# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 34 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-06 15:40' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 db 74			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd e8 74				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 7f 77			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 24 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 39 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd ba 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd c0 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd 14 75			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd 5f 78		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd 4e 78				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd 5f 78				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 23 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0d 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 5b 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 36 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 49 1b			dw prom_c2 
157f 5f 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d6 1b			dw prom_m4 
1583 f1 1b			dw prom_m4b 
1585 f9 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 08 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1d 1c			ld hl, prom_notav 
15bc 11 33 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1d 1c			ld hl, prom_notav 
15c7 11 33 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 32 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 08			cp 8 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 c0 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b4 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 76 1b			ld hl, crs_s1 
161a 11 ca 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 ce 16			ld de, .edworddef 
1624 21 7f 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d6 16			ld de, .demoworddef 
162e 21 88 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 94 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 9b 1b			ld hl, crs_s5 
1642 11 f8 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a5 1b			ld hl, crs_s6 
164c 11 06 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd ba 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 9e 6a			dw test5 
1698 d6 6a			dw test6 
169a 0e 6b			dw test7 
169c 22 6b			dw test8 
169e 4e 6b			dw test9 
16a0 64 6b			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 89 6b			dw sound1 
16a6 ad 6b			dw sound2 
16a8 dd 6b			dw sound3 
16aa 02 6c			dw sound4 
16ac 0f 6c			dw sound5 
16ae 1c 6c			dw sound6 
16b0 29 6c			dw sound7 
16b2 36 6c			dw sound8 
16b4 4e 6c			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 c4 68			dw strncpy 
16ba 9f 68			dw type 
16bc 21 6a			dw tuck 
16be 6b 68			dw clrstack 
16c0 24 68			dw longread 
16c2 25 69			dw start1 
16c4 35 69			dw start2 
16c6			; duplicated 
16c6			;	dw start3b 
16c6			;	dw start3c 
16c6 34 6a			dw list 
16c8 00 00			dw 0 
16ca			 
16ca			.lsworddef: 
16ca 46 69			dw start3b 
16cc 00 00			dw 0 
16ce			 
16ce			.edworddef: 
16ce 83 64			dw edit1 
16d0 a4 64			dw edit2 
16d2 d9 64			dw edit3 
16d4 00 00			dw 0 
16d6			 
16d6			.demoworddef: 
16d6 65 6c			dw game1 
16d8 76 6c			dw game1a 
16da d8 6c			dw game1b 
16dc 0d 6d			dw game1c 
16de 43 6d			dw game1d 
16e0 74 6d			dw game1s 
16e2 88 6d			dw game1t 
16e4 9d 6d			dw game1f 
16e6 d1 6d			dw game1z 
16e8 15 6e			dw game1zz 
16ea 7e 6e			dw ssv2 
16ec b4 6e			dw ssv3 
16ee d0 6e			dw ssv4 
16f0 ec 6e			dw ssv5 
16f2 05 6f			dw ssv1 
16f4 4d 6f			dw ssv1cpm	 
16f6			;	dw game2b 
16f6			;	dw game2bf 
16f6			;	dw game2mba 
16f6			;	dw game2mbas	 
16f6			;	dw game2mbht 
16f6			;	dw game2mbms 
16f6			;	dw game2mb 
16f6			;	dw game3w 
16f6			;	dw game3p 
16f6			;	dw game3sc 
16f6			;	dw game3vsi 
16f6			;	dw game3vs 
16f6 00 00			dw 0 
16f8			 
16f8			 
16f8			.spiworddef: 
16f8			 
16f8 11 65		    dw spi1 
16fa 6a 65		    dw spi2 
16fc 9e 65		    dw spi2b 
16fe 22 66		    dw spi3 
1700 cc 65		    dw spi4 
1702 f5 65		    dw spi5 
1704			;    dw spi6 
1704			;    dw spi7 
1704			 
1704			;    dw spi8 
1704			;    dw spi9 
1704			;    dw spi10 
1704 00 00		    dw 0 
1706			 
1706			.keyworddef: 
1706			 
1706 a4 6f			dw keyup 
1708 b2 6f			dw keydown 
170a c2 6f			dw keyleft 
170c d2 6f			dw keyright 
170e e3 6f			dw 	keyf1 
1710 f1 6f			dw keyf2 
1712 ff 6f			dw keyf3 
1714 0d 70			dw keyf4 
1716 1b 70			dw keyf5 
1718 29 70			dw keyf6 
171a 37 70			dw keyf7 
171c 45 70			dw keyf8 
171e 53 70			dw keyf9 
1720 61 70			dw keyf10 
1722 70 70			dw keyf11 
1724 7f 70			dw keyf12 
1726 8e 70			dw keytab 
1728 9d 70			dw keycr 
172a ab 70			dw keyhome 
172c bb 70			dw keyend 
172e ca 70			dw keybs 
1730 00 00			dw 0 
1732			 
1732			.crstart: 
1732 76 1b			dw crs_s1 
1734 7f 1b			dw crs_s2 
1736 88 1b			dw crs_s3 
1738 94 1b			dw crs_s4 
173a 9b 1b			dw crs_s5 
173c a5 1b			dw crs_s6 
173e b4 1b			dw crs_sound 
1740 c0 1b			dw crs_hw 
1742 00 00			dw 0 
1744			 
1744			endif 
1744			 
1744			 
1744			if STORAGE_SE 
1744			 
1744			config_fdir: 
1744				; using the scratch dir go through and release the memory allocated for each string 
1744				 
1744 21 f6 f0			ld hl, scratch 
1747 5e			.cfdir:	ld e,(hl) 
1748 23				inc hl 
1749 56				ld d,(hl) 
174a 23				inc hl 
174b			 
174b eb				ex de, hl 
174c cd 07 10			call ishlzero 
174f c8				ret z     ; return on null pointer 
1750 cd 83 14			call free 
1753 eb				ex de, hl 
1754 18 f1			jr .cfdir 
1756			 
1756			 
1756 c9				ret 
1757			 
1757			 
1757			config_dir: 
1757			 
1757				; for the config menus that need to build a directory of storage call this routine 
1757				; it will construct a menu in scratch to pass to menu 
1757			 
1757				; open storage device 
1757			 
1757				; execute DIR to build a list of files and their ids into scratch in menu format 
1757				; once the menu has finished then will need to call config_fdir to release the strings 
1757				 
1757				; c = number items 
1757			 
1757				 
1757 cd 25 05			call storage_get_block_0 
175a			 
175a 21 af f9			ld hl, store_page     ; get current id count 
175d 46				ld b, (hl) 
175e 0e 00			ld c, 0    ; count of files   
1760			 
1760			 
1760 21 f6 f0			ld hl, scratch 
1763 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1766			 
1766				; check for empty drive 
1766			 
1766 3e 00			ld a, 0 
1768 b8				cp b 
1769 ca 03 18			jp z, .dirdone 
176c			 
176c				 
176c					if DEBUG_FORTH_WORDS 
176c						DMARK "Cdc" 
176c f5				push af  
176d 3a 81 17			ld a, (.dmark)  
1770 32 a0 fd			ld (debug_mark),a  
1773 3a 82 17			ld a, (.dmark+1)  
1776 32 a1 fd			ld (debug_mark+1),a  
1779 3a 83 17			ld a, (.dmark+2)  
177c 32 a2 fd			ld (debug_mark+2),a  
177f 18 03			jr .pastdmark  
1781 ..			.dmark: db "Cdc"  
1784 f1			.pastdmark: pop af  
1785			endm  
# End of macro DMARK
1785						CALLMONITOR 
1785 cd aa fd			call debug_vector  
1788				endm  
# End of macro CALLMONITOR
1788					endif 
1788			 
1788			 
1788			.diritem:	 
1788 c5				push bc 
1789				; for each of the current ids do a search for them and if found push to stack 
1789			 
1789 21 40 00				ld hl, STORE_BLOCK_PHY 
178c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178e 58					ld e,b 
178f			 
178f cd a7 07				call storage_findnextid 
1792			 
1792			 
1792					; if found hl will be non zero 
1792			 
1792 cd 07 10				call ishlzero 
1795 28 69				jr z, .dirnotfound 
1797			 
1797					; increase count 
1797			 
1797 c1					pop bc	 
1798 0c					inc c 
1799 c5					push bc 
179a					 
179a			 
179a					; get file header and push the file name 
179a			 
179a 11 af f9				ld de, store_page 
179d cd 74 04				call storage_read_block 
17a0			 
17a0					; push file id to stack 
17a0				 
17a0 3a af f9				ld a, (store_page) 
17a3 26 00				ld h, 0 
17a5 6f					ld l, a 
17a6			 
17a6					;call forth_push_numhl 
17a6					; TODO store id 
17a6			 
17a6 e5					push hl 
17a7			 
17a7					; push extent count to stack  
17a7				 
17a7 21 b2 f9				ld hl, store_page+3 
17aa			 
17aa					; get file name length 
17aa			 
17aa cd 44 13				call strlenz   
17ad			 
17ad 23					inc hl   ; cover zero term 
17ae 23					inc hl  ; stick the id at the end of the area 
17af			 
17af e5					push hl 
17b0 c1					pop bc    ; move length to bc 
17b1			 
17b1 cd b9 13				call malloc 
17b4			 
17b4					; TODO save malloc area to scratch 
17b4			 
17b4 eb					ex de, hl 
17b5 2a a6 f9				ld hl, (store_tmp2) 
17b8 73					ld (hl), e 
17b9 23					inc hl 
17ba 72					ld (hl), d 
17bb 23					inc hl 
17bc 22 a6 f9				ld (store_tmp2), hl 
17bf			 
17bf					 
17bf			 
17bf					;pop hl   ; get source 
17bf			;		ex de, hl    ; swap aronund	 
17bf			 
17bf 21 b2 f9				ld hl, store_page+3 
17c2					if DEBUG_FORTH_WORDS 
17c2						DMARK "CFd" 
17c2 f5				push af  
17c3 3a d7 17			ld a, (.dmark)  
17c6 32 a0 fd			ld (debug_mark),a  
17c9 3a d8 17			ld a, (.dmark+1)  
17cc 32 a1 fd			ld (debug_mark+1),a  
17cf 3a d9 17			ld a, (.dmark+2)  
17d2 32 a2 fd			ld (debug_mark+2),a  
17d5 18 03			jr .pastdmark  
17d7 ..			.dmark: db "CFd"  
17da f1			.pastdmark: pop af  
17db			endm  
# End of macro DMARK
17db						CALLMONITOR 
17db cd aa fd			call debug_vector  
17de				endm  
# End of macro CALLMONITOR
17de					endif 
17de ed b0				ldir 
17e0			 
17e0					; de is past string, move back one and store id 
17e0					 
17e0 1b					dec de 
17e1			 
17e1					; store file id 
17e1			 
17e1 e1					pop hl 
17e2 eb					ex de,hl 
17e3 73					ld (hl), e 
17e4			 
17e4					if DEBUG_FORTH_WORDS 
17e4						DMARK "Cdi" 
17e4 f5				push af  
17e5 3a f9 17			ld a, (.dmark)  
17e8 32 a0 fd			ld (debug_mark),a  
17eb 3a fa 17			ld a, (.dmark+1)  
17ee 32 a1 fd			ld (debug_mark+1),a  
17f1 3a fb 17			ld a, (.dmark+2)  
17f4 32 a2 fd			ld (debug_mark+2),a  
17f7 18 03			jr .pastdmark  
17f9 ..			.dmark: db "Cdi"  
17fc f1			.pastdmark: pop af  
17fd			endm  
# End of macro DMARK
17fd						CALLMONITOR 
17fd cd aa fd			call debug_vector  
1800				endm  
# End of macro CALLMONITOR
1800					endif 
1800					 
1800			.dirnotfound: 
1800 c1					pop bc     
1801 10 85				djnz .diritem 
1803				 
1803			.dirdone:	 
1803			 
1803 3e 00				ld a, 0 
1805 2a a6 f9				ld hl, (store_tmp2) 
1808 77					ld (hl), a 
1809 23					inc hl 
180a 77					ld (hl), a 
180b 23					inc hl 
180c					; push a count of the dir items found 
180c			 
180c			;		ld h, 0 
180c			;		ld l, c 
180c			 
180c c9				ret 
180d			 
180d			endif 
180d			 
180d			 
180d			; Settings 
180d			; Run  
180d			 
180d			 
180d			 
180d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180d			;;hd_menu2:   db "        2: Editor",0   
180d			;hd_menu2:   db "        2: Editor       6: Menu",0   
180d			;hd_menu3:   db "        3: Storage",0 
180d			;hd_menu4:   db "0=quit  4: Debug",0 
180d			;hd_don:     db "ON",0 
180d			;hd_doff:     db "OFF",0 
180d			; 
180d			; 
180d			; 
180d			;hardware_diags_old:       
180d			; 
180d			;.diagmenu: 
180d			;	call clear_display 
180d			;	ld a, display_row_1 
180d			;	ld de, hd_menu1 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_2 
180d			;	ld de, hd_menu2 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_3 
180d			;	ld de, hd_menu3 
180d			;	call str_at_display 
180d			; 
180d			;	ld a,  display_row_4 
180d			;	ld de, hd_menu4 
180d			;	call str_at_display 
180d			; 
180d			;	; display debug state 
180d			; 
180d			;	ld de, hd_don 
180d			;	ld a, (os_view_disable) 
180d			;	cp 0 
180d			;	jr z, .distog 
180d			;	ld de, hd_doff 
180d			;.distog: ld a, display_row_4+17 
180d			;	call str_at_display 
180d			; 
180d			;	call update_display 
180d			; 
180d			;	call cin_wait 
180d			; 
180d			; 
180d			; 
180d			;	cp '4' 
180d			;	jr nz, .diagn1 
180d			; 
180d			;	; debug toggle 
180d			; 
180d			;	ld a, (os_view_disable) 
180d			;	ld b, '*' 
180d			;	cp 0 
180d			;	jr z, .debtog 
180d			;	ld b, 0 
180d			;.debtog:	 
180d			;	ld a,b 
180d			;	ld (os_view_disable),a 
180d			; 
180d			;.diagn1: cp '0' 
180d			;	 ret z 
180d			; 
180d			;;	cp '1' 
180d			;;       jp z, matrix	 
180d			;;   TODO keyboard matrix test 
180d			; 
180d			;	cp '2' 
180d			;	jp z, .diagedit 
180d			; 
180d			;;	cp '6' 
180d			;;	jp z, .menutest 
180d			;;if ENABLE_BASIC 
180d			;;	cp '6' 
180d			;;	jp z, basic 
180d			;;endif 
180d			 ; 
180d			;	jp .diagmenu 
180d			; 
180d			; 
180d			;	ret 
180d			 
180d			 
180d			.debug_tog: 
180d 21 57 18			ld hl, .menudebug 
1810				 
1810			;	ld a, (os_view_disable) 
1810			;	cp '*' 
1810 3a aa fd			ld a,(debug_vector) 
1813 fe c9			cp $C9   ; RET 
1815 20 04			jr nz,.tdon  
1817 3e 01			ld a, 1 
1819 18 02			jr .tog1 
181b 3e 00		.tdon: ld a, 0 
181d			 
181d			.tog1: 
181d cd db 0d			call menu 
1820 fe 00			cp 0 
1822 c8				ret z 
1823 fe 01			cp 1    ; disable debug 
1825 28 04			jr z, .dtog0 
1827 3e 2a			ld a, '*' 
1829 18 05			jr .dtogset 
182b			.dtog0:  
182b				;ld a, 0 
182b cd 49 19			call bp_on 
182e 18 dd			jr .debug_tog 
1830			.dtogset:  
1830				; ld (os_view_disable), a 
1830 cd 55 19			call bp_off 
1833 c3 0d 18			jp .debug_tog 
1836			 
1836			 
1836			hardware_diags:       
1836			 
1836			.diagm: 
1836 21 49 18			ld hl, .menuitems 
1839 3e 00			ld a, 0 
183b cd db 0d			call menu 
183e			 
183e fe 00		         cp 0 
1840 c8				 ret z 
1841			 
1841 fe 02			cp 2 
1843 ca a2 18			jp z, .diagedit 
1846			 
1846			;	cp '6' 
1846			;	jp z, .menutest 
1846			;if ENABLE_BASIC 
1846			;	cp '6' 
1846			;	jp z, basic 
1846			;endif 
1846			  
1846 c3 36 18			jp .diagm 
1849			 
1849				 
1849 5d 18		.menuitems:   	dw .m1 
184b 68 18				dw .m2 
184d 6f 18				dw .m3 
184f 77 18				dw .m5 
1851 7d 18				dw .m5a 
1853 86 18				dw .m5b 
1855 00 00				dw 0 
1857			 
1857			.menudebug: 
1857 8f 18				dw .m6 
1859 98 18				dw .m7 
185b 00 00				dw 0 
185d			 
185d .. 00		.m1:   db "Key Matrix",0 
1868 .. 00		.m2:   db "Editor",0 
186f .. 00		.m3:   db "Storage",0 
1877 .. 00		.m5:   db "Sound",0 
187d .. 00		.m5a:  db "RAM Test",0 
1886 .. 00		.m5b:  db "LCD Test",0 
188f			 
188f .. 00		.m6:   db "Debug ON",0 
1898 .. 00		.m7:   db "Debug OFF",0 
18a2			 
18a2			; debug editor 
18a2			 
18a2			.diagedit: 
18a2			 
18a2 21 f6 f0			ld hl, scratch 
18a5			;	ld bc, 250 
18a5			;	ldir 
18a5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a5 3e 00			ld a, 0 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa 23				inc hl 
18ab 77				ld (hl), a 
18ac			 
18ac cd aa 0d		        call clear_display 
18af cd cd 0d			call update_display 
18b2				;ld a, 1 
18b2				;ld (hardware_diag), a 
18b2			.diloop: 
18b2 3e 00			ld a, display_row_1 
18b4 0e 00			ld c, 0 
18b6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b8 1e 28			ld e, 40 
18ba			 
18ba 21 f6 f0			ld hl, scratch	 
18bd cd 0b 10			call input_str 
18c0			 
18c0 3e 28			ld a, display_row_2 
18c2 11 f6 f0			ld de, scratch 
18c5 cd bd 0d			call str_at_display 
18c8 cd cd 0d			call update_display 
18cb			 
18cb c3 b2 18			jp .diloop 
18ce			 
18ce			 
18ce			; pass word in hl 
18ce			; a has display location 
18ce			display_word_at: 
18ce f5				push af 
18cf e5				push hl 
18d0 7c				ld a,h 
18d1 21 fb f3			ld hl, os_word_scratch 
18d4 cd e7 11			call hexout 
18d7 e1				pop hl 
18d8 7d				ld a,l 
18d9 21 fd f3			ld hl, os_word_scratch+2 
18dc cd e7 11			call hexout 
18df 21 ff f3			ld hl, os_word_scratch+4 
18e2 3e 00			ld a,0 
18e4 77				ld (hl),a 
18e5 11 fb f3			ld de,os_word_scratch 
18e8 f1				pop af 
18e9 cd bd 0d				call str_at_display 
18ec c9				ret 
18ed			 
18ed			display_ptr_state: 
18ed			 
18ed				; to restore afterwards 
18ed			 
18ed d5				push de 
18ee c5				push bc 
18ef e5				push hl 
18f0 f5				push af 
18f1			 
18f1				; for use in here 
18f1			 
18f1			;	push bc 
18f1			;	push de 
18f1			;	push hl 
18f1			;	push af 
18f1			 
18f1 cd aa 0d			call clear_display 
18f4			 
18f4 11 cc 1a			ld de, .ptrstate 
18f7 3e 00			ld a, display_row_1 
18f9 cd bd 0d			call str_at_display 
18fc			 
18fc				; display debug step 
18fc			 
18fc			 
18fc 11 a0 fd			ld de, debug_mark 
18ff 3e 26			ld a, display_row_1+display_cols-2 
1901 cd bd 0d			call str_at_display 
1904			 
1904				; display a 
1904 11 d6 1a			ld de, .ptrcliptr 
1907 3e 28			ld a, display_row_2 
1909 cd bd 0d			call str_at_display 
190c			 
190c f1				pop af 
190d 2a 75 f9			ld hl,(cli_ptr) 
1910 3e 30			ld a, display_row_2+8 
1912 cd ce 18			call display_word_at 
1915			 
1915			 
1915				; display hl 
1915			 
1915			 
1915 11 de 1a			ld de, .ptrclioptr 
1918 3e 32			ld a, display_row_2+10 
191a cd bd 0d			call str_at_display 
191d			; 
191d			;	pop hl 
191d 3e 35			ld a, display_row_2+13 
191f 2a 73 f9			ld hl,(cli_origptr) 
1922 cd ce 18			call display_word_at 
1925			; 
1925			;	 
1925			;	; display de 
1925			 
1925			;	ld de, .regstatede 
1925			;	ld a, display_row_3 
1925			;	call str_at_display 
1925			 
1925			;	pop de 
1925			;	ld h,d 
1925			;	ld l, e 
1925			;	ld a, display_row_3+3 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display bc 
1925			 
1925			;	ld de, .regstatebc 
1925			;	ld a, display_row_3+10 
1925			;	call str_at_display 
1925			 
1925			;	pop bc 
1925			;	ld h,b 
1925			;	ld l, c 
1925			;	ld a, display_row_3+13 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display dsp 
1925			 
1925			;	ld de, .regstatedsp 
1925			;	ld a, display_row_4 
1925			;	call str_at_display 
1925			 
1925				 
1925			;	ld hl,(cli_data_sp) 
1925			;	ld a, display_row_4+4 
1925			;	call display_word_at 
1925			 
1925				; display rsp 
1925			 
1925 11 0d 1b			ld de, .regstatersp 
1928 3e 82			ld a, display_row_4+10 
192a cd bd 0d			call str_at_display 
192d			 
192d				 
192d 2a 27 f9			ld hl,(cli_ret_sp) 
1930 3e 86			ld a, display_row_4+14 
1932 cd ce 18			call display_word_at 
1935			 
1935 cd cd 0d			call update_display 
1938			 
1938 cd ed 0c			call delay1s 
193b cd ed 0c			call delay1s 
193e cd ed 0c			call delay1s 
1941			 
1941			 
1941 cd c0 1f			call next_page_prompt 
1944			 
1944				; restore  
1944			 
1944 f1				pop af 
1945 e1				pop hl 
1946 c1				pop bc 
1947 d1				pop de 
1948 c9				ret 
1949			 
1949			; Update the break point vector so that the user can hook a new routine 
1949			 
1949			bp_on: 
1949 3e c3			ld a, $c3    ; JP 
194b 32 aa fd			ld (debug_vector), a 
194e 21 5b 19			ld hl, break_point_state 
1951 22 ab fd			ld (debug_vector+1), hl 
1954 c9				ret 
1955			 
1955			bp_off: 
1955 3e c9			ld a, $c9    ; RET 
1957 32 aa fd			ld (debug_vector), a 
195a c9				ret 
195b			 
195b			 
195b			break_point_state: 
195b			;	push af 
195b			; 
195b			;	; see if disabled 
195b			; 
195b			;	ld a, (os_view_disable) 
195b			;	cp '*' 
195b			;	jr nz, .bpsgo 
195b			;	pop af 
195b			;	ret 
195b			 
195b			.bpsgo: 
195b			;	pop af 
195b f5				push af 
195c 22 d8 f0			ld (os_view_hl), hl 
195f ed 53 d6 f0		ld (os_view_de), de 
1963 ed 43 d4 f0		ld (os_view_bc), bc 
1967 e5				push hl 
1968 6f				ld l, a 
1969 26 00			ld h, 0 
196b 22 da f0			ld (os_view_af),hl 
196e			 
196e 21 e6 fc				ld hl, display_fb0 
1971 22 01 fb				ld (display_fb_active), hl 
1974 e1				pop hl	 
1975			 
1975 3e 31			ld a, '1' 
1977 fe 2a		.bps1:  cp '*' 
1979 cc 55 19			call z, bp_off 
197c			;	jr nz, .bps1b 
197c			;	ld (os_view_disable),a 
197c fe 31		.bps1b:  cp '1' 
197e 20 14			jr nz, .bps2 
1980			 
1980				; display reg 
1980			 
1980				 
1980			 
1980 3a da f0			ld a, (os_view_af) 
1983 2a d8 f0			ld hl, (os_view_hl) 
1986 ed 5b d6 f0		ld de, (os_view_de) 
198a ed 4b d4 f0		ld bc, (os_view_bc) 
198e cd 28 1a			call display_reg_state 
1991 c3 14 1a			jp .bpschk 
1994			 
1994 fe 32		.bps2:  cp '2' 
1996 20 08			jr nz, .bps3 
1998				 
1998				; display hl 
1998 2a d8 f0			ld hl, (os_view_hl) 
199b cd 12 1b			call display_dump_at_hl 
199e			 
199e 18 74			jr .bpschk 
19a0			 
19a0 fe 33		.bps3:  cp '3' 
19a2 20 08			jr nz, .bps4 
19a4			 
19a4			        ; display de 
19a4 2a d6 f0			ld hl, (os_view_de) 
19a7 cd 12 1b			call display_dump_at_hl 
19aa			 
19aa 18 68			jr .bpschk 
19ac fe 34		.bps4:  cp '4' 
19ae 20 08			jr nz, .bps5 
19b0			 
19b0			        ; display bc 
19b0 2a d4 f0			ld hl, (os_view_bc) 
19b3 cd 12 1b			call display_dump_at_hl 
19b6			 
19b6 18 5c			jr .bpschk 
19b8 fe 35		.bps5:  cp '5' 
19ba 20 08		        jr nz, .bps7 
19bc			 
19bc				; display cur ptr 
19bc 2a 75 f9			ld hl, (cli_ptr) 
19bf cd 12 1b			call display_dump_at_hl 
19c2			 
19c2 18 50			jr .bpschk 
19c4 fe 36		.bps7:  cp '6' 
19c6 20 08			jr nz, .bps8b 
19c8				 
19c8				; display cur orig ptr 
19c8 2a 73 f9			ld hl, (cli_origptr) 
19cb cd 12 1b			call display_dump_at_hl 
19ce 18 44			jr .bpschk 
19d0 fe 37		.bps8b:  cp '7' 
19d2 20 08			jr nz, .bps9 
19d4				 
19d4				; display dsp 
19d4 2a 23 f9			ld hl, (cli_data_sp) 
19d7 cd 12 1b			call display_dump_at_hl 
19da			 
19da 18 38			jr .bpschk 
19dc fe 39		.bps9:  cp '9' 
19de 20 05			jr nz, .bps8c 
19e0				 
19e0				; display SP 
19e0			;	ld hl, sp 
19e0 cd 12 1b			call display_dump_at_hl 
19e3			 
19e3 18 2f			jr .bpschk 
19e5 fe 38		.bps8c:  cp '8' 
19e7 20 08			jr nz, .bps8d 
19e9				 
19e9				; display rsp 
19e9 2a 27 f9			ld hl, (cli_ret_sp) 
19ec cd 12 1b			call display_dump_at_hl 
19ef			 
19ef 18 23			jr .bpschk 
19f1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f3 20 05			jr nz, .bps8 
19f5 cd 7a 1d			call monitor 
19f8			 
19f8 18 1a			jr .bpschk 
19fa fe 30		.bps8:  cp '0' 
19fc 20 16			jr nz, .bpschk 
19fe			 
19fe 21 45 fc				ld hl, display_fb1 
1a01 22 01 fb				ld (display_fb_active), hl 
1a04 cd cd 0d				call update_display 
1a07			 
1a07				;ld a, (os_view_af) 
1a07 2a d8 f0			ld hl, (os_view_hl) 
1a0a ed 5b d6 f0		ld de, (os_view_de) 
1a0e ed 4b d4 f0		ld bc, (os_view_bc) 
1a12 f1				pop af 
1a13 c9				ret 
1a14			 
1a14			.bpschk:   
1a14 cd ed 0c			call delay1s 
1a17 3e 9f		ld a,display_row_4 + display_cols - 1 
1a19 11 be 1f		        ld de, endprg 
1a1c cd bd 0d			call str_at_display 
1a1f cd cd 0d			call update_display 
1a22 cd 4e 78			call cin_wait 
1a25			 
1a25 c3 77 19			jp .bps1 
1a28			 
1a28			 
1a28			display_reg_state: 
1a28			 
1a28				; to restore afterwards 
1a28			 
1a28 d5				push de 
1a29 c5				push bc 
1a2a e5				push hl 
1a2b f5				push af 
1a2c			 
1a2c				; for use in here 
1a2c			 
1a2c c5				push bc 
1a2d d5				push de 
1a2e e5				push hl 
1a2f f5				push af 
1a30			 
1a30 cd aa 0d			call clear_display 
1a33			 
1a33 11 e8 1a			ld de, .regstate 
1a36 3e 00			ld a, display_row_1 
1a38 cd bd 0d			call str_at_display 
1a3b			 
1a3b				; display debug step 
1a3b			 
1a3b			 
1a3b 11 a0 fd			ld de, debug_mark 
1a3e 3e 25			ld a, display_row_1+display_cols-3 
1a40 cd bd 0d			call str_at_display 
1a43			 
1a43				; display a 
1a43 11 04 1b			ld de, .regstatea 
1a46 3e 28			ld a, display_row_2 
1a48 cd bd 0d			call str_at_display 
1a4b			 
1a4b e1				pop hl 
1a4c			;	ld h,0 
1a4c			;	ld l, a 
1a4c 3e 2b			ld a, display_row_2+3 
1a4e cd ce 18			call display_word_at 
1a51			 
1a51			 
1a51				; display hl 
1a51			 
1a51			 
1a51 11 f8 1a			ld de, .regstatehl 
1a54 3e 32			ld a, display_row_2+10 
1a56 cd bd 0d			call str_at_display 
1a59			 
1a59 e1				pop hl 
1a5a 3e 35			ld a, display_row_2+13 
1a5c cd ce 18			call display_word_at 
1a5f			 
1a5f				 
1a5f				; display de 
1a5f			 
1a5f 11 fc 1a			ld de, .regstatede 
1a62 3e 50			ld a, display_row_3 
1a64 cd bd 0d			call str_at_display 
1a67			 
1a67 e1				pop hl 
1a68			;	ld h,d 
1a68			;	ld l, e 
1a68 3e 53			ld a, display_row_3+3 
1a6a cd ce 18			call display_word_at 
1a6d			 
1a6d			 
1a6d				; display bc 
1a6d			 
1a6d 11 00 1b			ld de, .regstatebc 
1a70 3e 5a			ld a, display_row_3+10 
1a72 cd bd 0d			call str_at_display 
1a75			 
1a75 e1				pop hl 
1a76			;	ld h,b 
1a76			;	ld l, c 
1a76 3e 5d			ld a, display_row_3+13 
1a78 cd ce 18			call display_word_at 
1a7b			 
1a7b			 
1a7b				; display dsp 
1a7b			 
1a7b 11 08 1b			ld de, .regstatedsp 
1a7e 3e 78			ld a, display_row_4 
1a80 cd bd 0d			call str_at_display 
1a83			 
1a83				 
1a83 2a 23 f9			ld hl,(cli_data_sp) 
1a86 3e 7c			ld a, display_row_4+4 
1a88 cd ce 18			call display_word_at 
1a8b			 
1a8b				; display rsp 
1a8b			 
1a8b 11 0d 1b			ld de, .regstatersp 
1a8e 3e 82			ld a, display_row_4+10 
1a90 cd bd 0d			call str_at_display 
1a93			 
1a93				 
1a93 2a 27 f9			ld hl,(cli_ret_sp) 
1a96 3e 86			ld a, display_row_4+14 
1a98 cd ce 18			call display_word_at 
1a9b			 
1a9b cd cd 0d			call update_display 
1a9e			 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			 
1a9e			 
1a9e			;	call next_page_prompt 
1a9e			 
1a9e				; restore  
1a9e			 
1a9e f1				pop af 
1a9f e1				pop hl 
1aa0 c1				pop bc 
1aa1 d1				pop de 
1aa2 c9				ret 
1aa3			 
1aa3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1acc .. 00		.ptrstate:	db "Ptr State",0 
1ad6 .. 00		.ptrcliptr:     db "cli_ptr",0 
1ade .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae8 .. 00		.regstate:	db "Reg State (1/0)",0 
1af8 .. 00		.regstatehl:	db "HL:",0 
1afc .. 00		.regstatede:	db "DE:",0 
1b00 .. 00		.regstatebc:	db "BC:",0 
1b04 .. 00		.regstatea:	db "A :",0 
1b08 .. 00		.regstatedsp:	db "DSP:",0 
1b0d .. 00		.regstatersp:	db "RSP:",0 
1b12			 
1b12			display_dump_at_hl: 
1b12 e5				push hl 
1b13 d5				push de 
1b14 c5				push bc 
1b15 f5				push af 
1b16			 
1b16 22 19 f4			ld (os_cur_ptr),hl	 
1b19 cd aa 0d			call clear_display 
1b1c cd c8 1e			call dumpcont 
1b1f			;	call delay1s 
1b1f			;	call next_page_prompt 
1b1f			 
1b1f			 
1b1f f1				pop af 
1b20 c1				pop bc 
1b21 d1				pop de 
1b22 e1				pop hl 
1b23 c9				ret 
1b24			 
1b24			;if ENABLE_BASIC 
1b24			;	include "nascombasic.asm" 
1b24			;	basic: 
1b24			;	include "forth/FORTH.ASM" 
1b24			;endif 
1b24			 
1b24			; eof 
1b24			 
1b24			 
# End of file firmware_diags.asm
1b24			  
1b24			include "firmware_prompts.asm"  
1b24			; Prompts  
1b24			 
1b24			; boot messages 
1b24			 
1b24 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b39 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b49			 
1b49			 
1b49			; config menus 
1b49			 
1b49			;prom_c3: db "Add Dictionary To File",0 
1b49			 
1b49			if STARTUP_V1 
1b49			prom_c2: db "Select Autoload File",0 
1b49			prom_c2a: db "Disable Autoload File", 0 
1b49			endif 
1b49			 
1b49			if STARTUP_V2 
1b49 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5f .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b76			 
1b76 .. 00		crs_s1: db "*ls-word", 0 
1b7f .. 00		crs_s2: db "*ed-word", 0 
1b88 .. 00		crs_s3: db "*Demo-Games", 0 
1b94 .. 00		crs_s4: db "*Utils", 0 
1b9b .. 00		crs_s5: db "*SPI-Util", 0 
1ba5 .. 00		crs_s6: db "*Key-Constants", 0 
1bb4 .. 00		crs_sound: db "*Sound-Util", 0 
1bc0 .. 00		crs_hw: db "*Hello-World",0 
1bcd			 
1bcd			 
1bcd			 
1bcd			endif 
1bcd			;prom_c2b: db "Select Storage Bank",0 
1bcd .. 00		prom_c4: db "Settings",0 
1bd6 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bf1 .. 00		prom_m4b:   db "Monitor",0 
1bf9 .. 00		prom_c1: db "Hardware Diags",0 
1c08			 
1c08			 
1c08			if STARTUP_V2 
1c08 .. 00		prom_c9: db "Create Startup Files",0 
1c1d			endif 
1c1d			 
1c1d .. 00		prom_notav:    db "Feature not available",0 
1c33 .. 00		prom_empty:    db "",0 
1c34			 
1c34			; eof 
1c34			 
# End of file firmware_prompts.asm
1c34			  
1c34			; eof  
1c34			  
# End of file firmware.asm
1c34			 
1c34			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c34			;if BASE_KEV  
1c34			;baseram: equ 08000h 
1c34			;endif 
1c34			 
1c34			;if BASE_SC114 
1c34			;baseram:     equ    endofcode 
1c34			;endif 
1c34			 
1c34			 
1c34			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c34			 
1c34			; start system 
1c34			 
1c34			coldstart: 
1c34				; set sp 
1c34				; di/ei 
1c34			 
1c34 f3				di 
1c35 31 fd ff			ld sp, tos 
1c38 cd d5 74			call init_nmi 
1c3b			;	ei 
1c3b			 
1c3b				; init spinner 
1c3b 3e 00			ld a,0 
1c3d 32 fb fa			ld (display_active), a 
1c40			 
1c40				; disable breakpoint by default 
1c40			 
1c40				;ld a,'*' 
1c40			;	ld a,' ' 
1c40			;	ld (os_view_disable),a 
1c40			 
1c40				; set break point vector as new break point on or off 
1c40 cd 55 19			call bp_off 
1c43			 
1c43				; init hardware 
1c43			 
1c43				; init keyboard and screen hardware 
1c43			 
1c43 cd 6c 00			call hardware_init 
1c46			 
1c46			 
1c46 cd ed 0c			call delay1s 
1c49 3e 58			ld a, display_row_3+8 
1c4b 11 03 00			ld de, buildtime 
1c4e cd bd 0d			call str_at_display 
1c51 cd cd 0d			call update_display 
1c54			 
1c54 cd ed 0c			call delay1s 
1c57 cd ed 0c			call delay1s 
1c5a cd ed 0c			call delay1s 
1c5d			 
1c5d				; detect if any keys are held down to enable breakpoints at start up 
1c5d			 
1c5d cd 5f 78			call cin  
1c60 fe 00			cp 0 
1c62 28 03			jr z, .nokeys 
1c64			 
1c64				;call hardware_diags 
1c64 cd 52 15			call config 
1c67			 
1c67			;	ld de, .bpen 
1c67			;	ld a, display_row_4 
1c67			;	call str_at_display 
1c67			;	call update_display 
1c67			; 
1c67			;	ld a,0 
1c67			;	ld (os_view_disable),a 
1c67			; 
1c67			;.bpwait: 
1c67			;	call cin 
1c67			;	cp 0 
1c67			;	jr z, .bpwait 
1c67			;	jr .nokeys 
1c67			; 
1c67			; 
1c67			;.bpen:  db "Break points enabled!",0 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			.nokeys: 
1c67			 
1c67			 
1c67				 
1c67			 
1c67			;jp  testkey 
1c67			 
1c67			;call storage_get_block_0 
1c67			; 
1c67			;ld hl, 0 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67				 
1c67			;ld hl, 10 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			;stop:	nop 
1c67			;	jp stop 
1c67			 
1c67			 
1c67			 
1c67			main: 
1c67 cd aa 0d			call clear_display 
1c6a cd cd 0d			call update_display 
1c6d			 
1c6d			 
1c6d			 
1c6d			;	call testlcd 
1c6d			 
1c6d			 
1c6d			 
1c6d cd 08 24			call forth_init 
1c70			 
1c70			 
1c70			warmstart: 
1c70 cd de 23			call forth_warmstart 
1c73			 
1c73				; run startup word load 
1c73			        ; TODO prevent this running at warmstart after crash  
1c73			 
1c73				if STARTUP_ENABLE 
1c73			 
1c73					if STARTUP_V1 
1c73			 
1c73						if STORAGE_SE 
1c73							call forth_autoload 
1c73						endif 
1c73						call forth_startup 
1c73					endif 
1c73			 
1c73					if STARTUP_V2 
1c73			 
1c73						if STORAGE_SE 
1c73 cd 03 73						call forth_autoload 
1c76						else 
1c76							call forth_startup 
1c76						endif 
1c76			 
1c76			 
1c76					endif 
1c76			 
1c76				endif 
1c76			 
1c76			warmstart_afterauto: 
1c76			 
1c76				; show free memory after boot 
1c76 11 15 1d			ld de, freeram 
1c79 3e 00			ld a, display_row_1 
1c7b cd bd 0d			call str_at_display 
1c7e			 
1c7e				; get current heap start after loading any uwords 
1c7e			 
1c7e				;ld de, (os_last_new_uword) 
1c7e				;ex de, hl 
1c7e			 
1c7e			; Or use heap_size word???? 
1c7e				;ld hl, heap_end 
1c7e				;ld hl, heap_size 
1c7e				;ld de, topusermem 
1c7e				;ld de, heap_start 
1c7e ed 5b 0a 80			ld de, (free_list )      
1c82 21 d1 f0				ld hl, heap_end 
1c85 ed 52			sbc hl, de 
1c87				;push hl 
1c87				;ld a,h	         	 
1c87				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c87				;call hexout 
1c87			   	;pop hl 
1c87			; 
1c87			;	ld a,l 
1c87			;	ld hl, os_word_scratch+2 
1c87			;	call hexout 
1c87			;	ld hl, os_word_scratch+4 
1c87			;	ld a, 0 
1c87			;	ld (hl),a 
1c87 eb				ex de, hl 
1c88 21 fb f3			ld hl, os_word_scratch 
1c8b cd f3 12			call uitoa_16 
1c8e			 
1c8e			 
1c8e 11 fb f3			ld de, os_word_scratch 
1c91 3e 0d			ld a, display_row_1 + 13 
1c93 cd bd 0d			call str_at_display 
1c96 cd cd 0d			call update_display 
1c99			 
1c99			 
1c99				;call demo 
1c99			 
1c99			 
1c99				; init scratch input area for cli commands 
1c99			 
1c99 21 1d f4			ld hl, os_cli_cmd 
1c9c 3e 00			ld a,0 
1c9e 77				ld (hl),a 
1c9f 23				inc hl 
1ca0 77				ld (hl),a 
1ca1			 
1ca1 3e 00			ld a,0 
1ca3 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca6			 
1ca6 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca9 32 1a f4			ld (os_cur_ptr+1),a	 
1cac			 
1cac 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1caf 32 fc f3			ld (os_word_scratch+1),a	 
1cb2				 
1cb2			 
1cb2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb2 21 1d f4			ld hl, os_cli_cmd 
1cb5			 
1cb5 3e 00			ld a, 0		 ; init cli input 
1cb7 77				ld (hl), a 
1cb8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cba			cli: 
1cba				; show cli prompt 
1cba				;push af 
1cba				;ld a, 0 
1cba				;ld de, prompt 
1cba				;call str_at_display 
1cba			 
1cba				;call update_display 
1cba				;pop af 
1cba				;inc a 
1cba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cba			 
1cba			.lastrecall: 
1cba			 
1cba 0e 00			ld c, 0 
1cbc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbe 1e 28			ld e, 40 
1cc0			 
1cc0 21 1d f4			ld hl, os_cli_cmd 
1cc3			 
1cc3				STACKFRAME OFF $fefe $9f9f 
1cc3				if DEBUG_STACK_IMB 
1cc3					if OFF 
1cc3						exx 
1cc3						ld de, $fefe 
1cc3						ld a, d 
1cc3						ld hl, curframe 
1cc3						call hexout 
1cc3						ld a, e 
1cc3						ld hl, curframe+2 
1cc3						call hexout 
1cc3						ld hl, $fefe 
1cc3						push hl 
1cc3						ld hl, $9f9f 
1cc3						push hl 
1cc3						exx 
1cc3					endif 
1cc3				endif 
1cc3			endm 
# End of macro STACKFRAME
1cc3			 
1cc3 cd 0b 10			call input_str 
1cc6			 
1cc6				STACKFRAMECHK OFF $fefe $9f9f 
1cc6				if DEBUG_STACK_IMB 
1cc6					if OFF 
1cc6						exx 
1cc6						ld hl, $9f9f 
1cc6						pop de   ; $9f9f 
1cc6						call cmp16 
1cc6						jr nz, .spnosame 
1cc6						ld hl, $fefe 
1cc6						pop de   ; $fefe 
1cc6						call cmp16 
1cc6						jr z, .spfrsame 
1cc6						.spnosame: call showsperror 
1cc6						.spfrsame: nop 
1cc6						exx 
1cc6					endif 
1cc6				endif 
1cc6			endm 
# End of macro STACKFRAMECHK
1cc6			 
1cc6			 
1cc6				; check to see if last line recall has been requested 
1cc6			 
1cc6			if EDIT_V2 
1cc6 fe 05			cp KEY_UP 
1cc8 20 0f			jr nz, .noexecline 
1cca			 
1cca 11 1d f4			ld de, os_cli_cmd 
1ccd 21 1c f5			ld hl, os_last_cmd 
1cd0 01 ff 00			ld bc, 255 
1cd3 ed b0			ldir 
1cd5 3e 00			ld a, 0 
1cd7 18 e1			jr .lastrecall 
1cd9			endif 
1cd9			 
1cd9			.noexecline: 
1cd9				; no so exec the line		 
1cd9			 
1cd9				; copy input to last command 
1cd9			 
1cd9 21 1d f4			ld hl, os_cli_cmd 
1cdc 11 1c f5			ld de, os_last_cmd 
1cdf 01 ff 00			ld bc, 255 
1ce2 ed b0			ldir 
1ce4			 
1ce4				; wipe current buffer 
1ce4			 
1ce4			;	ld a, 0 
1ce4			;	ld hl, os_cli_cmd 
1ce4			;	ld de, os_cli_cmd+1 
1ce4			;	ld bc, 254 
1ce4			;	ldir 
1ce4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce4			;	call strcpy 
1ce4			;	ld a, 0 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			 
1ce4				; switch frame buffer to program  
1ce4			 
1ce4 21 45 fc				ld hl, display_fb1 
1ce7 22 01 fb				ld (display_fb_active), hl 
1cea			 
1cea			;	nop 
1cea				STACKFRAME ON $fbfe $8f9f 
1cea				if DEBUG_STACK_IMB 
1cea					if ON 
1cea						exx 
1cea						ld de, $fbfe 
1cea						ld a, d 
1cea						ld hl, curframe 
1cea						call hexout 
1cea						ld a, e 
1cea						ld hl, curframe+2 
1cea						call hexout 
1cea						ld hl, $fbfe 
1cea						push hl 
1cea						ld hl, $8f9f 
1cea						push hl 
1cea						exx 
1cea					endif 
1cea				endif 
1cea			endm 
# End of macro STACKFRAME
1cea				; first time into the parser so pass over the current scratch pad 
1cea 21 1d f4			ld hl,os_cli_cmd 
1ced				; tokenise the entered statement(s) in HL 
1ced cd 82 24			call forthparse 
1cf0			        ; exec forth statements in top of return stack 
1cf0 cd be 24			call forthexec 
1cf3				;call forthexec_cleanup 
1cf3			;	call parsenext 
1cf3			 
1cf3				STACKFRAMECHK ON $fbfe $8f9f 
1cf3				if DEBUG_STACK_IMB 
1cf3					if ON 
1cf3						exx 
1cf3						ld hl, $8f9f 
1cf3						pop de   ; $8f9f 
1cf3						call cmp16 
1cf3						jr nz, .spnosame 
1cf3						ld hl, $fbfe 
1cf3						pop de   ; $fbfe 
1cf3						call cmp16 
1cf3						jr z, .spfrsame 
1cf3						.spnosame: call showsperror 
1cf3						.spfrsame: nop 
1cf3						exx 
1cf3					endif 
1cf3				endif 
1cf3			endm 
# End of macro STACKFRAMECHK
1cf3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf3			 
1cf3 3e 78			ld a, display_row_4 
1cf5 11 26 1d			ld de, endprog 
1cf8			 
1cf8 cd cd 0d			call update_display		 
1cfb			 
1cfb cd c0 1f			call next_page_prompt 
1cfe			 
1cfe				; switch frame buffer to cli 
1cfe			 
1cfe 21 e6 fc				ld hl, display_fb0 
1d01 22 01 fb				ld (display_fb_active), hl 
1d04			 
1d04			 
1d04 cd aa 0d		        call clear_display 
1d07 cd cd 0d			call update_display		 
1d0a			 
1d0a 21 1d f4			ld hl, os_cli_cmd 
1d0d			 
1d0d 3e 00			ld a, 0		 ; init cli input 
1d0f 77				ld (hl), a 
1d10			 
1d10				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d10			 
1d10				; now on last line 
1d10			 
1d10				; TODO scroll screen up 
1d10			 
1d10				; TODO instead just clear screen and place at top of screen 
1d10			 
1d10			;	ld a, 0 
1d10			;	ld (f_cursor_ptr),a 
1d10			 
1d10				;call clear_display 
1d10				;call update_display 
1d10			 
1d10				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d12 c3 ba 1c			jp cli 
1d15			 
1d15 .. 00		freeram: db "Free bytes: ",0 
1d22 ..			asc: db "1A2F" 
1d26 .. 00		endprog: db "End prog...",0 
1d32			 
1d32			testenter2:   
1d32 21 28 f1			ld hl,scratch+50 
1d35 22 19 f4			ld (os_cur_ptr),hl 
1d38 c3 ba 1c			jp cli 
1d3b			 
1d3b			testenter:  
1d3b			 
1d3b 21 22 1d			ld hl,asc 
1d3e			;	ld a,(hl) 
1d3e			;	call nibble2val 
1d3e cd 3d 12			call get_byte 
1d41			 
1d41			 
1d41			;	ld a,(hl) 
1d41			;	call atohex 
1d41			 
1d41			;	call fourehexhl 
1d41 32 28 f1			ld (scratch+50),a 
1d44			 
1d44			 
1d44			 
1d44 21 24 1d			ld hl,asc+2 
1d47			;	ld a, (hl) 
1d47			;	call nibble2val 
1d47 cd 3d 12			call get_byte 
1d4a			 
1d4a			;	call fourehexhl 
1d4a 32 2a f1			ld (scratch+52),a 
1d4d				 
1d4d 21 28 f1			ld hl,scratch+50 
1d50 22 19 f4			ld (os_cur_ptr),hl 
1d53 c3 ba 1c			jp cli 
1d56			 
1d56			enter:	 
1d56 3a fa f0			ld a,(scratch+4) 
1d59 fe 00			cp 0 
1d5b 28 0c			jr z, .entercont 
1d5d				; no, not a null term line so has an address to work out.... 
1d5d			 
1d5d 21 f8 f0			ld hl,scratch+2 
1d60 cd 9d 12			call get_word_hl 
1d63			 
1d63 22 19 f4			ld (os_cur_ptr),hl	 
1d66 c3 ba 1c			jp cli 
1d69			 
1d69			 
1d69			.entercont:  
1d69			 
1d69 21 f8 f0			ld hl, scratch+2 
1d6c cd 3d 12			call get_byte 
1d6f			 
1d6f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d72 77					ld (hl),a 
1d73 23					inc hl 
1d74 22 19 f4				ld (os_cur_ptr),hl 
1d77				 
1d77			; get byte  
1d77			 
1d77			 
1d77 c3 ba 1c			jp cli 
1d7a			 
1d7a			 
1d7a			; basic monitor support 
1d7a			 
1d7a			monitor: 
1d7a				;  
1d7a cd aa 0d			call clear_display 
1d7d 3e 00			ld a, 0 
1d7f 11 d3 1d			ld de, .monprompt 
1d82 cd bd 0d			call str_at_display 
1d85 cd cd 0d			call update_display 
1d88			 
1d88				; get a monitor command 
1d88			 
1d88 0e 00			ld c, 0     ; entry at top left 
1d8a 16 64			ld d, 100   ; max buffer size 
1d8c 1e 0f			ld e, 15    ; input scroll area 
1d8e 3e 00			ld a, 0     ; init string 
1d90 21 f4 f2			ld hl, os_input 
1d93 77				ld (hl), a 
1d94 23				inc hl 
1d95 77				ld (hl), a 
1d96 21 f4 f2			ld hl, os_input 
1d99 3e 01			ld a, 1     ; init string 
1d9b cd 0b 10			call input_str 
1d9e			 
1d9e cd aa 0d		        call clear_display 
1da1 cd cd 0d			call update_display		 
1da4			 
1da4 3a f4 f2			ld a, (os_input) 
1da7 cd 3b 13			call toUpper 
1daa fe 48		        cp 'H' 
1dac ca 47 1e		        jp z, .monhelp 
1daf fe 44			cp 'D'		; dump 
1db1 ca 7a 1e			jp z, .mondump	 
1db4 fe 43			cp 'C'		; dump 
1db6 ca 94 1e			jp z, .moncdump	 
1db9 fe 4d			cp 'M'		; dump 
1dbb ca d5 1d			jp z, .moneditstart 
1dbe fe 55			cp 'U'		; dump 
1dc0 ca e1 1d			jp z, .monedit	 
1dc3 fe 47			cp 'G'		; dump 
1dc5 ca 70 1e			jp z, .monjump 
1dc8 fe 42			cp 'B'		; forth breakpoint 
1dca cc 5b 19			call z, break_point_state 
1dcd fe 51			cp 'Q'		; dump 
1dcf c8				ret z	 
1dd0			 
1dd0			 
1dd0				; TODO "S" to access symbol by name and not need the address 
1dd0				; TODO "F" to find a string in memory 
1dd0			 
1dd0 c3 7a 1d			jp monitor 
1dd3			 
1dd3 .. 00		.monprompt: db ">", 0 
1dd5			 
1dd5			.moneditstart: 
1dd5				; get starting address 
1dd5			 
1dd5 21 f6 f2			ld hl,os_input+2 
1dd8 cd 9d 12			call get_word_hl 
1ddb			 
1ddb 22 19 f4			ld (os_cur_ptr),hl	 
1dde			 
1dde c3 7a 1d			jp monitor 
1de1			 
1de1			.monedit: 
1de1				; get byte to load 
1de1			 
1de1 21 f6 f2			ld hl,os_input+2 
1de4 cd 3d 12			call get_byte 
1de7			 
1de7				; get address to update 
1de7 2a 19 f4			ld hl, (os_cur_ptr) 
1dea			 
1dea				; update byte 
1dea			 
1dea 77				ld (hl), a 
1deb			 
1deb				; move to next address and save it 
1deb			 
1deb 23				inc hl 
1dec 22 19 f4			ld (os_cur_ptr),hl	 
1def			 
1def c3 7a 1d			jp monitor 
1df2			 
1df2			 
1df2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e06 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e22 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e40 .. 00		.monhelptext4:  db "Q-Quit",0 
1e47			        
1e47			.monhelp: 
1e47 3e 00			ld a, display_row_1 
1e49 11 f2 1d		        ld de, .monhelptext1 
1e4c			 
1e4c cd bd 0d			call str_at_display 
1e4f 3e 28			ld a, display_row_2 
1e51 11 06 1e		        ld de, .monhelptext2 
1e54					 
1e54 cd bd 0d			call str_at_display 
1e57 3e 50			ld a, display_row_3 
1e59 11 22 1e		        ld de, .monhelptext3 
1e5c					 
1e5c cd bd 0d			call str_at_display 
1e5f 3e 78			ld a, display_row_4 
1e61 11 40 1e		        ld de, .monhelptext4 
1e64 cd bd 0d			call str_at_display 
1e67			 
1e67 cd cd 0d			call update_display		 
1e6a			 
1e6a cd c0 1f			call next_page_prompt 
1e6d c3 7a 1d			jp monitor 
1e70			 
1e70			.monjump:    
1e70 21 f6 f2			ld hl,os_input+2 
1e73 cd 9d 12			call get_word_hl 
1e76			 
1e76 e9				jp (hl) 
1e77 c3 7a 1d			jp monitor 
1e7a			 
1e7a			.mondump:    
1e7a 21 f6 f2			ld hl,os_input+2 
1e7d cd 9d 12			call get_word_hl 
1e80			 
1e80 22 19 f4			ld (os_cur_ptr),hl	 
1e83 cd c8 1e			call dumpcont 
1e86 3e 78			ld a, display_row_4 
1e88 11 26 1d			ld de, endprog 
1e8b			 
1e8b cd cd 0d			call update_display		 
1e8e			 
1e8e cd c0 1f			call next_page_prompt 
1e91 c3 7a 1d			jp monitor 
1e94			.moncdump: 
1e94 cd c8 1e			call dumpcont 
1e97 3e 78			ld a, display_row_4 
1e99 11 26 1d			ld de, endprog 
1e9c			 
1e9c cd cd 0d			call update_display		 
1e9f			 
1e9f cd c0 1f			call next_page_prompt 
1ea2 c3 7a 1d			jp monitor 
1ea5			 
1ea5			 
1ea5			; TODO symbol access  
1ea5			 
1ea5			.symbols:     ;; A list of symbols that can be called up  
1ea5 e6 fc			dw display_fb0 
1ea7 .. 00			db "fb0",0  
1eab af f9		     	dw store_page 
1ead .. 00			db "store_page",0 
1eb8			 
1eb8			 
1eb8			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb8			 
1eb8 3a f7 f0			ld a,(scratch+1) 
1ebb fe 00			cp 0 
1ebd 28 09			jr z, dumpcont 
1ebf			 
1ebf				; no, not a null term line so has an address to work out.... 
1ebf			 
1ebf 21 f8 f0			ld hl,scratch+2 
1ec2 cd 9d 12			call get_word_hl 
1ec5			 
1ec5 22 19 f4			ld (os_cur_ptr),hl	 
1ec8			 
1ec8			 
1ec8			 
1ec8			dumpcont: 
1ec8			 
1ec8				; dump bytes at ptr 
1ec8			 
1ec8			 
1ec8 3e 00			ld a, display_row_1 
1eca 2a 01 fb			ld hl, (display_fb_active) 
1ecd cd de 0f			call addatohl 
1ed0 cd f8 1e			call .dumpbyterow 
1ed3			 
1ed3 3e 28			ld a, display_row_2 
1ed5 2a 01 fb			ld hl, (display_fb_active) 
1ed8 cd de 0f			call addatohl 
1edb cd f8 1e			call .dumpbyterow 
1ede			 
1ede			 
1ede 3e 50			ld a, display_row_3 
1ee0 2a 01 fb			ld hl, (display_fb_active) 
1ee3 cd de 0f			call addatohl 
1ee6 cd f8 1e			call .dumpbyterow 
1ee9			 
1ee9 3e 78			ld a, display_row_4 
1eeb 2a 01 fb			ld hl, (display_fb_active) 
1eee cd de 0f			call addatohl 
1ef1 cd f8 1e			call .dumpbyterow 
1ef4			 
1ef4 cd cd 0d			call update_display 
1ef7			;		jp cli 
1ef7 c9				ret 
1ef8			 
1ef8			.dumpbyterow: 
1ef8			 
1ef8				;push af 
1ef8			 
1ef8 e5				push hl 
1ef9			 
1ef9				; calc where to poke the ascii 
1ef9			if display_cols == 20 
1ef9				ld a, 16 
1ef9			else 
1ef9 3e 1f			ld a, 31 
1efb			endif 
1efb			 
1efb cd de 0f			call addatohl 
1efe 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1f01			 
1f01			 
1f01			; display decoding address 
1f01 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f04			 
1f04 7c				ld a,h 
1f05 e1				pop hl 
1f06 e5				push hl 
1f07			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f07 cd e7 11			call hexout 
1f0a 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0d			 
1f0d 7d				ld a,l 
1f0e e1				pop hl 
1f0f 23				inc hl 
1f10 23				inc hl 
1f11 e5				push hl 
1f12			;	ld hl, os_word_scratch+2 
1f12 cd e7 11			call hexout 
1f15 e1				pop hl 
1f16 23				inc hl 
1f17 23				inc hl 
1f18				;ld hl, os_word_scratch+4 
1f18 3e 3a			ld a, ':' 
1f1a 77				ld (hl),a 
1f1b 23				inc hl 
1f1c				;ld a, 0 
1f1c				;ld (hl),a 
1f1c				;ld de, os_word_scratch 
1f1c				;pop af 
1f1c				;push af 
1f1c			;		ld a, display_row_2 
1f1c			;		call str_at_display 
1f1c			;		call update_display 
1f1c			 
1f1c			 
1f1c			;pop af 
1f1c			;	add 5 
1f1c			 
1f1c			if display_cols == 20 
1f1c				ld b, 4 
1f1c			else 
1f1c 06 08			ld b, 8 
1f1e			endif	 
1f1e			 
1f1e			.dumpbyte: 
1f1e c5				push bc 
1f1f e5				push hl 
1f20			 
1f20			 
1f20 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f23 7e					ld a,(hl) 
1f24			 
1f24					; poke the ascii to display 
1f24 2a fb f3				ld hl,(os_word_scratch) 
1f27 77					ld (hl),a 
1f28 23					inc hl 
1f29 22 fb f3				ld (os_word_scratch),hl 
1f2c			 
1f2c					 
1f2c			 
1f2c			 
1f2c e1					pop hl 
1f2d e5					push hl 
1f2e			 
1f2e cd e7 11				call hexout 
1f31			 
1f31					 
1f31 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f34 23				inc hl 
1f35 22 19 f4		   	ld (os_cur_ptr),hl 
1f38			 
1f38 e1					pop hl 
1f39 23					inc hl 
1f3a 23					inc hl 
1f3b 23					inc hl 
1f3c			 
1f3c			 
1f3c			 
1f3c					;ld a,0 
1f3c					;ld (os_word_scratch+2),a 
1f3c					;pop af 
1f3c					;push af 
1f3c			 
1f3c					;ld de, os_word_scratch 
1f3c					;call str_at_display 
1f3c			;		call update_display 
1f3c			;		pop af 
1f3c c1					pop bc 
1f3d c6 03				add 3 
1f3f 10 dd			djnz .dumpbyte 
1f41			 
1f41				 
1f41			 
1f41 c9				ret 
1f42			 
1f42			jump:	 
1f42			 
1f42 21 f8 f0			ld hl,scratch+2 
1f45 cd 9d 12			call get_word_hl 
1f48				;ld hl,(scratch+2) 
1f48				;call fourehexhl 
1f48			 
1f48 22 19 f4			ld (os_cur_ptr),hl	 
1f4b			 
1f4b e9				jp (hl) 
1f4c			 
1f4c			 
1f4c			 
1f4c			; TODO implement a basic monitor mode to start with 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			; testing and demo code during development 
1f4c			 
1f4c			 
1f4c .. 00		str1: db "Enter some text...",0 
1f5f .. 00		clear: db "                    ",0 
1f74			 
1f74			demo: 
1f74			 
1f74			 
1f74			 
1f74			;	call update_display 
1f74			 
1f74				; init scratch input area for testing 
1f74 21 f6 f0			ld hl, scratch	 
1f77 3e 00			ld a,0 
1f79 77				ld (hl),a 
1f7a			 
1f7a			 
1f7a 3e 28		            LD   A, display_row_2 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 4c 1f		            LD   DE, str1 
1f7f cd bd 0d			call str_at_display 
1f82			 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82			cloop:	 
1f82 3e 50		            LD   A, display_row_3 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 5f 1f		            LD   DE, clear 
1f87			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd bd 0d				call str_at_display 
1f8a 3e 78			ld a, display_row_4 
1f8c 11 bc 1f			ld de, prompt 
1f8f			 
1f8f cd bd 0d				call str_at_display 
1f92 cd cd 0d			call update_display 
1f95			 
1f95 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f97 16 0a			ld d, 10 
1f99 21 f6 f0			ld hl, scratch	 
1f9c cd 0b 10			call input_str 
1f9f			 
1f9f			;	call clear_display 
1f9f			;'	call update_display 
1f9f			 
1f9f 3e 00		            LD   A, display_row_1 
1fa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa1 11 5f 1f		            LD   DE, clear 
1fa4 cd bd 0d				call str_at_display 
1fa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa7 3e 00		            LD   A, display_row_1 
1fa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa9 11 f6 f0		            LD   DE, scratch 
1fac			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fac cd bd 0d				call str_at_display 
1faf cd cd 0d			call update_display 
1fb2			 
1fb2 3e 00				ld a,0 
1fb4 21 f6 f0			ld hl, scratch 
1fb7 77				ld (hl),a 
1fb8			 
1fb8 00				nop 
1fb9 c3 82 1f			jp cloop 
1fbc			 
1fbc			 
1fbc			 
1fbc			; OS Prompt 
1fbc			 
1fbc .. 00		prompt: db ">",0 
1fbe .. 00		endprg: db "?",0 
1fc0			 
1fc0			 
1fc0			; handy next page prompt 
1fc0			next_page_prompt: 
1fc0 e5				push hl 
1fc1 d5				push de 
1fc2 f5				push af 
1fc3 c5				push bc 
1fc4			 
1fc4 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc6 11 be 1f		        ld de, endprg 
1fc9 cd bd 0d			call str_at_display 
1fcc cd cd 0d			call update_display 
1fcf cd 4e 78			call cin_wait 
1fd2 c1				pop bc 
1fd3 f1				pop af 
1fd4 d1				pop de 
1fd5 e1				pop hl 
1fd6			 
1fd6			 
1fd6 c9				ret 
1fd7			 
1fd7			 
1fd7			; forth parser 
1fd7			 
1fd7			; My forth kernel 
1fd7			include "forth_kernel.asm" 
1fd7			; 
1fd7			; kernel to the forth OS 
1fd7			 
1fd7			DS_TYPE_STR: equ 1     ; string type 
1fd7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd7			 
1fd7			FORTH_PARSEV1: equ 0 
1fd7			FORTH_PARSEV2: equ 0 
1fd7			FORTH_PARSEV3: equ 0 
1fd7			FORTH_PARSEV4: equ 0 
1fd7			FORTH_PARSEV5: equ 0 
1fd7			FORTH_PARSEV6: equ 1 
1fd7			 
1fd7			;if FORTH_PARSEV5 
1fd7			;	FORTH_END_BUFFER: equ 0 
1fd7			;else 
1fd7			FORTH_END_BUFFER: equ 127 
1fd7			;endif 
1fd7			 
1fd7			FORTH_TRUE: equ 1 
1fd7			FORTH_FALSE: equ 0 
1fd7			 
1fd7			if FORTH_PARSEV4 
1fd7			include "forth_stackops.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV5 
1fd7			include "forth_stackopsv5.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV6 
1fd7			include "forth_stackopsv5.asm" 
1fd7			 
1fd7			; Stack operations for v5 parser on wards 
1fd7			; * DATA stack 
1fd7			; * LOOP stack 
1fd7			; * RETURN stack 
1fd7			 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_DSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_data_sp) 
1fd7				ld de, cli_data_stack 
1fd7				call cmp16 
1fd7				jp c, fault_dsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_RSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_ret_sp) 
1fd7				ld de, cli_ret_stack 
1fd7				call cmp16 
1fd7				jp c, fault_rsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_CHK_LOOP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_loop_sp) 
1fd7				ld de, cli_loop_stack 
1fd7				call cmp16 
1fd7				jp c, fault_loop_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTSTR: macro 
1fd7				; TOSO might need more for checks when used 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_STR 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTNUM: macro 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_INUM 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			; increase data stack pointer and save hl to it 
1fd7				 
1fd7			FORTH_DSP_NEXT: macro 
1fd7				call macro_forth_dsp_next 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			macro_forth_dsp_next: 
1fd7				if DEBUG_FORTH_STACK_GUARD 
1fd7 cd f2 70				call check_stacks 
1fda				endif 
1fda e5				push hl 
1fdb d5				push de 
1fdc eb				ex de,hl 
1fdd 2a 23 f9			ld hl,(cli_data_sp) 
1fe0 23				inc hl 
1fe1 23				inc hl 
1fe2			 
1fe2			; PARSEV5 
1fe2 23				inc hl 
1fe3 22 23 f9			ld (cli_data_sp),hl 
1fe6 73				ld (hl), e 
1fe7 23				inc hl 
1fe8 72				ld (hl), d 
1fe9 d1				pop de 
1fea e1				pop hl 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd f2 70				call check_stacks 
1fee				endif 
1fee c9				ret 
1fef			 
1fef			 
1fef			; increase ret stack pointer and save hl to it 
1fef				 
1fef			FORTH_RSP_NEXT: macro 
1fef				call macro_forth_rsp_next 
1fef				endm 
1fef			 
1fef			macro_forth_rsp_next: 
1fef				if DEBUG_FORTH_STACK_GUARD 
1fef cd f2 70				call check_stacks 
1ff2				endif 
1ff2 e5				push hl 
1ff3 d5				push de 
1ff4 eb				ex de,hl 
1ff5 2a 27 f9			ld hl,(cli_ret_sp) 
1ff8 23				inc hl 
1ff9 23				inc hl 
1ffa 22 27 f9			ld (cli_ret_sp),hl 
1ffd 73				ld (hl), e 
1ffe 23				inc hl 
1fff 72				ld (hl), d 
2000 d1				pop de 
2001 e1				pop hl 
2002				if DEBUG_FORTH_STACK_GUARD 
2002 cd f2 70				call check_stacks 
2005				endif 
2005 c9				ret 
2006			 
2006			; get current ret stack pointer and save to hl  
2006				 
2006			FORTH_RSP_TOS: macro 
2006				call macro_forth_rsp_tos 
2006				endm 
2006			 
2006			macro_forth_rsp_tos: 
2006				;push de 
2006 2a 27 f9			ld hl,(cli_ret_sp) 
2009 cd 41 20			call loadhlptrtohl 
200c				;ld e, (hl) 
200c				;inc hl 
200c				;ld d, (hl) 
200c				;ex de, hl 
200c					if DEBUG_FORTH_WORDS 
200c			;			DMARK "RST" 
200c						CALLMONITOR 
200c cd aa fd			call debug_vector  
200f				endm  
# End of macro CALLMONITOR
200f					endif 
200f				;pop de 
200f c9				ret 
2010			 
2010			; pop ret stack pointer 
2010				 
2010			FORTH_RSP_POP: macro 
2010				call macro_forth_rsp_pop 
2010				endm 
2010			 
2010			 
2010			macro_forth_rsp_pop: 
2010				if DEBUG_FORTH_STACK_GUARD 
2010			;		DMARK "RPP" 
2010 cd f2 70				call check_stacks 
2013					FORTH_CHK_RSP_UNDER 
2013 e5				push hl 
2014 d5				push de 
2015 2a 27 f9			ld hl,(cli_ret_sp) 
2018 11 e1 f8			ld de, cli_ret_stack 
201b cd fc 0f			call cmp16 
201e da 09 72			jp c, fault_rsp_under 
2021 d1				pop de 
2022 e1				pop hl 
2023				endm 
# End of macro FORTH_CHK_RSP_UNDER
2023				endif 
2023 e5				push hl 
2024 2a 27 f9			ld hl,(cli_ret_sp) 
2027			 
2027			 
2027				if FORTH_ENABLE_FREE 
2027			 
2027					; get pointer 
2027			 
2027					push de 
2027					push hl 
2027			 
2027					ld e, (hl) 
2027					inc hl 
2027					ld d, (hl) 
2027			 
2027					ex de, hl 
2027					call free 
2027			 
2027					pop hl 
2027					pop de 
2027			 
2027			 
2027				endif 
2027			 
2027			 
2027 2b				dec hl 
2028 2b				dec hl 
2029 22 27 f9			ld (cli_ret_sp), hl 
202c				; do stack underflow checks 
202c e1				pop hl 
202d				if DEBUG_FORTH_STACK_GUARD 
202d cd f2 70				call check_stacks 
2030					FORTH_CHK_RSP_UNDER 
2030 e5				push hl 
2031 d5				push de 
2032 2a 27 f9			ld hl,(cli_ret_sp) 
2035 11 e1 f8			ld de, cli_ret_stack 
2038 cd fc 0f			call cmp16 
203b da 09 72			jp c, fault_rsp_under 
203e d1				pop de 
203f e1				pop hl 
2040				endm 
# End of macro FORTH_CHK_RSP_UNDER
2040				endif 
2040 c9				ret 
2041			 
2041			 
2041			 
2041			; routine to load word pointed to by hl into hl 
2041			 
2041			loadhlptrtohl: 
2041			 
2041 d5				push de 
2042 5e				ld e, (hl) 
2043 23				inc hl 
2044 56				ld d, (hl) 
2045 eb				ex de, hl 
2046 d1				pop de 
2047			 
2047 c9				ret 
2048			 
2048			 
2048			 
2048			 
2048			 
2048			; push a number held in HL onto the data stack 
2048			; entry point for pushing a value when already in hl used in function above 
2048			 
2048			forth_push_numhl: 
2048			 
2048 e5				push hl    ; save value to push 
2049			 
2049			if DEBUG_FORTH_PUSH 
2049				; see if disabled 
2049			 
2049			 
2049 f5				push af 
204a 3a aa fd			ld a,(debug_vector) 
204d fe c9			cp $c9   ; ret 
204f			;	ld a, (os_view_disable) 
204f			;	cp '*' 
204f 28 34			jr z, .pskip2 
2051 e5				push hl 
2052 e5			push hl 
2053 cd aa 0d			call clear_display 
2056 e1			pop hl 
2057 7c				ld a,h 
2058 21 fb f3			ld hl, os_word_scratch 
205b cd e7 11			call hexout 
205e e1				pop hl 
205f 7d				ld a,l 
2060 21 fd f3			ld hl, os_word_scratch+2 
2063 cd e7 11			call hexout 
2066			 
2066 21 ff f3			ld hl, os_word_scratch+4 
2069 3e 00			ld a,0 
206b 77				ld (hl),a 
206c 11 fb f3			ld de,os_word_scratch 
206f 3e 28				ld a, display_row_2 
2071 cd bd 0d				call str_at_display 
2074 11 eb 62			ld de, .push_num 
2077 3e 00			ld a, display_row_1 
2079			 
2079 cd bd 0d				call str_at_display 
207c			 
207c			 
207c cd cd 0d			call update_display 
207f cd ed 0c			call delay1s 
2082 cd ed 0c			call delay1s 
2085			.pskip2:  
2085			 
2085 f1				pop af 
2086			endif	 
2086			 
2086			 
2086				FORTH_DSP_NEXT 
2086 cd d7 1f			call macro_forth_dsp_next 
2089				endm 
# End of macro FORTH_DSP_NEXT
2089			 
2089 2a 23 f9			ld hl, (cli_data_sp) 
208c			 
208c				; save item type 
208c 3e 02			ld a,  DS_TYPE_INUM 
208e 77				ld (hl), a 
208f 23				inc hl 
2090			 
2090				; get word off stack 
2090 d1				pop de 
2091 7b				ld a,e 
2092 77				ld (hl), a 
2093 23				inc hl 
2094 7a				ld a,d 
2095 77				ld (hl), a 
2096			 
2096			if DEBUG_FORTH_PUSH 
2096 2b				dec hl 
2097 2b				dec hl 
2098 2b				dec hl 
2099						DMARK "PH5" 
2099 f5				push af  
209a 3a ae 20			ld a, (.dmark)  
209d 32 a0 fd			ld (debug_mark),a  
20a0 3a af 20			ld a, (.dmark+1)  
20a3 32 a1 fd			ld (debug_mark+1),a  
20a6 3a b0 20			ld a, (.dmark+2)  
20a9 32 a2 fd			ld (debug_mark+2),a  
20ac 18 03			jr .pastdmark  
20ae ..			.dmark: db "PH5"  
20b1 f1			.pastdmark: pop af  
20b2			endm  
# End of macro DMARK
20b2				CALLMONITOR 
20b2 cd aa fd			call debug_vector  
20b5				endm  
# End of macro CALLMONITOR
20b5			endif	 
20b5			 
20b5 c9				ret 
20b6			 
20b6			 
20b6			; Push a string to stack pointed to by hl 
20b6			 
20b6			forth_push_str: 
20b6			 
20b6			if DEBUG_FORTH_PUSH 
20b6						DMARK "PSQ" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 a0 fd			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 a1 fd			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 a2 fd			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "PSQ"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf				CALLMONITOR 
20cf cd aa fd			call debug_vector  
20d2				endm  
# End of macro CALLMONITOR
20d2			endif	 
20d2			 
20d2			 
20d2			    
20d2 e5				push hl 
20d3 e5				push hl 
20d4			 
20d4			;	ld a, 0   ; find end of string 
20d4 cd 44 13			call strlenz 
20d7			if DEBUG_FORTH_PUSH 
20d7						DMARK "PQ2" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 a0 fd			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 a1 fd			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 a2 fd			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db "PQ2"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd aa fd			call debug_vector  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif	 
20f3 eb				ex de, hl 
20f4 e1				pop hl   ; get ptr to start of string 
20f5			if DEBUG_FORTH_PUSH 
20f5						DMARK "PQ3" 
20f5 f5				push af  
20f6 3a 0a 21			ld a, (.dmark)  
20f9 32 a0 fd			ld (debug_mark),a  
20fc 3a 0b 21			ld a, (.dmark+1)  
20ff 32 a1 fd			ld (debug_mark+1),a  
2102 3a 0c 21			ld a, (.dmark+2)  
2105 32 a2 fd			ld (debug_mark+2),a  
2108 18 03			jr .pastdmark  
210a ..			.dmark: db "PQ3"  
210d f1			.pastdmark: pop af  
210e			endm  
# End of macro DMARK
210e				CALLMONITOR 
210e cd aa fd			call debug_vector  
2111				endm  
# End of macro CALLMONITOR
2111			endif	 
2111 19				add hl,de 
2112			if DEBUG_FORTH_PUSH 
2112						DMARK "PQE" 
2112 f5				push af  
2113 3a 27 21			ld a, (.dmark)  
2116 32 a0 fd			ld (debug_mark),a  
2119 3a 28 21			ld a, (.dmark+1)  
211c 32 a1 fd			ld (debug_mark+1),a  
211f 3a 29 21			ld a, (.dmark+2)  
2122 32 a2 fd			ld (debug_mark+2),a  
2125 18 03			jr .pastdmark  
2127 ..			.dmark: db "PQE"  
212a f1			.pastdmark: pop af  
212b			endm  
# End of macro DMARK
212b				CALLMONITOR 
212b cd aa fd			call debug_vector  
212e				endm  
# End of macro CALLMONITOR
212e			endif	 
212e			 
212e 2b				dec hl    ; see if there is an optional trailing double quote 
212f 7e				ld a,(hl) 
2130 fe 22			cp '"' 
2132 20 03			jr nz, .strnoq 
2134 3e 00			ld a, 0      ; get rid of double quote 
2136 77				ld (hl), a 
2137 23			.strnoq: inc hl 
2138			 
2138 3e 00			ld a, 0 
213a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
213b			 
213b 13				inc de ; add one for the type string 
213c 13				inc de ; add one for null term??? 
213d			 
213d				; tos is get string pointer again 
213d				; de contains space to allocate 
213d				 
213d d5				push de 
213e			 
213e eb				ex de, hl 
213f			 
213f				;push af 
213f			 
213f			if DEBUG_FORTH_PUSH 
213f						DMARK "PHm" 
213f f5				push af  
2140 3a 54 21			ld a, (.dmark)  
2143 32 a0 fd			ld (debug_mark),a  
2146 3a 55 21			ld a, (.dmark+1)  
2149 32 a1 fd			ld (debug_mark+1),a  
214c 3a 56 21			ld a, (.dmark+2)  
214f 32 a2 fd			ld (debug_mark+2),a  
2152 18 03			jr .pastdmark  
2154 ..			.dmark: db "PHm"  
2157 f1			.pastdmark: pop af  
2158			endm  
# End of macro DMARK
2158				CALLMONITOR 
2158 cd aa fd			call debug_vector  
215b				endm  
# End of macro CALLMONITOR
215b			endif	 
215b cd b9 13			call malloc	; on ret hl now contains allocated memory 
215e				if DEBUG_FORTH_MALLOC_GUARD 
215e cc 43 63				call z,malloc_error 
2161				endif 
2161			 
2161				 
2161 c1				pop bc    ; get length 
2162 d1				pop de   ;  get string start    
2163			 
2163				; hl has destination from malloc 
2163			 
2163 eb				ex de, hl    ; prep for ldir 
2164			 
2164 d5				push de   ; save malloc area for DSP later 
2165				;push hl   ; save malloc area for DSP later 
2165			 
2165			if DEBUG_FORTH_PUSH 
2165						DMARK "PHc" 
2165 f5				push af  
2166 3a 7a 21			ld a, (.dmark)  
2169 32 a0 fd			ld (debug_mark),a  
216c 3a 7b 21			ld a, (.dmark+1)  
216f 32 a1 fd			ld (debug_mark+1),a  
2172 3a 7c 21			ld a, (.dmark+2)  
2175 32 a2 fd			ld (debug_mark+2),a  
2178 18 03			jr .pastdmark  
217a ..			.dmark: db "PHc"  
217d f1			.pastdmark: pop af  
217e			endm  
# End of macro DMARK
217e				CALLMONITOR 
217e cd aa fd			call debug_vector  
2181				endm  
# End of macro CALLMONITOR
2181			endif	 
2181			 
2181			 
2181 ed b0			ldir 
2183			 
2183			 
2183				; push malloc to data stack     macro?????  
2183			 
2183				FORTH_DSP_NEXT 
2183 cd d7 1f			call macro_forth_dsp_next 
2186				endm 
# End of macro FORTH_DSP_NEXT
2186			 
2186				; save value and type 
2186			 
2186 2a 23 f9			ld hl, (cli_data_sp) 
2189			 
2189				; save item type 
2189 3e 01			ld a,  DS_TYPE_STR 
218b 77				ld (hl), a 
218c 23				inc hl 
218d			 
218d				; get malloc word off stack 
218d d1				pop de 
218e 73				ld (hl), e 
218f 23				inc hl 
2190 72				ld (hl), d 
2191			 
2191			 
2191			 
2191			if DEBUG_FORTH_PUSH 
2191 2a 23 f9			ld hl, (cli_data_sp) 
2194						DMARK "PHS" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 a0 fd			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 a1 fd			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 a2 fd			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "PHS"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad				CALLMONITOR 
21ad cd aa fd			call debug_vector  
21b0				endm  
# End of macro CALLMONITOR
21b0			;	ex de,hl 
21b0			endif	 
21b0				; in case of spaces, skip the ptr past the copied string 
21b0				;pop af 
21b0				;ld (cli_origptr),hl 
21b0			 
21b0 c9				ret 
21b1			 
21b1			 
21b1			 
21b1			; TODO ascii push input onto stack given hl to start of input 
21b1			 
21b1			; identify type 
21b1			; if starts with a " then a string 
21b1			; otherwise it is a number 
21b1			;  
21b1			; if a string 
21b1			;     scan for ending " to get length of string to malloc for + 1 
21b1			;     malloc 
21b1			;     put pointer to string on stack first byte flags as string 
21b1			; 
21b1			; else a number 
21b1			;    look for number format identifier 
21b1			;    $xx hex 
21b1			;    %xxxxx bin 
21b1			;    xxxxx decimal 
21b1			;    convert number to 16bit word.  
21b1			;    malloc word + 1 with flag to identiy as num 
21b1			;    put pointer to number on stack 
21b1			;   
21b1			;  
21b1			  
21b1			forth_apush: 
21b1				; kernel push 
21b1			 
21b1			if DEBUG_FORTH_PUSH 
21b1						DMARK "PSH" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 a0 fd			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 a1 fd			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 a2 fd			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db "PSH"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd aa fd			call debug_vector  
21cd				endm  
# End of macro CALLMONITOR
21cd			endif	 
21cd				; identify input type 
21cd			 
21cd 7e				ld a,(hl) 
21ce			 
21ce fe 23			cp '#' 
21d0 ca 0a 22			jp z, .fapdec 
21d3			 
21d3			 
21d3 fe 22			cp '"' 
21d5 28 0a			jr z, .fapstr 
21d7 fe 24			cp '$' 
21d9 ca 01 22			jp z, .faphex 
21dc fe 25			cp '%' 
21de ca e9 21			jp z, .fapbin 
21e1			;	cp 'b' 
21e1			;	jp z, .fabin 
21e1				; else decimal 
21e1			 
21e1				; TODO do decimal conversion 
21e1				; decimal is stored as a 16bit word 
21e1			 
21e1				; by default everything is a string if type is not detected 
21e1			.fapstr: ; 
21e1 fe 22			cp '"' 
21e3 20 01			jr nz, .strnoqu 
21e5 23				inc hl 
21e6			.strnoqu: 
21e6 c3 b6 20			jp forth_push_str 
21e9			 
21e9			 
21e9			 
21e9			.fapbin:    ; push a binary string.  
21e9 11 00 00			ld de, 0   ; hold a 16bit value 
21ec			 
21ec 23			.fapbinshift:	inc hl  
21ed 7e				ld a,(hl) 
21ee fe 00			cp 0     ; done scanning  
21f0 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f2			 
21f2				; left shift de 
21f2 eb				ex de, hl	 
21f3 29				add hl, hl 
21f4			 
21f4				; is 1 
21f4 fe 31			cp '1' 
21f6 20 02			jr nz, .binzero 
21f8 cb 4d			bit 1, l 
21fa			.binzero: 
21fa eb				ex de, hl	 ; save current de 
21fb 18 ef			jr .fapbinshift 
21fd			 
21fd			.fapbdone: 
21fd eb				ex de, hl 
21fe c3 48 20			jp forth_push_numhl 
2201			 
2201			 
2201			.faphex:   ; hex is always stored as a 16bit word 
2201				; skip number prefix 
2201 23				inc hl 
2202				; turn ascii into number 
2202 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2205			 
2205 c3 48 20			jp forth_push_numhl 
2208			 
2208 00				 nop 
2209			 
2209			.fabin:   ; TODO bin conversion 
2209			 
2209			 
2209 c9				ret 
220a			.fapdec:	 
220a				; string to dec conversion 
220a 23				inc hl 
220b eb				ex de, hl 
220c cd db 12			call string_to_uint16 
220f c3 48 20			jp forth_push_numhl 
2212 c9				ret 
2213				 
2213			;atoui_16: 
2213			 
2213			; get either a string ptr or a 16bit word from the data stack 
2213			 
2213			FORTH_DSP: macro 
2213				call macro_forth_dsp 
2213				endm 
2213			 
2213			macro_forth_dsp: 
2213				; data stack pointer points to current word on tos 
2213			 
2213 2a 23 f9			ld hl,(cli_data_sp) 
2216			 
2216				if DEBUG_FORTH_PUSH 
2216						DMARK "DSP" 
2216 f5				push af  
2217 3a 2b 22			ld a, (.dmark)  
221a 32 a0 fd			ld (debug_mark),a  
221d 3a 2c 22			ld a, (.dmark+1)  
2220 32 a1 fd			ld (debug_mark+1),a  
2223 3a 2d 22			ld a, (.dmark+2)  
2226 32 a2 fd			ld (debug_mark+2),a  
2229 18 03			jr .pastdmark  
222b ..			.dmark: db "DSP"  
222e f1			.pastdmark: pop af  
222f			endm  
# End of macro DMARK
222f			 
222f cd 76 63				call display_data_sp 
2232				;call break_point_state 
2232				;rst 030h 
2232				CALLMONITOR 
2232 cd aa fd			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235				endif 
2235			 
2235 c9				ret 
2236			 
2236			; return hl to start of value on stack 
2236			 
2236			FORTH_DSP_VALUE: macro 
2236				call macro_forth_dsp_value 
2236				endm 
2236			 
2236			macro_forth_dsp_value: 
2236			 
2236				FORTH_DSP 
2236 cd 13 22			call macro_forth_dsp 
2239				endm 
# End of macro FORTH_DSP
2239			 
2239 d5				push de 
223a			 
223a 23				inc hl ; skip type 
223b			 
223b 5e				ld e, (hl) 
223c 23				inc hl 
223d 56				ld d, (hl) 
223e eb				ex de,hl  
223f			 
223f d1				pop de 
2240			 
2240 c9				ret 
2241			 
2241			; return hl to start of value to second item on stack 
2241			 
2241			FORTH_DSP_VALUEM1: macro 
2241				call macro_forth_dsp_value_m1 
2241				endm 
2241			 
2241			macro_forth_dsp_value_m1: 
2241			 
2241				FORTH_DSP 
2241 cd 13 22			call macro_forth_dsp 
2244				endm 
# End of macro FORTH_DSP
2244			 
2244 2b				dec hl 
2245 2b				dec hl 
2246			;	dec hl 
2246			 
2246 d5				push de 
2247			 
2247 5e				ld e, (hl) 
2248 23				inc hl 
2249 56				ld d, (hl) 
224a eb				ex de,hl  
224b			 
224b d1				pop de 
224c			 
224c c9				ret 
224d			 
224d				 
224d			 
224d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224d			 
224d			FORTH_DSP_POP: macro 
224d				call macro_forth_dsp_pop 
224d				endm 
224d			 
224d			 
224d			; get the tos data type 
224d			 
224d			FORTH_DSP_TYPE:   macro 
224d			 
224d				;FORTH_DSP_VALUE 
224d				FORTH_DSP 
224d				 
224d				; hl points to value 
224d				; check type 
224d			 
224d				ld a,(hl) 
224d			 
224d				endm 
224d			 
224d			; load the tos value into hl 
224d			 
224d			 
224d			FORTH_DSP_VALUEHL:  macro 
224d				call macro_dsp_valuehl 
224d				endm 
224d			 
224d			 
224d			 
224d			macro_dsp_valuehl: 
224d				FORTH_DSP_VALUE 
224d cd 36 22			call macro_forth_dsp_value 
2250				endm 
# End of macro FORTH_DSP_VALUE
2250			 
2250				;FORTH_ERR_TOS_NOTNUM 
2250			 
2250				;inc hl   ; skip type id 
2250			 
2250			;	push de 
2250			; 
2250			;	ld e, (hl) 
2250			;	inc hl 
2250			;	ld d, (hl) 
2250			;	ex de,hl  
2250			 
2250			;	pop de 
2250			 
2250				if DEBUG_FORTH_PUSH 
2250						DMARK "DVL" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 a0 fd			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 a1 fd			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 a2 fd			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "DVL"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269				CALLMONITOR 
2269 cd aa fd			call debug_vector  
226c				endm  
# End of macro CALLMONITOR
226c				endif 
226c c9				ret 
226d			 
226d			forth_apushstrhl:      
226d				; push of string requires use of cli_origptr 
226d				; bodge use 
226d			 
226d				; get current cli_origptr, save, update with temp pointer  
226d ed 5b 73 f9		ld de, (cli_origptr) 
2271 22 73 f9			ld (cli_origptr), hl 
2274 d5				push de 
2275 cd b1 21			call forth_apush 
2278 d1				pop de 
2279 ed 53 73 f9		ld (cli_origptr), de 
227d c9			        ret	 
227e			 
227e			 
227e			; increase loop stack pointer and save hl to it 
227e				 
227e			FORTH_LOOP_NEXT: macro 
227e				call macro_forth_loop_next 
227e				;nop 
227e				endm 
227e			 
227e			macro_forth_loop_next: 
227e				if DEBUG_FORTH_STACK_GUARD 
227e cd f2 70				call check_stacks 
2281				endif 
2281 e5				push hl 
2282 d5				push de 
2283 eb				ex de,hl 
2284 2a 25 f9			ld hl,(cli_loop_sp) 
2287 23				inc hl 
2288 23				inc hl 
2289					if DEBUG_FORTH_WORDS 
2289						DMARK "LNX" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 a0 fd			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 a1 fd			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 a2 fd			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "LNX"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2						CALLMONITOR 
22a2 cd aa fd			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5					endif 
22a5 22 25 f9			ld (cli_loop_sp),hl 
22a8 73				ld (hl), e 
22a9 23				inc hl 
22aa 72				ld (hl), d 
22ab d1				pop de    ; been reversed so save a swap on restore 
22ac e1				pop hl 
22ad				if DEBUG_FORTH_STACK_GUARD 
22ad cd f2 70				call check_stacks 
22b0				endif 
22b0 c9				ret 
22b1			 
22b1			; get current ret stack pointer and save to hl  
22b1				 
22b1			FORTH_LOOP_TOS: macro 
22b1				call macro_forth_loop_tos 
22b1				endm 
22b1			 
22b1			macro_forth_loop_tos: 
22b1 d5				push de 
22b2 2a 25 f9			ld hl,(cli_loop_sp) 
22b5 5e				ld e, (hl) 
22b6 23				inc hl 
22b7 56				ld d, (hl) 
22b8 eb				ex de, hl 
22b9 d1				pop de 
22ba c9				ret 
22bb			 
22bb			; pop loop stack pointer 
22bb				 
22bb			FORTH_LOOP_POP: macro 
22bb				call macro_forth_loop_pop 
22bb				endm 
22bb			 
22bb			 
22bb			macro_forth_loop_pop: 
22bb				if DEBUG_FORTH_STACK_GUARD 
22bb					DMARK "LPP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 a0 fd			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 a1 fd			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 a2 fd			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "LPP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4 cd f2 70				call check_stacks 
22d7					FORTH_CHK_LOOP_UNDER 
22d7 e5				push hl 
22d8 d5				push de 
22d9 2a 25 f9			ld hl,(cli_loop_sp) 
22dc 11 5f f8			ld de, cli_loop_stack 
22df cd fc 0f			call cmp16 
22e2 da 0f 72			jp c, fault_loop_under 
22e5 d1				pop de 
22e6 e1				pop hl 
22e7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e7				endif 
22e7 e5				push hl 
22e8 2a 25 f9			ld hl,(cli_loop_sp) 
22eb 2b				dec hl 
22ec 2b				dec hl 
22ed 22 25 f9			ld (cli_loop_sp), hl 
22f0				; TODO do stack underflow checks 
22f0 e1				pop hl 
22f1				if DEBUG_FORTH_STACK_GUARD 
22f1 cd f2 70				call check_stacks 
22f4					FORTH_CHK_LOOP_UNDER 
22f4 e5				push hl 
22f5 d5				push de 
22f6 2a 25 f9			ld hl,(cli_loop_sp) 
22f9 11 5f f8			ld de, cli_loop_stack 
22fc cd fc 0f			call cmp16 
22ff da 0f 72			jp c, fault_loop_under 
2302 d1				pop de 
2303 e1				pop hl 
2304				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2304				endif 
2304 c9				ret 
2305			 
2305			macro_forth_dsp_pop: 
2305			 
2305 e5				push hl 
2306			 
2306				; release malloc data 
2306			 
2306				if DEBUG_FORTH_STACK_GUARD 
2306 cd f2 70				call check_stacks 
2309					FORTH_CHK_DSP_UNDER 
2309 e5				push hl 
230a d5				push de 
230b 2a 23 f9			ld hl,(cli_data_sp) 
230e 11 5d f6			ld de, cli_data_stack 
2311 cd fc 0f			call cmp16 
2314 da 03 72			jp c, fault_dsp_under 
2317 d1				pop de 
2318 e1				pop hl 
2319				endm 
# End of macro FORTH_CHK_DSP_UNDER
2319				endif 
2319				;ld hl,(cli_data_sp) 
2319			if DEBUG_FORTH_DOT 
2319				DMARK "DPP" 
2319 f5				push af  
231a 3a 2e 23			ld a, (.dmark)  
231d 32 a0 fd			ld (debug_mark),a  
2320 3a 2f 23			ld a, (.dmark+1)  
2323 32 a1 fd			ld (debug_mark+1),a  
2326 3a 30 23			ld a, (.dmark+2)  
2329 32 a2 fd			ld (debug_mark+2),a  
232c 18 03			jr .pastdmark  
232e ..			.dmark: db "DPP"  
2331 f1			.pastdmark: pop af  
2332			endm  
# End of macro DMARK
2332				CALLMONITOR 
2332 cd aa fd			call debug_vector  
2335				endm  
# End of macro CALLMONITOR
2335			endif	 
2335			 
2335			 
2335			if FORTH_ENABLE_DSPPOPFREE 
2335			 
2335				FORTH_DSP 
2335 cd 13 22			call macro_forth_dsp 
2338				endm 
# End of macro FORTH_DSP
2338			 
2338 7e				ld a, (hl) 
2339 fe 01			cp DS_TYPE_STR 
233b 20 22			jr nz, .skippopfree 
233d			 
233d				FORTH_DSP_VALUEHL 
233d cd 4d 22			call macro_dsp_valuehl 
2340				endm 
# End of macro FORTH_DSP_VALUEHL
2340			;	nop 
2340			if DEBUG_FORTH_DOT 
2340				DMARK "DPf" 
2340 f5				push af  
2341 3a 55 23			ld a, (.dmark)  
2344 32 a0 fd			ld (debug_mark),a  
2347 3a 56 23			ld a, (.dmark+1)  
234a 32 a1 fd			ld (debug_mark+1),a  
234d 3a 57 23			ld a, (.dmark+2)  
2350 32 a2 fd			ld (debug_mark+2),a  
2353 18 03			jr .pastdmark  
2355 ..			.dmark: db "DPf"  
2358 f1			.pastdmark: pop af  
2359			endm  
# End of macro DMARK
2359				CALLMONITOR 
2359 cd aa fd			call debug_vector  
235c				endm  
# End of macro CALLMONITOR
235c			endif	 
235c cd 83 14			call free 
235f			.skippopfree: 
235f				 
235f			 
235f			endif 
235f			 
235f			if DEBUG_FORTH_DOT_KEY 
235f				DMARK "DP2" 
235f				CALLMONITOR 
235f			endif	 
235f			 
235f				; move pointer down 
235f			 
235f 2a 23 f9			ld hl,(cli_data_sp) 
2362 2b				dec hl 
2363 2b				dec hl 
2364			; PARSEV5 
2364 2b				dec hl 
2365 22 23 f9			ld (cli_data_sp), hl 
2368			 
2368				if DEBUG_FORTH_STACK_GUARD 
2368 cd f2 70				call check_stacks 
236b					FORTH_CHK_DSP_UNDER 
236b e5				push hl 
236c d5				push de 
236d 2a 23 f9			ld hl,(cli_data_sp) 
2370 11 5d f6			ld de, cli_data_stack 
2373 cd fc 0f			call cmp16 
2376 da 03 72			jp c, fault_dsp_under 
2379 d1				pop de 
237a e1				pop hl 
237b				endm 
# End of macro FORTH_CHK_DSP_UNDER
237b				endif 
237b			 
237b e1				pop hl 
237c			 
237c c9				ret 
237d			 
237d			getwordathl: 
237d				; hl points to an address 
237d				; load hl with the word at that address 
237d			 
237d d5				push de 
237e			 
237e 5e				ld e, (hl) 
237f 23				inc hl 
2380 56				ld d, (hl) 
2381 eb				ex de, hl 
2382			 
2382 d1				pop de 
2383 c9				ret 
2384			 
2384			 
2384			; functions to manuplite stack pointers 
2384			 
2384			; generate fragment to set hl to be pointer to a stack item 
2384			 
2384			FORTH_DSP_PTR: macro  x 
2384				ld hl,(cli_data_sp) 
2384				ld de, x * 3 
2384				sbc hl, de 
2384				endm 
2384			 
2384			 
2384			 
2384			; copy point in hl to stack tmp storage slots 1-4 
2384			hltostack1: 
2384 11 f3 f0			ld de, os_stack_1  
2387 c3 b2 23			jp hltostackmv 
238a			 
238a			hltostack2:  
238a 11 f0 f0			ld de, os_stack_2 
238d c3 b2 23			jp hltostackmv 
2390			 
2390			hltostack3:  
2390 11 ed f0			ld de, os_stack_3 
2393 c3 b2 23			jp hltostackmv 
2396			 
2396			hltostack4:  
2396 11 ea f0			ld de, os_stack_4  
2399 c3 b2 23			jp hltostackmv 
239c			 
239c			; copy to point in hl from stack tmp storage slots 1-4 
239c			hlfromstack1: 
239c 11 f3 f0			ld de, os_stack_1 
239f c3 b1 23			jp hlfromsttackmv 
23a2			 
23a2			hlfromstack2:  
23a2 11 f0 f0			ld de, os_stack_2 
23a5 c3 b1 23			jp hlfromsttackmv 
23a8			 
23a8			hlfromstack3:  
23a8 11 ed f0			ld de, os_stack_3 
23ab c3 b1 23			jp hlfromsttackmv 
23ae			 
23ae			hlfromstack4:  
23ae 11 ea f0			ld de, os_stack_4 
23b1			 
23b1			hlfromsttackmv: 
23b1 eb				ex de, hl 
23b2			 
23b2			hltostackmv: 
23b2			 
23b2				; do stack move 
23b2 c5				push bc 
23b3 01 03 00			ld bc, 3 
23b6 ed b0			ldir  
23b8 c1				pop bc	 
23b9 c9				ret 
23ba			 
23ba			; eof 
23ba			 
# End of file forth_stackopsv5.asm
23ba			endif 
23ba			loadwordinhl:	 
23ba			 
23ba d5				push de 
23bb			 
23bb 5e				ld e, (hl) 
23bc 23				inc hl 
23bd 56				ld d, (hl) 
23be eb				ex de,hl  
23bf			 
23bf d1				pop de 
23c0			 
23c0 c9				ret 
23c1			 
23c1			user_word_eol:  
23c1				; hl contains the pointer to where to create a linked list item from the end 
23c1				; of the user dict to continue on at the system word dict 
23c1				 
23c1				; poke the stub of the word list linked list to repoint to rom words 
23c1			 
23c1				; stub format 
23c1				; db   word id 
23c1				; dw    link to next word 
23c1			        ; db char length of token 
23c1				; db string + 0 term 
23c1				; db exec code....  
23c1			 
23c1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c3 77				ld (hl), a		; word id 
23c4 23				inc hl 
23c5			 
23c5 11 7c 25			ld de, sysdict 
23c8 73				ld (hl), e		; next word link ie system dict 
23c9 23				inc hl 
23ca 72				ld (hl), d		; next word link ie system dict 
23cb 23				inc hl	 
23cc			 
23cc			;	ld (hl), sysdict		; next word link ie system dict 
23cc			;	inc hl 
23cc			;	inc hl 
23cc			 
23cc			;	inc hl 
23cc			;	inc hl 
23cc			 
23cc 3e 02			ld a, 2			; word length is 0 
23ce 77				ld (hl), a	 
23cf 23				inc hl 
23d0			 
23d0 3e 7e			ld a, '~'			; word length is 0 
23d2 77				ld (hl), a	 
23d3 23				inc hl 
23d4 3e 00			ld a, 0			; save empty word 
23d6 77				ld (hl), a 
23d7			 
23d7 c9				ret 
23d8			 
23d8				 
23d8			 
23d8			forthexec_cleanup: 
23d8				FORTH_RSP_POP 
23d8 cd 10 20			call macro_forth_rsp_pop 
23db				endm 
# End of macro FORTH_RSP_POP
23db c9				ret 
23dc			 
23dc			forth_call_hl: 
23dc				; taking hl 
23dc e5				push hl 
23dd c9				ret 
23de			 
23de			; this is called to reset Forth system but keep existing uwords etc 
23de			 
23de			forth_warmstart: 
23de				; setup stack over/under flow checks 
23de				if DEBUG_FORTH_STACK_GUARD 
23de cd d8 70				call chk_stk_init 
23e1				endif 
23e1			 
23e1				; init stack pointers  - * these stacks go upwards *  
23e1 21 e1 f8			ld hl, cli_ret_stack 
23e4 22 27 f9			ld (cli_ret_sp), hl	 
23e7				; set bottom of stack 
23e7 3e 00			ld a,0 
23e9 77				ld (hl),a 
23ea 23				inc hl 
23eb 77				ld (hl),a 
23ec			 
23ec 21 5d f6			ld hl, cli_data_stack 
23ef 22 23 f9			ld (cli_data_sp), hl	 
23f2				; set bottom of stack 
23f2 3e 00			ld a,0 
23f4 77				ld (hl),a 
23f5 23				inc hl 
23f6 77				ld (hl),a 
23f7			 
23f7 21 5f f8			ld hl, cli_loop_stack 
23fa 22 25 f9			ld (cli_loop_sp), hl	 
23fd				; set bottom of stack 
23fd 3e 00			ld a,0 
23ff 77				ld (hl),a 
2400 23				inc hl 
2401 77				ld (hl),a 
2402			 
2402				; init extent of current open file 
2402			 
2402 3e 00			ld a, 0 
2404 32 9f f9			ld (store_openext), a 
2407			 
2407 c9				ret 
2408			 
2408			 
2408			 
2408			; Cold Start - this is called to setup the whole Forth system 
2408			 
2408			forth_init: 
2408			 
2408				; setup stack over/under flow checks 
2408			 
2408			;	if DEBUG_FORTH_STACK_GUARD 
2408			;		call chk_stk_init 
2408			;	endif 
2408			 
2408				; enable auto display updates (slow.....) 
2408			 
2408 3e 01			ld a, 1 
240a 32 71 f9			ld (cli_autodisplay), a 
240d			 
240d				; if storage is in use disable long reads for now 
240d 3e 00			ld a, 0 
240f 32 aa f9			ld (store_longread), a 
2412			 
2412			 
2412				; show start up screen 
2412			 
2412 cd aa 0d			call clear_display 
2415			 
2415 3e 00			ld a,0 
2417 32 93 f9			ld (f_cursor_ptr), a 
241a			 
241a				; set start of word list in start of ram - for use when creating user words 
241a			 
241a 21 00 80			ld hl, baseram 
241d 22 f3 f3			ld (os_last_new_uword), hl 
2420 cd c1 23			call user_word_eol 
2423				 
2423			;		call display_data_sp 
2423			;		call next_page_prompt 
2423			 
2423			 
2423			 
2423			 
2423 c9				ret 
2424			 
2424 .. 00		.bootforth: db " Forth Kernel Init ",0 
2438			 
2438			; TODO push to stack 
2438			 
2438			;  
2438			 
2438			if FORTH_PARSEV2 
2438			 
2438			 
2438				include "forth_parserv2.asm" 
2438			 
2438			endif 
2438			 
2438			 
2438			; parse cli version 1 
2438			 
2438			if FORTH_PARSEV1 
2438			 
2438			 
2438			 
2438			      include "forth_parserv1.asm" 
2438			endif 
2438				 
2438			if FORTH_PARSEV3 
2438			      include "forth_parserv3.asm" 
2438				include "forth_wordsv3.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV4 
2438			      include "forth_parserv4.asm" 
2438				include "forth_wordsv4.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV5 
2438			      include "forth_parserv5.asm" 
2438				include "forth_wordsv4.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV6 
2438			      include "forth_parserv6.asm" 
2438			 
2438			 
2438			; A better parser without using malloc and string copies all over the place.  
2438			; Exec in situ should be faster 
2438			 
2438			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2438			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2438			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2438			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2438			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2438			WORD_SYS_END: equ 0   ; Opcode for all user words 
2438			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2438			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2438			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2438			 
2438			; Core word preamble macro 
2438			 
2438			CWHEAD:   macro nxtword opcode lit len opflags 
2438				db WORD_SYS_CORE+opcode             
2438				; internal op code number 
2438				dw nxtword            
2438				; link to next dict word block 
2438				db len + 1 
2438				; literal length of dict word inc zero term 
2438				db lit,0              
2438				; literal dict word 
2438			        ; TODO db opflags        
2438				endm 
2438			 
2438			 
2438			NEXTW: macro  
2438				jp macro_next 
2438				endm 
2438			 
2438			macro_next: 
2438			if DEBUG_FORTH_PARSE_EXEC 
2438				DMARK "NXT" 
2438				CALLMONITOR 
2438			endif	 
2438			;	inc hl  ; skip token null term  
2438 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243c ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2440 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2443			if DEBUG_FORTH_PARSE_EXEC 
2443				DMARK "}AA" 
2443				CALLMONITOR 
2443			endif	 
2443 c3 32 25			jp execnext 
2446				;jp exec1 
2446			       
2446			 
2446			 
2446			; Another go at the parser to compile  
2446			 
2446			 
2446			; TODO rework parser to change all of the string words to byte tokens 
2446			; TODO do a search for  
2446			 
2446			; TODO first run normal parser to zero term sections 
2446			; TODO for each word do a token look up to get the op code 
2446			; TODO need some means to flag to the exec that this is a byte code form    
2446			 
2446			 
2446			forthcompile: 
2446			 
2446			; 
2446			; line parse: 
2446			;       parse raw input buffer 
2446			;       tokenise the words 
2446			;       malloc new copy (for looping etc) 
2446			;       copy to malloc + current pc in line to start of string and add line term 
2446			;       save on new rsp 
2446			; 
2446			 
2446			; hl to point to the line to tokenise 
2446			 
2446			;	push hl 
2446 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2449			 
2449			;	ld a,0		; string term on input 
2449			;	call strlent 
2449			 
2449			;	ld (os_tok_len), hl	 ; save string length 
2449			 
2449			;if DEBUG_FORTH_TOK 
2449			;	ex de,hl		 
2449			;endif 
2449			 
2449			;	pop hl 		; get back string pointer 
2449			 
2449			if DEBUG_FORTH_TOK 
2449						DMARK "TOc" 
2449				CALLMONITOR 
2449			endif 
2449 7e			.cptoken2:    ld a,(hl) 
244a 23				inc hl 
244b fe 7f			cp FORTH_END_BUFFER 
244d 28 29			jr z, .cptokendone2 
244f fe 00			cp 0 
2451 28 25			jr z, .cptokendone2 
2453 fe 22			cp '"' 
2455 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2457 fe 20			cp ' ' 
2459 20 ee			jr nz,  .cptoken2 
245b			 
245b			; TODO consume comments held between ( and ) 
245b			 
245b				; we have a space so change to zero term for dict match later 
245b 2b				dec hl 
245c 3e 00			ld a,0 
245e 77				ld (hl), a 
245f 23				inc hl 
2460 18 e7			jr .cptoken2 
2462				 
2462			 
2462			.cptokenstr2: 
2462				; skip all white space until either eol (because forgot to term) or end double quote 
2462			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2462				;inc hl ; skip current double quote 
2462 7e				ld a,(hl) 
2463 23				inc hl 
2464 fe 22			cp '"' 
2466 28 e1			jr z, .cptoken2 
2468 fe 7f			cp FORTH_END_BUFFER 
246a 28 0c			jr z, .cptokendone2 
246c fe 00			cp 0 
246e 28 08			jr z, .cptokendone2 
2470 fe 20			cp ' ' 
2472 28 02			jr z, .cptmp2 
2474 18 ec			jr .cptokenstr2 
2476			 
2476			.cptmp2:	; we have a space so change to zero term for dict match later 
2476				;dec hl 
2476				;ld a,"-"	; TODO remove this when working 
2476				;ld (hl), a 
2476				;inc hl 
2476 18 ea			jr .cptokenstr2 
2478			 
2478			.cptokendone2: 
2478				;inc hl 
2478 3e 7f			ld a, FORTH_END_BUFFER 
247a 77				ld (hl),a 
247b			;	inc hl 
247b			;	ld a, '!' 
247b			;	ld (hl),a 
247b			 
247b 2a f7 f3			ld hl,(os_tok_ptr) 
247e			         
247e			if DEBUG_FORTH_TOK 
247e						DMARK "Tc1" 
247e				CALLMONITOR 
247e			endif 
247e			 
247e				; push exec string to top of return stack 
247e				FORTH_RSP_NEXT 
247e cd ef 1f			call macro_forth_rsp_next 
2481				endm 
# End of macro FORTH_RSP_NEXT
2481 c9				ret 
2482			 
2482			; Another go at the parser need to simplify the process 
2482			 
2482			forthparse: 
2482			 
2482			; 
2482			; line parse: 
2482			;       parse raw input buffer 
2482			;       tokenise the words 
2482			;       malloc new copy (for looping etc) 
2482			;       copy to malloc + current pc in line to start of string and add line term 
2482			;       save on new rsp 
2482			; 
2482			 
2482			; hl to point to the line to tokenise 
2482			 
2482			;	push hl 
2482 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2485			 
2485			;	ld a,0		; string term on input 
2485			;	call strlent 
2485			 
2485			;	ld (os_tok_len), hl	 ; save string length 
2485			 
2485			;if DEBUG_FORTH_TOK 
2485			;	ex de,hl		 
2485			;endif 
2485			 
2485			;	pop hl 		; get back string pointer 
2485			 
2485			if DEBUG_FORTH_TOK 
2485						DMARK "TOK" 
2485				CALLMONITOR 
2485			endif 
2485 7e			.ptoken2:    ld a,(hl) 
2486 23				inc hl 
2487 fe 7f			cp FORTH_END_BUFFER 
2489 28 29			jr z, .ptokendone2 
248b fe 00			cp 0 
248d 28 25			jr z, .ptokendone2 
248f fe 22			cp '"' 
2491 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2493 fe 20			cp ' ' 
2495 20 ee			jr nz,  .ptoken2 
2497			 
2497			; TODO consume comments held between ( and ) 
2497			 
2497				; we have a space so change to zero term for dict match later 
2497 2b				dec hl 
2498 3e 00			ld a,0 
249a 77				ld (hl), a 
249b 23				inc hl 
249c 18 e7			jr .ptoken2 
249e				 
249e			 
249e			.ptokenstr2: 
249e				; skip all white space until either eol (because forgot to term) or end double quote 
249e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
249e				;inc hl ; skip current double quote 
249e 7e				ld a,(hl) 
249f 23				inc hl 
24a0 fe 22			cp '"' 
24a2 28 e1			jr z, .ptoken2 
24a4 fe 7f			cp FORTH_END_BUFFER 
24a6 28 0c			jr z, .ptokendone2 
24a8 fe 00			cp 0 
24aa 28 08			jr z, .ptokendone2 
24ac fe 20			cp ' ' 
24ae 28 02			jr z, .ptmp2 
24b0 18 ec			jr .ptokenstr2 
24b2			 
24b2			.ptmp2:	; we have a space so change to zero term for dict match later 
24b2				;dec hl 
24b2				;ld a,"-"	; TODO remove this when working 
24b2				;ld (hl), a 
24b2				;inc hl 
24b2 18 ea			jr .ptokenstr2 
24b4			 
24b4			.ptokendone2: 
24b4				;inc hl 
24b4 3e 7f			ld a, FORTH_END_BUFFER 
24b6 77				ld (hl),a 
24b7			;	inc hl 
24b7			;	ld a, '!' 
24b7			;	ld (hl),a 
24b7			 
24b7 2a f7 f3			ld hl,(os_tok_ptr) 
24ba			         
24ba			if DEBUG_FORTH_TOK 
24ba						DMARK "TK1" 
24ba				CALLMONITOR 
24ba			endif 
24ba			 
24ba				; push exec string to top of return stack 
24ba				FORTH_RSP_NEXT 
24ba cd ef 1f			call macro_forth_rsp_next 
24bd				endm 
# End of macro FORTH_RSP_NEXT
24bd c9				ret 
24be			 
24be			; 
24be			;	; malloc size + buffer pointer + if is loop flag 
24be			;	ld hl,(os_tok_len) 		 ; get string length 
24be			; 
24be			;	ld a,l 
24be			; 
24be			;	cp 0			; we dont want to use a null string 
24be			;	ret z 
24be			; 
24be			;;	add 3    ; prefix malloc with buffer for current word ptr 
24be			; 
24be			;	add 5     ; TODO when certain not over writing memory remove 
24be			; 
24be			;		 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKE" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	ld l,a 
24be			;	ld h,0 
24be			;;	push hl   ; save required space for the copy later 
24be			;	call malloc 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKM" 
24be			;	CALLMONITOR 
24be			;endif 
24be			;	if DEBUG_FORTH_MALLOC_GUARD 
24be			;		push af 
24be			;		call ishlzero 
24be			;;		ld a, l 
24be			;;		add h 
24be			;;		cp 0 
24be			;		pop af 
24be			;		 
24be			;		call z,malloc_error 
24be			;	endif 
24be			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24be			; 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKR" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	FORTH_RSP_NEXT 
24be			; 
24be			;	;inc hl	 ; go past current buffer pointer 
24be			;	;inc hl 
24be			;	;inc hl   ; and past if loop flag 
24be			;		; TODO Need to set flag  
24be			; 
24be			;	 
24be			;	 
24be			;	ex de,hl	; malloc is dest 
24be			;	ld hl, (os_tok_len) 
24be			;;	pop bc 
24be			;	ld c, l                
24be			;	ld b,0 
24be			;	ld hl, (os_tok_ptr) 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKT" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	; do str cpy 
24be			; 
24be			;	ldir      ; copy byte in hl to de 
24be			; 
24be			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			; 
24be			;			DMARK "TKY" 
24be			;	CALLMONITOR 
24be			;endif 
24be			;	;ld a,0 
24be			;	;ld a,FORTH_END_BUFFER 
24be			;	ex de, hl 
24be			;	;dec hl			 ; go back over the space delim at the end of word 
24be			;	;ld (hl),a 
24be			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24be			;	ld a,FORTH_END_BUFFER 
24be			;	ld (hl),a 
24be			;	inc hl 
24be			;	ld a,FORTH_END_BUFFER 
24be			;	ld (hl),a 
24be			; 
24be			;	; init the malloc area data 
24be			;	; set pc for in current area 
24be			;	;ld hl, (os_tok_malloc) 
24be			;	;inc hl 
24be			;	;inc hl 
24be			;	;inc hl 
24be			;	;ex de,hl 
24be			;	;ld hl, (os_tok_malloc) 
24be			;	;ld (hl),e 
24be			;	;inc hl 
24be			;	;ld (hl),d 
24be			; 
24be			; 
24be			;	ld hl,(os_tok_malloc) 
24be			;if DEBUG_FORTH_PARSE_KEY 
24be			;			DMARK "TKU" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	ret 
24be			 
24be			forthexec: 
24be			 
24be			; line exec: 
24be			; forth parser 
24be			 
24be			; 
24be			;       get current exec line on rsp 
24be			 
24be				FORTH_RSP_TOS 
24be cd 06 20			call macro_forth_rsp_tos 
24c1				endm 
# End of macro FORTH_RSP_TOS
24c1			 
24c1			;       restore current pc - hl points to malloc of data 
24c1			 
24c1				;ld e, (hl) 
24c1				;inc hl 
24c1				;ld d, (hl) 
24c1				;ex de,hl 
24c1			 
24c1			 
24c1			exec1: 
24c1 22 f7 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
24c4			 
24c4				; copy our PC to working vars  
24c4 22 75 f9			ld (cli_ptr), hl                    ; here 
24c7 22 73 f9			ld (cli_origptr), hl                ; here 
24ca			 
24ca 7e				ld a,(hl)                           ; here make hl be the ram ptr 
24cb fe 7f			cp FORTH_END_BUFFER 
24cd c8				ret z 
24ce			 
24ce				; skip any nulls 
24ce			 
24ce fe 00			cp 0 
24d0 20 03			jr nz, .execword 
24d2 23				inc hl 
24d3 18 ec			jr exec1 
24d5			 
24d5			 
24d5			.execword: 
24d5			 
24d5			 
24d5			 
24d5			if DEBUG_FORTH_PARSE_EXEC 
24d5						DMARK "KYQ" 
24d5				CALLMONITOR 
24d5			endif 
24d5			;       while at start of word: 
24d5			; get start of dict (in user area first) 
24d5			 
24d5 21 00 80		ld hl, baseram 
24d8			;ld hl, sysdict 
24d8 22 77 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
24db			;           match word at pc 
24db			;           exec word 
24db			;           or push to dsp 
24db			;           forward to next token 
24db			;           if line term pop rsp and exit 
24db			;        
24db			 
24db			if DEBUG_FORTH_PARSE_EXEC 
24db						DMARK "KYq" 
24db				CALLMONITOR 
24db			endif 
24db			 
24db			; 
24db			; word comp 
24db			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24db			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24db			;    move to start of word  
24db			;    compare word to cli_token 
24db			 
24db			.execpnword:	; HL at start of a word in the dictionary to check 
24db			 
24db 2a 77 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
24de			 
24de cd 75 25			call forth_tok_next 
24e1			; tok next end here 
24e1 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24e4 eb				ex de, hl 
24e5			 
24e5			 
24e5				; save the pointer of the current token - 1 to check against 
24e5				 
24e5 22 7b f9			ld (cli_token), hl   
24e8				; TODO maybe remove below save if no debug 
24e8				; save token string ptr for any debug later 
24e8 23				inc hl  
24e9 22 7d f9			ld (cli_origtoken), hl 
24ec 2b				dec hl 
24ed				; save pointer to the start of the next dictionay word 
24ed 7e				ld a,(hl)   ; get string length 
24ee 47				ld b,a 
24ef			.execpnwordinc:  
24ef 23				inc hl 
24f0 10 fd			djnz .execpnwordinc 
24f2 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24f5			 
24f5				; now check the word token against the string being parsed 
24f5			 
24f5 2a 7b f9			ld hl,(cli_token) 
24f8 23				inc hl     ; skip string length (use zero term instead to end) 
24f9				;ld (cli_token), hl 
24f9			 
24f9			.execpnchar:    ; compare char between token and string to parse 
24f9			 
24f9			 
24f9				;ld hl, (cli_token)     ; the dict word  
24f9 ed 5b 75 f9		ld de, (cli_ptr)     ; cli to parse 
24fd			 
24fd			 
24fd			.execpncharl:    ; compare char between token and string to parse (loop) 
24fd			 
24fd 1a				ld a,(de) 
24fe cd 3b 13			call toUpper 		; make sure the input string matches case 
2501 be				cp (hl) 
2502			 
2502 c2 1b 25			jp nz, .execpnskipword	 ; no match so move to next word 
2505				 
2505			;    if same 
2505			;       scan for string terms 0 for token and 32 for input 
2505 46				ld b,(hl) 
2506 80				add b			 
2507 23				inc hl 
2508 13				inc de 
2509 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
250b							; TODO need to make sure last word in zero term string is accounted for 
250b 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
250d			 
250d			 
250d				; at end of both strings so both are exact match 
250d			 
250d			;       skip ptr for next word 
250d			 
250d 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2510 23				inc hl			 ; at next char 
2511 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2514 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2517				 
2517				 
2517			 
2517			 
2517			 
2517			;       exec code block 
2517			if DEBUG_FORTH_JP 
2517				call clear_display 
2517				call update_display 
2517				call delay1s 
2517				ld hl, (cli_execword)     ; save for next check if no match on this word 
2517				ld a,h 
2517				ld hl, os_word_scratch 
2517				call hexout 
2517				ld hl, (cli_execword)     ; save for next check if no match on this word 
2517				ld a,l 
2517				ld hl, os_word_scratch+2 
2517				call hexout 
2517				ld hl, os_word_scratch+4 
2517				ld a,0 
2517				ld (hl),a 
2517				ld de,os_word_scratch 
2517				call str_at_display 
2517					ld a, display_row_2 
2517					call str_at_display 
2517				ld de, (cli_origtoken) 
2517				ld a, display_row_1+10 
2517					call str_at_display 
2517			 
2517				ld a,display_row_1 
2517				ld de, .foundword 
2517				ld a, display_row_3 
2517				call str_at_display 
2517				call update_display 
2517				call delay1s 
2517				call delay1s 
2517				call delay1s 
2517			endif 
2517			 
2517			if DEBUG_FORTH_PARSE_EXEC 
2517						DMARK "KYj" 
2517			endif 
2517				; TODO save the word pointer in this exec 
2517			 
2517 2a 79 f9			ld hl,(cli_execword) 
251a e9				jp (hl) 
251b			 
251b			 
251b			;    if not same 
251b			;	scan for zero term 
251b			;	get ptr for next word 
251b			;	goto word comp 
251b			 
251b			.execpnskipword:	; get pointer to next word 
251b 2a 77 f9			ld hl,(cli_nextword) 
251e			 
251e 7e				ld a,(hl) 
251f fe 00			cp WORD_SYS_END 
2521			;	cp 0 
2521 28 09			jr z, .execendofdict			 ; at end of words 
2523			 
2523			if DEBUG_FORTH_PARSE_EXEC 
2523						DMARK "KY4" 
2523			endif 
2523			if DEBUG_FORTH_PARSE_EXEC 
2523			 
2523				; see if disabled 
2523			 
2523			;	ld a, (os_view_disable) 
2523			;	cp '*' 
2523				ld a,(debug_vector) 
2523				cp $c9   ; RET 
2523				jr z, .noskip 
2523			 
2523			 
2523				ld de, .nowordfound 
2523				ld a, display_row_3 
2523				call str_at_display 
2523				call update_display 
2523				ld a, 100 
2523				call aDelayInMS 
2523				 
2523				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2523					call delay250ms 
2523				endif 
2523			.noskip:  
2523			 
2523			endif	 
2523			 
2523 2a 73 f9			ld hl,(cli_origptr) 
2526 22 75 f9			ld (cli_ptr),hl 
2529			 
2529			if DEBUG_FORTH_PARSE_EXEC 
2529						DMARK "KY5" 
2529			endif 
2529 c3 db 24			jp .execpnword			; else go to next word 
252c			 
252c			.execendofdict:  
252c			 
252c			if DEBUG_FORTH_PARSE_EXEC 
252c						DMARK "KYe" 
252c			endif 
252c			if DEBUG_FORTH_PARSE_EXEC 
252c				; see if disabled 
252c			 
252c			;	ld a, (os_view_disable) 
252c			;	cp '*' 
252c				ld a,(debug_vector) 
252c				cp $c9   ; ret 
252c				jr z, .ispskip 
252c			 
252c				call clear_display 
252c				call update_display 
252c				call delay1s 
252c				ld de, (cli_origptr) 
252c				ld a, display_row_1 
252c				call str_at_display 
252c				 
252c				ld de, .enddict 
252c				ld a, display_row_3 
252c				call str_at_display 
252c				call update_display 
252c				ld a, 100 
252c				call aDelayInMS 
252c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
252c				call delay1s 
252c				call delay1s 
252c				call delay1s 
252c				endif 
252c			.ispskip:  
252c				 
252c			endif	 
252c			 
252c			 
252c			 
252c				; if the word is not a keyword then must be a literal so push it to stack 
252c			 
252c			; push token to stack to end of word 
252c			 
252c				STACKFRAME ON $1efe $2f9f 
252c				if DEBUG_STACK_IMB 
252c					if ON 
252c						exx 
252c						ld de, $1efe 
252c						ld a, d 
252c						ld hl, curframe 
252c						call hexout 
252c						ld a, e 
252c						ld hl, curframe+2 
252c						call hexout 
252c						ld hl, $1efe 
252c						push hl 
252c						ld hl, $2f9f 
252c						push hl 
252c						exx 
252c					endif 
252c				endif 
252c			endm 
# End of macro STACKFRAME
252c			 
252c 2a f7 f3		ld hl,(os_tok_ptr) 
252f cd b1 21		call forth_apush 
2532			 
2532				STACKFRAMECHK ON $1efe $2f9f 
2532				if DEBUG_STACK_IMB 
2532					if ON 
2532						exx 
2532						ld hl, $2f9f 
2532						pop de   ; $2f9f 
2532						call cmp16 
2532						jr nz, .spnosame 
2532						ld hl, $1efe 
2532						pop de   ; $1efe 
2532						call cmp16 
2532						jr z, .spfrsame 
2532						.spnosame: call showsperror 
2532						.spfrsame: nop 
2532						exx 
2532					endif 
2532				endif 
2532			endm 
# End of macro STACKFRAMECHK
2532			 
2532			execnext: 
2532			 
2532			if DEBUG_FORTH_PARSE_EXEC 
2532						DMARK "KY>" 
2532			endif 
2532			; move past token to next word 
2532			 
2532 2a f7 f3		ld hl, (os_tok_ptr) 
2535 3e 00		ld a, 0 
2537 01 ff 00		ld bc, 255     ; input buffer size 
253a ed b1		cpir 
253c			 
253c			if DEBUG_FORTH_PARSE_EXEC 
253c						DMARK "KY!" 
253c				CALLMONITOR 
253c			endif	 
253c			; TODO this might place hl on the null, so will need to forward on??? 
253c			;inc hl   ; see if this gets onto the next item 
253c			 
253c			 
253c			; TODO pass a pointer to the buffer to push 
253c			; TODO call function to push 
253c			 
253c			; look for end of input 
253c			 
253c			;inc hl 
253c			;ld a,(hl) 
253c			;cp FORTH_END_BUFFER 
253c			;ret z 
253c			 
253c			 
253c c3 c1 24		jp exec1 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			findnexttok: 
253f			 
253f				; hl is pointer to move 
253f				; de is the token to locate 
253f			 
253f					if DEBUG_FORTH 
253f						DMARK "NTK" 
253f						CALLMONITOR 
253f					endif 
253f d5				push de 
2540			 
2540			.fnt1:	 
2540				; find first char of token to locate 
2540			 
2540 1a				ld a, (de) 
2541 4f				ld c,a 
2542 7e				ld a,(hl) 
2543 cd 3b 13			call toUpper 
2546					if DEBUG_FORTH 
2546						DMARK "NT1" 
2546						CALLMONITOR 
2546					endif 
2546 b9				cp c 
2547			 
2547 28 03			jr z, .fnt2cmpmorefirst	 
2549			 
2549				; first char not found move to next char 
2549			 
2549 23				inc hl 
254a 18 f4			jr .fnt1 
254c			 
254c			.fnt2cmpmorefirst:	 
254c				; first char of token found.  
254c			 
254c e5				push hl     ; save start of token just in case it is the right one 
254d d9				exx 
254e e1				pop hl        ; save it to hl' 
254f d9				exx 
2550			 
2550			 
2550			.fnt2cmpmore:	 
2550				; compare the rest 
2550				 
2550 23				inc hl 
2551 13				inc de 
2552				 
2552 1a				ld a, (de) 
2553 4f				ld c,a 
2554 7e				ld a,(hl) 
2555 cd 3b 13			call toUpper 
2558			 
2558					if DEBUG_FORTH 
2558						DMARK "NT2" 
2558						CALLMONITOR 
2558					endif 
2558				; c has the token to find char 
2558				; a has the mem to scan char 
2558			 
2558 b9				cp c 
2559 28 04			jr z,.fntmatch1 
255b			 
255b				; they are not the same 
255b			 
255b					if DEBUG_FORTH 
255b						DMARK "NT3" 
255b						CALLMONITOR 
255b					endif 
255b d1				pop de	; reset de token to look for 
255c d5				push de 
255d 18 e1			jr .fnt1 
255f				 
255f			.fntmatch1: 
255f			 
255f				; is the same char a null which means we might have a full hit? 
255f					if DEBUG_FORTH 
255f						DMARK "NT4" 
255f						CALLMONITOR 
255f					endif 
255f			 
255f fe 00			cp 0 
2561 28 0b			jr z, .fntmatchyes 
2563			 
2563				; are we at the end of the token to find? 
2563			 
2563					if DEBUG_FORTH 
2563						DMARK "NT5" 
2563						CALLMONITOR 
2563					endif 
2563 3e 00			ld a, 0 
2565 b9				cp c 
2566			 
2566 c2 50 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2569			 
2569					if DEBUG_FORTH 
2569						DMARK "NT6" 
2569						CALLMONITOR 
2569					endif 
2569				; token to find is exhusted but no match to stream 
2569			 
2569				; restore tok pointer and continue on 
2569 d1				pop de 
256a d5				push de 
256b c3 40 25			jp .fnt1 
256e			 
256e			 
256e			.fntmatchyes: 
256e			 
256e				; hl now contains the end of the found token 
256e			 
256e				; get rid of saved token pointer to find 
256e			 
256e d1				pop de 
256f			 
256f					if DEBUG_FORTH 
256f						DMARK "NT9" 
256f						CALLMONITOR 
256f					endif 
256f			 
256f				; hl will be on the null term so forward on 
256f			 
256f				; get back the saved start of the token 
256f			 
256f d9				exx 
2570 e5				push hl     ; save start of token just in case it is the right one 
2571 d9				exx 
2572 e1				pop hl        ; save it to hl 
2573			 
2573 c9				ret 
2574			 
2574			 
2574			; LIST needs to find a specific token   
2574			; FORGET needs to find a spefici token 
2574			 
2574			; SAVE needs to find all tokens by flag 
2574			; WORDS just needs to scan through all  by flag 
2574			; UWORDS needs to scan through all by flag 
2574			 
2574			 
2574			; given hl as pointer to start of dict look up string 
2574			; return hl as pointer to start of word block 
2574			; or 0 if not found 
2574			 
2574			forth_find_tok: 
2574 c9				ret 
2575			 
2575			; given hl as pointer to dict structure 
2575			; move to the next dict block structure 
2575			 
2575			forth_tok_next: 
2575				; hl now points to the address of the next word pointer  
2575				; TODO skip compiled symbol for now 
2575			;	push de 
2575 23				inc hl 
2576 5e				ld e, (hl) 
2577 23				inc hl 
2578 56				ld d, (hl) 
2579 23				inc hl 
257a			 
257a eb				ex de,hl 
257b			if DEBUG_FORTH_PARSE_NEXTWORD 
257b				push bc 
257b				ld bc, (cli_nextword) 
257b						DMARK "NXW" 
257b				CALLMONITOR 
257b				pop bc 
257b			endif 
257b			;	pop de	 
257b c9				ret 
257c			 
257c			 
257c			 
257c			; eof 
# End of file forth_parserv6.asm
257c				include "forth_wordsv4.asm" 
257c			 
257c			; the core word dictionary v4 
257c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
257c			 
257c			; this is a linked list for each of the system words used 
257c			; user defined words will follow the same format but will be in ram 
257c			 
257c			 
257c			; 
257c			; 
257c			; define linked list: 
257c			; 
257c			; 1. compiled byte op code 
257c			; 2. len of text word 
257c			; 3. text word 
257c			; 4. ptr to next dictionary word 
257c			; 5. asm, calls etc for the word 
257c			; 
257c			;  if 1 == 0 then last word in dict  
257c			;   
257c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
257c			;  
257c			;  
257c			; create basic standard set of words 
257c			; 
257c			;  
257c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
257c			; 2DUP 2DROP 2SWAP  
257c			; @ C@ - get byte  
257c			; ! C! - store byte 
257c			; 0< true if less than zero 
257c			; 0= true if zero 
257c			; < >  
257c			; = true if same 
257c			; variables 
257c			 
257c			 
257c			; Hardware specific words I may need 
257c			; 
257c			; IN OUT  
257c			; calls to key util functions 
257c			; calls to hardward abstraction stuff 
257c			; easy control of frame buffers and lcd i/o 
257c			; keyboard  
257c			 
257c			 
257c			;DICT: macro 
257c			; op_code, len, word, next 
257c			;    word: 
257c			;    db op_code 
257c			;    ds word zero term 
257c			;    dw next 
257c			;    endm 
257c			 
257c			 
257c			 
257c			 
257c			; op code 1 is a flag for user define words which are to be handled differently 
257c			 
257c			 
257c			; 
257c			; 
257c			;    TODO on entry to a word this should be the expected environment 
257c			;    hl - tos value if number then held, if string this is the ptr 
257c			;    de -  
257c			 
257c			 
257c			; opcode ranges 
257c			; 0 - end of word dict 
257c			; 255 - user define words 
257c			 
257c			sysdict: 
257c			include "forth_opcodes.asm" 
257c			; op codes for forth keywords 
257c			 
257c			; Changing use of opcodes to flag is the word exists in compiled form or not.  
257c			; This provides a means to compile uwords if required for higher performance 
257c			; by avoiding the use of the keyword parser and just jumping directly to the code 
257c			; Actually there is already a flag for if the code exists as binary thinking about it... 
257c			 
257c			 
257c			 
257c			 
257c			 
257c			; free to use code 0  
257c				OPCODE_HEAP: equ  1 
257c				OPCODE_EXEC: equ 2 
257c				OPCODE_DUP: equ 3 
257c				OPCODE_SWAP: equ 4 
257c				OPCODE_COLN: equ 5 
257c				OPCODE_SCOLN: equ 6 
257c				OPCODE_DROP: equ 7 
257c				OPCODE_DUP2: equ 8 
257c				OPCODE_DROP2: equ 9 
257c				OPCODE_SWAP2: equ 10 
257c				OPCODE_AT: equ 11 
257c				OPCODE_CAT: equ 12 
257c				OPCODE_BANG: equ 13 
257c				OPCODE_CBANG: equ 14 
257c				OPCODE_SCALL: equ 15 
257c				OPCODE_DEPTH: equ 16 
257c				OPCODE_OVER: equ 17 
257c				OPCODE_PAUSE: equ 18 
257c				OPCODE_PAUSES: equ 19 
257c				OPCODE_ROT: equ 20 
257c			;free to reuse	OPCODE_WORDS: equ 21 
257c			        OPCODE_NOT: equ 21 
257c				OPCODE_UWORDS: equ 22 
257c				OPCODE_BP: equ 23 
257c				OPCODE_MONITOR: equ 24  
257c				OPCODE_MALLOC: equ 25 
257c				OPCODE_FREE: equ 26 
257c				OPCODE_LIST: equ 27 
257c				OPCODE_FORGET: equ 28 
257c				OPCODE_NOP: equ 29 
257c				OPCODE_COMO: equ 30 
257c				OPCODE_COMC: equ 31 
257c			;free to reuse	OPCODE_ENDCORE: equ 32 
257c				OPCODE_AFTERSOUND: equ 33 
257c				OPCODE_GP2: equ 34 
257c				OPCODE_GP3: equ 35 
257c				OPCODE_GP4: equ 36 
257c				OPCODE_SIN: equ 37 
257c				OPCODE_SOUT: equ 38 
257c				OPCODE_SPIO: equ 39 
257c				OPCODE_SPICEH: equ 40 
257c				OPCODE_SPIOb: equ 41 
257c				OPCODE_SPII: equ 42 
257c				OPCODE_SESEL: equ 43 
257c				OPCODE_CARTDEV: equ 44 
257c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
257c				OPCODE_FB: equ 46 
257c				OPCODE_EMIT: equ 47 
257c				OPCODE_DOTH: equ 48 
257c				OPCODE_DOTF: equ 49 
257c				OPCODE_DOT: equ 50 
257c				OPCODE_CLS: equ 51 
257c				OPCODE_DRAW: equ 52 
257c				OPCODE_DUMP: equ 53 
257c				OPCODE_CDUMP: equ 54 
257c				OPCODE_DAT: equ 55 
257c				OPCODE_HOME: equ 56 
257c				OPCODE_SPACE: equ 57 
257c				OPCODE_SPACES: equ 58 
257c				OPCODE_SCROLL: equ 59 
257c				OPCODE_ATQ: equ 60 
257c				OPCODE_AUTODSP: equ 61 
257c				OPCODE_MENU: equ 62 
257c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
257c				OPCODE_THEN: equ 64 
257c				OPCODE_ELSE: equ 65 
257c				OPCODE_DO: equ 66 
257c				OPCODE_LOOP: equ 67 
257c				OPCODE_I: equ 68 
257c				OPCODE_DLOOP: equ 69  
257c				OPCODE_REPEAT: equ 70  
257c				OPCODE_UNTIL: equ 71 
257c				OPCODE_ENDFLOW: equ 72 
257c				OPCODE_WAITK: equ 73 
257c				OPCODE_ACCEPT: equ 74 
257c				OPCODE_EDIT: equ 75 
257c			;free to reuse	OPCODE_ENDKEY: equ 76 
257c				OPCODE_LZERO: equ 77 
257c				OPCODE_TZERO: equ 78 
257c				OPCODE_LESS: equ 79 
257c				OPCODE_GT: equ 80 
257c				OPCODE_EQUAL: equ 81  
257c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
257c				OPCODE_NEG: equ 83 
257c				OPCODE_DIV: equ 84 
257c				OPCODE_MUL: equ 85 
257c				OPCODE_MIN: equ 86 
257c				OPCODE_MAX: equ 87 
257c				OPCODE_RND16: equ 88 
257c				OPCODE_RND8: equ 89 
257c				OPCODE_RND: equ 90 
257c			;free to reuse	OPCODE_ENDMATHS: equ 91  
257c				OPCODE_BYNAME: equ 92 
257c				OPCODE_DIR: equ 93 
257c				OPCODE_SAVE: equ 94 
257c				OPCODE_LOAD: equ 95 
257c				OPCODE_BSAVE: equ 96 
257c				OPCODE_BLOAD: equ 97 
257c				OPCODE_SEO: equ 98  
257c				OPCODE_SEI: equ 99 
257c				OPCODE_SFREE: equ 100 
257c				OPCODE_SIZE: equ 101 
257c				OPCODE_CREATE: equ 102 
257c				OPCODE_APPEND: equ 103 
257c				OPCODE_SDEL: equ 104 
257c				OPCODE_OPEN: equ 105 
257c				OPCODE_READ: equ 106 
257c				OPCODE_EOF: equ 106 
257c				OPCODE_FORMAT: equ 107 
257c				OPCODE_LABEL: equ 108 
257c				OPCODE_LABELS: equ 109 
257c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
257c				OPCODE_UPPER: equ 111 
257c				OPCODE_LOWER: equ 112 
257c				OPCODE_SUBSTR: equ 113 
257c				OPCODE_LEFT: equ 114 
257c				OPCODE_RIGHT: equ 115 
257c				OPCODE_STR2NUM: equ 116 
257c				OPCODE_NUM2STR: equ 117 
257c				OPCODE_CONCAT: equ 118 
257c				OPCODE_FIND: equ 119 
257c				OPCODE_LEN: equ 120 
257c				OPCODE_CHAR: equ 121 
257c			; free to reuse	OPCODE_STRLEN: equ 122 
257c			; free to reuse	OPCODE_ENDSTR: equ 123 
257c				OPCODE_V0S: equ 124 
257c				OPCODE_V0Q: equ 125 
257c				OPCODE_V1S: equ 126 
257c				OPCODE_V1Q: equ 127 
257c				OPCODE_V2S: equ 128 
257c				OPCODE_V2Q: equ 129 
257c				OPCODE_V3S: equ 130 
257c				OPCODE_V3Q: equ 131 
257c			;free to reuse	OPCODE_END: equ 132 
257c				OPCODE_ZDUP: equ 133 
257c			 
257c			; eof 
# End of file forth_opcodes.asm
257c			 
257c			include "forth_words_core.asm" 
257c			 
257c			; | ## Core Words 
257c			 
257c			;if MALLOC_4 
257c			 
257c			.HEAP: 
257c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
257c 15				db WORD_SYS_CORE+OPCODE_HEAP             
257d bb 25			dw .EXEC            
257f 05				db 4 + 1 
2580 .. 00			db "HEAP",0              
2585				endm 
# End of macro CWHEAD
2585			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2585			; | | u1 - Current number of bytes in the heap 
2585			; | | u2 - Remaining bytes left on the heap 
2585			; | |  
2585			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2585			 
2585			 
2585				if DEBUG_FORTH_WORDS_KEY 
2585					DMARK "HEP" 
2585 f5				push af  
2586 3a 9a 25			ld a, (.dmark)  
2589 32 a0 fd			ld (debug_mark),a  
258c 3a 9b 25			ld a, (.dmark+1)  
258f 32 a1 fd			ld (debug_mark+1),a  
2592 3a 9c 25			ld a, (.dmark+2)  
2595 32 a2 fd			ld (debug_mark+2),a  
2598 18 03			jr .pastdmark  
259a ..			.dmark: db "HEP"  
259d f1			.pastdmark: pop af  
259e			endm  
# End of macro DMARK
259e					CALLMONITOR 
259e cd aa fd			call debug_vector  
25a1				endm  
# End of macro CALLMONITOR
25a1				endif 
25a1 2a 0a 80			ld hl, (free_list )      
25a4 11 0e 80			ld de, heap_start 
25a7			 
25a7 ed 52			sbc hl, de  
25a9			 
25a9 cd 48 20			call forth_push_numhl 
25ac			 
25ac			 
25ac ed 5b 0a 80		ld de, (free_list )      
25b0 21 d1 f0			ld hl, heap_end 
25b3			 
25b3 ed 52			sbc hl, de 
25b5			 
25b5 cd 48 20			call forth_push_numhl 
25b8				 
25b8			 
25b8				 
25b8			 
25b8			 
25b8			 
25b8				NEXTW 
25b8 c3 38 24			jp macro_next 
25bb				endm 
# End of macro NEXTW
25bb			;endif 
25bb			 
25bb			.EXEC: 
25bb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25bb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25bb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25bb			;; > > 
25bb			;; > >   
25bb			;	STACKFRAME OFF $5efe $5f9f 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "EXE" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	FORTH_DSP_POP 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX1" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;;	ld e,(hl) 
25bb			;;	inc hl 
25bb			;;	ld d,(hl) 
25bb			;;	ex de,hl 
25bb			; 
25bb			;;		if DEBUG_FORTH_WORDS 
25bb			;;			DMARK "EX2" 
25bb			;;			CALLMONITOR 
25bb			;;		endif 
25bb			;	push hl 
25bb			; 
25bb			;	;ld a, 0 
25bb			;	;ld a, FORTH_END_BUFFER 
25bb			;	call strlenz 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include term 
25bb			;	inc hl   ; include term 
25bb			;	ld b,0 
25bb			;	ld c,l 
25bb			;	pop hl 
25bb			;	ld de, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir 
25bb			; 
25bb			; 
25bb			;	ld hl, execscratch 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXe" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	call forthexec 
25bb			;;	call forthexec_cleanup 
25bb			;;	call forthparse 
25bb			;;	call forthexec 
25bb			; 
25bb			;	STACKFRAMECHK OFF $5efe $5f9f 
25bb			; 
25bb			;	; an immediate word so no need to process any more words 
25bb			;	ret 
25bb			;	NEXTW 
25bb			 
25bb			; dead code - old version  
25bb			;	FORTH_RSP_NEXT 
25bb			 
25bb			;  
25bb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25bb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25bb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25bb			;	push hl 
25bb			;	push de 
25bb			;	push bc 
25bb			; 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "EXR" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			; 
25bb			; 
25bb			;	;v5 FORTH_DSP_VALUE 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	; TODO do string type checks 
25bb			; 
25bb			;;v5	inc hl   ; skip type 
25bb			; 
25bb			;	push hl  ; source code  
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX1" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ld a, 0 
25bb			;	call strlent 
25bb			; 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			; 
25bb			;	push hl    ; size 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX2" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	call malloc 
25bb			; 
25bb			;	ex de, hl    ; de now contains malloc area 
25bb			;	pop bc   	; get byte count 
25bb			;	pop hl      ; get string to copy 
25bb			; 
25bb			;	push de     ; save malloc for free later 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir       ; duplicate string 
25bb			; 
25bb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25bb			;	 
25bb			;	; TODO fix the parse would be better than this...  
25bb			;	ex de, hl 
25bb			;	dec hl 
25bb			;	ld a, 0 
25bb			;	ld (hl), a 
25bb			;	dec hl 
25bb			;	ld a, ' ' 
25bb			;	ld (hl), a 
25bb			;	dec hl 
25bb			;	ld (hl), a 
25bb			; 
25bb			;	dec hl 
25bb			;	ld (hl), a 
25bb			; 
25bb			; 
25bb			;	FORTH_DSP_POP  
25bb			; 
25bb			;	pop hl     
25bb			;	push hl    ; save malloc area 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX4" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	call forthexec 
25bb			;	 
25bb			;	pop hl 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX5" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			; 
25bb			;	if FORTH_ENABLE_FREE 
25bb			;	call free 
25bb			;	endif 
25bb			; 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX6" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			; 
25bb			;	pop bc 
25bb			;	pop de 
25bb			;	pop hl 
25bb			;;	FORTH_RSP_POP	  
25bb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25bb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25bb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25bb			; 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX7" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			;	NEXTW 
25bb			 
25bb			;.STKEXEC: 
25bb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25bb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25bb			; 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "STX" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	ld (store_tmp1), hl    ; count 
25bb			; 
25bb			;	FORTH_DSP_POP 
25bb			;.stkexec1: 
25bb			;	ld hl, (store_tmp1)   ; count 
25bb			;	ld a, 0 
25bb			;	cp l 
25bb			;	ret z 
25bb			; 
25bb			;	dec hl 
25bb			;	ld (store_tmp1), hl    ; count 
25bb			;	 
25bb			;	FORTH_DSP_VALUEHL 
25bb			;	push hl 
25bb			;	 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXp" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	FORTH_DSP_POP 
25bb			; 
25bb			;	call strlenz 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	ld b,0 
25bb			;	ld c,l 
25bb			;	pop hl 
25bb			;	ld de, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir 
25bb			; 
25bb			; 
25bb			;	ld hl, execscratch 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXP" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	ld hl, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXx" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	call forthexec 
25bb			; 
25bb			;	jp .stkexec1 
25bb			; 
25bb			;	ret 
25bb			 
25bb			 
25bb			.DUP: 
25bb			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25bb 17				db WORD_SYS_CORE+OPCODE_DUP             
25bc 31 26			dw .ZDUP            
25be 04				db 3 + 1 
25bf .. 00			db "DUP",0              
25c3				endm 
# End of macro CWHEAD
25c3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25c3			 
25c3				if DEBUG_FORTH_WORDS_KEY 
25c3					DMARK "DUP" 
25c3 f5				push af  
25c4 3a d8 25			ld a, (.dmark)  
25c7 32 a0 fd			ld (debug_mark),a  
25ca 3a d9 25			ld a, (.dmark+1)  
25cd 32 a1 fd			ld (debug_mark+1),a  
25d0 3a da 25			ld a, (.dmark+2)  
25d3 32 a2 fd			ld (debug_mark+2),a  
25d6 18 03			jr .pastdmark  
25d8 ..			.dmark: db "DUP"  
25db f1			.pastdmark: pop af  
25dc			endm  
# End of macro DMARK
25dc					CALLMONITOR 
25dc cd aa fd			call debug_vector  
25df				endm  
# End of macro CALLMONITOR
25df				endif 
25df			 
25df				FORTH_DSP 
25df cd 13 22			call macro_forth_dsp 
25e2				endm 
# End of macro FORTH_DSP
25e2			 
25e2 7e				ld a, (HL) 
25e3 fe 01			cp DS_TYPE_STR 
25e5 20 25			jr nz, .dupinum 
25e7			 
25e7				; push another string 
25e7			 
25e7				FORTH_DSP_VALUEHL     		 
25e7 cd 4d 22			call macro_dsp_valuehl 
25ea				endm 
# End of macro FORTH_DSP_VALUEHL
25ea			 
25ea			if DEBUG_FORTH_WORDS 
25ea				DMARK "DUs" 
25ea f5				push af  
25eb 3a ff 25			ld a, (.dmark)  
25ee 32 a0 fd			ld (debug_mark),a  
25f1 3a 00 26			ld a, (.dmark+1)  
25f4 32 a1 fd			ld (debug_mark+1),a  
25f7 3a 01 26			ld a, (.dmark+2)  
25fa 32 a2 fd			ld (debug_mark+2),a  
25fd 18 03			jr .pastdmark  
25ff ..			.dmark: db "DUs"  
2602 f1			.pastdmark: pop af  
2603			endm  
# End of macro DMARK
2603				CALLMONITOR 
2603 cd aa fd			call debug_vector  
2606				endm  
# End of macro CALLMONITOR
2606			endif 
2606 cd b6 20			call forth_push_str 
2609			 
2609				NEXTW 
2609 c3 38 24			jp macro_next 
260c				endm 
# End of macro NEXTW
260c			 
260c			 
260c			.dupinum: 
260c				 
260c			 
260c			 
260c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260c cd 4d 22			call macro_dsp_valuehl 
260f				endm 
# End of macro FORTH_DSP_VALUEHL
260f			 
260f			; TODO add floating point number detection 
260f			 
260f			if DEBUG_FORTH_WORDS 
260f				DMARK "DUi" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 a0 fd			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 a1 fd			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 a2 fd			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "DUi"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628				CALLMONITOR 
2628 cd aa fd			call debug_vector  
262b				endm  
# End of macro CALLMONITOR
262b			endif 
262b			 
262b cd 48 20			call forth_push_numhl 
262e				NEXTW 
262e c3 38 24			jp macro_next 
2631				endm 
# End of macro NEXTW
2631			.ZDUP: 
2631			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2631 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2632 69 26			dw .DMRK            
2634 05				db 4 + 1 
2635 .. 00			db "?DUP",0              
263a				endm 
# End of macro CWHEAD
263a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
263a			 
263a				if DEBUG_FORTH_WORDS_KEY 
263a					DMARK "qDU" 
263a f5				push af  
263b 3a 4f 26			ld a, (.dmark)  
263e 32 a0 fd			ld (debug_mark),a  
2641 3a 50 26			ld a, (.dmark+1)  
2644 32 a1 fd			ld (debug_mark+1),a  
2647 3a 51 26			ld a, (.dmark+2)  
264a 32 a2 fd			ld (debug_mark+2),a  
264d 18 03			jr .pastdmark  
264f ..			.dmark: db "qDU"  
2652 f1			.pastdmark: pop af  
2653			endm  
# End of macro DMARK
2653					CALLMONITOR 
2653 cd aa fd			call debug_vector  
2656				endm  
# End of macro CALLMONITOR
2656				endif 
2656				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2656 cd 4d 22			call macro_dsp_valuehl 
2659				endm 
# End of macro FORTH_DSP_VALUEHL
2659			 
2659 e5				push hl 
265a			 
265a				; is it a zero? 
265a			 
265a 3e 00			ld a, 0 
265c 84				add h 
265d 85				add l 
265e			 
265e e1				pop hl 
265f			 
265f fe 00			cp 0 
2661 28 03			jr z, .dup2orig 
2663			 
2663			 
2663 cd 48 20			call forth_push_numhl 
2666			 
2666			 
2666			; TODO add floating point number detection 
2666			 
2666			.dup2orig: 
2666			 
2666				NEXTW 
2666 c3 38 24			jp macro_next 
2669				endm 
# End of macro NEXTW
2669			.DMRK: 
2669			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
2669 99				db WORD_SYS_CORE+OPCODE_ZDUP             
266a a6 26			dw .LSHIFT            
266c 06				db 5 + 1 
266d .. 00			db "DMARK",0              
2673				endm 
# End of macro CWHEAD
2673			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
2673			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
2673				if DEBUG_FORTH_WORDS_KEY 
2673					DMARK "DMK" 
2673 f5				push af  
2674 3a 88 26			ld a, (.dmark)  
2677 32 a0 fd			ld (debug_mark),a  
267a 3a 89 26			ld a, (.dmark+1)  
267d 32 a1 fd			ld (debug_mark+1),a  
2680 3a 8a 26			ld a, (.dmark+2)  
2683 32 a2 fd			ld (debug_mark+2),a  
2686 18 03			jr .pastdmark  
2688 ..			.dmark: db "DMK"  
268b f1			.pastdmark: pop af  
268c			endm  
# End of macro DMARK
268c					CALLMONITOR 
268c cd aa fd			call debug_vector  
268f				endm  
# End of macro CALLMONITOR
268f				endif 
268f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268f cd 4d 22			call macro_dsp_valuehl 
2692				endm 
# End of macro FORTH_DSP_VALUEHL
2692			 
2692 7e				ld a, (hl) 
2693 32 a0 fd			ld (debug_mark),a 
2696 23				inc hl 
2697 7e				ld a, (hl) 
2698 32 a1 fd			ld (debug_mark+1),a 
269b 23				inc hl 
269c 7e				ld a, (hl) 
269d 32 a2 fd			ld (debug_mark+2),a 
26a0			 
26a0			 
26a0				FORTH_DSP_POP 
26a0 cd 05 23			call macro_forth_dsp_pop 
26a3				endm 
# End of macro FORTH_DSP_POP
26a3				NEXTW 
26a3 c3 38 24			jp macro_next 
26a6				endm 
# End of macro NEXTW
26a6			.LSHIFT: 
26a6			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
26a6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26a7 da 26			dw .RSHIFT            
26a9 07				db 6 + 1 
26aa .. 00			db "LSHIFT",0              
26b1				endm 
# End of macro CWHEAD
26b1			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
26b1				if DEBUG_FORTH_WORDS_KEY 
26b1					DMARK "LSH" 
26b1 f5				push af  
26b2 3a c6 26			ld a, (.dmark)  
26b5 32 a0 fd			ld (debug_mark),a  
26b8 3a c7 26			ld a, (.dmark+1)  
26bb 32 a1 fd			ld (debug_mark+1),a  
26be 3a c8 26			ld a, (.dmark+2)  
26c1 32 a2 fd			ld (debug_mark+2),a  
26c4 18 03			jr .pastdmark  
26c6 ..			.dmark: db "LSH"  
26c9 f1			.pastdmark: pop af  
26ca			endm  
# End of macro DMARK
26ca					CALLMONITOR 
26ca cd aa fd			call debug_vector  
26cd				endm  
# End of macro CALLMONITOR
26cd				endif 
26cd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26cd cd 4d 22			call macro_dsp_valuehl 
26d0				endm 
# End of macro FORTH_DSP_VALUEHL
26d0				FORTH_DSP_POP 
26d0 cd 05 23			call macro_forth_dsp_pop 
26d3				endm 
# End of macro FORTH_DSP_POP
26d3			 
26d3 29				add hl, hl 
26d4 cd 48 20			call forth_push_numhl 
26d7				NEXTW 
26d7 c3 38 24			jp macro_next 
26da				endm 
# End of macro NEXTW
26da			.RSHIFT: 
26da			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
26da 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26db 11 27			dw .SWAP            
26dd 07				db 6 + 1 
26de .. 00			db "RSHIFT",0              
26e5				endm 
# End of macro CWHEAD
26e5			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
26e5				if DEBUG_FORTH_WORDS_KEY 
26e5					DMARK "RSH" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 a0 fd			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 a1 fd			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 a2 fd			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "RSH"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe					CALLMONITOR 
26fe cd aa fd			call debug_vector  
2701				endm  
# End of macro CALLMONITOR
2701				endif 
2701				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2701 cd 4d 22			call macro_dsp_valuehl 
2704				endm 
# End of macro FORTH_DSP_VALUEHL
2704				FORTH_DSP_POP 
2704 cd 05 23			call macro_forth_dsp_pop 
2707				endm 
# End of macro FORTH_DSP_POP
2707 cb 3c			srl h 
2709 cb 1d			rr l 
270b cd 48 20			call forth_push_numhl 
270e				NEXTW 
270e c3 38 24			jp macro_next 
2711				endm 
# End of macro NEXTW
2711			.SWAP: 
2711			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2711 18				db WORD_SYS_CORE+OPCODE_SWAP             
2712 65 27			dw .COLN            
2714 05				db 4 + 1 
2715 .. 00			db "SWAP",0              
271a				endm 
# End of macro CWHEAD
271a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
271a				if DEBUG_FORTH_WORDS_KEY 
271a					DMARK "SWP" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 a0 fd			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 a1 fd			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 a2 fd			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "SWP"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733					CALLMONITOR 
2733 cd aa fd			call debug_vector  
2736				endm  
# End of macro CALLMONITOR
2736				endif 
2736			 
2736			; DONE Use os stack swap memory 
2736			 
2736				FORTH_DSP_PTR 0     ; TOS 
2736 2a 23 f9			ld hl,(cli_data_sp) 
2739 11 00 00			ld de, 0 * 3 
273c ed 52			sbc hl, de 
273e				endm 
# End of macro FORTH_DSP_PTR
273e cd 84 23			call hltostack1 
2741			  
2741				FORTH_DSP_PTR 1     ; TOS 
2741 2a 23 f9			ld hl,(cli_data_sp) 
2744 11 03 00			ld de, 1 * 3 
2747 ed 52			sbc hl, de 
2749				endm 
# End of macro FORTH_DSP_PTR
2749 cd 8a 23			call hltostack2 
274c			 
274c				FORTH_DSP_PTR 0     ; TOS 
274c 2a 23 f9			ld hl,(cli_data_sp) 
274f 11 00 00			ld de, 0 * 3 
2752 ed 52			sbc hl, de 
2754				endm 
# End of macro FORTH_DSP_PTR
2754 cd a2 23			call hlfromstack2 
2757			 
2757				FORTH_DSP_PTR 1     ; TOS 
2757 2a 23 f9			ld hl,(cli_data_sp) 
275a 11 03 00			ld de, 1 * 3 
275d ed 52			sbc hl, de 
275f				endm 
# End of macro FORTH_DSP_PTR
275f cd 9c 23			call hlfromstack1 
2762			;	FORTH_DSP_VALUEHL 
2762			;	push hl     ; w2 
2762			; 
2762			;	FORTH_DSP_POP 
2762			; 
2762			;	FORTH_DSP_VALUEHL 
2762			; 
2762			;	FORTH_DSP_POP 
2762			; 
2762			;	pop de     ; w2	, hl = w1 
2762			; 
2762			;	ex de, hl 
2762			;	push de 
2762			; 
2762			;	call forth_push_numhl 
2762			; 
2762			;	pop hl 
2762			; 
2762			;	call forth_push_numhl 
2762				 
2762			 
2762				NEXTW 
2762 c3 38 24			jp macro_next 
2765				endm 
# End of macro NEXTW
2765			.COLN: 
2765			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2765 19				db WORD_SYS_CORE+OPCODE_COLN             
2766 f1 28			dw .SCOLN            
2768 02				db 1 + 1 
2769 .. 00			db ":",0              
276b				endm 
# End of macro CWHEAD
276b			; | : ( -- )         Create new word | DONE 
276b			 
276b				if DEBUG_FORTH_WORDS_KEY 
276b					DMARK "CLN" 
276b f5				push af  
276c 3a 80 27			ld a, (.dmark)  
276f 32 a0 fd			ld (debug_mark),a  
2772 3a 81 27			ld a, (.dmark+1)  
2775 32 a1 fd			ld (debug_mark+1),a  
2778 3a 82 27			ld a, (.dmark+2)  
277b 32 a2 fd			ld (debug_mark+2),a  
277e 18 03			jr .pastdmark  
2780 ..			.dmark: db "CLN"  
2783 f1			.pastdmark: pop af  
2784			endm  
# End of macro DMARK
2784					CALLMONITOR 
2784 cd aa fd			call debug_vector  
2787				endm  
# End of macro CALLMONITOR
2787				endif 
2787			STACKFRAME OFF $8efe $989f 
2787				if DEBUG_STACK_IMB 
2787					if OFF 
2787						exx 
2787						ld de, $8efe 
2787						ld a, d 
2787						ld hl, curframe 
2787						call hexout 
2787						ld a, e 
2787						ld hl, curframe+2 
2787						call hexout 
2787						ld hl, $8efe 
2787						push hl 
2787						ld hl, $989f 
2787						push hl 
2787						exx 
2787					endif 
2787				endif 
2787			endm 
# End of macro STACKFRAME
2787			; get parser buffer length  of new word 
2787			 
2787			 
2787			 
2787				; move tok past this to start of name defintition 
2787				; TODO get word to define 
2787				; TODO Move past word token 
2787				; TODO get length of string up to the ';' 
2787			 
2787 2a f7 f3		ld hl, (os_tok_ptr) 
278a 23			inc hl 
278b 23			inc hl 
278c			 
278c 3e 3b		ld a, ';' 
278e cd 4f 13		call strlent 
2791			 
2791 7d			ld a,l 
2792 32 e6 f0		ld (os_new_parse_len), a 
2795			 
2795			 
2795			if DEBUG_FORTH_UWORD 
2795 ed 5b f7 f3	ld de, (os_tok_ptr) 
2799					DMARK ":01" 
2799 f5				push af  
279a 3a ae 27			ld a, (.dmark)  
279d 32 a0 fd			ld (debug_mark),a  
27a0 3a af 27			ld a, (.dmark+1)  
27a3 32 a1 fd			ld (debug_mark+1),a  
27a6 3a b0 27			ld a, (.dmark+2)  
27a9 32 a2 fd			ld (debug_mark+2),a  
27ac 18 03			jr .pastdmark  
27ae ..			.dmark: db ":01"  
27b1 f1			.pastdmark: pop af  
27b2			endm  
# End of macro DMARK
27b2			CALLMONITOR 
27b2 cd aa fd			call debug_vector  
27b5				endm  
# End of macro CALLMONITOR
27b5			endif 
27b5			 
27b5			; 
27b5			;  new word memory layout: 
27b5			;  
27b5			;    : adg 6666 ;  
27b5			; 
27b5			;    db   1     ; user defined word  
27b5 23			inc hl    
27b6			;    dw   sysdict 
27b6 23			inc hl 
27b7 23			inc hl 
27b8			;    db <word len>+1 (for null) 
27b8 23			inc hl 
27b9			;    db .... <word> 
27b9			; 
27b9			 
27b9 23			inc hl    ; some extras for the word preamble before the above 
27ba 23			inc hl 
27bb 23			inc hl 
27bc 23			inc hl 
27bd 23			inc hl 
27be 23			inc hl 
27bf 23			inc hl  
27c0 23			inc hl 
27c1 23			inc hl 
27c2 23			inc hl 
27c3 23			inc hl 
27c4 23			inc hl 
27c5 23			inc hl 
27c6 23			inc hl     ; TODO how many do we really need?     maybe only 6 
27c7			;       exec word buffer 
27c7			;	<ptr word>   
27c7 23			inc hl 
27c8 23			inc hl 
27c9			;       <word list><null term> 7F final term 
27c9			 
27c9			 
27c9			if DEBUG_FORTH_UWORD 
27c9					DMARK ":02" 
27c9 f5				push af  
27ca 3a de 27			ld a, (.dmark)  
27cd 32 a0 fd			ld (debug_mark),a  
27d0 3a df 27			ld a, (.dmark+1)  
27d3 32 a1 fd			ld (debug_mark+1),a  
27d6 3a e0 27			ld a, (.dmark+2)  
27d9 32 a2 fd			ld (debug_mark+2),a  
27dc 18 03			jr .pastdmark  
27de ..			.dmark: db ":02"  
27e1 f1			.pastdmark: pop af  
27e2			endm  
# End of macro DMARK
27e2			CALLMONITOR 
27e2 cd aa fd			call debug_vector  
27e5				endm  
# End of macro CALLMONITOR
27e5			endif 
27e5			 
27e5			 
27e5				; malloc the size 
27e5			 
27e5 cd b9 13			call malloc 
27e8 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
27eb			 
27eb			;    db   1     ; user defined word  
27eb 3e 01			ld a, WORD_SYS_UWORD  
27ed 77				ld (hl), a 
27ee			 
27ee 23			inc hl    
27ef			;    dw   sysdict 
27ef 11 7c 25		ld de, sysdict       ; continue on with the scan to the system dict 
27f2 73			ld (hl), e 
27f3 23			inc hl 
27f4 72			ld (hl), d 
27f5 23			inc hl 
27f6			 
27f6			 
27f6			;    Setup dict word 
27f6			 
27f6 23			inc hl 
27f7 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27fa			 
27fa			; 1. get length of dict word 
27fa			 
27fa			 
27fa 2a f7 f3		ld hl, (os_tok_ptr) 
27fd 23			inc hl 
27fe 23			inc hl    ; position to start of dict word 
27ff 3e 00		ld a, 0 
2801 cd 4f 13		call strlent 
2804			 
2804			 
2804 23			inc hl    ; to include null??? 
2805			 
2805			; write length of dict word 
2805			 
2805 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2809 1b			dec de 
280a eb			ex de, hl 
280b 73			ld (hl), e 
280c eb			ex de, hl 
280d			 
280d			 
280d			 
280d			; copy  
280d 4d			ld c, l 
280e 06 00		ld b, 0 
2810 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2814 2a f7 f3		ld hl, (os_tok_ptr) 
2817 23			inc hl 
2818 23			inc hl    ; position to start of dict word 
2819			 
2819			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2819			 
2819			; TODO need to convert word to upper case 
2819			 
2819			ucasetok:	 
2819 7e			ld a,(hl) 
281a cd 3b 13		call toUpper 
281d 77			ld (hl),a 
281e ed a0		ldi 
2820 f2 19 28		jp p, ucasetok 
2823			 
2823			 
2823			 
2823			; de now points to start of where the word body code should be placed 
2823 ed 53 e2 f0	ld (os_new_work_ptr), de 
2827			; hl now points to the words to throw at forthexec which needs to be copied 
2827 22 e0 f0		ld (os_new_src_ptr), hl 
282a			 
282a			; TODO add 'call to forthexec' 
282a			 
282a			if DEBUG_FORTH_UWORD 
282a c5			push bc 
282b ed 4b e8 f0	ld bc, (os_new_malloc) 
282f					DMARK ":0x" 
282f f5				push af  
2830 3a 44 28			ld a, (.dmark)  
2833 32 a0 fd			ld (debug_mark),a  
2836 3a 45 28			ld a, (.dmark+1)  
2839 32 a1 fd			ld (debug_mark+1),a  
283c 3a 46 28			ld a, (.dmark+2)  
283f 32 a2 fd			ld (debug_mark+2),a  
2842 18 03			jr .pastdmark  
2844 ..			.dmark: db ":0x"  
2847 f1			.pastdmark: pop af  
2848			endm  
# End of macro DMARK
2848			CALLMONITOR 
2848 cd aa fd			call debug_vector  
284b				endm  
# End of macro CALLMONITOR
284b c1			pop bc 
284c			endif 
284c			 
284c			 
284c			; create word preamble which should be: 
284c			 
284c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
284c			 
284c			;    ld hl, <word code> 
284c			;    jp user_exec 
284c			;    <word code bytes> 
284c			 
284c			 
284c			;	inc de     ; TODO ??? or are we already past the word's null 
284c eb			ex de, hl 
284d			 
284d 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
284f			 
284f 23			inc hl 
2850 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2853 23			inc hl 
2854			 
2854 23			inc hl 
2855 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2857			 
2857 01 71 62		ld bc, user_exec 
285a 23			inc hl 
285b 71			ld (hl), c     ; poke address of user_exec 
285c 23			inc hl 
285d 70			ld (hl), b     
285e			; 
285e			;	inc hl 
285e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
285e			; 
285e			; 
285e			;	ld bc, macro_forth_rsp_next 
285e			;	inc hl 
285e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
285e			;	inc hl 
285e			;	ld (hl), b     
285e			; 
285e			;	inc hl 
285e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
285e			; 
285e			; 
285e			;	inc hl 
285e			;	ld bc, forthexec 
285e			;	ld (hl), c     ; poke address of forthexec 
285e			;	inc hl 
285e			;	ld (hl), b      
285e			; 
285e			;	inc hl 
285e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
285e			; 
285e			;	ld bc, user_dict_next 
285e			;	inc hl 
285e			;	ld (hl), c     ; poke address of forthexec 
285e			;	inc hl 
285e			;	ld (hl), b      
285e			 
285e			; hl is now where we need to copy the word byte data to save this 
285e			 
285e 23			inc hl 
285f 22 de f0		ld (os_new_exec), hl 
2862			 
2862			; copy definition 
2862			 
2862 eb			ex de, hl 
2863			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2863			;	inc de    ; skip the PC for this parse 
2863 3a e6 f0		ld a, (os_new_parse_len) 
2866 4f			ld c, a 
2867 06 00		ld b, 0 
2869 ed b0		ldir		 ; copy defintion 
286b			 
286b			 
286b			; poke the address of where the new word bytes live for forthexec 
286b			 
286b 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
286e			 
286e ed 5b de f0	ld de, (os_new_exec)      
2872			 
2872 73			ld (hl), e 
2873 23			inc hl 
2874 72			ld (hl), d 
2875			 
2875				; TODO copy last user dict word next link to this word 
2875				; TODO update last user dict word to point to this word 
2875			; 
2875			; hl f923 de 812a ; bc 811a 
2875			 
2875			if DEBUG_FORTH_UWORD 
2875 c5			push bc 
2876 ed 4b e8 f0	ld bc, (os_new_malloc) 
287a					DMARK ":0A" 
287a f5				push af  
287b 3a 8f 28			ld a, (.dmark)  
287e 32 a0 fd			ld (debug_mark),a  
2881 3a 90 28			ld a, (.dmark+1)  
2884 32 a1 fd			ld (debug_mark+1),a  
2887 3a 91 28			ld a, (.dmark+2)  
288a 32 a2 fd			ld (debug_mark+2),a  
288d 18 03			jr .pastdmark  
288f ..			.dmark: db ":0A"  
2892 f1			.pastdmark: pop af  
2893			endm  
# End of macro DMARK
2893			CALLMONITOR 
2893 cd aa fd			call debug_vector  
2896				endm  
# End of macro CALLMONITOR
2896 c1			pop bc 
2897			endif 
2897			if DEBUG_FORTH_UWORD 
2897 c5			push bc 
2898 ed 4b e8 f0	ld bc, (os_new_malloc) 
289c 03			inc bc 
289d 03			inc bc 
289e 03			inc bc 
289f 03			inc bc 
28a0 03			inc bc 
28a1 03			inc bc 
28a2 03			inc bc 
28a3 03			inc bc 
28a4			 
28a4					DMARK ":0B" 
28a4 f5				push af  
28a5 3a b9 28			ld a, (.dmark)  
28a8 32 a0 fd			ld (debug_mark),a  
28ab 3a ba 28			ld a, (.dmark+1)  
28ae 32 a1 fd			ld (debug_mark+1),a  
28b1 3a bb 28			ld a, (.dmark+2)  
28b4 32 a2 fd			ld (debug_mark+2),a  
28b7 18 03			jr .pastdmark  
28b9 ..			.dmark: db ":0B"  
28bc f1			.pastdmark: pop af  
28bd			endm  
# End of macro DMARK
28bd			CALLMONITOR 
28bd cd aa fd			call debug_vector  
28c0				endm  
# End of macro CALLMONITOR
28c0 c1			pop bc 
28c1			endif 
28c1			 
28c1			; update word dict linked list for new word 
28c1			 
28c1			 
28c1 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
28c4 23			inc hl     ; move to next work linked list ptr 
28c5			 
28c5 ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
28c9 73			ld (hl), e 
28ca 23			inc hl 
28cb 72			ld (hl), d 
28cc			 
28cc			if DEBUG_FORTH_UWORD 
28cc ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28d0			endif 
28d0			 
28d0 ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
28d4			 
28d4			 
28d4			if DEBUG_FORTH_UWORD 
28d4					DMARK ":0+" 
28d4 f5				push af  
28d5 3a e9 28			ld a, (.dmark)  
28d8 32 a0 fd			ld (debug_mark),a  
28db 3a ea 28			ld a, (.dmark+1)  
28de 32 a1 fd			ld (debug_mark+1),a  
28e1 3a eb 28			ld a, (.dmark+2)  
28e4 32 a2 fd			ld (debug_mark+2),a  
28e7 18 03			jr .pastdmark  
28e9 ..			.dmark: db ":0+"  
28ec f1			.pastdmark: pop af  
28ed			endm  
# End of macro DMARK
28ed			CALLMONITOR 
28ed cd aa fd			call debug_vector  
28f0				endm  
# End of macro CALLMONITOR
28f0			endif 
28f0			 
28f0			STACKFRAMECHK OFF $8efe $989f 
28f0				if DEBUG_STACK_IMB 
28f0					if OFF 
28f0						exx 
28f0						ld hl, $989f 
28f0						pop de   ; $989f 
28f0						call cmp16 
28f0						jr nz, .spnosame 
28f0						ld hl, $8efe 
28f0						pop de   ; $8efe 
28f0						call cmp16 
28f0						jr z, .spfrsame 
28f0						.spnosame: call showsperror 
28f0						.spfrsame: nop 
28f0						exx 
28f0					endif 
28f0				endif 
28f0			endm 
# End of macro STACKFRAMECHK
28f0			 
28f0 c9			ret    ; dont process any remaining parser tokens as they form new word 
28f1			 
28f1			 
28f1			 
28f1			 
28f1			;		NEXT 
28f1			.SCOLN: 
28f1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28f1 06			db OPCODE_SCOLN 
28f2 3d 29		dw .DROP 
28f4 02			db 2 
28f5 .. 00		db ";",0           
28f7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28f7				if DEBUG_FORTH_WORDS_KEY 
28f7					DMARK "SCN" 
28f7 f5				push af  
28f8 3a 0c 29			ld a, (.dmark)  
28fb 32 a0 fd			ld (debug_mark),a  
28fe 3a 0d 29			ld a, (.dmark+1)  
2901 32 a1 fd			ld (debug_mark+1),a  
2904 3a 0e 29			ld a, (.dmark+2)  
2907 32 a2 fd			ld (debug_mark+2),a  
290a 18 03			jr .pastdmark  
290c ..			.dmark: db "SCN"  
290f f1			.pastdmark: pop af  
2910			endm  
# End of macro DMARK
2910					CALLMONITOR 
2910 cd aa fd			call debug_vector  
2913				endm  
# End of macro CALLMONITOR
2913				endif 
2913				FORTH_RSP_TOS 
2913 cd 06 20			call macro_forth_rsp_tos 
2916				endm 
# End of macro FORTH_RSP_TOS
2916 e5				push hl 
2917				FORTH_RSP_POP 
2917 cd 10 20			call macro_forth_rsp_pop 
291a				endm 
# End of macro FORTH_RSP_POP
291a e1				pop hl 
291b			;		ex de,hl 
291b 22 f7 f3			ld (os_tok_ptr),hl 
291e			 
291e			if DEBUG_FORTH_UWORD 
291e					DMARK "SCL" 
291e f5				push af  
291f 3a 33 29			ld a, (.dmark)  
2922 32 a0 fd			ld (debug_mark),a  
2925 3a 34 29			ld a, (.dmark+1)  
2928 32 a1 fd			ld (debug_mark+1),a  
292b 3a 35 29			ld a, (.dmark+2)  
292e 32 a2 fd			ld (debug_mark+2),a  
2931 18 03			jr .pastdmark  
2933 ..			.dmark: db "SCL"  
2936 f1			.pastdmark: pop af  
2937			endm  
# End of macro DMARK
2937			CALLMONITOR 
2937 cd aa fd			call debug_vector  
293a				endm  
# End of macro CALLMONITOR
293a			endif 
293a				NEXTW 
293a c3 38 24			jp macro_next 
293d				endm 
# End of macro NEXTW
293d			 
293d			.DROP: 
293d			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
293d 1b				db WORD_SYS_CORE+OPCODE_DROP             
293e 68 29			dw .DUP2            
2940 05				db 4 + 1 
2941 .. 00			db "DROP",0              
2946				endm 
# End of macro CWHEAD
2946			; | DROP ( w -- )   drop the TOS item   | DONE 
2946				if DEBUG_FORTH_WORDS_KEY 
2946					DMARK "DRP" 
2946 f5				push af  
2947 3a 5b 29			ld a, (.dmark)  
294a 32 a0 fd			ld (debug_mark),a  
294d 3a 5c 29			ld a, (.dmark+1)  
2950 32 a1 fd			ld (debug_mark+1),a  
2953 3a 5d 29			ld a, (.dmark+2)  
2956 32 a2 fd			ld (debug_mark+2),a  
2959 18 03			jr .pastdmark  
295b ..			.dmark: db "DRP"  
295e f1			.pastdmark: pop af  
295f			endm  
# End of macro DMARK
295f					CALLMONITOR 
295f cd aa fd			call debug_vector  
2962				endm  
# End of macro CALLMONITOR
2962				endif 
2962				FORTH_DSP_POP 
2962 cd 05 23			call macro_forth_dsp_pop 
2965				endm 
# End of macro FORTH_DSP_POP
2965				NEXTW 
2965 c3 38 24			jp macro_next 
2968				endm 
# End of macro NEXTW
2968			.DUP2: 
2968			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2968 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2969 ad 29			dw .DROP2            
296b 05				db 4 + 1 
296c .. 00			db "2DUP",0              
2971				endm 
# End of macro CWHEAD
2971			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2971				if DEBUG_FORTH_WORDS_KEY 
2971					DMARK "2DU" 
2971 f5				push af  
2972 3a 86 29			ld a, (.dmark)  
2975 32 a0 fd			ld (debug_mark),a  
2978 3a 87 29			ld a, (.dmark+1)  
297b 32 a1 fd			ld (debug_mark+1),a  
297e 3a 88 29			ld a, (.dmark+2)  
2981 32 a2 fd			ld (debug_mark+2),a  
2984 18 03			jr .pastdmark  
2986 ..			.dmark: db "2DU"  
2989 f1			.pastdmark: pop af  
298a			endm  
# End of macro DMARK
298a					CALLMONITOR 
298a cd aa fd			call debug_vector  
298d				endm  
# End of macro CALLMONITOR
298d				endif 
298d				FORTH_DSP_VALUEHL 
298d cd 4d 22			call macro_dsp_valuehl 
2990				endm 
# End of macro FORTH_DSP_VALUEHL
2990 e5				push hl      ; 2 
2991			 
2991				FORTH_DSP_POP 
2991 cd 05 23			call macro_forth_dsp_pop 
2994				endm 
# End of macro FORTH_DSP_POP
2994				 
2994				FORTH_DSP_VALUEHL 
2994 cd 4d 22			call macro_dsp_valuehl 
2997				endm 
# End of macro FORTH_DSP_VALUEHL
2997			;		push hl      ; 1 
2997			 
2997				FORTH_DSP_POP 
2997 cd 05 23			call macro_forth_dsp_pop 
299a				endm 
# End of macro FORTH_DSP_POP
299a			 
299a			;		pop hl       ; 1 
299a d1				pop de       ; 2 
299b			 
299b cd 48 20			call forth_push_numhl 
299e eb				ex de, hl 
299f cd 48 20			call forth_push_numhl 
29a2			 
29a2				 
29a2 eb				ex de, hl 
29a3			 
29a3 cd 48 20			call forth_push_numhl 
29a6 eb				ex de, hl 
29a7 cd 48 20			call forth_push_numhl 
29aa			 
29aa			 
29aa				NEXTW 
29aa c3 38 24			jp macro_next 
29ad				endm 
# End of macro NEXTW
29ad			.DROP2: 
29ad			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
29ad 1d				db WORD_SYS_CORE+OPCODE_DROP2             
29ae dc 29			dw .PICK            
29b0 06				db 5 + 1 
29b1 .. 00			db "2DROP",0              
29b7				endm 
# End of macro CWHEAD
29b7			; | 2DROP ( w w -- )    Double drop | DONE 
29b7				if DEBUG_FORTH_WORDS_KEY 
29b7					DMARK "2DR" 
29b7 f5				push af  
29b8 3a cc 29			ld a, (.dmark)  
29bb 32 a0 fd			ld (debug_mark),a  
29be 3a cd 29			ld a, (.dmark+1)  
29c1 32 a1 fd			ld (debug_mark+1),a  
29c4 3a ce 29			ld a, (.dmark+2)  
29c7 32 a2 fd			ld (debug_mark+2),a  
29ca 18 03			jr .pastdmark  
29cc ..			.dmark: db "2DR"  
29cf f1			.pastdmark: pop af  
29d0			endm  
# End of macro DMARK
29d0					CALLMONITOR 
29d0 cd aa fd			call debug_vector  
29d3				endm  
# End of macro CALLMONITOR
29d3				endif 
29d3				FORTH_DSP_POP 
29d3 cd 05 23			call macro_forth_dsp_pop 
29d6				endm 
# End of macro FORTH_DSP_POP
29d6				FORTH_DSP_POP 
29d6 cd 05 23			call macro_forth_dsp_pop 
29d9				endm 
# End of macro FORTH_DSP_POP
29d9				NEXTW 
29d9 c3 38 24			jp macro_next 
29dc				endm 
# End of macro NEXTW
29dc			.PICK: 
29dc			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
29dc 77				db WORD_SYS_CORE+99             
29dd 76 2a			dw .SWAP2            
29df 05				db 4 + 1 
29e0 .. 00			db "PICK",0              
29e5				endm 
# End of macro CWHEAD
29e5			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
29e5			; | | >[!NOTE] 
29e5			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
29e5				if DEBUG_FORTH_WORDS_KEY 
29e5					DMARK "PIK" 
29e5 f5				push af  
29e6 3a fa 29			ld a, (.dmark)  
29e9 32 a0 fd			ld (debug_mark),a  
29ec 3a fb 29			ld a, (.dmark+1)  
29ef 32 a1 fd			ld (debug_mark+1),a  
29f2 3a fc 29			ld a, (.dmark+2)  
29f5 32 a2 fd			ld (debug_mark+2),a  
29f8 18 03			jr .pastdmark  
29fa ..			.dmark: db "PIK"  
29fd f1			.pastdmark: pop af  
29fe			endm  
# End of macro DMARK
29fe					CALLMONITOR 
29fe cd aa fd			call debug_vector  
2a01				endm  
# End of macro CALLMONITOR
2a01				endif 
2a01			 
2a01				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a01 cd 4d 22			call macro_dsp_valuehl 
2a04				endm 
# End of macro FORTH_DSP_VALUEHL
2a04				 
2a04				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a04 cd 05 23			call macro_forth_dsp_pop 
2a07				endm 
# End of macro FORTH_DSP_POP
2a07			 
2a07				; init from TOS 
2a07 e5				push hl 
2a08				FORTH_DSP 
2a08 cd 13 22			call macro_forth_dsp 
2a0b				endm 
# End of macro FORTH_DSP
2a0b			;	ld hl, cli_data_sp 
2a0b				if DEBUG_FORTH_WORDS 
2a0b					DMARK "PK1" 
2a0b f5				push af  
2a0c 3a 20 2a			ld a, (.dmark)  
2a0f 32 a0 fd			ld (debug_mark),a  
2a12 3a 21 2a			ld a, (.dmark+1)  
2a15 32 a1 fd			ld (debug_mark+1),a  
2a18 3a 22 2a			ld a, (.dmark+2)  
2a1b 32 a2 fd			ld (debug_mark+2),a  
2a1e 18 03			jr .pastdmark  
2a20 ..			.dmark: db "PK1"  
2a23 f1			.pastdmark: pop af  
2a24			endm  
# End of macro DMARK
2a24					CALLMONITOR 
2a24 cd aa fd			call debug_vector  
2a27				endm  
# End of macro CALLMONITOR
2a27				endif 
2a27 c1				pop bc 
2a28 41				ld b,c 
2a29 3e 00			ld a, 0 
2a2b b8				cp b 
2a2c 28 21			jr z, .pdone	 
2a2e			.pkl: 
2a2e 2b				dec hl 
2a2f 2b				dec hl 
2a30 2b				dec hl 
2a31			 
2a31				if DEBUG_FORTH_WORDS 
2a31					DMARK "PKl" 
2a31 f5				push af  
2a32 3a 46 2a			ld a, (.dmark)  
2a35 32 a0 fd			ld (debug_mark),a  
2a38 3a 47 2a			ld a, (.dmark+1)  
2a3b 32 a1 fd			ld (debug_mark+1),a  
2a3e 3a 48 2a			ld a, (.dmark+2)  
2a41 32 a2 fd			ld (debug_mark+2),a  
2a44 18 03			jr .pastdmark  
2a46 ..			.dmark: db "PKl"  
2a49 f1			.pastdmark: pop af  
2a4a			endm  
# End of macro DMARK
2a4a					CALLMONITOR 
2a4a cd aa fd			call debug_vector  
2a4d				endm  
# End of macro CALLMONITOR
2a4d				endif 
2a4d 10 df			djnz .pkl 
2a4f			.pdone: 
2a4f				 
2a4f				; TODO do type check with correct push 
2a4f			 
2a4f 23				inc hl 
2a50				;call loadwordinhl 
2a50 5e				ld e, (hl) 
2a51 23				inc hl 
2a52 56				ld d, (hl) 
2a53 eb				ex de,hl 
2a54				if DEBUG_FORTH_WORDS 
2a54					DMARK "PKp" 
2a54 f5				push af  
2a55 3a 69 2a			ld a, (.dmark)  
2a58 32 a0 fd			ld (debug_mark),a  
2a5b 3a 6a 2a			ld a, (.dmark+1)  
2a5e 32 a1 fd			ld (debug_mark+1),a  
2a61 3a 6b 2a			ld a, (.dmark+2)  
2a64 32 a2 fd			ld (debug_mark+2),a  
2a67 18 03			jr .pastdmark  
2a69 ..			.dmark: db "PKp"  
2a6c f1			.pastdmark: pop af  
2a6d			endm  
# End of macro DMARK
2a6d					CALLMONITOR 
2a6d cd aa fd			call debug_vector  
2a70				endm  
# End of macro CALLMONITOR
2a70				endif 
2a70 cd 48 20			call forth_push_numhl 
2a73			 
2a73				NEXTW 
2a73 c3 38 24			jp macro_next 
2a76				endm 
# End of macro NEXTW
2a76			.SWAP2: 
2a76			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2a76 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2a77 f7 2a			dw .AT            
2a79 06				db 5 + 1 
2a7a .. 00			db "2SWAP",0              
2a80				endm 
# End of macro CWHEAD
2a80			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2a80				if DEBUG_FORTH_WORDS_KEY 
2a80					DMARK "2SW" 
2a80 f5				push af  
2a81 3a 95 2a			ld a, (.dmark)  
2a84 32 a0 fd			ld (debug_mark),a  
2a87 3a 96 2a			ld a, (.dmark+1)  
2a8a 32 a1 fd			ld (debug_mark+1),a  
2a8d 3a 97 2a			ld a, (.dmark+2)  
2a90 32 a2 fd			ld (debug_mark+2),a  
2a93 18 03			jr .pastdmark  
2a95 ..			.dmark: db "2SW"  
2a98 f1			.pastdmark: pop af  
2a99			endm  
# End of macro DMARK
2a99					CALLMONITOR 
2a99 cd aa fd			call debug_vector  
2a9c				endm  
# End of macro CALLMONITOR
2a9c				endif 
2a9c			; TODO Use os stack swap memory 
2a9c			 
2a9c				FORTH_DSP_PTR 0     ; TOS    w4 
2a9c 2a 23 f9			ld hl,(cli_data_sp) 
2a9f 11 00 00			ld de, 0 * 3 
2aa2 ed 52			sbc hl, de 
2aa4				endm 
# End of macro FORTH_DSP_PTR
2aa4 cd 84 23			call hltostack1 
2aa7			  
2aa7				FORTH_DSP_PTR 1     ; TOS    w3 
2aa7 2a 23 f9			ld hl,(cli_data_sp) 
2aaa 11 03 00			ld de, 1 * 3 
2aad ed 52			sbc hl, de 
2aaf				endm 
# End of macro FORTH_DSP_PTR
2aaf cd 8a 23			call hltostack2 
2ab2			 
2ab2			 
2ab2			 
2ab2				FORTH_DSP_PTR 2     ; TOS    w2 
2ab2 2a 23 f9			ld hl,(cli_data_sp) 
2ab5 11 06 00			ld de, 2 * 3 
2ab8 ed 52			sbc hl, de 
2aba				endm 
# End of macro FORTH_DSP_PTR
2aba cd 90 23			call hltostack3 
2abd			 
2abd				FORTH_DSP_PTR 3     ; TOS   w1 
2abd 2a 23 f9			ld hl,(cli_data_sp) 
2ac0 11 09 00			ld de, 3 * 3 
2ac3 ed 52			sbc hl, de 
2ac5				endm 
# End of macro FORTH_DSP_PTR
2ac5 cd 96 23			call hltostack4 
2ac8			 
2ac8			 
2ac8			 
2ac8			 
2ac8				FORTH_DSP_PTR 0     ; TOS 
2ac8 2a 23 f9			ld hl,(cli_data_sp) 
2acb 11 00 00			ld de, 0 * 3 
2ace ed 52			sbc hl, de 
2ad0				endm 
# End of macro FORTH_DSP_PTR
2ad0 cd a8 23			call hlfromstack3 
2ad3			 
2ad3				FORTH_DSP_PTR 1     ; TOS 
2ad3 2a 23 f9			ld hl,(cli_data_sp) 
2ad6 11 03 00			ld de, 1 * 3 
2ad9 ed 52			sbc hl, de 
2adb				endm 
# End of macro FORTH_DSP_PTR
2adb cd ae 23			call hlfromstack4 
2ade			 
2ade			 
2ade			 
2ade				FORTH_DSP_PTR 2     ; TOS 
2ade 2a 23 f9			ld hl,(cli_data_sp) 
2ae1 11 06 00			ld de, 2 * 3 
2ae4 ed 52			sbc hl, de 
2ae6				endm 
# End of macro FORTH_DSP_PTR
2ae6 cd 9c 23			call hlfromstack1 
2ae9			 
2ae9				FORTH_DSP_PTR 3     ; TOS 
2ae9 2a 23 f9			ld hl,(cli_data_sp) 
2aec 11 09 00			ld de, 3 * 3 
2aef ed 52			sbc hl, de 
2af1				endm 
# End of macro FORTH_DSP_PTR
2af1 cd a2 23			call hlfromstack2 
2af4			 
2af4				NEXTW 
2af4 c3 38 24			jp macro_next 
2af7				endm 
# End of macro NEXTW
2af7			.AT: 
2af7			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2af7 1f				db WORD_SYS_CORE+OPCODE_AT             
2af8 29 2b			dw .CAT            
2afa 02				db 1 + 1 
2afb .. 00			db "@",0              
2afd				endm 
# End of macro CWHEAD
2afd			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2afd			 
2afd				if DEBUG_FORTH_WORDS_KEY 
2afd					DMARK "AT." 
2afd f5				push af  
2afe 3a 12 2b			ld a, (.dmark)  
2b01 32 a0 fd			ld (debug_mark),a  
2b04 3a 13 2b			ld a, (.dmark+1)  
2b07 32 a1 fd			ld (debug_mark+1),a  
2b0a 3a 14 2b			ld a, (.dmark+2)  
2b0d 32 a2 fd			ld (debug_mark+2),a  
2b10 18 03			jr .pastdmark  
2b12 ..			.dmark: db "AT."  
2b15 f1			.pastdmark: pop af  
2b16			endm  
# End of macro DMARK
2b16					CALLMONITOR 
2b16 cd aa fd			call debug_vector  
2b19				endm  
# End of macro CALLMONITOR
2b19				endif 
2b19			.getbyteat:	 
2b19				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b19 cd 4d 22			call macro_dsp_valuehl 
2b1c				endm 
# End of macro FORTH_DSP_VALUEHL
2b1c				 
2b1c			;		push hl 
2b1c			 
2b1c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1c cd 05 23			call macro_forth_dsp_pop 
2b1f				endm 
# End of macro FORTH_DSP_POP
2b1f			 
2b1f			;		pop hl 
2b1f			 
2b1f 7e				ld a, (hl) 
2b20			 
2b20 6f				ld l, a 
2b21 26 00			ld h, 0 
2b23 cd 48 20			call forth_push_numhl 
2b26			 
2b26				NEXTW 
2b26 c3 38 24			jp macro_next 
2b29				endm 
# End of macro NEXTW
2b29			.CAT: 
2b29			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2b29 20				db WORD_SYS_CORE+OPCODE_CAT             
2b2a 52 2b			dw .BANG            
2b2c 03				db 2 + 1 
2b2d .. 00			db "C@",0              
2b30				endm 
# End of macro CWHEAD
2b30			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2b30				if DEBUG_FORTH_WORDS_KEY 
2b30					DMARK "CAA" 
2b30 f5				push af  
2b31 3a 45 2b			ld a, (.dmark)  
2b34 32 a0 fd			ld (debug_mark),a  
2b37 3a 46 2b			ld a, (.dmark+1)  
2b3a 32 a1 fd			ld (debug_mark+1),a  
2b3d 3a 47 2b			ld a, (.dmark+2)  
2b40 32 a2 fd			ld (debug_mark+2),a  
2b43 18 03			jr .pastdmark  
2b45 ..			.dmark: db "CAA"  
2b48 f1			.pastdmark: pop af  
2b49			endm  
# End of macro DMARK
2b49					CALLMONITOR 
2b49 cd aa fd			call debug_vector  
2b4c				endm  
# End of macro CALLMONITOR
2b4c				endif 
2b4c c3 19 2b			jp .getbyteat 
2b4f				NEXTW 
2b4f c3 38 24			jp macro_next 
2b52				endm 
# End of macro NEXTW
2b52			.BANG: 
2b52			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2b52 21				db WORD_SYS_CORE+OPCODE_BANG             
2b53 88 2b			dw .CBANG            
2b55 02				db 1 + 1 
2b56 .. 00			db "!",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | ! ( x w -- ) Store x at address w      | DONE 
2b58				if DEBUG_FORTH_WORDS_KEY 
2b58					DMARK "BNG" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 a0 fd			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 a1 fd			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 a2 fd			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "BNG"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd aa fd			call debug_vector  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74			 
2b74			.storebyteat:		 
2b74				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b74 cd 4d 22			call macro_dsp_valuehl 
2b77				endm 
# End of macro FORTH_DSP_VALUEHL
2b77				 
2b77 e5				push hl 
2b78			 
2b78				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b78 cd 05 23			call macro_forth_dsp_pop 
2b7b				endm 
# End of macro FORTH_DSP_POP
2b7b			 
2b7b				; get byte to poke 
2b7b			 
2b7b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7b cd 4d 22			call macro_dsp_valuehl 
2b7e				endm 
# End of macro FORTH_DSP_VALUEHL
2b7e e5				push hl 
2b7f			 
2b7f			 
2b7f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b7f cd 05 23			call macro_forth_dsp_pop 
2b82				endm 
# End of macro FORTH_DSP_POP
2b82			 
2b82			 
2b82 d1				pop de 
2b83 e1				pop hl 
2b84			 
2b84 73				ld (hl),e 
2b85			 
2b85			 
2b85				NEXTW 
2b85 c3 38 24			jp macro_next 
2b88				endm 
# End of macro NEXTW
2b88			.CBANG: 
2b88			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2b88 22				db WORD_SYS_CORE+OPCODE_CBANG             
2b89 b1 2b			dw .SCALL            
2b8b 03				db 2 + 1 
2b8c .. 00			db "C!",0              
2b8f				endm 
# End of macro CWHEAD
2b8f			; | C!  ( x w -- ) Store x at address w  | DONE 
2b8f				if DEBUG_FORTH_WORDS_KEY 
2b8f					DMARK "CBA" 
2b8f f5				push af  
2b90 3a a4 2b			ld a, (.dmark)  
2b93 32 a0 fd			ld (debug_mark),a  
2b96 3a a5 2b			ld a, (.dmark+1)  
2b99 32 a1 fd			ld (debug_mark+1),a  
2b9c 3a a6 2b			ld a, (.dmark+2)  
2b9f 32 a2 fd			ld (debug_mark+2),a  
2ba2 18 03			jr .pastdmark  
2ba4 ..			.dmark: db "CBA"  
2ba7 f1			.pastdmark: pop af  
2ba8			endm  
# End of macro DMARK
2ba8					CALLMONITOR 
2ba8 cd aa fd			call debug_vector  
2bab				endm  
# End of macro CALLMONITOR
2bab				endif 
2bab c3 74 2b			jp .storebyteat 
2bae				NEXTW 
2bae c3 38 24			jp macro_next 
2bb1				endm 
# End of macro NEXTW
2bb1			.SCALL: 
2bb1			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2bb1 23				db WORD_SYS_CORE+OPCODE_SCALL             
2bb2 e5 2b			dw .DEPTH            
2bb4 05				db 4 + 1 
2bb5 .. 00			db "CALL",0              
2bba				endm 
# End of macro CWHEAD
2bba			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2bba				if DEBUG_FORTH_WORDS_KEY 
2bba					DMARK "CLL" 
2bba f5				push af  
2bbb 3a cf 2b			ld a, (.dmark)  
2bbe 32 a0 fd			ld (debug_mark),a  
2bc1 3a d0 2b			ld a, (.dmark+1)  
2bc4 32 a1 fd			ld (debug_mark+1),a  
2bc7 3a d1 2b			ld a, (.dmark+2)  
2bca 32 a2 fd			ld (debug_mark+2),a  
2bcd 18 03			jr .pastdmark  
2bcf ..			.dmark: db "CLL"  
2bd2 f1			.pastdmark: pop af  
2bd3			endm  
# End of macro DMARK
2bd3					CALLMONITOR 
2bd3 cd aa fd			call debug_vector  
2bd6				endm  
# End of macro CALLMONITOR
2bd6				endif 
2bd6			 
2bd6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bd6 cd 4d 22			call macro_dsp_valuehl 
2bd9				endm 
# End of macro FORTH_DSP_VALUEHL
2bd9			 
2bd9			;		push hl 
2bd9			 
2bd9				; destroy value TOS 
2bd9			 
2bd9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bd9 cd 05 23			call macro_forth_dsp_pop 
2bdc				endm 
# End of macro FORTH_DSP_POP
2bdc			 
2bdc					 
2bdc			;		pop hl 
2bdc			 
2bdc				; how to do a call with hl???? save SP? 
2bdc cd dc 23			call forth_call_hl 
2bdf			 
2bdf			 
2bdf				; TODO push value back onto stack for another op etc 
2bdf			 
2bdf cd 48 20			call forth_push_numhl 
2be2				NEXTW 
2be2 c3 38 24			jp macro_next 
2be5				endm 
# End of macro NEXTW
2be5			.DEPTH: 
2be5			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2be5 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2be6 22 2c			dw .OVER            
2be8 06				db 5 + 1 
2be9 .. 00			db "DEPTH",0              
2bef				endm 
# End of macro CWHEAD
2bef			; | DEPTH ( -- u ) Push count of stack | DONE 
2bef				; take current TOS and remove from base value div by two to get count 
2bef				if DEBUG_FORTH_WORDS_KEY 
2bef					DMARK "DEP" 
2bef f5				push af  
2bf0 3a 04 2c			ld a, (.dmark)  
2bf3 32 a0 fd			ld (debug_mark),a  
2bf6 3a 05 2c			ld a, (.dmark+1)  
2bf9 32 a1 fd			ld (debug_mark+1),a  
2bfc 3a 06 2c			ld a, (.dmark+2)  
2bff 32 a2 fd			ld (debug_mark+2),a  
2c02 18 03			jr .pastdmark  
2c04 ..			.dmark: db "DEP"  
2c07 f1			.pastdmark: pop af  
2c08			endm  
# End of macro DMARK
2c08					CALLMONITOR 
2c08 cd aa fd			call debug_vector  
2c0b				endm  
# End of macro CALLMONITOR
2c0b				endif 
2c0b			 
2c0b			 
2c0b 2a 23 f9		ld hl, (cli_data_sp) 
2c0e 11 5d f6		ld de, cli_data_stack 
2c11 ed 52		sbc hl,de 
2c13			 
2c13			; div by size of stack item 
2c13			 
2c13 5d			ld e,l 
2c14 0e 03		ld c, 3 
2c16 cd 6e 0f		call Div8 
2c19			 
2c19 6f			ld l,a 
2c1a 26 00		ld h,0 
2c1c			 
2c1c			;srl h 
2c1c			;rr l 
2c1c			 
2c1c cd 48 20			call forth_push_numhl 
2c1f				NEXTW 
2c1f c3 38 24			jp macro_next 
2c22				endm 
# End of macro NEXTW
2c22			.OVER: 
2c22			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2c22 42				db WORD_SYS_CORE+46             
2c23 69 2c			dw .PAUSE            
2c25 05				db 4 + 1 
2c26 .. 00			db "OVER",0              
2c2b				endm 
# End of macro CWHEAD
2c2b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2c2b			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2c2b				if DEBUG_FORTH_WORDS_KEY 
2c2b					DMARK "OVR" 
2c2b f5				push af  
2c2c 3a 40 2c			ld a, (.dmark)  
2c2f 32 a0 fd			ld (debug_mark),a  
2c32 3a 41 2c			ld a, (.dmark+1)  
2c35 32 a1 fd			ld (debug_mark+1),a  
2c38 3a 42 2c			ld a, (.dmark+2)  
2c3b 32 a2 fd			ld (debug_mark+2),a  
2c3e 18 03			jr .pastdmark  
2c40 ..			.dmark: db "OVR"  
2c43 f1			.pastdmark: pop af  
2c44			endm  
# End of macro DMARK
2c44					CALLMONITOR 
2c44 cd aa fd			call debug_vector  
2c47				endm  
# End of macro CALLMONITOR
2c47				endif 
2c47			 
2c47			; TODO Use os stack swap memory 
2c47			 
2c47				; work out what type we are looking at 
2c47			 
2c47				FORTH_DSP_PTR 1 
2c47 2a 23 f9			ld hl,(cli_data_sp) 
2c4a 11 03 00			ld de, 1 * 3 
2c4d ed 52			sbc hl, de 
2c4f				endm 
# End of macro FORTH_DSP_PTR
2c4f			 
2c4f 7e				ld a, (hl) 
2c50				 
2c50 f5				push af 
2c51				; whatever the type lets get the pointer or word 
2c51 23				inc hl 
2c52			;; 
2c52			 
2c52				; type check now to decide on how to push  
2c52			 
2c52 cd ba 23			call loadwordinhl 
2c55 f1				pop af 
2c56 fe 01			cp DS_TYPE_STR 
2c58 28 06			jr z, .ovstr 
2c5a			 
2c5a				; we have a numeric so load the word and push 
2c5a			;	ld e, (hl) 
2c5a			;	inc hl 
2c5a			;	ld d, (hl) 
2c5a			;	ex de, hl 
2c5a cd 48 20			call forth_push_numhl 
2c5d				NEXTW 
2c5d c3 38 24			jp macro_next 
2c60				endm 
# End of macro NEXTW
2c60			 
2c60			.ovstr: 
2c60				; ok, a string so get the pointer and push as a string 
2c60			 
2c60			;	call loadwordinhl 
2c60 cd b6 20			call forth_push_str 
2c63				NEXTW 
2c63 c3 38 24			jp macro_next 
2c66				endm 
# End of macro NEXTW
2c66			 
2c66			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c66			;	push hl    ; n2 
2c66			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c66			; 
2c66			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c66			;	push hl    ; n1 
2c66			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c66			; 
2c66			;	pop de     ; n1 
2c66			;	pop hl     ; n2 
2c66			; 
2c66			;	push de 
2c66			;	push hl 
2c66			;	push de 
2c66			 
2c66				; push back  
2c66			 
2c66			;	pop hl 
2c66			;	call forth_push_numhl 
2c66			;	pop hl 
2c66			;	call forth_push_numhl 
2c66			;	pop hl 
2c66			;	call forth_push_numhl 
2c66				NEXTW 
2c66 c3 38 24			jp macro_next 
2c69				endm 
# End of macro NEXTW
2c69			 
2c69			.PAUSE: 
2c69			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2c69 43				db WORD_SYS_CORE+47             
2c6a 9e 2c			dw .PAUSES            
2c6c 08				db 7 + 1 
2c6d .. 00			db "PAUSEMS",0              
2c75				endm 
# End of macro CWHEAD
2c75			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2c75				if DEBUG_FORTH_WORDS_KEY 
2c75					DMARK "PMS" 
2c75 f5				push af  
2c76 3a 8a 2c			ld a, (.dmark)  
2c79 32 a0 fd			ld (debug_mark),a  
2c7c 3a 8b 2c			ld a, (.dmark+1)  
2c7f 32 a1 fd			ld (debug_mark+1),a  
2c82 3a 8c 2c			ld a, (.dmark+2)  
2c85 32 a2 fd			ld (debug_mark+2),a  
2c88 18 03			jr .pastdmark  
2c8a ..			.dmark: db "PMS"  
2c8d f1			.pastdmark: pop af  
2c8e			endm  
# End of macro DMARK
2c8e					CALLMONITOR 
2c8e cd aa fd			call debug_vector  
2c91				endm  
# End of macro CALLMONITOR
2c91				endif 
2c91				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c91 cd 4d 22			call macro_dsp_valuehl 
2c94				endm 
# End of macro FORTH_DSP_VALUEHL
2c94			;		push hl    ; n2 
2c94				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c94 cd 05 23			call macro_forth_dsp_pop 
2c97				endm 
# End of macro FORTH_DSP_POP
2c97			;		pop hl 
2c97			 
2c97 7d				ld a, l 
2c98 cd d2 0c			call aDelayInMS 
2c9b			       NEXTW 
2c9b c3 38 24			jp macro_next 
2c9e				endm 
# End of macro NEXTW
2c9e			.PAUSES:  
2c9e			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c9e 44				db WORD_SYS_CORE+48             
2c9f 0d 2d			dw .ROT            
2ca1 06				db 5 + 1 
2ca2 .. 00			db "PAUSE",0              
2ca8				endm 
# End of macro CWHEAD
2ca8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2ca8				if DEBUG_FORTH_WORDS_KEY 
2ca8					DMARK "PAU" 
2ca8 f5				push af  
2ca9 3a bd 2c			ld a, (.dmark)  
2cac 32 a0 fd			ld (debug_mark),a  
2caf 3a be 2c			ld a, (.dmark+1)  
2cb2 32 a1 fd			ld (debug_mark+1),a  
2cb5 3a bf 2c			ld a, (.dmark+2)  
2cb8 32 a2 fd			ld (debug_mark+2),a  
2cbb 18 03			jr .pastdmark  
2cbd ..			.dmark: db "PAU"  
2cc0 f1			.pastdmark: pop af  
2cc1			endm  
# End of macro DMARK
2cc1					CALLMONITOR 
2cc1 cd aa fd			call debug_vector  
2cc4				endm  
# End of macro CALLMONITOR
2cc4				endif 
2cc4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cc4 cd 4d 22			call macro_dsp_valuehl 
2cc7				endm 
# End of macro FORTH_DSP_VALUEHL
2cc7			;		push hl    ; n2 
2cc7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cc7 cd 05 23			call macro_forth_dsp_pop 
2cca				endm 
# End of macro FORTH_DSP_POP
2cca			;		pop hl 
2cca 45				ld b, l 
2ccb				if DEBUG_FORTH_WORDS 
2ccb					DMARK "PAU" 
2ccb f5				push af  
2ccc 3a e0 2c			ld a, (.dmark)  
2ccf 32 a0 fd			ld (debug_mark),a  
2cd2 3a e1 2c			ld a, (.dmark+1)  
2cd5 32 a1 fd			ld (debug_mark+1),a  
2cd8 3a e2 2c			ld a, (.dmark+2)  
2cdb 32 a2 fd			ld (debug_mark+2),a  
2cde 18 03			jr .pastdmark  
2ce0 ..			.dmark: db "PAU"  
2ce3 f1			.pastdmark: pop af  
2ce4			endm  
# End of macro DMARK
2ce4					CALLMONITOR 
2ce4 cd aa fd			call debug_vector  
2ce7				endm  
# End of macro CALLMONITOR
2ce7				endif 
2ce7 c5			.pauses1:	push bc 
2ce8 cd ed 0c			call delay1s 
2ceb c1				pop bc 
2cec				if DEBUG_FORTH_WORDS 
2cec					DMARK "PA1" 
2cec f5				push af  
2ced 3a 01 2d			ld a, (.dmark)  
2cf0 32 a0 fd			ld (debug_mark),a  
2cf3 3a 02 2d			ld a, (.dmark+1)  
2cf6 32 a1 fd			ld (debug_mark+1),a  
2cf9 3a 03 2d			ld a, (.dmark+2)  
2cfc 32 a2 fd			ld (debug_mark+2),a  
2cff 18 03			jr .pastdmark  
2d01 ..			.dmark: db "PA1"  
2d04 f1			.pastdmark: pop af  
2d05			endm  
# End of macro DMARK
2d05					CALLMONITOR 
2d05 cd aa fd			call debug_vector  
2d08				endm  
# End of macro CALLMONITOR
2d08				endif 
2d08 10 dd			djnz .pauses1 
2d0a			 
2d0a			       NEXTW 
2d0a c3 38 24			jp macro_next 
2d0d				endm 
# End of macro NEXTW
2d0d			.ROT: 
2d0d			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2d0d 45				db WORD_SYS_CORE+49             
2d0e 76 2d			dw .UWORDS            
2d10 04				db 3 + 1 
2d11 .. 00			db "ROT",0              
2d15				endm 
# End of macro CWHEAD
2d15			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2d15				if DEBUG_FORTH_WORDS_KEY 
2d15					DMARK "ROT" 
2d15 f5				push af  
2d16 3a 2a 2d			ld a, (.dmark)  
2d19 32 a0 fd			ld (debug_mark),a  
2d1c 3a 2b 2d			ld a, (.dmark+1)  
2d1f 32 a1 fd			ld (debug_mark+1),a  
2d22 3a 2c 2d			ld a, (.dmark+2)  
2d25 32 a2 fd			ld (debug_mark+2),a  
2d28 18 03			jr .pastdmark  
2d2a ..			.dmark: db "ROT"  
2d2d f1			.pastdmark: pop af  
2d2e			endm  
# End of macro DMARK
2d2e					CALLMONITOR 
2d2e cd aa fd			call debug_vector  
2d31				endm  
# End of macro CALLMONITOR
2d31				endif 
2d31			 
2d31			; DONE Use os stack swap memory 
2d31			 
2d31				FORTH_DSP_PTR 0     ; u3 
2d31 2a 23 f9			ld hl,(cli_data_sp) 
2d34 11 00 00			ld de, 0 * 3 
2d37 ed 52			sbc hl, de 
2d39				endm 
# End of macro FORTH_DSP_PTR
2d39 cd 84 23			call hltostack1     
2d3c			  
2d3c				FORTH_DSP_PTR 1     ; u2 
2d3c 2a 23 f9			ld hl,(cli_data_sp) 
2d3f 11 03 00			ld de, 1 * 3 
2d42 ed 52			sbc hl, de 
2d44				endm 
# End of macro FORTH_DSP_PTR
2d44 cd 8a 23			call hltostack2      
2d47			 
2d47				FORTH_DSP_PTR 2     ; u1 
2d47 2a 23 f9			ld hl,(cli_data_sp) 
2d4a 11 06 00			ld de, 2 * 3 
2d4d ed 52			sbc hl, de 
2d4f				endm 
# End of macro FORTH_DSP_PTR
2d4f cd 90 23			call hltostack3 
2d52			 
2d52			 
2d52				FORTH_DSP_PTR 0     ;  
2d52 2a 23 f9			ld hl,(cli_data_sp) 
2d55 11 00 00			ld de, 0 * 3 
2d58 ed 52			sbc hl, de 
2d5a				endm 
# End of macro FORTH_DSP_PTR
2d5a cd a8 23			call hlfromstack3 
2d5d			 
2d5d				FORTH_DSP_PTR 1     ; TOS 
2d5d 2a 23 f9			ld hl,(cli_data_sp) 
2d60 11 03 00			ld de, 1 * 3 
2d63 ed 52			sbc hl, de 
2d65				endm 
# End of macro FORTH_DSP_PTR
2d65 cd 9c 23			call hlfromstack1 
2d68			 
2d68				FORTH_DSP_PTR 2     ; TOS 
2d68 2a 23 f9			ld hl,(cli_data_sp) 
2d6b 11 06 00			ld de, 2 * 3 
2d6e ed 52			sbc hl, de 
2d70				endm 
# End of macro FORTH_DSP_PTR
2d70 cd a2 23			call hlfromstack2 
2d73			 
2d73			 
2d73			;	FORTH_DSP_VALUEHL 
2d73			;	push hl    ; u3  
2d73			; 
2d73			;	FORTH_DSP_POP 
2d73			; 
2d73			;	FORTH_DSP_VALUEHL 
2d73			;	push hl     ; u2 
2d73			; 
2d73			;	FORTH_DSP_POP 
2d73			; 
2d73			;	FORTH_DSP_VALUEHL 
2d73			;	push hl     ; u1 
2d73			; 
2d73			;	FORTH_DSP_POP 
2d73			; 
2d73			;	pop bc      ; u1 
2d73			;	pop hl      ; u2 
2d73			;	pop de      ; u3 
2d73			; 
2d73			; 
2d73			;	push bc 
2d73			;	push de 
2d73			;	push hl 
2d73			; 
2d73			; 
2d73			;	pop hl 
2d73			;	call forth_push_numhl 
2d73			; 
2d73			;	pop hl 
2d73			;	call forth_push_numhl 
2d73			; 
2d73			;	pop hl 
2d73			;	call forth_push_numhl 
2d73				 
2d73			 
2d73			 
2d73			 
2d73			 
2d73			 
2d73			       NEXTW 
2d73 c3 38 24			jp macro_next 
2d76				endm 
# End of macro NEXTW
2d76			 
2d76			.UWORDS: 
2d76			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d76 50				db WORD_SYS_CORE+60             
2d77 38 2e			dw .BP            
2d79 07				db 6 + 1 
2d7a .. 00			db "UWORDS",0              
2d81				endm 
# End of macro CWHEAD
2d81			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2d81			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2d81			; | | Following the count are the individual words. 
2d81			; | | 
2d81			; | | e.g. UWORDS 
2d81			; | | BOX DIRLIST 2 
2d81			; | |  
2d81			; | | Can be used to save the words to storage via: 
2d81			; | | UWORDS $01 DO $01 APPEND LOOP 
2d81			if DEBUG_FORTH_WORDS_KEY 
2d81				DMARK "UWR" 
2d81 f5				push af  
2d82 3a 96 2d			ld a, (.dmark)  
2d85 32 a0 fd			ld (debug_mark),a  
2d88 3a 97 2d			ld a, (.dmark+1)  
2d8b 32 a1 fd			ld (debug_mark+1),a  
2d8e 3a 98 2d			ld a, (.dmark+2)  
2d91 32 a2 fd			ld (debug_mark+2),a  
2d94 18 03			jr .pastdmark  
2d96 ..			.dmark: db "UWR"  
2d99 f1			.pastdmark: pop af  
2d9a			endm  
# End of macro DMARK
2d9a				CALLMONITOR 
2d9a cd aa fd			call debug_vector  
2d9d				endm  
# End of macro CALLMONITOR
2d9d			endif 
2d9d 21 00 80			ld hl, baseram 
2da0				;ld hl, baseusermem 
2da0 01 00 00			ld bc, 0    ; start a counter 
2da3			 
2da3			; skip dict stub 
2da3			 
2da3 cd 75 25			call forth_tok_next 
2da6			 
2da6			 
2da6			; while we have words to look for 
2da6			 
2da6 7e			.douscan:	ld a, (hl)      
2da7			if DEBUG_FORTH_WORDS 
2da7				DMARK "UWs" 
2da7 f5				push af  
2da8 3a bc 2d			ld a, (.dmark)  
2dab 32 a0 fd			ld (debug_mark),a  
2dae 3a bd 2d			ld a, (.dmark+1)  
2db1 32 a1 fd			ld (debug_mark+1),a  
2db4 3a be 2d			ld a, (.dmark+2)  
2db7 32 a2 fd			ld (debug_mark+2),a  
2dba 18 03			jr .pastdmark  
2dbc ..			.dmark: db "UWs"  
2dbf f1			.pastdmark: pop af  
2dc0			endm  
# End of macro DMARK
2dc0				CALLMONITOR 
2dc0 cd aa fd			call debug_vector  
2dc3				endm  
# End of macro CALLMONITOR
2dc3			endif 
2dc3 fe 00			cp WORD_SYS_END 
2dc5 28 4d			jr z, .udone 
2dc7 fe 01			cp WORD_SYS_UWORD 
2dc9 20 44			jr nz, .nuword 
2dcb			 
2dcb			if DEBUG_FORTH_WORDS 
2dcb				DMARK "UWu" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 a0 fd			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 a1 fd			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 a2 fd			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "UWu"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4				CALLMONITOR 
2de4 cd aa fd			call debug_vector  
2de7				endm  
# End of macro CALLMONITOR
2de7			endif 
2de7				; we have a uword so push its name to the stack 
2de7			 
2de7 e5				push hl  ; save so we can move to next dict block 
2de8			 
2de8				; skip opcode 
2de8 23				inc hl  
2de9				; skip next ptr 
2de9 23				inc hl  
2dea 23				inc hl 
2deb				; skip len 
2deb 23				inc hl 
2dec			if DEBUG_FORTH_WORDS 
2dec				DMARK "UWt" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 a0 fd			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 a1 fd			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 a2 fd			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "UWt"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05				CALLMONITOR 
2e05 cd aa fd			call debug_vector  
2e08				endm  
# End of macro CALLMONITOR
2e08			endif 
2e08 03				inc bc 
2e09			 
2e09 c5				push bc 
2e0a cd b6 20			call forth_push_str 
2e0d c1				pop bc 
2e0e			 
2e0e e1				pop hl 	 
2e0f			 
2e0f cd 75 25		.nuword:	call forth_tok_next 
2e12 18 92			jr .douscan  
2e14			 
2e14			.udone:		 ; push count of uwords found 
2e14 c5				push bc 
2e15 e1				pop hl 
2e16			 
2e16			if DEBUG_FORTH_WORDS 
2e16				DMARK "UWc" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 a0 fd			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 a1 fd			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 a2 fd			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "UWc"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f				CALLMONITOR 
2e2f cd aa fd			call debug_vector  
2e32				endm  
# End of macro CALLMONITOR
2e32			endif 
2e32 cd 48 20			call forth_push_numhl 
2e35			 
2e35			 
2e35			       NEXTW 
2e35 c3 38 24			jp macro_next 
2e38				endm 
# End of macro NEXTW
2e38			 
2e38			.BP: 
2e38			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2e38 54				db WORD_SYS_CORE+64             
2e39 72 2e			dw .MONITOR            
2e3b 03				db 2 + 1 
2e3c .. 00			db "BP",0              
2e3f				endm 
# End of macro CWHEAD
2e3f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e3f			; | | $00 Will enable the break points within specific code paths 
2e3f			; | | $01 Will disable break points 
2e3f			; | |  
2e3f			; | | By default break points are off. Either the above can be used to enable them 
2e3f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e3f			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e3f			; | | can disable break points. Exiting will then continue boot process. 
2e3f				; get byte count 
2e3f				if DEBUG_FORTH_WORDS_KEY 
2e3f					DMARK "BP." 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 a0 fd			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 a1 fd			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 a2 fd			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "BP."  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58					CALLMONITOR 
2e58 cd aa fd			call debug_vector  
2e5b				endm  
# End of macro CALLMONITOR
2e5b				endif 
2e5b			 
2e5b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e5b cd 4d 22			call macro_dsp_valuehl 
2e5e				endm 
# End of macro FORTH_DSP_VALUEHL
2e5e			 
2e5e			;		push hl 
2e5e			 
2e5e				; destroy value TOS 
2e5e			 
2e5e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e5e cd 05 23			call macro_forth_dsp_pop 
2e61				endm 
# End of macro FORTH_DSP_POP
2e61			 
2e61			;		pop hl 
2e61			 
2e61 3e 00			ld a,0 
2e63 bd				cp l 
2e64 28 06			jr z, .bpset 
2e66			;		ld a, '*' 
2e66 cd 55 19			call bp_off 
2e69				NEXTW 
2e69 c3 38 24			jp macro_next 
2e6c				endm 
# End of macro NEXTW
2e6c			 
2e6c			.bpset:	 
2e6c				;	ld (os_view_disable), a 
2e6c cd 49 19			call bp_on 
2e6f			 
2e6f			 
2e6f				NEXTW 
2e6f c3 38 24			jp macro_next 
2e72				endm 
# End of macro NEXTW
2e72			 
2e72			 
2e72			.MONITOR: 
2e72			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e72 55				db WORD_SYS_CORE+65             
2e73 a3 2e			dw .MALLOC            
2e75 08				db 7 + 1 
2e76 .. 00			db "MONITOR",0              
2e7e				endm 
# End of macro CWHEAD
2e7e			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e7e			; | | At start the current various registers will be displayed with contents. 
2e7e			; | | Top right corner will show the most recent debug marker seen. 
2e7e			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e7e			; | | and the return stack pointer (RSP). 
2e7e			; | | Pressing: 
2e7e			; | |    1 - Initial screen 
2e7e			; | |    2 - Display a data dump of HL 
2e7e			; | |    3 - Display a data dump of DE 
2e7e			; | |    4 - Display a data dump of BC 
2e7e			; | |    5 - Display a data dump of HL 
2e7e			; | |    6 - Display a data dump of DSP 
2e7e			; | |    7 - Display a data dump of RSP 
2e7e			; | |    8 - Display a data dump of what is at DSP 
2e7e			; | |    9 - Display a data dump of what is at RSP 
2e7e			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e7e			; | |    * - Disable break points 
2e7e			; | |    # - Enter traditional monitor mode 
2e7e			; | | 
2e7e			; | | Monitor Mode 
2e7e			; | | ------------ 
2e7e			; | | A prompt of '>' will be shown for various commands: 
2e7e			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e7e			; | |    C - Continue display a data dump from the last set address 
2e7e			; | |    M xxxx - Set start of memory edit at address xx 
2e7e			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e7e			; | |    G xxxx - Exec code at specific address 
2e7e			; | |    Q - Return to previous 
2e7e				if DEBUG_FORTH_WORDS_KEY 
2e7e					DMARK "MON" 
2e7e f5				push af  
2e7f 3a 93 2e			ld a, (.dmark)  
2e82 32 a0 fd			ld (debug_mark),a  
2e85 3a 94 2e			ld a, (.dmark+1)  
2e88 32 a1 fd			ld (debug_mark+1),a  
2e8b 3a 95 2e			ld a, (.dmark+2)  
2e8e 32 a2 fd			ld (debug_mark+2),a  
2e91 18 03			jr .pastdmark  
2e93 ..			.dmark: db "MON"  
2e96 f1			.pastdmark: pop af  
2e97			endm  
# End of macro DMARK
2e97					CALLMONITOR 
2e97 cd aa fd			call debug_vector  
2e9a				endm  
# End of macro CALLMONITOR
2e9a				endif 
2e9a			;		ld a, 0 
2e9a			;		ld (os_view_disable), a 
2e9a cd 49 19			call bp_on 
2e9d			 
2e9d				CALLMONITOR 
2e9d cd aa fd			call debug_vector  
2ea0				endm  
# End of macro CALLMONITOR
2ea0			 
2ea0			;	call monitor 
2ea0			 
2ea0				NEXTW 
2ea0 c3 38 24			jp macro_next 
2ea3				endm 
# End of macro NEXTW
2ea3			 
2ea3			 
2ea3			.MALLOC: 
2ea3			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2ea3 56				db WORD_SYS_CORE+66             
2ea4 cc 2e			dw .MALLOC2            
2ea6 06				db 5 + 1 
2ea7 .. 00			db "ALLOT",0              
2ead				endm 
# End of macro CWHEAD
2ead			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ead				if DEBUG_FORTH_WORDS_KEY 
2ead					DMARK "ALL" 
2ead f5				push af  
2eae 3a c2 2e			ld a, (.dmark)  
2eb1 32 a0 fd			ld (debug_mark),a  
2eb4 3a c3 2e			ld a, (.dmark+1)  
2eb7 32 a1 fd			ld (debug_mark+1),a  
2eba 3a c4 2e			ld a, (.dmark+2)  
2ebd 32 a2 fd			ld (debug_mark+2),a  
2ec0 18 03			jr .pastdmark  
2ec2 ..			.dmark: db "ALL"  
2ec5 f1			.pastdmark: pop af  
2ec6			endm  
# End of macro DMARK
2ec6					CALLMONITOR 
2ec6 cd aa fd			call debug_vector  
2ec9				endm  
# End of macro CALLMONITOR
2ec9				endif 
2ec9 c3 f3 2e			jp .mallocc 
2ecc			.MALLOC2: 
2ecc			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2ecc 56				db WORD_SYS_CORE+66             
2ecd 0a 2f			dw .FREE            
2ecf 07				db 6 + 1 
2ed0 .. 00			db "MALLOC",0              
2ed7				endm 
# End of macro CWHEAD
2ed7			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ed7				; get byte count 
2ed7				if DEBUG_FORTH_WORDS_KEY 
2ed7					DMARK "MAL" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 a0 fd			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 a1 fd			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 a2 fd			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "MAL"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0					CALLMONITOR 
2ef0 cd aa fd			call debug_vector  
2ef3				endm  
# End of macro CALLMONITOR
2ef3				endif 
2ef3			.mallocc: 
2ef3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ef3 cd 4d 22			call macro_dsp_valuehl 
2ef6				endm 
# End of macro FORTH_DSP_VALUEHL
2ef6			 
2ef6			;		push hl 
2ef6			 
2ef6				; destroy value TOS 
2ef6			 
2ef6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ef6 cd 05 23			call macro_forth_dsp_pop 
2ef9				endm 
# End of macro FORTH_DSP_POP
2ef9			 
2ef9			;		pop hl 
2ef9 cd b9 13			call malloc 
2efc			if DEBUG_FORTH_MALLOC_GUARD 
2efc f5				push af 
2efd cd 07 10			call ishlzero 
2f00			;		ld a, l 
2f00			;		add h 
2f00			;		cp 0 
2f00 f1				pop af 
2f01				 
2f01 cc 43 63			call z,malloc_error 
2f04			endif 
2f04			 
2f04 cd 48 20			call forth_push_numhl 
2f07				NEXTW 
2f07 c3 38 24			jp macro_next 
2f0a				endm 
# End of macro NEXTW
2f0a			 
2f0a			.FREE: 
2f0a			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2f0a 57				db WORD_SYS_CORE+67             
2f0b 3b 2f			dw .UPTR            
2f0d 05				db 4 + 1 
2f0e .. 00			db "FREE",0              
2f13				endm 
# End of macro CWHEAD
2f13			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2f13				if DEBUG_FORTH_WORDS_KEY 
2f13					DMARK "FRE" 
2f13 f5				push af  
2f14 3a 28 2f			ld a, (.dmark)  
2f17 32 a0 fd			ld (debug_mark),a  
2f1a 3a 29 2f			ld a, (.dmark+1)  
2f1d 32 a1 fd			ld (debug_mark+1),a  
2f20 3a 2a 2f			ld a, (.dmark+2)  
2f23 32 a2 fd			ld (debug_mark+2),a  
2f26 18 03			jr .pastdmark  
2f28 ..			.dmark: db "FRE"  
2f2b f1			.pastdmark: pop af  
2f2c			endm  
# End of macro DMARK
2f2c					CALLMONITOR 
2f2c cd aa fd			call debug_vector  
2f2f				endm  
# End of macro CALLMONITOR
2f2f				endif 
2f2f				; get address 
2f2f			 
2f2f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f2f cd 4d 22			call macro_dsp_valuehl 
2f32				endm 
# End of macro FORTH_DSP_VALUEHL
2f32			 
2f32			;		push hl 
2f32			 
2f32				; destroy value TOS 
2f32			 
2f32				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f32 cd 05 23			call macro_forth_dsp_pop 
2f35				endm 
# End of macro FORTH_DSP_POP
2f35			 
2f35			;		pop hl 
2f35			if FORTH_ENABLE_MALLOCFREE 
2f35 cd 83 14			call free 
2f38			endif 
2f38				NEXTW 
2f38 c3 38 24			jp macro_next 
2f3b				endm 
# End of macro NEXTW
2f3b			.UPTR: 
2f3b			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2f3b 57				db WORD_SYS_CORE+67             
2f3c 3e 30			dw .LIST            
2f3e 05				db 4 + 1 
2f3f .. 00			db "UPTR",0              
2f44				endm 
# End of macro CWHEAD
2f44			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2f44				if DEBUG_FORTH_WORDS_KEY 
2f44					DMARK "UPT" 
2f44 f5				push af  
2f45 3a 59 2f			ld a, (.dmark)  
2f48 32 a0 fd			ld (debug_mark),a  
2f4b 3a 5a 2f			ld a, (.dmark+1)  
2f4e 32 a1 fd			ld (debug_mark+1),a  
2f51 3a 5b 2f			ld a, (.dmark+2)  
2f54 32 a2 fd			ld (debug_mark+2),a  
2f57 18 03			jr .pastdmark  
2f59 ..			.dmark: db "UPT"  
2f5c f1			.pastdmark: pop af  
2f5d			endm  
# End of macro DMARK
2f5d					CALLMONITOR 
2f5d cd aa fd			call debug_vector  
2f60				endm  
# End of macro CALLMONITOR
2f60				endif 
2f60				FORTH_DSP_VALUEHL 
2f60 cd 4d 22			call macro_dsp_valuehl 
2f63				endm 
# End of macro FORTH_DSP_VALUEHL
2f63			 
2f63 e5				push hl 
2f64				FORTH_DSP_POP 
2f64 cd 05 23			call macro_forth_dsp_pop 
2f67				endm 
# End of macro FORTH_DSP_POP
2f67 c1				pop bc 
2f68			 
2f68			 
2f68				; Get ptr to the word we need to look up 
2f68			 
2f68			;		FORTH_DSP_VALUEHL 
2f68				;v5 FORTH_DSP_VALUE 
2f68			; TODO type check 
2f68			;		inc hl    ; Skip type check  
2f68			;		push hl 
2f68			;		ex de, hl    ; put into DE 
2f68			 
2f68			 
2f68 21 00 80			ld hl, baseram 
2f6b				;ld hl, baseusermem 
2f6b			 
2f6b e5			push hl   ; sacreifical push 
2f6c			 
2f6c			.uldouscanm: 
2f6c e1			pop hl 
2f6d			.uldouscan: 
2f6d			if DEBUG_FORTH_WORDS 
2f6d				DMARK "LSs" 
2f6d f5				push af  
2f6e 3a 82 2f			ld a, (.dmark)  
2f71 32 a0 fd			ld (debug_mark),a  
2f74 3a 83 2f			ld a, (.dmark+1)  
2f77 32 a1 fd			ld (debug_mark+1),a  
2f7a 3a 84 2f			ld a, (.dmark+2)  
2f7d 32 a2 fd			ld (debug_mark+2),a  
2f80 18 03			jr .pastdmark  
2f82 ..			.dmark: db "LSs"  
2f85 f1			.pastdmark: pop af  
2f86			endm  
# End of macro DMARK
2f86				CALLMONITOR 
2f86 cd aa fd			call debug_vector  
2f89				endm  
# End of macro CALLMONITOR
2f89			endif 
2f89			; skip dict stub 
2f89 cd 75 25			call forth_tok_next 
2f8c			 
2f8c			 
2f8c			; while we have words to look for 
2f8c			 
2f8c 7e			ld a, (hl)      
2f8d			if DEBUG_FORTH_WORDS 
2f8d				DMARK "LSk" 
2f8d f5				push af  
2f8e 3a a2 2f			ld a, (.dmark)  
2f91 32 a0 fd			ld (debug_mark),a  
2f94 3a a3 2f			ld a, (.dmark+1)  
2f97 32 a1 fd			ld (debug_mark+1),a  
2f9a 3a a4 2f			ld a, (.dmark+2)  
2f9d 32 a2 fd			ld (debug_mark+2),a  
2fa0 18 03			jr .pastdmark  
2fa2 ..			.dmark: db "LSk"  
2fa5 f1			.pastdmark: pop af  
2fa6			endm  
# End of macro DMARK
2fa6				CALLMONITOR 
2fa6 cd aa fd			call debug_vector  
2fa9				endm  
# End of macro CALLMONITOR
2fa9			endif 
2fa9				;cp WORD_SYS_END 
2fa9				;jp z, .lunotfound 
2fa9			 
2fa9					; if we hit non uwords then gone too far 
2fa9 fe 01				cp WORD_SYS_UWORD 
2fab c2 38 30				jp nz, .ulunotfound 
2fae			 
2fae				if DEBUG_FORTH_WORDS 
2fae					DMARK "LSu" 
2fae f5				push af  
2faf 3a c3 2f			ld a, (.dmark)  
2fb2 32 a0 fd			ld (debug_mark),a  
2fb5 3a c4 2f			ld a, (.dmark+1)  
2fb8 32 a1 fd			ld (debug_mark+1),a  
2fbb 3a c5 2f			ld a, (.dmark+2)  
2fbe 32 a2 fd			ld (debug_mark+2),a  
2fc1 18 03			jr .pastdmark  
2fc3 ..			.dmark: db "LSu"  
2fc6 f1			.pastdmark: pop af  
2fc7			endm  
# End of macro DMARK
2fc7					CALLMONITOR 
2fc7 cd aa fd			call debug_vector  
2fca				endm  
# End of macro CALLMONITOR
2fca				endif 
2fca			 
2fca					; found a uword but is it the one we want... 
2fca			 
2fca c5					push bc     ; uword to find is on bc 
2fcb d1					pop de 
2fcc			 
2fcc e5					push hl  ; to save the ptr 
2fcd			 
2fcd					; skip opcode 
2fcd 23					inc hl  
2fce					; skip next ptr 
2fce 23					inc hl  
2fcf 23					inc hl 
2fd0					; skip len 
2fd0 23					inc hl 
2fd1			 
2fd1				if DEBUG_FORTH_WORDS 
2fd1					DMARK "LSc" 
2fd1 f5				push af  
2fd2 3a e6 2f			ld a, (.dmark)  
2fd5 32 a0 fd			ld (debug_mark),a  
2fd8 3a e7 2f			ld a, (.dmark+1)  
2fdb 32 a1 fd			ld (debug_mark+1),a  
2fde 3a e8 2f			ld a, (.dmark+2)  
2fe1 32 a2 fd			ld (debug_mark+2),a  
2fe4 18 03			jr .pastdmark  
2fe6 ..			.dmark: db "LSc"  
2fe9 f1			.pastdmark: pop af  
2fea			endm  
# End of macro DMARK
2fea					CALLMONITOR 
2fea cd aa fd			call debug_vector  
2fed				endm  
# End of macro CALLMONITOR
2fed				endif 
2fed			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2fed			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2fed			; Nope that has gone the other way. It needs to be exact not on first zero 
2fed			;		call strcmp 
2fed c5					push bc 
2fee cd 89 13				call StrictStrCmp 
2ff1 c1					pop bc 
2ff2 c2 6c 2f				jp nz, .uldouscanm 
2ff5				 
2ff5			 
2ff5			 
2ff5					; we have a uword so push its name to the stack 
2ff5			 
2ff5			;	   	push hl  ; save so we can move to next dict block 
2ff5 e1			pop hl 
2ff6			 
2ff6				if DEBUG_FORTH_WORDS 
2ff6					DMARK "LSm" 
2ff6 f5				push af  
2ff7 3a 0b 30			ld a, (.dmark)  
2ffa 32 a0 fd			ld (debug_mark),a  
2ffd 3a 0c 30			ld a, (.dmark+1)  
3000 32 a1 fd			ld (debug_mark+1),a  
3003 3a 0d 30			ld a, (.dmark+2)  
3006 32 a2 fd			ld (debug_mark+2),a  
3009 18 03			jr .pastdmark  
300b ..			.dmark: db "LSm"  
300e f1			.pastdmark: pop af  
300f			endm  
# End of macro DMARK
300f					CALLMONITOR 
300f cd aa fd			call debug_vector  
3012				endm  
# End of macro CALLMONITOR
3012				endif 
3012			 
3012					; skip opcode 
3012 23					inc hl  
3013					; skip next ptr 
3013 23					inc hl  
3014 23					inc hl 
3015					; skip len 
3015 7e					ld a, (hl)   ; save length to add 
3016				if DEBUG_FORTH_WORDS 
3016					DMARK "LS2" 
3016 f5				push af  
3017 3a 2b 30			ld a, (.dmark)  
301a 32 a0 fd			ld (debug_mark),a  
301d 3a 2c 30			ld a, (.dmark+1)  
3020 32 a1 fd			ld (debug_mark+1),a  
3023 3a 2d 30			ld a, (.dmark+2)  
3026 32 a2 fd			ld (debug_mark+2),a  
3029 18 03			jr .pastdmark  
302b ..			.dmark: db "LS2"  
302e f1			.pastdmark: pop af  
302f			endm  
# End of macro DMARK
302f					CALLMONITOR 
302f cd aa fd			call debug_vector  
3032				endm  
# End of macro CALLMONITOR
3032				endif 
3032			 
3032				; skip zero term and other uword defs to position right at the exec code 
3032 06 04			ld b, 4 
3034 80				add a,b 
3035			 
3035 cd de 0f			call addatohl 
3038					; save this location 
3038				 
3038			.ulunotfound: 
3038 cd 48 20			call forth_push_numhl 
303b						 
303b				NEXTW 
303b c3 38 24			jp macro_next 
303e				endm 
# End of macro NEXTW
303e			.LIST: 
303e			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
303e 5c				db WORD_SYS_CORE+72             
303f 3a 32			dw .FORGET            
3041 05				db 4 + 1 
3042 .. 00			db "LIST",0              
3047				endm 
# End of macro CWHEAD
3047			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
3047			; | | The quoted word must be in upper case. 
3047			if DEBUG_FORTH_WORDS_KEY 
3047				DMARK "LST" 
3047 f5				push af  
3048 3a 5c 30			ld a, (.dmark)  
304b 32 a0 fd			ld (debug_mark),a  
304e 3a 5d 30			ld a, (.dmark+1)  
3051 32 a1 fd			ld (debug_mark+1),a  
3054 3a 5e 30			ld a, (.dmark+2)  
3057 32 a2 fd			ld (debug_mark+2),a  
305a 18 03			jr .pastdmark  
305c ..			.dmark: db "LST"  
305f f1			.pastdmark: pop af  
3060			endm  
# End of macro DMARK
3060				CALLMONITOR 
3060 cd aa fd			call debug_vector  
3063				endm  
# End of macro CALLMONITOR
3063			endif 
3063			 
3063				FORTH_DSP_VALUEHL 
3063 cd 4d 22			call macro_dsp_valuehl 
3066				endm 
# End of macro FORTH_DSP_VALUEHL
3066			 
3066 e5				push hl 
3067				FORTH_DSP_POP 
3067 cd 05 23			call macro_forth_dsp_pop 
306a				endm 
# End of macro FORTH_DSP_POP
306a c1				pop bc 
306b			 
306b			; Start format of scratch string 
306b			 
306b 21 f6 f0			ld hl, scratch 
306e			 
306e 3e 3a			ld a, ':' 
3070 77				ld (hl),a 
3071 23				inc hl 
3072 3e 20			ld a, ' ' 
3074 77				ld (hl), a 
3075			 
3075				; Get ptr to the word we need to look up 
3075			 
3075			;		FORTH_DSP_VALUEHL 
3075				;v5 FORTH_DSP_VALUE 
3075			; TODO type check 
3075			;		inc hl    ; Skip type check  
3075			;		push hl 
3075			;		ex de, hl    ; put into DE 
3075			 
3075			 
3075 21 00 80			ld hl, baseram 
3078				;ld hl, baseusermem 
3078			 
3078 e5			push hl   ; sacreifical push 
3079			 
3079			.ldouscanm: 
3079 e1			pop hl 
307a			.ldouscan: 
307a			if DEBUG_FORTH_WORDS 
307a				DMARK "LSs" 
307a f5				push af  
307b 3a 8f 30			ld a, (.dmark)  
307e 32 a0 fd			ld (debug_mark),a  
3081 3a 90 30			ld a, (.dmark+1)  
3084 32 a1 fd			ld (debug_mark+1),a  
3087 3a 91 30			ld a, (.dmark+2)  
308a 32 a2 fd			ld (debug_mark+2),a  
308d 18 03			jr .pastdmark  
308f ..			.dmark: db "LSs"  
3092 f1			.pastdmark: pop af  
3093			endm  
# End of macro DMARK
3093				CALLMONITOR 
3093 cd aa fd			call debug_vector  
3096				endm  
# End of macro CALLMONITOR
3096			endif 
3096			; skip dict stub 
3096 cd 75 25			call forth_tok_next 
3099			 
3099			 
3099			; while we have words to look for 
3099			 
3099 7e			ld a, (hl)      
309a			if DEBUG_FORTH_WORDS 
309a				DMARK "LSk" 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 a0 fd			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 a1 fd			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 a2 fd			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db "LSk"  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3				CALLMONITOR 
30b3 cd aa fd			call debug_vector  
30b6				endm  
# End of macro CALLMONITOR
30b6			endif 
30b6				;cp WORD_SYS_END 
30b6				;jp z, .lunotfound 
30b6			 
30b6					; if we hit non uwords then gone too far 
30b6 fe 01				cp WORD_SYS_UWORD 
30b8 c2 f6 31				jp nz, .lunotfound 
30bb			 
30bb				if DEBUG_FORTH_WORDS 
30bb					DMARK "LSu" 
30bb f5				push af  
30bc 3a d0 30			ld a, (.dmark)  
30bf 32 a0 fd			ld (debug_mark),a  
30c2 3a d1 30			ld a, (.dmark+1)  
30c5 32 a1 fd			ld (debug_mark+1),a  
30c8 3a d2 30			ld a, (.dmark+2)  
30cb 32 a2 fd			ld (debug_mark+2),a  
30ce 18 03			jr .pastdmark  
30d0 ..			.dmark: db "LSu"  
30d3 f1			.pastdmark: pop af  
30d4			endm  
# End of macro DMARK
30d4					CALLMONITOR 
30d4 cd aa fd			call debug_vector  
30d7				endm  
# End of macro CALLMONITOR
30d7				endif 
30d7			 
30d7					; found a uword but is it the one we want... 
30d7			 
30d7 c5					push bc     ; uword to find is on bc 
30d8 d1					pop de 
30d9			 
30d9 e5					push hl  ; to save the ptr 
30da			 
30da					; skip opcode 
30da 23					inc hl  
30db					; skip next ptr 
30db 23					inc hl  
30dc 23					inc hl 
30dd					; skip len 
30dd 23					inc hl 
30de			 
30de				if DEBUG_FORTH_WORDS 
30de					DMARK "LSc" 
30de f5				push af  
30df 3a f3 30			ld a, (.dmark)  
30e2 32 a0 fd			ld (debug_mark),a  
30e5 3a f4 30			ld a, (.dmark+1)  
30e8 32 a1 fd			ld (debug_mark+1),a  
30eb 3a f5 30			ld a, (.dmark+2)  
30ee 32 a2 fd			ld (debug_mark+2),a  
30f1 18 03			jr .pastdmark  
30f3 ..			.dmark: db "LSc"  
30f6 f1			.pastdmark: pop af  
30f7			endm  
# End of macro DMARK
30f7					CALLMONITOR 
30f7 cd aa fd			call debug_vector  
30fa				endm  
# End of macro CALLMONITOR
30fa				endif 
30fa			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
30fa			; ie. If WOO is defined first and then WO. Couldnt list WO. 
30fa			; Nope that has gone the other way. It needs to be exact not on first zero 
30fa			;		call strcmp 
30fa c5					push bc 
30fb cd 89 13				call StrictStrCmp 
30fe c1					pop bc 
30ff c2 79 30				jp nz, .ldouscanm 
3102				 
3102			 
3102			 
3102					; we have a uword so push its name to the stack 
3102			 
3102			;	   	push hl  ; save so we can move to next dict block 
3102 e1			pop hl 
3103			 
3103				if DEBUG_FORTH_WORDS 
3103					DMARK "LSm" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 a0 fd			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 a1 fd			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 a2 fd			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "LSm"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c					CALLMONITOR 
311c cd aa fd			call debug_vector  
311f				endm  
# End of macro CALLMONITOR
311f				endif 
311f			 
311f					; skip opcode 
311f 23					inc hl  
3120					; skip next ptr 
3120 23					inc hl  
3121 23					inc hl 
3122					; skip len 
3122 7e					ld a, (hl)   ; save length to add 
3123				if DEBUG_FORTH_WORDS 
3123					DMARK "LS2" 
3123 f5				push af  
3124 3a 38 31			ld a, (.dmark)  
3127 32 a0 fd			ld (debug_mark),a  
312a 3a 39 31			ld a, (.dmark+1)  
312d 32 a1 fd			ld (debug_mark+1),a  
3130 3a 3a 31			ld a, (.dmark+2)  
3133 32 a2 fd			ld (debug_mark+2),a  
3136 18 03			jr .pastdmark  
3138 ..			.dmark: db "LS2"  
313b f1			.pastdmark: pop af  
313c			endm  
# End of macro DMARK
313c					CALLMONITOR 
313c cd aa fd			call debug_vector  
313f				endm  
# End of macro CALLMONITOR
313f				endif 
313f			 
313f					; save this location 
313f				 
313f e5					push hl 
3140			 
3140 23					inc hl 
3141 11 f8 f0				ld de, scratch+2 
3144 4f					ld c, a 
3145 06 00				ld b, 0 
3147			 
3147				if DEBUG_FORTH_WORDS 
3147					DMARK "LSn" 
3147 f5				push af  
3148 3a 5c 31			ld a, (.dmark)  
314b 32 a0 fd			ld (debug_mark),a  
314e 3a 5d 31			ld a, (.dmark+1)  
3151 32 a1 fd			ld (debug_mark+1),a  
3154 3a 5e 31			ld a, (.dmark+2)  
3157 32 a2 fd			ld (debug_mark+2),a  
315a 18 03			jr .pastdmark  
315c ..			.dmark: db "LSn"  
315f f1			.pastdmark: pop af  
3160			endm  
# End of macro DMARK
3160					CALLMONITOR 
3160 cd aa fd			call debug_vector  
3163				endm  
# End of macro CALLMONITOR
3163				endif 
3163			 
3163					; copy uword name to scratch 
3163			 
3163			;		ldir 
3163			.licplw:	; copy uword name to scratch converting to lower case as we go 
3163 ed a0				ldi 
3165 1b					dec de 
3166 1a					ld a, (de) 
3167 cd 5c 12				call to_lower 
316a 12					ld (de),a 
316b 13					inc de 
316c 3e 00				ld a, 0 
316e b9					cp c 
316f 20 f2				jr nz, .licplw 
3171			 
3171			 
3171			 
3171 1b					dec de 
3172 3e 20				ld a, ' '    ; change null to space 
3174 12					ld (de), a 
3175			 
3175 13					inc de 
3176			 
3176 d5					push de 
3177 c1					pop bc     ; move scratch pointer to end of word name and save it 
3178			 
3178 e1					pop hl 
3179 7e					ld a, (hl) 
317a					;inc hl 
317a					; skip word string 
317a cd de 0f				call addatohl 
317d			 
317d 23					inc hl 
317e			 
317e				if DEBUG_FORTH_WORDS 
317e					DMARK "LS3" 
317e f5				push af  
317f 3a 93 31			ld a, (.dmark)  
3182 32 a0 fd			ld (debug_mark),a  
3185 3a 94 31			ld a, (.dmark+1)  
3188 32 a1 fd			ld (debug_mark+1),a  
318b 3a 95 31			ld a, (.dmark+2)  
318e 32 a2 fd			ld (debug_mark+2),a  
3191 18 03			jr .pastdmark  
3193 ..			.dmark: db "LS3"  
3196 f1			.pastdmark: pop af  
3197			endm  
# End of macro DMARK
3197					CALLMONITOR 
3197 cd aa fd			call debug_vector  
319a				endm  
# End of macro CALLMONITOR
319a				endif 
319a					; should now be at the start of the machine code to setup the eval of the uword 
319a					; now locate the ptr to the string defintion 
319a			 
319a					; skip ld hl, 
319a					; then load the ptr 
319a			; TODO use get from hl ptr 
319a 23					inc hl 
319b 5e					ld e, (hl) 
319c 23					inc hl 
319d 56					ld d, (hl) 
319e eb					ex de, hl 
319f			 
319f			 
319f				if DEBUG_FORTH_WORDS 
319f					DMARK "LSt" 
319f f5				push af  
31a0 3a b4 31			ld a, (.dmark)  
31a3 32 a0 fd			ld (debug_mark),a  
31a6 3a b5 31			ld a, (.dmark+1)  
31a9 32 a1 fd			ld (debug_mark+1),a  
31ac 3a b6 31			ld a, (.dmark+2)  
31af 32 a2 fd			ld (debug_mark+2),a  
31b2 18 03			jr .pastdmark  
31b4 ..			.dmark: db "LSt"  
31b7 f1			.pastdmark: pop af  
31b8			endm  
# End of macro DMARK
31b8					CALLMONITOR 
31b8 cd aa fd			call debug_vector  
31bb				endm  
# End of macro CALLMONITOR
31bb				endif 
31bb			 
31bb			; cant push right now due to tokenised strings  
31bb			 
31bb			; get the destination of where to copy this definition to. 
31bb			 
31bb c5					push bc 
31bc d1					pop de 
31bd			 
31bd 7e			.listl:         ld a,(hl) 
31be fe 00				cp 0 
31c0 28 09				jr z, .lreplsp     ; replace zero with space 
31c2					;cp FORTH_END_BUFFER 
31c2 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
31c4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
31c6				 
31c6					; just copy this char as is then 
31c6			 
31c6 12					ld (de), a 
31c7			 
31c7 23			.listnxt:	inc hl 
31c8 13					inc de 
31c9 18 f2				jr .listl 
31cb			 
31cb 3e 20		.lreplsp:	ld a,' ' 
31cd 12					ld (de), a 
31ce 18 f7				jr .listnxt 
31d0			 
31d0			; close up uword def 
31d0			 
31d0			.listdone: 
31d0 12					ld (de), a 
31d1 13					inc de 
31d2 3e 00				ld a, 0 
31d4 12					ld (de), a 
31d5			 
31d5			; now have def so clean up and push to stack 
31d5			 
31d5 21 f6 f0				ld hl, scratch 
31d8				if DEBUG_FORTH_WORDS 
31d8					DMARK "Ltp" 
31d8 f5				push af  
31d9 3a ed 31			ld a, (.dmark)  
31dc 32 a0 fd			ld (debug_mark),a  
31df 3a ee 31			ld a, (.dmark+1)  
31e2 32 a1 fd			ld (debug_mark+1),a  
31e5 3a ef 31			ld a, (.dmark+2)  
31e8 32 a2 fd			ld (debug_mark+2),a  
31eb 18 03			jr .pastdmark  
31ed ..			.dmark: db "Ltp"  
31f0 f1			.pastdmark: pop af  
31f1			endm  
# End of macro DMARK
31f1					CALLMONITOR 
31f1 cd aa fd			call debug_vector  
31f4				endm  
# End of macro CALLMONITOR
31f4				endif 
31f4			 
31f4 18 1f			jr .listpush 
31f6			 
31f6			;.lnuword:	pop hl 
31f6			;		call forth_tok_next 
31f6			;		jp .ldouscan  
31f6			 
31f6			.lunotfound:		  
31f6			 
31f6				if DEBUG_FORTH_WORDS 
31f6					DMARK "LSn" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 a0 fd			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 a1 fd			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 a2 fd			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "LSn"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f					CALLMONITOR 
320f cd aa fd			call debug_vector  
3212				endm  
# End of macro CALLMONITOR
3212				endif 
3212			 
3212					 
3212			;		FORTH_DSP_POP 
3212			;		ld hl, .luno 
3212			 
3212					NEXTW			 
3212 c3 38 24			jp macro_next 
3215				endm 
# End of macro NEXTW
3215			 
3215			.listpush: 
3215				if DEBUG_FORTH_WORDS 
3215					DMARK "LS>" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 a0 fd			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 a1 fd			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 a2 fd			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "LS>"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e					CALLMONITOR 
322e cd aa fd			call debug_vector  
3231				endm  
# End of macro CALLMONITOR
3231				endif 
3231 cd b6 20				call forth_push_str 
3234			 
3234			 
3234			 
3234					NEXTW 
3234 c3 38 24			jp macro_next 
3237				endm 
# End of macro NEXTW
3237			 
3237			;.luno:    db "Word not found",0 
3237			 
3237			 
3237			 
3237			 
3237			 
3237			;		push hl   ; save pointer to start of uword def string 
3237			; 
3237			;; look for FORTH_EOL_LINE 
3237			;		ld a, FORTH_END_BUFFER 
3237			;		call strlent 
3237			; 
3237			;		inc hl		 ; space for coln def 
3237			;		inc hl 
3237			;		inc hl          ; space for terms 
3237			;		inc hl 
3237			; 
3237			;		ld a, 20   ; TODO get actual length 
3237			;		call addatohl    ; include a random amount of room for the uword name 
3237			; 
3237			;		 
3237			;	if DEBUG_FORTH_WORDS 
3237			;		DMARK "Lt1" 
3237			;		CALLMONITOR 
3237			;	endif 
3237			;		 
3237			; 
3237			;; malloc space for the string because we cant change it 
3237			; 
3237			;		call malloc 
3237			;	if DEBUG_FORTH_MALLOC_GUARD 
3237			;		push af 
3237			;		call ishlzero 
3237			;		pop af 
3237			;		 
3237			;		call z,malloc_error 
3237			;	endif 
3237			; 
3237			;	if DEBUG_FORTH_WORDS 
3237			;		DMARK "Lt2" 
3237			;		CALLMONITOR 
3237			;	endif 
3237			;		pop de 
3237			;		push hl    ; push the malloc to release later 
3237			;		push hl   ;  push back a copy for the later stack push 
3237			;		 
3237			;; copy the string swapping out the zero terms for spaces 
3237			; 
3237			;		; de has our source 
3237			;		; hl has our dest 
3237			; 
3237			;; add the coln def 
3237			; 
3237			;		ld a, ':' 
3237			;		ld (hl), a 
3237			;		inc hl 
3237			;		ld a, ' ' 
3237			;		ld (hl), a 
3237			;		inc hl 
3237			; 
3237			;; add the uname word 
3237			;		push de   ; save our string for now 
3237			;		ex de, hl 
3237			; 
3237			;		FORTH_DSP_VALUE 
3237			;		;v5 FORTH_DSP_VALUE 
3237			; 
3237			;		inc hl   ; skip type but we know by now this is OK 
3237			; 
3237			;.luword:	ld a,(hl) 
3237			;		cp 0 
3237			;		jr z, .luword2 
3237			;		ld (de), a 
3237			;		inc de 
3237			;		inc hl 
3237			;		jr .luword 
3237			; 
3237			;.luword2:	ld a, ' ' 
3237			;		ld (de), a 
3237			;;		inc hl 
3237			;;		inc de 
3237			;;		ld (de), a 
3237			;;		inc hl 
3237			;		inc de 
3237			; 
3237			;		ex de, hl 
3237			;		pop de 
3237			;		 
3237			;		 
3237			; 
3237			;; detoken that string and copy it 
3237			; 
3237			;	if DEBUG_FORTH_WORDS 
3237			;		DMARK "Lt2" 
3237			;		CALLMONITOR 
3237			;	endif 
3237			;.ldetok:	ld a, (de) 
3237			;		cp FORTH_END_BUFFER 
3237			;		jr z, .ldetokend 
3237			;		; swap out any zero term for space 
3237			;		cp 0 
3237			;		jr nz, .ldetoknext 
3237			;		ld a, ' ' 
3237			; 
3237			;	if DEBUG_FORTH_WORDS 
3237			;		DMARK "LtS" 
3237			;		CALLMONITOR 
3237			;	endif 
3237			;.ldetoknext:	ld (hl), a 
3237			;		inc de 
3237			;		inc hl 
3237			;		jr .ldetok 
3237			; 
3237			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
3237			;		ld (hl), a  
3237			; 
3237			;; free that temp malloc 
3237			; 
3237			;		pop hl    
3237			; 
3237			;	if DEBUG_FORTH_WORDS 
3237			;		DMARK "Lt4" 
3237			;		CALLMONITOR 
3237			;	endif 
3237			;		call forth_apushstrhl 
3237			; 
3237			;		; get rid of temp malloc area 
3237			; 
3237			;		pop hl 
3237			;		call free 
3237			; 
3237			;		jr .ludone 
3237			; 
3237			;.lnuword:	pop hl 
3237			;		call forth_tok_next 
3237			;		jp .ldouscan  
3237			; 
3237			;.ludone:		 pop hl 
3237			; 
3237					NEXTW 
3237 c3 38 24			jp macro_next 
323a				endm 
# End of macro NEXTW
323a			 
323a			.FORGET: 
323a				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
323a 5d				db WORD_SYS_CORE+73             
323b b3 32			dw .NOP            
323d 07				db 6 + 1 
323e .. 00			db "FORGET",0              
3245				endm 
# End of macro CWHEAD
3245			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3245			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
3245			; | |  
3245			; | | e.g. "MORE" forget 
3245					if DEBUG_FORTH_WORDS_KEY 
3245						DMARK "FRG" 
3245 f5				push af  
3246 3a 5a 32			ld a, (.dmark)  
3249 32 a0 fd			ld (debug_mark),a  
324c 3a 5b 32			ld a, (.dmark+1)  
324f 32 a1 fd			ld (debug_mark+1),a  
3252 3a 5c 32			ld a, (.dmark+2)  
3255 32 a2 fd			ld (debug_mark+2),a  
3258 18 03			jr .pastdmark  
325a ..			.dmark: db "FRG"  
325d f1			.pastdmark: pop af  
325e			endm  
# End of macro DMARK
325e						CALLMONITOR 
325e cd aa fd			call debug_vector  
3261				endm  
# End of macro CALLMONITOR
3261					endif 
3261			 
3261				; find uword 
3261			        ; update start of word with "_" 
3261				; replace uword with deleted flag 
3261			 
3261			 
3261			;	if DEBUG_FORTH_WORDS 
3261			;		DMARK "FOG" 
3261			;		CALLMONITOR 
3261			;	endif 
3261			 
3261			 
3261					; Get ptr to the word we need to look up 
3261			 
3261					FORTH_DSP_VALUEHL 
3261 cd 4d 22			call macro_dsp_valuehl 
3264				endm 
# End of macro FORTH_DSP_VALUEHL
3264					;v5 FORTH_DSP_VALUE 
3264				; TODO type check 
3264			;		inc hl    ; Skip type check  
3264 e5					push hl 
3265 c1					pop bc 
3266			;		ex de, hl    ; put into DE 
3266			 
3266			 
3266 21 00 80				ld hl, baseram 
3269					;ld hl, baseusermem 
3269			 
3269				; skip dict stub 
3269			;	call forth_tok_next 
3269 e5			push hl   ; sacreifical push 
326a			 
326a			.fldouscanm: 
326a e1				pop hl 
326b			.fldouscan: 
326b			;	if DEBUG_FORTH_WORDS 
326b			;		DMARK "LSs" 
326b			;		CALLMONITOR 
326b			;	endif 
326b				; skip dict stub 
326b cd 75 25				call forth_tok_next 
326e			 
326e			 
326e			; while we have words to look for 
326e			 
326e 7e				ld a, (hl)      
326f			;	if DEBUG_FORTH_WORDS 
326f			;		DMARK "LSk" 
326f			;		CALLMONITOR 
326f			;	endif 
326f fe 00				cp WORD_SYS_END 
3271 ca ad 32				jp z, .flunotfound 
3274 fe 01				cp WORD_SYS_UWORD 
3276 c2 6b 32				jp nz, .fldouscan 
3279			 
3279			;	if DEBUG_FORTH_WORDS 
3279			;		DMARK "LSu" 
3279			;		CALLMONITOR 
3279			;	endif 
3279			 
3279					; found a uword but is it the one we want... 
3279			 
3279 c5					push bc     ; uword to find is on bc 
327a d1					pop de 
327b			 
327b e5					push hl  ; to save the ptr 
327c			 
327c					; skip opcode 
327c 23					inc hl  
327d					; skip next ptr 
327d 23					inc hl  
327e 23					inc hl 
327f					; skip len 
327f 23					inc hl 
3280			 
3280			;	if DEBUG_FORTH_WORDS 
3280			;		DMARK "LSc" 
3280			;		CALLMONITOR 
3280			;	endif 
3280 cd 7c 13				call strcmp 
3283 c2 6a 32				jp nz, .fldouscanm 
3286			; 
3286			; 
3286			;; while we have words to look for 
3286			; 
3286			;.fdouscan:	ld a, (hl)      
3286			;	if DEBUG_FORTH_WORDS 
3286			;		DMARK "LSs" 
3286			;		CALLMONITOR 
3286			;	endif 
3286			;		cp WORD_SYS_END 
3286			;		jp z, .fudone 
3286			;		cp WORD_SYS_UWORD 
3286			;		jp nz, .fnuword 
3286			; 
3286			;	if DEBUG_FORTH_WORDS 
3286			;		DMARK "FGu" 
3286			;		CALLMONITOR 
3286			;	endif 
3286			; 
3286			;		; found a uword but is it the one we want... 
3286			; 
3286			; 
3286			;	        pop de   ; get back the dsp name 
3286			;		push de 
3286			; 
3286			;		push hl  ; to save the ptr 
3286			; 
3286			;		; skip opcode 
3286			;		inc hl  
3286			;		; skip next ptr 
3286			;		inc hl  
3286			;		inc hl 
3286			;		; skip len 
3286			;		inc hl 
3286			; 
3286			;	if DEBUG_FORTH_WORDS 
3286			;		DMARK "FGc" 
3286			;		CALLMONITOR 
3286			;	endif 
3286			;		call strcmp 
3286			;		jp nz, .fnuword 
3286			 
3286			 
3286 e1			pop hl 
3287			 
3287				 
3287				if DEBUG_FORTH_WORDS 
3287					DMARK "FGm" 
3287 f5				push af  
3288 3a 9c 32			ld a, (.dmark)  
328b 32 a0 fd			ld (debug_mark),a  
328e 3a 9d 32			ld a, (.dmark+1)  
3291 32 a1 fd			ld (debug_mark+1),a  
3294 3a 9e 32			ld a, (.dmark+2)  
3297 32 a2 fd			ld (debug_mark+2),a  
329a 18 03			jr .pastdmark  
329c ..			.dmark: db "FGm"  
329f f1			.pastdmark: pop af  
32a0			endm  
# End of macro DMARK
32a0					CALLMONITOR 
32a0 cd aa fd			call debug_vector  
32a3				endm  
# End of macro CALLMONITOR
32a3				endif 
32a3			 
32a3			 
32a3			 
32a3					; we have a uword so push its name to the stack 
32a3			 
32a3			;	   	push hl  ; save so we can move to next dict block 
32a3			;pop hl 
32a3			 
32a3					; update opcode to deleted 
32a3 3e 03				ld a, WORD_SYS_DELETED 
32a5 77					ld (hl), a 
32a6			 
32a6 23					inc hl  
32a7					; skip next ptr 
32a7 23					inc hl  
32a8 23					inc hl 
32a9					; skip len 
32a9 23					inc hl 
32aa			 
32aa					; TODO change parser to skip deleted words but for now mark it out 
32aa 3e 5f				ld a, "_" 
32ac 77					ld  (hl),a 
32ad			 
32ad			;		jr .fudone 
32ad			; 
32ad			;.fnuword:	pop hl 
32ad			;		call forth_tok_next 
32ad			;		jp .fdouscan  
32ad			 
32ad			.flunotfound:		  
32ad			 
32ad			 
32ad					 
32ad					FORTH_DSP_POP 
32ad cd 05 23			call macro_forth_dsp_pop 
32b0				endm 
# End of macro FORTH_DSP_POP
32b0			;		ld hl, .luno 
32b0			;.fudone:		 pop hl 
32b0					NEXTW 
32b0 c3 38 24			jp macro_next 
32b3				endm 
# End of macro NEXTW
32b3			.NOP: 
32b3				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
32b3 61				db WORD_SYS_CORE+77             
32b4 da 32			dw .COMO            
32b6 04				db 3 + 1 
32b7 .. 00			db "NOP",0              
32bb				endm 
# End of macro CWHEAD
32bb			; | NOP (  --  ) Do nothing | DONE 
32bb					if DEBUG_FORTH_WORDS_KEY 
32bb						DMARK "NOP" 
32bb f5				push af  
32bc 3a d0 32			ld a, (.dmark)  
32bf 32 a0 fd			ld (debug_mark),a  
32c2 3a d1 32			ld a, (.dmark+1)  
32c5 32 a1 fd			ld (debug_mark+1),a  
32c8 3a d2 32			ld a, (.dmark+2)  
32cb 32 a2 fd			ld (debug_mark+2),a  
32ce 18 03			jr .pastdmark  
32d0 ..			.dmark: db "NOP"  
32d3 f1			.pastdmark: pop af  
32d4			endm  
# End of macro DMARK
32d4						CALLMONITOR 
32d4 cd aa fd			call debug_vector  
32d7				endm  
# End of macro CALLMONITOR
32d7					endif 
32d7				       NEXTW 
32d7 c3 38 24			jp macro_next 
32da				endm 
# End of macro NEXTW
32da			.COMO: 
32da				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
32da 6e				db WORD_SYS_CORE+90             
32db 2c 33			dw .COMC            
32dd 02				db 1 + 1 
32de .. 00			db "(",0              
32e0				endm 
# End of macro CWHEAD
32e0			; | ( ( -- )  Start of comment | DONE 
32e0			 
32e0			 
32e0 2a f7 f3				ld hl, ( os_tok_ptr) 
32e3 11 27 33			ld de, .closepar 
32e6					 
32e6					if DEBUG_FORTH_WORDS 
32e6						DMARK ").." 
32e6 f5				push af  
32e7 3a fb 32			ld a, (.dmark)  
32ea 32 a0 fd			ld (debug_mark),a  
32ed 3a fc 32			ld a, (.dmark+1)  
32f0 32 a1 fd			ld (debug_mark+1),a  
32f3 3a fd 32			ld a, (.dmark+2)  
32f6 32 a2 fd			ld (debug_mark+2),a  
32f9 18 03			jr .pastdmark  
32fb ..			.dmark: db ").."  
32fe f1			.pastdmark: pop af  
32ff			endm  
# End of macro DMARK
32ff						CALLMONITOR 
32ff cd aa fd			call debug_vector  
3302				endm  
# End of macro CALLMONITOR
3302					endif 
3302 cd 3f 25			call findnexttok  
3305			 
3305					if DEBUG_FORTH_WORDS 
3305						DMARK "IF5" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 a0 fd			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 a1 fd			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 a2 fd			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "IF5"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd aa fd			call debug_vector  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321				; replace below with ) exec using tok_ptr 
3321 22 f7 f3			ld (os_tok_ptr), hl 
3324 c3 c1 24			jp exec1 
3327			 
3327 .. 00			.closepar:   db ")",0 
3329			 
3329				       NEXTW 
3329 c3 38 24			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.COMC: 
332c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
332c 6f				db WORD_SYS_CORE+91             
332d 35 33			dw .SCRATCH            
332f 02				db 1 + 1 
3330 .. 00			db ")",0              
3332				endm 
# End of macro CWHEAD
3332			; | ) ( -- )  End of comment |  DONE  
3332				       NEXTW 
3332 c3 38 24			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			 
3335			.SCRATCH: 
3335				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3335 6f				db WORD_SYS_CORE+91             
3336 70 33			dw .INC            
3338 08				db 7 + 1 
3339 .. 00			db "SCRATCH",0              
3341				endm 
# End of macro CWHEAD
3341			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3341			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3341			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3341			; | |  
3341			; | | e.g.    : score $00 scratch ; 
3341			; | |  
3341			; | | $00 score ! 
3341			; | | $01 score +! 
3341			; | |  
3341			; | | e.g.   : varword $0a scratch ;  
3341			; | | 
3341			; | | $8000 varword ! 
3341					if DEBUG_FORTH_WORDS_KEY 
3341						DMARK "SCR" 
3341 f5				push af  
3342 3a 56 33			ld a, (.dmark)  
3345 32 a0 fd			ld (debug_mark),a  
3348 3a 57 33			ld a, (.dmark+1)  
334b 32 a1 fd			ld (debug_mark+1),a  
334e 3a 58 33			ld a, (.dmark+2)  
3351 32 a2 fd			ld (debug_mark+2),a  
3354 18 03			jr .pastdmark  
3356 ..			.dmark: db "SCR"  
3359 f1			.pastdmark: pop af  
335a			endm  
# End of macro DMARK
335a						CALLMONITOR 
335a cd aa fd			call debug_vector  
335d				endm  
# End of macro CALLMONITOR
335d					endif 
335d			 
335d					FORTH_DSP_VALUEHL 
335d cd 4d 22			call macro_dsp_valuehl 
3360				endm 
# End of macro FORTH_DSP_VALUEHL
3360				 
3360					FORTH_DSP_POP 
3360 cd 05 23			call macro_forth_dsp_pop 
3363				endm 
# End of macro FORTH_DSP_POP
3363			 
3363 7d					ld a, l 
3364 21 1b f6				ld hl, os_var_array 
3367 cd de 0f				call addatohl 
336a			 
336a cd 48 20				call forth_push_numhl 
336d			 
336d				       NEXTW 
336d c3 38 24			jp macro_next 
3370				endm 
# End of macro NEXTW
3370			 
3370			.INC: 
3370				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3370 6f				db WORD_SYS_CORE+91             
3371 c6 33			dw .DEC            
3373 03				db 2 + 1 
3374 .. 00			db "+!",0              
3377				endm 
# End of macro CWHEAD
3377			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3377					if DEBUG_FORTH_WORDS_KEY 
3377						DMARK "+s_" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 a0 fd			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 a1 fd			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 a2 fd			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "+s_"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390						CALLMONITOR 
3390 cd aa fd			call debug_vector  
3393				endm  
# End of macro CALLMONITOR
3393					endif 
3393			 
3393					FORTH_DSP_VALUEHL 
3393 cd 4d 22			call macro_dsp_valuehl 
3396				endm 
# End of macro FORTH_DSP_VALUEHL
3396			 
3396 e5					push hl   ; save address 
3397			 
3397					FORTH_DSP_POP 
3397 cd 05 23			call macro_forth_dsp_pop 
339a				endm 
# End of macro FORTH_DSP_POP
339a			 
339a					FORTH_DSP_VALUEHL 
339a cd 4d 22			call macro_dsp_valuehl 
339d				endm 
# End of macro FORTH_DSP_VALUEHL
339d			 
339d e5					push hl 
339e					FORTH_DSP_POP 
339e cd 05 23			call macro_forth_dsp_pop 
33a1				endm 
# End of macro FORTH_DSP_POP
33a1 e1					pop hl 
33a2			 
33a2					; hl contains value to add to byte at a 
33a2				 
33a2 eb					ex de, hl 
33a3			 
33a3 e1					pop hl 
33a4			 
33a4					if DEBUG_FORTH_WORDS 
33a4						DMARK "INC" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 a0 fd			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 a1 fd			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 a2 fd			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "INC"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd						CALLMONITOR 
33bd cd aa fd			call debug_vector  
33c0				endm  
# End of macro CALLMONITOR
33c0					endif 
33c0			 
33c0 7e					ld a,(hl) 
33c1 83					add e 
33c2 77					ld (hl),a 
33c3			 
33c3			 
33c3			 
33c3				       NEXTW 
33c3 c3 38 24			jp macro_next 
33c6				endm 
# End of macro NEXTW
33c6			 
33c6			.DEC: 
33c6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
33c6 6f				db WORD_SYS_CORE+91             
33c7 1a 34			dw .INC2            
33c9 03				db 2 + 1 
33ca .. 00			db "-!",0              
33cd				endm 
# End of macro CWHEAD
33cd			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
33cd					if DEBUG_FORTH_WORDS_KEY 
33cd						DMARK "-s_" 
33cd f5				push af  
33ce 3a e2 33			ld a, (.dmark)  
33d1 32 a0 fd			ld (debug_mark),a  
33d4 3a e3 33			ld a, (.dmark+1)  
33d7 32 a1 fd			ld (debug_mark+1),a  
33da 3a e4 33			ld a, (.dmark+2)  
33dd 32 a2 fd			ld (debug_mark+2),a  
33e0 18 03			jr .pastdmark  
33e2 ..			.dmark: db "-s_"  
33e5 f1			.pastdmark: pop af  
33e6			endm  
# End of macro DMARK
33e6						CALLMONITOR 
33e6 cd aa fd			call debug_vector  
33e9				endm  
# End of macro CALLMONITOR
33e9					endif 
33e9			 
33e9					FORTH_DSP_VALUEHL 
33e9 cd 4d 22			call macro_dsp_valuehl 
33ec				endm 
# End of macro FORTH_DSP_VALUEHL
33ec			 
33ec e5					push hl   ; save address 
33ed			 
33ed					FORTH_DSP_POP 
33ed cd 05 23			call macro_forth_dsp_pop 
33f0				endm 
# End of macro FORTH_DSP_POP
33f0			 
33f0					FORTH_DSP_VALUEHL 
33f0 cd 4d 22			call macro_dsp_valuehl 
33f3				endm 
# End of macro FORTH_DSP_VALUEHL
33f3			 
33f3					; hl contains value to add to byte at a 
33f3				 
33f3 eb					ex de, hl 
33f4			 
33f4 e1					pop hl 
33f5			 
33f5					if DEBUG_FORTH_WORDS 
33f5						DMARK "DEC" 
33f5 f5				push af  
33f6 3a 0a 34			ld a, (.dmark)  
33f9 32 a0 fd			ld (debug_mark),a  
33fc 3a 0b 34			ld a, (.dmark+1)  
33ff 32 a1 fd			ld (debug_mark+1),a  
3402 3a 0c 34			ld a, (.dmark+2)  
3405 32 a2 fd			ld (debug_mark+2),a  
3408 18 03			jr .pastdmark  
340a ..			.dmark: db "DEC"  
340d f1			.pastdmark: pop af  
340e			endm  
# End of macro DMARK
340e						CALLMONITOR 
340e cd aa fd			call debug_vector  
3411				endm  
# End of macro CALLMONITOR
3411					endif 
3411			 
3411 7e					ld a,(hl) 
3412 93					sub e 
3413 77					ld (hl),a 
3414			 
3414			 
3414					FORTH_DSP_POP 
3414 cd 05 23			call macro_forth_dsp_pop 
3417				endm 
# End of macro FORTH_DSP_POP
3417			 
3417				       NEXTW 
3417 c3 38 24			jp macro_next 
341a				endm 
# End of macro NEXTW
341a			 
341a			.INC2: 
341a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
341a 6f				db WORD_SYS_CORE+91             
341b c7 34			dw .DEC2            
341d 04				db 3 + 1 
341e .. 00			db "+2!",0              
3422				endm 
# End of macro CWHEAD
3422			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3422			 
3422					if DEBUG_FORTH_WORDS_KEY 
3422						DMARK "+2s" 
3422 f5				push af  
3423 3a 37 34			ld a, (.dmark)  
3426 32 a0 fd			ld (debug_mark),a  
3429 3a 38 34			ld a, (.dmark+1)  
342c 32 a1 fd			ld (debug_mark+1),a  
342f 3a 39 34			ld a, (.dmark+2)  
3432 32 a2 fd			ld (debug_mark+2),a  
3435 18 03			jr .pastdmark  
3437 ..			.dmark: db "+2s"  
343a f1			.pastdmark: pop af  
343b			endm  
# End of macro DMARK
343b						CALLMONITOR 
343b cd aa fd			call debug_vector  
343e				endm  
# End of macro CALLMONITOR
343e					endif 
343e			 
343e					; Address 
343e			 
343e					FORTH_DSP_VALUEHL 
343e cd 4d 22			call macro_dsp_valuehl 
3441				endm 
# End of macro FORTH_DSP_VALUEHL
3441			 
3441 e5					push hl    ; save address 
3442			 
3442					; load content into de 
3442			 
3442 5e					ld e,(hl) 
3443 23					inc hl 
3444 56					ld d, (hl) 
3445			 
3445					if DEBUG_FORTH_WORDS 
3445						DMARK "+2a" 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 a0 fd			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 a1 fd			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 a2 fd			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "+2a"  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd aa fd			call debug_vector  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			 
3461					FORTH_DSP_POP 
3461 cd 05 23			call macro_forth_dsp_pop 
3464				endm 
# End of macro FORTH_DSP_POP
3464			 
3464					; Get value to add 
3464			 
3464					FORTH_DSP_VALUE 
3464 cd 36 22			call macro_forth_dsp_value 
3467				endm 
# End of macro FORTH_DSP_VALUE
3467			 
3467					if DEBUG_FORTH_WORDS 
3467						DMARK "+2v" 
3467 f5				push af  
3468 3a 7c 34			ld a, (.dmark)  
346b 32 a0 fd			ld (debug_mark),a  
346e 3a 7d 34			ld a, (.dmark+1)  
3471 32 a1 fd			ld (debug_mark+1),a  
3474 3a 7e 34			ld a, (.dmark+2)  
3477 32 a2 fd			ld (debug_mark+2),a  
347a 18 03			jr .pastdmark  
347c ..			.dmark: db "+2v"  
347f f1			.pastdmark: pop af  
3480			endm  
# End of macro DMARK
3480						CALLMONITOR 
3480 cd aa fd			call debug_vector  
3483				endm  
# End of macro CALLMONITOR
3483					endif 
3483			 
3483 19					add hl, de 
3484			 
3484					if DEBUG_FORTH_WORDS 
3484						DMARK "+2+" 
3484 f5				push af  
3485 3a 99 34			ld a, (.dmark)  
3488 32 a0 fd			ld (debug_mark),a  
348b 3a 9a 34			ld a, (.dmark+1)  
348e 32 a1 fd			ld (debug_mark+1),a  
3491 3a 9b 34			ld a, (.dmark+2)  
3494 32 a2 fd			ld (debug_mark+2),a  
3497 18 03			jr .pastdmark  
3499 ..			.dmark: db "+2+"  
349c f1			.pastdmark: pop af  
349d			endm  
# End of macro DMARK
349d						CALLMONITOR 
349d cd aa fd			call debug_vector  
34a0				endm  
# End of macro CALLMONITOR
34a0					endif 
34a0			 
34a0					; move result to de 
34a0			 
34a0 eb					ex de, hl 
34a1			 
34a1					; Address 
34a1			 
34a1 e1					pop hl 
34a2			 
34a2					; save it back 
34a2			 
34a2 73					ld (hl), e 
34a3 23					inc hl 
34a4 72					ld (hl), d 
34a5			 
34a5					if DEBUG_FORTH_WORDS 
34a5						DMARK "+2e" 
34a5 f5				push af  
34a6 3a ba 34			ld a, (.dmark)  
34a9 32 a0 fd			ld (debug_mark),a  
34ac 3a bb 34			ld a, (.dmark+1)  
34af 32 a1 fd			ld (debug_mark+1),a  
34b2 3a bc 34			ld a, (.dmark+2)  
34b5 32 a2 fd			ld (debug_mark+2),a  
34b8 18 03			jr .pastdmark  
34ba ..			.dmark: db "+2e"  
34bd f1			.pastdmark: pop af  
34be			endm  
# End of macro DMARK
34be						CALLMONITOR 
34be cd aa fd			call debug_vector  
34c1				endm  
# End of macro CALLMONITOR
34c1					endif 
34c1			 
34c1			 
34c1			 
34c1					FORTH_DSP_POP 
34c1 cd 05 23			call macro_forth_dsp_pop 
34c4				endm 
# End of macro FORTH_DSP_POP
34c4			 
34c4			 
34c4				       NEXTW 
34c4 c3 38 24			jp macro_next 
34c7				endm 
# End of macro NEXTW
34c7			 
34c7			.DEC2: 
34c7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
34c7 6f				db WORD_SYS_CORE+91             
34c8 76 35			dw .GET2            
34ca 04				db 3 + 1 
34cb .. 00			db "-2!",0              
34cf				endm 
# End of macro CWHEAD
34cf			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
34cf			 
34cf			 
34cf					if DEBUG_FORTH_WORDS_KEY 
34cf						DMARK "-2s" 
34cf f5				push af  
34d0 3a e4 34			ld a, (.dmark)  
34d3 32 a0 fd			ld (debug_mark),a  
34d6 3a e5 34			ld a, (.dmark+1)  
34d9 32 a1 fd			ld (debug_mark+1),a  
34dc 3a e6 34			ld a, (.dmark+2)  
34df 32 a2 fd			ld (debug_mark+2),a  
34e2 18 03			jr .pastdmark  
34e4 ..			.dmark: db "-2s"  
34e7 f1			.pastdmark: pop af  
34e8			endm  
# End of macro DMARK
34e8						CALLMONITOR 
34e8 cd aa fd			call debug_vector  
34eb				endm  
# End of macro CALLMONITOR
34eb					endif 
34eb			 
34eb					; Address 
34eb			 
34eb					FORTH_DSP_VALUEHL 
34eb cd 4d 22			call macro_dsp_valuehl 
34ee				endm 
# End of macro FORTH_DSP_VALUEHL
34ee			 
34ee e5					push hl    ; save address 
34ef			 
34ef					; load content into de 
34ef			 
34ef 5e					ld e,(hl) 
34f0 23					inc hl 
34f1 56					ld d, (hl) 
34f2			 
34f2					if DEBUG_FORTH_WORDS 
34f2						DMARK "-2a" 
34f2 f5				push af  
34f3 3a 07 35			ld a, (.dmark)  
34f6 32 a0 fd			ld (debug_mark),a  
34f9 3a 08 35			ld a, (.dmark+1)  
34fc 32 a1 fd			ld (debug_mark+1),a  
34ff 3a 09 35			ld a, (.dmark+2)  
3502 32 a2 fd			ld (debug_mark+2),a  
3505 18 03			jr .pastdmark  
3507 ..			.dmark: db "-2a"  
350a f1			.pastdmark: pop af  
350b			endm  
# End of macro DMARK
350b						CALLMONITOR 
350b cd aa fd			call debug_vector  
350e				endm  
# End of macro CALLMONITOR
350e					endif 
350e			 
350e					FORTH_DSP_POP 
350e cd 05 23			call macro_forth_dsp_pop 
3511				endm 
# End of macro FORTH_DSP_POP
3511			 
3511					; Get value to remove 
3511			 
3511					FORTH_DSP_VALUE 
3511 cd 36 22			call macro_forth_dsp_value 
3514				endm 
# End of macro FORTH_DSP_VALUE
3514			 
3514					if DEBUG_FORTH_WORDS 
3514						DMARK "-2v" 
3514 f5				push af  
3515 3a 29 35			ld a, (.dmark)  
3518 32 a0 fd			ld (debug_mark),a  
351b 3a 2a 35			ld a, (.dmark+1)  
351e 32 a1 fd			ld (debug_mark+1),a  
3521 3a 2b 35			ld a, (.dmark+2)  
3524 32 a2 fd			ld (debug_mark+2),a  
3527 18 03			jr .pastdmark  
3529 ..			.dmark: db "-2v"  
352c f1			.pastdmark: pop af  
352d			endm  
# End of macro DMARK
352d						CALLMONITOR 
352d cd aa fd			call debug_vector  
3530				endm  
# End of macro CALLMONITOR
3530					endif 
3530			 
3530 eb					ex de, hl 
3531 ed 52				sbc hl, de 
3533			 
3533					if DEBUG_FORTH_WORDS 
3533						DMARK "-2d" 
3533 f5				push af  
3534 3a 48 35			ld a, (.dmark)  
3537 32 a0 fd			ld (debug_mark),a  
353a 3a 49 35			ld a, (.dmark+1)  
353d 32 a1 fd			ld (debug_mark+1),a  
3540 3a 4a 35			ld a, (.dmark+2)  
3543 32 a2 fd			ld (debug_mark+2),a  
3546 18 03			jr .pastdmark  
3548 ..			.dmark: db "-2d"  
354b f1			.pastdmark: pop af  
354c			endm  
# End of macro DMARK
354c						CALLMONITOR 
354c cd aa fd			call debug_vector  
354f				endm  
# End of macro CALLMONITOR
354f					endif 
354f			 
354f					; move result to de 
354f			 
354f eb					ex de, hl 
3550			 
3550					; Address 
3550			 
3550 e1					pop hl 
3551			 
3551					; save it back 
3551			 
3551 73					ld (hl), e 
3552 23					inc hl 
3553 72					ld (hl), d 
3554			 
3554					if DEBUG_FORTH_WORDS 
3554						DMARK "-2e" 
3554 f5				push af  
3555 3a 69 35			ld a, (.dmark)  
3558 32 a0 fd			ld (debug_mark),a  
355b 3a 6a 35			ld a, (.dmark+1)  
355e 32 a1 fd			ld (debug_mark+1),a  
3561 3a 6b 35			ld a, (.dmark+2)  
3564 32 a2 fd			ld (debug_mark+2),a  
3567 18 03			jr .pastdmark  
3569 ..			.dmark: db "-2e"  
356c f1			.pastdmark: pop af  
356d			endm  
# End of macro DMARK
356d						CALLMONITOR 
356d cd aa fd			call debug_vector  
3570				endm  
# End of macro CALLMONITOR
3570					endif 
3570			 
3570			 
3570					FORTH_DSP_POP 
3570 cd 05 23			call macro_forth_dsp_pop 
3573				endm 
# End of macro FORTH_DSP_POP
3573			 
3573			 
3573			 
3573				       NEXTW 
3573 c3 38 24			jp macro_next 
3576				endm 
# End of macro NEXTW
3576			.GET2: 
3576				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3576 6f				db WORD_SYS_CORE+91             
3577 ab 35			dw .BANG2            
3579 03				db 2 + 1 
357a .. 00			db "2@",0              
357d				endm 
# End of macro CWHEAD
357d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
357d					if DEBUG_FORTH_WORDS_KEY 
357d						DMARK "2A_" 
357d f5				push af  
357e 3a 92 35			ld a, (.dmark)  
3581 32 a0 fd			ld (debug_mark),a  
3584 3a 93 35			ld a, (.dmark+1)  
3587 32 a1 fd			ld (debug_mark+1),a  
358a 3a 94 35			ld a, (.dmark+2)  
358d 32 a2 fd			ld (debug_mark+2),a  
3590 18 03			jr .pastdmark  
3592 ..			.dmark: db "2A_"  
3595 f1			.pastdmark: pop af  
3596			endm  
# End of macro DMARK
3596						CALLMONITOR 
3596 cd aa fd			call debug_vector  
3599				endm  
# End of macro CALLMONITOR
3599					endif 
3599			 
3599					FORTH_DSP_VALUEHL 
3599 cd 4d 22			call macro_dsp_valuehl 
359c				endm 
# End of macro FORTH_DSP_VALUEHL
359c			 
359c e5					push hl   ; save address 
359d			 
359d					FORTH_DSP_POP 
359d cd 05 23			call macro_forth_dsp_pop 
35a0				endm 
# End of macro FORTH_DSP_POP
35a0			 
35a0 e1					pop hl 
35a1			 
35a1 5e					ld e, (hl) 
35a2 23					inc hl 
35a3 56					ld d, (hl) 
35a4			 
35a4 eb					ex de, hl 
35a5			 
35a5 cd 48 20				call forth_push_numhl 
35a8			 
35a8				       NEXTW 
35a8 c3 38 24			jp macro_next 
35ab				endm 
# End of macro NEXTW
35ab			.BANG2: 
35ab				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
35ab 6f				db WORD_SYS_CORE+91             
35ac e3 35			dw .CONFIG            
35ae 03				db 2 + 1 
35af .. 00			db "2!",0              
35b2				endm 
# End of macro CWHEAD
35b2			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
35b2					if DEBUG_FORTH_WORDS_KEY 
35b2						DMARK "2S_" 
35b2 f5				push af  
35b3 3a c7 35			ld a, (.dmark)  
35b6 32 a0 fd			ld (debug_mark),a  
35b9 3a c8 35			ld a, (.dmark+1)  
35bc 32 a1 fd			ld (debug_mark+1),a  
35bf 3a c9 35			ld a, (.dmark+2)  
35c2 32 a2 fd			ld (debug_mark+2),a  
35c5 18 03			jr .pastdmark  
35c7 ..			.dmark: db "2S_"  
35ca f1			.pastdmark: pop af  
35cb			endm  
# End of macro DMARK
35cb						CALLMONITOR 
35cb cd aa fd			call debug_vector  
35ce				endm  
# End of macro CALLMONITOR
35ce					endif 
35ce			 
35ce					FORTH_DSP_VALUEHL 
35ce cd 4d 22			call macro_dsp_valuehl 
35d1				endm 
# End of macro FORTH_DSP_VALUEHL
35d1			 
35d1 e5					push hl   ; save address 
35d2			 
35d2			 
35d2					FORTH_DSP_POP 
35d2 cd 05 23			call macro_forth_dsp_pop 
35d5				endm 
# End of macro FORTH_DSP_POP
35d5			 
35d5					 
35d5					FORTH_DSP_VALUEHL 
35d5 cd 4d 22			call macro_dsp_valuehl 
35d8				endm 
# End of macro FORTH_DSP_VALUEHL
35d8			 
35d8					FORTH_DSP_POP 
35d8 cd 05 23			call macro_forth_dsp_pop 
35db				endm 
# End of macro FORTH_DSP_POP
35db			 
35db eb					ex de, hl    ; value now in de 
35dc			 
35dc e1					pop hl 
35dd			 
35dd 73					ld (hl), e 
35de			 
35de 23					inc hl 
35df			 
35df 72					ld (hl), d 
35e0			 
35e0			 
35e0				       NEXTW 
35e0 c3 38 24			jp macro_next 
35e3				endm 
# End of macro NEXTW
35e3			.CONFIG: 
35e3				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
35e3 6f				db WORD_SYS_CORE+91             
35e4 f4 35			dw .ADTOS            
35e6 07				db 6 + 1 
35e7 .. 00			db "CONFIG",0              
35ee				endm 
# End of macro CWHEAD
35ee			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
35ee			 
35ee cd 52 15				call config 
35f1					NEXTW 
35f1 c3 38 24			jp macro_next 
35f4				endm 
# End of macro NEXTW
35f4			 
35f4			.ADTOS: 
35f4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
35f4 6f				db WORD_SYS_CORE+91             
35f5 0a 36			dw .SBTOS            
35f7 03				db 2 + 1 
35f8 .. 00			db "1+",0              
35fb				endm 
# End of macro CWHEAD
35fb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
35fb			 
35fb					FORTH_DSP_VALUEHL 
35fb cd 4d 22			call macro_dsp_valuehl 
35fe				endm 
# End of macro FORTH_DSP_VALUEHL
35fe e5					push hl 
35ff			 
35ff					FORTH_DSP_POP 
35ff cd 05 23			call macro_forth_dsp_pop 
3602				endm 
# End of macro FORTH_DSP_POP
3602 e1					pop hl 
3603			 
3603 23					inc hl 
3604 cd 48 20				call forth_push_numhl 
3607					 
3607					NEXTW 
3607 c3 38 24			jp macro_next 
360a				endm 
# End of macro NEXTW
360a			.SBTOS: 
360a				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
360a 6f				db WORD_SYS_CORE+91             
360b 20 36			dw .ADSTORE            
360d 03				db 2 + 1 
360e .. 00			db "1-",0              
3611				endm 
# End of macro CWHEAD
3611			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3611			 
3611					FORTH_DSP_VALUEHL 
3611 cd 4d 22			call macro_dsp_valuehl 
3614				endm 
# End of macro FORTH_DSP_VALUEHL
3614 e5					push hl 
3615			 
3615					FORTH_DSP_POP 
3615 cd 05 23			call macro_forth_dsp_pop 
3618				endm 
# End of macro FORTH_DSP_POP
3618 e1					pop hl 
3619			 
3619 2b					dec hl 
361a cd 48 20				call forth_push_numhl 
361d					 
361d					NEXTW 
361d c3 38 24			jp macro_next 
3620				endm 
# End of macro NEXTW
3620			.ADSTORE: 
3620				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3620 6f				db WORD_SYS_CORE+91             
3621 36 36			dw .ADWSTORE            
3623 04				db 3 + 1 
3624 .. 00			db "1+!",0              
3628				endm 
# End of macro CWHEAD
3628			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3628			 
3628					FORTH_DSP_VALUEHL 
3628 cd 4d 22			call macro_dsp_valuehl 
362b				endm 
# End of macro FORTH_DSP_VALUEHL
362b e5					push hl 
362c			 
362c					FORTH_DSP_POP 
362c cd 05 23			call macro_forth_dsp_pop 
362f				endm 
# End of macro FORTH_DSP_POP
362f e1					pop hl 
3630			 
3630 7e					ld a, (hl) 
3631 3c					inc a 
3632 77					ld (hl), a 
3633					 
3633					NEXTW 
3633 c3 38 24			jp macro_next 
3636				endm 
# End of macro NEXTW
3636			.ADWSTORE: 
3636				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3636 6f				db WORD_SYS_CORE+91             
3637 54 36			dw .SBSTORE            
3639 05				db 4 + 1 
363a .. 00			db "1+2!",0              
363f				endm 
# End of macro CWHEAD
363f			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
363f			 
363f					FORTH_DSP_VALUEHL 
363f cd 4d 22			call macro_dsp_valuehl 
3642				endm 
# End of macro FORTH_DSP_VALUEHL
3642 e5					push hl 
3643			 
3643					FORTH_DSP_POP 
3643 cd 05 23			call macro_forth_dsp_pop 
3646				endm 
# End of macro FORTH_DSP_POP
3646 e1					pop hl 
3647			 
3647 e5					push hl 
3648			 
3648 cd ba 23				call loadwordinhl 
364b 23					inc hl 
364c			 
364c d1					pop de 
364d eb					ex de, hl 
364e 73					ld (hl), e 
364f 23					inc hl 
3650 72					ld (hl), d 
3651					 
3651					NEXTW 
3651 c3 38 24			jp macro_next 
3654				endm 
# End of macro NEXTW
3654			.SBSTORE: 
3654				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3654 6f				db WORD_SYS_CORE+91             
3655 6a 36			dw .SBWSTORE            
3657 04				db 3 + 1 
3658 .. 00			db "1-!",0              
365c				endm 
# End of macro CWHEAD
365c			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
365c			 
365c					FORTH_DSP_VALUEHL 
365c cd 4d 22			call macro_dsp_valuehl 
365f				endm 
# End of macro FORTH_DSP_VALUEHL
365f e5					push hl 
3660			 
3660					FORTH_DSP_POP 
3660 cd 05 23			call macro_forth_dsp_pop 
3663				endm 
# End of macro FORTH_DSP_POP
3663 e1					pop hl 
3664			 
3664 7e					ld a, (hl) 
3665 3d					dec a 
3666 77					ld (hl), a 
3667					 
3667					NEXTW 
3667 c3 38 24			jp macro_next 
366a				endm 
# End of macro NEXTW
366a			.SBWSTORE: 
366a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
366a 6f				db WORD_SYS_CORE+91             
366b 88 36			dw .ENDCORE            
366d 05				db 4 + 1 
366e .. 00			db "1-2!",0              
3673				endm 
# End of macro CWHEAD
3673			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3673			 
3673					FORTH_DSP_VALUEHL 
3673 cd 4d 22			call macro_dsp_valuehl 
3676				endm 
# End of macro FORTH_DSP_VALUEHL
3676 e5					push hl 
3677			 
3677					FORTH_DSP_POP 
3677 cd 05 23			call macro_forth_dsp_pop 
367a				endm 
# End of macro FORTH_DSP_POP
367a e1					pop hl 
367b			 
367b e5					push hl 
367c			 
367c cd ba 23				call loadwordinhl 
367f 2b					dec hl 
3680			 
3680 d1					pop de 
3681 eb					ex de, hl 
3682 73					ld (hl), e 
3683 23					inc hl 
3684 72					ld (hl), d 
3685					 
3685					NEXTW 
3685 c3 38 24			jp macro_next 
3688				endm 
# End of macro NEXTW
3688			.ENDCORE: 
3688			 
3688			; eof 
3688			 
3688			 
# End of file forth_words_core.asm
3688			include "forth_words_flow.asm" 
3688			 
3688			; | ## Program Flow Words 
3688			 
3688			.IF: 
3688				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3688 1e				db WORD_SYS_CORE+10             
3689 7d 37			dw .THEN            
368b 03				db 2 + 1 
368c .. 00			db "IF",0              
368f				endm 
# End of macro CWHEAD
368f			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
368f			; | | Note: currently not supporting ELSE or nested IF 
368f			; 
368f					if DEBUG_FORTH_WORDS_KEY 
368f						DMARK "IF." 
368f f5				push af  
3690 3a a4 36			ld a, (.dmark)  
3693 32 a0 fd			ld (debug_mark),a  
3696 3a a5 36			ld a, (.dmark+1)  
3699 32 a1 fd			ld (debug_mark+1),a  
369c 3a a6 36			ld a, (.dmark+2)  
369f 32 a2 fd			ld (debug_mark+2),a  
36a2 18 03			jr .pastdmark  
36a4 ..			.dmark: db "IF."  
36a7 f1			.pastdmark: pop af  
36a8			endm  
# End of macro DMARK
36a8						CALLMONITOR 
36a8 cd aa fd			call debug_vector  
36ab				endm  
# End of macro CALLMONITOR
36ab					endif 
36ab			; eval TOS 
36ab			 
36ab				FORTH_DSP_VALUEHL 
36ab cd 4d 22			call macro_dsp_valuehl 
36ae				endm 
# End of macro FORTH_DSP_VALUEHL
36ae			 
36ae			;	push hl 
36ae				FORTH_DSP_POP 
36ae cd 05 23			call macro_forth_dsp_pop 
36b1				endm 
# End of macro FORTH_DSP_POP
36b1			;	pop hl 
36b1			 
36b1					if DEBUG_FORTH_WORDS 
36b1						DMARK "IF1" 
36b1 f5				push af  
36b2 3a c6 36			ld a, (.dmark)  
36b5 32 a0 fd			ld (debug_mark),a  
36b8 3a c7 36			ld a, (.dmark+1)  
36bb 32 a1 fd			ld (debug_mark+1),a  
36be 3a c8 36			ld a, (.dmark+2)  
36c1 32 a2 fd			ld (debug_mark+2),a  
36c4 18 03			jr .pastdmark  
36c6 ..			.dmark: db "IF1"  
36c9 f1			.pastdmark: pop af  
36ca			endm  
# End of macro DMARK
36ca						CALLMONITOR 
36ca cd aa fd			call debug_vector  
36cd				endm  
# End of macro CALLMONITOR
36cd					endif 
36cd b7				or a        ; clear carry flag 
36ce 11 00 00			ld de, 0 
36d1 eb				ex de,hl 
36d2 ed 52			sbc hl, de 
36d4 c2 5e 37			jp nz, .iftrue 
36d7			 
36d7					if DEBUG_FORTH_WORDS 
36d7						DMARK "IF2" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 a0 fd			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 a1 fd			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 a2 fd			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "IF2"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd aa fd			call debug_vector  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3			 
36f3			; if not true then skip to THEN 
36f3			 
36f3				; TODO get tok_ptr 
36f3				; TODO consume toks until we get to THEN 
36f3			 
36f3 2a f7 f3			ld hl, (os_tok_ptr) 
36f6					if DEBUG_FORTH_WORDS 
36f6						DMARK "IF3" 
36f6 f5				push af  
36f7 3a 0b 37			ld a, (.dmark)  
36fa 32 a0 fd			ld (debug_mark),a  
36fd 3a 0c 37			ld a, (.dmark+1)  
3700 32 a1 fd			ld (debug_mark+1),a  
3703 3a 0d 37			ld a, (.dmark+2)  
3706 32 a2 fd			ld (debug_mark+2),a  
3709 18 03			jr .pastdmark  
370b ..			.dmark: db "IF3"  
370e f1			.pastdmark: pop af  
370f			endm  
# End of macro DMARK
370f						CALLMONITOR 
370f cd aa fd			call debug_vector  
3712				endm  
# End of macro CALLMONITOR
3712						 
3712					endif 
3712 11 59 37			ld de, .ifthen 
3715					if DEBUG_FORTH_WORDS 
3715						DMARK "IF4" 
3715 f5				push af  
3716 3a 2a 37			ld a, (.dmark)  
3719 32 a0 fd			ld (debug_mark),a  
371c 3a 2b 37			ld a, (.dmark+1)  
371f 32 a1 fd			ld (debug_mark+1),a  
3722 3a 2c 37			ld a, (.dmark+2)  
3725 32 a2 fd			ld (debug_mark+2),a  
3728 18 03			jr .pastdmark  
372a ..			.dmark: db "IF4"  
372d f1			.pastdmark: pop af  
372e			endm  
# End of macro DMARK
372e						CALLMONITOR 
372e cd aa fd			call debug_vector  
3731				endm  
# End of macro CALLMONITOR
3731					endif 
3731 cd 3f 25			call findnexttok  
3734			 
3734					if DEBUG_FORTH_WORDS 
3734						DMARK "IF5" 
3734 f5				push af  
3735 3a 49 37			ld a, (.dmark)  
3738 32 a0 fd			ld (debug_mark),a  
373b 3a 4a 37			ld a, (.dmark+1)  
373e 32 a1 fd			ld (debug_mark+1),a  
3741 3a 4b 37			ld a, (.dmark+2)  
3744 32 a2 fd			ld (debug_mark+2),a  
3747 18 03			jr .pastdmark  
3749 ..			.dmark: db "IF5"  
374c f1			.pastdmark: pop af  
374d			endm  
# End of macro DMARK
374d						CALLMONITOR 
374d cd aa fd			call debug_vector  
3750				endm  
# End of macro CALLMONITOR
3750					endif 
3750				; TODO replace below with ; exec using tok_ptr 
3750 22 f7 f3			ld (os_tok_ptr), hl 
3753 c3 c1 24			jp exec1 
3756				NEXTW 
3756 c3 38 24			jp macro_next 
3759				endm 
# End of macro NEXTW
3759			 
3759 .. 00		.ifthen:  db "THEN",0 
375e			 
375e			.iftrue:		 
375e				; Exec next words normally 
375e			 
375e				; if true then exec following IF as normal 
375e					if DEBUG_FORTH_WORDS 
375e						DMARK "IFT" 
375e f5				push af  
375f 3a 73 37			ld a, (.dmark)  
3762 32 a0 fd			ld (debug_mark),a  
3765 3a 74 37			ld a, (.dmark+1)  
3768 32 a1 fd			ld (debug_mark+1),a  
376b 3a 75 37			ld a, (.dmark+2)  
376e 32 a2 fd			ld (debug_mark+2),a  
3771 18 03			jr .pastdmark  
3773 ..			.dmark: db "IFT"  
3776 f1			.pastdmark: pop af  
3777			endm  
# End of macro DMARK
3777						CALLMONITOR 
3777 cd aa fd			call debug_vector  
377a				endm  
# End of macro CALLMONITOR
377a					endif 
377a			 
377a					NEXTW 
377a c3 38 24			jp macro_next 
377d				endm 
# End of macro NEXTW
377d			.THEN: 
377d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
377d 1f				db WORD_SYS_CORE+11             
377e a5 37			dw .ELSE            
3780 05				db 4 + 1 
3781 .. 00			db "THEN",0              
3786				endm 
# End of macro CWHEAD
3786			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3786					if DEBUG_FORTH_WORDS_KEY 
3786						DMARK "THN" 
3786 f5				push af  
3787 3a 9b 37			ld a, (.dmark)  
378a 32 a0 fd			ld (debug_mark),a  
378d 3a 9c 37			ld a, (.dmark+1)  
3790 32 a1 fd			ld (debug_mark+1),a  
3793 3a 9d 37			ld a, (.dmark+2)  
3796 32 a2 fd			ld (debug_mark+2),a  
3799 18 03			jr .pastdmark  
379b ..			.dmark: db "THN"  
379e f1			.pastdmark: pop af  
379f			endm  
# End of macro DMARK
379f						CALLMONITOR 
379f cd aa fd			call debug_vector  
37a2				endm  
# End of macro CALLMONITOR
37a2					endif 
37a2					NEXTW 
37a2 c3 38 24			jp macro_next 
37a5				endm 
# End of macro NEXTW
37a5			.ELSE: 
37a5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
37a5 20				db WORD_SYS_CORE+12             
37a6 cd 37			dw .DO            
37a8 03				db 2 + 1 
37a9 .. 00			db "ELSE",0              
37ae				endm 
# End of macro CWHEAD
37ae			; | ELSE ( -- ) Not supported - does nothing | TODO 
37ae			 
37ae					if DEBUG_FORTH_WORDS_KEY 
37ae						DMARK "ELS" 
37ae f5				push af  
37af 3a c3 37			ld a, (.dmark)  
37b2 32 a0 fd			ld (debug_mark),a  
37b5 3a c4 37			ld a, (.dmark+1)  
37b8 32 a1 fd			ld (debug_mark+1),a  
37bb 3a c5 37			ld a, (.dmark+2)  
37be 32 a2 fd			ld (debug_mark+2),a  
37c1 18 03			jr .pastdmark  
37c3 ..			.dmark: db "ELS"  
37c6 f1			.pastdmark: pop af  
37c7			endm  
# End of macro DMARK
37c7						CALLMONITOR 
37c7 cd aa fd			call debug_vector  
37ca				endm  
# End of macro CALLMONITOR
37ca					endif 
37ca			 
37ca			 
37ca					NEXTW 
37ca c3 38 24			jp macro_next 
37cd				endm 
# End of macro NEXTW
37cd			.DO: 
37cd				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
37cd 21				db WORD_SYS_CORE+13             
37ce f4 38			dw .LOOP            
37d0 03				db 2 + 1 
37d1 .. 00			db "DO",0              
37d4				endm 
# End of macro CWHEAD
37d4			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
37d4			 
37d4					if DEBUG_FORTH_WORDS_KEY 
37d4						DMARK "DO." 
37d4 f5				push af  
37d5 3a e9 37			ld a, (.dmark)  
37d8 32 a0 fd			ld (debug_mark),a  
37db 3a ea 37			ld a, (.dmark+1)  
37de 32 a1 fd			ld (debug_mark+1),a  
37e1 3a eb 37			ld a, (.dmark+2)  
37e4 32 a2 fd			ld (debug_mark+2),a  
37e7 18 03			jr .pastdmark  
37e9 ..			.dmark: db "DO."  
37ec f1			.pastdmark: pop af  
37ed			endm  
# End of macro DMARK
37ed						CALLMONITOR 
37ed cd aa fd			call debug_vector  
37f0				endm  
# End of macro CALLMONITOR
37f0					endif 
37f0			;  push pc to rsp stack past the DO 
37f0			 
37f0 2a f7 f3				ld hl, (os_tok_ptr) 
37f3 23					inc hl   ; D 
37f4 23					inc hl  ; O 
37f5 23					inc hl   ; null 
37f6					if DEBUG_FORTH_WORDS 
37f6						DMARK "DO2" 
37f6 f5				push af  
37f7 3a 0b 38			ld a, (.dmark)  
37fa 32 a0 fd			ld (debug_mark),a  
37fd 3a 0c 38			ld a, (.dmark+1)  
3800 32 a1 fd			ld (debug_mark+1),a  
3803 3a 0d 38			ld a, (.dmark+2)  
3806 32 a2 fd			ld (debug_mark+2),a  
3809 18 03			jr .pastdmark  
380b ..			.dmark: db "DO2"  
380e f1			.pastdmark: pop af  
380f			endm  
# End of macro DMARK
380f						CALLMONITOR 
380f cd aa fd			call debug_vector  
3812				endm  
# End of macro CALLMONITOR
3812					endif 
3812					FORTH_RSP_NEXT 
3812 cd ef 1f			call macro_forth_rsp_next 
3815				endm 
# End of macro FORTH_RSP_NEXT
3815					if DEBUG_FORTH_WORDS 
3815						DMARK "DO3" 
3815 f5				push af  
3816 3a 2a 38			ld a, (.dmark)  
3819 32 a0 fd			ld (debug_mark),a  
381c 3a 2b 38			ld a, (.dmark+1)  
381f 32 a1 fd			ld (debug_mark+1),a  
3822 3a 2c 38			ld a, (.dmark+2)  
3825 32 a2 fd			ld (debug_mark+2),a  
3828 18 03			jr .pastdmark  
382a ..			.dmark: db "DO3"  
382d f1			.pastdmark: pop af  
382e			endm  
# End of macro DMARK
382e						CALLMONITOR 
382e cd aa fd			call debug_vector  
3831				endm  
# End of macro CALLMONITOR
3831					endif 
3831			 
3831					;if DEBUG_FORTH_WORDS 
3831				;		push hl 
3831			;		endif  
3831			 
3831			; get counters from data stack 
3831			 
3831			 
3831					FORTH_DSP_VALUEHL 
3831 cd 4d 22			call macro_dsp_valuehl 
3834				endm 
# End of macro FORTH_DSP_VALUEHL
3834 e5					push hl		 ; hl now has starting counter which needs to be tos 
3835			 
3835					if DEBUG_FORTH_WORDS 
3835						DMARK "DO4" 
3835 f5				push af  
3836 3a 4a 38			ld a, (.dmark)  
3839 32 a0 fd			ld (debug_mark),a  
383c 3a 4b 38			ld a, (.dmark+1)  
383f 32 a1 fd			ld (debug_mark+1),a  
3842 3a 4c 38			ld a, (.dmark+2)  
3845 32 a2 fd			ld (debug_mark+2),a  
3848 18 03			jr .pastdmark  
384a ..			.dmark: db "DO4"  
384d f1			.pastdmark: pop af  
384e			endm  
# End of macro DMARK
384e						CALLMONITOR 
384e cd aa fd			call debug_vector  
3851				endm  
# End of macro CALLMONITOR
3851					endif 
3851					FORTH_DSP_POP 
3851 cd 05 23			call macro_forth_dsp_pop 
3854				endm 
# End of macro FORTH_DSP_POP
3854			 
3854					if DEBUG_FORTH_WORDS 
3854						DMARK "DO5" 
3854 f5				push af  
3855 3a 69 38			ld a, (.dmark)  
3858 32 a0 fd			ld (debug_mark),a  
385b 3a 6a 38			ld a, (.dmark+1)  
385e 32 a1 fd			ld (debug_mark+1),a  
3861 3a 6b 38			ld a, (.dmark+2)  
3864 32 a2 fd			ld (debug_mark+2),a  
3867 18 03			jr .pastdmark  
3869 ..			.dmark: db "DO5"  
386c f1			.pastdmark: pop af  
386d			endm  
# End of macro DMARK
386d						CALLMONITOR 
386d cd aa fd			call debug_vector  
3870				endm  
# End of macro CALLMONITOR
3870					endif 
3870			 
3870					FORTH_DSP_VALUEHL 
3870 cd 4d 22			call macro_dsp_valuehl 
3873				endm 
# End of macro FORTH_DSP_VALUEHL
3873			;		push hl		 ; hl now has starting limit counter 
3873			 
3873					if DEBUG_FORTH_WORDS 
3873						DMARK "DO6" 
3873 f5				push af  
3874 3a 88 38			ld a, (.dmark)  
3877 32 a0 fd			ld (debug_mark),a  
387a 3a 89 38			ld a, (.dmark+1)  
387d 32 a1 fd			ld (debug_mark+1),a  
3880 3a 8a 38			ld a, (.dmark+2)  
3883 32 a2 fd			ld (debug_mark+2),a  
3886 18 03			jr .pastdmark  
3888 ..			.dmark: db "DO6"  
388b f1			.pastdmark: pop af  
388c			endm  
# End of macro DMARK
388c						CALLMONITOR 
388c cd aa fd			call debug_vector  
388f				endm  
# End of macro CALLMONITOR
388f					endif 
388f					FORTH_DSP_POP 
388f cd 05 23			call macro_forth_dsp_pop 
3892				endm 
# End of macro FORTH_DSP_POP
3892			 
3892			; put counters on the loop stack 
3892			 
3892			;		pop hl			 ; limit counter 
3892 d1					pop de			; start counter 
3893			 
3893					; push limit counter 
3893			 
3893					if DEBUG_FORTH_WORDS 
3893						DMARK "DO7" 
3893 f5				push af  
3894 3a a8 38			ld a, (.dmark)  
3897 32 a0 fd			ld (debug_mark),a  
389a 3a a9 38			ld a, (.dmark+1)  
389d 32 a1 fd			ld (debug_mark+1),a  
38a0 3a aa 38			ld a, (.dmark+2)  
38a3 32 a2 fd			ld (debug_mark+2),a  
38a6 18 03			jr .pastdmark  
38a8 ..			.dmark: db "DO7"  
38ab f1			.pastdmark: pop af  
38ac			endm  
# End of macro DMARK
38ac						CALLMONITOR 
38ac cd aa fd			call debug_vector  
38af				endm  
# End of macro CALLMONITOR
38af					endif 
38af					FORTH_LOOP_NEXT 
38af cd 7e 22			call macro_forth_loop_next 
38b2				endm 
# End of macro FORTH_LOOP_NEXT
38b2			 
38b2					; push start counter 
38b2			 
38b2 eb					ex de, hl 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "DO7" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 a0 fd			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 a1 fd			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 a2 fd			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "DO7"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd aa fd			call debug_vector  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf					FORTH_LOOP_NEXT 
38cf cd 7e 22			call macro_forth_loop_next 
38d2				endm 
# End of macro FORTH_LOOP_NEXT
38d2			 
38d2			 
38d2					; init first round of I counter 
38d2			 
38d2 22 1b f4				ld (os_current_i), hl 
38d5			 
38d5					if DEBUG_FORTH_WORDS 
38d5						DMARK "DO8" 
38d5 f5				push af  
38d6 3a ea 38			ld a, (.dmark)  
38d9 32 a0 fd			ld (debug_mark),a  
38dc 3a eb 38			ld a, (.dmark+1)  
38df 32 a1 fd			ld (debug_mark+1),a  
38e2 3a ec 38			ld a, (.dmark+2)  
38e5 32 a2 fd			ld (debug_mark+2),a  
38e8 18 03			jr .pastdmark  
38ea ..			.dmark: db "DO8"  
38ed f1			.pastdmark: pop af  
38ee			endm  
# End of macro DMARK
38ee						CALLMONITOR 
38ee cd aa fd			call debug_vector  
38f1				endm  
# End of macro CALLMONITOR
38f1					endif 
38f1			 
38f1					NEXTW 
38f1 c3 38 24			jp macro_next 
38f4				endm 
# End of macro NEXTW
38f4			.LOOP: 
38f4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
38f4 22				db WORD_SYS_CORE+14             
38f5 0c 3a			dw .I            
38f7 05				db 4 + 1 
38f8 .. 00			db "LOOP",0              
38fd				endm 
# End of macro CWHEAD
38fd			; | LOOP ( -- ) Increment and test loop counter  | DONE 
38fd			 
38fd				; pop tos as current loop count to hl 
38fd			 
38fd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38fd			 
38fd				FORTH_LOOP_TOS 
38fd cd b1 22			call macro_forth_loop_tos 
3900				endm 
# End of macro FORTH_LOOP_TOS
3900 e5				push hl 
3901			 
3901					if DEBUG_FORTH_WORDS_KEY 
3901						DMARK "LOP" 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 a0 fd			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 a1 fd			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 a2 fd			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "LOP"  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a						CALLMONITOR 
391a cd aa fd			call debug_vector  
391d				endm  
# End of macro CALLMONITOR
391d					endif 
391d				; next item on the stack is the limit. get it 
391d			 
391d			 
391d				FORTH_LOOP_POP 
391d cd bb 22			call macro_forth_loop_pop 
3920				endm 
# End of macro FORTH_LOOP_POP
3920			 
3920				FORTH_LOOP_TOS 
3920 cd b1 22			call macro_forth_loop_tos 
3923				endm 
# End of macro FORTH_LOOP_TOS
3923			 
3923 d1				pop de		 ; de = i, hl = limit 
3924			 
3924					if DEBUG_FORTH_WORDS 
3924						DMARK "LP1" 
3924 f5				push af  
3925 3a 39 39			ld a, (.dmark)  
3928 32 a0 fd			ld (debug_mark),a  
392b 3a 3a 39			ld a, (.dmark+1)  
392e 32 a1 fd			ld (debug_mark+1),a  
3931 3a 3b 39			ld a, (.dmark+2)  
3934 32 a2 fd			ld (debug_mark+2),a  
3937 18 03			jr .pastdmark  
3939 ..			.dmark: db "LP1"  
393c f1			.pastdmark: pop af  
393d			endm  
# End of macro DMARK
393d						CALLMONITOR 
393d cd aa fd			call debug_vector  
3940				endm  
# End of macro CALLMONITOR
3940					endif 
3940			 
3940				; go back to previous word 
3940			 
3940 d5				push de    ; save I for inc later 
3941			 
3941			 
3941				; get limit 
3941				;  is I at limit? 
3941			 
3941			 
3941					if DEBUG_FORTH_WORDS 
3941						DMARK "LP1" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 a0 fd			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 a1 fd			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 a2 fd			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "LP1"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd aa fd			call debug_vector  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d			 
395d ed 52			sbc hl, de 
395f			 
395f			 
395f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
395f			 
395f 20 26				jr nz, .loopnotdone 
3961			 
3961 e1				pop hl   ; get rid of saved I 
3962				FORTH_LOOP_POP     ; get rid of limit 
3962 cd bb 22			call macro_forth_loop_pop 
3965				endm 
# End of macro FORTH_LOOP_POP
3965			 
3965				FORTH_RSP_POP     ; get rid of DO ptr 
3965 cd 10 20			call macro_forth_rsp_pop 
3968				endm 
# End of macro FORTH_RSP_POP
3968			 
3968			if DEBUG_FORTH_WORDS 
3968						DMARK "LP>" 
3968 f5				push af  
3969 3a 7d 39			ld a, (.dmark)  
396c 32 a0 fd			ld (debug_mark),a  
396f 3a 7e 39			ld a, (.dmark+1)  
3972 32 a1 fd			ld (debug_mark+1),a  
3975 3a 7f 39			ld a, (.dmark+2)  
3978 32 a2 fd			ld (debug_mark+2),a  
397b 18 03			jr .pastdmark  
397d ..			.dmark: db "LP>"  
3980 f1			.pastdmark: pop af  
3981			endm  
# End of macro DMARK
3981				CALLMONITOR 
3981 cd aa fd			call debug_vector  
3984				endm  
# End of macro CALLMONITOR
3984			endif 
3984			 
3984					NEXTW 
3984 c3 38 24			jp macro_next 
3987				endm 
# End of macro NEXTW
3987				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3987			 
3987			.loopnotdone: 
3987			 
3987 e1				pop hl    ; get I 
3988 23				inc hl 
3989			 
3989			   	; save new I 
3989			 
3989			 
3989					; set I counter 
3989			 
3989 22 1b f4				ld (os_current_i), hl 
398c			 
398c					if DEBUG_FORTH_WORDS 
398c						DMARK "LPN" 
398c f5				push af  
398d 3a a1 39			ld a, (.dmark)  
3990 32 a0 fd			ld (debug_mark),a  
3993 3a a2 39			ld a, (.dmark+1)  
3996 32 a1 fd			ld (debug_mark+1),a  
3999 3a a3 39			ld a, (.dmark+2)  
399c 32 a2 fd			ld (debug_mark+2),a  
399f 18 03			jr .pastdmark  
39a1 ..			.dmark: db "LPN"  
39a4 f1			.pastdmark: pop af  
39a5			endm  
# End of macro DMARK
39a5					CALLMONITOR 
39a5 cd aa fd			call debug_vector  
39a8				endm  
# End of macro CALLMONITOR
39a8					endif 
39a8					 
39a8				FORTH_LOOP_NEXT 
39a8 cd 7e 22			call macro_forth_loop_next 
39ab				endm 
# End of macro FORTH_LOOP_NEXT
39ab			 
39ab			 
39ab					if DEBUG_FORTH_WORDS 
39ab eb						ex de,hl 
39ac					endif 
39ac			 
39ac			;	; get DO ptr 
39ac			; 
39ac					if DEBUG_FORTH_WORDS 
39ac						DMARK "LP7" 
39ac f5				push af  
39ad 3a c1 39			ld a, (.dmark)  
39b0 32 a0 fd			ld (debug_mark),a  
39b3 3a c2 39			ld a, (.dmark+1)  
39b6 32 a1 fd			ld (debug_mark+1),a  
39b9 3a c3 39			ld a, (.dmark+2)  
39bc 32 a2 fd			ld (debug_mark+2),a  
39bf 18 03			jr .pastdmark  
39c1 ..			.dmark: db "LP7"  
39c4 f1			.pastdmark: pop af  
39c5			endm  
# End of macro DMARK
39c5					CALLMONITOR 
39c5 cd aa fd			call debug_vector  
39c8				endm  
# End of macro CALLMONITOR
39c8					endif 
39c8				FORTH_RSP_TOS 
39c8 cd 06 20			call macro_forth_rsp_tos 
39cb				endm 
# End of macro FORTH_RSP_TOS
39cb			 
39cb					if DEBUG_FORTH_WORDS 
39cb						DMARK "LP8" 
39cb f5				push af  
39cc 3a e0 39			ld a, (.dmark)  
39cf 32 a0 fd			ld (debug_mark),a  
39d2 3a e1 39			ld a, (.dmark+1)  
39d5 32 a1 fd			ld (debug_mark+1),a  
39d8 3a e2 39			ld a, (.dmark+2)  
39db 32 a2 fd			ld (debug_mark+2),a  
39de 18 03			jr .pastdmark  
39e0 ..			.dmark: db "LP8"  
39e3 f1			.pastdmark: pop af  
39e4			endm  
# End of macro DMARK
39e4					CALLMONITOR 
39e4 cd aa fd			call debug_vector  
39e7				endm  
# End of macro CALLMONITOR
39e7					endif 
39e7				;push hl 
39e7			 
39e7				; not going to DO any more 
39e7				; get rid of the RSP pointer as DO will add it back in 
39e7				;FORTH_RSP_POP 
39e7				;pop hl 
39e7			 
39e7				;ld hl,(cli_ret_sp) 
39e7				;ld e, (hl) 
39e7				;inc hl 
39e7				;ld d, (hl) 
39e7				;ex de,hl 
39e7 22 f7 f3			ld (os_tok_ptr), hl 
39ea					if DEBUG_FORTH_WORDS 
39ea						DMARK "LP<" 
39ea f5				push af  
39eb 3a ff 39			ld a, (.dmark)  
39ee 32 a0 fd			ld (debug_mark),a  
39f1 3a 00 3a			ld a, (.dmark+1)  
39f4 32 a1 fd			ld (debug_mark+1),a  
39f7 3a 01 3a			ld a, (.dmark+2)  
39fa 32 a2 fd			ld (debug_mark+2),a  
39fd 18 03			jr .pastdmark  
39ff ..			.dmark: db "LP<"  
3a02 f1			.pastdmark: pop af  
3a03			endm  
# End of macro DMARK
3a03					CALLMONITOR 
3a03 cd aa fd			call debug_vector  
3a06				endm  
# End of macro CALLMONITOR
3a06				endif 
3a06 c3 c1 24			jp exec1 
3a09			 
3a09					 
3a09			 
3a09			 
3a09					NEXTW 
3a09 c3 38 24			jp macro_next 
3a0c				endm 
# End of macro NEXTW
3a0c			.I:  
3a0c			 
3a0c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3a0c 5e				db WORD_SYS_CORE+74             
3a0d 37 3a			dw .DLOOP            
3a0f 02				db 1 + 1 
3a10 .. 00			db "I",0              
3a12				endm 
# End of macro CWHEAD
3a12			; | I ( -- ) Current loop counter | DONE 
3a12					if DEBUG_FORTH_WORDS_KEY 
3a12						DMARK "I.." 
3a12 f5				push af  
3a13 3a 27 3a			ld a, (.dmark)  
3a16 32 a0 fd			ld (debug_mark),a  
3a19 3a 28 3a			ld a, (.dmark+1)  
3a1c 32 a1 fd			ld (debug_mark+1),a  
3a1f 3a 29 3a			ld a, (.dmark+2)  
3a22 32 a2 fd			ld (debug_mark+2),a  
3a25 18 03			jr .pastdmark  
3a27 ..			.dmark: db "I.."  
3a2a f1			.pastdmark: pop af  
3a2b			endm  
# End of macro DMARK
3a2b						CALLMONITOR 
3a2b cd aa fd			call debug_vector  
3a2e				endm  
# End of macro CALLMONITOR
3a2e					endif 
3a2e			 
3a2e 2a 1b f4				ld hl,(os_current_i) 
3a31 cd 48 20				call forth_push_numhl 
3a34			 
3a34					NEXTW 
3a34 c3 38 24			jp macro_next 
3a37				endm 
# End of macro NEXTW
3a37			.DLOOP: 
3a37				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3a37 5f				db WORD_SYS_CORE+75             
3a38 18 3b			dw .REPEAT            
3a3a 06				db 5 + 1 
3a3b .. 00			db "-LOOP",0              
3a41				endm 
# End of macro CWHEAD
3a41			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3a41				; pop tos as current loop count to hl 
3a41					if DEBUG_FORTH_WORDS_KEY 
3a41						DMARK "-LP" 
3a41 f5				push af  
3a42 3a 56 3a			ld a, (.dmark)  
3a45 32 a0 fd			ld (debug_mark),a  
3a48 3a 57 3a			ld a, (.dmark+1)  
3a4b 32 a1 fd			ld (debug_mark+1),a  
3a4e 3a 58 3a			ld a, (.dmark+2)  
3a51 32 a2 fd			ld (debug_mark+2),a  
3a54 18 03			jr .pastdmark  
3a56 ..			.dmark: db "-LP"  
3a59 f1			.pastdmark: pop af  
3a5a			endm  
# End of macro DMARK
3a5a						CALLMONITOR 
3a5a cd aa fd			call debug_vector  
3a5d				endm  
# End of macro CALLMONITOR
3a5d					endif 
3a5d			 
3a5d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a5d			 
3a5d				FORTH_LOOP_TOS 
3a5d cd b1 22			call macro_forth_loop_tos 
3a60				endm 
# End of macro FORTH_LOOP_TOS
3a60 e5				push hl 
3a61			 
3a61					if DEBUG_FORTH_WORDS 
3a61						DMARK "-LP" 
3a61 f5				push af  
3a62 3a 76 3a			ld a, (.dmark)  
3a65 32 a0 fd			ld (debug_mark),a  
3a68 3a 77 3a			ld a, (.dmark+1)  
3a6b 32 a1 fd			ld (debug_mark+1),a  
3a6e 3a 78 3a			ld a, (.dmark+2)  
3a71 32 a2 fd			ld (debug_mark+2),a  
3a74 18 03			jr .pastdmark  
3a76 ..			.dmark: db "-LP"  
3a79 f1			.pastdmark: pop af  
3a7a			endm  
# End of macro DMARK
3a7a						CALLMONITOR 
3a7a cd aa fd			call debug_vector  
3a7d				endm  
# End of macro CALLMONITOR
3a7d					endif 
3a7d				; next item on the stack is the limit. get it 
3a7d			 
3a7d			 
3a7d				FORTH_LOOP_POP 
3a7d cd bb 22			call macro_forth_loop_pop 
3a80				endm 
# End of macro FORTH_LOOP_POP
3a80			 
3a80				FORTH_LOOP_TOS 
3a80 cd b1 22			call macro_forth_loop_tos 
3a83				endm 
# End of macro FORTH_LOOP_TOS
3a83			 
3a83 d1				pop de		 ; de = i, hl = limit 
3a84			 
3a84					if DEBUG_FORTH_WORDS 
3a84						DMARK "-L1" 
3a84 f5				push af  
3a85 3a 99 3a			ld a, (.dmark)  
3a88 32 a0 fd			ld (debug_mark),a  
3a8b 3a 9a 3a			ld a, (.dmark+1)  
3a8e 32 a1 fd			ld (debug_mark+1),a  
3a91 3a 9b 3a			ld a, (.dmark+2)  
3a94 32 a2 fd			ld (debug_mark+2),a  
3a97 18 03			jr .pastdmark  
3a99 ..			.dmark: db "-L1"  
3a9c f1			.pastdmark: pop af  
3a9d			endm  
# End of macro DMARK
3a9d						CALLMONITOR 
3a9d cd aa fd			call debug_vector  
3aa0				endm  
# End of macro CALLMONITOR
3aa0					endif 
3aa0			 
3aa0				; go back to previous word 
3aa0			 
3aa0 d5				push de    ; save I for inc later 
3aa1			 
3aa1			 
3aa1				; get limit 
3aa1				;  is I at limit? 
3aa1			 
3aa1			 
3aa1					if DEBUG_FORTH_WORDS 
3aa1						DMARK "-L1" 
3aa1 f5				push af  
3aa2 3a b6 3a			ld a, (.dmark)  
3aa5 32 a0 fd			ld (debug_mark),a  
3aa8 3a b7 3a			ld a, (.dmark+1)  
3aab 32 a1 fd			ld (debug_mark+1),a  
3aae 3a b8 3a			ld a, (.dmark+2)  
3ab1 32 a2 fd			ld (debug_mark+2),a  
3ab4 18 03			jr .pastdmark  
3ab6 ..			.dmark: db "-L1"  
3ab9 f1			.pastdmark: pop af  
3aba			endm  
# End of macro DMARK
3aba						CALLMONITOR 
3aba cd aa fd			call debug_vector  
3abd				endm  
# End of macro CALLMONITOR
3abd					endif 
3abd			 
3abd ed 52			sbc hl, de 
3abf			 
3abf			 
3abf				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3abf			 
3abf 20 26				jr nz, .mloopnotdone 
3ac1			 
3ac1 e1				pop hl   ; get rid of saved I 
3ac2				FORTH_LOOP_POP     ; get rid of limit 
3ac2 cd bb 22			call macro_forth_loop_pop 
3ac5				endm 
# End of macro FORTH_LOOP_POP
3ac5			 
3ac5				FORTH_RSP_POP     ; get rid of DO ptr 
3ac5 cd 10 20			call macro_forth_rsp_pop 
3ac8				endm 
# End of macro FORTH_RSP_POP
3ac8			 
3ac8			if DEBUG_FORTH_WORDS 
3ac8						DMARK "-L>" 
3ac8 f5				push af  
3ac9 3a dd 3a			ld a, (.dmark)  
3acc 32 a0 fd			ld (debug_mark),a  
3acf 3a de 3a			ld a, (.dmark+1)  
3ad2 32 a1 fd			ld (debug_mark+1),a  
3ad5 3a df 3a			ld a, (.dmark+2)  
3ad8 32 a2 fd			ld (debug_mark+2),a  
3adb 18 03			jr .pastdmark  
3add ..			.dmark: db "-L>"  
3ae0 f1			.pastdmark: pop af  
3ae1			endm  
# End of macro DMARK
3ae1				CALLMONITOR 
3ae1 cd aa fd			call debug_vector  
3ae4				endm  
# End of macro CALLMONITOR
3ae4			endif 
3ae4			 
3ae4					NEXTW 
3ae4 c3 38 24			jp macro_next 
3ae7				endm 
# End of macro NEXTW
3ae7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3ae7			 
3ae7			.mloopnotdone: 
3ae7			 
3ae7 e1				pop hl    ; get I 
3ae8 2b				dec hl 
3ae9			 
3ae9			   	; save new I 
3ae9			 
3ae9			 
3ae9					; set I counter 
3ae9			 
3ae9 22 1b f4				ld (os_current_i), hl 
3aec			 
3aec					 
3aec				FORTH_LOOP_NEXT 
3aec cd 7e 22			call macro_forth_loop_next 
3aef				endm 
# End of macro FORTH_LOOP_NEXT
3aef			 
3aef			 
3aef					if DEBUG_FORTH_WORDS 
3aef eb						ex de,hl 
3af0					endif 
3af0			 
3af0			;	; get DO ptr 
3af0			; 
3af0				FORTH_RSP_TOS 
3af0 cd 06 20			call macro_forth_rsp_tos 
3af3				endm 
# End of macro FORTH_RSP_TOS
3af3			 
3af3				;push hl 
3af3			 
3af3				; not going to DO any more 
3af3				; get rid of the RSP pointer as DO will add it back in 
3af3				;FORTH_RSP_POP 
3af3				;pop hl 
3af3			 
3af3			 
3af3 22 f7 f3			ld (os_tok_ptr), hl 
3af6					if DEBUG_FORTH_WORDS 
3af6						DMARK "-L<" 
3af6 f5				push af  
3af7 3a 0b 3b			ld a, (.dmark)  
3afa 32 a0 fd			ld (debug_mark),a  
3afd 3a 0c 3b			ld a, (.dmark+1)  
3b00 32 a1 fd			ld (debug_mark+1),a  
3b03 3a 0d 3b			ld a, (.dmark+2)  
3b06 32 a2 fd			ld (debug_mark+2),a  
3b09 18 03			jr .pastdmark  
3b0b ..			.dmark: db "-L<"  
3b0e f1			.pastdmark: pop af  
3b0f			endm  
# End of macro DMARK
3b0f					CALLMONITOR 
3b0f cd aa fd			call debug_vector  
3b12				endm  
# End of macro CALLMONITOR
3b12				endif 
3b12 c3 c1 24			jp exec1 
3b15			 
3b15					 
3b15			 
3b15			 
3b15			 
3b15				NEXTW 
3b15 c3 38 24			jp macro_next 
3b18				endm 
# End of macro NEXTW
3b18			 
3b18			 
3b18			 
3b18			 
3b18			.REPEAT: 
3b18				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3b18 71				db WORD_SYS_CORE+93             
3b19 6b 3b			dw .UNTIL            
3b1b 06				db 5 + 1 
3b1c .. 00			db "REPEAT",0              
3b23				endm 
# End of macro CWHEAD
3b23			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3b23			;  push pc to rsp stack past the REPEAT 
3b23					if DEBUG_FORTH_WORDS_KEY 
3b23						DMARK "REP" 
3b23 f5				push af  
3b24 3a 38 3b			ld a, (.dmark)  
3b27 32 a0 fd			ld (debug_mark),a  
3b2a 3a 39 3b			ld a, (.dmark+1)  
3b2d 32 a1 fd			ld (debug_mark+1),a  
3b30 3a 3a 3b			ld a, (.dmark+2)  
3b33 32 a2 fd			ld (debug_mark+2),a  
3b36 18 03			jr .pastdmark  
3b38 ..			.dmark: db "REP"  
3b3b f1			.pastdmark: pop af  
3b3c			endm  
# End of macro DMARK
3b3c						CALLMONITOR 
3b3c cd aa fd			call debug_vector  
3b3f				endm  
# End of macro CALLMONITOR
3b3f					endif 
3b3f			 
3b3f 2a f7 f3				ld hl, (os_tok_ptr) 
3b42 23					inc hl   ; R 
3b43 23					inc hl  ; E 
3b44 23					inc hl   ; P 
3b45 23					inc hl   ; E 
3b46 23					inc hl   ; A 
3b47 23					inc hl   ; T 
3b48 23					inc hl   ; zero 
3b49					FORTH_RSP_NEXT 
3b49 cd ef 1f			call macro_forth_rsp_next 
3b4c				endm 
# End of macro FORTH_RSP_NEXT
3b4c			 
3b4c			 
3b4c					if DEBUG_FORTH_WORDS 
3b4c						DMARK "REP" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 a0 fd			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 a1 fd			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 a2 fd			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "REP"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						;pop bc    ; TODO BUG ?????? what is this for???? 
3b65						CALLMONITOR 
3b65 cd aa fd			call debug_vector  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68			 
3b68					NEXTW 
3b68 c3 38 24			jp macro_next 
3b6b				endm 
# End of macro NEXTW
3b6b			;	       NEXTW 
3b6b			 
3b6b			.UNTIL: 
3b6b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3b6b 72				db WORD_SYS_CORE+94             
3b6c 02 3c			dw .ENDFLOW            
3b6e 06				db 5 + 1 
3b6f .. 00			db "UNTIL",0              
3b75				endm 
# End of macro CWHEAD
3b75			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3b75			 
3b75				; pop tos as check 
3b75			 
3b75				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3b75			 
3b75				FORTH_DSP_VALUEHL 
3b75 cd 4d 22			call macro_dsp_valuehl 
3b78				endm 
# End of macro FORTH_DSP_VALUEHL
3b78			 
3b78					if DEBUG_FORTH_WORDS_KEY 
3b78						DMARK "UNT" 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 a0 fd			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 a1 fd			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 a2 fd			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "UNT"  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd aa fd			call debug_vector  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94			 
3b94			;	push hl 
3b94				FORTH_DSP_POP 
3b94 cd 05 23			call macro_forth_dsp_pop 
3b97				endm 
# End of macro FORTH_DSP_POP
3b97			 
3b97			;	pop hl 
3b97			 
3b97				; test if true 
3b97			 
3b97 cd 07 10			call ishlzero 
3b9a			;	ld a,l 
3b9a			;	add h 
3b9a			; 
3b9a			;	cp 0 
3b9a			 
3b9a 20 3e			jr nz, .untilnotdone 
3b9c			 
3b9c					if DEBUG_FORTH_WORDS 
3b9c						DMARK "UNf" 
3b9c f5				push af  
3b9d 3a b1 3b			ld a, (.dmark)  
3ba0 32 a0 fd			ld (debug_mark),a  
3ba3 3a b2 3b			ld a, (.dmark+1)  
3ba6 32 a1 fd			ld (debug_mark+1),a  
3ba9 3a b3 3b			ld a, (.dmark+2)  
3bac 32 a2 fd			ld (debug_mark+2),a  
3baf 18 03			jr .pastdmark  
3bb1 ..			.dmark: db "UNf"  
3bb4 f1			.pastdmark: pop af  
3bb5			endm  
# End of macro DMARK
3bb5						CALLMONITOR 
3bb5 cd aa fd			call debug_vector  
3bb8				endm  
# End of macro CALLMONITOR
3bb8					endif 
3bb8			 
3bb8			 
3bb8			 
3bb8				FORTH_RSP_POP     ; get rid of DO ptr 
3bb8 cd 10 20			call macro_forth_rsp_pop 
3bbb				endm 
# End of macro FORTH_RSP_POP
3bbb			 
3bbb			if DEBUG_FORTH_WORDS 
3bbb						DMARK "UN>" 
3bbb f5				push af  
3bbc 3a d0 3b			ld a, (.dmark)  
3bbf 32 a0 fd			ld (debug_mark),a  
3bc2 3a d1 3b			ld a, (.dmark+1)  
3bc5 32 a1 fd			ld (debug_mark+1),a  
3bc8 3a d2 3b			ld a, (.dmark+2)  
3bcb 32 a2 fd			ld (debug_mark+2),a  
3bce 18 03			jr .pastdmark  
3bd0 ..			.dmark: db "UN>"  
3bd3 f1			.pastdmark: pop af  
3bd4			endm  
# End of macro DMARK
3bd4				CALLMONITOR 
3bd4 cd aa fd			call debug_vector  
3bd7				endm  
# End of macro CALLMONITOR
3bd7			endif 
3bd7			 
3bd7					NEXTW 
3bd7 c3 38 24			jp macro_next 
3bda				endm 
# End of macro NEXTW
3bda				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3bda			 
3bda			.untilnotdone: 
3bda			 
3bda			 
3bda			;	; get DO ptr 
3bda			; 
3bda				FORTH_RSP_TOS 
3bda cd 06 20			call macro_forth_rsp_tos 
3bdd				endm 
# End of macro FORTH_RSP_TOS
3bdd			 
3bdd				;push hl 
3bdd			 
3bdd				; not going to DO any more 
3bdd				; get rid of the RSP pointer as DO will add it back in 
3bdd				;FORTH_RSP_POP 
3bdd				;pop hl 
3bdd			 
3bdd			 
3bdd 22 f7 f3			ld (os_tok_ptr), hl 
3be0					if DEBUG_FORTH_WORDS 
3be0						DMARK "UN<" 
3be0 f5				push af  
3be1 3a f5 3b			ld a, (.dmark)  
3be4 32 a0 fd			ld (debug_mark),a  
3be7 3a f6 3b			ld a, (.dmark+1)  
3bea 32 a1 fd			ld (debug_mark+1),a  
3bed 3a f7 3b			ld a, (.dmark+2)  
3bf0 32 a2 fd			ld (debug_mark+2),a  
3bf3 18 03			jr .pastdmark  
3bf5 ..			.dmark: db "UN<"  
3bf8 f1			.pastdmark: pop af  
3bf9			endm  
# End of macro DMARK
3bf9					CALLMONITOR 
3bf9 cd aa fd			call debug_vector  
3bfc				endm  
# End of macro CALLMONITOR
3bfc				endif 
3bfc c3 c1 24			jp exec1 
3bff			 
3bff					 
3bff			 
3bff			 
3bff					NEXTW 
3bff c3 38 24			jp macro_next 
3c02				endm 
# End of macro NEXTW
3c02			 
3c02			 
3c02			.ENDFLOW: 
3c02			 
3c02			; eof 
3c02			 
# End of file forth_words_flow.asm
3c02			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3c02			include "forth_words_logic.asm" 
3c02			 
3c02			; | ## Logic Words 
3c02			 
3c02			.NOT: 
3c02				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3c02 2d				db WORD_SYS_CORE+25             
3c03 4a 3c			dw .IS            
3c05 04				db 3 + 1 
3c06 .. 00			db "NOT",0              
3c0a				endm 
# End of macro CWHEAD
3c0a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3c0a					if DEBUG_FORTH_WORDS_KEY 
3c0a						DMARK "NOT" 
3c0a f5				push af  
3c0b 3a 1f 3c			ld a, (.dmark)  
3c0e 32 a0 fd			ld (debug_mark),a  
3c11 3a 20 3c			ld a, (.dmark+1)  
3c14 32 a1 fd			ld (debug_mark+1),a  
3c17 3a 21 3c			ld a, (.dmark+2)  
3c1a 32 a2 fd			ld (debug_mark+2),a  
3c1d 18 03			jr .pastdmark  
3c1f ..			.dmark: db "NOT"  
3c22 f1			.pastdmark: pop af  
3c23			endm  
# End of macro DMARK
3c23						CALLMONITOR 
3c23 cd aa fd			call debug_vector  
3c26				endm  
# End of macro CALLMONITOR
3c26					endif 
3c26					FORTH_DSP 
3c26 cd 13 22			call macro_forth_dsp 
3c29				endm 
# End of macro FORTH_DSP
3c29 7e					ld a,(hl)	; get type of value on TOS 
3c2a fe 02				cp DS_TYPE_INUM  
3c2c 28 03				jr z, .noti 
3c2e					NEXTW 
3c2e c3 38 24			jp macro_next 
3c31				endm 
# End of macro NEXTW
3c31			.noti:          FORTH_DSP_VALUEHL 
3c31 cd 4d 22			call macro_dsp_valuehl 
3c34				endm 
# End of macro FORTH_DSP_VALUEHL
3c34			;		push hl 
3c34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c34 cd 05 23			call macro_forth_dsp_pop 
3c37				endm 
# End of macro FORTH_DSP_POP
3c37			;		pop hl 
3c37 3e 00				ld a,0 
3c39 bd					cp l 
3c3a 28 04				jr z, .not2t 
3c3c 2e 00				ld l, 0 
3c3e 18 02				jr .notip 
3c40			 
3c40 2e ff		.not2t:		ld l, 255 
3c42			 
3c42 26 00		.notip:		ld h, 0	 
3c44			 
3c44 cd 48 20				call forth_push_numhl 
3c47					NEXTW 
3c47 c3 38 24			jp macro_next 
3c4a				endm 
# End of macro NEXTW
3c4a			 
3c4a			.IS: 
3c4a				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3c4a 2d				db WORD_SYS_CORE+25             
3c4b 8b 3c			dw .LZERO            
3c4d 08				db 7 + 1 
3c4e .. 00			db "COMPARE",0              
3c56				endm 
# End of macro CWHEAD
3c56			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3c56					if DEBUG_FORTH_WORDS_KEY 
3c56						DMARK "CMP" 
3c56 f5				push af  
3c57 3a 6b 3c			ld a, (.dmark)  
3c5a 32 a0 fd			ld (debug_mark),a  
3c5d 3a 6c 3c			ld a, (.dmark+1)  
3c60 32 a1 fd			ld (debug_mark+1),a  
3c63 3a 6d 3c			ld a, (.dmark+2)  
3c66 32 a2 fd			ld (debug_mark+2),a  
3c69 18 03			jr .pastdmark  
3c6b ..			.dmark: db "CMP"  
3c6e f1			.pastdmark: pop af  
3c6f			endm  
# End of macro DMARK
3c6f						CALLMONITOR 
3c6f cd aa fd			call debug_vector  
3c72				endm  
# End of macro CALLMONITOR
3c72					endif 
3c72			 
3c72					FORTH_DSP_VALUEHL 
3c72 cd 4d 22			call macro_dsp_valuehl 
3c75				endm 
# End of macro FORTH_DSP_VALUEHL
3c75			 
3c75 e5					push hl 
3c76			 
3c76					FORTH_DSP_VALUEM1 
3c76 cd 41 22			call macro_forth_dsp_value_m1 
3c79				endm 
# End of macro FORTH_DSP_VALUEM1
3c79			 
3c79 d1					pop de 
3c7a			 
3c7a					; got pointers to both. Now check. 
3c7a			 
3c7a cd 7c 13				call strcmp 
3c7d				 
3c7d 26 00				ld h, 0 
3c7f 2e 00				ld l, 0 
3c81 20 02				jr nz, .compnsame 
3c83 2e 01				ld l, 1	 
3c85			.compnsame: 
3c85 cd 48 20				call forth_push_numhl 
3c88			 
3c88					NEXTW 
3c88 c3 38 24			jp macro_next 
3c8b				endm 
# End of macro NEXTW
3c8b			.LZERO: 
3c8b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3c8b 2d				db WORD_SYS_CORE+25             
3c8c 95 3c			dw .TZERO            
3c8e 03				db 2 + 1 
3c8f .. 00			db "0<",0              
3c92				endm 
# End of macro CWHEAD
3c92			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3c92					NEXTW 
3c92 c3 38 24			jp macro_next 
3c95				endm 
# End of macro NEXTW
3c95			.TZERO: 
3c95				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3c95 2e				db WORD_SYS_CORE+26             
3c96 dc 3c			dw .LESS            
3c98 03				db 2 + 1 
3c99 .. 00			db "0=",0              
3c9c				endm 
# End of macro CWHEAD
3c9c			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3c9c				; TODO add floating point number detection 
3c9c					;v5 FORTH_DSP_VALUE 
3c9c					if DEBUG_FORTH_WORDS_KEY 
3c9c						DMARK "0=." 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 a0 fd			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 a1 fd			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 a2 fd			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "0=."  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd aa fd			call debug_vector  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8					FORTH_DSP 
3cb8 cd 13 22			call macro_forth_dsp 
3cbb				endm 
# End of macro FORTH_DSP
3cbb 7e					ld a,(hl)	; get type of value on TOS 
3cbc fe 02				cp DS_TYPE_INUM  
3cbe 28 00				jr z, .tz_inum 
3cc0			 
3cc0				if FORTH_ENABLE_FLOATMATH 
3cc0					jr .tz_done 
3cc0			 
3cc0				endif 
3cc0					 
3cc0			 
3cc0			.tz_inum: 
3cc0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc0 cd 4d 22			call macro_dsp_valuehl 
3cc3				endm 
# End of macro FORTH_DSP_VALUEHL
3cc3			 
3cc3			;		push hl 
3cc3			 
3cc3					; destroy value TOS 
3cc3			 
3cc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc3 cd 05 23			call macro_forth_dsp_pop 
3cc6				endm 
# End of macro FORTH_DSP_POP
3cc6			 
3cc6			;		pop hl 
3cc6			 
3cc6 3e 00				ld a,0 
3cc8			 
3cc8 bd					cp l 
3cc9 20 08				jr nz, .tz_notzero 
3ccb			 
3ccb bc					cp h 
3ccc			 
3ccc 20 05				jr nz, .tz_notzero 
3cce			 
3cce			 
3cce 21 01 00				ld hl, FORTH_TRUE 
3cd1 18 03				jr .tz_done 
3cd3			 
3cd3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3cd6			 
3cd6					; push value back onto stack for another op etc 
3cd6			 
3cd6			.tz_done: 
3cd6 cd 48 20				call forth_push_numhl 
3cd9			 
3cd9					NEXTW 
3cd9 c3 38 24			jp macro_next 
3cdc				endm 
# End of macro NEXTW
3cdc			.LESS: 
3cdc				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3cdc 2f				db WORD_SYS_CORE+27             
3cdd 45 3d			dw .GT            
3cdf 02				db 1 + 1 
3ce0 .. 00			db "<",0              
3ce2				endm 
# End of macro CWHEAD
3ce2			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3ce2				; TODO add floating point number detection 
3ce2					if DEBUG_FORTH_WORDS_KEY 
3ce2						DMARK "LES" 
3ce2 f5				push af  
3ce3 3a f7 3c			ld a, (.dmark)  
3ce6 32 a0 fd			ld (debug_mark),a  
3ce9 3a f8 3c			ld a, (.dmark+1)  
3cec 32 a1 fd			ld (debug_mark+1),a  
3cef 3a f9 3c			ld a, (.dmark+2)  
3cf2 32 a2 fd			ld (debug_mark+2),a  
3cf5 18 03			jr .pastdmark  
3cf7 ..			.dmark: db "LES"  
3cfa f1			.pastdmark: pop af  
3cfb			endm  
# End of macro DMARK
3cfb						CALLMONITOR 
3cfb cd aa fd			call debug_vector  
3cfe				endm  
# End of macro CALLMONITOR
3cfe					endif 
3cfe					FORTH_DSP 
3cfe cd 13 22			call macro_forth_dsp 
3d01				endm 
# End of macro FORTH_DSP
3d01					;v5 FORTH_DSP_VALUE 
3d01 7e					ld a,(hl)	; get type of value on TOS 
3d02 fe 02				cp DS_TYPE_INUM  
3d04 28 00				jr z, .less_inum 
3d06			 
3d06				if FORTH_ENABLE_FLOATMATH 
3d06					jr .less_done 
3d06			 
3d06				endif 
3d06					 
3d06			 
3d06			.less_inum: 
3d06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d06 cd 4d 22			call macro_dsp_valuehl 
3d09				endm 
# End of macro FORTH_DSP_VALUEHL
3d09			 
3d09 e5					push hl  ; u2 
3d0a			 
3d0a					; destroy value TOS 
3d0a			 
3d0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0a cd 05 23			call macro_forth_dsp_pop 
3d0d				endm 
# End of macro FORTH_DSP_POP
3d0d			 
3d0d			 
3d0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0d cd 4d 22			call macro_dsp_valuehl 
3d10				endm 
# End of macro FORTH_DSP_VALUEHL
3d10			 
3d10 e5					push hl    ; u1 
3d11			 
3d11					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d11 cd 05 23			call macro_forth_dsp_pop 
3d14				endm 
# End of macro FORTH_DSP_POP
3d14			 
3d14			 
3d14 b7			 or a      ;clear carry flag 
3d15 01 00 00		 ld bc, FORTH_FALSE 
3d18 e1			  pop hl    ; u1 
3d19 d1			  pop de    ; u2 
3d1a ed 52		  sbc hl,de 
3d1c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3d1e			 
3d1e 01 01 00		 ld bc, FORTH_TRUE 
3d21			.lscont:  
3d21 c5					push bc 
3d22 e1					pop hl 
3d23			 
3d23					if DEBUG_FORTH_WORDS 
3d23						DMARK "LT1" 
3d23 f5				push af  
3d24 3a 38 3d			ld a, (.dmark)  
3d27 32 a0 fd			ld (debug_mark),a  
3d2a 3a 39 3d			ld a, (.dmark+1)  
3d2d 32 a1 fd			ld (debug_mark+1),a  
3d30 3a 3a 3d			ld a, (.dmark+2)  
3d33 32 a2 fd			ld (debug_mark+2),a  
3d36 18 03			jr .pastdmark  
3d38 ..			.dmark: db "LT1"  
3d3b f1			.pastdmark: pop af  
3d3c			endm  
# End of macro DMARK
3d3c						CALLMONITOR 
3d3c cd aa fd			call debug_vector  
3d3f				endm  
# End of macro CALLMONITOR
3d3f					endif 
3d3f cd 48 20				call forth_push_numhl 
3d42			 
3d42					NEXTW 
3d42 c3 38 24			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			.GT: 
3d45				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3d45 30				db WORD_SYS_CORE+28             
3d46 ae 3d			dw .EQUAL            
3d48 02				db 1 + 1 
3d49 .. 00			db ">",0              
3d4b				endm 
# End of macro CWHEAD
3d4b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3d4b				; TODO add floating point number detection 
3d4b					if DEBUG_FORTH_WORDS_KEY 
3d4b						DMARK "GRT" 
3d4b f5				push af  
3d4c 3a 60 3d			ld a, (.dmark)  
3d4f 32 a0 fd			ld (debug_mark),a  
3d52 3a 61 3d			ld a, (.dmark+1)  
3d55 32 a1 fd			ld (debug_mark+1),a  
3d58 3a 62 3d			ld a, (.dmark+2)  
3d5b 32 a2 fd			ld (debug_mark+2),a  
3d5e 18 03			jr .pastdmark  
3d60 ..			.dmark: db "GRT"  
3d63 f1			.pastdmark: pop af  
3d64			endm  
# End of macro DMARK
3d64						CALLMONITOR 
3d64 cd aa fd			call debug_vector  
3d67				endm  
# End of macro CALLMONITOR
3d67					endif 
3d67					FORTH_DSP 
3d67 cd 13 22			call macro_forth_dsp 
3d6a				endm 
# End of macro FORTH_DSP
3d6a					;FORTH_DSP_VALUE 
3d6a 7e					ld a,(hl)	; get type of value on TOS 
3d6b fe 02				cp DS_TYPE_INUM  
3d6d 28 00				jr z, .gt_inum 
3d6f			 
3d6f				if FORTH_ENABLE_FLOATMATH 
3d6f					jr .gt_done 
3d6f			 
3d6f				endif 
3d6f					 
3d6f			 
3d6f			.gt_inum: 
3d6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d6f cd 4d 22			call macro_dsp_valuehl 
3d72				endm 
# End of macro FORTH_DSP_VALUEHL
3d72			 
3d72 e5					push hl  ; u2 
3d73			 
3d73					; destroy value TOS 
3d73			 
3d73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d73 cd 05 23			call macro_forth_dsp_pop 
3d76				endm 
# End of macro FORTH_DSP_POP
3d76			 
3d76			 
3d76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d76 cd 4d 22			call macro_dsp_valuehl 
3d79				endm 
# End of macro FORTH_DSP_VALUEHL
3d79			 
3d79 e5					push hl    ; u1 
3d7a			 
3d7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d7a cd 05 23			call macro_forth_dsp_pop 
3d7d				endm 
# End of macro FORTH_DSP_POP
3d7d			 
3d7d			 
3d7d b7			 or a      ;clear carry flag 
3d7e 01 00 00		 ld bc, FORTH_FALSE 
3d81 e1			  pop hl    ; u1 
3d82 d1			  pop de    ; u2 
3d83 ed 52		  sbc hl,de 
3d85 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3d87			 
3d87 01 01 00		 ld bc, FORTH_TRUE 
3d8a			.gtcont:  
3d8a c5					push bc 
3d8b e1					pop hl 
3d8c			 
3d8c					if DEBUG_FORTH_WORDS 
3d8c						DMARK "GT1" 
3d8c f5				push af  
3d8d 3a a1 3d			ld a, (.dmark)  
3d90 32 a0 fd			ld (debug_mark),a  
3d93 3a a2 3d			ld a, (.dmark+1)  
3d96 32 a1 fd			ld (debug_mark+1),a  
3d99 3a a3 3d			ld a, (.dmark+2)  
3d9c 32 a2 fd			ld (debug_mark+2),a  
3d9f 18 03			jr .pastdmark  
3da1 ..			.dmark: db "GT1"  
3da4 f1			.pastdmark: pop af  
3da5			endm  
# End of macro DMARK
3da5						CALLMONITOR 
3da5 cd aa fd			call debug_vector  
3da8				endm  
# End of macro CALLMONITOR
3da8					endif 
3da8 cd 48 20				call forth_push_numhl 
3dab			 
3dab					NEXTW 
3dab c3 38 24			jp macro_next 
3dae				endm 
# End of macro NEXTW
3dae			.EQUAL: 
3dae				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3dae 31				db WORD_SYS_CORE+29             
3daf 19 3e			dw .ENDLOGIC            
3db1 02				db 1 + 1 
3db2 .. 00			db "=",0              
3db4				endm 
# End of macro CWHEAD
3db4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3db4				; TODO add floating point number detection 
3db4					if DEBUG_FORTH_WORDS_KEY 
3db4						DMARK "EQ." 
3db4 f5				push af  
3db5 3a c9 3d			ld a, (.dmark)  
3db8 32 a0 fd			ld (debug_mark),a  
3dbb 3a ca 3d			ld a, (.dmark+1)  
3dbe 32 a1 fd			ld (debug_mark+1),a  
3dc1 3a cb 3d			ld a, (.dmark+2)  
3dc4 32 a2 fd			ld (debug_mark+2),a  
3dc7 18 03			jr .pastdmark  
3dc9 ..			.dmark: db "EQ."  
3dcc f1			.pastdmark: pop af  
3dcd			endm  
# End of macro DMARK
3dcd						CALLMONITOR 
3dcd cd aa fd			call debug_vector  
3dd0				endm  
# End of macro CALLMONITOR
3dd0					endif 
3dd0					FORTH_DSP 
3dd0 cd 13 22			call macro_forth_dsp 
3dd3				endm 
# End of macro FORTH_DSP
3dd3					;v5 FORTH_DSP_VALUE 
3dd3 7e					ld a,(hl)	; get type of value on TOS 
3dd4 fe 02				cp DS_TYPE_INUM  
3dd6 28 00				jr z, .eq_inum 
3dd8			 
3dd8				if FORTH_ENABLE_FLOATMATH 
3dd8					jr .eq_done 
3dd8			 
3dd8				endif 
3dd8					 
3dd8			 
3dd8			.eq_inum: 
3dd8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dd8 cd 4d 22			call macro_dsp_valuehl 
3ddb				endm 
# End of macro FORTH_DSP_VALUEHL
3ddb			 
3ddb e5					push hl 
3ddc			 
3ddc					; destroy value TOS 
3ddc			 
3ddc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ddc cd 05 23			call macro_forth_dsp_pop 
3ddf				endm 
# End of macro FORTH_DSP_POP
3ddf			 
3ddf			 
3ddf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ddf cd 4d 22			call macro_dsp_valuehl 
3de2				endm 
# End of macro FORTH_DSP_VALUEHL
3de2			 
3de2					; one value on hl get other one back 
3de2			 
3de2 e5					push hl 
3de3			 
3de3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de3 cd 05 23			call macro_forth_dsp_pop 
3de6				endm 
# End of macro FORTH_DSP_POP
3de6			 
3de6 0e 00				ld c, FORTH_FALSE 
3de8			 
3de8 e1					pop hl 
3de9 d1					pop de 
3dea			 
3dea 7b					ld a, e 
3deb bd					cp l 
3dec			 
3dec 20 06				jr nz, .eq_done 
3dee			 
3dee 7a					ld a, d 
3def bc					cp h 
3df0			 
3df0 20 02				jr nz, .eq_done 
3df2			 
3df2 0e 01				ld c, FORTH_TRUE 
3df4					 
3df4			 
3df4			 
3df4			.eq_done: 
3df4			 
3df4					; TODO push value back onto stack for another op etc 
3df4			 
3df4 26 00				ld h, 0 
3df6 69					ld l, c 
3df7					if DEBUG_FORTH_WORDS 
3df7						DMARK "EQ1" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 a0 fd			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 a1 fd			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 a2 fd			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "EQ1"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10						CALLMONITOR 
3e10 cd aa fd			call debug_vector  
3e13				endm  
# End of macro CALLMONITOR
3e13					endif 
3e13 cd 48 20				call forth_push_numhl 
3e16			 
3e16					NEXTW 
3e16 c3 38 24			jp macro_next 
3e19				endm 
# End of macro NEXTW
3e19			 
3e19			 
3e19			.ENDLOGIC: 
3e19			; eof 
3e19			 
3e19			 
# End of file forth_words_logic.asm
3e19			include "forth_words_maths.asm" 
3e19			 
3e19			; | ## Maths Words 
3e19			 
3e19			.PLUS:	 
3e19				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3e19 15				db WORD_SYS_CORE+1             
3e1a 77 3e			dw .NEG            
3e1c 02				db 1 + 1 
3e1d .. 00			db "+",0              
3e1f				endm 
# End of macro CWHEAD
3e1f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3e1f					if DEBUG_FORTH_WORDS_KEY 
3e1f						DMARK "PLU" 
3e1f f5				push af  
3e20 3a 34 3e			ld a, (.dmark)  
3e23 32 a0 fd			ld (debug_mark),a  
3e26 3a 35 3e			ld a, (.dmark+1)  
3e29 32 a1 fd			ld (debug_mark+1),a  
3e2c 3a 36 3e			ld a, (.dmark+2)  
3e2f 32 a2 fd			ld (debug_mark+2),a  
3e32 18 03			jr .pastdmark  
3e34 ..			.dmark: db "PLU"  
3e37 f1			.pastdmark: pop af  
3e38			endm  
# End of macro DMARK
3e38						CALLMONITOR 
3e38 cd aa fd			call debug_vector  
3e3b				endm  
# End of macro CALLMONITOR
3e3b					endif 
3e3b					; add top two values and push back result 
3e3b			 
3e3b					;for v5 FORTH_DSP_VALUE 
3e3b					FORTH_DSP 
3e3b cd 13 22			call macro_forth_dsp 
3e3e				endm 
# End of macro FORTH_DSP
3e3e 7e					ld a,(hl)	; get type of value on TOS 
3e3f fe 02				cp DS_TYPE_INUM  
3e41 28 03				jr z, .dot_inum 
3e43			 
3e43					NEXTW 
3e43 c3 38 24			jp macro_next 
3e46				endm 
# End of macro NEXTW
3e46			 
3e46			; float maths 
3e46			 
3e46				if FORTH_ENABLE_FLOATMATH 
3e46						inc hl      ; now at start of numeric as string 
3e46			 
3e46					if DEBUG_FORTH_MATHS 
3e46						DMARK "ADD" 
3e46				CALLMONITOR 
3e46					endif 
3e46			 
3e46					;ld ix, hl 
3e46					call CON 
3e46			 
3e46			 
3e46					push hl 
3e46					 
3e46					 
3e46			 
3e46						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3e46			 
3e46					; get next number 
3e46			 
3e46						FORTH_DSP_VALUE 
3e46			 
3e46						inc hl      ; now at start of numeric as string 
3e46			 
3e46					;ld ix, hl 
3e46					call CON 
3e46			 
3e46					push hl 
3e46			 
3e46			 
3e46						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e46			 
3e46						; TODO do add 
3e46			 
3e46						call IADD 
3e46			 
3e46						; TODO get result back as ascii 
3e46			 
3e46						; TODO push result  
3e46			 
3e46			 
3e46			 
3e46						jr .dot_done 
3e46				endif 
3e46			 
3e46			.dot_inum: 
3e46			 
3e46			 
3e46					if DEBUG_FORTH_DOT 
3e46						DMARK "+IT" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 a0 fd			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 a1 fd			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 a2 fd			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "+IT"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f				CALLMONITOR 
3e5f cd aa fd			call debug_vector  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62			 
3e62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e62 cd 4d 22			call macro_dsp_valuehl 
3e65				endm 
# End of macro FORTH_DSP_VALUEHL
3e65			 
3e65				; TODO add floating point number detection 
3e65			 
3e65 e5					push hl 
3e66			 
3e66					; destroy value TOS 
3e66			 
3e66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e66 cd 05 23			call macro_forth_dsp_pop 
3e69				endm 
# End of macro FORTH_DSP_POP
3e69			 
3e69			 
3e69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e69 cd 4d 22			call macro_dsp_valuehl 
3e6c				endm 
# End of macro FORTH_DSP_VALUEHL
3e6c			 
3e6c					; one value on hl get other one back 
3e6c			 
3e6c d1					pop de 
3e6d			 
3e6d					; do the add 
3e6d			 
3e6d 19					add hl,de 
3e6e			 
3e6e					; save it 
3e6e			 
3e6e			;		push hl	 
3e6e			 
3e6e					; 
3e6e			 
3e6e					; destroy value TOS 
3e6e			 
3e6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e6e cd 05 23			call macro_forth_dsp_pop 
3e71				endm 
# End of macro FORTH_DSP_POP
3e71			 
3e71					; TODO push value back onto stack for another op etc 
3e71			 
3e71			;		pop hl 
3e71			 
3e71			.dot_done: 
3e71 cd 48 20				call forth_push_numhl 
3e74			 
3e74					NEXTW 
3e74 c3 38 24			jp macro_next 
3e77				endm 
# End of macro NEXTW
3e77			.NEG: 
3e77			 
3e77				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3e77 17				db WORD_SYS_CORE+3             
3e78 ba 3e			dw .DIV            
3e7a 02				db 1 + 1 
3e7b .. 00			db "-",0              
3e7d				endm 
# End of macro CWHEAD
3e7d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3e7d					if DEBUG_FORTH_WORDS_KEY 
3e7d						DMARK "SUB" 
3e7d f5				push af  
3e7e 3a 92 3e			ld a, (.dmark)  
3e81 32 a0 fd			ld (debug_mark),a  
3e84 3a 93 3e			ld a, (.dmark+1)  
3e87 32 a1 fd			ld (debug_mark+1),a  
3e8a 3a 94 3e			ld a, (.dmark+2)  
3e8d 32 a2 fd			ld (debug_mark+2),a  
3e90 18 03			jr .pastdmark  
3e92 ..			.dmark: db "SUB"  
3e95 f1			.pastdmark: pop af  
3e96			endm  
# End of macro DMARK
3e96						CALLMONITOR 
3e96 cd aa fd			call debug_vector  
3e99				endm  
# End of macro CALLMONITOR
3e99					endif 
3e99			 
3e99			 
3e99				; TODO add floating point number detection 
3e99					; v5 FORTH_DSP_VALUE 
3e99					FORTH_DSP 
3e99 cd 13 22			call macro_forth_dsp 
3e9c				endm 
# End of macro FORTH_DSP
3e9c 7e					ld a,(hl)	; get type of value on TOS 
3e9d fe 02				cp DS_TYPE_INUM  
3e9f 28 03				jr z, .neg_inum 
3ea1			 
3ea1					NEXTW 
3ea1 c3 38 24			jp macro_next 
3ea4				endm 
# End of macro NEXTW
3ea4			 
3ea4			; float maths 
3ea4			 
3ea4				if FORTH_ENABLE_FLOATMATH 
3ea4					jr .neg_done 
3ea4			 
3ea4				endif 
3ea4					 
3ea4			 
3ea4			.neg_inum: 
3ea4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea4 cd 4d 22			call macro_dsp_valuehl 
3ea7				endm 
# End of macro FORTH_DSP_VALUEHL
3ea7			 
3ea7 e5					push hl 
3ea8			 
3ea8					; destroy value TOS 
3ea8			 
3ea8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea8 cd 05 23			call macro_forth_dsp_pop 
3eab				endm 
# End of macro FORTH_DSP_POP
3eab			 
3eab			 
3eab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eab cd 4d 22			call macro_dsp_valuehl 
3eae				endm 
# End of macro FORTH_DSP_VALUEHL
3eae			 
3eae					; one value on hl get other one back 
3eae			 
3eae d1					pop de 
3eaf			 
3eaf					; do the sub 
3eaf			;		ex de, hl 
3eaf			 
3eaf ed 52				sbc hl,de 
3eb1			 
3eb1					; save it 
3eb1			 
3eb1			;		push hl	 
3eb1			 
3eb1					; 
3eb1			 
3eb1					; destroy value TOS 
3eb1			 
3eb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb1 cd 05 23			call macro_forth_dsp_pop 
3eb4				endm 
# End of macro FORTH_DSP_POP
3eb4			 
3eb4					; TODO push value back onto stack for another op etc 
3eb4			 
3eb4			;		pop hl 
3eb4			 
3eb4 cd 48 20				call forth_push_numhl 
3eb7			.neg_done: 
3eb7			 
3eb7					NEXTW 
3eb7 c3 38 24			jp macro_next 
3eba				endm 
# End of macro NEXTW
3eba			.DIV: 
3eba				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3eba 18				db WORD_SYS_CORE+4             
3ebb 07 3f			dw .MUL            
3ebd 02				db 1 + 1 
3ebe .. 00			db "/",0              
3ec0				endm 
# End of macro CWHEAD
3ec0			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3ec0					if DEBUG_FORTH_WORDS_KEY 
3ec0						DMARK "DIV" 
3ec0 f5				push af  
3ec1 3a d5 3e			ld a, (.dmark)  
3ec4 32 a0 fd			ld (debug_mark),a  
3ec7 3a d6 3e			ld a, (.dmark+1)  
3eca 32 a1 fd			ld (debug_mark+1),a  
3ecd 3a d7 3e			ld a, (.dmark+2)  
3ed0 32 a2 fd			ld (debug_mark+2),a  
3ed3 18 03			jr .pastdmark  
3ed5 ..			.dmark: db "DIV"  
3ed8 f1			.pastdmark: pop af  
3ed9			endm  
# End of macro DMARK
3ed9						CALLMONITOR 
3ed9 cd aa fd			call debug_vector  
3edc				endm  
# End of macro CALLMONITOR
3edc					endif 
3edc				; TODO add floating point number detection 
3edc					; v5 FORTH_DSP_VALUE 
3edc					FORTH_DSP 
3edc cd 13 22			call macro_forth_dsp 
3edf				endm 
# End of macro FORTH_DSP
3edf 7e					ld a,(hl)	; get type of value on TOS 
3ee0 fe 02				cp DS_TYPE_INUM  
3ee2 28 03				jr z, .div_inum 
3ee4			 
3ee4				if FORTH_ENABLE_FLOATMATH 
3ee4					jr .div_done 
3ee4			 
3ee4				endif 
3ee4					NEXTW 
3ee4 c3 38 24			jp macro_next 
3ee7				endm 
# End of macro NEXTW
3ee7			.div_inum: 
3ee7			 
3ee7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee7 cd 4d 22			call macro_dsp_valuehl 
3eea				endm 
# End of macro FORTH_DSP_VALUEHL
3eea			 
3eea e5					push hl    ; to go to bc 
3eeb			 
3eeb					; destroy value TOS 
3eeb			 
3eeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eeb cd 05 23			call macro_forth_dsp_pop 
3eee				endm 
# End of macro FORTH_DSP_POP
3eee			 
3eee			 
3eee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eee cd 4d 22			call macro_dsp_valuehl 
3ef1				endm 
# End of macro FORTH_DSP_VALUEHL
3ef1			 
3ef1					; hl to go to de 
3ef1			 
3ef1 e5					push hl 
3ef2			 
3ef2 c1					pop bc 
3ef3 d1					pop de		 
3ef4			 
3ef4			 
3ef4					if DEBUG_FORTH_MATHS 
3ef4						DMARK "DIV" 
3ef4				CALLMONITOR 
3ef4					endif 
3ef4					; one value on hl but move to a get other one back 
3ef4			 
3ef4			        
3ef4 cd 3b 0f			call Div16 
3ef7			 
3ef7			;	push af	 
3ef7 e5				push hl 
3ef8 c5				push bc 
3ef9			 
3ef9					if DEBUG_FORTH_MATHS 
3ef9						DMARK "DI1" 
3ef9				CALLMONITOR 
3ef9					endif 
3ef9			 
3ef9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef9 cd 05 23			call macro_forth_dsp_pop 
3efc				endm 
# End of macro FORTH_DSP_POP
3efc			 
3efc			 
3efc			 
3efc e1					pop hl    ; result 
3efd			 
3efd cd 48 20				call forth_push_numhl 
3f00			 
3f00 e1					pop hl    ; reminder 
3f01			;		ld h,0 
3f01			;		ld l,d 
3f01			 
3f01 cd 48 20				call forth_push_numhl 
3f04			.div_done: 
3f04					NEXTW 
3f04 c3 38 24			jp macro_next 
3f07				endm 
# End of macro NEXTW
3f07			.MUL: 
3f07				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3f07 19				db WORD_SYS_CORE+5             
3f08 4c 3f			dw .MIN            
3f0a 02				db 1 + 1 
3f0b .. 00			db "*",0              
3f0d				endm 
# End of macro CWHEAD
3f0d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3f0d				; TODO add floating point number detection 
3f0d					if DEBUG_FORTH_WORDS_KEY 
3f0d						DMARK "MUL" 
3f0d f5				push af  
3f0e 3a 22 3f			ld a, (.dmark)  
3f11 32 a0 fd			ld (debug_mark),a  
3f14 3a 23 3f			ld a, (.dmark+1)  
3f17 32 a1 fd			ld (debug_mark+1),a  
3f1a 3a 24 3f			ld a, (.dmark+2)  
3f1d 32 a2 fd			ld (debug_mark+2),a  
3f20 18 03			jr .pastdmark  
3f22 ..			.dmark: db "MUL"  
3f25 f1			.pastdmark: pop af  
3f26			endm  
# End of macro DMARK
3f26						CALLMONITOR 
3f26 cd aa fd			call debug_vector  
3f29				endm  
# End of macro CALLMONITOR
3f29					endif 
3f29					FORTH_DSP 
3f29 cd 13 22			call macro_forth_dsp 
3f2c				endm 
# End of macro FORTH_DSP
3f2c					; v5 FORTH_DSP_VALUE 
3f2c 7e					ld a,(hl)	; get type of value on TOS 
3f2d fe 02				cp DS_TYPE_INUM  
3f2f 28 03				jr z, .mul_inum 
3f31			 
3f31				if FORTH_ENABLE_FLOATMATH 
3f31					jr .mul_done 
3f31			 
3f31				endif 
3f31			 
3f31					NEXTW 
3f31 c3 38 24			jp macro_next 
3f34				endm 
# End of macro NEXTW
3f34			.mul_inum:	 
3f34			 
3f34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f34 cd 4d 22			call macro_dsp_valuehl 
3f37				endm 
# End of macro FORTH_DSP_VALUEHL
3f37			 
3f37 e5					push hl 
3f38			 
3f38					; destroy value TOS 
3f38			 
3f38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f38 cd 05 23			call macro_forth_dsp_pop 
3f3b				endm 
# End of macro FORTH_DSP_POP
3f3b			 
3f3b			 
3f3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3b cd 4d 22			call macro_dsp_valuehl 
3f3e				endm 
# End of macro FORTH_DSP_VALUEHL
3f3e			 
3f3e					; one value on hl but move to a get other one back 
3f3e			 
3f3e 7d					ld a, l 
3f3f			 
3f3f d1					pop de 
3f40			 
3f40					; do the mull 
3f40			;		ex de, hl 
3f40			 
3f40 cd 61 0f				call Mult16 
3f43					; save it 
3f43			 
3f43			;		push hl	 
3f43			 
3f43					; 
3f43			 
3f43					; destroy value TOS 
3f43			 
3f43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f43 cd 05 23			call macro_forth_dsp_pop 
3f46				endm 
# End of macro FORTH_DSP_POP
3f46			 
3f46					; TODO push value back onto stack for another op etc 
3f46			 
3f46			;		pop hl 
3f46			 
3f46 cd 48 20				call forth_push_numhl 
3f49			 
3f49			.mul_done: 
3f49					NEXTW 
3f49 c3 38 24			jp macro_next 
3f4c				endm 
# End of macro NEXTW
3f4c			 
3f4c			 
3f4c			 
3f4c			 
3f4c			.MIN: 
3f4c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3f4c 49				db WORD_SYS_CORE+53             
3f4d cd 3f			dw .MAX            
3f4f 04				db 3 + 1 
3f50 .. 00			db "MIN",0              
3f54				endm 
# End of macro CWHEAD
3f54			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3f54					if DEBUG_FORTH_WORDS_KEY 
3f54						DMARK "MIN" 
3f54 f5				push af  
3f55 3a 69 3f			ld a, (.dmark)  
3f58 32 a0 fd			ld (debug_mark),a  
3f5b 3a 6a 3f			ld a, (.dmark+1)  
3f5e 32 a1 fd			ld (debug_mark+1),a  
3f61 3a 6b 3f			ld a, (.dmark+2)  
3f64 32 a2 fd			ld (debug_mark+2),a  
3f67 18 03			jr .pastdmark  
3f69 ..			.dmark: db "MIN"  
3f6c f1			.pastdmark: pop af  
3f6d			endm  
# End of macro DMARK
3f6d						CALLMONITOR 
3f6d cd aa fd			call debug_vector  
3f70				endm  
# End of macro CALLMONITOR
3f70					endif 
3f70					; get u2 
3f70			 
3f70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f70 cd 4d 22			call macro_dsp_valuehl 
3f73				endm 
# End of macro FORTH_DSP_VALUEHL
3f73			 
3f73 e5					push hl   ; u2 
3f74			 
3f74					; destroy value TOS 
3f74			 
3f74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f74 cd 05 23			call macro_forth_dsp_pop 
3f77				endm 
# End of macro FORTH_DSP_POP
3f77			 
3f77					; get u1 
3f77			 
3f77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f77 cd 4d 22			call macro_dsp_valuehl 
3f7a				endm 
# End of macro FORTH_DSP_VALUEHL
3f7a			 
3f7a e5					push hl  ; u1 
3f7b			 
3f7b					; destroy value TOS 
3f7b			 
3f7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7b cd 05 23			call macro_forth_dsp_pop 
3f7e				endm 
# End of macro FORTH_DSP_POP
3f7e			 
3f7e b7			 or a      ;clear carry flag 
3f7f e1			  pop hl    ; u1 
3f80 d1			  pop de    ; u2 
3f81 e5				push hl   ; saved in case hl is lowest 
3f82 ed 52		  sbc hl,de 
3f84 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3f86			 
3f86 e1				pop hl 
3f87					if DEBUG_FORTH_WORDS 
3f87						DMARK "MIN" 
3f87 f5				push af  
3f88 3a 9c 3f			ld a, (.dmark)  
3f8b 32 a0 fd			ld (debug_mark),a  
3f8e 3a 9d 3f			ld a, (.dmark+1)  
3f91 32 a1 fd			ld (debug_mark+1),a  
3f94 3a 9e 3f			ld a, (.dmark+2)  
3f97 32 a2 fd			ld (debug_mark+2),a  
3f9a 18 03			jr .pastdmark  
3f9c ..			.dmark: db "MIN"  
3f9f f1			.pastdmark: pop af  
3fa0			endm  
# End of macro DMARK
3fa0						CALLMONITOR 
3fa0 cd aa fd			call debug_vector  
3fa3				endm  
# End of macro CALLMONITOR
3fa3					endif 
3fa3 cd 48 20				call forth_push_numhl 
3fa6			 
3fa6				       NEXTW 
3fa6 c3 38 24			jp macro_next 
3fa9				endm 
# End of macro NEXTW
3fa9			 
3fa9			.mincont:  
3fa9 c1				pop bc   ; tidy up 
3faa eb				ex de , hl  
3fab					if DEBUG_FORTH_WORDS 
3fab						DMARK "MI1" 
3fab f5				push af  
3fac 3a c0 3f			ld a, (.dmark)  
3faf 32 a0 fd			ld (debug_mark),a  
3fb2 3a c1 3f			ld a, (.dmark+1)  
3fb5 32 a1 fd			ld (debug_mark+1),a  
3fb8 3a c2 3f			ld a, (.dmark+2)  
3fbb 32 a2 fd			ld (debug_mark+2),a  
3fbe 18 03			jr .pastdmark  
3fc0 ..			.dmark: db "MI1"  
3fc3 f1			.pastdmark: pop af  
3fc4			endm  
# End of macro DMARK
3fc4						CALLMONITOR 
3fc4 cd aa fd			call debug_vector  
3fc7				endm  
# End of macro CALLMONITOR
3fc7					endif 
3fc7 cd 48 20				call forth_push_numhl 
3fca			 
3fca				       NEXTW 
3fca c3 38 24			jp macro_next 
3fcd				endm 
# End of macro NEXTW
3fcd			.MAX: 
3fcd				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3fcd 4a				db WORD_SYS_CORE+54             
3fce 4e 40			dw .RND16            
3fd0 04				db 3 + 1 
3fd1 .. 00			db "MAX",0              
3fd5				endm 
# End of macro CWHEAD
3fd5			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3fd5					if DEBUG_FORTH_WORDS_KEY 
3fd5						DMARK "MAX" 
3fd5 f5				push af  
3fd6 3a ea 3f			ld a, (.dmark)  
3fd9 32 a0 fd			ld (debug_mark),a  
3fdc 3a eb 3f			ld a, (.dmark+1)  
3fdf 32 a1 fd			ld (debug_mark+1),a  
3fe2 3a ec 3f			ld a, (.dmark+2)  
3fe5 32 a2 fd			ld (debug_mark+2),a  
3fe8 18 03			jr .pastdmark  
3fea ..			.dmark: db "MAX"  
3fed f1			.pastdmark: pop af  
3fee			endm  
# End of macro DMARK
3fee						CALLMONITOR 
3fee cd aa fd			call debug_vector  
3ff1				endm  
# End of macro CALLMONITOR
3ff1					endif 
3ff1					; get u2 
3ff1			 
3ff1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff1 cd 4d 22			call macro_dsp_valuehl 
3ff4				endm 
# End of macro FORTH_DSP_VALUEHL
3ff4			 
3ff4 e5					push hl   ; u2 
3ff5			 
3ff5					; destroy value TOS 
3ff5			 
3ff5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff5 cd 05 23			call macro_forth_dsp_pop 
3ff8				endm 
# End of macro FORTH_DSP_POP
3ff8			 
3ff8					; get u1 
3ff8			 
3ff8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff8 cd 4d 22			call macro_dsp_valuehl 
3ffb				endm 
# End of macro FORTH_DSP_VALUEHL
3ffb			 
3ffb e5					push hl  ; u1 
3ffc			 
3ffc					; destroy value TOS 
3ffc			 
3ffc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffc cd 05 23			call macro_forth_dsp_pop 
3fff				endm 
# End of macro FORTH_DSP_POP
3fff			 
3fff b7			 or a      ;clear carry flag 
4000 e1			  pop hl    ; u1 
4001 d1			  pop de    ; u2 
4002 e5				push hl   ; saved in case hl is lowest 
4003 ed 52		  sbc hl,de 
4005 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
4007			 
4007 e1				pop hl 
4008					if DEBUG_FORTH_WORDS 
4008						DMARK "MAX" 
4008 f5				push af  
4009 3a 1d 40			ld a, (.dmark)  
400c 32 a0 fd			ld (debug_mark),a  
400f 3a 1e 40			ld a, (.dmark+1)  
4012 32 a1 fd			ld (debug_mark+1),a  
4015 3a 1f 40			ld a, (.dmark+2)  
4018 32 a2 fd			ld (debug_mark+2),a  
401b 18 03			jr .pastdmark  
401d ..			.dmark: db "MAX"  
4020 f1			.pastdmark: pop af  
4021			endm  
# End of macro DMARK
4021						CALLMONITOR 
4021 cd aa fd			call debug_vector  
4024				endm  
# End of macro CALLMONITOR
4024					endif 
4024 cd 48 20				call forth_push_numhl 
4027			 
4027				       NEXTW 
4027 c3 38 24			jp macro_next 
402a				endm 
# End of macro NEXTW
402a			 
402a			.maxcont:  
402a c1				pop bc   ; tidy up 
402b eb				ex de , hl  
402c					if DEBUG_FORTH_WORDS 
402c						DMARK "MA1" 
402c f5				push af  
402d 3a 41 40			ld a, (.dmark)  
4030 32 a0 fd			ld (debug_mark),a  
4033 3a 42 40			ld a, (.dmark+1)  
4036 32 a1 fd			ld (debug_mark+1),a  
4039 3a 43 40			ld a, (.dmark+2)  
403c 32 a2 fd			ld (debug_mark+2),a  
403f 18 03			jr .pastdmark  
4041 ..			.dmark: db "MA1"  
4044 f1			.pastdmark: pop af  
4045			endm  
# End of macro DMARK
4045						CALLMONITOR 
4045 cd aa fd			call debug_vector  
4048				endm  
# End of macro CALLMONITOR
4048					endif 
4048 cd 48 20				call forth_push_numhl 
404b				       NEXTW 
404b c3 38 24			jp macro_next 
404e				endm 
# End of macro NEXTW
404e			 
404e			.RND16: 
404e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
404e 4e				db WORD_SYS_CORE+58             
404f 7d 40			dw .RND8            
4051 06				db 5 + 1 
4052 .. 00			db "RND16",0              
4058				endm 
# End of macro CWHEAD
4058			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
4058					if DEBUG_FORTH_WORDS_KEY 
4058						DMARK "R16" 
4058 f5				push af  
4059 3a 6d 40			ld a, (.dmark)  
405c 32 a0 fd			ld (debug_mark),a  
405f 3a 6e 40			ld a, (.dmark+1)  
4062 32 a1 fd			ld (debug_mark+1),a  
4065 3a 6f 40			ld a, (.dmark+2)  
4068 32 a2 fd			ld (debug_mark+2),a  
406b 18 03			jr .pastdmark  
406d ..			.dmark: db "R16"  
4070 f1			.pastdmark: pop af  
4071			endm  
# End of macro DMARK
4071						CALLMONITOR 
4071 cd aa fd			call debug_vector  
4074				endm  
# End of macro CALLMONITOR
4074					endif 
4074 cd 05 0f				call prng16  
4077 cd 48 20				call forth_push_numhl 
407a				       NEXTW 
407a c3 38 24			jp macro_next 
407d				endm 
# End of macro NEXTW
407d			.RND8: 
407d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
407d 60				db WORD_SYS_CORE+76             
407e b2 40			dw .RND            
4080 05				db 4 + 1 
4081 .. 00			db "RND8",0              
4086				endm 
# End of macro CWHEAD
4086			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
4086					if DEBUG_FORTH_WORDS_KEY 
4086						DMARK "RN8" 
4086 f5				push af  
4087 3a 9b 40			ld a, (.dmark)  
408a 32 a0 fd			ld (debug_mark),a  
408d 3a 9c 40			ld a, (.dmark+1)  
4090 32 a1 fd			ld (debug_mark+1),a  
4093 3a 9d 40			ld a, (.dmark+2)  
4096 32 a2 fd			ld (debug_mark+2),a  
4099 18 03			jr .pastdmark  
409b ..			.dmark: db "RN8"  
409e f1			.pastdmark: pop af  
409f			endm  
# End of macro DMARK
409f						CALLMONITOR 
409f cd aa fd			call debug_vector  
40a2				endm  
# End of macro CALLMONITOR
40a2					endif 
40a2 2a de fa				ld hl,(xrandc) 
40a5 23					inc hl 
40a6 cd 1f 0f				call xrnd 
40a9 6f					ld l,a	 
40aa 26 00				ld h,0 
40ac cd 48 20				call forth_push_numhl 
40af				       NEXTW 
40af c3 38 24			jp macro_next 
40b2				endm 
# End of macro NEXTW
40b2			.RND: 
40b2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
40b2 60				db WORD_SYS_CORE+76             
40b3 b8 41			dw .ENDMATHS            
40b5 04				db 3 + 1 
40b6 .. 00			db "RND",0              
40ba				endm 
# End of macro CWHEAD
40ba			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
40ba			 
40ba					if DEBUG_FORTH_WORDS_KEY 
40ba						DMARK "RND" 
40ba f5				push af  
40bb 3a cf 40			ld a, (.dmark)  
40be 32 a0 fd			ld (debug_mark),a  
40c1 3a d0 40			ld a, (.dmark+1)  
40c4 32 a1 fd			ld (debug_mark+1),a  
40c7 3a d1 40			ld a, (.dmark+2)  
40ca 32 a2 fd			ld (debug_mark+2),a  
40cd 18 03			jr .pastdmark  
40cf ..			.dmark: db "RND"  
40d2 f1			.pastdmark: pop af  
40d3			endm  
# End of macro DMARK
40d3						CALLMONITOR 
40d3 cd aa fd			call debug_vector  
40d6				endm  
# End of macro CALLMONITOR
40d6					endif 
40d6					 
40d6					FORTH_DSP_VALUEHL    ; upper range 
40d6 cd 4d 22			call macro_dsp_valuehl 
40d9				endm 
# End of macro FORTH_DSP_VALUEHL
40d9			 
40d9 22 e2 fa				ld (LFSRSeed), hl	 
40dc			 
40dc					if DEBUG_FORTH_WORDS 
40dc						DMARK "RN1" 
40dc f5				push af  
40dd 3a f1 40			ld a, (.dmark)  
40e0 32 a0 fd			ld (debug_mark),a  
40e3 3a f2 40			ld a, (.dmark+1)  
40e6 32 a1 fd			ld (debug_mark+1),a  
40e9 3a f3 40			ld a, (.dmark+2)  
40ec 32 a2 fd			ld (debug_mark+2),a  
40ef 18 03			jr .pastdmark  
40f1 ..			.dmark: db "RN1"  
40f4 f1			.pastdmark: pop af  
40f5			endm  
# End of macro DMARK
40f5						CALLMONITOR 
40f5 cd aa fd			call debug_vector  
40f8				endm  
# End of macro CALLMONITOR
40f8					endif 
40f8					FORTH_DSP_POP 
40f8 cd 05 23			call macro_forth_dsp_pop 
40fb				endm 
# End of macro FORTH_DSP_POP
40fb			 
40fb					FORTH_DSP_VALUEHL    ; low range 
40fb cd 4d 22			call macro_dsp_valuehl 
40fe				endm 
# End of macro FORTH_DSP_VALUEHL
40fe			 
40fe					if DEBUG_FORTH_WORDS 
40fe						DMARK "RN2" 
40fe f5				push af  
40ff 3a 13 41			ld a, (.dmark)  
4102 32 a0 fd			ld (debug_mark),a  
4105 3a 14 41			ld a, (.dmark+1)  
4108 32 a1 fd			ld (debug_mark+1),a  
410b 3a 15 41			ld a, (.dmark+2)  
410e 32 a2 fd			ld (debug_mark+2),a  
4111 18 03			jr .pastdmark  
4113 ..			.dmark: db "RN2"  
4116 f1			.pastdmark: pop af  
4117			endm  
# End of macro DMARK
4117						CALLMONITOR 
4117 cd aa fd			call debug_vector  
411a				endm  
# End of macro CALLMONITOR
411a					endif 
411a 22 e4 fa				ld (LFSRSeed+2), hl 
411d			 
411d					FORTH_DSP_POP 
411d cd 05 23			call macro_forth_dsp_pop 
4120				endm 
# End of macro FORTH_DSP_POP
4120			 
4120 e5					push hl 
4121			 
4121 e1			.inrange:	pop hl 
4122 cd 05 0f				call prng16  
4125					if DEBUG_FORTH_WORDS 
4125						DMARK "RN3" 
4125 f5				push af  
4126 3a 3a 41			ld a, (.dmark)  
4129 32 a0 fd			ld (debug_mark),a  
412c 3a 3b 41			ld a, (.dmark+1)  
412f 32 a1 fd			ld (debug_mark+1),a  
4132 3a 3c 41			ld a, (.dmark+2)  
4135 32 a2 fd			ld (debug_mark+2),a  
4138 18 03			jr .pastdmark  
413a ..			.dmark: db "RN3"  
413d f1			.pastdmark: pop af  
413e			endm  
# End of macro DMARK
413e						CALLMONITOR 
413e cd aa fd			call debug_vector  
4141				endm  
# End of macro CALLMONITOR
4141					endif 
4141					 
4141					; if the range is 8bit knock out the high byte 
4141			 
4141 ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
4145			 
4145 3e 00				ld a, 0 
4147 ba					cp d  
4148 20 1e				jr nz, .hirange 
414a 26 00				ld h, 0   ; knock it down to 8bit 
414c			 
414c					if DEBUG_FORTH_WORDS 
414c						DMARK "RNk" 
414c f5				push af  
414d 3a 61 41			ld a, (.dmark)  
4150 32 a0 fd			ld (debug_mark),a  
4153 3a 62 41			ld a, (.dmark+1)  
4156 32 a1 fd			ld (debug_mark+1),a  
4159 3a 63 41			ld a, (.dmark+2)  
415c 32 a2 fd			ld (debug_mark+2),a  
415f 18 03			jr .pastdmark  
4161 ..			.dmark: db "RNk"  
4164 f1			.pastdmark: pop af  
4165			endm  
# End of macro DMARK
4165						CALLMONITOR 
4165 cd aa fd			call debug_vector  
4168				endm  
# End of macro CALLMONITOR
4168					endif 
4168			.hirange:   
4168 e5					push hl  
4169 b7					or a  
416a ed 52		                sbc hl, de 
416c			 
416c					;call cmp16 
416c			 
416c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
416e e1					pop hl 
416f e5					push hl 
4170			 
4170					if DEBUG_FORTH_WORDS 
4170						DMARK "RN4" 
4170 f5				push af  
4171 3a 85 41			ld a, (.dmark)  
4174 32 a0 fd			ld (debug_mark),a  
4177 3a 86 41			ld a, (.dmark+1)  
417a 32 a1 fd			ld (debug_mark+1),a  
417d 3a 87 41			ld a, (.dmark+2)  
4180 32 a2 fd			ld (debug_mark+2),a  
4183 18 03			jr .pastdmark  
4185 ..			.dmark: db "RN4"  
4188 f1			.pastdmark: pop af  
4189			endm  
# End of macro DMARK
4189						CALLMONITOR 
4189 cd aa fd			call debug_vector  
418c				endm  
# End of macro CALLMONITOR
418c					endif 
418c ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
4190					;call cmp16 
4190				 
4190 b7					or a  
4191 ed 52		                sbc hl, de 
4193 38 8c				jr c, .inrange 
4195			 
4195 e1					pop hl 
4196					 
4196					if DEBUG_FORTH_WORDS 
4196						DMARK "RNd" 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 a0 fd			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 a1 fd			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 a2 fd			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "RNd"  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd aa fd			call debug_vector  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2			 
41b2			 
41b2 cd 48 20				call forth_push_numhl 
41b5				       NEXTW 
41b5 c3 38 24			jp macro_next 
41b8				endm 
# End of macro NEXTW
41b8			 
41b8			.ENDMATHS: 
41b8			 
41b8			; eof 
41b8			 
# End of file forth_words_maths.asm
41b8			include "forth_words_display.asm" 
41b8			 
41b8			; | ## Display Words 
41b8			 
41b8			.ACT: 
41b8			 
41b8				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
41b8 62				db WORD_SYS_CORE+78             
41b9 04 42			dw .INFO            
41bb 07				db 6 + 1 
41bc .. 00			db "ACTIVE",0              
41c3				endm 
# End of macro CWHEAD
41c3			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
41c3			;  
41c3			; | | To display a pulsing activity indicator in a processing loop do this... 
41c3			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
41c3			 
41c3					if DEBUG_FORTH_WORDS_KEY 
41c3						DMARK "ACT" 
41c3 f5				push af  
41c4 3a d8 41			ld a, (.dmark)  
41c7 32 a0 fd			ld (debug_mark),a  
41ca 3a d9 41			ld a, (.dmark+1)  
41cd 32 a1 fd			ld (debug_mark+1),a  
41d0 3a da 41			ld a, (.dmark+2)  
41d3 32 a2 fd			ld (debug_mark+2),a  
41d6 18 03			jr .pastdmark  
41d8 ..			.dmark: db "ACT"  
41db f1			.pastdmark: pop af  
41dc			endm  
# End of macro DMARK
41dc						CALLMONITOR 
41dc cd aa fd			call debug_vector  
41df				endm  
# End of macro CALLMONITOR
41df					endif 
41df cd 01 0d				call active 
41e2					if DEBUG_FORTH_WORDS 
41e2						DMARK "ACp" 
41e2 f5				push af  
41e3 3a f7 41			ld a, (.dmark)  
41e6 32 a0 fd			ld (debug_mark),a  
41e9 3a f8 41			ld a, (.dmark+1)  
41ec 32 a1 fd			ld (debug_mark+1),a  
41ef 3a f9 41			ld a, (.dmark+2)  
41f2 32 a2 fd			ld (debug_mark+2),a  
41f5 18 03			jr .pastdmark  
41f7 ..			.dmark: db "ACp"  
41fa f1			.pastdmark: pop af  
41fb			endm  
# End of macro DMARK
41fb						CALLMONITOR 
41fb cd aa fd			call debug_vector  
41fe				endm  
# End of macro CALLMONITOR
41fe					endif 
41fe cd b6 20				call forth_push_str 
4201			 
4201					NEXTW 
4201 c3 38 24			jp macro_next 
4204				endm 
# End of macro NEXTW
4204			.INFO: 
4204			 
4204				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
4204 62				db WORD_SYS_CORE+78             
4205 21 42			dw .ATP            
4207 05				db 4 + 1 
4208 .. 00			db "INFO",0              
420d				endm 
# End of macro CWHEAD
420d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
420d					FORTH_DSP_VALUEHL 
420d cd 4d 22			call macro_dsp_valuehl 
4210				endm 
# End of macro FORTH_DSP_VALUEHL
4210			 
4210					FORTH_DSP_POP 
4210 cd 05 23			call macro_forth_dsp_pop 
4213				endm 
# End of macro FORTH_DSP_POP
4213			 
4213 e5					push hl 
4214			 
4214					FORTH_DSP_VALUEHL 
4214 cd 4d 22			call macro_dsp_valuehl 
4217				endm 
# End of macro FORTH_DSP_VALUEHL
4217			 
4217					FORTH_DSP_POP 
4217 cd 05 23			call macro_forth_dsp_pop 
421a				endm 
# End of macro FORTH_DSP_POP
421a			 
421a d1					pop de 
421b			 
421b cd 3b 0d				call info_panel 
421e			 
421e			 
421e					NEXTW 
421e c3 38 24			jp macro_next 
4221				endm 
# End of macro NEXTW
4221			.ATP: 
4221				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
4221 62				db WORD_SYS_CORE+78             
4222 98 42			dw .FB            
4224 04				db 3 + 1 
4225 .. 00			db "AT?",0              
4229				endm 
# End of macro CWHEAD
4229			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
4229					if DEBUG_FORTH_WORDS_KEY 
4229						DMARK "AT?" 
4229 f5				push af  
422a 3a 3e 42			ld a, (.dmark)  
422d 32 a0 fd			ld (debug_mark),a  
4230 3a 3f 42			ld a, (.dmark+1)  
4233 32 a1 fd			ld (debug_mark+1),a  
4236 3a 40 42			ld a, (.dmark+2)  
4239 32 a2 fd			ld (debug_mark+2),a  
423c 18 03			jr .pastdmark  
423e ..			.dmark: db "AT?"  
4241 f1			.pastdmark: pop af  
4242			endm  
# End of macro DMARK
4242						CALLMONITOR 
4242 cd aa fd			call debug_vector  
4245				endm  
# End of macro CALLMONITOR
4245					endif 
4245 3a 93 f9				ld a, (f_cursor_ptr) 
4248			 
4248			if DEBUG_FORTH_WORDS 
4248				DMARK "AT?" 
4248 f5				push af  
4249 3a 5d 42			ld a, (.dmark)  
424c 32 a0 fd			ld (debug_mark),a  
424f 3a 5e 42			ld a, (.dmark+1)  
4252 32 a1 fd			ld (debug_mark+1),a  
4255 3a 5f 42			ld a, (.dmark+2)  
4258 32 a2 fd			ld (debug_mark+2),a  
425b 18 03			jr .pastdmark  
425d ..			.dmark: db "AT?"  
4260 f1			.pastdmark: pop af  
4261			endm  
# End of macro DMARK
4261				CALLMONITOR 
4261 cd aa fd			call debug_vector  
4264				endm  
# End of macro CALLMONITOR
4264			endif	 
4264					; count the number of rows 
4264			 
4264 06 00				ld b, 0 
4266 4f			.atpr:		ld c, a    ; save in case we go below zero 
4267 d6 28				sub display_cols 
4269 f2 6f 42				jp p, .atprunder 
426c 04					inc b 
426d 18 f7				jr .atpr 
426f			.atprunder:	 
426f			if DEBUG_FORTH_WORDS 
426f				DMARK "A?2" 
426f f5				push af  
4270 3a 84 42			ld a, (.dmark)  
4273 32 a0 fd			ld (debug_mark),a  
4276 3a 85 42			ld a, (.dmark+1)  
4279 32 a1 fd			ld (debug_mark+1),a  
427c 3a 86 42			ld a, (.dmark+2)  
427f 32 a2 fd			ld (debug_mark+2),a  
4282 18 03			jr .pastdmark  
4284 ..			.dmark: db "A?2"  
4287 f1			.pastdmark: pop af  
4288			endm  
# End of macro DMARK
4288				CALLMONITOR 
4288 cd aa fd			call debug_vector  
428b				endm  
# End of macro CALLMONITOR
428b			endif	 
428b 26 00				ld h, 0 
428d 69					ld l, c 
428e cd 48 20				call forth_push_numhl 
4291 68					ld l, b  
4292 cd 48 20				call forth_push_numhl 
4295			 
4295			 
4295				NEXTW 
4295 c3 38 24			jp macro_next 
4298				endm 
# End of macro NEXTW
4298			 
4298			.FB: 
4298				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4298 1b				db WORD_SYS_CORE+7             
4299 e6 42			dw .EMIT            
429b 03				db 2 + 1 
429c .. 00			db "FB",0              
429f				endm 
# End of macro CWHEAD
429f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
429f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
429f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
429f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
429f					if DEBUG_FORTH_WORDS_KEY 
429f						DMARK "FB." 
429f f5				push af  
42a0 3a b4 42			ld a, (.dmark)  
42a3 32 a0 fd			ld (debug_mark),a  
42a6 3a b5 42			ld a, (.dmark+1)  
42a9 32 a1 fd			ld (debug_mark+1),a  
42ac 3a b6 42			ld a, (.dmark+2)  
42af 32 a2 fd			ld (debug_mark+2),a  
42b2 18 03			jr .pastdmark  
42b4 ..			.dmark: db "FB."  
42b7 f1			.pastdmark: pop af  
42b8			endm  
# End of macro DMARK
42b8						CALLMONITOR 
42b8 cd aa fd			call debug_vector  
42bb				endm  
# End of macro CALLMONITOR
42bb					endif 
42bb			 
42bb					FORTH_DSP_VALUEHL 
42bb cd 4d 22			call macro_dsp_valuehl 
42be				endm 
# End of macro FORTH_DSP_VALUEHL
42be			 
42be 7d					ld a, l 
42bf fe 01				cp 1 
42c1 20 05				jr nz, .fbn1 
42c3 21 45 fc				ld hl, display_fb1 
42c6 18 15				jr .fbset 
42c8 fe 02		.fbn1:		cp 2 
42ca 20 05				jr nz, .fbn2 
42cc 21 03 fb				ld hl, display_fb2 
42cf 18 0c				jr .fbset 
42d1 fe 03		.fbn2:		cp 3 
42d3 20 05				jr nz, .fbn3 
42d5 21 a4 fb				ld hl, display_fb3 
42d8 18 03				jr .fbset 
42da			.fbn3:		 ; if invalid number select first 
42da 21 45 fc				ld hl, display_fb1 
42dd 22 01 fb		.fbset:		ld (display_fb_active), hl 
42e0			 
42e0					FORTH_DSP_POP 
42e0 cd 05 23			call macro_forth_dsp_pop 
42e3				endm 
# End of macro FORTH_DSP_POP
42e3			 
42e3					NEXTW 
42e3 c3 38 24			jp macro_next 
42e6				endm 
# End of macro NEXTW
42e6			 
42e6			 
42e6			.EMIT: 
42e6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
42e6 1b				db WORD_SYS_CORE+7             
42e7 37 43			dw .DOTH            
42e9 05				db 4 + 1 
42ea .. 00			db "EMIT",0              
42ef				endm 
# End of macro CWHEAD
42ef			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
42ef					; get value off TOS and display it 
42ef			 
42ef					if DEBUG_FORTH_WORDS_KEY 
42ef						DMARK "EMT" 
42ef f5				push af  
42f0 3a 04 43			ld a, (.dmark)  
42f3 32 a0 fd			ld (debug_mark),a  
42f6 3a 05 43			ld a, (.dmark+1)  
42f9 32 a1 fd			ld (debug_mark+1),a  
42fc 3a 06 43			ld a, (.dmark+2)  
42ff 32 a2 fd			ld (debug_mark+2),a  
4302 18 03			jr .pastdmark  
4304 ..			.dmark: db "EMT"  
4307 f1			.pastdmark: pop af  
4308			endm  
# End of macro DMARK
4308						CALLMONITOR 
4308 cd aa fd			call debug_vector  
430b				endm  
# End of macro CALLMONITOR
430b					endif 
430b			 
430b					FORTH_DSP_VALUEHL 
430b cd 4d 22			call macro_dsp_valuehl 
430e				endm 
# End of macro FORTH_DSP_VALUEHL
430e			 
430e 7d					ld a,l 
430f			 
430f					; TODO write to display 
430f			 
430f 32 f4 f2				ld (os_input), a 
4312 3e 00				ld a, 0 
4314 32 f5 f2				ld (os_input+1), a 
4317					 
4317 3a 93 f9				ld a, (f_cursor_ptr) 
431a 11 f4 f2				ld de, os_input 
431d cd bd 0d				call str_at_display 
4320			 
4320			 
4320 3a 71 f9				ld a,(cli_autodisplay) 
4323 fe 00				cp 0 
4325 28 03				jr z, .enoupdate 
4327 cd cd 0d						call update_display 
432a					.enoupdate: 
432a			 
432a 3a 93 f9				ld a, (f_cursor_ptr) 
432d 3c					inc a 
432e 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
4331			 
4331			 
4331					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4331 cd 05 23			call macro_forth_dsp_pop 
4334				endm 
# End of macro FORTH_DSP_POP
4334			  
4334			 
4334					NEXTW 
4334 c3 38 24			jp macro_next 
4337				endm 
# End of macro NEXTW
4337			.DOTH: 
4337				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4337 1c				db WORD_SYS_CORE+8             
4338 67 43			dw .DOTF            
433a 03				db 2 + 1 
433b .. 00			db ".-",0              
433e				endm 
# End of macro CWHEAD
433e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
433e					; get value off TOS and display it 
433e					if DEBUG_FORTH_WORDS_KEY 
433e						DMARK "DTD" 
433e f5				push af  
433f 3a 53 43			ld a, (.dmark)  
4342 32 a0 fd			ld (debug_mark),a  
4345 3a 54 43			ld a, (.dmark+1)  
4348 32 a1 fd			ld (debug_mark+1),a  
434b 3a 55 43			ld a, (.dmark+2)  
434e 32 a2 fd			ld (debug_mark+2),a  
4351 18 03			jr .pastdmark  
4353 ..			.dmark: db "DTD"  
4356 f1			.pastdmark: pop af  
4357			endm  
# End of macro DMARK
4357						CALLMONITOR 
4357 cd aa fd			call debug_vector  
435a				endm  
# End of macro CALLMONITOR
435a					endif 
435a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
435c 3e 00			ld a, 0 
435e 32 72 f9			ld (cli_mvdot), a 
4361 c3 be 43			jp .dotgo 
4364				NEXTW 
4364 c3 38 24			jp macro_next 
4367				endm 
# End of macro NEXTW
4367			.DOTF: 
4367				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4367 1c				db WORD_SYS_CORE+8             
4368 95 43			dw .DOT            
436a 03				db 2 + 1 
436b .. 00			db ".>",0              
436e				endm 
# End of macro CWHEAD
436e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
436e					; get value off TOS and display it 
436e			        ; TODO BUG adds extra spaces 
436e			        ; TODO BUG handle numerics? 
436e					if DEBUG_FORTH_WORDS_KEY 
436e						DMARK "DTC" 
436e f5				push af  
436f 3a 83 43			ld a, (.dmark)  
4372 32 a0 fd			ld (debug_mark),a  
4375 3a 84 43			ld a, (.dmark+1)  
4378 32 a1 fd			ld (debug_mark+1),a  
437b 3a 85 43			ld a, (.dmark+2)  
437e 32 a2 fd			ld (debug_mark+2),a  
4381 18 03			jr .pastdmark  
4383 ..			.dmark: db "DTC"  
4386 f1			.pastdmark: pop af  
4387			endm  
# End of macro DMARK
4387						CALLMONITOR 
4387 cd aa fd			call debug_vector  
438a				endm  
# End of macro CALLMONITOR
438a					endif 
438a 3e 01			ld a, 1 
438c 32 72 f9			ld (cli_mvdot), a 
438f c3 be 43			jp .dotgo 
4392				NEXTW 
4392 c3 38 24			jp macro_next 
4395				endm 
# End of macro NEXTW
4395			 
4395			.DOT: 
4395				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4395 1c				db WORD_SYS_CORE+8             
4396 71 45			dw .CLS            
4398 02				db 1 + 1 
4399 .. 00			db ".",0              
439b				endm 
# End of macro CWHEAD
439b			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
439b					; get value off TOS and display it 
439b			 
439b					if DEBUG_FORTH_WORDS_KEY 
439b						DMARK "DOT" 
439b f5				push af  
439c 3a b0 43			ld a, (.dmark)  
439f 32 a0 fd			ld (debug_mark),a  
43a2 3a b1 43			ld a, (.dmark+1)  
43a5 32 a1 fd			ld (debug_mark+1),a  
43a8 3a b2 43			ld a, (.dmark+2)  
43ab 32 a2 fd			ld (debug_mark+2),a  
43ae 18 03			jr .pastdmark  
43b0 ..			.dmark: db "DOT"  
43b3 f1			.pastdmark: pop af  
43b4			endm  
# End of macro DMARK
43b4						CALLMONITOR 
43b4 cd aa fd			call debug_vector  
43b7				endm  
# End of macro CALLMONITOR
43b7					endif 
43b7 3e 00			ld a, 0 
43b9 32 72 f9			ld (cli_mvdot), a 
43bc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
43be				 
43be			 
43be			.dotgo: 
43be			 
43be			; move up type to on stack for parserv5 
43be					FORTH_DSP 
43be cd 13 22			call macro_forth_dsp 
43c1				endm 
# End of macro FORTH_DSP
43c1				;FORTH_DSP_VALUE  
43c1			 
43c1			if DEBUG_FORTH_DOT 
43c1				DMARK "DOT" 
43c1 f5				push af  
43c2 3a d6 43			ld a, (.dmark)  
43c5 32 a0 fd			ld (debug_mark),a  
43c8 3a d7 43			ld a, (.dmark+1)  
43cb 32 a1 fd			ld (debug_mark+1),a  
43ce 3a d8 43			ld a, (.dmark+2)  
43d1 32 a2 fd			ld (debug_mark+2),a  
43d4 18 03			jr .pastdmark  
43d6 ..			.dmark: db "DOT"  
43d9 f1			.pastdmark: pop af  
43da			endm  
# End of macro DMARK
43da				CALLMONITOR 
43da cd aa fd			call debug_vector  
43dd				endm  
# End of macro CALLMONITOR
43dd			endif	 
43dd			;		.print: 
43dd			 
43dd 7e				ld a,(hl)  ; work out what type of value is on the TOS 
43de 23				inc hl   ; position to the actual value 
43df fe 01			cp DS_TYPE_STR 
43e1 20 06			jr nz, .dotnum1  
43e3			 
43e3			; display string 
43e3				FORTH_DSP_VALUE  
43e3 cd 36 22			call macro_forth_dsp_value 
43e6				endm 
# End of macro FORTH_DSP_VALUE
43e6 eb				ex de,hl 
43e7 18 49			jr .dotwrite 
43e9			 
43e9			.dotnum1: 
43e9 fe 02			cp DS_TYPE_INUM 
43eb 20 44			jr nz, .dotflot 
43ed			 
43ed			 
43ed			; display number 
43ed			 
43ed			;	push hl 
43ed			;	call clear_display 
43ed			;	pop hl 
43ed			 
43ed 5e				ld e, (hl) 
43ee 23				inc hl 
43ef 56				ld d, (hl) 
43f0 21 f6 f0			ld hl, scratch 
43f3			if DEBUG_FORTH_DOT 
43f3				DMARK "DT1" 
43f3 f5				push af  
43f4 3a 08 44			ld a, (.dmark)  
43f7 32 a0 fd			ld (debug_mark),a  
43fa 3a 09 44			ld a, (.dmark+1)  
43fd 32 a1 fd			ld (debug_mark+1),a  
4400 3a 0a 44			ld a, (.dmark+2)  
4403 32 a2 fd			ld (debug_mark+2),a  
4406 18 03			jr .pastdmark  
4408 ..			.dmark: db "DT1"  
440b f1			.pastdmark: pop af  
440c			endm  
# End of macro DMARK
440c				CALLMONITOR 
440c cd aa fd			call debug_vector  
440f				endm  
# End of macro CALLMONITOR
440f			endif	 
440f			 
440f cd f3 12			call uitoa_16 
4412 eb				ex de,hl 
4413			 
4413			if DEBUG_FORTH_DOT 
4413				DMARK "DT2" 
4413 f5				push af  
4414 3a 28 44			ld a, (.dmark)  
4417 32 a0 fd			ld (debug_mark),a  
441a 3a 29 44			ld a, (.dmark+1)  
441d 32 a1 fd			ld (debug_mark+1),a  
4420 3a 2a 44			ld a, (.dmark+2)  
4423 32 a2 fd			ld (debug_mark+2),a  
4426 18 03			jr .pastdmark  
4428 ..			.dmark: db "DT2"  
442b f1			.pastdmark: pop af  
442c			endm  
# End of macro DMARK
442c				CALLMONITOR 
442c cd aa fd			call debug_vector  
442f				endm  
# End of macro CALLMONITOR
442f			endif	 
442f			 
442f			;	ld de, os_word_scratch 
442f 18 01			jr .dotwrite 
4431			 
4431 00			.dotflot:   nop 
4432			; TODO print floating point number 
4432			 
4432			.dotwrite:		 
4432			 
4432					; if c is set then set all '-' to spaces 
4432					; need to also take into account .>  
4432			 
4432 3e 01				ld a, 1 
4434 b9					cp c 
4435 20 67				jr nz, .nodashswap 
4437			 
4437					; DE has the string to write, working with HL 
4437			 
4437 06 ff				ld b, 255 
4439 d5					push de 
443a e1					pop hl 
443b			 
443b			if DEBUG_FORTH_DOT 
443b				DMARK "DT-" 
443b f5				push af  
443c 3a 50 44			ld a, (.dmark)  
443f 32 a0 fd			ld (debug_mark),a  
4442 3a 51 44			ld a, (.dmark+1)  
4445 32 a1 fd			ld (debug_mark+1),a  
4448 3a 52 44			ld a, (.dmark+2)  
444b 32 a2 fd			ld (debug_mark+2),a  
444e 18 03			jr .pastdmark  
4450 ..			.dmark: db "DT-"  
4453 f1			.pastdmark: pop af  
4454			endm  
# End of macro DMARK
4454				CALLMONITOR 
4454 cd aa fd			call debug_vector  
4457				endm  
# End of macro CALLMONITOR
4457			endif	 
4457 7e			.dashscan:	ld a, (hl) 
4458 fe 00				cp 0 
445a 28 42				jr z, .nodashswap 
445c fe 2d				cp '-' 
445e 20 03				jr nz, .dashskip 
4460 3e 20				ld a, ' ' 
4462 77					ld (hl), a 
4463 23			.dashskip:	inc hl 
4464			if DEBUG_FORTH_DOT 
4464				DMARK "D-2" 
4464 f5				push af  
4465 3a 79 44			ld a, (.dmark)  
4468 32 a0 fd			ld (debug_mark),a  
446b 3a 7a 44			ld a, (.dmark+1)  
446e 32 a1 fd			ld (debug_mark+1),a  
4471 3a 7b 44			ld a, (.dmark+2)  
4474 32 a2 fd			ld (debug_mark+2),a  
4477 18 03			jr .pastdmark  
4479 ..			.dmark: db "D-2"  
447c f1			.pastdmark: pop af  
447d			endm  
# End of macro DMARK
447d				CALLMONITOR 
447d cd aa fd			call debug_vector  
4480				endm  
# End of macro CALLMONITOR
4480			endif	 
4480 10 d5				djnz .dashscan 
4482			 
4482			if DEBUG_FORTH_DOT 
4482				DMARK "D-1" 
4482 f5				push af  
4483 3a 97 44			ld a, (.dmark)  
4486 32 a0 fd			ld (debug_mark),a  
4489 3a 98 44			ld a, (.dmark+1)  
448c 32 a1 fd			ld (debug_mark+1),a  
448f 3a 99 44			ld a, (.dmark+2)  
4492 32 a2 fd			ld (debug_mark+2),a  
4495 18 03			jr .pastdmark  
4497 ..			.dmark: db "D-1"  
449a f1			.pastdmark: pop af  
449b			endm  
# End of macro DMARK
449b				CALLMONITOR 
449b cd aa fd			call debug_vector  
449e				endm  
# End of macro CALLMONITOR
449e			endif	 
449e			 
449e			.nodashswap: 
449e			 
449e			if DEBUG_FORTH_DOT 
449e				DMARK "D-o" 
449e f5				push af  
449f 3a b3 44			ld a, (.dmark)  
44a2 32 a0 fd			ld (debug_mark),a  
44a5 3a b4 44			ld a, (.dmark+1)  
44a8 32 a1 fd			ld (debug_mark+1),a  
44ab 3a b5 44			ld a, (.dmark+2)  
44ae 32 a2 fd			ld (debug_mark+2),a  
44b1 18 03			jr .pastdmark  
44b3 ..			.dmark: db "D-o"  
44b6 f1			.pastdmark: pop af  
44b7			endm  
# End of macro DMARK
44b7				CALLMONITOR 
44b7 cd aa fd			call debug_vector  
44ba				endm  
# End of macro CALLMONITOR
44ba			endif	 
44ba			 
44ba d5					push de   ; save string start in case we need to advance print 
44bb			 
44bb 3a 93 f9				ld a, (f_cursor_ptr) 
44be cd bd 0d				call str_at_display 
44c1 3a 71 f9				ld a,(cli_autodisplay) 
44c4 fe 00				cp 0 
44c6 28 03				jr z, .noupdate 
44c8 cd cd 0d						call update_display 
44cb					.noupdate: 
44cb			 
44cb			 
44cb					; see if we need to advance the print position 
44cb			 
44cb e1					pop hl   ; get back string 
44cc			;		ex de,hl 
44cc			 
44cc 3a 72 f9				ld a, (cli_mvdot) 
44cf			if DEBUG_FORTH_DOT 
44cf			;		ld e,a 
44cf				DMARK "D>1" 
44cf f5				push af  
44d0 3a e4 44			ld a, (.dmark)  
44d3 32 a0 fd			ld (debug_mark),a  
44d6 3a e5 44			ld a, (.dmark+1)  
44d9 32 a1 fd			ld (debug_mark+1),a  
44dc 3a e6 44			ld a, (.dmark+2)  
44df 32 a2 fd			ld (debug_mark+2),a  
44e2 18 03			jr .pastdmark  
44e4 ..			.dmark: db "D>1"  
44e7 f1			.pastdmark: pop af  
44e8			endm  
# End of macro DMARK
44e8				CALLMONITOR 
44e8 cd aa fd			call debug_vector  
44eb				endm  
# End of macro CALLMONITOR
44eb			endif	 
44eb fe 00				cp 0 
44ed 28 44				jr z, .noadv 
44ef					; yes, lets advance the print position 
44ef 3e 00				ld a, 0 
44f1 cd 4f 13				call strlent 
44f4			if DEBUG_FORTH_DOT 
44f4				DMARK "D-?" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 a0 fd			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 a1 fd			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 a2 fd			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "D-?"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d				CALLMONITOR 
450d cd aa fd			call debug_vector  
4510				endm  
# End of macro CALLMONITOR
4510			endif	 
4510 3a 93 f9				ld a, (f_cursor_ptr) 
4513 85					add a,l 
4514					;call addatohl 
4514					;ld a, l 
4514 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
4517			 
4517			if DEBUG_FORTH_DOT 
4517				DMARK "D->" 
4517 f5				push af  
4518 3a 2c 45			ld a, (.dmark)  
451b 32 a0 fd			ld (debug_mark),a  
451e 3a 2d 45			ld a, (.dmark+1)  
4521 32 a1 fd			ld (debug_mark+1),a  
4524 3a 2e 45			ld a, (.dmark+2)  
4527 32 a2 fd			ld (debug_mark+2),a  
452a 18 03			jr .pastdmark  
452c ..			.dmark: db "D->"  
452f f1			.pastdmark: pop af  
4530			endm  
# End of macro DMARK
4530				CALLMONITOR 
4530 cd aa fd			call debug_vector  
4533				endm  
# End of macro CALLMONITOR
4533			endif	 
4533			 
4533			.noadv:	 
4533			 
4533					if DEBUG_FORTH_DOT_WAIT 
4533							call next_page_prompt 
4533					endif	 
4533			; TODO this pop off the stack causes a crash. i dont know why 
4533			 
4533			 
4533			if DEBUG_FORTH_DOT 
4533				DMARK "DTh" 
4533 f5				push af  
4534 3a 48 45			ld a, (.dmark)  
4537 32 a0 fd			ld (debug_mark),a  
453a 3a 49 45			ld a, (.dmark+1)  
453d 32 a1 fd			ld (debug_mark+1),a  
4540 3a 4a 45			ld a, (.dmark+2)  
4543 32 a2 fd			ld (debug_mark+2),a  
4546 18 03			jr .pastdmark  
4548 ..			.dmark: db "DTh"  
454b f1			.pastdmark: pop af  
454c			endm  
# End of macro DMARK
454c				CALLMONITOR 
454c cd aa fd			call debug_vector  
454f				endm  
# End of macro CALLMONITOR
454f			endif	 
454f			 
454f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
454f cd 05 23			call macro_forth_dsp_pop 
4552				endm 
# End of macro FORTH_DSP_POP
4552			 
4552			if DEBUG_FORTH_DOT 
4552				DMARK "DTi" 
4552 f5				push af  
4553 3a 67 45			ld a, (.dmark)  
4556 32 a0 fd			ld (debug_mark),a  
4559 3a 68 45			ld a, (.dmark+1)  
455c 32 a1 fd			ld (debug_mark+1),a  
455f 3a 69 45			ld a, (.dmark+2)  
4562 32 a2 fd			ld (debug_mark+2),a  
4565 18 03			jr .pastdmark  
4567 ..			.dmark: db "DTi"  
456a f1			.pastdmark: pop af  
456b			endm  
# End of macro DMARK
456b				CALLMONITOR 
456b cd aa fd			call debug_vector  
456e				endm  
# End of macro CALLMONITOR
456e			endif	 
456e			 
456e			 
456e					NEXTW 
456e c3 38 24			jp macro_next 
4571				endm 
# End of macro NEXTW
4571			 
4571			.CLS: 
4571				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4571 35				db WORD_SYS_CORE+33             
4572 9e 45			dw .DRAW            
4574 04				db 3 + 1 
4575 .. 00			db "CLS",0              
4579				endm 
# End of macro CWHEAD
4579			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4579					if DEBUG_FORTH_WORDS_KEY 
4579						DMARK "CLS" 
4579 f5				push af  
457a 3a 8e 45			ld a, (.dmark)  
457d 32 a0 fd			ld (debug_mark),a  
4580 3a 8f 45			ld a, (.dmark+1)  
4583 32 a1 fd			ld (debug_mark+1),a  
4586 3a 90 45			ld a, (.dmark+2)  
4589 32 a2 fd			ld (debug_mark+2),a  
458c 18 03			jr .pastdmark  
458e ..			.dmark: db "CLS"  
4591 f1			.pastdmark: pop af  
4592			endm  
# End of macro DMARK
4592						CALLMONITOR 
4592 cd aa fd			call debug_vector  
4595				endm  
# End of macro CALLMONITOR
4595					endif 
4595 cd aa 0d				call clear_display 
4598 c3 ac 46				jp .home		; and home cursor 
459b					NEXTW 
459b c3 38 24			jp macro_next 
459e				endm 
# End of macro NEXTW
459e			 
459e			.DRAW: 
459e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
459e 36				db WORD_SYS_CORE+34             
459f c9 45			dw .DUMP            
45a1 05				db 4 + 1 
45a2 .. 00			db "DRAW",0              
45a7				endm 
# End of macro CWHEAD
45a7			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
45a7					if DEBUG_FORTH_WORDS_KEY 
45a7						DMARK "DRW" 
45a7 f5				push af  
45a8 3a bc 45			ld a, (.dmark)  
45ab 32 a0 fd			ld (debug_mark),a  
45ae 3a bd 45			ld a, (.dmark+1)  
45b1 32 a1 fd			ld (debug_mark+1),a  
45b4 3a be 45			ld a, (.dmark+2)  
45b7 32 a2 fd			ld (debug_mark+2),a  
45ba 18 03			jr .pastdmark  
45bc ..			.dmark: db "DRW"  
45bf f1			.pastdmark: pop af  
45c0			endm  
# End of macro DMARK
45c0						CALLMONITOR 
45c0 cd aa fd			call debug_vector  
45c3				endm  
# End of macro CALLMONITOR
45c3					endif 
45c3 cd cd 0d				call update_display 
45c6					NEXTW 
45c6 c3 38 24			jp macro_next 
45c9				endm 
# End of macro NEXTW
45c9			 
45c9			.DUMP: 
45c9				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
45c9 37				db WORD_SYS_CORE+35             
45ca 01 46			dw .CDUMP            
45cc 05				db 4 + 1 
45cd .. 00			db "DUMP",0              
45d2				endm 
# End of macro CWHEAD
45d2			; | DUMP ( x -- ) With address x display dump   | DONE 
45d2			; TODO pop address to use off of the stack 
45d2					if DEBUG_FORTH_WORDS_KEY 
45d2						DMARK "DUM" 
45d2 f5				push af  
45d3 3a e7 45			ld a, (.dmark)  
45d6 32 a0 fd			ld (debug_mark),a  
45d9 3a e8 45			ld a, (.dmark+1)  
45dc 32 a1 fd			ld (debug_mark+1),a  
45df 3a e9 45			ld a, (.dmark+2)  
45e2 32 a2 fd			ld (debug_mark+2),a  
45e5 18 03			jr .pastdmark  
45e7 ..			.dmark: db "DUM"  
45ea f1			.pastdmark: pop af  
45eb			endm  
# End of macro DMARK
45eb						CALLMONITOR 
45eb cd aa fd			call debug_vector  
45ee				endm  
# End of macro CALLMONITOR
45ee					endif 
45ee cd aa 0d				call clear_display 
45f1			 
45f1					; get address 
45f1			 
45f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45f1 cd 4d 22			call macro_dsp_valuehl 
45f4				endm 
# End of macro FORTH_DSP_VALUEHL
45f4				 
45f4					; save it for cdump 
45f4			 
45f4 22 19 f4				ld (os_cur_ptr),hl 
45f7			 
45f7					; destroy value TOS 
45f7			 
45f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f7 cd 05 23			call macro_forth_dsp_pop 
45fa				endm 
# End of macro FORTH_DSP_POP
45fa			 
45fa cd c8 1e				call dumpcont	; skip old style of param parsing	 
45fd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
45fe					NEXTW 
45fe c3 38 24			jp macro_next 
4601				endm 
# End of macro NEXTW
4601			.CDUMP: 
4601				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4601 38				db WORD_SYS_CORE+36             
4602 31 46			dw .DAT            
4604 06				db 5 + 1 
4605 .. 00			db "CDUMP",0              
460b				endm 
# End of macro CWHEAD
460b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
460b					if DEBUG_FORTH_WORDS_KEY 
460b						DMARK "CDP" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 a0 fd			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 a1 fd			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 a2 fd			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "CDP"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd aa fd			call debug_vector  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627 cd aa 0d				call clear_display 
462a cd c8 1e				call dumpcont	 
462d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
462e					NEXTW 
462e c3 38 24			jp macro_next 
4631				endm 
# End of macro NEXTW
4631			 
4631			 
4631			 
4631			 
4631			.DAT: 
4631				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4631 3d				db WORD_SYS_CORE+41             
4632 87 46			dw .HOME            
4634 03				db 2 + 1 
4635 .. 00			db "AT",0              
4638				endm 
# End of macro CWHEAD
4638			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4638					if DEBUG_FORTH_WORDS_KEY 
4638						DMARK "AT." 
4638 f5				push af  
4639 3a 4d 46			ld a, (.dmark)  
463c 32 a0 fd			ld (debug_mark),a  
463f 3a 4e 46			ld a, (.dmark+1)  
4642 32 a1 fd			ld (debug_mark+1),a  
4645 3a 4f 46			ld a, (.dmark+2)  
4648 32 a2 fd			ld (debug_mark+2),a  
464b 18 03			jr .pastdmark  
464d ..			.dmark: db "AT."  
4650 f1			.pastdmark: pop af  
4651			endm  
# End of macro DMARK
4651						CALLMONITOR 
4651 cd aa fd			call debug_vector  
4654				endm  
# End of macro CALLMONITOR
4654					endif 
4654					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4654 cd 4d 22			call macro_dsp_valuehl 
4657				endm 
# End of macro FORTH_DSP_VALUEHL
4657			 
4657			 
4657					; TODO save cursor row 
4657 7d					ld a,l 
4658 fe 02				cp 2 
465a 20 04				jr nz, .crow3 
465c 3e 28				ld a, display_row_2 
465e 18 12				jr .ccol1 
4660 fe 03		.crow3:		cp 3 
4662 20 04				jr nz, .crow4 
4664 3e 50				ld a, display_row_3 
4666 18 0a				jr .ccol1 
4668 fe 04		.crow4:		cp 4 
466a 20 04				jr nz, .crow1 
466c 3e 78				ld a, display_row_4 
466e 18 02				jr .ccol1 
4670 3e 00		.crow1:		ld a,display_row_1 
4672 f5			.ccol1:		push af			; got row offset 
4673 6f					ld l,a 
4674 26 00				ld h,0 
4676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4676 cd 05 23			call macro_forth_dsp_pop 
4679				endm 
# End of macro FORTH_DSP_POP
4679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4679 cd 4d 22			call macro_dsp_valuehl 
467c				endm 
# End of macro FORTH_DSP_VALUEHL
467c					; TODO save cursor col 
467c f1					pop af 
467d 85					add l		; add col offset 
467e 32 93 f9				ld (f_cursor_ptr), a 
4681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4681 cd 05 23			call macro_forth_dsp_pop 
4684				endm 
# End of macro FORTH_DSP_POP
4684			 
4684					; calculate  
4684			 
4684					NEXTW 
4684 c3 38 24			jp macro_next 
4687				endm 
# End of macro NEXTW
4687			 
4687			 
4687			.HOME: 
4687				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4687 41				db WORD_SYS_CORE+45             
4688 b4 46			dw .CR            
468a 05				db 4 + 1 
468b .. 00			db "HOME",0              
4690				endm 
# End of macro CWHEAD
4690			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4690					if DEBUG_FORTH_WORDS_KEY 
4690						DMARK "HOM" 
4690 f5				push af  
4691 3a a5 46			ld a, (.dmark)  
4694 32 a0 fd			ld (debug_mark),a  
4697 3a a6 46			ld a, (.dmark+1)  
469a 32 a1 fd			ld (debug_mark+1),a  
469d 3a a7 46			ld a, (.dmark+2)  
46a0 32 a2 fd			ld (debug_mark+2),a  
46a3 18 03			jr .pastdmark  
46a5 ..			.dmark: db "HOM"  
46a8 f1			.pastdmark: pop af  
46a9			endm  
# End of macro DMARK
46a9						CALLMONITOR 
46a9 cd aa fd			call debug_vector  
46ac				endm  
# End of macro CALLMONITOR
46ac					endif 
46ac 3e 00		.home:		ld a, 0		; and home cursor 
46ae 32 93 f9				ld (f_cursor_ptr), a 
46b1					NEXTW 
46b1 c3 38 24			jp macro_next 
46b4				endm 
# End of macro NEXTW
46b4			 
46b4			 
46b4			.CR: 
46b4				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
46b4 46				db WORD_SYS_CORE+50             
46b5 ef 46			dw .SPACE            
46b7 03				db 2 + 1 
46b8 .. 00			db "CR",0              
46bb				endm 
# End of macro CWHEAD
46bb			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
46bb					if DEBUG_FORTH_WORDS_KEY 
46bb						DMARK "CR." 
46bb f5				push af  
46bc 3a d0 46			ld a, (.dmark)  
46bf 32 a0 fd			ld (debug_mark),a  
46c2 3a d1 46			ld a, (.dmark+1)  
46c5 32 a1 fd			ld (debug_mark+1),a  
46c8 3a d2 46			ld a, (.dmark+2)  
46cb 32 a2 fd			ld (debug_mark+2),a  
46ce 18 03			jr .pastdmark  
46d0 ..			.dmark: db "CR."  
46d3 f1			.pastdmark: pop af  
46d4			endm  
# End of macro DMARK
46d4						CALLMONITOR 
46d4 cd aa fd			call debug_vector  
46d7				endm  
# End of macro CALLMONITOR
46d7					endif 
46d7 3e 0d				ld a, 13 
46d9 32 f6 f0				ld (scratch),a 
46dc 3e 0a				ld a, 10 
46de 32 f7 f0				ld (scratch+1),a 
46e1 3e 00				ld a, 0 
46e3 32 f8 f0				ld (scratch+2),a 
46e6 21 f6 f0				ld hl, scratch 
46e9 cd b6 20				call forth_push_str 
46ec					 
46ec				       NEXTW 
46ec c3 38 24			jp macro_next 
46ef				endm 
# End of macro NEXTW
46ef			.SPACE: 
46ef				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
46ef 46				db WORD_SYS_CORE+50             
46f0 25 47			dw .SPACES            
46f2 03				db 2 + 1 
46f3 .. 00			db "BL",0              
46f6				endm 
# End of macro CWHEAD
46f6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
46f6					if DEBUG_FORTH_WORDS_KEY 
46f6						DMARK "BL." 
46f6 f5				push af  
46f7 3a 0b 47			ld a, (.dmark)  
46fa 32 a0 fd			ld (debug_mark),a  
46fd 3a 0c 47			ld a, (.dmark+1)  
4700 32 a1 fd			ld (debug_mark+1),a  
4703 3a 0d 47			ld a, (.dmark+2)  
4706 32 a2 fd			ld (debug_mark+2),a  
4709 18 03			jr .pastdmark  
470b ..			.dmark: db "BL."  
470e f1			.pastdmark: pop af  
470f			endm  
# End of macro DMARK
470f						CALLMONITOR 
470f cd aa fd			call debug_vector  
4712				endm  
# End of macro CALLMONITOR
4712					endif 
4712 3e 20				ld a, " " 
4714 32 f6 f0				ld (scratch),a 
4717 3e 00				ld a, 0 
4719 32 f7 f0				ld (scratch+1),a 
471c 21 f6 f0				ld hl, scratch 
471f cd b6 20				call forth_push_str 
4722					 
4722				       NEXTW 
4722 c3 38 24			jp macro_next 
4725				endm 
# End of macro NEXTW
4725			 
4725			;.blstr: db " ", 0 
4725			 
4725			.SPACES: 
4725				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4725 47				db WORD_SYS_CORE+51             
4726 c0 47			dw .SCROLL            
4728 07				db 6 + 1 
4729 .. 00			db "SPACES",0              
4730				endm 
# End of macro CWHEAD
4730			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4730					if DEBUG_FORTH_WORDS_KEY 
4730						DMARK "SPS" 
4730 f5				push af  
4731 3a 45 47			ld a, (.dmark)  
4734 32 a0 fd			ld (debug_mark),a  
4737 3a 46 47			ld a, (.dmark+1)  
473a 32 a1 fd			ld (debug_mark+1),a  
473d 3a 47 47			ld a, (.dmark+2)  
4740 32 a2 fd			ld (debug_mark+2),a  
4743 18 03			jr .pastdmark  
4745 ..			.dmark: db "SPS"  
4748 f1			.pastdmark: pop af  
4749			endm  
# End of macro DMARK
4749						CALLMONITOR 
4749 cd aa fd			call debug_vector  
474c				endm  
# End of macro CALLMONITOR
474c					endif 
474c			 
474c			 
474c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
474c cd 4d 22			call macro_dsp_valuehl 
474f				endm 
# End of macro FORTH_DSP_VALUEHL
474f			 
474f e5					push hl    ; u 
4750					if DEBUG_FORTH_WORDS 
4750						DMARK "SPA" 
4750 f5				push af  
4751 3a 65 47			ld a, (.dmark)  
4754 32 a0 fd			ld (debug_mark),a  
4757 3a 66 47			ld a, (.dmark+1)  
475a 32 a1 fd			ld (debug_mark+1),a  
475d 3a 67 47			ld a, (.dmark+2)  
4760 32 a2 fd			ld (debug_mark+2),a  
4763 18 03			jr .pastdmark  
4765 ..			.dmark: db "SPA"  
4768 f1			.pastdmark: pop af  
4769			endm  
# End of macro DMARK
4769						CALLMONITOR 
4769 cd aa fd			call debug_vector  
476c				endm  
# End of macro CALLMONITOR
476c					endif 
476c			 
476c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
476c cd 05 23			call macro_forth_dsp_pop 
476f				endm 
# End of macro FORTH_DSP_POP
476f e1					pop hl 
4770 0e 00				ld c, 0 
4772 45					ld b, l 
4773 21 f6 f0				ld hl, scratch  
4776			 
4776					if DEBUG_FORTH_WORDS 
4776						DMARK "SP2" 
4776 f5				push af  
4777 3a 8b 47			ld a, (.dmark)  
477a 32 a0 fd			ld (debug_mark),a  
477d 3a 8c 47			ld a, (.dmark+1)  
4780 32 a1 fd			ld (debug_mark+1),a  
4783 3a 8d 47			ld a, (.dmark+2)  
4786 32 a2 fd			ld (debug_mark+2),a  
4789 18 03			jr .pastdmark  
478b ..			.dmark: db "SP2"  
478e f1			.pastdmark: pop af  
478f			endm  
# End of macro DMARK
478f						CALLMONITOR 
478f cd aa fd			call debug_vector  
4792				endm  
# End of macro CALLMONITOR
4792					endif 
4792 3e 20				ld a, ' ' 
4794			.spaces1:	 
4794 77					ld (hl),a 
4795 23					inc hl 
4796					 
4796 10 fc				djnz .spaces1 
4798 3e 00				ld a,0 
479a 77					ld (hl),a 
479b 21 f6 f0				ld hl, scratch 
479e					if DEBUG_FORTH_WORDS 
479e						DMARK "SP3" 
479e f5				push af  
479f 3a b3 47			ld a, (.dmark)  
47a2 32 a0 fd			ld (debug_mark),a  
47a5 3a b4 47			ld a, (.dmark+1)  
47a8 32 a1 fd			ld (debug_mark+1),a  
47ab 3a b5 47			ld a, (.dmark+2)  
47ae 32 a2 fd			ld (debug_mark+2),a  
47b1 18 03			jr .pastdmark  
47b3 ..			.dmark: db "SP3"  
47b6 f1			.pastdmark: pop af  
47b7			endm  
# End of macro DMARK
47b7						CALLMONITOR 
47b7 cd aa fd			call debug_vector  
47ba				endm  
# End of macro CALLMONITOR
47ba					endif 
47ba cd b6 20				call forth_push_str 
47bd			 
47bd				       NEXTW 
47bd c3 38 24			jp macro_next 
47c0				endm 
# End of macro NEXTW
47c0			 
47c0			 
47c0			 
47c0			.SCROLL: 
47c0				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
47c0 53				db WORD_SYS_CORE+63             
47c1 ed 47			dw .SCROLLD            
47c3 07				db 6 + 1 
47c4 .. 00			db "SCROLL",0              
47cb				endm 
# End of macro CWHEAD
47cb			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
47cb					if DEBUG_FORTH_WORDS_KEY 
47cb						DMARK "SCR" 
47cb f5				push af  
47cc 3a e0 47			ld a, (.dmark)  
47cf 32 a0 fd			ld (debug_mark),a  
47d2 3a e1 47			ld a, (.dmark+1)  
47d5 32 a1 fd			ld (debug_mark+1),a  
47d8 3a e2 47			ld a, (.dmark+2)  
47db 32 a2 fd			ld (debug_mark+2),a  
47de 18 03			jr .pastdmark  
47e0 ..			.dmark: db "SCR"  
47e3 f1			.pastdmark: pop af  
47e4			endm  
# End of macro DMARK
47e4						CALLMONITOR 
47e4 cd aa fd			call debug_vector  
47e7				endm  
# End of macro CALLMONITOR
47e7					endif 
47e7			 
47e7 cd 6c 0d			call scroll_up 
47ea			;	call update_display 
47ea			 
47ea					NEXTW 
47ea c3 38 24			jp macro_next 
47ed				endm 
# End of macro NEXTW
47ed			 
47ed			 
47ed			 
47ed			;		; get dir 
47ed			; 
47ed			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
47ed			; 
47ed			;		push hl 
47ed			; 
47ed			;		; destroy value TOS 
47ed			; 
47ed			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47ed			; 
47ed			;		; get count 
47ed			; 
47ed			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
47ed			; 
47ed			;		push hl 
47ed			; 
47ed			;		; destroy value TOS 
47ed			; 
47ed			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47ed			; 
47ed			;		; one value on hl get other one back 
47ed			; 
47ed			;		pop bc    ; count 
47ed			; 
47ed			;		pop de   ; dir 
47ed			; 
47ed			; 
47ed			;		ld b, c 
47ed			; 
47ed			;.scrolldir:     push bc 
47ed			;		push de 
47ed			; 
47ed			;		ld a, 0 
47ed			;		cp e 
47ed			;		jr z, .scrollup  
47ed			;		call scroll_down 
47ed			;		jr .scrollnext 
47ed			;.scrollup:	call scroll_up 
47ed			; 
47ed			;		 
47ed			;.scrollnext: 
47ed			;		pop de 
47ed			;		pop bc 
47ed			;		djnz .scrolldir 
47ed			; 
47ed			; 
47ed			; 
47ed			; 
47ed			; 
47ed			;		NEXTW 
47ed			 
47ed			.SCROLLD: 
47ed				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
47ed 53				db WORD_SYS_CORE+63             
47ee 1b 48			dw .ATQ            
47f0 08				db 7 + 1 
47f1 .. 00			db "SCROLLD",0              
47f9				endm 
# End of macro CWHEAD
47f9			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
47f9					if DEBUG_FORTH_WORDS_KEY 
47f9						DMARK "SCD" 
47f9 f5				push af  
47fa 3a 0e 48			ld a, (.dmark)  
47fd 32 a0 fd			ld (debug_mark),a  
4800 3a 0f 48			ld a, (.dmark+1)  
4803 32 a1 fd			ld (debug_mark+1),a  
4806 3a 10 48			ld a, (.dmark+2)  
4809 32 a2 fd			ld (debug_mark+2),a  
480c 18 03			jr .pastdmark  
480e ..			.dmark: db "SCD"  
4811 f1			.pastdmark: pop af  
4812			endm  
# End of macro DMARK
4812						CALLMONITOR 
4812 cd aa fd			call debug_vector  
4815				endm  
# End of macro CALLMONITOR
4815					endif 
4815			 
4815 cd 90 0d			call scroll_down 
4818			;	call update_display 
4818			 
4818					NEXTW 
4818 c3 38 24			jp macro_next 
481b				endm 
# End of macro NEXTW
481b			 
481b			 
481b			.ATQ: 
481b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
481b 62				db WORD_SYS_CORE+78             
481c 79 48			dw .AUTODSP            
481e 04				db 3 + 1 
481f .. 00			db "AT@",0              
4823				endm 
# End of macro CWHEAD
4823			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4823					if DEBUG_FORTH_WORDS_KEY 
4823						DMARK "ATA" 
4823 f5				push af  
4824 3a 38 48			ld a, (.dmark)  
4827 32 a0 fd			ld (debug_mark),a  
482a 3a 39 48			ld a, (.dmark+1)  
482d 32 a1 fd			ld (debug_mark+1),a  
4830 3a 3a 48			ld a, (.dmark+2)  
4833 32 a2 fd			ld (debug_mark+2),a  
4836 18 03			jr .pastdmark  
4838 ..			.dmark: db "ATA"  
483b f1			.pastdmark: pop af  
483c			endm  
# End of macro DMARK
483c						CALLMONITOR 
483c cd aa fd			call debug_vector  
483f				endm  
# End of macro CALLMONITOR
483f					endif 
483f			 
483f			 
483f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
483f cd 4d 22			call macro_dsp_valuehl 
4842				endm 
# End of macro FORTH_DSP_VALUEHL
4842			 
4842					; TODO save cursor row 
4842 7d					ld a,l 
4843 fe 02				cp 2 
4845 20 04				jr nz, .crow3aq 
4847 3e 28				ld a, display_row_2 
4849 18 12				jr .ccol1aq 
484b fe 03		.crow3aq:		cp 3 
484d 20 04				jr nz, .crow4aq 
484f 3e 50				ld a, display_row_3 
4851 18 0a				jr .ccol1aq 
4853 fe 04		.crow4aq:		cp 4 
4855 20 04				jr nz, .crow1aq 
4857 3e 78				ld a, display_row_4 
4859 18 02				jr .ccol1aq 
485b 3e 00		.crow1aq:		ld a,display_row_1 
485d f5			.ccol1aq:		push af			; got row offset 
485e 6f					ld l,a 
485f 26 00				ld h,0 
4861					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4861 cd 05 23			call macro_forth_dsp_pop 
4864				endm 
# End of macro FORTH_DSP_POP
4864					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4864 cd 4d 22			call macro_dsp_valuehl 
4867				endm 
# End of macro FORTH_DSP_VALUEHL
4867					; TODO save cursor col 
4867 f1					pop af 
4868 85					add l		; add col offset 
4869			 
4869					; add current frame buffer address 
4869 2a 01 fb				ld hl, (display_fb_active) 
486c cd de 0f				call addatohl 
486f			 
486f			 
486f			 
486f			 
486f					; get char frame buffer location offset in hl 
486f			 
486f 7e					ld a,(hl) 
4870 26 00				ld h, 0 
4872 6f					ld l, a 
4873			 
4873 cd 48 20				call forth_push_numhl 
4876			 
4876			 
4876					NEXTW 
4876 c3 38 24			jp macro_next 
4879				endm 
# End of macro NEXTW
4879			 
4879			.AUTODSP: 
4879				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4879 63				db WORD_SYS_CORE+79             
487a 8f 48			dw .MENU            
487c 05				db 4 + 1 
487d .. 00			db "ADSP",0              
4882				endm 
# End of macro CWHEAD
4882			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4882			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4882			 
4882					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4882 cd 4d 22			call macro_dsp_valuehl 
4885				endm 
# End of macro FORTH_DSP_VALUEHL
4885			 
4885			;		push hl 
4885			 
4885					; destroy value TOS 
4885			 
4885					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4885 cd 05 23			call macro_forth_dsp_pop 
4888				endm 
# End of macro FORTH_DSP_POP
4888			 
4888			;		pop hl 
4888			 
4888 7d					ld a,l 
4889 32 71 f9				ld (cli_autodisplay), a 
488c				       NEXTW 
488c c3 38 24			jp macro_next 
488f				endm 
# End of macro NEXTW
488f			 
488f			.MENU: 
488f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
488f 70				db WORD_SYS_CORE+92             
4890 38 49			dw .ENDDISPLAY            
4892 05				db 4 + 1 
4893 .. 00			db "MENU",0              
4898				endm 
# End of macro CWHEAD
4898			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4898			 
4898			;		; get number of items on the stack 
4898			; 
4898				 
4898					FORTH_DSP_VALUEHL 
4898 cd 4d 22			call macro_dsp_valuehl 
489b				endm 
# End of macro FORTH_DSP_VALUEHL
489b				 
489b					if DEBUG_FORTH_WORDS_KEY 
489b						DMARK "MNU" 
489b f5				push af  
489c 3a b0 48			ld a, (.dmark)  
489f 32 a0 fd			ld (debug_mark),a  
48a2 3a b1 48			ld a, (.dmark+1)  
48a5 32 a1 fd			ld (debug_mark+1),a  
48a8 3a b2 48			ld a, (.dmark+2)  
48ab 32 a2 fd			ld (debug_mark+2),a  
48ae 18 03			jr .pastdmark  
48b0 ..			.dmark: db "MNU"  
48b3 f1			.pastdmark: pop af  
48b4			endm  
# End of macro DMARK
48b4						CALLMONITOR 
48b4 cd aa fd			call debug_vector  
48b7				endm  
# End of macro CALLMONITOR
48b7					endif 
48b7			 
48b7 45					ld b, l	 
48b8 05					dec b 
48b9			 
48b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48b9 cd 05 23			call macro_forth_dsp_pop 
48bc				endm 
# End of macro FORTH_DSP_POP
48bc			 
48bc			 
48bc					; go directly through the stack to pluck out the string pointers and build an array 
48bc			 
48bc			;		FORTH_DSP 
48bc			 
48bc					; hl contains top most stack item 
48bc				 
48bc 11 f6 f0				ld de, scratch 
48bf			 
48bf			.mbuild: 
48bf			 
48bf					FORTH_DSP_VALUEHL 
48bf cd 4d 22			call macro_dsp_valuehl 
48c2				endm 
# End of macro FORTH_DSP_VALUEHL
48c2			 
48c2					if DEBUG_FORTH_WORDS 
48c2						DMARK "MN3" 
48c2 f5				push af  
48c3 3a d7 48			ld a, (.dmark)  
48c6 32 a0 fd			ld (debug_mark),a  
48c9 3a d8 48			ld a, (.dmark+1)  
48cc 32 a1 fd			ld (debug_mark+1),a  
48cf 3a d9 48			ld a, (.dmark+2)  
48d2 32 a2 fd			ld (debug_mark+2),a  
48d5 18 03			jr .pastdmark  
48d7 ..			.dmark: db "MN3"  
48da f1			.pastdmark: pop af  
48db			endm  
# End of macro DMARK
48db						CALLMONITOR 
48db cd aa fd			call debug_vector  
48de				endm  
# End of macro CALLMONITOR
48de					endif 
48de eb					ex de, hl 
48df 73					ld (hl), e 
48e0 23					inc hl 
48e1 72					ld (hl), d 
48e2 23					inc hl 
48e3 eb					ex de, hl 
48e4			 
48e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48e4 cd 05 23			call macro_forth_dsp_pop 
48e7				endm 
# End of macro FORTH_DSP_POP
48e7			 
48e7 10 d6				djnz .mbuild 
48e9			 
48e9					; done add term 
48e9			 
48e9 eb					ex de, hl 
48ea 36 00				ld (hl), 0 
48ec 23					inc hl 
48ed 36 00				ld (hl), 0 
48ef			 
48ef				 
48ef					 
48ef 21 f6 f0				ld hl, scratch 
48f2			 
48f2					if DEBUG_FORTH_WORDS 
48f2						DMARK "MNx" 
48f2 f5				push af  
48f3 3a 07 49			ld a, (.dmark)  
48f6 32 a0 fd			ld (debug_mark),a  
48f9 3a 08 49			ld a, (.dmark+1)  
48fc 32 a1 fd			ld (debug_mark+1),a  
48ff 3a 09 49			ld a, (.dmark+2)  
4902 32 a2 fd			ld (debug_mark+2),a  
4905 18 03			jr .pastdmark  
4907 ..			.dmark: db "MNx"  
490a f1			.pastdmark: pop af  
490b			endm  
# End of macro DMARK
490b						CALLMONITOR 
490b cd aa fd			call debug_vector  
490e				endm  
# End of macro CALLMONITOR
490e					endif 
490e			 
490e			 
490e			 
490e 3e 00				ld a, 0 
4910 cd db 0d				call menu 
4913			 
4913			 
4913 6f					ld l, a 
4914 26 00				ld h, 0 
4916			 
4916					if DEBUG_FORTH_WORDS 
4916						DMARK "MNr" 
4916 f5				push af  
4917 3a 2b 49			ld a, (.dmark)  
491a 32 a0 fd			ld (debug_mark),a  
491d 3a 2c 49			ld a, (.dmark+1)  
4920 32 a1 fd			ld (debug_mark+1),a  
4923 3a 2d 49			ld a, (.dmark+2)  
4926 32 a2 fd			ld (debug_mark+2),a  
4929 18 03			jr .pastdmark  
492b ..			.dmark: db "MNr"  
492e f1			.pastdmark: pop af  
492f			endm  
# End of macro DMARK
492f						CALLMONITOR 
492f cd aa fd			call debug_vector  
4932				endm  
# End of macro CALLMONITOR
4932					endif 
4932			 
4932 cd 48 20				call forth_push_numhl 
4935			 
4935			 
4935			 
4935			 
4935				       NEXTW 
4935 c3 38 24			jp macro_next 
4938				endm 
# End of macro NEXTW
4938			 
4938			 
4938			.ENDDISPLAY: 
4938			 
4938			; eof 
# End of file forth_words_display.asm
4938			include "forth_words_str.asm" 
4938			 
4938			; | ## String Words 
4938			 
4938			.SPLIT:   
4938			 
4938				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4938 48				db WORD_SYS_CORE+52             
4939 2d 4a			dw .PTR            
493b 06				db 5 + 1 
493c .. 00			db "SPLIT",0              
4942				endm 
# End of macro CWHEAD
4942			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
4942					if DEBUG_FORTH_WORDS_KEY 
4942						DMARK "SPT" 
4942 f5				push af  
4943 3a 57 49			ld a, (.dmark)  
4946 32 a0 fd			ld (debug_mark),a  
4949 3a 58 49			ld a, (.dmark+1)  
494c 32 a1 fd			ld (debug_mark+1),a  
494f 3a 59 49			ld a, (.dmark+2)  
4952 32 a2 fd			ld (debug_mark+2),a  
4955 18 03			jr .pastdmark  
4957 ..			.dmark: db "SPT"  
495a f1			.pastdmark: pop af  
495b			endm  
# End of macro DMARK
495b						CALLMONITOR 
495b cd aa fd			call debug_vector  
495e				endm  
# End of macro CALLMONITOR
495e					endif 
495e			 
495e					; get delim 
495e					FORTH_DSP_VALUEHL 
495e cd 4d 22			call macro_dsp_valuehl 
4961				endm 
# End of macro FORTH_DSP_VALUEHL
4961			 
4961					FORTH_DSP_POP 
4961 cd 05 23			call macro_forth_dsp_pop 
4964				endm 
# End of macro FORTH_DSP_POP
4964					 
4964			 
4964 45					ld b, l    ; move delim to b 
4965 0e 01				ld c, 1   ; count of poritions 
4967			 
4967 c5					push bc 
4968			 
4968					if DEBUG_FORTH_WORDS 
4968						DMARK "SPa" 
4968 f5				push af  
4969 3a 7d 49			ld a, (.dmark)  
496c 32 a0 fd			ld (debug_mark),a  
496f 3a 7e 49			ld a, (.dmark+1)  
4972 32 a1 fd			ld (debug_mark+1),a  
4975 3a 7f 49			ld a, (.dmark+2)  
4978 32 a2 fd			ld (debug_mark+2),a  
497b 18 03			jr .pastdmark  
497d ..			.dmark: db "SPa"  
4980 f1			.pastdmark: pop af  
4981			endm  
# End of macro DMARK
4981						CALLMONITOR 
4981 cd aa fd			call debug_vector  
4984				endm  
# End of macro CALLMONITOR
4984					endif 
4984					; get pointer to string to chop up 
4984					FORTH_DSP_VALUEHL 
4984 cd 4d 22			call macro_dsp_valuehl 
4987				endm 
# End of macro FORTH_DSP_VALUEHL
4987			 
4987			;		push hl 
4987 11 f6 f0				ld de, scratch 
498a			.spllop: 
498a c1					pop bc 
498b c5					push bc 
498c			;		pop hl 
498c					if DEBUG_FORTH_WORDS 
498c						DMARK "SPl" 
498c f5				push af  
498d 3a a1 49			ld a, (.dmark)  
4990 32 a0 fd			ld (debug_mark),a  
4993 3a a2 49			ld a, (.dmark+1)  
4996 32 a1 fd			ld (debug_mark+1),a  
4999 3a a3 49			ld a, (.dmark+2)  
499c 32 a2 fd			ld (debug_mark+2),a  
499f 18 03			jr .pastdmark  
49a1 ..			.dmark: db "SPl"  
49a4 f1			.pastdmark: pop af  
49a5			endm  
# End of macro DMARK
49a5						CALLMONITOR 
49a5 cd aa fd			call debug_vector  
49a8				endm  
# End of macro CALLMONITOR
49a8					endif 
49a8 7e					ld a, (hl) 
49a9 b8					cp b 
49aa 28 08				jr z, .splnxt 
49ac fe 00				cp 0 
49ae 28 34				jr z, .splend 
49b0 ed a0				ldi 
49b2 18 d6				jr .spllop 
49b4			 
49b4					; hit dlim 
49b4			 
49b4			.splnxt: 
49b4					if DEBUG_FORTH_WORDS 
49b4						DMARK "SPx" 
49b4 f5				push af  
49b5 3a c9 49			ld a, (.dmark)  
49b8 32 a0 fd			ld (debug_mark),a  
49bb 3a ca 49			ld a, (.dmark+1)  
49be 32 a1 fd			ld (debug_mark+1),a  
49c1 3a cb 49			ld a, (.dmark+2)  
49c4 32 a2 fd			ld (debug_mark+2),a  
49c7 18 03			jr .pastdmark  
49c9 ..			.dmark: db "SPx"  
49cc f1			.pastdmark: pop af  
49cd			endm  
# End of macro DMARK
49cd						CALLMONITOR 
49cd cd aa fd			call debug_vector  
49d0				endm  
# End of macro CALLMONITOR
49d0					endif 
49d0 3e 00				ld a, 0 
49d2 12					ld (de), a 
49d3					;ex de, hl 
49d3 e5					push hl 
49d4 21 f6 f0				ld hl, scratch 
49d7 cd b6 20				call forth_push_str 
49da e1					pop hl 
49db					;ex de, hl 
49db 23					inc hl 
49dc c1					pop bc 
49dd 0c					inc c 
49de c5					push bc 
49df 11 f6 f0				ld de, scratch 
49e2 18 a6				jr .spllop 
49e4			 
49e4			.splend:		 
49e4					if DEBUG_FORTH_WORDS 
49e4						DMARK "SPe" 
49e4 f5				push af  
49e5 3a f9 49			ld a, (.dmark)  
49e8 32 a0 fd			ld (debug_mark),a  
49eb 3a fa 49			ld a, (.dmark+1)  
49ee 32 a1 fd			ld (debug_mark+1),a  
49f1 3a fb 49			ld a, (.dmark+2)  
49f4 32 a2 fd			ld (debug_mark+2),a  
49f7 18 03			jr .pastdmark  
49f9 ..			.dmark: db "SPe"  
49fc f1			.pastdmark: pop af  
49fd			endm  
# End of macro DMARK
49fd						CALLMONITOR 
49fd cd aa fd			call debug_vector  
4a00				endm  
# End of macro CALLMONITOR
4a00					endif 
4a00 12					ld (de), a 
4a01 eb					ex de, hl 
4a02			;		push hl 
4a02 21 f6 f0				ld hl, scratch 
4a05 cd b6 20				call forth_push_str 
4a08					 
4a08					if DEBUG_FORTH_WORDS 
4a08						DMARK "SPc" 
4a08 f5				push af  
4a09 3a 1d 4a			ld a, (.dmark)  
4a0c 32 a0 fd			ld (debug_mark),a  
4a0f 3a 1e 4a			ld a, (.dmark+1)  
4a12 32 a1 fd			ld (debug_mark+1),a  
4a15 3a 1f 4a			ld a, (.dmark+2)  
4a18 32 a2 fd			ld (debug_mark+2),a  
4a1b 18 03			jr .pastdmark  
4a1d ..			.dmark: db "SPc"  
4a20 f1			.pastdmark: pop af  
4a21			endm  
# End of macro DMARK
4a21						CALLMONITOR 
4a21 cd aa fd			call debug_vector  
4a24				endm  
# End of macro CALLMONITOR
4a24					endif 
4a24			 
4a24 e1					pop hl    ; get counter from bc which has been push 
4a25 26 00				ld h, 0 
4a27			;		ld l, c 
4a27 cd 48 20				call forth_push_numhl 
4a2a			 
4a2a			 
4a2a				NEXTW 
4a2a c3 38 24			jp macro_next 
4a2d				endm 
# End of macro NEXTW
4a2d			.PTR:   
4a2d			 
4a2d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4a2d 48				db WORD_SYS_CORE+52             
4a2e 5a 4a			dw .STYPE            
4a30 04				db 3 + 1 
4a31 .. 00			db "PTR",0              
4a35				endm 
# End of macro CWHEAD
4a35			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4a35			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4a35			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4a35			 
4a35					if DEBUG_FORTH_WORDS_KEY 
4a35						DMARK "PTR" 
4a35 f5				push af  
4a36 3a 4a 4a			ld a, (.dmark)  
4a39 32 a0 fd			ld (debug_mark),a  
4a3c 3a 4b 4a			ld a, (.dmark+1)  
4a3f 32 a1 fd			ld (debug_mark+1),a  
4a42 3a 4c 4a			ld a, (.dmark+2)  
4a45 32 a2 fd			ld (debug_mark+2),a  
4a48 18 03			jr .pastdmark  
4a4a ..			.dmark: db "PTR"  
4a4d f1			.pastdmark: pop af  
4a4e			endm  
# End of macro DMARK
4a4e						CALLMONITOR 
4a4e cd aa fd			call debug_vector  
4a51				endm  
# End of macro CALLMONITOR
4a51					endif 
4a51					FORTH_DSP_VALUEHL 
4a51 cd 4d 22			call macro_dsp_valuehl 
4a54				endm 
# End of macro FORTH_DSP_VALUEHL
4a54 cd 48 20				call forth_push_numhl 
4a57			 
4a57			 
4a57					NEXTW 
4a57 c3 38 24			jp macro_next 
4a5a				endm 
# End of macro NEXTW
4a5a			.STYPE: 
4a5a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4a5a 48				db WORD_SYS_CORE+52             
4a5b a9 4a			dw .UPPER            
4a5d 06				db 5 + 1 
4a5e .. 00			db "STYPE",0              
4a64				endm 
# End of macro CWHEAD
4a64			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4a64			; | | 's' string or 'i' integer 
4a64					if DEBUG_FORTH_WORDS_KEY 
4a64						DMARK "STY" 
4a64 f5				push af  
4a65 3a 79 4a			ld a, (.dmark)  
4a68 32 a0 fd			ld (debug_mark),a  
4a6b 3a 7a 4a			ld a, (.dmark+1)  
4a6e 32 a1 fd			ld (debug_mark+1),a  
4a71 3a 7b 4a			ld a, (.dmark+2)  
4a74 32 a2 fd			ld (debug_mark+2),a  
4a77 18 03			jr .pastdmark  
4a79 ..			.dmark: db "STY"  
4a7c f1			.pastdmark: pop af  
4a7d			endm  
# End of macro DMARK
4a7d						CALLMONITOR 
4a7d cd aa fd			call debug_vector  
4a80				endm  
# End of macro CALLMONITOR
4a80					endif 
4a80					FORTH_DSP 
4a80 cd 13 22			call macro_forth_dsp 
4a83				endm 
# End of macro FORTH_DSP
4a83					;v5 FORTH_DSP_VALUE 
4a83			 
4a83 7e					ld a, (hl) 
4a84			 
4a84 f5					push af 
4a85			 
4a85			; Dont destroy TOS		FORTH_DSP_POP 
4a85			 
4a85 f1					pop af 
4a86			 
4a86 fe 01				cp DS_TYPE_STR 
4a88 28 09				jr z, .typestr 
4a8a			 
4a8a fe 02				cp DS_TYPE_INUM 
4a8c 28 0a				jr z, .typeinum 
4a8e			 
4a8e 21 a7 4a				ld hl, .tna 
4a91 18 0a				jr .tpush 
4a93			 
4a93 21 a3 4a		.typestr:	ld hl, .tstr 
4a96 18 05				jr .tpush 
4a98 21 a5 4a		.typeinum:	ld hl, .tinum 
4a9b 18 00				jr .tpush 
4a9d			 
4a9d			.tpush: 
4a9d			 
4a9d cd b6 20				call forth_push_str 
4aa0			 
4aa0					NEXTW 
4aa0 c3 38 24			jp macro_next 
4aa3				endm 
# End of macro NEXTW
4aa3 .. 00		.tstr:	db "s",0 
4aa5 .. 00		.tinum:  db "i",0 
4aa7 .. 00		.tna:   db "?", 0 
4aa9			 
4aa9			 
4aa9			.UPPER: 
4aa9				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4aa9 48				db WORD_SYS_CORE+52             
4aaa e4 4a			dw .LOWER            
4aac 06				db 5 + 1 
4aad .. 00			db "UPPER",0              
4ab3				endm 
# End of macro CWHEAD
4ab3			; | UPPER ( s -- s ) Upper case string s  | DONE 
4ab3					if DEBUG_FORTH_WORDS_KEY 
4ab3						DMARK "UPR" 
4ab3 f5				push af  
4ab4 3a c8 4a			ld a, (.dmark)  
4ab7 32 a0 fd			ld (debug_mark),a  
4aba 3a c9 4a			ld a, (.dmark+1)  
4abd 32 a1 fd			ld (debug_mark+1),a  
4ac0 3a ca 4a			ld a, (.dmark+2)  
4ac3 32 a2 fd			ld (debug_mark+2),a  
4ac6 18 03			jr .pastdmark  
4ac8 ..			.dmark: db "UPR"  
4acb f1			.pastdmark: pop af  
4acc			endm  
# End of macro DMARK
4acc						CALLMONITOR 
4acc cd aa fd			call debug_vector  
4acf				endm  
# End of macro CALLMONITOR
4acf					endif 
4acf			 
4acf					FORTH_DSP 
4acf cd 13 22			call macro_forth_dsp 
4ad2				endm 
# End of macro FORTH_DSP
4ad2					 
4ad2			; TODO check is string type 
4ad2			 
4ad2					FORTH_DSP_VALUEHL 
4ad2 cd 4d 22			call macro_dsp_valuehl 
4ad5				endm 
# End of macro FORTH_DSP_VALUEHL
4ad5			; get pointer to string in hl 
4ad5			 
4ad5 7e			.toup:		ld a, (hl) 
4ad6 fe 00				cp 0 
4ad8 28 07				jr z, .toupdone 
4ada			 
4ada cd 53 12				call to_upper 
4add			 
4add 77					ld (hl), a 
4ade 23					inc hl 
4adf 18 f4				jr .toup 
4ae1			 
4ae1					 
4ae1			 
4ae1			 
4ae1			; for each char convert to upper 
4ae1					 
4ae1			.toupdone: 
4ae1			 
4ae1			 
4ae1					NEXTW 
4ae1 c3 38 24			jp macro_next 
4ae4				endm 
# End of macro NEXTW
4ae4			.LOWER: 
4ae4				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4ae4 48				db WORD_SYS_CORE+52             
4ae5 1f 4b			dw .TCASE            
4ae7 06				db 5 + 1 
4ae8 .. 00			db "LOWER",0              
4aee				endm 
# End of macro CWHEAD
4aee			; | LOWER ( s -- s ) Lower case string s  | DONE 
4aee					if DEBUG_FORTH_WORDS_KEY 
4aee						DMARK "LWR" 
4aee f5				push af  
4aef 3a 03 4b			ld a, (.dmark)  
4af2 32 a0 fd			ld (debug_mark),a  
4af5 3a 04 4b			ld a, (.dmark+1)  
4af8 32 a1 fd			ld (debug_mark+1),a  
4afb 3a 05 4b			ld a, (.dmark+2)  
4afe 32 a2 fd			ld (debug_mark+2),a  
4b01 18 03			jr .pastdmark  
4b03 ..			.dmark: db "LWR"  
4b06 f1			.pastdmark: pop af  
4b07			endm  
# End of macro DMARK
4b07						CALLMONITOR 
4b07 cd aa fd			call debug_vector  
4b0a				endm  
# End of macro CALLMONITOR
4b0a					endif 
4b0a			 
4b0a					FORTH_DSP 
4b0a cd 13 22			call macro_forth_dsp 
4b0d				endm 
# End of macro FORTH_DSP
4b0d					 
4b0d			; TODO check is string type 
4b0d			 
4b0d					FORTH_DSP_VALUEHL 
4b0d cd 4d 22			call macro_dsp_valuehl 
4b10				endm 
# End of macro FORTH_DSP_VALUEHL
4b10			; get pointer to string in hl 
4b10			 
4b10 7e			.tolow:		ld a, (hl) 
4b11 fe 00				cp 0 
4b13 28 07				jr z, .tolowdone 
4b15			 
4b15 cd 5c 12				call to_lower 
4b18			 
4b18 77					ld (hl), a 
4b19 23					inc hl 
4b1a 18 f4				jr .tolow 
4b1c			 
4b1c					 
4b1c			 
4b1c			 
4b1c			; for each char convert to low 
4b1c					 
4b1c			.tolowdone: 
4b1c					NEXTW 
4b1c c3 38 24			jp macro_next 
4b1f				endm 
# End of macro NEXTW
4b1f			.TCASE: 
4b1f				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4b1f 48				db WORD_SYS_CORE+52             
4b20 55 4c			dw .SUBSTR            
4b22 06				db 5 + 1 
4b23 .. 00			db "TCASE",0              
4b29				endm 
# End of macro CWHEAD
4b29			; | TCASE ( s -- s ) Title case string s  | DONE 
4b29					if DEBUG_FORTH_WORDS_KEY 
4b29						DMARK "TCS" 
4b29 f5				push af  
4b2a 3a 3e 4b			ld a, (.dmark)  
4b2d 32 a0 fd			ld (debug_mark),a  
4b30 3a 3f 4b			ld a, (.dmark+1)  
4b33 32 a1 fd			ld (debug_mark+1),a  
4b36 3a 40 4b			ld a, (.dmark+2)  
4b39 32 a2 fd			ld (debug_mark+2),a  
4b3c 18 03			jr .pastdmark  
4b3e ..			.dmark: db "TCS"  
4b41 f1			.pastdmark: pop af  
4b42			endm  
# End of macro DMARK
4b42						CALLMONITOR 
4b42 cd aa fd			call debug_vector  
4b45				endm  
# End of macro CALLMONITOR
4b45					endif 
4b45			 
4b45					FORTH_DSP 
4b45 cd 13 22			call macro_forth_dsp 
4b48				endm 
# End of macro FORTH_DSP
4b48					 
4b48			; TODO check is string type 
4b48			 
4b48					FORTH_DSP_VALUEHL 
4b48 cd 4d 22			call macro_dsp_valuehl 
4b4b				endm 
# End of macro FORTH_DSP_VALUEHL
4b4b			; get pointer to string in hl 
4b4b			 
4b4b					if DEBUG_FORTH_WORDS 
4b4b						DMARK "TC1" 
4b4b f5				push af  
4b4c 3a 60 4b			ld a, (.dmark)  
4b4f 32 a0 fd			ld (debug_mark),a  
4b52 3a 61 4b			ld a, (.dmark+1)  
4b55 32 a1 fd			ld (debug_mark+1),a  
4b58 3a 62 4b			ld a, (.dmark+2)  
4b5b 32 a2 fd			ld (debug_mark+2),a  
4b5e 18 03			jr .pastdmark  
4b60 ..			.dmark: db "TC1"  
4b63 f1			.pastdmark: pop af  
4b64			endm  
# End of macro DMARK
4b64						CALLMONITOR 
4b64 cd aa fd			call debug_vector  
4b67				endm  
# End of macro CALLMONITOR
4b67					endif 
4b67			 
4b67					; first time in turn to upper case first char 
4b67			 
4b67 7e					ld a, (hl) 
4b68 c3 f2 4b				jp .totsiptou 
4b6b			 
4b6b			 
4b6b 7e			.tot:		ld a, (hl) 
4b6c fe 00				cp 0 
4b6e ca 36 4c				jp z, .totdone 
4b71			 
4b71					if DEBUG_FORTH_WORDS 
4b71						DMARK "TC2" 
4b71 f5				push af  
4b72 3a 86 4b			ld a, (.dmark)  
4b75 32 a0 fd			ld (debug_mark),a  
4b78 3a 87 4b			ld a, (.dmark+1)  
4b7b 32 a1 fd			ld (debug_mark+1),a  
4b7e 3a 88 4b			ld a, (.dmark+2)  
4b81 32 a2 fd			ld (debug_mark+2),a  
4b84 18 03			jr .pastdmark  
4b86 ..			.dmark: db "TC2"  
4b89 f1			.pastdmark: pop af  
4b8a			endm  
# End of macro DMARK
4b8a						CALLMONITOR 
4b8a cd aa fd			call debug_vector  
4b8d				endm  
# End of macro CALLMONITOR
4b8d					endif 
4b8d					; check to see if current char is a space 
4b8d			 
4b8d fe 20				cp ' ' 
4b8f 28 21				jr z, .totsp 
4b91 cd 5c 12				call to_lower 
4b94					if DEBUG_FORTH_WORDS 
4b94						DMARK "TC3" 
4b94 f5				push af  
4b95 3a a9 4b			ld a, (.dmark)  
4b98 32 a0 fd			ld (debug_mark),a  
4b9b 3a aa 4b			ld a, (.dmark+1)  
4b9e 32 a1 fd			ld (debug_mark+1),a  
4ba1 3a ab 4b			ld a, (.dmark+2)  
4ba4 32 a2 fd			ld (debug_mark+2),a  
4ba7 18 03			jr .pastdmark  
4ba9 ..			.dmark: db "TC3"  
4bac f1			.pastdmark: pop af  
4bad			endm  
# End of macro DMARK
4bad						CALLMONITOR 
4bad cd aa fd			call debug_vector  
4bb0				endm  
# End of macro CALLMONITOR
4bb0					endif 
4bb0 18 63				jr .totnxt 
4bb2			 
4bb2			.totsp:         ; on a space, find next char which should be upper 
4bb2			 
4bb2					if DEBUG_FORTH_WORDS 
4bb2						DMARK "TC4" 
4bb2 f5				push af  
4bb3 3a c7 4b			ld a, (.dmark)  
4bb6 32 a0 fd			ld (debug_mark),a  
4bb9 3a c8 4b			ld a, (.dmark+1)  
4bbc 32 a1 fd			ld (debug_mark+1),a  
4bbf 3a c9 4b			ld a, (.dmark+2)  
4bc2 32 a2 fd			ld (debug_mark+2),a  
4bc5 18 03			jr .pastdmark  
4bc7 ..			.dmark: db "TC4"  
4bca f1			.pastdmark: pop af  
4bcb			endm  
# End of macro DMARK
4bcb						CALLMONITOR 
4bcb cd aa fd			call debug_vector  
4bce				endm  
# End of macro CALLMONITOR
4bce					endif 
4bce					;; 
4bce			 
4bce fe 20				cp ' ' 
4bd0 20 20				jr nz, .totsiptou 
4bd2 23					inc hl 
4bd3 7e					ld a, (hl) 
4bd4					if DEBUG_FORTH_WORDS 
4bd4						DMARK "TC5" 
4bd4 f5				push af  
4bd5 3a e9 4b			ld a, (.dmark)  
4bd8 32 a0 fd			ld (debug_mark),a  
4bdb 3a ea 4b			ld a, (.dmark+1)  
4bde 32 a1 fd			ld (debug_mark+1),a  
4be1 3a eb 4b			ld a, (.dmark+2)  
4be4 32 a2 fd			ld (debug_mark+2),a  
4be7 18 03			jr .pastdmark  
4be9 ..			.dmark: db "TC5"  
4bec f1			.pastdmark: pop af  
4bed			endm  
# End of macro DMARK
4bed						CALLMONITOR 
4bed cd aa fd			call debug_vector  
4bf0				endm  
# End of macro CALLMONITOR
4bf0					endif 
4bf0 18 c0				jr .totsp 
4bf2 fe 00		.totsiptou:    cp 0 
4bf4 28 40				jr z, .totdone 
4bf6					; not space and not zero term so upper case it 
4bf6 cd 53 12				call to_upper 
4bf9			 
4bf9					if DEBUG_FORTH_WORDS 
4bf9						DMARK "TC6" 
4bf9 f5				push af  
4bfa 3a 0e 4c			ld a, (.dmark)  
4bfd 32 a0 fd			ld (debug_mark),a  
4c00 3a 0f 4c			ld a, (.dmark+1)  
4c03 32 a1 fd			ld (debug_mark+1),a  
4c06 3a 10 4c			ld a, (.dmark+2)  
4c09 32 a2 fd			ld (debug_mark+2),a  
4c0c 18 03			jr .pastdmark  
4c0e ..			.dmark: db "TC6"  
4c11 f1			.pastdmark: pop af  
4c12			endm  
# End of macro DMARK
4c12						CALLMONITOR 
4c12 cd aa fd			call debug_vector  
4c15				endm  
# End of macro CALLMONITOR
4c15					endif 
4c15			 
4c15			 
4c15			.totnxt: 
4c15			 
4c15 77					ld (hl), a 
4c16 23					inc hl 
4c17					if DEBUG_FORTH_WORDS 
4c17						DMARK "TC7" 
4c17 f5				push af  
4c18 3a 2c 4c			ld a, (.dmark)  
4c1b 32 a0 fd			ld (debug_mark),a  
4c1e 3a 2d 4c			ld a, (.dmark+1)  
4c21 32 a1 fd			ld (debug_mark+1),a  
4c24 3a 2e 4c			ld a, (.dmark+2)  
4c27 32 a2 fd			ld (debug_mark+2),a  
4c2a 18 03			jr .pastdmark  
4c2c ..			.dmark: db "TC7"  
4c2f f1			.pastdmark: pop af  
4c30			endm  
# End of macro DMARK
4c30						CALLMONITOR 
4c30 cd aa fd			call debug_vector  
4c33				endm  
# End of macro CALLMONITOR
4c33					endif 
4c33 c3 6b 4b				jp .tot 
4c36			 
4c36					 
4c36			 
4c36			 
4c36			; for each char convert to low 
4c36					 
4c36			.totdone: 
4c36					if DEBUG_FORTH_WORDS 
4c36						DMARK "TCd" 
4c36 f5				push af  
4c37 3a 4b 4c			ld a, (.dmark)  
4c3a 32 a0 fd			ld (debug_mark),a  
4c3d 3a 4c 4c			ld a, (.dmark+1)  
4c40 32 a1 fd			ld (debug_mark+1),a  
4c43 3a 4d 4c			ld a, (.dmark+2)  
4c46 32 a2 fd			ld (debug_mark+2),a  
4c49 18 03			jr .pastdmark  
4c4b ..			.dmark: db "TCd"  
4c4e f1			.pastdmark: pop af  
4c4f			endm  
# End of macro DMARK
4c4f						CALLMONITOR 
4c4f cd aa fd			call debug_vector  
4c52				endm  
# End of macro CALLMONITOR
4c52					endif 
4c52					NEXTW 
4c52 c3 38 24			jp macro_next 
4c55				endm 
# End of macro NEXTW
4c55			 
4c55			.SUBSTR: 
4c55				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4c55 48				db WORD_SYS_CORE+52             
4c56 b3 4c			dw .LEFT            
4c58 07				db 6 + 1 
4c59 .. 00			db "SUBSTR",0              
4c60				endm 
# End of macro CWHEAD
4c60			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4c60			 
4c60					if DEBUG_FORTH_WORDS_KEY 
4c60						DMARK "SST" 
4c60 f5				push af  
4c61 3a 75 4c			ld a, (.dmark)  
4c64 32 a0 fd			ld (debug_mark),a  
4c67 3a 76 4c			ld a, (.dmark+1)  
4c6a 32 a1 fd			ld (debug_mark+1),a  
4c6d 3a 77 4c			ld a, (.dmark+2)  
4c70 32 a2 fd			ld (debug_mark+2),a  
4c73 18 03			jr .pastdmark  
4c75 ..			.dmark: db "SST"  
4c78 f1			.pastdmark: pop af  
4c79			endm  
# End of macro DMARK
4c79						CALLMONITOR 
4c79 cd aa fd			call debug_vector  
4c7c				endm  
# End of macro CALLMONITOR
4c7c					endif 
4c7c			; TODO check string type 
4c7c					FORTH_DSP_VALUEHL 
4c7c cd 4d 22			call macro_dsp_valuehl 
4c7f				endm 
# End of macro FORTH_DSP_VALUEHL
4c7f			 
4c7f e5					push hl      ; string length 
4c80			 
4c80					FORTH_DSP_POP 
4c80 cd 05 23			call macro_forth_dsp_pop 
4c83				endm 
# End of macro FORTH_DSP_POP
4c83			 
4c83					FORTH_DSP_VALUEHL 
4c83 cd 4d 22			call macro_dsp_valuehl 
4c86				endm 
# End of macro FORTH_DSP_VALUEHL
4c86			 
4c86 e5					push hl     ; start char 
4c87			 
4c87					FORTH_DSP_POP 
4c87 cd 05 23			call macro_forth_dsp_pop 
4c8a				endm 
# End of macro FORTH_DSP_POP
4c8a			 
4c8a			 
4c8a					FORTH_DSP_VALUE 
4c8a cd 36 22			call macro_forth_dsp_value 
4c8d				endm 
# End of macro FORTH_DSP_VALUE
4c8d			 
4c8d d1					pop de    ; get start post offset 
4c8e			 
4c8e 19					add hl, de    ; starting offset 
4c8f			 
4c8f c1					pop bc 
4c90 c5					push bc      ; grab size of string 
4c91			 
4c91 e5					push hl    ; save string start  
4c92			 
4c92 26 00				ld h, 0 
4c94 69					ld l, c 
4c95 23					inc hl 
4c96 23					inc hl 
4c97			 
4c97 cd b9 13				call malloc 
4c9a				if DEBUG_FORTH_MALLOC_GUARD 
4c9a cc 43 63				call z,malloc_error 
4c9d				endif 
4c9d			 
4c9d eb					ex de, hl      ; save malloc area for string copy 
4c9e e1					pop hl    ; get back source 
4c9f c1					pop bc    ; get length of string back 
4ca0			 
4ca0 d5					push de    ; save malloc area for after we push 
4ca1 ed b0				ldir     ; copy substr 
4ca3			 
4ca3			 
4ca3 eb					ex de, hl 
4ca4 3e 00				ld a, 0 
4ca6 77					ld (hl), a   ; term substr 
4ca7			 
4ca7					 
4ca7 e1					pop hl    ; get malloc so we can push it 
4ca8 e5					push hl   ; save so we can free it afterwards 
4ca9			 
4ca9 cd b6 20				call forth_push_str 
4cac			 
4cac e1					pop hl 
4cad cd 83 14				call free 
4cb0			 
4cb0					 
4cb0					 
4cb0			 
4cb0			 
4cb0					NEXTW 
4cb0 c3 38 24			jp macro_next 
4cb3				endm 
# End of macro NEXTW
4cb3			 
4cb3			.LEFT: 
4cb3				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4cb3 48				db WORD_SYS_CORE+52             
4cb4 f4 4c			dw .RIGHT            
4cb6 05				db 4 + 1 
4cb7 .. 00			db "LEFT",0              
4cbc				endm 
# End of macro CWHEAD
4cbc			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4cbc					if DEBUG_FORTH_WORDS_KEY 
4cbc						DMARK "LEF" 
4cbc f5				push af  
4cbd 3a d1 4c			ld a, (.dmark)  
4cc0 32 a0 fd			ld (debug_mark),a  
4cc3 3a d2 4c			ld a, (.dmark+1)  
4cc6 32 a1 fd			ld (debug_mark+1),a  
4cc9 3a d3 4c			ld a, (.dmark+2)  
4ccc 32 a2 fd			ld (debug_mark+2),a  
4ccf 18 03			jr .pastdmark  
4cd1 ..			.dmark: db "LEF"  
4cd4 f1			.pastdmark: pop af  
4cd5			endm  
# End of macro DMARK
4cd5						CALLMONITOR 
4cd5 cd aa fd			call debug_vector  
4cd8				endm  
# End of macro CALLMONITOR
4cd8					endif 
4cd8			 
4cd8					 
4cd8			; TODO check string type 
4cd8					FORTH_DSP_VALUEHL 
4cd8 cd 4d 22			call macro_dsp_valuehl 
4cdb				endm 
# End of macro FORTH_DSP_VALUEHL
4cdb			 
4cdb e5					push hl      ; string length 
4cdc			 
4cdc					FORTH_DSP_POP 
4cdc cd 05 23			call macro_forth_dsp_pop 
4cdf				endm 
# End of macro FORTH_DSP_POP
4cdf			 
4cdf					FORTH_DSP_VALUEHL 
4cdf cd 4d 22			call macro_dsp_valuehl 
4ce2				endm 
# End of macro FORTH_DSP_VALUEHL
4ce2			 
4ce2 c1					pop bc 
4ce3			 
4ce3 11 f6 f0				ld de, scratch 
4ce6 ed b0				ldir 
4ce8 3e 00				ld a, 0 
4cea 12					ld (de), a 
4ceb					 
4ceb 21 f6 f0				ld hl, scratch 
4cee cd b6 20				call forth_push_str 
4cf1			 
4cf1					NEXTW 
4cf1 c3 38 24			jp macro_next 
4cf4				endm 
# End of macro NEXTW
4cf4			.RIGHT: 
4cf4				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4cf4 48				db WORD_SYS_CORE+52             
4cf5 b2 4d			dw .STR2NUM            
4cf7 06				db 5 + 1 
4cf8 .. 00			db "RIGHT",0              
4cfe				endm 
# End of macro CWHEAD
4cfe			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4cfe					if DEBUG_FORTH_WORDS_KEY 
4cfe						DMARK "RIG" 
4cfe f5				push af  
4cff 3a 13 4d			ld a, (.dmark)  
4d02 32 a0 fd			ld (debug_mark),a  
4d05 3a 14 4d			ld a, (.dmark+1)  
4d08 32 a1 fd			ld (debug_mark+1),a  
4d0b 3a 15 4d			ld a, (.dmark+2)  
4d0e 32 a2 fd			ld (debug_mark+2),a  
4d11 18 03			jr .pastdmark  
4d13 ..			.dmark: db "RIG"  
4d16 f1			.pastdmark: pop af  
4d17			endm  
# End of macro DMARK
4d17						CALLMONITOR 
4d17 cd aa fd			call debug_vector  
4d1a				endm  
# End of macro CALLMONITOR
4d1a					endif 
4d1a			 
4d1a			; TODO check string type 
4d1a					FORTH_DSP_VALUEHL 
4d1a cd 4d 22			call macro_dsp_valuehl 
4d1d				endm 
# End of macro FORTH_DSP_VALUEHL
4d1d			 
4d1d e5					push hl      ; string length 
4d1e			 
4d1e					FORTH_DSP_POP 
4d1e cd 05 23			call macro_forth_dsp_pop 
4d21				endm 
# End of macro FORTH_DSP_POP
4d21			 
4d21					FORTH_DSP_VALUEHL 
4d21 cd 4d 22			call macro_dsp_valuehl 
4d24				endm 
# End of macro FORTH_DSP_VALUEHL
4d24			 
4d24					if DEBUG_FORTH_WORDS 
4d24						DMARK "RI1" 
4d24 f5				push af  
4d25 3a 39 4d			ld a, (.dmark)  
4d28 32 a0 fd			ld (debug_mark),a  
4d2b 3a 3a 4d			ld a, (.dmark+1)  
4d2e 32 a1 fd			ld (debug_mark+1),a  
4d31 3a 3b 4d			ld a, (.dmark+2)  
4d34 32 a2 fd			ld (debug_mark+2),a  
4d37 18 03			jr .pastdmark  
4d39 ..			.dmark: db "RI1"  
4d3c f1			.pastdmark: pop af  
4d3d			endm  
# End of macro DMARK
4d3d						CALLMONITOR 
4d3d cd aa fd			call debug_vector  
4d40				endm  
# End of macro CALLMONITOR
4d40					endif 
4d40					; from the pointer to string get to the end of string 
4d40			 
4d40 01 ff 00				ld bc, 255 
4d43 3e 00				ld a, 0 
4d45 ed b1				cpir 
4d47 2b					dec hl 
4d48			 
4d48					;  
4d48			 
4d48					if DEBUG_FORTH_WORDS 
4d48						DMARK "RI2" 
4d48 f5				push af  
4d49 3a 5d 4d			ld a, (.dmark)  
4d4c 32 a0 fd			ld (debug_mark),a  
4d4f 3a 5e 4d			ld a, (.dmark+1)  
4d52 32 a1 fd			ld (debug_mark+1),a  
4d55 3a 5f 4d			ld a, (.dmark+2)  
4d58 32 a2 fd			ld (debug_mark+2),a  
4d5b 18 03			jr .pastdmark  
4d5d ..			.dmark: db "RI2"  
4d60 f1			.pastdmark: pop af  
4d61			endm  
# End of macro DMARK
4d61						CALLMONITOR 
4d61 cd aa fd			call debug_vector  
4d64				endm  
# End of macro CALLMONITOR
4d64					endif 
4d64			 
4d64 c1					pop bc    ;  length of string to copy 
4d65			 
4d65 79					ld a, c 
4d66 eb					ex de, hl 
4d67 21 f6 f0				ld hl, scratch  
4d6a cd de 0f				call addatohl 
4d6d			 
4d6d eb					ex de, hl 
4d6e			 
4d6e					if DEBUG_FORTH_WORDS 
4d6e						DMARK "RI3" 
4d6e f5				push af  
4d6f 3a 83 4d			ld a, (.dmark)  
4d72 32 a0 fd			ld (debug_mark),a  
4d75 3a 84 4d			ld a, (.dmark+1)  
4d78 32 a1 fd			ld (debug_mark+1),a  
4d7b 3a 85 4d			ld a, (.dmark+2)  
4d7e 32 a2 fd			ld (debug_mark+2),a  
4d81 18 03			jr .pastdmark  
4d83 ..			.dmark: db "RI3"  
4d86 f1			.pastdmark: pop af  
4d87			endm  
# End of macro DMARK
4d87						CALLMONITOR 
4d87 cd aa fd			call debug_vector  
4d8a				endm  
# End of macro CALLMONITOR
4d8a					endif 
4d8a			 
4d8a 03					inc bc 
4d8b ed b8				lddr 
4d8d					 
4d8d 21 f6 f0				ld hl, scratch 
4d90					if DEBUG_FORTH_WORDS 
4d90						DMARK "RI4" 
4d90 f5				push af  
4d91 3a a5 4d			ld a, (.dmark)  
4d94 32 a0 fd			ld (debug_mark),a  
4d97 3a a6 4d			ld a, (.dmark+1)  
4d9a 32 a1 fd			ld (debug_mark+1),a  
4d9d 3a a7 4d			ld a, (.dmark+2)  
4da0 32 a2 fd			ld (debug_mark+2),a  
4da3 18 03			jr .pastdmark  
4da5 ..			.dmark: db "RI4"  
4da8 f1			.pastdmark: pop af  
4da9			endm  
# End of macro DMARK
4da9						CALLMONITOR 
4da9 cd aa fd			call debug_vector  
4dac				endm  
# End of macro CALLMONITOR
4dac					endif 
4dac cd b6 20				call forth_push_str 
4daf			 
4daf			 
4daf					NEXTW 
4daf c3 38 24			jp macro_next 
4db2				endm 
# End of macro NEXTW
4db2			 
4db2			 
4db2			.STR2NUM: 
4db2				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4db2 48				db WORD_SYS_CORE+52             
4db3 3e 4e			dw .NUM2STR            
4db5 08				db 7 + 1 
4db6 .. 00			db "STR2NUM",0              
4dbe				endm 
# End of macro CWHEAD
4dbe			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4dbe			 
4dbe			 
4dbe			; TODO STR type check to do 
4dbe					if DEBUG_FORTH_WORDS_KEY 
4dbe						DMARK "S2N" 
4dbe f5				push af  
4dbf 3a d3 4d			ld a, (.dmark)  
4dc2 32 a0 fd			ld (debug_mark),a  
4dc5 3a d4 4d			ld a, (.dmark+1)  
4dc8 32 a1 fd			ld (debug_mark+1),a  
4dcb 3a d5 4d			ld a, (.dmark+2)  
4dce 32 a2 fd			ld (debug_mark+2),a  
4dd1 18 03			jr .pastdmark  
4dd3 ..			.dmark: db "S2N"  
4dd6 f1			.pastdmark: pop af  
4dd7			endm  
# End of macro DMARK
4dd7						CALLMONITOR 
4dd7 cd aa fd			call debug_vector  
4dda				endm  
# End of macro CALLMONITOR
4dda					endif 
4dda			 
4dda					;FORTH_DSP 
4dda					FORTH_DSP_VALUE 
4dda cd 36 22			call macro_forth_dsp_value 
4ddd				endm 
# End of macro FORTH_DSP_VALUE
4ddd					;inc hl 
4ddd			 
4ddd eb					ex de, hl 
4dde					if DEBUG_FORTH_WORDS 
4dde						DMARK "S2a" 
4dde f5				push af  
4ddf 3a f3 4d			ld a, (.dmark)  
4de2 32 a0 fd			ld (debug_mark),a  
4de5 3a f4 4d			ld a, (.dmark+1)  
4de8 32 a1 fd			ld (debug_mark+1),a  
4deb 3a f5 4d			ld a, (.dmark+2)  
4dee 32 a2 fd			ld (debug_mark+2),a  
4df1 18 03			jr .pastdmark  
4df3 ..			.dmark: db "S2a"  
4df6 f1			.pastdmark: pop af  
4df7			endm  
# End of macro DMARK
4df7						CALLMONITOR 
4df7 cd aa fd			call debug_vector  
4dfa				endm  
# End of macro CALLMONITOR
4dfa					endif 
4dfa cd db 12				call string_to_uint16 
4dfd			 
4dfd					if DEBUG_FORTH_WORDS 
4dfd						DMARK "S2b" 
4dfd f5				push af  
4dfe 3a 12 4e			ld a, (.dmark)  
4e01 32 a0 fd			ld (debug_mark),a  
4e04 3a 13 4e			ld a, (.dmark+1)  
4e07 32 a1 fd			ld (debug_mark+1),a  
4e0a 3a 14 4e			ld a, (.dmark+2)  
4e0d 32 a2 fd			ld (debug_mark+2),a  
4e10 18 03			jr .pastdmark  
4e12 ..			.dmark: db "S2b"  
4e15 f1			.pastdmark: pop af  
4e16			endm  
# End of macro DMARK
4e16						CALLMONITOR 
4e16 cd aa fd			call debug_vector  
4e19				endm  
# End of macro CALLMONITOR
4e19					endif 
4e19			;		push hl 
4e19					FORTH_DSP_POP 
4e19 cd 05 23			call macro_forth_dsp_pop 
4e1c				endm 
# End of macro FORTH_DSP_POP
4e1c			;		pop hl 
4e1c					 
4e1c					if DEBUG_FORTH_WORDS 
4e1c						DMARK "S2b" 
4e1c f5				push af  
4e1d 3a 31 4e			ld a, (.dmark)  
4e20 32 a0 fd			ld (debug_mark),a  
4e23 3a 32 4e			ld a, (.dmark+1)  
4e26 32 a1 fd			ld (debug_mark+1),a  
4e29 3a 33 4e			ld a, (.dmark+2)  
4e2c 32 a2 fd			ld (debug_mark+2),a  
4e2f 18 03			jr .pastdmark  
4e31 ..			.dmark: db "S2b"  
4e34 f1			.pastdmark: pop af  
4e35			endm  
# End of macro DMARK
4e35						CALLMONITOR 
4e35 cd aa fd			call debug_vector  
4e38				endm  
# End of macro CALLMONITOR
4e38					endif 
4e38 cd 48 20				call forth_push_numhl	 
4e3b			 
4e3b				 
4e3b				       NEXTW 
4e3b c3 38 24			jp macro_next 
4e3e				endm 
# End of macro NEXTW
4e3e			.NUM2STR: 
4e3e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4e3e 48				db WORD_SYS_CORE+52             
4e3f d0 4e			dw .CONCAT            
4e41 08				db 7 + 1 
4e42 .. 00			db "NUM2STR",0              
4e4a				endm 
# End of macro CWHEAD
4e4a			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4e4a			 
4e4a			;		; malloc a string to target 
4e4a			;		ld hl, 10     ; TODO max string size should be fine 
4e4a			;		call malloc 
4e4a			;		push hl    ; save malloc location 
4e4a			; 
4e4a			; 
4e4a			;; TODO check int type 
4e4a					if DEBUG_FORTH_WORDS_KEY 
4e4a						DMARK "N2S" 
4e4a f5				push af  
4e4b 3a 5f 4e			ld a, (.dmark)  
4e4e 32 a0 fd			ld (debug_mark),a  
4e51 3a 60 4e			ld a, (.dmark+1)  
4e54 32 a1 fd			ld (debug_mark+1),a  
4e57 3a 61 4e			ld a, (.dmark+2)  
4e5a 32 a2 fd			ld (debug_mark+2),a  
4e5d 18 03			jr .pastdmark  
4e5f ..			.dmark: db "N2S"  
4e62 f1			.pastdmark: pop af  
4e63			endm  
# End of macro DMARK
4e63						CALLMONITOR 
4e63 cd aa fd			call debug_vector  
4e66				endm  
# End of macro CALLMONITOR
4e66					endif 
4e66			 
4e66					FORTH_DSP_VALUEHL 
4e66 cd 4d 22			call macro_dsp_valuehl 
4e69				endm 
# End of macro FORTH_DSP_VALUEHL
4e69			 
4e69					if DEBUG_FORTH_WORDS 
4e69						DMARK "NS1" 
4e69 f5				push af  
4e6a 3a 7e 4e			ld a, (.dmark)  
4e6d 32 a0 fd			ld (debug_mark),a  
4e70 3a 7f 4e			ld a, (.dmark+1)  
4e73 32 a1 fd			ld (debug_mark+1),a  
4e76 3a 80 4e			ld a, (.dmark+2)  
4e79 32 a2 fd			ld (debug_mark+2),a  
4e7c 18 03			jr .pastdmark  
4e7e ..			.dmark: db "NS1"  
4e81 f1			.pastdmark: pop af  
4e82			endm  
# End of macro DMARK
4e82						CALLMONITOR 
4e82 cd aa fd			call debug_vector  
4e85				endm  
# End of macro CALLMONITOR
4e85					endif 
4e85					FORTH_DSP_POP 
4e85 cd 05 23			call macro_forth_dsp_pop 
4e88				endm 
# End of macro FORTH_DSP_POP
4e88			 
4e88 eb					ex de, hl 
4e89 21 f6 f0				ld hl, scratch 
4e8c					if DEBUG_FORTH_WORDS 
4e8c						DMARK "NS2" 
4e8c f5				push af  
4e8d 3a a1 4e			ld a, (.dmark)  
4e90 32 a0 fd			ld (debug_mark),a  
4e93 3a a2 4e			ld a, (.dmark+1)  
4e96 32 a1 fd			ld (debug_mark+1),a  
4e99 3a a3 4e			ld a, (.dmark+2)  
4e9c 32 a2 fd			ld (debug_mark+2),a  
4e9f 18 03			jr .pastdmark  
4ea1 ..			.dmark: db "NS2"  
4ea4 f1			.pastdmark: pop af  
4ea5			endm  
# End of macro DMARK
4ea5						CALLMONITOR 
4ea5 cd aa fd			call debug_vector  
4ea8				endm  
# End of macro CALLMONITOR
4ea8					endif 
4ea8 cd f3 12				call uitoa_16 
4eab 21 f6 f0				ld hl, scratch 
4eae					if DEBUG_FORTH_WORDS 
4eae						DMARK "NS3" 
4eae f5				push af  
4eaf 3a c3 4e			ld a, (.dmark)  
4eb2 32 a0 fd			ld (debug_mark),a  
4eb5 3a c4 4e			ld a, (.dmark+1)  
4eb8 32 a1 fd			ld (debug_mark+1),a  
4ebb 3a c5 4e			ld a, (.dmark+2)  
4ebe 32 a2 fd			ld (debug_mark+2),a  
4ec1 18 03			jr .pastdmark  
4ec3 ..			.dmark: db "NS3"  
4ec6 f1			.pastdmark: pop af  
4ec7			endm  
# End of macro DMARK
4ec7						CALLMONITOR 
4ec7 cd aa fd			call debug_vector  
4eca				endm  
# End of macro CALLMONITOR
4eca					endif 
4eca cd b6 20				call forth_push_str 
4ecd			;		ld a, l 
4ecd			;		call DispAToASCII   
4ecd			;;TODO need to chage above call to dump into string 
4ecd			; 
4ecd			; 
4ecd			 
4ecd				       NEXTW 
4ecd c3 38 24			jp macro_next 
4ed0				endm 
# End of macro NEXTW
4ed0			 
4ed0			.CONCAT: 
4ed0				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4ed0 48				db WORD_SYS_CORE+52             
4ed1 83 4f			dw .FIND            
4ed3 07				db 6 + 1 
4ed4 .. 00			db "CONCAT",0              
4edb				endm 
# End of macro CWHEAD
4edb			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4edb			 
4edb			; TODO check string type 
4edb			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4edb			 
4edb					if DEBUG_FORTH_WORDS_KEY 
4edb						DMARK "CON" 
4edb f5				push af  
4edc 3a f0 4e			ld a, (.dmark)  
4edf 32 a0 fd			ld (debug_mark),a  
4ee2 3a f1 4e			ld a, (.dmark+1)  
4ee5 32 a1 fd			ld (debug_mark+1),a  
4ee8 3a f2 4e			ld a, (.dmark+2)  
4eeb 32 a2 fd			ld (debug_mark+2),a  
4eee 18 03			jr .pastdmark  
4ef0 ..			.dmark: db "CON"  
4ef3 f1			.pastdmark: pop af  
4ef4			endm  
# End of macro DMARK
4ef4						CALLMONITOR 
4ef4 cd aa fd			call debug_vector  
4ef7				endm  
# End of macro CALLMONITOR
4ef7					endif 
4ef7			 
4ef7			 
4ef7					FORTH_DSP_VALUE 
4ef7 cd 36 22			call macro_forth_dsp_value 
4efa				endm 
# End of macro FORTH_DSP_VALUE
4efa e5					push hl   ; s2 
4efb			 
4efb					FORTH_DSP_POP 
4efb cd 05 23			call macro_forth_dsp_pop 
4efe				endm 
# End of macro FORTH_DSP_POP
4efe			 
4efe					FORTH_DSP_VALUE 
4efe cd 36 22			call macro_forth_dsp_value 
4f01				endm 
# End of macro FORTH_DSP_VALUE
4f01			 
4f01 e5					push hl   ; s1 
4f02			 
4f02					FORTH_DSP_POP 
4f02 cd 05 23			call macro_forth_dsp_pop 
4f05				endm 
# End of macro FORTH_DSP_POP
4f05					 
4f05			 
4f05					; copy s1 
4f05			 
4f05				 
4f05					; save ptr 
4f05 e1					pop hl  
4f06 e5					push hl 
4f07 3e 00				ld a, 0 
4f09 cd 4f 13				call strlent 
4f0c					;inc hl    ; zer0 
4f0c 06 00				ld b, 0 
4f0e 4d					ld c, l 
4f0f e1					pop hl		 
4f10 11 f6 f0				ld de, scratch	 
4f13					if DEBUG_FORTH_WORDS 
4f13						DMARK "CO1" 
4f13 f5				push af  
4f14 3a 28 4f			ld a, (.dmark)  
4f17 32 a0 fd			ld (debug_mark),a  
4f1a 3a 29 4f			ld a, (.dmark+1)  
4f1d 32 a1 fd			ld (debug_mark+1),a  
4f20 3a 2a 4f			ld a, (.dmark+2)  
4f23 32 a2 fd			ld (debug_mark+2),a  
4f26 18 03			jr .pastdmark  
4f28 ..			.dmark: db "CO1"  
4f2b f1			.pastdmark: pop af  
4f2c			endm  
# End of macro DMARK
4f2c						CALLMONITOR 
4f2c cd aa fd			call debug_vector  
4f2f				endm  
# End of macro CALLMONITOR
4f2f					endif 
4f2f ed b0				ldir 
4f31			 
4f31 e1					pop hl 
4f32 e5					push hl 
4f33 d5					push de 
4f34			 
4f34			 
4f34 3e 00				ld a, 0 
4f36 cd 4f 13				call strlent 
4f39 23					inc hl    ; zer0 
4f3a 23					inc hl 
4f3b 06 00				ld b, 0 
4f3d 4d					ld c, l 
4f3e d1					pop de 
4f3f e1					pop hl		 
4f40					if DEBUG_FORTH_WORDS 
4f40						DMARK "CO2" 
4f40 f5				push af  
4f41 3a 55 4f			ld a, (.dmark)  
4f44 32 a0 fd			ld (debug_mark),a  
4f47 3a 56 4f			ld a, (.dmark+1)  
4f4a 32 a1 fd			ld (debug_mark+1),a  
4f4d 3a 57 4f			ld a, (.dmark+2)  
4f50 32 a2 fd			ld (debug_mark+2),a  
4f53 18 03			jr .pastdmark  
4f55 ..			.dmark: db "CO2"  
4f58 f1			.pastdmark: pop af  
4f59			endm  
# End of macro DMARK
4f59						CALLMONITOR 
4f59 cd aa fd			call debug_vector  
4f5c				endm  
# End of macro CALLMONITOR
4f5c					endif 
4f5c ed b0				ldir 
4f5e			 
4f5e			 
4f5e			 
4f5e 21 f6 f0				ld hl, scratch 
4f61					if DEBUG_FORTH_WORDS 
4f61						DMARK "CO5" 
4f61 f5				push af  
4f62 3a 76 4f			ld a, (.dmark)  
4f65 32 a0 fd			ld (debug_mark),a  
4f68 3a 77 4f			ld a, (.dmark+1)  
4f6b 32 a1 fd			ld (debug_mark+1),a  
4f6e 3a 78 4f			ld a, (.dmark+2)  
4f71 32 a2 fd			ld (debug_mark+2),a  
4f74 18 03			jr .pastdmark  
4f76 ..			.dmark: db "CO5"  
4f79 f1			.pastdmark: pop af  
4f7a			endm  
# End of macro DMARK
4f7a						CALLMONITOR 
4f7a cd aa fd			call debug_vector  
4f7d				endm  
# End of macro CALLMONITOR
4f7d					endif 
4f7d			 
4f7d cd b6 20				call forth_push_str 
4f80			 
4f80			 
4f80			 
4f80			 
4f80				       NEXTW 
4f80 c3 38 24			jp macro_next 
4f83				endm 
# End of macro NEXTW
4f83			 
4f83			 
4f83			.FIND: 
4f83				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4f83 4b				db WORD_SYS_CORE+55             
4f84 41 50			dw .LEN            
4f86 05				db 4 + 1 
4f87 .. 00			db "FIND",0              
4f8c				endm 
# End of macro CWHEAD
4f8c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4f8c			 
4f8c					if DEBUG_FORTH_WORDS_KEY 
4f8c						DMARK "FND" 
4f8c f5				push af  
4f8d 3a a1 4f			ld a, (.dmark)  
4f90 32 a0 fd			ld (debug_mark),a  
4f93 3a a2 4f			ld a, (.dmark+1)  
4f96 32 a1 fd			ld (debug_mark+1),a  
4f99 3a a3 4f			ld a, (.dmark+2)  
4f9c 32 a2 fd			ld (debug_mark+2),a  
4f9f 18 03			jr .pastdmark  
4fa1 ..			.dmark: db "FND"  
4fa4 f1			.pastdmark: pop af  
4fa5			endm  
# End of macro DMARK
4fa5						CALLMONITOR 
4fa5 cd aa fd			call debug_vector  
4fa8				endm  
# End of macro CALLMONITOR
4fa8					endif 
4fa8			 
4fa8			; TODO check string type 
4fa8					FORTH_DSP_VALUE 
4fa8 cd 36 22			call macro_forth_dsp_value 
4fab				endm 
# End of macro FORTH_DSP_VALUE
4fab			 
4fab e5					push hl    
4fac 7e					ld a,(hl)    ; char to find   
4fad			; TODO change char to substr 
4fad			 
4fad f5					push af 
4fae					 
4fae			 
4fae			 
4fae					if DEBUG_FORTH_WORDS 
4fae						DMARK "FN1" 
4fae f5				push af  
4faf 3a c3 4f			ld a, (.dmark)  
4fb2 32 a0 fd			ld (debug_mark),a  
4fb5 3a c4 4f			ld a, (.dmark+1)  
4fb8 32 a1 fd			ld (debug_mark+1),a  
4fbb 3a c5 4f			ld a, (.dmark+2)  
4fbe 32 a2 fd			ld (debug_mark+2),a  
4fc1 18 03			jr .pastdmark  
4fc3 ..			.dmark: db "FN1"  
4fc6 f1			.pastdmark: pop af  
4fc7			endm  
# End of macro DMARK
4fc7						CALLMONITOR 
4fc7 cd aa fd			call debug_vector  
4fca				endm  
# End of macro CALLMONITOR
4fca					endif 
4fca			 
4fca					FORTH_DSP_POP 
4fca cd 05 23			call macro_forth_dsp_pop 
4fcd				endm 
# End of macro FORTH_DSP_POP
4fcd			 
4fcd					; string to search 
4fcd			 
4fcd					FORTH_DSP_VALUE 
4fcd cd 36 22			call macro_forth_dsp_value 
4fd0				endm 
# End of macro FORTH_DSP_VALUE
4fd0			 
4fd0 d1					pop de  ; d is char to find  
4fd1			 
4fd1					if DEBUG_FORTH_WORDS 
4fd1						DMARK "FN2" 
4fd1 f5				push af  
4fd2 3a e6 4f			ld a, (.dmark)  
4fd5 32 a0 fd			ld (debug_mark),a  
4fd8 3a e7 4f			ld a, (.dmark+1)  
4fdb 32 a1 fd			ld (debug_mark+1),a  
4fde 3a e8 4f			ld a, (.dmark+2)  
4fe1 32 a2 fd			ld (debug_mark+2),a  
4fe4 18 03			jr .pastdmark  
4fe6 ..			.dmark: db "FN2"  
4fe9 f1			.pastdmark: pop af  
4fea			endm  
# End of macro DMARK
4fea						CALLMONITOR 
4fea cd aa fd			call debug_vector  
4fed				endm  
# End of macro CALLMONITOR
4fed					endif 
4fed					 
4fed 01 00 00				ld bc, 0 
4ff0 7e			.findchar:      ld a,(hl) 
4ff1 fe 00				cp 0   		 
4ff3 28 27				jr z, .finddone     
4ff5 ba					cp d 
4ff6 28 20				jr z, .foundchar 
4ff8 03					inc bc 
4ff9 23					inc hl 
4ffa					if DEBUG_FORTH_WORDS 
4ffa						DMARK "FN3" 
4ffa f5				push af  
4ffb 3a 0f 50			ld a, (.dmark)  
4ffe 32 a0 fd			ld (debug_mark),a  
5001 3a 10 50			ld a, (.dmark+1)  
5004 32 a1 fd			ld (debug_mark+1),a  
5007 3a 11 50			ld a, (.dmark+2)  
500a 32 a2 fd			ld (debug_mark+2),a  
500d 18 03			jr .pastdmark  
500f ..			.dmark: db "FN3"  
5012 f1			.pastdmark: pop af  
5013			endm  
# End of macro DMARK
5013						CALLMONITOR 
5013 cd aa fd			call debug_vector  
5016				endm  
# End of macro CALLMONITOR
5016					endif 
5016 18 d8				jr .findchar 
5018			 
5018			 
5018 c5			.foundchar:	push bc 
5019 e1					pop hl 
501a 18 03				jr .findexit 
501c			 
501c			 
501c							 
501c			 
501c			.finddone:     ; got to end of string with no find 
501c 21 00 00				ld hl, 0 
501f			.findexit: 
501f			 
501f					if DEBUG_FORTH_WORDS 
501f						DMARK "FNd" 
501f f5				push af  
5020 3a 34 50			ld a, (.dmark)  
5023 32 a0 fd			ld (debug_mark),a  
5026 3a 35 50			ld a, (.dmark+1)  
5029 32 a1 fd			ld (debug_mark+1),a  
502c 3a 36 50			ld a, (.dmark+2)  
502f 32 a2 fd			ld (debug_mark+2),a  
5032 18 03			jr .pastdmark  
5034 ..			.dmark: db "FNd"  
5037 f1			.pastdmark: pop af  
5038			endm  
# End of macro DMARK
5038						CALLMONITOR 
5038 cd aa fd			call debug_vector  
503b				endm  
# End of macro CALLMONITOR
503b					endif 
503b cd 48 20			call forth_push_numhl 
503e			 
503e				       NEXTW 
503e c3 38 24			jp macro_next 
5041				endm 
# End of macro NEXTW
5041			 
5041			.LEN: 
5041				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
5041 4c				db WORD_SYS_CORE+56             
5042 ab 50			dw .ASC            
5044 06				db 5 + 1 
5045 .. 00			db "COUNT",0              
504b				endm 
# End of macro CWHEAD
504b			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
504b			 
504b					if DEBUG_FORTH_WORDS_KEY 
504b						DMARK "CNT" 
504b f5				push af  
504c 3a 60 50			ld a, (.dmark)  
504f 32 a0 fd			ld (debug_mark),a  
5052 3a 61 50			ld a, (.dmark+1)  
5055 32 a1 fd			ld (debug_mark+1),a  
5058 3a 62 50			ld a, (.dmark+2)  
505b 32 a2 fd			ld (debug_mark+2),a  
505e 18 03			jr .pastdmark  
5060 ..			.dmark: db "CNT"  
5063 f1			.pastdmark: pop af  
5064			endm  
# End of macro DMARK
5064						CALLMONITOR 
5064 cd aa fd			call debug_vector  
5067				endm  
# End of macro CALLMONITOR
5067					endif 
5067			; TODO check string type 
5067					FORTH_DSP_VALUE 
5067 cd 36 22			call macro_forth_dsp_value 
506a				endm 
# End of macro FORTH_DSP_VALUE
506a			 
506a			 
506a					if DEBUG_FORTH_WORDS 
506a						DMARK "CN?" 
506a f5				push af  
506b 3a 7f 50			ld a, (.dmark)  
506e 32 a0 fd			ld (debug_mark),a  
5071 3a 80 50			ld a, (.dmark+1)  
5074 32 a1 fd			ld (debug_mark+1),a  
5077 3a 81 50			ld a, (.dmark+2)  
507a 32 a2 fd			ld (debug_mark+2),a  
507d 18 03			jr .pastdmark  
507f ..			.dmark: db "CN?"  
5082 f1			.pastdmark: pop af  
5083			endm  
# End of macro DMARK
5083						CALLMONITOR 
5083 cd aa fd			call debug_vector  
5086				endm  
# End of macro CALLMONITOR
5086					endif 
5086 cd 44 13				call strlenz 
5089					if DEBUG_FORTH_WORDS 
5089						DMARK "CNl" 
5089 f5				push af  
508a 3a 9e 50			ld a, (.dmark)  
508d 32 a0 fd			ld (debug_mark),a  
5090 3a 9f 50			ld a, (.dmark+1)  
5093 32 a1 fd			ld (debug_mark+1),a  
5096 3a a0 50			ld a, (.dmark+2)  
5099 32 a2 fd			ld (debug_mark+2),a  
509c 18 03			jr .pastdmark  
509e ..			.dmark: db "CNl"  
50a1 f1			.pastdmark: pop af  
50a2			endm  
# End of macro DMARK
50a2						CALLMONITOR 
50a2 cd aa fd			call debug_vector  
50a5				endm  
# End of macro CALLMONITOR
50a5					endif 
50a5			 
50a5 cd 48 20				call forth_push_numhl 
50a8			 
50a8			 
50a8			 
50a8				       NEXTW 
50a8 c3 38 24			jp macro_next 
50ab				endm 
# End of macro NEXTW
50ab			.ASC: 
50ab				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
50ab 4d				db WORD_SYS_CORE+57             
50ac 19 51			dw .CHR            
50ae 04				db 3 + 1 
50af .. 00			db "ASC",0              
50b3				endm 
# End of macro CWHEAD
50b3			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
50b3					if DEBUG_FORTH_WORDS_KEY 
50b3						DMARK "ASC" 
50b3 f5				push af  
50b4 3a c8 50			ld a, (.dmark)  
50b7 32 a0 fd			ld (debug_mark),a  
50ba 3a c9 50			ld a, (.dmark+1)  
50bd 32 a1 fd			ld (debug_mark+1),a  
50c0 3a ca 50			ld a, (.dmark+2)  
50c3 32 a2 fd			ld (debug_mark+2),a  
50c6 18 03			jr .pastdmark  
50c8 ..			.dmark: db "ASC"  
50cb f1			.pastdmark: pop af  
50cc			endm  
# End of macro DMARK
50cc						CALLMONITOR 
50cc cd aa fd			call debug_vector  
50cf				endm  
# End of macro CALLMONITOR
50cf					endif 
50cf					FORTH_DSP_VALUE 
50cf cd 36 22			call macro_forth_dsp_value 
50d2				endm 
# End of macro FORTH_DSP_VALUE
50d2					;v5 FORTH_DSP_VALUE 
50d2			;		inc hl      ; now at start of numeric as string 
50d2			 
50d2 e5					push hl 
50d3			 
50d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d3 cd 05 23			call macro_forth_dsp_pop 
50d6				endm 
# End of macro FORTH_DSP_POP
50d6			 
50d6 e1					pop hl 
50d7			 
50d7					if DEBUG_FORTH_WORDS 
50d7						DMARK "AS1" 
50d7 f5				push af  
50d8 3a ec 50			ld a, (.dmark)  
50db 32 a0 fd			ld (debug_mark),a  
50de 3a ed 50			ld a, (.dmark+1)  
50e1 32 a1 fd			ld (debug_mark+1),a  
50e4 3a ee 50			ld a, (.dmark+2)  
50e7 32 a2 fd			ld (debug_mark+2),a  
50ea 18 03			jr .pastdmark  
50ec ..			.dmark: db "AS1"  
50ef f1			.pastdmark: pop af  
50f0			endm  
# End of macro DMARK
50f0						CALLMONITOR 
50f0 cd aa fd			call debug_vector  
50f3				endm  
# End of macro CALLMONITOR
50f3					endif 
50f3					; push the content of a onto the stack as a value 
50f3			 
50f3 7e					ld a,(hl)   ; get char 
50f4 26 00				ld h,0 
50f6 6f					ld l,a 
50f7					if DEBUG_FORTH_WORDS 
50f7						DMARK "AS2" 
50f7 f5				push af  
50f8 3a 0c 51			ld a, (.dmark)  
50fb 32 a0 fd			ld (debug_mark),a  
50fe 3a 0d 51			ld a, (.dmark+1)  
5101 32 a1 fd			ld (debug_mark+1),a  
5104 3a 0e 51			ld a, (.dmark+2)  
5107 32 a2 fd			ld (debug_mark+2),a  
510a 18 03			jr .pastdmark  
510c ..			.dmark: db "AS2"  
510f f1			.pastdmark: pop af  
5110			endm  
# End of macro DMARK
5110						CALLMONITOR 
5110 cd aa fd			call debug_vector  
5113				endm  
# End of macro CALLMONITOR
5113					endif 
5113 cd 48 20				call forth_push_numhl 
5116			 
5116				       NEXTW 
5116 c3 38 24			jp macro_next 
5119				endm 
# End of macro NEXTW
5119			 
5119			.CHR: 
5119				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
5119 4d				db WORD_SYS_CORE+57             
511a 55 51			dw .ENDSTR            
511c 04				db 3 + 1 
511d .. 00			db "CHR",0              
5121				endm 
# End of macro CWHEAD
5121			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
5121					if DEBUG_FORTH_WORDS_KEY 
5121						DMARK "CHR" 
5121 f5				push af  
5122 3a 36 51			ld a, (.dmark)  
5125 32 a0 fd			ld (debug_mark),a  
5128 3a 37 51			ld a, (.dmark+1)  
512b 32 a1 fd			ld (debug_mark+1),a  
512e 3a 38 51			ld a, (.dmark+2)  
5131 32 a2 fd			ld (debug_mark+2),a  
5134 18 03			jr .pastdmark  
5136 ..			.dmark: db "CHR"  
5139 f1			.pastdmark: pop af  
513a			endm  
# End of macro DMARK
513a						CALLMONITOR 
513a cd aa fd			call debug_vector  
513d				endm  
# End of macro CALLMONITOR
513d					endif 
513d					FORTH_DSP_VALUEHL 
513d cd 4d 22			call macro_dsp_valuehl 
5140				endm 
# End of macro FORTH_DSP_VALUEHL
5140			 
5140					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5140 cd 05 23			call macro_forth_dsp_pop 
5143				endm 
# End of macro FORTH_DSP_POP
5143			 
5143					; save asci byte as a zero term string and push string 
5143			 
5143 7d					ld a,l 
5144 32 f6 f0				ld (scratch), a 
5147			 
5147 3e 00				ld a, 0 
5149 32 f7 f0				ld (scratch+1), a 
514c			 
514c 21 f6 f0				ld hl, scratch 
514f cd b6 20				call forth_push_str 
5152			 
5152			 
5152				       NEXTW 
5152 c3 38 24			jp macro_next 
5155				endm 
# End of macro NEXTW
5155			 
5155			 
5155			 
5155			 
5155			.ENDSTR: 
5155			; eof 
5155			 
# End of file forth_words_str.asm
5155			include "forth_words_key.asm" 
5155			 
5155			; | ## Keyboard Words 
5155			 
5155			.KEY: 
5155				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
5155 3e				db WORD_SYS_CORE+42             
5156 85 51			dw .KEYDB            
5158 04				db 3 + 1 
5159 .. 00			db "KEY",0              
515d				endm 
# End of macro CWHEAD
515d			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
515d			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
515d			; | | Can use something like this to process: 
515d			; | | > repeat active . key ?dup if emit then #1 until  
515d			 
515d					if DEBUG_FORTH_WORDS_KEY 
515d						DMARK "KEY" 
515d f5				push af  
515e 3a 72 51			ld a, (.dmark)  
5161 32 a0 fd			ld (debug_mark),a  
5164 3a 73 51			ld a, (.dmark+1)  
5167 32 a1 fd			ld (debug_mark+1),a  
516a 3a 74 51			ld a, (.dmark+2)  
516d 32 a2 fd			ld (debug_mark+2),a  
5170 18 03			jr .pastdmark  
5172 ..			.dmark: db "KEY"  
5175 f1			.pastdmark: pop af  
5176			endm  
# End of macro DMARK
5176						CALLMONITOR 
5176 cd aa fd			call debug_vector  
5179				endm  
# End of macro CALLMONITOR
5179					endif 
5179			; TODO currently waits 
5179 cd 73 78				call cinndb 
517c					;call cin_wait 
517c 6f					ld l, a 
517d 26 00				ld h, 0 
517f cd 48 20				call forth_push_numhl 
5182					NEXTW 
5182 c3 38 24			jp macro_next 
5185				endm 
# End of macro NEXTW
5185			.KEYDB: 
5185				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
5185 3e				db WORD_SYS_CORE+42             
5186 b7 51			dw .WAITK            
5188 06				db 5 + 1 
5189 .. 00			db "KEYDB",0              
518f				endm 
# End of macro CWHEAD
518f			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
518f			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
518f			; | | Can use something like this to process: 
518f			; | | > repeat active . key ?dup if emit then #1 until  
518f			 
518f					if DEBUG_FORTH_WORDS_KEY 
518f						DMARK "KEB" 
518f f5				push af  
5190 3a a4 51			ld a, (.dmark)  
5193 32 a0 fd			ld (debug_mark),a  
5196 3a a5 51			ld a, (.dmark+1)  
5199 32 a1 fd			ld (debug_mark+1),a  
519c 3a a6 51			ld a, (.dmark+2)  
519f 32 a2 fd			ld (debug_mark+2),a  
51a2 18 03			jr .pastdmark  
51a4 ..			.dmark: db "KEB"  
51a7 f1			.pastdmark: pop af  
51a8			endm  
# End of macro DMARK
51a8						CALLMONITOR 
51a8 cd aa fd			call debug_vector  
51ab				endm  
# End of macro CALLMONITOR
51ab					endif 
51ab			; TODO currently waits 
51ab cd 5f 78				call cin 
51ae					;call cin_wait 
51ae 6f					ld l, a 
51af 26 00				ld h, 0 
51b1 cd 48 20				call forth_push_numhl 
51b4					NEXTW 
51b4 c3 38 24			jp macro_next 
51b7				endm 
# End of macro NEXTW
51b7			.WAITK: 
51b7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
51b7 3f				db WORD_SYS_CORE+43             
51b8 e9 51			dw .ACCEPT            
51ba 06				db 5 + 1 
51bb .. 00			db "WAITK",0              
51c1				endm 
# End of macro CWHEAD
51c1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
51c1					if DEBUG_FORTH_WORDS_KEY 
51c1						DMARK "WAI" 
51c1 f5				push af  
51c2 3a d6 51			ld a, (.dmark)  
51c5 32 a0 fd			ld (debug_mark),a  
51c8 3a d7 51			ld a, (.dmark+1)  
51cb 32 a1 fd			ld (debug_mark+1),a  
51ce 3a d8 51			ld a, (.dmark+2)  
51d1 32 a2 fd			ld (debug_mark+2),a  
51d4 18 03			jr .pastdmark  
51d6 ..			.dmark: db "WAI"  
51d9 f1			.pastdmark: pop af  
51da			endm  
# End of macro DMARK
51da						CALLMONITOR 
51da cd aa fd			call debug_vector  
51dd				endm  
# End of macro CALLMONITOR
51dd					endif 
51dd cd 4e 78				call cin_wait 
51e0 6f					ld l, a 
51e1 26 00				ld h, 0 
51e3 cd 48 20				call forth_push_numhl 
51e6					NEXTW 
51e6 c3 38 24			jp macro_next 
51e9				endm 
# End of macro NEXTW
51e9			.ACCEPT: 
51e9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
51e9 40				db WORD_SYS_CORE+44             
51ea 47 52			dw .EDIT            
51ec 07				db 6 + 1 
51ed .. 00			db "ACCEPT",0              
51f4				endm 
# End of macro CWHEAD
51f4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
51f4					; TODO crashes on push 
51f4					if DEBUG_FORTH_WORDS_KEY 
51f4						DMARK "ACC" 
51f4 f5				push af  
51f5 3a 09 52			ld a, (.dmark)  
51f8 32 a0 fd			ld (debug_mark),a  
51fb 3a 0a 52			ld a, (.dmark+1)  
51fe 32 a1 fd			ld (debug_mark+1),a  
5201 3a 0b 52			ld a, (.dmark+2)  
5204 32 a2 fd			ld (debug_mark+2),a  
5207 18 03			jr .pastdmark  
5209 ..			.dmark: db "ACC"  
520c f1			.pastdmark: pop af  
520d			endm  
# End of macro DMARK
520d						CALLMONITOR 
520d cd aa fd			call debug_vector  
5210				endm  
# End of macro CALLMONITOR
5210					endif 
5210 21 f4 f2				ld hl, os_input 
5213 3e 00				ld a, 0 
5215 77					ld (hl),a 
5216 3a 93 f9				ld a,(f_cursor_ptr) 
5219 16 64				ld d, 100 
521b 0e 00				ld c, 0 
521d 1e 28				ld e, 40 
521f cd 0b 10				call input_str 
5222					; TODO perhaps do a type check and wrap in quotes if not a number 
5222 21 f4 f2				ld hl, os_input 
5225					if DEBUG_FORTH_WORDS 
5225						DMARK "AC1" 
5225 f5				push af  
5226 3a 3a 52			ld a, (.dmark)  
5229 32 a0 fd			ld (debug_mark),a  
522c 3a 3b 52			ld a, (.dmark+1)  
522f 32 a1 fd			ld (debug_mark+1),a  
5232 3a 3c 52			ld a, (.dmark+2)  
5235 32 a2 fd			ld (debug_mark+2),a  
5238 18 03			jr .pastdmark  
523a ..			.dmark: db "AC1"  
523d f1			.pastdmark: pop af  
523e			endm  
# End of macro DMARK
523e						CALLMONITOR 
523e cd aa fd			call debug_vector  
5241				endm  
# End of macro CALLMONITOR
5241					endif 
5241 cd b6 20				call forth_push_str 
5244					NEXTW 
5244 c3 38 24			jp macro_next 
5247				endm 
# End of macro NEXTW
5247			 
5247			.EDIT: 
5247				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
5247 40				db WORD_SYS_CORE+44             
5248 e9 52			dw .DEDIT            
524a 05				db 4 + 1 
524b .. 00			db "EDIT",0              
5250				endm 
# End of macro CWHEAD
5250			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
5250			 
5250					; TODO does not copy from stack 
5250					if DEBUG_FORTH_WORDS_KEY 
5250						DMARK "EDT" 
5250 f5				push af  
5251 3a 65 52			ld a, (.dmark)  
5254 32 a0 fd			ld (debug_mark),a  
5257 3a 66 52			ld a, (.dmark+1)  
525a 32 a1 fd			ld (debug_mark+1),a  
525d 3a 67 52			ld a, (.dmark+2)  
5260 32 a2 fd			ld (debug_mark+2),a  
5263 18 03			jr .pastdmark  
5265 ..			.dmark: db "EDT"  
5268 f1			.pastdmark: pop af  
5269			endm  
# End of macro DMARK
5269						CALLMONITOR 
5269 cd aa fd			call debug_vector  
526c				endm  
# End of macro CALLMONITOR
526c					endif 
526c			 
526c					;FORTH_DSP 
526c					FORTH_DSP_VALUEHL 
526c cd 4d 22			call macro_dsp_valuehl 
526f				endm 
# End of macro FORTH_DSP_VALUEHL
526f			;		inc hl    ; TODO do type check 
526f			 
526f			;		call get_word_hl 
526f e5					push hl 
5270					if DEBUG_FORTH_WORDS 
5270						DMARK "EDp" 
5270 f5				push af  
5271 3a 85 52			ld a, (.dmark)  
5274 32 a0 fd			ld (debug_mark),a  
5277 3a 86 52			ld a, (.dmark+1)  
527a 32 a1 fd			ld (debug_mark+1),a  
527d 3a 87 52			ld a, (.dmark+2)  
5280 32 a2 fd			ld (debug_mark+2),a  
5283 18 03			jr .pastdmark  
5285 ..			.dmark: db "EDp"  
5288 f1			.pastdmark: pop af  
5289			endm  
# End of macro DMARK
5289						CALLMONITOR 
5289 cd aa fd			call debug_vector  
528c				endm  
# End of macro CALLMONITOR
528c					endif 
528c				;	ld a, 0 
528c cd 44 13				call strlenz 
528f 23					inc hl 
5290			 
5290 06 00				ld b, 0 
5292 4d					ld c, l 
5293			 
5293 e1					pop hl 
5294 11 f4 f2				ld de, os_input 
5297					if DEBUG_FORTH_WORDS_KEY 
5297						DMARK "EDc" 
5297 f5				push af  
5298 3a ac 52			ld a, (.dmark)  
529b 32 a0 fd			ld (debug_mark),a  
529e 3a ad 52			ld a, (.dmark+1)  
52a1 32 a1 fd			ld (debug_mark+1),a  
52a4 3a ae 52			ld a, (.dmark+2)  
52a7 32 a2 fd			ld (debug_mark+2),a  
52aa 18 03			jr .pastdmark  
52ac ..			.dmark: db "EDc"  
52af f1			.pastdmark: pop af  
52b0			endm  
# End of macro DMARK
52b0						CALLMONITOR 
52b0 cd aa fd			call debug_vector  
52b3				endm  
# End of macro CALLMONITOR
52b3					endif 
52b3 ed b0				ldir 
52b5			 
52b5			 
52b5 21 f4 f2				ld hl, os_input 
52b8					;ld a, 0 
52b8					;ld (hl),a 
52b8 3a 93 f9				ld a,(f_cursor_ptr) 
52bb 16 64				ld d, 100 
52bd 0e 00				ld c, 0 
52bf 1e 28				ld e, 40 
52c1 cd 0b 10				call input_str 
52c4					; TODO perhaps do a type check and wrap in quotes if not a number 
52c4 21 f4 f2				ld hl, os_input 
52c7					if DEBUG_FORTH_WORDS 
52c7						DMARK "ED1" 
52c7 f5				push af  
52c8 3a dc 52			ld a, (.dmark)  
52cb 32 a0 fd			ld (debug_mark),a  
52ce 3a dd 52			ld a, (.dmark+1)  
52d1 32 a1 fd			ld (debug_mark+1),a  
52d4 3a de 52			ld a, (.dmark+2)  
52d7 32 a2 fd			ld (debug_mark+2),a  
52da 18 03			jr .pastdmark  
52dc ..			.dmark: db "ED1"  
52df f1			.pastdmark: pop af  
52e0			endm  
# End of macro DMARK
52e0						CALLMONITOR 
52e0 cd aa fd			call debug_vector  
52e3				endm  
# End of macro CALLMONITOR
52e3					endif 
52e3 cd b6 20				call forth_push_str 
52e6					NEXTW 
52e6 c3 38 24			jp macro_next 
52e9				endm 
# End of macro NEXTW
52e9			 
52e9			.DEDIT: 
52e9				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
52e9 40				db WORD_SYS_CORE+44             
52ea 4b 53			dw .ENDKEY            
52ec 06				db 5 + 1 
52ed .. 00			db "DEDIT",0              
52f3				endm 
# End of macro CWHEAD
52f3			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
52f3			 
52f3					; TODO does not copy from stack 
52f3					if DEBUG_FORTH_WORDS_KEY 
52f3						DMARK "DED" 
52f3 f5				push af  
52f4 3a 08 53			ld a, (.dmark)  
52f7 32 a0 fd			ld (debug_mark),a  
52fa 3a 09 53			ld a, (.dmark+1)  
52fd 32 a1 fd			ld (debug_mark+1),a  
5300 3a 0a 53			ld a, (.dmark+2)  
5303 32 a2 fd			ld (debug_mark+2),a  
5306 18 03			jr .pastdmark  
5308 ..			.dmark: db "DED"  
530b f1			.pastdmark: pop af  
530c			endm  
# End of macro DMARK
530c						CALLMONITOR 
530c cd aa fd			call debug_vector  
530f				endm  
# End of macro CALLMONITOR
530f					endif 
530f			 
530f					;FORTH_DSP 
530f					FORTH_DSP_VALUEHL 
530f cd 4d 22			call macro_dsp_valuehl 
5312				endm 
# End of macro FORTH_DSP_VALUEHL
5312			;		inc hl    ; TODO do type check 
5312			 
5312			;		call get_word_hl 
5312 e5					push hl 
5313 e5					push hl 
5314					FORTH_DSP_POP 
5314 cd 05 23			call macro_forth_dsp_pop 
5317				endm 
# End of macro FORTH_DSP_POP
5317 e1					pop hl 
5318					if DEBUG_FORTH_WORDS 
5318						DMARK "EDp" 
5318 f5				push af  
5319 3a 2d 53			ld a, (.dmark)  
531c 32 a0 fd			ld (debug_mark),a  
531f 3a 2e 53			ld a, (.dmark+1)  
5322 32 a1 fd			ld (debug_mark+1),a  
5325 3a 2f 53			ld a, (.dmark+2)  
5328 32 a2 fd			ld (debug_mark+2),a  
532b 18 03			jr .pastdmark  
532d ..			.dmark: db "EDp"  
5330 f1			.pastdmark: pop af  
5331			endm  
# End of macro DMARK
5331						CALLMONITOR 
5331 cd aa fd			call debug_vector  
5334				endm  
# End of macro CALLMONITOR
5334					endif 
5334				;	ld a, 0 
5334 cd 44 13				call strlenz 
5337 23					inc hl 
5338			 
5338 06 00				ld b, 0 
533a 4d					ld c, l 
533b			 
533b e1					pop hl 
533c			 
533c					;ld a, 0 
533c					;ld (hl),a 
533c 3a 93 f9				ld a,(f_cursor_ptr) 
533f 16 64				ld d, 100 
5341 0e 00				ld c, 0 
5343 1e 28				ld e, 40 
5345 cd 0b 10				call input_str 
5348					; TODO perhaps do a type check and wrap in quotes if not a number 
5348					NEXTW 
5348 c3 38 24			jp macro_next 
534b				endm 
# End of macro NEXTW
534b			 
534b			 
534b			.ENDKEY: 
534b			; eof 
534b			 
# End of file forth_words_key.asm
534b			include "forth_words_const.asm" 
534b			 
534b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
534b			 
534b			 
534b			.SPITIME: 
534b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
534b 77				db WORD_SYS_CORE+99             
534c 60 53			dw .VA            
534e 08				db 7 + 1 
534f .. 00			db "SPITIME",0              
5357				endm 
# End of macro CWHEAD
5357			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
5357			; 
5357			; | | If using BANK devices then leave as is. 
5357			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
5357			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
5357			 
5357 21 99 f9				ld hl, spi_clktime  
535a cd 48 20				call forth_push_numhl 
535d			 
535d					NEXTW 
535d c3 38 24			jp macro_next 
5360				endm 
# End of macro NEXTW
5360			 
5360			 
5360			.VA: 
5360				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5360 77				db WORD_SYS_CORE+99             
5361 70 53			dw .SYMBOL            
5363 03				db 2 + 1 
5364 .. 00			db "VA",0              
5367				endm 
# End of macro CWHEAD
5367			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
5367 21 5d f9				ld hl, cli_var_array 
536a cd 48 20				call forth_push_numhl 
536d			 
536d					NEXTW 
536d c3 38 24			jp macro_next 
5370				endm 
# End of macro NEXTW
5370			 
5370			.SYMBOL: 
5370				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
5370 77				db WORD_SYS_CORE+99             
5371 7a 54			dw .ENDCONST            
5373 07				db 6 + 1 
5374 .. 00			db "SYMBOL",0              
537b				endm 
# End of macro CWHEAD
537b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
537b			; | 
537b			; | | The value is the number reference and the final address is pushed to stack 
537b			 
537b			; | | ``` 
537b			; | | dw sym_table 
537b			; | | dw nmi_vector 
537b			; | | dw cli_autodisplay 
537b			; | | dw cli_data_sp 
537b			; | | dw cli_data_stack 
537b			; | | dw cli_loop_sp 
537b			; | | dw cli_loop_stack 
537b			; | | dw cli_var_array 
537b			; | | dw cursor_col 
537b			; | | dw cursor_ptr 
537b			; | | ; 10 
537b			; | | dw cursor_row 
537b			; | | dw debug_mark 
537b			; | | dw display_fb0 
537b			; | | dw display_fb1 
537b			; | | dw display_fb2 
537b			; | | dw display_fb3 
537b			; | | dw display_fb_active 
537b			; | | dw execscratch 
537b			; | | dw f_cursor_ptr 
537b			; | | dw hardware_word 
537b			; | | ;20 
537b			; | | dw input_at_cursor 
537b			; | | dw input_at_pos 
537b			; | | dw input_cur_flash 
537b			; | | dw input_cur_onoff 
537b			; | | dw input_cursor 
537b			; | | dw input_display_size 
537b			; | | dw input_len 
537b			; | | dw input_ptr 
537b			; | | dw input_size 
537b			; | | dw input_start 
537b			; | | ; 30 
537b			; | | dw input_str 
537b			; | | dw input_under_cursor 
537b			; | | dw os_cli_cmd 
537b			; | | dw os_cur_ptr 
537b			; | | dw os_current_i 
537b			; | | dw os_input 
537b			; | | dw os_last_cmd 
537b			; | | dw os_last_new_uword 
537b			; | | dw debug_vector 
537b			; | | dw os_view_hl 
537b			; | | ;40 
537b			; | | dw os_word_scratch 
537b			; | | dw portbctl 
537b			; | | dw portbdata 
537b			; | | dw spi_cartdev 
537b			; | | dw spi_cartdev2 
537b			; | | dw spi_clktime 
537b			; | | dw spi_device 
537b			; | | dw spi_device_id 
537b			; | | dw spi_portbyte 
537b			; | | dw stackstore 
537b			; | | ; 50 
537b			; | | if STORAGE_SE 
537b			; | | dw storage_actl 
537b			; | | dw storage_adata 
537b			; | | else 
537b			; | | dw 0 
537b			; | | dw 0 
537b			; | | endif 
537b			; | | dw storage_append 
537b			; | | if STORAGE_SE 
537b			; | | dw storage_bctl 
537b			; | | else 
537b			; | | dw 0 
537b			; | | endif 
537b			; | | dw store_bank_active 
537b			; | | dw store_filecache 
537b			; | | dw store_longread 
537b			; | | dw store_openaddr 
537b			; | | dw store_openext 
537b			; | | dw store_openmaxext 
537b			; | | ; 60 
537b			; | | dw store_page 
537b			; | | dw store_readbuf 
537b			; | | dw store_readcont 
537b			; | | dw store_readptr 
537b			; | | dw store_tmpext 
537b			; | | dw store_tmpid 
537b			; | | dw store_tmppageid 
537b			; | | dw malloc 
537b			; | | dw free 
537b			; | | dw cin 
537b			; | | ; 70 
537b			; | | dw cin_wait 
537b			; | | dw forth_push_numhl 
537b			; | | dw forth_push_str 
537b			; | | ``` 
537b			 
537b					if DEBUG_FORTH_WORDS_KEY 
537b						DMARK "SYM" 
537b f5				push af  
537c 3a 90 53			ld a, (.dmark)  
537f 32 a0 fd			ld (debug_mark),a  
5382 3a 91 53			ld a, (.dmark+1)  
5385 32 a1 fd			ld (debug_mark+1),a  
5388 3a 92 53			ld a, (.dmark+2)  
538b 32 a2 fd			ld (debug_mark+2),a  
538e 18 03			jr .pastdmark  
5390 ..			.dmark: db "SYM"  
5393 f1			.pastdmark: pop af  
5394			endm  
# End of macro DMARK
5394						CALLMONITOR 
5394 cd aa fd			call debug_vector  
5397				endm  
# End of macro CALLMONITOR
5397					endif 
5397			 
5397					FORTH_DSP_VALUEHL 
5397 cd 4d 22			call macro_dsp_valuehl 
539a				endm 
# End of macro FORTH_DSP_VALUEHL
539a			 
539a 7d					ld a, l     
539b			 
539b			 
539b					if DEBUG_FORTH_WORDS 
539b						DMARK "SY1" 
539b f5				push af  
539c 3a b0 53			ld a, (.dmark)  
539f 32 a0 fd			ld (debug_mark),a  
53a2 3a b1 53			ld a, (.dmark+1)  
53a5 32 a1 fd			ld (debug_mark+1),a  
53a8 3a b2 53			ld a, (.dmark+2)  
53ab 32 a2 fd			ld (debug_mark+2),a  
53ae 18 03			jr .pastdmark  
53b0 ..			.dmark: db "SY1"  
53b3 f1			.pastdmark: pop af  
53b4			endm  
# End of macro DMARK
53b4						CALLMONITOR 
53b4 cd aa fd			call debug_vector  
53b7				endm  
# End of macro CALLMONITOR
53b7					endif 
53b7					 
53b7 f5					push af	 
53b8					FORTH_DSP_POP 
53b8 cd 05 23			call macro_forth_dsp_pop 
53bb				endm 
# End of macro FORTH_DSP_POP
53bb f1					pop af 
53bc			 
53bc cb 27				sla a  
53be				 
53be					 
53be					if DEBUG_FORTH_WORDS 
53be						DMARK "SY" 
53be f5				push af  
53bf 3a d3 53			ld a, (.dmark)  
53c2 32 a0 fd			ld (debug_mark),a  
53c5 3a d4 53			ld a, (.dmark+1)  
53c8 32 a1 fd			ld (debug_mark+1),a  
53cb 3a d5 53			ld a, (.dmark+2)  
53ce 32 a2 fd			ld (debug_mark+2),a  
53d1 18 02			jr .pastdmark  
53d3 ..			.dmark: db "SY"  
53d5 f1			.pastdmark: pop af  
53d6			endm  
# End of macro DMARK
53d6						CALLMONITOR 
53d6 cd aa fd			call debug_vector  
53d9				endm  
# End of macro CALLMONITOR
53d9					endif 
53d9			 
53d9 21 e8 53				ld hl, sym_table 
53dc cd de 0f				call addatohl 
53df cd ba 23				call loadwordinhl 
53e2 cd 48 20				call forth_push_numhl 
53e5			 
53e5			 
53e5				       NEXTW 
53e5 c3 38 24			jp macro_next 
53e8				endm 
# End of macro NEXTW
53e8			 
53e8			sym_table: 
53e8			 
53e8			; 0 
53e8 e8 53		dw sym_table 
53ea ad fd		dw nmi_vector 
53ec 71 f9		dw cli_autodisplay 
53ee 23 f9		dw cli_data_sp 
53f0 5d f6		dw cli_data_stack 
53f2 25 f9		dw cli_loop_sp 
53f4 5f f8		dw cli_loop_stack 
53f6 5d f9		dw cli_var_array 
53f8 fa fa		dw cursor_col 
53fa f8 fa		dw cursor_ptr 
53fc			; 10 
53fc f9 fa		dw cursor_row 
53fe a0 fd		dw debug_mark 
5400 e6 fc		dw display_fb0 
5402 45 fc		dw display_fb1 
5404 03 fb		dw display_fb2 
5406 a4 fb		dw display_fb3 
5408 01 fb		dw display_fb_active 
540a f5 f1		dw execscratch 
540c 93 f9		dw f_cursor_ptr 
540e b0 fd		dw hardware_word 
5410			;20 
5410 97 fd		dw input_at_cursor 
5412 99 fd		dw input_at_pos 
5414 95 fd		dw input_cur_flash 
5416 94 fd		dw input_cur_onoff 
5418 8a fd		dw input_cursor 
541a 9a fd		dw input_display_size 
541c 8f fd		dw input_len 
541e 9e fd		dw input_ptr 
5420 9b fd		dw input_size 
5422 9c fd		dw input_start 
5424			; 30 
5424 0b 10		dw input_str 
5426 98 fd		dw input_under_cursor 
5428 1d f4		dw os_cli_cmd 
542a 19 f4		dw os_cur_ptr 
542c 1b f4		dw os_current_i 
542e f4 f2		dw os_input 
5430 1c f5		dw os_last_cmd 
5432 f3 f3		dw os_last_new_uword 
5434 aa fd		dw debug_vector 
5436 d8 f0		dw os_view_hl 
5438			;40 
5438 fb f3		dw os_word_scratch 
543a c3 00		dw portbctl 
543c c1 00		dw portbdata 
543e 98 f9		dw spi_cartdev 
5440 97 f9		dw spi_cartdev2 
5442 99 f9		dw spi_clktime 
5444 95 f9		dw spi_device 
5446 94 f9		dw spi_device_id 
5448 96 f9		dw spi_portbyte 
544a dc fa		dw stackstore 
544c			; 50 
544c			if STORAGE_SE 
544c 82 00		dw storage_actl 
544e 80 00		dw storage_adata 
5450			else 
5450			dw 0 
5450			dw 0 
5450			endif 
5450 64 0b		dw storage_append 
5452			if STORAGE_SE 
5452 83 00		dw storage_bctl 
5454			else 
5454			dw 0 
5454			endif 
5454 c8 fa		dw store_bank_active 
5456 9c f9		dw store_filecache 
5458 aa f9		dw store_longread 
545a a0 f9		dw store_openaddr 
545c 9f f9		dw store_openext 
545e 9e f9		dw store_openmaxext 
5460			; 60 
5460 af f9		dw store_page 
5462 ab f9		dw store_readbuf 
5464 a2 f9		dw store_readcont 
5466 ad f9		dw store_readptr 
5468 a2 f9		dw store_tmpext 
546a a3 f9		dw store_tmpid 
546c 9a f9		dw store_tmppageid 
546e b9 13		dw malloc 
5470 83 14		dw free 
5472 5f 78		dw cin 
5474			; 70 
5474 4e 78		dw cin_wait 
5476 48 20		dw forth_push_numhl 
5478 b6 20		dw forth_push_str 
547a			 
547a			 
547a			.ENDCONST: 
547a			 
547a			; eof 
547a			 
547a			 
# End of file forth_words_const.asm
547a			 
547a			if STORAGE_SE 
547a			   	include "forth_words_storage.asm" 
547a			 
547a			; | ## Fixed Storage Words 
547a			 
547a			.RENAME: 
547a			  
547a				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
547a 3a				db WORD_SYS_CORE+38             
547b 70 55			dw .RECORD            
547d 07				db 6 + 1 
547e .. 00			db "RENAME",0              
5485				endm 
# End of macro CWHEAD
5485			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
5485			; | | > [!NOTE] 
5485			; | | > Compatible with PicoSPINet  
5485					if DEBUG_FORTH_WORDS_KEY 
5485						DMARK "REN" 
5485 f5				push af  
5486 3a 9a 54			ld a, (.dmark)  
5489 32 a0 fd			ld (debug_mark),a  
548c 3a 9b 54			ld a, (.dmark+1)  
548f 32 a1 fd			ld (debug_mark+1),a  
5492 3a 9c 54			ld a, (.dmark+2)  
5495 32 a2 fd			ld (debug_mark+2),a  
5498 18 03			jr .pastdmark  
549a ..			.dmark: db "REN"  
549d f1			.pastdmark: pop af  
549e			endm  
# End of macro DMARK
549e						CALLMONITOR 
549e cd aa fd			call debug_vector  
54a1				endm  
# End of macro CALLMONITOR
54a1					endif 
54a1			 
54a1			 
54a1					; preserve some internal vars used by other file handing routines 
54a1			 
54a1 2a a0 f9				ld hl, (store_openaddr) 
54a4 e5					push hl 
54a5 3a a2 f9				ld a, (store_readcont) 
54a8 f5					push af 
54a9			 
54a9					FORTH_DSP_VALUEHL 
54a9 cd 4d 22			call macro_dsp_valuehl 
54ac				endm 
# End of macro FORTH_DSP_VALUEHL
54ac			 
54ac					; move ext and id around for the file header 
54ac			 
54ac 65					ld h, l 
54ad 2e 00				ld l, 0 
54af			 
54af e5					push hl    ; id 
54b0			 
54b0					FORTH_DSP_POP 
54b0 cd 05 23			call macro_forth_dsp_pop 
54b3				endm 
# End of macro FORTH_DSP_POP
54b3			 
54b3					; Locate the file header 
54b3			 
54b3 e1					pop hl 
54b4 e5					push hl 
54b5 11 af f9				ld de, store_page      ; get block zero of file 
54b8					if DEBUG_FORTH_WORDS 
54b8						DMARK "REr" 
54b8 f5				push af  
54b9 3a cd 54			ld a, (.dmark)  
54bc 32 a0 fd			ld (debug_mark),a  
54bf 3a ce 54			ld a, (.dmark+1)  
54c2 32 a1 fd			ld (debug_mark+1),a  
54c5 3a cf 54			ld a, (.dmark+2)  
54c8 32 a2 fd			ld (debug_mark+2),a  
54cb 18 03			jr .pastdmark  
54cd ..			.dmark: db "REr"  
54d0 f1			.pastdmark: pop af  
54d1			endm  
# End of macro DMARK
54d1						CALLMONITOR 
54d1 cd aa fd			call debug_vector  
54d4				endm  
# End of macro CALLMONITOR
54d4					endif 
54d4 cd cd 09				call storage_read 
54d7			 
54d7 cd 07 10			call ishlzero 
54da 20 05			jr nz, .rnfound 
54dc			 
54dc				; file does not exist so indicate with 255 extents in use 
54dc			 
54dc 3e ff			ld a, 255 
54de e1				pop hl ; clear dup hl 
54df 18 7b			jr .skiprneof 
54e1			 
54e1			 
54e1			.rnfound: 
54e1					; file found so rename 
54e1			 
54e1					FORTH_DSP_VALUEHL 
54e1 cd 4d 22			call macro_dsp_valuehl 
54e4				endm 
# End of macro FORTH_DSP_VALUEHL
54e4			 
54e4 e5				push hl 
54e5 3e 00			ld a, 0 
54e7 cd 4f 13			call strlent 
54ea 23				inc hl   ; cover zero term 
54eb 06 00			ld b,0 
54ed 4d				ld c,l 
54ee e1				pop hl 
54ef 11 b2 f9				ld de, store_page + 3 
54f2 ed b0				ldir 
54f4			 
54f4 11 af f9				ld de, store_page 
54f7					if DEBUG_FORTH_WORDS 
54f7						DMARK "RER" 
54f7 f5				push af  
54f8 3a 0c 55			ld a, (.dmark)  
54fb 32 a0 fd			ld (debug_mark),a  
54fe 3a 0d 55			ld a, (.dmark+1)  
5501 32 a1 fd			ld (debug_mark+1),a  
5504 3a 0e 55			ld a, (.dmark+2)  
5507 32 a2 fd			ld (debug_mark+2),a  
550a 18 03			jr .pastdmark  
550c ..			.dmark: db "RER"  
550f f1			.pastdmark: pop af  
5510			endm  
# End of macro DMARK
5510						CALLMONITOR 
5510 cd aa fd			call debug_vector  
5513				endm  
# End of macro CALLMONITOR
5513					endif 
5513			 
5513 e1					pop hl    ; get orig file id and mangle it for find id 
5514 55					ld d, l 
5515 5c					ld e, h 
5516			 
5516 21 00 00				ld hl, 0 
5519					if DEBUG_FORTH_WORDS 
5519						DMARK "REf" 
5519 f5				push af  
551a 3a 2e 55			ld a, (.dmark)  
551d 32 a0 fd			ld (debug_mark),a  
5520 3a 2f 55			ld a, (.dmark+1)  
5523 32 a1 fd			ld (debug_mark+1),a  
5526 3a 30 55			ld a, (.dmark+2)  
5529 32 a2 fd			ld (debug_mark+2),a  
552c 18 03			jr .pastdmark  
552e ..			.dmark: db "REf"  
5531 f1			.pastdmark: pop af  
5532			endm  
# End of macro DMARK
5532						CALLMONITOR 
5532 cd aa fd			call debug_vector  
5535				endm  
# End of macro CALLMONITOR
5535					endif 
5535 cd a7 07				call storage_findnextid 
5538 11 af f9				ld de, store_page 
553b					if DEBUG_FORTH_WORDS 
553b						DMARK "REw" 
553b f5				push af  
553c 3a 50 55			ld a, (.dmark)  
553f 32 a0 fd			ld (debug_mark),a  
5542 3a 51 55			ld a, (.dmark+1)  
5545 32 a1 fd			ld (debug_mark+1),a  
5548 3a 52 55			ld a, (.dmark+2)  
554b 32 a2 fd			ld (debug_mark+2),a  
554e 18 03			jr .pastdmark  
5550 ..			.dmark: db "REw"  
5553 f1			.pastdmark: pop af  
5554			endm  
# End of macro DMARK
5554						CALLMONITOR 
5554 cd aa fd			call debug_vector  
5557				endm  
# End of macro CALLMONITOR
5557					endif 
5557 cd d9 04				call storage_write_block 
555a			 
555a 3e 00				ld a, 0 
555c			.skiprneof: 
555c					; drop file name 
555c					FORTH_DSP_POP 
555c cd 05 23			call macro_forth_dsp_pop 
555f				endm 
# End of macro FORTH_DSP_POP
555f			 
555f 6f					ld l, a 
5560 26 00				ld h, 0 
5562 cd 48 20				call forth_push_numhl 
5565			 
5565			 
5565 f1					pop af 
5566 32 a2 f9				ld (store_readcont),a 
5569 e1					pop hl 
556a 22 a0 f9				ld (store_openaddr), hl 
556d						 
556d				NEXTW 
556d c3 38 24			jp macro_next 
5570				endm 
# End of macro NEXTW
5570			.RECORD: 
5570			  
5570				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5570 3a				db WORD_SYS_CORE+38             
5571 14 56			dw .BREAD            
5573 07				db 6 + 1 
5574 .. 00			db "RECORD",0              
557b				endm 
# End of macro CWHEAD
557b			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
557b			; | | > [!NOTE] 
557b			; | | > Compatible with PicoSPINet  
557b			 
557b					if DEBUG_FORTH_WORDS_KEY 
557b						DMARK "REC" 
557b f5				push af  
557c 3a 90 55			ld a, (.dmark)  
557f 32 a0 fd			ld (debug_mark),a  
5582 3a 91 55			ld a, (.dmark+1)  
5585 32 a1 fd			ld (debug_mark+1),a  
5588 3a 92 55			ld a, (.dmark+2)  
558b 32 a2 fd			ld (debug_mark+2),a  
558e 18 03			jr .pastdmark  
5590 ..			.dmark: db "REC"  
5593 f1			.pastdmark: pop af  
5594			endm  
# End of macro DMARK
5594						CALLMONITOR 
5594 cd aa fd			call debug_vector  
5597				endm  
# End of macro CALLMONITOR
5597					endif 
5597			 
5597					FORTH_DSP_VALUEHL 
5597 cd 4d 22			call macro_dsp_valuehl 
559a				endm 
# End of macro FORTH_DSP_VALUEHL
559a			 
559a e5					push hl    ; id 
559b			 
559b					FORTH_DSP_POP 
559b cd 05 23			call macro_forth_dsp_pop 
559e				endm 
# End of macro FORTH_DSP_POP
559e			 
559e					FORTH_DSP_VALUEHL 
559e cd 4d 22			call macro_dsp_valuehl 
55a1				endm 
# End of macro FORTH_DSP_VALUEHL
55a1			 
55a1					FORTH_DSP_POP 
55a1 cd 05 23			call macro_forth_dsp_pop 
55a4				endm 
# End of macro FORTH_DSP_POP
55a4			 
55a4 d1					pop de     ; get file id 
55a5			 
55a5					; e = file id 
55a5					; l = file extent 
55a5			 
55a5			 
55a5					; construct request to access file extent 
55a5			 
55a5			;		ld a, e 
55a5 63					ld h, e 
55a6					 
55a6					 
55a6					 
55a6			 
55a6					; e has id 
55a6			 
55a6 11 af f9			ld de, store_page 
55a9					if DEBUG_FORTH_WORDS 
55a9						DMARK "REr" 
55a9 f5				push af  
55aa 3a be 55			ld a, (.dmark)  
55ad 32 a0 fd			ld (debug_mark),a  
55b0 3a bf 55			ld a, (.dmark+1)  
55b3 32 a1 fd			ld (debug_mark+1),a  
55b6 3a c0 55			ld a, (.dmark+2)  
55b9 32 a2 fd			ld (debug_mark+2),a  
55bc 18 03			jr .pastdmark  
55be ..			.dmark: db "REr"  
55c1 f1			.pastdmark: pop af  
55c2			endm  
# End of macro DMARK
55c2						CALLMONITOR 
55c2 cd aa fd			call debug_vector  
55c5				endm  
# End of macro CALLMONITOR
55c5					endif 
55c5 cd cd 09				call storage_read 
55c8 cd 07 10			call ishlzero 
55cb 28 22			jr z, .recnotfound 
55cd			 
55cd			 
55cd					if DEBUG_FORTH_WORDS 
55cd						DMARK "REe" 
55cd f5				push af  
55ce 3a e2 55			ld a, (.dmark)  
55d1 32 a0 fd			ld (debug_mark),a  
55d4 3a e3 55			ld a, (.dmark+1)  
55d7 32 a1 fd			ld (debug_mark+1),a  
55da 3a e4 55			ld a, (.dmark+2)  
55dd 32 a2 fd			ld (debug_mark+2),a  
55e0 18 03			jr .pastdmark  
55e2 ..			.dmark: db "REe"  
55e5 f1			.pastdmark: pop af  
55e6			endm  
# End of macro DMARK
55e6						CALLMONITOR 
55e6 cd aa fd			call debug_vector  
55e9				endm  
# End of macro CALLMONITOR
55e9					endif 
55e9 cd b6 20			call forth_push_str 
55ec			 
55ec					NEXTW 
55ec c3 38 24			jp macro_next 
55ef				endm 
# End of macro NEXTW
55ef			 
55ef			.recnotfound: 
55ef					if DEBUG_FORTH_WORDS 
55ef						DMARK "REf" 
55ef f5				push af  
55f0 3a 04 56			ld a, (.dmark)  
55f3 32 a0 fd			ld (debug_mark),a  
55f6 3a 05 56			ld a, (.dmark+1)  
55f9 32 a1 fd			ld (debug_mark+1),a  
55fc 3a 06 56			ld a, (.dmark+2)  
55ff 32 a2 fd			ld (debug_mark+2),a  
5602 18 03			jr .pastdmark  
5604 ..			.dmark: db "REf"  
5607 f1			.pastdmark: pop af  
5608			endm  
# End of macro DMARK
5608						CALLMONITOR 
5608 cd aa fd			call debug_vector  
560b				endm  
# End of macro CALLMONITOR
560b					endif 
560b 21 ff 00			ld hl, 255 
560e cd 48 20			call forth_push_numhl 
5611				NEXTW 
5611 c3 38 24			jp macro_next 
5614				endm 
# End of macro NEXTW
5614			 
5614			 
5614			.BREAD: 
5614			  
5614				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5614 3a				db WORD_SYS_CORE+38             
5615 97 56			dw .BWRITE            
5617 06				db 5 + 1 
5618 .. 00			db "BREAD",0              
561e				endm 
# End of macro CWHEAD
561e			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
561e			; | | > [!NOTE] 
561e			; | | > Compatible with PicoSPINet  
561e				 
561e					if DEBUG_FORTH_WORDS_KEY 
561e						DMARK "BRD" 
561e f5				push af  
561f 3a 33 56			ld a, (.dmark)  
5622 32 a0 fd			ld (debug_mark),a  
5625 3a 34 56			ld a, (.dmark+1)  
5628 32 a1 fd			ld (debug_mark+1),a  
562b 3a 35 56			ld a, (.dmark+2)  
562e 32 a2 fd			ld (debug_mark+2),a  
5631 18 03			jr .pastdmark  
5633 ..			.dmark: db "BRD"  
5636 f1			.pastdmark: pop af  
5637			endm  
# End of macro DMARK
5637						CALLMONITOR 
5637 cd aa fd			call debug_vector  
563a				endm  
# End of macro CALLMONITOR
563a					endif 
563a			 
563a				FORTH_DSP_VALUEHL 
563a cd 4d 22			call macro_dsp_valuehl 
563d				endm 
# End of macro FORTH_DSP_VALUEHL
563d			 
563d				FORTH_DSP_POP 
563d cd 05 23			call macro_forth_dsp_pop 
5640				endm 
# End of macro FORTH_DSP_POP
5640			 
5640				; calc block address 
5640			 
5640 eb				ex de, hl 
5641 3e 40			ld a, STORE_BLOCK_PHY 
5643 cd 61 0f			call Mult16 
5646			 
5646			 
5646 11 af f9			ld de, store_page 
5649			 
5649					if DEBUG_FORTH_WORDS 
5649						DMARK "BR1" 
5649 f5				push af  
564a 3a 5e 56			ld a, (.dmark)  
564d 32 a0 fd			ld (debug_mark),a  
5650 3a 5f 56			ld a, (.dmark+1)  
5653 32 a1 fd			ld (debug_mark+1),a  
5656 3a 60 56			ld a, (.dmark+2)  
5659 32 a2 fd			ld (debug_mark+2),a  
565c 18 03			jr .pastdmark  
565e ..			.dmark: db "BR1"  
5661 f1			.pastdmark: pop af  
5662			endm  
# End of macro DMARK
5662						CALLMONITOR 
5662 cd aa fd			call debug_vector  
5665				endm  
# End of macro CALLMONITOR
5665					endif 
5665			 
5665 cd 74 04			call storage_read_block 
5668			 
5668 cd 07 10			call ishlzero 
566b 20 05			jr nz, .brfound 
566d			 
566d cd 48 20			call forth_push_numhl 
5670 18 22			jr .brdone 
5672			 
5672			 
5672			.brfound: 
5672 21 b1 f9		        ld hl, store_page+2 
5675			 
5675					if DEBUG_FORTH_WORDS 
5675						DMARK "BR2" 
5675 f5				push af  
5676 3a 8a 56			ld a, (.dmark)  
5679 32 a0 fd			ld (debug_mark),a  
567c 3a 8b 56			ld a, (.dmark+1)  
567f 32 a1 fd			ld (debug_mark+1),a  
5682 3a 8c 56			ld a, (.dmark+2)  
5685 32 a2 fd			ld (debug_mark+2),a  
5688 18 03			jr .pastdmark  
568a ..			.dmark: db "BR2"  
568d f1			.pastdmark: pop af  
568e			endm  
# End of macro DMARK
568e						CALLMONITOR 
568e cd aa fd			call debug_vector  
5691				endm  
# End of macro CALLMONITOR
5691					endif 
5691			 
5691 cd b6 20			call forth_push_str 
5694			 
5694			 
5694			.brdone: 
5694			 
5694					NEXTW 
5694 c3 38 24			jp macro_next 
5697				endm 
# End of macro NEXTW
5697			.BWRITE: 
5697				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5697 3a				db WORD_SYS_CORE+38             
5698 2c 57			dw .BUPD            
569a 07				db 6 + 1 
569b .. 00			db "BWRITE",0              
56a2				endm 
# End of macro CWHEAD
56a2			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
56a2			; | | > [!NOTE] 
56a2			; | | > Compatible with PicoSPINet  
56a2			 
56a2					if DEBUG_FORTH_WORDS_KEY 
56a2						DMARK "BWR" 
56a2 f5				push af  
56a3 3a b7 56			ld a, (.dmark)  
56a6 32 a0 fd			ld (debug_mark),a  
56a9 3a b8 56			ld a, (.dmark+1)  
56ac 32 a1 fd			ld (debug_mark+1),a  
56af 3a b9 56			ld a, (.dmark+2)  
56b2 32 a2 fd			ld (debug_mark+2),a  
56b5 18 03			jr .pastdmark  
56b7 ..			.dmark: db "BWR"  
56ba f1			.pastdmark: pop af  
56bb			endm  
# End of macro DMARK
56bb						CALLMONITOR 
56bb cd aa fd			call debug_vector  
56be				endm  
# End of macro CALLMONITOR
56be					endif 
56be			 
56be				FORTH_DSP_VALUEHL 
56be cd 4d 22			call macro_dsp_valuehl 
56c1				endm 
# End of macro FORTH_DSP_VALUEHL
56c1			 
56c1				; calc block address 
56c1			 
56c1 eb				ex de, hl 
56c2 3e 40			ld a, STORE_BLOCK_PHY 
56c4 cd 61 0f			call Mult16 
56c7			 
56c7 e5				push hl         ; address 
56c8			 
56c8				FORTH_DSP_POP 
56c8 cd 05 23			call macro_forth_dsp_pop 
56cb				endm 
# End of macro FORTH_DSP_POP
56cb			 
56cb				FORTH_DSP_VALUEHL 
56cb cd 4d 22			call macro_dsp_valuehl 
56ce				endm 
# End of macro FORTH_DSP_VALUEHL
56ce			 
56ce				FORTH_DSP_POP 
56ce cd 05 23			call macro_forth_dsp_pop 
56d1				endm 
# End of macro FORTH_DSP_POP
56d1			 
56d1 cd b0 0c			call storage_clear_page 
56d4			 
56d4				; copy string to store page 
56d4			 
56d4 e5				push hl     ; save string address 
56d5			 
56d5 3e 00			ld a, 0 
56d7 cd 4f 13			call strlent 
56da			 
56da 23				inc hl 
56db			 
56db 4d				ld c, l 
56dc 06 00			ld b, 0 
56de			 
56de e1				pop hl 
56df 11 b1 f9			ld de, store_page + 2 
56e2					if DEBUG_FORTH_WORDS 
56e2						DMARK "BW1" 
56e2 f5				push af  
56e3 3a f7 56			ld a, (.dmark)  
56e6 32 a0 fd			ld (debug_mark),a  
56e9 3a f8 56			ld a, (.dmark+1)  
56ec 32 a1 fd			ld (debug_mark+1),a  
56ef 3a f9 56			ld a, (.dmark+2)  
56f2 32 a2 fd			ld (debug_mark+2),a  
56f5 18 03			jr .pastdmark  
56f7 ..			.dmark: db "BW1"  
56fa f1			.pastdmark: pop af  
56fb			endm  
# End of macro DMARK
56fb						CALLMONITOR 
56fb cd aa fd			call debug_vector  
56fe				endm  
# End of macro CALLMONITOR
56fe					endif 
56fe ed b0			ldir 
5700			 
5700			 
5700				; poke the start of the block with flags to prevent high level file ops hitting the block 
5700			 
5700 21 ff ff			ld hl, $ffff 
5703			 
5703 22 af f9			ld (store_page), hl	 
5706				 
5706 e1				pop hl    ; get address 
5707 11 af f9			ld de, store_page 
570a			 
570a					if DEBUG_FORTH_WORDS 
570a						DMARK "BW2" 
570a f5				push af  
570b 3a 1f 57			ld a, (.dmark)  
570e 32 a0 fd			ld (debug_mark),a  
5711 3a 20 57			ld a, (.dmark+1)  
5714 32 a1 fd			ld (debug_mark+1),a  
5717 3a 21 57			ld a, (.dmark+2)  
571a 32 a2 fd			ld (debug_mark+2),a  
571d 18 03			jr .pastdmark  
571f ..			.dmark: db "BW2"  
5722 f1			.pastdmark: pop af  
5723			endm  
# End of macro DMARK
5723						CALLMONITOR 
5723 cd aa fd			call debug_vector  
5726				endm  
# End of macro CALLMONITOR
5726					endif 
5726			 
5726 cd d9 04			call storage_write_block 
5729			 
5729					NEXTW 
5729 c3 38 24			jp macro_next 
572c				endm 
# End of macro NEXTW
572c			 
572c			.BUPD: 
572c				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
572c 3a				db WORD_SYS_CORE+38             
572d 82 57			dw .BYID            
572f 05				db 4 + 1 
5730 .. 00			db "BUPD",0              
5735				endm 
# End of macro CWHEAD
5735			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5735			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5735			; | | or completely different file system structure. 
5735			; | | > [!NOTE] 
5735			; | | > Compatible with PicoSPINet  
5735			 
5735					if DEBUG_FORTH_WORDS_KEY 
5735						DMARK "BUD" 
5735 f5				push af  
5736 3a 4a 57			ld a, (.dmark)  
5739 32 a0 fd			ld (debug_mark),a  
573c 3a 4b 57			ld a, (.dmark+1)  
573f 32 a1 fd			ld (debug_mark+1),a  
5742 3a 4c 57			ld a, (.dmark+2)  
5745 32 a2 fd			ld (debug_mark+2),a  
5748 18 03			jr .pastdmark  
574a ..			.dmark: db "BUD"  
574d f1			.pastdmark: pop af  
574e			endm  
# End of macro DMARK
574e						CALLMONITOR 
574e cd aa fd			call debug_vector  
5751				endm  
# End of macro CALLMONITOR
5751					endif 
5751			 
5751				FORTH_DSP_VALUEHL 
5751 cd 4d 22			call macro_dsp_valuehl 
5754				endm 
# End of macro FORTH_DSP_VALUEHL
5754			 
5754				; calc block address 
5754			 
5754 eb				ex de, hl 
5755 3e 40			ld a, STORE_BLOCK_PHY 
5757 cd 61 0f			call Mult16 
575a			 
575a				FORTH_DSP_POP 
575a cd 05 23			call macro_forth_dsp_pop 
575d				endm 
# End of macro FORTH_DSP_POP
575d			 
575d			 
575d 11 af f9			ld de, store_page 
5760			 
5760					if DEBUG_FORTH_WORDS 
5760						DMARK "BUe" 
5760 f5				push af  
5761 3a 75 57			ld a, (.dmark)  
5764 32 a0 fd			ld (debug_mark),a  
5767 3a 76 57			ld a, (.dmark+1)  
576a 32 a1 fd			ld (debug_mark+1),a  
576d 3a 77 57			ld a, (.dmark+2)  
5770 32 a2 fd			ld (debug_mark+2),a  
5773 18 03			jr .pastdmark  
5775 ..			.dmark: db "BUe"  
5778 f1			.pastdmark: pop af  
5779			endm  
# End of macro DMARK
5779						CALLMONITOR 
5779 cd aa fd			call debug_vector  
577c				endm  
# End of macro CALLMONITOR
577c					endif 
577c			 
577c cd d9 04			call storage_write_block 
577f			 
577f					NEXTW 
577f c3 38 24			jp macro_next 
5782				endm 
# End of macro NEXTW
5782			 
5782			.BYID: 
5782			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5782			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5782			; 
5782			;		 
5782			;		if DEBUG_FORTH_WORDS_KEY 
5782			;			DMARK "BYID" 
5782			;			CALLMONITOR 
5782			;		endif 
5782			; 
5782			;		; get direct address 
5782			; 
5782			;		FORTH_DSP_VALUEHL 
5782			; 
5782			;		FORTH_DSP_POP 
5782			; 
5782			;	; calc block address 
5782			; 
5782			;	ex de, hl 
5782			;	ld a, STORE_BLOCK_PHY 
5782			;	call Mult16 
5782			;	;	do BREAD with number as param 
5782			;	; push the file name	 
5782			;	ld de, store_page 
5782			;	call storage_read_block 
5782			 ;       ld hl, store_page+2 
5782			; 
5782			; 
5782			;		NEXTW 
5782			;.BYNAME: 
5782				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5782 3a				db WORD_SYS_CORE+38             
5783 9b 57			dw .DIR            
5785 06				db 5 + 1 
5786 .. 00			db "GETID",0              
578c				endm 
# End of macro CWHEAD
578c			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
578c			; | | > [!NOTE] 
578c			; | | > Compatible with PicoSPINet  
578c			 
578c					; get pointer to file name to seek 
578c			 
578c					FORTH_DSP_VALUEHL 
578c cd 4d 22			call macro_dsp_valuehl 
578f				endm 
# End of macro FORTH_DSP_VALUEHL
578f			 
578f			 
578f cd 9b 03				call storage_getid  
5792			 
5792					FORTH_DSP_POP 
5792 cd 05 23			call macro_forth_dsp_pop 
5795				endm 
# End of macro FORTH_DSP_POP
5795			 
5795 cd 48 20				call forth_push_numhl 
5798			 
5798					NEXTW 
5798 c3 38 24			jp macro_next 
579b				endm 
# End of macro NEXTW
579b			; 
579b			.DIR: 
579b				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
579b 3a				db WORD_SYS_CORE+38             
579c 9f 58			dw .SAVE            
579e 04				db 3 + 1 
579f .. 00			db "DIR",0              
57a3				endm 
# End of macro CWHEAD
57a3			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
57a3			; | | > [!NOTE] 
57a3			; | | > Compatible with PicoSPINet  
57a3			 
57a3					if DEBUG_FORTH_WORDS_KEY 
57a3						DMARK "DIR" 
57a3 f5				push af  
57a4 3a b8 57			ld a, (.dmark)  
57a7 32 a0 fd			ld (debug_mark),a  
57aa 3a b9 57			ld a, (.dmark+1)  
57ad 32 a1 fd			ld (debug_mark+1),a  
57b0 3a ba 57			ld a, (.dmark+2)  
57b3 32 a2 fd			ld (debug_mark+2),a  
57b6 18 03			jr .pastdmark  
57b8 ..			.dmark: db "DIR"  
57bb f1			.pastdmark: pop af  
57bc			endm  
# End of macro DMARK
57bc						CALLMONITOR 
57bc cd aa fd			call debug_vector  
57bf				endm  
# End of macro CALLMONITOR
57bf					endif 
57bf cd 25 05			call storage_get_block_0 
57c2			 
57c2 21 af f9			ld hl, store_page     ; get current id count 
57c5 46				ld b, (hl) 
57c6 0e 00			ld c, 0    ; count of files   
57c8					if DEBUG_FORTH_WORDS 
57c8						DMARK "DI1" 
57c8 f5				push af  
57c9 3a dd 57			ld a, (.dmark)  
57cc 32 a0 fd			ld (debug_mark),a  
57cf 3a de 57			ld a, (.dmark+1)  
57d2 32 a1 fd			ld (debug_mark+1),a  
57d5 3a df 57			ld a, (.dmark+2)  
57d8 32 a2 fd			ld (debug_mark+2),a  
57db 18 03			jr .pastdmark  
57dd ..			.dmark: db "DI1"  
57e0 f1			.pastdmark: pop af  
57e1			endm  
# End of macro DMARK
57e1						CALLMONITOR 
57e1 cd aa fd			call debug_vector  
57e4				endm  
# End of macro CALLMONITOR
57e4					endif 
57e4			 
57e4				; check for empty drive 
57e4			 
57e4 3e 00			ld a, 0 
57e6 b8				cp b 
57e7 ca 55 58			jp z, .dirdone 
57ea			 
57ea				; for each of the current ids do a search for them and if found push to stack 
57ea			 
57ea c5			.diritem:	push bc 
57eb 21 40 00				ld hl, STORE_BLOCK_PHY 
57ee 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
57f0 58					ld e,b 
57f1			 
57f1			;		if DEBUG_FORTH_WORDS 
57f1			;			DMARK "DI2" 
57f1			;			CALLMONITOR 
57f1			;		endif 
57f1			 
57f1 cd a7 07				call storage_findnextid 
57f4			 
57f4			;		if DEBUG_FORTH_WORDS 
57f4			;			DMARK "DI3" 
57f4			;			CALLMONITOR 
57f4			;		endif 
57f4			 
57f4					; if found hl will be non zero 
57f4			 
57f4 cd 07 10				call ishlzero 
57f7			;		ld a, l 
57f7			;		add h 
57f7			; 
57f7			;		cp 0 
57f7 28 59				jr z, .dirnotfound 
57f9			 
57f9					; increase count 
57f9			 
57f9 c1					pop bc	 
57fa 0c					inc c 
57fb c5					push bc 
57fc					 
57fc			 
57fc					; get file header and push the file name 
57fc			 
57fc 11 af f9				ld de, store_page 
57ff cd 74 04				call storage_read_block 
5802			 
5802					; push file id to stack 
5802				 
5802 3a af f9				ld a, (store_page) 
5805 26 00				ld h, 0 
5807 6f					ld l, a 
5808 cd 48 20				call forth_push_numhl 
580b			 
580b					; push extent count to stack  
580b				 
580b 3a b1 f9				ld a, (store_page+2) 
580e 26 00				ld h, 0 
5810 6f					ld l, a 
5811 cd 48 20				call forth_push_numhl 
5814			 
5814					; push file name 
5814			 
5814 21 b2 f9				ld hl, store_page+3 
5817					if DEBUG_FORTH_WORDS 
5817						DMARK "DI5" 
5817 f5				push af  
5818 3a 2c 58			ld a, (.dmark)  
581b 32 a0 fd			ld (debug_mark),a  
581e 3a 2d 58			ld a, (.dmark+1)  
5821 32 a1 fd			ld (debug_mark+1),a  
5824 3a 2e 58			ld a, (.dmark+2)  
5827 32 a2 fd			ld (debug_mark+2),a  
582a 18 03			jr .pastdmark  
582c ..			.dmark: db "DI5"  
582f f1			.pastdmark: pop af  
5830			endm  
# End of macro DMARK
5830						CALLMONITOR 
5830 cd aa fd			call debug_vector  
5833				endm  
# End of macro CALLMONITOR
5833					endif 
5833 cd b6 20				call forth_push_str 
5836					if DEBUG_FORTH_WORDS 
5836						DMARK "DI6" 
5836 f5				push af  
5837 3a 4b 58			ld a, (.dmark)  
583a 32 a0 fd			ld (debug_mark),a  
583d 3a 4c 58			ld a, (.dmark+1)  
5840 32 a1 fd			ld (debug_mark+1),a  
5843 3a 4d 58			ld a, (.dmark+2)  
5846 32 a2 fd			ld (debug_mark+2),a  
5849 18 03			jr .pastdmark  
584b ..			.dmark: db "DI6"  
584e f1			.pastdmark: pop af  
584f			endm  
# End of macro DMARK
584f						CALLMONITOR 
584f cd aa fd			call debug_vector  
5852				endm  
# End of macro CALLMONITOR
5852					endif 
5852			.dirnotfound: 
5852 c1					pop bc     
5853 10 95				djnz .diritem 
5855				 
5855			.dirdone:	 
5855					if DEBUG_FORTH_WORDS 
5855						DMARK "DI7" 
5855 f5				push af  
5856 3a 6a 58			ld a, (.dmark)  
5859 32 a0 fd			ld (debug_mark),a  
585c 3a 6b 58			ld a, (.dmark+1)  
585f 32 a1 fd			ld (debug_mark+1),a  
5862 3a 6c 58			ld a, (.dmark+2)  
5865 32 a2 fd			ld (debug_mark+2),a  
5868 18 03			jr .pastdmark  
586a ..			.dmark: db "DI7"  
586d f1			.pastdmark: pop af  
586e			endm  
# End of macro DMARK
586e						CALLMONITOR 
586e cd aa fd			call debug_vector  
5871				endm  
# End of macro CALLMONITOR
5871					endif 
5871			 
5871					; push a count of the dir items found 
5871			 
5871 26 00				ld h, 0 
5873 69					ld l, c 
5874 cd 48 20				call forth_push_numhl 
5877			 
5877					; push the bank label 
5877			 
5877 cd 25 05				call storage_get_block_0 
587a			 
587a				 
587a 21 b2 f9		 		ld hl, store_page+3 
587d			 
587d					if DEBUG_FORTH_WORDS 
587d						DMARK "DI8" 
587d f5				push af  
587e 3a 92 58			ld a, (.dmark)  
5881 32 a0 fd			ld (debug_mark),a  
5884 3a 93 58			ld a, (.dmark+1)  
5887 32 a1 fd			ld (debug_mark+1),a  
588a 3a 94 58			ld a, (.dmark+2)  
588d 32 a2 fd			ld (debug_mark+2),a  
5890 18 03			jr .pastdmark  
5892 ..			.dmark: db "DI8"  
5895 f1			.pastdmark: pop af  
5896			endm  
# End of macro DMARK
5896						CALLMONITOR 
5896 cd aa fd			call debug_vector  
5899				endm  
# End of macro CALLMONITOR
5899					endif 
5899 cd b6 20				call forth_push_str 
589c			 
589c			 
589c				 
589c					NEXTW 
589c c3 38 24			jp macro_next 
589f				endm 
# End of macro NEXTW
589f			.SAVE: 
589f			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
589f			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
589f			;		NEXTW 
589f			;.LOAD: 
589f			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
589f			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
589f			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
589f			;; > > The LOAD command can not be used in any user words or compound lines. 
589f			; 
589f			;		; store_openext use it. If zero it is EOF 
589f			; 
589f			;		; read block from current stream id 
589f			;		; if the block does not contain zero term keep reading blocks until zero found 
589f			;		; push the block to stack 
589f			;		; save the block id to stream 
589f			; 
589f			; 
589f			;		FORTH_DSP_VALUEHL 
589f			; 
589f			;;		push hl 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LOA" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;		FORTH_DSP_POP 
589f			; 
589f			;;		pop hl 
589f			; 
589f			;		ld h, l 
589f			;		ld l, 0 
589f			; 
589f			;		push hl     ; stack holds current file id and extent to work with 
589f			; 
589f			; 
589f			;		ld de, store_page      ; get block zero of file 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LO0" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;		call storage_read 
589f			; 
589f			;		ld a, (store_page+2)    ; max extents for this file 
589f			;		ld  (store_openmaxext),a   ; get our limit 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LOE" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			; 
589f			;; TODO dont know why max extents are not present 
589f			;;		cp 0 
589f			;;		jp z, .loadeof     ; dont read past eof 
589f			; 
589f			;;		ld a, 1   ; start from the head of the file 
589f			; 
589f			;.loadline:	pop hl 
589f			;		inc hl 
589f			;		ld  a, (store_openmaxext)   ; get our limit 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LOx" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;		inc a 
589f			;		cp l 
589f			;		jp z, .loadeof 
589f			;		push hl    ; save current extent 
589f			; 
589f			;		ld de, store_page 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LO1" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;		call storage_read 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LO2" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;	call ishlzero 
589f			;	ld a, l 
589f			;	add h 
589f			;	cp 0 
589f			;	jr z, .loadeof 
589f			; 
589f			;	; not eof so hl should point to data to exec 
589f			; 
589f			;	; will need to add the FORTH_END_BUFFER flag 
589f			 ; 
589f			;	ld hl, store_page+2 
589f			;	ld bc, 255 
589f			;	ld a, 0 
589f			;	cpir 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LOt" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;	dec hl 
589f			;	ld a, ' ' 
589f			;	ld (hl), a 
589f			;	inc hl 
589f			;	ld (hl), a 
589f			;	inc hl 
589f			;	ld (hl), a 
589f			;	inc hl 
589f			;	ld a, FORTH_END_BUFFER 
589f			;	ld (hl), a 
589f			; 
589f			;	; TODO handle more than a single block read 
589f			; 
589f			; 
589f			;	ld hl, store_page+2 
589f			; 
589f			;	ld (os_tok_ptr), hl 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LO3" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			; 
589f			;	call forthparse 
589f			;	call forthexec 
589f			;	call forthexec_cleanup 
589f			; 
589f			;	; go to next extent 
589f			; 
589f			;	; get next block  or mark as eof 
589f			;	jp .loadline 
589f			; 
589f			; 
589f			; 
589f			;	       NEXTW 
589f			;.loadeof:	ld a, 0 
589f			;		ld (store_openext), a 
589f			; 
589f			;	if DEBUG_STORESE 
589f			;		DMARK "LOF" 
589f			;		CALLMONITOR 
589f			;	endif 
589f			;		ret 
589f			;		;NEXTW 
589f			;.BSAVE:   
589f			; 
589f			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
589f			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
589f			;		NEXTW 
589f			;.BLOAD: 
589f			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
589f			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
589f			;		NEXTW 
589f			;;;; counter gap 
589f			 
589f			 
589f			.SEO: 
589f				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
589f 64				db WORD_SYS_CORE+80             
58a0 be 58			dw .SEI            
58a2 04				db 3 + 1 
58a3 .. 00			db "SEO",0              
58a7				endm 
# End of macro CWHEAD
58a7			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
58a7			 
58a7					; get port 
58a7			 
58a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58a7 cd 4d 22			call macro_dsp_valuehl 
58aa				endm 
# End of macro FORTH_DSP_VALUEHL
58aa			 
58aa e5					push hl    ; u2 - byte 
58ab			 
58ab					; destroy value TOS 
58ab			 
58ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58ab cd 05 23			call macro_forth_dsp_pop 
58ae				endm 
# End of macro FORTH_DSP_POP
58ae			 
58ae					; get byte to send 
58ae			 
58ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58ae cd 4d 22			call macro_dsp_valuehl 
58b1				endm 
# End of macro FORTH_DSP_VALUEHL
58b1			 
58b1 e5					push hl    ; u1 - addr 
58b2			 
58b2					; destroy value TOS 
58b2			 
58b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58b2 cd 05 23			call macro_forth_dsp_pop 
58b5				endm 
# End of macro FORTH_DSP_POP
58b5			 
58b5					; one value on hl get other one back 
58b5			 
58b5 d1					pop de   ; u1 - byte 
58b6			 
58b6 e1					pop hl   ; u2 - addr 
58b7			 
58b7					; TODO Send SPI byte 
58b7			 
58b7			 
58b7 7b					ld a, e 
58b8 cd 79 02				call se_writebyte 
58bb			 
58bb					 
58bb			 
58bb					NEXTW 
58bb c3 38 24			jp macro_next 
58be				endm 
# End of macro NEXTW
58be			 
58be			.SEI: 
58be				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
58be 65				db WORD_SYS_CORE+81             
58bf d8 58			dw .SFREE            
58c1 04				db 3 + 1 
58c2 .. 00			db "SEI",0              
58c6				endm 
# End of macro CWHEAD
58c6			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
58c6			 
58c6					; get port 
58c6			 
58c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58c6 cd 4d 22			call macro_dsp_valuehl 
58c9				endm 
# End of macro FORTH_DSP_VALUEHL
58c9			 
58c9			;		push hl 
58c9			 
58c9					; destroy value TOS 
58c9			 
58c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58c9 cd 05 23			call macro_forth_dsp_pop 
58cc				endm 
# End of macro FORTH_DSP_POP
58cc			 
58cc					; one value on hl get other one back 
58cc			 
58cc			;		pop hl 
58cc			 
58cc			 
58cc					; TODO Get SPI byte 
58cc			 
58cc cd 1b 03				call se_readbyte 
58cf			 
58cf 26 00				ld h, 0 
58d1 6f					ld l, a 
58d2 cd 48 20				call forth_push_numhl 
58d5			 
58d5					NEXTW 
58d5 c3 38 24			jp macro_next 
58d8				endm 
# End of macro NEXTW
58d8			 
58d8			.SFREE: 
58d8				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
58d8 67				db WORD_SYS_CORE+83             
58d9 07 59			dw .SIZE            
58db 06				db 5 + 1 
58dc .. 00			db "FFREE",0              
58e2				endm 
# End of macro CWHEAD
58e2			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
58e2			; | | > [!NOTE] 
58e2			; | | > Compatible with PicoSPINet  
58e2					if DEBUG_FORTH_WORDS_KEY 
58e2						DMARK "FFR" 
58e2 f5				push af  
58e3 3a f7 58			ld a, (.dmark)  
58e6 32 a0 fd			ld (debug_mark),a  
58e9 3a f8 58			ld a, (.dmark+1)  
58ec 32 a1 fd			ld (debug_mark+1),a  
58ef 3a f9 58			ld a, (.dmark+2)  
58f2 32 a2 fd			ld (debug_mark+2),a  
58f5 18 03			jr .pastdmark  
58f7 ..			.dmark: db "FFR"  
58fa f1			.pastdmark: pop af  
58fb			endm  
# End of macro DMARK
58fb						CALLMONITOR 
58fb cd aa fd			call debug_vector  
58fe				endm  
# End of macro CALLMONITOR
58fe					endif 
58fe			 
58fe cd 41 08				call storage_freeblocks 
5901			 
5901 cd 48 20				call forth_push_numhl 
5904			 
5904				       NEXTW 
5904 c3 38 24			jp macro_next 
5907				endm 
# End of macro NEXTW
5907			.SIZE: 
5907				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5907 67				db WORD_SYS_CORE+83             
5908 3b 59			dw .CREATE            
590a 05				db 4 + 1 
590b .. 00			db "SIZE",0              
5910				endm 
# End of macro CWHEAD
5910			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5910			; | | > [!NOTE] 
5910			; | | > Compatible with PicoSPINet  
5910					if DEBUG_FORTH_WORDS_KEY 
5910						DMARK "SIZ" 
5910 f5				push af  
5911 3a 25 59			ld a, (.dmark)  
5914 32 a0 fd			ld (debug_mark),a  
5917 3a 26 59			ld a, (.dmark+1)  
591a 32 a1 fd			ld (debug_mark+1),a  
591d 3a 27 59			ld a, (.dmark+2)  
5920 32 a2 fd			ld (debug_mark+2),a  
5923 18 03			jr .pastdmark  
5925 ..			.dmark: db "SIZ"  
5928 f1			.pastdmark: pop af  
5929			endm  
# End of macro DMARK
5929						CALLMONITOR 
5929 cd aa fd			call debug_vector  
592c				endm  
# End of macro CALLMONITOR
592c					endif 
592c			 
592c					FORTH_DSP_VALUEHL 
592c cd 4d 22			call macro_dsp_valuehl 
592f				endm 
# End of macro FORTH_DSP_VALUEHL
592f			;		push hl 
592f					FORTH_DSP_POP 
592f cd 05 23			call macro_forth_dsp_pop 
5932				endm 
# End of macro FORTH_DSP_POP
5932			;		pop hl 
5932 cd a3 04				call storage_file_size 
5935			 
5935 cd 48 20				call forth_push_numhl 
5938			  
5938			 
5938				       NEXTW 
5938 c3 38 24			jp macro_next 
593b				endm 
# End of macro NEXTW
593b			 
593b			.CREATE: 
593b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
593b 68				db WORD_SYS_CORE+84             
593c a9 59			dw .APPEND            
593e 07				db 6 + 1 
593f .. 00			db "CREATE",0              
5946				endm 
# End of macro CWHEAD
5946			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5946			; | | e.g.  
5946			; | | TestProgram CREATE 
5946			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5946			; | |  
5946			; | | Max file IDs are 255. 
5946			; | |  
5946			; | | > [!NOTE] 
5946			; | | > Compatible with PicoSPINet  
5946					 
5946					if DEBUG_FORTH_WORDS_KEY 
5946						DMARK "CRT" 
5946 f5				push af  
5947 3a 5b 59			ld a, (.dmark)  
594a 32 a0 fd			ld (debug_mark),a  
594d 3a 5c 59			ld a, (.dmark+1)  
5950 32 a1 fd			ld (debug_mark+1),a  
5953 3a 5d 59			ld a, (.dmark+2)  
5956 32 a2 fd			ld (debug_mark+2),a  
5959 18 03			jr .pastdmark  
595b ..			.dmark: db "CRT"  
595e f1			.pastdmark: pop af  
595f			endm  
# End of macro DMARK
595f						CALLMONITOR 
595f cd aa fd			call debug_vector  
5962				endm  
# End of macro CALLMONITOR
5962					endif 
5962			;		call storage_get_block_0 
5962			 
5962					; TODO pop hl 
5962			 
5962					;v5 FORTH_DSP_VALUE 
5962					FORTH_DSP_VALUE 
5962 cd 36 22			call macro_forth_dsp_value 
5965				endm 
# End of macro FORTH_DSP_VALUE
5965			 
5965				if DEBUG_STORESE 
5965					DMARK "CR1" 
5965 f5				push af  
5966 3a 7a 59			ld a, (.dmark)  
5969 32 a0 fd			ld (debug_mark),a  
596c 3a 7b 59			ld a, (.dmark+1)  
596f 32 a1 fd			ld (debug_mark+1),a  
5972 3a 7c 59			ld a, (.dmark+2)  
5975 32 a2 fd			ld (debug_mark+2),a  
5978 18 03			jr .pastdmark  
597a ..			.dmark: db "CR1"  
597d f1			.pastdmark: pop af  
597e			endm  
# End of macro DMARK
597e					CALLMONITOR 
597e cd aa fd			call debug_vector  
5981				endm  
# End of macro CALLMONITOR
5981				endif 
5981			;		push hl 
5981			;		FORTH_DSP_POP 
5981			;		pop hl 
5981			 
5981			;		inc hl   ; move past the type marker 
5981			 
5981 cd 77 08				call storage_create 
5984			 
5984				if DEBUG_STORESE 
5984					DMARK "CT1" 
5984 f5				push af  
5985 3a 99 59			ld a, (.dmark)  
5988 32 a0 fd			ld (debug_mark),a  
598b 3a 9a 59			ld a, (.dmark+1)  
598e 32 a1 fd			ld (debug_mark+1),a  
5991 3a 9b 59			ld a, (.dmark+2)  
5994 32 a2 fd			ld (debug_mark+2),a  
5997 18 03			jr .pastdmark  
5999 ..			.dmark: db "CT1"  
599c f1			.pastdmark: pop af  
599d			endm  
# End of macro DMARK
599d					CALLMONITOR 
599d cd aa fd			call debug_vector  
59a0				endm  
# End of macro CALLMONITOR
59a0				endif 
59a0			;		push hl 
59a0					FORTH_DSP_POP 
59a0 cd 05 23			call macro_forth_dsp_pop 
59a3				endm 
# End of macro FORTH_DSP_POP
59a3			;		pop hl 
59a3					; push file id to stack 
59a3 cd 48 20				call forth_push_numhl 
59a6			 
59a6			 
59a6			 
59a6				       NEXTW 
59a6 c3 38 24			jp macro_next 
59a9				endm 
# End of macro NEXTW
59a9			 
59a9			.APPEND: 
59a9				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
59a9 69				db WORD_SYS_CORE+85             
59aa 3a 5a			dw .SDEL            
59ac 07				db 6 + 1 
59ad .. 00			db "APPEND",0              
59b4				endm 
# End of macro CWHEAD
59b4			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
59b4			; | | e.g. 
59b4			; | | Test CREATE      -> $01 
59b4			; | | "A string to add to file" $01 APPEND 
59b4			; | |  
59b4			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
59b4			; | | > [!NOTE] 
59b4			; | | > Compatible with PicoSPINet  
59b4					if DEBUG_FORTH_WORDS_KEY 
59b4						DMARK "APP" 
59b4 f5				push af  
59b5 3a c9 59			ld a, (.dmark)  
59b8 32 a0 fd			ld (debug_mark),a  
59bb 3a ca 59			ld a, (.dmark+1)  
59be 32 a1 fd			ld (debug_mark+1),a  
59c1 3a cb 59			ld a, (.dmark+2)  
59c4 32 a2 fd			ld (debug_mark+2),a  
59c7 18 03			jr .pastdmark  
59c9 ..			.dmark: db "APP"  
59cc f1			.pastdmark: pop af  
59cd			endm  
# End of macro DMARK
59cd						CALLMONITOR 
59cd cd aa fd			call debug_vector  
59d0				endm  
# End of macro CALLMONITOR
59d0					endif 
59d0			 
59d0					FORTH_DSP_VALUEHL 
59d0 cd 4d 22			call macro_dsp_valuehl 
59d3				endm 
# End of macro FORTH_DSP_VALUEHL
59d3 e5					push hl 	; save file id 
59d4			 
59d4				if DEBUG_STORESE 
59d4					DMARK "AP1" 
59d4 f5				push af  
59d5 3a e9 59			ld a, (.dmark)  
59d8 32 a0 fd			ld (debug_mark),a  
59db 3a ea 59			ld a, (.dmark+1)  
59de 32 a1 fd			ld (debug_mark+1),a  
59e1 3a eb 59			ld a, (.dmark+2)  
59e4 32 a2 fd			ld (debug_mark+2),a  
59e7 18 03			jr .pastdmark  
59e9 ..			.dmark: db "AP1"  
59ec f1			.pastdmark: pop af  
59ed			endm  
# End of macro DMARK
59ed					CALLMONITOR 
59ed cd aa fd			call debug_vector  
59f0				endm  
# End of macro CALLMONITOR
59f0				endif 
59f0					FORTH_DSP_POP 
59f0 cd 05 23			call macro_forth_dsp_pop 
59f3				endm 
# End of macro FORTH_DSP_POP
59f3			 
59f3					FORTH_DSP_VALUEHL 
59f3 cd 4d 22			call macro_dsp_valuehl 
59f6				endm 
# End of macro FORTH_DSP_VALUEHL
59f6					;v5 FORTH_DSP_VALUE 
59f6 e5					push hl 	; save ptr to string to save 
59f7			 
59f7				if DEBUG_STORESE 
59f7					DMARK "AP1" 
59f7 f5				push af  
59f8 3a 0c 5a			ld a, (.dmark)  
59fb 32 a0 fd			ld (debug_mark),a  
59fe 3a 0d 5a			ld a, (.dmark+1)  
5a01 32 a1 fd			ld (debug_mark+1),a  
5a04 3a 0e 5a			ld a, (.dmark+2)  
5a07 32 a2 fd			ld (debug_mark+2),a  
5a0a 18 03			jr .pastdmark  
5a0c ..			.dmark: db "AP1"  
5a0f f1			.pastdmark: pop af  
5a10			endm  
# End of macro DMARK
5a10					CALLMONITOR 
5a10 cd aa fd			call debug_vector  
5a13				endm  
# End of macro CALLMONITOR
5a13				endif 
5a13					FORTH_DSP_POP 
5a13 cd 05 23			call macro_forth_dsp_pop 
5a16				endm 
# End of macro FORTH_DSP_POP
5a16			 
5a16 d1					pop de 
5a17 e1					pop hl 
5a18				if DEBUG_STORESE 
5a18					DMARK "AP2" 
5a18 f5				push af  
5a19 3a 2d 5a			ld a, (.dmark)  
5a1c 32 a0 fd			ld (debug_mark),a  
5a1f 3a 2e 5a			ld a, (.dmark+1)  
5a22 32 a1 fd			ld (debug_mark+1),a  
5a25 3a 2f 5a			ld a, (.dmark+2)  
5a28 32 a2 fd			ld (debug_mark+2),a  
5a2b 18 03			jr .pastdmark  
5a2d ..			.dmark: db "AP2"  
5a30 f1			.pastdmark: pop af  
5a31			endm  
# End of macro DMARK
5a31					CALLMONITOR 
5a31 cd aa fd			call debug_vector  
5a34				endm  
# End of macro CALLMONITOR
5a34				endif 
5a34					;inc de ; skip var type indicator 
5a34			 
5a34					; TODO how to append numerics???? 
5a34			 
5a34 cd 64 0b				call storage_append		 
5a37			 
5a37				       NEXTW 
5a37 c3 38 24			jp macro_next 
5a3a				endm 
# End of macro NEXTW
5a3a			.SDEL: 
5a3a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5a3a 6a				db WORD_SYS_CORE+86             
5a3b 86 5a			dw .OPEN            
5a3d 05				db 4 + 1 
5a3e .. 00			db "ERA",0              
5a42				endm 
# End of macro CWHEAD
5a42			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5a42			; | | > [!NOTE] 
5a42			; | | > Compatible with PicoSPINet  
5a42					FORTH_DSP_VALUEHL 
5a42 cd 4d 22			call macro_dsp_valuehl 
5a45				endm 
# End of macro FORTH_DSP_VALUEHL
5a45			;		push hl 	; save file id 
5a45			 
5a45					if DEBUG_FORTH_WORDS_KEY 
5a45						DMARK "ERA" 
5a45 f5				push af  
5a46 3a 5a 5a			ld a, (.dmark)  
5a49 32 a0 fd			ld (debug_mark),a  
5a4c 3a 5b 5a			ld a, (.dmark+1)  
5a4f 32 a1 fd			ld (debug_mark+1),a  
5a52 3a 5c 5a			ld a, (.dmark+2)  
5a55 32 a2 fd			ld (debug_mark+2),a  
5a58 18 03			jr .pastdmark  
5a5a ..			.dmark: db "ERA"  
5a5d f1			.pastdmark: pop af  
5a5e			endm  
# End of macro DMARK
5a5e						CALLMONITOR 
5a5e cd aa fd			call debug_vector  
5a61				endm  
# End of macro CALLMONITOR
5a61					endif 
5a61				if DEBUG_STORESE 
5a61					DMARK "ER1" 
5a61 f5				push af  
5a62 3a 76 5a			ld a, (.dmark)  
5a65 32 a0 fd			ld (debug_mark),a  
5a68 3a 77 5a			ld a, (.dmark+1)  
5a6b 32 a1 fd			ld (debug_mark+1),a  
5a6e 3a 78 5a			ld a, (.dmark+2)  
5a71 32 a2 fd			ld (debug_mark+2),a  
5a74 18 03			jr .pastdmark  
5a76 ..			.dmark: db "ER1"  
5a79 f1			.pastdmark: pop af  
5a7a			endm  
# End of macro DMARK
5a7a					CALLMONITOR 
5a7a cd aa fd			call debug_vector  
5a7d				endm  
# End of macro CALLMONITOR
5a7d				endif 
5a7d					FORTH_DSP_POP 
5a7d cd 05 23			call macro_forth_dsp_pop 
5a80				endm 
# End of macro FORTH_DSP_POP
5a80			 
5a80			;		pop hl 
5a80			 
5a80 cd b6 06				call storage_erase 
5a83				       NEXTW 
5a83 c3 38 24			jp macro_next 
5a86				endm 
# End of macro NEXTW
5a86			 
5a86			.OPEN: 
5a86				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5a86 6b				db WORD_SYS_CORE+87             
5a87 1a 5b			dw .READ            
5a89 05				db 4 + 1 
5a8a .. 00			db "OPEN",0              
5a8f				endm 
# End of macro CWHEAD
5a8f			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5a8f			; | | e.g. 
5a8f			; | | $01 OPEN $01 DO $01 READ . LOOP 
5a8f			; | | 
5a8f			; | | Will return with 255 blocks if the file does not exist 
5a8f			; | | > [!NOTE] 
5a8f			; | | > Compatible with PicoSPINet  
5a8f			 
5a8f					if DEBUG_FORTH_WORDS_KEY 
5a8f						DMARK "OPN" 
5a8f f5				push af  
5a90 3a a4 5a			ld a, (.dmark)  
5a93 32 a0 fd			ld (debug_mark),a  
5a96 3a a5 5a			ld a, (.dmark+1)  
5a99 32 a1 fd			ld (debug_mark+1),a  
5a9c 3a a6 5a			ld a, (.dmark+2)  
5a9f 32 a2 fd			ld (debug_mark+2),a  
5aa2 18 03			jr .pastdmark  
5aa4 ..			.dmark: db "OPN"  
5aa7 f1			.pastdmark: pop af  
5aa8			endm  
# End of macro DMARK
5aa8						CALLMONITOR 
5aa8 cd aa fd			call debug_vector  
5aab				endm  
# End of macro CALLMONITOR
5aab					endif 
5aab					; TODO handle multiple file opens 
5aab			 
5aab 3e 01			       	ld a, 1 
5aad 32 9f f9				ld (store_openext), a 
5ab0			 
5ab0					; get max extents for this file 
5ab0				 
5ab0								 
5ab0					FORTH_DSP_VALUEHL 
5ab0 cd 4d 22			call macro_dsp_valuehl 
5ab3				endm 
# End of macro FORTH_DSP_VALUEHL
5ab3			 
5ab3 65					ld h, l 
5ab4 2e 00				ld l, 0 
5ab6			 
5ab6					; store file id 
5ab6			 
5ab6 7c					ld a, h 
5ab7 32 9c f9				ld (store_filecache), a 
5aba			 
5aba				if DEBUG_STORESE 
5aba					DMARK "OPN" 
5aba f5				push af  
5abb 3a cf 5a			ld a, (.dmark)  
5abe 32 a0 fd			ld (debug_mark),a  
5ac1 3a d0 5a			ld a, (.dmark+1)  
5ac4 32 a1 fd			ld (debug_mark+1),a  
5ac7 3a d1 5a			ld a, (.dmark+2)  
5aca 32 a2 fd			ld (debug_mark+2),a  
5acd 18 03			jr .pastdmark  
5acf ..			.dmark: db "OPN"  
5ad2 f1			.pastdmark: pop af  
5ad3			endm  
# End of macro DMARK
5ad3					CALLMONITOR 
5ad3 cd aa fd			call debug_vector  
5ad6				endm  
# End of macro CALLMONITOR
5ad6				endif 
5ad6			;		push hl 
5ad6					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5ad6 cd 05 23			call macro_forth_dsp_pop 
5ad9				endm 
# End of macro FORTH_DSP_POP
5ad9			;		pop hl 
5ad9						 
5ad9 11 af f9				ld de, store_page      ; get block zero of file 
5adc cd cd 09				call storage_read 
5adf cd 07 10			call ishlzero 
5ae2 20 04			jr nz, .opfound 
5ae4			 
5ae4				; file does not exist so indicate with 255 extents in use 
5ae4			 
5ae4 3e ff			ld a, 255 
5ae6 18 29			jr .skipopeneof 
5ae8			 
5ae8			 
5ae8			.opfound: 
5ae8			 
5ae8			 
5ae8 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
5aeb 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
5aee					 
5aee				if DEBUG_STORESE 
5aee					DMARK "OPx" 
5aee f5				push af  
5aef 3a 03 5b			ld a, (.dmark)  
5af2 32 a0 fd			ld (debug_mark),a  
5af5 3a 04 5b			ld a, (.dmark+1)  
5af8 32 a1 fd			ld (debug_mark+1),a  
5afb 3a 05 5b			ld a, (.dmark+2)  
5afe 32 a2 fd			ld (debug_mark+2),a  
5b01 18 03			jr .pastdmark  
5b03 ..			.dmark: db "OPx"  
5b06 f1			.pastdmark: pop af  
5b07			endm  
# End of macro DMARK
5b07					CALLMONITOR 
5b07 cd aa fd			call debug_vector  
5b0a				endm  
# End of macro CALLMONITOR
5b0a				endif 
5b0a fe 00				cp 0 
5b0c 20 03				jr nz, .skipopeneof 
5b0e					; have opened an empty file 
5b0e					 
5b0e 32 9f f9				ld (store_openext), a 
5b11			 
5b11			.skipopeneof: 
5b11			 
5b11 6f					ld l, a 
5b12 26 00				ld h, 0 
5b14 cd 48 20				call forth_push_numhl 
5b17			 
5b17			 
5b17				       NEXTW 
5b17 c3 38 24			jp macro_next 
5b1a				endm 
# End of macro NEXTW
5b1a			.READ: 
5b1a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5b1a 6c				db WORD_SYS_CORE+88             
5b1b 44 5c			dw .EOF            
5b1d 05				db 4 + 1 
5b1e .. 00			db "READ",0              
5b23				endm 
# End of macro CWHEAD
5b23			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5b23			; | | e.g. 
5b23			; | | $01 OPEN $01 DO READ . LOOP 
5b23			; | | 
5b23			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5b23			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5b23			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5b23			; | | two bytes contain the file id and extent. 
5b23			; | |  
5b23			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5b23			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5b23			; | | > [!NOTE] 
5b23			; | | > Compatible with PicoSPINet  
5b23			 
5b23					if DEBUG_FORTH_WORDS_KEY 
5b23						DMARK "REA" 
5b23 f5				push af  
5b24 3a 38 5b			ld a, (.dmark)  
5b27 32 a0 fd			ld (debug_mark),a  
5b2a 3a 39 5b			ld a, (.dmark+1)  
5b2d 32 a1 fd			ld (debug_mark+1),a  
5b30 3a 3a 5b			ld a, (.dmark+2)  
5b33 32 a2 fd			ld (debug_mark+2),a  
5b36 18 03			jr .pastdmark  
5b38 ..			.dmark: db "REA"  
5b3b f1			.pastdmark: pop af  
5b3c			endm  
# End of macro DMARK
5b3c						CALLMONITOR 
5b3c cd aa fd			call debug_vector  
5b3f				endm  
# End of macro CALLMONITOR
5b3f					endif 
5b3f					; store_openext use it. If zero it is EOF 
5b3f			 
5b3f					; read block from current stream id 
5b3f					; if the block does not contain zero term keep reading blocks until zero found 
5b3f					; push the block to stack 
5b3f					; save the block id to stream 
5b3f			 
5b3f			 
5b3f cd 71 5c				call .testeof 
5b42 3e 01				ld a, 1 
5b44 bd					cp l 
5b45 ca 20 5c				jp z, .ateof 
5b48			 
5b48			 
5b48			;		FORTH_DSP_VALUEHL 
5b48			 
5b48			;		push hl 
5b48			 
5b48			;	if DEBUG_STORESE 
5b48			;		DMARK "REA" 
5b48			;		CALLMONITOR 
5b48			;	endif 
5b48			;		FORTH_DSP_POP 
5b48			 
5b48			;		pop hl 
5b48				 
5b48 3a 9c f9				ld a, (store_filecache) 
5b4b 67					ld h,a 
5b4c			 
5b4c 3a 9f f9				ld a, (store_openext) 
5b4f 6f					ld l, a 
5b50					 
5b50 fe 00				cp 0 
5b52 ca 20 5c				jp z, .ateof     ; dont read past eof 
5b55			 
5b55 cd b0 0c				call storage_clear_page 
5b58			 
5b58 11 af f9				ld de, store_page 
5b5b				if DEBUG_STORESE 
5b5b					DMARK "RE1" 
5b5b f5				push af  
5b5c 3a 70 5b			ld a, (.dmark)  
5b5f 32 a0 fd			ld (debug_mark),a  
5b62 3a 71 5b			ld a, (.dmark+1)  
5b65 32 a1 fd			ld (debug_mark+1),a  
5b68 3a 72 5b			ld a, (.dmark+2)  
5b6b 32 a2 fd			ld (debug_mark+2),a  
5b6e 18 03			jr .pastdmark  
5b70 ..			.dmark: db "RE1"  
5b73 f1			.pastdmark: pop af  
5b74			endm  
# End of macro DMARK
5b74					CALLMONITOR 
5b74 cd aa fd			call debug_vector  
5b77				endm  
# End of macro CALLMONITOR
5b77				endif 
5b77 cd cd 09				call storage_read 
5b7a			 
5b7a				if DEBUG_STORESE 
5b7a					DMARK "RE2" 
5b7a f5				push af  
5b7b 3a 8f 5b			ld a, (.dmark)  
5b7e 32 a0 fd			ld (debug_mark),a  
5b81 3a 90 5b			ld a, (.dmark+1)  
5b84 32 a1 fd			ld (debug_mark+1),a  
5b87 3a 91 5b			ld a, (.dmark+2)  
5b8a 32 a2 fd			ld (debug_mark+2),a  
5b8d 18 03			jr .pastdmark  
5b8f ..			.dmark: db "RE2"  
5b92 f1			.pastdmark: pop af  
5b93			endm  
# End of macro DMARK
5b93					CALLMONITOR 
5b93 cd aa fd			call debug_vector  
5b96				endm  
# End of macro CALLMONITOR
5b96				endif 
5b96 cd 07 10			call ishlzero 
5b99			;	ld a, l 
5b99			;	add h 
5b99			;	cp 0 
5b99 ca 20 5c			jp z, .readeof 
5b9c			 
5b9c				; not eof so hl should point to data to push to stack 
5b9c			 
5b9c				if DEBUG_STORESE 
5b9c					DMARK "RE3" 
5b9c f5				push af  
5b9d 3a b1 5b			ld a, (.dmark)  
5ba0 32 a0 fd			ld (debug_mark),a  
5ba3 3a b2 5b			ld a, (.dmark+1)  
5ba6 32 a1 fd			ld (debug_mark+1),a  
5ba9 3a b3 5b			ld a, (.dmark+2)  
5bac 32 a2 fd			ld (debug_mark+2),a  
5baf 18 03			jr .pastdmark  
5bb1 ..			.dmark: db "RE3"  
5bb4 f1			.pastdmark: pop af  
5bb5			endm  
# End of macro DMARK
5bb5					CALLMONITOR 
5bb5 cd aa fd			call debug_vector  
5bb8				endm  
# End of macro CALLMONITOR
5bb8				endif 
5bb8 cd b6 20			call forth_push_str 
5bbb			 
5bbb				if DEBUG_STORESE 
5bbb					DMARK "RE4" 
5bbb f5				push af  
5bbc 3a d0 5b			ld a, (.dmark)  
5bbf 32 a0 fd			ld (debug_mark),a  
5bc2 3a d1 5b			ld a, (.dmark+1)  
5bc5 32 a1 fd			ld (debug_mark+1),a  
5bc8 3a d2 5b			ld a, (.dmark+2)  
5bcb 32 a2 fd			ld (debug_mark+2),a  
5bce 18 03			jr .pastdmark  
5bd0 ..			.dmark: db "RE4"  
5bd3 f1			.pastdmark: pop af  
5bd4			endm  
# End of macro DMARK
5bd4					CALLMONITOR 
5bd4 cd aa fd			call debug_vector  
5bd7				endm  
# End of macro CALLMONITOR
5bd7				endif 
5bd7				; get next block  or mark as eof 
5bd7			 
5bd7 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
5bda 4f				ld c, a	 
5bdb 3a 9f f9			ld a, (store_openext) 
5bde			 
5bde				if DEBUG_STORESE 
5bde					DMARK "RE5" 
5bde f5				push af  
5bdf 3a f3 5b			ld a, (.dmark)  
5be2 32 a0 fd			ld (debug_mark),a  
5be5 3a f4 5b			ld a, (.dmark+1)  
5be8 32 a1 fd			ld (debug_mark+1),a  
5beb 3a f5 5b			ld a, (.dmark+2)  
5bee 32 a2 fd			ld (debug_mark+2),a  
5bf1 18 03			jr .pastdmark  
5bf3 ..			.dmark: db "RE5"  
5bf6 f1			.pastdmark: pop af  
5bf7			endm  
# End of macro DMARK
5bf7					CALLMONITOR 
5bf7 cd aa fd			call debug_vector  
5bfa				endm  
# End of macro CALLMONITOR
5bfa				endif 
5bfa b9				cp c 
5bfb 28 23			jr z, .readeof     ; at last extent 
5bfd			 
5bfd 3c					inc a 
5bfe 32 9f f9				ld (store_openext), a 
5c01			 
5c01				if DEBUG_STORESE 
5c01					DMARK "RE6" 
5c01 f5				push af  
5c02 3a 16 5c			ld a, (.dmark)  
5c05 32 a0 fd			ld (debug_mark),a  
5c08 3a 17 5c			ld a, (.dmark+1)  
5c0b 32 a1 fd			ld (debug_mark+1),a  
5c0e 3a 18 5c			ld a, (.dmark+2)  
5c11 32 a2 fd			ld (debug_mark+2),a  
5c14 18 03			jr .pastdmark  
5c16 ..			.dmark: db "RE6"  
5c19 f1			.pastdmark: pop af  
5c1a			endm  
# End of macro DMARK
5c1a					CALLMONITOR 
5c1a cd aa fd			call debug_vector  
5c1d				endm  
# End of macro CALLMONITOR
5c1d				endif 
5c1d			 
5c1d			 
5c1d				       NEXTW 
5c1d c3 38 24			jp macro_next 
5c20				endm 
# End of macro NEXTW
5c20			.ateof: 
5c20				;	ld hl, .showeof 
5c20				;	call forth_push_str 
5c20 3e 00		.readeof:	ld a, 0 
5c22 32 9f f9				ld (store_openext), a 
5c25			 
5c25					 
5c25				if DEBUG_STORESE 
5c25					DMARK "REF" 
5c25 f5				push af  
5c26 3a 3a 5c			ld a, (.dmark)  
5c29 32 a0 fd			ld (debug_mark),a  
5c2c 3a 3b 5c			ld a, (.dmark+1)  
5c2f 32 a1 fd			ld (debug_mark+1),a  
5c32 3a 3c 5c			ld a, (.dmark+2)  
5c35 32 a2 fd			ld (debug_mark+2),a  
5c38 18 03			jr .pastdmark  
5c3a ..			.dmark: db "REF"  
5c3d f1			.pastdmark: pop af  
5c3e			endm  
# End of macro DMARK
5c3e					CALLMONITOR 
5c3e cd aa fd			call debug_vector  
5c41				endm  
# End of macro CALLMONITOR
5c41				endif 
5c41				       NEXTW 
5c41 c3 38 24			jp macro_next 
5c44				endm 
# End of macro NEXTW
5c44			 
5c44			;.showeof:   db "eof", 0 
5c44			 
5c44			 
5c44			.EOF: 
5c44				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5c44 6d				db WORD_SYS_CORE+89             
5c45 86 5c			dw .FORMAT            
5c47 04				db 3 + 1 
5c48 .. 00			db "EOF",0              
5c4c				endm 
# End of macro CWHEAD
5c4c			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5c4c			; | | e.g. 
5c4c			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5c4c			; | | > [!NOTE] 
5c4c			; | | > Compatible with PicoSPINet  
5c4c					; TODO if current block id for stream is zero then push true else false 
5c4c			 
5c4c					if DEBUG_FORTH_WORDS_KEY 
5c4c						DMARK "EOF" 
5c4c f5				push af  
5c4d 3a 61 5c			ld a, (.dmark)  
5c50 32 a0 fd			ld (debug_mark),a  
5c53 3a 62 5c			ld a, (.dmark+1)  
5c56 32 a1 fd			ld (debug_mark+1),a  
5c59 3a 63 5c			ld a, (.dmark+2)  
5c5c 32 a2 fd			ld (debug_mark+2),a  
5c5f 18 03			jr .pastdmark  
5c61 ..			.dmark: db "EOF"  
5c64 f1			.pastdmark: pop af  
5c65			endm  
# End of macro DMARK
5c65						CALLMONITOR 
5c65 cd aa fd			call debug_vector  
5c68				endm  
# End of macro CALLMONITOR
5c68					endif 
5c68			 
5c68					; TODO handlue multiple file streams 
5c68			 
5c68			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5c68 cd 71 5c				call .testeof 
5c6b cd 48 20				call forth_push_numhl 
5c6e			 
5c6e			 
5c6e				       NEXTW 
5c6e c3 38 24			jp macro_next 
5c71				endm 
# End of macro NEXTW
5c71			 
5c71			.testeof: 
5c71 2e 01				ld l, 1 
5c73 3a 9e f9				ld a, (store_openmaxext) 
5c76 fe 00				cp 0 
5c78 28 09				jr  z, .eofdone   ; empty file 
5c7a 3a 9f f9				ld a, (store_openext) 
5c7d fe 00				cp 0 
5c7f 28 02				jr  z, .eofdone 
5c81 2e 00				ld l, 0 
5c83 26 00		.eofdone:	ld h, 0 
5c85 c9					ret 
5c86			 
5c86			 
5c86			 
5c86			 
5c86			.FORMAT: 
5c86				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5c86 6d				db WORD_SYS_CORE+89             
5c87 d7 5c			dw .LABEL            
5c89 07				db 6 + 1 
5c8a .. 00			db "FORMAT",0              
5c91				endm 
# End of macro CWHEAD
5c91			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5c91			; | | > [!NOTE] 
5c91			; | | > Compatible with PicoSPINet  
5c91					; TODO if current block id for stream is zero then push true else false 
5c91				 
5c91				if DEBUG_STORESE 
5c91					DMARK "FOR" 
5c91 f5				push af  
5c92 3a a6 5c			ld a, (.dmark)  
5c95 32 a0 fd			ld (debug_mark),a  
5c98 3a a7 5c			ld a, (.dmark+1)  
5c9b 32 a1 fd			ld (debug_mark+1),a  
5c9e 3a a8 5c			ld a, (.dmark+2)  
5ca1 32 a2 fd			ld (debug_mark+2),a  
5ca4 18 03			jr .pastdmark  
5ca6 ..			.dmark: db "FOR"  
5ca9 f1			.pastdmark: pop af  
5caa			endm  
# End of macro DMARK
5caa					CALLMONITOR 
5caa cd aa fd			call debug_vector  
5cad				endm  
# End of macro CALLMONITOR
5cad				endif 
5cad					; Wipes the bank check flags to cause a reformat on next block 0 read 
5cad			 
5cad 21 01 00				ld hl, 1 
5cb0 3e 00				ld a, 0 
5cb2 cd 79 02				call se_writebyte 
5cb5			 
5cb5				if DEBUG_STORESE 
5cb5					DMARK "FO0" 
5cb5 f5				push af  
5cb6 3a ca 5c			ld a, (.dmark)  
5cb9 32 a0 fd			ld (debug_mark),a  
5cbc 3a cb 5c			ld a, (.dmark+1)  
5cbf 32 a1 fd			ld (debug_mark+1),a  
5cc2 3a cc 5c			ld a, (.dmark+2)  
5cc5 32 a2 fd			ld (debug_mark+2),a  
5cc8 18 03			jr .pastdmark  
5cca ..			.dmark: db "FO0"  
5ccd f1			.pastdmark: pop af  
5cce			endm  
# End of macro DMARK
5cce					CALLMONITOR 
5cce cd aa fd			call debug_vector  
5cd1				endm  
# End of macro CALLMONITOR
5cd1				endif 
5cd1					; force bank init 
5cd1			 
5cd1 cd 25 05				call storage_get_block_0 
5cd4					 
5cd4				       NEXTW 
5cd4 c3 38 24			jp macro_next 
5cd7				endm 
# End of macro NEXTW
5cd7			.LABEL: 
5cd7				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5cd7 6d				db WORD_SYS_CORE+89             
5cd8 25 5d			dw .STOREPAGE            
5cda 06				db 5 + 1 
5cdb .. 00			db "LABEL",0              
5ce1				endm 
# End of macro CWHEAD
5ce1			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5ce1			; | | > [!NOTE] 
5ce1			; | | > Compatible with PicoSPINet  
5ce1					; TODO test to see if bank is selected 
5ce1				 
5ce1					if DEBUG_FORTH_WORDS_KEY 
5ce1						DMARK "LBL" 
5ce1 f5				push af  
5ce2 3a f6 5c			ld a, (.dmark)  
5ce5 32 a0 fd			ld (debug_mark),a  
5ce8 3a f7 5c			ld a, (.dmark+1)  
5ceb 32 a1 fd			ld (debug_mark+1),a  
5cee 3a f8 5c			ld a, (.dmark+2)  
5cf1 32 a2 fd			ld (debug_mark+2),a  
5cf4 18 03			jr .pastdmark  
5cf6 ..			.dmark: db "LBL"  
5cf9 f1			.pastdmark: pop af  
5cfa			endm  
# End of macro DMARK
5cfa						CALLMONITOR 
5cfa cd aa fd			call debug_vector  
5cfd				endm  
# End of macro CALLMONITOR
5cfd					endif 
5cfd			;	if DEBUG_STORESE 
5cfd			;		DMARK "LBL" 
5cfd			;		CALLMONITOR 
5cfd			;	endif 
5cfd					FORTH_DSP_VALUEHL 
5cfd cd 4d 22			call macro_dsp_valuehl 
5d00				endm 
# End of macro FORTH_DSP_VALUEHL
5d00					;v5FORTH_DSP_VALUE 
5d00					 
5d00			;		push hl 
5d00					FORTH_DSP_POP 
5d00 cd 05 23			call macro_forth_dsp_pop 
5d03				endm 
# End of macro FORTH_DSP_POP
5d03			;		pop hl 
5d03			 
5d03			;v5		inc hl   ; move past the type marker 
5d03			 
5d03				if DEBUG_STORESE 
5d03					DMARK "LBl" 
5d03 f5				push af  
5d04 3a 18 5d			ld a, (.dmark)  
5d07 32 a0 fd			ld (debug_mark),a  
5d0a 3a 19 5d			ld a, (.dmark+1)  
5d0d 32 a1 fd			ld (debug_mark+1),a  
5d10 3a 1a 5d			ld a, (.dmark+2)  
5d13 32 a2 fd			ld (debug_mark+2),a  
5d16 18 03			jr .pastdmark  
5d18 ..			.dmark: db "LBl"  
5d1b f1			.pastdmark: pop af  
5d1c			endm  
# End of macro DMARK
5d1c					CALLMONITOR 
5d1c cd aa fd			call debug_vector  
5d1f				endm  
# End of macro CALLMONITOR
5d1f				endif 
5d1f cd 49 06				call storage_label 
5d22			 
5d22				       NEXTW 
5d22 c3 38 24			jp macro_next 
5d25				endm 
# End of macro NEXTW
5d25			.STOREPAGE: 
5d25				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5d25 6d				db WORD_SYS_CORE+89             
5d26 58 5d			dw .LABELS            
5d28 0a				db 9 + 1 
5d29 .. 00			db "STOREPAGE",0              
5d33				endm 
# End of macro CWHEAD
5d33			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5d33			; | | > [!NOTE] 
5d33			; | | > Compatible with PicoSPINet  
5d33					; TODO test to see if bank is selected 
5d33				 
5d33					if DEBUG_FORTH_WORDS_KEY 
5d33						DMARK "STP" 
5d33 f5				push af  
5d34 3a 48 5d			ld a, (.dmark)  
5d37 32 a0 fd			ld (debug_mark),a  
5d3a 3a 49 5d			ld a, (.dmark+1)  
5d3d 32 a1 fd			ld (debug_mark+1),a  
5d40 3a 4a 5d			ld a, (.dmark+2)  
5d43 32 a2 fd			ld (debug_mark+2),a  
5d46 18 03			jr .pastdmark  
5d48 ..			.dmark: db "STP"  
5d4b f1			.pastdmark: pop af  
5d4c			endm  
# End of macro DMARK
5d4c						CALLMONITOR 
5d4c cd aa fd			call debug_vector  
5d4f				endm  
# End of macro CALLMONITOR
5d4f					endif 
5d4f			;	if DEBUG_STORESE 
5d4f			;		DMARK "STP" 
5d4f			;		CALLMONITOR 
5d4f			;	endif 
5d4f			 
5d4f 21 af f9			ld hl, store_page 
5d52 cd 48 20			call forth_push_numhl 
5d55			 
5d55			 
5d55				       NEXTW 
5d55 c3 38 24			jp macro_next 
5d58				endm 
# End of macro NEXTW
5d58			.LABELS: 
5d58				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5d58 6d				db WORD_SYS_CORE+89             
5d59 e2 5d			dw .SCONST1            
5d5b 07				db 6 + 1 
5d5c .. 00			db "LABELS",0              
5d63				endm 
# End of macro CWHEAD
5d63			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5d63			; | | > [!CAUTION] 
5d63			; | | > *NOT* Compatible with PicoSPINet  
5d63					;  
5d63			 
5d63					; save the current device selected to restore afterwards 
5d63				 
5d63 3a 95 f9				ld a, (spi_device) 
5d66 f5					push af 
5d67			 
5d67			 
5d67					; run through each of the banks 
5d67			 
5d67 21 01 00				ld hl, 1 
5d6a cd 48 20				call forth_push_numhl 
5d6d 3e ff				ld a, SPI_CE_HIGH 
5d6f cb 87				res SPI_CE0, a 
5d71 32 95 f9				ld (spi_device), a 
5d74 cd 25 05				call storage_get_block_0 
5d77 21 b2 f9				ld hl, store_page+3 
5d7a cd b6 20				call forth_push_str 
5d7d			 
5d7d					 
5d7d 21 02 00				ld hl, 2 
5d80 cd 48 20				call forth_push_numhl 
5d83 3e ff				ld a, SPI_CE_HIGH 
5d85 cb 8f				res SPI_CE1, a 
5d87 32 95 f9				ld (spi_device), a 
5d8a cd 25 05				call storage_get_block_0 
5d8d 21 b2 f9				ld hl, store_page+3 
5d90 cd b6 20				call forth_push_str 
5d93			 
5d93					 
5d93 21 03 00				ld hl, 3 
5d96 cd 48 20				call forth_push_numhl 
5d99 3e ff				ld a, SPI_CE_HIGH 
5d9b cb 97				res SPI_CE2, a 
5d9d 32 95 f9				ld (spi_device), a 
5da0 cd 25 05				call storage_get_block_0 
5da3 21 b2 f9				ld hl, store_page+3 
5da6 cd b6 20				call forth_push_str 
5da9			 
5da9			 
5da9 21 04 00				ld hl, 4 
5dac cd 48 20				call forth_push_numhl 
5daf 3e ff				ld a, SPI_CE_HIGH 
5db1 cb 9f				res SPI_CE3, a 
5db3 32 95 f9				ld (spi_device), a 
5db6 cd 25 05				call storage_get_block_0 
5db9 21 b2 f9				ld hl, store_page+3 
5dbc cd b6 20				call forth_push_str 
5dbf			 
5dbf					 
5dbf			 
5dbf 21 05 00				ld hl, 5 
5dc2 cd 48 20				call forth_push_numhl 
5dc5 3e ff				ld a, SPI_CE_HIGH 
5dc7 cb a7				res SPI_CE4, a 
5dc9 32 95 f9				ld (spi_device), a 
5dcc cd 25 05				call storage_get_block_0 
5dcf 21 b2 f9				ld hl, store_page+3 
5dd2 cd b6 20				call forth_push_str 
5dd5			 
5dd5					 
5dd5					; push fixed count of storage devices (on board) for now 
5dd5			 
5dd5 21 05 00				ld hl, 5 
5dd8 cd 48 20				call forth_push_numhl 
5ddb			 
5ddb					; restore selected device  
5ddb				 
5ddb f1					pop af 
5ddc 32 95 f9				ld (spi_device), a 
5ddf			 
5ddf				       NEXTW 
5ddf c3 38 24			jp macro_next 
5de2				endm 
# End of macro NEXTW
5de2			 
5de2			.SCONST1: 
5de2				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5de2 6d				db WORD_SYS_CORE+89             
5de3 f9 5d			dw .SCONST2            
5de5 07				db 6 + 1 
5de6 .. 00			db "FILEID",0              
5ded				endm 
# End of macro CWHEAD
5ded			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5ded			; | | > [!NOTE] 
5ded			; | | > Compatible with PicoSPINet  
5ded 3a 9c f9				ld a, (store_filecache) 
5df0 26 00				ld h, 0 
5df2 6f					ld l, a 
5df3 cd 48 20				call forth_push_numhl 
5df6					NEXTW 
5df6 c3 38 24			jp macro_next 
5df9				endm 
# End of macro NEXTW
5df9			.SCONST2: 
5df9				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5df9 6d				db WORD_SYS_CORE+89             
5dfa 11 5e			dw .SCONST3            
5dfc 08				db 7 + 1 
5dfd .. 00			db "FILEEXT",0              
5e05				endm 
# End of macro CWHEAD
5e05			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5e05			; | | > [!NOTE] 
5e05			; | | > Compatible with PicoSPINet  
5e05 3a 9f f9				ld a, (store_openext) 
5e08 26 00				ld h, 0 
5e0a 6f					ld l, a 
5e0b cd 48 20				call forth_push_numhl 
5e0e					NEXTW 
5e0e c3 38 24			jp macro_next 
5e11				endm 
# End of macro NEXTW
5e11			.SCONST3: 
5e11				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5e11 6d				db WORD_SYS_CORE+89             
5e12 29 5e			dw .SCONST4            
5e14 08				db 7 + 1 
5e15 .. 00			db "FILEMAX",0              
5e1d				endm 
# End of macro CWHEAD
5e1d			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5e1d			; | | > [!NOTE] 
5e1d			; | | > Compatible with PicoSPINet  
5e1d 3a 9e f9				ld a, (store_openmaxext) 
5e20 26 00				ld h, 0 
5e22 6f					ld l, a 
5e23 cd 48 20				call forth_push_numhl 
5e26					NEXTW 
5e26 c3 38 24			jp macro_next 
5e29				endm 
# End of macro NEXTW
5e29			.SCONST4: 
5e29				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5e29 6d				db WORD_SYS_CORE+89             
5e2a 3f 5e			dw .SCONST5            
5e2c 09				db 8 + 1 
5e2d .. 00			db "FILEADDR",0              
5e36				endm 
# End of macro CWHEAD
5e36			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5e36			; | | > [!NOTE] 
5e36			; | | > Compatible with PicoSPINet  
5e36 2a a0 f9				ld hl, (store_openaddr) 
5e39 cd 48 20				call forth_push_numhl 
5e3c					NEXTW 
5e3c c3 38 24			jp macro_next 
5e3f				endm 
# End of macro NEXTW
5e3f			.SCONST5: 
5e3f				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5e3f 6d				db WORD_SYS_CORE+89             
5e40 60 5e			dw .SCONST6            
5e42 09				db 8 + 1 
5e43 .. 00			db "FILEPAGE",0              
5e4c				endm 
# End of macro CWHEAD
5e4c			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5e4c			; | | > [!NOTE] 
5e4c			; | | > Compatible with PicoSPINet  
5e4c 2a a0 f9				ld hl, (store_openaddr) 
5e4f e5					push hl 
5e50 c1					pop bc 
5e51 16 00				ld d, 0 
5e53 1e 40				ld e, STORE_BLOCK_PHY 
5e55 cd 3b 0f				call Div16 
5e58 c5					push bc 
5e59 e1					pop hl 
5e5a cd 48 20				call forth_push_numhl 
5e5d					NEXTW 
5e5d c3 38 24			jp macro_next 
5e60				endm 
# End of macro NEXTW
5e60			.SCONST6: 
5e60				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5e60 6d				db WORD_SYS_CORE+89             
5e61 79 5e			dw .ENDSTORAGE            
5e63 09				db 8 + 1 
5e64 .. 00			db "READCONT",0              
5e6d				endm 
# End of macro CWHEAD
5e6d			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5e6d			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5e6d			; | | a further read should, if applicable, be CONCAT to the previous read. 
5e6d			; | | > [!NOTE] 
5e6d			; | | > Compatible with PicoSPINet  
5e6d 3a a2 f9				ld a, (store_readcont) 
5e70 26 00				ld h, 0 
5e72 6f					ld l, a 
5e73 cd 48 20				call forth_push_numhl 
5e76					NEXTW 
5e76 c3 38 24			jp macro_next 
5e79				endm 
# End of macro NEXTW
5e79			.ENDSTORAGE: 
5e79			; eof 
# End of file forth_words_storage.asm
5e79			endif 
5e79				include "forth_words_device.asm" 
5e79			; Device related words 
5e79			 
5e79			; | ## Device Words 
5e79			 
5e79			;if SOUND_ENABLE 
5e79			;.NOTE: 
5e79			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5e79			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5e79			;		if DEBUG_FORTH_WORDS_KEY 
5e79			;			DMARK "NTE" 
5e79			;			CALLMONITOR 
5e79			;		endif 
5e79			; 
5e79			;	 
5e79			; 
5e79			;		NEXTW 
5e79			;.AFTERSOUND: 
5e79			;endif 
5e79			 
5e79			 
5e79			USE_GPIO: equ 0 
5e79			 
5e79			if USE_GPIO 
5e79			.GP1: 
5e79				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5e79			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5e79					NEXTW 
5e79			.GP2: 
5e79				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5e79			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5e79			 
5e79					NEXTW 
5e79			 
5e79			.GP3: 
5e79				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5e79			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5e79			 
5e79					NEXTW 
5e79			 
5e79			.GP4: 
5e79				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5e79			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5e79			 
5e79					NEXTW 
5e79			.SIN: 
5e79			 
5e79			 
5e79			endif 
5e79			 
5e79			 
5e79				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5e79 33				db WORD_SYS_CORE+31             
5e7a ae 5e			dw .SOUT            
5e7c 03				db 2 + 1 
5e7d .. 00			db "IN",0              
5e80				endm 
# End of macro CWHEAD
5e80			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5e80					if DEBUG_FORTH_WORDS_KEY 
5e80						DMARK "IN." 
5e80 f5				push af  
5e81 3a 95 5e			ld a, (.dmark)  
5e84 32 a0 fd			ld (debug_mark),a  
5e87 3a 96 5e			ld a, (.dmark+1)  
5e8a 32 a1 fd			ld (debug_mark+1),a  
5e8d 3a 97 5e			ld a, (.dmark+2)  
5e90 32 a2 fd			ld (debug_mark+2),a  
5e93 18 03			jr .pastdmark  
5e95 ..			.dmark: db "IN."  
5e98 f1			.pastdmark: pop af  
5e99			endm  
# End of macro DMARK
5e99						CALLMONITOR 
5e99 cd aa fd			call debug_vector  
5e9c				endm  
# End of macro CALLMONITOR
5e9c					endif 
5e9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e9c cd 4d 22			call macro_dsp_valuehl 
5e9f				endm 
# End of macro FORTH_DSP_VALUEHL
5e9f			 
5e9f e5					push hl 
5ea0			 
5ea0					; destroy value TOS 
5ea0			 
5ea0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ea0 cd 05 23			call macro_forth_dsp_pop 
5ea3				endm 
# End of macro FORTH_DSP_POP
5ea3			 
5ea3					; one value on hl get other one back 
5ea3			 
5ea3 c1					pop bc 
5ea4			 
5ea4					; do the sub 
5ea4			;		ex de, hl 
5ea4			 
5ea4 ed 68				in l,(c) 
5ea6			 
5ea6					; save it 
5ea6			 
5ea6 26 00				ld h,0 
5ea8			 
5ea8					; TODO push value back onto stack for another op etc 
5ea8			 
5ea8 cd 48 20				call forth_push_numhl 
5eab					NEXTW 
5eab c3 38 24			jp macro_next 
5eae				endm 
# End of macro NEXTW
5eae			.SOUT: 
5eae				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5eae 34				db WORD_SYS_CORE+32             
5eaf 01 5f			dw .SPIO            
5eb1 04				db 3 + 1 
5eb2 .. 00			db "OUT",0              
5eb6				endm 
# End of macro CWHEAD
5eb6			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5eb6					if DEBUG_FORTH_WORDS_KEY 
5eb6						DMARK "OUT" 
5eb6 f5				push af  
5eb7 3a cb 5e			ld a, (.dmark)  
5eba 32 a0 fd			ld (debug_mark),a  
5ebd 3a cc 5e			ld a, (.dmark+1)  
5ec0 32 a1 fd			ld (debug_mark+1),a  
5ec3 3a cd 5e			ld a, (.dmark+2)  
5ec6 32 a2 fd			ld (debug_mark+2),a  
5ec9 18 03			jr .pastdmark  
5ecb ..			.dmark: db "OUT"  
5ece f1			.pastdmark: pop af  
5ecf			endm  
# End of macro DMARK
5ecf						CALLMONITOR 
5ecf cd aa fd			call debug_vector  
5ed2				endm  
# End of macro CALLMONITOR
5ed2					endif 
5ed2			 
5ed2					; get port 
5ed2			 
5ed2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ed2 cd 4d 22			call macro_dsp_valuehl 
5ed5				endm 
# End of macro FORTH_DSP_VALUEHL
5ed5			 
5ed5 e5					push hl 
5ed6			 
5ed6					; destroy value TOS 
5ed6			 
5ed6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ed6 cd 05 23			call macro_forth_dsp_pop 
5ed9				endm 
# End of macro FORTH_DSP_POP
5ed9			 
5ed9					; get byte to send 
5ed9			 
5ed9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ed9 cd 4d 22			call macro_dsp_valuehl 
5edc				endm 
# End of macro FORTH_DSP_VALUEHL
5edc			 
5edc			;		push hl 
5edc			 
5edc					; destroy value TOS 
5edc			 
5edc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5edc cd 05 23			call macro_forth_dsp_pop 
5edf				endm 
# End of macro FORTH_DSP_POP
5edf			 
5edf					; one value on hl get other one back 
5edf			 
5edf			;		pop hl 
5edf			 
5edf c1					pop bc 
5ee0			 
5ee0					if DEBUG_FORTH_WORDS 
5ee0						DMARK "OUT" 
5ee0 f5				push af  
5ee1 3a f5 5e			ld a, (.dmark)  
5ee4 32 a0 fd			ld (debug_mark),a  
5ee7 3a f6 5e			ld a, (.dmark+1)  
5eea 32 a1 fd			ld (debug_mark+1),a  
5eed 3a f7 5e			ld a, (.dmark+2)  
5ef0 32 a2 fd			ld (debug_mark+2),a  
5ef3 18 03			jr .pastdmark  
5ef5 ..			.dmark: db "OUT"  
5ef8 f1			.pastdmark: pop af  
5ef9			endm  
# End of macro DMARK
5ef9						CALLMONITOR 
5ef9 cd aa fd			call debug_vector  
5efc				endm  
# End of macro CALLMONITOR
5efc					endif 
5efc			 
5efc ed 69				out (c), l 
5efe			 
5efe					NEXTW 
5efe c3 38 24			jp macro_next 
5f01				endm 
# End of macro NEXTW
5f01			 
5f01			 
5f01			.SPIO: 
5f01			 
5f01			if STORAGE_SE 
5f01				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5f01 51				db WORD_SYS_CORE+61             
5f02 12 5f			dw .SPICEH            
5f04 07				db 6 + 1 
5f05 .. 00			db "SPICEL",0              
5f0c				endm 
# End of macro CWHEAD
5f0c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5f0c			 
5f0c cd 22 02				call spi_ce_low 
5f0f			    NEXTW 
5f0f c3 38 24			jp macro_next 
5f12				endm 
# End of macro NEXTW
5f12			 
5f12			.SPICEH: 
5f12				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5f12 51				db WORD_SYS_CORE+61             
5f13 23 5f			dw .SPIOb            
5f15 07				db 6 + 1 
5f16 .. 00			db "SPICEH",0              
5f1d				endm 
# End of macro CWHEAD
5f1d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5f1d			 
5f1d cd 11 02				call spi_ce_high 
5f20			    NEXTW 
5f20 c3 38 24			jp macro_next 
5f23				endm 
# End of macro NEXTW
5f23			 
5f23			 
5f23			.SPIOb: 
5f23			 
5f23				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5f23 51				db WORD_SYS_CORE+61             
5f24 55 5f			dw .SPII            
5f26 05				db 4 + 1 
5f27 .. 00			db "SPIO",0              
5f2c				endm 
# End of macro CWHEAD
5f2c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5f2c			 
5f2c					if DEBUG_FORTH_WORDS_KEY 
5f2c						DMARK "SPo" 
5f2c f5				push af  
5f2d 3a 41 5f			ld a, (.dmark)  
5f30 32 a0 fd			ld (debug_mark),a  
5f33 3a 42 5f			ld a, (.dmark+1)  
5f36 32 a1 fd			ld (debug_mark+1),a  
5f39 3a 43 5f			ld a, (.dmark+2)  
5f3c 32 a2 fd			ld (debug_mark+2),a  
5f3f 18 03			jr .pastdmark  
5f41 ..			.dmark: db "SPo"  
5f44 f1			.pastdmark: pop af  
5f45			endm  
# End of macro DMARK
5f45						CALLMONITOR 
5f45 cd aa fd			call debug_vector  
5f48				endm  
# End of macro CALLMONITOR
5f48					endif 
5f48					; get port 
5f48			 
5f48			 
5f48					; get byte to send 
5f48			 
5f48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5f48 cd 4d 22			call macro_dsp_valuehl 
5f4b				endm 
# End of macro FORTH_DSP_VALUEHL
5f4b			 
5f4b			;		push hl    ; u1  
5f4b			 
5f4b					; destroy value TOS 
5f4b			 
5f4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5f4b cd 05 23			call macro_forth_dsp_pop 
5f4e				endm 
# End of macro FORTH_DSP_POP
5f4e			 
5f4e					; one value on hl get other one back 
5f4e			 
5f4e			;		pop hl   ; u2 - addr 
5f4e			 
5f4e					; TODO Send SPI byte 
5f4e			 
5f4e			;		push hl 
5f4e			;		call spi_ce_low 
5f4e			;		pop hl 
5f4e 7d					ld a, l 
5f4f cd 10 01				call spi_send_byte 
5f52			;		call spi_ce_high 
5f52			 
5f52					NEXTW 
5f52 c3 38 24			jp macro_next 
5f55				endm 
# End of macro NEXTW
5f55			 
5f55			.SPII: 
5f55				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5f55 52				db WORD_SYS_CORE+62             
5f56 be 5f			dw .SESEL            
5f58 06				db 5 + 1 
5f59 .. 00			db "SPII",0              
5f5e				endm 
# End of macro CWHEAD
5f5e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5f5e					if DEBUG_FORTH_WORDS_KEY 
5f5e						DMARK "SPi" 
5f5e f5				push af  
5f5f 3a 73 5f			ld a, (.dmark)  
5f62 32 a0 fd			ld (debug_mark),a  
5f65 3a 74 5f			ld a, (.dmark+1)  
5f68 32 a1 fd			ld (debug_mark+1),a  
5f6b 3a 75 5f			ld a, (.dmark+2)  
5f6e 32 a2 fd			ld (debug_mark+2),a  
5f71 18 03			jr .pastdmark  
5f73 ..			.dmark: db "SPi"  
5f76 f1			.pastdmark: pop af  
5f77			endm  
# End of macro DMARK
5f77						CALLMONITOR 
5f77 cd aa fd			call debug_vector  
5f7a				endm  
# End of macro CALLMONITOR
5f7a					endif 
5f7a			 
5f7a					; TODO Get SPI byte 
5f7a			 
5f7a cd 37 01				call spi_read_byte 
5f7d			 
5f7d					if DEBUG_FORTH_WORDS 
5f7d						DMARK "Si2" 
5f7d f5				push af  
5f7e 3a 92 5f			ld a, (.dmark)  
5f81 32 a0 fd			ld (debug_mark),a  
5f84 3a 93 5f			ld a, (.dmark+1)  
5f87 32 a1 fd			ld (debug_mark+1),a  
5f8a 3a 94 5f			ld a, (.dmark+2)  
5f8d 32 a2 fd			ld (debug_mark+2),a  
5f90 18 03			jr .pastdmark  
5f92 ..			.dmark: db "Si2"  
5f95 f1			.pastdmark: pop af  
5f96			endm  
# End of macro DMARK
5f96						CALLMONITOR 
5f96 cd aa fd			call debug_vector  
5f99				endm  
# End of macro CALLMONITOR
5f99					endif 
5f99 26 00				ld h, 0 
5f9b 6f					ld l, a 
5f9c					if DEBUG_FORTH_WORDS 
5f9c						DMARK "Si3" 
5f9c f5				push af  
5f9d 3a b1 5f			ld a, (.dmark)  
5fa0 32 a0 fd			ld (debug_mark),a  
5fa3 3a b2 5f			ld a, (.dmark+1)  
5fa6 32 a1 fd			ld (debug_mark+1),a  
5fa9 3a b3 5f			ld a, (.dmark+2)  
5fac 32 a2 fd			ld (debug_mark+2),a  
5faf 18 03			jr .pastdmark  
5fb1 ..			.dmark: db "Si3"  
5fb4 f1			.pastdmark: pop af  
5fb5			endm  
# End of macro DMARK
5fb5						CALLMONITOR 
5fb5 cd aa fd			call debug_vector  
5fb8				endm  
# End of macro CALLMONITOR
5fb8					endif 
5fb8 cd 48 20				call forth_push_numhl 
5fbb			 
5fbb					NEXTW 
5fbb c3 38 24			jp macro_next 
5fbe				endm 
# End of macro NEXTW
5fbe			 
5fbe			 
5fbe			 
5fbe			.SESEL: 
5fbe				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5fbe 66				db WORD_SYS_CORE+82             
5fbf 67 60			dw .CARTDEV            
5fc1 05				db 4 + 1 
5fc2 .. 00			db "BANK",0              
5fc7				endm 
# End of macro CWHEAD
5fc7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5fc7					if DEBUG_FORTH_WORDS_KEY 
5fc7						DMARK "BNK" 
5fc7 f5				push af  
5fc8 3a dc 5f			ld a, (.dmark)  
5fcb 32 a0 fd			ld (debug_mark),a  
5fce 3a dd 5f			ld a, (.dmark+1)  
5fd1 32 a1 fd			ld (debug_mark+1),a  
5fd4 3a de 5f			ld a, (.dmark+2)  
5fd7 32 a2 fd			ld (debug_mark+2),a  
5fda 18 03			jr .pastdmark  
5fdc ..			.dmark: db "BNK"  
5fdf f1			.pastdmark: pop af  
5fe0			endm  
# End of macro DMARK
5fe0						CALLMONITOR 
5fe0 cd aa fd			call debug_vector  
5fe3				endm  
# End of macro CALLMONITOR
5fe3					endif 
5fe3			 
5fe3 3e ff				ld a, 255 
5fe5 32 98 f9				ld (spi_cartdev), a 
5fe8			 
5fe8					; get bank 
5fe8			 
5fe8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fe8 cd 4d 22			call macro_dsp_valuehl 
5feb				endm 
# End of macro FORTH_DSP_VALUEHL
5feb			 
5feb			;		push hl 
5feb			 
5feb					; destroy value TOS 
5feb			 
5feb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5feb cd 05 23			call macro_forth_dsp_pop 
5fee				endm 
# End of macro FORTH_DSP_POP
5fee			 
5fee					; one value on hl get other one back 
5fee			 
5fee			;		pop hl 
5fee			 
5fee			 
5fee 0e ff				ld c, SPI_CE_HIGH 
5ff0 06 30				ld b, '0'    ; human readable bank number 
5ff2			 
5ff2 7d					ld a, l 
5ff3			 
5ff3					if DEBUG_FORTH_WORDS 
5ff3						DMARK "BNK" 
5ff3 f5				push af  
5ff4 3a 08 60			ld a, (.dmark)  
5ff7 32 a0 fd			ld (debug_mark),a  
5ffa 3a 09 60			ld a, (.dmark+1)  
5ffd 32 a1 fd			ld (debug_mark+1),a  
6000 3a 0a 60			ld a, (.dmark+2)  
6003 32 a2 fd			ld (debug_mark+2),a  
6006 18 03			jr .pastdmark  
6008 ..			.dmark: db "BNK"  
600b f1			.pastdmark: pop af  
600c			endm  
# End of macro DMARK
600c						CALLMONITOR 
600c cd aa fd			call debug_vector  
600f				endm  
# End of macro CALLMONITOR
600f					endif 
600f			 
600f					; active low 
600f			 
600f fe 00				cp 0 
6011 28 28				jr z, .bset 
6013 fe 01				cp 1 
6015 20 04				jr nz, .b2 
6017 cb 81				res 0, c 
6019 06 31				ld b, '1'    ; human readable bank number 
601b fe 02		.b2:		cp 2 
601d 20 04				jr nz, .b3 
601f cb 89				res 1, c 
6021 06 32				ld b, '2'    ; human readable bank number 
6023 fe 03		.b3:		cp 3 
6025 20 04				jr nz, .b4 
6027 cb 91				res 2, c 
6029 06 33				ld b, '3'    ; human readable bank number 
602b fe 04		.b4:		cp 4 
602d 20 04				jr nz, .b5 
602f cb 99				res 3, c 
6031 06 34				ld b, '4'    ; human readable bank number 
6033 fe 05		.b5:		cp 5 
6035 20 04				jr nz, .bset 
6037 cb a1				res 4, c 
6039 06 35				ld b, '5'    ; human readable bank number 
603b			 
603b			.bset: 
603b 79					ld a, c 
603c 32 95 f9				ld (spi_device),a 
603f 78					ld a, b 
6040 32 94 f9				ld (spi_device_id),a 
6043					if DEBUG_FORTH_WORDS 
6043						DMARK "BN2" 
6043 f5				push af  
6044 3a 58 60			ld a, (.dmark)  
6047 32 a0 fd			ld (debug_mark),a  
604a 3a 59 60			ld a, (.dmark+1)  
604d 32 a1 fd			ld (debug_mark+1),a  
6050 3a 5a 60			ld a, (.dmark+2)  
6053 32 a2 fd			ld (debug_mark+2),a  
6056 18 03			jr .pastdmark  
6058 ..			.dmark: db "BN2"  
605b f1			.pastdmark: pop af  
605c			endm  
# End of macro DMARK
605c						CALLMONITOR 
605c cd aa fd			call debug_vector  
605f				endm  
# End of macro CALLMONITOR
605f					endif 
605f			 
605f					; set default SPI clk pulse time as disabled for BANK use 
605f			 
605f 3e 00				ld a, 0 
6061 32 99 f9				ld (spi_clktime), a 
6064			 
6064					NEXTW 
6064 c3 38 24			jp macro_next 
6067				endm 
# End of macro NEXTW
6067			 
6067			.CARTDEV: 
6067				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
6067 66				db WORD_SYS_CORE+82             
6068 15 61			dw .ENDDEVICE            
606a 08				db 7 + 1 
606b .. 00			db "CARTDEV",0              
6073				endm 
# End of macro CWHEAD
6073			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
6073					if DEBUG_FORTH_WORDS_KEY 
6073						DMARK "CDV" 
6073 f5				push af  
6074 3a 88 60			ld a, (.dmark)  
6077 32 a0 fd			ld (debug_mark),a  
607a 3a 89 60			ld a, (.dmark+1)  
607d 32 a1 fd			ld (debug_mark+1),a  
6080 3a 8a 60			ld a, (.dmark+2)  
6083 32 a2 fd			ld (debug_mark+2),a  
6086 18 03			jr .pastdmark  
6088 ..			.dmark: db "CDV"  
608b f1			.pastdmark: pop af  
608c			endm  
# End of macro DMARK
608c						CALLMONITOR 
608c cd aa fd			call debug_vector  
608f				endm  
# End of macro CALLMONITOR
608f					endif 
608f			 
608f					; disable se storage bank selection 
608f			 
608f 3e ff				ld a, SPI_CE_HIGH		; ce high 
6091 32 95 f9				ld (spi_device), a 
6094			 
6094					; get bank 
6094			 
6094					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6094 cd 4d 22			call macro_dsp_valuehl 
6097				endm 
# End of macro FORTH_DSP_VALUEHL
6097			 
6097			;		push hl 
6097			 
6097					; destroy value TOS 
6097			 
6097					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6097 cd 05 23			call macro_forth_dsp_pop 
609a				endm 
# End of macro FORTH_DSP_POP
609a			 
609a					; one value on hl get other one back 
609a			 
609a			;		pop hl 
609a			 
609a					; active low 
609a			 
609a 0e ff				ld c, 255 
609c			 
609c 7d					ld a, l 
609d					if DEBUG_FORTH_WORDS 
609d						DMARK "CDV" 
609d f5				push af  
609e 3a b2 60			ld a, (.dmark)  
60a1 32 a0 fd			ld (debug_mark),a  
60a4 3a b3 60			ld a, (.dmark+1)  
60a7 32 a1 fd			ld (debug_mark+1),a  
60aa 3a b4 60			ld a, (.dmark+2)  
60ad 32 a2 fd			ld (debug_mark+2),a  
60b0 18 03			jr .pastdmark  
60b2 ..			.dmark: db "CDV"  
60b5 f1			.pastdmark: pop af  
60b6			endm  
# End of macro DMARK
60b6						CALLMONITOR 
60b6 cd aa fd			call debug_vector  
60b9				endm  
# End of macro CALLMONITOR
60b9					endif 
60b9 fe 00				cp 0 
60bb 28 30				jr z, .cset 
60bd fe 01				cp 1 
60bf 20 02				jr nz, .c2 
60c1 cb 81				res 0, c 
60c3 fe 02		.c2:		cp 2 
60c5 20 02				jr nz, .c3 
60c7 cb 89				res 1, c 
60c9 fe 03		.c3:		cp 3 
60cb 20 02				jr nz, .c4 
60cd cb 91				res 2, c 
60cf fe 04		.c4:		cp 4 
60d1 20 02				jr nz, .c5 
60d3 cb 99				res 3, c 
60d5 fe 05		.c5:		cp 5 
60d7 20 02				jr nz, .c6 
60d9 cb a1				res 4, c 
60db fe 06		.c6:		cp 6 
60dd 20 02				jr nz, .c7 
60df cb a9				res 5, c 
60e1 fe 07		.c7:		cp 7 
60e3 20 02				jr nz, .c8 
60e5 cb b1				res 6, c 
60e7 fe 08		.c8:		cp 8 
60e9 20 02				jr nz, .cset 
60eb cb b9				res 7, c 
60ed 79			.cset:		ld a, c 
60ee 32 98 f9				ld (spi_cartdev),a 
60f1			 
60f1					if DEBUG_FORTH_WORDS 
60f1						DMARK "CD2" 
60f1 f5				push af  
60f2 3a 06 61			ld a, (.dmark)  
60f5 32 a0 fd			ld (debug_mark),a  
60f8 3a 07 61			ld a, (.dmark+1)  
60fb 32 a1 fd			ld (debug_mark+1),a  
60fe 3a 08 61			ld a, (.dmark+2)  
6101 32 a2 fd			ld (debug_mark+2),a  
6104 18 03			jr .pastdmark  
6106 ..			.dmark: db "CD2"  
6109 f1			.pastdmark: pop af  
610a			endm  
# End of macro DMARK
610a						CALLMONITOR 
610a cd aa fd			call debug_vector  
610d				endm  
# End of macro CALLMONITOR
610d					endif 
610d			 
610d					; set default SPI clk pulse time as 10ms for CARTDEV use 
610d			 
610d 3e 0a				ld a, $0a 
610f 32 99 f9				ld (spi_clktime), a 
6112					NEXTW 
6112 c3 38 24			jp macro_next 
6115				endm 
# End of macro NEXTW
6115			endif 
6115			 
6115			.ENDDEVICE: 
6115			; eof 
6115			 
# End of file forth_words_device.asm
6115			 
6115			; var handler 
6115			 
6115			 
6115			.VARS: 
6115				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
6115 77				db WORD_SYS_CORE+99             
6116 c6 61			dw .V0            
6118 04				db 3 + 1 
6119 .. 00			db "VAR",0              
611d				endm 
# End of macro CWHEAD
611d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
611d			;| 
611d			;| The variable name should consist of a single letter. e.g. "a" 
611d			;! If a full string is passed then only the first char is looked at 
611d			;| Any other char could exceed bounds checks!  
611d			 
611d					if DEBUG_FORTH_WORDS_KEY 
611d						DMARK "VAR" 
611d f5				push af  
611e 3a 32 61			ld a, (.dmark)  
6121 32 a0 fd			ld (debug_mark),a  
6124 3a 33 61			ld a, (.dmark+1)  
6127 32 a1 fd			ld (debug_mark+1),a  
612a 3a 34 61			ld a, (.dmark+2)  
612d 32 a2 fd			ld (debug_mark+2),a  
6130 18 03			jr .pastdmark  
6132 ..			.dmark: db "VAR"  
6135 f1			.pastdmark: pop af  
6136			endm  
# End of macro DMARK
6136						CALLMONITOR 
6136 cd aa fd			call debug_vector  
6139				endm  
# End of macro CALLMONITOR
6139					endif 
6139			 
6139					FORTH_DSP_VALUEHL 
6139 cd 4d 22			call macro_dsp_valuehl 
613c				endm 
# End of macro FORTH_DSP_VALUEHL
613c			 
613c 7e					ld a, (hl)    ; get first char on of the string 
613d			 
613d			 
613d					if DEBUG_FORTH_WORDS 
613d						DMARK "VR1" 
613d f5				push af  
613e 3a 52 61			ld a, (.dmark)  
6141 32 a0 fd			ld (debug_mark),a  
6144 3a 53 61			ld a, (.dmark+1)  
6147 32 a1 fd			ld (debug_mark+1),a  
614a 3a 54 61			ld a, (.dmark+2)  
614d 32 a2 fd			ld (debug_mark+2),a  
6150 18 03			jr .pastdmark  
6152 ..			.dmark: db "VR1"  
6155 f1			.pastdmark: pop af  
6156			endm  
# End of macro DMARK
6156						CALLMONITOR 
6156 cd aa fd			call debug_vector  
6159				endm  
# End of macro CALLMONITOR
6159					endif 
6159					 
6159 f5					push af	 
615a					FORTH_DSP_POP 
615a cd 05 23			call macro_forth_dsp_pop 
615d				endm 
# End of macro FORTH_DSP_POP
615d f1					pop af 
615e			 
615e					; convert to upper 
615e			 
615e cd 53 12				call to_upper 
6161					if DEBUG_FORTH_WORDS 
6161						DMARK "Vaa" 
6161 f5				push af  
6162 3a 76 61			ld a, (.dmark)  
6165 32 a0 fd			ld (debug_mark),a  
6168 3a 77 61			ld a, (.dmark+1)  
616b 32 a1 fd			ld (debug_mark+1),a  
616e 3a 78 61			ld a, (.dmark+2)  
6171 32 a2 fd			ld (debug_mark+2),a  
6174 18 03			jr .pastdmark  
6176 ..			.dmark: db "Vaa"  
6179 f1			.pastdmark: pop af  
617a			endm  
# End of macro DMARK
617a						CALLMONITOR 
617a cd aa fd			call debug_vector  
617d				endm  
# End of macro CALLMONITOR
617d					endif 
617d 06 41				ld b, 'A' 
617f 90					sub b			; set offset 
6180					if DEBUG_FORTH_WORDS 
6180						DMARK "Vbb" 
6180 f5				push af  
6181 3a 95 61			ld a, (.dmark)  
6184 32 a0 fd			ld (debug_mark),a  
6187 3a 96 61			ld a, (.dmark+1)  
618a 32 a1 fd			ld (debug_mark+1),a  
618d 3a 97 61			ld a, (.dmark+2)  
6190 32 a2 fd			ld (debug_mark+2),a  
6193 18 03			jr .pastdmark  
6195 ..			.dmark: db "Vbb"  
6198 f1			.pastdmark: pop af  
6199			endm  
# End of macro DMARK
6199						CALLMONITOR 
6199 cd aa fd			call debug_vector  
619c				endm  
# End of macro CALLMONITOR
619c					endif 
619c cb 27				sla a  
619e				 
619e					 
619e					if DEBUG_FORTH_WORDS 
619e						DMARK "VR2" 
619e f5				push af  
619f 3a b3 61			ld a, (.dmark)  
61a2 32 a0 fd			ld (debug_mark),a  
61a5 3a b4 61			ld a, (.dmark+1)  
61a8 32 a1 fd			ld (debug_mark+1),a  
61ab 3a b5 61			ld a, (.dmark+2)  
61ae 32 a2 fd			ld (debug_mark+2),a  
61b1 18 03			jr .pastdmark  
61b3 ..			.dmark: db "VR2"  
61b6 f1			.pastdmark: pop af  
61b7			endm  
# End of macro DMARK
61b7						CALLMONITOR 
61b7 cd aa fd			call debug_vector  
61ba				endm  
# End of macro CALLMONITOR
61ba					endif 
61ba			 
61ba 21 29 f9				ld hl, cli_var_array2 
61bd cd de 0f				call addatohl 
61c0 cd 48 20				call forth_push_numhl 
61c3			 
61c3			 
61c3				       NEXTW 
61c3 c3 38 24			jp macro_next 
61c6				endm 
# End of macro NEXTW
61c6			.V0: 
61c6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
61c6 78				db WORD_SYS_CORE+100             
61c7 de 61			dw .V0Q            
61c9 04				db 3 + 1 
61ca .. 00			db "V0!",0              
61ce				endm 
# End of macro CWHEAD
61ce			;| V0! ( u1 -- )  Store value to v0  | DONE 
61ce			 
61ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
61ce cd 4d 22			call macro_dsp_valuehl 
61d1				endm 
# End of macro FORTH_DSP_VALUEHL
61d1			 
61d1 11 5d f9				ld de, cli_var_array 
61d4			 
61d4 eb					ex de, hl 
61d5 73					ld (hl), e 
61d6 23					inc hl 
61d7 72					ld (hl), d 
61d8			 
61d8					; destroy value TOS 
61d8			 
61d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
61d8 cd 05 23			call macro_forth_dsp_pop 
61db				endm 
# End of macro FORTH_DSP_POP
61db			 
61db				       NEXTW 
61db c3 38 24			jp macro_next 
61de				endm 
# End of macro NEXTW
61de			.V0Q: 
61de				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
61de 79				db WORD_SYS_CORE+101             
61df ef 61			dw .V1S            
61e1 04				db 3 + 1 
61e2 .. 00			db "V0@",0              
61e6				endm 
# End of macro CWHEAD
61e6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
61e6 2a 5d f9				ld hl, (cli_var_array) 
61e9 cd 48 20				call forth_push_numhl 
61ec			 
61ec				       NEXTW 
61ec c3 38 24			jp macro_next 
61ef				endm 
# End of macro NEXTW
61ef			.V1S: 
61ef				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
61ef 7a				db WORD_SYS_CORE+102             
61f0 07 62			dw .V1Q            
61f2 04				db 3 + 1 
61f3 .. 00			db "V1!",0              
61f7				endm 
# End of macro CWHEAD
61f7			;| V1! ( u1 -- )  Store value to v1 | DONE 
61f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
61f7 cd 4d 22			call macro_dsp_valuehl 
61fa				endm 
# End of macro FORTH_DSP_VALUEHL
61fa			 
61fa 11 5f f9				ld de, cli_var_array+2 
61fd				 
61fd eb					ex de, hl 
61fe 73					ld (hl), e 
61ff 23					inc hl 
6200 72					ld (hl), d 
6201			 
6201					; destroy value TOS 
6201			 
6201					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6201 cd 05 23			call macro_forth_dsp_pop 
6204				endm 
# End of macro FORTH_DSP_POP
6204				       NEXTW 
6204 c3 38 24			jp macro_next 
6207				endm 
# End of macro NEXTW
6207			.V1Q: 
6207				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
6207 7b				db WORD_SYS_CORE+103             
6208 18 62			dw .V2S            
620a 04				db 3 + 1 
620b .. 00			db "V1@",0              
620f				endm 
# End of macro CWHEAD
620f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
620f 2a 5f f9				ld hl, (cli_var_array+2) 
6212 cd 48 20				call forth_push_numhl 
6215				       NEXTW 
6215 c3 38 24			jp macro_next 
6218				endm 
# End of macro NEXTW
6218			.V2S: 
6218				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
6218 7c				db WORD_SYS_CORE+104             
6219 30 62			dw .V2Q            
621b 04				db 3 + 1 
621c .. 00			db "V2!",0              
6220				endm 
# End of macro CWHEAD
6220			;| V2! ( u1 -- )  Store value to v2 | DONE 
6220					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6220 cd 4d 22			call macro_dsp_valuehl 
6223				endm 
# End of macro FORTH_DSP_VALUEHL
6223			 
6223 11 61 f9				ld de, cli_var_array+4 
6226				 
6226 eb					ex de, hl 
6227 73					ld (hl), e 
6228 23					inc hl 
6229 72					ld (hl), d 
622a			 
622a					; destroy value TOS 
622a			 
622a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
622a cd 05 23			call macro_forth_dsp_pop 
622d				endm 
# End of macro FORTH_DSP_POP
622d				       NEXTW 
622d c3 38 24			jp macro_next 
6230				endm 
# End of macro NEXTW
6230			.V2Q: 
6230				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
6230 7d				db WORD_SYS_CORE+105             
6231 41 62			dw .V3S            
6233 04				db 3 + 1 
6234 .. 00			db "V2@",0              
6238				endm 
# End of macro CWHEAD
6238			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
6238 2a 61 f9				ld hl, (cli_var_array+4) 
623b cd 48 20				call forth_push_numhl 
623e				       NEXTW 
623e c3 38 24			jp macro_next 
6241				endm 
# End of macro NEXTW
6241			.V3S: 
6241				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
6241 7c				db WORD_SYS_CORE+104             
6242 59 62			dw .V3Q            
6244 04				db 3 + 1 
6245 .. 00			db "V3!",0              
6249				endm 
# End of macro CWHEAD
6249			;| V3! ( u1 -- )  Store value to v3 | DONE 
6249					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6249 cd 4d 22			call macro_dsp_valuehl 
624c				endm 
# End of macro FORTH_DSP_VALUEHL
624c			 
624c 11 63 f9				ld de, cli_var_array+6 
624f				 
624f eb					ex de, hl 
6250 73					ld (hl), e 
6251 23					inc hl 
6252 72					ld (hl), d 
6253			 
6253					; destroy value TOS 
6253			 
6253					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6253 cd 05 23			call macro_forth_dsp_pop 
6256				endm 
# End of macro FORTH_DSP_POP
6256				       NEXTW 
6256 c3 38 24			jp macro_next 
6259				endm 
# End of macro NEXTW
6259			.V3Q: 
6259				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
6259 7d				db WORD_SYS_CORE+105             
625a 6a 62			dw .END            
625c 04				db 3 + 1 
625d .. 00			db "V3@",0              
6261				endm 
# End of macro CWHEAD
6261			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
6261 2a 63 f9				ld hl, (cli_var_array+6) 
6264 cd 48 20				call forth_push_numhl 
6267				       NEXTW 
6267 c3 38 24			jp macro_next 
626a				endm 
# End of macro NEXTW
626a			 
626a			 
626a			 
626a			 
626a			 
626a			; end of dict marker 
626a			 
626a 00			.END:    db WORD_SYS_END 
626b 00 00			dw 0 
626d 00				db 0 
626e			 
626e			; use to jp here for user dict words to save on macro expansion  
626e			 
626e			user_dict_next: 
626e				NEXTW 
626e c3 38 24			jp macro_next 
6271				endm 
# End of macro NEXTW
6271			 
6271			 
6271			user_exec: 
6271				;    ld hl, <word code> 
6271				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
6271				;    call forthexec 
6271				;    jp user_dict_next   (NEXT) 
6271			        ;    <word code bytes> 
6271 eb				ex de, hl 
6272 2a f7 f3			ld hl,(os_tok_ptr) 
6275				 
6275				FORTH_RSP_NEXT 
6275 cd ef 1f			call macro_forth_rsp_next 
6278				endm 
# End of macro FORTH_RSP_NEXT
6278			 
6278			if DEBUG_FORTH_UWORD 
6278						DMARK "UEX" 
6278 f5				push af  
6279 3a 8d 62			ld a, (.dmark)  
627c 32 a0 fd			ld (debug_mark),a  
627f 3a 8e 62			ld a, (.dmark+1)  
6282 32 a1 fd			ld (debug_mark+1),a  
6285 3a 8f 62			ld a, (.dmark+2)  
6288 32 a2 fd			ld (debug_mark+2),a  
628b 18 03			jr .pastdmark  
628d ..			.dmark: db "UEX"  
6290 f1			.pastdmark: pop af  
6291			endm  
# End of macro DMARK
6291				CALLMONITOR 
6291 cd aa fd			call debug_vector  
6294				endm  
# End of macro CALLMONITOR
6294			endif 
6294			 
6294			 
6294			 
6294 eb				ex de, hl 
6295 22 f7 f3			ld (os_tok_ptr), hl 
6298				 
6298				; Don't use next - Skips the first word in uword. 
6298			 
6298 c3 c1 24			jp exec1 
629b			;	NEXT 
629b			 
629b			 
629b			; eof 
# End of file forth_wordsv4.asm
629b			endif 
629b			;;;;;;;;;;;;;; Debug code 
629b			 
629b			 
629b			;if DEBUG_FORTH_PARSE 
629b .. 00		.nowordfound: db "No match",0 
62a4 .. 00		.compword:	db "Comparing word ",0 
62b4 .. 00		.nextwordat:	db "Next word at",0 
62c1 .. 00		.charmatch:	db "Char match",0 
62cc			;endif 
62cc			if DEBUG_FORTH_JP 
62cc			.foundword:	db "Word match. Exec..",0 
62cc			endif 
62cc			;if DEBUG_FORTH_PUSH 
62cc .. 00		.enddict:	db "Dict end. Push.",0 
62dc .. 00		.push_str:	db "Pushing string",0 
62eb .. 00		.push_num:	db "Pushing number",0 
62fa .. 00		.data_sp:	db "SP:",0 
62fe .. 00		.wordinhl:	db "Word in HL (2/0):",0 
6310 .. 00		.wordinde:	db "Word in DE (3/0):",0 
6322 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
6334			;endif 
6334			;if DEBUG_FORTH_MALLOC 
6334 .. 00		.push_malloc:	db "Malloc address",0 
6343			;endif 
6343			 
6343			 
6343			 
6343			; display malloc address and current data stack pointer  
6343			 
6343			malloc_error: 
6343 d5				push de 
6344 f5				push af 
6345 e5				push hl 
6346 cd aa 0d			call clear_display 
6349 11 69 63			ld de, .mallocerr 
634c 3e 00			ld a,0 
634e			;	ld de,os_word_scratch 
634e cd bd 0d			call str_at_display 
6351 3e 11			ld a, display_row_1+17 
6353 11 a0 fd			ld de, debug_mark 
6356 cd bd 0d			call str_at_display 
6359 cd cd 0d			call update_display 
635c				;call break_point_state 
635c cd 4e 78			call cin_wait 
635f			 
635f			;	ld a, ' ' 
635f			;	ld (os_view_disable), a 
635f cd 49 19			call bp_on 
6362 e1				pop hl 
6363 f1				pop af 
6364 d1				pop de	 
6365				CALLMONITOR 
6365 cd aa fd			call debug_vector  
6368				endm  
# End of macro CALLMONITOR
6368 c9				ret 
6369			 
6369 .. 00		.mallocerr: 	db "Malloc Error",0 
6376			;if DEBUG_FORTH_PUSH 
6376			display_data_sp: 
6376 f5				push af 
6377			 
6377				; see if disabled 
6377			 
6377			 
6377 3a aa fd			ld a, (debug_vector) 
637a fe c9			cp $C9  ; RET 
637c				;ld a, (os_view_disable) 
637c				;cp '*' 
637c 28 67			jr z, .skipdsp 
637e			 
637e e5				push hl 
637f e5				push hl 
6380 e5			push hl 
6381 cd aa 0d			call clear_display 
6384 e1			pop hl 
6385 7c				ld a,h 
6386 21 fb f3			ld hl, os_word_scratch 
6389 cd e7 11			call hexout 
638c e1				pop hl 
638d 7d				ld a,l 
638e 21 fd f3			ld hl, os_word_scratch+2 
6391 cd e7 11			call hexout 
6394 21 ff f3			ld hl, os_word_scratch+4 
6397 3e 00			ld a,0 
6399 77				ld (hl),a 
639a 11 fb f3			ld de,os_word_scratch 
639d 3e 28				ld a, display_row_2 
639f cd bd 0d				call str_at_display 
63a2 11 fe 62			ld de, .wordinhl 
63a5 3e 00			ld a, display_row_1 
63a7			 
63a7 cd bd 0d				call str_at_display 
63aa 11 a0 fd			ld de, debug_mark 
63ad 3e 11			ld a, display_row_1+17 
63af			 
63af cd bd 0d				call str_at_display 
63b2			 
63b2				; display current data stack pointer 
63b2 11 fa 62			ld de,.data_sp 
63b5 3e 30				ld a, display_row_2 + 8 
63b7 cd bd 0d				call str_at_display 
63ba			 
63ba 2a 23 f9			ld hl,(cli_data_sp) 
63bd e5				push hl 
63be 7c				ld a,h 
63bf 21 fb f3			ld hl, os_word_scratch 
63c2 cd e7 11			call hexout 
63c5 e1				pop hl 
63c6 7d				ld a,l 
63c7 21 fd f3			ld hl, os_word_scratch+2 
63ca cd e7 11			call hexout 
63cd 21 ff f3			ld hl, os_word_scratch+4 
63d0 3e 00			ld a,0 
63d2 77				ld (hl),a 
63d3 11 fb f3			ld de,os_word_scratch 
63d6 3e 33				ld a, display_row_2 + 11 
63d8 cd bd 0d				call str_at_display 
63db			 
63db			 
63db cd cd 0d			call update_display 
63de cd ed 0c			call delay1s 
63e1 cd ed 0c			call delay1s 
63e4 e1				pop hl 
63e5			.skipdsp: 
63e5 f1				pop af 
63e6 c9				ret 
63e7			 
63e7			display_data_malloc: 
63e7			 
63e7 f5				push af 
63e8 e5				push hl 
63e9 e5				push hl 
63ea e5			push hl 
63eb cd aa 0d			call clear_display 
63ee e1			pop hl 
63ef 7c				ld a,h 
63f0 21 fb f3			ld hl, os_word_scratch 
63f3 cd e7 11			call hexout 
63f6 e1				pop hl 
63f7 7d				ld a,l 
63f8 21 fd f3			ld hl, os_word_scratch+2 
63fb cd e7 11			call hexout 
63fe 21 ff f3			ld hl, os_word_scratch+4 
6401 3e 00			ld a,0 
6403 77				ld (hl),a 
6404 11 fb f3			ld de,os_word_scratch 
6407 3e 28				ld a, display_row_2 
6409 cd bd 0d				call str_at_display 
640c 11 34 63			ld de, .push_malloc 
640f 3e 00			ld a, display_row_1 
6411			 
6411 cd bd 0d				call str_at_display 
6414			 
6414				; display current data stack pointer 
6414 11 fa 62			ld de,.data_sp 
6417 3e 30				ld a, display_row_2 + 8 
6419 cd bd 0d				call str_at_display 
641c			 
641c 2a 23 f9			ld hl,(cli_data_sp) 
641f e5				push hl 
6420 7c				ld a,h 
6421 21 fb f3			ld hl, os_word_scratch 
6424 cd e7 11			call hexout 
6427 e1				pop hl 
6428 7d				ld a,l 
6429 21 fd f3			ld hl, os_word_scratch+2 
642c cd e7 11			call hexout 
642f 21 ff f3			ld hl, os_word_scratch+4 
6432 3e 00			ld a,0 
6434 77				ld (hl),a 
6435 11 fb f3			ld de,os_word_scratch 
6438 3e 33				ld a, display_row_2 + 11 
643a cd bd 0d				call str_at_display 
643d			 
643d cd cd 0d			call update_display 
6440 cd ed 0c			call delay1s 
6443 cd ed 0c			call delay1s 
6446 e1				pop hl 
6447 f1				pop af 
6448 c9				ret 
6449			;endif 
6449			 
6449			include "forth_autostart.asm" 
6449			; list of commands to perform at system start up 
6449			 
6449			startcmds: 
6449			;	dw test11 
6449			;	dw test12 
6449			;	dw test13 
6449			;	dw test14 
6449			;	dw test15 
6449			;	dw test16 
6449			;	dw test17 
6449			;	dw ifthtest1 
6449			;	dw ifthtest2 
6449			;	dw ifthtest3 
6449			;	dw mmtest1 
6449			;	dw mmtest2 
6449			;	dw mmtest3 
6449			;	dw mmtest4 
6449			;	dw mmtest5 
6449			;	dw mmtest6 
6449			;	dw iftest1 
6449			;	dw iftest2 
6449			;	dw iftest3 
6449			;	dw looptest1 
6449			;	dw looptest2 
6449			;	dw test1 
6449			;	dw test2 
6449			;	dw test3 
6449			;	dw test4 
6449			;	dw game2r 
6449			;	dw game2b1 
6449			;	dw game2b2 
6449			 
6449				; start up words that are actually useful 
6449			 
6449			;    dw spi1 
6449			;    dw spi2 
6449			;    dw spi3 
6449			;    dw spi4 
6449			;    dw spi5 
6449			;    dw spi6 
6449			;    dw spi7 
6449			; 
6449			;    dw spi8 
6449			;    dw spi9 
6449			;    dw spi10 
6449			 
6449			; file editor 
6449			;	dw edit1 
6449			;	dw edit2 
6449			;	dw edit3 
6449			 
6449			;	dw longread 
6449 6b 68			dw clrstack 
644b 9f 68			dw type 
644d			;	dw stest 
644d c4 68			dw strncpy 
644f 34 6a			dw list 
6451 25 69			dw start1 
6453 35 69			dw start2 
6455			;	dw start3 
6455			;	dw start3b 
6455			;	dw start3c 
6455			 
6455				; (unit) testing words 
6455			 
6455			;	dw mtesta 
6455			;	dw mtestb 
6455			;	dw mtestc 
6455			;	dw mtestd 
6455			;	dw mteste 
6455			 
6455				; demo/game words 
6455			 
6455			;        dw game3w 
6455			;        dw game3p 
6455			;        dw game3sc 
6455			;        dw game3vsi 
6455			;        dw game3vs 
6455				 
6455			;	dw game2b 
6455			;	dw game2bf 
6455			;	dw game2mba 
6455			;	dw game2mbas 
6455			;	dw game2mb 
6455			 
6455 65 6c			dw game1 
6457 76 6c			dw game1a 
6459 d8 6c			dw game1b 
645b 0d 6d			dw game1c 
645d 43 6d			dw game1d 
645f 74 6d			dw game1s 
6461 88 6d			dw game1t 
6463 9d 6d			dw game1f 
6465 d1 6d			dw game1z 
6467 15 6e			dw game1zz 
6469			 
6469 9e 6a			dw test5 
646b d6 6a			dw test6 
646d 0e 6b			dw test7 
646f 22 6b			dw test8 
6471 4e 6b			dw test9 
6473 64 6b			dw test10 
6475				 
6475 ec 6e		        dw ssv5 
6477 d0 6e		        dw ssv4 
6479 b4 6e		        dw ssv3 
647b 7e 6e		        dw ssv2 
647d 05 6f		        dw ssv1 
647f 4d 6f		        dw ssv1cpm 
6481			;	dw keyup 
6481			;	dw keydown 
6481			;	dw keyleft 
6481			;	dw keyright 
6481			;	dw 	keyf1 
6481			;	dw keyf2 
6481			;	dw keyf3 
6481			;	dw keyf4 
6481			;	dw keyf5 
6481			;	dw keyf6 
6481			;	dw keyf7 
6481			;	dw keyf8 
6481			;	dw keyf9 
6481			;	dw keyf10 
6481			;	dw keyf11 
6481			;	dw keyf12 
6481			;	dw keytab 
6481			;	dw keycr 
6481			;	dw keyhome 
6481			;	dw keyend 
6481			;	dw keybs 
6481 00 00			db 0, 0	 
6483			 
6483			 
6483			; File Editor 
6483			 
6483			; ( id - ) use 'e' to edit the displayed line 
6483 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
64a4 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
64d9			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
64d9 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6511			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6511			 
6511			; SPI Net support words 
6511			 
6511			; v0! = node to send to 
6511			; ( str count - ) 
6511 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
656a			 
656a			; spiputc ( char node - ) 
656a .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
659e			; spiputc ( u node - ) 
659e .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
65cc			 
65cc			; spigetc ( - n ) 
65cc .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
65f5			 
65f5			; getnode ( - n ) 
65f5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6622			 
6622			; ( str node - )  
6622 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6688			; store string ( str i - ) 
6688			 
6688			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6688 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
66dd			 
66dd			; get string ( addr i -  )    TO FIX 
66dd			 
66dd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6735			 
6735			 
6735			; NETCHAT (TODO) 
6735			; Program to allow two nodes to chat with eachother 
6735			; 
6735			; v0 - target node 
6735			;  
6735			; accept input at 0,0 
6735			; if input is string send spitype to target node 
6735			; starting at row 2,0 , while spigetchr is not zero ->  
6735			; 
6735			; 
6735			; TODO add paging of get request 
6735			 
6735			; ( node - ) 
6735 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6754 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
67ac .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6824			 
6824			 
6824			; Long read of currently open file 
6824 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
686b			 
686b			; clear stack  
686b			 
686b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
689f			 
689f			; type ( addr count - ) 
689f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
68c4			 
68c4			; some direct memory words 
68c4			; strncpy ( len t f -- t ) 
68c4			 
68c4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6925			 
6925 .. 00		start1:     	db ": bpon $00 bp ;",0 
6935 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6946 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
69c1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6a21			 
6a21 .. 00		tuck:         db ": tuck swap over ;", 0 
6a34			 
6a34			; a handy word to list items on the stack 
6a34			 
6a34 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6a9e			 
6a9e			 
6a9e			; test stack  
6a9e			; rnd8 stest 
6a9e			 
6a9e			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6a9e			 
6a9e			; random malloc and free cycles 
6a9e			 
6a9e			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6a9e			 
6a9e			; fixed malloc and free cycles 
6a9e			 
6a9e			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6a9e			 
6a9e			; fixed double string push and drop cycle  
6a9e			 
6a9e			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6a9e			 
6a9e			; consistent fixed string push and drop cycle  
6a9e			 
6a9e			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6a9e			 
6a9e			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6a9e			 
6a9e			;test1:		db ": aa 1 2 3 ;", 0 
6a9e			;test2:     	db "111 aa 888 999",0 
6a9e			;test3:     	db ": bb 77 ;",0 
6a9e			;test4:     	db "$02 $01 do i . loop bb",0 
6a9e			 
6a9e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6ad6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6b0e .. 00		test7:     	db ": box hline vline ;",0 
6b22 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6b4e .. 00		test9:     	db ": sw $01 adsp world ;",0 
6b64 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6b89			;test11:     	db "hello create .",0 
6b89			;test12:     	db "hello2 create .",0 
6b89			 
6b89			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6b89			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6b89			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6b89			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6b89			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6b89			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6b89			 
6b89			;iftest1:     	db "$0001 IF cls .",0 
6b89			;iftest2:     	db "$0000 IF cls .",0 
6b89			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6b89			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6b89			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6b89			 
6b89			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6b89			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6b89			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6b89			 
6b89			 
6b89 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6bad .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6bdd .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6c02 .. 00		sound4: db ": cha $00 ; ",0 
6c0f .. 00		sound5: db ": chb $20 ; ",0 
6c1c .. 00		sound6: db ": chc $40 ; ",0 
6c29 .. 00		sound7: db ": chd $60 ; ",0 
6c36 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6c4e .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6c65			 
6c65			 
6c65			 
6c65			 
6c65			; a small guess the number game 
6c65			 
6c65 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6c76 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6cd8			 
6cd8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6d0d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6d43 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6d74 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6d88 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6d9d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6dd1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6e15			 
6e15			; Using 'ga' save a high score across multiple runs using external storage 
6e15			 
6e15 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6e7e			 
6e7e			 
6e7e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6e7e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6e7e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6e7e			 
6e7e			; simple screen saver to test code memory reuse to destruction 
6e7e			 
6e7e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6eb4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6ed0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6eec .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6f05 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6f4d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6fa4			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6fa4			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6fa4			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6fa4			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6fa4			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6fa4			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6fa4			 
6fa4			 
6fa4			 
6fa4			; minesweeper/battleship finding game 
6fa4			; draws a game board of random ship/mine positions 
6fa4			; user enters coords to see if it hits on 
6fa4			; game ends when all are hit 
6fa4			; when hit or miss says how many may be in the area 
6fa4			 
6fa4			; setup the game board and then hide it 
6fa4			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6fa4			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6fa4			;; prompt for where to target 
6fa4			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6fa4			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6fa4			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6fa4			;game2mbht:      db ": mbckht nop ;",0 
6fa4			;game2mbms:      db ": mbcms nop ;",0 
6fa4			; TODO how many might be near by 
6fa4			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6fa4			 
6fa4			; Game 3 
6fa4			 
6fa4			; Vert scroller ski game - avoid the trees! 
6fa4			 
6fa4			; v0 score (ie turns) 
6fa4			; v1 player pos 
6fa4			; v2 left wall 
6fa4			; v3 right wall 
6fa4			 
6fa4			; Draw side walls randomly 
6fa4			 
6fa4			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6fa4			 
6fa4			; Draw player 
6fa4			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6fa4			 
6fa4			; TODO Get Key 
6fa4			 
6fa4			; TODO Move left right 
6fa4			 
6fa4			; scroll and move walls a bit 
6fa4			 
6fa4			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6fa4			 
6fa4			; main game loop 
6fa4			 
6fa4			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6fa4			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6fa4			 
6fa4			; key board defs 
6fa4			 
6fa4 .. 00		keyup:       db ": keyup $05 ;",0 
6fb2 .. 00		keydown:       db ": keydown $0a ;",0 
6fc2 .. 00		keyleft:       db ": keyleft $0b ;",0 
6fd2 .. 00		keyright:       db ": keyright $0c ;",0 
6fe3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6ff1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6fff .. 00		keyf3:       db ": keyf3 $12 ;",0 
700d .. 00		keyf4:       db ": keyf4 $13 ;",0 
701b .. 00		keyf5:       db ": keyf5 $14 ;",0 
7029 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7037 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7045 .. 00		keyf8:       db ": keyf8 $17 ;",0 
7053 .. 00		keyf9:       db ": keyf9 $18 ;",0 
7061 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7070 .. 00		keyf11:       db ": keyf11 $1a ;",0 
707f .. 00		keyf12:       db ": keyf12 $1b ;",0 
708e			 
708e .. 00		keytab:       db ": keytab $09 ;",0 
709d .. 00		keycr:       db ": keycr $0d ;",0 
70ab .. 00		keyhome:       db ": keyhome $0e ;",0 
70bb .. 00		keyend:       db ": keyend $0f ;",0 
70ca .. 00		keybs:       db ": keybs $08 ;",0 
70d8			 
70d8			   
70d8			 
70d8			 
70d8			 
70d8			; eof 
# End of file forth_autostart.asm
70d8			 
70d8			 
70d8			 
70d8			; stack over and underflow checks 
70d8			 
70d8			; init the words to detect the under/overflow 
70d8			 
70d8			chk_stk_init: 
70d8				; a vague random number to check so we dont get any "lucky" hits 
70d8 3e 2d			ld a, 45 
70da 6f				ld l, a 
70db 00				nop 
70dc 3e 17			ld a, 23 
70de 67				ld h, a 
70df			 
70df 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
70e2			 
70e2			;	ld (chk_stund), hl	; stack points.... 
70e2 22 3b fe			ld (chk_stovr), hl 
70e5 22 21 f9			ld (chk_ret_und), hl 
70e8 22 df f8			ld (chk_ret_ovr), hl 
70eb 22 5d f8			ld (chk_loop_ovr), hl 
70ee 22 5b f6			ld (chk_data_ovr), hl 
70f1 c9				ret 
70f2				 
70f2			check_stacks: 
70f2				; check all stack words 
70f2			 
70f2 e5				push hl 
70f3 d5				push de 
70f4			 
70f4			;	ld de,(chk_word) 
70f4			;	ld hl, (chk_stund)	; stack points.... 
70f4			;	if DEBUG_STK_FAULT 
70f4			;		DMARK "FAa" 
70f4			;		CALLMONITOR 
70f4			;	endif 
70f4			;	call cmp16 
70f4			;	jp z, .chk_faulta 
70f4			; 
70f4			;	ld de, sfaultsu 
70f4			;	jp .chk_fault 
70f4			 
70f4 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
70f7 ed 5b d2 f0		ld de,(chk_word) 
70fb				if DEBUG_STK_FAULT 
70fb					DMARK "FAb" 
70fb					CALLMONITOR 
70fb				endif 
70fb cd fc 0f			call cmp16 
70fe 28 06			jr z, .chk_fault1 
7100 11 a4 71			ld de, sfaultso 
7103 c3 55 71			jp .chk_fault 
7106			.chk_fault1:  
7106 2a 21 f9			ld hl, (chk_ret_und) 
7109 ed 5b d2 f0		ld de,(chk_word) 
710d				if DEBUG_STK_FAULT 
710d					DMARK "FAU" 
710d					CALLMONITOR 
710d				endif 
710d cd fc 0f			call cmp16 
7110 ca 19 71			jp z, .chk_fault2 
7113 11 b4 71			ld de, sfaultru 
7116 c3 55 71			jp .chk_fault 
7119			.chk_fault2:  
7119 2a df f8			ld hl, (chk_ret_ovr) 
711c ed 5b d2 f0		ld de,(chk_word) 
7120				if DEBUG_STK_FAULT 
7120					DMARK "FA1" 
7120					CALLMONITOR 
7120				endif 
7120 cd fc 0f			call cmp16 
7123 ca 2c 71			jp z, .chk_fault3 
7126 11 c2 71			ld de, sfaultro 
7129 c3 55 71			jp .chk_fault 
712c			.chk_fault3:  
712c 2a 5d f8			ld hl, (chk_loop_ovr) 
712f ed 5b d2 f0		ld de,(chk_word) 
7133				if DEBUG_STK_FAULT 
7133					DMARK "FA2" 
7133					CALLMONITOR 
7133				endif 
7133 cd fc 0f			call cmp16 
7136 ca 3f 71			jp z, .chk_fault4 
7139 11 dc 71			ld de, sfaultlo 
713c c3 55 71			jp .chk_fault 
713f			.chk_fault4:  
713f 2a 5b f6			ld hl, (chk_data_ovr) 
7142 ed 5b d2 f0		ld de,(chk_word) 
7146				if DEBUG_STK_FAULT 
7146					DMARK "FA3" 
7146					CALLMONITOR 
7146				endif 
7146 cd fc 0f			call cmp16 
7149 ca 52 71			jp z, .chk_fault5 
714c 11 f6 71			ld de, sfaultdo 
714f c3 55 71			jp .chk_fault 
7152			 
7152			 
7152			.chk_fault5:  
7152 d1				pop de 
7153 e1				pop hl 
7154			 
7154 c9				ret 
7155			 
7155 cd aa 0d		.chk_fault: 	call clear_display 
7158 3e 28				ld a, display_row_2 
715a cd bd 0d				call str_at_display 
715d 11 86 71				   ld de, .stackfault 
7160 3e 00				ld a, display_row_1 
7162 cd bd 0d				call str_at_display 
7165 11 a0 fd				    ld de, debug_mark 
7168 3e 11				ld a, display_row_1+17 
716a cd bd 0d				call str_at_display 
716d cd cd 0d				call update_display 
7170			 
7170				; prompt before entering montior for investigating issue 
7170			 
7170 3e 78			ld a, display_row_4 
7172 11 26 1d			ld de, endprog 
7175			 
7175 cd cd 0d			call update_display		 
7178			 
7178 cd c0 1f			call next_page_prompt 
717b			 
717b d1				pop de 
717c e1				pop hl 
717d cd 7a 1d				call monitor 
7180 cd de 23				call forth_warmstart 
7183 c3 76 1c				jp warmstart_afterauto 
7186					;jp 0 
7186					;halt 
7186			 
7186			 
7186			 
7186 .. 00		.stackfault: 	db "Stack fault:",0 
7193			 
7193 .. 00		sfaultsu: 	db	"Stack under flow",0 
71a4 .. 00		sfaultso: 	db	"Stack over flow",0 
71b4 .. 00		sfaultru:	db "RTS underflow",0 
71c2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
71dc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
71f6 .. 00		sfaultdo:	db "DTS overflow", 0 
7203			 
7203			 
7203			fault_dsp_under: 
7203 11 15 72			ld de, .dsp_under 
7206 c3 cb 72			jp .show_fault 
7209			 
7209			fault_rsp_under: 
7209 11 23 72			ld de, .rsp_under 
720c c3 cb 72			jp .show_fault 
720f			fault_loop_under: 
720f 11 31 72			ld de, .loop_under 
7212 c3 cb 72			jp .show_fault 
7215			 
7215 .. 00		.dsp_under: db "DSP Underflow",0 
7223 .. 00		.rsp_under: db "RSP Underflow",0 
7231 .. 00		.loop_under: db "LOOP Underflow",0 
7240			 
7240			 
7240 d5			type_faultn: 	push de 
7241 e5					push hl 
7242 cd aa 0d				call clear_display 
7245 11 6f 72				   ld de, .typefaultn 
7248 3e 00				ld a, display_row_1 
724a cd bd 0d				call str_at_display 
724d 11 a0 fd				    ld de, debug_mark 
7250 3e 11				ld a, display_row_1+17 
7252 cd bd 0d				call str_at_display 
7255 cd cd 0d				call update_display 
7258			 
7258				; prompt before entering montior for investigating issue 
7258			 
7258 3e 78			ld a, display_row_4 
725a 11 26 1d			ld de, endprog 
725d			 
725d cd cd 0d			call update_display		 
7260			 
7260 cd c0 1f			call next_page_prompt 
7263			 
7263 e5					push hl 
7264 d5					push de 
7265 cd 7a 1d				call monitor 
7268 cd de 23				call forth_warmstart 
726b c3 76 1c				jp warmstart_afterauto 
726e 76					halt 
726f			 
726f			 
726f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7286			 
7286 d5			type_faults: 	push de 
7287 e5					push hl 
7288 cd aa 0d				call clear_display 
728b 11 b4 72				   ld de, .typefaults 
728e 3e 00				ld a, display_row_1 
7290 cd bd 0d				call str_at_display 
7293 11 a0 fd				    ld de, debug_mark 
7296 3e 11				ld a, display_row_1+17 
7298 cd bd 0d				call str_at_display 
729b cd cd 0d				call update_display 
729e			 
729e				; prompt before entering montior for investigating issue 
729e			 
729e 3e 78			ld a, display_row_4 
72a0 11 26 1d			ld de, endprog 
72a3			 
72a3 cd cd 0d			call update_display		 
72a6			 
72a6 cd c0 1f			call next_page_prompt 
72a9			 
72a9 e1					pop hl 
72aa d1					pop de 
72ab cd 7a 1d				call monitor 
72ae cd de 23				call forth_warmstart 
72b1 c3 76 1c				jp warmstart_afterauto 
72b4			 
72b4			 
72b4 .. 00		.typefaults: db "STR Type Expected TOS!",0 
72cb			 
72cb			.show_fault: 	 
72cb d5					push de 
72cc cd aa 0d				call clear_display 
72cf d1					pop de 
72d0 3e 00				ld a, display_row_1 
72d2 cd bd 0d				call str_at_display 
72d5 11 a0 fd				    ld de, debug_mark 
72d8 3e 11				ld a, display_row_1+17 
72da cd bd 0d				call str_at_display 
72dd cd cd 0d				call update_display 
72e0			 
72e0				; prompt before entering montior for investigating issue 
72e0			 
72e0 3e 78			ld a, display_row_4 
72e2 11 26 1d			ld de, endprog 
72e5			 
72e5 cd cd 0d			call update_display		 
72e8			 
72e8 cd c0 1f			call next_page_prompt 
72eb			 
72eb e1					pop hl 
72ec d1					pop de 
72ed cd 7a 1d				call monitor 
72f0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
72f0			; TODO Make optional fault restart to cli or warm boot? 
72f0					;jp warmstart 
72f0 c3 ba 1c				jp cli 
72f3 76					halt 
72f4			 
72f4			 
72f4			; handle the auto run of code from files in storage 
72f4			 
72f4			 
72f4			include "forth_startup.asm" 
72f4			; Which startup method to use? 
72f4			; 
72f4			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
72f4			; followed by loading of a list of scripts in eeprom 
72f4			 
72f4			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
72f4			; from eeprom 
72f4			 
72f4			; Select with define in main stubs 
72f4			 
72f4			if STARTUP_V1 
72f4				include "forth_startupv1.asm" 
72f4			endif 
72f4			if STARTUP_V2 
72f4				include "forth_startupv2.asm" 
72f4			; Version 2 of the startup  
72f4			;  
72f4			; Auto load any files in bank 1 that start with a '*' 
72f4			; If no se storage then revert to using eprom 
72f4			 
72f4			 
72f4			if STORAGE_SE = 0 
72f4			 
72f4			sprompt1: db "Startup load...",0 
72f4			sprompt2: db "Run? 1=No *=End #=All",0 
72f4			 
72f4			 
72f4			 
72f4			 
72f4			forth_startup: 
72f4				ld hl, startcmds 
72f4				ld a, 0 
72f4				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
72f4			 
72f4			.start1:	push hl 
72f4				call clear_display 
72f4				ld de, sprompt1 
72f4			        ld a, display_row_1 
72f4				call str_at_display 
72f4				ld de, sprompt2 
72f4			        ld a, display_row_2 
72f4				call str_at_display 
72f4				pop hl 
72f4				push hl 
72f4				ld e,(hl) 
72f4				inc hl 
72f4				ld d,(hl) 
72f4			        ld a, display_row_3 
72f4				call str_at_display 
72f4				call update_display 
72f4			 
72f4			 
72f4				ld a, (os_last_cmd) 
72f4				cp 0 
72f4				jr z, .startprompt 
72f4				call delay250ms 
72f4				jr .startdo 
72f4				 
72f4				 
72f4			 
72f4			.startprompt: 
72f4			 
72f4				ld a,display_row_4 + display_cols - 1 
72f4			        ld de, endprg 
72f4				call str_at_display 
72f4				call update_display 
72f4				call delay1s 
72f4				call cin_wait 
72f4						 
72f4				cp '*' 
72f4				jr z, .startupend1 
72f4				cp '#' 
72f4				jr nz, .startno 
72f4				ld a, 1 
72f4				ld (os_last_cmd),a 
72f4				jr .startdo 
72f4			.startno:	cp '1' 
72f4				jr z,.startnxt  
72f4			 
72f4				; exec startup line 
72f4			.startdo:	 
72f4				pop hl 
72f4				push hl 
72f4				 
72f4				ld e,(hl) 
72f4				inc hl 
72f4				ld d,(hl) 
72f4				ex de,hl 
72f4			 
72f4				push hl 
72f4			 
72f4				ld a, 0 
72f4				;ld a, FORTH_END_BUFFER 
72f4				call strlent 
72f4				inc hl   ; include zero term to copy 
72f4				ld b,0 
72f4				ld c,l 
72f4				pop hl 
72f4				ld de, scratch 
72f4				ldir 
72f4			 
72f4			 
72f4				ld hl, scratch 
72f4				call forthparse 
72f4				call forthexec 
72f4				call forthexec_cleanup 
72f4			 
72f4				ld a, display_row_4 
72f4				ld de, endprog 
72f4			 
72f4				call update_display		 
72f4			 
72f4				ld a, (os_last_cmd) 
72f4				cp 0 
72f4				jr nz, .startnxt 
72f4				call next_page_prompt 
72f4			        call clear_display 
72f4				call update_display		 
72f4			 
72f4				; move onto next startup line? 
72f4			.startnxt: 
72f4			 
72f4				call delay250ms 
72f4				pop hl 
72f4			 
72f4				inc hl 
72f4				inc hl 
72f4			 
72f4				push hl 
72f4				ld e, (hl) 
72f4				inc hl 
72f4				ld d, (hl) 
72f4				pop hl 
72f4				; TODO replace 0 test 
72f4			 
72f4				ex de, hl 
72f4				call ishlzero 
72f4			;	ld a,e 
72f4			;	add d 
72f4			;	cp 0    ; any left to do? 
72f4				ex de, hl 
72f4				jp nz, .start1 
72f4				jr .startupend 
72f4			 
72f4			.startupend1: pop hl 
72f4			.startupend: 
72f4			 
72f4				call clear_display 
72f4				call update_display 
72f4				ret 
72f4			endif 
72f4			 
72f4			 
72f4			if STORAGE_SE 
72f4			 
72f4			;sprompt3: db "Loading from start-up file:",0 
72f4 .. 00		sprompt3: db "  Searching...",0 
7303			;sprompt4: db "(Any key to stop)",0 
7303			 
7303			 
7303			forth_autoload: 
7303			 
7303				; load block 0 of store 1 
7303				 
7303 3e fe			ld a, $fe      ; bit 0 clear 
7305 32 95 f9			ld (spi_device), a 
7308			 
7308 cd 25 05			call storage_get_block_0 
730b			 
730b 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
730e			 
730e fe 00			cp 0 
7310 c8				ret z     ; auto start not enabled 
7311			 
7311 cd aa 0d			call clear_display 
7314			 
7314				; set bank 
7314			 
7314 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
7317 32 95 f9				ld (spi_device), a 
731a			 
731a			 
731a				; generate a directory of bank 1 and search for flagged files 
731a			 
731a					if DEBUG_FORTH_WORDS_KEY 
731a						DMARK "DIR" 
731a f5				push af  
731b 3a 2f 73			ld a, (.dmark)  
731e 32 a0 fd			ld (debug_mark),a  
7321 3a 30 73			ld a, (.dmark+1)  
7324 32 a1 fd			ld (debug_mark+1),a  
7327 3a 31 73			ld a, (.dmark+2)  
732a 32 a2 fd			ld (debug_mark+2),a  
732d 18 03			jr .pastdmark  
732f ..			.dmark: db "DIR"  
7332 f1			.pastdmark: pop af  
7333			endm  
# End of macro DMARK
7333						CALLMONITOR 
7333 cd aa fd			call debug_vector  
7336				endm  
# End of macro CALLMONITOR
7336					endif 
7336			 
7336 cd 25 05			call storage_get_block_0 
7339			 
7339 21 af f9			ld hl, store_page     ; get current id count 
733c 46				ld b, (hl) 
733d 0e 00			ld c, 0    ; count of files   
733f					if DEBUG_FORTH_WORDS 
733f						DMARK "DI1" 
733f f5				push af  
7340 3a 54 73			ld a, (.dmark)  
7343 32 a0 fd			ld (debug_mark),a  
7346 3a 55 73			ld a, (.dmark+1)  
7349 32 a1 fd			ld (debug_mark+1),a  
734c 3a 56 73			ld a, (.dmark+2)  
734f 32 a2 fd			ld (debug_mark+2),a  
7352 18 03			jr .pastdmark  
7354 ..			.dmark: db "DI1"  
7357 f1			.pastdmark: pop af  
7358			endm  
# End of macro DMARK
7358						CALLMONITOR 
7358 cd aa fd			call debug_vector  
735b				endm  
# End of macro CALLMONITOR
735b					endif 
735b			 
735b				; check for empty drive 
735b			 
735b 3e 00			ld a, 0 
735d b8				cp b 
735e ca ab 73			jp z, .dirdone 
7361			 
7361				; for each of the current ids do a search for them and if found push to stack 
7361			 
7361 c5			.diritem:	push bc 
7362 21 40 00				ld hl, STORE_BLOCK_PHY 
7365 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7367 58					ld e,b 
7368			 
7368 d5					push de 
7369 e5					push hl 
736a cd aa 0d			call clear_display 
736d 3e 32			ld a, display_row_2 + 10 
736f 11 f4 72			ld de, sprompt3 
7372 cd bd 0d			call str_at_display 
7375 cd 01 0d			call active 
7378 eb				ex de, hl 
7379 3e 2f			ld a, display_row_2 + 7 
737b cd bd 0d			call str_at_display 
737e cd cd 0d			call update_display 
7381 e1				pop hl 
7382 d1				pop de 
7383			 
7383			;		if DEBUG_FORTH_WORDS 
7383			;			DMARK "DI2" 
7383			;			CALLMONITOR 
7383			;		endif 
7383			 
7383 cd a7 07				call storage_findnextid 
7386			 
7386			;		if DEBUG_FORTH_WORDS 
7386			;			DMARK "DI3" 
7386			;			CALLMONITOR 
7386			;		endif 
7386			 
7386					; if found hl will be non zero 
7386			 
7386 cd 07 10				call ishlzero 
7389			;		ld a, l 
7389			;		add h 
7389			; 
7389			;		cp 0 
7389 28 1d				jr z, .dirnotfound 
738b			 
738b					; increase count 
738b			 
738b c1					pop bc	 
738c 0c					inc c 
738d c5					push bc 
738e					 
738e			 
738e					; get file header and push the file name 
738e			 
738e 11 af f9				ld de, store_page 
7391 cd 74 04				call storage_read_block 
7394			 
7394					; push file id to stack 
7394				 
7394			 
7394					; is this a file we want to run? 
7394			 
7394 21 b2 f9				ld hl, store_page+3 
7397 7e					ld a,(hl) 
7398 fe 2a				cp '*' 
739a 20 0c				jr nz,  .dirnotfound 
739c					 
739c			 
739c			 
739c 3a af f9				ld a, (store_page) 
739f d5					push de 
73a0 e5					push hl 
73a1 c5					push bc 
73a2 cd ce 73				call .autorunf 
73a5 c1					pop bc 
73a6 e1					pop hl 
73a7 d1					pop de 
73a8			 
73a8			 
73a8			 
73a8				; save this extent 
73a8			 
73a8					; push file name 
73a8			;display file name to run 
73a8			 
73a8			;		ld hl, store_page+3 
73a8			;		if DEBUG_FORTH_WORDS 
73a8			;			DMARK "DI5" 
73a8			;			CALLMONITOR 
73a8			;		endif 
73a8			; 
73a8			;		 
73a8			; 
73a8			;		call forth_push_str 
73a8			;		if DEBUG_FORTH_WORDS 
73a8			;			DMARK "DI6" 
73a8			;			CALLMONITOR 
73a8			;		endif 
73a8			.dirnotfound: 
73a8 c1					pop bc     
73a9 10 b6				djnz .diritem 
73ab				 
73ab			.dirdone:	 
73ab					if DEBUG_FORTH_WORDS 
73ab						DMARK "DI7" 
73ab f5				push af  
73ac 3a c0 73			ld a, (.dmark)  
73af 32 a0 fd			ld (debug_mark),a  
73b2 3a c1 73			ld a, (.dmark+1)  
73b5 32 a1 fd			ld (debug_mark+1),a  
73b8 3a c2 73			ld a, (.dmark+2)  
73bb 32 a2 fd			ld (debug_mark+2),a  
73be 18 03			jr .pastdmark  
73c0 ..			.dmark: db "DI7"  
73c3 f1			.pastdmark: pop af  
73c4			endm  
# End of macro DMARK
73c4						CALLMONITOR 
73c4 cd aa fd			call debug_vector  
73c7				endm  
# End of macro CALLMONITOR
73c7					endif 
73c7			 
73c7 cd aa 0d				call clear_display 
73ca cd cd 0d				call update_display 
73cd			 
73cd c9					ret 
73ce			 
73ce			 
73ce			 
73ce			 
73ce			 
73ce			.autorunf: 
73ce			 
73ce			 
73ce				; get file id to load from and get the file name to display 
73ce			 
73ce			;		ld a, (store_page+STORE_0_FILERUN) 
73ce			 
73ce 2e 00				ld l, 0 
73d0 67					ld h, a 
73d1 11 af f9				ld de, store_page 
73d4			 
73d4					if DEBUG_FORTH_WORDS 
73d4						DMARK "ASp" 
73d4 f5				push af  
73d5 3a e9 73			ld a, (.dmark)  
73d8 32 a0 fd			ld (debug_mark),a  
73db 3a ea 73			ld a, (.dmark+1)  
73de 32 a1 fd			ld (debug_mark+1),a  
73e1 3a eb 73			ld a, (.dmark+2)  
73e4 32 a2 fd			ld (debug_mark+2),a  
73e7 18 03			jr .pastdmark  
73e9 ..			.dmark: db "ASp"  
73ec f1			.pastdmark: pop af  
73ed			endm  
# End of macro DMARK
73ed						CALLMONITOR 
73ed cd aa fd			call debug_vector  
73f0				endm  
# End of macro CALLMONITOR
73f0					endif 
73f0 cd cd 09				call storage_read 
73f3			 
73f3					if DEBUG_FORTH_WORDS 
73f3						DMARK "ASr" 
73f3 f5				push af  
73f4 3a 08 74			ld a, (.dmark)  
73f7 32 a0 fd			ld (debug_mark),a  
73fa 3a 09 74			ld a, (.dmark+1)  
73fd 32 a1 fd			ld (debug_mark+1),a  
7400 3a 0a 74			ld a, (.dmark+2)  
7403 32 a2 fd			ld (debug_mark+2),a  
7406 18 03			jr .pastdmark  
7408 ..			.dmark: db "ASr"  
740b f1			.pastdmark: pop af  
740c			endm  
# End of macro DMARK
740c						CALLMONITOR 
740c cd aa fd			call debug_vector  
740f				endm  
# End of macro CALLMONITOR
740f					endif 
740f			 
740f cd 07 10				call ishlzero 
7412 c8					ret z             ; file not found 
7413			 
7413					; display file name we are loading 
7413			 
7413 cd aa 0d				call clear_display 
7416			 
7416 3e 32				ld a, display_row_2 + 10 
7418 11 b2 f9				ld de, store_page+3 
741b cd bd 0d				call str_at_display 
741e				 
741e			; 
741e			 
741e			;	ld a, display_row_1+5 
741e			;	ld de, sprompt3 
741e			;	call str_at_display 
741e			;	ld a, display_row_2+7 
741e			;	call active 
741e			;	ex de, hl 
741e			;;	ld de, sprompt4 
741e			;	call str_at_display 
741e			; 
741e cd cd 0d			call update_display 
7421			 
7421			;	call cin_wait 
7421			;	cp 'n' 
7421			;	ret z 
7421			;	cp 'N' 
7421			;	ret z 
7421			 
7421			;	call delay1s 
7421			 
7421 3a b1 f9			ld a, (store_page+2) 
7424 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
7427 3e 01			ld a, 1  
7429 32 9f f9			ld (store_openext), a    ; save count of ext 
742c			 
742c			.autof: 
742c				; begin to read a line from file 
742c			 
742c 21 1d f4			ld hl, os_cli_cmd 
742f 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7432			  
7432			.readext: 
7432 3a 9f f9			ld a, (store_openext) 
7435 6f				ld l , a 
7436				 
7436 3a af f9			ld a, (store_page) 
7439 67				ld h, a	 
743a 11 af f9			ld de, store_page 
743d					if DEBUG_FORTH_WORDS 
743d						DMARK "ASl" 
743d f5				push af  
743e 3a 52 74			ld a, (.dmark)  
7441 32 a0 fd			ld (debug_mark),a  
7444 3a 53 74			ld a, (.dmark+1)  
7447 32 a1 fd			ld (debug_mark+1),a  
744a 3a 54 74			ld a, (.dmark+2)  
744d 32 a2 fd			ld (debug_mark+2),a  
7450 18 03			jr .pastdmark  
7452 ..			.dmark: db "ASl"  
7455 f1			.pastdmark: pop af  
7456			endm  
# End of macro DMARK
7456						CALLMONITOR 
7456 cd aa fd			call debug_vector  
7459				endm  
# End of macro CALLMONITOR
7459					endif 
7459 cd cd 09				call storage_read 
745c cd 07 10			call ishlzero 
745f c8				ret z 
7460			 
7460			; TODO copy to exec buffer 
7460			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7460			 
7460				; copy the record buffer to the cli buffer 
7460			 
7460 ed 5b 1b f6		ld de, (os_var_array) 
7464 21 b1 f9			ld hl, store_page+2 
7467			;	ex de, hl 
7467 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
746a ed b0			ldir 
746c ed 53 1b f6		ld (os_var_array), de 
7470				 
7470 3a 9f f9			ld a, (store_openext) 
7473 3c				inc a 
7474 32 9f f9			ld (store_openext), a    ; save count of ext 
7477			 
7477			 
7477			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7477				 
7477 3a a2 f9			ld a, (store_readcont) 
747a fe 00			cp 0 
747c 20 b4			jr nz, .readext 
747e			 
747e			;	jr z, .autoend 
747e			 
747e					if DEBUG_FORTH_WORDS 
747e						DMARK "ASc" 
747e f5				push af  
747f 3a 93 74			ld a, (.dmark)  
7482 32 a0 fd			ld (debug_mark),a  
7485 3a 94 74			ld a, (.dmark+1)  
7488 32 a1 fd			ld (debug_mark+1),a  
748b 3a 95 74			ld a, (.dmark+2)  
748e 32 a2 fd			ld (debug_mark+2),a  
7491 18 03			jr .pastdmark  
7493 ..			.dmark: db "ASc"  
7496 f1			.pastdmark: pop af  
7497			endm  
# End of macro DMARK
7497						CALLMONITOR 
7497 cd aa fd			call debug_vector  
749a				endm  
# End of macro CALLMONITOR
749a					endif 
749a e5				push hl	 
749b d5				push de 
749c cd 01 0d			call active 
749f eb				ex de, hl 
74a0 3e 2f			ld a, display_row_2 + 7 
74a2 cd bd 0d			call str_at_display 
74a5			 
74a5 cd cd 0d			call update_display 
74a8 d1				pop de  
74a9 e1				pop hl 
74aa			;	call delay250ms 
74aa			 
74aa			 
74aa			 
74aa			 
74aa			.autoexec: 
74aa			 
74aa			 
74aa 21 1d f4			ld hl, os_cli_cmd 
74ad					if DEBUG_FORTH_WORDS 
74ad						DMARK "ASx" 
74ad f5				push af  
74ae 3a c2 74			ld a, (.dmark)  
74b1 32 a0 fd			ld (debug_mark),a  
74b4 3a c3 74			ld a, (.dmark+1)  
74b7 32 a1 fd			ld (debug_mark+1),a  
74ba 3a c4 74			ld a, (.dmark+2)  
74bd 32 a2 fd			ld (debug_mark+2),a  
74c0 18 03			jr .pastdmark  
74c2 ..			.dmark: db "ASx"  
74c5 f1			.pastdmark: pop af  
74c6			endm  
# End of macro DMARK
74c6						CALLMONITOR 
74c6 cd aa fd			call debug_vector  
74c9				endm  
# End of macro CALLMONITOR
74c9					endif 
74c9 cd 82 24			call forthparse 
74cc cd be 24			call forthexec 
74cf cd d8 23			call forthexec_cleanup 
74d2			 
74d2			 
74d2			 
74d2 c3 2c 74			jp .autof 
74d5			;.autofdone: 
74d5			; 
74d5			;		if DEBUG_FORTH_WORDS 
74d5			;			DMARK "ASx" 
74d5			;			CALLMONITOR 
74d5			;		endif 
74d5			;;	call clear_display 
74d5			;	ret 
74d5			 
74d5			 
74d5			 
74d5			endif 
# End of file forth_startupv2.asm
74d5			endif 
74d5			 
# End of file forth_startup.asm
74d5			 
74d5			; eof 
# End of file forth_kernel.asm
74d5			;include "nascombasic.asm" 
74d5			 
74d5			 
74d5			; find out where the code ends if loaded into RAM (for SC114) 
74d5			;endofcode:  
74d5			;	nop 
74d5			 
74d5			 
74d5			; jump to nmi vector 
74d5			 
74d5			init_nmi: 
74d5 3e c9			ld a, $c9   ; RET 
74d7 32 ad fd			ld (nmi_vector), a 
74da c9				ret 
74db			nmi: 
74db e5				push hl 
74dc d5				push de 
74dd c5				push bc 
74de f5				push af 
74df cd ad fd			call nmi_vector 
74e2 f5				push af 
74e3 c5				push bc 
74e4 d5				push de 
74e5 e5				push hl 
74e6 ed 4d			reti 
74e8			 
74e8			 
74e8			; eof 
74e8			 
# End of file main.asm
74e8			include "firmware_lcd_4x40.asm" 
74e8			; **********************************************************************  
74e8			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
74e8			; **********************************************************************  
74e8			;  
74e8			; **  Written as a Small Computer Monitor App  
74e8			; **  www.scc.me.uk  
74e8			;  
74e8			; History  
74e8			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
74e8			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
74e8			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
74e8			;  
74e8			; **********************************************************************  
74e8			;  
74e8			; This program is an example of one of the methods of interfacing an   
74e8			; alphanumeric LCD module.   
74e8			;  
74e8			; In this example the display is connected to either a Z80 PIO or a   
74e8			; simple 8-bit output port.   
74e8			;  
74e8			; This interfacing method uses 4-bit data mode and uses time delays  
74e8			; rather than polling the display's ready status. As a result the   
74e8			; interface only requires 6 simple output lines:  
74e8			;   Output bit 0 = not used  
74e8			;   Output bit 1 = not used  
74e8			;   Output bit 2 = RS         High = data, Low = instruction  
74e8			;   Output bit 3 = E          Active high  
74e8			;   Output bit 4 = DB4  
74e8			;   Output bit 5 = DB5  
74e8			;   Output bit 6 = DB6  
74e8			;   Output bit 7 = DB7  
74e8			; Display's R/W is connected to 0v so it is always in write mode  
74e8			;  
74e8			; This set up should work with any system supporting the RC2014 bus  
74e8			  
74e8			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
74e8			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
74e8			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
74e8			;  
74e8			; **********************************************************************  
74e8			  
74e8			; Additonal for 4x40. E1 and E2 instead of just E   
74e8			; TODO swipe vidout signal on port a to activate E2  
74e8			  
74e8			; **********************************************************************  
74e8			; **  Constants  
74e8			; **********************************************************************  
74e8			; LCD constants required by LCD support module  
74e8			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
74e8			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
74e8			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
74e8			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
74e8			; TODO Decide which E is being set  
74e8			kLCDWidth:  EQU display_cols             ;Width in characters  
74e8			  
74e8			; **********************************************************************  
74e8			; **  Code library usage  
74e8			; **********************************************************************  
74e8			  
74e8			; send character to current cursor position  
74e8			; wraps and/or scrolls screen automatically  
74e8			  
74e8			  
74e8			  
74e8			lcd_init:  
74e8			  
74e8			; SCMonAPI functions used  
74e8			  
74e8			; Alphanumeric LCD functions used  
74e8			; no need to specify specific functions for this module  
74e8			  
74e8 3e cf		            LD   A, 11001111b  
74ea d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
74ec 3e 00		            LD   A, 00000000b  
74ee d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
74f0			  
74f0			; Initialise alphanumeric LCD module  
74f0 3e 00				ld a, 0  
74f2 32 00 fb				ld (display_lcde1e2), a  
74f5 cd 76 75		            CALL fLCD_Init      ;Initialise LCD module  
74f8 3e 01				ld a, 1  
74fa 32 00 fb				ld (display_lcde1e2), a  
74fd cd 76 75		            CALL fLCD_Init      ;Initialise LCD module  
7500			  
7500 c9				ret  
7501			  
7501			;  
7501			;;  
7501			; lcd functions  
7501			;  
7501			;  
7501			  
7501			; what is at cursor position   
7501			  
7501			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7501			;		call curptr  
7501			;		ret  
7501			  
7501			  
7501			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7501			  
7501			curptr:  
7501 c5				push bc  
7502 21 e6 fc			ld hl, display_fb0  
7505			cpr:	  
7505				; loop for cursor whole row  
7505 0e 28			ld c, display_cols  
7507 23			cpr1:	inc hl  
7508 0d				dec c  
7509 20 fc			jr nz, cpr1  
750b 05				dec b  
750c 20 f7			jr nz, cpr  
750e			  
750e				; add col	  
750e			  
750e 23			cpr2:	inc hl  
750f 1d				dec e  
7510 20 fc			jr nz, cpr2  
7512			  
7512 c1				pop bc  
7513 c9				ret  
7514				  
7514			  
7514			  
7514			  
7514			  
7514			; write the frame buffer given in hl to hardware   
7514 22 fe fa		write_display: ld (display_write_tmp), hl 	   
7517 3e 00			ld a, kLCD_Line1  
7519 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
751c 06 28			ld b, display_cols  
751e ed 5b fe fa		ld de, (display_write_tmp)  
7522 cd 6e 75			call write_len_string  
7525				  
7525				  
7525 2a fe fa			ld hl, (display_write_tmp)  
7528 11 28 00			ld de, display_cols  
752b 19				add hl,de  
752c 22 fe fa			ld (display_write_tmp),hl  
752f			  
752f				  
752f 3e 28			ld a, kLCD_Line2  
7531 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7534 06 28			ld b, display_cols  
7536 ed 5b fe fa		ld de, (display_write_tmp)  
753a cd 6e 75			call write_len_string  
753d				  
753d 2a fe fa			ld hl, (display_write_tmp)  
7540 11 28 00			ld de, display_cols  
7543 19				add hl,de  
7544 22 fe fa			ld (display_write_tmp),hl  
7547			  
7547				  
7547 3e 50			ld a, kLCD_Line3  
7549 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
754c 06 28			ld b, display_cols  
754e ed 5b fe fa		ld de, (display_write_tmp)  
7552 cd 6e 75			call write_len_string  
7555				  
7555 2a fe fa			ld hl, (display_write_tmp)  
7558 11 28 00			ld de, display_cols  
755b 19				add hl,de  
755c 22 fe fa			ld (display_write_tmp),hl  
755f			  
755f				  
755f 3e 78			ld a, kLCD_Line4  
7561 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7564 06 28			ld b, display_cols  
7566 ed 5b fe fa		ld de, (display_write_tmp)  
756a cd 6e 75			call write_len_string  
756d c9					ret  
756e				  
756e				; write out a fixed length string given in b from de  
756e			  
756e 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
756f cd db 75		            CALL fLCD_Data      ;Write character to display  
7572 13				inc de  
7573 10 f9			djnz write_len_string  
7575 c9				ret  
7576			  
7576			; Some other things to do  
7576			;            LD   A, kLCD_Clear ;Display clear  
7576			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7576			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7576			;            LD   A, kLCD_On     ;Display on with no cursor  
7576			;            ;LD   A, kLCD_Off   ;Display off  
7576			;            CALL fLCD_Inst      ;Send instruction to display  
7576			;  
7576			;  
7576			;            halt  
7576			;  
7576			;  
7576			;MsgHello:   DB  "Hello World!",0  
7576			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7576			  
7576			; Custom characters 5 pixels wide by 8 pixels high  
7576			; Up to 8 custom characters can be defined  
7576			;BitMaps:      
7576			;; Character 0x00 = Battery icon  
7576			;            DB  01110b  
7576			;            DB  11011b  
7576			;            DB  10001b  
7576			;            DB  10001b  
7576			;            DB  11111b  
7576			;            DB  11111b  
7576			;            DB  11111b  
7576			;            DB  11111b  
7576			;; Character 0x01 = Bluetooth icon  
7576			;            DB  01100b  
7576			;            DB  01010b  
7576			;            DB  11100b  
7576			;            DB  01000b  
7576			;            DB  11100b  
7576			;            DB  01010b  
7576			;            DB  01100b  
7576			;            DB  00000b  
7576			;  
7576			  
7576			  
7576			; **********************************************************************  
7576			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7576			; **********************************************************************  
7576			;  
7576			; **  Written as a Small Computer Monitor App   
7576			; **  Version 0.1 SCC 2018-05-16  
7576			; **  www.scc.me.uk  
7576			;  
7576			; **********************************************************************  
7576			;  
7576			; This module provides support for alphanumeric LCD modules using with  
7576			; *  HD44780 (or compatible) controller  
7576			; *  5 x 7 pixel fonts  
7576			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7576			; *  Interface via six digital outputs to the display (see below)  
7576			;  
7576			; LCD module pinout:  
7576			;   1  Vss   0v supply  
7576			;   2  Vdd   5v supply  
7576			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7576			;   4  RS    High = data, Low = instruction  
7576			;   5  R/W   High = Read, Low = Write  
7576			;   6  E     Enable signal (active high)  
7576			;   7  DB0   Data bit 0  
7576			;   8  DB1   Data bit 1  
7576			;   9  DB2   Data bit 2  
7576			;  10  DB3   Data bit 3  
7576			;  11  DB4   Data bit 4  
7576			;  12  DB5   Data bit 5  
7576			;  13  DB6   Data bit 6  
7576			;  14  DB7   Data bit 7  
7576			;  15  A     Backlight anode (+)  
7576			;  16  K     Backlight cathode (-)  
7576			;  
7576			; This interfacing method uses 4-bit data mode and uses time delays  
7576			; rather than polling the display's ready status. As a result the   
7576			; interface only requires 6 simple output lines:  
7576			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7576			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7576			;   LCD DB4 = Microcomputer output port bit 4  
7576			;   LCD DB5 = Microcomputer output port bit 5  
7576			;   LCD DB6 = Microcomputer output port bit 6  
7576			;   LCD DB7 = Microcomputer output port bit 7  
7576			; Display's R/W is connected to 0v so it is always in write mode  
7576			; All 6 connections must be on the same port address <kLCDPrt>  
7576			; This method also allows a decent length of cable from micro to LCD  
7576			;  
7576			; **********************************************************************  
7576			;  
7576			; To include the code for any given function provided by this module,   
7576			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7576			; the parent source file.  
7576			; For example:  #REQUIRES   uHexPrefix  
7576			;  
7576			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7576			; in the parent source file.  
7576			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7576			;  
7576			; These are the function names provided by this module:  
7576			; fLCD_Init                     ;Initialise LCD  
7576			; fLCD_Inst                     ;Send instruction to LCD  
7576			; fLCD_Data                     ;Send data byte to LCD  
7576			; fLCD_Pos                      ;Position cursor  
7576			; fLCD_Str                      ;Display string  
7576			; fLCD_Def                      ;Define custom character  
7576			;  
7576			; **********************************************************************  
7576			;  
7576			; Requires SCMonAPI.asm to also be included in the project  
7576			;  
7576			  
7576			  
7576			; **********************************************************************  
7576			; **  Constants  
7576			; **********************************************************************  
7576			  
7576			; Constants that must be defined externally  
7576			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7576			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7576			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7576			;kLCDWidth: EQU 20             ;Width in characters  
7576			  
7576			; general line offsets in any frame buffer  
7576			  
7576			  
7576			display_row_1: equ 0  
7576			display_row_2: equ display_row_1+display_cols  
7576			display_row_3: equ display_row_2 + display_cols  
7576			display_row_4: equ display_row_3 + display_cols  
7576			;display_row_4_eol:   
7576			  
7576			  
7576			; Cursor position values for the start of each line  
7576			  
7576			; E  
7576			kLCD_Line1: EQU 0x00   
7576			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7576			; E1  
7576			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7576			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7576			  
7576			; Instructions to send as A register to fLCD_Inst  
7576			kLCD_Clear: EQU 00000001b     ;LCD clear  
7576			kLCD_Off:   EQU 00001000b     ;LCD off  
7576			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7576			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7576			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7576			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7576			  
7576			; Constants used by this code module  
7576			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7576			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7576			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7576			  
7576			  
7576			  
7576			; **********************************************************************  
7576			; **  LCD support functions  
7576			; **********************************************************************  
7576			  
7576			; Initialise alphanumeric LCD module  
7576			; LCD control register codes:  
7576			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7576			;   N    0 = 1-line mode       1 = 2-line mode  
7576			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7576			;   D    0 = Display off       1 = Display on  
7576			;   C    0 = Cursor off        1 = Cursor on  
7576			;   B    0 = Blinking off      1 = Blinking on  
7576			;   ID   0 = Decrement mode    1 = Increment mode  
7576			;   SH   0 = Entire shift off  1 = Entire shift on  
7576 3e 28		fLCD_Init:  LD   A, 40  
7578 cd 9d 76		            CALL LCDDelay       ;Delay 40ms after power up  
757b			; For reliable reset set 8-bit mode - 3 times  
757b cd 6d 76		            CALL WrFn8bit       ;Function = 8-bit mode  
757e cd 6d 76		            CALL WrFn8bit       ;Function = 8-bit mode  
7581 cd 6d 76		            CALL WrFn8bit       ;Function = 8-bit mode  
7584			; Set 4-bit mode  
7584 cd 69 76		            CALL WrFn4bit       ;Function = 4-bit mode  
7587 cd 9b 76		            CALL LCDDelay1      ;Delay 37 us or more  
758a			; Function set  
758a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
758c cd 9f 75		            CALL fLCD_Inst      ;2 line, display on  
758f			; Display On/Off control  
758f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7591 cd 9f 75		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7594			; Display Clear  
7594 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7596 cd 9f 75		            CALL fLCD_Inst      ;Clear display  
7599			; Entry mode  
7599 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
759b cd 9f 75		            CALL fLCD_Inst      ;Increment mode, shift off  
759e			; Display module now initialised  
759e c9			            RET  
759f			; ok to here  
759f			  
759f			; Write instruction to LCD  
759f			;   On entry: A = Instruction byte to be written  
759f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
759f f5			fLCD_Inst:  PUSH AF  
75a0 f5			            PUSH AF  
75a1 cd b3 75		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
75a4 f1			            POP  AF  
75a5 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
75a6 17			            RLA  
75a7 17			            RLA  
75a8 17			            RLA  
75a9 cd b3 75		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
75ac 3e 02		            LD   A, 2  
75ae cd 9d 76		            CALL LCDDelay       ;Delay 2 ms to complete   
75b1 f1			            POP  AF  
75b2 c9			            RET  
75b3			Wr4bits:   
75b3 f5					push af  
75b4 3a 00 fb				ld a, (display_lcde1e2)  
75b7 fe 00				cp 0     ; e  
75b9 20 10				jr nz, .wea2	  
75bb f1					pop af  
75bc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
75be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75c0 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
75c2 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
75c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
75c6 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
75c8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75ca c9			            RET  
75cb f1			.wea2:		pop af  
75cc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
75ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75d0 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
75d2 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
75d4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
75d6 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
75d8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75da c9			            RET  
75db			  
75db			  
75db			; Write data to LCD  
75db			;   On entry: A = Data byte to be written  
75db			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75db f5			fLCD_Data:  PUSH AF  
75dc f5			            PUSH AF  
75dd cd ef 75		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
75e0 f1			            POP  AF  
75e1 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
75e2 17			            RLA  
75e3 17			            RLA  
75e4 17			            RLA  
75e5 cd ef 75		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
75e8 3e 96		            LD   A, 150  
75ea 3d			Wait:      DEC  A              ;Wait a while to allow data   
75eb 20 fd		            JR   NZ, Wait      ;  write to complete  
75ed f1			            POP  AF  
75ee c9			            RET  
75ef			Wr4bitsa:     
75ef f5					push af  
75f0 3a 00 fb				ld a, (display_lcde1e2)  
75f3 fe 00				cp 0     ; e1  
75f5 20 16				jr nz, .we2	  
75f7 f1					pop af  
75f8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
75fa cb d7		            SET  kLCDBitRS, A  
75fc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
75fe cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7600 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7602 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7604 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7606 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7608 cb 97		            RES  kLCDBitRS, A  
760a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
760c c9			            RET  
760d f1			.we2:		pop af  
760e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7610 cb d7		            SET  kLCDBitRS, A  
7612 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7614 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7616 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7618 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
761a cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
761c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
761e cb 97		            RES  kLCDBitRS, A  
7620 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7622 c9			            RET  
7623			  
7623			  
7623			; Position cursor to specified location  
7623			;   On entry: A = Cursor position  
7623			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7623 f5			fLCD_Pos:   PUSH AF  
7624					; at this point set the E1 or E2 flag depending on position  
7624			  
7624 c5					push bc  
7625			;		push af  
7625 06 00				ld b, 0  
7627 4f					ld c, a  
7628 3e 4f				ld a, kLCD_Line3-1  
762a b7			 		or a      ;clear carry flag  
762b 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
762c 38 04				jr c, .pe1  
762e			  
762e					; E selection  
762e cb 80				res 0, b         ; bit 0 unset e  
7630			;		pop af    ; before line 3 so recover orig pos  
7630			;		ld c, a    ; save for poking back  
7630 18 06				jr .peset	          
7632			.pe1:          	; E2 selection  
7632 cb c0				set 0, b         ; bit 0 set e1  
7634 79					ld a, c  
7635 de 4f				sbc a, kLCD_Line3-1  
7637 4f					ld c, a	         ; save caculated offset  
7638			;		pop af     ; bin this original value now we have calculated form  
7638			  
7638			.peset:		; set bit  
7638 78					ld a, b  
7639 32 00 fb				ld (display_lcde1e2), a 	  
763c 79					ld a, c  
763d c1					pop bc  
763e			  
763e f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7640 cd 9f 75		            CALL fLCD_Inst      ;Write instruction to LCD  
7643 f1			            POP  AF  
7644 c9			            RET  
7645			  
7645			  
7645			; Output text string to LCD  
7645			;   On entry: DE = Pointer to null terminated text string  
7645			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7645 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7646 b7			            OR   A              ;Null terminator?  
7647 c8			            RET  Z              ;Yes, so finished  
7648 cd db 75		            CALL fLCD_Data      ;Write character to display  
764b 13			            INC  DE             ;Point to next character  
764c 18 f7		            JR   fLCD_Str       ;Repeat  
764e c9					ret  
764f			  
764f			; Define custom character  
764f			;   On entry: A = Character number (0 to 7)  
764f			;             DE = Pointer to character bitmap data  
764f			;   On exit:  A = Next character number  
764f			;             DE = Next location following bitmap  
764f			;             BC HL IX IY I AF' BC' DE' HL' preserved  
764f			; Character is   
764f c5			fLCD_Def:   PUSH BC  
7650 f5			            PUSH AF  
7651 07			            RLCA                ;Calculate location  
7652 07			            RLCA                ;  for bitmap data  
7653 07			            RLCA                ;  = 8 x CharacterNumber  
7654 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7656 cd 9f 75		            CALL fLCD_Inst      ;Write instruction to LCD  
7659 06 00		            LD   B, 0  
765b 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
765c cd db 75		            CALL fLCD_Data      ;Write byte to display  
765f 13			            INC  DE             ;Point to next byte  
7660 04			            INC  B              ;Count bytes  
7661 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7663 28 f6		            JR   Z, Loop       ;No, so repeat  
7665 f1			            POP  AF  
7666 3c			            INC  A              ;Increment character number  
7667 c1			            POP  BC  
7668 c9			            RET  
7669			  
7669			  
7669			; **********************************************************************  
7669			; **  Private functions  
7669			; **********************************************************************  
7669			  
7669			; Write function to LCD  
7669			;   On entry: A = Function byte to be written  
7669			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7669 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
766b 18 02		            JR   WrFunc  
766d 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
766f f5			WrFunc:     PUSH AF  
7670 f5					push af  
7671 3a 00 fb				ld a, (display_lcde1e2)  
7674 fe 00				cp 0     ; e1  
7676 20 0f				jr nz, .wfea2	  
7678 f1					pop af  
7679 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
767b cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
767d cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
767f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7681 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7683 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7685 18 0d			jr .wfskip  
7687 f1			.wfea2:		pop af  
7688 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
768a cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
768c cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
768e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7690 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7692 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7694 3e 05		.wfskip:            LD  A, 5  
7696 cd 9d 76		            CALL LCDDelay       ;Delay 5 ms to complete  
7699 f1			            POP  AF  
769a c9			            RET  
769b			  
769b			  
769b			; Delay in milliseconds  
769b			;   On entry: A = Number of milliseconds delay  
769b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
769b 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
769d d5			LCDDelay:   PUSH DE  
769e 5f			            LD   E, A           ;Delay by 'A' ms  
769f 16 00		            LD   D, 0  
76a1 cd d2 0c		            CALL aDelayInMS  
76a4 d1			            POP  DE  
76a5 c9			            RET  
76a6			  
76a6			  
76a6			testlcd:  
76a6 3e 00			ld a, kLCD_Line1  
76a8 cd 23 76			call fLCD_Pos  
76ab 06 28			ld b, 40  
76ad 11 db 76			ld de, .ttext1  
76b0 cd 6e 75			call write_len_string  
76b3			  
76b3 3e 28			ld a, kLCD_Line2  
76b5 cd 23 76			call fLCD_Pos  
76b8 06 28			ld b, 40  
76ba 11 04 77			ld de, .ttext2  
76bd cd 6e 75			call write_len_string  
76c0 3e 50			ld a, kLCD_Line3  
76c2 cd 23 76			call fLCD_Pos  
76c5 06 28			ld b, 40  
76c7 11 2d 77			ld de, .ttext3  
76ca cd 6e 75			call write_len_string  
76cd 3e 78			ld a, kLCD_Line4  
76cf cd 23 76			call fLCD_Pos  
76d2 06 28			ld b, 40  
76d4 11 56 77			ld de, .ttext4  
76d7 cd 6e 75			call write_len_string  
76da			  
76da 76				halt  
76db			  
76db			  
76db .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7704 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
772d .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7756 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
777f			   
777f			  
777f			  
777f			; eof  
777f			  
# End of file firmware_lcd_4x40.asm
777f			;include "firmware_lcd_4x20.asm" 
777f			include "firmware_key_5x10.asm" 
777f			; 5 x 10 decade counter scanner  
777f			  
777f			  
777f			; TODO do cursor shape change for shift keys  
777f			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
777f			  
777f			  
777f			; bit mask for each scan column and row for teing the matrix  
777f			  
777f			  
777f			key_init:  
777f			  
777f			; SCMonAPI functions used  
777f			  
777f			; Alphanumeric LCD functions used  
777f			; no need to specify specific functions for this module  
777f			  
777f			  
777f 3e cf		            LD   A, 11001111b  
7781 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7783			;            LD   A, 00000000b  
7783 3e 1f		            LD   A, 00011111b  
7785 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7787			  
7787			  
7787				; TODO Configure cursor shapes  
7787			  
7787				; Load cursor shapes   
7787 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7789 11 99 77		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
778c 06 02		            LD   B, 2           ;Number of characters to define  
778e cd 4f 76		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7791 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7793			  
7793 3e 01				ld a, 1  
7795 32 f6 fa			ld (cursor_shape),a  
7798 c9				ret  
7799			  
7799			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7799			; Up to 8 custom characters can be defined  
7799			.cursor_shapes:      
7799			;; Character 0x00 = Normal  
7799 1f			            DB  11111b  
779a 1f			            DB  11111b  
779b 1f			            DB  11111b  
779c 1f			            DB  11111b  
779d 1f			            DB  11111b  
779e 1f			            DB  11111b  
779f 1f			            DB  11111b  
77a0 1f			            DB  11111b  
77a1			;; Character 0x01 = Modifier  
77a1 1f			            DB  11111b  
77a2 1b			            DB  11011b  
77a3 1b			            DB  11011b  
77a4 1b			            DB  11011b  
77a5 1b			            DB  11011b  
77a6 1f			            DB  11111b  
77a7 1b			            DB  11011b  
77a8 1f			            DB  11111b  
77a9			  
77a9			  
77a9			  
77a9			  
77a9			; Display custom character 0  
77a9			;            LD   A, kLCD_Line1+14  
77a9			;            CALL fLCD_Pos       ;Position cursor to location in A  
77a9			;            LD   A, 0  
77a9			;            CALL fLCD_Data      ;Write character in A at cursor  
77a9			  
77a9			; Display custom character 1  
77a9			;            LD   A, kLCD_Line2+14  
77a9			;            CALL fLCD_Pos      ;Position cursor to location in A  
77a9			;            LD   A, 1  
77a9			;            CALL fLCD_Data     ;Write character in A at cursor  
77a9			  
77a9			; keyboard scanning   
77a9			  
77a9			; character in from keyboard  
77a9			  
77a9			; mapping for the pcb layout  
77a9			  
77a9			.matrix_to_char:  
77a9 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
77b4 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
77bf 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
77ca 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
77d5 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
77e0			.matrix_to_shift:  
77e0			  
77e0 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
77eb .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
77f6 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7801 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
780c .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7817			  
7817			.matrix_to_symbolshift:  
7817			  
7817 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7822 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
782d 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7838			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7838 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7843 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
784e			  
784e			  
784e			  
784e			; mapping for a simple straight through breadboard layout  
784e			  
784e			;.matrix_to_char:  
784e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
784e			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
784e			;		db "asdfghjkl",KEY_CR,0  
784e			;		db "qwertyuiop",0  
784e			;		 db "1234567890",0  
784e			;.matrix_to_shift:  
784e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
784e			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
784e			;		db "ASDFGHJKL",KEY_CR,0  
784e			;		db "QWERTYUIOP",0  
784e			;		 db "!",'"',"#$%^&*()",0  
784e			;.matrix_to_symbolshift:  
784e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
784e			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
784e			;		db "_?*fghjk=",KEY_CR,0  
784e			;		db "-/+*[]{}@#",0  
784e			;		 db "1234567890",0  
784e			  
784e			;.matrix_to_char: db "D#0*C987B654A321"  
784e			  
784e			  
784e				  
784e			  
784e			; add cin and cin_wait  
784e			  
784e cd 5f 78		cin_wait: 	call cin  
7851						if DEBUG_KEYCINWAIT  
7851							push af  
7851							  
7851							ld hl,key_repeat_ct  
7851							ld (hl),a  
7851							inc hl  
7851							call hexout  
7851							ld hl,key_repeat_ct+3  
7851							ld a,0  
7851							ld (hl),a  
7851			  
7851							    LD   A, kLCD_Line1+11  
7851							    CALL fLCD_Pos       ;Position cursor to location in A  
7851							    LD   DE, key_repeat_ct  
7851							    ;LD   DE, MsgHello  
7851							    CALL fLCD_Str       ;Display string pointed to by DE  
7851			  
7851			  
7851			  
7851							pop af  
7851						endif  
7851 fe 00			cp 0  
7853 28 f9			jr z, cin_wait   ; block until key press  
7855			  
7855							if DEBUG_KEYCINWAIT  
7855								push af  
7855			  
7855								ld a, 'A'	  
7855								ld hl,key_repeat_ct  
7855								ld (hl),a  
7855								inc hl  
7855								ld a,0  
7855								ld (hl),a  
7855			  
7855								    LD   A, kLCD_Line2+11  
7855								    CALL fLCD_Pos       ;Position cursor to location in A  
7855								    LD   DE, key_repeat_ct  
7855								    ;LD   DE, MsgHello  
7855								    CALL fLCD_Str       ;Display string pointed to by DE  
7855			  
7855							call delay500ms  
7855			  
7855								pop af  
7855							endif  
7855 f5				push af   ; save key pressed  
7856			  
7856			.cin_wait1:	  
7856							if DEBUG_KEYCINWAIT  
7856								push af  
7856			  
7856								ld a, 'b'	  
7856								ld hl,key_repeat_ct  
7856								ld (hl),a  
7856								inc hl  
7856								ld a,0  
7856								ld (hl),a  
7856			  
7856								    LD   A, kLCD_Line2+11  
7856								    CALL fLCD_Pos       ;Position cursor to location in A  
7856								    LD   DE, key_repeat_ct  
7856								    ;LD   DE, MsgHello  
7856								    CALL fLCD_Str       ;Display string pointed to by DE  
7856			  
7856			  
7856							call delay500ms  
7856			  
7856								pop af  
7856							endif  
7856			  
7856 cd 5f 78		call cin  
7859 fe 00			cp 0  
785b 20 f9			jr nz, .cin_wait1  	; wait for key release  
785d			if DEBUG_KEYCINWAIT  
785d				push af  
785d			  
785d				ld a, '3'	  
785d				ld hl,key_repeat_ct  
785d				ld (hl),a  
785d				inc hl  
785d				ld a,0  
785d				ld (hl),a  
785d			  
785d			            LD   A, kLCD_Line2+11  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, key_repeat_ct  
785d			            ;LD   DE, MsgHello  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			  
785d			  
785d			call delay500ms  
785d			  
785d				pop af  
785d			endif  
785d			  
785d f1				pop af   ; get key  
785e c9				ret  
785f			  
785f			  
785f			; cin - key non-blocking except for keybounce release  
785f			  
785f cd 7d 78		cin: 	call .mtoc  
7862			  
7862			if DEBUG_KEYCIN  
7862				push af  
7862				  
7862				ld hl,key_repeat_ct  
7862				ld (hl),a  
7862				inc hl  
7862				call hexout  
7862				ld hl,key_repeat_ct+3  
7862				ld a,0  
7862				ld (hl),a  
7862			  
7862			            LD   A, kLCD_Line3+15  
7862			            CALL fLCD_Pos       ;Position cursor to location in A  
7862			            LD   DE, key_repeat_ct  
7862			            ;LD   DE, MsgHello  
7862			            CALL fLCD_Str       ;Display string pointed to by DE  
7862			  
7862			  
7862			call delay500ms  
7862			  
7862				pop af  
7862			endif  
7862			  
7862			  
7862				; no key held  
7862 fe 00			cp 0  
7864 c8				ret z  
7865			  
7865			if DEBUG_KEYCIN  
7865				push af  
7865			  
7865				ld a, '1'	  
7865				ld hl,key_repeat_ct  
7865				ld (hl),a  
7865				inc hl  
7865				ld a,0  
7865				ld (hl),a  
7865			  
7865			            LD   A, kLCD_Line4+15  
7865			            CALL fLCD_Pos       ;Position cursor to location in A  
7865			            LD   DE, key_repeat_ct  
7865			            ;LD   DE, MsgHello  
7865			            CALL fLCD_Str       ;Display string pointed to by DE  
7865			  
7865			  
7865			call delay500ms  
7865			  
7865				pop af  
7865			endif  
7865			  
7865				; stop key bounce  
7865			  
7865 32 c6 fd			ld (key_held),a		 ; save it  
7868 47				ld b, a  
7869			  
7869 c5			.cina1:	push bc  
786a			if DEBUG_KEYCIN  
786a				push af  
786a			  
786a				ld hl,key_repeat_ct  
786a				inc hl  
786a				call hexout  
786a				ld hl,key_repeat_ct+3  
786a				ld a,0  
786a				ld (hl),a  
786a				ld hl,key_repeat_ct  
786a				ld a, '2'	  
786a				ld (hl),a  
786a			  
786a			            LD   A, kLCD_Line4+15  
786a			            CALL fLCD_Pos       ;Position cursor to location in A  
786a			            LD   DE, key_repeat_ct  
786a			            ;LD   DE, MsgHello  
786a			            CALL fLCD_Str       ;Display string pointed to by DE  
786a			  
786a				pop af  
786a			endif  
786a cd 7d 78			call .mtoc  
786d c1				pop bc  
786e b8				cp b  
786f 28 f8			jr z, .cina1  
7871 78				ld a,b		  
7872			if DEBUG_KEYCIN  
7872				push af  
7872			  
7872				ld hl,key_repeat_ct  
7872				inc hl  
7872				call hexout  
7872				ld hl,key_repeat_ct+3  
7872				ld a,0  
7872				ld (hl),a  
7872				ld hl,key_repeat_ct  
7872				ld a, '3'	  
7872				ld (hl),a  
7872			  
7872			            LD   A, kLCD_Line4+15  
7872			            CALL fLCD_Pos       ;Position cursor to location in A  
7872			            LD   DE, key_repeat_ct  
7872			            ;LD   DE, MsgHello  
7872			            CALL fLCD_Str       ;Display string pointed to by DE  
7872			  
7872				pop af  
7872			endif  
7872 c9				ret  
7873			  
7873			; cinndb - key non-blocking without keybounce release  
7873			  
7873 cd 7d 78		cinndb: 	call .mtoc  
7876			  
7876			if DEBUG_KEYCIN  
7876				push af  
7876				  
7876				ld hl,key_repeat_ct  
7876				ld (hl),a  
7876				inc hl  
7876				call hexout  
7876				ld hl,key_repeat_ct+3  
7876				ld a,0  
7876				ld (hl),a  
7876			  
7876			            LD   A, kLCD_Line3+15  
7876			            CALL fLCD_Pos       ;Position cursor to location in A  
7876			            LD   DE, key_repeat_ct  
7876			            ;LD   DE, MsgHello  
7876			            CALL fLCD_Str       ;Display string pointed to by DE  
7876			  
7876			  
7876			call delay500ms  
7876			  
7876				pop af  
7876			endif  
7876			  
7876			  
7876				; no key held  
7876 fe 00			cp 0  
7878 c8				ret z  
7879			  
7879			if DEBUG_KEYCIN  
7879				push af  
7879			  
7879				ld a, '1'	  
7879				ld hl,key_repeat_ct  
7879				ld (hl),a  
7879				inc hl  
7879				ld a,0  
7879				ld (hl),a  
7879			  
7879			            LD   A, kLCD_Line4+15  
7879			            CALL fLCD_Pos       ;Position cursor to location in A  
7879			            LD   DE, key_repeat_ct  
7879			            ;LD   DE, MsgHello  
7879			            CALL fLCD_Str       ;Display string pointed to by DE  
7879			  
7879			  
7879			call delay500ms  
7879			  
7879				pop af  
7879			endif  
7879			  
7879 32 c6 fd			ld (key_held),a		 ; save it  
787c			  
787c			if DEBUG_KEYCIN  
787c				push af  
787c			  
787c				ld hl,key_repeat_ct  
787c				inc hl  
787c				call hexout  
787c				ld hl,key_repeat_ct+3  
787c				ld a,0  
787c				ld (hl),a  
787c				ld hl,key_repeat_ct  
787c				ld a, '3'	  
787c				ld (hl),a  
787c			  
787c			            LD   A, kLCD_Line4+15  
787c			            CALL fLCD_Pos       ;Position cursor to location in A  
787c			            LD   DE, key_repeat_ct  
787c			            ;LD   DE, MsgHello  
787c			            CALL fLCD_Str       ;Display string pointed to by DE  
787c			  
787c				pop af  
787c			endif  
787c c9				ret  
787d			; detect keyboard modifier key press and apply new overlay to the face key held  
787d			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
787d			  
787d			;.cin_map_modifier:   
787d			;	ld a, (hl)  
787d			;	and 255  
787d			;	ret NZ		; modifier key not flagged  
787d			;  
787d			;	; get key face  
787d			;  
787d			;	ld b,(key_face_held)  
787d			;  
787d			;	ld b, key_cols * key_rows  
787d			;  
787d			;	push de  
787d			;	pop hl  
787d			;  
787d			;.mmod1: ld a,(hl)   ; get map test  
787d			;	cp b  
787d			;	jr z, .mmod2  
787d			;  
787d			;  
787d			;  
787d			;.mmod2: inc hl    ;   
787d			;  
787d			;	  
787d			;  
787d			;	  
787d			;  
787d			;	ld hl,key_actual_pressed  
787d			;	ld (hl),a,  
787d			;	ret  
787d			  
787d			; map matrix key held to char on face of key  
787d			  
787d			.mtoc:  
787d			  
787d			; test decade counter strobes  
787d			  
787d			;.decadetest1:  
787d			  
787d			; reset counter  
787d			;ld a, 128  
787d			;out (portbdata),a  
787d			  
787d			  
787d			;ld b, 5  
787d			;.dec1:  
787d			;ld a, 0  
787d			;out (portbdata),a  
787d			;call delay1s  
787d			  
787d			;ld a, 32  
787d			;out (portbdata),a  
787d			;call delay1s  
787d			;call delay1s  
787d			;call delay1s  
787d			;  
787d			;ld a, 64+32  
787d			;out (portbdata),a  
787d			;call delay1s  
787d			;;djnz .dec1  
787d			;  
787d			;jp .decadetest1  
787d			  
787d			  
787d			  
787d			  
787d			  
787d			  
787d			  
787d			  
787d			  
787d			  
787d				; scan keyboard matrix and generate raw scan map  
787d cd 10 79			call matrix  
7880			  
7880				; reuse c bit 0 left modifer button - ie shift  
7880			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7880				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7880			  
7880 0e 00			ld c, 0  
7882			  
7882				; TODO set flags for modifer key presses   
7882				; TODO do a search for modifer key...  
7882			  
7882				;ld hl,keyscan_table_row4  
7882 21 25 fe			ld hl,keyscan_table_row2  
7885			  
7885 7e				ld a, (hl)  
7886 fe 23			cp '#'  
7888 20 07			jr nz, .nextmodcheck  
788a cb c1			set 0, c  
788c 21 e0 77			ld hl, .matrix_to_shift  
788f 18 21			jr .dokeymap  
7891				; TODO for now igonre  
7891			.nextmodcheck:  
7891 21 1a fe			ld hl,keyscan_table_row3  
7894			  
7894 7e				ld a, (hl)  
7895 fe 23			cp '#'  
7897 20 07			jr nz, .nextmodcheck2  
7899 cb c9			set 1, c   
789b 21 17 78			ld hl, .matrix_to_symbolshift  
789e 18 12			jr .dokeymap  
78a0			.nextmodcheck2:  
78a0 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
78a3			  
78a3 7e				ld a, (hl)  
78a4 fe 23			cp '#'  
78a6 20 07			jr nz, .donemodcheck  
78a8 cb c9			set 1, c   
78aa 21 e0 77			ld hl, .matrix_to_shift  
78ad 18 03			jr .dokeymap  
78af			  
78af				; no modifer found so just map to normal keys  
78af				; get mtoc map matrix to respective keys  
78af			;	ld hl, .matrix_to_char  
78af			;	ld hl, .matrix_to_char  
78af			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78af			;	ld a, KEY_SHIFT  
78af			;	call findchar  
78af			;  
78af			;	; got offset to key modifer in b  
78af			;  
78af			;	ld hl,keyscan_table_row5  
78af			;  
78af			;	ld a,b  
78af			;	call addatohl  
78af			;	ld a,(hl)  
78af			;  
78af			;	cp '#'  
78af			;	jr nz, .nextmodcheck  
78af			;	set 0, c  
78af			;	ld hl, .matrix_to_char  
78af			;	jr .dokeymap  
78af			;	; TODO for now igonre  
78af			;.nextmodcheck:  
78af			;	ld hl, .matrix_to_symbolshift  
78af			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78af			;	ld a, KEY_SYMBOLSHIFT  
78af			;	call findchar  
78af			;  
78af			;  
78af			;	; got offset to key modifer in b  
78af			;  
78af			;	ld hl,keyscan_table_row5  
78af			;  
78af			;	ld a,b  
78af			;	call addatohl  
78af			;	ld a,(hl)  
78af			;  
78af			;	cp '#'  
78af			;	jr nz, .donemodcheck  
78af			;	set 1, c   
78af			;	ld hl, .matrix_to_symbolshift  
78af			;	jr .dokeymap  
78af			  
78af			  
78af			  
78af			.donemodcheck:  
78af				; no modifer found so just map to normal keys  
78af				; get mtoc map matrix to respective keys  
78af 21 a9 77			ld hl, .matrix_to_char  
78b2			  
78b2			.dokeymap:  
78b2				;ld (key_fa), c   
78b2 cd cb 78			call .mapkeys  
78b5			  
78b5			  
78b5			if DEBUG_KEY  
78b5			  
78b5			; Display text on first line  
78b5			            LD   A, kLCD_Line1  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, keyscan_table_row1  
78b5			            ;LD   DE, MsgHello  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			  
78b5			; Display text on second line  
78b5			            LD   A, kLCD_Line2  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, keyscan_table_row2  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			            LD   A, kLCD_Line3  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, keyscan_table_row3  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			            LD   A, kLCD_Line4  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, keyscan_table_row4  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			            LD   A, kLCD_Line1+10  
78b5			            CALL fLCD_Pos       ;Position cursor to location in A  
78b5			            LD   DE, keyscan_table_row5  
78b5			            CALL fLCD_Str       ;Display string pointed to by DE  
78b5			  
78b5				;call delay250ms  
78b5			endif  
78b5			;	jp testkey  
78b5			  
78b5			; get first char reported  
78b5			  
78b5 21 04 fe			ld hl,keyscan_table_row5  
78b8			  
78b8				;ld b, 46   ; 30 keys to remap + 8 nulls   
78b8 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
78ba			.findkey:  
78ba 7e				ld a,(hl)  
78bb fe 00			cp 0  
78bd 28 04			jr z, .nextkey  
78bf fe 7e			cp KEY_MATRIX_NO_PRESS  
78c1 20 06			jr nz, .foundkey  
78c3			.nextkey:  
78c3 23				inc hl  
78c4 10 f4			djnz .findkey  
78c6 3e 00			ld a,0  
78c8 c9				ret  
78c9			.foundkey:  
78c9 7e				ld a,(hl)  
78ca c9				ret  
78cb				  
78cb			  
78cb			; convert the raw key map given hl for destination key  
78cb			.mapkeys:  
78cb 11 04 fe			ld de,keyscan_table_row5  
78ce			  
78ce 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
78d0			.remap:  
78d0 1a				ld a,(de)  
78d1 fe 23			cp '#'  
78d3 20 02			jr nz, .remapnext  
78d5				;CALLMONITOR  
78d5 7e				ld a,(hl)  
78d6 12				ld (de),a  
78d7			  
78d7			  
78d7			  
78d7			.remapnext:  
78d7 23				inc hl  
78d8 13				inc de  
78d9 10 f5			djnz .remap  
78db				  
78db c9				ret  
78dc			  
78dc			  
78dc			  
78dc			.mtocold2:  
78dc			  
78dc			;	; flag if key D is held down and remove from reporting  
78dc			;	ld bc, .key_map_fd    
78dc			;	ld hl, keyscan_table  
78dc			;	ld de, key_fd  
78dc			;	call .key_shift_hold  
78dc			;	cp 255  
78dc			;	jr z, .cinmap  
78dc			;	; flag if key C is held down and remove from reporting  
78dc			;	ld bc, .key_map_fc    
78dc			;	ld hl, keyscan_table+key_cols  
78dc			;	ld de, key_fc  
78dc			;	call .key_shift_hold  
78dc			;	cp 255  
78dc			;	jr z, .cinmap  
78dc			;	; flag if key B is held down and remove from reporting  
78dc			;	ld bc, .key_map_fb    
78dc			;	ld hl, keyscan_table+(key_cols*2)  
78dc			;	ld de, key_fb  
78dc			;	call .key_shift_hold  
78dc			;	cp 255  
78dc			;	jr z, .cinmap  
78dc			;	; flag if key A is held down and remove from reporting  
78dc			;	ld bc, .key_map_fa    
78dc			;	ld hl, keyscan_table+(key_cols*3)  
78dc			;	ld de, key_fa  
78dc			;	call .key_shift_hold  
78dc			;	cp 255  
78dc			;	jr z, .cinmap  
78dc			  
78dc 11 a9 77			ld de, .matrix_to_char  
78df			  
78df			  
78df			.cinmap1:   
78df				if DEBUG_KEY  
78df			            LD   A, kLCD_Line4  
78df			            CALL fLCD_Pos       ;Position cursor to location in A  
78df					push de  
78df			            LD   DE, keyscan_table  
78df			            CALL fLCD_Str       ;Display string pointed to by DE  
78df					pop de  
78df				endif  
78df			  
78df				; scan key matrix table for any held key  
78df			  
78df				; de holds either the default matrix or one selected above  
78df			  
78df 21 d1 fd			ld hl, keyscan_table  
78e2 06 32			ld b,key_cols*key_rows  
78e4			  
78e4 7e			.cin11:	ld a,(hl)  
78e5 fe 23			cp '#'  
78e7 28 08			jr z, .cinhit1  
78e9 23				inc hl  
78ea 13				inc de  
78eb 05				dec b  
78ec 20 f6			jr nz, .cin11  
78ee				; no key found held  
78ee 3e 00			ld a,0  
78f0 c9				ret  
78f1 d5			.cinhit1: push de  
78f2 e1				pop hl  
78f3 7e				ld a,(hl)  
78f4 c9				ret  
78f5			  
78f5			; flag a control key is held   
78f5			; hl is key pin, de is flag indicator  
78f5			  
78f5			.key_shift_hold1:  
78f5 c5				push bc  
78f6 3e 01			ld a, 1  
78f8 32 f6 fa			ld (cursor_shape),a  
78fb 06 00			ld b, 0  
78fd 7e				ld a, (hl)  
78fe fe 2e			cp '.'  
7900 28 0a			jr z, .key_shift11  
7902 06 ff			ld b, 255  
7904 3e 2b			ld a, '+'    ; hide key from later scans  
7906 77				ld (hl),a  
7907 3e 02			ld a, 2  
7909 32 f6 fa			ld (cursor_shape),a  
790c			.key_shift11:  
790c				; write flag indicator  
790c 78				ld a,b  
790d 12				ld (de),a  
790e			  
790e d1				pop de    ; de now holds the key map ptr  
790f c9				ret  
7910			  
7910				  
7910			  
7910			; scans keyboard matrix and flags key press in memory array	  
7910				  
7910			matrix:  
7910				;call matrix  
7910				; TODO optimise the code....  
7910			  
7910			  
7910			;ld hl, keyscan_table_row1  
7910			;ld de, keyscan_table_row1+1  
7910			;ld bc,46  
7910			;ld a,KEY_MATRIX_NO_PRESS  
7910			;ldir  
7910			  
7910			  
7910			  
7910			; reset counter  
7910 3e 80		ld a, 128  
7912 d3 c1		out (portbdata),a  
7914			  
7914 06 0a		ld b, 10  
7916 0e 00		ld c, 0       ; current clock toggle  
7918			  
7918			.colscan:  
7918			  
7918			; set current column  
7918			; disable clock enable and set clock low  
7918			  
7918			;ld a, 0  
7918			;out (portbdata),a  
7918			  
7918			; For each column scan for switches  
7918			  
7918 c5			push bc  
7919 21 c7 fd		ld hl, keyscan_scancol  
791c cd 25 7a		call .rowscan  
791f c1			pop bc  
7920			  
7920			  
7920			; get back current column  
7920			  
7920			; translate the row scan  
7920			  
7920			;   
7920			; row 1  
7920			  
7920 78			ld a,b  
7921			  
7921 21 3a fe		LD   hl, keyscan_table_row1+10  
7924			  
7924 cd f0 0f		call subafromhl  
7927			;call addatohl  
7927			  
7927 11 c7 fd		ld de, keyscan_scancol  
792a			  
792a 1a			ld a,(de)  
792b 77			ld (hl),a  
792c			  
792c			  
792c			  
792c			  
792c			; row 2  
792c			  
792c 78			ld a,b  
792d			  
792d 21 2f fe		LD   hl, keyscan_table_row2+10  
7930			  
7930			;call addatohl  
7930 cd f0 0f		call subafromhl  
7933			  
7933			  
7933 11 c8 fd		ld de, keyscan_scancol+1  
7936			  
7936 1a			ld a,(de)  
7937 77			ld (hl),a  
7938			  
7938			  
7938			; row 3  
7938			  
7938 78			ld a,b  
7939			  
7939 21 24 fe		LD   hl, keyscan_table_row3+10  
793c			  
793c			;call addatohl  
793c cd f0 0f		call subafromhl  
793f			  
793f 11 c9 fd		ld de, keyscan_scancol+2  
7942			  
7942 1a			ld a,(de)  
7943 77			ld (hl),a  
7944			  
7944			  
7944			  
7944			; row 4  
7944			  
7944 78			ld a,b  
7945			  
7945 21 19 fe		LD   hl, keyscan_table_row4+10  
7948			  
7948			;call addatohl  
7948 cd f0 0f		call subafromhl  
794b			  
794b 11 ca fd		ld de, keyscan_scancol+3  
794e			  
794e 1a			ld a,(de)  
794f 77			ld (hl),a  
7950			  
7950			; row 5  
7950			  
7950 78			ld a,b  
7951			  
7951 21 0e fe		LD   hl, keyscan_table_row5+10  
7954			  
7954			;call addatohl  
7954 cd f0 0f		call subafromhl  
7957			  
7957 11 cb fd		ld de, keyscan_scancol+4  
795a			  
795a 1a			ld a,(de)  
795b 77			ld (hl),a  
795c			  
795c			; handshake next column  
795c			  
795c			  
795c 3e 40		ld a, 64  
795e d3 c1		out (portbdata),a  
7960			  
7960 3e 00		ld a, 0  
7962 d3 c1		out (portbdata),a  
7964			  
7964			; toggle clk and move to next column  
7964			;ld a, 64  
7964			;cp c  
7964			;  
7964			;jr z, .coltoglow  
7964			;ld c, a  
7964			;jr .coltog  
7964			;.coltoglow:  
7964			;ld c, 0  
7964			;.coltog:  
7964			;ld a, c  
7964			;out (portbdata),a  
7964			  
7964 10 b2		djnz .colscan  
7966			  
7966 3e 0a		ld a,10  
7968 21 30 fe		LD   hl, keyscan_table_row1  
796b cd de 0f		call addatohl  
796e 3e 00		ld a, 0  
7970 77			ld (hl), a  
7971			  
7971			  
7971 3e 0a		ld a,10  
7973 21 25 fe		LD   hl, keyscan_table_row2  
7976 cd de 0f		call addatohl  
7979 3e 00		ld a, 0  
797b 77			ld (hl), a  
797c			  
797c 3e 0a		ld a,10  
797e 21 1a fe		LD   hl, keyscan_table_row3  
7981 cd de 0f		call addatohl  
7984 3e 00		ld a, 0  
7986 77			ld (hl), a  
7987			  
7987 3e 0a		ld a,10  
7989 21 0f fe		LD   hl, keyscan_table_row4  
798c cd de 0f		call addatohl  
798f 3e 00		ld a, 0  
7991 77			ld (hl), a  
7992			  
7992 3e 0a		ld a,10  
7994 21 04 fe		LD   hl, keyscan_table_row5  
7997 cd de 0f		call addatohl  
799a 3e 00		ld a, 0  
799c 77			ld (hl), a  
799d			  
799d			if DEBUG_KEY_MATRIX  
799d			  
799d			; Display text on first line  
799d			            LD   A, kLCD_Line1  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, keyscan_table_row1  
799d			            ;LD   DE, MsgHello  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			  
799d			; Display text on second line  
799d			            LD   A, kLCD_Line2  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, keyscan_table_row2  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			            LD   A, kLCD_Line3  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, keyscan_table_row3  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			            LD   A, kLCD_Line4  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, keyscan_table_row4  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			            LD   A, kLCD_Line4+10  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, keyscan_table_row5  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			  
799d			;call delay250ms  
799d				jp matrix  
799d			endif  
799d c9			ret  
799e			  
799e			; using decade counter....  
799e			  
799e			  
799e			; TODO reset decade counter to start of scan  
799e			  
799e			; reset 15  
799e			; clock 14  
799e			; ce 13  
799e			  
799e			; 1 - q5  
799e			; 2 - q1  
799e			; 3 - q0  
799e			; 4 - q2  
799e			; 5 - q6  
799e			; 6 - q7  
799e			; 7 - q3  
799e			; 8 - vss  
799e			; 9 - q8  
799e			; 10 - q4  
799e			; 11 - q9  
799e			; 12 - cout  
799e			; 16 - vdd  
799e			  
799e			; clock      ce       reset     output  
799e			; 0          x        0         n  
799e			; x          1        0         n  
799e			; x          x        1         q0  
799e			; rising     0        0         n+1  
799e			; falling    x        0         n  
799e			; x          rising   0         n  
799e			; 1          falling  0         x+1  
799e			;  
799e			; x = dont care, if n < 5 carry = 1 otherwise 0  
799e			  
799e			;   
799e			; reset   
799e			; 13=0, 14=0, 15=1 .. 15=0  
799e			;  
799e			; handshake line  
799e			; 14=1.... read line 14=0  
799e			  
799e			  
799e			  
799e			  
799e			  
799e			; TODO hand shake clock for next column scan  
799e			; TODO detect each row  
799e			  
799e			  
799e			  
799e			  
799e			; reset 128  
799e			; clock 64  
799e			; ce 32  
799e			  
799e			  
799e			.cyclestart:  
799e			  
799e			; reset counter  
799e 3e 80		ld a, 128  
79a0 d3 c1		out (portbdata),a  
79a2			  
79a2			; loop leds  
79a2 06 0a		ld b,10  
79a4			  
79a4			.cycle1:  
79a4 c5			push bc  
79a5 3e 00		ld a, 0  
79a7 d3 c1		out (portbdata),a  
79a9 cd e1 0c		call delay250ms  
79ac			  
79ac 3e 40		ld a, 64  
79ae d3 c1		out (portbdata),a  
79b0 cd e1 0c		call delay250ms  
79b3			  
79b3 3e 00		ld a, 0  
79b5 d3 c1		out (portbdata),a  
79b7 cd e1 0c		call delay250ms  
79ba			  
79ba c1			pop bc  
79bb 10 e7		djnz .cycle1  
79bd			  
79bd			  
79bd 18 df		jr .cyclestart  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			; map matrix key held to char on face of key  
79bf			  
79bf			;.mtocold:  
79bf			;  
79bf			;  
79bf			;; reset counter  
79bf			;ld a, 128  
79bf			;out (portbdata),a  
79bf			;  
79bf			;  
79bf			;; scan keyboard row 1  
79bf			;ld a, 0  
79bf			;out (portbdata),a  
79bf			;;ld a, 64  
79bf			;;out (portbdata),a  
79bf			;  
79bf			;  
79bf			;	ld a, 128  
79bf			;	ld hl, keyscan_table  
79bf			;	call .rowscan  
79bf			;  
79bf			;;ld a, 0  
79bf			;;out (portbdata),a  
79bf			;ld a, 64  
79bf			;out (portbdata),a  
79bf			;  
79bf			;	ld a, 64  
79bf			;	ld hl, keyscan_table+key_cols  
79bf			;	call .rowscan  
79bf			;  
79bf			;ld a, 0  
79bf			;out (portbdata),a  
79bf			;;ld a, 64  
79bf			;;out (portbdata),a  
79bf			;	ld a, 32  
79bf			;	ld hl, keyscan_table+(key_cols*2)  
79bf			;	call .rowscan  
79bf			;  
79bf			;  
79bf			;;ld a, 0  
79bf			;;out (portbdata),a  
79bf			;ld a, 64  
79bf			;out (portbdata),a  
79bf			;  
79bf			;	ld a, 16  
79bf			;	ld hl, keyscan_table+(key_cols*3)  
79bf			;	call .rowscan  
79bf			;  
79bf			;  
79bf			;	; flag if key D is held down and remove from reporting  
79bf			;	ld bc, .key_map_fd    
79bf			;	ld hl, keyscan_table  
79bf			;	ld de, key_fd  
79bf			;	call .key_shift_hold  
79bf			;	cp 255  
79bf			;	jr z, .cinmap  
79bf			;	; flag if key C is held down and remove from reporting  
79bf			;	ld bc, .key_map_fc    
79bf			;	ld hl, keyscan_table+key_cols  
79bf			;	ld de, key_fc  
79bf			;	call .key_shift_hold  
79bf			;	cp 255  
79bf			;	jr z, .cinmap  
79bf			;	; flag if key B is held down and remove from reporting  
79bf			;	ld bc, .key_map_fb    
79bf			;	ld hl, keyscan_table+(key_cols*2)  
79bf			;	ld de, key_fb  
79bf			;	call .key_shift_hold  
79bf			;	cp 255  
79bf			;	jr z, .cinmap  
79bf			;	; flag if key A is held down and remove from reporting  
79bf			;	ld bc, .key_map_fa    
79bf			;	ld hl, keyscan_table+(key_cols*3)  
79bf			;	ld de, key_fa  
79bf			;	call .key_shift_hold  
79bf			;	cp 255  
79bf			;	jr z, .cinmap  
79bf			;  
79bf			;	ld de, .matrix_to_char  
79bf			;  
79bf			;  
79bf			;.cinmap:   
79bf			;	if DEBUG_KEY  
79bf			;            LD   A, kLCD_Line4  
79bf			;            CALL fLCD_Pos       ;Position cursor to location in A  
79bf			;		push de  
79bf			;            LD   DE, keyscan_table  
79bf			;            CALL fLCD_Str       ;Display string pointed to by DE  
79bf			;		pop de  
79bf			;	endif  
79bf			  
79bf				; scan key matrix table for any held key  
79bf			  
79bf				; de holds either the default matrix or one selected above  
79bf			  
79bf			;	ld hl, keyscan_table  
79bf			;	ld b,key_cols*key_rows  
79bf			;  
79bf			;.cin1:	ld a,(hl)  
79bf			;	cp '#'  
79bf			;	jr z, .cinhit  
79bf			;	inc hl  
79bf			;	inc de  
79bf			;	dec b  
79bf			;	jr nz, .cin1  
79bf			;	; no key found held  
79bf			;	ld a,0  
79bf			;	ret  
79bf			;.cinhit: push de  
79bf			;	pop hl  
79bf			;	ld a,(hl)  
79bf			;	ret  
79bf			  
79bf			; flag a control key is held   
79bf			; hl is key pin, de is flag indicator  
79bf			  
79bf			;.key_shift_hold:  
79bf			;	push bc  
79bf			;	ld a, 1  
79bf			;	ld (cursor_shape),a  
79bf			;	ld b, 0  
79bf			;	ld a, (hl)  
79bf			;	cp '.'  
79bf			;	jr z, .key_shift1  
79bf			;	ld b, 255  
79bf			;	ld a, '+'    ; hide key from later scans  
79bf			;	ld (hl),a  
79bf			;	ld a, 2  
79bf			;	ld (cursor_shape),a  
79bf			;.key_shift1:  
79bf			;	; write flag indicator  
79bf			;	ld a,b  
79bf			;	ld (de),a  
79bf			;  
79bf			;	pop de    ; de now holds the key map ptr  
79bf			;	ret  
79bf			  
79bf				  
79bf				  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			;	push hl  
79bf			;	push de  
79bf			;	push bc  
79bf			;	call keyscan  
79bf			;	; map key matrix to ascii value of key face  
79bf			;  
79bf			;	ld hl, key_face_map  
79bf			;	ld de, keyscan_table  
79bf			;  
79bf			;	; get how many keys to look at  
79bf			;	ld b, keyscan_table_len  
79bf			;	  
79bf			;  
79bf			;	; at this stage fall out on first key hit  
79bf			;	; TODO handle multiple key press  
79bf			;  
79bf			;map1:	ld a,(hl)  
79bf			;	cp '#'  
79bf			;	jr z, keyhit  
79bf			;	inc hl  
79bf			;	inc de  
79bf			;	dec b  
79bf			;	jr nz, map1  
79bf			;nohit:	ld a, 0  
79bf			;	jr keydone  
79bf			;keyhit: push de  
79bf			;	pop hl  
79bf			;	ld a,(hl)  
79bf			;keydone:  
79bf			;	push bc  
79bf			;	push de  
79bf			; 	push hl  
79bf			;	ret   
79bf			;  
79bf			  
79bf			  
79bf			  
79bf			  
79bf			; scan physical key matrix  
79bf			  
79bf			  
79bf			;keyscan:  
79bf			;  
79bf			;; for each key_row use keyscanr bit mask for out  
79bf			;; then read in for keyscanc bitmask  
79bf			;; save result of row scan to keyscantable  
79bf			;  
79bf			;; scan keyboard row 1  
79bf			;  
79bf			;	ld b, key_rows  
79bf			;	ld hl, key_scanr  
79bf			;	ld de, keyscan_table  
79bf			;  
79bf			;rowloop:  
79bf			;  
79bf			;	ld a,(hl)		; out bit mask to energise keyboard row  
79bf			;	call rowscan  
79bf			;	inc hl  
79bf			;	dec b  
79bf			;	jr nz, rowloop  
79bf			;  
79bf			;	ret  
79bf			;  
79bf			;  
79bf			;; pass a out bitmask, b row number  
79bf			;arowscan:   
79bf			;	push bc  
79bf			;  
79bf			;	ld d, b  
79bf			;  
79bf			;	; calculate buffer location for this row  
79bf			;  
79bf			;	ld hl, keyscan_table	  
79bf			;kbufr:  ld e, key_cols  
79bf			;kbufc:	inc hl  
79bf			;	dec e  
79bf			;	jr nz, kbufc  
79bf			;	dec d  
79bf			;	jr nz, kbufr  
79bf			;  
79bf			;	; energise row and read columns  
79bf			;  
79bf			;	out (portbdata),a  
79bf			;	in a,(portbdata)  
79bf			;	ld c,a  
79bf			;  
79bf			;  
79bf			;	; save buffer loc  
79bf			;  
79bf			;	ld (keybufptr), hl  
79bf			;  
79bf			;	ld hl, key_scanc  
79bf			;	ld d, key_cols  
79bf			;  
79bf			;	; for each column check each bit mask  
79bf			;  
79bf			;colloop:  
79bf			;	  
79bf			;  
79bf			;	; reset flags for the row   
79bf			;  
79bf			;	ld b,'.'  
79bf			;	and (hl)  
79bf			;	jr z, maskskip  
79bf			;	ld b,'#'  
79bf			;maskskip:  
79bf			;	; save  key state  
79bf			;	push hl  
79bf			;	ld hl, (keybufptr)  
79bf			;	ld (hl), b  
79bf			;	inc hl  
79bf			;	ld (keybufptr), hl  
79bf			;  
79bf			;	; move to next bit mask  
79bf			;	pop hl  
79bf			;	inc hl  
79bf			;  
79bf			;	dec d  
79bf			;	jr nz, colloop  
79bf			;  
79bf			;	ret  
79bf			;  
79bf			;  
79bf			;;  
79bf			; lcd functions  
79bf			;  
79bf			;  
79bf			  
79bf			;if DEBUG_KEY_MATRIX  
79bf			  
79bf			; test function to display hardware view of matrix state  
79bf			  
79bf			matrixold:  
79bf			  
79bf			  
79bf			  
79bf			; reset counter  
79bf 3e 80		ld a, 128  
79c1 d3 c1		out (portbdata),a  
79c3			; scan keyboard row 1  
79c3 3e 00		ld a, 0  
79c5 d3 c1		out (portbdata),a  
79c7			;ld a, 64  
79c7			;out (portbdata),a  
79c7 3e 80			ld a, 128  
79c9 21 30 fe			ld hl, keyscan_table_row1  
79cc cd 25 7a			call .rowscan  
79cf			  
79cf			;ld a, 0  
79cf			;out (portbdata),a  
79cf 3e 40		ld a, 64  
79d1 d3 c1		out (portbdata),a  
79d3 3e 40			ld a, 64  
79d5 21 25 fe			ld hl, keyscan_table_row2  
79d8 cd 25 7a			call .rowscan  
79db			  
79db 3e 00		ld a, 0  
79dd d3 c1		out (portbdata),a  
79df			;ld a, 64  
79df			;out (portbdata),a  
79df 3e 20			ld a, 32  
79e1 21 1a fe			ld hl, keyscan_table_row3  
79e4 cd 25 7a			call .rowscan  
79e7			  
79e7			;ld a, 0  
79e7			;out (portbdata),a  
79e7 3e 40		ld a, 64  
79e9 d3 c1		out (portbdata),a  
79eb 3e 10			ld a, 16  
79ed 21 0f fe			ld hl, keyscan_table_row4  
79f0 cd 25 7a			call .rowscan  
79f3			  
79f3			; Display text on first line  
79f3 3e 00		            LD   A, kLCD_Line1  
79f5 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
79f8 11 30 fe		            LD   DE, keyscan_table_row1  
79fb			            ;LD   DE, MsgHello  
79fb cd 45 76		            CALL fLCD_Str       ;Display string pointed to by DE  
79fe			  
79fe			; Display text on second line  
79fe 3e 28		            LD   A, kLCD_Line2  
7a00 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a03 11 25 fe		            LD   DE, keyscan_table_row2  
7a06 cd 45 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a09 3e 50		            LD   A, kLCD_Line3  
7a0b cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a0e 11 1a fe		            LD   DE, keyscan_table_row3  
7a11 cd 45 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a14 3e 78		            LD   A, kLCD_Line4  
7a16 cd 23 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a19 11 0f fe		            LD   DE, keyscan_table_row4  
7a1c cd 45 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			  
7a1f cd e1 0c			call delay250ms  
7a22 c3 10 79			jp matrix  
7a25			  
7a25			; pass de as row display flags  
7a25			.rowscan:   
7a25			;	out (portbdata),a  
7a25 db c1			in a,(portbdata)  
7a27 4f				ld c,a  
7a28				; reset flags for the row   
7a28 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a2a e6 01			and 1  
7a2c 28 02			jr z, .p1on  
7a2e 06 23			ld b,'#'  
7a30			.p1on:  
7a30 70				ld (hl), b  
7a31 23				inc hl  
7a32			  
7a32 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a34 79				ld a,c  
7a35 e6 02			and 2  
7a37			;	bit 0,a  
7a37 28 02			jr z, .p2on  
7a39 06 23			ld b,'#'  
7a3b			.p2on:  
7a3b 70				ld (hl), b  
7a3c 23				inc hl  
7a3d			;  
7a3d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a3f 79				ld a,c  
7a40 e6 04			and 4  
7a42			;;	bit 0,a  
7a42 28 02			jr z, .p3on  
7a44 06 23			ld b,'#'  
7a46			.p3on:  
7a46 70				ld (hl), b  
7a47 23				inc hl  
7a48			;;  
7a48 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a4a			;;	bit 0,a  
7a4a 79				ld a,c  
7a4b e6 08			and 8  
7a4d 28 02			jr z, .p4on  
7a4f 06 23			ld b,'#'  
7a51			.p4on:  
7a51 70				ld (hl), b  
7a52 23				inc hl  
7a53			  
7a53 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a55			;;	bit 0,a  
7a55 79				ld a,c  
7a56 e6 10			and 16  
7a58 28 02			jr z, .p5on  
7a5a 06 23			ld b,'#'  
7a5c			.p5on:  
7a5c 70				ld (hl), b  
7a5d 23				inc hl  
7a5e			; zero term  
7a5e 06 00			ld b,0  
7a60 70				ld (hl), b  
7a61			  
7a61 c9			.rscandone: ret  
7a62			  
7a62			;addatohl:  
7a62			;  
7a62			 ;add   a, l    ; A = A+L  
7a62			  ;  ld    l, a    ; L = A+L  
7a62			   ; adc   a, h    ; A = A+L+H+carry  
7a62			   ; sub   l       ; A = H+carry  
7a62			   ; ld    h, a    ; H = H+carry  
7a62			  
7a62			;ret  
7a62			; eof  
# End of file firmware_key_5x10.asm
7a62			;include "firmware_key_4x10.asm" 
7a62			 
7a62			heap_size:    equ heap_end - heap_start 
7a62			;eof 
# End of file os_mega.asm
7a62
