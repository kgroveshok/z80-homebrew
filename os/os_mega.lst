# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 19 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			if BASE_KEV = 1  
001c			 
001c				; need to be at $66 for nmi support 
001c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0022 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0028 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0034 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003a 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0040 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0046 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0052 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0058 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0064 00 ff			db 0,255 
0066 c3 51 76			jp nmi 
0069			endif 
0069			 
0069			include "firmware.asm" 
0069			  
0069			; main constants (used here and in firmware)  
0069			  
0069			; TODO have page 0 of storage as bios  
0069			  
0069			Device_A: equ 0h  
0069			Device_B: equ 040h          ; Sound  
0069			  
0069			if BASE_KEV  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_SC114  
0069			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			; TODO fixup for CPM  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			Device_D: equ 0c0h             ; Keyboard and LCD  
0069			  
0069			; Odd specific debug points for testing hardware dev  
0069			  
0069			DEBUG_SOUND: equ 0       
0069			DEBUG_STK_FAULT: equ 0  
0069			DEBUG_INPUT: equ 0     ; Debug input entry code  
0069			DEBUG_KEYCINWAIT: equ 0  
0069			DEBUG_KEYCIN: equ 0  
0069			DEBUG_KEY: equ 0  
0069			DEBUG_KEY_MATRIX: equ 0  
0069			DEBUG_STORECF: equ 0  
0069			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0069			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0069			DEBUG_SPI: equ 0    ; low level spi tests  
0069			  
0069			; Enable many break points  
0069			  
0069			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0069			DEBUG_FORTH_JP: equ 0    ; 4  
0069			DEBUG_FORTH_MALLOC: equ 0  
0069			DEBUG_FORTH_MALLOC_INT: equ 0  
0069			DEBUG_FORTH_DOT: equ 1  
0069			DEBUG_FORTH_DOT_WAIT: equ 0  
0069			DEBUG_FORTH_MATHS: equ 0  
0069			DEBUG_FORTH_TOK: equ 0    ; 4  
0069			DEBUG_FORTH_PARSE: equ 0    ; 3  
0069			DEBUG_FORTH: equ 0  ;2  
0069			DEBUG_FORTH_WORDS: equ 1   ; 1  
0069			DEBUG_FORTH_PUSH: equ 1   ; 1  
0069			DEBUG_FORTH_UWORD: equ 1   ; 1  
0069			  
0069			; Enable key point breakpoints  
0069			  
0069			DEBUG_FORTH_DOT_KEY: equ 0  
0069			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0069			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0069			  
0069			; Debug stack imbalances  
0069			  
0069			ON: equ 1  
0069			OFF: equ 0  
0069			  
0069			DEBUG_STACK_IMB: equ 0  
0069			STACK_IMB_STORE: equ 20  
0069			  
0069			; House keeping and protections  
0069			  
0069			DEBUG_FORTH_STACK_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0069			FORTH_ENABLE_FREE: equ 0  
0069			FORTH_ENABLE_MALLOCFREE: equ 1  
0069			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0069			FORTH_ENABLE_FLOATMATH: equ 0  
0069			  
0069			  
0069			CALLMONITOR: macro  
0069			;	call break_point_state  
0069			; now use the break point debug vector  
0069				call debug_vector  
0069				endm  
0069			  
0069			MALLOC_1: equ 1        ; from dk88   
0069			MALLOC_2: equ 0           ; broke  
0069			MALLOC_3: equ 0           ; really broke  
0069			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0069			  
0069			if BASE_KEV   
0069			stacksize: equ 256  
0069			  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 512  
0069			endif  
0069			if BASE_SC114  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			;if STORAGE_SE == 0  
0069			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0069			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0069			;endif  
0069			  
0069			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0069			  
0069			STORE_0_AUTORUN: equ $20  
0069			  
0069			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0069			  
0069			STORE_0_AUTOFILE: equ $21  
0069			STORE_0_BANKRUN: equ $23  
0069			STORE_0_FILERUN: equ $24  
0069			  
0069			; Block 0 offsets for settings  
0069			  
0069			; if set then skip prompt for start up and accept all  
0069			  
0069			STORE_0_QUICKSTART: equ $25  
0069			  
0069			; Blocks where directory table is held  
0069			  
0069			; Reducing the number of entries increases the max file size  
0069			  
0069			;STORE_DIR_START: equ 1  
0069			;STORE_DIR_END: equ 33  
0069			  
0069			; Blocks from where file data is stored  
0069			  
0069			;STORE_DATA_START: equ STORE_DIR_END + 1  
0069			  
0069			; Block indicators (<32 are data files)  
0069			  
0069			;STORE_BLOCK_CFG: equ $8f       ; config block  
0069			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0069			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0069			;STORE_BLOCK_FREE: equ $85       ; data block free  
0069			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0069			  
0069			  
0069			  
0069			; Directory entry flags  
0069			  
0069			;STORE_DIR_FREE: equ 0  
0069			;STORE_DIR_FILE:  equ 1  
0069			  
0069			; Structure offsets to directory entries  
0069			;STORE_DE_FLAG: equ 0  
0069			;STORE_DE_MAXEXT: equ 1  
0069			;STORE_DE_FILENAME: equ 2  
0069			  
0069			; Structure offsets to block 0  
0069			  
0069			;STORE_BK0_ISFOR: equ 1  
0069			;STORE_BK0_LABEL: equ 3  
0069			  
0069			; memory allocation   
0069			  
0069			chk_stund: equ tos+2           ; underflow check word  
0069			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0069			  
0069			; keyscan table needs rows x cols buffer  
0069			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0069			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0069			  
0069			keyscan_table_row1: equ chk_stovr -key_cols-1  
0069			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0069			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0069			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0069			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0069			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0069			keyscan_scancol: equ keyscan_table-key_cols  
0069			;keyscan_table_len: equ key_rows*key_cols  
0069			;keybufptr: equ keyscan_table - 2  
0069			;keysymbol: equ keybufptr - 1  
0069			key_held: equ keyscan_scancol-1	; currently held  
0069			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0069			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0069			key_fa: equ key_repeat_ct -1 ;  
0069			key_fb: equ key_fa -1 ;  
0069			key_fc: equ key_fb -1 ;  
0069			key_fd: equ key_fc -1 ;  
0069			key_face_held: equ key_fd - 1   
0069			  
0069			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0069			  
0069			hardware_config: equ key_face_held - 10  
0069			  
0069			; hardware config switches  
0069			; TODO add bitmasks on includes for hardware  
0069			; high byte for expansion ids  
0069			;     0000 0000  no card inserted  
0069			;     0000 0001  storage card inserted  
0069			;     0000 0010  spi sd card active  
0069			  
0069			;       
0069			; low byte:  
0069			;     0000 0001   4x4 keypad  
0069			;     0000 0010   full keyboard  
0069			;     0000 0011   spi/ext keyboard  
0069			;     0000 0100   20x4 lcd  
0069			;     0000 1000   40x4 lcd  
0069			;     0000 1100   spi/ext display  
0069			;     0001 0000   ide interface available  
0069			  
0069			hardware_word: equ hardware_config - 2  
0069			  
0069			; debug marker - optional display of debug point on the debug screens  
0069			  
0069			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0069			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0069			  
0069			debug_mark: equ debug_vector - 4  
0069			  
0069			; input_str vars  
0069			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0069			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0069			input_size: equ input_start -1  ; number of chars  
0069			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0069			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0069			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0069			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0069			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0069			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0069			input_len: equ input_cur_onoff - 5 ; length of current input  
0069			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0069			  
0069			CUR_BLINK_RATE: equ 15  
0069			  
0069			key_actual_pressed: equ input_cursor - 1   
0069			key_symbol: equ key_actual_pressed - 1   
0069			key_shift: equ key_symbol - 1   
0069			  
0069			; Display allocation  
0069			  
0069			;display_rows: equ 4     ; move out to mini and mega files  
0069			;display_cols: equ 20  
0069			  
0069			display_fb_len: equ display_rows*display_cols  
0069			  
0069			; primary frame buffer     
0069			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0069			; working frame buffers  
0069			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0069			display_fb3: equ  display_fb1-display_fb_len - 1  
0069			display_fb2: equ  display_fb3-display_fb_len - 1  
0069			;  
0069			; pointer to active frame buffer  
0069			display_fb_active: equ display_fb2 - 2  
0069			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0069			display_write_tmp: equ display_lcde1e2 - 2  
0069			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0069			  
0069			;  
0069			  
0069			;; can load into de directory  
0069			cursor_col: equ display_active-1  
0069			cursor_row: equ cursor_col-1  
0069			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0069			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0069			  
0069			; maths vars  
0069			  
0069			LFSRSeed: equ cursor_shape -20   
0069			randData: equ LFSRSeed - 2  
0069			xrandc: equ randData - 2  
0069			stackstore: equ xrandc - 2  
0069			seed1: equ  stackstore -2   
0069			seed2: equ seed1 - 2  
0069			  
0069			; cf storage vars  
0069			  
0069			iErrorNum:  equ seed2-1         ;Error number  
0069			iErrorReg:  equ iErrorNum -1              ;Error register  
0069			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0069			  
0069			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0069			  
0069			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0069			  
0069			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0069			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0069			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0069			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0069			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0069			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0069			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0069			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0069			store_tmpid: equ store_tmp3 - 1		; page temp id  
0069			store_tmpext: equ store_tmpid - 1		; file extent temp  
0069			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0069			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0069			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0069			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0069			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0069			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0069			;  
0069			; spi vars  
0069			  
0069			  
0069			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0069			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0069			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0069			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0069			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0069			spi_device_id: equ spi_device - 1    ; human readable bank number  
0069			  
0069			;;;;; forth cli params  
0069			  
0069			; TODO use a different frame buffer for forth???  
0069			  
0069			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0069			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0069			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0069			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0069			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0069			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0069			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0069			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0069			  
0069			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0069			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0069			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0069			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0069			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0069			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0069			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0069			  
0069			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0069			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0069			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0069			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0069			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0069			  
0069			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0069			  
0069			; os/forth token vars  
0069			  
0069			os_last_cmd: equ os_var_array-255  
0069			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0069			os_current_i: equ os_cli_cmd-2  
0069			os_cur_ptr: equ os_current_i-2  
0069			os_word_scratch: equ os_cur_ptr-30  
0069			os_tok_len: equ os_word_scratch - 2  
0069			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0069			os_tok_malloc: equ os_tok_ptr - 2  
0069			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0069			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0069			execscratch: equ os_input-255        ; exec cmd eval buffer  
0069			scratch: equ execscratch-255  
0069			  
0069			os_stack_1: equ scratch - 3       ; stack holding area 1  
0069			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0069			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0069			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0069			  
0069			  
0069			; temp locations for new word processing to save on adding more   
0069			  
0069			os_new_malloc: equ os_stack_4-2  
0069			os_new_parse_len: equ os_new_malloc - 2  
0069			os_new_word_len: equ os_new_parse_len - 2  
0069			os_new_work_ptr: equ os_new_word_len - 2  
0069			os_new_src_ptr: equ os_new_work_ptr - 2  
0069			os_new_exec: equ os_new_src_ptr - 2  
0069			os_new_exec_ptr: equ os_new_exec - 2  
0069			  
0069			; resume memory alloocations....  
0069			  
0069			;os_view_disable: equ os_new_exec_ptr - 1  
0069			os_view_af: equ os_new_exec_ptr - 2  
0069			os_view_hl: equ os_view_af -2  
0069			os_view_de: equ os_view_hl - 2  
0069			os_view_bc: equ os_view_de - 2  
0069			  
0069			; stack checksum word  
0069			if DEBUG_STACK_IMB  
0069				curframe: equ  os_view_de - 5  
0069				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0069				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			else  
0069				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			endif  
0069			  
0069			; with data stack could see memory filled with junk. need some memory management   
0069			; malloc and free entry points added  
0069			  
0069			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0069			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			;heap_end: equ free_list-1  ; Starting address of heap  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			heap_end: equ chk_word-1  ; Starting address of heap  
0069			  
0069			  
0069			;if BASE_KEV   
0069			;heap_start: equ 0800eh  ; Starting address of heap  
0069			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;heap_start: equ baseram+15  ; Starting address of heap  
0069			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;endif  
0069			  
0069			  
0069			;;;;  
0069			  
0069			  
0069			; change below to point to last memory alloc above  
0069			topusermem:  equ   heap_start  
0069			  
0069			;if BASE_KEV   
0069			;baseusermem: equ 08000h  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;;aseusermem:     equ    12  
0069			;baseusermem:     equ    prompt  
0069			;;baseusermem:     equ    endofcode  
0069			;endif  
0069			  
0069			  
0069			; **********************************************************************  
0069			; **  Constants  
0069			; **********************************************************************  
0069			  
0069			; Constants used by this code module  
0069			kDataReg:   EQU Device_D           ;PIO port A data register  
0069			kContReg:   EQU Device_D+2           ;PIO port A control register  
0069			  
0069			  
0069			portbdata:  equ Device_D+1    ; port b data  
0069			portbctl:   equ Device_D+3    ; port b control  
0069			  
0069			  
0069			;KEY_SHIFT:   equ 5  
0069			;KEY_SYMBOLSHIFT:  equ 6  
0069			  
0069			KEY_SHIFTLOCK: equ 4  
0069			  
0069			  
0069			KEY_UP: equ 5  
0069			KEY_NEXTWORD: equ 6  
0069			KEY_PREVWORD: equ 7  
0069			KEY_BS: equ 8  
0069			KEY_TAB:  equ 9  
0069			KEY_DOWN: equ 10  
0069			KEY_LEFT: equ 11  
0069			KEY_RIGHT: equ 12  
0069			KEY_CR:   equ 13  
0069			KEY_HOME: equ 14  
0069			KEY_END: equ 15  
0069			  
0069			KEY_F1: equ 16  
0069			KEY_F2: equ 17  
0069			KEY_F3: equ 18  
0069			KEY_F4: equ 19  
0069			  
0069			KEY_F5: equ 20  
0069			KEY_F6: equ 21  
0069			KEY_F7: equ 22  
0069			KEY_F8: equ 23  
0069			  
0069			KEY_F9: equ 24  
0069			KEY_F10: equ 25  
0069			KEY_F11: equ 26  
0069			KEY_F12: equ 27  
0069			  
0069			;if DEBUG_KEY  
0069			;	KEY_MATRIX_NO_PRESS: equ '.'  
0069			;	KEY_SHIFT:   equ '.'  
0069			;	KEY_SYMBOLSHIFT:  equ '.'  
0069			;else  
0069				KEY_SHIFT:   equ '~'  
0069				KEY_SYMBOLSHIFT:  equ '~'  
0069				KEY_MATRIX_NO_PRESS: equ '~'  
0069			;endi  
0069			  
0069			  
0069			  
0069			  
0069			; Macro to make adding debug marks easier  
0069			  
0069			DMARK: macro str  
0069				push af  
0069				ld a, (.dmark)  
0069				ld (debug_mark),a  
0069				ld a, (.dmark+1)  
0069				ld (debug_mark+1),a  
0069				ld a, (.dmark+2)  
0069				ld (debug_mark+2),a  
0069				jr .pastdmark  
0069			.dmark: db str  
0069			.pastdmark: pop af  
0069			  
0069			endm  
0069			  
0069			  
0069			; macro to detect for stack imbalances  
0069			  
0069			include "stackimbal.asm"  
0069			; Macro and code to detect stock imbalances 
0069			 
0069			SPPUSH: equ 0 
0069			 
0069			; Add a stack frame which can be checked before return 
0069			 
0069			STACKFRAME: macro onoff frame1 frame2 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069						exx 
0069			 
0069						ld de, frame1 
0069						ld a, d 
0069						ld hl, curframe 
0069						call hexout 
0069						ld a, e 
0069						ld hl, curframe+2 
0069						call hexout 
0069			  
0069						ld hl, frame1 
0069						push hl 
0069						ld hl, frame2 
0069						push hl 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			endm 
0069			 
0069			STACKFRAMECHK: macro onoff frame1 frame2 
0069			 
0069					 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						exx 
0069						; check stack frame SP 
0069			 
0069						ld hl, frame2 
0069						pop de   ; frame2 
0069			 
0069						call cmp16 
0069						jr nz, .spnosame 
0069						 
0069			 
0069						ld hl, frame1 
0069						pop de   ; frame1 
0069			 
0069						call cmp16 
0069						jr z, .spfrsame 
0069			 
0069						.spnosame: call showsperror 
0069			 
0069						.spfrsame: nop 
0069			 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			 
0069			 
0069			endm 
0069			 
0069			 
0069			; for a sub routine, wrap SP collection and comparisons 
0069			 
0069			; Usage: 
0069			; 
0069			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0069			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0069			 
0069			SAVESP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069			 
0069						ld (store_sp+(storeword*4)), sp 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			CHECKSP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069			 
0069						; save SP after last save 
0069				 
0069						ld (store_sp+(storeword*4)+2), sp 
0069			 
0069						push hl 
0069						ld hl, store_sp+(storeword*4) 
0069						call check_stack_sp  
0069						pop hl 
0069			 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			if DEBUG_STACK_IMB 
0069			 
0069			check_stack_sp: 
0069					push de 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					push de 
0069			 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					pop hl 
0069			 
0069			 
0069					; check to see if the same 
0069			 
0069					call cmp16 
0069					jr z, .spsame 
0069			 
0069					; not same 
0069			 
0069					call showsperror 
0069			.spsame: 
0069			 
0069					pop de 
0069			 
0069					ret 
0069			 
0069			.sperr:  db "Stack imbalance",0 
0069			 
0069			 
0069			showsperror: 
0069			 
0069			 
0069				push hl 
0069				push af 
0069				push de 
0069				call clear_display 
0069				ld de, .sperr 
0069				ld a,0 
0069			;	ld de,os_word_scratch 
0069				call str_at_display 
0069				ld a, display_row_1+17 
0069				ld de, debug_mark 
0069				call str_at_display 
0069				ld a, 0 
0069				ld (curframe+4),a 
0069				ld hl, curframe 
0069				ld de, os_word_scratch 
0069				ld a, display_row_4 
0069				call str_at_display 
0069				call update_display 
0069				;call break_point_state 
0069				call cin_wait 
0069			 
0069			;	ld a, ' ' 
0069			;	ld (os_view_disable), a 
0069				call bp_on 
0069				pop de	 
0069				pop af 
0069				pop hl 
0069				CALLMONITOR 
0069				ret 
0069			 
0069			endif 
0069			 
0069			 
0069			 
0069			; eof 
# End of file stackimbal.asm
0069			  
0069			;TODO macro to calc col and row offset into screen  
0069			  
0069			  
0069			  
0069			hardware_init:  
0069			  
0069				  
0069			  
0069					;ld a, 0  
0069					;ld (hardware_diag), a  
0069			  
0069					; clear all the buffers  
0069			  
0069 21 0d fd				ld hl, display_fb1  
006c 22 c9 fb				ld (display_fb_active), hl  
006f			  
006f cd 9c 0d				call clear_display  
0072			  
0072 21 cb fb				ld hl, display_fb2  
0075 22 c9 fb				ld (display_fb_active), hl  
0078			  
0078 cd 9c 0d				call clear_display  
007b			  
007b					; init primary frame buffer area  
007b 21 ae fd				ld hl, display_fb0  
007e 22 c9 fb				ld (display_fb_active), hl  
0081			  
0081 cd 9c 0d				call clear_display  
0084			  
0084			  
0084 cd 5e 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0087			  
0087 cd f5 78			call key_init  
008a cd 48 02			call storage_init  
008d			  
008d				; setup malloc functions  
008d			  
008d				if MALLOC_1  
008d cd 73 14				call  heap_init  
0090				endif  
0090				if MALLOC_4  
0090					call  heap_init  
0090				endif  
0090			  
0090				; init sound hardware if present  
0090			  
0090				if SOUND_ENABLE  
0090					call sound_init  
0090				endif  
0090			  
0090				; lcd test sequence  
0090					  
0090 cd bf 0d			call update_display  
0093 cd df 0c			call delay1s  
0096 3e 2b			ld a,'+'  
0098 cd a1 0d			call fill_display  
009b cd bf 0d			call update_display  
009e cd df 0c			call delay1s  
00a1 3e 2a			ld a,'*'  
00a3 cd a1 0d			call fill_display  
00a6 cd bf 0d			call update_display  
00a9 cd df 0c			call delay1s  
00ac 3e 2d			ld a,'-'  
00ae cd a1 0d			call fill_display  
00b1 cd bf 0d			call update_display  
00b4 cd df 0c			call delay1s  
00b7			  
00b7			; boot splash screen  
00b7			if display_cols == 20	  
00b7			        ld a, display_row_1    
00b7			else  
00b7 3e 0a		        ld a, display_row_1 +10   
00b9			endif  
00b9 11 11 1c			ld de, prom_bootmsg  
00bc cd af 0d			call str_at_display  
00bf cd bf 0d			call update_display  
00c2			  
00c2			  
00c2 cd df 0c			call delay1s  
00c5 cd df 0c			call delay1s  
00c8			if display_cols == 20	  
00c8			            LD   A, display_row_3+2  
00c8			else  
00c8 3e 5c		            LD   A, display_row_3+12  
00ca			endif  
00ca 11 26 1c			ld de, prom_bootmsg1  
00cd cd af 0d			call str_at_display  
00d0 cd bf 0d			call update_display  
00d3 cd df 0c			call delay1s  
00d6 cd df 0c			call delay1s  
00d9			  
00d9			;	ld a, display_row_4+3  
00d9			;	ld de, bootmsg2  
00d9			;	call str_at_display  
00d9			;	call update_display  
00d9			;	call delay1s  
00d9			;	call delay1s  
00d9			  
00d9			; debug mark setup  
00d9			  
00d9 3e 5f		ld a, '_'  
00db 32 68 fe		ld (debug_mark),a  
00de 32 69 fe		ld (debug_mark+1),a  
00e1 32 6a fe		ld (debug_mark+2),a  
00e4 3e 00		ld a,0  
00e6 32 6b fe		ld (debug_mark+3),a  
00e9			  
00e9 c9					ret  
00ea			  
00ea			  
00ea			;bootmsg2:	db "Firmware v0.1",0  
00ea			  
00ea			; a 4x20 lcd  
00ea			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ea			  
00ea			;if display_cols == 20  
00ea			;	include "firmware_lcd_4x20.asm"  
00ea			;endif  
00ea			  
00ea			;if display_cols == 40  
00ea			;	include "firmware_lcd_4x40.asm"  
00ea			;endif  
00ea			  
00ea			;  
00ea			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ea			; TODO abstract the bit bang video out interface for dual display  
00ea			; TODO wire video out to tx pin on rc2014 bus  
00ea			  
00ea			; must supply cin, and cin_wait for low level hardware abstraction   
00ea			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ea			; test scancode  
00ea			  
00ea			;;;;;  
00ea			;;;  
00ea			; Moved out to mini and maxi versions  
00ea			;  
00ea			; include "firmware_key_4x4.asm"  
00ea			; using existing 4 wire x 4 resistor array for input  
00ea			;include "firmware_key_4x10.asm"  
00ea			; need to mod the board for 5 rows due to resistor array  
00ea			;include "firmware_key_5x10.asm"  
00ea			  
00ea			; storage hardware interface  
00ea			  
00ea			; use microchip serial eeprom for storage  
00ea			  
00ea			  
00ea			if STORAGE_SE  
00ea				include "firmware_spi.asm"  
00ea			; my spi protocol (used by storage) 
00ea			 
00ea			; SPI pins 
00ea			 
00ea			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ea			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ea			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ea			 
00ea			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ea			; chip pin 4 gnd 
00ea			 
00ea			 
00ea			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ea			SPI_CE1: equ 1      ;    port a1 pin 14  
00ea			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ea			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ea			SPI_CE4: equ 4      ; port a4     pin 10 
00ea			 
00ea			; active low AND masks 
00ea			 
00ea			;SPI_CE0_MASK: equ    255-1 
00ea			;SPI_CE1_MASK: equ   255-2 
00ea			;SPI_CE2_MASK: equ   255-4 
00ea			;SPI_CE3_MASK: equ   255-8 
00ea			;SPI_CE4_MASK: equ   255-16 
00ea			SPI_CE_HIGH:  equ 255 
00ea			 
00ea			 
00ea			 
00ea			;  Perform SCLK wait pulse 
00ea			 
00ea			spi_clk: 
00ea f5				push af 
00eb 3a 61 fa			ld a, (spi_clktime) 
00ee fe 00			cp 0 
00f0 28 03			jr z, .scskip 
00f2 cd c4 0c			call aDelayInMS 
00f5			.scskip: 
00f5 f1				pop af 
00f6 c9				ret 
00f7			 
00f7			 
00f7			 
00f7			; TODO store port id for spi device ie dev c 
00f7			; TODO store pin for SO 
00f7			; TODO store pin for SI 
00f7			; TODO store pin for SCLK 
00f7			 
00f7			; 
00f7			 
00f7			; ensure that spi bus is in a stable state with default pins  
00f7			 
00f7			se_stable_spi:   
00f7			 
00f7				 ; set DI high, CE high , SCLK low 
00f7				;ld a, SPI_DI | SPI_CE0 
00f7 3e 07			ld a, SPI_DI  
00f9 cd 03 02			call spi_ce_high 
00fc d3 80			 out (storage_adata),a 
00fe 32 5e fa			ld (spi_portbyte),a 
0101			 
0101				if DEBUG_SPI 
0101					push hl 
0101					ld l, a 
0101					DMARK "SPI" 
0101					CALLMONITOR 
0101					pop hl 
0101				endif 
0101 c9				ret 
0102			 
0102			; byte to send in a 
0102			 
0102			spi_send_byte: 
0102				; save byte to send for bit mask shift out 
0102 4f			        ld c,a 
0103 3a 5e fa			ld a,(spi_portbyte) 
0106				  
0106				; clock out	each bit of the byte msb first 
0106			 
0106 06 08			ld b, 8 
0108			.ssb1: 
0108				; clear so bit  
0108 cb bf			res SPI_DI, a 
010a cb 11			rl c 
010c				; if bit 7 is set then carry is set 
010c 30 02			jr nc, .ssb2 
010e cb ff			set SPI_DI,a 
0110			.ssb2:  ; output bit to ensure it is stable 
0110 d3 80			out (storage_adata),a 
0112 00				nop 
0113				; clock bit high 
0113 cb ef			set SPI_SCLK,a 
0115 d3 80			out (storage_adata),a 
0117 00				nop 
0118 cd ea 00			call spi_clk 
011b				; then low 
011b cb af			res SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120 cd ea 00			call spi_clk 
0123 10 e3			djnz .ssb1 
0125			 
0125 32 5e fa			ld (spi_portbyte),a 
0128 c9				ret 
0129			 
0129			; TODO low level get byte into A on spi 
0129			 
0129			spi_read_byte:  
0129			 
0129				; save byte to send for bit mask shift out 
0129 0e 00		    ld c,0 
012b 3a 5e fa			ld a,(spi_portbyte) 
012e				  
012e				; clock out	each bit of the byte msb first 
012e			 
012e			 
012e				; clock bit high 
012e cb ef			set SPI_SCLK,a 
0130 d3 80			out (storage_adata),a 
0132 00				nop 
0133 cd ea 00			call spi_clk 
0136			 
0136			    ; read DO  
0136			 
0136 cb f9		    set 7,c 
0138 db 80			in a,(storage_adata) 
013a cb 77		    bit SPI_DO,a 
013c 20 02		    jr nz, .b7 
013e cb b9		    res 7,c 
0140			.b7: 
0140				; then low 
0140 cb af			res SPI_SCLK,a 
0142 d3 80			out (storage_adata),a 
0144 00				nop 
0145 cd ea 00			call spi_clk 
0148			     
0148			 
0148				; clock bit high 
0148 cb ef			set SPI_SCLK,a 
014a d3 80			out (storage_adata),a 
014c 00				nop 
014d cd ea 00			call spi_clk 
0150			 
0150			    ; read DO  
0150			 
0150 cb f1		    set 6,c 
0152 db 80			in a,(storage_adata) 
0154 cb 77		    bit SPI_DO,a 
0156 20 02		    jr nz, .b6 
0158 cb b1		    res 6,c 
015a			.b6: 
015a				; then low 
015a cb af			res SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f cd ea 00			call spi_clk 
0162			 
0162				; clock bit high 
0162 cb ef			set SPI_SCLK,a 
0164 d3 80			out (storage_adata),a 
0166 00				nop 
0167 cd ea 00			call spi_clk 
016a			 
016a			 
016a			    ; read DO  
016a			 
016a cb e9		    set 5,c 
016c db 80			in a,(storage_adata) 
016e cb 77		    bit SPI_DO,a 
0170 20 02		    jr nz, .b5 
0172 cb a9		    res 5,c 
0174			.b5: 
0174				; then low 
0174 cb af			res SPI_SCLK,a 
0176 d3 80			out (storage_adata),a 
0178 00				nop 
0179 cd ea 00			call spi_clk 
017c				; clock bit high 
017c cb ef			set SPI_SCLK,a 
017e d3 80			out (storage_adata),a 
0180 00				nop 
0181 cd ea 00			call spi_clk 
0184			 
0184			    ; read DO  
0184			 
0184 cb e1		    set 4,c 
0186 db 80			in a,(storage_adata) 
0188 cb 77		    bit SPI_DO,a 
018a 20 02		    jr nz, .b4 
018c cb a1		    res 4,c 
018e			.b4: 
018e				; then low 
018e cb af			res SPI_SCLK,a 
0190 d3 80			out (storage_adata),a 
0192 00				nop 
0193 cd ea 00			call spi_clk 
0196				; clock bit high 
0196 cb ef			set SPI_SCLK,a 
0198 d3 80			out (storage_adata),a 
019a 00				nop 
019b cd ea 00			call spi_clk 
019e			 
019e			    ; read DO  
019e			 
019e cb d9		    set 3,c 
01a0 db 80			in a,(storage_adata) 
01a2 cb 77		    bit SPI_DO,a 
01a4 20 02		    jr nz, .b3 
01a6 cb 99		    res 3,c 
01a8			.b3: 
01a8				; then low 
01a8 cb af			res SPI_SCLK,a 
01aa d3 80			out (storage_adata),a 
01ac 00				nop 
01ad cd ea 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4 00				nop 
01b5 cd ea 00			call spi_clk 
01b8			 
01b8			    ; read DO  
01b8			 
01b8 cb d1		    set 2,c 
01ba db 80			in a,(storage_adata) 
01bc cb 77		    bit SPI_DO,a 
01be 20 02		    jr nz, .b2 
01c0 cb 91		    res 2,c 
01c2			.b2: 
01c2				; then low 
01c2 cb af			res SPI_SCLK,a 
01c4 d3 80			out (storage_adata),a 
01c6 00				nop 
01c7 cd ea 00			call spi_clk 
01ca				; clock bit high 
01ca cb ef			set SPI_SCLK,a 
01cc d3 80			out (storage_adata),a 
01ce 00				nop 
01cf cd ea 00			call spi_clk 
01d2			 
01d2			    ; read DO  
01d2			 
01d2 cb c9		    set 1,c 
01d4 db 80			in a,(storage_adata) 
01d6 cb 77		    bit SPI_DO,a 
01d8 20 02		    jr nz, .b1 
01da cb 89		    res 1,c 
01dc			.b1: 
01dc				; then low 
01dc cb af			res SPI_SCLK,a 
01de d3 80			out (storage_adata),a 
01e0 00				nop 
01e1 cd ea 00			call spi_clk 
01e4				; clock bit high 
01e4 cb ef			set SPI_SCLK,a 
01e6 d3 80			out (storage_adata),a 
01e8 00				nop 
01e9 cd ea 00			call spi_clk 
01ec			 
01ec			    ; read DO  
01ec			 
01ec cb c1		    set 0,c 
01ee db 80			in a,(storage_adata) 
01f0 cb 77		    bit SPI_DO,a 
01f2 20 02		    jr nz, .b0 
01f4 cb 81		    res 0,c 
01f6			.b0: 
01f6				; then low 
01f6 cb af			res SPI_SCLK,a 
01f8 d3 80			out (storage_adata),a 
01fa 00				nop 
01fb cd ea 00			call spi_clk 
01fe			 
01fe			 
01fe 32 5e fa			ld (spi_portbyte),a 
0201			 
0201			    ; return byte 
0201 79			    ld a,c 
0202			 
0202			 
0202 c9				ret 
0203			 
0203			 
0203			 
0203			spi_ce_high: 
0203			 
0203				if DEBUG_SPI_HARD_CE0 
0203			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0203					ret 
0203			 
0203				endif 
0203			 
0203			 
0203 f5				push af 
0204			 
0204				; send direct ce to port b 
0204 3e ff			ld a, 255 
0206 d3 81			out (storage_bdata), a 
0208			 
0208 f1				pop af 
0209			 
0209				; for port a that shares with spi lines AND the mask 
0209			  
0209				if DEBUG_SPI 
0209					push hl 
0209					ld h, a 
0209				endif 
0209			;	ld c, SPI_CE_HIGH 
0209			;	and c 
0209 cb c7			set SPI_CE0, a 
020b cb cf			set SPI_CE1, a 
020d cb d7			set SPI_CE2, a 
020f cb df			set SPI_CE3, a 
0211 cb e7			set SPI_CE4, a 
0213			 
0213				if DEBUG_SPI 
0213					ld l, a 
0213					DMARK "CEh" 
0213					CALLMONITOR 
0213					pop hl 
0213				endif 
0213 c9				ret 
0214			 
0214			 
0214			spi_ce_low: 
0214			 
0214				if DEBUG_SPI_HARD_CE0 
0214			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214					ret 
0214			 
0214				endif 
0214			 
0214 c5				push bc 
0215 f5				push af 
0216			 
0216				; send direct ce to port b 
0216 3a 60 fa			ld a, (spi_cartdev) 
0219 d3 81			out (storage_bdata), a 
021b			 
021b			 
021b			 
021b				; for port a that shares with spi lines AND the mask 
021b			 
021b 3a 5d fa			ld a, (spi_device)  
021e 4f				ld c, a 
021f			 
021f f1				pop af 
0220			 
0220				; detect CEx 
0220			 
0220				if DEBUG_SPI 
0220					push hl 
0220					ld h, a 
0220				endif 
0220			 
0220 cb 41			bit SPI_CE0, c 
0222 20 04			jr nz, .cel1 
0224 cb 87			res SPI_CE0, a 
0226 18 1e			jr .celn 
0228			.cel1: 
0228 cb 49			bit SPI_CE1, c 
022a 20 04			jr nz, .cel2 
022c cb 8f			res SPI_CE1, a 
022e 18 16			jr .celn 
0230			.cel2: 
0230 cb 51			bit SPI_CE2, c 
0232 20 04			jr nz, .cel3 
0234 cb 97			res SPI_CE2, a 
0236 18 0e			jr .celn 
0238			.cel3: 
0238 cb 59			bit SPI_CE3, c 
023a 20 04			jr nz, .cel4 
023c cb 9f			res SPI_CE3, a 
023e 18 06			jr .celn 
0240			.cel4: 
0240 cb 61			bit SPI_CE4, c 
0242 20 02			jr nz, .celn 
0244 cb a7			res SPI_CE4, a 
0246			.celn: 
0246			 
0246			 
0246			 
0246			;	add c 
0246			 
0246				if DEBUG_SPI 
0246					ld l, a 
0246					DMARK "CEl" 
0246					CALLMONITOR 
0246					pop hl 
0246				endif 
0246 c1				pop bc 
0247 c9				ret 
0248			 
0248			 
0248			 
0248			; eof 
0248			 
0248			 
0248			 
0248			 
0248			 
# End of file firmware_spi.asm
0248				include "firmware_seeprom.asm"  
0248			; 
0248			; persisent storage interface via microchip serial eeprom 
0248			 
0248			; port a pio 2 
0248			; pa 7 - si 
0248			; pa 6 - sclk  
0248			; pa 5 - so 
0248			; pa 4 - cs 
0248			; pa 3 - cs 
0248			; pa 2 - cs 
0248			; pa 1 - cs 
0248			; pa 0 - cs 
0248			; 
0248			; TODO get block 
0248			; TODO save block 
0248			; TODO load file 
0248			; TODO save file 
0248			; TODO get dir  
0248			 
0248			;  
0248			storage_adata: equ Device_C    ; device c port a - onboard storage 
0248			storage_actl: equ Device_C+2     ; device c port a 
0248			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0248			storage_bctl: equ Device_C+3     ; device c port b 
0248			 
0248			 
0248			; TODO move these to hardware driver file 
0248			 
0248			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0248			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0248			; storage bank file system format 
0248			; 
0248			; first page of bank: 
0248			; 	addr 0 - status check 
0248			;       addr 1 - write protect flag 
0248			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0248			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0248			;         TODO see if scanning whole of for available next file id is fast enough 
0248			;	addr 4 > zero term string of bank label 
0248			; 
0248			;        
0248			;  
0248			; first page of any file: 
0248			;      byte 0 - file id  
0248			;      byte 1-17 - fixed file name  
0248			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0248			; 
0248			; other pages of any file: 
0248			;      byte 0 - file id 
0248			;      byte 1> - file data 
0248			; 
0248			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0248			;  
0248			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0248			 
0248			 
0248			;storage_so_bit: 5 
0248			;storage_si_bit: 7 
0248			;storage_sclk_bit: 6 
0248			  
0248			 
0248			; init storage pio 
0248			 
0248			storage_init: 
0248			 
0248			 
0248					; set default SPI clk pulse time as disabled 
0248			 
0248 3e 00				ld a, 0 
024a 32 61 fa				ld (spi_clktime), a 
024d			 
024d					; init hardware 
024d			 
024d 3e cf		            LD   A, 11001111b 
024f d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0251 3e 00		            LD   A, 00000000b 
0253 cb f7			set SPI_DO,a 
0255			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0255 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0257			 
0257 3e cf		            LD   A, 11001111b 
0259 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025b 3e 00		            LD   A, 00000000b 
025d d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025f			 
025f				; set all external spi devices off  
025f 3e ff			ld a, 255 
0261 32 5d fa			ld (spi_device), a 
0264 32 60 fa			ld (spi_cartdev), a 
0267			 
0267					; ensure the spi bus is in a default stable state 
0267 cd f7 00				call se_stable_spi 
026a			 
026a			; TODO scan spi bus and gather which storage banks are present 
026a			 
026a			; populate store_bank_active  
026a			; for each ce line activate and attempt to write first byte of bank and read back 
026a			; if zero is returned then bank is empty 
026a			;   
026a			; 
026a			 
026a					; init file extent cache to save on slow reads 
026a			 
026a			;	ld hl, store_filecache 
026a			;	ld de, 0 
026a			;	ld hl,(de)	 
026a			 
026a			 
026a c9			    ret 
026b			 
026b			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026b			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026b			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026b			 
026b			; INSTRUCTION SET 
026b			; READ 0000 0011 Read data from memory array beginning at selected address 
026b			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026b			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026b			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026b			; RDSR 0000 0101 Read STATUS register 
026b			; WRSR 0000 0001 Write STATUS register 
026b			; PE 0100 0010 Page Erase – erase one page in memory array 
026b			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026b			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026b			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026b			 
026b			; TODO send byte steam for page without setting the address for every single byte 
026b			; TODO read byte  
026b			 
026b			; byte in a 
026b			; address in hl  
026b			se_writebyte: 
026b			        
026b			    ;   ld c, a 
026b f5			        push af 
026c e5			        push hl 
026d			 
026d			    ; initi write mode 
026d			    ; 
026d			    ;CS low 
026d			 
026d 3a 5e fa		       ld a,(spi_portbyte) 
0270 cd 14 02			call spi_ce_low 
0273			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0273 d3 80		       out (storage_adata),a 
0275 32 5e fa		       ld (spi_portbyte), a 
0278			 
0278			    ;clock out wren instruction 
0278			 
0278 3e 06		    ld a, store_wren_ins 
027a cd 02 01		    call spi_send_byte  
027d			 
027d			    ;cs high to enable write latch 
027d			 
027d 3a 5e fa		       ld a,(spi_portbyte) 
0280 cd 03 02			call spi_ce_high 
0283			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0283 d3 80		       out (storage_adata),a 
0285 32 5e fa		       ld (spi_portbyte), a 
0288			 
0288 00				nop 
0289			    ; 
0289			    ; intial write data 
0289			    ; 
0289			    ; cs low 
0289			     
0289 3a 5e fa		       ld a,(spi_portbyte) 
028c cd 14 02			call spi_ce_low 
028f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028f d3 80		       out (storage_adata),a 
0291 32 5e fa		       ld (spi_portbyte), a 
0294			 
0294			    ; clock out write instruction 
0294			     
0294 3e 02		    ld a, store_write_ins  
0296 cd 02 01		    call spi_send_byte  
0299			 
0299			    ; clock out address (depending on address size) 
0299			     
0299 e1			    pop hl 
029a 7c			    ld a,h    ; address out msb first 
029b cd 02 01		    call spi_send_byte  
029e 7d			    ld a,l 
029f cd 02 01		    call spi_send_byte  
02a2			 
02a2			    ; clock out byte(s) for page 
02a2			 
02a2 f1			    pop af 
02a3 cd 02 01		    call spi_send_byte  
02a6			 
02a6			    ; end write with ce high 
02a6 3a 5e fa		       ld a,(spi_portbyte) 
02a9			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a9 cd 03 02			call spi_ce_high 
02ac d3 80		       out (storage_adata),a 
02ae 32 5e fa		       ld (spi_portbyte), a 
02b1			 
02b1				; pause for internal write cycle 
02b1 3e 0a			ld a, 10 
02b3 cd c4 0c			call aDelayInMS 
02b6 c9			    ret 
02b7			 
02b7			; buffer to write in de 
02b7			; address in hl  
02b7			se_writepage: 
02b7			        
02b7			    ;   ld c, a 
02b7 d5				push de 
02b8 e5			        push hl 
02b9			 
02b9			    ; initi write mode 
02b9			    ; 
02b9			    ;CS low 
02b9			 
02b9 3a 5e fa		       ld a,(spi_portbyte) 
02bc cd 14 02			call spi_ce_low 
02bf			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02bf d3 80		       out (storage_adata),a 
02c1 32 5e fa		       ld (spi_portbyte), a 
02c4			 
02c4			    ;clock out wren instruction 
02c4			 
02c4 3e 06		    ld a, store_wren_ins 
02c6 cd 02 01		    call spi_send_byte  
02c9			 
02c9			    ;cs high to enable write latch 
02c9			 
02c9 3a 5e fa		       ld a,(spi_portbyte) 
02cc cd 03 02			call spi_ce_high 
02cf			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cf d3 80		       out (storage_adata),a 
02d1 32 5e fa		       ld (spi_portbyte), a 
02d4			 
02d4 00				nop 
02d5			    ; 
02d5			    ; intial write data 
02d5			    ; 
02d5			    ; cs low 
02d5			     
02d5 3a 5e fa		       ld a,(spi_portbyte) 
02d8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d8 cd 14 02			call spi_ce_low 
02db d3 80		       out (storage_adata),a 
02dd 32 5e fa		       ld (spi_portbyte), a 
02e0			 
02e0			    ; clock out write instruction 
02e0			     
02e0 3e 02		    ld a, store_write_ins  
02e2 cd 02 01		    call spi_send_byte  
02e5			 
02e5			    ; clock out address (depending on address size) 
02e5			     
02e5 e1			    pop hl 
02e6 7c			    ld a,h    ; address out msb first 
02e7 cd 02 01		    call spi_send_byte  
02ea 7d			    ld a,l 
02eb cd 02 01		    call spi_send_byte  
02ee			 
02ee			    ; clock out byte(s) for page 
02ee			 
02ee e1				pop hl 
02ef 06 40			ld b, STORE_BLOCK_PHY 
02f1			.bytewrite: 
02f1			 
02f1 7e				ld a,(hl) 
02f2 e5			    push hl 
02f3 c5				push bc 
02f4 cd 02 01		    call spi_send_byte  
02f7 c1				pop bc 
02f8 e1				pop hl 
02f9			 
02f9			    ; end write with ce high 
02f9 3a 5e fa		       ld a,(spi_portbyte) 
02fc cd 03 02			call spi_ce_high 
02ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ff d3 80		       out (storage_adata),a 
0301 32 5e fa		       ld (spi_portbyte), a 
0304			 
0304 23				inc hl 
0305 10 ea			djnz .bytewrite 
0307			 
0307				; pause for internal write cycle 
0307 3e 64			ld a, 100 
0309 cd c4 0c			call aDelayInMS 
030c c9			    ret 
030d			; returns byte in a 
030d			; address in hl  
030d			se_readbyte: 
030d d5				push de 
030e c5				push bc 
030f			 
030f			    ;   ld c, a 
030f e5			        push hl 
0310			 
0310			    ; initi write mode 
0310			    ; 
0310			    ;CS low 
0310			 
0310 3a 5e fa		       ld a,(spi_portbyte) 
0313 cd 14 02			call spi_ce_low 
0316			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0316 d3 80		       out (storage_adata),a 
0318 32 5e fa		       ld (spi_portbyte), a 
031b			 
031b			    ;clock out wren instruction 
031b			 
031b 3e 03		    ld a, store_read_ins 
031d cd 02 01		    call spi_send_byte  
0320			 
0320			 
0320			    ; clock out address (depending on address size) 
0320			     
0320 e1			    pop hl 
0321 7c			    ld a,h    ; address out msb first 
0322 cd 02 01		    call spi_send_byte  
0325 7d			    ld a,l 
0326 cd 02 01		    call spi_send_byte  
0329			 
0329			    ; clock in byte(s) for page 
0329			 
0329 cd 29 01		    call spi_read_byte  
032c f5				push af 
032d			 
032d			    ; end write with ce high 
032d 3a 5e fa		       ld a,(spi_portbyte) 
0330			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0330 cd 03 02			call spi_ce_high 
0333 d3 80		       out (storage_adata),a 
0335 32 5e fa		       ld (spi_portbyte), a 
0338			 
0338 f1				pop af 
0339			 
0339 c1				pop bc 
033a d1				pop de 
033b			 
033b c9			    ret 
033c			 
033c			if DEBUG_STORESE 
033c			 
033c			storageput:  
033c			 
033c			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033c			 
033c 21 c0 f1			ld hl,scratch+2 
033f cd 87 13			call get_word_hl 
0342			 
0342				; stuff it here for the moment as it will be overwritten later anyway 
0342			 
0342 22 e1 f4			ld (os_cur_ptr),hl	 
0345			 
0345			 
0345			; get pointer to start of string 
0345			 
0345 21 c5 f1			ld hl, scratch+7 
0348			 
0348			; loop writing char of string to eeprom 
0348			 
0348 7e			.writestr:	ld a,(hl) 
0349 fe 00				cp 0 
034b 28 12				jr z, .wsdone		; done writing 
034d e5					push hl 
034e 2a e1 f4				ld hl,(os_cur_ptr) 
0351 cd 6b 02				call se_writebyte 
0354			 
0354 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0357 23					inc hl 
0358 22 e1 f4				ld (os_cur_ptr),hl 
035b			 
035b					; restore string pointer and get next char 
035b			 
035b e1					pop hl 
035c 23					inc hl 
035d 18 e9				jr .writestr 
035f			 
035f			 
035f			 
035f			.wsdone: 
035f			 
035f			 
035f			; when done load first page into a buffer  
035f			 
035f 21 00 80				ld hl,08000h		; start in ram 
0362 22 e1 f4				ld (os_cur_ptr),hl 
0365 21 00 00				ld hl, 0		 ; start of page 
0368 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036b			 
036b 06 80				ld b, 128		; actually get more then one page 
036d c5			.wsload:	push bc 
036e 2a e6 f1				ld hl,(scratch+40) 
0371 e5					push hl 
0372 cd 0d 03				call se_readbyte 
0375			 
0375					; a now as the byte 
0375			 
0375 2a e1 f4				ld hl,(os_cur_ptr) 
0378 77					ld (hl),a 
0379					; inc next buffer area 
0379 23					inc hl 
037a 22 e1 f4				ld (os_cur_ptr),hl 
037d			 
037d					; get eeprom position, inc and save for next round 
037d e1					pop hl		 
037e 23					inc hl 
037f 22 e6 f1				ld (scratch+40),hl 
0382 c1					pop bc 
0383 10 e8				djnz .wsload 
0385			 
0385			; set 'd' pointer to start of buffer 
0385			 
0385 21 00 80				ld hl,08000h 
0388 22 e1 f4				ld (os_cur_ptr),hl 
038b			 
038b			 
038b c9			ret 
038c			 
038c			 
038c c9			storageread: ret 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			endif 
038d			 
038d			 
038d			 
# End of file firmware_seeprom.asm
038d			else  
038d			   ; create some stubs for the labels  
038d			se_readbyte: ret  
038d			se_writebyte: ret  
038d			storage_init: ret  
038d			  
038d			endif  
038d			  
038d			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038d			;include "firmware_cf.asm"  
038d			  
038d			; load up high level storage hardward abstractions  
038d			include "firmware_storage.asm"  
038d			 
038d			; persisent storage hardware abstraction layer  
038d			 
038d			 
038d			 
038d			; Block 0 on storage is a config state 
038d			 
038d			 
038d			 
038d			; TODO add read phy block and write phy block functions 
038d			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038d			 
038d			; Abstraction layer  
038d			 
038d			; Logocial block size is same size as physical size - using tape concept 
038d			 
038d			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038d			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038d			 
038d			 
038d			 
038d			; Filesystem layout (Logical layout) 
038d			; 
038d			; Block 0 - Bank config  
038d			; 
038d			;      Byte - 0 file id counter 
038d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038d			;      Byte - 3-20 zero terminated bank label 
038d			; 
038d			; Block 1 > File storage 
038d			; 
038d			;      Byte 0 file id    - block 0 file details 
038d			;      Byte 1 block id - block 0 is file  
038d			;            Byte 2-15 - File name 
038d			; 
038d			;       - to end of block data 
038d			; 
038d			 
038d			; Get ID for the file named in pointer held HL 
038d			; Returns ID in HL = 255 if no file found 
038d			 
038d			storage_getid: 
038d			 
038d 22 70 fa			ld (store_tmp1), hl 
0390			 
0390				if DEBUG_STORESE 
0390					DMARK "SGI" 
0390 f5				push af  
0391 3a a5 03			ld a, (.dmark)  
0394 32 68 fe			ld (debug_mark),a  
0397 3a a6 03			ld a, (.dmark+1)  
039a 32 69 fe			ld (debug_mark+1),a  
039d 3a a7 03			ld a, (.dmark+2)  
03a0 32 6a fe			ld (debug_mark+2),a  
03a3 18 03			jr .pastdmark  
03a5 ..			.dmark: db "SGI"  
03a8 f1			.pastdmark: pop af  
03a9			endm  
# End of macro DMARK
03a9					CALLMONITOR 
03a9 cd 6c fe			call debug_vector  
03ac				endm  
# End of macro CALLMONITOR
03ac				endif 
03ac				; get block 0 and set counter for number of files to scan 
03ac			 
03ac cd 17 05			call storage_get_block_0 
03af			 
03af 3a 77 fa			ld a, (store_page) 
03b2 47				ld b, a 
03b3			 
03b3				; get extent 0 of each file id 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 68 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 69 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 6a fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd 6c fe			call debug_vector  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf 60			.getloop:	ld h, b 
03d0 2e 00				ld l, 0 
03d2 c5					push bc 
03d3			 
03d3 11 77 fa				ld de, store_page 
03d6				if DEBUG_STORESE 
03d6					DMARK "SGr" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 68 fe			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 69 fe			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 6a fe			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SGr"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					CALLMONITOR 
03ef cd 6c fe			call debug_vector  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 cd bf 09				call storage_read 
03f5 cd f9 0f				call ishlzero 
03f8 28 2d				jr z, .gap 
03fa					 
03fa					; have a file name read. Is it one we want. 
03fa			 
03fa 2a 70 fa				ld hl, (store_tmp1) 
03fd 11 7a fa				ld de, store_page+3   ; file name 
0400			 
0400				if DEBUG_STORESE 
0400					DMARK "SGc" 
0400 f5				push af  
0401 3a 15 04			ld a, (.dmark)  
0404 32 68 fe			ld (debug_mark),a  
0407 3a 16 04			ld a, (.dmark+1)  
040a 32 69 fe			ld (debug_mark+1),a  
040d 3a 17 04			ld a, (.dmark+2)  
0410 32 6a fe			ld (debug_mark+2),a  
0413 18 03			jr .pastdmark  
0415 ..			.dmark: db "SGc"  
0418 f1			.pastdmark: pop af  
0419			endm  
# End of macro DMARK
0419					CALLMONITOR 
0419 cd 6c fe			call debug_vector  
041c				endm  
# End of macro CALLMONITOR
041c				endif 
041c cd 66 14				call strcmp 
041f 20 06				jr nz, .gap   ; not this one 
0421			 
0421 c1				        pop bc 
0422			 
0422 26 00				ld h, 0 
0424 68					ld l, b 
0425 18 22				jr .getdone 
0427						 
0427			 
0427			 
0427			 
0427			.gap: 
0427				if DEBUG_STORESE 
0427					DMARK "SGg" 
0427 f5				push af  
0428 3a 3c 04			ld a, (.dmark)  
042b 32 68 fe			ld (debug_mark),a  
042e 3a 3d 04			ld a, (.dmark+1)  
0431 32 69 fe			ld (debug_mark+1),a  
0434 3a 3e 04			ld a, (.dmark+2)  
0437 32 6a fe			ld (debug_mark+2),a  
043a 18 03			jr .pastdmark  
043c ..			.dmark: db "SGg"  
043f f1			.pastdmark: pop af  
0440			endm  
# End of macro DMARK
0440					CALLMONITOR 
0440 cd 6c fe			call debug_vector  
0443				endm  
# End of macro CALLMONITOR
0443				endif 
0443			 
0443 c1					pop bc 
0444 10 89				djnz .getloop 
0446 21 ff 00				ld hl, 255 
0449			.getdone: 
0449			 
0449				if DEBUG_STORESE 
0449					DMARK "SGe" 
0449 f5				push af  
044a 3a 5e 04			ld a, (.dmark)  
044d 32 68 fe			ld (debug_mark),a  
0450 3a 5f 04			ld a, (.dmark+1)  
0453 32 69 fe			ld (debug_mark+1),a  
0456 3a 60 04			ld a, (.dmark+2)  
0459 32 6a fe			ld (debug_mark+2),a  
045c 18 03			jr .pastdmark  
045e ..			.dmark: db "SGe"  
0461 f1			.pastdmark: pop af  
0462			endm  
# End of macro DMARK
0462					CALLMONITOR 
0462 cd 6c fe			call debug_vector  
0465				endm  
# End of macro CALLMONITOR
0465				endif 
0465			 
0465 c9				ret 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			; Read Block 
0466			; ---------- 
0466			; 
0466			; With current bank 
0466			;  
0466			; Get block number to read 
0466			; Load physical blocks starting at start block into buffer 
0466			 
0466			; de points to buffer to use 
0466			; hl holds logical block number  
0466			 
0466			storage_read_block: 
0466			 
0466				; TODO bank selection 
0466			 
0466				; for each of the physical blocks read it into the buffer 
0466 06 40			ld b, STORE_BLOCK_PHY 
0468			 
0468				if DEBUG_STORESE 
0468 d5					push de 
0469				endif 
0469				 
0469			.rl1:    
0469			 
0469				; read physical block at hl into de 
0469			        ; increment hl and de to next read position on exit 
0469			 
0469 e5				push hl 
046a d5				push de	 
046b c5				push bc 
046c			;	if DEBUG_STORESE 
046c			;		push af 
046c			;		ld a, 'R' 
046c			;		ld (debug_mark),a 
046c			;		pop af 
046c			;		CALLMONITOR 
046c			;	endif 
046c cd 0d 03			call se_readbyte 
046f			;	if DEBUG_STORESE 
046f			;		ld a,(spi_portbyte) 
046f			;		ld l, a 
046f			;		push af 
046f			;		ld a, '1' 
046f			;		ld (debug_mark),a 
046f			;		pop af 
046f			;		CALLMONITOR 
046f			;	endif 
046f c1				pop bc 
0470 d1				pop de 
0471 e1				pop hl 
0472 12				ld (de),a 
0473 23				inc hl 
0474 13				inc de 
0475			 
0475			;	if DEBUG_STORESE 
0475			;		push af 
0475			;		ld a, 'r' 
0475			;		ld (debug_mark),a 
0475			;		pop af 
0475			;		CALLMONITOR 
0475			;	endif 
0475			 
0475 10 f2			djnz .rl1 
0477			 
0477				if DEBUG_STORESE 
0477					DMARK "SRB" 
0477 f5				push af  
0478 3a 8c 04			ld a, (.dmark)  
047b 32 68 fe			ld (debug_mark),a  
047e 3a 8d 04			ld a, (.dmark+1)  
0481 32 69 fe			ld (debug_mark+1),a  
0484 3a 8e 04			ld a, (.dmark+2)  
0487 32 6a fe			ld (debug_mark+2),a  
048a 18 03			jr .pastdmark  
048c ..			.dmark: db "SRB"  
048f f1			.pastdmark: pop af  
0490			endm  
# End of macro DMARK
0490 d1					pop de 
0491			; 
0491			;		push af 
0491			;		ld a, 'R' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 6c fe			call debug_vector  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494 c9				ret	 
0495				 
0495			 
0495			; File Size 
0495			; --------- 
0495			; 
0495			;   hl file id 
0495			; 
0495			;  returns in hl the number of blocks 
0495			 
0495			storage_file_size: 
0495 5d				ld e, l 
0496 16 00			ld d, 0 
0498 21 40 00			ld hl, STORE_BLOCK_PHY 
049b					if DEBUG_FORTH_WORDS 
049b						DMARK "SIZ" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 68 fe			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 69 fe			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 6a fe			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SIZ"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4						CALLMONITOR 
04b4 cd 6c fe			call debug_vector  
04b7				endm  
# End of macro CALLMONITOR
04b7					endif 
04b7 cd 99 07			call storage_findnextid 
04ba			 
04ba cd f9 0f			call ishlzero 
04bd			;	ld a, l 
04bd			;	add h 
04bd			;	cp 0 
04bd c8				ret z			; block not found so EOF 
04be			 
04be 11 77 fa			ld de, store_page 
04c1 cd 66 04			call storage_read_block 
04c4			 
04c4 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c7 6f				ld l, a 
04c8 26 00			ld h, 0 
04ca c9			 	ret 
04cb			 
04cb			 
04cb			; Write Block 
04cb			; ----------- 
04cb			; 
04cb			; With current bank 
04cb			;  
04cb			; Get block number to write 
04cb			; Write physical blocks starting at start block from buffer 
04cb			  
04cb			storage_write_block: 
04cb				; TODO bank selection 
04cb			 
04cb				; for each of the physical blocks read it into the buffer 
04cb 06 40			ld b, STORE_BLOCK_PHY 
04cd			 
04cd				if DEBUG_STORESE 
04cd					DMARK "SWB" 
04cd f5				push af  
04ce 3a e2 04			ld a, (.dmark)  
04d1 32 68 fe			ld (debug_mark),a  
04d4 3a e3 04			ld a, (.dmark+1)  
04d7 32 69 fe			ld (debug_mark+1),a  
04da 3a e4 04			ld a, (.dmark+2)  
04dd 32 6a fe			ld (debug_mark+2),a  
04e0 18 03			jr .pastdmark  
04e2 ..			.dmark: db "SWB"  
04e5 f1			.pastdmark: pop af  
04e6			endm  
# End of macro DMARK
04e6			 
04e6					;push af 
04e6					;ld a, 'W' 
04e6					;ld (debug_mark),a 
04e6					;pop af 
04e6					CALLMONITOR 
04e6 cd 6c fe			call debug_vector  
04e9				endm  
# End of macro CALLMONITOR
04e9				endif 
04e9			 
04e9			; might not be working 
04e9			;	call se_writepage 
04e9			 
04e9			;	ret 
04e9			; 
04e9			 
04e9			 
04e9			 
04e9			.wl1:    
04e9			 
04e9				; read physical block at hl into de 
04e9			        ; increment hl and de to next read position on exit 
04e9			 
04e9 e5				push hl 
04ea d5				push de	 
04eb c5				push bc 
04ec 1a				ld a,(de) 
04ed				;if DEBUG_STORESE 
04ed			;		push af 
04ed			;		ld a, 'W' 
04ed			;		ld (debug_mark),a 
04ed			;		pop af 
04ed			;		CALLMONITOR 
04ed			;	endif 
04ed cd 6b 02			call se_writebyte 
04f0			;	call delay250ms 
04f0 00				nop 
04f1 00				nop 
04f2 00				nop 
04f3			;	if DEBUG_STORESE 
04f3			;		push af 
04f3			;		ld a, 'w' 
04f3			;		ld (debug_mark),a 
04f3			;		pop af 
04f3			;		CALLMONITOR 
04f3			;	endif 
04f3 c1				pop bc 
04f4 d1				pop de 
04f5 e1				pop hl 
04f6 23				inc hl 
04f7 13				inc de 
04f8			 
04f8			 
04f8 10 ef			djnz .wl1 
04fa			 
04fa				if DEBUG_STORESE 
04fa					DMARK "SW2" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 68 fe			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 69 fe			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 6a fe			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "SW2"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513			 
0513					;push af 
0513					;ld a, 'W' 
0513					;ld (debug_mark),a 
0513					;pop af 
0513					CALLMONITOR 
0513 cd 6c fe			call debug_vector  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 c9				ret	 
0517			 
0517			; Init bank 
0517			; --------- 
0517			; 
0517			; With current bank 
0517			; 
0517			; Setup block 0 config 
0517			;     Set 0 file id counter 
0517			;     Set formatted byte pattern 
0517			;     Zero out bank label 
0517			;      
0517			; For every logical block write 0-1 byte as null 
0517			 
0517			storage_get_block_0: 
0517			 
0517				; TODO check presence 
0517			 
0517				; get block 0 config 
0517			 
0517 21 00 00			ld hl, 0 
051a 11 77 fa			ld de, store_page 
051d cd 66 04			call storage_read_block 
0520			 
0520				if DEBUG_STORESE 
0520					DMARK "SB0" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 68 fe			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 69 fe			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 6a fe			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB0"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539 11 77 fa				ld de, store_page 
053c			;		push af 
053c			;		ld a, 'i' 
053c			;		ld (debug_mark),a 
053c			;		pop af 
053c					CALLMONITOR 
053c cd 6c fe			call debug_vector  
053f				endm  
# End of macro CALLMONITOR
053f				endif 
053f			 
053f				; is this area formatted? 
053f			 
053f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053f 2a 78 fa			ld hl, (store_page+1) 
0542 3e 80			ld a,0x80 
0544 bd				cp l 
0545 20 22			jr nz, .ininotformatted 
0547				; do a double check 
0547 3e 27			ld a, 0x27 
0549 bc				cp h 
054a 20 1d			jr nz, .ininotformatted 
054c			 
054c				; formatted then 
054c			 
054c				if DEBUG_STORESE 
054c					DMARK "SB1" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 68 fe			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 69 fe			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 6a fe			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "SB1"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;push af 
0565					;ld a, 'I' 
0565					;ld (debug_mark),a 
0565					;pop af 
0565					CALLMONITOR 
0565 cd 6c fe			call debug_vector  
0568				endm  
# End of macro CALLMONITOR
0568				endif 
0568 c9				ret 
0569			 
0569			.ininotformatted: 
0569				; bank not formatted so poke various bits to make sure 
0569			 
0569				if DEBUG_STORESE 
0569					DMARK "SB2" 
0569 f5				push af  
056a 3a 7e 05			ld a, (.dmark)  
056d 32 68 fe			ld (debug_mark),a  
0570 3a 7f 05			ld a, (.dmark+1)  
0573 32 69 fe			ld (debug_mark+1),a  
0576 3a 80 05			ld a, (.dmark+2)  
0579 32 6a fe			ld (debug_mark+2),a  
057c 18 03			jr .pastdmark  
057e ..			.dmark: db "SB2"  
0581 f1			.pastdmark: pop af  
0582			endm  
# End of macro DMARK
0582					;push af 
0582					;ld a, 'f' 
0582					;ld (debug_mark),a 
0582					;pop af 
0582					CALLMONITOR 
0582 cd 6c fe			call debug_vector  
0585				endm  
# End of macro CALLMONITOR
0585				endif 
0585			 
0585 cd a2 0c			call storage_clear_page 
0588			 
0588 21 77 fa			ld hl, store_page 
058b 3e 00			ld a, 0 
058d				 
058d 77				ld (hl),a   ; reset file counter 
058e			 
058e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0591 22 78 fa		 	ld (store_page+1), hl	 
0594			 
0594				; set default label 
0594			 
0594 21 30 06			ld hl, .defaultbanklabl 
0597 11 7a fa		 	ld de, store_page+3 
059a 01 0f 00			ld bc, 15 
059d ed b0			ldir 
059f			 
059f				; Append the current bank id 
059f 21 83 fa			ld hl, store_page+3+9 
05a2 3a 5c fa			ld a, (spi_device_id) 
05a5 77				ld (hl), a 
05a6			 
05a6				; save default page 0 
05a6			 
05a6 21 00 00			ld hl, 0 
05a9 11 77 fa			ld de, store_page 
05ac				if DEBUG_STORESE 
05ac					DMARK "SB3" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 68 fe			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 69 fe			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 6a fe			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "SB3"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5			;		push af 
05c5			;		ld a, 'F' 
05c5			;		ld (debug_mark),a 
05c5			;		pop af 
05c5					CALLMONITOR 
05c5 cd 6c fe			call debug_vector  
05c8				endm  
# End of macro CALLMONITOR
05c8				endif 
05c8 cd cb 04			call storage_write_block 
05cb				if DEBUG_STORESE 
05cb					DMARK "SB4" 
05cb f5				push af  
05cc 3a e0 05			ld a, (.dmark)  
05cf 32 68 fe			ld (debug_mark),a  
05d2 3a e1 05			ld a, (.dmark+1)  
05d5 32 69 fe			ld (debug_mark+1),a  
05d8 3a e2 05			ld a, (.dmark+2)  
05db 32 6a fe			ld (debug_mark+2),a  
05de 18 03			jr .pastdmark  
05e0 ..			.dmark: db "SB4"  
05e3 f1			.pastdmark: pop af  
05e4			endm  
# End of macro DMARK
05e4			;		push af 
05e4			;		ld a, '>' 
05e4			;		ld (debug_mark),a 
05e4			;		pop af 
05e4					CALLMONITOR 
05e4 cd 6c fe			call debug_vector  
05e7				endm  
# End of macro CALLMONITOR
05e7				endif 
05e7			 
05e7 00				nop 
05e8 00				nop 
05e9 00				nop 
05ea			 
05ea				; now set 0 in every page to mark as a free block 
05ea			 
05ea 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ec 21 40 00			ld hl, STORE_BLOCK_PHY 
05ef			 
05ef 3e 00		.setmark1:   	ld a,0 
05f1 e5					push hl 
05f2 c5					push bc 
05f3 cd 6b 02				call se_writebyte 
05f6 3e 0a			ld a, 10 
05f8 cd c4 0c			call aDelayInMS 
05fb 23				inc hl 
05fc cd 6b 02				call se_writebyte 
05ff 3e 0a			ld a, 10 
0601 cd c4 0c			call aDelayInMS 
0604 2b				dec hl 
0605 c1					pop bc 
0606 e1					pop hl 
0607 3e 40				ld a, STORE_BLOCK_PHY 
0609 cd d0 0f				call addatohl 
060c 10 e1				djnz .setmark1 
060e			 
060e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0610 3e 00		.setmark2:   	ld a,0 
0612 e5					push hl 
0613 c5					push bc 
0614 cd 6b 02				call se_writebyte 
0617 3e 0a			ld a, 10 
0619 cd c4 0c			call aDelayInMS 
061c 23				inc hl 
061d cd 6b 02				call se_writebyte 
0620 3e 0a			ld a, 10 
0622 cd c4 0c			call aDelayInMS 
0625 2b				dec hl 
0626 c1					pop bc 
0627 e1					pop hl 
0628 3e 40				ld a, STORE_BLOCK_PHY 
062a cd d0 0f				call addatohl 
062d 10 e1				djnz .setmark2 
062f			 
062f					 
062f			 
062f			 
062f c9				ret 
0630			 
0630			 
0630			 
0630			 
0630 .. 00		.defaultbanklabl:   db "BankLabel_",0 
063b			 
063b			 
063b			 
063b			; Label Bank 
063b			; ---------- 
063b			; 
063b			; With current bank 
063b			; Read block 0 
063b			; Set label 
063b			; Write block 0 
063b			 
063b			; label str pointer in hl 
063b			 
063b			storage_label:     
063b			 
063b				if DEBUG_STORESE 
063b					DMARK "LBL" 
063b f5				push af  
063c 3a 50 06			ld a, (.dmark)  
063f 32 68 fe			ld (debug_mark),a  
0642 3a 51 06			ld a, (.dmark+1)  
0645 32 69 fe			ld (debug_mark+1),a  
0648 3a 52 06			ld a, (.dmark+2)  
064b 32 6a fe			ld (debug_mark+2),a  
064e 18 03			jr .pastdmark  
0650 ..			.dmark: db "LBL"  
0653 f1			.pastdmark: pop af  
0654			endm  
# End of macro DMARK
0654					CALLMONITOR 
0654 cd 6c fe			call debug_vector  
0657				endm  
# End of macro CALLMONITOR
0657				endif 
0657			 
0657 e5				push hl 
0658			 
0658 cd 17 05			call storage_get_block_0 
065b			 
065b				; set default label 
065b			 
065b e1				pop hl 
065c			 
065c 11 7a fa		 	ld de, store_page+3 
065f 01 0f 00			ld bc, 15 
0662				if DEBUG_STORESE 
0662					DMARK "LB3" 
0662 f5				push af  
0663 3a 77 06			ld a, (.dmark)  
0666 32 68 fe			ld (debug_mark),a  
0669 3a 78 06			ld a, (.dmark+1)  
066c 32 69 fe			ld (debug_mark+1),a  
066f 3a 79 06			ld a, (.dmark+2)  
0672 32 6a fe			ld (debug_mark+2),a  
0675 18 03			jr .pastdmark  
0677 ..			.dmark: db "LB3"  
067a f1			.pastdmark: pop af  
067b			endm  
# End of macro DMARK
067b					CALLMONITOR 
067b cd 6c fe			call debug_vector  
067e				endm  
# End of macro CALLMONITOR
067e				endif 
067e ed b0			ldir 
0680				; save default page 0 
0680			 
0680 21 00 00			ld hl, 0 
0683 11 77 fa			ld de, store_page 
0686				if DEBUG_STORESE 
0686					DMARK "LBW" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 68 fe			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 69 fe			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 6a fe			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "LBW"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					CALLMONITOR 
069f cd 6c fe			call debug_vector  
06a2				endm  
# End of macro CALLMONITOR
06a2				endif 
06a2 cd cb 04			call storage_write_block 
06a5			 
06a5 c9				ret 
06a6			 
06a6			 
06a6			 
06a6			; Read Block 0 - Config 
06a6			; --------------------- 
06a6			; 
06a6			; With current bank 
06a6			; Call presence test 
06a6			;    If not present format/init bank  
06a6			; Read block 0  
06a6			;  
06a6			 
06a6			 
06a6			; Dir 
06a6			; --- 
06a6			; 
06a6			; With current bank 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block read byte 2 
06a6			;      if first block of file 
06a6			;         Display file name 
06a6			;         Display type flags for file 
06a6			;        
06a6			 
06a6			; moving to words as this requires stack control 
06a6			 
06a6			 
06a6			; Delete File 
06a6			; ----------- 
06a6			; 
06a6			; With current bank 
06a6			; 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block file id 
06a6			;      If first block of file and dont have file id 
06a6			;         if file to delete 
06a6			;         Save file id 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			;      If file id is one saved 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			 
06a6			 
06a6			.se_done: 
06a6 e1				pop hl 
06a7 c9				ret 
06a8			 
06a8			storage_erase: 
06a8			 
06a8				; hl contains the file id 
06a8			 
06a8 5d				ld e, l 
06a9 16 00			ld d, 0 
06ab 21 40 00			ld hl, STORE_BLOCK_PHY 
06ae					if DEBUG_FORTH_WORDS 
06ae						DMARK "ERA" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 68 fe			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 69 fe			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 6a fe			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "ERA"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7						CALLMONITOR 
06c7 cd 6c fe			call debug_vector  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca cd 99 07			call storage_findnextid 
06cd cd f9 0f			call ishlzero 
06d0 c8				ret z 
06d1			 
06d1 e5				push hl 
06d2			 
06d2				; TODO check file not found 
06d2			 
06d2 11 77 fa			ld de, store_page 
06d5 cd 66 04			call storage_read_block 
06d8			 
06d8 cd f9 0f			call ishlzero 
06db ca a6 06			jp z,.se_done 
06de			 
06de					if DEBUG_FORTH_WORDS 
06de						DMARK "ER1" 
06de f5				push af  
06df 3a f3 06			ld a, (.dmark)  
06e2 32 68 fe			ld (debug_mark),a  
06e5 3a f4 06			ld a, (.dmark+1)  
06e8 32 69 fe			ld (debug_mark+1),a  
06eb 3a f5 06			ld a, (.dmark+2)  
06ee 32 6a fe			ld (debug_mark+2),a  
06f1 18 03			jr .pastdmark  
06f3 ..			.dmark: db "ER1"  
06f6 f1			.pastdmark: pop af  
06f7			endm  
# End of macro DMARK
06f7						CALLMONITOR 
06f7 cd 6c fe			call debug_vector  
06fa				endm  
# End of macro CALLMONITOR
06fa					endif 
06fa 3a 77 fa			ld a, (store_page)	; get file id 
06fd 32 6b fa			ld (store_tmpid), a 
0700			 
0700 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0703 32 6a fa			ld (store_tmpext), a 
0706			 
0706				; wipe file header 
0706			 
0706 e1				pop hl 
0707 3e 00			ld a, 0 
0709 32 77 fa			ld (store_page), a 
070c 32 78 fa			ld (store_page+1),a 
070f 11 77 fa			ld de, store_page 
0712					if DEBUG_FORTH_WORDS 
0712						DMARK "ER2" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 68 fe			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 69 fe			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 6a fe			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "ER2"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b						CALLMONITOR 
072b cd 6c fe			call debug_vector  
072e				endm  
# End of macro CALLMONITOR
072e					endif 
072e cd cb 04			call storage_write_block 
0731			 
0731			 
0731				; wipe file extents 
0731			 
0731 3a 6a fa			ld a, (store_tmpext) 
0734 47				ld b, a 
0735			 
0735			.eraext:	  
0735 c5				push bc 
0736			 
0736 21 40 00			ld hl, STORE_BLOCK_PHY 
0739 3a 6b fa			ld a,(store_tmpid) 
073c 5f				ld e, a 
073d 50				ld d, b	 
073e					if DEBUG_FORTH_WORDS 
073e						DMARK "ER3" 
073e f5				push af  
073f 3a 53 07			ld a, (.dmark)  
0742 32 68 fe			ld (debug_mark),a  
0745 3a 54 07			ld a, (.dmark+1)  
0748 32 69 fe			ld (debug_mark+1),a  
074b 3a 55 07			ld a, (.dmark+2)  
074e 32 6a fe			ld (debug_mark+2),a  
0751 18 03			jr .pastdmark  
0753 ..			.dmark: db "ER3"  
0756 f1			.pastdmark: pop af  
0757			endm  
# End of macro DMARK
0757						CALLMONITOR 
0757 cd 6c fe			call debug_vector  
075a				endm  
# End of macro CALLMONITOR
075a					endif 
075a cd 99 07			call storage_findnextid 
075d cd f9 0f			call ishlzero 
0760 ca a6 06			jp z,.se_done 
0763			 
0763 e5				push hl 
0764 11 77 fa			ld de, store_page 
0767 cd 66 04			call storage_read_block 
076a			 
076a				; free block	 
076a			 
076a 3e 00			ld a, 0 
076c 32 77 fa			ld (store_page), a 
076f 32 78 fa			ld (store_page+1),a 
0772 11 77 fa			ld de, store_page 
0775 e1				pop hl 
0776					if DEBUG_FORTH_WORDS 
0776						DMARK "ER4" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 68 fe			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 69 fe			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 6a fe			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "ER4"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f						CALLMONITOR 
078f cd 6c fe			call debug_vector  
0792				endm  
# End of macro CALLMONITOR
0792					endif 
0792 cd cb 04			call storage_write_block 
0795			 
0795 c1				pop bc 
0796 10 9d			djnz .eraext 
0798			 
0798 c9				ret 
0799			 
0799			 
0799			; Find Free Block 
0799			; --------------- 
0799			; 
0799			; With current bank 
0799			;  
0799			; From given starting logical block 
0799			;    Read block  
0799			;    If no file id 
0799			;         Return block id 
0799			 
0799			 
0799			; hl starting page number 
0799			; hl contains free page number or zero if no pages free 
0799			; e contains the file id to locate 
0799			; d contains the block number 
0799			 
0799			; TODO change to find file id and use zero for free block 
0799			 
0799			storage_findnextid: 
0799			 
0799				; now locate first 0 page to mark as a free block 
0799			 
0799 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079b			;	ld hl, STORE_BLOCK_PHY 
079b			 
079b					if DEBUG_FORTH_WORDS 
079b					DMARK "FNI" 
079b f5				push af  
079c 3a b0 07			ld a, (.dmark)  
079f 32 68 fe			ld (debug_mark),a  
07a2 3a b1 07			ld a, (.dmark+1)  
07a5 32 69 fe			ld (debug_mark+1),a  
07a8 3a b2 07			ld a, (.dmark+2)  
07ab 32 6a fe			ld (debug_mark+2),a  
07ae 18 03			jr .pastdmark  
07b0 ..			.dmark: db "FNI"  
07b3 f1			.pastdmark: pop af  
07b4			endm  
# End of macro DMARK
07b4						CALLMONITOR 
07b4 cd 6c fe			call debug_vector  
07b7				endm  
# End of macro CALLMONITOR
07b7					endif 
07b7			.ff1:   	 
07b7 e5					push hl 
07b8 c5					push bc 
07b9 d5					push de 
07ba cd 0d 03				call se_readbyte 
07bd 5f					ld e,a 
07be 23					inc hl 
07bf cd 0d 03				call se_readbyte 
07c2 57					ld d, a 
07c3 e1					pop hl 
07c4 e5					push hl 
07c5 cd ee 0f				call cmp16 
07c8 28 49				jr z, .fffound 
07ca			 
07ca d1					pop de 
07cb c1					pop bc 
07cc e1					pop hl 
07cd			 
07cd					; is found? 
07cd					;cp e 
07cd					;ret z 
07cd			 
07cd 3e 40				ld a, STORE_BLOCK_PHY 
07cf cd d0 0f				call addatohl 
07d2 10 e3				djnz .ff1 
07d4			 
07d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d6			.ff2:   	 
07d6			 
07d6 e5					push hl 
07d7 c5					push bc 
07d8 d5					push de 
07d9 cd 0d 03				call se_readbyte 
07dc 5f					ld e,a 
07dd 23					inc hl 
07de cd 0d 03				call se_readbyte 
07e1 57					ld d, a 
07e2			 
07e2 e1					pop hl 
07e3 e5					push hl 
07e4 cd ee 0f				call cmp16 
07e7 28 2a				jr z, .fffound 
07e9			 
07e9 d1					pop de 
07ea c1					pop bc 
07eb e1					pop hl 
07ec					; is found? 
07ec					;cp e 
07ec					;ret z 
07ec			 
07ec 3e 40				ld a, STORE_BLOCK_PHY 
07ee cd d0 0f				call addatohl 
07f1 10 e3				djnz .ff2 
07f3			 
07f3			 
07f3					if DEBUG_FORTH_WORDS 
07f3					DMARK "FN-" 
07f3 f5				push af  
07f4 3a 08 08			ld a, (.dmark)  
07f7 32 68 fe			ld (debug_mark),a  
07fa 3a 09 08			ld a, (.dmark+1)  
07fd 32 69 fe			ld (debug_mark+1),a  
0800 3a 0a 08			ld a, (.dmark+2)  
0803 32 6a fe			ld (debug_mark+2),a  
0806 18 03			jr .pastdmark  
0808 ..			.dmark: db "FN-"  
080b f1			.pastdmark: pop af  
080c			endm  
# End of macro DMARK
080c					;	push af 
080c					;	ld a, 'n' 
080c					;	ld (debug_mark),a 
080c					;	pop af 
080c						CALLMONITOR 
080c cd 6c fe			call debug_vector  
080f				endm  
# End of macro CALLMONITOR
080f					endif 
080f				; no free marks! 
080f 21 00 00				ld hl, 0 
0812 c9				ret 
0813			.fffound: 
0813				 
0813			 
0813 d1					pop de 
0814 c1					pop bc 
0815 e1					pop hl 
0816					if DEBUG_FORTH_WORDS 
0816					DMARK "FNF" 
0816 f5				push af  
0817 3a 2b 08			ld a, (.dmark)  
081a 32 68 fe			ld (debug_mark),a  
081d 3a 2c 08			ld a, (.dmark+1)  
0820 32 69 fe			ld (debug_mark+1),a  
0823 3a 2d 08			ld a, (.dmark+2)  
0826 32 6a fe			ld (debug_mark+2),a  
0829 18 03			jr .pastdmark  
082b ..			.dmark: db "FNF"  
082e f1			.pastdmark: pop af  
082f			endm  
# End of macro DMARK
082f					;	push af 
082f					;	ld a, 'n' 
082f					;	ld (debug_mark),a 
082f					;	pop af 
082f						CALLMONITOR 
082f cd 6c fe			call debug_vector  
0832				endm  
# End of macro CALLMONITOR
0832					endif 
0832 c9				ret 
0833			 
0833			 
0833			 
0833			; Free Space 
0833			; ---------- 
0833			; 
0833			; With current bank 
0833			; 
0833			; Set block count to zero 
0833			; Starting with first logical block 
0833			;      Find free block  
0833			;      If block id given, increment block count 
0833			; 
0833			;  
0833			 
0833			 
0833			; hl contains count of free blocks 
0833			 
0833			storage_freeblocks: 
0833			 
0833				; now locate first 0 page to mark as a free block 
0833			 
0833 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0835 21 40 00			ld hl, STORE_BLOCK_PHY 
0838 11 00 00			ld de, 0 
083b			 
083b			.fb1:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd 0d 03				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844 fe 00				cp 0 
0846 20 01				jr nz, .ff1cont 
0848 13					inc de 
0849			 
0849			.ff1cont: 
0849			 
0849			 
0849 3e 40				ld a, STORE_BLOCK_PHY 
084b cd d0 0f				call addatohl 
084e 10 eb				djnz .fb1 
0850			 
0850 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0852			.fb2:   	 
0852 e5					push hl 
0853 c5					push bc 
0854 d5					push de 
0855 cd 0d 03				call se_readbyte 
0858 d1					pop de 
0859 c1					pop bc 
085a e1					pop hl 
085b			 
085b					; is free? 
085b fe 00				cp 0 
085d 20 01				jr nz, .ff2cont 
085f 13					inc de 
0860			 
0860			.ff2cont: 
0860			 
0860 3e 40				ld a, STORE_BLOCK_PHY 
0862 cd d0 0f				call addatohl 
0865 10 eb				djnz .fb2 
0867			 
0867 eb				ex de, hl 
0868 c9				ret 
0869			 
0869			; Get File ID 
0869			; ----------- 
0869			; 
0869			; With current bank 
0869			;  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; For each logical block 
0869			;    Read block file id 
0869			;      If first block of file and dont have file id 
0869			;         if file get id and exit 
0869			 
0869			 
0869			 
0869			 
0869			; Create File 
0869			; ----------- 
0869			; 
0869			; With current bank  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; Increment file id number 
0869			; Save Config 
0869			; Find free block 
0869			; Set buffer with file name and file id 
0869			; Write buffer to free block  
0869			 
0869			 
0869			; hl point to file name 
0869			; hl returns file id 
0869			 
0869			; file format: 
0869			; byte 0 - file id 
0869			; byte 1 - extent number 
0869			; byte 2-> data 
0869			 
0869			; format for extent number 0: 
0869			; 
0869			; byte 0 - file id 
0869			; byte 1 - extent 0 
0869			; byte 2 - extent count 
0869			; byte 3 -> file name and meta data 
0869			 
0869			 
0869			storage_create: 
0869				if DEBUG_STORESE 
0869					DMARK "SCR" 
0869 f5				push af  
086a 3a 7e 08			ld a, (.dmark)  
086d 32 68 fe			ld (debug_mark),a  
0870 3a 7f 08			ld a, (.dmark+1)  
0873 32 69 fe			ld (debug_mark+1),a  
0876 3a 80 08			ld a, (.dmark+2)  
0879 32 6a fe			ld (debug_mark+2),a  
087c 18 03			jr .pastdmark  
087e ..			.dmark: db "SCR"  
0881 f1			.pastdmark: pop af  
0882			endm  
# End of macro DMARK
0882					CALLMONITOR 
0882 cd 6c fe			call debug_vector  
0885				endm  
# End of macro CALLMONITOR
0885				endif 
0885			 
0885 e5				push hl		; save file name pointer 
0886			 
0886 cd 17 05			call storage_get_block_0 
0889			 
0889 3a 77 fa			ld a,(store_page)	; get current file id 
088c 3c				inc a 
088d 32 77 fa			ld (store_page),a 
0890				 
0890 32 6b fa			ld (store_tmpid),a			; save id 
0893			 
0893 21 00 00			ld hl, 0 
0896 11 77 fa			ld de, store_page 
0899				if DEBUG_STORESE 
0899					DMARK "SCw" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 68 fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 69 fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6a fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCw"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6c fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5 cd cb 04			call storage_write_block	 ; save update 
08b8			 
08b8				if DEBUG_STORESE 
08b8 11 77 fa				ld de, store_page 
08bb					DMARK "SCC" 
08bb f5				push af  
08bc 3a d0 08			ld a, (.dmark)  
08bf 32 68 fe			ld (debug_mark),a  
08c2 3a d1 08			ld a, (.dmark+1)  
08c5 32 69 fe			ld (debug_mark+1),a  
08c8 3a d2 08			ld a, (.dmark+2)  
08cb 32 6a fe			ld (debug_mark+2),a  
08ce 18 03			jr .pastdmark  
08d0 ..			.dmark: db "SCC"  
08d3 f1			.pastdmark: pop af  
08d4			endm  
# End of macro DMARK
08d4					CALLMONITOR 
08d4 cd 6c fe			call debug_vector  
08d7				endm  
# End of macro CALLMONITOR
08d7				endif 
08d7				;  
08d7				 
08d7 21 40 00			ld hl, STORE_BLOCK_PHY 
08da 11 00 00			ld de, 0 
08dd cd 99 07			call storage_findnextid 
08e0			 
08e0 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e3			 
08e3				; TODO detect 0 = no spare blocks 
08e3			 
08e3				; hl now contains the free page to use for the file header page 
08e3			 
08e3				if DEBUG_STORESE 
08e3				DMARK "SCF" 
08e3 f5				push af  
08e4 3a f8 08			ld a, (.dmark)  
08e7 32 68 fe			ld (debug_mark),a  
08ea 3a f9 08			ld a, (.dmark+1)  
08ed 32 69 fe			ld (debug_mark+1),a  
08f0 3a fa 08			ld a, (.dmark+2)  
08f3 32 6a fe			ld (debug_mark+2),a  
08f6 18 03			jr .pastdmark  
08f8 ..			.dmark: db "SCF"  
08fb f1			.pastdmark: pop af  
08fc			endm  
# End of macro DMARK
08fc					CALLMONITOR 
08fc cd 6c fe			call debug_vector  
08ff				endm  
# End of macro CALLMONITOR
08ff				endif 
08ff			 
08ff 22 62 fa			ld (store_tmppageid), hl 
0902				 
0902 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0905			;	ld a, (store_filecache)			; save to cache 
0905			 
0905 32 77 fa			ld (store_page),a    ; set page id 
0908 3e 00			ld a, 0			 ; extent 0 is file header 
090a 32 78 fa			ld (store_page+1), a   ; set file extent 
090d			 
090d 32 79 fa			ld (store_page+2), a   ; extent count for the file 
0910			 
0910			;	inc hl 		; init block 0 of file 
0910			;	inc hl   		; skip file and extent id 
0910			 ;       ld a, 0 
0910			;	ld (hl),a 
0910			;	ld a, (store_filecache+1)  	; save to cache 
0910			 
0910			;	inc hl    ; file name 
0910				 
0910				 
0910 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0913				if DEBUG_STORESE 
0913					DMARK "SCc" 
0913 f5				push af  
0914 3a 28 09			ld a, (.dmark)  
0917 32 68 fe			ld (debug_mark),a  
091a 3a 29 09			ld a, (.dmark+1)  
091d 32 69 fe			ld (debug_mark+1),a  
0920 3a 2a 09			ld a, (.dmark+2)  
0923 32 6a fe			ld (debug_mark+2),a  
0926 18 03			jr .pastdmark  
0928 ..			.dmark: db "SCc"  
092b f1			.pastdmark: pop af  
092c			endm  
# End of macro DMARK
092c					CALLMONITOR 
092c cd 6c fe			call debug_vector  
092f				endm  
# End of macro CALLMONITOR
092f				endif 
092f e1				pop hl    ; get zero term string 
0930 e5				push hl 
0931 3e 00			ld a, 0 
0933 cd 39 14			call strlent 
0936 23				inc hl   ; cover zero term 
0937 06 00			ld b,0 
0939 4d				ld c,l 
093a e1				pop hl 
093b				;ex de, hl 
093b				if DEBUG_STORESE 
093b					DMARK "SCa" 
093b f5				push af  
093c 3a 50 09			ld a, (.dmark)  
093f 32 68 fe			ld (debug_mark),a  
0942 3a 51 09			ld a, (.dmark+1)  
0945 32 69 fe			ld (debug_mark+1),a  
0948 3a 52 09			ld a, (.dmark+2)  
094b 32 6a fe			ld (debug_mark+2),a  
094e 18 03			jr .pastdmark  
0950 ..			.dmark: db "SCa"  
0953 f1			.pastdmark: pop af  
0954			endm  
# End of macro DMARK
0954					;push af 
0954					;ld a, 'a' 
0954					;ld (debug_mark),a 
0954					;pop af 
0954					CALLMONITOR 
0954 cd 6c fe			call debug_vector  
0957				endm  
# End of macro CALLMONITOR
0957				endif 
0957 ed b0			ldir    ; copy zero term string 
0959				if DEBUG_STORESE 
0959					DMARK "SCA" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 68 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 69 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 6a fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SCA"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 6c fe			call debug_vector  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975			 
0975				; write file header page 
0975			 
0975 2a 62 fa			ld hl,(store_tmppageid) 
0978 11 77 fa			ld de, store_page 
097b				if DEBUG_STORESE 
097b					DMARK "SCb" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 68 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 69 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 6a fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SCb"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					;push af 
0994					;ld a, 'b' 
0994					;ld (debug_mark),a 
0994					;pop af 
0994					CALLMONITOR 
0994 cd 6c fe			call debug_vector  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 cd cb 04			call storage_write_block 
099a			 
099a 3a 6b fa			ld a, (store_tmpid) 
099d 6f				ld l, a 
099e 26 00			ld h,0 
09a0				if DEBUG_STORESE 
09a0					DMARK "SCz" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 68 fe			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 69 fe			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 6a fe			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "SCz"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6c fe			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc c9				ret 
09bd				 
09bd			 
09bd			 
09bd			; 
09bd			; Read File 
09bd			; 
09bd			; h - file id to locate 
09bd			; l - extent to locate 
09bd			; de - pointer to string to read into 
09bd			; 
09bd			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bd			 
09bd			.sr_fail: 
09bd d1				pop de 
09be c9				ret 
09bf			 
09bf			storage_read: 
09bf			 
09bf			 
09bf d5				push de 
09c0			 
09c0			; TODO BUG the above push is it popped before the RET Z? 
09c0			 
09c0			; TODO how to handle multiple part blocks 
09c0			 
09c0				; locate file extent to read 
09c0			 
09c0 5c				ld e, h 
09c1 55				ld d, l 
09c2			 
09c2			.srext: 
09c2 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c5 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c9			 
09c9 21 40 00			ld hl, STORE_BLOCK_PHY 
09cc				if DEBUG_STORESE 
09cc					DMARK "sre" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 68 fe			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 69 fe			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 6a fe			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "sre"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6c fe			call debug_vector  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8 cd 99 07			call storage_findnextid 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "srf" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 68 fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 69 fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 6a fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "srf"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 6c fe			call debug_vector  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd f9 0f			call ishlzero 
0a0a			;	ld a, l 
0a0a			;	add h 
0a0a			;	cp 0 
0a0a 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0c			 
0a0c				; save current address for use by higher level words etc 
0a0c			 
0a0c 22 68 fa			ld (store_openaddr),hl 
0a0f			 
0a0f			 
0a0f				; hl contains page number to load 
0a0f d1				pop de   ; get storage 
0a10 ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a14 d5				push de 
0a15				if DEBUG_STORESE 
0a15					DMARK "srg" 
0a15 f5				push af  
0a16 3a 2a 0a			ld a, (.dmark)  
0a19 32 68 fe			ld (debug_mark),a  
0a1c 3a 2b 0a			ld a, (.dmark+1)  
0a1f 32 69 fe			ld (debug_mark+1),a  
0a22 3a 2c 0a			ld a, (.dmark+2)  
0a25 32 6a fe			ld (debug_mark+2),a  
0a28 18 03			jr .pastdmark  
0a2a ..			.dmark: db "srg"  
0a2d f1			.pastdmark: pop af  
0a2e			endm  
# End of macro DMARK
0a2e					CALLMONITOR 
0a2e cd 6c fe			call debug_vector  
0a31				endm  
# End of macro CALLMONITOR
0a31				endif 
0a31 cd 66 04			call storage_read_block 
0a34			 
0a34				; if this a continuation read??? 
0a34			 
0a34 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a37			 
0a37 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a39 cd d0 0f			call addatohl 
0a3c 7e				ld a,(hl) 
0a3d fe 00			cp 0 
0a3f 28 02			jr z, .markiscont 
0a41 3e ff			ld a, 255 
0a43			 
0a43			.markiscont: 
0a43 32 6a fa			ld (store_readcont), a 
0a46			 
0a46				if DEBUG_STORESE 
0a46					DMARK "srC" 
0a46 f5				push af  
0a47 3a 5b 0a			ld a, (.dmark)  
0a4a 32 68 fe			ld (debug_mark),a  
0a4d 3a 5c 0a			ld a, (.dmark+1)  
0a50 32 69 fe			ld (debug_mark+1),a  
0a53 3a 5d 0a			ld a, (.dmark+2)  
0a56 32 6a fe			ld (debug_mark+2),a  
0a59 18 03			jr .pastdmark  
0a5b ..			.dmark: db "srC"  
0a5e f1			.pastdmark: pop af  
0a5f			endm  
# End of macro DMARK
0a5f					CALLMONITOR 
0a5f cd 6c fe			call debug_vector  
0a62				endm  
# End of macro CALLMONITOR
0a62				endif 
0a62				; only short reads enabled 
0a62			 
0a62 3a 72 fa			ld a, (store_longread) 
0a65 fe 00			cp 0 
0a67 ca 34 0b			jp z, .readdone 
0a6a			 
0a6a			; TODO if block has no zeros then need to read next block  
0a6a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a6a			; check last byte of physical block. 
0a6a			; if not zero then the next block needs to be loaded 
0a6a			 
0a6a			 
0a6a 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6d			 
0a6d 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6f cd d0 0f			call addatohl 
0a72				;dec hl 
0a72 7e				ld a,(hl) 
0a73				if DEBUG_STORESE 
0a73					DMARK "sr?" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 68 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 69 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 6a fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sr?"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd 6c fe			call debug_vector  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f fe 00			cp 0 
0a91 ca 34 0b			jp z, .readdone 
0a94			 
0a94				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a94			 
0a94 23				inc hl 
0a95			 
0a95 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a98			 
0a98 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9c			 
0a9c eb				ex de, hl 
0a9d			 
0a9d				; next ext 
0a9d			 
0a9d 23				inc hl 
0a9e 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa1			 
0aa1				if DEBUG_STORESE 
0aa1					DMARK "sF2" 
0aa1 f5				push af  
0aa2 3a b6 0a			ld a, (.dmark)  
0aa5 32 68 fe			ld (debug_mark),a  
0aa8 3a b7 0a			ld a, (.dmark+1)  
0aab 32 69 fe			ld (debug_mark+1),a  
0aae 3a b8 0a			ld a, (.dmark+2)  
0ab1 32 6a fe			ld (debug_mark+2),a  
0ab4 18 03			jr .pastdmark  
0ab6 ..			.dmark: db "sF2"  
0ab9 f1			.pastdmark: pop af  
0aba			endm  
# End of macro DMARK
0aba					CALLMONITOR 
0aba cd 6c fe			call debug_vector  
0abd				endm  
# End of macro CALLMONITOR
0abd				endif 
0abd			 
0abd				; get and load block 
0abd			 
0abd cd 99 07			call storage_findnextid 
0ac0			 
0ac0				if DEBUG_STORESE 
0ac0					DMARK "sf2" 
0ac0 f5				push af  
0ac1 3a d5 0a			ld a, (.dmark)  
0ac4 32 68 fe			ld (debug_mark),a  
0ac7 3a d6 0a			ld a, (.dmark+1)  
0aca 32 69 fe			ld (debug_mark+1),a  
0acd 3a d7 0a			ld a, (.dmark+2)  
0ad0 32 6a fe			ld (debug_mark+2),a  
0ad3 18 03			jr .pastdmark  
0ad5 ..			.dmark: db "sf2"  
0ad8 f1			.pastdmark: pop af  
0ad9			endm  
# End of macro DMARK
0ad9					CALLMONITOR 
0ad9 cd 6c fe			call debug_vector  
0adc				endm  
# End of macro CALLMONITOR
0adc				endif 
0adc cd f9 0f			call ishlzero 
0adf			;	ld a, l 
0adf			;	add h 
0adf			;	cp 0 
0adf ca bd 09			jp z,.sr_fail			; block not found so EOF 
0ae2				 
0ae2				; save current address for use by higher level words etc 
0ae2			 
0ae2 22 68 fa			ld (store_openaddr),hl 
0ae5			 
0ae5 cd 66 04			call storage_read_block 
0ae8			 
0ae8				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae8				; we need to pull everything back  
0ae8			 
0ae8 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aec 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aef 23				inc hl 
0af0 23				inc hl     ; skip id and ext 
0af1 01 40 00			ld bc, STORE_BLOCK_PHY 
0af4				if DEBUG_STORESE 
0af4					DMARK "SR<" 
0af4 f5				push af  
0af5 3a 09 0b			ld a, (.dmark)  
0af8 32 68 fe			ld (debug_mark),a  
0afb 3a 0a 0b			ld a, (.dmark+1)  
0afe 32 69 fe			ld (debug_mark+1),a  
0b01 3a 0b 0b			ld a, (.dmark+2)  
0b04 32 6a fe			ld (debug_mark+2),a  
0b07 18 03			jr .pastdmark  
0b09 ..			.dmark: db "SR<"  
0b0c f1			.pastdmark: pop af  
0b0d			endm  
# End of macro DMARK
0b0d					CALLMONITOR 
0b0d cd 6c fe			call debug_vector  
0b10				endm  
# End of macro CALLMONITOR
0b10				endif 
0b10 ed b0			ldir     ; copy data 
0b12			 
0b12				; move the pointer back and pretend we have a full buffer for next recheck 
0b12			 
0b12 1b				dec de 
0b13 1b				dec de 
0b14			 
0b14			; TODO do pop below now short circuit loop????? 
0b14 c1				pop bc     ; get rid of spare de on stack 
0b15				if DEBUG_STORESE 
0b15					DMARK "SR>" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 68 fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 69 fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 6a fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "SR>"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd 6c fe			call debug_vector  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31 c3 c2 09			jp .srext 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			.readdone:		 
0b34 e1				pop hl 		 ; return start of data to show as not EOF 
0b35 23				inc hl   ; past file id 
0b36 23				inc hl   ; past ext 
0b37				if DEBUG_STORESE 
0b37					DMARK "SRe" 
0b37 f5				push af  
0b38 3a 4c 0b			ld a, (.dmark)  
0b3b 32 68 fe			ld (debug_mark),a  
0b3e 3a 4d 0b			ld a, (.dmark+1)  
0b41 32 69 fe			ld (debug_mark+1),a  
0b44 3a 4e 0b			ld a, (.dmark+2)  
0b47 32 6a fe			ld (debug_mark+2),a  
0b4a 18 03			jr .pastdmark  
0b4c ..			.dmark: db "SRe"  
0b4f f1			.pastdmark: pop af  
0b50			endm  
# End of macro DMARK
0b50					CALLMONITOR 
0b50 cd 6c fe			call debug_vector  
0b53				endm  
# End of macro CALLMONITOR
0b53				endif 
0b53 c9					ret 
0b54			 
0b54			 
0b54			 
0b54			; 
0b54			; Append File 
0b54			; 
0b54			; hl - file id to locate 
0b54			; de - pointer to (multi block) string to write 
0b54			 
0b54			.sa_notfound: 
0b54 d1				pop de 
0b55 c9				ret 
0b56			 
0b56			 
0b56			storage_append: 
0b56				; hl -  file id to append to 
0b56				; de - string to append 
0b56			 
0b56 d5				push de 
0b57				 
0b57				if DEBUG_STORESE 
0b57					DMARK "AP1" 
0b57 f5				push af  
0b58 3a 6c 0b			ld a, (.dmark)  
0b5b 32 68 fe			ld (debug_mark),a  
0b5e 3a 6d 0b			ld a, (.dmark+1)  
0b61 32 69 fe			ld (debug_mark+1),a  
0b64 3a 6e 0b			ld a, (.dmark+2)  
0b67 32 6a fe			ld (debug_mark+2),a  
0b6a 18 03			jr .pastdmark  
0b6c ..			.dmark: db "AP1"  
0b6f f1			.pastdmark: pop af  
0b70			endm  
# End of macro DMARK
0b70					CALLMONITOR 
0b70 cd 6c fe			call debug_vector  
0b73				endm  
# End of macro CALLMONITOR
0b73				endif 
0b73			 
0b73 7d				ld a, l 
0b74 32 6b fa			ld (store_tmpid), a 
0b77			 
0b77				; get file header  
0b77			 
0b77 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b79 3a 6b fa			ld a, (store_tmpid) 
0b7c 5f				ld e, a 
0b7d			 
0b7d 21 40 00				ld hl, STORE_BLOCK_PHY 
0b80 cd 99 07				call storage_findnextid 
0b83			 
0b83 cd f9 0f			call ishlzero 
0b86 28 cc			jr z, .sa_notfound 
0b88			 
0b88 22 62 fa			ld (store_tmppageid), hl 
0b8b			 
0b8b				; TODO handle file id not found 
0b8b			 
0b8b				if DEBUG_STORESE 
0b8b					DMARK "AP2" 
0b8b f5				push af  
0b8c 3a a0 0b			ld a, (.dmark)  
0b8f 32 68 fe			ld (debug_mark),a  
0b92 3a a1 0b			ld a, (.dmark+1)  
0b95 32 69 fe			ld (debug_mark+1),a  
0b98 3a a2 0b			ld a, (.dmark+2)  
0b9b 32 6a fe			ld (debug_mark+2),a  
0b9e 18 03			jr .pastdmark  
0ba0 ..			.dmark: db "AP2"  
0ba3 f1			.pastdmark: pop af  
0ba4			endm  
# End of macro DMARK
0ba4					CALLMONITOR 
0ba4 cd 6c fe			call debug_vector  
0ba7				endm  
# End of macro CALLMONITOR
0ba7				endif 
0ba7			 
0ba7				; update file extent count 
0ba7			 
0ba7 11 77 fa			ld de, store_page 
0baa			 
0baa cd 66 04			call storage_read_block 
0bad			 
0bad				if DEBUG_STORESE 
0bad					DMARK "AP3" 
0bad f5				push af  
0bae 3a c2 0b			ld a, (.dmark)  
0bb1 32 68 fe			ld (debug_mark),a  
0bb4 3a c3 0b			ld a, (.dmark+1)  
0bb7 32 69 fe			ld (debug_mark+1),a  
0bba 3a c4 0b			ld a, (.dmark+2)  
0bbd 32 6a fe			ld (debug_mark+2),a  
0bc0 18 03			jr .pastdmark  
0bc2 ..			.dmark: db "AP3"  
0bc5 f1			.pastdmark: pop af  
0bc6			endm  
# End of macro DMARK
0bc6					CALLMONITOR 
0bc6 cd 6c fe			call debug_vector  
0bc9				endm  
# End of macro CALLMONITOR
0bc9				endif 
0bc9			;	ld (store_tmppageid), hl 
0bc9			 
0bc9 3a 79 fa			ld a, (store_page+2) 
0bcc 3c				inc a 
0bcd 32 79 fa			ld (store_page+2), a 
0bd0 32 6a fa			ld (store_tmpext), a 
0bd3				 
0bd3				if DEBUG_STORESE 
0bd3					DMARK "AP3" 
0bd3 f5				push af  
0bd4 3a e8 0b			ld a, (.dmark)  
0bd7 32 68 fe			ld (debug_mark),a  
0bda 3a e9 0b			ld a, (.dmark+1)  
0bdd 32 69 fe			ld (debug_mark+1),a  
0be0 3a ea 0b			ld a, (.dmark+2)  
0be3 32 6a fe			ld (debug_mark+2),a  
0be6 18 03			jr .pastdmark  
0be8 ..			.dmark: db "AP3"  
0beb f1			.pastdmark: pop af  
0bec			endm  
# End of macro DMARK
0bec					CALLMONITOR 
0bec cd 6c fe			call debug_vector  
0bef				endm  
# End of macro CALLMONITOR
0bef				endif 
0bef 2a 62 fa			ld hl, (store_tmppageid) 
0bf2 11 77 fa			ld de, store_page 
0bf5 cd cb 04			call storage_write_block 
0bf8			 
0bf8				; find free block 
0bf8			 
0bf8 11 00 00			ld de, 0			 ; file extent to locate 
0bfb			 
0bfb 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfe cd 99 07				call storage_findnextid 
0c01 cd f9 0f			call ishlzero 
0c04 ca 54 0b			jp z, .sa_notfound 
0c07			 
0c07					; TODO handle no space left 
0c07					 
0c07 22 62 fa				ld (store_tmppageid), hl 
0c0a			 
0c0a				if DEBUG_STORESE 
0c0a					DMARK "AP4" 
0c0a f5				push af  
0c0b 3a 1f 0c			ld a, (.dmark)  
0c0e 32 68 fe			ld (debug_mark),a  
0c11 3a 20 0c			ld a, (.dmark+1)  
0c14 32 69 fe			ld (debug_mark+1),a  
0c17 3a 21 0c			ld a, (.dmark+2)  
0c1a 32 6a fe			ld (debug_mark+2),a  
0c1d 18 03			jr .pastdmark  
0c1f ..			.dmark: db "AP4"  
0c22 f1			.pastdmark: pop af  
0c23			endm  
# End of macro DMARK
0c23					CALLMONITOR 
0c23 cd 6c fe			call debug_vector  
0c26				endm  
# End of macro CALLMONITOR
0c26				endif 
0c26					; init the buffer with zeros so we can id if the buffer is full or not 
0c26			 
0c26 e5					push hl 
0c27 c5					push bc 
0c28			 
0c28 21 77 fa				ld hl, store_page 
0c2b 06 40				ld b, STORE_BLOCK_PHY 
0c2d 3e 00				ld a, 0 
0c2f 77			.zeroblock:	ld (hl), a 
0c30 23					inc hl 
0c31 10 fc				djnz .zeroblock 
0c33			 
0c33 c1					pop bc 
0c34 e1					pop hl 
0c35			 
0c35					; construct block 
0c35			 
0c35 3a 6b fa				ld a, (store_tmpid) 
0c38 32 77 fa				ld (store_page), a   ; file id 
0c3b 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3e 32 78 fa				ld (store_page+1), a 
0c41			 
0c41 e1					pop hl    ; get string to write 
0c42 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c44 11 79 fa				ld de, store_page+2 
0c47			 
0c47				if DEBUG_STORESE 
0c47					DMARK "AP5" 
0c47 f5				push af  
0c48 3a 5c 0c			ld a, (.dmark)  
0c4b 32 68 fe			ld (debug_mark),a  
0c4e 3a 5d 0c			ld a, (.dmark+1)  
0c51 32 69 fe			ld (debug_mark+1),a  
0c54 3a 5e 0c			ld a, (.dmark+2)  
0c57 32 6a fe			ld (debug_mark+2),a  
0c5a 18 03			jr .pastdmark  
0c5c ..			.dmark: db "AP5"  
0c5f f1			.pastdmark: pop af  
0c60			endm  
# End of macro DMARK
0c60					CALLMONITOR 
0c60 cd 6c fe			call debug_vector  
0c63				endm  
# End of macro CALLMONITOR
0c63				endif 
0c63			 
0c63			 
0c63			 
0c63					; fill buffer with data until end of string or full block 
0c63			 
0c63 7e			.appd:		ld a, (hl) 
0c64 12					ld (de), a 
0c65 fe 00				cp 0 
0c67 28 04				jr z, .appdone 
0c69 23					inc hl 
0c6a 13					inc de 
0c6b 10 f6				djnz .appd 
0c6d			 
0c6d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6e f5					push af   		; save last byte dumped 
0c6f			 
0c6f			 
0c6f 2a 62 fa			ld hl, (store_tmppageid) 
0c72 11 77 fa			ld de, store_page 
0c75				if DEBUG_STORESE 
0c75					DMARK "AP6" 
0c75 f5				push af  
0c76 3a 8a 0c			ld a, (.dmark)  
0c79 32 68 fe			ld (debug_mark),a  
0c7c 3a 8b 0c			ld a, (.dmark+1)  
0c7f 32 69 fe			ld (debug_mark+1),a  
0c82 3a 8c 0c			ld a, (.dmark+2)  
0c85 32 6a fe			ld (debug_mark+2),a  
0c88 18 03			jr .pastdmark  
0c8a ..			.dmark: db "AP6"  
0c8d f1			.pastdmark: pop af  
0c8e			endm  
# End of macro DMARK
0c8e					CALLMONITOR 
0c8e cd 6c fe			call debug_vector  
0c91				endm  
# End of macro CALLMONITOR
0c91				endif 
0c91 cd cb 04				call storage_write_block 
0c94			 
0c94			 
0c94				; was that a full block of data written? 
0c94				; any more to write out? 
0c94			 
0c94				; if yes then set vars and jump to start of function again 
0c94			 
0c94 f1					pop af 
0c95 d1					pop de 
0c96			 
0c96 fe 00				cp 0		 ; no, string was fully written 
0c98 c8					ret z 
0c99			 
0c99					; setup vars for next cycle 
0c99			 
0c99 3a 6b fa				ld a, (store_tmpid) 
0c9c 6f					ld l, a 
0c9d 26 00				ld h, 0 
0c9f			 
0c9f c3 56 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			if DEBUG_STORECF 
0ca2			storageput:	 
0ca2					ret 
0ca2			storageread: 
0ca2					ld hl, store_page 
0ca2					ld b, 200 
0ca2					ld a,0 
0ca2			.src:		ld (hl),a 
0ca2					inc hl 
0ca2					djnz .src 
0ca2					 
0ca2			 
0ca2					ld de, 0 
0ca2					ld bc, 1 
0ca2					ld hl, store_page 
0ca2					call cfRead 
0ca2			 
0ca2				call cfGetError 
0ca2				ld hl,scratch 
0ca2				call hexout 
0ca2				ld hl, scratch+2 
0ca2				ld a, 0 
0ca2				ld (hl),a 
0ca2				ld de, scratch 
0ca2				ld a,display_row_1 
0ca2				call str_at_display 
0ca2				call update_display 
0ca2			 
0ca2					ld hl, store_page 
0ca2					ld (os_cur_ptr),hl 
0ca2			 
0ca2					ret 
0ca2			endif 
0ca2			 
0ca2			 
0ca2			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca2			 
0ca2			storage_clear_page: 
0ca2 e5				push hl 
0ca3 d5				push de 
0ca4 c5				push bc 
0ca5 21 77 fa			ld hl, store_page 
0ca8 3e 00			ld a, 0 
0caa 77				ld (hl), a 
0cab			 
0cab 11 78 fa			ld de, store_page+1 
0cae 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb1			 
0cb1 ed b0			ldir 
0cb3				 
0cb3 c1				pop bc 
0cb4 d1				pop de 
0cb5 e1				pop hl 
0cb6 c9				ret 
0cb7			 
0cb7			; eof 
# End of file firmware_storage.asm
0cb7			  
0cb7			; support routines for above hardware abstraction layer  
0cb7			  
0cb7			include "firmware_general.asm"        ; general support functions  
0cb7			 
0cb7			; word look up 
0cb7			 
0cb7			; in 
0cb7			; a is the index 
0cb7			; hl is pointer start of array 
0cb7			; 
0cb7			; returns 
0cb7			; hl to the word 
0cb7			; 
0cb7			 
0cb7			table_lookup:  
0cb7 d5					push de 
0cb8 eb					ex de, hl 
0cb9			 
0cb9 6f					ld l, a 
0cba 26 00				ld h, 0 
0cbc 29					add hl, hl 
0cbd 19					add hl, de 
0cbe 7e					ld a, (hl) 
0cbf 23					inc hl 
0cc0 66					ld h,(hl) 
0cc1 6f					ld l, a 
0cc2			 
0cc2 d1					pop de 
0cc3 c9					ret 
0cc4			 
0cc4			; Delay loops 
0cc4			 
0cc4			 
0cc4			 
0cc4			aDelayInMS: 
0cc4 c5				push bc 
0cc5 47				ld b,a 
0cc6			msdelay: 
0cc6 c5				push bc 
0cc7				 
0cc7			 
0cc7 01 41 00			ld bc,041h 
0cca cd e2 0c			call delayloop 
0ccd c1				pop bc 
0cce 05				dec b 
0ccf 20 f5			jr nz,msdelay 
0cd1			 
0cd1			;if CPU_CLOCK_8MHZ 
0cd1			;msdelay8: 
0cd1			;	push bc 
0cd1			;	 
0cd1			; 
0cd1			;	ld bc,041h 
0cd1			;	call delayloop 
0cd1			;	pop bc 
0cd1			;	dec b 
0cd1			;	jr nz,msdelay8 
0cd1			;endif 
0cd1			 
0cd1			 
0cd1 c1				pop bc 
0cd2 c9				ret 
0cd3			 
0cd3			 
0cd3			delay250ms: 
0cd3				;push de 
0cd3 01 00 40			ld bc, 04000h 
0cd6 c3 e2 0c			jp delayloop 
0cd9			delay500ms: 
0cd9				;push de 
0cd9 01 00 80			ld bc, 08000h 
0cdc c3 e2 0c			jp delayloop 
0cdf			delay1s: 
0cdf				;push bc 
0cdf			   ; Clobbers A, d and e 
0cdf 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce2			delayloop: 
0ce2 c5			    push bc 
0ce3			 
0ce3			if BASE_CPM 
0ce3				ld bc, CPM_DELAY_TUNE 
0ce3			.cpmloop: 
0ce3				push bc 
0ce3			 
0ce3			endif 
0ce3			 
0ce3			 
0ce3			 
0ce3			delayloopi: 
0ce3			;	push bc 
0ce3			;.dl: 
0ce3 cb 47		    bit     0,a    	; 8 
0ce5 cb 47		    bit     0,a    	; 8 
0ce7 cb 47		    bit     0,a    	; 8 
0ce9 e6 ff		    and     255  	; 7 
0ceb 0b			    dec     bc      	; 6 
0cec 79			    ld      a,c     	; 4 
0ced b0			    or      b     	; 4 
0cee c2 e3 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf1				;pop de 
0cf1			;pop bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				pop bc 
0cf1				 
0cf1			    dec     bc      	; 6 
0cf1			    ld      a,c     	; 4 
0cf1			    or      b     	; 4 
0cf1			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf1				 
0cf1			 
0cf1			endif 
0cf1			;if CPU_CLOCK_8MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1			 
0cf1			;if CPU_CLOCK_10MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1 c1			    pop bc 
0cf2			 
0cf2 c9				ret 
0cf3			 
0cf3			 
0cf3			 
0cf3			; eof 
# End of file firmware_general.asm
0cf3			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf3			; display routines that use the physical hardware abstraction layer 
0cf3			 
0cf3			 
0cf3			; Display an activity indicator 
0cf3			; Each call returns the new char pointed to in hl 
0cf3			 
0cf3			active: 
0cf3 3a c3 fb			ld a, (display_active) 
0cf6 fe 06			cp 6 
0cf8			 
0cf8 20 02			jr nz, .sne 
0cfa				; gone past the last one reset sequence 
0cfa 3e ff			ld a, 255 
0cfc			 
0cfc			.sne:   
0cfc				; get the next char in seq 
0cfc 3c				inc a 
0cfd 32 c3 fb			ld (display_active), a 
0d00			 
0d00				; look up the string in the table 
0d00 21 17 0d			ld hl, actseq 
0d03 cb 27			sla a 
0d05 cd d0 0f			call addatohl 
0d08 cd 35 24			call loadwordinhl 
0d0b			 
0d0b				; forth will write the to string when pushing so move from rom to ram 
0d0b			 
0d0b 11 c4 fb			ld de, display_active+1 
0d0e 01 02 00			ld bc, 2 
0d11 ed b0			ldir 
0d13			 
0d13 21 c4 fb			ld hl, display_active+1 
0d16 c9				ret 
0d17				 
0d17				 
0d17			 
0d17			 
0d17			;db "|/-\|-\" 
0d17			 
0d17			actseq: 
0d17			 
0d17 25 0d		dw spin0 
0d19 27 0d		dw spin1 
0d1b 29 0d		dw spin2 
0d1d 2b 0d		dw spin3 
0d1f 29 0d		dw spin2 
0d21 27 0d		dw spin1 
0d23 25 0d		dw spin0 
0d25			 
0d25 .. 00		spin0: db " ", 0 
0d27 .. 00		spin1: db "-", 0 
0d29 .. 00		spin2: db "+", 0 
0d2b .. 00		spin3: db "#", 0 
0d2d			 
0d2d			 
0d2d			; information window 
0d2d			 
0d2d			; pass hl with 1st string to display 
0d2d			; pass de with 2nd string to display 
0d2d			 
0d2d			info_panel: 
0d2d e5				push hl 
0d2e			 
0d2e 2a c9 fb			ld hl, (display_fb_active) 
0d31 e5				push hl    ; future de destination 
0d32 21 ae fd				ld hl, display_fb0 
0d35 22 c9 fb				ld (display_fb_active), hl 
0d38			 
0d38			;	call clear_display 
0d38			 
0d38				if BASE_CPM 
0d38				ld a, '.' 
0d38				else 
0d38 3e a5			ld a, 165 
0d3a				endif 
0d3a cd a1 0d			call fill_display 
0d3d			 
0d3d			 
0d3d 3e 55			ld a, display_row_3 + 5 
0d3f cd af 0d			call str_at_display 
0d42			 
0d42 e1				pop hl 
0d43 d1				pop de 
0d44			 
0d44 e5				push hl 
0d45			 
0d45			 
0d45 3e 2d			ld a, display_row_2 + 5 
0d47 cd af 0d			call str_at_display 
0d4a			 
0d4a			 
0d4a cd bf 0d			call update_display 
0d4d cd 7e 20			call next_page_prompt 
0d50 cd 9c 0d			call clear_display 
0d53			 
0d53				 
0d53 21 0d fd				ld hl, display_fb1 
0d56 22 c9 fb				ld (display_fb_active), hl 
0d59 cd bf 0d			call update_display 
0d5c			 
0d5c e1				pop hl 
0d5d			 
0d5d c9				ret 
0d5e			 
0d5e			 
0d5e			 
0d5e			 
0d5e			; TODO windowing? 
0d5e			 
0d5e			; TODO scroll line up 
0d5e			 
0d5e			scroll_up: 
0d5e			 
0d5e e5				push hl 
0d5f d5				push de 
0d60 c5				push bc 
0d61			 
0d61				; get frame buffer  
0d61			 
0d61 2a c9 fb			ld hl, (display_fb_active) 
0d64 e5				push hl    ; future de destination 
0d65			 
0d65 11 28 00			ld  de, display_cols 
0d68 19				add hl, de 
0d69			 
0d69 d1				pop de 
0d6a			 
0d6a				;ex de, hl 
0d6a 01 9f 00			ld bc, display_fb_len -1  
0d6d			;if DEBUG_FORTH_WORDS 
0d6d			;	DMARK "SCL" 
0d6d			;	CALLMONITOR 
0d6d			;endif	 
0d6d ed b0			ldir 
0d6f			 
0d6f				; wipe bottom row 
0d6f			 
0d6f			 
0d6f 2a c9 fb			ld hl, (display_fb_active) 
0d72 11 a0 00			ld de, display_cols*display_rows 
0d75 19				add hl, de 
0d76 06 28			ld b, display_cols 
0d78 3e 20			ld a, ' ' 
0d7a			.scwipe: 
0d7a 77				ld (hl), a 
0d7b 2b				dec hl 
0d7c 10 fc			djnz .scwipe 
0d7e			 
0d7e				;pop hl 
0d7e			 
0d7e c1				pop bc 
0d7f d1				pop de 
0d80 e1				pop hl 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			;scroll_upo: 
0d82			;	ld de, display_row_1 
0d82			 ;	ld hl, display_row_2 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_2 
0d82			 ;	ld hl, display_row_3 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_3 
0d82			 ;	ld hl, display_row_4 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			 
0d82			; TODO clear row 4 
0d82			 
0d82			;	ret 
0d82			 
0d82				 
0d82			scroll_down: 
0d82			 
0d82 e5				push hl 
0d83 d5				push de 
0d84 c5				push bc 
0d85			 
0d85				; get frame buffer  
0d85			 
0d85 2a c9 fb			ld hl, (display_fb_active) 
0d88			 
0d88 11 9f 00			ld de, display_fb_len - 1 
0d8b 19				add hl, de 
0d8c			 
0d8c e5			push hl    ; future de destination 
0d8d			 
0d8d 11 28 00			ld  de, display_cols 
0d90 ed 52			sbc hl, de 
0d92			 
0d92			 
0d92 d1				pop de 
0d93			 
0d93			;	ex de, hl 
0d93 01 9f 00			ld bc, display_fb_len -1  
0d96			 
0d96			 
0d96				 
0d96			 
0d96 ed b0			ldir 
0d98			 
0d98				; wipe bottom row 
0d98			 
0d98			 
0d98			;	ld hl, (display_fb_active) 
0d98			;;	ld de, display_cols*display_rows 
0d98			;;	add hl, de 
0d98			;	ld b, display_cols 
0d98			;	ld a, ' ' 
0d98			;.scwiped: 
0d98			;	ld (hl), a 
0d98			;	dec hl 
0d98			;	djnz .scwiped 
0d98			 
0d98				;pop hl 
0d98			 
0d98 c1				pop bc 
0d99 d1				pop de 
0d9a e1				pop hl 
0d9b			 
0d9b c9				ret 
0d9c			;scroll_down: 
0d9c			;	ld de, display_row_4 
0d9c			;	ld hl, display_row_3 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_3 
0d9c			; 	ld hl, display_row_2 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_2 
0d9c			;	ld hl, display_row_1 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;;; TODO clear row 1 
0d9c			;	ret 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			; clear active frame buffer 
0d9c			 
0d9c			clear_display: 
0d9c 3e 20			ld a, ' ' 
0d9e c3 a1 0d			jp fill_display 
0da1			 
0da1			; fill active frame buffer with a char in A 
0da1			 
0da1			fill_display: 
0da1 06 a0			ld b,display_fb_len 
0da3 2a c9 fb			ld hl, (display_fb_active) 
0da6 77			.fd1:	ld (hl),a 
0da7 23				inc hl 
0da8 10 fc			djnz .fd1 
0daa 23				inc hl 
0dab 3e 00			ld a,0 
0dad 77				ld (hl),a 
0dae			 
0dae			 
0dae c9				ret 
0daf			; Write string (DE) at pos (A) to active frame buffer 
0daf			 
0daf 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db2 06 00					ld b,0 
0db4 4f					ld c,a 
0db5 09					add hl,bc 
0db6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db7 b7			            OR   A              ;Null terminator? 
0db8 c8			            RET  Z              ;Yes, so finished 
0db9 77					ld (hl),a 
0dba 23				inc hl 
0dbb 13			            INC  DE             ;Point to next character 
0dbc 18 f8		            JR   .sad1     ;Repeat 
0dbe c9					ret 
0dbf			 
0dbf			; using current frame buffer write to physical display 
0dbf			 
0dbf			update_display: 
0dbf e5				push hl 
0dc0 2a c9 fb			ld hl, (display_fb_active) 
0dc3 cd 8a 76			call write_display 
0dc6 e1				pop hl 
0dc7 c9				ret 
0dc8			 
0dc8			; TODO scrolling 
0dc8			 
0dc8			 
0dc8			; move cursor right one char 
0dc8			cursor_right: 
0dc8			 
0dc8				; TODO shift right 
0dc8				; TODO if beyond max col 
0dc8				; TODO       cursor_next_line 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			 
0dc9			cursor_next_line: 
0dc9				; TODO first char 
0dc9				; TODO line down 
0dc9				; TODO if past last row 
0dc9				; TODO    scroll up 
0dc9			 
0dc9 c9				ret 
0dca			 
0dca			cursor_left: 
0dca				; TODO shift left 
0dca				; TODO if beyond left  
0dca				; TODO     cursor prev line 
0dca				 
0dca c9				ret 
0dcb			 
0dcb			cursor_prev_line: 
0dcb				; TODO last char 
0dcb				; TODO line up 
0dcb				; TODO if past first row 
0dcb				; TODO   scroll down 
0dcb			 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			cout: 
0dcc				; A - char 
0dcc c9				ret 
0dcd			 
0dcd			 
0dcd			; Display a menu and allow item selection (optional toggle items) 
0dcd			; 
0dcd			; format: 
0dcd			; hl pointer to word array with zero term for items 
0dcd			; e.g.    db item1 
0dcd			;         db .... 
0dcd			;         db 0 
0dcd			; 
0dcd			; a = starting menu item  
0dcd			; 
0dcd			; de = pointer item toggle array   (todo) 
0dcd			; 
0dcd			; returns item selected in a 1-... 
0dcd			; returns 0 if back button pressed 
0dcd			; 
0dcd			; NOTE: Uses system frame buffer to display 
0dcd			; 
0dcd			; LEFT, Q = go back 
0dcd			; RIGHT, SPACE, CR = select 
0dcd			; UP, A - Up 
0dcd			; DOWN, Z - Down 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			menu: 
0dcd			 
0dcd					; keep array pointer 
0dcd			 
0dcd 22 70 fa				ld (store_tmp1), hl 
0dd0 32 6e fa				ld (store_tmp2), a 
0dd3			 
0dd3					; check for key bounce 
0dd3			 
0dd3			if BASE_KEV 
0dd3			 
0dd3 cd d5 79		.mbounce:	call cin 
0dd6 fe 00				cp 0 
0dd8 20 f9				jr nz, .mbounce 
0dda			endif 
0dda					; for ease use ex 
0dda			 
0dda					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dda 21 ae fd				ld hl, display_fb0 
0ddd 22 c9 fb				ld (display_fb_active), hl 
0de0			 
0de0 cd 9c 0d		.mloop:		call clear_display 
0de3 cd bf 0d				call update_display 
0de6			 
0de6					; draw selection id '>' at 1 
0de6			 
0de6					; init start of list display 
0de6			 
0de6 3e 05				ld a, 5 
0de8 32 6c fa				ld (store_tmp3), a   ; display row count 
0deb 3a 6e fa				ld a,( store_tmp2) 
0dee 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df1			 
0df1					 
0df1			.mitem:	 
0df1			 
0df1			 
0df1 3a 6f fa				ld a,(store_tmp2+1) 
0df4 6f					ld l, a 
0df5 26 00				ld h, 0 
0df7 29					add hl, hl 
0df8 ed 5b 70 fa			ld de, (store_tmp1) 
0dfc 19					add hl, de 
0dfd 7e					ld a, (hl) 
0dfe 23					inc hl 
0dff 66					ld h,(hl) 
0e00 6f					ld l, a 
0e01			 
0e01 cd f9 0f				call ishlzero 
0e04 28 1a				jr z, .mdone 
0e06			 
0e06 eb					ex de, hl 
0e07 3a 6c fa				ld a, (store_tmp3) 
0e0a cd af 0d				call str_at_display 
0e0d					 
0e0d			 
0e0d					; next item 
0e0d 3a 6f fa				ld a, (store_tmp2+1) 
0e10 3c					inc a 
0e11 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e14			 
0e14			 		; next row 
0e14			 
0e14 3a 6c fa				ld a, (store_tmp3) 
0e17 c6 28				add display_cols 
0e19 32 6c fa				ld (store_tmp3), a 
0e1c			 
0e1c					; at end of screen? 
0e1c			 
0e1c fe 10				cp display_rows*4 
0e1e 20 d1				jr nz, .mitem 
0e20			 
0e20			 
0e20			.mdone: 
0e20 cd f9 0f				call ishlzero 
0e23 28 08				jr z, .nodn 
0e25			 
0e25 3e 78				ld a, display_row_4 
0e27 11 a6 0e				ld de, .mdown 
0e2a cd af 0d				call str_at_display 
0e2d			 
0e2d					; draw options to fill the screens with active item on line 1 
0e2d					; if current option is 2 or more then display ^ in top 
0e2d			 
0e2d 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e30 fe 00				cp 0 
0e32 28 08				jr z, .noup 
0e34			 
0e34 3e 00				ld a, 0 
0e36 11 a4 0e				ld de, .mup 
0e39 cd af 0d				call str_at_display 
0e3c			 
0e3c 3e 02		.noup:		ld a, 2 
0e3e 11 a2 0e				ld de, .msel 
0e41 cd af 0d				call str_at_display 
0e44			 
0e44					; if current option + 1 is not null then display V in bottom 
0e44					; get key 
0e44 cd bf 0d				call update_display 
0e47			 
0e47			 
0e47					; handle key 
0e47			 
0e47 cd c4 79				call cin_wait 
0e4a			 
0e4a fe 05				cp KEY_UP 
0e4c 28 2b				jr z, .mgoup 
0e4e fe 61				cp 'a' 
0e50 28 27				jr z, .mgoup 
0e52 fe 0a				cp KEY_DOWN 
0e54 28 32				jr z, .mgod 
0e56 fe 7a				cp 'z' 
0e58 28 2e				jr z, .mgod 
0e5a fe 20				cp ' ' 
0e5c 28 34				jr z, .goend 
0e5e fe 0c				cp KEY_RIGHT 
0e60 28 30				jr z, .goend 
0e62 fe 0d				cp KEY_CR 
0e64 28 2c				jr z, .goend 
0e66 fe 71				cp 'q' 
0e68 28 0b				jr z, .goback 
0e6a			 
0e6a fe 0b				cp KEY_LEFT 
0e6c 28 07				jr z, .goback 
0e6e fe 08				cp KEY_BS 
0e70 28 03				jr z, .goback 
0e72 c3 e0 0d				jp .mloop 
0e75			 
0e75			.goback: 
0e75 3e 00			ld a, 0 
0e77 18 1d			jr .goend2 
0e79			 
0e79				; move up one 
0e79			.mgoup: 
0e79 3a 6e fa				ld a, (store_tmp2) 
0e7c fe 00				cp 0 
0e7e ca e0 0d				jp z, .mloop 
0e81 3d					dec a 
0e82 32 6e fa				ld (store_tmp2), a 
0e85 c3 e0 0d				jp .mloop 
0e88			 
0e88				; move down one 
0e88			.mgod: 
0e88 3a 6e fa				ld a, (store_tmp2) 
0e8b 3c					inc a 
0e8c 32 6e fa				ld (store_tmp2), a 
0e8f c3 e0 0d				jp .mloop 
0e92			 
0e92			 
0e92			.goend: 
0e92					; get selected item number 
0e92			 
0e92 3a 6e fa				ld a, (store_tmp2) 
0e95 3c					inc a 
0e96			 
0e96			.goend2: 
0e96 f5					push af 
0e97			 
0e97					; restore active fb 
0e97					; TODO BUG assumes fb1 
0e97			 
0e97 21 0d fd				ld hl, display_fb1 
0e9a 22 c9 fb				ld (display_fb_active), hl 
0e9d			 
0e9d					; restore main regs 
0e9d			 
0e9d			 
0e9d cd bf 0d				call update_display 
0ea0			 
0ea0 f1					pop af 
0ea1			 
0ea1 c9				ret 
0ea2			 
0ea2 .. 00		.msel:   db ">",0 
0ea4 .. 00		.mup:   db "^",0 
0ea6 .. 00		.mdown:   db "v",0 
0ea8			 
0ea8			 
0ea8			; eof 
0ea8			 
# End of file firmware_display.asm
0ea8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea8			; random number generators 
0ea8			 
0ea8			 
0ea8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea8			 
0ea8			 
0ea8			;-----> Generate a random number 
0ea8			; output a=answer 0<=a<=255 
0ea8			; all registers are preserved except: af 
0ea8			random: 
0ea8 e5			        push    hl 
0ea9 d5			        push    de 
0eaa 2a a8 fb		        ld      hl,(randData) 
0ead ed 5f		        ld      a,r 
0eaf 57			        ld      d,a 
0eb0 5e			        ld      e,(hl) 
0eb1 19			        add     hl,de 
0eb2 85			        add     a,l 
0eb3 ac			        xor     h 
0eb4 22 a8 fb		        ld      (randData),hl 
0eb7 d1			        pop     de 
0eb8 e1			        pop     hl 
0eb9 c9			        ret 
0eba			 
0eba			 
0eba			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eba			 
0eba			 
0eba			 
0eba			;------LFSR------ 
0eba			;James Montelongo 
0eba			;optimized by Spencer Putt 
0eba			;out: 
0eba			; a = 8 bit random number 
0eba			RandLFSR: 
0eba 21 ae fb		        ld hl,LFSRSeed+4 
0ebd 5e			        ld e,(hl) 
0ebe 23			        inc hl 
0ebf 56			        ld d,(hl) 
0ec0 23			        inc hl 
0ec1 4e			        ld c,(hl) 
0ec2 23			        inc hl 
0ec3 7e			        ld a,(hl) 
0ec4 47			        ld b,a 
0ec5 cb 13		        rl e  
0ec7 cb 12			rl d 
0ec9 cb 11		        rl c  
0ecb 17				rla 
0ecc cb 13		        rl e  
0ece cb 12			rl d 
0ed0 cb 11		        rl c  
0ed2 17				rla 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda 67			        ld h,a 
0edb cb 13		        rl e  
0edd cb 12			rl d 
0edf cb 11		        rl c  
0ee1 17				rla 
0ee2 a8			        xor b 
0ee3 cb 13		        rl e  
0ee5 cb 12			rl d 
0ee7 ac			        xor h 
0ee8 a9			        xor c 
0ee9 aa			        xor d 
0eea 21 b0 fb		        ld hl,LFSRSeed+6 
0eed 11 b1 fb		        ld de,LFSRSeed+7 
0ef0 01 07 00		        ld bc,7 
0ef3 ed b8		        lddr 
0ef5 12			        ld (de),a 
0ef6 c9			        ret 
0ef7			 
0ef7			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef7			 
0ef7			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef7			 
0ef7			 
0ef7			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef7			 
0ef7			prng16: 
0ef7			;Inputs: 
0ef7			;   (seed1) contains a 16-bit seed value 
0ef7			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef7			;Outputs: 
0ef7			;   HL is the result 
0ef7			;   BC is the result of the LCG, so not that great of quality 
0ef7			;   DE is preserved 
0ef7			;Destroys: 
0ef7			;   AF 
0ef7			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef7			;160cc 
0ef7			;26 bytes 
0ef7 2a a2 fb		    ld hl,(seed1) 
0efa 44			    ld b,h 
0efb 4d			    ld c,l 
0efc 29			    add hl,hl 
0efd 29			    add hl,hl 
0efe 2c			    inc l 
0eff 09			    add hl,bc 
0f00 22 a2 fb		    ld (seed1),hl 
0f03 2a a0 fb		    ld hl,(seed2) 
0f06 29			    add hl,hl 
0f07 9f			    sbc a,a 
0f08 e6 2d		    and %00101101 
0f0a ad			    xor l 
0f0b 6f			    ld l,a 
0f0c 22 a0 fb		    ld (seed2),hl 
0f0f 09			    add hl,bc 
0f10 c9			    ret 
0f11			 
0f11			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f11			 
0f11			rand32: 
0f11			;Inputs: 
0f11			;   (seed1_0) holds the lower 16 bits of the first seed 
0f11			;   (seed1_1) holds the upper 16 bits of the first seed 
0f11			;   (seed2_0) holds the lower 16 bits of the second seed 
0f11			;   (seed2_1) holds the upper 16 bits of the second seed 
0f11			;   **NOTE: seed2 must be non-zero 
0f11			;Outputs: 
0f11			;   HL is the result 
0f11			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f11			;Destroys: 
0f11			;   AF 
0f11			;Tested and passes all CAcert tests 
0f11			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f11			;it has a period of 18,446,744,069,414,584,320 
0f11			;roughly 18.4 quintillion. 
0f11			;LFSR taps: 0,2,6,7  = 11000101 
0f11			;291cc 
0f11			;seed1_0=$+1 
0f11			;    ld hl,12345 
0f11			;seed1_1=$+1 
0f11			;    ld de,6789 
0f11			;    ld b,h 
0f11			;    ld c,l 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    inc l 
0f11			;    add hl,bc 
0f11			;    ld (seed1_0),hl 
0f11			;    ld hl,(seed1_1) 
0f11			;    adc hl,de 
0f11			;    ld (seed1_1),hl 
0f11			;    ex de,hl 
0f11			;seed2_0=$+1 
0f11			;    ld hl,9876 
0f11			;seed2_1=$+1 
0f11			;    ld bc,54321 
0f11			;    add hl,hl \ rl c \ rl b 
0f11			;    ld (seed2_1),bc 
0f11			;    sbc a,a 
0f11			;    and %11000101 
0f11			;    xor l 
0f11			;    ld l,a 
0f11			;    ld (seed2_0),hl 
0f11			;    ex de,hl 
0f11			;    add hl,bc 
0f11			;    ret 
0f11			; 
0f11			 
0f11			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f11			; 20 bytes, 86 cycles (excluding ret) 
0f11			 
0f11			; returns   hl = pseudorandom number 
0f11			; corrupts   a 
0f11			 
0f11			; generates 16-bit pseudorandom numbers with a period of 65535 
0f11			; using the xorshift method: 
0f11			 
0f11			; hl ^= hl << 7 
0f11			; hl ^= hl >> 9 
0f11			; hl ^= hl << 8 
0f11			 
0f11			; some alternative shift triplets which also perform well are: 
0f11			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f11			 
0f11			;  org 32768 
0f11			 
0f11			xrnd: 
0f11 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f14 3e 00		  ld a,0 
0f16 bd			  cp l 
0f17 20 02		  jr nz, .xrnd1 
0f19 2e 01		  ld l, 1 
0f1b			.xrnd1: 
0f1b			 
0f1b 7c			  ld a,h 
0f1c 1f			  rra 
0f1d 7d			  ld a,l 
0f1e 1f			  rra 
0f1f ac			  xor h 
0f20 67			  ld h,a 
0f21 7d			  ld a,l 
0f22 1f			  rra 
0f23 7c			  ld a,h 
0f24 1f			  rra 
0f25 ad			  xor l 
0f26 6f			  ld l,a 
0f27 ac			  xor h 
0f28 67			  ld h,a 
0f29			 
0f29 22 a6 fb		  ld (xrandc),hl 
0f2c			 
0f2c c9			  ret 
0f2d			;  
0f2d			 
0f2d			 
0f2d			;;;; int maths 
0f2d			 
0f2d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2d			; Divide 16-bit values (with 16-bit result) 
0f2d			; In: Divide BC by divider DE 
0f2d			; Out: BC = result, HL = rest 
0f2d			; 
0f2d			Div16: 
0f2d 21 00 00		    ld hl,0 
0f30 78			    ld a,b 
0f31 06 08		    ld b,8 
0f33			Div16_Loop1: 
0f33 17			    rla 
0f34 ed 6a		    adc hl,hl 
0f36 ed 52		    sbc hl,de 
0f38 30 01		    jr nc,Div16_NoAdd1 
0f3a 19			    add hl,de 
0f3b			Div16_NoAdd1: 
0f3b 10 f6		    djnz Div16_Loop1 
0f3d 17			    rla 
0f3e 2f			    cpl 
0f3f 47			    ld b,a 
0f40 79			    ld a,c 
0f41 48			    ld c,b 
0f42 06 08		    ld b,8 
0f44			Div16_Loop2: 
0f44 17			    rla 
0f45 ed 6a		    adc hl,hl 
0f47 ed 52		    sbc hl,de 
0f49 30 01		    jr nc,Div16_NoAdd2 
0f4b 19			    add hl,de 
0f4c			Div16_NoAdd2: 
0f4c 10 f6		    djnz Div16_Loop2 
0f4e 17			    rla 
0f4f 2f			    cpl 
0f50 41			    ld b,c 
0f51 4f			    ld c,a 
0f52 c9			ret 
0f53			 
0f53			 
0f53			;http://z80-heaven.wikidot.com/math 
0f53			; 
0f53			;Inputs: 
0f53			;     DE and A are factors 
0f53			;Outputs: 
0f53			;     A is not changed 
0f53			;     B is 0 
0f53			;     C is not changed 
0f53			;     DE is not changed 
0f53			;     HL is the product 
0f53			;Time: 
0f53			;     342+6x 
0f53			; 
0f53			Mult16: 
0f53			 
0f53 06 08		     ld b,8          ;7           7 
0f55 21 00 00		     ld hl,0         ;10         10 
0f58 29			       add hl,hl     ;11*8       88 
0f59 07			       rlca          ;4*8        32 
0f5a 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5c 19			         add hl,de   ;--         -- 
0f5d 10 f9		       djnz $-5      ;13*7+8     99 
0f5f c9			ret 
0f60			 
0f60			; 
0f60			; Square root of 16-bit value 
0f60			; In:  HL = value 
0f60			; Out:  D = result (rounded down) 
0f60			; 
0f60			;Sqr16: 
0f60			;    ld de,#0040 
0f60			;    ld a,l 
0f60			;    ld l,h 
0f60			;    ld h,d 
0f60			;    or a 
0f60			;    ld b,8 
0f60			;Sqr16_Loop: 
0f60			;    sbc hl,de 
0f60			;    jr nc,Sqr16_Skip 
0f60			;    add hl,de 
0f60			;Sqr16_Skip: 
0f60			;    ccf 
0f60			;    rl d 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    djnz Sqr16_Loop 
0f60			;    ret 
0f60			; 
0f60			; 
0f60			; Divide 8-bit values 
0f60			; In: Divide E by divider C 
0f60			; Out: A = result, B = rest 
0f60			; 
0f60			Div8: 
0f60 af			    xor a 
0f61 06 08		    ld b,8 
0f63			Div8_Loop: 
0f63 cb 13		    rl e 
0f65 17			    rla 
0f66 91			    sub c 
0f67 30 01		    jr nc,Div8_NoAdd 
0f69 81			    add a,c 
0f6a			Div8_NoAdd: 
0f6a 10 f7		    djnz Div8_Loop 
0f6c 47			    ld b,a 
0f6d 7b			    ld a,e 
0f6e 17			    rla 
0f6f 2f			    cpl 
0f70 c9			    ret 
0f71			 
0f71			; 
0f71			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f71			; In: Multiply A with DE 
0f71			; Out: HL = result 
0f71			; 
0f71			Mult12U: 
0f71 2e 00		    ld l,0 
0f73 87			    add a,a 
0f74 30 01		    jr nc,Mult12U_NoAdd0 
0f76 19			    add hl,de 
0f77			Mult12U_NoAdd0: 
0f77 29			    add hl,hl 
0f78 87			    add a,a 
0f79 30 01		    jr nc,Mult12U_NoAdd1 
0f7b 19			    add hl,de 
0f7c			Mult12U_NoAdd1: 
0f7c 29			    add hl,hl 
0f7d 87			    add a,a 
0f7e 30 01		    jr nc,Mult12U_NoAdd2 
0f80 19			    add hl,de 
0f81			Mult12U_NoAdd2: 
0f81 29			    add hl,hl 
0f82 87			    add a,a 
0f83 30 01		    jr nc,Mult12U_NoAdd3 
0f85 19			    add hl,de 
0f86			Mult12U_NoAdd3: 
0f86 29			    add hl,hl 
0f87 87			    add a,a 
0f88 30 01		    jr nc,Mult12U_NoAdd4 
0f8a 19			    add hl,de 
0f8b			Mult12U_NoAdd4: 
0f8b 29			    add hl,hl 
0f8c 87			    add a,a 
0f8d 30 01		    jr nc,Mult12U_NoAdd5 
0f8f 19			    add hl,de 
0f90			Mult12U_NoAdd5: 
0f90 29			    add hl,hl 
0f91 87			    add a,a 
0f92 30 01		    jr nc,Mult12U_NoAdd6 
0f94 19			    add hl,de 
0f95			Mult12U_NoAdd6: 
0f95 29			    add hl,hl 
0f96 87			    add a,a 
0f97 d0			    ret nc 
0f98 19			    add hl,de 
0f99 c9			    ret 
0f9a			 
0f9a			; 
0f9a			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f9a			; In: Multiply A with DE 
0f9a			;      Put lowest value in A for most efficient calculation 
0f9a			; Out: HL = result 
0f9a			; 
0f9a			Mult12R: 
0f9a 21 00 00		    ld hl,0 
0f9d			Mult12R_Loop: 
0f9d cb 3f		    srl a 
0f9f 30 01		    jr nc,Mult12R_NoAdd 
0fa1 19			    add hl,de 
0fa2			Mult12R_NoAdd: 
0fa2 cb 23		    sla e 
0fa4 cb 12		    rl d 
0fa6 b7			    or a 
0fa7 c2 9d 0f		    jp nz,Mult12R_Loop 
0faa c9			    ret 
0fab			 
0fab			; 
0fab			; Multiply 16-bit values (with 32-bit result) 
0fab			; In: Multiply BC with DE 
0fab			; Out: BCHL = result 
0fab			; 
0fab			Mult32: 
0fab 79			    ld a,c 
0fac 48			    ld c,b 
0fad 21 00 00		    ld hl,0 
0fb0 06 10		    ld b,16 
0fb2			Mult32_Loop: 
0fb2 29			    add hl,hl 
0fb3 17			    rla 
0fb4 cb 11		    rl c 
0fb6 30 07		    jr nc,Mult32_NoAdd 
0fb8 19			    add hl,de 
0fb9 ce 00		    adc a,0 
0fbb d2 bf 0f		    jp nc,Mult32_NoAdd 
0fbe 0c			    inc c 
0fbf			Mult32_NoAdd: 
0fbf 10 f1		    djnz Mult32_Loop 
0fc1 41			    ld b,c 
0fc2 4f			    ld c,a 
0fc3 c9			    ret 
0fc4			 
0fc4			 
0fc4			 
0fc4			; 
0fc4			; Multiply 8-bit values 
0fc4			; In:  Multiply H with E 
0fc4			; Out: HL = result 
0fc4			; 
0fc4			Mult8: 
0fc4 16 00		    ld d,0 
0fc6 6a			    ld l,d 
0fc7 06 08		    ld b,8 
0fc9			Mult8_Loop: 
0fc9 29			    add hl,hl 
0fca 30 01		    jr nc,Mult8_NoAdd 
0fcc 19			    add hl,de 
0fcd			Mult8_NoAdd: 
0fcd 10 fa		    djnz Mult8_Loop 
0fcf c9			    ret 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			;;http://z80-heaven.wikidot.com/math 
0fd0			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fd0			; 
0fd0			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fd0			;     ld a,16        ;7 
0fd0			;     ld hl,0        ;10 
0fd0			;     jp $+5         ;10 
0fd0			;.DivLoop: 
0fd0			;       add hl,bc    ;-- 
0fd0			;       dec a        ;64 
0fd0			;       jr z,.DivLoopEnd        ;86 
0fd0			; 
0fd0			;       sla e        ;128 
0fd0			;       rl d         ;128 
0fd0			;       adc hl,hl    ;240 
0fd0			;       sbc hl,bc    ;240 
0fd0			;       jr nc,.DivLoop ;23|21 
0fd0			;       inc e        ;-- 
0fd0			;       jp .DivLoop+1 
0fd0			; 
0fd0			;.DivLoopEnd: 
0fd0			 
0fd0			;HL_Div_C: 
0fd0			;Inputs: 
0fd0			;     HL is the numerator 
0fd0			;     C is the denominator 
0fd0			;Outputs: 
0fd0			;     A is the remainder 
0fd0			;     B is 0 
0fd0			;     C is not changed 
0fd0			;     DE is not changed 
0fd0			;     HL is the quotient 
0fd0			; 
0fd0			;       ld b,16 
0fd0			;       xor a 
0fd0			;         add hl,hl 
0fd0			;         rla 
0fd0			;         cp c 
0fd0			;         jr c,$+4 
0fd0			;           inc l 
0fd0			;           sub c 
0fd0			;         djnz $-7 
0fd0			 
0fd0			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fd0			 
0fd0			addatohl: 
0fd0 85			    add   a, l    ; A = A+L 
0fd1 6f			    ld    l, a    ; L = A+L 
0fd2 8c			    adc   a, h    ; A = A+L+H+carry 
0fd3 95			    sub   l       ; A = H+carry 
0fd4 67			    ld    h, a    ; H = H+carry 
0fd5 c9			ret 
0fd6			 
0fd6			addatode: 
0fd6 83			    add   a, e    ; A = A+L 
0fd7 5f			    ld    e, a    ; L = A+L 
0fd8 8a			    adc   a, d    ; A = A+L+H+carry 
0fd9 93			    sub   e       ; A = H+carry 
0fda 57			    ld    d, a    ; H = H+carry 
0fdb c9			ret 
0fdc			 
0fdc			 
0fdc			addatobc: 
0fdc 81			    add   a, c    ; A = A+L 
0fdd 4f			    ld    c, a    ; L = A+L 
0fde 88			    adc   a, b    ; A = A+L+H+carry 
0fdf 91			    sub   c       ; A = H+carry 
0fe0 47			    ld    b, a    ; H = H+carry 
0fe1 c9			ret 
0fe2			 
0fe2			subafromhl: 
0fe2			   ; If A=0 do nothing 
0fe2			    ; Otherwise flip A's sign. Since 
0fe2			    ; the upper byte becomes -1, also 
0fe2			    ; substract 1 from H. 
0fe2 ed 44		    neg 
0fe4 ca ed 0f		    jp    z, Skip 
0fe7 25			    dec   h 
0fe8			     
0fe8			    ; Now add the low byte as usual 
0fe8			    ; Two's complement takes care of 
0fe8			    ; ensuring the result is correct 
0fe8 85			    add   a, l 
0fe9 6f			    ld    l, a 
0fea 8c			    adc   a, h 
0feb 95			    sub   l 
0fec 67			    ld    h, a 
0fed			Skip: 
0fed c9				ret 
0fee			 
0fee			 
0fee			; compare hl and de 
0fee			; returns:  
0fee			; if hl = de, z=1, s=0, c0=0 
0fee			; if hl > de, z=0, s=0, c=0 
0fee			; if hl < de, z=0, s=1, c=1 
0fee			cmp16:	 
0fee b7				or a 
0fef ed 52			sbc hl,de 
0ff1 e0				ret po 
0ff2 7c				ld a,h 
0ff3 1f				rra 
0ff4 ee 40			xor 01000000B 
0ff6 37				scf 
0ff7 8f				adc a,a 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; test if hl contains zero   - A is destroyed 
0ff9			 
0ff9			ishlzero:    
0ff9 b7				or a     ; reset flags 
0ffa 7c				ld a, h 
0ffb b5				or l        	 
0ffc			 
0ffc c9				ret 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			if FORTH_ENABLE_FLOATMATH 
0ffd			;include "float/bbcmath.z80" 
0ffd			include "float/lpfpcalc.asm" 
0ffd			endif 
0ffd			 
0ffd			 
0ffd			; eof 
0ffd			 
# End of file firmware_maths.asm
0ffd			include "firmware_strings.asm"   ; string handling  
0ffd			 
0ffd			 
0ffd			; TODO string len 
0ffd			; input text string, end on cr with zero term 
0ffd			; a offset into frame buffer to start prompt 
0ffd			; d is max length 
0ffd			; e is display size TODO 
0ffd			; c is current cursor position 
0ffd			; hl is ptr to where string will be stored 
0ffd			 
0ffd			 
0ffd			; TODO check limit of buffer for new inserts 
0ffd			; TODO check insert does not push beyond buffer 
0ffd			; TODO scroll in a limited display area 
0ffd			; TODO scroll whole screen on page wrap 
0ffd			 
0ffd			 
0ffd			; TODO handle KEY_PREVWORD 
0ffd			; TODO handle KEY_NEXTWORD 
0ffd			; TODO handle KEY_HOME 
0ffd			; TODO handle KEY_END 
0ffd			; TODO use LCD cursor? 
0ffd			 
0ffd 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
1000 81					add c 
1001 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1004 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1007 79					ld a, c 
1008 cd d0 0f				call addatohl 
100b 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 63 fe			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1016 7b					ld a,e 
1017 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a					 
101a					 
101a			 
101a			;		ld a,(input_ptr) 
101a			;		ld (input_under_cursor),a 	; save what is under the cursor 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 be fb				ld hl, cursor_shape 
101d 3e ff				ld a, 255 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 0f				ld a, CUR_BLINK_RATE 
1026 32 5d fe				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 5c fe				ld (input_cur_onoff),a 
102e			 
102e			;	if DEBUG_INPUT 
102e			;		push af 
102e			;		ld a, 'I' 
102e			;		ld (debug_mark),a 
102e			;		pop af 
102e			;		CALLMONITOR 
102e			;	endif 
102e			.is1:		; main entry loop 
102e			 
102e			 
102e			 
102e					; pause 1ms 
102e			 
102e 3e 01				ld a, 1 
1030 cd c4 0c				call aDelayInMS 
1033			 
1033					; dec flash counter 
1033 3a 5d fe				ld a, (input_cur_flash) 
1036 3d					dec a 
1037 32 5d fe				ld (input_cur_flash), a 
103a fe 00				cp 0 
103c 20 0d				jr nz, .nochgstate 
103e			 
103e			 
103e					; change state 
103e 3a 5c fe				ld a,(input_cur_onoff) 
1041 ed 44				neg 
1043 32 5c fe				ld (input_cur_onoff),a 
1046			 
1046			 
1046					; reset on change of state 
1046 3e 0f				ld a, CUR_BLINK_RATE 
1048 32 5d fe				ld (input_cur_flash), a 
104b			 
104b			.nochgstate: 
104b					 
104b					 
104b			 
104b					; display cursor  
104b			 
104b			;		ld hl, (input_start) 
104b			;		ld a, (input_cursor) 
104b			;		call addatohl 
104b			 
104b					; get char under cursor and replace with cursor 
104b 2a 66 fe		ld hl, (input_ptr) 
104e			;		ld a, (hl) 
104e			;		ld (input_under_cursor),a 
104e			;		ld a, '_' 
104e			;		ld (hl), a 
104e			 
104e					; display string 
104e			 
104e ed 5b 64 fe			ld de, (input_start) 
1052 3a 61 fe				ld a, (input_at_pos) 
1055 cd af 0d				call str_at_display 
1058			;	        call update_display 
1058			 
1058					; find place to put the cursor 
1058			;		add h 
1058			;		ld l, display_row_1 
1058			;		sub l 
1058			; (input_at_pos) 
1058					;ld c, a 
1058			;		ld a, (input_cursor) 
1058			;		ld l, (input_at_pos) 
1058			;		;ld b, h 
1058			;		add l 
1058			;		ld (input_at_cursor),a 
1058					;ld l,h 
1058			 
1058			;		ld h, 0 
1058			;		ld l,(input_at_pos) 
1058			;		ld a, (input_cursor) 
1058			;		call addatohl 
1058			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1058			;		call subafromhl 
1058			;		ld a,l 
1058			;		ld (input_at_cursor), a 
1058			 
1058				if DEBUG_INPUT 
1058					ld a, (hardware_diag) 
1058					cp 0 
1058					jr z, .skip_input_diag 
1058			 
1058					ld a,(input_at_pos) 
1058					ld hl, LFSRSeed 
1058					call hexout 
1058					ld a, (input_cursor) 
1058					ld hl, LFSRSeed+2 
1058					call hexout 
1058					ld a,(input_at_cursor) 
1058					ld hl, LFSRSeed+4 
1058					call hexout 
1058			 
1058					ld a,(input_cur_onoff) 
1058					ld hl, LFSRSeed+6 
1058					call hexout 
1058			 
1058					ld a,(input_cur_flash) 
1058					ld hl, LFSRSeed+8 
1058					call hexout 
1058			 
1058					ld a,(input_len) 
1058					ld hl, LFSRSeed+10 
1058					call hexout 
1058					ld hl, LFSRSeed+12 
1058					ld a, 0 
1058					ld (hl),a 
1058					ld a, display_row_4 
1058					ld de, LFSRSeed 
1058					call str_at_display 
1058					.skip_input_diag: 
1058				endif 
1058			 
1058					; decide on if we are showing the cursor this time round 
1058			 
1058 3a 5c fe				ld a, (input_cur_onoff) 
105b fe ff				cp 255 
105d 28 13				jr z, .skipcur 
105f			 
105f			 
105f 3a 5f fe				ld a,(input_at_cursor) 
1062 11 be fb				ld de, cursor_shape 
1065 cd af 0d				call str_at_display 
1068			 
1068					; save length of current input string 
1068 2a 64 fe				ld hl, (input_start) 
106b cd 2e 14				call strlenz 
106e 7d					ld a,l 
106f 32 57 fe				ld (input_len),a 
1072			 
1072			.skipcur: 
1072			 
1072 cd bf 0d			        call update_display 
1075					 
1075			 
1075			 
1075					; wait 
1075				 
1075					; TODO loop without wait to flash the cursor and char under cursor	 
1075 cd d5 79				call cin    ; _wait 
1078			 
1078 fe 00				cp 0 
107a ca 2e 10				jp z, .is1 
107d			 
107d					; get ptr to char to input into 
107d			 
107d 4f					ld c,a 
107e 2a 64 fe				ld hl, (input_start) 
1081 3a 52 fe				ld a, (input_cursor) 
1084 cd d0 0f				call addatohl 
1087 22 66 fe				ld (input_ptr), hl 
108a 79					ld a,c 
108b			 
108b					; replace char under cursor 
108b			 
108b			;		ld hl, (input_ptr) 
108b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108b			;		ld (hl), a 
108b			 
108b			;	if DEBUG_INPUT 
108b			;		push af 
108b			;		ld a, 'i' 
108b			;		ld (debug_mark),a 
108b			;		pop af 
108b			;		CALLMONITOR 
108b			;	endif 
108b fe 0e				cp KEY_HOME 
108d 20 0e				jr nz, .iske 
108f			 
108f 3a 61 fe				ld a, (input_at_pos) 
1092 32 5f fe				ld (input_at_cursor),a 
1095 3e 00				ld a, 0 
1097 32 52 fe				ld (input_cursor), a 
109a c3 2e 10				jp .is1 
109d					 
109d fe 0f		.iske:		cp KEY_END 
109f 20 03				jr nz, .isknw 
10a1 c3 2e 10				jp .is1 
10a4			 
10a4 fe 06		.isknw:		cp KEY_NEXTWORD 
10a6 20 1b				jr nz, .iskpw 
10a8			 
10a8 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10ab 7e					ld a,(hl)	 
10ac fe 00				cp 0 
10ae ca 2e 10				jp z, .is1    ; end of string 
10b1 fe 20				cp ' ' 
10b3 ca 2e 10				jp z, .is1    ; end of word 
10b6 23					inc hl 
10b7 22 66 fe				ld (input_ptr), hl 
10ba 3a 5f fe				ld a, (input_at_cursor) 
10bd 3c					inc a 
10be 32 5f fe				ld (input_at_cursor), a 
10c1 18 e5				jr .isknwm 
10c3			 
10c3 fe 07		.iskpw:		cp KEY_PREVWORD 
10c5 20 1b				jr nz, .iskl 
10c7			.iskpwm:	 
10c7 2a 66 fe				ld hl, (input_ptr) 
10ca 7e					ld a,(hl)	 
10cb fe 00				cp 0  
10cd ca 2e 10				jp z, .is1    ; end of string 
10d0 fe 20				cp ' ' 
10d2 ca 2e 10				jp z, .is1    ; end of word 
10d5 2b					dec hl 
10d6 22 66 fe				ld (input_ptr), hl 
10d9 3a 5f fe				ld a, (input_at_cursor) 
10dc 3d					dec a 
10dd 32 5f fe				ld (input_at_cursor), a 
10e0 18 e5				jr .iskpwm 
10e2			 
10e2			 
10e2 fe 0b		.iskl:		cp KEY_LEFT 
10e4 20 27				jr nz, .isk1 
10e6			 
10e6 3a 52 fe				ld a, (input_cursor) 
10e9			 
10e9 fe 00				cp 0 
10eb ca 2e 10				jp z, .is1 		; at start of line to ignore  
10ee			 
10ee 3d					dec  a 		; TODO check underflow 
10ef 32 52 fe				ld (input_cursor), a 
10f2			 
10f2 2a 66 fe				ld hl, (input_ptr) 
10f5 2b					dec hl 
10f6 22 66 fe				ld (input_ptr), hl 
10f9					 
10f9 3a 5f fe				ld a, (input_at_cursor) 
10fc 3d					dec a 
10fd 32 5f fe				ld (input_at_cursor), a 
1100			 
1100 3e 01				ld a, 1		; show cursor moving 
1102 32 5c fe				ld (input_cur_onoff),a 
1105 3e 0f				ld a, CUR_BLINK_RATE 
1107 32 5d fe				ld (input_cur_flash), a 
110a			 
110a c3 2e 10				jp .is1 
110d			 
110d fe 0c		.isk1:		cp KEY_RIGHT 
110f 20 2a				jr nz, .isk2 
1111			 
1111 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1114 5f					ld e,a 
1115 3a 52 fe				ld a, (input_cursor) 
1118 bb					cp e 
1119 ca 2e 10				jp z, .is1		; at the end of string so dont go right 
111c			 
111c 3c					inc  a 		; TODO check overflow 
111d 32 52 fe				ld (input_cursor), a 
1120			 
1120 3a 5f fe				ld a, (input_at_cursor) 
1123 3c					inc a 
1124 32 5f fe				ld (input_at_cursor), a 
1127			 
1127 2a 66 fe				ld hl, (input_ptr) 
112a 23					inc hl 
112b 22 66 fe				ld (input_ptr), hl 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5c fe				ld (input_cur_onoff),a 
1133 3e 0f				ld a, CUR_BLINK_RATE 
1135 32 5d fe				ld (input_cur_flash), a 
1138			 
1138 c3 2e 10				jp .is1 
113b			 
113b fe 05		.isk2:		cp KEY_UP 
113d			 
113d 20 26				jr nz, .isk3 
113f			 
113f					; swap last command with the current on 
113f			 
113f					; move cursor to start of string 
113f 2a 64 fe				ld hl, (input_start) 
1142 22 66 fe				ld (input_ptr), hl 
1145			 
1145 3a 61 fe				ld a, (input_at_pos) 
1148 32 5f fe				ld (input_at_cursor), a 
114b			 
114b 3e 00				ld a, 0 
114d 32 52 fe				ld (input_cursor), a 
1150					 
1150					; swap input and last command buffers 
1150			 
1150 21 e5 f4				ld hl, os_cli_cmd 
1153 11 e4 f5				ld de, os_last_cmd 
1156 06 ff				ld b, 255 
1158 7e			.swap1:		ld a, (hl) 
1159 4f					ld c,a 
115a 1a					ld a, (de) 
115b 77					ld (hl), a 
115c 79					ld a,c 
115d 12					ld (de),a 
115e 23					inc hl 
115f 13					inc de 
1160 10 f6				djnz .swap1 
1162			 
1162			 
1162			 
1162			 
1162			 
1162 c3 2e 10				jp .is1 
1165			 
1165 fe 08		.isk3:		cp KEY_BS 
1167 20 3c				jr nz, .isk4 
1169			 
1169 3a 52 fe				ld a, (input_cursor) 
116c			 
116c fe 00				cp 0 
116e ca 2e 10				jp z, .is1 		; at start of line to ignore  
1171			 
1171 3d					dec  a 		; TODO check underflow 
1172 32 52 fe				ld (input_cursor), a 
1175			 
1175					; hl is source 
1175					; de needs to be source - 1 
1175			 
1175			;		ld a, 0 
1175			;		dec hl 
1175			;		ld (hl), a 
1175			 
1175 2a 66 fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 22 66 fe				ld (input_ptr), hl 
117c			 
117c					; shift all data 
117c			 
117c e5					push hl 
117d 23					inc hl 
117e d1					pop de 
117f 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1182 4f					ld c,a 
1183 06 00				ld b,0 
1185 ed b0				ldir  
1187			 
1187			 
1187			 
1187			 
1187 3a 5f fe				ld a, (input_at_cursor) 
118a 3d					dec a 
118b 32 5f fe				ld (input_at_cursor), a 
118e			 
118e			 
118e 3e 01				ld a, 1		; show cursor moving 
1190 32 5c fe				ld (input_cur_onoff),a 
1193 3e 0f				ld a, CUR_BLINK_RATE 
1195 32 5d fe				ld (input_cur_flash), a 
1198			 
1198					; remove char 
1198 3a 5f fe				ld a, (input_at_cursor) 
119b 3c					inc a 
119c 11 26 12				ld de,.iblank 
119f cd af 0d				call str_at_display 
11a2			 
11a2 c3 2e 10				jp .is1 
11a5			 
11a5 fe 0d		.isk4:		cp KEY_CR 
11a7 28 6c				jr z, .endinput 
11a9			 
11a9					; else add the key press to the end 
11a9			 
11a9 4f					ld c, a			; save key pressed 
11aa			 
11aa 7e					ld a,(hl)		; get what is currently under char 
11ab			 
11ab fe 00				cp 0			; we are at the end of the string 
11ad 20 2f				jr nz, .onchar 
11af					 
11af					; add a char to the end of the string 
11af				 
11af 71					ld (hl),c 
11b0 23					inc hl 
11b1			;		ld a,' ' 
11b1			;		ld (hl),a 
11b1			;		inc hl 
11b1 3e 00				ld a,0 
11b3 77					ld (hl),a 
11b4 2b					dec hl 
11b5			 
11b5 3a 52 fe				ld a, (input_cursor) 
11b8 3c					inc a				; TODO check max string length and scroll  
11b9 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bc							 
11bc 3a 5f fe				ld a, (input_at_cursor) 
11bf 3c					inc a 
11c0 32 5f fe				ld (input_at_cursor), a 
11c3			 
11c3 2a 66 fe				ld hl, (input_ptr) 
11c6 23					inc hl 
11c7 22 66 fe				ld (input_ptr), hl 
11ca			 
11ca 2a 66 fe				ld hl, (input_ptr) 
11cd 23					inc hl 
11ce 22 66 fe				ld (input_ptr), hl 
11d1			;	if DEBUG_INPUT 
11d1			;		push af 
11d1			;		ld a, '+' 
11d1			;		ld (debug_mark),a 
11d1			;		pop af 
11d1			;		CALLMONITOR 
11d1			;	endif 
11d1 3e 01				ld a, 1		; show cursor moving 
11d3 32 5c fe				ld (input_cur_onoff),a 
11d6 3e 0f				ld a, CUR_BLINK_RATE 
11d8 32 5d fe				ld (input_cur_flash), a 
11db c3 2e 10				jp .is1 
11de					 
11de			 
11de			 
11de					; if on a char then insert 
11de			.onchar: 
11de			 
11de					; TODO over flow check: make sure insert does not blow out buffer 
11de			 
11de					; need to do some maths to use lddr 
11de			 
11de e5					push hl   ; save char pos 
11df c5					push bc 
11e0			 
11e0 2a 64 fe				ld hl, (input_start) 
11e3 3a 57 fe				ld a, (input_len) 
11e6 cd d0 0f				call addatohl  		; end of string 
11e9 23					inc hl 
11ea 23					inc hl		; past zero term 
11eb e5					push hl 
11ec 23					inc hl 
11ed e5					push hl  
11ee			 
11ee								; start and end of lddr set, now how much to move? 
11ee			 
11ee							 
11ee 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f1 47					ld b,a 
11f2 3a 57 fe				ld a,(input_len) 
11f5 5f					ld e,a 
11f6 90					sub b 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9 3c					inc a		;?? 
11fa			 
11fa 06 00				ld b,0 
11fc 4f					ld c,a 
11fd			 
11fd				if DEBUG_INPUT 
11fd					push af 
11fd					ld a, 'i' 
11fd					ld (debug_mark),a 
11fd					pop af 
11fd			;		CALLMONITOR 
11fd				endif 
11fd d1					pop de 
11fe e1					pop hl 
11ff				if DEBUG_INPUT 
11ff					push af 
11ff					ld a, 'I' 
11ff					ld (debug_mark),a 
11ff					pop af 
11ff			;		CALLMONITOR 
11ff				endif 
11ff ed b8				lddr 
1201				 
1201			 
1201			 
1201					; TODO have a key for insert/overwrite mode???? 
1201 c1					pop bc 
1202 e1					pop hl 
1203 71					ld (hl), c		; otherwise overwrite current char 
1204					 
1204			 
1204			 
1204			 
1204 3a 52 fe				ld a, (input_cursor) 
1207 3c					inc  a 		; TODO check overflow 
1208 32 52 fe				ld (input_cursor), a 
120b			 
120b 3a 5f fe				ld a, (input_at_cursor) 
120e 3c					inc a 
120f 32 5f fe				ld (input_at_cursor), a 
1212			 
1212 c3 2e 10				jp .is1 
1215			 
1215			.endinput:	; TODO look for end of string 
1215			 
1215					; add trailing space for end of token 
1215			 
1215 2a 64 fe				ld hl, (input_start) 
1218 3a 57 fe				ld a,(input_len) 
121b cd d0 0f				call addatohl 
121e 3e 20				ld a, ' ' 
1220 77					ld (hl),a 
1221					; TODO eof of parse marker 
1221			 
1221 23					inc hl 
1222 3e 00				ld a, 0 
1224 77					ld (hl),a 
1225			 
1225			 
1225 c9					ret 
1226			 
1226 .. 00		.iblank: db " ",0 
1228			 
1228			 
1228 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122b 22 64 fe				ld (input_start), hl 
122e 3e 01				ld a,1			; add cursor 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235 22 66 fe				ld (input_ptr), hl 
1238 7a					ld a,d 
1239 32 63 fe				ld (input_size), a 
123c 3e 00				ld a,0 
123e 32 52 fe				ld (input_cursor),a 
1241			.instr1:	 
1241			 
1241					; TODO do block cursor 
1241					; TODO switch cursor depending on the modifer key 
1241			 
1241					; update cursor shape change on key hold 
1241			 
1241 2a 66 fe				ld hl, (input_ptr) 
1244 2b					dec hl 
1245 3a be fb				ld a,(cursor_shape) 
1248 77					ld (hl), a 
1249			 
1249					; display entered text 
1249 3a 61 fe				ld a,(input_at_pos) 
124c cd 99 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124f ed 5b 64 fe	            	LD   de, (input_start) 
1253 cd bb 77		            	CALL fLCD_Str       ;Display string pointed to by DE 
1256			 
1256 cd d5 79				call cin 
1259 fe 00				cp 0 
125b 28 e4				jr z, .instr1 
125d			 
125d					; proecess keyboard controls first 
125d			 
125d 2a 66 fe				ld hl,(input_ptr) 
1260			 
1260 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1262 28 5a				jr z, .instrcr 
1264			 
1264 fe 08				cp KEY_BS 	; back space 
1266 20 0f				jr nz, .instr2 
1268					; process back space 
1268			 
1268					; TODO stop back space if at start of string 
1268 2b					dec hl 
1269 2b					dec hl ; to over write cursor 
126a 3a be fb				ld a,(cursor_shape) 
126d					;ld a,0 
126d 77					ld (hl),a 
126e 23					inc hl 
126f 3e 20				ld a," " 
1271 77					ld (hl),a 
1272 22 66 fe				ld (input_ptr),hl 
1275					 
1275			 
1275 18 ca				jr .instr1 
1277			 
1277 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1279 20 06				jr nz, .instr3 
127b 2b					dec hl 
127c 22 66 fe				ld (input_ptr),hl 
127f 18 c0				jr .instr1 
1281				 
1281 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1283 20 06				jr nz, .instr4 
1285 23					inc hl 
1286 22 66 fe				ld (input_ptr),hl 
1289 18 b6				jr .instr1 
128b			 
128b fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128d 20 06				jr nz, .instr5 
128f 2b					dec hl 
1290 22 66 fe				ld (input_ptr),hl 
1293 18 ac				jr .instr1 
1295			 
1295 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1297 20 06				jr nz, .instr6 
1299 2b					dec hl 
129a 22 66 fe				ld (input_ptr),hl 
129d 18 a2				jr .instr1 
129f fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a1 20 0b				jr nz, .instrnew 
12a3			 
12a3 21 be f1			ld hl, scratch 
12a6 11 e4 f5			ld de, os_last_cmd 
12a9 cd c7 12			call strcpy 
12ac 18 93				jr .instr1 
12ae			 
12ae			 
12ae			.instrnew:	; no special key pressed to see if we have room to store it 
12ae			 
12ae					; TODO do string size test 
12ae			 
12ae 2b					dec hl ; to over write cursor 
12af 77					ld (hl),a 
12b0 23					inc hl 
12b1 3a be fb				ld a,(cursor_shape) 
12b4 77					ld (hl),a 
12b5 23					inc hl 
12b6 3e 00				ld a,0 
12b8 77					ld (hl),a 
12b9			 
12b9 22 66 fe				ld (input_ptr),hl 
12bc					 
12bc 18 83				jr .instr1 
12be 2b			.instrcr:	dec hl		; remove cursor 
12bf 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c1 77					ld (hl),a 
12c2 23					inc hl 
12c3 3e 00				ld a,0 
12c5 77					ld (hl),a 
12c6			 
12c6			 
12c6					; if at end of line scroll up    
12c6					; TODO detecting only end of line 4 for scroll up  
12c6			 
12c6					;ld   
12c6			 
12c6 c9					ret 
12c7			 
12c7			 
12c7			; strcpy hl = dest, de source 
12c7			 
12c7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c8 b7			            OR   A              ;Null terminator? 
12c9 c8			            RET  Z              ;Yes, so finished 
12ca 1a					ld a,(de) 
12cb 77					ld (hl),a 
12cc 13			            INC  DE             ;Point to next character 
12cd 23					inc hl 
12ce 18 f7		            JR   strcpy       ;Repeat 
12d0 c9					ret 
12d1			 
12d1			 
12d1			; TODO string_at  
12d1			; pass string which starts with lcd offset address and then null term string 
12d1			 
12d1			; TODO string to dec 
12d1			; TODO string to hex 
12d1			; TODO byte to string hex 
12d1			; TODO byte to string dec 
12d1			 
12d1			 
12d1			 
12d1			; from z80uartmonitor 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d1			; pass hl for where to put the text 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1 c5			hexout:	PUSH BC 
12d2 f5					PUSH AF 
12d3 47					LD B, A 
12d4					; Upper nybble 
12d4 cb 3f				SRL A 
12d6 cb 3f				SRL A 
12d8 cb 3f				SRL A 
12da cb 3f				SRL A 
12dc cd ec 12				CALL tohex 
12df 77					ld (hl),a 
12e0 23					inc hl	 
12e1					 
12e1					; Lower nybble 
12e1 78					LD A, B 
12e2 e6 0f				AND 0FH 
12e4 cd ec 12				CALL tohex 
12e7 77					ld (hl),a 
12e8 23					inc hl	 
12e9					 
12e9 f1					POP AF 
12ea c1					POP BC 
12eb c9					RET 
12ec					 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			tohex: 
12ec e5					PUSH HL 
12ed d5					PUSH DE 
12ee 16 00				LD D, 0 
12f0 5f					LD E, A 
12f1 21 f9 12				LD HL, .DATA 
12f4 19					ADD HL, DE 
12f5 7e					LD A, (HL) 
12f6 d1					POP DE 
12f7 e1					POP HL 
12f8 c9					RET 
12f9			 
12f9			.DATA: 
12f9 30					DEFB	30h	; 0 
12fa 31					DEFB	31h	; 1 
12fb 32					DEFB	32h	; 2 
12fc 33					DEFB	33h	; 3 
12fd 34					DEFB	34h	; 4 
12fe 35					DEFB	35h	; 5 
12ff 36					DEFB	36h	; 6 
1300 37					DEFB	37h	; 7 
1301 38					DEFB	38h	; 8 
1302 39					DEFB	39h	; 9 
1303 41					DEFB	41h	; A 
1304 42					DEFB	42h	; B 
1305 43					DEFB	43h	; C 
1306 44					DEFB	44h	; D 
1307 45					DEFB	45h	; E 
1308 46					DEFB	46h	; F 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1309			;;    subtract $30, if result > 9 then subtract $7 more 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			atohex: 
1309 d6 30				SUB $30 
130b fe 0a				CP 10 
130d f8					RET M		; If result negative it was 0-9 so we're done 
130e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1310 c9					RET		 
1311			 
1311			 
1311			 
1311			 
1311			; Get 2 ASCII characters as hex byte from pointer in hl 
1311			 
1311			BYTERD: 
1311 16 00			LD	D,00h		;Set up 
1313 cd 1b 13			CALL	HEXCON		;Get byte and convert to hex 
1316 87				ADD	A,A		;First nibble so 
1317 87				ADD	A,A		;multiply by 16 
1318 87				ADD	A,A		; 
1319 87				ADD	A,A		; 
131a 57				LD	D,A		;Save hi nibble in D 
131b			HEXCON: 
131b 7e				ld a, (hl)		;Get next chr 
131c 23				inc hl 
131d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131f fe 0a			CP	00Ah		;Is it 0-9 ? 
1321 38 02			JR	C,NALPHA	;If so miss next bit 
1323 d6 07			SUB	007h		;Else convert alpha 
1325			NALPHA: 
1325 b2				OR	D		;Add hi nibble back 
1326 c9				RET			; 
1327			 
1327			 
1327			; 
1327			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1327			; Since the routines get_byte and therefore get_nibble are called, only valid 
1327			; characters (0-9a-f) are accepted. 
1327			; 
1327			;get_word        push    af 
1327			;                call    get_byte        ; Get the upper byte 
1327			;                ld      h, a 
1327			;                call    get_byte        ; Get the lower byte 
1327			;                ld      l, a 
1327			;                pop     af 
1327			;                ret 
1327			; 
1327			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1327			; the routine get_nibble is used only valid characters are accepted - the  
1327			; input routine only accepts characters 0-9a-f. 
1327			; 
1327 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1328 7e					ld a,(hl) 
1329 23					inc hl 
132a cd 4f 13		                call    nibble2val      ; Get upper nibble 
132d cb 07		                rlc     a 
132f cb 07		                rlc     a 
1331 cb 07		                rlc     a 
1333 cb 07		                rlc     a 
1335 47			                ld      b, a            ; Save upper four bits 
1336 7e					ld a,(hl) 
1337 cd 4f 13		                call    nibble2val      ; Get lower nibble 
133a b0			                or      b               ; Combine both nibbles 
133b c1			                pop     bc              ; Restore B (and C) 
133c c9			                ret 
133d			; 
133d			; Get a hexadecimal digit from the serial line. This routine blocks until 
133d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133d			; to the serial line interface. The lower 4 bits of A contain the value of  
133d			; that particular digit. 
133d			; 
133d			;get_nibble      ld a,(hl)           ; Read a character 
133d			;                call    to_upper        ; Convert to upper case 
133d			;                call    is_hex          ; Was it a hex digit? 
133d			;                jr      nc, get_nibble  ; No, get another character 
133d			 ;               call    nibble2val      ; Convert nibble to value 
133d			 ;               call    print_nibble 
133d			 ;               ret 
133d			; 
133d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133d			; A valid hexadecimal digit is denoted by a set C flag. 
133d			; 
133d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133d			;                ret     nc              ; Yes 
133d			;                cp      '0'             ; Less than '0'? 
133d			;                jr      nc, is_hex_1    ; No, continue 
133d			;                ccf                     ; Complement carry (i.e. clear it) 
133d			;                ret 
133d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133d			;                ret     c               ; Yes 
133d			;                cp      'A'             ; Less than 'A'? 
133d			;                jr      nc, is_hex_2    ; No, continue 
133d			;                ccf                     ; Yes - clear carry and return 
133d			;                ret 
133d			;is_hex_2        scf                     ; Set carry 
133d			;                ret 
133d			; 
133d			; Convert a single character contained in A to upper case: 
133d			; 
133d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133f d8			                ret     c 
1340 fe 7b		                cp      'z' + 1         ; > 'z'? 
1342 d0			                ret     nc              ; Nothing to do, either 
1343 e6 5f		                and     $5f             ; Convert to upper case 
1345 c9			                ret 
1346			 
1346			 
1346			to_lower: 
1346			 
1346			   ; if char is in [A-Z] make it lower case 
1346			 
1346			   ; enter : a = char 
1346			   ; exit  : a = lower case char 
1346			   ; uses  : af 
1346			 
1346 fe 41		   cp 'A' 
1348 d8			   ret c 
1349			    
1349 fe 5b		   cp 'Z'+1 
134b d0			   ret nc 
134c			    
134c f6 20		   or $20 
134e c9			   ret 
134f			 
134f			; 
134f			; Expects a hexadecimal digit (upper case!) in A and returns the 
134f			; corresponding value in A. 
134f			; 
134f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1351 38 02		                jr      c, nibble2val_1 ; Yes 
1353 d6 07		                sub     7               ; Adjust for A-F 
1355 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1357 e6 0f		                and     $f              ; Only return lower 4 bits 
1359 c9			                ret 
135a			; 
135a			; Print_nibble prints a single hex nibble which is contained in the lower  
135a			; four bits of A: 
135a			; 
135a			;print_nibble    push    af              ; We won't destroy the contents of A 
135a			;                and     $f              ; Just in case... 
135a			;                add     a, '0'             ; If we have a digit we are done here. 
135a			;                cp      '9' + 1         ; Is the result > 9? 
135a			;                jr      c, print_nibble_1 
135a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
135a			;print_nibble_1  call    putc            ; Print the nibble and 
135a			;                pop     af              ; restore the original value of A 
135a			;                ret 
135a			;; 
135a			;; Send a CR/LF pair: 
135a			; 
135a			;crlf            push    af 
135a			;                ld      a, cr 
135a			;                call    putc 
135a			;                ld      a, lf 
135a			;                call    putc 
135a			;                pop     af 
135a			;                ret 
135a			; 
135a			; Print_word prints the four hex digits of a word to the serial line. The  
135a			; word is expected to be in HL. 
135a			; 
135a			;print_word      push    hl 
135a			;                push    af 
135a			;                ld      a, h 
135a			;                call    print_byte 
135a			;                ld      a, l 
135a			;                call    print_byte 
135a			;                pop     af 
135a			;                pop     hl 
135a			;                ret 
135a			; 
135a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
135a			; The byte to be printed is expected to be in A. 
135a			; 
135a			;print_byte      push    af              ; Save the contents of the registers 
135a			;                push    bc 
135a			;                ld      b, a 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                call    print_nibble    ; Print high nibble 
135a			;                ld      a, b 
135a			;                call    print_nibble    ; Print low nibble 
135a			;                pop     bc              ; Restore original register contents 
135a			;                pop     af 
135a			;                ret 
135a			 
135a			 
135a			 
135a			 
135a			 
135a			fourehexhl:  
135a 7e				ld a,(hl) 
135b cd 09 13			call atohex 
135e cb 3f				SRL A 
1360 cb 3f				SRL A 
1362 cb 3f				SRL A 
1364 cb 3f				SRL A 
1366 47				ld b, a 
1367 23				inc hl 
1368 7e				ld a,(hl) 
1369 23				inc hl 
136a cd 09 13			call atohex 
136d 80				add b 
136e 57				ld d,a 
136f 7e				ld a,(hl) 
1370 cd 09 13			call atohex 
1373 cb 3f				SRL A 
1375 cb 3f				SRL A 
1377 cb 3f				SRL A 
1379 cb 3f				SRL A 
137b 47				ld b, a 
137c 23				inc hl 
137d 7e				ld a,(hl) 
137e 23				inc hl 
137f cd 09 13			call atohex 
1382 80				add b 
1383 5f				ld e, a 
1384 d5				push de 
1385 e1				pop hl 
1386 c9				ret 
1387			 
1387			; pass hl. returns z set if the byte at hl is a digit 
1387			;isdigithl:  
1387			;	push bc 
1387			;	ld a,(hl) 
1387			;	cp ':' 
1387			;	jr nc, .isdf 		; > 
1387			;	cp '0' 
1387			;	jr c, .isdf		; < 
1387			; 
1387			;	; TODO find a better way to set z 
1387			; 
1387			;	ld b,a 
1387			;	cp b 
1387			;	pop bc 
1387			;	ret 
1387			; 
1387			;.isdf:	; not digit so clear z 
1387			; 
1387			;	; TODO find a better way to unset z 
1387			; 
1387			;	ld b,a 
1387			;	inc b 
1387			;	cp b 
1387			; 
1387			;	pop bc 
1387			;	ret 
1387				 
1387				 
1387			 
1387			 
1387			; pass hl as the four byte address to load 
1387			 
1387			get_word_hl:  
1387 e5				push hl 
1388 cd 27 13			call get_byte 
138b				 
138b 47				ld b, a 
138c			 
138c e1				pop hl 
138d 23				inc hl 
138e 23				inc hl 
138f			 
138f			; TODO not able to handle a-f  
138f 7e				ld a,(hl) 
1390			;	;cp ':' 
1390			;	cp 'g' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp 'G' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp '0' 
1390			;	jr c, .single_byte_hl		; < 
1390			 
1390				;call isdigithl 
1390 fe 00			cp 0 
1392 28 06			jr z, .single_byte_hl 
1394			 
1394			.getwhln:   ; hex word so get next byte 
1394			 
1394 cd 27 13			call get_byte 
1397 6f				ld l, a 
1398 60				ld h,b 
1399 c9				ret 
139a 68			.single_byte_hl:   ld l,b 
139b 26 00				ld h,0 
139d c9					ret 
139e			 
139e			 
139e			 
139e			 
139e 21 f5 1d			ld hl,asc+1 
13a1			;	ld a, (hl) 
13a1			;	call nibble2val 
13a1 cd 27 13			call get_byte 
13a4			 
13a4			;	call fourehexhl 
13a4 32 f2 f1			ld (scratch+52),a 
13a7				 
13a7 21 f0 f1			ld hl,scratch+50 
13aa 22 e1 f4			ld (os_cur_ptr),hl 
13ad			 
13ad c9				ret 
13ae			 
13ae			 
13ae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ae			 
13ae			; Decimal Unsigned Version 
13ae			 
13ae			;Number in a to decimal ASCII 
13ae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ae			;Example: display a=56 as "056" 
13ae			;input: a = number 
13ae			;Output: a=0,value of a in the screen 
13ae			;destroys af,bc (don't know about hl and de) 
13ae			DispAToASCII: 
13ae 0e 9c			ld	c,-100 
13b0 cd ba 13			call	.Na1 
13b3 0e f6			ld	c,-10 
13b5 cd ba 13			call	.Na1 
13b8 0e ff			ld	c,-1 
13ba 06 2f		.Na1:	ld	b,'0'-1 
13bc 04			.Na2:	inc	b 
13bd 81				add	a,c 
13be 38 fc			jr	c,.Na2 
13c0 91				sub	c		;works as add 100/10/1 
13c1 f5				push af		;safer than ld c,a 
13c2 78				ld	a,b		;char is in b 
13c3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c3 f1				pop af		;safer than ld a,c 
13c4 c9				ret 
13c5			 
13c5			; Decimal Signed Version 
13c5			 
13c5			; DispA 
13c5			; -------------------------------------------------------------- 
13c5			; Converts a signed integer value to a zero-terminated ASCII 
13c5			; string representative of that value (using radix 10). 
13c5			; -------------------------------------------------------------- 
13c5			; INPUTS: 
13c5			;     HL     Value to convert (two's complement integer). 
13c5			;     DE     Base address of string destination. (pointer). 
13c5			; -------------------------------------------------------------- 
13c5			; OUTPUTS: 
13c5			;     None 
13c5			; -------------------------------------------------------------- 
13c5			; REGISTERS/MEMORY DESTROYED 
13c5			; AF HL 
13c5			; -------------------------------------------------------------- 
13c5			 
13c5			;DispHLToASCII: 
13c5			;   push    de 
13c5			;   push    bc 
13c5			; 
13c5			;; Detect sign of HL. 
13c5			;    bit    7, h 
13c5			;    jr     z, ._DoConvert 
13c5			; 
13c5			;; HL is negative. Output '-' to string and negate HL. 
13c5			;    ld     a, '-' 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			; 
13c5			;; Negate HL (using two's complement) 
13c5			;    xor    a 
13c5			;    sub    l 
13c5			;    ld     l, a 
13c5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c5			;    sbc    a, h 
13c5			;    ld     h, a 
13c5			; 
13c5			;; Convert HL to digit characters 
13c5			;._DoConvert: 
13c5			;    ld     b, 0     ; B will count character length of number 
13c5			;-   ld     a, 10 
13c5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c5			;    push   af 
13c5			;    inc    b 
13c5			;    ld     a, h 
13c5			;    or     l 
13c5			;    jr     nz, - 
13c5			; 
13c5			;; Retrieve digits from stack 
13c5			;-   pop    af 
13c5			;    or     $30 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			;    djnz   - 
13c5			; 
13c5			;; Terminate string with NULL 
13c5			;    xor    a 
13c5			;    ld     (de), a 
13c5			; 
13c5			;    pop    bc 
13c5			;    pop    de 
13c5			;    ret 
13c5			 
13c5			;Comments 
13c5			; 
13c5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c5			;    Note that the output string will not be fixed-width. 
13c5			; 
13c5			;Example Usage 
13c5			; 
13c5			;    ld    hl, -1004 
13c5			;    ld    de, OP1 
13c5			;    call  DispA 
13c5			;    ld    hl, OP1 
13c5			;    syscall  PutS 
13c5			 
13c5			 
13c5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c5			 
13c5			 
13c5			;Converts an ASCII string to an unsigned 16-bit integer 
13c5			;Quits when it reaches a non-decimal digit 
13c5			 
13c5			string_to_uint16: 
13c5			atoui_16: 
13c5			;Input: 
13c5			;     DE points to the string 
13c5			;Outputs: 
13c5			;     HL is the result 
13c5			;     A is the 8-bit value of the number 
13c5			;     DE points to the byte after the number 
13c5			;Destroys: 
13c5			;     BC 
13c5			;       if the string is non-empty, BC is HL/10 
13c5			;Size:  24 bytes 
13c5			;Speed: 42+d(104+{0,9}) 
13c5			;       d is the number of digits in the number 
13c5			;       max is 640 cycles for a 5 digit number 
13c5			;Assuming no leading zeros: 
13c5			;1 digit:  146cc 
13c5			;2 digit:  250cc 
13c5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c5			;avg: 544.81158447265625cc (544+13297/16384) 
13c5			;=============================================================== 
13c5 21 00 00		  ld hl,0 
13c8			.u16a: 
13c8 1a			  ld a,(de) 
13c9 d6 30		  sub 30h 
13cb fe 0a		  cp 10 
13cd d0			  ret nc 
13ce 13			  inc de 
13cf 44			  ld b,h 
13d0 4d			  ld c,l 
13d1 29			  add hl,hl 
13d2 29			  add hl,hl 
13d3 09			  add hl,bc 
13d4 29			  add hl,hl 
13d5 85			  add a,l 
13d6 6f			  ld l,a 
13d7 30 ef		  jr nc,.u16a 
13d9 24			  inc h 
13da c3 c8 13		  jp .u16a 
13dd			 
13dd			 
13dd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dd			 
13dd			;written by Zeda 
13dd			;Converts a 16-bit unsigned integer to an ASCII string. 
13dd			 
13dd			uitoa_16: 
13dd			;Input: 
13dd			;   DE is the number to convert 
13dd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dd			;Output: 
13dd			;   HL points to the null-terminated ASCII string 
13dd			;      NOTE: This isn't necessarily the same as the input HL. 
13dd d5			  push de 
13de c5			  push bc 
13df f5			  push af 
13e0 eb			  ex de,hl 
13e1			 
13e1 01 f0 d8		  ld bc,-10000 
13e4 3e 2f		  ld a,'0'-1 
13e6 3c			  inc a 
13e7 09			  add hl,bc  
13e8 38 fc		   jr c,$-2 
13ea 12			  ld (de),a 
13eb 13			  inc de 
13ec			 
13ec 01 e8 03		  ld bc,1000 
13ef 3e 3a		  ld a,'9'+1 
13f1 3d			  dec a  
13f2 09			  add hl,bc  
13f3 30 fc		   jr nc,$-2 
13f5 12			  ld (de),a 
13f6 13			  inc de 
13f7			 
13f7 01 9c ff		  ld bc,-100 
13fa 3e 2f		  ld a,'0'-1 
13fc 3c			  inc a  
13fd 09			  add hl,bc  
13fe 38 fc		   jr c,$-2 
1400 12			  ld (de),a 
1401 13			  inc de 
1402			 
1402 7d			  ld a,l 
1403 26 3a		  ld h,'9'+1 
1405 25			  dec h  
1406 c6 0a		  add a,10  
1408 30 fb		   jr nc,$-3 
140a c6 30		  add a,'0' 
140c eb			  ex de,hl 
140d 72			  ld (hl),d 
140e 23			  inc hl 
140f 77			  ld (hl),a 
1410 23			  inc hl 
1411 36 00		  ld (hl),0 
1413			 
1413			;Now strip the leading zeros 
1413 0e fa		  ld c,-6 
1415 09			  add hl,bc 
1416 3e 30		  ld a,'0' 
1418 23			  inc hl  
1419 be			  cp (hl)  
141a 28 fc		  jr z,$-2 
141c			 
141c			;Make sure that the string is non-empty! 
141c 7e			  ld a,(hl) 
141d b7			  or a 
141e 20 01		  jr nz,.atoub 
1420 2b			  dec hl 
1421			.atoub: 
1421			 
1421 f1			  pop af 
1422 c1			  pop bc 
1423 d1			  pop de 
1424 c9			  ret 
1425			 
1425			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1425			 
1425			toUpper: 
1425			;A is the char. 
1425			;If A is a lowercase letter, this sets it to the matching uppercase 
1425			;18cc or 30cc or 41cc 
1425			;avg: 26.75cc 
1425 fe 61		  cp 'a' 
1427 d8			  ret c 
1428 fe 7b		  cp 'z'+1 
142a d0			  ret nc 
142b d6 20		  sub 'a'-'A' 
142d c9			  ret 
142e			 
142e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142e			 
142e			; String Length 
142e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142e			 
142e			; Get the length of the null-terminated string starting at $8000 hl 
142e			;    LD     HL, $8000 
142e			 
142e			strlenz: 
142e			 
142e af			    XOR    A               ; Zero is the value we are looking for. 
142f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1430 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1431			                           ; 65, 536 bytes (the entire addressable memory space). 
1431 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1433			 
1433			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1433 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1434 6f			    LD     L, A             ; number of bytes 
1435 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1437 2b			    DEC    HL              ; Compensate for null. 
1438 c9				ret 
1439			 
1439			; Get the length of the A terminated string starting at $8000 hl 
1439			;    LD     HL, $8000 
1439			 
1439			strlent: 
1439			 
1439			                  ; A is the value we are looking for. 
1439 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143d			                           ; 65, 536 bytes (the entire addressable memory space). 
143d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143f			 
143f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1441 2e 00		    LD     L, 0             ; number of bytes 
1443 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1445 2b			    DEC    HL              ; Compensate for null. 
1446 c9				ret 
1447			 
1447			 
1447			;Comparing Strings 
1447			 
1447			;IN    HL     Address of string1. 
1447			;      DE     Address of string2. 
1447			 
1447			; doc given but wrong??? 
1447			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1447			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1447			; tested 
1447			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1447			 
1447			strcmp_old: 
1447 e5			    PUSH   HL 
1448 d5			    PUSH   DE 
1449			 
1449 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
144a be			    CP     (HL)            ; (want to minimize work). 
144b 38 01		    JR     C, Str1IsBigger 
144d 7e			    LD     A, (HL) 
144e			 
144e			Str1IsBigger: 
144e 4f			    LD     C, A             ; Put length in BC 
144f 06 00		    LD     B, 0 
1451 13			    INC    DE              ; Increment pointers to meat of string. 
1452 23			    INC    HL 
1453			 
1453			CmpLoop: 
1453 1a			    LD     A, (DE)          ; Compare bytes. 
1454 ed a1		    CPI 
1456 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1458 13			    INC    DE              ; Update pointer. 
1459 ea 53 14		    JP     PE, CmpLoop 
145c			 
145c d1			    POP    DE 
145d e1			    POP    HL 
145e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145f be			    CP     (HL) 
1460 c9			    RET 
1461			 
1461			NoMatch: 
1461 2b			    DEC    HL 
1462 be			    CP     (HL)            ; Compare again to affect carry. 
1463 d1			    POP    DE 
1464 e1			    POP    HL 
1465 c9			    RET 
1466			 
1466			;; test strmp 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr z, .z1 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z1: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr z, .z2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr c, .c1 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c1: 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr c, .c2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;	NEXTW 
1466			;.str1:   db "string1",0 
1466			;.str2:   db "string2",0 
1466			 
1466			; only care about direct match or not 
1466			; hl and de strings 
1466			; zero set if the same 
1466			 
1466			strcmp: 
1466 1a				ld a, (de) 
1467 be				cp (hl) 
1468 28 02			jr z, .ssame 
146a b7				or a 
146b c9				ret 
146c			 
146c			.ssame:  
146c fe 00			cp 0 
146e c8				ret z 
146f			 
146f 23				inc hl 
1470 13				inc de 
1471 18 f3			jr strcmp 
1473				 
1473				 
1473			 
1473			 
1473			 
1473			 
1473			; eof 
1473			 
1473			 
1473			 
1473			 
1473			 
1473			 
# End of file firmware_strings.asm
1473			include "firmware_memory.asm"   ; malloc and free  
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			.mallocsize: db "Wants malloc >256",0 
1473			.mallocasize: db "MALLOC gives >256",0 
1473			.malloczero: db "MALLOC gives zero",0 
1473			 
1473			malloc_guard_zerolen: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473				ld de, 0 
1473			        call cmp16 
1473				jr nz, .lowalloz 
1473			 
1473				push hl 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .malloczero 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473				call bp_on 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473			.lowalloz: 
1473			 
1473			 
1473				pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_entry: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowalloc 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocsize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473				jr .lowdone 
1473			.lowalloc: 
1473			 
1473			 
1473				pop hl 
1473			.lowdone:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_exit: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowallocx 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocasize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473				pop de 
1473				pop hl 
1473			 
1473				CALLMONITOR 
1473				jr .lowdonex 
1473			.lowallocx: 
1473			 
1473				pop hl 
1473			.lowdonex:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			endif 
1473			 
1473			if MALLOC_2 
1473			; Z80 Malloc and Free Functions 
1473			 
1473			; Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc: 
1473				 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_entry 
1473			endif 
1473			 
1473			 
1473			 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "mal" 
1473						CALLMONITOR 
1473					endif 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of size into A 
1473			    or h               ; Check if size is zero 
1473			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1473			 
1473			    ; Allocate memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma1" 
1473						CALLMONITOR 
1473					endif 
1473			    call malloc_internal ; Call internal malloc function 
1473			    pop af             ; Restore AF register 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret                ; Return 
1473			 
1473			; Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free: 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of pointer into A 
1473			    or h               ; Check if pointer is NULL 
1473			    jp z, free_exit    ; If pointer is NULL, exit 
1473			 
1473			    ; Free memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473			    call free_internal  ; Call internal free function 
1473			    pop af             ; Restore AF register 
1473			    ret                ; Return 
1473			 
1473			; Internal Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc_internal: 
1473			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to requested size 
1473			    ex de, hl          ; Save total size in DE, and keep it in HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			 
1473			    ; Search for free memory block 
1473			    ld de, (heap_end)  ; Load end of heap into DE 
1473			    ld bc, 0           ; Initialize counter 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			malloc_search_loop: 
1473			    ; Check if current block is free 
1473			    ld a, (hl)         ; Load current block's status (free or used) 
1473			    cp 0               ; Compare with zero (free) 
1473			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1473			 
1473			    ; Check if current block is large enough 
1473			    ld a, (hl+1)       ; Load high byte of block size 
1473			    cp l               ; Compare with low byte of requested size 
1473			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1473			 
1473			    ld a, (hl+2)       ; Load low byte of block size 
1473			    cp h               ; Compare with high byte of requested size 
1473			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1473			 
1473			    ; Mark block as used 
1473			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1473			 
1473			    ; Calculate remaining space in block 
1473			    ld bc, 0           ; Clear BC 
1473			    add hl, bc         ; Increment HL to point to start of data block 
1473			    add hl, de         ; HL = HL + DE (total size) 
1473			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to start of data block 
1473			 
1473			    ; Save pointer to allocated block in HL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma5" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			malloc_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3           ; Size of management overhead 
1473			    add hl, bc         ; Move to the next block 
1473			    inc de             ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e            ; Load low byte of heap end address 
1473			    cp (hl)            ; Compare with low byte of current address 
1473			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1473			    ld a, d            ; Load high byte of heap end address 
1473			    cp 0               ; Check if it's zero (end of memory) 
1473			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, allocation failed 
1473			    xor a              ; Set result to NULL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma6" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			malloc_exit: 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma7" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			; Internal Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free_internal: 
1473			    ld de, (heap_start) ; Load start of heap into DE 
1473			    ld bc, 0            ; Initialize counter 
1473			 
1473			free_search_loop: 
1473			    ; Check if current block contains the pointer 
1473			    ld a, l             ; Load low byte of pointer 
1473			    cp (hl+1)           ; Compare with high byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			    ld a, h             ; Load high byte of pointer 
1473			    cp (hl+2)           ; Compare with low byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			 
1473			    ; Mark block as free 
1473			    ld (hl), 0          ; Set status byte to indicate free block 
1473			    ret                 ; Return 
1473			 
1473			free_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3            ; Size of management overhead 
1473			    add hl, bc          ; Move to the next block 
1473			    inc de              ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e             ; Load low byte of heap end address 
1473			    cp (hl)             ; Compare with low byte of current address 
1473			    jr nz, free_search_loop  ; If not equal, continue searching 
1473			    ld a, d             ; Load high byte of heap end address 
1473			    cp 0                ; Check if it's zero (end of memory) 
1473			    jr nz, free_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, pointer is not found in heap 
1473			    ret 
1473			 
1473			free_exit: 
1473			    ret                 ; Return 
1473			 
1473			; Define heap start and end addresses 
1473			;heap_start:    .dw 0xC000   ; Start of heap 
1473			;heap_end:      .dw 0xE000   ; End of heap 
1473			 
1473			endif 
1473			 
1473			 
1473			if MALLOC_1 
1473			 
1473			 
1473			 
1473			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1473			 
1473			;moved to firmware.asm 
1473			;heap_start        .equ  0x9000      ; Starting address of heap 
1473			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1473			 
1473			;      .org 0 
1473			;      jp    main 
1473			 
1473			 
1473			;      .org  0x100 
1473			;main: 
1473			;      ld    HL, 0x8100 
1473			;      ld    SP, HL 
1473			; 
1473			;      call  heap_init 
1473			; 
1473			;      ; Make some allocations 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9004 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9014 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9024 
1473			; 
1473			;      ; Free some allocations 
1473			;      ld    HL, 0x9014 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9004 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9024 
1473			;      call  free 
1473			; 
1473			; 
1473			;      halt 
1473			 
1473			 
1473			;------------------------------------------------------------------------------ 
1473			;     heap_init                                                               : 
1473			;                                                                             : 
1473			; Description                                                                 : 
1473			;     Initialise the heap and make it ready for malloc and free operations.   : 
1473			;                                                                             : 
1473			;     The heap is maintained as a linked list, starting with an initial       : 
1473			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1473			;     the first free block in the heap. Each block then points to the next    : 
1473			;     free block within the heap, and the free list ends at the first block   : 
1473			;     with a null pointer to the next free block.                             : 
1473			;                                                                             : 
1473			; Parameters                                                                  : 
1473			;     Inputs are compile-time only. Two defines which specify the starting    : 
1473			;     address of the heap and its size are required, along with a memory      : 
1473			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1473			;     principally stores a pointer to the first free block in the heap.       : 
1473			;                                                                             : 
1473			; Returns                                                                     : 
1473			;     Nothing                                                                 : 
1473			;------------------------------------------------------------------------------ 
1473			heap_init: 
1473 e5			      push  HL 
1474			 
1474			      ; Initialise free list struct 
1474 21 0e 80		      ld    HL, heap_start 
1477 22 0a 80		      ld    (free_list), HL 
147a 21 00 00		      ld    HL, 0 
147d 22 0c 80		      ld    (free_list+2), HL 
1480			 
1480			      ; Insert first free block at bottom of heap, consumes entire heap 
1480 21 95 f1		      ld    HL, heap_start+heap_size-4 
1483 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1486 21 87 71		      ld    HL, heap_size-4 
1489 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148c			 
148c			      ; Insert end of free list block at top of heap - two null words will 
148c			      ; terminate the free list 
148c 21 00 00		      ld    HL, 0 
148f 22 97 f1		      ld    (heap_start+heap_size-2), HL 
1492 22 95 f1		      ld    (heap_start+heap_size-4), HL 
1495			 
1495 e1			      pop   HL 
1496			 
1496 c9			      ret 
1497			 
1497			 
1497			;------------------------------------------------------------------------------ 
1497			;     malloc                                                                  : 
1497			;                                                                             : 
1497			; Description                                                                 : 
1497			;     Allocates the wanted space from the heap and returns the address of the : 
1497			;     first useable byte of the allocation.                                   : 
1497			;                                                                             : 
1497			;     Allocations can happen in one of two ways:                              : 
1497			;                                                                             : 
1497			;     1. A free block may be found which is the exact size wanted. In this    : 
1497			;        case the block is removed from the free list and retuedn to the      : 
1497			;        caller.                                                              : 
1497			;     2. A free block may be found which is larger than the size wanted. In   : 
1497			;        this case, the larger block is split into two. The first portion of  : 
1497			;        this block will become the requested space by the malloc call and    : 
1497			;        is returned to the caller. The second portion becomes a new free     : 
1497			;        block, and the free list is adjusted to maintain continuity via this : 
1497			;        newly created block.                                                 : 
1497			;                                                                             : 
1497			;     malloc does not set any initial value in the allocated space, the       : 
1497			;     caller is required to do this as required.                              : 
1497			;                                                                             : 
1497			;     This implementation of malloc uses the stack exclusively, and is        : 
1497			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1497			;     advisable to disable interrupts before calling malloc, and recommended  : 
1497			;     to avoid the use of malloc inside ISRs in general.                      : 
1497			;                                                                             : 
1497			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1497			;                                                                             : 
1497			; Parameters                                                                  : 
1497			;     HL  Number of bytes wanted                                              : 
1497			;                                                                             : 
1497			; Returns                                                                     : 
1497			;     HL  Address of the first useable byte of the allocation                 : 
1497			;                                                                             : 
1497			; Flags                                                                       : 
1497			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1497			;                                                                             : 
1497			; Stack frame                                                                 : 
1497			;       |             |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     BC      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     DE      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     IX      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |  prev_free  |                                                       : 
1497			;   +4  +-------------+                                                       : 
1497			;       |  this_free  |                                                       : 
1497			;   +2  +-------------+                                                       : 
1497			;       |  next_free  |                                                       : 
1497			;   +0  +-------------+                                                       : 
1497			;       |             |                                                       : 
1497			;                                                                             : 
1497			;------------------------------------------------------------------------------ 
1497			 
1497			 
1497			;malloc: 
1497			; 
1497			;	SAVESP ON 1 
1497			; 
1497			;	call malloc_code 
1497			; 
1497			;	CHECKSP ON 1 
1497			;	ret 
1497			 
1497			 
1497			malloc: 
1497 c5			      push  BC 
1498 d5			      push  DE 
1499 dd e5		      push  IX 
149b			if DEBUG_FORTH_MALLOC_HIGH 
149b			call malloc_guard_entry 
149b			endif 
149b			 
149b					if DEBUG_FORTH_MALLOC 
149b						DMARK "mal" 
149b						CALLMONITOR 
149b					endif 
149b 7c			      ld    A, H                    ; Exit if no space requested 
149c b5			      or    L 
149d ca 5c 15		      jp    Z, malloc_early_exit 
14a0			 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			; 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			 
14a0			 
14a0			 
14a0			 
14a0					if DEBUG_FORTH_MALLOC 
14a0						DMARK "maA" 
14a0						CALLMONITOR 
14a0					endif 
14a0			      ; Set up stack frame 
14a0 eb			      ex    DE, HL 
14a1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a4 39			      add   HL, SP 
14a5 f9			      ld    SP, HL 
14a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14aa dd 39		      add   IX, SP 
14ac			 
14ac			      ; Setup initial state 
14ac 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14af 19			      add   HL, DE 
14b0			 
14b0 44			      ld    B, H                    ; Move want to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b5 dd 75 04		      ld    (IX+4), L 
14b8 dd 74 05		      ld    (IX+5), H 
14bb			 
14bb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be dd 73 02		      ld    (IX+2), E 
14c1 dd 72 03		      ld    (IX+3), D 
14c4 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c5			 
14c5					if DEBUG_FORTH_MALLOC 
14c5						DMARK "maB" 
14c5						CALLMONITOR 
14c5					endif 
14c5			      ; Loop through free block list to find some space 
14c5			malloc_find_space: 
14c5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8			 
14c8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c9 b3			      or    E 
14ca ca 56 15		      jp    Z, malloc_no_space 
14cd			 
14cd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14d0 dd 72 01		      ld    (IX+1), D 
14d3			 
14d3			      ; Does this block have enough space to make the allocation? 
14d3 23			      inc   HL                      ; Load free block size into DE 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7			 
14d7 eb			      ex    DE, HL                  ; Check size of block against want 
14d8 b7			      or    A                       ; Ensure carry flag clear 
14d9 ed 42		      sbc   HL, BC 
14db e5			      push  HL                      ; Store the result for later (new block size) 
14dc			 
14dc ca 2b 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14df 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e1			 
14e1			      ; this_free block is not big enough, setup ptrs to test next free block 
14e1 e1			      pop   HL                      ; Discard previous result 
14e2			 
14e2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e5 dd 66 03		      ld    H, (IX+3) 
14e8 dd 75 04		      ld    (IX+4), L 
14eb dd 74 05		      ld    (IX+5), H 
14ee			 
14ee dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4 dd 75 02		      ld    (IX+2), L 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa					if DEBUG_FORTH_MALLOC 
14fa						DMARK "MA>" 
14fa						CALLMONITOR 
14fa					endif 
14fa 18 c9		      jr    malloc_find_space 
14fc			 
14fc			      ; split a bigger block into two - requested size and remaining size 
14fc			malloc_alloc_split: 
14fc					if DEBUG_FORTH_MALLOC 
14fc						DMARK "MAs" 
14fc						CALLMONITOR 
14fc					endif 
14fc eb			      ex    DE, HL                  ; Calculate address of new free block 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 2b			      dec   HL 
1500 09			      add   HL, BC 
1501			 
1501			      ; Create a new block and point it at next_free 
1501 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1504 dd 56 01		      ld    D, (IX+1) 
1507			 
1507 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1508 23			      inc   HL 
1509 72			      ld    (HL), D 
150a			 
150a d1			      pop   DE                      ; Store size of new block into new block 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			      ; Update this_free ptr to point to new block 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1515 dd 56 03		      ld    D, (IX+3) 
1518			 
1518 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151b dd 74 03		      ld    (IX+3), H 
151e			 
151e			      ; Modify this_free block to be allocation 
151e eb			      ex    DE, HL 
151f af			      xor   A                       ; Null the next block ptr of allocated block 
1520 77			      ld    (HL), A 
1521 23			      inc   HL 
1522 77			      ld    (HL), A 
1523			 
1523 23			      inc   HL                      ; Store want size into allocated block 
1524 71			      ld    (HL), C 
1525 23			      inc   HL 
1526 70			      ld    (HL), B 
1527 23			      inc   HL 
1528 e5			      push  HL                      ; Address of allocation to return 
1529			 
1529 18 19		      jr    malloc_update_links 
152b			 
152b			malloc_alloc_fit: 
152b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c					if DEBUG_FORTH_MALLOC 
152c						DMARK "MAf" 
152c						CALLMONITOR 
152c					endif 
152c			      ; Modify this_free block to be allocation 
152c eb			      ex    DE, HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f 2b			      dec   HL 
1530			 
1530 af			      xor   A                       ; Null the next block ptr of allocated block 
1531 77			      ld    (HL), A 
1532 23			      inc   HL 
1533 77			      ld    (HL), A 
1534			 
1534 23			      inc   HL                      ; Store address of allocation to return 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 e5			      push  HL 
1538			 
1538			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1538 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153b dd 66 01		      ld    H, (IX+1) 
153e			 
153e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1541 dd 74 03		      ld    (IX+3), H 
1544			 
1544			 
1544			malloc_update_links: 
1544			      ; Update prev_free ptr to point to this_free 
1544 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1547 dd 66 05		      ld    H, (IX+5) 
154a			 
154a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154d dd 56 03		      ld    D, (IX+3) 
1550			 
1550 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1551 23			      inc   HL 
1552 72			      ld    (HL), D 
1553			 
1553					if DEBUG_FORTH_MALLOC 
1553						DMARK "Mul" 
1553						CALLMONITOR 
1553					endif 
1553			      ; Clear the Z flag to indicate successful allocation 
1553 7a			      ld    A, D 
1554 b3			      or    E 
1555			 
1555 d1			      pop   DE                      ; Address of allocation 
1556					if DEBUG_FORTH_MALLOC 
1556						DMARK "MAu" 
1556						CALLMONITOR 
1556					endif 
1556			 
1556			malloc_no_space: 
1556 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1559 39			      add   HL, SP 
155a f9			      ld    SP, HL 
155b			 
155b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAN" 
155c						CALLMONITOR 
155c					endif 
155c			 
155c			malloc_early_exit: 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAx" 
155c						CALLMONITOR 
155c					endif 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560			if DEBUG_FORTH_MALLOC_HIGH 
1560			call malloc_guard_exit 
1560			call malloc_guard_zerolen 
1560			endif 
1560 c9			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561 c5			      push  BC 
1562 d5			      push  DE 
1563 dd e5		      push  IX 
1565			 
1565 7c			      ld    A, H                    ; Exit if ptr is null 
1566 b5			      or    L 
1567 ca 2b 16		      jp    Z, free_early_exit 
156a			 
156a			      ; Set up stack frame 
156a eb			      ex    DE, HL 
156b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156e 39			      add   HL, SP 
156f f9			      ld    SP, HL 
1570 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1574 dd 39		      add   IX, SP 
1576			 
1576			      ; The address in HL points to the start of the useable allocated space, 
1576			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1576			      ; address of the block itself. 
1576 eb			      ex    DE, HL 
1577 11 fc ff		      ld    DE, -4 
157a 19			      add   HL, DE 
157b			 
157b			      ; An allocated block must have a null next block pointer in it 
157b 7e			      ld    A, (HL) 
157c 23			      inc   HL 
157d b6			      or    (HL) 
157e c2 26 16		      jp    NZ, free_done 
1581			 
1581 2b			      dec   HL 
1582			 
1582 44			      ld    B, H                    ; Copy HL to BC 
1583 4d			      ld    C, L 
1584			 
1584			      ; Loop through the free list to find the first block with an address 
1584			      ; higher than the block being freed 
1584 21 0a 80		      ld    HL, free_list 
1587			 
1587			free_find_higher_block: 
1587 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1588 23			      inc   HL 
1589 56			      ld    D, (HL) 
158a 2b			      dec   HL 
158b			 
158b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158e dd 72 01		      ld    (IX+1), D 
1591 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1594 dd 74 03		      ld    (IX+3), H 
1597			 
1597 78			      ld    A, B                    ; Check if DE is greater than BC 
1598 ba			      cp    D                       ; Compare MSB first 
1599 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159b 30 04		      jr    NC, free_find_higher_block_skip 
159d 79			      ld    A, C 
159e bb			      cp    E                       ; Then compare LSB 
159f 38 08		      jr    C, free_found_higher_block 
15a1			 
15a1			free_find_higher_block_skip: 
15a1 7a			      ld    A, D                    ; Reached the end of the free list? 
15a2 b3			      or    E 
15a3 ca 26 16		      jp    Z, free_done 
15a6			 
15a6 eb			      ex    DE, HL 
15a7			 
15a7 18 de		      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9 71			      ld    (HL), C                 ; Point prev free block to freed block 
15aa 23			      inc   HL 
15ab 70			      ld    (HL), B 
15ac			 
15ac 60			      ld    H, B                    ; Point freed block at next free block 
15ad 69			      ld    L, C 
15ae 73			      ld    (HL), E 
15af 23			      inc   HL 
15b0 72			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1 23			      inc   HL                      ; Load size of freed block into HL 
15b2 5e			      ld    E, (HL) 
15b3 23			      inc   HL 
15b4 56			      ld    D, (HL) 
15b5 eb			      ex    DE, HL 
15b6			 
15b6 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b7			 
15b7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ba dd 56 01		      ld    D, (IX+1) 
15bd			 
15bd b7			      or    A                       ; Clear the carry flag 
15be ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15c0 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c2			 
15c2			      ; Freed block is adjacent to next, merge into one bigger block 
15c2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c3 5e			      ld    E, (HL) 
15c4 23			      inc   HL 
15c5 56			      ld    D, (HL) 
15c6 e5			      push  HL                      ; Save ptr to next block for later 
15c7			 
15c7 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c8 69			      ld    L, C 
15c9 73			      ld    (HL), E 
15ca 23			      inc   HL 
15cb 72			      ld    (HL), D 
15cc			 
15cc e1			      pop   HL                      ; Restore ptr to next block 
15cd 23			      inc   HL                      ; Load size of next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 d5			      push  DE                      ; Save next block size for later 
15d2			 
15d2 60			      ld    H, B                    ; Load size of freed block into HL 
15d3 69			      ld    L, C 
15d4 23			      inc   HL 
15d5 23			      inc   HL 
15d6 5e			      ld    E, (HL) 
15d7 23			      inc   HL 
15d8 56			      ld    D, (HL) 
15d9 eb			      ex    DE, HL 
15da			 
15da d1			      pop   DE                      ; Restore size of next block 
15db 19			      add   HL, DE                  ; Add sizes of both blocks 
15dc eb			      ex    DE, HL 
15dd			 
15dd 60			      ld    H, B                    ; Store new bigger size into freed block 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 73			      ld    (HL), E 
15e2 23			      inc   HL 
15e3 72			      ld    (HL), D 
15e4			 
15e4			free_check_adjacent_to_prev: 
15e4			      ; Check if the freed block is adjacent to the prev free block 
15e4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e7 dd 66 03		      ld    H, (IX+3) 
15ea			 
15ea 23			      inc   HL                      ; Size of prev free block into DE 
15eb 23			      inc   HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1 2b			      dec   HL 
15f2			 
15f2 19			      add   HL, DE                  ; Add prev block addr and size 
15f3			 
15f3 b7			      or    A                       ; Clear the carry flag 
15f4 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f6 20 2e		      jr    NZ, free_done 
15f8			 
15f8			      ; Freed block is adjacent to prev, merge into one bigger block 
15f8 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f9 69			      ld    L, C 
15fa 5e			      ld    E, (HL) 
15fb 23			      inc   HL 
15fc 56			      ld    D, (HL) 
15fd e5			      push  HL                      ; Save freed block ptr for later 
15fe			 
15fe dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1601 dd 66 03		      ld    H, (IX+3) 
1604 73			      ld    (HL), E 
1605 23			      inc   HL 
1606 72			      ld    (HL), D 
1607			 
1607 e1			      pop   HL                      ; Restore freed block ptr 
1608 23			      inc   HL                      ; Load size of freed block into DE 
1609 5e			      ld    E, (HL) 
160a 23			      inc   HL 
160b 56			      ld    D, (HL) 
160c d5			      push  DE                      ; Save freed block size for later 
160d			 
160d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1610 dd 66 03		      ld    H, (IX+3) 
1613 23			      inc   HL 
1614 23			      inc   HL 
1615 5e			      ld    E, (HL) 
1616 23			      inc   HL 
1617 56			      ld    D, (HL) 
1618			 
1618 e1			      pop   HL                      ; Add sizes of both blocks 
1619 19			      add   HL, DE 
161a eb			      ex    DE, HL 
161b			 
161b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161e dd 66 03		      ld    H, (IX+3) 
1621 23			      inc   HL 
1622 23			      inc   HL 
1623 73			      ld    (HL), E 
1624 23			      inc   HL 
1625 72			      ld    (HL), D 
1626			 
1626			free_done: 
1626 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1629 39			      add   HL, SP 
162a f9			      ld    SP, HL 
162b			 
162b			free_early_exit: 
162b dd e1		      pop   IX 
162d d1			      pop   DE 
162e c1			      pop   BC 
162f			 
162f c9			      ret 
1630			 
1630			; moved to firmware.asm 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			;                  .dw   0 
1630			 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_3 
1630			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1630			;heap_start        .equ  0x9000      ; Starting address of heap 
1630			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1630			; 
1630			 ;     .org 0 
1630			  ;    jp    main 
1630			; 
1630			; 
1630			 ;     .org  0x100 
1630			;main: 
1630			 ;     ld    HL, 0x8100 
1630			  ;    ld    SP, HL 
1630			; 
1630			;      call  heap_init 
1630			 
1630			      ; Make some allocations 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9004 
1630			; 
1630			 ;     ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9014 
1630			 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9024 
1630			 
1630			      ; Free some allocations 
1630			;      ld    HL, 0x9014 
1630			;      call  free 
1630			 
1630			;      ld    HL, 0x9004 
1630			;      call  free 
1630			; 
1630			;      ld    HL, 0x9024 
1630			;      call  free 
1630			 
1630			 
1630			 ;     halt 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     heap_init                                                               : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Initialise the heap and make it ready for malloc and free operations.   : 
1630			;                                                                             : 
1630			;     The heap is maintained as a linked list, starting with an initial       : 
1630			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1630			;     the first free block in the heap. Each block then points to the next    : 
1630			;     free block within the heap, and the free list ends at the first block   : 
1630			;     with a null pointer to the next free block.                             : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     Inputs are compile-time only. Two defines which specify the starting    : 
1630			;     address of the heap and its size are required, along with a memory      : 
1630			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1630			;     principally stores a pointer to the first free block in the heap.       : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;------------------------------------------------------------------------------ 
1630			heap_init: 
1630			      push  HL 
1630			 
1630			      ; Initialise free list struct 
1630			      ld    HL, heap_start 
1630			      ld    (free_list), HL 
1630			      ld    HL, 0 
1630			      ld    (free_list+2), HL 
1630			 
1630			      ; Insert first free block at bottom of heap, consumes entire heap 
1630			      ld    HL, heap_start+heap_size-4 
1630			      ld    (heap_start), HL        ; Next block (end of free list) 
1630			      ld    HL, heap_size-4 
1630			      ld    (heap_start+2), HL      ; Block size 
1630			 
1630			      ; Insert end of free list block at top of heap - two null words will 
1630			      ; terminate the free list 
1630			      ld    HL, 0 
1630			      ld    (heap_start+heap_size-2), HL 
1630			      ld    (heap_start+heap_size-4), HL 
1630			 
1630			      pop   HL 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     malloc                                                                  : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Allocates the wanted space from the heap and returns the address of the : 
1630			;     first useable byte of the allocation.                                   : 
1630			;                                                                             : 
1630			;     Allocations can happen in one of two ways:                              : 
1630			;                                                                             : 
1630			;     1. A free block may be found which is the exact size wanted. In this    : 
1630			;        case the block is removed from the free list and retuedn to the      : 
1630			;        caller.                                                              : 
1630			;     2. A free block may be found which is larger than the size wanted. In   : 
1630			;        this case, the larger block is split into two. The first portion of  : 
1630			;        this block will become the requested space by the malloc call and    : 
1630			;        is returned to the caller. The second portion becomes a new free     : 
1630			;        block, and the free list is adjusted to maintain continuity via this : 
1630			;        newly created block.                                                 : 
1630			;                                                                             : 
1630			;     malloc does not set any initial value in the allocated space, the       : 
1630			;     caller is required to do this as required.                              : 
1630			;                                                                             : 
1630			;     This implementation of malloc uses the stack exclusively, and is        : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling malloc, and recommended  : 
1630			;     to avoid the use of malloc inside ISRs in general.                      : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Number of bytes wanted                                              : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     HL  Address of the first useable byte of the allocation                 : 
1630			;                                                                             : 
1630			; Flags                                                                       : 
1630			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +4  +-------------+                                                       : 
1630			;       |  this_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			malloc: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if no space requested 
1630			      or    L 
1630			      jp    Z, malloc_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; Setup initial state 
1630			      ld    HL, 4                   ; want must also include space used by block struct 
1630			      add   HL, DE 
1630			 
1630			      ld    B, H                    ; Move want to BC 
1630			      ld    C, L 
1630			 
1630			      ld    HL, free_list           ; Store prev_free ptr to stack 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    E, (HL)                 ; Store this_free ptr to stack 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ld    (IX+2), E 
1630			      ld    (IX+3), D 
1630			      ex    DE, HL                  ; this_free ptr into HL 
1630			 
1630			      ; Loop through free block list to find some space 
1630			malloc_find_space: 
1630			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1630			      or    E 
1630			      jp    Z, malloc_no_space 
1630			 
1630			      ld    (IX+0), E               ; Store next_free ptr to stack 
1630			      ld    (IX+1), D 
1630			 
1630			      ; Does this block have enough space to make the allocation? 
1630			      inc   HL                      ; Load free block size into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ex    DE, HL                  ; Check size of block against want 
1630			      or    A                       ; Ensure carry flag clear 
1630			      sbc   HL, BC 
1630			      push  HL                      ; Store the result for later (new block size) 
1630			 
1630			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1630			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1630			 
1630			      ; this_free block is not big enough, setup ptrs to test next free block 
1630			      pop   HL                      ; Discard previous result 
1630			 
1630			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1630			      ld    H, (IX+3) 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1630			      ld    H, (IX+1) 
1630			      ld    (IX+2), L 
1630			      ld    (IX+3), H 
1630			 
1630			      jr    malloc_find_space 
1630			 
1630			      ; split a bigger block into two - requested size and remaining size 
1630			malloc_alloc_split: 
1630			      ex    DE, HL                  ; Calculate address of new free block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      add   HL, BC 
1630			 
1630			      ; Create a new block and point it at next_free 
1630			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      ld    (HL), E                 ; Store next_free ptr into new block 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   DE                      ; Store size of new block into new block 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Update this_free ptr to point to new block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1630			      ld    (IX+3), H 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store want size into allocated block 
1630			      ld    (HL), C 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			      inc   HL 
1630			      push  HL                      ; Address of allocation to return 
1630			 
1630			      jr    malloc_update_links 
1630			 
1630			malloc_alloc_fit: 
1630			      pop   HL                      ; Dont need new block size, want is exact fit 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store address of allocation to return 
1630			      inc   HL 
1630			      inc   HL 
1630			      push  HL 
1630			 
1630			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1630			      ld    L, (IX+0)               ; next_free to HL 
1630			      ld    H, (IX+1) 
1630			 
1630			      ld    (IX+2), L               ; HL to this_free 
1630			      ld    (IX+3), H 
1630			 
1630			 
1630			malloc_update_links: 
1630			      ; Update prev_free ptr to point to this_free 
1630			      ld    L, (IX+4)               ; prev_free ptr to HL 
1630			      ld    H, (IX+5) 
1630			 
1630			      ld    E, (IX+2)               ; this_free ptr to DE 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (HL), E                 ; this_free ptr into prev_free 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Clear the Z flag to indicate successful allocation 
1630			      ld    A, D 
1630			      or    E 
1630			 
1630			      pop   DE                      ; Address of allocation 
1630			 
1630			malloc_no_space: 
1630			      ld    HL, 6                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			      ex    DE, HL                  ; Alloc addr into HL for return 
1630			 
1630			malloc_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     free                                                                    : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1630			;     returned by malloc, otherwise the behaviour is undefined.               : 
1630			;                                                                             : 
1630			;     Where possible, directly adjacent free blocks will be merged together   : 
1630			;     into larger blocks to help ensure that the heap does not become         : 
1630			;     excessively fragmented.                                                 : 
1630			;                                                                             : 
1630			;     free does not clear or set any other value into the freed space, and    : 
1630			;     therefore its contents may be visible through subsequent malloc's. The  : 
1630			;     caller should clear the freed space as required.                        : 
1630			;                                                                             : 
1630			;     This implementation of free uses the stack exclusively, and is          : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling free, and recommended    : 
1630			;     to avoid the use of free inside ISRs in general.                        : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Pointer to address of first byte of allocation to be freed          : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			free: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if ptr is null 
1630			      or    L 
1630			      jp    Z, free_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; The address in HL points to the start of the useable allocated space, 
1630			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1630			      ; address of the block itself. 
1630			      ex    DE, HL 
1630			      ld    DE, -4 
1630			      add   HL, DE 
1630			 
1630			      ; An allocated block must have a null next block pointer in it 
1630			      ld    A, (HL) 
1630			      inc   HL 
1630			      or    (HL) 
1630			      jp    NZ, free_done 
1630			 
1630			      dec   HL 
1630			 
1630			      ld    B, H                    ; Copy HL to BC 
1630			      ld    C, L 
1630			 
1630			      ; Loop through the free list to find the first block with an address 
1630			      ; higher than the block being freed 
1630			      ld    HL, free_list 
1630			 
1630			free_find_higher_block: 
1630			      ld    E, (HL)                 ; Load next ptr from free block 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			 
1630			      ld    (IX+0), E               ; Save ptr to next free block 
1630			      ld    (IX+1), D 
1630			      ld    (IX+2), L               ; Save ptr to prev free block 
1630			      ld    (IX+3), H 
1630			 
1630			      ld    A, B                    ; Check if DE is greater than BC 
1630			      cp    D                       ; Compare MSB first 
1630			      jr    Z, $+4                  ; MSB the same, compare LSB 
1630			      jr    NC, free_find_higher_block_skip 
1630			      ld    A, C 
1630			      cp    E                       ; Then compare LSB 
1630			      jr    C, free_found_higher_block 
1630			 
1630			free_find_higher_block_skip: 
1630			      ld    A, D                    ; Reached the end of the free list? 
1630			      or    E 
1630			      jp    Z, free_done 
1630			 
1630			      ex    DE, HL 
1630			 
1630			      jr    free_find_higher_block 
1630			 
1630			free_found_higher_block: 
1630			      ; Insert freed block between prev and next free blocks 
1630			      ld    (HL), C                 ; Point prev free block to freed block 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			 
1630			      ld    H, B                    ; Point freed block at next free block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Check if the freed block is adjacent to the next free block 
1630			      inc   HL                      ; Load size of freed block into HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      add   HL, BC                  ; Add addr of freed block and its size 
1630			 
1630			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_check_adjacent_to_prev 
1630			 
1630			      ; Freed block is adjacent to next, merge into one bigger block 
1630			      ex    DE, HL                  ; Load next ptr from next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save ptr to next block for later 
1630			 
1630			      ld    H, B                    ; Store ptr from next block into freed block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore ptr to next block 
1630			      inc   HL                      ; Load size of next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save next block size for later 
1630			 
1630			      ld    H, B                    ; Load size of freed block into HL 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      pop   DE                      ; Restore size of next block 
1630			      add   HL, DE                  ; Add sizes of both blocks 
1630			      ex    DE, HL 
1630			 
1630			      ld    H, B                    ; Store new bigger size into freed block 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_check_adjacent_to_prev: 
1630			      ; Check if the freed block is adjacent to the prev free block 
1630			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1630			      ld    H, (IX+3) 
1630			 
1630			      inc   HL                      ; Size of prev free block into DE 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      add   HL, DE                  ; Add prev block addr and size 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_done 
1630			 
1630			      ; Freed block is adjacent to prev, merge into one bigger block 
1630			      ld    H, B                    ; Load next ptr from freed block into DE 
1630			      ld    L, C 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save freed block ptr for later 
1630			 
1630			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1630			      ld    H, (IX+3) 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore freed block ptr 
1630			      inc   HL                      ; Load size of freed block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save freed block size for later 
1630			 
1630			      ld    L, (IX+2)               ; Load size of prev block into DE 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      pop   HL                      ; Add sizes of both blocks 
1630			      add   HL, DE 
1630			      ex    DE, HL 
1630			 
1630			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_done: 
1630			      ld    HL, 4                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			free_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;      .org 0x8000 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			 ;                 .dw   0 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_4 
1630			 
1630			; My memory allocation code. Very very simple.... 
1630			; allocate space under 250 chars 
1630			 
1630			heap_init: 
1630				; init start of heap as zero 
1630				;  
1630			 
1630				ld hl, heap_start 
1630				ld a, 0 
1630				ld (hl), a      ; empty block 
1630				inc hl 
1630				ld a, 0 
1630				ld (hl), a      ; length of block 
1630				; write end of list 
1630				inc hl 
1630				ld a,(hl) 
1630				inc hl 
1630				ld a,(hl) 
1630				 
1630			 
1630				; init some malloc vars 
1630			 
1630				ld hl, 0 
1630				ld (free_list), hl       ; store last malloc location 
1630			 
1630				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1630				ld a, 0 
1630				ld (hl), a 
1630			 
1630			 
1630				ld hl, heap_start 
1630				;  
1630				  
1630				ret 
1630			 
1630			 
1630			;    free block marker 
1630			;    requested size  
1630			;    pointer to next block 
1630			;    .... 
1630			;    next block marker 
1630			 
1630			 
1630			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1630			; 
1630			 
1630			 
1630			malloc:  
1630				push de 
1630				push bc 
1630				push af 
1630			 
1630				; hl space required 
1630				 
1630				ld c, l    ; hold space   (TODO only a max of 255) 
1630			 
1630			;	inc c     ; TODO BUG need to fix memory leak on push str 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			 
1630			 
1630			 
1630				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1630			 
1630				ld a, (free_list+3) 
1630				cp 0 
1630				jr z, .contheap 
1630			 
1630				ld hl, (free_list)     ; get last alloc 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mrs" 
1630						CALLMONITOR 
1630					endif 
1630				jr .startalloc 
1630			 
1630			.contheap: 
1630				ld hl, heap_start 
1630			 
1630			.startalloc: 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mym" 
1630						CALLMONITOR 
1630					endif 
1630			.findblock: 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmf" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630				ld a,(hl)  
1630				; if byte is zero then clear to use 
1630			 
1630				cp 0 
1630				jr z, .foundemptyblock 
1630			 
1630				; if byte is not clear 
1630				;     then byte is offset to next block 
1630			 
1630				inc hl 
1630				ld a, (hl) ; get size 
1630			.nextblock:	inc hl 
1630					ld e, (hl) 
1630					inc hl 
1630					ld d, (hl) 
1630					ex de, hl 
1630			;	inc hl  ; move past the store space 
1630			;	inc hl  ; move past zero index  
1630			 
1630				; TODO detect no more space 
1630			 
1630				push hl 
1630				ld de, heap_end 
1630				call cmp16 
1630				pop hl 
1630				jr nc, .nospace 
1630			 
1630				jr .findblock 
1630			 
1630			.nospace: ld hl, 0 
1630				jp .exit 
1630			 
1630			 
1630			.foundemptyblock:	 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mme" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; TODO has block enough space if reusing??? 
1630			 
1630				;  
1630			 
1630			; see if this block has been previously used 
1630				inc hl 
1630				ld a, (hl) 
1630				dec hl 
1630				cp 0 
1630				jr z, .newblock 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meR" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; no reusing previously allocated block 
1630			 
1630			; is it smaller than previously used? 
1630				 
1630				inc hl    ; move to size 
1630				ld a, c 
1630				sub (hl)        ; we want c < (hl) 
1630				dec hl    ; move back to marker 
1630			        jr z, .findblock 
1630			 
1630				; update with the new size which should be lower 
1630			 
1630			        ;inc  hl   ; negate next move. move back to size  
1630			 
1630			.newblock: 
1630				; need to be at marker here 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meN" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			 
1630				ld a, c 
1630			 
1630				ld (free_list+3), a	 ; flag resume from last malloc  
1630				ld (free_list), hl    ; save out last location 
1630			 
1630			 
1630				;inc a     ; space for length byte 
1630				ld (hl), a     ; save block in use marker 
1630			 
1630				inc hl   ; move to space marker 
1630				ld (hl), a    ; save new space 
1630			 
1630				inc hl   ; move to start of allocated area 
1630				 
1630			;	push hl     ; save where we are - 1  
1630			 
1630			;	inc hl  ; move past zero index  
1630				; skip space to set down new marker 
1630			 
1630				; provide some extra space for now 
1630			 
1630				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1630				inc a 
1630				inc a 
1630			 
1630				push hl   ; save where we are in the node block 
1630			 
1630				call addatohl 
1630			 
1630				; write linked list point 
1630			 
1630				pop de     ; get our node position 
1630				ex de, hl 
1630			 
1630				ld (hl), e 
1630				inc hl 
1630				ld (hl), d 
1630			 
1630				inc hl 
1630			 
1630				; now at start of allocated data so save pointer 
1630			 
1630				push hl 
1630			 
1630				; jump to position of next node and setup empty header in DE 
1630			 
1630				ex de, hl 
1630			 
1630			;	inc hl ; move past end of block 
1630			 
1630				ld a, 0 
1630				ld (hl), a   ; empty marker 
1630				inc hl 
1630				ld (hl), a   ; size 
1630				inc hl  
1630				ld (hl), a   ; ptr 
1630				inc hl 
1630				ld (hl), a   ; ptr 
1630			 
1630			 
1630				pop hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmr" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			.exit: 
1630				pop af 
1630				pop bc 
1630				pop de  
1630				ret 
1630			 
1630			 
1630			 
1630			 
1630			free:  
1630				push hl 
1630				push af 
1630				; get address in hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "fre" 
1630						CALLMONITOR 
1630					endif 
1630				; data is at hl - move to block count 
1630				dec hl 
1630				dec hl    ; get past pointer 
1630				dec hl 
1630			 
1630				ld a, (hl)    ; need this for a validation check 
1630			 
1630				dec hl    ; move to block marker 
1630			 
1630				; now check that the block count and block marker are the same  
1630			        ; this checks that we are on a malloc node and not random memory 
1630			        ; OK a faint chance this could be a problem but rare - famous last words! 
1630			 
1630				ld c, a 
1630				ld a, (hl)    
1630			 
1630				cp c 
1630				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1630			 
1630				; yes good chance we are on a malloc node 
1630			 
1630				ld a, 0      
1630				ld (hl), a   ; mark as free 
1630			 
1630				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1630			 
1630			.freeignore:  
1630			 
1630				pop af 
1630				pop hl 
1630			 
1630				ret 
1630			 
1630			 
1630			 
1630			endif 
1630			 
1630			; eof 
# End of file firmware_memory.asm
1630			  
1630			; device C  
1630			; Now handled by SPI  
1630			;if SOUND_ENABLE  
1630			;	include "firmware_sound.asm"  
1630			;endif  
1630			  
1630			include "firmware_diags.asm"  
1630			; Hardware diags menu 
1630			 
1630			 
1630			config: 
1630			 
1630 3e 00			ld a, 0 
1632 21 5b 16			ld hl, .configmn 
1635 cd cd 0d			call menu 
1638			 
1638 fe 00			cp 0 
163a c8				ret z 
163b			 
163b			;	cp 1 
163b			;	call z, .savetostore 
163b			 
163b fe 01			cp 1 
163d			if STARTUP_V1 
163d				call z, .selautoload 
163d			endif 
163d			 
163d			if STARTUP_V2 
163d cc 69 16			call z, .enautoload 
1640			endif 
1640 fe 02			cp 2 
1642 cc 80 16			call z, .disautoload 
1645			;	cp 3 
1645			;	call z, .selbank 
1645 fe 03			cp 3 
1647 cc fa 18			call z, .debug_tog 
164a fe 04			cp 4 
164c cc 48 1a			call z, .bpsgo 
164f fe 05			cp 5 
1651 cc 23 19			call z, hardware_diags 
1654			if STARTUP_V2 
1654 fe 06			cp 6 
1656 cc ac 16			call z, create_startup 
1659			endif 
1659 18 d5			jr config 
165b			 
165b			.configmn: 
165b			;	dw prom_c3 
165b 36 1c			dw prom_c2 
165d 4c 1c			dw prom_c2a 
165f			;	dw prom_c2b 
165f			;	dw prom_c4 
165f bb 1c			dw prom_m4 
1661 d6 1c			dw prom_m4b 
1663 de 1c			dw prom_c1 
1665			if STARTUP_V2 
1665 ed 1c			dw prom_c9 
1667			endif 
1667 00 00			dw 0 
1669				 
1669			 
1669			if STARTUP_V2 
1669			.enautoload: 
1669				if STORAGE_SE 
1669 3e fe			ld a, $fe      ; bit 0 clear 
166b 32 5d fa			ld (spi_device), a 
166e			 
166e cd 17 05			call storage_get_block_0 
1671			 
1671 3e 01			ld a, 1 
1673 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1676			 
1676 21 00 00				ld hl, 0 
1679 11 77 fa				ld de, store_page 
167c cd cb 04			call storage_write_block	 ; save update 
167f				else 
167f			 
167f				ld hl, prom_notav 
167f				ld de, prom_empty 
167f				call info_panel 
167f				endif 
167f			 
167f			 
167f c9				ret 
1680			endif 
1680			 
1680			.disautoload: 
1680				if STORAGE_SE 
1680 3e fe			ld a, $fe      ; bit 0 clear 
1682 32 5d fa			ld (spi_device), a 
1685			 
1685 cd 17 05			call storage_get_block_0 
1688			 
1688 3e 00			ld a, 0 
168a 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168d			 
168d 21 00 00				ld hl, 0 
1690 11 77 fa				ld de, store_page 
1693 cd cb 04			call storage_write_block	 ; save update 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696				endif 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			if STARTUP_V1 
1697			 
1697			; Select auto start 
1697			 
1697			.selautoload: 
1697			 
1697				 
1697				if STORAGE_SE 
1697			 
1697					call config_dir 
1697				        ld hl, scratch 
1697					ld a, 0 
1697					call menu 
1697			 
1697					cp 0 
1697					ret z 
1697			 
1697					dec a 
1697			 
1697			 
1697					; locate menu option 
1697			 
1697					ld hl, scratch 
1697					call table_lookup 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALl" 
1697						CALLMONITOR 
1697					endif 
1697					; with the pointer to the menu it, the byte following the zero term is the file id 
1697			 
1697					ld a, 0 
1697					ld bc, 50   ; max of bytes to look at 
1697					cpir  
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALb" 
1697						CALLMONITOR 
1697					endif 
1697					;inc hl 
1697			 
1697					ld a, (hl)   ; file id 
1697					 
1697				        ; save bank and file ids 
1697			 
1697					push af 
1697			 
1697			; TODO need to save to block 0 on bank 1	 
1697			 
1697					call storage_get_block_0 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "AL0" 
1697						CALLMONITOR 
1697					endif 
1697					pop af 
1697			 
1697					ld (store_page+STORE_0_FILERUN),a 
1697					 
1697					; save bank id 
1697			 
1697					ld a,(spi_device) 
1697					ld (store_page+STORE_0_BANKRUN),a 
1697			 
1697					; enable auto run of store file 
1697			 
1697					ld a, 1 
1697					ld (store_page+STORE_0_AUTOFILE),a 
1697			 
1697					; save buffer 
1697			 
1697					ld hl, 0 
1697					ld de, store_page 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALw" 
1697						CALLMONITOR 
1697					endif 
1697				call storage_write_block	 ; save update 
1697			  
1697			 
1697			 
1697			 
1697					ld hl, scratch 
1697					call config_fdir 
1697			 
1697				else 
1697			 
1697				ld hl, prom_notav 
1697				ld de, prom_empty 
1697				call info_panel 
1697			 
1697				endif 
1697				ret 
1697			endif 
1697			 
1697			 
1697			; Select storage bank 
1697			 
1697			.selbank: 
1697			 
1697			;	if STORAGE_SE 
1697			;	else 
1697			 
1697 21 02 1d			ld hl, prom_notav 
169a 11 18 1d			ld de, prom_empty 
169d cd 2d 0d			call info_panel 
16a0			;	endif 
16a0				 
16a0 c9				ret 
16a1			 
16a1			if STORAGE_SE 
16a1			 
16a1			.config_ldir:   
16a1				; Load storage bank labels into menu array 
16a1			 
16a1				 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			 
16a2			endif 
16a2			 
16a2			 
16a2			; Save user words to storage 
16a2			 
16a2			.savetostore: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			; 
16a2			;		call config_dir 
16a2			;	        ld hl, scratch 
16a2			;		ld a, 0 
16a2			;		call menu 
16a2			;		 
16a2			;		ld hl, scratch 
16a2			;		call config_fdir 
16a2			; 
16a2			;	else 
16a2			 
16a2 21 02 1d			ld hl, prom_notav 
16a5 11 18 1d			ld de, prom_empty 
16a8 cd 2d 0d			call info_panel 
16ab			 
16ab			;	endif 
16ab			 
16ab c9				ret 
16ac			 
16ac			if STARTUP_V2 
16ac			 
16ac			create_startup: 
16ac			 
16ac 3e 00			ld a, 0 
16ae 21 21 18			ld hl, .crstart 
16b1 cd cd 0d			call menu 
16b4			 
16b4 fe 00			cp 0 
16b6 c8				ret z 
16b7			 
16b7 fe 01			cp 1 
16b9 cc e6 16			call z, .genlsword 
16bc fe 02			cp 2 
16be cc f0 16			call z, .genedword 
16c1			 
16c1 fe 03			cp 3 
16c3 cc fa 16			call z, .gendemword 
16c6			 
16c6 fe 04			cp 4 
16c8 cc 04 17			call z, .genutlword 
16cb fe 05			cp 5 
16cd cc 0e 17			call z, .genspiword 
16d0 fe 06			cp 6 
16d2 cc 18 17			call z, .genkeyword 
16d5 fe 07			cp 7 
16d7 cc dc 16			call z, .gensoundword 
16da 18 d0			jr create_startup 
16dc			 
16dc			.gensoundword: 
16dc 21 a6 1c			ld hl, crs_sound 
16df 11 65 17			ld de, .soundworddef 
16e2 cd 22 17			call .genfile 
16e5 c9				ret 
16e6			.genlsword: 
16e6 21 63 1c			ld hl, crs_s1 
16e9 11 8d 17			ld de, .lsworddef 
16ec cd 22 17			call .genfile 
16ef c9				ret 
16f0			 
16f0			.genedword: 
16f0 11 91 17			ld de, .edworddef 
16f3 21 6c 1c			ld hl, crs_s2 
16f6 cd 22 17			call .genfile 
16f9 c9				ret 
16fa			 
16fa			.gendemword: 
16fa 11 99 17			ld de, .demoworddef 
16fd 21 75 1c			ld hl, crs_s3 
1700 cd 22 17			call .genfile 
1703 c9				ret 
1704			 
1704			.genutlword: 
1704 21 84 1c			ld hl, crs_s4 
1707 11 79 17			ld de, .utilwordef 
170a cd 22 17			call .genfile 
170d c9				ret 
170e			.genspiword: 
170e 21 8b 1c			ld hl, crs_s5 
1711 11 df 17			ld de, .spiworddef 
1714 cd 22 17			call .genfile 
1717 c9				ret 
1718			.genkeyword: 
1718 21 97 1c			ld hl, crs_s6 
171b 11 f5 17			ld de, .keyworddef 
171e cd 22 17			call .genfile 
1721 c9				ret 
1722			 
1722			; hl - points to file name 
1722			; de - points to strings to add to file 
1722			 
1722			.genfile: 
1722 e5				push hl 
1723 d5				push de 
1724			 
1724 cd 9c 0d			call clear_display 
1727 3e 00			ld a, display_row_1 
1729 11 54 17			ld de, .genfiletxt 
172c cd af 0d			call str_at_display 
172f cd bf 0d			call update_display 
1732			 
1732 d1				pop de 
1733 e1				pop hl 
1734			 
1734			 
1734 d5				push de 
1735 cd 69 08			call storage_create 
1738				; id in hl 
1738 d1				pop de   ; table of strings to add 
1739			 
1739			.genloop: 
1739			 
1739 e5				push hl ; save id for next time around 
173a d5				push de ; save de for next time around 
173b			 
173b eb				ex de, hl 
173c cd 35 24			call loadwordinhl 
173f eb				ex de, hl 
1740			 
1740				; need hl to be the id 
1740				; need de to be the string ptr 
1740				 
1740 cd 56 0b			call storage_append 
1743			 
1743 d1				pop de 
1744 e1				pop hl 
1745			 
1745 13				inc de 
1746 13				inc de 
1747			 
1747 1a				ld a,(de) 
1748 fe 00			cp 0 
174a 20 ed			jr nz, .genloop 
174c 13				inc de 
174d 1a				ld a, (de) 
174e 1b				dec de 
174f fe 00			cp 0 
1751 20 e6			jr nz, .genloop	 
1753			 
1753 c9				ret 
1754			 
1754 .. 00		.genfiletxt:  db "Creating file...",0 
1765			 
1765			.soundworddef: 
1765 13 6a			dw sound1 
1767 37 6a			dw sound2 
1769 67 6a			dw sound3 
176b 8c 6a			dw sound4 
176d 99 6a			dw sound5 
176f a6 6a			dw sound6 
1771 b3 6a			dw sound7 
1773 c0 6a			dw sound8 
1775 d8 6a			dw sound9 
1777 00 00			dw 0 
1779			 
1779			.utilwordef: 
1779 64 63			dw strncpy 
177b 3f 63			dw type 
177d 0b 63			dw clrstack 
177f c4 62			dw longread 
1781 c5 63			dw start1 
1783 d5 63			dw start2 
1785 e6 63			dw start3b 
1787 61 64			dw start3c 
1789 c1 64			dw list 
178b 00 00			dw 0 
178d			 
178d			.lsworddef: 
178d e6 63			dw start3b 
178f 00 00			dw 0 
1791			 
1791			.edworddef: 
1791 4d 5f			dw edit1 
1793 6e 5f			dw edit2 
1795 a3 5f			dw edit3 
1797 00 00			dw 0 
1799			 
1799			.demoworddef: 
1799 09 69			dw test5 
179b 41 69			dw test6 
179d 79 69			dw test7 
179f 8d 69			dw test8 
17a1 b9 69			dw test9 
17a3 cf 69			dw test10 
17a5 ef 6a			dw game1 
17a7 00 6b			dw game1a 
17a9 62 6b			dw game1b 
17ab 97 6b			dw game1c 
17ad cd 6b			dw game1d 
17af fe 6b			dw game1s 
17b1 12 6c			dw game1t 
17b3 27 6c			dw game1f 
17b5 5b 6c			dw game1z 
17b7 9f 6c			dw game1zz 
17b9 08 6d			dw ssv2 
17bb 3e 6d			dw ssv3 
17bd 5a 6d			dw ssv4 
17bf 76 6d			dw ssv5 
17c1 8f 6d			dw ssv1 
17c3 d7 6d			dw ssv1cpm	 
17c5 2e 6e			dw game2b 
17c7 9c 6e			dw game2bf 
17c9 e6 6e			dw game2mba 
17cb 7c 6f			dw game2mbas	 
17cd a1 6f			dw game2mbht 
17cf b0 6f			dw game2mbms 
17d1 be 6f			dw game2mb 
17d3 3b 70			dw game3w 
17d5 69 70			dw game3p 
17d7 87 70			dw game3sc 
17d9 b8 70			dw game3vsi 
17db e4 70			dw game3vs 
17dd 00 00			dw 0 
17df			 
17df			 
17df			.spiworddef: 
17df			 
17df db 5f		    dw spi1 
17e1 34 60		    dw spi2 
17e3 c2 60		    dw spi3 
17e5 6a 60		    dw spi4 
17e7 95 60		    dw spi5 
17e9 28 61		    dw spi6 
17eb 7d 61		    dw spi7 
17ed			 
17ed d5 61		    dw spi8 
17ef f4 61		    dw spi9 
17f1 4c 62		    dw spi10 
17f3 00 00		    dw 0 
17f5			 
17f5			.keyworddef: 
17f5			 
17f5 23 71			dw keyup 
17f7 31 71			dw keydown 
17f9 41 71			dw keyleft 
17fb 51 71			dw keyright 
17fd 62 71			dw 	keyf1 
17ff 70 71			dw keyf2 
1801 7e 71			dw keyf3 
1803 8c 71			dw keyf4 
1805 9a 71			dw keyf5 
1807 a8 71			dw keyf6 
1809 b6 71			dw keyf7 
180b c4 71			dw keyf8 
180d d2 71			dw keyf9 
180f e0 71			dw keyf10 
1811 ef 71			dw keyf11 
1813 fe 71			dw keyf12 
1815 0d 72			dw keytab 
1817 1c 72			dw keycr 
1819 2a 72			dw keyhome 
181b 3a 72			dw keyend 
181d 49 72			dw keybs 
181f 00 00			dw 0 
1821			 
1821			.crstart: 
1821 63 1c			dw crs_s1 
1823 6c 1c			dw crs_s2 
1825 75 1c			dw crs_s3 
1827 84 1c			dw crs_s4 
1829 8b 1c			dw crs_s5 
182b 97 1c			dw crs_s6 
182d a6 1c			dw crs_sound 
182f 00 00			dw 0 
1831			 
1831			endif 
1831			 
1831			 
1831			if STORAGE_SE 
1831			 
1831			config_fdir: 
1831				; using the scratch dir go through and release the memory allocated for each string 
1831				 
1831 21 be f1			ld hl, scratch 
1834 5e			.cfdir:	ld e,(hl) 
1835 23				inc hl 
1836 56				ld d,(hl) 
1837 23				inc hl 
1838			 
1838 eb				ex de, hl 
1839 cd f9 0f			call ishlzero 
183c c8				ret z     ; return on null pointer 
183d cd 61 15			call free 
1840 eb				ex de, hl 
1841 18 f1			jr .cfdir 
1843			 
1843			 
1843 c9				ret 
1844			 
1844			 
1844			config_dir: 
1844			 
1844				; for the config menus that need to build a directory of storage call this routine 
1844				; it will construct a menu in scratch to pass to menu 
1844			 
1844				; open storage device 
1844			 
1844				; execute DIR to build a list of files and their ids into scratch in menu format 
1844				; once the menu has finished then will need to call config_fdir to release the strings 
1844				 
1844				; c = number items 
1844			 
1844				 
1844 cd 17 05			call storage_get_block_0 
1847			 
1847 21 77 fa			ld hl, store_page     ; get current id count 
184a 46				ld b, (hl) 
184b 0e 00			ld c, 0    ; count of files   
184d			 
184d			 
184d 21 be f1			ld hl, scratch 
1850 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
1853			 
1853				; check for empty drive 
1853			 
1853 3e 00			ld a, 0 
1855 b8				cp b 
1856 ca f0 18			jp z, .dirdone 
1859			 
1859				 
1859					if DEBUG_FORTH_WORDS 
1859						DMARK "Cdc" 
1859 f5				push af  
185a 3a 6e 18			ld a, (.dmark)  
185d 32 68 fe			ld (debug_mark),a  
1860 3a 6f 18			ld a, (.dmark+1)  
1863 32 69 fe			ld (debug_mark+1),a  
1866 3a 70 18			ld a, (.dmark+2)  
1869 32 6a fe			ld (debug_mark+2),a  
186c 18 03			jr .pastdmark  
186e ..			.dmark: db "Cdc"  
1871 f1			.pastdmark: pop af  
1872			endm  
# End of macro DMARK
1872						CALLMONITOR 
1872 cd 6c fe			call debug_vector  
1875				endm  
# End of macro CALLMONITOR
1875					endif 
1875			 
1875			 
1875			.diritem:	 
1875 c5				push bc 
1876				; for each of the current ids do a search for them and if found push to stack 
1876			 
1876 21 40 00				ld hl, STORE_BLOCK_PHY 
1879 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
187b 58					ld e,b 
187c			 
187c cd 99 07				call storage_findnextid 
187f			 
187f			 
187f					; if found hl will be non zero 
187f			 
187f cd f9 0f				call ishlzero 
1882 28 69				jr z, .dirnotfound 
1884			 
1884					; increase count 
1884			 
1884 c1					pop bc	 
1885 0c					inc c 
1886 c5					push bc 
1887					 
1887			 
1887					; get file header and push the file name 
1887			 
1887 11 77 fa				ld de, store_page 
188a cd 66 04				call storage_read_block 
188d			 
188d					; push file id to stack 
188d				 
188d 3a 77 fa				ld a, (store_page) 
1890 26 00				ld h, 0 
1892 6f					ld l, a 
1893			 
1893					;call forth_push_numhl 
1893					; TODO store id 
1893			 
1893 e5					push hl 
1894			 
1894					; push extent count to stack  
1894				 
1894 21 7a fa				ld hl, store_page+3 
1897			 
1897					; get file name length 
1897			 
1897 cd 2e 14				call strlenz   
189a			 
189a 23					inc hl   ; cover zero term 
189b 23					inc hl  ; stick the id at the end of the area 
189c			 
189c e5					push hl 
189d c1					pop bc    ; move length to bc 
189e			 
189e cd 97 14				call malloc 
18a1			 
18a1					; TODO save malloc area to scratch 
18a1			 
18a1 eb					ex de, hl 
18a2 2a 6e fa				ld hl, (store_tmp2) 
18a5 73					ld (hl), e 
18a6 23					inc hl 
18a7 72					ld (hl), d 
18a8 23					inc hl 
18a9 22 6e fa				ld (store_tmp2), hl 
18ac			 
18ac					 
18ac			 
18ac					;pop hl   ; get source 
18ac			;		ex de, hl    ; swap aronund	 
18ac			 
18ac 21 7a fa				ld hl, store_page+3 
18af					if DEBUG_FORTH_WORDS 
18af						DMARK "CFd" 
18af f5				push af  
18b0 3a c4 18			ld a, (.dmark)  
18b3 32 68 fe			ld (debug_mark),a  
18b6 3a c5 18			ld a, (.dmark+1)  
18b9 32 69 fe			ld (debug_mark+1),a  
18bc 3a c6 18			ld a, (.dmark+2)  
18bf 32 6a fe			ld (debug_mark+2),a  
18c2 18 03			jr .pastdmark  
18c4 ..			.dmark: db "CFd"  
18c7 f1			.pastdmark: pop af  
18c8			endm  
# End of macro DMARK
18c8						CALLMONITOR 
18c8 cd 6c fe			call debug_vector  
18cb				endm  
# End of macro CALLMONITOR
18cb					endif 
18cb ed b0				ldir 
18cd			 
18cd					; de is past string, move back one and store id 
18cd					 
18cd 1b					dec de 
18ce			 
18ce					; store file id 
18ce			 
18ce e1					pop hl 
18cf eb					ex de,hl 
18d0 73					ld (hl), e 
18d1			 
18d1					if DEBUG_FORTH_WORDS 
18d1						DMARK "Cdi" 
18d1 f5				push af  
18d2 3a e6 18			ld a, (.dmark)  
18d5 32 68 fe			ld (debug_mark),a  
18d8 3a e7 18			ld a, (.dmark+1)  
18db 32 69 fe			ld (debug_mark+1),a  
18de 3a e8 18			ld a, (.dmark+2)  
18e1 32 6a fe			ld (debug_mark+2),a  
18e4 18 03			jr .pastdmark  
18e6 ..			.dmark: db "Cdi"  
18e9 f1			.pastdmark: pop af  
18ea			endm  
# End of macro DMARK
18ea						CALLMONITOR 
18ea cd 6c fe			call debug_vector  
18ed				endm  
# End of macro CALLMONITOR
18ed					endif 
18ed					 
18ed			.dirnotfound: 
18ed c1					pop bc     
18ee 10 85				djnz .diritem 
18f0				 
18f0			.dirdone:	 
18f0			 
18f0 3e 00				ld a, 0 
18f2 2a 6e fa				ld hl, (store_tmp2) 
18f5 77					ld (hl), a 
18f6 23					inc hl 
18f7 77					ld (hl), a 
18f8 23					inc hl 
18f9					; push a count of the dir items found 
18f9			 
18f9			;		ld h, 0 
18f9			;		ld l, c 
18f9			 
18f9 c9				ret 
18fa			 
18fa			endif 
18fa			 
18fa			 
18fa			; Settings 
18fa			; Run  
18fa			 
18fa			 
18fa			 
18fa			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18fa			;;hd_menu2:   db "        2: Editor",0   
18fa			;hd_menu2:   db "        2: Editor       6: Menu",0   
18fa			;hd_menu3:   db "        3: Storage",0 
18fa			;hd_menu4:   db "0=quit  4: Debug",0 
18fa			;hd_don:     db "ON",0 
18fa			;hd_doff:     db "OFF",0 
18fa			; 
18fa			; 
18fa			; 
18fa			;hardware_diags_old:       
18fa			; 
18fa			;.diagmenu: 
18fa			;	call clear_display 
18fa			;	ld a, display_row_1 
18fa			;	ld de, hd_menu1 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_2 
18fa			;	ld de, hd_menu2 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_3 
18fa			;	ld de, hd_menu3 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a,  display_row_4 
18fa			;	ld de, hd_menu4 
18fa			;	call str_at_display 
18fa			; 
18fa			;	; display debug state 
18fa			; 
18fa			;	ld de, hd_don 
18fa			;	ld a, (os_view_disable) 
18fa			;	cp 0 
18fa			;	jr z, .distog 
18fa			;	ld de, hd_doff 
18fa			;.distog: ld a, display_row_4+17 
18fa			;	call str_at_display 
18fa			; 
18fa			;	call update_display 
18fa			; 
18fa			;	call cin_wait 
18fa			; 
18fa			; 
18fa			; 
18fa			;	cp '4' 
18fa			;	jr nz, .diagn1 
18fa			; 
18fa			;	; debug toggle 
18fa			; 
18fa			;	ld a, (os_view_disable) 
18fa			;	ld b, '*' 
18fa			;	cp 0 
18fa			;	jr z, .debtog 
18fa			;	ld b, 0 
18fa			;.debtog:	 
18fa			;	ld a,b 
18fa			;	ld (os_view_disable),a 
18fa			; 
18fa			;.diagn1: cp '0' 
18fa			;	 ret z 
18fa			; 
18fa			;;	cp '1' 
18fa			;;       jp z, matrix	 
18fa			;;   TODO keyboard matrix test 
18fa			; 
18fa			;	cp '2' 
18fa			;	jp z, .diagedit 
18fa			; 
18fa			;;	cp '6' 
18fa			;;	jp z, .menutest 
18fa			;;if ENABLE_BASIC 
18fa			;;	cp '6' 
18fa			;;	jp z, basic 
18fa			;;endif 
18fa			 ; 
18fa			;	jp .diagmenu 
18fa			; 
18fa			; 
18fa			;	ret 
18fa			 
18fa			 
18fa			.debug_tog: 
18fa 21 44 19			ld hl, .menudebug 
18fd				 
18fd			;	ld a, (os_view_disable) 
18fd			;	cp '*' 
18fd 3a 6c fe			ld a,(debug_vector) 
1900 fe c9			cp $C9   ; RET 
1902 20 04			jr nz,.tdon  
1904 3e 01			ld a, 1 
1906 18 02			jr .tog1 
1908 3e 00		.tdon: ld a, 0 
190a			 
190a			.tog1: 
190a cd cd 0d			call menu 
190d fe 00			cp 0 
190f c8				ret z 
1910 fe 01			cp 1    ; disable debug 
1912 28 04			jr z, .dtog0 
1914 3e 2a			ld a, '*' 
1916 18 05			jr .dtogset 
1918			.dtog0:  
1918				;ld a, 0 
1918 cd 36 1a			call bp_on 
191b 18 dd			jr .debug_tog 
191d			.dtogset:  
191d				; ld (os_view_disable), a 
191d cd 42 1a			call bp_off 
1920 c3 fa 18			jp .debug_tog 
1923			 
1923			 
1923			hardware_diags:       
1923			 
1923			.diagm: 
1923 21 36 19			ld hl, .menuitems 
1926 3e 00			ld a, 0 
1928 cd cd 0d			call menu 
192b			 
192b fe 00		         cp 0 
192d c8				 ret z 
192e			 
192e fe 02			cp 2 
1930 ca 8f 19			jp z, .diagedit 
1933			 
1933			;	cp '6' 
1933			;	jp z, .menutest 
1933			;if ENABLE_BASIC 
1933			;	cp '6' 
1933			;	jp z, basic 
1933			;endif 
1933			  
1933 c3 23 19			jp .diagm 
1936			 
1936				 
1936 4a 19		.menuitems:   	dw .m1 
1938 55 19				dw .m2 
193a 5c 19				dw .m3 
193c 64 19				dw .m5 
193e 6a 19				dw .m5a 
1940 73 19				dw .m5b 
1942 00 00				dw 0 
1944			 
1944			.menudebug: 
1944 7c 19				dw .m6 
1946 85 19				dw .m7 
1948 00 00				dw 0 
194a			 
194a .. 00		.m1:   db "Key Matrix",0 
1955 .. 00		.m2:   db "Editor",0 
195c .. 00		.m3:   db "Storage",0 
1964 .. 00		.m5:   db "Sound",0 
196a .. 00		.m5a:  db "RAM Test",0 
1973 .. 00		.m5b:  db "LCD Test",0 
197c			 
197c .. 00		.m6:   db "Debug ON",0 
1985 .. 00		.m7:   db "Debug OFF",0 
198f			 
198f			; debug editor 
198f			 
198f			.diagedit: 
198f			 
198f 21 be f1			ld hl, scratch 
1992			;	ld bc, 250 
1992			;	ldir 
1992				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1992 3e 00			ld a, 0 
1994 77				ld (hl), a 
1995 23				inc hl 
1996 77				ld (hl), a 
1997 23				inc hl 
1998 77				ld (hl), a 
1999			 
1999 cd 9c 0d		        call clear_display 
199c cd bf 0d			call update_display 
199f				;ld a, 1 
199f				;ld (hardware_diag), a 
199f			.diloop: 
199f 3e 00			ld a, display_row_1 
19a1 0e 00			ld c, 0 
19a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a5 1e 28			ld e, 40 
19a7			 
19a7 21 be f1			ld hl, scratch	 
19aa cd fd 0f			call input_str 
19ad			 
19ad 3e 28			ld a, display_row_2 
19af 11 be f1			ld de, scratch 
19b2 cd af 0d			call str_at_display 
19b5 cd bf 0d			call update_display 
19b8			 
19b8 c3 9f 19			jp .diloop 
19bb			 
19bb			 
19bb			; pass word in hl 
19bb			; a has display location 
19bb			display_word_at: 
19bb f5				push af 
19bc e5				push hl 
19bd 7c				ld a,h 
19be 21 c3 f4			ld hl, os_word_scratch 
19c1 cd d1 12			call hexout 
19c4 e1				pop hl 
19c5 7d				ld a,l 
19c6 21 c5 f4			ld hl, os_word_scratch+2 
19c9 cd d1 12			call hexout 
19cc 21 c7 f4			ld hl, os_word_scratch+4 
19cf 3e 00			ld a,0 
19d1 77				ld (hl),a 
19d2 11 c3 f4			ld de,os_word_scratch 
19d5 f1				pop af 
19d6 cd af 0d				call str_at_display 
19d9 c9				ret 
19da			 
19da			display_ptr_state: 
19da			 
19da				; to restore afterwards 
19da			 
19da d5				push de 
19db c5				push bc 
19dc e5				push hl 
19dd f5				push af 
19de			 
19de				; for use in here 
19de			 
19de			;	push bc 
19de			;	push de 
19de			;	push hl 
19de			;	push af 
19de			 
19de cd 9c 0d			call clear_display 
19e1			 
19e1 11 b9 1b			ld de, .ptrstate 
19e4 3e 00			ld a, display_row_1 
19e6 cd af 0d			call str_at_display 
19e9			 
19e9				; display debug step 
19e9			 
19e9			 
19e9 11 68 fe			ld de, debug_mark 
19ec 3e 26			ld a, display_row_1+display_cols-2 
19ee cd af 0d			call str_at_display 
19f1			 
19f1				; display a 
19f1 11 c3 1b			ld de, .ptrcliptr 
19f4 3e 28			ld a, display_row_2 
19f6 cd af 0d			call str_at_display 
19f9			 
19f9 f1				pop af 
19fa 2a 3d fa			ld hl,(cli_ptr) 
19fd 3e 30			ld a, display_row_2+8 
19ff cd bb 19			call display_word_at 
1a02			 
1a02			 
1a02				; display hl 
1a02			 
1a02			 
1a02 11 cb 1b			ld de, .ptrclioptr 
1a05 3e 32			ld a, display_row_2+10 
1a07 cd af 0d			call str_at_display 
1a0a			; 
1a0a			;	pop hl 
1a0a 3e 35			ld a, display_row_2+13 
1a0c 2a 3b fa			ld hl,(cli_origptr) 
1a0f cd bb 19			call display_word_at 
1a12			; 
1a12			;	 
1a12			;	; display de 
1a12			 
1a12			;	ld de, .regstatede 
1a12			;	ld a, display_row_3 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop de 
1a12			;	ld h,d 
1a12			;	ld l, e 
1a12			;	ld a, display_row_3+3 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12			;	ld de, .regstatebc 
1a12			;	ld a, display_row_3+10 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop bc 
1a12			;	ld h,b 
1a12			;	ld l, c 
1a12			;	ld a, display_row_3+13 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display dsp 
1a12			 
1a12			;	ld de, .regstatedsp 
1a12			;	ld a, display_row_4 
1a12			;	call str_at_display 
1a12			 
1a12				 
1a12			;	ld hl,(cli_data_sp) 
1a12			;	ld a, display_row_4+4 
1a12			;	call display_word_at 
1a12			 
1a12				; display rsp 
1a12			 
1a12 11 fa 1b			ld de, .regstatersp 
1a15 3e 82			ld a, display_row_4+10 
1a17 cd af 0d			call str_at_display 
1a1a			 
1a1a				 
1a1a 2a ef f9			ld hl,(cli_ret_sp) 
1a1d 3e 86			ld a, display_row_4+14 
1a1f cd bb 19			call display_word_at 
1a22			 
1a22 cd bf 0d			call update_display 
1a25			 
1a25 cd df 0c			call delay1s 
1a28 cd df 0c			call delay1s 
1a2b cd df 0c			call delay1s 
1a2e			 
1a2e			 
1a2e cd 7e 20			call next_page_prompt 
1a31			 
1a31				; restore  
1a31			 
1a31 f1				pop af 
1a32 e1				pop hl 
1a33 c1				pop bc 
1a34 d1				pop de 
1a35 c9				ret 
1a36			 
1a36			; Update the break point vector so that the user can hook a new routine 
1a36			 
1a36			bp_on: 
1a36 3e c3			ld a, $c3    ; JP 
1a38 32 6c fe			ld (debug_vector), a 
1a3b 21 48 1a			ld hl, break_point_state 
1a3e 22 6d fe			ld (debug_vector+1), hl 
1a41 c9				ret 
1a42			 
1a42			bp_off: 
1a42 3e c9			ld a, $c9    ; RET 
1a44 32 6c fe			ld (debug_vector), a 
1a47 c9				ret 
1a48			 
1a48			 
1a48			break_point_state: 
1a48			;	push af 
1a48			; 
1a48			;	; see if disabled 
1a48			; 
1a48			;	ld a, (os_view_disable) 
1a48			;	cp '*' 
1a48			;	jr nz, .bpsgo 
1a48			;	pop af 
1a48			;	ret 
1a48			 
1a48			.bpsgo: 
1a48			;	pop af 
1a48 f5				push af 
1a49 22 a0 f1			ld (os_view_hl), hl 
1a4c ed 53 9e f1		ld (os_view_de), de 
1a50 ed 43 9c f1		ld (os_view_bc), bc 
1a54 e5				push hl 
1a55 6f				ld l, a 
1a56 26 00			ld h, 0 
1a58 22 a2 f1			ld (os_view_af),hl 
1a5b			 
1a5b 21 ae fd				ld hl, display_fb0 
1a5e 22 c9 fb				ld (display_fb_active), hl 
1a61 e1				pop hl	 
1a62			 
1a62 3e 31			ld a, '1' 
1a64 fe 2a		.bps1:  cp '*' 
1a66 cc 42 1a			call z, bp_off 
1a69			;	jr nz, .bps1b 
1a69			;	ld (os_view_disable),a 
1a69 fe 31		.bps1b:  cp '1' 
1a6b 20 14			jr nz, .bps2 
1a6d			 
1a6d				; display reg 
1a6d			 
1a6d				 
1a6d			 
1a6d 3a a2 f1			ld a, (os_view_af) 
1a70 2a a0 f1			ld hl, (os_view_hl) 
1a73 ed 5b 9e f1		ld de, (os_view_de) 
1a77 ed 4b 9c f1		ld bc, (os_view_bc) 
1a7b cd 15 1b			call display_reg_state 
1a7e c3 01 1b			jp .bpschk 
1a81			 
1a81 fe 32		.bps2:  cp '2' 
1a83 20 08			jr nz, .bps3 
1a85				 
1a85				; display hl 
1a85 2a a0 f1			ld hl, (os_view_hl) 
1a88 cd ff 1b			call display_dump_at_hl 
1a8b			 
1a8b 18 74			jr .bpschk 
1a8d			 
1a8d fe 33		.bps3:  cp '3' 
1a8f 20 08			jr nz, .bps4 
1a91			 
1a91			        ; display de 
1a91 2a 9e f1			ld hl, (os_view_de) 
1a94 cd ff 1b			call display_dump_at_hl 
1a97			 
1a97 18 68			jr .bpschk 
1a99 fe 34		.bps4:  cp '4' 
1a9b 20 08			jr nz, .bps5 
1a9d			 
1a9d			        ; display bc 
1a9d 2a 9c f1			ld hl, (os_view_bc) 
1aa0 cd ff 1b			call display_dump_at_hl 
1aa3			 
1aa3 18 5c			jr .bpschk 
1aa5 fe 35		.bps5:  cp '5' 
1aa7 20 08		        jr nz, .bps7 
1aa9			 
1aa9				; display cur ptr 
1aa9 2a 3d fa			ld hl, (cli_ptr) 
1aac cd ff 1b			call display_dump_at_hl 
1aaf			 
1aaf 18 50			jr .bpschk 
1ab1 fe 36		.bps7:  cp '6' 
1ab3 20 08			jr nz, .bps8b 
1ab5				 
1ab5				; display cur orig ptr 
1ab5 2a 3b fa			ld hl, (cli_origptr) 
1ab8 cd ff 1b			call display_dump_at_hl 
1abb 18 44			jr .bpschk 
1abd fe 37		.bps8b:  cp '7' 
1abf 20 08			jr nz, .bps9 
1ac1				 
1ac1				; display dsp 
1ac1 2a eb f9			ld hl, (cli_data_sp) 
1ac4 cd ff 1b			call display_dump_at_hl 
1ac7			 
1ac7 18 38			jr .bpschk 
1ac9 fe 39		.bps9:  cp '9' 
1acb 20 05			jr nz, .bps8c 
1acd				 
1acd				; display SP 
1acd			;	ld hl, sp 
1acd cd ff 1b			call display_dump_at_hl 
1ad0			 
1ad0 18 2f			jr .bpschk 
1ad2 fe 38		.bps8c:  cp '8' 
1ad4 20 08			jr nz, .bps8d 
1ad6				 
1ad6				; display rsp 
1ad6 2a ef f9			ld hl, (cli_ret_sp) 
1ad9 cd ff 1b			call display_dump_at_hl 
1adc			 
1adc 18 23			jr .bpschk 
1ade fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ae0 20 05			jr nz, .bps8 
1ae2 cd 4c 1e			call monitor 
1ae5			 
1ae5 18 1a			jr .bpschk 
1ae7 fe 30		.bps8:  cp '0' 
1ae9 20 16			jr nz, .bpschk 
1aeb			 
1aeb 21 0d fd				ld hl, display_fb1 
1aee 22 c9 fb				ld (display_fb_active), hl 
1af1 cd bf 0d				call update_display 
1af4			 
1af4				;ld a, (os_view_af) 
1af4 2a a0 f1			ld hl, (os_view_hl) 
1af7 ed 5b 9e f1		ld de, (os_view_de) 
1afb ed 4b 9c f1		ld bc, (os_view_bc) 
1aff f1				pop af 
1b00 c9				ret 
1b01			 
1b01			.bpschk:   
1b01 cd df 0c			call delay1s 
1b04 3e 9f		ld a,display_row_4 + display_cols - 1 
1b06 11 7c 20		        ld de, endprg 
1b09 cd af 0d			call str_at_display 
1b0c cd bf 0d			call update_display 
1b0f cd c4 79			call cin_wait 
1b12			 
1b12 c3 64 1a			jp .bps1 
1b15			 
1b15			 
1b15			display_reg_state: 
1b15			 
1b15				; to restore afterwards 
1b15			 
1b15 d5				push de 
1b16 c5				push bc 
1b17 e5				push hl 
1b18 f5				push af 
1b19			 
1b19				; for use in here 
1b19			 
1b19 c5				push bc 
1b1a d5				push de 
1b1b e5				push hl 
1b1c f5				push af 
1b1d			 
1b1d cd 9c 0d			call clear_display 
1b20			 
1b20 11 d5 1b			ld de, .regstate 
1b23 3e 00			ld a, display_row_1 
1b25 cd af 0d			call str_at_display 
1b28			 
1b28				; display debug step 
1b28			 
1b28			 
1b28 11 68 fe			ld de, debug_mark 
1b2b 3e 25			ld a, display_row_1+display_cols-3 
1b2d cd af 0d			call str_at_display 
1b30			 
1b30				; display a 
1b30 11 f1 1b			ld de, .regstatea 
1b33 3e 28			ld a, display_row_2 
1b35 cd af 0d			call str_at_display 
1b38			 
1b38 e1				pop hl 
1b39			;	ld h,0 
1b39			;	ld l, a 
1b39 3e 2b			ld a, display_row_2+3 
1b3b cd bb 19			call display_word_at 
1b3e			 
1b3e			 
1b3e				; display hl 
1b3e			 
1b3e			 
1b3e 11 e5 1b			ld de, .regstatehl 
1b41 3e 32			ld a, display_row_2+10 
1b43 cd af 0d			call str_at_display 
1b46			 
1b46 e1				pop hl 
1b47 3e 35			ld a, display_row_2+13 
1b49 cd bb 19			call display_word_at 
1b4c			 
1b4c				 
1b4c				; display de 
1b4c			 
1b4c 11 e9 1b			ld de, .regstatede 
1b4f 3e 50			ld a, display_row_3 
1b51 cd af 0d			call str_at_display 
1b54			 
1b54 e1				pop hl 
1b55			;	ld h,d 
1b55			;	ld l, e 
1b55 3e 53			ld a, display_row_3+3 
1b57 cd bb 19			call display_word_at 
1b5a			 
1b5a			 
1b5a				; display bc 
1b5a			 
1b5a 11 ed 1b			ld de, .regstatebc 
1b5d 3e 5a			ld a, display_row_3+10 
1b5f cd af 0d			call str_at_display 
1b62			 
1b62 e1				pop hl 
1b63			;	ld h,b 
1b63			;	ld l, c 
1b63 3e 5d			ld a, display_row_3+13 
1b65 cd bb 19			call display_word_at 
1b68			 
1b68			 
1b68				; display dsp 
1b68			 
1b68 11 f5 1b			ld de, .regstatedsp 
1b6b 3e 78			ld a, display_row_4 
1b6d cd af 0d			call str_at_display 
1b70			 
1b70				 
1b70 2a eb f9			ld hl,(cli_data_sp) 
1b73 3e 7c			ld a, display_row_4+4 
1b75 cd bb 19			call display_word_at 
1b78			 
1b78				; display rsp 
1b78			 
1b78 11 fa 1b			ld de, .regstatersp 
1b7b 3e 82			ld a, display_row_4+10 
1b7d cd af 0d			call str_at_display 
1b80			 
1b80				 
1b80 2a ef f9			ld hl,(cli_ret_sp) 
1b83 3e 86			ld a, display_row_4+14 
1b85 cd bb 19			call display_word_at 
1b88			 
1b88 cd bf 0d			call update_display 
1b8b			 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			 
1b8b			 
1b8b			;	call next_page_prompt 
1b8b			 
1b8b				; restore  
1b8b			 
1b8b f1				pop af 
1b8c e1				pop hl 
1b8d c1				pop bc 
1b8e d1				pop de 
1b8f c9				ret 
1b90			 
1b90 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb9 .. 00		.ptrstate:	db "Ptr State",0 
1bc3 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bcb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd5 .. 00		.regstate:	db "Reg State (1/0)",0 
1be5 .. 00		.regstatehl:	db "HL:",0 
1be9 .. 00		.regstatede:	db "DE:",0 
1bed .. 00		.regstatebc:	db "BC:",0 
1bf1 .. 00		.regstatea:	db "A :",0 
1bf5 .. 00		.regstatedsp:	db "DSP:",0 
1bfa .. 00		.regstatersp:	db "RSP:",0 
1bff			 
1bff			display_dump_at_hl: 
1bff e5				push hl 
1c00 d5				push de 
1c01 c5				push bc 
1c02 f5				push af 
1c03			 
1c03 22 e1 f4			ld (os_cur_ptr),hl	 
1c06 cd 9c 0d			call clear_display 
1c09 cd 86 1f			call dumpcont 
1c0c			;	call delay1s 
1c0c			;	call next_page_prompt 
1c0c			 
1c0c			 
1c0c f1				pop af 
1c0d c1				pop bc 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10 c9				ret 
1c11			 
1c11			;if ENABLE_BASIC 
1c11			;	include "nascombasic.asm" 
1c11			;	basic: 
1c11			;	include "forth/FORTH.ASM" 
1c11			;endif 
1c11			 
1c11			; eof 
1c11			 
1c11			 
# End of file firmware_diags.asm
1c11			  
1c11			include "firmware_prompts.asm"  
1c11			; Prompts  
1c11			 
1c11			; boot messages 
1c11			 
1c11 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c26 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c36			 
1c36			 
1c36			; config menus 
1c36			 
1c36			;prom_c3: db "Add Dictionary To File",0 
1c36			 
1c36			if STARTUP_V1 
1c36			prom_c2: db "Select Autoload File",0 
1c36			prom_c2a: db "Disable Autoload File", 0 
1c36			endif 
1c36			 
1c36			if STARTUP_V2 
1c36 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4c .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c63			 
1c63 .. 00		crs_s1: db "*ls-word", 0 
1c6c .. 00		crs_s2: db "*ed-word", 0 
1c75 .. 00		crs_s3: db "*Demo-Programs", 0 
1c84 .. 00		crs_s4: db "*Utils", 0 
1c8b .. 00		crs_s5: db "*SPI-Addons", 0 
1c97 .. 00		crs_s6: db "*Key-constants", 0 
1ca6 .. 00		crs_sound: db "*Sound-Util", 0 
1cb2			 
1cb2			 
1cb2			 
1cb2			endif 
1cb2			;prom_c2b: db "Select Storage Bank",0 
1cb2 .. 00		prom_c4: db "Settings",0 
1cbb .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd6 .. 00		prom_m4b:   db "Monitor",0 
1cde .. 00		prom_c1: db "Hardware Diags",0 
1ced			 
1ced			 
1ced			if STARTUP_V2 
1ced .. 00		prom_c9: db "Create Startup Files",0 
1d02			endif 
1d02			 
1d02 .. 00		prom_notav:    db "Feature not available",0 
1d18 .. 00		prom_empty:    db "",0 
1d19			 
1d19			; eof 
1d19			 
# End of file firmware_prompts.asm
1d19			  
1d19			  
1d19			; eof  
1d19			  
# End of file firmware.asm
1d19			 
1d19			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d19			;if BASE_KEV  
1d19			;baseram: equ 08000h 
1d19			;endif 
1d19			 
1d19			;if BASE_SC114 
1d19			;baseram:     equ    endofcode 
1d19			;endif 
1d19			 
1d19			 
1d19			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d19			 
1d19			; start system 
1d19			 
1d19			coldstart: 
1d19				; set sp 
1d19				; di/ei 
1d19			 
1d19 f3				di 
1d1a 31 fd ff			ld sp, tos 
1d1d cd 4b 76			call init_nmi 
1d20			;	ei 
1d20			 
1d20				; init spinner 
1d20 3e 00			ld a,0 
1d22 32 c3 fb			ld (display_active), a 
1d25			 
1d25				; disable breakpoint by default 
1d25			 
1d25				;ld a,'*' 
1d25			;	ld a,' ' 
1d25			;	ld (os_view_disable),a 
1d25			 
1d25				; set break point vector as new break point on or off 
1d25 cd 42 1a			call bp_off 
1d28			 
1d28				; init hardware 
1d28			 
1d28				; init keyboard and screen hardware 
1d28			 
1d28 cd 69 00			call hardware_init 
1d2b			 
1d2b			 
1d2b cd df 0c			call delay1s 
1d2e 3e 58			ld a, display_row_3+8 
1d30 11 03 00			ld de, buildtime 
1d33 cd af 0d			call str_at_display 
1d36 cd bf 0d			call update_display 
1d39			 
1d39 cd df 0c			call delay1s 
1d3c cd df 0c			call delay1s 
1d3f cd df 0c			call delay1s 
1d42			 
1d42				; detect if any keys are held down to enable breakpoints at start up 
1d42			 
1d42 cd d5 79			call cin  
1d45 fe 00			cp 0 
1d47 28 03			jr z, .nokeys 
1d49			 
1d49				;call hardware_diags 
1d49 cd 30 16			call config 
1d4c			 
1d4c			;	ld de, .bpen 
1d4c			;	ld a, display_row_4 
1d4c			;	call str_at_display 
1d4c			;	call update_display 
1d4c			; 
1d4c			;	ld a,0 
1d4c			;	ld (os_view_disable),a 
1d4c			; 
1d4c			;.bpwait: 
1d4c			;	call cin 
1d4c			;	cp 0 
1d4c			;	jr z, .bpwait 
1d4c			;	jr .nokeys 
1d4c			; 
1d4c			; 
1d4c			;.bpen:  db "Break points enabled!",0 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			.nokeys: 
1d4c			 
1d4c			 
1d4c				 
1d4c			 
1d4c			;jp  testkey 
1d4c			 
1d4c			;call storage_get_block_0 
1d4c			; 
1d4c			;ld hl, 0 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c				 
1d4c			;ld hl, 10 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			;stop:	nop 
1d4c			;	jp stop 
1d4c			 
1d4c			 
1d4c			 
1d4c			main: 
1d4c cd 9c 0d			call clear_display 
1d4f cd bf 0d			call update_display 
1d52			 
1d52			 
1d52			 
1d52			;	call testlcd 
1d52			 
1d52			 
1d52			 
1d52 cd 83 24			call forth_init 
1d55			 
1d55			 
1d55			warmstart: 
1d55 cd 59 24			call forth_warmstart 
1d58			 
1d58				; run startup word load 
1d58			        ; TODO prevent this running at warmstart after crash  
1d58			 
1d58				if STARTUP_ENABLE 
1d58			 
1d58					if STARTUP_V1 
1d58			 
1d58						if STORAGE_SE 
1d58							call forth_autoload 
1d58						endif 
1d58						call forth_startup 
1d58					endif 
1d58			 
1d58					if STARTUP_V2 
1d58			 
1d58						if STORAGE_SE 
1d58 cd 79 74						call forth_autoload 
1d5b						else 
1d5b							call forth_startup 
1d5b						endif 
1d5b			 
1d5b			 
1d5b					endif 
1d5b			 
1d5b				endif 
1d5b			 
1d5b				; show free memory after boot 
1d5b 11 e7 1d			ld de, freeram 
1d5e 3e 00			ld a, display_row_1 
1d60 cd af 0d			call str_at_display 
1d63			 
1d63				; get current heap start after loading any uwords 
1d63			 
1d63				;ld de, (os_last_new_uword) 
1d63				;ex de, hl 
1d63			 
1d63			; Or use heap_size word???? 
1d63				;ld hl, heap_end 
1d63				;ld hl, heap_size 
1d63				;ld de, topusermem 
1d63				;ld de, heap_start 
1d63 ed 5b 0a 80			ld de, (free_list )      
1d67 21 99 f1				ld hl, heap_end 
1d6a ed 52			sbc hl, de 
1d6c				;push hl 
1d6c				;ld a,h	         	 
1d6c				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d6c				;call hexout 
1d6c			   	;pop hl 
1d6c			; 
1d6c			;	ld a,l 
1d6c			;	ld hl, os_word_scratch+2 
1d6c			;	call hexout 
1d6c			;	ld hl, os_word_scratch+4 
1d6c			;	ld a, 0 
1d6c			;	ld (hl),a 
1d6c eb				ex de, hl 
1d6d 21 c3 f4			ld hl, os_word_scratch 
1d70 cd dd 13			call uitoa_16 
1d73			 
1d73			 
1d73 11 c3 f4			ld de, os_word_scratch 
1d76 3e 0d			ld a, display_row_1 + 13 
1d78 cd af 0d			call str_at_display 
1d7b cd bf 0d			call update_display 
1d7e			 
1d7e			 
1d7e				;call demo 
1d7e			 
1d7e			 
1d7e				; init scratch input area for cli commands 
1d7e			 
1d7e 21 e5 f4			ld hl, os_cli_cmd 
1d81 3e 00			ld a,0 
1d83 77				ld (hl),a 
1d84 23				inc hl 
1d85 77				ld (hl),a 
1d86			 
1d86 3e 00			ld a,0 
1d88 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d8b			 
1d8b 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d8e 32 e2 f4			ld (os_cur_ptr+1),a	 
1d91			 
1d91 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d94 32 c4 f4			ld (os_word_scratch+1),a	 
1d97				 
1d97			 
1d97				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d97 21 e5 f4			ld hl, os_cli_cmd 
1d9a			 
1d9a 3e 00			ld a, 0		 ; init cli input 
1d9c 77				ld (hl), a 
1d9d 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9f			cli: 
1d9f				; show cli prompt 
1d9f				;push af 
1d9f				;ld a, 0 
1d9f				;ld de, prompt 
1d9f				;call str_at_display 
1d9f			 
1d9f				;call update_display 
1d9f				;pop af 
1d9f				;inc a 
1d9f				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d9f 0e 00			ld c, 0 
1da1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1da3 1e 28			ld e, 40 
1da5			 
1da5 21 e5 f4			ld hl, os_cli_cmd 
1da8			 
1da8				STACKFRAME OFF $fefe $9f9f 
1da8				if DEBUG_STACK_IMB 
1da8					if OFF 
1da8						exx 
1da8						ld de, $fefe 
1da8						ld a, d 
1da8						ld hl, curframe 
1da8						call hexout 
1da8						ld a, e 
1da8						ld hl, curframe+2 
1da8						call hexout 
1da8						ld hl, $fefe 
1da8						push hl 
1da8						ld hl, $9f9f 
1da8						push hl 
1da8						exx 
1da8					endif 
1da8				endif 
1da8			endm 
# End of macro STACKFRAME
1da8			 
1da8 cd fd 0f			call input_str 
1dab			 
1dab				STACKFRAMECHK OFF $fefe $9f9f 
1dab				if DEBUG_STACK_IMB 
1dab					if OFF 
1dab						exx 
1dab						ld hl, $9f9f 
1dab						pop de   ; $9f9f 
1dab						call cmp16 
1dab						jr nz, .spnosame 
1dab						ld hl, $fefe 
1dab						pop de   ; $fefe 
1dab						call cmp16 
1dab						jr z, .spfrsame 
1dab						.spnosame: call showsperror 
1dab						.spfrsame: nop 
1dab						exx 
1dab					endif 
1dab				endif 
1dab			endm 
# End of macro STACKFRAMECHK
1dab			 
1dab				; copy input to last command 
1dab			 
1dab 21 e5 f4			ld hl, os_cli_cmd 
1dae 11 e4 f5			ld de, os_last_cmd 
1db1 01 ff 00			ld bc, 255 
1db4 ed b0			ldir 
1db6			 
1db6				; wipe current buffer 
1db6			 
1db6			;	ld a, 0 
1db6			;	ld hl, os_cli_cmd 
1db6			;	ld de, os_cli_cmd+1 
1db6			;	ld bc, 254 
1db6			;	ldir 
1db6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1db6			;	call strcpy 
1db6			;	ld a, 0 
1db6			;	ld (hl), a 
1db6			;	inc hl 
1db6			;	ld (hl), a 
1db6			;	inc hl 
1db6			;	ld (hl), a 
1db6			 
1db6				; switch frame buffer to program  
1db6			 
1db6 21 0d fd				ld hl, display_fb1 
1db9 22 c9 fb				ld (display_fb_active), hl 
1dbc			 
1dbc			;	nop 
1dbc				STACKFRAME ON $fbfe $8f9f 
1dbc				if DEBUG_STACK_IMB 
1dbc					if ON 
1dbc						exx 
1dbc						ld de, $fbfe 
1dbc						ld a, d 
1dbc						ld hl, curframe 
1dbc						call hexout 
1dbc						ld a, e 
1dbc						ld hl, curframe+2 
1dbc						call hexout 
1dbc						ld hl, $fbfe 
1dbc						push hl 
1dbc						ld hl, $8f9f 
1dbc						push hl 
1dbc						exx 
1dbc					endif 
1dbc				endif 
1dbc			endm 
# End of macro STACKFRAME
1dbc				; first time into the parser so pass over the current scratch pad 
1dbc 21 e5 f4			ld hl,os_cli_cmd 
1dbf				; tokenise the entered statement(s) in HL 
1dbf cd 01 25			call forthparse 
1dc2			        ; exec forth statements in top of return stack 
1dc2 cd 41 25			call forthexec 
1dc5				;call forthexec_cleanup 
1dc5			;	call parsenext 
1dc5			 
1dc5				STACKFRAMECHK ON $fbfe $8f9f 
1dc5				if DEBUG_STACK_IMB 
1dc5					if ON 
1dc5						exx 
1dc5						ld hl, $8f9f 
1dc5						pop de   ; $8f9f 
1dc5						call cmp16 
1dc5						jr nz, .spnosame 
1dc5						ld hl, $fbfe 
1dc5						pop de   ; $fbfe 
1dc5						call cmp16 
1dc5						jr z, .spfrsame 
1dc5						.spnosame: call showsperror 
1dc5						.spfrsame: nop 
1dc5						exx 
1dc5					endif 
1dc5				endif 
1dc5			endm 
# End of macro STACKFRAMECHK
1dc5				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dc5			 
1dc5 3e 78			ld a, display_row_4 
1dc7 11 f8 1d			ld de, endprog 
1dca			 
1dca cd bf 0d			call update_display		 
1dcd			 
1dcd cd 7e 20			call next_page_prompt 
1dd0			 
1dd0				; switch frame buffer to cli 
1dd0			 
1dd0 21 ae fd				ld hl, display_fb0 
1dd3 22 c9 fb				ld (display_fb_active), hl 
1dd6			 
1dd6			 
1dd6 cd 9c 0d		        call clear_display 
1dd9 cd bf 0d			call update_display		 
1ddc			 
1ddc 21 e5 f4			ld hl, os_cli_cmd 
1ddf			 
1ddf 3e 00			ld a, 0		 ; init cli input 
1de1 77				ld (hl), a 
1de2			 
1de2				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1de2			 
1de2				; now on last line 
1de2			 
1de2				; TODO scroll screen up 
1de2			 
1de2				; TODO instead just clear screen and place at top of screen 
1de2			 
1de2			;	ld a, 0 
1de2			;	ld (f_cursor_ptr),a 
1de2			 
1de2				;call clear_display 
1de2				;call update_display 
1de2			 
1de2				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de2 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de4 c3 9f 1d			jp cli 
1de7			 
1de7 .. 00		freeram: db "Free bytes: ",0 
1df4 ..			asc: db "1A2F" 
1df8 .. 00		endprog: db "End prog...",0 
1e04			 
1e04			testenter2:   
1e04 21 f0 f1			ld hl,scratch+50 
1e07 22 e1 f4			ld (os_cur_ptr),hl 
1e0a c3 9f 1d			jp cli 
1e0d			 
1e0d			testenter:  
1e0d			 
1e0d 21 f4 1d			ld hl,asc 
1e10			;	ld a,(hl) 
1e10			;	call nibble2val 
1e10 cd 27 13			call get_byte 
1e13			 
1e13			 
1e13			;	ld a,(hl) 
1e13			;	call atohex 
1e13			 
1e13			;	call fourehexhl 
1e13 32 f0 f1			ld (scratch+50),a 
1e16			 
1e16			 
1e16			 
1e16 21 f6 1d			ld hl,asc+2 
1e19			;	ld a, (hl) 
1e19			;	call nibble2val 
1e19 cd 27 13			call get_byte 
1e1c			 
1e1c			;	call fourehexhl 
1e1c 32 f2 f1			ld (scratch+52),a 
1e1f				 
1e1f 21 f0 f1			ld hl,scratch+50 
1e22 22 e1 f4			ld (os_cur_ptr),hl 
1e25 c3 9f 1d			jp cli 
1e28			 
1e28			enter:	 
1e28 3a c2 f1			ld a,(scratch+4) 
1e2b fe 00			cp 0 
1e2d 28 0c			jr z, .entercont 
1e2f				; no, not a null term line so has an address to work out.... 
1e2f			 
1e2f 21 c0 f1			ld hl,scratch+2 
1e32 cd 87 13			call get_word_hl 
1e35			 
1e35 22 e1 f4			ld (os_cur_ptr),hl	 
1e38 c3 9f 1d			jp cli 
1e3b			 
1e3b			 
1e3b			.entercont:  
1e3b			 
1e3b 21 c0 f1			ld hl, scratch+2 
1e3e cd 27 13			call get_byte 
1e41			 
1e41 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e44 77					ld (hl),a 
1e45 23					inc hl 
1e46 22 e1 f4				ld (os_cur_ptr),hl 
1e49				 
1e49			; get byte  
1e49			 
1e49			 
1e49 c3 9f 1d			jp cli 
1e4c			 
1e4c			 
1e4c			; basic monitor support 
1e4c			 
1e4c			monitor: 
1e4c				;  
1e4c cd 9c 0d			call clear_display 
1e4f 3e 00			ld a, 0 
1e51 11 a0 1e			ld de, .monprompt 
1e54 cd af 0d			call str_at_display 
1e57 cd bf 0d			call update_display 
1e5a			 
1e5a				; get a monitor command 
1e5a			 
1e5a 0e 00			ld c, 0     ; entry at top left 
1e5c 16 64			ld d, 100   ; max buffer size 
1e5e 1e 0f			ld e, 15    ; input scroll area 
1e60 3e 00			ld a, 0     ; init string 
1e62 21 bc f3			ld hl, os_input 
1e65 77				ld (hl), a 
1e66 23				inc hl 
1e67 77				ld (hl), a 
1e68 21 bc f3			ld hl, os_input 
1e6b 3e 01			ld a, 1     ; init string 
1e6d cd fd 0f			call input_str 
1e70			 
1e70 cd 9c 0d		        call clear_display 
1e73 cd bf 0d			call update_display		 
1e76			 
1e76 3a bc f3			ld a, (os_input) 
1e79 cd 25 14			call toUpper 
1e7c fe 48		        cp 'H' 
1e7e ca 05 1f		        jp z, .monhelp 
1e81 fe 44			cp 'D'		; dump 
1e83 ca 38 1f			jp z, .mondump	 
1e86 fe 43			cp 'C'		; dump 
1e88 ca 52 1f			jp z, .moncdump	 
1e8b fe 4d			cp 'M'		; dump 
1e8d ca a2 1e			jp z, .moneditstart 
1e90 fe 55			cp 'U'		; dump 
1e92 ca ae 1e			jp z, .monedit	 
1e95 fe 47			cp 'G'		; dump 
1e97 ca 2e 1f			jp z, .monjump 
1e9a fe 51			cp 'Q'		; dump 
1e9c c8				ret z	 
1e9d			 
1e9d			 
1e9d				; TODO "S" to access symbol by name and not need the address 
1e9d				; TODO "F" to find a string in memory 
1e9d			 
1e9d c3 4c 1e			jp monitor 
1ea0			 
1ea0 .. 00		.monprompt: db ">", 0 
1ea2			 
1ea2			.moneditstart: 
1ea2				; get starting address 
1ea2			 
1ea2 21 be f3			ld hl,os_input+2 
1ea5 cd 87 13			call get_word_hl 
1ea8			 
1ea8 22 e1 f4			ld (os_cur_ptr),hl	 
1eab			 
1eab c3 4c 1e			jp monitor 
1eae			 
1eae			.monedit: 
1eae				; get byte to load 
1eae			 
1eae 21 be f3			ld hl,os_input+2 
1eb1 cd 27 13			call get_byte 
1eb4			 
1eb4				; get address to update 
1eb4 2a e1 f4			ld hl, (os_cur_ptr) 
1eb7			 
1eb7				; update byte 
1eb7			 
1eb7 77				ld (hl), a 
1eb8			 
1eb8				; move to next address and save it 
1eb8			 
1eb8 23				inc hl 
1eb9 22 e1 f4			ld (os_cur_ptr),hl	 
1ebc			 
1ebc c3 4c 1e			jp monitor 
1ebf			 
1ebf			 
1ebf .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ed3 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1eef .. 00		.monhelptext3:  db "G-Call address",0 
1efe .. 00		.monhelptext4:  db "Q-Quit",0 
1f05			        
1f05			.monhelp: 
1f05 3e 00			ld a, display_row_1 
1f07 11 bf 1e		        ld de, .monhelptext1 
1f0a			 
1f0a cd af 0d			call str_at_display 
1f0d 3e 28			ld a, display_row_2 
1f0f 11 d3 1e		        ld de, .monhelptext2 
1f12					 
1f12 cd af 0d			call str_at_display 
1f15 3e 50			ld a, display_row_3 
1f17 11 ef 1e		        ld de, .monhelptext3 
1f1a					 
1f1a cd af 0d			call str_at_display 
1f1d 3e 78			ld a, display_row_4 
1f1f 11 fe 1e		        ld de, .monhelptext4 
1f22 cd af 0d			call str_at_display 
1f25			 
1f25 cd bf 0d			call update_display		 
1f28			 
1f28 cd 7e 20			call next_page_prompt 
1f2b c3 4c 1e			jp monitor 
1f2e			 
1f2e			.monjump:    
1f2e 21 be f3			ld hl,os_input+2 
1f31 cd 87 13			call get_word_hl 
1f34			 
1f34 e9				jp (hl) 
1f35 c3 4c 1e			jp monitor 
1f38			 
1f38			.mondump:    
1f38 21 be f3			ld hl,os_input+2 
1f3b cd 87 13			call get_word_hl 
1f3e			 
1f3e 22 e1 f4			ld (os_cur_ptr),hl	 
1f41 cd 86 1f			call dumpcont 
1f44 3e 78			ld a, display_row_4 
1f46 11 f8 1d			ld de, endprog 
1f49			 
1f49 cd bf 0d			call update_display		 
1f4c			 
1f4c cd 7e 20			call next_page_prompt 
1f4f c3 4c 1e			jp monitor 
1f52			.moncdump: 
1f52 cd 86 1f			call dumpcont 
1f55 3e 78			ld a, display_row_4 
1f57 11 f8 1d			ld de, endprog 
1f5a			 
1f5a cd bf 0d			call update_display		 
1f5d			 
1f5d cd 7e 20			call next_page_prompt 
1f60 c3 4c 1e			jp monitor 
1f63			 
1f63			 
1f63			; TODO symbol access  
1f63			 
1f63			.symbols:     ;; A list of symbols that can be called up  
1f63 ae fd			dw display_fb0 
1f65 .. 00			db "fb0",0  
1f69 77 fa		     	dw store_page 
1f6b .. 00			db "store_page",0 
1f76			 
1f76			 
1f76			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f76			 
1f76 3a bf f1			ld a,(scratch+1) 
1f79 fe 00			cp 0 
1f7b 28 09			jr z, dumpcont 
1f7d			 
1f7d				; no, not a null term line so has an address to work out.... 
1f7d			 
1f7d 21 c0 f1			ld hl,scratch+2 
1f80 cd 87 13			call get_word_hl 
1f83			 
1f83 22 e1 f4			ld (os_cur_ptr),hl	 
1f86			 
1f86			 
1f86			 
1f86			dumpcont: 
1f86			 
1f86				; dump bytes at ptr 
1f86			 
1f86			 
1f86 3e 00			ld a, display_row_1 
1f88 2a c9 fb			ld hl, (display_fb_active) 
1f8b cd d0 0f			call addatohl 
1f8e cd b6 1f			call .dumpbyterow 
1f91			 
1f91 3e 28			ld a, display_row_2 
1f93 2a c9 fb			ld hl, (display_fb_active) 
1f96 cd d0 0f			call addatohl 
1f99 cd b6 1f			call .dumpbyterow 
1f9c			 
1f9c			 
1f9c 3e 50			ld a, display_row_3 
1f9e 2a c9 fb			ld hl, (display_fb_active) 
1fa1 cd d0 0f			call addatohl 
1fa4 cd b6 1f			call .dumpbyterow 
1fa7			 
1fa7 3e 78			ld a, display_row_4 
1fa9 2a c9 fb			ld hl, (display_fb_active) 
1fac cd d0 0f			call addatohl 
1faf cd b6 1f			call .dumpbyterow 
1fb2			 
1fb2 cd bf 0d			call update_display 
1fb5			;		jp cli 
1fb5 c9				ret 
1fb6			 
1fb6			.dumpbyterow: 
1fb6			 
1fb6				;push af 
1fb6			 
1fb6 e5				push hl 
1fb7			 
1fb7				; calc where to poke the ascii 
1fb7			if display_cols == 20 
1fb7				ld a, 16 
1fb7			else 
1fb7 3e 1f			ld a, 31 
1fb9			endif 
1fb9			 
1fb9 cd d0 0f			call addatohl 
1fbc 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fbf			 
1fbf			 
1fbf			; display decoding address 
1fbf 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fc2			 
1fc2 7c				ld a,h 
1fc3 e1				pop hl 
1fc4 e5				push hl 
1fc5			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fc5 cd d1 12			call hexout 
1fc8 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fcb			 
1fcb 7d				ld a,l 
1fcc e1				pop hl 
1fcd 23				inc hl 
1fce 23				inc hl 
1fcf e5				push hl 
1fd0			;	ld hl, os_word_scratch+2 
1fd0 cd d1 12			call hexout 
1fd3 e1				pop hl 
1fd4 23				inc hl 
1fd5 23				inc hl 
1fd6				;ld hl, os_word_scratch+4 
1fd6 3e 3a			ld a, ':' 
1fd8 77				ld (hl),a 
1fd9 23				inc hl 
1fda				;ld a, 0 
1fda				;ld (hl),a 
1fda				;ld de, os_word_scratch 
1fda				;pop af 
1fda				;push af 
1fda			;		ld a, display_row_2 
1fda			;		call str_at_display 
1fda			;		call update_display 
1fda			 
1fda			 
1fda			;pop af 
1fda			;	add 5 
1fda			 
1fda			if display_cols == 20 
1fda				ld b, 4 
1fda			else 
1fda 06 08			ld b, 8 
1fdc			endif	 
1fdc			 
1fdc			.dumpbyte: 
1fdc c5				push bc 
1fdd e5				push hl 
1fde			 
1fde			 
1fde 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fe1 7e					ld a,(hl) 
1fe2			 
1fe2					; poke the ascii to display 
1fe2 2a c3 f4				ld hl,(os_word_scratch) 
1fe5 77					ld (hl),a 
1fe6 23					inc hl 
1fe7 22 c3 f4				ld (os_word_scratch),hl 
1fea			 
1fea					 
1fea			 
1fea			 
1fea e1					pop hl 
1feb e5					push hl 
1fec			 
1fec cd d1 12				call hexout 
1fef			 
1fef					 
1fef 2a e1 f4		   	ld hl,(os_cur_ptr) 
1ff2 23				inc hl 
1ff3 22 e1 f4		   	ld (os_cur_ptr),hl 
1ff6			 
1ff6 e1					pop hl 
1ff7 23					inc hl 
1ff8 23					inc hl 
1ff9 23					inc hl 
1ffa			 
1ffa			 
1ffa			 
1ffa					;ld a,0 
1ffa					;ld (os_word_scratch+2),a 
1ffa					;pop af 
1ffa					;push af 
1ffa			 
1ffa					;ld de, os_word_scratch 
1ffa					;call str_at_display 
1ffa			;		call update_display 
1ffa			;		pop af 
1ffa c1					pop bc 
1ffb c6 03				add 3 
1ffd 10 dd			djnz .dumpbyte 
1fff			 
1fff				 
1fff			 
1fff c9				ret 
2000			 
2000			jump:	 
2000			 
2000 21 c0 f1			ld hl,scratch+2 
2003 cd 87 13			call get_word_hl 
2006				;ld hl,(scratch+2) 
2006				;call fourehexhl 
2006			 
2006 22 e1 f4			ld (os_cur_ptr),hl	 
2009			 
2009 e9				jp (hl) 
200a			 
200a			 
200a			 
200a			; TODO implement a basic monitor mode to start with 
200a			 
200a			 
200a			 
200a			 
200a			 
200a			 
200a			 
200a			 
200a			 
200a			; testing and demo code during development 
200a			 
200a			 
200a .. 00		str1: db "Enter some text...",0 
201d .. 00		clear: db "                    ",0 
2032			 
2032			demo: 
2032			 
2032			 
2032			 
2032			;	call update_display 
2032			 
2032				; init scratch input area for testing 
2032 21 be f1			ld hl, scratch	 
2035 3e 00			ld a,0 
2037 77				ld (hl),a 
2038			 
2038			 
2038 3e 28		            LD   A, display_row_2 
203a			;            CALL fLCD_Pos       ;Position cursor to location in A 
203a 11 0a 20		            LD   DE, str1 
203d cd af 0d			call str_at_display 
2040			 
2040			;            CALL fLCD_Str       ;Display string pointed to by DE 
2040			cloop:	 
2040 3e 50		            LD   A, display_row_3 
2042			;            CALL fLCD_Pos       ;Position cursor to location in A 
2042 11 1d 20		            LD   DE, clear 
2045			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2045 cd af 0d				call str_at_display 
2048 3e 78			ld a, display_row_4 
204a 11 7a 20			ld de, prompt 
204d			 
204d cd af 0d				call str_at_display 
2050 cd bf 0d			call update_display 
2053			 
2053 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2055 16 0a			ld d, 10 
2057 21 be f1			ld hl, scratch	 
205a cd fd 0f			call input_str 
205d			 
205d			;	call clear_display 
205d			;'	call update_display 
205d			 
205d 3e 00		            LD   A, display_row_1 
205f			;            CALL fLCD_Pos       ;Position cursor to location in A 
205f 11 1d 20		            LD   DE, clear 
2062 cd af 0d				call str_at_display 
2065			;            CALL fLCD_Str       ;Display string pointed to by DE 
2065 3e 00		            LD   A, display_row_1 
2067			;            CALL fLCD_Pos       ;Position cursor to location in A 
2067 11 be f1		            LD   DE, scratch 
206a			;            CALL fLCD_Str       ;Display string pointed to by DE 
206a cd af 0d				call str_at_display 
206d cd bf 0d			call update_display 
2070			 
2070 3e 00				ld a,0 
2072 21 be f1			ld hl, scratch 
2075 77				ld (hl),a 
2076			 
2076 00				nop 
2077 c3 40 20			jp cloop 
207a			 
207a			 
207a			 
207a			; OS Prompt 
207a			 
207a .. 00		prompt: db ">",0 
207c .. 00		endprg: db "?",0 
207e			 
207e			 
207e			; handy next page prompt 
207e			next_page_prompt: 
207e e5				push hl 
207f d5				push de 
2080 f5				push af 
2081 c5				push bc 
2082			 
2082 3e 9f			ld a,display_row_4 + display_cols - 1 
2084 11 7c 20		        ld de, endprg 
2087 cd af 0d			call str_at_display 
208a cd bf 0d			call update_display 
208d cd c4 79			call cin_wait 
2090 c1				pop bc 
2091 f1				pop af 
2092 d1				pop de 
2093 e1				pop hl 
2094			 
2094			 
2094 c9				ret 
2095			 
2095			 
2095			; forth parser 
2095			 
2095			; My forth kernel 
2095			include "forth_kernel.asm" 
2095			; 
2095			; kernel to the forth OS 
2095			 
2095			DS_TYPE_STR: equ 1     ; string type 
2095			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2095			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2095			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2095			 
2095			FORTH_PARSEV1: equ 0 
2095			FORTH_PARSEV2: equ 0 
2095			FORTH_PARSEV3: equ 0 
2095			FORTH_PARSEV4: equ 0 
2095			FORTH_PARSEV5: equ 1 
2095			 
2095			;if FORTH_PARSEV5 
2095			;	FORTH_END_BUFFER: equ 0 
2095			;else 
2095			FORTH_END_BUFFER: equ 127 
2095			;endif 
2095			 
2095			FORTH_TRUE: equ 1 
2095			FORTH_FALSE: equ 0 
2095			 
2095			if FORTH_PARSEV4 
2095			include "forth_stackops.asm" 
2095			endif 
2095			 
2095			if FORTH_PARSEV5 
2095			include "forth_stackopsv5.asm" 
2095			 
2095			; Stack operations for v5 parser on wards 
2095			; * DATA stack 
2095			; * LOOP stack 
2095			; * RETURN stack 
2095			 
2095			 
2095			 
2095			FORTH_CHK_DSP_UNDER: macro 
2095				push hl 
2095				push de 
2095				ld hl,(cli_data_sp) 
2095				ld de, cli_data_stack 
2095				call cmp16 
2095				jp c, fault_dsp_under 
2095				pop de 
2095				pop hl 
2095				endm 
2095			 
2095			 
2095			FORTH_CHK_RSP_UNDER: macro 
2095				push hl 
2095				push de 
2095				ld hl,(cli_ret_sp) 
2095				ld de, cli_ret_stack 
2095				call cmp16 
2095				jp c, fault_rsp_under 
2095				pop de 
2095				pop hl 
2095				endm 
2095			 
2095			FORTH_CHK_LOOP_UNDER: macro 
2095				push hl 
2095				push de 
2095				ld hl,(cli_loop_sp) 
2095				ld de, cli_loop_stack 
2095				call cmp16 
2095				jp c, fault_loop_under 
2095				pop de 
2095				pop hl 
2095				endm 
2095			 
2095			FORTH_ERR_TOS_NOTSTR: macro 
2095				; TOSO might need more for checks when used 
2095				push af 
2095				ld a,(hl) 
2095				cp DS_TYPE_STR 
2095				jp nz, type_faultn   
2095				pop af 
2095				endm 
2095			 
2095			FORTH_ERR_TOS_NOTNUM: macro 
2095				push af 
2095				ld a,(hl) 
2095				cp DS_TYPE_INUM 
2095				jp nz, type_faultn   
2095				pop af 
2095				endm 
2095			 
2095			 
2095			; increase data stack pointer and save hl to it 
2095				 
2095			FORTH_DSP_NEXT: macro 
2095				call macro_forth_dsp_next 
2095				endm 
2095			 
2095			 
2095			macro_forth_dsp_next: 
2095				if DEBUG_FORTH_STACK_GUARD 
2095 cd 71 72				call check_stacks 
2098				endif 
2098 e5				push hl 
2099 d5				push de 
209a eb				ex de,hl 
209b 2a eb f9			ld hl,(cli_data_sp) 
209e 23				inc hl 
209f 23				inc hl 
20a0			 
20a0			; PARSEV5 
20a0 23				inc hl 
20a1 22 eb f9			ld (cli_data_sp),hl 
20a4 73				ld (hl), e 
20a5 23				inc hl 
20a6 72				ld (hl), d 
20a7 d1				pop de 
20a8 e1				pop hl 
20a9				if DEBUG_FORTH_STACK_GUARD 
20a9 cd 71 72				call check_stacks 
20ac				endif 
20ac c9				ret 
20ad			 
20ad			 
20ad			; increase ret stack pointer and save hl to it 
20ad				 
20ad			FORTH_RSP_NEXT: macro 
20ad				call macro_forth_rsp_next 
20ad				endm 
20ad			 
20ad			macro_forth_rsp_next: 
20ad				if DEBUG_FORTH_STACK_GUARD 
20ad cd 71 72				call check_stacks 
20b0				endif 
20b0 e5				push hl 
20b1 d5				push de 
20b2 eb				ex de,hl 
20b3 2a ef f9			ld hl,(cli_ret_sp) 
20b6 23				inc hl 
20b7 23				inc hl 
20b8 22 ef f9			ld (cli_ret_sp),hl 
20bb 73				ld (hl), e 
20bc 23				inc hl 
20bd 72				ld (hl), d 
20be d1				pop de 
20bf e1				pop hl 
20c0				if DEBUG_FORTH_STACK_GUARD 
20c0 cd 71 72				call check_stacks 
20c3				endif 
20c3 c9				ret 
20c4			 
20c4			; get current ret stack pointer and save to hl  
20c4				 
20c4			FORTH_RSP_TOS: macro 
20c4				call macro_forth_rsp_tos 
20c4				endm 
20c4			 
20c4			macro_forth_rsp_tos: 
20c4				;push de 
20c4 2a ef f9			ld hl,(cli_ret_sp) 
20c7 cd ff 20			call loadhlptrtohl 
20ca				;ld e, (hl) 
20ca				;inc hl 
20ca				;ld d, (hl) 
20ca				;ex de, hl 
20ca					if DEBUG_FORTH_WORDS 
20ca			;			DMARK "RST" 
20ca						CALLMONITOR 
20ca cd 6c fe			call debug_vector  
20cd				endm  
# End of macro CALLMONITOR
20cd					endif 
20cd				;pop de 
20cd c9				ret 
20ce			 
20ce			; pop ret stack pointer 
20ce				 
20ce			FORTH_RSP_POP: macro 
20ce				call macro_forth_rsp_pop 
20ce				endm 
20ce			 
20ce			 
20ce			macro_forth_rsp_pop: 
20ce				if DEBUG_FORTH_STACK_GUARD 
20ce			;		DMARK "RPP" 
20ce cd 71 72				call check_stacks 
20d1					FORTH_CHK_RSP_UNDER 
20d1 e5				push hl 
20d2 d5				push de 
20d3 2a ef f9			ld hl,(cli_ret_sp) 
20d6 11 a9 f9			ld de, cli_ret_stack 
20d9 cd ee 0f			call cmp16 
20dc da 85 73			jp c, fault_rsp_under 
20df d1				pop de 
20e0 e1				pop hl 
20e1				endm 
# End of macro FORTH_CHK_RSP_UNDER
20e1				endif 
20e1 e5				push hl 
20e2 2a ef f9			ld hl,(cli_ret_sp) 
20e5			 
20e5			 
20e5				if FORTH_ENABLE_FREE 
20e5			 
20e5					; get pointer 
20e5			 
20e5					push de 
20e5					push hl 
20e5			 
20e5					ld e, (hl) 
20e5					inc hl 
20e5					ld d, (hl) 
20e5			 
20e5					ex de, hl 
20e5					call free 
20e5			 
20e5					pop hl 
20e5					pop de 
20e5			 
20e5			 
20e5				endif 
20e5			 
20e5			 
20e5 2b				dec hl 
20e6 2b				dec hl 
20e7 22 ef f9			ld (cli_ret_sp), hl 
20ea				; do stack underflow checks 
20ea e1				pop hl 
20eb				if DEBUG_FORTH_STACK_GUARD 
20eb cd 71 72				call check_stacks 
20ee					FORTH_CHK_RSP_UNDER 
20ee e5				push hl 
20ef d5				push de 
20f0 2a ef f9			ld hl,(cli_ret_sp) 
20f3 11 a9 f9			ld de, cli_ret_stack 
20f6 cd ee 0f			call cmp16 
20f9 da 85 73			jp c, fault_rsp_under 
20fc d1				pop de 
20fd e1				pop hl 
20fe				endm 
# End of macro FORTH_CHK_RSP_UNDER
20fe				endif 
20fe c9				ret 
20ff			 
20ff			 
20ff			 
20ff			; routine to load word pointed to by hl into hl 
20ff			 
20ff			loadhlptrtohl: 
20ff			 
20ff d5				push de 
2100 5e				ld e, (hl) 
2101 23				inc hl 
2102 56				ld d, (hl) 
2103 eb				ex de, hl 
2104 d1				pop de 
2105			 
2105 c9				ret 
2106			 
2106			 
2106			 
2106			 
2106			 
2106			; push a number held in HL onto the data stack 
2106			; entry point for pushing a value when already in hl used in function above 
2106			 
2106			forth_push_numhl: 
2106			 
2106 e5				push hl    ; save value to push 
2107			 
2107			if DEBUG_FORTH_PUSH 
2107				; see if disabled 
2107			 
2107			 
2107 f5				push af 
2108 3a 6c fe			ld a,(debug_vector) 
210b fe c9			cp $c9   ; ret 
210d			;	ld a, (os_view_disable) 
210d			;	cp '*' 
210d 28 34			jr z, .pskip2 
210f e5				push hl 
2110 e5			push hl 
2111 cd 9c 0d			call clear_display 
2114 e1			pop hl 
2115 7c				ld a,h 
2116 21 c3 f4			ld hl, os_word_scratch 
2119 cd d1 12			call hexout 
211c e1				pop hl 
211d 7d				ld a,l 
211e 21 c5 f4			ld hl, os_word_scratch+2 
2121 cd d1 12			call hexout 
2124			 
2124 21 c7 f4			ld hl, os_word_scratch+4 
2127 3e 00			ld a,0 
2129 77				ld (hl),a 
212a 11 c3 f4			ld de,os_word_scratch 
212d 3e 28				ld a, display_row_2 
212f cd af 0d				call str_at_display 
2132 11 ad 5d			ld de, .push_num 
2135 3e 00			ld a, display_row_1 
2137			 
2137 cd af 0d				call str_at_display 
213a			 
213a			 
213a cd bf 0d			call update_display 
213d cd df 0c			call delay1s 
2140 cd df 0c			call delay1s 
2143			.pskip2:  
2143			 
2143 f1				pop af 
2144			endif	 
2144			 
2144			 
2144				FORTH_DSP_NEXT 
2144 cd 95 20			call macro_forth_dsp_next 
2147				endm 
# End of macro FORTH_DSP_NEXT
2147			 
2147 2a eb f9			ld hl, (cli_data_sp) 
214a			 
214a				; save item type 
214a 3e 02			ld a,  DS_TYPE_INUM 
214c 77				ld (hl), a 
214d 23				inc hl 
214e			 
214e				; get word off stack 
214e d1				pop de 
214f 7b				ld a,e 
2150 77				ld (hl), a 
2151 23				inc hl 
2152 7a				ld a,d 
2153 77				ld (hl), a 
2154			 
2154			if DEBUG_FORTH_PUSH 
2154 2b				dec hl 
2155 2b				dec hl 
2156 2b				dec hl 
2157						DMARK "PH5" 
2157 f5				push af  
2158 3a 6c 21			ld a, (.dmark)  
215b 32 68 fe			ld (debug_mark),a  
215e 3a 6d 21			ld a, (.dmark+1)  
2161 32 69 fe			ld (debug_mark+1),a  
2164 3a 6e 21			ld a, (.dmark+2)  
2167 32 6a fe			ld (debug_mark+2),a  
216a 18 03			jr .pastdmark  
216c ..			.dmark: db "PH5"  
216f f1			.pastdmark: pop af  
2170			endm  
# End of macro DMARK
2170				CALLMONITOR 
2170 cd 6c fe			call debug_vector  
2173				endm  
# End of macro CALLMONITOR
2173			endif	 
2173			 
2173 c9				ret 
2174			 
2174			 
2174			; Push a string to stack pointed to by hl 
2174			 
2174			forth_push_str: 
2174			 
2174			if DEBUG_FORTH_PUSH 
2174						DMARK "PSQ" 
2174 f5				push af  
2175 3a 89 21			ld a, (.dmark)  
2178 32 68 fe			ld (debug_mark),a  
217b 3a 8a 21			ld a, (.dmark+1)  
217e 32 69 fe			ld (debug_mark+1),a  
2181 3a 8b 21			ld a, (.dmark+2)  
2184 32 6a fe			ld (debug_mark+2),a  
2187 18 03			jr .pastdmark  
2189 ..			.dmark: db "PSQ"  
218c f1			.pastdmark: pop af  
218d			endm  
# End of macro DMARK
218d				CALLMONITOR 
218d cd 6c fe			call debug_vector  
2190				endm  
# End of macro CALLMONITOR
2190			endif	 
2190			    
2190 e5				push hl 
2191 e5				push hl 
2192			 
2192			;	ld a, 0   ; find end of string 
2192 cd 2e 14			call strlenz 
2195			if DEBUG_FORTH_PUSH 
2195						DMARK "PQ2" 
2195 f5				push af  
2196 3a aa 21			ld a, (.dmark)  
2199 32 68 fe			ld (debug_mark),a  
219c 3a ab 21			ld a, (.dmark+1)  
219f 32 69 fe			ld (debug_mark+1),a  
21a2 3a ac 21			ld a, (.dmark+2)  
21a5 32 6a fe			ld (debug_mark+2),a  
21a8 18 03			jr .pastdmark  
21aa ..			.dmark: db "PQ2"  
21ad f1			.pastdmark: pop af  
21ae			endm  
# End of macro DMARK
21ae				CALLMONITOR 
21ae cd 6c fe			call debug_vector  
21b1				endm  
# End of macro CALLMONITOR
21b1			endif	 
21b1 eb				ex de, hl 
21b2 e1				pop hl   ; get ptr to start of string 
21b3			if DEBUG_FORTH_PUSH 
21b3						DMARK "PQ3" 
21b3 f5				push af  
21b4 3a c8 21			ld a, (.dmark)  
21b7 32 68 fe			ld (debug_mark),a  
21ba 3a c9 21			ld a, (.dmark+1)  
21bd 32 69 fe			ld (debug_mark+1),a  
21c0 3a ca 21			ld a, (.dmark+2)  
21c3 32 6a fe			ld (debug_mark+2),a  
21c6 18 03			jr .pastdmark  
21c8 ..			.dmark: db "PQ3"  
21cb f1			.pastdmark: pop af  
21cc			endm  
# End of macro DMARK
21cc				CALLMONITOR 
21cc cd 6c fe			call debug_vector  
21cf				endm  
# End of macro CALLMONITOR
21cf			endif	 
21cf 19				add hl,de 
21d0			if DEBUG_FORTH_PUSH 
21d0						DMARK "PQE" 
21d0 f5				push af  
21d1 3a e5 21			ld a, (.dmark)  
21d4 32 68 fe			ld (debug_mark),a  
21d7 3a e6 21			ld a, (.dmark+1)  
21da 32 69 fe			ld (debug_mark+1),a  
21dd 3a e7 21			ld a, (.dmark+2)  
21e0 32 6a fe			ld (debug_mark+2),a  
21e3 18 03			jr .pastdmark  
21e5 ..			.dmark: db "PQE"  
21e8 f1			.pastdmark: pop af  
21e9			endm  
# End of macro DMARK
21e9				CALLMONITOR 
21e9 cd 6c fe			call debug_vector  
21ec				endm  
# End of macro CALLMONITOR
21ec			endif	 
21ec			 
21ec 2b				dec hl    ; see if there is an optional trailing double quote 
21ed 7e				ld a,(hl) 
21ee fe 22			cp '"' 
21f0 20 03			jr nz, .strnoq 
21f2 3e 00			ld a, 0      ; get rid of double quote 
21f4 77				ld (hl), a 
21f5 23			.strnoq: inc hl 
21f6			 
21f6 3e 00			ld a, 0 
21f8 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21f9			 
21f9 13				inc de ; add one for the type string 
21fa 13				inc de ; add one for null term??? 
21fb			 
21fb				; tos is get string pointer again 
21fb				; de contains space to allocate 
21fb				 
21fb d5				push de 
21fc			 
21fc eb				ex de, hl 
21fd			 
21fd				;push af 
21fd			 
21fd			if DEBUG_FORTH_PUSH 
21fd						DMARK "PHm" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 68 fe			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 69 fe			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 6a fe			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "PHm"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216				CALLMONITOR 
2216 cd 6c fe			call debug_vector  
2219				endm  
# End of macro CALLMONITOR
2219			endif	 
2219 cd 97 14			call malloc	; on ret hl now contains allocated memory 
221c				if DEBUG_FORTH_MALLOC_GUARD 
221c cc 05 5e				call z,malloc_error 
221f				endif 
221f			 
221f				 
221f c1				pop bc    ; get length 
2220 d1				pop de   ;  get string start    
2221			 
2221				; hl has destination from malloc 
2221			 
2221 eb				ex de, hl    ; prep for ldir 
2222			 
2222 d5				push de   ; save malloc area for DSP later 
2223				;push hl   ; save malloc area for DSP later 
2223			 
2223			if DEBUG_FORTH_PUSH 
2223						DMARK "PHc" 
2223 f5				push af  
2224 3a 38 22			ld a, (.dmark)  
2227 32 68 fe			ld (debug_mark),a  
222a 3a 39 22			ld a, (.dmark+1)  
222d 32 69 fe			ld (debug_mark+1),a  
2230 3a 3a 22			ld a, (.dmark+2)  
2233 32 6a fe			ld (debug_mark+2),a  
2236 18 03			jr .pastdmark  
2238 ..			.dmark: db "PHc"  
223b f1			.pastdmark: pop af  
223c			endm  
# End of macro DMARK
223c				CALLMONITOR 
223c cd 6c fe			call debug_vector  
223f				endm  
# End of macro CALLMONITOR
223f			endif	 
223f			 
223f			 
223f ed b0			ldir 
2241			 
2241			 
2241				; push malloc to data stack     macro?????  
2241			 
2241				FORTH_DSP_NEXT 
2241 cd 95 20			call macro_forth_dsp_next 
2244				endm 
# End of macro FORTH_DSP_NEXT
2244			 
2244				; save value and type 
2244			 
2244 2a eb f9			ld hl, (cli_data_sp) 
2247			 
2247				; save item type 
2247 3e 01			ld a,  DS_TYPE_STR 
2249 77				ld (hl), a 
224a 23				inc hl 
224b			 
224b				; get malloc word off stack 
224b d1				pop de 
224c 73				ld (hl), e 
224d 23				inc hl 
224e 72				ld (hl), d 
224f			 
224f			 
224f			 
224f			if DEBUG_FORTH_PUSH 
224f 2a eb f9			ld hl, (cli_data_sp) 
2252						DMARK "PHS" 
2252 f5				push af  
2253 3a 67 22			ld a, (.dmark)  
2256 32 68 fe			ld (debug_mark),a  
2259 3a 68 22			ld a, (.dmark+1)  
225c 32 69 fe			ld (debug_mark+1),a  
225f 3a 69 22			ld a, (.dmark+2)  
2262 32 6a fe			ld (debug_mark+2),a  
2265 18 03			jr .pastdmark  
2267 ..			.dmark: db "PHS"  
226a f1			.pastdmark: pop af  
226b			endm  
# End of macro DMARK
226b				CALLMONITOR 
226b cd 6c fe			call debug_vector  
226e				endm  
# End of macro CALLMONITOR
226e			;	ex de,hl 
226e			endif	 
226e				; in case of spaces, skip the ptr past the copied string 
226e				;pop af 
226e				;ld (cli_origptr),hl 
226e			 
226e c9				ret 
226f			 
226f			 
226f			 
226f			; TODO ascii push input onto stack given hl to start of input 
226f			 
226f			; identify type 
226f			; if starts with a " then a string 
226f			; otherwise it is a number 
226f			;  
226f			; if a string 
226f			;     scan for ending " to get length of string to malloc for + 1 
226f			;     malloc 
226f			;     put pointer to string on stack first byte flags as string 
226f			; 
226f			; else a number 
226f			;    look for number format identifier 
226f			;    $xx hex 
226f			;    %xxxxx bin 
226f			;    xxxxx decimal 
226f			;    convert number to 16bit word.  
226f			;    malloc word + 1 with flag to identiy as num 
226f			;    put pointer to number on stack 
226f			;   
226f			;  
226f			  
226f			forth_apush: 
226f				; kernel push 
226f			 
226f			if DEBUG_FORTH_PUSH 
226f						DMARK "PSH" 
226f f5				push af  
2270 3a 84 22			ld a, (.dmark)  
2273 32 68 fe			ld (debug_mark),a  
2276 3a 85 22			ld a, (.dmark+1)  
2279 32 69 fe			ld (debug_mark+1),a  
227c 3a 86 22			ld a, (.dmark+2)  
227f 32 6a fe			ld (debug_mark+2),a  
2282 18 03			jr .pastdmark  
2284 ..			.dmark: db "PSH"  
2287 f1			.pastdmark: pop af  
2288			endm  
# End of macro DMARK
2288				CALLMONITOR 
2288 cd 6c fe			call debug_vector  
228b				endm  
# End of macro CALLMONITOR
228b			endif	 
228b				; identify input type 
228b			 
228b 7e				ld a,(hl) 
228c fe 22			cp '"' 
228e 28 0a			jr z, .fapstr 
2290 fe 24			cp '$' 
2292 ca ba 22			jp z, .faphex 
2295 fe 25			cp '%' 
2297 ca a2 22			jp z, .fapbin 
229a			;	cp 'b' 
229a			;	jp z, .fabin 
229a				; else decimal 
229a			 
229a				; TODO do decimal conversion 
229a				; decimal is stored as a 16bit word 
229a			 
229a				; by default everything is a string if type is not detected 
229a			.fapstr: ; 
229a fe 22			cp '"' 
229c 20 01			jr nz, .strnoqu 
229e 23				inc hl 
229f			.strnoqu: 
229f c3 74 21			jp forth_push_str 
22a2			 
22a2			 
22a2			 
22a2			.fapbin:    ; push a binary string.  
22a2 11 00 00			ld de, 0   ; hold a 16bit value 
22a5			 
22a5 23			.fapbinshift:	inc hl  
22a6 7e				ld a,(hl) 
22a7 fe 00			cp 0     ; done scanning  
22a9 28 0b			jr z, .fapbdone  	; got it in HL so push  
22ab			 
22ab				; left shift de 
22ab eb				ex de, hl	 
22ac 29				add hl, hl 
22ad			 
22ad				; is 1 
22ad fe 31			cp '1' 
22af 20 02			jr nz, .binzero 
22b1 cb 4d			bit 1, l 
22b3			.binzero: 
22b3 eb				ex de, hl	 ; save current de 
22b4 18 ef			jr .fapbinshift 
22b6			 
22b6			.fapbdone: 
22b6 eb				ex de, hl 
22b7 c3 06 21			jp forth_push_numhl 
22ba			 
22ba			 
22ba			.faphex:   ; hex is always stored as a 16bit word 
22ba				; skip number prefix 
22ba 23				inc hl 
22bb				; turn ascii into number 
22bb cd 87 13			call get_word_hl	; ret 16bit word in hl 
22be			 
22be c3 06 21			jp forth_push_numhl 
22c1			 
22c1 00				 nop 
22c2			 
22c2			.fabin:   ; TODO bin conversion 
22c2			 
22c2			 
22c2 c9				ret 
22c3			 
22c3			 
22c3			; get either a string ptr or a 16bit word from the data stack 
22c3			 
22c3			FORTH_DSP: macro 
22c3				call macro_forth_dsp 
22c3				endm 
22c3			 
22c3			macro_forth_dsp: 
22c3				; data stack pointer points to current word on tos 
22c3			 
22c3 2a eb f9			ld hl,(cli_data_sp) 
22c6			 
22c6				if DEBUG_FORTH_PUSH 
22c6						DMARK "DSP" 
22c6 f5				push af  
22c7 3a db 22			ld a, (.dmark)  
22ca 32 68 fe			ld (debug_mark),a  
22cd 3a dc 22			ld a, (.dmark+1)  
22d0 32 69 fe			ld (debug_mark+1),a  
22d3 3a dd 22			ld a, (.dmark+2)  
22d6 32 6a fe			ld (debug_mark+2),a  
22d9 18 03			jr .pastdmark  
22db ..			.dmark: db "DSP"  
22de f1			.pastdmark: pop af  
22df			endm  
# End of macro DMARK
22df			 
22df cd 38 5e				call display_data_sp 
22e2				;call break_point_state 
22e2				;rst 030h 
22e2				CALLMONITOR 
22e2 cd 6c fe			call debug_vector  
22e5				endm  
# End of macro CALLMONITOR
22e5				endif 
22e5			 
22e5 c9				ret 
22e6			 
22e6			; return hl to start of value on stack 
22e6			 
22e6			FORTH_DSP_VALUE: macro 
22e6				call macro_forth_dsp_value 
22e6				endm 
22e6			 
22e6			macro_forth_dsp_value: 
22e6			 
22e6				FORTH_DSP 
22e6 cd c3 22			call macro_forth_dsp 
22e9				endm 
# End of macro FORTH_DSP
22e9			 
22e9 d5				push de 
22ea			 
22ea 23				inc hl ; skip type 
22eb			 
22eb 5e				ld e, (hl) 
22ec 23				inc hl 
22ed 56				ld d, (hl) 
22ee eb				ex de,hl  
22ef			 
22ef d1				pop de 
22f0			 
22f0 c9				ret 
22f1			 
22f1			; return hl to start of value to second item on stack 
22f1			 
22f1			FORTH_DSP_VALUEM1: macro 
22f1				call macro_forth_dsp_value_m1 
22f1				endm 
22f1			 
22f1			macro_forth_dsp_value_m1: 
22f1			 
22f1				FORTH_DSP 
22f1 cd c3 22			call macro_forth_dsp 
22f4				endm 
# End of macro FORTH_DSP
22f4			 
22f4 2b				dec hl 
22f5 2b				dec hl 
22f6			;	dec hl 
22f6			 
22f6 d5				push de 
22f7			 
22f7 5e				ld e, (hl) 
22f8 23				inc hl 
22f9 56				ld d, (hl) 
22fa eb				ex de,hl  
22fb			 
22fb d1				pop de 
22fc			 
22fc c9				ret 
22fd			 
22fd				 
22fd			 
22fd			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22fd			 
22fd			FORTH_DSP_POP: macro 
22fd				call macro_forth_dsp_pop 
22fd				endm 
22fd			 
22fd			 
22fd			; get the tos data type 
22fd			 
22fd			FORTH_DSP_TYPE:   macro 
22fd			 
22fd				;FORTH_DSP_VALUE 
22fd				FORTH_DSP 
22fd				 
22fd				; hl points to value 
22fd				; check type 
22fd			 
22fd				ld a,(hl) 
22fd			 
22fd				endm 
22fd			 
22fd			; load the tos value into hl 
22fd			 
22fd			 
22fd			FORTH_DSP_VALUEHL:  macro 
22fd				call macro_dsp_valuehl 
22fd				endm 
22fd			 
22fd			 
22fd			 
22fd			macro_dsp_valuehl: 
22fd				FORTH_DSP_VALUE 
22fd cd e6 22			call macro_forth_dsp_value 
2300				endm 
# End of macro FORTH_DSP_VALUE
2300			 
2300				;FORTH_ERR_TOS_NOTNUM 
2300			 
2300				;inc hl   ; skip type id 
2300			 
2300			;	push de 
2300			; 
2300			;	ld e, (hl) 
2300			;	inc hl 
2300			;	ld d, (hl) 
2300			;	ex de,hl  
2300			 
2300			;	pop de 
2300			 
2300				if DEBUG_FORTH_PUSH 
2300						DMARK "DVL" 
2300 f5				push af  
2301 3a 15 23			ld a, (.dmark)  
2304 32 68 fe			ld (debug_mark),a  
2307 3a 16 23			ld a, (.dmark+1)  
230a 32 69 fe			ld (debug_mark+1),a  
230d 3a 17 23			ld a, (.dmark+2)  
2310 32 6a fe			ld (debug_mark+2),a  
2313 18 03			jr .pastdmark  
2315 ..			.dmark: db "DVL"  
2318 f1			.pastdmark: pop af  
2319			endm  
# End of macro DMARK
2319				CALLMONITOR 
2319 cd 6c fe			call debug_vector  
231c				endm  
# End of macro CALLMONITOR
231c				endif 
231c c9				ret 
231d			 
231d			forth_apushstrhl:      
231d				; push of string requires use of cli_origptr 
231d				; bodge use 
231d			 
231d				; get current cli_origptr, save, update with temp pointer  
231d ed 5b 3b fa		ld de, (cli_origptr) 
2321 22 3b fa			ld (cli_origptr), hl 
2324 d5				push de 
2325 cd 6f 22			call forth_apush 
2328 d1				pop de 
2329 ed 53 3b fa		ld (cli_origptr), de 
232d c9			        ret	 
232e			 
232e			 
232e			; increase loop stack pointer and save hl to it 
232e				 
232e			FORTH_LOOP_NEXT: macro 
232e				call macro_forth_loop_next 
232e				;nop 
232e				endm 
232e			 
232e			macro_forth_loop_next: 
232e				if DEBUG_FORTH_STACK_GUARD 
232e cd 71 72				call check_stacks 
2331				endif 
2331 e5				push hl 
2332 d5				push de 
2333 eb				ex de,hl 
2334 2a ed f9			ld hl,(cli_loop_sp) 
2337 23				inc hl 
2338 23				inc hl 
2339					if DEBUG_FORTH_WORDS 
2339						DMARK "LNX" 
2339 f5				push af  
233a 3a 4e 23			ld a, (.dmark)  
233d 32 68 fe			ld (debug_mark),a  
2340 3a 4f 23			ld a, (.dmark+1)  
2343 32 69 fe			ld (debug_mark+1),a  
2346 3a 50 23			ld a, (.dmark+2)  
2349 32 6a fe			ld (debug_mark+2),a  
234c 18 03			jr .pastdmark  
234e ..			.dmark: db "LNX"  
2351 f1			.pastdmark: pop af  
2352			endm  
# End of macro DMARK
2352						CALLMONITOR 
2352 cd 6c fe			call debug_vector  
2355				endm  
# End of macro CALLMONITOR
2355					endif 
2355 22 ed f9			ld (cli_loop_sp),hl 
2358 73				ld (hl), e 
2359 23				inc hl 
235a 72				ld (hl), d 
235b d1				pop de    ; been reversed so save a swap on restore 
235c e1				pop hl 
235d				if DEBUG_FORTH_STACK_GUARD 
235d cd 71 72				call check_stacks 
2360				endif 
2360 c9				ret 
2361			 
2361			; get current ret stack pointer and save to hl  
2361				 
2361			FORTH_LOOP_TOS: macro 
2361				call macro_forth_loop_tos 
2361				endm 
2361			 
2361			macro_forth_loop_tos: 
2361 d5				push de 
2362 2a ed f9			ld hl,(cli_loop_sp) 
2365 5e				ld e, (hl) 
2366 23				inc hl 
2367 56				ld d, (hl) 
2368 eb				ex de, hl 
2369 d1				pop de 
236a c9				ret 
236b			 
236b			; pop loop stack pointer 
236b				 
236b			FORTH_LOOP_POP: macro 
236b				call macro_forth_loop_pop 
236b				endm 
236b			 
236b			 
236b			macro_forth_loop_pop: 
236b				if DEBUG_FORTH_STACK_GUARD 
236b					DMARK "LPP" 
236b f5				push af  
236c 3a 80 23			ld a, (.dmark)  
236f 32 68 fe			ld (debug_mark),a  
2372 3a 81 23			ld a, (.dmark+1)  
2375 32 69 fe			ld (debug_mark+1),a  
2378 3a 82 23			ld a, (.dmark+2)  
237b 32 6a fe			ld (debug_mark+2),a  
237e 18 03			jr .pastdmark  
2380 ..			.dmark: db "LPP"  
2383 f1			.pastdmark: pop af  
2384			endm  
# End of macro DMARK
2384 cd 71 72				call check_stacks 
2387					FORTH_CHK_LOOP_UNDER 
2387 e5				push hl 
2388 d5				push de 
2389 2a ed f9			ld hl,(cli_loop_sp) 
238c 11 27 f9			ld de, cli_loop_stack 
238f cd ee 0f			call cmp16 
2392 da 8b 73			jp c, fault_loop_under 
2395 d1				pop de 
2396 e1				pop hl 
2397				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2397				endif 
2397 e5				push hl 
2398 2a ed f9			ld hl,(cli_loop_sp) 
239b 2b				dec hl 
239c 2b				dec hl 
239d 22 ed f9			ld (cli_loop_sp), hl 
23a0				; TODO do stack underflow checks 
23a0 e1				pop hl 
23a1				if DEBUG_FORTH_STACK_GUARD 
23a1 cd 71 72				call check_stacks 
23a4					FORTH_CHK_LOOP_UNDER 
23a4 e5				push hl 
23a5 d5				push de 
23a6 2a ed f9			ld hl,(cli_loop_sp) 
23a9 11 27 f9			ld de, cli_loop_stack 
23ac cd ee 0f			call cmp16 
23af da 8b 73			jp c, fault_loop_under 
23b2 d1				pop de 
23b3 e1				pop hl 
23b4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23b4				endif 
23b4 c9				ret 
23b5			 
23b5			macro_forth_dsp_pop: 
23b5			 
23b5 e5				push hl 
23b6			 
23b6				; release malloc data 
23b6			 
23b6				if DEBUG_FORTH_STACK_GUARD 
23b6 cd 71 72				call check_stacks 
23b9					FORTH_CHK_DSP_UNDER 
23b9 e5				push hl 
23ba d5				push de 
23bb 2a eb f9			ld hl,(cli_data_sp) 
23be 11 25 f7			ld de, cli_data_stack 
23c1 cd ee 0f			call cmp16 
23c4 da 7f 73			jp c, fault_dsp_under 
23c7 d1				pop de 
23c8 e1				pop hl 
23c9				endm 
# End of macro FORTH_CHK_DSP_UNDER
23c9				endif 
23c9				;ld hl,(cli_data_sp) 
23c9			if DEBUG_FORTH_DOT 
23c9				DMARK "DPP" 
23c9 f5				push af  
23ca 3a de 23			ld a, (.dmark)  
23cd 32 68 fe			ld (debug_mark),a  
23d0 3a df 23			ld a, (.dmark+1)  
23d3 32 69 fe			ld (debug_mark+1),a  
23d6 3a e0 23			ld a, (.dmark+2)  
23d9 32 6a fe			ld (debug_mark+2),a  
23dc 18 03			jr .pastdmark  
23de ..			.dmark: db "DPP"  
23e1 f1			.pastdmark: pop af  
23e2			endm  
# End of macro DMARK
23e2				CALLMONITOR 
23e2 cd 6c fe			call debug_vector  
23e5				endm  
# End of macro CALLMONITOR
23e5			endif	 
23e5			 
23e5			 
23e5			if FORTH_ENABLE_DSPPOPFREE 
23e5			 
23e5				FORTH_DSP 
23e5 cd c3 22			call macro_forth_dsp 
23e8				endm 
# End of macro FORTH_DSP
23e8			 
23e8 7e				ld a, (hl) 
23e9 fe 01			cp DS_TYPE_STR 
23eb 20 23			jr nz, .skippopfree 
23ed			 
23ed				FORTH_DSP_VALUEHL 
23ed cd fd 22			call macro_dsp_valuehl 
23f0				endm 
# End of macro FORTH_DSP_VALUEHL
23f0 00				nop 
23f1			if DEBUG_FORTH_DOT 
23f1				DMARK "DPf" 
23f1 f5				push af  
23f2 3a 06 24			ld a, (.dmark)  
23f5 32 68 fe			ld (debug_mark),a  
23f8 3a 07 24			ld a, (.dmark+1)  
23fb 32 69 fe			ld (debug_mark+1),a  
23fe 3a 08 24			ld a, (.dmark+2)  
2401 32 6a fe			ld (debug_mark+2),a  
2404 18 03			jr .pastdmark  
2406 ..			.dmark: db "DPf"  
2409 f1			.pastdmark: pop af  
240a			endm  
# End of macro DMARK
240a				CALLMONITOR 
240a cd 6c fe			call debug_vector  
240d				endm  
# End of macro CALLMONITOR
240d			endif	 
240d cd 61 15			call free 
2410			.skippopfree: 
2410				 
2410			 
2410			endif 
2410			 
2410			if DEBUG_FORTH_DOT_KEY 
2410				DMARK "DP2" 
2410				CALLMONITOR 
2410			endif	 
2410			 
2410				; move pointer down 
2410			 
2410 2a eb f9			ld hl,(cli_data_sp) 
2413 2b				dec hl 
2414 2b				dec hl 
2415			; PARSEV5 
2415 2b				dec hl 
2416 22 eb f9			ld (cli_data_sp), hl 
2419			 
2419				if DEBUG_FORTH_STACK_GUARD 
2419 cd 71 72				call check_stacks 
241c					FORTH_CHK_DSP_UNDER 
241c e5				push hl 
241d d5				push de 
241e 2a eb f9			ld hl,(cli_data_sp) 
2421 11 25 f7			ld de, cli_data_stack 
2424 cd ee 0f			call cmp16 
2427 da 7f 73			jp c, fault_dsp_under 
242a d1				pop de 
242b e1				pop hl 
242c				endm 
# End of macro FORTH_CHK_DSP_UNDER
242c				endif 
242c			 
242c e1				pop hl 
242d			 
242d c9				ret 
242e			 
242e			getwordathl: 
242e				; hl points to an address 
242e				; load hl with the word at that address 
242e			 
242e d5				push de 
242f			 
242f 5e				ld e, (hl) 
2430 23				inc hl 
2431 56				ld d, (hl) 
2432 eb				ex de, hl 
2433			 
2433 d1				pop de 
2434 c9				ret 
2435			 
2435			 
2435			 
2435			 
2435			 
2435			; eof 
2435			 
# End of file forth_stackopsv5.asm
2435			endif 
2435			 
2435			loadwordinhl:	 
2435			 
2435 d5				push de 
2436			 
2436 5e				ld e, (hl) 
2437 23				inc hl 
2438 56				ld d, (hl) 
2439 eb				ex de,hl  
243a			 
243a d1				pop de 
243b			 
243b c9				ret 
243c			 
243c			user_word_eol:  
243c				; hl contains the pointer to where to create a linked list item from the end 
243c				; of the user dict to continue on at the system word dict 
243c				 
243c				; poke the stub of the word list linked list to repoint to rom words 
243c			 
243c				; stub format 
243c				; db   word id 
243c				; dw    link to next word 
243c			        ; db char length of token 
243c				; db string + 0 term 
243c				; db exec code....  
243c			 
243c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
243e 77				ld (hl), a		; word id 
243f 23				inc hl 
2440			 
2440 11 0b 26			ld de, sysdict 
2443 73				ld (hl), e		; next word link ie system dict 
2444 23				inc hl 
2445 72				ld (hl), d		; next word link ie system dict 
2446 23				inc hl	 
2447			 
2447			;	ld (hl), sysdict		; next word link ie system dict 
2447			;	inc hl 
2447			;	inc hl 
2447			 
2447			;	inc hl 
2447			;	inc hl 
2447			 
2447 3e 02			ld a, 2			; word length is 0 
2449 77				ld (hl), a	 
244a 23				inc hl 
244b			 
244b 3e 7e			ld a, '~'			; word length is 0 
244d 77				ld (hl), a	 
244e 23				inc hl 
244f 3e 00			ld a, 0			; save empty word 
2451 77				ld (hl), a 
2452			 
2452 c9				ret 
2453			 
2453				 
2453			 
2453			forthexec_cleanup: 
2453				FORTH_RSP_POP 
2453 cd ce 20			call macro_forth_rsp_pop 
2456				endm 
# End of macro FORTH_RSP_POP
2456 c9				ret 
2457			 
2457			forth_call_hl: 
2457				; taking hl 
2457 e5				push hl 
2458 c9				ret 
2459			 
2459			; this is called to reset Forth system but keep existing uwords etc 
2459			 
2459			forth_warmstart: 
2459				; setup stack over/under flow checks 
2459				if DEBUG_FORTH_STACK_GUARD 
2459 cd 57 72				call chk_stk_init 
245c				endif 
245c			 
245c				; init stack pointers  - * these stacks go upwards *  
245c 21 a9 f9			ld hl, cli_ret_stack 
245f 22 ef f9			ld (cli_ret_sp), hl	 
2462				; set bottom of stack 
2462 3e 00			ld a,0 
2464 77				ld (hl),a 
2465 23				inc hl 
2466 77				ld (hl),a 
2467			 
2467 21 25 f7			ld hl, cli_data_stack 
246a 22 eb f9			ld (cli_data_sp), hl	 
246d				; set bottom of stack 
246d 3e 00			ld a,0 
246f 77				ld (hl),a 
2470 23				inc hl 
2471 77				ld (hl),a 
2472			 
2472 21 27 f9			ld hl, cli_loop_stack 
2475 22 ed f9			ld (cli_loop_sp), hl	 
2478				; set bottom of stack 
2478 3e 00			ld a,0 
247a 77				ld (hl),a 
247b 23				inc hl 
247c 77				ld (hl),a 
247d			 
247d				; init extent of current open file 
247d			 
247d 3e 00			ld a, 0 
247f 32 67 fa			ld (store_openext), a 
2482			 
2482 c9				ret 
2483			 
2483			 
2483			 
2483			; Cold Start - this is called to setup the whole Forth system 
2483			 
2483			forth_init: 
2483			 
2483				; setup stack over/under flow checks 
2483			 
2483			;	if DEBUG_FORTH_STACK_GUARD 
2483			;		call chk_stk_init 
2483			;	endif 
2483			 
2483				; enable auto display updates (slow.....) 
2483			 
2483 3e 01			ld a, 1 
2485 32 39 fa			ld (cli_autodisplay), a 
2488			 
2488				; if storage is in use disable long reads for now 
2488 3e 00			ld a, 0 
248a 32 72 fa			ld (store_longread), a 
248d			 
248d			 
248d				; show start up screen 
248d			 
248d cd 9c 0d			call clear_display 
2490			 
2490 3e 00			ld a,0 
2492 32 5b fa			ld (f_cursor_ptr), a 
2495			 
2495				; set start of word list in start of ram - for use when creating user words 
2495			 
2495 21 00 80			ld hl, baseram 
2498 22 bb f4			ld (os_last_new_uword), hl 
249b cd 3c 24			call user_word_eol 
249e				 
249e			;		call display_data_sp 
249e			;		call next_page_prompt 
249e			 
249e			 
249e			 
249e			 
249e c9				ret 
249f			 
249f .. 00		.bootforth: db " Forth Kernel Init ",0 
24b3			 
24b3			; TODO push to stack 
24b3			 
24b3			;  
24b3			 
24b3			if FORTH_PARSEV2 
24b3			 
24b3			 
24b3				include "forth_parserv2.asm" 
24b3			 
24b3			endif 
24b3			 
24b3			 
24b3			; parse cli version 1 
24b3			 
24b3			if FORTH_PARSEV1 
24b3			 
24b3			 
24b3			 
24b3			      include "forth_parserv1.asm" 
24b3			endif 
24b3				 
24b3			if FORTH_PARSEV3 
24b3			 
24b3			 
24b3			 
24b3			      include "forth_parserv3.asm" 
24b3				include "forth_wordsv3.asm" 
24b3			endif 
24b3			 
24b3			if FORTH_PARSEV4 
24b3			 
24b3			 
24b3			 
24b3			      include "forth_parserv4.asm" 
24b3				include "forth_wordsv4.asm" 
24b3			endif 
24b3			 
24b3			if FORTH_PARSEV5 
24b3			 
24b3			 
24b3			 
24b3			      include "forth_parserv5.asm" 
24b3			 
24b3			 
24b3			; A better parser without using malloc and string copies all over the place.  
24b3			; Exec in situ should be faster 
24b3			 
24b3			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24b3			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24b3			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24b3			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24b3			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24b3			WORD_SYS_END: equ 0   ; Opcode for all user words 
24b3			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24b3			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24b3			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24b3			 
24b3			; Core word preamble macro 
24b3			 
24b3			CWHEAD:   macro nxtword opcode lit len opflags 
24b3				db WORD_SYS_CORE+opcode             
24b3				; internal op code number 
24b3				dw nxtword            
24b3				; link to next dict word block 
24b3				db len + 1 
24b3				; literal length of dict word inc zero term 
24b3				db lit,0              
24b3				; literal dict word 
24b3			        ; TODO db opflags        
24b3				endm 
24b3			 
24b3			 
24b3			NEXTW: macro  
24b3				jp macro_next 
24b3				endm 
24b3			 
24b3			macro_next: 
24b3			if DEBUG_FORTH_PARSE_KEY 
24b3				DMARK "NXT" 
24b3				CALLMONITOR 
24b3			endif	 
24b3			;	inc hl  ; skip token null term  
24b3 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24b7 ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24bb 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24be			if DEBUG_FORTH_PARSE_KEY 
24be				DMARK "}AA" 
24be				CALLMONITOR 
24be			endif	 
24be c3 c1 25			jp execnext 
24c1				;jp exec1 
24c1			       
24c1			 
24c1			 
24c1			; Another go at the parser to compile  
24c1			 
24c1			 
24c1			; TODO rework parser to change all of the string words to byte tokens 
24c1			; TODO do a search for  
24c1			 
24c1			; TODO first run normal parser to zero term sections 
24c1			; TODO for each word do a token look up to get the op code 
24c1			; TODO need some means to flag to the exec that this is a byte code form    
24c1			 
24c1			 
24c1			forthcompile: 
24c1			 
24c1			; 
24c1			; line parse: 
24c1			;       parse raw input buffer 
24c1			;       tokenise the words 
24c1			;       malloc new copy (for looping etc) 
24c1			;       copy to malloc + current pc in line to start of string and add line term 
24c1			;       save on new rsp 
24c1			; 
24c1			 
24c1			; hl to point to the line to tokenise 
24c1			 
24c1			;	push hl 
24c1 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24c4			 
24c4			;	ld a,0		; string term on input 
24c4			;	call strlent 
24c4			 
24c4			;	ld (os_tok_len), hl	 ; save string length 
24c4			 
24c4			;if DEBUG_FORTH_TOK 
24c4			;	ex de,hl		 
24c4			;endif 
24c4			 
24c4			;	pop hl 		; get back string pointer 
24c4			 
24c4			if DEBUG_FORTH_TOK 
24c4						DMARK "TOc" 
24c4				CALLMONITOR 
24c4			endif 
24c4 7e			.cptoken2:    ld a,(hl) 
24c5 23				inc hl 
24c6 fe 7f			cp FORTH_END_BUFFER 
24c8 28 29			jr z, .cptokendone2 
24ca fe 00			cp 0 
24cc 28 25			jr z, .cptokendone2 
24ce fe 22			cp '"' 
24d0 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24d2 fe 20			cp ' ' 
24d4 20 ee			jr nz,  .cptoken2 
24d6			 
24d6			; TODO consume comments held between ( and ) 
24d6			 
24d6				; we have a space so change to zero term for dict match later 
24d6 2b				dec hl 
24d7 3e 00			ld a,0 
24d9 77				ld (hl), a 
24da 23				inc hl 
24db 18 e7			jr .cptoken2 
24dd				 
24dd			 
24dd			.cptokenstr2: 
24dd				; skip all white space until either eol (because forgot to term) or end double quote 
24dd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24dd				;inc hl ; skip current double quote 
24dd 7e				ld a,(hl) 
24de 23				inc hl 
24df fe 22			cp '"' 
24e1 28 e1			jr z, .cptoken2 
24e3 fe 7f			cp FORTH_END_BUFFER 
24e5 28 0c			jr z, .cptokendone2 
24e7 fe 00			cp 0 
24e9 28 08			jr z, .cptokendone2 
24eb fe 20			cp ' ' 
24ed 28 02			jr z, .cptmp2 
24ef 18 ec			jr .cptokenstr2 
24f1			 
24f1			.cptmp2:	; we have a space so change to zero term for dict match later 
24f1				;dec hl 
24f1				;ld a,"-"	; TODO remove this when working 
24f1				;ld (hl), a 
24f1				;inc hl 
24f1 18 ea			jr .cptokenstr2 
24f3			 
24f3			.cptokendone2: 
24f3				;inc hl 
24f3 3e 7f			ld a, FORTH_END_BUFFER 
24f5 77				ld (hl),a 
24f6 23				inc hl 
24f7 3e 21			ld a, '!' 
24f9 77				ld (hl),a 
24fa			 
24fa 2a bf f4			ld hl,(os_tok_ptr) 
24fd			         
24fd			if DEBUG_FORTH_TOK 
24fd						DMARK "Tc1" 
24fd				CALLMONITOR 
24fd			endif 
24fd			 
24fd				; push exec string to top of return stack 
24fd				FORTH_RSP_NEXT 
24fd cd ad 20			call macro_forth_rsp_next 
2500				endm 
# End of macro FORTH_RSP_NEXT
2500 c9				ret 
2501			 
2501			; Another go at the parser need to simplify the process 
2501			 
2501			forthparse: 
2501			 
2501			; 
2501			; line parse: 
2501			;       parse raw input buffer 
2501			;       tokenise the words 
2501			;       malloc new copy (for looping etc) 
2501			;       copy to malloc + current pc in line to start of string and add line term 
2501			;       save on new rsp 
2501			; 
2501			 
2501			; hl to point to the line to tokenise 
2501			 
2501			;	push hl 
2501 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
2504			 
2504			;	ld a,0		; string term on input 
2504			;	call strlent 
2504			 
2504			;	ld (os_tok_len), hl	 ; save string length 
2504			 
2504			;if DEBUG_FORTH_TOK 
2504			;	ex de,hl		 
2504			;endif 
2504			 
2504			;	pop hl 		; get back string pointer 
2504			 
2504			if DEBUG_FORTH_TOK 
2504						DMARK "TOK" 
2504				CALLMONITOR 
2504			endif 
2504 7e			.ptoken2:    ld a,(hl) 
2505 23				inc hl 
2506 fe 7f			cp FORTH_END_BUFFER 
2508 28 29			jr z, .ptokendone2 
250a fe 00			cp 0 
250c 28 25			jr z, .ptokendone2 
250e fe 22			cp '"' 
2510 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2512 fe 20			cp ' ' 
2514 20 ee			jr nz,  .ptoken2 
2516			 
2516			; TODO consume comments held between ( and ) 
2516			 
2516				; we have a space so change to zero term for dict match later 
2516 2b				dec hl 
2517 3e 00			ld a,0 
2519 77				ld (hl), a 
251a 23				inc hl 
251b 18 e7			jr .ptoken2 
251d				 
251d			 
251d			.ptokenstr2: 
251d				; skip all white space until either eol (because forgot to term) or end double quote 
251d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
251d				;inc hl ; skip current double quote 
251d 7e				ld a,(hl) 
251e 23				inc hl 
251f fe 22			cp '"' 
2521 28 e1			jr z, .ptoken2 
2523 fe 7f			cp FORTH_END_BUFFER 
2525 28 0c			jr z, .ptokendone2 
2527 fe 00			cp 0 
2529 28 08			jr z, .ptokendone2 
252b fe 20			cp ' ' 
252d 28 02			jr z, .ptmp2 
252f 18 ec			jr .ptokenstr2 
2531			 
2531			.ptmp2:	; we have a space so change to zero term for dict match later 
2531				;dec hl 
2531				;ld a,"-"	; TODO remove this when working 
2531				;ld (hl), a 
2531				;inc hl 
2531 18 ea			jr .ptokenstr2 
2533			 
2533			.ptokendone2: 
2533				;inc hl 
2533 3e 7f			ld a, FORTH_END_BUFFER 
2535 77				ld (hl),a 
2536 23				inc hl 
2537 3e 21			ld a, '!' 
2539 77				ld (hl),a 
253a			 
253a 2a bf f4			ld hl,(os_tok_ptr) 
253d			         
253d			if DEBUG_FORTH_TOK 
253d						DMARK "TK1" 
253d				CALLMONITOR 
253d			endif 
253d			 
253d				; push exec string to top of return stack 
253d				FORTH_RSP_NEXT 
253d cd ad 20			call macro_forth_rsp_next 
2540				endm 
# End of macro FORTH_RSP_NEXT
2540 c9				ret 
2541			 
2541			; 
2541			;	; malloc size + buffer pointer + if is loop flag 
2541			;	ld hl,(os_tok_len) 		 ; get string length 
2541			; 
2541			;	ld a,l 
2541			; 
2541			;	cp 0			; we dont want to use a null string 
2541			;	ret z 
2541			; 
2541			;;	add 3    ; prefix malloc with buffer for current word ptr 
2541			; 
2541			;	add 5     ; TODO when certain not over writing memory remove 
2541			; 
2541			;		 
2541			; 
2541			;if DEBUG_FORTH_TOK 
2541			;			DMARK "TKE" 
2541			;	CALLMONITOR 
2541			;endif 
2541			; 
2541			;	ld l,a 
2541			;	ld h,0 
2541			;;	push hl   ; save required space for the copy later 
2541			;	call malloc 
2541			;if DEBUG_FORTH_TOK 
2541			;			DMARK "TKM" 
2541			;	CALLMONITOR 
2541			;endif 
2541			;	if DEBUG_FORTH_MALLOC_GUARD 
2541			;		push af 
2541			;		call ishlzero 
2541			;;		ld a, l 
2541			;;		add h 
2541			;;		cp 0 
2541			;		pop af 
2541			;		 
2541			;		call z,malloc_error 
2541			;	endif 
2541			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2541			; 
2541			; 
2541			;if DEBUG_FORTH_TOK 
2541			;			DMARK "TKR" 
2541			;	CALLMONITOR 
2541			;endif 
2541			; 
2541			;	FORTH_RSP_NEXT 
2541			; 
2541			;	;inc hl	 ; go past current buffer pointer 
2541			;	;inc hl 
2541			;	;inc hl   ; and past if loop flag 
2541			;		; TODO Need to set flag  
2541			; 
2541			;	 
2541			;	 
2541			;	ex de,hl	; malloc is dest 
2541			;	ld hl, (os_tok_len) 
2541			;;	pop bc 
2541			;	ld c, l                
2541			;	ld b,0 
2541			;	ld hl, (os_tok_ptr) 
2541			; 
2541			;if DEBUG_FORTH_TOK 
2541			;			DMARK "TKT" 
2541			;	CALLMONITOR 
2541			;endif 
2541			; 
2541			;	; do str cpy 
2541			; 
2541			;	ldir      ; copy byte in hl to de 
2541			; 
2541			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2541			; 
2541			;if DEBUG_FORTH_TOK 
2541			; 
2541			;			DMARK "TKY" 
2541			;	CALLMONITOR 
2541			;endif 
2541			;	;ld a,0 
2541			;	;ld a,FORTH_END_BUFFER 
2541			;	ex de, hl 
2541			;	;dec hl			 ; go back over the space delim at the end of word 
2541			;	;ld (hl),a 
2541			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2541			;	ld a,FORTH_END_BUFFER 
2541			;	ld (hl),a 
2541			;	inc hl 
2541			;	ld a,FORTH_END_BUFFER 
2541			;	ld (hl),a 
2541			; 
2541			;	; init the malloc area data 
2541			;	; set pc for in current area 
2541			;	;ld hl, (os_tok_malloc) 
2541			;	;inc hl 
2541			;	;inc hl 
2541			;	;inc hl 
2541			;	;ex de,hl 
2541			;	;ld hl, (os_tok_malloc) 
2541			;	;ld (hl),e 
2541			;	;inc hl 
2541			;	;ld (hl),d 
2541			; 
2541			; 
2541			;	ld hl,(os_tok_malloc) 
2541			;if DEBUG_FORTH_PARSE_KEY 
2541			;			DMARK "TKU" 
2541			;	CALLMONITOR 
2541			;endif 
2541			; 
2541			;	ret 
2541			 
2541			forthexec: 
2541			 
2541			; line exec: 
2541			; forth parser 
2541			 
2541			; 
2541			;       get current exec line on rsp 
2541			 
2541				FORTH_RSP_TOS 
2541 cd c4 20			call macro_forth_rsp_tos 
2544				endm 
# End of macro FORTH_RSP_TOS
2544			 
2544			;       restore current pc - hl points to malloc of data 
2544			 
2544				;ld e, (hl) 
2544				;inc hl 
2544				;ld d, (hl) 
2544				;ex de,hl 
2544			 
2544			 
2544			exec1: 
2544 22 bf f4			ld (os_tok_ptr), hl 
2547			 
2547				; copy our PC to working vars  
2547 22 3d fa			ld (cli_ptr), hl 
254a 22 3b fa			ld (cli_origptr), hl 
254d			 
254d 7e				ld a,(hl) 
254e fe 7f			cp FORTH_END_BUFFER 
2550 c8				ret z 
2551			 
2551				; skip any nulls 
2551			 
2551 fe 00			cp 0 
2553 20 03			jr nz, .execword 
2555 23				inc hl 
2556 18 ec			jr exec1 
2558			 
2558			 
2558			.execword: 
2558			 
2558			 
2558			 
2558			if DEBUG_FORTH_PARSE_KEY 
2558						DMARK "KYQ" 
2558				CALLMONITOR 
2558			endif 
2558			;       while at start of word: 
2558			; get start of dict (in user area first) 
2558			 
2558 21 00 80		ld hl, baseram 
255b			;ld hl, sysdict 
255b 22 3f fa		ld (cli_nextword),hl 
255e			;           match word at pc 
255e			;           exec word 
255e			;           or push to dsp 
255e			;           forward to next token 
255e			;           if line term pop rsp and exit 
255e			;        
255e			 
255e			if DEBUG_FORTH_PARSE_KEY 
255e						DMARK "KYq" 
255e				CALLMONITOR 
255e			endif 
255e			 
255e			; 
255e			; word comp 
255e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
255e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
255e			;    move to start of word  
255e			;    compare word to cli_token 
255e			 
255e			.execpnword:	; HL at start of a word in the dictionary to check 
255e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
255e			;	ld (cli_ptr), hl 
255e			 
255e 2a 3f fa			ld hl,(cli_nextword) 
2561			 
2561 cd 04 26			call forth_tok_next 
2564			; tok next start here 
2564			;	; TODO skip compiled symbol for now 
2564			;	inc hl 
2564			; 
2564			;	; save pointer to next word 
2564			; 
2564			;	; hl now points to the address of the next word pointer  
2564			;	ld e, (hl) 
2564			;	inc hl 
2564			;	ld d, (hl) 
2564			;	inc l 
2564			; 
2564			;	ex de,hl 
2564			;if DEBUG_FORTH_PARSE_NEXTWORD 
2564			;	push bc 
2564			;	ld bc, (cli_nextword) 
2564			;			DMARK "NXW" 
2564			;	CALLMONITOR 
2564			;	pop bc 
2564			;endif 
2564			; tok next end here 
2564 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2567 eb				ex de, hl 
2568			 
2568			 
2568				; save the pointer of the current token - 1 to check against 
2568				 
2568 22 43 fa			ld (cli_token), hl   
256b				; TODO maybe remove below save if no debug 
256b				; save token string ptr for any debug later 
256b 23				inc hl  
256c 22 45 fa			ld (cli_origtoken), hl 
256f 2b				dec hl 
2570				; save pointer to the start of the next dictionay word 
2570 7e				ld a,(hl)   ; get string length 
2571 47				ld b,a 
2572			.execpnwordinc:  
2572 23				inc hl 
2573 10 fd			djnz .execpnwordinc 
2575 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
2578			 
2578				; now check the word token against the string being parsed 
2578			 
2578 2a 43 fa			ld hl,(cli_token) 
257b 23				inc hl     ; skip string length (use zero term instead to end) 
257c 22 43 fa			ld (cli_token), hl 
257f			 
257f			if DEBUG_FORTH_PARSE_KEY 
257f						DMARK "KY2" 
257f			endif 
257f			if DEBUG_FORTH_PARSE_EXEC 
257f				; see if disabled 
257f			 
257f			;	ld a, (os_view_disable) 
257f			;	cp '*' 
257f				ld a, (debug_vector) 
257f				cp $c9   ; RET  
257f				jr z, .skip 
257f			 
257f				push hl 
257f				push hl 
257f				call clear_display 
257f				ld de, .compword 
257f				ld a, display_row_1 
257f				call str_at_display 
257f				pop de 
257f				ld a, display_row_2 
257f				call str_at_display 
257f				ld hl,(cli_ptr) 
257f				ld a,(hl) 
257f			        ld hl, os_word_scratch 
257f				ld (hl),a 
257f				ld a,0 
257f				inc hl 
257f				ld (hl),a 	 
257f				ld de, os_word_scratch 
257f				ld a, display_row_2+10 
257f				call str_at_display 
257f				call update_display 
257f				ld a, 100 
257f				call aDelayInMS 
257f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
257f				call delay250ms 
257f				endif 
257f				pop hl 
257f			.skip:  
257f			endif	 
257f			.execpnchar:    ; compare char between token and string to parse 
257f			 
257f			if DEBUG_FORTH_PARSE_KEY 
257f						DMARK "Ky3" 
257f			endif 
257f			if DEBUG_FORTH_PARSE_EXEC 
257f				; see if disabled 
257f			 
257f			;	ld a, (os_view_disable) 
257f			;	cp '*' 
257f				ld a, (debug_vector) 
257f				cp $C9  ; RET 
257f				jr z, .skip2 
257f			 
257f			;	call clear_display 
257f			ld hl,(cli_token) 
257f			ld a,(hl) 
257f			ld (os_word_scratch),a 
257f				ld hl,(cli_ptr) 
257f			ld a,(hl) 
257f				ld (os_word_scratch+1),a 
257f				ld a,0 
257f				ld (os_word_scratch+2),a 
257f				ld de,os_word_scratch 
257f				ld a,display_row_4 
257f				call str_at_display 
257f				call update_display 
257f			.skip2:  
257f			endif 
257f 2a 43 fa			ld hl,(cli_token) 
2582 7e				ld a, (hl)	 ; char in word token 
2583 23				inc hl 		; move to next char 
2584 22 43 fa			ld (cli_token), hl ; and save it 
2587 47				ld b,a 
2588			 
2588 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
258b 7e				ld a,(hl) 
258c 23				inc hl 
258d 22 3d fa			ld (cli_ptr), hl		; move to next char 
2590 cd 25 14			call toUpper 		; make sure the input string matches case 
2593			 
2593			if DEBUG_FORTH_PARSE 
2593			endif 
2593			 
2593				; input stream end of token is a space so get rid of it 
2593			 
2593			;	cp ' ' 
2593			;	jr nz, .pnskipspace 
2593			; 
2593			;	ld a, 0		; make same term as word token term 
2593			; 
2593			;.pnskipspace: 
2593			 
2593			if DEBUG_FORTH_PARSE_KEY 
2593						DMARK "KY7" 
2593			endif 
2593 b8				cp b 
2594 c2 aa 25			jp nz, .execpnskipword	 ; no match so move to next word 
2597				 
2597			;    if same 
2597			;       scan for string terms 0 for token and 32 for input 
2597			 
2597				 
2597			if DEBUG_FORTH_PARSE_KEY 
2597						DMARK "KY8" 
2597			endif 
2597			 
2597 80				add b			 
2598 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
259a							; TODO need to make sure last word in zero term string is accounted for 
259a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
259c			 
259c			 
259c				; at end of both strings so both are exact match 
259c			 
259c			;       skip ptr for next word 
259c			 
259c 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
259f 23				inc hl			 ; at next char 
25a0 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
25a3 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25a6				 
25a6				 
25a6			if DEBUG_FORTH_PARSE_KEY 
25a6						DMARK "KY3" 
25a6			endif 
25a6			 
25a6			 
25a6			 
25a6			;       exec code block 
25a6			if DEBUG_FORTH_JP 
25a6				call clear_display 
25a6				call update_display 
25a6				call delay1s 
25a6				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a6				ld a,h 
25a6				ld hl, os_word_scratch 
25a6				call hexout 
25a6				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a6				ld a,l 
25a6				ld hl, os_word_scratch+2 
25a6				call hexout 
25a6				ld hl, os_word_scratch+4 
25a6				ld a,0 
25a6				ld (hl),a 
25a6				ld de,os_word_scratch 
25a6				call str_at_display 
25a6					ld a, display_row_2 
25a6					call str_at_display 
25a6				ld de, (cli_origtoken) 
25a6				ld a, display_row_1+10 
25a6					call str_at_display 
25a6			 
25a6				ld a,display_row_1 
25a6				ld de, .foundword 
25a6				ld a, display_row_3 
25a6				call str_at_display 
25a6				call update_display 
25a6				call delay1s 
25a6				call delay1s 
25a6				call delay1s 
25a6			endif 
25a6			 
25a6			if DEBUG_FORTH_PARSE_KEY 
25a6						DMARK "KYj" 
25a6			endif 
25a6				; TODO save the word pointer in this exec 
25a6			 
25a6 2a 41 fa			ld hl,(cli_execword) 
25a9 e9				jp (hl) 
25aa			 
25aa			 
25aa			;    if not same 
25aa			;	scan for zero term 
25aa			;	get ptr for next word 
25aa			;	goto word comp 
25aa			 
25aa			.execpnskipword:	; get pointer to next word 
25aa 2a 3f fa			ld hl,(cli_nextword) 
25ad			 
25ad 7e				ld a,(hl) 
25ae fe 00			cp WORD_SYS_END 
25b0			;	cp 0 
25b0 28 09			jr z, .execendofdict			 ; at end of words 
25b2			 
25b2			if DEBUG_FORTH_PARSE_KEY 
25b2						DMARK "KY4" 
25b2			endif 
25b2			if DEBUG_FORTH_PARSE_EXEC 
25b2			 
25b2				; see if disabled 
25b2			 
25b2			;	ld a, (os_view_disable) 
25b2			;	cp '*' 
25b2				ld a,(debug_vector) 
25b2				cp $c9   ; RET 
25b2				jr z, .noskip 
25b2			 
25b2			 
25b2				ld de, .nowordfound 
25b2				ld a, display_row_3 
25b2				call str_at_display 
25b2				call update_display 
25b2				ld a, 100 
25b2				call aDelayInMS 
25b2				 
25b2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b2					call delay250ms 
25b2				endif 
25b2			.noskip:  
25b2			 
25b2			endif	 
25b2			 
25b2 2a 3b fa			ld hl,(cli_origptr) 
25b5 22 3d fa			ld (cli_ptr),hl 
25b8			 
25b8			if DEBUG_FORTH_PARSE_KEY 
25b8						DMARK "KY5" 
25b8			endif 
25b8 c3 5e 25			jp .execpnword			; else go to next word 
25bb			 
25bb			.execendofdict:  
25bb			 
25bb			if DEBUG_FORTH_PARSE_KEY 
25bb						DMARK "KYe" 
25bb			endif 
25bb			if DEBUG_FORTH_PARSE_EXEC 
25bb				; see if disabled 
25bb			 
25bb			;	ld a, (os_view_disable) 
25bb			;	cp '*' 
25bb				ld a,(debug_vector) 
25bb				cp $c9   ; ret 
25bb				jr z, .ispskip 
25bb			 
25bb				call clear_display 
25bb				call update_display 
25bb				call delay1s 
25bb				ld de, (cli_origptr) 
25bb				ld a, display_row_1 
25bb				call str_at_display 
25bb				 
25bb				ld de, .enddict 
25bb				ld a, display_row_3 
25bb				call str_at_display 
25bb				call update_display 
25bb				ld a, 100 
25bb				call aDelayInMS 
25bb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25bb				call delay1s 
25bb				call delay1s 
25bb				call delay1s 
25bb				endif 
25bb			.ispskip:  
25bb				 
25bb			endif	 
25bb			 
25bb			 
25bb			 
25bb				; if the word is not a keyword then must be a literal so push it to stack 
25bb			 
25bb			; push token to stack to end of word 
25bb			 
25bb				STACKFRAME ON $1efe $2f9f 
25bb				if DEBUG_STACK_IMB 
25bb					if ON 
25bb						exx 
25bb						ld de, $1efe 
25bb						ld a, d 
25bb						ld hl, curframe 
25bb						call hexout 
25bb						ld a, e 
25bb						ld hl, curframe+2 
25bb						call hexout 
25bb						ld hl, $1efe 
25bb						push hl 
25bb						ld hl, $2f9f 
25bb						push hl 
25bb						exx 
25bb					endif 
25bb				endif 
25bb			endm 
# End of macro STACKFRAME
25bb			 
25bb 2a bf f4		ld hl,(os_tok_ptr) 
25be cd 6f 22		call forth_apush 
25c1			 
25c1				STACKFRAMECHK ON $1efe $2f9f 
25c1				if DEBUG_STACK_IMB 
25c1					if ON 
25c1						exx 
25c1						ld hl, $2f9f 
25c1						pop de   ; $2f9f 
25c1						call cmp16 
25c1						jr nz, .spnosame 
25c1						ld hl, $1efe 
25c1						pop de   ; $1efe 
25c1						call cmp16 
25c1						jr z, .spfrsame 
25c1						.spnosame: call showsperror 
25c1						.spfrsame: nop 
25c1						exx 
25c1					endif 
25c1				endif 
25c1			endm 
# End of macro STACKFRAMECHK
25c1			 
25c1			execnext: 
25c1			 
25c1			if DEBUG_FORTH_PARSE_KEY 
25c1						DMARK "KY>" 
25c1			endif 
25c1			; move past token to next word 
25c1			 
25c1 2a bf f4		ld hl, (os_tok_ptr) 
25c4 3e 00		ld a, 0 
25c6 01 ff 00		ld bc, 255     ; input buffer size 
25c9 ed b1		cpir 
25cb			 
25cb			if DEBUG_FORTH_PARSE_KEY 
25cb						DMARK "KY!" 
25cb				CALLMONITOR 
25cb			endif	 
25cb			; TODO this might place hl on the null, so will need to forward on??? 
25cb			;inc hl   ; see if this gets onto the next item 
25cb			 
25cb			 
25cb			; TODO pass a pointer to the buffer to push 
25cb			; TODO call function to push 
25cb			 
25cb			; look for end of input 
25cb			 
25cb			;inc hl 
25cb			;ld a,(hl) 
25cb			;cp FORTH_END_BUFFER 
25cb			;ret z 
25cb			 
25cb			 
25cb c3 44 25		jp exec1 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			 
25ce			findnexttok: 
25ce			 
25ce				; hl is pointer to move 
25ce				; de is the token to locate 
25ce			 
25ce					if DEBUG_FORTH 
25ce						DMARK "NTK" 
25ce						CALLMONITOR 
25ce					endif 
25ce d5				push de 
25cf			 
25cf			.fnt1:	 
25cf				; find first char of token to locate 
25cf			 
25cf 1a				ld a, (de) 
25d0 4f				ld c,a 
25d1 7e				ld a,(hl) 
25d2 cd 25 14			call toUpper 
25d5					if DEBUG_FORTH 
25d5						DMARK "NT1" 
25d5						CALLMONITOR 
25d5					endif 
25d5 b9				cp c 
25d6			 
25d6 28 03			jr z, .fnt2cmpmorefirst	 
25d8			 
25d8				; first char not found move to next char 
25d8			 
25d8 23				inc hl 
25d9 18 f4			jr .fnt1 
25db			 
25db			.fnt2cmpmorefirst:	 
25db				; first char of token found.  
25db			 
25db e5				push hl     ; save start of token just in case it is the right one 
25dc d9				exx 
25dd e1				pop hl        ; save it to hl' 
25de d9				exx 
25df			 
25df			 
25df			.fnt2cmpmore:	 
25df				; compare the rest 
25df				 
25df 23				inc hl 
25e0 13				inc de 
25e1				 
25e1 1a				ld a, (de) 
25e2 4f				ld c,a 
25e3 7e				ld a,(hl) 
25e4 cd 25 14			call toUpper 
25e7			 
25e7					if DEBUG_FORTH 
25e7						DMARK "NT2" 
25e7						CALLMONITOR 
25e7					endif 
25e7				; c has the token to find char 
25e7				; a has the mem to scan char 
25e7			 
25e7 b9				cp c 
25e8 28 04			jr z,.fntmatch1 
25ea			 
25ea				; they are not the same 
25ea			 
25ea					if DEBUG_FORTH 
25ea						DMARK "NT3" 
25ea						CALLMONITOR 
25ea					endif 
25ea d1				pop de	; reset de token to look for 
25eb d5				push de 
25ec 18 e1			jr .fnt1 
25ee				 
25ee			.fntmatch1: 
25ee			 
25ee				; is the same char a null which means we might have a full hit? 
25ee					if DEBUG_FORTH 
25ee						DMARK "NT4" 
25ee						CALLMONITOR 
25ee					endif 
25ee			 
25ee fe 00			cp 0 
25f0 28 0b			jr z, .fntmatchyes 
25f2			 
25f2				; are we at the end of the token to find? 
25f2			 
25f2					if DEBUG_FORTH 
25f2						DMARK "NT5" 
25f2						CALLMONITOR 
25f2					endif 
25f2 3e 00			ld a, 0 
25f4 b9				cp c 
25f5			 
25f5 c2 df 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25f8			 
25f8					if DEBUG_FORTH 
25f8						DMARK "NT6" 
25f8						CALLMONITOR 
25f8					endif 
25f8				; token to find is exhusted but no match to stream 
25f8			 
25f8				; restore tok pointer and continue on 
25f8 d1				pop de 
25f9 d5				push de 
25fa c3 cf 25			jp .fnt1 
25fd			 
25fd			 
25fd			.fntmatchyes: 
25fd			 
25fd				; hl now contains the end of the found token 
25fd			 
25fd				; get rid of saved token pointer to find 
25fd			 
25fd d1				pop de 
25fe			 
25fe					if DEBUG_FORTH 
25fe						DMARK "NT9" 
25fe						CALLMONITOR 
25fe					endif 
25fe			 
25fe				; hl will be on the null term so forward on 
25fe			 
25fe				; get back the saved start of the token 
25fe			 
25fe d9				exx 
25ff e5				push hl     ; save start of token just in case it is the right one 
2600 d9				exx 
2601 e1				pop hl        ; save it to hl 
2602			 
2602 c9				ret 
2603			 
2603			 
2603			; LIST needs to find a specific token   
2603			; FORGET needs to find a spefici token 
2603			 
2603			; SAVE needs to find all tokens by flag 
2603			; WORDS just needs to scan through all  by flag 
2603			; UWORDS needs to scan through all by flag 
2603			 
2603			 
2603			; given hl as pointer to start of dict look up string 
2603			; return hl as pointer to start of word block 
2603			; or 0 if not found 
2603			 
2603			forth_find_tok: 
2603 c9				ret 
2604			 
2604			; given hl as pointer to dict structure 
2604			; move to the next dict block structure 
2604			 
2604			forth_tok_next: 
2604				; hl now points to the address of the next word pointer  
2604				; TODO skip compiled symbol for now 
2604			;	push de 
2604 23				inc hl 
2605 5e				ld e, (hl) 
2606 23				inc hl 
2607 56				ld d, (hl) 
2608 23				inc hl 
2609			 
2609 eb				ex de,hl 
260a			if DEBUG_FORTH_PARSE_NEXTWORD 
260a				push bc 
260a				ld bc, (cli_nextword) 
260a						DMARK "NXW" 
260a				CALLMONITOR 
260a				pop bc 
260a			endif 
260a			;	pop de	 
260a c9				ret 
260b			 
260b			 
260b			 
260b			; eof 
# End of file forth_parserv5.asm
260b				include "forth_wordsv4.asm" 
260b			 
260b			; the core word dictionary v4 
260b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
260b			 
260b			; this is a linked list for each of the system words used 
260b			; user defined words will follow the same format but will be in ram 
260b			 
260b			 
260b			; 
260b			; 
260b			; define linked list: 
260b			; 
260b			; 1. compiled byte op code 
260b			; 2. len of text word 
260b			; 3. text word 
260b			; 4. ptr to next dictionary word 
260b			; 5. asm, calls etc for the word 
260b			; 
260b			;  if 1 == 0 then last word in dict  
260b			;   
260b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
260b			;  
260b			;  
260b			; create basic standard set of words 
260b			; 
260b			;  
260b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
260b			; 2DUP 2DROP 2SWAP  
260b			; @ C@ - get byte  
260b			; ! C! - store byte 
260b			; 0< true if less than zero 
260b			; 0= true if zero 
260b			; < >  
260b			; = true if same 
260b			; variables 
260b			 
260b			 
260b			; Hardware specific words I may need 
260b			; 
260b			; IN OUT  
260b			; calls to key util functions 
260b			; calls to hardward abstraction stuff 
260b			; easy control of frame buffers and lcd i/o 
260b			; keyboard  
260b			 
260b			 
260b			;DICT: macro 
260b			; op_code, len, word, next 
260b			;    word: 
260b			;    db op_code 
260b			;    ds word zero term 
260b			;    dw next 
260b			;    endm 
260b			 
260b			 
260b			 
260b			 
260b			; op code 1 is a flag for user define words which are to be handled differently 
260b			 
260b			 
260b			; 
260b			; 
260b			;    TODO on entry to a word this should be the expected environment 
260b			;    hl - tos value if number then held, if string this is the ptr 
260b			;    de -  
260b			 
260b			 
260b			; opcode ranges 
260b			; 0 - end of word dict 
260b			; 255 - user define words 
260b			 
260b			sysdict: 
260b			include "forth_opcodes.asm" 
260b			; op codes for forth keywords 
260b			; free to use code 0  
260b				OPCODE_HEAP: equ  1 
260b				OPCODE_EXEC: equ 2 
260b				OPCODE_DUP: equ 3 
260b				OPCODE_SWAP: equ 4 
260b				OPCODE_COLN: equ 5 
260b				OPCODE_SCOLN: equ 6 
260b				OPCODE_DROP: equ 7 
260b				OPCODE_DUP2: equ 8 
260b				OPCODE_DROP2: equ 9 
260b				OPCODE_SWAP2: equ 10 
260b				OPCODE_AT: equ 11 
260b				OPCODE_CAT: equ 12 
260b				OPCODE_BANG: equ 13 
260b				OPCODE_CBANG: equ 14 
260b				OPCODE_SCALL: equ 15 
260b				OPCODE_DEPTH: equ 16 
260b				OPCODE_OVER: equ 17 
260b				OPCODE_PAUSE: equ 18 
260b				OPCODE_PAUSES: equ 19 
260b				OPCODE_ROT: equ 20 
260b			;free to reuse	OPCODE_WORDS: equ 21 
260b			        OPCODE_NOT: equ 21 
260b				OPCODE_UWORDS: equ 22 
260b				OPCODE_BP: equ 23 
260b				OPCODE_MONITOR: equ 24  
260b				OPCODE_MALLOC: equ 25 
260b				OPCODE_FREE: equ 26 
260b				OPCODE_LIST: equ 27 
260b				OPCODE_FORGET: equ 28 
260b				OPCODE_NOP: equ 29 
260b				OPCODE_COMO: equ 30 
260b				OPCODE_COMC: equ 31 
260b			;free to reuse	OPCODE_ENDCORE: equ 32 
260b				OPCODE_AFTERSOUND: equ 33 
260b				OPCODE_GP2: equ 34 
260b				OPCODE_GP3: equ 35 
260b				OPCODE_GP4: equ 36 
260b				OPCODE_SIN: equ 37 
260b				OPCODE_SOUT: equ 38 
260b				OPCODE_SPIO: equ 39 
260b				OPCODE_SPICEH: equ 40 
260b				OPCODE_SPIOb: equ 41 
260b				OPCODE_SPII: equ 42 
260b				OPCODE_SESEL: equ 43 
260b				OPCODE_CARTDEV: equ 44 
260b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
260b				OPCODE_FB: equ 46 
260b				OPCODE_EMIT: equ 47 
260b				OPCODE_DOTH: equ 48 
260b				OPCODE_DOTF: equ 49 
260b				OPCODE_DOT: equ 50 
260b				OPCODE_CLS: equ 51 
260b				OPCODE_DRAW: equ 52 
260b				OPCODE_DUMP: equ 53 
260b				OPCODE_CDUMP: equ 54 
260b				OPCODE_DAT: equ 55 
260b				OPCODE_HOME: equ 56 
260b				OPCODE_SPACE: equ 57 
260b				OPCODE_SPACES: equ 58 
260b				OPCODE_SCROLL: equ 59 
260b				OPCODE_ATQ: equ 60 
260b				OPCODE_AUTODSP: equ 61 
260b				OPCODE_MENU: equ 62 
260b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
260b				OPCODE_THEN: equ 64 
260b				OPCODE_ELSE: equ 65 
260b				OPCODE_DO: equ 66 
260b				OPCODE_LOOP: equ 67 
260b				OPCODE_I: equ 68 
260b				OPCODE_DLOOP: equ 69  
260b				OPCODE_REPEAT: equ 70  
260b				OPCODE_UNTIL: equ 71 
260b				OPCODE_ENDFLOW: equ 72 
260b				OPCODE_WAITK: equ 73 
260b				OPCODE_ACCEPT: equ 74 
260b				OPCODE_EDIT: equ 75 
260b			;free to reuse	OPCODE_ENDKEY: equ 76 
260b				OPCODE_LZERO: equ 77 
260b				OPCODE_TZERO: equ 78 
260b				OPCODE_LESS: equ 79 
260b				OPCODE_GT: equ 80 
260b				OPCODE_EQUAL: equ 81  
260b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
260b				OPCODE_NEG: equ 83 
260b				OPCODE_DIV: equ 84 
260b				OPCODE_MUL: equ 85 
260b				OPCODE_MIN: equ 86 
260b				OPCODE_MAX: equ 87 
260b				OPCODE_RND16: equ 88 
260b				OPCODE_RND8: equ 89 
260b				OPCODE_RND: equ 90 
260b			;free to reuse	OPCODE_ENDMATHS: equ 91  
260b				OPCODE_BYNAME: equ 92 
260b				OPCODE_DIR: equ 93 
260b				OPCODE_SAVE: equ 94 
260b				OPCODE_LOAD: equ 95 
260b				OPCODE_BSAVE: equ 96 
260b				OPCODE_BLOAD: equ 97 
260b				OPCODE_SEO: equ 98  
260b				OPCODE_SEI: equ 99 
260b				OPCODE_SFREE: equ 100 
260b				OPCODE_SIZE: equ 101 
260b				OPCODE_CREATE: equ 102 
260b				OPCODE_APPEND: equ 103 
260b				OPCODE_SDEL: equ 104 
260b				OPCODE_OPEN: equ 105 
260b				OPCODE_READ: equ 106 
260b				OPCODE_EOF: equ 106 
260b				OPCODE_FORMAT: equ 107 
260b				OPCODE_LABEL: equ 108 
260b				OPCODE_LABELS: equ 109 
260b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
260b				OPCODE_UPPER: equ 111 
260b				OPCODE_LOWER: equ 112 
260b				OPCODE_SUBSTR: equ 113 
260b				OPCODE_LEFT: equ 114 
260b				OPCODE_RIGHT: equ 115 
260b				OPCODE_STR2NUM: equ 116 
260b				OPCODE_NUM2STR: equ 117 
260b				OPCODE_CONCAT: equ 118 
260b				OPCODE_FIND: equ 119 
260b				OPCODE_LEN: equ 120 
260b				OPCODE_CHAR: equ 121 
260b			; free to reuse	OPCODE_STRLEN: equ 122 
260b			; free to reuse	OPCODE_ENDSTR: equ 123 
260b				OPCODE_V0S: equ 124 
260b				OPCODE_V0Q: equ 125 
260b				OPCODE_V1S: equ 126 
260b				OPCODE_V1Q: equ 127 
260b				OPCODE_V2S: equ 128 
260b				OPCODE_V2Q: equ 129 
260b				OPCODE_V3S: equ 130 
260b				OPCODE_V3Q: equ 131 
260b			;free to reuse	OPCODE_END: equ 132 
260b				OPCODE_ZDUP: equ 133 
260b			 
260b			; eof 
# End of file forth_opcodes.asm
260b			 
260b			include "forth_words_core.asm" 
260b			 
260b			; | ## Core Words 
260b			 
260b			;if MALLOC_4 
260b			 
260b			.HEAP: 
260b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
260b 15				db WORD_SYS_CORE+OPCODE_HEAP             
260c 4a 26			dw .EXEC            
260e 05				db 4 + 1 
260f .. 00			db "HEAP",0              
2614				endm 
# End of macro CWHEAD
2614			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2614			; | | u1 - Current number of bytes in the heap 
2614			; | | u2 - Remaining bytes left on the heap 
2614			; | |  
2614			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2614			 
2614			 
2614					if DEBUG_FORTH_WORDS_KEY 
2614						DMARK "HEP" 
2614 f5				push af  
2615 3a 29 26			ld a, (.dmark)  
2618 32 68 fe			ld (debug_mark),a  
261b 3a 2a 26			ld a, (.dmark+1)  
261e 32 69 fe			ld (debug_mark+1),a  
2621 3a 2b 26			ld a, (.dmark+2)  
2624 32 6a fe			ld (debug_mark+2),a  
2627 18 03			jr .pastdmark  
2629 ..			.dmark: db "HEP"  
262c f1			.pastdmark: pop af  
262d			endm  
# End of macro DMARK
262d						CALLMONITOR 
262d cd 6c fe			call debug_vector  
2630				endm  
# End of macro CALLMONITOR
2630					endif 
2630 2a 0a 80				ld hl, (free_list )      
2633 11 0e 80				ld de, heap_start 
2636			 
2636 ed 52				sbc hl, de  
2638			 
2638 cd 06 21				call forth_push_numhl 
263b			 
263b			 
263b ed 5b 0a 80			ld de, (free_list )      
263f 21 99 f1				ld hl, heap_end 
2642			 
2642 ed 52				sbc hl, de 
2644			 
2644 cd 06 21				call forth_push_numhl 
2647					 
2647			 
2647					 
2647			 
2647			 
2647			 
2647					NEXTW 
2647 c3 b3 24			jp macro_next 
264a				endm 
# End of macro NEXTW
264a			;endif 
264a			 
264a			.EXEC: 
264a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
264a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
264a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
264a			;; > > 
264a			;; > >   
264a			;	STACKFRAME OFF $5efe $5f9f 
264a			; 
264a			;		if DEBUG_FORTH_WORDS_KEY 
264a			;			DMARK "EXE" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			;	FORTH_DSP_VALUEHL 
264a			; 
264a			;	FORTH_DSP_POP 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX1" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;;	ld e,(hl) 
264a			;;	inc hl 
264a			;;	ld d,(hl) 
264a			;;	ex de,hl 
264a			; 
264a			;;		if DEBUG_FORTH_WORDS 
264a			;;			DMARK "EX2" 
264a			;;			CALLMONITOR 
264a			;;		endif 
264a			;	push hl 
264a			; 
264a			;	;ld a, 0 
264a			;	;ld a, FORTH_END_BUFFER 
264a			;	call strlenz 
264a			;	inc hl   ; include zero term to copy 
264a			;	inc hl   ; include term 
264a			;	inc hl   ; include term 
264a			;	ld b,0 
264a			;	ld c,l 
264a			;	pop hl 
264a			;	ld de, execscratch 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX3" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	ldir 
264a			; 
264a			; 
264a			;	ld hl, execscratch 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EXe" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			;	call forthparse 
264a			;	call forthexec 
264a			;;	call forthexec_cleanup 
264a			;;	call forthparse 
264a			;;	call forthexec 
264a			; 
264a			;	STACKFRAMECHK OFF $5efe $5f9f 
264a			; 
264a			;	; an immediate word so no need to process any more words 
264a			;	ret 
264a			;	NEXTW 
264a			 
264a			; dead code - old version  
264a			;	FORTH_RSP_NEXT 
264a			 
264a			;  
264a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
264a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
264a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
264a			;	push hl 
264a			;	push de 
264a			;	push bc 
264a			; 
264a			; 
264a			;		if DEBUG_FORTH_WORDS_KEY 
264a			;			DMARK "EXR" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			; 
264a			; 
264a			;	;v5 FORTH_DSP_VALUE 
264a			;	FORTH_DSP_VALUEHL 
264a			; 
264a			;	; TODO do string type checks 
264a			; 
264a			;;v5	inc hl   ; skip type 
264a			; 
264a			;	push hl  ; source code  
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX1" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	ld a, 0 
264a			;	call strlent 
264a			; 
264a			;	inc hl 
264a			;	inc hl 
264a			;	inc hl 
264a			;	inc hl 
264a			; 
264a			;	push hl    ; size 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX2" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	call malloc 
264a			; 
264a			;	ex de, hl    ; de now contains malloc area 
264a			;	pop bc   	; get byte count 
264a			;	pop hl      ; get string to copy 
264a			; 
264a			;	push de     ; save malloc for free later 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX3" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	ldir       ; duplicate string 
264a			; 
264a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
264a			;	 
264a			;	; TODO fix the parse would be better than this...  
264a			;	ex de, hl 
264a			;	dec hl 
264a			;	ld a, 0 
264a			;	ld (hl), a 
264a			;	dec hl 
264a			;	ld a, ' ' 
264a			;	ld (hl), a 
264a			;	dec hl 
264a			;	ld (hl), a 
264a			; 
264a			;	dec hl 
264a			;	ld (hl), a 
264a			; 
264a			; 
264a			;	FORTH_DSP_POP  
264a			; 
264a			;	pop hl     
264a			;	push hl    ; save malloc area 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX4" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			;	call forthparse 
264a			;	call forthexec 
264a			;	 
264a			;	pop hl 
264a			;	if DEBUG_FORTH_WORDS 
264a			;		DMARK "EX5" 
264a			;		CALLMONITOR 
264a			;	endif 
264a			; 
264a			;	if FORTH_ENABLE_FREE 
264a			;	call free 
264a			;	endif 
264a			; 
264a			;	if DEBUG_FORTH_WORDS 
264a			;		DMARK "EX6" 
264a			;		CALLMONITOR 
264a			;	endif 
264a			; 
264a			;	pop bc 
264a			;	pop de 
264a			;	pop hl 
264a			;;	FORTH_RSP_POP	  
264a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
264a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
264a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
264a			; 
264a			;	if DEBUG_FORTH_WORDS 
264a			;		DMARK "EX7" 
264a			;		CALLMONITOR 
264a			;	endif 
264a			;	NEXTW 
264a			 
264a			;.STKEXEC: 
264a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
264a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
264a			; 
264a			; 
264a			;		if DEBUG_FORTH_WORDS_KEY 
264a			;			DMARK "STX" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			;	FORTH_DSP_VALUEHL 
264a			; 
264a			;	ld (store_tmp1), hl    ; count 
264a			; 
264a			;	FORTH_DSP_POP 
264a			;.stkexec1: 
264a			;	ld hl, (store_tmp1)   ; count 
264a			;	ld a, 0 
264a			;	cp l 
264a			;	ret z 
264a			; 
264a			;	dec hl 
264a			;	ld (store_tmp1), hl    ; count 
264a			;	 
264a			;	FORTH_DSP_VALUEHL 
264a			;	push hl 
264a			;	 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EXp" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	FORTH_DSP_POP 
264a			; 
264a			;	call strlenz 
264a			;	inc hl   ; include zero term to copy 
264a			;	inc hl   ; include zero term to copy 
264a			;	inc hl   ; include zero term to copy 
264a			;	ld b,0 
264a			;	ld c,l 
264a			;	pop hl 
264a			;	ld de, execscratch 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EX3" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	ldir 
264a			; 
264a			; 
264a			;	ld hl, execscratch 
264a			; 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EXP" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			; 
264a			;	call forthparse 
264a			;	ld hl, execscratch 
264a			;		if DEBUG_FORTH_WORDS 
264a			;			DMARK "EXx" 
264a			;			CALLMONITOR 
264a			;		endif 
264a			;	call forthexec 
264a			; 
264a			;	jp .stkexec1 
264a			; 
264a			;	ret 
264a			 
264a			 
264a			.DUP: 
264a				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
264a 17				db WORD_SYS_CORE+OPCODE_DUP             
264b c0 26			dw .ZDUP            
264d 04				db 3 + 1 
264e .. 00			db "DUP",0              
2652				endm 
# End of macro CWHEAD
2652			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2652			 
2652					if DEBUG_FORTH_WORDS_KEY 
2652						DMARK "DUP" 
2652 f5				push af  
2653 3a 67 26			ld a, (.dmark)  
2656 32 68 fe			ld (debug_mark),a  
2659 3a 68 26			ld a, (.dmark+1)  
265c 32 69 fe			ld (debug_mark+1),a  
265f 3a 69 26			ld a, (.dmark+2)  
2662 32 6a fe			ld (debug_mark+2),a  
2665 18 03			jr .pastdmark  
2667 ..			.dmark: db "DUP"  
266a f1			.pastdmark: pop af  
266b			endm  
# End of macro DMARK
266b						CALLMONITOR 
266b cd 6c fe			call debug_vector  
266e				endm  
# End of macro CALLMONITOR
266e					endif 
266e			 
266e					FORTH_DSP 
266e cd c3 22			call macro_forth_dsp 
2671				endm 
# End of macro FORTH_DSP
2671			 
2671 7e					ld a, (HL) 
2672 fe 01				cp DS_TYPE_STR 
2674 20 25				jr nz, .dupinum 
2676			 
2676					; push another string 
2676			 
2676					FORTH_DSP_VALUEHL     		 
2676 cd fd 22			call macro_dsp_valuehl 
2679				endm 
# End of macro FORTH_DSP_VALUEHL
2679			 
2679				if DEBUG_FORTH_WORDS 
2679					DMARK "DUs" 
2679 f5				push af  
267a 3a 8e 26			ld a, (.dmark)  
267d 32 68 fe			ld (debug_mark),a  
2680 3a 8f 26			ld a, (.dmark+1)  
2683 32 69 fe			ld (debug_mark+1),a  
2686 3a 90 26			ld a, (.dmark+2)  
2689 32 6a fe			ld (debug_mark+2),a  
268c 18 03			jr .pastdmark  
268e ..			.dmark: db "DUs"  
2691 f1			.pastdmark: pop af  
2692			endm  
# End of macro DMARK
2692					CALLMONITOR 
2692 cd 6c fe			call debug_vector  
2695				endm  
# End of macro CALLMONITOR
2695				endif 
2695 cd 74 21				call forth_push_str 
2698			 
2698					NEXTW 
2698 c3 b3 24			jp macro_next 
269b				endm 
# End of macro NEXTW
269b			 
269b			 
269b			.dupinum: 
269b					 
269b			 
269b			 
269b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
269b cd fd 22			call macro_dsp_valuehl 
269e				endm 
# End of macro FORTH_DSP_VALUEHL
269e			 
269e				; TODO add floating point number detection 
269e			 
269e				if DEBUG_FORTH_WORDS 
269e					DMARK "DUi" 
269e f5				push af  
269f 3a b3 26			ld a, (.dmark)  
26a2 32 68 fe			ld (debug_mark),a  
26a5 3a b4 26			ld a, (.dmark+1)  
26a8 32 69 fe			ld (debug_mark+1),a  
26ab 3a b5 26			ld a, (.dmark+2)  
26ae 32 6a fe			ld (debug_mark+2),a  
26b1 18 03			jr .pastdmark  
26b3 ..			.dmark: db "DUi"  
26b6 f1			.pastdmark: pop af  
26b7			endm  
# End of macro DMARK
26b7					CALLMONITOR 
26b7 cd 6c fe			call debug_vector  
26ba				endm  
# End of macro CALLMONITOR
26ba				endif 
26ba			 
26ba cd 06 21				call forth_push_numhl 
26bd					NEXTW 
26bd c3 b3 24			jp macro_next 
26c0				endm 
# End of macro NEXTW
26c0			.ZDUP: 
26c0				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26c0 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26c1 f8 26			dw .SWAP            
26c3 05				db 4 + 1 
26c4 .. 00			db "?DUP",0              
26c9				endm 
# End of macro CWHEAD
26c9			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26c9			 
26c9					if DEBUG_FORTH_WORDS_KEY 
26c9						DMARK "qDU" 
26c9 f5				push af  
26ca 3a de 26			ld a, (.dmark)  
26cd 32 68 fe			ld (debug_mark),a  
26d0 3a df 26			ld a, (.dmark+1)  
26d3 32 69 fe			ld (debug_mark+1),a  
26d6 3a e0 26			ld a, (.dmark+2)  
26d9 32 6a fe			ld (debug_mark+2),a  
26dc 18 03			jr .pastdmark  
26de ..			.dmark: db "qDU"  
26e1 f1			.pastdmark: pop af  
26e2			endm  
# End of macro DMARK
26e2						CALLMONITOR 
26e2 cd 6c fe			call debug_vector  
26e5				endm  
# End of macro CALLMONITOR
26e5					endif 
26e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e5 cd fd 22			call macro_dsp_valuehl 
26e8				endm 
# End of macro FORTH_DSP_VALUEHL
26e8			 
26e8 e5					push hl 
26e9			 
26e9					; is it a zero? 
26e9			 
26e9 3e 00				ld a, 0 
26eb 84					add h 
26ec 85					add l 
26ed			 
26ed e1					pop hl 
26ee			 
26ee fe 00				cp 0 
26f0 28 03				jr z, .dup2orig 
26f2			 
26f2			 
26f2 cd 06 21				call forth_push_numhl 
26f5			 
26f5			 
26f5				; TODO add floating point number detection 
26f5			 
26f5			.dup2orig: 
26f5			 
26f5					NEXTW 
26f5 c3 b3 24			jp macro_next 
26f8				endm 
# End of macro NEXTW
26f8			.SWAP: 
26f8				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26f8 18				db WORD_SYS_CORE+OPCODE_SWAP             
26f9 37 27			dw .COLN            
26fb 05				db 4 + 1 
26fc .. 00			db "SWAP",0              
2701				endm 
# End of macro CWHEAD
2701			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2701					if DEBUG_FORTH_WORDS_KEY 
2701						DMARK "SWP" 
2701 f5				push af  
2702 3a 16 27			ld a, (.dmark)  
2705 32 68 fe			ld (debug_mark),a  
2708 3a 17 27			ld a, (.dmark+1)  
270b 32 69 fe			ld (debug_mark+1),a  
270e 3a 18 27			ld a, (.dmark+2)  
2711 32 6a fe			ld (debug_mark+2),a  
2714 18 03			jr .pastdmark  
2716 ..			.dmark: db "SWP"  
2719 f1			.pastdmark: pop af  
271a			endm  
# End of macro DMARK
271a						CALLMONITOR 
271a cd 6c fe			call debug_vector  
271d				endm  
# End of macro CALLMONITOR
271d					endif 
271d			 
271d					FORTH_DSP_VALUEHL 
271d cd fd 22			call macro_dsp_valuehl 
2720				endm 
# End of macro FORTH_DSP_VALUEHL
2720 e5					push hl     ; w2 
2721			 
2721					FORTH_DSP_POP 
2721 cd b5 23			call macro_forth_dsp_pop 
2724				endm 
# End of macro FORTH_DSP_POP
2724			 
2724					FORTH_DSP_VALUEHL 
2724 cd fd 22			call macro_dsp_valuehl 
2727				endm 
# End of macro FORTH_DSP_VALUEHL
2727			 
2727					FORTH_DSP_POP 
2727 cd b5 23			call macro_forth_dsp_pop 
272a				endm 
# End of macro FORTH_DSP_POP
272a			 
272a d1					pop de     ; w2	, hl = w1 
272b			 
272b eb					ex de, hl 
272c d5					push de 
272d			 
272d cd 06 21				call forth_push_numhl 
2730			 
2730 e1					pop hl 
2731			 
2731 cd 06 21				call forth_push_numhl 
2734					 
2734			 
2734					NEXTW 
2734 c3 b3 24			jp macro_next 
2737				endm 
# End of macro NEXTW
2737			.COLN: 
2737				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2737 19				db WORD_SYS_CORE+OPCODE_COLN             
2738 c3 28			dw .SCOLN            
273a 02				db 1 + 1 
273b .. 00			db ":",0              
273d				endm 
# End of macro CWHEAD
273d			; | : ( -- )         Create new word | DONE 
273d			 
273d					if DEBUG_FORTH_WORDS_KEY 
273d						DMARK "CLN" 
273d f5				push af  
273e 3a 52 27			ld a, (.dmark)  
2741 32 68 fe			ld (debug_mark),a  
2744 3a 53 27			ld a, (.dmark+1)  
2747 32 69 fe			ld (debug_mark+1),a  
274a 3a 54 27			ld a, (.dmark+2)  
274d 32 6a fe			ld (debug_mark+2),a  
2750 18 03			jr .pastdmark  
2752 ..			.dmark: db "CLN"  
2755 f1			.pastdmark: pop af  
2756			endm  
# End of macro DMARK
2756						CALLMONITOR 
2756 cd 6c fe			call debug_vector  
2759				endm  
# End of macro CALLMONITOR
2759					endif 
2759				STACKFRAME OFF $8efe $989f 
2759				if DEBUG_STACK_IMB 
2759					if OFF 
2759						exx 
2759						ld de, $8efe 
2759						ld a, d 
2759						ld hl, curframe 
2759						call hexout 
2759						ld a, e 
2759						ld hl, curframe+2 
2759						call hexout 
2759						ld hl, $8efe 
2759						push hl 
2759						ld hl, $989f 
2759						push hl 
2759						exx 
2759					endif 
2759				endif 
2759			endm 
# End of macro STACKFRAME
2759				; get parser buffer length  of new word 
2759			 
2759				 
2759			 
2759					; move tok past this to start of name defintition 
2759					; TODO get word to define 
2759					; TODO Move past word token 
2759					; TODO get length of string up to the ';' 
2759			 
2759 2a bf f4			ld hl, (os_tok_ptr) 
275c 23				inc hl 
275d 23				inc hl 
275e			 
275e 3e 3b			ld a, ';' 
2760 cd 39 14			call strlent 
2763			 
2763 7d				ld a,l 
2764 32 ae f1			ld (os_new_parse_len), a 
2767			 
2767			 
2767			if DEBUG_FORTH_UWORD 
2767 ed 5b bf f4		ld de, (os_tok_ptr) 
276b						DMARK ":01" 
276b f5				push af  
276c 3a 80 27			ld a, (.dmark)  
276f 32 68 fe			ld (debug_mark),a  
2772 3a 81 27			ld a, (.dmark+1)  
2775 32 69 fe			ld (debug_mark+1),a  
2778 3a 82 27			ld a, (.dmark+2)  
277b 32 6a fe			ld (debug_mark+2),a  
277e 18 03			jr .pastdmark  
2780 ..			.dmark: db ":01"  
2783 f1			.pastdmark: pop af  
2784			endm  
# End of macro DMARK
2784				CALLMONITOR 
2784 cd 6c fe			call debug_vector  
2787				endm  
# End of macro CALLMONITOR
2787			endif 
2787			 
2787			; 
2787			;  new word memory layout: 
2787			;  
2787			;    : adg 6666 ;  
2787			; 
2787			;    db   1     ; user defined word  
2787 23				inc hl    
2788			;    dw   sysdict 
2788 23				inc hl 
2789 23				inc hl 
278a			;    db <word len>+1 (for null) 
278a 23				inc hl 
278b			;    db .... <word> 
278b			; 
278b			 
278b 23				inc hl    ; some extras for the word preamble before the above 
278c 23				inc hl 
278d 23				inc hl 
278e 23				inc hl 
278f 23				inc hl 
2790 23				inc hl 
2791 23				inc hl  
2792 23				inc hl 
2793 23				inc hl 
2794 23				inc hl 
2795 23				inc hl 
2796 23				inc hl 
2797 23				inc hl 
2798 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2799			;       exec word buffer 
2799			;	<ptr word>   
2799 23				inc hl 
279a 23				inc hl 
279b			;       <word list><null term> 7F final term 
279b			 
279b			 
279b			if DEBUG_FORTH_UWORD 
279b						DMARK ":02" 
279b f5				push af  
279c 3a b0 27			ld a, (.dmark)  
279f 32 68 fe			ld (debug_mark),a  
27a2 3a b1 27			ld a, (.dmark+1)  
27a5 32 69 fe			ld (debug_mark+1),a  
27a8 3a b2 27			ld a, (.dmark+2)  
27ab 32 6a fe			ld (debug_mark+2),a  
27ae 18 03			jr .pastdmark  
27b0 ..			.dmark: db ":02"  
27b3 f1			.pastdmark: pop af  
27b4			endm  
# End of macro DMARK
27b4				CALLMONITOR 
27b4 cd 6c fe			call debug_vector  
27b7				endm  
# End of macro CALLMONITOR
27b7			endif 
27b7			 
27b7				 
27b7					; malloc the size 
27b7			 
27b7 cd 97 14				call malloc 
27ba 22 b0 f1				ld (os_new_malloc), hl     ; save malloc start 
27bd			 
27bd			;    db   1     ; user defined word  
27bd 3e 01				ld a, WORD_SYS_UWORD  
27bf 77					ld (hl), a 
27c0				 
27c0 23				inc hl    
27c1			;    dw   sysdict 
27c1 11 0b 26			ld de, sysdict       ; continue on with the scan to the system dict 
27c4 73				ld (hl), e 
27c5 23				inc hl 
27c6 72				ld (hl), d 
27c7 23				inc hl 
27c8			 
27c8			 
27c8			;    Setup dict word 
27c8			 
27c8 23				inc hl 
27c9 22 aa f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27cc			 
27cc				; 1. get length of dict word 
27cc			 
27cc			 
27cc 2a bf f4			ld hl, (os_tok_ptr) 
27cf 23				inc hl 
27d0 23				inc hl    ; position to start of dict word 
27d1 3e 00			ld a, 0 
27d3 cd 39 14			call strlent 
27d6			 
27d6			 
27d6 23				inc hl    ; to include null??? 
27d7			 
27d7				; write length of dict word 
27d7			 
27d7 ed 5b aa f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27db 1b				dec de 
27dc eb				ex de, hl 
27dd 73				ld (hl), e 
27de eb				ex de, hl 
27df			 
27df				 
27df			 
27df				; copy  
27df 4d				ld c, l 
27e0 06 00			ld b, 0 
27e2 ed 5b aa f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27e6 2a bf f4			ld hl, (os_tok_ptr) 
27e9 23				inc hl 
27ea 23				inc hl    ; position to start of dict word 
27eb				 
27eb			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27eb				 
27eb				; TODO need to convert word to upper case 
27eb			 
27eb			ucasetok:	 
27eb 7e				ld a,(hl) 
27ec cd 25 14			call toUpper 
27ef 77				ld (hl),a 
27f0 ed a0			ldi 
27f2 f2 eb 27		 	jp p, ucasetok 
27f5			 
27f5			 
27f5			 
27f5				; de now points to start of where the word body code should be placed 
27f5 ed 53 aa f1		ld (os_new_work_ptr), de 
27f9				; hl now points to the words to throw at forthexec which needs to be copied 
27f9 22 a8 f1			ld (os_new_src_ptr), hl 
27fc			 
27fc				; TODO add 'call to forthexec' 
27fc			 
27fc			if DEBUG_FORTH_UWORD 
27fc c5				push bc 
27fd ed 4b b0 f1		ld bc, (os_new_malloc) 
2801						DMARK ":0x" 
2801 f5				push af  
2802 3a 16 28			ld a, (.dmark)  
2805 32 68 fe			ld (debug_mark),a  
2808 3a 17 28			ld a, (.dmark+1)  
280b 32 69 fe			ld (debug_mark+1),a  
280e 3a 18 28			ld a, (.dmark+2)  
2811 32 6a fe			ld (debug_mark+2),a  
2814 18 03			jr .pastdmark  
2816 ..			.dmark: db ":0x"  
2819 f1			.pastdmark: pop af  
281a			endm  
# End of macro DMARK
281a				CALLMONITOR 
281a cd 6c fe			call debug_vector  
281d				endm  
# End of macro CALLMONITOR
281d c1				pop bc 
281e			endif 
281e			 
281e			 
281e				; create word preamble which should be: 
281e			 
281e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
281e			 
281e				;    ld hl, <word code> 
281e				;    jp user_exec 
281e			        ;    <word code bytes> 
281e			 
281e			 
281e			;	inc de     ; TODO ??? or are we already past the word's null 
281e eb				ex de, hl 
281f			 
281f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2821			 
2821 23				inc hl 
2822 22 a4 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2825 23				inc hl 
2826			 
2826 23				inc hl 
2827 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2829			 
2829 01 33 5d			ld bc, user_exec 
282c 23				inc hl 
282d 71				ld (hl), c     ; poke address of user_exec 
282e 23				inc hl 
282f 70				ld (hl), b     
2830			 ; 
2830			;	inc hl 
2830			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2830			; 
2830			; 
2830			;	ld bc, macro_forth_rsp_next 
2830			;	inc hl 
2830			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2830			;	inc hl 
2830			;	ld (hl), b     
2830			 ; 
2830			;	inc hl 
2830			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2830			; 
2830			; 
2830			;	inc hl 
2830			;	ld bc, forthexec 
2830			;	ld (hl), c     ; poke address of forthexec 
2830			;	inc hl 
2830			;	ld (hl), b      
2830			; 
2830			;	inc hl 
2830			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2830			; 
2830			;	ld bc, user_dict_next 
2830			;	inc hl 
2830			;	ld (hl), c     ; poke address of forthexec 
2830			;	inc hl 
2830			;	ld (hl), b      
2830			 
2830				; hl is now where we need to copy the word byte data to save this 
2830			 
2830 23				inc hl 
2831 22 a6 f1			ld (os_new_exec), hl 
2834				 
2834				; copy definition 
2834			 
2834 eb				ex de, hl 
2835			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2835			;	inc de    ; skip the PC for this parse 
2835 3a ae f1			ld a, (os_new_parse_len) 
2838 4f				ld c, a 
2839 06 00			ld b, 0 
283b ed b0			ldir		 ; copy defintion 
283d			 
283d			 
283d				; poke the address of where the new word bytes live for forthexec 
283d			 
283d 2a a4 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2840			 
2840 ed 5b a6 f1		ld de, (os_new_exec)      
2844				 
2844 73				ld (hl), e 
2845 23				inc hl 
2846 72				ld (hl), d 
2847			 
2847					; TODO copy last user dict word next link to this word 
2847					; TODO update last user dict word to point to this word 
2847			; 
2847			; hl f923 de 812a ; bc 811a 
2847			 
2847			if DEBUG_FORTH_UWORD 
2847 c5				push bc 
2848 ed 4b b0 f1		ld bc, (os_new_malloc) 
284c						DMARK ":0A" 
284c f5				push af  
284d 3a 61 28			ld a, (.dmark)  
2850 32 68 fe			ld (debug_mark),a  
2853 3a 62 28			ld a, (.dmark+1)  
2856 32 69 fe			ld (debug_mark+1),a  
2859 3a 63 28			ld a, (.dmark+2)  
285c 32 6a fe			ld (debug_mark+2),a  
285f 18 03			jr .pastdmark  
2861 ..			.dmark: db ":0A"  
2864 f1			.pastdmark: pop af  
2865			endm  
# End of macro DMARK
2865				CALLMONITOR 
2865 cd 6c fe			call debug_vector  
2868				endm  
# End of macro CALLMONITOR
2868 c1				pop bc 
2869			endif 
2869			if DEBUG_FORTH_UWORD 
2869 c5				push bc 
286a ed 4b b0 f1		ld bc, (os_new_malloc) 
286e 03				inc bc 
286f 03				inc bc 
2870 03				inc bc 
2871 03				inc bc 
2872 03				inc bc 
2873 03				inc bc 
2874 03				inc bc 
2875 03				inc bc 
2876			 
2876						DMARK ":0B" 
2876 f5				push af  
2877 3a 8b 28			ld a, (.dmark)  
287a 32 68 fe			ld (debug_mark),a  
287d 3a 8c 28			ld a, (.dmark+1)  
2880 32 69 fe			ld (debug_mark+1),a  
2883 3a 8d 28			ld a, (.dmark+2)  
2886 32 6a fe			ld (debug_mark+2),a  
2889 18 03			jr .pastdmark  
288b ..			.dmark: db ":0B"  
288e f1			.pastdmark: pop af  
288f			endm  
# End of macro DMARK
288f				CALLMONITOR 
288f cd 6c fe			call debug_vector  
2892				endm  
# End of macro CALLMONITOR
2892 c1				pop bc 
2893			endif 
2893			 
2893			; update word dict linked list for new word 
2893			 
2893			 
2893 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2896 23			inc hl     ; move to next work linked list ptr 
2897			 
2897 ed 5b b0 f1	ld de, (os_new_malloc)		 ; new next word 
289b 73			ld (hl), e 
289c 23			inc hl 
289d 72			ld (hl), d 
289e			 
289e			if DEBUG_FORTH_UWORD 
289e ed 4b bb f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28a2			endif 
28a2			 
28a2 ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
28a6			 
28a6			 
28a6			if DEBUG_FORTH_UWORD 
28a6						DMARK ":0+" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 68 fe			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 69 fe			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 6a fe			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db ":0+"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf				CALLMONITOR 
28bf cd 6c fe			call debug_vector  
28c2				endm  
# End of macro CALLMONITOR
28c2			endif 
28c2			 
28c2				STACKFRAMECHK OFF $8efe $989f 
28c2				if DEBUG_STACK_IMB 
28c2					if OFF 
28c2						exx 
28c2						ld hl, $989f 
28c2						pop de   ; $989f 
28c2						call cmp16 
28c2						jr nz, .spnosame 
28c2						ld hl, $8efe 
28c2						pop de   ; $8efe 
28c2						call cmp16 
28c2						jr z, .spfrsame 
28c2						.spnosame: call showsperror 
28c2						.spfrsame: nop 
28c2						exx 
28c2					endif 
28c2				endif 
28c2			endm 
# End of macro STACKFRAMECHK
28c2			 
28c2 c9			ret    ; dont process any remaining parser tokens as they form new word 
28c3			 
28c3			 
28c3			 
28c3			 
28c3			;		NEXT 
28c3			.SCOLN: 
28c3			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28c3 06				db OPCODE_SCOLN 
28c4 0f 29			dw .DROP 
28c6 02				db 2 
28c7 .. 00			db ";",0           
28c9			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28c9					if DEBUG_FORTH_WORDS_KEY 
28c9						DMARK "SCN" 
28c9 f5				push af  
28ca 3a de 28			ld a, (.dmark)  
28cd 32 68 fe			ld (debug_mark),a  
28d0 3a df 28			ld a, (.dmark+1)  
28d3 32 69 fe			ld (debug_mark+1),a  
28d6 3a e0 28			ld a, (.dmark+2)  
28d9 32 6a fe			ld (debug_mark+2),a  
28dc 18 03			jr .pastdmark  
28de ..			.dmark: db "SCN"  
28e1 f1			.pastdmark: pop af  
28e2			endm  
# End of macro DMARK
28e2						CALLMONITOR 
28e2 cd 6c fe			call debug_vector  
28e5				endm  
# End of macro CALLMONITOR
28e5					endif 
28e5					FORTH_RSP_TOS 
28e5 cd c4 20			call macro_forth_rsp_tos 
28e8				endm 
# End of macro FORTH_RSP_TOS
28e8 e5					push hl 
28e9					FORTH_RSP_POP 
28e9 cd ce 20			call macro_forth_rsp_pop 
28ec				endm 
# End of macro FORTH_RSP_POP
28ec e1					pop hl 
28ed			;		ex de,hl 
28ed 22 bf f4				ld (os_tok_ptr),hl 
28f0			 
28f0			if DEBUG_FORTH_UWORD 
28f0						DMARK "SCL" 
28f0 f5				push af  
28f1 3a 05 29			ld a, (.dmark)  
28f4 32 68 fe			ld (debug_mark),a  
28f7 3a 06 29			ld a, (.dmark+1)  
28fa 32 69 fe			ld (debug_mark+1),a  
28fd 3a 07 29			ld a, (.dmark+2)  
2900 32 6a fe			ld (debug_mark+2),a  
2903 18 03			jr .pastdmark  
2905 ..			.dmark: db "SCL"  
2908 f1			.pastdmark: pop af  
2909			endm  
# End of macro DMARK
2909				CALLMONITOR 
2909 cd 6c fe			call debug_vector  
290c				endm  
# End of macro CALLMONITOR
290c			endif 
290c					NEXTW 
290c c3 b3 24			jp macro_next 
290f				endm 
# End of macro NEXTW
290f			 
290f			.DROP: 
290f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
290f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2910 3a 29			dw .DUP2            
2912 05				db 4 + 1 
2913 .. 00			db "DROP",0              
2918				endm 
# End of macro CWHEAD
2918			; | DROP ( w -- )   drop the TOS item   | DONE 
2918					if DEBUG_FORTH_WORDS_KEY 
2918						DMARK "DRP" 
2918 f5				push af  
2919 3a 2d 29			ld a, (.dmark)  
291c 32 68 fe			ld (debug_mark),a  
291f 3a 2e 29			ld a, (.dmark+1)  
2922 32 69 fe			ld (debug_mark+1),a  
2925 3a 2f 29			ld a, (.dmark+2)  
2928 32 6a fe			ld (debug_mark+2),a  
292b 18 03			jr .pastdmark  
292d ..			.dmark: db "DRP"  
2930 f1			.pastdmark: pop af  
2931			endm  
# End of macro DMARK
2931						CALLMONITOR 
2931 cd 6c fe			call debug_vector  
2934				endm  
# End of macro CALLMONITOR
2934					endif 
2934					FORTH_DSP_POP 
2934 cd b5 23			call macro_forth_dsp_pop 
2937				endm 
# End of macro FORTH_DSP_POP
2937					NEXTW 
2937 c3 b3 24			jp macro_next 
293a				endm 
# End of macro NEXTW
293a			.DUP2: 
293a				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
293a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
293b 7f 29			dw .DROP2            
293d 05				db 4 + 1 
293e .. 00			db "2DUP",0              
2943				endm 
# End of macro CWHEAD
2943			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2943					if DEBUG_FORTH_WORDS_KEY 
2943						DMARK "2DU" 
2943 f5				push af  
2944 3a 58 29			ld a, (.dmark)  
2947 32 68 fe			ld (debug_mark),a  
294a 3a 59 29			ld a, (.dmark+1)  
294d 32 69 fe			ld (debug_mark+1),a  
2950 3a 5a 29			ld a, (.dmark+2)  
2953 32 6a fe			ld (debug_mark+2),a  
2956 18 03			jr .pastdmark  
2958 ..			.dmark: db "2DU"  
295b f1			.pastdmark: pop af  
295c			endm  
# End of macro DMARK
295c						CALLMONITOR 
295c cd 6c fe			call debug_vector  
295f				endm  
# End of macro CALLMONITOR
295f					endif 
295f					FORTH_DSP_VALUEHL 
295f cd fd 22			call macro_dsp_valuehl 
2962				endm 
# End of macro FORTH_DSP_VALUEHL
2962 e5					push hl      ; 2 
2963			 
2963					FORTH_DSP_POP 
2963 cd b5 23			call macro_forth_dsp_pop 
2966				endm 
# End of macro FORTH_DSP_POP
2966					 
2966					FORTH_DSP_VALUEHL 
2966 cd fd 22			call macro_dsp_valuehl 
2969				endm 
# End of macro FORTH_DSP_VALUEHL
2969			;		push hl      ; 1 
2969			 
2969					FORTH_DSP_POP 
2969 cd b5 23			call macro_forth_dsp_pop 
296c				endm 
# End of macro FORTH_DSP_POP
296c			 
296c			;		pop hl       ; 1 
296c d1					pop de       ; 2 
296d			 
296d cd 06 21				call forth_push_numhl 
2970 eb					ex de, hl 
2971 cd 06 21				call forth_push_numhl 
2974			 
2974					 
2974 eb					ex de, hl 
2975			 
2975 cd 06 21				call forth_push_numhl 
2978 eb					ex de, hl 
2979 cd 06 21				call forth_push_numhl 
297c			 
297c			 
297c					NEXTW 
297c c3 b3 24			jp macro_next 
297f				endm 
# End of macro NEXTW
297f			.DROP2: 
297f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
297f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2980 ae 29			dw .SWAP2            
2982 06				db 5 + 1 
2983 .. 00			db "2DROP",0              
2989				endm 
# End of macro CWHEAD
2989			; | 2DROP ( w w -- )    Double drop | DONE 
2989					if DEBUG_FORTH_WORDS_KEY 
2989						DMARK "2DR" 
2989 f5				push af  
298a 3a 9e 29			ld a, (.dmark)  
298d 32 68 fe			ld (debug_mark),a  
2990 3a 9f 29			ld a, (.dmark+1)  
2993 32 69 fe			ld (debug_mark+1),a  
2996 3a a0 29			ld a, (.dmark+2)  
2999 32 6a fe			ld (debug_mark+2),a  
299c 18 03			jr .pastdmark  
299e ..			.dmark: db "2DR"  
29a1 f1			.pastdmark: pop af  
29a2			endm  
# End of macro DMARK
29a2						CALLMONITOR 
29a2 cd 6c fe			call debug_vector  
29a5				endm  
# End of macro CALLMONITOR
29a5					endif 
29a5					FORTH_DSP_POP 
29a5 cd b5 23			call macro_forth_dsp_pop 
29a8				endm 
# End of macro FORTH_DSP_POP
29a8					FORTH_DSP_POP 
29a8 cd b5 23			call macro_forth_dsp_pop 
29ab				endm 
# End of macro FORTH_DSP_POP
29ab					NEXTW 
29ab c3 b3 24			jp macro_next 
29ae				endm 
# End of macro NEXTW
29ae			.SWAP2: 
29ae				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29ae 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29af d7 29			dw .AT            
29b1 06				db 5 + 1 
29b2 .. 00			db "2SWAP",0              
29b8				endm 
# End of macro CWHEAD
29b8			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29b8					if DEBUG_FORTH_WORDS_KEY 
29b8						DMARK "2SW" 
29b8 f5				push af  
29b9 3a cd 29			ld a, (.dmark)  
29bc 32 68 fe			ld (debug_mark),a  
29bf 3a ce 29			ld a, (.dmark+1)  
29c2 32 69 fe			ld (debug_mark+1),a  
29c5 3a cf 29			ld a, (.dmark+2)  
29c8 32 6a fe			ld (debug_mark+2),a  
29cb 18 03			jr .pastdmark  
29cd ..			.dmark: db "2SW"  
29d0 f1			.pastdmark: pop af  
29d1			endm  
# End of macro DMARK
29d1						CALLMONITOR 
29d1 cd 6c fe			call debug_vector  
29d4				endm  
# End of macro CALLMONITOR
29d4					endif 
29d4					NEXTW 
29d4 c3 b3 24			jp macro_next 
29d7				endm 
# End of macro NEXTW
29d7			.AT: 
29d7				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29d7 1f				db WORD_SYS_CORE+OPCODE_AT             
29d8 09 2a			dw .CAT            
29da 02				db 1 + 1 
29db .. 00			db "@",0              
29dd				endm 
# End of macro CWHEAD
29dd			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29dd			 
29dd					if DEBUG_FORTH_WORDS_KEY 
29dd						DMARK "AT." 
29dd f5				push af  
29de 3a f2 29			ld a, (.dmark)  
29e1 32 68 fe			ld (debug_mark),a  
29e4 3a f3 29			ld a, (.dmark+1)  
29e7 32 69 fe			ld (debug_mark+1),a  
29ea 3a f4 29			ld a, (.dmark+2)  
29ed 32 6a fe			ld (debug_mark+2),a  
29f0 18 03			jr .pastdmark  
29f2 ..			.dmark: db "AT."  
29f5 f1			.pastdmark: pop af  
29f6			endm  
# End of macro DMARK
29f6						CALLMONITOR 
29f6 cd 6c fe			call debug_vector  
29f9				endm  
# End of macro CALLMONITOR
29f9					endif 
29f9			.getbyteat:	 
29f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f9 cd fd 22			call macro_dsp_valuehl 
29fc				endm 
# End of macro FORTH_DSP_VALUEHL
29fc					 
29fc			;		push hl 
29fc				 
29fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29fc cd b5 23			call macro_forth_dsp_pop 
29ff				endm 
# End of macro FORTH_DSP_POP
29ff			 
29ff			;		pop hl 
29ff			 
29ff 7e					ld a, (hl) 
2a00			 
2a00 6f					ld l, a 
2a01 26 00				ld h, 0 
2a03 cd 06 21				call forth_push_numhl 
2a06			 
2a06					NEXTW 
2a06 c3 b3 24			jp macro_next 
2a09				endm 
# End of macro NEXTW
2a09			.CAT: 
2a09				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a09 20				db WORD_SYS_CORE+OPCODE_CAT             
2a0a 32 2a			dw .BANG            
2a0c 03				db 2 + 1 
2a0d .. 00			db "C@",0              
2a10				endm 
# End of macro CWHEAD
2a10			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a10					if DEBUG_FORTH_WORDS_KEY 
2a10						DMARK "CAA" 
2a10 f5				push af  
2a11 3a 25 2a			ld a, (.dmark)  
2a14 32 68 fe			ld (debug_mark),a  
2a17 3a 26 2a			ld a, (.dmark+1)  
2a1a 32 69 fe			ld (debug_mark+1),a  
2a1d 3a 27 2a			ld a, (.dmark+2)  
2a20 32 6a fe			ld (debug_mark+2),a  
2a23 18 03			jr .pastdmark  
2a25 ..			.dmark: db "CAA"  
2a28 f1			.pastdmark: pop af  
2a29			endm  
# End of macro DMARK
2a29						CALLMONITOR 
2a29 cd 6c fe			call debug_vector  
2a2c				endm  
# End of macro CALLMONITOR
2a2c					endif 
2a2c c3 f9 29				jp .getbyteat 
2a2f					NEXTW 
2a2f c3 b3 24			jp macro_next 
2a32				endm 
# End of macro NEXTW
2a32			.BANG: 
2a32				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a32 21				db WORD_SYS_CORE+OPCODE_BANG             
2a33 68 2a			dw .CBANG            
2a35 02				db 1 + 1 
2a36 .. 00			db "!",0              
2a38				endm 
# End of macro CWHEAD
2a38			; | ! ( x w -- ) Store x at address w      | DONE 
2a38					if DEBUG_FORTH_WORDS_KEY 
2a38						DMARK "BNG" 
2a38 f5				push af  
2a39 3a 4d 2a			ld a, (.dmark)  
2a3c 32 68 fe			ld (debug_mark),a  
2a3f 3a 4e 2a			ld a, (.dmark+1)  
2a42 32 69 fe			ld (debug_mark+1),a  
2a45 3a 4f 2a			ld a, (.dmark+2)  
2a48 32 6a fe			ld (debug_mark+2),a  
2a4b 18 03			jr .pastdmark  
2a4d ..			.dmark: db "BNG"  
2a50 f1			.pastdmark: pop af  
2a51			endm  
# End of macro DMARK
2a51						CALLMONITOR 
2a51 cd 6c fe			call debug_vector  
2a54				endm  
# End of macro CALLMONITOR
2a54					endif 
2a54			 
2a54			.storebyteat:		 
2a54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a54 cd fd 22			call macro_dsp_valuehl 
2a57				endm 
# End of macro FORTH_DSP_VALUEHL
2a57					 
2a57 e5					push hl 
2a58				 
2a58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a58 cd b5 23			call macro_forth_dsp_pop 
2a5b				endm 
# End of macro FORTH_DSP_POP
2a5b			 
2a5b					; get byte to poke 
2a5b			 
2a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a5b cd fd 22			call macro_dsp_valuehl 
2a5e				endm 
# End of macro FORTH_DSP_VALUEHL
2a5e e5					push hl 
2a5f			 
2a5f			 
2a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5f cd b5 23			call macro_forth_dsp_pop 
2a62				endm 
# End of macro FORTH_DSP_POP
2a62			 
2a62			 
2a62 d1					pop de 
2a63 e1					pop hl 
2a64			 
2a64 73					ld (hl),e 
2a65			 
2a65			 
2a65					NEXTW 
2a65 c3 b3 24			jp macro_next 
2a68				endm 
# End of macro NEXTW
2a68			.CBANG: 
2a68				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a68 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a69 91 2a			dw .SCALL            
2a6b 03				db 2 + 1 
2a6c .. 00			db "C!",0              
2a6f				endm 
# End of macro CWHEAD
2a6f			; | C!  ( x w -- ) Store x at address w  | DONE 
2a6f					if DEBUG_FORTH_WORDS_KEY 
2a6f						DMARK "CBA" 
2a6f f5				push af  
2a70 3a 84 2a			ld a, (.dmark)  
2a73 32 68 fe			ld (debug_mark),a  
2a76 3a 85 2a			ld a, (.dmark+1)  
2a79 32 69 fe			ld (debug_mark+1),a  
2a7c 3a 86 2a			ld a, (.dmark+2)  
2a7f 32 6a fe			ld (debug_mark+2),a  
2a82 18 03			jr .pastdmark  
2a84 ..			.dmark: db "CBA"  
2a87 f1			.pastdmark: pop af  
2a88			endm  
# End of macro DMARK
2a88						CALLMONITOR 
2a88 cd 6c fe			call debug_vector  
2a8b				endm  
# End of macro CALLMONITOR
2a8b					endif 
2a8b c3 54 2a				jp .storebyteat 
2a8e					NEXTW 
2a8e c3 b3 24			jp macro_next 
2a91				endm 
# End of macro NEXTW
2a91			.SCALL: 
2a91				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a91 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a92 c5 2a			dw .DEPTH            
2a94 05				db 4 + 1 
2a95 .. 00			db "CALL",0              
2a9a				endm 
# End of macro CWHEAD
2a9a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a9a					if DEBUG_FORTH_WORDS_KEY 
2a9a						DMARK "CLL" 
2a9a f5				push af  
2a9b 3a af 2a			ld a, (.dmark)  
2a9e 32 68 fe			ld (debug_mark),a  
2aa1 3a b0 2a			ld a, (.dmark+1)  
2aa4 32 69 fe			ld (debug_mark+1),a  
2aa7 3a b1 2a			ld a, (.dmark+2)  
2aaa 32 6a fe			ld (debug_mark+2),a  
2aad 18 03			jr .pastdmark  
2aaf ..			.dmark: db "CLL"  
2ab2 f1			.pastdmark: pop af  
2ab3			endm  
# End of macro DMARK
2ab3						CALLMONITOR 
2ab3 cd 6c fe			call debug_vector  
2ab6				endm  
# End of macro CALLMONITOR
2ab6					endif 
2ab6			 
2ab6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab6 cd fd 22			call macro_dsp_valuehl 
2ab9				endm 
# End of macro FORTH_DSP_VALUEHL
2ab9			 
2ab9			;		push hl 
2ab9			 
2ab9					; destroy value TOS 
2ab9			 
2ab9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab9 cd b5 23			call macro_forth_dsp_pop 
2abc				endm 
# End of macro FORTH_DSP_POP
2abc			 
2abc						 
2abc			;		pop hl 
2abc			 
2abc					; how to do a call with hl???? save SP? 
2abc cd 57 24				call forth_call_hl 
2abf			 
2abf			 
2abf					; TODO push value back onto stack for another op etc 
2abf			 
2abf cd 06 21				call forth_push_numhl 
2ac2					NEXTW 
2ac2 c3 b3 24			jp macro_next 
2ac5				endm 
# End of macro NEXTW
2ac5			.DEPTH: 
2ac5				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ac5 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ac6 02 2b			dw .OVER            
2ac8 06				db 5 + 1 
2ac9 .. 00			db "DEPTH",0              
2acf				endm 
# End of macro CWHEAD
2acf			; | DEPTH ( -- u ) Push count of stack | DONE 
2acf					; take current TOS and remove from base value div by two to get count 
2acf					if DEBUG_FORTH_WORDS_KEY 
2acf						DMARK "DEP" 
2acf f5				push af  
2ad0 3a e4 2a			ld a, (.dmark)  
2ad3 32 68 fe			ld (debug_mark),a  
2ad6 3a e5 2a			ld a, (.dmark+1)  
2ad9 32 69 fe			ld (debug_mark+1),a  
2adc 3a e6 2a			ld a, (.dmark+2)  
2adf 32 6a fe			ld (debug_mark+2),a  
2ae2 18 03			jr .pastdmark  
2ae4 ..			.dmark: db "DEP"  
2ae7 f1			.pastdmark: pop af  
2ae8			endm  
# End of macro DMARK
2ae8						CALLMONITOR 
2ae8 cd 6c fe			call debug_vector  
2aeb				endm  
# End of macro CALLMONITOR
2aeb					endif 
2aeb			 
2aeb			 
2aeb 2a eb f9			ld hl, (cli_data_sp) 
2aee 11 25 f7			ld de, cli_data_stack 
2af1 ed 52			sbc hl,de 
2af3				 
2af3				; div by size of stack item 
2af3			 
2af3 5d				ld e,l 
2af4 0e 03			ld c, 3 
2af6 cd 60 0f			call Div8 
2af9			 
2af9 6f				ld l,a 
2afa 26 00			ld h,0 
2afc			 
2afc				;srl h 
2afc				;rr l 
2afc			 
2afc cd 06 21				call forth_push_numhl 
2aff					NEXTW 
2aff c3 b3 24			jp macro_next 
2b02				endm 
# End of macro NEXTW
2b02			.OVER: 
2b02				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b02 42				db WORD_SYS_CORE+46             
2b03 49 2b			dw .PAUSE            
2b05 05				db 4 + 1 
2b06 .. 00			db "OVER",0              
2b0b				endm 
# End of macro CWHEAD
2b0b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b0b					if DEBUG_FORTH_WORDS_KEY 
2b0b						DMARK "OVR" 
2b0b f5				push af  
2b0c 3a 20 2b			ld a, (.dmark)  
2b0f 32 68 fe			ld (debug_mark),a  
2b12 3a 21 2b			ld a, (.dmark+1)  
2b15 32 69 fe			ld (debug_mark+1),a  
2b18 3a 22 2b			ld a, (.dmark+2)  
2b1b 32 6a fe			ld (debug_mark+2),a  
2b1e 18 03			jr .pastdmark  
2b20 ..			.dmark: db "OVR"  
2b23 f1			.pastdmark: pop af  
2b24			endm  
# End of macro DMARK
2b24						CALLMONITOR 
2b24 cd 6c fe			call debug_vector  
2b27				endm  
# End of macro CALLMONITOR
2b27					endif 
2b27			 
2b27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b27 cd fd 22			call macro_dsp_valuehl 
2b2a				endm 
# End of macro FORTH_DSP_VALUEHL
2b2a e5					push hl    ; n2 
2b2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2b cd b5 23			call macro_forth_dsp_pop 
2b2e				endm 
# End of macro FORTH_DSP_POP
2b2e			 
2b2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2e cd fd 22			call macro_dsp_valuehl 
2b31				endm 
# End of macro FORTH_DSP_VALUEHL
2b31 e5					push hl    ; n1 
2b32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b32 cd b5 23			call macro_forth_dsp_pop 
2b35				endm 
# End of macro FORTH_DSP_POP
2b35			 
2b35 d1					pop de     ; n1 
2b36 e1					pop hl     ; n2 
2b37			 
2b37 d5					push de 
2b38 e5					push hl 
2b39 d5					push de 
2b3a			 
2b3a					; push back  
2b3a			 
2b3a e1					pop hl 
2b3b cd 06 21				call forth_push_numhl 
2b3e e1					pop hl 
2b3f cd 06 21				call forth_push_numhl 
2b42 e1					pop hl 
2b43 cd 06 21				call forth_push_numhl 
2b46					NEXTW 
2b46 c3 b3 24			jp macro_next 
2b49				endm 
# End of macro NEXTW
2b49			 
2b49			.PAUSE: 
2b49				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b49 43				db WORD_SYS_CORE+47             
2b4a 7e 2b			dw .PAUSES            
2b4c 08				db 7 + 1 
2b4d .. 00			db "PAUSEMS",0              
2b55				endm 
# End of macro CWHEAD
2b55			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b55					if DEBUG_FORTH_WORDS_KEY 
2b55						DMARK "PMS" 
2b55 f5				push af  
2b56 3a 6a 2b			ld a, (.dmark)  
2b59 32 68 fe			ld (debug_mark),a  
2b5c 3a 6b 2b			ld a, (.dmark+1)  
2b5f 32 69 fe			ld (debug_mark+1),a  
2b62 3a 6c 2b			ld a, (.dmark+2)  
2b65 32 6a fe			ld (debug_mark+2),a  
2b68 18 03			jr .pastdmark  
2b6a ..			.dmark: db "PMS"  
2b6d f1			.pastdmark: pop af  
2b6e			endm  
# End of macro DMARK
2b6e						CALLMONITOR 
2b6e cd 6c fe			call debug_vector  
2b71				endm  
# End of macro CALLMONITOR
2b71					endif 
2b71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b71 cd fd 22			call macro_dsp_valuehl 
2b74				endm 
# End of macro FORTH_DSP_VALUEHL
2b74			;		push hl    ; n2 
2b74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b74 cd b5 23			call macro_forth_dsp_pop 
2b77				endm 
# End of macro FORTH_DSP_POP
2b77			;		pop hl 
2b77			 
2b77 7d					ld a, l 
2b78 cd c4 0c				call aDelayInMS 
2b7b				       NEXTW 
2b7b c3 b3 24			jp macro_next 
2b7e				endm 
# End of macro NEXTW
2b7e			.PAUSES:  
2b7e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b7e 44				db WORD_SYS_CORE+48             
2b7f ed 2b			dw .ROT            
2b81 06				db 5 + 1 
2b82 .. 00			db "PAUSE",0              
2b88				endm 
# End of macro CWHEAD
2b88			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b88					if DEBUG_FORTH_WORDS_KEY 
2b88						DMARK "PAU" 
2b88 f5				push af  
2b89 3a 9d 2b			ld a, (.dmark)  
2b8c 32 68 fe			ld (debug_mark),a  
2b8f 3a 9e 2b			ld a, (.dmark+1)  
2b92 32 69 fe			ld (debug_mark+1),a  
2b95 3a 9f 2b			ld a, (.dmark+2)  
2b98 32 6a fe			ld (debug_mark+2),a  
2b9b 18 03			jr .pastdmark  
2b9d ..			.dmark: db "PAU"  
2ba0 f1			.pastdmark: pop af  
2ba1			endm  
# End of macro DMARK
2ba1						CALLMONITOR 
2ba1 cd 6c fe			call debug_vector  
2ba4				endm  
# End of macro CALLMONITOR
2ba4					endif 
2ba4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ba4 cd fd 22			call macro_dsp_valuehl 
2ba7				endm 
# End of macro FORTH_DSP_VALUEHL
2ba7			;		push hl    ; n2 
2ba7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ba7 cd b5 23			call macro_forth_dsp_pop 
2baa				endm 
# End of macro FORTH_DSP_POP
2baa			;		pop hl 
2baa 45					ld b, l 
2bab					if DEBUG_FORTH_WORDS 
2bab						DMARK "PAU" 
2bab f5				push af  
2bac 3a c0 2b			ld a, (.dmark)  
2baf 32 68 fe			ld (debug_mark),a  
2bb2 3a c1 2b			ld a, (.dmark+1)  
2bb5 32 69 fe			ld (debug_mark+1),a  
2bb8 3a c2 2b			ld a, (.dmark+2)  
2bbb 32 6a fe			ld (debug_mark+2),a  
2bbe 18 03			jr .pastdmark  
2bc0 ..			.dmark: db "PAU"  
2bc3 f1			.pastdmark: pop af  
2bc4			endm  
# End of macro DMARK
2bc4						CALLMONITOR 
2bc4 cd 6c fe			call debug_vector  
2bc7				endm  
# End of macro CALLMONITOR
2bc7					endif 
2bc7 c5			.pauses1:	push bc 
2bc8 cd df 0c				call delay1s 
2bcb c1					pop bc 
2bcc					if DEBUG_FORTH_WORDS 
2bcc						DMARK "PA1" 
2bcc f5				push af  
2bcd 3a e1 2b			ld a, (.dmark)  
2bd0 32 68 fe			ld (debug_mark),a  
2bd3 3a e2 2b			ld a, (.dmark+1)  
2bd6 32 69 fe			ld (debug_mark+1),a  
2bd9 3a e3 2b			ld a, (.dmark+2)  
2bdc 32 6a fe			ld (debug_mark+2),a  
2bdf 18 03			jr .pastdmark  
2be1 ..			.dmark: db "PA1"  
2be4 f1			.pastdmark: pop af  
2be5			endm  
# End of macro DMARK
2be5						CALLMONITOR 
2be5 cd 6c fe			call debug_vector  
2be8				endm  
# End of macro CALLMONITOR
2be8					endif 
2be8 10 dd				djnz .pauses1 
2bea			 
2bea				       NEXTW 
2bea c3 b3 24			jp macro_next 
2bed				endm 
# End of macro NEXTW
2bed			.ROT: 
2bed				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bed 45				db WORD_SYS_CORE+49             
2bee 3b 2c			dw .UWORDS            
2bf0 04				db 3 + 1 
2bf1 .. 00			db "ROT",0              
2bf5				endm 
# End of macro CWHEAD
2bf5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bf5					if DEBUG_FORTH_WORDS_KEY 
2bf5						DMARK "ROT" 
2bf5 f5				push af  
2bf6 3a 0a 2c			ld a, (.dmark)  
2bf9 32 68 fe			ld (debug_mark),a  
2bfc 3a 0b 2c			ld a, (.dmark+1)  
2bff 32 69 fe			ld (debug_mark+1),a  
2c02 3a 0c 2c			ld a, (.dmark+2)  
2c05 32 6a fe			ld (debug_mark+2),a  
2c08 18 03			jr .pastdmark  
2c0a ..			.dmark: db "ROT"  
2c0d f1			.pastdmark: pop af  
2c0e			endm  
# End of macro DMARK
2c0e						CALLMONITOR 
2c0e cd 6c fe			call debug_vector  
2c11				endm  
# End of macro CALLMONITOR
2c11					endif 
2c11			 
2c11					FORTH_DSP_VALUEHL 
2c11 cd fd 22			call macro_dsp_valuehl 
2c14				endm 
# End of macro FORTH_DSP_VALUEHL
2c14 e5					push hl    ; u3  
2c15			 
2c15					FORTH_DSP_POP 
2c15 cd b5 23			call macro_forth_dsp_pop 
2c18				endm 
# End of macro FORTH_DSP_POP
2c18			   
2c18					FORTH_DSP_VALUEHL 
2c18 cd fd 22			call macro_dsp_valuehl 
2c1b				endm 
# End of macro FORTH_DSP_VALUEHL
2c1b e5					push hl     ; u2 
2c1c			 
2c1c					FORTH_DSP_POP 
2c1c cd b5 23			call macro_forth_dsp_pop 
2c1f				endm 
# End of macro FORTH_DSP_POP
2c1f			 
2c1f					FORTH_DSP_VALUEHL 
2c1f cd fd 22			call macro_dsp_valuehl 
2c22				endm 
# End of macro FORTH_DSP_VALUEHL
2c22 e5					push hl     ; u1 
2c23			 
2c23					FORTH_DSP_POP 
2c23 cd b5 23			call macro_forth_dsp_pop 
2c26				endm 
# End of macro FORTH_DSP_POP
2c26			 
2c26 c1					pop bc      ; u1 
2c27 e1					pop hl      ; u2 
2c28 d1					pop de      ; u3 
2c29			 
2c29			 
2c29 c5					push bc 
2c2a d5					push de 
2c2b e5					push hl 
2c2c			 
2c2c			 
2c2c e1					pop hl 
2c2d cd 06 21				call forth_push_numhl 
2c30			 
2c30 e1					pop hl 
2c31 cd 06 21				call forth_push_numhl 
2c34			 
2c34 e1					pop hl 
2c35 cd 06 21				call forth_push_numhl 
2c38					 
2c38			 
2c38			 
2c38			 
2c38			 
2c38			 
2c38				       NEXTW 
2c38 c3 b3 24			jp macro_next 
2c3b				endm 
# End of macro NEXTW
2c3b			 
2c3b			.UWORDS: 
2c3b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c3b 50				db WORD_SYS_CORE+60             
2c3c fd 2c			dw .BP            
2c3e 07				db 6 + 1 
2c3f .. 00			db "UWORDS",0              
2c46				endm 
# End of macro CWHEAD
2c46			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c46			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c46			; | | Following the count are the individual words. 
2c46			; | | 
2c46			; | | e.g. UWORDS 
2c46			; | | BOX DIRLIST 2 
2c46			; | |  
2c46			; | | Can be used to save the words to storage via: 
2c46			; | | UWORDS $01 DO $01 APPEND LOOP 
2c46				if DEBUG_FORTH_WORDS_KEY 
2c46					DMARK "UWR" 
2c46 f5				push af  
2c47 3a 5b 2c			ld a, (.dmark)  
2c4a 32 68 fe			ld (debug_mark),a  
2c4d 3a 5c 2c			ld a, (.dmark+1)  
2c50 32 69 fe			ld (debug_mark+1),a  
2c53 3a 5d 2c			ld a, (.dmark+2)  
2c56 32 6a fe			ld (debug_mark+2),a  
2c59 18 03			jr .pastdmark  
2c5b ..			.dmark: db "UWR"  
2c5e f1			.pastdmark: pop af  
2c5f			endm  
# End of macro DMARK
2c5f					CALLMONITOR 
2c5f cd 6c fe			call debug_vector  
2c62				endm  
# End of macro CALLMONITOR
2c62				endif 
2c62 21 00 80				ld hl, baseram 
2c65					;ld hl, baseusermem 
2c65 01 00 00				ld bc, 0    ; start a counter 
2c68			 
2c68				; skip dict stub 
2c68			 
2c68 cd 04 26				call forth_tok_next 
2c6b			 
2c6b			 
2c6b			; while we have words to look for 
2c6b			 
2c6b 7e			.douscan:	ld a, (hl)      
2c6c				if DEBUG_FORTH_WORDS 
2c6c					DMARK "UWs" 
2c6c f5				push af  
2c6d 3a 81 2c			ld a, (.dmark)  
2c70 32 68 fe			ld (debug_mark),a  
2c73 3a 82 2c			ld a, (.dmark+1)  
2c76 32 69 fe			ld (debug_mark+1),a  
2c79 3a 83 2c			ld a, (.dmark+2)  
2c7c 32 6a fe			ld (debug_mark+2),a  
2c7f 18 03			jr .pastdmark  
2c81 ..			.dmark: db "UWs"  
2c84 f1			.pastdmark: pop af  
2c85			endm  
# End of macro DMARK
2c85					CALLMONITOR 
2c85 cd 6c fe			call debug_vector  
2c88				endm  
# End of macro CALLMONITOR
2c88				endif 
2c88 fe 00				cp WORD_SYS_END 
2c8a 28 4d				jr z, .udone 
2c8c fe 01				cp WORD_SYS_UWORD 
2c8e 20 44				jr nz, .nuword 
2c90			 
2c90				if DEBUG_FORTH_WORDS 
2c90					DMARK "UWu" 
2c90 f5				push af  
2c91 3a a5 2c			ld a, (.dmark)  
2c94 32 68 fe			ld (debug_mark),a  
2c97 3a a6 2c			ld a, (.dmark+1)  
2c9a 32 69 fe			ld (debug_mark+1),a  
2c9d 3a a7 2c			ld a, (.dmark+2)  
2ca0 32 6a fe			ld (debug_mark+2),a  
2ca3 18 03			jr .pastdmark  
2ca5 ..			.dmark: db "UWu"  
2ca8 f1			.pastdmark: pop af  
2ca9			endm  
# End of macro DMARK
2ca9					CALLMONITOR 
2ca9 cd 6c fe			call debug_vector  
2cac				endm  
# End of macro CALLMONITOR
2cac				endif 
2cac					; we have a uword so push its name to the stack 
2cac			 
2cac e5				   	push hl  ; save so we can move to next dict block 
2cad			 
2cad					; skip opcode 
2cad 23					inc hl  
2cae					; skip next ptr 
2cae 23					inc hl  
2caf 23					inc hl 
2cb0					; skip len 
2cb0 23					inc hl 
2cb1				if DEBUG_FORTH_WORDS 
2cb1					DMARK "UWt" 
2cb1 f5				push af  
2cb2 3a c6 2c			ld a, (.dmark)  
2cb5 32 68 fe			ld (debug_mark),a  
2cb8 3a c7 2c			ld a, (.dmark+1)  
2cbb 32 69 fe			ld (debug_mark+1),a  
2cbe 3a c8 2c			ld a, (.dmark+2)  
2cc1 32 6a fe			ld (debug_mark+2),a  
2cc4 18 03			jr .pastdmark  
2cc6 ..			.dmark: db "UWt"  
2cc9 f1			.pastdmark: pop af  
2cca			endm  
# End of macro DMARK
2cca					CALLMONITOR 
2cca cd 6c fe			call debug_vector  
2ccd				endm  
# End of macro CALLMONITOR
2ccd				endif 
2ccd 03					inc bc 
2cce			 
2cce c5					push bc 
2ccf cd 74 21				call forth_push_str 
2cd2 c1					pop bc 
2cd3			 
2cd3 e1					pop hl 	 
2cd4			 
2cd4 cd 04 26		.nuword:	call forth_tok_next 
2cd7 18 92				jr .douscan  
2cd9			 
2cd9			.udone:		 ; push count of uwords found 
2cd9 c5					push bc 
2cda e1					pop hl 
2cdb			 
2cdb				if DEBUG_FORTH_WORDS 
2cdb					DMARK "UWc" 
2cdb f5				push af  
2cdc 3a f0 2c			ld a, (.dmark)  
2cdf 32 68 fe			ld (debug_mark),a  
2ce2 3a f1 2c			ld a, (.dmark+1)  
2ce5 32 69 fe			ld (debug_mark+1),a  
2ce8 3a f2 2c			ld a, (.dmark+2)  
2ceb 32 6a fe			ld (debug_mark+2),a  
2cee 18 03			jr .pastdmark  
2cf0 ..			.dmark: db "UWc"  
2cf3 f1			.pastdmark: pop af  
2cf4			endm  
# End of macro DMARK
2cf4					CALLMONITOR 
2cf4 cd 6c fe			call debug_vector  
2cf7				endm  
# End of macro CALLMONITOR
2cf7				endif 
2cf7 cd 06 21				call forth_push_numhl 
2cfa			 
2cfa			 
2cfa				       NEXTW 
2cfa c3 b3 24			jp macro_next 
2cfd				endm 
# End of macro NEXTW
2cfd			 
2cfd			.BP: 
2cfd				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cfd 54				db WORD_SYS_CORE+64             
2cfe 37 2d			dw .MONITOR            
2d00 03				db 2 + 1 
2d01 .. 00			db "BP",0              
2d04				endm 
# End of macro CWHEAD
2d04			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d04			; | | $00 Will enable the break points within specific code paths 
2d04			; | | $01 Will disable break points 
2d04			; | |  
2d04			; | | By default break points are off. Either the above can be used to enable them 
2d04			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d04			; | | and on release of the pressed key a message will be disaplayed to notify 
2d04			; | | that break points are enabled. Pressing any key will then continue boot process. 
2d04					; get byte count 
2d04					if DEBUG_FORTH_WORDS_KEY 
2d04						DMARK "BP." 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 68 fe			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 69 fe			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 6a fe			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "BP."  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d						CALLMONITOR 
2d1d cd 6c fe			call debug_vector  
2d20				endm  
# End of macro CALLMONITOR
2d20					endif 
2d20			 
2d20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d20 cd fd 22			call macro_dsp_valuehl 
2d23				endm 
# End of macro FORTH_DSP_VALUEHL
2d23			 
2d23			;		push hl 
2d23			 
2d23					; destroy value TOS 
2d23			 
2d23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d23 cd b5 23			call macro_forth_dsp_pop 
2d26				endm 
# End of macro FORTH_DSP_POP
2d26			 
2d26			;		pop hl 
2d26			 
2d26 3e 00				ld a,0 
2d28 bd					cp l 
2d29 28 06				jr z, .bpset 
2d2b			;		ld a, '*' 
2d2b cd 42 1a				call bp_off 
2d2e					NEXTW 
2d2e c3 b3 24			jp macro_next 
2d31				endm 
# End of macro NEXTW
2d31			 
2d31			.bpset:	 
2d31					;	ld (os_view_disable), a 
2d31 cd 36 1a				call bp_on 
2d34			 
2d34			 
2d34					NEXTW 
2d34 c3 b3 24			jp macro_next 
2d37				endm 
# End of macro NEXTW
2d37			 
2d37			 
2d37			.MONITOR: 
2d37				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d37 55				db WORD_SYS_CORE+65             
2d38 68 2d			dw .MALLOC            
2d3a 08				db 7 + 1 
2d3b .. 00			db "MONITOR",0              
2d43				endm 
# End of macro CWHEAD
2d43			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d43			; | | At start the current various registers will be displayed with contents. 
2d43			; | | Top right corner will show the most recent debug marker seen. 
2d43			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d43			; | | and the return stack pointer (RSP). 
2d43			; | | Pressing: 
2d43			; | |    1 - Initial screen 
2d43			; | |    2 - Display a data dump of HL 
2d43			; | |    3 - Display a data dump of DE 
2d43			; | |    4 - Display a data dump of BC 
2d43			; | |    5 - Display a data dump of HL 
2d43			; | |    6 - Display a data dump of DSP 
2d43			; | |    7 - Display a data dump of RSP 
2d43			; | |    8 - Display a data dump of what is at DSP 
2d43			; | |    9 - Display a data dump of what is at RSP 
2d43			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d43			; | |    * - Disable break points 
2d43			; | |    # - Enter traditional monitor mode 
2d43			; | | 
2d43			; | | Monitor Mode 
2d43			; | | ------------ 
2d43			; | | A prompt of '>' will be shown for various commands: 
2d43			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d43			; | |    C - Continue display a data dump from the last set address 
2d43			; | |    M xxxx - Set start of memory edit at address xx 
2d43			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d43			; | |    Q - Return to previous 
2d43					if DEBUG_FORTH_WORDS_KEY 
2d43						DMARK "MON" 
2d43 f5				push af  
2d44 3a 58 2d			ld a, (.dmark)  
2d47 32 68 fe			ld (debug_mark),a  
2d4a 3a 59 2d			ld a, (.dmark+1)  
2d4d 32 69 fe			ld (debug_mark+1),a  
2d50 3a 5a 2d			ld a, (.dmark+2)  
2d53 32 6a fe			ld (debug_mark+2),a  
2d56 18 03			jr .pastdmark  
2d58 ..			.dmark: db "MON"  
2d5b f1			.pastdmark: pop af  
2d5c			endm  
# End of macro DMARK
2d5c						CALLMONITOR 
2d5c cd 6c fe			call debug_vector  
2d5f				endm  
# End of macro CALLMONITOR
2d5f					endif 
2d5f			;		ld a, 0 
2d5f			;		ld (os_view_disable), a 
2d5f cd 36 1a				call bp_on 
2d62			 
2d62					CALLMONITOR 
2d62 cd 6c fe			call debug_vector  
2d65				endm  
# End of macro CALLMONITOR
2d65			 
2d65			;	call monitor 
2d65			 
2d65					NEXTW 
2d65 c3 b3 24			jp macro_next 
2d68				endm 
# End of macro NEXTW
2d68			 
2d68			 
2d68			.MALLOC: 
2d68				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d68 56				db WORD_SYS_CORE+66             
2d69 91 2d			dw .MALLOC2            
2d6b 06				db 5 + 1 
2d6c .. 00			db "ALLOT",0              
2d72				endm 
# End of macro CWHEAD
2d72			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d72					if DEBUG_FORTH_WORDS_KEY 
2d72						DMARK "ALL" 
2d72 f5				push af  
2d73 3a 87 2d			ld a, (.dmark)  
2d76 32 68 fe			ld (debug_mark),a  
2d79 3a 88 2d			ld a, (.dmark+1)  
2d7c 32 69 fe			ld (debug_mark+1),a  
2d7f 3a 89 2d			ld a, (.dmark+2)  
2d82 32 6a fe			ld (debug_mark+2),a  
2d85 18 03			jr .pastdmark  
2d87 ..			.dmark: db "ALL"  
2d8a f1			.pastdmark: pop af  
2d8b			endm  
# End of macro DMARK
2d8b						CALLMONITOR 
2d8b cd 6c fe			call debug_vector  
2d8e				endm  
# End of macro CALLMONITOR
2d8e					endif 
2d8e c3 b8 2d				jp .mallocc 
2d91			.MALLOC2: 
2d91				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d91 56				db WORD_SYS_CORE+66             
2d92 cf 2d			dw .FREE            
2d94 07				db 6 + 1 
2d95 .. 00			db "MALLOC",0              
2d9c				endm 
# End of macro CWHEAD
2d9c			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d9c					; get byte count 
2d9c					if DEBUG_FORTH_WORDS_KEY 
2d9c						DMARK "MAL" 
2d9c f5				push af  
2d9d 3a b1 2d			ld a, (.dmark)  
2da0 32 68 fe			ld (debug_mark),a  
2da3 3a b2 2d			ld a, (.dmark+1)  
2da6 32 69 fe			ld (debug_mark+1),a  
2da9 3a b3 2d			ld a, (.dmark+2)  
2dac 32 6a fe			ld (debug_mark+2),a  
2daf 18 03			jr .pastdmark  
2db1 ..			.dmark: db "MAL"  
2db4 f1			.pastdmark: pop af  
2db5			endm  
# End of macro DMARK
2db5						CALLMONITOR 
2db5 cd 6c fe			call debug_vector  
2db8				endm  
# End of macro CALLMONITOR
2db8					endif 
2db8			.mallocc: 
2db8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db8 cd fd 22			call macro_dsp_valuehl 
2dbb				endm 
# End of macro FORTH_DSP_VALUEHL
2dbb			 
2dbb			;		push hl 
2dbb			 
2dbb					; destroy value TOS 
2dbb			 
2dbb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dbb cd b5 23			call macro_forth_dsp_pop 
2dbe				endm 
# End of macro FORTH_DSP_POP
2dbe			 
2dbe			;		pop hl 
2dbe cd 97 14				call malloc 
2dc1				if DEBUG_FORTH_MALLOC_GUARD 
2dc1 f5					push af 
2dc2 cd f9 0f				call ishlzero 
2dc5			;		ld a, l 
2dc5			;		add h 
2dc5			;		cp 0 
2dc5 f1					pop af 
2dc6					 
2dc6 cc 05 5e				call z,malloc_error 
2dc9				endif 
2dc9			 
2dc9 cd 06 21				call forth_push_numhl 
2dcc					NEXTW 
2dcc c3 b3 24			jp macro_next 
2dcf				endm 
# End of macro NEXTW
2dcf			 
2dcf			.FREE: 
2dcf				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dcf 57				db WORD_SYS_CORE+67             
2dd0 00 2e			dw .LIST            
2dd2 05				db 4 + 1 
2dd3 .. 00			db "FREE",0              
2dd8				endm 
# End of macro CWHEAD
2dd8			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dd8					if DEBUG_FORTH_WORDS_KEY 
2dd8						DMARK "FRE" 
2dd8 f5				push af  
2dd9 3a ed 2d			ld a, (.dmark)  
2ddc 32 68 fe			ld (debug_mark),a  
2ddf 3a ee 2d			ld a, (.dmark+1)  
2de2 32 69 fe			ld (debug_mark+1),a  
2de5 3a ef 2d			ld a, (.dmark+2)  
2de8 32 6a fe			ld (debug_mark+2),a  
2deb 18 03			jr .pastdmark  
2ded ..			.dmark: db "FRE"  
2df0 f1			.pastdmark: pop af  
2df1			endm  
# End of macro DMARK
2df1						CALLMONITOR 
2df1 cd 6c fe			call debug_vector  
2df4				endm  
# End of macro CALLMONITOR
2df4					endif 
2df4					; get address 
2df4			 
2df4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2df4 cd fd 22			call macro_dsp_valuehl 
2df7				endm 
# End of macro FORTH_DSP_VALUEHL
2df7			 
2df7			;		push hl 
2df7			 
2df7					; destroy value TOS 
2df7			 
2df7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2df7 cd b5 23			call macro_forth_dsp_pop 
2dfa				endm 
# End of macro FORTH_DSP_POP
2dfa			 
2dfa			;		pop hl 
2dfa			if FORTH_ENABLE_MALLOCFREE 
2dfa cd 61 15				call free 
2dfd			endif 
2dfd					NEXTW 
2dfd c3 b3 24			jp macro_next 
2e00				endm 
# End of macro NEXTW
2e00			.LIST: 
2e00				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2e00 5c				db WORD_SYS_CORE+72             
2e01 ee 2f			dw .FORGET            
2e03 05				db 4 + 1 
2e04 .. 00			db "LIST",0              
2e09				endm 
# End of macro CWHEAD
2e09			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e09			; | | The quoted word must be in upper case. 
2e09				if DEBUG_FORTH_WORDS_KEY 
2e09					DMARK "LST" 
2e09 f5				push af  
2e0a 3a 1e 2e			ld a, (.dmark)  
2e0d 32 68 fe			ld (debug_mark),a  
2e10 3a 1f 2e			ld a, (.dmark+1)  
2e13 32 69 fe			ld (debug_mark+1),a  
2e16 3a 20 2e			ld a, (.dmark+2)  
2e19 32 6a fe			ld (debug_mark+2),a  
2e1c 18 03			jr .pastdmark  
2e1e ..			.dmark: db "LST"  
2e21 f1			.pastdmark: pop af  
2e22			endm  
# End of macro DMARK
2e22					CALLMONITOR 
2e22 cd 6c fe			call debug_vector  
2e25				endm  
# End of macro CALLMONITOR
2e25				endif 
2e25			 
2e25					FORTH_DSP_VALUEHL 
2e25 cd fd 22			call macro_dsp_valuehl 
2e28				endm 
# End of macro FORTH_DSP_VALUEHL
2e28			 
2e28 e5					push hl 
2e29					FORTH_DSP_POP 
2e29 cd b5 23			call macro_forth_dsp_pop 
2e2c				endm 
# End of macro FORTH_DSP_POP
2e2c c1					pop bc 
2e2d			 
2e2d			; Start format of scratch string 
2e2d			 
2e2d 21 be f1				ld hl, scratch 
2e30			 
2e30 3e 3a				ld a, ':' 
2e32 77					ld (hl),a 
2e33 23					inc hl 
2e34 3e 20				ld a, ' ' 
2e36 77					ld (hl), a 
2e37			 
2e37					; Get ptr to the word we need to look up 
2e37			 
2e37			;		FORTH_DSP_VALUEHL 
2e37					;v5 FORTH_DSP_VALUE 
2e37				; TODO type check 
2e37			;		inc hl    ; Skip type check  
2e37			;		push hl 
2e37			;		ex de, hl    ; put into DE 
2e37			 
2e37			 
2e37 21 00 80				ld hl, baseram 
2e3a					;ld hl, baseusermem 
2e3a			 
2e3a e5			push hl   ; sacreifical push 
2e3b			 
2e3b			.ldouscanm: 
2e3b e1				pop hl 
2e3c			.ldouscan: 
2e3c				if DEBUG_FORTH_WORDS 
2e3c					DMARK "LSs" 
2e3c f5				push af  
2e3d 3a 51 2e			ld a, (.dmark)  
2e40 32 68 fe			ld (debug_mark),a  
2e43 3a 52 2e			ld a, (.dmark+1)  
2e46 32 69 fe			ld (debug_mark+1),a  
2e49 3a 53 2e			ld a, (.dmark+2)  
2e4c 32 6a fe			ld (debug_mark+2),a  
2e4f 18 03			jr .pastdmark  
2e51 ..			.dmark: db "LSs"  
2e54 f1			.pastdmark: pop af  
2e55			endm  
# End of macro DMARK
2e55					CALLMONITOR 
2e55 cd 6c fe			call debug_vector  
2e58				endm  
# End of macro CALLMONITOR
2e58				endif 
2e58				; skip dict stub 
2e58 cd 04 26				call forth_tok_next 
2e5b			 
2e5b			 
2e5b			; while we have words to look for 
2e5b			 
2e5b 7e				ld a, (hl)      
2e5c				if DEBUG_FORTH_WORDS 
2e5c					DMARK "LSk" 
2e5c f5				push af  
2e5d 3a 71 2e			ld a, (.dmark)  
2e60 32 68 fe			ld (debug_mark),a  
2e63 3a 72 2e			ld a, (.dmark+1)  
2e66 32 69 fe			ld (debug_mark+1),a  
2e69 3a 73 2e			ld a, (.dmark+2)  
2e6c 32 6a fe			ld (debug_mark+2),a  
2e6f 18 03			jr .pastdmark  
2e71 ..			.dmark: db "LSk"  
2e74 f1			.pastdmark: pop af  
2e75			endm  
# End of macro DMARK
2e75					CALLMONITOR 
2e75 cd 6c fe			call debug_vector  
2e78				endm  
# End of macro CALLMONITOR
2e78				endif 
2e78					;cp WORD_SYS_END 
2e78					;jp z, .lunotfound 
2e78			 
2e78					; if we hit non uwords then gone too far 
2e78 fe 01				cp WORD_SYS_UWORD 
2e7a c2 aa 2f				jp nz, .lunotfound 
2e7d			 
2e7d				if DEBUG_FORTH_WORDS 
2e7d					DMARK "LSu" 
2e7d f5				push af  
2e7e 3a 92 2e			ld a, (.dmark)  
2e81 32 68 fe			ld (debug_mark),a  
2e84 3a 93 2e			ld a, (.dmark+1)  
2e87 32 69 fe			ld (debug_mark+1),a  
2e8a 3a 94 2e			ld a, (.dmark+2)  
2e8d 32 6a fe			ld (debug_mark+2),a  
2e90 18 03			jr .pastdmark  
2e92 ..			.dmark: db "LSu"  
2e95 f1			.pastdmark: pop af  
2e96			endm  
# End of macro DMARK
2e96					CALLMONITOR 
2e96 cd 6c fe			call debug_vector  
2e99				endm  
# End of macro CALLMONITOR
2e99				endif 
2e99			 
2e99					; found a uword but is it the one we want... 
2e99			 
2e99 c5					push bc     ; uword to find is on bc 
2e9a d1					pop de 
2e9b			 
2e9b e5					push hl  ; to save the ptr 
2e9c			 
2e9c					; skip opcode 
2e9c 23					inc hl  
2e9d					; skip next ptr 
2e9d 23					inc hl  
2e9e 23					inc hl 
2e9f					; skip len 
2e9f 23					inc hl 
2ea0			 
2ea0				if DEBUG_FORTH_WORDS 
2ea0					DMARK "LSc" 
2ea0 f5				push af  
2ea1 3a b5 2e			ld a, (.dmark)  
2ea4 32 68 fe			ld (debug_mark),a  
2ea7 3a b6 2e			ld a, (.dmark+1)  
2eaa 32 69 fe			ld (debug_mark+1),a  
2ead 3a b7 2e			ld a, (.dmark+2)  
2eb0 32 6a fe			ld (debug_mark+2),a  
2eb3 18 03			jr .pastdmark  
2eb5 ..			.dmark: db "LSc"  
2eb8 f1			.pastdmark: pop af  
2eb9			endm  
# End of macro DMARK
2eb9					CALLMONITOR 
2eb9 cd 6c fe			call debug_vector  
2ebc				endm  
# End of macro CALLMONITOR
2ebc				endif 
2ebc cd 66 14				call strcmp 
2ebf c2 3b 2e				jp nz, .ldouscanm 
2ec2				 
2ec2			 
2ec2			 
2ec2					; we have a uword so push its name to the stack 
2ec2			 
2ec2			;	   	push hl  ; save so we can move to next dict block 
2ec2 e1			pop hl 
2ec3			 
2ec3				if DEBUG_FORTH_WORDS 
2ec3					DMARK "LSm" 
2ec3 f5				push af  
2ec4 3a d8 2e			ld a, (.dmark)  
2ec7 32 68 fe			ld (debug_mark),a  
2eca 3a d9 2e			ld a, (.dmark+1)  
2ecd 32 69 fe			ld (debug_mark+1),a  
2ed0 3a da 2e			ld a, (.dmark+2)  
2ed3 32 6a fe			ld (debug_mark+2),a  
2ed6 18 03			jr .pastdmark  
2ed8 ..			.dmark: db "LSm"  
2edb f1			.pastdmark: pop af  
2edc			endm  
# End of macro DMARK
2edc					CALLMONITOR 
2edc cd 6c fe			call debug_vector  
2edf				endm  
# End of macro CALLMONITOR
2edf				endif 
2edf			 
2edf					; skip opcode 
2edf 23					inc hl  
2ee0					; skip next ptr 
2ee0 23					inc hl  
2ee1 23					inc hl 
2ee2					; skip len 
2ee2 7e					ld a, (hl)   ; save length to add 
2ee3				if DEBUG_FORTH_WORDS 
2ee3					DMARK "LS2" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 68 fe			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 69 fe			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 6a fe			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "LS2"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc					CALLMONITOR 
2efc cd 6c fe			call debug_vector  
2eff				endm  
# End of macro CALLMONITOR
2eff				endif 
2eff			 
2eff					; save this location 
2eff				 
2eff e5					push hl 
2f00			 
2f00 23					inc hl 
2f01 11 c0 f1				ld de, scratch+2 
2f04 4f					ld c, a 
2f05 06 00				ld b, 0 
2f07			 
2f07				if DEBUG_FORTH_WORDS 
2f07					DMARK "LSn" 
2f07 f5				push af  
2f08 3a 1c 2f			ld a, (.dmark)  
2f0b 32 68 fe			ld (debug_mark),a  
2f0e 3a 1d 2f			ld a, (.dmark+1)  
2f11 32 69 fe			ld (debug_mark+1),a  
2f14 3a 1e 2f			ld a, (.dmark+2)  
2f17 32 6a fe			ld (debug_mark+2),a  
2f1a 18 03			jr .pastdmark  
2f1c ..			.dmark: db "LSn"  
2f1f f1			.pastdmark: pop af  
2f20			endm  
# End of macro DMARK
2f20					CALLMONITOR 
2f20 cd 6c fe			call debug_vector  
2f23				endm  
# End of macro CALLMONITOR
2f23				endif 
2f23			 
2f23					; copy uword name to scratch 
2f23			 
2f23 ed b0				ldir 
2f25			 
2f25 1b					dec de 
2f26 3e 20				ld a, ' '    ; change null to space 
2f28 12					ld (de), a 
2f29			 
2f29 13					inc de 
2f2a			 
2f2a d5					push de 
2f2b c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2c			 
2f2c e1					pop hl 
2f2d 7e					ld a, (hl) 
2f2e					;inc hl 
2f2e					; skip word string 
2f2e cd d0 0f				call addatohl 
2f31			 
2f31 23					inc hl 
2f32			 
2f32				if DEBUG_FORTH_WORDS 
2f32					DMARK "LS3" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 68 fe			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 69 fe			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 6a fe			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "LS3"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b					CALLMONITOR 
2f4b cd 6c fe			call debug_vector  
2f4e				endm  
# End of macro CALLMONITOR
2f4e				endif 
2f4e					; should now be at the start of the machine code to setup the eval of the uword 
2f4e					; now locate the ptr to the string defintion 
2f4e			 
2f4e					; skip ld hl, 
2f4e					; then load the ptr 
2f4e			; TODO use get from hl ptr 
2f4e 23					inc hl 
2f4f 5e					ld e, (hl) 
2f50 23					inc hl 
2f51 56					ld d, (hl) 
2f52 eb					ex de, hl 
2f53			 
2f53			 
2f53				if DEBUG_FORTH_WORDS 
2f53					DMARK "LSt" 
2f53 f5				push af  
2f54 3a 68 2f			ld a, (.dmark)  
2f57 32 68 fe			ld (debug_mark),a  
2f5a 3a 69 2f			ld a, (.dmark+1)  
2f5d 32 69 fe			ld (debug_mark+1),a  
2f60 3a 6a 2f			ld a, (.dmark+2)  
2f63 32 6a fe			ld (debug_mark+2),a  
2f66 18 03			jr .pastdmark  
2f68 ..			.dmark: db "LSt"  
2f6b f1			.pastdmark: pop af  
2f6c			endm  
# End of macro DMARK
2f6c					CALLMONITOR 
2f6c cd 6c fe			call debug_vector  
2f6f				endm  
# End of macro CALLMONITOR
2f6f				endif 
2f6f			 
2f6f			; cant push right now due to tokenised strings  
2f6f			 
2f6f			; get the destination of where to copy this definition to. 
2f6f			 
2f6f c5					push bc 
2f70 d1					pop de 
2f71			 
2f71 7e			.listl:         ld a,(hl) 
2f72 fe 00				cp 0 
2f74 28 09				jr z, .lreplsp     ; replace zero with space 
2f76					;cp FORTH_END_BUFFER 
2f76 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f78 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f7a				 
2f7a					; just copy this char as is then 
2f7a			 
2f7a 12					ld (de), a 
2f7b			 
2f7b 23			.listnxt:	inc hl 
2f7c 13					inc de 
2f7d 18 f2				jr .listl 
2f7f			 
2f7f 3e 20		.lreplsp:	ld a,' ' 
2f81 12					ld (de), a 
2f82 18 f7				jr .listnxt 
2f84			 
2f84			; close up uword def 
2f84			 
2f84			.listdone: 
2f84 12					ld (de), a 
2f85 13					inc de 
2f86 3e 00				ld a, 0 
2f88 12					ld (de), a 
2f89			 
2f89			; now have def so clean up and push to stack 
2f89			 
2f89 21 be f1				ld hl, scratch 
2f8c				if DEBUG_FORTH_WORDS 
2f8c					DMARK "Ltp" 
2f8c f5				push af  
2f8d 3a a1 2f			ld a, (.dmark)  
2f90 32 68 fe			ld (debug_mark),a  
2f93 3a a2 2f			ld a, (.dmark+1)  
2f96 32 69 fe			ld (debug_mark+1),a  
2f99 3a a3 2f			ld a, (.dmark+2)  
2f9c 32 6a fe			ld (debug_mark+2),a  
2f9f 18 03			jr .pastdmark  
2fa1 ..			.dmark: db "Ltp"  
2fa4 f1			.pastdmark: pop af  
2fa5			endm  
# End of macro DMARK
2fa5					CALLMONITOR 
2fa5 cd 6c fe			call debug_vector  
2fa8				endm  
# End of macro CALLMONITOR
2fa8				endif 
2fa8			 
2fa8 18 1f			jr .listpush 
2faa			 
2faa			;.lnuword:	pop hl 
2faa			;		call forth_tok_next 
2faa			;		jp .ldouscan  
2faa			 
2faa			.lunotfound:		  
2faa			 
2faa				if DEBUG_FORTH_WORDS 
2faa					DMARK "LSn" 
2faa f5				push af  
2fab 3a bf 2f			ld a, (.dmark)  
2fae 32 68 fe			ld (debug_mark),a  
2fb1 3a c0 2f			ld a, (.dmark+1)  
2fb4 32 69 fe			ld (debug_mark+1),a  
2fb7 3a c1 2f			ld a, (.dmark+2)  
2fba 32 6a fe			ld (debug_mark+2),a  
2fbd 18 03			jr .pastdmark  
2fbf ..			.dmark: db "LSn"  
2fc2 f1			.pastdmark: pop af  
2fc3			endm  
# End of macro DMARK
2fc3					CALLMONITOR 
2fc3 cd 6c fe			call debug_vector  
2fc6				endm  
# End of macro CALLMONITOR
2fc6				endif 
2fc6			 
2fc6					 
2fc6			;		FORTH_DSP_POP 
2fc6			;		ld hl, .luno 
2fc6			 
2fc6					NEXTW			 
2fc6 c3 b3 24			jp macro_next 
2fc9				endm 
# End of macro NEXTW
2fc9			 
2fc9			.listpush: 
2fc9				if DEBUG_FORTH_WORDS 
2fc9					DMARK "LS>" 
2fc9 f5				push af  
2fca 3a de 2f			ld a, (.dmark)  
2fcd 32 68 fe			ld (debug_mark),a  
2fd0 3a df 2f			ld a, (.dmark+1)  
2fd3 32 69 fe			ld (debug_mark+1),a  
2fd6 3a e0 2f			ld a, (.dmark+2)  
2fd9 32 6a fe			ld (debug_mark+2),a  
2fdc 18 03			jr .pastdmark  
2fde ..			.dmark: db "LS>"  
2fe1 f1			.pastdmark: pop af  
2fe2			endm  
# End of macro DMARK
2fe2					CALLMONITOR 
2fe2 cd 6c fe			call debug_vector  
2fe5				endm  
# End of macro CALLMONITOR
2fe5				endif 
2fe5 cd 74 21				call forth_push_str 
2fe8			 
2fe8			 
2fe8			 
2fe8					NEXTW 
2fe8 c3 b3 24			jp macro_next 
2feb				endm 
# End of macro NEXTW
2feb			 
2feb			;.luno:    db "Word not found",0 
2feb			 
2feb			 
2feb			 
2feb			 
2feb			 
2feb			;		push hl   ; save pointer to start of uword def string 
2feb			; 
2feb			;; look for FORTH_EOL_LINE 
2feb			;		ld a, FORTH_END_BUFFER 
2feb			;		call strlent 
2feb			; 
2feb			;		inc hl		 ; space for coln def 
2feb			;		inc hl 
2feb			;		inc hl          ; space for terms 
2feb			;		inc hl 
2feb			; 
2feb			;		ld a, 20   ; TODO get actual length 
2feb			;		call addatohl    ; include a random amount of room for the uword name 
2feb			; 
2feb			;		 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt1" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		 
2feb			; 
2feb			;; malloc space for the string because we cant change it 
2feb			; 
2feb			;		call malloc 
2feb			;	if DEBUG_FORTH_MALLOC_GUARD 
2feb			;		push af 
2feb			;		call ishlzero 
2feb			;		pop af 
2feb			;		 
2feb			;		call z,malloc_error 
2feb			;	endif 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt2" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		pop de 
2feb			;		push hl    ; push the malloc to release later 
2feb			;		push hl   ;  push back a copy for the later stack push 
2feb			;		 
2feb			;; copy the string swapping out the zero terms for spaces 
2feb			; 
2feb			;		; de has our source 
2feb			;		; hl has our dest 
2feb			; 
2feb			;; add the coln def 
2feb			; 
2feb			;		ld a, ':' 
2feb			;		ld (hl), a 
2feb			;		inc hl 
2feb			;		ld a, ' ' 
2feb			;		ld (hl), a 
2feb			;		inc hl 
2feb			; 
2feb			;; add the uname word 
2feb			;		push de   ; save our string for now 
2feb			;		ex de, hl 
2feb			; 
2feb			;		FORTH_DSP_VALUE 
2feb			;		;v5 FORTH_DSP_VALUE 
2feb			; 
2feb			;		inc hl   ; skip type but we know by now this is OK 
2feb			; 
2feb			;.luword:	ld a,(hl) 
2feb			;		cp 0 
2feb			;		jr z, .luword2 
2feb			;		ld (de), a 
2feb			;		inc de 
2feb			;		inc hl 
2feb			;		jr .luword 
2feb			; 
2feb			;.luword2:	ld a, ' ' 
2feb			;		ld (de), a 
2feb			;;		inc hl 
2feb			;;		inc de 
2feb			;;		ld (de), a 
2feb			;;		inc hl 
2feb			;		inc de 
2feb			; 
2feb			;		ex de, hl 
2feb			;		pop de 
2feb			;		 
2feb			;		 
2feb			; 
2feb			;; detoken that string and copy it 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt2" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;.ldetok:	ld a, (de) 
2feb			;		cp FORTH_END_BUFFER 
2feb			;		jr z, .ldetokend 
2feb			;		; swap out any zero term for space 
2feb			;		cp 0 
2feb			;		jr nz, .ldetoknext 
2feb			;		ld a, ' ' 
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "LtS" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;.ldetoknext:	ld (hl), a 
2feb			;		inc de 
2feb			;		inc hl 
2feb			;		jr .ldetok 
2feb			; 
2feb			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2feb			;		ld (hl), a  
2feb			; 
2feb			;; free that temp malloc 
2feb			; 
2feb			;		pop hl    
2feb			; 
2feb			;	if DEBUG_FORTH_WORDS 
2feb			;		DMARK "Lt4" 
2feb			;		CALLMONITOR 
2feb			;	endif 
2feb			;		call forth_apushstrhl 
2feb			; 
2feb			;		; get rid of temp malloc area 
2feb			; 
2feb			;		pop hl 
2feb			;		call free 
2feb			; 
2feb			;		jr .ludone 
2feb			; 
2feb			;.lnuword:	pop hl 
2feb			;		call forth_tok_next 
2feb			;		jp .ldouscan  
2feb			; 
2feb			;.ludone:		 pop hl 
2feb			; 
2feb					NEXTW 
2feb c3 b3 24			jp macro_next 
2fee				endm 
# End of macro NEXTW
2fee			 
2fee			.FORGET: 
2fee				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fee 5d				db WORD_SYS_CORE+73             
2fef 67 30			dw .NOP            
2ff1 07				db 6 + 1 
2ff2 .. 00			db "FORGET",0              
2ff9				endm 
# End of macro CWHEAD
2ff9			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ff9			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2ff9			; | |  
2ff9			; | | e.g. "MORE" forget 
2ff9					if DEBUG_FORTH_WORDS_KEY 
2ff9						DMARK "FRG" 
2ff9 f5				push af  
2ffa 3a 0e 30			ld a, (.dmark)  
2ffd 32 68 fe			ld (debug_mark),a  
3000 3a 0f 30			ld a, (.dmark+1)  
3003 32 69 fe			ld (debug_mark+1),a  
3006 3a 10 30			ld a, (.dmark+2)  
3009 32 6a fe			ld (debug_mark+2),a  
300c 18 03			jr .pastdmark  
300e ..			.dmark: db "FRG"  
3011 f1			.pastdmark: pop af  
3012			endm  
# End of macro DMARK
3012						CALLMONITOR 
3012 cd 6c fe			call debug_vector  
3015				endm  
# End of macro CALLMONITOR
3015					endif 
3015			 
3015				; find uword 
3015			        ; update start of word with "_" 
3015				; replace uword with deleted flag 
3015			 
3015			 
3015			;	if DEBUG_FORTH_WORDS 
3015			;		DMARK "FOG" 
3015			;		CALLMONITOR 
3015			;	endif 
3015			 
3015			 
3015					; Get ptr to the word we need to look up 
3015			 
3015					FORTH_DSP_VALUEHL 
3015 cd fd 22			call macro_dsp_valuehl 
3018				endm 
# End of macro FORTH_DSP_VALUEHL
3018					;v5 FORTH_DSP_VALUE 
3018				; TODO type check 
3018			;		inc hl    ; Skip type check  
3018 e5					push hl 
3019 c1					pop bc 
301a			;		ex de, hl    ; put into DE 
301a			 
301a			 
301a 21 00 80				ld hl, baseram 
301d					;ld hl, baseusermem 
301d			 
301d				; skip dict stub 
301d			;	call forth_tok_next 
301d e5			push hl   ; sacreifical push 
301e			 
301e			.fldouscanm: 
301e e1				pop hl 
301f			.fldouscan: 
301f			;	if DEBUG_FORTH_WORDS 
301f			;		DMARK "LSs" 
301f			;		CALLMONITOR 
301f			;	endif 
301f				; skip dict stub 
301f cd 04 26				call forth_tok_next 
3022			 
3022			 
3022			; while we have words to look for 
3022			 
3022 7e				ld a, (hl)      
3023			;	if DEBUG_FORTH_WORDS 
3023			;		DMARK "LSk" 
3023			;		CALLMONITOR 
3023			;	endif 
3023 fe 00				cp WORD_SYS_END 
3025 ca 61 30				jp z, .flunotfound 
3028 fe 01				cp WORD_SYS_UWORD 
302a c2 1f 30				jp nz, .fldouscan 
302d			 
302d			;	if DEBUG_FORTH_WORDS 
302d			;		DMARK "LSu" 
302d			;		CALLMONITOR 
302d			;	endif 
302d			 
302d					; found a uword but is it the one we want... 
302d			 
302d c5					push bc     ; uword to find is on bc 
302e d1					pop de 
302f			 
302f e5					push hl  ; to save the ptr 
3030			 
3030					; skip opcode 
3030 23					inc hl  
3031					; skip next ptr 
3031 23					inc hl  
3032 23					inc hl 
3033					; skip len 
3033 23					inc hl 
3034			 
3034			;	if DEBUG_FORTH_WORDS 
3034			;		DMARK "LSc" 
3034			;		CALLMONITOR 
3034			;	endif 
3034 cd 66 14				call strcmp 
3037 c2 1e 30				jp nz, .fldouscanm 
303a			; 
303a			; 
303a			;; while we have words to look for 
303a			; 
303a			;.fdouscan:	ld a, (hl)      
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "LSs" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			;		cp WORD_SYS_END 
303a			;		jp z, .fudone 
303a			;		cp WORD_SYS_UWORD 
303a			;		jp nz, .fnuword 
303a			; 
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "FGu" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			; 
303a			;		; found a uword but is it the one we want... 
303a			; 
303a			; 
303a			;	        pop de   ; get back the dsp name 
303a			;		push de 
303a			; 
303a			;		push hl  ; to save the ptr 
303a			; 
303a			;		; skip opcode 
303a			;		inc hl  
303a			;		; skip next ptr 
303a			;		inc hl  
303a			;		inc hl 
303a			;		; skip len 
303a			;		inc hl 
303a			; 
303a			;	if DEBUG_FORTH_WORDS 
303a			;		DMARK "FGc" 
303a			;		CALLMONITOR 
303a			;	endif 
303a			;		call strcmp 
303a			;		jp nz, .fnuword 
303a			 
303a			 
303a e1			pop hl 
303b			 
303b				 
303b				if DEBUG_FORTH_WORDS 
303b					DMARK "FGm" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 68 fe			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 69 fe			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 6a fe			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "FGm"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054					CALLMONITOR 
3054 cd 6c fe			call debug_vector  
3057				endm  
# End of macro CALLMONITOR
3057				endif 
3057			 
3057			 
3057			 
3057					; we have a uword so push its name to the stack 
3057			 
3057			;	   	push hl  ; save so we can move to next dict block 
3057			;pop hl 
3057			 
3057					; update opcode to deleted 
3057 3e 03				ld a, WORD_SYS_DELETED 
3059 77					ld (hl), a 
305a			 
305a 23					inc hl  
305b					; skip next ptr 
305b 23					inc hl  
305c 23					inc hl 
305d					; skip len 
305d 23					inc hl 
305e			 
305e					; TODO change parser to skip deleted words but for now mark it out 
305e 3e 5f				ld a, "_" 
3060 77					ld  (hl),a 
3061			 
3061			;		jr .fudone 
3061			; 
3061			;.fnuword:	pop hl 
3061			;		call forth_tok_next 
3061			;		jp .fdouscan  
3061			 
3061			.flunotfound:		  
3061			 
3061			 
3061					 
3061					FORTH_DSP_POP 
3061 cd b5 23			call macro_forth_dsp_pop 
3064				endm 
# End of macro FORTH_DSP_POP
3064			;		ld hl, .luno 
3064			;.fudone:		 pop hl 
3064					NEXTW 
3064 c3 b3 24			jp macro_next 
3067				endm 
# End of macro NEXTW
3067			.NOP: 
3067				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3067 61				db WORD_SYS_CORE+77             
3068 8e 30			dw .COMO            
306a 04				db 3 + 1 
306b .. 00			db "NOP",0              
306f				endm 
# End of macro CWHEAD
306f			; | NOP (  --  ) Do nothing | DONE 
306f					if DEBUG_FORTH_WORDS_KEY 
306f						DMARK "NOP" 
306f f5				push af  
3070 3a 84 30			ld a, (.dmark)  
3073 32 68 fe			ld (debug_mark),a  
3076 3a 85 30			ld a, (.dmark+1)  
3079 32 69 fe			ld (debug_mark+1),a  
307c 3a 86 30			ld a, (.dmark+2)  
307f 32 6a fe			ld (debug_mark+2),a  
3082 18 03			jr .pastdmark  
3084 ..			.dmark: db "NOP"  
3087 f1			.pastdmark: pop af  
3088			endm  
# End of macro DMARK
3088						CALLMONITOR 
3088 cd 6c fe			call debug_vector  
308b				endm  
# End of macro CALLMONITOR
308b					endif 
308b				       NEXTW 
308b c3 b3 24			jp macro_next 
308e				endm 
# End of macro NEXTW
308e			.COMO: 
308e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
308e 6e				db WORD_SYS_CORE+90             
308f e0 30			dw .COMC            
3091 02				db 1 + 1 
3092 .. 00			db "(",0              
3094				endm 
# End of macro CWHEAD
3094			; | ( ( -- )  Start of comment | DONE 
3094			 
3094			 
3094 2a bf f4				ld hl, ( os_tok_ptr) 
3097 11 db 30			ld de, .closepar 
309a					 
309a					if DEBUG_FORTH_WORDS 
309a						DMARK ").." 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 68 fe			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 69 fe			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 6a fe			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db ").."  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3						CALLMONITOR 
30b3 cd 6c fe			call debug_vector  
30b6				endm  
# End of macro CALLMONITOR
30b6					endif 
30b6 cd ce 25			call findnexttok  
30b9			 
30b9					if DEBUG_FORTH_WORDS 
30b9						DMARK "IF5" 
30b9 f5				push af  
30ba 3a ce 30			ld a, (.dmark)  
30bd 32 68 fe			ld (debug_mark),a  
30c0 3a cf 30			ld a, (.dmark+1)  
30c3 32 69 fe			ld (debug_mark+1),a  
30c6 3a d0 30			ld a, (.dmark+2)  
30c9 32 6a fe			ld (debug_mark+2),a  
30cc 18 03			jr .pastdmark  
30ce ..			.dmark: db "IF5"  
30d1 f1			.pastdmark: pop af  
30d2			endm  
# End of macro DMARK
30d2						CALLMONITOR 
30d2 cd 6c fe			call debug_vector  
30d5				endm  
# End of macro CALLMONITOR
30d5					endif 
30d5				; replace below with ) exec using tok_ptr 
30d5 22 bf f4			ld (os_tok_ptr), hl 
30d8 c3 44 25			jp exec1 
30db			 
30db .. 00			.closepar:   db ")",0 
30dd			 
30dd				       NEXTW 
30dd c3 b3 24			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			.COMC: 
30e0				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30e0 6f				db WORD_SYS_CORE+91             
30e1 e9 30			dw .SCRATCH            
30e3 02				db 1 + 1 
30e4 .. 00			db ")",0              
30e6				endm 
# End of macro CWHEAD
30e6			; | ) ( -- )  End of comment |  DONE  
30e6				       NEXTW 
30e6 c3 b3 24			jp macro_next 
30e9				endm 
# End of macro NEXTW
30e9			 
30e9			.SCRATCH: 
30e9				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30e9 6f				db WORD_SYS_CORE+91             
30ea 24 31			dw .INC            
30ec 08				db 7 + 1 
30ed .. 00			db "SCRATCH",0              
30f5				endm 
# End of macro CWHEAD
30f5			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f5			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f5			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f5			; | |  
30f5			; | | e.g.    : score $00 scratch ; 
30f5			; | |  
30f5			; | | $00 score ! 
30f5			; | | $01 score +! 
30f5			; | |  
30f5			; | | e.g.   : varword $0a scratch ;  
30f5			; | | 
30f5			; | | $8000 varword ! 
30f5					if DEBUG_FORTH_WORDS_KEY 
30f5						DMARK "SCR" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 68 fe			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 69 fe			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 6a fe			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "SCR"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd 6c fe			call debug_vector  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111			 
3111					FORTH_DSP_VALUEHL 
3111 cd fd 22			call macro_dsp_valuehl 
3114				endm 
# End of macro FORTH_DSP_VALUEHL
3114				 
3114					FORTH_DSP_POP 
3114 cd b5 23			call macro_forth_dsp_pop 
3117				endm 
# End of macro FORTH_DSP_POP
3117			 
3117 7d					ld a, l 
3118 21 e3 f6				ld hl, os_var_array 
311b cd d0 0f				call addatohl 
311e			 
311e cd 06 21				call forth_push_numhl 
3121			 
3121				       NEXTW 
3121 c3 b3 24			jp macro_next 
3124				endm 
# End of macro NEXTW
3124			 
3124			.INC: 
3124				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3124 6f				db WORD_SYS_CORE+91             
3125 78 31			dw .DEC            
3127 03				db 2 + 1 
3128 .. 00			db "+!",0              
312b				endm 
# End of macro CWHEAD
312b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
312b					if DEBUG_FORTH_WORDS_KEY 
312b						DMARK "+s_" 
312b f5				push af  
312c 3a 40 31			ld a, (.dmark)  
312f 32 68 fe			ld (debug_mark),a  
3132 3a 41 31			ld a, (.dmark+1)  
3135 32 69 fe			ld (debug_mark+1),a  
3138 3a 42 31			ld a, (.dmark+2)  
313b 32 6a fe			ld (debug_mark+2),a  
313e 18 03			jr .pastdmark  
3140 ..			.dmark: db "+s_"  
3143 f1			.pastdmark: pop af  
3144			endm  
# End of macro DMARK
3144						CALLMONITOR 
3144 cd 6c fe			call debug_vector  
3147				endm  
# End of macro CALLMONITOR
3147					endif 
3147			 
3147					FORTH_DSP_VALUEHL 
3147 cd fd 22			call macro_dsp_valuehl 
314a				endm 
# End of macro FORTH_DSP_VALUEHL
314a			 
314a e5					push hl   ; save address 
314b			 
314b					FORTH_DSP_POP 
314b cd b5 23			call macro_forth_dsp_pop 
314e				endm 
# End of macro FORTH_DSP_POP
314e			 
314e					FORTH_DSP_VALUEHL 
314e cd fd 22			call macro_dsp_valuehl 
3151				endm 
# End of macro FORTH_DSP_VALUEHL
3151			 
3151					FORTH_DSP_POP 
3151 cd b5 23			call macro_forth_dsp_pop 
3154				endm 
# End of macro FORTH_DSP_POP
3154			 
3154					; hl contains value to add to byte at a 
3154				 
3154 eb					ex de, hl 
3155			 
3155 e1					pop hl 
3156			 
3156					if DEBUG_FORTH_WORDS 
3156						DMARK "INC" 
3156 f5				push af  
3157 3a 6b 31			ld a, (.dmark)  
315a 32 68 fe			ld (debug_mark),a  
315d 3a 6c 31			ld a, (.dmark+1)  
3160 32 69 fe			ld (debug_mark+1),a  
3163 3a 6d 31			ld a, (.dmark+2)  
3166 32 6a fe			ld (debug_mark+2),a  
3169 18 03			jr .pastdmark  
316b ..			.dmark: db "INC"  
316e f1			.pastdmark: pop af  
316f			endm  
# End of macro DMARK
316f						CALLMONITOR 
316f cd 6c fe			call debug_vector  
3172				endm  
# End of macro CALLMONITOR
3172					endif 
3172			 
3172 7e					ld a,(hl) 
3173 83					add e 
3174 77					ld (hl),a 
3175			 
3175			 
3175			 
3175				       NEXTW 
3175 c3 b3 24			jp macro_next 
3178				endm 
# End of macro NEXTW
3178			 
3178			.DEC: 
3178				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3178 6f				db WORD_SYS_CORE+91             
3179 c9 31			dw .INC2            
317b 03				db 2 + 1 
317c .. 00			db "-!",0              
317f				endm 
# End of macro CWHEAD
317f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
317f					if DEBUG_FORTH_WORDS_KEY 
317f						DMARK "-s_" 
317f f5				push af  
3180 3a 94 31			ld a, (.dmark)  
3183 32 68 fe			ld (debug_mark),a  
3186 3a 95 31			ld a, (.dmark+1)  
3189 32 69 fe			ld (debug_mark+1),a  
318c 3a 96 31			ld a, (.dmark+2)  
318f 32 6a fe			ld (debug_mark+2),a  
3192 18 03			jr .pastdmark  
3194 ..			.dmark: db "-s_"  
3197 f1			.pastdmark: pop af  
3198			endm  
# End of macro DMARK
3198						CALLMONITOR 
3198 cd 6c fe			call debug_vector  
319b				endm  
# End of macro CALLMONITOR
319b					endif 
319b			 
319b					FORTH_DSP_VALUEHL 
319b cd fd 22			call macro_dsp_valuehl 
319e				endm 
# End of macro FORTH_DSP_VALUEHL
319e			 
319e e5					push hl   ; save address 
319f			 
319f					FORTH_DSP_POP 
319f cd b5 23			call macro_forth_dsp_pop 
31a2				endm 
# End of macro FORTH_DSP_POP
31a2			 
31a2					FORTH_DSP_VALUEHL 
31a2 cd fd 22			call macro_dsp_valuehl 
31a5				endm 
# End of macro FORTH_DSP_VALUEHL
31a5			 
31a5					; hl contains value to add to byte at a 
31a5				 
31a5 eb					ex de, hl 
31a6			 
31a6 e1					pop hl 
31a7			 
31a7					if DEBUG_FORTH_WORDS 
31a7						DMARK "DEC" 
31a7 f5				push af  
31a8 3a bc 31			ld a, (.dmark)  
31ab 32 68 fe			ld (debug_mark),a  
31ae 3a bd 31			ld a, (.dmark+1)  
31b1 32 69 fe			ld (debug_mark+1),a  
31b4 3a be 31			ld a, (.dmark+2)  
31b7 32 6a fe			ld (debug_mark+2),a  
31ba 18 03			jr .pastdmark  
31bc ..			.dmark: db "DEC"  
31bf f1			.pastdmark: pop af  
31c0			endm  
# End of macro DMARK
31c0						CALLMONITOR 
31c0 cd 6c fe			call debug_vector  
31c3				endm  
# End of macro CALLMONITOR
31c3					endif 
31c3			 
31c3 7e					ld a,(hl) 
31c4 93					sub e 
31c5 77					ld (hl),a 
31c6			 
31c6			 
31c6			 
31c6				       NEXTW 
31c6 c3 b3 24			jp macro_next 
31c9				endm 
# End of macro NEXTW
31c9			 
31c9			.INC2: 
31c9				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31c9 6f				db WORD_SYS_CORE+91             
31ca 73 32			dw .DEC2            
31cc 04				db 3 + 1 
31cd .. 00			db "+2!",0              
31d1				endm 
# End of macro CWHEAD
31d1			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31d1			 
31d1					if DEBUG_FORTH_WORDS_KEY 
31d1						DMARK "+2s" 
31d1 f5				push af  
31d2 3a e6 31			ld a, (.dmark)  
31d5 32 68 fe			ld (debug_mark),a  
31d8 3a e7 31			ld a, (.dmark+1)  
31db 32 69 fe			ld (debug_mark+1),a  
31de 3a e8 31			ld a, (.dmark+2)  
31e1 32 6a fe			ld (debug_mark+2),a  
31e4 18 03			jr .pastdmark  
31e6 ..			.dmark: db "+2s"  
31e9 f1			.pastdmark: pop af  
31ea			endm  
# End of macro DMARK
31ea						CALLMONITOR 
31ea cd 6c fe			call debug_vector  
31ed				endm  
# End of macro CALLMONITOR
31ed					endif 
31ed			 
31ed					; Address 
31ed			 
31ed					FORTH_DSP_VALUEHL 
31ed cd fd 22			call macro_dsp_valuehl 
31f0				endm 
# End of macro FORTH_DSP_VALUEHL
31f0			 
31f0 e5					push hl    ; save address 
31f1			 
31f1					; load content into de 
31f1			 
31f1 5e					ld e,(hl) 
31f2 23					inc hl 
31f3 56					ld d, (hl) 
31f4			 
31f4					if DEBUG_FORTH_WORDS 
31f4						DMARK "+2a" 
31f4 f5				push af  
31f5 3a 09 32			ld a, (.dmark)  
31f8 32 68 fe			ld (debug_mark),a  
31fb 3a 0a 32			ld a, (.dmark+1)  
31fe 32 69 fe			ld (debug_mark+1),a  
3201 3a 0b 32			ld a, (.dmark+2)  
3204 32 6a fe			ld (debug_mark+2),a  
3207 18 03			jr .pastdmark  
3209 ..			.dmark: db "+2a"  
320c f1			.pastdmark: pop af  
320d			endm  
# End of macro DMARK
320d						CALLMONITOR 
320d cd 6c fe			call debug_vector  
3210				endm  
# End of macro CALLMONITOR
3210					endif 
3210			 
3210					FORTH_DSP_POP 
3210 cd b5 23			call macro_forth_dsp_pop 
3213				endm 
# End of macro FORTH_DSP_POP
3213			 
3213					; Get value to add 
3213			 
3213					FORTH_DSP_VALUE 
3213 cd e6 22			call macro_forth_dsp_value 
3216				endm 
# End of macro FORTH_DSP_VALUE
3216			 
3216					if DEBUG_FORTH_WORDS 
3216						DMARK "+2v" 
3216 f5				push af  
3217 3a 2b 32			ld a, (.dmark)  
321a 32 68 fe			ld (debug_mark),a  
321d 3a 2c 32			ld a, (.dmark+1)  
3220 32 69 fe			ld (debug_mark+1),a  
3223 3a 2d 32			ld a, (.dmark+2)  
3226 32 6a fe			ld (debug_mark+2),a  
3229 18 03			jr .pastdmark  
322b ..			.dmark: db "+2v"  
322e f1			.pastdmark: pop af  
322f			endm  
# End of macro DMARK
322f						CALLMONITOR 
322f cd 6c fe			call debug_vector  
3232				endm  
# End of macro CALLMONITOR
3232					endif 
3232			 
3232 19					add hl, de 
3233			 
3233					if DEBUG_FORTH_WORDS 
3233						DMARK "+2+" 
3233 f5				push af  
3234 3a 48 32			ld a, (.dmark)  
3237 32 68 fe			ld (debug_mark),a  
323a 3a 49 32			ld a, (.dmark+1)  
323d 32 69 fe			ld (debug_mark+1),a  
3240 3a 4a 32			ld a, (.dmark+2)  
3243 32 6a fe			ld (debug_mark+2),a  
3246 18 03			jr .pastdmark  
3248 ..			.dmark: db "+2+"  
324b f1			.pastdmark: pop af  
324c			endm  
# End of macro DMARK
324c						CALLMONITOR 
324c cd 6c fe			call debug_vector  
324f				endm  
# End of macro CALLMONITOR
324f					endif 
324f			 
324f					; move result to de 
324f			 
324f eb					ex de, hl 
3250			 
3250					; Address 
3250			 
3250 e1					pop hl 
3251			 
3251					; save it back 
3251			 
3251 73					ld (hl), e 
3252 23					inc hl 
3253 72					ld (hl), d 
3254			 
3254					if DEBUG_FORTH_WORDS 
3254						DMARK "+2e" 
3254 f5				push af  
3255 3a 69 32			ld a, (.dmark)  
3258 32 68 fe			ld (debug_mark),a  
325b 3a 6a 32			ld a, (.dmark+1)  
325e 32 69 fe			ld (debug_mark+1),a  
3261 3a 6b 32			ld a, (.dmark+2)  
3264 32 6a fe			ld (debug_mark+2),a  
3267 18 03			jr .pastdmark  
3269 ..			.dmark: db "+2e"  
326c f1			.pastdmark: pop af  
326d			endm  
# End of macro DMARK
326d						CALLMONITOR 
326d cd 6c fe			call debug_vector  
3270				endm  
# End of macro CALLMONITOR
3270					endif 
3270			 
3270			 
3270			 
3270			 
3270			 
3270				       NEXTW 
3270 c3 b3 24			jp macro_next 
3273				endm 
# End of macro NEXTW
3273			 
3273			.DEC2: 
3273				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3273 6f				db WORD_SYS_CORE+91             
3274 1f 33			dw .GET2            
3276 04				db 3 + 1 
3277 .. 00			db "-2!",0              
327b				endm 
# End of macro CWHEAD
327b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
327b			 
327b			 
327b					if DEBUG_FORTH_WORDS_KEY 
327b						DMARK "-2s" 
327b f5				push af  
327c 3a 90 32			ld a, (.dmark)  
327f 32 68 fe			ld (debug_mark),a  
3282 3a 91 32			ld a, (.dmark+1)  
3285 32 69 fe			ld (debug_mark+1),a  
3288 3a 92 32			ld a, (.dmark+2)  
328b 32 6a fe			ld (debug_mark+2),a  
328e 18 03			jr .pastdmark  
3290 ..			.dmark: db "-2s"  
3293 f1			.pastdmark: pop af  
3294			endm  
# End of macro DMARK
3294						CALLMONITOR 
3294 cd 6c fe			call debug_vector  
3297				endm  
# End of macro CALLMONITOR
3297					endif 
3297			 
3297					; Address 
3297			 
3297					FORTH_DSP_VALUEHL 
3297 cd fd 22			call macro_dsp_valuehl 
329a				endm 
# End of macro FORTH_DSP_VALUEHL
329a			 
329a e5					push hl    ; save address 
329b			 
329b					; load content into de 
329b			 
329b 5e					ld e,(hl) 
329c 23					inc hl 
329d 56					ld d, (hl) 
329e			 
329e					if DEBUG_FORTH_WORDS 
329e						DMARK "-2a" 
329e f5				push af  
329f 3a b3 32			ld a, (.dmark)  
32a2 32 68 fe			ld (debug_mark),a  
32a5 3a b4 32			ld a, (.dmark+1)  
32a8 32 69 fe			ld (debug_mark+1),a  
32ab 3a b5 32			ld a, (.dmark+2)  
32ae 32 6a fe			ld (debug_mark+2),a  
32b1 18 03			jr .pastdmark  
32b3 ..			.dmark: db "-2a"  
32b6 f1			.pastdmark: pop af  
32b7			endm  
# End of macro DMARK
32b7						CALLMONITOR 
32b7 cd 6c fe			call debug_vector  
32ba				endm  
# End of macro CALLMONITOR
32ba					endif 
32ba			 
32ba					FORTH_DSP_POP 
32ba cd b5 23			call macro_forth_dsp_pop 
32bd				endm 
# End of macro FORTH_DSP_POP
32bd			 
32bd					; Get value to remove 
32bd			 
32bd					FORTH_DSP_VALUE 
32bd cd e6 22			call macro_forth_dsp_value 
32c0				endm 
# End of macro FORTH_DSP_VALUE
32c0			 
32c0					if DEBUG_FORTH_WORDS 
32c0						DMARK "-2v" 
32c0 f5				push af  
32c1 3a d5 32			ld a, (.dmark)  
32c4 32 68 fe			ld (debug_mark),a  
32c7 3a d6 32			ld a, (.dmark+1)  
32ca 32 69 fe			ld (debug_mark+1),a  
32cd 3a d7 32			ld a, (.dmark+2)  
32d0 32 6a fe			ld (debug_mark+2),a  
32d3 18 03			jr .pastdmark  
32d5 ..			.dmark: db "-2v"  
32d8 f1			.pastdmark: pop af  
32d9			endm  
# End of macro DMARK
32d9						CALLMONITOR 
32d9 cd 6c fe			call debug_vector  
32dc				endm  
# End of macro CALLMONITOR
32dc					endif 
32dc			 
32dc eb					ex de, hl 
32dd ed 52				sbc hl, de 
32df			 
32df					if DEBUG_FORTH_WORDS 
32df						DMARK "-2d" 
32df f5				push af  
32e0 3a f4 32			ld a, (.dmark)  
32e3 32 68 fe			ld (debug_mark),a  
32e6 3a f5 32			ld a, (.dmark+1)  
32e9 32 69 fe			ld (debug_mark+1),a  
32ec 3a f6 32			ld a, (.dmark+2)  
32ef 32 6a fe			ld (debug_mark+2),a  
32f2 18 03			jr .pastdmark  
32f4 ..			.dmark: db "-2d"  
32f7 f1			.pastdmark: pop af  
32f8			endm  
# End of macro DMARK
32f8						CALLMONITOR 
32f8 cd 6c fe			call debug_vector  
32fb				endm  
# End of macro CALLMONITOR
32fb					endif 
32fb			 
32fb					; move result to de 
32fb			 
32fb eb					ex de, hl 
32fc			 
32fc					; Address 
32fc			 
32fc e1					pop hl 
32fd			 
32fd					; save it back 
32fd			 
32fd 73					ld (hl), e 
32fe 23					inc hl 
32ff 72					ld (hl), d 
3300			 
3300					if DEBUG_FORTH_WORDS 
3300						DMARK "-2e" 
3300 f5				push af  
3301 3a 15 33			ld a, (.dmark)  
3304 32 68 fe			ld (debug_mark),a  
3307 3a 16 33			ld a, (.dmark+1)  
330a 32 69 fe			ld (debug_mark+1),a  
330d 3a 17 33			ld a, (.dmark+2)  
3310 32 6a fe			ld (debug_mark+2),a  
3313 18 03			jr .pastdmark  
3315 ..			.dmark: db "-2e"  
3318 f1			.pastdmark: pop af  
3319			endm  
# End of macro DMARK
3319						CALLMONITOR 
3319 cd 6c fe			call debug_vector  
331c				endm  
# End of macro CALLMONITOR
331c					endif 
331c			 
331c			 
331c			 
331c			 
331c			 
331c				       NEXTW 
331c c3 b3 24			jp macro_next 
331f				endm 
# End of macro NEXTW
331f			.GET2: 
331f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
331f 6f				db WORD_SYS_CORE+91             
3320 4f 33			dw .BANG2            
3322 03				db 2 + 1 
3323 .. 00			db "2@",0              
3326				endm 
# End of macro CWHEAD
3326			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3326					if DEBUG_FORTH_WORDS_KEY 
3326						DMARK "2A_" 
3326 f5				push af  
3327 3a 3b 33			ld a, (.dmark)  
332a 32 68 fe			ld (debug_mark),a  
332d 3a 3c 33			ld a, (.dmark+1)  
3330 32 69 fe			ld (debug_mark+1),a  
3333 3a 3d 33			ld a, (.dmark+2)  
3336 32 6a fe			ld (debug_mark+2),a  
3339 18 03			jr .pastdmark  
333b ..			.dmark: db "2A_"  
333e f1			.pastdmark: pop af  
333f			endm  
# End of macro DMARK
333f						CALLMONITOR 
333f cd 6c fe			call debug_vector  
3342				endm  
# End of macro CALLMONITOR
3342					endif 
3342			 
3342					FORTH_DSP_VALUEHL 
3342 cd fd 22			call macro_dsp_valuehl 
3345				endm 
# End of macro FORTH_DSP_VALUEHL
3345			 
3345 5e					ld e, (hl) 
3346 23					inc hl 
3347 56					ld d, (hl) 
3348			 
3348 eb					ex de, hl 
3349			 
3349 cd 06 21				call forth_push_numhl 
334c			 
334c				       NEXTW 
334c c3 b3 24			jp macro_next 
334f				endm 
# End of macro NEXTW
334f			.BANG2: 
334f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
334f 6f				db WORD_SYS_CORE+91             
3350 87 33			dw .CONFIG            
3352 03				db 2 + 1 
3353 .. 00			db "2!",0              
3356				endm 
# End of macro CWHEAD
3356			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3356					if DEBUG_FORTH_WORDS_KEY 
3356						DMARK "2S_" 
3356 f5				push af  
3357 3a 6b 33			ld a, (.dmark)  
335a 32 68 fe			ld (debug_mark),a  
335d 3a 6c 33			ld a, (.dmark+1)  
3360 32 69 fe			ld (debug_mark+1),a  
3363 3a 6d 33			ld a, (.dmark+2)  
3366 32 6a fe			ld (debug_mark+2),a  
3369 18 03			jr .pastdmark  
336b ..			.dmark: db "2S_"  
336e f1			.pastdmark: pop af  
336f			endm  
# End of macro DMARK
336f						CALLMONITOR 
336f cd 6c fe			call debug_vector  
3372				endm  
# End of macro CALLMONITOR
3372					endif 
3372			 
3372					FORTH_DSP_VALUEHL 
3372 cd fd 22			call macro_dsp_valuehl 
3375				endm 
# End of macro FORTH_DSP_VALUEHL
3375			 
3375 e5					push hl   ; save address 
3376			 
3376			 
3376					FORTH_DSP_POP 
3376 cd b5 23			call macro_forth_dsp_pop 
3379				endm 
# End of macro FORTH_DSP_POP
3379			 
3379					 
3379					FORTH_DSP_VALUEHL 
3379 cd fd 22			call macro_dsp_valuehl 
337c				endm 
# End of macro FORTH_DSP_VALUEHL
337c			 
337c					FORTH_DSP_POP 
337c cd b5 23			call macro_forth_dsp_pop 
337f				endm 
# End of macro FORTH_DSP_POP
337f			 
337f eb					ex de, hl    ; value now in de 
3380			 
3380 e1					pop hl 
3381			 
3381 73					ld (hl), e 
3382			 
3382 23					inc hl 
3383			 
3383 72					ld (hl), d 
3384			 
3384			 
3384				       NEXTW 
3384 c3 b3 24			jp macro_next 
3387				endm 
# End of macro NEXTW
3387			.CONFIG: 
3387				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3387 6f				db WORD_SYS_CORE+91             
3388 98 33			dw .ADTOS            
338a 07				db 6 + 1 
338b .. 00			db "CONFIG",0              
3392				endm 
# End of macro CWHEAD
3392			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3392			 
3392 cd 30 16				call config 
3395					NEXTW 
3395 c3 b3 24			jp macro_next 
3398				endm 
# End of macro NEXTW
3398			 
3398			.ADTOS: 
3398				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3398 6f				db WORD_SYS_CORE+91             
3399 ae 33			dw .SBTOS            
339b 03				db 2 + 1 
339c .. 00			db "1+",0              
339f				endm 
# End of macro CWHEAD
339f			; | 1+ ( u -- u )  Increment value on TOS | DONE 
339f			 
339f					FORTH_DSP_VALUEHL 
339f cd fd 22			call macro_dsp_valuehl 
33a2				endm 
# End of macro FORTH_DSP_VALUEHL
33a2 e5					push hl 
33a3			 
33a3					FORTH_DSP_POP 
33a3 cd b5 23			call macro_forth_dsp_pop 
33a6				endm 
# End of macro FORTH_DSP_POP
33a6 e1					pop hl 
33a7			 
33a7 23					inc hl 
33a8 cd 06 21				call forth_push_numhl 
33ab					 
33ab					NEXTW 
33ab c3 b3 24			jp macro_next 
33ae				endm 
# End of macro NEXTW
33ae			.SBTOS: 
33ae				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33ae 6f				db WORD_SYS_CORE+91             
33af c4 33			dw .ADSTORE            
33b1 03				db 2 + 1 
33b2 .. 00			db "1-",0              
33b5				endm 
# End of macro CWHEAD
33b5			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33b5			 
33b5					FORTH_DSP_VALUEHL 
33b5 cd fd 22			call macro_dsp_valuehl 
33b8				endm 
# End of macro FORTH_DSP_VALUEHL
33b8 e5					push hl 
33b9			 
33b9					FORTH_DSP_POP 
33b9 cd b5 23			call macro_forth_dsp_pop 
33bc				endm 
# End of macro FORTH_DSP_POP
33bc e1					pop hl 
33bd			 
33bd 2b					dec hl 
33be cd 06 21				call forth_push_numhl 
33c1					 
33c1					NEXTW 
33c1 c3 b3 24			jp macro_next 
33c4				endm 
# End of macro NEXTW
33c4			.ADSTORE: 
33c4				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33c4 6f				db WORD_SYS_CORE+91             
33c5 da 33			dw .ADWSTORE            
33c7 04				db 3 + 1 
33c8 .. 00			db "1+!",0              
33cc				endm 
# End of macro CWHEAD
33cc			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33cc			 
33cc					FORTH_DSP_VALUEHL 
33cc cd fd 22			call macro_dsp_valuehl 
33cf				endm 
# End of macro FORTH_DSP_VALUEHL
33cf e5					push hl 
33d0			 
33d0					FORTH_DSP_POP 
33d0 cd b5 23			call macro_forth_dsp_pop 
33d3				endm 
# End of macro FORTH_DSP_POP
33d3 e1					pop hl 
33d4			 
33d4 7e					ld a, (hl) 
33d5 3c					inc a 
33d6 77					ld (hl), a 
33d7					 
33d7					NEXTW 
33d7 c3 b3 24			jp macro_next 
33da				endm 
# End of macro NEXTW
33da			.ADWSTORE: 
33da				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
33da 6f				db WORD_SYS_CORE+91             
33db f8 33			dw .ENDCORE            
33dd 05				db 4 + 1 
33de .. 00			db "1+2!",0              
33e3				endm 
# End of macro CWHEAD
33e3			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33e3			 
33e3					FORTH_DSP_VALUEHL 
33e3 cd fd 22			call macro_dsp_valuehl 
33e6				endm 
# End of macro FORTH_DSP_VALUEHL
33e6 e5					push hl 
33e7			 
33e7					FORTH_DSP_POP 
33e7 cd b5 23			call macro_forth_dsp_pop 
33ea				endm 
# End of macro FORTH_DSP_POP
33ea e1					pop hl 
33eb			 
33eb e5					push hl 
33ec			 
33ec cd 35 24				call loadwordinhl 
33ef 23					inc hl 
33f0			 
33f0 d1					pop de 
33f1 eb					ex de, hl 
33f2 73					ld (hl), e 
33f3 23					inc hl 
33f4 72					ld (hl), d 
33f5					 
33f5					NEXTW 
33f5 c3 b3 24			jp macro_next 
33f8				endm 
# End of macro NEXTW
33f8			.ENDCORE: 
33f8			 
33f8			; eof 
33f8			 
33f8			 
# End of file forth_words_core.asm
33f8			include "forth_words_flow.asm" 
33f8			 
33f8			; | ## Program Flow Words 
33f8			 
33f8			.IF: 
33f8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
33f8 1e				db WORD_SYS_CORE+10             
33f9 ed 34			dw .THEN            
33fb 03				db 2 + 1 
33fc .. 00			db "IF",0              
33ff				endm 
# End of macro CWHEAD
33ff			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
33ff			; 
33ff					if DEBUG_FORTH_WORDS_KEY 
33ff						DMARK "IF." 
33ff f5				push af  
3400 3a 14 34			ld a, (.dmark)  
3403 32 68 fe			ld (debug_mark),a  
3406 3a 15 34			ld a, (.dmark+1)  
3409 32 69 fe			ld (debug_mark+1),a  
340c 3a 16 34			ld a, (.dmark+2)  
340f 32 6a fe			ld (debug_mark+2),a  
3412 18 03			jr .pastdmark  
3414 ..			.dmark: db "IF."  
3417 f1			.pastdmark: pop af  
3418			endm  
# End of macro DMARK
3418						CALLMONITOR 
3418 cd 6c fe			call debug_vector  
341b				endm  
# End of macro CALLMONITOR
341b					endif 
341b			; eval TOS 
341b			 
341b				FORTH_DSP_VALUEHL 
341b cd fd 22			call macro_dsp_valuehl 
341e				endm 
# End of macro FORTH_DSP_VALUEHL
341e			 
341e			;	push hl 
341e				FORTH_DSP_POP 
341e cd b5 23			call macro_forth_dsp_pop 
3421				endm 
# End of macro FORTH_DSP_POP
3421			;	pop hl 
3421			 
3421					if DEBUG_FORTH_WORDS 
3421						DMARK "IF1" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 68 fe			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 69 fe			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 6a fe			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "IF1"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd 6c fe			call debug_vector  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d b7				or a        ; clear carry flag 
343e 11 00 00			ld de, 0 
3441 eb				ex de,hl 
3442 ed 52			sbc hl, de 
3444 c2 ce 34			jp nz, .iftrue 
3447			 
3447					if DEBUG_FORTH_WORDS 
3447						DMARK "IF2" 
3447 f5				push af  
3448 3a 5c 34			ld a, (.dmark)  
344b 32 68 fe			ld (debug_mark),a  
344e 3a 5d 34			ld a, (.dmark+1)  
3451 32 69 fe			ld (debug_mark+1),a  
3454 3a 5e 34			ld a, (.dmark+2)  
3457 32 6a fe			ld (debug_mark+2),a  
345a 18 03			jr .pastdmark  
345c ..			.dmark: db "IF2"  
345f f1			.pastdmark: pop af  
3460			endm  
# End of macro DMARK
3460						CALLMONITOR 
3460 cd 6c fe			call debug_vector  
3463				endm  
# End of macro CALLMONITOR
3463					endif 
3463			 
3463			; if not true then skip to THEN 
3463			 
3463				; TODO get tok_ptr 
3463				; TODO consume toks until we get to THEN 
3463			 
3463 2a bf f4			ld hl, (os_tok_ptr) 
3466					if DEBUG_FORTH_WORDS 
3466						DMARK "IF3" 
3466 f5				push af  
3467 3a 7b 34			ld a, (.dmark)  
346a 32 68 fe			ld (debug_mark),a  
346d 3a 7c 34			ld a, (.dmark+1)  
3470 32 69 fe			ld (debug_mark+1),a  
3473 3a 7d 34			ld a, (.dmark+2)  
3476 32 6a fe			ld (debug_mark+2),a  
3479 18 03			jr .pastdmark  
347b ..			.dmark: db "IF3"  
347e f1			.pastdmark: pop af  
347f			endm  
# End of macro DMARK
347f						CALLMONITOR 
347f cd 6c fe			call debug_vector  
3482				endm  
# End of macro CALLMONITOR
3482						 
3482					endif 
3482 11 c9 34			ld de, .ifthen 
3485					if DEBUG_FORTH_WORDS 
3485						DMARK "IF4" 
3485 f5				push af  
3486 3a 9a 34			ld a, (.dmark)  
3489 32 68 fe			ld (debug_mark),a  
348c 3a 9b 34			ld a, (.dmark+1)  
348f 32 69 fe			ld (debug_mark+1),a  
3492 3a 9c 34			ld a, (.dmark+2)  
3495 32 6a fe			ld (debug_mark+2),a  
3498 18 03			jr .pastdmark  
349a ..			.dmark: db "IF4"  
349d f1			.pastdmark: pop af  
349e			endm  
# End of macro DMARK
349e						CALLMONITOR 
349e cd 6c fe			call debug_vector  
34a1				endm  
# End of macro CALLMONITOR
34a1					endif 
34a1 cd ce 25			call findnexttok  
34a4			 
34a4					if DEBUG_FORTH_WORDS 
34a4						DMARK "IF5" 
34a4 f5				push af  
34a5 3a b9 34			ld a, (.dmark)  
34a8 32 68 fe			ld (debug_mark),a  
34ab 3a ba 34			ld a, (.dmark+1)  
34ae 32 69 fe			ld (debug_mark+1),a  
34b1 3a bb 34			ld a, (.dmark+2)  
34b4 32 6a fe			ld (debug_mark+2),a  
34b7 18 03			jr .pastdmark  
34b9 ..			.dmark: db "IF5"  
34bc f1			.pastdmark: pop af  
34bd			endm  
# End of macro DMARK
34bd						CALLMONITOR 
34bd cd 6c fe			call debug_vector  
34c0				endm  
# End of macro CALLMONITOR
34c0					endif 
34c0				; TODO replace below with ; exec using tok_ptr 
34c0 22 bf f4			ld (os_tok_ptr), hl 
34c3 c3 44 25			jp exec1 
34c6				NEXTW 
34c6 c3 b3 24			jp macro_next 
34c9				endm 
# End of macro NEXTW
34c9			 
34c9 .. 00		.ifthen:  db "THEN",0 
34ce			 
34ce			.iftrue:		 
34ce				; Exec next words normally 
34ce			 
34ce				; if true then exec following IF as normal 
34ce					if DEBUG_FORTH_WORDS 
34ce						DMARK "IFT" 
34ce f5				push af  
34cf 3a e3 34			ld a, (.dmark)  
34d2 32 68 fe			ld (debug_mark),a  
34d5 3a e4 34			ld a, (.dmark+1)  
34d8 32 69 fe			ld (debug_mark+1),a  
34db 3a e5 34			ld a, (.dmark+2)  
34de 32 6a fe			ld (debug_mark+2),a  
34e1 18 03			jr .pastdmark  
34e3 ..			.dmark: db "IFT"  
34e6 f1			.pastdmark: pop af  
34e7			endm  
# End of macro DMARK
34e7						CALLMONITOR 
34e7 cd 6c fe			call debug_vector  
34ea				endm  
# End of macro CALLMONITOR
34ea					endif 
34ea			 
34ea					NEXTW 
34ea c3 b3 24			jp macro_next 
34ed				endm 
# End of macro NEXTW
34ed			.THEN: 
34ed				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
34ed 1f				db WORD_SYS_CORE+11             
34ee 15 35			dw .ELSE            
34f0 05				db 4 + 1 
34f1 .. 00			db "THEN",0              
34f6				endm 
# End of macro CWHEAD
34f6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
34f6					if DEBUG_FORTH_WORDS_KEY 
34f6						DMARK "THN" 
34f6 f5				push af  
34f7 3a 0b 35			ld a, (.dmark)  
34fa 32 68 fe			ld (debug_mark),a  
34fd 3a 0c 35			ld a, (.dmark+1)  
3500 32 69 fe			ld (debug_mark+1),a  
3503 3a 0d 35			ld a, (.dmark+2)  
3506 32 6a fe			ld (debug_mark+2),a  
3509 18 03			jr .pastdmark  
350b ..			.dmark: db "THN"  
350e f1			.pastdmark: pop af  
350f			endm  
# End of macro DMARK
350f						CALLMONITOR 
350f cd 6c fe			call debug_vector  
3512				endm  
# End of macro CALLMONITOR
3512					endif 
3512					NEXTW 
3512 c3 b3 24			jp macro_next 
3515				endm 
# End of macro NEXTW
3515			.ELSE: 
3515				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3515 20				db WORD_SYS_CORE+12             
3516 3d 35			dw .DO            
3518 03				db 2 + 1 
3519 .. 00			db "ELSE",0              
351e				endm 
# End of macro CWHEAD
351e			; | ELSE ( -- ) Not supported - does nothing | TODO 
351e			 
351e					if DEBUG_FORTH_WORDS_KEY 
351e						DMARK "ELS" 
351e f5				push af  
351f 3a 33 35			ld a, (.dmark)  
3522 32 68 fe			ld (debug_mark),a  
3525 3a 34 35			ld a, (.dmark+1)  
3528 32 69 fe			ld (debug_mark+1),a  
352b 3a 35 35			ld a, (.dmark+2)  
352e 32 6a fe			ld (debug_mark+2),a  
3531 18 03			jr .pastdmark  
3533 ..			.dmark: db "ELS"  
3536 f1			.pastdmark: pop af  
3537			endm  
# End of macro DMARK
3537						CALLMONITOR 
3537 cd 6c fe			call debug_vector  
353a				endm  
# End of macro CALLMONITOR
353a					endif 
353a			 
353a			 
353a					NEXTW 
353a c3 b3 24			jp macro_next 
353d				endm 
# End of macro NEXTW
353d			.DO: 
353d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
353d 21				db WORD_SYS_CORE+13             
353e 64 36			dw .LOOP            
3540 03				db 2 + 1 
3541 .. 00			db "DO",0              
3544				endm 
# End of macro CWHEAD
3544			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3544			 
3544					if DEBUG_FORTH_WORDS_KEY 
3544						DMARK "DO." 
3544 f5				push af  
3545 3a 59 35			ld a, (.dmark)  
3548 32 68 fe			ld (debug_mark),a  
354b 3a 5a 35			ld a, (.dmark+1)  
354e 32 69 fe			ld (debug_mark+1),a  
3551 3a 5b 35			ld a, (.dmark+2)  
3554 32 6a fe			ld (debug_mark+2),a  
3557 18 03			jr .pastdmark  
3559 ..			.dmark: db "DO."  
355c f1			.pastdmark: pop af  
355d			endm  
# End of macro DMARK
355d						CALLMONITOR 
355d cd 6c fe			call debug_vector  
3560				endm  
# End of macro CALLMONITOR
3560					endif 
3560			;  push pc to rsp stack past the DO 
3560			 
3560 2a bf f4				ld hl, (os_tok_ptr) 
3563 23					inc hl   ; D 
3564 23					inc hl  ; O 
3565 23					inc hl   ; null 
3566					if DEBUG_FORTH_WORDS 
3566						DMARK "DO2" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 68 fe			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 69 fe			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 6a fe			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "DO2"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd 6c fe			call debug_vector  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582					FORTH_RSP_NEXT 
3582 cd ad 20			call macro_forth_rsp_next 
3585				endm 
# End of macro FORTH_RSP_NEXT
3585					if DEBUG_FORTH_WORDS 
3585						DMARK "DO3" 
3585 f5				push af  
3586 3a 9a 35			ld a, (.dmark)  
3589 32 68 fe			ld (debug_mark),a  
358c 3a 9b 35			ld a, (.dmark+1)  
358f 32 69 fe			ld (debug_mark+1),a  
3592 3a 9c 35			ld a, (.dmark+2)  
3595 32 6a fe			ld (debug_mark+2),a  
3598 18 03			jr .pastdmark  
359a ..			.dmark: db "DO3"  
359d f1			.pastdmark: pop af  
359e			endm  
# End of macro DMARK
359e						CALLMONITOR 
359e cd 6c fe			call debug_vector  
35a1				endm  
# End of macro CALLMONITOR
35a1					endif 
35a1			 
35a1					;if DEBUG_FORTH_WORDS 
35a1				;		push hl 
35a1			;		endif  
35a1			 
35a1			; get counters from data stack 
35a1			 
35a1			 
35a1					FORTH_DSP_VALUEHL 
35a1 cd fd 22			call macro_dsp_valuehl 
35a4				endm 
# End of macro FORTH_DSP_VALUEHL
35a4 e5					push hl		 ; hl now has starting counter which needs to be tos 
35a5			 
35a5					if DEBUG_FORTH_WORDS 
35a5						DMARK "DO4" 
35a5 f5				push af  
35a6 3a ba 35			ld a, (.dmark)  
35a9 32 68 fe			ld (debug_mark),a  
35ac 3a bb 35			ld a, (.dmark+1)  
35af 32 69 fe			ld (debug_mark+1),a  
35b2 3a bc 35			ld a, (.dmark+2)  
35b5 32 6a fe			ld (debug_mark+2),a  
35b8 18 03			jr .pastdmark  
35ba ..			.dmark: db "DO4"  
35bd f1			.pastdmark: pop af  
35be			endm  
# End of macro DMARK
35be						CALLMONITOR 
35be cd 6c fe			call debug_vector  
35c1				endm  
# End of macro CALLMONITOR
35c1					endif 
35c1					FORTH_DSP_POP 
35c1 cd b5 23			call macro_forth_dsp_pop 
35c4				endm 
# End of macro FORTH_DSP_POP
35c4			 
35c4					if DEBUG_FORTH_WORDS 
35c4						DMARK "DO5" 
35c4 f5				push af  
35c5 3a d9 35			ld a, (.dmark)  
35c8 32 68 fe			ld (debug_mark),a  
35cb 3a da 35			ld a, (.dmark+1)  
35ce 32 69 fe			ld (debug_mark+1),a  
35d1 3a db 35			ld a, (.dmark+2)  
35d4 32 6a fe			ld (debug_mark+2),a  
35d7 18 03			jr .pastdmark  
35d9 ..			.dmark: db "DO5"  
35dc f1			.pastdmark: pop af  
35dd			endm  
# End of macro DMARK
35dd						CALLMONITOR 
35dd cd 6c fe			call debug_vector  
35e0				endm  
# End of macro CALLMONITOR
35e0					endif 
35e0			 
35e0					FORTH_DSP_VALUEHL 
35e0 cd fd 22			call macro_dsp_valuehl 
35e3				endm 
# End of macro FORTH_DSP_VALUEHL
35e3			;		push hl		 ; hl now has starting limit counter 
35e3			 
35e3					if DEBUG_FORTH_WORDS 
35e3						DMARK "DO6" 
35e3 f5				push af  
35e4 3a f8 35			ld a, (.dmark)  
35e7 32 68 fe			ld (debug_mark),a  
35ea 3a f9 35			ld a, (.dmark+1)  
35ed 32 69 fe			ld (debug_mark+1),a  
35f0 3a fa 35			ld a, (.dmark+2)  
35f3 32 6a fe			ld (debug_mark+2),a  
35f6 18 03			jr .pastdmark  
35f8 ..			.dmark: db "DO6"  
35fb f1			.pastdmark: pop af  
35fc			endm  
# End of macro DMARK
35fc						CALLMONITOR 
35fc cd 6c fe			call debug_vector  
35ff				endm  
# End of macro CALLMONITOR
35ff					endif 
35ff					FORTH_DSP_POP 
35ff cd b5 23			call macro_forth_dsp_pop 
3602				endm 
# End of macro FORTH_DSP_POP
3602			 
3602			; put counters on the loop stack 
3602			 
3602			;		pop hl			 ; limit counter 
3602 d1					pop de			; start counter 
3603			 
3603					; push limit counter 
3603			 
3603					if DEBUG_FORTH_WORDS 
3603						DMARK "DO7" 
3603 f5				push af  
3604 3a 18 36			ld a, (.dmark)  
3607 32 68 fe			ld (debug_mark),a  
360a 3a 19 36			ld a, (.dmark+1)  
360d 32 69 fe			ld (debug_mark+1),a  
3610 3a 1a 36			ld a, (.dmark+2)  
3613 32 6a fe			ld (debug_mark+2),a  
3616 18 03			jr .pastdmark  
3618 ..			.dmark: db "DO7"  
361b f1			.pastdmark: pop af  
361c			endm  
# End of macro DMARK
361c						CALLMONITOR 
361c cd 6c fe			call debug_vector  
361f				endm  
# End of macro CALLMONITOR
361f					endif 
361f					FORTH_LOOP_NEXT 
361f cd 2e 23			call macro_forth_loop_next 
3622				endm 
# End of macro FORTH_LOOP_NEXT
3622			 
3622					; push start counter 
3622			 
3622 eb					ex de, hl 
3623					if DEBUG_FORTH_WORDS 
3623						DMARK "DO7" 
3623 f5				push af  
3624 3a 38 36			ld a, (.dmark)  
3627 32 68 fe			ld (debug_mark),a  
362a 3a 39 36			ld a, (.dmark+1)  
362d 32 69 fe			ld (debug_mark+1),a  
3630 3a 3a 36			ld a, (.dmark+2)  
3633 32 6a fe			ld (debug_mark+2),a  
3636 18 03			jr .pastdmark  
3638 ..			.dmark: db "DO7"  
363b f1			.pastdmark: pop af  
363c			endm  
# End of macro DMARK
363c						CALLMONITOR 
363c cd 6c fe			call debug_vector  
363f				endm  
# End of macro CALLMONITOR
363f					endif 
363f					FORTH_LOOP_NEXT 
363f cd 2e 23			call macro_forth_loop_next 
3642				endm 
# End of macro FORTH_LOOP_NEXT
3642			 
3642			 
3642					; init first round of I counter 
3642			 
3642 22 e3 f4				ld (os_current_i), hl 
3645			 
3645					if DEBUG_FORTH_WORDS 
3645						DMARK "DO8" 
3645 f5				push af  
3646 3a 5a 36			ld a, (.dmark)  
3649 32 68 fe			ld (debug_mark),a  
364c 3a 5b 36			ld a, (.dmark+1)  
364f 32 69 fe			ld (debug_mark+1),a  
3652 3a 5c 36			ld a, (.dmark+2)  
3655 32 6a fe			ld (debug_mark+2),a  
3658 18 03			jr .pastdmark  
365a ..			.dmark: db "DO8"  
365d f1			.pastdmark: pop af  
365e			endm  
# End of macro DMARK
365e						CALLMONITOR 
365e cd 6c fe			call debug_vector  
3661				endm  
# End of macro CALLMONITOR
3661					endif 
3661			 
3661					NEXTW 
3661 c3 b3 24			jp macro_next 
3664				endm 
# End of macro NEXTW
3664			.LOOP: 
3664				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3664 22				db WORD_SYS_CORE+14             
3665 7c 37			dw .I            
3667 05				db 4 + 1 
3668 .. 00			db "LOOP",0              
366d				endm 
# End of macro CWHEAD
366d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
366d			 
366d				; pop tos as current loop count to hl 
366d			 
366d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
366d			 
366d				FORTH_LOOP_TOS 
366d cd 61 23			call macro_forth_loop_tos 
3670				endm 
# End of macro FORTH_LOOP_TOS
3670 e5				push hl 
3671			 
3671					if DEBUG_FORTH_WORDS_KEY 
3671						DMARK "LOP" 
3671 f5				push af  
3672 3a 86 36			ld a, (.dmark)  
3675 32 68 fe			ld (debug_mark),a  
3678 3a 87 36			ld a, (.dmark+1)  
367b 32 69 fe			ld (debug_mark+1),a  
367e 3a 88 36			ld a, (.dmark+2)  
3681 32 6a fe			ld (debug_mark+2),a  
3684 18 03			jr .pastdmark  
3686 ..			.dmark: db "LOP"  
3689 f1			.pastdmark: pop af  
368a			endm  
# End of macro DMARK
368a						CALLMONITOR 
368a cd 6c fe			call debug_vector  
368d				endm  
# End of macro CALLMONITOR
368d					endif 
368d				; next item on the stack is the limit. get it 
368d			 
368d			 
368d				FORTH_LOOP_POP 
368d cd 6b 23			call macro_forth_loop_pop 
3690				endm 
# End of macro FORTH_LOOP_POP
3690			 
3690				FORTH_LOOP_TOS 
3690 cd 61 23			call macro_forth_loop_tos 
3693				endm 
# End of macro FORTH_LOOP_TOS
3693			 
3693 d1				pop de		 ; de = i, hl = limit 
3694			 
3694					if DEBUG_FORTH_WORDS 
3694						DMARK "LP1" 
3694 f5				push af  
3695 3a a9 36			ld a, (.dmark)  
3698 32 68 fe			ld (debug_mark),a  
369b 3a aa 36			ld a, (.dmark+1)  
369e 32 69 fe			ld (debug_mark+1),a  
36a1 3a ab 36			ld a, (.dmark+2)  
36a4 32 6a fe			ld (debug_mark+2),a  
36a7 18 03			jr .pastdmark  
36a9 ..			.dmark: db "LP1"  
36ac f1			.pastdmark: pop af  
36ad			endm  
# End of macro DMARK
36ad						CALLMONITOR 
36ad cd 6c fe			call debug_vector  
36b0				endm  
# End of macro CALLMONITOR
36b0					endif 
36b0			 
36b0				; go back to previous word 
36b0			 
36b0 d5				push de    ; save I for inc later 
36b1			 
36b1			 
36b1				; get limit 
36b1				;  is I at limit? 
36b1			 
36b1			 
36b1					if DEBUG_FORTH_WORDS 
36b1						DMARK "LP1" 
36b1 f5				push af  
36b2 3a c6 36			ld a, (.dmark)  
36b5 32 68 fe			ld (debug_mark),a  
36b8 3a c7 36			ld a, (.dmark+1)  
36bb 32 69 fe			ld (debug_mark+1),a  
36be 3a c8 36			ld a, (.dmark+2)  
36c1 32 6a fe			ld (debug_mark+2),a  
36c4 18 03			jr .pastdmark  
36c6 ..			.dmark: db "LP1"  
36c9 f1			.pastdmark: pop af  
36ca			endm  
# End of macro DMARK
36ca						CALLMONITOR 
36ca cd 6c fe			call debug_vector  
36cd				endm  
# End of macro CALLMONITOR
36cd					endif 
36cd			 
36cd ed 52			sbc hl, de 
36cf			 
36cf			 
36cf				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
36cf			 
36cf 20 26				jr nz, .loopnotdone 
36d1			 
36d1 e1				pop hl   ; get rid of saved I 
36d2				FORTH_LOOP_POP     ; get rid of limit 
36d2 cd 6b 23			call macro_forth_loop_pop 
36d5				endm 
# End of macro FORTH_LOOP_POP
36d5			 
36d5				FORTH_RSP_POP     ; get rid of DO ptr 
36d5 cd ce 20			call macro_forth_rsp_pop 
36d8				endm 
# End of macro FORTH_RSP_POP
36d8			 
36d8			if DEBUG_FORTH_WORDS 
36d8						DMARK "LP>" 
36d8 f5				push af  
36d9 3a ed 36			ld a, (.dmark)  
36dc 32 68 fe			ld (debug_mark),a  
36df 3a ee 36			ld a, (.dmark+1)  
36e2 32 69 fe			ld (debug_mark+1),a  
36e5 3a ef 36			ld a, (.dmark+2)  
36e8 32 6a fe			ld (debug_mark+2),a  
36eb 18 03			jr .pastdmark  
36ed ..			.dmark: db "LP>"  
36f0 f1			.pastdmark: pop af  
36f1			endm  
# End of macro DMARK
36f1				CALLMONITOR 
36f1 cd 6c fe			call debug_vector  
36f4				endm  
# End of macro CALLMONITOR
36f4			endif 
36f4			 
36f4					NEXTW 
36f4 c3 b3 24			jp macro_next 
36f7				endm 
# End of macro NEXTW
36f7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36f7			 
36f7			.loopnotdone: 
36f7			 
36f7 e1				pop hl    ; get I 
36f8 23				inc hl 
36f9			 
36f9			   	; save new I 
36f9			 
36f9			 
36f9					; set I counter 
36f9			 
36f9 22 e3 f4				ld (os_current_i), hl 
36fc			 
36fc					if DEBUG_FORTH_WORDS 
36fc						DMARK "LPN" 
36fc f5				push af  
36fd 3a 11 37			ld a, (.dmark)  
3700 32 68 fe			ld (debug_mark),a  
3703 3a 12 37			ld a, (.dmark+1)  
3706 32 69 fe			ld (debug_mark+1),a  
3709 3a 13 37			ld a, (.dmark+2)  
370c 32 6a fe			ld (debug_mark+2),a  
370f 18 03			jr .pastdmark  
3711 ..			.dmark: db "LPN"  
3714 f1			.pastdmark: pop af  
3715			endm  
# End of macro DMARK
3715					CALLMONITOR 
3715 cd 6c fe			call debug_vector  
3718				endm  
# End of macro CALLMONITOR
3718					endif 
3718					 
3718				FORTH_LOOP_NEXT 
3718 cd 2e 23			call macro_forth_loop_next 
371b				endm 
# End of macro FORTH_LOOP_NEXT
371b			 
371b			 
371b					if DEBUG_FORTH_WORDS 
371b eb						ex de,hl 
371c					endif 
371c			 
371c			;	; get DO ptr 
371c			; 
371c					if DEBUG_FORTH_WORDS 
371c						DMARK "LP7" 
371c f5				push af  
371d 3a 31 37			ld a, (.dmark)  
3720 32 68 fe			ld (debug_mark),a  
3723 3a 32 37			ld a, (.dmark+1)  
3726 32 69 fe			ld (debug_mark+1),a  
3729 3a 33 37			ld a, (.dmark+2)  
372c 32 6a fe			ld (debug_mark+2),a  
372f 18 03			jr .pastdmark  
3731 ..			.dmark: db "LP7"  
3734 f1			.pastdmark: pop af  
3735			endm  
# End of macro DMARK
3735					CALLMONITOR 
3735 cd 6c fe			call debug_vector  
3738				endm  
# End of macro CALLMONITOR
3738					endif 
3738				FORTH_RSP_TOS 
3738 cd c4 20			call macro_forth_rsp_tos 
373b				endm 
# End of macro FORTH_RSP_TOS
373b			 
373b					if DEBUG_FORTH_WORDS 
373b						DMARK "LP8" 
373b f5				push af  
373c 3a 50 37			ld a, (.dmark)  
373f 32 68 fe			ld (debug_mark),a  
3742 3a 51 37			ld a, (.dmark+1)  
3745 32 69 fe			ld (debug_mark+1),a  
3748 3a 52 37			ld a, (.dmark+2)  
374b 32 6a fe			ld (debug_mark+2),a  
374e 18 03			jr .pastdmark  
3750 ..			.dmark: db "LP8"  
3753 f1			.pastdmark: pop af  
3754			endm  
# End of macro DMARK
3754					CALLMONITOR 
3754 cd 6c fe			call debug_vector  
3757				endm  
# End of macro CALLMONITOR
3757					endif 
3757				;push hl 
3757			 
3757				; not going to DO any more 
3757				; get rid of the RSP pointer as DO will add it back in 
3757				;FORTH_RSP_POP 
3757				;pop hl 
3757			 
3757				;ld hl,(cli_ret_sp) 
3757				;ld e, (hl) 
3757				;inc hl 
3757				;ld d, (hl) 
3757				;ex de,hl 
3757 22 bf f4			ld (os_tok_ptr), hl 
375a					if DEBUG_FORTH_WORDS 
375a						DMARK "LP<" 
375a f5				push af  
375b 3a 6f 37			ld a, (.dmark)  
375e 32 68 fe			ld (debug_mark),a  
3761 3a 70 37			ld a, (.dmark+1)  
3764 32 69 fe			ld (debug_mark+1),a  
3767 3a 71 37			ld a, (.dmark+2)  
376a 32 6a fe			ld (debug_mark+2),a  
376d 18 03			jr .pastdmark  
376f ..			.dmark: db "LP<"  
3772 f1			.pastdmark: pop af  
3773			endm  
# End of macro DMARK
3773					CALLMONITOR 
3773 cd 6c fe			call debug_vector  
3776				endm  
# End of macro CALLMONITOR
3776				endif 
3776 c3 44 25			jp exec1 
3779			 
3779					 
3779			 
3779			 
3779					NEXTW 
3779 c3 b3 24			jp macro_next 
377c				endm 
# End of macro NEXTW
377c			.I:  
377c			 
377c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
377c 5e				db WORD_SYS_CORE+74             
377d a7 37			dw .DLOOP            
377f 02				db 1 + 1 
3780 .. 00			db "I",0              
3782				endm 
# End of macro CWHEAD
3782			; | I ( -- ) Current loop counter | DONE 
3782					if DEBUG_FORTH_WORDS_KEY 
3782						DMARK "I.." 
3782 f5				push af  
3783 3a 97 37			ld a, (.dmark)  
3786 32 68 fe			ld (debug_mark),a  
3789 3a 98 37			ld a, (.dmark+1)  
378c 32 69 fe			ld (debug_mark+1),a  
378f 3a 99 37			ld a, (.dmark+2)  
3792 32 6a fe			ld (debug_mark+2),a  
3795 18 03			jr .pastdmark  
3797 ..			.dmark: db "I.."  
379a f1			.pastdmark: pop af  
379b			endm  
# End of macro DMARK
379b						CALLMONITOR 
379b cd 6c fe			call debug_vector  
379e				endm  
# End of macro CALLMONITOR
379e					endif 
379e			 
379e 2a e3 f4				ld hl,(os_current_i) 
37a1 cd 06 21				call forth_push_numhl 
37a4			 
37a4					NEXTW 
37a4 c3 b3 24			jp macro_next 
37a7				endm 
# End of macro NEXTW
37a7			.DLOOP: 
37a7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37a7 5f				db WORD_SYS_CORE+75             
37a8 88 38			dw .REPEAT            
37aa 06				db 5 + 1 
37ab .. 00			db "-LOOP",0              
37b1				endm 
# End of macro CWHEAD
37b1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37b1				; pop tos as current loop count to hl 
37b1					if DEBUG_FORTH_WORDS_KEY 
37b1						DMARK "-LP" 
37b1 f5				push af  
37b2 3a c6 37			ld a, (.dmark)  
37b5 32 68 fe			ld (debug_mark),a  
37b8 3a c7 37			ld a, (.dmark+1)  
37bb 32 69 fe			ld (debug_mark+1),a  
37be 3a c8 37			ld a, (.dmark+2)  
37c1 32 6a fe			ld (debug_mark+2),a  
37c4 18 03			jr .pastdmark  
37c6 ..			.dmark: db "-LP"  
37c9 f1			.pastdmark: pop af  
37ca			endm  
# End of macro DMARK
37ca						CALLMONITOR 
37ca cd 6c fe			call debug_vector  
37cd				endm  
# End of macro CALLMONITOR
37cd					endif 
37cd			 
37cd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37cd			 
37cd				FORTH_LOOP_TOS 
37cd cd 61 23			call macro_forth_loop_tos 
37d0				endm 
# End of macro FORTH_LOOP_TOS
37d0 e5				push hl 
37d1			 
37d1					if DEBUG_FORTH_WORDS 
37d1						DMARK "-LP" 
37d1 f5				push af  
37d2 3a e6 37			ld a, (.dmark)  
37d5 32 68 fe			ld (debug_mark),a  
37d8 3a e7 37			ld a, (.dmark+1)  
37db 32 69 fe			ld (debug_mark+1),a  
37de 3a e8 37			ld a, (.dmark+2)  
37e1 32 6a fe			ld (debug_mark+2),a  
37e4 18 03			jr .pastdmark  
37e6 ..			.dmark: db "-LP"  
37e9 f1			.pastdmark: pop af  
37ea			endm  
# End of macro DMARK
37ea						CALLMONITOR 
37ea cd 6c fe			call debug_vector  
37ed				endm  
# End of macro CALLMONITOR
37ed					endif 
37ed				; next item on the stack is the limit. get it 
37ed			 
37ed			 
37ed				FORTH_LOOP_POP 
37ed cd 6b 23			call macro_forth_loop_pop 
37f0				endm 
# End of macro FORTH_LOOP_POP
37f0			 
37f0				FORTH_LOOP_TOS 
37f0 cd 61 23			call macro_forth_loop_tos 
37f3				endm 
# End of macro FORTH_LOOP_TOS
37f3			 
37f3 d1				pop de		 ; de = i, hl = limit 
37f4			 
37f4					if DEBUG_FORTH_WORDS 
37f4						DMARK "-L1" 
37f4 f5				push af  
37f5 3a 09 38			ld a, (.dmark)  
37f8 32 68 fe			ld (debug_mark),a  
37fb 3a 0a 38			ld a, (.dmark+1)  
37fe 32 69 fe			ld (debug_mark+1),a  
3801 3a 0b 38			ld a, (.dmark+2)  
3804 32 6a fe			ld (debug_mark+2),a  
3807 18 03			jr .pastdmark  
3809 ..			.dmark: db "-L1"  
380c f1			.pastdmark: pop af  
380d			endm  
# End of macro DMARK
380d						CALLMONITOR 
380d cd 6c fe			call debug_vector  
3810				endm  
# End of macro CALLMONITOR
3810					endif 
3810			 
3810				; go back to previous word 
3810			 
3810 d5				push de    ; save I for inc later 
3811			 
3811			 
3811				; get limit 
3811				;  is I at limit? 
3811			 
3811			 
3811					if DEBUG_FORTH_WORDS 
3811						DMARK "-L1" 
3811 f5				push af  
3812 3a 26 38			ld a, (.dmark)  
3815 32 68 fe			ld (debug_mark),a  
3818 3a 27 38			ld a, (.dmark+1)  
381b 32 69 fe			ld (debug_mark+1),a  
381e 3a 28 38			ld a, (.dmark+2)  
3821 32 6a fe			ld (debug_mark+2),a  
3824 18 03			jr .pastdmark  
3826 ..			.dmark: db "-L1"  
3829 f1			.pastdmark: pop af  
382a			endm  
# End of macro DMARK
382a						CALLMONITOR 
382a cd 6c fe			call debug_vector  
382d				endm  
# End of macro CALLMONITOR
382d					endif 
382d			 
382d ed 52			sbc hl, de 
382f			 
382f			 
382f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
382f			 
382f 20 26				jr nz, .mloopnotdone 
3831			 
3831 e1				pop hl   ; get rid of saved I 
3832				FORTH_LOOP_POP     ; get rid of limit 
3832 cd 6b 23			call macro_forth_loop_pop 
3835				endm 
# End of macro FORTH_LOOP_POP
3835			 
3835				FORTH_RSP_POP     ; get rid of DO ptr 
3835 cd ce 20			call macro_forth_rsp_pop 
3838				endm 
# End of macro FORTH_RSP_POP
3838			 
3838			if DEBUG_FORTH_WORDS 
3838						DMARK "-L>" 
3838 f5				push af  
3839 3a 4d 38			ld a, (.dmark)  
383c 32 68 fe			ld (debug_mark),a  
383f 3a 4e 38			ld a, (.dmark+1)  
3842 32 69 fe			ld (debug_mark+1),a  
3845 3a 4f 38			ld a, (.dmark+2)  
3848 32 6a fe			ld (debug_mark+2),a  
384b 18 03			jr .pastdmark  
384d ..			.dmark: db "-L>"  
3850 f1			.pastdmark: pop af  
3851			endm  
# End of macro DMARK
3851				CALLMONITOR 
3851 cd 6c fe			call debug_vector  
3854				endm  
# End of macro CALLMONITOR
3854			endif 
3854			 
3854					NEXTW 
3854 c3 b3 24			jp macro_next 
3857				endm 
# End of macro NEXTW
3857				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3857			 
3857			.mloopnotdone: 
3857			 
3857 e1				pop hl    ; get I 
3858 2b				dec hl 
3859			 
3859			   	; save new I 
3859			 
3859			 
3859					; set I counter 
3859			 
3859 22 e3 f4				ld (os_current_i), hl 
385c			 
385c					 
385c				FORTH_LOOP_NEXT 
385c cd 2e 23			call macro_forth_loop_next 
385f				endm 
# End of macro FORTH_LOOP_NEXT
385f			 
385f			 
385f					if DEBUG_FORTH_WORDS 
385f eb						ex de,hl 
3860					endif 
3860			 
3860			;	; get DO ptr 
3860			; 
3860				FORTH_RSP_TOS 
3860 cd c4 20			call macro_forth_rsp_tos 
3863				endm 
# End of macro FORTH_RSP_TOS
3863			 
3863				;push hl 
3863			 
3863				; not going to DO any more 
3863				; get rid of the RSP pointer as DO will add it back in 
3863				;FORTH_RSP_POP 
3863				;pop hl 
3863			 
3863			 
3863 22 bf f4			ld (os_tok_ptr), hl 
3866					if DEBUG_FORTH_WORDS 
3866						DMARK "-L<" 
3866 f5				push af  
3867 3a 7b 38			ld a, (.dmark)  
386a 32 68 fe			ld (debug_mark),a  
386d 3a 7c 38			ld a, (.dmark+1)  
3870 32 69 fe			ld (debug_mark+1),a  
3873 3a 7d 38			ld a, (.dmark+2)  
3876 32 6a fe			ld (debug_mark+2),a  
3879 18 03			jr .pastdmark  
387b ..			.dmark: db "-L<"  
387e f1			.pastdmark: pop af  
387f			endm  
# End of macro DMARK
387f					CALLMONITOR 
387f cd 6c fe			call debug_vector  
3882				endm  
# End of macro CALLMONITOR
3882				endif 
3882 c3 44 25			jp exec1 
3885			 
3885					 
3885			 
3885			 
3885			 
3885				NEXTW 
3885 c3 b3 24			jp macro_next 
3888				endm 
# End of macro NEXTW
3888			 
3888			 
3888			 
3888			 
3888			.REPEAT: 
3888				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3888 71				db WORD_SYS_CORE+93             
3889 db 38			dw .UNTIL            
388b 06				db 5 + 1 
388c .. 00			db "REPEAT",0              
3893				endm 
# End of macro CWHEAD
3893			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3893			;  push pc to rsp stack past the REPEAT 
3893					if DEBUG_FORTH_WORDS_KEY 
3893						DMARK "REP" 
3893 f5				push af  
3894 3a a8 38			ld a, (.dmark)  
3897 32 68 fe			ld (debug_mark),a  
389a 3a a9 38			ld a, (.dmark+1)  
389d 32 69 fe			ld (debug_mark+1),a  
38a0 3a aa 38			ld a, (.dmark+2)  
38a3 32 6a fe			ld (debug_mark+2),a  
38a6 18 03			jr .pastdmark  
38a8 ..			.dmark: db "REP"  
38ab f1			.pastdmark: pop af  
38ac			endm  
# End of macro DMARK
38ac						CALLMONITOR 
38ac cd 6c fe			call debug_vector  
38af				endm  
# End of macro CALLMONITOR
38af					endif 
38af			 
38af 2a bf f4				ld hl, (os_tok_ptr) 
38b2 23					inc hl   ; R 
38b3 23					inc hl  ; E 
38b4 23					inc hl   ; P 
38b5 23					inc hl   ; E 
38b6 23					inc hl   ; A 
38b7 23					inc hl   ; T 
38b8 23					inc hl   ; zero 
38b9					FORTH_RSP_NEXT 
38b9 cd ad 20			call macro_forth_rsp_next 
38bc				endm 
# End of macro FORTH_RSP_NEXT
38bc			 
38bc			 
38bc					if DEBUG_FORTH_WORDS 
38bc						DMARK "REP" 
38bc f5				push af  
38bd 3a d1 38			ld a, (.dmark)  
38c0 32 68 fe			ld (debug_mark),a  
38c3 3a d2 38			ld a, (.dmark+1)  
38c6 32 69 fe			ld (debug_mark+1),a  
38c9 3a d3 38			ld a, (.dmark+2)  
38cc 32 6a fe			ld (debug_mark+2),a  
38cf 18 03			jr .pastdmark  
38d1 ..			.dmark: db "REP"  
38d4 f1			.pastdmark: pop af  
38d5			endm  
# End of macro DMARK
38d5						;pop bc    ; TODO BUG ?????? what is this for???? 
38d5						CALLMONITOR 
38d5 cd 6c fe			call debug_vector  
38d8				endm  
# End of macro CALLMONITOR
38d8					endif 
38d8			 
38d8					NEXTW 
38d8 c3 b3 24			jp macro_next 
38db				endm 
# End of macro NEXTW
38db			;	       NEXTW 
38db			 
38db			.UNTIL: 
38db				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
38db 72				db WORD_SYS_CORE+94             
38dc 72 39			dw .ENDFLOW            
38de 06				db 5 + 1 
38df .. 00			db "UNTIL",0              
38e5				endm 
# End of macro CWHEAD
38e5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
38e5			 
38e5				; pop tos as check 
38e5			 
38e5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38e5			 
38e5				FORTH_DSP_VALUEHL 
38e5 cd fd 22			call macro_dsp_valuehl 
38e8				endm 
# End of macro FORTH_DSP_VALUEHL
38e8			 
38e8					if DEBUG_FORTH_WORDS_KEY 
38e8						DMARK "UNT" 
38e8 f5				push af  
38e9 3a fd 38			ld a, (.dmark)  
38ec 32 68 fe			ld (debug_mark),a  
38ef 3a fe 38			ld a, (.dmark+1)  
38f2 32 69 fe			ld (debug_mark+1),a  
38f5 3a ff 38			ld a, (.dmark+2)  
38f8 32 6a fe			ld (debug_mark+2),a  
38fb 18 03			jr .pastdmark  
38fd ..			.dmark: db "UNT"  
3900 f1			.pastdmark: pop af  
3901			endm  
# End of macro DMARK
3901						CALLMONITOR 
3901 cd 6c fe			call debug_vector  
3904				endm  
# End of macro CALLMONITOR
3904					endif 
3904			 
3904			;	push hl 
3904				FORTH_DSP_POP 
3904 cd b5 23			call macro_forth_dsp_pop 
3907				endm 
# End of macro FORTH_DSP_POP
3907			 
3907			;	pop hl 
3907			 
3907				; test if true 
3907			 
3907 cd f9 0f			call ishlzero 
390a			;	ld a,l 
390a			;	add h 
390a			; 
390a			;	cp 0 
390a			 
390a 20 3e			jr nz, .untilnotdone 
390c			 
390c					if DEBUG_FORTH_WORDS 
390c						DMARK "UNf" 
390c f5				push af  
390d 3a 21 39			ld a, (.dmark)  
3910 32 68 fe			ld (debug_mark),a  
3913 3a 22 39			ld a, (.dmark+1)  
3916 32 69 fe			ld (debug_mark+1),a  
3919 3a 23 39			ld a, (.dmark+2)  
391c 32 6a fe			ld (debug_mark+2),a  
391f 18 03			jr .pastdmark  
3921 ..			.dmark: db "UNf"  
3924 f1			.pastdmark: pop af  
3925			endm  
# End of macro DMARK
3925						CALLMONITOR 
3925 cd 6c fe			call debug_vector  
3928				endm  
# End of macro CALLMONITOR
3928					endif 
3928			 
3928			 
3928			 
3928				FORTH_RSP_POP     ; get rid of DO ptr 
3928 cd ce 20			call macro_forth_rsp_pop 
392b				endm 
# End of macro FORTH_RSP_POP
392b			 
392b			if DEBUG_FORTH_WORDS 
392b						DMARK "UN>" 
392b f5				push af  
392c 3a 40 39			ld a, (.dmark)  
392f 32 68 fe			ld (debug_mark),a  
3932 3a 41 39			ld a, (.dmark+1)  
3935 32 69 fe			ld (debug_mark+1),a  
3938 3a 42 39			ld a, (.dmark+2)  
393b 32 6a fe			ld (debug_mark+2),a  
393e 18 03			jr .pastdmark  
3940 ..			.dmark: db "UN>"  
3943 f1			.pastdmark: pop af  
3944			endm  
# End of macro DMARK
3944				CALLMONITOR 
3944 cd 6c fe			call debug_vector  
3947				endm  
# End of macro CALLMONITOR
3947			endif 
3947			 
3947					NEXTW 
3947 c3 b3 24			jp macro_next 
394a				endm 
# End of macro NEXTW
394a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
394a			 
394a			.untilnotdone: 
394a			 
394a			 
394a			;	; get DO ptr 
394a			; 
394a				FORTH_RSP_TOS 
394a cd c4 20			call macro_forth_rsp_tos 
394d				endm 
# End of macro FORTH_RSP_TOS
394d			 
394d				;push hl 
394d			 
394d				; not going to DO any more 
394d				; get rid of the RSP pointer as DO will add it back in 
394d				;FORTH_RSP_POP 
394d				;pop hl 
394d			 
394d			 
394d 22 bf f4			ld (os_tok_ptr), hl 
3950					if DEBUG_FORTH_WORDS 
3950						DMARK "UN<" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 68 fe			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 69 fe			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 6a fe			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "UN<"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969					CALLMONITOR 
3969 cd 6c fe			call debug_vector  
396c				endm  
# End of macro CALLMONITOR
396c				endif 
396c c3 44 25			jp exec1 
396f			 
396f					 
396f			 
396f			 
396f					NEXTW 
396f c3 b3 24			jp macro_next 
3972				endm 
# End of macro NEXTW
3972			 
3972			 
3972			.ENDFLOW: 
3972			 
3972			; eof 
3972			 
# End of file forth_words_flow.asm
3972			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3972			include "forth_words_logic.asm" 
3972			 
3972			; | ## Logic Words 
3972			 
3972			.NOT: 
3972				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3972 2d				db WORD_SYS_CORE+25             
3973 ba 39			dw .IS            
3975 04				db 3 + 1 
3976 .. 00			db "NOT",0              
397a				endm 
# End of macro CWHEAD
397a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
397a					if DEBUG_FORTH_WORDS_KEY 
397a						DMARK "NOT" 
397a f5				push af  
397b 3a 8f 39			ld a, (.dmark)  
397e 32 68 fe			ld (debug_mark),a  
3981 3a 90 39			ld a, (.dmark+1)  
3984 32 69 fe			ld (debug_mark+1),a  
3987 3a 91 39			ld a, (.dmark+2)  
398a 32 6a fe			ld (debug_mark+2),a  
398d 18 03			jr .pastdmark  
398f ..			.dmark: db "NOT"  
3992 f1			.pastdmark: pop af  
3993			endm  
# End of macro DMARK
3993						CALLMONITOR 
3993 cd 6c fe			call debug_vector  
3996				endm  
# End of macro CALLMONITOR
3996					endif 
3996					FORTH_DSP 
3996 cd c3 22			call macro_forth_dsp 
3999				endm 
# End of macro FORTH_DSP
3999 7e					ld a,(hl)	; get type of value on TOS 
399a fe 02				cp DS_TYPE_INUM  
399c 28 03				jr z, .noti 
399e					NEXTW 
399e c3 b3 24			jp macro_next 
39a1				endm 
# End of macro NEXTW
39a1			.noti:          FORTH_DSP_VALUEHL 
39a1 cd fd 22			call macro_dsp_valuehl 
39a4				endm 
# End of macro FORTH_DSP_VALUEHL
39a4			;		push hl 
39a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a4 cd b5 23			call macro_forth_dsp_pop 
39a7				endm 
# End of macro FORTH_DSP_POP
39a7			;		pop hl 
39a7 3e 00				ld a,0 
39a9 bd					cp l 
39aa 28 04				jr z, .not2t 
39ac 2e 00				ld l, 0 
39ae 18 02				jr .notip 
39b0			 
39b0 2e ff		.not2t:		ld l, 255 
39b2			 
39b2 26 00		.notip:		ld h, 0	 
39b4			 
39b4 cd 06 21				call forth_push_numhl 
39b7					NEXTW 
39b7 c3 b3 24			jp macro_next 
39ba				endm 
# End of macro NEXTW
39ba			 
39ba			.IS: 
39ba				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39ba 2d				db WORD_SYS_CORE+25             
39bb e0 39			dw .LZERO            
39bd 03				db 2 + 1 
39be .. 00			db "IS",0              
39c1				endm 
# End of macro CWHEAD
39c1			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
39c1					if DEBUG_FORTH_WORDS_KEY 
39c1						DMARK "IS." 
39c1 f5				push af  
39c2 3a d6 39			ld a, (.dmark)  
39c5 32 68 fe			ld (debug_mark),a  
39c8 3a d7 39			ld a, (.dmark+1)  
39cb 32 69 fe			ld (debug_mark+1),a  
39ce 3a d8 39			ld a, (.dmark+2)  
39d1 32 6a fe			ld (debug_mark+2),a  
39d4 18 03			jr .pastdmark  
39d6 ..			.dmark: db "IS."  
39d9 f1			.pastdmark: pop af  
39da			endm  
# End of macro DMARK
39da						CALLMONITOR 
39da cd 6c fe			call debug_vector  
39dd				endm  
# End of macro CALLMONITOR
39dd					endif 
39dd					NEXTW 
39dd c3 b3 24			jp macro_next 
39e0				endm 
# End of macro NEXTW
39e0			.LZERO: 
39e0				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
39e0 2d				db WORD_SYS_CORE+25             
39e1 ea 39			dw .TZERO            
39e3 03				db 2 + 1 
39e4 .. 00			db "0<",0              
39e7				endm 
# End of macro CWHEAD
39e7			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
39e7					NEXTW 
39e7 c3 b3 24			jp macro_next 
39ea				endm 
# End of macro NEXTW
39ea			.TZERO: 
39ea				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
39ea 2e				db WORD_SYS_CORE+26             
39eb 31 3a			dw .LESS            
39ed 03				db 2 + 1 
39ee .. 00			db "0=",0              
39f1				endm 
# End of macro CWHEAD
39f1			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
39f1				; TODO add floating point number detection 
39f1					;v5 FORTH_DSP_VALUE 
39f1					if DEBUG_FORTH_WORDS_KEY 
39f1						DMARK "0=." 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 68 fe			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 69 fe			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 6a fe			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "0=."  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a						CALLMONITOR 
3a0a cd 6c fe			call debug_vector  
3a0d				endm  
# End of macro CALLMONITOR
3a0d					endif 
3a0d					FORTH_DSP 
3a0d cd c3 22			call macro_forth_dsp 
3a10				endm 
# End of macro FORTH_DSP
3a10 7e					ld a,(hl)	; get type of value on TOS 
3a11 fe 02				cp DS_TYPE_INUM  
3a13 28 00				jr z, .tz_inum 
3a15			 
3a15				if FORTH_ENABLE_FLOATMATH 
3a15					jr .tz_done 
3a15			 
3a15				endif 
3a15					 
3a15			 
3a15			.tz_inum: 
3a15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a15 cd fd 22			call macro_dsp_valuehl 
3a18				endm 
# End of macro FORTH_DSP_VALUEHL
3a18			 
3a18			;		push hl 
3a18			 
3a18					; destroy value TOS 
3a18			 
3a18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a18 cd b5 23			call macro_forth_dsp_pop 
3a1b				endm 
# End of macro FORTH_DSP_POP
3a1b			 
3a1b			;		pop hl 
3a1b			 
3a1b 3e 00				ld a,0 
3a1d			 
3a1d bd					cp l 
3a1e 20 08				jr nz, .tz_notzero 
3a20			 
3a20 bc					cp h 
3a21			 
3a21 20 05				jr nz, .tz_notzero 
3a23			 
3a23			 
3a23 21 01 00				ld hl, FORTH_TRUE 
3a26 18 03				jr .tz_done 
3a28			 
3a28 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a2b			 
3a2b					; push value back onto stack for another op etc 
3a2b			 
3a2b			.tz_done: 
3a2b cd 06 21				call forth_push_numhl 
3a2e			 
3a2e					NEXTW 
3a2e c3 b3 24			jp macro_next 
3a31				endm 
# End of macro NEXTW
3a31			.LESS: 
3a31				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a31 2f				db WORD_SYS_CORE+27             
3a32 9a 3a			dw .GT            
3a34 02				db 1 + 1 
3a35 .. 00			db "<",0              
3a37				endm 
# End of macro CWHEAD
3a37			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a37				; TODO add floating point number detection 
3a37					if DEBUG_FORTH_WORDS_KEY 
3a37						DMARK "LES" 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 68 fe			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 69 fe			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 6a fe			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "LES"  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50						CALLMONITOR 
3a50 cd 6c fe			call debug_vector  
3a53				endm  
# End of macro CALLMONITOR
3a53					endif 
3a53					FORTH_DSP 
3a53 cd c3 22			call macro_forth_dsp 
3a56				endm 
# End of macro FORTH_DSP
3a56					;v5 FORTH_DSP_VALUE 
3a56 7e					ld a,(hl)	; get type of value on TOS 
3a57 fe 02				cp DS_TYPE_INUM  
3a59 28 00				jr z, .less_inum 
3a5b			 
3a5b				if FORTH_ENABLE_FLOATMATH 
3a5b					jr .less_done 
3a5b			 
3a5b				endif 
3a5b					 
3a5b			 
3a5b			.less_inum: 
3a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5b cd fd 22			call macro_dsp_valuehl 
3a5e				endm 
# End of macro FORTH_DSP_VALUEHL
3a5e			 
3a5e e5					push hl  ; u2 
3a5f			 
3a5f					; destroy value TOS 
3a5f			 
3a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5f cd b5 23			call macro_forth_dsp_pop 
3a62				endm 
# End of macro FORTH_DSP_POP
3a62			 
3a62			 
3a62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a62 cd fd 22			call macro_dsp_valuehl 
3a65				endm 
# End of macro FORTH_DSP_VALUEHL
3a65			 
3a65 e5					push hl    ; u1 
3a66			 
3a66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a66 cd b5 23			call macro_forth_dsp_pop 
3a69				endm 
# End of macro FORTH_DSP_POP
3a69			 
3a69			 
3a69 b7			 or a      ;clear carry flag 
3a6a 01 00 00		 ld bc, FORTH_FALSE 
3a6d e1			  pop hl    ; u1 
3a6e d1			  pop de    ; u2 
3a6f ed 52		  sbc hl,de 
3a71 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a73			 
3a73 01 01 00		 ld bc, FORTH_TRUE 
3a76			.lscont:  
3a76 c5					push bc 
3a77 e1					pop hl 
3a78			 
3a78					if DEBUG_FORTH_WORDS 
3a78						DMARK "LT1" 
3a78 f5				push af  
3a79 3a 8d 3a			ld a, (.dmark)  
3a7c 32 68 fe			ld (debug_mark),a  
3a7f 3a 8e 3a			ld a, (.dmark+1)  
3a82 32 69 fe			ld (debug_mark+1),a  
3a85 3a 8f 3a			ld a, (.dmark+2)  
3a88 32 6a fe			ld (debug_mark+2),a  
3a8b 18 03			jr .pastdmark  
3a8d ..			.dmark: db "LT1"  
3a90 f1			.pastdmark: pop af  
3a91			endm  
# End of macro DMARK
3a91						CALLMONITOR 
3a91 cd 6c fe			call debug_vector  
3a94				endm  
# End of macro CALLMONITOR
3a94					endif 
3a94 cd 06 21				call forth_push_numhl 
3a97			 
3a97					NEXTW 
3a97 c3 b3 24			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			.GT: 
3a9a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a9a 30				db WORD_SYS_CORE+28             
3a9b 03 3b			dw .EQUAL            
3a9d 02				db 1 + 1 
3a9e .. 00			db ">",0              
3aa0				endm 
# End of macro CWHEAD
3aa0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3aa0				; TODO add floating point number detection 
3aa0					if DEBUG_FORTH_WORDS_KEY 
3aa0						DMARK "GRT" 
3aa0 f5				push af  
3aa1 3a b5 3a			ld a, (.dmark)  
3aa4 32 68 fe			ld (debug_mark),a  
3aa7 3a b6 3a			ld a, (.dmark+1)  
3aaa 32 69 fe			ld (debug_mark+1),a  
3aad 3a b7 3a			ld a, (.dmark+2)  
3ab0 32 6a fe			ld (debug_mark+2),a  
3ab3 18 03			jr .pastdmark  
3ab5 ..			.dmark: db "GRT"  
3ab8 f1			.pastdmark: pop af  
3ab9			endm  
# End of macro DMARK
3ab9						CALLMONITOR 
3ab9 cd 6c fe			call debug_vector  
3abc				endm  
# End of macro CALLMONITOR
3abc					endif 
3abc					FORTH_DSP 
3abc cd c3 22			call macro_forth_dsp 
3abf				endm 
# End of macro FORTH_DSP
3abf					;FORTH_DSP_VALUE 
3abf 7e					ld a,(hl)	; get type of value on TOS 
3ac0 fe 02				cp DS_TYPE_INUM  
3ac2 28 00				jr z, .gt_inum 
3ac4			 
3ac4				if FORTH_ENABLE_FLOATMATH 
3ac4					jr .gt_done 
3ac4			 
3ac4				endif 
3ac4					 
3ac4			 
3ac4			.gt_inum: 
3ac4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac4 cd fd 22			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 e5					push hl  ; u2 
3ac8			 
3ac8					; destroy value TOS 
3ac8			 
3ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac8 cd b5 23			call macro_forth_dsp_pop 
3acb				endm 
# End of macro FORTH_DSP_POP
3acb			 
3acb			 
3acb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3acb cd fd 22			call macro_dsp_valuehl 
3ace				endm 
# End of macro FORTH_DSP_VALUEHL
3ace			 
3ace e5					push hl    ; u1 
3acf			 
3acf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3acf cd b5 23			call macro_forth_dsp_pop 
3ad2				endm 
# End of macro FORTH_DSP_POP
3ad2			 
3ad2			 
3ad2 b7			 or a      ;clear carry flag 
3ad3 01 00 00		 ld bc, FORTH_FALSE 
3ad6 e1			  pop hl    ; u1 
3ad7 d1			  pop de    ; u2 
3ad8 ed 52		  sbc hl,de 
3ada 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3adc			 
3adc 01 01 00		 ld bc, FORTH_TRUE 
3adf			.gtcont:  
3adf c5					push bc 
3ae0 e1					pop hl 
3ae1			 
3ae1					if DEBUG_FORTH_WORDS 
3ae1						DMARK "GT1" 
3ae1 f5				push af  
3ae2 3a f6 3a			ld a, (.dmark)  
3ae5 32 68 fe			ld (debug_mark),a  
3ae8 3a f7 3a			ld a, (.dmark+1)  
3aeb 32 69 fe			ld (debug_mark+1),a  
3aee 3a f8 3a			ld a, (.dmark+2)  
3af1 32 6a fe			ld (debug_mark+2),a  
3af4 18 03			jr .pastdmark  
3af6 ..			.dmark: db "GT1"  
3af9 f1			.pastdmark: pop af  
3afa			endm  
# End of macro DMARK
3afa						CALLMONITOR 
3afa cd 6c fe			call debug_vector  
3afd				endm  
# End of macro CALLMONITOR
3afd					endif 
3afd cd 06 21				call forth_push_numhl 
3b00			 
3b00					NEXTW 
3b00 c3 b3 24			jp macro_next 
3b03				endm 
# End of macro NEXTW
3b03			.EQUAL: 
3b03				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b03 31				db WORD_SYS_CORE+29             
3b04 6e 3b			dw .ENDLOGIC            
3b06 02				db 1 + 1 
3b07 .. 00			db "=",0              
3b09				endm 
# End of macro CWHEAD
3b09			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b09				; TODO add floating point number detection 
3b09					if DEBUG_FORTH_WORDS_KEY 
3b09						DMARK "EQ." 
3b09 f5				push af  
3b0a 3a 1e 3b			ld a, (.dmark)  
3b0d 32 68 fe			ld (debug_mark),a  
3b10 3a 1f 3b			ld a, (.dmark+1)  
3b13 32 69 fe			ld (debug_mark+1),a  
3b16 3a 20 3b			ld a, (.dmark+2)  
3b19 32 6a fe			ld (debug_mark+2),a  
3b1c 18 03			jr .pastdmark  
3b1e ..			.dmark: db "EQ."  
3b21 f1			.pastdmark: pop af  
3b22			endm  
# End of macro DMARK
3b22						CALLMONITOR 
3b22 cd 6c fe			call debug_vector  
3b25				endm  
# End of macro CALLMONITOR
3b25					endif 
3b25					FORTH_DSP 
3b25 cd c3 22			call macro_forth_dsp 
3b28				endm 
# End of macro FORTH_DSP
3b28					;v5 FORTH_DSP_VALUE 
3b28 7e					ld a,(hl)	; get type of value on TOS 
3b29 fe 02				cp DS_TYPE_INUM  
3b2b 28 00				jr z, .eq_inum 
3b2d			 
3b2d				if FORTH_ENABLE_FLOATMATH 
3b2d					jr .eq_done 
3b2d			 
3b2d				endif 
3b2d					 
3b2d			 
3b2d			.eq_inum: 
3b2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2d cd fd 22			call macro_dsp_valuehl 
3b30				endm 
# End of macro FORTH_DSP_VALUEHL
3b30			 
3b30 e5					push hl 
3b31			 
3b31					; destroy value TOS 
3b31			 
3b31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b31 cd b5 23			call macro_forth_dsp_pop 
3b34				endm 
# End of macro FORTH_DSP_POP
3b34			 
3b34			 
3b34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b34 cd fd 22			call macro_dsp_valuehl 
3b37				endm 
# End of macro FORTH_DSP_VALUEHL
3b37			 
3b37					; one value on hl get other one back 
3b37			 
3b37 e5					push hl 
3b38			 
3b38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b38 cd b5 23			call macro_forth_dsp_pop 
3b3b				endm 
# End of macro FORTH_DSP_POP
3b3b			 
3b3b 0e 00				ld c, FORTH_FALSE 
3b3d			 
3b3d e1					pop hl 
3b3e d1					pop de 
3b3f			 
3b3f 7b					ld a, e 
3b40 bd					cp l 
3b41			 
3b41 20 06				jr nz, .eq_done 
3b43			 
3b43 7a					ld a, d 
3b44 bc					cp h 
3b45			 
3b45 20 02				jr nz, .eq_done 
3b47			 
3b47 0e 01				ld c, FORTH_TRUE 
3b49					 
3b49			 
3b49			 
3b49			.eq_done: 
3b49			 
3b49					; TODO push value back onto stack for another op etc 
3b49			 
3b49 26 00				ld h, 0 
3b4b 69					ld l, c 
3b4c					if DEBUG_FORTH_WORDS 
3b4c						DMARK "EQ1" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 68 fe			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 69 fe			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 6a fe			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "EQ1"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd 6c fe			call debug_vector  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68 cd 06 21				call forth_push_numhl 
3b6b			 
3b6b					NEXTW 
3b6b c3 b3 24			jp macro_next 
3b6e				endm 
# End of macro NEXTW
3b6e			 
3b6e			 
3b6e			.ENDLOGIC: 
3b6e			; eof 
3b6e			 
3b6e			 
# End of file forth_words_logic.asm
3b6e			include "forth_words_maths.asm" 
3b6e			 
3b6e			; | ## Maths Words 
3b6e			 
3b6e			.PLUS:	 
3b6e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b6e 15				db WORD_SYS_CORE+1             
3b6f cc 3b			dw .NEG            
3b71 02				db 1 + 1 
3b72 .. 00			db "+",0              
3b74				endm 
# End of macro CWHEAD
3b74			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b74					if DEBUG_FORTH_WORDS_KEY 
3b74						DMARK "PLU" 
3b74 f5				push af  
3b75 3a 89 3b			ld a, (.dmark)  
3b78 32 68 fe			ld (debug_mark),a  
3b7b 3a 8a 3b			ld a, (.dmark+1)  
3b7e 32 69 fe			ld (debug_mark+1),a  
3b81 3a 8b 3b			ld a, (.dmark+2)  
3b84 32 6a fe			ld (debug_mark+2),a  
3b87 18 03			jr .pastdmark  
3b89 ..			.dmark: db "PLU"  
3b8c f1			.pastdmark: pop af  
3b8d			endm  
# End of macro DMARK
3b8d						CALLMONITOR 
3b8d cd 6c fe			call debug_vector  
3b90				endm  
# End of macro CALLMONITOR
3b90					endif 
3b90					; add top two values and push back result 
3b90			 
3b90					;for v5 FORTH_DSP_VALUE 
3b90					FORTH_DSP 
3b90 cd c3 22			call macro_forth_dsp 
3b93				endm 
# End of macro FORTH_DSP
3b93 7e					ld a,(hl)	; get type of value on TOS 
3b94 fe 02				cp DS_TYPE_INUM  
3b96 28 03				jr z, .dot_inum 
3b98			 
3b98					NEXTW 
3b98 c3 b3 24			jp macro_next 
3b9b				endm 
# End of macro NEXTW
3b9b			 
3b9b			; float maths 
3b9b			 
3b9b				if FORTH_ENABLE_FLOATMATH 
3b9b						inc hl      ; now at start of numeric as string 
3b9b			 
3b9b					if DEBUG_FORTH_MATHS 
3b9b						DMARK "ADD" 
3b9b				CALLMONITOR 
3b9b					endif 
3b9b			 
3b9b					;ld ix, hl 
3b9b					call CON 
3b9b			 
3b9b			 
3b9b					push hl 
3b9b					 
3b9b					 
3b9b			 
3b9b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b9b			 
3b9b					; get next number 
3b9b			 
3b9b						FORTH_DSP_VALUE 
3b9b			 
3b9b						inc hl      ; now at start of numeric as string 
3b9b			 
3b9b					;ld ix, hl 
3b9b					call CON 
3b9b			 
3b9b					push hl 
3b9b			 
3b9b			 
3b9b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b9b			 
3b9b						; TODO do add 
3b9b			 
3b9b						call IADD 
3b9b			 
3b9b						; TODO get result back as ascii 
3b9b			 
3b9b						; TODO push result  
3b9b			 
3b9b			 
3b9b			 
3b9b						jr .dot_done 
3b9b				endif 
3b9b			 
3b9b			.dot_inum: 
3b9b			 
3b9b			 
3b9b					if DEBUG_FORTH_DOT 
3b9b						DMARK "+IT" 
3b9b f5				push af  
3b9c 3a b0 3b			ld a, (.dmark)  
3b9f 32 68 fe			ld (debug_mark),a  
3ba2 3a b1 3b			ld a, (.dmark+1)  
3ba5 32 69 fe			ld (debug_mark+1),a  
3ba8 3a b2 3b			ld a, (.dmark+2)  
3bab 32 6a fe			ld (debug_mark+2),a  
3bae 18 03			jr .pastdmark  
3bb0 ..			.dmark: db "+IT"  
3bb3 f1			.pastdmark: pop af  
3bb4			endm  
# End of macro DMARK
3bb4				CALLMONITOR 
3bb4 cd 6c fe			call debug_vector  
3bb7				endm  
# End of macro CALLMONITOR
3bb7					endif 
3bb7			 
3bb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb7 cd fd 22			call macro_dsp_valuehl 
3bba				endm 
# End of macro FORTH_DSP_VALUEHL
3bba			 
3bba				; TODO add floating point number detection 
3bba			 
3bba e5					push hl 
3bbb			 
3bbb					; destroy value TOS 
3bbb			 
3bbb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bbb cd b5 23			call macro_forth_dsp_pop 
3bbe				endm 
# End of macro FORTH_DSP_POP
3bbe			 
3bbe			 
3bbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bbe cd fd 22			call macro_dsp_valuehl 
3bc1				endm 
# End of macro FORTH_DSP_VALUEHL
3bc1			 
3bc1					; one value on hl get other one back 
3bc1			 
3bc1 d1					pop de 
3bc2			 
3bc2					; do the add 
3bc2			 
3bc2 19					add hl,de 
3bc3			 
3bc3					; save it 
3bc3			 
3bc3			;		push hl	 
3bc3			 
3bc3					; 
3bc3			 
3bc3					; destroy value TOS 
3bc3			 
3bc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc3 cd b5 23			call macro_forth_dsp_pop 
3bc6				endm 
# End of macro FORTH_DSP_POP
3bc6			 
3bc6					; TODO push value back onto stack for another op etc 
3bc6			 
3bc6			;		pop hl 
3bc6			 
3bc6			.dot_done: 
3bc6 cd 06 21				call forth_push_numhl 
3bc9			 
3bc9					NEXTW 
3bc9 c3 b3 24			jp macro_next 
3bcc				endm 
# End of macro NEXTW
3bcc			.NEG: 
3bcc			 
3bcc				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3bcc 17				db WORD_SYS_CORE+3             
3bcd 0f 3c			dw .DIV            
3bcf 02				db 1 + 1 
3bd0 .. 00			db "-",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3bd2					if DEBUG_FORTH_WORDS_KEY 
3bd2						DMARK "SUB" 
3bd2 f5				push af  
3bd3 3a e7 3b			ld a, (.dmark)  
3bd6 32 68 fe			ld (debug_mark),a  
3bd9 3a e8 3b			ld a, (.dmark+1)  
3bdc 32 69 fe			ld (debug_mark+1),a  
3bdf 3a e9 3b			ld a, (.dmark+2)  
3be2 32 6a fe			ld (debug_mark+2),a  
3be5 18 03			jr .pastdmark  
3be7 ..			.dmark: db "SUB"  
3bea f1			.pastdmark: pop af  
3beb			endm  
# End of macro DMARK
3beb						CALLMONITOR 
3beb cd 6c fe			call debug_vector  
3bee				endm  
# End of macro CALLMONITOR
3bee					endif 
3bee			 
3bee			 
3bee				; TODO add floating point number detection 
3bee					; v5 FORTH_DSP_VALUE 
3bee					FORTH_DSP 
3bee cd c3 22			call macro_forth_dsp 
3bf1				endm 
# End of macro FORTH_DSP
3bf1 7e					ld a,(hl)	; get type of value on TOS 
3bf2 fe 02				cp DS_TYPE_INUM  
3bf4 28 03				jr z, .neg_inum 
3bf6			 
3bf6					NEXTW 
3bf6 c3 b3 24			jp macro_next 
3bf9				endm 
# End of macro NEXTW
3bf9			 
3bf9			; float maths 
3bf9			 
3bf9				if FORTH_ENABLE_FLOATMATH 
3bf9					jr .neg_done 
3bf9			 
3bf9				endif 
3bf9					 
3bf9			 
3bf9			.neg_inum: 
3bf9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf9 cd fd 22			call macro_dsp_valuehl 
3bfc				endm 
# End of macro FORTH_DSP_VALUEHL
3bfc			 
3bfc e5					push hl 
3bfd			 
3bfd					; destroy value TOS 
3bfd			 
3bfd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfd cd b5 23			call macro_forth_dsp_pop 
3c00				endm 
# End of macro FORTH_DSP_POP
3c00			 
3c00			 
3c00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c00 cd fd 22			call macro_dsp_valuehl 
3c03				endm 
# End of macro FORTH_DSP_VALUEHL
3c03			 
3c03					; one value on hl get other one back 
3c03			 
3c03 d1					pop de 
3c04			 
3c04					; do the sub 
3c04			;		ex de, hl 
3c04			 
3c04 ed 52				sbc hl,de 
3c06			 
3c06					; save it 
3c06			 
3c06			;		push hl	 
3c06			 
3c06					; 
3c06			 
3c06					; destroy value TOS 
3c06			 
3c06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c06 cd b5 23			call macro_forth_dsp_pop 
3c09				endm 
# End of macro FORTH_DSP_POP
3c09			 
3c09					; TODO push value back onto stack for another op etc 
3c09			 
3c09			;		pop hl 
3c09			 
3c09 cd 06 21				call forth_push_numhl 
3c0c			.neg_done: 
3c0c			 
3c0c					NEXTW 
3c0c c3 b3 24			jp macro_next 
3c0f				endm 
# End of macro NEXTW
3c0f			.DIV: 
3c0f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c0f 18				db WORD_SYS_CORE+4             
3c10 5c 3c			dw .MUL            
3c12 02				db 1 + 1 
3c13 .. 00			db "/",0              
3c15				endm 
# End of macro CWHEAD
3c15			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c15					if DEBUG_FORTH_WORDS_KEY 
3c15						DMARK "DIV" 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 68 fe			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 69 fe			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 6a fe			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "DIV"  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e						CALLMONITOR 
3c2e cd 6c fe			call debug_vector  
3c31				endm  
# End of macro CALLMONITOR
3c31					endif 
3c31				; TODO add floating point number detection 
3c31					; v5 FORTH_DSP_VALUE 
3c31					FORTH_DSP 
3c31 cd c3 22			call macro_forth_dsp 
3c34				endm 
# End of macro FORTH_DSP
3c34 7e					ld a,(hl)	; get type of value on TOS 
3c35 fe 02				cp DS_TYPE_INUM  
3c37 28 03				jr z, .div_inum 
3c39			 
3c39				if FORTH_ENABLE_FLOATMATH 
3c39					jr .div_done 
3c39			 
3c39				endif 
3c39					NEXTW 
3c39 c3 b3 24			jp macro_next 
3c3c				endm 
# End of macro NEXTW
3c3c			.div_inum: 
3c3c			 
3c3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3c cd fd 22			call macro_dsp_valuehl 
3c3f				endm 
# End of macro FORTH_DSP_VALUEHL
3c3f			 
3c3f e5					push hl    ; to go to bc 
3c40			 
3c40					; destroy value TOS 
3c40			 
3c40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c40 cd b5 23			call macro_forth_dsp_pop 
3c43				endm 
# End of macro FORTH_DSP_POP
3c43			 
3c43			 
3c43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c43 cd fd 22			call macro_dsp_valuehl 
3c46				endm 
# End of macro FORTH_DSP_VALUEHL
3c46			 
3c46					; hl to go to de 
3c46			 
3c46 e5					push hl 
3c47			 
3c47 c1					pop bc 
3c48 d1					pop de		 
3c49			 
3c49			 
3c49					if DEBUG_FORTH_MATHS 
3c49						DMARK "DIV" 
3c49				CALLMONITOR 
3c49					endif 
3c49					; one value on hl but move to a get other one back 
3c49			 
3c49			        
3c49 cd 2d 0f			call Div16 
3c4c			 
3c4c			;	push af	 
3c4c e5				push hl 
3c4d c5				push bc 
3c4e			 
3c4e					if DEBUG_FORTH_MATHS 
3c4e						DMARK "DI1" 
3c4e				CALLMONITOR 
3c4e					endif 
3c4e			 
3c4e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4e cd b5 23			call macro_forth_dsp_pop 
3c51				endm 
# End of macro FORTH_DSP_POP
3c51			 
3c51			 
3c51			 
3c51 e1					pop hl    ; result 
3c52			 
3c52 cd 06 21				call forth_push_numhl 
3c55			 
3c55 e1					pop hl    ; reminder 
3c56			;		ld h,0 
3c56			;		ld l,d 
3c56			 
3c56 cd 06 21				call forth_push_numhl 
3c59			.div_done: 
3c59					NEXTW 
3c59 c3 b3 24			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			.MUL: 
3c5c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c5c 19				db WORD_SYS_CORE+5             
3c5d a1 3c			dw .MIN            
3c5f 02				db 1 + 1 
3c60 .. 00			db "*",0              
3c62				endm 
# End of macro CWHEAD
3c62			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c62				; TODO add floating point number detection 
3c62					if DEBUG_FORTH_WORDS_KEY 
3c62						DMARK "MUL" 
3c62 f5				push af  
3c63 3a 77 3c			ld a, (.dmark)  
3c66 32 68 fe			ld (debug_mark),a  
3c69 3a 78 3c			ld a, (.dmark+1)  
3c6c 32 69 fe			ld (debug_mark+1),a  
3c6f 3a 79 3c			ld a, (.dmark+2)  
3c72 32 6a fe			ld (debug_mark+2),a  
3c75 18 03			jr .pastdmark  
3c77 ..			.dmark: db "MUL"  
3c7a f1			.pastdmark: pop af  
3c7b			endm  
# End of macro DMARK
3c7b						CALLMONITOR 
3c7b cd 6c fe			call debug_vector  
3c7e				endm  
# End of macro CALLMONITOR
3c7e					endif 
3c7e					FORTH_DSP 
3c7e cd c3 22			call macro_forth_dsp 
3c81				endm 
# End of macro FORTH_DSP
3c81					; v5 FORTH_DSP_VALUE 
3c81 7e					ld a,(hl)	; get type of value on TOS 
3c82 fe 02				cp DS_TYPE_INUM  
3c84 28 03				jr z, .mul_inum 
3c86			 
3c86				if FORTH_ENABLE_FLOATMATH 
3c86					jr .mul_done 
3c86			 
3c86				endif 
3c86			 
3c86					NEXTW 
3c86 c3 b3 24			jp macro_next 
3c89				endm 
# End of macro NEXTW
3c89			.mul_inum:	 
3c89			 
3c89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c89 cd fd 22			call macro_dsp_valuehl 
3c8c				endm 
# End of macro FORTH_DSP_VALUEHL
3c8c			 
3c8c e5					push hl 
3c8d			 
3c8d					; destroy value TOS 
3c8d			 
3c8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c8d cd b5 23			call macro_forth_dsp_pop 
3c90				endm 
# End of macro FORTH_DSP_POP
3c90			 
3c90			 
3c90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c90 cd fd 22			call macro_dsp_valuehl 
3c93				endm 
# End of macro FORTH_DSP_VALUEHL
3c93			 
3c93					; one value on hl but move to a get other one back 
3c93			 
3c93 7d					ld a, l 
3c94			 
3c94 d1					pop de 
3c95			 
3c95					; do the mull 
3c95			;		ex de, hl 
3c95			 
3c95 cd 53 0f				call Mult16 
3c98					; save it 
3c98			 
3c98			;		push hl	 
3c98			 
3c98					; 
3c98			 
3c98					; destroy value TOS 
3c98			 
3c98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c98 cd b5 23			call macro_forth_dsp_pop 
3c9b				endm 
# End of macro FORTH_DSP_POP
3c9b			 
3c9b					; TODO push value back onto stack for another op etc 
3c9b			 
3c9b			;		pop hl 
3c9b			 
3c9b cd 06 21				call forth_push_numhl 
3c9e			 
3c9e			.mul_done: 
3c9e					NEXTW 
3c9e c3 b3 24			jp macro_next 
3ca1				endm 
# End of macro NEXTW
3ca1			 
3ca1			 
3ca1			 
3ca1			 
3ca1			.MIN: 
3ca1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ca1 49				db WORD_SYS_CORE+53             
3ca2 22 3d			dw .MAX            
3ca4 04				db 3 + 1 
3ca5 .. 00			db "MIN",0              
3ca9				endm 
# End of macro CWHEAD
3ca9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ca9					if DEBUG_FORTH_WORDS_KEY 
3ca9						DMARK "MIN" 
3ca9 f5				push af  
3caa 3a be 3c			ld a, (.dmark)  
3cad 32 68 fe			ld (debug_mark),a  
3cb0 3a bf 3c			ld a, (.dmark+1)  
3cb3 32 69 fe			ld (debug_mark+1),a  
3cb6 3a c0 3c			ld a, (.dmark+2)  
3cb9 32 6a fe			ld (debug_mark+2),a  
3cbc 18 03			jr .pastdmark  
3cbe ..			.dmark: db "MIN"  
3cc1 f1			.pastdmark: pop af  
3cc2			endm  
# End of macro DMARK
3cc2						CALLMONITOR 
3cc2 cd 6c fe			call debug_vector  
3cc5				endm  
# End of macro CALLMONITOR
3cc5					endif 
3cc5					; get u2 
3cc5			 
3cc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc5 cd fd 22			call macro_dsp_valuehl 
3cc8				endm 
# End of macro FORTH_DSP_VALUEHL
3cc8			 
3cc8 e5					push hl   ; u2 
3cc9			 
3cc9					; destroy value TOS 
3cc9			 
3cc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc9 cd b5 23			call macro_forth_dsp_pop 
3ccc				endm 
# End of macro FORTH_DSP_POP
3ccc			 
3ccc					; get u1 
3ccc			 
3ccc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccc cd fd 22			call macro_dsp_valuehl 
3ccf				endm 
# End of macro FORTH_DSP_VALUEHL
3ccf			 
3ccf e5					push hl  ; u1 
3cd0			 
3cd0					; destroy value TOS 
3cd0			 
3cd0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd0 cd b5 23			call macro_forth_dsp_pop 
3cd3				endm 
# End of macro FORTH_DSP_POP
3cd3			 
3cd3 b7			 or a      ;clear carry flag 
3cd4 e1			  pop hl    ; u1 
3cd5 d1			  pop de    ; u2 
3cd6 e5				push hl   ; saved in case hl is lowest 
3cd7 ed 52		  sbc hl,de 
3cd9 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3cdb			 
3cdb e1				pop hl 
3cdc					if DEBUG_FORTH_WORDS 
3cdc						DMARK "MIN" 
3cdc f5				push af  
3cdd 3a f1 3c			ld a, (.dmark)  
3ce0 32 68 fe			ld (debug_mark),a  
3ce3 3a f2 3c			ld a, (.dmark+1)  
3ce6 32 69 fe			ld (debug_mark+1),a  
3ce9 3a f3 3c			ld a, (.dmark+2)  
3cec 32 6a fe			ld (debug_mark+2),a  
3cef 18 03			jr .pastdmark  
3cf1 ..			.dmark: db "MIN"  
3cf4 f1			.pastdmark: pop af  
3cf5			endm  
# End of macro DMARK
3cf5						CALLMONITOR 
3cf5 cd 6c fe			call debug_vector  
3cf8				endm  
# End of macro CALLMONITOR
3cf8					endif 
3cf8 cd 06 21				call forth_push_numhl 
3cfb			 
3cfb				       NEXTW 
3cfb c3 b3 24			jp macro_next 
3cfe				endm 
# End of macro NEXTW
3cfe			 
3cfe			.mincont:  
3cfe c1				pop bc   ; tidy up 
3cff eb				ex de , hl  
3d00					if DEBUG_FORTH_WORDS 
3d00						DMARK "MI1" 
3d00 f5				push af  
3d01 3a 15 3d			ld a, (.dmark)  
3d04 32 68 fe			ld (debug_mark),a  
3d07 3a 16 3d			ld a, (.dmark+1)  
3d0a 32 69 fe			ld (debug_mark+1),a  
3d0d 3a 17 3d			ld a, (.dmark+2)  
3d10 32 6a fe			ld (debug_mark+2),a  
3d13 18 03			jr .pastdmark  
3d15 ..			.dmark: db "MI1"  
3d18 f1			.pastdmark: pop af  
3d19			endm  
# End of macro DMARK
3d19						CALLMONITOR 
3d19 cd 6c fe			call debug_vector  
3d1c				endm  
# End of macro CALLMONITOR
3d1c					endif 
3d1c cd 06 21				call forth_push_numhl 
3d1f			 
3d1f				       NEXTW 
3d1f c3 b3 24			jp macro_next 
3d22				endm 
# End of macro NEXTW
3d22			.MAX: 
3d22				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d22 4a				db WORD_SYS_CORE+54             
3d23 a3 3d			dw .RND16            
3d25 04				db 3 + 1 
3d26 .. 00			db "MAX",0              
3d2a				endm 
# End of macro CWHEAD
3d2a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d2a					if DEBUG_FORTH_WORDS_KEY 
3d2a						DMARK "MAX" 
3d2a f5				push af  
3d2b 3a 3f 3d			ld a, (.dmark)  
3d2e 32 68 fe			ld (debug_mark),a  
3d31 3a 40 3d			ld a, (.dmark+1)  
3d34 32 69 fe			ld (debug_mark+1),a  
3d37 3a 41 3d			ld a, (.dmark+2)  
3d3a 32 6a fe			ld (debug_mark+2),a  
3d3d 18 03			jr .pastdmark  
3d3f ..			.dmark: db "MAX"  
3d42 f1			.pastdmark: pop af  
3d43			endm  
# End of macro DMARK
3d43						CALLMONITOR 
3d43 cd 6c fe			call debug_vector  
3d46				endm  
# End of macro CALLMONITOR
3d46					endif 
3d46					; get u2 
3d46			 
3d46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d46 cd fd 22			call macro_dsp_valuehl 
3d49				endm 
# End of macro FORTH_DSP_VALUEHL
3d49			 
3d49 e5					push hl   ; u2 
3d4a			 
3d4a					; destroy value TOS 
3d4a			 
3d4a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d4a cd b5 23			call macro_forth_dsp_pop 
3d4d				endm 
# End of macro FORTH_DSP_POP
3d4d			 
3d4d					; get u1 
3d4d			 
3d4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d4d cd fd 22			call macro_dsp_valuehl 
3d50				endm 
# End of macro FORTH_DSP_VALUEHL
3d50			 
3d50 e5					push hl  ; u1 
3d51			 
3d51					; destroy value TOS 
3d51			 
3d51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d51 cd b5 23			call macro_forth_dsp_pop 
3d54				endm 
# End of macro FORTH_DSP_POP
3d54			 
3d54 b7			 or a      ;clear carry flag 
3d55 e1			  pop hl    ; u1 
3d56 d1			  pop de    ; u2 
3d57 e5				push hl   ; saved in case hl is lowest 
3d58 ed 52		  sbc hl,de 
3d5a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d5c			 
3d5c e1				pop hl 
3d5d					if DEBUG_FORTH_WORDS 
3d5d						DMARK "MAX" 
3d5d f5				push af  
3d5e 3a 72 3d			ld a, (.dmark)  
3d61 32 68 fe			ld (debug_mark),a  
3d64 3a 73 3d			ld a, (.dmark+1)  
3d67 32 69 fe			ld (debug_mark+1),a  
3d6a 3a 74 3d			ld a, (.dmark+2)  
3d6d 32 6a fe			ld (debug_mark+2),a  
3d70 18 03			jr .pastdmark  
3d72 ..			.dmark: db "MAX"  
3d75 f1			.pastdmark: pop af  
3d76			endm  
# End of macro DMARK
3d76						CALLMONITOR 
3d76 cd 6c fe			call debug_vector  
3d79				endm  
# End of macro CALLMONITOR
3d79					endif 
3d79 cd 06 21				call forth_push_numhl 
3d7c			 
3d7c				       NEXTW 
3d7c c3 b3 24			jp macro_next 
3d7f				endm 
# End of macro NEXTW
3d7f			 
3d7f			.maxcont:  
3d7f c1				pop bc   ; tidy up 
3d80 eb				ex de , hl  
3d81					if DEBUG_FORTH_WORDS 
3d81						DMARK "MA1" 
3d81 f5				push af  
3d82 3a 96 3d			ld a, (.dmark)  
3d85 32 68 fe			ld (debug_mark),a  
3d88 3a 97 3d			ld a, (.dmark+1)  
3d8b 32 69 fe			ld (debug_mark+1),a  
3d8e 3a 98 3d			ld a, (.dmark+2)  
3d91 32 6a fe			ld (debug_mark+2),a  
3d94 18 03			jr .pastdmark  
3d96 ..			.dmark: db "MA1"  
3d99 f1			.pastdmark: pop af  
3d9a			endm  
# End of macro DMARK
3d9a						CALLMONITOR 
3d9a cd 6c fe			call debug_vector  
3d9d				endm  
# End of macro CALLMONITOR
3d9d					endif 
3d9d cd 06 21				call forth_push_numhl 
3da0				       NEXTW 
3da0 c3 b3 24			jp macro_next 
3da3				endm 
# End of macro NEXTW
3da3			 
3da3			.RND16: 
3da3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3da3 4e				db WORD_SYS_CORE+58             
3da4 d2 3d			dw .RND8            
3da6 06				db 5 + 1 
3da7 .. 00			db "RND16",0              
3dad				endm 
# End of macro CWHEAD
3dad			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3dad					if DEBUG_FORTH_WORDS_KEY 
3dad						DMARK "R16" 
3dad f5				push af  
3dae 3a c2 3d			ld a, (.dmark)  
3db1 32 68 fe			ld (debug_mark),a  
3db4 3a c3 3d			ld a, (.dmark+1)  
3db7 32 69 fe			ld (debug_mark+1),a  
3dba 3a c4 3d			ld a, (.dmark+2)  
3dbd 32 6a fe			ld (debug_mark+2),a  
3dc0 18 03			jr .pastdmark  
3dc2 ..			.dmark: db "R16"  
3dc5 f1			.pastdmark: pop af  
3dc6			endm  
# End of macro DMARK
3dc6						CALLMONITOR 
3dc6 cd 6c fe			call debug_vector  
3dc9				endm  
# End of macro CALLMONITOR
3dc9					endif 
3dc9 cd f7 0e				call prng16  
3dcc cd 06 21				call forth_push_numhl 
3dcf				       NEXTW 
3dcf c3 b3 24			jp macro_next 
3dd2				endm 
# End of macro NEXTW
3dd2			.RND8: 
3dd2				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3dd2 60				db WORD_SYS_CORE+76             
3dd3 07 3e			dw .RND            
3dd5 05				db 4 + 1 
3dd6 .. 00			db "RND8",0              
3ddb				endm 
# End of macro CWHEAD
3ddb			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3ddb					if DEBUG_FORTH_WORDS_KEY 
3ddb						DMARK "RN8" 
3ddb f5				push af  
3ddc 3a f0 3d			ld a, (.dmark)  
3ddf 32 68 fe			ld (debug_mark),a  
3de2 3a f1 3d			ld a, (.dmark+1)  
3de5 32 69 fe			ld (debug_mark+1),a  
3de8 3a f2 3d			ld a, (.dmark+2)  
3deb 32 6a fe			ld (debug_mark+2),a  
3dee 18 03			jr .pastdmark  
3df0 ..			.dmark: db "RN8"  
3df3 f1			.pastdmark: pop af  
3df4			endm  
# End of macro DMARK
3df4						CALLMONITOR 
3df4 cd 6c fe			call debug_vector  
3df7				endm  
# End of macro CALLMONITOR
3df7					endif 
3df7 2a a6 fb				ld hl,(xrandc) 
3dfa 23					inc hl 
3dfb cd 11 0f				call xrnd 
3dfe 6f					ld l,a	 
3dff 26 00				ld h,0 
3e01 cd 06 21				call forth_push_numhl 
3e04				       NEXTW 
3e04 c3 b3 24			jp macro_next 
3e07				endm 
# End of macro NEXTW
3e07			.RND: 
3e07				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e07 60				db WORD_SYS_CORE+76             
3e08 0d 3f			dw .ENDMATHS            
3e0a 04				db 3 + 1 
3e0b .. 00			db "RND",0              
3e0f				endm 
# End of macro CWHEAD
3e0f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e0f			 
3e0f					if DEBUG_FORTH_WORDS_KEY 
3e0f						DMARK "RND" 
3e0f f5				push af  
3e10 3a 24 3e			ld a, (.dmark)  
3e13 32 68 fe			ld (debug_mark),a  
3e16 3a 25 3e			ld a, (.dmark+1)  
3e19 32 69 fe			ld (debug_mark+1),a  
3e1c 3a 26 3e			ld a, (.dmark+2)  
3e1f 32 6a fe			ld (debug_mark+2),a  
3e22 18 03			jr .pastdmark  
3e24 ..			.dmark: db "RND"  
3e27 f1			.pastdmark: pop af  
3e28			endm  
# End of macro DMARK
3e28						CALLMONITOR 
3e28 cd 6c fe			call debug_vector  
3e2b				endm  
# End of macro CALLMONITOR
3e2b					endif 
3e2b					 
3e2b					FORTH_DSP_VALUEHL    ; upper range 
3e2b cd fd 22			call macro_dsp_valuehl 
3e2e				endm 
# End of macro FORTH_DSP_VALUEHL
3e2e			 
3e2e 22 aa fb				ld (LFSRSeed), hl	 
3e31			 
3e31					if DEBUG_FORTH_WORDS 
3e31						DMARK "RN1" 
3e31 f5				push af  
3e32 3a 46 3e			ld a, (.dmark)  
3e35 32 68 fe			ld (debug_mark),a  
3e38 3a 47 3e			ld a, (.dmark+1)  
3e3b 32 69 fe			ld (debug_mark+1),a  
3e3e 3a 48 3e			ld a, (.dmark+2)  
3e41 32 6a fe			ld (debug_mark+2),a  
3e44 18 03			jr .pastdmark  
3e46 ..			.dmark: db "RN1"  
3e49 f1			.pastdmark: pop af  
3e4a			endm  
# End of macro DMARK
3e4a						CALLMONITOR 
3e4a cd 6c fe			call debug_vector  
3e4d				endm  
# End of macro CALLMONITOR
3e4d					endif 
3e4d					FORTH_DSP_POP 
3e4d cd b5 23			call macro_forth_dsp_pop 
3e50				endm 
# End of macro FORTH_DSP_POP
3e50			 
3e50					FORTH_DSP_VALUEHL    ; low range 
3e50 cd fd 22			call macro_dsp_valuehl 
3e53				endm 
# End of macro FORTH_DSP_VALUEHL
3e53			 
3e53					if DEBUG_FORTH_WORDS 
3e53						DMARK "RN2" 
3e53 f5				push af  
3e54 3a 68 3e			ld a, (.dmark)  
3e57 32 68 fe			ld (debug_mark),a  
3e5a 3a 69 3e			ld a, (.dmark+1)  
3e5d 32 69 fe			ld (debug_mark+1),a  
3e60 3a 6a 3e			ld a, (.dmark+2)  
3e63 32 6a fe			ld (debug_mark+2),a  
3e66 18 03			jr .pastdmark  
3e68 ..			.dmark: db "RN2"  
3e6b f1			.pastdmark: pop af  
3e6c			endm  
# End of macro DMARK
3e6c						CALLMONITOR 
3e6c cd 6c fe			call debug_vector  
3e6f				endm  
# End of macro CALLMONITOR
3e6f					endif 
3e6f 22 ac fb				ld (LFSRSeed+2), hl 
3e72			 
3e72					FORTH_DSP_POP 
3e72 cd b5 23			call macro_forth_dsp_pop 
3e75				endm 
# End of macro FORTH_DSP_POP
3e75			 
3e75 e5					push hl 
3e76			 
3e76 e1			.inrange:	pop hl 
3e77 cd f7 0e				call prng16  
3e7a					if DEBUG_FORTH_WORDS 
3e7a						DMARK "RN3" 
3e7a f5				push af  
3e7b 3a 8f 3e			ld a, (.dmark)  
3e7e 32 68 fe			ld (debug_mark),a  
3e81 3a 90 3e			ld a, (.dmark+1)  
3e84 32 69 fe			ld (debug_mark+1),a  
3e87 3a 91 3e			ld a, (.dmark+2)  
3e8a 32 6a fe			ld (debug_mark+2),a  
3e8d 18 03			jr .pastdmark  
3e8f ..			.dmark: db "RN3"  
3e92 f1			.pastdmark: pop af  
3e93			endm  
# End of macro DMARK
3e93						CALLMONITOR 
3e93 cd 6c fe			call debug_vector  
3e96				endm  
# End of macro CALLMONITOR
3e96					endif 
3e96					 
3e96					; if the range is 8bit knock out the high byte 
3e96			 
3e96 ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3e9a			 
3e9a 3e 00				ld a, 0 
3e9c ba					cp d  
3e9d 20 1e				jr nz, .hirange 
3e9f 26 00				ld h, 0   ; knock it down to 8bit 
3ea1			 
3ea1					if DEBUG_FORTH_WORDS 
3ea1						DMARK "RNk" 
3ea1 f5				push af  
3ea2 3a b6 3e			ld a, (.dmark)  
3ea5 32 68 fe			ld (debug_mark),a  
3ea8 3a b7 3e			ld a, (.dmark+1)  
3eab 32 69 fe			ld (debug_mark+1),a  
3eae 3a b8 3e			ld a, (.dmark+2)  
3eb1 32 6a fe			ld (debug_mark+2),a  
3eb4 18 03			jr .pastdmark  
3eb6 ..			.dmark: db "RNk"  
3eb9 f1			.pastdmark: pop af  
3eba			endm  
# End of macro DMARK
3eba						CALLMONITOR 
3eba cd 6c fe			call debug_vector  
3ebd				endm  
# End of macro CALLMONITOR
3ebd					endif 
3ebd			.hirange:   
3ebd e5					push hl  
3ebe b7					or a  
3ebf ed 52		                sbc hl, de 
3ec1			 
3ec1					;call cmp16 
3ec1			 
3ec1 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ec3 e1					pop hl 
3ec4 e5					push hl 
3ec5			 
3ec5					if DEBUG_FORTH_WORDS 
3ec5						DMARK "RN4" 
3ec5 f5				push af  
3ec6 3a da 3e			ld a, (.dmark)  
3ec9 32 68 fe			ld (debug_mark),a  
3ecc 3a db 3e			ld a, (.dmark+1)  
3ecf 32 69 fe			ld (debug_mark+1),a  
3ed2 3a dc 3e			ld a, (.dmark+2)  
3ed5 32 6a fe			ld (debug_mark+2),a  
3ed8 18 03			jr .pastdmark  
3eda ..			.dmark: db "RN4"  
3edd f1			.pastdmark: pop af  
3ede			endm  
# End of macro DMARK
3ede						CALLMONITOR 
3ede cd 6c fe			call debug_vector  
3ee1				endm  
# End of macro CALLMONITOR
3ee1					endif 
3ee1 ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3ee5					;call cmp16 
3ee5				 
3ee5 b7					or a  
3ee6 ed 52		                sbc hl, de 
3ee8 38 8c				jr c, .inrange 
3eea			 
3eea e1					pop hl 
3eeb					 
3eeb					if DEBUG_FORTH_WORDS 
3eeb						DMARK "RNd" 
3eeb f5				push af  
3eec 3a 00 3f			ld a, (.dmark)  
3eef 32 68 fe			ld (debug_mark),a  
3ef2 3a 01 3f			ld a, (.dmark+1)  
3ef5 32 69 fe			ld (debug_mark+1),a  
3ef8 3a 02 3f			ld a, (.dmark+2)  
3efb 32 6a fe			ld (debug_mark+2),a  
3efe 18 03			jr .pastdmark  
3f00 ..			.dmark: db "RNd"  
3f03 f1			.pastdmark: pop af  
3f04			endm  
# End of macro DMARK
3f04						CALLMONITOR 
3f04 cd 6c fe			call debug_vector  
3f07				endm  
# End of macro CALLMONITOR
3f07					endif 
3f07			 
3f07			 
3f07 cd 06 21				call forth_push_numhl 
3f0a				       NEXTW 
3f0a c3 b3 24			jp macro_next 
3f0d				endm 
# End of macro NEXTW
3f0d			 
3f0d			.ENDMATHS: 
3f0d			 
3f0d			; eof 
3f0d			 
# End of file forth_words_maths.asm
3f0d			include "forth_words_display.asm" 
3f0d			 
3f0d			; | ## Display Words 
3f0d			 
3f0d			.ACT: 
3f0d			 
3f0d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f0d 62				db WORD_SYS_CORE+78             
3f0e 59 3f			dw .INFO            
3f10 07				db 6 + 1 
3f11 .. 00			db "ACTIVE",0              
3f18				endm 
# End of macro CWHEAD
3f18			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f18			;  
3f18			; | | e.g. $ff $00 do active . $01 pause loop 
3f18			 
3f18					if DEBUG_FORTH_WORDS_KEY 
3f18						DMARK "ACT" 
3f18 f5				push af  
3f19 3a 2d 3f			ld a, (.dmark)  
3f1c 32 68 fe			ld (debug_mark),a  
3f1f 3a 2e 3f			ld a, (.dmark+1)  
3f22 32 69 fe			ld (debug_mark+1),a  
3f25 3a 2f 3f			ld a, (.dmark+2)  
3f28 32 6a fe			ld (debug_mark+2),a  
3f2b 18 03			jr .pastdmark  
3f2d ..			.dmark: db "ACT"  
3f30 f1			.pastdmark: pop af  
3f31			endm  
# End of macro DMARK
3f31						CALLMONITOR 
3f31 cd 6c fe			call debug_vector  
3f34				endm  
# End of macro CALLMONITOR
3f34					endif 
3f34 cd f3 0c				call active 
3f37					if DEBUG_FORTH_WORDS 
3f37						DMARK "ACp" 
3f37 f5				push af  
3f38 3a 4c 3f			ld a, (.dmark)  
3f3b 32 68 fe			ld (debug_mark),a  
3f3e 3a 4d 3f			ld a, (.dmark+1)  
3f41 32 69 fe			ld (debug_mark+1),a  
3f44 3a 4e 3f			ld a, (.dmark+2)  
3f47 32 6a fe			ld (debug_mark+2),a  
3f4a 18 03			jr .pastdmark  
3f4c ..			.dmark: db "ACp"  
3f4f f1			.pastdmark: pop af  
3f50			endm  
# End of macro DMARK
3f50						CALLMONITOR 
3f50 cd 6c fe			call debug_vector  
3f53				endm  
# End of macro CALLMONITOR
3f53					endif 
3f53 cd 74 21				call forth_push_str 
3f56			 
3f56					NEXTW 
3f56 c3 b3 24			jp macro_next 
3f59				endm 
# End of macro NEXTW
3f59			.INFO: 
3f59			 
3f59				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f59 62				db WORD_SYS_CORE+78             
3f5a 76 3f			dw .ATP            
3f5c 05				db 4 + 1 
3f5d .. 00			db "INFO",0              
3f62				endm 
# End of macro CWHEAD
3f62			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f62					FORTH_DSP_VALUEHL 
3f62 cd fd 22			call macro_dsp_valuehl 
3f65				endm 
# End of macro FORTH_DSP_VALUEHL
3f65			 
3f65					FORTH_DSP_POP 
3f65 cd b5 23			call macro_forth_dsp_pop 
3f68				endm 
# End of macro FORTH_DSP_POP
3f68			 
3f68 e5					push hl 
3f69			 
3f69					FORTH_DSP_VALUEHL 
3f69 cd fd 22			call macro_dsp_valuehl 
3f6c				endm 
# End of macro FORTH_DSP_VALUEHL
3f6c			 
3f6c					FORTH_DSP_POP 
3f6c cd b5 23			call macro_forth_dsp_pop 
3f6f				endm 
# End of macro FORTH_DSP_POP
3f6f			 
3f6f d1					pop de 
3f70			 
3f70 cd 2d 0d				call info_panel 
3f73			 
3f73			 
3f73					NEXTW 
3f73 c3 b3 24			jp macro_next 
3f76				endm 
# End of macro NEXTW
3f76			.ATP: 
3f76				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f76 62				db WORD_SYS_CORE+78             
3f77 ed 3f			dw .FB            
3f79 04				db 3 + 1 
3f7a .. 00			db "AT?",0              
3f7e				endm 
# End of macro CWHEAD
3f7e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f7e					if DEBUG_FORTH_WORDS_KEY 
3f7e						DMARK "AT?" 
3f7e f5				push af  
3f7f 3a 93 3f			ld a, (.dmark)  
3f82 32 68 fe			ld (debug_mark),a  
3f85 3a 94 3f			ld a, (.dmark+1)  
3f88 32 69 fe			ld (debug_mark+1),a  
3f8b 3a 95 3f			ld a, (.dmark+2)  
3f8e 32 6a fe			ld (debug_mark+2),a  
3f91 18 03			jr .pastdmark  
3f93 ..			.dmark: db "AT?"  
3f96 f1			.pastdmark: pop af  
3f97			endm  
# End of macro DMARK
3f97						CALLMONITOR 
3f97 cd 6c fe			call debug_vector  
3f9a				endm  
# End of macro CALLMONITOR
3f9a					endif 
3f9a 3a 5b fa				ld a, (f_cursor_ptr) 
3f9d			 
3f9d			if DEBUG_FORTH_WORDS 
3f9d				DMARK "AT?" 
3f9d f5				push af  
3f9e 3a b2 3f			ld a, (.dmark)  
3fa1 32 68 fe			ld (debug_mark),a  
3fa4 3a b3 3f			ld a, (.dmark+1)  
3fa7 32 69 fe			ld (debug_mark+1),a  
3faa 3a b4 3f			ld a, (.dmark+2)  
3fad 32 6a fe			ld (debug_mark+2),a  
3fb0 18 03			jr .pastdmark  
3fb2 ..			.dmark: db "AT?"  
3fb5 f1			.pastdmark: pop af  
3fb6			endm  
# End of macro DMARK
3fb6				CALLMONITOR 
3fb6 cd 6c fe			call debug_vector  
3fb9				endm  
# End of macro CALLMONITOR
3fb9			endif	 
3fb9					; count the number of rows 
3fb9			 
3fb9 06 00				ld b, 0 
3fbb 4f			.atpr:		ld c, a    ; save in case we go below zero 
3fbc d6 28				sub display_cols 
3fbe f2 c4 3f				jp p, .atprunder 
3fc1 04					inc b 
3fc2 18 f7				jr .atpr 
3fc4			.atprunder:	 
3fc4			if DEBUG_FORTH_WORDS 
3fc4				DMARK "A?2" 
3fc4 f5				push af  
3fc5 3a d9 3f			ld a, (.dmark)  
3fc8 32 68 fe			ld (debug_mark),a  
3fcb 3a da 3f			ld a, (.dmark+1)  
3fce 32 69 fe			ld (debug_mark+1),a  
3fd1 3a db 3f			ld a, (.dmark+2)  
3fd4 32 6a fe			ld (debug_mark+2),a  
3fd7 18 03			jr .pastdmark  
3fd9 ..			.dmark: db "A?2"  
3fdc f1			.pastdmark: pop af  
3fdd			endm  
# End of macro DMARK
3fdd				CALLMONITOR 
3fdd cd 6c fe			call debug_vector  
3fe0				endm  
# End of macro CALLMONITOR
3fe0			endif	 
3fe0 26 00				ld h, 0 
3fe2 69					ld l, c 
3fe3 cd 06 21				call forth_push_numhl 
3fe6 68					ld l, b  
3fe7 cd 06 21				call forth_push_numhl 
3fea			 
3fea			 
3fea				NEXTW 
3fea c3 b3 24			jp macro_next 
3fed				endm 
# End of macro NEXTW
3fed			 
3fed			.FB: 
3fed				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3fed 1b				db WORD_SYS_CORE+7             
3fee 3b 40			dw .EMIT            
3ff0 03				db 2 + 1 
3ff1 .. 00			db "FB",0              
3ff4				endm 
# End of macro CWHEAD
3ff4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ff4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ff4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ff4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ff4					if DEBUG_FORTH_WORDS_KEY 
3ff4						DMARK "FB." 
3ff4 f5				push af  
3ff5 3a 09 40			ld a, (.dmark)  
3ff8 32 68 fe			ld (debug_mark),a  
3ffb 3a 0a 40			ld a, (.dmark+1)  
3ffe 32 69 fe			ld (debug_mark+1),a  
4001 3a 0b 40			ld a, (.dmark+2)  
4004 32 6a fe			ld (debug_mark+2),a  
4007 18 03			jr .pastdmark  
4009 ..			.dmark: db "FB."  
400c f1			.pastdmark: pop af  
400d			endm  
# End of macro DMARK
400d						CALLMONITOR 
400d cd 6c fe			call debug_vector  
4010				endm  
# End of macro CALLMONITOR
4010					endif 
4010			 
4010					FORTH_DSP_VALUEHL 
4010 cd fd 22			call macro_dsp_valuehl 
4013				endm 
# End of macro FORTH_DSP_VALUEHL
4013			 
4013 7d					ld a, l 
4014 fe 01				cp 1 
4016 20 05				jr nz, .fbn1 
4018 21 0d fd				ld hl, display_fb1 
401b 18 15				jr .fbset 
401d fe 02		.fbn1:		cp 2 
401f 20 05				jr nz, .fbn2 
4021 21 cb fb				ld hl, display_fb2 
4024 18 0c				jr .fbset 
4026 fe 03		.fbn2:		cp 3 
4028 20 05				jr nz, .fbn3 
402a 21 6c fc				ld hl, display_fb3 
402d 18 03				jr .fbset 
402f			.fbn3:		 ; if invalid number select first 
402f 21 0d fd				ld hl, display_fb1 
4032 22 c9 fb		.fbset:		ld (display_fb_active), hl 
4035			 
4035					FORTH_DSP_POP 
4035 cd b5 23			call macro_forth_dsp_pop 
4038				endm 
# End of macro FORTH_DSP_POP
4038			 
4038					NEXTW 
4038 c3 b3 24			jp macro_next 
403b				endm 
# End of macro NEXTW
403b			 
403b			 
403b			.EMIT: 
403b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
403b 1b				db WORD_SYS_CORE+7             
403c 8c 40			dw .DOTH            
403e 05				db 4 + 1 
403f .. 00			db "EMIT",0              
4044				endm 
# End of macro CWHEAD
4044			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4044					; get value off TOS and display it 
4044			 
4044					if DEBUG_FORTH_WORDS_KEY 
4044						DMARK "EMT" 
4044 f5				push af  
4045 3a 59 40			ld a, (.dmark)  
4048 32 68 fe			ld (debug_mark),a  
404b 3a 5a 40			ld a, (.dmark+1)  
404e 32 69 fe			ld (debug_mark+1),a  
4051 3a 5b 40			ld a, (.dmark+2)  
4054 32 6a fe			ld (debug_mark+2),a  
4057 18 03			jr .pastdmark  
4059 ..			.dmark: db "EMT"  
405c f1			.pastdmark: pop af  
405d			endm  
# End of macro DMARK
405d						CALLMONITOR 
405d cd 6c fe			call debug_vector  
4060				endm  
# End of macro CALLMONITOR
4060					endif 
4060			 
4060					FORTH_DSP_VALUEHL 
4060 cd fd 22			call macro_dsp_valuehl 
4063				endm 
# End of macro FORTH_DSP_VALUEHL
4063			 
4063 7d					ld a,l 
4064			 
4064					; TODO write to display 
4064			 
4064 32 bc f3				ld (os_input), a 
4067 3e 00				ld a, 0 
4069 32 bd f3				ld (os_input+1), a 
406c					 
406c 3a 5b fa				ld a, (f_cursor_ptr) 
406f 11 bc f3				ld de, os_input 
4072 cd af 0d				call str_at_display 
4075			 
4075			 
4075 3a 39 fa				ld a,(cli_autodisplay) 
4078 fe 00				cp 0 
407a 28 03				jr z, .enoupdate 
407c cd bf 0d						call update_display 
407f					.enoupdate: 
407f			 
407f 3a 5b fa				ld a, (f_cursor_ptr) 
4082 3c					inc a 
4083 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4086			 
4086			 
4086					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4086 cd b5 23			call macro_forth_dsp_pop 
4089				endm 
# End of macro FORTH_DSP_POP
4089			  
4089			 
4089					NEXTW 
4089 c3 b3 24			jp macro_next 
408c				endm 
# End of macro NEXTW
408c			.DOTH: 
408c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
408c 1c				db WORD_SYS_CORE+8             
408d bc 40			dw .DOTF            
408f 03				db 2 + 1 
4090 .. 00			db ".-",0              
4093				endm 
# End of macro CWHEAD
4093			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4093					; get value off TOS and display it 
4093					if DEBUG_FORTH_WORDS_KEY 
4093						DMARK "DTD" 
4093 f5				push af  
4094 3a a8 40			ld a, (.dmark)  
4097 32 68 fe			ld (debug_mark),a  
409a 3a a9 40			ld a, (.dmark+1)  
409d 32 69 fe			ld (debug_mark+1),a  
40a0 3a aa 40			ld a, (.dmark+2)  
40a3 32 6a fe			ld (debug_mark+2),a  
40a6 18 03			jr .pastdmark  
40a8 ..			.dmark: db "DTD"  
40ab f1			.pastdmark: pop af  
40ac			endm  
# End of macro DMARK
40ac						CALLMONITOR 
40ac cd 6c fe			call debug_vector  
40af				endm  
# End of macro CALLMONITOR
40af					endif 
40af 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40b1 3e 00			ld a, 0 
40b3 32 3a fa			ld (cli_mvdot), a 
40b6 c3 13 41			jp .dotgo 
40b9				NEXTW 
40b9 c3 b3 24			jp macro_next 
40bc				endm 
# End of macro NEXTW
40bc			.DOTF: 
40bc				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40bc 1c				db WORD_SYS_CORE+8             
40bd ea 40			dw .DOT            
40bf 03				db 2 + 1 
40c0 .. 00			db ".>",0              
40c3				endm 
# End of macro CWHEAD
40c3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
40c3					; get value off TOS and display it 
40c3			        ; TODO BUG adds extra spaces 
40c3			        ; TODO BUG handle numerics? 
40c3					if DEBUG_FORTH_WORDS_KEY 
40c3						DMARK "DTC" 
40c3 f5				push af  
40c4 3a d8 40			ld a, (.dmark)  
40c7 32 68 fe			ld (debug_mark),a  
40ca 3a d9 40			ld a, (.dmark+1)  
40cd 32 69 fe			ld (debug_mark+1),a  
40d0 3a da 40			ld a, (.dmark+2)  
40d3 32 6a fe			ld (debug_mark+2),a  
40d6 18 03			jr .pastdmark  
40d8 ..			.dmark: db "DTC"  
40db f1			.pastdmark: pop af  
40dc			endm  
# End of macro DMARK
40dc						CALLMONITOR 
40dc cd 6c fe			call debug_vector  
40df				endm  
# End of macro CALLMONITOR
40df					endif 
40df 3e 01			ld a, 1 
40e1 32 3a fa			ld (cli_mvdot), a 
40e4 c3 13 41			jp .dotgo 
40e7				NEXTW 
40e7 c3 b3 24			jp macro_next 
40ea				endm 
# End of macro NEXTW
40ea			 
40ea			.DOT: 
40ea				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
40ea 1c				db WORD_SYS_CORE+8             
40eb c6 42			dw .CLS            
40ed 02				db 1 + 1 
40ee .. 00			db ".",0              
40f0				endm 
# End of macro CWHEAD
40f0			        ; | . ( u -- ) Display TOS | DONE 
40f0					; get value off TOS and display it 
40f0			 
40f0					if DEBUG_FORTH_WORDS_KEY 
40f0						DMARK "DOT" 
40f0 f5				push af  
40f1 3a 05 41			ld a, (.dmark)  
40f4 32 68 fe			ld (debug_mark),a  
40f7 3a 06 41			ld a, (.dmark+1)  
40fa 32 69 fe			ld (debug_mark+1),a  
40fd 3a 07 41			ld a, (.dmark+2)  
4100 32 6a fe			ld (debug_mark+2),a  
4103 18 03			jr .pastdmark  
4105 ..			.dmark: db "DOT"  
4108 f1			.pastdmark: pop af  
4109			endm  
# End of macro DMARK
4109						CALLMONITOR 
4109 cd 6c fe			call debug_vector  
410c				endm  
# End of macro CALLMONITOR
410c					endif 
410c 3e 00			ld a, 0 
410e 32 3a fa			ld (cli_mvdot), a 
4111 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4113				 
4113			 
4113			.dotgo: 
4113			 
4113			; move up type to on stack for parserv5 
4113					FORTH_DSP 
4113 cd c3 22			call macro_forth_dsp 
4116				endm 
# End of macro FORTH_DSP
4116				;FORTH_DSP_VALUE  
4116			 
4116			if DEBUG_FORTH_DOT 
4116				DMARK "DOT" 
4116 f5				push af  
4117 3a 2b 41			ld a, (.dmark)  
411a 32 68 fe			ld (debug_mark),a  
411d 3a 2c 41			ld a, (.dmark+1)  
4120 32 69 fe			ld (debug_mark+1),a  
4123 3a 2d 41			ld a, (.dmark+2)  
4126 32 6a fe			ld (debug_mark+2),a  
4129 18 03			jr .pastdmark  
412b ..			.dmark: db "DOT"  
412e f1			.pastdmark: pop af  
412f			endm  
# End of macro DMARK
412f				CALLMONITOR 
412f cd 6c fe			call debug_vector  
4132				endm  
# End of macro CALLMONITOR
4132			endif	 
4132			;		.print: 
4132			 
4132 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4133 23				inc hl   ; position to the actual value 
4134 fe 01			cp DS_TYPE_STR 
4136 20 06			jr nz, .dotnum1  
4138			 
4138			; display string 
4138				FORTH_DSP_VALUE  
4138 cd e6 22			call macro_forth_dsp_value 
413b				endm 
# End of macro FORTH_DSP_VALUE
413b eb				ex de,hl 
413c 18 49			jr .dotwrite 
413e			 
413e			.dotnum1: 
413e fe 02			cp DS_TYPE_INUM 
4140 20 44			jr nz, .dotflot 
4142			 
4142			 
4142			; display number 
4142			 
4142			;	push hl 
4142			;	call clear_display 
4142			;	pop hl 
4142			 
4142 5e				ld e, (hl) 
4143 23				inc hl 
4144 56				ld d, (hl) 
4145 21 be f1			ld hl, scratch 
4148			if DEBUG_FORTH_DOT 
4148				DMARK "DT1" 
4148 f5				push af  
4149 3a 5d 41			ld a, (.dmark)  
414c 32 68 fe			ld (debug_mark),a  
414f 3a 5e 41			ld a, (.dmark+1)  
4152 32 69 fe			ld (debug_mark+1),a  
4155 3a 5f 41			ld a, (.dmark+2)  
4158 32 6a fe			ld (debug_mark+2),a  
415b 18 03			jr .pastdmark  
415d ..			.dmark: db "DT1"  
4160 f1			.pastdmark: pop af  
4161			endm  
# End of macro DMARK
4161				CALLMONITOR 
4161 cd 6c fe			call debug_vector  
4164				endm  
# End of macro CALLMONITOR
4164			endif	 
4164			 
4164 cd dd 13			call uitoa_16 
4167 eb				ex de,hl 
4168			 
4168			if DEBUG_FORTH_DOT 
4168				DMARK "DT2" 
4168 f5				push af  
4169 3a 7d 41			ld a, (.dmark)  
416c 32 68 fe			ld (debug_mark),a  
416f 3a 7e 41			ld a, (.dmark+1)  
4172 32 69 fe			ld (debug_mark+1),a  
4175 3a 7f 41			ld a, (.dmark+2)  
4178 32 6a fe			ld (debug_mark+2),a  
417b 18 03			jr .pastdmark  
417d ..			.dmark: db "DT2"  
4180 f1			.pastdmark: pop af  
4181			endm  
# End of macro DMARK
4181				CALLMONITOR 
4181 cd 6c fe			call debug_vector  
4184				endm  
# End of macro CALLMONITOR
4184			endif	 
4184			 
4184			;	ld de, os_word_scratch 
4184 18 01			jr .dotwrite 
4186			 
4186 00			.dotflot:   nop 
4187			; TODO print floating point number 
4187			 
4187			.dotwrite:		 
4187			 
4187					; if c is set then set all '-' to spaces 
4187					; need to also take into account .>  
4187			 
4187 3e 01				ld a, 1 
4189 b9					cp c 
418a 20 67				jr nz, .nodashswap 
418c			 
418c					; DE has the string to write, working with HL 
418c			 
418c 06 ff				ld b, 255 
418e d5					push de 
418f e1					pop hl 
4190			 
4190			if DEBUG_FORTH_DOT 
4190				DMARK "DT-" 
4190 f5				push af  
4191 3a a5 41			ld a, (.dmark)  
4194 32 68 fe			ld (debug_mark),a  
4197 3a a6 41			ld a, (.dmark+1)  
419a 32 69 fe			ld (debug_mark+1),a  
419d 3a a7 41			ld a, (.dmark+2)  
41a0 32 6a fe			ld (debug_mark+2),a  
41a3 18 03			jr .pastdmark  
41a5 ..			.dmark: db "DT-"  
41a8 f1			.pastdmark: pop af  
41a9			endm  
# End of macro DMARK
41a9				CALLMONITOR 
41a9 cd 6c fe			call debug_vector  
41ac				endm  
# End of macro CALLMONITOR
41ac			endif	 
41ac 7e			.dashscan:	ld a, (hl) 
41ad fe 00				cp 0 
41af 28 42				jr z, .nodashswap 
41b1 fe 2d				cp '-' 
41b3 20 03				jr nz, .dashskip 
41b5 3e 20				ld a, ' ' 
41b7 77					ld (hl), a 
41b8 23			.dashskip:	inc hl 
41b9			if DEBUG_FORTH_DOT 
41b9				DMARK "D-2" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 68 fe			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 69 fe			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 6a fe			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "D-2"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2				CALLMONITOR 
41d2 cd 6c fe			call debug_vector  
41d5				endm  
# End of macro CALLMONITOR
41d5			endif	 
41d5 10 d5				djnz .dashscan 
41d7			 
41d7			if DEBUG_FORTH_DOT 
41d7				DMARK "D-1" 
41d7 f5				push af  
41d8 3a ec 41			ld a, (.dmark)  
41db 32 68 fe			ld (debug_mark),a  
41de 3a ed 41			ld a, (.dmark+1)  
41e1 32 69 fe			ld (debug_mark+1),a  
41e4 3a ee 41			ld a, (.dmark+2)  
41e7 32 6a fe			ld (debug_mark+2),a  
41ea 18 03			jr .pastdmark  
41ec ..			.dmark: db "D-1"  
41ef f1			.pastdmark: pop af  
41f0			endm  
# End of macro DMARK
41f0				CALLMONITOR 
41f0 cd 6c fe			call debug_vector  
41f3				endm  
# End of macro CALLMONITOR
41f3			endif	 
41f3			 
41f3			.nodashswap: 
41f3			 
41f3			if DEBUG_FORTH_DOT 
41f3				DMARK "D-o" 
41f3 f5				push af  
41f4 3a 08 42			ld a, (.dmark)  
41f7 32 68 fe			ld (debug_mark),a  
41fa 3a 09 42			ld a, (.dmark+1)  
41fd 32 69 fe			ld (debug_mark+1),a  
4200 3a 0a 42			ld a, (.dmark+2)  
4203 32 6a fe			ld (debug_mark+2),a  
4206 18 03			jr .pastdmark  
4208 ..			.dmark: db "D-o"  
420b f1			.pastdmark: pop af  
420c			endm  
# End of macro DMARK
420c				CALLMONITOR 
420c cd 6c fe			call debug_vector  
420f				endm  
# End of macro CALLMONITOR
420f			endif	 
420f			 
420f d5					push de   ; save string start in case we need to advance print 
4210			 
4210 3a 5b fa				ld a, (f_cursor_ptr) 
4213 cd af 0d				call str_at_display 
4216 3a 39 fa				ld a,(cli_autodisplay) 
4219 fe 00				cp 0 
421b 28 03				jr z, .noupdate 
421d cd bf 0d						call update_display 
4220					.noupdate: 
4220			 
4220			 
4220					; see if we need to advance the print position 
4220			 
4220 e1					pop hl   ; get back string 
4221			;		ex de,hl 
4221			 
4221 3a 3a fa				ld a, (cli_mvdot) 
4224			if DEBUG_FORTH_DOT 
4224			;		ld e,a 
4224				DMARK "D>1" 
4224 f5				push af  
4225 3a 39 42			ld a, (.dmark)  
4228 32 68 fe			ld (debug_mark),a  
422b 3a 3a 42			ld a, (.dmark+1)  
422e 32 69 fe			ld (debug_mark+1),a  
4231 3a 3b 42			ld a, (.dmark+2)  
4234 32 6a fe			ld (debug_mark+2),a  
4237 18 03			jr .pastdmark  
4239 ..			.dmark: db "D>1"  
423c f1			.pastdmark: pop af  
423d			endm  
# End of macro DMARK
423d				CALLMONITOR 
423d cd 6c fe			call debug_vector  
4240				endm  
# End of macro CALLMONITOR
4240			endif	 
4240 fe 00				cp 0 
4242 28 44				jr z, .noadv 
4244					; yes, lets advance the print position 
4244 3e 00				ld a, 0 
4246 cd 39 14				call strlent 
4249			if DEBUG_FORTH_DOT 
4249				DMARK "D-?" 
4249 f5				push af  
424a 3a 5e 42			ld a, (.dmark)  
424d 32 68 fe			ld (debug_mark),a  
4250 3a 5f 42			ld a, (.dmark+1)  
4253 32 69 fe			ld (debug_mark+1),a  
4256 3a 60 42			ld a, (.dmark+2)  
4259 32 6a fe			ld (debug_mark+2),a  
425c 18 03			jr .pastdmark  
425e ..			.dmark: db "D-?"  
4261 f1			.pastdmark: pop af  
4262			endm  
# End of macro DMARK
4262				CALLMONITOR 
4262 cd 6c fe			call debug_vector  
4265				endm  
# End of macro CALLMONITOR
4265			endif	 
4265 3a 5b fa				ld a, (f_cursor_ptr) 
4268 85					add a,l 
4269					;call addatohl 
4269					;ld a, l 
4269 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
426c			 
426c			if DEBUG_FORTH_DOT 
426c				DMARK "D->" 
426c f5				push af  
426d 3a 81 42			ld a, (.dmark)  
4270 32 68 fe			ld (debug_mark),a  
4273 3a 82 42			ld a, (.dmark+1)  
4276 32 69 fe			ld (debug_mark+1),a  
4279 3a 83 42			ld a, (.dmark+2)  
427c 32 6a fe			ld (debug_mark+2),a  
427f 18 03			jr .pastdmark  
4281 ..			.dmark: db "D->"  
4284 f1			.pastdmark: pop af  
4285			endm  
# End of macro DMARK
4285				CALLMONITOR 
4285 cd 6c fe			call debug_vector  
4288				endm  
# End of macro CALLMONITOR
4288			endif	 
4288			 
4288			.noadv:	 
4288			 
4288					if DEBUG_FORTH_DOT_WAIT 
4288							call next_page_prompt 
4288					endif	 
4288			; TODO this pop off the stack causes a crash. i dont know why 
4288			 
4288			 
4288			if DEBUG_FORTH_DOT 
4288				DMARK "DTh" 
4288 f5				push af  
4289 3a 9d 42			ld a, (.dmark)  
428c 32 68 fe			ld (debug_mark),a  
428f 3a 9e 42			ld a, (.dmark+1)  
4292 32 69 fe			ld (debug_mark+1),a  
4295 3a 9f 42			ld a, (.dmark+2)  
4298 32 6a fe			ld (debug_mark+2),a  
429b 18 03			jr .pastdmark  
429d ..			.dmark: db "DTh"  
42a0 f1			.pastdmark: pop af  
42a1			endm  
# End of macro DMARK
42a1				CALLMONITOR 
42a1 cd 6c fe			call debug_vector  
42a4				endm  
# End of macro CALLMONITOR
42a4			endif	 
42a4			 
42a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a4 cd b5 23			call macro_forth_dsp_pop 
42a7				endm 
# End of macro FORTH_DSP_POP
42a7			 
42a7			if DEBUG_FORTH_DOT 
42a7				DMARK "DTi" 
42a7 f5				push af  
42a8 3a bc 42			ld a, (.dmark)  
42ab 32 68 fe			ld (debug_mark),a  
42ae 3a bd 42			ld a, (.dmark+1)  
42b1 32 69 fe			ld (debug_mark+1),a  
42b4 3a be 42			ld a, (.dmark+2)  
42b7 32 6a fe			ld (debug_mark+2),a  
42ba 18 03			jr .pastdmark  
42bc ..			.dmark: db "DTi"  
42bf f1			.pastdmark: pop af  
42c0			endm  
# End of macro DMARK
42c0				CALLMONITOR 
42c0 cd 6c fe			call debug_vector  
42c3				endm  
# End of macro CALLMONITOR
42c3			endif	 
42c3			 
42c3			 
42c3					NEXTW 
42c3 c3 b3 24			jp macro_next 
42c6				endm 
# End of macro NEXTW
42c6			 
42c6			.CLS: 
42c6				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
42c6 35				db WORD_SYS_CORE+33             
42c7 f3 42			dw .DRAW            
42c9 04				db 3 + 1 
42ca .. 00			db "CLS",0              
42ce				endm 
# End of macro CWHEAD
42ce			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
42ce					if DEBUG_FORTH_WORDS_KEY 
42ce						DMARK "CLS" 
42ce f5				push af  
42cf 3a e3 42			ld a, (.dmark)  
42d2 32 68 fe			ld (debug_mark),a  
42d5 3a e4 42			ld a, (.dmark+1)  
42d8 32 69 fe			ld (debug_mark+1),a  
42db 3a e5 42			ld a, (.dmark+2)  
42de 32 6a fe			ld (debug_mark+2),a  
42e1 18 03			jr .pastdmark  
42e3 ..			.dmark: db "CLS"  
42e6 f1			.pastdmark: pop af  
42e7			endm  
# End of macro DMARK
42e7						CALLMONITOR 
42e7 cd 6c fe			call debug_vector  
42ea				endm  
# End of macro CALLMONITOR
42ea					endif 
42ea cd 9c 0d				call clear_display 
42ed c3 01 44				jp .home		; and home cursor 
42f0					NEXTW 
42f0 c3 b3 24			jp macro_next 
42f3				endm 
# End of macro NEXTW
42f3			 
42f3			.DRAW: 
42f3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
42f3 36				db WORD_SYS_CORE+34             
42f4 1e 43			dw .DUMP            
42f6 05				db 4 + 1 
42f7 .. 00			db "DRAW",0              
42fc				endm 
# End of macro CWHEAD
42fc			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
42fc					if DEBUG_FORTH_WORDS_KEY 
42fc						DMARK "DRW" 
42fc f5				push af  
42fd 3a 11 43			ld a, (.dmark)  
4300 32 68 fe			ld (debug_mark),a  
4303 3a 12 43			ld a, (.dmark+1)  
4306 32 69 fe			ld (debug_mark+1),a  
4309 3a 13 43			ld a, (.dmark+2)  
430c 32 6a fe			ld (debug_mark+2),a  
430f 18 03			jr .pastdmark  
4311 ..			.dmark: db "DRW"  
4314 f1			.pastdmark: pop af  
4315			endm  
# End of macro DMARK
4315						CALLMONITOR 
4315 cd 6c fe			call debug_vector  
4318				endm  
# End of macro CALLMONITOR
4318					endif 
4318 cd bf 0d				call update_display 
431b					NEXTW 
431b c3 b3 24			jp macro_next 
431e				endm 
# End of macro NEXTW
431e			 
431e			.DUMP: 
431e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
431e 37				db WORD_SYS_CORE+35             
431f 56 43			dw .CDUMP            
4321 05				db 4 + 1 
4322 .. 00			db "DUMP",0              
4327				endm 
# End of macro CWHEAD
4327			; | DUMP ( x -- ) With address x display dump   | DONE 
4327			; TODO pop address to use off of the stack 
4327					if DEBUG_FORTH_WORDS_KEY 
4327						DMARK "DUM" 
4327 f5				push af  
4328 3a 3c 43			ld a, (.dmark)  
432b 32 68 fe			ld (debug_mark),a  
432e 3a 3d 43			ld a, (.dmark+1)  
4331 32 69 fe			ld (debug_mark+1),a  
4334 3a 3e 43			ld a, (.dmark+2)  
4337 32 6a fe			ld (debug_mark+2),a  
433a 18 03			jr .pastdmark  
433c ..			.dmark: db "DUM"  
433f f1			.pastdmark: pop af  
4340			endm  
# End of macro DMARK
4340						CALLMONITOR 
4340 cd 6c fe			call debug_vector  
4343				endm  
# End of macro CALLMONITOR
4343					endif 
4343 cd 9c 0d				call clear_display 
4346			 
4346					; get address 
4346			 
4346					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4346 cd fd 22			call macro_dsp_valuehl 
4349				endm 
# End of macro FORTH_DSP_VALUEHL
4349				 
4349					; save it for cdump 
4349			 
4349 22 e1 f4				ld (os_cur_ptr),hl 
434c			 
434c					; destroy value TOS 
434c			 
434c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434c cd b5 23			call macro_forth_dsp_pop 
434f				endm 
# End of macro FORTH_DSP_POP
434f			 
434f cd 86 1f				call dumpcont	; skip old style of param parsing	 
4352 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4353					NEXTW 
4353 c3 b3 24			jp macro_next 
4356				endm 
# End of macro NEXTW
4356			.CDUMP: 
4356				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4356 38				db WORD_SYS_CORE+36             
4357 86 43			dw .DAT            
4359 06				db 5 + 1 
435a .. 00			db "CDUMP",0              
4360				endm 
# End of macro CWHEAD
4360			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4360					if DEBUG_FORTH_WORDS_KEY 
4360						DMARK "CDP" 
4360 f5				push af  
4361 3a 75 43			ld a, (.dmark)  
4364 32 68 fe			ld (debug_mark),a  
4367 3a 76 43			ld a, (.dmark+1)  
436a 32 69 fe			ld (debug_mark+1),a  
436d 3a 77 43			ld a, (.dmark+2)  
4370 32 6a fe			ld (debug_mark+2),a  
4373 18 03			jr .pastdmark  
4375 ..			.dmark: db "CDP"  
4378 f1			.pastdmark: pop af  
4379			endm  
# End of macro DMARK
4379						CALLMONITOR 
4379 cd 6c fe			call debug_vector  
437c				endm  
# End of macro CALLMONITOR
437c					endif 
437c cd 9c 0d				call clear_display 
437f cd 86 1f				call dumpcont	 
4382 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4383					NEXTW 
4383 c3 b3 24			jp macro_next 
4386				endm 
# End of macro NEXTW
4386			 
4386			 
4386			 
4386			 
4386			.DAT: 
4386				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4386 3d				db WORD_SYS_CORE+41             
4387 dc 43			dw .HOME            
4389 03				db 2 + 1 
438a .. 00			db "AT",0              
438d				endm 
# End of macro CWHEAD
438d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
438d					if DEBUG_FORTH_WORDS_KEY 
438d						DMARK "AT." 
438d f5				push af  
438e 3a a2 43			ld a, (.dmark)  
4391 32 68 fe			ld (debug_mark),a  
4394 3a a3 43			ld a, (.dmark+1)  
4397 32 69 fe			ld (debug_mark+1),a  
439a 3a a4 43			ld a, (.dmark+2)  
439d 32 6a fe			ld (debug_mark+2),a  
43a0 18 03			jr .pastdmark  
43a2 ..			.dmark: db "AT."  
43a5 f1			.pastdmark: pop af  
43a6			endm  
# End of macro DMARK
43a6						CALLMONITOR 
43a6 cd 6c fe			call debug_vector  
43a9				endm  
# End of macro CALLMONITOR
43a9					endif 
43a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a9 cd fd 22			call macro_dsp_valuehl 
43ac				endm 
# End of macro FORTH_DSP_VALUEHL
43ac			 
43ac			 
43ac					; TODO save cursor row 
43ac 7d					ld a,l 
43ad fe 02				cp 2 
43af 20 04				jr nz, .crow3 
43b1 3e 28				ld a, display_row_2 
43b3 18 12				jr .ccol1 
43b5 fe 03		.crow3:		cp 3 
43b7 20 04				jr nz, .crow4 
43b9 3e 50				ld a, display_row_3 
43bb 18 0a				jr .ccol1 
43bd fe 04		.crow4:		cp 4 
43bf 20 04				jr nz, .crow1 
43c1 3e 78				ld a, display_row_4 
43c3 18 02				jr .ccol1 
43c5 3e 00		.crow1:		ld a,display_row_1 
43c7 f5			.ccol1:		push af			; got row offset 
43c8 6f					ld l,a 
43c9 26 00				ld h,0 
43cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43cb cd b5 23			call macro_forth_dsp_pop 
43ce				endm 
# End of macro FORTH_DSP_POP
43ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ce cd fd 22			call macro_dsp_valuehl 
43d1				endm 
# End of macro FORTH_DSP_VALUEHL
43d1					; TODO save cursor col 
43d1 f1					pop af 
43d2 85					add l		; add col offset 
43d3 32 5b fa				ld (f_cursor_ptr), a 
43d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43d6 cd b5 23			call macro_forth_dsp_pop 
43d9				endm 
# End of macro FORTH_DSP_POP
43d9			 
43d9					; calculate  
43d9			 
43d9					NEXTW 
43d9 c3 b3 24			jp macro_next 
43dc				endm 
# End of macro NEXTW
43dc			 
43dc			 
43dc			.HOME: 
43dc				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
43dc 41				db WORD_SYS_CORE+45             
43dd 09 44			dw .SPACE            
43df 05				db 4 + 1 
43e0 .. 00			db "HOME",0              
43e5				endm 
# End of macro CWHEAD
43e5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
43e5					if DEBUG_FORTH_WORDS_KEY 
43e5						DMARK "HOM" 
43e5 f5				push af  
43e6 3a fa 43			ld a, (.dmark)  
43e9 32 68 fe			ld (debug_mark),a  
43ec 3a fb 43			ld a, (.dmark+1)  
43ef 32 69 fe			ld (debug_mark+1),a  
43f2 3a fc 43			ld a, (.dmark+2)  
43f5 32 6a fe			ld (debug_mark+2),a  
43f8 18 03			jr .pastdmark  
43fa ..			.dmark: db "HOM"  
43fd f1			.pastdmark: pop af  
43fe			endm  
# End of macro DMARK
43fe						CALLMONITOR 
43fe cd 6c fe			call debug_vector  
4401				endm  
# End of macro CALLMONITOR
4401					endif 
4401 3e 00		.home:		ld a, 0		; and home cursor 
4403 32 5b fa				ld (f_cursor_ptr), a 
4406					NEXTW 
4406 c3 b3 24			jp macro_next 
4409				endm 
# End of macro NEXTW
4409			 
4409			 
4409			.SPACE: 
4409				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4409 46				db WORD_SYS_CORE+50             
440a 3f 44			dw .SPACES            
440c 03				db 2 + 1 
440d .. 00			db "BL",0              
4410				endm 
# End of macro CWHEAD
4410			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4410					if DEBUG_FORTH_WORDS_KEY 
4410						DMARK "BL." 
4410 f5				push af  
4411 3a 25 44			ld a, (.dmark)  
4414 32 68 fe			ld (debug_mark),a  
4417 3a 26 44			ld a, (.dmark+1)  
441a 32 69 fe			ld (debug_mark+1),a  
441d 3a 27 44			ld a, (.dmark+2)  
4420 32 6a fe			ld (debug_mark+2),a  
4423 18 03			jr .pastdmark  
4425 ..			.dmark: db "BL."  
4428 f1			.pastdmark: pop af  
4429			endm  
# End of macro DMARK
4429						CALLMONITOR 
4429 cd 6c fe			call debug_vector  
442c				endm  
# End of macro CALLMONITOR
442c					endif 
442c 3e 20				ld a, " " 
442e 32 be f1				ld (scratch),a 
4431 3e 00				ld a, 0 
4433 32 bf f1				ld (scratch+1),a 
4436 21 be f1				ld hl, scratch 
4439 cd 74 21				call forth_push_str 
443c					 
443c				       NEXTW 
443c c3 b3 24			jp macro_next 
443f				endm 
# End of macro NEXTW
443f			 
443f			;.blstr: db " ", 0 
443f			 
443f			.SPACES: 
443f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
443f 47				db WORD_SYS_CORE+51             
4440 da 44			dw .SCROLL            
4442 07				db 6 + 1 
4443 .. 00			db "SPACES",0              
444a				endm 
# End of macro CWHEAD
444a			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
444a					if DEBUG_FORTH_WORDS_KEY 
444a						DMARK "SPS" 
444a f5				push af  
444b 3a 5f 44			ld a, (.dmark)  
444e 32 68 fe			ld (debug_mark),a  
4451 3a 60 44			ld a, (.dmark+1)  
4454 32 69 fe			ld (debug_mark+1),a  
4457 3a 61 44			ld a, (.dmark+2)  
445a 32 6a fe			ld (debug_mark+2),a  
445d 18 03			jr .pastdmark  
445f ..			.dmark: db "SPS"  
4462 f1			.pastdmark: pop af  
4463			endm  
# End of macro DMARK
4463						CALLMONITOR 
4463 cd 6c fe			call debug_vector  
4466				endm  
# End of macro CALLMONITOR
4466					endif 
4466			 
4466			 
4466					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4466 cd fd 22			call macro_dsp_valuehl 
4469				endm 
# End of macro FORTH_DSP_VALUEHL
4469			 
4469 e5					push hl    ; u 
446a					if DEBUG_FORTH_WORDS 
446a						DMARK "SPA" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 68 fe			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 69 fe			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 6a fe			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "SPA"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd 6c fe			call debug_vector  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486			 
4486					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4486 cd b5 23			call macro_forth_dsp_pop 
4489				endm 
# End of macro FORTH_DSP_POP
4489 e1					pop hl 
448a 0e 00				ld c, 0 
448c 45					ld b, l 
448d 21 be f1				ld hl, scratch  
4490			 
4490					if DEBUG_FORTH_WORDS 
4490						DMARK "SP2" 
4490 f5				push af  
4491 3a a5 44			ld a, (.dmark)  
4494 32 68 fe			ld (debug_mark),a  
4497 3a a6 44			ld a, (.dmark+1)  
449a 32 69 fe			ld (debug_mark+1),a  
449d 3a a7 44			ld a, (.dmark+2)  
44a0 32 6a fe			ld (debug_mark+2),a  
44a3 18 03			jr .pastdmark  
44a5 ..			.dmark: db "SP2"  
44a8 f1			.pastdmark: pop af  
44a9			endm  
# End of macro DMARK
44a9						CALLMONITOR 
44a9 cd 6c fe			call debug_vector  
44ac				endm  
# End of macro CALLMONITOR
44ac					endif 
44ac 3e 20				ld a, ' ' 
44ae			.spaces1:	 
44ae 77					ld (hl),a 
44af 23					inc hl 
44b0					 
44b0 10 fc				djnz .spaces1 
44b2 3e 00				ld a,0 
44b4 77					ld (hl),a 
44b5 21 be f1				ld hl, scratch 
44b8					if DEBUG_FORTH_WORDS 
44b8						DMARK "SP3" 
44b8 f5				push af  
44b9 3a cd 44			ld a, (.dmark)  
44bc 32 68 fe			ld (debug_mark),a  
44bf 3a ce 44			ld a, (.dmark+1)  
44c2 32 69 fe			ld (debug_mark+1),a  
44c5 3a cf 44			ld a, (.dmark+2)  
44c8 32 6a fe			ld (debug_mark+2),a  
44cb 18 03			jr .pastdmark  
44cd ..			.dmark: db "SP3"  
44d0 f1			.pastdmark: pop af  
44d1			endm  
# End of macro DMARK
44d1						CALLMONITOR 
44d1 cd 6c fe			call debug_vector  
44d4				endm  
# End of macro CALLMONITOR
44d4					endif 
44d4 cd 74 21				call forth_push_str 
44d7			 
44d7				       NEXTW 
44d7 c3 b3 24			jp macro_next 
44da				endm 
# End of macro NEXTW
44da			 
44da			 
44da			 
44da			.SCROLL: 
44da				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44da 53				db WORD_SYS_CORE+63             
44db 07 45			dw .SCROLLD            
44dd 07				db 6 + 1 
44de .. 00			db "SCROLL",0              
44e5				endm 
# End of macro CWHEAD
44e5			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44e5					if DEBUG_FORTH_WORDS_KEY 
44e5						DMARK "SCR" 
44e5 f5				push af  
44e6 3a fa 44			ld a, (.dmark)  
44e9 32 68 fe			ld (debug_mark),a  
44ec 3a fb 44			ld a, (.dmark+1)  
44ef 32 69 fe			ld (debug_mark+1),a  
44f2 3a fc 44			ld a, (.dmark+2)  
44f5 32 6a fe			ld (debug_mark+2),a  
44f8 18 03			jr .pastdmark  
44fa ..			.dmark: db "SCR"  
44fd f1			.pastdmark: pop af  
44fe			endm  
# End of macro DMARK
44fe						CALLMONITOR 
44fe cd 6c fe			call debug_vector  
4501				endm  
# End of macro CALLMONITOR
4501					endif 
4501			 
4501 cd 5e 0d			call scroll_up 
4504			;	call update_display 
4504			 
4504					NEXTW 
4504 c3 b3 24			jp macro_next 
4507				endm 
# End of macro NEXTW
4507			 
4507			 
4507			 
4507			;		; get dir 
4507			; 
4507			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4507			; 
4507			;		push hl 
4507			; 
4507			;		; destroy value TOS 
4507			; 
4507			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4507			; 
4507			;		; get count 
4507			; 
4507			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4507			; 
4507			;		push hl 
4507			; 
4507			;		; destroy value TOS 
4507			; 
4507			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4507			; 
4507			;		; one value on hl get other one back 
4507			; 
4507			;		pop bc    ; count 
4507			; 
4507			;		pop de   ; dir 
4507			; 
4507			; 
4507			;		ld b, c 
4507			; 
4507			;.scrolldir:     push bc 
4507			;		push de 
4507			; 
4507			;		ld a, 0 
4507			;		cp e 
4507			;		jr z, .scrollup  
4507			;		call scroll_down 
4507			;		jr .scrollnext 
4507			;.scrollup:	call scroll_up 
4507			; 
4507			;		 
4507			;.scrollnext: 
4507			;		pop de 
4507			;		pop bc 
4507			;		djnz .scrolldir 
4507			; 
4507			; 
4507			; 
4507			; 
4507			; 
4507			;		NEXTW 
4507			 
4507			.SCROLLD: 
4507				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4507 53				db WORD_SYS_CORE+63             
4508 35 45			dw .ATQ            
450a 08				db 7 + 1 
450b .. 00			db "SCROLLD",0              
4513				endm 
# End of macro CWHEAD
4513			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4513					if DEBUG_FORTH_WORDS_KEY 
4513						DMARK "SCD" 
4513 f5				push af  
4514 3a 28 45			ld a, (.dmark)  
4517 32 68 fe			ld (debug_mark),a  
451a 3a 29 45			ld a, (.dmark+1)  
451d 32 69 fe			ld (debug_mark+1),a  
4520 3a 2a 45			ld a, (.dmark+2)  
4523 32 6a fe			ld (debug_mark+2),a  
4526 18 03			jr .pastdmark  
4528 ..			.dmark: db "SCD"  
452b f1			.pastdmark: pop af  
452c			endm  
# End of macro DMARK
452c						CALLMONITOR 
452c cd 6c fe			call debug_vector  
452f				endm  
# End of macro CALLMONITOR
452f					endif 
452f			 
452f cd 82 0d			call scroll_down 
4532			;	call update_display 
4532			 
4532					NEXTW 
4532 c3 b3 24			jp macro_next 
4535				endm 
# End of macro NEXTW
4535			 
4535			 
4535			.ATQ: 
4535				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4535 62				db WORD_SYS_CORE+78             
4536 93 45			dw .AUTODSP            
4538 04				db 3 + 1 
4539 .. 00			db "AT@",0              
453d				endm 
# End of macro CWHEAD
453d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
453d					if DEBUG_FORTH_WORDS_KEY 
453d						DMARK "ATA" 
453d f5				push af  
453e 3a 52 45			ld a, (.dmark)  
4541 32 68 fe			ld (debug_mark),a  
4544 3a 53 45			ld a, (.dmark+1)  
4547 32 69 fe			ld (debug_mark+1),a  
454a 3a 54 45			ld a, (.dmark+2)  
454d 32 6a fe			ld (debug_mark+2),a  
4550 18 03			jr .pastdmark  
4552 ..			.dmark: db "ATA"  
4555 f1			.pastdmark: pop af  
4556			endm  
# End of macro DMARK
4556						CALLMONITOR 
4556 cd 6c fe			call debug_vector  
4559				endm  
# End of macro CALLMONITOR
4559					endif 
4559			 
4559			 
4559					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4559 cd fd 22			call macro_dsp_valuehl 
455c				endm 
# End of macro FORTH_DSP_VALUEHL
455c			 
455c					; TODO save cursor row 
455c 7d					ld a,l 
455d fe 02				cp 2 
455f 20 04				jr nz, .crow3aq 
4561 3e 28				ld a, display_row_2 
4563 18 12				jr .ccol1aq 
4565 fe 03		.crow3aq:		cp 3 
4567 20 04				jr nz, .crow4aq 
4569 3e 50				ld a, display_row_3 
456b 18 0a				jr .ccol1aq 
456d fe 04		.crow4aq:		cp 4 
456f 20 04				jr nz, .crow1aq 
4571 3e 78				ld a, display_row_4 
4573 18 02				jr .ccol1aq 
4575 3e 00		.crow1aq:		ld a,display_row_1 
4577 f5			.ccol1aq:		push af			; got row offset 
4578 6f					ld l,a 
4579 26 00				ld h,0 
457b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
457b cd b5 23			call macro_forth_dsp_pop 
457e				endm 
# End of macro FORTH_DSP_POP
457e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
457e cd fd 22			call macro_dsp_valuehl 
4581				endm 
# End of macro FORTH_DSP_VALUEHL
4581					; TODO save cursor col 
4581 f1					pop af 
4582 85					add l		; add col offset 
4583			 
4583					; add current frame buffer address 
4583 2a c9 fb				ld hl, (display_fb_active) 
4586 cd d0 0f				call addatohl 
4589			 
4589			 
4589			 
4589			 
4589					; get char frame buffer location offset in hl 
4589			 
4589 7e					ld a,(hl) 
458a 26 00				ld h, 0 
458c 6f					ld l, a 
458d			 
458d cd 06 21				call forth_push_numhl 
4590			 
4590			 
4590					NEXTW 
4590 c3 b3 24			jp macro_next 
4593				endm 
# End of macro NEXTW
4593			 
4593			.AUTODSP: 
4593				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4593 63				db WORD_SYS_CORE+79             
4594 a9 45			dw .MENU            
4596 05				db 4 + 1 
4597 .. 00			db "ADSP",0              
459c				endm 
# End of macro CWHEAD
459c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
459c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
459c			 
459c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
459c cd fd 22			call macro_dsp_valuehl 
459f				endm 
# End of macro FORTH_DSP_VALUEHL
459f			 
459f			;		push hl 
459f			 
459f					; destroy value TOS 
459f			 
459f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
459f cd b5 23			call macro_forth_dsp_pop 
45a2				endm 
# End of macro FORTH_DSP_POP
45a2			 
45a2			;		pop hl 
45a2			 
45a2 7d					ld a,l 
45a3 32 39 fa				ld (cli_autodisplay), a 
45a6				       NEXTW 
45a6 c3 b3 24			jp macro_next 
45a9				endm 
# End of macro NEXTW
45a9			 
45a9			.MENU: 
45a9				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45a9 70				db WORD_SYS_CORE+92             
45aa 52 46			dw .ENDDISPLAY            
45ac 05				db 4 + 1 
45ad .. 00			db "MENU",0              
45b2				endm 
# End of macro CWHEAD
45b2			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
45b2			 
45b2			;		; get number of items on the stack 
45b2			; 
45b2				 
45b2					FORTH_DSP_VALUEHL 
45b2 cd fd 22			call macro_dsp_valuehl 
45b5				endm 
# End of macro FORTH_DSP_VALUEHL
45b5				 
45b5					if DEBUG_FORTH_WORDS_KEY 
45b5						DMARK "MNU" 
45b5 f5				push af  
45b6 3a ca 45			ld a, (.dmark)  
45b9 32 68 fe			ld (debug_mark),a  
45bc 3a cb 45			ld a, (.dmark+1)  
45bf 32 69 fe			ld (debug_mark+1),a  
45c2 3a cc 45			ld a, (.dmark+2)  
45c5 32 6a fe			ld (debug_mark+2),a  
45c8 18 03			jr .pastdmark  
45ca ..			.dmark: db "MNU"  
45cd f1			.pastdmark: pop af  
45ce			endm  
# End of macro DMARK
45ce						CALLMONITOR 
45ce cd 6c fe			call debug_vector  
45d1				endm  
# End of macro CALLMONITOR
45d1					endif 
45d1			 
45d1 45					ld b, l	 
45d2 05					dec b 
45d3			 
45d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d3 cd b5 23			call macro_forth_dsp_pop 
45d6				endm 
# End of macro FORTH_DSP_POP
45d6			 
45d6			 
45d6					; go directly through the stack to pluck out the string pointers and build an array 
45d6			 
45d6			;		FORTH_DSP 
45d6			 
45d6					; hl contains top most stack item 
45d6				 
45d6 11 be f1				ld de, scratch 
45d9			 
45d9			.mbuild: 
45d9			 
45d9					FORTH_DSP_VALUEHL 
45d9 cd fd 22			call macro_dsp_valuehl 
45dc				endm 
# End of macro FORTH_DSP_VALUEHL
45dc			 
45dc					if DEBUG_FORTH_WORDS 
45dc						DMARK "MN3" 
45dc f5				push af  
45dd 3a f1 45			ld a, (.dmark)  
45e0 32 68 fe			ld (debug_mark),a  
45e3 3a f2 45			ld a, (.dmark+1)  
45e6 32 69 fe			ld (debug_mark+1),a  
45e9 3a f3 45			ld a, (.dmark+2)  
45ec 32 6a fe			ld (debug_mark+2),a  
45ef 18 03			jr .pastdmark  
45f1 ..			.dmark: db "MN3"  
45f4 f1			.pastdmark: pop af  
45f5			endm  
# End of macro DMARK
45f5						CALLMONITOR 
45f5 cd 6c fe			call debug_vector  
45f8				endm  
# End of macro CALLMONITOR
45f8					endif 
45f8 eb					ex de, hl 
45f9 73					ld (hl), e 
45fa 23					inc hl 
45fb 72					ld (hl), d 
45fc 23					inc hl 
45fd eb					ex de, hl 
45fe			 
45fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45fe cd b5 23			call macro_forth_dsp_pop 
4601				endm 
# End of macro FORTH_DSP_POP
4601			 
4601 10 d6				djnz .mbuild 
4603			 
4603					; done add term 
4603			 
4603 eb					ex de, hl 
4604 36 00				ld (hl), 0 
4606 23					inc hl 
4607 36 00				ld (hl), 0 
4609			 
4609				 
4609					 
4609 21 be f1				ld hl, scratch 
460c			 
460c					if DEBUG_FORTH_WORDS 
460c						DMARK "MNx" 
460c f5				push af  
460d 3a 21 46			ld a, (.dmark)  
4610 32 68 fe			ld (debug_mark),a  
4613 3a 22 46			ld a, (.dmark+1)  
4616 32 69 fe			ld (debug_mark+1),a  
4619 3a 23 46			ld a, (.dmark+2)  
461c 32 6a fe			ld (debug_mark+2),a  
461f 18 03			jr .pastdmark  
4621 ..			.dmark: db "MNx"  
4624 f1			.pastdmark: pop af  
4625			endm  
# End of macro DMARK
4625						CALLMONITOR 
4625 cd 6c fe			call debug_vector  
4628				endm  
# End of macro CALLMONITOR
4628					endif 
4628			 
4628			 
4628			 
4628 3e 00				ld a, 0 
462a cd cd 0d				call menu 
462d			 
462d			 
462d 6f					ld l, a 
462e 26 00				ld h, 0 
4630			 
4630					if DEBUG_FORTH_WORDS 
4630						DMARK "MNr" 
4630 f5				push af  
4631 3a 45 46			ld a, (.dmark)  
4634 32 68 fe			ld (debug_mark),a  
4637 3a 46 46			ld a, (.dmark+1)  
463a 32 69 fe			ld (debug_mark+1),a  
463d 3a 47 46			ld a, (.dmark+2)  
4640 32 6a fe			ld (debug_mark+2),a  
4643 18 03			jr .pastdmark  
4645 ..			.dmark: db "MNr"  
4648 f1			.pastdmark: pop af  
4649			endm  
# End of macro DMARK
4649						CALLMONITOR 
4649 cd 6c fe			call debug_vector  
464c				endm  
# End of macro CALLMONITOR
464c					endif 
464c			 
464c cd 06 21				call forth_push_numhl 
464f			 
464f			 
464f			 
464f			 
464f				       NEXTW 
464f c3 b3 24			jp macro_next 
4652				endm 
# End of macro NEXTW
4652			 
4652			 
4652			.ENDDISPLAY: 
4652			 
4652			; eof 
# End of file forth_words_display.asm
4652			include "forth_words_str.asm" 
4652			 
4652			; | ## String Words 
4652			 
4652			.PTR:   
4652			 
4652				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4652 48				db WORD_SYS_CORE+52             
4653 7f 46			dw .STYPE            
4655 04				db 3 + 1 
4656 .. 00			db "PTR",0              
465a				endm 
# End of macro CWHEAD
465a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
465a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
465a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
465a			 
465a					if DEBUG_FORTH_WORDS_KEY 
465a						DMARK "PTR" 
465a f5				push af  
465b 3a 6f 46			ld a, (.dmark)  
465e 32 68 fe			ld (debug_mark),a  
4661 3a 70 46			ld a, (.dmark+1)  
4664 32 69 fe			ld (debug_mark+1),a  
4667 3a 71 46			ld a, (.dmark+2)  
466a 32 6a fe			ld (debug_mark+2),a  
466d 18 03			jr .pastdmark  
466f ..			.dmark: db "PTR"  
4672 f1			.pastdmark: pop af  
4673			endm  
# End of macro DMARK
4673						CALLMONITOR 
4673 cd 6c fe			call debug_vector  
4676				endm  
# End of macro CALLMONITOR
4676					endif 
4676					FORTH_DSP_VALUEHL 
4676 cd fd 22			call macro_dsp_valuehl 
4679				endm 
# End of macro FORTH_DSP_VALUEHL
4679 cd 06 21				call forth_push_numhl 
467c			 
467c			 
467c					NEXTW 
467c c3 b3 24			jp macro_next 
467f				endm 
# End of macro NEXTW
467f			.STYPE: 
467f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
467f 48				db WORD_SYS_CORE+52             
4680 ce 46			dw .UPPER            
4682 06				db 5 + 1 
4683 .. 00			db "STYPE",0              
4689				endm 
# End of macro CWHEAD
4689			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4689					if DEBUG_FORTH_WORDS_KEY 
4689						DMARK "STY" 
4689 f5				push af  
468a 3a 9e 46			ld a, (.dmark)  
468d 32 68 fe			ld (debug_mark),a  
4690 3a 9f 46			ld a, (.dmark+1)  
4693 32 69 fe			ld (debug_mark+1),a  
4696 3a a0 46			ld a, (.dmark+2)  
4699 32 6a fe			ld (debug_mark+2),a  
469c 18 03			jr .pastdmark  
469e ..			.dmark: db "STY"  
46a1 f1			.pastdmark: pop af  
46a2			endm  
# End of macro DMARK
46a2						CALLMONITOR 
46a2 cd 6c fe			call debug_vector  
46a5				endm  
# End of macro CALLMONITOR
46a5					endif 
46a5					FORTH_DSP 
46a5 cd c3 22			call macro_forth_dsp 
46a8				endm 
# End of macro FORTH_DSP
46a8					;v5 FORTH_DSP_VALUE 
46a8			 
46a8 7e					ld a, (hl) 
46a9			 
46a9 f5					push af 
46aa			 
46aa			; Dont destroy TOS		FORTH_DSP_POP 
46aa			 
46aa f1					pop af 
46ab			 
46ab fe 01				cp DS_TYPE_STR 
46ad 28 09				jr z, .typestr 
46af			 
46af fe 02				cp DS_TYPE_INUM 
46b1 28 0a				jr z, .typeinum 
46b3			 
46b3 21 cc 46				ld hl, .tna 
46b6 18 0a				jr .tpush 
46b8			 
46b8 21 c8 46		.typestr:	ld hl, .tstr 
46bb 18 05				jr .tpush 
46bd 21 ca 46		.typeinum:	ld hl, .tinum 
46c0 18 00				jr .tpush 
46c2			 
46c2			.tpush: 
46c2			 
46c2 cd 74 21				call forth_push_str 
46c5			 
46c5					NEXTW 
46c5 c3 b3 24			jp macro_next 
46c8				endm 
# End of macro NEXTW
46c8 .. 00		.tstr:	db "s",0 
46ca .. 00		.tinum:  db "i",0 
46cc .. 00		.tna:   db "?", 0 
46ce			 
46ce			 
46ce			.UPPER: 
46ce				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46ce 48				db WORD_SYS_CORE+52             
46cf 09 47			dw .LOWER            
46d1 06				db 5 + 1 
46d2 .. 00			db "UPPER",0              
46d8				endm 
# End of macro CWHEAD
46d8			; | UPPER ( s -- s ) Upper case string s  | DONE 
46d8					if DEBUG_FORTH_WORDS_KEY 
46d8						DMARK "UPR" 
46d8 f5				push af  
46d9 3a ed 46			ld a, (.dmark)  
46dc 32 68 fe			ld (debug_mark),a  
46df 3a ee 46			ld a, (.dmark+1)  
46e2 32 69 fe			ld (debug_mark+1),a  
46e5 3a ef 46			ld a, (.dmark+2)  
46e8 32 6a fe			ld (debug_mark+2),a  
46eb 18 03			jr .pastdmark  
46ed ..			.dmark: db "UPR"  
46f0 f1			.pastdmark: pop af  
46f1			endm  
# End of macro DMARK
46f1						CALLMONITOR 
46f1 cd 6c fe			call debug_vector  
46f4				endm  
# End of macro CALLMONITOR
46f4					endif 
46f4			 
46f4					FORTH_DSP 
46f4 cd c3 22			call macro_forth_dsp 
46f7				endm 
# End of macro FORTH_DSP
46f7					 
46f7			; TODO check is string type 
46f7			 
46f7					FORTH_DSP_VALUEHL 
46f7 cd fd 22			call macro_dsp_valuehl 
46fa				endm 
# End of macro FORTH_DSP_VALUEHL
46fa			; get pointer to string in hl 
46fa			 
46fa 7e			.toup:		ld a, (hl) 
46fb fe 00				cp 0 
46fd 28 07				jr z, .toupdone 
46ff			 
46ff cd 3d 13				call to_upper 
4702			 
4702 77					ld (hl), a 
4703 23					inc hl 
4704 18 f4				jr .toup 
4706			 
4706					 
4706			 
4706			 
4706			; for each char convert to upper 
4706					 
4706			.toupdone: 
4706			 
4706			 
4706					NEXTW 
4706 c3 b3 24			jp macro_next 
4709				endm 
# End of macro NEXTW
4709			.LOWER: 
4709				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4709 48				db WORD_SYS_CORE+52             
470a 44 47			dw .TCASE            
470c 06				db 5 + 1 
470d .. 00			db "LOWER",0              
4713				endm 
# End of macro CWHEAD
4713			; | LOWER ( s -- s ) Lower case string s  | DONE 
4713					if DEBUG_FORTH_WORDS_KEY 
4713						DMARK "LWR" 
4713 f5				push af  
4714 3a 28 47			ld a, (.dmark)  
4717 32 68 fe			ld (debug_mark),a  
471a 3a 29 47			ld a, (.dmark+1)  
471d 32 69 fe			ld (debug_mark+1),a  
4720 3a 2a 47			ld a, (.dmark+2)  
4723 32 6a fe			ld (debug_mark+2),a  
4726 18 03			jr .pastdmark  
4728 ..			.dmark: db "LWR"  
472b f1			.pastdmark: pop af  
472c			endm  
# End of macro DMARK
472c						CALLMONITOR 
472c cd 6c fe			call debug_vector  
472f				endm  
# End of macro CALLMONITOR
472f					endif 
472f			 
472f					FORTH_DSP 
472f cd c3 22			call macro_forth_dsp 
4732				endm 
# End of macro FORTH_DSP
4732					 
4732			; TODO check is string type 
4732			 
4732					FORTH_DSP_VALUEHL 
4732 cd fd 22			call macro_dsp_valuehl 
4735				endm 
# End of macro FORTH_DSP_VALUEHL
4735			; get pointer to string in hl 
4735			 
4735 7e			.tolow:		ld a, (hl) 
4736 fe 00				cp 0 
4738 28 07				jr z, .tolowdone 
473a			 
473a cd 46 13				call to_lower 
473d			 
473d 77					ld (hl), a 
473e 23					inc hl 
473f 18 f4				jr .tolow 
4741			 
4741					 
4741			 
4741			 
4741			; for each char convert to low 
4741					 
4741			.tolowdone: 
4741					NEXTW 
4741 c3 b3 24			jp macro_next 
4744				endm 
# End of macro NEXTW
4744			.TCASE: 
4744				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4744 48				db WORD_SYS_CORE+52             
4745 7a 48			dw .SUBSTR            
4747 06				db 5 + 1 
4748 .. 00			db "TCASE",0              
474e				endm 
# End of macro CWHEAD
474e			; | TCASE ( s -- s ) Title case string s  | DONE 
474e					if DEBUG_FORTH_WORDS_KEY 
474e						DMARK "TCS" 
474e f5				push af  
474f 3a 63 47			ld a, (.dmark)  
4752 32 68 fe			ld (debug_mark),a  
4755 3a 64 47			ld a, (.dmark+1)  
4758 32 69 fe			ld (debug_mark+1),a  
475b 3a 65 47			ld a, (.dmark+2)  
475e 32 6a fe			ld (debug_mark+2),a  
4761 18 03			jr .pastdmark  
4763 ..			.dmark: db "TCS"  
4766 f1			.pastdmark: pop af  
4767			endm  
# End of macro DMARK
4767						CALLMONITOR 
4767 cd 6c fe			call debug_vector  
476a				endm  
# End of macro CALLMONITOR
476a					endif 
476a			 
476a					FORTH_DSP 
476a cd c3 22			call macro_forth_dsp 
476d				endm 
# End of macro FORTH_DSP
476d					 
476d			; TODO check is string type 
476d			 
476d					FORTH_DSP_VALUEHL 
476d cd fd 22			call macro_dsp_valuehl 
4770				endm 
# End of macro FORTH_DSP_VALUEHL
4770			; get pointer to string in hl 
4770			 
4770					if DEBUG_FORTH_WORDS 
4770						DMARK "TC1" 
4770 f5				push af  
4771 3a 85 47			ld a, (.dmark)  
4774 32 68 fe			ld (debug_mark),a  
4777 3a 86 47			ld a, (.dmark+1)  
477a 32 69 fe			ld (debug_mark+1),a  
477d 3a 87 47			ld a, (.dmark+2)  
4780 32 6a fe			ld (debug_mark+2),a  
4783 18 03			jr .pastdmark  
4785 ..			.dmark: db "TC1"  
4788 f1			.pastdmark: pop af  
4789			endm  
# End of macro DMARK
4789						CALLMONITOR 
4789 cd 6c fe			call debug_vector  
478c				endm  
# End of macro CALLMONITOR
478c					endif 
478c			 
478c					; first time in turn to upper case first char 
478c			 
478c 7e					ld a, (hl) 
478d c3 17 48				jp .totsiptou 
4790			 
4790			 
4790 7e			.tot:		ld a, (hl) 
4791 fe 00				cp 0 
4793 ca 5b 48				jp z, .totdone 
4796			 
4796					if DEBUG_FORTH_WORDS 
4796						DMARK "TC2" 
4796 f5				push af  
4797 3a ab 47			ld a, (.dmark)  
479a 32 68 fe			ld (debug_mark),a  
479d 3a ac 47			ld a, (.dmark+1)  
47a0 32 69 fe			ld (debug_mark+1),a  
47a3 3a ad 47			ld a, (.dmark+2)  
47a6 32 6a fe			ld (debug_mark+2),a  
47a9 18 03			jr .pastdmark  
47ab ..			.dmark: db "TC2"  
47ae f1			.pastdmark: pop af  
47af			endm  
# End of macro DMARK
47af						CALLMONITOR 
47af cd 6c fe			call debug_vector  
47b2				endm  
# End of macro CALLMONITOR
47b2					endif 
47b2					; check to see if current char is a space 
47b2			 
47b2 fe 20				cp ' ' 
47b4 28 21				jr z, .totsp 
47b6 cd 46 13				call to_lower 
47b9					if DEBUG_FORTH_WORDS 
47b9						DMARK "TC3" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 68 fe			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 69 fe			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 6a fe			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "TC3"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2						CALLMONITOR 
47d2 cd 6c fe			call debug_vector  
47d5				endm  
# End of macro CALLMONITOR
47d5					endif 
47d5 18 63				jr .totnxt 
47d7			 
47d7			.totsp:         ; on a space, find next char which should be upper 
47d7			 
47d7					if DEBUG_FORTH_WORDS 
47d7						DMARK "TC4" 
47d7 f5				push af  
47d8 3a ec 47			ld a, (.dmark)  
47db 32 68 fe			ld (debug_mark),a  
47de 3a ed 47			ld a, (.dmark+1)  
47e1 32 69 fe			ld (debug_mark+1),a  
47e4 3a ee 47			ld a, (.dmark+2)  
47e7 32 6a fe			ld (debug_mark+2),a  
47ea 18 03			jr .pastdmark  
47ec ..			.dmark: db "TC4"  
47ef f1			.pastdmark: pop af  
47f0			endm  
# End of macro DMARK
47f0						CALLMONITOR 
47f0 cd 6c fe			call debug_vector  
47f3				endm  
# End of macro CALLMONITOR
47f3					endif 
47f3					;; 
47f3			 
47f3 fe 20				cp ' ' 
47f5 20 20				jr nz, .totsiptou 
47f7 23					inc hl 
47f8 7e					ld a, (hl) 
47f9					if DEBUG_FORTH_WORDS 
47f9						DMARK "TC5" 
47f9 f5				push af  
47fa 3a 0e 48			ld a, (.dmark)  
47fd 32 68 fe			ld (debug_mark),a  
4800 3a 0f 48			ld a, (.dmark+1)  
4803 32 69 fe			ld (debug_mark+1),a  
4806 3a 10 48			ld a, (.dmark+2)  
4809 32 6a fe			ld (debug_mark+2),a  
480c 18 03			jr .pastdmark  
480e ..			.dmark: db "TC5"  
4811 f1			.pastdmark: pop af  
4812			endm  
# End of macro DMARK
4812						CALLMONITOR 
4812 cd 6c fe			call debug_vector  
4815				endm  
# End of macro CALLMONITOR
4815					endif 
4815 18 c0				jr .totsp 
4817 fe 00		.totsiptou:    cp 0 
4819 28 40				jr z, .totdone 
481b					; not space and not zero term so upper case it 
481b cd 3d 13				call to_upper 
481e			 
481e					if DEBUG_FORTH_WORDS 
481e						DMARK "TC6" 
481e f5				push af  
481f 3a 33 48			ld a, (.dmark)  
4822 32 68 fe			ld (debug_mark),a  
4825 3a 34 48			ld a, (.dmark+1)  
4828 32 69 fe			ld (debug_mark+1),a  
482b 3a 35 48			ld a, (.dmark+2)  
482e 32 6a fe			ld (debug_mark+2),a  
4831 18 03			jr .pastdmark  
4833 ..			.dmark: db "TC6"  
4836 f1			.pastdmark: pop af  
4837			endm  
# End of macro DMARK
4837						CALLMONITOR 
4837 cd 6c fe			call debug_vector  
483a				endm  
# End of macro CALLMONITOR
483a					endif 
483a			 
483a			 
483a			.totnxt: 
483a			 
483a 77					ld (hl), a 
483b 23					inc hl 
483c					if DEBUG_FORTH_WORDS 
483c						DMARK "TC7" 
483c f5				push af  
483d 3a 51 48			ld a, (.dmark)  
4840 32 68 fe			ld (debug_mark),a  
4843 3a 52 48			ld a, (.dmark+1)  
4846 32 69 fe			ld (debug_mark+1),a  
4849 3a 53 48			ld a, (.dmark+2)  
484c 32 6a fe			ld (debug_mark+2),a  
484f 18 03			jr .pastdmark  
4851 ..			.dmark: db "TC7"  
4854 f1			.pastdmark: pop af  
4855			endm  
# End of macro DMARK
4855						CALLMONITOR 
4855 cd 6c fe			call debug_vector  
4858				endm  
# End of macro CALLMONITOR
4858					endif 
4858 c3 90 47				jp .tot 
485b			 
485b					 
485b			 
485b			 
485b			; for each char convert to low 
485b					 
485b			.totdone: 
485b					if DEBUG_FORTH_WORDS 
485b						DMARK "TCd" 
485b f5				push af  
485c 3a 70 48			ld a, (.dmark)  
485f 32 68 fe			ld (debug_mark),a  
4862 3a 71 48			ld a, (.dmark+1)  
4865 32 69 fe			ld (debug_mark+1),a  
4868 3a 72 48			ld a, (.dmark+2)  
486b 32 6a fe			ld (debug_mark+2),a  
486e 18 03			jr .pastdmark  
4870 ..			.dmark: db "TCd"  
4873 f1			.pastdmark: pop af  
4874			endm  
# End of macro DMARK
4874						CALLMONITOR 
4874 cd 6c fe			call debug_vector  
4877				endm  
# End of macro CALLMONITOR
4877					endif 
4877					NEXTW 
4877 c3 b3 24			jp macro_next 
487a				endm 
# End of macro NEXTW
487a			 
487a			.SUBSTR: 
487a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
487a 48				db WORD_SYS_CORE+52             
487b d8 48			dw .LEFT            
487d 07				db 6 + 1 
487e .. 00			db "SUBSTR",0              
4885				endm 
# End of macro CWHEAD
4885			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4885			 
4885					if DEBUG_FORTH_WORDS_KEY 
4885						DMARK "SST" 
4885 f5				push af  
4886 3a 9a 48			ld a, (.dmark)  
4889 32 68 fe			ld (debug_mark),a  
488c 3a 9b 48			ld a, (.dmark+1)  
488f 32 69 fe			ld (debug_mark+1),a  
4892 3a 9c 48			ld a, (.dmark+2)  
4895 32 6a fe			ld (debug_mark+2),a  
4898 18 03			jr .pastdmark  
489a ..			.dmark: db "SST"  
489d f1			.pastdmark: pop af  
489e			endm  
# End of macro DMARK
489e						CALLMONITOR 
489e cd 6c fe			call debug_vector  
48a1				endm  
# End of macro CALLMONITOR
48a1					endif 
48a1			; TODO check string type 
48a1					FORTH_DSP_VALUEHL 
48a1 cd fd 22			call macro_dsp_valuehl 
48a4				endm 
# End of macro FORTH_DSP_VALUEHL
48a4			 
48a4 e5					push hl      ; string length 
48a5			 
48a5					FORTH_DSP_POP 
48a5 cd b5 23			call macro_forth_dsp_pop 
48a8				endm 
# End of macro FORTH_DSP_POP
48a8			 
48a8					FORTH_DSP_VALUEHL 
48a8 cd fd 22			call macro_dsp_valuehl 
48ab				endm 
# End of macro FORTH_DSP_VALUEHL
48ab			 
48ab e5					push hl     ; start char 
48ac			 
48ac					FORTH_DSP_POP 
48ac cd b5 23			call macro_forth_dsp_pop 
48af				endm 
# End of macro FORTH_DSP_POP
48af			 
48af			 
48af					FORTH_DSP_VALUE 
48af cd e6 22			call macro_forth_dsp_value 
48b2				endm 
# End of macro FORTH_DSP_VALUE
48b2			 
48b2 d1					pop de    ; get start post offset 
48b3			 
48b3 19					add hl, de    ; starting offset 
48b4			 
48b4 c1					pop bc 
48b5 c5					push bc      ; grab size of string 
48b6			 
48b6 e5					push hl    ; save string start  
48b7			 
48b7 26 00				ld h, 0 
48b9 69					ld l, c 
48ba 23					inc hl 
48bb 23					inc hl 
48bc			 
48bc cd 97 14				call malloc 
48bf				if DEBUG_FORTH_MALLOC_GUARD 
48bf cc 05 5e				call z,malloc_error 
48c2				endif 
48c2			 
48c2 eb					ex de, hl      ; save malloc area for string copy 
48c3 e1					pop hl    ; get back source 
48c4 c1					pop bc    ; get length of string back 
48c5			 
48c5 d5					push de    ; save malloc area for after we push 
48c6 ed b0				ldir     ; copy substr 
48c8			 
48c8			 
48c8 eb					ex de, hl 
48c9 3e 00				ld a, 0 
48cb 77					ld (hl), a   ; term substr 
48cc			 
48cc					 
48cc e1					pop hl    ; get malloc so we can push it 
48cd e5					push hl   ; save so we can free it afterwards 
48ce			 
48ce cd 74 21				call forth_push_str 
48d1			 
48d1 e1					pop hl 
48d2 cd 61 15				call free 
48d5			 
48d5					 
48d5					 
48d5			 
48d5			 
48d5					NEXTW 
48d5 c3 b3 24			jp macro_next 
48d8				endm 
# End of macro NEXTW
48d8			 
48d8			.LEFT: 
48d8				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48d8 48				db WORD_SYS_CORE+52             
48d9 00 49			dw .RIGHT            
48db 05				db 4 + 1 
48dc .. 00			db "LEFT",0              
48e1				endm 
# End of macro CWHEAD
48e1			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48e1					if DEBUG_FORTH_WORDS_KEY 
48e1						DMARK "LEF" 
48e1 f5				push af  
48e2 3a f6 48			ld a, (.dmark)  
48e5 32 68 fe			ld (debug_mark),a  
48e8 3a f7 48			ld a, (.dmark+1)  
48eb 32 69 fe			ld (debug_mark+1),a  
48ee 3a f8 48			ld a, (.dmark+2)  
48f1 32 6a fe			ld (debug_mark+2),a  
48f4 18 03			jr .pastdmark  
48f6 ..			.dmark: db "LEF"  
48f9 f1			.pastdmark: pop af  
48fa			endm  
# End of macro DMARK
48fa						CALLMONITOR 
48fa cd 6c fe			call debug_vector  
48fd				endm  
# End of macro CALLMONITOR
48fd					endif 
48fd			 
48fd					NEXTW 
48fd c3 b3 24			jp macro_next 
4900				endm 
# End of macro NEXTW
4900			.RIGHT: 
4900				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4900 48				db WORD_SYS_CORE+52             
4901 29 49			dw .STR2NUM            
4903 06				db 5 + 1 
4904 .. 00			db "RIGHT",0              
490a				endm 
# End of macro CWHEAD
490a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
490a					if DEBUG_FORTH_WORDS_KEY 
490a						DMARK "RIG" 
490a f5				push af  
490b 3a 1f 49			ld a, (.dmark)  
490e 32 68 fe			ld (debug_mark),a  
4911 3a 20 49			ld a, (.dmark+1)  
4914 32 69 fe			ld (debug_mark+1),a  
4917 3a 21 49			ld a, (.dmark+2)  
491a 32 6a fe			ld (debug_mark+2),a  
491d 18 03			jr .pastdmark  
491f ..			.dmark: db "RIG"  
4922 f1			.pastdmark: pop af  
4923			endm  
# End of macro DMARK
4923						CALLMONITOR 
4923 cd 6c fe			call debug_vector  
4926				endm  
# End of macro CALLMONITOR
4926					endif 
4926			 
4926					NEXTW 
4926 c3 b3 24			jp macro_next 
4929				endm 
# End of macro NEXTW
4929			 
4929			 
4929			.STR2NUM: 
4929				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4929 48				db WORD_SYS_CORE+52             
492a b5 49			dw .NUM2STR            
492c 08				db 7 + 1 
492d .. 00			db "STR2NUM",0              
4935				endm 
# End of macro CWHEAD
4935			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4935			 
4935			 
4935			; TODO STR type check to do 
4935					if DEBUG_FORTH_WORDS_KEY 
4935						DMARK "S2N" 
4935 f5				push af  
4936 3a 4a 49			ld a, (.dmark)  
4939 32 68 fe			ld (debug_mark),a  
493c 3a 4b 49			ld a, (.dmark+1)  
493f 32 69 fe			ld (debug_mark+1),a  
4942 3a 4c 49			ld a, (.dmark+2)  
4945 32 6a fe			ld (debug_mark+2),a  
4948 18 03			jr .pastdmark  
494a ..			.dmark: db "S2N"  
494d f1			.pastdmark: pop af  
494e			endm  
# End of macro DMARK
494e						CALLMONITOR 
494e cd 6c fe			call debug_vector  
4951				endm  
# End of macro CALLMONITOR
4951					endif 
4951			 
4951					;FORTH_DSP 
4951					FORTH_DSP_VALUE 
4951 cd e6 22			call macro_forth_dsp_value 
4954				endm 
# End of macro FORTH_DSP_VALUE
4954					;inc hl 
4954			 
4954 eb					ex de, hl 
4955					if DEBUG_FORTH_WORDS 
4955						DMARK "S2a" 
4955 f5				push af  
4956 3a 6a 49			ld a, (.dmark)  
4959 32 68 fe			ld (debug_mark),a  
495c 3a 6b 49			ld a, (.dmark+1)  
495f 32 69 fe			ld (debug_mark+1),a  
4962 3a 6c 49			ld a, (.dmark+2)  
4965 32 6a fe			ld (debug_mark+2),a  
4968 18 03			jr .pastdmark  
496a ..			.dmark: db "S2a"  
496d f1			.pastdmark: pop af  
496e			endm  
# End of macro DMARK
496e						CALLMONITOR 
496e cd 6c fe			call debug_vector  
4971				endm  
# End of macro CALLMONITOR
4971					endif 
4971 cd c5 13				call string_to_uint16 
4974			 
4974					if DEBUG_FORTH_WORDS 
4974						DMARK "S2b" 
4974 f5				push af  
4975 3a 89 49			ld a, (.dmark)  
4978 32 68 fe			ld (debug_mark),a  
497b 3a 8a 49			ld a, (.dmark+1)  
497e 32 69 fe			ld (debug_mark+1),a  
4981 3a 8b 49			ld a, (.dmark+2)  
4984 32 6a fe			ld (debug_mark+2),a  
4987 18 03			jr .pastdmark  
4989 ..			.dmark: db "S2b"  
498c f1			.pastdmark: pop af  
498d			endm  
# End of macro DMARK
498d						CALLMONITOR 
498d cd 6c fe			call debug_vector  
4990				endm  
# End of macro CALLMONITOR
4990					endif 
4990			;		push hl 
4990					FORTH_DSP_POP 
4990 cd b5 23			call macro_forth_dsp_pop 
4993				endm 
# End of macro FORTH_DSP_POP
4993			;		pop hl 
4993					 
4993					if DEBUG_FORTH_WORDS 
4993						DMARK "S2b" 
4993 f5				push af  
4994 3a a8 49			ld a, (.dmark)  
4997 32 68 fe			ld (debug_mark),a  
499a 3a a9 49			ld a, (.dmark+1)  
499d 32 69 fe			ld (debug_mark+1),a  
49a0 3a aa 49			ld a, (.dmark+2)  
49a3 32 6a fe			ld (debug_mark+2),a  
49a6 18 03			jr .pastdmark  
49a8 ..			.dmark: db "S2b"  
49ab f1			.pastdmark: pop af  
49ac			endm  
# End of macro DMARK
49ac						CALLMONITOR 
49ac cd 6c fe			call debug_vector  
49af				endm  
# End of macro CALLMONITOR
49af					endif 
49af cd 06 21				call forth_push_numhl	 
49b2			 
49b2				 
49b2				       NEXTW 
49b2 c3 b3 24			jp macro_next 
49b5				endm 
# End of macro NEXTW
49b5			.NUM2STR: 
49b5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49b5 48				db WORD_SYS_CORE+52             
49b6 c4 49			dw .CONCAT            
49b8 08				db 7 + 1 
49b9 .. 00			db "NUM2STR",0              
49c1				endm 
# End of macro CWHEAD
49c1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
49c1			 
49c1			;		; malloc a string to target 
49c1			;		ld hl, 10     ; TODO max string size should be fine 
49c1			;		call malloc 
49c1			;		push hl    ; save malloc location 
49c1			; 
49c1			; 
49c1			;; TODO check int type 
49c1			;		FORTH_DSP_VALUEHL 
49c1			;		ld a, l 
49c1			;		call DispAToASCII   
49c1			;;TODO need to chage above call to dump into string 
49c1			; 
49c1			; 
49c1			 
49c1				       NEXTW 
49c1 c3 b3 24			jp macro_next 
49c4				endm 
# End of macro NEXTW
49c4			 
49c4			.CONCAT: 
49c4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49c4 48				db WORD_SYS_CORE+52             
49c5 77 4a			dw .FIND            
49c7 07				db 6 + 1 
49c8 .. 00			db "CONCAT",0              
49cf				endm 
# End of macro CWHEAD
49cf			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49cf			 
49cf			; TODO check string type 
49cf			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49cf			 
49cf					if DEBUG_FORTH_WORDS_KEY 
49cf						DMARK "CON" 
49cf f5				push af  
49d0 3a e4 49			ld a, (.dmark)  
49d3 32 68 fe			ld (debug_mark),a  
49d6 3a e5 49			ld a, (.dmark+1)  
49d9 32 69 fe			ld (debug_mark+1),a  
49dc 3a e6 49			ld a, (.dmark+2)  
49df 32 6a fe			ld (debug_mark+2),a  
49e2 18 03			jr .pastdmark  
49e4 ..			.dmark: db "CON"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd 6c fe			call debug_vector  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb			 
49eb			 
49eb					FORTH_DSP_VALUE 
49eb cd e6 22			call macro_forth_dsp_value 
49ee				endm 
# End of macro FORTH_DSP_VALUE
49ee e5					push hl   ; s2 
49ef			 
49ef					FORTH_DSP_POP 
49ef cd b5 23			call macro_forth_dsp_pop 
49f2				endm 
# End of macro FORTH_DSP_POP
49f2			 
49f2					FORTH_DSP_VALUE 
49f2 cd e6 22			call macro_forth_dsp_value 
49f5				endm 
# End of macro FORTH_DSP_VALUE
49f5			 
49f5 e5					push hl   ; s1 
49f6			 
49f6					FORTH_DSP_POP 
49f6 cd b5 23			call macro_forth_dsp_pop 
49f9				endm 
# End of macro FORTH_DSP_POP
49f9					 
49f9			 
49f9					; copy s1 
49f9			 
49f9				 
49f9					; save ptr 
49f9 e1					pop hl  
49fa e5					push hl 
49fb 3e 00				ld a, 0 
49fd cd 39 14				call strlent 
4a00					;inc hl    ; zer0 
4a00 06 00				ld b, 0 
4a02 4d					ld c, l 
4a03 e1					pop hl		 
4a04 11 be f1				ld de, scratch	 
4a07					if DEBUG_FORTH_WORDS 
4a07						DMARK "CO1" 
4a07 f5				push af  
4a08 3a 1c 4a			ld a, (.dmark)  
4a0b 32 68 fe			ld (debug_mark),a  
4a0e 3a 1d 4a			ld a, (.dmark+1)  
4a11 32 69 fe			ld (debug_mark+1),a  
4a14 3a 1e 4a			ld a, (.dmark+2)  
4a17 32 6a fe			ld (debug_mark+2),a  
4a1a 18 03			jr .pastdmark  
4a1c ..			.dmark: db "CO1"  
4a1f f1			.pastdmark: pop af  
4a20			endm  
# End of macro DMARK
4a20						CALLMONITOR 
4a20 cd 6c fe			call debug_vector  
4a23				endm  
# End of macro CALLMONITOR
4a23					endif 
4a23 ed b0				ldir 
4a25			 
4a25 e1					pop hl 
4a26 e5					push hl 
4a27 d5					push de 
4a28			 
4a28			 
4a28 3e 00				ld a, 0 
4a2a cd 39 14				call strlent 
4a2d 23					inc hl    ; zer0 
4a2e 23					inc hl 
4a2f 06 00				ld b, 0 
4a31 4d					ld c, l 
4a32 d1					pop de 
4a33 e1					pop hl		 
4a34					if DEBUG_FORTH_WORDS 
4a34						DMARK "CO2" 
4a34 f5				push af  
4a35 3a 49 4a			ld a, (.dmark)  
4a38 32 68 fe			ld (debug_mark),a  
4a3b 3a 4a 4a			ld a, (.dmark+1)  
4a3e 32 69 fe			ld (debug_mark+1),a  
4a41 3a 4b 4a			ld a, (.dmark+2)  
4a44 32 6a fe			ld (debug_mark+2),a  
4a47 18 03			jr .pastdmark  
4a49 ..			.dmark: db "CO2"  
4a4c f1			.pastdmark: pop af  
4a4d			endm  
# End of macro DMARK
4a4d						CALLMONITOR 
4a4d cd 6c fe			call debug_vector  
4a50				endm  
# End of macro CALLMONITOR
4a50					endif 
4a50 ed b0				ldir 
4a52			 
4a52			 
4a52			 
4a52 21 be f1				ld hl, scratch 
4a55					if DEBUG_FORTH_WORDS 
4a55						DMARK "CO5" 
4a55 f5				push af  
4a56 3a 6a 4a			ld a, (.dmark)  
4a59 32 68 fe			ld (debug_mark),a  
4a5c 3a 6b 4a			ld a, (.dmark+1)  
4a5f 32 69 fe			ld (debug_mark+1),a  
4a62 3a 6c 4a			ld a, (.dmark+2)  
4a65 32 6a fe			ld (debug_mark+2),a  
4a68 18 03			jr .pastdmark  
4a6a ..			.dmark: db "CO5"  
4a6d f1			.pastdmark: pop af  
4a6e			endm  
# End of macro DMARK
4a6e						CALLMONITOR 
4a6e cd 6c fe			call debug_vector  
4a71				endm  
# End of macro CALLMONITOR
4a71					endif 
4a71			 
4a71 cd 74 21				call forth_push_str 
4a74			 
4a74			 
4a74			 
4a74			 
4a74				       NEXTW 
4a74 c3 b3 24			jp macro_next 
4a77				endm 
# End of macro NEXTW
4a77			 
4a77			 
4a77			.FIND: 
4a77				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a77 4b				db WORD_SYS_CORE+55             
4a78 35 4b			dw .LEN            
4a7a 05				db 4 + 1 
4a7b .. 00			db "FIND",0              
4a80				endm 
# End of macro CWHEAD
4a80			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a80			 
4a80					if DEBUG_FORTH_WORDS_KEY 
4a80						DMARK "FND" 
4a80 f5				push af  
4a81 3a 95 4a			ld a, (.dmark)  
4a84 32 68 fe			ld (debug_mark),a  
4a87 3a 96 4a			ld a, (.dmark+1)  
4a8a 32 69 fe			ld (debug_mark+1),a  
4a8d 3a 97 4a			ld a, (.dmark+2)  
4a90 32 6a fe			ld (debug_mark+2),a  
4a93 18 03			jr .pastdmark  
4a95 ..			.dmark: db "FND"  
4a98 f1			.pastdmark: pop af  
4a99			endm  
# End of macro DMARK
4a99						CALLMONITOR 
4a99 cd 6c fe			call debug_vector  
4a9c				endm  
# End of macro CALLMONITOR
4a9c					endif 
4a9c			 
4a9c			; TODO check string type 
4a9c					FORTH_DSP_VALUE 
4a9c cd e6 22			call macro_forth_dsp_value 
4a9f				endm 
# End of macro FORTH_DSP_VALUE
4a9f			 
4a9f e5					push hl    
4aa0 7e					ld a,(hl)    ; char to find   
4aa1			; TODO change char to substr 
4aa1			 
4aa1 f5					push af 
4aa2					 
4aa2			 
4aa2			 
4aa2					if DEBUG_FORTH_WORDS 
4aa2						DMARK "FN1" 
4aa2 f5				push af  
4aa3 3a b7 4a			ld a, (.dmark)  
4aa6 32 68 fe			ld (debug_mark),a  
4aa9 3a b8 4a			ld a, (.dmark+1)  
4aac 32 69 fe			ld (debug_mark+1),a  
4aaf 3a b9 4a			ld a, (.dmark+2)  
4ab2 32 6a fe			ld (debug_mark+2),a  
4ab5 18 03			jr .pastdmark  
4ab7 ..			.dmark: db "FN1"  
4aba f1			.pastdmark: pop af  
4abb			endm  
# End of macro DMARK
4abb						CALLMONITOR 
4abb cd 6c fe			call debug_vector  
4abe				endm  
# End of macro CALLMONITOR
4abe					endif 
4abe			 
4abe					FORTH_DSP_POP 
4abe cd b5 23			call macro_forth_dsp_pop 
4ac1				endm 
# End of macro FORTH_DSP_POP
4ac1			 
4ac1					; string to search 
4ac1			 
4ac1					FORTH_DSP_VALUE 
4ac1 cd e6 22			call macro_forth_dsp_value 
4ac4				endm 
# End of macro FORTH_DSP_VALUE
4ac4			 
4ac4 d1					pop de  ; d is char to find  
4ac5			 
4ac5					if DEBUG_FORTH_WORDS 
4ac5						DMARK "FN2" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 68 fe			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 69 fe			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 6a fe			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "FN2"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd 6c fe			call debug_vector  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1					 
4ae1 01 00 00				ld bc, 0 
4ae4 7e			.findchar:      ld a,(hl) 
4ae5 fe 00				cp 0   		 
4ae7 28 27				jr z, .finddone     
4ae9 ba					cp d 
4aea 28 20				jr z, .foundchar 
4aec 03					inc bc 
4aed 23					inc hl 
4aee					if DEBUG_FORTH_WORDS 
4aee						DMARK "FN3" 
4aee f5				push af  
4aef 3a 03 4b			ld a, (.dmark)  
4af2 32 68 fe			ld (debug_mark),a  
4af5 3a 04 4b			ld a, (.dmark+1)  
4af8 32 69 fe			ld (debug_mark+1),a  
4afb 3a 05 4b			ld a, (.dmark+2)  
4afe 32 6a fe			ld (debug_mark+2),a  
4b01 18 03			jr .pastdmark  
4b03 ..			.dmark: db "FN3"  
4b06 f1			.pastdmark: pop af  
4b07			endm  
# End of macro DMARK
4b07						CALLMONITOR 
4b07 cd 6c fe			call debug_vector  
4b0a				endm  
# End of macro CALLMONITOR
4b0a					endif 
4b0a 18 d8				jr .findchar 
4b0c			 
4b0c			 
4b0c c5			.foundchar:	push bc 
4b0d e1					pop hl 
4b0e 18 03				jr .findexit 
4b10			 
4b10			 
4b10							 
4b10			 
4b10			.finddone:     ; got to end of string with no find 
4b10 21 00 00				ld hl, 0 
4b13			.findexit: 
4b13			 
4b13					if DEBUG_FORTH_WORDS 
4b13						DMARK "FNd" 
4b13 f5				push af  
4b14 3a 28 4b			ld a, (.dmark)  
4b17 32 68 fe			ld (debug_mark),a  
4b1a 3a 29 4b			ld a, (.dmark+1)  
4b1d 32 69 fe			ld (debug_mark+1),a  
4b20 3a 2a 4b			ld a, (.dmark+2)  
4b23 32 6a fe			ld (debug_mark+2),a  
4b26 18 03			jr .pastdmark  
4b28 ..			.dmark: db "FNd"  
4b2b f1			.pastdmark: pop af  
4b2c			endm  
# End of macro DMARK
4b2c						CALLMONITOR 
4b2c cd 6c fe			call debug_vector  
4b2f				endm  
# End of macro CALLMONITOR
4b2f					endif 
4b2f cd 06 21			call forth_push_numhl 
4b32			 
4b32				       NEXTW 
4b32 c3 b3 24			jp macro_next 
4b35				endm 
# End of macro NEXTW
4b35			 
4b35			.LEN: 
4b35				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b35 4c				db WORD_SYS_CORE+56             
4b36 9f 4b			dw .ASC            
4b38 06				db 5 + 1 
4b39 .. 00			db "COUNT",0              
4b3f				endm 
# End of macro CWHEAD
4b3f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b3f			 
4b3f					if DEBUG_FORTH_WORDS_KEY 
4b3f						DMARK "CNT" 
4b3f f5				push af  
4b40 3a 54 4b			ld a, (.dmark)  
4b43 32 68 fe			ld (debug_mark),a  
4b46 3a 55 4b			ld a, (.dmark+1)  
4b49 32 69 fe			ld (debug_mark+1),a  
4b4c 3a 56 4b			ld a, (.dmark+2)  
4b4f 32 6a fe			ld (debug_mark+2),a  
4b52 18 03			jr .pastdmark  
4b54 ..			.dmark: db "CNT"  
4b57 f1			.pastdmark: pop af  
4b58			endm  
# End of macro DMARK
4b58						CALLMONITOR 
4b58 cd 6c fe			call debug_vector  
4b5b				endm  
# End of macro CALLMONITOR
4b5b					endif 
4b5b			; TODO check string type 
4b5b					FORTH_DSP_VALUE 
4b5b cd e6 22			call macro_forth_dsp_value 
4b5e				endm 
# End of macro FORTH_DSP_VALUE
4b5e			 
4b5e			 
4b5e					if DEBUG_FORTH_WORDS 
4b5e						DMARK "CN?" 
4b5e f5				push af  
4b5f 3a 73 4b			ld a, (.dmark)  
4b62 32 68 fe			ld (debug_mark),a  
4b65 3a 74 4b			ld a, (.dmark+1)  
4b68 32 69 fe			ld (debug_mark+1),a  
4b6b 3a 75 4b			ld a, (.dmark+2)  
4b6e 32 6a fe			ld (debug_mark+2),a  
4b71 18 03			jr .pastdmark  
4b73 ..			.dmark: db "CN?"  
4b76 f1			.pastdmark: pop af  
4b77			endm  
# End of macro DMARK
4b77						CALLMONITOR 
4b77 cd 6c fe			call debug_vector  
4b7a				endm  
# End of macro CALLMONITOR
4b7a					endif 
4b7a cd 2e 14				call strlenz 
4b7d					if DEBUG_FORTH_WORDS 
4b7d						DMARK "CNl" 
4b7d f5				push af  
4b7e 3a 92 4b			ld a, (.dmark)  
4b81 32 68 fe			ld (debug_mark),a  
4b84 3a 93 4b			ld a, (.dmark+1)  
4b87 32 69 fe			ld (debug_mark+1),a  
4b8a 3a 94 4b			ld a, (.dmark+2)  
4b8d 32 6a fe			ld (debug_mark+2),a  
4b90 18 03			jr .pastdmark  
4b92 ..			.dmark: db "CNl"  
4b95 f1			.pastdmark: pop af  
4b96			endm  
# End of macro DMARK
4b96						CALLMONITOR 
4b96 cd 6c fe			call debug_vector  
4b99				endm  
# End of macro CALLMONITOR
4b99					endif 
4b99			 
4b99 cd 06 21				call forth_push_numhl 
4b9c			 
4b9c			 
4b9c			 
4b9c				       NEXTW 
4b9c c3 b3 24			jp macro_next 
4b9f				endm 
# End of macro NEXTW
4b9f			.ASC: 
4b9f				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b9f 4d				db WORD_SYS_CORE+57             
4ba0 0d 4c			dw .CHR            
4ba2 04				db 3 + 1 
4ba3 .. 00			db "ASC",0              
4ba7				endm 
# End of macro CWHEAD
4ba7			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4ba7					if DEBUG_FORTH_WORDS_KEY 
4ba7						DMARK "ASC" 
4ba7 f5				push af  
4ba8 3a bc 4b			ld a, (.dmark)  
4bab 32 68 fe			ld (debug_mark),a  
4bae 3a bd 4b			ld a, (.dmark+1)  
4bb1 32 69 fe			ld (debug_mark+1),a  
4bb4 3a be 4b			ld a, (.dmark+2)  
4bb7 32 6a fe			ld (debug_mark+2),a  
4bba 18 03			jr .pastdmark  
4bbc ..			.dmark: db "ASC"  
4bbf f1			.pastdmark: pop af  
4bc0			endm  
# End of macro DMARK
4bc0						CALLMONITOR 
4bc0 cd 6c fe			call debug_vector  
4bc3				endm  
# End of macro CALLMONITOR
4bc3					endif 
4bc3					FORTH_DSP_VALUE 
4bc3 cd e6 22			call macro_forth_dsp_value 
4bc6				endm 
# End of macro FORTH_DSP_VALUE
4bc6					;v5 FORTH_DSP_VALUE 
4bc6			;		inc hl      ; now at start of numeric as string 
4bc6			 
4bc6 e5					push hl 
4bc7			 
4bc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc7 cd b5 23			call macro_forth_dsp_pop 
4bca				endm 
# End of macro FORTH_DSP_POP
4bca			 
4bca e1					pop hl 
4bcb			 
4bcb					if DEBUG_FORTH_WORDS 
4bcb						DMARK "AS1" 
4bcb f5				push af  
4bcc 3a e0 4b			ld a, (.dmark)  
4bcf 32 68 fe			ld (debug_mark),a  
4bd2 3a e1 4b			ld a, (.dmark+1)  
4bd5 32 69 fe			ld (debug_mark+1),a  
4bd8 3a e2 4b			ld a, (.dmark+2)  
4bdb 32 6a fe			ld (debug_mark+2),a  
4bde 18 03			jr .pastdmark  
4be0 ..			.dmark: db "AS1"  
4be3 f1			.pastdmark: pop af  
4be4			endm  
# End of macro DMARK
4be4						CALLMONITOR 
4be4 cd 6c fe			call debug_vector  
4be7				endm  
# End of macro CALLMONITOR
4be7					endif 
4be7					; push the content of a onto the stack as a value 
4be7			 
4be7 7e					ld a,(hl)   ; get char 
4be8 26 00				ld h,0 
4bea 6f					ld l,a 
4beb					if DEBUG_FORTH_WORDS 
4beb						DMARK "AS2" 
4beb f5				push af  
4bec 3a 00 4c			ld a, (.dmark)  
4bef 32 68 fe			ld (debug_mark),a  
4bf2 3a 01 4c			ld a, (.dmark+1)  
4bf5 32 69 fe			ld (debug_mark+1),a  
4bf8 3a 02 4c			ld a, (.dmark+2)  
4bfb 32 6a fe			ld (debug_mark+2),a  
4bfe 18 03			jr .pastdmark  
4c00 ..			.dmark: db "AS2"  
4c03 f1			.pastdmark: pop af  
4c04			endm  
# End of macro DMARK
4c04						CALLMONITOR 
4c04 cd 6c fe			call debug_vector  
4c07				endm  
# End of macro CALLMONITOR
4c07					endif 
4c07 cd 06 21				call forth_push_numhl 
4c0a			 
4c0a				       NEXTW 
4c0a c3 b3 24			jp macro_next 
4c0d				endm 
# End of macro NEXTW
4c0d			 
4c0d			.CHR: 
4c0d				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c0d 4d				db WORD_SYS_CORE+57             
4c0e 49 4c			dw .ENDSTR            
4c10 04				db 3 + 1 
4c11 .. 00			db "CHR",0              
4c15				endm 
# End of macro CWHEAD
4c15			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c15					if DEBUG_FORTH_WORDS_KEY 
4c15						DMARK "CHR" 
4c15 f5				push af  
4c16 3a 2a 4c			ld a, (.dmark)  
4c19 32 68 fe			ld (debug_mark),a  
4c1c 3a 2b 4c			ld a, (.dmark+1)  
4c1f 32 69 fe			ld (debug_mark+1),a  
4c22 3a 2c 4c			ld a, (.dmark+2)  
4c25 32 6a fe			ld (debug_mark+2),a  
4c28 18 03			jr .pastdmark  
4c2a ..			.dmark: db "CHR"  
4c2d f1			.pastdmark: pop af  
4c2e			endm  
# End of macro DMARK
4c2e						CALLMONITOR 
4c2e cd 6c fe			call debug_vector  
4c31				endm  
# End of macro CALLMONITOR
4c31					endif 
4c31					FORTH_DSP_VALUEHL 
4c31 cd fd 22			call macro_dsp_valuehl 
4c34				endm 
# End of macro FORTH_DSP_VALUEHL
4c34			 
4c34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c34 cd b5 23			call macro_forth_dsp_pop 
4c37				endm 
# End of macro FORTH_DSP_POP
4c37			 
4c37					; save asci byte as a zero term string and push string 
4c37			 
4c37 7d					ld a,l 
4c38 32 be f1				ld (scratch), a 
4c3b			 
4c3b 3e 00				ld a, 0 
4c3d 32 bf f1				ld (scratch+1), a 
4c40			 
4c40 21 be f1				ld hl, scratch 
4c43 cd 74 21				call forth_push_str 
4c46			 
4c46			 
4c46				       NEXTW 
4c46 c3 b3 24			jp macro_next 
4c49				endm 
# End of macro NEXTW
4c49			 
4c49			 
4c49			 
4c49			 
4c49			.ENDSTR: 
4c49			; eof 
4c49			 
# End of file forth_words_str.asm
4c49			include "forth_words_key.asm" 
4c49			 
4c49			; | ## Keyboard Words 
4c49			 
4c49			.KEY: 
4c49				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c49 3e				db WORD_SYS_CORE+42             
4c4a 79 4c			dw .WAITK            
4c4c 04				db 3 + 1 
4c4d .. 00			db "KEY",0              
4c51				endm 
# End of macro CWHEAD
4c51			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c51			 
4c51					if DEBUG_FORTH_WORDS_KEY 
4c51						DMARK "KEY" 
4c51 f5				push af  
4c52 3a 66 4c			ld a, (.dmark)  
4c55 32 68 fe			ld (debug_mark),a  
4c58 3a 67 4c			ld a, (.dmark+1)  
4c5b 32 69 fe			ld (debug_mark+1),a  
4c5e 3a 68 4c			ld a, (.dmark+2)  
4c61 32 6a fe			ld (debug_mark+2),a  
4c64 18 03			jr .pastdmark  
4c66 ..			.dmark: db "KEY"  
4c69 f1			.pastdmark: pop af  
4c6a			endm  
# End of macro DMARK
4c6a						CALLMONITOR 
4c6a cd 6c fe			call debug_vector  
4c6d				endm  
# End of macro CALLMONITOR
4c6d					endif 
4c6d			; TODO currently waits 
4c6d cd d5 79				call cin 
4c70					;call cin_wait 
4c70 6f					ld l, a 
4c71 26 00				ld h, 0 
4c73 cd 06 21				call forth_push_numhl 
4c76					NEXTW 
4c76 c3 b3 24			jp macro_next 
4c79				endm 
# End of macro NEXTW
4c79			.WAITK: 
4c79				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c79 3f				db WORD_SYS_CORE+43             
4c7a ab 4c			dw .ACCEPT            
4c7c 06				db 5 + 1 
4c7d .. 00			db "WAITK",0              
4c83				endm 
# End of macro CWHEAD
4c83			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c83					if DEBUG_FORTH_WORDS_KEY 
4c83						DMARK "WAI" 
4c83 f5				push af  
4c84 3a 98 4c			ld a, (.dmark)  
4c87 32 68 fe			ld (debug_mark),a  
4c8a 3a 99 4c			ld a, (.dmark+1)  
4c8d 32 69 fe			ld (debug_mark+1),a  
4c90 3a 9a 4c			ld a, (.dmark+2)  
4c93 32 6a fe			ld (debug_mark+2),a  
4c96 18 03			jr .pastdmark  
4c98 ..			.dmark: db "WAI"  
4c9b f1			.pastdmark: pop af  
4c9c			endm  
# End of macro DMARK
4c9c						CALLMONITOR 
4c9c cd 6c fe			call debug_vector  
4c9f				endm  
# End of macro CALLMONITOR
4c9f					endif 
4c9f cd c4 79				call cin_wait 
4ca2 6f					ld l, a 
4ca3 26 00				ld h, 0 
4ca5 cd 06 21				call forth_push_numhl 
4ca8					NEXTW 
4ca8 c3 b3 24			jp macro_next 
4cab				endm 
# End of macro NEXTW
4cab			.ACCEPT: 
4cab				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4cab 40				db WORD_SYS_CORE+44             
4cac 09 4d			dw .EDIT            
4cae 07				db 6 + 1 
4caf .. 00			db "ACCEPT",0              
4cb6				endm 
# End of macro CWHEAD
4cb6			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cb6					; TODO crashes on push 
4cb6					if DEBUG_FORTH_WORDS_KEY 
4cb6						DMARK "ACC" 
4cb6 f5				push af  
4cb7 3a cb 4c			ld a, (.dmark)  
4cba 32 68 fe			ld (debug_mark),a  
4cbd 3a cc 4c			ld a, (.dmark+1)  
4cc0 32 69 fe			ld (debug_mark+1),a  
4cc3 3a cd 4c			ld a, (.dmark+2)  
4cc6 32 6a fe			ld (debug_mark+2),a  
4cc9 18 03			jr .pastdmark  
4ccb ..			.dmark: db "ACC"  
4cce f1			.pastdmark: pop af  
4ccf			endm  
# End of macro DMARK
4ccf						CALLMONITOR 
4ccf cd 6c fe			call debug_vector  
4cd2				endm  
# End of macro CALLMONITOR
4cd2					endif 
4cd2 21 bc f3				ld hl, os_input 
4cd5 3e 00				ld a, 0 
4cd7 77					ld (hl),a 
4cd8 3a 5b fa				ld a,(f_cursor_ptr) 
4cdb 16 64				ld d, 100 
4cdd 0e 00				ld c, 0 
4cdf 1e 28				ld e, 40 
4ce1 cd fd 0f				call input_str 
4ce4					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce4 21 bc f3				ld hl, os_input 
4ce7					if DEBUG_FORTH_WORDS 
4ce7						DMARK "AC1" 
4ce7 f5				push af  
4ce8 3a fc 4c			ld a, (.dmark)  
4ceb 32 68 fe			ld (debug_mark),a  
4cee 3a fd 4c			ld a, (.dmark+1)  
4cf1 32 69 fe			ld (debug_mark+1),a  
4cf4 3a fe 4c			ld a, (.dmark+2)  
4cf7 32 6a fe			ld (debug_mark+2),a  
4cfa 18 03			jr .pastdmark  
4cfc ..			.dmark: db "AC1"  
4cff f1			.pastdmark: pop af  
4d00			endm  
# End of macro DMARK
4d00						CALLMONITOR 
4d00 cd 6c fe			call debug_vector  
4d03				endm  
# End of macro CALLMONITOR
4d03					endif 
4d03 cd 74 21				call forth_push_str 
4d06					NEXTW 
4d06 c3 b3 24			jp macro_next 
4d09				endm 
# End of macro NEXTW
4d09			 
4d09			.EDIT: 
4d09				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d09 40				db WORD_SYS_CORE+44             
4d0a ab 4d			dw .DEDIT            
4d0c 05				db 4 + 1 
4d0d .. 00			db "EDIT",0              
4d12				endm 
# End of macro CWHEAD
4d12			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d12			 
4d12					; TODO does not copy from stack 
4d12					if DEBUG_FORTH_WORDS_KEY 
4d12						DMARK "EDT" 
4d12 f5				push af  
4d13 3a 27 4d			ld a, (.dmark)  
4d16 32 68 fe			ld (debug_mark),a  
4d19 3a 28 4d			ld a, (.dmark+1)  
4d1c 32 69 fe			ld (debug_mark+1),a  
4d1f 3a 29 4d			ld a, (.dmark+2)  
4d22 32 6a fe			ld (debug_mark+2),a  
4d25 18 03			jr .pastdmark  
4d27 ..			.dmark: db "EDT"  
4d2a f1			.pastdmark: pop af  
4d2b			endm  
# End of macro DMARK
4d2b						CALLMONITOR 
4d2b cd 6c fe			call debug_vector  
4d2e				endm  
# End of macro CALLMONITOR
4d2e					endif 
4d2e			 
4d2e					;FORTH_DSP 
4d2e					FORTH_DSP_VALUEHL 
4d2e cd fd 22			call macro_dsp_valuehl 
4d31				endm 
# End of macro FORTH_DSP_VALUEHL
4d31			;		inc hl    ; TODO do type check 
4d31			 
4d31			;		call get_word_hl 
4d31 e5					push hl 
4d32					if DEBUG_FORTH_WORDS 
4d32						DMARK "EDp" 
4d32 f5				push af  
4d33 3a 47 4d			ld a, (.dmark)  
4d36 32 68 fe			ld (debug_mark),a  
4d39 3a 48 4d			ld a, (.dmark+1)  
4d3c 32 69 fe			ld (debug_mark+1),a  
4d3f 3a 49 4d			ld a, (.dmark+2)  
4d42 32 6a fe			ld (debug_mark+2),a  
4d45 18 03			jr .pastdmark  
4d47 ..			.dmark: db "EDp"  
4d4a f1			.pastdmark: pop af  
4d4b			endm  
# End of macro DMARK
4d4b						CALLMONITOR 
4d4b cd 6c fe			call debug_vector  
4d4e				endm  
# End of macro CALLMONITOR
4d4e					endif 
4d4e				;	ld a, 0 
4d4e cd 2e 14				call strlenz 
4d51 23					inc hl 
4d52			 
4d52 06 00				ld b, 0 
4d54 4d					ld c, l 
4d55			 
4d55 e1					pop hl 
4d56 11 bc f3				ld de, os_input 
4d59					if DEBUG_FORTH_WORDS_KEY 
4d59						DMARK "EDc" 
4d59 f5				push af  
4d5a 3a 6e 4d			ld a, (.dmark)  
4d5d 32 68 fe			ld (debug_mark),a  
4d60 3a 6f 4d			ld a, (.dmark+1)  
4d63 32 69 fe			ld (debug_mark+1),a  
4d66 3a 70 4d			ld a, (.dmark+2)  
4d69 32 6a fe			ld (debug_mark+2),a  
4d6c 18 03			jr .pastdmark  
4d6e ..			.dmark: db "EDc"  
4d71 f1			.pastdmark: pop af  
4d72			endm  
# End of macro DMARK
4d72						CALLMONITOR 
4d72 cd 6c fe			call debug_vector  
4d75				endm  
# End of macro CALLMONITOR
4d75					endif 
4d75 ed b0				ldir 
4d77			 
4d77			 
4d77 21 bc f3				ld hl, os_input 
4d7a					;ld a, 0 
4d7a					;ld (hl),a 
4d7a 3a 5b fa				ld a,(f_cursor_ptr) 
4d7d 16 64				ld d, 100 
4d7f 0e 00				ld c, 0 
4d81 1e 28				ld e, 40 
4d83 cd fd 0f				call input_str 
4d86					; TODO perhaps do a type check and wrap in quotes if not a number 
4d86 21 bc f3				ld hl, os_input 
4d89					if DEBUG_FORTH_WORDS 
4d89						DMARK "ED1" 
4d89 f5				push af  
4d8a 3a 9e 4d			ld a, (.dmark)  
4d8d 32 68 fe			ld (debug_mark),a  
4d90 3a 9f 4d			ld a, (.dmark+1)  
4d93 32 69 fe			ld (debug_mark+1),a  
4d96 3a a0 4d			ld a, (.dmark+2)  
4d99 32 6a fe			ld (debug_mark+2),a  
4d9c 18 03			jr .pastdmark  
4d9e ..			.dmark: db "ED1"  
4da1 f1			.pastdmark: pop af  
4da2			endm  
# End of macro DMARK
4da2						CALLMONITOR 
4da2 cd 6c fe			call debug_vector  
4da5				endm  
# End of macro CALLMONITOR
4da5					endif 
4da5 cd 74 21				call forth_push_str 
4da8					NEXTW 
4da8 c3 b3 24			jp macro_next 
4dab				endm 
# End of macro NEXTW
4dab			 
4dab			.DEDIT: 
4dab				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4dab 40				db WORD_SYS_CORE+44             
4dac 0d 4e			dw .ENDKEY            
4dae 06				db 5 + 1 
4daf .. 00			db "DEDIT",0              
4db5				endm 
# End of macro CWHEAD
4db5			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4db5			 
4db5					; TODO does not copy from stack 
4db5					if DEBUG_FORTH_WORDS_KEY 
4db5						DMARK "DED" 
4db5 f5				push af  
4db6 3a ca 4d			ld a, (.dmark)  
4db9 32 68 fe			ld (debug_mark),a  
4dbc 3a cb 4d			ld a, (.dmark+1)  
4dbf 32 69 fe			ld (debug_mark+1),a  
4dc2 3a cc 4d			ld a, (.dmark+2)  
4dc5 32 6a fe			ld (debug_mark+2),a  
4dc8 18 03			jr .pastdmark  
4dca ..			.dmark: db "DED"  
4dcd f1			.pastdmark: pop af  
4dce			endm  
# End of macro DMARK
4dce						CALLMONITOR 
4dce cd 6c fe			call debug_vector  
4dd1				endm  
# End of macro CALLMONITOR
4dd1					endif 
4dd1			 
4dd1					;FORTH_DSP 
4dd1					FORTH_DSP_VALUEHL 
4dd1 cd fd 22			call macro_dsp_valuehl 
4dd4				endm 
# End of macro FORTH_DSP_VALUEHL
4dd4			;		inc hl    ; TODO do type check 
4dd4			 
4dd4			;		call get_word_hl 
4dd4 e5					push hl 
4dd5 e5					push hl 
4dd6					FORTH_DSP_POP 
4dd6 cd b5 23			call macro_forth_dsp_pop 
4dd9				endm 
# End of macro FORTH_DSP_POP
4dd9 e1					pop hl 
4dda					if DEBUG_FORTH_WORDS 
4dda						DMARK "EDp" 
4dda f5				push af  
4ddb 3a ef 4d			ld a, (.dmark)  
4dde 32 68 fe			ld (debug_mark),a  
4de1 3a f0 4d			ld a, (.dmark+1)  
4de4 32 69 fe			ld (debug_mark+1),a  
4de7 3a f1 4d			ld a, (.dmark+2)  
4dea 32 6a fe			ld (debug_mark+2),a  
4ded 18 03			jr .pastdmark  
4def ..			.dmark: db "EDp"  
4df2 f1			.pastdmark: pop af  
4df3			endm  
# End of macro DMARK
4df3						CALLMONITOR 
4df3 cd 6c fe			call debug_vector  
4df6				endm  
# End of macro CALLMONITOR
4df6					endif 
4df6				;	ld a, 0 
4df6 cd 2e 14				call strlenz 
4df9 23					inc hl 
4dfa			 
4dfa 06 00				ld b, 0 
4dfc 4d					ld c, l 
4dfd			 
4dfd e1					pop hl 
4dfe			 
4dfe					;ld a, 0 
4dfe					;ld (hl),a 
4dfe 3a 5b fa				ld a,(f_cursor_ptr) 
4e01 16 64				ld d, 100 
4e03 0e 00				ld c, 0 
4e05 1e 28				ld e, 40 
4e07 cd fd 0f				call input_str 
4e0a					; TODO perhaps do a type check and wrap in quotes if not a number 
4e0a					NEXTW 
4e0a c3 b3 24			jp macro_next 
4e0d				endm 
# End of macro NEXTW
4e0d			 
4e0d			 
4e0d			.ENDKEY: 
4e0d			; eof 
4e0d			 
# End of file forth_words_key.asm
4e0d			include "forth_words_const.asm" 
4e0d			 
4e0d			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e0d			 
4e0d			 
4e0d			.SPITIME: 
4e0d				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e0d 77				db WORD_SYS_CORE+99             
4e0e 22 4e			dw .VA            
4e10 08				db 7 + 1 
4e11 .. 00			db "SPITIME",0              
4e19				endm 
# End of macro CWHEAD
4e19			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4e19			; 
4e19			; | If using BANK devices then leave as is. 
4e19			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4e19			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4e19			 
4e19 21 61 fa				ld hl, spi_clktime  
4e1c cd 06 21				call forth_push_numhl 
4e1f			 
4e1f					NEXTW 
4e1f c3 b3 24			jp macro_next 
4e22				endm 
# End of macro NEXTW
4e22			 
4e22			 
4e22			.VA: 
4e22				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e22 77				db WORD_SYS_CORE+99             
4e23 32 4e			dw .SYMBOL            
4e25 03				db 2 + 1 
4e26 .. 00			db "VA",0              
4e29				endm 
# End of macro CWHEAD
4e29			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4e29 21 25 fa				ld hl, cli_var_array 
4e2c cd 06 21				call forth_push_numhl 
4e2f			 
4e2f					NEXTW 
4e2f c3 b3 24			jp macro_next 
4e32				endm 
# End of macro NEXTW
4e32			 
4e32			.SYMBOL: 
4e32				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e32 77				db WORD_SYS_CORE+99             
4e33 3c 4f			dw .ENDCONST            
4e35 07				db 6 + 1 
4e36 .. 00			db "SYMBOL",0              
4e3d				endm 
# End of macro CWHEAD
4e3d			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e3d			; | 
4e3d			; | The value is the number reference and the final address is pushed to stack 
4e3d			 
4e3d			; | dw sym_table 
4e3d			; | dw nmi_vector 
4e3d			; | dw cli_autodisplay 
4e3d			; | dw cli_data_sp 
4e3d			; | dw cli_data_stack 
4e3d			; | dw cli_loop_sp 
4e3d			; | dw cli_loop_stack 
4e3d			; | dw cli_var_array 
4e3d			; | dw cursor_col 
4e3d			; | dw cursor_ptr 
4e3d			; | ; 10 
4e3d			; | dw cursor_row 
4e3d			; | dw debug_mark 
4e3d			; | dw display_fb0 
4e3d			; | dw display_fb1 
4e3d			; | dw display_fb2 
4e3d			; | dw display_fb3 
4e3d			; | dw display_fb_active 
4e3d			; | dw execscratch 
4e3d			; | dw f_cursor_ptr 
4e3d			; | dw hardware_word 
4e3d			; | ;20 
4e3d			; | dw input_at_cursor 
4e3d			; | dw input_at_pos 
4e3d			; | dw input_cur_flash 
4e3d			; | dw input_cur_onoff 
4e3d			; | dw input_cursor 
4e3d			; | dw input_display_size 
4e3d			; | dw input_len 
4e3d			; | dw input_ptr 
4e3d			; | dw input_size 
4e3d			; | dw input_start 
4e3d			; | ; 30 
4e3d			; | dw input_str 
4e3d			; | dw input_under_cursor 
4e3d			; | dw os_cli_cmd 
4e3d			; | dw os_cur_ptr 
4e3d			; | dw os_current_i 
4e3d			; | dw os_input 
4e3d			; | dw os_last_cmd 
4e3d			; | dw os_last_new_uword 
4e3d			; | dw debug_vector 
4e3d			; | dw os_view_hl 
4e3d			; | ;40 
4e3d			; | dw os_word_scratch 
4e3d			; | dw portbctl 
4e3d			; | dw portbdata 
4e3d			; | dw spi_cartdev 
4e3d			; | dw spi_cartdev2 
4e3d			; | dw spi_clktime 
4e3d			; | dw spi_device 
4e3d			; | dw spi_device_id 
4e3d			; | dw spi_portbyte 
4e3d			; | dw stackstore 
4e3d			; | ; 50 
4e3d			; | if STORAGE_SE 
4e3d			; | dw storage_actl 
4e3d			; | dw storage_adata 
4e3d			; | else 
4e3d			; | dw 0 
4e3d			; | dw 0 
4e3d			; | endif 
4e3d			; | dw storage_append 
4e3d			; | if STORAGE_SE 
4e3d			; | dw storage_bctl 
4e3d			; | else 
4e3d			; | dw 0 
4e3d			; | endif 
4e3d			; | dw store_bank_active 
4e3d			; | dw store_filecache 
4e3d			; | dw store_longread 
4e3d			; | dw store_openaddr 
4e3d			; | dw store_openext 
4e3d			; | dw store_openmaxext 
4e3d			; | ; 60 
4e3d			; | dw store_page 
4e3d			; | dw store_readbuf 
4e3d			; | dw store_readcont 
4e3d			; | dw store_readptr 
4e3d			; | dw store_tmpext 
4e3d			; | dw store_tmpid 
4e3d			; | dw store_tmppageid 
4e3d			; | dw malloc 
4e3d			; | dw free 
4e3d			; | dw cin 
4e3d			; | ; 70 
4e3d			; | dw cin_wait 
4e3d			; | dw forth_push_numhl 
4e3d			; | dw forth_push_str 
4e3d			 
4e3d					if DEBUG_FORTH_WORDS_KEY 
4e3d						DMARK "SYM" 
4e3d f5				push af  
4e3e 3a 52 4e			ld a, (.dmark)  
4e41 32 68 fe			ld (debug_mark),a  
4e44 3a 53 4e			ld a, (.dmark+1)  
4e47 32 69 fe			ld (debug_mark+1),a  
4e4a 3a 54 4e			ld a, (.dmark+2)  
4e4d 32 6a fe			ld (debug_mark+2),a  
4e50 18 03			jr .pastdmark  
4e52 ..			.dmark: db "SYM"  
4e55 f1			.pastdmark: pop af  
4e56			endm  
# End of macro DMARK
4e56						CALLMONITOR 
4e56 cd 6c fe			call debug_vector  
4e59				endm  
# End of macro CALLMONITOR
4e59					endif 
4e59			 
4e59					FORTH_DSP_VALUEHL 
4e59 cd fd 22			call macro_dsp_valuehl 
4e5c				endm 
# End of macro FORTH_DSP_VALUEHL
4e5c			 
4e5c 7d					ld a, l     
4e5d			 
4e5d			 
4e5d					if DEBUG_FORTH_WORDS 
4e5d						DMARK "SY1" 
4e5d f5				push af  
4e5e 3a 72 4e			ld a, (.dmark)  
4e61 32 68 fe			ld (debug_mark),a  
4e64 3a 73 4e			ld a, (.dmark+1)  
4e67 32 69 fe			ld (debug_mark+1),a  
4e6a 3a 74 4e			ld a, (.dmark+2)  
4e6d 32 6a fe			ld (debug_mark+2),a  
4e70 18 03			jr .pastdmark  
4e72 ..			.dmark: db "SY1"  
4e75 f1			.pastdmark: pop af  
4e76			endm  
# End of macro DMARK
4e76						CALLMONITOR 
4e76 cd 6c fe			call debug_vector  
4e79				endm  
# End of macro CALLMONITOR
4e79					endif 
4e79					 
4e79 f5					push af	 
4e7a					FORTH_DSP_POP 
4e7a cd b5 23			call macro_forth_dsp_pop 
4e7d				endm 
# End of macro FORTH_DSP_POP
4e7d f1					pop af 
4e7e			 
4e7e cb 27				sla a  
4e80				 
4e80					 
4e80					if DEBUG_FORTH_WORDS 
4e80						DMARK "SY" 
4e80 f5				push af  
4e81 3a 95 4e			ld a, (.dmark)  
4e84 32 68 fe			ld (debug_mark),a  
4e87 3a 96 4e			ld a, (.dmark+1)  
4e8a 32 69 fe			ld (debug_mark+1),a  
4e8d 3a 97 4e			ld a, (.dmark+2)  
4e90 32 6a fe			ld (debug_mark+2),a  
4e93 18 02			jr .pastdmark  
4e95 ..			.dmark: db "SY"  
4e97 f1			.pastdmark: pop af  
4e98			endm  
# End of macro DMARK
4e98						CALLMONITOR 
4e98 cd 6c fe			call debug_vector  
4e9b				endm  
# End of macro CALLMONITOR
4e9b					endif 
4e9b			 
4e9b 21 aa 4e				ld hl, sym_table 
4e9e cd d0 0f				call addatohl 
4ea1 cd 35 24				call loadwordinhl 
4ea4 cd 06 21				call forth_push_numhl 
4ea7			 
4ea7			 
4ea7				       NEXTW 
4ea7 c3 b3 24			jp macro_next 
4eaa				endm 
# End of macro NEXTW
4eaa			 
4eaa			sym_table: 
4eaa			 
4eaa			; 0 
4eaa aa 4e		dw sym_table 
4eac 6f fe		dw nmi_vector 
4eae 39 fa		dw cli_autodisplay 
4eb0 eb f9		dw cli_data_sp 
4eb2 25 f7		dw cli_data_stack 
4eb4 ed f9		dw cli_loop_sp 
4eb6 27 f9		dw cli_loop_stack 
4eb8 25 fa		dw cli_var_array 
4eba c2 fb		dw cursor_col 
4ebc c0 fb		dw cursor_ptr 
4ebe			; 10 
4ebe c1 fb		dw cursor_row 
4ec0 68 fe		dw debug_mark 
4ec2 ae fd		dw display_fb0 
4ec4 0d fd		dw display_fb1 
4ec6 cb fb		dw display_fb2 
4ec8 6c fc		dw display_fb3 
4eca c9 fb		dw display_fb_active 
4ecc bd f2		dw execscratch 
4ece 5b fa		dw f_cursor_ptr 
4ed0 72 fe		dw hardware_word 
4ed2			;20 
4ed2 5f fe		dw input_at_cursor 
4ed4 61 fe		dw input_at_pos 
4ed6 5d fe		dw input_cur_flash 
4ed8 5c fe		dw input_cur_onoff 
4eda 52 fe		dw input_cursor 
4edc 62 fe		dw input_display_size 
4ede 57 fe		dw input_len 
4ee0 66 fe		dw input_ptr 
4ee2 63 fe		dw input_size 
4ee4 64 fe		dw input_start 
4ee6			; 30 
4ee6 fd 0f		dw input_str 
4ee8 60 fe		dw input_under_cursor 
4eea e5 f4		dw os_cli_cmd 
4eec e1 f4		dw os_cur_ptr 
4eee e3 f4		dw os_current_i 
4ef0 bc f3		dw os_input 
4ef2 e4 f5		dw os_last_cmd 
4ef4 bb f4		dw os_last_new_uword 
4ef6 6c fe		dw debug_vector 
4ef8 a0 f1		dw os_view_hl 
4efa			;40 
4efa c3 f4		dw os_word_scratch 
4efc c3 00		dw portbctl 
4efe c1 00		dw portbdata 
4f00 60 fa		dw spi_cartdev 
4f02 5f fa		dw spi_cartdev2 
4f04 61 fa		dw spi_clktime 
4f06 5d fa		dw spi_device 
4f08 5c fa		dw spi_device_id 
4f0a 5e fa		dw spi_portbyte 
4f0c a4 fb		dw stackstore 
4f0e			; 50 
4f0e			if STORAGE_SE 
4f0e 82 00		dw storage_actl 
4f10 80 00		dw storage_adata 
4f12			else 
4f12			dw 0 
4f12			dw 0 
4f12			endif 
4f12 56 0b		dw storage_append 
4f14			if STORAGE_SE 
4f14 83 00		dw storage_bctl 
4f16			else 
4f16			dw 0 
4f16			endif 
4f16 90 fb		dw store_bank_active 
4f18 64 fa		dw store_filecache 
4f1a 72 fa		dw store_longread 
4f1c 68 fa		dw store_openaddr 
4f1e 67 fa		dw store_openext 
4f20 66 fa		dw store_openmaxext 
4f22			; 60 
4f22 77 fa		dw store_page 
4f24 73 fa		dw store_readbuf 
4f26 6a fa		dw store_readcont 
4f28 75 fa		dw store_readptr 
4f2a 6a fa		dw store_tmpext 
4f2c 6b fa		dw store_tmpid 
4f2e 62 fa		dw store_tmppageid 
4f30 97 14		dw malloc 
4f32 61 15		dw free 
4f34 d5 79		dw cin 
4f36			; 70 
4f36 c4 79		dw cin_wait 
4f38 06 21		dw forth_push_numhl 
4f3a 74 21		dw forth_push_str 
4f3c			 
4f3c			 
4f3c			.ENDCONST: 
4f3c			 
4f3c			; eof 
4f3c			 
4f3c			 
# End of file forth_words_const.asm
4f3c			 
4f3c			if STORAGE_SE 
4f3c			   	include "forth_words_storage.asm" 
4f3c			 
4f3c			; | ## Fixed Storage Words 
4f3c			 
4f3c			.RENAME: 
4f3c			  
4f3c				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f3c 3a				db WORD_SYS_CORE+38             
4f3d 32 50			dw .RECORD            
4f3f 07				db 6 + 1 
4f40 .. 00			db "RENAME",0              
4f47				endm 
# End of macro CWHEAD
4f47			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f47			; | | Compatible with PicoSPINet  
4f47					if DEBUG_FORTH_WORDS_KEY 
4f47						DMARK "REN" 
4f47 f5				push af  
4f48 3a 5c 4f			ld a, (.dmark)  
4f4b 32 68 fe			ld (debug_mark),a  
4f4e 3a 5d 4f			ld a, (.dmark+1)  
4f51 32 69 fe			ld (debug_mark+1),a  
4f54 3a 5e 4f			ld a, (.dmark+2)  
4f57 32 6a fe			ld (debug_mark+2),a  
4f5a 18 03			jr .pastdmark  
4f5c ..			.dmark: db "REN"  
4f5f f1			.pastdmark: pop af  
4f60			endm  
# End of macro DMARK
4f60						CALLMONITOR 
4f60 cd 6c fe			call debug_vector  
4f63				endm  
# End of macro CALLMONITOR
4f63					endif 
4f63			 
4f63			 
4f63					; preserve some internal vars used by other file handing routines 
4f63			 
4f63 2a 68 fa				ld hl, (store_openaddr) 
4f66 e5					push hl 
4f67 3a 6a fa				ld a, (store_readcont) 
4f6a f5					push af 
4f6b			 
4f6b					FORTH_DSP_VALUEHL 
4f6b cd fd 22			call macro_dsp_valuehl 
4f6e				endm 
# End of macro FORTH_DSP_VALUEHL
4f6e			 
4f6e					; move ext and id around for the file header 
4f6e			 
4f6e 65					ld h, l 
4f6f 2e 00				ld l, 0 
4f71			 
4f71 e5					push hl    ; id 
4f72			 
4f72					FORTH_DSP_POP 
4f72 cd b5 23			call macro_forth_dsp_pop 
4f75				endm 
# End of macro FORTH_DSP_POP
4f75			 
4f75					; Locate the file header 
4f75			 
4f75 e1					pop hl 
4f76 e5					push hl 
4f77 11 77 fa				ld de, store_page      ; get block zero of file 
4f7a					if DEBUG_FORTH_WORDS 
4f7a						DMARK "REr" 
4f7a f5				push af  
4f7b 3a 8f 4f			ld a, (.dmark)  
4f7e 32 68 fe			ld (debug_mark),a  
4f81 3a 90 4f			ld a, (.dmark+1)  
4f84 32 69 fe			ld (debug_mark+1),a  
4f87 3a 91 4f			ld a, (.dmark+2)  
4f8a 32 6a fe			ld (debug_mark+2),a  
4f8d 18 03			jr .pastdmark  
4f8f ..			.dmark: db "REr"  
4f92 f1			.pastdmark: pop af  
4f93			endm  
# End of macro DMARK
4f93						CALLMONITOR 
4f93 cd 6c fe			call debug_vector  
4f96				endm  
# End of macro CALLMONITOR
4f96					endif 
4f96 cd bf 09				call storage_read 
4f99			 
4f99 cd f9 0f			call ishlzero 
4f9c 20 05			jr nz, .rnfound 
4f9e			 
4f9e				; file does not exist so indicate with 255 extents in use 
4f9e			 
4f9e 3e ff			ld a, 255 
4fa0 e1				pop hl ; clear dup hl 
4fa1 18 7b			jr .skiprneof 
4fa3			 
4fa3			 
4fa3			.rnfound: 
4fa3					; file found so rename 
4fa3			 
4fa3					FORTH_DSP_VALUEHL 
4fa3 cd fd 22			call macro_dsp_valuehl 
4fa6				endm 
# End of macro FORTH_DSP_VALUEHL
4fa6			 
4fa6 e5				push hl 
4fa7 3e 00			ld a, 0 
4fa9 cd 39 14			call strlent 
4fac 23				inc hl   ; cover zero term 
4fad 06 00			ld b,0 
4faf 4d				ld c,l 
4fb0 e1				pop hl 
4fb1 11 7a fa				ld de, store_page + 3 
4fb4 ed b0				ldir 
4fb6			 
4fb6 11 77 fa				ld de, store_page 
4fb9					if DEBUG_FORTH_WORDS 
4fb9						DMARK "RER" 
4fb9 f5				push af  
4fba 3a ce 4f			ld a, (.dmark)  
4fbd 32 68 fe			ld (debug_mark),a  
4fc0 3a cf 4f			ld a, (.dmark+1)  
4fc3 32 69 fe			ld (debug_mark+1),a  
4fc6 3a d0 4f			ld a, (.dmark+2)  
4fc9 32 6a fe			ld (debug_mark+2),a  
4fcc 18 03			jr .pastdmark  
4fce ..			.dmark: db "RER"  
4fd1 f1			.pastdmark: pop af  
4fd2			endm  
# End of macro DMARK
4fd2						CALLMONITOR 
4fd2 cd 6c fe			call debug_vector  
4fd5				endm  
# End of macro CALLMONITOR
4fd5					endif 
4fd5			 
4fd5 e1					pop hl    ; get orig file id and mangle it for find id 
4fd6 55					ld d, l 
4fd7 5c					ld e, h 
4fd8			 
4fd8 21 00 00				ld hl, 0 
4fdb					if DEBUG_FORTH_WORDS 
4fdb						DMARK "REf" 
4fdb f5				push af  
4fdc 3a f0 4f			ld a, (.dmark)  
4fdf 32 68 fe			ld (debug_mark),a  
4fe2 3a f1 4f			ld a, (.dmark+1)  
4fe5 32 69 fe			ld (debug_mark+1),a  
4fe8 3a f2 4f			ld a, (.dmark+2)  
4feb 32 6a fe			ld (debug_mark+2),a  
4fee 18 03			jr .pastdmark  
4ff0 ..			.dmark: db "REf"  
4ff3 f1			.pastdmark: pop af  
4ff4			endm  
# End of macro DMARK
4ff4						CALLMONITOR 
4ff4 cd 6c fe			call debug_vector  
4ff7				endm  
# End of macro CALLMONITOR
4ff7					endif 
4ff7 cd 99 07				call storage_findnextid 
4ffa 11 77 fa				ld de, store_page 
4ffd					if DEBUG_FORTH_WORDS 
4ffd						DMARK "REw" 
4ffd f5				push af  
4ffe 3a 12 50			ld a, (.dmark)  
5001 32 68 fe			ld (debug_mark),a  
5004 3a 13 50			ld a, (.dmark+1)  
5007 32 69 fe			ld (debug_mark+1),a  
500a 3a 14 50			ld a, (.dmark+2)  
500d 32 6a fe			ld (debug_mark+2),a  
5010 18 03			jr .pastdmark  
5012 ..			.dmark: db "REw"  
5015 f1			.pastdmark: pop af  
5016			endm  
# End of macro DMARK
5016						CALLMONITOR 
5016 cd 6c fe			call debug_vector  
5019				endm  
# End of macro CALLMONITOR
5019					endif 
5019 cd cb 04				call storage_write_block 
501c			 
501c 3e 00				ld a, 0 
501e			.skiprneof: 
501e					; drop file name 
501e					FORTH_DSP_POP 
501e cd b5 23			call macro_forth_dsp_pop 
5021				endm 
# End of macro FORTH_DSP_POP
5021			 
5021 6f					ld l, a 
5022 26 00				ld h, 0 
5024 cd 06 21				call forth_push_numhl 
5027			 
5027			 
5027 f1					pop af 
5028 32 6a fa				ld (store_readcont),a 
502b e1					pop hl 
502c 22 68 fa				ld (store_openaddr), hl 
502f						 
502f				NEXTW 
502f c3 b3 24			jp macro_next 
5032				endm 
# End of macro NEXTW
5032			.RECORD: 
5032			  
5032				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5032 3a				db WORD_SYS_CORE+38             
5033 d6 50			dw .BREAD            
5035 07				db 6 + 1 
5036 .. 00			db "RECORD",0              
503d				endm 
# End of macro CWHEAD
503d			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
503d			; | | Compatible with PicoSPINet  
503d			 
503d					if DEBUG_FORTH_WORDS_KEY 
503d						DMARK "REC" 
503d f5				push af  
503e 3a 52 50			ld a, (.dmark)  
5041 32 68 fe			ld (debug_mark),a  
5044 3a 53 50			ld a, (.dmark+1)  
5047 32 69 fe			ld (debug_mark+1),a  
504a 3a 54 50			ld a, (.dmark+2)  
504d 32 6a fe			ld (debug_mark+2),a  
5050 18 03			jr .pastdmark  
5052 ..			.dmark: db "REC"  
5055 f1			.pastdmark: pop af  
5056			endm  
# End of macro DMARK
5056						CALLMONITOR 
5056 cd 6c fe			call debug_vector  
5059				endm  
# End of macro CALLMONITOR
5059					endif 
5059			 
5059					FORTH_DSP_VALUEHL 
5059 cd fd 22			call macro_dsp_valuehl 
505c				endm 
# End of macro FORTH_DSP_VALUEHL
505c			 
505c e5					push hl    ; id 
505d			 
505d					FORTH_DSP_POP 
505d cd b5 23			call macro_forth_dsp_pop 
5060				endm 
# End of macro FORTH_DSP_POP
5060			 
5060					FORTH_DSP_VALUEHL 
5060 cd fd 22			call macro_dsp_valuehl 
5063				endm 
# End of macro FORTH_DSP_VALUEHL
5063			 
5063					FORTH_DSP_POP 
5063 cd b5 23			call macro_forth_dsp_pop 
5066				endm 
# End of macro FORTH_DSP_POP
5066			 
5066 d1					pop de     ; get file id 
5067			 
5067					; e = file id 
5067					; l = file extent 
5067			 
5067			 
5067					; construct request to access file extent 
5067			 
5067			;		ld a, e 
5067 63					ld h, e 
5068					 
5068					 
5068					 
5068			 
5068					; e has id 
5068			 
5068 11 77 fa			ld de, store_page 
506b					if DEBUG_FORTH_WORDS 
506b						DMARK "REr" 
506b f5				push af  
506c 3a 80 50			ld a, (.dmark)  
506f 32 68 fe			ld (debug_mark),a  
5072 3a 81 50			ld a, (.dmark+1)  
5075 32 69 fe			ld (debug_mark+1),a  
5078 3a 82 50			ld a, (.dmark+2)  
507b 32 6a fe			ld (debug_mark+2),a  
507e 18 03			jr .pastdmark  
5080 ..			.dmark: db "REr"  
5083 f1			.pastdmark: pop af  
5084			endm  
# End of macro DMARK
5084						CALLMONITOR 
5084 cd 6c fe			call debug_vector  
5087				endm  
# End of macro CALLMONITOR
5087					endif 
5087 cd bf 09				call storage_read 
508a cd f9 0f			call ishlzero 
508d 28 22			jr z, .recnotfound 
508f			 
508f			 
508f					if DEBUG_FORTH_WORDS 
508f						DMARK "REe" 
508f f5				push af  
5090 3a a4 50			ld a, (.dmark)  
5093 32 68 fe			ld (debug_mark),a  
5096 3a a5 50			ld a, (.dmark+1)  
5099 32 69 fe			ld (debug_mark+1),a  
509c 3a a6 50			ld a, (.dmark+2)  
509f 32 6a fe			ld (debug_mark+2),a  
50a2 18 03			jr .pastdmark  
50a4 ..			.dmark: db "REe"  
50a7 f1			.pastdmark: pop af  
50a8			endm  
# End of macro DMARK
50a8						CALLMONITOR 
50a8 cd 6c fe			call debug_vector  
50ab				endm  
# End of macro CALLMONITOR
50ab					endif 
50ab cd 74 21			call forth_push_str 
50ae			 
50ae					NEXTW 
50ae c3 b3 24			jp macro_next 
50b1				endm 
# End of macro NEXTW
50b1			 
50b1			.recnotfound: 
50b1					if DEBUG_FORTH_WORDS 
50b1						DMARK "REf" 
50b1 f5				push af  
50b2 3a c6 50			ld a, (.dmark)  
50b5 32 68 fe			ld (debug_mark),a  
50b8 3a c7 50			ld a, (.dmark+1)  
50bb 32 69 fe			ld (debug_mark+1),a  
50be 3a c8 50			ld a, (.dmark+2)  
50c1 32 6a fe			ld (debug_mark+2),a  
50c4 18 03			jr .pastdmark  
50c6 ..			.dmark: db "REf"  
50c9 f1			.pastdmark: pop af  
50ca			endm  
# End of macro DMARK
50ca						CALLMONITOR 
50ca cd 6c fe			call debug_vector  
50cd				endm  
# End of macro CALLMONITOR
50cd					endif 
50cd 21 ff 00			ld hl, 255 
50d0 cd 06 21			call forth_push_numhl 
50d3				NEXTW 
50d3 c3 b3 24			jp macro_next 
50d6				endm 
# End of macro NEXTW
50d6			 
50d6			 
50d6			.BREAD: 
50d6			  
50d6				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50d6 3a				db WORD_SYS_CORE+38             
50d7 59 51			dw .BWRITE            
50d9 06				db 5 + 1 
50da .. 00			db "BREAD",0              
50e0				endm 
# End of macro CWHEAD
50e0			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50e0			; | | Compatible with PicoSPINet  
50e0				 
50e0					if DEBUG_FORTH_WORDS_KEY 
50e0						DMARK "BRD" 
50e0 f5				push af  
50e1 3a f5 50			ld a, (.dmark)  
50e4 32 68 fe			ld (debug_mark),a  
50e7 3a f6 50			ld a, (.dmark+1)  
50ea 32 69 fe			ld (debug_mark+1),a  
50ed 3a f7 50			ld a, (.dmark+2)  
50f0 32 6a fe			ld (debug_mark+2),a  
50f3 18 03			jr .pastdmark  
50f5 ..			.dmark: db "BRD"  
50f8 f1			.pastdmark: pop af  
50f9			endm  
# End of macro DMARK
50f9						CALLMONITOR 
50f9 cd 6c fe			call debug_vector  
50fc				endm  
# End of macro CALLMONITOR
50fc					endif 
50fc			 
50fc				FORTH_DSP_VALUEHL 
50fc cd fd 22			call macro_dsp_valuehl 
50ff				endm 
# End of macro FORTH_DSP_VALUEHL
50ff			 
50ff				FORTH_DSP_POP 
50ff cd b5 23			call macro_forth_dsp_pop 
5102				endm 
# End of macro FORTH_DSP_POP
5102			 
5102				; calc block address 
5102			 
5102 eb				ex de, hl 
5103 3e 40			ld a, STORE_BLOCK_PHY 
5105 cd 53 0f			call Mult16 
5108			 
5108			 
5108 11 77 fa			ld de, store_page 
510b			 
510b					if DEBUG_FORTH_WORDS 
510b						DMARK "BR1" 
510b f5				push af  
510c 3a 20 51			ld a, (.dmark)  
510f 32 68 fe			ld (debug_mark),a  
5112 3a 21 51			ld a, (.dmark+1)  
5115 32 69 fe			ld (debug_mark+1),a  
5118 3a 22 51			ld a, (.dmark+2)  
511b 32 6a fe			ld (debug_mark+2),a  
511e 18 03			jr .pastdmark  
5120 ..			.dmark: db "BR1"  
5123 f1			.pastdmark: pop af  
5124			endm  
# End of macro DMARK
5124						CALLMONITOR 
5124 cd 6c fe			call debug_vector  
5127				endm  
# End of macro CALLMONITOR
5127					endif 
5127			 
5127 cd 66 04			call storage_read_block 
512a			 
512a cd f9 0f			call ishlzero 
512d 20 05			jr nz, .brfound 
512f			 
512f cd 06 21			call forth_push_numhl 
5132 18 22			jr .brdone 
5134			 
5134			 
5134			.brfound: 
5134 21 79 fa		        ld hl, store_page+2 
5137			 
5137					if DEBUG_FORTH_WORDS 
5137						DMARK "BR2" 
5137 f5				push af  
5138 3a 4c 51			ld a, (.dmark)  
513b 32 68 fe			ld (debug_mark),a  
513e 3a 4d 51			ld a, (.dmark+1)  
5141 32 69 fe			ld (debug_mark+1),a  
5144 3a 4e 51			ld a, (.dmark+2)  
5147 32 6a fe			ld (debug_mark+2),a  
514a 18 03			jr .pastdmark  
514c ..			.dmark: db "BR2"  
514f f1			.pastdmark: pop af  
5150			endm  
# End of macro DMARK
5150						CALLMONITOR 
5150 cd 6c fe			call debug_vector  
5153				endm  
# End of macro CALLMONITOR
5153					endif 
5153			 
5153 cd 74 21			call forth_push_str 
5156			 
5156			 
5156			.brdone: 
5156			 
5156					NEXTW 
5156 c3 b3 24			jp macro_next 
5159				endm 
# End of macro NEXTW
5159			.BWRITE: 
5159				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5159 3a				db WORD_SYS_CORE+38             
515a ee 51			dw .BUPD            
515c 07				db 6 + 1 
515d .. 00			db "BWRITE",0              
5164				endm 
# End of macro CWHEAD
5164			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5164			; | | Compatible with PicoSPINet  
5164			 
5164					if DEBUG_FORTH_WORDS_KEY 
5164						DMARK "BWR" 
5164 f5				push af  
5165 3a 79 51			ld a, (.dmark)  
5168 32 68 fe			ld (debug_mark),a  
516b 3a 7a 51			ld a, (.dmark+1)  
516e 32 69 fe			ld (debug_mark+1),a  
5171 3a 7b 51			ld a, (.dmark+2)  
5174 32 6a fe			ld (debug_mark+2),a  
5177 18 03			jr .pastdmark  
5179 ..			.dmark: db "BWR"  
517c f1			.pastdmark: pop af  
517d			endm  
# End of macro DMARK
517d						CALLMONITOR 
517d cd 6c fe			call debug_vector  
5180				endm  
# End of macro CALLMONITOR
5180					endif 
5180			 
5180				FORTH_DSP_VALUEHL 
5180 cd fd 22			call macro_dsp_valuehl 
5183				endm 
# End of macro FORTH_DSP_VALUEHL
5183			 
5183				; calc block address 
5183			 
5183 eb				ex de, hl 
5184 3e 40			ld a, STORE_BLOCK_PHY 
5186 cd 53 0f			call Mult16 
5189			 
5189 e5				push hl         ; address 
518a			 
518a				FORTH_DSP_POP 
518a cd b5 23			call macro_forth_dsp_pop 
518d				endm 
# End of macro FORTH_DSP_POP
518d			 
518d				FORTH_DSP_VALUEHL 
518d cd fd 22			call macro_dsp_valuehl 
5190				endm 
# End of macro FORTH_DSP_VALUEHL
5190			 
5190				FORTH_DSP_POP 
5190 cd b5 23			call macro_forth_dsp_pop 
5193				endm 
# End of macro FORTH_DSP_POP
5193			 
5193 cd a2 0c			call storage_clear_page 
5196			 
5196				; copy string to store page 
5196			 
5196 e5				push hl     ; save string address 
5197			 
5197 3e 00			ld a, 0 
5199 cd 39 14			call strlent 
519c			 
519c 23				inc hl 
519d			 
519d 4d				ld c, l 
519e 06 00			ld b, 0 
51a0			 
51a0 e1				pop hl 
51a1 11 79 fa			ld de, store_page + 2 
51a4					if DEBUG_FORTH_WORDS 
51a4						DMARK "BW1" 
51a4 f5				push af  
51a5 3a b9 51			ld a, (.dmark)  
51a8 32 68 fe			ld (debug_mark),a  
51ab 3a ba 51			ld a, (.dmark+1)  
51ae 32 69 fe			ld (debug_mark+1),a  
51b1 3a bb 51			ld a, (.dmark+2)  
51b4 32 6a fe			ld (debug_mark+2),a  
51b7 18 03			jr .pastdmark  
51b9 ..			.dmark: db "BW1"  
51bc f1			.pastdmark: pop af  
51bd			endm  
# End of macro DMARK
51bd						CALLMONITOR 
51bd cd 6c fe			call debug_vector  
51c0				endm  
# End of macro CALLMONITOR
51c0					endif 
51c0 ed b0			ldir 
51c2			 
51c2			 
51c2				; poke the start of the block with flags to prevent high level file ops hitting the block 
51c2			 
51c2 21 ff ff			ld hl, $ffff 
51c5			 
51c5 22 77 fa			ld (store_page), hl	 
51c8				 
51c8 e1				pop hl    ; get address 
51c9 11 77 fa			ld de, store_page 
51cc			 
51cc					if DEBUG_FORTH_WORDS 
51cc						DMARK "BW2" 
51cc f5				push af  
51cd 3a e1 51			ld a, (.dmark)  
51d0 32 68 fe			ld (debug_mark),a  
51d3 3a e2 51			ld a, (.dmark+1)  
51d6 32 69 fe			ld (debug_mark+1),a  
51d9 3a e3 51			ld a, (.dmark+2)  
51dc 32 6a fe			ld (debug_mark+2),a  
51df 18 03			jr .pastdmark  
51e1 ..			.dmark: db "BW2"  
51e4 f1			.pastdmark: pop af  
51e5			endm  
# End of macro DMARK
51e5						CALLMONITOR 
51e5 cd 6c fe			call debug_vector  
51e8				endm  
# End of macro CALLMONITOR
51e8					endif 
51e8			 
51e8 cd cb 04			call storage_write_block 
51eb			 
51eb					NEXTW 
51eb c3 b3 24			jp macro_next 
51ee				endm 
# End of macro NEXTW
51ee			 
51ee			.BUPD: 
51ee				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51ee 3a				db WORD_SYS_CORE+38             
51ef 44 52			dw .BYID            
51f1 05				db 4 + 1 
51f2 .. 00			db "BUPD",0              
51f7				endm 
# End of macro CWHEAD
51f7			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51f7			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51f7			; | | or completely different file system structure. 
51f7			; | | Compatible with PicoSPINet  
51f7			 
51f7					if DEBUG_FORTH_WORDS_KEY 
51f7						DMARK "BUD" 
51f7 f5				push af  
51f8 3a 0c 52			ld a, (.dmark)  
51fb 32 68 fe			ld (debug_mark),a  
51fe 3a 0d 52			ld a, (.dmark+1)  
5201 32 69 fe			ld (debug_mark+1),a  
5204 3a 0e 52			ld a, (.dmark+2)  
5207 32 6a fe			ld (debug_mark+2),a  
520a 18 03			jr .pastdmark  
520c ..			.dmark: db "BUD"  
520f f1			.pastdmark: pop af  
5210			endm  
# End of macro DMARK
5210						CALLMONITOR 
5210 cd 6c fe			call debug_vector  
5213				endm  
# End of macro CALLMONITOR
5213					endif 
5213			 
5213				FORTH_DSP_VALUEHL 
5213 cd fd 22			call macro_dsp_valuehl 
5216				endm 
# End of macro FORTH_DSP_VALUEHL
5216			 
5216				; calc block address 
5216			 
5216 eb				ex de, hl 
5217 3e 40			ld a, STORE_BLOCK_PHY 
5219 cd 53 0f			call Mult16 
521c			 
521c				FORTH_DSP_POP 
521c cd b5 23			call macro_forth_dsp_pop 
521f				endm 
# End of macro FORTH_DSP_POP
521f			 
521f			 
521f 11 77 fa			ld de, store_page 
5222			 
5222					if DEBUG_FORTH_WORDS 
5222						DMARK "BUe" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 68 fe			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 69 fe			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 6a fe			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "BUe"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd 6c fe			call debug_vector  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e			 
523e cd cb 04			call storage_write_block 
5241			 
5241					NEXTW 
5241 c3 b3 24			jp macro_next 
5244				endm 
# End of macro NEXTW
5244			 
5244			.BYID: 
5244			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5244			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5244			; 
5244			;		 
5244			;		if DEBUG_FORTH_WORDS_KEY 
5244			;			DMARK "BYID" 
5244			;			CALLMONITOR 
5244			;		endif 
5244			; 
5244			;		; get direct address 
5244			; 
5244			;		FORTH_DSP_VALUEHL 
5244			; 
5244			;		FORTH_DSP_POP 
5244			; 
5244			;	; calc block address 
5244			; 
5244			;	ex de, hl 
5244			;	ld a, STORE_BLOCK_PHY 
5244			;	call Mult16 
5244			;	;	do BREAD with number as param 
5244			;	; push the file name	 
5244			;	ld de, store_page 
5244			;	call storage_read_block 
5244			 ;       ld hl, store_page+2 
5244			; 
5244			; 
5244			;		NEXTW 
5244			;.BYNAME: 
5244				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5244 3a				db WORD_SYS_CORE+38             
5245 5d 52			dw .DIR            
5247 06				db 5 + 1 
5248 .. 00			db "GETID",0              
524e				endm 
# End of macro CWHEAD
524e			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
524e			; | | Compatible with PicoSPINet  
524e			 
524e					; get pointer to file name to seek 
524e			 
524e					FORTH_DSP_VALUEHL 
524e cd fd 22			call macro_dsp_valuehl 
5251				endm 
# End of macro FORTH_DSP_VALUEHL
5251			 
5251			 
5251 cd 8d 03				call storage_getid  
5254			 
5254					FORTH_DSP_POP 
5254 cd b5 23			call macro_forth_dsp_pop 
5257				endm 
# End of macro FORTH_DSP_POP
5257			 
5257 cd 06 21				call forth_push_numhl 
525a			 
525a					NEXTW 
525a c3 b3 24			jp macro_next 
525d				endm 
# End of macro NEXTW
525d			; 
525d			.DIR: 
525d				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
525d 3a				db WORD_SYS_CORE+38             
525e 61 53			dw .SAVE            
5260 04				db 3 + 1 
5261 .. 00			db "DIR",0              
5265				endm 
# End of macro CWHEAD
5265			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5265			; | | Compatible with PicoSPINet  
5265			 
5265					if DEBUG_FORTH_WORDS_KEY 
5265						DMARK "DIR" 
5265 f5				push af  
5266 3a 7a 52			ld a, (.dmark)  
5269 32 68 fe			ld (debug_mark),a  
526c 3a 7b 52			ld a, (.dmark+1)  
526f 32 69 fe			ld (debug_mark+1),a  
5272 3a 7c 52			ld a, (.dmark+2)  
5275 32 6a fe			ld (debug_mark+2),a  
5278 18 03			jr .pastdmark  
527a ..			.dmark: db "DIR"  
527d f1			.pastdmark: pop af  
527e			endm  
# End of macro DMARK
527e						CALLMONITOR 
527e cd 6c fe			call debug_vector  
5281				endm  
# End of macro CALLMONITOR
5281					endif 
5281 cd 17 05			call storage_get_block_0 
5284			 
5284 21 77 fa			ld hl, store_page     ; get current id count 
5287 46				ld b, (hl) 
5288 0e 00			ld c, 0    ; count of files   
528a					if DEBUG_FORTH_WORDS 
528a						DMARK "DI1" 
528a f5				push af  
528b 3a 9f 52			ld a, (.dmark)  
528e 32 68 fe			ld (debug_mark),a  
5291 3a a0 52			ld a, (.dmark+1)  
5294 32 69 fe			ld (debug_mark+1),a  
5297 3a a1 52			ld a, (.dmark+2)  
529a 32 6a fe			ld (debug_mark+2),a  
529d 18 03			jr .pastdmark  
529f ..			.dmark: db "DI1"  
52a2 f1			.pastdmark: pop af  
52a3			endm  
# End of macro DMARK
52a3						CALLMONITOR 
52a3 cd 6c fe			call debug_vector  
52a6				endm  
# End of macro CALLMONITOR
52a6					endif 
52a6			 
52a6				; check for empty drive 
52a6			 
52a6 3e 00			ld a, 0 
52a8 b8				cp b 
52a9 ca 17 53			jp z, .dirdone 
52ac			 
52ac				; for each of the current ids do a search for them and if found push to stack 
52ac			 
52ac c5			.diritem:	push bc 
52ad 21 40 00				ld hl, STORE_BLOCK_PHY 
52b0 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52b2 58					ld e,b 
52b3			 
52b3			;		if DEBUG_FORTH_WORDS 
52b3			;			DMARK "DI2" 
52b3			;			CALLMONITOR 
52b3			;		endif 
52b3			 
52b3 cd 99 07				call storage_findnextid 
52b6			 
52b6			;		if DEBUG_FORTH_WORDS 
52b6			;			DMARK "DI3" 
52b6			;			CALLMONITOR 
52b6			;		endif 
52b6			 
52b6					; if found hl will be non zero 
52b6			 
52b6 cd f9 0f				call ishlzero 
52b9			;		ld a, l 
52b9			;		add h 
52b9			; 
52b9			;		cp 0 
52b9 28 59				jr z, .dirnotfound 
52bb			 
52bb					; increase count 
52bb			 
52bb c1					pop bc	 
52bc 0c					inc c 
52bd c5					push bc 
52be					 
52be			 
52be					; get file header and push the file name 
52be			 
52be 11 77 fa				ld de, store_page 
52c1 cd 66 04				call storage_read_block 
52c4			 
52c4					; push file id to stack 
52c4				 
52c4 3a 77 fa				ld a, (store_page) 
52c7 26 00				ld h, 0 
52c9 6f					ld l, a 
52ca cd 06 21				call forth_push_numhl 
52cd			 
52cd					; push extent count to stack  
52cd				 
52cd 3a 79 fa				ld a, (store_page+2) 
52d0 26 00				ld h, 0 
52d2 6f					ld l, a 
52d3 cd 06 21				call forth_push_numhl 
52d6			 
52d6					; push file name 
52d6			 
52d6 21 7a fa				ld hl, store_page+3 
52d9					if DEBUG_FORTH_WORDS 
52d9						DMARK "DI5" 
52d9 f5				push af  
52da 3a ee 52			ld a, (.dmark)  
52dd 32 68 fe			ld (debug_mark),a  
52e0 3a ef 52			ld a, (.dmark+1)  
52e3 32 69 fe			ld (debug_mark+1),a  
52e6 3a f0 52			ld a, (.dmark+2)  
52e9 32 6a fe			ld (debug_mark+2),a  
52ec 18 03			jr .pastdmark  
52ee ..			.dmark: db "DI5"  
52f1 f1			.pastdmark: pop af  
52f2			endm  
# End of macro DMARK
52f2						CALLMONITOR 
52f2 cd 6c fe			call debug_vector  
52f5				endm  
# End of macro CALLMONITOR
52f5					endif 
52f5 cd 74 21				call forth_push_str 
52f8					if DEBUG_FORTH_WORDS 
52f8						DMARK "DI6" 
52f8 f5				push af  
52f9 3a 0d 53			ld a, (.dmark)  
52fc 32 68 fe			ld (debug_mark),a  
52ff 3a 0e 53			ld a, (.dmark+1)  
5302 32 69 fe			ld (debug_mark+1),a  
5305 3a 0f 53			ld a, (.dmark+2)  
5308 32 6a fe			ld (debug_mark+2),a  
530b 18 03			jr .pastdmark  
530d ..			.dmark: db "DI6"  
5310 f1			.pastdmark: pop af  
5311			endm  
# End of macro DMARK
5311						CALLMONITOR 
5311 cd 6c fe			call debug_vector  
5314				endm  
# End of macro CALLMONITOR
5314					endif 
5314			.dirnotfound: 
5314 c1					pop bc     
5315 10 95				djnz .diritem 
5317				 
5317			.dirdone:	 
5317					if DEBUG_FORTH_WORDS 
5317						DMARK "DI7" 
5317 f5				push af  
5318 3a 2c 53			ld a, (.dmark)  
531b 32 68 fe			ld (debug_mark),a  
531e 3a 2d 53			ld a, (.dmark+1)  
5321 32 69 fe			ld (debug_mark+1),a  
5324 3a 2e 53			ld a, (.dmark+2)  
5327 32 6a fe			ld (debug_mark+2),a  
532a 18 03			jr .pastdmark  
532c ..			.dmark: db "DI7"  
532f f1			.pastdmark: pop af  
5330			endm  
# End of macro DMARK
5330						CALLMONITOR 
5330 cd 6c fe			call debug_vector  
5333				endm  
# End of macro CALLMONITOR
5333					endif 
5333			 
5333					; push a count of the dir items found 
5333			 
5333 26 00				ld h, 0 
5335 69					ld l, c 
5336 cd 06 21				call forth_push_numhl 
5339			 
5339					; push the bank label 
5339			 
5339 cd 17 05				call storage_get_block_0 
533c			 
533c				 
533c 21 7a fa		 		ld hl, store_page+3 
533f			 
533f					if DEBUG_FORTH_WORDS 
533f						DMARK "DI8" 
533f f5				push af  
5340 3a 54 53			ld a, (.dmark)  
5343 32 68 fe			ld (debug_mark),a  
5346 3a 55 53			ld a, (.dmark+1)  
5349 32 69 fe			ld (debug_mark+1),a  
534c 3a 56 53			ld a, (.dmark+2)  
534f 32 6a fe			ld (debug_mark+2),a  
5352 18 03			jr .pastdmark  
5354 ..			.dmark: db "DI8"  
5357 f1			.pastdmark: pop af  
5358			endm  
# End of macro DMARK
5358						CALLMONITOR 
5358 cd 6c fe			call debug_vector  
535b				endm  
# End of macro CALLMONITOR
535b					endif 
535b cd 74 21				call forth_push_str 
535e			 
535e			 
535e				 
535e					NEXTW 
535e c3 b3 24			jp macro_next 
5361				endm 
# End of macro NEXTW
5361			.SAVE: 
5361			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5361			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5361			;		NEXTW 
5361			;.LOAD: 
5361			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5361			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5361			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5361			;; > > The LOAD command can not be used in any user words or compound lines. 
5361			; 
5361			;		; store_openext use it. If zero it is EOF 
5361			; 
5361			;		; read block from current stream id 
5361			;		; if the block does not contain zero term keep reading blocks until zero found 
5361			;		; push the block to stack 
5361			;		; save the block id to stream 
5361			; 
5361			; 
5361			;		FORTH_DSP_VALUEHL 
5361			; 
5361			;;		push hl 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LOA" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;		FORTH_DSP_POP 
5361			; 
5361			;;		pop hl 
5361			; 
5361			;		ld h, l 
5361			;		ld l, 0 
5361			; 
5361			;		push hl     ; stack holds current file id and extent to work with 
5361			; 
5361			; 
5361			;		ld de, store_page      ; get block zero of file 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LO0" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;		call storage_read 
5361			; 
5361			;		ld a, (store_page+2)    ; max extents for this file 
5361			;		ld  (store_openmaxext),a   ; get our limit 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LOE" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			; 
5361			;; TODO dont know why max extents are not present 
5361			;;		cp 0 
5361			;;		jp z, .loadeof     ; dont read past eof 
5361			; 
5361			;;		ld a, 1   ; start from the head of the file 
5361			; 
5361			;.loadline:	pop hl 
5361			;		inc hl 
5361			;		ld  a, (store_openmaxext)   ; get our limit 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LOx" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;		inc a 
5361			;		cp l 
5361			;		jp z, .loadeof 
5361			;		push hl    ; save current extent 
5361			; 
5361			;		ld de, store_page 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LO1" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;		call storage_read 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LO2" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;	call ishlzero 
5361			;	ld a, l 
5361			;	add h 
5361			;	cp 0 
5361			;	jr z, .loadeof 
5361			; 
5361			;	; not eof so hl should point to data to exec 
5361			; 
5361			;	; will need to add the FORTH_END_BUFFER flag 
5361			 ; 
5361			;	ld hl, store_page+2 
5361			;	ld bc, 255 
5361			;	ld a, 0 
5361			;	cpir 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LOt" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;	dec hl 
5361			;	ld a, ' ' 
5361			;	ld (hl), a 
5361			;	inc hl 
5361			;	ld (hl), a 
5361			;	inc hl 
5361			;	ld (hl), a 
5361			;	inc hl 
5361			;	ld a, FORTH_END_BUFFER 
5361			;	ld (hl), a 
5361			; 
5361			;	; TODO handle more than a single block read 
5361			; 
5361			; 
5361			;	ld hl, store_page+2 
5361			; 
5361			;	ld (os_tok_ptr), hl 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LO3" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			; 
5361			;	call forthparse 
5361			;	call forthexec 
5361			;	call forthexec_cleanup 
5361			; 
5361			;	; go to next extent 
5361			; 
5361			;	; get next block  or mark as eof 
5361			;	jp .loadline 
5361			; 
5361			; 
5361			; 
5361			;	       NEXTW 
5361			;.loadeof:	ld a, 0 
5361			;		ld (store_openext), a 
5361			; 
5361			;	if DEBUG_STORESE 
5361			;		DMARK "LOF" 
5361			;		CALLMONITOR 
5361			;	endif 
5361			;		ret 
5361			;		;NEXTW 
5361			;.BSAVE:   
5361			; 
5361			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5361			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5361			;		NEXTW 
5361			;.BLOAD: 
5361			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5361			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5361			;		NEXTW 
5361			;;;; counter gap 
5361			 
5361			 
5361			.SEO: 
5361				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5361 64				db WORD_SYS_CORE+80             
5362 80 53			dw .SEI            
5364 04				db 3 + 1 
5365 .. 00			db "SEO",0              
5369				endm 
# End of macro CWHEAD
5369			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5369			 
5369					; get port 
5369			 
5369					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5369 cd fd 22			call macro_dsp_valuehl 
536c				endm 
# End of macro FORTH_DSP_VALUEHL
536c			 
536c e5					push hl    ; u2 - byte 
536d			 
536d					; destroy value TOS 
536d			 
536d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
536d cd b5 23			call macro_forth_dsp_pop 
5370				endm 
# End of macro FORTH_DSP_POP
5370			 
5370					; get byte to send 
5370			 
5370					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5370 cd fd 22			call macro_dsp_valuehl 
5373				endm 
# End of macro FORTH_DSP_VALUEHL
5373			 
5373 e5					push hl    ; u1 - addr 
5374			 
5374					; destroy value TOS 
5374			 
5374					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5374 cd b5 23			call macro_forth_dsp_pop 
5377				endm 
# End of macro FORTH_DSP_POP
5377			 
5377					; one value on hl get other one back 
5377			 
5377 d1					pop de   ; u1 - byte 
5378			 
5378 e1					pop hl   ; u2 - addr 
5379			 
5379					; TODO Send SPI byte 
5379			 
5379			 
5379 7b					ld a, e 
537a cd 6b 02				call se_writebyte 
537d			 
537d					 
537d			 
537d					NEXTW 
537d c3 b3 24			jp macro_next 
5380				endm 
# End of macro NEXTW
5380			 
5380			.SEI: 
5380				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5380 65				db WORD_SYS_CORE+81             
5381 9a 53			dw .SFREE            
5383 04				db 3 + 1 
5384 .. 00			db "SEI",0              
5388				endm 
# End of macro CWHEAD
5388			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5388			 
5388					; get port 
5388			 
5388					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5388 cd fd 22			call macro_dsp_valuehl 
538b				endm 
# End of macro FORTH_DSP_VALUEHL
538b			 
538b			;		push hl 
538b			 
538b					; destroy value TOS 
538b			 
538b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
538b cd b5 23			call macro_forth_dsp_pop 
538e				endm 
# End of macro FORTH_DSP_POP
538e			 
538e					; one value on hl get other one back 
538e			 
538e			;		pop hl 
538e			 
538e			 
538e					; TODO Get SPI byte 
538e			 
538e cd 0d 03				call se_readbyte 
5391			 
5391 26 00				ld h, 0 
5393 6f					ld l, a 
5394 cd 06 21				call forth_push_numhl 
5397			 
5397					NEXTW 
5397 c3 b3 24			jp macro_next 
539a				endm 
# End of macro NEXTW
539a			 
539a			.SFREE: 
539a				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
539a 67				db WORD_SYS_CORE+83             
539b c9 53			dw .SIZE            
539d 06				db 5 + 1 
539e .. 00			db "FFREE",0              
53a4				endm 
# End of macro CWHEAD
53a4			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53a4			; | | Compatible with PicoSPINet  
53a4					if DEBUG_FORTH_WORDS_KEY 
53a4						DMARK "FFR" 
53a4 f5				push af  
53a5 3a b9 53			ld a, (.dmark)  
53a8 32 68 fe			ld (debug_mark),a  
53ab 3a ba 53			ld a, (.dmark+1)  
53ae 32 69 fe			ld (debug_mark+1),a  
53b1 3a bb 53			ld a, (.dmark+2)  
53b4 32 6a fe			ld (debug_mark+2),a  
53b7 18 03			jr .pastdmark  
53b9 ..			.dmark: db "FFR"  
53bc f1			.pastdmark: pop af  
53bd			endm  
# End of macro DMARK
53bd						CALLMONITOR 
53bd cd 6c fe			call debug_vector  
53c0				endm  
# End of macro CALLMONITOR
53c0					endif 
53c0			 
53c0 cd 33 08				call storage_freeblocks 
53c3			 
53c3 cd 06 21				call forth_push_numhl 
53c6			 
53c6				       NEXTW 
53c6 c3 b3 24			jp macro_next 
53c9				endm 
# End of macro NEXTW
53c9			.SIZE: 
53c9				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53c9 67				db WORD_SYS_CORE+83             
53ca fd 53			dw .CREATE            
53cc 05				db 4 + 1 
53cd .. 00			db "SIZE",0              
53d2				endm 
# End of macro CWHEAD
53d2			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53d2			; | | Compatible with PicoSPINet  
53d2					if DEBUG_FORTH_WORDS_KEY 
53d2						DMARK "SIZ" 
53d2 f5				push af  
53d3 3a e7 53			ld a, (.dmark)  
53d6 32 68 fe			ld (debug_mark),a  
53d9 3a e8 53			ld a, (.dmark+1)  
53dc 32 69 fe			ld (debug_mark+1),a  
53df 3a e9 53			ld a, (.dmark+2)  
53e2 32 6a fe			ld (debug_mark+2),a  
53e5 18 03			jr .pastdmark  
53e7 ..			.dmark: db "SIZ"  
53ea f1			.pastdmark: pop af  
53eb			endm  
# End of macro DMARK
53eb						CALLMONITOR 
53eb cd 6c fe			call debug_vector  
53ee				endm  
# End of macro CALLMONITOR
53ee					endif 
53ee			 
53ee					FORTH_DSP_VALUEHL 
53ee cd fd 22			call macro_dsp_valuehl 
53f1				endm 
# End of macro FORTH_DSP_VALUEHL
53f1			;		push hl 
53f1					FORTH_DSP_POP 
53f1 cd b5 23			call macro_forth_dsp_pop 
53f4				endm 
# End of macro FORTH_DSP_POP
53f4			;		pop hl 
53f4 cd 95 04				call storage_file_size 
53f7			 
53f7 cd 06 21				call forth_push_numhl 
53fa			  
53fa			 
53fa				       NEXTW 
53fa c3 b3 24			jp macro_next 
53fd				endm 
# End of macro NEXTW
53fd			 
53fd			.CREATE: 
53fd				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53fd 68				db WORD_SYS_CORE+84             
53fe 6b 54			dw .APPEND            
5400 07				db 6 + 1 
5401 .. 00			db "CREATE",0              
5408				endm 
# End of macro CWHEAD
5408			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5408			; | | e.g.  
5408			; | | TestProgram CREATE 
5408			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5408			; | |  
5408			; | | Max file IDs are 255. 
5408			; | |  
5408			; | | Compatible with PicoSPINet  
5408					 
5408					if DEBUG_FORTH_WORDS_KEY 
5408						DMARK "CRT" 
5408 f5				push af  
5409 3a 1d 54			ld a, (.dmark)  
540c 32 68 fe			ld (debug_mark),a  
540f 3a 1e 54			ld a, (.dmark+1)  
5412 32 69 fe			ld (debug_mark+1),a  
5415 3a 1f 54			ld a, (.dmark+2)  
5418 32 6a fe			ld (debug_mark+2),a  
541b 18 03			jr .pastdmark  
541d ..			.dmark: db "CRT"  
5420 f1			.pastdmark: pop af  
5421			endm  
# End of macro DMARK
5421						CALLMONITOR 
5421 cd 6c fe			call debug_vector  
5424				endm  
# End of macro CALLMONITOR
5424					endif 
5424			;		call storage_get_block_0 
5424			 
5424					; TODO pop hl 
5424			 
5424					;v5 FORTH_DSP_VALUE 
5424					FORTH_DSP_VALUE 
5424 cd e6 22			call macro_forth_dsp_value 
5427				endm 
# End of macro FORTH_DSP_VALUE
5427			 
5427				if DEBUG_STORESE 
5427					DMARK "CR1" 
5427 f5				push af  
5428 3a 3c 54			ld a, (.dmark)  
542b 32 68 fe			ld (debug_mark),a  
542e 3a 3d 54			ld a, (.dmark+1)  
5431 32 69 fe			ld (debug_mark+1),a  
5434 3a 3e 54			ld a, (.dmark+2)  
5437 32 6a fe			ld (debug_mark+2),a  
543a 18 03			jr .pastdmark  
543c ..			.dmark: db "CR1"  
543f f1			.pastdmark: pop af  
5440			endm  
# End of macro DMARK
5440					CALLMONITOR 
5440 cd 6c fe			call debug_vector  
5443				endm  
# End of macro CALLMONITOR
5443				endif 
5443			;		push hl 
5443			;		FORTH_DSP_POP 
5443			;		pop hl 
5443			 
5443			;		inc hl   ; move past the type marker 
5443			 
5443 cd 69 08				call storage_create 
5446			 
5446				if DEBUG_STORESE 
5446					DMARK "CT1" 
5446 f5				push af  
5447 3a 5b 54			ld a, (.dmark)  
544a 32 68 fe			ld (debug_mark),a  
544d 3a 5c 54			ld a, (.dmark+1)  
5450 32 69 fe			ld (debug_mark+1),a  
5453 3a 5d 54			ld a, (.dmark+2)  
5456 32 6a fe			ld (debug_mark+2),a  
5459 18 03			jr .pastdmark  
545b ..			.dmark: db "CT1"  
545e f1			.pastdmark: pop af  
545f			endm  
# End of macro DMARK
545f					CALLMONITOR 
545f cd 6c fe			call debug_vector  
5462				endm  
# End of macro CALLMONITOR
5462				endif 
5462			;		push hl 
5462					FORTH_DSP_POP 
5462 cd b5 23			call macro_forth_dsp_pop 
5465				endm 
# End of macro FORTH_DSP_POP
5465			;		pop hl 
5465					; push file id to stack 
5465 cd 06 21				call forth_push_numhl 
5468			 
5468			 
5468			 
5468				       NEXTW 
5468 c3 b3 24			jp macro_next 
546b				endm 
# End of macro NEXTW
546b			 
546b			.APPEND: 
546b				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
546b 69				db WORD_SYS_CORE+85             
546c fc 54			dw .SDEL            
546e 07				db 6 + 1 
546f .. 00			db "APPEND",0              
5476				endm 
# End of macro CWHEAD
5476			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5476			; | | e.g. 
5476			; | | Test CREATE      -> $01 
5476			; | | "A string to add to file" $01 APPEND 
5476			; | |  
5476			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5476			; | | Compatible with PicoSPINet  
5476					if DEBUG_FORTH_WORDS_KEY 
5476						DMARK "APP" 
5476 f5				push af  
5477 3a 8b 54			ld a, (.dmark)  
547a 32 68 fe			ld (debug_mark),a  
547d 3a 8c 54			ld a, (.dmark+1)  
5480 32 69 fe			ld (debug_mark+1),a  
5483 3a 8d 54			ld a, (.dmark+2)  
5486 32 6a fe			ld (debug_mark+2),a  
5489 18 03			jr .pastdmark  
548b ..			.dmark: db "APP"  
548e f1			.pastdmark: pop af  
548f			endm  
# End of macro DMARK
548f						CALLMONITOR 
548f cd 6c fe			call debug_vector  
5492				endm  
# End of macro CALLMONITOR
5492					endif 
5492			 
5492					FORTH_DSP_VALUEHL 
5492 cd fd 22			call macro_dsp_valuehl 
5495				endm 
# End of macro FORTH_DSP_VALUEHL
5495 e5					push hl 	; save file id 
5496			 
5496				if DEBUG_STORESE 
5496					DMARK "AP1" 
5496 f5				push af  
5497 3a ab 54			ld a, (.dmark)  
549a 32 68 fe			ld (debug_mark),a  
549d 3a ac 54			ld a, (.dmark+1)  
54a0 32 69 fe			ld (debug_mark+1),a  
54a3 3a ad 54			ld a, (.dmark+2)  
54a6 32 6a fe			ld (debug_mark+2),a  
54a9 18 03			jr .pastdmark  
54ab ..			.dmark: db "AP1"  
54ae f1			.pastdmark: pop af  
54af			endm  
# End of macro DMARK
54af					CALLMONITOR 
54af cd 6c fe			call debug_vector  
54b2				endm  
# End of macro CALLMONITOR
54b2				endif 
54b2					FORTH_DSP_POP 
54b2 cd b5 23			call macro_forth_dsp_pop 
54b5				endm 
# End of macro FORTH_DSP_POP
54b5			 
54b5					FORTH_DSP_VALUEHL 
54b5 cd fd 22			call macro_dsp_valuehl 
54b8				endm 
# End of macro FORTH_DSP_VALUEHL
54b8					;v5 FORTH_DSP_VALUE 
54b8 e5					push hl 	; save ptr to string to save 
54b9			 
54b9				if DEBUG_STORESE 
54b9					DMARK "AP1" 
54b9 f5				push af  
54ba 3a ce 54			ld a, (.dmark)  
54bd 32 68 fe			ld (debug_mark),a  
54c0 3a cf 54			ld a, (.dmark+1)  
54c3 32 69 fe			ld (debug_mark+1),a  
54c6 3a d0 54			ld a, (.dmark+2)  
54c9 32 6a fe			ld (debug_mark+2),a  
54cc 18 03			jr .pastdmark  
54ce ..			.dmark: db "AP1"  
54d1 f1			.pastdmark: pop af  
54d2			endm  
# End of macro DMARK
54d2					CALLMONITOR 
54d2 cd 6c fe			call debug_vector  
54d5				endm  
# End of macro CALLMONITOR
54d5				endif 
54d5					FORTH_DSP_POP 
54d5 cd b5 23			call macro_forth_dsp_pop 
54d8				endm 
# End of macro FORTH_DSP_POP
54d8			 
54d8 d1					pop de 
54d9 e1					pop hl 
54da				if DEBUG_STORESE 
54da					DMARK "AP2" 
54da f5				push af  
54db 3a ef 54			ld a, (.dmark)  
54de 32 68 fe			ld (debug_mark),a  
54e1 3a f0 54			ld a, (.dmark+1)  
54e4 32 69 fe			ld (debug_mark+1),a  
54e7 3a f1 54			ld a, (.dmark+2)  
54ea 32 6a fe			ld (debug_mark+2),a  
54ed 18 03			jr .pastdmark  
54ef ..			.dmark: db "AP2"  
54f2 f1			.pastdmark: pop af  
54f3			endm  
# End of macro DMARK
54f3					CALLMONITOR 
54f3 cd 6c fe			call debug_vector  
54f6				endm  
# End of macro CALLMONITOR
54f6				endif 
54f6					;inc de ; skip var type indicator 
54f6			 
54f6					; TODO how to append numerics???? 
54f6			 
54f6 cd 56 0b				call storage_append		 
54f9			 
54f9				       NEXTW 
54f9 c3 b3 24			jp macro_next 
54fc				endm 
# End of macro NEXTW
54fc			.SDEL: 
54fc				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54fc 6a				db WORD_SYS_CORE+86             
54fd 48 55			dw .OPEN            
54ff 05				db 4 + 1 
5500 .. 00			db "ERA",0              
5504				endm 
# End of macro CWHEAD
5504			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5504			; | | Compatible with PicoSPINet  
5504					FORTH_DSP_VALUEHL 
5504 cd fd 22			call macro_dsp_valuehl 
5507				endm 
# End of macro FORTH_DSP_VALUEHL
5507			;		push hl 	; save file id 
5507			 
5507					if DEBUG_FORTH_WORDS_KEY 
5507						DMARK "ERA" 
5507 f5				push af  
5508 3a 1c 55			ld a, (.dmark)  
550b 32 68 fe			ld (debug_mark),a  
550e 3a 1d 55			ld a, (.dmark+1)  
5511 32 69 fe			ld (debug_mark+1),a  
5514 3a 1e 55			ld a, (.dmark+2)  
5517 32 6a fe			ld (debug_mark+2),a  
551a 18 03			jr .pastdmark  
551c ..			.dmark: db "ERA"  
551f f1			.pastdmark: pop af  
5520			endm  
# End of macro DMARK
5520						CALLMONITOR 
5520 cd 6c fe			call debug_vector  
5523				endm  
# End of macro CALLMONITOR
5523					endif 
5523				if DEBUG_STORESE 
5523					DMARK "ER1" 
5523 f5				push af  
5524 3a 38 55			ld a, (.dmark)  
5527 32 68 fe			ld (debug_mark),a  
552a 3a 39 55			ld a, (.dmark+1)  
552d 32 69 fe			ld (debug_mark+1),a  
5530 3a 3a 55			ld a, (.dmark+2)  
5533 32 6a fe			ld (debug_mark+2),a  
5536 18 03			jr .pastdmark  
5538 ..			.dmark: db "ER1"  
553b f1			.pastdmark: pop af  
553c			endm  
# End of macro DMARK
553c					CALLMONITOR 
553c cd 6c fe			call debug_vector  
553f				endm  
# End of macro CALLMONITOR
553f				endif 
553f					FORTH_DSP_POP 
553f cd b5 23			call macro_forth_dsp_pop 
5542				endm 
# End of macro FORTH_DSP_POP
5542			 
5542			;		pop hl 
5542			 
5542 cd a8 06				call storage_erase 
5545				       NEXTW 
5545 c3 b3 24			jp macro_next 
5548				endm 
# End of macro NEXTW
5548			 
5548			.OPEN: 
5548				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5548 6b				db WORD_SYS_CORE+87             
5549 dc 55			dw .READ            
554b 05				db 4 + 1 
554c .. 00			db "OPEN",0              
5551				endm 
# End of macro CWHEAD
5551			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5551			; | | e.g. 
5551			; | | $01 OPEN $01 DO $01 READ . LOOP 
5551			; | | 
5551			; | | Will return with 255 blocks if the file does not exist 
5551			; | | Compatible with PicoSPINet  
5551			 
5551					if DEBUG_FORTH_WORDS_KEY 
5551						DMARK "OPN" 
5551 f5				push af  
5552 3a 66 55			ld a, (.dmark)  
5555 32 68 fe			ld (debug_mark),a  
5558 3a 67 55			ld a, (.dmark+1)  
555b 32 69 fe			ld (debug_mark+1),a  
555e 3a 68 55			ld a, (.dmark+2)  
5561 32 6a fe			ld (debug_mark+2),a  
5564 18 03			jr .pastdmark  
5566 ..			.dmark: db "OPN"  
5569 f1			.pastdmark: pop af  
556a			endm  
# End of macro DMARK
556a						CALLMONITOR 
556a cd 6c fe			call debug_vector  
556d				endm  
# End of macro CALLMONITOR
556d					endif 
556d					; TODO handle multiple file opens 
556d			 
556d 3e 01			       	ld a, 1 
556f 32 67 fa				ld (store_openext), a 
5572			 
5572					; get max extents for this file 
5572				 
5572								 
5572					FORTH_DSP_VALUEHL 
5572 cd fd 22			call macro_dsp_valuehl 
5575				endm 
# End of macro FORTH_DSP_VALUEHL
5575			 
5575 65					ld h, l 
5576 2e 00				ld l, 0 
5578			 
5578					; store file id 
5578			 
5578 7c					ld a, h 
5579 32 64 fa				ld (store_filecache), a 
557c			 
557c				if DEBUG_STORESE 
557c					DMARK "OPN" 
557c f5				push af  
557d 3a 91 55			ld a, (.dmark)  
5580 32 68 fe			ld (debug_mark),a  
5583 3a 92 55			ld a, (.dmark+1)  
5586 32 69 fe			ld (debug_mark+1),a  
5589 3a 93 55			ld a, (.dmark+2)  
558c 32 6a fe			ld (debug_mark+2),a  
558f 18 03			jr .pastdmark  
5591 ..			.dmark: db "OPN"  
5594 f1			.pastdmark: pop af  
5595			endm  
# End of macro DMARK
5595					CALLMONITOR 
5595 cd 6c fe			call debug_vector  
5598				endm  
# End of macro CALLMONITOR
5598				endif 
5598			;		push hl 
5598					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5598 cd b5 23			call macro_forth_dsp_pop 
559b				endm 
# End of macro FORTH_DSP_POP
559b			;		pop hl 
559b						 
559b 11 77 fa				ld de, store_page      ; get block zero of file 
559e cd bf 09				call storage_read 
55a1 cd f9 0f			call ishlzero 
55a4 20 04			jr nz, .opfound 
55a6			 
55a6				; file does not exist so indicate with 255 extents in use 
55a6			 
55a6 3e ff			ld a, 255 
55a8 18 29			jr .skipopeneof 
55aa			 
55aa			 
55aa			.opfound: 
55aa			 
55aa			 
55aa 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
55ad 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
55b0					 
55b0				if DEBUG_STORESE 
55b0					DMARK "OPx" 
55b0 f5				push af  
55b1 3a c5 55			ld a, (.dmark)  
55b4 32 68 fe			ld (debug_mark),a  
55b7 3a c6 55			ld a, (.dmark+1)  
55ba 32 69 fe			ld (debug_mark+1),a  
55bd 3a c7 55			ld a, (.dmark+2)  
55c0 32 6a fe			ld (debug_mark+2),a  
55c3 18 03			jr .pastdmark  
55c5 ..			.dmark: db "OPx"  
55c8 f1			.pastdmark: pop af  
55c9			endm  
# End of macro DMARK
55c9					CALLMONITOR 
55c9 cd 6c fe			call debug_vector  
55cc				endm  
# End of macro CALLMONITOR
55cc				endif 
55cc fe 00				cp 0 
55ce 20 03				jr nz, .skipopeneof 
55d0					; have opened an empty file 
55d0					 
55d0 32 67 fa				ld (store_openext), a 
55d3			 
55d3			.skipopeneof: 
55d3			 
55d3 6f					ld l, a 
55d4 26 00				ld h, 0 
55d6 cd 06 21				call forth_push_numhl 
55d9			 
55d9			 
55d9				       NEXTW 
55d9 c3 b3 24			jp macro_next 
55dc				endm 
# End of macro NEXTW
55dc			.READ: 
55dc				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55dc 6c				db WORD_SYS_CORE+88             
55dd 06 57			dw .EOF            
55df 05				db 4 + 1 
55e0 .. 00			db "READ",0              
55e5				endm 
# End of macro CWHEAD
55e5			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55e5			; | | e.g. 
55e5			; | | $01 OPEN $01 DO READ . LOOP 
55e5			; | | 
55e5			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55e5			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55e5			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55e5			; | | two bytes contain the file id and extent. 
55e5			; | |  
55e5			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55e5			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55e5			; | | Compatible with PicoSPINet  
55e5			 
55e5					if DEBUG_FORTH_WORDS_KEY 
55e5						DMARK "REA" 
55e5 f5				push af  
55e6 3a fa 55			ld a, (.dmark)  
55e9 32 68 fe			ld (debug_mark),a  
55ec 3a fb 55			ld a, (.dmark+1)  
55ef 32 69 fe			ld (debug_mark+1),a  
55f2 3a fc 55			ld a, (.dmark+2)  
55f5 32 6a fe			ld (debug_mark+2),a  
55f8 18 03			jr .pastdmark  
55fa ..			.dmark: db "REA"  
55fd f1			.pastdmark: pop af  
55fe			endm  
# End of macro DMARK
55fe						CALLMONITOR 
55fe cd 6c fe			call debug_vector  
5601				endm  
# End of macro CALLMONITOR
5601					endif 
5601					; store_openext use it. If zero it is EOF 
5601			 
5601					; read block from current stream id 
5601					; if the block does not contain zero term keep reading blocks until zero found 
5601					; push the block to stack 
5601					; save the block id to stream 
5601			 
5601			 
5601 cd 33 57				call .testeof 
5604 3e 01				ld a, 1 
5606 bd					cp l 
5607 ca e2 56				jp z, .ateof 
560a			 
560a			 
560a			;		FORTH_DSP_VALUEHL 
560a			 
560a			;		push hl 
560a			 
560a			;	if DEBUG_STORESE 
560a			;		DMARK "REA" 
560a			;		CALLMONITOR 
560a			;	endif 
560a			;		FORTH_DSP_POP 
560a			 
560a			;		pop hl 
560a				 
560a 3a 64 fa				ld a, (store_filecache) 
560d 67					ld h,a 
560e			 
560e 3a 67 fa				ld a, (store_openext) 
5611 6f					ld l, a 
5612					 
5612 fe 00				cp 0 
5614 ca e2 56				jp z, .ateof     ; dont read past eof 
5617			 
5617 cd a2 0c				call storage_clear_page 
561a			 
561a 11 77 fa				ld de, store_page 
561d				if DEBUG_STORESE 
561d					DMARK "RE1" 
561d f5				push af  
561e 3a 32 56			ld a, (.dmark)  
5621 32 68 fe			ld (debug_mark),a  
5624 3a 33 56			ld a, (.dmark+1)  
5627 32 69 fe			ld (debug_mark+1),a  
562a 3a 34 56			ld a, (.dmark+2)  
562d 32 6a fe			ld (debug_mark+2),a  
5630 18 03			jr .pastdmark  
5632 ..			.dmark: db "RE1"  
5635 f1			.pastdmark: pop af  
5636			endm  
# End of macro DMARK
5636					CALLMONITOR 
5636 cd 6c fe			call debug_vector  
5639				endm  
# End of macro CALLMONITOR
5639				endif 
5639 cd bf 09				call storage_read 
563c			 
563c				if DEBUG_STORESE 
563c					DMARK "RE2" 
563c f5				push af  
563d 3a 51 56			ld a, (.dmark)  
5640 32 68 fe			ld (debug_mark),a  
5643 3a 52 56			ld a, (.dmark+1)  
5646 32 69 fe			ld (debug_mark+1),a  
5649 3a 53 56			ld a, (.dmark+2)  
564c 32 6a fe			ld (debug_mark+2),a  
564f 18 03			jr .pastdmark  
5651 ..			.dmark: db "RE2"  
5654 f1			.pastdmark: pop af  
5655			endm  
# End of macro DMARK
5655					CALLMONITOR 
5655 cd 6c fe			call debug_vector  
5658				endm  
# End of macro CALLMONITOR
5658				endif 
5658 cd f9 0f			call ishlzero 
565b			;	ld a, l 
565b			;	add h 
565b			;	cp 0 
565b ca e2 56			jp z, .readeof 
565e			 
565e				; not eof so hl should point to data to push to stack 
565e			 
565e				if DEBUG_STORESE 
565e					DMARK "RE3" 
565e f5				push af  
565f 3a 73 56			ld a, (.dmark)  
5662 32 68 fe			ld (debug_mark),a  
5665 3a 74 56			ld a, (.dmark+1)  
5668 32 69 fe			ld (debug_mark+1),a  
566b 3a 75 56			ld a, (.dmark+2)  
566e 32 6a fe			ld (debug_mark+2),a  
5671 18 03			jr .pastdmark  
5673 ..			.dmark: db "RE3"  
5676 f1			.pastdmark: pop af  
5677			endm  
# End of macro DMARK
5677					CALLMONITOR 
5677 cd 6c fe			call debug_vector  
567a				endm  
# End of macro CALLMONITOR
567a				endif 
567a cd 74 21			call forth_push_str 
567d			 
567d				if DEBUG_STORESE 
567d					DMARK "RE4" 
567d f5				push af  
567e 3a 92 56			ld a, (.dmark)  
5681 32 68 fe			ld (debug_mark),a  
5684 3a 93 56			ld a, (.dmark+1)  
5687 32 69 fe			ld (debug_mark+1),a  
568a 3a 94 56			ld a, (.dmark+2)  
568d 32 6a fe			ld (debug_mark+2),a  
5690 18 03			jr .pastdmark  
5692 ..			.dmark: db "RE4"  
5695 f1			.pastdmark: pop af  
5696			endm  
# End of macro DMARK
5696					CALLMONITOR 
5696 cd 6c fe			call debug_vector  
5699				endm  
# End of macro CALLMONITOR
5699				endif 
5699				; get next block  or mark as eof 
5699			 
5699 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
569c 4f				ld c, a	 
569d 3a 67 fa			ld a, (store_openext) 
56a0			 
56a0				if DEBUG_STORESE 
56a0					DMARK "RE5" 
56a0 f5				push af  
56a1 3a b5 56			ld a, (.dmark)  
56a4 32 68 fe			ld (debug_mark),a  
56a7 3a b6 56			ld a, (.dmark+1)  
56aa 32 69 fe			ld (debug_mark+1),a  
56ad 3a b7 56			ld a, (.dmark+2)  
56b0 32 6a fe			ld (debug_mark+2),a  
56b3 18 03			jr .pastdmark  
56b5 ..			.dmark: db "RE5"  
56b8 f1			.pastdmark: pop af  
56b9			endm  
# End of macro DMARK
56b9					CALLMONITOR 
56b9 cd 6c fe			call debug_vector  
56bc				endm  
# End of macro CALLMONITOR
56bc				endif 
56bc b9				cp c 
56bd 28 23			jr z, .readeof     ; at last extent 
56bf			 
56bf 3c					inc a 
56c0 32 67 fa				ld (store_openext), a 
56c3			 
56c3				if DEBUG_STORESE 
56c3					DMARK "RE6" 
56c3 f5				push af  
56c4 3a d8 56			ld a, (.dmark)  
56c7 32 68 fe			ld (debug_mark),a  
56ca 3a d9 56			ld a, (.dmark+1)  
56cd 32 69 fe			ld (debug_mark+1),a  
56d0 3a da 56			ld a, (.dmark+2)  
56d3 32 6a fe			ld (debug_mark+2),a  
56d6 18 03			jr .pastdmark  
56d8 ..			.dmark: db "RE6"  
56db f1			.pastdmark: pop af  
56dc			endm  
# End of macro DMARK
56dc					CALLMONITOR 
56dc cd 6c fe			call debug_vector  
56df				endm  
# End of macro CALLMONITOR
56df				endif 
56df			 
56df			 
56df				       NEXTW 
56df c3 b3 24			jp macro_next 
56e2				endm 
# End of macro NEXTW
56e2			.ateof: 
56e2				;	ld hl, .showeof 
56e2				;	call forth_push_str 
56e2 3e 00		.readeof:	ld a, 0 
56e4 32 67 fa				ld (store_openext), a 
56e7			 
56e7					 
56e7				if DEBUG_STORESE 
56e7					DMARK "REF" 
56e7 f5				push af  
56e8 3a fc 56			ld a, (.dmark)  
56eb 32 68 fe			ld (debug_mark),a  
56ee 3a fd 56			ld a, (.dmark+1)  
56f1 32 69 fe			ld (debug_mark+1),a  
56f4 3a fe 56			ld a, (.dmark+2)  
56f7 32 6a fe			ld (debug_mark+2),a  
56fa 18 03			jr .pastdmark  
56fc ..			.dmark: db "REF"  
56ff f1			.pastdmark: pop af  
5700			endm  
# End of macro DMARK
5700					CALLMONITOR 
5700 cd 6c fe			call debug_vector  
5703				endm  
# End of macro CALLMONITOR
5703				endif 
5703				       NEXTW 
5703 c3 b3 24			jp macro_next 
5706				endm 
# End of macro NEXTW
5706			 
5706			;.showeof:   db "eof", 0 
5706			 
5706			 
5706			.EOF: 
5706				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5706 6d				db WORD_SYS_CORE+89             
5707 48 57			dw .FORMAT            
5709 04				db 3 + 1 
570a .. 00			db "EOF",0              
570e				endm 
# End of macro CWHEAD
570e			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
570e			; | | e.g. 
570e			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
570e			; | | Compatible with PicoSPINet  
570e					; TODO if current block id for stream is zero then push true else false 
570e			 
570e					if DEBUG_FORTH_WORDS_KEY 
570e						DMARK "EOF" 
570e f5				push af  
570f 3a 23 57			ld a, (.dmark)  
5712 32 68 fe			ld (debug_mark),a  
5715 3a 24 57			ld a, (.dmark+1)  
5718 32 69 fe			ld (debug_mark+1),a  
571b 3a 25 57			ld a, (.dmark+2)  
571e 32 6a fe			ld (debug_mark+2),a  
5721 18 03			jr .pastdmark  
5723 ..			.dmark: db "EOF"  
5726 f1			.pastdmark: pop af  
5727			endm  
# End of macro DMARK
5727						CALLMONITOR 
5727 cd 6c fe			call debug_vector  
572a				endm  
# End of macro CALLMONITOR
572a					endif 
572a			 
572a					; TODO handlue multiple file streams 
572a			 
572a			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
572a cd 33 57				call .testeof 
572d cd 06 21				call forth_push_numhl 
5730			 
5730			 
5730				       NEXTW 
5730 c3 b3 24			jp macro_next 
5733				endm 
# End of macro NEXTW
5733			 
5733			.testeof: 
5733 2e 01				ld l, 1 
5735 3a 66 fa				ld a, (store_openmaxext) 
5738 fe 00				cp 0 
573a 28 09				jr  z, .eofdone   ; empty file 
573c 3a 67 fa				ld a, (store_openext) 
573f fe 00				cp 0 
5741 28 02				jr  z, .eofdone 
5743 2e 00				ld l, 0 
5745 26 00		.eofdone:	ld h, 0 
5747 c9					ret 
5748			 
5748			 
5748			 
5748			 
5748			.FORMAT: 
5748				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5748 6d				db WORD_SYS_CORE+89             
5749 99 57			dw .LABEL            
574b 07				db 6 + 1 
574c .. 00			db "FORMAT",0              
5753				endm 
# End of macro CWHEAD
5753			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5753			; | | Compatible with PicoSPINet  
5753					; TODO if current block id for stream is zero then push true else false 
5753				 
5753				if DEBUG_STORESE 
5753					DMARK "FOR" 
5753 f5				push af  
5754 3a 68 57			ld a, (.dmark)  
5757 32 68 fe			ld (debug_mark),a  
575a 3a 69 57			ld a, (.dmark+1)  
575d 32 69 fe			ld (debug_mark+1),a  
5760 3a 6a 57			ld a, (.dmark+2)  
5763 32 6a fe			ld (debug_mark+2),a  
5766 18 03			jr .pastdmark  
5768 ..			.dmark: db "FOR"  
576b f1			.pastdmark: pop af  
576c			endm  
# End of macro DMARK
576c					CALLMONITOR 
576c cd 6c fe			call debug_vector  
576f				endm  
# End of macro CALLMONITOR
576f				endif 
576f					; Wipes the bank check flags to cause a reformat on next block 0 read 
576f			 
576f 21 01 00				ld hl, 1 
5772 3e 00				ld a, 0 
5774 cd 6b 02				call se_writebyte 
5777			 
5777				if DEBUG_STORESE 
5777					DMARK "FO0" 
5777 f5				push af  
5778 3a 8c 57			ld a, (.dmark)  
577b 32 68 fe			ld (debug_mark),a  
577e 3a 8d 57			ld a, (.dmark+1)  
5781 32 69 fe			ld (debug_mark+1),a  
5784 3a 8e 57			ld a, (.dmark+2)  
5787 32 6a fe			ld (debug_mark+2),a  
578a 18 03			jr .pastdmark  
578c ..			.dmark: db "FO0"  
578f f1			.pastdmark: pop af  
5790			endm  
# End of macro DMARK
5790					CALLMONITOR 
5790 cd 6c fe			call debug_vector  
5793				endm  
# End of macro CALLMONITOR
5793				endif 
5793					; force bank init 
5793			 
5793 cd 17 05				call storage_get_block_0 
5796					 
5796				       NEXTW 
5796 c3 b3 24			jp macro_next 
5799				endm 
# End of macro NEXTW
5799			.LABEL: 
5799				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5799 6d				db WORD_SYS_CORE+89             
579a e7 57			dw .STOREPAGE            
579c 06				db 5 + 1 
579d .. 00			db "LABEL",0              
57a3				endm 
# End of macro CWHEAD
57a3			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57a3			; | | Compatible with PicoSPINet  
57a3					; TODO test to see if bank is selected 
57a3				 
57a3					if DEBUG_FORTH_WORDS_KEY 
57a3						DMARK "LBL" 
57a3 f5				push af  
57a4 3a b8 57			ld a, (.dmark)  
57a7 32 68 fe			ld (debug_mark),a  
57aa 3a b9 57			ld a, (.dmark+1)  
57ad 32 69 fe			ld (debug_mark+1),a  
57b0 3a ba 57			ld a, (.dmark+2)  
57b3 32 6a fe			ld (debug_mark+2),a  
57b6 18 03			jr .pastdmark  
57b8 ..			.dmark: db "LBL"  
57bb f1			.pastdmark: pop af  
57bc			endm  
# End of macro DMARK
57bc						CALLMONITOR 
57bc cd 6c fe			call debug_vector  
57bf				endm  
# End of macro CALLMONITOR
57bf					endif 
57bf			;	if DEBUG_STORESE 
57bf			;		DMARK "LBL" 
57bf			;		CALLMONITOR 
57bf			;	endif 
57bf					FORTH_DSP_VALUEHL 
57bf cd fd 22			call macro_dsp_valuehl 
57c2				endm 
# End of macro FORTH_DSP_VALUEHL
57c2					;v5FORTH_DSP_VALUE 
57c2					 
57c2			;		push hl 
57c2					FORTH_DSP_POP 
57c2 cd b5 23			call macro_forth_dsp_pop 
57c5				endm 
# End of macro FORTH_DSP_POP
57c5			;		pop hl 
57c5			 
57c5			;v5		inc hl   ; move past the type marker 
57c5			 
57c5				if DEBUG_STORESE 
57c5					DMARK "LBl" 
57c5 f5				push af  
57c6 3a da 57			ld a, (.dmark)  
57c9 32 68 fe			ld (debug_mark),a  
57cc 3a db 57			ld a, (.dmark+1)  
57cf 32 69 fe			ld (debug_mark+1),a  
57d2 3a dc 57			ld a, (.dmark+2)  
57d5 32 6a fe			ld (debug_mark+2),a  
57d8 18 03			jr .pastdmark  
57da ..			.dmark: db "LBl"  
57dd f1			.pastdmark: pop af  
57de			endm  
# End of macro DMARK
57de					CALLMONITOR 
57de cd 6c fe			call debug_vector  
57e1				endm  
# End of macro CALLMONITOR
57e1				endif 
57e1 cd 3b 06				call storage_label 
57e4			 
57e4				       NEXTW 
57e4 c3 b3 24			jp macro_next 
57e7				endm 
# End of macro NEXTW
57e7			.STOREPAGE: 
57e7				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57e7 6d				db WORD_SYS_CORE+89             
57e8 1a 58			dw .LABELS            
57ea 0a				db 9 + 1 
57eb .. 00			db "STOREPAGE",0              
57f5				endm 
# End of macro CWHEAD
57f5			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57f5			; | | Compatible with PicoSPINet  
57f5					; TODO test to see if bank is selected 
57f5				 
57f5					if DEBUG_FORTH_WORDS_KEY 
57f5						DMARK "STP" 
57f5 f5				push af  
57f6 3a 0a 58			ld a, (.dmark)  
57f9 32 68 fe			ld (debug_mark),a  
57fc 3a 0b 58			ld a, (.dmark+1)  
57ff 32 69 fe			ld (debug_mark+1),a  
5802 3a 0c 58			ld a, (.dmark+2)  
5805 32 6a fe			ld (debug_mark+2),a  
5808 18 03			jr .pastdmark  
580a ..			.dmark: db "STP"  
580d f1			.pastdmark: pop af  
580e			endm  
# End of macro DMARK
580e						CALLMONITOR 
580e cd 6c fe			call debug_vector  
5811				endm  
# End of macro CALLMONITOR
5811					endif 
5811			;	if DEBUG_STORESE 
5811			;		DMARK "STP" 
5811			;		CALLMONITOR 
5811			;	endif 
5811			 
5811 21 77 fa			ld hl, store_page 
5814 cd 06 21			call forth_push_numhl 
5817			 
5817			 
5817				       NEXTW 
5817 c3 b3 24			jp macro_next 
581a				endm 
# End of macro NEXTW
581a			.LABELS: 
581a				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
581a 6d				db WORD_SYS_CORE+89             
581b a4 58			dw .SCONST1            
581d 07				db 6 + 1 
581e .. 00			db "LABELS",0              
5825				endm 
# End of macro CWHEAD
5825			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5825			; | | *NOT* Compatible with PicoSPINet  
5825					;  
5825			 
5825					; save the current device selected to restore afterwards 
5825				 
5825 3a 5d fa				ld a, (spi_device) 
5828 f5					push af 
5829			 
5829			 
5829					; run through each of the banks 
5829			 
5829 21 01 00				ld hl, 1 
582c cd 06 21				call forth_push_numhl 
582f 3e ff				ld a, SPI_CE_HIGH 
5831 cb 87				res SPI_CE0, a 
5833 32 5d fa				ld (spi_device), a 
5836 cd 17 05				call storage_get_block_0 
5839 21 7a fa				ld hl, store_page+3 
583c cd 74 21				call forth_push_str 
583f			 
583f					 
583f 21 02 00				ld hl, 2 
5842 cd 06 21				call forth_push_numhl 
5845 3e ff				ld a, SPI_CE_HIGH 
5847 cb 8f				res SPI_CE1, a 
5849 32 5d fa				ld (spi_device), a 
584c cd 17 05				call storage_get_block_0 
584f 21 7a fa				ld hl, store_page+3 
5852 cd 74 21				call forth_push_str 
5855			 
5855					 
5855 21 03 00				ld hl, 3 
5858 cd 06 21				call forth_push_numhl 
585b 3e ff				ld a, SPI_CE_HIGH 
585d cb 97				res SPI_CE2, a 
585f 32 5d fa				ld (spi_device), a 
5862 cd 17 05				call storage_get_block_0 
5865 21 7a fa				ld hl, store_page+3 
5868 cd 74 21				call forth_push_str 
586b			 
586b			 
586b 21 04 00				ld hl, 4 
586e cd 06 21				call forth_push_numhl 
5871 3e ff				ld a, SPI_CE_HIGH 
5873 cb 9f				res SPI_CE3, a 
5875 32 5d fa				ld (spi_device), a 
5878 cd 17 05				call storage_get_block_0 
587b 21 7a fa				ld hl, store_page+3 
587e cd 74 21				call forth_push_str 
5881			 
5881					 
5881			 
5881 21 05 00				ld hl, 5 
5884 cd 06 21				call forth_push_numhl 
5887 3e ff				ld a, SPI_CE_HIGH 
5889 cb a7				res SPI_CE4, a 
588b 32 5d fa				ld (spi_device), a 
588e cd 17 05				call storage_get_block_0 
5891 21 7a fa				ld hl, store_page+3 
5894 cd 74 21				call forth_push_str 
5897			 
5897					 
5897					; push fixed count of storage devices (on board) for now 
5897			 
5897 21 05 00				ld hl, 5 
589a cd 06 21				call forth_push_numhl 
589d			 
589d					; restore selected device  
589d				 
589d f1					pop af 
589e 32 5d fa				ld (spi_device), a 
58a1			 
58a1				       NEXTW 
58a1 c3 b3 24			jp macro_next 
58a4				endm 
# End of macro NEXTW
58a4			 
58a4			.SCONST1: 
58a4				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58a4 6d				db WORD_SYS_CORE+89             
58a5 bb 58			dw .SCONST2            
58a7 07				db 6 + 1 
58a8 .. 00			db "FILEID",0              
58af				endm 
# End of macro CWHEAD
58af			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58af			; | | Compatible with PicoSPINet  
58af 3a 64 fa				ld a, (store_filecache) 
58b2 26 00				ld h, 0 
58b4 6f					ld l, a 
58b5 cd 06 21				call forth_push_numhl 
58b8					NEXTW 
58b8 c3 b3 24			jp macro_next 
58bb				endm 
# End of macro NEXTW
58bb			.SCONST2: 
58bb				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58bb 6d				db WORD_SYS_CORE+89             
58bc d3 58			dw .SCONST3            
58be 08				db 7 + 1 
58bf .. 00			db "FILEEXT",0              
58c7				endm 
# End of macro CWHEAD
58c7			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
58c7			; | | Compatible with PicoSPINet  
58c7 3a 67 fa				ld a, (store_openext) 
58ca 26 00				ld h, 0 
58cc 6f					ld l, a 
58cd cd 06 21				call forth_push_numhl 
58d0					NEXTW 
58d0 c3 b3 24			jp macro_next 
58d3				endm 
# End of macro NEXTW
58d3			.SCONST3: 
58d3				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58d3 6d				db WORD_SYS_CORE+89             
58d4 eb 58			dw .SCONST4            
58d6 08				db 7 + 1 
58d7 .. 00			db "FILEMAX",0              
58df				endm 
# End of macro CWHEAD
58df			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58df			; | | Compatible with PicoSPINet  
58df 3a 66 fa				ld a, (store_openmaxext) 
58e2 26 00				ld h, 0 
58e4 6f					ld l, a 
58e5 cd 06 21				call forth_push_numhl 
58e8					NEXTW 
58e8 c3 b3 24			jp macro_next 
58eb				endm 
# End of macro NEXTW
58eb			.SCONST4: 
58eb				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58eb 6d				db WORD_SYS_CORE+89             
58ec 01 59			dw .SCONST5            
58ee 09				db 8 + 1 
58ef .. 00			db "FILEADDR",0              
58f8				endm 
# End of macro CWHEAD
58f8			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
58f8			; | | Compatible with PicoSPINet  
58f8 2a 68 fa				ld hl, (store_openaddr) 
58fb cd 06 21				call forth_push_numhl 
58fe					NEXTW 
58fe c3 b3 24			jp macro_next 
5901				endm 
# End of macro NEXTW
5901			.SCONST5: 
5901				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5901 6d				db WORD_SYS_CORE+89             
5902 22 59			dw .SCONST6            
5904 09				db 8 + 1 
5905 .. 00			db "FILEPAGE",0              
590e				endm 
# End of macro CWHEAD
590e			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
590e			; | | Compatible with PicoSPINet  
590e 2a 68 fa				ld hl, (store_openaddr) 
5911 e5					push hl 
5912 c1					pop bc 
5913 16 00				ld d, 0 
5915 1e 40				ld e, STORE_BLOCK_PHY 
5917 cd 2d 0f				call Div16 
591a c5					push bc 
591b e1					pop hl 
591c cd 06 21				call forth_push_numhl 
591f					NEXTW 
591f c3 b3 24			jp macro_next 
5922				endm 
# End of macro NEXTW
5922			.SCONST6: 
5922				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5922 6d				db WORD_SYS_CORE+89             
5923 3b 59			dw .ENDSTORAGE            
5925 09				db 8 + 1 
5926 .. 00			db "READCONT",0              
592f				endm 
# End of macro CWHEAD
592f			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
592f			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
592f			; | | a further read should, if applicable, be CONCAT to the previous read. 
592f			; | | Compatible with PicoSPINet  
592f 3a 6a fa				ld a, (store_readcont) 
5932 26 00				ld h, 0 
5934 6f					ld l, a 
5935 cd 06 21				call forth_push_numhl 
5938					NEXTW 
5938 c3 b3 24			jp macro_next 
593b				endm 
# End of macro NEXTW
593b			.ENDSTORAGE: 
593b			; eof 
# End of file forth_words_storage.asm
593b			endif 
593b				include "forth_words_device.asm" 
593b			; Device related words 
593b			 
593b			; | ## Device Words 
593b			 
593b			;if SOUND_ENABLE 
593b			;.NOTE: 
593b			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
593b			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
593b			;		if DEBUG_FORTH_WORDS_KEY 
593b			;			DMARK "NTE" 
593b			;			CALLMONITOR 
593b			;		endif 
593b			; 
593b			;	 
593b			; 
593b			;		NEXTW 
593b			;.AFTERSOUND: 
593b			;endif 
593b			 
593b			 
593b			USE_GPIO: equ 0 
593b			 
593b			if USE_GPIO 
593b			.GP1: 
593b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
593b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
593b					NEXTW 
593b			.GP2: 
593b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
593b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
593b			 
593b					NEXTW 
593b			 
593b			.GP3: 
593b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
593b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
593b			 
593b					NEXTW 
593b			 
593b			.GP4: 
593b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
593b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
593b			 
593b					NEXTW 
593b			.SIN: 
593b			 
593b			 
593b			endif 
593b			 
593b			 
593b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
593b 33				db WORD_SYS_CORE+31             
593c 70 59			dw .SOUT            
593e 03				db 2 + 1 
593f .. 00			db "IN",0              
5942				endm 
# End of macro CWHEAD
5942			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5942					if DEBUG_FORTH_WORDS_KEY 
5942						DMARK "IN." 
5942 f5				push af  
5943 3a 57 59			ld a, (.dmark)  
5946 32 68 fe			ld (debug_mark),a  
5949 3a 58 59			ld a, (.dmark+1)  
594c 32 69 fe			ld (debug_mark+1),a  
594f 3a 59 59			ld a, (.dmark+2)  
5952 32 6a fe			ld (debug_mark+2),a  
5955 18 03			jr .pastdmark  
5957 ..			.dmark: db "IN."  
595a f1			.pastdmark: pop af  
595b			endm  
# End of macro DMARK
595b						CALLMONITOR 
595b cd 6c fe			call debug_vector  
595e				endm  
# End of macro CALLMONITOR
595e					endif 
595e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
595e cd fd 22			call macro_dsp_valuehl 
5961				endm 
# End of macro FORTH_DSP_VALUEHL
5961			 
5961 e5					push hl 
5962			 
5962					; destroy value TOS 
5962			 
5962					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5962 cd b5 23			call macro_forth_dsp_pop 
5965				endm 
# End of macro FORTH_DSP_POP
5965			 
5965					; one value on hl get other one back 
5965			 
5965 c1					pop bc 
5966			 
5966					; do the sub 
5966			;		ex de, hl 
5966			 
5966 ed 68				in l,(c) 
5968			 
5968					; save it 
5968			 
5968 26 00				ld h,0 
596a			 
596a					; TODO push value back onto stack for another op etc 
596a			 
596a cd 06 21				call forth_push_numhl 
596d					NEXTW 
596d c3 b3 24			jp macro_next 
5970				endm 
# End of macro NEXTW
5970			.SOUT: 
5970				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5970 34				db WORD_SYS_CORE+32             
5971 c3 59			dw .SPIO            
5973 04				db 3 + 1 
5974 .. 00			db "OUT",0              
5978				endm 
# End of macro CWHEAD
5978			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5978					if DEBUG_FORTH_WORDS_KEY 
5978						DMARK "OUT" 
5978 f5				push af  
5979 3a 8d 59			ld a, (.dmark)  
597c 32 68 fe			ld (debug_mark),a  
597f 3a 8e 59			ld a, (.dmark+1)  
5982 32 69 fe			ld (debug_mark+1),a  
5985 3a 8f 59			ld a, (.dmark+2)  
5988 32 6a fe			ld (debug_mark+2),a  
598b 18 03			jr .pastdmark  
598d ..			.dmark: db "OUT"  
5990 f1			.pastdmark: pop af  
5991			endm  
# End of macro DMARK
5991						CALLMONITOR 
5991 cd 6c fe			call debug_vector  
5994				endm  
# End of macro CALLMONITOR
5994					endif 
5994			 
5994					; get port 
5994			 
5994					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5994 cd fd 22			call macro_dsp_valuehl 
5997				endm 
# End of macro FORTH_DSP_VALUEHL
5997			 
5997 e5					push hl 
5998			 
5998					; destroy value TOS 
5998			 
5998					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5998 cd b5 23			call macro_forth_dsp_pop 
599b				endm 
# End of macro FORTH_DSP_POP
599b			 
599b					; get byte to send 
599b			 
599b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
599b cd fd 22			call macro_dsp_valuehl 
599e				endm 
# End of macro FORTH_DSP_VALUEHL
599e			 
599e			;		push hl 
599e			 
599e					; destroy value TOS 
599e			 
599e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
599e cd b5 23			call macro_forth_dsp_pop 
59a1				endm 
# End of macro FORTH_DSP_POP
59a1			 
59a1					; one value on hl get other one back 
59a1			 
59a1			;		pop hl 
59a1			 
59a1 c1					pop bc 
59a2			 
59a2					if DEBUG_FORTH_WORDS 
59a2						DMARK "OUT" 
59a2 f5				push af  
59a3 3a b7 59			ld a, (.dmark)  
59a6 32 68 fe			ld (debug_mark),a  
59a9 3a b8 59			ld a, (.dmark+1)  
59ac 32 69 fe			ld (debug_mark+1),a  
59af 3a b9 59			ld a, (.dmark+2)  
59b2 32 6a fe			ld (debug_mark+2),a  
59b5 18 03			jr .pastdmark  
59b7 ..			.dmark: db "OUT"  
59ba f1			.pastdmark: pop af  
59bb			endm  
# End of macro DMARK
59bb						CALLMONITOR 
59bb cd 6c fe			call debug_vector  
59be				endm  
# End of macro CALLMONITOR
59be					endif 
59be			 
59be ed 69				out (c), l 
59c0			 
59c0					NEXTW 
59c0 c3 b3 24			jp macro_next 
59c3				endm 
# End of macro NEXTW
59c3			 
59c3			 
59c3			.SPIO: 
59c3			 
59c3			if STORAGE_SE 
59c3				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59c3 51				db WORD_SYS_CORE+61             
59c4 d4 59			dw .SPICEH            
59c6 07				db 6 + 1 
59c7 .. 00			db "SPICEL",0              
59ce				endm 
# End of macro CWHEAD
59ce			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59ce			 
59ce cd 14 02				call spi_ce_low 
59d1			    NEXTW 
59d1 c3 b3 24			jp macro_next 
59d4				endm 
# End of macro NEXTW
59d4			 
59d4			.SPICEH: 
59d4				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59d4 51				db WORD_SYS_CORE+61             
59d5 e5 59			dw .SPIOb            
59d7 07				db 6 + 1 
59d8 .. 00			db "SPICEH",0              
59df				endm 
# End of macro CWHEAD
59df			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59df			 
59df cd 03 02				call spi_ce_high 
59e2			    NEXTW 
59e2 c3 b3 24			jp macro_next 
59e5				endm 
# End of macro NEXTW
59e5			 
59e5			 
59e5			.SPIOb: 
59e5			 
59e5				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59e5 51				db WORD_SYS_CORE+61             
59e6 17 5a			dw .SPII            
59e8 05				db 4 + 1 
59e9 .. 00			db "SPIO",0              
59ee				endm 
# End of macro CWHEAD
59ee			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59ee			 
59ee					if DEBUG_FORTH_WORDS_KEY 
59ee						DMARK "SPo" 
59ee f5				push af  
59ef 3a 03 5a			ld a, (.dmark)  
59f2 32 68 fe			ld (debug_mark),a  
59f5 3a 04 5a			ld a, (.dmark+1)  
59f8 32 69 fe			ld (debug_mark+1),a  
59fb 3a 05 5a			ld a, (.dmark+2)  
59fe 32 6a fe			ld (debug_mark+2),a  
5a01 18 03			jr .pastdmark  
5a03 ..			.dmark: db "SPo"  
5a06 f1			.pastdmark: pop af  
5a07			endm  
# End of macro DMARK
5a07						CALLMONITOR 
5a07 cd 6c fe			call debug_vector  
5a0a				endm  
# End of macro CALLMONITOR
5a0a					endif 
5a0a					; get port 
5a0a			 
5a0a			 
5a0a					; get byte to send 
5a0a			 
5a0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a0a cd fd 22			call macro_dsp_valuehl 
5a0d				endm 
# End of macro FORTH_DSP_VALUEHL
5a0d			 
5a0d			;		push hl    ; u1  
5a0d			 
5a0d					; destroy value TOS 
5a0d			 
5a0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a0d cd b5 23			call macro_forth_dsp_pop 
5a10				endm 
# End of macro FORTH_DSP_POP
5a10			 
5a10					; one value on hl get other one back 
5a10			 
5a10			;		pop hl   ; u2 - addr 
5a10			 
5a10					; TODO Send SPI byte 
5a10			 
5a10			;		push hl 
5a10			;		call spi_ce_low 
5a10			;		pop hl 
5a10 7d					ld a, l 
5a11 cd 02 01				call spi_send_byte 
5a14			;		call spi_ce_high 
5a14			 
5a14					NEXTW 
5a14 c3 b3 24			jp macro_next 
5a17				endm 
# End of macro NEXTW
5a17			 
5a17			.SPII: 
5a17				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a17 52				db WORD_SYS_CORE+62             
5a18 80 5a			dw .SESEL            
5a1a 06				db 5 + 1 
5a1b .. 00			db "SPII",0              
5a20				endm 
# End of macro CWHEAD
5a20			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a20					if DEBUG_FORTH_WORDS_KEY 
5a20						DMARK "SPi" 
5a20 f5				push af  
5a21 3a 35 5a			ld a, (.dmark)  
5a24 32 68 fe			ld (debug_mark),a  
5a27 3a 36 5a			ld a, (.dmark+1)  
5a2a 32 69 fe			ld (debug_mark+1),a  
5a2d 3a 37 5a			ld a, (.dmark+2)  
5a30 32 6a fe			ld (debug_mark+2),a  
5a33 18 03			jr .pastdmark  
5a35 ..			.dmark: db "SPi"  
5a38 f1			.pastdmark: pop af  
5a39			endm  
# End of macro DMARK
5a39						CALLMONITOR 
5a39 cd 6c fe			call debug_vector  
5a3c				endm  
# End of macro CALLMONITOR
5a3c					endif 
5a3c			 
5a3c					; TODO Get SPI byte 
5a3c			 
5a3c cd 29 01				call spi_read_byte 
5a3f			 
5a3f					if DEBUG_FORTH_WORDS 
5a3f						DMARK "Si2" 
5a3f f5				push af  
5a40 3a 54 5a			ld a, (.dmark)  
5a43 32 68 fe			ld (debug_mark),a  
5a46 3a 55 5a			ld a, (.dmark+1)  
5a49 32 69 fe			ld (debug_mark+1),a  
5a4c 3a 56 5a			ld a, (.dmark+2)  
5a4f 32 6a fe			ld (debug_mark+2),a  
5a52 18 03			jr .pastdmark  
5a54 ..			.dmark: db "Si2"  
5a57 f1			.pastdmark: pop af  
5a58			endm  
# End of macro DMARK
5a58						CALLMONITOR 
5a58 cd 6c fe			call debug_vector  
5a5b				endm  
# End of macro CALLMONITOR
5a5b					endif 
5a5b 26 00				ld h, 0 
5a5d 6f					ld l, a 
5a5e					if DEBUG_FORTH_WORDS 
5a5e						DMARK "Si3" 
5a5e f5				push af  
5a5f 3a 73 5a			ld a, (.dmark)  
5a62 32 68 fe			ld (debug_mark),a  
5a65 3a 74 5a			ld a, (.dmark+1)  
5a68 32 69 fe			ld (debug_mark+1),a  
5a6b 3a 75 5a			ld a, (.dmark+2)  
5a6e 32 6a fe			ld (debug_mark+2),a  
5a71 18 03			jr .pastdmark  
5a73 ..			.dmark: db "Si3"  
5a76 f1			.pastdmark: pop af  
5a77			endm  
# End of macro DMARK
5a77						CALLMONITOR 
5a77 cd 6c fe			call debug_vector  
5a7a				endm  
# End of macro CALLMONITOR
5a7a					endif 
5a7a cd 06 21				call forth_push_numhl 
5a7d			 
5a7d					NEXTW 
5a7d c3 b3 24			jp macro_next 
5a80				endm 
# End of macro NEXTW
5a80			 
5a80			 
5a80			 
5a80			.SESEL: 
5a80				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a80 66				db WORD_SYS_CORE+82             
5a81 29 5b			dw .CARTDEV            
5a83 05				db 4 + 1 
5a84 .. 00			db "BANK",0              
5a89				endm 
# End of macro CWHEAD
5a89			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a89					if DEBUG_FORTH_WORDS_KEY 
5a89						DMARK "BNK" 
5a89 f5				push af  
5a8a 3a 9e 5a			ld a, (.dmark)  
5a8d 32 68 fe			ld (debug_mark),a  
5a90 3a 9f 5a			ld a, (.dmark+1)  
5a93 32 69 fe			ld (debug_mark+1),a  
5a96 3a a0 5a			ld a, (.dmark+2)  
5a99 32 6a fe			ld (debug_mark+2),a  
5a9c 18 03			jr .pastdmark  
5a9e ..			.dmark: db "BNK"  
5aa1 f1			.pastdmark: pop af  
5aa2			endm  
# End of macro DMARK
5aa2						CALLMONITOR 
5aa2 cd 6c fe			call debug_vector  
5aa5				endm  
# End of macro CALLMONITOR
5aa5					endif 
5aa5			 
5aa5 3e ff				ld a, 255 
5aa7 32 60 fa				ld (spi_cartdev), a 
5aaa			 
5aaa					; get bank 
5aaa			 
5aaa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5aaa cd fd 22			call macro_dsp_valuehl 
5aad				endm 
# End of macro FORTH_DSP_VALUEHL
5aad			 
5aad			;		push hl 
5aad			 
5aad					; destroy value TOS 
5aad			 
5aad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aad cd b5 23			call macro_forth_dsp_pop 
5ab0				endm 
# End of macro FORTH_DSP_POP
5ab0			 
5ab0					; one value on hl get other one back 
5ab0			 
5ab0			;		pop hl 
5ab0			 
5ab0			 
5ab0 0e ff				ld c, SPI_CE_HIGH 
5ab2 06 30				ld b, '0'    ; human readable bank number 
5ab4			 
5ab4 7d					ld a, l 
5ab5			 
5ab5					if DEBUG_FORTH_WORDS 
5ab5						DMARK "BNK" 
5ab5 f5				push af  
5ab6 3a ca 5a			ld a, (.dmark)  
5ab9 32 68 fe			ld (debug_mark),a  
5abc 3a cb 5a			ld a, (.dmark+1)  
5abf 32 69 fe			ld (debug_mark+1),a  
5ac2 3a cc 5a			ld a, (.dmark+2)  
5ac5 32 6a fe			ld (debug_mark+2),a  
5ac8 18 03			jr .pastdmark  
5aca ..			.dmark: db "BNK"  
5acd f1			.pastdmark: pop af  
5ace			endm  
# End of macro DMARK
5ace						CALLMONITOR 
5ace cd 6c fe			call debug_vector  
5ad1				endm  
# End of macro CALLMONITOR
5ad1					endif 
5ad1			 
5ad1					; active low 
5ad1			 
5ad1 fe 00				cp 0 
5ad3 28 28				jr z, .bset 
5ad5 fe 01				cp 1 
5ad7 20 04				jr nz, .b2 
5ad9 cb 81				res 0, c 
5adb 06 31				ld b, '1'    ; human readable bank number 
5add fe 02		.b2:		cp 2 
5adf 20 04				jr nz, .b3 
5ae1 cb 89				res 1, c 
5ae3 06 32				ld b, '2'    ; human readable bank number 
5ae5 fe 03		.b3:		cp 3 
5ae7 20 04				jr nz, .b4 
5ae9 cb 91				res 2, c 
5aeb 06 33				ld b, '3'    ; human readable bank number 
5aed fe 04		.b4:		cp 4 
5aef 20 04				jr nz, .b5 
5af1 cb 99				res 3, c 
5af3 06 34				ld b, '4'    ; human readable bank number 
5af5 fe 05		.b5:		cp 5 
5af7 20 04				jr nz, .bset 
5af9 cb a1				res 4, c 
5afb 06 35				ld b, '5'    ; human readable bank number 
5afd			 
5afd			.bset: 
5afd 79					ld a, c 
5afe 32 5d fa				ld (spi_device),a 
5b01 78					ld a, b 
5b02 32 5c fa				ld (spi_device_id),a 
5b05					if DEBUG_FORTH_WORDS 
5b05						DMARK "BN2" 
5b05 f5				push af  
5b06 3a 1a 5b			ld a, (.dmark)  
5b09 32 68 fe			ld (debug_mark),a  
5b0c 3a 1b 5b			ld a, (.dmark+1)  
5b0f 32 69 fe			ld (debug_mark+1),a  
5b12 3a 1c 5b			ld a, (.dmark+2)  
5b15 32 6a fe			ld (debug_mark+2),a  
5b18 18 03			jr .pastdmark  
5b1a ..			.dmark: db "BN2"  
5b1d f1			.pastdmark: pop af  
5b1e			endm  
# End of macro DMARK
5b1e						CALLMONITOR 
5b1e cd 6c fe			call debug_vector  
5b21				endm  
# End of macro CALLMONITOR
5b21					endif 
5b21			 
5b21					; set default SPI clk pulse time as disabled for BANK use 
5b21			 
5b21 3e 00				ld a, 0 
5b23 32 61 fa				ld (spi_clktime), a 
5b26			 
5b26					NEXTW 
5b26 c3 b3 24			jp macro_next 
5b29				endm 
# End of macro NEXTW
5b29			 
5b29			.CARTDEV: 
5b29				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b29 66				db WORD_SYS_CORE+82             
5b2a d7 5b			dw .ENDDEVICE            
5b2c 08				db 7 + 1 
5b2d .. 00			db "CARTDEV",0              
5b35				endm 
# End of macro CWHEAD
5b35			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b35					if DEBUG_FORTH_WORDS_KEY 
5b35						DMARK "CDV" 
5b35 f5				push af  
5b36 3a 4a 5b			ld a, (.dmark)  
5b39 32 68 fe			ld (debug_mark),a  
5b3c 3a 4b 5b			ld a, (.dmark+1)  
5b3f 32 69 fe			ld (debug_mark+1),a  
5b42 3a 4c 5b			ld a, (.dmark+2)  
5b45 32 6a fe			ld (debug_mark+2),a  
5b48 18 03			jr .pastdmark  
5b4a ..			.dmark: db "CDV"  
5b4d f1			.pastdmark: pop af  
5b4e			endm  
# End of macro DMARK
5b4e						CALLMONITOR 
5b4e cd 6c fe			call debug_vector  
5b51				endm  
# End of macro CALLMONITOR
5b51					endif 
5b51			 
5b51					; disable se storage bank selection 
5b51			 
5b51 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b53 32 5d fa				ld (spi_device), a 
5b56			 
5b56					; get bank 
5b56			 
5b56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b56 cd fd 22			call macro_dsp_valuehl 
5b59				endm 
# End of macro FORTH_DSP_VALUEHL
5b59			 
5b59			;		push hl 
5b59			 
5b59					; destroy value TOS 
5b59			 
5b59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b59 cd b5 23			call macro_forth_dsp_pop 
5b5c				endm 
# End of macro FORTH_DSP_POP
5b5c			 
5b5c					; one value on hl get other one back 
5b5c			 
5b5c			;		pop hl 
5b5c			 
5b5c					; active low 
5b5c			 
5b5c 0e ff				ld c, 255 
5b5e			 
5b5e 7d					ld a, l 
5b5f					if DEBUG_FORTH_WORDS 
5b5f						DMARK "CDV" 
5b5f f5				push af  
5b60 3a 74 5b			ld a, (.dmark)  
5b63 32 68 fe			ld (debug_mark),a  
5b66 3a 75 5b			ld a, (.dmark+1)  
5b69 32 69 fe			ld (debug_mark+1),a  
5b6c 3a 76 5b			ld a, (.dmark+2)  
5b6f 32 6a fe			ld (debug_mark+2),a  
5b72 18 03			jr .pastdmark  
5b74 ..			.dmark: db "CDV"  
5b77 f1			.pastdmark: pop af  
5b78			endm  
# End of macro DMARK
5b78						CALLMONITOR 
5b78 cd 6c fe			call debug_vector  
5b7b				endm  
# End of macro CALLMONITOR
5b7b					endif 
5b7b fe 00				cp 0 
5b7d 28 30				jr z, .cset 
5b7f fe 01				cp 1 
5b81 20 02				jr nz, .c2 
5b83 cb 81				res 0, c 
5b85 fe 02		.c2:		cp 2 
5b87 20 02				jr nz, .c3 
5b89 cb 89				res 1, c 
5b8b fe 03		.c3:		cp 3 
5b8d 20 02				jr nz, .c4 
5b8f cb 91				res 2, c 
5b91 fe 04		.c4:		cp 4 
5b93 20 02				jr nz, .c5 
5b95 cb 99				res 3, c 
5b97 fe 05		.c5:		cp 5 
5b99 20 02				jr nz, .c6 
5b9b cb a1				res 4, c 
5b9d fe 06		.c6:		cp 6 
5b9f 20 02				jr nz, .c7 
5ba1 cb a9				res 5, c 
5ba3 fe 07		.c7:		cp 7 
5ba5 20 02				jr nz, .c8 
5ba7 cb b1				res 6, c 
5ba9 fe 08		.c8:		cp 8 
5bab 20 02				jr nz, .cset 
5bad cb b9				res 7, c 
5baf 79			.cset:		ld a, c 
5bb0 32 60 fa				ld (spi_cartdev),a 
5bb3			 
5bb3					if DEBUG_FORTH_WORDS 
5bb3						DMARK "CD2" 
5bb3 f5				push af  
5bb4 3a c8 5b			ld a, (.dmark)  
5bb7 32 68 fe			ld (debug_mark),a  
5bba 3a c9 5b			ld a, (.dmark+1)  
5bbd 32 69 fe			ld (debug_mark+1),a  
5bc0 3a ca 5b			ld a, (.dmark+2)  
5bc3 32 6a fe			ld (debug_mark+2),a  
5bc6 18 03			jr .pastdmark  
5bc8 ..			.dmark: db "CD2"  
5bcb f1			.pastdmark: pop af  
5bcc			endm  
# End of macro DMARK
5bcc						CALLMONITOR 
5bcc cd 6c fe			call debug_vector  
5bcf				endm  
# End of macro CALLMONITOR
5bcf					endif 
5bcf			 
5bcf					; set default SPI clk pulse time as 10ms for CARTDEV use 
5bcf			 
5bcf 3e 0a				ld a, $0a 
5bd1 32 61 fa				ld (spi_clktime), a 
5bd4					NEXTW 
5bd4 c3 b3 24			jp macro_next 
5bd7				endm 
# End of macro NEXTW
5bd7			endif 
5bd7			 
5bd7			.ENDDEVICE: 
5bd7			; eof 
5bd7			 
# End of file forth_words_device.asm
5bd7			 
5bd7			; var handler 
5bd7			 
5bd7			 
5bd7			.VARS: 
5bd7				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5bd7 77				db WORD_SYS_CORE+99             
5bd8 88 5c			dw .V0            
5bda 04				db 3 + 1 
5bdb .. 00			db "VAR",0              
5bdf				endm 
# End of macro CWHEAD
5bdf			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bdf			;| 
5bdf			;| The variable name should consist of a single letter. e.g. "a" 
5bdf			;! If a full string is passed then only the first char is looked at 
5bdf			;| Any other char could exceed bounds checks!  
5bdf			 
5bdf					if DEBUG_FORTH_WORDS_KEY 
5bdf						DMARK "VAR" 
5bdf f5				push af  
5be0 3a f4 5b			ld a, (.dmark)  
5be3 32 68 fe			ld (debug_mark),a  
5be6 3a f5 5b			ld a, (.dmark+1)  
5be9 32 69 fe			ld (debug_mark+1),a  
5bec 3a f6 5b			ld a, (.dmark+2)  
5bef 32 6a fe			ld (debug_mark+2),a  
5bf2 18 03			jr .pastdmark  
5bf4 ..			.dmark: db "VAR"  
5bf7 f1			.pastdmark: pop af  
5bf8			endm  
# End of macro DMARK
5bf8						CALLMONITOR 
5bf8 cd 6c fe			call debug_vector  
5bfb				endm  
# End of macro CALLMONITOR
5bfb					endif 
5bfb			 
5bfb					FORTH_DSP_VALUEHL 
5bfb cd fd 22			call macro_dsp_valuehl 
5bfe				endm 
# End of macro FORTH_DSP_VALUEHL
5bfe			 
5bfe 7e					ld a, (hl)    ; get first char on of the string 
5bff			 
5bff			 
5bff					if DEBUG_FORTH_WORDS 
5bff						DMARK "VR1" 
5bff f5				push af  
5c00 3a 14 5c			ld a, (.dmark)  
5c03 32 68 fe			ld (debug_mark),a  
5c06 3a 15 5c			ld a, (.dmark+1)  
5c09 32 69 fe			ld (debug_mark+1),a  
5c0c 3a 16 5c			ld a, (.dmark+2)  
5c0f 32 6a fe			ld (debug_mark+2),a  
5c12 18 03			jr .pastdmark  
5c14 ..			.dmark: db "VR1"  
5c17 f1			.pastdmark: pop af  
5c18			endm  
# End of macro DMARK
5c18						CALLMONITOR 
5c18 cd 6c fe			call debug_vector  
5c1b				endm  
# End of macro CALLMONITOR
5c1b					endif 
5c1b					 
5c1b f5					push af	 
5c1c					FORTH_DSP_POP 
5c1c cd b5 23			call macro_forth_dsp_pop 
5c1f				endm 
# End of macro FORTH_DSP_POP
5c1f f1					pop af 
5c20			 
5c20					; convert to upper 
5c20			 
5c20 cd 3d 13				call to_upper 
5c23					if DEBUG_FORTH_WORDS 
5c23						DMARK "Vaa" 
5c23 f5				push af  
5c24 3a 38 5c			ld a, (.dmark)  
5c27 32 68 fe			ld (debug_mark),a  
5c2a 3a 39 5c			ld a, (.dmark+1)  
5c2d 32 69 fe			ld (debug_mark+1),a  
5c30 3a 3a 5c			ld a, (.dmark+2)  
5c33 32 6a fe			ld (debug_mark+2),a  
5c36 18 03			jr .pastdmark  
5c38 ..			.dmark: db "Vaa"  
5c3b f1			.pastdmark: pop af  
5c3c			endm  
# End of macro DMARK
5c3c						CALLMONITOR 
5c3c cd 6c fe			call debug_vector  
5c3f				endm  
# End of macro CALLMONITOR
5c3f					endif 
5c3f 06 41				ld b, 'A' 
5c41 90					sub b			; set offset 
5c42					if DEBUG_FORTH_WORDS 
5c42						DMARK "Vbb" 
5c42 f5				push af  
5c43 3a 57 5c			ld a, (.dmark)  
5c46 32 68 fe			ld (debug_mark),a  
5c49 3a 58 5c			ld a, (.dmark+1)  
5c4c 32 69 fe			ld (debug_mark+1),a  
5c4f 3a 59 5c			ld a, (.dmark+2)  
5c52 32 6a fe			ld (debug_mark+2),a  
5c55 18 03			jr .pastdmark  
5c57 ..			.dmark: db "Vbb"  
5c5a f1			.pastdmark: pop af  
5c5b			endm  
# End of macro DMARK
5c5b						CALLMONITOR 
5c5b cd 6c fe			call debug_vector  
5c5e				endm  
# End of macro CALLMONITOR
5c5e					endif 
5c5e cb 27				sla a  
5c60				 
5c60					 
5c60					if DEBUG_FORTH_WORDS 
5c60						DMARK "VR2" 
5c60 f5				push af  
5c61 3a 75 5c			ld a, (.dmark)  
5c64 32 68 fe			ld (debug_mark),a  
5c67 3a 76 5c			ld a, (.dmark+1)  
5c6a 32 69 fe			ld (debug_mark+1),a  
5c6d 3a 77 5c			ld a, (.dmark+2)  
5c70 32 6a fe			ld (debug_mark+2),a  
5c73 18 03			jr .pastdmark  
5c75 ..			.dmark: db "VR2"  
5c78 f1			.pastdmark: pop af  
5c79			endm  
# End of macro DMARK
5c79						CALLMONITOR 
5c79 cd 6c fe			call debug_vector  
5c7c				endm  
# End of macro CALLMONITOR
5c7c					endif 
5c7c			 
5c7c 21 f1 f9				ld hl, cli_var_array2 
5c7f cd d0 0f				call addatohl 
5c82 cd 06 21				call forth_push_numhl 
5c85			 
5c85			 
5c85				       NEXTW 
5c85 c3 b3 24			jp macro_next 
5c88				endm 
# End of macro NEXTW
5c88			.V0: 
5c88				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c88 78				db WORD_SYS_CORE+100             
5c89 a0 5c			dw .V0Q            
5c8b 04				db 3 + 1 
5c8c .. 00			db "V0!",0              
5c90				endm 
# End of macro CWHEAD
5c90			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c90			 
5c90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c90 cd fd 22			call macro_dsp_valuehl 
5c93				endm 
# End of macro FORTH_DSP_VALUEHL
5c93			 
5c93 11 25 fa				ld de, cli_var_array 
5c96			 
5c96 eb					ex de, hl 
5c97 73					ld (hl), e 
5c98 23					inc hl 
5c99 72					ld (hl), d 
5c9a			 
5c9a					; destroy value TOS 
5c9a			 
5c9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c9a cd b5 23			call macro_forth_dsp_pop 
5c9d				endm 
# End of macro FORTH_DSP_POP
5c9d			 
5c9d				       NEXTW 
5c9d c3 b3 24			jp macro_next 
5ca0				endm 
# End of macro NEXTW
5ca0			.V0Q: 
5ca0				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5ca0 79				db WORD_SYS_CORE+101             
5ca1 b1 5c			dw .V1S            
5ca3 04				db 3 + 1 
5ca4 .. 00			db "V0@",0              
5ca8				endm 
# End of macro CWHEAD
5ca8			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5ca8 2a 25 fa				ld hl, (cli_var_array) 
5cab cd 06 21				call forth_push_numhl 
5cae			 
5cae				       NEXTW 
5cae c3 b3 24			jp macro_next 
5cb1				endm 
# End of macro NEXTW
5cb1			.V1S: 
5cb1				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5cb1 7a				db WORD_SYS_CORE+102             
5cb2 c9 5c			dw .V1Q            
5cb4 04				db 3 + 1 
5cb5 .. 00			db "V1!",0              
5cb9				endm 
# End of macro CWHEAD
5cb9			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb9 cd fd 22			call macro_dsp_valuehl 
5cbc				endm 
# End of macro FORTH_DSP_VALUEHL
5cbc			 
5cbc 11 27 fa				ld de, cli_var_array+2 
5cbf				 
5cbf eb					ex de, hl 
5cc0 73					ld (hl), e 
5cc1 23					inc hl 
5cc2 72					ld (hl), d 
5cc3			 
5cc3					; destroy value TOS 
5cc3			 
5cc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc3 cd b5 23			call macro_forth_dsp_pop 
5cc6				endm 
# End of macro FORTH_DSP_POP
5cc6				       NEXTW 
5cc6 c3 b3 24			jp macro_next 
5cc9				endm 
# End of macro NEXTW
5cc9			.V1Q: 
5cc9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5cc9 7b				db WORD_SYS_CORE+103             
5cca da 5c			dw .V2S            
5ccc 04				db 3 + 1 
5ccd .. 00			db "V1@",0              
5cd1				endm 
# End of macro CWHEAD
5cd1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5cd1 2a 27 fa				ld hl, (cli_var_array+2) 
5cd4 cd 06 21				call forth_push_numhl 
5cd7				       NEXTW 
5cd7 c3 b3 24			jp macro_next 
5cda				endm 
# End of macro NEXTW
5cda			.V2S: 
5cda				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5cda 7c				db WORD_SYS_CORE+104             
5cdb f2 5c			dw .V2Q            
5cdd 04				db 3 + 1 
5cde .. 00			db "V2!",0              
5ce2				endm 
# End of macro CWHEAD
5ce2			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ce2 cd fd 22			call macro_dsp_valuehl 
5ce5				endm 
# End of macro FORTH_DSP_VALUEHL
5ce5			 
5ce5 11 29 fa				ld de, cli_var_array+4 
5ce8				 
5ce8 eb					ex de, hl 
5ce9 73					ld (hl), e 
5cea 23					inc hl 
5ceb 72					ld (hl), d 
5cec			 
5cec					; destroy value TOS 
5cec			 
5cec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cec cd b5 23			call macro_forth_dsp_pop 
5cef				endm 
# End of macro FORTH_DSP_POP
5cef				       NEXTW 
5cef c3 b3 24			jp macro_next 
5cf2				endm 
# End of macro NEXTW
5cf2			.V2Q: 
5cf2				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cf2 7d				db WORD_SYS_CORE+105             
5cf3 03 5d			dw .V3S            
5cf5 04				db 3 + 1 
5cf6 .. 00			db "V2@",0              
5cfa				endm 
# End of macro CWHEAD
5cfa			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cfa 2a 29 fa				ld hl, (cli_var_array+4) 
5cfd cd 06 21				call forth_push_numhl 
5d00				       NEXTW 
5d00 c3 b3 24			jp macro_next 
5d03				endm 
# End of macro NEXTW
5d03			.V3S: 
5d03				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d03 7c				db WORD_SYS_CORE+104             
5d04 1b 5d			dw .V3Q            
5d06 04				db 3 + 1 
5d07 .. 00			db "V3!",0              
5d0b				endm 
# End of macro CWHEAD
5d0b			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d0b cd fd 22			call macro_dsp_valuehl 
5d0e				endm 
# End of macro FORTH_DSP_VALUEHL
5d0e			 
5d0e 11 2b fa				ld de, cli_var_array+6 
5d11				 
5d11 eb					ex de, hl 
5d12 73					ld (hl), e 
5d13 23					inc hl 
5d14 72					ld (hl), d 
5d15			 
5d15					; destroy value TOS 
5d15			 
5d15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d15 cd b5 23			call macro_forth_dsp_pop 
5d18				endm 
# End of macro FORTH_DSP_POP
5d18				       NEXTW 
5d18 c3 b3 24			jp macro_next 
5d1b				endm 
# End of macro NEXTW
5d1b			.V3Q: 
5d1b				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d1b 7d				db WORD_SYS_CORE+105             
5d1c 2c 5d			dw .END            
5d1e 04				db 3 + 1 
5d1f .. 00			db "V3@",0              
5d23				endm 
# End of macro CWHEAD
5d23			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d23 2a 2b fa				ld hl, (cli_var_array+6) 
5d26 cd 06 21				call forth_push_numhl 
5d29				       NEXTW 
5d29 c3 b3 24			jp macro_next 
5d2c				endm 
# End of macro NEXTW
5d2c			 
5d2c			 
5d2c			 
5d2c			 
5d2c			 
5d2c			; end of dict marker 
5d2c			 
5d2c 00			.END:    db WORD_SYS_END 
5d2d 00 00			dw 0 
5d2f 00				db 0 
5d30			 
5d30			; use to jp here for user dict words to save on macro expansion  
5d30			 
5d30			user_dict_next: 
5d30				NEXTW 
5d30 c3 b3 24			jp macro_next 
5d33				endm 
# End of macro NEXTW
5d33			 
5d33			 
5d33			user_exec: 
5d33				;    ld hl, <word code> 
5d33				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d33				;    call forthexec 
5d33				;    jp user_dict_next   (NEXT) 
5d33			        ;    <word code bytes> 
5d33 eb				ex de, hl 
5d34 2a bf f4			ld hl,(os_tok_ptr) 
5d37				 
5d37				FORTH_RSP_NEXT 
5d37 cd ad 20			call macro_forth_rsp_next 
5d3a				endm 
# End of macro FORTH_RSP_NEXT
5d3a			 
5d3a			if DEBUG_FORTH_UWORD 
5d3a						DMARK "UEX" 
5d3a f5				push af  
5d3b 3a 4f 5d			ld a, (.dmark)  
5d3e 32 68 fe			ld (debug_mark),a  
5d41 3a 50 5d			ld a, (.dmark+1)  
5d44 32 69 fe			ld (debug_mark+1),a  
5d47 3a 51 5d			ld a, (.dmark+2)  
5d4a 32 6a fe			ld (debug_mark+2),a  
5d4d 18 03			jr .pastdmark  
5d4f ..			.dmark: db "UEX"  
5d52 f1			.pastdmark: pop af  
5d53			endm  
# End of macro DMARK
5d53				CALLMONITOR 
5d53 cd 6c fe			call debug_vector  
5d56				endm  
# End of macro CALLMONITOR
5d56			endif 
5d56			 
5d56			 
5d56			 
5d56 eb				ex de, hl 
5d57 22 bf f4			ld (os_tok_ptr), hl 
5d5a				 
5d5a				; Don't use next - Skips the first word in uword. 
5d5a			 
5d5a c3 44 25			jp exec1 
5d5d			;	NEXT 
5d5d			 
5d5d			 
5d5d			; eof 
# End of file forth_wordsv4.asm
5d5d			endif 
5d5d			;;;;;;;;;;;;;; Debug code 
5d5d			 
5d5d			 
5d5d			;if DEBUG_FORTH_PARSE 
5d5d .. 00		.nowordfound: db "No match",0 
5d66 .. 00		.compword:	db "Comparing word ",0 
5d76 .. 00		.nextwordat:	db "Next word at",0 
5d83 .. 00		.charmatch:	db "Char match",0 
5d8e			;endif 
5d8e			if DEBUG_FORTH_JP 
5d8e			.foundword:	db "Word match. Exec..",0 
5d8e			endif 
5d8e			;if DEBUG_FORTH_PUSH 
5d8e .. 00		.enddict:	db "Dict end. Push.",0 
5d9e .. 00		.push_str:	db "Pushing string",0 
5dad .. 00		.push_num:	db "Pushing number",0 
5dbc .. 00		.data_sp:	db "SP:",0 
5dc0 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5dd2 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5de4 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5df6			;endif 
5df6			;if DEBUG_FORTH_MALLOC 
5df6 .. 00		.push_malloc:	db "Malloc address",0 
5e05			;endif 
5e05			 
5e05			 
5e05			 
5e05			; display malloc address and current data stack pointer  
5e05			 
5e05			malloc_error: 
5e05 d5				push de 
5e06 f5				push af 
5e07 e5				push hl 
5e08 cd 9c 0d			call clear_display 
5e0b 11 2b 5e			ld de, .mallocerr 
5e0e 3e 00			ld a,0 
5e10			;	ld de,os_word_scratch 
5e10 cd af 0d			call str_at_display 
5e13 3e 11			ld a, display_row_1+17 
5e15 11 68 fe			ld de, debug_mark 
5e18 cd af 0d			call str_at_display 
5e1b cd bf 0d			call update_display 
5e1e				;call break_point_state 
5e1e cd c4 79			call cin_wait 
5e21			 
5e21			;	ld a, ' ' 
5e21			;	ld (os_view_disable), a 
5e21 cd 36 1a			call bp_on 
5e24 e1				pop hl 
5e25 f1				pop af 
5e26 d1				pop de	 
5e27				CALLMONITOR 
5e27 cd 6c fe			call debug_vector  
5e2a				endm  
# End of macro CALLMONITOR
5e2a c9				ret 
5e2b			 
5e2b .. 00		.mallocerr: 	db "Malloc Error",0 
5e38			;if DEBUG_FORTH_PUSH 
5e38			display_data_sp: 
5e38 f5				push af 
5e39			 
5e39				; see if disabled 
5e39			 
5e39			 
5e39 3a 6c fe			ld a, (debug_vector) 
5e3c fe c9			cp $C9  ; RET 
5e3e				;ld a, (os_view_disable) 
5e3e				;cp '*' 
5e3e 28 67			jr z, .skipdsp 
5e40			 
5e40 e5				push hl 
5e41 e5				push hl 
5e42 e5			push hl 
5e43 cd 9c 0d			call clear_display 
5e46 e1			pop hl 
5e47 7c				ld a,h 
5e48 21 c3 f4			ld hl, os_word_scratch 
5e4b cd d1 12			call hexout 
5e4e e1				pop hl 
5e4f 7d				ld a,l 
5e50 21 c5 f4			ld hl, os_word_scratch+2 
5e53 cd d1 12			call hexout 
5e56 21 c7 f4			ld hl, os_word_scratch+4 
5e59 3e 00			ld a,0 
5e5b 77				ld (hl),a 
5e5c 11 c3 f4			ld de,os_word_scratch 
5e5f 3e 28				ld a, display_row_2 
5e61 cd af 0d				call str_at_display 
5e64 11 c0 5d			ld de, .wordinhl 
5e67 3e 00			ld a, display_row_1 
5e69			 
5e69 cd af 0d				call str_at_display 
5e6c 11 68 fe			ld de, debug_mark 
5e6f 3e 11			ld a, display_row_1+17 
5e71			 
5e71 cd af 0d				call str_at_display 
5e74			 
5e74				; display current data stack pointer 
5e74 11 bc 5d			ld de,.data_sp 
5e77 3e 30				ld a, display_row_2 + 8 
5e79 cd af 0d				call str_at_display 
5e7c			 
5e7c 2a eb f9			ld hl,(cli_data_sp) 
5e7f e5				push hl 
5e80 7c				ld a,h 
5e81 21 c3 f4			ld hl, os_word_scratch 
5e84 cd d1 12			call hexout 
5e87 e1				pop hl 
5e88 7d				ld a,l 
5e89 21 c5 f4			ld hl, os_word_scratch+2 
5e8c cd d1 12			call hexout 
5e8f 21 c7 f4			ld hl, os_word_scratch+4 
5e92 3e 00			ld a,0 
5e94 77				ld (hl),a 
5e95 11 c3 f4			ld de,os_word_scratch 
5e98 3e 33				ld a, display_row_2 + 11 
5e9a cd af 0d				call str_at_display 
5e9d			 
5e9d			 
5e9d cd bf 0d			call update_display 
5ea0 cd df 0c			call delay1s 
5ea3 cd df 0c			call delay1s 
5ea6 e1				pop hl 
5ea7			.skipdsp: 
5ea7 f1				pop af 
5ea8 c9				ret 
5ea9			 
5ea9			display_data_malloc: 
5ea9			 
5ea9 f5				push af 
5eaa e5				push hl 
5eab e5				push hl 
5eac e5			push hl 
5ead cd 9c 0d			call clear_display 
5eb0 e1			pop hl 
5eb1 7c				ld a,h 
5eb2 21 c3 f4			ld hl, os_word_scratch 
5eb5 cd d1 12			call hexout 
5eb8 e1				pop hl 
5eb9 7d				ld a,l 
5eba 21 c5 f4			ld hl, os_word_scratch+2 
5ebd cd d1 12			call hexout 
5ec0 21 c7 f4			ld hl, os_word_scratch+4 
5ec3 3e 00			ld a,0 
5ec5 77				ld (hl),a 
5ec6 11 c3 f4			ld de,os_word_scratch 
5ec9 3e 28				ld a, display_row_2 
5ecb cd af 0d				call str_at_display 
5ece 11 f6 5d			ld de, .push_malloc 
5ed1 3e 00			ld a, display_row_1 
5ed3			 
5ed3 cd af 0d				call str_at_display 
5ed6			 
5ed6				; display current data stack pointer 
5ed6 11 bc 5d			ld de,.data_sp 
5ed9 3e 30				ld a, display_row_2 + 8 
5edb cd af 0d				call str_at_display 
5ede			 
5ede 2a eb f9			ld hl,(cli_data_sp) 
5ee1 e5				push hl 
5ee2 7c				ld a,h 
5ee3 21 c3 f4			ld hl, os_word_scratch 
5ee6 cd d1 12			call hexout 
5ee9 e1				pop hl 
5eea 7d				ld a,l 
5eeb 21 c5 f4			ld hl, os_word_scratch+2 
5eee cd d1 12			call hexout 
5ef1 21 c7 f4			ld hl, os_word_scratch+4 
5ef4 3e 00			ld a,0 
5ef6 77				ld (hl),a 
5ef7 11 c3 f4			ld de,os_word_scratch 
5efa 3e 33				ld a, display_row_2 + 11 
5efc cd af 0d				call str_at_display 
5eff			 
5eff cd bf 0d			call update_display 
5f02 cd df 0c			call delay1s 
5f05 cd df 0c			call delay1s 
5f08 e1				pop hl 
5f09 f1				pop af 
5f0a c9				ret 
5f0b			;endif 
5f0b			 
5f0b			include "forth_autostart.asm" 
5f0b			; list of commands to perform at system start up 
5f0b			 
5f0b			startcmds: 
5f0b			;	dw test11 
5f0b			;	dw test12 
5f0b			;	dw test13 
5f0b			;	dw test14 
5f0b			;	dw test15 
5f0b			;	dw test16 
5f0b			;	dw test17 
5f0b			;	dw ifthtest1 
5f0b			;	dw ifthtest2 
5f0b			;	dw ifthtest3 
5f0b			;	dw mmtest1 
5f0b			;	dw mmtest2 
5f0b			;	dw mmtest3 
5f0b			;	dw mmtest4 
5f0b			;	dw mmtest5 
5f0b			;	dw mmtest6 
5f0b			;	dw iftest1 
5f0b			;	dw iftest2 
5f0b			;	dw iftest3 
5f0b			;	dw looptest1 
5f0b			;	dw looptest2 
5f0b			;	dw test1 
5f0b			;	dw test2 
5f0b			;	dw test3 
5f0b			;	dw test4 
5f0b			;	dw game2r 
5f0b			;	dw game2b1 
5f0b			;	dw game2b2 
5f0b			 
5f0b				; start up words that are actually useful 
5f0b			 
5f0b			;    dw spi1 
5f0b			;    dw spi2 
5f0b			;    dw spi3 
5f0b			;    dw spi4 
5f0b			;    dw spi5 
5f0b			;    dw spi6 
5f0b			;    dw spi7 
5f0b			; 
5f0b			;    dw spi8 
5f0b			;    dw spi9 
5f0b			;    dw spi10 
5f0b			 
5f0b			; file editor 
5f0b			;	dw edit1 
5f0b			;	dw edit2 
5f0b			;	dw edit3 
5f0b			 
5f0b			;	dw longread 
5f0b 0b 63			dw clrstack 
5f0d 3f 63			dw type 
5f0f			;	dw stest 
5f0f 64 63			dw strncpy 
5f11			;	dw list 
5f11 c5 63			dw start1 
5f13 d5 63			dw start2 
5f15			;	dw start3 
5f15			;	dw start3b 
5f15			;	dw start3c 
5f15			 
5f15				; (unit) testing words 
5f15			 
5f15			;	dw mtesta 
5f15			;	dw mtestb 
5f15			;	dw mtestc 
5f15			;	dw mtestd 
5f15			;	dw mteste 
5f15			 
5f15				; demo/game words 
5f15			 
5f15			;        dw game3w 
5f15			;        dw game3p 
5f15			;        dw game3sc 
5f15			;        dw game3vsi 
5f15			;        dw game3vs 
5f15				 
5f15 2e 6e			dw game2b 
5f17 9c 6e			dw game2bf 
5f19 e6 6e			dw game2mba 
5f1b 7c 6f			dw game2mbas 
5f1d be 6f			dw game2mb 
5f1f			 
5f1f ef 6a			dw game1 
5f21 00 6b			dw game1a 
5f23 62 6b			dw game1b 
5f25 97 6b			dw game1c 
5f27 cd 6b			dw game1d 
5f29 fe 6b			dw game1s 
5f2b 12 6c			dw game1t 
5f2d 27 6c			dw game1f 
5f2f 5b 6c			dw game1z 
5f31 9f 6c			dw game1zz 
5f33			 
5f33 09 69			dw test5 
5f35 41 69			dw test6 
5f37 79 69			dw test7 
5f39 8d 69			dw test8 
5f3b b9 69			dw test9 
5f3d cf 69			dw test10 
5f3f				 
5f3f 76 6d		        dw ssv5 
5f41 5a 6d		        dw ssv4 
5f43 3e 6d		        dw ssv3 
5f45 08 6d		        dw ssv2 
5f47 8f 6d		        dw ssv1 
5f49 d7 6d		        dw ssv1cpm 
5f4b			;	dw keyup 
5f4b			;	dw keydown 
5f4b			;	dw keyleft 
5f4b			;	dw keyright 
5f4b			;	dw 	keyf1 
5f4b			;	dw keyf2 
5f4b			;	dw keyf3 
5f4b			;	dw keyf4 
5f4b			;	dw keyf5 
5f4b			;	dw keyf6 
5f4b			;	dw keyf7 
5f4b			;	dw keyf8 
5f4b			;	dw keyf9 
5f4b			;	dw keyf10 
5f4b			;	dw keyf11 
5f4b			;	dw keyf12 
5f4b			;	dw keytab 
5f4b			;	dw keycr 
5f4b			;	dw keyhome 
5f4b			;	dw keyend 
5f4b			;	dw keybs 
5f4b 00 00			db 0, 0	 
5f4d			 
5f4d			 
5f4d			; File Editor 
5f4d			 
5f4d			; ( id - ) use 'e' to edit the displayed line 
5f4d .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f6e .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa3			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa3 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fdb			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fdb			 
5fdb			; SPI Net support words 
5fdb			 
5fdb			; v0! = node to send to 
5fdb			; ( str count - ) 
5fdb .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6034			 
6034			; spiputchr ( char node - ) 
6034 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
606a			 
606a			; spigetchr ( - n ) 
606a .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6095			 
6095			; getnode ( - n ) 
6095 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60c2			 
60c2			; ( str node - )  
60c2 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6128			; store string ( str i - ) 
6128			 
6128			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6128 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
617d			 
617d			; get string ( addr i -  )    TO FIX 
617d			 
617d .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61d5			 
61d5			 
61d5			; NETCHAT (TODO) 
61d5			; Program to allow two nodes to chat with eachother 
61d5			; 
61d5			; v0 - target node 
61d5			;  
61d5			; accept input at 0,0 
61d5			; if input is string send spitype to target node 
61d5			; starting at row 2,0 , while spigetchr is not zero ->  
61d5			; 
61d5			; 
61d5			; TODO add paging of get request 
61d5			 
61d5			; ( node - ) 
61d5 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61f4 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
624c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62c4			 
62c4			 
62c4			; Long read of currently open file 
62c4 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
630b			 
630b			; clear stack  
630b			 
630b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
633f			 
633f			; type ( addr count - ) 
633f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6364			 
6364			; some direct memory words 
6364			; strncpy ( len t f -- t ) 
6364			 
6364 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63c5			 
63c5 .. 00		start1:     	db ": bpon $00 bp ;",0 
63d5 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63e6 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6461 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64c1			 
64c1			 
64c1			; a handy word to list items on the stack 
64c1			 
64c1 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
652b			 
652b			 
652b			; test stack  
652b			; rnd8 stest 
652b			 
652b .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65a2			 
65a2			; random malloc and free cycles 
65a2			 
65a2 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6657			 
6657			; fixed malloc and free cycles 
6657			 
6657 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66fa			 
66fa			; fixed double string push and drop cycle  
66fa			 
66fa .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
67af			 
67af			; consistent fixed string push and drop cycle  
67af			 
67af .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6853			 
6853 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6909			 
6909			;test1:		db ": aa 1 2 3 ;", 0 
6909			;test2:     	db "111 aa 888 999",0 
6909			;test3:     	db ": bb 77 ;",0 
6909			;test4:     	db "$02 $01 do i . loop bb",0 
6909			 
6909 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6941 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6979 .. 00		test7:     	db ": box hline vline ;",0 
698d .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69b9 .. 00		test9:     	db ": sw $01 adsp world ;",0 
69cf .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69f4 .. 00		test11:     	db "hello create .",0 
6a03 .. 00		test12:     	db "hello2 create .",0 
6a13			 
6a13			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a13			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a13			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a13			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a13			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a13			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a13			 
6a13			;iftest1:     	db "$0001 IF cls .",0 
6a13			;iftest2:     	db "$0000 IF cls .",0 
6a13			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a13			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a13			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a13			 
6a13			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a13			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a13			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a13			 
6a13			 
6a13 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a37 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a67 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a8c .. 00		sound4: db ": cha $00 ; ",0 
6a99 .. 00		sound5: db ": chb $20 ; ",0 
6aa6 .. 00		sound6: db ": chc $40 ; ",0 
6ab3 .. 00		sound7: db ": chd $60 ; ",0 
6ac0 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6ad8 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6aef			 
6aef			 
6aef			 
6aef			 
6aef			; a small guess the number game 
6aef			 
6aef .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6b00 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b62			 
6b62 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b97 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6bcd .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bfe .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c12 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c27 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c5b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c9f			 
6c9f			; Using 'ga' save a high score across multiple runs using external storage 
6c9f			 
6c9f .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d08			 
6d08			 
6d08			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d08			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d08			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d08			 
6d08			; simple screen saver to test code memory reuse to destruction 
6d08			 
6d08 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6d3e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d5a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d76 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d8f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6dd7 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e2e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e2e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e2e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e2e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e2e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e2e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e2e			 
6e2e			 
6e2e			 
6e2e			; minesweeper/battleship finding game 
6e2e			; draws a game board of random ship/mine positions 
6e2e			; user enters coords to see if it hits on 
6e2e			; game ends when all are hit 
6e2e			; when hit or miss says how many may be in the area 
6e2e			 
6e2e			; setup the game board and then hide it 
6e2e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e9c .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ee6			; prompt for where to target 
6ee6 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f7c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6fa1			; TODO see if the entered coords hits or misses pushes char hit of miss 
6fa1 .. 00		game2mbht:      db ": mbckht nop ;",0 
6fb0 .. 00		game2mbms:      db ": mbcms nop ;",0 
6fbe			; TODO how many might be near by 
6fbe .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
703b			 
703b			; Game 3 
703b			 
703b			; Vert scroller ski game - avoid the trees! 
703b			 
703b			; v0 score (ie turns) 
703b			; v1 player pos 
703b			; v2 left wall 
703b			; v3 right wall 
703b			 
703b			; Draw side walls randomly 
703b			 
703b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7069			 
7069			; Draw player 
7069 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7087			 
7087			; TODO Get Key 
7087			 
7087			; TODO Move left right 
7087			 
7087			; scroll and move walls a bit 
7087			 
7087 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
70b8			 
70b8			; main game loop 
70b8			 
70b8 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70e4 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7123			 
7123			; key board defs 
7123			 
7123 .. 00		keyup:       db ": keyup $05 ;",0 
7131 .. 00		keydown:       db ": keydown $0a ;",0 
7141 .. 00		keyleft:       db ": keyleft $0b ;",0 
7151 .. 00		keyright:       db ": keyright $0c ;",0 
7162 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7170 .. 00		keyf2:       db ": keyf2 $11 ;",0 
717e .. 00		keyf3:       db ": keyf3 $12 ;",0 
718c .. 00		keyf4:       db ": keyf4 $13 ;",0 
719a .. 00		keyf5:       db ": keyf5 $14 ;",0 
71a8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71b6 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71c4 .. 00		keyf8:       db ": keyf8 $17 ;",0 
71d2 .. 00		keyf9:       db ": keyf9 $18 ;",0 
71e0 .. 00		keyf10:       db ": keyf10 $19 ;",0 
71ef .. 00		keyf11:       db ": keyf11 $1a ;",0 
71fe .. 00		keyf12:       db ": keyf12 $1b ;",0 
720d			 
720d .. 00		keytab:       db ": keytab $09 ;",0 
721c .. 00		keycr:       db ": keycr $0d ;",0 
722a .. 00		keyhome:       db ": keyhome $0e ;",0 
723a .. 00		keyend:       db ": keyend $0f ;",0 
7249 .. 00		keybs:       db ": keybs $08 ;",0 
7257			 
7257			   
7257			 
7257			 
7257			 
7257			; eof 
# End of file forth_autostart.asm
7257			 
7257			 
7257			 
7257			; stack over and underflow checks 
7257			 
7257			; init the words to detect the under/overflow 
7257			 
7257			chk_stk_init: 
7257				; a vague random number to check so we dont get any "lucky" hits 
7257 3e 2d			ld a, 45 
7259 6f				ld l, a 
725a 00				nop 
725b 3e 17			ld a, 23 
725d 67				ld h, a 
725e			 
725e 22 9a f1			ld (chk_word), hl     ; the word we need to check against 
7261			 
7261			;	ld (chk_stund), hl	; stack points.... 
7261 22 fd fe			ld (chk_stovr), hl 
7264 22 e9 f9			ld (chk_ret_und), hl 
7267 22 a7 f9			ld (chk_ret_ovr), hl 
726a 22 25 f9			ld (chk_loop_ovr), hl 
726d 22 23 f7			ld (chk_data_ovr), hl 
7270 c9				ret 
7271				 
7271			check_stacks: 
7271				; check all stack words 
7271			 
7271 e5				push hl 
7272 d5				push de 
7273			 
7273			;	ld de,(chk_word) 
7273			;	ld hl, (chk_stund)	; stack points.... 
7273			;	if DEBUG_STK_FAULT 
7273			;		DMARK "FAa" 
7273			;		CALLMONITOR 
7273			;	endif 
7273			;	call cmp16 
7273			;	jp z, .chk_faulta 
7273			; 
7273			;	ld de, sfaultsu 
7273			;	jp .chk_fault 
7273			 
7273 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7276 ed 5b 9a f1		ld de,(chk_word) 
727a				if DEBUG_STK_FAULT 
727a					DMARK "FAb" 
727a					CALLMONITOR 
727a				endif 
727a cd ee 0f			call cmp16 
727d 28 06			jr z, .chk_fault1 
727f 11 20 73			ld de, sfaultso 
7282 c3 d4 72			jp .chk_fault 
7285			.chk_fault1:  
7285 2a e9 f9			ld hl, (chk_ret_und) 
7288 ed 5b 9a f1		ld de,(chk_word) 
728c				if DEBUG_STK_FAULT 
728c					DMARK "FAU" 
728c					CALLMONITOR 
728c				endif 
728c cd ee 0f			call cmp16 
728f ca 98 72			jp z, .chk_fault2 
7292 11 30 73			ld de, sfaultru 
7295 c3 d4 72			jp .chk_fault 
7298			.chk_fault2:  
7298 2a a7 f9			ld hl, (chk_ret_ovr) 
729b ed 5b 9a f1		ld de,(chk_word) 
729f				if DEBUG_STK_FAULT 
729f					DMARK "FA1" 
729f					CALLMONITOR 
729f				endif 
729f cd ee 0f			call cmp16 
72a2 ca ab 72			jp z, .chk_fault3 
72a5 11 3e 73			ld de, sfaultro 
72a8 c3 d4 72			jp .chk_fault 
72ab			.chk_fault3:  
72ab 2a 25 f9			ld hl, (chk_loop_ovr) 
72ae ed 5b 9a f1		ld de,(chk_word) 
72b2				if DEBUG_STK_FAULT 
72b2					DMARK "FA2" 
72b2					CALLMONITOR 
72b2				endif 
72b2 cd ee 0f			call cmp16 
72b5 ca be 72			jp z, .chk_fault4 
72b8 11 58 73			ld de, sfaultlo 
72bb c3 d4 72			jp .chk_fault 
72be			.chk_fault4:  
72be 2a 23 f7			ld hl, (chk_data_ovr) 
72c1 ed 5b 9a f1		ld de,(chk_word) 
72c5				if DEBUG_STK_FAULT 
72c5					DMARK "FA3" 
72c5					CALLMONITOR 
72c5				endif 
72c5 cd ee 0f			call cmp16 
72c8 ca d1 72			jp z, .chk_fault5 
72cb 11 72 73			ld de, sfaultdo 
72ce c3 d4 72			jp .chk_fault 
72d1			 
72d1			 
72d1			.chk_fault5:  
72d1 d1				pop de 
72d2 e1				pop hl 
72d3			 
72d3 c9				ret 
72d4			 
72d4 cd 9c 0d		.chk_fault: 	call clear_display 
72d7 3e 28				ld a, display_row_2 
72d9 cd af 0d				call str_at_display 
72dc 11 02 73				   ld de, .stackfault 
72df 3e 00				ld a, display_row_1 
72e1 cd af 0d				call str_at_display 
72e4 11 68 fe				    ld de, debug_mark 
72e7 3e 11				ld a, display_row_1+17 
72e9 cd af 0d				call str_at_display 
72ec cd bf 0d				call update_display 
72ef			 
72ef				; prompt before entering montior for investigating issue 
72ef			 
72ef 3e 78			ld a, display_row_4 
72f1 11 f8 1d			ld de, endprog 
72f4			 
72f4 cd bf 0d			call update_display		 
72f7			 
72f7 cd 7e 20			call next_page_prompt 
72fa			 
72fa d1				pop de 
72fb e1				pop hl 
72fc cd 4c 1e				call monitor 
72ff c3 55 1d				jp warmstart 
7302					;jp 0 
7302					;halt 
7302			 
7302			 
7302			 
7302 .. 00		.stackfault: 	db "Stack fault:",0 
730f			 
730f .. 00		sfaultsu: 	db	"Stack under flow",0 
7320 .. 00		sfaultso: 	db	"Stack over flow",0 
7330 .. 00		sfaultru:	db "RTS underflow",0 
733e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7358 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7372 .. 00		sfaultdo:	db "DTS overflow", 0 
737f			 
737f			 
737f			fault_dsp_under: 
737f 11 91 73			ld de, .dsp_under 
7382 c3 41 74			jp .show_fault 
7385			 
7385			fault_rsp_under: 
7385 11 9f 73			ld de, .rsp_under 
7388 c3 41 74			jp .show_fault 
738b			fault_loop_under: 
738b 11 ad 73			ld de, .loop_under 
738e c3 41 74			jp .show_fault 
7391			 
7391 .. 00		.dsp_under: db "DSP Underflow",0 
739f .. 00		.rsp_under: db "RSP Underflow",0 
73ad .. 00		.loop_under: db "LOOP Underflow",0 
73bc			 
73bc			 
73bc d5			type_faultn: 	push de 
73bd e5					push hl 
73be cd 9c 0d				call clear_display 
73c1 11 e8 73				   ld de, .typefaultn 
73c4 3e 00				ld a, display_row_1 
73c6 cd af 0d				call str_at_display 
73c9 11 68 fe				    ld de, debug_mark 
73cc 3e 11				ld a, display_row_1+17 
73ce cd af 0d				call str_at_display 
73d1 cd bf 0d				call update_display 
73d4			 
73d4				; prompt before entering montior for investigating issue 
73d4			 
73d4 3e 78			ld a, display_row_4 
73d6 11 f8 1d			ld de, endprog 
73d9			 
73d9 cd bf 0d			call update_display		 
73dc			 
73dc cd 7e 20			call next_page_prompt 
73df			 
73df e5					push hl 
73e0 d5					push de 
73e1 cd 4c 1e				call monitor 
73e4 c3 55 1d				jp warmstart 
73e7 76					halt 
73e8			 
73e8			 
73e8 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
73ff			 
73ff d5			type_faults: 	push de 
7400 e5					push hl 
7401 cd 9c 0d				call clear_display 
7404 11 2a 74				   ld de, .typefaults 
7407 3e 00				ld a, display_row_1 
7409 cd af 0d				call str_at_display 
740c 11 68 fe				    ld de, debug_mark 
740f 3e 11				ld a, display_row_1+17 
7411 cd af 0d				call str_at_display 
7414 cd bf 0d				call update_display 
7417			 
7417				; prompt before entering montior for investigating issue 
7417			 
7417 3e 78			ld a, display_row_4 
7419 11 f8 1d			ld de, endprog 
741c			 
741c cd bf 0d			call update_display		 
741f			 
741f cd 7e 20			call next_page_prompt 
7422			 
7422 e1					pop hl 
7423 d1					pop de 
7424 cd 4c 1e				call monitor 
7427 c3 55 1d				jp warmstart 
742a			 
742a			 
742a .. 00		.typefaults: db "STR Type Expected TOS!",0 
7441			 
7441			.show_fault: 	 
7441 d5					push de 
7442 cd 9c 0d				call clear_display 
7445 d1					pop de 
7446 3e 00				ld a, display_row_1 
7448 cd af 0d				call str_at_display 
744b 11 68 fe				    ld de, debug_mark 
744e 3e 11				ld a, display_row_1+17 
7450 cd af 0d				call str_at_display 
7453 cd bf 0d				call update_display 
7456			 
7456				; prompt before entering montior for investigating issue 
7456			 
7456 3e 78			ld a, display_row_4 
7458 11 f8 1d			ld de, endprog 
745b			 
745b cd bf 0d			call update_display		 
745e			 
745e cd 7e 20			call next_page_prompt 
7461			 
7461 e1					pop hl 
7462 d1					pop de 
7463 cd 4c 1e				call monitor 
7466			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7466			; TODO Make optional fault restart to cli or warm boot? 
7466					;jp warmstart 
7466 c3 9f 1d				jp cli 
7469 76					halt 
746a			 
746a			; handle the auto run of code from files in storage 
746a			 
746a			 
746a			include "forth_startup.asm" 
746a			; Which startup method to use? 
746a			; 
746a			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
746a			; followed by loading of a list of scripts in eeprom 
746a			 
746a			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
746a			; from eeprom 
746a			 
746a			; Select with define in main stubs 
746a			 
746a			if STARTUP_V1 
746a				include "forth_startupv1.asm" 
746a			endif 
746a			if STARTUP_V2 
746a				include "forth_startupv2.asm" 
746a			; Version 2 of the startup  
746a			;  
746a			; Auto load any files in bank 1 that start with a '*' 
746a			; If no se storage then revert to using eprom 
746a			 
746a			 
746a			if STORAGE_SE = 0 
746a			 
746a			sprompt1: db "Startup load...",0 
746a			sprompt2: db "Run? 1=No *=End #=All",0 
746a			 
746a			 
746a			 
746a			 
746a			forth_startup: 
746a				ld hl, startcmds 
746a				ld a, 0 
746a				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
746a			 
746a			.start1:	push hl 
746a				call clear_display 
746a				ld de, sprompt1 
746a			        ld a, display_row_1 
746a				call str_at_display 
746a				ld de, sprompt2 
746a			        ld a, display_row_2 
746a				call str_at_display 
746a				pop hl 
746a				push hl 
746a				ld e,(hl) 
746a				inc hl 
746a				ld d,(hl) 
746a			        ld a, display_row_3 
746a				call str_at_display 
746a				call update_display 
746a			 
746a			 
746a				ld a, (os_last_cmd) 
746a				cp 0 
746a				jr z, .startprompt 
746a				call delay250ms 
746a				jr .startdo 
746a				 
746a				 
746a			 
746a			.startprompt: 
746a			 
746a				ld a,display_row_4 + display_cols - 1 
746a			        ld de, endprg 
746a				call str_at_display 
746a				call update_display 
746a				call delay1s 
746a				call cin_wait 
746a						 
746a				cp '*' 
746a				jr z, .startupend1 
746a				cp '#' 
746a				jr nz, .startno 
746a				ld a, 1 
746a				ld (os_last_cmd),a 
746a				jr .startdo 
746a			.startno:	cp '1' 
746a				jr z,.startnxt  
746a			 
746a				; exec startup line 
746a			.startdo:	 
746a				pop hl 
746a				push hl 
746a				 
746a				ld e,(hl) 
746a				inc hl 
746a				ld d,(hl) 
746a				ex de,hl 
746a			 
746a				push hl 
746a			 
746a				ld a, 0 
746a				;ld a, FORTH_END_BUFFER 
746a				call strlent 
746a				inc hl   ; include zero term to copy 
746a				ld b,0 
746a				ld c,l 
746a				pop hl 
746a				ld de, scratch 
746a				ldir 
746a			 
746a			 
746a				ld hl, scratch 
746a				call forthparse 
746a				call forthexec 
746a				call forthexec_cleanup 
746a			 
746a				ld a, display_row_4 
746a				ld de, endprog 
746a			 
746a				call update_display		 
746a			 
746a				ld a, (os_last_cmd) 
746a				cp 0 
746a				jr nz, .startnxt 
746a				call next_page_prompt 
746a			        call clear_display 
746a				call update_display		 
746a			 
746a				; move onto next startup line? 
746a			.startnxt: 
746a			 
746a				call delay250ms 
746a				pop hl 
746a			 
746a				inc hl 
746a				inc hl 
746a			 
746a				push hl 
746a				ld e, (hl) 
746a				inc hl 
746a				ld d, (hl) 
746a				pop hl 
746a				; TODO replace 0 test 
746a			 
746a				ex de, hl 
746a				call ishlzero 
746a			;	ld a,e 
746a			;	add d 
746a			;	cp 0    ; any left to do? 
746a				ex de, hl 
746a				jp nz, .start1 
746a				jr .startupend 
746a			 
746a			.startupend1: pop hl 
746a			.startupend: 
746a			 
746a				call clear_display 
746a				call update_display 
746a				ret 
746a			endif 
746a			 
746a			 
746a			if STORAGE_SE 
746a			 
746a			;sprompt3: db "Loading from start-up file:",0 
746a .. 00		sprompt3: db "  Searching...",0 
7479			;sprompt4: db "(Any key to stop)",0 
7479			 
7479			 
7479			forth_autoload: 
7479			 
7479				; load block 0 of store 1 
7479				 
7479 3e fe			ld a, $fe      ; bit 0 clear 
747b 32 5d fa			ld (spi_device), a 
747e			 
747e cd 17 05			call storage_get_block_0 
7481			 
7481 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
7484			 
7484 fe 00			cp 0 
7486 c8				ret z     ; auto start not enabled 
7487			 
7487 cd 9c 0d			call clear_display 
748a			 
748a				; set bank 
748a			 
748a 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
748d 32 5d fa				ld (spi_device), a 
7490			 
7490			 
7490				; generate a directory of bank 1 and search for flagged files 
7490			 
7490					if DEBUG_FORTH_WORDS_KEY 
7490						DMARK "DIR" 
7490 f5				push af  
7491 3a a5 74			ld a, (.dmark)  
7494 32 68 fe			ld (debug_mark),a  
7497 3a a6 74			ld a, (.dmark+1)  
749a 32 69 fe			ld (debug_mark+1),a  
749d 3a a7 74			ld a, (.dmark+2)  
74a0 32 6a fe			ld (debug_mark+2),a  
74a3 18 03			jr .pastdmark  
74a5 ..			.dmark: db "DIR"  
74a8 f1			.pastdmark: pop af  
74a9			endm  
# End of macro DMARK
74a9						CALLMONITOR 
74a9 cd 6c fe			call debug_vector  
74ac				endm  
# End of macro CALLMONITOR
74ac					endif 
74ac			 
74ac cd 17 05			call storage_get_block_0 
74af			 
74af 21 77 fa			ld hl, store_page     ; get current id count 
74b2 46				ld b, (hl) 
74b3 0e 00			ld c, 0    ; count of files   
74b5					if DEBUG_FORTH_WORDS 
74b5						DMARK "DI1" 
74b5 f5				push af  
74b6 3a ca 74			ld a, (.dmark)  
74b9 32 68 fe			ld (debug_mark),a  
74bc 3a cb 74			ld a, (.dmark+1)  
74bf 32 69 fe			ld (debug_mark+1),a  
74c2 3a cc 74			ld a, (.dmark+2)  
74c5 32 6a fe			ld (debug_mark+2),a  
74c8 18 03			jr .pastdmark  
74ca ..			.dmark: db "DI1"  
74cd f1			.pastdmark: pop af  
74ce			endm  
# End of macro DMARK
74ce						CALLMONITOR 
74ce cd 6c fe			call debug_vector  
74d1				endm  
# End of macro CALLMONITOR
74d1					endif 
74d1			 
74d1				; check for empty drive 
74d1			 
74d1 3e 00			ld a, 0 
74d3 b8				cp b 
74d4 ca 21 75			jp z, .dirdone 
74d7			 
74d7				; for each of the current ids do a search for them and if found push to stack 
74d7			 
74d7 c5			.diritem:	push bc 
74d8 21 40 00				ld hl, STORE_BLOCK_PHY 
74db 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
74dd 58					ld e,b 
74de			 
74de d5					push de 
74df e5					push hl 
74e0 cd 9c 0d			call clear_display 
74e3 3e 32			ld a, display_row_2 + 10 
74e5 11 6a 74			ld de, sprompt3 
74e8 cd af 0d			call str_at_display 
74eb cd f3 0c			call active 
74ee eb				ex de, hl 
74ef 3e 2f			ld a, display_row_2 + 7 
74f1 cd af 0d			call str_at_display 
74f4 cd bf 0d			call update_display 
74f7 e1				pop hl 
74f8 d1				pop de 
74f9			 
74f9			;		if DEBUG_FORTH_WORDS 
74f9			;			DMARK "DI2" 
74f9			;			CALLMONITOR 
74f9			;		endif 
74f9			 
74f9 cd 99 07				call storage_findnextid 
74fc			 
74fc			;		if DEBUG_FORTH_WORDS 
74fc			;			DMARK "DI3" 
74fc			;			CALLMONITOR 
74fc			;		endif 
74fc			 
74fc					; if found hl will be non zero 
74fc			 
74fc cd f9 0f				call ishlzero 
74ff			;		ld a, l 
74ff			;		add h 
74ff			; 
74ff			;		cp 0 
74ff 28 1d				jr z, .dirnotfound 
7501			 
7501					; increase count 
7501			 
7501 c1					pop bc	 
7502 0c					inc c 
7503 c5					push bc 
7504					 
7504			 
7504					; get file header and push the file name 
7504			 
7504 11 77 fa				ld de, store_page 
7507 cd 66 04				call storage_read_block 
750a			 
750a					; push file id to stack 
750a				 
750a			 
750a					; is this a file we want to run? 
750a			 
750a 21 7a fa				ld hl, store_page+3 
750d 7e					ld a,(hl) 
750e fe 2a				cp '*' 
7510 20 0c				jr nz,  .dirnotfound 
7512					 
7512			 
7512			 
7512 3a 77 fa				ld a, (store_page) 
7515 d5					push de 
7516 e5					push hl 
7517 c5					push bc 
7518 cd 44 75				call .autorunf 
751b c1					pop bc 
751c e1					pop hl 
751d d1					pop de 
751e			 
751e			 
751e			 
751e				; save this extent 
751e			 
751e					; push file name 
751e			;display file name to run 
751e			 
751e			;		ld hl, store_page+3 
751e			;		if DEBUG_FORTH_WORDS 
751e			;			DMARK "DI5" 
751e			;			CALLMONITOR 
751e			;		endif 
751e			; 
751e			;		 
751e			; 
751e			;		call forth_push_str 
751e			;		if DEBUG_FORTH_WORDS 
751e			;			DMARK "DI6" 
751e			;			CALLMONITOR 
751e			;		endif 
751e			.dirnotfound: 
751e c1					pop bc     
751f 10 b6				djnz .diritem 
7521				 
7521			.dirdone:	 
7521					if DEBUG_FORTH_WORDS 
7521						DMARK "DI7" 
7521 f5				push af  
7522 3a 36 75			ld a, (.dmark)  
7525 32 68 fe			ld (debug_mark),a  
7528 3a 37 75			ld a, (.dmark+1)  
752b 32 69 fe			ld (debug_mark+1),a  
752e 3a 38 75			ld a, (.dmark+2)  
7531 32 6a fe			ld (debug_mark+2),a  
7534 18 03			jr .pastdmark  
7536 ..			.dmark: db "DI7"  
7539 f1			.pastdmark: pop af  
753a			endm  
# End of macro DMARK
753a						CALLMONITOR 
753a cd 6c fe			call debug_vector  
753d				endm  
# End of macro CALLMONITOR
753d					endif 
753d			 
753d cd 9c 0d				call clear_display 
7540 cd bf 0d				call update_display 
7543			 
7543 c9					ret 
7544			 
7544			 
7544			 
7544			 
7544			 
7544			.autorunf: 
7544			 
7544			 
7544				; get file id to load from and get the file name to display 
7544			 
7544			;		ld a, (store_page+STORE_0_FILERUN) 
7544			 
7544 2e 00				ld l, 0 
7546 67					ld h, a 
7547 11 77 fa				ld de, store_page 
754a			 
754a					if DEBUG_FORTH_WORDS 
754a						DMARK "ASp" 
754a f5				push af  
754b 3a 5f 75			ld a, (.dmark)  
754e 32 68 fe			ld (debug_mark),a  
7551 3a 60 75			ld a, (.dmark+1)  
7554 32 69 fe			ld (debug_mark+1),a  
7557 3a 61 75			ld a, (.dmark+2)  
755a 32 6a fe			ld (debug_mark+2),a  
755d 18 03			jr .pastdmark  
755f ..			.dmark: db "ASp"  
7562 f1			.pastdmark: pop af  
7563			endm  
# End of macro DMARK
7563						CALLMONITOR 
7563 cd 6c fe			call debug_vector  
7566				endm  
# End of macro CALLMONITOR
7566					endif 
7566 cd bf 09				call storage_read 
7569			 
7569					if DEBUG_FORTH_WORDS 
7569						DMARK "ASr" 
7569 f5				push af  
756a 3a 7e 75			ld a, (.dmark)  
756d 32 68 fe			ld (debug_mark),a  
7570 3a 7f 75			ld a, (.dmark+1)  
7573 32 69 fe			ld (debug_mark+1),a  
7576 3a 80 75			ld a, (.dmark+2)  
7579 32 6a fe			ld (debug_mark+2),a  
757c 18 03			jr .pastdmark  
757e ..			.dmark: db "ASr"  
7581 f1			.pastdmark: pop af  
7582			endm  
# End of macro DMARK
7582						CALLMONITOR 
7582 cd 6c fe			call debug_vector  
7585				endm  
# End of macro CALLMONITOR
7585					endif 
7585			 
7585 cd f9 0f				call ishlzero 
7588 c8					ret z             ; file not found 
7589			 
7589					; display file name we are loading 
7589			 
7589 cd 9c 0d				call clear_display 
758c			 
758c 3e 32				ld a, display_row_2 + 10 
758e 11 7a fa				ld de, store_page+3 
7591 cd af 0d				call str_at_display 
7594				 
7594			; 
7594			 
7594			;	ld a, display_row_1+5 
7594			;	ld de, sprompt3 
7594			;	call str_at_display 
7594			;	ld a, display_row_2+7 
7594			;	call active 
7594			;	ex de, hl 
7594			;;	ld de, sprompt4 
7594			;	call str_at_display 
7594			; 
7594 cd bf 0d			call update_display 
7597			 
7597			;	call cin_wait 
7597			;	cp 'n' 
7597			;	ret z 
7597			;	cp 'N' 
7597			;	ret z 
7597			 
7597			;	call delay1s 
7597			 
7597 3a 79 fa			ld a, (store_page+2) 
759a 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
759d 3e 01			ld a, 1  
759f 32 67 fa			ld (store_openext), a    ; save count of ext 
75a2			 
75a2			.autof: 
75a2				; begin to read a line from file 
75a2			 
75a2 21 e5 f4			ld hl, os_cli_cmd 
75a5 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75a8			  
75a8			.readext: 
75a8 3a 67 fa			ld a, (store_openext) 
75ab 6f				ld l , a 
75ac				 
75ac 3a 77 fa			ld a, (store_page) 
75af 67				ld h, a	 
75b0 11 77 fa			ld de, store_page 
75b3					if DEBUG_FORTH_WORDS 
75b3						DMARK "ASl" 
75b3 f5				push af  
75b4 3a c8 75			ld a, (.dmark)  
75b7 32 68 fe			ld (debug_mark),a  
75ba 3a c9 75			ld a, (.dmark+1)  
75bd 32 69 fe			ld (debug_mark+1),a  
75c0 3a ca 75			ld a, (.dmark+2)  
75c3 32 6a fe			ld (debug_mark+2),a  
75c6 18 03			jr .pastdmark  
75c8 ..			.dmark: db "ASl"  
75cb f1			.pastdmark: pop af  
75cc			endm  
# End of macro DMARK
75cc						CALLMONITOR 
75cc cd 6c fe			call debug_vector  
75cf				endm  
# End of macro CALLMONITOR
75cf					endif 
75cf cd bf 09				call storage_read 
75d2 cd f9 0f			call ishlzero 
75d5 c8				ret z 
75d6			 
75d6			; TODO copy to exec buffer 
75d6			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75d6			 
75d6				; copy the record buffer to the cli buffer 
75d6			 
75d6 ed 5b e3 f6		ld de, (os_var_array) 
75da 21 79 fa			ld hl, store_page+2 
75dd			;	ex de, hl 
75dd 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
75e0 ed b0			ldir 
75e2 ed 53 e3 f6		ld (os_var_array), de 
75e6				 
75e6 3a 67 fa			ld a, (store_openext) 
75e9 3c				inc a 
75ea 32 67 fa			ld (store_openext), a    ; save count of ext 
75ed			 
75ed			 
75ed			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75ed				 
75ed 3a 6a fa			ld a, (store_readcont) 
75f0 fe 00			cp 0 
75f2 20 b4			jr nz, .readext 
75f4			 
75f4			;	jr z, .autoend 
75f4			 
75f4					if DEBUG_FORTH_WORDS 
75f4						DMARK "ASc" 
75f4 f5				push af  
75f5 3a 09 76			ld a, (.dmark)  
75f8 32 68 fe			ld (debug_mark),a  
75fb 3a 0a 76			ld a, (.dmark+1)  
75fe 32 69 fe			ld (debug_mark+1),a  
7601 3a 0b 76			ld a, (.dmark+2)  
7604 32 6a fe			ld (debug_mark+2),a  
7607 18 03			jr .pastdmark  
7609 ..			.dmark: db "ASc"  
760c f1			.pastdmark: pop af  
760d			endm  
# End of macro DMARK
760d						CALLMONITOR 
760d cd 6c fe			call debug_vector  
7610				endm  
# End of macro CALLMONITOR
7610					endif 
7610 e5				push hl	 
7611 d5				push de 
7612 cd f3 0c			call active 
7615 eb				ex de, hl 
7616 3e 2f			ld a, display_row_2 + 7 
7618 cd af 0d			call str_at_display 
761b			 
761b cd bf 0d			call update_display 
761e d1				pop de  
761f e1				pop hl 
7620			;	call delay250ms 
7620			 
7620			 
7620			 
7620			 
7620			.autoexec: 
7620			 
7620			 
7620 21 e5 f4			ld hl, os_cli_cmd 
7623					if DEBUG_FORTH_WORDS 
7623						DMARK "ASx" 
7623 f5				push af  
7624 3a 38 76			ld a, (.dmark)  
7627 32 68 fe			ld (debug_mark),a  
762a 3a 39 76			ld a, (.dmark+1)  
762d 32 69 fe			ld (debug_mark+1),a  
7630 3a 3a 76			ld a, (.dmark+2)  
7633 32 6a fe			ld (debug_mark+2),a  
7636 18 03			jr .pastdmark  
7638 ..			.dmark: db "ASx"  
763b f1			.pastdmark: pop af  
763c			endm  
# End of macro DMARK
763c						CALLMONITOR 
763c cd 6c fe			call debug_vector  
763f				endm  
# End of macro CALLMONITOR
763f					endif 
763f cd 01 25			call forthparse 
7642 cd 41 25			call forthexec 
7645 cd 53 24			call forthexec_cleanup 
7648			 
7648			 
7648			 
7648 c3 a2 75			jp .autof 
764b			;.autofdone: 
764b			; 
764b			;		if DEBUG_FORTH_WORDS 
764b			;			DMARK "ASx" 
764b			;			CALLMONITOR 
764b			;		endif 
764b			;;	call clear_display 
764b			;	ret 
764b			 
764b			 
764b			 
764b			endif 
# End of file forth_startupv2.asm
764b			endif 
764b			 
# End of file forth_startup.asm
764b			 
764b			; eof 
# End of file forth_kernel.asm
764b			;include "nascombasic.asm" 
764b			 
764b			 
764b			; find out where the code ends if loaded into RAM (for SC114) 
764b			;endofcode:  
764b			;	nop 
764b			 
764b			 
764b			; jump to nmi vector 
764b			 
764b			init_nmi: 
764b 3e c9			ld a, $c9   ; RET 
764d 32 6f fe			ld (nmi_vector), a 
7650 c9				ret 
7651			nmi: 
7651 e5				push hl 
7652 d5				push de 
7653 c5				push bc 
7654 f5				push af 
7655 cd 6f fe			call nmi_vector 
7658 f5				push af 
7659 c5				push bc 
765a d5				push de 
765b e5				push hl 
765c ed 4d			reti 
765e			 
765e			 
765e			; eof 
765e			 
# End of file main.asm
765e			include "firmware_lcd_4x40.asm" 
765e			; **********************************************************************  
765e			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
765e			; **********************************************************************  
765e			;  
765e			; **  Written as a Small Computer Monitor App  
765e			; **  www.scc.me.uk  
765e			;  
765e			; History  
765e			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
765e			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
765e			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
765e			;  
765e			; **********************************************************************  
765e			;  
765e			; This program is an example of one of the methods of interfacing an   
765e			; alphanumeric LCD module.   
765e			;  
765e			; In this example the display is connected to either a Z80 PIO or a   
765e			; simple 8-bit output port.   
765e			;  
765e			; This interfacing method uses 4-bit data mode and uses time delays  
765e			; rather than polling the display's ready status. As a result the   
765e			; interface only requires 6 simple output lines:  
765e			;   Output bit 0 = not used  
765e			;   Output bit 1 = not used  
765e			;   Output bit 2 = RS         High = data, Low = instruction  
765e			;   Output bit 3 = E          Active high  
765e			;   Output bit 4 = DB4  
765e			;   Output bit 5 = DB5  
765e			;   Output bit 6 = DB6  
765e			;   Output bit 7 = DB7  
765e			; Display's R/W is connected to 0v so it is always in write mode  
765e			;  
765e			; This set up should work with any system supporting the RC2014 bus  
765e			  
765e			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
765e			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
765e			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
765e			;  
765e			; **********************************************************************  
765e			  
765e			; Additonal for 4x40. E1 and E2 instead of just E   
765e			; TODO swipe vidout signal on port a to activate E2  
765e			  
765e			; **********************************************************************  
765e			; **  Constants  
765e			; **********************************************************************  
765e			; LCD constants required by LCD support module  
765e			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
765e			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
765e			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
765e			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
765e			; TODO Decide which E is being set  
765e			kLCDWidth:  EQU display_cols             ;Width in characters  
765e			  
765e			; **********************************************************************  
765e			; **  Code library usage  
765e			; **********************************************************************  
765e			  
765e			; send character to current cursor position  
765e			; wraps and/or scrolls screen automatically  
765e			  
765e			  
765e			  
765e			lcd_init:  
765e			  
765e			; SCMonAPI functions used  
765e			  
765e			; Alphanumeric LCD functions used  
765e			; no need to specify specific functions for this module  
765e			  
765e 3e cf		            LD   A, 11001111b  
7660 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7662 3e 00		            LD   A, 00000000b  
7664 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7666			  
7666			; Initialise alphanumeric LCD module  
7666 3e 00				ld a, 0  
7668 32 c8 fb				ld (display_lcde1e2), a  
766b cd ec 76		            CALL fLCD_Init      ;Initialise LCD module  
766e 3e 01				ld a, 1  
7670 32 c8 fb				ld (display_lcde1e2), a  
7673 cd ec 76		            CALL fLCD_Init      ;Initialise LCD module  
7676			  
7676 c9				ret  
7677			  
7677			;  
7677			;;  
7677			; lcd functions  
7677			;  
7677			;  
7677			  
7677			; what is at cursor position   
7677			  
7677			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7677			;		call curptr  
7677			;		ret  
7677			  
7677			  
7677			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7677			  
7677			curptr:  
7677 c5				push bc  
7678 21 ae fd			ld hl, display_fb0  
767b			cpr:	  
767b				; loop for cursor whole row  
767b 0e 28			ld c, display_cols  
767d 23			cpr1:	inc hl  
767e 0d				dec c  
767f 20 fc			jr nz, cpr1  
7681 05				dec b  
7682 20 f7			jr nz, cpr  
7684			  
7684				; add col	  
7684			  
7684 23			cpr2:	inc hl  
7685 1d				dec e  
7686 20 fc			jr nz, cpr2  
7688			  
7688 c1				pop bc  
7689 c9				ret  
768a				  
768a			  
768a			  
768a			  
768a			  
768a			; write the frame buffer given in hl to hardware   
768a 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
768d 3e 00			ld a, kLCD_Line1  
768f cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7692 06 28			ld b, display_cols  
7694 ed 5b c6 fb		ld de, (display_write_tmp)  
7698 cd e4 76			call write_len_string  
769b				  
769b				  
769b 2a c6 fb			ld hl, (display_write_tmp)  
769e 11 28 00			ld de, display_cols  
76a1 19				add hl,de  
76a2 22 c6 fb			ld (display_write_tmp),hl  
76a5			  
76a5				  
76a5 3e 28			ld a, kLCD_Line2  
76a7 cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76aa 06 28			ld b, display_cols  
76ac ed 5b c6 fb		ld de, (display_write_tmp)  
76b0 cd e4 76			call write_len_string  
76b3				  
76b3 2a c6 fb			ld hl, (display_write_tmp)  
76b6 11 28 00			ld de, display_cols  
76b9 19				add hl,de  
76ba 22 c6 fb			ld (display_write_tmp),hl  
76bd			  
76bd				  
76bd 3e 50			ld a, kLCD_Line3  
76bf cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76c2 06 28			ld b, display_cols  
76c4 ed 5b c6 fb		ld de, (display_write_tmp)  
76c8 cd e4 76			call write_len_string  
76cb				  
76cb 2a c6 fb			ld hl, (display_write_tmp)  
76ce 11 28 00			ld de, display_cols  
76d1 19				add hl,de  
76d2 22 c6 fb			ld (display_write_tmp),hl  
76d5			  
76d5				  
76d5 3e 78			ld a, kLCD_Line4  
76d7 cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76da 06 28			ld b, display_cols  
76dc ed 5b c6 fb		ld de, (display_write_tmp)  
76e0 cd e4 76			call write_len_string  
76e3 c9					ret  
76e4				  
76e4				; write out a fixed length string given in b from de  
76e4			  
76e4 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76e5 cd 51 77		            CALL fLCD_Data      ;Write character to display  
76e8 13				inc de  
76e9 10 f9			djnz write_len_string  
76eb c9				ret  
76ec			  
76ec			; Some other things to do  
76ec			;            LD   A, kLCD_Clear ;Display clear  
76ec			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76ec			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76ec			;            LD   A, kLCD_On     ;Display on with no cursor  
76ec			;            ;LD   A, kLCD_Off   ;Display off  
76ec			;            CALL fLCD_Inst      ;Send instruction to display  
76ec			;  
76ec			;  
76ec			;            halt  
76ec			;  
76ec			;  
76ec			;MsgHello:   DB  "Hello World!",0  
76ec			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76ec			  
76ec			; Custom characters 5 pixels wide by 8 pixels high  
76ec			; Up to 8 custom characters can be defined  
76ec			;BitMaps:      
76ec			;; Character 0x00 = Battery icon  
76ec			;            DB  01110b  
76ec			;            DB  11011b  
76ec			;            DB  10001b  
76ec			;            DB  10001b  
76ec			;            DB  11111b  
76ec			;            DB  11111b  
76ec			;            DB  11111b  
76ec			;            DB  11111b  
76ec			;; Character 0x01 = Bluetooth icon  
76ec			;            DB  01100b  
76ec			;            DB  01010b  
76ec			;            DB  11100b  
76ec			;            DB  01000b  
76ec			;            DB  11100b  
76ec			;            DB  01010b  
76ec			;            DB  01100b  
76ec			;            DB  00000b  
76ec			;  
76ec			  
76ec			  
76ec			; **********************************************************************  
76ec			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76ec			; **********************************************************************  
76ec			;  
76ec			; **  Written as a Small Computer Monitor App   
76ec			; **  Version 0.1 SCC 2018-05-16  
76ec			; **  www.scc.me.uk  
76ec			;  
76ec			; **********************************************************************  
76ec			;  
76ec			; This module provides support for alphanumeric LCD modules using with  
76ec			; *  HD44780 (or compatible) controller  
76ec			; *  5 x 7 pixel fonts  
76ec			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76ec			; *  Interface via six digital outputs to the display (see below)  
76ec			;  
76ec			; LCD module pinout:  
76ec			;   1  Vss   0v supply  
76ec			;   2  Vdd   5v supply  
76ec			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76ec			;   4  RS    High = data, Low = instruction  
76ec			;   5  R/W   High = Read, Low = Write  
76ec			;   6  E     Enable signal (active high)  
76ec			;   7  DB0   Data bit 0  
76ec			;   8  DB1   Data bit 1  
76ec			;   9  DB2   Data bit 2  
76ec			;  10  DB3   Data bit 3  
76ec			;  11  DB4   Data bit 4  
76ec			;  12  DB5   Data bit 5  
76ec			;  13  DB6   Data bit 6  
76ec			;  14  DB7   Data bit 7  
76ec			;  15  A     Backlight anode (+)  
76ec			;  16  K     Backlight cathode (-)  
76ec			;  
76ec			; This interfacing method uses 4-bit data mode and uses time delays  
76ec			; rather than polling the display's ready status. As a result the   
76ec			; interface only requires 6 simple output lines:  
76ec			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76ec			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76ec			;   LCD DB4 = Microcomputer output port bit 4  
76ec			;   LCD DB5 = Microcomputer output port bit 5  
76ec			;   LCD DB6 = Microcomputer output port bit 6  
76ec			;   LCD DB7 = Microcomputer output port bit 7  
76ec			; Display's R/W is connected to 0v so it is always in write mode  
76ec			; All 6 connections must be on the same port address <kLCDPrt>  
76ec			; This method also allows a decent length of cable from micro to LCD  
76ec			;  
76ec			; **********************************************************************  
76ec			;  
76ec			; To include the code for any given function provided by this module,   
76ec			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76ec			; the parent source file.  
76ec			; For example:  #REQUIRES   uHexPrefix  
76ec			;  
76ec			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76ec			; in the parent source file.  
76ec			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76ec			;  
76ec			; These are the function names provided by this module:  
76ec			; fLCD_Init                     ;Initialise LCD  
76ec			; fLCD_Inst                     ;Send instruction to LCD  
76ec			; fLCD_Data                     ;Send data byte to LCD  
76ec			; fLCD_Pos                      ;Position cursor  
76ec			; fLCD_Str                      ;Display string  
76ec			; fLCD_Def                      ;Define custom character  
76ec			;  
76ec			; **********************************************************************  
76ec			;  
76ec			; Requires SCMonAPI.asm to also be included in the project  
76ec			;  
76ec			  
76ec			  
76ec			; **********************************************************************  
76ec			; **  Constants  
76ec			; **********************************************************************  
76ec			  
76ec			; Constants that must be defined externally  
76ec			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76ec			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76ec			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76ec			;kLCDWidth: EQU 20             ;Width in characters  
76ec			  
76ec			; general line offsets in any frame buffer  
76ec			  
76ec			  
76ec			display_row_1: equ 0  
76ec			display_row_2: equ display_row_1+display_cols  
76ec			display_row_3: equ display_row_2 + display_cols  
76ec			display_row_4: equ display_row_3 + display_cols  
76ec			;display_row_4_eol:   
76ec			  
76ec			  
76ec			; Cursor position values for the start of each line  
76ec			  
76ec			; E  
76ec			kLCD_Line1: EQU 0x00   
76ec			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76ec			; E1  
76ec			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76ec			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76ec			  
76ec			; Instructions to send as A register to fLCD_Inst  
76ec			kLCD_Clear: EQU 00000001b     ;LCD clear  
76ec			kLCD_Off:   EQU 00001000b     ;LCD off  
76ec			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76ec			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76ec			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76ec			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76ec			  
76ec			; Constants used by this code module  
76ec			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76ec			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76ec			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76ec			  
76ec			  
76ec			  
76ec			; **********************************************************************  
76ec			; **  LCD support functions  
76ec			; **********************************************************************  
76ec			  
76ec			; Initialise alphanumeric LCD module  
76ec			; LCD control register codes:  
76ec			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76ec			;   N    0 = 1-line mode       1 = 2-line mode  
76ec			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76ec			;   D    0 = Display off       1 = Display on  
76ec			;   C    0 = Cursor off        1 = Cursor on  
76ec			;   B    0 = Blinking off      1 = Blinking on  
76ec			;   ID   0 = Decrement mode    1 = Increment mode  
76ec			;   SH   0 = Entire shift off  1 = Entire shift on  
76ec 3e 28		fLCD_Init:  LD   A, 40  
76ee cd 13 78		            CALL LCDDelay       ;Delay 40ms after power up  
76f1			; For reliable reset set 8-bit mode - 3 times  
76f1 cd e3 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f4 cd e3 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f7 cd e3 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76fa			; Set 4-bit mode  
76fa cd df 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76fd cd 11 78		            CALL LCDDelay1      ;Delay 37 us or more  
7700			; Function set  
7700 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7702 cd 15 77		            CALL fLCD_Inst      ;2 line, display on  
7705			; Display On/Off control  
7705 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7707 cd 15 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
770a			; Display Clear  
770a 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
770c cd 15 77		            CALL fLCD_Inst      ;Clear display  
770f			; Entry mode  
770f 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7711 cd 15 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7714			; Display module now initialised  
7714 c9			            RET  
7715			; ok to here  
7715			  
7715			; Write instruction to LCD  
7715			;   On entry: A = Instruction byte to be written  
7715			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7715 f5			fLCD_Inst:  PUSH AF  
7716 f5			            PUSH AF  
7717 cd 29 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
771a f1			            POP  AF  
771b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
771c 17			            RLA  
771d 17			            RLA  
771e 17			            RLA  
771f cd 29 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7722 3e 02		            LD   A, 2  
7724 cd 13 78		            CALL LCDDelay       ;Delay 2 ms to complete   
7727 f1			            POP  AF  
7728 c9			            RET  
7729			Wr4bits:   
7729 f5					push af  
772a 3a c8 fb				ld a, (display_lcde1e2)  
772d fe 00				cp 0     ; e  
772f 20 10				jr nz, .wea2	  
7731 f1					pop af  
7732 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7734 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7736 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7738 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
773a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
773c cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
773e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7740 c9			            RET  
7741 f1			.wea2:		pop af  
7742 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7744 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7746 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7748 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
774a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
774c cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
774e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7750 c9			            RET  
7751			  
7751			  
7751			; Write data to LCD  
7751			;   On entry: A = Data byte to be written  
7751			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7751 f5			fLCD_Data:  PUSH AF  
7752 f5			            PUSH AF  
7753 cd 65 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7756 f1			            POP  AF  
7757 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7758 17			            RLA  
7759 17			            RLA  
775a 17			            RLA  
775b cd 65 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
775e 3e 96		            LD   A, 150  
7760 3d			Wait:      DEC  A              ;Wait a while to allow data   
7761 20 fd		            JR   NZ, Wait      ;  write to complete  
7763 f1			            POP  AF  
7764 c9			            RET  
7765			Wr4bitsa:     
7765 f5					push af  
7766 3a c8 fb				ld a, (display_lcde1e2)  
7769 fe 00				cp 0     ; e1  
776b 20 16				jr nz, .we2	  
776d f1					pop af  
776e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7770 cb d7		            SET  kLCDBitRS, A  
7772 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7774 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7776 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7778 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
777a cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
777c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
777e cb 97		            RES  kLCDBitRS, A  
7780 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7782 c9			            RET  
7783 f1			.we2:		pop af  
7784 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7786 cb d7		            SET  kLCDBitRS, A  
7788 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
778a cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
778c cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
778e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7790 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7792 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7794 cb 97		            RES  kLCDBitRS, A  
7796 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7798 c9			            RET  
7799			  
7799			  
7799			; Position cursor to specified location  
7799			;   On entry: A = Cursor position  
7799			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7799 f5			fLCD_Pos:   PUSH AF  
779a					; at this point set the E1 or E2 flag depending on position  
779a			  
779a c5					push bc  
779b			;		push af  
779b 06 00				ld b, 0  
779d 4f					ld c, a  
779e 3e 4f				ld a, kLCD_Line3-1  
77a0 b7			 		or a      ;clear carry flag  
77a1 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77a2 38 04				jr c, .pe1  
77a4			  
77a4					; E selection  
77a4 cb 80				res 0, b         ; bit 0 unset e  
77a6			;		pop af    ; before line 3 so recover orig pos  
77a6			;		ld c, a    ; save for poking back  
77a6 18 06				jr .peset	          
77a8			.pe1:          	; E2 selection  
77a8 cb c0				set 0, b         ; bit 0 set e1  
77aa 79					ld a, c  
77ab de 4f				sbc a, kLCD_Line3-1  
77ad 4f					ld c, a	         ; save caculated offset  
77ae			;		pop af     ; bin this original value now we have calculated form  
77ae			  
77ae			.peset:		; set bit  
77ae 78					ld a, b  
77af 32 c8 fb				ld (display_lcde1e2), a 	  
77b2 79					ld a, c  
77b3 c1					pop bc  
77b4			  
77b4 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77b6 cd 15 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77b9 f1			            POP  AF  
77ba c9			            RET  
77bb			  
77bb			  
77bb			; Output text string to LCD  
77bb			;   On entry: DE = Pointer to null terminated text string  
77bb			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77bb 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77bc b7			            OR   A              ;Null terminator?  
77bd c8			            RET  Z              ;Yes, so finished  
77be cd 51 77		            CALL fLCD_Data      ;Write character to display  
77c1 13			            INC  DE             ;Point to next character  
77c2 18 f7		            JR   fLCD_Str       ;Repeat  
77c4 c9					ret  
77c5			  
77c5			; Define custom character  
77c5			;   On entry: A = Character number (0 to 7)  
77c5			;             DE = Pointer to character bitmap data  
77c5			;   On exit:  A = Next character number  
77c5			;             DE = Next location following bitmap  
77c5			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77c5			; Character is   
77c5 c5			fLCD_Def:   PUSH BC  
77c6 f5			            PUSH AF  
77c7 07			            RLCA                ;Calculate location  
77c8 07			            RLCA                ;  for bitmap data  
77c9 07			            RLCA                ;  = 8 x CharacterNumber  
77ca f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77cc cd 15 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77cf 06 00		            LD   B, 0  
77d1 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77d2 cd 51 77		            CALL fLCD_Data      ;Write byte to display  
77d5 13			            INC  DE             ;Point to next byte  
77d6 04			            INC  B              ;Count bytes  
77d7 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77d9 28 f6		            JR   Z, Loop       ;No, so repeat  
77db f1			            POP  AF  
77dc 3c			            INC  A              ;Increment character number  
77dd c1			            POP  BC  
77de c9			            RET  
77df			  
77df			  
77df			; **********************************************************************  
77df			; **  Private functions  
77df			; **********************************************************************  
77df			  
77df			; Write function to LCD  
77df			;   On entry: A = Function byte to be written  
77df			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77df 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
77e1 18 02		            JR   WrFunc  
77e3 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77e5 f5			WrFunc:     PUSH AF  
77e6 f5					push af  
77e7 3a c8 fb				ld a, (display_lcde1e2)  
77ea fe 00				cp 0     ; e1  
77ec 20 0f				jr nz, .wfea2	  
77ee f1					pop af  
77ef d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77f1 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77f3 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77f7 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fb 18 0d			jr .wfskip  
77fd f1			.wfea2:		pop af  
77fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7800 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7802 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7804 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7806 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7808 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
780a 3e 05		.wfskip:            LD  A, 5  
780c cd 13 78		            CALL LCDDelay       ;Delay 5 ms to complete  
780f f1			            POP  AF  
7810 c9			            RET  
7811			  
7811			  
7811			; Delay in milliseconds  
7811			;   On entry: A = Number of milliseconds delay  
7811			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7811 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7813 d5			LCDDelay:   PUSH DE  
7814 5f			            LD   E, A           ;Delay by 'A' ms  
7815 16 00		            LD   D, 0  
7817 cd c4 0c		            CALL aDelayInMS  
781a d1			            POP  DE  
781b c9			            RET  
781c			  
781c			  
781c			testlcd:  
781c 3e 00			ld a, kLCD_Line1  
781e cd 99 77			call fLCD_Pos  
7821 06 28			ld b, 40  
7823 11 51 78			ld de, .ttext1  
7826 cd e4 76			call write_len_string  
7829			  
7829 3e 28			ld a, kLCD_Line2  
782b cd 99 77			call fLCD_Pos  
782e 06 28			ld b, 40  
7830 11 7a 78			ld de, .ttext2  
7833 cd e4 76			call write_len_string  
7836 3e 50			ld a, kLCD_Line3  
7838 cd 99 77			call fLCD_Pos  
783b 06 28			ld b, 40  
783d 11 a3 78			ld de, .ttext3  
7840 cd e4 76			call write_len_string  
7843 3e 78			ld a, kLCD_Line4  
7845 cd 99 77			call fLCD_Pos  
7848 06 28			ld b, 40  
784a 11 cc 78			ld de, .ttext4  
784d cd e4 76			call write_len_string  
7850			  
7850 76				halt  
7851			  
7851			  
7851 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
787a .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78a3 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78cc .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78f5			   
78f5			  
78f5			  
78f5			; eof  
78f5			  
# End of file firmware_lcd_4x40.asm
78f5			;include "firmware_lcd_4x20.asm" 
78f5			include "firmware_key_5x10.asm" 
78f5			; 5 x 10 decade counter scanner  
78f5			  
78f5			  
78f5			; TODO do cursor shape change for shift keys  
78f5			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78f5			  
78f5			  
78f5			; bit mask for each scan column and row for teing the matrix  
78f5			  
78f5			  
78f5			key_init:  
78f5			  
78f5			; SCMonAPI functions used  
78f5			  
78f5			; Alphanumeric LCD functions used  
78f5			; no need to specify specific functions for this module  
78f5			  
78f5			  
78f5 3e cf		            LD   A, 11001111b  
78f7 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78f9			;            LD   A, 00000000b  
78f9 3e 1f		            LD   A, 00011111b  
78fb d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78fd			  
78fd			  
78fd				; TODO Configure cursor shapes  
78fd			  
78fd				; Load cursor shapes   
78fd 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
78ff 11 0f 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7902 06 02		            LD   B, 2           ;Number of characters to define  
7904 cd c5 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7907 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7909			  
7909 3e 01				ld a, 1  
790b 32 be fb			ld (cursor_shape),a  
790e c9				ret  
790f			  
790f			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
790f			; Up to 8 custom characters can be defined  
790f			.cursor_shapes:      
790f			;; Character 0x00 = Normal  
790f 1f			            DB  11111b  
7910 1f			            DB  11111b  
7911 1f			            DB  11111b  
7912 1f			            DB  11111b  
7913 1f			            DB  11111b  
7914 1f			            DB  11111b  
7915 1f			            DB  11111b  
7916 1f			            DB  11111b  
7917			;; Character 0x01 = Modifier  
7917 1f			            DB  11111b  
7918 1b			            DB  11011b  
7919 1b			            DB  11011b  
791a 1b			            DB  11011b  
791b 1b			            DB  11011b  
791c 1f			            DB  11111b  
791d 1b			            DB  11011b  
791e 1f			            DB  11111b  
791f			  
791f			  
791f			  
791f			  
791f			; Display custom character 0  
791f			;            LD   A, kLCD_Line1+14  
791f			;            CALL fLCD_Pos       ;Position cursor to location in A  
791f			;            LD   A, 0  
791f			;            CALL fLCD_Data      ;Write character in A at cursor  
791f			  
791f			; Display custom character 1  
791f			;            LD   A, kLCD_Line2+14  
791f			;            CALL fLCD_Pos      ;Position cursor to location in A  
791f			;            LD   A, 1  
791f			;            CALL fLCD_Data     ;Write character in A at cursor  
791f			  
791f			; keyboard scanning   
791f			  
791f			; character in from keyboard  
791f			  
791f			; mapping for the pcb layout  
791f			  
791f			.matrix_to_char:  
791f .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
792a .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7935 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7940 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
794b .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7956			.matrix_to_shift:  
7956			  
7956 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7961 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
796c 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7977 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7982 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
798d			  
798d			.matrix_to_symbolshift:  
798d			  
798d fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7998 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79a3 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79ae			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79ae 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79b9 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79c4			  
79c4			  
79c4			  
79c4			; mapping for a simple straight through breadboard layout  
79c4			  
79c4			;.matrix_to_char:  
79c4			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c4			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79c4			;		db "asdfghjkl",KEY_CR,0  
79c4			;		db "qwertyuiop",0  
79c4			;		 db "1234567890",0  
79c4			;.matrix_to_shift:  
79c4			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79c4			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79c4			;		db "ASDFGHJKL",KEY_CR,0  
79c4			;		db "QWERTYUIOP",0  
79c4			;		 db "!",'"',"#$%^&*()",0  
79c4			;.matrix_to_symbolshift:  
79c4			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c4			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79c4			;		db "_?*fghjk=",KEY_CR,0  
79c4			;		db "-/+*[]{}@#",0  
79c4			;		 db "1234567890",0  
79c4			  
79c4			;.matrix_to_char: db "D#0*C987B654A321"  
79c4			  
79c4			  
79c4				  
79c4			  
79c4			; add cin and cin_wait  
79c4			  
79c4 cd d5 79		cin_wait: 	call cin  
79c7						if DEBUG_KEYCINWAIT  
79c7							push af  
79c7							  
79c7							ld hl,key_repeat_ct  
79c7							ld (hl),a  
79c7							inc hl  
79c7							call hexout  
79c7							ld hl,key_repeat_ct+3  
79c7							ld a,0  
79c7							ld (hl),a  
79c7			  
79c7							    LD   A, kLCD_Line1+11  
79c7							    CALL fLCD_Pos       ;Position cursor to location in A  
79c7							    LD   DE, key_repeat_ct  
79c7							    ;LD   DE, MsgHello  
79c7							    CALL fLCD_Str       ;Display string pointed to by DE  
79c7			  
79c7			  
79c7			  
79c7							pop af  
79c7						endif  
79c7 fe 00			cp 0  
79c9 28 f9			jr z, cin_wait   ; block until key press  
79cb			  
79cb							if DEBUG_KEYCINWAIT  
79cb								push af  
79cb			  
79cb								ld a, 'A'	  
79cb								ld hl,key_repeat_ct  
79cb								ld (hl),a  
79cb								inc hl  
79cb								ld a,0  
79cb								ld (hl),a  
79cb			  
79cb								    LD   A, kLCD_Line2+11  
79cb								    CALL fLCD_Pos       ;Position cursor to location in A  
79cb								    LD   DE, key_repeat_ct  
79cb								    ;LD   DE, MsgHello  
79cb								    CALL fLCD_Str       ;Display string pointed to by DE  
79cb			  
79cb							call delay500ms  
79cb			  
79cb								pop af  
79cb							endif  
79cb f5				push af   ; save key pressed  
79cc			  
79cc			.cin_wait1:	  
79cc							if DEBUG_KEYCINWAIT  
79cc								push af  
79cc			  
79cc								ld a, 'b'	  
79cc								ld hl,key_repeat_ct  
79cc								ld (hl),a  
79cc								inc hl  
79cc								ld a,0  
79cc								ld (hl),a  
79cc			  
79cc								    LD   A, kLCD_Line2+11  
79cc								    CALL fLCD_Pos       ;Position cursor to location in A  
79cc								    LD   DE, key_repeat_ct  
79cc								    ;LD   DE, MsgHello  
79cc								    CALL fLCD_Str       ;Display string pointed to by DE  
79cc			  
79cc			  
79cc							call delay500ms  
79cc			  
79cc								pop af  
79cc							endif  
79cc			  
79cc cd d5 79		call cin  
79cf fe 00			cp 0  
79d1 20 f9			jr nz, .cin_wait1  	; wait for key release  
79d3			if DEBUG_KEYCINWAIT  
79d3				push af  
79d3			  
79d3				ld a, '3'	  
79d3				ld hl,key_repeat_ct  
79d3				ld (hl),a  
79d3				inc hl  
79d3				ld a,0  
79d3				ld (hl),a  
79d3			  
79d3			            LD   A, kLCD_Line2+11  
79d3			            CALL fLCD_Pos       ;Position cursor to location in A  
79d3			            LD   DE, key_repeat_ct  
79d3			            ;LD   DE, MsgHello  
79d3			            CALL fLCD_Str       ;Display string pointed to by DE  
79d3			  
79d3			  
79d3			call delay500ms  
79d3			  
79d3				pop af  
79d3			endif  
79d3			  
79d3 f1				pop af   ; get key  
79d4 c9				ret  
79d5			  
79d5			  
79d5 cd e9 79		cin: 	call .mtoc  
79d8			  
79d8			if DEBUG_KEYCIN  
79d8				push af  
79d8				  
79d8				ld hl,key_repeat_ct  
79d8				ld (hl),a  
79d8				inc hl  
79d8				call hexout  
79d8				ld hl,key_repeat_ct+3  
79d8				ld a,0  
79d8				ld (hl),a  
79d8			  
79d8			            LD   A, kLCD_Line3+15  
79d8			            CALL fLCD_Pos       ;Position cursor to location in A  
79d8			            LD   DE, key_repeat_ct  
79d8			            ;LD   DE, MsgHello  
79d8			            CALL fLCD_Str       ;Display string pointed to by DE  
79d8			  
79d8			  
79d8			call delay500ms  
79d8			  
79d8				pop af  
79d8			endif  
79d8			  
79d8			  
79d8				; no key held  
79d8 fe 00			cp 0  
79da c8				ret z  
79db			  
79db			if DEBUG_KEYCIN  
79db				push af  
79db			  
79db				ld a, '1'	  
79db				ld hl,key_repeat_ct  
79db				ld (hl),a  
79db				inc hl  
79db				ld a,0  
79db				ld (hl),a  
79db			  
79db			            LD   A, kLCD_Line4+15  
79db			            CALL fLCD_Pos       ;Position cursor to location in A  
79db			            LD   DE, key_repeat_ct  
79db			            ;LD   DE, MsgHello  
79db			            CALL fLCD_Str       ;Display string pointed to by DE  
79db			  
79db			  
79db			call delay500ms  
79db			  
79db				pop af  
79db			endif  
79db			  
79db				; stop key bounce  
79db			  
79db 32 88 fe			ld (key_held),a		 ; save it  
79de 47				ld b, a  
79df			  
79df c5			.cina1:	push bc  
79e0			if DEBUG_KEYCIN  
79e0				push af  
79e0			  
79e0				ld hl,key_repeat_ct  
79e0				inc hl  
79e0				call hexout  
79e0				ld hl,key_repeat_ct+3  
79e0				ld a,0  
79e0				ld (hl),a  
79e0				ld hl,key_repeat_ct  
79e0				ld a, '2'	  
79e0				ld (hl),a  
79e0			  
79e0			            LD   A, kLCD_Line4+15  
79e0			            CALL fLCD_Pos       ;Position cursor to location in A  
79e0			            LD   DE, key_repeat_ct  
79e0			            ;LD   DE, MsgHello  
79e0			            CALL fLCD_Str       ;Display string pointed to by DE  
79e0			  
79e0				pop af  
79e0			endif  
79e0 cd e9 79			call .mtoc  
79e3 c1				pop bc  
79e4 b8				cp b  
79e5 28 f8			jr z, .cina1  
79e7 78				ld a,b		  
79e8			if DEBUG_KEYCIN  
79e8				push af  
79e8			  
79e8				ld hl,key_repeat_ct  
79e8				inc hl  
79e8				call hexout  
79e8				ld hl,key_repeat_ct+3  
79e8				ld a,0  
79e8				ld (hl),a  
79e8				ld hl,key_repeat_ct  
79e8				ld a, '3'	  
79e8				ld (hl),a  
79e8			  
79e8			            LD   A, kLCD_Line4+15  
79e8			            CALL fLCD_Pos       ;Position cursor to location in A  
79e8			            LD   DE, key_repeat_ct  
79e8			            ;LD   DE, MsgHello  
79e8			            CALL fLCD_Str       ;Display string pointed to by DE  
79e8			  
79e8				pop af  
79e8			endif  
79e8 c9				ret  
79e9			  
79e9			; detect keyboard modifier key press and apply new overlay to the face key held  
79e9			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79e9			  
79e9			;.cin_map_modifier:   
79e9			;	ld a, (hl)  
79e9			;	and 255  
79e9			;	ret NZ		; modifier key not flagged  
79e9			;  
79e9			;	; get key face  
79e9			;  
79e9			;	ld b,(key_face_held)  
79e9			;  
79e9			;	ld b, key_cols * key_rows  
79e9			;  
79e9			;	push de  
79e9			;	pop hl  
79e9			;  
79e9			;.mmod1: ld a,(hl)   ; get map test  
79e9			;	cp b  
79e9			;	jr z, .mmod2  
79e9			;  
79e9			;  
79e9			;  
79e9			;.mmod2: inc hl    ;   
79e9			;  
79e9			;	  
79e9			;  
79e9			;	  
79e9			;  
79e9			;	ld hl,key_actual_pressed  
79e9			;	ld (hl),a,  
79e9			;	ret  
79e9			  
79e9			; map matrix key held to char on face of key  
79e9			  
79e9			.mtoc:  
79e9			  
79e9			; test decade counter strobes  
79e9			  
79e9			;.decadetest1:  
79e9			  
79e9			; reset counter  
79e9			;ld a, 128  
79e9			;out (portbdata),a  
79e9			  
79e9			  
79e9			;ld b, 5  
79e9			;.dec1:  
79e9			;ld a, 0  
79e9			;out (portbdata),a  
79e9			;call delay1s  
79e9			  
79e9			;ld a, 32  
79e9			;out (portbdata),a  
79e9			;call delay1s  
79e9			;call delay1s  
79e9			;call delay1s  
79e9			;  
79e9			;ld a, 64+32  
79e9			;out (portbdata),a  
79e9			;call delay1s  
79e9			;;djnz .dec1  
79e9			;  
79e9			;jp .decadetest1  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9			  
79e9				; scan keyboard matrix and generate raw scan map  
79e9 cd 7c 7a			call matrix  
79ec			  
79ec				; reuse c bit 0 left modifer button - ie shift  
79ec			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79ec				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79ec			  
79ec 0e 00			ld c, 0  
79ee			  
79ee				; TODO set flags for modifer key presses   
79ee				; TODO do a search for modifer key...  
79ee			  
79ee				;ld hl,keyscan_table_row4  
79ee 21 e7 fe			ld hl,keyscan_table_row2  
79f1			  
79f1 7e				ld a, (hl)  
79f2 fe 23			cp '#'  
79f4 20 07			jr nz, .nextmodcheck  
79f6 cb c1			set 0, c  
79f8 21 56 79			ld hl, .matrix_to_shift  
79fb 18 21			jr .dokeymap  
79fd				; TODO for now igonre  
79fd			.nextmodcheck:  
79fd 21 dc fe			ld hl,keyscan_table_row3  
7a00			  
7a00 7e				ld a, (hl)  
7a01 fe 23			cp '#'  
7a03 20 07			jr nz, .nextmodcheck2  
7a05 cb c9			set 1, c   
7a07 21 8d 79			ld hl, .matrix_to_symbolshift  
7a0a 18 12			jr .dokeymap  
7a0c			.nextmodcheck2:  
7a0c 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7a0f			  
7a0f 7e				ld a, (hl)  
7a10 fe 23			cp '#'  
7a12 20 07			jr nz, .donemodcheck  
7a14 cb c9			set 1, c   
7a16 21 56 79			ld hl, .matrix_to_shift  
7a19 18 03			jr .dokeymap  
7a1b			  
7a1b				; no modifer found so just map to normal keys  
7a1b				; get mtoc map matrix to respective keys  
7a1b			;	ld hl, .matrix_to_char  
7a1b			;	ld hl, .matrix_to_char  
7a1b			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1b			;	ld a, KEY_SHIFT  
7a1b			;	call findchar  
7a1b			;  
7a1b			;	; got offset to key modifer in b  
7a1b			;  
7a1b			;	ld hl,keyscan_table_row5  
7a1b			;  
7a1b			;	ld a,b  
7a1b			;	call addatohl  
7a1b			;	ld a,(hl)  
7a1b			;  
7a1b			;	cp '#'  
7a1b			;	jr nz, .nextmodcheck  
7a1b			;	set 0, c  
7a1b			;	ld hl, .matrix_to_char  
7a1b			;	jr .dokeymap  
7a1b			;	; TODO for now igonre  
7a1b			;.nextmodcheck:  
7a1b			;	ld hl, .matrix_to_symbolshift  
7a1b			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1b			;	ld a, KEY_SYMBOLSHIFT  
7a1b			;	call findchar  
7a1b			;  
7a1b			;  
7a1b			;	; got offset to key modifer in b  
7a1b			;  
7a1b			;	ld hl,keyscan_table_row5  
7a1b			;  
7a1b			;	ld a,b  
7a1b			;	call addatohl  
7a1b			;	ld a,(hl)  
7a1b			;  
7a1b			;	cp '#'  
7a1b			;	jr nz, .donemodcheck  
7a1b			;	set 1, c   
7a1b			;	ld hl, .matrix_to_symbolshift  
7a1b			;	jr .dokeymap  
7a1b			  
7a1b			  
7a1b			  
7a1b			.donemodcheck:  
7a1b				; no modifer found so just map to normal keys  
7a1b				; get mtoc map matrix to respective keys  
7a1b 21 1f 79			ld hl, .matrix_to_char  
7a1e			  
7a1e			.dokeymap:  
7a1e				;ld (key_fa), c   
7a1e cd 37 7a			call .mapkeys  
7a21			  
7a21			  
7a21			if DEBUG_KEY  
7a21			  
7a21			; Display text on first line  
7a21			            LD   A, kLCD_Line1  
7a21			            CALL fLCD_Pos       ;Position cursor to location in A  
7a21			            LD   DE, keyscan_table_row1  
7a21			            ;LD   DE, MsgHello  
7a21			            CALL fLCD_Str       ;Display string pointed to by DE  
7a21			  
7a21			; Display text on second line  
7a21			            LD   A, kLCD_Line2  
7a21			            CALL fLCD_Pos       ;Position cursor to location in A  
7a21			            LD   DE, keyscan_table_row2  
7a21			            CALL fLCD_Str       ;Display string pointed to by DE  
7a21			            LD   A, kLCD_Line3  
7a21			            CALL fLCD_Pos       ;Position cursor to location in A  
7a21			            LD   DE, keyscan_table_row3  
7a21			            CALL fLCD_Str       ;Display string pointed to by DE  
7a21			            LD   A, kLCD_Line4  
7a21			            CALL fLCD_Pos       ;Position cursor to location in A  
7a21			            LD   DE, keyscan_table_row4  
7a21			            CALL fLCD_Str       ;Display string pointed to by DE  
7a21			            LD   A, kLCD_Line1+10  
7a21			            CALL fLCD_Pos       ;Position cursor to location in A  
7a21			            LD   DE, keyscan_table_row5  
7a21			            CALL fLCD_Str       ;Display string pointed to by DE  
7a21			  
7a21				;call delay250ms  
7a21			endif  
7a21			;	jp testkey  
7a21			  
7a21			; get first char reported  
7a21			  
7a21 21 c6 fe			ld hl,keyscan_table_row5  
7a24			  
7a24				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a24 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a26			.findkey:  
7a26 7e				ld a,(hl)  
7a27 fe 00			cp 0  
7a29 28 04			jr z, .nextkey  
7a2b fe 7e			cp KEY_MATRIX_NO_PRESS  
7a2d 20 06			jr nz, .foundkey  
7a2f			.nextkey:  
7a2f 23				inc hl  
7a30 10 f4			djnz .findkey  
7a32 3e 00			ld a,0  
7a34 c9				ret  
7a35			.foundkey:  
7a35 7e				ld a,(hl)  
7a36 c9				ret  
7a37				  
7a37			  
7a37			; convert the raw key map given hl for destination key  
7a37			.mapkeys:  
7a37 11 c6 fe			ld de,keyscan_table_row5  
7a3a			  
7a3a 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a3c			.remap:  
7a3c 1a				ld a,(de)  
7a3d fe 23			cp '#'  
7a3f 20 02			jr nz, .remapnext  
7a41				;CALLMONITOR  
7a41 7e				ld a,(hl)  
7a42 12				ld (de),a  
7a43			  
7a43			  
7a43			  
7a43			.remapnext:  
7a43 23				inc hl  
7a44 13				inc de  
7a45 10 f5			djnz .remap  
7a47				  
7a47 c9				ret  
7a48			  
7a48			  
7a48			  
7a48			.mtocold2:  
7a48			  
7a48			;	; flag if key D is held down and remove from reporting  
7a48			;	ld bc, .key_map_fd    
7a48			;	ld hl, keyscan_table  
7a48			;	ld de, key_fd  
7a48			;	call .key_shift_hold  
7a48			;	cp 255  
7a48			;	jr z, .cinmap  
7a48			;	; flag if key C is held down and remove from reporting  
7a48			;	ld bc, .key_map_fc    
7a48			;	ld hl, keyscan_table+key_cols  
7a48			;	ld de, key_fc  
7a48			;	call .key_shift_hold  
7a48			;	cp 255  
7a48			;	jr z, .cinmap  
7a48			;	; flag if key B is held down and remove from reporting  
7a48			;	ld bc, .key_map_fb    
7a48			;	ld hl, keyscan_table+(key_cols*2)  
7a48			;	ld de, key_fb  
7a48			;	call .key_shift_hold  
7a48			;	cp 255  
7a48			;	jr z, .cinmap  
7a48			;	; flag if key A is held down and remove from reporting  
7a48			;	ld bc, .key_map_fa    
7a48			;	ld hl, keyscan_table+(key_cols*3)  
7a48			;	ld de, key_fa  
7a48			;	call .key_shift_hold  
7a48			;	cp 255  
7a48			;	jr z, .cinmap  
7a48			  
7a48 11 1f 79			ld de, .matrix_to_char  
7a4b			  
7a4b			  
7a4b			.cinmap1:   
7a4b				if DEBUG_KEY  
7a4b			            LD   A, kLCD_Line4  
7a4b			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4b					push de  
7a4b			            LD   DE, keyscan_table  
7a4b			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4b					pop de  
7a4b				endif  
7a4b			  
7a4b				; scan key matrix table for any held key  
7a4b			  
7a4b				; de holds either the default matrix or one selected above  
7a4b			  
7a4b 21 93 fe			ld hl, keyscan_table  
7a4e 06 32			ld b,key_cols*key_rows  
7a50			  
7a50 7e			.cin11:	ld a,(hl)  
7a51 fe 23			cp '#'  
7a53 28 08			jr z, .cinhit1  
7a55 23				inc hl  
7a56 13				inc de  
7a57 05				dec b  
7a58 20 f6			jr nz, .cin11  
7a5a				; no key found held  
7a5a 3e 00			ld a,0  
7a5c c9				ret  
7a5d d5			.cinhit1: push de  
7a5e e1				pop hl  
7a5f 7e				ld a,(hl)  
7a60 c9				ret  
7a61			  
7a61			; flag a control key is held   
7a61			; hl is key pin, de is flag indicator  
7a61			  
7a61			.key_shift_hold1:  
7a61 c5				push bc  
7a62 3e 01			ld a, 1  
7a64 32 be fb			ld (cursor_shape),a  
7a67 06 00			ld b, 0  
7a69 7e				ld a, (hl)  
7a6a fe 2e			cp '.'  
7a6c 28 0a			jr z, .key_shift11  
7a6e 06 ff			ld b, 255  
7a70 3e 2b			ld a, '+'    ; hide key from later scans  
7a72 77				ld (hl),a  
7a73 3e 02			ld a, 2  
7a75 32 be fb			ld (cursor_shape),a  
7a78			.key_shift11:  
7a78				; write flag indicator  
7a78 78				ld a,b  
7a79 12				ld (de),a  
7a7a			  
7a7a d1				pop de    ; de now holds the key map ptr  
7a7b c9				ret  
7a7c			  
7a7c				  
7a7c			  
7a7c			; scans keyboard matrix and flags key press in memory array	  
7a7c				  
7a7c			matrix:  
7a7c				;call matrix  
7a7c				; TODO optimise the code....  
7a7c			  
7a7c			  
7a7c			;ld hl, keyscan_table_row1  
7a7c			;ld de, keyscan_table_row1+1  
7a7c			;ld bc,46  
7a7c			;ld a,KEY_MATRIX_NO_PRESS  
7a7c			;ldir  
7a7c			  
7a7c			  
7a7c			  
7a7c			; reset counter  
7a7c 3e 80		ld a, 128  
7a7e d3 c1		out (portbdata),a  
7a80			  
7a80 06 0a		ld b, 10  
7a82 0e 00		ld c, 0       ; current clock toggle  
7a84			  
7a84			.colscan:  
7a84			  
7a84			; set current column  
7a84			; disable clock enable and set clock low  
7a84			  
7a84			;ld a, 0  
7a84			;out (portbdata),a  
7a84			  
7a84			; For each column scan for switches  
7a84			  
7a84 c5			push bc  
7a85 21 89 fe		ld hl, keyscan_scancol  
7a88 cd 91 7b		call .rowscan  
7a8b c1			pop bc  
7a8c			  
7a8c			  
7a8c			; get back current column  
7a8c			  
7a8c			; translate the row scan  
7a8c			  
7a8c			;   
7a8c			; row 1  
7a8c			  
7a8c 78			ld a,b  
7a8d			  
7a8d 21 fc fe		LD   hl, keyscan_table_row1+10  
7a90			  
7a90 cd e2 0f		call subafromhl  
7a93			;call addatohl  
7a93			  
7a93 11 89 fe		ld de, keyscan_scancol  
7a96			  
7a96 1a			ld a,(de)  
7a97 77			ld (hl),a  
7a98			  
7a98			  
7a98			  
7a98			  
7a98			; row 2  
7a98			  
7a98 78			ld a,b  
7a99			  
7a99 21 f1 fe		LD   hl, keyscan_table_row2+10  
7a9c			  
7a9c			;call addatohl  
7a9c cd e2 0f		call subafromhl  
7a9f			  
7a9f			  
7a9f 11 8a fe		ld de, keyscan_scancol+1  
7aa2			  
7aa2 1a			ld a,(de)  
7aa3 77			ld (hl),a  
7aa4			  
7aa4			  
7aa4			; row 3  
7aa4			  
7aa4 78			ld a,b  
7aa5			  
7aa5 21 e6 fe		LD   hl, keyscan_table_row3+10  
7aa8			  
7aa8			;call addatohl  
7aa8 cd e2 0f		call subafromhl  
7aab			  
7aab 11 8b fe		ld de, keyscan_scancol+2  
7aae			  
7aae 1a			ld a,(de)  
7aaf 77			ld (hl),a  
7ab0			  
7ab0			  
7ab0			  
7ab0			; row 4  
7ab0			  
7ab0 78			ld a,b  
7ab1			  
7ab1 21 db fe		LD   hl, keyscan_table_row4+10  
7ab4			  
7ab4			;call addatohl  
7ab4 cd e2 0f		call subafromhl  
7ab7			  
7ab7 11 8c fe		ld de, keyscan_scancol+3  
7aba			  
7aba 1a			ld a,(de)  
7abb 77			ld (hl),a  
7abc			  
7abc			; row 5  
7abc			  
7abc 78			ld a,b  
7abd			  
7abd 21 d0 fe		LD   hl, keyscan_table_row5+10  
7ac0			  
7ac0			;call addatohl  
7ac0 cd e2 0f		call subafromhl  
7ac3			  
7ac3 11 8d fe		ld de, keyscan_scancol+4  
7ac6			  
7ac6 1a			ld a,(de)  
7ac7 77			ld (hl),a  
7ac8			  
7ac8			; handshake next column  
7ac8			  
7ac8			  
7ac8 3e 40		ld a, 64  
7aca d3 c1		out (portbdata),a  
7acc			  
7acc 3e 00		ld a, 0  
7ace d3 c1		out (portbdata),a  
7ad0			  
7ad0			; toggle clk and move to next column  
7ad0			;ld a, 64  
7ad0			;cp c  
7ad0			;  
7ad0			;jr z, .coltoglow  
7ad0			;ld c, a  
7ad0			;jr .coltog  
7ad0			;.coltoglow:  
7ad0			;ld c, 0  
7ad0			;.coltog:  
7ad0			;ld a, c  
7ad0			;out (portbdata),a  
7ad0			  
7ad0 10 b2		djnz .colscan  
7ad2			  
7ad2 3e 0a		ld a,10  
7ad4 21 f2 fe		LD   hl, keyscan_table_row1  
7ad7 cd d0 0f		call addatohl  
7ada 3e 00		ld a, 0  
7adc 77			ld (hl), a  
7add			  
7add			  
7add 3e 0a		ld a,10  
7adf 21 e7 fe		LD   hl, keyscan_table_row2  
7ae2 cd d0 0f		call addatohl  
7ae5 3e 00		ld a, 0  
7ae7 77			ld (hl), a  
7ae8			  
7ae8 3e 0a		ld a,10  
7aea 21 dc fe		LD   hl, keyscan_table_row3  
7aed cd d0 0f		call addatohl  
7af0 3e 00		ld a, 0  
7af2 77			ld (hl), a  
7af3			  
7af3 3e 0a		ld a,10  
7af5 21 d1 fe		LD   hl, keyscan_table_row4  
7af8 cd d0 0f		call addatohl  
7afb 3e 00		ld a, 0  
7afd 77			ld (hl), a  
7afe			  
7afe 3e 0a		ld a,10  
7b00 21 c6 fe		LD   hl, keyscan_table_row5  
7b03 cd d0 0f		call addatohl  
7b06 3e 00		ld a, 0  
7b08 77			ld (hl), a  
7b09			  
7b09			if DEBUG_KEY_MATRIX  
7b09			  
7b09			; Display text on first line  
7b09			            LD   A, kLCD_Line1  
7b09			            CALL fLCD_Pos       ;Position cursor to location in A  
7b09			            LD   DE, keyscan_table_row1  
7b09			            ;LD   DE, MsgHello  
7b09			            CALL fLCD_Str       ;Display string pointed to by DE  
7b09			  
7b09			; Display text on second line  
7b09			            LD   A, kLCD_Line2  
7b09			            CALL fLCD_Pos       ;Position cursor to location in A  
7b09			            LD   DE, keyscan_table_row2  
7b09			            CALL fLCD_Str       ;Display string pointed to by DE  
7b09			            LD   A, kLCD_Line3  
7b09			            CALL fLCD_Pos       ;Position cursor to location in A  
7b09			            LD   DE, keyscan_table_row3  
7b09			            CALL fLCD_Str       ;Display string pointed to by DE  
7b09			            LD   A, kLCD_Line4  
7b09			            CALL fLCD_Pos       ;Position cursor to location in A  
7b09			            LD   DE, keyscan_table_row4  
7b09			            CALL fLCD_Str       ;Display string pointed to by DE  
7b09			            LD   A, kLCD_Line4+10  
7b09			            CALL fLCD_Pos       ;Position cursor to location in A  
7b09			            LD   DE, keyscan_table_row5  
7b09			            CALL fLCD_Str       ;Display string pointed to by DE  
7b09			  
7b09			;call delay250ms  
7b09				jp matrix  
7b09			endif  
7b09 c9			ret  
7b0a			  
7b0a			; using decade counter....  
7b0a			  
7b0a			  
7b0a			; TODO reset decade counter to start of scan  
7b0a			  
7b0a			; reset 15  
7b0a			; clock 14  
7b0a			; ce 13  
7b0a			  
7b0a			; 1 - q5  
7b0a			; 2 - q1  
7b0a			; 3 - q0  
7b0a			; 4 - q2  
7b0a			; 5 - q6  
7b0a			; 6 - q7  
7b0a			; 7 - q3  
7b0a			; 8 - vss  
7b0a			; 9 - q8  
7b0a			; 10 - q4  
7b0a			; 11 - q9  
7b0a			; 12 - cout  
7b0a			; 16 - vdd  
7b0a			  
7b0a			; clock      ce       reset     output  
7b0a			; 0          x        0         n  
7b0a			; x          1        0         n  
7b0a			; x          x        1         q0  
7b0a			; rising     0        0         n+1  
7b0a			; falling    x        0         n  
7b0a			; x          rising   0         n  
7b0a			; 1          falling  0         x+1  
7b0a			;  
7b0a			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b0a			  
7b0a			;   
7b0a			; reset   
7b0a			; 13=0, 14=0, 15=1 .. 15=0  
7b0a			;  
7b0a			; handshake line  
7b0a			; 14=1.... read line 14=0  
7b0a			  
7b0a			  
7b0a			  
7b0a			  
7b0a			  
7b0a			; TODO hand shake clock for next column scan  
7b0a			; TODO detect each row  
7b0a			  
7b0a			  
7b0a			  
7b0a			  
7b0a			; reset 128  
7b0a			; clock 64  
7b0a			; ce 32  
7b0a			  
7b0a			  
7b0a			.cyclestart:  
7b0a			  
7b0a			; reset counter  
7b0a 3e 80		ld a, 128  
7b0c d3 c1		out (portbdata),a  
7b0e			  
7b0e			; loop leds  
7b0e 06 0a		ld b,10  
7b10			  
7b10			.cycle1:  
7b10 c5			push bc  
7b11 3e 00		ld a, 0  
7b13 d3 c1		out (portbdata),a  
7b15 cd d3 0c		call delay250ms  
7b18			  
7b18 3e 40		ld a, 64  
7b1a d3 c1		out (portbdata),a  
7b1c cd d3 0c		call delay250ms  
7b1f			  
7b1f 3e 00		ld a, 0  
7b21 d3 c1		out (portbdata),a  
7b23 cd d3 0c		call delay250ms  
7b26			  
7b26 c1			pop bc  
7b27 10 e7		djnz .cycle1  
7b29			  
7b29			  
7b29 18 df		jr .cyclestart  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			; map matrix key held to char on face of key  
7b2b			  
7b2b			;.mtocold:  
7b2b			;  
7b2b			;  
7b2b			;; reset counter  
7b2b			;ld a, 128  
7b2b			;out (portbdata),a  
7b2b			;  
7b2b			;  
7b2b			;; scan keyboard row 1  
7b2b			;ld a, 0  
7b2b			;out (portbdata),a  
7b2b			;;ld a, 64  
7b2b			;;out (portbdata),a  
7b2b			;  
7b2b			;  
7b2b			;	ld a, 128  
7b2b			;	ld hl, keyscan_table  
7b2b			;	call .rowscan  
7b2b			;  
7b2b			;;ld a, 0  
7b2b			;;out (portbdata),a  
7b2b			;ld a, 64  
7b2b			;out (portbdata),a  
7b2b			;  
7b2b			;	ld a, 64  
7b2b			;	ld hl, keyscan_table+key_cols  
7b2b			;	call .rowscan  
7b2b			;  
7b2b			;ld a, 0  
7b2b			;out (portbdata),a  
7b2b			;;ld a, 64  
7b2b			;;out (portbdata),a  
7b2b			;	ld a, 32  
7b2b			;	ld hl, keyscan_table+(key_cols*2)  
7b2b			;	call .rowscan  
7b2b			;  
7b2b			;  
7b2b			;;ld a, 0  
7b2b			;;out (portbdata),a  
7b2b			;ld a, 64  
7b2b			;out (portbdata),a  
7b2b			;  
7b2b			;	ld a, 16  
7b2b			;	ld hl, keyscan_table+(key_cols*3)  
7b2b			;	call .rowscan  
7b2b			;  
7b2b			;  
7b2b			;	; flag if key D is held down and remove from reporting  
7b2b			;	ld bc, .key_map_fd    
7b2b			;	ld hl, keyscan_table  
7b2b			;	ld de, key_fd  
7b2b			;	call .key_shift_hold  
7b2b			;	cp 255  
7b2b			;	jr z, .cinmap  
7b2b			;	; flag if key C is held down and remove from reporting  
7b2b			;	ld bc, .key_map_fc    
7b2b			;	ld hl, keyscan_table+key_cols  
7b2b			;	ld de, key_fc  
7b2b			;	call .key_shift_hold  
7b2b			;	cp 255  
7b2b			;	jr z, .cinmap  
7b2b			;	; flag if key B is held down and remove from reporting  
7b2b			;	ld bc, .key_map_fb    
7b2b			;	ld hl, keyscan_table+(key_cols*2)  
7b2b			;	ld de, key_fb  
7b2b			;	call .key_shift_hold  
7b2b			;	cp 255  
7b2b			;	jr z, .cinmap  
7b2b			;	; flag if key A is held down and remove from reporting  
7b2b			;	ld bc, .key_map_fa    
7b2b			;	ld hl, keyscan_table+(key_cols*3)  
7b2b			;	ld de, key_fa  
7b2b			;	call .key_shift_hold  
7b2b			;	cp 255  
7b2b			;	jr z, .cinmap  
7b2b			;  
7b2b			;	ld de, .matrix_to_char  
7b2b			;  
7b2b			;  
7b2b			;.cinmap:   
7b2b			;	if DEBUG_KEY  
7b2b			;            LD   A, kLCD_Line4  
7b2b			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b2b			;		push de  
7b2b			;            LD   DE, keyscan_table  
7b2b			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b2b			;		pop de  
7b2b			;	endif  
7b2b			  
7b2b				; scan key matrix table for any held key  
7b2b			  
7b2b				; de holds either the default matrix or one selected above  
7b2b			  
7b2b			;	ld hl, keyscan_table  
7b2b			;	ld b,key_cols*key_rows  
7b2b			;  
7b2b			;.cin1:	ld a,(hl)  
7b2b			;	cp '#'  
7b2b			;	jr z, .cinhit  
7b2b			;	inc hl  
7b2b			;	inc de  
7b2b			;	dec b  
7b2b			;	jr nz, .cin1  
7b2b			;	; no key found held  
7b2b			;	ld a,0  
7b2b			;	ret  
7b2b			;.cinhit: push de  
7b2b			;	pop hl  
7b2b			;	ld a,(hl)  
7b2b			;	ret  
7b2b			  
7b2b			; flag a control key is held   
7b2b			; hl is key pin, de is flag indicator  
7b2b			  
7b2b			;.key_shift_hold:  
7b2b			;	push bc  
7b2b			;	ld a, 1  
7b2b			;	ld (cursor_shape),a  
7b2b			;	ld b, 0  
7b2b			;	ld a, (hl)  
7b2b			;	cp '.'  
7b2b			;	jr z, .key_shift1  
7b2b			;	ld b, 255  
7b2b			;	ld a, '+'    ; hide key from later scans  
7b2b			;	ld (hl),a  
7b2b			;	ld a, 2  
7b2b			;	ld (cursor_shape),a  
7b2b			;.key_shift1:  
7b2b			;	; write flag indicator  
7b2b			;	ld a,b  
7b2b			;	ld (de),a  
7b2b			;  
7b2b			;	pop de    ; de now holds the key map ptr  
7b2b			;	ret  
7b2b			  
7b2b				  
7b2b				  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			;	push hl  
7b2b			;	push de  
7b2b			;	push bc  
7b2b			;	call keyscan  
7b2b			;	; map key matrix to ascii value of key face  
7b2b			;  
7b2b			;	ld hl, key_face_map  
7b2b			;	ld de, keyscan_table  
7b2b			;  
7b2b			;	; get how many keys to look at  
7b2b			;	ld b, keyscan_table_len  
7b2b			;	  
7b2b			;  
7b2b			;	; at this stage fall out on first key hit  
7b2b			;	; TODO handle multiple key press  
7b2b			;  
7b2b			;map1:	ld a,(hl)  
7b2b			;	cp '#'  
7b2b			;	jr z, keyhit  
7b2b			;	inc hl  
7b2b			;	inc de  
7b2b			;	dec b  
7b2b			;	jr nz, map1  
7b2b			;nohit:	ld a, 0  
7b2b			;	jr keydone  
7b2b			;keyhit: push de  
7b2b			;	pop hl  
7b2b			;	ld a,(hl)  
7b2b			;keydone:  
7b2b			;	push bc  
7b2b			;	push de  
7b2b			; 	push hl  
7b2b			;	ret   
7b2b			;  
7b2b			  
7b2b			  
7b2b			  
7b2b			  
7b2b			; scan physical key matrix  
7b2b			  
7b2b			  
7b2b			;keyscan:  
7b2b			;  
7b2b			;; for each key_row use keyscanr bit mask for out  
7b2b			;; then read in for keyscanc bitmask  
7b2b			;; save result of row scan to keyscantable  
7b2b			;  
7b2b			;; scan keyboard row 1  
7b2b			;  
7b2b			;	ld b, key_rows  
7b2b			;	ld hl, key_scanr  
7b2b			;	ld de, keyscan_table  
7b2b			;  
7b2b			;rowloop:  
7b2b			;  
7b2b			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b2b			;	call rowscan  
7b2b			;	inc hl  
7b2b			;	dec b  
7b2b			;	jr nz, rowloop  
7b2b			;  
7b2b			;	ret  
7b2b			;  
7b2b			;  
7b2b			;; pass a out bitmask, b row number  
7b2b			;arowscan:   
7b2b			;	push bc  
7b2b			;  
7b2b			;	ld d, b  
7b2b			;  
7b2b			;	; calculate buffer location for this row  
7b2b			;  
7b2b			;	ld hl, keyscan_table	  
7b2b			;kbufr:  ld e, key_cols  
7b2b			;kbufc:	inc hl  
7b2b			;	dec e  
7b2b			;	jr nz, kbufc  
7b2b			;	dec d  
7b2b			;	jr nz, kbufr  
7b2b			;  
7b2b			;	; energise row and read columns  
7b2b			;  
7b2b			;	out (portbdata),a  
7b2b			;	in a,(portbdata)  
7b2b			;	ld c,a  
7b2b			;  
7b2b			;  
7b2b			;	; save buffer loc  
7b2b			;  
7b2b			;	ld (keybufptr), hl  
7b2b			;  
7b2b			;	ld hl, key_scanc  
7b2b			;	ld d, key_cols  
7b2b			;  
7b2b			;	; for each column check each bit mask  
7b2b			;  
7b2b			;colloop:  
7b2b			;	  
7b2b			;  
7b2b			;	; reset flags for the row   
7b2b			;  
7b2b			;	ld b,'.'  
7b2b			;	and (hl)  
7b2b			;	jr z, maskskip  
7b2b			;	ld b,'#'  
7b2b			;maskskip:  
7b2b			;	; save  key state  
7b2b			;	push hl  
7b2b			;	ld hl, (keybufptr)  
7b2b			;	ld (hl), b  
7b2b			;	inc hl  
7b2b			;	ld (keybufptr), hl  
7b2b			;  
7b2b			;	; move to next bit mask  
7b2b			;	pop hl  
7b2b			;	inc hl  
7b2b			;  
7b2b			;	dec d  
7b2b			;	jr nz, colloop  
7b2b			;  
7b2b			;	ret  
7b2b			;  
7b2b			;  
7b2b			;;  
7b2b			; lcd functions  
7b2b			;  
7b2b			;  
7b2b			  
7b2b			;if DEBUG_KEY_MATRIX  
7b2b			  
7b2b			; test function to display hardware view of matrix state  
7b2b			  
7b2b			matrixold:  
7b2b			  
7b2b			  
7b2b			  
7b2b			; reset counter  
7b2b 3e 80		ld a, 128  
7b2d d3 c1		out (portbdata),a  
7b2f			; scan keyboard row 1  
7b2f 3e 00		ld a, 0  
7b31 d3 c1		out (portbdata),a  
7b33			;ld a, 64  
7b33			;out (portbdata),a  
7b33 3e 80			ld a, 128  
7b35 21 f2 fe			ld hl, keyscan_table_row1  
7b38 cd 91 7b			call .rowscan  
7b3b			  
7b3b			;ld a, 0  
7b3b			;out (portbdata),a  
7b3b 3e 40		ld a, 64  
7b3d d3 c1		out (portbdata),a  
7b3f 3e 40			ld a, 64  
7b41 21 e7 fe			ld hl, keyscan_table_row2  
7b44 cd 91 7b			call .rowscan  
7b47			  
7b47 3e 00		ld a, 0  
7b49 d3 c1		out (portbdata),a  
7b4b			;ld a, 64  
7b4b			;out (portbdata),a  
7b4b 3e 20			ld a, 32  
7b4d 21 dc fe			ld hl, keyscan_table_row3  
7b50 cd 91 7b			call .rowscan  
7b53			  
7b53			;ld a, 0  
7b53			;out (portbdata),a  
7b53 3e 40		ld a, 64  
7b55 d3 c1		out (portbdata),a  
7b57 3e 10			ld a, 16  
7b59 21 d1 fe			ld hl, keyscan_table_row4  
7b5c cd 91 7b			call .rowscan  
7b5f			  
7b5f			; Display text on first line  
7b5f 3e 00		            LD   A, kLCD_Line1  
7b61 cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b64 11 f2 fe		            LD   DE, keyscan_table_row1  
7b67			            ;LD   DE, MsgHello  
7b67 cd bb 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b6a			  
7b6a			; Display text on second line  
7b6a 3e 28		            LD   A, kLCD_Line2  
7b6c cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b6f 11 e7 fe		            LD   DE, keyscan_table_row2  
7b72 cd bb 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b75 3e 50		            LD   A, kLCD_Line3  
7b77 cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b7a 11 dc fe		            LD   DE, keyscan_table_row3  
7b7d cd bb 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b80 3e 78		            LD   A, kLCD_Line4  
7b82 cd 99 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b85 11 d1 fe		            LD   DE, keyscan_table_row4  
7b88 cd bb 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b8b			  
7b8b cd d3 0c			call delay250ms  
7b8e c3 7c 7a			jp matrix  
7b91			  
7b91			; pass de as row display flags  
7b91			.rowscan:   
7b91			;	out (portbdata),a  
7b91 db c1			in a,(portbdata)  
7b93 4f				ld c,a  
7b94				; reset flags for the row   
7b94 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b96 e6 01			and 1  
7b98 28 02			jr z, .p1on  
7b9a 06 23			ld b,'#'  
7b9c			.p1on:  
7b9c 70				ld (hl), b  
7b9d 23				inc hl  
7b9e			  
7b9e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ba0 79				ld a,c  
7ba1 e6 02			and 2  
7ba3			;	bit 0,a  
7ba3 28 02			jr z, .p2on  
7ba5 06 23			ld b,'#'  
7ba7			.p2on:  
7ba7 70				ld (hl), b  
7ba8 23				inc hl  
7ba9			;  
7ba9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bab 79				ld a,c  
7bac e6 04			and 4  
7bae			;;	bit 0,a  
7bae 28 02			jr z, .p3on  
7bb0 06 23			ld b,'#'  
7bb2			.p3on:  
7bb2 70				ld (hl), b  
7bb3 23				inc hl  
7bb4			;;  
7bb4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bb6			;;	bit 0,a  
7bb6 79				ld a,c  
7bb7 e6 08			and 8  
7bb9 28 02			jr z, .p4on  
7bbb 06 23			ld b,'#'  
7bbd			.p4on:  
7bbd 70				ld (hl), b  
7bbe 23				inc hl  
7bbf			  
7bbf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bc1			;;	bit 0,a  
7bc1 79				ld a,c  
7bc2 e6 10			and 16  
7bc4 28 02			jr z, .p5on  
7bc6 06 23			ld b,'#'  
7bc8			.p5on:  
7bc8 70				ld (hl), b  
7bc9 23				inc hl  
7bca			; zero term  
7bca 06 00			ld b,0  
7bcc 70				ld (hl), b  
7bcd			  
7bcd c9			.rscandone: ret  
7bce			  
7bce			;addatohl:  
7bce			;  
7bce			 ;add   a, l    ; A = A+L  
7bce			  ;  ld    l, a    ; L = A+L  
7bce			   ; adc   a, h    ; A = A+L+H+carry  
7bce			   ; sub   l       ; A = H+carry  
7bce			   ; ld    h, a    ; H = H+carry  
7bce			  
7bce			;ret  
7bce			; eof  
# End of file firmware_key_5x10.asm
7bce			;include "firmware_key_4x10.asm" 
7bce			 
7bce			heap_size:    equ heap_end - heap_start 
7bce			;eof 
# End of file os_mega.asm
7bce
