# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 71 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-06 15:40' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			  
801f			debug_umark: equ debug_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 0a ed				ld hl, display_fb1  
8022 22 c6 eb				ld (display_fb_active), hl  
8025			  
8025 cd bd 8a				call clear_display  
8028			  
8028 21 c8 eb				ld hl, display_fb2  
802b 22 c6 eb				ld (display_fb_active), hl  
802e			  
802e cd bd 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 ab ed				ld hl, display_fb0  
8034 22 c6 eb				ld (display_fb_active), hl  
8037			  
8037 cd bd 8a				call clear_display  
803a			  
803a			  
803a cd 07 e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd a9 e2			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd a1 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd e0 8a			call update_display  
8049 cd 00 8a			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd c2 8a			call fill_display  
8051 cd e0 8a			call update_display  
8054 cd 00 8a			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd c2 8a			call fill_display  
805c cd e0 8a			call update_display  
805f cd 00 8a			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd c2 8a			call fill_display  
8067 cd e0 8a			call update_display  
806a cd 00 8a			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 cf 95			ld de, prom_bootmsg  
8072 cd d0 8a			call str_at_display  
8075 cd e0 8a			call update_display  
8078			  
8078			  
8078 cd 00 8a			call delay1s  
807b cd 00 8a			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 e4 95			ld de, prom_bootmsg1  
8083 cd d0 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd d0 8a			call str_at_display  
808e			  
808e cd e0 8a			call update_display  
8091 cd 00 8a			call delay1s  
8094 cd 00 8a			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 65 ee		ld (debug_mark),a  
809c 32 66 ee		ld (debug_mark+1),a  
809f 32 67 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 68 ee		ld (debug_mark+3),a  
80a7 32 69 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 6d ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 65 ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 66 ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 67 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6f ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 38 82			call storage_get_block_0 
80d0			 
80d0 3a 74 ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 65 ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 66 ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 67 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6f ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 74 ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 65 ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 66 ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 67 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6f ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd e0 86				call storage_read 
8116 cd 13 8d				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 6d ea				ld hl, (store_tmp1) 
811e 11 77 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 65 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 66 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 67 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6f ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 88 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 65 ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 66 ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 67 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6f ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 65 ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 66 ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 67 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6f ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 65 ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 66 ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 67 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6f ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 65 ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 66 ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 67 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6f ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd ba 84			call storage_findnextid 
81db			 
81db cd 13 8d			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 74 ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 76 ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 65 ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 66 ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 67 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6f ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211 00				nop 
8212 00				nop 
8213 00				nop 
8214			;	if DEBUG_STORESE 
8214			;		push af 
8214			;		ld a, 'w' 
8214			;		ld (debug_mark),a 
8214			;		pop af 
8214			;		CALLMONITOR 
8214			;	endif 
8214 c1				pop bc 
8215 d1				pop de 
8216 e1				pop hl 
8217 23				inc hl 
8218 13				inc de 
8219			 
8219			 
8219 10 ef			djnz .wl1 
821b			 
821b				if DEBUG_STORESE 
821b					DMARK "SW2" 
821b f5				push af  
821c 3a 30 82			ld a, (.dmark)  
821f 32 65 ee			ld (debug_mark),a  
8222 3a 31 82			ld a, (.dmark+1)  
8225 32 66 ee			ld (debug_mark+1),a  
8228 3a 32 82			ld a, (.dmark+2)  
822b 32 67 ee			ld (debug_mark+2),a  
822e 18 03			jr .pastdmark  
8230 ..			.dmark: db "SW2"  
8233 f1			.pastdmark: pop af  
8234			endm  
# End of macro DMARK
8234			 
8234					;push af 
8234					;ld a, 'W' 
8234					;ld (debug_mark),a 
8234					;pop af 
8234					CALLMONITOR 
8234 cd 6f ee			call debug_vector  
8237				endm  
# End of macro CALLMONITOR
8237				endif 
8237 c9				ret	 
8238			 
8238			; Init bank 
8238			; --------- 
8238			; 
8238			; With current bank 
8238			; 
8238			; Setup block 0 config 
8238			;     Set 0 file id counter 
8238			;     Set formatted byte pattern 
8238			;     Zero out bank label 
8238			;      
8238			; For every logical block write 0-1 byte as null 
8238			 
8238			storage_get_block_0: 
8238			 
8238				; TODO check presence 
8238			 
8238				; get block 0 config 
8238			 
8238 21 00 00			ld hl, 0 
823b 11 74 ea			ld de, store_page 
823e cd 87 81			call storage_read_block 
8241			 
8241				if DEBUG_STORESE 
8241					DMARK "SB0" 
8241 f5				push af  
8242 3a 56 82			ld a, (.dmark)  
8245 32 65 ee			ld (debug_mark),a  
8248 3a 57 82			ld a, (.dmark+1)  
824b 32 66 ee			ld (debug_mark+1),a  
824e 3a 58 82			ld a, (.dmark+2)  
8251 32 67 ee			ld (debug_mark+2),a  
8254 18 03			jr .pastdmark  
8256 ..			.dmark: db "SB0"  
8259 f1			.pastdmark: pop af  
825a			endm  
# End of macro DMARK
825a 11 74 ea				ld de, store_page 
825d			;		push af 
825d			;		ld a, 'i' 
825d			;		ld (debug_mark),a 
825d			;		pop af 
825d					CALLMONITOR 
825d cd 6f ee			call debug_vector  
8260				endm  
# End of macro CALLMONITOR
8260				endif 
8260			 
8260				; is this area formatted? 
8260			 
8260			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8260 2a 75 ea			ld hl, (store_page+1) 
8263 3e 80			ld a,0x80 
8265 bd				cp l 
8266 20 22			jr nz, .ininotformatted 
8268				; do a double check 
8268 3e 27			ld a, 0x27 
826a bc				cp h 
826b 20 1d			jr nz, .ininotformatted 
826d			 
826d				; formatted then 
826d			 
826d				if DEBUG_STORESE 
826d					DMARK "SB1" 
826d f5				push af  
826e 3a 82 82			ld a, (.dmark)  
8271 32 65 ee			ld (debug_mark),a  
8274 3a 83 82			ld a, (.dmark+1)  
8277 32 66 ee			ld (debug_mark+1),a  
827a 3a 84 82			ld a, (.dmark+2)  
827d 32 67 ee			ld (debug_mark+2),a  
8280 18 03			jr .pastdmark  
8282 ..			.dmark: db "SB1"  
8285 f1			.pastdmark: pop af  
8286			endm  
# End of macro DMARK
8286					;push af 
8286					;ld a, 'I' 
8286					;ld (debug_mark),a 
8286					;pop af 
8286					CALLMONITOR 
8286 cd 6f ee			call debug_vector  
8289				endm  
# End of macro CALLMONITOR
8289				endif 
8289 c9				ret 
828a			 
828a			.ininotformatted: 
828a				; bank not formatted so poke various bits to make sure 
828a			 
828a				if DEBUG_STORESE 
828a					DMARK "SB2" 
828a f5				push af  
828b 3a 9f 82			ld a, (.dmark)  
828e 32 65 ee			ld (debug_mark),a  
8291 3a a0 82			ld a, (.dmark+1)  
8294 32 66 ee			ld (debug_mark+1),a  
8297 3a a1 82			ld a, (.dmark+2)  
829a 32 67 ee			ld (debug_mark+2),a  
829d 18 03			jr .pastdmark  
829f ..			.dmark: db "SB2"  
82a2 f1			.pastdmark: pop af  
82a3			endm  
# End of macro DMARK
82a3					;push af 
82a3					;ld a, 'f' 
82a3					;ld (debug_mark),a 
82a3					;pop af 
82a3					CALLMONITOR 
82a3 cd 6f ee			call debug_vector  
82a6				endm  
# End of macro CALLMONITOR
82a6				endif 
82a6			 
82a6 cd c3 89			call storage_clear_page 
82a9			 
82a9 21 74 ea			ld hl, store_page 
82ac 3e 00			ld a, 0 
82ae				 
82ae 77				ld (hl),a   ; reset file counter 
82af			 
82af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82b2 22 75 ea		 	ld (store_page+1), hl	 
82b5			 
82b5				; set default label 
82b5			 
82b5 21 51 83			ld hl, .defaultbanklabl 
82b8 11 77 ea		 	ld de, store_page+3 
82bb 01 0f 00			ld bc, 15 
82be ed b0			ldir 
82c0			 
82c0				; Append the current bank id 
82c0 21 80 ea			ld hl, store_page+3+9 
82c3 3a 59 ea			ld a, (spi_device_id) 
82c6 77				ld (hl), a 
82c7			 
82c7				; save default page 0 
82c7			 
82c7 21 00 00			ld hl, 0 
82ca 11 74 ea			ld de, store_page 
82cd				if DEBUG_STORESE 
82cd					DMARK "SB3" 
82cd f5				push af  
82ce 3a e2 82			ld a, (.dmark)  
82d1 32 65 ee			ld (debug_mark),a  
82d4 3a e3 82			ld a, (.dmark+1)  
82d7 32 66 ee			ld (debug_mark+1),a  
82da 3a e4 82			ld a, (.dmark+2)  
82dd 32 67 ee			ld (debug_mark+2),a  
82e0 18 03			jr .pastdmark  
82e2 ..			.dmark: db "SB3"  
82e5 f1			.pastdmark: pop af  
82e6			endm  
# End of macro DMARK
82e6			;		push af 
82e6			;		ld a, 'F' 
82e6			;		ld (debug_mark),a 
82e6			;		pop af 
82e6					CALLMONITOR 
82e6 cd 6f ee			call debug_vector  
82e9				endm  
# End of macro CALLMONITOR
82e9				endif 
82e9 cd ec 81			call storage_write_block 
82ec				if DEBUG_STORESE 
82ec					DMARK "SB4" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 65 ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 66 ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 67 ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "SB4"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305			;		push af 
8305			;		ld a, '>' 
8305			;		ld (debug_mark),a 
8305			;		pop af 
8305					CALLMONITOR 
8305 cd 6f ee			call debug_vector  
8308				endm  
# End of macro CALLMONITOR
8308				endif 
8308			 
8308 00				nop 
8309 00				nop 
830a 00				nop 
830b			 
830b				; now set 0 in every page to mark as a free block 
830b			 
830b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830d 21 40 00			ld hl, STORE_BLOCK_PHY 
8310			 
8310 3e 00		.setmark1:   	ld a,0 
8312 e5					push hl 
8313 c5					push bc 
8314 cd ac 80				call se_writebyte 
8317 3e 0a			ld a, 10 
8319 cd e5 89			call aDelayInMS 
831c 23				inc hl 
831d cd ac 80				call se_writebyte 
8320 3e 0a			ld a, 10 
8322 cd e5 89			call aDelayInMS 
8325 2b				dec hl 
8326 c1					pop bc 
8327 e1					pop hl 
8328 3e 40				ld a, STORE_BLOCK_PHY 
832a cd ea 8c				call addatohl 
832d 10 e1				djnz .setmark1 
832f			 
832f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8331 3e 00		.setmark2:   	ld a,0 
8333 e5					push hl 
8334 c5					push bc 
8335 cd ac 80				call se_writebyte 
8338 3e 0a			ld a, 10 
833a cd e5 89			call aDelayInMS 
833d 23				inc hl 
833e cd ac 80				call se_writebyte 
8341 3e 0a			ld a, 10 
8343 cd e5 89			call aDelayInMS 
8346 2b				dec hl 
8347 c1					pop bc 
8348 e1					pop hl 
8349 3e 40				ld a, STORE_BLOCK_PHY 
834b cd ea 8c				call addatohl 
834e 10 e1				djnz .setmark2 
8350			 
8350					 
8350			 
8350			 
8350 c9				ret 
8351			 
8351			 
8351			 
8351			 
8351 .. 00		.defaultbanklabl:   db "BankLabel_",0 
835c			 
835c			 
835c			 
835c			; Label Bank 
835c			; ---------- 
835c			; 
835c			; With current bank 
835c			; Read block 0 
835c			; Set label 
835c			; Write block 0 
835c			 
835c			; label str pointer in hl 
835c			 
835c			storage_label:     
835c			 
835c				if DEBUG_STORESE 
835c					DMARK "LBL" 
835c f5				push af  
835d 3a 71 83			ld a, (.dmark)  
8360 32 65 ee			ld (debug_mark),a  
8363 3a 72 83			ld a, (.dmark+1)  
8366 32 66 ee			ld (debug_mark+1),a  
8369 3a 73 83			ld a, (.dmark+2)  
836c 32 67 ee			ld (debug_mark+2),a  
836f 18 03			jr .pastdmark  
8371 ..			.dmark: db "LBL"  
8374 f1			.pastdmark: pop af  
8375			endm  
# End of macro DMARK
8375					CALLMONITOR 
8375 cd 6f ee			call debug_vector  
8378				endm  
# End of macro CALLMONITOR
8378				endif 
8378			 
8378 e5				push hl 
8379			 
8379 cd 38 82			call storage_get_block_0 
837c			 
837c				; set default label 
837c			 
837c e1				pop hl 
837d			 
837d 11 77 ea		 	ld de, store_page+3 
8380 01 0f 00			ld bc, 15 
8383				if DEBUG_STORESE 
8383					DMARK "LB3" 
8383 f5				push af  
8384 3a 98 83			ld a, (.dmark)  
8387 32 65 ee			ld (debug_mark),a  
838a 3a 99 83			ld a, (.dmark+1)  
838d 32 66 ee			ld (debug_mark+1),a  
8390 3a 9a 83			ld a, (.dmark+2)  
8393 32 67 ee			ld (debug_mark+2),a  
8396 18 03			jr .pastdmark  
8398 ..			.dmark: db "LB3"  
839b f1			.pastdmark: pop af  
839c			endm  
# End of macro DMARK
839c					CALLMONITOR 
839c cd 6f ee			call debug_vector  
839f				endm  
# End of macro CALLMONITOR
839f				endif 
839f ed b0			ldir 
83a1				; save default page 0 
83a1			 
83a1 21 00 00			ld hl, 0 
83a4 11 74 ea			ld de, store_page 
83a7				if DEBUG_STORESE 
83a7					DMARK "LBW" 
83a7 f5				push af  
83a8 3a bc 83			ld a, (.dmark)  
83ab 32 65 ee			ld (debug_mark),a  
83ae 3a bd 83			ld a, (.dmark+1)  
83b1 32 66 ee			ld (debug_mark+1),a  
83b4 3a be 83			ld a, (.dmark+2)  
83b7 32 67 ee			ld (debug_mark+2),a  
83ba 18 03			jr .pastdmark  
83bc ..			.dmark: db "LBW"  
83bf f1			.pastdmark: pop af  
83c0			endm  
# End of macro DMARK
83c0					CALLMONITOR 
83c0 cd 6f ee			call debug_vector  
83c3				endm  
# End of macro CALLMONITOR
83c3				endif 
83c3 cd ec 81			call storage_write_block 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			 
83c7			; Read Block 0 - Config 
83c7			; --------------------- 
83c7			; 
83c7			; With current bank 
83c7			; Call presence test 
83c7			;    If not present format/init bank  
83c7			; Read block 0  
83c7			;  
83c7			 
83c7			 
83c7			; Dir 
83c7			; --- 
83c7			; 
83c7			; With current bank 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block read byte 2 
83c7			;      if first block of file 
83c7			;         Display file name 
83c7			;         Display type flags for file 
83c7			;        
83c7			 
83c7			; moving to words as this requires stack control 
83c7			 
83c7			 
83c7			; Delete File 
83c7			; ----------- 
83c7			; 
83c7			; With current bank 
83c7			; 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block file id 
83c7			;      If first block of file and dont have file id 
83c7			;         if file to delete 
83c7			;         Save file id 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			;      If file id is one saved 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			 
83c7			 
83c7			.se_done: 
83c7 e1				pop hl 
83c8 c9				ret 
83c9			 
83c9			storage_erase: 
83c9			 
83c9				; hl contains the file id 
83c9			 
83c9 5d				ld e, l 
83ca 16 00			ld d, 0 
83cc 21 40 00			ld hl, STORE_BLOCK_PHY 
83cf					if DEBUG_FORTH_WORDS 
83cf						DMARK "ERA" 
83cf f5				push af  
83d0 3a e4 83			ld a, (.dmark)  
83d3 32 65 ee			ld (debug_mark),a  
83d6 3a e5 83			ld a, (.dmark+1)  
83d9 32 66 ee			ld (debug_mark+1),a  
83dc 3a e6 83			ld a, (.dmark+2)  
83df 32 67 ee			ld (debug_mark+2),a  
83e2 18 03			jr .pastdmark  
83e4 ..			.dmark: db "ERA"  
83e7 f1			.pastdmark: pop af  
83e8			endm  
# End of macro DMARK
83e8						CALLMONITOR 
83e8 cd 6f ee			call debug_vector  
83eb				endm  
# End of macro CALLMONITOR
83eb					endif 
83eb cd ba 84			call storage_findnextid 
83ee cd 13 8d			call ishlzero 
83f1 c8				ret z 
83f2			 
83f2 e5				push hl 
83f3			 
83f3				; TODO check file not found 
83f3			 
83f3 11 74 ea			ld de, store_page 
83f6 cd 87 81			call storage_read_block 
83f9			 
83f9 cd 13 8d			call ishlzero 
83fc ca c7 83			jp z,.se_done 
83ff			 
83ff					if DEBUG_FORTH_WORDS 
83ff						DMARK "ER1" 
83ff f5				push af  
8400 3a 14 84			ld a, (.dmark)  
8403 32 65 ee			ld (debug_mark),a  
8406 3a 15 84			ld a, (.dmark+1)  
8409 32 66 ee			ld (debug_mark+1),a  
840c 3a 16 84			ld a, (.dmark+2)  
840f 32 67 ee			ld (debug_mark+2),a  
8412 18 03			jr .pastdmark  
8414 ..			.dmark: db "ER1"  
8417 f1			.pastdmark: pop af  
8418			endm  
# End of macro DMARK
8418						CALLMONITOR 
8418 cd 6f ee			call debug_vector  
841b				endm  
# End of macro CALLMONITOR
841b					endif 
841b 3a 74 ea			ld a, (store_page)	; get file id 
841e 32 68 ea			ld (store_tmpid), a 
8421			 
8421 3a 76 ea			ld a, (store_page+2)    ; get count of extends 
8424 32 67 ea			ld (store_tmpext), a 
8427			 
8427				; wipe file header 
8427			 
8427 e1				pop hl 
8428 3e 00			ld a, 0 
842a 32 74 ea			ld (store_page), a 
842d 32 75 ea			ld (store_page+1),a 
8430 11 74 ea			ld de, store_page 
8433					if DEBUG_FORTH_WORDS 
8433						DMARK "ER2" 
8433 f5				push af  
8434 3a 48 84			ld a, (.dmark)  
8437 32 65 ee			ld (debug_mark),a  
843a 3a 49 84			ld a, (.dmark+1)  
843d 32 66 ee			ld (debug_mark+1),a  
8440 3a 4a 84			ld a, (.dmark+2)  
8443 32 67 ee			ld (debug_mark+2),a  
8446 18 03			jr .pastdmark  
8448 ..			.dmark: db "ER2"  
844b f1			.pastdmark: pop af  
844c			endm  
# End of macro DMARK
844c						CALLMONITOR 
844c cd 6f ee			call debug_vector  
844f				endm  
# End of macro CALLMONITOR
844f					endif 
844f cd ec 81			call storage_write_block 
8452			 
8452			 
8452				; wipe file extents 
8452			 
8452 3a 67 ea			ld a, (store_tmpext) 
8455 47				ld b, a 
8456			 
8456			.eraext:	  
8456 c5				push bc 
8457			 
8457 21 40 00			ld hl, STORE_BLOCK_PHY 
845a 3a 68 ea			ld a,(store_tmpid) 
845d 5f				ld e, a 
845e 50				ld d, b	 
845f					if DEBUG_FORTH_WORDS 
845f						DMARK "ER3" 
845f f5				push af  
8460 3a 74 84			ld a, (.dmark)  
8463 32 65 ee			ld (debug_mark),a  
8466 3a 75 84			ld a, (.dmark+1)  
8469 32 66 ee			ld (debug_mark+1),a  
846c 3a 76 84			ld a, (.dmark+2)  
846f 32 67 ee			ld (debug_mark+2),a  
8472 18 03			jr .pastdmark  
8474 ..			.dmark: db "ER3"  
8477 f1			.pastdmark: pop af  
8478			endm  
# End of macro DMARK
8478						CALLMONITOR 
8478 cd 6f ee			call debug_vector  
847b				endm  
# End of macro CALLMONITOR
847b					endif 
847b cd ba 84			call storage_findnextid 
847e cd 13 8d			call ishlzero 
8481 ca c7 83			jp z,.se_done 
8484			 
8484 e5				push hl 
8485 11 74 ea			ld de, store_page 
8488 cd 87 81			call storage_read_block 
848b			 
848b				; free block	 
848b			 
848b 3e 00			ld a, 0 
848d 32 74 ea			ld (store_page), a 
8490 32 75 ea			ld (store_page+1),a 
8493 11 74 ea			ld de, store_page 
8496 e1				pop hl 
8497					if DEBUG_FORTH_WORDS 
8497						DMARK "ER4" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 65 ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 66 ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 67 ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "ER4"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0						CALLMONITOR 
84b0 cd 6f ee			call debug_vector  
84b3				endm  
# End of macro CALLMONITOR
84b3					endif 
84b3 cd ec 81			call storage_write_block 
84b6			 
84b6 c1				pop bc 
84b7 10 9d			djnz .eraext 
84b9			 
84b9 c9				ret 
84ba			 
84ba			 
84ba			; Find Free Block 
84ba			; --------------- 
84ba			; 
84ba			; With current bank 
84ba			;  
84ba			; From given starting logical block 
84ba			;    Read block  
84ba			;    If no file id 
84ba			;         Return block id 
84ba			 
84ba			 
84ba			; hl starting page number 
84ba			; hl contains free page number or zero if no pages free 
84ba			; e contains the file id to locate 
84ba			; d contains the block number 
84ba			 
84ba			; TODO change to find file id and use zero for free block 
84ba			 
84ba			storage_findnextid: 
84ba			 
84ba				; now locate first 0 page to mark as a free block 
84ba			 
84ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84bc			;	ld hl, STORE_BLOCK_PHY 
84bc			 
84bc					if DEBUG_FORTH_WORDS 
84bc					DMARK "FNI" 
84bc f5				push af  
84bd 3a d1 84			ld a, (.dmark)  
84c0 32 65 ee			ld (debug_mark),a  
84c3 3a d2 84			ld a, (.dmark+1)  
84c6 32 66 ee			ld (debug_mark+1),a  
84c9 3a d3 84			ld a, (.dmark+2)  
84cc 32 67 ee			ld (debug_mark+2),a  
84cf 18 03			jr .pastdmark  
84d1 ..			.dmark: db "FNI"  
84d4 f1			.pastdmark: pop af  
84d5			endm  
# End of macro DMARK
84d5						CALLMONITOR 
84d5 cd 6f ee			call debug_vector  
84d8				endm  
# End of macro CALLMONITOR
84d8					endif 
84d8			.ff1:   	 
84d8 e5					push hl 
84d9 c5					push bc 
84da d5					push de 
84db cd ab 80				call se_readbyte 
84de 5f					ld e,a 
84df 23					inc hl 
84e0 cd ab 80				call se_readbyte 
84e3 57					ld d, a 
84e4 e1					pop hl 
84e5 e5					push hl 
84e6 cd 08 8d				call cmp16 
84e9 28 49				jr z, .fffound 
84eb			 
84eb d1					pop de 
84ec c1					pop bc 
84ed e1					pop hl 
84ee			 
84ee					; is found? 
84ee					;cp e 
84ee					;ret z 
84ee			 
84ee 3e 40				ld a, STORE_BLOCK_PHY 
84f0 cd ea 8c				call addatohl 
84f3 10 e3				djnz .ff1 
84f5			 
84f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f7			.ff2:   	 
84f7			 
84f7 e5					push hl 
84f8 c5					push bc 
84f9 d5					push de 
84fa cd ab 80				call se_readbyte 
84fd 5f					ld e,a 
84fe 23					inc hl 
84ff cd ab 80				call se_readbyte 
8502 57					ld d, a 
8503			 
8503 e1					pop hl 
8504 e5					push hl 
8505 cd 08 8d				call cmp16 
8508 28 2a				jr z, .fffound 
850a			 
850a d1					pop de 
850b c1					pop bc 
850c e1					pop hl 
850d					; is found? 
850d					;cp e 
850d					;ret z 
850d			 
850d 3e 40				ld a, STORE_BLOCK_PHY 
850f cd ea 8c				call addatohl 
8512 10 e3				djnz .ff2 
8514			 
8514			 
8514					if DEBUG_FORTH_WORDS 
8514					DMARK "FN-" 
8514 f5				push af  
8515 3a 29 85			ld a, (.dmark)  
8518 32 65 ee			ld (debug_mark),a  
851b 3a 2a 85			ld a, (.dmark+1)  
851e 32 66 ee			ld (debug_mark+1),a  
8521 3a 2b 85			ld a, (.dmark+2)  
8524 32 67 ee			ld (debug_mark+2),a  
8527 18 03			jr .pastdmark  
8529 ..			.dmark: db "FN-"  
852c f1			.pastdmark: pop af  
852d			endm  
# End of macro DMARK
852d					;	push af 
852d					;	ld a, 'n' 
852d					;	ld (debug_mark),a 
852d					;	pop af 
852d						CALLMONITOR 
852d cd 6f ee			call debug_vector  
8530				endm  
# End of macro CALLMONITOR
8530					endif 
8530				; no free marks! 
8530 21 00 00				ld hl, 0 
8533 c9				ret 
8534			.fffound: 
8534				 
8534			 
8534 d1					pop de 
8535 c1					pop bc 
8536 e1					pop hl 
8537					if DEBUG_FORTH_WORDS 
8537					DMARK "FNF" 
8537 f5				push af  
8538 3a 4c 85			ld a, (.dmark)  
853b 32 65 ee			ld (debug_mark),a  
853e 3a 4d 85			ld a, (.dmark+1)  
8541 32 66 ee			ld (debug_mark+1),a  
8544 3a 4e 85			ld a, (.dmark+2)  
8547 32 67 ee			ld (debug_mark+2),a  
854a 18 03			jr .pastdmark  
854c ..			.dmark: db "FNF"  
854f f1			.pastdmark: pop af  
8550			endm  
# End of macro DMARK
8550					;	push af 
8550					;	ld a, 'n' 
8550					;	ld (debug_mark),a 
8550					;	pop af 
8550						CALLMONITOR 
8550 cd 6f ee			call debug_vector  
8553				endm  
# End of macro CALLMONITOR
8553					endif 
8553 c9				ret 
8554			 
8554			 
8554			 
8554			; Free Space 
8554			; ---------- 
8554			; 
8554			; With current bank 
8554			; 
8554			; Set block count to zero 
8554			; Starting with first logical block 
8554			;      Find free block  
8554			;      If block id given, increment block count 
8554			; 
8554			;  
8554			 
8554			 
8554			; hl contains count of free blocks 
8554			 
8554			storage_freeblocks: 
8554			 
8554				; now locate first 0 page to mark as a free block 
8554			 
8554 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8556 21 40 00			ld hl, STORE_BLOCK_PHY 
8559 11 00 00			ld de, 0 
855c			 
855c			.fb1:   	 
855c e5					push hl 
855d c5					push bc 
855e d5					push de 
855f cd ab 80				call se_readbyte 
8562 d1					pop de 
8563 c1					pop bc 
8564 e1					pop hl 
8565			 
8565					; is free? 
8565 fe 00				cp 0 
8567 20 01				jr nz, .ff1cont 
8569 13					inc de 
856a			 
856a			.ff1cont: 
856a			 
856a			 
856a 3e 40				ld a, STORE_BLOCK_PHY 
856c cd ea 8c				call addatohl 
856f 10 eb				djnz .fb1 
8571			 
8571 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8573			.fb2:   	 
8573 e5					push hl 
8574 c5					push bc 
8575 d5					push de 
8576 cd ab 80				call se_readbyte 
8579 d1					pop de 
857a c1					pop bc 
857b e1					pop hl 
857c			 
857c					; is free? 
857c fe 00				cp 0 
857e 20 01				jr nz, .ff2cont 
8580 13					inc de 
8581			 
8581			.ff2cont: 
8581			 
8581 3e 40				ld a, STORE_BLOCK_PHY 
8583 cd ea 8c				call addatohl 
8586 10 eb				djnz .fb2 
8588			 
8588 eb				ex de, hl 
8589 c9				ret 
858a			 
858a			; Get File ID 
858a			; ----------- 
858a			; 
858a			; With current bank 
858a			;  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; For each logical block 
858a			;    Read block file id 
858a			;      If first block of file and dont have file id 
858a			;         if file get id and exit 
858a			 
858a			 
858a			 
858a			 
858a			; Create File 
858a			; ----------- 
858a			; 
858a			; With current bank  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; Increment file id number 
858a			; Save Config 
858a			; Find free block 
858a			; Set buffer with file name and file id 
858a			; Write buffer to free block  
858a			 
858a			 
858a			; hl point to file name 
858a			; hl returns file id 
858a			 
858a			; file format: 
858a			; byte 0 - file id 
858a			; byte 1 - extent number 
858a			; byte 2-> data 
858a			 
858a			; format for extent number 0: 
858a			; 
858a			; byte 0 - file id 
858a			; byte 1 - extent 0 
858a			; byte 2 - extent count 
858a			; byte 3 -> file name and meta data 
858a			 
858a			 
858a			storage_create: 
858a				if DEBUG_STORESE 
858a					DMARK "SCR" 
858a f5				push af  
858b 3a 9f 85			ld a, (.dmark)  
858e 32 65 ee			ld (debug_mark),a  
8591 3a a0 85			ld a, (.dmark+1)  
8594 32 66 ee			ld (debug_mark+1),a  
8597 3a a1 85			ld a, (.dmark+2)  
859a 32 67 ee			ld (debug_mark+2),a  
859d 18 03			jr .pastdmark  
859f ..			.dmark: db "SCR"  
85a2 f1			.pastdmark: pop af  
85a3			endm  
# End of macro DMARK
85a3					CALLMONITOR 
85a3 cd 6f ee			call debug_vector  
85a6				endm  
# End of macro CALLMONITOR
85a6				endif 
85a6			 
85a6 e5				push hl		; save file name pointer 
85a7			 
85a7 cd 38 82			call storage_get_block_0 
85aa			 
85aa 3a 74 ea			ld a,(store_page)	; get current file id 
85ad 3c				inc a 
85ae 32 74 ea			ld (store_page),a 
85b1				 
85b1 32 68 ea			ld (store_tmpid),a			; save id 
85b4			 
85b4 21 00 00			ld hl, 0 
85b7 11 74 ea			ld de, store_page 
85ba				if DEBUG_STORESE 
85ba					DMARK "SCw" 
85ba f5				push af  
85bb 3a cf 85			ld a, (.dmark)  
85be 32 65 ee			ld (debug_mark),a  
85c1 3a d0 85			ld a, (.dmark+1)  
85c4 32 66 ee			ld (debug_mark+1),a  
85c7 3a d1 85			ld a, (.dmark+2)  
85ca 32 67 ee			ld (debug_mark+2),a  
85cd 18 03			jr .pastdmark  
85cf ..			.dmark: db "SCw"  
85d2 f1			.pastdmark: pop af  
85d3			endm  
# End of macro DMARK
85d3					CALLMONITOR 
85d3 cd 6f ee			call debug_vector  
85d6				endm  
# End of macro CALLMONITOR
85d6				endif 
85d6 cd ec 81			call storage_write_block	 ; save update 
85d9			 
85d9				if DEBUG_STORESE 
85d9 11 74 ea				ld de, store_page 
85dc					DMARK "SCC" 
85dc f5				push af  
85dd 3a f1 85			ld a, (.dmark)  
85e0 32 65 ee			ld (debug_mark),a  
85e3 3a f2 85			ld a, (.dmark+1)  
85e6 32 66 ee			ld (debug_mark+1),a  
85e9 3a f3 85			ld a, (.dmark+2)  
85ec 32 67 ee			ld (debug_mark+2),a  
85ef 18 03			jr .pastdmark  
85f1 ..			.dmark: db "SCC"  
85f4 f1			.pastdmark: pop af  
85f5			endm  
# End of macro DMARK
85f5					CALLMONITOR 
85f5 cd 6f ee			call debug_vector  
85f8				endm  
# End of macro CALLMONITOR
85f8				endif 
85f8				;  
85f8				 
85f8 21 40 00			ld hl, STORE_BLOCK_PHY 
85fb 11 00 00			ld de, 0 
85fe cd ba 84			call storage_findnextid 
8601			 
8601 22 5f ea			ld (store_tmppageid), hl    ; save page to use  
8604			 
8604				; TODO detect 0 = no spare blocks 
8604			 
8604				; hl now contains the free page to use for the file header page 
8604			 
8604				if DEBUG_STORESE 
8604				DMARK "SCF" 
8604 f5				push af  
8605 3a 19 86			ld a, (.dmark)  
8608 32 65 ee			ld (debug_mark),a  
860b 3a 1a 86			ld a, (.dmark+1)  
860e 32 66 ee			ld (debug_mark+1),a  
8611 3a 1b 86			ld a, (.dmark+2)  
8614 32 67 ee			ld (debug_mark+2),a  
8617 18 03			jr .pastdmark  
8619 ..			.dmark: db "SCF"  
861c f1			.pastdmark: pop af  
861d			endm  
# End of macro DMARK
861d					CALLMONITOR 
861d cd 6f ee			call debug_vector  
8620				endm  
# End of macro CALLMONITOR
8620				endif 
8620			 
8620 22 5f ea			ld (store_tmppageid), hl 
8623				 
8623 3a 68 ea			ld a,(store_tmpid)    ; get file id 
8626			;	ld a, (store_filecache)			; save to cache 
8626			 
8626 32 74 ea			ld (store_page),a    ; set page id 
8629 3e 00			ld a, 0			 ; extent 0 is file header 
862b 32 75 ea			ld (store_page+1), a   ; set file extent 
862e			 
862e 32 76 ea			ld (store_page+2), a   ; extent count for the file 
8631			 
8631			;	inc hl 		; init block 0 of file 
8631			;	inc hl   		; skip file and extent id 
8631			 ;       ld a, 0 
8631			;	ld (hl),a 
8631			;	ld a, (store_filecache+1)  	; save to cache 
8631			 
8631			;	inc hl    ; file name 
8631				 
8631				 
8631 11 77 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8634				if DEBUG_STORESE 
8634					DMARK "SCc" 
8634 f5				push af  
8635 3a 49 86			ld a, (.dmark)  
8638 32 65 ee			ld (debug_mark),a  
863b 3a 4a 86			ld a, (.dmark+1)  
863e 32 66 ee			ld (debug_mark+1),a  
8641 3a 4b 86			ld a, (.dmark+2)  
8644 32 67 ee			ld (debug_mark+2),a  
8647 18 03			jr .pastdmark  
8649 ..			.dmark: db "SCc"  
864c f1			.pastdmark: pop af  
864d			endm  
# End of macro DMARK
864d					CALLMONITOR 
864d cd 6f ee			call debug_vector  
8650				endm  
# End of macro CALLMONITOR
8650				endif 
8650 e1				pop hl    ; get zero term string 
8651 e5				push hl 
8652 3e 00			ld a, 0 
8654 cd 5b 90			call strlent 
8657 23				inc hl   ; cover zero term 
8658 06 00			ld b,0 
865a 4d				ld c,l 
865b e1				pop hl 
865c				;ex de, hl 
865c				if DEBUG_STORESE 
865c					DMARK "SCa" 
865c f5				push af  
865d 3a 71 86			ld a, (.dmark)  
8660 32 65 ee			ld (debug_mark),a  
8663 3a 72 86			ld a, (.dmark+1)  
8666 32 66 ee			ld (debug_mark+1),a  
8669 3a 73 86			ld a, (.dmark+2)  
866c 32 67 ee			ld (debug_mark+2),a  
866f 18 03			jr .pastdmark  
8671 ..			.dmark: db "SCa"  
8674 f1			.pastdmark: pop af  
8675			endm  
# End of macro DMARK
8675					;push af 
8675					;ld a, 'a' 
8675					;ld (debug_mark),a 
8675					;pop af 
8675					CALLMONITOR 
8675 cd 6f ee			call debug_vector  
8678				endm  
# End of macro CALLMONITOR
8678				endif 
8678 ed b0			ldir    ; copy zero term string 
867a				if DEBUG_STORESE 
867a					DMARK "SCA" 
867a f5				push af  
867b 3a 8f 86			ld a, (.dmark)  
867e 32 65 ee			ld (debug_mark),a  
8681 3a 90 86			ld a, (.dmark+1)  
8684 32 66 ee			ld (debug_mark+1),a  
8687 3a 91 86			ld a, (.dmark+2)  
868a 32 67 ee			ld (debug_mark+2),a  
868d 18 03			jr .pastdmark  
868f ..			.dmark: db "SCA"  
8692 f1			.pastdmark: pop af  
8693			endm  
# End of macro DMARK
8693					CALLMONITOR 
8693 cd 6f ee			call debug_vector  
8696				endm  
# End of macro CALLMONITOR
8696				endif 
8696			 
8696				; write file header page 
8696			 
8696 2a 5f ea			ld hl,(store_tmppageid) 
8699 11 74 ea			ld de, store_page 
869c				if DEBUG_STORESE 
869c					DMARK "SCb" 
869c f5				push af  
869d 3a b1 86			ld a, (.dmark)  
86a0 32 65 ee			ld (debug_mark),a  
86a3 3a b2 86			ld a, (.dmark+1)  
86a6 32 66 ee			ld (debug_mark+1),a  
86a9 3a b3 86			ld a, (.dmark+2)  
86ac 32 67 ee			ld (debug_mark+2),a  
86af 18 03			jr .pastdmark  
86b1 ..			.dmark: db "SCb"  
86b4 f1			.pastdmark: pop af  
86b5			endm  
# End of macro DMARK
86b5					;push af 
86b5					;ld a, 'b' 
86b5					;ld (debug_mark),a 
86b5					;pop af 
86b5					CALLMONITOR 
86b5 cd 6f ee			call debug_vector  
86b8				endm  
# End of macro CALLMONITOR
86b8				endif 
86b8 cd ec 81			call storage_write_block 
86bb			 
86bb 3a 68 ea			ld a, (store_tmpid) 
86be 6f				ld l, a 
86bf 26 00			ld h,0 
86c1				if DEBUG_STORESE 
86c1					DMARK "SCz" 
86c1 f5				push af  
86c2 3a d6 86			ld a, (.dmark)  
86c5 32 65 ee			ld (debug_mark),a  
86c8 3a d7 86			ld a, (.dmark+1)  
86cb 32 66 ee			ld (debug_mark+1),a  
86ce 3a d8 86			ld a, (.dmark+2)  
86d1 32 67 ee			ld (debug_mark+2),a  
86d4 18 03			jr .pastdmark  
86d6 ..			.dmark: db "SCz"  
86d9 f1			.pastdmark: pop af  
86da			endm  
# End of macro DMARK
86da					CALLMONITOR 
86da cd 6f ee			call debug_vector  
86dd				endm  
# End of macro CALLMONITOR
86dd				endif 
86dd c9				ret 
86de				 
86de			 
86de			 
86de			; 
86de			; Read File 
86de			; 
86de			; h - file id to locate 
86de			; l - extent to locate 
86de			; de - pointer to string to read into 
86de			; 
86de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86de			 
86de			.sr_fail: 
86de d1				pop de 
86df c9				ret 
86e0			 
86e0			storage_read: 
86e0			 
86e0			 
86e0 d5				push de 
86e1			 
86e1			; TODO BUG the above push is it popped before the RET Z? 
86e1			 
86e1			; TODO how to handle multiple part blocks 
86e1			 
86e1				; locate file extent to read 
86e1			 
86e1 5c				ld e, h 
86e2 55				ld d, l 
86e3			 
86e3			.srext: 
86e3 22 72 ea			ld (store_readptr), hl     ; save the current extent to load 
86e6 ed 53 70 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86ea			 
86ea 21 40 00			ld hl, STORE_BLOCK_PHY 
86ed				if DEBUG_STORESE 
86ed					DMARK "sre" 
86ed f5				push af  
86ee 3a 02 87			ld a, (.dmark)  
86f1 32 65 ee			ld (debug_mark),a  
86f4 3a 03 87			ld a, (.dmark+1)  
86f7 32 66 ee			ld (debug_mark+1),a  
86fa 3a 04 87			ld a, (.dmark+2)  
86fd 32 67 ee			ld (debug_mark+2),a  
8700 18 03			jr .pastdmark  
8702 ..			.dmark: db "sre"  
8705 f1			.pastdmark: pop af  
8706			endm  
# End of macro DMARK
8706					CALLMONITOR 
8706 cd 6f ee			call debug_vector  
8709				endm  
# End of macro CALLMONITOR
8709				endif 
8709 cd ba 84			call storage_findnextid 
870c			 
870c				if DEBUG_STORESE 
870c					DMARK "srf" 
870c f5				push af  
870d 3a 21 87			ld a, (.dmark)  
8710 32 65 ee			ld (debug_mark),a  
8713 3a 22 87			ld a, (.dmark+1)  
8716 32 66 ee			ld (debug_mark+1),a  
8719 3a 23 87			ld a, (.dmark+2)  
871c 32 67 ee			ld (debug_mark+2),a  
871f 18 03			jr .pastdmark  
8721 ..			.dmark: db "srf"  
8724 f1			.pastdmark: pop af  
8725			endm  
# End of macro DMARK
8725					CALLMONITOR 
8725 cd 6f ee			call debug_vector  
8728				endm  
# End of macro CALLMONITOR
8728				endif 
8728 cd 13 8d			call ishlzero 
872b			;	ld a, l 
872b			;	add h 
872b			;	cp 0 
872b 28 b1			jr z,.sr_fail			; block not found so EOF 
872d			 
872d				; save current address for use by higher level words etc 
872d			 
872d 22 65 ea			ld (store_openaddr),hl 
8730			 
8730			 
8730				; hl contains page number to load 
8730 d1				pop de   ; get storage 
8731 ed 53 70 ea		ld (store_readbuf), de     ; current buffer to load in to 
8735 d5				push de 
8736				if DEBUG_STORESE 
8736					DMARK "srg" 
8736 f5				push af  
8737 3a 4b 87			ld a, (.dmark)  
873a 32 65 ee			ld (debug_mark),a  
873d 3a 4c 87			ld a, (.dmark+1)  
8740 32 66 ee			ld (debug_mark+1),a  
8743 3a 4d 87			ld a, (.dmark+2)  
8746 32 67 ee			ld (debug_mark+2),a  
8749 18 03			jr .pastdmark  
874b ..			.dmark: db "srg"  
874e f1			.pastdmark: pop af  
874f			endm  
# End of macro DMARK
874f					CALLMONITOR 
874f cd 6f ee			call debug_vector  
8752				endm  
# End of macro CALLMONITOR
8752				endif 
8752 cd 87 81			call storage_read_block 
8755			 
8755				; if this a continuation read??? 
8755			 
8755 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8758			 
8758 3e 3f			ld a, STORE_BLOCK_PHY-1 
875a cd ea 8c			call addatohl 
875d 7e				ld a,(hl) 
875e fe 00			cp 0 
8760 28 02			jr z, .markiscont 
8762 3e ff			ld a, 255 
8764			 
8764			.markiscont: 
8764 32 67 ea			ld (store_readcont), a 
8767			 
8767				if DEBUG_STORESE 
8767					DMARK "srC" 
8767 f5				push af  
8768 3a 7c 87			ld a, (.dmark)  
876b 32 65 ee			ld (debug_mark),a  
876e 3a 7d 87			ld a, (.dmark+1)  
8771 32 66 ee			ld (debug_mark+1),a  
8774 3a 7e 87			ld a, (.dmark+2)  
8777 32 67 ee			ld (debug_mark+2),a  
877a 18 03			jr .pastdmark  
877c ..			.dmark: db "srC"  
877f f1			.pastdmark: pop af  
8780			endm  
# End of macro DMARK
8780					CALLMONITOR 
8780 cd 6f ee			call debug_vector  
8783				endm  
# End of macro CALLMONITOR
8783				endif 
8783				; only short reads enabled 
8783			 
8783 3a 6f ea			ld a, (store_longread) 
8786 fe 00			cp 0 
8788 ca 55 88			jp z, .readdone 
878b			 
878b			; TODO if block has no zeros then need to read next block  
878b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
878b			; check last byte of physical block. 
878b			; if not zero then the next block needs to be loaded 
878b			 
878b			 
878b 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
878e			 
878e 3e 3f			ld a, STORE_BLOCK_PHY-1 
8790 cd ea 8c			call addatohl 
8793				;dec hl 
8793 7e				ld a,(hl) 
8794				if DEBUG_STORESE 
8794					DMARK "sr?" 
8794 f5				push af  
8795 3a a9 87			ld a, (.dmark)  
8798 32 65 ee			ld (debug_mark),a  
879b 3a aa 87			ld a, (.dmark+1)  
879e 32 66 ee			ld (debug_mark+1),a  
87a1 3a ab 87			ld a, (.dmark+2)  
87a4 32 67 ee			ld (debug_mark+2),a  
87a7 18 03			jr .pastdmark  
87a9 ..			.dmark: db "sr?"  
87ac f1			.pastdmark: pop af  
87ad			endm  
# End of macro DMARK
87ad					CALLMONITOR 
87ad cd 6f ee			call debug_vector  
87b0				endm  
# End of macro CALLMONITOR
87b0				endif 
87b0 fe 00			cp 0 
87b2 ca 55 88			jp z, .readdone 
87b5			 
87b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87b5			 
87b5 23				inc hl 
87b6			 
87b6 22 70 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87b9			 
87b9 ed 5b 72 ea		ld de, (store_readptr)     ; save the current extent to load 
87bd			 
87bd eb				ex de, hl 
87be			 
87be				; next ext 
87be			 
87be 23				inc hl 
87bf 22 72 ea			ld  (store_readptr), hl     ; save the current extent to load 
87c2			 
87c2				if DEBUG_STORESE 
87c2					DMARK "sF2" 
87c2 f5				push af  
87c3 3a d7 87			ld a, (.dmark)  
87c6 32 65 ee			ld (debug_mark),a  
87c9 3a d8 87			ld a, (.dmark+1)  
87cc 32 66 ee			ld (debug_mark+1),a  
87cf 3a d9 87			ld a, (.dmark+2)  
87d2 32 67 ee			ld (debug_mark+2),a  
87d5 18 03			jr .pastdmark  
87d7 ..			.dmark: db "sF2"  
87da f1			.pastdmark: pop af  
87db			endm  
# End of macro DMARK
87db					CALLMONITOR 
87db cd 6f ee			call debug_vector  
87de				endm  
# End of macro CALLMONITOR
87de				endif 
87de			 
87de				; get and load block 
87de			 
87de cd ba 84			call storage_findnextid 
87e1			 
87e1				if DEBUG_STORESE 
87e1					DMARK "sf2" 
87e1 f5				push af  
87e2 3a f6 87			ld a, (.dmark)  
87e5 32 65 ee			ld (debug_mark),a  
87e8 3a f7 87			ld a, (.dmark+1)  
87eb 32 66 ee			ld (debug_mark+1),a  
87ee 3a f8 87			ld a, (.dmark+2)  
87f1 32 67 ee			ld (debug_mark+2),a  
87f4 18 03			jr .pastdmark  
87f6 ..			.dmark: db "sf2"  
87f9 f1			.pastdmark: pop af  
87fa			endm  
# End of macro DMARK
87fa					CALLMONITOR 
87fa cd 6f ee			call debug_vector  
87fd				endm  
# End of macro CALLMONITOR
87fd				endif 
87fd cd 13 8d			call ishlzero 
8800			;	ld a, l 
8800			;	add h 
8800			;	cp 0 
8800 ca de 86			jp z,.sr_fail			; block not found so EOF 
8803				 
8803				; save current address for use by higher level words etc 
8803			 
8803 22 65 ea			ld (store_openaddr),hl 
8806			 
8806 cd 87 81			call storage_read_block 
8809			 
8809				; on a continuation block, we now have the file id and ext in the middle of the block 
8809				; we need to pull everything back  
8809			 
8809 ed 5b 70 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
880d 2a 70 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8810 23				inc hl 
8811 23				inc hl     ; skip id and ext 
8812 01 40 00			ld bc, STORE_BLOCK_PHY 
8815				if DEBUG_STORESE 
8815					DMARK "SR<" 
8815 f5				push af  
8816 3a 2a 88			ld a, (.dmark)  
8819 32 65 ee			ld (debug_mark),a  
881c 3a 2b 88			ld a, (.dmark+1)  
881f 32 66 ee			ld (debug_mark+1),a  
8822 3a 2c 88			ld a, (.dmark+2)  
8825 32 67 ee			ld (debug_mark+2),a  
8828 18 03			jr .pastdmark  
882a ..			.dmark: db "SR<"  
882d f1			.pastdmark: pop af  
882e			endm  
# End of macro DMARK
882e					CALLMONITOR 
882e cd 6f ee			call debug_vector  
8831				endm  
# End of macro CALLMONITOR
8831				endif 
8831 ed b0			ldir     ; copy data 
8833			 
8833				; move the pointer back and pretend we have a full buffer for next recheck 
8833			 
8833 1b				dec de 
8834 1b				dec de 
8835			 
8835			; TODO do pop below now short circuit loop????? 
8835 c1				pop bc     ; get rid of spare de on stack 
8836				if DEBUG_STORESE 
8836					DMARK "SR>" 
8836 f5				push af  
8837 3a 4b 88			ld a, (.dmark)  
883a 32 65 ee			ld (debug_mark),a  
883d 3a 4c 88			ld a, (.dmark+1)  
8840 32 66 ee			ld (debug_mark+1),a  
8843 3a 4d 88			ld a, (.dmark+2)  
8846 32 67 ee			ld (debug_mark+2),a  
8849 18 03			jr .pastdmark  
884b ..			.dmark: db "SR>"  
884e f1			.pastdmark: pop af  
884f			endm  
# End of macro DMARK
884f					CALLMONITOR 
884f cd 6f ee			call debug_vector  
8852				endm  
# End of macro CALLMONITOR
8852				endif 
8852 c3 e3 86			jp .srext 
8855			 
8855			 
8855			 
8855			 
8855			 
8855			.readdone:		 
8855 e1				pop hl 		 ; return start of data to show as not EOF 
8856 23				inc hl   ; past file id 
8857 23				inc hl   ; past ext 
8858				if DEBUG_STORESE 
8858					DMARK "SRe" 
8858 f5				push af  
8859 3a 6d 88			ld a, (.dmark)  
885c 32 65 ee			ld (debug_mark),a  
885f 3a 6e 88			ld a, (.dmark+1)  
8862 32 66 ee			ld (debug_mark+1),a  
8865 3a 6f 88			ld a, (.dmark+2)  
8868 32 67 ee			ld (debug_mark+2),a  
886b 18 03			jr .pastdmark  
886d ..			.dmark: db "SRe"  
8870 f1			.pastdmark: pop af  
8871			endm  
# End of macro DMARK
8871					CALLMONITOR 
8871 cd 6f ee			call debug_vector  
8874				endm  
# End of macro CALLMONITOR
8874				endif 
8874 c9					ret 
8875			 
8875			 
8875			 
8875			; 
8875			; Append File 
8875			; 
8875			; hl - file id to locate 
8875			; de - pointer to (multi block) string to write 
8875			 
8875			.sa_notfound: 
8875 d1				pop de 
8876 c9				ret 
8877			 
8877			 
8877			storage_append: 
8877				; hl -  file id to append to 
8877				; de - string to append 
8877			 
8877 d5				push de 
8878				 
8878				if DEBUG_STORESE 
8878					DMARK "AP1" 
8878 f5				push af  
8879 3a 8d 88			ld a, (.dmark)  
887c 32 65 ee			ld (debug_mark),a  
887f 3a 8e 88			ld a, (.dmark+1)  
8882 32 66 ee			ld (debug_mark+1),a  
8885 3a 8f 88			ld a, (.dmark+2)  
8888 32 67 ee			ld (debug_mark+2),a  
888b 18 03			jr .pastdmark  
888d ..			.dmark: db "AP1"  
8890 f1			.pastdmark: pop af  
8891			endm  
# End of macro DMARK
8891					CALLMONITOR 
8891 cd 6f ee			call debug_vector  
8894				endm  
# End of macro CALLMONITOR
8894				endif 
8894			 
8894 7d				ld a, l 
8895 32 68 ea			ld (store_tmpid), a 
8898			 
8898				; get file header  
8898			 
8898 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
889a 3a 68 ea			ld a, (store_tmpid) 
889d 5f				ld e, a 
889e			 
889e 21 40 00				ld hl, STORE_BLOCK_PHY 
88a1 cd ba 84				call storage_findnextid 
88a4			 
88a4 cd 13 8d			call ishlzero 
88a7 28 cc			jr z, .sa_notfound 
88a9			 
88a9 22 5f ea			ld (store_tmppageid), hl 
88ac			 
88ac				; TODO handle file id not found 
88ac			 
88ac				if DEBUG_STORESE 
88ac					DMARK "AP2" 
88ac f5				push af  
88ad 3a c1 88			ld a, (.dmark)  
88b0 32 65 ee			ld (debug_mark),a  
88b3 3a c2 88			ld a, (.dmark+1)  
88b6 32 66 ee			ld (debug_mark+1),a  
88b9 3a c3 88			ld a, (.dmark+2)  
88bc 32 67 ee			ld (debug_mark+2),a  
88bf 18 03			jr .pastdmark  
88c1 ..			.dmark: db "AP2"  
88c4 f1			.pastdmark: pop af  
88c5			endm  
# End of macro DMARK
88c5					CALLMONITOR 
88c5 cd 6f ee			call debug_vector  
88c8				endm  
# End of macro CALLMONITOR
88c8				endif 
88c8			 
88c8				; update file extent count 
88c8			 
88c8 11 74 ea			ld de, store_page 
88cb			 
88cb cd 87 81			call storage_read_block 
88ce			 
88ce				if DEBUG_STORESE 
88ce					DMARK "AP3" 
88ce f5				push af  
88cf 3a e3 88			ld a, (.dmark)  
88d2 32 65 ee			ld (debug_mark),a  
88d5 3a e4 88			ld a, (.dmark+1)  
88d8 32 66 ee			ld (debug_mark+1),a  
88db 3a e5 88			ld a, (.dmark+2)  
88de 32 67 ee			ld (debug_mark+2),a  
88e1 18 03			jr .pastdmark  
88e3 ..			.dmark: db "AP3"  
88e6 f1			.pastdmark: pop af  
88e7			endm  
# End of macro DMARK
88e7					CALLMONITOR 
88e7 cd 6f ee			call debug_vector  
88ea				endm  
# End of macro CALLMONITOR
88ea				endif 
88ea			;	ld (store_tmppageid), hl 
88ea			 
88ea 3a 76 ea			ld a, (store_page+2) 
88ed 3c				inc a 
88ee 32 76 ea			ld (store_page+2), a 
88f1 32 67 ea			ld (store_tmpext), a 
88f4				 
88f4				if DEBUG_STORESE 
88f4					DMARK "AP3" 
88f4 f5				push af  
88f5 3a 09 89			ld a, (.dmark)  
88f8 32 65 ee			ld (debug_mark),a  
88fb 3a 0a 89			ld a, (.dmark+1)  
88fe 32 66 ee			ld (debug_mark+1),a  
8901 3a 0b 89			ld a, (.dmark+2)  
8904 32 67 ee			ld (debug_mark+2),a  
8907 18 03			jr .pastdmark  
8909 ..			.dmark: db "AP3"  
890c f1			.pastdmark: pop af  
890d			endm  
# End of macro DMARK
890d					CALLMONITOR 
890d cd 6f ee			call debug_vector  
8910				endm  
# End of macro CALLMONITOR
8910				endif 
8910 2a 5f ea			ld hl, (store_tmppageid) 
8913 11 74 ea			ld de, store_page 
8916 cd ec 81			call storage_write_block 
8919			 
8919				; find free block 
8919			 
8919 11 00 00			ld de, 0			 ; file extent to locate 
891c			 
891c 21 40 00				ld hl, STORE_BLOCK_PHY 
891f cd ba 84				call storage_findnextid 
8922 cd 13 8d			call ishlzero 
8925 ca 75 88			jp z, .sa_notfound 
8928			 
8928					; TODO handle no space left 
8928					 
8928 22 5f ea				ld (store_tmppageid), hl 
892b			 
892b				if DEBUG_STORESE 
892b					DMARK "AP4" 
892b f5				push af  
892c 3a 40 89			ld a, (.dmark)  
892f 32 65 ee			ld (debug_mark),a  
8932 3a 41 89			ld a, (.dmark+1)  
8935 32 66 ee			ld (debug_mark+1),a  
8938 3a 42 89			ld a, (.dmark+2)  
893b 32 67 ee			ld (debug_mark+2),a  
893e 18 03			jr .pastdmark  
8940 ..			.dmark: db "AP4"  
8943 f1			.pastdmark: pop af  
8944			endm  
# End of macro DMARK
8944					CALLMONITOR 
8944 cd 6f ee			call debug_vector  
8947				endm  
# End of macro CALLMONITOR
8947				endif 
8947					; init the buffer with zeros so we can id if the buffer is full or not 
8947			 
8947 e5					push hl 
8948 c5					push bc 
8949			 
8949 21 74 ea				ld hl, store_page 
894c 06 40				ld b, STORE_BLOCK_PHY 
894e 3e 00				ld a, 0 
8950 77			.zeroblock:	ld (hl), a 
8951 23					inc hl 
8952 10 fc				djnz .zeroblock 
8954			 
8954 c1					pop bc 
8955 e1					pop hl 
8956			 
8956					; construct block 
8956			 
8956 3a 68 ea				ld a, (store_tmpid) 
8959 32 74 ea				ld (store_page), a   ; file id 
895c 3a 67 ea				ld a, (store_tmpext)   ; extent for this block 
895f 32 75 ea				ld (store_page+1), a 
8962			 
8962 e1					pop hl    ; get string to write 
8963 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8965 11 76 ea				ld de, store_page+2 
8968			 
8968				if DEBUG_STORESE 
8968					DMARK "AP5" 
8968 f5				push af  
8969 3a 7d 89			ld a, (.dmark)  
896c 32 65 ee			ld (debug_mark),a  
896f 3a 7e 89			ld a, (.dmark+1)  
8972 32 66 ee			ld (debug_mark+1),a  
8975 3a 7f 89			ld a, (.dmark+2)  
8978 32 67 ee			ld (debug_mark+2),a  
897b 18 03			jr .pastdmark  
897d ..			.dmark: db "AP5"  
8980 f1			.pastdmark: pop af  
8981			endm  
# End of macro DMARK
8981					CALLMONITOR 
8981 cd 6f ee			call debug_vector  
8984				endm  
# End of macro CALLMONITOR
8984				endif 
8984			 
8984			 
8984			 
8984					; fill buffer with data until end of string or full block 
8984			 
8984 7e			.appd:		ld a, (hl) 
8985 12					ld (de), a 
8986 fe 00				cp 0 
8988 28 04				jr z, .appdone 
898a 23					inc hl 
898b 13					inc de 
898c 10 f6				djnz .appd 
898e			 
898e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
898f f5					push af   		; save last byte dumped 
8990			 
8990			 
8990 2a 5f ea			ld hl, (store_tmppageid) 
8993 11 74 ea			ld de, store_page 
8996				if DEBUG_STORESE 
8996					DMARK "AP6" 
8996 f5				push af  
8997 3a ab 89			ld a, (.dmark)  
899a 32 65 ee			ld (debug_mark),a  
899d 3a ac 89			ld a, (.dmark+1)  
89a0 32 66 ee			ld (debug_mark+1),a  
89a3 3a ad 89			ld a, (.dmark+2)  
89a6 32 67 ee			ld (debug_mark+2),a  
89a9 18 03			jr .pastdmark  
89ab ..			.dmark: db "AP6"  
89ae f1			.pastdmark: pop af  
89af			endm  
# End of macro DMARK
89af					CALLMONITOR 
89af cd 6f ee			call debug_vector  
89b2				endm  
# End of macro CALLMONITOR
89b2				endif 
89b2 cd ec 81				call storage_write_block 
89b5			 
89b5			 
89b5				; was that a full block of data written? 
89b5				; any more to write out? 
89b5			 
89b5				; if yes then set vars and jump to start of function again 
89b5			 
89b5 f1					pop af 
89b6 d1					pop de 
89b7			 
89b7 fe 00				cp 0		 ; no, string was fully written 
89b9 c8					ret z 
89ba			 
89ba					; setup vars for next cycle 
89ba			 
89ba 3a 68 ea				ld a, (store_tmpid) 
89bd 6f					ld l, a 
89be 26 00				ld h, 0 
89c0			 
89c0 c3 77 88			 	jp storage_append	 ; yes, need to write out some more 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			if DEBUG_STORECF 
89c3			storageput:	 
89c3					ret 
89c3			storageread: 
89c3					ld hl, store_page 
89c3					ld b, 200 
89c3					ld a,0 
89c3			.src:		ld (hl),a 
89c3					inc hl 
89c3					djnz .src 
89c3					 
89c3			 
89c3					ld de, 0 
89c3					ld bc, 1 
89c3					ld hl, store_page 
89c3					call cfRead 
89c3			 
89c3				call cfGetError 
89c3				ld hl,scratch 
89c3				call hexout 
89c3				ld hl, scratch+2 
89c3				ld a, 0 
89c3				ld (hl),a 
89c3				ld de, scratch 
89c3				ld a,display_row_1 
89c3				call str_at_display 
89c3				call update_display 
89c3			 
89c3					ld hl, store_page 
89c3					ld (os_cur_ptr),hl 
89c3			 
89c3					ret 
89c3			endif 
89c3			 
89c3			 
89c3			; Clear out the main buffer store (used to remove junk before writing a new block) 
89c3			 
89c3			storage_clear_page: 
89c3 e5				push hl 
89c4 d5				push de 
89c5 c5				push bc 
89c6 21 74 ea			ld hl, store_page 
89c9 3e 00			ld a, 0 
89cb 77				ld (hl), a 
89cc			 
89cc 11 75 ea			ld de, store_page+1 
89cf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89d2			 
89d2 ed b0			ldir 
89d4				 
89d4 c1				pop bc 
89d5 d1				pop de 
89d6 e1				pop hl 
89d7 c9				ret 
89d8			 
89d8			; eof 
# End of file firmware_storage.asm
89d8			  
89d8			; support routines for above hardware abstraction layer  
89d8			  
89d8			include "firmware_general.asm"        ; general support functions  
89d8			 
89d8			; word look up 
89d8			 
89d8			; in 
89d8			; a is the index 
89d8			; hl is pointer start of array 
89d8			; 
89d8			; returns 
89d8			; hl to the word 
89d8			; 
89d8			 
89d8			table_lookup:  
89d8 d5					push de 
89d9 eb					ex de, hl 
89da			 
89da 6f					ld l, a 
89db 26 00				ld h, 0 
89dd 29					add hl, hl 
89de 19					add hl, de 
89df 7e					ld a, (hl) 
89e0 23					inc hl 
89e1 66					ld h,(hl) 
89e2 6f					ld l, a 
89e3			 
89e3 d1					pop de 
89e4 c9					ret 
89e5			 
89e5			; Delay loops 
89e5			 
89e5			 
89e5			 
89e5			aDelayInMS: 
89e5 c5				push bc 
89e6 47				ld b,a 
89e7			msdelay: 
89e7 c5				push bc 
89e8				 
89e8			 
89e8 01 41 00			ld bc,041h 
89eb cd 03 8a			call delayloop 
89ee c1				pop bc 
89ef 05				dec b 
89f0 20 f5			jr nz,msdelay 
89f2			 
89f2			;if CPU_CLOCK_8MHZ 
89f2			;msdelay8: 
89f2			;	push bc 
89f2			;	 
89f2			; 
89f2			;	ld bc,041h 
89f2			;	call delayloop 
89f2			;	pop bc 
89f2			;	dec b 
89f2			;	jr nz,msdelay8 
89f2			;endif 
89f2			 
89f2			 
89f2 c1				pop bc 
89f3 c9				ret 
89f4			 
89f4			 
89f4			delay250ms: 
89f4				;push de 
89f4 01 00 40			ld bc, 04000h 
89f7 c3 03 8a			jp delayloop 
89fa			delay500ms: 
89fa				;push de 
89fa 01 00 80			ld bc, 08000h 
89fd c3 03 8a			jp delayloop 
8a00			delay1s: 
8a00				;push bc 
8a00			   ; Clobbers A, d and e 
8a00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8a03			delayloop: 
8a03 c5			    push bc 
8a04			 
8a04			if BASE_CPM 
8a04				ld bc, CPM_DELAY_TUNE 
8a04			.cpmloop: 
8a04				push bc 
8a04			 
8a04			endif 
8a04			 
8a04			 
8a04			 
8a04			delayloopi: 
8a04			;	push bc 
8a04			;.dl: 
8a04 cb 47		    bit     0,a    	; 8 
8a06 cb 47		    bit     0,a    	; 8 
8a08 cb 47		    bit     0,a    	; 8 
8a0a e6 ff		    and     255  	; 7 
8a0c 0b			    dec     bc      	; 6 
8a0d 79			    ld      a,c     	; 4 
8a0e b0			    or      b     	; 4 
8a0f c2 04 8a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a12			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a12				;pop de 
8a12			;pop bc 
8a12			 
8a12			if BASE_CPM 
8a12				pop bc 
8a12				 
8a12			    dec     bc      	; 6 
8a12			    ld      a,c     	; 4 
8a12			    or      b     	; 4 
8a12			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a12				 
8a12			 
8a12			endif 
8a12			;if CPU_CLOCK_8MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12			 
8a12			;if CPU_CLOCK_10MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12 c1			    pop bc 
8a13			 
8a13 c9				ret 
8a14			 
8a14			 
8a14			 
8a14			; eof 
# End of file firmware_general.asm
8a14			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a14			; display routines that use the physical hardware abstraction layer 
8a14			 
8a14			 
8a14			; Display an activity indicator 
8a14			; Each call returns the new char pointed to in hl 
8a14			 
8a14			active: 
8a14 3a c0 eb			ld a, (display_active) 
8a17 fe 06			cp 6 
8a19			 
8a19 20 02			jr nz, .sne 
8a1b				; gone past the last one reset sequence 
8a1b 3e ff			ld a, 255 
8a1d			 
8a1d			.sne:   
8a1d				; get the next char in seq 
8a1d 3c				inc a 
8a1e 32 c0 eb			ld (display_active), a 
8a21			 
8a21				; look up the string in the table 
8a21 21 38 8a			ld hl, actseq 
8a24 cb 27			sla a 
8a26 cd ea 8c			call addatohl 
8a29 cd f7 9d			call loadwordinhl 
8a2c			 
8a2c				; forth will write the to string when pushing so move from rom to ram 
8a2c			 
8a2c 11 c1 eb			ld de, display_active+1 
8a2f 01 02 00			ld bc, 2 
8a32 ed b0			ldir 
8a34			 
8a34 21 c1 eb			ld hl, display_active+1 
8a37 c9				ret 
8a38				 
8a38				 
8a38			 
8a38			 
8a38			;db "|/-\|-\" 
8a38			 
8a38			actseq: 
8a38			 
8a38 46 8a		dw spin0 
8a3a 48 8a		dw spin1 
8a3c 4a 8a		dw spin2 
8a3e 4c 8a		dw spin3 
8a40 4a 8a		dw spin2 
8a42 48 8a		dw spin1 
8a44 46 8a		dw spin0 
8a46			 
8a46 .. 00		spin0: db " ", 0 
8a48 .. 00		spin1: db "-", 0 
8a4a .. 00		spin2: db "+", 0 
8a4c .. 00		spin3: db "#", 0 
8a4e			 
8a4e			 
8a4e			; information window 
8a4e			 
8a4e			; pass hl with 1st string to display 
8a4e			; pass de with 2nd string to display 
8a4e			 
8a4e			info_panel: 
8a4e e5				push hl 
8a4f			 
8a4f 2a c6 eb			ld hl, (display_fb_active) 
8a52 e5				push hl    ; future de destination 
8a53 21 ab ed				ld hl, display_fb0 
8a56 22 c6 eb				ld (display_fb_active), hl 
8a59			 
8a59			;	call clear_display 
8a59			 
8a59				if BASE_CPM 
8a59				ld a, '.' 
8a59				else 
8a59 3e a5			ld a, 165 
8a5b				endif 
8a5b cd c2 8a			call fill_display 
8a5e			 
8a5e			 
8a5e 3e 55			ld a, display_row_3 + 5 
8a60 cd d0 8a			call str_at_display 
8a63			 
8a63 e1				pop hl 
8a64 d1				pop de 
8a65			 
8a65 e5				push hl 
8a66			 
8a66			 
8a66 3e 2d			ld a, display_row_2 + 5 
8a68 cd d0 8a			call str_at_display 
8a6b			 
8a6b			 
8a6b cd e0 8a			call update_display 
8a6e cd fd 99			call next_page_prompt 
8a71 cd bd 8a			call clear_display 
8a74			 
8a74				 
8a74 21 0a ed				ld hl, display_fb1 
8a77 22 c6 eb				ld (display_fb_active), hl 
8a7a cd e0 8a			call update_display 
8a7d			 
8a7d e1				pop hl 
8a7e			 
8a7e c9				ret 
8a7f			 
8a7f			 
8a7f			 
8a7f			 
8a7f			; TODO windowing? 
8a7f			 
8a7f			; TODO scroll line up 
8a7f			 
8a7f			scroll_up: 
8a7f			 
8a7f e5				push hl 
8a80 d5				push de 
8a81 c5				push bc 
8a82			 
8a82				; get frame buffer  
8a82			 
8a82 2a c6 eb			ld hl, (display_fb_active) 
8a85 e5				push hl    ; future de destination 
8a86			 
8a86 11 28 00			ld  de, display_cols 
8a89 19				add hl, de 
8a8a			 
8a8a d1				pop de 
8a8b			 
8a8b				;ex de, hl 
8a8b 01 9f 00			ld bc, display_fb_len -1  
8a8e			;if DEBUG_FORTH_WORDS 
8a8e			;	DMARK "SCL" 
8a8e			;	CALLMONITOR 
8a8e			;endif	 
8a8e ed b0			ldir 
8a90			 
8a90				; wipe bottom row 
8a90			 
8a90			 
8a90 2a c6 eb			ld hl, (display_fb_active) 
8a93 11 a0 00			ld de, display_cols*display_rows 
8a96 19				add hl, de 
8a97 06 28			ld b, display_cols 
8a99 3e 20			ld a, ' ' 
8a9b			.scwipe: 
8a9b 77				ld (hl), a 
8a9c 2b				dec hl 
8a9d 10 fc			djnz .scwipe 
8a9f			 
8a9f				;pop hl 
8a9f			 
8a9f c1				pop bc 
8aa0 d1				pop de 
8aa1 e1				pop hl 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			 
8aa3			;scroll_upo: 
8aa3			;	ld de, display_row_1 
8aa3			 ;	ld hl, display_row_2 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_2 
8aa3			 ;	ld hl, display_row_3 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_3 
8aa3			 ;	ld hl, display_row_4 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			 
8aa3			; TODO clear row 4 
8aa3			 
8aa3			;	ret 
8aa3			 
8aa3				 
8aa3			scroll_down: 
8aa3			 
8aa3 e5				push hl 
8aa4 d5				push de 
8aa5 c5				push bc 
8aa6			 
8aa6				; get frame buffer  
8aa6			 
8aa6 2a c6 eb			ld hl, (display_fb_active) 
8aa9			 
8aa9 11 9f 00			ld de, display_fb_len - 1 
8aac 19				add hl, de 
8aad			 
8aad e5			push hl    ; future de destination 
8aae			 
8aae 11 28 00			ld  de, display_cols 
8ab1 ed 52			sbc hl, de 
8ab3			 
8ab3			 
8ab3 d1				pop de 
8ab4			 
8ab4			;	ex de, hl 
8ab4 01 9f 00			ld bc, display_fb_len -1  
8ab7			 
8ab7			 
8ab7				 
8ab7			 
8ab7 ed b0			ldir 
8ab9			 
8ab9				; wipe bottom row 
8ab9			 
8ab9			 
8ab9			;	ld hl, (display_fb_active) 
8ab9			;;	ld de, display_cols*display_rows 
8ab9			;;	add hl, de 
8ab9			;	ld b, display_cols 
8ab9			;	ld a, ' ' 
8ab9			;.scwiped: 
8ab9			;	ld (hl), a 
8ab9			;	dec hl 
8ab9			;	djnz .scwiped 
8ab9			 
8ab9				;pop hl 
8ab9			 
8ab9 c1				pop bc 
8aba d1				pop de 
8abb e1				pop hl 
8abc			 
8abc c9				ret 
8abd			;scroll_down: 
8abd			;	ld de, display_row_4 
8abd			;	ld hl, display_row_3 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_3 
8abd			; 	ld hl, display_row_2 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_2 
8abd			;	ld hl, display_row_1 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;;; TODO clear row 1 
8abd			;	ret 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			; clear active frame buffer 
8abd			 
8abd			clear_display: 
8abd 3e 20			ld a, ' ' 
8abf c3 c2 8a			jp fill_display 
8ac2			 
8ac2			; fill active frame buffer with a char in A 
8ac2			 
8ac2			fill_display: 
8ac2 06 a0			ld b,display_fb_len 
8ac4 2a c6 eb			ld hl, (display_fb_active) 
8ac7 77			.fd1:	ld (hl),a 
8ac8 23				inc hl 
8ac9 10 fc			djnz .fd1 
8acb 23				inc hl 
8acc 3e 00			ld a,0 
8ace 77				ld (hl),a 
8acf			 
8acf			 
8acf c9				ret 
8ad0			; Write string (DE) at pos (A) to active frame buffer 
8ad0			 
8ad0 2a c6 eb		str_at_display:    ld hl,(display_fb_active) 
8ad3 06 00					ld b,0 
8ad5 4f					ld c,a 
8ad6 09					add hl,bc 
8ad7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ad8 b7			            OR   A              ;Null terminator? 
8ad9 c8			            RET  Z              ;Yes, so finished 
8ada 77					ld (hl),a 
8adb 23				inc hl 
8adc 13			            INC  DE             ;Point to next character 
8add 18 f8		            JR   .sad1     ;Repeat 
8adf c9					ret 
8ae0			 
8ae0			; using current frame buffer write to physical display 
8ae0			 
8ae0			update_display: 
8ae0 e5				push hl 
8ae1 2a c6 eb			ld hl, (display_fb_active) 
8ae4 cd 1e e2			call write_display 
8ae7 e1				pop hl 
8ae8 c9				ret 
8ae9			 
8ae9			; TODO scrolling 
8ae9			 
8ae9			 
8ae9			; move cursor right one char 
8ae9			cursor_right: 
8ae9			 
8ae9				; TODO shift right 
8ae9				; TODO if beyond max col 
8ae9				; TODO       cursor_next_line 
8ae9			 
8ae9 c9				ret 
8aea			 
8aea			 
8aea			cursor_next_line: 
8aea				; TODO first char 
8aea				; TODO line down 
8aea				; TODO if past last row 
8aea				; TODO    scroll up 
8aea			 
8aea c9				ret 
8aeb			 
8aeb			cursor_left: 
8aeb				; TODO shift left 
8aeb				; TODO if beyond left  
8aeb				; TODO     cursor prev line 
8aeb				 
8aeb c9				ret 
8aec			 
8aec			cursor_prev_line: 
8aec				; TODO last char 
8aec				; TODO line up 
8aec				; TODO if past first row 
8aec				; TODO   scroll down 
8aec			 
8aec c9				ret 
8aed			 
8aed			 
8aed			cout: 
8aed				; A - char 
8aed c9				ret 
8aee			 
8aee			 
8aee			; Display a menu and allow item selection (optional toggle items) 
8aee			; 
8aee			; format: 
8aee			; hl pointer to word array with zero term for items 
8aee			; e.g.    db item1 
8aee			;         db .... 
8aee			;         db 0 
8aee			; 
8aee			; a = starting menu item  
8aee			; 
8aee			; de = pointer item toggle array   (todo) 
8aee			; 
8aee			; returns item selected in a 1-... 
8aee			; returns 0 if back button pressed 
8aee			; 
8aee			; NOTE: Uses system frame buffer to display 
8aee			; 
8aee			; LEFT, Q = go back 
8aee			; RIGHT, SPACE, CR = select 
8aee			; UP, A - Up 
8aee			; DOWN, Z - Down 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			menu: 
8aee			 
8aee					; keep array pointer 
8aee			 
8aee 22 6d ea				ld (store_tmp1), hl 
8af1 32 6b ea				ld (store_tmp2), a 
8af4			 
8af4					; check for key bounce 
8af4			 
8af4			if BASE_KEV 
8af4			 
8af4			.mbounce:	call cin 
8af4					cp 0 
8af4					jr nz, .mbounce 
8af4			endif 
8af4					; for ease use ex 
8af4			 
8af4					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8af4 21 ab ed				ld hl, display_fb0 
8af7 22 c6 eb				ld (display_fb_active), hl 
8afa			 
8afa cd bd 8a		.mloop:		call clear_display 
8afd cd e0 8a				call update_display 
8b00			 
8b00					; draw selection id '>' at 1 
8b00			 
8b00					; init start of list display 
8b00			 
8b00 3e 05				ld a, 5 
8b02 32 69 ea				ld (store_tmp3), a   ; display row count 
8b05 3a 6b ea				ld a,( store_tmp2) 
8b08 32 6c ea				ld (store_tmp2+1), a   ; display item count 
8b0b			 
8b0b					 
8b0b			.mitem:	 
8b0b			 
8b0b			 
8b0b 3a 6c ea				ld a,(store_tmp2+1) 
8b0e 6f					ld l, a 
8b0f 26 00				ld h, 0 
8b11 29					add hl, hl 
8b12 ed 5b 6d ea			ld de, (store_tmp1) 
8b16 19					add hl, de 
8b17 7e					ld a, (hl) 
8b18 23					inc hl 
8b19 66					ld h,(hl) 
8b1a 6f					ld l, a 
8b1b			 
8b1b cd 13 8d				call ishlzero 
8b1e 28 1a				jr z, .mdone 
8b20			 
8b20 eb					ex de, hl 
8b21 3a 69 ea				ld a, (store_tmp3) 
8b24 cd d0 8a				call str_at_display 
8b27					 
8b27			 
8b27					; next item 
8b27 3a 6c ea				ld a, (store_tmp2+1) 
8b2a 3c					inc a 
8b2b 32 6c ea				ld (store_tmp2+1), a   ; display item count 
8b2e			 
8b2e			 		; next row 
8b2e			 
8b2e 3a 69 ea				ld a, (store_tmp3) 
8b31 c6 28				add display_cols 
8b33 32 69 ea				ld (store_tmp3), a 
8b36			 
8b36					; at end of screen? 
8b36			 
8b36 fe 10				cp display_rows*4 
8b38 20 d1				jr nz, .mitem 
8b3a			 
8b3a			 
8b3a			.mdone: 
8b3a cd 13 8d				call ishlzero 
8b3d 28 08				jr z, .nodn 
8b3f			 
8b3f 3e 78				ld a, display_row_4 
8b41 11 c0 8b				ld de, .mdown 
8b44 cd d0 8a				call str_at_display 
8b47			 
8b47					; draw options to fill the screens with active item on line 1 
8b47					; if current option is 2 or more then display ^ in top 
8b47			 
8b47 3a 6b ea		.nodn:		ld a, (store_tmp2) 
8b4a fe 00				cp 0 
8b4c 28 08				jr z, .noup 
8b4e			 
8b4e 3e 00				ld a, 0 
8b50 11 be 8b				ld de, .mup 
8b53 cd d0 8a				call str_at_display 
8b56			 
8b56 3e 02		.noup:		ld a, 2 
8b58 11 bc 8b				ld de, .msel 
8b5b cd d0 8a				call str_at_display 
8b5e			 
8b5e					; if current option + 1 is not null then display V in bottom 
8b5e					; get key 
8b5e cd e0 8a				call update_display 
8b61			 
8b61			 
8b61					; handle key 
8b61			 
8b61 cd aa e2				call cin_wait 
8b64			 
8b64 fe 05				cp KEY_UP 
8b66 28 2b				jr z, .mgoup 
8b68 fe 61				cp 'a' 
8b6a 28 27				jr z, .mgoup 
8b6c fe 0a				cp KEY_DOWN 
8b6e 28 32				jr z, .mgod 
8b70 fe 7a				cp 'z' 
8b72 28 2e				jr z, .mgod 
8b74 fe 20				cp ' ' 
8b76 28 34				jr z, .goend 
8b78 fe 0c				cp KEY_RIGHT 
8b7a 28 30				jr z, .goend 
8b7c fe 0d				cp KEY_CR 
8b7e 28 2c				jr z, .goend 
8b80 fe 71				cp 'q' 
8b82 28 0b				jr z, .goback 
8b84			 
8b84 fe 0b				cp KEY_LEFT 
8b86 28 07				jr z, .goback 
8b88 fe 08				cp KEY_BS 
8b8a 28 03				jr z, .goback 
8b8c c3 fa 8a				jp .mloop 
8b8f			 
8b8f			.goback: 
8b8f 3e 00			ld a, 0 
8b91 18 1d			jr .goend2 
8b93			 
8b93				; move up one 
8b93			.mgoup: 
8b93 3a 6b ea				ld a, (store_tmp2) 
8b96 fe 00				cp 0 
8b98 ca fa 8a				jp z, .mloop 
8b9b 3d					dec a 
8b9c 32 6b ea				ld (store_tmp2), a 
8b9f c3 fa 8a				jp .mloop 
8ba2			 
8ba2				; move down one 
8ba2			.mgod: 
8ba2 3a 6b ea				ld a, (store_tmp2) 
8ba5 3c					inc a 
8ba6 32 6b ea				ld (store_tmp2), a 
8ba9 c3 fa 8a				jp .mloop 
8bac			 
8bac			 
8bac			.goend: 
8bac					; get selected item number 
8bac			 
8bac 3a 6b ea				ld a, (store_tmp2) 
8baf 3c					inc a 
8bb0			 
8bb0			.goend2: 
8bb0 f5					push af 
8bb1			 
8bb1					; restore active fb 
8bb1					; TODO BUG assumes fb1 
8bb1			 
8bb1 21 0a ed				ld hl, display_fb1 
8bb4 22 c6 eb				ld (display_fb_active), hl 
8bb7			 
8bb7					; restore main regs 
8bb7			 
8bb7			 
8bb7 cd e0 8a				call update_display 
8bba			 
8bba f1					pop af 
8bbb			 
8bbb c9				ret 
8bbc			 
8bbc .. 00		.msel:   db ">",0 
8bbe .. 00		.mup:   db "^",0 
8bc0 .. 00		.mdown:   db "v",0 
8bc2			 
8bc2			 
8bc2			; eof 
8bc2			 
# End of file firmware_display.asm
8bc2			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bc2			; random number generators 
8bc2			 
8bc2			 
8bc2			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bc2			 
8bc2			 
8bc2			;-----> Generate a random number 
8bc2			; output a=answer 0<=a<=255 
8bc2			; all registers are preserved except: af 
8bc2			random: 
8bc2 e5			        push    hl 
8bc3 d5			        push    de 
8bc4 2a a5 eb		        ld      hl,(randData) 
8bc7 ed 5f		        ld      a,r 
8bc9 57			        ld      d,a 
8bca 5e			        ld      e,(hl) 
8bcb 19			        add     hl,de 
8bcc 85			        add     a,l 
8bcd ac			        xor     h 
8bce 22 a5 eb		        ld      (randData),hl 
8bd1 d1			        pop     de 
8bd2 e1			        pop     hl 
8bd3 c9			        ret 
8bd4			 
8bd4			 
8bd4			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bd4			 
8bd4			 
8bd4			 
8bd4			;------LFSR------ 
8bd4			;James Montelongo 
8bd4			;optimized by Spencer Putt 
8bd4			;out: 
8bd4			; a = 8 bit random number 
8bd4			RandLFSR: 
8bd4 21 ab eb		        ld hl,LFSRSeed+4 
8bd7 5e			        ld e,(hl) 
8bd8 23			        inc hl 
8bd9 56			        ld d,(hl) 
8bda 23			        inc hl 
8bdb 4e			        ld c,(hl) 
8bdc 23			        inc hl 
8bdd 7e			        ld a,(hl) 
8bde 47			        ld b,a 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed cb 13		        rl e  
8bef cb 12			rl d 
8bf1 cb 11		        rl c  
8bf3 17				rla 
8bf4 67			        ld h,a 
8bf5 cb 13		        rl e  
8bf7 cb 12			rl d 
8bf9 cb 11		        rl c  
8bfb 17				rla 
8bfc a8			        xor b 
8bfd cb 13		        rl e  
8bff cb 12			rl d 
8c01 ac			        xor h 
8c02 a9			        xor c 
8c03 aa			        xor d 
8c04 21 ad eb		        ld hl,LFSRSeed+6 
8c07 11 ae eb		        ld de,LFSRSeed+7 
8c0a 01 07 00		        ld bc,7 
8c0d ed b8		        lddr 
8c0f 12			        ld (de),a 
8c10 c9			        ret 
8c11			 
8c11			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c11			 
8c11			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c11			 
8c11			 
8c11			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c11			 
8c11			prng16: 
8c11			;Inputs: 
8c11			;   (seed1) contains a 16-bit seed value 
8c11			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c11			;Outputs: 
8c11			;   HL is the result 
8c11			;   BC is the result of the LCG, so not that great of quality 
8c11			;   DE is preserved 
8c11			;Destroys: 
8c11			;   AF 
8c11			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c11			;160cc 
8c11			;26 bytes 
8c11 2a 9f eb		    ld hl,(seed1) 
8c14 44			    ld b,h 
8c15 4d			    ld c,l 
8c16 29			    add hl,hl 
8c17 29			    add hl,hl 
8c18 2c			    inc l 
8c19 09			    add hl,bc 
8c1a 22 9f eb		    ld (seed1),hl 
8c1d 2a 9d eb		    ld hl,(seed2) 
8c20 29			    add hl,hl 
8c21 9f			    sbc a,a 
8c22 e6 2d		    and %00101101 
8c24 ad			    xor l 
8c25 6f			    ld l,a 
8c26 22 9d eb		    ld (seed2),hl 
8c29 09			    add hl,bc 
8c2a c9			    ret 
8c2b			 
8c2b			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c2b			 
8c2b			rand32: 
8c2b			;Inputs: 
8c2b			;   (seed1_0) holds the lower 16 bits of the first seed 
8c2b			;   (seed1_1) holds the upper 16 bits of the first seed 
8c2b			;   (seed2_0) holds the lower 16 bits of the second seed 
8c2b			;   (seed2_1) holds the upper 16 bits of the second seed 
8c2b			;   **NOTE: seed2 must be non-zero 
8c2b			;Outputs: 
8c2b			;   HL is the result 
8c2b			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c2b			;Destroys: 
8c2b			;   AF 
8c2b			;Tested and passes all CAcert tests 
8c2b			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c2b			;it has a period of 18,446,744,069,414,584,320 
8c2b			;roughly 18.4 quintillion. 
8c2b			;LFSR taps: 0,2,6,7  = 11000101 
8c2b			;291cc 
8c2b			;seed1_0=$+1 
8c2b			;    ld hl,12345 
8c2b			;seed1_1=$+1 
8c2b			;    ld de,6789 
8c2b			;    ld b,h 
8c2b			;    ld c,l 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    inc l 
8c2b			;    add hl,bc 
8c2b			;    ld (seed1_0),hl 
8c2b			;    ld hl,(seed1_1) 
8c2b			;    adc hl,de 
8c2b			;    ld (seed1_1),hl 
8c2b			;    ex de,hl 
8c2b			;seed2_0=$+1 
8c2b			;    ld hl,9876 
8c2b			;seed2_1=$+1 
8c2b			;    ld bc,54321 
8c2b			;    add hl,hl \ rl c \ rl b 
8c2b			;    ld (seed2_1),bc 
8c2b			;    sbc a,a 
8c2b			;    and %11000101 
8c2b			;    xor l 
8c2b			;    ld l,a 
8c2b			;    ld (seed2_0),hl 
8c2b			;    ex de,hl 
8c2b			;    add hl,bc 
8c2b			;    ret 
8c2b			; 
8c2b			 
8c2b			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c2b			; 20 bytes, 86 cycles (excluding ret) 
8c2b			 
8c2b			; returns   hl = pseudorandom number 
8c2b			; corrupts   a 
8c2b			 
8c2b			; generates 16-bit pseudorandom numbers with a period of 65535 
8c2b			; using the xorshift method: 
8c2b			 
8c2b			; hl ^= hl << 7 
8c2b			; hl ^= hl >> 9 
8c2b			; hl ^= hl << 8 
8c2b			 
8c2b			; some alternative shift triplets which also perform well are: 
8c2b			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c2b			 
8c2b			;  org 32768 
8c2b			 
8c2b			xrnd: 
8c2b 2a a3 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c2e 3e 00		  ld a,0 
8c30 bd			  cp l 
8c31 20 02		  jr nz, .xrnd1 
8c33 2e 01		  ld l, 1 
8c35			.xrnd1: 
8c35			 
8c35 7c			  ld a,h 
8c36 1f			  rra 
8c37 7d			  ld a,l 
8c38 1f			  rra 
8c39 ac			  xor h 
8c3a 67			  ld h,a 
8c3b 7d			  ld a,l 
8c3c 1f			  rra 
8c3d 7c			  ld a,h 
8c3e 1f			  rra 
8c3f ad			  xor l 
8c40 6f			  ld l,a 
8c41 ac			  xor h 
8c42 67			  ld h,a 
8c43			 
8c43 22 a3 eb		  ld (xrandc),hl 
8c46			 
8c46 c9			  ret 
8c47			;  
8c47			 
8c47			 
8c47			;;;; int maths 
8c47			 
8c47			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c47			; Divide 16-bit values (with 16-bit result) 
8c47			; In: Divide BC by divider DE 
8c47			; Out: BC = result, HL = rest 
8c47			; 
8c47			Div16: 
8c47 21 00 00		    ld hl,0 
8c4a 78			    ld a,b 
8c4b 06 08		    ld b,8 
8c4d			Div16_Loop1: 
8c4d 17			    rla 
8c4e ed 6a		    adc hl,hl 
8c50 ed 52		    sbc hl,de 
8c52 30 01		    jr nc,Div16_NoAdd1 
8c54 19			    add hl,de 
8c55			Div16_NoAdd1: 
8c55 10 f6		    djnz Div16_Loop1 
8c57 17			    rla 
8c58 2f			    cpl 
8c59 47			    ld b,a 
8c5a 79			    ld a,c 
8c5b 48			    ld c,b 
8c5c 06 08		    ld b,8 
8c5e			Div16_Loop2: 
8c5e 17			    rla 
8c5f ed 6a		    adc hl,hl 
8c61 ed 52		    sbc hl,de 
8c63 30 01		    jr nc,Div16_NoAdd2 
8c65 19			    add hl,de 
8c66			Div16_NoAdd2: 
8c66 10 f6		    djnz Div16_Loop2 
8c68 17			    rla 
8c69 2f			    cpl 
8c6a 41			    ld b,c 
8c6b 4f			    ld c,a 
8c6c c9			ret 
8c6d			 
8c6d			 
8c6d			;http://z80-heaven.wikidot.com/math 
8c6d			; 
8c6d			;Inputs: 
8c6d			;     DE and A are factors 
8c6d			;Outputs: 
8c6d			;     A is not changed 
8c6d			;     B is 0 
8c6d			;     C is not changed 
8c6d			;     DE is not changed 
8c6d			;     HL is the product 
8c6d			;Time: 
8c6d			;     342+6x 
8c6d			; 
8c6d			Mult16: 
8c6d			 
8c6d 06 08		     ld b,8          ;7           7 
8c6f 21 00 00		     ld hl,0         ;10         10 
8c72 29			       add hl,hl     ;11*8       88 
8c73 07			       rlca          ;4*8        32 
8c74 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c76 19			         add hl,de   ;--         -- 
8c77 10 f9		       djnz $-5      ;13*7+8     99 
8c79 c9			ret 
8c7a			 
8c7a			; 
8c7a			; Square root of 16-bit value 
8c7a			; In:  HL = value 
8c7a			; Out:  D = result (rounded down) 
8c7a			; 
8c7a			;Sqr16: 
8c7a			;    ld de,#0040 
8c7a			;    ld a,l 
8c7a			;    ld l,h 
8c7a			;    ld h,d 
8c7a			;    or a 
8c7a			;    ld b,8 
8c7a			;Sqr16_Loop: 
8c7a			;    sbc hl,de 
8c7a			;    jr nc,Sqr16_Skip 
8c7a			;    add hl,de 
8c7a			;Sqr16_Skip: 
8c7a			;    ccf 
8c7a			;    rl d 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    djnz Sqr16_Loop 
8c7a			;    ret 
8c7a			; 
8c7a			; 
8c7a			; Divide 8-bit values 
8c7a			; In: Divide E by divider C 
8c7a			; Out: A = result, B = rest 
8c7a			; 
8c7a			Div8: 
8c7a af			    xor a 
8c7b 06 08		    ld b,8 
8c7d			Div8_Loop: 
8c7d cb 13		    rl e 
8c7f 17			    rla 
8c80 91			    sub c 
8c81 30 01		    jr nc,Div8_NoAdd 
8c83 81			    add a,c 
8c84			Div8_NoAdd: 
8c84 10 f7		    djnz Div8_Loop 
8c86 47			    ld b,a 
8c87 7b			    ld a,e 
8c88 17			    rla 
8c89 2f			    cpl 
8c8a c9			    ret 
8c8b			 
8c8b			; 
8c8b			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c8b			; In: Multiply A with DE 
8c8b			; Out: HL = result 
8c8b			; 
8c8b			Mult12U: 
8c8b 2e 00		    ld l,0 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd0 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd0: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd1 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd1: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd2 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd2: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd3 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd3: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 30 01		    jr nc,Mult12U_NoAdd4 
8ca4 19			    add hl,de 
8ca5			Mult12U_NoAdd4: 
8ca5 29			    add hl,hl 
8ca6 87			    add a,a 
8ca7 30 01		    jr nc,Mult12U_NoAdd5 
8ca9 19			    add hl,de 
8caa			Mult12U_NoAdd5: 
8caa 29			    add hl,hl 
8cab 87			    add a,a 
8cac 30 01		    jr nc,Mult12U_NoAdd6 
8cae 19			    add hl,de 
8caf			Mult12U_NoAdd6: 
8caf 29			    add hl,hl 
8cb0 87			    add a,a 
8cb1 d0			    ret nc 
8cb2 19			    add hl,de 
8cb3 c9			    ret 
8cb4			 
8cb4			; 
8cb4			; Multiply 8-bit value with a 16-bit value (right rotating) 
8cb4			; In: Multiply A with DE 
8cb4			;      Put lowest value in A for most efficient calculation 
8cb4			; Out: HL = result 
8cb4			; 
8cb4			Mult12R: 
8cb4 21 00 00		    ld hl,0 
8cb7			Mult12R_Loop: 
8cb7 cb 3f		    srl a 
8cb9 30 01		    jr nc,Mult12R_NoAdd 
8cbb 19			    add hl,de 
8cbc			Mult12R_NoAdd: 
8cbc cb 23		    sla e 
8cbe cb 12		    rl d 
8cc0 b7			    or a 
8cc1 c2 b7 8c		    jp nz,Mult12R_Loop 
8cc4 c9			    ret 
8cc5			 
8cc5			; 
8cc5			; Multiply 16-bit values (with 32-bit result) 
8cc5			; In: Multiply BC with DE 
8cc5			; Out: BCHL = result 
8cc5			; 
8cc5			Mult32: 
8cc5 79			    ld a,c 
8cc6 48			    ld c,b 
8cc7 21 00 00		    ld hl,0 
8cca 06 10		    ld b,16 
8ccc			Mult32_Loop: 
8ccc 29			    add hl,hl 
8ccd 17			    rla 
8cce cb 11		    rl c 
8cd0 30 07		    jr nc,Mult32_NoAdd 
8cd2 19			    add hl,de 
8cd3 ce 00		    adc a,0 
8cd5 d2 d9 8c		    jp nc,Mult32_NoAdd 
8cd8 0c			    inc c 
8cd9			Mult32_NoAdd: 
8cd9 10 f1		    djnz Mult32_Loop 
8cdb 41			    ld b,c 
8cdc 4f			    ld c,a 
8cdd c9			    ret 
8cde			 
8cde			 
8cde			 
8cde			; 
8cde			; Multiply 8-bit values 
8cde			; In:  Multiply H with E 
8cde			; Out: HL = result 
8cde			; 
8cde			Mult8: 
8cde 16 00		    ld d,0 
8ce0 6a			    ld l,d 
8ce1 06 08		    ld b,8 
8ce3			Mult8_Loop: 
8ce3 29			    add hl,hl 
8ce4 30 01		    jr nc,Mult8_NoAdd 
8ce6 19			    add hl,de 
8ce7			Mult8_NoAdd: 
8ce7 10 fa		    djnz Mult8_Loop 
8ce9 c9			    ret 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			;;http://z80-heaven.wikidot.com/math 
8cea			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cea			; 
8cea			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cea			;     ld a,16        ;7 
8cea			;     ld hl,0        ;10 
8cea			;     jp $+5         ;10 
8cea			;.DivLoop: 
8cea			;       add hl,bc    ;-- 
8cea			;       dec a        ;64 
8cea			;       jr z,.DivLoopEnd        ;86 
8cea			; 
8cea			;       sla e        ;128 
8cea			;       rl d         ;128 
8cea			;       adc hl,hl    ;240 
8cea			;       sbc hl,bc    ;240 
8cea			;       jr nc,.DivLoop ;23|21 
8cea			;       inc e        ;-- 
8cea			;       jp .DivLoop+1 
8cea			; 
8cea			;.DivLoopEnd: 
8cea			 
8cea			;HL_Div_C: 
8cea			;Inputs: 
8cea			;     HL is the numerator 
8cea			;     C is the denominator 
8cea			;Outputs: 
8cea			;     A is the remainder 
8cea			;     B is 0 
8cea			;     C is not changed 
8cea			;     DE is not changed 
8cea			;     HL is the quotient 
8cea			; 
8cea			;       ld b,16 
8cea			;       xor a 
8cea			;         add hl,hl 
8cea			;         rla 
8cea			;         cp c 
8cea			;         jr c,$+4 
8cea			;           inc l 
8cea			;           sub c 
8cea			;         djnz $-7 
8cea			 
8cea			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cea			 
8cea			addatohl: 
8cea 85			    add   a, l    ; A = A+L 
8ceb 6f			    ld    l, a    ; L = A+L 
8cec 8c			    adc   a, h    ; A = A+L+H+carry 
8ced 95			    sub   l       ; A = H+carry 
8cee 67			    ld    h, a    ; H = H+carry 
8cef c9			ret 
8cf0			 
8cf0			addatode: 
8cf0 83			    add   a, e    ; A = A+L 
8cf1 5f			    ld    e, a    ; L = A+L 
8cf2 8a			    adc   a, d    ; A = A+L+H+carry 
8cf3 93			    sub   e       ; A = H+carry 
8cf4 57			    ld    d, a    ; H = H+carry 
8cf5 c9			ret 
8cf6			 
8cf6			 
8cf6			addatobc: 
8cf6 81			    add   a, c    ; A = A+L 
8cf7 4f			    ld    c, a    ; L = A+L 
8cf8 88			    adc   a, b    ; A = A+L+H+carry 
8cf9 91			    sub   c       ; A = H+carry 
8cfa 47			    ld    b, a    ; H = H+carry 
8cfb c9			ret 
8cfc			 
8cfc			subafromhl: 
8cfc			   ; If A=0 do nothing 
8cfc			    ; Otherwise flip A's sign. Since 
8cfc			    ; the upper byte becomes -1, also 
8cfc			    ; substract 1 from H. 
8cfc ed 44		    neg 
8cfe ca 07 8d		    jp    z, Skip 
8d01 25			    dec   h 
8d02			     
8d02			    ; Now add the low byte as usual 
8d02			    ; Two's complement takes care of 
8d02			    ; ensuring the result is correct 
8d02 85			    add   a, l 
8d03 6f			    ld    l, a 
8d04 8c			    adc   a, h 
8d05 95			    sub   l 
8d06 67			    ld    h, a 
8d07			Skip: 
8d07 c9				ret 
8d08			 
8d08			 
8d08			; compare hl and de 
8d08			; returns:  
8d08			; if hl = de, z=1, s=0, c0=0 
8d08			; if hl > de, z=0, s=0, c=0 
8d08			; if hl < de, z=0, s=1, c=1 
8d08			cmp16:	 
8d08 b7				or a 
8d09 ed 52			sbc hl,de 
8d0b e0				ret po 
8d0c 7c				ld a,h 
8d0d 1f				rra 
8d0e ee 40			xor 01000000B 
8d10 37				scf 
8d11 8f				adc a,a 
8d12 c9				ret 
8d13			 
8d13			 
8d13			; test if hl contains zero   - A is destroyed 
8d13			 
8d13			ishlzero:    
8d13 b7				or a     ; reset flags 
8d14 7c				ld a, h 
8d15 b5				or l        	 
8d16			 
8d16 c9				ret 
8d17			 
8d17			 
8d17			 
8d17			 
8d17			if FORTH_ENABLE_FLOATMATH 
8d17			;include "float/bbcmath.z80" 
8d17			include "float/lpfpcalc.asm" 
8d17			endif 
8d17			 
8d17			 
8d17			; eof 
8d17			 
# End of file firmware_maths.asm
8d17			include "firmware_strings.asm"   ; string handling  
8d17			 
8d17			 
8d17			; TODO string len 
8d17			; input text string, end on cr with zero term 
8d17			; a offset into frame buffer to start prompt 
8d17			; d is max length 
8d17			; e is display size TODO 
8d17			; c is current cursor position 
8d17			; hl is ptr to where string will be stored and edited directly 
8d17			 
8d17			 
8d17			; TODO check limit of buffer for new inserts 
8d17			; TODO check insert does not push beyond buffer 
8d17			; TODO scroll in a limited display area 
8d17			; TODO scroll whole screen on page wrap 
8d17			 
8d17			 
8d17			; TODO use LCD cursor? 
8d17			 
8d17			EDIT_V1: equ 0 
8d17			EDIT_V2: equ 1 
8d17			 
8d17			 
8d17			 
8d17			if EDIT_V2 
8d17			input_str: 
8d17			 
8d17 32 5e ee			    	ld (input_at_pos),a      ; save display position to start 
8d1a			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d1a 22 61 ee				ld (input_start), hl     ; save ptr to buffer 
8d1d			;		ld a, c 
8d1d			;		call addatohl 
8d1d			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1d 7a					ld a,d 
8d1e 32 60 ee			        ld (input_size), a       ; save length of input area 
8d21 79					ld a, c 
8d22 32 4f ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d25 7b					ld a,e 
8d26 32 5f ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d29			 
8d29			 
8d29					; add a trailing space to make screen refresh nicer 
8d29			 
8d29					;ld hl, (input_start) 
8d29					;push hl 
8d29					;ld a, 0 
8d29					;call strlent 
8d29					;ld a, l 
8d29					;pop hl 
8d29					;call addatohl 
8d29					;dec hl 
8d29					;ld a, ' ' 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld a, 0 
8d29					;ld (hl), a 
8d29			 
8d29			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d29					; init cursor shape if not set by the cin routines 
8d29 21 bb eb				ld hl, cursor_shape 
8d2c			if BASE_KEV 
8d2c					ld a, 255 
8d2c			else 
8d2c 3e 23				ld a, '#' 
8d2e			endif 
8d2e 77					ld (hl), a 
8d2f 23					inc hl 
8d30 3e 00				ld a, 0 
8d32 77					ld (hl), a 
8d33			 
8d33 3e 09				ld a, CUR_BLINK_RATE 
8d35 32 5a ee				ld (input_cur_flash), a 
8d38 3e 01				ld a, 1 
8d3a 32 59 ee				ld (input_cur_onoff),a 
8d3d			.inmain:	 
8d3d			 
8d3d cd 65 8e				call input_disp_ref 
8d40			 
8d40					; save current length of string 
8d40			 
8d40 2a 61 ee				ld hl, (input_start) 
8d43 3e 00				ld a, 0 
8d45 cd 5b 90				call strlent 
8d48 7d					ld a,l 
8d49 32 54 ee				ld (input_len), a 
8d4c			 
8d4c					;call input_disp_oncur 
8d4c			 
8d4c					; display current state of input buffer 
8d4c			 
8d4c					; clean any backspace chars 
8d4c			 
8d4c 3e 20				ld a, " " 
8d4e 32 bb e2				ld (scratch),a 
8d51 3e 00				ld a, 0 
8d53 32 bc e2				ld (scratch+1),a 
8d56 3a 5e ee				ld a,(input_at_pos) 
8d59 85					add l 
8d5a 11 bb e2				ld de, scratch 
8d5d cd d0 8a				call str_at_display 
8d60			 
8d60					; pause 1ms 
8d60			 
8d60 3e 01				ld a, 1 
8d62 cd e5 89				call aDelayInMS 
8d65			 
8d65			; display cursor if visible on this cycle 
8d65			 
8d65					; dec flash counter 
8d65 3a 5a ee				ld a, (input_cur_flash) 
8d68 3d					dec a 
8d69 32 5a ee				ld (input_cur_flash), a 
8d6c fe 00				cp 0 
8d6e 20 0d				jr nz, .inochgstate 
8d70			 
8d70			 
8d70					; reset on change of state 
8d70 3e 09				ld a, CUR_BLINK_RATE 
8d72 32 5a ee				ld (input_cur_flash), a 
8d75			 
8d75					; change state 
8d75 3a 59 ee				ld a,(input_cur_onoff) 
8d78 ed 44				neg 
8d7a 32 59 ee				ld (input_cur_onoff),a 
8d7d			 
8d7d			 
8d7d			 
8d7d			 
8d7d					; TODO is cursor visible? 
8d7d					; TODO if so then over write the char at curspos pos with the cursor shape 
8d7d			 
8d7d								 
8d7d			 
8d7d			.inochgstate: 
8d7d 3a 59 ee				ld a,(input_cur_onoff) 
8d80 fe ff				cp 255 
8d82 28 0e				jr z, .skipcursor 
8d84 3a 5e ee				ld a, (input_at_pos) 
8d87 47					ld b, a 
8d88 3a 4f ee				ld a, (input_cursor) 
8d8b 80					add b 
8d8c 11 bb eb				ld de, cursor_shape 
8d8f					 
8d8f cd d0 8a				call str_at_display 
8d92			 
8d92			.skipcursor: 
8d92				if DEBUG_INPUTV2 
8d92			 
8d92					ld a,(input_at_pos) 
8d92					ld hl, LFSRSeed 
8d92					call hexout 
8d92					ld a, (input_cursor) 
8d92					ld hl, LFSRSeed+2 
8d92					call hexout 
8d92					ld a,(input_size) 
8d92					ld hl, LFSRSeed+4 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_onoff) 
8d92					ld hl, LFSRSeed+6 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_flash) 
8d92					ld hl, LFSRSeed+8 
8d92					call hexout 
8d92			 
8d92					ld a,(input_len) 
8d92					ld hl, LFSRSeed+10 
8d92					call hexout 
8d92					ld hl, LFSRSeed+12 
8d92					ld a, 0 
8d92					ld (hl),a 
8d92					ld a, display_row_4 
8d92					ld de, LFSRSeed 
8d92					call str_at_display 
8d92				endif 
8d92 cd e0 8a				call update_display 
8d95			 
8d95					; TODO keyboard processing 
8d95			 
8d95			if BASE_CPM 
8d95					call cin_wait 
8d95			else 
8d95 cd b0 e2				call cin    ; _wait 
8d98			endif 
8d98 fe 00				cp 0 
8d9a ca 3d 8d				jp z, .inmain 
8d9d			 
8d9d fe 0b				cp KEY_LEFT    ; cursor left 
8d9f ca 57 8e				jp z, input_left 
8da2				 
8da2 fe 0c				cp KEY_RIGHT      ; cursor right 
8da4 ca 5e 8e				jp z, input_right 
8da7			 
8da7 fe 0d				cp KEY_CR 
8da9 c8					ret z 
8daa			 
8daa fe 08				cp KEY_BS 
8dac ca cc 8e				jp z, input_delchar 
8daf			 
8daf fe 06				cp KEY_NEXTWORD 
8db1 ca d8 8d				jp z, input_nxtword 
8db4			 
8db4 fe 07				cp KEY_PREVWORD 
8db6 ca ff 8d				jp z, input_prvword 
8db9			 
8db9 fe 0e				cp KEY_HOME    ; jump to start of line 
8dbb 20 08				jr nz, .ikh 
8dbd 3e 00				ld a, 0 
8dbf 32 4f ee				ld (input_cursor), a 
8dc2 ca 3d 8d				jp z, .inmain 
8dc5			.ikh: 
8dc5			 
8dc5 fe 0f				cp KEY_END     ; jump to end of line 
8dc7 20 09				jr nz, .ike 
8dc9 3a 54 ee				ld a, (input_len) 
8dcc 32 4f ee				ld (input_cursor),a 
8dcf ca 3d 8d				jp z, .inmain 
8dd2			.ike: 
8dd2 fe 05			        cp KEY_UP      ; recall last command 
8dd4 c8					ret z 
8dd5			;jr nz, .irec 
8dd5			; TODO next word 
8dd5			; TODO prev word 
8dd5			;  
8dd5			; 
8dd5			;	ld hl, scratch 
8dd5			;	ld de, os_last_cmd 
8dd5			;	call strcpy 
8dd5			;		jp  .inmain 
8dd5			.irec: 
8dd5			;		jr .instr1 
8dd5			 
8dd5			 
8dd5			 
8dd5					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dd5			 
8dd5			; TODO return if any special keys are given 
8dd5			;		ld l, a 
8dd5			;		ld a, 28 ; KEY_F12   ; 27 
8dd5			;		sub l 
8dd5			;		ret m 
8dd5			;		ld a, l 
8dd5					; if no special key then insert as a char 
8dd5			 
8dd5 c3 9e 8e				jp input_inschr 
8dd8			 
8dd8				 
8dd8			input_nxtword: 
8dd8				; jump to start next word after the cursor 
8dd8			 
8dd8			.insknwn:	 
8dd8 cd 94 8e				call input_curptr	 
8ddb 7e					ld a,(hl)	 
8ddc fe 00				cp 0 
8dde ca 3d 8d				jp z, .inmain    ; end of string 
8de1			 
8de1			; if we are on a word, then move off of it 
8de1			 
8de1 fe 20				cp ' ' 
8de3 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de5 21 4f ee				ld hl, input_cursor 
8de8 34					inc (hl) 
8de9 18 ed				jr .insknwn 
8deb			 
8deb			.inspace: 
8deb			 
8deb cd 94 8e				call input_curptr	 
8dee 7e					ld a,(hl)	 
8def fe 00				cp 0 
8df1 ca 3d 8d				jp z, .inmain    ; end of string 
8df4			 
8df4			; if we are on a word, then move off of it 
8df4			 
8df4 fe 20				cp ' ' 
8df6 c2 3d 8d				jp nz, .inmain     ; we are on non space so at next word 
8df9 21 4f ee				ld hl, input_cursor 
8dfc 34					inc (hl) 
8dfd 18 ec				jr .inspace 
8dff			 
8dff			 
8dff			 
8dff			 
8dff			input_prvword: 
8dff				; jump to the start of previous word before the cursor 
8dff			 
8dff			; where are we to start with currently? 
8dff			 
8dff cd 94 8e				call input_curptr	 
8e02 7e					ld a, (hl) 
8e03 fe 20				cp ' ' 
8e05 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e07			 
8e07			 
8e07			 
8e07			.inskpwn:	 
8e07 3a 4f ee				ld a,(input_cursor) 
8e0a fe 00				cp 0 
8e0c ca 3d 8d				jp z, .inmain    ; start of string 
8e0f			 
8e0f			;if we are on a word, then move off of it 
8e0f			 
8e0f cd 94 8e				call input_curptr	 
8e12 7e					ld a, (hl) 
8e13 fe 20				cp ' ' 
8e15 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e17					;jp z, .inmain    ; start of string 
8e17 21 4f ee				ld hl, input_cursor 
8e1a 35					dec (hl) 
8e1b 18 ea				jr .inskpwn 
8e1d			.iwstart: 
8e1d 21 4f ee				ld hl, input_cursor 
8e20 34					inc (hl) 
8e21 c3 3d 8d				jp .inmain 
8e24					 
8e24			 
8e24			.inspacep: 
8e24			 
8e24					;jp .inmain    ; start of string 
8e24			 
8e24			 
8e24			 
8e24 3a 4f ee				ld a,(input_cursor) 
8e27 fe 00				cp 0 
8e29 ca 3d 8d				jp z, .inmain    ; start of string 
8e2c			 
8e2c			; if we are on a word, then move off of it 
8e2c			 
8e2c cd 94 8e				call input_curptr	 
8e2f 7e					ld a, (hl) 
8e30 fe 20				cp ' ' 
8e32 c2 3b 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e35 21 4f ee				ld hl, input_cursor 
8e38 35					dec (hl) 
8e39 18 e9				jr .inspacep 
8e3b			 
8e3b			 
8e3b			.incharp:	 
8e3b					; eat the word to get to the start 
8e3b 3a 4f ee				ld a,(input_cursor) 
8e3e fe 00				cp 0 
8e40 ca 3d 8d				jp z, .inmain    ; start of string 
8e43			 
8e43			; if we are on a word, then move off of it 
8e43			 
8e43 cd 94 8e				call input_curptr	 
8e46 7e					ld a, (hl) 
8e47 fe 20				cp ' ' 
8e49 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e4b 21 4f ee				ld hl, input_cursor 
8e4e 35					dec (hl) 
8e4f 18 ea				jr .incharp 
8e51			.ipwordst: 
8e51					; at space before the prev word so reposition over it 
8e51 21 4f ee				ld hl, input_cursor 
8e54 34					inc (hl) 
8e55 18 b0				jr .inskpwn 
8e57					 
8e57			 
8e57			 
8e57			input_left: 
8e57				; move cursor left 
8e57 21 4f ee			ld hl, input_cursor 
8e5a 35				dec (hl) 
8e5b			;	cp 0 
8e5b			;	jp z, .inmain    ; ignore left as at the start of the string 
8e5b c3 3d 8d			jp .inmain 
8e5e			 
8e5e			input_right: 
8e5e				; move cursor right 
8e5e				 
8e5e				;ld a, (input_size) 
8e5e				;ld b, a 
8e5e 21 4f ee			ld hl, input_cursor 
8e61 34				inc (hl) 
8e62				;dec b 
8e62				;cp 0 
8e62				;jp z, .inmain   ; ignore as at end of the string buffer 
8e62				;ld a, b 
8e62				;inc a 
8e62				;ld (input_cursor), a 
8e62 c3 3d 8d			jp .inmain 
8e65			 
8e65			 
8e65			 
8e65			input_disp_ref: 
8e65				; display the text from start of buffer (ie full refresh) 
8e65 3a 5e ee			ld a, (input_at_pos) 
8e68 2a 61 ee			ld hl,(input_start) 
8e6b eb				ex de, hl 
8e6c cd d0 8a			call str_at_display  
8e6f c9				ret 
8e70			input_disp_oncur: 
8e70				; display the text from cursor position to end of buffer 
8e70				; TODO position start of string at cursor position on screen 
8e70				; TODO draw from that point on 
8e70 3a 4f ee			ld a, (input_cursor) 
8e73 47				ld b, a 
8e74 3a 5e ee			ld a, (input_at_pos) 
8e77 80				add b 
8e78 48				ld c, b     ; save a 
8e79 78				ld a, b     ; inc string start for cursor 
8e7a 2a 61 ee			ld hl,(input_start) 
8e7d cd ea 8c			call addatohl 
8e80 eb				ex de, hl 
8e81 79				ld a, c 
8e82 cd d0 8a			call str_at_display  
8e85 c9				ret 
8e86			 
8e86			input_nxtw: 
8e86				; Find next word 
8e86 c9				ret 
8e87			 
8e87			input_prvw: 
8e87				; Find previous word 
8e87 c9				ret 
8e88			 
8e88			input_lenrem:   
8e88				; Calculate the length of string remaining from current cursor 
8e88				; position to end of buffer (exc null term) 
8e88				 
8e88 3a 4f ee			ld a, (input_cursor) 
8e8b 4f				ld c, a 
8e8c 3a 60 ee			ld a, (input_size) 
8e8f 91				sub c 
8e90 06 00			ld b, 0 
8e92 0d				dec c 
8e93 c9				ret	 
8e94			 
8e94			input_curptr: 
8e94				; calc address of the character under the cursor 
8e94				 
8e94 2a 61 ee			ld hl, (input_start) 
8e97 3a 4f ee			ld a, (input_cursor) 
8e9a cd ea 8c			call addatohl 
8e9d c9				ret 
8e9e			 
8e9e			input_inschr: 
8e9e				; Insert char at cursor position 
8e9e f5				push af   ; save char 
8e9f				;call input_lenrem    ; get bc length of remaining string 
8e9f			 
8e9f				 
8e9f cd 94 8e			call input_curptr 
8ea2			;	ld hl, (input_start) 
8ea2			;	ld a, (input_cursor) 
8ea2			;	call addatohl 
8ea2				;push hl   ; save to come back to 
8ea2			 
8ea2				; shift everything up one to end of buffer 
8ea2			 
8ea2				;push hl 
8ea2				;dec de 
8ea2				;inc de 
8ea2			;	ldir 
8ea2				 
8ea2				;pop hl 
8ea2			 
8ea2				; are we adding to the end of line? 
8ea2			 
8ea2 3a 4f ee			ld a, (input_cursor) 
8ea5 47				ld b, a 
8ea6 3a 54 ee			ld a, (input_len) 
8ea9 b8				cp b 
8eaa 20 09			jr nz, .insmid   ; no, insert in middle of text 
8eac			 
8eac				; tack on the end of the line 
8eac f1				pop af 
8ead 77				ld (hl), a   ; save new char 
8eae 23				inc hl 
8eaf 3e 00			ld a, 0 
8eb1 77				ld (hl), a 
8eb2 c3 5e 8e			jp input_right 
8eb5				 
8eb5			.insmid: 
8eb5				; hl has insertion point so move everything up one to allow for insertion 
8eb5				;call input_shiftright 
8eb5 f1				pop af 
8eb6			 
8eb6			.shufinsmid: 
8eb6 47				ld b, a     ; b contains new char, c prev char at this position  
8eb7 7e				ld a, (hl) 
8eb8			 
8eb8 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eba 28 07			jr z, .endinsmid 
8ebc 4f				ld c, a 
8ebd 78				ld a, b 
8ebe 77				ld (hl), a 
8ebf 23				inc hl 
8ec0 79				ld a, c 
8ec1 18 f3			jr .shufinsmid 
8ec3				 
8ec3			 
8ec3			 
8ec3			 
8ec3			.endinsmid: 
8ec3 78				ld a, b 
8ec4 77				ld (hl), a 
8ec5 23				inc hl 
8ec6 3e 00			ld a, 0 
8ec8 77				ld (hl), a 
8ec9			 
8ec9			 
8ec9			;	ld (hl), a   ; save new char 
8ec9			 
8ec9 c3 5e 8e			jp input_right 
8ecc			 
8ecc			;input_shiftright: 
8ecc			;	; shift text right at cursor, hl has shift start 
8ecc			;	push hl 
8ecc			;	push de 
8ecc			;	push bc 
8ecc			; 
8ecc			; 
8ecc			;	; move to end of string past zero term 
8ecc			;	ld hl,(input_start) 
8ecc			;	ld a, (input_len) 
8ecc			;	call addatohl 
8ecc			;	inc hl 
8ecc			;;	inc hl 
8ecc			;;	inc hl 
8ecc			;	ld a, 0 
8ecc			;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			;	 
8ecc			;;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			; 
8ecc			;	push hl 
8ecc			;	pop de 
8ecc			;	inc de 
8ecc			;	 
8ecc			; 
8ecc			;;	ld hl,(input_start) 
8ecc			;;	ld a, (input_cursor) 
8ecc			;;	call addatohl 
8ecc			; 
8ecc			; 
8ecc			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ecc			;	call input_lenrem    ; get bc length of remaining string 
8ecc			;	;ld a, (input_cursor) 
8ecc			;	;ld c, a 
8ecc			;	ld a, (input_len) 
8ecc			;	cp 2 
8ecc			;	jr z, .iskipzero	 
8ecc			;	;sub c 
8ecc			;	;inc a 
8ecc			;	;ld c, a 
8ecc			;	;ld b, 0 
8ecc			;	inc c 
8ecc			;	inc c 
8ecc			;	; move data 
8ecc			;	lddr 
8ecc			;.iskipzero: 
8ecc			; 
8ecc			;	pop bc 
8ecc			;	pop de 
8ecc			;	pop hl 
8ecc			;	ret	 
8ecc			 
8ecc			input_delchar: 
8ecc				; Delete char at cursor position 
8ecc cd 88 8e			call input_lenrem    ; get bc length of remaining string 
8ecf 2a 61 ee			ld hl, (input_start) 
8ed2 3a 4f ee			ld a, (input_cursor) 
8ed5 cd ea 8c			call addatohl 
8ed8			 
8ed8 e5				push hl 
8ed9 d1				pop de 
8eda 1b				dec de 
8edb			 
8edb			.dl:	 
8edb ed a0			ldi  
8edd 7e				ld a, (hl) 
8ede fe 00			cp 0 
8ee0 28 02			jr z, .dldone 
8ee2 18 f7			jr .dl 
8ee4			.dldone: 
8ee4 ed a0			ldi 
8ee6			 
8ee6 c3 57 8e			jp input_left 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			 
8ee9			 
8ee9			 
8ee9			if EDIT_V1 
8ee9			input_str: 
8ee9			 
8ee9				    	ld (input_at_pos),a      ; save display position to start 
8ee9					add c 
8ee9					ld (input_at_cursor),a	; save draw pos of cursor 
8ee9					ld (input_start), hl     ; save ptr to buffer 
8ee9					ld a, c 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee9					ld a,d 
8ee9				        ld (input_size), a       ; save length of input area 
8ee9					ld a, c 
8ee9					ld (input_cursor),a      ; init cursor start position  
8ee9					ld a,e 
8ee9				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee9					 
8ee9					 
8ee9			 
8ee9			;		ld a,(input_ptr) 
8ee9			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee9			 
8ee9			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee9					; init cursor shape if not set by the cin routines 
8ee9					ld hl, cursor_shape 
8ee9			if BASE_KEV 
8ee9					ld a, 255 
8ee9			else 
8ee9					ld a, '#' 
8ee9			endif 
8ee9					ld (hl), a 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl), a 
8ee9			 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					ld a, 1 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'I' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9			.is1:		; main entry loop 
8ee9			 
8ee9			 
8ee9			 
8ee9					; pause 1ms 
8ee9			 
8ee9					ld a, 1 
8ee9					call aDelayInMS 
8ee9			 
8ee9					; dec flash counter 
8ee9					ld a, (input_cur_flash) 
8ee9					dec a 
8ee9					ld (input_cur_flash), a 
8ee9					cp 0 
8ee9					jr nz, .nochgstate 
8ee9			 
8ee9			 
8ee9					; change state 
8ee9					ld a,(input_cur_onoff) 
8ee9					neg 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			 
8ee9					; reset on change of state 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9			.nochgstate: 
8ee9					 
8ee9					 
8ee9			 
8ee9					; display cursor  
8ee9			 
8ee9			;		ld hl, (input_start) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			 
8ee9					; get char under cursor and replace with cursor 
8ee9			ld hl, (input_ptr) 
8ee9			;		ld a, (hl) 
8ee9			;		ld (input_under_cursor),a 
8ee9			;		ld a, '_' 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					; display string 
8ee9			 
8ee9					ld de, (input_start) 
8ee9					ld a, (input_at_pos) 
8ee9					call str_at_display 
8ee9			;	        call update_display 
8ee9			 
8ee9					; find place to put the cursor 
8ee9			;		add h 
8ee9			;		ld l, display_row_1 
8ee9			;		sub l 
8ee9			; (input_at_pos) 
8ee9					;ld c, a 
8ee9			;		ld a, (input_cursor) 
8ee9			;		ld l, (input_at_pos) 
8ee9			;		;ld b, h 
8ee9			;		add l 
8ee9			;		ld (input_at_cursor),a 
8ee9					;ld l,h 
8ee9			 
8ee9			;		ld h, 0 
8ee9			;		ld l,(input_at_pos) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee9			;		call subafromhl 
8ee9			;		ld a,l 
8ee9			;		ld (input_at_cursor), a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					ld a, (hardware_diag) 
8ee9					cp 0 
8ee9					jr z, .skip_input_diag 
8ee9			 
8ee9					ld a,(input_at_pos) 
8ee9					ld hl, LFSRSeed 
8ee9					call hexout 
8ee9					ld a, (input_cursor) 
8ee9					ld hl, LFSRSeed+2 
8ee9					call hexout 
8ee9					ld a,(input_at_cursor) 
8ee9					ld hl, LFSRSeed+4 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_onoff) 
8ee9					ld hl, LFSRSeed+6 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_flash) 
8ee9					ld hl, LFSRSeed+8 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_len) 
8ee9					ld hl, LFSRSeed+10 
8ee9					call hexout 
8ee9					ld hl, LFSRSeed+12 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9					ld a, display_row_4 
8ee9					ld de, LFSRSeed 
8ee9					call str_at_display 
8ee9					.skip_input_diag: 
8ee9				endif 
8ee9			 
8ee9					; decide on if we are showing the cursor this time round 
8ee9			 
8ee9					ld a, (input_cur_onoff) 
8ee9					cp 255 
8ee9					jr z, .skipcur 
8ee9			 
8ee9			 
8ee9					ld a,(input_at_cursor) 
8ee9					ld de, cursor_shape 
8ee9					call str_at_display 
8ee9			 
8ee9					; save length of current input string 
8ee9					ld hl, (input_start) 
8ee9					ld a, 0 
8ee9					call strlent 
8ee9					ld a,l 
8ee9					ld (input_len),a 
8ee9			 
8ee9			.skipcur: 
8ee9			 
8ee9				        call update_display 
8ee9					 
8ee9			 
8ee9			 
8ee9					; wait 
8ee9				 
8ee9					; TODO loop without wait to flash the cursor and char under cursor	 
8ee9					call cin    ; _wait 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 
8ee9			 
8ee9					; get ptr to char to input into 
8ee9			 
8ee9					ld c,a 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_cursor) 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl 
8ee9					ld a,c 
8ee9			 
8ee9					; replace char under cursor 
8ee9			 
8ee9			;		ld hl, (input_ptr) 
8ee9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee9			;		ld (hl), a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'i' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					cp KEY_HOME 
8ee9					jr nz, .iske 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor),a 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					jp .is1 
8ee9					 
8ee9			.iske:		cp KEY_END 
8ee9					jr nz, .isknw 
8ee9					jp .is1 
8ee9			 
8ee9			.isknw:		cp KEY_NEXTWORD 
8ee9					jr nz, .iskpw 
8ee9			 
8ee9			.isknwm:	ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0 
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .isknwm 
8ee9			 
8ee9			.iskpw:		cp KEY_PREVWORD 
8ee9					jr nz, .iskl 
8ee9			.iskpwm:	 
8ee9					ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0  
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .iskpwm 
8ee9			 
8ee9			 
8ee9			.iskl:		cp KEY_LEFT 
8ee9					jr nz, .isk1 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk1:		cp KEY_RIGHT 
8ee9					jr nz, .isk2 
8ee9			 
8ee9					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee9					ld e,a 
8ee9					ld a, (input_cursor) 
8ee9					cp e 
8ee9					jp z, .is1		; at the end of string so dont go right 
8ee9			 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk2:		cp KEY_UP 
8ee9			 
8ee9					jr nz, .isk3 
8ee9			 
8ee9					; swap last command with the current on 
8ee9			 
8ee9					; move cursor to start of string 
8ee9					ld hl, (input_start) 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					 
8ee9					; swap input and last command buffers 
8ee9			 
8ee9					ld hl, os_cli_cmd 
8ee9					ld de, os_last_cmd 
8ee9					ld b, 255 
8ee9			.swap1:		ld a, (hl) 
8ee9					ld c,a 
8ee9					ld a, (de) 
8ee9					ld (hl), a 
8ee9					ld a,c 
8ee9					ld (de),a 
8ee9					inc hl 
8ee9					inc de 
8ee9					djnz .swap1 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk3:		cp KEY_BS 
8ee9					jr nz, .isk4 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					; hl is source 
8ee9					; de needs to be source - 1 
8ee9			 
8ee9			;		ld a, 0 
8ee9			;		dec hl 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					; shift all data 
8ee9			 
8ee9					push hl 
8ee9					inc hl 
8ee9					pop de 
8ee9					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee9					ld c,a 
8ee9					ld b,0 
8ee9					ldir  
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					; remove char 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld de,.iblank 
8ee9					call str_at_display 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk4:		cp KEY_CR 
8ee9					jr z, .endinput 
8ee9			 
8ee9					; else add the key press to the end 
8ee9			 
8ee9					ld c, a			; save key pressed 
8ee9			 
8ee9					ld a,(hl)		; get what is currently under char 
8ee9			 
8ee9					cp 0			; we are at the end of the string 
8ee9					jr nz, .onchar 
8ee9					 
8ee9					; add a char to the end of the string 
8ee9				 
8ee9					ld (hl),c 
8ee9					inc hl 
8ee9			;		ld a,' ' 
8ee9			;		ld (hl),a 
8ee9			;		inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					dec hl 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc a				; TODO check max string length and scroll  
8ee9					ld (input_cursor), a		; inc cursor pos 
8ee9							 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, '+' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					jp .is1 
8ee9					 
8ee9			 
8ee9			 
8ee9					; if on a char then insert 
8ee9			.onchar: 
8ee9			 
8ee9					; TODO over flow check: make sure insert does not blow out buffer 
8ee9			 
8ee9					; need to do some maths to use lddr 
8ee9			 
8ee9					push hl   ; save char pos 
8ee9					push bc 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_len) 
8ee9					call addatohl  		; end of string 
8ee9					inc hl 
8ee9					inc hl		; past zero term 
8ee9					push hl 
8ee9					inc hl 
8ee9					push hl  
8ee9			 
8ee9								; start and end of lddr set, now how much to move? 
8ee9			 
8ee9							 
8ee9					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee9					ld b,a 
8ee9					ld a,(input_len) 
8ee9					ld e,a 
8ee9					sub b 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9			 
8ee9					ld b,0 
8ee9					ld c,a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'i' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					pop de 
8ee9					pop hl 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'I' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					lddr 
8ee9				 
8ee9			 
8ee9			 
8ee9					; TODO have a key for insert/overwrite mode???? 
8ee9					pop bc 
8ee9					pop hl 
8ee9					ld (hl), c		; otherwise overwrite current char 
8ee9					 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.endinput:	; TODO look for end of string 
8ee9			 
8ee9					; add trailing space for end of token 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a,(input_len) 
8ee9					call addatohl 
8ee9					ld a, ' ' 
8ee9					ld (hl),a 
8ee9					; TODO eof of parse marker 
8ee9			 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					ret 
8ee9			 
8ee9			.iblank: db " ",0 
8ee9			 
8ee9			 
8ee9			input_str_prev:	ld (input_at_pos), a 
8ee9					ld (input_start), hl 
8ee9					ld a,1			; add cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					ld (input_ptr), hl 
8ee9					ld a,d 
8ee9					ld (input_size), a 
8ee9					ld a,0 
8ee9					ld (input_cursor),a 
8ee9			.instr1:	 
8ee9			 
8ee9					; TODO do block cursor 
8ee9					; TODO switch cursor depending on the modifer key 
8ee9			 
8ee9					; update cursor shape change on key hold 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl), a 
8ee9			 
8ee9					; display entered text 
8ee9					ld a,(input_at_pos) 
8ee9			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee9			            	LD   de, (input_start) 
8ee9			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee9			 
8ee9					call cin 
8ee9					cp 0 
8ee9					jr z, .instr1 
8ee9			 
8ee9					; proecess keyboard controls first 
8ee9			 
8ee9					ld hl,(input_ptr) 
8ee9			 
8ee9					cp KEY_CR	 ; pressing enter ends input 
8ee9					jr z, .instrcr 
8ee9			 
8ee9					cp KEY_BS 	; back space 
8ee9					jr nz, .instr2 
8ee9					; process back space 
8ee9			 
8ee9					; TODO stop back space if at start of string 
8ee9					dec hl 
8ee9					dec hl ; to over write cursor 
8ee9					ld a,(cursor_shape) 
8ee9					;ld a,0 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a," " 
8ee9					ld (hl),a 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9			 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr2:	cp KEY_LEFT    ; cursor left 
8ee9					jr nz, .instr3 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9				 
8ee9			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee9					jr nz, .instr4 
8ee9					inc hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee9					jr nz, .instr5 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr5:	cp KEY_END     ; jump to end of line 
8ee9					jr nz, .instr6 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			.instr6:        cp KEY_UP      ; recall last command 
8ee9					jr nz, .instrnew 
8ee9			 
8ee9				ld hl, scratch 
8ee9				ld de, os_last_cmd 
8ee9				call strcpy 
8ee9					jr .instr1 
8ee9			 
8ee9			 
8ee9			.instrnew:	; no special key pressed to see if we have room to store it 
8ee9			 
8ee9					; TODO do string size test 
8ee9			 
8ee9					dec hl ; to over write cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9					jr .instr1 
8ee9			.instrcr:	dec hl		; remove cursor 
8ee9					ld a,' '	; TODO add a trailing space for safety 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					; if at end of line scroll up    
8ee9					; TODO detecting only end of line 4 for scroll up  
8ee9			 
8ee9					;ld   
8ee9			 
8ee9					ret 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			; strcpy hl = dest, de source 
8ee9			 
8ee9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8eea b7			            OR   A              ;Null terminator? 
8eeb c8			            RET  Z              ;Yes, so finished 
8eec 1a					ld a,(de) 
8eed 77					ld (hl),a 
8eee 13			            INC  DE             ;Point to next character 
8eef 23					inc hl 
8ef0 18 f7		            JR   strcpy       ;Repeat 
8ef2 c9					ret 
8ef3			 
8ef3			 
8ef3			; TODO string_at  
8ef3			; pass string which starts with lcd offset address and then null term string 
8ef3			 
8ef3			; TODO string to dec 
8ef3			; TODO string to hex 
8ef3			; TODO byte to string hex 
8ef3			; TODO byte to string dec 
8ef3			 
8ef3			 
8ef3			 
8ef3			; from z80uartmonitor 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef3			; pass hl for where to put the text 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3 c5			hexout:	PUSH BC 
8ef4 f5					PUSH AF 
8ef5 47					LD B, A 
8ef6					; Upper nybble 
8ef6 cb 3f				SRL A 
8ef8 cb 3f				SRL A 
8efa cb 3f				SRL A 
8efc cb 3f				SRL A 
8efe cd 0e 8f				CALL tohex 
8f01 77					ld (hl),a 
8f02 23					inc hl	 
8f03					 
8f03					; Lower nybble 
8f03 78					LD A, B 
8f04 e6 0f				AND 0FH 
8f06 cd 0e 8f				CALL tohex 
8f09 77					ld (hl),a 
8f0a 23					inc hl	 
8f0b					 
8f0b f1					POP AF 
8f0c c1					POP BC 
8f0d c9					RET 
8f0e					 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			tohex: 
8f0e e5					PUSH HL 
8f0f d5					PUSH DE 
8f10 16 00				LD D, 0 
8f12 5f					LD E, A 
8f13 21 1b 8f				LD HL, .DATA 
8f16 19					ADD HL, DE 
8f17 7e					LD A, (HL) 
8f18 d1					POP DE 
8f19 e1					POP HL 
8f1a c9					RET 
8f1b			 
8f1b			.DATA: 
8f1b 30					DEFB	30h	; 0 
8f1c 31					DEFB	31h	; 1 
8f1d 32					DEFB	32h	; 2 
8f1e 33					DEFB	33h	; 3 
8f1f 34					DEFB	34h	; 4 
8f20 35					DEFB	35h	; 5 
8f21 36					DEFB	36h	; 6 
8f22 37					DEFB	37h	; 7 
8f23 38					DEFB	38h	; 8 
8f24 39					DEFB	39h	; 9 
8f25 41					DEFB	41h	; A 
8f26 42					DEFB	42h	; B 
8f27 43					DEFB	43h	; C 
8f28 44					DEFB	44h	; D 
8f29 45					DEFB	45h	; E 
8f2a 46					DEFB	46h	; F 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f2b			;;    subtract $30, if result > 9 then subtract $7 more 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			atohex: 
8f2b d6 30				SUB $30 
8f2d fe 0a				CP 10 
8f2f f8					RET M		; If result negative it was 0-9 so we're done 
8f30 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f32 c9					RET		 
8f33			 
8f33			 
8f33			 
8f33			 
8f33			; Get 2 ASCII characters as hex byte from pointer in hl 
8f33			 
8f33			BYTERD: 
8f33 16 00			LD	D,00h		;Set up 
8f35 cd 3d 8f			CALL	HEXCON		;Get byte and convert to hex 
8f38 87				ADD	A,A		;First nibble so 
8f39 87				ADD	A,A		;multiply by 16 
8f3a 87				ADD	A,A		; 
8f3b 87				ADD	A,A		; 
8f3c 57				LD	D,A		;Save hi nibble in D 
8f3d			HEXCON: 
8f3d 7e				ld a, (hl)		;Get next chr 
8f3e 23				inc hl 
8f3f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f41 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f43 38 02			JR	C,NALPHA	;If so miss next bit 
8f45 d6 07			SUB	007h		;Else convert alpha 
8f47			NALPHA: 
8f47 b2				OR	D		;Add hi nibble back 
8f48 c9				RET			; 
8f49			 
8f49			 
8f49			; 
8f49			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f49			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f49			; characters (0-9a-f) are accepted. 
8f49			; 
8f49			;get_word        push    af 
8f49			;                call    get_byte        ; Get the upper byte 
8f49			;                ld      h, a 
8f49			;                call    get_byte        ; Get the lower byte 
8f49			;                ld      l, a 
8f49			;                pop     af 
8f49			;                ret 
8f49			; 
8f49			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f49			; the routine get_nibble is used only valid characters are accepted - the  
8f49			; input routine only accepts characters 0-9a-f. 
8f49			; 
8f49 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f4a 7e					ld a,(hl) 
8f4b 23					inc hl 
8f4c cd 71 8f		                call    nibble2val      ; Get upper nibble 
8f4f cb 07		                rlc     a 
8f51 cb 07		                rlc     a 
8f53 cb 07		                rlc     a 
8f55 cb 07		                rlc     a 
8f57 47			                ld      b, a            ; Save upper four bits 
8f58 7e					ld a,(hl) 
8f59 cd 71 8f		                call    nibble2val      ; Get lower nibble 
8f5c b0			                or      b               ; Combine both nibbles 
8f5d c1			                pop     bc              ; Restore B (and C) 
8f5e c9			                ret 
8f5f			; 
8f5f			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5f			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5f			; that particular digit. 
8f5f			; 
8f5f			;get_nibble      ld a,(hl)           ; Read a character 
8f5f			;                call    to_upper        ; Convert to upper case 
8f5f			;                call    is_hex          ; Was it a hex digit? 
8f5f			;                jr      nc, get_nibble  ; No, get another character 
8f5f			 ;               call    nibble2val      ; Convert nibble to value 
8f5f			 ;               call    print_nibble 
8f5f			 ;               ret 
8f5f			; 
8f5f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5f			; A valid hexadecimal digit is denoted by a set C flag. 
8f5f			; 
8f5f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5f			;                ret     nc              ; Yes 
8f5f			;                cp      '0'             ; Less than '0'? 
8f5f			;                jr      nc, is_hex_1    ; No, continue 
8f5f			;                ccf                     ; Complement carry (i.e. clear it) 
8f5f			;                ret 
8f5f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5f			;                ret     c               ; Yes 
8f5f			;                cp      'A'             ; Less than 'A'? 
8f5f			;                jr      nc, is_hex_2    ; No, continue 
8f5f			;                ccf                     ; Yes - clear carry and return 
8f5f			;                ret 
8f5f			;is_hex_2        scf                     ; Set carry 
8f5f			;                ret 
8f5f			; 
8f5f			; Convert a single character contained in A to upper case: 
8f5f			; 
8f5f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f61 d8			                ret     c 
8f62 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f64 d0			                ret     nc              ; Nothing to do, either 
8f65 e6 5f		                and     $5f             ; Convert to upper case 
8f67 c9			                ret 
8f68			 
8f68			 
8f68			to_lower: 
8f68			 
8f68			   ; if char is in [A-Z] make it lower case 
8f68			 
8f68			   ; enter : a = char 
8f68			   ; exit  : a = lower case char 
8f68			   ; uses  : af 
8f68			 
8f68 fe 41		   cp 'A' 
8f6a d8			   ret c 
8f6b			    
8f6b fe 5b		   cp 'Z'+1 
8f6d d0			   ret nc 
8f6e			    
8f6e f6 20		   or $20 
8f70 c9			   ret 
8f71			 
8f71			; 
8f71			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f71			; corresponding value in A. 
8f71			; 
8f71 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f73 38 02		                jr      c, nibble2val_1 ; Yes 
8f75 d6 07		                sub     7               ; Adjust for A-F 
8f77 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f79 e6 0f		                and     $f              ; Only return lower 4 bits 
8f7b c9			                ret 
8f7c			; 
8f7c			; Print_nibble prints a single hex nibble which is contained in the lower  
8f7c			; four bits of A: 
8f7c			; 
8f7c			;print_nibble    push    af              ; We won't destroy the contents of A 
8f7c			;                and     $f              ; Just in case... 
8f7c			;                add     a, '0'             ; If we have a digit we are done here. 
8f7c			;                cp      '9' + 1         ; Is the result > 9? 
8f7c			;                jr      c, print_nibble_1 
8f7c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f7c			;print_nibble_1  call    putc            ; Print the nibble and 
8f7c			;                pop     af              ; restore the original value of A 
8f7c			;                ret 
8f7c			;; 
8f7c			;; Send a CR/LF pair: 
8f7c			; 
8f7c			;crlf            push    af 
8f7c			;                ld      a, cr 
8f7c			;                call    putc 
8f7c			;                ld      a, lf 
8f7c			;                call    putc 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_word prints the four hex digits of a word to the serial line. The  
8f7c			; word is expected to be in HL. 
8f7c			; 
8f7c			;print_word      push    hl 
8f7c			;                push    af 
8f7c			;                ld      a, h 
8f7c			;                call    print_byte 
8f7c			;                ld      a, l 
8f7c			;                call    print_byte 
8f7c			;                pop     af 
8f7c			;                pop     hl 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f7c			; The byte to be printed is expected to be in A. 
8f7c			; 
8f7c			;print_byte      push    af              ; Save the contents of the registers 
8f7c			;                push    bc 
8f7c			;                ld      b, a 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                call    print_nibble    ; Print high nibble 
8f7c			;                ld      a, b 
8f7c			;                call    print_nibble    ; Print low nibble 
8f7c			;                pop     bc              ; Restore original register contents 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			fourehexhl:  
8f7c 7e				ld a,(hl) 
8f7d cd 2b 8f			call atohex 
8f80 cb 3f				SRL A 
8f82 cb 3f				SRL A 
8f84 cb 3f				SRL A 
8f86 cb 3f				SRL A 
8f88 47				ld b, a 
8f89 23				inc hl 
8f8a 7e				ld a,(hl) 
8f8b 23				inc hl 
8f8c cd 2b 8f			call atohex 
8f8f 80				add b 
8f90 57				ld d,a 
8f91 7e				ld a,(hl) 
8f92 cd 2b 8f			call atohex 
8f95 cb 3f				SRL A 
8f97 cb 3f				SRL A 
8f99 cb 3f				SRL A 
8f9b cb 3f				SRL A 
8f9d 47				ld b, a 
8f9e 23				inc hl 
8f9f 7e				ld a,(hl) 
8fa0 23				inc hl 
8fa1 cd 2b 8f			call atohex 
8fa4 80				add b 
8fa5 5f				ld e, a 
8fa6 d5				push de 
8fa7 e1				pop hl 
8fa8 c9				ret 
8fa9			 
8fa9			; pass hl. returns z set if the byte at hl is a digit 
8fa9			;isdigithl:  
8fa9			;	push bc 
8fa9			;	ld a,(hl) 
8fa9			;	cp ':' 
8fa9			;	jr nc, .isdf 		; > 
8fa9			;	cp '0' 
8fa9			;	jr c, .isdf		; < 
8fa9			; 
8fa9			;	; TODO find a better way to set z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	cp b 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9			; 
8fa9			;.isdf:	; not digit so clear z 
8fa9			; 
8fa9			;	; TODO find a better way to unset z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	inc b 
8fa9			;	cp b 
8fa9			; 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9				 
8fa9				 
8fa9			 
8fa9			 
8fa9			; pass hl as the four byte address to load 
8fa9			 
8fa9			get_word_hl:  
8fa9 e5				push hl 
8faa cd 49 8f			call get_byte 
8fad				 
8fad 47				ld b, a 
8fae			 
8fae e1				pop hl 
8faf 23				inc hl 
8fb0 23				inc hl 
8fb1			 
8fb1			; TODO not able to handle a-f  
8fb1 7e				ld a,(hl) 
8fb2			;	;cp ':' 
8fb2			;	cp 'g' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp 'G' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp '0' 
8fb2			;	jr c, .single_byte_hl		; < 
8fb2			 
8fb2				;call isdigithl 
8fb2 fe 00			cp 0 
8fb4 28 06			jr z, .single_byte_hl 
8fb6			 
8fb6			.getwhln:   ; hex word so get next byte 
8fb6			 
8fb6 cd 49 8f			call get_byte 
8fb9 6f				ld l, a 
8fba 60				ld h,b 
8fbb c9				ret 
8fbc 68			.single_byte_hl:   ld l,b 
8fbd 26 00				ld h,0 
8fbf c9					ret 
8fc0			 
8fc0			 
8fc0			 
8fc0			 
8fc0 21 60 97			ld hl,asc+1 
8fc3			;	ld a, (hl) 
8fc3			;	call nibble2val 
8fc3 cd 49 8f			call get_byte 
8fc6			 
8fc6			;	call fourehexhl 
8fc6 32 ef e2			ld (scratch+52),a 
8fc9				 
8fc9 21 ed e2			ld hl,scratch+50 
8fcc 22 de e5			ld (os_cur_ptr),hl 
8fcf			 
8fcf c9				ret 
8fd0			 
8fd0			 
8fd0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fd0			 
8fd0			; Decimal Unsigned Version 
8fd0			 
8fd0			;Number in a to decimal ASCII 
8fd0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fd0			;Example: display a=56 as "056" 
8fd0			;input: a = number 
8fd0			;Output: a=0,value of a in the screen 
8fd0			;destroys af,bc (don't know about hl and de) 
8fd0			DispAToASCII: 
8fd0 0e 9c			ld	c,-100 
8fd2 cd dc 8f			call	.Na1 
8fd5 0e f6			ld	c,-10 
8fd7 cd dc 8f			call	.Na1 
8fda 0e ff			ld	c,-1 
8fdc 06 2f		.Na1:	ld	b,'0'-1 
8fde 04			.Na2:	inc	b 
8fdf 81				add	a,c 
8fe0 38 fc			jr	c,.Na2 
8fe2 91				sub	c		;works as add 100/10/1 
8fe3 f5				push af		;safer than ld c,a 
8fe4 78				ld	a,b		;char is in b 
8fe5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe5 f1				pop af		;safer than ld a,c 
8fe6 c9				ret 
8fe7			 
8fe7			; Decimal Signed Version 
8fe7			 
8fe7			; DispA 
8fe7			; -------------------------------------------------------------- 
8fe7			; Converts a signed integer value to a zero-terminated ASCII 
8fe7			; string representative of that value (using radix 10). 
8fe7			; -------------------------------------------------------------- 
8fe7			; INPUTS: 
8fe7			;     HL     Value to convert (two's complement integer). 
8fe7			;     DE     Base address of string destination. (pointer). 
8fe7			; -------------------------------------------------------------- 
8fe7			; OUTPUTS: 
8fe7			;     None 
8fe7			; -------------------------------------------------------------- 
8fe7			; REGISTERS/MEMORY DESTROYED 
8fe7			; AF HL 
8fe7			; -------------------------------------------------------------- 
8fe7			 
8fe7			;DispHLToASCII: 
8fe7			;   push    de 
8fe7			;   push    bc 
8fe7			; 
8fe7			;; Detect sign of HL. 
8fe7			;    bit    7, h 
8fe7			;    jr     z, ._DoConvert 
8fe7			; 
8fe7			;; HL is negative. Output '-' to string and negate HL. 
8fe7			;    ld     a, '-' 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			; 
8fe7			;; Negate HL (using two's complement) 
8fe7			;    xor    a 
8fe7			;    sub    l 
8fe7			;    ld     l, a 
8fe7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe7			;    sbc    a, h 
8fe7			;    ld     h, a 
8fe7			; 
8fe7			;; Convert HL to digit characters 
8fe7			;._DoConvert: 
8fe7			;    ld     b, 0     ; B will count character length of number 
8fe7			;-   ld     a, 10 
8fe7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe7			;    push   af 
8fe7			;    inc    b 
8fe7			;    ld     a, h 
8fe7			;    or     l 
8fe7			;    jr     nz, - 
8fe7			; 
8fe7			;; Retrieve digits from stack 
8fe7			;-   pop    af 
8fe7			;    or     $30 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			;    djnz   - 
8fe7			; 
8fe7			;; Terminate string with NULL 
8fe7			;    xor    a 
8fe7			;    ld     (de), a 
8fe7			; 
8fe7			;    pop    bc 
8fe7			;    pop    de 
8fe7			;    ret 
8fe7			 
8fe7			;Comments 
8fe7			; 
8fe7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe7			;    Note that the output string will not be fixed-width. 
8fe7			; 
8fe7			;Example Usage 
8fe7			; 
8fe7			;    ld    hl, -1004 
8fe7			;    ld    de, OP1 
8fe7			;    call  DispA 
8fe7			;    ld    hl, OP1 
8fe7			;    syscall  PutS 
8fe7			 
8fe7			 
8fe7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe7			 
8fe7			 
8fe7			;Converts an ASCII string to an unsigned 16-bit integer 
8fe7			;Quits when it reaches a non-decimal digit 
8fe7			 
8fe7			string_to_uint16: 
8fe7			atoui_16: 
8fe7			;Input: 
8fe7			;     DE points to the string 
8fe7			;Outputs: 
8fe7			;     HL is the result 
8fe7			;     A is the 8-bit value of the number 
8fe7			;     DE points to the byte after the number 
8fe7			;Destroys: 
8fe7			;     BC 
8fe7			;       if the string is non-empty, BC is HL/10 
8fe7			;Size:  24 bytes 
8fe7			;Speed: 42+d(104+{0,9}) 
8fe7			;       d is the number of digits in the number 
8fe7			;       max is 640 cycles for a 5 digit number 
8fe7			;Assuming no leading zeros: 
8fe7			;1 digit:  146cc 
8fe7			;2 digit:  250cc 
8fe7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe7			;avg: 544.81158447265625cc (544+13297/16384) 
8fe7			;=============================================================== 
8fe7 21 00 00		  ld hl,0 
8fea			.u16a: 
8fea 1a			  ld a,(de) 
8feb d6 30		  sub 30h 
8fed fe 0a		  cp 10 
8fef d0			  ret nc 
8ff0 13			  inc de 
8ff1 44			  ld b,h 
8ff2 4d			  ld c,l 
8ff3 29			  add hl,hl 
8ff4 29			  add hl,hl 
8ff5 09			  add hl,bc 
8ff6 29			  add hl,hl 
8ff7 85			  add a,l 
8ff8 6f			  ld l,a 
8ff9 30 ef		  jr nc,.u16a 
8ffb 24			  inc h 
8ffc c3 ea 8f		  jp .u16a 
8fff			 
8fff			 
8fff			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fff			 
8fff			;written by Zeda 
8fff			;Converts a 16-bit unsigned integer to an ASCII string. 
8fff			 
8fff			uitoa_16: 
8fff			;Input: 
8fff			;   DE is the number to convert 
8fff			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fff			;Output: 
8fff			;   HL points to the null-terminated ASCII string 
8fff			;      NOTE: This isn't necessarily the same as the input HL. 
8fff d5			  push de 
9000 c5			  push bc 
9001 f5			  push af 
9002 eb			  ex de,hl 
9003			 
9003 01 f0 d8		  ld bc,-10000 
9006 3e 2f		  ld a,'0'-1 
9008 3c			  inc a 
9009 09			  add hl,bc  
900a 38 fc		   jr c,$-2 
900c 12			  ld (de),a 
900d 13			  inc de 
900e			 
900e 01 e8 03		  ld bc,1000 
9011 3e 3a		  ld a,'9'+1 
9013 3d			  dec a  
9014 09			  add hl,bc  
9015 30 fc		   jr nc,$-2 
9017 12			  ld (de),a 
9018 13			  inc de 
9019			 
9019 01 9c ff		  ld bc,-100 
901c 3e 2f		  ld a,'0'-1 
901e 3c			  inc a  
901f 09			  add hl,bc  
9020 38 fc		   jr c,$-2 
9022 12			  ld (de),a 
9023 13			  inc de 
9024			 
9024 7d			  ld a,l 
9025 26 3a		  ld h,'9'+1 
9027 25			  dec h  
9028 c6 0a		  add a,10  
902a 30 fb		   jr nc,$-3 
902c c6 30		  add a,'0' 
902e eb			  ex de,hl 
902f 72			  ld (hl),d 
9030 23			  inc hl 
9031 77			  ld (hl),a 
9032 23			  inc hl 
9033 36 00		  ld (hl),0 
9035			 
9035			;Now strip the leading zeros 
9035 0e fa		  ld c,-6 
9037 09			  add hl,bc 
9038 3e 30		  ld a,'0' 
903a 23			  inc hl  
903b be			  cp (hl)  
903c 28 fc		  jr z,$-2 
903e			 
903e			;Make sure that the string is non-empty! 
903e 7e			  ld a,(hl) 
903f b7			  or a 
9040 20 01		  jr nz,.atoub 
9042 2b			  dec hl 
9043			.atoub: 
9043			 
9043 f1			  pop af 
9044 c1			  pop bc 
9045 d1			  pop de 
9046 c9			  ret 
9047			 
9047			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9047			 
9047			toUpper: 
9047			;A is the char. 
9047			;If A is a lowercase letter, this sets it to the matching uppercase 
9047			;18cc or 30cc or 41cc 
9047			;avg: 26.75cc 
9047 fe 61		  cp 'a' 
9049 d8			  ret c 
904a fe 7b		  cp 'z'+1 
904c d0			  ret nc 
904d d6 20		  sub 'a'-'A' 
904f c9			  ret 
9050			 
9050			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9050			 
9050			; String Length 
9050			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9050			 
9050			; Get the length of the null-terminated string starting at $8000 hl 
9050			;    LD     HL, $8000 
9050			 
9050			strlenz: 
9050			 
9050 af			    XOR    A               ; Zero is the value we are looking for. 
9051 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9052 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9053			                           ; 65, 536 bytes (the entire addressable memory space). 
9053 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9055			 
9055			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9055 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9056 6f			    LD     L, A             ; number of bytes 
9057 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9059 2b			    DEC    HL              ; Compensate for null. 
905a c9				ret 
905b			 
905b			; Get the length of the A terminated string starting at $8000 hl 
905b			;    LD     HL, $8000 
905b			 
905b			strlent: 
905b			 
905b			                  ; A is the value we are looking for. 
905b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905f			                           ; 65, 536 bytes (the entire addressable memory space). 
905f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9061			 
9061			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9061 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9063 2e 00		    LD     L, 0             ; number of bytes 
9065 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9067 2b			    DEC    HL              ; Compensate for null. 
9068 c9				ret 
9069			 
9069			 
9069			;Comparing Strings 
9069			 
9069			;IN    HL     Address of string1. 
9069			;      DE     Address of string2. 
9069			 
9069			; doc given but wrong??? 
9069			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9069			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9069			; tested 
9069			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9069			 
9069			strcmp_old: 
9069 e5			    PUSH   HL 
906a d5			    PUSH   DE 
906b			 
906b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
906c be			    CP     (HL)            ; (want to minimize work). 
906d 38 01		    JR     C, Str1IsBigger 
906f 7e			    LD     A, (HL) 
9070			 
9070			Str1IsBigger: 
9070 4f			    LD     C, A             ; Put length in BC 
9071 06 00		    LD     B, 0 
9073 13			    INC    DE              ; Increment pointers to meat of string. 
9074 23			    INC    HL 
9075			 
9075			CmpLoop: 
9075 1a			    LD     A, (DE)          ; Compare bytes. 
9076 ed a1		    CPI 
9078 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
907a 13			    INC    DE              ; Update pointer. 
907b ea 75 90		    JP     PE, CmpLoop 
907e			 
907e d1			    POP    DE 
907f e1			    POP    HL 
9080 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9081 be			    CP     (HL) 
9082 c9			    RET 
9083			 
9083			NoMatch: 
9083 2b			    DEC    HL 
9084 be			    CP     (HL)            ; Compare again to affect carry. 
9085 d1			    POP    DE 
9086 e1			    POP    HL 
9087 c9			    RET 
9088			 
9088			;; test strmp 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr z, .z1 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z1: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr z, .z2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr c, .c1 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c1: 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr c, .c2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;	NEXTW 
9088			;.str1:   db "string1",0 
9088			;.str2:   db "string2",0 
9088			 
9088			; only care about direct match or not 
9088			; hl and de strings 
9088			; zero set if the same 
9088			 
9088			strcmp: 
9088 1a				ld a, (de) 
9089 be				cp (hl) 
908a 28 02			jr z, .ssame 
908c b7				or a 
908d c9				ret 
908e			 
908e			.ssame:  
908e fe 00			cp 0 
9090 c8				ret z 
9091			 
9091 23				inc hl 
9092 13				inc de 
9093 18 f3			jr strcmp 
9095				 
9095				 
9095			 
9095			;Copyright (c) 2014, Luke Maurits 
9095			;All rights reserved. 
9095			; 
9095			;Redistribution and use in source and binary forms, with or without 
9095			;modification, are permitted provided that the following conditions are met: 
9095			; 
9095			;* Redistributions of source code must retain the above copyright notice, this 
9095			;  list of conditions and the following disclaimer. 
9095			; 
9095			;* Redistributions in binary form must reproduce the above copyright notice, 
9095			;  this list of conditions and the following disclaimer in the documentation 
9095			;  and/or other materials provided with the distribution. 
9095			; 
9095			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9095			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9095			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9095			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9095			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9095			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9095			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9095			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9095			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9095			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9095			 
9095			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9095			 
9095			StrictStrCmp: 
9095				; Load next chars of each string 
9095 1a				ld a, (de) 
9096 47				ld b, a 
9097 7e				ld a, (hl) 
9098				; Compare 
9098 b8				cp b 
9099				; Return non-zero if chars don't match 
9099 c0				ret nz 
909a				; Check for end of both strings 
909a fe 00			cp "\0" 
909c				; Return if strings have ended 
909c c8				ret z 
909d				; Otherwise, advance to next chars 
909d 23				inc hl 
909e 13				inc de 
909f 18 f4			jr StrictStrCmp 
90a1			 
90a1			;end 
90a1			; eof 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
# End of file firmware_strings.asm
90a1			include "firmware_memory.asm"   ; malloc and free  
90a1			 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			.mallocsize: db "Wants malloc >256",0 
90a1			.mallocasize: db "MALLOC gives >256",0 
90a1			.malloczero: db "MALLOC gives zero",0 
90a1			 
90a1			malloc_guard_zerolen: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1				ld de, 0 
90a1			        call cmp16 
90a1				jr nz, .lowalloz 
90a1			 
90a1				push hl 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .malloczero 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1				call bp_on 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1			.lowalloz: 
90a1			 
90a1			 
90a1				pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_entry: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowalloc 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocsize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdone 
90a1			.lowalloc: 
90a1			 
90a1			 
90a1				pop hl 
90a1			.lowdone:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_exit: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowallocx 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocasize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdonex 
90a1			.lowallocx: 
90a1			 
90a1				pop hl 
90a1			.lowdonex:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			endif 
90a1			 
90a1			if MALLOC_2 
90a1			; Z80 Malloc and Free Functions 
90a1			 
90a1			; Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc: 
90a1				 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_entry 
90a1			endif 
90a1			 
90a1			 
90a1			 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "mal" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of size into A 
90a1			    or h               ; Check if size is zero 
90a1			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
90a1			 
90a1			    ; Allocate memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma1" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    call malloc_internal ; Call internal malloc function 
90a1			    pop af             ; Restore AF register 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret                ; Return 
90a1			 
90a1			; Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free: 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of pointer into A 
90a1			    or h               ; Check if pointer is NULL 
90a1			    jp z, free_exit    ; If pointer is NULL, exit 
90a1			 
90a1			    ; Free memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1			    call free_internal  ; Call internal free function 
90a1			    pop af             ; Restore AF register 
90a1			    ret                ; Return 
90a1			 
90a1			; Internal Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc_internal: 
90a1			    ld bc, 2           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to requested size 
90a1			    ex de, hl          ; Save total size in DE, and keep it in HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			 
90a1			    ; Search for free memory block 
90a1			    ld de, (heap_end)  ; Load end of heap into DE 
90a1			    ld bc, 0           ; Initialize counter 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			malloc_search_loop: 
90a1			    ; Check if current block is free 
90a1			    ld a, (hl)         ; Load current block's status (free or used) 
90a1			    cp 0               ; Compare with zero (free) 
90a1			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
90a1			 
90a1			    ; Check if current block is large enough 
90a1			    ld a, (hl+1)       ; Load high byte of block size 
90a1			    cp l               ; Compare with low byte of requested size 
90a1			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
90a1			 
90a1			    ld a, (hl+2)       ; Load low byte of block size 
90a1			    cp h               ; Compare with high byte of requested size 
90a1			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
90a1			 
90a1			    ; Mark block as used 
90a1			    ld (hl), 0xFF      ; Set status byte to indicate used block 
90a1			 
90a1			    ; Calculate remaining space in block 
90a1			    ld bc, 0           ; Clear BC 
90a1			    add hl, bc         ; Increment HL to point to start of data block 
90a1			    add hl, de         ; HL = HL + DE (total size) 
90a1			    ld bc, 1           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to start of data block 
90a1			 
90a1			    ; Save pointer to allocated block in HL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma5" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			malloc_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3           ; Size of management overhead 
90a1			    add hl, bc         ; Move to the next block 
90a1			    inc de             ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e            ; Load low byte of heap end address 
90a1			    cp (hl)            ; Compare with low byte of current address 
90a1			    jr nz, malloc_search_loop  ; If not equal, continue searching 
90a1			    ld a, d            ; Load high byte of heap end address 
90a1			    cp 0               ; Check if it's zero (end of memory) 
90a1			    jr nz, malloc_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, allocation failed 
90a1			    xor a              ; Set result to NULL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma6" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			malloc_exit: 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma7" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			; Internal Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free_internal: 
90a1			    ld de, (heap_start) ; Load start of heap into DE 
90a1			    ld bc, 0            ; Initialize counter 
90a1			 
90a1			free_search_loop: 
90a1			    ; Check if current block contains the pointer 
90a1			    ld a, l             ; Load low byte of pointer 
90a1			    cp (hl+1)           ; Compare with high byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			    ld a, h             ; Load high byte of pointer 
90a1			    cp (hl+2)           ; Compare with low byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			 
90a1			    ; Mark block as free 
90a1			    ld (hl), 0          ; Set status byte to indicate free block 
90a1			    ret                 ; Return 
90a1			 
90a1			free_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3            ; Size of management overhead 
90a1			    add hl, bc          ; Move to the next block 
90a1			    inc de              ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e             ; Load low byte of heap end address 
90a1			    cp (hl)             ; Compare with low byte of current address 
90a1			    jr nz, free_search_loop  ; If not equal, continue searching 
90a1			    ld a, d             ; Load high byte of heap end address 
90a1			    cp 0                ; Check if it's zero (end of memory) 
90a1			    jr nz, free_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, pointer is not found in heap 
90a1			    ret 
90a1			 
90a1			free_exit: 
90a1			    ret                 ; Return 
90a1			 
90a1			; Define heap start and end addresses 
90a1			;heap_start:    .dw 0xC000   ; Start of heap 
90a1			;heap_end:      .dw 0xE000   ; End of heap 
90a1			 
90a1			endif 
90a1			 
90a1			 
90a1			if MALLOC_1 
90a1			 
90a1			 
90a1			 
90a1			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
90a1			 
90a1			;moved to firmware.asm 
90a1			;heap_start        .equ  0x9000      ; Starting address of heap 
90a1			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90a1			 
90a1			;      .org 0 
90a1			;      jp    main 
90a1			 
90a1			 
90a1			;      .org  0x100 
90a1			;main: 
90a1			;      ld    HL, 0x8100 
90a1			;      ld    SP, HL 
90a1			; 
90a1			;      call  heap_init 
90a1			; 
90a1			;      ; Make some allocations 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9004 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9014 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9024 
90a1			; 
90a1			;      ; Free some allocations 
90a1			;      ld    HL, 0x9014 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9004 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9024 
90a1			;      call  free 
90a1			; 
90a1			; 
90a1			;      halt 
90a1			 
90a1			 
90a1			;------------------------------------------------------------------------------ 
90a1			;     heap_init                                                               : 
90a1			;                                                                             : 
90a1			; Description                                                                 : 
90a1			;     Initialise the heap and make it ready for malloc and free operations.   : 
90a1			;                                                                             : 
90a1			;     The heap is maintained as a linked list, starting with an initial       : 
90a1			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90a1			;     the first free block in the heap. Each block then points to the next    : 
90a1			;     free block within the heap, and the free list ends at the first block   : 
90a1			;     with a null pointer to the next free block.                             : 
90a1			;                                                                             : 
90a1			; Parameters                                                                  : 
90a1			;     Inputs are compile-time only. Two defines which specify the starting    : 
90a1			;     address of the heap and its size are required, along with a memory      : 
90a1			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90a1			;     principally stores a pointer to the first free block in the heap.       : 
90a1			;                                                                             : 
90a1			; Returns                                                                     : 
90a1			;     Nothing                                                                 : 
90a1			;------------------------------------------------------------------------------ 
90a1			heap_init: 
90a1 e5			      push  HL 
90a2			 
90a2			      ; Initialise free list struct 
90a2 21 ce e2		      ld    HL, heap_start 
90a5 22 c9 e2		      ld    (free_list), HL 
90a8 21 00 00		      ld    HL, 0 
90ab 22 cb e2		      ld    (free_list+2), HL 
90ae			 
90ae			      ; Insert first free block at bottom of heap, consumes entire heap 
90ae 21 92 e2		      ld    HL, heap_start+heap_size-4 
90b1 22 ce e2		      ld    (heap_start), HL        ; Next block (end of free list) 
90b4 21 c4 ff		      ld    HL, heap_size-4 
90b7 22 d0 e2		      ld    (heap_start+2), HL      ; Block size 
90ba			 
90ba			      ; Insert end of free list block at top of heap - two null words will 
90ba			      ; terminate the free list 
90ba 21 00 00		      ld    HL, 0 
90bd 22 94 e2		      ld    (heap_start+heap_size-2), HL 
90c0 22 92 e2		      ld    (heap_start+heap_size-4), HL 
90c3			 
90c3 e1			      pop   HL 
90c4			 
90c4 c9			      ret 
90c5			 
90c5			 
90c5			;------------------------------------------------------------------------------ 
90c5			;     malloc                                                                  : 
90c5			;                                                                             : 
90c5			; Description                                                                 : 
90c5			;     Allocates the wanted space from the heap and returns the address of the : 
90c5			;     first useable byte of the allocation.                                   : 
90c5			;                                                                             : 
90c5			;     Allocations can happen in one of two ways:                              : 
90c5			;                                                                             : 
90c5			;     1. A free block may be found which is the exact size wanted. In this    : 
90c5			;        case the block is removed from the free list and retuedn to the      : 
90c5			;        caller.                                                              : 
90c5			;     2. A free block may be found which is larger than the size wanted. In   : 
90c5			;        this case, the larger block is split into two. The first portion of  : 
90c5			;        this block will become the requested space by the malloc call and    : 
90c5			;        is returned to the caller. The second portion becomes a new free     : 
90c5			;        block, and the free list is adjusted to maintain continuity via this : 
90c5			;        newly created block.                                                 : 
90c5			;                                                                             : 
90c5			;     malloc does not set any initial value in the allocated space, the       : 
90c5			;     caller is required to do this as required.                              : 
90c5			;                                                                             : 
90c5			;     This implementation of malloc uses the stack exclusively, and is        : 
90c5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c5			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c5			;     to avoid the use of malloc inside ISRs in general.                      : 
90c5			;                                                                             : 
90c5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c5			;                                                                             : 
90c5			; Parameters                                                                  : 
90c5			;     HL  Number of bytes wanted                                              : 
90c5			;                                                                             : 
90c5			; Returns                                                                     : 
90c5			;     HL  Address of the first useable byte of the allocation                 : 
90c5			;                                                                             : 
90c5			; Flags                                                                       : 
90c5			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c5			;                                                                             : 
90c5			; Stack frame                                                                 : 
90c5			;       |             |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     BC      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     DE      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     IX      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |  prev_free  |                                                       : 
90c5			;   +4  +-------------+                                                       : 
90c5			;       |  this_free  |                                                       : 
90c5			;   +2  +-------------+                                                       : 
90c5			;       |  next_free  |                                                       : 
90c5			;   +0  +-------------+                                                       : 
90c5			;       |             |                                                       : 
90c5			;                                                                             : 
90c5			;------------------------------------------------------------------------------ 
90c5			 
90c5			 
90c5			;malloc: 
90c5			; 
90c5			;	SAVESP ON 1 
90c5			; 
90c5			;	call malloc_code 
90c5			; 
90c5			;	CHECKSP ON 1 
90c5			;	ret 
90c5			 
90c5			 
90c5			malloc: 
90c5 c5			      push  BC 
90c6 d5			      push  DE 
90c7 dd e5		      push  IX 
90c9			if DEBUG_FORTH_MALLOC_HIGH 
90c9			call malloc_guard_entry 
90c9			endif 
90c9			 
90c9					if DEBUG_FORTH_MALLOC 
90c9						DMARK "mal" 
90c9						CALLMONITOR 
90c9					endif 
90c9 7c			      ld    A, H                    ; Exit if no space requested 
90ca b5			      or    L 
90cb ca 8a 91		      jp    Z, malloc_early_exit 
90ce			 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			; 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			 
90ce			 
90ce			 
90ce			 
90ce					if DEBUG_FORTH_MALLOC 
90ce						DMARK "maA" 
90ce						CALLMONITOR 
90ce					endif 
90ce			      ; Set up stack frame 
90ce eb			      ex    DE, HL 
90cf 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90d2 39			      add   HL, SP 
90d3 f9			      ld    SP, HL 
90d4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d8 dd 39		      add   IX, SP 
90da			 
90da			      ; Setup initial state 
90da 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90dd 19			      add   HL, DE 
90de			 
90de 44			      ld    B, H                    ; Move want to BC 
90df 4d			      ld    C, L 
90e0			 
90e0 21 c9 e2		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e3 dd 75 04		      ld    (IX+4), L 
90e6 dd 74 05		      ld    (IX+5), H 
90e9			 
90e9 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90ea 23			      inc   HL 
90eb 56			      ld    D, (HL) 
90ec dd 73 02		      ld    (IX+2), E 
90ef dd 72 03		      ld    (IX+3), D 
90f2 eb			      ex    DE, HL                  ; this_free ptr into HL 
90f3			 
90f3					if DEBUG_FORTH_MALLOC 
90f3						DMARK "maB" 
90f3						CALLMONITOR 
90f3					endif 
90f3			      ; Loop through free block list to find some space 
90f3			malloc_find_space: 
90f3 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f4 23			      inc   HL 
90f5 56			      ld    D, (HL) 
90f6			 
90f6 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f7 b3			      or    E 
90f8 ca 84 91		      jp    Z, malloc_no_space 
90fb			 
90fb dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fe dd 72 01		      ld    (IX+1), D 
9101			 
9101			      ; Does this block have enough space to make the allocation? 
9101 23			      inc   HL                      ; Load free block size into DE 
9102 5e			      ld    E, (HL) 
9103 23			      inc   HL 
9104 56			      ld    D, (HL) 
9105			 
9105 eb			      ex    DE, HL                  ; Check size of block against want 
9106 b7			      or    A                       ; Ensure carry flag clear 
9107 ed 42		      sbc   HL, BC 
9109 e5			      push  HL                      ; Store the result for later (new block size) 
910a			 
910a ca 59 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910d 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910f			 
910f			      ; this_free block is not big enough, setup ptrs to test next free block 
910f e1			      pop   HL                      ; Discard previous result 
9110			 
9110 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9113 dd 66 03		      ld    H, (IX+3) 
9116 dd 75 04		      ld    (IX+4), L 
9119 dd 74 05		      ld    (IX+5), H 
911c			 
911c dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911f dd 66 01		      ld    H, (IX+1) 
9122 dd 75 02		      ld    (IX+2), L 
9125 dd 74 03		      ld    (IX+3), H 
9128			 
9128					if DEBUG_FORTH_MALLOC 
9128						DMARK "MA>" 
9128						CALLMONITOR 
9128					endif 
9128 18 c9		      jr    malloc_find_space 
912a			 
912a			      ; split a bigger block into two - requested size and remaining size 
912a			malloc_alloc_split: 
912a					if DEBUG_FORTH_MALLOC 
912a						DMARK "MAs" 
912a						CALLMONITOR 
912a					endif 
912a eb			      ex    DE, HL                  ; Calculate address of new free block 
912b 2b			      dec   HL 
912c 2b			      dec   HL 
912d 2b			      dec   HL 
912e 09			      add   HL, BC 
912f			 
912f			      ; Create a new block and point it at next_free 
912f dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9132 dd 56 01		      ld    D, (IX+1) 
9135			 
9135 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9136 23			      inc   HL 
9137 72			      ld    (HL), D 
9138			 
9138 d1			      pop   DE                      ; Store size of new block into new block 
9139 23			      inc   HL 
913a 73			      ld    (HL), E 
913b 23			      inc   HL 
913c 72			      ld    (HL), D 
913d			 
913d			      ; Update this_free ptr to point to new block 
913d 2b			      dec   HL 
913e 2b			      dec   HL 
913f 2b			      dec   HL 
9140			 
9140 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9143 dd 56 03		      ld    D, (IX+3) 
9146			 
9146 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9149 dd 74 03		      ld    (IX+3), H 
914c			 
914c			      ; Modify this_free block to be allocation 
914c eb			      ex    DE, HL 
914d af			      xor   A                       ; Null the next block ptr of allocated block 
914e 77			      ld    (HL), A 
914f 23			      inc   HL 
9150 77			      ld    (HL), A 
9151			 
9151 23			      inc   HL                      ; Store want size into allocated block 
9152 71			      ld    (HL), C 
9153 23			      inc   HL 
9154 70			      ld    (HL), B 
9155 23			      inc   HL 
9156 e5			      push  HL                      ; Address of allocation to return 
9157			 
9157 18 19		      jr    malloc_update_links 
9159			 
9159			malloc_alloc_fit: 
9159 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
915a			 
915a					if DEBUG_FORTH_MALLOC 
915a						DMARK "MAf" 
915a						CALLMONITOR 
915a					endif 
915a			      ; Modify this_free block to be allocation 
915a eb			      ex    DE, HL 
915b 2b			      dec   HL 
915c 2b			      dec   HL 
915d 2b			      dec   HL 
915e			 
915e af			      xor   A                       ; Null the next block ptr of allocated block 
915f 77			      ld    (HL), A 
9160 23			      inc   HL 
9161 77			      ld    (HL), A 
9162			 
9162 23			      inc   HL                      ; Store address of allocation to return 
9163 23			      inc   HL 
9164 23			      inc   HL 
9165 e5			      push  HL 
9166			 
9166			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9166 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9169 dd 66 01		      ld    H, (IX+1) 
916c			 
916c dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916f dd 74 03		      ld    (IX+3), H 
9172			 
9172			 
9172			malloc_update_links: 
9172			      ; Update prev_free ptr to point to this_free 
9172 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9175 dd 66 05		      ld    H, (IX+5) 
9178			 
9178 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
917b dd 56 03		      ld    D, (IX+3) 
917e			 
917e 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917f 23			      inc   HL 
9180 72			      ld    (HL), D 
9181			 
9181					if DEBUG_FORTH_MALLOC 
9181						DMARK "Mul" 
9181						CALLMONITOR 
9181					endif 
9181			      ; Clear the Z flag to indicate successful allocation 
9181 7a			      ld    A, D 
9182 b3			      or    E 
9183			 
9183 d1			      pop   DE                      ; Address of allocation 
9184					if DEBUG_FORTH_MALLOC 
9184						DMARK "MAu" 
9184						CALLMONITOR 
9184					endif 
9184			 
9184			malloc_no_space: 
9184 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9187 39			      add   HL, SP 
9188 f9			      ld    SP, HL 
9189			 
9189 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAN" 
918a						CALLMONITOR 
918a					endif 
918a			 
918a			malloc_early_exit: 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAx" 
918a						CALLMONITOR 
918a					endif 
918a dd e1		      pop   IX 
918c d1			      pop   DE 
918d c1			      pop   BC 
918e			 
918e			if DEBUG_FORTH_MALLOC_HIGH 
918e			call malloc_guard_exit 
918e			call malloc_guard_zerolen 
918e			endif 
918e c9			      ret 
918f			 
918f			 
918f			;------------------------------------------------------------------------------ 
918f			;     free                                                                    : 
918f			;                                                                             : 
918f			; Description                                                                 : 
918f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918f			;     returned by malloc, otherwise the behaviour is undefined.               : 
918f			;                                                                             : 
918f			;     Where possible, directly adjacent free blocks will be merged together   : 
918f			;     into larger blocks to help ensure that the heap does not become         : 
918f			;     excessively fragmented.                                                 : 
918f			;                                                                             : 
918f			;     free does not clear or set any other value into the freed space, and    : 
918f			;     therefore its contents may be visible through subsequent malloc's. The  : 
918f			;     caller should clear the freed space as required.                        : 
918f			;                                                                             : 
918f			;     This implementation of free uses the stack exclusively, and is          : 
918f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918f			;     advisable to disable interrupts before calling free, and recommended    : 
918f			;     to avoid the use of free inside ISRs in general.                        : 
918f			;                                                                             : 
918f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918f			;                                                                             : 
918f			; Parameters                                                                  : 
918f			;     HL  Pointer to address of first byte of allocation to be freed          : 
918f			;                                                                             : 
918f			; Returns                                                                     : 
918f			;     Nothing                                                                 : 
918f			;                                                                             : 
918f			; Stack frame                                                                 : 
918f			;       |             |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     BC      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     DE      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     IX      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |  prev_free  |                                                       : 
918f			;   +2  +-------------+                                                       : 
918f			;       |  next_free  |                                                       : 
918f			;   +0  +-------------+                                                       : 
918f			;       |             |                                                       : 
918f			;                                                                             : 
918f			;------------------------------------------------------------------------------ 
918f			free: 
918f c5			      push  BC 
9190 d5			      push  DE 
9191 dd e5		      push  IX 
9193			 
9193 7c			      ld    A, H                    ; Exit if ptr is null 
9194 b5			      or    L 
9195 ca 59 92		      jp    Z, free_early_exit 
9198			 
9198			      ; Set up stack frame 
9198 eb			      ex    DE, HL 
9199 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
919c 39			      add   HL, SP 
919d f9			      ld    SP, HL 
919e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91a2 dd 39		      add   IX, SP 
91a4			 
91a4			      ; The address in HL points to the start of the useable allocated space, 
91a4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a4			      ; address of the block itself. 
91a4 eb			      ex    DE, HL 
91a5 11 fc ff		      ld    DE, -4 
91a8 19			      add   HL, DE 
91a9			 
91a9			      ; An allocated block must have a null next block pointer in it 
91a9 7e			      ld    A, (HL) 
91aa 23			      inc   HL 
91ab b6			      or    (HL) 
91ac c2 54 92		      jp    NZ, free_done 
91af			 
91af 2b			      dec   HL 
91b0			 
91b0 44			      ld    B, H                    ; Copy HL to BC 
91b1 4d			      ld    C, L 
91b2			 
91b2			      ; Loop through the free list to find the first block with an address 
91b2			      ; higher than the block being freed 
91b2 21 c9 e2		      ld    HL, free_list 
91b5			 
91b5			free_find_higher_block: 
91b5 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b6 23			      inc   HL 
91b7 56			      ld    D, (HL) 
91b8 2b			      dec   HL 
91b9			 
91b9 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91bc dd 72 01		      ld    (IX+1), D 
91bf dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91c2 dd 74 03		      ld    (IX+3), H 
91c5			 
91c5 78			      ld    A, B                    ; Check if DE is greater than BC 
91c6 ba			      cp    D                       ; Compare MSB first 
91c7 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c9 30 04		      jr    NC, free_find_higher_block_skip 
91cb 79			      ld    A, C 
91cc bb			      cp    E                       ; Then compare LSB 
91cd 38 08		      jr    C, free_found_higher_block 
91cf			 
91cf			free_find_higher_block_skip: 
91cf 7a			      ld    A, D                    ; Reached the end of the free list? 
91d0 b3			      or    E 
91d1 ca 54 92		      jp    Z, free_done 
91d4			 
91d4 eb			      ex    DE, HL 
91d5			 
91d5 18 de		      jr    free_find_higher_block 
91d7			 
91d7			free_found_higher_block: 
91d7			      ; Insert freed block between prev and next free blocks 
91d7 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d8 23			      inc   HL 
91d9 70			      ld    (HL), B 
91da			 
91da 60			      ld    H, B                    ; Point freed block at next free block 
91db 69			      ld    L, C 
91dc 73			      ld    (HL), E 
91dd 23			      inc   HL 
91de 72			      ld    (HL), D 
91df			 
91df			      ; Check if the freed block is adjacent to the next free block 
91df 23			      inc   HL                      ; Load size of freed block into HL 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3 eb			      ex    DE, HL 
91e4			 
91e4 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e5			 
91e5 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e8 dd 56 01		      ld    D, (IX+1) 
91eb			 
91eb b7			      or    A                       ; Clear the carry flag 
91ec ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91ee 20 22		      jr    NZ, free_check_adjacent_to_prev 
91f0			 
91f0			      ; Freed block is adjacent to next, merge into one bigger block 
91f0 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91f1 5e			      ld    E, (HL) 
91f2 23			      inc   HL 
91f3 56			      ld    D, (HL) 
91f4 e5			      push  HL                      ; Save ptr to next block for later 
91f5			 
91f5 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f6 69			      ld    L, C 
91f7 73			      ld    (HL), E 
91f8 23			      inc   HL 
91f9 72			      ld    (HL), D 
91fa			 
91fa e1			      pop   HL                      ; Restore ptr to next block 
91fb 23			      inc   HL                      ; Load size of next block into DE 
91fc 5e			      ld    E, (HL) 
91fd 23			      inc   HL 
91fe 56			      ld    D, (HL) 
91ff d5			      push  DE                      ; Save next block size for later 
9200			 
9200 60			      ld    H, B                    ; Load size of freed block into HL 
9201 69			      ld    L, C 
9202 23			      inc   HL 
9203 23			      inc   HL 
9204 5e			      ld    E, (HL) 
9205 23			      inc   HL 
9206 56			      ld    D, (HL) 
9207 eb			      ex    DE, HL 
9208			 
9208 d1			      pop   DE                      ; Restore size of next block 
9209 19			      add   HL, DE                  ; Add sizes of both blocks 
920a eb			      ex    DE, HL 
920b			 
920b 60			      ld    H, B                    ; Store new bigger size into freed block 
920c 69			      ld    L, C 
920d 23			      inc   HL 
920e 23			      inc   HL 
920f 73			      ld    (HL), E 
9210 23			      inc   HL 
9211 72			      ld    (HL), D 
9212			 
9212			free_check_adjacent_to_prev: 
9212			      ; Check if the freed block is adjacent to the prev free block 
9212 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9215 dd 66 03		      ld    H, (IX+3) 
9218			 
9218 23			      inc   HL                      ; Size of prev free block into DE 
9219 23			      inc   HL 
921a 5e			      ld    E, (HL) 
921b 23			      inc   HL 
921c 56			      ld    D, (HL) 
921d 2b			      dec   HL 
921e 2b			      dec   HL 
921f 2b			      dec   HL 
9220			 
9220 19			      add   HL, DE                  ; Add prev block addr and size 
9221			 
9221 b7			      or    A                       ; Clear the carry flag 
9222 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9224 20 2e		      jr    NZ, free_done 
9226			 
9226			      ; Freed block is adjacent to prev, merge into one bigger block 
9226 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9227 69			      ld    L, C 
9228 5e			      ld    E, (HL) 
9229 23			      inc   HL 
922a 56			      ld    D, (HL) 
922b e5			      push  HL                      ; Save freed block ptr for later 
922c			 
922c dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922f dd 66 03		      ld    H, (IX+3) 
9232 73			      ld    (HL), E 
9233 23			      inc   HL 
9234 72			      ld    (HL), D 
9235			 
9235 e1			      pop   HL                      ; Restore freed block ptr 
9236 23			      inc   HL                      ; Load size of freed block into DE 
9237 5e			      ld    E, (HL) 
9238 23			      inc   HL 
9239 56			      ld    D, (HL) 
923a d5			      push  DE                      ; Save freed block size for later 
923b			 
923b dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923e dd 66 03		      ld    H, (IX+3) 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 5e			      ld    E, (HL) 
9244 23			      inc   HL 
9245 56			      ld    D, (HL) 
9246			 
9246 e1			      pop   HL                      ; Add sizes of both blocks 
9247 19			      add   HL, DE 
9248 eb			      ex    DE, HL 
9249			 
9249 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
924c dd 66 03		      ld    H, (IX+3) 
924f 23			      inc   HL 
9250 23			      inc   HL 
9251 73			      ld    (HL), E 
9252 23			      inc   HL 
9253 72			      ld    (HL), D 
9254			 
9254			free_done: 
9254 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9257 39			      add   HL, SP 
9258 f9			      ld    SP, HL 
9259			 
9259			free_early_exit: 
9259 dd e1		      pop   IX 
925b d1			      pop   DE 
925c c1			      pop   BC 
925d			 
925d c9			      ret 
925e			 
925e			; moved to firmware.asm 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			;                  .dw   0 
925e			 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_3 
925e			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925e			;heap_start        .equ  0x9000      ; Starting address of heap 
925e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925e			; 
925e			 ;     .org 0 
925e			  ;    jp    main 
925e			; 
925e			; 
925e			 ;     .org  0x100 
925e			;main: 
925e			 ;     ld    HL, 0x8100 
925e			  ;    ld    SP, HL 
925e			; 
925e			;      call  heap_init 
925e			 
925e			      ; Make some allocations 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9004 
925e			; 
925e			 ;     ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9014 
925e			 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9024 
925e			 
925e			      ; Free some allocations 
925e			;      ld    HL, 0x9014 
925e			;      call  free 
925e			 
925e			;      ld    HL, 0x9004 
925e			;      call  free 
925e			; 
925e			;      ld    HL, 0x9024 
925e			;      call  free 
925e			 
925e			 
925e			 ;     halt 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     heap_init                                                               : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Initialise the heap and make it ready for malloc and free operations.   : 
925e			;                                                                             : 
925e			;     The heap is maintained as a linked list, starting with an initial       : 
925e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925e			;     the first free block in the heap. Each block then points to the next    : 
925e			;     free block within the heap, and the free list ends at the first block   : 
925e			;     with a null pointer to the next free block.                             : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     Inputs are compile-time only. Two defines which specify the starting    : 
925e			;     address of the heap and its size are required, along with a memory      : 
925e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925e			;     principally stores a pointer to the first free block in the heap.       : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;------------------------------------------------------------------------------ 
925e			heap_init: 
925e			      push  HL 
925e			 
925e			      ; Initialise free list struct 
925e			      ld    HL, heap_start 
925e			      ld    (free_list), HL 
925e			      ld    HL, 0 
925e			      ld    (free_list+2), HL 
925e			 
925e			      ; Insert first free block at bottom of heap, consumes entire heap 
925e			      ld    HL, heap_start+heap_size-4 
925e			      ld    (heap_start), HL        ; Next block (end of free list) 
925e			      ld    HL, heap_size-4 
925e			      ld    (heap_start+2), HL      ; Block size 
925e			 
925e			      ; Insert end of free list block at top of heap - two null words will 
925e			      ; terminate the free list 
925e			      ld    HL, 0 
925e			      ld    (heap_start+heap_size-2), HL 
925e			      ld    (heap_start+heap_size-4), HL 
925e			 
925e			      pop   HL 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     malloc                                                                  : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Allocates the wanted space from the heap and returns the address of the : 
925e			;     first useable byte of the allocation.                                   : 
925e			;                                                                             : 
925e			;     Allocations can happen in one of two ways:                              : 
925e			;                                                                             : 
925e			;     1. A free block may be found which is the exact size wanted. In this    : 
925e			;        case the block is removed from the free list and retuedn to the      : 
925e			;        caller.                                                              : 
925e			;     2. A free block may be found which is larger than the size wanted. In   : 
925e			;        this case, the larger block is split into two. The first portion of  : 
925e			;        this block will become the requested space by the malloc call and    : 
925e			;        is returned to the caller. The second portion becomes a new free     : 
925e			;        block, and the free list is adjusted to maintain continuity via this : 
925e			;        newly created block.                                                 : 
925e			;                                                                             : 
925e			;     malloc does not set any initial value in the allocated space, the       : 
925e			;     caller is required to do this as required.                              : 
925e			;                                                                             : 
925e			;     This implementation of malloc uses the stack exclusively, and is        : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling malloc, and recommended  : 
925e			;     to avoid the use of malloc inside ISRs in general.                      : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Number of bytes wanted                                              : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     HL  Address of the first useable byte of the allocation                 : 
925e			;                                                                             : 
925e			; Flags                                                                       : 
925e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +4  +-------------+                                                       : 
925e			;       |  this_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			malloc: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if no space requested 
925e			      or    L 
925e			      jp    Z, malloc_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; Setup initial state 
925e			      ld    HL, 4                   ; want must also include space used by block struct 
925e			      add   HL, DE 
925e			 
925e			      ld    B, H                    ; Move want to BC 
925e			      ld    C, L 
925e			 
925e			      ld    HL, free_list           ; Store prev_free ptr to stack 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    E, (HL)                 ; Store this_free ptr to stack 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ld    (IX+2), E 
925e			      ld    (IX+3), D 
925e			      ex    DE, HL                  ; this_free ptr into HL 
925e			 
925e			      ; Loop through free block list to find some space 
925e			malloc_find_space: 
925e			      ld    E, (HL)                 ; Load next_free ptr into DE 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925e			      or    E 
925e			      jp    Z, malloc_no_space 
925e			 
925e			      ld    (IX+0), E               ; Store next_free ptr to stack 
925e			      ld    (IX+1), D 
925e			 
925e			      ; Does this block have enough space to make the allocation? 
925e			      inc   HL                      ; Load free block size into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ex    DE, HL                  ; Check size of block against want 
925e			      or    A                       ; Ensure carry flag clear 
925e			      sbc   HL, BC 
925e			      push  HL                      ; Store the result for later (new block size) 
925e			 
925e			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925e			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925e			 
925e			      ; this_free block is not big enough, setup ptrs to test next free block 
925e			      pop   HL                      ; Discard previous result 
925e			 
925e			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925e			      ld    H, (IX+3) 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925e			      ld    H, (IX+1) 
925e			      ld    (IX+2), L 
925e			      ld    (IX+3), H 
925e			 
925e			      jr    malloc_find_space 
925e			 
925e			      ; split a bigger block into two - requested size and remaining size 
925e			malloc_alloc_split: 
925e			      ex    DE, HL                  ; Calculate address of new free block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      add   HL, BC 
925e			 
925e			      ; Create a new block and point it at next_free 
925e			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      ld    (HL), E                 ; Store next_free ptr into new block 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   DE                      ; Store size of new block into new block 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Update this_free ptr to point to new block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925e			      ld    (IX+3), H 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store want size into allocated block 
925e			      ld    (HL), C 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			      inc   HL 
925e			      push  HL                      ; Address of allocation to return 
925e			 
925e			      jr    malloc_update_links 
925e			 
925e			malloc_alloc_fit: 
925e			      pop   HL                      ; Dont need new block size, want is exact fit 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store address of allocation to return 
925e			      inc   HL 
925e			      inc   HL 
925e			      push  HL 
925e			 
925e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925e			      ld    L, (IX+0)               ; next_free to HL 
925e			      ld    H, (IX+1) 
925e			 
925e			      ld    (IX+2), L               ; HL to this_free 
925e			      ld    (IX+3), H 
925e			 
925e			 
925e			malloc_update_links: 
925e			      ; Update prev_free ptr to point to this_free 
925e			      ld    L, (IX+4)               ; prev_free ptr to HL 
925e			      ld    H, (IX+5) 
925e			 
925e			      ld    E, (IX+2)               ; this_free ptr to DE 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (HL), E                 ; this_free ptr into prev_free 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Clear the Z flag to indicate successful allocation 
925e			      ld    A, D 
925e			      or    E 
925e			 
925e			      pop   DE                      ; Address of allocation 
925e			 
925e			malloc_no_space: 
925e			      ld    HL, 6                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			      ex    DE, HL                  ; Alloc addr into HL for return 
925e			 
925e			malloc_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     free                                                                    : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925e			;     returned by malloc, otherwise the behaviour is undefined.               : 
925e			;                                                                             : 
925e			;     Where possible, directly adjacent free blocks will be merged together   : 
925e			;     into larger blocks to help ensure that the heap does not become         : 
925e			;     excessively fragmented.                                                 : 
925e			;                                                                             : 
925e			;     free does not clear or set any other value into the freed space, and    : 
925e			;     therefore its contents may be visible through subsequent malloc's. The  : 
925e			;     caller should clear the freed space as required.                        : 
925e			;                                                                             : 
925e			;     This implementation of free uses the stack exclusively, and is          : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling free, and recommended    : 
925e			;     to avoid the use of free inside ISRs in general.                        : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Pointer to address of first byte of allocation to be freed          : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			free: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if ptr is null 
925e			      or    L 
925e			      jp    Z, free_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; The address in HL points to the start of the useable allocated space, 
925e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925e			      ; address of the block itself. 
925e			      ex    DE, HL 
925e			      ld    DE, -4 
925e			      add   HL, DE 
925e			 
925e			      ; An allocated block must have a null next block pointer in it 
925e			      ld    A, (HL) 
925e			      inc   HL 
925e			      or    (HL) 
925e			      jp    NZ, free_done 
925e			 
925e			      dec   HL 
925e			 
925e			      ld    B, H                    ; Copy HL to BC 
925e			      ld    C, L 
925e			 
925e			      ; Loop through the free list to find the first block with an address 
925e			      ; higher than the block being freed 
925e			      ld    HL, free_list 
925e			 
925e			free_find_higher_block: 
925e			      ld    E, (HL)                 ; Load next ptr from free block 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			 
925e			      ld    (IX+0), E               ; Save ptr to next free block 
925e			      ld    (IX+1), D 
925e			      ld    (IX+2), L               ; Save ptr to prev free block 
925e			      ld    (IX+3), H 
925e			 
925e			      ld    A, B                    ; Check if DE is greater than BC 
925e			      cp    D                       ; Compare MSB first 
925e			      jr    Z, $+4                  ; MSB the same, compare LSB 
925e			      jr    NC, free_find_higher_block_skip 
925e			      ld    A, C 
925e			      cp    E                       ; Then compare LSB 
925e			      jr    C, free_found_higher_block 
925e			 
925e			free_find_higher_block_skip: 
925e			      ld    A, D                    ; Reached the end of the free list? 
925e			      or    E 
925e			      jp    Z, free_done 
925e			 
925e			      ex    DE, HL 
925e			 
925e			      jr    free_find_higher_block 
925e			 
925e			free_found_higher_block: 
925e			      ; Insert freed block between prev and next free blocks 
925e			      ld    (HL), C                 ; Point prev free block to freed block 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			 
925e			      ld    H, B                    ; Point freed block at next free block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Check if the freed block is adjacent to the next free block 
925e			      inc   HL                      ; Load size of freed block into HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      add   HL, BC                  ; Add addr of freed block and its size 
925e			 
925e			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_check_adjacent_to_prev 
925e			 
925e			      ; Freed block is adjacent to next, merge into one bigger block 
925e			      ex    DE, HL                  ; Load next ptr from next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save ptr to next block for later 
925e			 
925e			      ld    H, B                    ; Store ptr from next block into freed block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore ptr to next block 
925e			      inc   HL                      ; Load size of next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save next block size for later 
925e			 
925e			      ld    H, B                    ; Load size of freed block into HL 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      pop   DE                      ; Restore size of next block 
925e			      add   HL, DE                  ; Add sizes of both blocks 
925e			      ex    DE, HL 
925e			 
925e			      ld    H, B                    ; Store new bigger size into freed block 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_check_adjacent_to_prev: 
925e			      ; Check if the freed block is adjacent to the prev free block 
925e			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925e			      ld    H, (IX+3) 
925e			 
925e			      inc   HL                      ; Size of prev free block into DE 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      add   HL, DE                  ; Add prev block addr and size 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_done 
925e			 
925e			      ; Freed block is adjacent to prev, merge into one bigger block 
925e			      ld    H, B                    ; Load next ptr from freed block into DE 
925e			      ld    L, C 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save freed block ptr for later 
925e			 
925e			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925e			      ld    H, (IX+3) 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore freed block ptr 
925e			      inc   HL                      ; Load size of freed block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save freed block size for later 
925e			 
925e			      ld    L, (IX+2)               ; Load size of prev block into DE 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      pop   HL                      ; Add sizes of both blocks 
925e			      add   HL, DE 
925e			      ex    DE, HL 
925e			 
925e			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_done: 
925e			      ld    HL, 4                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			free_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;      .org 0x8000 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			 ;                 .dw   0 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_4 
925e			 
925e			; My memory allocation code. Very very simple.... 
925e			; allocate space under 250 chars 
925e			 
925e			heap_init: 
925e				; init start of heap as zero 
925e				;  
925e			 
925e				ld hl, heap_start 
925e				ld a, 0 
925e				ld (hl), a      ; empty block 
925e				inc hl 
925e				ld a, 0 
925e				ld (hl), a      ; length of block 
925e				; write end of list 
925e				inc hl 
925e				ld a,(hl) 
925e				inc hl 
925e				ld a,(hl) 
925e				 
925e			 
925e				; init some malloc vars 
925e			 
925e				ld hl, 0 
925e				ld (free_list), hl       ; store last malloc location 
925e			 
925e				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925e				ld a, 0 
925e				ld (hl), a 
925e			 
925e			 
925e				ld hl, heap_start 
925e				;  
925e				  
925e				ret 
925e			 
925e			 
925e			;    free block marker 
925e			;    requested size  
925e			;    pointer to next block 
925e			;    .... 
925e			;    next block marker 
925e			 
925e			 
925e			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925e			; 
925e			 
925e			 
925e			malloc:  
925e				push de 
925e				push bc 
925e				push af 
925e			 
925e				; hl space required 
925e				 
925e				ld c, l    ; hold space   (TODO only a max of 255) 
925e			 
925e			;	inc c     ; TODO BUG need to fix memory leak on push str 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			 
925e			 
925e			 
925e				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925e			 
925e				ld a, (free_list+3) 
925e				cp 0 
925e				jr z, .contheap 
925e			 
925e				ld hl, (free_list)     ; get last alloc 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mrs" 
925e						CALLMONITOR 
925e					endif 
925e				jr .startalloc 
925e			 
925e			.contheap: 
925e				ld hl, heap_start 
925e			 
925e			.startalloc: 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mym" 
925e						CALLMONITOR 
925e					endif 
925e			.findblock: 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmf" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e				ld a,(hl)  
925e				; if byte is zero then clear to use 
925e			 
925e				cp 0 
925e				jr z, .foundemptyblock 
925e			 
925e				; if byte is not clear 
925e				;     then byte is offset to next block 
925e			 
925e				inc hl 
925e				ld a, (hl) ; get size 
925e			.nextblock:	inc hl 
925e					ld e, (hl) 
925e					inc hl 
925e					ld d, (hl) 
925e					ex de, hl 
925e			;	inc hl  ; move past the store space 
925e			;	inc hl  ; move past zero index  
925e			 
925e				; TODO detect no more space 
925e			 
925e				push hl 
925e				ld de, heap_end 
925e				call cmp16 
925e				pop hl 
925e				jr nc, .nospace 
925e			 
925e				jr .findblock 
925e			 
925e			.nospace: ld hl, 0 
925e				jp .exit 
925e			 
925e			 
925e			.foundemptyblock:	 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mme" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; TODO has block enough space if reusing??? 
925e			 
925e				;  
925e			 
925e			; see if this block has been previously used 
925e				inc hl 
925e				ld a, (hl) 
925e				dec hl 
925e				cp 0 
925e				jr z, .newblock 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meR" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; no reusing previously allocated block 
925e			 
925e			; is it smaller than previously used? 
925e				 
925e				inc hl    ; move to size 
925e				ld a, c 
925e				sub (hl)        ; we want c < (hl) 
925e				dec hl    ; move back to marker 
925e			        jr z, .findblock 
925e			 
925e				; update with the new size which should be lower 
925e			 
925e			        ;inc  hl   ; negate next move. move back to size  
925e			 
925e			.newblock: 
925e				; need to be at marker here 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meN" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			 
925e				ld a, c 
925e			 
925e				ld (free_list+3), a	 ; flag resume from last malloc  
925e				ld (free_list), hl    ; save out last location 
925e			 
925e			 
925e				;inc a     ; space for length byte 
925e				ld (hl), a     ; save block in use marker 
925e			 
925e				inc hl   ; move to space marker 
925e				ld (hl), a    ; save new space 
925e			 
925e				inc hl   ; move to start of allocated area 
925e				 
925e			;	push hl     ; save where we are - 1  
925e			 
925e			;	inc hl  ; move past zero index  
925e				; skip space to set down new marker 
925e			 
925e				; provide some extra space for now 
925e			 
925e				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925e				inc a 
925e				inc a 
925e			 
925e				push hl   ; save where we are in the node block 
925e			 
925e				call addatohl 
925e			 
925e				; write linked list point 
925e			 
925e				pop de     ; get our node position 
925e				ex de, hl 
925e			 
925e				ld (hl), e 
925e				inc hl 
925e				ld (hl), d 
925e			 
925e				inc hl 
925e			 
925e				; now at start of allocated data so save pointer 
925e			 
925e				push hl 
925e			 
925e				; jump to position of next node and setup empty header in DE 
925e			 
925e				ex de, hl 
925e			 
925e			;	inc hl ; move past end of block 
925e			 
925e				ld a, 0 
925e				ld (hl), a   ; empty marker 
925e				inc hl 
925e				ld (hl), a   ; size 
925e				inc hl  
925e				ld (hl), a   ; ptr 
925e				inc hl 
925e				ld (hl), a   ; ptr 
925e			 
925e			 
925e				pop hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmr" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			.exit: 
925e				pop af 
925e				pop bc 
925e				pop de  
925e				ret 
925e			 
925e			 
925e			 
925e			 
925e			free:  
925e				push hl 
925e				push af 
925e				; get address in hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "fre" 
925e						CALLMONITOR 
925e					endif 
925e				; data is at hl - move to block count 
925e				dec hl 
925e				dec hl    ; get past pointer 
925e				dec hl 
925e			 
925e				ld a, (hl)    ; need this for a validation check 
925e			 
925e				dec hl    ; move to block marker 
925e			 
925e				; now check that the block count and block marker are the same  
925e			        ; this checks that we are on a malloc node and not random memory 
925e			        ; OK a faint chance this could be a problem but rare - famous last words! 
925e			 
925e				ld c, a 
925e				ld a, (hl)    
925e			 
925e				cp c 
925e				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925e			 
925e				; yes good chance we are on a malloc node 
925e			 
925e				ld a, 0      
925e				ld (hl), a   ; mark as free 
925e			 
925e				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925e			 
925e			.freeignore:  
925e			 
925e				pop af 
925e				pop hl 
925e			 
925e				ret 
925e			 
925e			 
925e			 
925e			endif 
925e			 
925e			; eof 
# End of file firmware_memory.asm
925e			  
925e			; device C  
925e			; Now handled by SPI  
925e			;if SOUND_ENABLE  
925e			;	include "firmware_sound.asm"  
925e			;endif  
925e			  
925e			include "firmware_diags.asm"  
925e			; Hardware diags menu 
925e			 
925e			 
925e			config: 
925e			 
925e 3e 00			ld a, 0 
9260 21 84 92			ld hl, .configmn 
9263 cd ee 8a			call menu 
9266			 
9266 fe 00			cp 0 
9268 c8				ret z 
9269			 
9269			;	cp 1 
9269			;	call z, .savetostore 
9269			 
9269 fe 01			cp 1 
926b			if STARTUP_V1 
926b cc 9a 92			call z, .selautoload 
926e			endif 
926e			 
926e			if STARTUP_V2 
926e				call z, .enautoload 
926e			endif 
926e fe 02			cp 2 
9270 cc 90 92			call z, .disautoload 
9273			;	cp 3 
9273			;	call z, .selbank 
9273 fe 03			cp 3 
9275 cc b8 92			call z, .debug_tog 
9278 fe 04			cp 4 
927a cc 06 94			call z, .bpsgo 
927d fe 05			cp 5 
927f cc e1 92			call z, hardware_diags 
9282			if STARTUP_V2 
9282				cp 6 
9282				call z, create_startup 
9282			endif 
9282 18 da			jr config 
9284			 
9284			.configmn: 
9284			;	dw prom_c3 
9284 f4 95			dw prom_c2 
9286 09 96			dw prom_c2a 
9288			;	dw prom_c2b 
9288			;	dw prom_c4 
9288 28 96			dw prom_m4 
928a 43 96			dw prom_m4b 
928c 4b 96			dw prom_c1 
928e			if STARTUP_V2 
928e				dw prom_c9 
928e			endif 
928e 00 00			dw 0 
9290				 
9290			 
9290			if STARTUP_V2 
9290			.enautoload: 
9290				if STORAGE_SE 
9290				ld a, $fe      ; bit 0 clear 
9290				ld (spi_device), a 
9290			 
9290				call storage_get_block_0 
9290			 
9290				ld a, 1 
9290				ld (store_page+STORE_0_AUTOFILE), a 
9290			 
9290					ld hl, 0 
9290					ld de, store_page 
9290				call storage_write_block	 ; save update 
9290				else 
9290			 
9290				ld hl, prom_notav 
9290				ld de, prom_empty 
9290				call info_panel 
9290				endif 
9290			 
9290			 
9290				ret 
9290			endif 
9290			 
9290			.disautoload: 
9290				if STORAGE_SE 
9290				ld a, $fe      ; bit 0 clear 
9290				ld (spi_device), a 
9290			 
9290				call storage_get_block_0 
9290			 
9290				ld a, 0 
9290				ld (store_page+STORE_0_AUTOFILE), a 
9290			 
9290					ld hl, 0 
9290					ld de, store_page 
9290				call storage_write_block	 ; save update 
9290				else 
9290			 
9290 21 5a 96			ld hl, prom_notav 
9293 11 70 96			ld de, prom_empty 
9296 cd 4e 8a			call info_panel 
9299				endif 
9299			 
9299			 
9299 c9				ret 
929a			 
929a			if STARTUP_V1 
929a			 
929a			; Select auto start 
929a			 
929a			.selautoload: 
929a			 
929a				 
929a				if STORAGE_SE 
929a			 
929a					call config_dir 
929a				        ld hl, scratch 
929a					ld a, 0 
929a					call menu 
929a			 
929a					cp 0 
929a					ret z 
929a			 
929a					dec a 
929a			 
929a			 
929a					; locate menu option 
929a			 
929a					ld hl, scratch 
929a					call table_lookup 
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALl" 
929a						CALLMONITOR 
929a					endif 
929a					; with the pointer to the menu it, the byte following the zero term is the file id 
929a			 
929a					ld a, 0 
929a					ld bc, 50   ; max of bytes to look at 
929a					cpir  
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALb" 
929a						CALLMONITOR 
929a					endif 
929a					;inc hl 
929a			 
929a					ld a, (hl)   ; file id 
929a					 
929a				        ; save bank and file ids 
929a			 
929a					push af 
929a			 
929a			; TODO need to save to block 0 on bank 1	 
929a			 
929a					call storage_get_block_0 
929a			 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "AL0" 
929a						CALLMONITOR 
929a					endif 
929a					pop af 
929a			 
929a					ld (store_page+STORE_0_FILERUN),a 
929a					 
929a					; save bank id 
929a			 
929a					ld a,(spi_device) 
929a					ld (store_page+STORE_0_BANKRUN),a 
929a			 
929a					; enable auto run of store file 
929a			 
929a					ld a, 1 
929a					ld (store_page+STORE_0_AUTOFILE),a 
929a			 
929a					; save buffer 
929a			 
929a					ld hl, 0 
929a					ld de, store_page 
929a					if DEBUG_FORTH_WORDS 
929a						DMARK "ALw" 
929a						CALLMONITOR 
929a					endif 
929a				call storage_write_block	 ; save update 
929a			  
929a			 
929a			 
929a			 
929a					ld hl, scratch 
929a					call config_fdir 
929a			 
929a				else 
929a			 
929a 21 5a 96			ld hl, prom_notav 
929d 11 70 96			ld de, prom_empty 
92a0 cd 4e 8a			call info_panel 
92a3			 
92a3				endif 
92a3 c9				ret 
92a4			endif 
92a4			 
92a4			 
92a4			; Select storage bank 
92a4			 
92a4			.selbank: 
92a4			 
92a4			;	if STORAGE_SE 
92a4			;	else 
92a4			 
92a4 21 5a 96			ld hl, prom_notav 
92a7 11 70 96			ld de, prom_empty 
92aa cd 4e 8a			call info_panel 
92ad			;	endif 
92ad				 
92ad c9				ret 
92ae			 
92ae			if STORAGE_SE 
92ae			 
92ae			.config_ldir:   
92ae				; Load storage bank labels into menu array 
92ae			 
92ae				 
92ae			 
92ae			 
92ae				ret 
92ae			 
92ae			 
92ae			endif 
92ae			 
92ae			 
92ae			; Save user words to storage 
92ae			 
92ae			.savetostore: 
92ae			 
92ae			;	if STORAGE_SE 
92ae			; 
92ae			;		call config_dir 
92ae			;	        ld hl, scratch 
92ae			;		ld a, 0 
92ae			;		call menu 
92ae			;		 
92ae			;		ld hl, scratch 
92ae			;		call config_fdir 
92ae			; 
92ae			;	else 
92ae			 
92ae 21 5a 96			ld hl, prom_notav 
92b1 11 70 96			ld de, prom_empty 
92b4 cd 4e 8a			call info_panel 
92b7			 
92b7			;	endif 
92b7			 
92b7 c9				ret 
92b8			 
92b8			if STARTUP_V2 
92b8			 
92b8			create_startup: 
92b8			 
92b8				ld a, 0 
92b8				ld hl, .crstart 
92b8				call menu 
92b8			 
92b8				cp 0 
92b8				ret z 
92b8			 
92b8				cp 1 
92b8				call z, .genlsword 
92b8				cp 2 
92b8				call z, .genedword 
92b8			 
92b8				cp 3 
92b8				call z, .gendemword 
92b8			 
92b8				cp 4 
92b8				call z, .genutlword 
92b8				cp 5 
92b8				call z, .genspiword 
92b8				cp 6 
92b8				call z, .genkeyword 
92b8				cp 7 
92b8				call z, .gensoundword 
92b8				cp 8 
92b8				call z, .genhwword 
92b8				jr create_startup 
92b8			 
92b8			.genhwword: 
92b8				ld hl, crs_hw 
92b8				ld de, .hwworddef 
92b8				call .genfile 
92b8				ret 
92b8			.gensoundword: 
92b8				ld hl, crs_sound 
92b8				ld de, .soundworddef 
92b8				call .genfile 
92b8				ret 
92b8			.genlsword: 
92b8				ld hl, crs_s1 
92b8				ld de, .lsworddef 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.genedword: 
92b8				ld de, .edworddef 
92b8				ld hl, crs_s2 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.gendemword: 
92b8				ld de, .demoworddef 
92b8				ld hl, crs_s3 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			.genutlword: 
92b8				ld hl, crs_s4 
92b8				ld de, .utilwordef 
92b8				call .genfile 
92b8				ret 
92b8			.genspiword: 
92b8				ld hl, crs_s5 
92b8				ld de, .spiworddef 
92b8				call .genfile 
92b8				ret 
92b8			.genkeyword: 
92b8				ld hl, crs_s6 
92b8				ld de, .keyworddef 
92b8				call .genfile 
92b8				ret 
92b8			 
92b8			; hl - points to file name 
92b8			; de - points to strings to add to file 
92b8			 
92b8			.genfile: 
92b8				push hl 
92b8				push de 
92b8			 
92b8				call clear_display 
92b8				ld a, display_row_1 
92b8				ld de, .genfiletxt 
92b8				call str_at_display 
92b8				call update_display 
92b8			 
92b8				pop de 
92b8				pop hl 
92b8			 
92b8			 
92b8				push de 
92b8				call storage_create 
92b8				; id in hl 
92b8				pop de   ; table of strings to add 
92b8			 
92b8			.genloop: 
92b8			 
92b8				push hl ; save id for next time around 
92b8				push de ; save de for next time around 
92b8			 
92b8				ex de, hl 
92b8				call loadwordinhl 
92b8				ex de, hl 
92b8			 
92b8				; need hl to be the id 
92b8				; need de to be the string ptr 
92b8				 
92b8				call storage_append 
92b8			 
92b8				pop de 
92b8				pop hl 
92b8			 
92b8				inc de 
92b8				inc de 
92b8			 
92b8				ld a,(de) 
92b8				cp 0 
92b8				jr nz, .genloop 
92b8				inc de 
92b8				ld a, (de) 
92b8				dec de 
92b8				cp 0 
92b8				jr nz, .genloop	 
92b8			 
92b8				ret 
92b8			 
92b8			.genfiletxt:  db "Creating file...",0 
92b8			 
92b8			.hwworddef: 
92b8				dw test5 
92b8				dw test6 
92b8				dw test7 
92b8				dw test8 
92b8				dw test9 
92b8				dw test10 
92b8				dw 0 
92b8			 
92b8			.soundworddef: 
92b8				dw sound1 
92b8				dw sound2 
92b8				dw sound3 
92b8				dw sound4 
92b8				dw sound5 
92b8				dw sound6 
92b8				dw sound7 
92b8				dw sound8 
92b8				dw sound9 
92b8				dw 0 
92b8			 
92b8			.utilwordef: 
92b8				dw strncpy 
92b8				dw type 
92b8				dw tuck 
92b8				dw clrstack 
92b8				dw longread 
92b8				dw start1 
92b8				dw start2 
92b8			; duplicated 
92b8			;	dw start3b 
92b8			;	dw start3c 
92b8				dw list 
92b8				dw 0 
92b8			 
92b8			.lsworddef: 
92b8				dw start3b 
92b8				dw 0 
92b8			 
92b8			.edworddef: 
92b8				dw edit1 
92b8				dw edit2 
92b8				dw edit3 
92b8				dw 0 
92b8			 
92b8			.demoworddef: 
92b8				dw game1 
92b8				dw game1a 
92b8				dw game1b 
92b8				dw game1c 
92b8				dw game1d 
92b8				dw game1s 
92b8				dw game1t 
92b8				dw game1f 
92b8				dw game1z 
92b8				dw game1zz 
92b8				dw ssv2 
92b8				dw ssv3 
92b8				dw ssv4 
92b8				dw ssv5 
92b8				dw ssv1 
92b8				dw ssv1cpm	 
92b8			;	dw game2b 
92b8			;	dw game2bf 
92b8			;	dw game2mba 
92b8			;	dw game2mbas	 
92b8			;	dw game2mbht 
92b8			;	dw game2mbms 
92b8			;	dw game2mb 
92b8			;	dw game3w 
92b8			;	dw game3p 
92b8			;	dw game3sc 
92b8			;	dw game3vsi 
92b8			;	dw game3vs 
92b8				dw 0 
92b8			 
92b8			 
92b8			.spiworddef: 
92b8			 
92b8			    dw spi1 
92b8			    dw spi2 
92b8			    dw spi2b 
92b8			    dw spi3 
92b8			    dw spi4 
92b8			    dw spi5 
92b8			;    dw spi6 
92b8			;    dw spi7 
92b8			 
92b8			;    dw spi8 
92b8			;    dw spi9 
92b8			;    dw spi10 
92b8			    dw 0 
92b8			 
92b8			.keyworddef: 
92b8			 
92b8				dw keyup 
92b8				dw keydown 
92b8				dw keyleft 
92b8				dw keyright 
92b8				dw 	keyf1 
92b8				dw keyf2 
92b8				dw keyf3 
92b8				dw keyf4 
92b8				dw keyf5 
92b8				dw keyf6 
92b8				dw keyf7 
92b8				dw keyf8 
92b8				dw keyf9 
92b8				dw keyf10 
92b8				dw keyf11 
92b8				dw keyf12 
92b8				dw keytab 
92b8				dw keycr 
92b8				dw keyhome 
92b8				dw keyend 
92b8				dw keybs 
92b8				dw 0 
92b8			 
92b8			.crstart: 
92b8				dw crs_s1 
92b8				dw crs_s2 
92b8				dw crs_s3 
92b8				dw crs_s4 
92b8				dw crs_s5 
92b8				dw crs_s6 
92b8				dw crs_sound 
92b8				dw crs_hw 
92b8				dw 0 
92b8			 
92b8			endif 
92b8			 
92b8			 
92b8			if STORAGE_SE 
92b8			 
92b8			config_fdir: 
92b8				; using the scratch dir go through and release the memory allocated for each string 
92b8				 
92b8				ld hl, scratch 
92b8			.cfdir:	ld e,(hl) 
92b8				inc hl 
92b8				ld d,(hl) 
92b8				inc hl 
92b8			 
92b8				ex de, hl 
92b8				call ishlzero 
92b8				ret z     ; return on null pointer 
92b8				call free 
92b8				ex de, hl 
92b8				jr .cfdir 
92b8			 
92b8			 
92b8				ret 
92b8			 
92b8			 
92b8			config_dir: 
92b8			 
92b8				; for the config menus that need to build a directory of storage call this routine 
92b8				; it will construct a menu in scratch to pass to menu 
92b8			 
92b8				; open storage device 
92b8			 
92b8				; execute DIR to build a list of files and their ids into scratch in menu format 
92b8				; once the menu has finished then will need to call config_fdir to release the strings 
92b8				 
92b8				; c = number items 
92b8			 
92b8				 
92b8				call storage_get_block_0 
92b8			 
92b8				ld hl, store_page     ; get current id count 
92b8				ld b, (hl) 
92b8				ld c, 0    ; count of files   
92b8			 
92b8			 
92b8				ld hl, scratch 
92b8				ld (store_tmp2), hl    ; location to poke strings 
92b8			 
92b8				; check for empty drive 
92b8			 
92b8				ld a, 0 
92b8				cp b 
92b8				jp z, .dirdone 
92b8			 
92b8				 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "Cdc" 
92b8						CALLMONITOR 
92b8					endif 
92b8			 
92b8			 
92b8			.diritem:	 
92b8				push bc 
92b8				; for each of the current ids do a search for them and if found push to stack 
92b8			 
92b8					ld hl, STORE_BLOCK_PHY 
92b8					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b8					ld e,b 
92b8			 
92b8					call storage_findnextid 
92b8			 
92b8			 
92b8					; if found hl will be non zero 
92b8			 
92b8					call ishlzero 
92b8					jr z, .dirnotfound 
92b8			 
92b8					; increase count 
92b8			 
92b8					pop bc	 
92b8					inc c 
92b8					push bc 
92b8					 
92b8			 
92b8					; get file header and push the file name 
92b8			 
92b8					ld de, store_page 
92b8					call storage_read_block 
92b8			 
92b8					; push file id to stack 
92b8				 
92b8					ld a, (store_page) 
92b8					ld h, 0 
92b8					ld l, a 
92b8			 
92b8					;call forth_push_numhl 
92b8					; TODO store id 
92b8			 
92b8					push hl 
92b8			 
92b8					; push extent count to stack  
92b8				 
92b8					ld hl, store_page+3 
92b8			 
92b8					; get file name length 
92b8			 
92b8					call strlenz   
92b8			 
92b8					inc hl   ; cover zero term 
92b8					inc hl  ; stick the id at the end of the area 
92b8			 
92b8					push hl 
92b8					pop bc    ; move length to bc 
92b8			 
92b8					call malloc 
92b8			 
92b8					; TODO save malloc area to scratch 
92b8			 
92b8					ex de, hl 
92b8					ld hl, (store_tmp2) 
92b8					ld (hl), e 
92b8					inc hl 
92b8					ld (hl), d 
92b8					inc hl 
92b8					ld (store_tmp2), hl 
92b8			 
92b8					 
92b8			 
92b8					;pop hl   ; get source 
92b8			;		ex de, hl    ; swap aronund	 
92b8			 
92b8					ld hl, store_page+3 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "CFd" 
92b8						CALLMONITOR 
92b8					endif 
92b8					ldir 
92b8			 
92b8					; de is past string, move back one and store id 
92b8					 
92b8					dec de 
92b8			 
92b8					; store file id 
92b8			 
92b8					pop hl 
92b8					ex de,hl 
92b8					ld (hl), e 
92b8			 
92b8					if DEBUG_FORTH_WORDS 
92b8						DMARK "Cdi" 
92b8						CALLMONITOR 
92b8					endif 
92b8					 
92b8			.dirnotfound: 
92b8					pop bc     
92b8					djnz .diritem 
92b8				 
92b8			.dirdone:	 
92b8			 
92b8					ld a, 0 
92b8					ld hl, (store_tmp2) 
92b8					ld (hl), a 
92b8					inc hl 
92b8					ld (hl), a 
92b8					inc hl 
92b8					; push a count of the dir items found 
92b8			 
92b8			;		ld h, 0 
92b8			;		ld l, c 
92b8			 
92b8				ret 
92b8			 
92b8			endif 
92b8			 
92b8			 
92b8			; Settings 
92b8			; Run  
92b8			 
92b8			 
92b8			 
92b8			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b8			;;hd_menu2:   db "        2: Editor",0   
92b8			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b8			;hd_menu3:   db "        3: Storage",0 
92b8			;hd_menu4:   db "0=quit  4: Debug",0 
92b8			;hd_don:     db "ON",0 
92b8			;hd_doff:     db "OFF",0 
92b8			; 
92b8			; 
92b8			; 
92b8			;hardware_diags_old:       
92b8			; 
92b8			;.diagmenu: 
92b8			;	call clear_display 
92b8			;	ld a, display_row_1 
92b8			;	ld de, hd_menu1 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a, display_row_2 
92b8			;	ld de, hd_menu2 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a, display_row_3 
92b8			;	ld de, hd_menu3 
92b8			;	call str_at_display 
92b8			; 
92b8			;	ld a,  display_row_4 
92b8			;	ld de, hd_menu4 
92b8			;	call str_at_display 
92b8			; 
92b8			;	; display debug state 
92b8			; 
92b8			;	ld de, hd_don 
92b8			;	ld a, (os_view_disable) 
92b8			;	cp 0 
92b8			;	jr z, .distog 
92b8			;	ld de, hd_doff 
92b8			;.distog: ld a, display_row_4+17 
92b8			;	call str_at_display 
92b8			; 
92b8			;	call update_display 
92b8			; 
92b8			;	call cin_wait 
92b8			; 
92b8			; 
92b8			; 
92b8			;	cp '4' 
92b8			;	jr nz, .diagn1 
92b8			; 
92b8			;	; debug toggle 
92b8			; 
92b8			;	ld a, (os_view_disable) 
92b8			;	ld b, '*' 
92b8			;	cp 0 
92b8			;	jr z, .debtog 
92b8			;	ld b, 0 
92b8			;.debtog:	 
92b8			;	ld a,b 
92b8			;	ld (os_view_disable),a 
92b8			; 
92b8			;.diagn1: cp '0' 
92b8			;	 ret z 
92b8			; 
92b8			;;	cp '1' 
92b8			;;       jp z, matrix	 
92b8			;;   TODO keyboard matrix test 
92b8			; 
92b8			;	cp '2' 
92b8			;	jp z, .diagedit 
92b8			; 
92b8			;;	cp '6' 
92b8			;;	jp z, .menutest 
92b8			;;if ENABLE_BASIC 
92b8			;;	cp '6' 
92b8			;;	jp z, basic 
92b8			;;endif 
92b8			 ; 
92b8			;	jp .diagmenu 
92b8			; 
92b8			; 
92b8			;	ret 
92b8			 
92b8			 
92b8			.debug_tog: 
92b8 21 02 93			ld hl, .menudebug 
92bb				 
92bb			;	ld a, (os_view_disable) 
92bb			;	cp '*' 
92bb 3a 6f ee			ld a,(debug_vector) 
92be fe c9			cp $C9   ; RET 
92c0 20 04			jr nz,.tdon  
92c2 3e 01			ld a, 1 
92c4 18 02			jr .tog1 
92c6 3e 00		.tdon: ld a, 0 
92c8			 
92c8			.tog1: 
92c8 cd ee 8a			call menu 
92cb fe 00			cp 0 
92cd c8				ret z 
92ce fe 01			cp 1    ; disable debug 
92d0 28 04			jr z, .dtog0 
92d2 3e 2a			ld a, '*' 
92d4 18 05			jr .dtogset 
92d6			.dtog0:  
92d6				;ld a, 0 
92d6 cd f4 93			call bp_on 
92d9 18 dd			jr .debug_tog 
92db			.dtogset:  
92db				; ld (os_view_disable), a 
92db cd 00 94			call bp_off 
92de c3 b8 92			jp .debug_tog 
92e1			 
92e1			 
92e1			hardware_diags:       
92e1			 
92e1			.diagm: 
92e1 21 f4 92			ld hl, .menuitems 
92e4 3e 00			ld a, 0 
92e6 cd ee 8a			call menu 
92e9			 
92e9 fe 00		         cp 0 
92eb c8				 ret z 
92ec			 
92ec fe 02			cp 2 
92ee ca 4d 93			jp z, .diagedit 
92f1			 
92f1			;	cp '6' 
92f1			;	jp z, .menutest 
92f1			;if ENABLE_BASIC 
92f1			;	cp '6' 
92f1			;	jp z, basic 
92f1			;endif 
92f1			  
92f1 c3 e1 92			jp .diagm 
92f4			 
92f4				 
92f4 08 93		.menuitems:   	dw .m1 
92f6 13 93				dw .m2 
92f8 1a 93				dw .m3 
92fa 22 93				dw .m5 
92fc 28 93				dw .m5a 
92fe 31 93				dw .m5b 
9300 00 00				dw 0 
9302			 
9302			.menudebug: 
9302 3a 93				dw .m6 
9304 43 93				dw .m7 
9306 00 00				dw 0 
9308			 
9308 .. 00		.m1:   db "Key Matrix",0 
9313 .. 00		.m2:   db "Editor",0 
931a .. 00		.m3:   db "Storage",0 
9322 .. 00		.m5:   db "Sound",0 
9328 .. 00		.m5a:  db "RAM Test",0 
9331 .. 00		.m5b:  db "LCD Test",0 
933a			 
933a .. 00		.m6:   db "Debug ON",0 
9343 .. 00		.m7:   db "Debug OFF",0 
934d			 
934d			; debug editor 
934d			 
934d			.diagedit: 
934d			 
934d 21 bb e2			ld hl, scratch 
9350			;	ld bc, 250 
9350			;	ldir 
9350				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9350 3e 00			ld a, 0 
9352 77				ld (hl), a 
9353 23				inc hl 
9354 77				ld (hl), a 
9355 23				inc hl 
9356 77				ld (hl), a 
9357			 
9357 cd bd 8a		        call clear_display 
935a cd e0 8a			call update_display 
935d				;ld a, 1 
935d				;ld (hardware_diag), a 
935d			.diloop: 
935d 3e 00			ld a, display_row_1 
935f 0e 00			ld c, 0 
9361 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9363 1e 28			ld e, 40 
9365			 
9365 21 bb e2			ld hl, scratch	 
9368 cd 17 8d			call input_str 
936b			 
936b 3e 28			ld a, display_row_2 
936d 11 bb e2			ld de, scratch 
9370 cd d0 8a			call str_at_display 
9373 cd e0 8a			call update_display 
9376			 
9376 c3 5d 93			jp .diloop 
9379			 
9379			 
9379			; pass word in hl 
9379			; a has display location 
9379			display_word_at: 
9379 f5				push af 
937a e5				push hl 
937b 7c				ld a,h 
937c 21 c0 e5			ld hl, os_word_scratch 
937f cd f3 8e			call hexout 
9382 e1				pop hl 
9383 7d				ld a,l 
9384 21 c2 e5			ld hl, os_word_scratch+2 
9387 cd f3 8e			call hexout 
938a 21 c4 e5			ld hl, os_word_scratch+4 
938d 3e 00			ld a,0 
938f 77				ld (hl),a 
9390 11 c0 e5			ld de,os_word_scratch 
9393 f1				pop af 
9394 cd d0 8a				call str_at_display 
9397 c9				ret 
9398			 
9398			display_ptr_state: 
9398			 
9398				; to restore afterwards 
9398			 
9398 d5				push de 
9399 c5				push bc 
939a e5				push hl 
939b f5				push af 
939c			 
939c				; for use in here 
939c			 
939c			;	push bc 
939c			;	push de 
939c			;	push hl 
939c			;	push af 
939c			 
939c cd bd 8a			call clear_display 
939f			 
939f 11 77 95			ld de, .ptrstate 
93a2 3e 00			ld a, display_row_1 
93a4 cd d0 8a			call str_at_display 
93a7			 
93a7				; display debug step 
93a7			 
93a7			 
93a7 11 65 ee			ld de, debug_mark 
93aa 3e 26			ld a, display_row_1+display_cols-2 
93ac cd d0 8a			call str_at_display 
93af			 
93af				; display a 
93af 11 81 95			ld de, .ptrcliptr 
93b2 3e 28			ld a, display_row_2 
93b4 cd d0 8a			call str_at_display 
93b7			 
93b7 f1				pop af 
93b8 2a 3a ea			ld hl,(cli_ptr) 
93bb 3e 30			ld a, display_row_2+8 
93bd cd 79 93			call display_word_at 
93c0			 
93c0			 
93c0				; display hl 
93c0			 
93c0			 
93c0 11 89 95			ld de, .ptrclioptr 
93c3 3e 32			ld a, display_row_2+10 
93c5 cd d0 8a			call str_at_display 
93c8			; 
93c8			;	pop hl 
93c8 3e 35			ld a, display_row_2+13 
93ca 2a 38 ea			ld hl,(cli_origptr) 
93cd cd 79 93			call display_word_at 
93d0			; 
93d0			;	 
93d0			;	; display de 
93d0			 
93d0			;	ld de, .regstatede 
93d0			;	ld a, display_row_3 
93d0			;	call str_at_display 
93d0			 
93d0			;	pop de 
93d0			;	ld h,d 
93d0			;	ld l, e 
93d0			;	ld a, display_row_3+3 
93d0			;	call display_word_at 
93d0			 
93d0			 
93d0				; display bc 
93d0			 
93d0			;	ld de, .regstatebc 
93d0			;	ld a, display_row_3+10 
93d0			;	call str_at_display 
93d0			 
93d0			;	pop bc 
93d0			;	ld h,b 
93d0			;	ld l, c 
93d0			;	ld a, display_row_3+13 
93d0			;	call display_word_at 
93d0			 
93d0			 
93d0				; display dsp 
93d0			 
93d0			;	ld de, .regstatedsp 
93d0			;	ld a, display_row_4 
93d0			;	call str_at_display 
93d0			 
93d0				 
93d0			;	ld hl,(cli_data_sp) 
93d0			;	ld a, display_row_4+4 
93d0			;	call display_word_at 
93d0			 
93d0				; display rsp 
93d0			 
93d0 11 b8 95			ld de, .regstatersp 
93d3 3e 82			ld a, display_row_4+10 
93d5 cd d0 8a			call str_at_display 
93d8			 
93d8				 
93d8 2a ec e9			ld hl,(cli_ret_sp) 
93db 3e 86			ld a, display_row_4+14 
93dd cd 79 93			call display_word_at 
93e0			 
93e0 cd e0 8a			call update_display 
93e3			 
93e3 cd 00 8a			call delay1s 
93e6 cd 00 8a			call delay1s 
93e9 cd 00 8a			call delay1s 
93ec			 
93ec			 
93ec cd fd 99			call next_page_prompt 
93ef			 
93ef				; restore  
93ef			 
93ef f1				pop af 
93f0 e1				pop hl 
93f1 c1				pop bc 
93f2 d1				pop de 
93f3 c9				ret 
93f4			 
93f4			; Update the break point vector so that the user can hook a new routine 
93f4			 
93f4			bp_on: 
93f4 3e c3			ld a, $c3    ; JP 
93f6 32 6f ee			ld (debug_vector), a 
93f9 21 06 94			ld hl, break_point_state 
93fc 22 70 ee			ld (debug_vector+1), hl 
93ff c9				ret 
9400			 
9400			bp_off: 
9400 3e c9			ld a, $c9    ; RET 
9402 32 6f ee			ld (debug_vector), a 
9405 c9				ret 
9406			 
9406			 
9406			break_point_state: 
9406			;	push af 
9406			; 
9406			;	; see if disabled 
9406			; 
9406			;	ld a, (os_view_disable) 
9406			;	cp '*' 
9406			;	jr nz, .bpsgo 
9406			;	pop af 
9406			;	ret 
9406			 
9406			.bpsgo: 
9406			;	pop af 
9406 f5				push af 
9407 22 9d e2			ld (os_view_hl), hl 
940a ed 53 9b e2		ld (os_view_de), de 
940e ed 43 99 e2		ld (os_view_bc), bc 
9412 e5				push hl 
9413 6f				ld l, a 
9414 26 00			ld h, 0 
9416 22 9f e2			ld (os_view_af),hl 
9419			 
9419 21 ab ed				ld hl, display_fb0 
941c 22 c6 eb				ld (display_fb_active), hl 
941f e1				pop hl	 
9420			 
9420 3e 31			ld a, '1' 
9422 fe 2a		.bps1:  cp '*' 
9424 cc 00 94			call z, bp_off 
9427			;	jr nz, .bps1b 
9427			;	ld (os_view_disable),a 
9427 fe 31		.bps1b:  cp '1' 
9429 20 14			jr nz, .bps2 
942b			 
942b				; display reg 
942b			 
942b				 
942b			 
942b 3a 9f e2			ld a, (os_view_af) 
942e 2a 9d e2			ld hl, (os_view_hl) 
9431 ed 5b 9b e2		ld de, (os_view_de) 
9435 ed 4b 99 e2		ld bc, (os_view_bc) 
9439 cd d3 94			call display_reg_state 
943c c3 bf 94			jp .bpschk 
943f			 
943f fe 32		.bps2:  cp '2' 
9441 20 08			jr nz, .bps3 
9443				 
9443				; display hl 
9443 2a 9d e2			ld hl, (os_view_hl) 
9446 cd bd 95			call display_dump_at_hl 
9449			 
9449 18 74			jr .bpschk 
944b			 
944b fe 33		.bps3:  cp '3' 
944d 20 08			jr nz, .bps4 
944f			 
944f			        ; display de 
944f 2a 9b e2			ld hl, (os_view_de) 
9452 cd bd 95			call display_dump_at_hl 
9455			 
9455 18 68			jr .bpschk 
9457 fe 34		.bps4:  cp '4' 
9459 20 08			jr nz, .bps5 
945b			 
945b			        ; display bc 
945b 2a 99 e2			ld hl, (os_view_bc) 
945e cd bd 95			call display_dump_at_hl 
9461			 
9461 18 5c			jr .bpschk 
9463 fe 35		.bps5:  cp '5' 
9465 20 08		        jr nz, .bps7 
9467			 
9467				; display cur ptr 
9467 2a 3a ea			ld hl, (cli_ptr) 
946a cd bd 95			call display_dump_at_hl 
946d			 
946d 18 50			jr .bpschk 
946f fe 36		.bps7:  cp '6' 
9471 20 08			jr nz, .bps8b 
9473				 
9473				; display cur orig ptr 
9473 2a 38 ea			ld hl, (cli_origptr) 
9476 cd bd 95			call display_dump_at_hl 
9479 18 44			jr .bpschk 
947b fe 37		.bps8b:  cp '7' 
947d 20 08			jr nz, .bps9 
947f				 
947f				; display dsp 
947f 2a e8 e9			ld hl, (cli_data_sp) 
9482 cd bd 95			call display_dump_at_hl 
9485			 
9485 18 38			jr .bpschk 
9487 fe 39		.bps9:  cp '9' 
9489 20 05			jr nz, .bps8c 
948b				 
948b				; display SP 
948b			;	ld hl, sp 
948b cd bd 95			call display_dump_at_hl 
948e			 
948e 18 2f			jr .bpschk 
9490 fe 38		.bps8c:  cp '8' 
9492 20 08			jr nz, .bps8d 
9494				 
9494				; display rsp 
9494 2a ec e9			ld hl, (cli_ret_sp) 
9497 cd bd 95			call display_dump_at_hl 
949a			 
949a 18 23			jr .bpschk 
949c fe 23		.bps8d:  cp '#'     ; access monitor sub system 
949e 20 05			jr nz, .bps8 
94a0 cd b7 97			call monitor 
94a3			 
94a3 18 1a			jr .bpschk 
94a5 fe 30		.bps8:  cp '0' 
94a7 20 16			jr nz, .bpschk 
94a9			 
94a9 21 0a ed				ld hl, display_fb1 
94ac 22 c6 eb				ld (display_fb_active), hl 
94af cd e0 8a				call update_display 
94b2			 
94b2				;ld a, (os_view_af) 
94b2 2a 9d e2			ld hl, (os_view_hl) 
94b5 ed 5b 9b e2		ld de, (os_view_de) 
94b9 ed 4b 99 e2		ld bc, (os_view_bc) 
94bd f1				pop af 
94be c9				ret 
94bf			 
94bf			.bpschk:   
94bf cd 00 8a			call delay1s 
94c2 3e 9f		ld a,display_row_4 + display_cols - 1 
94c4 11 fb 99		        ld de, endprg 
94c7 cd d0 8a			call str_at_display 
94ca cd e0 8a			call update_display 
94cd cd aa e2			call cin_wait 
94d0			 
94d0 c3 22 94			jp .bps1 
94d3			 
94d3			 
94d3			display_reg_state: 
94d3			 
94d3				; to restore afterwards 
94d3			 
94d3 d5				push de 
94d4 c5				push bc 
94d5 e5				push hl 
94d6 f5				push af 
94d7			 
94d7				; for use in here 
94d7			 
94d7 c5				push bc 
94d8 d5				push de 
94d9 e5				push hl 
94da f5				push af 
94db			 
94db cd bd 8a			call clear_display 
94de			 
94de 11 93 95			ld de, .regstate 
94e1 3e 00			ld a, display_row_1 
94e3 cd d0 8a			call str_at_display 
94e6			 
94e6				; display debug step 
94e6			 
94e6			 
94e6 11 65 ee			ld de, debug_mark 
94e9 3e 25			ld a, display_row_1+display_cols-3 
94eb cd d0 8a			call str_at_display 
94ee			 
94ee				; display a 
94ee 11 af 95			ld de, .regstatea 
94f1 3e 28			ld a, display_row_2 
94f3 cd d0 8a			call str_at_display 
94f6			 
94f6 e1				pop hl 
94f7			;	ld h,0 
94f7			;	ld l, a 
94f7 3e 2b			ld a, display_row_2+3 
94f9 cd 79 93			call display_word_at 
94fc			 
94fc			 
94fc				; display hl 
94fc			 
94fc			 
94fc 11 a3 95			ld de, .regstatehl 
94ff 3e 32			ld a, display_row_2+10 
9501 cd d0 8a			call str_at_display 
9504			 
9504 e1				pop hl 
9505 3e 35			ld a, display_row_2+13 
9507 cd 79 93			call display_word_at 
950a			 
950a				 
950a				; display de 
950a			 
950a 11 a7 95			ld de, .regstatede 
950d 3e 50			ld a, display_row_3 
950f cd d0 8a			call str_at_display 
9512			 
9512 e1				pop hl 
9513			;	ld h,d 
9513			;	ld l, e 
9513 3e 53			ld a, display_row_3+3 
9515 cd 79 93			call display_word_at 
9518			 
9518			 
9518				; display bc 
9518			 
9518 11 ab 95			ld de, .regstatebc 
951b 3e 5a			ld a, display_row_3+10 
951d cd d0 8a			call str_at_display 
9520			 
9520 e1				pop hl 
9521			;	ld h,b 
9521			;	ld l, c 
9521 3e 5d			ld a, display_row_3+13 
9523 cd 79 93			call display_word_at 
9526			 
9526			 
9526				; display dsp 
9526			 
9526 11 b3 95			ld de, .regstatedsp 
9529 3e 78			ld a, display_row_4 
952b cd d0 8a			call str_at_display 
952e			 
952e				 
952e 2a e8 e9			ld hl,(cli_data_sp) 
9531 3e 7c			ld a, display_row_4+4 
9533 cd 79 93			call display_word_at 
9536			 
9536				; display rsp 
9536			 
9536 11 b8 95			ld de, .regstatersp 
9539 3e 82			ld a, display_row_4+10 
953b cd d0 8a			call str_at_display 
953e			 
953e				 
953e 2a ec e9			ld hl,(cli_ret_sp) 
9541 3e 86			ld a, display_row_4+14 
9543 cd 79 93			call display_word_at 
9546			 
9546 cd e0 8a			call update_display 
9549			 
9549			;	call delay1s 
9549			;	call delay1s 
9549			;	call delay1s 
9549			 
9549			 
9549			;	call next_page_prompt 
9549			 
9549				; restore  
9549			 
9549 f1				pop af 
954a e1				pop hl 
954b c1				pop bc 
954c d1				pop de 
954d c9				ret 
954e			 
954e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9562 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9577 .. 00		.ptrstate:	db "Ptr State",0 
9581 .. 00		.ptrcliptr:     db "cli_ptr",0 
9589 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9593 .. 00		.regstate:	db "Reg State (1/0)",0 
95a3 .. 00		.regstatehl:	db "HL:",0 
95a7 .. 00		.regstatede:	db "DE:",0 
95ab .. 00		.regstatebc:	db "BC:",0 
95af .. 00		.regstatea:	db "A :",0 
95b3 .. 00		.regstatedsp:	db "DSP:",0 
95b8 .. 00		.regstatersp:	db "RSP:",0 
95bd			 
95bd			display_dump_at_hl: 
95bd e5				push hl 
95be d5				push de 
95bf c5				push bc 
95c0 f5				push af 
95c1			 
95c1 22 de e5			ld (os_cur_ptr),hl	 
95c4 cd bd 8a			call clear_display 
95c7 cd 05 99			call dumpcont 
95ca			;	call delay1s 
95ca			;	call next_page_prompt 
95ca			 
95ca			 
95ca f1				pop af 
95cb c1				pop bc 
95cc d1				pop de 
95cd e1				pop hl 
95ce c9				ret 
95cf			 
95cf			;if ENABLE_BASIC 
95cf			;	include "nascombasic.asm" 
95cf			;	basic: 
95cf			;	include "forth/FORTH.ASM" 
95cf			;endif 
95cf			 
95cf			; eof 
95cf			 
95cf			 
# End of file firmware_diags.asm
95cf			  
95cf			include "firmware_prompts.asm"  
95cf			; Prompts  
95cf			 
95cf			; boot messages 
95cf			 
95cf .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95e4 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95f4			 
95f4			 
95f4			; config menus 
95f4			 
95f4			;prom_c3: db "Add Dictionary To File",0 
95f4			 
95f4			if STARTUP_V1 
95f4 .. 00		prom_c2: db "Select Autoload File",0 
9609 .. 00		prom_c2a: db "Disable Autoload File", 0 
961f			endif 
961f			 
961f			if STARTUP_V2 
961f			prom_c2: db "Enable Autoload Files",0 
961f			prom_c2a: db "Disable Autoload Files", 0 
961f			 
961f			crs_s1: db "*ls-word", 0 
961f			crs_s2: db "*ed-word", 0 
961f			crs_s3: db "*Demo-Games", 0 
961f			crs_s4: db "*Utils", 0 
961f			crs_s5: db "*SPI-Util", 0 
961f			crs_s6: db "*Key-Constants", 0 
961f			crs_sound: db "*Sound-Util", 0 
961f			crs_hw: db "*Hello-World",0 
961f			 
961f			 
961f			 
961f			endif 
961f			;prom_c2b: db "Select Storage Bank",0 
961f .. 00		prom_c4: db "Settings",0 
9628 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9643 .. 00		prom_m4b:   db "Monitor",0 
964b .. 00		prom_c1: db "Hardware Diags",0 
965a			 
965a			 
965a			if STARTUP_V2 
965a			prom_c9: db "Create Startup Files",0 
965a			endif 
965a			 
965a .. 00		prom_notav:    db "Feature not available",0 
9670 .. 00		prom_empty:    db "",0 
9671			 
9671			; eof 
9671			 
# End of file firmware_prompts.asm
9671			  
9671			; eof  
9671			  
# End of file firmware.asm
9671			 
9671			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9671			;if BASE_KEV  
9671			;baseram: equ 08000h 
9671			;endif 
9671			 
9671			;if BASE_SC114 
9671			;baseram:     equ    endofcode 
9671			;endif 
9671			 
9671			 
9671			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9671			 
9671			; start system 
9671			 
9671			coldstart: 
9671				; set sp 
9671				; di/ei 
9671			 
9671 f3				di 
9672 31 00 f0			ld sp, tos 
9675 cd f4 e1			call init_nmi 
9678			;	ei 
9678			 
9678				; init spinner 
9678 3e 00			ld a,0 
967a 32 c0 eb			ld (display_active), a 
967d			 
967d				; disable breakpoint by default 
967d			 
967d				;ld a,'*' 
967d			;	ld a,' ' 
967d			;	ld (os_view_disable),a 
967d			 
967d				; set break point vector as new break point on or off 
967d cd 00 94			call bp_off 
9680			 
9680				; init hardware 
9680			 
9680				; init keyboard and screen hardware 
9680			 
9680 cd 1f 80			call hardware_init 
9683			 
9683			 
9683 cd 00 8a			call delay1s 
9686 3e 58			ld a, display_row_3+8 
9688 11 03 80			ld de, buildtime 
968b cd d0 8a			call str_at_display 
968e cd e0 8a			call update_display 
9691			 
9691 cd 00 8a			call delay1s 
9694 cd 00 8a			call delay1s 
9697 cd 00 8a			call delay1s 
969a			 
969a				; detect if any keys are held down to enable breakpoints at start up 
969a			 
969a cd b0 e2			call cin  
969d fe 00			cp 0 
969f 28 03			jr z, .nokeys 
96a1			 
96a1				;call hardware_diags 
96a1 cd 5e 92			call config 
96a4			 
96a4			;	ld de, .bpen 
96a4			;	ld a, display_row_4 
96a4			;	call str_at_display 
96a4			;	call update_display 
96a4			; 
96a4			;	ld a,0 
96a4			;	ld (os_view_disable),a 
96a4			; 
96a4			;.bpwait: 
96a4			;	call cin 
96a4			;	cp 0 
96a4			;	jr z, .bpwait 
96a4			;	jr .nokeys 
96a4			; 
96a4			; 
96a4			;.bpen:  db "Break points enabled!",0 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			.nokeys: 
96a4			 
96a4			 
96a4				 
96a4			 
96a4			;jp  testkey 
96a4			 
96a4			;call storage_get_block_0 
96a4			; 
96a4			;ld hl, 0 
96a4			;ld de, store_page 
96a4			;call storage_read_block 
96a4			 
96a4				 
96a4			;ld hl, 10 
96a4			;ld de, store_page 
96a4			;call storage_read_block 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			 
96a4			;stop:	nop 
96a4			;	jp stop 
96a4			 
96a4			 
96a4			 
96a4			main: 
96a4 cd bd 8a			call clear_display 
96a7 cd e0 8a			call update_display 
96aa			 
96aa			 
96aa			 
96aa			;	call testlcd 
96aa			 
96aa			 
96aa			 
96aa cd 45 9e			call forth_init 
96ad			 
96ad			 
96ad			warmstart: 
96ad cd 1b 9e			call forth_warmstart 
96b0			 
96b0				; run startup word load 
96b0			        ; TODO prevent this running at warmstart after crash  
96b0			 
96b0				if STARTUP_ENABLE 
96b0			 
96b0					if STARTUP_V1 
96b0			 
96b0						if STORAGE_SE 
96b0							call forth_autoload 
96b0						endif 
96b0 cd 44 e1					call forth_startup 
96b3					endif 
96b3			 
96b3					if STARTUP_V2 
96b3			 
96b3						if STORAGE_SE 
96b3							call forth_autoload 
96b3						else 
96b3							call forth_startup 
96b3						endif 
96b3			 
96b3			 
96b3					endif 
96b3			 
96b3				endif 
96b3			 
96b3			warmstart_afterauto: 
96b3			 
96b3				; show free memory after boot 
96b3 11 52 97			ld de, freeram 
96b6 3e 00			ld a, display_row_1 
96b8 cd d0 8a			call str_at_display 
96bb			 
96bb				; get current heap start after loading any uwords 
96bb			 
96bb				;ld de, (os_last_new_uword) 
96bb				;ex de, hl 
96bb			 
96bb			; Or use heap_size word???? 
96bb				;ld hl, heap_end 
96bb				;ld hl, heap_size 
96bb				;ld de, topusermem 
96bb				;ld de, heap_start 
96bb ed 5b c9 e2			ld de, (free_list )      
96bf 21 96 e2				ld hl, heap_end 
96c2 ed 52			sbc hl, de 
96c4				;push hl 
96c4				;ld a,h	         	 
96c4				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96c4				;call hexout 
96c4			   	;pop hl 
96c4			; 
96c4			;	ld a,l 
96c4			;	ld hl, os_word_scratch+2 
96c4			;	call hexout 
96c4			;	ld hl, os_word_scratch+4 
96c4			;	ld a, 0 
96c4			;	ld (hl),a 
96c4 eb				ex de, hl 
96c5 21 c0 e5			ld hl, os_word_scratch 
96c8 cd ff 8f			call uitoa_16 
96cb			 
96cb			 
96cb 11 c0 e5			ld de, os_word_scratch 
96ce 3e 0d			ld a, display_row_1 + 13 
96d0 cd d0 8a			call str_at_display 
96d3 cd e0 8a			call update_display 
96d6			 
96d6			 
96d6				;call demo 
96d6			 
96d6			 
96d6				; init scratch input area for cli commands 
96d6			 
96d6 21 e2 e5			ld hl, os_cli_cmd 
96d9 3e 00			ld a,0 
96db 77				ld (hl),a 
96dc 23				inc hl 
96dd 77				ld (hl),a 
96de			 
96de 3e 00			ld a,0 
96e0 32 e1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96e3			 
96e3 32 de e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96e6 32 df e5			ld (os_cur_ptr+1),a	 
96e9			 
96e9 32 c0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96ec 32 c1 e5			ld (os_word_scratch+1),a	 
96ef				 
96ef			 
96ef				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96ef 21 e2 e5			ld hl, os_cli_cmd 
96f2			 
96f2 3e 00			ld a, 0		 ; init cli input 
96f4 77				ld (hl), a 
96f5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96f7			cli: 
96f7				; show cli prompt 
96f7				;push af 
96f7				;ld a, 0 
96f7				;ld de, prompt 
96f7				;call str_at_display 
96f7			 
96f7				;call update_display 
96f7				;pop af 
96f7				;inc a 
96f7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96f7			 
96f7			.lastrecall: 
96f7			 
96f7 0e 00			ld c, 0 
96f9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96fb 1e 28			ld e, 40 
96fd			 
96fd 21 e2 e5			ld hl, os_cli_cmd 
9700			 
9700				STACKFRAME OFF $fefe $9f9f 
9700				if DEBUG_STACK_IMB 
9700					if OFF 
9700						exx 
9700						ld de, $fefe 
9700						ld a, d 
9700						ld hl, curframe 
9700						call hexout 
9700						ld a, e 
9700						ld hl, curframe+2 
9700						call hexout 
9700						ld hl, $fefe 
9700						push hl 
9700						ld hl, $9f9f 
9700						push hl 
9700						exx 
9700					endif 
9700				endif 
9700			endm 
# End of macro STACKFRAME
9700			 
9700 cd 17 8d			call input_str 
9703			 
9703				STACKFRAMECHK OFF $fefe $9f9f 
9703				if DEBUG_STACK_IMB 
9703					if OFF 
9703						exx 
9703						ld hl, $9f9f 
9703						pop de   ; $9f9f 
9703						call cmp16 
9703						jr nz, .spnosame 
9703						ld hl, $fefe 
9703						pop de   ; $fefe 
9703						call cmp16 
9703						jr z, .spfrsame 
9703						.spnosame: call showsperror 
9703						.spfrsame: nop 
9703						exx 
9703					endif 
9703				endif 
9703			endm 
# End of macro STACKFRAMECHK
9703			 
9703			 
9703				; check to see if last line recall has been requested 
9703			 
9703			if EDIT_V2 
9703 fe 05			cp KEY_UP 
9705 20 0f			jr nz, .noexecline 
9707			 
9707 11 e2 e5			ld de, os_cli_cmd 
970a 21 e1 e6			ld hl, os_last_cmd 
970d 01 ff 00			ld bc, 255 
9710 ed b0			ldir 
9712 3e 00			ld a, 0 
9714 18 e1			jr .lastrecall 
9716			endif 
9716			 
9716			.noexecline: 
9716				; no so exec the line		 
9716			 
9716				; copy input to last command 
9716			 
9716 21 e2 e5			ld hl, os_cli_cmd 
9719 11 e1 e6			ld de, os_last_cmd 
971c 01 ff 00			ld bc, 255 
971f ed b0			ldir 
9721			 
9721				; wipe current buffer 
9721			 
9721			;	ld a, 0 
9721			;	ld hl, os_cli_cmd 
9721			;	ld de, os_cli_cmd+1 
9721			;	ld bc, 254 
9721			;	ldir 
9721				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9721			;	call strcpy 
9721			;	ld a, 0 
9721			;	ld (hl), a 
9721			;	inc hl 
9721			;	ld (hl), a 
9721			;	inc hl 
9721			;	ld (hl), a 
9721			 
9721				; switch frame buffer to program  
9721			 
9721 21 0a ed				ld hl, display_fb1 
9724 22 c6 eb				ld (display_fb_active), hl 
9727			 
9727			;	nop 
9727				STACKFRAME ON $fbfe $8f9f 
9727				if DEBUG_STACK_IMB 
9727					if ON 
9727						exx 
9727						ld de, $fbfe 
9727						ld a, d 
9727						ld hl, curframe 
9727						call hexout 
9727						ld a, e 
9727						ld hl, curframe+2 
9727						call hexout 
9727						ld hl, $fbfe 
9727						push hl 
9727						ld hl, $8f9f 
9727						push hl 
9727						exx 
9727					endif 
9727				endif 
9727			endm 
# End of macro STACKFRAME
9727				; first time into the parser so pass over the current scratch pad 
9727 21 e2 e5			ld hl,os_cli_cmd 
972a				; tokenise the entered statement(s) in HL 
972a cd bf 9e			call forthparse 
972d			        ; exec forth statements in top of return stack 
972d cd fb 9e			call forthexec 
9730				;call forthexec_cleanup 
9730			;	call parsenext 
9730			 
9730				STACKFRAMECHK ON $fbfe $8f9f 
9730				if DEBUG_STACK_IMB 
9730					if ON 
9730						exx 
9730						ld hl, $8f9f 
9730						pop de   ; $8f9f 
9730						call cmp16 
9730						jr nz, .spnosame 
9730						ld hl, $fbfe 
9730						pop de   ; $fbfe 
9730						call cmp16 
9730						jr z, .spfrsame 
9730						.spnosame: call showsperror 
9730						.spfrsame: nop 
9730						exx 
9730					endif 
9730				endif 
9730			endm 
# End of macro STACKFRAMECHK
9730				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9730			 
9730 3e 78			ld a, display_row_4 
9732 11 63 97			ld de, endprog 
9735			 
9735 cd e0 8a			call update_display		 
9738			 
9738 cd fd 99			call next_page_prompt 
973b			 
973b				; switch frame buffer to cli 
973b			 
973b 21 ab ed				ld hl, display_fb0 
973e 22 c6 eb				ld (display_fb_active), hl 
9741			 
9741			 
9741 cd bd 8a		        call clear_display 
9744 cd e0 8a			call update_display		 
9747			 
9747 21 e2 e5			ld hl, os_cli_cmd 
974a			 
974a 3e 00			ld a, 0		 ; init cli input 
974c 77				ld (hl), a 
974d			 
974d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
974d			 
974d				; now on last line 
974d			 
974d				; TODO scroll screen up 
974d			 
974d				; TODO instead just clear screen and place at top of screen 
974d			 
974d			;	ld a, 0 
974d			;	ld (f_cursor_ptr),a 
974d			 
974d				;call clear_display 
974d				;call update_display 
974d			 
974d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974f c3 f7 96			jp cli 
9752			 
9752 .. 00		freeram: db "Free bytes: ",0 
975f ..			asc: db "1A2F" 
9763 .. 00		endprog: db "End prog...",0 
976f			 
976f			testenter2:   
976f 21 ed e2			ld hl,scratch+50 
9772 22 de e5			ld (os_cur_ptr),hl 
9775 c3 f7 96			jp cli 
9778			 
9778			testenter:  
9778			 
9778 21 5f 97			ld hl,asc 
977b			;	ld a,(hl) 
977b			;	call nibble2val 
977b cd 49 8f			call get_byte 
977e			 
977e			 
977e			;	ld a,(hl) 
977e			;	call atohex 
977e			 
977e			;	call fourehexhl 
977e 32 ed e2			ld (scratch+50),a 
9781			 
9781			 
9781			 
9781 21 61 97			ld hl,asc+2 
9784			;	ld a, (hl) 
9784			;	call nibble2val 
9784 cd 49 8f			call get_byte 
9787			 
9787			;	call fourehexhl 
9787 32 ef e2			ld (scratch+52),a 
978a				 
978a 21 ed e2			ld hl,scratch+50 
978d 22 de e5			ld (os_cur_ptr),hl 
9790 c3 f7 96			jp cli 
9793			 
9793			enter:	 
9793 3a bf e2			ld a,(scratch+4) 
9796 fe 00			cp 0 
9798 28 0c			jr z, .entercont 
979a				; no, not a null term line so has an address to work out.... 
979a			 
979a 21 bd e2			ld hl,scratch+2 
979d cd a9 8f			call get_word_hl 
97a0			 
97a0 22 de e5			ld (os_cur_ptr),hl	 
97a3 c3 f7 96			jp cli 
97a6			 
97a6			 
97a6			.entercont:  
97a6			 
97a6 21 bd e2			ld hl, scratch+2 
97a9 cd 49 8f			call get_byte 
97ac			 
97ac 2a de e5		   	ld hl,(os_cur_ptr) 
97af 77					ld (hl),a 
97b0 23					inc hl 
97b1 22 de e5				ld (os_cur_ptr),hl 
97b4				 
97b4			; get byte  
97b4			 
97b4			 
97b4 c3 f7 96			jp cli 
97b7			 
97b7			 
97b7			; basic monitor support 
97b7			 
97b7			monitor: 
97b7				;  
97b7 cd bd 8a			call clear_display 
97ba 3e 00			ld a, 0 
97bc 11 10 98			ld de, .monprompt 
97bf cd d0 8a			call str_at_display 
97c2 cd e0 8a			call update_display 
97c5			 
97c5				; get a monitor command 
97c5			 
97c5 0e 00			ld c, 0     ; entry at top left 
97c7 16 64			ld d, 100   ; max buffer size 
97c9 1e 0f			ld e, 15    ; input scroll area 
97cb 3e 00			ld a, 0     ; init string 
97cd 21 b9 e4			ld hl, os_input 
97d0 77				ld (hl), a 
97d1 23				inc hl 
97d2 77				ld (hl), a 
97d3 21 b9 e4			ld hl, os_input 
97d6 3e 01			ld a, 1     ; init string 
97d8 cd 17 8d			call input_str 
97db			 
97db cd bd 8a		        call clear_display 
97de cd e0 8a			call update_display		 
97e1			 
97e1 3a b9 e4			ld a, (os_input) 
97e4 cd 47 90			call toUpper 
97e7 fe 48		        cp 'H' 
97e9 ca 84 98		        jp z, .monhelp 
97ec fe 44			cp 'D'		; dump 
97ee ca b7 98			jp z, .mondump	 
97f1 fe 43			cp 'C'		; dump 
97f3 ca d1 98			jp z, .moncdump	 
97f6 fe 4d			cp 'M'		; dump 
97f8 ca 12 98			jp z, .moneditstart 
97fb fe 55			cp 'U'		; dump 
97fd ca 1e 98			jp z, .monedit	 
9800 fe 47			cp 'G'		; dump 
9802 ca ad 98			jp z, .monjump 
9805 fe 42			cp 'B'		; forth breakpoint 
9807 cc 06 94			call z, break_point_state 
980a fe 51			cp 'Q'		; dump 
980c c8				ret z	 
980d			 
980d			 
980d				; TODO "S" to access symbol by name and not need the address 
980d				; TODO "F" to find a string in memory 
980d			 
980d c3 b7 97			jp monitor 
9810			 
9810 .. 00		.monprompt: db ">", 0 
9812			 
9812			.moneditstart: 
9812				; get starting address 
9812			 
9812 21 bb e4			ld hl,os_input+2 
9815 cd a9 8f			call get_word_hl 
9818			 
9818 22 de e5			ld (os_cur_ptr),hl	 
981b			 
981b c3 b7 97			jp monitor 
981e			 
981e			.monedit: 
981e				; get byte to load 
981e			 
981e 21 bb e4			ld hl,os_input+2 
9821 cd 49 8f			call get_byte 
9824			 
9824				; get address to update 
9824 2a de e5			ld hl, (os_cur_ptr) 
9827			 
9827				; update byte 
9827			 
9827 77				ld (hl), a 
9828			 
9828				; move to next address and save it 
9828			 
9828 23				inc hl 
9829 22 de e5			ld (os_cur_ptr),hl	 
982c			 
982c c3 b7 97			jp monitor 
982f			 
982f			 
982f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9843 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
985f .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
987d .. 00		.monhelptext4:  db "Q-Quit",0 
9884			        
9884			.monhelp: 
9884 3e 00			ld a, display_row_1 
9886 11 2f 98		        ld de, .monhelptext1 
9889			 
9889 cd d0 8a			call str_at_display 
988c 3e 28			ld a, display_row_2 
988e 11 43 98		        ld de, .monhelptext2 
9891					 
9891 cd d0 8a			call str_at_display 
9894 3e 50			ld a, display_row_3 
9896 11 5f 98		        ld de, .monhelptext3 
9899					 
9899 cd d0 8a			call str_at_display 
989c 3e 78			ld a, display_row_4 
989e 11 7d 98		        ld de, .monhelptext4 
98a1 cd d0 8a			call str_at_display 
98a4			 
98a4 cd e0 8a			call update_display		 
98a7			 
98a7 cd fd 99			call next_page_prompt 
98aa c3 b7 97			jp monitor 
98ad			 
98ad			.monjump:    
98ad 21 bb e4			ld hl,os_input+2 
98b0 cd a9 8f			call get_word_hl 
98b3			 
98b3 e9				jp (hl) 
98b4 c3 b7 97			jp monitor 
98b7			 
98b7			.mondump:    
98b7 21 bb e4			ld hl,os_input+2 
98ba cd a9 8f			call get_word_hl 
98bd			 
98bd 22 de e5			ld (os_cur_ptr),hl	 
98c0 cd 05 99			call dumpcont 
98c3 3e 78			ld a, display_row_4 
98c5 11 63 97			ld de, endprog 
98c8			 
98c8 cd e0 8a			call update_display		 
98cb			 
98cb cd fd 99			call next_page_prompt 
98ce c3 b7 97			jp monitor 
98d1			.moncdump: 
98d1 cd 05 99			call dumpcont 
98d4 3e 78			ld a, display_row_4 
98d6 11 63 97			ld de, endprog 
98d9			 
98d9 cd e0 8a			call update_display		 
98dc			 
98dc cd fd 99			call next_page_prompt 
98df c3 b7 97			jp monitor 
98e2			 
98e2			 
98e2			; TODO symbol access  
98e2			 
98e2			.symbols:     ;; A list of symbols that can be called up  
98e2 ab ed			dw display_fb0 
98e4 .. 00			db "fb0",0  
98e8 74 ea		     	dw store_page 
98ea .. 00			db "store_page",0 
98f5			 
98f5			 
98f5			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98f5			 
98f5 3a bc e2			ld a,(scratch+1) 
98f8 fe 00			cp 0 
98fa 28 09			jr z, dumpcont 
98fc			 
98fc				; no, not a null term line so has an address to work out.... 
98fc			 
98fc 21 bd e2			ld hl,scratch+2 
98ff cd a9 8f			call get_word_hl 
9902			 
9902 22 de e5			ld (os_cur_ptr),hl	 
9905			 
9905			 
9905			 
9905			dumpcont: 
9905			 
9905				; dump bytes at ptr 
9905			 
9905			 
9905 3e 00			ld a, display_row_1 
9907 2a c6 eb			ld hl, (display_fb_active) 
990a cd ea 8c			call addatohl 
990d cd 35 99			call .dumpbyterow 
9910			 
9910 3e 28			ld a, display_row_2 
9912 2a c6 eb			ld hl, (display_fb_active) 
9915 cd ea 8c			call addatohl 
9918 cd 35 99			call .dumpbyterow 
991b			 
991b			 
991b 3e 50			ld a, display_row_3 
991d 2a c6 eb			ld hl, (display_fb_active) 
9920 cd ea 8c			call addatohl 
9923 cd 35 99			call .dumpbyterow 
9926			 
9926 3e 78			ld a, display_row_4 
9928 2a c6 eb			ld hl, (display_fb_active) 
992b cd ea 8c			call addatohl 
992e cd 35 99			call .dumpbyterow 
9931			 
9931 cd e0 8a			call update_display 
9934			;		jp cli 
9934 c9				ret 
9935			 
9935			.dumpbyterow: 
9935			 
9935				;push af 
9935			 
9935 e5				push hl 
9936			 
9936				; calc where to poke the ascii 
9936			if display_cols == 20 
9936				ld a, 16 
9936			else 
9936 3e 1f			ld a, 31 
9938			endif 
9938			 
9938 cd ea 8c			call addatohl 
993b 22 c0 e5			ld (os_word_scratch),hl  		; save pos for later 
993e			 
993e			 
993e			; display decoding address 
993e 2a de e5		   	ld hl,(os_cur_ptr) 
9941			 
9941 7c				ld a,h 
9942 e1				pop hl 
9943 e5				push hl 
9944			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9944 cd f3 8e			call hexout 
9947 2a de e5		   	ld hl,(os_cur_ptr) 
994a			 
994a 7d				ld a,l 
994b e1				pop hl 
994c 23				inc hl 
994d 23				inc hl 
994e e5				push hl 
994f			;	ld hl, os_word_scratch+2 
994f cd f3 8e			call hexout 
9952 e1				pop hl 
9953 23				inc hl 
9954 23				inc hl 
9955				;ld hl, os_word_scratch+4 
9955 3e 3a			ld a, ':' 
9957 77				ld (hl),a 
9958 23				inc hl 
9959				;ld a, 0 
9959				;ld (hl),a 
9959				;ld de, os_word_scratch 
9959				;pop af 
9959				;push af 
9959			;		ld a, display_row_2 
9959			;		call str_at_display 
9959			;		call update_display 
9959			 
9959			 
9959			;pop af 
9959			;	add 5 
9959			 
9959			if display_cols == 20 
9959				ld b, 4 
9959			else 
9959 06 08			ld b, 8 
995b			endif	 
995b			 
995b			.dumpbyte: 
995b c5				push bc 
995c e5				push hl 
995d			 
995d			 
995d 2a de e5		   	ld hl,(os_cur_ptr) 
9960 7e					ld a,(hl) 
9961			 
9961					; poke the ascii to display 
9961 2a c0 e5				ld hl,(os_word_scratch) 
9964 77					ld (hl),a 
9965 23					inc hl 
9966 22 c0 e5				ld (os_word_scratch),hl 
9969			 
9969					 
9969			 
9969			 
9969 e1					pop hl 
996a e5					push hl 
996b			 
996b cd f3 8e				call hexout 
996e			 
996e					 
996e 2a de e5		   	ld hl,(os_cur_ptr) 
9971 23				inc hl 
9972 22 de e5		   	ld (os_cur_ptr),hl 
9975			 
9975 e1					pop hl 
9976 23					inc hl 
9977 23					inc hl 
9978 23					inc hl 
9979			 
9979			 
9979			 
9979					;ld a,0 
9979					;ld (os_word_scratch+2),a 
9979					;pop af 
9979					;push af 
9979			 
9979					;ld de, os_word_scratch 
9979					;call str_at_display 
9979			;		call update_display 
9979			;		pop af 
9979 c1					pop bc 
997a c6 03				add 3 
997c 10 dd			djnz .dumpbyte 
997e			 
997e				 
997e			 
997e c9				ret 
997f			 
997f			jump:	 
997f			 
997f 21 bd e2			ld hl,scratch+2 
9982 cd a9 8f			call get_word_hl 
9985				;ld hl,(scratch+2) 
9985				;call fourehexhl 
9985			 
9985 22 de e5			ld (os_cur_ptr),hl	 
9988			 
9988 e9				jp (hl) 
9989			 
9989			 
9989			 
9989			; TODO implement a basic monitor mode to start with 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			 
9989			; testing and demo code during development 
9989			 
9989			 
9989 .. 00		str1: db "Enter some text...",0 
999c .. 00		clear: db "                    ",0 
99b1			 
99b1			demo: 
99b1			 
99b1			 
99b1			 
99b1			;	call update_display 
99b1			 
99b1				; init scratch input area for testing 
99b1 21 bb e2			ld hl, scratch	 
99b4 3e 00			ld a,0 
99b6 77				ld (hl),a 
99b7			 
99b7			 
99b7 3e 28		            LD   A, display_row_2 
99b9			;            CALL fLCD_Pos       ;Position cursor to location in A 
99b9 11 89 99		            LD   DE, str1 
99bc cd d0 8a			call str_at_display 
99bf			 
99bf			;            CALL fLCD_Str       ;Display string pointed to by DE 
99bf			cloop:	 
99bf 3e 50		            LD   A, display_row_3 
99c1			;            CALL fLCD_Pos       ;Position cursor to location in A 
99c1 11 9c 99		            LD   DE, clear 
99c4			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99c4 cd d0 8a				call str_at_display 
99c7 3e 78			ld a, display_row_4 
99c9 11 f9 99			ld de, prompt 
99cc			 
99cc cd d0 8a				call str_at_display 
99cf cd e0 8a			call update_display 
99d2			 
99d2 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99d4 16 0a			ld d, 10 
99d6 21 bb e2			ld hl, scratch	 
99d9 cd 17 8d			call input_str 
99dc			 
99dc			;	call clear_display 
99dc			;'	call update_display 
99dc			 
99dc 3e 00		            LD   A, display_row_1 
99de			;            CALL fLCD_Pos       ;Position cursor to location in A 
99de 11 9c 99		            LD   DE, clear 
99e1 cd d0 8a				call str_at_display 
99e4			;            CALL fLCD_Str       ;Display string pointed to by DE 
99e4 3e 00		            LD   A, display_row_1 
99e6			;            CALL fLCD_Pos       ;Position cursor to location in A 
99e6 11 bb e2		            LD   DE, scratch 
99e9			;            CALL fLCD_Str       ;Display string pointed to by DE 
99e9 cd d0 8a				call str_at_display 
99ec cd e0 8a			call update_display 
99ef			 
99ef 3e 00				ld a,0 
99f1 21 bb e2			ld hl, scratch 
99f4 77				ld (hl),a 
99f5			 
99f5 00				nop 
99f6 c3 bf 99			jp cloop 
99f9			 
99f9			 
99f9			 
99f9			; OS Prompt 
99f9			 
99f9 .. 00		prompt: db ">",0 
99fb .. 00		endprg: db "?",0 
99fd			 
99fd			 
99fd			; handy next page prompt 
99fd			next_page_prompt: 
99fd e5				push hl 
99fe d5				push de 
99ff f5				push af 
9a00 c5				push bc 
9a01			 
9a01 3e 9f			ld a,display_row_4 + display_cols - 1 
9a03 11 fb 99		        ld de, endprg 
9a06 cd d0 8a			call str_at_display 
9a09 cd e0 8a			call update_display 
9a0c cd aa e2			call cin_wait 
9a0f c1				pop bc 
9a10 f1				pop af 
9a11 d1				pop de 
9a12 e1				pop hl 
9a13			 
9a13			 
9a13 c9				ret 
9a14			 
9a14			 
9a14			; forth parser 
9a14			 
9a14			; My forth kernel 
9a14			include "forth_kernel.asm" 
9a14			; 
9a14			; kernel to the forth OS 
9a14			 
9a14			DS_TYPE_STR: equ 1     ; string type 
9a14			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9a14			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9a14			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9a14			 
9a14			FORTH_PARSEV1: equ 0 
9a14			FORTH_PARSEV2: equ 0 
9a14			FORTH_PARSEV3: equ 0 
9a14			FORTH_PARSEV4: equ 0 
9a14			FORTH_PARSEV5: equ 0 
9a14			FORTH_PARSEV6: equ 1 
9a14			 
9a14			;if FORTH_PARSEV5 
9a14			;	FORTH_END_BUFFER: equ 0 
9a14			;else 
9a14			FORTH_END_BUFFER: equ 127 
9a14			;endif 
9a14			 
9a14			FORTH_TRUE: equ 1 
9a14			FORTH_FALSE: equ 0 
9a14			 
9a14			if FORTH_PARSEV4 
9a14			include "forth_stackops.asm" 
9a14			endif 
9a14			 
9a14			if FORTH_PARSEV5 
9a14			include "forth_stackopsv5.asm" 
9a14			endif 
9a14			 
9a14			if FORTH_PARSEV6 
9a14			include "forth_stackopsv5.asm" 
9a14			 
9a14			; Stack operations for v5 parser on wards 
9a14			; * DATA stack 
9a14			; * LOOP stack 
9a14			; * RETURN stack 
9a14			 
9a14			 
9a14			 
9a14			FORTH_CHK_DSP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_data_sp) 
9a14				ld de, cli_data_stack 
9a14				call cmp16 
9a14				jp c, fault_dsp_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			 
9a14			FORTH_CHK_RSP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_ret_sp) 
9a14				ld de, cli_ret_stack 
9a14				call cmp16 
9a14				jp c, fault_rsp_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			FORTH_CHK_LOOP_UNDER: macro 
9a14				push hl 
9a14				push de 
9a14				ld hl,(cli_loop_sp) 
9a14				ld de, cli_loop_stack 
9a14				call cmp16 
9a14				jp c, fault_loop_under 
9a14				pop de 
9a14				pop hl 
9a14				endm 
9a14			 
9a14			FORTH_ERR_TOS_NOTSTR: macro 
9a14				; TOSO might need more for checks when used 
9a14				push af 
9a14				ld a,(hl) 
9a14				cp DS_TYPE_STR 
9a14				jp nz, type_faultn   
9a14				pop af 
9a14				endm 
9a14			 
9a14			FORTH_ERR_TOS_NOTNUM: macro 
9a14				push af 
9a14				ld a,(hl) 
9a14				cp DS_TYPE_INUM 
9a14				jp nz, type_faultn   
9a14				pop af 
9a14				endm 
9a14			 
9a14			 
9a14			; increase data stack pointer and save hl to it 
9a14				 
9a14			FORTH_DSP_NEXT: macro 
9a14				call macro_forth_dsp_next 
9a14				endm 
9a14			 
9a14			 
9a14			macro_forth_dsp_next: 
9a14				if DEBUG_FORTH_STACK_GUARD 
9a14 cd 1c df				call check_stacks 
9a17				endif 
9a17 e5				push hl 
9a18 d5				push de 
9a19 eb				ex de,hl 
9a1a 2a e8 e9			ld hl,(cli_data_sp) 
9a1d 23				inc hl 
9a1e 23				inc hl 
9a1f			 
9a1f			; PARSEV5 
9a1f 23				inc hl 
9a20 22 e8 e9			ld (cli_data_sp),hl 
9a23 73				ld (hl), e 
9a24 23				inc hl 
9a25 72				ld (hl), d 
9a26 d1				pop de 
9a27 e1				pop hl 
9a28				if DEBUG_FORTH_STACK_GUARD 
9a28 cd 1c df				call check_stacks 
9a2b				endif 
9a2b c9				ret 
9a2c			 
9a2c			 
9a2c			; increase ret stack pointer and save hl to it 
9a2c				 
9a2c			FORTH_RSP_NEXT: macro 
9a2c				call macro_forth_rsp_next 
9a2c				endm 
9a2c			 
9a2c			macro_forth_rsp_next: 
9a2c				if DEBUG_FORTH_STACK_GUARD 
9a2c cd 1c df				call check_stacks 
9a2f				endif 
9a2f e5				push hl 
9a30 d5				push de 
9a31 eb				ex de,hl 
9a32 2a ec e9			ld hl,(cli_ret_sp) 
9a35 23				inc hl 
9a36 23				inc hl 
9a37 22 ec e9			ld (cli_ret_sp),hl 
9a3a 73				ld (hl), e 
9a3b 23				inc hl 
9a3c 72				ld (hl), d 
9a3d d1				pop de 
9a3e e1				pop hl 
9a3f				if DEBUG_FORTH_STACK_GUARD 
9a3f cd 1c df				call check_stacks 
9a42				endif 
9a42 c9				ret 
9a43			 
9a43			; get current ret stack pointer and save to hl  
9a43				 
9a43			FORTH_RSP_TOS: macro 
9a43				call macro_forth_rsp_tos 
9a43				endm 
9a43			 
9a43			macro_forth_rsp_tos: 
9a43				;push de 
9a43 2a ec e9			ld hl,(cli_ret_sp) 
9a46 cd 7e 9a			call loadhlptrtohl 
9a49				;ld e, (hl) 
9a49				;inc hl 
9a49				;ld d, (hl) 
9a49				;ex de, hl 
9a49					if DEBUG_FORTH_WORDS 
9a49			;			DMARK "RST" 
9a49						CALLMONITOR 
9a49 cd 6f ee			call debug_vector  
9a4c				endm  
# End of macro CALLMONITOR
9a4c					endif 
9a4c				;pop de 
9a4c c9				ret 
9a4d			 
9a4d			; pop ret stack pointer 
9a4d				 
9a4d			FORTH_RSP_POP: macro 
9a4d				call macro_forth_rsp_pop 
9a4d				endm 
9a4d			 
9a4d			 
9a4d			macro_forth_rsp_pop: 
9a4d				if DEBUG_FORTH_STACK_GUARD 
9a4d			;		DMARK "RPP" 
9a4d cd 1c df				call check_stacks 
9a50					FORTH_CHK_RSP_UNDER 
9a50 e5				push hl 
9a51 d5				push de 
9a52 2a ec e9			ld hl,(cli_ret_sp) 
9a55 11 a6 e9			ld de, cli_ret_stack 
9a58 cd 08 8d			call cmp16 
9a5b da 33 e0			jp c, fault_rsp_under 
9a5e d1				pop de 
9a5f e1				pop hl 
9a60				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a60				endif 
9a60 e5				push hl 
9a61 2a ec e9			ld hl,(cli_ret_sp) 
9a64			 
9a64			 
9a64				if FORTH_ENABLE_FREE 
9a64			 
9a64					; get pointer 
9a64			 
9a64					push de 
9a64					push hl 
9a64			 
9a64					ld e, (hl) 
9a64					inc hl 
9a64					ld d, (hl) 
9a64			 
9a64					ex de, hl 
9a64					call free 
9a64			 
9a64					pop hl 
9a64					pop de 
9a64			 
9a64			 
9a64				endif 
9a64			 
9a64			 
9a64 2b				dec hl 
9a65 2b				dec hl 
9a66 22 ec e9			ld (cli_ret_sp), hl 
9a69				; do stack underflow checks 
9a69 e1				pop hl 
9a6a				if DEBUG_FORTH_STACK_GUARD 
9a6a cd 1c df				call check_stacks 
9a6d					FORTH_CHK_RSP_UNDER 
9a6d e5				push hl 
9a6e d5				push de 
9a6f 2a ec e9			ld hl,(cli_ret_sp) 
9a72 11 a6 e9			ld de, cli_ret_stack 
9a75 cd 08 8d			call cmp16 
9a78 da 33 e0			jp c, fault_rsp_under 
9a7b d1				pop de 
9a7c e1				pop hl 
9a7d				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a7d				endif 
9a7d c9				ret 
9a7e			 
9a7e			 
9a7e			 
9a7e			; routine to load word pointed to by hl into hl 
9a7e			 
9a7e			loadhlptrtohl: 
9a7e			 
9a7e d5				push de 
9a7f 5e				ld e, (hl) 
9a80 23				inc hl 
9a81 56				ld d, (hl) 
9a82 eb				ex de, hl 
9a83 d1				pop de 
9a84			 
9a84 c9				ret 
9a85			 
9a85			 
9a85			 
9a85			 
9a85			 
9a85			; push a number held in HL onto the data stack 
9a85			; entry point for pushing a value when already in hl used in function above 
9a85			 
9a85			forth_push_numhl: 
9a85			 
9a85 e5				push hl    ; save value to push 
9a86			 
9a86			if DEBUG_FORTH_PUSH 
9a86				; see if disabled 
9a86			 
9a86			 
9a86 f5				push af 
9a87 3a 6f ee			ld a,(debug_vector) 
9a8a fe c9			cp $c9   ; ret 
9a8c			;	ld a, (os_view_disable) 
9a8c			;	cp '*' 
9a8c 28 34			jr z, .pskip2 
9a8e e5				push hl 
9a8f e5			push hl 
9a90 cd bd 8a			call clear_display 
9a93 e1			pop hl 
9a94 7c				ld a,h 
9a95 21 c0 e5			ld hl, os_word_scratch 
9a98 cd f3 8e			call hexout 
9a9b e1				pop hl 
9a9c 7d				ld a,l 
9a9d 21 c2 e5			ld hl, os_word_scratch+2 
9aa0 cd f3 8e			call hexout 
9aa3			 
9aa3 21 c4 e5			ld hl, os_word_scratch+4 
9aa6 3e 00			ld a,0 
9aa8 77				ld (hl),a 
9aa9 11 c0 e5			ld de,os_word_scratch 
9aac 3e 28				ld a, display_row_2 
9aae cd d0 8a				call str_at_display 
9ab1 11 15 d1			ld de, .push_num 
9ab4 3e 00			ld a, display_row_1 
9ab6			 
9ab6 cd d0 8a				call str_at_display 
9ab9			 
9ab9			 
9ab9 cd e0 8a			call update_display 
9abc cd 00 8a			call delay1s 
9abf cd 00 8a			call delay1s 
9ac2			.pskip2:  
9ac2			 
9ac2 f1				pop af 
9ac3			endif	 
9ac3			 
9ac3			 
9ac3				FORTH_DSP_NEXT 
9ac3 cd 14 9a			call macro_forth_dsp_next 
9ac6				endm 
# End of macro FORTH_DSP_NEXT
9ac6			 
9ac6 2a e8 e9			ld hl, (cli_data_sp) 
9ac9			 
9ac9				; save item type 
9ac9 3e 02			ld a,  DS_TYPE_INUM 
9acb 77				ld (hl), a 
9acc 23				inc hl 
9acd			 
9acd				; get word off stack 
9acd d1				pop de 
9ace 7b				ld a,e 
9acf 77				ld (hl), a 
9ad0 23				inc hl 
9ad1 7a				ld a,d 
9ad2 77				ld (hl), a 
9ad3			 
9ad3			if DEBUG_FORTH_PUSH 
9ad3 2b				dec hl 
9ad4 2b				dec hl 
9ad5 2b				dec hl 
9ad6						DMARK "PH5" 
9ad6 f5				push af  
9ad7 3a eb 9a			ld a, (.dmark)  
9ada 32 65 ee			ld (debug_mark),a  
9add 3a ec 9a			ld a, (.dmark+1)  
9ae0 32 66 ee			ld (debug_mark+1),a  
9ae3 3a ed 9a			ld a, (.dmark+2)  
9ae6 32 67 ee			ld (debug_mark+2),a  
9ae9 18 03			jr .pastdmark  
9aeb ..			.dmark: db "PH5"  
9aee f1			.pastdmark: pop af  
9aef			endm  
# End of macro DMARK
9aef				CALLMONITOR 
9aef cd 6f ee			call debug_vector  
9af2				endm  
# End of macro CALLMONITOR
9af2			endif	 
9af2			 
9af2 c9				ret 
9af3			 
9af3			 
9af3			; Push a string to stack pointed to by hl 
9af3			 
9af3			forth_push_str: 
9af3			 
9af3			if DEBUG_FORTH_PUSH 
9af3						DMARK "PSQ" 
9af3 f5				push af  
9af4 3a 08 9b			ld a, (.dmark)  
9af7 32 65 ee			ld (debug_mark),a  
9afa 3a 09 9b			ld a, (.dmark+1)  
9afd 32 66 ee			ld (debug_mark+1),a  
9b00 3a 0a 9b			ld a, (.dmark+2)  
9b03 32 67 ee			ld (debug_mark+2),a  
9b06 18 03			jr .pastdmark  
9b08 ..			.dmark: db "PSQ"  
9b0b f1			.pastdmark: pop af  
9b0c			endm  
# End of macro DMARK
9b0c				CALLMONITOR 
9b0c cd 6f ee			call debug_vector  
9b0f				endm  
# End of macro CALLMONITOR
9b0f			endif	 
9b0f			 
9b0f			 
9b0f			    
9b0f e5				push hl 
9b10 e5				push hl 
9b11			 
9b11			;	ld a, 0   ; find end of string 
9b11 cd 50 90			call strlenz 
9b14			if DEBUG_FORTH_PUSH 
9b14						DMARK "PQ2" 
9b14 f5				push af  
9b15 3a 29 9b			ld a, (.dmark)  
9b18 32 65 ee			ld (debug_mark),a  
9b1b 3a 2a 9b			ld a, (.dmark+1)  
9b1e 32 66 ee			ld (debug_mark+1),a  
9b21 3a 2b 9b			ld a, (.dmark+2)  
9b24 32 67 ee			ld (debug_mark+2),a  
9b27 18 03			jr .pastdmark  
9b29 ..			.dmark: db "PQ2"  
9b2c f1			.pastdmark: pop af  
9b2d			endm  
# End of macro DMARK
9b2d				CALLMONITOR 
9b2d cd 6f ee			call debug_vector  
9b30				endm  
# End of macro CALLMONITOR
9b30			endif	 
9b30 eb				ex de, hl 
9b31 e1				pop hl   ; get ptr to start of string 
9b32			if DEBUG_FORTH_PUSH 
9b32						DMARK "PQ3" 
9b32 f5				push af  
9b33 3a 47 9b			ld a, (.dmark)  
9b36 32 65 ee			ld (debug_mark),a  
9b39 3a 48 9b			ld a, (.dmark+1)  
9b3c 32 66 ee			ld (debug_mark+1),a  
9b3f 3a 49 9b			ld a, (.dmark+2)  
9b42 32 67 ee			ld (debug_mark+2),a  
9b45 18 03			jr .pastdmark  
9b47 ..			.dmark: db "PQ3"  
9b4a f1			.pastdmark: pop af  
9b4b			endm  
# End of macro DMARK
9b4b				CALLMONITOR 
9b4b cd 6f ee			call debug_vector  
9b4e				endm  
# End of macro CALLMONITOR
9b4e			endif	 
9b4e 19				add hl,de 
9b4f			if DEBUG_FORTH_PUSH 
9b4f						DMARK "PQE" 
9b4f f5				push af  
9b50 3a 64 9b			ld a, (.dmark)  
9b53 32 65 ee			ld (debug_mark),a  
9b56 3a 65 9b			ld a, (.dmark+1)  
9b59 32 66 ee			ld (debug_mark+1),a  
9b5c 3a 66 9b			ld a, (.dmark+2)  
9b5f 32 67 ee			ld (debug_mark+2),a  
9b62 18 03			jr .pastdmark  
9b64 ..			.dmark: db "PQE"  
9b67 f1			.pastdmark: pop af  
9b68			endm  
# End of macro DMARK
9b68				CALLMONITOR 
9b68 cd 6f ee			call debug_vector  
9b6b				endm  
# End of macro CALLMONITOR
9b6b			endif	 
9b6b			 
9b6b 2b				dec hl    ; see if there is an optional trailing double quote 
9b6c 7e				ld a,(hl) 
9b6d fe 22			cp '"' 
9b6f 20 03			jr nz, .strnoq 
9b71 3e 00			ld a, 0      ; get rid of double quote 
9b73 77				ld (hl), a 
9b74 23			.strnoq: inc hl 
9b75			 
9b75 3e 00			ld a, 0 
9b77 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b78			 
9b78 13				inc de ; add one for the type string 
9b79 13				inc de ; add one for null term??? 
9b7a			 
9b7a				; tos is get string pointer again 
9b7a				; de contains space to allocate 
9b7a				 
9b7a d5				push de 
9b7b			 
9b7b eb				ex de, hl 
9b7c			 
9b7c				;push af 
9b7c			 
9b7c			if DEBUG_FORTH_PUSH 
9b7c						DMARK "PHm" 
9b7c f5				push af  
9b7d 3a 91 9b			ld a, (.dmark)  
9b80 32 65 ee			ld (debug_mark),a  
9b83 3a 92 9b			ld a, (.dmark+1)  
9b86 32 66 ee			ld (debug_mark+1),a  
9b89 3a 93 9b			ld a, (.dmark+2)  
9b8c 32 67 ee			ld (debug_mark+2),a  
9b8f 18 03			jr .pastdmark  
9b91 ..			.dmark: db "PHm"  
9b94 f1			.pastdmark: pop af  
9b95			endm  
# End of macro DMARK
9b95				CALLMONITOR 
9b95 cd 6f ee			call debug_vector  
9b98				endm  
# End of macro CALLMONITOR
9b98			endif	 
9b98 cd c5 90			call malloc	; on ret hl now contains allocated memory 
9b9b				if DEBUG_FORTH_MALLOC_GUARD 
9b9b cc 6d d1				call z,malloc_error 
9b9e				endif 
9b9e			 
9b9e				 
9b9e c1				pop bc    ; get length 
9b9f d1				pop de   ;  get string start    
9ba0			 
9ba0				; hl has destination from malloc 
9ba0			 
9ba0 eb				ex de, hl    ; prep for ldir 
9ba1			 
9ba1 d5				push de   ; save malloc area for DSP later 
9ba2				;push hl   ; save malloc area for DSP later 
9ba2			 
9ba2			if DEBUG_FORTH_PUSH 
9ba2						DMARK "PHc" 
9ba2 f5				push af  
9ba3 3a b7 9b			ld a, (.dmark)  
9ba6 32 65 ee			ld (debug_mark),a  
9ba9 3a b8 9b			ld a, (.dmark+1)  
9bac 32 66 ee			ld (debug_mark+1),a  
9baf 3a b9 9b			ld a, (.dmark+2)  
9bb2 32 67 ee			ld (debug_mark+2),a  
9bb5 18 03			jr .pastdmark  
9bb7 ..			.dmark: db "PHc"  
9bba f1			.pastdmark: pop af  
9bbb			endm  
# End of macro DMARK
9bbb				CALLMONITOR 
9bbb cd 6f ee			call debug_vector  
9bbe				endm  
# End of macro CALLMONITOR
9bbe			endif	 
9bbe			 
9bbe			 
9bbe ed b0			ldir 
9bc0			 
9bc0			 
9bc0				; push malloc to data stack     macro?????  
9bc0			 
9bc0				FORTH_DSP_NEXT 
9bc0 cd 14 9a			call macro_forth_dsp_next 
9bc3				endm 
# End of macro FORTH_DSP_NEXT
9bc3			 
9bc3				; save value and type 
9bc3			 
9bc3 2a e8 e9			ld hl, (cli_data_sp) 
9bc6			 
9bc6				; save item type 
9bc6 3e 01			ld a,  DS_TYPE_STR 
9bc8 77				ld (hl), a 
9bc9 23				inc hl 
9bca			 
9bca				; get malloc word off stack 
9bca d1				pop de 
9bcb 73				ld (hl), e 
9bcc 23				inc hl 
9bcd 72				ld (hl), d 
9bce			 
9bce			 
9bce			 
9bce			if DEBUG_FORTH_PUSH 
9bce 2a e8 e9			ld hl, (cli_data_sp) 
9bd1						DMARK "PHS" 
9bd1 f5				push af  
9bd2 3a e6 9b			ld a, (.dmark)  
9bd5 32 65 ee			ld (debug_mark),a  
9bd8 3a e7 9b			ld a, (.dmark+1)  
9bdb 32 66 ee			ld (debug_mark+1),a  
9bde 3a e8 9b			ld a, (.dmark+2)  
9be1 32 67 ee			ld (debug_mark+2),a  
9be4 18 03			jr .pastdmark  
9be6 ..			.dmark: db "PHS"  
9be9 f1			.pastdmark: pop af  
9bea			endm  
# End of macro DMARK
9bea				CALLMONITOR 
9bea cd 6f ee			call debug_vector  
9bed				endm  
# End of macro CALLMONITOR
9bed			;	ex de,hl 
9bed			endif	 
9bed				; in case of spaces, skip the ptr past the copied string 
9bed				;pop af 
9bed				;ld (cli_origptr),hl 
9bed			 
9bed c9				ret 
9bee			 
9bee			 
9bee			 
9bee			; TODO ascii push input onto stack given hl to start of input 
9bee			 
9bee			; identify type 
9bee			; if starts with a " then a string 
9bee			; otherwise it is a number 
9bee			;  
9bee			; if a string 
9bee			;     scan for ending " to get length of string to malloc for + 1 
9bee			;     malloc 
9bee			;     put pointer to string on stack first byte flags as string 
9bee			; 
9bee			; else a number 
9bee			;    look for number format identifier 
9bee			;    $xx hex 
9bee			;    %xxxxx bin 
9bee			;    xxxxx decimal 
9bee			;    convert number to 16bit word.  
9bee			;    malloc word + 1 with flag to identiy as num 
9bee			;    put pointer to number on stack 
9bee			;   
9bee			;  
9bee			  
9bee			forth_apush: 
9bee				; kernel push 
9bee			 
9bee			if DEBUG_FORTH_PUSH 
9bee						DMARK "PSH" 
9bee f5				push af  
9bef 3a 03 9c			ld a, (.dmark)  
9bf2 32 65 ee			ld (debug_mark),a  
9bf5 3a 04 9c			ld a, (.dmark+1)  
9bf8 32 66 ee			ld (debug_mark+1),a  
9bfb 3a 05 9c			ld a, (.dmark+2)  
9bfe 32 67 ee			ld (debug_mark+2),a  
9c01 18 03			jr .pastdmark  
9c03 ..			.dmark: db "PSH"  
9c06 f1			.pastdmark: pop af  
9c07			endm  
# End of macro DMARK
9c07				CALLMONITOR 
9c07 cd 6f ee			call debug_vector  
9c0a				endm  
# End of macro CALLMONITOR
9c0a			endif	 
9c0a				; identify input type 
9c0a			 
9c0a 7e				ld a,(hl) 
9c0b			 
9c0b fe 23			cp '#' 
9c0d ca 47 9c			jp z, .fapdec 
9c10			 
9c10			 
9c10 fe 22			cp '"' 
9c12 28 0a			jr z, .fapstr 
9c14 fe 24			cp '$' 
9c16 ca 3e 9c			jp z, .faphex 
9c19 fe 25			cp '%' 
9c1b ca 26 9c			jp z, .fapbin 
9c1e			;	cp 'b' 
9c1e			;	jp z, .fabin 
9c1e				; else decimal 
9c1e			 
9c1e				; TODO do decimal conversion 
9c1e				; decimal is stored as a 16bit word 
9c1e			 
9c1e				; by default everything is a string if type is not detected 
9c1e			.fapstr: ; 
9c1e fe 22			cp '"' 
9c20 20 01			jr nz, .strnoqu 
9c22 23				inc hl 
9c23			.strnoqu: 
9c23 c3 f3 9a			jp forth_push_str 
9c26			 
9c26			 
9c26			 
9c26			.fapbin:    ; push a binary string.  
9c26 11 00 00			ld de, 0   ; hold a 16bit value 
9c29			 
9c29 23			.fapbinshift:	inc hl  
9c2a 7e				ld a,(hl) 
9c2b fe 00			cp 0     ; done scanning  
9c2d 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c2f			 
9c2f				; left shift de 
9c2f eb				ex de, hl	 
9c30 29				add hl, hl 
9c31			 
9c31				; is 1 
9c31 fe 31			cp '1' 
9c33 20 02			jr nz, .binzero 
9c35 cb 4d			bit 1, l 
9c37			.binzero: 
9c37 eb				ex de, hl	 ; save current de 
9c38 18 ef			jr .fapbinshift 
9c3a			 
9c3a			.fapbdone: 
9c3a eb				ex de, hl 
9c3b c3 85 9a			jp forth_push_numhl 
9c3e			 
9c3e			 
9c3e			.faphex:   ; hex is always stored as a 16bit word 
9c3e				; skip number prefix 
9c3e 23				inc hl 
9c3f				; turn ascii into number 
9c3f cd a9 8f			call get_word_hl	; ret 16bit word in hl 
9c42			 
9c42 c3 85 9a			jp forth_push_numhl 
9c45			 
9c45 00				 nop 
9c46			 
9c46			.fabin:   ; TODO bin conversion 
9c46			 
9c46			 
9c46 c9				ret 
9c47			.fapdec:	 
9c47				; string to dec conversion 
9c47 23				inc hl 
9c48 eb				ex de, hl 
9c49 cd e7 8f			call string_to_uint16 
9c4c c3 85 9a			jp forth_push_numhl 
9c4f c9				ret 
9c50				 
9c50			;atoui_16: 
9c50			 
9c50			; get either a string ptr or a 16bit word from the data stack 
9c50			 
9c50			FORTH_DSP: macro 
9c50				call macro_forth_dsp 
9c50				endm 
9c50			 
9c50			macro_forth_dsp: 
9c50				; data stack pointer points to current word on tos 
9c50			 
9c50 2a e8 e9			ld hl,(cli_data_sp) 
9c53			 
9c53				if DEBUG_FORTH_PUSH 
9c53						DMARK "DSP" 
9c53 f5				push af  
9c54 3a 68 9c			ld a, (.dmark)  
9c57 32 65 ee			ld (debug_mark),a  
9c5a 3a 69 9c			ld a, (.dmark+1)  
9c5d 32 66 ee			ld (debug_mark+1),a  
9c60 3a 6a 9c			ld a, (.dmark+2)  
9c63 32 67 ee			ld (debug_mark+2),a  
9c66 18 03			jr .pastdmark  
9c68 ..			.dmark: db "DSP"  
9c6b f1			.pastdmark: pop af  
9c6c			endm  
# End of macro DMARK
9c6c			 
9c6c cd a0 d1				call display_data_sp 
9c6f				;call break_point_state 
9c6f				;rst 030h 
9c6f				CALLMONITOR 
9c6f cd 6f ee			call debug_vector  
9c72				endm  
# End of macro CALLMONITOR
9c72				endif 
9c72			 
9c72 c9				ret 
9c73			 
9c73			; return hl to start of value on stack 
9c73			 
9c73			FORTH_DSP_VALUE: macro 
9c73				call macro_forth_dsp_value 
9c73				endm 
9c73			 
9c73			macro_forth_dsp_value: 
9c73			 
9c73				FORTH_DSP 
9c73 cd 50 9c			call macro_forth_dsp 
9c76				endm 
# End of macro FORTH_DSP
9c76			 
9c76 d5				push de 
9c77			 
9c77 23				inc hl ; skip type 
9c78			 
9c78 5e				ld e, (hl) 
9c79 23				inc hl 
9c7a 56				ld d, (hl) 
9c7b eb				ex de,hl  
9c7c			 
9c7c d1				pop de 
9c7d			 
9c7d c9				ret 
9c7e			 
9c7e			; return hl to start of value to second item on stack 
9c7e			 
9c7e			FORTH_DSP_VALUEM1: macro 
9c7e				call macro_forth_dsp_value_m1 
9c7e				endm 
9c7e			 
9c7e			macro_forth_dsp_value_m1: 
9c7e			 
9c7e				FORTH_DSP 
9c7e cd 50 9c			call macro_forth_dsp 
9c81				endm 
# End of macro FORTH_DSP
9c81			 
9c81 2b				dec hl 
9c82 2b				dec hl 
9c83			;	dec hl 
9c83			 
9c83 d5				push de 
9c84			 
9c84 5e				ld e, (hl) 
9c85 23				inc hl 
9c86 56				ld d, (hl) 
9c87 eb				ex de,hl  
9c88			 
9c88 d1				pop de 
9c89			 
9c89 c9				ret 
9c8a			 
9c8a				 
9c8a			 
9c8a			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c8a			 
9c8a			FORTH_DSP_POP: macro 
9c8a				call macro_forth_dsp_pop 
9c8a				endm 
9c8a			 
9c8a			 
9c8a			; get the tos data type 
9c8a			 
9c8a			FORTH_DSP_TYPE:   macro 
9c8a			 
9c8a				;FORTH_DSP_VALUE 
9c8a				FORTH_DSP 
9c8a				 
9c8a				; hl points to value 
9c8a				; check type 
9c8a			 
9c8a				ld a,(hl) 
9c8a			 
9c8a				endm 
9c8a			 
9c8a			; load the tos value into hl 
9c8a			 
9c8a			 
9c8a			FORTH_DSP_VALUEHL:  macro 
9c8a				call macro_dsp_valuehl 
9c8a				endm 
9c8a			 
9c8a			 
9c8a			 
9c8a			macro_dsp_valuehl: 
9c8a				FORTH_DSP_VALUE 
9c8a cd 73 9c			call macro_forth_dsp_value 
9c8d				endm 
# End of macro FORTH_DSP_VALUE
9c8d			 
9c8d				;FORTH_ERR_TOS_NOTNUM 
9c8d			 
9c8d				;inc hl   ; skip type id 
9c8d			 
9c8d			;	push de 
9c8d			; 
9c8d			;	ld e, (hl) 
9c8d			;	inc hl 
9c8d			;	ld d, (hl) 
9c8d			;	ex de,hl  
9c8d			 
9c8d			;	pop de 
9c8d			 
9c8d				if DEBUG_FORTH_PUSH 
9c8d						DMARK "DVL" 
9c8d f5				push af  
9c8e 3a a2 9c			ld a, (.dmark)  
9c91 32 65 ee			ld (debug_mark),a  
9c94 3a a3 9c			ld a, (.dmark+1)  
9c97 32 66 ee			ld (debug_mark+1),a  
9c9a 3a a4 9c			ld a, (.dmark+2)  
9c9d 32 67 ee			ld (debug_mark+2),a  
9ca0 18 03			jr .pastdmark  
9ca2 ..			.dmark: db "DVL"  
9ca5 f1			.pastdmark: pop af  
9ca6			endm  
# End of macro DMARK
9ca6				CALLMONITOR 
9ca6 cd 6f ee			call debug_vector  
9ca9				endm  
# End of macro CALLMONITOR
9ca9				endif 
9ca9 c9				ret 
9caa			 
9caa			forth_apushstrhl:      
9caa				; push of string requires use of cli_origptr 
9caa				; bodge use 
9caa			 
9caa				; get current cli_origptr, save, update with temp pointer  
9caa ed 5b 38 ea		ld de, (cli_origptr) 
9cae 22 38 ea			ld (cli_origptr), hl 
9cb1 d5				push de 
9cb2 cd ee 9b			call forth_apush 
9cb5 d1				pop de 
9cb6 ed 53 38 ea		ld (cli_origptr), de 
9cba c9			        ret	 
9cbb			 
9cbb			 
9cbb			; increase loop stack pointer and save hl to it 
9cbb				 
9cbb			FORTH_LOOP_NEXT: macro 
9cbb				call macro_forth_loop_next 
9cbb				;nop 
9cbb				endm 
9cbb			 
9cbb			macro_forth_loop_next: 
9cbb				if DEBUG_FORTH_STACK_GUARD 
9cbb cd 1c df				call check_stacks 
9cbe				endif 
9cbe e5				push hl 
9cbf d5				push de 
9cc0 eb				ex de,hl 
9cc1 2a ea e9			ld hl,(cli_loop_sp) 
9cc4 23				inc hl 
9cc5 23				inc hl 
9cc6					if DEBUG_FORTH_WORDS 
9cc6						DMARK "LNX" 
9cc6 f5				push af  
9cc7 3a db 9c			ld a, (.dmark)  
9cca 32 65 ee			ld (debug_mark),a  
9ccd 3a dc 9c			ld a, (.dmark+1)  
9cd0 32 66 ee			ld (debug_mark+1),a  
9cd3 3a dd 9c			ld a, (.dmark+2)  
9cd6 32 67 ee			ld (debug_mark+2),a  
9cd9 18 03			jr .pastdmark  
9cdb ..			.dmark: db "LNX"  
9cde f1			.pastdmark: pop af  
9cdf			endm  
# End of macro DMARK
9cdf						CALLMONITOR 
9cdf cd 6f ee			call debug_vector  
9ce2				endm  
# End of macro CALLMONITOR
9ce2					endif 
9ce2 22 ea e9			ld (cli_loop_sp),hl 
9ce5 73				ld (hl), e 
9ce6 23				inc hl 
9ce7 72				ld (hl), d 
9ce8 d1				pop de    ; been reversed so save a swap on restore 
9ce9 e1				pop hl 
9cea				if DEBUG_FORTH_STACK_GUARD 
9cea cd 1c df				call check_stacks 
9ced				endif 
9ced c9				ret 
9cee			 
9cee			; get current ret stack pointer and save to hl  
9cee				 
9cee			FORTH_LOOP_TOS: macro 
9cee				call macro_forth_loop_tos 
9cee				endm 
9cee			 
9cee			macro_forth_loop_tos: 
9cee d5				push de 
9cef 2a ea e9			ld hl,(cli_loop_sp) 
9cf2 5e				ld e, (hl) 
9cf3 23				inc hl 
9cf4 56				ld d, (hl) 
9cf5 eb				ex de, hl 
9cf6 d1				pop de 
9cf7 c9				ret 
9cf8			 
9cf8			; pop loop stack pointer 
9cf8				 
9cf8			FORTH_LOOP_POP: macro 
9cf8				call macro_forth_loop_pop 
9cf8				endm 
9cf8			 
9cf8			 
9cf8			macro_forth_loop_pop: 
9cf8				if DEBUG_FORTH_STACK_GUARD 
9cf8					DMARK "LPP" 
9cf8 f5				push af  
9cf9 3a 0d 9d			ld a, (.dmark)  
9cfc 32 65 ee			ld (debug_mark),a  
9cff 3a 0e 9d			ld a, (.dmark+1)  
9d02 32 66 ee			ld (debug_mark+1),a  
9d05 3a 0f 9d			ld a, (.dmark+2)  
9d08 32 67 ee			ld (debug_mark+2),a  
9d0b 18 03			jr .pastdmark  
9d0d ..			.dmark: db "LPP"  
9d10 f1			.pastdmark: pop af  
9d11			endm  
# End of macro DMARK
9d11 cd 1c df				call check_stacks 
9d14					FORTH_CHK_LOOP_UNDER 
9d14 e5				push hl 
9d15 d5				push de 
9d16 2a ea e9			ld hl,(cli_loop_sp) 
9d19 11 24 e9			ld de, cli_loop_stack 
9d1c cd 08 8d			call cmp16 
9d1f da 39 e0			jp c, fault_loop_under 
9d22 d1				pop de 
9d23 e1				pop hl 
9d24				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d24				endif 
9d24 e5				push hl 
9d25 2a ea e9			ld hl,(cli_loop_sp) 
9d28 2b				dec hl 
9d29 2b				dec hl 
9d2a 22 ea e9			ld (cli_loop_sp), hl 
9d2d				; TODO do stack underflow checks 
9d2d e1				pop hl 
9d2e				if DEBUG_FORTH_STACK_GUARD 
9d2e cd 1c df				call check_stacks 
9d31					FORTH_CHK_LOOP_UNDER 
9d31 e5				push hl 
9d32 d5				push de 
9d33 2a ea e9			ld hl,(cli_loop_sp) 
9d36 11 24 e9			ld de, cli_loop_stack 
9d39 cd 08 8d			call cmp16 
9d3c da 39 e0			jp c, fault_loop_under 
9d3f d1				pop de 
9d40 e1				pop hl 
9d41				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d41				endif 
9d41 c9				ret 
9d42			 
9d42			macro_forth_dsp_pop: 
9d42			 
9d42 e5				push hl 
9d43			 
9d43				; release malloc data 
9d43			 
9d43				if DEBUG_FORTH_STACK_GUARD 
9d43 cd 1c df				call check_stacks 
9d46					FORTH_CHK_DSP_UNDER 
9d46 e5				push hl 
9d47 d5				push de 
9d48 2a e8 e9			ld hl,(cli_data_sp) 
9d4b 11 22 e8			ld de, cli_data_stack 
9d4e cd 08 8d			call cmp16 
9d51 da 2d e0			jp c, fault_dsp_under 
9d54 d1				pop de 
9d55 e1				pop hl 
9d56				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d56				endif 
9d56				;ld hl,(cli_data_sp) 
9d56			if DEBUG_FORTH_DOT 
9d56				DMARK "DPP" 
9d56 f5				push af  
9d57 3a 6b 9d			ld a, (.dmark)  
9d5a 32 65 ee			ld (debug_mark),a  
9d5d 3a 6c 9d			ld a, (.dmark+1)  
9d60 32 66 ee			ld (debug_mark+1),a  
9d63 3a 6d 9d			ld a, (.dmark+2)  
9d66 32 67 ee			ld (debug_mark+2),a  
9d69 18 03			jr .pastdmark  
9d6b ..			.dmark: db "DPP"  
9d6e f1			.pastdmark: pop af  
9d6f			endm  
# End of macro DMARK
9d6f				CALLMONITOR 
9d6f cd 6f ee			call debug_vector  
9d72				endm  
# End of macro CALLMONITOR
9d72			endif	 
9d72			 
9d72			 
9d72			if FORTH_ENABLE_DSPPOPFREE 
9d72			 
9d72				FORTH_DSP 
9d72 cd 50 9c			call macro_forth_dsp 
9d75				endm 
# End of macro FORTH_DSP
9d75			 
9d75 7e				ld a, (hl) 
9d76 fe 01			cp DS_TYPE_STR 
9d78 20 22			jr nz, .skippopfree 
9d7a			 
9d7a				FORTH_DSP_VALUEHL 
9d7a cd 8a 9c			call macro_dsp_valuehl 
9d7d				endm 
# End of macro FORTH_DSP_VALUEHL
9d7d			;	nop 
9d7d			if DEBUG_FORTH_DOT 
9d7d				DMARK "DPf" 
9d7d f5				push af  
9d7e 3a 92 9d			ld a, (.dmark)  
9d81 32 65 ee			ld (debug_mark),a  
9d84 3a 93 9d			ld a, (.dmark+1)  
9d87 32 66 ee			ld (debug_mark+1),a  
9d8a 3a 94 9d			ld a, (.dmark+2)  
9d8d 32 67 ee			ld (debug_mark+2),a  
9d90 18 03			jr .pastdmark  
9d92 ..			.dmark: db "DPf"  
9d95 f1			.pastdmark: pop af  
9d96			endm  
# End of macro DMARK
9d96				CALLMONITOR 
9d96 cd 6f ee			call debug_vector  
9d99				endm  
# End of macro CALLMONITOR
9d99			endif	 
9d99 cd 8f 91			call free 
9d9c			.skippopfree: 
9d9c				 
9d9c			 
9d9c			endif 
9d9c			 
9d9c			if DEBUG_FORTH_DOT_KEY 
9d9c				DMARK "DP2" 
9d9c				CALLMONITOR 
9d9c			endif	 
9d9c			 
9d9c				; move pointer down 
9d9c			 
9d9c 2a e8 e9			ld hl,(cli_data_sp) 
9d9f 2b				dec hl 
9da0 2b				dec hl 
9da1			; PARSEV5 
9da1 2b				dec hl 
9da2 22 e8 e9			ld (cli_data_sp), hl 
9da5			 
9da5				if DEBUG_FORTH_STACK_GUARD 
9da5 cd 1c df				call check_stacks 
9da8					FORTH_CHK_DSP_UNDER 
9da8 e5				push hl 
9da9 d5				push de 
9daa 2a e8 e9			ld hl,(cli_data_sp) 
9dad 11 22 e8			ld de, cli_data_stack 
9db0 cd 08 8d			call cmp16 
9db3 da 2d e0			jp c, fault_dsp_under 
9db6 d1				pop de 
9db7 e1				pop hl 
9db8				endm 
# End of macro FORTH_CHK_DSP_UNDER
9db8				endif 
9db8			 
9db8 e1				pop hl 
9db9			 
9db9 c9				ret 
9dba			 
9dba			getwordathl: 
9dba				; hl points to an address 
9dba				; load hl with the word at that address 
9dba			 
9dba d5				push de 
9dbb			 
9dbb 5e				ld e, (hl) 
9dbc 23				inc hl 
9dbd 56				ld d, (hl) 
9dbe eb				ex de, hl 
9dbf			 
9dbf d1				pop de 
9dc0 c9				ret 
9dc1			 
9dc1			 
9dc1			; functions to manuplite stack pointers 
9dc1			 
9dc1			; generate fragment to set hl to be pointer to a stack item 
9dc1			 
9dc1			FORTH_DSP_PTR: macro  x 
9dc1				ld hl,(cli_data_sp) 
9dc1				ld de, x * 3 
9dc1				sbc hl, de 
9dc1				endm 
9dc1			 
9dc1			 
9dc1			 
9dc1			; copy point in hl to stack tmp storage slots 1-4 
9dc1			hltostack1: 
9dc1 11 b8 e2			ld de, os_stack_1  
9dc4 c3 ef 9d			jp hltostackmv 
9dc7			 
9dc7			hltostack2:  
9dc7 11 b5 e2			ld de, os_stack_2 
9dca c3 ef 9d			jp hltostackmv 
9dcd			 
9dcd			hltostack3:  
9dcd 11 b2 e2			ld de, os_stack_3 
9dd0 c3 ef 9d			jp hltostackmv 
9dd3			 
9dd3			hltostack4:  
9dd3 11 af e2			ld de, os_stack_4  
9dd6 c3 ef 9d			jp hltostackmv 
9dd9			 
9dd9			; copy to point in hl from stack tmp storage slots 1-4 
9dd9			hlfromstack1: 
9dd9 11 b8 e2			ld de, os_stack_1 
9ddc c3 ee 9d			jp hlfromsttackmv 
9ddf			 
9ddf			hlfromstack2:  
9ddf 11 b5 e2			ld de, os_stack_2 
9de2 c3 ee 9d			jp hlfromsttackmv 
9de5			 
9de5			hlfromstack3:  
9de5 11 b2 e2			ld de, os_stack_3 
9de8 c3 ee 9d			jp hlfromsttackmv 
9deb			 
9deb			hlfromstack4:  
9deb 11 af e2			ld de, os_stack_4 
9dee			 
9dee			hlfromsttackmv: 
9dee eb				ex de, hl 
9def			 
9def			hltostackmv: 
9def			 
9def				; do stack move 
9def c5				push bc 
9df0 01 03 00			ld bc, 3 
9df3 ed b0			ldir  
9df5 c1				pop bc	 
9df6 c9				ret 
9df7			 
9df7			; eof 
9df7			 
# End of file forth_stackopsv5.asm
9df7			endif 
9df7			loadwordinhl:	 
9df7			 
9df7 d5				push de 
9df8			 
9df8 5e				ld e, (hl) 
9df9 23				inc hl 
9dfa 56				ld d, (hl) 
9dfb eb				ex de,hl  
9dfc			 
9dfc d1				pop de 
9dfd			 
9dfd c9				ret 
9dfe			 
9dfe			user_word_eol:  
9dfe				; hl contains the pointer to where to create a linked list item from the end 
9dfe				; of the user dict to continue on at the system word dict 
9dfe				 
9dfe				; poke the stub of the word list linked list to repoint to rom words 
9dfe			 
9dfe				; stub format 
9dfe				; db   word id 
9dfe				; dw    link to next word 
9dfe			        ; db char length of token 
9dfe				; db string + 0 term 
9dfe				; db exec code....  
9dfe			 
9dfe 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e00 77				ld (hl), a		; word id 
9e01 23				inc hl 
9e02			 
9e02 11 b9 9f			ld de, sysdict 
9e05 73				ld (hl), e		; next word link ie system dict 
9e06 23				inc hl 
9e07 72				ld (hl), d		; next word link ie system dict 
9e08 23				inc hl	 
9e09			 
9e09			;	ld (hl), sysdict		; next word link ie system dict 
9e09			;	inc hl 
9e09			;	inc hl 
9e09			 
9e09			;	inc hl 
9e09			;	inc hl 
9e09			 
9e09 3e 02			ld a, 2			; word length is 0 
9e0b 77				ld (hl), a	 
9e0c 23				inc hl 
9e0d			 
9e0d 3e 7e			ld a, '~'			; word length is 0 
9e0f 77				ld (hl), a	 
9e10 23				inc hl 
9e11 3e 00			ld a, 0			; save empty word 
9e13 77				ld (hl), a 
9e14			 
9e14 c9				ret 
9e15			 
9e15				 
9e15			 
9e15			forthexec_cleanup: 
9e15				FORTH_RSP_POP 
9e15 cd 4d 9a			call macro_forth_rsp_pop 
9e18				endm 
# End of macro FORTH_RSP_POP
9e18 c9				ret 
9e19			 
9e19			forth_call_hl: 
9e19				; taking hl 
9e19 e5				push hl 
9e1a c9				ret 
9e1b			 
9e1b			; this is called to reset Forth system but keep existing uwords etc 
9e1b			 
9e1b			forth_warmstart: 
9e1b				; setup stack over/under flow checks 
9e1b				if DEBUG_FORTH_STACK_GUARD 
9e1b cd 02 df				call chk_stk_init 
9e1e				endif 
9e1e			 
9e1e				; init stack pointers  - * these stacks go upwards *  
9e1e 21 a6 e9			ld hl, cli_ret_stack 
9e21 22 ec e9			ld (cli_ret_sp), hl	 
9e24				; set bottom of stack 
9e24 3e 00			ld a,0 
9e26 77				ld (hl),a 
9e27 23				inc hl 
9e28 77				ld (hl),a 
9e29			 
9e29 21 22 e8			ld hl, cli_data_stack 
9e2c 22 e8 e9			ld (cli_data_sp), hl	 
9e2f				; set bottom of stack 
9e2f 3e 00			ld a,0 
9e31 77				ld (hl),a 
9e32 23				inc hl 
9e33 77				ld (hl),a 
9e34			 
9e34 21 24 e9			ld hl, cli_loop_stack 
9e37 22 ea e9			ld (cli_loop_sp), hl	 
9e3a				; set bottom of stack 
9e3a 3e 00			ld a,0 
9e3c 77				ld (hl),a 
9e3d 23				inc hl 
9e3e 77				ld (hl),a 
9e3f			 
9e3f				; init extent of current open file 
9e3f			 
9e3f 3e 00			ld a, 0 
9e41 32 64 ea			ld (store_openext), a 
9e44			 
9e44 c9				ret 
9e45			 
9e45			 
9e45			 
9e45			; Cold Start - this is called to setup the whole Forth system 
9e45			 
9e45			forth_init: 
9e45			 
9e45				; setup stack over/under flow checks 
9e45			 
9e45			;	if DEBUG_FORTH_STACK_GUARD 
9e45			;		call chk_stk_init 
9e45			;	endif 
9e45			 
9e45				; enable auto display updates (slow.....) 
9e45			 
9e45 3e 01			ld a, 1 
9e47 32 36 ea			ld (cli_autodisplay), a 
9e4a			 
9e4a				; if storage is in use disable long reads for now 
9e4a 3e 00			ld a, 0 
9e4c 32 6f ea			ld (store_longread), a 
9e4f			 
9e4f			 
9e4f				; show start up screen 
9e4f			 
9e4f cd bd 8a			call clear_display 
9e52			 
9e52 3e 00			ld a,0 
9e54 32 58 ea			ld (f_cursor_ptr), a 
9e57			 
9e57				; set start of word list in start of ram - for use when creating user words 
9e57			 
9e57 21 bf e2			ld hl, baseram 
9e5a 22 b8 e5			ld (os_last_new_uword), hl 
9e5d cd fe 9d			call user_word_eol 
9e60				 
9e60			;		call display_data_sp 
9e60			;		call next_page_prompt 
9e60			 
9e60			 
9e60			 
9e60			 
9e60 c9				ret 
9e61			 
9e61 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e75			 
9e75			; TODO push to stack 
9e75			 
9e75			;  
9e75			 
9e75			if FORTH_PARSEV2 
9e75			 
9e75			 
9e75				include "forth_parserv2.asm" 
9e75			 
9e75			endif 
9e75			 
9e75			 
9e75			; parse cli version 1 
9e75			 
9e75			if FORTH_PARSEV1 
9e75			 
9e75			 
9e75			 
9e75			      include "forth_parserv1.asm" 
9e75			endif 
9e75				 
9e75			if FORTH_PARSEV3 
9e75			      include "forth_parserv3.asm" 
9e75				include "forth_wordsv3.asm" 
9e75			endif 
9e75			 
9e75			if FORTH_PARSEV4 
9e75			      include "forth_parserv4.asm" 
9e75				include "forth_wordsv4.asm" 
9e75			endif 
9e75			 
9e75			if FORTH_PARSEV5 
9e75			      include "forth_parserv5.asm" 
9e75				include "forth_wordsv4.asm" 
9e75			endif 
9e75			 
9e75			if FORTH_PARSEV6 
9e75			      include "forth_parserv6.asm" 
9e75			 
9e75			 
9e75			; A better parser without using malloc and string copies all over the place.  
9e75			; Exec in situ should be faster 
9e75			 
9e75			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e75			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e75			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e75			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e75			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e75			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e75			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e75			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e75			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e75			 
9e75			; Core word preamble macro 
9e75			 
9e75			CWHEAD:   macro nxtword opcode lit len opflags 
9e75				db WORD_SYS_CORE+opcode             
9e75				; internal op code number 
9e75				dw nxtword            
9e75				; link to next dict word block 
9e75				db len + 1 
9e75				; literal length of dict word inc zero term 
9e75				db lit,0              
9e75				; literal dict word 
9e75			        ; TODO db opflags        
9e75				endm 
9e75			 
9e75			 
9e75			NEXTW: macro  
9e75				jp macro_next 
9e75				endm 
9e75			 
9e75			macro_next: 
9e75			if DEBUG_FORTH_PARSE_EXEC 
9e75				DMARK "NXT" 
9e75				CALLMONITOR 
9e75			endif	 
9e75			;	inc hl  ; skip token null term  
9e75 ed 4b 3a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e79 ed 5b 38 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e7d 2a bc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e80			if DEBUG_FORTH_PARSE_EXEC 
9e80				DMARK "}AA" 
9e80				CALLMONITOR 
9e80			endif	 
9e80 c3 6f 9f			jp execnext 
9e83				;jp exec1 
9e83			       
9e83			 
9e83			 
9e83			; Another go at the parser to compile  
9e83			 
9e83			 
9e83			; TODO rework parser to change all of the string words to byte tokens 
9e83			; TODO do a search for  
9e83			 
9e83			; TODO first run normal parser to zero term sections 
9e83			; TODO for each word do a token look up to get the op code 
9e83			; TODO need some means to flag to the exec that this is a byte code form    
9e83			 
9e83			 
9e83			forthcompile: 
9e83			 
9e83			; 
9e83			; line parse: 
9e83			;       parse raw input buffer 
9e83			;       tokenise the words 
9e83			;       malloc new copy (for looping etc) 
9e83			;       copy to malloc + current pc in line to start of string and add line term 
9e83			;       save on new rsp 
9e83			; 
9e83			 
9e83			; hl to point to the line to tokenise 
9e83			 
9e83			;	push hl 
9e83 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e86			 
9e86			;	ld a,0		; string term on input 
9e86			;	call strlent 
9e86			 
9e86			;	ld (os_tok_len), hl	 ; save string length 
9e86			 
9e86			;if DEBUG_FORTH_TOK 
9e86			;	ex de,hl		 
9e86			;endif 
9e86			 
9e86			;	pop hl 		; get back string pointer 
9e86			 
9e86			if DEBUG_FORTH_TOK 
9e86						DMARK "TOc" 
9e86				CALLMONITOR 
9e86			endif 
9e86 7e			.cptoken2:    ld a,(hl) 
9e87 23				inc hl 
9e88 fe 7f			cp FORTH_END_BUFFER 
9e8a 28 29			jr z, .cptokendone2 
9e8c fe 00			cp 0 
9e8e 28 25			jr z, .cptokendone2 
9e90 fe 22			cp '"' 
9e92 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e94 fe 20			cp ' ' 
9e96 20 ee			jr nz,  .cptoken2 
9e98			 
9e98			; TODO consume comments held between ( and ) 
9e98			 
9e98				; we have a space so change to zero term for dict match later 
9e98 2b				dec hl 
9e99 3e 00			ld a,0 
9e9b 77				ld (hl), a 
9e9c 23				inc hl 
9e9d 18 e7			jr .cptoken2 
9e9f				 
9e9f			 
9e9f			.cptokenstr2: 
9e9f				; skip all white space until either eol (because forgot to term) or end double quote 
9e9f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e9f				;inc hl ; skip current double quote 
9e9f 7e				ld a,(hl) 
9ea0 23				inc hl 
9ea1 fe 22			cp '"' 
9ea3 28 e1			jr z, .cptoken2 
9ea5 fe 7f			cp FORTH_END_BUFFER 
9ea7 28 0c			jr z, .cptokendone2 
9ea9 fe 00			cp 0 
9eab 28 08			jr z, .cptokendone2 
9ead fe 20			cp ' ' 
9eaf 28 02			jr z, .cptmp2 
9eb1 18 ec			jr .cptokenstr2 
9eb3			 
9eb3			.cptmp2:	; we have a space so change to zero term for dict match later 
9eb3				;dec hl 
9eb3				;ld a,"-"	; TODO remove this when working 
9eb3				;ld (hl), a 
9eb3				;inc hl 
9eb3 18 ea			jr .cptokenstr2 
9eb5			 
9eb5			.cptokendone2: 
9eb5				;inc hl 
9eb5 3e 7f			ld a, FORTH_END_BUFFER 
9eb7 77				ld (hl),a 
9eb8			;	inc hl 
9eb8			;	ld a, '!' 
9eb8			;	ld (hl),a 
9eb8			 
9eb8 2a bc e5			ld hl,(os_tok_ptr) 
9ebb			         
9ebb			if DEBUG_FORTH_TOK 
9ebb						DMARK "Tc1" 
9ebb				CALLMONITOR 
9ebb			endif 
9ebb			 
9ebb				; push exec string to top of return stack 
9ebb				FORTH_RSP_NEXT 
9ebb cd 2c 9a			call macro_forth_rsp_next 
9ebe				endm 
# End of macro FORTH_RSP_NEXT
9ebe c9				ret 
9ebf			 
9ebf			; Another go at the parser need to simplify the process 
9ebf			 
9ebf			forthparse: 
9ebf			 
9ebf			; 
9ebf			; line parse: 
9ebf			;       parse raw input buffer 
9ebf			;       tokenise the words 
9ebf			;       malloc new copy (for looping etc) 
9ebf			;       copy to malloc + current pc in line to start of string and add line term 
9ebf			;       save on new rsp 
9ebf			; 
9ebf			 
9ebf			; hl to point to the line to tokenise 
9ebf			 
9ebf			;	push hl 
9ebf 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ec2			 
9ec2			;	ld a,0		; string term on input 
9ec2			;	call strlent 
9ec2			 
9ec2			;	ld (os_tok_len), hl	 ; save string length 
9ec2			 
9ec2			;if DEBUG_FORTH_TOK 
9ec2			;	ex de,hl		 
9ec2			;endif 
9ec2			 
9ec2			;	pop hl 		; get back string pointer 
9ec2			 
9ec2			if DEBUG_FORTH_TOK 
9ec2						DMARK "TOK" 
9ec2				CALLMONITOR 
9ec2			endif 
9ec2 7e			.ptoken2:    ld a,(hl) 
9ec3 23				inc hl 
9ec4 fe 7f			cp FORTH_END_BUFFER 
9ec6 28 29			jr z, .ptokendone2 
9ec8 fe 00			cp 0 
9eca 28 25			jr z, .ptokendone2 
9ecc fe 22			cp '"' 
9ece 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9ed0 fe 20			cp ' ' 
9ed2 20 ee			jr nz,  .ptoken2 
9ed4			 
9ed4			; TODO consume comments held between ( and ) 
9ed4			 
9ed4				; we have a space so change to zero term for dict match later 
9ed4 2b				dec hl 
9ed5 3e 00			ld a,0 
9ed7 77				ld (hl), a 
9ed8 23				inc hl 
9ed9 18 e7			jr .ptoken2 
9edb				 
9edb			 
9edb			.ptokenstr2: 
9edb				; skip all white space until either eol (because forgot to term) or end double quote 
9edb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9edb				;inc hl ; skip current double quote 
9edb 7e				ld a,(hl) 
9edc 23				inc hl 
9edd fe 22			cp '"' 
9edf 28 e1			jr z, .ptoken2 
9ee1 fe 7f			cp FORTH_END_BUFFER 
9ee3 28 0c			jr z, .ptokendone2 
9ee5 fe 00			cp 0 
9ee7 28 08			jr z, .ptokendone2 
9ee9 fe 20			cp ' ' 
9eeb 28 02			jr z, .ptmp2 
9eed 18 ec			jr .ptokenstr2 
9eef			 
9eef			.ptmp2:	; we have a space so change to zero term for dict match later 
9eef				;dec hl 
9eef				;ld a,"-"	; TODO remove this when working 
9eef				;ld (hl), a 
9eef				;inc hl 
9eef 18 ea			jr .ptokenstr2 
9ef1			 
9ef1			.ptokendone2: 
9ef1				;inc hl 
9ef1 3e 7f			ld a, FORTH_END_BUFFER 
9ef3 77				ld (hl),a 
9ef4			;	inc hl 
9ef4			;	ld a, '!' 
9ef4			;	ld (hl),a 
9ef4			 
9ef4 2a bc e5			ld hl,(os_tok_ptr) 
9ef7			         
9ef7			if DEBUG_FORTH_TOK 
9ef7						DMARK "TK1" 
9ef7				CALLMONITOR 
9ef7			endif 
9ef7			 
9ef7				; push exec string to top of return stack 
9ef7				FORTH_RSP_NEXT 
9ef7 cd 2c 9a			call macro_forth_rsp_next 
9efa				endm 
# End of macro FORTH_RSP_NEXT
9efa c9				ret 
9efb			 
9efb			; 
9efb			;	; malloc size + buffer pointer + if is loop flag 
9efb			;	ld hl,(os_tok_len) 		 ; get string length 
9efb			; 
9efb			;	ld a,l 
9efb			; 
9efb			;	cp 0			; we dont want to use a null string 
9efb			;	ret z 
9efb			; 
9efb			;;	add 3    ; prefix malloc with buffer for current word ptr 
9efb			; 
9efb			;	add 5     ; TODO when certain not over writing memory remove 
9efb			; 
9efb			;		 
9efb			; 
9efb			;if DEBUG_FORTH_TOK 
9efb			;			DMARK "TKE" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			; 
9efb			;	ld l,a 
9efb			;	ld h,0 
9efb			;;	push hl   ; save required space for the copy later 
9efb			;	call malloc 
9efb			;if DEBUG_FORTH_TOK 
9efb			;			DMARK "TKM" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			;	if DEBUG_FORTH_MALLOC_GUARD 
9efb			;		push af 
9efb			;		call ishlzero 
9efb			;;		ld a, l 
9efb			;;		add h 
9efb			;;		cp 0 
9efb			;		pop af 
9efb			;		 
9efb			;		call z,malloc_error 
9efb			;	endif 
9efb			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9efb			; 
9efb			; 
9efb			;if DEBUG_FORTH_TOK 
9efb			;			DMARK "TKR" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			; 
9efb			;	FORTH_RSP_NEXT 
9efb			; 
9efb			;	;inc hl	 ; go past current buffer pointer 
9efb			;	;inc hl 
9efb			;	;inc hl   ; and past if loop flag 
9efb			;		; TODO Need to set flag  
9efb			; 
9efb			;	 
9efb			;	 
9efb			;	ex de,hl	; malloc is dest 
9efb			;	ld hl, (os_tok_len) 
9efb			;;	pop bc 
9efb			;	ld c, l                
9efb			;	ld b,0 
9efb			;	ld hl, (os_tok_ptr) 
9efb			; 
9efb			;if DEBUG_FORTH_TOK 
9efb			;			DMARK "TKT" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			; 
9efb			;	; do str cpy 
9efb			; 
9efb			;	ldir      ; copy byte in hl to de 
9efb			; 
9efb			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9efb			; 
9efb			;if DEBUG_FORTH_TOK 
9efb			; 
9efb			;			DMARK "TKY" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			;	;ld a,0 
9efb			;	;ld a,FORTH_END_BUFFER 
9efb			;	ex de, hl 
9efb			;	;dec hl			 ; go back over the space delim at the end of word 
9efb			;	;ld (hl),a 
9efb			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9efb			;	ld a,FORTH_END_BUFFER 
9efb			;	ld (hl),a 
9efb			;	inc hl 
9efb			;	ld a,FORTH_END_BUFFER 
9efb			;	ld (hl),a 
9efb			; 
9efb			;	; init the malloc area data 
9efb			;	; set pc for in current area 
9efb			;	;ld hl, (os_tok_malloc) 
9efb			;	;inc hl 
9efb			;	;inc hl 
9efb			;	;inc hl 
9efb			;	;ex de,hl 
9efb			;	;ld hl, (os_tok_malloc) 
9efb			;	;ld (hl),e 
9efb			;	;inc hl 
9efb			;	;ld (hl),d 
9efb			; 
9efb			; 
9efb			;	ld hl,(os_tok_malloc) 
9efb			;if DEBUG_FORTH_PARSE_KEY 
9efb			;			DMARK "TKU" 
9efb			;	CALLMONITOR 
9efb			;endif 
9efb			; 
9efb			;	ret 
9efb			 
9efb			forthexec: 
9efb			 
9efb			; line exec: 
9efb			; forth parser 
9efb			 
9efb			; 
9efb			;       get current exec line on rsp 
9efb			 
9efb				FORTH_RSP_TOS 
9efb cd 43 9a			call macro_forth_rsp_tos 
9efe				endm 
# End of macro FORTH_RSP_TOS
9efe			 
9efe			;       restore current pc - hl points to malloc of data 
9efe			 
9efe				;ld e, (hl) 
9efe				;inc hl 
9efe				;ld d, (hl) 
9efe				;ex de,hl 
9efe			 
9efe			 
9efe			exec1: 
9efe 22 bc e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9f01			 
9f01				; copy our PC to working vars  
9f01 22 3a ea			ld (cli_ptr), hl                    ; here 
9f04 22 38 ea			ld (cli_origptr), hl                ; here 
9f07			 
9f07 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9f08 fe 7f			cp FORTH_END_BUFFER 
9f0a c8				ret z 
9f0b			 
9f0b				; skip any nulls 
9f0b			 
9f0b fe 00			cp 0 
9f0d 20 03			jr nz, .execword 
9f0f 23				inc hl 
9f10 18 ec			jr exec1 
9f12			 
9f12			 
9f12			.execword: 
9f12			 
9f12			 
9f12			 
9f12			if DEBUG_FORTH_PARSE_EXEC 
9f12						DMARK "KYQ" 
9f12				CALLMONITOR 
9f12			endif 
9f12			;       while at start of word: 
9f12			; get start of dict (in user area first) 
9f12			 
9f12 21 bf e2		ld hl, baseram 
9f15			;ld hl, sysdict 
9f15 22 3c ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9f18			;           match word at pc 
9f18			;           exec word 
9f18			;           or push to dsp 
9f18			;           forward to next token 
9f18			;           if line term pop rsp and exit 
9f18			;        
9f18			 
9f18			if DEBUG_FORTH_PARSE_EXEC 
9f18						DMARK "KYq" 
9f18				CALLMONITOR 
9f18			endif 
9f18			 
9f18			; 
9f18			; word comp 
9f18			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f18			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f18			;    move to start of word  
9f18			;    compare word to cli_token 
9f18			 
9f18			.execpnword:	; HL at start of a word in the dictionary to check 
9f18			 
9f18 2a 3c ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9f1b			 
9f1b cd b2 9f			call forth_tok_next 
9f1e			; tok next end here 
9f1e 22 3c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f21 eb				ex de, hl 
9f22			 
9f22			 
9f22				; save the pointer of the current token - 1 to check against 
9f22				 
9f22 22 40 ea			ld (cli_token), hl   
9f25				; TODO maybe remove below save if no debug 
9f25				; save token string ptr for any debug later 
9f25 23				inc hl  
9f26 22 42 ea			ld (cli_origtoken), hl 
9f29 2b				dec hl 
9f2a				; save pointer to the start of the next dictionay word 
9f2a 7e				ld a,(hl)   ; get string length 
9f2b 47				ld b,a 
9f2c			.execpnwordinc:  
9f2c 23				inc hl 
9f2d 10 fd			djnz .execpnwordinc 
9f2f 22 3e ea			ld (cli_execword), hl      ; save start of this words code 
9f32			 
9f32				; now check the word token against the string being parsed 
9f32			 
9f32 2a 40 ea			ld hl,(cli_token) 
9f35 23				inc hl     ; skip string length (use zero term instead to end) 
9f36				;ld (cli_token), hl 
9f36			 
9f36			.execpnchar:    ; compare char between token and string to parse 
9f36			 
9f36			 
9f36				;ld hl, (cli_token)     ; the dict word  
9f36 ed 5b 3a ea		ld de, (cli_ptr)     ; cli to parse 
9f3a			 
9f3a			 
9f3a			.execpncharl:    ; compare char between token and string to parse (loop) 
9f3a			 
9f3a 1a				ld a,(de) 
9f3b cd 47 90			call toUpper 		; make sure the input string matches case 
9f3e be				cp (hl) 
9f3f			 
9f3f c2 58 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f42				 
9f42			;    if same 
9f42			;       scan for string terms 0 for token and 32 for input 
9f42 46				ld b,(hl) 
9f43 80				add b			 
9f44 23				inc hl 
9f45 13				inc de 
9f46 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f48							; TODO need to make sure last word in zero term string is accounted for 
9f48 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
9f4a			 
9f4a			 
9f4a				; at end of both strings so both are exact match 
9f4a			 
9f4a			;       skip ptr for next word 
9f4a			 
9f4a 2a 3a ea			ld hl,(cli_ptr) 	; at input string term 
9f4d 23				inc hl			 ; at next char 
9f4e 22 3a ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f51 22 38 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f54				 
9f54				 
9f54			 
9f54			 
9f54			 
9f54			;       exec code block 
9f54			if DEBUG_FORTH_JP 
9f54				call clear_display 
9f54				call update_display 
9f54				call delay1s 
9f54				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f54				ld a,h 
9f54				ld hl, os_word_scratch 
9f54				call hexout 
9f54				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f54				ld a,l 
9f54				ld hl, os_word_scratch+2 
9f54				call hexout 
9f54				ld hl, os_word_scratch+4 
9f54				ld a,0 
9f54				ld (hl),a 
9f54				ld de,os_word_scratch 
9f54				call str_at_display 
9f54					ld a, display_row_2 
9f54					call str_at_display 
9f54				ld de, (cli_origtoken) 
9f54				ld a, display_row_1+10 
9f54					call str_at_display 
9f54			 
9f54				ld a,display_row_1 
9f54				ld de, .foundword 
9f54				ld a, display_row_3 
9f54				call str_at_display 
9f54				call update_display 
9f54				call delay1s 
9f54				call delay1s 
9f54				call delay1s 
9f54			endif 
9f54			 
9f54			if DEBUG_FORTH_PARSE_EXEC 
9f54						DMARK "KYj" 
9f54			endif 
9f54				; TODO save the word pointer in this exec 
9f54			 
9f54 2a 3e ea			ld hl,(cli_execword) 
9f57 e9				jp (hl) 
9f58			 
9f58			 
9f58			;    if not same 
9f58			;	scan for zero term 
9f58			;	get ptr for next word 
9f58			;	goto word comp 
9f58			 
9f58			.execpnskipword:	; get pointer to next word 
9f58 2a 3c ea			ld hl,(cli_nextword) 
9f5b			 
9f5b 7e				ld a,(hl) 
9f5c fe 00			cp WORD_SYS_END 
9f5e			;	cp 0 
9f5e 28 09			jr z, .execendofdict			 ; at end of words 
9f60			 
9f60			if DEBUG_FORTH_PARSE_EXEC 
9f60						DMARK "KY4" 
9f60			endif 
9f60			if DEBUG_FORTH_PARSE_EXEC 
9f60			 
9f60				; see if disabled 
9f60			 
9f60			;	ld a, (os_view_disable) 
9f60			;	cp '*' 
9f60				ld a,(debug_vector) 
9f60				cp $c9   ; RET 
9f60				jr z, .noskip 
9f60			 
9f60			 
9f60				ld de, .nowordfound 
9f60				ld a, display_row_3 
9f60				call str_at_display 
9f60				call update_display 
9f60				ld a, 100 
9f60				call aDelayInMS 
9f60				 
9f60				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f60					call delay250ms 
9f60				endif 
9f60			.noskip:  
9f60			 
9f60			endif	 
9f60			 
9f60 2a 38 ea			ld hl,(cli_origptr) 
9f63 22 3a ea			ld (cli_ptr),hl 
9f66			 
9f66			if DEBUG_FORTH_PARSE_EXEC 
9f66						DMARK "KY5" 
9f66			endif 
9f66 c3 18 9f			jp .execpnword			; else go to next word 
9f69			 
9f69			.execendofdict:  
9f69			 
9f69			if DEBUG_FORTH_PARSE_EXEC 
9f69						DMARK "KYe" 
9f69			endif 
9f69			if DEBUG_FORTH_PARSE_EXEC 
9f69				; see if disabled 
9f69			 
9f69			;	ld a, (os_view_disable) 
9f69			;	cp '*' 
9f69				ld a,(debug_vector) 
9f69				cp $c9   ; ret 
9f69				jr z, .ispskip 
9f69			 
9f69				call clear_display 
9f69				call update_display 
9f69				call delay1s 
9f69				ld de, (cli_origptr) 
9f69				ld a, display_row_1 
9f69				call str_at_display 
9f69				 
9f69				ld de, .enddict 
9f69				ld a, display_row_3 
9f69				call str_at_display 
9f69				call update_display 
9f69				ld a, 100 
9f69				call aDelayInMS 
9f69				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f69				call delay1s 
9f69				call delay1s 
9f69				call delay1s 
9f69				endif 
9f69			.ispskip:  
9f69				 
9f69			endif	 
9f69			 
9f69			 
9f69			 
9f69				; if the word is not a keyword then must be a literal so push it to stack 
9f69			 
9f69			; push token to stack to end of word 
9f69			 
9f69				STACKFRAME ON $1efe $2f9f 
9f69				if DEBUG_STACK_IMB 
9f69					if ON 
9f69						exx 
9f69						ld de, $1efe 
9f69						ld a, d 
9f69						ld hl, curframe 
9f69						call hexout 
9f69						ld a, e 
9f69						ld hl, curframe+2 
9f69						call hexout 
9f69						ld hl, $1efe 
9f69						push hl 
9f69						ld hl, $2f9f 
9f69						push hl 
9f69						exx 
9f69					endif 
9f69				endif 
9f69			endm 
# End of macro STACKFRAME
9f69			 
9f69 2a bc e5		ld hl,(os_tok_ptr) 
9f6c cd ee 9b		call forth_apush 
9f6f			 
9f6f				STACKFRAMECHK ON $1efe $2f9f 
9f6f				if DEBUG_STACK_IMB 
9f6f					if ON 
9f6f						exx 
9f6f						ld hl, $2f9f 
9f6f						pop de   ; $2f9f 
9f6f						call cmp16 
9f6f						jr nz, .spnosame 
9f6f						ld hl, $1efe 
9f6f						pop de   ; $1efe 
9f6f						call cmp16 
9f6f						jr z, .spfrsame 
9f6f						.spnosame: call showsperror 
9f6f						.spfrsame: nop 
9f6f						exx 
9f6f					endif 
9f6f				endif 
9f6f			endm 
# End of macro STACKFRAMECHK
9f6f			 
9f6f			execnext: 
9f6f			 
9f6f			if DEBUG_FORTH_PARSE_EXEC 
9f6f						DMARK "KY>" 
9f6f			endif 
9f6f			; move past token to next word 
9f6f			 
9f6f 2a bc e5		ld hl, (os_tok_ptr) 
9f72 3e 00		ld a, 0 
9f74 01 ff 00		ld bc, 255     ; input buffer size 
9f77 ed b1		cpir 
9f79			 
9f79			if DEBUG_FORTH_PARSE_EXEC 
9f79						DMARK "KY!" 
9f79				CALLMONITOR 
9f79			endif	 
9f79			; TODO this might place hl on the null, so will need to forward on??? 
9f79			;inc hl   ; see if this gets onto the next item 
9f79			 
9f79			 
9f79			; TODO pass a pointer to the buffer to push 
9f79			; TODO call function to push 
9f79			 
9f79			; look for end of input 
9f79			 
9f79			;inc hl 
9f79			;ld a,(hl) 
9f79			;cp FORTH_END_BUFFER 
9f79			;ret z 
9f79			 
9f79			 
9f79 c3 fe 9e		jp exec1 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			 
9f7c			findnexttok: 
9f7c			 
9f7c				; hl is pointer to move 
9f7c				; de is the token to locate 
9f7c			 
9f7c					if DEBUG_FORTH 
9f7c						DMARK "NTK" 
9f7c						CALLMONITOR 
9f7c					endif 
9f7c d5				push de 
9f7d			 
9f7d			.fnt1:	 
9f7d				; find first char of token to locate 
9f7d			 
9f7d 1a				ld a, (de) 
9f7e 4f				ld c,a 
9f7f 7e				ld a,(hl) 
9f80 cd 47 90			call toUpper 
9f83					if DEBUG_FORTH 
9f83						DMARK "NT1" 
9f83						CALLMONITOR 
9f83					endif 
9f83 b9				cp c 
9f84			 
9f84 28 03			jr z, .fnt2cmpmorefirst	 
9f86			 
9f86				; first char not found move to next char 
9f86			 
9f86 23				inc hl 
9f87 18 f4			jr .fnt1 
9f89			 
9f89			.fnt2cmpmorefirst:	 
9f89				; first char of token found.  
9f89			 
9f89 e5				push hl     ; save start of token just in case it is the right one 
9f8a d9				exx 
9f8b e1				pop hl        ; save it to hl' 
9f8c d9				exx 
9f8d			 
9f8d			 
9f8d			.fnt2cmpmore:	 
9f8d				; compare the rest 
9f8d				 
9f8d 23				inc hl 
9f8e 13				inc de 
9f8f				 
9f8f 1a				ld a, (de) 
9f90 4f				ld c,a 
9f91 7e				ld a,(hl) 
9f92 cd 47 90			call toUpper 
9f95			 
9f95					if DEBUG_FORTH 
9f95						DMARK "NT2" 
9f95						CALLMONITOR 
9f95					endif 
9f95				; c has the token to find char 
9f95				; a has the mem to scan char 
9f95			 
9f95 b9				cp c 
9f96 28 04			jr z,.fntmatch1 
9f98			 
9f98				; they are not the same 
9f98			 
9f98					if DEBUG_FORTH 
9f98						DMARK "NT3" 
9f98						CALLMONITOR 
9f98					endif 
9f98 d1				pop de	; reset de token to look for 
9f99 d5				push de 
9f9a 18 e1			jr .fnt1 
9f9c				 
9f9c			.fntmatch1: 
9f9c			 
9f9c				; is the same char a null which means we might have a full hit? 
9f9c					if DEBUG_FORTH 
9f9c						DMARK "NT4" 
9f9c						CALLMONITOR 
9f9c					endif 
9f9c			 
9f9c fe 00			cp 0 
9f9e 28 0b			jr z, .fntmatchyes 
9fa0			 
9fa0				; are we at the end of the token to find? 
9fa0			 
9fa0					if DEBUG_FORTH 
9fa0						DMARK "NT5" 
9fa0						CALLMONITOR 
9fa0					endif 
9fa0 3e 00			ld a, 0 
9fa2 b9				cp c 
9fa3			 
9fa3 c2 8d 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9fa6			 
9fa6					if DEBUG_FORTH 
9fa6						DMARK "NT6" 
9fa6						CALLMONITOR 
9fa6					endif 
9fa6				; token to find is exhusted but no match to stream 
9fa6			 
9fa6				; restore tok pointer and continue on 
9fa6 d1				pop de 
9fa7 d5				push de 
9fa8 c3 7d 9f			jp .fnt1 
9fab			 
9fab			 
9fab			.fntmatchyes: 
9fab			 
9fab				; hl now contains the end of the found token 
9fab			 
9fab				; get rid of saved token pointer to find 
9fab			 
9fab d1				pop de 
9fac			 
9fac					if DEBUG_FORTH 
9fac						DMARK "NT9" 
9fac						CALLMONITOR 
9fac					endif 
9fac			 
9fac				; hl will be on the null term so forward on 
9fac			 
9fac				; get back the saved start of the token 
9fac			 
9fac d9				exx 
9fad e5				push hl     ; save start of token just in case it is the right one 
9fae d9				exx 
9faf e1				pop hl        ; save it to hl 
9fb0			 
9fb0 c9				ret 
9fb1			 
9fb1			 
9fb1			; LIST needs to find a specific token   
9fb1			; FORGET needs to find a spefici token 
9fb1			 
9fb1			; SAVE needs to find all tokens by flag 
9fb1			; WORDS just needs to scan through all  by flag 
9fb1			; UWORDS needs to scan through all by flag 
9fb1			 
9fb1			 
9fb1			; given hl as pointer to start of dict look up string 
9fb1			; return hl as pointer to start of word block 
9fb1			; or 0 if not found 
9fb1			 
9fb1			forth_find_tok: 
9fb1 c9				ret 
9fb2			 
9fb2			; given hl as pointer to dict structure 
9fb2			; move to the next dict block structure 
9fb2			 
9fb2			forth_tok_next: 
9fb2				; hl now points to the address of the next word pointer  
9fb2				; TODO skip compiled symbol for now 
9fb2			;	push de 
9fb2 23				inc hl 
9fb3 5e				ld e, (hl) 
9fb4 23				inc hl 
9fb5 56				ld d, (hl) 
9fb6 23				inc hl 
9fb7			 
9fb7 eb				ex de,hl 
9fb8			if DEBUG_FORTH_PARSE_NEXTWORD 
9fb8				push bc 
9fb8				ld bc, (cli_nextword) 
9fb8						DMARK "NXW" 
9fb8				CALLMONITOR 
9fb8				pop bc 
9fb8			endif 
9fb8			;	pop de	 
9fb8 c9				ret 
9fb9			 
9fb9			 
9fb9			 
9fb9			; eof 
# End of file forth_parserv6.asm
9fb9				include "forth_wordsv4.asm" 
9fb9			 
9fb9			; the core word dictionary v4 
9fb9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fb9			 
9fb9			; this is a linked list for each of the system words used 
9fb9			; user defined words will follow the same format but will be in ram 
9fb9			 
9fb9			 
9fb9			; 
9fb9			; 
9fb9			; define linked list: 
9fb9			; 
9fb9			; 1. compiled byte op code 
9fb9			; 2. len of text word 
9fb9			; 3. text word 
9fb9			; 4. ptr to next dictionary word 
9fb9			; 5. asm, calls etc for the word 
9fb9			; 
9fb9			;  if 1 == 0 then last word in dict  
9fb9			;   
9fb9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fb9			;  
9fb9			;  
9fb9			; create basic standard set of words 
9fb9			; 
9fb9			;  
9fb9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fb9			; 2DUP 2DROP 2SWAP  
9fb9			; @ C@ - get byte  
9fb9			; ! C! - store byte 
9fb9			; 0< true if less than zero 
9fb9			; 0= true if zero 
9fb9			; < >  
9fb9			; = true if same 
9fb9			; variables 
9fb9			 
9fb9			 
9fb9			; Hardware specific words I may need 
9fb9			; 
9fb9			; IN OUT  
9fb9			; calls to key util functions 
9fb9			; calls to hardward abstraction stuff 
9fb9			; easy control of frame buffers and lcd i/o 
9fb9			; keyboard  
9fb9			 
9fb9			 
9fb9			;DICT: macro 
9fb9			; op_code, len, word, next 
9fb9			;    word: 
9fb9			;    db op_code 
9fb9			;    ds word zero term 
9fb9			;    dw next 
9fb9			;    endm 
9fb9			 
9fb9			 
9fb9			 
9fb9			 
9fb9			; op code 1 is a flag for user define words which are to be handled differently 
9fb9			 
9fb9			 
9fb9			; 
9fb9			; 
9fb9			;    TODO on entry to a word this should be the expected environment 
9fb9			;    hl - tos value if number then held, if string this is the ptr 
9fb9			;    de -  
9fb9			 
9fb9			 
9fb9			; opcode ranges 
9fb9			; 0 - end of word dict 
9fb9			; 255 - user define words 
9fb9			 
9fb9			sysdict: 
9fb9			include "forth_opcodes.asm" 
9fb9			; op codes for forth keywords 
9fb9			 
9fb9			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9fb9			; This provides a means to compile uwords if required for higher performance 
9fb9			; by avoiding the use of the keyword parser and just jumping directly to the code 
9fb9			; Actually there is already a flag for if the code exists as binary thinking about it... 
9fb9			 
9fb9			 
9fb9			 
9fb9			 
9fb9			 
9fb9			; free to use code 0  
9fb9				OPCODE_HEAP: equ  1 
9fb9				OPCODE_EXEC: equ 2 
9fb9				OPCODE_DUP: equ 3 
9fb9				OPCODE_SWAP: equ 4 
9fb9				OPCODE_COLN: equ 5 
9fb9				OPCODE_SCOLN: equ 6 
9fb9				OPCODE_DROP: equ 7 
9fb9				OPCODE_DUP2: equ 8 
9fb9				OPCODE_DROP2: equ 9 
9fb9				OPCODE_SWAP2: equ 10 
9fb9				OPCODE_AT: equ 11 
9fb9				OPCODE_CAT: equ 12 
9fb9				OPCODE_BANG: equ 13 
9fb9				OPCODE_CBANG: equ 14 
9fb9				OPCODE_SCALL: equ 15 
9fb9				OPCODE_DEPTH: equ 16 
9fb9				OPCODE_OVER: equ 17 
9fb9				OPCODE_PAUSE: equ 18 
9fb9				OPCODE_PAUSES: equ 19 
9fb9				OPCODE_ROT: equ 20 
9fb9			;free to reuse	OPCODE_WORDS: equ 21 
9fb9			        OPCODE_NOT: equ 21 
9fb9				OPCODE_UWORDS: equ 22 
9fb9				OPCODE_BP: equ 23 
9fb9				OPCODE_MONITOR: equ 24  
9fb9				OPCODE_MALLOC: equ 25 
9fb9				OPCODE_FREE: equ 26 
9fb9				OPCODE_LIST: equ 27 
9fb9				OPCODE_FORGET: equ 28 
9fb9				OPCODE_NOP: equ 29 
9fb9				OPCODE_COMO: equ 30 
9fb9				OPCODE_COMC: equ 31 
9fb9			;free to reuse	OPCODE_ENDCORE: equ 32 
9fb9				OPCODE_AFTERSOUND: equ 33 
9fb9				OPCODE_GP2: equ 34 
9fb9				OPCODE_GP3: equ 35 
9fb9				OPCODE_GP4: equ 36 
9fb9				OPCODE_SIN: equ 37 
9fb9				OPCODE_SOUT: equ 38 
9fb9				OPCODE_SPIO: equ 39 
9fb9				OPCODE_SPICEH: equ 40 
9fb9				OPCODE_SPIOb: equ 41 
9fb9				OPCODE_SPII: equ 42 
9fb9				OPCODE_SESEL: equ 43 
9fb9				OPCODE_CARTDEV: equ 44 
9fb9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fb9				OPCODE_FB: equ 46 
9fb9				OPCODE_EMIT: equ 47 
9fb9				OPCODE_DOTH: equ 48 
9fb9				OPCODE_DOTF: equ 49 
9fb9				OPCODE_DOT: equ 50 
9fb9				OPCODE_CLS: equ 51 
9fb9				OPCODE_DRAW: equ 52 
9fb9				OPCODE_DUMP: equ 53 
9fb9				OPCODE_CDUMP: equ 54 
9fb9				OPCODE_DAT: equ 55 
9fb9				OPCODE_HOME: equ 56 
9fb9				OPCODE_SPACE: equ 57 
9fb9				OPCODE_SPACES: equ 58 
9fb9				OPCODE_SCROLL: equ 59 
9fb9				OPCODE_ATQ: equ 60 
9fb9				OPCODE_AUTODSP: equ 61 
9fb9				OPCODE_MENU: equ 62 
9fb9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fb9				OPCODE_THEN: equ 64 
9fb9				OPCODE_ELSE: equ 65 
9fb9				OPCODE_DO: equ 66 
9fb9				OPCODE_LOOP: equ 67 
9fb9				OPCODE_I: equ 68 
9fb9				OPCODE_DLOOP: equ 69  
9fb9				OPCODE_REPEAT: equ 70  
9fb9				OPCODE_UNTIL: equ 71 
9fb9				OPCODE_ENDFLOW: equ 72 
9fb9				OPCODE_WAITK: equ 73 
9fb9				OPCODE_ACCEPT: equ 74 
9fb9				OPCODE_EDIT: equ 75 
9fb9			;free to reuse	OPCODE_ENDKEY: equ 76 
9fb9				OPCODE_LZERO: equ 77 
9fb9				OPCODE_TZERO: equ 78 
9fb9				OPCODE_LESS: equ 79 
9fb9				OPCODE_GT: equ 80 
9fb9				OPCODE_EQUAL: equ 81  
9fb9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fb9				OPCODE_NEG: equ 83 
9fb9				OPCODE_DIV: equ 84 
9fb9				OPCODE_MUL: equ 85 
9fb9				OPCODE_MIN: equ 86 
9fb9				OPCODE_MAX: equ 87 
9fb9				OPCODE_RND16: equ 88 
9fb9				OPCODE_RND8: equ 89 
9fb9				OPCODE_RND: equ 90 
9fb9			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fb9				OPCODE_BYNAME: equ 92 
9fb9				OPCODE_DIR: equ 93 
9fb9				OPCODE_SAVE: equ 94 
9fb9				OPCODE_LOAD: equ 95 
9fb9				OPCODE_BSAVE: equ 96 
9fb9				OPCODE_BLOAD: equ 97 
9fb9				OPCODE_SEO: equ 98  
9fb9				OPCODE_SEI: equ 99 
9fb9				OPCODE_SFREE: equ 100 
9fb9				OPCODE_SIZE: equ 101 
9fb9				OPCODE_CREATE: equ 102 
9fb9				OPCODE_APPEND: equ 103 
9fb9				OPCODE_SDEL: equ 104 
9fb9				OPCODE_OPEN: equ 105 
9fb9				OPCODE_READ: equ 106 
9fb9				OPCODE_EOF: equ 106 
9fb9				OPCODE_FORMAT: equ 107 
9fb9				OPCODE_LABEL: equ 108 
9fb9				OPCODE_LABELS: equ 109 
9fb9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fb9				OPCODE_UPPER: equ 111 
9fb9				OPCODE_LOWER: equ 112 
9fb9				OPCODE_SUBSTR: equ 113 
9fb9				OPCODE_LEFT: equ 114 
9fb9				OPCODE_RIGHT: equ 115 
9fb9				OPCODE_STR2NUM: equ 116 
9fb9				OPCODE_NUM2STR: equ 117 
9fb9				OPCODE_CONCAT: equ 118 
9fb9				OPCODE_FIND: equ 119 
9fb9				OPCODE_LEN: equ 120 
9fb9				OPCODE_CHAR: equ 121 
9fb9			; free to reuse	OPCODE_STRLEN: equ 122 
9fb9			; free to reuse	OPCODE_ENDSTR: equ 123 
9fb9				OPCODE_V0S: equ 124 
9fb9				OPCODE_V0Q: equ 125 
9fb9				OPCODE_V1S: equ 126 
9fb9				OPCODE_V1Q: equ 127 
9fb9				OPCODE_V2S: equ 128 
9fb9				OPCODE_V2Q: equ 129 
9fb9				OPCODE_V3S: equ 130 
9fb9				OPCODE_V3Q: equ 131 
9fb9			;free to reuse	OPCODE_END: equ 132 
9fb9				OPCODE_ZDUP: equ 133 
9fb9			 
9fb9			; eof 
# End of file forth_opcodes.asm
9fb9			 
9fb9			include "forth_words_core.asm" 
9fb9			 
9fb9			; | ## Core Words 
9fb9			 
9fb9			;if MALLOC_4 
9fb9			 
9fb9			.HEAP: 
9fb9			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fb9 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fba f8 9f			dw .EXEC            
9fbc 05				db 4 + 1 
9fbd .. 00			db "HEAP",0              
9fc2				endm 
# End of macro CWHEAD
9fc2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fc2			; | | u1 - Current number of bytes in the heap 
9fc2			; | | u2 - Remaining bytes left on the heap 
9fc2			; | |  
9fc2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fc2			 
9fc2			 
9fc2				if DEBUG_FORTH_WORDS_KEY 
9fc2					DMARK "HEP" 
9fc2 f5				push af  
9fc3 3a d7 9f			ld a, (.dmark)  
9fc6 32 65 ee			ld (debug_mark),a  
9fc9 3a d8 9f			ld a, (.dmark+1)  
9fcc 32 66 ee			ld (debug_mark+1),a  
9fcf 3a d9 9f			ld a, (.dmark+2)  
9fd2 32 67 ee			ld (debug_mark+2),a  
9fd5 18 03			jr .pastdmark  
9fd7 ..			.dmark: db "HEP"  
9fda f1			.pastdmark: pop af  
9fdb			endm  
# End of macro DMARK
9fdb					CALLMONITOR 
9fdb cd 6f ee			call debug_vector  
9fde				endm  
# End of macro CALLMONITOR
9fde				endif 
9fde 2a c9 e2			ld hl, (free_list )      
9fe1 11 ce e2			ld de, heap_start 
9fe4			 
9fe4 ed 52			sbc hl, de  
9fe6			 
9fe6 cd 85 9a			call forth_push_numhl 
9fe9			 
9fe9			 
9fe9 ed 5b c9 e2		ld de, (free_list )      
9fed 21 96 e2			ld hl, heap_end 
9ff0			 
9ff0 ed 52			sbc hl, de 
9ff2			 
9ff2 cd 85 9a			call forth_push_numhl 
9ff5				 
9ff5			 
9ff5				 
9ff5			 
9ff5			 
9ff5			 
9ff5				NEXTW 
9ff5 c3 75 9e			jp macro_next 
9ff8				endm 
# End of macro NEXTW
9ff8			;endif 
9ff8			 
9ff8			.EXEC: 
9ff8			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9ff8			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9ff8			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9ff8			;; > > 
9ff8			;; > >   
9ff8			;	STACKFRAME OFF $5efe $5f9f 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS_KEY 
9ff8			;			DMARK "EXE" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			;	FORTH_DSP_VALUEHL 
9ff8			; 
9ff8			;	FORTH_DSP_POP 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX1" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;;	ld e,(hl) 
9ff8			;;	inc hl 
9ff8			;;	ld d,(hl) 
9ff8			;;	ex de,hl 
9ff8			; 
9ff8			;;		if DEBUG_FORTH_WORDS 
9ff8			;;			DMARK "EX2" 
9ff8			;;			CALLMONITOR 
9ff8			;;		endif 
9ff8			;	push hl 
9ff8			; 
9ff8			;	;ld a, 0 
9ff8			;	;ld a, FORTH_END_BUFFER 
9ff8			;	call strlenz 
9ff8			;	inc hl   ; include zero term to copy 
9ff8			;	inc hl   ; include term 
9ff8			;	inc hl   ; include term 
9ff8			;	ld b,0 
9ff8			;	ld c,l 
9ff8			;	pop hl 
9ff8			;	ld de, execscratch 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX3" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	ldir 
9ff8			; 
9ff8			; 
9ff8			;	ld hl, execscratch 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EXe" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			;	call forthparse 
9ff8			;	call forthexec 
9ff8			;;	call forthexec_cleanup 
9ff8			;;	call forthparse 
9ff8			;;	call forthexec 
9ff8			; 
9ff8			;	STACKFRAMECHK OFF $5efe $5f9f 
9ff8			; 
9ff8			;	; an immediate word so no need to process any more words 
9ff8			;	ret 
9ff8			;	NEXTW 
9ff8			 
9ff8			; dead code - old version  
9ff8			;	FORTH_RSP_NEXT 
9ff8			 
9ff8			;  
9ff8			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ff8			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ff8			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ff8			;	push hl 
9ff8			;	push de 
9ff8			;	push bc 
9ff8			; 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS_KEY 
9ff8			;			DMARK "EXR" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			; 
9ff8			; 
9ff8			;	;v5 FORTH_DSP_VALUE 
9ff8			;	FORTH_DSP_VALUEHL 
9ff8			; 
9ff8			;	; TODO do string type checks 
9ff8			; 
9ff8			;;v5	inc hl   ; skip type 
9ff8			; 
9ff8			;	push hl  ; source code  
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX1" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	ld a, 0 
9ff8			;	call strlent 
9ff8			; 
9ff8			;	inc hl 
9ff8			;	inc hl 
9ff8			;	inc hl 
9ff8			;	inc hl 
9ff8			; 
9ff8			;	push hl    ; size 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX2" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	call malloc 
9ff8			; 
9ff8			;	ex de, hl    ; de now contains malloc area 
9ff8			;	pop bc   	; get byte count 
9ff8			;	pop hl      ; get string to copy 
9ff8			; 
9ff8			;	push de     ; save malloc for free later 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX3" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	ldir       ; duplicate string 
9ff8			; 
9ff8			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9ff8			;	 
9ff8			;	; TODO fix the parse would be better than this...  
9ff8			;	ex de, hl 
9ff8			;	dec hl 
9ff8			;	ld a, 0 
9ff8			;	ld (hl), a 
9ff8			;	dec hl 
9ff8			;	ld a, ' ' 
9ff8			;	ld (hl), a 
9ff8			;	dec hl 
9ff8			;	ld (hl), a 
9ff8			; 
9ff8			;	dec hl 
9ff8			;	ld (hl), a 
9ff8			; 
9ff8			; 
9ff8			;	FORTH_DSP_POP  
9ff8			; 
9ff8			;	pop hl     
9ff8			;	push hl    ; save malloc area 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX4" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			;	call forthparse 
9ff8			;	call forthexec 
9ff8			;	 
9ff8			;	pop hl 
9ff8			;	if DEBUG_FORTH_WORDS 
9ff8			;		DMARK "EX5" 
9ff8			;		CALLMONITOR 
9ff8			;	endif 
9ff8			; 
9ff8			;	if FORTH_ENABLE_FREE 
9ff8			;	call free 
9ff8			;	endif 
9ff8			; 
9ff8			;	if DEBUG_FORTH_WORDS 
9ff8			;		DMARK "EX6" 
9ff8			;		CALLMONITOR 
9ff8			;	endif 
9ff8			; 
9ff8			;	pop bc 
9ff8			;	pop de 
9ff8			;	pop hl 
9ff8			;;	FORTH_RSP_POP	  
9ff8			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9ff8			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9ff8			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9ff8			; 
9ff8			;	if DEBUG_FORTH_WORDS 
9ff8			;		DMARK "EX7" 
9ff8			;		CALLMONITOR 
9ff8			;	endif 
9ff8			;	NEXTW 
9ff8			 
9ff8			;.STKEXEC: 
9ff8			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9ff8			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9ff8			; 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS_KEY 
9ff8			;			DMARK "STX" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			;	FORTH_DSP_VALUEHL 
9ff8			; 
9ff8			;	ld (store_tmp1), hl    ; count 
9ff8			; 
9ff8			;	FORTH_DSP_POP 
9ff8			;.stkexec1: 
9ff8			;	ld hl, (store_tmp1)   ; count 
9ff8			;	ld a, 0 
9ff8			;	cp l 
9ff8			;	ret z 
9ff8			; 
9ff8			;	dec hl 
9ff8			;	ld (store_tmp1), hl    ; count 
9ff8			;	 
9ff8			;	FORTH_DSP_VALUEHL 
9ff8			;	push hl 
9ff8			;	 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EXp" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	FORTH_DSP_POP 
9ff8			; 
9ff8			;	call strlenz 
9ff8			;	inc hl   ; include zero term to copy 
9ff8			;	inc hl   ; include zero term to copy 
9ff8			;	inc hl   ; include zero term to copy 
9ff8			;	ld b,0 
9ff8			;	ld c,l 
9ff8			;	pop hl 
9ff8			;	ld de, execscratch 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EX3" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	ldir 
9ff8			; 
9ff8			; 
9ff8			;	ld hl, execscratch 
9ff8			; 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EXP" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			; 
9ff8			;	call forthparse 
9ff8			;	ld hl, execscratch 
9ff8			;		if DEBUG_FORTH_WORDS 
9ff8			;			DMARK "EXx" 
9ff8			;			CALLMONITOR 
9ff8			;		endif 
9ff8			;	call forthexec 
9ff8			; 
9ff8			;	jp .stkexec1 
9ff8			; 
9ff8			;	ret 
9ff8			 
9ff8			 
9ff8			.DUP: 
9ff8			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9ff8 17				db WORD_SYS_CORE+OPCODE_DUP             
9ff9 6e a0			dw .ZDUP            
9ffb 04				db 3 + 1 
9ffc .. 00			db "DUP",0              
a000				endm 
# End of macro CWHEAD
a000			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a000			 
a000				if DEBUG_FORTH_WORDS_KEY 
a000					DMARK "DUP" 
a000 f5				push af  
a001 3a 15 a0			ld a, (.dmark)  
a004 32 65 ee			ld (debug_mark),a  
a007 3a 16 a0			ld a, (.dmark+1)  
a00a 32 66 ee			ld (debug_mark+1),a  
a00d 3a 17 a0			ld a, (.dmark+2)  
a010 32 67 ee			ld (debug_mark+2),a  
a013 18 03			jr .pastdmark  
a015 ..			.dmark: db "DUP"  
a018 f1			.pastdmark: pop af  
a019			endm  
# End of macro DMARK
a019					CALLMONITOR 
a019 cd 6f ee			call debug_vector  
a01c				endm  
# End of macro CALLMONITOR
a01c				endif 
a01c			 
a01c				FORTH_DSP 
a01c cd 50 9c			call macro_forth_dsp 
a01f				endm 
# End of macro FORTH_DSP
a01f			 
a01f 7e				ld a, (HL) 
a020 fe 01			cp DS_TYPE_STR 
a022 20 25			jr nz, .dupinum 
a024			 
a024				; push another string 
a024			 
a024				FORTH_DSP_VALUEHL     		 
a024 cd 8a 9c			call macro_dsp_valuehl 
a027				endm 
# End of macro FORTH_DSP_VALUEHL
a027			 
a027			if DEBUG_FORTH_WORDS 
a027				DMARK "DUs" 
a027 f5				push af  
a028 3a 3c a0			ld a, (.dmark)  
a02b 32 65 ee			ld (debug_mark),a  
a02e 3a 3d a0			ld a, (.dmark+1)  
a031 32 66 ee			ld (debug_mark+1),a  
a034 3a 3e a0			ld a, (.dmark+2)  
a037 32 67 ee			ld (debug_mark+2),a  
a03a 18 03			jr .pastdmark  
a03c ..			.dmark: db "DUs"  
a03f f1			.pastdmark: pop af  
a040			endm  
# End of macro DMARK
a040				CALLMONITOR 
a040 cd 6f ee			call debug_vector  
a043				endm  
# End of macro CALLMONITOR
a043			endif 
a043 cd f3 9a			call forth_push_str 
a046			 
a046				NEXTW 
a046 c3 75 9e			jp macro_next 
a049				endm 
# End of macro NEXTW
a049			 
a049			 
a049			.dupinum: 
a049				 
a049			 
a049			 
a049				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a049 cd 8a 9c			call macro_dsp_valuehl 
a04c				endm 
# End of macro FORTH_DSP_VALUEHL
a04c			 
a04c			; TODO add floating point number detection 
a04c			 
a04c			if DEBUG_FORTH_WORDS 
a04c				DMARK "DUi" 
a04c f5				push af  
a04d 3a 61 a0			ld a, (.dmark)  
a050 32 65 ee			ld (debug_mark),a  
a053 3a 62 a0			ld a, (.dmark+1)  
a056 32 66 ee			ld (debug_mark+1),a  
a059 3a 63 a0			ld a, (.dmark+2)  
a05c 32 67 ee			ld (debug_mark+2),a  
a05f 18 03			jr .pastdmark  
a061 ..			.dmark: db "DUi"  
a064 f1			.pastdmark: pop af  
a065			endm  
# End of macro DMARK
a065				CALLMONITOR 
a065 cd 6f ee			call debug_vector  
a068				endm  
# End of macro CALLMONITOR
a068			endif 
a068			 
a068 cd 85 9a			call forth_push_numhl 
a06b				NEXTW 
a06b c3 75 9e			jp macro_next 
a06e				endm 
# End of macro NEXTW
a06e			.ZDUP: 
a06e			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a06e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a06f a6 a0			dw .DMRK            
a071 05				db 4 + 1 
a072 .. 00			db "?DUP",0              
a077				endm 
# End of macro CWHEAD
a077			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
a077			 
a077				if DEBUG_FORTH_WORDS_KEY 
a077					DMARK "qDU" 
a077 f5				push af  
a078 3a 8c a0			ld a, (.dmark)  
a07b 32 65 ee			ld (debug_mark),a  
a07e 3a 8d a0			ld a, (.dmark+1)  
a081 32 66 ee			ld (debug_mark+1),a  
a084 3a 8e a0			ld a, (.dmark+2)  
a087 32 67 ee			ld (debug_mark+2),a  
a08a 18 03			jr .pastdmark  
a08c ..			.dmark: db "qDU"  
a08f f1			.pastdmark: pop af  
a090			endm  
# End of macro DMARK
a090					CALLMONITOR 
a090 cd 6f ee			call debug_vector  
a093				endm  
# End of macro CALLMONITOR
a093				endif 
a093				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a093 cd 8a 9c			call macro_dsp_valuehl 
a096				endm 
# End of macro FORTH_DSP_VALUEHL
a096			 
a096 e5				push hl 
a097			 
a097				; is it a zero? 
a097			 
a097 3e 00			ld a, 0 
a099 84				add h 
a09a 85				add l 
a09b			 
a09b e1				pop hl 
a09c			 
a09c fe 00			cp 0 
a09e 28 03			jr z, .dup2orig 
a0a0			 
a0a0			 
a0a0 cd 85 9a			call forth_push_numhl 
a0a3			 
a0a3			 
a0a3			; TODO add floating point number detection 
a0a3			 
a0a3			.dup2orig: 
a0a3			 
a0a3				NEXTW 
a0a3 c3 75 9e			jp macro_next 
a0a6				endm 
# End of macro NEXTW
a0a6			.DMRK: 
a0a6			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
a0a6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0a7 e3 a0			dw .LSHIFT            
a0a9 06				db 5 + 1 
a0aa .. 00			db "DMARK",0              
a0b0				endm 
# End of macro CWHEAD
a0b0			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
a0b0			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
a0b0				if DEBUG_FORTH_WORDS_KEY 
a0b0					DMARK "DMK" 
a0b0 f5				push af  
a0b1 3a c5 a0			ld a, (.dmark)  
a0b4 32 65 ee			ld (debug_mark),a  
a0b7 3a c6 a0			ld a, (.dmark+1)  
a0ba 32 66 ee			ld (debug_mark+1),a  
a0bd 3a c7 a0			ld a, (.dmark+2)  
a0c0 32 67 ee			ld (debug_mark+2),a  
a0c3 18 03			jr .pastdmark  
a0c5 ..			.dmark: db "DMK"  
a0c8 f1			.pastdmark: pop af  
a0c9			endm  
# End of macro DMARK
a0c9					CALLMONITOR 
a0c9 cd 6f ee			call debug_vector  
a0cc				endm  
# End of macro CALLMONITOR
a0cc				endif 
a0cc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0cc cd 8a 9c			call macro_dsp_valuehl 
a0cf				endm 
# End of macro FORTH_DSP_VALUEHL
a0cf			 
a0cf 7e				ld a, (hl) 
a0d0 32 65 ee			ld (debug_mark),a 
a0d3 23				inc hl 
a0d4 7e				ld a, (hl) 
a0d5 32 66 ee			ld (debug_mark+1),a 
a0d8 23				inc hl 
a0d9 7e				ld a, (hl) 
a0da 32 67 ee			ld (debug_mark+2),a 
a0dd			 
a0dd			 
a0dd				FORTH_DSP_POP 
a0dd cd 42 9d			call macro_forth_dsp_pop 
a0e0				endm 
# End of macro FORTH_DSP_POP
a0e0				NEXTW 
a0e0 c3 75 9e			jp macro_next 
a0e3				endm 
# End of macro NEXTW
a0e3			.LSHIFT: 
a0e3			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
a0e3 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0e4 17 a1			dw .RSHIFT            
a0e6 07				db 6 + 1 
a0e7 .. 00			db "LSHIFT",0              
a0ee				endm 
# End of macro CWHEAD
a0ee			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
a0ee				if DEBUG_FORTH_WORDS_KEY 
a0ee					DMARK "LSH" 
a0ee f5				push af  
a0ef 3a 03 a1			ld a, (.dmark)  
a0f2 32 65 ee			ld (debug_mark),a  
a0f5 3a 04 a1			ld a, (.dmark+1)  
a0f8 32 66 ee			ld (debug_mark+1),a  
a0fb 3a 05 a1			ld a, (.dmark+2)  
a0fe 32 67 ee			ld (debug_mark+2),a  
a101 18 03			jr .pastdmark  
a103 ..			.dmark: db "LSH"  
a106 f1			.pastdmark: pop af  
a107			endm  
# End of macro DMARK
a107					CALLMONITOR 
a107 cd 6f ee			call debug_vector  
a10a				endm  
# End of macro CALLMONITOR
a10a				endif 
a10a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a10a cd 8a 9c			call macro_dsp_valuehl 
a10d				endm 
# End of macro FORTH_DSP_VALUEHL
a10d				FORTH_DSP_POP 
a10d cd 42 9d			call macro_forth_dsp_pop 
a110				endm 
# End of macro FORTH_DSP_POP
a110			 
a110 29				add hl, hl 
a111 cd 85 9a			call forth_push_numhl 
a114				NEXTW 
a114 c3 75 9e			jp macro_next 
a117				endm 
# End of macro NEXTW
a117			.RSHIFT: 
a117			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
a117 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a118 4e a1			dw .SWAP            
a11a 07				db 6 + 1 
a11b .. 00			db "RSHIFT",0              
a122				endm 
# End of macro CWHEAD
a122			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
a122				if DEBUG_FORTH_WORDS_KEY 
a122					DMARK "RSH" 
a122 f5				push af  
a123 3a 37 a1			ld a, (.dmark)  
a126 32 65 ee			ld (debug_mark),a  
a129 3a 38 a1			ld a, (.dmark+1)  
a12c 32 66 ee			ld (debug_mark+1),a  
a12f 3a 39 a1			ld a, (.dmark+2)  
a132 32 67 ee			ld (debug_mark+2),a  
a135 18 03			jr .pastdmark  
a137 ..			.dmark: db "RSH"  
a13a f1			.pastdmark: pop af  
a13b			endm  
# End of macro DMARK
a13b					CALLMONITOR 
a13b cd 6f ee			call debug_vector  
a13e				endm  
# End of macro CALLMONITOR
a13e				endif 
a13e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a13e cd 8a 9c			call macro_dsp_valuehl 
a141				endm 
# End of macro FORTH_DSP_VALUEHL
a141				FORTH_DSP_POP 
a141 cd 42 9d			call macro_forth_dsp_pop 
a144				endm 
# End of macro FORTH_DSP_POP
a144 cb 3c			srl h 
a146 cb 1d			rr l 
a148 cd 85 9a			call forth_push_numhl 
a14b				NEXTW 
a14b c3 75 9e			jp macro_next 
a14e				endm 
# End of macro NEXTW
a14e			.SWAP: 
a14e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a14e 18				db WORD_SYS_CORE+OPCODE_SWAP             
a14f a2 a1			dw .COLN            
a151 05				db 4 + 1 
a152 .. 00			db "SWAP",0              
a157				endm 
# End of macro CWHEAD
a157			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a157				if DEBUG_FORTH_WORDS_KEY 
a157					DMARK "SWP" 
a157 f5				push af  
a158 3a 6c a1			ld a, (.dmark)  
a15b 32 65 ee			ld (debug_mark),a  
a15e 3a 6d a1			ld a, (.dmark+1)  
a161 32 66 ee			ld (debug_mark+1),a  
a164 3a 6e a1			ld a, (.dmark+2)  
a167 32 67 ee			ld (debug_mark+2),a  
a16a 18 03			jr .pastdmark  
a16c ..			.dmark: db "SWP"  
a16f f1			.pastdmark: pop af  
a170			endm  
# End of macro DMARK
a170					CALLMONITOR 
a170 cd 6f ee			call debug_vector  
a173				endm  
# End of macro CALLMONITOR
a173				endif 
a173			 
a173			; DONE Use os stack swap memory 
a173			 
a173				FORTH_DSP_PTR 0     ; TOS 
a173 2a e8 e9			ld hl,(cli_data_sp) 
a176 11 00 00			ld de, 0 * 3 
a179 ed 52			sbc hl, de 
a17b				endm 
# End of macro FORTH_DSP_PTR
a17b cd c1 9d			call hltostack1 
a17e			  
a17e				FORTH_DSP_PTR 1     ; TOS 
a17e 2a e8 e9			ld hl,(cli_data_sp) 
a181 11 03 00			ld de, 1 * 3 
a184 ed 52			sbc hl, de 
a186				endm 
# End of macro FORTH_DSP_PTR
a186 cd c7 9d			call hltostack2 
a189			 
a189				FORTH_DSP_PTR 0     ; TOS 
a189 2a e8 e9			ld hl,(cli_data_sp) 
a18c 11 00 00			ld de, 0 * 3 
a18f ed 52			sbc hl, de 
a191				endm 
# End of macro FORTH_DSP_PTR
a191 cd df 9d			call hlfromstack2 
a194			 
a194				FORTH_DSP_PTR 1     ; TOS 
a194 2a e8 e9			ld hl,(cli_data_sp) 
a197 11 03 00			ld de, 1 * 3 
a19a ed 52			sbc hl, de 
a19c				endm 
# End of macro FORTH_DSP_PTR
a19c cd d9 9d			call hlfromstack1 
a19f			;	FORTH_DSP_VALUEHL 
a19f			;	push hl     ; w2 
a19f			; 
a19f			;	FORTH_DSP_POP 
a19f			; 
a19f			;	FORTH_DSP_VALUEHL 
a19f			; 
a19f			;	FORTH_DSP_POP 
a19f			; 
a19f			;	pop de     ; w2	, hl = w1 
a19f			; 
a19f			;	ex de, hl 
a19f			;	push de 
a19f			; 
a19f			;	call forth_push_numhl 
a19f			; 
a19f			;	pop hl 
a19f			; 
a19f			;	call forth_push_numhl 
a19f				 
a19f			 
a19f				NEXTW 
a19f c3 75 9e			jp macro_next 
a1a2				endm 
# End of macro NEXTW
a1a2			.COLN: 
a1a2			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a1a2 19				db WORD_SYS_CORE+OPCODE_COLN             
a1a3 2e a3			dw .SCOLN            
a1a5 02				db 1 + 1 
a1a6 .. 00			db ":",0              
a1a8				endm 
# End of macro CWHEAD
a1a8			; | : ( -- )         Create new word | DONE 
a1a8			 
a1a8				if DEBUG_FORTH_WORDS_KEY 
a1a8					DMARK "CLN" 
a1a8 f5				push af  
a1a9 3a bd a1			ld a, (.dmark)  
a1ac 32 65 ee			ld (debug_mark),a  
a1af 3a be a1			ld a, (.dmark+1)  
a1b2 32 66 ee			ld (debug_mark+1),a  
a1b5 3a bf a1			ld a, (.dmark+2)  
a1b8 32 67 ee			ld (debug_mark+2),a  
a1bb 18 03			jr .pastdmark  
a1bd ..			.dmark: db "CLN"  
a1c0 f1			.pastdmark: pop af  
a1c1			endm  
# End of macro DMARK
a1c1					CALLMONITOR 
a1c1 cd 6f ee			call debug_vector  
a1c4				endm  
# End of macro CALLMONITOR
a1c4				endif 
a1c4			STACKFRAME OFF $8efe $989f 
a1c4				if DEBUG_STACK_IMB 
a1c4					if OFF 
a1c4						exx 
a1c4						ld de, $8efe 
a1c4						ld a, d 
a1c4						ld hl, curframe 
a1c4						call hexout 
a1c4						ld a, e 
a1c4						ld hl, curframe+2 
a1c4						call hexout 
a1c4						ld hl, $8efe 
a1c4						push hl 
a1c4						ld hl, $989f 
a1c4						push hl 
a1c4						exx 
a1c4					endif 
a1c4				endif 
a1c4			endm 
# End of macro STACKFRAME
a1c4			; get parser buffer length  of new word 
a1c4			 
a1c4			 
a1c4			 
a1c4				; move tok past this to start of name defintition 
a1c4				; TODO get word to define 
a1c4				; TODO Move past word token 
a1c4				; TODO get length of string up to the ';' 
a1c4			 
a1c4 2a bc e5		ld hl, (os_tok_ptr) 
a1c7 23			inc hl 
a1c8 23			inc hl 
a1c9			 
a1c9 3e 3b		ld a, ';' 
a1cb cd 5b 90		call strlent 
a1ce			 
a1ce 7d			ld a,l 
a1cf 32 ab e2		ld (os_new_parse_len), a 
a1d2			 
a1d2			 
a1d2			if DEBUG_FORTH_UWORD 
a1d2 ed 5b bc e5	ld de, (os_tok_ptr) 
a1d6					DMARK ":01" 
a1d6 f5				push af  
a1d7 3a eb a1			ld a, (.dmark)  
a1da 32 65 ee			ld (debug_mark),a  
a1dd 3a ec a1			ld a, (.dmark+1)  
a1e0 32 66 ee			ld (debug_mark+1),a  
a1e3 3a ed a1			ld a, (.dmark+2)  
a1e6 32 67 ee			ld (debug_mark+2),a  
a1e9 18 03			jr .pastdmark  
a1eb ..			.dmark: db ":01"  
a1ee f1			.pastdmark: pop af  
a1ef			endm  
# End of macro DMARK
a1ef			CALLMONITOR 
a1ef cd 6f ee			call debug_vector  
a1f2				endm  
# End of macro CALLMONITOR
a1f2			endif 
a1f2			 
a1f2			; 
a1f2			;  new word memory layout: 
a1f2			;  
a1f2			;    : adg 6666 ;  
a1f2			; 
a1f2			;    db   1     ; user defined word  
a1f2 23			inc hl    
a1f3			;    dw   sysdict 
a1f3 23			inc hl 
a1f4 23			inc hl 
a1f5			;    db <word len>+1 (for null) 
a1f5 23			inc hl 
a1f6			;    db .... <word> 
a1f6			; 
a1f6			 
a1f6 23			inc hl    ; some extras for the word preamble before the above 
a1f7 23			inc hl 
a1f8 23			inc hl 
a1f9 23			inc hl 
a1fa 23			inc hl 
a1fb 23			inc hl 
a1fc 23			inc hl  
a1fd 23			inc hl 
a1fe 23			inc hl 
a1ff 23			inc hl 
a200 23			inc hl 
a201 23			inc hl 
a202 23			inc hl 
a203 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a204			;       exec word buffer 
a204			;	<ptr word>   
a204 23			inc hl 
a205 23			inc hl 
a206			;       <word list><null term> 7F final term 
a206			 
a206			 
a206			if DEBUG_FORTH_UWORD 
a206					DMARK ":02" 
a206 f5				push af  
a207 3a 1b a2			ld a, (.dmark)  
a20a 32 65 ee			ld (debug_mark),a  
a20d 3a 1c a2			ld a, (.dmark+1)  
a210 32 66 ee			ld (debug_mark+1),a  
a213 3a 1d a2			ld a, (.dmark+2)  
a216 32 67 ee			ld (debug_mark+2),a  
a219 18 03			jr .pastdmark  
a21b ..			.dmark: db ":02"  
a21e f1			.pastdmark: pop af  
a21f			endm  
# End of macro DMARK
a21f			CALLMONITOR 
a21f cd 6f ee			call debug_vector  
a222				endm  
# End of macro CALLMONITOR
a222			endif 
a222			 
a222			 
a222				; malloc the size 
a222			 
a222 cd c5 90			call malloc 
a225 22 ad e2			ld (os_new_malloc), hl     ; save malloc start 
a228			 
a228			;    db   1     ; user defined word  
a228 3e 01			ld a, WORD_SYS_UWORD  
a22a 77				ld (hl), a 
a22b			 
a22b 23			inc hl    
a22c			;    dw   sysdict 
a22c 11 b9 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a22f 73			ld (hl), e 
a230 23			inc hl 
a231 72			ld (hl), d 
a232 23			inc hl 
a233			 
a233			 
a233			;    Setup dict word 
a233			 
a233 23			inc hl 
a234 22 a7 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a237			 
a237			; 1. get length of dict word 
a237			 
a237			 
a237 2a bc e5		ld hl, (os_tok_ptr) 
a23a 23			inc hl 
a23b 23			inc hl    ; position to start of dict word 
a23c 3e 00		ld a, 0 
a23e cd 5b 90		call strlent 
a241			 
a241			 
a241 23			inc hl    ; to include null??? 
a242			 
a242			; write length of dict word 
a242			 
a242 ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a246 1b			dec de 
a247 eb			ex de, hl 
a248 73			ld (hl), e 
a249 eb			ex de, hl 
a24a			 
a24a			 
a24a			 
a24a			; copy  
a24a 4d			ld c, l 
a24b 06 00		ld b, 0 
a24d ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a251 2a bc e5		ld hl, (os_tok_ptr) 
a254 23			inc hl 
a255 23			inc hl    ; position to start of dict word 
a256			 
a256			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a256			 
a256			; TODO need to convert word to upper case 
a256			 
a256			ucasetok:	 
a256 7e			ld a,(hl) 
a257 cd 47 90		call toUpper 
a25a 77			ld (hl),a 
a25b ed a0		ldi 
a25d f2 56 a2		jp p, ucasetok 
a260			 
a260			 
a260			 
a260			; de now points to start of where the word body code should be placed 
a260 ed 53 a7 e2	ld (os_new_work_ptr), de 
a264			; hl now points to the words to throw at forthexec which needs to be copied 
a264 22 a5 e2		ld (os_new_src_ptr), hl 
a267			 
a267			; TODO add 'call to forthexec' 
a267			 
a267			if DEBUG_FORTH_UWORD 
a267 c5			push bc 
a268 ed 4b ad e2	ld bc, (os_new_malloc) 
a26c					DMARK ":0x" 
a26c f5				push af  
a26d 3a 81 a2			ld a, (.dmark)  
a270 32 65 ee			ld (debug_mark),a  
a273 3a 82 a2			ld a, (.dmark+1)  
a276 32 66 ee			ld (debug_mark+1),a  
a279 3a 83 a2			ld a, (.dmark+2)  
a27c 32 67 ee			ld (debug_mark+2),a  
a27f 18 03			jr .pastdmark  
a281 ..			.dmark: db ":0x"  
a284 f1			.pastdmark: pop af  
a285			endm  
# End of macro DMARK
a285			CALLMONITOR 
a285 cd 6f ee			call debug_vector  
a288				endm  
# End of macro CALLMONITOR
a288 c1			pop bc 
a289			endif 
a289			 
a289			 
a289			; create word preamble which should be: 
a289			 
a289			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a289			 
a289			;    ld hl, <word code> 
a289			;    jp user_exec 
a289			;    <word code bytes> 
a289			 
a289			 
a289			;	inc de     ; TODO ??? or are we already past the word's null 
a289 eb			ex de, hl 
a28a			 
a28a 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a28c			 
a28c 23			inc hl 
a28d 22 a1 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a290 23			inc hl 
a291			 
a291 23			inc hl 
a292 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a294			 
a294 01 9b d0		ld bc, user_exec 
a297 23			inc hl 
a298 71			ld (hl), c     ; poke address of user_exec 
a299 23			inc hl 
a29a 70			ld (hl), b     
a29b			; 
a29b			;	inc hl 
a29b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a29b			; 
a29b			; 
a29b			;	ld bc, macro_forth_rsp_next 
a29b			;	inc hl 
a29b			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a29b			;	inc hl 
a29b			;	ld (hl), b     
a29b			; 
a29b			;	inc hl 
a29b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a29b			; 
a29b			; 
a29b			;	inc hl 
a29b			;	ld bc, forthexec 
a29b			;	ld (hl), c     ; poke address of forthexec 
a29b			;	inc hl 
a29b			;	ld (hl), b      
a29b			; 
a29b			;	inc hl 
a29b			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a29b			; 
a29b			;	ld bc, user_dict_next 
a29b			;	inc hl 
a29b			;	ld (hl), c     ; poke address of forthexec 
a29b			;	inc hl 
a29b			;	ld (hl), b      
a29b			 
a29b			; hl is now where we need to copy the word byte data to save this 
a29b			 
a29b 23			inc hl 
a29c 22 a3 e2		ld (os_new_exec), hl 
a29f			 
a29f			; copy definition 
a29f			 
a29f eb			ex de, hl 
a2a0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a2a0			;	inc de    ; skip the PC for this parse 
a2a0 3a ab e2		ld a, (os_new_parse_len) 
a2a3 4f			ld c, a 
a2a4 06 00		ld b, 0 
a2a6 ed b0		ldir		 ; copy defintion 
a2a8			 
a2a8			 
a2a8			; poke the address of where the new word bytes live for forthexec 
a2a8			 
a2a8 2a a1 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a2ab			 
a2ab ed 5b a3 e2	ld de, (os_new_exec)      
a2af			 
a2af 73			ld (hl), e 
a2b0 23			inc hl 
a2b1 72			ld (hl), d 
a2b2			 
a2b2				; TODO copy last user dict word next link to this word 
a2b2				; TODO update last user dict word to point to this word 
a2b2			; 
a2b2			; hl f923 de 812a ; bc 811a 
a2b2			 
a2b2			if DEBUG_FORTH_UWORD 
a2b2 c5			push bc 
a2b3 ed 4b ad e2	ld bc, (os_new_malloc) 
a2b7					DMARK ":0A" 
a2b7 f5				push af  
a2b8 3a cc a2			ld a, (.dmark)  
a2bb 32 65 ee			ld (debug_mark),a  
a2be 3a cd a2			ld a, (.dmark+1)  
a2c1 32 66 ee			ld (debug_mark+1),a  
a2c4 3a ce a2			ld a, (.dmark+2)  
a2c7 32 67 ee			ld (debug_mark+2),a  
a2ca 18 03			jr .pastdmark  
a2cc ..			.dmark: db ":0A"  
a2cf f1			.pastdmark: pop af  
a2d0			endm  
# End of macro DMARK
a2d0			CALLMONITOR 
a2d0 cd 6f ee			call debug_vector  
a2d3				endm  
# End of macro CALLMONITOR
a2d3 c1			pop bc 
a2d4			endif 
a2d4			if DEBUG_FORTH_UWORD 
a2d4 c5			push bc 
a2d5 ed 4b ad e2	ld bc, (os_new_malloc) 
a2d9 03			inc bc 
a2da 03			inc bc 
a2db 03			inc bc 
a2dc 03			inc bc 
a2dd 03			inc bc 
a2de 03			inc bc 
a2df 03			inc bc 
a2e0 03			inc bc 
a2e1			 
a2e1					DMARK ":0B" 
a2e1 f5				push af  
a2e2 3a f6 a2			ld a, (.dmark)  
a2e5 32 65 ee			ld (debug_mark),a  
a2e8 3a f7 a2			ld a, (.dmark+1)  
a2eb 32 66 ee			ld (debug_mark+1),a  
a2ee 3a f8 a2			ld a, (.dmark+2)  
a2f1 32 67 ee			ld (debug_mark+2),a  
a2f4 18 03			jr .pastdmark  
a2f6 ..			.dmark: db ":0B"  
a2f9 f1			.pastdmark: pop af  
a2fa			endm  
# End of macro DMARK
a2fa			CALLMONITOR 
a2fa cd 6f ee			call debug_vector  
a2fd				endm  
# End of macro CALLMONITOR
a2fd c1			pop bc 
a2fe			endif 
a2fe			 
a2fe			; update word dict linked list for new word 
a2fe			 
a2fe			 
a2fe 2a b8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a301 23			inc hl     ; move to next work linked list ptr 
a302			 
a302 ed 5b ad e2	ld de, (os_new_malloc)		 ; new next word 
a306 73			ld (hl), e 
a307 23			inc hl 
a308 72			ld (hl), d 
a309			 
a309			if DEBUG_FORTH_UWORD 
a309 ed 4b b8 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a30d			endif 
a30d			 
a30d ed 53 b8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a311			 
a311			 
a311			if DEBUG_FORTH_UWORD 
a311					DMARK ":0+" 
a311 f5				push af  
a312 3a 26 a3			ld a, (.dmark)  
a315 32 65 ee			ld (debug_mark),a  
a318 3a 27 a3			ld a, (.dmark+1)  
a31b 32 66 ee			ld (debug_mark+1),a  
a31e 3a 28 a3			ld a, (.dmark+2)  
a321 32 67 ee			ld (debug_mark+2),a  
a324 18 03			jr .pastdmark  
a326 ..			.dmark: db ":0+"  
a329 f1			.pastdmark: pop af  
a32a			endm  
# End of macro DMARK
a32a			CALLMONITOR 
a32a cd 6f ee			call debug_vector  
a32d				endm  
# End of macro CALLMONITOR
a32d			endif 
a32d			 
a32d			STACKFRAMECHK OFF $8efe $989f 
a32d				if DEBUG_STACK_IMB 
a32d					if OFF 
a32d						exx 
a32d						ld hl, $989f 
a32d						pop de   ; $989f 
a32d						call cmp16 
a32d						jr nz, .spnosame 
a32d						ld hl, $8efe 
a32d						pop de   ; $8efe 
a32d						call cmp16 
a32d						jr z, .spfrsame 
a32d						.spnosame: call showsperror 
a32d						.spfrsame: nop 
a32d						exx 
a32d					endif 
a32d				endif 
a32d			endm 
# End of macro STACKFRAMECHK
a32d			 
a32d c9			ret    ; dont process any remaining parser tokens as they form new word 
a32e			 
a32e			 
a32e			 
a32e			 
a32e			;		NEXT 
a32e			.SCOLN: 
a32e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a32e 06			db OPCODE_SCOLN 
a32f 7a a3		dw .DROP 
a331 02			db 2 
a332 .. 00		db ";",0           
a334			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a334				if DEBUG_FORTH_WORDS_KEY 
a334					DMARK "SCN" 
a334 f5				push af  
a335 3a 49 a3			ld a, (.dmark)  
a338 32 65 ee			ld (debug_mark),a  
a33b 3a 4a a3			ld a, (.dmark+1)  
a33e 32 66 ee			ld (debug_mark+1),a  
a341 3a 4b a3			ld a, (.dmark+2)  
a344 32 67 ee			ld (debug_mark+2),a  
a347 18 03			jr .pastdmark  
a349 ..			.dmark: db "SCN"  
a34c f1			.pastdmark: pop af  
a34d			endm  
# End of macro DMARK
a34d					CALLMONITOR 
a34d cd 6f ee			call debug_vector  
a350				endm  
# End of macro CALLMONITOR
a350				endif 
a350				FORTH_RSP_TOS 
a350 cd 43 9a			call macro_forth_rsp_tos 
a353				endm 
# End of macro FORTH_RSP_TOS
a353 e5				push hl 
a354				FORTH_RSP_POP 
a354 cd 4d 9a			call macro_forth_rsp_pop 
a357				endm 
# End of macro FORTH_RSP_POP
a357 e1				pop hl 
a358			;		ex de,hl 
a358 22 bc e5			ld (os_tok_ptr),hl 
a35b			 
a35b			if DEBUG_FORTH_UWORD 
a35b					DMARK "SCL" 
a35b f5				push af  
a35c 3a 70 a3			ld a, (.dmark)  
a35f 32 65 ee			ld (debug_mark),a  
a362 3a 71 a3			ld a, (.dmark+1)  
a365 32 66 ee			ld (debug_mark+1),a  
a368 3a 72 a3			ld a, (.dmark+2)  
a36b 32 67 ee			ld (debug_mark+2),a  
a36e 18 03			jr .pastdmark  
a370 ..			.dmark: db "SCL"  
a373 f1			.pastdmark: pop af  
a374			endm  
# End of macro DMARK
a374			CALLMONITOR 
a374 cd 6f ee			call debug_vector  
a377				endm  
# End of macro CALLMONITOR
a377			endif 
a377				NEXTW 
a377 c3 75 9e			jp macro_next 
a37a				endm 
# End of macro NEXTW
a37a			 
a37a			.DROP: 
a37a			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a37a 1b				db WORD_SYS_CORE+OPCODE_DROP             
a37b a5 a3			dw .DUP2            
a37d 05				db 4 + 1 
a37e .. 00			db "DROP",0              
a383				endm 
# End of macro CWHEAD
a383			; | DROP ( w -- )   drop the TOS item   | DONE 
a383				if DEBUG_FORTH_WORDS_KEY 
a383					DMARK "DRP" 
a383 f5				push af  
a384 3a 98 a3			ld a, (.dmark)  
a387 32 65 ee			ld (debug_mark),a  
a38a 3a 99 a3			ld a, (.dmark+1)  
a38d 32 66 ee			ld (debug_mark+1),a  
a390 3a 9a a3			ld a, (.dmark+2)  
a393 32 67 ee			ld (debug_mark+2),a  
a396 18 03			jr .pastdmark  
a398 ..			.dmark: db "DRP"  
a39b f1			.pastdmark: pop af  
a39c			endm  
# End of macro DMARK
a39c					CALLMONITOR 
a39c cd 6f ee			call debug_vector  
a39f				endm  
# End of macro CALLMONITOR
a39f				endif 
a39f				FORTH_DSP_POP 
a39f cd 42 9d			call macro_forth_dsp_pop 
a3a2				endm 
# End of macro FORTH_DSP_POP
a3a2				NEXTW 
a3a2 c3 75 9e			jp macro_next 
a3a5				endm 
# End of macro NEXTW
a3a5			.DUP2: 
a3a5			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a3a5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a3a6 ea a3			dw .DROP2            
a3a8 05				db 4 + 1 
a3a9 .. 00			db "2DUP",0              
a3ae				endm 
# End of macro CWHEAD
a3ae			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a3ae				if DEBUG_FORTH_WORDS_KEY 
a3ae					DMARK "2DU" 
a3ae f5				push af  
a3af 3a c3 a3			ld a, (.dmark)  
a3b2 32 65 ee			ld (debug_mark),a  
a3b5 3a c4 a3			ld a, (.dmark+1)  
a3b8 32 66 ee			ld (debug_mark+1),a  
a3bb 3a c5 a3			ld a, (.dmark+2)  
a3be 32 67 ee			ld (debug_mark+2),a  
a3c1 18 03			jr .pastdmark  
a3c3 ..			.dmark: db "2DU"  
a3c6 f1			.pastdmark: pop af  
a3c7			endm  
# End of macro DMARK
a3c7					CALLMONITOR 
a3c7 cd 6f ee			call debug_vector  
a3ca				endm  
# End of macro CALLMONITOR
a3ca				endif 
a3ca				FORTH_DSP_VALUEHL 
a3ca cd 8a 9c			call macro_dsp_valuehl 
a3cd				endm 
# End of macro FORTH_DSP_VALUEHL
a3cd e5				push hl      ; 2 
a3ce			 
a3ce				FORTH_DSP_POP 
a3ce cd 42 9d			call macro_forth_dsp_pop 
a3d1				endm 
# End of macro FORTH_DSP_POP
a3d1				 
a3d1				FORTH_DSP_VALUEHL 
a3d1 cd 8a 9c			call macro_dsp_valuehl 
a3d4				endm 
# End of macro FORTH_DSP_VALUEHL
a3d4			;		push hl      ; 1 
a3d4			 
a3d4				FORTH_DSP_POP 
a3d4 cd 42 9d			call macro_forth_dsp_pop 
a3d7				endm 
# End of macro FORTH_DSP_POP
a3d7			 
a3d7			;		pop hl       ; 1 
a3d7 d1				pop de       ; 2 
a3d8			 
a3d8 cd 85 9a			call forth_push_numhl 
a3db eb				ex de, hl 
a3dc cd 85 9a			call forth_push_numhl 
a3df			 
a3df				 
a3df eb				ex de, hl 
a3e0			 
a3e0 cd 85 9a			call forth_push_numhl 
a3e3 eb				ex de, hl 
a3e4 cd 85 9a			call forth_push_numhl 
a3e7			 
a3e7			 
a3e7				NEXTW 
a3e7 c3 75 9e			jp macro_next 
a3ea				endm 
# End of macro NEXTW
a3ea			.DROP2: 
a3ea			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3ea 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3eb 19 a4			dw .PICK            
a3ed 06				db 5 + 1 
a3ee .. 00			db "2DROP",0              
a3f4				endm 
# End of macro CWHEAD
a3f4			; | 2DROP ( w w -- )    Double drop | DONE 
a3f4				if DEBUG_FORTH_WORDS_KEY 
a3f4					DMARK "2DR" 
a3f4 f5				push af  
a3f5 3a 09 a4			ld a, (.dmark)  
a3f8 32 65 ee			ld (debug_mark),a  
a3fb 3a 0a a4			ld a, (.dmark+1)  
a3fe 32 66 ee			ld (debug_mark+1),a  
a401 3a 0b a4			ld a, (.dmark+2)  
a404 32 67 ee			ld (debug_mark+2),a  
a407 18 03			jr .pastdmark  
a409 ..			.dmark: db "2DR"  
a40c f1			.pastdmark: pop af  
a40d			endm  
# End of macro DMARK
a40d					CALLMONITOR 
a40d cd 6f ee			call debug_vector  
a410				endm  
# End of macro CALLMONITOR
a410				endif 
a410				FORTH_DSP_POP 
a410 cd 42 9d			call macro_forth_dsp_pop 
a413				endm 
# End of macro FORTH_DSP_POP
a413				FORTH_DSP_POP 
a413 cd 42 9d			call macro_forth_dsp_pop 
a416				endm 
# End of macro FORTH_DSP_POP
a416				NEXTW 
a416 c3 75 9e			jp macro_next 
a419				endm 
# End of macro NEXTW
a419			.PICK: 
a419			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a419 77				db WORD_SYS_CORE+99             
a41a b3 a4			dw .SWAP2            
a41c 05				db 4 + 1 
a41d .. 00			db "PICK",0              
a422				endm 
# End of macro CWHEAD
a422			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
a422			; | | >[!NOTE] 
a422			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
a422				if DEBUG_FORTH_WORDS_KEY 
a422					DMARK "PIK" 
a422 f5				push af  
a423 3a 37 a4			ld a, (.dmark)  
a426 32 65 ee			ld (debug_mark),a  
a429 3a 38 a4			ld a, (.dmark+1)  
a42c 32 66 ee			ld (debug_mark+1),a  
a42f 3a 39 a4			ld a, (.dmark+2)  
a432 32 67 ee			ld (debug_mark+2),a  
a435 18 03			jr .pastdmark  
a437 ..			.dmark: db "PIK"  
a43a f1			.pastdmark: pop af  
a43b			endm  
# End of macro DMARK
a43b					CALLMONITOR 
a43b cd 6f ee			call debug_vector  
a43e				endm  
# End of macro CALLMONITOR
a43e				endif 
a43e			 
a43e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a43e cd 8a 9c			call macro_dsp_valuehl 
a441				endm 
# End of macro FORTH_DSP_VALUEHL
a441				 
a441				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a441 cd 42 9d			call macro_forth_dsp_pop 
a444				endm 
# End of macro FORTH_DSP_POP
a444			 
a444				; init from TOS 
a444 e5				push hl 
a445				FORTH_DSP 
a445 cd 50 9c			call macro_forth_dsp 
a448				endm 
# End of macro FORTH_DSP
a448			;	ld hl, cli_data_sp 
a448				if DEBUG_FORTH_WORDS 
a448					DMARK "PK1" 
a448 f5				push af  
a449 3a 5d a4			ld a, (.dmark)  
a44c 32 65 ee			ld (debug_mark),a  
a44f 3a 5e a4			ld a, (.dmark+1)  
a452 32 66 ee			ld (debug_mark+1),a  
a455 3a 5f a4			ld a, (.dmark+2)  
a458 32 67 ee			ld (debug_mark+2),a  
a45b 18 03			jr .pastdmark  
a45d ..			.dmark: db "PK1"  
a460 f1			.pastdmark: pop af  
a461			endm  
# End of macro DMARK
a461					CALLMONITOR 
a461 cd 6f ee			call debug_vector  
a464				endm  
# End of macro CALLMONITOR
a464				endif 
a464 c1				pop bc 
a465 41				ld b,c 
a466 3e 00			ld a, 0 
a468 b8				cp b 
a469 28 21			jr z, .pdone	 
a46b			.pkl: 
a46b 2b				dec hl 
a46c 2b				dec hl 
a46d 2b				dec hl 
a46e			 
a46e				if DEBUG_FORTH_WORDS 
a46e					DMARK "PKl" 
a46e f5				push af  
a46f 3a 83 a4			ld a, (.dmark)  
a472 32 65 ee			ld (debug_mark),a  
a475 3a 84 a4			ld a, (.dmark+1)  
a478 32 66 ee			ld (debug_mark+1),a  
a47b 3a 85 a4			ld a, (.dmark+2)  
a47e 32 67 ee			ld (debug_mark+2),a  
a481 18 03			jr .pastdmark  
a483 ..			.dmark: db "PKl"  
a486 f1			.pastdmark: pop af  
a487			endm  
# End of macro DMARK
a487					CALLMONITOR 
a487 cd 6f ee			call debug_vector  
a48a				endm  
# End of macro CALLMONITOR
a48a				endif 
a48a 10 df			djnz .pkl 
a48c			.pdone: 
a48c				 
a48c				; TODO do type check with correct push 
a48c			 
a48c 23				inc hl 
a48d				;call loadwordinhl 
a48d 5e				ld e, (hl) 
a48e 23				inc hl 
a48f 56				ld d, (hl) 
a490 eb				ex de,hl 
a491				if DEBUG_FORTH_WORDS 
a491					DMARK "PKp" 
a491 f5				push af  
a492 3a a6 a4			ld a, (.dmark)  
a495 32 65 ee			ld (debug_mark),a  
a498 3a a7 a4			ld a, (.dmark+1)  
a49b 32 66 ee			ld (debug_mark+1),a  
a49e 3a a8 a4			ld a, (.dmark+2)  
a4a1 32 67 ee			ld (debug_mark+2),a  
a4a4 18 03			jr .pastdmark  
a4a6 ..			.dmark: db "PKp"  
a4a9 f1			.pastdmark: pop af  
a4aa			endm  
# End of macro DMARK
a4aa					CALLMONITOR 
a4aa cd 6f ee			call debug_vector  
a4ad				endm  
# End of macro CALLMONITOR
a4ad				endif 
a4ad cd 85 9a			call forth_push_numhl 
a4b0			 
a4b0				NEXTW 
a4b0 c3 75 9e			jp macro_next 
a4b3				endm 
# End of macro NEXTW
a4b3			.SWAP2: 
a4b3			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a4b3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a4b4 34 a5			dw .AT            
a4b6 06				db 5 + 1 
a4b7 .. 00			db "2SWAP",0              
a4bd				endm 
# End of macro CWHEAD
a4bd			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a4bd				if DEBUG_FORTH_WORDS_KEY 
a4bd					DMARK "2SW" 
a4bd f5				push af  
a4be 3a d2 a4			ld a, (.dmark)  
a4c1 32 65 ee			ld (debug_mark),a  
a4c4 3a d3 a4			ld a, (.dmark+1)  
a4c7 32 66 ee			ld (debug_mark+1),a  
a4ca 3a d4 a4			ld a, (.dmark+2)  
a4cd 32 67 ee			ld (debug_mark+2),a  
a4d0 18 03			jr .pastdmark  
a4d2 ..			.dmark: db "2SW"  
a4d5 f1			.pastdmark: pop af  
a4d6			endm  
# End of macro DMARK
a4d6					CALLMONITOR 
a4d6 cd 6f ee			call debug_vector  
a4d9				endm  
# End of macro CALLMONITOR
a4d9				endif 
a4d9			; TODO Use os stack swap memory 
a4d9			 
a4d9				FORTH_DSP_PTR 0     ; TOS    w4 
a4d9 2a e8 e9			ld hl,(cli_data_sp) 
a4dc 11 00 00			ld de, 0 * 3 
a4df ed 52			sbc hl, de 
a4e1				endm 
# End of macro FORTH_DSP_PTR
a4e1 cd c1 9d			call hltostack1 
a4e4			  
a4e4				FORTH_DSP_PTR 1     ; TOS    w3 
a4e4 2a e8 e9			ld hl,(cli_data_sp) 
a4e7 11 03 00			ld de, 1 * 3 
a4ea ed 52			sbc hl, de 
a4ec				endm 
# End of macro FORTH_DSP_PTR
a4ec cd c7 9d			call hltostack2 
a4ef			 
a4ef			 
a4ef			 
a4ef				FORTH_DSP_PTR 2     ; TOS    w2 
a4ef 2a e8 e9			ld hl,(cli_data_sp) 
a4f2 11 06 00			ld de, 2 * 3 
a4f5 ed 52			sbc hl, de 
a4f7				endm 
# End of macro FORTH_DSP_PTR
a4f7 cd cd 9d			call hltostack3 
a4fa			 
a4fa				FORTH_DSP_PTR 3     ; TOS   w1 
a4fa 2a e8 e9			ld hl,(cli_data_sp) 
a4fd 11 09 00			ld de, 3 * 3 
a500 ed 52			sbc hl, de 
a502				endm 
# End of macro FORTH_DSP_PTR
a502 cd d3 9d			call hltostack4 
a505			 
a505			 
a505			 
a505			 
a505				FORTH_DSP_PTR 0     ; TOS 
a505 2a e8 e9			ld hl,(cli_data_sp) 
a508 11 00 00			ld de, 0 * 3 
a50b ed 52			sbc hl, de 
a50d				endm 
# End of macro FORTH_DSP_PTR
a50d cd e5 9d			call hlfromstack3 
a510			 
a510				FORTH_DSP_PTR 1     ; TOS 
a510 2a e8 e9			ld hl,(cli_data_sp) 
a513 11 03 00			ld de, 1 * 3 
a516 ed 52			sbc hl, de 
a518				endm 
# End of macro FORTH_DSP_PTR
a518 cd eb 9d			call hlfromstack4 
a51b			 
a51b			 
a51b			 
a51b				FORTH_DSP_PTR 2     ; TOS 
a51b 2a e8 e9			ld hl,(cli_data_sp) 
a51e 11 06 00			ld de, 2 * 3 
a521 ed 52			sbc hl, de 
a523				endm 
# End of macro FORTH_DSP_PTR
a523 cd d9 9d			call hlfromstack1 
a526			 
a526				FORTH_DSP_PTR 3     ; TOS 
a526 2a e8 e9			ld hl,(cli_data_sp) 
a529 11 09 00			ld de, 3 * 3 
a52c ed 52			sbc hl, de 
a52e				endm 
# End of macro FORTH_DSP_PTR
a52e cd df 9d			call hlfromstack2 
a531			 
a531				NEXTW 
a531 c3 75 9e			jp macro_next 
a534				endm 
# End of macro NEXTW
a534			.AT: 
a534			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a534 1f				db WORD_SYS_CORE+OPCODE_AT             
a535 66 a5			dw .CAT            
a537 02				db 1 + 1 
a538 .. 00			db "@",0              
a53a				endm 
# End of macro CWHEAD
a53a			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a53a			 
a53a				if DEBUG_FORTH_WORDS_KEY 
a53a					DMARK "AT." 
a53a f5				push af  
a53b 3a 4f a5			ld a, (.dmark)  
a53e 32 65 ee			ld (debug_mark),a  
a541 3a 50 a5			ld a, (.dmark+1)  
a544 32 66 ee			ld (debug_mark+1),a  
a547 3a 51 a5			ld a, (.dmark+2)  
a54a 32 67 ee			ld (debug_mark+2),a  
a54d 18 03			jr .pastdmark  
a54f ..			.dmark: db "AT."  
a552 f1			.pastdmark: pop af  
a553			endm  
# End of macro DMARK
a553					CALLMONITOR 
a553 cd 6f ee			call debug_vector  
a556				endm  
# End of macro CALLMONITOR
a556				endif 
a556			.getbyteat:	 
a556				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a556 cd 8a 9c			call macro_dsp_valuehl 
a559				endm 
# End of macro FORTH_DSP_VALUEHL
a559				 
a559			;		push hl 
a559			 
a559				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a559 cd 42 9d			call macro_forth_dsp_pop 
a55c				endm 
# End of macro FORTH_DSP_POP
a55c			 
a55c			;		pop hl 
a55c			 
a55c 7e				ld a, (hl) 
a55d			 
a55d 6f				ld l, a 
a55e 26 00			ld h, 0 
a560 cd 85 9a			call forth_push_numhl 
a563			 
a563				NEXTW 
a563 c3 75 9e			jp macro_next 
a566				endm 
# End of macro NEXTW
a566			.CAT: 
a566			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a566 20				db WORD_SYS_CORE+OPCODE_CAT             
a567 8f a5			dw .BANG            
a569 03				db 2 + 1 
a56a .. 00			db "C@",0              
a56d				endm 
# End of macro CWHEAD
a56d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a56d				if DEBUG_FORTH_WORDS_KEY 
a56d					DMARK "CAA" 
a56d f5				push af  
a56e 3a 82 a5			ld a, (.dmark)  
a571 32 65 ee			ld (debug_mark),a  
a574 3a 83 a5			ld a, (.dmark+1)  
a577 32 66 ee			ld (debug_mark+1),a  
a57a 3a 84 a5			ld a, (.dmark+2)  
a57d 32 67 ee			ld (debug_mark+2),a  
a580 18 03			jr .pastdmark  
a582 ..			.dmark: db "CAA"  
a585 f1			.pastdmark: pop af  
a586			endm  
# End of macro DMARK
a586					CALLMONITOR 
a586 cd 6f ee			call debug_vector  
a589				endm  
# End of macro CALLMONITOR
a589				endif 
a589 c3 56 a5			jp .getbyteat 
a58c				NEXTW 
a58c c3 75 9e			jp macro_next 
a58f				endm 
# End of macro NEXTW
a58f			.BANG: 
a58f			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a58f 21				db WORD_SYS_CORE+OPCODE_BANG             
a590 c5 a5			dw .CBANG            
a592 02				db 1 + 1 
a593 .. 00			db "!",0              
a595				endm 
# End of macro CWHEAD
a595			; | ! ( x w -- ) Store x at address w      | DONE 
a595				if DEBUG_FORTH_WORDS_KEY 
a595					DMARK "BNG" 
a595 f5				push af  
a596 3a aa a5			ld a, (.dmark)  
a599 32 65 ee			ld (debug_mark),a  
a59c 3a ab a5			ld a, (.dmark+1)  
a59f 32 66 ee			ld (debug_mark+1),a  
a5a2 3a ac a5			ld a, (.dmark+2)  
a5a5 32 67 ee			ld (debug_mark+2),a  
a5a8 18 03			jr .pastdmark  
a5aa ..			.dmark: db "BNG"  
a5ad f1			.pastdmark: pop af  
a5ae			endm  
# End of macro DMARK
a5ae					CALLMONITOR 
a5ae cd 6f ee			call debug_vector  
a5b1				endm  
# End of macro CALLMONITOR
a5b1				endif 
a5b1			 
a5b1			.storebyteat:		 
a5b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b1 cd 8a 9c			call macro_dsp_valuehl 
a5b4				endm 
# End of macro FORTH_DSP_VALUEHL
a5b4				 
a5b4 e5				push hl 
a5b5			 
a5b5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b5 cd 42 9d			call macro_forth_dsp_pop 
a5b8				endm 
# End of macro FORTH_DSP_POP
a5b8			 
a5b8				; get byte to poke 
a5b8			 
a5b8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b8 cd 8a 9c			call macro_dsp_valuehl 
a5bb				endm 
# End of macro FORTH_DSP_VALUEHL
a5bb e5				push hl 
a5bc			 
a5bc			 
a5bc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5bc cd 42 9d			call macro_forth_dsp_pop 
a5bf				endm 
# End of macro FORTH_DSP_POP
a5bf			 
a5bf			 
a5bf d1				pop de 
a5c0 e1				pop hl 
a5c1			 
a5c1 73				ld (hl),e 
a5c2			 
a5c2			 
a5c2				NEXTW 
a5c2 c3 75 9e			jp macro_next 
a5c5				endm 
# End of macro NEXTW
a5c5			.CBANG: 
a5c5			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a5c5 22				db WORD_SYS_CORE+OPCODE_CBANG             
a5c6 ee a5			dw .SCALL            
a5c8 03				db 2 + 1 
a5c9 .. 00			db "C!",0              
a5cc				endm 
# End of macro CWHEAD
a5cc			; | C!  ( x w -- ) Store x at address w  | DONE 
a5cc				if DEBUG_FORTH_WORDS_KEY 
a5cc					DMARK "CBA" 
a5cc f5				push af  
a5cd 3a e1 a5			ld a, (.dmark)  
a5d0 32 65 ee			ld (debug_mark),a  
a5d3 3a e2 a5			ld a, (.dmark+1)  
a5d6 32 66 ee			ld (debug_mark+1),a  
a5d9 3a e3 a5			ld a, (.dmark+2)  
a5dc 32 67 ee			ld (debug_mark+2),a  
a5df 18 03			jr .pastdmark  
a5e1 ..			.dmark: db "CBA"  
a5e4 f1			.pastdmark: pop af  
a5e5			endm  
# End of macro DMARK
a5e5					CALLMONITOR 
a5e5 cd 6f ee			call debug_vector  
a5e8				endm  
# End of macro CALLMONITOR
a5e8				endif 
a5e8 c3 b1 a5			jp .storebyteat 
a5eb				NEXTW 
a5eb c3 75 9e			jp macro_next 
a5ee				endm 
# End of macro NEXTW
a5ee			.SCALL: 
a5ee			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a5ee 23				db WORD_SYS_CORE+OPCODE_SCALL             
a5ef 22 a6			dw .DEPTH            
a5f1 05				db 4 + 1 
a5f2 .. 00			db "CALL",0              
a5f7				endm 
# End of macro CWHEAD
a5f7			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a5f7				if DEBUG_FORTH_WORDS_KEY 
a5f7					DMARK "CLL" 
a5f7 f5				push af  
a5f8 3a 0c a6			ld a, (.dmark)  
a5fb 32 65 ee			ld (debug_mark),a  
a5fe 3a 0d a6			ld a, (.dmark+1)  
a601 32 66 ee			ld (debug_mark+1),a  
a604 3a 0e a6			ld a, (.dmark+2)  
a607 32 67 ee			ld (debug_mark+2),a  
a60a 18 03			jr .pastdmark  
a60c ..			.dmark: db "CLL"  
a60f f1			.pastdmark: pop af  
a610			endm  
# End of macro DMARK
a610					CALLMONITOR 
a610 cd 6f ee			call debug_vector  
a613				endm  
# End of macro CALLMONITOR
a613				endif 
a613			 
a613				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a613 cd 8a 9c			call macro_dsp_valuehl 
a616				endm 
# End of macro FORTH_DSP_VALUEHL
a616			 
a616			;		push hl 
a616			 
a616				; destroy value TOS 
a616			 
a616				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a616 cd 42 9d			call macro_forth_dsp_pop 
a619				endm 
# End of macro FORTH_DSP_POP
a619			 
a619					 
a619			;		pop hl 
a619			 
a619				; how to do a call with hl???? save SP? 
a619 cd 19 9e			call forth_call_hl 
a61c			 
a61c			 
a61c				; TODO push value back onto stack for another op etc 
a61c			 
a61c cd 85 9a			call forth_push_numhl 
a61f				NEXTW 
a61f c3 75 9e			jp macro_next 
a622				endm 
# End of macro NEXTW
a622			.DEPTH: 
a622			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a622 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a623 5f a6			dw .OVER            
a625 06				db 5 + 1 
a626 .. 00			db "DEPTH",0              
a62c				endm 
# End of macro CWHEAD
a62c			; | DEPTH ( -- u ) Push count of stack | DONE 
a62c				; take current TOS and remove from base value div by two to get count 
a62c				if DEBUG_FORTH_WORDS_KEY 
a62c					DMARK "DEP" 
a62c f5				push af  
a62d 3a 41 a6			ld a, (.dmark)  
a630 32 65 ee			ld (debug_mark),a  
a633 3a 42 a6			ld a, (.dmark+1)  
a636 32 66 ee			ld (debug_mark+1),a  
a639 3a 43 a6			ld a, (.dmark+2)  
a63c 32 67 ee			ld (debug_mark+2),a  
a63f 18 03			jr .pastdmark  
a641 ..			.dmark: db "DEP"  
a644 f1			.pastdmark: pop af  
a645			endm  
# End of macro DMARK
a645					CALLMONITOR 
a645 cd 6f ee			call debug_vector  
a648				endm  
# End of macro CALLMONITOR
a648				endif 
a648			 
a648			 
a648 2a e8 e9		ld hl, (cli_data_sp) 
a64b 11 22 e8		ld de, cli_data_stack 
a64e ed 52		sbc hl,de 
a650			 
a650			; div by size of stack item 
a650			 
a650 5d			ld e,l 
a651 0e 03		ld c, 3 
a653 cd 7a 8c		call Div8 
a656			 
a656 6f			ld l,a 
a657 26 00		ld h,0 
a659			 
a659			;srl h 
a659			;rr l 
a659			 
a659 cd 85 9a			call forth_push_numhl 
a65c				NEXTW 
a65c c3 75 9e			jp macro_next 
a65f				endm 
# End of macro NEXTW
a65f			.OVER: 
a65f			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a65f 42				db WORD_SYS_CORE+46             
a660 a6 a6			dw .PAUSE            
a662 05				db 4 + 1 
a663 .. 00			db "OVER",0              
a668				endm 
# End of macro CWHEAD
a668			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a668			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
a668				if DEBUG_FORTH_WORDS_KEY 
a668					DMARK "OVR" 
a668 f5				push af  
a669 3a 7d a6			ld a, (.dmark)  
a66c 32 65 ee			ld (debug_mark),a  
a66f 3a 7e a6			ld a, (.dmark+1)  
a672 32 66 ee			ld (debug_mark+1),a  
a675 3a 7f a6			ld a, (.dmark+2)  
a678 32 67 ee			ld (debug_mark+2),a  
a67b 18 03			jr .pastdmark  
a67d ..			.dmark: db "OVR"  
a680 f1			.pastdmark: pop af  
a681			endm  
# End of macro DMARK
a681					CALLMONITOR 
a681 cd 6f ee			call debug_vector  
a684				endm  
# End of macro CALLMONITOR
a684				endif 
a684			 
a684			; TODO Use os stack swap memory 
a684			 
a684				; work out what type we are looking at 
a684			 
a684				FORTH_DSP_PTR 1 
a684 2a e8 e9			ld hl,(cli_data_sp) 
a687 11 03 00			ld de, 1 * 3 
a68a ed 52			sbc hl, de 
a68c				endm 
# End of macro FORTH_DSP_PTR
a68c			 
a68c 7e				ld a, (hl) 
a68d				 
a68d f5				push af 
a68e				; whatever the type lets get the pointer or word 
a68e 23				inc hl 
a68f			;; 
a68f			 
a68f				; type check now to decide on how to push  
a68f			 
a68f cd f7 9d			call loadwordinhl 
a692 f1				pop af 
a693 fe 01			cp DS_TYPE_STR 
a695 28 06			jr z, .ovstr 
a697			 
a697				; we have a numeric so load the word and push 
a697			;	ld e, (hl) 
a697			;	inc hl 
a697			;	ld d, (hl) 
a697			;	ex de, hl 
a697 cd 85 9a			call forth_push_numhl 
a69a				NEXTW 
a69a c3 75 9e			jp macro_next 
a69d				endm 
# End of macro NEXTW
a69d			 
a69d			.ovstr: 
a69d				; ok, a string so get the pointer and push as a string 
a69d			 
a69d			;	call loadwordinhl 
a69d cd f3 9a			call forth_push_str 
a6a0				NEXTW 
a6a0 c3 75 9e			jp macro_next 
a6a3				endm 
# End of macro NEXTW
a6a3			 
a6a3			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6a3			;	push hl    ; n2 
a6a3			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6a3			; 
a6a3			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6a3			;	push hl    ; n1 
a6a3			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6a3			; 
a6a3			;	pop de     ; n1 
a6a3			;	pop hl     ; n2 
a6a3			; 
a6a3			;	push de 
a6a3			;	push hl 
a6a3			;	push de 
a6a3			 
a6a3				; push back  
a6a3			 
a6a3			;	pop hl 
a6a3			;	call forth_push_numhl 
a6a3			;	pop hl 
a6a3			;	call forth_push_numhl 
a6a3			;	pop hl 
a6a3			;	call forth_push_numhl 
a6a3				NEXTW 
a6a3 c3 75 9e			jp macro_next 
a6a6				endm 
# End of macro NEXTW
a6a6			 
a6a6			.PAUSE: 
a6a6			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a6a6 43				db WORD_SYS_CORE+47             
a6a7 db a6			dw .PAUSES            
a6a9 08				db 7 + 1 
a6aa .. 00			db "PAUSEMS",0              
a6b2				endm 
# End of macro CWHEAD
a6b2			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a6b2				if DEBUG_FORTH_WORDS_KEY 
a6b2					DMARK "PMS" 
a6b2 f5				push af  
a6b3 3a c7 a6			ld a, (.dmark)  
a6b6 32 65 ee			ld (debug_mark),a  
a6b9 3a c8 a6			ld a, (.dmark+1)  
a6bc 32 66 ee			ld (debug_mark+1),a  
a6bf 3a c9 a6			ld a, (.dmark+2)  
a6c2 32 67 ee			ld (debug_mark+2),a  
a6c5 18 03			jr .pastdmark  
a6c7 ..			.dmark: db "PMS"  
a6ca f1			.pastdmark: pop af  
a6cb			endm  
# End of macro DMARK
a6cb					CALLMONITOR 
a6cb cd 6f ee			call debug_vector  
a6ce				endm  
# End of macro CALLMONITOR
a6ce				endif 
a6ce				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ce cd 8a 9c			call macro_dsp_valuehl 
a6d1				endm 
# End of macro FORTH_DSP_VALUEHL
a6d1			;		push hl    ; n2 
a6d1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6d1 cd 42 9d			call macro_forth_dsp_pop 
a6d4				endm 
# End of macro FORTH_DSP_POP
a6d4			;		pop hl 
a6d4			 
a6d4 7d				ld a, l 
a6d5 cd e5 89			call aDelayInMS 
a6d8			       NEXTW 
a6d8 c3 75 9e			jp macro_next 
a6db				endm 
# End of macro NEXTW
a6db			.PAUSES:  
a6db			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a6db 44				db WORD_SYS_CORE+48             
a6dc 4a a7			dw .ROT            
a6de 06				db 5 + 1 
a6df .. 00			db "PAUSE",0              
a6e5				endm 
# End of macro CWHEAD
a6e5			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a6e5				if DEBUG_FORTH_WORDS_KEY 
a6e5					DMARK "PAU" 
a6e5 f5				push af  
a6e6 3a fa a6			ld a, (.dmark)  
a6e9 32 65 ee			ld (debug_mark),a  
a6ec 3a fb a6			ld a, (.dmark+1)  
a6ef 32 66 ee			ld (debug_mark+1),a  
a6f2 3a fc a6			ld a, (.dmark+2)  
a6f5 32 67 ee			ld (debug_mark+2),a  
a6f8 18 03			jr .pastdmark  
a6fa ..			.dmark: db "PAU"  
a6fd f1			.pastdmark: pop af  
a6fe			endm  
# End of macro DMARK
a6fe					CALLMONITOR 
a6fe cd 6f ee			call debug_vector  
a701				endm  
# End of macro CALLMONITOR
a701				endif 
a701				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a701 cd 8a 9c			call macro_dsp_valuehl 
a704				endm 
# End of macro FORTH_DSP_VALUEHL
a704			;		push hl    ; n2 
a704				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a704 cd 42 9d			call macro_forth_dsp_pop 
a707				endm 
# End of macro FORTH_DSP_POP
a707			;		pop hl 
a707 45				ld b, l 
a708				if DEBUG_FORTH_WORDS 
a708					DMARK "PAU" 
a708 f5				push af  
a709 3a 1d a7			ld a, (.dmark)  
a70c 32 65 ee			ld (debug_mark),a  
a70f 3a 1e a7			ld a, (.dmark+1)  
a712 32 66 ee			ld (debug_mark+1),a  
a715 3a 1f a7			ld a, (.dmark+2)  
a718 32 67 ee			ld (debug_mark+2),a  
a71b 18 03			jr .pastdmark  
a71d ..			.dmark: db "PAU"  
a720 f1			.pastdmark: pop af  
a721			endm  
# End of macro DMARK
a721					CALLMONITOR 
a721 cd 6f ee			call debug_vector  
a724				endm  
# End of macro CALLMONITOR
a724				endif 
a724 c5			.pauses1:	push bc 
a725 cd 00 8a			call delay1s 
a728 c1				pop bc 
a729				if DEBUG_FORTH_WORDS 
a729					DMARK "PA1" 
a729 f5				push af  
a72a 3a 3e a7			ld a, (.dmark)  
a72d 32 65 ee			ld (debug_mark),a  
a730 3a 3f a7			ld a, (.dmark+1)  
a733 32 66 ee			ld (debug_mark+1),a  
a736 3a 40 a7			ld a, (.dmark+2)  
a739 32 67 ee			ld (debug_mark+2),a  
a73c 18 03			jr .pastdmark  
a73e ..			.dmark: db "PA1"  
a741 f1			.pastdmark: pop af  
a742			endm  
# End of macro DMARK
a742					CALLMONITOR 
a742 cd 6f ee			call debug_vector  
a745				endm  
# End of macro CALLMONITOR
a745				endif 
a745 10 dd			djnz .pauses1 
a747			 
a747			       NEXTW 
a747 c3 75 9e			jp macro_next 
a74a				endm 
# End of macro NEXTW
a74a			.ROT: 
a74a			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a74a 45				db WORD_SYS_CORE+49             
a74b b3 a7			dw .UWORDS            
a74d 04				db 3 + 1 
a74e .. 00			db "ROT",0              
a752				endm 
# End of macro CWHEAD
a752			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a752				if DEBUG_FORTH_WORDS_KEY 
a752					DMARK "ROT" 
a752 f5				push af  
a753 3a 67 a7			ld a, (.dmark)  
a756 32 65 ee			ld (debug_mark),a  
a759 3a 68 a7			ld a, (.dmark+1)  
a75c 32 66 ee			ld (debug_mark+1),a  
a75f 3a 69 a7			ld a, (.dmark+2)  
a762 32 67 ee			ld (debug_mark+2),a  
a765 18 03			jr .pastdmark  
a767 ..			.dmark: db "ROT"  
a76a f1			.pastdmark: pop af  
a76b			endm  
# End of macro DMARK
a76b					CALLMONITOR 
a76b cd 6f ee			call debug_vector  
a76e				endm  
# End of macro CALLMONITOR
a76e				endif 
a76e			 
a76e			; DONE Use os stack swap memory 
a76e			 
a76e				FORTH_DSP_PTR 0     ; u3 
a76e 2a e8 e9			ld hl,(cli_data_sp) 
a771 11 00 00			ld de, 0 * 3 
a774 ed 52			sbc hl, de 
a776				endm 
# End of macro FORTH_DSP_PTR
a776 cd c1 9d			call hltostack1     
a779			  
a779				FORTH_DSP_PTR 1     ; u2 
a779 2a e8 e9			ld hl,(cli_data_sp) 
a77c 11 03 00			ld de, 1 * 3 
a77f ed 52			sbc hl, de 
a781				endm 
# End of macro FORTH_DSP_PTR
a781 cd c7 9d			call hltostack2      
a784			 
a784				FORTH_DSP_PTR 2     ; u1 
a784 2a e8 e9			ld hl,(cli_data_sp) 
a787 11 06 00			ld de, 2 * 3 
a78a ed 52			sbc hl, de 
a78c				endm 
# End of macro FORTH_DSP_PTR
a78c cd cd 9d			call hltostack3 
a78f			 
a78f			 
a78f				FORTH_DSP_PTR 0     ;  
a78f 2a e8 e9			ld hl,(cli_data_sp) 
a792 11 00 00			ld de, 0 * 3 
a795 ed 52			sbc hl, de 
a797				endm 
# End of macro FORTH_DSP_PTR
a797 cd e5 9d			call hlfromstack3 
a79a			 
a79a				FORTH_DSP_PTR 1     ; TOS 
a79a 2a e8 e9			ld hl,(cli_data_sp) 
a79d 11 03 00			ld de, 1 * 3 
a7a0 ed 52			sbc hl, de 
a7a2				endm 
# End of macro FORTH_DSP_PTR
a7a2 cd d9 9d			call hlfromstack1 
a7a5			 
a7a5				FORTH_DSP_PTR 2     ; TOS 
a7a5 2a e8 e9			ld hl,(cli_data_sp) 
a7a8 11 06 00			ld de, 2 * 3 
a7ab ed 52			sbc hl, de 
a7ad				endm 
# End of macro FORTH_DSP_PTR
a7ad cd df 9d			call hlfromstack2 
a7b0			 
a7b0			 
a7b0			;	FORTH_DSP_VALUEHL 
a7b0			;	push hl    ; u3  
a7b0			; 
a7b0			;	FORTH_DSP_POP 
a7b0			; 
a7b0			;	FORTH_DSP_VALUEHL 
a7b0			;	push hl     ; u2 
a7b0			; 
a7b0			;	FORTH_DSP_POP 
a7b0			; 
a7b0			;	FORTH_DSP_VALUEHL 
a7b0			;	push hl     ; u1 
a7b0			; 
a7b0			;	FORTH_DSP_POP 
a7b0			; 
a7b0			;	pop bc      ; u1 
a7b0			;	pop hl      ; u2 
a7b0			;	pop de      ; u3 
a7b0			; 
a7b0			; 
a7b0			;	push bc 
a7b0			;	push de 
a7b0			;	push hl 
a7b0			; 
a7b0			; 
a7b0			;	pop hl 
a7b0			;	call forth_push_numhl 
a7b0			; 
a7b0			;	pop hl 
a7b0			;	call forth_push_numhl 
a7b0			; 
a7b0			;	pop hl 
a7b0			;	call forth_push_numhl 
a7b0				 
a7b0			 
a7b0			 
a7b0			 
a7b0			 
a7b0			 
a7b0			       NEXTW 
a7b0 c3 75 9e			jp macro_next 
a7b3				endm 
# End of macro NEXTW
a7b3			 
a7b3			.UWORDS: 
a7b3			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a7b3 50				db WORD_SYS_CORE+60             
a7b4 75 a8			dw .BP            
a7b6 07				db 6 + 1 
a7b7 .. 00			db "UWORDS",0              
a7be				endm 
# End of macro CWHEAD
a7be			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a7be			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a7be			; | | Following the count are the individual words. 
a7be			; | | 
a7be			; | | e.g. UWORDS 
a7be			; | | BOX DIRLIST 2 
a7be			; | |  
a7be			; | | Can be used to save the words to storage via: 
a7be			; | | UWORDS $01 DO $01 APPEND LOOP 
a7be			if DEBUG_FORTH_WORDS_KEY 
a7be				DMARK "UWR" 
a7be f5				push af  
a7bf 3a d3 a7			ld a, (.dmark)  
a7c2 32 65 ee			ld (debug_mark),a  
a7c5 3a d4 a7			ld a, (.dmark+1)  
a7c8 32 66 ee			ld (debug_mark+1),a  
a7cb 3a d5 a7			ld a, (.dmark+2)  
a7ce 32 67 ee			ld (debug_mark+2),a  
a7d1 18 03			jr .pastdmark  
a7d3 ..			.dmark: db "UWR"  
a7d6 f1			.pastdmark: pop af  
a7d7			endm  
# End of macro DMARK
a7d7				CALLMONITOR 
a7d7 cd 6f ee			call debug_vector  
a7da				endm  
# End of macro CALLMONITOR
a7da			endif 
a7da 21 bf e2			ld hl, baseram 
a7dd				;ld hl, baseusermem 
a7dd 01 00 00			ld bc, 0    ; start a counter 
a7e0			 
a7e0			; skip dict stub 
a7e0			 
a7e0 cd b2 9f			call forth_tok_next 
a7e3			 
a7e3			 
a7e3			; while we have words to look for 
a7e3			 
a7e3 7e			.douscan:	ld a, (hl)      
a7e4			if DEBUG_FORTH_WORDS 
a7e4				DMARK "UWs" 
a7e4 f5				push af  
a7e5 3a f9 a7			ld a, (.dmark)  
a7e8 32 65 ee			ld (debug_mark),a  
a7eb 3a fa a7			ld a, (.dmark+1)  
a7ee 32 66 ee			ld (debug_mark+1),a  
a7f1 3a fb a7			ld a, (.dmark+2)  
a7f4 32 67 ee			ld (debug_mark+2),a  
a7f7 18 03			jr .pastdmark  
a7f9 ..			.dmark: db "UWs"  
a7fc f1			.pastdmark: pop af  
a7fd			endm  
# End of macro DMARK
a7fd				CALLMONITOR 
a7fd cd 6f ee			call debug_vector  
a800				endm  
# End of macro CALLMONITOR
a800			endif 
a800 fe 00			cp WORD_SYS_END 
a802 28 4d			jr z, .udone 
a804 fe 01			cp WORD_SYS_UWORD 
a806 20 44			jr nz, .nuword 
a808			 
a808			if DEBUG_FORTH_WORDS 
a808				DMARK "UWu" 
a808 f5				push af  
a809 3a 1d a8			ld a, (.dmark)  
a80c 32 65 ee			ld (debug_mark),a  
a80f 3a 1e a8			ld a, (.dmark+1)  
a812 32 66 ee			ld (debug_mark+1),a  
a815 3a 1f a8			ld a, (.dmark+2)  
a818 32 67 ee			ld (debug_mark+2),a  
a81b 18 03			jr .pastdmark  
a81d ..			.dmark: db "UWu"  
a820 f1			.pastdmark: pop af  
a821			endm  
# End of macro DMARK
a821				CALLMONITOR 
a821 cd 6f ee			call debug_vector  
a824				endm  
# End of macro CALLMONITOR
a824			endif 
a824				; we have a uword so push its name to the stack 
a824			 
a824 e5				push hl  ; save so we can move to next dict block 
a825			 
a825				; skip opcode 
a825 23				inc hl  
a826				; skip next ptr 
a826 23				inc hl  
a827 23				inc hl 
a828				; skip len 
a828 23				inc hl 
a829			if DEBUG_FORTH_WORDS 
a829				DMARK "UWt" 
a829 f5				push af  
a82a 3a 3e a8			ld a, (.dmark)  
a82d 32 65 ee			ld (debug_mark),a  
a830 3a 3f a8			ld a, (.dmark+1)  
a833 32 66 ee			ld (debug_mark+1),a  
a836 3a 40 a8			ld a, (.dmark+2)  
a839 32 67 ee			ld (debug_mark+2),a  
a83c 18 03			jr .pastdmark  
a83e ..			.dmark: db "UWt"  
a841 f1			.pastdmark: pop af  
a842			endm  
# End of macro DMARK
a842				CALLMONITOR 
a842 cd 6f ee			call debug_vector  
a845				endm  
# End of macro CALLMONITOR
a845			endif 
a845 03				inc bc 
a846			 
a846 c5				push bc 
a847 cd f3 9a			call forth_push_str 
a84a c1				pop bc 
a84b			 
a84b e1				pop hl 	 
a84c			 
a84c cd b2 9f		.nuword:	call forth_tok_next 
a84f 18 92			jr .douscan  
a851			 
a851			.udone:		 ; push count of uwords found 
a851 c5				push bc 
a852 e1				pop hl 
a853			 
a853			if DEBUG_FORTH_WORDS 
a853				DMARK "UWc" 
a853 f5				push af  
a854 3a 68 a8			ld a, (.dmark)  
a857 32 65 ee			ld (debug_mark),a  
a85a 3a 69 a8			ld a, (.dmark+1)  
a85d 32 66 ee			ld (debug_mark+1),a  
a860 3a 6a a8			ld a, (.dmark+2)  
a863 32 67 ee			ld (debug_mark+2),a  
a866 18 03			jr .pastdmark  
a868 ..			.dmark: db "UWc"  
a86b f1			.pastdmark: pop af  
a86c			endm  
# End of macro DMARK
a86c				CALLMONITOR 
a86c cd 6f ee			call debug_vector  
a86f				endm  
# End of macro CALLMONITOR
a86f			endif 
a86f cd 85 9a			call forth_push_numhl 
a872			 
a872			 
a872			       NEXTW 
a872 c3 75 9e			jp macro_next 
a875				endm 
# End of macro NEXTW
a875			 
a875			.BP: 
a875			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a875 54				db WORD_SYS_CORE+64             
a876 af a8			dw .MONITOR            
a878 03				db 2 + 1 
a879 .. 00			db "BP",0              
a87c				endm 
# End of macro CWHEAD
a87c			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a87c			; | | $00 Will enable the break points within specific code paths 
a87c			; | | $01 Will disable break points 
a87c			; | |  
a87c			; | | By default break points are off. Either the above can be used to enable them 
a87c			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a87c			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a87c			; | | can disable break points. Exiting will then continue boot process. 
a87c				; get byte count 
a87c				if DEBUG_FORTH_WORDS_KEY 
a87c					DMARK "BP." 
a87c f5				push af  
a87d 3a 91 a8			ld a, (.dmark)  
a880 32 65 ee			ld (debug_mark),a  
a883 3a 92 a8			ld a, (.dmark+1)  
a886 32 66 ee			ld (debug_mark+1),a  
a889 3a 93 a8			ld a, (.dmark+2)  
a88c 32 67 ee			ld (debug_mark+2),a  
a88f 18 03			jr .pastdmark  
a891 ..			.dmark: db "BP."  
a894 f1			.pastdmark: pop af  
a895			endm  
# End of macro DMARK
a895					CALLMONITOR 
a895 cd 6f ee			call debug_vector  
a898				endm  
# End of macro CALLMONITOR
a898				endif 
a898			 
a898				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a898 cd 8a 9c			call macro_dsp_valuehl 
a89b				endm 
# End of macro FORTH_DSP_VALUEHL
a89b			 
a89b			;		push hl 
a89b			 
a89b				; destroy value TOS 
a89b			 
a89b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a89b cd 42 9d			call macro_forth_dsp_pop 
a89e				endm 
# End of macro FORTH_DSP_POP
a89e			 
a89e			;		pop hl 
a89e			 
a89e 3e 00			ld a,0 
a8a0 bd				cp l 
a8a1 28 06			jr z, .bpset 
a8a3			;		ld a, '*' 
a8a3 cd 00 94			call bp_off 
a8a6				NEXTW 
a8a6 c3 75 9e			jp macro_next 
a8a9				endm 
# End of macro NEXTW
a8a9			 
a8a9			.bpset:	 
a8a9				;	ld (os_view_disable), a 
a8a9 cd f4 93			call bp_on 
a8ac			 
a8ac			 
a8ac				NEXTW 
a8ac c3 75 9e			jp macro_next 
a8af				endm 
# End of macro NEXTW
a8af			 
a8af			 
a8af			.MONITOR: 
a8af			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a8af 55				db WORD_SYS_CORE+65             
a8b0 e0 a8			dw .MALLOC            
a8b2 08				db 7 + 1 
a8b3 .. 00			db "MONITOR",0              
a8bb				endm 
# End of macro CWHEAD
a8bb			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a8bb			; | | At start the current various registers will be displayed with contents. 
a8bb			; | | Top right corner will show the most recent debug marker seen. 
a8bb			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a8bb			; | | and the return stack pointer (RSP). 
a8bb			; | | Pressing: 
a8bb			; | |    1 - Initial screen 
a8bb			; | |    2 - Display a data dump of HL 
a8bb			; | |    3 - Display a data dump of DE 
a8bb			; | |    4 - Display a data dump of BC 
a8bb			; | |    5 - Display a data dump of HL 
a8bb			; | |    6 - Display a data dump of DSP 
a8bb			; | |    7 - Display a data dump of RSP 
a8bb			; | |    8 - Display a data dump of what is at DSP 
a8bb			; | |    9 - Display a data dump of what is at RSP 
a8bb			; | |    0 - Exit monitor and continue running. This will also enable break points 
a8bb			; | |    * - Disable break points 
a8bb			; | |    # - Enter traditional monitor mode 
a8bb			; | | 
a8bb			; | | Monitor Mode 
a8bb			; | | ------------ 
a8bb			; | | A prompt of '>' will be shown for various commands: 
a8bb			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a8bb			; | |    C - Continue display a data dump from the last set address 
a8bb			; | |    M xxxx - Set start of memory edit at address xx 
a8bb			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a8bb			; | |    G xxxx - Exec code at specific address 
a8bb			; | |    Q - Return to previous 
a8bb				if DEBUG_FORTH_WORDS_KEY 
a8bb					DMARK "MON" 
a8bb f5				push af  
a8bc 3a d0 a8			ld a, (.dmark)  
a8bf 32 65 ee			ld (debug_mark),a  
a8c2 3a d1 a8			ld a, (.dmark+1)  
a8c5 32 66 ee			ld (debug_mark+1),a  
a8c8 3a d2 a8			ld a, (.dmark+2)  
a8cb 32 67 ee			ld (debug_mark+2),a  
a8ce 18 03			jr .pastdmark  
a8d0 ..			.dmark: db "MON"  
a8d3 f1			.pastdmark: pop af  
a8d4			endm  
# End of macro DMARK
a8d4					CALLMONITOR 
a8d4 cd 6f ee			call debug_vector  
a8d7				endm  
# End of macro CALLMONITOR
a8d7				endif 
a8d7			;		ld a, 0 
a8d7			;		ld (os_view_disable), a 
a8d7 cd f4 93			call bp_on 
a8da			 
a8da				CALLMONITOR 
a8da cd 6f ee			call debug_vector  
a8dd				endm  
# End of macro CALLMONITOR
a8dd			 
a8dd			;	call monitor 
a8dd			 
a8dd				NEXTW 
a8dd c3 75 9e			jp macro_next 
a8e0				endm 
# End of macro NEXTW
a8e0			 
a8e0			 
a8e0			.MALLOC: 
a8e0			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a8e0 56				db WORD_SYS_CORE+66             
a8e1 09 a9			dw .MALLOC2            
a8e3 06				db 5 + 1 
a8e4 .. 00			db "ALLOT",0              
a8ea				endm 
# End of macro CWHEAD
a8ea			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a8ea				if DEBUG_FORTH_WORDS_KEY 
a8ea					DMARK "ALL" 
a8ea f5				push af  
a8eb 3a ff a8			ld a, (.dmark)  
a8ee 32 65 ee			ld (debug_mark),a  
a8f1 3a 00 a9			ld a, (.dmark+1)  
a8f4 32 66 ee			ld (debug_mark+1),a  
a8f7 3a 01 a9			ld a, (.dmark+2)  
a8fa 32 67 ee			ld (debug_mark+2),a  
a8fd 18 03			jr .pastdmark  
a8ff ..			.dmark: db "ALL"  
a902 f1			.pastdmark: pop af  
a903			endm  
# End of macro DMARK
a903					CALLMONITOR 
a903 cd 6f ee			call debug_vector  
a906				endm  
# End of macro CALLMONITOR
a906				endif 
a906 c3 30 a9			jp .mallocc 
a909			.MALLOC2: 
a909			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a909 56				db WORD_SYS_CORE+66             
a90a 47 a9			dw .FREE            
a90c 07				db 6 + 1 
a90d .. 00			db "MALLOC",0              
a914				endm 
# End of macro CWHEAD
a914			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a914				; get byte count 
a914				if DEBUG_FORTH_WORDS_KEY 
a914					DMARK "MAL" 
a914 f5				push af  
a915 3a 29 a9			ld a, (.dmark)  
a918 32 65 ee			ld (debug_mark),a  
a91b 3a 2a a9			ld a, (.dmark+1)  
a91e 32 66 ee			ld (debug_mark+1),a  
a921 3a 2b a9			ld a, (.dmark+2)  
a924 32 67 ee			ld (debug_mark+2),a  
a927 18 03			jr .pastdmark  
a929 ..			.dmark: db "MAL"  
a92c f1			.pastdmark: pop af  
a92d			endm  
# End of macro DMARK
a92d					CALLMONITOR 
a92d cd 6f ee			call debug_vector  
a930				endm  
# End of macro CALLMONITOR
a930				endif 
a930			.mallocc: 
a930				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a930 cd 8a 9c			call macro_dsp_valuehl 
a933				endm 
# End of macro FORTH_DSP_VALUEHL
a933			 
a933			;		push hl 
a933			 
a933				; destroy value TOS 
a933			 
a933				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a933 cd 42 9d			call macro_forth_dsp_pop 
a936				endm 
# End of macro FORTH_DSP_POP
a936			 
a936			;		pop hl 
a936 cd c5 90			call malloc 
a939			if DEBUG_FORTH_MALLOC_GUARD 
a939 f5				push af 
a93a cd 13 8d			call ishlzero 
a93d			;		ld a, l 
a93d			;		add h 
a93d			;		cp 0 
a93d f1				pop af 
a93e				 
a93e cc 6d d1			call z,malloc_error 
a941			endif 
a941			 
a941 cd 85 9a			call forth_push_numhl 
a944				NEXTW 
a944 c3 75 9e			jp macro_next 
a947				endm 
# End of macro NEXTW
a947			 
a947			.FREE: 
a947			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
a947 57				db WORD_SYS_CORE+67             
a948 78 a9			dw .UPTR            
a94a 05				db 4 + 1 
a94b .. 00			db "FREE",0              
a950				endm 
# End of macro CWHEAD
a950			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a950				if DEBUG_FORTH_WORDS_KEY 
a950					DMARK "FRE" 
a950 f5				push af  
a951 3a 65 a9			ld a, (.dmark)  
a954 32 65 ee			ld (debug_mark),a  
a957 3a 66 a9			ld a, (.dmark+1)  
a95a 32 66 ee			ld (debug_mark+1),a  
a95d 3a 67 a9			ld a, (.dmark+2)  
a960 32 67 ee			ld (debug_mark+2),a  
a963 18 03			jr .pastdmark  
a965 ..			.dmark: db "FRE"  
a968 f1			.pastdmark: pop af  
a969			endm  
# End of macro DMARK
a969					CALLMONITOR 
a969 cd 6f ee			call debug_vector  
a96c				endm  
# End of macro CALLMONITOR
a96c				endif 
a96c				; get address 
a96c			 
a96c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a96c cd 8a 9c			call macro_dsp_valuehl 
a96f				endm 
# End of macro FORTH_DSP_VALUEHL
a96f			 
a96f			;		push hl 
a96f			 
a96f				; destroy value TOS 
a96f			 
a96f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a96f cd 42 9d			call macro_forth_dsp_pop 
a972				endm 
# End of macro FORTH_DSP_POP
a972			 
a972			;		pop hl 
a972			if FORTH_ENABLE_MALLOCFREE 
a972 cd 8f 91			call free 
a975			endif 
a975				NEXTW 
a975 c3 75 9e			jp macro_next 
a978				endm 
# End of macro NEXTW
a978			.UPTR: 
a978			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
a978 57				db WORD_SYS_CORE+67             
a979 7b aa			dw .LIST            
a97b 05				db 4 + 1 
a97c .. 00			db "UPTR",0              
a981				endm 
# End of macro CWHEAD
a981			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
a981				if DEBUG_FORTH_WORDS_KEY 
a981					DMARK "UPT" 
a981 f5				push af  
a982 3a 96 a9			ld a, (.dmark)  
a985 32 65 ee			ld (debug_mark),a  
a988 3a 97 a9			ld a, (.dmark+1)  
a98b 32 66 ee			ld (debug_mark+1),a  
a98e 3a 98 a9			ld a, (.dmark+2)  
a991 32 67 ee			ld (debug_mark+2),a  
a994 18 03			jr .pastdmark  
a996 ..			.dmark: db "UPT"  
a999 f1			.pastdmark: pop af  
a99a			endm  
# End of macro DMARK
a99a					CALLMONITOR 
a99a cd 6f ee			call debug_vector  
a99d				endm  
# End of macro CALLMONITOR
a99d				endif 
a99d				FORTH_DSP_VALUEHL 
a99d cd 8a 9c			call macro_dsp_valuehl 
a9a0				endm 
# End of macro FORTH_DSP_VALUEHL
a9a0			 
a9a0 e5				push hl 
a9a1				FORTH_DSP_POP 
a9a1 cd 42 9d			call macro_forth_dsp_pop 
a9a4				endm 
# End of macro FORTH_DSP_POP
a9a4 c1				pop bc 
a9a5			 
a9a5			 
a9a5				; Get ptr to the word we need to look up 
a9a5			 
a9a5			;		FORTH_DSP_VALUEHL 
a9a5				;v5 FORTH_DSP_VALUE 
a9a5			; TODO type check 
a9a5			;		inc hl    ; Skip type check  
a9a5			;		push hl 
a9a5			;		ex de, hl    ; put into DE 
a9a5			 
a9a5			 
a9a5 21 bf e2			ld hl, baseram 
a9a8				;ld hl, baseusermem 
a9a8			 
a9a8 e5			push hl   ; sacreifical push 
a9a9			 
a9a9			.uldouscanm: 
a9a9 e1			pop hl 
a9aa			.uldouscan: 
a9aa			if DEBUG_FORTH_WORDS 
a9aa				DMARK "LSs" 
a9aa f5				push af  
a9ab 3a bf a9			ld a, (.dmark)  
a9ae 32 65 ee			ld (debug_mark),a  
a9b1 3a c0 a9			ld a, (.dmark+1)  
a9b4 32 66 ee			ld (debug_mark+1),a  
a9b7 3a c1 a9			ld a, (.dmark+2)  
a9ba 32 67 ee			ld (debug_mark+2),a  
a9bd 18 03			jr .pastdmark  
a9bf ..			.dmark: db "LSs"  
a9c2 f1			.pastdmark: pop af  
a9c3			endm  
# End of macro DMARK
a9c3				CALLMONITOR 
a9c3 cd 6f ee			call debug_vector  
a9c6				endm  
# End of macro CALLMONITOR
a9c6			endif 
a9c6			; skip dict stub 
a9c6 cd b2 9f			call forth_tok_next 
a9c9			 
a9c9			 
a9c9			; while we have words to look for 
a9c9			 
a9c9 7e			ld a, (hl)      
a9ca			if DEBUG_FORTH_WORDS 
a9ca				DMARK "LSk" 
a9ca f5				push af  
a9cb 3a df a9			ld a, (.dmark)  
a9ce 32 65 ee			ld (debug_mark),a  
a9d1 3a e0 a9			ld a, (.dmark+1)  
a9d4 32 66 ee			ld (debug_mark+1),a  
a9d7 3a e1 a9			ld a, (.dmark+2)  
a9da 32 67 ee			ld (debug_mark+2),a  
a9dd 18 03			jr .pastdmark  
a9df ..			.dmark: db "LSk"  
a9e2 f1			.pastdmark: pop af  
a9e3			endm  
# End of macro DMARK
a9e3				CALLMONITOR 
a9e3 cd 6f ee			call debug_vector  
a9e6				endm  
# End of macro CALLMONITOR
a9e6			endif 
a9e6				;cp WORD_SYS_END 
a9e6				;jp z, .lunotfound 
a9e6			 
a9e6					; if we hit non uwords then gone too far 
a9e6 fe 01				cp WORD_SYS_UWORD 
a9e8 c2 75 aa				jp nz, .ulunotfound 
a9eb			 
a9eb				if DEBUG_FORTH_WORDS 
a9eb					DMARK "LSu" 
a9eb f5				push af  
a9ec 3a 00 aa			ld a, (.dmark)  
a9ef 32 65 ee			ld (debug_mark),a  
a9f2 3a 01 aa			ld a, (.dmark+1)  
a9f5 32 66 ee			ld (debug_mark+1),a  
a9f8 3a 02 aa			ld a, (.dmark+2)  
a9fb 32 67 ee			ld (debug_mark+2),a  
a9fe 18 03			jr .pastdmark  
aa00 ..			.dmark: db "LSu"  
aa03 f1			.pastdmark: pop af  
aa04			endm  
# End of macro DMARK
aa04					CALLMONITOR 
aa04 cd 6f ee			call debug_vector  
aa07				endm  
# End of macro CALLMONITOR
aa07				endif 
aa07			 
aa07					; found a uword but is it the one we want... 
aa07			 
aa07 c5					push bc     ; uword to find is on bc 
aa08 d1					pop de 
aa09			 
aa09 e5					push hl  ; to save the ptr 
aa0a			 
aa0a					; skip opcode 
aa0a 23					inc hl  
aa0b					; skip next ptr 
aa0b 23					inc hl  
aa0c 23					inc hl 
aa0d					; skip len 
aa0d 23					inc hl 
aa0e			 
aa0e				if DEBUG_FORTH_WORDS 
aa0e					DMARK "LSc" 
aa0e f5				push af  
aa0f 3a 23 aa			ld a, (.dmark)  
aa12 32 65 ee			ld (debug_mark),a  
aa15 3a 24 aa			ld a, (.dmark+1)  
aa18 32 66 ee			ld (debug_mark+1),a  
aa1b 3a 25 aa			ld a, (.dmark+2)  
aa1e 32 67 ee			ld (debug_mark+2),a  
aa21 18 03			jr .pastdmark  
aa23 ..			.dmark: db "LSc"  
aa26 f1			.pastdmark: pop af  
aa27			endm  
# End of macro DMARK
aa27					CALLMONITOR 
aa27 cd 6f ee			call debug_vector  
aa2a				endm  
# End of macro CALLMONITOR
aa2a				endif 
aa2a			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
aa2a			; ie. If WOO is defined first and then WO. Couldnt list WO. 
aa2a			; Nope that has gone the other way. It needs to be exact not on first zero 
aa2a			;		call strcmp 
aa2a c5					push bc 
aa2b cd 95 90				call StrictStrCmp 
aa2e c1					pop bc 
aa2f c2 a9 a9				jp nz, .uldouscanm 
aa32				 
aa32			 
aa32			 
aa32					; we have a uword so push its name to the stack 
aa32			 
aa32			;	   	push hl  ; save so we can move to next dict block 
aa32 e1			pop hl 
aa33			 
aa33				if DEBUG_FORTH_WORDS 
aa33					DMARK "LSm" 
aa33 f5				push af  
aa34 3a 48 aa			ld a, (.dmark)  
aa37 32 65 ee			ld (debug_mark),a  
aa3a 3a 49 aa			ld a, (.dmark+1)  
aa3d 32 66 ee			ld (debug_mark+1),a  
aa40 3a 4a aa			ld a, (.dmark+2)  
aa43 32 67 ee			ld (debug_mark+2),a  
aa46 18 03			jr .pastdmark  
aa48 ..			.dmark: db "LSm"  
aa4b f1			.pastdmark: pop af  
aa4c			endm  
# End of macro DMARK
aa4c					CALLMONITOR 
aa4c cd 6f ee			call debug_vector  
aa4f				endm  
# End of macro CALLMONITOR
aa4f				endif 
aa4f			 
aa4f					; skip opcode 
aa4f 23					inc hl  
aa50					; skip next ptr 
aa50 23					inc hl  
aa51 23					inc hl 
aa52					; skip len 
aa52 7e					ld a, (hl)   ; save length to add 
aa53				if DEBUG_FORTH_WORDS 
aa53					DMARK "LS2" 
aa53 f5				push af  
aa54 3a 68 aa			ld a, (.dmark)  
aa57 32 65 ee			ld (debug_mark),a  
aa5a 3a 69 aa			ld a, (.dmark+1)  
aa5d 32 66 ee			ld (debug_mark+1),a  
aa60 3a 6a aa			ld a, (.dmark+2)  
aa63 32 67 ee			ld (debug_mark+2),a  
aa66 18 03			jr .pastdmark  
aa68 ..			.dmark: db "LS2"  
aa6b f1			.pastdmark: pop af  
aa6c			endm  
# End of macro DMARK
aa6c					CALLMONITOR 
aa6c cd 6f ee			call debug_vector  
aa6f				endm  
# End of macro CALLMONITOR
aa6f				endif 
aa6f			 
aa6f				; skip zero term and other uword defs to position right at the exec code 
aa6f 06 04			ld b, 4 
aa71 80				add a,b 
aa72			 
aa72 cd ea 8c			call addatohl 
aa75					; save this location 
aa75				 
aa75			.ulunotfound: 
aa75 cd 85 9a			call forth_push_numhl 
aa78						 
aa78				NEXTW 
aa78 c3 75 9e			jp macro_next 
aa7b				endm 
# End of macro NEXTW
aa7b			.LIST: 
aa7b			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa7b 5c				db WORD_SYS_CORE+72             
aa7c 77 ac			dw .FORGET            
aa7e 05				db 4 + 1 
aa7f .. 00			db "LIST",0              
aa84				endm 
# End of macro CWHEAD
aa84			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa84			; | | The quoted word must be in upper case. 
aa84			if DEBUG_FORTH_WORDS_KEY 
aa84				DMARK "LST" 
aa84 f5				push af  
aa85 3a 99 aa			ld a, (.dmark)  
aa88 32 65 ee			ld (debug_mark),a  
aa8b 3a 9a aa			ld a, (.dmark+1)  
aa8e 32 66 ee			ld (debug_mark+1),a  
aa91 3a 9b aa			ld a, (.dmark+2)  
aa94 32 67 ee			ld (debug_mark+2),a  
aa97 18 03			jr .pastdmark  
aa99 ..			.dmark: db "LST"  
aa9c f1			.pastdmark: pop af  
aa9d			endm  
# End of macro DMARK
aa9d				CALLMONITOR 
aa9d cd 6f ee			call debug_vector  
aaa0				endm  
# End of macro CALLMONITOR
aaa0			endif 
aaa0			 
aaa0				FORTH_DSP_VALUEHL 
aaa0 cd 8a 9c			call macro_dsp_valuehl 
aaa3				endm 
# End of macro FORTH_DSP_VALUEHL
aaa3			 
aaa3 e5				push hl 
aaa4				FORTH_DSP_POP 
aaa4 cd 42 9d			call macro_forth_dsp_pop 
aaa7				endm 
# End of macro FORTH_DSP_POP
aaa7 c1				pop bc 
aaa8			 
aaa8			; Start format of scratch string 
aaa8			 
aaa8 21 bb e2			ld hl, scratch 
aaab			 
aaab 3e 3a			ld a, ':' 
aaad 77				ld (hl),a 
aaae 23				inc hl 
aaaf 3e 20			ld a, ' ' 
aab1 77				ld (hl), a 
aab2			 
aab2				; Get ptr to the word we need to look up 
aab2			 
aab2			;		FORTH_DSP_VALUEHL 
aab2				;v5 FORTH_DSP_VALUE 
aab2			; TODO type check 
aab2			;		inc hl    ; Skip type check  
aab2			;		push hl 
aab2			;		ex de, hl    ; put into DE 
aab2			 
aab2			 
aab2 21 bf e2			ld hl, baseram 
aab5				;ld hl, baseusermem 
aab5			 
aab5 e5			push hl   ; sacreifical push 
aab6			 
aab6			.ldouscanm: 
aab6 e1			pop hl 
aab7			.ldouscan: 
aab7			if DEBUG_FORTH_WORDS 
aab7				DMARK "LSs" 
aab7 f5				push af  
aab8 3a cc aa			ld a, (.dmark)  
aabb 32 65 ee			ld (debug_mark),a  
aabe 3a cd aa			ld a, (.dmark+1)  
aac1 32 66 ee			ld (debug_mark+1),a  
aac4 3a ce aa			ld a, (.dmark+2)  
aac7 32 67 ee			ld (debug_mark+2),a  
aaca 18 03			jr .pastdmark  
aacc ..			.dmark: db "LSs"  
aacf f1			.pastdmark: pop af  
aad0			endm  
# End of macro DMARK
aad0				CALLMONITOR 
aad0 cd 6f ee			call debug_vector  
aad3				endm  
# End of macro CALLMONITOR
aad3			endif 
aad3			; skip dict stub 
aad3 cd b2 9f			call forth_tok_next 
aad6			 
aad6			 
aad6			; while we have words to look for 
aad6			 
aad6 7e			ld a, (hl)      
aad7			if DEBUG_FORTH_WORDS 
aad7				DMARK "LSk" 
aad7 f5				push af  
aad8 3a ec aa			ld a, (.dmark)  
aadb 32 65 ee			ld (debug_mark),a  
aade 3a ed aa			ld a, (.dmark+1)  
aae1 32 66 ee			ld (debug_mark+1),a  
aae4 3a ee aa			ld a, (.dmark+2)  
aae7 32 67 ee			ld (debug_mark+2),a  
aaea 18 03			jr .pastdmark  
aaec ..			.dmark: db "LSk"  
aaef f1			.pastdmark: pop af  
aaf0			endm  
# End of macro DMARK
aaf0				CALLMONITOR 
aaf0 cd 6f ee			call debug_vector  
aaf3				endm  
# End of macro CALLMONITOR
aaf3			endif 
aaf3				;cp WORD_SYS_END 
aaf3				;jp z, .lunotfound 
aaf3			 
aaf3					; if we hit non uwords then gone too far 
aaf3 fe 01				cp WORD_SYS_UWORD 
aaf5 c2 33 ac				jp nz, .lunotfound 
aaf8			 
aaf8				if DEBUG_FORTH_WORDS 
aaf8					DMARK "LSu" 
aaf8 f5				push af  
aaf9 3a 0d ab			ld a, (.dmark)  
aafc 32 65 ee			ld (debug_mark),a  
aaff 3a 0e ab			ld a, (.dmark+1)  
ab02 32 66 ee			ld (debug_mark+1),a  
ab05 3a 0f ab			ld a, (.dmark+2)  
ab08 32 67 ee			ld (debug_mark+2),a  
ab0b 18 03			jr .pastdmark  
ab0d ..			.dmark: db "LSu"  
ab10 f1			.pastdmark: pop af  
ab11			endm  
# End of macro DMARK
ab11					CALLMONITOR 
ab11 cd 6f ee			call debug_vector  
ab14				endm  
# End of macro CALLMONITOR
ab14				endif 
ab14			 
ab14					; found a uword but is it the one we want... 
ab14			 
ab14 c5					push bc     ; uword to find is on bc 
ab15 d1					pop de 
ab16			 
ab16 e5					push hl  ; to save the ptr 
ab17			 
ab17					; skip opcode 
ab17 23					inc hl  
ab18					; skip next ptr 
ab18 23					inc hl  
ab19 23					inc hl 
ab1a					; skip len 
ab1a 23					inc hl 
ab1b			 
ab1b				if DEBUG_FORTH_WORDS 
ab1b					DMARK "LSc" 
ab1b f5				push af  
ab1c 3a 30 ab			ld a, (.dmark)  
ab1f 32 65 ee			ld (debug_mark),a  
ab22 3a 31 ab			ld a, (.dmark+1)  
ab25 32 66 ee			ld (debug_mark+1),a  
ab28 3a 32 ab			ld a, (.dmark+2)  
ab2b 32 67 ee			ld (debug_mark+2),a  
ab2e 18 03			jr .pastdmark  
ab30 ..			.dmark: db "LSc"  
ab33 f1			.pastdmark: pop af  
ab34			endm  
# End of macro DMARK
ab34					CALLMONITOR 
ab34 cd 6f ee			call debug_vector  
ab37				endm  
# End of macro CALLMONITOR
ab37				endif 
ab37			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
ab37			; ie. If WOO is defined first and then WO. Couldnt list WO. 
ab37			; Nope that has gone the other way. It needs to be exact not on first zero 
ab37			;		call strcmp 
ab37 c5					push bc 
ab38 cd 95 90				call StrictStrCmp 
ab3b c1					pop bc 
ab3c c2 b6 aa				jp nz, .ldouscanm 
ab3f				 
ab3f			 
ab3f			 
ab3f					; we have a uword so push its name to the stack 
ab3f			 
ab3f			;	   	push hl  ; save so we can move to next dict block 
ab3f e1			pop hl 
ab40			 
ab40				if DEBUG_FORTH_WORDS 
ab40					DMARK "LSm" 
ab40 f5				push af  
ab41 3a 55 ab			ld a, (.dmark)  
ab44 32 65 ee			ld (debug_mark),a  
ab47 3a 56 ab			ld a, (.dmark+1)  
ab4a 32 66 ee			ld (debug_mark+1),a  
ab4d 3a 57 ab			ld a, (.dmark+2)  
ab50 32 67 ee			ld (debug_mark+2),a  
ab53 18 03			jr .pastdmark  
ab55 ..			.dmark: db "LSm"  
ab58 f1			.pastdmark: pop af  
ab59			endm  
# End of macro DMARK
ab59					CALLMONITOR 
ab59 cd 6f ee			call debug_vector  
ab5c				endm  
# End of macro CALLMONITOR
ab5c				endif 
ab5c			 
ab5c					; skip opcode 
ab5c 23					inc hl  
ab5d					; skip next ptr 
ab5d 23					inc hl  
ab5e 23					inc hl 
ab5f					; skip len 
ab5f 7e					ld a, (hl)   ; save length to add 
ab60				if DEBUG_FORTH_WORDS 
ab60					DMARK "LS2" 
ab60 f5				push af  
ab61 3a 75 ab			ld a, (.dmark)  
ab64 32 65 ee			ld (debug_mark),a  
ab67 3a 76 ab			ld a, (.dmark+1)  
ab6a 32 66 ee			ld (debug_mark+1),a  
ab6d 3a 77 ab			ld a, (.dmark+2)  
ab70 32 67 ee			ld (debug_mark+2),a  
ab73 18 03			jr .pastdmark  
ab75 ..			.dmark: db "LS2"  
ab78 f1			.pastdmark: pop af  
ab79			endm  
# End of macro DMARK
ab79					CALLMONITOR 
ab79 cd 6f ee			call debug_vector  
ab7c				endm  
# End of macro CALLMONITOR
ab7c				endif 
ab7c			 
ab7c					; save this location 
ab7c				 
ab7c e5					push hl 
ab7d			 
ab7d 23					inc hl 
ab7e 11 bd e2				ld de, scratch+2 
ab81 4f					ld c, a 
ab82 06 00				ld b, 0 
ab84			 
ab84				if DEBUG_FORTH_WORDS 
ab84					DMARK "LSn" 
ab84 f5				push af  
ab85 3a 99 ab			ld a, (.dmark)  
ab88 32 65 ee			ld (debug_mark),a  
ab8b 3a 9a ab			ld a, (.dmark+1)  
ab8e 32 66 ee			ld (debug_mark+1),a  
ab91 3a 9b ab			ld a, (.dmark+2)  
ab94 32 67 ee			ld (debug_mark+2),a  
ab97 18 03			jr .pastdmark  
ab99 ..			.dmark: db "LSn"  
ab9c f1			.pastdmark: pop af  
ab9d			endm  
# End of macro DMARK
ab9d					CALLMONITOR 
ab9d cd 6f ee			call debug_vector  
aba0				endm  
# End of macro CALLMONITOR
aba0				endif 
aba0			 
aba0					; copy uword name to scratch 
aba0			 
aba0			;		ldir 
aba0			.licplw:	; copy uword name to scratch converting to lower case as we go 
aba0 ed a0				ldi 
aba2 1b					dec de 
aba3 1a					ld a, (de) 
aba4 cd 68 8f				call to_lower 
aba7 12					ld (de),a 
aba8 13					inc de 
aba9 3e 00				ld a, 0 
abab b9					cp c 
abac 20 f2				jr nz, .licplw 
abae			 
abae			 
abae			 
abae 1b					dec de 
abaf 3e 20				ld a, ' '    ; change null to space 
abb1 12					ld (de), a 
abb2			 
abb2 13					inc de 
abb3			 
abb3 d5					push de 
abb4 c1					pop bc     ; move scratch pointer to end of word name and save it 
abb5			 
abb5 e1					pop hl 
abb6 7e					ld a, (hl) 
abb7					;inc hl 
abb7					; skip word string 
abb7 cd ea 8c				call addatohl 
abba			 
abba 23					inc hl 
abbb			 
abbb				if DEBUG_FORTH_WORDS 
abbb					DMARK "LS3" 
abbb f5				push af  
abbc 3a d0 ab			ld a, (.dmark)  
abbf 32 65 ee			ld (debug_mark),a  
abc2 3a d1 ab			ld a, (.dmark+1)  
abc5 32 66 ee			ld (debug_mark+1),a  
abc8 3a d2 ab			ld a, (.dmark+2)  
abcb 32 67 ee			ld (debug_mark+2),a  
abce 18 03			jr .pastdmark  
abd0 ..			.dmark: db "LS3"  
abd3 f1			.pastdmark: pop af  
abd4			endm  
# End of macro DMARK
abd4					CALLMONITOR 
abd4 cd 6f ee			call debug_vector  
abd7				endm  
# End of macro CALLMONITOR
abd7				endif 
abd7					; should now be at the start of the machine code to setup the eval of the uword 
abd7					; now locate the ptr to the string defintion 
abd7			 
abd7					; skip ld hl, 
abd7					; then load the ptr 
abd7			; TODO use get from hl ptr 
abd7 23					inc hl 
abd8 5e					ld e, (hl) 
abd9 23					inc hl 
abda 56					ld d, (hl) 
abdb eb					ex de, hl 
abdc			 
abdc			 
abdc				if DEBUG_FORTH_WORDS 
abdc					DMARK "LSt" 
abdc f5				push af  
abdd 3a f1 ab			ld a, (.dmark)  
abe0 32 65 ee			ld (debug_mark),a  
abe3 3a f2 ab			ld a, (.dmark+1)  
abe6 32 66 ee			ld (debug_mark+1),a  
abe9 3a f3 ab			ld a, (.dmark+2)  
abec 32 67 ee			ld (debug_mark+2),a  
abef 18 03			jr .pastdmark  
abf1 ..			.dmark: db "LSt"  
abf4 f1			.pastdmark: pop af  
abf5			endm  
# End of macro DMARK
abf5					CALLMONITOR 
abf5 cd 6f ee			call debug_vector  
abf8				endm  
# End of macro CALLMONITOR
abf8				endif 
abf8			 
abf8			; cant push right now due to tokenised strings  
abf8			 
abf8			; get the destination of where to copy this definition to. 
abf8			 
abf8 c5					push bc 
abf9 d1					pop de 
abfa			 
abfa 7e			.listl:         ld a,(hl) 
abfb fe 00				cp 0 
abfd 28 09				jr z, .lreplsp     ; replace zero with space 
abff					;cp FORTH_END_BUFFER 
abff fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
ac01 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
ac03				 
ac03					; just copy this char as is then 
ac03			 
ac03 12					ld (de), a 
ac04			 
ac04 23			.listnxt:	inc hl 
ac05 13					inc de 
ac06 18 f2				jr .listl 
ac08			 
ac08 3e 20		.lreplsp:	ld a,' ' 
ac0a 12					ld (de), a 
ac0b 18 f7				jr .listnxt 
ac0d			 
ac0d			; close up uword def 
ac0d			 
ac0d			.listdone: 
ac0d 12					ld (de), a 
ac0e 13					inc de 
ac0f 3e 00				ld a, 0 
ac11 12					ld (de), a 
ac12			 
ac12			; now have def so clean up and push to stack 
ac12			 
ac12 21 bb e2				ld hl, scratch 
ac15				if DEBUG_FORTH_WORDS 
ac15					DMARK "Ltp" 
ac15 f5				push af  
ac16 3a 2a ac			ld a, (.dmark)  
ac19 32 65 ee			ld (debug_mark),a  
ac1c 3a 2b ac			ld a, (.dmark+1)  
ac1f 32 66 ee			ld (debug_mark+1),a  
ac22 3a 2c ac			ld a, (.dmark+2)  
ac25 32 67 ee			ld (debug_mark+2),a  
ac28 18 03			jr .pastdmark  
ac2a ..			.dmark: db "Ltp"  
ac2d f1			.pastdmark: pop af  
ac2e			endm  
# End of macro DMARK
ac2e					CALLMONITOR 
ac2e cd 6f ee			call debug_vector  
ac31				endm  
# End of macro CALLMONITOR
ac31				endif 
ac31			 
ac31 18 1f			jr .listpush 
ac33			 
ac33			;.lnuword:	pop hl 
ac33			;		call forth_tok_next 
ac33			;		jp .ldouscan  
ac33			 
ac33			.lunotfound:		  
ac33			 
ac33				if DEBUG_FORTH_WORDS 
ac33					DMARK "LSn" 
ac33 f5				push af  
ac34 3a 48 ac			ld a, (.dmark)  
ac37 32 65 ee			ld (debug_mark),a  
ac3a 3a 49 ac			ld a, (.dmark+1)  
ac3d 32 66 ee			ld (debug_mark+1),a  
ac40 3a 4a ac			ld a, (.dmark+2)  
ac43 32 67 ee			ld (debug_mark+2),a  
ac46 18 03			jr .pastdmark  
ac48 ..			.dmark: db "LSn"  
ac4b f1			.pastdmark: pop af  
ac4c			endm  
# End of macro DMARK
ac4c					CALLMONITOR 
ac4c cd 6f ee			call debug_vector  
ac4f				endm  
# End of macro CALLMONITOR
ac4f				endif 
ac4f			 
ac4f					 
ac4f			;		FORTH_DSP_POP 
ac4f			;		ld hl, .luno 
ac4f			 
ac4f					NEXTW			 
ac4f c3 75 9e			jp macro_next 
ac52				endm 
# End of macro NEXTW
ac52			 
ac52			.listpush: 
ac52				if DEBUG_FORTH_WORDS 
ac52					DMARK "LS>" 
ac52 f5				push af  
ac53 3a 67 ac			ld a, (.dmark)  
ac56 32 65 ee			ld (debug_mark),a  
ac59 3a 68 ac			ld a, (.dmark+1)  
ac5c 32 66 ee			ld (debug_mark+1),a  
ac5f 3a 69 ac			ld a, (.dmark+2)  
ac62 32 67 ee			ld (debug_mark+2),a  
ac65 18 03			jr .pastdmark  
ac67 ..			.dmark: db "LS>"  
ac6a f1			.pastdmark: pop af  
ac6b			endm  
# End of macro DMARK
ac6b					CALLMONITOR 
ac6b cd 6f ee			call debug_vector  
ac6e				endm  
# End of macro CALLMONITOR
ac6e				endif 
ac6e cd f3 9a				call forth_push_str 
ac71			 
ac71			 
ac71			 
ac71					NEXTW 
ac71 c3 75 9e			jp macro_next 
ac74				endm 
# End of macro NEXTW
ac74			 
ac74			;.luno:    db "Word not found",0 
ac74			 
ac74			 
ac74			 
ac74			 
ac74			 
ac74			;		push hl   ; save pointer to start of uword def string 
ac74			; 
ac74			;; look for FORTH_EOL_LINE 
ac74			;		ld a, FORTH_END_BUFFER 
ac74			;		call strlent 
ac74			; 
ac74			;		inc hl		 ; space for coln def 
ac74			;		inc hl 
ac74			;		inc hl          ; space for terms 
ac74			;		inc hl 
ac74			; 
ac74			;		ld a, 20   ; TODO get actual length 
ac74			;		call addatohl    ; include a random amount of room for the uword name 
ac74			; 
ac74			;		 
ac74			;	if DEBUG_FORTH_WORDS 
ac74			;		DMARK "Lt1" 
ac74			;		CALLMONITOR 
ac74			;	endif 
ac74			;		 
ac74			; 
ac74			;; malloc space for the string because we cant change it 
ac74			; 
ac74			;		call malloc 
ac74			;	if DEBUG_FORTH_MALLOC_GUARD 
ac74			;		push af 
ac74			;		call ishlzero 
ac74			;		pop af 
ac74			;		 
ac74			;		call z,malloc_error 
ac74			;	endif 
ac74			; 
ac74			;	if DEBUG_FORTH_WORDS 
ac74			;		DMARK "Lt2" 
ac74			;		CALLMONITOR 
ac74			;	endif 
ac74			;		pop de 
ac74			;		push hl    ; push the malloc to release later 
ac74			;		push hl   ;  push back a copy for the later stack push 
ac74			;		 
ac74			;; copy the string swapping out the zero terms for spaces 
ac74			; 
ac74			;		; de has our source 
ac74			;		; hl has our dest 
ac74			; 
ac74			;; add the coln def 
ac74			; 
ac74			;		ld a, ':' 
ac74			;		ld (hl), a 
ac74			;		inc hl 
ac74			;		ld a, ' ' 
ac74			;		ld (hl), a 
ac74			;		inc hl 
ac74			; 
ac74			;; add the uname word 
ac74			;		push de   ; save our string for now 
ac74			;		ex de, hl 
ac74			; 
ac74			;		FORTH_DSP_VALUE 
ac74			;		;v5 FORTH_DSP_VALUE 
ac74			; 
ac74			;		inc hl   ; skip type but we know by now this is OK 
ac74			; 
ac74			;.luword:	ld a,(hl) 
ac74			;		cp 0 
ac74			;		jr z, .luword2 
ac74			;		ld (de), a 
ac74			;		inc de 
ac74			;		inc hl 
ac74			;		jr .luword 
ac74			; 
ac74			;.luword2:	ld a, ' ' 
ac74			;		ld (de), a 
ac74			;;		inc hl 
ac74			;;		inc de 
ac74			;;		ld (de), a 
ac74			;;		inc hl 
ac74			;		inc de 
ac74			; 
ac74			;		ex de, hl 
ac74			;		pop de 
ac74			;		 
ac74			;		 
ac74			; 
ac74			;; detoken that string and copy it 
ac74			; 
ac74			;	if DEBUG_FORTH_WORDS 
ac74			;		DMARK "Lt2" 
ac74			;		CALLMONITOR 
ac74			;	endif 
ac74			;.ldetok:	ld a, (de) 
ac74			;		cp FORTH_END_BUFFER 
ac74			;		jr z, .ldetokend 
ac74			;		; swap out any zero term for space 
ac74			;		cp 0 
ac74			;		jr nz, .ldetoknext 
ac74			;		ld a, ' ' 
ac74			; 
ac74			;	if DEBUG_FORTH_WORDS 
ac74			;		DMARK "LtS" 
ac74			;		CALLMONITOR 
ac74			;	endif 
ac74			;.ldetoknext:	ld (hl), a 
ac74			;		inc de 
ac74			;		inc hl 
ac74			;		jr .ldetok 
ac74			; 
ac74			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac74			;		ld (hl), a  
ac74			; 
ac74			;; free that temp malloc 
ac74			; 
ac74			;		pop hl    
ac74			; 
ac74			;	if DEBUG_FORTH_WORDS 
ac74			;		DMARK "Lt4" 
ac74			;		CALLMONITOR 
ac74			;	endif 
ac74			;		call forth_apushstrhl 
ac74			; 
ac74			;		; get rid of temp malloc area 
ac74			; 
ac74			;		pop hl 
ac74			;		call free 
ac74			; 
ac74			;		jr .ludone 
ac74			; 
ac74			;.lnuword:	pop hl 
ac74			;		call forth_tok_next 
ac74			;		jp .ldouscan  
ac74			; 
ac74			;.ludone:		 pop hl 
ac74			; 
ac74					NEXTW 
ac74 c3 75 9e			jp macro_next 
ac77				endm 
# End of macro NEXTW
ac77			 
ac77			.FORGET: 
ac77				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac77 5d				db WORD_SYS_CORE+73             
ac78 f0 ac			dw .NOP            
ac7a 07				db 6 + 1 
ac7b .. 00			db "FORGET",0              
ac82				endm 
# End of macro CWHEAD
ac82			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac82			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac82			; | |  
ac82			; | | e.g. "MORE" forget 
ac82					if DEBUG_FORTH_WORDS_KEY 
ac82						DMARK "FRG" 
ac82 f5				push af  
ac83 3a 97 ac			ld a, (.dmark)  
ac86 32 65 ee			ld (debug_mark),a  
ac89 3a 98 ac			ld a, (.dmark+1)  
ac8c 32 66 ee			ld (debug_mark+1),a  
ac8f 3a 99 ac			ld a, (.dmark+2)  
ac92 32 67 ee			ld (debug_mark+2),a  
ac95 18 03			jr .pastdmark  
ac97 ..			.dmark: db "FRG"  
ac9a f1			.pastdmark: pop af  
ac9b			endm  
# End of macro DMARK
ac9b						CALLMONITOR 
ac9b cd 6f ee			call debug_vector  
ac9e				endm  
# End of macro CALLMONITOR
ac9e					endif 
ac9e			 
ac9e				; find uword 
ac9e			        ; update start of word with "_" 
ac9e				; replace uword with deleted flag 
ac9e			 
ac9e			 
ac9e			;	if DEBUG_FORTH_WORDS 
ac9e			;		DMARK "FOG" 
ac9e			;		CALLMONITOR 
ac9e			;	endif 
ac9e			 
ac9e			 
ac9e					; Get ptr to the word we need to look up 
ac9e			 
ac9e					FORTH_DSP_VALUEHL 
ac9e cd 8a 9c			call macro_dsp_valuehl 
aca1				endm 
# End of macro FORTH_DSP_VALUEHL
aca1					;v5 FORTH_DSP_VALUE 
aca1				; TODO type check 
aca1			;		inc hl    ; Skip type check  
aca1 e5					push hl 
aca2 c1					pop bc 
aca3			;		ex de, hl    ; put into DE 
aca3			 
aca3			 
aca3 21 bf e2				ld hl, baseram 
aca6					;ld hl, baseusermem 
aca6			 
aca6				; skip dict stub 
aca6			;	call forth_tok_next 
aca6 e5			push hl   ; sacreifical push 
aca7			 
aca7			.fldouscanm: 
aca7 e1				pop hl 
aca8			.fldouscan: 
aca8			;	if DEBUG_FORTH_WORDS 
aca8			;		DMARK "LSs" 
aca8			;		CALLMONITOR 
aca8			;	endif 
aca8				; skip dict stub 
aca8 cd b2 9f				call forth_tok_next 
acab			 
acab			 
acab			; while we have words to look for 
acab			 
acab 7e				ld a, (hl)      
acac			;	if DEBUG_FORTH_WORDS 
acac			;		DMARK "LSk" 
acac			;		CALLMONITOR 
acac			;	endif 
acac fe 00				cp WORD_SYS_END 
acae ca ea ac				jp z, .flunotfound 
acb1 fe 01				cp WORD_SYS_UWORD 
acb3 c2 a8 ac				jp nz, .fldouscan 
acb6			 
acb6			;	if DEBUG_FORTH_WORDS 
acb6			;		DMARK "LSu" 
acb6			;		CALLMONITOR 
acb6			;	endif 
acb6			 
acb6					; found a uword but is it the one we want... 
acb6			 
acb6 c5					push bc     ; uword to find is on bc 
acb7 d1					pop de 
acb8			 
acb8 e5					push hl  ; to save the ptr 
acb9			 
acb9					; skip opcode 
acb9 23					inc hl  
acba					; skip next ptr 
acba 23					inc hl  
acbb 23					inc hl 
acbc					; skip len 
acbc 23					inc hl 
acbd			 
acbd			;	if DEBUG_FORTH_WORDS 
acbd			;		DMARK "LSc" 
acbd			;		CALLMONITOR 
acbd			;	endif 
acbd cd 88 90				call strcmp 
acc0 c2 a7 ac				jp nz, .fldouscanm 
acc3			; 
acc3			; 
acc3			;; while we have words to look for 
acc3			; 
acc3			;.fdouscan:	ld a, (hl)      
acc3			;	if DEBUG_FORTH_WORDS 
acc3			;		DMARK "LSs" 
acc3			;		CALLMONITOR 
acc3			;	endif 
acc3			;		cp WORD_SYS_END 
acc3			;		jp z, .fudone 
acc3			;		cp WORD_SYS_UWORD 
acc3			;		jp nz, .fnuword 
acc3			; 
acc3			;	if DEBUG_FORTH_WORDS 
acc3			;		DMARK "FGu" 
acc3			;		CALLMONITOR 
acc3			;	endif 
acc3			; 
acc3			;		; found a uword but is it the one we want... 
acc3			; 
acc3			; 
acc3			;	        pop de   ; get back the dsp name 
acc3			;		push de 
acc3			; 
acc3			;		push hl  ; to save the ptr 
acc3			; 
acc3			;		; skip opcode 
acc3			;		inc hl  
acc3			;		; skip next ptr 
acc3			;		inc hl  
acc3			;		inc hl 
acc3			;		; skip len 
acc3			;		inc hl 
acc3			; 
acc3			;	if DEBUG_FORTH_WORDS 
acc3			;		DMARK "FGc" 
acc3			;		CALLMONITOR 
acc3			;	endif 
acc3			;		call strcmp 
acc3			;		jp nz, .fnuword 
acc3			 
acc3			 
acc3 e1			pop hl 
acc4			 
acc4				 
acc4				if DEBUG_FORTH_WORDS 
acc4					DMARK "FGm" 
acc4 f5				push af  
acc5 3a d9 ac			ld a, (.dmark)  
acc8 32 65 ee			ld (debug_mark),a  
accb 3a da ac			ld a, (.dmark+1)  
acce 32 66 ee			ld (debug_mark+1),a  
acd1 3a db ac			ld a, (.dmark+2)  
acd4 32 67 ee			ld (debug_mark+2),a  
acd7 18 03			jr .pastdmark  
acd9 ..			.dmark: db "FGm"  
acdc f1			.pastdmark: pop af  
acdd			endm  
# End of macro DMARK
acdd					CALLMONITOR 
acdd cd 6f ee			call debug_vector  
ace0				endm  
# End of macro CALLMONITOR
ace0				endif 
ace0			 
ace0			 
ace0			 
ace0					; we have a uword so push its name to the stack 
ace0			 
ace0			;	   	push hl  ; save so we can move to next dict block 
ace0			;pop hl 
ace0			 
ace0					; update opcode to deleted 
ace0 3e 03				ld a, WORD_SYS_DELETED 
ace2 77					ld (hl), a 
ace3			 
ace3 23					inc hl  
ace4					; skip next ptr 
ace4 23					inc hl  
ace5 23					inc hl 
ace6					; skip len 
ace6 23					inc hl 
ace7			 
ace7					; TODO change parser to skip deleted words but for now mark it out 
ace7 3e 5f				ld a, "_" 
ace9 77					ld  (hl),a 
acea			 
acea			;		jr .fudone 
acea			; 
acea			;.fnuword:	pop hl 
acea			;		call forth_tok_next 
acea			;		jp .fdouscan  
acea			 
acea			.flunotfound:		  
acea			 
acea			 
acea					 
acea					FORTH_DSP_POP 
acea cd 42 9d			call macro_forth_dsp_pop 
aced				endm 
# End of macro FORTH_DSP_POP
aced			;		ld hl, .luno 
aced			;.fudone:		 pop hl 
aced					NEXTW 
aced c3 75 9e			jp macro_next 
acf0				endm 
# End of macro NEXTW
acf0			.NOP: 
acf0				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
acf0 61				db WORD_SYS_CORE+77             
acf1 17 ad			dw .COMO            
acf3 04				db 3 + 1 
acf4 .. 00			db "NOP",0              
acf8				endm 
# End of macro CWHEAD
acf8			; | NOP (  --  ) Do nothing | DONE 
acf8					if DEBUG_FORTH_WORDS_KEY 
acf8						DMARK "NOP" 
acf8 f5				push af  
acf9 3a 0d ad			ld a, (.dmark)  
acfc 32 65 ee			ld (debug_mark),a  
acff 3a 0e ad			ld a, (.dmark+1)  
ad02 32 66 ee			ld (debug_mark+1),a  
ad05 3a 0f ad			ld a, (.dmark+2)  
ad08 32 67 ee			ld (debug_mark+2),a  
ad0b 18 03			jr .pastdmark  
ad0d ..			.dmark: db "NOP"  
ad10 f1			.pastdmark: pop af  
ad11			endm  
# End of macro DMARK
ad11						CALLMONITOR 
ad11 cd 6f ee			call debug_vector  
ad14				endm  
# End of macro CALLMONITOR
ad14					endif 
ad14				       NEXTW 
ad14 c3 75 9e			jp macro_next 
ad17				endm 
# End of macro NEXTW
ad17			.COMO: 
ad17				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
ad17 6e				db WORD_SYS_CORE+90             
ad18 69 ad			dw .COMC            
ad1a 02				db 1 + 1 
ad1b .. 00			db "(",0              
ad1d				endm 
# End of macro CWHEAD
ad1d			; | ( ( -- )  Start of comment | DONE 
ad1d			 
ad1d			 
ad1d 2a bc e5				ld hl, ( os_tok_ptr) 
ad20 11 64 ad			ld de, .closepar 
ad23					 
ad23					if DEBUG_FORTH_WORDS 
ad23						DMARK ").." 
ad23 f5				push af  
ad24 3a 38 ad			ld a, (.dmark)  
ad27 32 65 ee			ld (debug_mark),a  
ad2a 3a 39 ad			ld a, (.dmark+1)  
ad2d 32 66 ee			ld (debug_mark+1),a  
ad30 3a 3a ad			ld a, (.dmark+2)  
ad33 32 67 ee			ld (debug_mark+2),a  
ad36 18 03			jr .pastdmark  
ad38 ..			.dmark: db ").."  
ad3b f1			.pastdmark: pop af  
ad3c			endm  
# End of macro DMARK
ad3c						CALLMONITOR 
ad3c cd 6f ee			call debug_vector  
ad3f				endm  
# End of macro CALLMONITOR
ad3f					endif 
ad3f cd 7c 9f			call findnexttok  
ad42			 
ad42					if DEBUG_FORTH_WORDS 
ad42						DMARK "IF5" 
ad42 f5				push af  
ad43 3a 57 ad			ld a, (.dmark)  
ad46 32 65 ee			ld (debug_mark),a  
ad49 3a 58 ad			ld a, (.dmark+1)  
ad4c 32 66 ee			ld (debug_mark+1),a  
ad4f 3a 59 ad			ld a, (.dmark+2)  
ad52 32 67 ee			ld (debug_mark+2),a  
ad55 18 03			jr .pastdmark  
ad57 ..			.dmark: db "IF5"  
ad5a f1			.pastdmark: pop af  
ad5b			endm  
# End of macro DMARK
ad5b						CALLMONITOR 
ad5b cd 6f ee			call debug_vector  
ad5e				endm  
# End of macro CALLMONITOR
ad5e					endif 
ad5e				; replace below with ) exec using tok_ptr 
ad5e 22 bc e5			ld (os_tok_ptr), hl 
ad61 c3 fe 9e			jp exec1 
ad64			 
ad64 .. 00			.closepar:   db ")",0 
ad66			 
ad66				       NEXTW 
ad66 c3 75 9e			jp macro_next 
ad69				endm 
# End of macro NEXTW
ad69			.COMC: 
ad69				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad69 6f				db WORD_SYS_CORE+91             
ad6a 72 ad			dw .SCRATCH            
ad6c 02				db 1 + 1 
ad6d .. 00			db ")",0              
ad6f				endm 
# End of macro CWHEAD
ad6f			; | ) ( -- )  End of comment |  DONE  
ad6f				       NEXTW 
ad6f c3 75 9e			jp macro_next 
ad72				endm 
# End of macro NEXTW
ad72			 
ad72			.SCRATCH: 
ad72				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad72 6f				db WORD_SYS_CORE+91             
ad73 ad ad			dw .INC            
ad75 08				db 7 + 1 
ad76 .. 00			db "SCRATCH",0              
ad7e				endm 
# End of macro CWHEAD
ad7e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad7e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad7e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad7e			; | |  
ad7e			; | | e.g.    : score $00 scratch ; 
ad7e			; | |  
ad7e			; | | $00 score ! 
ad7e			; | | $01 score +! 
ad7e			; | |  
ad7e			; | | e.g.   : varword $0a scratch ;  
ad7e			; | | 
ad7e			; | | $8000 varword ! 
ad7e					if DEBUG_FORTH_WORDS_KEY 
ad7e						DMARK "SCR" 
ad7e f5				push af  
ad7f 3a 93 ad			ld a, (.dmark)  
ad82 32 65 ee			ld (debug_mark),a  
ad85 3a 94 ad			ld a, (.dmark+1)  
ad88 32 66 ee			ld (debug_mark+1),a  
ad8b 3a 95 ad			ld a, (.dmark+2)  
ad8e 32 67 ee			ld (debug_mark+2),a  
ad91 18 03			jr .pastdmark  
ad93 ..			.dmark: db "SCR"  
ad96 f1			.pastdmark: pop af  
ad97			endm  
# End of macro DMARK
ad97						CALLMONITOR 
ad97 cd 6f ee			call debug_vector  
ad9a				endm  
# End of macro CALLMONITOR
ad9a					endif 
ad9a			 
ad9a					FORTH_DSP_VALUEHL 
ad9a cd 8a 9c			call macro_dsp_valuehl 
ad9d				endm 
# End of macro FORTH_DSP_VALUEHL
ad9d				 
ad9d					FORTH_DSP_POP 
ad9d cd 42 9d			call macro_forth_dsp_pop 
ada0				endm 
# End of macro FORTH_DSP_POP
ada0			 
ada0 7d					ld a, l 
ada1 21 e0 e7				ld hl, os_var_array 
ada4 cd ea 8c				call addatohl 
ada7			 
ada7 cd 85 9a				call forth_push_numhl 
adaa			 
adaa				       NEXTW 
adaa c3 75 9e			jp macro_next 
adad				endm 
# End of macro NEXTW
adad			 
adad			.INC: 
adad				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
adad 6f				db WORD_SYS_CORE+91             
adae 03 ae			dw .DEC            
adb0 03				db 2 + 1 
adb1 .. 00			db "+!",0              
adb4				endm 
# End of macro CWHEAD
adb4			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
adb4					if DEBUG_FORTH_WORDS_KEY 
adb4						DMARK "+s_" 
adb4 f5				push af  
adb5 3a c9 ad			ld a, (.dmark)  
adb8 32 65 ee			ld (debug_mark),a  
adbb 3a ca ad			ld a, (.dmark+1)  
adbe 32 66 ee			ld (debug_mark+1),a  
adc1 3a cb ad			ld a, (.dmark+2)  
adc4 32 67 ee			ld (debug_mark+2),a  
adc7 18 03			jr .pastdmark  
adc9 ..			.dmark: db "+s_"  
adcc f1			.pastdmark: pop af  
adcd			endm  
# End of macro DMARK
adcd						CALLMONITOR 
adcd cd 6f ee			call debug_vector  
add0				endm  
# End of macro CALLMONITOR
add0					endif 
add0			 
add0					FORTH_DSP_VALUEHL 
add0 cd 8a 9c			call macro_dsp_valuehl 
add3				endm 
# End of macro FORTH_DSP_VALUEHL
add3			 
add3 e5					push hl   ; save address 
add4			 
add4					FORTH_DSP_POP 
add4 cd 42 9d			call macro_forth_dsp_pop 
add7				endm 
# End of macro FORTH_DSP_POP
add7			 
add7					FORTH_DSP_VALUEHL 
add7 cd 8a 9c			call macro_dsp_valuehl 
adda				endm 
# End of macro FORTH_DSP_VALUEHL
adda			 
adda e5					push hl 
addb					FORTH_DSP_POP 
addb cd 42 9d			call macro_forth_dsp_pop 
adde				endm 
# End of macro FORTH_DSP_POP
adde e1					pop hl 
addf			 
addf					; hl contains value to add to byte at a 
addf				 
addf eb					ex de, hl 
ade0			 
ade0 e1					pop hl 
ade1			 
ade1					if DEBUG_FORTH_WORDS 
ade1						DMARK "INC" 
ade1 f5				push af  
ade2 3a f6 ad			ld a, (.dmark)  
ade5 32 65 ee			ld (debug_mark),a  
ade8 3a f7 ad			ld a, (.dmark+1)  
adeb 32 66 ee			ld (debug_mark+1),a  
adee 3a f8 ad			ld a, (.dmark+2)  
adf1 32 67 ee			ld (debug_mark+2),a  
adf4 18 03			jr .pastdmark  
adf6 ..			.dmark: db "INC"  
adf9 f1			.pastdmark: pop af  
adfa			endm  
# End of macro DMARK
adfa						CALLMONITOR 
adfa cd 6f ee			call debug_vector  
adfd				endm  
# End of macro CALLMONITOR
adfd					endif 
adfd			 
adfd 7e					ld a,(hl) 
adfe 83					add e 
adff 77					ld (hl),a 
ae00			 
ae00			 
ae00			 
ae00				       NEXTW 
ae00 c3 75 9e			jp macro_next 
ae03				endm 
# End of macro NEXTW
ae03			 
ae03			.DEC: 
ae03				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ae03 6f				db WORD_SYS_CORE+91             
ae04 57 ae			dw .INC2            
ae06 03				db 2 + 1 
ae07 .. 00			db "-!",0              
ae0a				endm 
# End of macro CWHEAD
ae0a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ae0a					if DEBUG_FORTH_WORDS_KEY 
ae0a						DMARK "-s_" 
ae0a f5				push af  
ae0b 3a 1f ae			ld a, (.dmark)  
ae0e 32 65 ee			ld (debug_mark),a  
ae11 3a 20 ae			ld a, (.dmark+1)  
ae14 32 66 ee			ld (debug_mark+1),a  
ae17 3a 21 ae			ld a, (.dmark+2)  
ae1a 32 67 ee			ld (debug_mark+2),a  
ae1d 18 03			jr .pastdmark  
ae1f ..			.dmark: db "-s_"  
ae22 f1			.pastdmark: pop af  
ae23			endm  
# End of macro DMARK
ae23						CALLMONITOR 
ae23 cd 6f ee			call debug_vector  
ae26				endm  
# End of macro CALLMONITOR
ae26					endif 
ae26			 
ae26					FORTH_DSP_VALUEHL 
ae26 cd 8a 9c			call macro_dsp_valuehl 
ae29				endm 
# End of macro FORTH_DSP_VALUEHL
ae29			 
ae29 e5					push hl   ; save address 
ae2a			 
ae2a					FORTH_DSP_POP 
ae2a cd 42 9d			call macro_forth_dsp_pop 
ae2d				endm 
# End of macro FORTH_DSP_POP
ae2d			 
ae2d					FORTH_DSP_VALUEHL 
ae2d cd 8a 9c			call macro_dsp_valuehl 
ae30				endm 
# End of macro FORTH_DSP_VALUEHL
ae30			 
ae30					; hl contains value to add to byte at a 
ae30				 
ae30 eb					ex de, hl 
ae31			 
ae31 e1					pop hl 
ae32			 
ae32					if DEBUG_FORTH_WORDS 
ae32						DMARK "DEC" 
ae32 f5				push af  
ae33 3a 47 ae			ld a, (.dmark)  
ae36 32 65 ee			ld (debug_mark),a  
ae39 3a 48 ae			ld a, (.dmark+1)  
ae3c 32 66 ee			ld (debug_mark+1),a  
ae3f 3a 49 ae			ld a, (.dmark+2)  
ae42 32 67 ee			ld (debug_mark+2),a  
ae45 18 03			jr .pastdmark  
ae47 ..			.dmark: db "DEC"  
ae4a f1			.pastdmark: pop af  
ae4b			endm  
# End of macro DMARK
ae4b						CALLMONITOR 
ae4b cd 6f ee			call debug_vector  
ae4e				endm  
# End of macro CALLMONITOR
ae4e					endif 
ae4e			 
ae4e 7e					ld a,(hl) 
ae4f 93					sub e 
ae50 77					ld (hl),a 
ae51			 
ae51			 
ae51					FORTH_DSP_POP 
ae51 cd 42 9d			call macro_forth_dsp_pop 
ae54				endm 
# End of macro FORTH_DSP_POP
ae54			 
ae54				       NEXTW 
ae54 c3 75 9e			jp macro_next 
ae57				endm 
# End of macro NEXTW
ae57			 
ae57			.INC2: 
ae57				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ae57 6f				db WORD_SYS_CORE+91             
ae58 04 af			dw .DEC2            
ae5a 04				db 3 + 1 
ae5b .. 00			db "+2!",0              
ae5f				endm 
# End of macro CWHEAD
ae5f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae5f			 
ae5f					if DEBUG_FORTH_WORDS_KEY 
ae5f						DMARK "+2s" 
ae5f f5				push af  
ae60 3a 74 ae			ld a, (.dmark)  
ae63 32 65 ee			ld (debug_mark),a  
ae66 3a 75 ae			ld a, (.dmark+1)  
ae69 32 66 ee			ld (debug_mark+1),a  
ae6c 3a 76 ae			ld a, (.dmark+2)  
ae6f 32 67 ee			ld (debug_mark+2),a  
ae72 18 03			jr .pastdmark  
ae74 ..			.dmark: db "+2s"  
ae77 f1			.pastdmark: pop af  
ae78			endm  
# End of macro DMARK
ae78						CALLMONITOR 
ae78 cd 6f ee			call debug_vector  
ae7b				endm  
# End of macro CALLMONITOR
ae7b					endif 
ae7b			 
ae7b					; Address 
ae7b			 
ae7b					FORTH_DSP_VALUEHL 
ae7b cd 8a 9c			call macro_dsp_valuehl 
ae7e				endm 
# End of macro FORTH_DSP_VALUEHL
ae7e			 
ae7e e5					push hl    ; save address 
ae7f			 
ae7f					; load content into de 
ae7f			 
ae7f 5e					ld e,(hl) 
ae80 23					inc hl 
ae81 56					ld d, (hl) 
ae82			 
ae82					if DEBUG_FORTH_WORDS 
ae82						DMARK "+2a" 
ae82 f5				push af  
ae83 3a 97 ae			ld a, (.dmark)  
ae86 32 65 ee			ld (debug_mark),a  
ae89 3a 98 ae			ld a, (.dmark+1)  
ae8c 32 66 ee			ld (debug_mark+1),a  
ae8f 3a 99 ae			ld a, (.dmark+2)  
ae92 32 67 ee			ld (debug_mark+2),a  
ae95 18 03			jr .pastdmark  
ae97 ..			.dmark: db "+2a"  
ae9a f1			.pastdmark: pop af  
ae9b			endm  
# End of macro DMARK
ae9b						CALLMONITOR 
ae9b cd 6f ee			call debug_vector  
ae9e				endm  
# End of macro CALLMONITOR
ae9e					endif 
ae9e			 
ae9e					FORTH_DSP_POP 
ae9e cd 42 9d			call macro_forth_dsp_pop 
aea1				endm 
# End of macro FORTH_DSP_POP
aea1			 
aea1					; Get value to add 
aea1			 
aea1					FORTH_DSP_VALUE 
aea1 cd 73 9c			call macro_forth_dsp_value 
aea4				endm 
# End of macro FORTH_DSP_VALUE
aea4			 
aea4					if DEBUG_FORTH_WORDS 
aea4						DMARK "+2v" 
aea4 f5				push af  
aea5 3a b9 ae			ld a, (.dmark)  
aea8 32 65 ee			ld (debug_mark),a  
aeab 3a ba ae			ld a, (.dmark+1)  
aeae 32 66 ee			ld (debug_mark+1),a  
aeb1 3a bb ae			ld a, (.dmark+2)  
aeb4 32 67 ee			ld (debug_mark+2),a  
aeb7 18 03			jr .pastdmark  
aeb9 ..			.dmark: db "+2v"  
aebc f1			.pastdmark: pop af  
aebd			endm  
# End of macro DMARK
aebd						CALLMONITOR 
aebd cd 6f ee			call debug_vector  
aec0				endm  
# End of macro CALLMONITOR
aec0					endif 
aec0			 
aec0 19					add hl, de 
aec1			 
aec1					if DEBUG_FORTH_WORDS 
aec1						DMARK "+2+" 
aec1 f5				push af  
aec2 3a d6 ae			ld a, (.dmark)  
aec5 32 65 ee			ld (debug_mark),a  
aec8 3a d7 ae			ld a, (.dmark+1)  
aecb 32 66 ee			ld (debug_mark+1),a  
aece 3a d8 ae			ld a, (.dmark+2)  
aed1 32 67 ee			ld (debug_mark+2),a  
aed4 18 03			jr .pastdmark  
aed6 ..			.dmark: db "+2+"  
aed9 f1			.pastdmark: pop af  
aeda			endm  
# End of macro DMARK
aeda						CALLMONITOR 
aeda cd 6f ee			call debug_vector  
aedd				endm  
# End of macro CALLMONITOR
aedd					endif 
aedd			 
aedd					; move result to de 
aedd			 
aedd eb					ex de, hl 
aede			 
aede					; Address 
aede			 
aede e1					pop hl 
aedf			 
aedf					; save it back 
aedf			 
aedf 73					ld (hl), e 
aee0 23					inc hl 
aee1 72					ld (hl), d 
aee2			 
aee2					if DEBUG_FORTH_WORDS 
aee2						DMARK "+2e" 
aee2 f5				push af  
aee3 3a f7 ae			ld a, (.dmark)  
aee6 32 65 ee			ld (debug_mark),a  
aee9 3a f8 ae			ld a, (.dmark+1)  
aeec 32 66 ee			ld (debug_mark+1),a  
aeef 3a f9 ae			ld a, (.dmark+2)  
aef2 32 67 ee			ld (debug_mark+2),a  
aef5 18 03			jr .pastdmark  
aef7 ..			.dmark: db "+2e"  
aefa f1			.pastdmark: pop af  
aefb			endm  
# End of macro DMARK
aefb						CALLMONITOR 
aefb cd 6f ee			call debug_vector  
aefe				endm  
# End of macro CALLMONITOR
aefe					endif 
aefe			 
aefe			 
aefe			 
aefe					FORTH_DSP_POP 
aefe cd 42 9d			call macro_forth_dsp_pop 
af01				endm 
# End of macro FORTH_DSP_POP
af01			 
af01			 
af01				       NEXTW 
af01 c3 75 9e			jp macro_next 
af04				endm 
# End of macro NEXTW
af04			 
af04			.DEC2: 
af04				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
af04 6f				db WORD_SYS_CORE+91             
af05 b3 af			dw .GET2            
af07 04				db 3 + 1 
af08 .. 00			db "-2!",0              
af0c				endm 
# End of macro CWHEAD
af0c			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
af0c			 
af0c			 
af0c					if DEBUG_FORTH_WORDS_KEY 
af0c						DMARK "-2s" 
af0c f5				push af  
af0d 3a 21 af			ld a, (.dmark)  
af10 32 65 ee			ld (debug_mark),a  
af13 3a 22 af			ld a, (.dmark+1)  
af16 32 66 ee			ld (debug_mark+1),a  
af19 3a 23 af			ld a, (.dmark+2)  
af1c 32 67 ee			ld (debug_mark+2),a  
af1f 18 03			jr .pastdmark  
af21 ..			.dmark: db "-2s"  
af24 f1			.pastdmark: pop af  
af25			endm  
# End of macro DMARK
af25						CALLMONITOR 
af25 cd 6f ee			call debug_vector  
af28				endm  
# End of macro CALLMONITOR
af28					endif 
af28			 
af28					; Address 
af28			 
af28					FORTH_DSP_VALUEHL 
af28 cd 8a 9c			call macro_dsp_valuehl 
af2b				endm 
# End of macro FORTH_DSP_VALUEHL
af2b			 
af2b e5					push hl    ; save address 
af2c			 
af2c					; load content into de 
af2c			 
af2c 5e					ld e,(hl) 
af2d 23					inc hl 
af2e 56					ld d, (hl) 
af2f			 
af2f					if DEBUG_FORTH_WORDS 
af2f						DMARK "-2a" 
af2f f5				push af  
af30 3a 44 af			ld a, (.dmark)  
af33 32 65 ee			ld (debug_mark),a  
af36 3a 45 af			ld a, (.dmark+1)  
af39 32 66 ee			ld (debug_mark+1),a  
af3c 3a 46 af			ld a, (.dmark+2)  
af3f 32 67 ee			ld (debug_mark+2),a  
af42 18 03			jr .pastdmark  
af44 ..			.dmark: db "-2a"  
af47 f1			.pastdmark: pop af  
af48			endm  
# End of macro DMARK
af48						CALLMONITOR 
af48 cd 6f ee			call debug_vector  
af4b				endm  
# End of macro CALLMONITOR
af4b					endif 
af4b			 
af4b					FORTH_DSP_POP 
af4b cd 42 9d			call macro_forth_dsp_pop 
af4e				endm 
# End of macro FORTH_DSP_POP
af4e			 
af4e					; Get value to remove 
af4e			 
af4e					FORTH_DSP_VALUE 
af4e cd 73 9c			call macro_forth_dsp_value 
af51				endm 
# End of macro FORTH_DSP_VALUE
af51			 
af51					if DEBUG_FORTH_WORDS 
af51						DMARK "-2v" 
af51 f5				push af  
af52 3a 66 af			ld a, (.dmark)  
af55 32 65 ee			ld (debug_mark),a  
af58 3a 67 af			ld a, (.dmark+1)  
af5b 32 66 ee			ld (debug_mark+1),a  
af5e 3a 68 af			ld a, (.dmark+2)  
af61 32 67 ee			ld (debug_mark+2),a  
af64 18 03			jr .pastdmark  
af66 ..			.dmark: db "-2v"  
af69 f1			.pastdmark: pop af  
af6a			endm  
# End of macro DMARK
af6a						CALLMONITOR 
af6a cd 6f ee			call debug_vector  
af6d				endm  
# End of macro CALLMONITOR
af6d					endif 
af6d			 
af6d eb					ex de, hl 
af6e ed 52				sbc hl, de 
af70			 
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "-2d" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 65 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 66 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 67 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "-2d"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89						CALLMONITOR 
af89 cd 6f ee			call debug_vector  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c			 
af8c					; move result to de 
af8c			 
af8c eb					ex de, hl 
af8d			 
af8d					; Address 
af8d			 
af8d e1					pop hl 
af8e			 
af8e					; save it back 
af8e			 
af8e 73					ld (hl), e 
af8f 23					inc hl 
af90 72					ld (hl), d 
af91			 
af91					if DEBUG_FORTH_WORDS 
af91						DMARK "-2e" 
af91 f5				push af  
af92 3a a6 af			ld a, (.dmark)  
af95 32 65 ee			ld (debug_mark),a  
af98 3a a7 af			ld a, (.dmark+1)  
af9b 32 66 ee			ld (debug_mark+1),a  
af9e 3a a8 af			ld a, (.dmark+2)  
afa1 32 67 ee			ld (debug_mark+2),a  
afa4 18 03			jr .pastdmark  
afa6 ..			.dmark: db "-2e"  
afa9 f1			.pastdmark: pop af  
afaa			endm  
# End of macro DMARK
afaa						CALLMONITOR 
afaa cd 6f ee			call debug_vector  
afad				endm  
# End of macro CALLMONITOR
afad					endif 
afad			 
afad			 
afad					FORTH_DSP_POP 
afad cd 42 9d			call macro_forth_dsp_pop 
afb0				endm 
# End of macro FORTH_DSP_POP
afb0			 
afb0			 
afb0			 
afb0				       NEXTW 
afb0 c3 75 9e			jp macro_next 
afb3				endm 
# End of macro NEXTW
afb3			.GET2: 
afb3				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
afb3 6f				db WORD_SYS_CORE+91             
afb4 e8 af			dw .BANG2            
afb6 03				db 2 + 1 
afb7 .. 00			db "2@",0              
afba				endm 
# End of macro CWHEAD
afba			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
afba					if DEBUG_FORTH_WORDS_KEY 
afba						DMARK "2A_" 
afba f5				push af  
afbb 3a cf af			ld a, (.dmark)  
afbe 32 65 ee			ld (debug_mark),a  
afc1 3a d0 af			ld a, (.dmark+1)  
afc4 32 66 ee			ld (debug_mark+1),a  
afc7 3a d1 af			ld a, (.dmark+2)  
afca 32 67 ee			ld (debug_mark+2),a  
afcd 18 03			jr .pastdmark  
afcf ..			.dmark: db "2A_"  
afd2 f1			.pastdmark: pop af  
afd3			endm  
# End of macro DMARK
afd3						CALLMONITOR 
afd3 cd 6f ee			call debug_vector  
afd6				endm  
# End of macro CALLMONITOR
afd6					endif 
afd6			 
afd6					FORTH_DSP_VALUEHL 
afd6 cd 8a 9c			call macro_dsp_valuehl 
afd9				endm 
# End of macro FORTH_DSP_VALUEHL
afd9			 
afd9 e5					push hl   ; save address 
afda			 
afda					FORTH_DSP_POP 
afda cd 42 9d			call macro_forth_dsp_pop 
afdd				endm 
# End of macro FORTH_DSP_POP
afdd			 
afdd e1					pop hl 
afde			 
afde 5e					ld e, (hl) 
afdf 23					inc hl 
afe0 56					ld d, (hl) 
afe1			 
afe1 eb					ex de, hl 
afe2			 
afe2 cd 85 9a				call forth_push_numhl 
afe5			 
afe5				       NEXTW 
afe5 c3 75 9e			jp macro_next 
afe8				endm 
# End of macro NEXTW
afe8			.BANG2: 
afe8				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
afe8 6f				db WORD_SYS_CORE+91             
afe9 20 b0			dw .CONFIG            
afeb 03				db 2 + 1 
afec .. 00			db "2!",0              
afef				endm 
# End of macro CWHEAD
afef			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
afef					if DEBUG_FORTH_WORDS_KEY 
afef						DMARK "2S_" 
afef f5				push af  
aff0 3a 04 b0			ld a, (.dmark)  
aff3 32 65 ee			ld (debug_mark),a  
aff6 3a 05 b0			ld a, (.dmark+1)  
aff9 32 66 ee			ld (debug_mark+1),a  
affc 3a 06 b0			ld a, (.dmark+2)  
afff 32 67 ee			ld (debug_mark+2),a  
b002 18 03			jr .pastdmark  
b004 ..			.dmark: db "2S_"  
b007 f1			.pastdmark: pop af  
b008			endm  
# End of macro DMARK
b008						CALLMONITOR 
b008 cd 6f ee			call debug_vector  
b00b				endm  
# End of macro CALLMONITOR
b00b					endif 
b00b			 
b00b					FORTH_DSP_VALUEHL 
b00b cd 8a 9c			call macro_dsp_valuehl 
b00e				endm 
# End of macro FORTH_DSP_VALUEHL
b00e			 
b00e e5					push hl   ; save address 
b00f			 
b00f			 
b00f					FORTH_DSP_POP 
b00f cd 42 9d			call macro_forth_dsp_pop 
b012				endm 
# End of macro FORTH_DSP_POP
b012			 
b012					 
b012					FORTH_DSP_VALUEHL 
b012 cd 8a 9c			call macro_dsp_valuehl 
b015				endm 
# End of macro FORTH_DSP_VALUEHL
b015			 
b015					FORTH_DSP_POP 
b015 cd 42 9d			call macro_forth_dsp_pop 
b018				endm 
# End of macro FORTH_DSP_POP
b018			 
b018 eb					ex de, hl    ; value now in de 
b019			 
b019 e1					pop hl 
b01a			 
b01a 73					ld (hl), e 
b01b			 
b01b 23					inc hl 
b01c			 
b01c 72					ld (hl), d 
b01d			 
b01d			 
b01d				       NEXTW 
b01d c3 75 9e			jp macro_next 
b020				endm 
# End of macro NEXTW
b020			.CONFIG: 
b020				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
b020 6f				db WORD_SYS_CORE+91             
b021 31 b0			dw .ADTOS            
b023 07				db 6 + 1 
b024 .. 00			db "CONFIG",0              
b02b				endm 
# End of macro CWHEAD
b02b			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
b02b			 
b02b cd 5e 92				call config 
b02e					NEXTW 
b02e c3 75 9e			jp macro_next 
b031				endm 
# End of macro NEXTW
b031			 
b031			.ADTOS: 
b031				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
b031 6f				db WORD_SYS_CORE+91             
b032 47 b0			dw .SBTOS            
b034 03				db 2 + 1 
b035 .. 00			db "1+",0              
b038				endm 
# End of macro CWHEAD
b038			; | 1+ ( u -- u )  Increment value on TOS | DONE 
b038			 
b038					FORTH_DSP_VALUEHL 
b038 cd 8a 9c			call macro_dsp_valuehl 
b03b				endm 
# End of macro FORTH_DSP_VALUEHL
b03b e5					push hl 
b03c			 
b03c					FORTH_DSP_POP 
b03c cd 42 9d			call macro_forth_dsp_pop 
b03f				endm 
# End of macro FORTH_DSP_POP
b03f e1					pop hl 
b040			 
b040 23					inc hl 
b041 cd 85 9a				call forth_push_numhl 
b044					 
b044					NEXTW 
b044 c3 75 9e			jp macro_next 
b047				endm 
# End of macro NEXTW
b047			.SBTOS: 
b047				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
b047 6f				db WORD_SYS_CORE+91             
b048 5d b0			dw .ADSTORE            
b04a 03				db 2 + 1 
b04b .. 00			db "1-",0              
b04e				endm 
# End of macro CWHEAD
b04e			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b04e			 
b04e					FORTH_DSP_VALUEHL 
b04e cd 8a 9c			call macro_dsp_valuehl 
b051				endm 
# End of macro FORTH_DSP_VALUEHL
b051 e5					push hl 
b052			 
b052					FORTH_DSP_POP 
b052 cd 42 9d			call macro_forth_dsp_pop 
b055				endm 
# End of macro FORTH_DSP_POP
b055 e1					pop hl 
b056			 
b056 2b					dec hl 
b057 cd 85 9a				call forth_push_numhl 
b05a					 
b05a					NEXTW 
b05a c3 75 9e			jp macro_next 
b05d				endm 
# End of macro NEXTW
b05d			.ADSTORE: 
b05d				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b05d 6f				db WORD_SYS_CORE+91             
b05e 73 b0			dw .ADWSTORE            
b060 04				db 3 + 1 
b061 .. 00			db "1+!",0              
b065				endm 
# End of macro CWHEAD
b065			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b065			 
b065					FORTH_DSP_VALUEHL 
b065 cd 8a 9c			call macro_dsp_valuehl 
b068				endm 
# End of macro FORTH_DSP_VALUEHL
b068 e5					push hl 
b069			 
b069					FORTH_DSP_POP 
b069 cd 42 9d			call macro_forth_dsp_pop 
b06c				endm 
# End of macro FORTH_DSP_POP
b06c e1					pop hl 
b06d			 
b06d 7e					ld a, (hl) 
b06e 3c					inc a 
b06f 77					ld (hl), a 
b070					 
b070					NEXTW 
b070 c3 75 9e			jp macro_next 
b073				endm 
# End of macro NEXTW
b073			.ADWSTORE: 
b073				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b073 6f				db WORD_SYS_CORE+91             
b074 91 b0			dw .SBSTORE            
b076 05				db 4 + 1 
b077 .. 00			db "1+2!",0              
b07c				endm 
# End of macro CWHEAD
b07c			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b07c			 
b07c					FORTH_DSP_VALUEHL 
b07c cd 8a 9c			call macro_dsp_valuehl 
b07f				endm 
# End of macro FORTH_DSP_VALUEHL
b07f e5					push hl 
b080			 
b080					FORTH_DSP_POP 
b080 cd 42 9d			call macro_forth_dsp_pop 
b083				endm 
# End of macro FORTH_DSP_POP
b083 e1					pop hl 
b084			 
b084 e5					push hl 
b085			 
b085 cd f7 9d				call loadwordinhl 
b088 23					inc hl 
b089			 
b089 d1					pop de 
b08a eb					ex de, hl 
b08b 73					ld (hl), e 
b08c 23					inc hl 
b08d 72					ld (hl), d 
b08e					 
b08e					NEXTW 
b08e c3 75 9e			jp macro_next 
b091				endm 
# End of macro NEXTW
b091			.SBSTORE: 
b091				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b091 6f				db WORD_SYS_CORE+91             
b092 a7 b0			dw .SBWSTORE            
b094 04				db 3 + 1 
b095 .. 00			db "1-!",0              
b099				endm 
# End of macro CWHEAD
b099			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b099			 
b099					FORTH_DSP_VALUEHL 
b099 cd 8a 9c			call macro_dsp_valuehl 
b09c				endm 
# End of macro FORTH_DSP_VALUEHL
b09c e5					push hl 
b09d			 
b09d					FORTH_DSP_POP 
b09d cd 42 9d			call macro_forth_dsp_pop 
b0a0				endm 
# End of macro FORTH_DSP_POP
b0a0 e1					pop hl 
b0a1			 
b0a1 7e					ld a, (hl) 
b0a2 3d					dec a 
b0a3 77					ld (hl), a 
b0a4					 
b0a4					NEXTW 
b0a4 c3 75 9e			jp macro_next 
b0a7				endm 
# End of macro NEXTW
b0a7			.SBWSTORE: 
b0a7				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b0a7 6f				db WORD_SYS_CORE+91             
b0a8 c5 b0			dw .ENDCORE            
b0aa 05				db 4 + 1 
b0ab .. 00			db "1-2!",0              
b0b0				endm 
# End of macro CWHEAD
b0b0			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b0b0			 
b0b0					FORTH_DSP_VALUEHL 
b0b0 cd 8a 9c			call macro_dsp_valuehl 
b0b3				endm 
# End of macro FORTH_DSP_VALUEHL
b0b3 e5					push hl 
b0b4			 
b0b4					FORTH_DSP_POP 
b0b4 cd 42 9d			call macro_forth_dsp_pop 
b0b7				endm 
# End of macro FORTH_DSP_POP
b0b7 e1					pop hl 
b0b8			 
b0b8 e5					push hl 
b0b9			 
b0b9 cd f7 9d				call loadwordinhl 
b0bc 2b					dec hl 
b0bd			 
b0bd d1					pop de 
b0be eb					ex de, hl 
b0bf 73					ld (hl), e 
b0c0 23					inc hl 
b0c1 72					ld (hl), d 
b0c2					 
b0c2					NEXTW 
b0c2 c3 75 9e			jp macro_next 
b0c5				endm 
# End of macro NEXTW
b0c5			.ENDCORE: 
b0c5			 
b0c5			; eof 
b0c5			 
b0c5			 
# End of file forth_words_core.asm
b0c5			include "forth_words_flow.asm" 
b0c5			 
b0c5			; | ## Program Flow Words 
b0c5			 
b0c5			.IF: 
b0c5				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b0c5 1e				db WORD_SYS_CORE+10             
b0c6 ba b1			dw .THEN            
b0c8 03				db 2 + 1 
b0c9 .. 00			db "IF",0              
b0cc				endm 
# End of macro CWHEAD
b0cc			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
b0cc			; | | Note: currently not supporting ELSE or nested IF 
b0cc			; 
b0cc					if DEBUG_FORTH_WORDS_KEY 
b0cc						DMARK "IF." 
b0cc f5				push af  
b0cd 3a e1 b0			ld a, (.dmark)  
b0d0 32 65 ee			ld (debug_mark),a  
b0d3 3a e2 b0			ld a, (.dmark+1)  
b0d6 32 66 ee			ld (debug_mark+1),a  
b0d9 3a e3 b0			ld a, (.dmark+2)  
b0dc 32 67 ee			ld (debug_mark+2),a  
b0df 18 03			jr .pastdmark  
b0e1 ..			.dmark: db "IF."  
b0e4 f1			.pastdmark: pop af  
b0e5			endm  
# End of macro DMARK
b0e5						CALLMONITOR 
b0e5 cd 6f ee			call debug_vector  
b0e8				endm  
# End of macro CALLMONITOR
b0e8					endif 
b0e8			; eval TOS 
b0e8			 
b0e8				FORTH_DSP_VALUEHL 
b0e8 cd 8a 9c			call macro_dsp_valuehl 
b0eb				endm 
# End of macro FORTH_DSP_VALUEHL
b0eb			 
b0eb			;	push hl 
b0eb				FORTH_DSP_POP 
b0eb cd 42 9d			call macro_forth_dsp_pop 
b0ee				endm 
# End of macro FORTH_DSP_POP
b0ee			;	pop hl 
b0ee			 
b0ee					if DEBUG_FORTH_WORDS 
b0ee						DMARK "IF1" 
b0ee f5				push af  
b0ef 3a 03 b1			ld a, (.dmark)  
b0f2 32 65 ee			ld (debug_mark),a  
b0f5 3a 04 b1			ld a, (.dmark+1)  
b0f8 32 66 ee			ld (debug_mark+1),a  
b0fb 3a 05 b1			ld a, (.dmark+2)  
b0fe 32 67 ee			ld (debug_mark+2),a  
b101 18 03			jr .pastdmark  
b103 ..			.dmark: db "IF1"  
b106 f1			.pastdmark: pop af  
b107			endm  
# End of macro DMARK
b107						CALLMONITOR 
b107 cd 6f ee			call debug_vector  
b10a				endm  
# End of macro CALLMONITOR
b10a					endif 
b10a b7				or a        ; clear carry flag 
b10b 11 00 00			ld de, 0 
b10e eb				ex de,hl 
b10f ed 52			sbc hl, de 
b111 c2 9b b1			jp nz, .iftrue 
b114			 
b114					if DEBUG_FORTH_WORDS 
b114						DMARK "IF2" 
b114 f5				push af  
b115 3a 29 b1			ld a, (.dmark)  
b118 32 65 ee			ld (debug_mark),a  
b11b 3a 2a b1			ld a, (.dmark+1)  
b11e 32 66 ee			ld (debug_mark+1),a  
b121 3a 2b b1			ld a, (.dmark+2)  
b124 32 67 ee			ld (debug_mark+2),a  
b127 18 03			jr .pastdmark  
b129 ..			.dmark: db "IF2"  
b12c f1			.pastdmark: pop af  
b12d			endm  
# End of macro DMARK
b12d						CALLMONITOR 
b12d cd 6f ee			call debug_vector  
b130				endm  
# End of macro CALLMONITOR
b130					endif 
b130			 
b130			; if not true then skip to THEN 
b130			 
b130				; TODO get tok_ptr 
b130				; TODO consume toks until we get to THEN 
b130			 
b130 2a bc e5			ld hl, (os_tok_ptr) 
b133					if DEBUG_FORTH_WORDS 
b133						DMARK "IF3" 
b133 f5				push af  
b134 3a 48 b1			ld a, (.dmark)  
b137 32 65 ee			ld (debug_mark),a  
b13a 3a 49 b1			ld a, (.dmark+1)  
b13d 32 66 ee			ld (debug_mark+1),a  
b140 3a 4a b1			ld a, (.dmark+2)  
b143 32 67 ee			ld (debug_mark+2),a  
b146 18 03			jr .pastdmark  
b148 ..			.dmark: db "IF3"  
b14b f1			.pastdmark: pop af  
b14c			endm  
# End of macro DMARK
b14c						CALLMONITOR 
b14c cd 6f ee			call debug_vector  
b14f				endm  
# End of macro CALLMONITOR
b14f						 
b14f					endif 
b14f 11 96 b1			ld de, .ifthen 
b152					if DEBUG_FORTH_WORDS 
b152						DMARK "IF4" 
b152 f5				push af  
b153 3a 67 b1			ld a, (.dmark)  
b156 32 65 ee			ld (debug_mark),a  
b159 3a 68 b1			ld a, (.dmark+1)  
b15c 32 66 ee			ld (debug_mark+1),a  
b15f 3a 69 b1			ld a, (.dmark+2)  
b162 32 67 ee			ld (debug_mark+2),a  
b165 18 03			jr .pastdmark  
b167 ..			.dmark: db "IF4"  
b16a f1			.pastdmark: pop af  
b16b			endm  
# End of macro DMARK
b16b						CALLMONITOR 
b16b cd 6f ee			call debug_vector  
b16e				endm  
# End of macro CALLMONITOR
b16e					endif 
b16e cd 7c 9f			call findnexttok  
b171			 
b171					if DEBUG_FORTH_WORDS 
b171						DMARK "IF5" 
b171 f5				push af  
b172 3a 86 b1			ld a, (.dmark)  
b175 32 65 ee			ld (debug_mark),a  
b178 3a 87 b1			ld a, (.dmark+1)  
b17b 32 66 ee			ld (debug_mark+1),a  
b17e 3a 88 b1			ld a, (.dmark+2)  
b181 32 67 ee			ld (debug_mark+2),a  
b184 18 03			jr .pastdmark  
b186 ..			.dmark: db "IF5"  
b189 f1			.pastdmark: pop af  
b18a			endm  
# End of macro DMARK
b18a						CALLMONITOR 
b18a cd 6f ee			call debug_vector  
b18d				endm  
# End of macro CALLMONITOR
b18d					endif 
b18d				; TODO replace below with ; exec using tok_ptr 
b18d 22 bc e5			ld (os_tok_ptr), hl 
b190 c3 fe 9e			jp exec1 
b193				NEXTW 
b193 c3 75 9e			jp macro_next 
b196				endm 
# End of macro NEXTW
b196			 
b196 .. 00		.ifthen:  db "THEN",0 
b19b			 
b19b			.iftrue:		 
b19b				; Exec next words normally 
b19b			 
b19b				; if true then exec following IF as normal 
b19b					if DEBUG_FORTH_WORDS 
b19b						DMARK "IFT" 
b19b f5				push af  
b19c 3a b0 b1			ld a, (.dmark)  
b19f 32 65 ee			ld (debug_mark),a  
b1a2 3a b1 b1			ld a, (.dmark+1)  
b1a5 32 66 ee			ld (debug_mark+1),a  
b1a8 3a b2 b1			ld a, (.dmark+2)  
b1ab 32 67 ee			ld (debug_mark+2),a  
b1ae 18 03			jr .pastdmark  
b1b0 ..			.dmark: db "IFT"  
b1b3 f1			.pastdmark: pop af  
b1b4			endm  
# End of macro DMARK
b1b4						CALLMONITOR 
b1b4 cd 6f ee			call debug_vector  
b1b7				endm  
# End of macro CALLMONITOR
b1b7					endif 
b1b7			 
b1b7					NEXTW 
b1b7 c3 75 9e			jp macro_next 
b1ba				endm 
# End of macro NEXTW
b1ba			.THEN: 
b1ba				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b1ba 1f				db WORD_SYS_CORE+11             
b1bb e2 b1			dw .ELSE            
b1bd 05				db 4 + 1 
b1be .. 00			db "THEN",0              
b1c3				endm 
# End of macro CWHEAD
b1c3			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b1c3					if DEBUG_FORTH_WORDS_KEY 
b1c3						DMARK "THN" 
b1c3 f5				push af  
b1c4 3a d8 b1			ld a, (.dmark)  
b1c7 32 65 ee			ld (debug_mark),a  
b1ca 3a d9 b1			ld a, (.dmark+1)  
b1cd 32 66 ee			ld (debug_mark+1),a  
b1d0 3a da b1			ld a, (.dmark+2)  
b1d3 32 67 ee			ld (debug_mark+2),a  
b1d6 18 03			jr .pastdmark  
b1d8 ..			.dmark: db "THN"  
b1db f1			.pastdmark: pop af  
b1dc			endm  
# End of macro DMARK
b1dc						CALLMONITOR 
b1dc cd 6f ee			call debug_vector  
b1df				endm  
# End of macro CALLMONITOR
b1df					endif 
b1df					NEXTW 
b1df c3 75 9e			jp macro_next 
b1e2				endm 
# End of macro NEXTW
b1e2			.ELSE: 
b1e2				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1e2 20				db WORD_SYS_CORE+12             
b1e3 0a b2			dw .DO            
b1e5 03				db 2 + 1 
b1e6 .. 00			db "ELSE",0              
b1eb				endm 
# End of macro CWHEAD
b1eb			; | ELSE ( -- ) Not supported - does nothing | TODO 
b1eb			 
b1eb					if DEBUG_FORTH_WORDS_KEY 
b1eb						DMARK "ELS" 
b1eb f5				push af  
b1ec 3a 00 b2			ld a, (.dmark)  
b1ef 32 65 ee			ld (debug_mark),a  
b1f2 3a 01 b2			ld a, (.dmark+1)  
b1f5 32 66 ee			ld (debug_mark+1),a  
b1f8 3a 02 b2			ld a, (.dmark+2)  
b1fb 32 67 ee			ld (debug_mark+2),a  
b1fe 18 03			jr .pastdmark  
b200 ..			.dmark: db "ELS"  
b203 f1			.pastdmark: pop af  
b204			endm  
# End of macro DMARK
b204						CALLMONITOR 
b204 cd 6f ee			call debug_vector  
b207				endm  
# End of macro CALLMONITOR
b207					endif 
b207			 
b207			 
b207					NEXTW 
b207 c3 75 9e			jp macro_next 
b20a				endm 
# End of macro NEXTW
b20a			.DO: 
b20a				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b20a 21				db WORD_SYS_CORE+13             
b20b 31 b3			dw .LOOP            
b20d 03				db 2 + 1 
b20e .. 00			db "DO",0              
b211				endm 
# End of macro CWHEAD
b211			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b211			 
b211					if DEBUG_FORTH_WORDS_KEY 
b211						DMARK "DO." 
b211 f5				push af  
b212 3a 26 b2			ld a, (.dmark)  
b215 32 65 ee			ld (debug_mark),a  
b218 3a 27 b2			ld a, (.dmark+1)  
b21b 32 66 ee			ld (debug_mark+1),a  
b21e 3a 28 b2			ld a, (.dmark+2)  
b221 32 67 ee			ld (debug_mark+2),a  
b224 18 03			jr .pastdmark  
b226 ..			.dmark: db "DO."  
b229 f1			.pastdmark: pop af  
b22a			endm  
# End of macro DMARK
b22a						CALLMONITOR 
b22a cd 6f ee			call debug_vector  
b22d				endm  
# End of macro CALLMONITOR
b22d					endif 
b22d			;  push pc to rsp stack past the DO 
b22d			 
b22d 2a bc e5				ld hl, (os_tok_ptr) 
b230 23					inc hl   ; D 
b231 23					inc hl  ; O 
b232 23					inc hl   ; null 
b233					if DEBUG_FORTH_WORDS 
b233						DMARK "DO2" 
b233 f5				push af  
b234 3a 48 b2			ld a, (.dmark)  
b237 32 65 ee			ld (debug_mark),a  
b23a 3a 49 b2			ld a, (.dmark+1)  
b23d 32 66 ee			ld (debug_mark+1),a  
b240 3a 4a b2			ld a, (.dmark+2)  
b243 32 67 ee			ld (debug_mark+2),a  
b246 18 03			jr .pastdmark  
b248 ..			.dmark: db "DO2"  
b24b f1			.pastdmark: pop af  
b24c			endm  
# End of macro DMARK
b24c						CALLMONITOR 
b24c cd 6f ee			call debug_vector  
b24f				endm  
# End of macro CALLMONITOR
b24f					endif 
b24f					FORTH_RSP_NEXT 
b24f cd 2c 9a			call macro_forth_rsp_next 
b252				endm 
# End of macro FORTH_RSP_NEXT
b252					if DEBUG_FORTH_WORDS 
b252						DMARK "DO3" 
b252 f5				push af  
b253 3a 67 b2			ld a, (.dmark)  
b256 32 65 ee			ld (debug_mark),a  
b259 3a 68 b2			ld a, (.dmark+1)  
b25c 32 66 ee			ld (debug_mark+1),a  
b25f 3a 69 b2			ld a, (.dmark+2)  
b262 32 67 ee			ld (debug_mark+2),a  
b265 18 03			jr .pastdmark  
b267 ..			.dmark: db "DO3"  
b26a f1			.pastdmark: pop af  
b26b			endm  
# End of macro DMARK
b26b						CALLMONITOR 
b26b cd 6f ee			call debug_vector  
b26e				endm  
# End of macro CALLMONITOR
b26e					endif 
b26e			 
b26e					;if DEBUG_FORTH_WORDS 
b26e				;		push hl 
b26e			;		endif  
b26e			 
b26e			; get counters from data stack 
b26e			 
b26e			 
b26e					FORTH_DSP_VALUEHL 
b26e cd 8a 9c			call macro_dsp_valuehl 
b271				endm 
# End of macro FORTH_DSP_VALUEHL
b271 e5					push hl		 ; hl now has starting counter which needs to be tos 
b272			 
b272					if DEBUG_FORTH_WORDS 
b272						DMARK "DO4" 
b272 f5				push af  
b273 3a 87 b2			ld a, (.dmark)  
b276 32 65 ee			ld (debug_mark),a  
b279 3a 88 b2			ld a, (.dmark+1)  
b27c 32 66 ee			ld (debug_mark+1),a  
b27f 3a 89 b2			ld a, (.dmark+2)  
b282 32 67 ee			ld (debug_mark+2),a  
b285 18 03			jr .pastdmark  
b287 ..			.dmark: db "DO4"  
b28a f1			.pastdmark: pop af  
b28b			endm  
# End of macro DMARK
b28b						CALLMONITOR 
b28b cd 6f ee			call debug_vector  
b28e				endm  
# End of macro CALLMONITOR
b28e					endif 
b28e					FORTH_DSP_POP 
b28e cd 42 9d			call macro_forth_dsp_pop 
b291				endm 
# End of macro FORTH_DSP_POP
b291			 
b291					if DEBUG_FORTH_WORDS 
b291						DMARK "DO5" 
b291 f5				push af  
b292 3a a6 b2			ld a, (.dmark)  
b295 32 65 ee			ld (debug_mark),a  
b298 3a a7 b2			ld a, (.dmark+1)  
b29b 32 66 ee			ld (debug_mark+1),a  
b29e 3a a8 b2			ld a, (.dmark+2)  
b2a1 32 67 ee			ld (debug_mark+2),a  
b2a4 18 03			jr .pastdmark  
b2a6 ..			.dmark: db "DO5"  
b2a9 f1			.pastdmark: pop af  
b2aa			endm  
# End of macro DMARK
b2aa						CALLMONITOR 
b2aa cd 6f ee			call debug_vector  
b2ad				endm  
# End of macro CALLMONITOR
b2ad					endif 
b2ad			 
b2ad					FORTH_DSP_VALUEHL 
b2ad cd 8a 9c			call macro_dsp_valuehl 
b2b0				endm 
# End of macro FORTH_DSP_VALUEHL
b2b0			;		push hl		 ; hl now has starting limit counter 
b2b0			 
b2b0					if DEBUG_FORTH_WORDS 
b2b0						DMARK "DO6" 
b2b0 f5				push af  
b2b1 3a c5 b2			ld a, (.dmark)  
b2b4 32 65 ee			ld (debug_mark),a  
b2b7 3a c6 b2			ld a, (.dmark+1)  
b2ba 32 66 ee			ld (debug_mark+1),a  
b2bd 3a c7 b2			ld a, (.dmark+2)  
b2c0 32 67 ee			ld (debug_mark+2),a  
b2c3 18 03			jr .pastdmark  
b2c5 ..			.dmark: db "DO6"  
b2c8 f1			.pastdmark: pop af  
b2c9			endm  
# End of macro DMARK
b2c9						CALLMONITOR 
b2c9 cd 6f ee			call debug_vector  
b2cc				endm  
# End of macro CALLMONITOR
b2cc					endif 
b2cc					FORTH_DSP_POP 
b2cc cd 42 9d			call macro_forth_dsp_pop 
b2cf				endm 
# End of macro FORTH_DSP_POP
b2cf			 
b2cf			; put counters on the loop stack 
b2cf			 
b2cf			;		pop hl			 ; limit counter 
b2cf d1					pop de			; start counter 
b2d0			 
b2d0					; push limit counter 
b2d0			 
b2d0					if DEBUG_FORTH_WORDS 
b2d0						DMARK "DO7" 
b2d0 f5				push af  
b2d1 3a e5 b2			ld a, (.dmark)  
b2d4 32 65 ee			ld (debug_mark),a  
b2d7 3a e6 b2			ld a, (.dmark+1)  
b2da 32 66 ee			ld (debug_mark+1),a  
b2dd 3a e7 b2			ld a, (.dmark+2)  
b2e0 32 67 ee			ld (debug_mark+2),a  
b2e3 18 03			jr .pastdmark  
b2e5 ..			.dmark: db "DO7"  
b2e8 f1			.pastdmark: pop af  
b2e9			endm  
# End of macro DMARK
b2e9						CALLMONITOR 
b2e9 cd 6f ee			call debug_vector  
b2ec				endm  
# End of macro CALLMONITOR
b2ec					endif 
b2ec					FORTH_LOOP_NEXT 
b2ec cd bb 9c			call macro_forth_loop_next 
b2ef				endm 
# End of macro FORTH_LOOP_NEXT
b2ef			 
b2ef					; push start counter 
b2ef			 
b2ef eb					ex de, hl 
b2f0					if DEBUG_FORTH_WORDS 
b2f0						DMARK "DO7" 
b2f0 f5				push af  
b2f1 3a 05 b3			ld a, (.dmark)  
b2f4 32 65 ee			ld (debug_mark),a  
b2f7 3a 06 b3			ld a, (.dmark+1)  
b2fa 32 66 ee			ld (debug_mark+1),a  
b2fd 3a 07 b3			ld a, (.dmark+2)  
b300 32 67 ee			ld (debug_mark+2),a  
b303 18 03			jr .pastdmark  
b305 ..			.dmark: db "DO7"  
b308 f1			.pastdmark: pop af  
b309			endm  
# End of macro DMARK
b309						CALLMONITOR 
b309 cd 6f ee			call debug_vector  
b30c				endm  
# End of macro CALLMONITOR
b30c					endif 
b30c					FORTH_LOOP_NEXT 
b30c cd bb 9c			call macro_forth_loop_next 
b30f				endm 
# End of macro FORTH_LOOP_NEXT
b30f			 
b30f			 
b30f					; init first round of I counter 
b30f			 
b30f 22 e0 e5				ld (os_current_i), hl 
b312			 
b312					if DEBUG_FORTH_WORDS 
b312						DMARK "DO8" 
b312 f5				push af  
b313 3a 27 b3			ld a, (.dmark)  
b316 32 65 ee			ld (debug_mark),a  
b319 3a 28 b3			ld a, (.dmark+1)  
b31c 32 66 ee			ld (debug_mark+1),a  
b31f 3a 29 b3			ld a, (.dmark+2)  
b322 32 67 ee			ld (debug_mark+2),a  
b325 18 03			jr .pastdmark  
b327 ..			.dmark: db "DO8"  
b32a f1			.pastdmark: pop af  
b32b			endm  
# End of macro DMARK
b32b						CALLMONITOR 
b32b cd 6f ee			call debug_vector  
b32e				endm  
# End of macro CALLMONITOR
b32e					endif 
b32e			 
b32e					NEXTW 
b32e c3 75 9e			jp macro_next 
b331				endm 
# End of macro NEXTW
b331			.LOOP: 
b331				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b331 22				db WORD_SYS_CORE+14             
b332 49 b4			dw .I            
b334 05				db 4 + 1 
b335 .. 00			db "LOOP",0              
b33a				endm 
# End of macro CWHEAD
b33a			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b33a			 
b33a				; pop tos as current loop count to hl 
b33a			 
b33a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b33a			 
b33a				FORTH_LOOP_TOS 
b33a cd ee 9c			call macro_forth_loop_tos 
b33d				endm 
# End of macro FORTH_LOOP_TOS
b33d e5				push hl 
b33e			 
b33e					if DEBUG_FORTH_WORDS_KEY 
b33e						DMARK "LOP" 
b33e f5				push af  
b33f 3a 53 b3			ld a, (.dmark)  
b342 32 65 ee			ld (debug_mark),a  
b345 3a 54 b3			ld a, (.dmark+1)  
b348 32 66 ee			ld (debug_mark+1),a  
b34b 3a 55 b3			ld a, (.dmark+2)  
b34e 32 67 ee			ld (debug_mark+2),a  
b351 18 03			jr .pastdmark  
b353 ..			.dmark: db "LOP"  
b356 f1			.pastdmark: pop af  
b357			endm  
# End of macro DMARK
b357						CALLMONITOR 
b357 cd 6f ee			call debug_vector  
b35a				endm  
# End of macro CALLMONITOR
b35a					endif 
b35a				; next item on the stack is the limit. get it 
b35a			 
b35a			 
b35a				FORTH_LOOP_POP 
b35a cd f8 9c			call macro_forth_loop_pop 
b35d				endm 
# End of macro FORTH_LOOP_POP
b35d			 
b35d				FORTH_LOOP_TOS 
b35d cd ee 9c			call macro_forth_loop_tos 
b360				endm 
# End of macro FORTH_LOOP_TOS
b360			 
b360 d1				pop de		 ; de = i, hl = limit 
b361			 
b361					if DEBUG_FORTH_WORDS 
b361						DMARK "LP1" 
b361 f5				push af  
b362 3a 76 b3			ld a, (.dmark)  
b365 32 65 ee			ld (debug_mark),a  
b368 3a 77 b3			ld a, (.dmark+1)  
b36b 32 66 ee			ld (debug_mark+1),a  
b36e 3a 78 b3			ld a, (.dmark+2)  
b371 32 67 ee			ld (debug_mark+2),a  
b374 18 03			jr .pastdmark  
b376 ..			.dmark: db "LP1"  
b379 f1			.pastdmark: pop af  
b37a			endm  
# End of macro DMARK
b37a						CALLMONITOR 
b37a cd 6f ee			call debug_vector  
b37d				endm  
# End of macro CALLMONITOR
b37d					endif 
b37d			 
b37d				; go back to previous word 
b37d			 
b37d d5				push de    ; save I for inc later 
b37e			 
b37e			 
b37e				; get limit 
b37e				;  is I at limit? 
b37e			 
b37e			 
b37e					if DEBUG_FORTH_WORDS 
b37e						DMARK "LP1" 
b37e f5				push af  
b37f 3a 93 b3			ld a, (.dmark)  
b382 32 65 ee			ld (debug_mark),a  
b385 3a 94 b3			ld a, (.dmark+1)  
b388 32 66 ee			ld (debug_mark+1),a  
b38b 3a 95 b3			ld a, (.dmark+2)  
b38e 32 67 ee			ld (debug_mark+2),a  
b391 18 03			jr .pastdmark  
b393 ..			.dmark: db "LP1"  
b396 f1			.pastdmark: pop af  
b397			endm  
# End of macro DMARK
b397						CALLMONITOR 
b397 cd 6f ee			call debug_vector  
b39a				endm  
# End of macro CALLMONITOR
b39a					endif 
b39a			 
b39a ed 52			sbc hl, de 
b39c			 
b39c			 
b39c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b39c			 
b39c 20 26				jr nz, .loopnotdone 
b39e			 
b39e e1				pop hl   ; get rid of saved I 
b39f				FORTH_LOOP_POP     ; get rid of limit 
b39f cd f8 9c			call macro_forth_loop_pop 
b3a2				endm 
# End of macro FORTH_LOOP_POP
b3a2			 
b3a2				FORTH_RSP_POP     ; get rid of DO ptr 
b3a2 cd 4d 9a			call macro_forth_rsp_pop 
b3a5				endm 
# End of macro FORTH_RSP_POP
b3a5			 
b3a5			if DEBUG_FORTH_WORDS 
b3a5						DMARK "LP>" 
b3a5 f5				push af  
b3a6 3a ba b3			ld a, (.dmark)  
b3a9 32 65 ee			ld (debug_mark),a  
b3ac 3a bb b3			ld a, (.dmark+1)  
b3af 32 66 ee			ld (debug_mark+1),a  
b3b2 3a bc b3			ld a, (.dmark+2)  
b3b5 32 67 ee			ld (debug_mark+2),a  
b3b8 18 03			jr .pastdmark  
b3ba ..			.dmark: db "LP>"  
b3bd f1			.pastdmark: pop af  
b3be			endm  
# End of macro DMARK
b3be				CALLMONITOR 
b3be cd 6f ee			call debug_vector  
b3c1				endm  
# End of macro CALLMONITOR
b3c1			endif 
b3c1			 
b3c1					NEXTW 
b3c1 c3 75 9e			jp macro_next 
b3c4				endm 
# End of macro NEXTW
b3c4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3c4			 
b3c4			.loopnotdone: 
b3c4			 
b3c4 e1				pop hl    ; get I 
b3c5 23				inc hl 
b3c6			 
b3c6			   	; save new I 
b3c6			 
b3c6			 
b3c6					; set I counter 
b3c6			 
b3c6 22 e0 e5				ld (os_current_i), hl 
b3c9			 
b3c9					if DEBUG_FORTH_WORDS 
b3c9						DMARK "LPN" 
b3c9 f5				push af  
b3ca 3a de b3			ld a, (.dmark)  
b3cd 32 65 ee			ld (debug_mark),a  
b3d0 3a df b3			ld a, (.dmark+1)  
b3d3 32 66 ee			ld (debug_mark+1),a  
b3d6 3a e0 b3			ld a, (.dmark+2)  
b3d9 32 67 ee			ld (debug_mark+2),a  
b3dc 18 03			jr .pastdmark  
b3de ..			.dmark: db "LPN"  
b3e1 f1			.pastdmark: pop af  
b3e2			endm  
# End of macro DMARK
b3e2					CALLMONITOR 
b3e2 cd 6f ee			call debug_vector  
b3e5				endm  
# End of macro CALLMONITOR
b3e5					endif 
b3e5					 
b3e5				FORTH_LOOP_NEXT 
b3e5 cd bb 9c			call macro_forth_loop_next 
b3e8				endm 
# End of macro FORTH_LOOP_NEXT
b3e8			 
b3e8			 
b3e8					if DEBUG_FORTH_WORDS 
b3e8 eb						ex de,hl 
b3e9					endif 
b3e9			 
b3e9			;	; get DO ptr 
b3e9			; 
b3e9					if DEBUG_FORTH_WORDS 
b3e9						DMARK "LP7" 
b3e9 f5				push af  
b3ea 3a fe b3			ld a, (.dmark)  
b3ed 32 65 ee			ld (debug_mark),a  
b3f0 3a ff b3			ld a, (.dmark+1)  
b3f3 32 66 ee			ld (debug_mark+1),a  
b3f6 3a 00 b4			ld a, (.dmark+2)  
b3f9 32 67 ee			ld (debug_mark+2),a  
b3fc 18 03			jr .pastdmark  
b3fe ..			.dmark: db "LP7"  
b401 f1			.pastdmark: pop af  
b402			endm  
# End of macro DMARK
b402					CALLMONITOR 
b402 cd 6f ee			call debug_vector  
b405				endm  
# End of macro CALLMONITOR
b405					endif 
b405				FORTH_RSP_TOS 
b405 cd 43 9a			call macro_forth_rsp_tos 
b408				endm 
# End of macro FORTH_RSP_TOS
b408			 
b408					if DEBUG_FORTH_WORDS 
b408						DMARK "LP8" 
b408 f5				push af  
b409 3a 1d b4			ld a, (.dmark)  
b40c 32 65 ee			ld (debug_mark),a  
b40f 3a 1e b4			ld a, (.dmark+1)  
b412 32 66 ee			ld (debug_mark+1),a  
b415 3a 1f b4			ld a, (.dmark+2)  
b418 32 67 ee			ld (debug_mark+2),a  
b41b 18 03			jr .pastdmark  
b41d ..			.dmark: db "LP8"  
b420 f1			.pastdmark: pop af  
b421			endm  
# End of macro DMARK
b421					CALLMONITOR 
b421 cd 6f ee			call debug_vector  
b424				endm  
# End of macro CALLMONITOR
b424					endif 
b424				;push hl 
b424			 
b424				; not going to DO any more 
b424				; get rid of the RSP pointer as DO will add it back in 
b424				;FORTH_RSP_POP 
b424				;pop hl 
b424			 
b424				;ld hl,(cli_ret_sp) 
b424				;ld e, (hl) 
b424				;inc hl 
b424				;ld d, (hl) 
b424				;ex de,hl 
b424 22 bc e5			ld (os_tok_ptr), hl 
b427					if DEBUG_FORTH_WORDS 
b427						DMARK "LP<" 
b427 f5				push af  
b428 3a 3c b4			ld a, (.dmark)  
b42b 32 65 ee			ld (debug_mark),a  
b42e 3a 3d b4			ld a, (.dmark+1)  
b431 32 66 ee			ld (debug_mark+1),a  
b434 3a 3e b4			ld a, (.dmark+2)  
b437 32 67 ee			ld (debug_mark+2),a  
b43a 18 03			jr .pastdmark  
b43c ..			.dmark: db "LP<"  
b43f f1			.pastdmark: pop af  
b440			endm  
# End of macro DMARK
b440					CALLMONITOR 
b440 cd 6f ee			call debug_vector  
b443				endm  
# End of macro CALLMONITOR
b443				endif 
b443 c3 fe 9e			jp exec1 
b446			 
b446					 
b446			 
b446			 
b446					NEXTW 
b446 c3 75 9e			jp macro_next 
b449				endm 
# End of macro NEXTW
b449			.I:  
b449			 
b449				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b449 5e				db WORD_SYS_CORE+74             
b44a 74 b4			dw .DLOOP            
b44c 02				db 1 + 1 
b44d .. 00			db "I",0              
b44f				endm 
# End of macro CWHEAD
b44f			; | I ( -- ) Current loop counter | DONE 
b44f					if DEBUG_FORTH_WORDS_KEY 
b44f						DMARK "I.." 
b44f f5				push af  
b450 3a 64 b4			ld a, (.dmark)  
b453 32 65 ee			ld (debug_mark),a  
b456 3a 65 b4			ld a, (.dmark+1)  
b459 32 66 ee			ld (debug_mark+1),a  
b45c 3a 66 b4			ld a, (.dmark+2)  
b45f 32 67 ee			ld (debug_mark+2),a  
b462 18 03			jr .pastdmark  
b464 ..			.dmark: db "I.."  
b467 f1			.pastdmark: pop af  
b468			endm  
# End of macro DMARK
b468						CALLMONITOR 
b468 cd 6f ee			call debug_vector  
b46b				endm  
# End of macro CALLMONITOR
b46b					endif 
b46b			 
b46b 2a e0 e5				ld hl,(os_current_i) 
b46e cd 85 9a				call forth_push_numhl 
b471			 
b471					NEXTW 
b471 c3 75 9e			jp macro_next 
b474				endm 
# End of macro NEXTW
b474			.DLOOP: 
b474				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b474 5f				db WORD_SYS_CORE+75             
b475 55 b5			dw .REPEAT            
b477 06				db 5 + 1 
b478 .. 00			db "-LOOP",0              
b47e				endm 
# End of macro CWHEAD
b47e			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b47e				; pop tos as current loop count to hl 
b47e					if DEBUG_FORTH_WORDS_KEY 
b47e						DMARK "-LP" 
b47e f5				push af  
b47f 3a 93 b4			ld a, (.dmark)  
b482 32 65 ee			ld (debug_mark),a  
b485 3a 94 b4			ld a, (.dmark+1)  
b488 32 66 ee			ld (debug_mark+1),a  
b48b 3a 95 b4			ld a, (.dmark+2)  
b48e 32 67 ee			ld (debug_mark+2),a  
b491 18 03			jr .pastdmark  
b493 ..			.dmark: db "-LP"  
b496 f1			.pastdmark: pop af  
b497			endm  
# End of macro DMARK
b497						CALLMONITOR 
b497 cd 6f ee			call debug_vector  
b49a				endm  
# End of macro CALLMONITOR
b49a					endif 
b49a			 
b49a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b49a			 
b49a				FORTH_LOOP_TOS 
b49a cd ee 9c			call macro_forth_loop_tos 
b49d				endm 
# End of macro FORTH_LOOP_TOS
b49d e5				push hl 
b49e			 
b49e					if DEBUG_FORTH_WORDS 
b49e						DMARK "-LP" 
b49e f5				push af  
b49f 3a b3 b4			ld a, (.dmark)  
b4a2 32 65 ee			ld (debug_mark),a  
b4a5 3a b4 b4			ld a, (.dmark+1)  
b4a8 32 66 ee			ld (debug_mark+1),a  
b4ab 3a b5 b4			ld a, (.dmark+2)  
b4ae 32 67 ee			ld (debug_mark+2),a  
b4b1 18 03			jr .pastdmark  
b4b3 ..			.dmark: db "-LP"  
b4b6 f1			.pastdmark: pop af  
b4b7			endm  
# End of macro DMARK
b4b7						CALLMONITOR 
b4b7 cd 6f ee			call debug_vector  
b4ba				endm  
# End of macro CALLMONITOR
b4ba					endif 
b4ba				; next item on the stack is the limit. get it 
b4ba			 
b4ba			 
b4ba				FORTH_LOOP_POP 
b4ba cd f8 9c			call macro_forth_loop_pop 
b4bd				endm 
# End of macro FORTH_LOOP_POP
b4bd			 
b4bd				FORTH_LOOP_TOS 
b4bd cd ee 9c			call macro_forth_loop_tos 
b4c0				endm 
# End of macro FORTH_LOOP_TOS
b4c0			 
b4c0 d1				pop de		 ; de = i, hl = limit 
b4c1			 
b4c1					if DEBUG_FORTH_WORDS 
b4c1						DMARK "-L1" 
b4c1 f5				push af  
b4c2 3a d6 b4			ld a, (.dmark)  
b4c5 32 65 ee			ld (debug_mark),a  
b4c8 3a d7 b4			ld a, (.dmark+1)  
b4cb 32 66 ee			ld (debug_mark+1),a  
b4ce 3a d8 b4			ld a, (.dmark+2)  
b4d1 32 67 ee			ld (debug_mark+2),a  
b4d4 18 03			jr .pastdmark  
b4d6 ..			.dmark: db "-L1"  
b4d9 f1			.pastdmark: pop af  
b4da			endm  
# End of macro DMARK
b4da						CALLMONITOR 
b4da cd 6f ee			call debug_vector  
b4dd				endm  
# End of macro CALLMONITOR
b4dd					endif 
b4dd			 
b4dd				; go back to previous word 
b4dd			 
b4dd d5				push de    ; save I for inc later 
b4de			 
b4de			 
b4de				; get limit 
b4de				;  is I at limit? 
b4de			 
b4de			 
b4de					if DEBUG_FORTH_WORDS 
b4de						DMARK "-L1" 
b4de f5				push af  
b4df 3a f3 b4			ld a, (.dmark)  
b4e2 32 65 ee			ld (debug_mark),a  
b4e5 3a f4 b4			ld a, (.dmark+1)  
b4e8 32 66 ee			ld (debug_mark+1),a  
b4eb 3a f5 b4			ld a, (.dmark+2)  
b4ee 32 67 ee			ld (debug_mark+2),a  
b4f1 18 03			jr .pastdmark  
b4f3 ..			.dmark: db "-L1"  
b4f6 f1			.pastdmark: pop af  
b4f7			endm  
# End of macro DMARK
b4f7						CALLMONITOR 
b4f7 cd 6f ee			call debug_vector  
b4fa				endm  
# End of macro CALLMONITOR
b4fa					endif 
b4fa			 
b4fa ed 52			sbc hl, de 
b4fc			 
b4fc			 
b4fc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b4fc			 
b4fc 20 26				jr nz, .mloopnotdone 
b4fe			 
b4fe e1				pop hl   ; get rid of saved I 
b4ff				FORTH_LOOP_POP     ; get rid of limit 
b4ff cd f8 9c			call macro_forth_loop_pop 
b502				endm 
# End of macro FORTH_LOOP_POP
b502			 
b502				FORTH_RSP_POP     ; get rid of DO ptr 
b502 cd 4d 9a			call macro_forth_rsp_pop 
b505				endm 
# End of macro FORTH_RSP_POP
b505			 
b505			if DEBUG_FORTH_WORDS 
b505						DMARK "-L>" 
b505 f5				push af  
b506 3a 1a b5			ld a, (.dmark)  
b509 32 65 ee			ld (debug_mark),a  
b50c 3a 1b b5			ld a, (.dmark+1)  
b50f 32 66 ee			ld (debug_mark+1),a  
b512 3a 1c b5			ld a, (.dmark+2)  
b515 32 67 ee			ld (debug_mark+2),a  
b518 18 03			jr .pastdmark  
b51a ..			.dmark: db "-L>"  
b51d f1			.pastdmark: pop af  
b51e			endm  
# End of macro DMARK
b51e				CALLMONITOR 
b51e cd 6f ee			call debug_vector  
b521				endm  
# End of macro CALLMONITOR
b521			endif 
b521			 
b521					NEXTW 
b521 c3 75 9e			jp macro_next 
b524				endm 
# End of macro NEXTW
b524				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b524			 
b524			.mloopnotdone: 
b524			 
b524 e1				pop hl    ; get I 
b525 2b				dec hl 
b526			 
b526			   	; save new I 
b526			 
b526			 
b526					; set I counter 
b526			 
b526 22 e0 e5				ld (os_current_i), hl 
b529			 
b529					 
b529				FORTH_LOOP_NEXT 
b529 cd bb 9c			call macro_forth_loop_next 
b52c				endm 
# End of macro FORTH_LOOP_NEXT
b52c			 
b52c			 
b52c					if DEBUG_FORTH_WORDS 
b52c eb						ex de,hl 
b52d					endif 
b52d			 
b52d			;	; get DO ptr 
b52d			; 
b52d				FORTH_RSP_TOS 
b52d cd 43 9a			call macro_forth_rsp_tos 
b530				endm 
# End of macro FORTH_RSP_TOS
b530			 
b530				;push hl 
b530			 
b530				; not going to DO any more 
b530				; get rid of the RSP pointer as DO will add it back in 
b530				;FORTH_RSP_POP 
b530				;pop hl 
b530			 
b530			 
b530 22 bc e5			ld (os_tok_ptr), hl 
b533					if DEBUG_FORTH_WORDS 
b533						DMARK "-L<" 
b533 f5				push af  
b534 3a 48 b5			ld a, (.dmark)  
b537 32 65 ee			ld (debug_mark),a  
b53a 3a 49 b5			ld a, (.dmark+1)  
b53d 32 66 ee			ld (debug_mark+1),a  
b540 3a 4a b5			ld a, (.dmark+2)  
b543 32 67 ee			ld (debug_mark+2),a  
b546 18 03			jr .pastdmark  
b548 ..			.dmark: db "-L<"  
b54b f1			.pastdmark: pop af  
b54c			endm  
# End of macro DMARK
b54c					CALLMONITOR 
b54c cd 6f ee			call debug_vector  
b54f				endm  
# End of macro CALLMONITOR
b54f				endif 
b54f c3 fe 9e			jp exec1 
b552			 
b552					 
b552			 
b552			 
b552			 
b552				NEXTW 
b552 c3 75 9e			jp macro_next 
b555				endm 
# End of macro NEXTW
b555			 
b555			 
b555			 
b555			 
b555			.REPEAT: 
b555				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b555 71				db WORD_SYS_CORE+93             
b556 a8 b5			dw .UNTIL            
b558 06				db 5 + 1 
b559 .. 00			db "REPEAT",0              
b560				endm 
# End of macro CWHEAD
b560			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b560			;  push pc to rsp stack past the REPEAT 
b560					if DEBUG_FORTH_WORDS_KEY 
b560						DMARK "REP" 
b560 f5				push af  
b561 3a 75 b5			ld a, (.dmark)  
b564 32 65 ee			ld (debug_mark),a  
b567 3a 76 b5			ld a, (.dmark+1)  
b56a 32 66 ee			ld (debug_mark+1),a  
b56d 3a 77 b5			ld a, (.dmark+2)  
b570 32 67 ee			ld (debug_mark+2),a  
b573 18 03			jr .pastdmark  
b575 ..			.dmark: db "REP"  
b578 f1			.pastdmark: pop af  
b579			endm  
# End of macro DMARK
b579						CALLMONITOR 
b579 cd 6f ee			call debug_vector  
b57c				endm  
# End of macro CALLMONITOR
b57c					endif 
b57c			 
b57c 2a bc e5				ld hl, (os_tok_ptr) 
b57f 23					inc hl   ; R 
b580 23					inc hl  ; E 
b581 23					inc hl   ; P 
b582 23					inc hl   ; E 
b583 23					inc hl   ; A 
b584 23					inc hl   ; T 
b585 23					inc hl   ; zero 
b586					FORTH_RSP_NEXT 
b586 cd 2c 9a			call macro_forth_rsp_next 
b589				endm 
# End of macro FORTH_RSP_NEXT
b589			 
b589			 
b589					if DEBUG_FORTH_WORDS 
b589						DMARK "REP" 
b589 f5				push af  
b58a 3a 9e b5			ld a, (.dmark)  
b58d 32 65 ee			ld (debug_mark),a  
b590 3a 9f b5			ld a, (.dmark+1)  
b593 32 66 ee			ld (debug_mark+1),a  
b596 3a a0 b5			ld a, (.dmark+2)  
b599 32 67 ee			ld (debug_mark+2),a  
b59c 18 03			jr .pastdmark  
b59e ..			.dmark: db "REP"  
b5a1 f1			.pastdmark: pop af  
b5a2			endm  
# End of macro DMARK
b5a2						;pop bc    ; TODO BUG ?????? what is this for???? 
b5a2						CALLMONITOR 
b5a2 cd 6f ee			call debug_vector  
b5a5				endm  
# End of macro CALLMONITOR
b5a5					endif 
b5a5			 
b5a5					NEXTW 
b5a5 c3 75 9e			jp macro_next 
b5a8				endm 
# End of macro NEXTW
b5a8			;	       NEXTW 
b5a8			 
b5a8			.UNTIL: 
b5a8				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b5a8 72				db WORD_SYS_CORE+94             
b5a9 3f b6			dw .ENDFLOW            
b5ab 06				db 5 + 1 
b5ac .. 00			db "UNTIL",0              
b5b2				endm 
# End of macro CWHEAD
b5b2			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b5b2			 
b5b2				; pop tos as check 
b5b2			 
b5b2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b5b2			 
b5b2				FORTH_DSP_VALUEHL 
b5b2 cd 8a 9c			call macro_dsp_valuehl 
b5b5				endm 
# End of macro FORTH_DSP_VALUEHL
b5b5			 
b5b5					if DEBUG_FORTH_WORDS_KEY 
b5b5						DMARK "UNT" 
b5b5 f5				push af  
b5b6 3a ca b5			ld a, (.dmark)  
b5b9 32 65 ee			ld (debug_mark),a  
b5bc 3a cb b5			ld a, (.dmark+1)  
b5bf 32 66 ee			ld (debug_mark+1),a  
b5c2 3a cc b5			ld a, (.dmark+2)  
b5c5 32 67 ee			ld (debug_mark+2),a  
b5c8 18 03			jr .pastdmark  
b5ca ..			.dmark: db "UNT"  
b5cd f1			.pastdmark: pop af  
b5ce			endm  
# End of macro DMARK
b5ce						CALLMONITOR 
b5ce cd 6f ee			call debug_vector  
b5d1				endm  
# End of macro CALLMONITOR
b5d1					endif 
b5d1			 
b5d1			;	push hl 
b5d1				FORTH_DSP_POP 
b5d1 cd 42 9d			call macro_forth_dsp_pop 
b5d4				endm 
# End of macro FORTH_DSP_POP
b5d4			 
b5d4			;	pop hl 
b5d4			 
b5d4				; test if true 
b5d4			 
b5d4 cd 13 8d			call ishlzero 
b5d7			;	ld a,l 
b5d7			;	add h 
b5d7			; 
b5d7			;	cp 0 
b5d7			 
b5d7 20 3e			jr nz, .untilnotdone 
b5d9			 
b5d9					if DEBUG_FORTH_WORDS 
b5d9						DMARK "UNf" 
b5d9 f5				push af  
b5da 3a ee b5			ld a, (.dmark)  
b5dd 32 65 ee			ld (debug_mark),a  
b5e0 3a ef b5			ld a, (.dmark+1)  
b5e3 32 66 ee			ld (debug_mark+1),a  
b5e6 3a f0 b5			ld a, (.dmark+2)  
b5e9 32 67 ee			ld (debug_mark+2),a  
b5ec 18 03			jr .pastdmark  
b5ee ..			.dmark: db "UNf"  
b5f1 f1			.pastdmark: pop af  
b5f2			endm  
# End of macro DMARK
b5f2						CALLMONITOR 
b5f2 cd 6f ee			call debug_vector  
b5f5				endm  
# End of macro CALLMONITOR
b5f5					endif 
b5f5			 
b5f5			 
b5f5			 
b5f5				FORTH_RSP_POP     ; get rid of DO ptr 
b5f5 cd 4d 9a			call macro_forth_rsp_pop 
b5f8				endm 
# End of macro FORTH_RSP_POP
b5f8			 
b5f8			if DEBUG_FORTH_WORDS 
b5f8						DMARK "UN>" 
b5f8 f5				push af  
b5f9 3a 0d b6			ld a, (.dmark)  
b5fc 32 65 ee			ld (debug_mark),a  
b5ff 3a 0e b6			ld a, (.dmark+1)  
b602 32 66 ee			ld (debug_mark+1),a  
b605 3a 0f b6			ld a, (.dmark+2)  
b608 32 67 ee			ld (debug_mark+2),a  
b60b 18 03			jr .pastdmark  
b60d ..			.dmark: db "UN>"  
b610 f1			.pastdmark: pop af  
b611			endm  
# End of macro DMARK
b611				CALLMONITOR 
b611 cd 6f ee			call debug_vector  
b614				endm  
# End of macro CALLMONITOR
b614			endif 
b614			 
b614					NEXTW 
b614 c3 75 9e			jp macro_next 
b617				endm 
# End of macro NEXTW
b617				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b617			 
b617			.untilnotdone: 
b617			 
b617			 
b617			;	; get DO ptr 
b617			; 
b617				FORTH_RSP_TOS 
b617 cd 43 9a			call macro_forth_rsp_tos 
b61a				endm 
# End of macro FORTH_RSP_TOS
b61a			 
b61a				;push hl 
b61a			 
b61a				; not going to DO any more 
b61a				; get rid of the RSP pointer as DO will add it back in 
b61a				;FORTH_RSP_POP 
b61a				;pop hl 
b61a			 
b61a			 
b61a 22 bc e5			ld (os_tok_ptr), hl 
b61d					if DEBUG_FORTH_WORDS 
b61d						DMARK "UN<" 
b61d f5				push af  
b61e 3a 32 b6			ld a, (.dmark)  
b621 32 65 ee			ld (debug_mark),a  
b624 3a 33 b6			ld a, (.dmark+1)  
b627 32 66 ee			ld (debug_mark+1),a  
b62a 3a 34 b6			ld a, (.dmark+2)  
b62d 32 67 ee			ld (debug_mark+2),a  
b630 18 03			jr .pastdmark  
b632 ..			.dmark: db "UN<"  
b635 f1			.pastdmark: pop af  
b636			endm  
# End of macro DMARK
b636					CALLMONITOR 
b636 cd 6f ee			call debug_vector  
b639				endm  
# End of macro CALLMONITOR
b639				endif 
b639 c3 fe 9e			jp exec1 
b63c			 
b63c					 
b63c			 
b63c			 
b63c					NEXTW 
b63c c3 75 9e			jp macro_next 
b63f				endm 
# End of macro NEXTW
b63f			 
b63f			 
b63f			.ENDFLOW: 
b63f			 
b63f			; eof 
b63f			 
# End of file forth_words_flow.asm
b63f			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b63f			include "forth_words_logic.asm" 
b63f			 
b63f			; | ## Logic Words 
b63f			 
b63f			.NOT: 
b63f				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b63f 2d				db WORD_SYS_CORE+25             
b640 87 b6			dw .IS            
b642 04				db 3 + 1 
b643 .. 00			db "NOT",0              
b647				endm 
# End of macro CWHEAD
b647			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b647					if DEBUG_FORTH_WORDS_KEY 
b647						DMARK "NOT" 
b647 f5				push af  
b648 3a 5c b6			ld a, (.dmark)  
b64b 32 65 ee			ld (debug_mark),a  
b64e 3a 5d b6			ld a, (.dmark+1)  
b651 32 66 ee			ld (debug_mark+1),a  
b654 3a 5e b6			ld a, (.dmark+2)  
b657 32 67 ee			ld (debug_mark+2),a  
b65a 18 03			jr .pastdmark  
b65c ..			.dmark: db "NOT"  
b65f f1			.pastdmark: pop af  
b660			endm  
# End of macro DMARK
b660						CALLMONITOR 
b660 cd 6f ee			call debug_vector  
b663				endm  
# End of macro CALLMONITOR
b663					endif 
b663					FORTH_DSP 
b663 cd 50 9c			call macro_forth_dsp 
b666				endm 
# End of macro FORTH_DSP
b666 7e					ld a,(hl)	; get type of value on TOS 
b667 fe 02				cp DS_TYPE_INUM  
b669 28 03				jr z, .noti 
b66b					NEXTW 
b66b c3 75 9e			jp macro_next 
b66e				endm 
# End of macro NEXTW
b66e			.noti:          FORTH_DSP_VALUEHL 
b66e cd 8a 9c			call macro_dsp_valuehl 
b671				endm 
# End of macro FORTH_DSP_VALUEHL
b671			;		push hl 
b671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b671 cd 42 9d			call macro_forth_dsp_pop 
b674				endm 
# End of macro FORTH_DSP_POP
b674			;		pop hl 
b674 3e 00				ld a,0 
b676 bd					cp l 
b677 28 04				jr z, .not2t 
b679 2e 00				ld l, 0 
b67b 18 02				jr .notip 
b67d			 
b67d 2e ff		.not2t:		ld l, 255 
b67f			 
b67f 26 00		.notip:		ld h, 0	 
b681			 
b681 cd 85 9a				call forth_push_numhl 
b684					NEXTW 
b684 c3 75 9e			jp macro_next 
b687				endm 
# End of macro NEXTW
b687			 
b687			.IS: 
b687				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
b687 2d				db WORD_SYS_CORE+25             
b688 c8 b6			dw .LZERO            
b68a 08				db 7 + 1 
b68b .. 00			db "COMPARE",0              
b693				endm 
# End of macro CWHEAD
b693			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
b693					if DEBUG_FORTH_WORDS_KEY 
b693						DMARK "CMP" 
b693 f5				push af  
b694 3a a8 b6			ld a, (.dmark)  
b697 32 65 ee			ld (debug_mark),a  
b69a 3a a9 b6			ld a, (.dmark+1)  
b69d 32 66 ee			ld (debug_mark+1),a  
b6a0 3a aa b6			ld a, (.dmark+2)  
b6a3 32 67 ee			ld (debug_mark+2),a  
b6a6 18 03			jr .pastdmark  
b6a8 ..			.dmark: db "CMP"  
b6ab f1			.pastdmark: pop af  
b6ac			endm  
# End of macro DMARK
b6ac						CALLMONITOR 
b6ac cd 6f ee			call debug_vector  
b6af				endm  
# End of macro CALLMONITOR
b6af					endif 
b6af			 
b6af					FORTH_DSP_VALUEHL 
b6af cd 8a 9c			call macro_dsp_valuehl 
b6b2				endm 
# End of macro FORTH_DSP_VALUEHL
b6b2			 
b6b2 e5					push hl 
b6b3			 
b6b3					FORTH_DSP_VALUEM1 
b6b3 cd 7e 9c			call macro_forth_dsp_value_m1 
b6b6				endm 
# End of macro FORTH_DSP_VALUEM1
b6b6			 
b6b6 d1					pop de 
b6b7			 
b6b7					; got pointers to both. Now check. 
b6b7			 
b6b7 cd 88 90				call strcmp 
b6ba				 
b6ba 26 00				ld h, 0 
b6bc 2e 00				ld l, 0 
b6be 20 02				jr nz, .compnsame 
b6c0 2e 01				ld l, 1	 
b6c2			.compnsame: 
b6c2 cd 85 9a				call forth_push_numhl 
b6c5			 
b6c5					NEXTW 
b6c5 c3 75 9e			jp macro_next 
b6c8				endm 
# End of macro NEXTW
b6c8			.LZERO: 
b6c8				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b6c8 2d				db WORD_SYS_CORE+25             
b6c9 d2 b6			dw .TZERO            
b6cb 03				db 2 + 1 
b6cc .. 00			db "0<",0              
b6cf				endm 
# End of macro CWHEAD
b6cf			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b6cf					NEXTW 
b6cf c3 75 9e			jp macro_next 
b6d2				endm 
# End of macro NEXTW
b6d2			.TZERO: 
b6d2				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b6d2 2e				db WORD_SYS_CORE+26             
b6d3 19 b7			dw .LESS            
b6d5 03				db 2 + 1 
b6d6 .. 00			db "0=",0              
b6d9				endm 
# End of macro CWHEAD
b6d9			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b6d9				; TODO add floating point number detection 
b6d9					;v5 FORTH_DSP_VALUE 
b6d9					if DEBUG_FORTH_WORDS_KEY 
b6d9						DMARK "0=." 
b6d9 f5				push af  
b6da 3a ee b6			ld a, (.dmark)  
b6dd 32 65 ee			ld (debug_mark),a  
b6e0 3a ef b6			ld a, (.dmark+1)  
b6e3 32 66 ee			ld (debug_mark+1),a  
b6e6 3a f0 b6			ld a, (.dmark+2)  
b6e9 32 67 ee			ld (debug_mark+2),a  
b6ec 18 03			jr .pastdmark  
b6ee ..			.dmark: db "0=."  
b6f1 f1			.pastdmark: pop af  
b6f2			endm  
# End of macro DMARK
b6f2						CALLMONITOR 
b6f2 cd 6f ee			call debug_vector  
b6f5				endm  
# End of macro CALLMONITOR
b6f5					endif 
b6f5					FORTH_DSP 
b6f5 cd 50 9c			call macro_forth_dsp 
b6f8				endm 
# End of macro FORTH_DSP
b6f8 7e					ld a,(hl)	; get type of value on TOS 
b6f9 fe 02				cp DS_TYPE_INUM  
b6fb 28 00				jr z, .tz_inum 
b6fd			 
b6fd				if FORTH_ENABLE_FLOATMATH 
b6fd					jr .tz_done 
b6fd			 
b6fd				endif 
b6fd					 
b6fd			 
b6fd			.tz_inum: 
b6fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fd cd 8a 9c			call macro_dsp_valuehl 
b700				endm 
# End of macro FORTH_DSP_VALUEHL
b700			 
b700			;		push hl 
b700			 
b700					; destroy value TOS 
b700			 
b700					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b700 cd 42 9d			call macro_forth_dsp_pop 
b703				endm 
# End of macro FORTH_DSP_POP
b703			 
b703			;		pop hl 
b703			 
b703 3e 00				ld a,0 
b705			 
b705 bd					cp l 
b706 20 08				jr nz, .tz_notzero 
b708			 
b708 bc					cp h 
b709			 
b709 20 05				jr nz, .tz_notzero 
b70b			 
b70b			 
b70b 21 01 00				ld hl, FORTH_TRUE 
b70e 18 03				jr .tz_done 
b710			 
b710 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b713			 
b713					; push value back onto stack for another op etc 
b713			 
b713			.tz_done: 
b713 cd 85 9a				call forth_push_numhl 
b716			 
b716					NEXTW 
b716 c3 75 9e			jp macro_next 
b719				endm 
# End of macro NEXTW
b719			.LESS: 
b719				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b719 2f				db WORD_SYS_CORE+27             
b71a 82 b7			dw .GT            
b71c 02				db 1 + 1 
b71d .. 00			db "<",0              
b71f				endm 
# End of macro CWHEAD
b71f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b71f				; TODO add floating point number detection 
b71f					if DEBUG_FORTH_WORDS_KEY 
b71f						DMARK "LES" 
b71f f5				push af  
b720 3a 34 b7			ld a, (.dmark)  
b723 32 65 ee			ld (debug_mark),a  
b726 3a 35 b7			ld a, (.dmark+1)  
b729 32 66 ee			ld (debug_mark+1),a  
b72c 3a 36 b7			ld a, (.dmark+2)  
b72f 32 67 ee			ld (debug_mark+2),a  
b732 18 03			jr .pastdmark  
b734 ..			.dmark: db "LES"  
b737 f1			.pastdmark: pop af  
b738			endm  
# End of macro DMARK
b738						CALLMONITOR 
b738 cd 6f ee			call debug_vector  
b73b				endm  
# End of macro CALLMONITOR
b73b					endif 
b73b					FORTH_DSP 
b73b cd 50 9c			call macro_forth_dsp 
b73e				endm 
# End of macro FORTH_DSP
b73e					;v5 FORTH_DSP_VALUE 
b73e 7e					ld a,(hl)	; get type of value on TOS 
b73f fe 02				cp DS_TYPE_INUM  
b741 28 00				jr z, .less_inum 
b743			 
b743				if FORTH_ENABLE_FLOATMATH 
b743					jr .less_done 
b743			 
b743				endif 
b743					 
b743			 
b743			.less_inum: 
b743					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b743 cd 8a 9c			call macro_dsp_valuehl 
b746				endm 
# End of macro FORTH_DSP_VALUEHL
b746			 
b746 e5					push hl  ; u2 
b747			 
b747					; destroy value TOS 
b747			 
b747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b747 cd 42 9d			call macro_forth_dsp_pop 
b74a				endm 
# End of macro FORTH_DSP_POP
b74a			 
b74a			 
b74a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b74a cd 8a 9c			call macro_dsp_valuehl 
b74d				endm 
# End of macro FORTH_DSP_VALUEHL
b74d			 
b74d e5					push hl    ; u1 
b74e			 
b74e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b74e cd 42 9d			call macro_forth_dsp_pop 
b751				endm 
# End of macro FORTH_DSP_POP
b751			 
b751			 
b751 b7			 or a      ;clear carry flag 
b752 01 00 00		 ld bc, FORTH_FALSE 
b755 e1			  pop hl    ; u1 
b756 d1			  pop de    ; u2 
b757 ed 52		  sbc hl,de 
b759 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b75b			 
b75b 01 01 00		 ld bc, FORTH_TRUE 
b75e			.lscont:  
b75e c5					push bc 
b75f e1					pop hl 
b760			 
b760					if DEBUG_FORTH_WORDS 
b760						DMARK "LT1" 
b760 f5				push af  
b761 3a 75 b7			ld a, (.dmark)  
b764 32 65 ee			ld (debug_mark),a  
b767 3a 76 b7			ld a, (.dmark+1)  
b76a 32 66 ee			ld (debug_mark+1),a  
b76d 3a 77 b7			ld a, (.dmark+2)  
b770 32 67 ee			ld (debug_mark+2),a  
b773 18 03			jr .pastdmark  
b775 ..			.dmark: db "LT1"  
b778 f1			.pastdmark: pop af  
b779			endm  
# End of macro DMARK
b779						CALLMONITOR 
b779 cd 6f ee			call debug_vector  
b77c				endm  
# End of macro CALLMONITOR
b77c					endif 
b77c cd 85 9a				call forth_push_numhl 
b77f			 
b77f					NEXTW 
b77f c3 75 9e			jp macro_next 
b782				endm 
# End of macro NEXTW
b782			.GT: 
b782				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b782 30				db WORD_SYS_CORE+28             
b783 eb b7			dw .EQUAL            
b785 02				db 1 + 1 
b786 .. 00			db ">",0              
b788				endm 
# End of macro CWHEAD
b788			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b788				; TODO add floating point number detection 
b788					if DEBUG_FORTH_WORDS_KEY 
b788						DMARK "GRT" 
b788 f5				push af  
b789 3a 9d b7			ld a, (.dmark)  
b78c 32 65 ee			ld (debug_mark),a  
b78f 3a 9e b7			ld a, (.dmark+1)  
b792 32 66 ee			ld (debug_mark+1),a  
b795 3a 9f b7			ld a, (.dmark+2)  
b798 32 67 ee			ld (debug_mark+2),a  
b79b 18 03			jr .pastdmark  
b79d ..			.dmark: db "GRT"  
b7a0 f1			.pastdmark: pop af  
b7a1			endm  
# End of macro DMARK
b7a1						CALLMONITOR 
b7a1 cd 6f ee			call debug_vector  
b7a4				endm  
# End of macro CALLMONITOR
b7a4					endif 
b7a4					FORTH_DSP 
b7a4 cd 50 9c			call macro_forth_dsp 
b7a7				endm 
# End of macro FORTH_DSP
b7a7					;FORTH_DSP_VALUE 
b7a7 7e					ld a,(hl)	; get type of value on TOS 
b7a8 fe 02				cp DS_TYPE_INUM  
b7aa 28 00				jr z, .gt_inum 
b7ac			 
b7ac				if FORTH_ENABLE_FLOATMATH 
b7ac					jr .gt_done 
b7ac			 
b7ac				endif 
b7ac					 
b7ac			 
b7ac			.gt_inum: 
b7ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7ac cd 8a 9c			call macro_dsp_valuehl 
b7af				endm 
# End of macro FORTH_DSP_VALUEHL
b7af			 
b7af e5					push hl  ; u2 
b7b0			 
b7b0					; destroy value TOS 
b7b0			 
b7b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7b0 cd 42 9d			call macro_forth_dsp_pop 
b7b3				endm 
# End of macro FORTH_DSP_POP
b7b3			 
b7b3			 
b7b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b3 cd 8a 9c			call macro_dsp_valuehl 
b7b6				endm 
# End of macro FORTH_DSP_VALUEHL
b7b6			 
b7b6 e5					push hl    ; u1 
b7b7			 
b7b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7b7 cd 42 9d			call macro_forth_dsp_pop 
b7ba				endm 
# End of macro FORTH_DSP_POP
b7ba			 
b7ba			 
b7ba b7			 or a      ;clear carry flag 
b7bb 01 00 00		 ld bc, FORTH_FALSE 
b7be e1			  pop hl    ; u1 
b7bf d1			  pop de    ; u2 
b7c0 ed 52		  sbc hl,de 
b7c2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b7c4			 
b7c4 01 01 00		 ld bc, FORTH_TRUE 
b7c7			.gtcont:  
b7c7 c5					push bc 
b7c8 e1					pop hl 
b7c9			 
b7c9					if DEBUG_FORTH_WORDS 
b7c9						DMARK "GT1" 
b7c9 f5				push af  
b7ca 3a de b7			ld a, (.dmark)  
b7cd 32 65 ee			ld (debug_mark),a  
b7d0 3a df b7			ld a, (.dmark+1)  
b7d3 32 66 ee			ld (debug_mark+1),a  
b7d6 3a e0 b7			ld a, (.dmark+2)  
b7d9 32 67 ee			ld (debug_mark+2),a  
b7dc 18 03			jr .pastdmark  
b7de ..			.dmark: db "GT1"  
b7e1 f1			.pastdmark: pop af  
b7e2			endm  
# End of macro DMARK
b7e2						CALLMONITOR 
b7e2 cd 6f ee			call debug_vector  
b7e5				endm  
# End of macro CALLMONITOR
b7e5					endif 
b7e5 cd 85 9a				call forth_push_numhl 
b7e8			 
b7e8					NEXTW 
b7e8 c3 75 9e			jp macro_next 
b7eb				endm 
# End of macro NEXTW
b7eb			.EQUAL: 
b7eb				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b7eb 31				db WORD_SYS_CORE+29             
b7ec 56 b8			dw .ENDLOGIC            
b7ee 02				db 1 + 1 
b7ef .. 00			db "=",0              
b7f1				endm 
# End of macro CWHEAD
b7f1			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b7f1				; TODO add floating point number detection 
b7f1					if DEBUG_FORTH_WORDS_KEY 
b7f1						DMARK "EQ." 
b7f1 f5				push af  
b7f2 3a 06 b8			ld a, (.dmark)  
b7f5 32 65 ee			ld (debug_mark),a  
b7f8 3a 07 b8			ld a, (.dmark+1)  
b7fb 32 66 ee			ld (debug_mark+1),a  
b7fe 3a 08 b8			ld a, (.dmark+2)  
b801 32 67 ee			ld (debug_mark+2),a  
b804 18 03			jr .pastdmark  
b806 ..			.dmark: db "EQ."  
b809 f1			.pastdmark: pop af  
b80a			endm  
# End of macro DMARK
b80a						CALLMONITOR 
b80a cd 6f ee			call debug_vector  
b80d				endm  
# End of macro CALLMONITOR
b80d					endif 
b80d					FORTH_DSP 
b80d cd 50 9c			call macro_forth_dsp 
b810				endm 
# End of macro FORTH_DSP
b810					;v5 FORTH_DSP_VALUE 
b810 7e					ld a,(hl)	; get type of value on TOS 
b811 fe 02				cp DS_TYPE_INUM  
b813 28 00				jr z, .eq_inum 
b815			 
b815				if FORTH_ENABLE_FLOATMATH 
b815					jr .eq_done 
b815			 
b815				endif 
b815					 
b815			 
b815			.eq_inum: 
b815					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b815 cd 8a 9c			call macro_dsp_valuehl 
b818				endm 
# End of macro FORTH_DSP_VALUEHL
b818			 
b818 e5					push hl 
b819			 
b819					; destroy value TOS 
b819			 
b819					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b819 cd 42 9d			call macro_forth_dsp_pop 
b81c				endm 
# End of macro FORTH_DSP_POP
b81c			 
b81c			 
b81c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b81c cd 8a 9c			call macro_dsp_valuehl 
b81f				endm 
# End of macro FORTH_DSP_VALUEHL
b81f			 
b81f					; one value on hl get other one back 
b81f			 
b81f e5					push hl 
b820			 
b820					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b820 cd 42 9d			call macro_forth_dsp_pop 
b823				endm 
# End of macro FORTH_DSP_POP
b823			 
b823 0e 00				ld c, FORTH_FALSE 
b825			 
b825 e1					pop hl 
b826 d1					pop de 
b827			 
b827 7b					ld a, e 
b828 bd					cp l 
b829			 
b829 20 06				jr nz, .eq_done 
b82b			 
b82b 7a					ld a, d 
b82c bc					cp h 
b82d			 
b82d 20 02				jr nz, .eq_done 
b82f			 
b82f 0e 01				ld c, FORTH_TRUE 
b831					 
b831			 
b831			 
b831			.eq_done: 
b831			 
b831					; TODO push value back onto stack for another op etc 
b831			 
b831 26 00				ld h, 0 
b833 69					ld l, c 
b834					if DEBUG_FORTH_WORDS 
b834						DMARK "EQ1" 
b834 f5				push af  
b835 3a 49 b8			ld a, (.dmark)  
b838 32 65 ee			ld (debug_mark),a  
b83b 3a 4a b8			ld a, (.dmark+1)  
b83e 32 66 ee			ld (debug_mark+1),a  
b841 3a 4b b8			ld a, (.dmark+2)  
b844 32 67 ee			ld (debug_mark+2),a  
b847 18 03			jr .pastdmark  
b849 ..			.dmark: db "EQ1"  
b84c f1			.pastdmark: pop af  
b84d			endm  
# End of macro DMARK
b84d						CALLMONITOR 
b84d cd 6f ee			call debug_vector  
b850				endm  
# End of macro CALLMONITOR
b850					endif 
b850 cd 85 9a				call forth_push_numhl 
b853			 
b853					NEXTW 
b853 c3 75 9e			jp macro_next 
b856				endm 
# End of macro NEXTW
b856			 
b856			 
b856			.ENDLOGIC: 
b856			; eof 
b856			 
b856			 
# End of file forth_words_logic.asm
b856			include "forth_words_maths.asm" 
b856			 
b856			; | ## Maths Words 
b856			 
b856			.PLUS:	 
b856				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b856 15				db WORD_SYS_CORE+1             
b857 b4 b8			dw .NEG            
b859 02				db 1 + 1 
b85a .. 00			db "+",0              
b85c				endm 
# End of macro CWHEAD
b85c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b85c					if DEBUG_FORTH_WORDS_KEY 
b85c						DMARK "PLU" 
b85c f5				push af  
b85d 3a 71 b8			ld a, (.dmark)  
b860 32 65 ee			ld (debug_mark),a  
b863 3a 72 b8			ld a, (.dmark+1)  
b866 32 66 ee			ld (debug_mark+1),a  
b869 3a 73 b8			ld a, (.dmark+2)  
b86c 32 67 ee			ld (debug_mark+2),a  
b86f 18 03			jr .pastdmark  
b871 ..			.dmark: db "PLU"  
b874 f1			.pastdmark: pop af  
b875			endm  
# End of macro DMARK
b875						CALLMONITOR 
b875 cd 6f ee			call debug_vector  
b878				endm  
# End of macro CALLMONITOR
b878					endif 
b878					; add top two values and push back result 
b878			 
b878					;for v5 FORTH_DSP_VALUE 
b878					FORTH_DSP 
b878 cd 50 9c			call macro_forth_dsp 
b87b				endm 
# End of macro FORTH_DSP
b87b 7e					ld a,(hl)	; get type of value on TOS 
b87c fe 02				cp DS_TYPE_INUM  
b87e 28 03				jr z, .dot_inum 
b880			 
b880					NEXTW 
b880 c3 75 9e			jp macro_next 
b883				endm 
# End of macro NEXTW
b883			 
b883			; float maths 
b883			 
b883				if FORTH_ENABLE_FLOATMATH 
b883						inc hl      ; now at start of numeric as string 
b883			 
b883					if DEBUG_FORTH_MATHS 
b883						DMARK "ADD" 
b883				CALLMONITOR 
b883					endif 
b883			 
b883					;ld ix, hl 
b883					call CON 
b883			 
b883			 
b883					push hl 
b883					 
b883					 
b883			 
b883						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b883			 
b883					; get next number 
b883			 
b883						FORTH_DSP_VALUE 
b883			 
b883						inc hl      ; now at start of numeric as string 
b883			 
b883					;ld ix, hl 
b883					call CON 
b883			 
b883					push hl 
b883			 
b883			 
b883						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b883			 
b883						; TODO do add 
b883			 
b883						call IADD 
b883			 
b883						; TODO get result back as ascii 
b883			 
b883						; TODO push result  
b883			 
b883			 
b883			 
b883						jr .dot_done 
b883				endif 
b883			 
b883			.dot_inum: 
b883			 
b883			 
b883					if DEBUG_FORTH_DOT 
b883						DMARK "+IT" 
b883 f5				push af  
b884 3a 98 b8			ld a, (.dmark)  
b887 32 65 ee			ld (debug_mark),a  
b88a 3a 99 b8			ld a, (.dmark+1)  
b88d 32 66 ee			ld (debug_mark+1),a  
b890 3a 9a b8			ld a, (.dmark+2)  
b893 32 67 ee			ld (debug_mark+2),a  
b896 18 03			jr .pastdmark  
b898 ..			.dmark: db "+IT"  
b89b f1			.pastdmark: pop af  
b89c			endm  
# End of macro DMARK
b89c				CALLMONITOR 
b89c cd 6f ee			call debug_vector  
b89f				endm  
# End of macro CALLMONITOR
b89f					endif 
b89f			 
b89f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b89f cd 8a 9c			call macro_dsp_valuehl 
b8a2				endm 
# End of macro FORTH_DSP_VALUEHL
b8a2			 
b8a2				; TODO add floating point number detection 
b8a2			 
b8a2 e5					push hl 
b8a3			 
b8a3					; destroy value TOS 
b8a3			 
b8a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8a3 cd 42 9d			call macro_forth_dsp_pop 
b8a6				endm 
# End of macro FORTH_DSP_POP
b8a6			 
b8a6			 
b8a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8a6 cd 8a 9c			call macro_dsp_valuehl 
b8a9				endm 
# End of macro FORTH_DSP_VALUEHL
b8a9			 
b8a9					; one value on hl get other one back 
b8a9			 
b8a9 d1					pop de 
b8aa			 
b8aa					; do the add 
b8aa			 
b8aa 19					add hl,de 
b8ab			 
b8ab					; save it 
b8ab			 
b8ab			;		push hl	 
b8ab			 
b8ab					; 
b8ab			 
b8ab					; destroy value TOS 
b8ab			 
b8ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ab cd 42 9d			call macro_forth_dsp_pop 
b8ae				endm 
# End of macro FORTH_DSP_POP
b8ae			 
b8ae					; TODO push value back onto stack for another op etc 
b8ae			 
b8ae			;		pop hl 
b8ae			 
b8ae			.dot_done: 
b8ae cd 85 9a				call forth_push_numhl 
b8b1			 
b8b1					NEXTW 
b8b1 c3 75 9e			jp macro_next 
b8b4				endm 
# End of macro NEXTW
b8b4			.NEG: 
b8b4			 
b8b4				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b8b4 17				db WORD_SYS_CORE+3             
b8b5 f7 b8			dw .DIV            
b8b7 02				db 1 + 1 
b8b8 .. 00			db "-",0              
b8ba				endm 
# End of macro CWHEAD
b8ba			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b8ba					if DEBUG_FORTH_WORDS_KEY 
b8ba						DMARK "SUB" 
b8ba f5				push af  
b8bb 3a cf b8			ld a, (.dmark)  
b8be 32 65 ee			ld (debug_mark),a  
b8c1 3a d0 b8			ld a, (.dmark+1)  
b8c4 32 66 ee			ld (debug_mark+1),a  
b8c7 3a d1 b8			ld a, (.dmark+2)  
b8ca 32 67 ee			ld (debug_mark+2),a  
b8cd 18 03			jr .pastdmark  
b8cf ..			.dmark: db "SUB"  
b8d2 f1			.pastdmark: pop af  
b8d3			endm  
# End of macro DMARK
b8d3						CALLMONITOR 
b8d3 cd 6f ee			call debug_vector  
b8d6				endm  
# End of macro CALLMONITOR
b8d6					endif 
b8d6			 
b8d6			 
b8d6				; TODO add floating point number detection 
b8d6					; v5 FORTH_DSP_VALUE 
b8d6					FORTH_DSP 
b8d6 cd 50 9c			call macro_forth_dsp 
b8d9				endm 
# End of macro FORTH_DSP
b8d9 7e					ld a,(hl)	; get type of value on TOS 
b8da fe 02				cp DS_TYPE_INUM  
b8dc 28 03				jr z, .neg_inum 
b8de			 
b8de					NEXTW 
b8de c3 75 9e			jp macro_next 
b8e1				endm 
# End of macro NEXTW
b8e1			 
b8e1			; float maths 
b8e1			 
b8e1				if FORTH_ENABLE_FLOATMATH 
b8e1					jr .neg_done 
b8e1			 
b8e1				endif 
b8e1					 
b8e1			 
b8e1			.neg_inum: 
b8e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8e1 cd 8a 9c			call macro_dsp_valuehl 
b8e4				endm 
# End of macro FORTH_DSP_VALUEHL
b8e4			 
b8e4 e5					push hl 
b8e5			 
b8e5					; destroy value TOS 
b8e5			 
b8e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8e5 cd 42 9d			call macro_forth_dsp_pop 
b8e8				endm 
# End of macro FORTH_DSP_POP
b8e8			 
b8e8			 
b8e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8e8 cd 8a 9c			call macro_dsp_valuehl 
b8eb				endm 
# End of macro FORTH_DSP_VALUEHL
b8eb			 
b8eb					; one value on hl get other one back 
b8eb			 
b8eb d1					pop de 
b8ec			 
b8ec					; do the sub 
b8ec			;		ex de, hl 
b8ec			 
b8ec ed 52				sbc hl,de 
b8ee			 
b8ee					; save it 
b8ee			 
b8ee			;		push hl	 
b8ee			 
b8ee					; 
b8ee			 
b8ee					; destroy value TOS 
b8ee			 
b8ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ee cd 42 9d			call macro_forth_dsp_pop 
b8f1				endm 
# End of macro FORTH_DSP_POP
b8f1			 
b8f1					; TODO push value back onto stack for another op etc 
b8f1			 
b8f1			;		pop hl 
b8f1			 
b8f1 cd 85 9a				call forth_push_numhl 
b8f4			.neg_done: 
b8f4			 
b8f4					NEXTW 
b8f4 c3 75 9e			jp macro_next 
b8f7				endm 
# End of macro NEXTW
b8f7			.DIV: 
b8f7				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b8f7 18				db WORD_SYS_CORE+4             
b8f8 44 b9			dw .MUL            
b8fa 02				db 1 + 1 
b8fb .. 00			db "/",0              
b8fd				endm 
# End of macro CWHEAD
b8fd			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b8fd					if DEBUG_FORTH_WORDS_KEY 
b8fd						DMARK "DIV" 
b8fd f5				push af  
b8fe 3a 12 b9			ld a, (.dmark)  
b901 32 65 ee			ld (debug_mark),a  
b904 3a 13 b9			ld a, (.dmark+1)  
b907 32 66 ee			ld (debug_mark+1),a  
b90a 3a 14 b9			ld a, (.dmark+2)  
b90d 32 67 ee			ld (debug_mark+2),a  
b910 18 03			jr .pastdmark  
b912 ..			.dmark: db "DIV"  
b915 f1			.pastdmark: pop af  
b916			endm  
# End of macro DMARK
b916						CALLMONITOR 
b916 cd 6f ee			call debug_vector  
b919				endm  
# End of macro CALLMONITOR
b919					endif 
b919				; TODO add floating point number detection 
b919					; v5 FORTH_DSP_VALUE 
b919					FORTH_DSP 
b919 cd 50 9c			call macro_forth_dsp 
b91c				endm 
# End of macro FORTH_DSP
b91c 7e					ld a,(hl)	; get type of value on TOS 
b91d fe 02				cp DS_TYPE_INUM  
b91f 28 03				jr z, .div_inum 
b921			 
b921				if FORTH_ENABLE_FLOATMATH 
b921					jr .div_done 
b921			 
b921				endif 
b921					NEXTW 
b921 c3 75 9e			jp macro_next 
b924				endm 
# End of macro NEXTW
b924			.div_inum: 
b924			 
b924					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b924 cd 8a 9c			call macro_dsp_valuehl 
b927				endm 
# End of macro FORTH_DSP_VALUEHL
b927			 
b927 e5					push hl    ; to go to bc 
b928			 
b928					; destroy value TOS 
b928			 
b928					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b928 cd 42 9d			call macro_forth_dsp_pop 
b92b				endm 
# End of macro FORTH_DSP_POP
b92b			 
b92b			 
b92b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b92b cd 8a 9c			call macro_dsp_valuehl 
b92e				endm 
# End of macro FORTH_DSP_VALUEHL
b92e			 
b92e					; hl to go to de 
b92e			 
b92e e5					push hl 
b92f			 
b92f c1					pop bc 
b930 d1					pop de		 
b931			 
b931			 
b931					if DEBUG_FORTH_MATHS 
b931						DMARK "DIV" 
b931				CALLMONITOR 
b931					endif 
b931					; one value on hl but move to a get other one back 
b931			 
b931			        
b931 cd 47 8c			call Div16 
b934			 
b934			;	push af	 
b934 e5				push hl 
b935 c5				push bc 
b936			 
b936					if DEBUG_FORTH_MATHS 
b936						DMARK "DI1" 
b936				CALLMONITOR 
b936					endif 
b936			 
b936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b936 cd 42 9d			call macro_forth_dsp_pop 
b939				endm 
# End of macro FORTH_DSP_POP
b939			 
b939			 
b939			 
b939 e1					pop hl    ; result 
b93a			 
b93a cd 85 9a				call forth_push_numhl 
b93d			 
b93d e1					pop hl    ; reminder 
b93e			;		ld h,0 
b93e			;		ld l,d 
b93e			 
b93e cd 85 9a				call forth_push_numhl 
b941			.div_done: 
b941					NEXTW 
b941 c3 75 9e			jp macro_next 
b944				endm 
# End of macro NEXTW
b944			.MUL: 
b944				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b944 19				db WORD_SYS_CORE+5             
b945 89 b9			dw .MIN            
b947 02				db 1 + 1 
b948 .. 00			db "*",0              
b94a				endm 
# End of macro CWHEAD
b94a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b94a				; TODO add floating point number detection 
b94a					if DEBUG_FORTH_WORDS_KEY 
b94a						DMARK "MUL" 
b94a f5				push af  
b94b 3a 5f b9			ld a, (.dmark)  
b94e 32 65 ee			ld (debug_mark),a  
b951 3a 60 b9			ld a, (.dmark+1)  
b954 32 66 ee			ld (debug_mark+1),a  
b957 3a 61 b9			ld a, (.dmark+2)  
b95a 32 67 ee			ld (debug_mark+2),a  
b95d 18 03			jr .pastdmark  
b95f ..			.dmark: db "MUL"  
b962 f1			.pastdmark: pop af  
b963			endm  
# End of macro DMARK
b963						CALLMONITOR 
b963 cd 6f ee			call debug_vector  
b966				endm  
# End of macro CALLMONITOR
b966					endif 
b966					FORTH_DSP 
b966 cd 50 9c			call macro_forth_dsp 
b969				endm 
# End of macro FORTH_DSP
b969					; v5 FORTH_DSP_VALUE 
b969 7e					ld a,(hl)	; get type of value on TOS 
b96a fe 02				cp DS_TYPE_INUM  
b96c 28 03				jr z, .mul_inum 
b96e			 
b96e				if FORTH_ENABLE_FLOATMATH 
b96e					jr .mul_done 
b96e			 
b96e				endif 
b96e			 
b96e					NEXTW 
b96e c3 75 9e			jp macro_next 
b971				endm 
# End of macro NEXTW
b971			.mul_inum:	 
b971			 
b971					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b971 cd 8a 9c			call macro_dsp_valuehl 
b974				endm 
# End of macro FORTH_DSP_VALUEHL
b974			 
b974 e5					push hl 
b975			 
b975					; destroy value TOS 
b975			 
b975					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b975 cd 42 9d			call macro_forth_dsp_pop 
b978				endm 
# End of macro FORTH_DSP_POP
b978			 
b978			 
b978					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b978 cd 8a 9c			call macro_dsp_valuehl 
b97b				endm 
# End of macro FORTH_DSP_VALUEHL
b97b			 
b97b					; one value on hl but move to a get other one back 
b97b			 
b97b 7d					ld a, l 
b97c			 
b97c d1					pop de 
b97d			 
b97d					; do the mull 
b97d			;		ex de, hl 
b97d			 
b97d cd 6d 8c				call Mult16 
b980					; save it 
b980			 
b980			;		push hl	 
b980			 
b980					; 
b980			 
b980					; destroy value TOS 
b980			 
b980					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b980 cd 42 9d			call macro_forth_dsp_pop 
b983				endm 
# End of macro FORTH_DSP_POP
b983			 
b983					; TODO push value back onto stack for another op etc 
b983			 
b983			;		pop hl 
b983			 
b983 cd 85 9a				call forth_push_numhl 
b986			 
b986			.mul_done: 
b986					NEXTW 
b986 c3 75 9e			jp macro_next 
b989				endm 
# End of macro NEXTW
b989			 
b989			 
b989			 
b989			 
b989			.MIN: 
b989				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b989 49				db WORD_SYS_CORE+53             
b98a 0a ba			dw .MAX            
b98c 04				db 3 + 1 
b98d .. 00			db "MIN",0              
b991				endm 
# End of macro CWHEAD
b991			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b991					if DEBUG_FORTH_WORDS_KEY 
b991						DMARK "MIN" 
b991 f5				push af  
b992 3a a6 b9			ld a, (.dmark)  
b995 32 65 ee			ld (debug_mark),a  
b998 3a a7 b9			ld a, (.dmark+1)  
b99b 32 66 ee			ld (debug_mark+1),a  
b99e 3a a8 b9			ld a, (.dmark+2)  
b9a1 32 67 ee			ld (debug_mark+2),a  
b9a4 18 03			jr .pastdmark  
b9a6 ..			.dmark: db "MIN"  
b9a9 f1			.pastdmark: pop af  
b9aa			endm  
# End of macro DMARK
b9aa						CALLMONITOR 
b9aa cd 6f ee			call debug_vector  
b9ad				endm  
# End of macro CALLMONITOR
b9ad					endif 
b9ad					; get u2 
b9ad			 
b9ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ad cd 8a 9c			call macro_dsp_valuehl 
b9b0				endm 
# End of macro FORTH_DSP_VALUEHL
b9b0			 
b9b0 e5					push hl   ; u2 
b9b1			 
b9b1					; destroy value TOS 
b9b1			 
b9b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9b1 cd 42 9d			call macro_forth_dsp_pop 
b9b4				endm 
# End of macro FORTH_DSP_POP
b9b4			 
b9b4					; get u1 
b9b4			 
b9b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9b4 cd 8a 9c			call macro_dsp_valuehl 
b9b7				endm 
# End of macro FORTH_DSP_VALUEHL
b9b7			 
b9b7 e5					push hl  ; u1 
b9b8			 
b9b8					; destroy value TOS 
b9b8			 
b9b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9b8 cd 42 9d			call macro_forth_dsp_pop 
b9bb				endm 
# End of macro FORTH_DSP_POP
b9bb			 
b9bb b7			 or a      ;clear carry flag 
b9bc e1			  pop hl    ; u1 
b9bd d1			  pop de    ; u2 
b9be e5				push hl   ; saved in case hl is lowest 
b9bf ed 52		  sbc hl,de 
b9c1 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b9c3			 
b9c3 e1				pop hl 
b9c4					if DEBUG_FORTH_WORDS 
b9c4						DMARK "MIN" 
b9c4 f5				push af  
b9c5 3a d9 b9			ld a, (.dmark)  
b9c8 32 65 ee			ld (debug_mark),a  
b9cb 3a da b9			ld a, (.dmark+1)  
b9ce 32 66 ee			ld (debug_mark+1),a  
b9d1 3a db b9			ld a, (.dmark+2)  
b9d4 32 67 ee			ld (debug_mark+2),a  
b9d7 18 03			jr .pastdmark  
b9d9 ..			.dmark: db "MIN"  
b9dc f1			.pastdmark: pop af  
b9dd			endm  
# End of macro DMARK
b9dd						CALLMONITOR 
b9dd cd 6f ee			call debug_vector  
b9e0				endm  
# End of macro CALLMONITOR
b9e0					endif 
b9e0 cd 85 9a				call forth_push_numhl 
b9e3			 
b9e3				       NEXTW 
b9e3 c3 75 9e			jp macro_next 
b9e6				endm 
# End of macro NEXTW
b9e6			 
b9e6			.mincont:  
b9e6 c1				pop bc   ; tidy up 
b9e7 eb				ex de , hl  
b9e8					if DEBUG_FORTH_WORDS 
b9e8						DMARK "MI1" 
b9e8 f5				push af  
b9e9 3a fd b9			ld a, (.dmark)  
b9ec 32 65 ee			ld (debug_mark),a  
b9ef 3a fe b9			ld a, (.dmark+1)  
b9f2 32 66 ee			ld (debug_mark+1),a  
b9f5 3a ff b9			ld a, (.dmark+2)  
b9f8 32 67 ee			ld (debug_mark+2),a  
b9fb 18 03			jr .pastdmark  
b9fd ..			.dmark: db "MI1"  
ba00 f1			.pastdmark: pop af  
ba01			endm  
# End of macro DMARK
ba01						CALLMONITOR 
ba01 cd 6f ee			call debug_vector  
ba04				endm  
# End of macro CALLMONITOR
ba04					endif 
ba04 cd 85 9a				call forth_push_numhl 
ba07			 
ba07				       NEXTW 
ba07 c3 75 9e			jp macro_next 
ba0a				endm 
# End of macro NEXTW
ba0a			.MAX: 
ba0a				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
ba0a 4a				db WORD_SYS_CORE+54             
ba0b 8b ba			dw .RND16            
ba0d 04				db 3 + 1 
ba0e .. 00			db "MAX",0              
ba12				endm 
# End of macro CWHEAD
ba12			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
ba12					if DEBUG_FORTH_WORDS_KEY 
ba12						DMARK "MAX" 
ba12 f5				push af  
ba13 3a 27 ba			ld a, (.dmark)  
ba16 32 65 ee			ld (debug_mark),a  
ba19 3a 28 ba			ld a, (.dmark+1)  
ba1c 32 66 ee			ld (debug_mark+1),a  
ba1f 3a 29 ba			ld a, (.dmark+2)  
ba22 32 67 ee			ld (debug_mark+2),a  
ba25 18 03			jr .pastdmark  
ba27 ..			.dmark: db "MAX"  
ba2a f1			.pastdmark: pop af  
ba2b			endm  
# End of macro DMARK
ba2b						CALLMONITOR 
ba2b cd 6f ee			call debug_vector  
ba2e				endm  
# End of macro CALLMONITOR
ba2e					endif 
ba2e					; get u2 
ba2e			 
ba2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba2e cd 8a 9c			call macro_dsp_valuehl 
ba31				endm 
# End of macro FORTH_DSP_VALUEHL
ba31			 
ba31 e5					push hl   ; u2 
ba32			 
ba32					; destroy value TOS 
ba32			 
ba32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba32 cd 42 9d			call macro_forth_dsp_pop 
ba35				endm 
# End of macro FORTH_DSP_POP
ba35			 
ba35					; get u1 
ba35			 
ba35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba35 cd 8a 9c			call macro_dsp_valuehl 
ba38				endm 
# End of macro FORTH_DSP_VALUEHL
ba38			 
ba38 e5					push hl  ; u1 
ba39			 
ba39					; destroy value TOS 
ba39			 
ba39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba39 cd 42 9d			call macro_forth_dsp_pop 
ba3c				endm 
# End of macro FORTH_DSP_POP
ba3c			 
ba3c b7			 or a      ;clear carry flag 
ba3d e1			  pop hl    ; u1 
ba3e d1			  pop de    ; u2 
ba3f e5				push hl   ; saved in case hl is lowest 
ba40 ed 52		  sbc hl,de 
ba42 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
ba44			 
ba44 e1				pop hl 
ba45					if DEBUG_FORTH_WORDS 
ba45						DMARK "MAX" 
ba45 f5				push af  
ba46 3a 5a ba			ld a, (.dmark)  
ba49 32 65 ee			ld (debug_mark),a  
ba4c 3a 5b ba			ld a, (.dmark+1)  
ba4f 32 66 ee			ld (debug_mark+1),a  
ba52 3a 5c ba			ld a, (.dmark+2)  
ba55 32 67 ee			ld (debug_mark+2),a  
ba58 18 03			jr .pastdmark  
ba5a ..			.dmark: db "MAX"  
ba5d f1			.pastdmark: pop af  
ba5e			endm  
# End of macro DMARK
ba5e						CALLMONITOR 
ba5e cd 6f ee			call debug_vector  
ba61				endm  
# End of macro CALLMONITOR
ba61					endif 
ba61 cd 85 9a				call forth_push_numhl 
ba64			 
ba64				       NEXTW 
ba64 c3 75 9e			jp macro_next 
ba67				endm 
# End of macro NEXTW
ba67			 
ba67			.maxcont:  
ba67 c1				pop bc   ; tidy up 
ba68 eb				ex de , hl  
ba69					if DEBUG_FORTH_WORDS 
ba69						DMARK "MA1" 
ba69 f5				push af  
ba6a 3a 7e ba			ld a, (.dmark)  
ba6d 32 65 ee			ld (debug_mark),a  
ba70 3a 7f ba			ld a, (.dmark+1)  
ba73 32 66 ee			ld (debug_mark+1),a  
ba76 3a 80 ba			ld a, (.dmark+2)  
ba79 32 67 ee			ld (debug_mark+2),a  
ba7c 18 03			jr .pastdmark  
ba7e ..			.dmark: db "MA1"  
ba81 f1			.pastdmark: pop af  
ba82			endm  
# End of macro DMARK
ba82						CALLMONITOR 
ba82 cd 6f ee			call debug_vector  
ba85				endm  
# End of macro CALLMONITOR
ba85					endif 
ba85 cd 85 9a				call forth_push_numhl 
ba88				       NEXTW 
ba88 c3 75 9e			jp macro_next 
ba8b				endm 
# End of macro NEXTW
ba8b			 
ba8b			.RND16: 
ba8b				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
ba8b 4e				db WORD_SYS_CORE+58             
ba8c ba ba			dw .RND8            
ba8e 06				db 5 + 1 
ba8f .. 00			db "RND16",0              
ba95				endm 
# End of macro CWHEAD
ba95			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
ba95					if DEBUG_FORTH_WORDS_KEY 
ba95						DMARK "R16" 
ba95 f5				push af  
ba96 3a aa ba			ld a, (.dmark)  
ba99 32 65 ee			ld (debug_mark),a  
ba9c 3a ab ba			ld a, (.dmark+1)  
ba9f 32 66 ee			ld (debug_mark+1),a  
baa2 3a ac ba			ld a, (.dmark+2)  
baa5 32 67 ee			ld (debug_mark+2),a  
baa8 18 03			jr .pastdmark  
baaa ..			.dmark: db "R16"  
baad f1			.pastdmark: pop af  
baae			endm  
# End of macro DMARK
baae						CALLMONITOR 
baae cd 6f ee			call debug_vector  
bab1				endm  
# End of macro CALLMONITOR
bab1					endif 
bab1 cd 11 8c				call prng16  
bab4 cd 85 9a				call forth_push_numhl 
bab7				       NEXTW 
bab7 c3 75 9e			jp macro_next 
baba				endm 
# End of macro NEXTW
baba			.RND8: 
baba				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
baba 60				db WORD_SYS_CORE+76             
babb ef ba			dw .RND            
babd 05				db 4 + 1 
babe .. 00			db "RND8",0              
bac3				endm 
# End of macro CWHEAD
bac3			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
bac3					if DEBUG_FORTH_WORDS_KEY 
bac3						DMARK "RN8" 
bac3 f5				push af  
bac4 3a d8 ba			ld a, (.dmark)  
bac7 32 65 ee			ld (debug_mark),a  
baca 3a d9 ba			ld a, (.dmark+1)  
bacd 32 66 ee			ld (debug_mark+1),a  
bad0 3a da ba			ld a, (.dmark+2)  
bad3 32 67 ee			ld (debug_mark+2),a  
bad6 18 03			jr .pastdmark  
bad8 ..			.dmark: db "RN8"  
badb f1			.pastdmark: pop af  
badc			endm  
# End of macro DMARK
badc						CALLMONITOR 
badc cd 6f ee			call debug_vector  
badf				endm  
# End of macro CALLMONITOR
badf					endif 
badf 2a a3 eb				ld hl,(xrandc) 
bae2 23					inc hl 
bae3 cd 2b 8c				call xrnd 
bae6 6f					ld l,a	 
bae7 26 00				ld h,0 
bae9 cd 85 9a				call forth_push_numhl 
baec				       NEXTW 
baec c3 75 9e			jp macro_next 
baef				endm 
# End of macro NEXTW
baef			.RND: 
baef				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
baef 60				db WORD_SYS_CORE+76             
baf0 f5 bb			dw .ENDMATHS            
baf2 04				db 3 + 1 
baf3 .. 00			db "RND",0              
baf7				endm 
# End of macro CWHEAD
baf7			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
baf7			 
baf7					if DEBUG_FORTH_WORDS_KEY 
baf7						DMARK "RND" 
baf7 f5				push af  
baf8 3a 0c bb			ld a, (.dmark)  
bafb 32 65 ee			ld (debug_mark),a  
bafe 3a 0d bb			ld a, (.dmark+1)  
bb01 32 66 ee			ld (debug_mark+1),a  
bb04 3a 0e bb			ld a, (.dmark+2)  
bb07 32 67 ee			ld (debug_mark+2),a  
bb0a 18 03			jr .pastdmark  
bb0c ..			.dmark: db "RND"  
bb0f f1			.pastdmark: pop af  
bb10			endm  
# End of macro DMARK
bb10						CALLMONITOR 
bb10 cd 6f ee			call debug_vector  
bb13				endm  
# End of macro CALLMONITOR
bb13					endif 
bb13					 
bb13					FORTH_DSP_VALUEHL    ; upper range 
bb13 cd 8a 9c			call macro_dsp_valuehl 
bb16				endm 
# End of macro FORTH_DSP_VALUEHL
bb16			 
bb16 22 a7 eb				ld (LFSRSeed), hl	 
bb19			 
bb19					if DEBUG_FORTH_WORDS 
bb19						DMARK "RN1" 
bb19 f5				push af  
bb1a 3a 2e bb			ld a, (.dmark)  
bb1d 32 65 ee			ld (debug_mark),a  
bb20 3a 2f bb			ld a, (.dmark+1)  
bb23 32 66 ee			ld (debug_mark+1),a  
bb26 3a 30 bb			ld a, (.dmark+2)  
bb29 32 67 ee			ld (debug_mark+2),a  
bb2c 18 03			jr .pastdmark  
bb2e ..			.dmark: db "RN1"  
bb31 f1			.pastdmark: pop af  
bb32			endm  
# End of macro DMARK
bb32						CALLMONITOR 
bb32 cd 6f ee			call debug_vector  
bb35				endm  
# End of macro CALLMONITOR
bb35					endif 
bb35					FORTH_DSP_POP 
bb35 cd 42 9d			call macro_forth_dsp_pop 
bb38				endm 
# End of macro FORTH_DSP_POP
bb38			 
bb38					FORTH_DSP_VALUEHL    ; low range 
bb38 cd 8a 9c			call macro_dsp_valuehl 
bb3b				endm 
# End of macro FORTH_DSP_VALUEHL
bb3b			 
bb3b					if DEBUG_FORTH_WORDS 
bb3b						DMARK "RN2" 
bb3b f5				push af  
bb3c 3a 50 bb			ld a, (.dmark)  
bb3f 32 65 ee			ld (debug_mark),a  
bb42 3a 51 bb			ld a, (.dmark+1)  
bb45 32 66 ee			ld (debug_mark+1),a  
bb48 3a 52 bb			ld a, (.dmark+2)  
bb4b 32 67 ee			ld (debug_mark+2),a  
bb4e 18 03			jr .pastdmark  
bb50 ..			.dmark: db "RN2"  
bb53 f1			.pastdmark: pop af  
bb54			endm  
# End of macro DMARK
bb54						CALLMONITOR 
bb54 cd 6f ee			call debug_vector  
bb57				endm  
# End of macro CALLMONITOR
bb57					endif 
bb57 22 a9 eb				ld (LFSRSeed+2), hl 
bb5a			 
bb5a					FORTH_DSP_POP 
bb5a cd 42 9d			call macro_forth_dsp_pop 
bb5d				endm 
# End of macro FORTH_DSP_POP
bb5d			 
bb5d e5					push hl 
bb5e			 
bb5e e1			.inrange:	pop hl 
bb5f cd 11 8c				call prng16  
bb62					if DEBUG_FORTH_WORDS 
bb62						DMARK "RN3" 
bb62 f5				push af  
bb63 3a 77 bb			ld a, (.dmark)  
bb66 32 65 ee			ld (debug_mark),a  
bb69 3a 78 bb			ld a, (.dmark+1)  
bb6c 32 66 ee			ld (debug_mark+1),a  
bb6f 3a 79 bb			ld a, (.dmark+2)  
bb72 32 67 ee			ld (debug_mark+2),a  
bb75 18 03			jr .pastdmark  
bb77 ..			.dmark: db "RN3"  
bb7a f1			.pastdmark: pop af  
bb7b			endm  
# End of macro DMARK
bb7b						CALLMONITOR 
bb7b cd 6f ee			call debug_vector  
bb7e				endm  
# End of macro CALLMONITOR
bb7e					endif 
bb7e					 
bb7e					; if the range is 8bit knock out the high byte 
bb7e			 
bb7e ed 5b a7 eb			ld de, (LFSRSeed)     ; check high level 
bb82			 
bb82 3e 00				ld a, 0 
bb84 ba					cp d  
bb85 20 1e				jr nz, .hirange 
bb87 26 00				ld h, 0   ; knock it down to 8bit 
bb89			 
bb89					if DEBUG_FORTH_WORDS 
bb89						DMARK "RNk" 
bb89 f5				push af  
bb8a 3a 9e bb			ld a, (.dmark)  
bb8d 32 65 ee			ld (debug_mark),a  
bb90 3a 9f bb			ld a, (.dmark+1)  
bb93 32 66 ee			ld (debug_mark+1),a  
bb96 3a a0 bb			ld a, (.dmark+2)  
bb99 32 67 ee			ld (debug_mark+2),a  
bb9c 18 03			jr .pastdmark  
bb9e ..			.dmark: db "RNk"  
bba1 f1			.pastdmark: pop af  
bba2			endm  
# End of macro DMARK
bba2						CALLMONITOR 
bba2 cd 6f ee			call debug_vector  
bba5				endm  
# End of macro CALLMONITOR
bba5					endif 
bba5			.hirange:   
bba5 e5					push hl  
bba6 b7					or a  
bba7 ed 52		                sbc hl, de 
bba9			 
bba9					;call cmp16 
bba9			 
bba9 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bbab e1					pop hl 
bbac e5					push hl 
bbad			 
bbad					if DEBUG_FORTH_WORDS 
bbad						DMARK "RN4" 
bbad f5				push af  
bbae 3a c2 bb			ld a, (.dmark)  
bbb1 32 65 ee			ld (debug_mark),a  
bbb4 3a c3 bb			ld a, (.dmark+1)  
bbb7 32 66 ee			ld (debug_mark+1),a  
bbba 3a c4 bb			ld a, (.dmark+2)  
bbbd 32 67 ee			ld (debug_mark+2),a  
bbc0 18 03			jr .pastdmark  
bbc2 ..			.dmark: db "RN4"  
bbc5 f1			.pastdmark: pop af  
bbc6			endm  
# End of macro DMARK
bbc6						CALLMONITOR 
bbc6 cd 6f ee			call debug_vector  
bbc9				endm  
# End of macro CALLMONITOR
bbc9					endif 
bbc9 ed 5b a9 eb			ld de, (LFSRSeed+2)   ; check low range 
bbcd					;call cmp16 
bbcd				 
bbcd b7					or a  
bbce ed 52		                sbc hl, de 
bbd0 38 8c				jr c, .inrange 
bbd2			 
bbd2 e1					pop hl 
bbd3					 
bbd3					if DEBUG_FORTH_WORDS 
bbd3						DMARK "RNd" 
bbd3 f5				push af  
bbd4 3a e8 bb			ld a, (.dmark)  
bbd7 32 65 ee			ld (debug_mark),a  
bbda 3a e9 bb			ld a, (.dmark+1)  
bbdd 32 66 ee			ld (debug_mark+1),a  
bbe0 3a ea bb			ld a, (.dmark+2)  
bbe3 32 67 ee			ld (debug_mark+2),a  
bbe6 18 03			jr .pastdmark  
bbe8 ..			.dmark: db "RNd"  
bbeb f1			.pastdmark: pop af  
bbec			endm  
# End of macro DMARK
bbec						CALLMONITOR 
bbec cd 6f ee			call debug_vector  
bbef				endm  
# End of macro CALLMONITOR
bbef					endif 
bbef			 
bbef			 
bbef cd 85 9a				call forth_push_numhl 
bbf2				       NEXTW 
bbf2 c3 75 9e			jp macro_next 
bbf5				endm 
# End of macro NEXTW
bbf5			 
bbf5			.ENDMATHS: 
bbf5			 
bbf5			; eof 
bbf5			 
# End of file forth_words_maths.asm
bbf5			include "forth_words_display.asm" 
bbf5			 
bbf5			; | ## Display Words 
bbf5			 
bbf5			.ACT: 
bbf5			 
bbf5				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bbf5 62				db WORD_SYS_CORE+78             
bbf6 41 bc			dw .INFO            
bbf8 07				db 6 + 1 
bbf9 .. 00			db "ACTIVE",0              
bc00				endm 
# End of macro CWHEAD
bc00			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bc00			;  
bc00			; | | To display a pulsing activity indicator in a processing loop do this... 
bc00			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bc00			 
bc00					if DEBUG_FORTH_WORDS_KEY 
bc00						DMARK "ACT" 
bc00 f5				push af  
bc01 3a 15 bc			ld a, (.dmark)  
bc04 32 65 ee			ld (debug_mark),a  
bc07 3a 16 bc			ld a, (.dmark+1)  
bc0a 32 66 ee			ld (debug_mark+1),a  
bc0d 3a 17 bc			ld a, (.dmark+2)  
bc10 32 67 ee			ld (debug_mark+2),a  
bc13 18 03			jr .pastdmark  
bc15 ..			.dmark: db "ACT"  
bc18 f1			.pastdmark: pop af  
bc19			endm  
# End of macro DMARK
bc19						CALLMONITOR 
bc19 cd 6f ee			call debug_vector  
bc1c				endm  
# End of macro CALLMONITOR
bc1c					endif 
bc1c cd 14 8a				call active 
bc1f					if DEBUG_FORTH_WORDS 
bc1f						DMARK "ACp" 
bc1f f5				push af  
bc20 3a 34 bc			ld a, (.dmark)  
bc23 32 65 ee			ld (debug_mark),a  
bc26 3a 35 bc			ld a, (.dmark+1)  
bc29 32 66 ee			ld (debug_mark+1),a  
bc2c 3a 36 bc			ld a, (.dmark+2)  
bc2f 32 67 ee			ld (debug_mark+2),a  
bc32 18 03			jr .pastdmark  
bc34 ..			.dmark: db "ACp"  
bc37 f1			.pastdmark: pop af  
bc38			endm  
# End of macro DMARK
bc38						CALLMONITOR 
bc38 cd 6f ee			call debug_vector  
bc3b				endm  
# End of macro CALLMONITOR
bc3b					endif 
bc3b cd f3 9a				call forth_push_str 
bc3e			 
bc3e					NEXTW 
bc3e c3 75 9e			jp macro_next 
bc41				endm 
# End of macro NEXTW
bc41			.INFO: 
bc41			 
bc41				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bc41 62				db WORD_SYS_CORE+78             
bc42 5e bc			dw .ATP            
bc44 05				db 4 + 1 
bc45 .. 00			db "INFO",0              
bc4a				endm 
# End of macro CWHEAD
bc4a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bc4a					FORTH_DSP_VALUEHL 
bc4a cd 8a 9c			call macro_dsp_valuehl 
bc4d				endm 
# End of macro FORTH_DSP_VALUEHL
bc4d			 
bc4d					FORTH_DSP_POP 
bc4d cd 42 9d			call macro_forth_dsp_pop 
bc50				endm 
# End of macro FORTH_DSP_POP
bc50			 
bc50 e5					push hl 
bc51			 
bc51					FORTH_DSP_VALUEHL 
bc51 cd 8a 9c			call macro_dsp_valuehl 
bc54				endm 
# End of macro FORTH_DSP_VALUEHL
bc54			 
bc54					FORTH_DSP_POP 
bc54 cd 42 9d			call macro_forth_dsp_pop 
bc57				endm 
# End of macro FORTH_DSP_POP
bc57			 
bc57 d1					pop de 
bc58			 
bc58 cd 4e 8a				call info_panel 
bc5b			 
bc5b			 
bc5b					NEXTW 
bc5b c3 75 9e			jp macro_next 
bc5e				endm 
# End of macro NEXTW
bc5e			.ATP: 
bc5e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bc5e 62				db WORD_SYS_CORE+78             
bc5f d5 bc			dw .FB            
bc61 04				db 3 + 1 
bc62 .. 00			db "AT?",0              
bc66				endm 
# End of macro CWHEAD
bc66			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bc66					if DEBUG_FORTH_WORDS_KEY 
bc66						DMARK "AT?" 
bc66 f5				push af  
bc67 3a 7b bc			ld a, (.dmark)  
bc6a 32 65 ee			ld (debug_mark),a  
bc6d 3a 7c bc			ld a, (.dmark+1)  
bc70 32 66 ee			ld (debug_mark+1),a  
bc73 3a 7d bc			ld a, (.dmark+2)  
bc76 32 67 ee			ld (debug_mark+2),a  
bc79 18 03			jr .pastdmark  
bc7b ..			.dmark: db "AT?"  
bc7e f1			.pastdmark: pop af  
bc7f			endm  
# End of macro DMARK
bc7f						CALLMONITOR 
bc7f cd 6f ee			call debug_vector  
bc82				endm  
# End of macro CALLMONITOR
bc82					endif 
bc82 3a 58 ea				ld a, (f_cursor_ptr) 
bc85			 
bc85			if DEBUG_FORTH_WORDS 
bc85				DMARK "AT?" 
bc85 f5				push af  
bc86 3a 9a bc			ld a, (.dmark)  
bc89 32 65 ee			ld (debug_mark),a  
bc8c 3a 9b bc			ld a, (.dmark+1)  
bc8f 32 66 ee			ld (debug_mark+1),a  
bc92 3a 9c bc			ld a, (.dmark+2)  
bc95 32 67 ee			ld (debug_mark+2),a  
bc98 18 03			jr .pastdmark  
bc9a ..			.dmark: db "AT?"  
bc9d f1			.pastdmark: pop af  
bc9e			endm  
# End of macro DMARK
bc9e				CALLMONITOR 
bc9e cd 6f ee			call debug_vector  
bca1				endm  
# End of macro CALLMONITOR
bca1			endif	 
bca1					; count the number of rows 
bca1			 
bca1 06 00				ld b, 0 
bca3 4f			.atpr:		ld c, a    ; save in case we go below zero 
bca4 d6 28				sub display_cols 
bca6 f2 ac bc				jp p, .atprunder 
bca9 04					inc b 
bcaa 18 f7				jr .atpr 
bcac			.atprunder:	 
bcac			if DEBUG_FORTH_WORDS 
bcac				DMARK "A?2" 
bcac f5				push af  
bcad 3a c1 bc			ld a, (.dmark)  
bcb0 32 65 ee			ld (debug_mark),a  
bcb3 3a c2 bc			ld a, (.dmark+1)  
bcb6 32 66 ee			ld (debug_mark+1),a  
bcb9 3a c3 bc			ld a, (.dmark+2)  
bcbc 32 67 ee			ld (debug_mark+2),a  
bcbf 18 03			jr .pastdmark  
bcc1 ..			.dmark: db "A?2"  
bcc4 f1			.pastdmark: pop af  
bcc5			endm  
# End of macro DMARK
bcc5				CALLMONITOR 
bcc5 cd 6f ee			call debug_vector  
bcc8				endm  
# End of macro CALLMONITOR
bcc8			endif	 
bcc8 26 00				ld h, 0 
bcca 69					ld l, c 
bccb cd 85 9a				call forth_push_numhl 
bcce 68					ld l, b  
bccf cd 85 9a				call forth_push_numhl 
bcd2			 
bcd2			 
bcd2				NEXTW 
bcd2 c3 75 9e			jp macro_next 
bcd5				endm 
# End of macro NEXTW
bcd5			 
bcd5			.FB: 
bcd5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bcd5 1b				db WORD_SYS_CORE+7             
bcd6 23 bd			dw .EMIT            
bcd8 03				db 2 + 1 
bcd9 .. 00			db "FB",0              
bcdc				endm 
# End of macro CWHEAD
bcdc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bcdc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bcdc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bcdc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bcdc					if DEBUG_FORTH_WORDS_KEY 
bcdc						DMARK "FB." 
bcdc f5				push af  
bcdd 3a f1 bc			ld a, (.dmark)  
bce0 32 65 ee			ld (debug_mark),a  
bce3 3a f2 bc			ld a, (.dmark+1)  
bce6 32 66 ee			ld (debug_mark+1),a  
bce9 3a f3 bc			ld a, (.dmark+2)  
bcec 32 67 ee			ld (debug_mark+2),a  
bcef 18 03			jr .pastdmark  
bcf1 ..			.dmark: db "FB."  
bcf4 f1			.pastdmark: pop af  
bcf5			endm  
# End of macro DMARK
bcf5						CALLMONITOR 
bcf5 cd 6f ee			call debug_vector  
bcf8				endm  
# End of macro CALLMONITOR
bcf8					endif 
bcf8			 
bcf8					FORTH_DSP_VALUEHL 
bcf8 cd 8a 9c			call macro_dsp_valuehl 
bcfb				endm 
# End of macro FORTH_DSP_VALUEHL
bcfb			 
bcfb 7d					ld a, l 
bcfc fe 01				cp 1 
bcfe 20 05				jr nz, .fbn1 
bd00 21 0a ed				ld hl, display_fb1 
bd03 18 15				jr .fbset 
bd05 fe 02		.fbn1:		cp 2 
bd07 20 05				jr nz, .fbn2 
bd09 21 c8 eb				ld hl, display_fb2 
bd0c 18 0c				jr .fbset 
bd0e fe 03		.fbn2:		cp 3 
bd10 20 05				jr nz, .fbn3 
bd12 21 69 ec				ld hl, display_fb3 
bd15 18 03				jr .fbset 
bd17			.fbn3:		 ; if invalid number select first 
bd17 21 0a ed				ld hl, display_fb1 
bd1a 22 c6 eb		.fbset:		ld (display_fb_active), hl 
bd1d			 
bd1d					FORTH_DSP_POP 
bd1d cd 42 9d			call macro_forth_dsp_pop 
bd20				endm 
# End of macro FORTH_DSP_POP
bd20			 
bd20					NEXTW 
bd20 c3 75 9e			jp macro_next 
bd23				endm 
# End of macro NEXTW
bd23			 
bd23			 
bd23			.EMIT: 
bd23				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bd23 1b				db WORD_SYS_CORE+7             
bd24 74 bd			dw .DOTH            
bd26 05				db 4 + 1 
bd27 .. 00			db "EMIT",0              
bd2c				endm 
# End of macro CWHEAD
bd2c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bd2c					; get value off TOS and display it 
bd2c			 
bd2c					if DEBUG_FORTH_WORDS_KEY 
bd2c						DMARK "EMT" 
bd2c f5				push af  
bd2d 3a 41 bd			ld a, (.dmark)  
bd30 32 65 ee			ld (debug_mark),a  
bd33 3a 42 bd			ld a, (.dmark+1)  
bd36 32 66 ee			ld (debug_mark+1),a  
bd39 3a 43 bd			ld a, (.dmark+2)  
bd3c 32 67 ee			ld (debug_mark+2),a  
bd3f 18 03			jr .pastdmark  
bd41 ..			.dmark: db "EMT"  
bd44 f1			.pastdmark: pop af  
bd45			endm  
# End of macro DMARK
bd45						CALLMONITOR 
bd45 cd 6f ee			call debug_vector  
bd48				endm  
# End of macro CALLMONITOR
bd48					endif 
bd48			 
bd48					FORTH_DSP_VALUEHL 
bd48 cd 8a 9c			call macro_dsp_valuehl 
bd4b				endm 
# End of macro FORTH_DSP_VALUEHL
bd4b			 
bd4b 7d					ld a,l 
bd4c			 
bd4c					; TODO write to display 
bd4c			 
bd4c 32 b9 e4				ld (os_input), a 
bd4f 3e 00				ld a, 0 
bd51 32 ba e4				ld (os_input+1), a 
bd54					 
bd54 3a 58 ea				ld a, (f_cursor_ptr) 
bd57 11 b9 e4				ld de, os_input 
bd5a cd d0 8a				call str_at_display 
bd5d			 
bd5d			 
bd5d 3a 36 ea				ld a,(cli_autodisplay) 
bd60 fe 00				cp 0 
bd62 28 03				jr z, .enoupdate 
bd64 cd e0 8a						call update_display 
bd67					.enoupdate: 
bd67			 
bd67 3a 58 ea				ld a, (f_cursor_ptr) 
bd6a 3c					inc a 
bd6b 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
bd6e			 
bd6e			 
bd6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd6e cd 42 9d			call macro_forth_dsp_pop 
bd71				endm 
# End of macro FORTH_DSP_POP
bd71			  
bd71			 
bd71					NEXTW 
bd71 c3 75 9e			jp macro_next 
bd74				endm 
# End of macro NEXTW
bd74			.DOTH: 
bd74				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bd74 1c				db WORD_SYS_CORE+8             
bd75 a4 bd			dw .DOTF            
bd77 03				db 2 + 1 
bd78 .. 00			db ".-",0              
bd7b				endm 
# End of macro CWHEAD
bd7b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bd7b					; get value off TOS and display it 
bd7b					if DEBUG_FORTH_WORDS_KEY 
bd7b						DMARK "DTD" 
bd7b f5				push af  
bd7c 3a 90 bd			ld a, (.dmark)  
bd7f 32 65 ee			ld (debug_mark),a  
bd82 3a 91 bd			ld a, (.dmark+1)  
bd85 32 66 ee			ld (debug_mark+1),a  
bd88 3a 92 bd			ld a, (.dmark+2)  
bd8b 32 67 ee			ld (debug_mark+2),a  
bd8e 18 03			jr .pastdmark  
bd90 ..			.dmark: db "DTD"  
bd93 f1			.pastdmark: pop af  
bd94			endm  
# End of macro DMARK
bd94						CALLMONITOR 
bd94 cd 6f ee			call debug_vector  
bd97				endm  
# End of macro CALLMONITOR
bd97					endif 
bd97 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bd99 3e 00			ld a, 0 
bd9b 32 37 ea			ld (cli_mvdot), a 
bd9e c3 fb bd			jp .dotgo 
bda1				NEXTW 
bda1 c3 75 9e			jp macro_next 
bda4				endm 
# End of macro NEXTW
bda4			.DOTF: 
bda4				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bda4 1c				db WORD_SYS_CORE+8             
bda5 d2 bd			dw .DOT            
bda7 03				db 2 + 1 
bda8 .. 00			db ".>",0              
bdab				endm 
# End of macro CWHEAD
bdab			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bdab					; get value off TOS and display it 
bdab			        ; TODO BUG adds extra spaces 
bdab			        ; TODO BUG handle numerics? 
bdab					if DEBUG_FORTH_WORDS_KEY 
bdab						DMARK "DTC" 
bdab f5				push af  
bdac 3a c0 bd			ld a, (.dmark)  
bdaf 32 65 ee			ld (debug_mark),a  
bdb2 3a c1 bd			ld a, (.dmark+1)  
bdb5 32 66 ee			ld (debug_mark+1),a  
bdb8 3a c2 bd			ld a, (.dmark+2)  
bdbb 32 67 ee			ld (debug_mark+2),a  
bdbe 18 03			jr .pastdmark  
bdc0 ..			.dmark: db "DTC"  
bdc3 f1			.pastdmark: pop af  
bdc4			endm  
# End of macro DMARK
bdc4						CALLMONITOR 
bdc4 cd 6f ee			call debug_vector  
bdc7				endm  
# End of macro CALLMONITOR
bdc7					endif 
bdc7 3e 01			ld a, 1 
bdc9 32 37 ea			ld (cli_mvdot), a 
bdcc c3 fb bd			jp .dotgo 
bdcf				NEXTW 
bdcf c3 75 9e			jp macro_next 
bdd2				endm 
# End of macro NEXTW
bdd2			 
bdd2			.DOT: 
bdd2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bdd2 1c				db WORD_SYS_CORE+8             
bdd3 ae bf			dw .CLS            
bdd5 02				db 1 + 1 
bdd6 .. 00			db ".",0              
bdd8				endm 
# End of macro CWHEAD
bdd8			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bdd8					; get value off TOS and display it 
bdd8			 
bdd8					if DEBUG_FORTH_WORDS_KEY 
bdd8						DMARK "DOT" 
bdd8 f5				push af  
bdd9 3a ed bd			ld a, (.dmark)  
bddc 32 65 ee			ld (debug_mark),a  
bddf 3a ee bd			ld a, (.dmark+1)  
bde2 32 66 ee			ld (debug_mark+1),a  
bde5 3a ef bd			ld a, (.dmark+2)  
bde8 32 67 ee			ld (debug_mark+2),a  
bdeb 18 03			jr .pastdmark  
bded ..			.dmark: db "DOT"  
bdf0 f1			.pastdmark: pop af  
bdf1			endm  
# End of macro DMARK
bdf1						CALLMONITOR 
bdf1 cd 6f ee			call debug_vector  
bdf4				endm  
# End of macro CALLMONITOR
bdf4					endif 
bdf4 3e 00			ld a, 0 
bdf6 32 37 ea			ld (cli_mvdot), a 
bdf9 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bdfb				 
bdfb			 
bdfb			.dotgo: 
bdfb			 
bdfb			; move up type to on stack for parserv5 
bdfb					FORTH_DSP 
bdfb cd 50 9c			call macro_forth_dsp 
bdfe				endm 
# End of macro FORTH_DSP
bdfe				;FORTH_DSP_VALUE  
bdfe			 
bdfe			if DEBUG_FORTH_DOT 
bdfe				DMARK "DOT" 
bdfe f5				push af  
bdff 3a 13 be			ld a, (.dmark)  
be02 32 65 ee			ld (debug_mark),a  
be05 3a 14 be			ld a, (.dmark+1)  
be08 32 66 ee			ld (debug_mark+1),a  
be0b 3a 15 be			ld a, (.dmark+2)  
be0e 32 67 ee			ld (debug_mark+2),a  
be11 18 03			jr .pastdmark  
be13 ..			.dmark: db "DOT"  
be16 f1			.pastdmark: pop af  
be17			endm  
# End of macro DMARK
be17				CALLMONITOR 
be17 cd 6f ee			call debug_vector  
be1a				endm  
# End of macro CALLMONITOR
be1a			endif	 
be1a			;		.print: 
be1a			 
be1a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
be1b 23				inc hl   ; position to the actual value 
be1c fe 01			cp DS_TYPE_STR 
be1e 20 06			jr nz, .dotnum1  
be20			 
be20			; display string 
be20				FORTH_DSP_VALUE  
be20 cd 73 9c			call macro_forth_dsp_value 
be23				endm 
# End of macro FORTH_DSP_VALUE
be23 eb				ex de,hl 
be24 18 49			jr .dotwrite 
be26			 
be26			.dotnum1: 
be26 fe 02			cp DS_TYPE_INUM 
be28 20 44			jr nz, .dotflot 
be2a			 
be2a			 
be2a			; display number 
be2a			 
be2a			;	push hl 
be2a			;	call clear_display 
be2a			;	pop hl 
be2a			 
be2a 5e				ld e, (hl) 
be2b 23				inc hl 
be2c 56				ld d, (hl) 
be2d 21 bb e2			ld hl, scratch 
be30			if DEBUG_FORTH_DOT 
be30				DMARK "DT1" 
be30 f5				push af  
be31 3a 45 be			ld a, (.dmark)  
be34 32 65 ee			ld (debug_mark),a  
be37 3a 46 be			ld a, (.dmark+1)  
be3a 32 66 ee			ld (debug_mark+1),a  
be3d 3a 47 be			ld a, (.dmark+2)  
be40 32 67 ee			ld (debug_mark+2),a  
be43 18 03			jr .pastdmark  
be45 ..			.dmark: db "DT1"  
be48 f1			.pastdmark: pop af  
be49			endm  
# End of macro DMARK
be49				CALLMONITOR 
be49 cd 6f ee			call debug_vector  
be4c				endm  
# End of macro CALLMONITOR
be4c			endif	 
be4c			 
be4c cd ff 8f			call uitoa_16 
be4f eb				ex de,hl 
be50			 
be50			if DEBUG_FORTH_DOT 
be50				DMARK "DT2" 
be50 f5				push af  
be51 3a 65 be			ld a, (.dmark)  
be54 32 65 ee			ld (debug_mark),a  
be57 3a 66 be			ld a, (.dmark+1)  
be5a 32 66 ee			ld (debug_mark+1),a  
be5d 3a 67 be			ld a, (.dmark+2)  
be60 32 67 ee			ld (debug_mark+2),a  
be63 18 03			jr .pastdmark  
be65 ..			.dmark: db "DT2"  
be68 f1			.pastdmark: pop af  
be69			endm  
# End of macro DMARK
be69				CALLMONITOR 
be69 cd 6f ee			call debug_vector  
be6c				endm  
# End of macro CALLMONITOR
be6c			endif	 
be6c			 
be6c			;	ld de, os_word_scratch 
be6c 18 01			jr .dotwrite 
be6e			 
be6e 00			.dotflot:   nop 
be6f			; TODO print floating point number 
be6f			 
be6f			.dotwrite:		 
be6f			 
be6f					; if c is set then set all '-' to spaces 
be6f					; need to also take into account .>  
be6f			 
be6f 3e 01				ld a, 1 
be71 b9					cp c 
be72 20 67				jr nz, .nodashswap 
be74			 
be74					; DE has the string to write, working with HL 
be74			 
be74 06 ff				ld b, 255 
be76 d5					push de 
be77 e1					pop hl 
be78			 
be78			if DEBUG_FORTH_DOT 
be78				DMARK "DT-" 
be78 f5				push af  
be79 3a 8d be			ld a, (.dmark)  
be7c 32 65 ee			ld (debug_mark),a  
be7f 3a 8e be			ld a, (.dmark+1)  
be82 32 66 ee			ld (debug_mark+1),a  
be85 3a 8f be			ld a, (.dmark+2)  
be88 32 67 ee			ld (debug_mark+2),a  
be8b 18 03			jr .pastdmark  
be8d ..			.dmark: db "DT-"  
be90 f1			.pastdmark: pop af  
be91			endm  
# End of macro DMARK
be91				CALLMONITOR 
be91 cd 6f ee			call debug_vector  
be94				endm  
# End of macro CALLMONITOR
be94			endif	 
be94 7e			.dashscan:	ld a, (hl) 
be95 fe 00				cp 0 
be97 28 42				jr z, .nodashswap 
be99 fe 2d				cp '-' 
be9b 20 03				jr nz, .dashskip 
be9d 3e 20				ld a, ' ' 
be9f 77					ld (hl), a 
bea0 23			.dashskip:	inc hl 
bea1			if DEBUG_FORTH_DOT 
bea1				DMARK "D-2" 
bea1 f5				push af  
bea2 3a b6 be			ld a, (.dmark)  
bea5 32 65 ee			ld (debug_mark),a  
bea8 3a b7 be			ld a, (.dmark+1)  
beab 32 66 ee			ld (debug_mark+1),a  
beae 3a b8 be			ld a, (.dmark+2)  
beb1 32 67 ee			ld (debug_mark+2),a  
beb4 18 03			jr .pastdmark  
beb6 ..			.dmark: db "D-2"  
beb9 f1			.pastdmark: pop af  
beba			endm  
# End of macro DMARK
beba				CALLMONITOR 
beba cd 6f ee			call debug_vector  
bebd				endm  
# End of macro CALLMONITOR
bebd			endif	 
bebd 10 d5				djnz .dashscan 
bebf			 
bebf			if DEBUG_FORTH_DOT 
bebf				DMARK "D-1" 
bebf f5				push af  
bec0 3a d4 be			ld a, (.dmark)  
bec3 32 65 ee			ld (debug_mark),a  
bec6 3a d5 be			ld a, (.dmark+1)  
bec9 32 66 ee			ld (debug_mark+1),a  
becc 3a d6 be			ld a, (.dmark+2)  
becf 32 67 ee			ld (debug_mark+2),a  
bed2 18 03			jr .pastdmark  
bed4 ..			.dmark: db "D-1"  
bed7 f1			.pastdmark: pop af  
bed8			endm  
# End of macro DMARK
bed8				CALLMONITOR 
bed8 cd 6f ee			call debug_vector  
bedb				endm  
# End of macro CALLMONITOR
bedb			endif	 
bedb			 
bedb			.nodashswap: 
bedb			 
bedb			if DEBUG_FORTH_DOT 
bedb				DMARK "D-o" 
bedb f5				push af  
bedc 3a f0 be			ld a, (.dmark)  
bedf 32 65 ee			ld (debug_mark),a  
bee2 3a f1 be			ld a, (.dmark+1)  
bee5 32 66 ee			ld (debug_mark+1),a  
bee8 3a f2 be			ld a, (.dmark+2)  
beeb 32 67 ee			ld (debug_mark+2),a  
beee 18 03			jr .pastdmark  
bef0 ..			.dmark: db "D-o"  
bef3 f1			.pastdmark: pop af  
bef4			endm  
# End of macro DMARK
bef4				CALLMONITOR 
bef4 cd 6f ee			call debug_vector  
bef7				endm  
# End of macro CALLMONITOR
bef7			endif	 
bef7			 
bef7 d5					push de   ; save string start in case we need to advance print 
bef8			 
bef8 3a 58 ea				ld a, (f_cursor_ptr) 
befb cd d0 8a				call str_at_display 
befe 3a 36 ea				ld a,(cli_autodisplay) 
bf01 fe 00				cp 0 
bf03 28 03				jr z, .noupdate 
bf05 cd e0 8a						call update_display 
bf08					.noupdate: 
bf08			 
bf08			 
bf08					; see if we need to advance the print position 
bf08			 
bf08 e1					pop hl   ; get back string 
bf09			;		ex de,hl 
bf09			 
bf09 3a 37 ea				ld a, (cli_mvdot) 
bf0c			if DEBUG_FORTH_DOT 
bf0c			;		ld e,a 
bf0c				DMARK "D>1" 
bf0c f5				push af  
bf0d 3a 21 bf			ld a, (.dmark)  
bf10 32 65 ee			ld (debug_mark),a  
bf13 3a 22 bf			ld a, (.dmark+1)  
bf16 32 66 ee			ld (debug_mark+1),a  
bf19 3a 23 bf			ld a, (.dmark+2)  
bf1c 32 67 ee			ld (debug_mark+2),a  
bf1f 18 03			jr .pastdmark  
bf21 ..			.dmark: db "D>1"  
bf24 f1			.pastdmark: pop af  
bf25			endm  
# End of macro DMARK
bf25				CALLMONITOR 
bf25 cd 6f ee			call debug_vector  
bf28				endm  
# End of macro CALLMONITOR
bf28			endif	 
bf28 fe 00				cp 0 
bf2a 28 44				jr z, .noadv 
bf2c					; yes, lets advance the print position 
bf2c 3e 00				ld a, 0 
bf2e cd 5b 90				call strlent 
bf31			if DEBUG_FORTH_DOT 
bf31				DMARK "D-?" 
bf31 f5				push af  
bf32 3a 46 bf			ld a, (.dmark)  
bf35 32 65 ee			ld (debug_mark),a  
bf38 3a 47 bf			ld a, (.dmark+1)  
bf3b 32 66 ee			ld (debug_mark+1),a  
bf3e 3a 48 bf			ld a, (.dmark+2)  
bf41 32 67 ee			ld (debug_mark+2),a  
bf44 18 03			jr .pastdmark  
bf46 ..			.dmark: db "D-?"  
bf49 f1			.pastdmark: pop af  
bf4a			endm  
# End of macro DMARK
bf4a				CALLMONITOR 
bf4a cd 6f ee			call debug_vector  
bf4d				endm  
# End of macro CALLMONITOR
bf4d			endif	 
bf4d 3a 58 ea				ld a, (f_cursor_ptr) 
bf50 85					add a,l 
bf51					;call addatohl 
bf51					;ld a, l 
bf51 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
bf54			 
bf54			if DEBUG_FORTH_DOT 
bf54				DMARK "D->" 
bf54 f5				push af  
bf55 3a 69 bf			ld a, (.dmark)  
bf58 32 65 ee			ld (debug_mark),a  
bf5b 3a 6a bf			ld a, (.dmark+1)  
bf5e 32 66 ee			ld (debug_mark+1),a  
bf61 3a 6b bf			ld a, (.dmark+2)  
bf64 32 67 ee			ld (debug_mark+2),a  
bf67 18 03			jr .pastdmark  
bf69 ..			.dmark: db "D->"  
bf6c f1			.pastdmark: pop af  
bf6d			endm  
# End of macro DMARK
bf6d				CALLMONITOR 
bf6d cd 6f ee			call debug_vector  
bf70				endm  
# End of macro CALLMONITOR
bf70			endif	 
bf70			 
bf70			.noadv:	 
bf70			 
bf70					if DEBUG_FORTH_DOT_WAIT 
bf70							call next_page_prompt 
bf70					endif	 
bf70			; TODO this pop off the stack causes a crash. i dont know why 
bf70			 
bf70			 
bf70			if DEBUG_FORTH_DOT 
bf70				DMARK "DTh" 
bf70 f5				push af  
bf71 3a 85 bf			ld a, (.dmark)  
bf74 32 65 ee			ld (debug_mark),a  
bf77 3a 86 bf			ld a, (.dmark+1)  
bf7a 32 66 ee			ld (debug_mark+1),a  
bf7d 3a 87 bf			ld a, (.dmark+2)  
bf80 32 67 ee			ld (debug_mark+2),a  
bf83 18 03			jr .pastdmark  
bf85 ..			.dmark: db "DTh"  
bf88 f1			.pastdmark: pop af  
bf89			endm  
# End of macro DMARK
bf89				CALLMONITOR 
bf89 cd 6f ee			call debug_vector  
bf8c				endm  
# End of macro CALLMONITOR
bf8c			endif	 
bf8c			 
bf8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf8c cd 42 9d			call macro_forth_dsp_pop 
bf8f				endm 
# End of macro FORTH_DSP_POP
bf8f			 
bf8f			if DEBUG_FORTH_DOT 
bf8f				DMARK "DTi" 
bf8f f5				push af  
bf90 3a a4 bf			ld a, (.dmark)  
bf93 32 65 ee			ld (debug_mark),a  
bf96 3a a5 bf			ld a, (.dmark+1)  
bf99 32 66 ee			ld (debug_mark+1),a  
bf9c 3a a6 bf			ld a, (.dmark+2)  
bf9f 32 67 ee			ld (debug_mark+2),a  
bfa2 18 03			jr .pastdmark  
bfa4 ..			.dmark: db "DTi"  
bfa7 f1			.pastdmark: pop af  
bfa8			endm  
# End of macro DMARK
bfa8				CALLMONITOR 
bfa8 cd 6f ee			call debug_vector  
bfab				endm  
# End of macro CALLMONITOR
bfab			endif	 
bfab			 
bfab			 
bfab					NEXTW 
bfab c3 75 9e			jp macro_next 
bfae				endm 
# End of macro NEXTW
bfae			 
bfae			.CLS: 
bfae				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bfae 35				db WORD_SYS_CORE+33             
bfaf db bf			dw .DRAW            
bfb1 04				db 3 + 1 
bfb2 .. 00			db "CLS",0              
bfb6				endm 
# End of macro CWHEAD
bfb6			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bfb6					if DEBUG_FORTH_WORDS_KEY 
bfb6						DMARK "CLS" 
bfb6 f5				push af  
bfb7 3a cb bf			ld a, (.dmark)  
bfba 32 65 ee			ld (debug_mark),a  
bfbd 3a cc bf			ld a, (.dmark+1)  
bfc0 32 66 ee			ld (debug_mark+1),a  
bfc3 3a cd bf			ld a, (.dmark+2)  
bfc6 32 67 ee			ld (debug_mark+2),a  
bfc9 18 03			jr .pastdmark  
bfcb ..			.dmark: db "CLS"  
bfce f1			.pastdmark: pop af  
bfcf			endm  
# End of macro DMARK
bfcf						CALLMONITOR 
bfcf cd 6f ee			call debug_vector  
bfd2				endm  
# End of macro CALLMONITOR
bfd2					endif 
bfd2 cd bd 8a				call clear_display 
bfd5 c3 e9 c0				jp .home		; and home cursor 
bfd8					NEXTW 
bfd8 c3 75 9e			jp macro_next 
bfdb				endm 
# End of macro NEXTW
bfdb			 
bfdb			.DRAW: 
bfdb				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bfdb 36				db WORD_SYS_CORE+34             
bfdc 06 c0			dw .DUMP            
bfde 05				db 4 + 1 
bfdf .. 00			db "DRAW",0              
bfe4				endm 
# End of macro CWHEAD
bfe4			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bfe4					if DEBUG_FORTH_WORDS_KEY 
bfe4						DMARK "DRW" 
bfe4 f5				push af  
bfe5 3a f9 bf			ld a, (.dmark)  
bfe8 32 65 ee			ld (debug_mark),a  
bfeb 3a fa bf			ld a, (.dmark+1)  
bfee 32 66 ee			ld (debug_mark+1),a  
bff1 3a fb bf			ld a, (.dmark+2)  
bff4 32 67 ee			ld (debug_mark+2),a  
bff7 18 03			jr .pastdmark  
bff9 ..			.dmark: db "DRW"  
bffc f1			.pastdmark: pop af  
bffd			endm  
# End of macro DMARK
bffd						CALLMONITOR 
bffd cd 6f ee			call debug_vector  
c000				endm  
# End of macro CALLMONITOR
c000					endif 
c000 cd e0 8a				call update_display 
c003					NEXTW 
c003 c3 75 9e			jp macro_next 
c006				endm 
# End of macro NEXTW
c006			 
c006			.DUMP: 
c006				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
c006 37				db WORD_SYS_CORE+35             
c007 3e c0			dw .CDUMP            
c009 05				db 4 + 1 
c00a .. 00			db "DUMP",0              
c00f				endm 
# End of macro CWHEAD
c00f			; | DUMP ( x -- ) With address x display dump   | DONE 
c00f			; TODO pop address to use off of the stack 
c00f					if DEBUG_FORTH_WORDS_KEY 
c00f						DMARK "DUM" 
c00f f5				push af  
c010 3a 24 c0			ld a, (.dmark)  
c013 32 65 ee			ld (debug_mark),a  
c016 3a 25 c0			ld a, (.dmark+1)  
c019 32 66 ee			ld (debug_mark+1),a  
c01c 3a 26 c0			ld a, (.dmark+2)  
c01f 32 67 ee			ld (debug_mark+2),a  
c022 18 03			jr .pastdmark  
c024 ..			.dmark: db "DUM"  
c027 f1			.pastdmark: pop af  
c028			endm  
# End of macro DMARK
c028						CALLMONITOR 
c028 cd 6f ee			call debug_vector  
c02b				endm  
# End of macro CALLMONITOR
c02b					endif 
c02b cd bd 8a				call clear_display 
c02e			 
c02e					; get address 
c02e			 
c02e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c02e cd 8a 9c			call macro_dsp_valuehl 
c031				endm 
# End of macro FORTH_DSP_VALUEHL
c031				 
c031					; save it for cdump 
c031			 
c031 22 de e5				ld (os_cur_ptr),hl 
c034			 
c034					; destroy value TOS 
c034			 
c034					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c034 cd 42 9d			call macro_forth_dsp_pop 
c037				endm 
# End of macro FORTH_DSP_POP
c037			 
c037 cd 05 99				call dumpcont	; skip old style of param parsing	 
c03a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
c03b					NEXTW 
c03b c3 75 9e			jp macro_next 
c03e				endm 
# End of macro NEXTW
c03e			.CDUMP: 
c03e				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
c03e 38				db WORD_SYS_CORE+36             
c03f 6e c0			dw .DAT            
c041 06				db 5 + 1 
c042 .. 00			db "CDUMP",0              
c048				endm 
# End of macro CWHEAD
c048			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
c048					if DEBUG_FORTH_WORDS_KEY 
c048						DMARK "CDP" 
c048 f5				push af  
c049 3a 5d c0			ld a, (.dmark)  
c04c 32 65 ee			ld (debug_mark),a  
c04f 3a 5e c0			ld a, (.dmark+1)  
c052 32 66 ee			ld (debug_mark+1),a  
c055 3a 5f c0			ld a, (.dmark+2)  
c058 32 67 ee			ld (debug_mark+2),a  
c05b 18 03			jr .pastdmark  
c05d ..			.dmark: db "CDP"  
c060 f1			.pastdmark: pop af  
c061			endm  
# End of macro DMARK
c061						CALLMONITOR 
c061 cd 6f ee			call debug_vector  
c064				endm  
# End of macro CALLMONITOR
c064					endif 
c064 cd bd 8a				call clear_display 
c067 cd 05 99				call dumpcont	 
c06a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c06b					NEXTW 
c06b c3 75 9e			jp macro_next 
c06e				endm 
# End of macro NEXTW
c06e			 
c06e			 
c06e			 
c06e			 
c06e			.DAT: 
c06e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c06e 3d				db WORD_SYS_CORE+41             
c06f c4 c0			dw .HOME            
c071 03				db 2 + 1 
c072 .. 00			db "AT",0              
c075				endm 
# End of macro CWHEAD
c075			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c075					if DEBUG_FORTH_WORDS_KEY 
c075						DMARK "AT." 
c075 f5				push af  
c076 3a 8a c0			ld a, (.dmark)  
c079 32 65 ee			ld (debug_mark),a  
c07c 3a 8b c0			ld a, (.dmark+1)  
c07f 32 66 ee			ld (debug_mark+1),a  
c082 3a 8c c0			ld a, (.dmark+2)  
c085 32 67 ee			ld (debug_mark+2),a  
c088 18 03			jr .pastdmark  
c08a ..			.dmark: db "AT."  
c08d f1			.pastdmark: pop af  
c08e			endm  
# End of macro DMARK
c08e						CALLMONITOR 
c08e cd 6f ee			call debug_vector  
c091				endm  
# End of macro CALLMONITOR
c091					endif 
c091					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c091 cd 8a 9c			call macro_dsp_valuehl 
c094				endm 
# End of macro FORTH_DSP_VALUEHL
c094			 
c094			 
c094					; TODO save cursor row 
c094 7d					ld a,l 
c095 fe 02				cp 2 
c097 20 04				jr nz, .crow3 
c099 3e 28				ld a, display_row_2 
c09b 18 12				jr .ccol1 
c09d fe 03		.crow3:		cp 3 
c09f 20 04				jr nz, .crow4 
c0a1 3e 50				ld a, display_row_3 
c0a3 18 0a				jr .ccol1 
c0a5 fe 04		.crow4:		cp 4 
c0a7 20 04				jr nz, .crow1 
c0a9 3e 78				ld a, display_row_4 
c0ab 18 02				jr .ccol1 
c0ad 3e 00		.crow1:		ld a,display_row_1 
c0af f5			.ccol1:		push af			; got row offset 
c0b0 6f					ld l,a 
c0b1 26 00				ld h,0 
c0b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0b3 cd 42 9d			call macro_forth_dsp_pop 
c0b6				endm 
# End of macro FORTH_DSP_POP
c0b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c0b6 cd 8a 9c			call macro_dsp_valuehl 
c0b9				endm 
# End of macro FORTH_DSP_VALUEHL
c0b9					; TODO save cursor col 
c0b9 f1					pop af 
c0ba 85					add l		; add col offset 
c0bb 32 58 ea				ld (f_cursor_ptr), a 
c0be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0be cd 42 9d			call macro_forth_dsp_pop 
c0c1				endm 
# End of macro FORTH_DSP_POP
c0c1			 
c0c1					; calculate  
c0c1			 
c0c1					NEXTW 
c0c1 c3 75 9e			jp macro_next 
c0c4				endm 
# End of macro NEXTW
c0c4			 
c0c4			 
c0c4			.HOME: 
c0c4				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c0c4 41				db WORD_SYS_CORE+45             
c0c5 f1 c0			dw .CR            
c0c7 05				db 4 + 1 
c0c8 .. 00			db "HOME",0              
c0cd				endm 
# End of macro CWHEAD
c0cd			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c0cd					if DEBUG_FORTH_WORDS_KEY 
c0cd						DMARK "HOM" 
c0cd f5				push af  
c0ce 3a e2 c0			ld a, (.dmark)  
c0d1 32 65 ee			ld (debug_mark),a  
c0d4 3a e3 c0			ld a, (.dmark+1)  
c0d7 32 66 ee			ld (debug_mark+1),a  
c0da 3a e4 c0			ld a, (.dmark+2)  
c0dd 32 67 ee			ld (debug_mark+2),a  
c0e0 18 03			jr .pastdmark  
c0e2 ..			.dmark: db "HOM"  
c0e5 f1			.pastdmark: pop af  
c0e6			endm  
# End of macro DMARK
c0e6						CALLMONITOR 
c0e6 cd 6f ee			call debug_vector  
c0e9				endm  
# End of macro CALLMONITOR
c0e9					endif 
c0e9 3e 00		.home:		ld a, 0		; and home cursor 
c0eb 32 58 ea				ld (f_cursor_ptr), a 
c0ee					NEXTW 
c0ee c3 75 9e			jp macro_next 
c0f1				endm 
# End of macro NEXTW
c0f1			 
c0f1			 
c0f1			.CR: 
c0f1				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c0f1 46				db WORD_SYS_CORE+50             
c0f2 2c c1			dw .SPACE            
c0f4 03				db 2 + 1 
c0f5 .. 00			db "CR",0              
c0f8				endm 
# End of macro CWHEAD
c0f8			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c0f8					if DEBUG_FORTH_WORDS_KEY 
c0f8						DMARK "CR." 
c0f8 f5				push af  
c0f9 3a 0d c1			ld a, (.dmark)  
c0fc 32 65 ee			ld (debug_mark),a  
c0ff 3a 0e c1			ld a, (.dmark+1)  
c102 32 66 ee			ld (debug_mark+1),a  
c105 3a 0f c1			ld a, (.dmark+2)  
c108 32 67 ee			ld (debug_mark+2),a  
c10b 18 03			jr .pastdmark  
c10d ..			.dmark: db "CR."  
c110 f1			.pastdmark: pop af  
c111			endm  
# End of macro DMARK
c111						CALLMONITOR 
c111 cd 6f ee			call debug_vector  
c114				endm  
# End of macro CALLMONITOR
c114					endif 
c114 3e 0d				ld a, 13 
c116 32 bb e2				ld (scratch),a 
c119 3e 0a				ld a, 10 
c11b 32 bc e2				ld (scratch+1),a 
c11e 3e 00				ld a, 0 
c120 32 bd e2				ld (scratch+2),a 
c123 21 bb e2				ld hl, scratch 
c126 cd f3 9a				call forth_push_str 
c129					 
c129				       NEXTW 
c129 c3 75 9e			jp macro_next 
c12c				endm 
# End of macro NEXTW
c12c			.SPACE: 
c12c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c12c 46				db WORD_SYS_CORE+50             
c12d 62 c1			dw .SPACES            
c12f 03				db 2 + 1 
c130 .. 00			db "BL",0              
c133				endm 
# End of macro CWHEAD
c133			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c133					if DEBUG_FORTH_WORDS_KEY 
c133						DMARK "BL." 
c133 f5				push af  
c134 3a 48 c1			ld a, (.dmark)  
c137 32 65 ee			ld (debug_mark),a  
c13a 3a 49 c1			ld a, (.dmark+1)  
c13d 32 66 ee			ld (debug_mark+1),a  
c140 3a 4a c1			ld a, (.dmark+2)  
c143 32 67 ee			ld (debug_mark+2),a  
c146 18 03			jr .pastdmark  
c148 ..			.dmark: db "BL."  
c14b f1			.pastdmark: pop af  
c14c			endm  
# End of macro DMARK
c14c						CALLMONITOR 
c14c cd 6f ee			call debug_vector  
c14f				endm  
# End of macro CALLMONITOR
c14f					endif 
c14f 3e 20				ld a, " " 
c151 32 bb e2				ld (scratch),a 
c154 3e 00				ld a, 0 
c156 32 bc e2				ld (scratch+1),a 
c159 21 bb e2				ld hl, scratch 
c15c cd f3 9a				call forth_push_str 
c15f					 
c15f				       NEXTW 
c15f c3 75 9e			jp macro_next 
c162				endm 
# End of macro NEXTW
c162			 
c162			;.blstr: db " ", 0 
c162			 
c162			.SPACES: 
c162				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c162 47				db WORD_SYS_CORE+51             
c163 fd c1			dw .SCROLL            
c165 07				db 6 + 1 
c166 .. 00			db "SPACES",0              
c16d				endm 
# End of macro CWHEAD
c16d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c16d					if DEBUG_FORTH_WORDS_KEY 
c16d						DMARK "SPS" 
c16d f5				push af  
c16e 3a 82 c1			ld a, (.dmark)  
c171 32 65 ee			ld (debug_mark),a  
c174 3a 83 c1			ld a, (.dmark+1)  
c177 32 66 ee			ld (debug_mark+1),a  
c17a 3a 84 c1			ld a, (.dmark+2)  
c17d 32 67 ee			ld (debug_mark+2),a  
c180 18 03			jr .pastdmark  
c182 ..			.dmark: db "SPS"  
c185 f1			.pastdmark: pop af  
c186			endm  
# End of macro DMARK
c186						CALLMONITOR 
c186 cd 6f ee			call debug_vector  
c189				endm  
# End of macro CALLMONITOR
c189					endif 
c189			 
c189			 
c189					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c189 cd 8a 9c			call macro_dsp_valuehl 
c18c				endm 
# End of macro FORTH_DSP_VALUEHL
c18c			 
c18c e5					push hl    ; u 
c18d					if DEBUG_FORTH_WORDS 
c18d						DMARK "SPA" 
c18d f5				push af  
c18e 3a a2 c1			ld a, (.dmark)  
c191 32 65 ee			ld (debug_mark),a  
c194 3a a3 c1			ld a, (.dmark+1)  
c197 32 66 ee			ld (debug_mark+1),a  
c19a 3a a4 c1			ld a, (.dmark+2)  
c19d 32 67 ee			ld (debug_mark+2),a  
c1a0 18 03			jr .pastdmark  
c1a2 ..			.dmark: db "SPA"  
c1a5 f1			.pastdmark: pop af  
c1a6			endm  
# End of macro DMARK
c1a6						CALLMONITOR 
c1a6 cd 6f ee			call debug_vector  
c1a9				endm  
# End of macro CALLMONITOR
c1a9					endif 
c1a9			 
c1a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1a9 cd 42 9d			call macro_forth_dsp_pop 
c1ac				endm 
# End of macro FORTH_DSP_POP
c1ac e1					pop hl 
c1ad 0e 00				ld c, 0 
c1af 45					ld b, l 
c1b0 21 bb e2				ld hl, scratch  
c1b3			 
c1b3					if DEBUG_FORTH_WORDS 
c1b3						DMARK "SP2" 
c1b3 f5				push af  
c1b4 3a c8 c1			ld a, (.dmark)  
c1b7 32 65 ee			ld (debug_mark),a  
c1ba 3a c9 c1			ld a, (.dmark+1)  
c1bd 32 66 ee			ld (debug_mark+1),a  
c1c0 3a ca c1			ld a, (.dmark+2)  
c1c3 32 67 ee			ld (debug_mark+2),a  
c1c6 18 03			jr .pastdmark  
c1c8 ..			.dmark: db "SP2"  
c1cb f1			.pastdmark: pop af  
c1cc			endm  
# End of macro DMARK
c1cc						CALLMONITOR 
c1cc cd 6f ee			call debug_vector  
c1cf				endm  
# End of macro CALLMONITOR
c1cf					endif 
c1cf 3e 20				ld a, ' ' 
c1d1			.spaces1:	 
c1d1 77					ld (hl),a 
c1d2 23					inc hl 
c1d3					 
c1d3 10 fc				djnz .spaces1 
c1d5 3e 00				ld a,0 
c1d7 77					ld (hl),a 
c1d8 21 bb e2				ld hl, scratch 
c1db					if DEBUG_FORTH_WORDS 
c1db						DMARK "SP3" 
c1db f5				push af  
c1dc 3a f0 c1			ld a, (.dmark)  
c1df 32 65 ee			ld (debug_mark),a  
c1e2 3a f1 c1			ld a, (.dmark+1)  
c1e5 32 66 ee			ld (debug_mark+1),a  
c1e8 3a f2 c1			ld a, (.dmark+2)  
c1eb 32 67 ee			ld (debug_mark+2),a  
c1ee 18 03			jr .pastdmark  
c1f0 ..			.dmark: db "SP3"  
c1f3 f1			.pastdmark: pop af  
c1f4			endm  
# End of macro DMARK
c1f4						CALLMONITOR 
c1f4 cd 6f ee			call debug_vector  
c1f7				endm  
# End of macro CALLMONITOR
c1f7					endif 
c1f7 cd f3 9a				call forth_push_str 
c1fa			 
c1fa				       NEXTW 
c1fa c3 75 9e			jp macro_next 
c1fd				endm 
# End of macro NEXTW
c1fd			 
c1fd			 
c1fd			 
c1fd			.SCROLL: 
c1fd				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c1fd 53				db WORD_SYS_CORE+63             
c1fe 2a c2			dw .SCROLLD            
c200 07				db 6 + 1 
c201 .. 00			db "SCROLL",0              
c208				endm 
# End of macro CWHEAD
c208			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c208					if DEBUG_FORTH_WORDS_KEY 
c208						DMARK "SCR" 
c208 f5				push af  
c209 3a 1d c2			ld a, (.dmark)  
c20c 32 65 ee			ld (debug_mark),a  
c20f 3a 1e c2			ld a, (.dmark+1)  
c212 32 66 ee			ld (debug_mark+1),a  
c215 3a 1f c2			ld a, (.dmark+2)  
c218 32 67 ee			ld (debug_mark+2),a  
c21b 18 03			jr .pastdmark  
c21d ..			.dmark: db "SCR"  
c220 f1			.pastdmark: pop af  
c221			endm  
# End of macro DMARK
c221						CALLMONITOR 
c221 cd 6f ee			call debug_vector  
c224				endm  
# End of macro CALLMONITOR
c224					endif 
c224			 
c224 cd 7f 8a			call scroll_up 
c227			;	call update_display 
c227			 
c227					NEXTW 
c227 c3 75 9e			jp macro_next 
c22a				endm 
# End of macro NEXTW
c22a			 
c22a			 
c22a			 
c22a			;		; get dir 
c22a			; 
c22a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c22a			; 
c22a			;		push hl 
c22a			; 
c22a			;		; destroy value TOS 
c22a			; 
c22a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c22a			; 
c22a			;		; get count 
c22a			; 
c22a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c22a			; 
c22a			;		push hl 
c22a			; 
c22a			;		; destroy value TOS 
c22a			; 
c22a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c22a			; 
c22a			;		; one value on hl get other one back 
c22a			; 
c22a			;		pop bc    ; count 
c22a			; 
c22a			;		pop de   ; dir 
c22a			; 
c22a			; 
c22a			;		ld b, c 
c22a			; 
c22a			;.scrolldir:     push bc 
c22a			;		push de 
c22a			; 
c22a			;		ld a, 0 
c22a			;		cp e 
c22a			;		jr z, .scrollup  
c22a			;		call scroll_down 
c22a			;		jr .scrollnext 
c22a			;.scrollup:	call scroll_up 
c22a			; 
c22a			;		 
c22a			;.scrollnext: 
c22a			;		pop de 
c22a			;		pop bc 
c22a			;		djnz .scrolldir 
c22a			; 
c22a			; 
c22a			; 
c22a			; 
c22a			; 
c22a			;		NEXTW 
c22a			 
c22a			.SCROLLD: 
c22a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c22a 53				db WORD_SYS_CORE+63             
c22b 58 c2			dw .ATQ            
c22d 08				db 7 + 1 
c22e .. 00			db "SCROLLD",0              
c236				endm 
# End of macro CWHEAD
c236			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c236					if DEBUG_FORTH_WORDS_KEY 
c236						DMARK "SCD" 
c236 f5				push af  
c237 3a 4b c2			ld a, (.dmark)  
c23a 32 65 ee			ld (debug_mark),a  
c23d 3a 4c c2			ld a, (.dmark+1)  
c240 32 66 ee			ld (debug_mark+1),a  
c243 3a 4d c2			ld a, (.dmark+2)  
c246 32 67 ee			ld (debug_mark+2),a  
c249 18 03			jr .pastdmark  
c24b ..			.dmark: db "SCD"  
c24e f1			.pastdmark: pop af  
c24f			endm  
# End of macro DMARK
c24f						CALLMONITOR 
c24f cd 6f ee			call debug_vector  
c252				endm  
# End of macro CALLMONITOR
c252					endif 
c252			 
c252 cd a3 8a			call scroll_down 
c255			;	call update_display 
c255			 
c255					NEXTW 
c255 c3 75 9e			jp macro_next 
c258				endm 
# End of macro NEXTW
c258			 
c258			 
c258			.ATQ: 
c258				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c258 62				db WORD_SYS_CORE+78             
c259 b6 c2			dw .AUTODSP            
c25b 04				db 3 + 1 
c25c .. 00			db "AT@",0              
c260				endm 
# End of macro CWHEAD
c260			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c260					if DEBUG_FORTH_WORDS_KEY 
c260						DMARK "ATA" 
c260 f5				push af  
c261 3a 75 c2			ld a, (.dmark)  
c264 32 65 ee			ld (debug_mark),a  
c267 3a 76 c2			ld a, (.dmark+1)  
c26a 32 66 ee			ld (debug_mark+1),a  
c26d 3a 77 c2			ld a, (.dmark+2)  
c270 32 67 ee			ld (debug_mark+2),a  
c273 18 03			jr .pastdmark  
c275 ..			.dmark: db "ATA"  
c278 f1			.pastdmark: pop af  
c279			endm  
# End of macro DMARK
c279						CALLMONITOR 
c279 cd 6f ee			call debug_vector  
c27c				endm  
# End of macro CALLMONITOR
c27c					endif 
c27c			 
c27c			 
c27c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c27c cd 8a 9c			call macro_dsp_valuehl 
c27f				endm 
# End of macro FORTH_DSP_VALUEHL
c27f			 
c27f					; TODO save cursor row 
c27f 7d					ld a,l 
c280 fe 02				cp 2 
c282 20 04				jr nz, .crow3aq 
c284 3e 28				ld a, display_row_2 
c286 18 12				jr .ccol1aq 
c288 fe 03		.crow3aq:		cp 3 
c28a 20 04				jr nz, .crow4aq 
c28c 3e 50				ld a, display_row_3 
c28e 18 0a				jr .ccol1aq 
c290 fe 04		.crow4aq:		cp 4 
c292 20 04				jr nz, .crow1aq 
c294 3e 78				ld a, display_row_4 
c296 18 02				jr .ccol1aq 
c298 3e 00		.crow1aq:		ld a,display_row_1 
c29a f5			.ccol1aq:		push af			; got row offset 
c29b 6f					ld l,a 
c29c 26 00				ld h,0 
c29e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c29e cd 42 9d			call macro_forth_dsp_pop 
c2a1				endm 
# End of macro FORTH_DSP_POP
c2a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2a1 cd 8a 9c			call macro_dsp_valuehl 
c2a4				endm 
# End of macro FORTH_DSP_VALUEHL
c2a4					; TODO save cursor col 
c2a4 f1					pop af 
c2a5 85					add l		; add col offset 
c2a6			 
c2a6					; add current frame buffer address 
c2a6 2a c6 eb				ld hl, (display_fb_active) 
c2a9 cd ea 8c				call addatohl 
c2ac			 
c2ac			 
c2ac			 
c2ac			 
c2ac					; get char frame buffer location offset in hl 
c2ac			 
c2ac 7e					ld a,(hl) 
c2ad 26 00				ld h, 0 
c2af 6f					ld l, a 
c2b0			 
c2b0 cd 85 9a				call forth_push_numhl 
c2b3			 
c2b3			 
c2b3					NEXTW 
c2b3 c3 75 9e			jp macro_next 
c2b6				endm 
# End of macro NEXTW
c2b6			 
c2b6			.AUTODSP: 
c2b6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c2b6 63				db WORD_SYS_CORE+79             
c2b7 cc c2			dw .MENU            
c2b9 05				db 4 + 1 
c2ba .. 00			db "ADSP",0              
c2bf				endm 
# End of macro CWHEAD
c2bf			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c2bf			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c2bf			 
c2bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2bf cd 8a 9c			call macro_dsp_valuehl 
c2c2				endm 
# End of macro FORTH_DSP_VALUEHL
c2c2			 
c2c2			;		push hl 
c2c2			 
c2c2					; destroy value TOS 
c2c2			 
c2c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2c2 cd 42 9d			call macro_forth_dsp_pop 
c2c5				endm 
# End of macro FORTH_DSP_POP
c2c5			 
c2c5			;		pop hl 
c2c5			 
c2c5 7d					ld a,l 
c2c6 32 36 ea				ld (cli_autodisplay), a 
c2c9				       NEXTW 
c2c9 c3 75 9e			jp macro_next 
c2cc				endm 
# End of macro NEXTW
c2cc			 
c2cc			.MENU: 
c2cc				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c2cc 70				db WORD_SYS_CORE+92             
c2cd 75 c3			dw .ENDDISPLAY            
c2cf 05				db 4 + 1 
c2d0 .. 00			db "MENU",0              
c2d5				endm 
# End of macro CWHEAD
c2d5			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c2d5			 
c2d5			;		; get number of items on the stack 
c2d5			; 
c2d5				 
c2d5					FORTH_DSP_VALUEHL 
c2d5 cd 8a 9c			call macro_dsp_valuehl 
c2d8				endm 
# End of macro FORTH_DSP_VALUEHL
c2d8				 
c2d8					if DEBUG_FORTH_WORDS_KEY 
c2d8						DMARK "MNU" 
c2d8 f5				push af  
c2d9 3a ed c2			ld a, (.dmark)  
c2dc 32 65 ee			ld (debug_mark),a  
c2df 3a ee c2			ld a, (.dmark+1)  
c2e2 32 66 ee			ld (debug_mark+1),a  
c2e5 3a ef c2			ld a, (.dmark+2)  
c2e8 32 67 ee			ld (debug_mark+2),a  
c2eb 18 03			jr .pastdmark  
c2ed ..			.dmark: db "MNU"  
c2f0 f1			.pastdmark: pop af  
c2f1			endm  
# End of macro DMARK
c2f1						CALLMONITOR 
c2f1 cd 6f ee			call debug_vector  
c2f4				endm  
# End of macro CALLMONITOR
c2f4					endif 
c2f4			 
c2f4 45					ld b, l	 
c2f5 05					dec b 
c2f6			 
c2f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f6 cd 42 9d			call macro_forth_dsp_pop 
c2f9				endm 
# End of macro FORTH_DSP_POP
c2f9			 
c2f9			 
c2f9					; go directly through the stack to pluck out the string pointers and build an array 
c2f9			 
c2f9			;		FORTH_DSP 
c2f9			 
c2f9					; hl contains top most stack item 
c2f9				 
c2f9 11 bb e2				ld de, scratch 
c2fc			 
c2fc			.mbuild: 
c2fc			 
c2fc					FORTH_DSP_VALUEHL 
c2fc cd 8a 9c			call macro_dsp_valuehl 
c2ff				endm 
# End of macro FORTH_DSP_VALUEHL
c2ff			 
c2ff					if DEBUG_FORTH_WORDS 
c2ff						DMARK "MN3" 
c2ff f5				push af  
c300 3a 14 c3			ld a, (.dmark)  
c303 32 65 ee			ld (debug_mark),a  
c306 3a 15 c3			ld a, (.dmark+1)  
c309 32 66 ee			ld (debug_mark+1),a  
c30c 3a 16 c3			ld a, (.dmark+2)  
c30f 32 67 ee			ld (debug_mark+2),a  
c312 18 03			jr .pastdmark  
c314 ..			.dmark: db "MN3"  
c317 f1			.pastdmark: pop af  
c318			endm  
# End of macro DMARK
c318						CALLMONITOR 
c318 cd 6f ee			call debug_vector  
c31b				endm  
# End of macro CALLMONITOR
c31b					endif 
c31b eb					ex de, hl 
c31c 73					ld (hl), e 
c31d 23					inc hl 
c31e 72					ld (hl), d 
c31f 23					inc hl 
c320 eb					ex de, hl 
c321			 
c321					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c321 cd 42 9d			call macro_forth_dsp_pop 
c324				endm 
# End of macro FORTH_DSP_POP
c324			 
c324 10 d6				djnz .mbuild 
c326			 
c326					; done add term 
c326			 
c326 eb					ex de, hl 
c327 36 00				ld (hl), 0 
c329 23					inc hl 
c32a 36 00				ld (hl), 0 
c32c			 
c32c				 
c32c					 
c32c 21 bb e2				ld hl, scratch 
c32f			 
c32f					if DEBUG_FORTH_WORDS 
c32f						DMARK "MNx" 
c32f f5				push af  
c330 3a 44 c3			ld a, (.dmark)  
c333 32 65 ee			ld (debug_mark),a  
c336 3a 45 c3			ld a, (.dmark+1)  
c339 32 66 ee			ld (debug_mark+1),a  
c33c 3a 46 c3			ld a, (.dmark+2)  
c33f 32 67 ee			ld (debug_mark+2),a  
c342 18 03			jr .pastdmark  
c344 ..			.dmark: db "MNx"  
c347 f1			.pastdmark: pop af  
c348			endm  
# End of macro DMARK
c348						CALLMONITOR 
c348 cd 6f ee			call debug_vector  
c34b				endm  
# End of macro CALLMONITOR
c34b					endif 
c34b			 
c34b			 
c34b			 
c34b 3e 00				ld a, 0 
c34d cd ee 8a				call menu 
c350			 
c350			 
c350 6f					ld l, a 
c351 26 00				ld h, 0 
c353			 
c353					if DEBUG_FORTH_WORDS 
c353						DMARK "MNr" 
c353 f5				push af  
c354 3a 68 c3			ld a, (.dmark)  
c357 32 65 ee			ld (debug_mark),a  
c35a 3a 69 c3			ld a, (.dmark+1)  
c35d 32 66 ee			ld (debug_mark+1),a  
c360 3a 6a c3			ld a, (.dmark+2)  
c363 32 67 ee			ld (debug_mark+2),a  
c366 18 03			jr .pastdmark  
c368 ..			.dmark: db "MNr"  
c36b f1			.pastdmark: pop af  
c36c			endm  
# End of macro DMARK
c36c						CALLMONITOR 
c36c cd 6f ee			call debug_vector  
c36f				endm  
# End of macro CALLMONITOR
c36f					endif 
c36f			 
c36f cd 85 9a				call forth_push_numhl 
c372			 
c372			 
c372			 
c372			 
c372				       NEXTW 
c372 c3 75 9e			jp macro_next 
c375				endm 
# End of macro NEXTW
c375			 
c375			 
c375			.ENDDISPLAY: 
c375			 
c375			; eof 
# End of file forth_words_display.asm
c375			include "forth_words_str.asm" 
c375			 
c375			; | ## String Words 
c375			 
c375			.SPLIT:   
c375			 
c375				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c375 48				db WORD_SYS_CORE+52             
c376 6a c4			dw .PTR            
c378 06				db 5 + 1 
c379 .. 00			db "SPLIT",0              
c37f				endm 
# End of macro CWHEAD
c37f			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c37f					if DEBUG_FORTH_WORDS_KEY 
c37f						DMARK "SPT" 
c37f f5				push af  
c380 3a 94 c3			ld a, (.dmark)  
c383 32 65 ee			ld (debug_mark),a  
c386 3a 95 c3			ld a, (.dmark+1)  
c389 32 66 ee			ld (debug_mark+1),a  
c38c 3a 96 c3			ld a, (.dmark+2)  
c38f 32 67 ee			ld (debug_mark+2),a  
c392 18 03			jr .pastdmark  
c394 ..			.dmark: db "SPT"  
c397 f1			.pastdmark: pop af  
c398			endm  
# End of macro DMARK
c398						CALLMONITOR 
c398 cd 6f ee			call debug_vector  
c39b				endm  
# End of macro CALLMONITOR
c39b					endif 
c39b			 
c39b					; get delim 
c39b					FORTH_DSP_VALUEHL 
c39b cd 8a 9c			call macro_dsp_valuehl 
c39e				endm 
# End of macro FORTH_DSP_VALUEHL
c39e			 
c39e					FORTH_DSP_POP 
c39e cd 42 9d			call macro_forth_dsp_pop 
c3a1				endm 
# End of macro FORTH_DSP_POP
c3a1					 
c3a1			 
c3a1 45					ld b, l    ; move delim to b 
c3a2 0e 01				ld c, 1   ; count of poritions 
c3a4			 
c3a4 c5					push bc 
c3a5			 
c3a5					if DEBUG_FORTH_WORDS 
c3a5						DMARK "SPa" 
c3a5 f5				push af  
c3a6 3a ba c3			ld a, (.dmark)  
c3a9 32 65 ee			ld (debug_mark),a  
c3ac 3a bb c3			ld a, (.dmark+1)  
c3af 32 66 ee			ld (debug_mark+1),a  
c3b2 3a bc c3			ld a, (.dmark+2)  
c3b5 32 67 ee			ld (debug_mark+2),a  
c3b8 18 03			jr .pastdmark  
c3ba ..			.dmark: db "SPa"  
c3bd f1			.pastdmark: pop af  
c3be			endm  
# End of macro DMARK
c3be						CALLMONITOR 
c3be cd 6f ee			call debug_vector  
c3c1				endm  
# End of macro CALLMONITOR
c3c1					endif 
c3c1					; get pointer to string to chop up 
c3c1					FORTH_DSP_VALUEHL 
c3c1 cd 8a 9c			call macro_dsp_valuehl 
c3c4				endm 
# End of macro FORTH_DSP_VALUEHL
c3c4			 
c3c4			;		push hl 
c3c4 11 bb e2				ld de, scratch 
c3c7			.spllop: 
c3c7 c1					pop bc 
c3c8 c5					push bc 
c3c9			;		pop hl 
c3c9					if DEBUG_FORTH_WORDS 
c3c9						DMARK "SPl" 
c3c9 f5				push af  
c3ca 3a de c3			ld a, (.dmark)  
c3cd 32 65 ee			ld (debug_mark),a  
c3d0 3a df c3			ld a, (.dmark+1)  
c3d3 32 66 ee			ld (debug_mark+1),a  
c3d6 3a e0 c3			ld a, (.dmark+2)  
c3d9 32 67 ee			ld (debug_mark+2),a  
c3dc 18 03			jr .pastdmark  
c3de ..			.dmark: db "SPl"  
c3e1 f1			.pastdmark: pop af  
c3e2			endm  
# End of macro DMARK
c3e2						CALLMONITOR 
c3e2 cd 6f ee			call debug_vector  
c3e5				endm  
# End of macro CALLMONITOR
c3e5					endif 
c3e5 7e					ld a, (hl) 
c3e6 b8					cp b 
c3e7 28 08				jr z, .splnxt 
c3e9 fe 00				cp 0 
c3eb 28 34				jr z, .splend 
c3ed ed a0				ldi 
c3ef 18 d6				jr .spllop 
c3f1			 
c3f1					; hit dlim 
c3f1			 
c3f1			.splnxt: 
c3f1					if DEBUG_FORTH_WORDS 
c3f1						DMARK "SPx" 
c3f1 f5				push af  
c3f2 3a 06 c4			ld a, (.dmark)  
c3f5 32 65 ee			ld (debug_mark),a  
c3f8 3a 07 c4			ld a, (.dmark+1)  
c3fb 32 66 ee			ld (debug_mark+1),a  
c3fe 3a 08 c4			ld a, (.dmark+2)  
c401 32 67 ee			ld (debug_mark+2),a  
c404 18 03			jr .pastdmark  
c406 ..			.dmark: db "SPx"  
c409 f1			.pastdmark: pop af  
c40a			endm  
# End of macro DMARK
c40a						CALLMONITOR 
c40a cd 6f ee			call debug_vector  
c40d				endm  
# End of macro CALLMONITOR
c40d					endif 
c40d 3e 00				ld a, 0 
c40f 12					ld (de), a 
c410					;ex de, hl 
c410 e5					push hl 
c411 21 bb e2				ld hl, scratch 
c414 cd f3 9a				call forth_push_str 
c417 e1					pop hl 
c418					;ex de, hl 
c418 23					inc hl 
c419 c1					pop bc 
c41a 0c					inc c 
c41b c5					push bc 
c41c 11 bb e2				ld de, scratch 
c41f 18 a6				jr .spllop 
c421			 
c421			.splend:		 
c421					if DEBUG_FORTH_WORDS 
c421						DMARK "SPe" 
c421 f5				push af  
c422 3a 36 c4			ld a, (.dmark)  
c425 32 65 ee			ld (debug_mark),a  
c428 3a 37 c4			ld a, (.dmark+1)  
c42b 32 66 ee			ld (debug_mark+1),a  
c42e 3a 38 c4			ld a, (.dmark+2)  
c431 32 67 ee			ld (debug_mark+2),a  
c434 18 03			jr .pastdmark  
c436 ..			.dmark: db "SPe"  
c439 f1			.pastdmark: pop af  
c43a			endm  
# End of macro DMARK
c43a						CALLMONITOR 
c43a cd 6f ee			call debug_vector  
c43d				endm  
# End of macro CALLMONITOR
c43d					endif 
c43d 12					ld (de), a 
c43e eb					ex de, hl 
c43f			;		push hl 
c43f 21 bb e2				ld hl, scratch 
c442 cd f3 9a				call forth_push_str 
c445					 
c445					if DEBUG_FORTH_WORDS 
c445						DMARK "SPc" 
c445 f5				push af  
c446 3a 5a c4			ld a, (.dmark)  
c449 32 65 ee			ld (debug_mark),a  
c44c 3a 5b c4			ld a, (.dmark+1)  
c44f 32 66 ee			ld (debug_mark+1),a  
c452 3a 5c c4			ld a, (.dmark+2)  
c455 32 67 ee			ld (debug_mark+2),a  
c458 18 03			jr .pastdmark  
c45a ..			.dmark: db "SPc"  
c45d f1			.pastdmark: pop af  
c45e			endm  
# End of macro DMARK
c45e						CALLMONITOR 
c45e cd 6f ee			call debug_vector  
c461				endm  
# End of macro CALLMONITOR
c461					endif 
c461			 
c461 e1					pop hl    ; get counter from bc which has been push 
c462 26 00				ld h, 0 
c464			;		ld l, c 
c464 cd 85 9a				call forth_push_numhl 
c467			 
c467			 
c467				NEXTW 
c467 c3 75 9e			jp macro_next 
c46a				endm 
# End of macro NEXTW
c46a			.PTR:   
c46a			 
c46a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c46a 48				db WORD_SYS_CORE+52             
c46b 97 c4			dw .STYPE            
c46d 04				db 3 + 1 
c46e .. 00			db "PTR",0              
c472				endm 
# End of macro CWHEAD
c472			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c472			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c472			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c472			 
c472					if DEBUG_FORTH_WORDS_KEY 
c472						DMARK "PTR" 
c472 f5				push af  
c473 3a 87 c4			ld a, (.dmark)  
c476 32 65 ee			ld (debug_mark),a  
c479 3a 88 c4			ld a, (.dmark+1)  
c47c 32 66 ee			ld (debug_mark+1),a  
c47f 3a 89 c4			ld a, (.dmark+2)  
c482 32 67 ee			ld (debug_mark+2),a  
c485 18 03			jr .pastdmark  
c487 ..			.dmark: db "PTR"  
c48a f1			.pastdmark: pop af  
c48b			endm  
# End of macro DMARK
c48b						CALLMONITOR 
c48b cd 6f ee			call debug_vector  
c48e				endm  
# End of macro CALLMONITOR
c48e					endif 
c48e					FORTH_DSP_VALUEHL 
c48e cd 8a 9c			call macro_dsp_valuehl 
c491				endm 
# End of macro FORTH_DSP_VALUEHL
c491 cd 85 9a				call forth_push_numhl 
c494			 
c494			 
c494					NEXTW 
c494 c3 75 9e			jp macro_next 
c497				endm 
# End of macro NEXTW
c497			.STYPE: 
c497				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c497 48				db WORD_SYS_CORE+52             
c498 e6 c4			dw .UPPER            
c49a 06				db 5 + 1 
c49b .. 00			db "STYPE",0              
c4a1				endm 
# End of macro CWHEAD
c4a1			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
c4a1			; | | 's' string or 'i' integer 
c4a1					if DEBUG_FORTH_WORDS_KEY 
c4a1						DMARK "STY" 
c4a1 f5				push af  
c4a2 3a b6 c4			ld a, (.dmark)  
c4a5 32 65 ee			ld (debug_mark),a  
c4a8 3a b7 c4			ld a, (.dmark+1)  
c4ab 32 66 ee			ld (debug_mark+1),a  
c4ae 3a b8 c4			ld a, (.dmark+2)  
c4b1 32 67 ee			ld (debug_mark+2),a  
c4b4 18 03			jr .pastdmark  
c4b6 ..			.dmark: db "STY"  
c4b9 f1			.pastdmark: pop af  
c4ba			endm  
# End of macro DMARK
c4ba						CALLMONITOR 
c4ba cd 6f ee			call debug_vector  
c4bd				endm  
# End of macro CALLMONITOR
c4bd					endif 
c4bd					FORTH_DSP 
c4bd cd 50 9c			call macro_forth_dsp 
c4c0				endm 
# End of macro FORTH_DSP
c4c0					;v5 FORTH_DSP_VALUE 
c4c0			 
c4c0 7e					ld a, (hl) 
c4c1			 
c4c1 f5					push af 
c4c2			 
c4c2			; Dont destroy TOS		FORTH_DSP_POP 
c4c2			 
c4c2 f1					pop af 
c4c3			 
c4c3 fe 01				cp DS_TYPE_STR 
c4c5 28 09				jr z, .typestr 
c4c7			 
c4c7 fe 02				cp DS_TYPE_INUM 
c4c9 28 0a				jr z, .typeinum 
c4cb			 
c4cb 21 e4 c4				ld hl, .tna 
c4ce 18 0a				jr .tpush 
c4d0			 
c4d0 21 e0 c4		.typestr:	ld hl, .tstr 
c4d3 18 05				jr .tpush 
c4d5 21 e2 c4		.typeinum:	ld hl, .tinum 
c4d8 18 00				jr .tpush 
c4da			 
c4da			.tpush: 
c4da			 
c4da cd f3 9a				call forth_push_str 
c4dd			 
c4dd					NEXTW 
c4dd c3 75 9e			jp macro_next 
c4e0				endm 
# End of macro NEXTW
c4e0 .. 00		.tstr:	db "s",0 
c4e2 .. 00		.tinum:  db "i",0 
c4e4 .. 00		.tna:   db "?", 0 
c4e6			 
c4e6			 
c4e6			.UPPER: 
c4e6				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c4e6 48				db WORD_SYS_CORE+52             
c4e7 21 c5			dw .LOWER            
c4e9 06				db 5 + 1 
c4ea .. 00			db "UPPER",0              
c4f0				endm 
# End of macro CWHEAD
c4f0			; | UPPER ( s -- s ) Upper case string s  | DONE 
c4f0					if DEBUG_FORTH_WORDS_KEY 
c4f0						DMARK "UPR" 
c4f0 f5				push af  
c4f1 3a 05 c5			ld a, (.dmark)  
c4f4 32 65 ee			ld (debug_mark),a  
c4f7 3a 06 c5			ld a, (.dmark+1)  
c4fa 32 66 ee			ld (debug_mark+1),a  
c4fd 3a 07 c5			ld a, (.dmark+2)  
c500 32 67 ee			ld (debug_mark+2),a  
c503 18 03			jr .pastdmark  
c505 ..			.dmark: db "UPR"  
c508 f1			.pastdmark: pop af  
c509			endm  
# End of macro DMARK
c509						CALLMONITOR 
c509 cd 6f ee			call debug_vector  
c50c				endm  
# End of macro CALLMONITOR
c50c					endif 
c50c			 
c50c					FORTH_DSP 
c50c cd 50 9c			call macro_forth_dsp 
c50f				endm 
# End of macro FORTH_DSP
c50f					 
c50f			; TODO check is string type 
c50f			 
c50f					FORTH_DSP_VALUEHL 
c50f cd 8a 9c			call macro_dsp_valuehl 
c512				endm 
# End of macro FORTH_DSP_VALUEHL
c512			; get pointer to string in hl 
c512			 
c512 7e			.toup:		ld a, (hl) 
c513 fe 00				cp 0 
c515 28 07				jr z, .toupdone 
c517			 
c517 cd 5f 8f				call to_upper 
c51a			 
c51a 77					ld (hl), a 
c51b 23					inc hl 
c51c 18 f4				jr .toup 
c51e			 
c51e					 
c51e			 
c51e			 
c51e			; for each char convert to upper 
c51e					 
c51e			.toupdone: 
c51e			 
c51e			 
c51e					NEXTW 
c51e c3 75 9e			jp macro_next 
c521				endm 
# End of macro NEXTW
c521			.LOWER: 
c521				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c521 48				db WORD_SYS_CORE+52             
c522 5c c5			dw .TCASE            
c524 06				db 5 + 1 
c525 .. 00			db "LOWER",0              
c52b				endm 
# End of macro CWHEAD
c52b			; | LOWER ( s -- s ) Lower case string s  | DONE 
c52b					if DEBUG_FORTH_WORDS_KEY 
c52b						DMARK "LWR" 
c52b f5				push af  
c52c 3a 40 c5			ld a, (.dmark)  
c52f 32 65 ee			ld (debug_mark),a  
c532 3a 41 c5			ld a, (.dmark+1)  
c535 32 66 ee			ld (debug_mark+1),a  
c538 3a 42 c5			ld a, (.dmark+2)  
c53b 32 67 ee			ld (debug_mark+2),a  
c53e 18 03			jr .pastdmark  
c540 ..			.dmark: db "LWR"  
c543 f1			.pastdmark: pop af  
c544			endm  
# End of macro DMARK
c544						CALLMONITOR 
c544 cd 6f ee			call debug_vector  
c547				endm  
# End of macro CALLMONITOR
c547					endif 
c547			 
c547					FORTH_DSP 
c547 cd 50 9c			call macro_forth_dsp 
c54a				endm 
# End of macro FORTH_DSP
c54a					 
c54a			; TODO check is string type 
c54a			 
c54a					FORTH_DSP_VALUEHL 
c54a cd 8a 9c			call macro_dsp_valuehl 
c54d				endm 
# End of macro FORTH_DSP_VALUEHL
c54d			; get pointer to string in hl 
c54d			 
c54d 7e			.tolow:		ld a, (hl) 
c54e fe 00				cp 0 
c550 28 07				jr z, .tolowdone 
c552			 
c552 cd 68 8f				call to_lower 
c555			 
c555 77					ld (hl), a 
c556 23					inc hl 
c557 18 f4				jr .tolow 
c559			 
c559					 
c559			 
c559			 
c559			; for each char convert to low 
c559					 
c559			.tolowdone: 
c559					NEXTW 
c559 c3 75 9e			jp macro_next 
c55c				endm 
# End of macro NEXTW
c55c			.TCASE: 
c55c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c55c 48				db WORD_SYS_CORE+52             
c55d 92 c6			dw .SUBSTR            
c55f 06				db 5 + 1 
c560 .. 00			db "TCASE",0              
c566				endm 
# End of macro CWHEAD
c566			; | TCASE ( s -- s ) Title case string s  | DONE 
c566					if DEBUG_FORTH_WORDS_KEY 
c566						DMARK "TCS" 
c566 f5				push af  
c567 3a 7b c5			ld a, (.dmark)  
c56a 32 65 ee			ld (debug_mark),a  
c56d 3a 7c c5			ld a, (.dmark+1)  
c570 32 66 ee			ld (debug_mark+1),a  
c573 3a 7d c5			ld a, (.dmark+2)  
c576 32 67 ee			ld (debug_mark+2),a  
c579 18 03			jr .pastdmark  
c57b ..			.dmark: db "TCS"  
c57e f1			.pastdmark: pop af  
c57f			endm  
# End of macro DMARK
c57f						CALLMONITOR 
c57f cd 6f ee			call debug_vector  
c582				endm  
# End of macro CALLMONITOR
c582					endif 
c582			 
c582					FORTH_DSP 
c582 cd 50 9c			call macro_forth_dsp 
c585				endm 
# End of macro FORTH_DSP
c585					 
c585			; TODO check is string type 
c585			 
c585					FORTH_DSP_VALUEHL 
c585 cd 8a 9c			call macro_dsp_valuehl 
c588				endm 
# End of macro FORTH_DSP_VALUEHL
c588			; get pointer to string in hl 
c588			 
c588					if DEBUG_FORTH_WORDS 
c588						DMARK "TC1" 
c588 f5				push af  
c589 3a 9d c5			ld a, (.dmark)  
c58c 32 65 ee			ld (debug_mark),a  
c58f 3a 9e c5			ld a, (.dmark+1)  
c592 32 66 ee			ld (debug_mark+1),a  
c595 3a 9f c5			ld a, (.dmark+2)  
c598 32 67 ee			ld (debug_mark+2),a  
c59b 18 03			jr .pastdmark  
c59d ..			.dmark: db "TC1"  
c5a0 f1			.pastdmark: pop af  
c5a1			endm  
# End of macro DMARK
c5a1						CALLMONITOR 
c5a1 cd 6f ee			call debug_vector  
c5a4				endm  
# End of macro CALLMONITOR
c5a4					endif 
c5a4			 
c5a4					; first time in turn to upper case first char 
c5a4			 
c5a4 7e					ld a, (hl) 
c5a5 c3 2f c6				jp .totsiptou 
c5a8			 
c5a8			 
c5a8 7e			.tot:		ld a, (hl) 
c5a9 fe 00				cp 0 
c5ab ca 73 c6				jp z, .totdone 
c5ae			 
c5ae					if DEBUG_FORTH_WORDS 
c5ae						DMARK "TC2" 
c5ae f5				push af  
c5af 3a c3 c5			ld a, (.dmark)  
c5b2 32 65 ee			ld (debug_mark),a  
c5b5 3a c4 c5			ld a, (.dmark+1)  
c5b8 32 66 ee			ld (debug_mark+1),a  
c5bb 3a c5 c5			ld a, (.dmark+2)  
c5be 32 67 ee			ld (debug_mark+2),a  
c5c1 18 03			jr .pastdmark  
c5c3 ..			.dmark: db "TC2"  
c5c6 f1			.pastdmark: pop af  
c5c7			endm  
# End of macro DMARK
c5c7						CALLMONITOR 
c5c7 cd 6f ee			call debug_vector  
c5ca				endm  
# End of macro CALLMONITOR
c5ca					endif 
c5ca					; check to see if current char is a space 
c5ca			 
c5ca fe 20				cp ' ' 
c5cc 28 21				jr z, .totsp 
c5ce cd 68 8f				call to_lower 
c5d1					if DEBUG_FORTH_WORDS 
c5d1						DMARK "TC3" 
c5d1 f5				push af  
c5d2 3a e6 c5			ld a, (.dmark)  
c5d5 32 65 ee			ld (debug_mark),a  
c5d8 3a e7 c5			ld a, (.dmark+1)  
c5db 32 66 ee			ld (debug_mark+1),a  
c5de 3a e8 c5			ld a, (.dmark+2)  
c5e1 32 67 ee			ld (debug_mark+2),a  
c5e4 18 03			jr .pastdmark  
c5e6 ..			.dmark: db "TC3"  
c5e9 f1			.pastdmark: pop af  
c5ea			endm  
# End of macro DMARK
c5ea						CALLMONITOR 
c5ea cd 6f ee			call debug_vector  
c5ed				endm  
# End of macro CALLMONITOR
c5ed					endif 
c5ed 18 63				jr .totnxt 
c5ef			 
c5ef			.totsp:         ; on a space, find next char which should be upper 
c5ef			 
c5ef					if DEBUG_FORTH_WORDS 
c5ef						DMARK "TC4" 
c5ef f5				push af  
c5f0 3a 04 c6			ld a, (.dmark)  
c5f3 32 65 ee			ld (debug_mark),a  
c5f6 3a 05 c6			ld a, (.dmark+1)  
c5f9 32 66 ee			ld (debug_mark+1),a  
c5fc 3a 06 c6			ld a, (.dmark+2)  
c5ff 32 67 ee			ld (debug_mark+2),a  
c602 18 03			jr .pastdmark  
c604 ..			.dmark: db "TC4"  
c607 f1			.pastdmark: pop af  
c608			endm  
# End of macro DMARK
c608						CALLMONITOR 
c608 cd 6f ee			call debug_vector  
c60b				endm  
# End of macro CALLMONITOR
c60b					endif 
c60b					;; 
c60b			 
c60b fe 20				cp ' ' 
c60d 20 20				jr nz, .totsiptou 
c60f 23					inc hl 
c610 7e					ld a, (hl) 
c611					if DEBUG_FORTH_WORDS 
c611						DMARK "TC5" 
c611 f5				push af  
c612 3a 26 c6			ld a, (.dmark)  
c615 32 65 ee			ld (debug_mark),a  
c618 3a 27 c6			ld a, (.dmark+1)  
c61b 32 66 ee			ld (debug_mark+1),a  
c61e 3a 28 c6			ld a, (.dmark+2)  
c621 32 67 ee			ld (debug_mark+2),a  
c624 18 03			jr .pastdmark  
c626 ..			.dmark: db "TC5"  
c629 f1			.pastdmark: pop af  
c62a			endm  
# End of macro DMARK
c62a						CALLMONITOR 
c62a cd 6f ee			call debug_vector  
c62d				endm  
# End of macro CALLMONITOR
c62d					endif 
c62d 18 c0				jr .totsp 
c62f fe 00		.totsiptou:    cp 0 
c631 28 40				jr z, .totdone 
c633					; not space and not zero term so upper case it 
c633 cd 5f 8f				call to_upper 
c636			 
c636					if DEBUG_FORTH_WORDS 
c636						DMARK "TC6" 
c636 f5				push af  
c637 3a 4b c6			ld a, (.dmark)  
c63a 32 65 ee			ld (debug_mark),a  
c63d 3a 4c c6			ld a, (.dmark+1)  
c640 32 66 ee			ld (debug_mark+1),a  
c643 3a 4d c6			ld a, (.dmark+2)  
c646 32 67 ee			ld (debug_mark+2),a  
c649 18 03			jr .pastdmark  
c64b ..			.dmark: db "TC6"  
c64e f1			.pastdmark: pop af  
c64f			endm  
# End of macro DMARK
c64f						CALLMONITOR 
c64f cd 6f ee			call debug_vector  
c652				endm  
# End of macro CALLMONITOR
c652					endif 
c652			 
c652			 
c652			.totnxt: 
c652			 
c652 77					ld (hl), a 
c653 23					inc hl 
c654					if DEBUG_FORTH_WORDS 
c654						DMARK "TC7" 
c654 f5				push af  
c655 3a 69 c6			ld a, (.dmark)  
c658 32 65 ee			ld (debug_mark),a  
c65b 3a 6a c6			ld a, (.dmark+1)  
c65e 32 66 ee			ld (debug_mark+1),a  
c661 3a 6b c6			ld a, (.dmark+2)  
c664 32 67 ee			ld (debug_mark+2),a  
c667 18 03			jr .pastdmark  
c669 ..			.dmark: db "TC7"  
c66c f1			.pastdmark: pop af  
c66d			endm  
# End of macro DMARK
c66d						CALLMONITOR 
c66d cd 6f ee			call debug_vector  
c670				endm  
# End of macro CALLMONITOR
c670					endif 
c670 c3 a8 c5				jp .tot 
c673			 
c673					 
c673			 
c673			 
c673			; for each char convert to low 
c673					 
c673			.totdone: 
c673					if DEBUG_FORTH_WORDS 
c673						DMARK "TCd" 
c673 f5				push af  
c674 3a 88 c6			ld a, (.dmark)  
c677 32 65 ee			ld (debug_mark),a  
c67a 3a 89 c6			ld a, (.dmark+1)  
c67d 32 66 ee			ld (debug_mark+1),a  
c680 3a 8a c6			ld a, (.dmark+2)  
c683 32 67 ee			ld (debug_mark+2),a  
c686 18 03			jr .pastdmark  
c688 ..			.dmark: db "TCd"  
c68b f1			.pastdmark: pop af  
c68c			endm  
# End of macro DMARK
c68c						CALLMONITOR 
c68c cd 6f ee			call debug_vector  
c68f				endm  
# End of macro CALLMONITOR
c68f					endif 
c68f					NEXTW 
c68f c3 75 9e			jp macro_next 
c692				endm 
# End of macro NEXTW
c692			 
c692			.SUBSTR: 
c692				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c692 48				db WORD_SYS_CORE+52             
c693 f0 c6			dw .LEFT            
c695 07				db 6 + 1 
c696 .. 00			db "SUBSTR",0              
c69d				endm 
# End of macro CWHEAD
c69d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c69d			 
c69d					if DEBUG_FORTH_WORDS_KEY 
c69d						DMARK "SST" 
c69d f5				push af  
c69e 3a b2 c6			ld a, (.dmark)  
c6a1 32 65 ee			ld (debug_mark),a  
c6a4 3a b3 c6			ld a, (.dmark+1)  
c6a7 32 66 ee			ld (debug_mark+1),a  
c6aa 3a b4 c6			ld a, (.dmark+2)  
c6ad 32 67 ee			ld (debug_mark+2),a  
c6b0 18 03			jr .pastdmark  
c6b2 ..			.dmark: db "SST"  
c6b5 f1			.pastdmark: pop af  
c6b6			endm  
# End of macro DMARK
c6b6						CALLMONITOR 
c6b6 cd 6f ee			call debug_vector  
c6b9				endm  
# End of macro CALLMONITOR
c6b9					endif 
c6b9			; TODO check string type 
c6b9					FORTH_DSP_VALUEHL 
c6b9 cd 8a 9c			call macro_dsp_valuehl 
c6bc				endm 
# End of macro FORTH_DSP_VALUEHL
c6bc			 
c6bc e5					push hl      ; string length 
c6bd			 
c6bd					FORTH_DSP_POP 
c6bd cd 42 9d			call macro_forth_dsp_pop 
c6c0				endm 
# End of macro FORTH_DSP_POP
c6c0			 
c6c0					FORTH_DSP_VALUEHL 
c6c0 cd 8a 9c			call macro_dsp_valuehl 
c6c3				endm 
# End of macro FORTH_DSP_VALUEHL
c6c3			 
c6c3 e5					push hl     ; start char 
c6c4			 
c6c4					FORTH_DSP_POP 
c6c4 cd 42 9d			call macro_forth_dsp_pop 
c6c7				endm 
# End of macro FORTH_DSP_POP
c6c7			 
c6c7			 
c6c7					FORTH_DSP_VALUE 
c6c7 cd 73 9c			call macro_forth_dsp_value 
c6ca				endm 
# End of macro FORTH_DSP_VALUE
c6ca			 
c6ca d1					pop de    ; get start post offset 
c6cb			 
c6cb 19					add hl, de    ; starting offset 
c6cc			 
c6cc c1					pop bc 
c6cd c5					push bc      ; grab size of string 
c6ce			 
c6ce e5					push hl    ; save string start  
c6cf			 
c6cf 26 00				ld h, 0 
c6d1 69					ld l, c 
c6d2 23					inc hl 
c6d3 23					inc hl 
c6d4			 
c6d4 cd c5 90				call malloc 
c6d7				if DEBUG_FORTH_MALLOC_GUARD 
c6d7 cc 6d d1				call z,malloc_error 
c6da				endif 
c6da			 
c6da eb					ex de, hl      ; save malloc area for string copy 
c6db e1					pop hl    ; get back source 
c6dc c1					pop bc    ; get length of string back 
c6dd			 
c6dd d5					push de    ; save malloc area for after we push 
c6de ed b0				ldir     ; copy substr 
c6e0			 
c6e0			 
c6e0 eb					ex de, hl 
c6e1 3e 00				ld a, 0 
c6e3 77					ld (hl), a   ; term substr 
c6e4			 
c6e4					 
c6e4 e1					pop hl    ; get malloc so we can push it 
c6e5 e5					push hl   ; save so we can free it afterwards 
c6e6			 
c6e6 cd f3 9a				call forth_push_str 
c6e9			 
c6e9 e1					pop hl 
c6ea cd 8f 91				call free 
c6ed			 
c6ed					 
c6ed					 
c6ed			 
c6ed			 
c6ed					NEXTW 
c6ed c3 75 9e			jp macro_next 
c6f0				endm 
# End of macro NEXTW
c6f0			 
c6f0			.LEFT: 
c6f0				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c6f0 48				db WORD_SYS_CORE+52             
c6f1 31 c7			dw .RIGHT            
c6f3 05				db 4 + 1 
c6f4 .. 00			db "LEFT",0              
c6f9				endm 
# End of macro CWHEAD
c6f9			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
c6f9					if DEBUG_FORTH_WORDS_KEY 
c6f9						DMARK "LEF" 
c6f9 f5				push af  
c6fa 3a 0e c7			ld a, (.dmark)  
c6fd 32 65 ee			ld (debug_mark),a  
c700 3a 0f c7			ld a, (.dmark+1)  
c703 32 66 ee			ld (debug_mark+1),a  
c706 3a 10 c7			ld a, (.dmark+2)  
c709 32 67 ee			ld (debug_mark+2),a  
c70c 18 03			jr .pastdmark  
c70e ..			.dmark: db "LEF"  
c711 f1			.pastdmark: pop af  
c712			endm  
# End of macro DMARK
c712						CALLMONITOR 
c712 cd 6f ee			call debug_vector  
c715				endm  
# End of macro CALLMONITOR
c715					endif 
c715			 
c715					 
c715			; TODO check string type 
c715					FORTH_DSP_VALUEHL 
c715 cd 8a 9c			call macro_dsp_valuehl 
c718				endm 
# End of macro FORTH_DSP_VALUEHL
c718			 
c718 e5					push hl      ; string length 
c719			 
c719					FORTH_DSP_POP 
c719 cd 42 9d			call macro_forth_dsp_pop 
c71c				endm 
# End of macro FORTH_DSP_POP
c71c			 
c71c					FORTH_DSP_VALUEHL 
c71c cd 8a 9c			call macro_dsp_valuehl 
c71f				endm 
# End of macro FORTH_DSP_VALUEHL
c71f			 
c71f c1					pop bc 
c720			 
c720 11 bb e2				ld de, scratch 
c723 ed b0				ldir 
c725 3e 00				ld a, 0 
c727 12					ld (de), a 
c728					 
c728 21 bb e2				ld hl, scratch 
c72b cd f3 9a				call forth_push_str 
c72e			 
c72e					NEXTW 
c72e c3 75 9e			jp macro_next 
c731				endm 
# End of macro NEXTW
c731			.RIGHT: 
c731				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c731 48				db WORD_SYS_CORE+52             
c732 ef c7			dw .STR2NUM            
c734 06				db 5 + 1 
c735 .. 00			db "RIGHT",0              
c73b				endm 
# End of macro CWHEAD
c73b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
c73b					if DEBUG_FORTH_WORDS_KEY 
c73b						DMARK "RIG" 
c73b f5				push af  
c73c 3a 50 c7			ld a, (.dmark)  
c73f 32 65 ee			ld (debug_mark),a  
c742 3a 51 c7			ld a, (.dmark+1)  
c745 32 66 ee			ld (debug_mark+1),a  
c748 3a 52 c7			ld a, (.dmark+2)  
c74b 32 67 ee			ld (debug_mark+2),a  
c74e 18 03			jr .pastdmark  
c750 ..			.dmark: db "RIG"  
c753 f1			.pastdmark: pop af  
c754			endm  
# End of macro DMARK
c754						CALLMONITOR 
c754 cd 6f ee			call debug_vector  
c757				endm  
# End of macro CALLMONITOR
c757					endif 
c757			 
c757			; TODO check string type 
c757					FORTH_DSP_VALUEHL 
c757 cd 8a 9c			call macro_dsp_valuehl 
c75a				endm 
# End of macro FORTH_DSP_VALUEHL
c75a			 
c75a e5					push hl      ; string length 
c75b			 
c75b					FORTH_DSP_POP 
c75b cd 42 9d			call macro_forth_dsp_pop 
c75e				endm 
# End of macro FORTH_DSP_POP
c75e			 
c75e					FORTH_DSP_VALUEHL 
c75e cd 8a 9c			call macro_dsp_valuehl 
c761				endm 
# End of macro FORTH_DSP_VALUEHL
c761			 
c761					if DEBUG_FORTH_WORDS 
c761						DMARK "RI1" 
c761 f5				push af  
c762 3a 76 c7			ld a, (.dmark)  
c765 32 65 ee			ld (debug_mark),a  
c768 3a 77 c7			ld a, (.dmark+1)  
c76b 32 66 ee			ld (debug_mark+1),a  
c76e 3a 78 c7			ld a, (.dmark+2)  
c771 32 67 ee			ld (debug_mark+2),a  
c774 18 03			jr .pastdmark  
c776 ..			.dmark: db "RI1"  
c779 f1			.pastdmark: pop af  
c77a			endm  
# End of macro DMARK
c77a						CALLMONITOR 
c77a cd 6f ee			call debug_vector  
c77d				endm  
# End of macro CALLMONITOR
c77d					endif 
c77d					; from the pointer to string get to the end of string 
c77d			 
c77d 01 ff 00				ld bc, 255 
c780 3e 00				ld a, 0 
c782 ed b1				cpir 
c784 2b					dec hl 
c785			 
c785					;  
c785			 
c785					if DEBUG_FORTH_WORDS 
c785						DMARK "RI2" 
c785 f5				push af  
c786 3a 9a c7			ld a, (.dmark)  
c789 32 65 ee			ld (debug_mark),a  
c78c 3a 9b c7			ld a, (.dmark+1)  
c78f 32 66 ee			ld (debug_mark+1),a  
c792 3a 9c c7			ld a, (.dmark+2)  
c795 32 67 ee			ld (debug_mark+2),a  
c798 18 03			jr .pastdmark  
c79a ..			.dmark: db "RI2"  
c79d f1			.pastdmark: pop af  
c79e			endm  
# End of macro DMARK
c79e						CALLMONITOR 
c79e cd 6f ee			call debug_vector  
c7a1				endm  
# End of macro CALLMONITOR
c7a1					endif 
c7a1			 
c7a1 c1					pop bc    ;  length of string to copy 
c7a2			 
c7a2 79					ld a, c 
c7a3 eb					ex de, hl 
c7a4 21 bb e2				ld hl, scratch  
c7a7 cd ea 8c				call addatohl 
c7aa			 
c7aa eb					ex de, hl 
c7ab			 
c7ab					if DEBUG_FORTH_WORDS 
c7ab						DMARK "RI3" 
c7ab f5				push af  
c7ac 3a c0 c7			ld a, (.dmark)  
c7af 32 65 ee			ld (debug_mark),a  
c7b2 3a c1 c7			ld a, (.dmark+1)  
c7b5 32 66 ee			ld (debug_mark+1),a  
c7b8 3a c2 c7			ld a, (.dmark+2)  
c7bb 32 67 ee			ld (debug_mark+2),a  
c7be 18 03			jr .pastdmark  
c7c0 ..			.dmark: db "RI3"  
c7c3 f1			.pastdmark: pop af  
c7c4			endm  
# End of macro DMARK
c7c4						CALLMONITOR 
c7c4 cd 6f ee			call debug_vector  
c7c7				endm  
# End of macro CALLMONITOR
c7c7					endif 
c7c7			 
c7c7 03					inc bc 
c7c8 ed b8				lddr 
c7ca					 
c7ca 21 bb e2				ld hl, scratch 
c7cd					if DEBUG_FORTH_WORDS 
c7cd						DMARK "RI4" 
c7cd f5				push af  
c7ce 3a e2 c7			ld a, (.dmark)  
c7d1 32 65 ee			ld (debug_mark),a  
c7d4 3a e3 c7			ld a, (.dmark+1)  
c7d7 32 66 ee			ld (debug_mark+1),a  
c7da 3a e4 c7			ld a, (.dmark+2)  
c7dd 32 67 ee			ld (debug_mark+2),a  
c7e0 18 03			jr .pastdmark  
c7e2 ..			.dmark: db "RI4"  
c7e5 f1			.pastdmark: pop af  
c7e6			endm  
# End of macro DMARK
c7e6						CALLMONITOR 
c7e6 cd 6f ee			call debug_vector  
c7e9				endm  
# End of macro CALLMONITOR
c7e9					endif 
c7e9 cd f3 9a				call forth_push_str 
c7ec			 
c7ec			 
c7ec					NEXTW 
c7ec c3 75 9e			jp macro_next 
c7ef				endm 
# End of macro NEXTW
c7ef			 
c7ef			 
c7ef			.STR2NUM: 
c7ef				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c7ef 48				db WORD_SYS_CORE+52             
c7f0 7b c8			dw .NUM2STR            
c7f2 08				db 7 + 1 
c7f3 .. 00			db "STR2NUM",0              
c7fb				endm 
# End of macro CWHEAD
c7fb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c7fb			 
c7fb			 
c7fb			; TODO STR type check to do 
c7fb					if DEBUG_FORTH_WORDS_KEY 
c7fb						DMARK "S2N" 
c7fb f5				push af  
c7fc 3a 10 c8			ld a, (.dmark)  
c7ff 32 65 ee			ld (debug_mark),a  
c802 3a 11 c8			ld a, (.dmark+1)  
c805 32 66 ee			ld (debug_mark+1),a  
c808 3a 12 c8			ld a, (.dmark+2)  
c80b 32 67 ee			ld (debug_mark+2),a  
c80e 18 03			jr .pastdmark  
c810 ..			.dmark: db "S2N"  
c813 f1			.pastdmark: pop af  
c814			endm  
# End of macro DMARK
c814						CALLMONITOR 
c814 cd 6f ee			call debug_vector  
c817				endm  
# End of macro CALLMONITOR
c817					endif 
c817			 
c817					;FORTH_DSP 
c817					FORTH_DSP_VALUE 
c817 cd 73 9c			call macro_forth_dsp_value 
c81a				endm 
# End of macro FORTH_DSP_VALUE
c81a					;inc hl 
c81a			 
c81a eb					ex de, hl 
c81b					if DEBUG_FORTH_WORDS 
c81b						DMARK "S2a" 
c81b f5				push af  
c81c 3a 30 c8			ld a, (.dmark)  
c81f 32 65 ee			ld (debug_mark),a  
c822 3a 31 c8			ld a, (.dmark+1)  
c825 32 66 ee			ld (debug_mark+1),a  
c828 3a 32 c8			ld a, (.dmark+2)  
c82b 32 67 ee			ld (debug_mark+2),a  
c82e 18 03			jr .pastdmark  
c830 ..			.dmark: db "S2a"  
c833 f1			.pastdmark: pop af  
c834			endm  
# End of macro DMARK
c834						CALLMONITOR 
c834 cd 6f ee			call debug_vector  
c837				endm  
# End of macro CALLMONITOR
c837					endif 
c837 cd e7 8f				call string_to_uint16 
c83a			 
c83a					if DEBUG_FORTH_WORDS 
c83a						DMARK "S2b" 
c83a f5				push af  
c83b 3a 4f c8			ld a, (.dmark)  
c83e 32 65 ee			ld (debug_mark),a  
c841 3a 50 c8			ld a, (.dmark+1)  
c844 32 66 ee			ld (debug_mark+1),a  
c847 3a 51 c8			ld a, (.dmark+2)  
c84a 32 67 ee			ld (debug_mark+2),a  
c84d 18 03			jr .pastdmark  
c84f ..			.dmark: db "S2b"  
c852 f1			.pastdmark: pop af  
c853			endm  
# End of macro DMARK
c853						CALLMONITOR 
c853 cd 6f ee			call debug_vector  
c856				endm  
# End of macro CALLMONITOR
c856					endif 
c856			;		push hl 
c856					FORTH_DSP_POP 
c856 cd 42 9d			call macro_forth_dsp_pop 
c859				endm 
# End of macro FORTH_DSP_POP
c859			;		pop hl 
c859					 
c859					if DEBUG_FORTH_WORDS 
c859						DMARK "S2b" 
c859 f5				push af  
c85a 3a 6e c8			ld a, (.dmark)  
c85d 32 65 ee			ld (debug_mark),a  
c860 3a 6f c8			ld a, (.dmark+1)  
c863 32 66 ee			ld (debug_mark+1),a  
c866 3a 70 c8			ld a, (.dmark+2)  
c869 32 67 ee			ld (debug_mark+2),a  
c86c 18 03			jr .pastdmark  
c86e ..			.dmark: db "S2b"  
c871 f1			.pastdmark: pop af  
c872			endm  
# End of macro DMARK
c872						CALLMONITOR 
c872 cd 6f ee			call debug_vector  
c875				endm  
# End of macro CALLMONITOR
c875					endif 
c875 cd 85 9a				call forth_push_numhl	 
c878			 
c878				 
c878				       NEXTW 
c878 c3 75 9e			jp macro_next 
c87b				endm 
# End of macro NEXTW
c87b			.NUM2STR: 
c87b				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c87b 48				db WORD_SYS_CORE+52             
c87c 0d c9			dw .CONCAT            
c87e 08				db 7 + 1 
c87f .. 00			db "NUM2STR",0              
c887				endm 
# End of macro CWHEAD
c887			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c887			 
c887			;		; malloc a string to target 
c887			;		ld hl, 10     ; TODO max string size should be fine 
c887			;		call malloc 
c887			;		push hl    ; save malloc location 
c887			; 
c887			; 
c887			;; TODO check int type 
c887					if DEBUG_FORTH_WORDS_KEY 
c887						DMARK "N2S" 
c887 f5				push af  
c888 3a 9c c8			ld a, (.dmark)  
c88b 32 65 ee			ld (debug_mark),a  
c88e 3a 9d c8			ld a, (.dmark+1)  
c891 32 66 ee			ld (debug_mark+1),a  
c894 3a 9e c8			ld a, (.dmark+2)  
c897 32 67 ee			ld (debug_mark+2),a  
c89a 18 03			jr .pastdmark  
c89c ..			.dmark: db "N2S"  
c89f f1			.pastdmark: pop af  
c8a0			endm  
# End of macro DMARK
c8a0						CALLMONITOR 
c8a0 cd 6f ee			call debug_vector  
c8a3				endm  
# End of macro CALLMONITOR
c8a3					endif 
c8a3			 
c8a3					FORTH_DSP_VALUEHL 
c8a3 cd 8a 9c			call macro_dsp_valuehl 
c8a6				endm 
# End of macro FORTH_DSP_VALUEHL
c8a6			 
c8a6					if DEBUG_FORTH_WORDS 
c8a6						DMARK "NS1" 
c8a6 f5				push af  
c8a7 3a bb c8			ld a, (.dmark)  
c8aa 32 65 ee			ld (debug_mark),a  
c8ad 3a bc c8			ld a, (.dmark+1)  
c8b0 32 66 ee			ld (debug_mark+1),a  
c8b3 3a bd c8			ld a, (.dmark+2)  
c8b6 32 67 ee			ld (debug_mark+2),a  
c8b9 18 03			jr .pastdmark  
c8bb ..			.dmark: db "NS1"  
c8be f1			.pastdmark: pop af  
c8bf			endm  
# End of macro DMARK
c8bf						CALLMONITOR 
c8bf cd 6f ee			call debug_vector  
c8c2				endm  
# End of macro CALLMONITOR
c8c2					endif 
c8c2					FORTH_DSP_POP 
c8c2 cd 42 9d			call macro_forth_dsp_pop 
c8c5				endm 
# End of macro FORTH_DSP_POP
c8c5			 
c8c5 eb					ex de, hl 
c8c6 21 bb e2				ld hl, scratch 
c8c9					if DEBUG_FORTH_WORDS 
c8c9						DMARK "NS2" 
c8c9 f5				push af  
c8ca 3a de c8			ld a, (.dmark)  
c8cd 32 65 ee			ld (debug_mark),a  
c8d0 3a df c8			ld a, (.dmark+1)  
c8d3 32 66 ee			ld (debug_mark+1),a  
c8d6 3a e0 c8			ld a, (.dmark+2)  
c8d9 32 67 ee			ld (debug_mark+2),a  
c8dc 18 03			jr .pastdmark  
c8de ..			.dmark: db "NS2"  
c8e1 f1			.pastdmark: pop af  
c8e2			endm  
# End of macro DMARK
c8e2						CALLMONITOR 
c8e2 cd 6f ee			call debug_vector  
c8e5				endm  
# End of macro CALLMONITOR
c8e5					endif 
c8e5 cd ff 8f				call uitoa_16 
c8e8 21 bb e2				ld hl, scratch 
c8eb					if DEBUG_FORTH_WORDS 
c8eb						DMARK "NS3" 
c8eb f5				push af  
c8ec 3a 00 c9			ld a, (.dmark)  
c8ef 32 65 ee			ld (debug_mark),a  
c8f2 3a 01 c9			ld a, (.dmark+1)  
c8f5 32 66 ee			ld (debug_mark+1),a  
c8f8 3a 02 c9			ld a, (.dmark+2)  
c8fb 32 67 ee			ld (debug_mark+2),a  
c8fe 18 03			jr .pastdmark  
c900 ..			.dmark: db "NS3"  
c903 f1			.pastdmark: pop af  
c904			endm  
# End of macro DMARK
c904						CALLMONITOR 
c904 cd 6f ee			call debug_vector  
c907				endm  
# End of macro CALLMONITOR
c907					endif 
c907 cd f3 9a				call forth_push_str 
c90a			;		ld a, l 
c90a			;		call DispAToASCII   
c90a			;;TODO need to chage above call to dump into string 
c90a			; 
c90a			; 
c90a			 
c90a				       NEXTW 
c90a c3 75 9e			jp macro_next 
c90d				endm 
# End of macro NEXTW
c90d			 
c90d			.CONCAT: 
c90d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c90d 48				db WORD_SYS_CORE+52             
c90e c0 c9			dw .FIND            
c910 07				db 6 + 1 
c911 .. 00			db "CONCAT",0              
c918				endm 
# End of macro CWHEAD
c918			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c918			 
c918			; TODO check string type 
c918			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c918			 
c918					if DEBUG_FORTH_WORDS_KEY 
c918						DMARK "CON" 
c918 f5				push af  
c919 3a 2d c9			ld a, (.dmark)  
c91c 32 65 ee			ld (debug_mark),a  
c91f 3a 2e c9			ld a, (.dmark+1)  
c922 32 66 ee			ld (debug_mark+1),a  
c925 3a 2f c9			ld a, (.dmark+2)  
c928 32 67 ee			ld (debug_mark+2),a  
c92b 18 03			jr .pastdmark  
c92d ..			.dmark: db "CON"  
c930 f1			.pastdmark: pop af  
c931			endm  
# End of macro DMARK
c931						CALLMONITOR 
c931 cd 6f ee			call debug_vector  
c934				endm  
# End of macro CALLMONITOR
c934					endif 
c934			 
c934			 
c934					FORTH_DSP_VALUE 
c934 cd 73 9c			call macro_forth_dsp_value 
c937				endm 
# End of macro FORTH_DSP_VALUE
c937 e5					push hl   ; s2 
c938			 
c938					FORTH_DSP_POP 
c938 cd 42 9d			call macro_forth_dsp_pop 
c93b				endm 
# End of macro FORTH_DSP_POP
c93b			 
c93b					FORTH_DSP_VALUE 
c93b cd 73 9c			call macro_forth_dsp_value 
c93e				endm 
# End of macro FORTH_DSP_VALUE
c93e			 
c93e e5					push hl   ; s1 
c93f			 
c93f					FORTH_DSP_POP 
c93f cd 42 9d			call macro_forth_dsp_pop 
c942				endm 
# End of macro FORTH_DSP_POP
c942					 
c942			 
c942					; copy s1 
c942			 
c942				 
c942					; save ptr 
c942 e1					pop hl  
c943 e5					push hl 
c944 3e 00				ld a, 0 
c946 cd 5b 90				call strlent 
c949					;inc hl    ; zer0 
c949 06 00				ld b, 0 
c94b 4d					ld c, l 
c94c e1					pop hl		 
c94d 11 bb e2				ld de, scratch	 
c950					if DEBUG_FORTH_WORDS 
c950						DMARK "CO1" 
c950 f5				push af  
c951 3a 65 c9			ld a, (.dmark)  
c954 32 65 ee			ld (debug_mark),a  
c957 3a 66 c9			ld a, (.dmark+1)  
c95a 32 66 ee			ld (debug_mark+1),a  
c95d 3a 67 c9			ld a, (.dmark+2)  
c960 32 67 ee			ld (debug_mark+2),a  
c963 18 03			jr .pastdmark  
c965 ..			.dmark: db "CO1"  
c968 f1			.pastdmark: pop af  
c969			endm  
# End of macro DMARK
c969						CALLMONITOR 
c969 cd 6f ee			call debug_vector  
c96c				endm  
# End of macro CALLMONITOR
c96c					endif 
c96c ed b0				ldir 
c96e			 
c96e e1					pop hl 
c96f e5					push hl 
c970 d5					push de 
c971			 
c971			 
c971 3e 00				ld a, 0 
c973 cd 5b 90				call strlent 
c976 23					inc hl    ; zer0 
c977 23					inc hl 
c978 06 00				ld b, 0 
c97a 4d					ld c, l 
c97b d1					pop de 
c97c e1					pop hl		 
c97d					if DEBUG_FORTH_WORDS 
c97d						DMARK "CO2" 
c97d f5				push af  
c97e 3a 92 c9			ld a, (.dmark)  
c981 32 65 ee			ld (debug_mark),a  
c984 3a 93 c9			ld a, (.dmark+1)  
c987 32 66 ee			ld (debug_mark+1),a  
c98a 3a 94 c9			ld a, (.dmark+2)  
c98d 32 67 ee			ld (debug_mark+2),a  
c990 18 03			jr .pastdmark  
c992 ..			.dmark: db "CO2"  
c995 f1			.pastdmark: pop af  
c996			endm  
# End of macro DMARK
c996						CALLMONITOR 
c996 cd 6f ee			call debug_vector  
c999				endm  
# End of macro CALLMONITOR
c999					endif 
c999 ed b0				ldir 
c99b			 
c99b			 
c99b			 
c99b 21 bb e2				ld hl, scratch 
c99e					if DEBUG_FORTH_WORDS 
c99e						DMARK "CO5" 
c99e f5				push af  
c99f 3a b3 c9			ld a, (.dmark)  
c9a2 32 65 ee			ld (debug_mark),a  
c9a5 3a b4 c9			ld a, (.dmark+1)  
c9a8 32 66 ee			ld (debug_mark+1),a  
c9ab 3a b5 c9			ld a, (.dmark+2)  
c9ae 32 67 ee			ld (debug_mark+2),a  
c9b1 18 03			jr .pastdmark  
c9b3 ..			.dmark: db "CO5"  
c9b6 f1			.pastdmark: pop af  
c9b7			endm  
# End of macro DMARK
c9b7						CALLMONITOR 
c9b7 cd 6f ee			call debug_vector  
c9ba				endm  
# End of macro CALLMONITOR
c9ba					endif 
c9ba			 
c9ba cd f3 9a				call forth_push_str 
c9bd			 
c9bd			 
c9bd			 
c9bd			 
c9bd				       NEXTW 
c9bd c3 75 9e			jp macro_next 
c9c0				endm 
# End of macro NEXTW
c9c0			 
c9c0			 
c9c0			.FIND: 
c9c0				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c9c0 4b				db WORD_SYS_CORE+55             
c9c1 7e ca			dw .LEN            
c9c3 05				db 4 + 1 
c9c4 .. 00			db "FIND",0              
c9c9				endm 
# End of macro CWHEAD
c9c9			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c9c9			 
c9c9					if DEBUG_FORTH_WORDS_KEY 
c9c9						DMARK "FND" 
c9c9 f5				push af  
c9ca 3a de c9			ld a, (.dmark)  
c9cd 32 65 ee			ld (debug_mark),a  
c9d0 3a df c9			ld a, (.dmark+1)  
c9d3 32 66 ee			ld (debug_mark+1),a  
c9d6 3a e0 c9			ld a, (.dmark+2)  
c9d9 32 67 ee			ld (debug_mark+2),a  
c9dc 18 03			jr .pastdmark  
c9de ..			.dmark: db "FND"  
c9e1 f1			.pastdmark: pop af  
c9e2			endm  
# End of macro DMARK
c9e2						CALLMONITOR 
c9e2 cd 6f ee			call debug_vector  
c9e5				endm  
# End of macro CALLMONITOR
c9e5					endif 
c9e5			 
c9e5			; TODO check string type 
c9e5					FORTH_DSP_VALUE 
c9e5 cd 73 9c			call macro_forth_dsp_value 
c9e8				endm 
# End of macro FORTH_DSP_VALUE
c9e8			 
c9e8 e5					push hl    
c9e9 7e					ld a,(hl)    ; char to find   
c9ea			; TODO change char to substr 
c9ea			 
c9ea f5					push af 
c9eb					 
c9eb			 
c9eb			 
c9eb					if DEBUG_FORTH_WORDS 
c9eb						DMARK "FN1" 
c9eb f5				push af  
c9ec 3a 00 ca			ld a, (.dmark)  
c9ef 32 65 ee			ld (debug_mark),a  
c9f2 3a 01 ca			ld a, (.dmark+1)  
c9f5 32 66 ee			ld (debug_mark+1),a  
c9f8 3a 02 ca			ld a, (.dmark+2)  
c9fb 32 67 ee			ld (debug_mark+2),a  
c9fe 18 03			jr .pastdmark  
ca00 ..			.dmark: db "FN1"  
ca03 f1			.pastdmark: pop af  
ca04			endm  
# End of macro DMARK
ca04						CALLMONITOR 
ca04 cd 6f ee			call debug_vector  
ca07				endm  
# End of macro CALLMONITOR
ca07					endif 
ca07			 
ca07					FORTH_DSP_POP 
ca07 cd 42 9d			call macro_forth_dsp_pop 
ca0a				endm 
# End of macro FORTH_DSP_POP
ca0a			 
ca0a					; string to search 
ca0a			 
ca0a					FORTH_DSP_VALUE 
ca0a cd 73 9c			call macro_forth_dsp_value 
ca0d				endm 
# End of macro FORTH_DSP_VALUE
ca0d			 
ca0d d1					pop de  ; d is char to find  
ca0e			 
ca0e					if DEBUG_FORTH_WORDS 
ca0e						DMARK "FN2" 
ca0e f5				push af  
ca0f 3a 23 ca			ld a, (.dmark)  
ca12 32 65 ee			ld (debug_mark),a  
ca15 3a 24 ca			ld a, (.dmark+1)  
ca18 32 66 ee			ld (debug_mark+1),a  
ca1b 3a 25 ca			ld a, (.dmark+2)  
ca1e 32 67 ee			ld (debug_mark+2),a  
ca21 18 03			jr .pastdmark  
ca23 ..			.dmark: db "FN2"  
ca26 f1			.pastdmark: pop af  
ca27			endm  
# End of macro DMARK
ca27						CALLMONITOR 
ca27 cd 6f ee			call debug_vector  
ca2a				endm  
# End of macro CALLMONITOR
ca2a					endif 
ca2a					 
ca2a 01 00 00				ld bc, 0 
ca2d 7e			.findchar:      ld a,(hl) 
ca2e fe 00				cp 0   		 
ca30 28 27				jr z, .finddone     
ca32 ba					cp d 
ca33 28 20				jr z, .foundchar 
ca35 03					inc bc 
ca36 23					inc hl 
ca37					if DEBUG_FORTH_WORDS 
ca37						DMARK "FN3" 
ca37 f5				push af  
ca38 3a 4c ca			ld a, (.dmark)  
ca3b 32 65 ee			ld (debug_mark),a  
ca3e 3a 4d ca			ld a, (.dmark+1)  
ca41 32 66 ee			ld (debug_mark+1),a  
ca44 3a 4e ca			ld a, (.dmark+2)  
ca47 32 67 ee			ld (debug_mark+2),a  
ca4a 18 03			jr .pastdmark  
ca4c ..			.dmark: db "FN3"  
ca4f f1			.pastdmark: pop af  
ca50			endm  
# End of macro DMARK
ca50						CALLMONITOR 
ca50 cd 6f ee			call debug_vector  
ca53				endm  
# End of macro CALLMONITOR
ca53					endif 
ca53 18 d8				jr .findchar 
ca55			 
ca55			 
ca55 c5			.foundchar:	push bc 
ca56 e1					pop hl 
ca57 18 03				jr .findexit 
ca59			 
ca59			 
ca59							 
ca59			 
ca59			.finddone:     ; got to end of string with no find 
ca59 21 00 00				ld hl, 0 
ca5c			.findexit: 
ca5c			 
ca5c					if DEBUG_FORTH_WORDS 
ca5c						DMARK "FNd" 
ca5c f5				push af  
ca5d 3a 71 ca			ld a, (.dmark)  
ca60 32 65 ee			ld (debug_mark),a  
ca63 3a 72 ca			ld a, (.dmark+1)  
ca66 32 66 ee			ld (debug_mark+1),a  
ca69 3a 73 ca			ld a, (.dmark+2)  
ca6c 32 67 ee			ld (debug_mark+2),a  
ca6f 18 03			jr .pastdmark  
ca71 ..			.dmark: db "FNd"  
ca74 f1			.pastdmark: pop af  
ca75			endm  
# End of macro DMARK
ca75						CALLMONITOR 
ca75 cd 6f ee			call debug_vector  
ca78				endm  
# End of macro CALLMONITOR
ca78					endif 
ca78 cd 85 9a			call forth_push_numhl 
ca7b			 
ca7b				       NEXTW 
ca7b c3 75 9e			jp macro_next 
ca7e				endm 
# End of macro NEXTW
ca7e			 
ca7e			.LEN: 
ca7e				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
ca7e 4c				db WORD_SYS_CORE+56             
ca7f e8 ca			dw .ASC            
ca81 06				db 5 + 1 
ca82 .. 00			db "COUNT",0              
ca88				endm 
# End of macro CWHEAD
ca88			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
ca88			 
ca88					if DEBUG_FORTH_WORDS_KEY 
ca88						DMARK "CNT" 
ca88 f5				push af  
ca89 3a 9d ca			ld a, (.dmark)  
ca8c 32 65 ee			ld (debug_mark),a  
ca8f 3a 9e ca			ld a, (.dmark+1)  
ca92 32 66 ee			ld (debug_mark+1),a  
ca95 3a 9f ca			ld a, (.dmark+2)  
ca98 32 67 ee			ld (debug_mark+2),a  
ca9b 18 03			jr .pastdmark  
ca9d ..			.dmark: db "CNT"  
caa0 f1			.pastdmark: pop af  
caa1			endm  
# End of macro DMARK
caa1						CALLMONITOR 
caa1 cd 6f ee			call debug_vector  
caa4				endm  
# End of macro CALLMONITOR
caa4					endif 
caa4			; TODO check string type 
caa4					FORTH_DSP_VALUE 
caa4 cd 73 9c			call macro_forth_dsp_value 
caa7				endm 
# End of macro FORTH_DSP_VALUE
caa7			 
caa7			 
caa7					if DEBUG_FORTH_WORDS 
caa7						DMARK "CN?" 
caa7 f5				push af  
caa8 3a bc ca			ld a, (.dmark)  
caab 32 65 ee			ld (debug_mark),a  
caae 3a bd ca			ld a, (.dmark+1)  
cab1 32 66 ee			ld (debug_mark+1),a  
cab4 3a be ca			ld a, (.dmark+2)  
cab7 32 67 ee			ld (debug_mark+2),a  
caba 18 03			jr .pastdmark  
cabc ..			.dmark: db "CN?"  
cabf f1			.pastdmark: pop af  
cac0			endm  
# End of macro DMARK
cac0						CALLMONITOR 
cac0 cd 6f ee			call debug_vector  
cac3				endm  
# End of macro CALLMONITOR
cac3					endif 
cac3 cd 50 90				call strlenz 
cac6					if DEBUG_FORTH_WORDS 
cac6						DMARK "CNl" 
cac6 f5				push af  
cac7 3a db ca			ld a, (.dmark)  
caca 32 65 ee			ld (debug_mark),a  
cacd 3a dc ca			ld a, (.dmark+1)  
cad0 32 66 ee			ld (debug_mark+1),a  
cad3 3a dd ca			ld a, (.dmark+2)  
cad6 32 67 ee			ld (debug_mark+2),a  
cad9 18 03			jr .pastdmark  
cadb ..			.dmark: db "CNl"  
cade f1			.pastdmark: pop af  
cadf			endm  
# End of macro DMARK
cadf						CALLMONITOR 
cadf cd 6f ee			call debug_vector  
cae2				endm  
# End of macro CALLMONITOR
cae2					endif 
cae2			 
cae2 cd 85 9a				call forth_push_numhl 
cae5			 
cae5			 
cae5			 
cae5				       NEXTW 
cae5 c3 75 9e			jp macro_next 
cae8				endm 
# End of macro NEXTW
cae8			.ASC: 
cae8				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
cae8 4d				db WORD_SYS_CORE+57             
cae9 56 cb			dw .CHR            
caeb 04				db 3 + 1 
caec .. 00			db "ASC",0              
caf0				endm 
# End of macro CWHEAD
caf0			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
caf0					if DEBUG_FORTH_WORDS_KEY 
caf0						DMARK "ASC" 
caf0 f5				push af  
caf1 3a 05 cb			ld a, (.dmark)  
caf4 32 65 ee			ld (debug_mark),a  
caf7 3a 06 cb			ld a, (.dmark+1)  
cafa 32 66 ee			ld (debug_mark+1),a  
cafd 3a 07 cb			ld a, (.dmark+2)  
cb00 32 67 ee			ld (debug_mark+2),a  
cb03 18 03			jr .pastdmark  
cb05 ..			.dmark: db "ASC"  
cb08 f1			.pastdmark: pop af  
cb09			endm  
# End of macro DMARK
cb09						CALLMONITOR 
cb09 cd 6f ee			call debug_vector  
cb0c				endm  
# End of macro CALLMONITOR
cb0c					endif 
cb0c					FORTH_DSP_VALUE 
cb0c cd 73 9c			call macro_forth_dsp_value 
cb0f				endm 
# End of macro FORTH_DSP_VALUE
cb0f					;v5 FORTH_DSP_VALUE 
cb0f			;		inc hl      ; now at start of numeric as string 
cb0f			 
cb0f e5					push hl 
cb10			 
cb10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb10 cd 42 9d			call macro_forth_dsp_pop 
cb13				endm 
# End of macro FORTH_DSP_POP
cb13			 
cb13 e1					pop hl 
cb14			 
cb14					if DEBUG_FORTH_WORDS 
cb14						DMARK "AS1" 
cb14 f5				push af  
cb15 3a 29 cb			ld a, (.dmark)  
cb18 32 65 ee			ld (debug_mark),a  
cb1b 3a 2a cb			ld a, (.dmark+1)  
cb1e 32 66 ee			ld (debug_mark+1),a  
cb21 3a 2b cb			ld a, (.dmark+2)  
cb24 32 67 ee			ld (debug_mark+2),a  
cb27 18 03			jr .pastdmark  
cb29 ..			.dmark: db "AS1"  
cb2c f1			.pastdmark: pop af  
cb2d			endm  
# End of macro DMARK
cb2d						CALLMONITOR 
cb2d cd 6f ee			call debug_vector  
cb30				endm  
# End of macro CALLMONITOR
cb30					endif 
cb30					; push the content of a onto the stack as a value 
cb30			 
cb30 7e					ld a,(hl)   ; get char 
cb31 26 00				ld h,0 
cb33 6f					ld l,a 
cb34					if DEBUG_FORTH_WORDS 
cb34						DMARK "AS2" 
cb34 f5				push af  
cb35 3a 49 cb			ld a, (.dmark)  
cb38 32 65 ee			ld (debug_mark),a  
cb3b 3a 4a cb			ld a, (.dmark+1)  
cb3e 32 66 ee			ld (debug_mark+1),a  
cb41 3a 4b cb			ld a, (.dmark+2)  
cb44 32 67 ee			ld (debug_mark+2),a  
cb47 18 03			jr .pastdmark  
cb49 ..			.dmark: db "AS2"  
cb4c f1			.pastdmark: pop af  
cb4d			endm  
# End of macro DMARK
cb4d						CALLMONITOR 
cb4d cd 6f ee			call debug_vector  
cb50				endm  
# End of macro CALLMONITOR
cb50					endif 
cb50 cd 85 9a				call forth_push_numhl 
cb53			 
cb53				       NEXTW 
cb53 c3 75 9e			jp macro_next 
cb56				endm 
# End of macro NEXTW
cb56			 
cb56			.CHR: 
cb56				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
cb56 4d				db WORD_SYS_CORE+57             
cb57 92 cb			dw .ENDSTR            
cb59 04				db 3 + 1 
cb5a .. 00			db "CHR",0              
cb5e				endm 
# End of macro CWHEAD
cb5e			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
cb5e					if DEBUG_FORTH_WORDS_KEY 
cb5e						DMARK "CHR" 
cb5e f5				push af  
cb5f 3a 73 cb			ld a, (.dmark)  
cb62 32 65 ee			ld (debug_mark),a  
cb65 3a 74 cb			ld a, (.dmark+1)  
cb68 32 66 ee			ld (debug_mark+1),a  
cb6b 3a 75 cb			ld a, (.dmark+2)  
cb6e 32 67 ee			ld (debug_mark+2),a  
cb71 18 03			jr .pastdmark  
cb73 ..			.dmark: db "CHR"  
cb76 f1			.pastdmark: pop af  
cb77			endm  
# End of macro DMARK
cb77						CALLMONITOR 
cb77 cd 6f ee			call debug_vector  
cb7a				endm  
# End of macro CALLMONITOR
cb7a					endif 
cb7a					FORTH_DSP_VALUEHL 
cb7a cd 8a 9c			call macro_dsp_valuehl 
cb7d				endm 
# End of macro FORTH_DSP_VALUEHL
cb7d			 
cb7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb7d cd 42 9d			call macro_forth_dsp_pop 
cb80				endm 
# End of macro FORTH_DSP_POP
cb80			 
cb80					; save asci byte as a zero term string and push string 
cb80			 
cb80 7d					ld a,l 
cb81 32 bb e2				ld (scratch), a 
cb84			 
cb84 3e 00				ld a, 0 
cb86 32 bc e2				ld (scratch+1), a 
cb89			 
cb89 21 bb e2				ld hl, scratch 
cb8c cd f3 9a				call forth_push_str 
cb8f			 
cb8f			 
cb8f				       NEXTW 
cb8f c3 75 9e			jp macro_next 
cb92				endm 
# End of macro NEXTW
cb92			 
cb92			 
cb92			 
cb92			 
cb92			.ENDSTR: 
cb92			; eof 
cb92			 
# End of file forth_words_str.asm
cb92			include "forth_words_key.asm" 
cb92			 
cb92			; | ## Keyboard Words 
cb92			 
cb92			.KEY: 
cb92				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
cb92 3e				db WORD_SYS_CORE+42             
cb93 c2 cb			dw .KEYDB            
cb95 04				db 3 + 1 
cb96 .. 00			db "KEY",0              
cb9a				endm 
# End of macro CWHEAD
cb9a			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
cb9a			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cb9a			; | | Can use something like this to process: 
cb9a			; | | > repeat active . key ?dup if emit then #1 until  
cb9a			 
cb9a					if DEBUG_FORTH_WORDS_KEY 
cb9a						DMARK "KEY" 
cb9a f5				push af  
cb9b 3a af cb			ld a, (.dmark)  
cb9e 32 65 ee			ld (debug_mark),a  
cba1 3a b0 cb			ld a, (.dmark+1)  
cba4 32 66 ee			ld (debug_mark+1),a  
cba7 3a b1 cb			ld a, (.dmark+2)  
cbaa 32 67 ee			ld (debug_mark+2),a  
cbad 18 03			jr .pastdmark  
cbaf ..			.dmark: db "KEY"  
cbb2 f1			.pastdmark: pop af  
cbb3			endm  
# End of macro DMARK
cbb3						CALLMONITOR 
cbb3 cd 6f ee			call debug_vector  
cbb6				endm  
# End of macro CALLMONITOR
cbb6					endif 
cbb6			; TODO currently waits 
cbb6 cd b0 e2				call cinndb 
cbb9					;call cin_wait 
cbb9 6f					ld l, a 
cbba 26 00				ld h, 0 
cbbc cd 85 9a				call forth_push_numhl 
cbbf					NEXTW 
cbbf c3 75 9e			jp macro_next 
cbc2				endm 
# End of macro NEXTW
cbc2			.KEYDB: 
cbc2				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
cbc2 3e				db WORD_SYS_CORE+42             
cbc3 f4 cb			dw .WAITK            
cbc5 06				db 5 + 1 
cbc6 .. 00			db "KEYDB",0              
cbcc				endm 
# End of macro CWHEAD
cbcc			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
cbcc			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cbcc			; | | Can use something like this to process: 
cbcc			; | | > repeat active . key ?dup if emit then #1 until  
cbcc			 
cbcc					if DEBUG_FORTH_WORDS_KEY 
cbcc						DMARK "KEB" 
cbcc f5				push af  
cbcd 3a e1 cb			ld a, (.dmark)  
cbd0 32 65 ee			ld (debug_mark),a  
cbd3 3a e2 cb			ld a, (.dmark+1)  
cbd6 32 66 ee			ld (debug_mark+1),a  
cbd9 3a e3 cb			ld a, (.dmark+2)  
cbdc 32 67 ee			ld (debug_mark+2),a  
cbdf 18 03			jr .pastdmark  
cbe1 ..			.dmark: db "KEB"  
cbe4 f1			.pastdmark: pop af  
cbe5			endm  
# End of macro DMARK
cbe5						CALLMONITOR 
cbe5 cd 6f ee			call debug_vector  
cbe8				endm  
# End of macro CALLMONITOR
cbe8					endif 
cbe8			; TODO currently waits 
cbe8 cd b0 e2				call cin 
cbeb					;call cin_wait 
cbeb 6f					ld l, a 
cbec 26 00				ld h, 0 
cbee cd 85 9a				call forth_push_numhl 
cbf1					NEXTW 
cbf1 c3 75 9e			jp macro_next 
cbf4				endm 
# End of macro NEXTW
cbf4			.WAITK: 
cbf4				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
cbf4 3f				db WORD_SYS_CORE+43             
cbf5 26 cc			dw .ACCEPT            
cbf7 06				db 5 + 1 
cbf8 .. 00			db "WAITK",0              
cbfe				endm 
# End of macro CWHEAD
cbfe			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
cbfe					if DEBUG_FORTH_WORDS_KEY 
cbfe						DMARK "WAI" 
cbfe f5				push af  
cbff 3a 13 cc			ld a, (.dmark)  
cc02 32 65 ee			ld (debug_mark),a  
cc05 3a 14 cc			ld a, (.dmark+1)  
cc08 32 66 ee			ld (debug_mark+1),a  
cc0b 3a 15 cc			ld a, (.dmark+2)  
cc0e 32 67 ee			ld (debug_mark+2),a  
cc11 18 03			jr .pastdmark  
cc13 ..			.dmark: db "WAI"  
cc16 f1			.pastdmark: pop af  
cc17			endm  
# End of macro DMARK
cc17						CALLMONITOR 
cc17 cd 6f ee			call debug_vector  
cc1a				endm  
# End of macro CALLMONITOR
cc1a					endif 
cc1a cd aa e2				call cin_wait 
cc1d 6f					ld l, a 
cc1e 26 00				ld h, 0 
cc20 cd 85 9a				call forth_push_numhl 
cc23					NEXTW 
cc23 c3 75 9e			jp macro_next 
cc26				endm 
# End of macro NEXTW
cc26			.ACCEPT: 
cc26				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
cc26 40				db WORD_SYS_CORE+44             
cc27 84 cc			dw .EDIT            
cc29 07				db 6 + 1 
cc2a .. 00			db "ACCEPT",0              
cc31				endm 
# End of macro CWHEAD
cc31			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
cc31					; TODO crashes on push 
cc31					if DEBUG_FORTH_WORDS_KEY 
cc31						DMARK "ACC" 
cc31 f5				push af  
cc32 3a 46 cc			ld a, (.dmark)  
cc35 32 65 ee			ld (debug_mark),a  
cc38 3a 47 cc			ld a, (.dmark+1)  
cc3b 32 66 ee			ld (debug_mark+1),a  
cc3e 3a 48 cc			ld a, (.dmark+2)  
cc41 32 67 ee			ld (debug_mark+2),a  
cc44 18 03			jr .pastdmark  
cc46 ..			.dmark: db "ACC"  
cc49 f1			.pastdmark: pop af  
cc4a			endm  
# End of macro DMARK
cc4a						CALLMONITOR 
cc4a cd 6f ee			call debug_vector  
cc4d				endm  
# End of macro CALLMONITOR
cc4d					endif 
cc4d 21 b9 e4				ld hl, os_input 
cc50 3e 00				ld a, 0 
cc52 77					ld (hl),a 
cc53 3a 58 ea				ld a,(f_cursor_ptr) 
cc56 16 64				ld d, 100 
cc58 0e 00				ld c, 0 
cc5a 1e 28				ld e, 40 
cc5c cd 17 8d				call input_str 
cc5f					; TODO perhaps do a type check and wrap in quotes if not a number 
cc5f 21 b9 e4				ld hl, os_input 
cc62					if DEBUG_FORTH_WORDS 
cc62						DMARK "AC1" 
cc62 f5				push af  
cc63 3a 77 cc			ld a, (.dmark)  
cc66 32 65 ee			ld (debug_mark),a  
cc69 3a 78 cc			ld a, (.dmark+1)  
cc6c 32 66 ee			ld (debug_mark+1),a  
cc6f 3a 79 cc			ld a, (.dmark+2)  
cc72 32 67 ee			ld (debug_mark+2),a  
cc75 18 03			jr .pastdmark  
cc77 ..			.dmark: db "AC1"  
cc7a f1			.pastdmark: pop af  
cc7b			endm  
# End of macro DMARK
cc7b						CALLMONITOR 
cc7b cd 6f ee			call debug_vector  
cc7e				endm  
# End of macro CALLMONITOR
cc7e					endif 
cc7e cd f3 9a				call forth_push_str 
cc81					NEXTW 
cc81 c3 75 9e			jp macro_next 
cc84				endm 
# End of macro NEXTW
cc84			 
cc84			.EDIT: 
cc84				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
cc84 40				db WORD_SYS_CORE+44             
cc85 26 cd			dw .DEDIT            
cc87 05				db 4 + 1 
cc88 .. 00			db "EDIT",0              
cc8d				endm 
# End of macro CWHEAD
cc8d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
cc8d			 
cc8d					; TODO does not copy from stack 
cc8d					if DEBUG_FORTH_WORDS_KEY 
cc8d						DMARK "EDT" 
cc8d f5				push af  
cc8e 3a a2 cc			ld a, (.dmark)  
cc91 32 65 ee			ld (debug_mark),a  
cc94 3a a3 cc			ld a, (.dmark+1)  
cc97 32 66 ee			ld (debug_mark+1),a  
cc9a 3a a4 cc			ld a, (.dmark+2)  
cc9d 32 67 ee			ld (debug_mark+2),a  
cca0 18 03			jr .pastdmark  
cca2 ..			.dmark: db "EDT"  
cca5 f1			.pastdmark: pop af  
cca6			endm  
# End of macro DMARK
cca6						CALLMONITOR 
cca6 cd 6f ee			call debug_vector  
cca9				endm  
# End of macro CALLMONITOR
cca9					endif 
cca9			 
cca9					;FORTH_DSP 
cca9					FORTH_DSP_VALUEHL 
cca9 cd 8a 9c			call macro_dsp_valuehl 
ccac				endm 
# End of macro FORTH_DSP_VALUEHL
ccac			;		inc hl    ; TODO do type check 
ccac			 
ccac			;		call get_word_hl 
ccac e5					push hl 
ccad					if DEBUG_FORTH_WORDS 
ccad						DMARK "EDp" 
ccad f5				push af  
ccae 3a c2 cc			ld a, (.dmark)  
ccb1 32 65 ee			ld (debug_mark),a  
ccb4 3a c3 cc			ld a, (.dmark+1)  
ccb7 32 66 ee			ld (debug_mark+1),a  
ccba 3a c4 cc			ld a, (.dmark+2)  
ccbd 32 67 ee			ld (debug_mark+2),a  
ccc0 18 03			jr .pastdmark  
ccc2 ..			.dmark: db "EDp"  
ccc5 f1			.pastdmark: pop af  
ccc6			endm  
# End of macro DMARK
ccc6						CALLMONITOR 
ccc6 cd 6f ee			call debug_vector  
ccc9				endm  
# End of macro CALLMONITOR
ccc9					endif 
ccc9				;	ld a, 0 
ccc9 cd 50 90				call strlenz 
cccc 23					inc hl 
cccd			 
cccd 06 00				ld b, 0 
cccf 4d					ld c, l 
ccd0			 
ccd0 e1					pop hl 
ccd1 11 b9 e4				ld de, os_input 
ccd4					if DEBUG_FORTH_WORDS_KEY 
ccd4						DMARK "EDc" 
ccd4 f5				push af  
ccd5 3a e9 cc			ld a, (.dmark)  
ccd8 32 65 ee			ld (debug_mark),a  
ccdb 3a ea cc			ld a, (.dmark+1)  
ccde 32 66 ee			ld (debug_mark+1),a  
cce1 3a eb cc			ld a, (.dmark+2)  
cce4 32 67 ee			ld (debug_mark+2),a  
cce7 18 03			jr .pastdmark  
cce9 ..			.dmark: db "EDc"  
ccec f1			.pastdmark: pop af  
cced			endm  
# End of macro DMARK
cced						CALLMONITOR 
cced cd 6f ee			call debug_vector  
ccf0				endm  
# End of macro CALLMONITOR
ccf0					endif 
ccf0 ed b0				ldir 
ccf2			 
ccf2			 
ccf2 21 b9 e4				ld hl, os_input 
ccf5					;ld a, 0 
ccf5					;ld (hl),a 
ccf5 3a 58 ea				ld a,(f_cursor_ptr) 
ccf8 16 64				ld d, 100 
ccfa 0e 00				ld c, 0 
ccfc 1e 28				ld e, 40 
ccfe cd 17 8d				call input_str 
cd01					; TODO perhaps do a type check and wrap in quotes if not a number 
cd01 21 b9 e4				ld hl, os_input 
cd04					if DEBUG_FORTH_WORDS 
cd04						DMARK "ED1" 
cd04 f5				push af  
cd05 3a 19 cd			ld a, (.dmark)  
cd08 32 65 ee			ld (debug_mark),a  
cd0b 3a 1a cd			ld a, (.dmark+1)  
cd0e 32 66 ee			ld (debug_mark+1),a  
cd11 3a 1b cd			ld a, (.dmark+2)  
cd14 32 67 ee			ld (debug_mark+2),a  
cd17 18 03			jr .pastdmark  
cd19 ..			.dmark: db "ED1"  
cd1c f1			.pastdmark: pop af  
cd1d			endm  
# End of macro DMARK
cd1d						CALLMONITOR 
cd1d cd 6f ee			call debug_vector  
cd20				endm  
# End of macro CALLMONITOR
cd20					endif 
cd20 cd f3 9a				call forth_push_str 
cd23					NEXTW 
cd23 c3 75 9e			jp macro_next 
cd26				endm 
# End of macro NEXTW
cd26			 
cd26			.DEDIT: 
cd26				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
cd26 40				db WORD_SYS_CORE+44             
cd27 88 cd			dw .ENDKEY            
cd29 06				db 5 + 1 
cd2a .. 00			db "DEDIT",0              
cd30				endm 
# End of macro CWHEAD
cd30			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
cd30			 
cd30					; TODO does not copy from stack 
cd30					if DEBUG_FORTH_WORDS_KEY 
cd30						DMARK "DED" 
cd30 f5				push af  
cd31 3a 45 cd			ld a, (.dmark)  
cd34 32 65 ee			ld (debug_mark),a  
cd37 3a 46 cd			ld a, (.dmark+1)  
cd3a 32 66 ee			ld (debug_mark+1),a  
cd3d 3a 47 cd			ld a, (.dmark+2)  
cd40 32 67 ee			ld (debug_mark+2),a  
cd43 18 03			jr .pastdmark  
cd45 ..			.dmark: db "DED"  
cd48 f1			.pastdmark: pop af  
cd49			endm  
# End of macro DMARK
cd49						CALLMONITOR 
cd49 cd 6f ee			call debug_vector  
cd4c				endm  
# End of macro CALLMONITOR
cd4c					endif 
cd4c			 
cd4c					;FORTH_DSP 
cd4c					FORTH_DSP_VALUEHL 
cd4c cd 8a 9c			call macro_dsp_valuehl 
cd4f				endm 
# End of macro FORTH_DSP_VALUEHL
cd4f			;		inc hl    ; TODO do type check 
cd4f			 
cd4f			;		call get_word_hl 
cd4f e5					push hl 
cd50 e5					push hl 
cd51					FORTH_DSP_POP 
cd51 cd 42 9d			call macro_forth_dsp_pop 
cd54				endm 
# End of macro FORTH_DSP_POP
cd54 e1					pop hl 
cd55					if DEBUG_FORTH_WORDS 
cd55						DMARK "EDp" 
cd55 f5				push af  
cd56 3a 6a cd			ld a, (.dmark)  
cd59 32 65 ee			ld (debug_mark),a  
cd5c 3a 6b cd			ld a, (.dmark+1)  
cd5f 32 66 ee			ld (debug_mark+1),a  
cd62 3a 6c cd			ld a, (.dmark+2)  
cd65 32 67 ee			ld (debug_mark+2),a  
cd68 18 03			jr .pastdmark  
cd6a ..			.dmark: db "EDp"  
cd6d f1			.pastdmark: pop af  
cd6e			endm  
# End of macro DMARK
cd6e						CALLMONITOR 
cd6e cd 6f ee			call debug_vector  
cd71				endm  
# End of macro CALLMONITOR
cd71					endif 
cd71				;	ld a, 0 
cd71 cd 50 90				call strlenz 
cd74 23					inc hl 
cd75			 
cd75 06 00				ld b, 0 
cd77 4d					ld c, l 
cd78			 
cd78 e1					pop hl 
cd79			 
cd79					;ld a, 0 
cd79					;ld (hl),a 
cd79 3a 58 ea				ld a,(f_cursor_ptr) 
cd7c 16 64				ld d, 100 
cd7e 0e 00				ld c, 0 
cd80 1e 28				ld e, 40 
cd82 cd 17 8d				call input_str 
cd85					; TODO perhaps do a type check and wrap in quotes if not a number 
cd85					NEXTW 
cd85 c3 75 9e			jp macro_next 
cd88				endm 
# End of macro NEXTW
cd88			 
cd88			 
cd88			.ENDKEY: 
cd88			; eof 
cd88			 
# End of file forth_words_key.asm
cd88			include "forth_words_const.asm" 
cd88			 
cd88			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
cd88			 
cd88			 
cd88			.SPITIME: 
cd88				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
cd88 77				db WORD_SYS_CORE+99             
cd89 9d cd			dw .VA            
cd8b 08				db 7 + 1 
cd8c .. 00			db "SPITIME",0              
cd94				endm 
# End of macro CWHEAD
cd94			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
cd94			; 
cd94			; | | If using BANK devices then leave as is. 
cd94			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
cd94			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
cd94			 
cd94 21 5e ea				ld hl, spi_clktime  
cd97 cd 85 9a				call forth_push_numhl 
cd9a			 
cd9a					NEXTW 
cd9a c3 75 9e			jp macro_next 
cd9d				endm 
# End of macro NEXTW
cd9d			 
cd9d			 
cd9d			.VA: 
cd9d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
cd9d 77				db WORD_SYS_CORE+99             
cd9e ad cd			dw .SYMBOL            
cda0 03				db 2 + 1 
cda1 .. 00			db "VA",0              
cda4				endm 
# End of macro CWHEAD
cda4			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
cda4 21 22 ea				ld hl, cli_var_array 
cda7 cd 85 9a				call forth_push_numhl 
cdaa			 
cdaa					NEXTW 
cdaa c3 75 9e			jp macro_next 
cdad				endm 
# End of macro NEXTW
cdad			 
cdad			.SYMBOL: 
cdad				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
cdad 77				db WORD_SYS_CORE+99             
cdae b7 ce			dw .ENDCONST            
cdb0 07				db 6 + 1 
cdb1 .. 00			db "SYMBOL",0              
cdb8				endm 
# End of macro CWHEAD
cdb8			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
cdb8			; | 
cdb8			; | | The value is the number reference and the final address is pushed to stack 
cdb8			 
cdb8			; | | ``` 
cdb8			; | | dw sym_table 
cdb8			; | | dw nmi_vector 
cdb8			; | | dw cli_autodisplay 
cdb8			; | | dw cli_data_sp 
cdb8			; | | dw cli_data_stack 
cdb8			; | | dw cli_loop_sp 
cdb8			; | | dw cli_loop_stack 
cdb8			; | | dw cli_var_array 
cdb8			; | | dw cursor_col 
cdb8			; | | dw cursor_ptr 
cdb8			; | | ; 10 
cdb8			; | | dw cursor_row 
cdb8			; | | dw debug_mark 
cdb8			; | | dw display_fb0 
cdb8			; | | dw display_fb1 
cdb8			; | | dw display_fb2 
cdb8			; | | dw display_fb3 
cdb8			; | | dw display_fb_active 
cdb8			; | | dw execscratch 
cdb8			; | | dw f_cursor_ptr 
cdb8			; | | dw hardware_word 
cdb8			; | | ;20 
cdb8			; | | dw input_at_cursor 
cdb8			; | | dw input_at_pos 
cdb8			; | | dw input_cur_flash 
cdb8			; | | dw input_cur_onoff 
cdb8			; | | dw input_cursor 
cdb8			; | | dw input_display_size 
cdb8			; | | dw input_len 
cdb8			; | | dw input_ptr 
cdb8			; | | dw input_size 
cdb8			; | | dw input_start 
cdb8			; | | ; 30 
cdb8			; | | dw input_str 
cdb8			; | | dw input_under_cursor 
cdb8			; | | dw os_cli_cmd 
cdb8			; | | dw os_cur_ptr 
cdb8			; | | dw os_current_i 
cdb8			; | | dw os_input 
cdb8			; | | dw os_last_cmd 
cdb8			; | | dw os_last_new_uword 
cdb8			; | | dw debug_vector 
cdb8			; | | dw os_view_hl 
cdb8			; | | ;40 
cdb8			; | | dw os_word_scratch 
cdb8			; | | dw portbctl 
cdb8			; | | dw portbdata 
cdb8			; | | dw spi_cartdev 
cdb8			; | | dw spi_cartdev2 
cdb8			; | | dw spi_clktime 
cdb8			; | | dw spi_device 
cdb8			; | | dw spi_device_id 
cdb8			; | | dw spi_portbyte 
cdb8			; | | dw stackstore 
cdb8			; | | ; 50 
cdb8			; | | if STORAGE_SE 
cdb8			; | | dw storage_actl 
cdb8			; | | dw storage_adata 
cdb8			; | | else 
cdb8			; | | dw 0 
cdb8			; | | dw 0 
cdb8			; | | endif 
cdb8			; | | dw storage_append 
cdb8			; | | if STORAGE_SE 
cdb8			; | | dw storage_bctl 
cdb8			; | | else 
cdb8			; | | dw 0 
cdb8			; | | endif 
cdb8			; | | dw store_bank_active 
cdb8			; | | dw store_filecache 
cdb8			; | | dw store_longread 
cdb8			; | | dw store_openaddr 
cdb8			; | | dw store_openext 
cdb8			; | | dw store_openmaxext 
cdb8			; | | ; 60 
cdb8			; | | dw store_page 
cdb8			; | | dw store_readbuf 
cdb8			; | | dw store_readcont 
cdb8			; | | dw store_readptr 
cdb8			; | | dw store_tmpext 
cdb8			; | | dw store_tmpid 
cdb8			; | | dw store_tmppageid 
cdb8			; | | dw malloc 
cdb8			; | | dw free 
cdb8			; | | dw cin 
cdb8			; | | ; 70 
cdb8			; | | dw cin_wait 
cdb8			; | | dw forth_push_numhl 
cdb8			; | | dw forth_push_str 
cdb8			; | | ``` 
cdb8			 
cdb8					if DEBUG_FORTH_WORDS_KEY 
cdb8						DMARK "SYM" 
cdb8 f5				push af  
cdb9 3a cd cd			ld a, (.dmark)  
cdbc 32 65 ee			ld (debug_mark),a  
cdbf 3a ce cd			ld a, (.dmark+1)  
cdc2 32 66 ee			ld (debug_mark+1),a  
cdc5 3a cf cd			ld a, (.dmark+2)  
cdc8 32 67 ee			ld (debug_mark+2),a  
cdcb 18 03			jr .pastdmark  
cdcd ..			.dmark: db "SYM"  
cdd0 f1			.pastdmark: pop af  
cdd1			endm  
# End of macro DMARK
cdd1						CALLMONITOR 
cdd1 cd 6f ee			call debug_vector  
cdd4				endm  
# End of macro CALLMONITOR
cdd4					endif 
cdd4			 
cdd4					FORTH_DSP_VALUEHL 
cdd4 cd 8a 9c			call macro_dsp_valuehl 
cdd7				endm 
# End of macro FORTH_DSP_VALUEHL
cdd7			 
cdd7 7d					ld a, l     
cdd8			 
cdd8			 
cdd8					if DEBUG_FORTH_WORDS 
cdd8						DMARK "SY1" 
cdd8 f5				push af  
cdd9 3a ed cd			ld a, (.dmark)  
cddc 32 65 ee			ld (debug_mark),a  
cddf 3a ee cd			ld a, (.dmark+1)  
cde2 32 66 ee			ld (debug_mark+1),a  
cde5 3a ef cd			ld a, (.dmark+2)  
cde8 32 67 ee			ld (debug_mark+2),a  
cdeb 18 03			jr .pastdmark  
cded ..			.dmark: db "SY1"  
cdf0 f1			.pastdmark: pop af  
cdf1			endm  
# End of macro DMARK
cdf1						CALLMONITOR 
cdf1 cd 6f ee			call debug_vector  
cdf4				endm  
# End of macro CALLMONITOR
cdf4					endif 
cdf4					 
cdf4 f5					push af	 
cdf5					FORTH_DSP_POP 
cdf5 cd 42 9d			call macro_forth_dsp_pop 
cdf8				endm 
# End of macro FORTH_DSP_POP
cdf8 f1					pop af 
cdf9			 
cdf9 cb 27				sla a  
cdfb				 
cdfb					 
cdfb					if DEBUG_FORTH_WORDS 
cdfb						DMARK "SY" 
cdfb f5				push af  
cdfc 3a 10 ce			ld a, (.dmark)  
cdff 32 65 ee			ld (debug_mark),a  
ce02 3a 11 ce			ld a, (.dmark+1)  
ce05 32 66 ee			ld (debug_mark+1),a  
ce08 3a 12 ce			ld a, (.dmark+2)  
ce0b 32 67 ee			ld (debug_mark+2),a  
ce0e 18 02			jr .pastdmark  
ce10 ..			.dmark: db "SY"  
ce12 f1			.pastdmark: pop af  
ce13			endm  
# End of macro DMARK
ce13						CALLMONITOR 
ce13 cd 6f ee			call debug_vector  
ce16				endm  
# End of macro CALLMONITOR
ce16					endif 
ce16			 
ce16 21 25 ce				ld hl, sym_table 
ce19 cd ea 8c				call addatohl 
ce1c cd f7 9d				call loadwordinhl 
ce1f cd 85 9a				call forth_push_numhl 
ce22			 
ce22			 
ce22				       NEXTW 
ce22 c3 75 9e			jp macro_next 
ce25				endm 
# End of macro NEXTW
ce25			 
ce25			sym_table: 
ce25			 
ce25			; 0 
ce25 25 ce		dw sym_table 
ce27 72 ee		dw nmi_vector 
ce29 36 ea		dw cli_autodisplay 
ce2b e8 e9		dw cli_data_sp 
ce2d 22 e8		dw cli_data_stack 
ce2f ea e9		dw cli_loop_sp 
ce31 24 e9		dw cli_loop_stack 
ce33 22 ea		dw cli_var_array 
ce35 bf eb		dw cursor_col 
ce37 bd eb		dw cursor_ptr 
ce39			; 10 
ce39 be eb		dw cursor_row 
ce3b 65 ee		dw debug_mark 
ce3d ab ed		dw display_fb0 
ce3f 0a ed		dw display_fb1 
ce41 c8 eb		dw display_fb2 
ce43 69 ec		dw display_fb3 
ce45 c6 eb		dw display_fb_active 
ce47 ba e3		dw execscratch 
ce49 58 ea		dw f_cursor_ptr 
ce4b 75 ee		dw hardware_word 
ce4d			;20 
ce4d 5c ee		dw input_at_cursor 
ce4f 5e ee		dw input_at_pos 
ce51 5a ee		dw input_cur_flash 
ce53 59 ee		dw input_cur_onoff 
ce55 4f ee		dw input_cursor 
ce57 5f ee		dw input_display_size 
ce59 54 ee		dw input_len 
ce5b 63 ee		dw input_ptr 
ce5d 60 ee		dw input_size 
ce5f 61 ee		dw input_start 
ce61			; 30 
ce61 17 8d		dw input_str 
ce63 5d ee		dw input_under_cursor 
ce65 e2 e5		dw os_cli_cmd 
ce67 de e5		dw os_cur_ptr 
ce69 e0 e5		dw os_current_i 
ce6b b9 e4		dw os_input 
ce6d e1 e6		dw os_last_cmd 
ce6f b8 e5		dw os_last_new_uword 
ce71 6f ee		dw debug_vector 
ce73 9d e2		dw os_view_hl 
ce75			;40 
ce75 c0 e5		dw os_word_scratch 
ce77 c3 00		dw portbctl 
ce79 c1 00		dw portbdata 
ce7b 5d ea		dw spi_cartdev 
ce7d 5c ea		dw spi_cartdev2 
ce7f 5e ea		dw spi_clktime 
ce81 5a ea		dw spi_device 
ce83 59 ea		dw spi_device_id 
ce85 5b ea		dw spi_portbyte 
ce87 a1 eb		dw stackstore 
ce89			; 50 
ce89			if STORAGE_SE 
ce89			dw storage_actl 
ce89			dw storage_adata 
ce89			else 
ce89 00 00		dw 0 
ce8b 00 00		dw 0 
ce8d			endif 
ce8d 77 88		dw storage_append 
ce8f			if STORAGE_SE 
ce8f			dw storage_bctl 
ce8f			else 
ce8f 00 00		dw 0 
ce91			endif 
ce91 8d eb		dw store_bank_active 
ce93 61 ea		dw store_filecache 
ce95 6f ea		dw store_longread 
ce97 65 ea		dw store_openaddr 
ce99 64 ea		dw store_openext 
ce9b 63 ea		dw store_openmaxext 
ce9d			; 60 
ce9d 74 ea		dw store_page 
ce9f 70 ea		dw store_readbuf 
cea1 67 ea		dw store_readcont 
cea3 72 ea		dw store_readptr 
cea5 67 ea		dw store_tmpext 
cea7 68 ea		dw store_tmpid 
cea9 5f ea		dw store_tmppageid 
ceab c5 90		dw malloc 
cead 8f 91		dw free 
ceaf b0 e2		dw cin 
ceb1			; 70 
ceb1 aa e2		dw cin_wait 
ceb3 85 9a		dw forth_push_numhl 
ceb5 f3 9a		dw forth_push_str 
ceb7			 
ceb7			 
ceb7			.ENDCONST: 
ceb7			 
ceb7			; eof 
ceb7			 
ceb7			 
# End of file forth_words_const.asm
ceb7			 
ceb7			if STORAGE_SE 
ceb7			   	include "forth_words_storage.asm" 
ceb7			endif 
ceb7				include "forth_words_device.asm" 
ceb7			; Device related words 
ceb7			 
ceb7			; | ## Device Words 
ceb7			 
ceb7			;if SOUND_ENABLE 
ceb7			;.NOTE: 
ceb7			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
ceb7			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
ceb7			;		if DEBUG_FORTH_WORDS_KEY 
ceb7			;			DMARK "NTE" 
ceb7			;			CALLMONITOR 
ceb7			;		endif 
ceb7			; 
ceb7			;	 
ceb7			; 
ceb7			;		NEXTW 
ceb7			;.AFTERSOUND: 
ceb7			;endif 
ceb7			 
ceb7			 
ceb7			USE_GPIO: equ 0 
ceb7			 
ceb7			if USE_GPIO 
ceb7			.GP1: 
ceb7				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
ceb7			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
ceb7					NEXTW 
ceb7			.GP2: 
ceb7				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
ceb7			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
ceb7			 
ceb7					NEXTW 
ceb7			 
ceb7			.GP3: 
ceb7				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
ceb7			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
ceb7			 
ceb7					NEXTW 
ceb7			 
ceb7			.GP4: 
ceb7				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
ceb7			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
ceb7			 
ceb7					NEXTW 
ceb7			.SIN: 
ceb7			 
ceb7			 
ceb7			endif 
ceb7			 
ceb7			 
ceb7				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
ceb7 33				db WORD_SYS_CORE+31             
ceb8 ec ce			dw .SOUT            
ceba 03				db 2 + 1 
cebb .. 00			db "IN",0              
cebe				endm 
# End of macro CWHEAD
cebe			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cebe					if DEBUG_FORTH_WORDS_KEY 
cebe						DMARK "IN." 
cebe f5				push af  
cebf 3a d3 ce			ld a, (.dmark)  
cec2 32 65 ee			ld (debug_mark),a  
cec5 3a d4 ce			ld a, (.dmark+1)  
cec8 32 66 ee			ld (debug_mark+1),a  
cecb 3a d5 ce			ld a, (.dmark+2)  
cece 32 67 ee			ld (debug_mark+2),a  
ced1 18 03			jr .pastdmark  
ced3 ..			.dmark: db "IN."  
ced6 f1			.pastdmark: pop af  
ced7			endm  
# End of macro DMARK
ced7						CALLMONITOR 
ced7 cd 6f ee			call debug_vector  
ceda				endm  
# End of macro CALLMONITOR
ceda					endif 
ceda					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ceda cd 8a 9c			call macro_dsp_valuehl 
cedd				endm 
# End of macro FORTH_DSP_VALUEHL
cedd			 
cedd e5					push hl 
cede			 
cede					; destroy value TOS 
cede			 
cede					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cede cd 42 9d			call macro_forth_dsp_pop 
cee1				endm 
# End of macro FORTH_DSP_POP
cee1			 
cee1					; one value on hl get other one back 
cee1			 
cee1 c1					pop bc 
cee2			 
cee2					; do the sub 
cee2			;		ex de, hl 
cee2			 
cee2 ed 68				in l,(c) 
cee4			 
cee4					; save it 
cee4			 
cee4 26 00				ld h,0 
cee6			 
cee6					; TODO push value back onto stack for another op etc 
cee6			 
cee6 cd 85 9a				call forth_push_numhl 
cee9					NEXTW 
cee9 c3 75 9e			jp macro_next 
ceec				endm 
# End of macro NEXTW
ceec			.SOUT: 
ceec				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
ceec 34				db WORD_SYS_CORE+32             
ceed 3f cf			dw .SPIO            
ceef 04				db 3 + 1 
cef0 .. 00			db "OUT",0              
cef4				endm 
# End of macro CWHEAD
cef4			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
cef4					if DEBUG_FORTH_WORDS_KEY 
cef4						DMARK "OUT" 
cef4 f5				push af  
cef5 3a 09 cf			ld a, (.dmark)  
cef8 32 65 ee			ld (debug_mark),a  
cefb 3a 0a cf			ld a, (.dmark+1)  
cefe 32 66 ee			ld (debug_mark+1),a  
cf01 3a 0b cf			ld a, (.dmark+2)  
cf04 32 67 ee			ld (debug_mark+2),a  
cf07 18 03			jr .pastdmark  
cf09 ..			.dmark: db "OUT"  
cf0c f1			.pastdmark: pop af  
cf0d			endm  
# End of macro DMARK
cf0d						CALLMONITOR 
cf0d cd 6f ee			call debug_vector  
cf10				endm  
# End of macro CALLMONITOR
cf10					endif 
cf10			 
cf10					; get port 
cf10			 
cf10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf10 cd 8a 9c			call macro_dsp_valuehl 
cf13				endm 
# End of macro FORTH_DSP_VALUEHL
cf13			 
cf13 e5					push hl 
cf14			 
cf14					; destroy value TOS 
cf14			 
cf14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf14 cd 42 9d			call macro_forth_dsp_pop 
cf17				endm 
# End of macro FORTH_DSP_POP
cf17			 
cf17					; get byte to send 
cf17			 
cf17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf17 cd 8a 9c			call macro_dsp_valuehl 
cf1a				endm 
# End of macro FORTH_DSP_VALUEHL
cf1a			 
cf1a			;		push hl 
cf1a			 
cf1a					; destroy value TOS 
cf1a			 
cf1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf1a cd 42 9d			call macro_forth_dsp_pop 
cf1d				endm 
# End of macro FORTH_DSP_POP
cf1d			 
cf1d					; one value on hl get other one back 
cf1d			 
cf1d			;		pop hl 
cf1d			 
cf1d c1					pop bc 
cf1e			 
cf1e					if DEBUG_FORTH_WORDS 
cf1e						DMARK "OUT" 
cf1e f5				push af  
cf1f 3a 33 cf			ld a, (.dmark)  
cf22 32 65 ee			ld (debug_mark),a  
cf25 3a 34 cf			ld a, (.dmark+1)  
cf28 32 66 ee			ld (debug_mark+1),a  
cf2b 3a 35 cf			ld a, (.dmark+2)  
cf2e 32 67 ee			ld (debug_mark+2),a  
cf31 18 03			jr .pastdmark  
cf33 ..			.dmark: db "OUT"  
cf36 f1			.pastdmark: pop af  
cf37			endm  
# End of macro DMARK
cf37						CALLMONITOR 
cf37 cd 6f ee			call debug_vector  
cf3a				endm  
# End of macro CALLMONITOR
cf3a					endif 
cf3a			 
cf3a ed 69				out (c), l 
cf3c			 
cf3c					NEXTW 
cf3c c3 75 9e			jp macro_next 
cf3f				endm 
# End of macro NEXTW
cf3f			 
cf3f			 
cf3f			.SPIO: 
cf3f			 
cf3f			if STORAGE_SE 
cf3f				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
cf3f			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
cf3f			 
cf3f					call spi_ce_low 
cf3f			    NEXTW 
cf3f			 
cf3f			.SPICEH: 
cf3f				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
cf3f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
cf3f			 
cf3f					call spi_ce_high 
cf3f			    NEXTW 
cf3f			 
cf3f			 
cf3f			.SPIOb: 
cf3f			 
cf3f				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
cf3f			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
cf3f			 
cf3f					if DEBUG_FORTH_WORDS_KEY 
cf3f						DMARK "SPo" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f					; get port 
cf3f			 
cf3f			 
cf3f					; get byte to send 
cf3f			 
cf3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf3f			 
cf3f			;		push hl    ; u1  
cf3f			 
cf3f					; destroy value TOS 
cf3f			 
cf3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf3f			 
cf3f					; one value on hl get other one back 
cf3f			 
cf3f			;		pop hl   ; u2 - addr 
cf3f			 
cf3f					; TODO Send SPI byte 
cf3f			 
cf3f			;		push hl 
cf3f			;		call spi_ce_low 
cf3f			;		pop hl 
cf3f					ld a, l 
cf3f					call spi_send_byte 
cf3f			;		call spi_ce_high 
cf3f			 
cf3f					NEXTW 
cf3f			 
cf3f			.SPII: 
cf3f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
cf3f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
cf3f					if DEBUG_FORTH_WORDS_KEY 
cf3f						DMARK "SPi" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					; TODO Get SPI byte 
cf3f			 
cf3f					call spi_read_byte 
cf3f			 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "Si2" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f					ld h, 0 
cf3f					ld l, a 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "Si3" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f					call forth_push_numhl 
cf3f			 
cf3f					NEXTW 
cf3f			 
cf3f			 
cf3f			 
cf3f			.SESEL: 
cf3f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
cf3f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
cf3f					if DEBUG_FORTH_WORDS_KEY 
cf3f						DMARK "BNK" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					ld a, 255 
cf3f					ld (spi_cartdev), a 
cf3f			 
cf3f					; get bank 
cf3f			 
cf3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf3f			 
cf3f			;		push hl 
cf3f			 
cf3f					; destroy value TOS 
cf3f			 
cf3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf3f			 
cf3f					; one value on hl get other one back 
cf3f			 
cf3f			;		pop hl 
cf3f			 
cf3f			 
cf3f					ld c, SPI_CE_HIGH 
cf3f					ld b, '0'    ; human readable bank number 
cf3f			 
cf3f					ld a, l 
cf3f			 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "BNK" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					; active low 
cf3f			 
cf3f					cp 0 
cf3f					jr z, .bset 
cf3f					cp 1 
cf3f					jr nz, .b2 
cf3f					res 0, c 
cf3f					ld b, '1'    ; human readable bank number 
cf3f			.b2:		cp 2 
cf3f					jr nz, .b3 
cf3f					res 1, c 
cf3f					ld b, '2'    ; human readable bank number 
cf3f			.b3:		cp 3 
cf3f					jr nz, .b4 
cf3f					res 2, c 
cf3f					ld b, '3'    ; human readable bank number 
cf3f			.b4:		cp 4 
cf3f					jr nz, .b5 
cf3f					res 3, c 
cf3f					ld b, '4'    ; human readable bank number 
cf3f			.b5:		cp 5 
cf3f					jr nz, .bset 
cf3f					res 4, c 
cf3f					ld b, '5'    ; human readable bank number 
cf3f			 
cf3f			.bset: 
cf3f					ld a, c 
cf3f					ld (spi_device),a 
cf3f					ld a, b 
cf3f					ld (spi_device_id),a 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "BN2" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					; set default SPI clk pulse time as disabled for BANK use 
cf3f			 
cf3f					ld a, 0 
cf3f					ld (spi_clktime), a 
cf3f			 
cf3f					NEXTW 
cf3f			 
cf3f			.CARTDEV: 
cf3f				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
cf3f			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
cf3f					if DEBUG_FORTH_WORDS_KEY 
cf3f						DMARK "CDV" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					; disable se storage bank selection 
cf3f			 
cf3f					ld a, SPI_CE_HIGH		; ce high 
cf3f					ld (spi_device), a 
cf3f			 
cf3f					; get bank 
cf3f			 
cf3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf3f			 
cf3f			;		push hl 
cf3f			 
cf3f					; destroy value TOS 
cf3f			 
cf3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf3f			 
cf3f					; one value on hl get other one back 
cf3f			 
cf3f			;		pop hl 
cf3f			 
cf3f					; active low 
cf3f			 
cf3f					ld c, 255 
cf3f			 
cf3f					ld a, l 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "CDV" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f					cp 0 
cf3f					jr z, .cset 
cf3f					cp 1 
cf3f					jr nz, .c2 
cf3f					res 0, c 
cf3f			.c2:		cp 2 
cf3f					jr nz, .c3 
cf3f					res 1, c 
cf3f			.c3:		cp 3 
cf3f					jr nz, .c4 
cf3f					res 2, c 
cf3f			.c4:		cp 4 
cf3f					jr nz, .c5 
cf3f					res 3, c 
cf3f			.c5:		cp 5 
cf3f					jr nz, .c6 
cf3f					res 4, c 
cf3f			.c6:		cp 6 
cf3f					jr nz, .c7 
cf3f					res 5, c 
cf3f			.c7:		cp 7 
cf3f					jr nz, .c8 
cf3f					res 6, c 
cf3f			.c8:		cp 8 
cf3f					jr nz, .cset 
cf3f					res 7, c 
cf3f			.cset:		ld a, c 
cf3f					ld (spi_cartdev),a 
cf3f			 
cf3f					if DEBUG_FORTH_WORDS 
cf3f						DMARK "CD2" 
cf3f						CALLMONITOR 
cf3f					endif 
cf3f			 
cf3f					; set default SPI clk pulse time as 10ms for CARTDEV use 
cf3f			 
cf3f					ld a, $0a 
cf3f					ld (spi_clktime), a 
cf3f					NEXTW 
cf3f			endif 
cf3f			 
cf3f			.ENDDEVICE: 
cf3f			; eof 
cf3f			 
# End of file forth_words_device.asm
cf3f			 
cf3f			; var handler 
cf3f			 
cf3f			 
cf3f			.VARS: 
cf3f				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
cf3f 77				db WORD_SYS_CORE+99             
cf40 f0 cf			dw .V0            
cf42 04				db 3 + 1 
cf43 .. 00			db "VAR",0              
cf47				endm 
# End of macro CWHEAD
cf47			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
cf47			;| 
cf47			;| The variable name should consist of a single letter. e.g. "a" 
cf47			;! If a full string is passed then only the first char is looked at 
cf47			;| Any other char could exceed bounds checks!  
cf47			 
cf47					if DEBUG_FORTH_WORDS_KEY 
cf47						DMARK "VAR" 
cf47 f5				push af  
cf48 3a 5c cf			ld a, (.dmark)  
cf4b 32 65 ee			ld (debug_mark),a  
cf4e 3a 5d cf			ld a, (.dmark+1)  
cf51 32 66 ee			ld (debug_mark+1),a  
cf54 3a 5e cf			ld a, (.dmark+2)  
cf57 32 67 ee			ld (debug_mark+2),a  
cf5a 18 03			jr .pastdmark  
cf5c ..			.dmark: db "VAR"  
cf5f f1			.pastdmark: pop af  
cf60			endm  
# End of macro DMARK
cf60						CALLMONITOR 
cf60 cd 6f ee			call debug_vector  
cf63				endm  
# End of macro CALLMONITOR
cf63					endif 
cf63			 
cf63					FORTH_DSP_VALUEHL 
cf63 cd 8a 9c			call macro_dsp_valuehl 
cf66				endm 
# End of macro FORTH_DSP_VALUEHL
cf66			 
cf66 7e					ld a, (hl)    ; get first char on of the string 
cf67			 
cf67			 
cf67					if DEBUG_FORTH_WORDS 
cf67						DMARK "VR1" 
cf67 f5				push af  
cf68 3a 7c cf			ld a, (.dmark)  
cf6b 32 65 ee			ld (debug_mark),a  
cf6e 3a 7d cf			ld a, (.dmark+1)  
cf71 32 66 ee			ld (debug_mark+1),a  
cf74 3a 7e cf			ld a, (.dmark+2)  
cf77 32 67 ee			ld (debug_mark+2),a  
cf7a 18 03			jr .pastdmark  
cf7c ..			.dmark: db "VR1"  
cf7f f1			.pastdmark: pop af  
cf80			endm  
# End of macro DMARK
cf80						CALLMONITOR 
cf80 cd 6f ee			call debug_vector  
cf83				endm  
# End of macro CALLMONITOR
cf83					endif 
cf83					 
cf83 f5					push af	 
cf84					FORTH_DSP_POP 
cf84 cd 42 9d			call macro_forth_dsp_pop 
cf87				endm 
# End of macro FORTH_DSP_POP
cf87 f1					pop af 
cf88			 
cf88					; convert to upper 
cf88			 
cf88 cd 5f 8f				call to_upper 
cf8b					if DEBUG_FORTH_WORDS 
cf8b						DMARK "Vaa" 
cf8b f5				push af  
cf8c 3a a0 cf			ld a, (.dmark)  
cf8f 32 65 ee			ld (debug_mark),a  
cf92 3a a1 cf			ld a, (.dmark+1)  
cf95 32 66 ee			ld (debug_mark+1),a  
cf98 3a a2 cf			ld a, (.dmark+2)  
cf9b 32 67 ee			ld (debug_mark+2),a  
cf9e 18 03			jr .pastdmark  
cfa0 ..			.dmark: db "Vaa"  
cfa3 f1			.pastdmark: pop af  
cfa4			endm  
# End of macro DMARK
cfa4						CALLMONITOR 
cfa4 cd 6f ee			call debug_vector  
cfa7				endm  
# End of macro CALLMONITOR
cfa7					endif 
cfa7 06 41				ld b, 'A' 
cfa9 90					sub b			; set offset 
cfaa					if DEBUG_FORTH_WORDS 
cfaa						DMARK "Vbb" 
cfaa f5				push af  
cfab 3a bf cf			ld a, (.dmark)  
cfae 32 65 ee			ld (debug_mark),a  
cfb1 3a c0 cf			ld a, (.dmark+1)  
cfb4 32 66 ee			ld (debug_mark+1),a  
cfb7 3a c1 cf			ld a, (.dmark+2)  
cfba 32 67 ee			ld (debug_mark+2),a  
cfbd 18 03			jr .pastdmark  
cfbf ..			.dmark: db "Vbb"  
cfc2 f1			.pastdmark: pop af  
cfc3			endm  
# End of macro DMARK
cfc3						CALLMONITOR 
cfc3 cd 6f ee			call debug_vector  
cfc6				endm  
# End of macro CALLMONITOR
cfc6					endif 
cfc6 cb 27				sla a  
cfc8				 
cfc8					 
cfc8					if DEBUG_FORTH_WORDS 
cfc8						DMARK "VR2" 
cfc8 f5				push af  
cfc9 3a dd cf			ld a, (.dmark)  
cfcc 32 65 ee			ld (debug_mark),a  
cfcf 3a de cf			ld a, (.dmark+1)  
cfd2 32 66 ee			ld (debug_mark+1),a  
cfd5 3a df cf			ld a, (.dmark+2)  
cfd8 32 67 ee			ld (debug_mark+2),a  
cfdb 18 03			jr .pastdmark  
cfdd ..			.dmark: db "VR2"  
cfe0 f1			.pastdmark: pop af  
cfe1			endm  
# End of macro DMARK
cfe1						CALLMONITOR 
cfe1 cd 6f ee			call debug_vector  
cfe4				endm  
# End of macro CALLMONITOR
cfe4					endif 
cfe4			 
cfe4 21 ee e9				ld hl, cli_var_array2 
cfe7 cd ea 8c				call addatohl 
cfea cd 85 9a				call forth_push_numhl 
cfed			 
cfed			 
cfed				       NEXTW 
cfed c3 75 9e			jp macro_next 
cff0				endm 
# End of macro NEXTW
cff0			.V0: 
cff0				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
cff0 78				db WORD_SYS_CORE+100             
cff1 08 d0			dw .V0Q            
cff3 04				db 3 + 1 
cff4 .. 00			db "V0!",0              
cff8				endm 
# End of macro CWHEAD
cff8			;| V0! ( u1 -- )  Store value to v0  | DONE 
cff8			 
cff8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cff8 cd 8a 9c			call macro_dsp_valuehl 
cffb				endm 
# End of macro FORTH_DSP_VALUEHL
cffb			 
cffb 11 22 ea				ld de, cli_var_array 
cffe			 
cffe eb					ex de, hl 
cfff 73					ld (hl), e 
d000 23					inc hl 
d001 72					ld (hl), d 
d002			 
d002					; destroy value TOS 
d002			 
d002					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d002 cd 42 9d			call macro_forth_dsp_pop 
d005				endm 
# End of macro FORTH_DSP_POP
d005			 
d005				       NEXTW 
d005 c3 75 9e			jp macro_next 
d008				endm 
# End of macro NEXTW
d008			.V0Q: 
d008				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
d008 79				db WORD_SYS_CORE+101             
d009 19 d0			dw .V1S            
d00b 04				db 3 + 1 
d00c .. 00			db "V0@",0              
d010				endm 
# End of macro CWHEAD
d010			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
d010 2a 22 ea				ld hl, (cli_var_array) 
d013 cd 85 9a				call forth_push_numhl 
d016			 
d016				       NEXTW 
d016 c3 75 9e			jp macro_next 
d019				endm 
# End of macro NEXTW
d019			.V1S: 
d019				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
d019 7a				db WORD_SYS_CORE+102             
d01a 31 d0			dw .V1Q            
d01c 04				db 3 + 1 
d01d .. 00			db "V1!",0              
d021				endm 
# End of macro CWHEAD
d021			;| V1! ( u1 -- )  Store value to v1 | DONE 
d021					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d021 cd 8a 9c			call macro_dsp_valuehl 
d024				endm 
# End of macro FORTH_DSP_VALUEHL
d024			 
d024 11 24 ea				ld de, cli_var_array+2 
d027				 
d027 eb					ex de, hl 
d028 73					ld (hl), e 
d029 23					inc hl 
d02a 72					ld (hl), d 
d02b			 
d02b					; destroy value TOS 
d02b			 
d02b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d02b cd 42 9d			call macro_forth_dsp_pop 
d02e				endm 
# End of macro FORTH_DSP_POP
d02e				       NEXTW 
d02e c3 75 9e			jp macro_next 
d031				endm 
# End of macro NEXTW
d031			.V1Q: 
d031				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
d031 7b				db WORD_SYS_CORE+103             
d032 42 d0			dw .V2S            
d034 04				db 3 + 1 
d035 .. 00			db "V1@",0              
d039				endm 
# End of macro CWHEAD
d039			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
d039 2a 24 ea				ld hl, (cli_var_array+2) 
d03c cd 85 9a				call forth_push_numhl 
d03f				       NEXTW 
d03f c3 75 9e			jp macro_next 
d042				endm 
# End of macro NEXTW
d042			.V2S: 
d042				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
d042 7c				db WORD_SYS_CORE+104             
d043 5a d0			dw .V2Q            
d045 04				db 3 + 1 
d046 .. 00			db "V2!",0              
d04a				endm 
# End of macro CWHEAD
d04a			;| V2! ( u1 -- )  Store value to v2 | DONE 
d04a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d04a cd 8a 9c			call macro_dsp_valuehl 
d04d				endm 
# End of macro FORTH_DSP_VALUEHL
d04d			 
d04d 11 26 ea				ld de, cli_var_array+4 
d050				 
d050 eb					ex de, hl 
d051 73					ld (hl), e 
d052 23					inc hl 
d053 72					ld (hl), d 
d054			 
d054					; destroy value TOS 
d054			 
d054					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d054 cd 42 9d			call macro_forth_dsp_pop 
d057				endm 
# End of macro FORTH_DSP_POP
d057				       NEXTW 
d057 c3 75 9e			jp macro_next 
d05a				endm 
# End of macro NEXTW
d05a			.V2Q: 
d05a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
d05a 7d				db WORD_SYS_CORE+105             
d05b 6b d0			dw .V3S            
d05d 04				db 3 + 1 
d05e .. 00			db "V2@",0              
d062				endm 
# End of macro CWHEAD
d062			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
d062 2a 26 ea				ld hl, (cli_var_array+4) 
d065 cd 85 9a				call forth_push_numhl 
d068				       NEXTW 
d068 c3 75 9e			jp macro_next 
d06b				endm 
# End of macro NEXTW
d06b			.V3S: 
d06b				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
d06b 7c				db WORD_SYS_CORE+104             
d06c 83 d0			dw .V3Q            
d06e 04				db 3 + 1 
d06f .. 00			db "V3!",0              
d073				endm 
# End of macro CWHEAD
d073			;| V3! ( u1 -- )  Store value to v3 | DONE 
d073					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d073 cd 8a 9c			call macro_dsp_valuehl 
d076				endm 
# End of macro FORTH_DSP_VALUEHL
d076			 
d076 11 28 ea				ld de, cli_var_array+6 
d079				 
d079 eb					ex de, hl 
d07a 73					ld (hl), e 
d07b 23					inc hl 
d07c 72					ld (hl), d 
d07d			 
d07d					; destroy value TOS 
d07d			 
d07d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d07d cd 42 9d			call macro_forth_dsp_pop 
d080				endm 
# End of macro FORTH_DSP_POP
d080				       NEXTW 
d080 c3 75 9e			jp macro_next 
d083				endm 
# End of macro NEXTW
d083			.V3Q: 
d083				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
d083 7d				db WORD_SYS_CORE+105             
d084 94 d0			dw .END            
d086 04				db 3 + 1 
d087 .. 00			db "V3@",0              
d08b				endm 
# End of macro CWHEAD
d08b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
d08b 2a 28 ea				ld hl, (cli_var_array+6) 
d08e cd 85 9a				call forth_push_numhl 
d091				       NEXTW 
d091 c3 75 9e			jp macro_next 
d094				endm 
# End of macro NEXTW
d094			 
d094			 
d094			 
d094			 
d094			 
d094			; end of dict marker 
d094			 
d094 00			.END:    db WORD_SYS_END 
d095 00 00			dw 0 
d097 00				db 0 
d098			 
d098			; use to jp here for user dict words to save on macro expansion  
d098			 
d098			user_dict_next: 
d098				NEXTW 
d098 c3 75 9e			jp macro_next 
d09b				endm 
# End of macro NEXTW
d09b			 
d09b			 
d09b			user_exec: 
d09b				;    ld hl, <word code> 
d09b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
d09b				;    call forthexec 
d09b				;    jp user_dict_next   (NEXT) 
d09b			        ;    <word code bytes> 
d09b eb				ex de, hl 
d09c 2a bc e5			ld hl,(os_tok_ptr) 
d09f				 
d09f				FORTH_RSP_NEXT 
d09f cd 2c 9a			call macro_forth_rsp_next 
d0a2				endm 
# End of macro FORTH_RSP_NEXT
d0a2			 
d0a2			if DEBUG_FORTH_UWORD 
d0a2						DMARK "UEX" 
d0a2 f5				push af  
d0a3 3a b7 d0			ld a, (.dmark)  
d0a6 32 65 ee			ld (debug_mark),a  
d0a9 3a b8 d0			ld a, (.dmark+1)  
d0ac 32 66 ee			ld (debug_mark+1),a  
d0af 3a b9 d0			ld a, (.dmark+2)  
d0b2 32 67 ee			ld (debug_mark+2),a  
d0b5 18 03			jr .pastdmark  
d0b7 ..			.dmark: db "UEX"  
d0ba f1			.pastdmark: pop af  
d0bb			endm  
# End of macro DMARK
d0bb				CALLMONITOR 
d0bb cd 6f ee			call debug_vector  
d0be				endm  
# End of macro CALLMONITOR
d0be			endif 
d0be			 
d0be			 
d0be			 
d0be eb				ex de, hl 
d0bf 22 bc e5			ld (os_tok_ptr), hl 
d0c2				 
d0c2				; Don't use next - Skips the first word in uword. 
d0c2			 
d0c2 c3 fe 9e			jp exec1 
d0c5			;	NEXT 
d0c5			 
d0c5			 
d0c5			; eof 
# End of file forth_wordsv4.asm
d0c5			endif 
d0c5			;;;;;;;;;;;;;; Debug code 
d0c5			 
d0c5			 
d0c5			;if DEBUG_FORTH_PARSE 
d0c5 .. 00		.nowordfound: db "No match",0 
d0ce .. 00		.compword:	db "Comparing word ",0 
d0de .. 00		.nextwordat:	db "Next word at",0 
d0eb .. 00		.charmatch:	db "Char match",0 
d0f6			;endif 
d0f6			if DEBUG_FORTH_JP 
d0f6			.foundword:	db "Word match. Exec..",0 
d0f6			endif 
d0f6			;if DEBUG_FORTH_PUSH 
d0f6 .. 00		.enddict:	db "Dict end. Push.",0 
d106 .. 00		.push_str:	db "Pushing string",0 
d115 .. 00		.push_num:	db "Pushing number",0 
d124 .. 00		.data_sp:	db "SP:",0 
d128 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
d13a .. 00		.wordinde:	db "Word in DE (3/0):",0 
d14c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
d15e			;endif 
d15e			;if DEBUG_FORTH_MALLOC 
d15e .. 00		.push_malloc:	db "Malloc address",0 
d16d			;endif 
d16d			 
d16d			 
d16d			 
d16d			; display malloc address and current data stack pointer  
d16d			 
d16d			malloc_error: 
d16d d5				push de 
d16e f5				push af 
d16f e5				push hl 
d170 cd bd 8a			call clear_display 
d173 11 93 d1			ld de, .mallocerr 
d176 3e 00			ld a,0 
d178			;	ld de,os_word_scratch 
d178 cd d0 8a			call str_at_display 
d17b 3e 11			ld a, display_row_1+17 
d17d 11 65 ee			ld de, debug_mark 
d180 cd d0 8a			call str_at_display 
d183 cd e0 8a			call update_display 
d186				;call break_point_state 
d186 cd aa e2			call cin_wait 
d189			 
d189			;	ld a, ' ' 
d189			;	ld (os_view_disable), a 
d189 cd f4 93			call bp_on 
d18c e1				pop hl 
d18d f1				pop af 
d18e d1				pop de	 
d18f				CALLMONITOR 
d18f cd 6f ee			call debug_vector  
d192				endm  
# End of macro CALLMONITOR
d192 c9				ret 
d193			 
d193 .. 00		.mallocerr: 	db "Malloc Error",0 
d1a0			;if DEBUG_FORTH_PUSH 
d1a0			display_data_sp: 
d1a0 f5				push af 
d1a1			 
d1a1				; see if disabled 
d1a1			 
d1a1			 
d1a1 3a 6f ee			ld a, (debug_vector) 
d1a4 fe c9			cp $C9  ; RET 
d1a6				;ld a, (os_view_disable) 
d1a6				;cp '*' 
d1a6 28 67			jr z, .skipdsp 
d1a8			 
d1a8 e5				push hl 
d1a9 e5				push hl 
d1aa e5			push hl 
d1ab cd bd 8a			call clear_display 
d1ae e1			pop hl 
d1af 7c				ld a,h 
d1b0 21 c0 e5			ld hl, os_word_scratch 
d1b3 cd f3 8e			call hexout 
d1b6 e1				pop hl 
d1b7 7d				ld a,l 
d1b8 21 c2 e5			ld hl, os_word_scratch+2 
d1bb cd f3 8e			call hexout 
d1be 21 c4 e5			ld hl, os_word_scratch+4 
d1c1 3e 00			ld a,0 
d1c3 77				ld (hl),a 
d1c4 11 c0 e5			ld de,os_word_scratch 
d1c7 3e 28				ld a, display_row_2 
d1c9 cd d0 8a				call str_at_display 
d1cc 11 28 d1			ld de, .wordinhl 
d1cf 3e 00			ld a, display_row_1 
d1d1			 
d1d1 cd d0 8a				call str_at_display 
d1d4 11 65 ee			ld de, debug_mark 
d1d7 3e 11			ld a, display_row_1+17 
d1d9			 
d1d9 cd d0 8a				call str_at_display 
d1dc			 
d1dc				; display current data stack pointer 
d1dc 11 24 d1			ld de,.data_sp 
d1df 3e 30				ld a, display_row_2 + 8 
d1e1 cd d0 8a				call str_at_display 
d1e4			 
d1e4 2a e8 e9			ld hl,(cli_data_sp) 
d1e7 e5				push hl 
d1e8 7c				ld a,h 
d1e9 21 c0 e5			ld hl, os_word_scratch 
d1ec cd f3 8e			call hexout 
d1ef e1				pop hl 
d1f0 7d				ld a,l 
d1f1 21 c2 e5			ld hl, os_word_scratch+2 
d1f4 cd f3 8e			call hexout 
d1f7 21 c4 e5			ld hl, os_word_scratch+4 
d1fa 3e 00			ld a,0 
d1fc 77				ld (hl),a 
d1fd 11 c0 e5			ld de,os_word_scratch 
d200 3e 33				ld a, display_row_2 + 11 
d202 cd d0 8a				call str_at_display 
d205			 
d205			 
d205 cd e0 8a			call update_display 
d208 cd 00 8a			call delay1s 
d20b cd 00 8a			call delay1s 
d20e e1				pop hl 
d20f			.skipdsp: 
d20f f1				pop af 
d210 c9				ret 
d211			 
d211			display_data_malloc: 
d211			 
d211 f5				push af 
d212 e5				push hl 
d213 e5				push hl 
d214 e5			push hl 
d215 cd bd 8a			call clear_display 
d218 e1			pop hl 
d219 7c				ld a,h 
d21a 21 c0 e5			ld hl, os_word_scratch 
d21d cd f3 8e			call hexout 
d220 e1				pop hl 
d221 7d				ld a,l 
d222 21 c2 e5			ld hl, os_word_scratch+2 
d225 cd f3 8e			call hexout 
d228 21 c4 e5			ld hl, os_word_scratch+4 
d22b 3e 00			ld a,0 
d22d 77				ld (hl),a 
d22e 11 c0 e5			ld de,os_word_scratch 
d231 3e 28				ld a, display_row_2 
d233 cd d0 8a				call str_at_display 
d236 11 5e d1			ld de, .push_malloc 
d239 3e 00			ld a, display_row_1 
d23b			 
d23b cd d0 8a				call str_at_display 
d23e			 
d23e				; display current data stack pointer 
d23e 11 24 d1			ld de,.data_sp 
d241 3e 30				ld a, display_row_2 + 8 
d243 cd d0 8a				call str_at_display 
d246			 
d246 2a e8 e9			ld hl,(cli_data_sp) 
d249 e5				push hl 
d24a 7c				ld a,h 
d24b 21 c0 e5			ld hl, os_word_scratch 
d24e cd f3 8e			call hexout 
d251 e1				pop hl 
d252 7d				ld a,l 
d253 21 c2 e5			ld hl, os_word_scratch+2 
d256 cd f3 8e			call hexout 
d259 21 c4 e5			ld hl, os_word_scratch+4 
d25c 3e 00			ld a,0 
d25e 77				ld (hl),a 
d25f 11 c0 e5			ld de,os_word_scratch 
d262 3e 33				ld a, display_row_2 + 11 
d264 cd d0 8a				call str_at_display 
d267			 
d267 cd e0 8a			call update_display 
d26a cd 00 8a			call delay1s 
d26d cd 00 8a			call delay1s 
d270 e1				pop hl 
d271 f1				pop af 
d272 c9				ret 
d273			;endif 
d273			 
d273			include "forth_autostart.asm" 
d273			; list of commands to perform at system start up 
d273			 
d273			startcmds: 
d273			;	dw test11 
d273			;	dw test12 
d273			;	dw test13 
d273			;	dw test14 
d273			;	dw test15 
d273			;	dw test16 
d273			;	dw test17 
d273			;	dw ifthtest1 
d273			;	dw ifthtest2 
d273			;	dw ifthtest3 
d273			;	dw mmtest1 
d273			;	dw mmtest2 
d273			;	dw mmtest3 
d273			;	dw mmtest4 
d273			;	dw mmtest5 
d273			;	dw mmtest6 
d273			;	dw iftest1 
d273			;	dw iftest2 
d273			;	dw iftest3 
d273			;	dw looptest1 
d273			;	dw looptest2 
d273			;	dw test1 
d273			;	dw test2 
d273			;	dw test3 
d273			;	dw test4 
d273			;	dw game2r 
d273			;	dw game2b1 
d273			;	dw game2b2 
d273			 
d273				; start up words that are actually useful 
d273			 
d273			;    dw spi1 
d273			;    dw spi2 
d273			;    dw spi3 
d273			;    dw spi4 
d273			;    dw spi5 
d273			;    dw spi6 
d273			;    dw spi7 
d273			; 
d273			;    dw spi8 
d273			;    dw spi9 
d273			;    dw spi10 
d273			 
d273			; file editor 
d273			;	dw edit1 
d273			;	dw edit2 
d273			;	dw edit3 
d273			 
d273			;	dw longread 
d273 95 d6			dw clrstack 
d275 c9 d6			dw type 
d277			;	dw stest 
d277 ee d6			dw strncpy 
d279 5e d8			dw list 
d27b 4f d7			dw start1 
d27d 5f d7			dw start2 
d27f			;	dw start3 
d27f			;	dw start3b 
d27f			;	dw start3c 
d27f			 
d27f				; (unit) testing words 
d27f			 
d27f			;	dw mtesta 
d27f			;	dw mtestb 
d27f			;	dw mtestc 
d27f			;	dw mtestd 
d27f			;	dw mteste 
d27f			 
d27f				; demo/game words 
d27f			 
d27f			;        dw game3w 
d27f			;        dw game3p 
d27f			;        dw game3sc 
d27f			;        dw game3vsi 
d27f			;        dw game3vs 
d27f				 
d27f			;	dw game2b 
d27f			;	dw game2bf 
d27f			;	dw game2mba 
d27f			;	dw game2mbas 
d27f			;	dw game2mb 
d27f			 
d27f 8f da			dw game1 
d281 a0 da			dw game1a 
d283 02 db			dw game1b 
d285 37 db			dw game1c 
d287 6d db			dw game1d 
d289 9e db			dw game1s 
d28b b2 db			dw game1t 
d28d c7 db			dw game1f 
d28f fb db			dw game1z 
d291 3f dc			dw game1zz 
d293			 
d293 c8 d8			dw test5 
d295 00 d9			dw test6 
d297 38 d9			dw test7 
d299 4c d9			dw test8 
d29b 78 d9			dw test9 
d29d 8e d9			dw test10 
d29f				 
d29f 16 dd		        dw ssv5 
d2a1 fa dc		        dw ssv4 
d2a3 de dc		        dw ssv3 
d2a5 a8 dc		        dw ssv2 
d2a7 2f dd		        dw ssv1 
d2a9 77 dd		        dw ssv1cpm 
d2ab			;	dw keyup 
d2ab			;	dw keydown 
d2ab			;	dw keyleft 
d2ab			;	dw keyright 
d2ab			;	dw 	keyf1 
d2ab			;	dw keyf2 
d2ab			;	dw keyf3 
d2ab			;	dw keyf4 
d2ab			;	dw keyf5 
d2ab			;	dw keyf6 
d2ab			;	dw keyf7 
d2ab			;	dw keyf8 
d2ab			;	dw keyf9 
d2ab			;	dw keyf10 
d2ab			;	dw keyf11 
d2ab			;	dw keyf12 
d2ab			;	dw keytab 
d2ab			;	dw keycr 
d2ab			;	dw keyhome 
d2ab			;	dw keyend 
d2ab			;	dw keybs 
d2ab 00 00			db 0, 0	 
d2ad			 
d2ad			 
d2ad			; File Editor 
d2ad			 
d2ad			; ( id - ) use 'e' to edit the displayed line 
d2ad .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d2ce .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d303			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d303 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d33b			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d33b			 
d33b			; SPI Net support words 
d33b			 
d33b			; v0! = node to send to 
d33b			; ( str count - ) 
d33b .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d394			 
d394			; spiputc ( char node - ) 
d394 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d3c8			; spiputc ( u node - ) 
d3c8 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d3f6			 
d3f6			; spigetc ( - n ) 
d3f6 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d41f			 
d41f			; getnode ( - n ) 
d41f .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d44c			 
d44c			; ( str node - )  
d44c .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d4b2			; store string ( str i - ) 
d4b2			 
d4b2			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d4b2 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d507			 
d507			; get string ( addr i -  )    TO FIX 
d507			 
d507 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d55f			 
d55f			 
d55f			; NETCHAT (TODO) 
d55f			; Program to allow two nodes to chat with eachother 
d55f			; 
d55f			; v0 - target node 
d55f			;  
d55f			; accept input at 0,0 
d55f			; if input is string send spitype to target node 
d55f			; starting at row 2,0 , while spigetchr is not zero ->  
d55f			; 
d55f			; 
d55f			; TODO add paging of get request 
d55f			 
d55f			; ( node - ) 
d55f .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d57e .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d5d6 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d64e			 
d64e			 
d64e			; Long read of currently open file 
d64e .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d695			 
d695			; clear stack  
d695			 
d695 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d6c9			 
d6c9			; type ( addr count - ) 
d6c9 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d6ee			 
d6ee			; some direct memory words 
d6ee			; strncpy ( len t f -- t ) 
d6ee			 
d6ee .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d74f			 
d74f .. 00		start1:     	db ": bpon $00 bp ;",0 
d75f .. 00		start2:     	db ": bpoff $01 bp ;",0 
d770 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d7eb .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d84b			 
d84b .. 00		tuck:         db ": tuck swap over ;", 0 
d85e			 
d85e			; a handy word to list items on the stack 
d85e			 
d85e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d8c8			 
d8c8			 
d8c8			; test stack  
d8c8			; rnd8 stest 
d8c8			 
d8c8			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d8c8			 
d8c8			; random malloc and free cycles 
d8c8			 
d8c8			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d8c8			 
d8c8			; fixed malloc and free cycles 
d8c8			 
d8c8			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d8c8			 
d8c8			; fixed double string push and drop cycle  
d8c8			 
d8c8			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d8c8			 
d8c8			; consistent fixed string push and drop cycle  
d8c8			 
d8c8			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d8c8			 
d8c8			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d8c8			 
d8c8			;test1:		db ": aa 1 2 3 ;", 0 
d8c8			;test2:     	db "111 aa 888 999",0 
d8c8			;test3:     	db ": bb 77 ;",0 
d8c8			;test4:     	db "$02 $01 do i . loop bb",0 
d8c8			 
d8c8 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d900 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d938 .. 00		test7:     	db ": box hline vline ;",0 
d94c .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d978 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d98e .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d9b3			;test11:     	db "hello create .",0 
d9b3			;test12:     	db "hello2 create .",0 
d9b3			 
d9b3			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d9b3			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d9b3			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d9b3			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d9b3			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d9b3			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d9b3			 
d9b3			;iftest1:     	db "$0001 IF cls .",0 
d9b3			;iftest2:     	db "$0000 IF cls .",0 
d9b3			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d9b3			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d9b3			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d9b3			 
d9b3			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d9b3			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d9b3			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d9b3			 
d9b3			 
d9b3 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d9d7 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
da07 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
da2c .. 00		sound4: db ": cha $00 ; ",0 
da39 .. 00		sound5: db ": chb $20 ; ",0 
da46 .. 00		sound6: db ": chc $40 ; ",0 
da53 .. 00		sound7: db ": chd $60 ; ",0 
da60 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
da78 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
da8f			 
da8f			 
da8f			 
da8f			 
da8f			; a small guess the number game 
da8f			 
da8f .. 00		game1:          db ": gsn rnd8 v1! ;",0 
daa0 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
db02			 
db02 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
db37 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
db6d .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
db9e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dbb2 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dbc7 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dbfb .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dc3f			 
dc3f			; Using 'ga' save a high score across multiple runs using external storage 
dc3f			 
dc3f .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
dca8			 
dca8			 
dca8			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
dca8			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
dca8			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
dca8			 
dca8			; simple screen saver to test code memory reuse to destruction 
dca8			 
dca8 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
dcde .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dcfa .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dd16 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dd2f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dd77 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
ddce			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
ddce			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
ddce			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
ddce			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
ddce			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
ddce			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
ddce			 
ddce			 
ddce			 
ddce			; minesweeper/battleship finding game 
ddce			; draws a game board of random ship/mine positions 
ddce			; user enters coords to see if it hits on 
ddce			; game ends when all are hit 
ddce			; when hit or miss says how many may be in the area 
ddce			 
ddce			; setup the game board and then hide it 
ddce			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
ddce			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
ddce			;; prompt for where to target 
ddce			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
ddce			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ddce			;; TODO see if the entered coords hits or misses pushes char hit of miss 
ddce			;game2mbht:      db ": mbckht nop ;",0 
ddce			;game2mbms:      db ": mbcms nop ;",0 
ddce			; TODO how many might be near by 
ddce			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
ddce			 
ddce			; Game 3 
ddce			 
ddce			; Vert scroller ski game - avoid the trees! 
ddce			 
ddce			; v0 score (ie turns) 
ddce			; v1 player pos 
ddce			; v2 left wall 
ddce			; v3 right wall 
ddce			 
ddce			; Draw side walls randomly 
ddce			 
ddce			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
ddce			 
ddce			; Draw player 
ddce			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
ddce			 
ddce			; TODO Get Key 
ddce			 
ddce			; TODO Move left right 
ddce			 
ddce			; scroll and move walls a bit 
ddce			 
ddce			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
ddce			 
ddce			; main game loop 
ddce			 
ddce			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
ddce			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
ddce			 
ddce			; key board defs 
ddce			 
ddce .. 00		keyup:       db ": keyup $05 ;",0 
dddc .. 00		keydown:       db ": keydown $0a ;",0 
ddec .. 00		keyleft:       db ": keyleft $0b ;",0 
ddfc .. 00		keyright:       db ": keyright $0c ;",0 
de0d .. 00		keyf1:       db ": keyf1 $10 ;",0 
de1b .. 00		keyf2:       db ": keyf2 $11 ;",0 
de29 .. 00		keyf3:       db ": keyf3 $12 ;",0 
de37 .. 00		keyf4:       db ": keyf4 $13 ;",0 
de45 .. 00		keyf5:       db ": keyf5 $14 ;",0 
de53 .. 00		keyf6:       db ": keyf6 $15 ;",0 
de61 .. 00		keyf7:       db ": keyf7 $16 ;",0 
de6f .. 00		keyf8:       db ": keyf8 $17 ;",0 
de7d .. 00		keyf9:       db ": keyf9 $18 ;",0 
de8b .. 00		keyf10:       db ": keyf10 $19 ;",0 
de9a .. 00		keyf11:       db ": keyf11 $1a ;",0 
dea9 .. 00		keyf12:       db ": keyf12 $1b ;",0 
deb8			 
deb8 .. 00		keytab:       db ": keytab $09 ;",0 
dec7 .. 00		keycr:       db ": keycr $0d ;",0 
ded5 .. 00		keyhome:       db ": keyhome $0e ;",0 
dee5 .. 00		keyend:       db ": keyend $0f ;",0 
def4 .. 00		keybs:       db ": keybs $08 ;",0 
df02			 
df02			   
df02			 
df02			 
df02			 
df02			; eof 
# End of file forth_autostart.asm
df02			 
df02			 
df02			 
df02			; stack over and underflow checks 
df02			 
df02			; init the words to detect the under/overflow 
df02			 
df02			chk_stk_init: 
df02				; a vague random number to check so we dont get any "lucky" hits 
df02 3e 2d			ld a, 45 
df04 6f				ld l, a 
df05 00				nop 
df06 3e 17			ld a, 23 
df08 67				ld h, a 
df09			 
df09 22 97 e2			ld (chk_word), hl     ; the word we need to check against 
df0c			 
df0c			;	ld (chk_stund), hl	; stack points.... 
df0c 22 00 ef			ld (chk_stovr), hl 
df0f 22 e6 e9			ld (chk_ret_und), hl 
df12 22 a4 e9			ld (chk_ret_ovr), hl 
df15 22 22 e9			ld (chk_loop_ovr), hl 
df18 22 20 e8			ld (chk_data_ovr), hl 
df1b c9				ret 
df1c				 
df1c			check_stacks: 
df1c				; check all stack words 
df1c			 
df1c e5				push hl 
df1d d5				push de 
df1e			 
df1e			;	ld de,(chk_word) 
df1e			;	ld hl, (chk_stund)	; stack points.... 
df1e			;	if DEBUG_STK_FAULT 
df1e			;		DMARK "FAa" 
df1e			;		CALLMONITOR 
df1e			;	endif 
df1e			;	call cmp16 
df1e			;	jp z, .chk_faulta 
df1e			; 
df1e			;	ld de, sfaultsu 
df1e			;	jp .chk_fault 
df1e			 
df1e 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
df21 ed 5b 97 e2		ld de,(chk_word) 
df25				if DEBUG_STK_FAULT 
df25					DMARK "FAb" 
df25					CALLMONITOR 
df25				endif 
df25 cd 08 8d			call cmp16 
df28 28 06			jr z, .chk_fault1 
df2a 11 ce df			ld de, sfaultso 
df2d c3 7f df			jp .chk_fault 
df30			.chk_fault1:  
df30 2a e6 e9			ld hl, (chk_ret_und) 
df33 ed 5b 97 e2		ld de,(chk_word) 
df37				if DEBUG_STK_FAULT 
df37					DMARK "FAU" 
df37					CALLMONITOR 
df37				endif 
df37 cd 08 8d			call cmp16 
df3a ca 43 df			jp z, .chk_fault2 
df3d 11 de df			ld de, sfaultru 
df40 c3 7f df			jp .chk_fault 
df43			.chk_fault2:  
df43 2a a4 e9			ld hl, (chk_ret_ovr) 
df46 ed 5b 97 e2		ld de,(chk_word) 
df4a				if DEBUG_STK_FAULT 
df4a					DMARK "FA1" 
df4a					CALLMONITOR 
df4a				endif 
df4a cd 08 8d			call cmp16 
df4d ca 56 df			jp z, .chk_fault3 
df50 11 ec df			ld de, sfaultro 
df53 c3 7f df			jp .chk_fault 
df56			.chk_fault3:  
df56 2a 22 e9			ld hl, (chk_loop_ovr) 
df59 ed 5b 97 e2		ld de,(chk_word) 
df5d				if DEBUG_STK_FAULT 
df5d					DMARK "FA2" 
df5d					CALLMONITOR 
df5d				endif 
df5d cd 08 8d			call cmp16 
df60 ca 69 df			jp z, .chk_fault4 
df63 11 06 e0			ld de, sfaultlo 
df66 c3 7f df			jp .chk_fault 
df69			.chk_fault4:  
df69 2a 20 e8			ld hl, (chk_data_ovr) 
df6c ed 5b 97 e2		ld de,(chk_word) 
df70				if DEBUG_STK_FAULT 
df70					DMARK "FA3" 
df70					CALLMONITOR 
df70				endif 
df70 cd 08 8d			call cmp16 
df73 ca 7c df			jp z, .chk_fault5 
df76 11 20 e0			ld de, sfaultdo 
df79 c3 7f df			jp .chk_fault 
df7c			 
df7c			 
df7c			.chk_fault5:  
df7c d1				pop de 
df7d e1				pop hl 
df7e			 
df7e c9				ret 
df7f			 
df7f cd bd 8a		.chk_fault: 	call clear_display 
df82 3e 28				ld a, display_row_2 
df84 cd d0 8a				call str_at_display 
df87 11 b0 df				   ld de, .stackfault 
df8a 3e 00				ld a, display_row_1 
df8c cd d0 8a				call str_at_display 
df8f 11 65 ee				    ld de, debug_mark 
df92 3e 11				ld a, display_row_1+17 
df94 cd d0 8a				call str_at_display 
df97 cd e0 8a				call update_display 
df9a			 
df9a				; prompt before entering montior for investigating issue 
df9a			 
df9a 3e 78			ld a, display_row_4 
df9c 11 63 97			ld de, endprog 
df9f			 
df9f cd e0 8a			call update_display		 
dfa2			 
dfa2 cd fd 99			call next_page_prompt 
dfa5			 
dfa5 d1				pop de 
dfa6 e1				pop hl 
dfa7 cd b7 97				call monitor 
dfaa cd 1b 9e				call forth_warmstart 
dfad c3 b3 96				jp warmstart_afterauto 
dfb0					;jp 0 
dfb0					;halt 
dfb0			 
dfb0			 
dfb0			 
dfb0 .. 00		.stackfault: 	db "Stack fault:",0 
dfbd			 
dfbd .. 00		sfaultsu: 	db	"Stack under flow",0 
dfce .. 00		sfaultso: 	db	"Stack over flow",0 
dfde .. 00		sfaultru:	db "RTS underflow",0 
dfec .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e006 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e020 .. 00		sfaultdo:	db "DTS overflow", 0 
e02d			 
e02d			 
e02d			fault_dsp_under: 
e02d 11 3f e0			ld de, .dsp_under 
e030 c3 f5 e0			jp .show_fault 
e033			 
e033			fault_rsp_under: 
e033 11 4d e0			ld de, .rsp_under 
e036 c3 f5 e0			jp .show_fault 
e039			fault_loop_under: 
e039 11 5b e0			ld de, .loop_under 
e03c c3 f5 e0			jp .show_fault 
e03f			 
e03f .. 00		.dsp_under: db "DSP Underflow",0 
e04d .. 00		.rsp_under: db "RSP Underflow",0 
e05b .. 00		.loop_under: db "LOOP Underflow",0 
e06a			 
e06a			 
e06a d5			type_faultn: 	push de 
e06b e5					push hl 
e06c cd bd 8a				call clear_display 
e06f 11 99 e0				   ld de, .typefaultn 
e072 3e 00				ld a, display_row_1 
e074 cd d0 8a				call str_at_display 
e077 11 65 ee				    ld de, debug_mark 
e07a 3e 11				ld a, display_row_1+17 
e07c cd d0 8a				call str_at_display 
e07f cd e0 8a				call update_display 
e082			 
e082				; prompt before entering montior for investigating issue 
e082			 
e082 3e 78			ld a, display_row_4 
e084 11 63 97			ld de, endprog 
e087			 
e087 cd e0 8a			call update_display		 
e08a			 
e08a cd fd 99			call next_page_prompt 
e08d			 
e08d e5					push hl 
e08e d5					push de 
e08f cd b7 97				call monitor 
e092 cd 1b 9e				call forth_warmstart 
e095 c3 b3 96				jp warmstart_afterauto 
e098 76					halt 
e099			 
e099			 
e099 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e0b0			 
e0b0 d5			type_faults: 	push de 
e0b1 e5					push hl 
e0b2 cd bd 8a				call clear_display 
e0b5 11 de e0				   ld de, .typefaults 
e0b8 3e 00				ld a, display_row_1 
e0ba cd d0 8a				call str_at_display 
e0bd 11 65 ee				    ld de, debug_mark 
e0c0 3e 11				ld a, display_row_1+17 
e0c2 cd d0 8a				call str_at_display 
e0c5 cd e0 8a				call update_display 
e0c8			 
e0c8				; prompt before entering montior for investigating issue 
e0c8			 
e0c8 3e 78			ld a, display_row_4 
e0ca 11 63 97			ld de, endprog 
e0cd			 
e0cd cd e0 8a			call update_display		 
e0d0			 
e0d0 cd fd 99			call next_page_prompt 
e0d3			 
e0d3 e1					pop hl 
e0d4 d1					pop de 
e0d5 cd b7 97				call monitor 
e0d8 cd 1b 9e				call forth_warmstart 
e0db c3 b3 96				jp warmstart_afterauto 
e0de			 
e0de			 
e0de .. 00		.typefaults: db "STR Type Expected TOS!",0 
e0f5			 
e0f5			.show_fault: 	 
e0f5 d5					push de 
e0f6 cd bd 8a				call clear_display 
e0f9 d1					pop de 
e0fa 3e 00				ld a, display_row_1 
e0fc cd d0 8a				call str_at_display 
e0ff 11 65 ee				    ld de, debug_mark 
e102 3e 11				ld a, display_row_1+17 
e104 cd d0 8a				call str_at_display 
e107 cd e0 8a				call update_display 
e10a			 
e10a				; prompt before entering montior for investigating issue 
e10a			 
e10a 3e 78			ld a, display_row_4 
e10c 11 63 97			ld de, endprog 
e10f			 
e10f cd e0 8a			call update_display		 
e112			 
e112 cd fd 99			call next_page_prompt 
e115			 
e115 e1					pop hl 
e116 d1					pop de 
e117 cd b7 97				call monitor 
e11a			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e11a			; TODO Make optional fault restart to cli or warm boot? 
e11a					;jp warmstart 
e11a c3 f7 96				jp cli 
e11d 76					halt 
e11e			 
e11e			 
e11e			; handle the auto run of code from files in storage 
e11e			 
e11e			 
e11e			include "forth_startup.asm" 
e11e			; Which startup method to use? 
e11e			; 
e11e			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e11e			; followed by loading of a list of scripts in eeprom 
e11e			 
e11e			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e11e			; from eeprom 
e11e			 
e11e			; Select with define in main stubs 
e11e			 
e11e			if STARTUP_V1 
e11e				include "forth_startupv1.asm" 
e11e			; Startup script loading version 1 
e11e			 
e11e			; If SE storage is available first stage is to use the selected file 
e11e			; then go through the eeprom list 
e11e			 
e11e .. 00		sprompt1: db "Startup load...",0 
e12e .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e144			 
e144			 
e144			 
e144			 
e144			forth_startup: 
e144 21 73 d2			ld hl, startcmds 
e147 3e 00			ld a, 0 
e149 32 e1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e14c			 
e14c e5			.start1:	push hl 
e14d cd bd 8a			call clear_display 
e150 11 1e e1			ld de, sprompt1 
e153 3e 00		        ld a, display_row_1 
e155 cd d0 8a			call str_at_display 
e158 11 2e e1			ld de, sprompt2 
e15b 3e 28		        ld a, display_row_2 
e15d cd d0 8a			call str_at_display 
e160 e1				pop hl 
e161 e5				push hl 
e162 5e				ld e,(hl) 
e163 23				inc hl 
e164 56				ld d,(hl) 
e165 3e 50		        ld a, display_row_3 
e167 cd d0 8a			call str_at_display 
e16a cd e0 8a			call update_display 
e16d			 
e16d			 
e16d 3a e1 e6			ld a, (os_last_cmd) 
e170 fe 00			cp 0 
e172 28 05			jr z, .startprompt 
e174 cd f4 89			call delay250ms 
e177 18 24			jr .startdo 
e179				 
e179				 
e179			 
e179			.startprompt: 
e179			 
e179 3e 9f			ld a,display_row_4 + display_cols - 1 
e17b 11 fb 99		        ld de, endprg 
e17e cd d0 8a			call str_at_display 
e181 cd e0 8a			call update_display 
e184 cd 00 8a			call delay1s 
e187 cd aa e2			call cin_wait 
e18a						 
e18a fe 2a			cp '*' 
e18c 28 5e			jr z, .startupend1 
e18e fe 23			cp '#' 
e190 20 07			jr nz, .startno 
e192 3e 01			ld a, 1 
e194 32 e1 e6			ld (os_last_cmd),a 
e197 18 04			jr .startdo 
e199 fe 31		.startno:	cp '1' 
e19b 28 3a			jr z,.startnxt  
e19d			 
e19d				; exec startup line 
e19d			.startdo:	 
e19d e1				pop hl 
e19e e5				push hl 
e19f				 
e19f 5e				ld e,(hl) 
e1a0 23				inc hl 
e1a1 56				ld d,(hl) 
e1a2 eb				ex de,hl 
e1a3			 
e1a3 e5				push hl 
e1a4			 
e1a4 3e 00			ld a, 0 
e1a6				;ld a, FORTH_END_BUFFER 
e1a6 cd 5b 90			call strlent 
e1a9 23				inc hl   ; include zero term to copy 
e1aa 06 00			ld b,0 
e1ac 4d				ld c,l 
e1ad e1				pop hl 
e1ae 11 bb e2			ld de, scratch 
e1b1 ed b0			ldir 
e1b3			 
e1b3			 
e1b3 21 bb e2			ld hl, scratch 
e1b6 cd bf 9e			call forthparse 
e1b9 cd fb 9e			call forthexec 
e1bc cd 15 9e			call forthexec_cleanup 
e1bf			 
e1bf 3e 78			ld a, display_row_4 
e1c1 11 63 97			ld de, endprog 
e1c4			 
e1c4 cd e0 8a			call update_display		 
e1c7			 
e1c7 3a e1 e6			ld a, (os_last_cmd) 
e1ca fe 00			cp 0 
e1cc 20 09			jr nz, .startnxt 
e1ce cd fd 99			call next_page_prompt 
e1d1 cd bd 8a		        call clear_display 
e1d4 cd e0 8a			call update_display		 
e1d7			 
e1d7				; move onto next startup line? 
e1d7			.startnxt: 
e1d7			 
e1d7 cd f4 89			call delay250ms 
e1da e1				pop hl 
e1db			 
e1db 23				inc hl 
e1dc 23				inc hl 
e1dd			 
e1dd e5				push hl 
e1de 5e				ld e, (hl) 
e1df 23				inc hl 
e1e0 56				ld d, (hl) 
e1e1 e1				pop hl 
e1e2				; TODO replace 0 test 
e1e2			 
e1e2 eb				ex de, hl 
e1e3 cd 13 8d			call ishlzero 
e1e6			;	ld a,e 
e1e6			;	add d 
e1e6			;	cp 0    ; any left to do? 
e1e6 eb				ex de, hl 
e1e7 c2 4c e1			jp nz, .start1 
e1ea 18 01			jr .startupend 
e1ec			 
e1ec e1			.startupend1: pop hl 
e1ed			.startupend: 
e1ed			 
e1ed cd bd 8a			call clear_display 
e1f0 cd e0 8a			call update_display 
e1f3 c9				ret 
e1f4			if STORAGE_SE 
e1f4			 
e1f4			sprompt3: db "Loading from start-up file?:",0 
e1f4			sprompt4: db "(Y=Any key/N=No)",0 
e1f4			 
e1f4			 
e1f4			forth_autoload: 
e1f4			 
e1f4				; load block 0 of store 1 
e1f4				 
e1f4				ld a, $fe      ; bit 0 clear 
e1f4				ld (spi_device), a 
e1f4			 
e1f4				call storage_get_block_0 
e1f4			 
e1f4				ld a, (store_page+STORE_0_AUTOFILE) 
e1f4			 
e1f4				cp 0 
e1f4				ret z     ; auto start not enabled 
e1f4			 
e1f4				call clear_display 
e1f4			 
e1f4				; set bank 
e1f4			 
e1f4					ld a, (store_page+STORE_0_BANKRUN) 
e1f4					ld (spi_device), a 
e1f4			 
e1f4				; get file id to load from and get the file name to display 
e1f4			 
e1f4					ld a, (store_page+STORE_0_FILERUN) 
e1f4			 
e1f4					ld l, 0 
e1f4					ld h, a 
e1f4					ld de, store_page 
e1f4			 
e1f4					if DEBUG_FORTH_WORDS 
e1f4						DMARK "ASp" 
e1f4						CALLMONITOR 
e1f4					endif 
e1f4					call storage_read 
e1f4			 
e1f4					if DEBUG_FORTH_WORDS 
e1f4						DMARK "ASr" 
e1f4						CALLMONITOR 
e1f4					endif 
e1f4			 
e1f4					call ishlzero 
e1f4					ret z             ; file not found 
e1f4			 
e1f4					ld a, display_row_2 + 10 
e1f4					ld de, store_page+3 
e1f4					call str_at_display 
e1f4				 
e1f4			; 
e1f4			 
e1f4				ld a, display_row_1+5 
e1f4				ld de, sprompt3 
e1f4				call str_at_display 
e1f4				ld a, display_row_3+15 
e1f4				ld de, sprompt4 
e1f4				call str_at_display 
e1f4			 
e1f4				call update_display 
e1f4			 
e1f4				call cin_wait 
e1f4				cp 'n' 
e1f4				ret z 
e1f4				cp 'N' 
e1f4				ret z 
e1f4			 
e1f4				call delay1s 
e1f4			 
e1f4				ld a, (store_page+2) 
e1f4				ld (store_openmaxext), a    ; save count of ext 
e1f4				ld a, 1  
e1f4				ld (store_openext), a    ; save count of ext 
e1f4			 
e1f4			.autof:  
e1f4				ld l , a 
e1f4				 
e1f4				ld a, (store_page) 
e1f4				ld h, a	 
e1f4				ld de, store_page 
e1f4					if DEBUG_FORTH_WORDS 
e1f4						DMARK "ASl" 
e1f4						CALLMONITOR 
e1f4					endif 
e1f4					call storage_read 
e1f4				call ishlzero 
e1f4				ret z 
e1f4			;	jr z, .autoend 
e1f4			 
e1f4					if DEBUG_FORTH_WORDS 
e1f4						DMARK "ASc" 
e1f4						CALLMONITOR 
e1f4					endif 
e1f4				ld de, store_page+2 
e1f4				ld a, display_row_4 
e1f4				call str_at_display 
e1f4			 
e1f4				call update_display 
e1f4				call delay250ms 
e1f4			 
e1f4			 
e1f4			 
e1f4				ld hl, store_page+2 
e1f4				call forthparse 
e1f4				call forthexec 
e1f4				call forthexec_cleanup 
e1f4			 
e1f4				 
e1f4				ld a, (store_openext) 
e1f4				inc a 
e1f4				ld (store_openext), a    ; save count of ext 
e1f4			 
e1f4				jr .autof 
e1f4			;.autofdone: 
e1f4			; 
e1f4			;		if DEBUG_FORTH_WORDS 
e1f4			;			DMARK "ASx" 
e1f4			;			CALLMONITOR 
e1f4			;		endif 
e1f4			;;	call clear_display 
e1f4			;	ret 
e1f4			 
e1f4			 
e1f4			 
e1f4			endif 
# End of file forth_startupv1.asm
e1f4			endif 
e1f4			if STARTUP_V2 
e1f4				include "forth_startupv2.asm" 
e1f4			endif 
e1f4			 
# End of file forth_startup.asm
e1f4			 
e1f4			; eof 
# End of file forth_kernel.asm
e1f4			;include "nascombasic.asm" 
e1f4			 
e1f4			 
e1f4			; find out where the code ends if loaded into RAM (for SC114) 
e1f4			;endofcode:  
e1f4			;	nop 
e1f4			 
e1f4			 
e1f4			; jump to nmi vector 
e1f4			 
e1f4			init_nmi: 
e1f4 3e c9			ld a, $c9   ; RET 
e1f6 32 72 ee			ld (nmi_vector), a 
e1f9 c9				ret 
e1fa			nmi: 
e1fa e5				push hl 
e1fb d5				push de 
e1fc c5				push bc 
e1fd f5				push af 
e1fe cd 72 ee			call nmi_vector 
e201 f5				push af 
e202 c5				push bc 
e203 d5				push de 
e204 e5				push hl 
e205 ed 4d			reti 
e207			 
e207			 
e207			; eof 
e207			 
# End of file main.asm
e207			;include "firmware_lcd_4x40.asm" 
e207			;;include "firmware_lcd_4x20.asm" 
e207			include "firmware_serial_display.asm" 
e207			 
e207			; Serial display interface for SC114 
e207			 
e207			 
e207			display_row_1: equ 0 
e207			display_row_2: equ display_row_1+display_cols 
e207			display_row_3: equ display_row_2 + display_cols 
e207			display_row_4: equ display_row_3 + display_cols 
e207			 
e207			kLCDWidth:  EQU display_cols             ;Width in characters 
e207			kLCD_Line1: EQU 0x00  
e207			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e207			; E1 
e207			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e207			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e207			 
e207			lcd_init: 
e207				; no init as handled by the SCM bios 
e207 c9				ret 
e208			 
e208			 
e208			; low level functions for direct screen writes 
e208			 
e208			; output char at pos? 
e208			fLCD_Str: 
e208			        ;out (SC114_SIO_1_OUT),a 
e208 c5				push bc 
e209 0e 02			ld c, $02 
e20b f7				rst $30 
e20c c1				pop bc 
e20d c9				ret 
e20e			 
e20e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e20e			fLCD_Pos: 
e20e				; use ASCII escape to position 
e20e			        ;out (SC114_SIO_1_OUT),a 
e20e c5				push bc 
e20f 0e 02			ld c, $02 
e211 f7				rst $30 
e212 c1				pop bc 
e213			 
e213 c9				ret 
e214			 
e214			; output char at pos 
e214			fLCD_Data: 
e214			      ;  out (SC114_SIO_1_OUT),a 
e214 c5				push bc 
e215 0e 02			ld c, $02 
e217 f7				rst $30 
e218 c1				pop bc 
e219			 
e219 c9				ret 
e21a			 
e21a			; ascii cls  
e21a			 
e21a 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e21e			 
e21e			; write the frame buffer given in hl to hardware  
e21e			write_display: 
e21e			 
e21e			API: equ 0 
e21e			 
e21e			if API 
e21e				push bc 
e21e				ld b, 4 
e21e			 
e21e			        ld (display_write_tmp), hl 	  
e21e			 
e21e				; clear and home cursor 
e21e			 
e21e				ld c, 6 
e21e				ld de, .cls 
e21e				rst $30 
e21e			 
e21e			 
e21e			.writeln: 
e21e			 
e21e				ld de, (display_write_tmp) 
e21e				ld c, 6 
e21e				rst $30 
e21e				ld c, 7 
e21e				rst $30 
e21e			 
e21e				ld hl, (display_write_tmp) 
e21e				ld de, display_cols 
e21e				add hl,de 
e21e				ld (display_write_tmp),hl 
e21e			 
e21e				djnz  .writeln 
e21e			 
e21e				pop bc 
e21e			 
e21e			 
e21e				ret 
e21e			endif 
e21e e5				push hl 
e21f c5				push bc 
e220 d5				push de 
e221			 
e221			;	ld c, 2 
e221			;	;ld de, .cls 
e221			;	ld a, 27 
e221			;	rst $30 
e221			;	ld c, 2 
e221			;	;ld de, .cls 
e221			;	ld a, '[' 
e221			;	rst $30 
e221			; 
e221			;	ld c, 2 
e221			;	;ld de, .cls 
e221			;	ld a, 'H' 
e221			;	rst $30 
e221			; 
e221			 
e221 0e 02			ld c, 2 
e223				;ld de, .cls 
e223 3e 1b			ld a, 27 
e225 f7				rst $30 
e226			 
e226			 
e226 0e 02			ld c, 2 
e228				;ld de, .cls 
e228 3e 5b			ld a, '[' 
e22a f7				rst $30 
e22b 0e 02			ld c, 2 
e22d				;ld de, .cls 
e22d 3e 32			ld a, '2' 
e22f f7				rst $30 
e230 0e 02			ld c, 2 
e232				;ld de, .cls 
e232 3e 4a			ld a, 'J' 
e234 f7				rst $30 
e235 d1				pop de 
e236 c1				pop bc 
e237 e1				pop hl 
e238			 
e238			 
e238 22 c3 eb		        ld (display_write_tmp), hl 	  
e23b 3e 00			ld a, kLCD_Line1 
e23d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e23d 06 28			ld b, display_cols 
e23f ed 5b c3 eb		ld de, (display_write_tmp) 
e243 cd a1 e2			call write_len_string 
e246				 
e246			 
e246 e5			push hl 
e247 d5			push de 
e248 c5			push bc 
e249 0e 07			ld c, 7 
e24b f7				rst $30 
e24c c1			pop bc 
e24d d1			pop de 
e24e e1			pop hl 
e24f			 
e24f				 
e24f 2a c3 eb			ld hl, (display_write_tmp) 
e252 11 28 00			ld de, display_cols 
e255 19				add hl,de 
e256 22 c3 eb			ld (display_write_tmp),hl 
e259			 
e259				 
e259 3e 28			ld a, kLCD_Line2 
e25b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e25b 06 28			ld b, display_cols 
e25d ed 5b c3 eb		ld de, (display_write_tmp) 
e261 cd a1 e2			call write_len_string 
e264				 
e264 2a c3 eb			ld hl, (display_write_tmp) 
e267 11 28 00			ld de, display_cols 
e26a 19				add hl,de 
e26b 22 c3 eb			ld (display_write_tmp),hl 
e26e			 
e26e e5			push hl 
e26f d5			push de 
e270 c5			push bc 
e271 0e 07			ld c, 7 
e273 f7				rst $30 
e274 c1			pop bc 
e275 d1			pop de 
e276 e1			pop hl 
e277			 
e277				 
e277 3e 50			ld a, kLCD_Line3 
e279			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e279 06 28			ld b, display_cols 
e27b ed 5b c3 eb		ld de, (display_write_tmp) 
e27f cd a1 e2			call write_len_string 
e282				 
e282 2a c3 eb			ld hl, (display_write_tmp) 
e285 11 28 00			ld de, display_cols 
e288 19				add hl,de 
e289 22 c3 eb			ld (display_write_tmp),hl 
e28c			 
e28c e5			push hl 
e28d d5			push de 
e28e c5			push bc 
e28f 0e 07			ld c, 7 
e291 f7				rst $30 
e292 c1			pop bc 
e293 d1			pop de 
e294 e1			pop hl 
e295			 
e295				 
e295 3e 78			ld a, kLCD_Line4 
e297			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e297 06 28			ld b, display_cols 
e299 ed 5b c3 eb		ld de, (display_write_tmp) 
e29d cd a1 e2			call write_len_string 
e2a0 c9					ret 
e2a1			 
e2a1			 
e2a1				; write out a fixed length string given in b from de 
e2a1			 
e2a1 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e2a2 cd 14 e2		            CALL fLCD_Data      ;Write character to display 
e2a5 13				inc de 
e2a6 10 f9			djnz write_len_string 
e2a8 c9				ret 
e2a9			 
e2a9			 
e2a9			; eof 
# End of file firmware_serial_display.asm
e2a9			;include "firmware_key_5x10.asm" 
e2a9			;;include "firmware_key_4x10.asm" 
e2a9			include "firmware_key_serial.asm" 
e2a9			; Serial keyboard interface for SC114 
e2a9			 
e2a9			key_init: 
e2a9				; no init as handled by the SCM bios 
e2a9 c9				ret 
e2aa			 
e2aa			 
e2aa			cin_wait: 
e2aa			;	ld a, 0 
e2aa			;	ret 
e2aa			 
e2aa				;in a,(SC114_SIO_1_IN) 
e2aa			        ; Use SCM API to get from whatever console device we are using 
e2aa c5				push bc 
e2ab 0e 01			ld c, $01 
e2ad f7				rst $30 
e2ae c1				pop bc 
e2af c9				ret 
e2b0			 
e2b0			cinndb: 	 
e2b0			cin: 
e2b0			 
e2b0			 
e2b0 c5				push bc 
e2b1			 
e2b1				; any key waiting to process? 
e2b1 0e 03			ld c, $03 
e2b3 f7				rst $30 
e2b4 28 05			jr z, .cin_skip 
e2b6			 
e2b6				; yep, get it 
e2b6			 
e2b6 0e 01			ld c, $01 
e2b8 f7				rst $30 
e2b9 c1				pop bc 
e2ba c9				ret 
e2bb			.cin_skip: 
e2bb 3e 00			ld a, 0 
e2bd c1				pop bc 
e2be c9				ret 
e2bf			 
e2bf			 
e2bf			 
e2bf			 
# End of file firmware_key_serial.asm
e2bf			endofcode:  
e2bf			baseram:  
e2bf 00				nop 
e2c0			 
e2c0			heap_start: equ baseram+15  ; Starting address of heap 
e2c0			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e2c0			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e2c0			;VDU:  EQU     endofcode           ; BASIC Work space 
e2c0			; eof 
e2c0			 
# End of file os_mega_sc114.asm
e2c0
