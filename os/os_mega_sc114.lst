# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 1f 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 offsets for settings  
8003			  
8003			; if set then skip prompt for start up and accept all  
8003			  
8003			STORE_0_QUICKSTART: equ $25  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
8003			  
8003			hardware_config: equ key_face_held - 10  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_config - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003				  
8003			  
8003					;ld a, 0  
8003					;ld (hardware_diag), a  
8003			  
8003					; clear all the buffers  
8003			  
8003 21 16 ed				ld hl, display_fb1  
8006 22 d2 eb				ld (display_fb_active), hl  
8009			  
8009 cd 4e 89				call clear_display  
800c			  
800c 21 d4 eb				ld hl, display_fb2  
800f 22 d2 eb				ld (display_fb_active), hl  
8012			  
8012 cd 4e 89				call clear_display  
8015			  
8015					; init primary frame buffer area  
8015 21 b7 ed				ld hl, display_fb0  
8018 22 d2 eb				ld (display_fb_active), hl  
801b			  
801b cd 4e 89				call clear_display  
801e			  
801e			  
801e cd 33 d8				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8021			  
8021 cd d5 d8			call key_init  
8024 cd 86 80			call storage_init  
8027			  
8027				; setup malloc functions  
8027			  
8027				if MALLOC_1  
8027 cd 1e 90				call  heap_init  
802a				endif  
802a				if MALLOC_4  
802a					call  heap_init  
802a				endif  
802a			  
802a				; init sound hardware if present  
802a			  
802a				if SOUND_ENABLE  
802a					call sound_init  
802a				endif  
802a			  
802a				; lcd test sequence  
802a					  
802a cd 71 89			call update_display  
802d cd cb 88			call delay1s  
8030 3e 2b			ld a,'+'  
8032 cd 53 89			call fill_display  
8035 cd 71 89			call update_display  
8038 cd cb 88			call delay1s  
803b 3e 2a			ld a,'*'  
803d cd 53 89			call fill_display  
8040 cd 71 89			call update_display  
8043 cd cb 88			call delay1s  
8046 3e 2d			ld a,'-'  
8048 cd 53 89			call fill_display  
804b cd 71 89			call update_display  
804e cd cb 88			call delay1s  
8051			  
8051			; boot splash screen  
8051			if display_cols == 20	  
8051			        ld a, display_row_1    
8051			else  
8051 3e 0a		        ld a, display_row_1 +10   
8053			endif  
8053 11 52 95			ld de, prom_bootmsg  
8056 cd 61 89			call str_at_display  
8059 cd 71 89			call update_display  
805c			  
805c			  
805c cd cb 88			call delay1s  
805f cd cb 88			call delay1s  
8062			if display_cols == 20	  
8062			            LD   A, display_row_3+2  
8062			else  
8062 3e 5c		            LD   A, display_row_3+12  
8064			endif  
8064 11 67 95			ld de, prom_bootmsg1  
8067 cd 61 89			call str_at_display  
806a cd 71 89			call update_display  
806d cd cb 88			call delay1s  
8070 cd cb 88			call delay1s  
8073			  
8073			;	ld a, display_row_4+3  
8073			;	ld de, bootmsg2  
8073			;	call str_at_display  
8073			;	call update_display  
8073			;	call delay1s  
8073			;	call delay1s  
8073			  
8073			; debug mark setup  
8073			  
8073 3e 5f		ld a, '_'  
8075 32 71 ee		ld (debug_mark),a  
8078 32 72 ee		ld (debug_mark+1),a  
807b 32 73 ee		ld (debug_mark+2),a  
807e 3e 00		ld a,0  
8080 32 74 ee		ld (debug_mark+3),a  
8083			  
8083 c9					ret  
8084			  
8084			  
8084			;bootmsg2:	db "Firmware v0.1",0  
8084			  
8084			; a 4x20 lcd  
8084			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
8084			  
8084			;if display_cols == 20  
8084			;	include "firmware_lcd_4x20.asm"  
8084			;endif  
8084			  
8084			;if display_cols == 40  
8084			;	include "firmware_lcd_4x40.asm"  
8084			;endif  
8084			  
8084			;  
8084			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
8084			; TODO abstract the bit bang video out interface for dual display  
8084			; TODO wire video out to tx pin on rc2014 bus  
8084			  
8084			; must supply cin, and cin_wait for low level hardware abstraction   
8084			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
8084			; test scancode  
8084			  
8084			;;;;;  
8084			;;;  
8084			; Moved out to mini and maxi versions  
8084			;  
8084			; include "firmware_key_4x4.asm"  
8084			; using existing 4 wire x 4 resistor array for input  
8084			;include "firmware_key_4x10.asm"  
8084			; need to mod the board for 5 rows due to resistor array  
8084			;include "firmware_key_5x10.asm"  
8084			  
8084			; storage hardware interface  
8084			  
8084			; use microchip serial eeprom for storage  
8084			  
8084			  
8084			if STORAGE_SE  
8084				include "firmware_spi.asm"  
8084				include "firmware_seeprom.asm"  
8084			else  
8084			   ; create some stubs for the labels  
8084 c9			se_readbyte: ret  
8085 c9			se_writebyte: ret  
8086 c9			storage_init: ret  
8087			  
8087			endif  
8087			  
8087			; use cf card for storage - throwing timeout errors. Hardware or software?????  
8087			;include "firmware_cf.asm"  
8087			  
8087			; load up high level storage hardward abstractions  
8087			include "firmware_storage.asm"  
8087			 
8087			; persisent storage hardware abstraction layer  
8087			 
8087			 
8087			 
8087			; Block 0 on storage is a config state 
8087			 
8087			 
8087			 
8087			; TODO add read phy block and write phy block functions 
8087			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
8087			 
8087			; Abstraction layer  
8087			 
8087			; Logocial block size is same size as physical size - using tape concept 
8087			 
8087			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
8087			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
8087			 
8087			 
8087			 
8087			; Filesystem layout (Logical layout) 
8087			; 
8087			; Block 0 - Bank config  
8087			; 
8087			;      Byte - 0 file id counter 
8087			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8087			;      Byte - 3-20 zero terminated bank label 
8087			; 
8087			; Block 1 > File storage 
8087			; 
8087			;      Byte 0 file id    - block 0 file details 
8087			;      Byte 1 block id - block 0 is file  
8087			;            Byte 2-15 - File name 
8087			; 
8087			;       - to end of block data 
8087			; 
8087			 
8087			; Get ID for the file named in pointer held HL 
8087			; Returns ID in HL = 255 if no file found 
8087			 
8087			storage_getid: 
8087			 
8087 22 5a eb			ld (store_tmp1), hl 
808a			 
808a				if DEBUG_STORESE 
808a					DMARK "SGI" 
808a f5				push af  
808b 3a 9f 80			ld a, (.dmark)  
808e 32 71 ee			ld (debug_mark),a  
8091 3a a0 80			ld a, (.dmark+1)  
8094 32 72 ee			ld (debug_mark+1),a  
8097 3a a1 80			ld a, (.dmark+2)  
809a 32 73 ee			ld (debug_mark+2),a  
809d 18 03			jr .pastdmark  
809f ..			.dmark: db "SGI"  
80a2 f1			.pastdmark: pop af  
80a3			endm  
# End of macro DMARK
80a3					CALLMONITOR 
80a3 cd 7c 93			call break_point_state  
80a6				endm  
# End of macro CALLMONITOR
80a6				endif 
80a6				; get block 0 and set counter for number of files to scan 
80a6			 
80a6 cd 11 82			call storage_get_block_0 
80a9			 
80a9 3a 5c eb			ld a, (store_page) 
80ac 47				ld b, a 
80ad			 
80ad				; get extent 0 of each file id 
80ad			 
80ad				if DEBUG_STORESE 
80ad					DMARK "SGc" 
80ad f5				push af  
80ae 3a c2 80			ld a, (.dmark)  
80b1 32 71 ee			ld (debug_mark),a  
80b4 3a c3 80			ld a, (.dmark+1)  
80b7 32 72 ee			ld (debug_mark+1),a  
80ba 3a c4 80			ld a, (.dmark+2)  
80bd 32 73 ee			ld (debug_mark+2),a  
80c0 18 03			jr .pastdmark  
80c2 ..			.dmark: db "SGc"  
80c5 f1			.pastdmark: pop af  
80c6			endm  
# End of macro DMARK
80c6					CALLMONITOR 
80c6 cd 7c 93			call break_point_state  
80c9				endm  
# End of macro CALLMONITOR
80c9				endif 
80c9 60			.getloop:	ld h, b 
80ca 2e 00				ld l, 0 
80cc c5					push bc 
80cd			 
80cd 11 5c eb				ld de, store_page 
80d0				if DEBUG_STORESE 
80d0					DMARK "SGr" 
80d0 f5				push af  
80d1 3a e5 80			ld a, (.dmark)  
80d4 32 71 ee			ld (debug_mark),a  
80d7 3a e6 80			ld a, (.dmark+1)  
80da 32 72 ee			ld (debug_mark+1),a  
80dd 3a e7 80			ld a, (.dmark+2)  
80e0 32 73 ee			ld (debug_mark+2),a  
80e3 18 03			jr .pastdmark  
80e5 ..			.dmark: db "SGr"  
80e8 f1			.pastdmark: pop af  
80e9			endm  
# End of macro DMARK
80e9					CALLMONITOR 
80e9 cd 7c 93			call break_point_state  
80ec				endm  
# End of macro CALLMONITOR
80ec				endif 
80ec cd b9 86				call storage_read 
80ef cd a4 8b				call ishlzero 
80f2 28 2d				jr z, .gap 
80f4					 
80f4					; have a file name read. Is it one we want. 
80f4			 
80f4 2a 5a eb				ld hl, (store_tmp1) 
80f7 11 5f eb				ld de, store_page+3   ; file name 
80fa			 
80fa				if DEBUG_STORESE 
80fa					DMARK "SGc" 
80fa f5				push af  
80fb 3a 0f 81			ld a, (.dmark)  
80fe 32 71 ee			ld (debug_mark),a  
8101 3a 10 81			ld a, (.dmark+1)  
8104 32 72 ee			ld (debug_mark+1),a  
8107 3a 11 81			ld a, (.dmark+2)  
810a 32 73 ee			ld (debug_mark+2),a  
810d 18 03			jr .pastdmark  
810f ..			.dmark: db "SGc"  
8112 f1			.pastdmark: pop af  
8113			endm  
# End of macro DMARK
8113					CALLMONITOR 
8113 cd 7c 93			call break_point_state  
8116				endm  
# End of macro CALLMONITOR
8116				endif 
8116 cd 11 90				call strcmp 
8119 20 06				jr nz, .gap   ; not this one 
811b			 
811b c1				        pop bc 
811c			 
811c 26 00				ld h, 0 
811e 68					ld l, b 
811f 18 22				jr .getdone 
8121						 
8121			 
8121			 
8121			 
8121			.gap: 
8121				if DEBUG_STORESE 
8121					DMARK "SGg" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 71 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 72 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 73 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGg"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 7c 93			call break_point_state  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d			 
813d c1					pop bc 
813e 10 89				djnz .getloop 
8140 21 ff 00				ld hl, 255 
8143			.getdone: 
8143			 
8143				if DEBUG_STORESE 
8143					DMARK "SGe" 
8143 f5				push af  
8144 3a 58 81			ld a, (.dmark)  
8147 32 71 ee			ld (debug_mark),a  
814a 3a 59 81			ld a, (.dmark+1)  
814d 32 72 ee			ld (debug_mark+1),a  
8150 3a 5a 81			ld a, (.dmark+2)  
8153 32 73 ee			ld (debug_mark+2),a  
8156 18 03			jr .pastdmark  
8158 ..			.dmark: db "SGe"  
815b f1			.pastdmark: pop af  
815c			endm  
# End of macro DMARK
815c					CALLMONITOR 
815c cd 7c 93			call break_point_state  
815f				endm  
# End of macro CALLMONITOR
815f				endif 
815f			 
815f c9				ret 
8160			 
8160			 
8160			 
8160			 
8160			 
8160			 
8160			 
8160			 
8160			; Read Block 
8160			; ---------- 
8160			; 
8160			; With current bank 
8160			;  
8160			; Get block number to read 
8160			; Load physical blocks starting at start block into buffer 
8160			 
8160			; de points to buffer to use 
8160			; hl holds logical block number  
8160			 
8160			storage_read_block: 
8160			 
8160				; TODO bank selection 
8160			 
8160				; for each of the physical blocks read it into the buffer 
8160 06 40			ld b, STORE_BLOCK_PHY 
8162			 
8162				if DEBUG_STORESE 
8162 d5					push de 
8163				endif 
8163				 
8163			.rl1:    
8163			 
8163				; read physical block at hl into de 
8163			        ; increment hl and de to next read position on exit 
8163			 
8163 e5				push hl 
8164 d5				push de	 
8165 c5				push bc 
8166			;	if DEBUG_STORESE 
8166			;		push af 
8166			;		ld a, 'R' 
8166			;		ld (debug_mark),a 
8166			;		pop af 
8166			;		CALLMONITOR 
8166			;	endif 
8166 cd 84 80			call se_readbyte 
8169			;	if DEBUG_STORESE 
8169			;		ld a,(spi_portbyte) 
8169			;		ld l, a 
8169			;		push af 
8169			;		ld a, '1' 
8169			;		ld (debug_mark),a 
8169			;		pop af 
8169			;		CALLMONITOR 
8169			;	endif 
8169 c1				pop bc 
816a d1				pop de 
816b e1				pop hl 
816c 12				ld (de),a 
816d 23				inc hl 
816e 13				inc de 
816f			 
816f			;	if DEBUG_STORESE 
816f			;		push af 
816f			;		ld a, 'r' 
816f			;		ld (debug_mark),a 
816f			;		pop af 
816f			;		CALLMONITOR 
816f			;	endif 
816f			 
816f 10 f2			djnz .rl1 
8171			 
8171				if DEBUG_STORESE 
8171					DMARK "SRB" 
8171 f5				push af  
8172 3a 86 81			ld a, (.dmark)  
8175 32 71 ee			ld (debug_mark),a  
8178 3a 87 81			ld a, (.dmark+1)  
817b 32 72 ee			ld (debug_mark+1),a  
817e 3a 88 81			ld a, (.dmark+2)  
8181 32 73 ee			ld (debug_mark+2),a  
8184 18 03			jr .pastdmark  
8186 ..			.dmark: db "SRB"  
8189 f1			.pastdmark: pop af  
818a			endm  
# End of macro DMARK
818a d1					pop de 
818b			; 
818b			;		push af 
818b			;		ld a, 'R' 
818b			;		ld (debug_mark),a 
818b			;		pop af 
818b					CALLMONITOR 
818b cd 7c 93			call break_point_state  
818e				endm  
# End of macro CALLMONITOR
818e				endif 
818e c9				ret	 
818f				 
818f			 
818f			; File Size 
818f			; --------- 
818f			; 
818f			;   hl file id 
818f			; 
818f			;  returns in hl the number of blocks 
818f			 
818f			storage_file_size: 
818f 5d				ld e, l 
8190 16 00			ld d, 0 
8192 21 40 00			ld hl, STORE_BLOCK_PHY 
8195					if DEBUG_FORTH_WORDS 
8195						DMARK "SIZ" 
8195 f5				push af  
8196 3a aa 81			ld a, (.dmark)  
8199 32 71 ee			ld (debug_mark),a  
819c 3a ab 81			ld a, (.dmark+1)  
819f 32 72 ee			ld (debug_mark+1),a  
81a2 3a ac 81			ld a, (.dmark+2)  
81a5 32 73 ee			ld (debug_mark+2),a  
81a8 18 03			jr .pastdmark  
81aa ..			.dmark: db "SIZ"  
81ad f1			.pastdmark: pop af  
81ae			endm  
# End of macro DMARK
81ae						CALLMONITOR 
81ae cd 7c 93			call break_point_state  
81b1				endm  
# End of macro CALLMONITOR
81b1					endif 
81b1 cd 93 84			call storage_findnextid 
81b4			 
81b4 cd a4 8b			call ishlzero 
81b7			;	ld a, l 
81b7			;	add h 
81b7			;	cp 0 
81b7 c8				ret z			; block not found so EOF 
81b8			 
81b8 11 5c eb			ld de, store_page 
81bb cd 60 81			call storage_read_block 
81be			 
81be 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
81c1 6f				ld l, a 
81c2 26 00			ld h, 0 
81c4 c9			 	ret 
81c5			 
81c5			 
81c5			; Write Block 
81c5			; ----------- 
81c5			; 
81c5			; With current bank 
81c5			;  
81c5			; Get block number to write 
81c5			; Write physical blocks starting at start block from buffer 
81c5			  
81c5			storage_write_block: 
81c5				; TODO bank selection 
81c5			 
81c5				; for each of the physical blocks read it into the buffer 
81c5 06 40			ld b, STORE_BLOCK_PHY 
81c7			 
81c7				if DEBUG_STORESE 
81c7					DMARK "SWB" 
81c7 f5				push af  
81c8 3a dc 81			ld a, (.dmark)  
81cb 32 71 ee			ld (debug_mark),a  
81ce 3a dd 81			ld a, (.dmark+1)  
81d1 32 72 ee			ld (debug_mark+1),a  
81d4 3a de 81			ld a, (.dmark+2)  
81d7 32 73 ee			ld (debug_mark+2),a  
81da 18 03			jr .pastdmark  
81dc ..			.dmark: db "SWB"  
81df f1			.pastdmark: pop af  
81e0			endm  
# End of macro DMARK
81e0			 
81e0					;push af 
81e0					;ld a, 'W' 
81e0					;ld (debug_mark),a 
81e0					;pop af 
81e0					CALLMONITOR 
81e0 cd 7c 93			call break_point_state  
81e3				endm  
# End of macro CALLMONITOR
81e3				endif 
81e3			 
81e3			; might not be working 
81e3			;	call se_writepage 
81e3			 
81e3			;	ret 
81e3			; 
81e3			 
81e3			 
81e3			 
81e3			.wl1:    
81e3			 
81e3				; read physical block at hl into de 
81e3			        ; increment hl and de to next read position on exit 
81e3			 
81e3 e5				push hl 
81e4 d5				push de	 
81e5 c5				push bc 
81e6 1a				ld a,(de) 
81e7				;if DEBUG_STORESE 
81e7			;		push af 
81e7			;		ld a, 'W' 
81e7			;		ld (debug_mark),a 
81e7			;		pop af 
81e7			;		CALLMONITOR 
81e7			;	endif 
81e7 cd 85 80			call se_writebyte 
81ea			;	call delay250ms 
81ea 00				nop 
81eb 00				nop 
81ec 00				nop 
81ed			;	if DEBUG_STORESE 
81ed			;		push af 
81ed			;		ld a, 'w' 
81ed			;		ld (debug_mark),a 
81ed			;		pop af 
81ed			;		CALLMONITOR 
81ed			;	endif 
81ed c1				pop bc 
81ee d1				pop de 
81ef e1				pop hl 
81f0 23				inc hl 
81f1 13				inc de 
81f2			 
81f2			 
81f2 10 ef			djnz .wl1 
81f4			 
81f4				if DEBUG_STORESE 
81f4					DMARK "SW2" 
81f4 f5				push af  
81f5 3a 09 82			ld a, (.dmark)  
81f8 32 71 ee			ld (debug_mark),a  
81fb 3a 0a 82			ld a, (.dmark+1)  
81fe 32 72 ee			ld (debug_mark+1),a  
8201 3a 0b 82			ld a, (.dmark+2)  
8204 32 73 ee			ld (debug_mark+2),a  
8207 18 03			jr .pastdmark  
8209 ..			.dmark: db "SW2"  
820c f1			.pastdmark: pop af  
820d			endm  
# End of macro DMARK
820d			 
820d					;push af 
820d					;ld a, 'W' 
820d					;ld (debug_mark),a 
820d					;pop af 
820d					CALLMONITOR 
820d cd 7c 93			call break_point_state  
8210				endm  
# End of macro CALLMONITOR
8210				endif 
8210 c9				ret	 
8211			 
8211			; Init bank 
8211			; --------- 
8211			; 
8211			; With current bank 
8211			; 
8211			; Setup block 0 config 
8211			;     Set 0 file id counter 
8211			;     Set formatted byte pattern 
8211			;     Zero out bank label 
8211			;      
8211			; For every logical block write 0-1 byte as null 
8211			 
8211			storage_get_block_0: 
8211			 
8211				; TODO check presence 
8211			 
8211				; get block 0 config 
8211			 
8211 21 00 00			ld hl, 0 
8214 11 5c eb			ld de, store_page 
8217 cd 60 81			call storage_read_block 
821a			 
821a				if DEBUG_STORESE 
821a					DMARK "SB0" 
821a f5				push af  
821b 3a 2f 82			ld a, (.dmark)  
821e 32 71 ee			ld (debug_mark),a  
8221 3a 30 82			ld a, (.dmark+1)  
8224 32 72 ee			ld (debug_mark+1),a  
8227 3a 31 82			ld a, (.dmark+2)  
822a 32 73 ee			ld (debug_mark+2),a  
822d 18 03			jr .pastdmark  
822f ..			.dmark: db "SB0"  
8232 f1			.pastdmark: pop af  
8233			endm  
# End of macro DMARK
8233 11 5c eb				ld de, store_page 
8236			;		push af 
8236			;		ld a, 'i' 
8236			;		ld (debug_mark),a 
8236			;		pop af 
8236					CALLMONITOR 
8236 cd 7c 93			call break_point_state  
8239				endm  
# End of macro CALLMONITOR
8239				endif 
8239			 
8239				; is this area formatted? 
8239			 
8239			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8239 2a 5d eb			ld hl, (store_page+1) 
823c 3e 80			ld a,0x80 
823e bd				cp l 
823f 20 22			jr nz, .ininotformatted 
8241				; do a double check 
8241 3e 27			ld a, 0x27 
8243 bc				cp h 
8244 20 1d			jr nz, .ininotformatted 
8246			 
8246				; formatted then 
8246			 
8246				if DEBUG_STORESE 
8246					DMARK "SB1" 
8246 f5				push af  
8247 3a 5b 82			ld a, (.dmark)  
824a 32 71 ee			ld (debug_mark),a  
824d 3a 5c 82			ld a, (.dmark+1)  
8250 32 72 ee			ld (debug_mark+1),a  
8253 3a 5d 82			ld a, (.dmark+2)  
8256 32 73 ee			ld (debug_mark+2),a  
8259 18 03			jr .pastdmark  
825b ..			.dmark: db "SB1"  
825e f1			.pastdmark: pop af  
825f			endm  
# End of macro DMARK
825f					;push af 
825f					;ld a, 'I' 
825f					;ld (debug_mark),a 
825f					;pop af 
825f					CALLMONITOR 
825f cd 7c 93			call break_point_state  
8262				endm  
# End of macro CALLMONITOR
8262				endif 
8262 c9				ret 
8263			 
8263			.ininotformatted: 
8263				; bank not formatted so poke various bits to make sure 
8263			 
8263				if DEBUG_STORESE 
8263					DMARK "SB2" 
8263 f5				push af  
8264 3a 78 82			ld a, (.dmark)  
8267 32 71 ee			ld (debug_mark),a  
826a 3a 79 82			ld a, (.dmark+1)  
826d 32 72 ee			ld (debug_mark+1),a  
8270 3a 7a 82			ld a, (.dmark+2)  
8273 32 73 ee			ld (debug_mark+2),a  
8276 18 03			jr .pastdmark  
8278 ..			.dmark: db "SB2"  
827b f1			.pastdmark: pop af  
827c			endm  
# End of macro DMARK
827c					;push af 
827c					;ld a, 'f' 
827c					;ld (debug_mark),a 
827c					;pop af 
827c					CALLMONITOR 
827c cd 7c 93			call break_point_state  
827f				endm  
# End of macro CALLMONITOR
827f				endif 
827f			 
827f cd 8e 88			call storage_clear_page 
8282			 
8282 21 5c eb			ld hl, store_page 
8285 3e 00			ld a, 0 
8287				 
8287 77				ld (hl),a   ; reset file counter 
8288			 
8288 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
828b 22 5d eb		 	ld (store_page+1), hl	 
828e			 
828e				; set default label 
828e			 
828e 21 2a 83			ld hl, .defaultbanklabl 
8291 11 5f eb		 	ld de, store_page+3 
8294 01 0f 00			ld bc, 15 
8297 ed b0			ldir 
8299			 
8299				; Append the current bank id 
8299 21 68 eb			ld hl, store_page+3+9 
829c 3a 41 eb			ld a, (spi_device_id) 
829f 77				ld (hl), a 
82a0			 
82a0				; save default page 0 
82a0			 
82a0 21 00 00			ld hl, 0 
82a3 11 5c eb			ld de, store_page 
82a6				if DEBUG_STORESE 
82a6					DMARK "SB3" 
82a6 f5				push af  
82a7 3a bb 82			ld a, (.dmark)  
82aa 32 71 ee			ld (debug_mark),a  
82ad 3a bc 82			ld a, (.dmark+1)  
82b0 32 72 ee			ld (debug_mark+1),a  
82b3 3a bd 82			ld a, (.dmark+2)  
82b6 32 73 ee			ld (debug_mark+2),a  
82b9 18 03			jr .pastdmark  
82bb ..			.dmark: db "SB3"  
82be f1			.pastdmark: pop af  
82bf			endm  
# End of macro DMARK
82bf			;		push af 
82bf			;		ld a, 'F' 
82bf			;		ld (debug_mark),a 
82bf			;		pop af 
82bf					CALLMONITOR 
82bf cd 7c 93			call break_point_state  
82c2				endm  
# End of macro CALLMONITOR
82c2				endif 
82c2 cd c5 81			call storage_write_block 
82c5				if DEBUG_STORESE 
82c5					DMARK "SB4" 
82c5 f5				push af  
82c6 3a da 82			ld a, (.dmark)  
82c9 32 71 ee			ld (debug_mark),a  
82cc 3a db 82			ld a, (.dmark+1)  
82cf 32 72 ee			ld (debug_mark+1),a  
82d2 3a dc 82			ld a, (.dmark+2)  
82d5 32 73 ee			ld (debug_mark+2),a  
82d8 18 03			jr .pastdmark  
82da ..			.dmark: db "SB4"  
82dd f1			.pastdmark: pop af  
82de			endm  
# End of macro DMARK
82de			;		push af 
82de			;		ld a, '>' 
82de			;		ld (debug_mark),a 
82de			;		pop af 
82de					CALLMONITOR 
82de cd 7c 93			call break_point_state  
82e1				endm  
# End of macro CALLMONITOR
82e1				endif 
82e1			 
82e1 00				nop 
82e2 00				nop 
82e3 00				nop 
82e4			 
82e4				; now set 0 in every page to mark as a free block 
82e4			 
82e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82e6 21 40 00			ld hl, STORE_BLOCK_PHY 
82e9			 
82e9 3e 00		.setmark1:   	ld a,0 
82eb e5					push hl 
82ec c5					push bc 
82ed cd 85 80				call se_writebyte 
82f0 3e 0a			ld a, 10 
82f2 cd b0 88			call aDelayInMS 
82f5 23				inc hl 
82f6 cd 85 80				call se_writebyte 
82f9 3e 0a			ld a, 10 
82fb cd b0 88			call aDelayInMS 
82fe 2b				dec hl 
82ff c1					pop bc 
8300 e1					pop hl 
8301 3e 40				ld a, STORE_BLOCK_PHY 
8303 cd 7b 8b				call addatohl 
8306 10 e1				djnz .setmark1 
8308			 
8308 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830a 3e 00		.setmark2:   	ld a,0 
830c e5					push hl 
830d c5					push bc 
830e cd 85 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd b0 88			call aDelayInMS 
8316 23				inc hl 
8317 cd 85 80				call se_writebyte 
831a 3e 0a			ld a, 10 
831c cd b0 88			call aDelayInMS 
831f 2b				dec hl 
8320 c1					pop bc 
8321 e1					pop hl 
8322 3e 40				ld a, STORE_BLOCK_PHY 
8324 cd 7b 8b				call addatohl 
8327 10 e1				djnz .setmark2 
8329			 
8329					 
8329			 
8329			 
8329 c9				ret 
832a			 
832a			 
832a			 
832a			 
832a .. 00		.defaultbanklabl:   db "BankLabel_",0 
8335			 
8335			 
8335			 
8335			; Label Bank 
8335			; ---------- 
8335			; 
8335			; With current bank 
8335			; Read block 0 
8335			; Set label 
8335			; Write block 0 
8335			 
8335			; label str pointer in hl 
8335			 
8335			storage_label:     
8335			 
8335				if DEBUG_STORESE 
8335					DMARK "LBL" 
8335 f5				push af  
8336 3a 4a 83			ld a, (.dmark)  
8339 32 71 ee			ld (debug_mark),a  
833c 3a 4b 83			ld a, (.dmark+1)  
833f 32 72 ee			ld (debug_mark+1),a  
8342 3a 4c 83			ld a, (.dmark+2)  
8345 32 73 ee			ld (debug_mark+2),a  
8348 18 03			jr .pastdmark  
834a ..			.dmark: db "LBL"  
834d f1			.pastdmark: pop af  
834e			endm  
# End of macro DMARK
834e					CALLMONITOR 
834e cd 7c 93			call break_point_state  
8351				endm  
# End of macro CALLMONITOR
8351				endif 
8351			 
8351 e5				push hl 
8352			 
8352 cd 11 82			call storage_get_block_0 
8355			 
8355				; set default label 
8355			 
8355 e1				pop hl 
8356			 
8356 11 5f eb		 	ld de, store_page+3 
8359 01 0f 00			ld bc, 15 
835c				if DEBUG_STORESE 
835c					DMARK "LB3" 
835c f5				push af  
835d 3a 71 83			ld a, (.dmark)  
8360 32 71 ee			ld (debug_mark),a  
8363 3a 72 83			ld a, (.dmark+1)  
8366 32 72 ee			ld (debug_mark+1),a  
8369 3a 73 83			ld a, (.dmark+2)  
836c 32 73 ee			ld (debug_mark+2),a  
836f 18 03			jr .pastdmark  
8371 ..			.dmark: db "LB3"  
8374 f1			.pastdmark: pop af  
8375			endm  
# End of macro DMARK
8375					CALLMONITOR 
8375 cd 7c 93			call break_point_state  
8378				endm  
# End of macro CALLMONITOR
8378				endif 
8378 ed b0			ldir 
837a				; save default page 0 
837a			 
837a 21 00 00			ld hl, 0 
837d 11 5c eb			ld de, store_page 
8380				if DEBUG_STORESE 
8380					DMARK "LBW" 
8380 f5				push af  
8381 3a 95 83			ld a, (.dmark)  
8384 32 71 ee			ld (debug_mark),a  
8387 3a 96 83			ld a, (.dmark+1)  
838a 32 72 ee			ld (debug_mark+1),a  
838d 3a 97 83			ld a, (.dmark+2)  
8390 32 73 ee			ld (debug_mark+2),a  
8393 18 03			jr .pastdmark  
8395 ..			.dmark: db "LBW"  
8398 f1			.pastdmark: pop af  
8399			endm  
# End of macro DMARK
8399					CALLMONITOR 
8399 cd 7c 93			call break_point_state  
839c				endm  
# End of macro CALLMONITOR
839c				endif 
839c cd c5 81			call storage_write_block 
839f			 
839f c9				ret 
83a0			 
83a0			 
83a0			 
83a0			; Read Block 0 - Config 
83a0			; --------------------- 
83a0			; 
83a0			; With current bank 
83a0			; Call presence test 
83a0			;    If not present format/init bank  
83a0			; Read block 0  
83a0			;  
83a0			 
83a0			 
83a0			; Dir 
83a0			; --- 
83a0			; 
83a0			; With current bank 
83a0			; Load Block 0 Config 
83a0			; Get max file id number 
83a0			; For each logical block 
83a0			;    Read block read byte 2 
83a0			;      if first block of file 
83a0			;         Display file name 
83a0			;         Display type flags for file 
83a0			;        
83a0			 
83a0			; moving to words as this requires stack control 
83a0			 
83a0			 
83a0			; Delete File 
83a0			; ----------- 
83a0			; 
83a0			; With current bank 
83a0			; 
83a0			; Load Block 0 Config 
83a0			; Get max file id number 
83a0			; For each logical block 
83a0			;    Read block file id 
83a0			;      If first block of file and dont have file id 
83a0			;         if file to delete 
83a0			;         Save file id 
83a0			;         Null file id 
83a0			;         Write this block back 
83a0			;      If file id is one saved 
83a0			;         Null file id 
83a0			;         Write this block back 
83a0			 
83a0			 
83a0			.se_done: 
83a0 e1				pop hl 
83a1 c9				ret 
83a2			 
83a2			storage_erase: 
83a2			 
83a2				; hl contains the file id 
83a2			 
83a2 5d				ld e, l 
83a3 16 00			ld d, 0 
83a5 21 40 00			ld hl, STORE_BLOCK_PHY 
83a8					if DEBUG_FORTH_WORDS 
83a8						DMARK "ERA" 
83a8 f5				push af  
83a9 3a bd 83			ld a, (.dmark)  
83ac 32 71 ee			ld (debug_mark),a  
83af 3a be 83			ld a, (.dmark+1)  
83b2 32 72 ee			ld (debug_mark+1),a  
83b5 3a bf 83			ld a, (.dmark+2)  
83b8 32 73 ee			ld (debug_mark+2),a  
83bb 18 03			jr .pastdmark  
83bd ..			.dmark: db "ERA"  
83c0 f1			.pastdmark: pop af  
83c1			endm  
# End of macro DMARK
83c1						CALLMONITOR 
83c1 cd 7c 93			call break_point_state  
83c4				endm  
# End of macro CALLMONITOR
83c4					endif 
83c4 cd 93 84			call storage_findnextid 
83c7 cd a4 8b			call ishlzero 
83ca c8				ret z 
83cb			 
83cb e5				push hl 
83cc			 
83cc				; TODO check file not found 
83cc			 
83cc 11 5c eb			ld de, store_page 
83cf cd 60 81			call storage_read_block 
83d2			 
83d2 cd a4 8b			call ishlzero 
83d5 ca a0 83			jp z,.se_done 
83d8			 
83d8					if DEBUG_FORTH_WORDS 
83d8						DMARK "ER1" 
83d8 f5				push af  
83d9 3a ed 83			ld a, (.dmark)  
83dc 32 71 ee			ld (debug_mark),a  
83df 3a ee 83			ld a, (.dmark+1)  
83e2 32 72 ee			ld (debug_mark+1),a  
83e5 3a ef 83			ld a, (.dmark+2)  
83e8 32 73 ee			ld (debug_mark+2),a  
83eb 18 03			jr .pastdmark  
83ed ..			.dmark: db "ER1"  
83f0 f1			.pastdmark: pop af  
83f1			endm  
# End of macro DMARK
83f1						CALLMONITOR 
83f1 cd 7c 93			call break_point_state  
83f4				endm  
# End of macro CALLMONITOR
83f4					endif 
83f4 3a 5c eb			ld a, (store_page)	; get file id 
83f7 32 55 eb			ld (store_tmpid), a 
83fa			 
83fa 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
83fd 32 54 eb			ld (store_tmpext), a 
8400			 
8400				; wipe file header 
8400			 
8400 e1				pop hl 
8401 3e 00			ld a, 0 
8403 32 5c eb			ld (store_page), a 
8406 32 5d eb			ld (store_page+1),a 
8409 11 5c eb			ld de, store_page 
840c					if DEBUG_FORTH_WORDS 
840c						DMARK "ER2" 
840c f5				push af  
840d 3a 21 84			ld a, (.dmark)  
8410 32 71 ee			ld (debug_mark),a  
8413 3a 22 84			ld a, (.dmark+1)  
8416 32 72 ee			ld (debug_mark+1),a  
8419 3a 23 84			ld a, (.dmark+2)  
841c 32 73 ee			ld (debug_mark+2),a  
841f 18 03			jr .pastdmark  
8421 ..			.dmark: db "ER2"  
8424 f1			.pastdmark: pop af  
8425			endm  
# End of macro DMARK
8425						CALLMONITOR 
8425 cd 7c 93			call break_point_state  
8428				endm  
# End of macro CALLMONITOR
8428					endif 
8428 cd c5 81			call storage_write_block 
842b			 
842b			 
842b				; wipe file extents 
842b			 
842b 3a 54 eb			ld a, (store_tmpext) 
842e 47				ld b, a 
842f			 
842f			.eraext:	  
842f c5				push bc 
8430			 
8430 21 40 00			ld hl, STORE_BLOCK_PHY 
8433 3a 55 eb			ld a,(store_tmpid) 
8436 5f				ld e, a 
8437 50				ld d, b	 
8438					if DEBUG_FORTH_WORDS 
8438						DMARK "ER3" 
8438 f5				push af  
8439 3a 4d 84			ld a, (.dmark)  
843c 32 71 ee			ld (debug_mark),a  
843f 3a 4e 84			ld a, (.dmark+1)  
8442 32 72 ee			ld (debug_mark+1),a  
8445 3a 4f 84			ld a, (.dmark+2)  
8448 32 73 ee			ld (debug_mark+2),a  
844b 18 03			jr .pastdmark  
844d ..			.dmark: db "ER3"  
8450 f1			.pastdmark: pop af  
8451			endm  
# End of macro DMARK
8451						CALLMONITOR 
8451 cd 7c 93			call break_point_state  
8454				endm  
# End of macro CALLMONITOR
8454					endif 
8454 cd 93 84			call storage_findnextid 
8457 cd a4 8b			call ishlzero 
845a ca a0 83			jp z,.se_done 
845d			 
845d e5				push hl 
845e 11 5c eb			ld de, store_page 
8461 cd 60 81			call storage_read_block 
8464			 
8464				; free block	 
8464			 
8464 3e 00			ld a, 0 
8466 32 5c eb			ld (store_page), a 
8469 32 5d eb			ld (store_page+1),a 
846c 11 5c eb			ld de, store_page 
846f e1				pop hl 
8470					if DEBUG_FORTH_WORDS 
8470						DMARK "ER4" 
8470 f5				push af  
8471 3a 85 84			ld a, (.dmark)  
8474 32 71 ee			ld (debug_mark),a  
8477 3a 86 84			ld a, (.dmark+1)  
847a 32 72 ee			ld (debug_mark+1),a  
847d 3a 87 84			ld a, (.dmark+2)  
8480 32 73 ee			ld (debug_mark+2),a  
8483 18 03			jr .pastdmark  
8485 ..			.dmark: db "ER4"  
8488 f1			.pastdmark: pop af  
8489			endm  
# End of macro DMARK
8489						CALLMONITOR 
8489 cd 7c 93			call break_point_state  
848c				endm  
# End of macro CALLMONITOR
848c					endif 
848c cd c5 81			call storage_write_block 
848f			 
848f c1				pop bc 
8490 10 9d			djnz .eraext 
8492			 
8492 c9				ret 
8493			 
8493			 
8493			; Find Free Block 
8493			; --------------- 
8493			; 
8493			; With current bank 
8493			;  
8493			; From given starting logical block 
8493			;    Read block  
8493			;    If no file id 
8493			;         Return block id 
8493			 
8493			 
8493			; hl starting page number 
8493			; hl contains free page number or zero if no pages free 
8493			; e contains the file id to locate 
8493			; d contains the block number 
8493			 
8493			; TODO change to find file id and use zero for free block 
8493			 
8493			storage_findnextid: 
8493			 
8493				; now locate first 0 page to mark as a free block 
8493			 
8493 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8495			;	ld hl, STORE_BLOCK_PHY 
8495			 
8495					if DEBUG_FORTH_WORDS 
8495					DMARK "FNI" 
8495 f5				push af  
8496 3a aa 84			ld a, (.dmark)  
8499 32 71 ee			ld (debug_mark),a  
849c 3a ab 84			ld a, (.dmark+1)  
849f 32 72 ee			ld (debug_mark+1),a  
84a2 3a ac 84			ld a, (.dmark+2)  
84a5 32 73 ee			ld (debug_mark+2),a  
84a8 18 03			jr .pastdmark  
84aa ..			.dmark: db "FNI"  
84ad f1			.pastdmark: pop af  
84ae			endm  
# End of macro DMARK
84ae						CALLMONITOR 
84ae cd 7c 93			call break_point_state  
84b1				endm  
# End of macro CALLMONITOR
84b1					endif 
84b1			.ff1:   	 
84b1 e5					push hl 
84b2 c5					push bc 
84b3 d5					push de 
84b4 cd 84 80				call se_readbyte 
84b7 5f					ld e,a 
84b8 23					inc hl 
84b9 cd 84 80				call se_readbyte 
84bc 57					ld d, a 
84bd e1					pop hl 
84be e5					push hl 
84bf cd 99 8b				call cmp16 
84c2 28 49				jr z, .fffound 
84c4			 
84c4 d1					pop de 
84c5 c1					pop bc 
84c6 e1					pop hl 
84c7			 
84c7					; is found? 
84c7					;cp e 
84c7					;ret z 
84c7			 
84c7 3e 40				ld a, STORE_BLOCK_PHY 
84c9 cd 7b 8b				call addatohl 
84cc 10 e3				djnz .ff1 
84ce			 
84ce 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84d0			.ff2:   	 
84d0			 
84d0 e5					push hl 
84d1 c5					push bc 
84d2 d5					push de 
84d3 cd 84 80				call se_readbyte 
84d6 5f					ld e,a 
84d7 23					inc hl 
84d8 cd 84 80				call se_readbyte 
84db 57					ld d, a 
84dc			 
84dc e1					pop hl 
84dd e5					push hl 
84de cd 99 8b				call cmp16 
84e1 28 2a				jr z, .fffound 
84e3			 
84e3 d1					pop de 
84e4 c1					pop bc 
84e5 e1					pop hl 
84e6					; is found? 
84e6					;cp e 
84e6					;ret z 
84e6			 
84e6 3e 40				ld a, STORE_BLOCK_PHY 
84e8 cd 7b 8b				call addatohl 
84eb 10 e3				djnz .ff2 
84ed			 
84ed			 
84ed					if DEBUG_FORTH_WORDS 
84ed					DMARK "FN-" 
84ed f5				push af  
84ee 3a 02 85			ld a, (.dmark)  
84f1 32 71 ee			ld (debug_mark),a  
84f4 3a 03 85			ld a, (.dmark+1)  
84f7 32 72 ee			ld (debug_mark+1),a  
84fa 3a 04 85			ld a, (.dmark+2)  
84fd 32 73 ee			ld (debug_mark+2),a  
8500 18 03			jr .pastdmark  
8502 ..			.dmark: db "FN-"  
8505 f1			.pastdmark: pop af  
8506			endm  
# End of macro DMARK
8506					;	push af 
8506					;	ld a, 'n' 
8506					;	ld (debug_mark),a 
8506					;	pop af 
8506						CALLMONITOR 
8506 cd 7c 93			call break_point_state  
8509				endm  
# End of macro CALLMONITOR
8509					endif 
8509				; no free marks! 
8509 21 00 00				ld hl, 0 
850c c9				ret 
850d			.fffound: 
850d				 
850d			 
850d d1					pop de 
850e c1					pop bc 
850f e1					pop hl 
8510					if DEBUG_FORTH_WORDS 
8510					DMARK "FNF" 
8510 f5				push af  
8511 3a 25 85			ld a, (.dmark)  
8514 32 71 ee			ld (debug_mark),a  
8517 3a 26 85			ld a, (.dmark+1)  
851a 32 72 ee			ld (debug_mark+1),a  
851d 3a 27 85			ld a, (.dmark+2)  
8520 32 73 ee			ld (debug_mark+2),a  
8523 18 03			jr .pastdmark  
8525 ..			.dmark: db "FNF"  
8528 f1			.pastdmark: pop af  
8529			endm  
# End of macro DMARK
8529					;	push af 
8529					;	ld a, 'n' 
8529					;	ld (debug_mark),a 
8529					;	pop af 
8529						CALLMONITOR 
8529 cd 7c 93			call break_point_state  
852c				endm  
# End of macro CALLMONITOR
852c					endif 
852c c9				ret 
852d			 
852d			 
852d			 
852d			; Free Space 
852d			; ---------- 
852d			; 
852d			; With current bank 
852d			; 
852d			; Set block count to zero 
852d			; Starting with first logical block 
852d			;      Find free block  
852d			;      If block id given, increment block count 
852d			; 
852d			;  
852d			 
852d			 
852d			; hl contains count of free blocks 
852d			 
852d			storage_freeblocks: 
852d			 
852d				; now locate first 0 page to mark as a free block 
852d			 
852d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
852f 21 40 00			ld hl, STORE_BLOCK_PHY 
8532 11 00 00			ld de, 0 
8535			 
8535			.fb1:   	 
8535 e5					push hl 
8536 c5					push bc 
8537 d5					push de 
8538 cd 84 80				call se_readbyte 
853b d1					pop de 
853c c1					pop bc 
853d e1					pop hl 
853e			 
853e					; is free? 
853e fe 00				cp 0 
8540 20 01				jr nz, .ff1cont 
8542 13					inc de 
8543			 
8543			.ff1cont: 
8543			 
8543			 
8543 3e 40				ld a, STORE_BLOCK_PHY 
8545 cd 7b 8b				call addatohl 
8548 10 eb				djnz .fb1 
854a			 
854a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
854c			.fb2:   	 
854c e5					push hl 
854d c5					push bc 
854e d5					push de 
854f cd 84 80				call se_readbyte 
8552 d1					pop de 
8553 c1					pop bc 
8554 e1					pop hl 
8555			 
8555					; is free? 
8555 fe 00				cp 0 
8557 20 01				jr nz, .ff2cont 
8559 13					inc de 
855a			 
855a			.ff2cont: 
855a			 
855a 3e 40				ld a, STORE_BLOCK_PHY 
855c cd 7b 8b				call addatohl 
855f 10 eb				djnz .fb2 
8561			 
8561 eb				ex de, hl 
8562 c9				ret 
8563			 
8563			; Get File ID 
8563			; ----------- 
8563			; 
8563			; With current bank 
8563			;  
8563			; Load Block 0 Config 
8563			; Get max file id number 
8563			; For each logical block 
8563			;    Read block file id 
8563			;      If first block of file and dont have file id 
8563			;         if file get id and exit 
8563			 
8563			 
8563			 
8563			 
8563			; Create File 
8563			; ----------- 
8563			; 
8563			; With current bank  
8563			; Load Block 0 Config 
8563			; Get max file id number 
8563			; Increment file id number 
8563			; Save Config 
8563			; Find free block 
8563			; Set buffer with file name and file id 
8563			; Write buffer to free block  
8563			 
8563			 
8563			; hl point to file name 
8563			; hl returns file id 
8563			 
8563			; file format: 
8563			; byte 0 - file id 
8563			; byte 1 - extent number 
8563			; byte 2-> data 
8563			 
8563			; format for extent number 0: 
8563			; 
8563			; byte 0 - file id 
8563			; byte 1 - extent 0 
8563			; byte 2 - extent count 
8563			; byte 3 -> file name and meta data 
8563			 
8563			 
8563			storage_create: 
8563				if DEBUG_STORESE 
8563					DMARK "SCR" 
8563 f5				push af  
8564 3a 78 85			ld a, (.dmark)  
8567 32 71 ee			ld (debug_mark),a  
856a 3a 79 85			ld a, (.dmark+1)  
856d 32 72 ee			ld (debug_mark+1),a  
8570 3a 7a 85			ld a, (.dmark+2)  
8573 32 73 ee			ld (debug_mark+2),a  
8576 18 03			jr .pastdmark  
8578 ..			.dmark: db "SCR"  
857b f1			.pastdmark: pop af  
857c			endm  
# End of macro DMARK
857c					CALLMONITOR 
857c cd 7c 93			call break_point_state  
857f				endm  
# End of macro CALLMONITOR
857f				endif 
857f			 
857f e5				push hl		; save file name pointer 
8580			 
8580 cd 11 82			call storage_get_block_0 
8583			 
8583 3a 5c eb			ld a,(store_page)	; get current file id 
8586 3c				inc a 
8587 32 5c eb			ld (store_page),a 
858a				 
858a 32 55 eb			ld (store_tmpid),a			; save id 
858d			 
858d 21 00 00			ld hl, 0 
8590 11 5c eb			ld de, store_page 
8593				if DEBUG_STORESE 
8593					DMARK "SCw" 
8593 f5				push af  
8594 3a a8 85			ld a, (.dmark)  
8597 32 71 ee			ld (debug_mark),a  
859a 3a a9 85			ld a, (.dmark+1)  
859d 32 72 ee			ld (debug_mark+1),a  
85a0 3a aa 85			ld a, (.dmark+2)  
85a3 32 73 ee			ld (debug_mark+2),a  
85a6 18 03			jr .pastdmark  
85a8 ..			.dmark: db "SCw"  
85ab f1			.pastdmark: pop af  
85ac			endm  
# End of macro DMARK
85ac					CALLMONITOR 
85ac cd 7c 93			call break_point_state  
85af				endm  
# End of macro CALLMONITOR
85af				endif 
85af cd c5 81			call storage_write_block	 ; save update 
85b2			 
85b2				if DEBUG_STORESE 
85b2 11 5c eb				ld de, store_page 
85b5					DMARK "SCC" 
85b5 f5				push af  
85b6 3a ca 85			ld a, (.dmark)  
85b9 32 71 ee			ld (debug_mark),a  
85bc 3a cb 85			ld a, (.dmark+1)  
85bf 32 72 ee			ld (debug_mark+1),a  
85c2 3a cc 85			ld a, (.dmark+2)  
85c5 32 73 ee			ld (debug_mark+2),a  
85c8 18 03			jr .pastdmark  
85ca ..			.dmark: db "SCC"  
85cd f1			.pastdmark: pop af  
85ce			endm  
# End of macro DMARK
85ce					CALLMONITOR 
85ce cd 7c 93			call break_point_state  
85d1				endm  
# End of macro CALLMONITOR
85d1				endif 
85d1				;  
85d1				 
85d1 21 40 00			ld hl, STORE_BLOCK_PHY 
85d4 11 00 00			ld de, 0 
85d7 cd 93 84			call storage_findnextid 
85da			 
85da 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
85dd			 
85dd				; TODO detect 0 = no spare blocks 
85dd			 
85dd				; hl now contains the free page to use for the file header page 
85dd			 
85dd				if DEBUG_STORESE 
85dd				DMARK "SCF" 
85dd f5				push af  
85de 3a f2 85			ld a, (.dmark)  
85e1 32 71 ee			ld (debug_mark),a  
85e4 3a f3 85			ld a, (.dmark+1)  
85e7 32 72 ee			ld (debug_mark+1),a  
85ea 3a f4 85			ld a, (.dmark+2)  
85ed 32 73 ee			ld (debug_mark+2),a  
85f0 18 03			jr .pastdmark  
85f2 ..			.dmark: db "SCF"  
85f5 f1			.pastdmark: pop af  
85f6			endm  
# End of macro DMARK
85f6					CALLMONITOR 
85f6 cd 7c 93			call break_point_state  
85f9				endm  
# End of macro CALLMONITOR
85f9				endif 
85f9			 
85f9 22 46 eb			ld (store_tmppageid), hl 
85fc				 
85fc 3a 55 eb			ld a,(store_tmpid)    ; get file id 
85ff			;	ld a, (store_filecache)			; save to cache 
85ff			 
85ff 32 5c eb			ld (store_page),a    ; set page id 
8602 3e 00			ld a, 0			 ; extent 0 is file header 
8604 32 5d eb			ld (store_page+1), a   ; set file extent 
8607			 
8607 32 5e eb			ld (store_page+2), a   ; extent count for the file 
860a			 
860a			;	inc hl 		; init block 0 of file 
860a			;	inc hl   		; skip file and extent id 
860a			 ;       ld a, 0 
860a			;	ld (hl),a 
860a			;	ld a, (store_filecache+1)  	; save to cache 
860a			 
860a			;	inc hl    ; file name 
860a				 
860a				 
860a 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
860d				if DEBUG_STORESE 
860d					DMARK "SCc" 
860d f5				push af  
860e 3a 22 86			ld a, (.dmark)  
8611 32 71 ee			ld (debug_mark),a  
8614 3a 23 86			ld a, (.dmark+1)  
8617 32 72 ee			ld (debug_mark+1),a  
861a 3a 24 86			ld a, (.dmark+2)  
861d 32 73 ee			ld (debug_mark+2),a  
8620 18 03			jr .pastdmark  
8622 ..			.dmark: db "SCc"  
8625 f1			.pastdmark: pop af  
8626			endm  
# End of macro DMARK
8626					CALLMONITOR 
8626 cd 7c 93			call break_point_state  
8629				endm  
# End of macro CALLMONITOR
8629				endif 
8629 e1				pop hl    ; get zero term string 
862a e5				push hl 
862b 3e 00			ld a, 0 
862d cd e4 8f			call strlent 
8630 23				inc hl   ; cover zero term 
8631 06 00			ld b,0 
8633 4d				ld c,l 
8634 e1				pop hl 
8635				;ex de, hl 
8635				if DEBUG_STORESE 
8635					DMARK "SCa" 
8635 f5				push af  
8636 3a 4a 86			ld a, (.dmark)  
8639 32 71 ee			ld (debug_mark),a  
863c 3a 4b 86			ld a, (.dmark+1)  
863f 32 72 ee			ld (debug_mark+1),a  
8642 3a 4c 86			ld a, (.dmark+2)  
8645 32 73 ee			ld (debug_mark+2),a  
8648 18 03			jr .pastdmark  
864a ..			.dmark: db "SCa"  
864d f1			.pastdmark: pop af  
864e			endm  
# End of macro DMARK
864e					;push af 
864e					;ld a, 'a' 
864e					;ld (debug_mark),a 
864e					;pop af 
864e					CALLMONITOR 
864e cd 7c 93			call break_point_state  
8651				endm  
# End of macro CALLMONITOR
8651				endif 
8651 ed b0			ldir    ; copy zero term string 
8653				if DEBUG_STORESE 
8653					DMARK "SCA" 
8653 f5				push af  
8654 3a 68 86			ld a, (.dmark)  
8657 32 71 ee			ld (debug_mark),a  
865a 3a 69 86			ld a, (.dmark+1)  
865d 32 72 ee			ld (debug_mark+1),a  
8660 3a 6a 86			ld a, (.dmark+2)  
8663 32 73 ee			ld (debug_mark+2),a  
8666 18 03			jr .pastdmark  
8668 ..			.dmark: db "SCA"  
866b f1			.pastdmark: pop af  
866c			endm  
# End of macro DMARK
866c					CALLMONITOR 
866c cd 7c 93			call break_point_state  
866f				endm  
# End of macro CALLMONITOR
866f				endif 
866f			 
866f				; write file header page 
866f			 
866f 2a 46 eb			ld hl,(store_tmppageid) 
8672 11 5c eb			ld de, store_page 
8675				if DEBUG_STORESE 
8675					DMARK "SCb" 
8675 f5				push af  
8676 3a 8a 86			ld a, (.dmark)  
8679 32 71 ee			ld (debug_mark),a  
867c 3a 8b 86			ld a, (.dmark+1)  
867f 32 72 ee			ld (debug_mark+1),a  
8682 3a 8c 86			ld a, (.dmark+2)  
8685 32 73 ee			ld (debug_mark+2),a  
8688 18 03			jr .pastdmark  
868a ..			.dmark: db "SCb"  
868d f1			.pastdmark: pop af  
868e			endm  
# End of macro DMARK
868e					;push af 
868e					;ld a, 'b' 
868e					;ld (debug_mark),a 
868e					;pop af 
868e					CALLMONITOR 
868e cd 7c 93			call break_point_state  
8691				endm  
# End of macro CALLMONITOR
8691				endif 
8691 cd c5 81			call storage_write_block 
8694			 
8694 3a 55 eb			ld a, (store_tmpid) 
8697 6f				ld l, a 
8698 26 00			ld h,0 
869a				if DEBUG_STORESE 
869a					DMARK "SCz" 
869a f5				push af  
869b 3a af 86			ld a, (.dmark)  
869e 32 71 ee			ld (debug_mark),a  
86a1 3a b0 86			ld a, (.dmark+1)  
86a4 32 72 ee			ld (debug_mark+1),a  
86a7 3a b1 86			ld a, (.dmark+2)  
86aa 32 73 ee			ld (debug_mark+2),a  
86ad 18 03			jr .pastdmark  
86af ..			.dmark: db "SCz"  
86b2 f1			.pastdmark: pop af  
86b3			endm  
# End of macro DMARK
86b3					CALLMONITOR 
86b3 cd 7c 93			call break_point_state  
86b6				endm  
# End of macro CALLMONITOR
86b6				endif 
86b6 c9				ret 
86b7				 
86b7			 
86b7			 
86b7			; 
86b7			; Read File 
86b7			; 
86b7			; h - file id to locate 
86b7			; l - extent to locate 
86b7			; de - pointer to string to read into 
86b7			; 
86b7			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86b7			 
86b7			.sr_fail: 
86b7 d1				pop de 
86b8 c9				ret 
86b9			 
86b9			storage_read: 
86b9 d5				push de 
86ba			 
86ba			; TODO BUG the above push is it popped before the RET Z? 
86ba			 
86ba			; TODO how to handle multiple part blocks 
86ba			 
86ba				; locate file extent to read 
86ba			 
86ba 5c				ld e, h 
86bb 55				ld d, l 
86bc 21 40 00			ld hl, STORE_BLOCK_PHY 
86bf				if DEBUG_STORESE 
86bf					DMARK "SRE" 
86bf f5				push af  
86c0 3a d4 86			ld a, (.dmark)  
86c3 32 71 ee			ld (debug_mark),a  
86c6 3a d5 86			ld a, (.dmark+1)  
86c9 32 72 ee			ld (debug_mark+1),a  
86cc 3a d6 86			ld a, (.dmark+2)  
86cf 32 73 ee			ld (debug_mark+2),a  
86d2 18 03			jr .pastdmark  
86d4 ..			.dmark: db "SRE"  
86d7 f1			.pastdmark: pop af  
86d8			endm  
# End of macro DMARK
86d8					CALLMONITOR 
86d8 cd 7c 93			call break_point_state  
86db				endm  
# End of macro CALLMONITOR
86db				endif 
86db cd 93 84			call storage_findnextid 
86de			 
86de				if DEBUG_STORESE 
86de					DMARK "SRf" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 71 ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 72 ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 73 ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "SRf"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 7c 93			call break_point_state  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd a4 8b			call ishlzero 
86fd			;	ld a, l 
86fd			;	add h 
86fd			;	cp 0 
86fd 28 b8			jr z,.sr_fail			; block not found so EOF 
86ff			 
86ff				; hl contains page number to load 
86ff d1				pop de   ; get storage 
8700 d5				push de 
8701				if DEBUG_STORESE 
8701					DMARK "SRg" 
8701 f5				push af  
8702 3a 16 87			ld a, (.dmark)  
8705 32 71 ee			ld (debug_mark),a  
8708 3a 17 87			ld a, (.dmark+1)  
870b 32 72 ee			ld (debug_mark+1),a  
870e 3a 18 87			ld a, (.dmark+2)  
8711 32 73 ee			ld (debug_mark+2),a  
8714 18 03			jr .pastdmark  
8716 ..			.dmark: db "SRg"  
8719 f1			.pastdmark: pop af  
871a			endm  
# End of macro DMARK
871a					CALLMONITOR 
871a cd 7c 93			call break_point_state  
871d				endm  
# End of macro CALLMONITOR
871d				endif 
871d cd 60 81			call storage_read_block 
8720			 
8720			 
8720			; TODO if block has no zeros then need to read next block  
8720			 
8720			 
8720					 
8720 e1				pop hl 		 ; return start of data to show as not EOF 
8721 23				inc hl   ; past file id 
8722 23				inc hl   ; past ext 
8723				if DEBUG_STORESE 
8723					DMARK "SRe" 
8723 f5				push af  
8724 3a 38 87			ld a, (.dmark)  
8727 32 71 ee			ld (debug_mark),a  
872a 3a 39 87			ld a, (.dmark+1)  
872d 32 72 ee			ld (debug_mark+1),a  
8730 3a 3a 87			ld a, (.dmark+2)  
8733 32 73 ee			ld (debug_mark+2),a  
8736 18 03			jr .pastdmark  
8738 ..			.dmark: db "SRe"  
873b f1			.pastdmark: pop af  
873c			endm  
# End of macro DMARK
873c					CALLMONITOR 
873c cd 7c 93			call break_point_state  
873f				endm  
# End of macro CALLMONITOR
873f				endif 
873f c9					ret 
8740			 
8740			 
8740			 
8740			; 
8740			; Append File 
8740			; 
8740			; hl - file id to locate 
8740			; de - pointer to (multi block) string to write 
8740			 
8740			.sa_notfound: 
8740 d1				pop de 
8741 c9				ret 
8742			 
8742			 
8742			storage_append: 
8742				; hl -  file id to append to 
8742				; de - string to append 
8742			 
8742 d5				push de 
8743				 
8743				if DEBUG_STORESE 
8743					DMARK "AP1" 
8743 f5				push af  
8744 3a 58 87			ld a, (.dmark)  
8747 32 71 ee			ld (debug_mark),a  
874a 3a 59 87			ld a, (.dmark+1)  
874d 32 72 ee			ld (debug_mark+1),a  
8750 3a 5a 87			ld a, (.dmark+2)  
8753 32 73 ee			ld (debug_mark+2),a  
8756 18 03			jr .pastdmark  
8758 ..			.dmark: db "AP1"  
875b f1			.pastdmark: pop af  
875c			endm  
# End of macro DMARK
875c					CALLMONITOR 
875c cd 7c 93			call break_point_state  
875f				endm  
# End of macro CALLMONITOR
875f				endif 
875f			 
875f 7d				ld a, l 
8760 32 55 eb			ld (store_tmpid), a 
8763			 
8763				; get file header  
8763			 
8763 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8765 3a 55 eb			ld a, (store_tmpid) 
8768 5f				ld e, a 
8769			 
8769 21 40 00				ld hl, STORE_BLOCK_PHY 
876c cd 93 84				call storage_findnextid 
876f			 
876f cd a4 8b			call ishlzero 
8772 28 cc			jr z, .sa_notfound 
8774			 
8774 22 46 eb			ld (store_tmppageid), hl 
8777			 
8777				; TODO handle file id not found 
8777			 
8777				if DEBUG_STORESE 
8777					DMARK "AP2" 
8777 f5				push af  
8778 3a 8c 87			ld a, (.dmark)  
877b 32 71 ee			ld (debug_mark),a  
877e 3a 8d 87			ld a, (.dmark+1)  
8781 32 72 ee			ld (debug_mark+1),a  
8784 3a 8e 87			ld a, (.dmark+2)  
8787 32 73 ee			ld (debug_mark+2),a  
878a 18 03			jr .pastdmark  
878c ..			.dmark: db "AP2"  
878f f1			.pastdmark: pop af  
8790			endm  
# End of macro DMARK
8790					CALLMONITOR 
8790 cd 7c 93			call break_point_state  
8793				endm  
# End of macro CALLMONITOR
8793				endif 
8793			 
8793				; update file extent count 
8793			 
8793 11 5c eb			ld de, store_page 
8796			 
8796 cd 60 81			call storage_read_block 
8799			 
8799				if DEBUG_STORESE 
8799					DMARK "AP3" 
8799 f5				push af  
879a 3a ae 87			ld a, (.dmark)  
879d 32 71 ee			ld (debug_mark),a  
87a0 3a af 87			ld a, (.dmark+1)  
87a3 32 72 ee			ld (debug_mark+1),a  
87a6 3a b0 87			ld a, (.dmark+2)  
87a9 32 73 ee			ld (debug_mark+2),a  
87ac 18 03			jr .pastdmark  
87ae ..			.dmark: db "AP3"  
87b1 f1			.pastdmark: pop af  
87b2			endm  
# End of macro DMARK
87b2					CALLMONITOR 
87b2 cd 7c 93			call break_point_state  
87b5				endm  
# End of macro CALLMONITOR
87b5				endif 
87b5			;	ld (store_tmppageid), hl 
87b5			 
87b5 3a 5e eb			ld a, (store_page+2) 
87b8 3c				inc a 
87b9 32 5e eb			ld (store_page+2), a 
87bc 32 54 eb			ld (store_tmpext), a 
87bf				 
87bf				if DEBUG_STORESE 
87bf					DMARK "AP3" 
87bf f5				push af  
87c0 3a d4 87			ld a, (.dmark)  
87c3 32 71 ee			ld (debug_mark),a  
87c6 3a d5 87			ld a, (.dmark+1)  
87c9 32 72 ee			ld (debug_mark+1),a  
87cc 3a d6 87			ld a, (.dmark+2)  
87cf 32 73 ee			ld (debug_mark+2),a  
87d2 18 03			jr .pastdmark  
87d4 ..			.dmark: db "AP3"  
87d7 f1			.pastdmark: pop af  
87d8			endm  
# End of macro DMARK
87d8					CALLMONITOR 
87d8 cd 7c 93			call break_point_state  
87db				endm  
# End of macro CALLMONITOR
87db				endif 
87db 2a 46 eb			ld hl, (store_tmppageid) 
87de 11 5c eb			ld de, store_page 
87e1 cd c5 81			call storage_write_block 
87e4			 
87e4				; find free block 
87e4			 
87e4 11 00 00			ld de, 0			 ; file extent to locate 
87e7			 
87e7 21 40 00				ld hl, STORE_BLOCK_PHY 
87ea cd 93 84				call storage_findnextid 
87ed cd a4 8b			call ishlzero 
87f0 ca 40 87			jp z, .sa_notfound 
87f3			 
87f3					; TODO handle no space left 
87f3					 
87f3 22 46 eb				ld (store_tmppageid), hl 
87f6			 
87f6				if DEBUG_STORESE 
87f6					DMARK "AP4" 
87f6 f5				push af  
87f7 3a 0b 88			ld a, (.dmark)  
87fa 32 71 ee			ld (debug_mark),a  
87fd 3a 0c 88			ld a, (.dmark+1)  
8800 32 72 ee			ld (debug_mark+1),a  
8803 3a 0d 88			ld a, (.dmark+2)  
8806 32 73 ee			ld (debug_mark+2),a  
8809 18 03			jr .pastdmark  
880b ..			.dmark: db "AP4"  
880e f1			.pastdmark: pop af  
880f			endm  
# End of macro DMARK
880f					CALLMONITOR 
880f cd 7c 93			call break_point_state  
8812				endm  
# End of macro CALLMONITOR
8812				endif 
8812					; init the buffer with zeros so we can id if the buffer is full or not 
8812			 
8812 e5					push hl 
8813 c5					push bc 
8814			 
8814 21 5c eb				ld hl, store_page 
8817 06 40				ld b, STORE_BLOCK_PHY 
8819 3e 00				ld a, 0 
881b 77			.zeroblock:	ld (hl), a 
881c 23					inc hl 
881d 10 fc				djnz .zeroblock 
881f			 
881f c1					pop bc 
8820 e1					pop hl 
8821			 
8821					; construct block 
8821			 
8821 3a 55 eb				ld a, (store_tmpid) 
8824 32 5c eb				ld (store_page), a   ; file id 
8827 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
882a 32 5d eb				ld (store_page+1), a 
882d			 
882d e1					pop hl    ; get string to write 
882e 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8830 11 5e eb				ld de, store_page+2 
8833			 
8833				if DEBUG_STORESE 
8833					DMARK "AP5" 
8833 f5				push af  
8834 3a 48 88			ld a, (.dmark)  
8837 32 71 ee			ld (debug_mark),a  
883a 3a 49 88			ld a, (.dmark+1)  
883d 32 72 ee			ld (debug_mark+1),a  
8840 3a 4a 88			ld a, (.dmark+2)  
8843 32 73 ee			ld (debug_mark+2),a  
8846 18 03			jr .pastdmark  
8848 ..			.dmark: db "AP5"  
884b f1			.pastdmark: pop af  
884c			endm  
# End of macro DMARK
884c					CALLMONITOR 
884c cd 7c 93			call break_point_state  
884f				endm  
# End of macro CALLMONITOR
884f				endif 
884f			 
884f			 
884f			 
884f					; fill buffer with data until end of string or full block 
884f			 
884f 7e			.appd:		ld a, (hl) 
8850 12					ld (de), a 
8851 fe 00				cp 0 
8853 28 04				jr z, .appdone 
8855 23					inc hl 
8856 13					inc de 
8857 10 f6				djnz .appd 
8859			 
8859 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
885a f5					push af   		; save last byte dumped 
885b			 
885b			 
885b 2a 46 eb			ld hl, (store_tmppageid) 
885e 11 5c eb			ld de, store_page 
8861				if DEBUG_STORESE 
8861					DMARK "AP6" 
8861 f5				push af  
8862 3a 76 88			ld a, (.dmark)  
8865 32 71 ee			ld (debug_mark),a  
8868 3a 77 88			ld a, (.dmark+1)  
886b 32 72 ee			ld (debug_mark+1),a  
886e 3a 78 88			ld a, (.dmark+2)  
8871 32 73 ee			ld (debug_mark+2),a  
8874 18 03			jr .pastdmark  
8876 ..			.dmark: db "AP6"  
8879 f1			.pastdmark: pop af  
887a			endm  
# End of macro DMARK
887a					CALLMONITOR 
887a cd 7c 93			call break_point_state  
887d				endm  
# End of macro CALLMONITOR
887d				endif 
887d cd c5 81				call storage_write_block 
8880			 
8880			 
8880				; was that a full block of data written? 
8880				; any more to write out? 
8880			 
8880				; if yes then set vars and jump to start of function again 
8880			 
8880 f1					pop af 
8881 d1					pop de 
8882			 
8882 fe 00				cp 0		 ; no, string was fully written 
8884 c8					ret z 
8885			 
8885					; setup vars for next cycle 
8885			 
8885 3a 55 eb				ld a, (store_tmpid) 
8888 6f					ld l, a 
8889 26 00				ld h, 0 
888b			 
888b c3 42 87			 	jp storage_append	 ; yes, need to write out some more 
888e			 
888e			 
888e			 
888e			 
888e			 
888e			 
888e			 
888e			if DEBUG_STORECF 
888e			storageput:	 
888e					ret 
888e			storageread: 
888e					ld hl, store_page 
888e					ld b, 200 
888e					ld a,0 
888e			.src:		ld (hl),a 
888e					inc hl 
888e					djnz .src 
888e					 
888e			 
888e					ld de, 0 
888e					ld bc, 1 
888e					ld hl, store_page 
888e					call cfRead 
888e			 
888e				call cfGetError 
888e				ld hl,scratch 
888e				call hexout 
888e				ld hl, scratch+2 
888e				ld a, 0 
888e				ld (hl),a 
888e				ld de, scratch 
888e				ld a,display_row_1 
888e				call str_at_display 
888e				call update_display 
888e			 
888e					ld hl, store_page 
888e					ld (os_cur_ptr),hl 
888e			 
888e					ret 
888e			endif 
888e			 
888e			 
888e			; Clear out the main buffer store (used to remove junk before writing a new block) 
888e			 
888e			storage_clear_page: 
888e e5				push hl 
888f d5				push de 
8890 c5				push bc 
8891 21 5c eb			ld hl, store_page 
8894 3e 00			ld a, 0 
8896 77				ld (hl), a 
8897			 
8897 11 5d eb			ld de, store_page+1 
889a 01 40 00			ld bc, STORE_BLOCK_PHY 
889d			 
889d ed b0			ldir 
889f				 
889f c1				pop bc 
88a0 d1				pop de 
88a1 e1				pop hl 
88a2 c9				ret 
88a3			 
88a3			; eof 
# End of file firmware_storage.asm
88a3			  
88a3			; support routines for above hardware abstraction layer  
88a3			  
88a3			include "firmware_general.asm"        ; general support functions  
88a3			 
88a3			; word look up 
88a3			 
88a3			; in 
88a3			; a is the index 
88a3			; hl is pointer start of array 
88a3			; 
88a3			; returns 
88a3			; hl to the word 
88a3			; 
88a3			 
88a3			table_lookup:  
88a3 d5					push de 
88a4 eb					ex de, hl 
88a5			 
88a5 6f					ld l, a 
88a6 26 00				ld h, 0 
88a8 29					add hl, hl 
88a9 19					add hl, de 
88aa 7e					ld a, (hl) 
88ab 23					inc hl 
88ac 66					ld h,(hl) 
88ad 6f					ld l, a 
88ae			 
88ae d1					pop de 
88af c9					ret 
88b0			 
88b0			; Delay loops 
88b0			 
88b0			 
88b0			 
88b0			aDelayInMS: 
88b0 c5				push bc 
88b1 47				ld b,a 
88b2			msdelay: 
88b2 c5				push bc 
88b3				 
88b3			 
88b3 01 41 00			ld bc,041h 
88b6 cd ce 88			call delayloop 
88b9 c1				pop bc 
88ba 05				dec b 
88bb 20 f5			jr nz,msdelay 
88bd			 
88bd			;if CPU_CLOCK_8MHZ 
88bd			;msdelay8: 
88bd			;	push bc 
88bd			;	 
88bd			; 
88bd			;	ld bc,041h 
88bd			;	call delayloop 
88bd			;	pop bc 
88bd			;	dec b 
88bd			;	jr nz,msdelay8 
88bd			;endif 
88bd			 
88bd			 
88bd c1				pop bc 
88be c9				ret 
88bf			 
88bf			 
88bf			delay250ms: 
88bf				;push de 
88bf 01 00 40			ld bc, 04000h 
88c2 c3 ce 88			jp delayloop 
88c5			delay500ms: 
88c5				;push de 
88c5 01 00 80			ld bc, 08000h 
88c8 c3 ce 88			jp delayloop 
88cb			delay1s: 
88cb				;push bc 
88cb			   ; Clobbers A, d and e 
88cb 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
88ce			delayloop: 
88ce c5			    push bc 
88cf			 
88cf			if BASE_CPM 
88cf				ld bc, CPM_DELAY_TUNE 
88cf			.cpmloop: 
88cf				push bc 
88cf			 
88cf			endif 
88cf			 
88cf			 
88cf			 
88cf			delayloopi: 
88cf			;	push bc 
88cf			;.dl: 
88cf cb 47		    bit     0,a    	; 8 
88d1 cb 47		    bit     0,a    	; 8 
88d3 cb 47		    bit     0,a    	; 8 
88d5 e6 ff		    and     255  	; 7 
88d7 0b			    dec     bc      	; 6 
88d8 79			    ld      a,c     	; 4 
88d9 b0			    or      b     	; 4 
88da c2 cf 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
88dd			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
88dd				;pop de 
88dd			;pop bc 
88dd			 
88dd			if BASE_CPM 
88dd				pop bc 
88dd				 
88dd			    dec     bc      	; 6 
88dd			    ld      a,c     	; 4 
88dd			    or      b     	; 4 
88dd			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
88dd				 
88dd			 
88dd			endif 
88dd			;if CPU_CLOCK_8MHZ 
88dd			;    pop bc 
88dd			;    push bc 
88dd			;.dl8: 
88dd			;    bit     0,a    	; 8 
88dd			;    bit     0,a    	; 8 
88dd			;    bit     0,a    	; 8 
88dd			;    and     255  	; 7 
88dd			;    dec     bc      	; 6 
88dd			;    ld      a,c     	; 4 
88dd			;    or      b     	; 4 
88dd			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
88dd			;endif 
88dd			 
88dd			;if CPU_CLOCK_10MHZ 
88dd			;    pop bc 
88dd			;    push bc 
88dd			;.dl8: 
88dd			;    bit     0,a    	; 8 
88dd			;    bit     0,a    	; 8 
88dd			;    bit     0,a    	; 8 
88dd			;    and     255  	; 7 
88dd			;    dec     bc      	; 6 
88dd			;    ld      a,c     	; 4 
88dd			;    or      b     	; 4 
88dd			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
88dd			;endif 
88dd c1			    pop bc 
88de			 
88de c9				ret 
88df			 
88df			 
88df			 
88df			; eof 
# End of file firmware_general.asm
88df			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
88df			; display routines that use the physical hardware abstraction layer 
88df			 
88df			 
88df			; information window 
88df			 
88df			; pass hl with 1st string to display 
88df			; pass de with 2nd string to display 
88df			 
88df			info_panel: 
88df e5				push hl 
88e0			 
88e0 2a d2 eb			ld hl, (display_fb_active) 
88e3 e5				push hl    ; future de destination 
88e4 21 b7 ed				ld hl, display_fb0 
88e7 22 d2 eb				ld (display_fb_active), hl 
88ea			 
88ea			;	call clear_display 
88ea			 
88ea				if BASE_CPM 
88ea				ld a, '.' 
88ea				else 
88ea 3e a5			ld a, 165 
88ec				endif 
88ec cd 53 89			call fill_display 
88ef			 
88ef			 
88ef 3e 55			ld a, display_row_3 + 5 
88f1 cd 61 89			call str_at_display 
88f4			 
88f4 e1				pop hl 
88f5 d1				pop de 
88f6			 
88f6 e5				push hl 
88f7			 
88f7			 
88f7 3e 2d			ld a, display_row_2 + 5 
88f9 cd 61 89			call str_at_display 
88fc			 
88fc			 
88fc cd 71 89			call update_display 
88ff cd 4e 99			call next_page_prompt 
8902 cd 4e 89			call clear_display 
8905			 
8905				 
8905 21 16 ed				ld hl, display_fb1 
8908 22 d2 eb				ld (display_fb_active), hl 
890b cd 71 89			call update_display 
890e			 
890e e1				pop hl 
890f			 
890f c9				ret 
8910			 
8910			 
8910			 
8910			 
8910			; TODO windowing? 
8910			 
8910			; TODO scroll line up 
8910			 
8910			scroll_up: 
8910			 
8910 e5				push hl 
8911 d5				push de 
8912 c5				push bc 
8913			 
8913				; get frame buffer  
8913			 
8913 2a d2 eb			ld hl, (display_fb_active) 
8916 e5				push hl    ; future de destination 
8917			 
8917 11 28 00			ld  de, display_cols 
891a 19				add hl, de 
891b			 
891b d1				pop de 
891c			 
891c				;ex de, hl 
891c 01 9f 00			ld bc, display_fb_len -1  
891f			;if DEBUG_FORTH_WORDS 
891f			;	DMARK "SCL" 
891f			;	CALLMONITOR 
891f			;endif	 
891f ed b0			ldir 
8921			 
8921				; wipe bottom row 
8921			 
8921			 
8921 2a d2 eb			ld hl, (display_fb_active) 
8924 11 a0 00			ld de, display_cols*display_rows 
8927 19				add hl, de 
8928 06 28			ld b, display_cols 
892a 3e 20			ld a, ' ' 
892c			.scwipe: 
892c 77				ld (hl), a 
892d 2b				dec hl 
892e 10 fc			djnz .scwipe 
8930			 
8930				;pop hl 
8930			 
8930 c1				pop bc 
8931 d1				pop de 
8932 e1				pop hl 
8933			 
8933 c9				ret 
8934			 
8934			 
8934			;scroll_upo: 
8934			;	ld de, display_row_1 
8934			 ;	ld hl, display_row_2 
8934			;	ld bc, display_cols 
8934			;	ldir 
8934			;	ld de, display_row_2 
8934			 ;	ld hl, display_row_3 
8934			;	ld bc, display_cols 
8934			;	ldir 
8934			;	ld de, display_row_3 
8934			 ;	ld hl, display_row_4 
8934			;	ld bc, display_cols 
8934			;	ldir 
8934			 
8934			; TODO clear row 4 
8934			 
8934			;	ret 
8934			 
8934				 
8934			scroll_down: 
8934			 
8934 e5				push hl 
8935 d5				push de 
8936 c5				push bc 
8937			 
8937				; get frame buffer  
8937			 
8937 2a d2 eb			ld hl, (display_fb_active) 
893a			 
893a 11 9f 00			ld de, display_fb_len - 1 
893d 19				add hl, de 
893e			 
893e e5			push hl    ; future de destination 
893f			 
893f 11 28 00			ld  de, display_cols 
8942 ed 52			sbc hl, de 
8944			 
8944			 
8944 d1				pop de 
8945			 
8945			;	ex de, hl 
8945 01 9f 00			ld bc, display_fb_len -1  
8948			 
8948			 
8948				 
8948			 
8948 ed b0			ldir 
894a			 
894a				; wipe bottom row 
894a			 
894a			 
894a			;	ld hl, (display_fb_active) 
894a			;;	ld de, display_cols*display_rows 
894a			;;	add hl, de 
894a			;	ld b, display_cols 
894a			;	ld a, ' ' 
894a			;.scwiped: 
894a			;	ld (hl), a 
894a			;	dec hl 
894a			;	djnz .scwiped 
894a			 
894a				;pop hl 
894a			 
894a c1				pop bc 
894b d1				pop de 
894c e1				pop hl 
894d			 
894d c9				ret 
894e			;scroll_down: 
894e			;	ld de, display_row_4 
894e			;	ld hl, display_row_3 
894e			;	ld bc, display_cols 
894e			;	ldir 
894e			;	ld de, display_row_3 
894e			; 	ld hl, display_row_2 
894e			;	ld bc, display_cols 
894e			;	ldir 
894e			;	ld de, display_row_2 
894e			;	ld hl, display_row_1 
894e			;	ld bc, display_cols 
894e			;	ldir 
894e			;;; TODO clear row 1 
894e			;	ret 
894e			 
894e			 
894e			 
894e			 
894e			 
894e			; clear active frame buffer 
894e			 
894e			clear_display: 
894e 3e 20			ld a, ' ' 
8950 c3 53 89			jp fill_display 
8953			 
8953			; fill active frame buffer with a char in A 
8953			 
8953			fill_display: 
8953 06 a0			ld b,display_fb_len 
8955 2a d2 eb			ld hl, (display_fb_active) 
8958 77			.fd1:	ld (hl),a 
8959 23				inc hl 
895a 10 fc			djnz .fd1 
895c 23				inc hl 
895d 3e 00			ld a,0 
895f 77				ld (hl),a 
8960			 
8960			 
8960 c9				ret 
8961			; Write string (DE) at pos (A) to active frame buffer 
8961			 
8961 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8964 06 00					ld b,0 
8966 4f					ld c,a 
8967 09					add hl,bc 
8968 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8969 b7			            OR   A              ;Null terminator? 
896a c8			            RET  Z              ;Yes, so finished 
896b 77					ld (hl),a 
896c 23				inc hl 
896d 13			            INC  DE             ;Point to next character 
896e 18 f8		            JR   .sad1     ;Repeat 
8970 c9					ret 
8971			 
8971			; using current frame buffer write to physical display 
8971			 
8971			update_display: 
8971 e5				push hl 
8972 2a d2 eb			ld hl, (display_fb_active) 
8975 cd 4a d8			call write_display 
8978 e1				pop hl 
8979 c9				ret 
897a			 
897a			; TODO scrolling 
897a			 
897a			 
897a			; move cursor right one char 
897a			cursor_right: 
897a			 
897a				; TODO shift right 
897a				; TODO if beyond max col 
897a				; TODO       cursor_next_line 
897a			 
897a c9				ret 
897b			 
897b			 
897b			cursor_next_line: 
897b				; TODO first char 
897b				; TODO line down 
897b				; TODO if past last row 
897b				; TODO    scroll up 
897b			 
897b c9				ret 
897c			 
897c			cursor_left: 
897c				; TODO shift left 
897c				; TODO if beyond left  
897c				; TODO     cursor prev line 
897c				 
897c c9				ret 
897d			 
897d			cursor_prev_line: 
897d				; TODO last char 
897d				; TODO line up 
897d				; TODO if past first row 
897d				; TODO   scroll down 
897d			 
897d c9				ret 
897e			 
897e			 
897e			cout: 
897e				; A - char 
897e c9				ret 
897f			 
897f			 
897f			; Display a menu and allow item selection (optional toggle items) 
897f			; 
897f			; format: 
897f			; hl pointer to word array with zero term for items 
897f			; e.g.    db item1 
897f			;         db .... 
897f			;         db 0 
897f			; 
897f			; a = starting menu item  
897f			; 
897f			; de = pointer item toggle array   (todo) 
897f			; 
897f			; returns item selected in a 1-... 
897f			; returns 0 if back button pressed 
897f			; 
897f			; NOTE: Uses system frame buffer to display 
897f			; 
897f			; LEFT, Q = go back 
897f			; RIGHT, SPACE, CR = select 
897f			; UP, A - Up 
897f			; DOWN, Z - Down 
897f			 
897f			 
897f			 
897f			 
897f			 
897f			menu: 
897f			 
897f					; keep array pointer 
897f			 
897f 22 5a eb				ld (store_tmp1), hl 
8982 32 58 eb				ld (store_tmp2), a 
8985			 
8985					; check for key bounce 
8985			 
8985			if BASE_KEV 
8985			 
8985			.mbounce:	call cin 
8985					cp 0 
8985					jr nz, .mbounce 
8985			endif 
8985					; for ease use ex 
8985			 
8985					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8985 21 b7 ed				ld hl, display_fb0 
8988 22 d2 eb				ld (display_fb_active), hl 
898b			 
898b cd 4e 89		.mloop:		call clear_display 
898e cd 71 89				call update_display 
8991			 
8991					; draw selection id '>' at 1 
8991			 
8991					; init start of list display 
8991			 
8991 3e 05				ld a, 5 
8993 32 56 eb				ld (store_tmp3), a   ; display row count 
8996 3a 58 eb				ld a,( store_tmp2) 
8999 32 59 eb				ld (store_tmp2+1), a   ; display item count 
899c			 
899c					 
899c			.mitem:	 
899c			 
899c			 
899c 3a 59 eb				ld a,(store_tmp2+1) 
899f 6f					ld l, a 
89a0 26 00				ld h, 0 
89a2 29					add hl, hl 
89a3 ed 5b 5a eb			ld de, (store_tmp1) 
89a7 19					add hl, de 
89a8 7e					ld a, (hl) 
89a9 23					inc hl 
89aa 66					ld h,(hl) 
89ab 6f					ld l, a 
89ac			 
89ac cd a4 8b				call ishlzero 
89af 28 1a				jr z, .mdone 
89b1			 
89b1 eb					ex de, hl 
89b2 3a 56 eb				ld a, (store_tmp3) 
89b5 cd 61 89				call str_at_display 
89b8					 
89b8			 
89b8					; next item 
89b8 3a 59 eb				ld a, (store_tmp2+1) 
89bb 3c					inc a 
89bc 32 59 eb				ld (store_tmp2+1), a   ; display item count 
89bf			 
89bf			 		; next row 
89bf			 
89bf 3a 56 eb				ld a, (store_tmp3) 
89c2 c6 28				add display_cols 
89c4 32 56 eb				ld (store_tmp3), a 
89c7			 
89c7					; at end of screen? 
89c7			 
89c7 fe 10				cp display_rows*4 
89c9 20 d1				jr nz, .mitem 
89cb			 
89cb			 
89cb			.mdone: 
89cb cd a4 8b				call ishlzero 
89ce 28 08				jr z, .nodn 
89d0			 
89d0 3e 78				ld a, display_row_4 
89d2 11 51 8a				ld de, .mdown 
89d5 cd 61 89				call str_at_display 
89d8			 
89d8					; draw options to fill the screens with active item on line 1 
89d8					; if current option is 2 or more then display ^ in top 
89d8			 
89d8 3a 58 eb		.nodn:		ld a, (store_tmp2) 
89db fe 00				cp 0 
89dd 28 08				jr z, .noup 
89df			 
89df 3e 00				ld a, 0 
89e1 11 4f 8a				ld de, .mup 
89e4 cd 61 89				call str_at_display 
89e7			 
89e7 3e 02		.noup:		ld a, 2 
89e9 11 4d 8a				ld de, .msel 
89ec cd 61 89				call str_at_display 
89ef			 
89ef					; if current option + 1 is not null then display V in bottom 
89ef					; get key 
89ef cd 71 89				call update_display 
89f2			 
89f2			 
89f2					; handle key 
89f2			 
89f2 cd d6 d8				call cin_wait 
89f5			 
89f5 fe 05				cp KEY_UP 
89f7 28 2b				jr z, .mgoup 
89f9 fe 61				cp 'a' 
89fb 28 27				jr z, .mgoup 
89fd fe 0a				cp KEY_DOWN 
89ff 28 32				jr z, .mgod 
8a01 fe 7a				cp 'z' 
8a03 28 2e				jr z, .mgod 
8a05 fe 20				cp ' ' 
8a07 28 34				jr z, .goend 
8a09 fe 0c				cp KEY_RIGHT 
8a0b 28 30				jr z, .goend 
8a0d fe 0d				cp KEY_CR 
8a0f 28 2c				jr z, .goend 
8a11 fe 71				cp 'q' 
8a13 28 0b				jr z, .goback 
8a15			 
8a15 fe 0b				cp KEY_LEFT 
8a17 28 07				jr z, .goback 
8a19 fe 08				cp KEY_BS 
8a1b 28 03				jr z, .goback 
8a1d c3 8b 89				jp .mloop 
8a20			 
8a20			.goback: 
8a20 3e 00			ld a, 0 
8a22 18 1d			jr .goend2 
8a24			 
8a24				; move up one 
8a24			.mgoup: 
8a24 3a 58 eb				ld a, (store_tmp2) 
8a27 fe 00				cp 0 
8a29 ca 8b 89				jp z, .mloop 
8a2c 3d					dec a 
8a2d 32 58 eb				ld (store_tmp2), a 
8a30 c3 8b 89				jp .mloop 
8a33			 
8a33				; move down one 
8a33			.mgod: 
8a33 3a 58 eb				ld a, (store_tmp2) 
8a36 3c					inc a 
8a37 32 58 eb				ld (store_tmp2), a 
8a3a c3 8b 89				jp .mloop 
8a3d			 
8a3d			 
8a3d			.goend: 
8a3d					; get selected item number 
8a3d			 
8a3d 3a 58 eb				ld a, (store_tmp2) 
8a40 3c					inc a 
8a41			 
8a41			.goend2: 
8a41 f5					push af 
8a42			 
8a42					; restore active fb 
8a42					; TODO BUG assumes fb1 
8a42			 
8a42 21 16 ed				ld hl, display_fb1 
8a45 22 d2 eb				ld (display_fb_active), hl 
8a48			 
8a48					; restore main regs 
8a48			 
8a48			 
8a48 cd 71 89				call update_display 
8a4b			 
8a4b f1					pop af 
8a4c			 
8a4c c9				ret 
8a4d			 
8a4d .. 00		.msel:   db ">",0 
8a4f .. 00		.mup:   db "^",0 
8a51 .. 00		.mdown:   db "v",0 
8a53			 
8a53			 
8a53			; eof 
8a53			 
# End of file firmware_display.asm
8a53			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8a53			; random number generators 
8a53			 
8a53			 
8a53			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8a53			 
8a53			 
8a53			;-----> Generate a random number 
8a53			; output a=answer 0<=a<=255 
8a53			; all registers are preserved except: af 
8a53			random: 
8a53 e5			        push    hl 
8a54 d5			        push    de 
8a55 2a b4 eb		        ld      hl,(randData) 
8a58 ed 5f		        ld      a,r 
8a5a 57			        ld      d,a 
8a5b 5e			        ld      e,(hl) 
8a5c 19			        add     hl,de 
8a5d 85			        add     a,l 
8a5e ac			        xor     h 
8a5f 22 b4 eb		        ld      (randData),hl 
8a62 d1			        pop     de 
8a63 e1			        pop     hl 
8a64 c9			        ret 
8a65			 
8a65			 
8a65			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8a65			 
8a65			 
8a65			 
8a65			;------LFSR------ 
8a65			;James Montelongo 
8a65			;optimized by Spencer Putt 
8a65			;out: 
8a65			; a = 8 bit random number 
8a65			RandLFSR: 
8a65 21 ba eb		        ld hl,LFSRSeed+4 
8a68 5e			        ld e,(hl) 
8a69 23			        inc hl 
8a6a 56			        ld d,(hl) 
8a6b 23			        inc hl 
8a6c 4e			        ld c,(hl) 
8a6d 23			        inc hl 
8a6e 7e			        ld a,(hl) 
8a6f 47			        ld b,a 
8a70 cb 13		        rl e  
8a72 cb 12			rl d 
8a74 cb 11		        rl c  
8a76 17				rla 
8a77 cb 13		        rl e  
8a79 cb 12			rl d 
8a7b cb 11		        rl c  
8a7d 17				rla 
8a7e cb 13		        rl e  
8a80 cb 12			rl d 
8a82 cb 11		        rl c  
8a84 17				rla 
8a85 67			        ld h,a 
8a86 cb 13		        rl e  
8a88 cb 12			rl d 
8a8a cb 11		        rl c  
8a8c 17				rla 
8a8d a8			        xor b 
8a8e cb 13		        rl e  
8a90 cb 12			rl d 
8a92 ac			        xor h 
8a93 a9			        xor c 
8a94 aa			        xor d 
8a95 21 bc eb		        ld hl,LFSRSeed+6 
8a98 11 bd eb		        ld de,LFSRSeed+7 
8a9b 01 07 00		        ld bc,7 
8a9e ed b8		        lddr 
8aa0 12			        ld (de),a 
8aa1 c9			        ret 
8aa2			 
8aa2			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8aa2			 
8aa2			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8aa2			 
8aa2			 
8aa2			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8aa2			 
8aa2			prng16: 
8aa2			;Inputs: 
8aa2			;   (seed1) contains a 16-bit seed value 
8aa2			;   (seed2) contains a NON-ZERO 16-bit seed value 
8aa2			;Outputs: 
8aa2			;   HL is the result 
8aa2			;   BC is the result of the LCG, so not that great of quality 
8aa2			;   DE is preserved 
8aa2			;Destroys: 
8aa2			;   AF 
8aa2			;cycle: 4,294,901,760 (almost 4.3 billion) 
8aa2			;160cc 
8aa2			;26 bytes 
8aa2 2a ae eb		    ld hl,(seed1) 
8aa5 44			    ld b,h 
8aa6 4d			    ld c,l 
8aa7 29			    add hl,hl 
8aa8 29			    add hl,hl 
8aa9 2c			    inc l 
8aaa 09			    add hl,bc 
8aab 22 ae eb		    ld (seed1),hl 
8aae 2a ac eb		    ld hl,(seed2) 
8ab1 29			    add hl,hl 
8ab2 9f			    sbc a,a 
8ab3 e6 2d		    and %00101101 
8ab5 ad			    xor l 
8ab6 6f			    ld l,a 
8ab7 22 ac eb		    ld (seed2),hl 
8aba 09			    add hl,bc 
8abb c9			    ret 
8abc			 
8abc			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8abc			 
8abc			rand32: 
8abc			;Inputs: 
8abc			;   (seed1_0) holds the lower 16 bits of the first seed 
8abc			;   (seed1_1) holds the upper 16 bits of the first seed 
8abc			;   (seed2_0) holds the lower 16 bits of the second seed 
8abc			;   (seed2_1) holds the upper 16 bits of the second seed 
8abc			;   **NOTE: seed2 must be non-zero 
8abc			;Outputs: 
8abc			;   HL is the result 
8abc			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8abc			;Destroys: 
8abc			;   AF 
8abc			;Tested and passes all CAcert tests 
8abc			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8abc			;it has a period of 18,446,744,069,414,584,320 
8abc			;roughly 18.4 quintillion. 
8abc			;LFSR taps: 0,2,6,7  = 11000101 
8abc			;291cc 
8abc			;seed1_0=$+1 
8abc			;    ld hl,12345 
8abc			;seed1_1=$+1 
8abc			;    ld de,6789 
8abc			;    ld b,h 
8abc			;    ld c,l 
8abc			;    add hl,hl \ rl e \ rl d 
8abc			;    add hl,hl \ rl e \ rl d 
8abc			;    inc l 
8abc			;    add hl,bc 
8abc			;    ld (seed1_0),hl 
8abc			;    ld hl,(seed1_1) 
8abc			;    adc hl,de 
8abc			;    ld (seed1_1),hl 
8abc			;    ex de,hl 
8abc			;seed2_0=$+1 
8abc			;    ld hl,9876 
8abc			;seed2_1=$+1 
8abc			;    ld bc,54321 
8abc			;    add hl,hl \ rl c \ rl b 
8abc			;    ld (seed2_1),bc 
8abc			;    sbc a,a 
8abc			;    and %11000101 
8abc			;    xor l 
8abc			;    ld l,a 
8abc			;    ld (seed2_0),hl 
8abc			;    ex de,hl 
8abc			;    add hl,bc 
8abc			;    ret 
8abc			; 
8abc			 
8abc			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8abc			; 20 bytes, 86 cycles (excluding ret) 
8abc			 
8abc			; returns   hl = pseudorandom number 
8abc			; corrupts   a 
8abc			 
8abc			; generates 16-bit pseudorandom numbers with a period of 65535 
8abc			; using the xorshift method: 
8abc			 
8abc			; hl ^= hl << 7 
8abc			; hl ^= hl >> 9 
8abc			; hl ^= hl << 8 
8abc			 
8abc			; some alternative shift triplets which also perform well are: 
8abc			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8abc			 
8abc			;  org 32768 
8abc			 
8abc			xrnd: 
8abc 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8abf 3e 00		  ld a,0 
8ac1 bd			  cp l 
8ac2 20 02		  jr nz, .xrnd1 
8ac4 2e 01		  ld l, 1 
8ac6			.xrnd1: 
8ac6			 
8ac6 7c			  ld a,h 
8ac7 1f			  rra 
8ac8 7d			  ld a,l 
8ac9 1f			  rra 
8aca ac			  xor h 
8acb 67			  ld h,a 
8acc 7d			  ld a,l 
8acd 1f			  rra 
8ace 7c			  ld a,h 
8acf 1f			  rra 
8ad0 ad			  xor l 
8ad1 6f			  ld l,a 
8ad2 ac			  xor h 
8ad3 67			  ld h,a 
8ad4			 
8ad4 22 b2 eb		  ld (xrandc),hl 
8ad7			 
8ad7 c9			  ret 
8ad8			;  
8ad8			 
8ad8			 
8ad8			;;;; int maths 
8ad8			 
8ad8			; https://map.grauw.nl/articles/mult_div_shifts.php 
8ad8			; Divide 16-bit values (with 16-bit result) 
8ad8			; In: Divide BC by divider DE 
8ad8			; Out: BC = result, HL = rest 
8ad8			; 
8ad8			Div16: 
8ad8 21 00 00		    ld hl,0 
8adb 78			    ld a,b 
8adc 06 08		    ld b,8 
8ade			Div16_Loop1: 
8ade 17			    rla 
8adf ed 6a		    adc hl,hl 
8ae1 ed 52		    sbc hl,de 
8ae3 30 01		    jr nc,Div16_NoAdd1 
8ae5 19			    add hl,de 
8ae6			Div16_NoAdd1: 
8ae6 10 f6		    djnz Div16_Loop1 
8ae8 17			    rla 
8ae9 2f			    cpl 
8aea 47			    ld b,a 
8aeb 79			    ld a,c 
8aec 48			    ld c,b 
8aed 06 08		    ld b,8 
8aef			Div16_Loop2: 
8aef 17			    rla 
8af0 ed 6a		    adc hl,hl 
8af2 ed 52		    sbc hl,de 
8af4 30 01		    jr nc,Div16_NoAdd2 
8af6 19			    add hl,de 
8af7			Div16_NoAdd2: 
8af7 10 f6		    djnz Div16_Loop2 
8af9 17			    rla 
8afa 2f			    cpl 
8afb 41			    ld b,c 
8afc 4f			    ld c,a 
8afd c9			ret 
8afe			 
8afe			 
8afe			;http://z80-heaven.wikidot.com/math 
8afe			; 
8afe			;Inputs: 
8afe			;     DE and A are factors 
8afe			;Outputs: 
8afe			;     A is not changed 
8afe			;     B is 0 
8afe			;     C is not changed 
8afe			;     DE is not changed 
8afe			;     HL is the product 
8afe			;Time: 
8afe			;     342+6x 
8afe			; 
8afe			Mult16: 
8afe			 
8afe 06 08		     ld b,8          ;7           7 
8b00 21 00 00		     ld hl,0         ;10         10 
8b03 29			       add hl,hl     ;11*8       88 
8b04 07			       rlca          ;4*8        32 
8b05 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8b07 19			         add hl,de   ;--         -- 
8b08 10 f9		       djnz $-5      ;13*7+8     99 
8b0a c9			ret 
8b0b			 
8b0b			; 
8b0b			; Square root of 16-bit value 
8b0b			; In:  HL = value 
8b0b			; Out:  D = result (rounded down) 
8b0b			; 
8b0b			;Sqr16: 
8b0b			;    ld de,#0040 
8b0b			;    ld a,l 
8b0b			;    ld l,h 
8b0b			;    ld h,d 
8b0b			;    or a 
8b0b			;    ld b,8 
8b0b			;Sqr16_Loop: 
8b0b			;    sbc hl,de 
8b0b			;    jr nc,Sqr16_Skip 
8b0b			;    add hl,de 
8b0b			;Sqr16_Skip: 
8b0b			;    ccf 
8b0b			;    rl d 
8b0b			;    add a,a 
8b0b			;    adc hl,hl 
8b0b			;    add a,a 
8b0b			;    adc hl,hl 
8b0b			;    djnz Sqr16_Loop 
8b0b			;    ret 
8b0b			; 
8b0b			; 
8b0b			; Divide 8-bit values 
8b0b			; In: Divide E by divider C 
8b0b			; Out: A = result, B = rest 
8b0b			; 
8b0b			Div8: 
8b0b af			    xor a 
8b0c 06 08		    ld b,8 
8b0e			Div8_Loop: 
8b0e cb 13		    rl e 
8b10 17			    rla 
8b11 91			    sub c 
8b12 30 01		    jr nc,Div8_NoAdd 
8b14 81			    add a,c 
8b15			Div8_NoAdd: 
8b15 10 f7		    djnz Div8_Loop 
8b17 47			    ld b,a 
8b18 7b			    ld a,e 
8b19 17			    rla 
8b1a 2f			    cpl 
8b1b c9			    ret 
8b1c			 
8b1c			; 
8b1c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8b1c			; In: Multiply A with DE 
8b1c			; Out: HL = result 
8b1c			; 
8b1c			Mult12U: 
8b1c 2e 00		    ld l,0 
8b1e 87			    add a,a 
8b1f 30 01		    jr nc,Mult12U_NoAdd0 
8b21 19			    add hl,de 
8b22			Mult12U_NoAdd0: 
8b22 29			    add hl,hl 
8b23 87			    add a,a 
8b24 30 01		    jr nc,Mult12U_NoAdd1 
8b26 19			    add hl,de 
8b27			Mult12U_NoAdd1: 
8b27 29			    add hl,hl 
8b28 87			    add a,a 
8b29 30 01		    jr nc,Mult12U_NoAdd2 
8b2b 19			    add hl,de 
8b2c			Mult12U_NoAdd2: 
8b2c 29			    add hl,hl 
8b2d 87			    add a,a 
8b2e 30 01		    jr nc,Mult12U_NoAdd3 
8b30 19			    add hl,de 
8b31			Mult12U_NoAdd3: 
8b31 29			    add hl,hl 
8b32 87			    add a,a 
8b33 30 01		    jr nc,Mult12U_NoAdd4 
8b35 19			    add hl,de 
8b36			Mult12U_NoAdd4: 
8b36 29			    add hl,hl 
8b37 87			    add a,a 
8b38 30 01		    jr nc,Mult12U_NoAdd5 
8b3a 19			    add hl,de 
8b3b			Mult12U_NoAdd5: 
8b3b 29			    add hl,hl 
8b3c 87			    add a,a 
8b3d 30 01		    jr nc,Mult12U_NoAdd6 
8b3f 19			    add hl,de 
8b40			Mult12U_NoAdd6: 
8b40 29			    add hl,hl 
8b41 87			    add a,a 
8b42 d0			    ret nc 
8b43 19			    add hl,de 
8b44 c9			    ret 
8b45			 
8b45			; 
8b45			; Multiply 8-bit value with a 16-bit value (right rotating) 
8b45			; In: Multiply A with DE 
8b45			;      Put lowest value in A for most efficient calculation 
8b45			; Out: HL = result 
8b45			; 
8b45			Mult12R: 
8b45 21 00 00		    ld hl,0 
8b48			Mult12R_Loop: 
8b48 cb 3f		    srl a 
8b4a 30 01		    jr nc,Mult12R_NoAdd 
8b4c 19			    add hl,de 
8b4d			Mult12R_NoAdd: 
8b4d cb 23		    sla e 
8b4f cb 12		    rl d 
8b51 b7			    or a 
8b52 c2 48 8b		    jp nz,Mult12R_Loop 
8b55 c9			    ret 
8b56			 
8b56			; 
8b56			; Multiply 16-bit values (with 32-bit result) 
8b56			; In: Multiply BC with DE 
8b56			; Out: BCHL = result 
8b56			; 
8b56			Mult32: 
8b56 79			    ld a,c 
8b57 48			    ld c,b 
8b58 21 00 00		    ld hl,0 
8b5b 06 10		    ld b,16 
8b5d			Mult32_Loop: 
8b5d 29			    add hl,hl 
8b5e 17			    rla 
8b5f cb 11		    rl c 
8b61 30 07		    jr nc,Mult32_NoAdd 
8b63 19			    add hl,de 
8b64 ce 00		    adc a,0 
8b66 d2 6a 8b		    jp nc,Mult32_NoAdd 
8b69 0c			    inc c 
8b6a			Mult32_NoAdd: 
8b6a 10 f1		    djnz Mult32_Loop 
8b6c 41			    ld b,c 
8b6d 4f			    ld c,a 
8b6e c9			    ret 
8b6f			 
8b6f			 
8b6f			 
8b6f			; 
8b6f			; Multiply 8-bit values 
8b6f			; In:  Multiply H with E 
8b6f			; Out: HL = result 
8b6f			; 
8b6f			Mult8: 
8b6f 16 00		    ld d,0 
8b71 6a			    ld l,d 
8b72 06 08		    ld b,8 
8b74			Mult8_Loop: 
8b74 29			    add hl,hl 
8b75 30 01		    jr nc,Mult8_NoAdd 
8b77 19			    add hl,de 
8b78			Mult8_NoAdd: 
8b78 10 fa		    djnz Mult8_Loop 
8b7a c9			    ret 
8b7b			 
8b7b			 
8b7b			 
8b7b			 
8b7b			 
8b7b			 
8b7b			 
8b7b			 
8b7b			;;http://z80-heaven.wikidot.com/math 
8b7b			;;This divides DE by BC, storing the result in DE, remainder in HL 
8b7b			; 
8b7b			;DE_Div_BC:          ;1281-2x, x is at most 16 
8b7b			;     ld a,16        ;7 
8b7b			;     ld hl,0        ;10 
8b7b			;     jp $+5         ;10 
8b7b			;.DivLoop: 
8b7b			;       add hl,bc    ;-- 
8b7b			;       dec a        ;64 
8b7b			;       jr z,.DivLoopEnd        ;86 
8b7b			; 
8b7b			;       sla e        ;128 
8b7b			;       rl d         ;128 
8b7b			;       adc hl,hl    ;240 
8b7b			;       sbc hl,bc    ;240 
8b7b			;       jr nc,.DivLoop ;23|21 
8b7b			;       inc e        ;-- 
8b7b			;       jp .DivLoop+1 
8b7b			; 
8b7b			;.DivLoopEnd: 
8b7b			 
8b7b			;HL_Div_C: 
8b7b			;Inputs: 
8b7b			;     HL is the numerator 
8b7b			;     C is the denominator 
8b7b			;Outputs: 
8b7b			;     A is the remainder 
8b7b			;     B is 0 
8b7b			;     C is not changed 
8b7b			;     DE is not changed 
8b7b			;     HL is the quotient 
8b7b			; 
8b7b			;       ld b,16 
8b7b			;       xor a 
8b7b			;         add hl,hl 
8b7b			;         rla 
8b7b			;         cp c 
8b7b			;         jr c,$+4 
8b7b			;           inc l 
8b7b			;           sub c 
8b7b			;         djnz $-7 
8b7b			 
8b7b			; https://plutiedev.com/z80-add-8bit-to-16bit 
8b7b			 
8b7b			addatohl: 
8b7b 85			    add   a, l    ; A = A+L 
8b7c 6f			    ld    l, a    ; L = A+L 
8b7d 8c			    adc   a, h    ; A = A+L+H+carry 
8b7e 95			    sub   l       ; A = H+carry 
8b7f 67			    ld    h, a    ; H = H+carry 
8b80 c9			ret 
8b81			 
8b81			addatode: 
8b81 83			    add   a, e    ; A = A+L 
8b82 5f			    ld    e, a    ; L = A+L 
8b83 8a			    adc   a, d    ; A = A+L+H+carry 
8b84 93			    sub   e       ; A = H+carry 
8b85 57			    ld    d, a    ; H = H+carry 
8b86 c9			ret 
8b87			 
8b87			 
8b87			addatobc: 
8b87 81			    add   a, c    ; A = A+L 
8b88 4f			    ld    c, a    ; L = A+L 
8b89 88			    adc   a, b    ; A = A+L+H+carry 
8b8a 91			    sub   c       ; A = H+carry 
8b8b 47			    ld    b, a    ; H = H+carry 
8b8c c9			ret 
8b8d			 
8b8d			subafromhl: 
8b8d			   ; If A=0 do nothing 
8b8d			    ; Otherwise flip A's sign. Since 
8b8d			    ; the upper byte becomes -1, also 
8b8d			    ; substract 1 from H. 
8b8d ed 44		    neg 
8b8f ca 98 8b		    jp    z, Skip 
8b92 25			    dec   h 
8b93			     
8b93			    ; Now add the low byte as usual 
8b93			    ; Two's complement takes care of 
8b93			    ; ensuring the result is correct 
8b93 85			    add   a, l 
8b94 6f			    ld    l, a 
8b95 8c			    adc   a, h 
8b96 95			    sub   l 
8b97 67			    ld    h, a 
8b98			Skip: 
8b98 c9				ret 
8b99			 
8b99			 
8b99			; compare hl and de 
8b99			; returns:  
8b99			; if hl = de, z=1, s=0, c0=0 
8b99			; if hl > de, z=0, s=0, c=0 
8b99			; if hl < de, z=0, s=1, c=1 
8b99			cmp16:	 
8b99 b7				or a 
8b9a ed 52			sbc hl,de 
8b9c e0				ret po 
8b9d 7c				ld a,h 
8b9e 1f				rra 
8b9f ee 40			xor 01000000B 
8ba1 37				scf 
8ba2 8f				adc a,a 
8ba3 c9				ret 
8ba4			 
8ba4			 
8ba4			; test if hl contains zero   - A is destroyed 
8ba4			 
8ba4			ishlzero:    
8ba4 b7				or a     ; reset flags 
8ba5 7c				ld a, h 
8ba6 b5				or l        	 
8ba7			 
8ba7 c9				ret 
8ba8			 
8ba8			 
8ba8			 
8ba8			 
8ba8			if FORTH_ENABLE_FLOATMATH 
8ba8			;include "float/bbcmath.z80" 
8ba8			include "float/lpfpcalc.asm" 
8ba8			endif 
8ba8			 
8ba8			 
8ba8			; eof 
8ba8			 
# End of file firmware_maths.asm
8ba8			include "firmware_strings.asm"   ; string handling  
8ba8			 
8ba8			 
8ba8			; TODO string len 
8ba8			; input text string, end on cr with zero term 
8ba8			; a offset into frame buffer to start prompt 
8ba8			; d is max length 
8ba8			; e is display size TODO 
8ba8			; c is current cursor position 
8ba8			; hl is ptr to where string will be stored 
8ba8			 
8ba8			 
8ba8			; TODO check limit of buffer for new inserts 
8ba8			; TODO check insert does not push beyond buffer 
8ba8			; TODO scroll in a limited display area 
8ba8			; TODO scroll whole screen on page wrap 
8ba8			 
8ba8			 
8ba8			; TODO handle KEY_PREVWORD 
8ba8			; TODO handle KEY_NEXTWORD 
8ba8			; TODO handle KEY_HOME 
8ba8			; TODO handle KEY_END 
8ba8			; TODO use LCD cursor? 
8ba8			 
8ba8 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8bab 81					add c 
8bac 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8baf 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8bb2 79					ld a, c 
8bb3 cd 7b 8b				call addatohl 
8bb6 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8bb9 7a					ld a,d 
8bba 32 6c ee			        ld (input_size), a       ; save length of input area 
8bbd 79					ld a, c 
8bbe 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8bc1 7b					ld a,e 
8bc2 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8bc5					 
8bc5					 
8bc5			 
8bc5			;		ld a,(input_ptr) 
8bc5			;		ld (input_under_cursor),a 	; save what is under the cursor 
8bc5			 
8bc5			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8bc5					; init cursor shape if not set by the cin routines 
8bc5 21 ca eb				ld hl, cursor_shape 
8bc8 3e ff				ld a, 255 
8bca 77					ld (hl), a 
8bcb 23					inc hl 
8bcc 3e 00				ld a, 0 
8bce 77					ld (hl), a 
8bcf			 
8bcf 3e 0f				ld a, CUR_BLINK_RATE 
8bd1 32 66 ee				ld (input_cur_flash), a 
8bd4 3e 01				ld a, 1 
8bd6 32 65 ee				ld (input_cur_onoff),a 
8bd9			 
8bd9			;	if DEBUG_INPUT 
8bd9			;		push af 
8bd9			;		ld a, 'I' 
8bd9			;		ld (debug_mark),a 
8bd9			;		pop af 
8bd9			;		CALLMONITOR 
8bd9			;	endif 
8bd9			.is1:		; main entry loop 
8bd9			 
8bd9			 
8bd9			 
8bd9					; pause 1ms 
8bd9			 
8bd9 3e 01				ld a, 1 
8bdb cd b0 88				call aDelayInMS 
8bde			 
8bde					; dec flash counter 
8bde 3a 66 ee				ld a, (input_cur_flash) 
8be1 3d					dec a 
8be2 32 66 ee				ld (input_cur_flash), a 
8be5 fe 00				cp 0 
8be7 20 0d				jr nz, .nochgstate 
8be9			 
8be9			 
8be9					; change state 
8be9 3a 65 ee				ld a,(input_cur_onoff) 
8bec ed 44				neg 
8bee 32 65 ee				ld (input_cur_onoff),a 
8bf1			 
8bf1			 
8bf1					; reset on change of state 
8bf1 3e 0f				ld a, CUR_BLINK_RATE 
8bf3 32 66 ee				ld (input_cur_flash), a 
8bf6			 
8bf6			.nochgstate: 
8bf6					 
8bf6					 
8bf6			 
8bf6					; display cursor  
8bf6			 
8bf6			;		ld hl, (input_start) 
8bf6			;		ld a, (input_cursor) 
8bf6			;		call addatohl 
8bf6			 
8bf6					; get char under cursor and replace with cursor 
8bf6 2a 6f ee		ld hl, (input_ptr) 
8bf9			;		ld a, (hl) 
8bf9			;		ld (input_under_cursor),a 
8bf9			;		ld a, '_' 
8bf9			;		ld (hl), a 
8bf9			 
8bf9					; display string 
8bf9			 
8bf9 ed 5b 6d ee			ld de, (input_start) 
8bfd 3a 6a ee				ld a, (input_at_pos) 
8c00 cd 61 89				call str_at_display 
8c03			;	        call update_display 
8c03			 
8c03					; find place to put the cursor 
8c03			;		add h 
8c03			;		ld l, display_row_1 
8c03			;		sub l 
8c03			; (input_at_pos) 
8c03					;ld c, a 
8c03			;		ld a, (input_cursor) 
8c03			;		ld l, (input_at_pos) 
8c03			;		;ld b, h 
8c03			;		add l 
8c03			;		ld (input_at_cursor),a 
8c03					;ld l,h 
8c03			 
8c03			;		ld h, 0 
8c03			;		ld l,(input_at_pos) 
8c03			;		ld a, (input_cursor) 
8c03			;		call addatohl 
8c03			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8c03			;		call subafromhl 
8c03			;		ld a,l 
8c03			;		ld (input_at_cursor), a 
8c03			 
8c03				if DEBUG_INPUT 
8c03					ld a, (hardware_diag) 
8c03					cp 0 
8c03					jr z, .skip_input_diag 
8c03			 
8c03					ld a,(input_at_pos) 
8c03					ld hl, LFSRSeed 
8c03					call hexout 
8c03					ld a, (input_cursor) 
8c03					ld hl, LFSRSeed+2 
8c03					call hexout 
8c03					ld a,(input_at_cursor) 
8c03					ld hl, LFSRSeed+4 
8c03					call hexout 
8c03			 
8c03					ld a,(input_cur_onoff) 
8c03					ld hl, LFSRSeed+6 
8c03					call hexout 
8c03			 
8c03					ld a,(input_cur_flash) 
8c03					ld hl, LFSRSeed+8 
8c03					call hexout 
8c03			 
8c03					ld a,(input_len) 
8c03					ld hl, LFSRSeed+10 
8c03					call hexout 
8c03					ld hl, LFSRSeed+12 
8c03					ld a, 0 
8c03					ld (hl),a 
8c03					ld a, display_row_4 
8c03					ld de, LFSRSeed 
8c03					call str_at_display 
8c03					.skip_input_diag: 
8c03				endif 
8c03			 
8c03					; decide on if we are showing the cursor this time round 
8c03			 
8c03 3a 65 ee				ld a, (input_cur_onoff) 
8c06 fe ff				cp 255 
8c08 28 13				jr z, .skipcur 
8c0a			 
8c0a			 
8c0a 3a 68 ee				ld a,(input_at_cursor) 
8c0d 11 ca eb				ld de, cursor_shape 
8c10 cd 61 89				call str_at_display 
8c13			 
8c13					; save length of current input string 
8c13 2a 6d ee				ld hl, (input_start) 
8c16 cd d9 8f				call strlenz 
8c19 7d					ld a,l 
8c1a 32 60 ee				ld (input_len),a 
8c1d			 
8c1d			.skipcur: 
8c1d			 
8c1d cd 71 89			        call update_display 
8c20					 
8c20			 
8c20			 
8c20					; wait 
8c20				 
8c20					; TODO loop without wait to flash the cursor and char under cursor	 
8c20 cd dc d8				call cin    ; _wait 
8c23			 
8c23 fe 00				cp 0 
8c25 ca d9 8b				jp z, .is1 
8c28			 
8c28					; get ptr to char to input into 
8c28			 
8c28 4f					ld c,a 
8c29 2a 6d ee				ld hl, (input_start) 
8c2c 3a 5b ee				ld a, (input_cursor) 
8c2f cd 7b 8b				call addatohl 
8c32 22 6f ee				ld (input_ptr), hl 
8c35 79					ld a,c 
8c36			 
8c36					; replace char under cursor 
8c36			 
8c36			;		ld hl, (input_ptr) 
8c36			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8c36			;		ld (hl), a 
8c36			 
8c36			;	if DEBUG_INPUT 
8c36			;		push af 
8c36			;		ld a, 'i' 
8c36			;		ld (debug_mark),a 
8c36			;		pop af 
8c36			;		CALLMONITOR 
8c36			;	endif 
8c36 fe 0e				cp KEY_HOME 
8c38 20 0e				jr nz, .iske 
8c3a			 
8c3a 3a 6a ee				ld a, (input_at_pos) 
8c3d 32 68 ee				ld (input_at_cursor),a 
8c40 3e 00				ld a, 0 
8c42 32 5b ee				ld (input_cursor), a 
8c45 c3 d9 8b				jp .is1 
8c48					 
8c48 fe 0f		.iske:		cp KEY_END 
8c4a 20 03				jr nz, .isknw 
8c4c c3 d9 8b				jp .is1 
8c4f			 
8c4f fe 06		.isknw:		cp KEY_NEXTWORD 
8c51 20 1b				jr nz, .iskpw 
8c53			 
8c53 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8c56 7e					ld a,(hl)	 
8c57 fe 00				cp 0 
8c59 ca d9 8b				jp z, .is1    ; end of string 
8c5c fe 20				cp ' ' 
8c5e ca d9 8b				jp z, .is1    ; end of word 
8c61 23					inc hl 
8c62 22 6f ee				ld (input_ptr), hl 
8c65 3a 68 ee				ld a, (input_at_cursor) 
8c68 3c					inc a 
8c69 32 68 ee				ld (input_at_cursor), a 
8c6c 18 e5				jr .isknwm 
8c6e			 
8c6e fe 07		.iskpw:		cp KEY_PREVWORD 
8c70 20 1b				jr nz, .iskl 
8c72			.iskpwm:	 
8c72 2a 6f ee				ld hl, (input_ptr) 
8c75 7e					ld a,(hl)	 
8c76 fe 00				cp 0  
8c78 ca d9 8b				jp z, .is1    ; end of string 
8c7b fe 20				cp ' ' 
8c7d ca d9 8b				jp z, .is1    ; end of word 
8c80 2b					dec hl 
8c81 22 6f ee				ld (input_ptr), hl 
8c84 3a 68 ee				ld a, (input_at_cursor) 
8c87 3d					dec a 
8c88 32 68 ee				ld (input_at_cursor), a 
8c8b 18 e5				jr .iskpwm 
8c8d			 
8c8d			 
8c8d fe 0b		.iskl:		cp KEY_LEFT 
8c8f 20 27				jr nz, .isk1 
8c91			 
8c91 3a 5b ee				ld a, (input_cursor) 
8c94			 
8c94 fe 00				cp 0 
8c96 ca d9 8b				jp z, .is1 		; at start of line to ignore  
8c99			 
8c99 3d					dec  a 		; TODO check underflow 
8c9a 32 5b ee				ld (input_cursor), a 
8c9d			 
8c9d 2a 6f ee				ld hl, (input_ptr) 
8ca0 2b					dec hl 
8ca1 22 6f ee				ld (input_ptr), hl 
8ca4					 
8ca4 3a 68 ee				ld a, (input_at_cursor) 
8ca7 3d					dec a 
8ca8 32 68 ee				ld (input_at_cursor), a 
8cab			 
8cab 3e 01				ld a, 1		; show cursor moving 
8cad 32 65 ee				ld (input_cur_onoff),a 
8cb0 3e 0f				ld a, CUR_BLINK_RATE 
8cb2 32 66 ee				ld (input_cur_flash), a 
8cb5			 
8cb5 c3 d9 8b				jp .is1 
8cb8			 
8cb8 fe 0c		.isk1:		cp KEY_RIGHT 
8cba 20 2a				jr nz, .isk2 
8cbc			 
8cbc 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8cbf 5f					ld e,a 
8cc0 3a 5b ee				ld a, (input_cursor) 
8cc3 bb					cp e 
8cc4 ca d9 8b				jp z, .is1		; at the end of string so dont go right 
8cc7			 
8cc7 3c					inc  a 		; TODO check overflow 
8cc8 32 5b ee				ld (input_cursor), a 
8ccb			 
8ccb 3a 68 ee				ld a, (input_at_cursor) 
8cce 3c					inc a 
8ccf 32 68 ee				ld (input_at_cursor), a 
8cd2			 
8cd2 2a 6f ee				ld hl, (input_ptr) 
8cd5 23					inc hl 
8cd6 22 6f ee				ld (input_ptr), hl 
8cd9			 
8cd9 3e 01				ld a, 1		; show cursor moving 
8cdb 32 65 ee				ld (input_cur_onoff),a 
8cde 3e 0f				ld a, CUR_BLINK_RATE 
8ce0 32 66 ee				ld (input_cur_flash), a 
8ce3			 
8ce3 c3 d9 8b				jp .is1 
8ce6			 
8ce6 fe 05		.isk2:		cp KEY_UP 
8ce8			 
8ce8 20 26				jr nz, .isk3 
8cea			 
8cea					; swap last command with the current on 
8cea			 
8cea					; move cursor to start of string 
8cea 2a 6d ee				ld hl, (input_start) 
8ced 22 6f ee				ld (input_ptr), hl 
8cf0			 
8cf0 3a 6a ee				ld a, (input_at_pos) 
8cf3 32 68 ee				ld (input_at_cursor), a 
8cf6			 
8cf6 3e 00				ld a, 0 
8cf8 32 5b ee				ld (input_cursor), a 
8cfb					 
8cfb					; swap input and last command buffers 
8cfb			 
8cfb 21 7e e6				ld hl, os_cli_cmd 
8cfe 11 7d e7				ld de, os_last_cmd 
8d01 06 ff				ld b, 255 
8d03 7e			.swap1:		ld a, (hl) 
8d04 4f					ld c,a 
8d05 1a					ld a, (de) 
8d06 77					ld (hl), a 
8d07 79					ld a,c 
8d08 12					ld (de),a 
8d09 23					inc hl 
8d0a 13					inc de 
8d0b 10 f6				djnz .swap1 
8d0d			 
8d0d			 
8d0d			 
8d0d			 
8d0d			 
8d0d c3 d9 8b				jp .is1 
8d10			 
8d10 fe 08		.isk3:		cp KEY_BS 
8d12 20 3c				jr nz, .isk4 
8d14			 
8d14 3a 5b ee				ld a, (input_cursor) 
8d17			 
8d17 fe 00				cp 0 
8d19 ca d9 8b				jp z, .is1 		; at start of line to ignore  
8d1c			 
8d1c 3d					dec  a 		; TODO check underflow 
8d1d 32 5b ee				ld (input_cursor), a 
8d20			 
8d20					; hl is source 
8d20					; de needs to be source - 1 
8d20			 
8d20			;		ld a, 0 
8d20			;		dec hl 
8d20			;		ld (hl), a 
8d20			 
8d20 2a 6f ee				ld hl, (input_ptr) 
8d23 2b					dec hl 
8d24 22 6f ee				ld (input_ptr), hl 
8d27			 
8d27					; shift all data 
8d27			 
8d27 e5					push hl 
8d28 23					inc hl 
8d29 d1					pop de 
8d2a 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8d2d 4f					ld c,a 
8d2e 06 00				ld b,0 
8d30 ed b0				ldir  
8d32			 
8d32			 
8d32			 
8d32			 
8d32 3a 68 ee				ld a, (input_at_cursor) 
8d35 3d					dec a 
8d36 32 68 ee				ld (input_at_cursor), a 
8d39			 
8d39			 
8d39 3e 01				ld a, 1		; show cursor moving 
8d3b 32 65 ee				ld (input_cur_onoff),a 
8d3e 3e 0f				ld a, CUR_BLINK_RATE 
8d40 32 66 ee				ld (input_cur_flash), a 
8d43			 
8d43					; remove char 
8d43 3a 68 ee				ld a, (input_at_cursor) 
8d46 3c					inc a 
8d47 11 d1 8d				ld de,.iblank 
8d4a cd 61 89				call str_at_display 
8d4d			 
8d4d c3 d9 8b				jp .is1 
8d50			 
8d50 fe 0d		.isk4:		cp KEY_CR 
8d52 28 6c				jr z, .endinput 
8d54			 
8d54					; else add the key press to the end 
8d54			 
8d54 4f					ld c, a			; save key pressed 
8d55			 
8d55 7e					ld a,(hl)		; get what is currently under char 
8d56			 
8d56 fe 00				cp 0			; we are at the end of the string 
8d58 20 2f				jr nz, .onchar 
8d5a					 
8d5a					; add a char to the end of the string 
8d5a				 
8d5a 71					ld (hl),c 
8d5b 23					inc hl 
8d5c			;		ld a,' ' 
8d5c			;		ld (hl),a 
8d5c			;		inc hl 
8d5c 3e 00				ld a,0 
8d5e 77					ld (hl),a 
8d5f 2b					dec hl 
8d60			 
8d60 3a 5b ee				ld a, (input_cursor) 
8d63 3c					inc a				; TODO check max string length and scroll  
8d64 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8d67							 
8d67 3a 68 ee				ld a, (input_at_cursor) 
8d6a 3c					inc a 
8d6b 32 68 ee				ld (input_at_cursor), a 
8d6e			 
8d6e 2a 6f ee				ld hl, (input_ptr) 
8d71 23					inc hl 
8d72 22 6f ee				ld (input_ptr), hl 
8d75			 
8d75 2a 6f ee				ld hl, (input_ptr) 
8d78 23					inc hl 
8d79 22 6f ee				ld (input_ptr), hl 
8d7c			;	if DEBUG_INPUT 
8d7c			;		push af 
8d7c			;		ld a, '+' 
8d7c			;		ld (debug_mark),a 
8d7c			;		pop af 
8d7c			;		CALLMONITOR 
8d7c			;	endif 
8d7c 3e 01				ld a, 1		; show cursor moving 
8d7e 32 65 ee				ld (input_cur_onoff),a 
8d81 3e 0f				ld a, CUR_BLINK_RATE 
8d83 32 66 ee				ld (input_cur_flash), a 
8d86 c3 d9 8b				jp .is1 
8d89					 
8d89			 
8d89			 
8d89					; if on a char then insert 
8d89			.onchar: 
8d89			 
8d89					; TODO over flow check: make sure insert does not blow out buffer 
8d89			 
8d89					; need to do some maths to use lddr 
8d89			 
8d89 e5					push hl   ; save char pos 
8d8a c5					push bc 
8d8b			 
8d8b 2a 6d ee				ld hl, (input_start) 
8d8e 3a 60 ee				ld a, (input_len) 
8d91 cd 7b 8b				call addatohl  		; end of string 
8d94 23					inc hl 
8d95 23					inc hl		; past zero term 
8d96 e5					push hl 
8d97 23					inc hl 
8d98 e5					push hl  
8d99			 
8d99								; start and end of lddr set, now how much to move? 
8d99			 
8d99							 
8d99 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8d9c 47					ld b,a 
8d9d 3a 60 ee				ld a,(input_len) 
8da0 5f					ld e,a 
8da1 90					sub b 
8da2 3c					inc a		;?? 
8da3 3c					inc a		;?? 
8da4 3c					inc a		;?? 
8da5			 
8da5 06 00				ld b,0 
8da7 4f					ld c,a 
8da8			 
8da8				if DEBUG_INPUT 
8da8					push af 
8da8					ld a, 'i' 
8da8					ld (debug_mark),a 
8da8					pop af 
8da8			;		CALLMONITOR 
8da8				endif 
8da8 d1					pop de 
8da9 e1					pop hl 
8daa				if DEBUG_INPUT 
8daa					push af 
8daa					ld a, 'I' 
8daa					ld (debug_mark),a 
8daa					pop af 
8daa			;		CALLMONITOR 
8daa				endif 
8daa ed b8				lddr 
8dac				 
8dac			 
8dac			 
8dac					; TODO have a key for insert/overwrite mode???? 
8dac c1					pop bc 
8dad e1					pop hl 
8dae 71					ld (hl), c		; otherwise overwrite current char 
8daf					 
8daf			 
8daf			 
8daf			 
8daf 3a 5b ee				ld a, (input_cursor) 
8db2 3c					inc  a 		; TODO check overflow 
8db3 32 5b ee				ld (input_cursor), a 
8db6			 
8db6 3a 68 ee				ld a, (input_at_cursor) 
8db9 3c					inc a 
8dba 32 68 ee				ld (input_at_cursor), a 
8dbd			 
8dbd c3 d9 8b				jp .is1 
8dc0			 
8dc0			.endinput:	; TODO look for end of string 
8dc0			 
8dc0					; add trailing space for end of token 
8dc0			 
8dc0 2a 6d ee				ld hl, (input_start) 
8dc3 3a 60 ee				ld a,(input_len) 
8dc6 cd 7b 8b				call addatohl 
8dc9 3e 20				ld a, ' ' 
8dcb 77					ld (hl),a 
8dcc					; TODO eof of parse marker 
8dcc			 
8dcc 23					inc hl 
8dcd 3e 00				ld a, 0 
8dcf 77					ld (hl),a 
8dd0			 
8dd0			 
8dd0 c9					ret 
8dd1			 
8dd1 .. 00		.iblank: db " ",0 
8dd3			 
8dd3			 
8dd3 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8dd6 22 6d ee				ld (input_start), hl 
8dd9 3e 01				ld a,1			; add cursor 
8ddb 77					ld (hl),a 
8ddc 23					inc hl 
8ddd 3e 00				ld a,0 
8ddf 77					ld (hl),a 
8de0 22 6f ee				ld (input_ptr), hl 
8de3 7a					ld a,d 
8de4 32 6c ee				ld (input_size), a 
8de7 3e 00				ld a,0 
8de9 32 5b ee				ld (input_cursor),a 
8dec			.instr1:	 
8dec			 
8dec					; TODO do block cursor 
8dec					; TODO switch cursor depending on the modifer key 
8dec			 
8dec					; update cursor shape change on key hold 
8dec			 
8dec 2a 6f ee				ld hl, (input_ptr) 
8def 2b					dec hl 
8df0 3a ca eb				ld a,(cursor_shape) 
8df3 77					ld (hl), a 
8df4			 
8df4					; display entered text 
8df4 3a 6a ee				ld a,(input_at_pos) 
8df7 cd 3a d8		            	CALL fLCD_Pos       ;Position cursor to location in A 
8dfa ed 5b 6d ee	            	LD   de, (input_start) 
8dfe cd 34 d8		            	CALL fLCD_Str       ;Display string pointed to by DE 
8e01			 
8e01 cd dc d8				call cin 
8e04 fe 00				cp 0 
8e06 28 e4				jr z, .instr1 
8e08			 
8e08					; proecess keyboard controls first 
8e08			 
8e08 2a 6f ee				ld hl,(input_ptr) 
8e0b			 
8e0b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8e0d 28 5a				jr z, .instrcr 
8e0f			 
8e0f fe 08				cp KEY_BS 	; back space 
8e11 20 0f				jr nz, .instr2 
8e13					; process back space 
8e13			 
8e13					; TODO stop back space if at start of string 
8e13 2b					dec hl 
8e14 2b					dec hl ; to over write cursor 
8e15 3a ca eb				ld a,(cursor_shape) 
8e18					;ld a,0 
8e18 77					ld (hl),a 
8e19 23					inc hl 
8e1a 3e 20				ld a," " 
8e1c 77					ld (hl),a 
8e1d 22 6f ee				ld (input_ptr),hl 
8e20					 
8e20			 
8e20 18 ca				jr .instr1 
8e22			 
8e22 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8e24 20 06				jr nz, .instr3 
8e26 2b					dec hl 
8e27 22 6f ee				ld (input_ptr),hl 
8e2a 18 c0				jr .instr1 
8e2c				 
8e2c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8e2e 20 06				jr nz, .instr4 
8e30 23					inc hl 
8e31 22 6f ee				ld (input_ptr),hl 
8e34 18 b6				jr .instr1 
8e36			 
8e36 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8e38 20 06				jr nz, .instr5 
8e3a 2b					dec hl 
8e3b 22 6f ee				ld (input_ptr),hl 
8e3e 18 ac				jr .instr1 
8e40			 
8e40 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8e42 20 06				jr nz, .instr6 
8e44 2b					dec hl 
8e45 22 6f ee				ld (input_ptr),hl 
8e48 18 a2				jr .instr1 
8e4a fe 05		.instr6:        cp KEY_UP      ; recall last command 
8e4c 20 0b				jr nz, .instrnew 
8e4e			 
8e4e 21 57 e3			ld hl, scratch 
8e51 11 7d e7			ld de, os_last_cmd 
8e54 cd 72 8e			call strcpy 
8e57 18 93				jr .instr1 
8e59			 
8e59			 
8e59			.instrnew:	; no special key pressed to see if we have room to store it 
8e59			 
8e59					; TODO do string size test 
8e59			 
8e59 2b					dec hl ; to over write cursor 
8e5a 77					ld (hl),a 
8e5b 23					inc hl 
8e5c 3a ca eb				ld a,(cursor_shape) 
8e5f 77					ld (hl),a 
8e60 23					inc hl 
8e61 3e 00				ld a,0 
8e63 77					ld (hl),a 
8e64			 
8e64 22 6f ee				ld (input_ptr),hl 
8e67					 
8e67 18 83				jr .instr1 
8e69 2b			.instrcr:	dec hl		; remove cursor 
8e6a 3e 20				ld a,' '	; TODO add a trailing space for safety 
8e6c 77					ld (hl),a 
8e6d 23					inc hl 
8e6e 3e 00				ld a,0 
8e70 77					ld (hl),a 
8e71			 
8e71			 
8e71					; if at end of line scroll up    
8e71					; TODO detecting only end of line 4 for scroll up  
8e71			 
8e71					;ld   
8e71			 
8e71 c9					ret 
8e72			 
8e72			 
8e72			; strcpy hl = dest, de source 
8e72			 
8e72 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8e73 b7			            OR   A              ;Null terminator? 
8e74 c8			            RET  Z              ;Yes, so finished 
8e75 1a					ld a,(de) 
8e76 77					ld (hl),a 
8e77 13			            INC  DE             ;Point to next character 
8e78 23					inc hl 
8e79 18 f7		            JR   strcpy       ;Repeat 
8e7b c9					ret 
8e7c			 
8e7c			 
8e7c			; TODO string_at  
8e7c			; pass string which starts with lcd offset address and then null term string 
8e7c			 
8e7c			; TODO string to dec 
8e7c			; TODO string to hex 
8e7c			; TODO byte to string hex 
8e7c			; TODO byte to string dec 
8e7c			 
8e7c			 
8e7c			 
8e7c			; from z80uartmonitor 
8e7c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e7c			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8e7c			; pass hl for where to put the text 
8e7c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e7c c5			hexout:	PUSH BC 
8e7d f5					PUSH AF 
8e7e 47					LD B, A 
8e7f					; Upper nybble 
8e7f cb 3f				SRL A 
8e81 cb 3f				SRL A 
8e83 cb 3f				SRL A 
8e85 cb 3f				SRL A 
8e87 cd 97 8e				CALL tohex 
8e8a 77					ld (hl),a 
8e8b 23					inc hl	 
8e8c					 
8e8c					; Lower nybble 
8e8c 78					LD A, B 
8e8d e6 0f				AND 0FH 
8e8f cd 97 8e				CALL tohex 
8e92 77					ld (hl),a 
8e93 23					inc hl	 
8e94					 
8e94 f1					POP AF 
8e95 c1					POP BC 
8e96 c9					RET 
8e97					 
8e97			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e97			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8e97			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e97			tohex: 
8e97 e5					PUSH HL 
8e98 d5					PUSH DE 
8e99 16 00				LD D, 0 
8e9b 5f					LD E, A 
8e9c 21 a4 8e				LD HL, .DATA 
8e9f 19					ADD HL, DE 
8ea0 7e					LD A, (HL) 
8ea1 d1					POP DE 
8ea2 e1					POP HL 
8ea3 c9					RET 
8ea4			 
8ea4			.DATA: 
8ea4 30					DEFB	30h	; 0 
8ea5 31					DEFB	31h	; 1 
8ea6 32					DEFB	32h	; 2 
8ea7 33					DEFB	33h	; 3 
8ea8 34					DEFB	34h	; 4 
8ea9 35					DEFB	35h	; 5 
8eaa 36					DEFB	36h	; 6 
8eab 37					DEFB	37h	; 7 
8eac 38					DEFB	38h	; 8 
8ead 39					DEFB	39h	; 9 
8eae 41					DEFB	41h	; A 
8eaf 42					DEFB	42h	; B 
8eb0 43					DEFB	43h	; C 
8eb1 44					DEFB	44h	; D 
8eb2 45					DEFB	45h	; E 
8eb3 46					DEFB	46h	; F 
8eb4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8eb4			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8eb4			;;    subtract $30, if result > 9 then subtract $7 more 
8eb4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8eb4			atohex: 
8eb4 d6 30				SUB $30 
8eb6 fe 0a				CP 10 
8eb8 f8					RET M		; If result negative it was 0-9 so we're done 
8eb9 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8ebb c9					RET		 
8ebc			 
8ebc			 
8ebc			 
8ebc			 
8ebc			; Get 2 ASCII characters as hex byte from pointer in hl 
8ebc			 
8ebc			BYTERD: 
8ebc 16 00			LD	D,00h		;Set up 
8ebe cd c6 8e			CALL	HEXCON		;Get byte and convert to hex 
8ec1 87				ADD	A,A		;First nibble so 
8ec2 87				ADD	A,A		;multiply by 16 
8ec3 87				ADD	A,A		; 
8ec4 87				ADD	A,A		; 
8ec5 57				LD	D,A		;Save hi nibble in D 
8ec6			HEXCON: 
8ec6 7e				ld a, (hl)		;Get next chr 
8ec7 23				inc hl 
8ec8 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8eca fe 0a			CP	00Ah		;Is it 0-9 ? 
8ecc 38 02			JR	C,NALPHA	;If so miss next bit 
8ece d6 07			SUB	007h		;Else convert alpha 
8ed0			NALPHA: 
8ed0 b2				OR	D		;Add hi nibble back 
8ed1 c9				RET			; 
8ed2			 
8ed2			 
8ed2			; 
8ed2			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ed2			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ed2			; characters (0-9a-f) are accepted. 
8ed2			; 
8ed2			;get_word        push    af 
8ed2			;                call    get_byte        ; Get the upper byte 
8ed2			;                ld      h, a 
8ed2			;                call    get_byte        ; Get the lower byte 
8ed2			;                ld      l, a 
8ed2			;                pop     af 
8ed2			;                ret 
8ed2			; 
8ed2			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ed2			; the routine get_nibble is used only valid characters are accepted - the  
8ed2			; input routine only accepts characters 0-9a-f. 
8ed2			; 
8ed2 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ed3 7e					ld a,(hl) 
8ed4 23					inc hl 
8ed5 cd fa 8e		                call    nibble2val      ; Get upper nibble 
8ed8 cb 07		                rlc     a 
8eda cb 07		                rlc     a 
8edc cb 07		                rlc     a 
8ede cb 07		                rlc     a 
8ee0 47			                ld      b, a            ; Save upper four bits 
8ee1 7e					ld a,(hl) 
8ee2 cd fa 8e		                call    nibble2val      ; Get lower nibble 
8ee5 b0			                or      b               ; Combine both nibbles 
8ee6 c1			                pop     bc              ; Restore B (and C) 
8ee7 c9			                ret 
8ee8			; 
8ee8			; Get a hexadecimal digit from the serial line. This routine blocks until 
8ee8			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8ee8			; to the serial line interface. The lower 4 bits of A contain the value of  
8ee8			; that particular digit. 
8ee8			; 
8ee8			;get_nibble      ld a,(hl)           ; Read a character 
8ee8			;                call    to_upper        ; Convert to upper case 
8ee8			;                call    is_hex          ; Was it a hex digit? 
8ee8			;                jr      nc, get_nibble  ; No, get another character 
8ee8			 ;               call    nibble2val      ; Convert nibble to value 
8ee8			 ;               call    print_nibble 
8ee8			 ;               ret 
8ee8			; 
8ee8			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8ee8			; A valid hexadecimal digit is denoted by a set C flag. 
8ee8			; 
8ee8			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8ee8			;                ret     nc              ; Yes 
8ee8			;                cp      '0'             ; Less than '0'? 
8ee8			;                jr      nc, is_hex_1    ; No, continue 
8ee8			;                ccf                     ; Complement carry (i.e. clear it) 
8ee8			;                ret 
8ee8			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8ee8			;                ret     c               ; Yes 
8ee8			;                cp      'A'             ; Less than 'A'? 
8ee8			;                jr      nc, is_hex_2    ; No, continue 
8ee8			;                ccf                     ; Yes - clear carry and return 
8ee8			;                ret 
8ee8			;is_hex_2        scf                     ; Set carry 
8ee8			;                ret 
8ee8			; 
8ee8			; Convert a single character contained in A to upper case: 
8ee8			; 
8ee8 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8eea d8			                ret     c 
8eeb fe 7b		                cp      'z' + 1         ; > 'z'? 
8eed d0			                ret     nc              ; Nothing to do, either 
8eee e6 5f		                and     $5f             ; Convert to upper case 
8ef0 c9			                ret 
8ef1			 
8ef1			 
8ef1			to_lower: 
8ef1			 
8ef1			   ; if char is in [A-Z] make it lower case 
8ef1			 
8ef1			   ; enter : a = char 
8ef1			   ; exit  : a = lower case char 
8ef1			   ; uses  : af 
8ef1			 
8ef1 fe 41		   cp 'A' 
8ef3 d8			   ret c 
8ef4			    
8ef4 fe 5b		   cp 'Z'+1 
8ef6 d0			   ret nc 
8ef7			    
8ef7 f6 20		   or $20 
8ef9 c9			   ret 
8efa			 
8efa			; 
8efa			; Expects a hexadecimal digit (upper case!) in A and returns the 
8efa			; corresponding value in A. 
8efa			; 
8efa fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8efc 38 02		                jr      c, nibble2val_1 ; Yes 
8efe d6 07		                sub     7               ; Adjust for A-F 
8f00 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f02 e6 0f		                and     $f              ; Only return lower 4 bits 
8f04 c9			                ret 
8f05			; 
8f05			; Print_nibble prints a single hex nibble which is contained in the lower  
8f05			; four bits of A: 
8f05			; 
8f05			;print_nibble    push    af              ; We won't destroy the contents of A 
8f05			;                and     $f              ; Just in case... 
8f05			;                add     a, '0'             ; If we have a digit we are done here. 
8f05			;                cp      '9' + 1         ; Is the result > 9? 
8f05			;                jr      c, print_nibble_1 
8f05			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f05			;print_nibble_1  call    putc            ; Print the nibble and 
8f05			;                pop     af              ; restore the original value of A 
8f05			;                ret 
8f05			;; 
8f05			;; Send a CR/LF pair: 
8f05			; 
8f05			;crlf            push    af 
8f05			;                ld      a, cr 
8f05			;                call    putc 
8f05			;                ld      a, lf 
8f05			;                call    putc 
8f05			;                pop     af 
8f05			;                ret 
8f05			; 
8f05			; Print_word prints the four hex digits of a word to the serial line. The  
8f05			; word is expected to be in HL. 
8f05			; 
8f05			;print_word      push    hl 
8f05			;                push    af 
8f05			;                ld      a, h 
8f05			;                call    print_byte 
8f05			;                ld      a, l 
8f05			;                call    print_byte 
8f05			;                pop     af 
8f05			;                pop     hl 
8f05			;                ret 
8f05			; 
8f05			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f05			; The byte to be printed is expected to be in A. 
8f05			; 
8f05			;print_byte      push    af              ; Save the contents of the registers 
8f05			;                push    bc 
8f05			;                ld      b, a 
8f05			;                rrca 
8f05			;                rrca 
8f05			;                rrca 
8f05			;                rrca 
8f05			;                call    print_nibble    ; Print high nibble 
8f05			;                ld      a, b 
8f05			;                call    print_nibble    ; Print low nibble 
8f05			;                pop     bc              ; Restore original register contents 
8f05			;                pop     af 
8f05			;                ret 
8f05			 
8f05			 
8f05			 
8f05			 
8f05			 
8f05			fourehexhl:  
8f05 7e				ld a,(hl) 
8f06 cd b4 8e			call atohex 
8f09 cb 3f				SRL A 
8f0b cb 3f				SRL A 
8f0d cb 3f				SRL A 
8f0f cb 3f				SRL A 
8f11 47				ld b, a 
8f12 23				inc hl 
8f13 7e				ld a,(hl) 
8f14 23				inc hl 
8f15 cd b4 8e			call atohex 
8f18 80				add b 
8f19 57				ld d,a 
8f1a 7e				ld a,(hl) 
8f1b cd b4 8e			call atohex 
8f1e cb 3f				SRL A 
8f20 cb 3f				SRL A 
8f22 cb 3f				SRL A 
8f24 cb 3f				SRL A 
8f26 47				ld b, a 
8f27 23				inc hl 
8f28 7e				ld a,(hl) 
8f29 23				inc hl 
8f2a cd b4 8e			call atohex 
8f2d 80				add b 
8f2e 5f				ld e, a 
8f2f d5				push de 
8f30 e1				pop hl 
8f31 c9				ret 
8f32			 
8f32			; pass hl. returns z set if the byte at hl is a digit 
8f32			;isdigithl:  
8f32			;	push bc 
8f32			;	ld a,(hl) 
8f32			;	cp ':' 
8f32			;	jr nc, .isdf 		; > 
8f32			;	cp '0' 
8f32			;	jr c, .isdf		; < 
8f32			; 
8f32			;	; TODO find a better way to set z 
8f32			; 
8f32			;	ld b,a 
8f32			;	cp b 
8f32			;	pop bc 
8f32			;	ret 
8f32			; 
8f32			;.isdf:	; not digit so clear z 
8f32			; 
8f32			;	; TODO find a better way to unset z 
8f32			; 
8f32			;	ld b,a 
8f32			;	inc b 
8f32			;	cp b 
8f32			; 
8f32			;	pop bc 
8f32			;	ret 
8f32				 
8f32				 
8f32			 
8f32			 
8f32			; pass hl as the four byte address to load 
8f32			 
8f32			get_word_hl:  
8f32 e5				push hl 
8f33 cd d2 8e			call get_byte 
8f36				 
8f36 47				ld b, a 
8f37			 
8f37 e1				pop hl 
8f38 23				inc hl 
8f39 23				inc hl 
8f3a			 
8f3a			; TODO not able to handle a-f  
8f3a 7e				ld a,(hl) 
8f3b			;	;cp ':' 
8f3b			;	cp 'g' 
8f3b			;	jr nc, .single_byte_hl 		; > 
8f3b			;	cp 'G' 
8f3b			;	jr nc, .single_byte_hl 		; > 
8f3b			;	cp '0' 
8f3b			;	jr c, .single_byte_hl		; < 
8f3b			 
8f3b				;call isdigithl 
8f3b fe 00			cp 0 
8f3d 28 06			jr z, .single_byte_hl 
8f3f			 
8f3f			.getwhln:   ; hex word so get next byte 
8f3f			 
8f3f cd d2 8e			call get_byte 
8f42 6f				ld l, a 
8f43 60				ld h,b 
8f44 c9				ret 
8f45 68			.single_byte_hl:   ld l,b 
8f46 26 00				ld h,0 
8f48 c9					ret 
8f49			 
8f49			 
8f49			 
8f49			 
8f49 21 ed 96			ld hl,asc+1 
8f4c			;	ld a, (hl) 
8f4c			;	call nibble2val 
8f4c cd d2 8e			call get_byte 
8f4f			 
8f4f			;	call fourehexhl 
8f4f 32 8b e3			ld (scratch+52),a 
8f52				 
8f52 21 89 e3			ld hl,scratch+50 
8f55 22 7a e6			ld (os_cur_ptr),hl 
8f58			 
8f58 c9				ret 
8f59			 
8f59			 
8f59			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8f59			 
8f59			; Decimal Unsigned Version 
8f59			 
8f59			;Number in a to decimal ASCII 
8f59			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8f59			;Example: display a=56 as "056" 
8f59			;input: a = number 
8f59			;Output: a=0,value of a in the screen 
8f59			;destroys af,bc (don't know about hl and de) 
8f59			DispAToASCII: 
8f59 0e 9c			ld	c,-100 
8f5b cd 65 8f			call	.Na1 
8f5e 0e f6			ld	c,-10 
8f60 cd 65 8f			call	.Na1 
8f63 0e ff			ld	c,-1 
8f65 06 2f		.Na1:	ld	b,'0'-1 
8f67 04			.Na2:	inc	b 
8f68 81				add	a,c 
8f69 38 fc			jr	c,.Na2 
8f6b 91				sub	c		;works as add 100/10/1 
8f6c f5				push af		;safer than ld c,a 
8f6d 78				ld	a,b		;char is in b 
8f6e			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8f6e f1				pop af		;safer than ld a,c 
8f6f c9				ret 
8f70			 
8f70			; Decimal Signed Version 
8f70			 
8f70			; DispA 
8f70			; -------------------------------------------------------------- 
8f70			; Converts a signed integer value to a zero-terminated ASCII 
8f70			; string representative of that value (using radix 10). 
8f70			; -------------------------------------------------------------- 
8f70			; INPUTS: 
8f70			;     HL     Value to convert (two's complement integer). 
8f70			;     DE     Base address of string destination. (pointer). 
8f70			; -------------------------------------------------------------- 
8f70			; OUTPUTS: 
8f70			;     None 
8f70			; -------------------------------------------------------------- 
8f70			; REGISTERS/MEMORY DESTROYED 
8f70			; AF HL 
8f70			; -------------------------------------------------------------- 
8f70			 
8f70			;DispHLToASCII: 
8f70			;   push    de 
8f70			;   push    bc 
8f70			; 
8f70			;; Detect sign of HL. 
8f70			;    bit    7, h 
8f70			;    jr     z, ._DoConvert 
8f70			; 
8f70			;; HL is negative. Output '-' to string and negate HL. 
8f70			;    ld     a, '-' 
8f70			;    ld     (de), a 
8f70			;    inc    de 
8f70			; 
8f70			;; Negate HL (using two's complement) 
8f70			;    xor    a 
8f70			;    sub    l 
8f70			;    ld     l, a 
8f70			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8f70			;    sbc    a, h 
8f70			;    ld     h, a 
8f70			; 
8f70			;; Convert HL to digit characters 
8f70			;._DoConvert: 
8f70			;    ld     b, 0     ; B will count character length of number 
8f70			;-   ld     a, 10 
8f70			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8f70			;    push   af 
8f70			;    inc    b 
8f70			;    ld     a, h 
8f70			;    or     l 
8f70			;    jr     nz, - 
8f70			; 
8f70			;; Retrieve digits from stack 
8f70			;-   pop    af 
8f70			;    or     $30 
8f70			;    ld     (de), a 
8f70			;    inc    de 
8f70			;    djnz   - 
8f70			; 
8f70			;; Terminate string with NULL 
8f70			;    xor    a 
8f70			;    ld     (de), a 
8f70			; 
8f70			;    pop    bc 
8f70			;    pop    de 
8f70			;    ret 
8f70			 
8f70			;Comments 
8f70			; 
8f70			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8f70			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8f70			;    Note that the output string will not be fixed-width. 
8f70			; 
8f70			;Example Usage 
8f70			; 
8f70			;    ld    hl, -1004 
8f70			;    ld    de, OP1 
8f70			;    call  DispA 
8f70			;    ld    hl, OP1 
8f70			;    syscall  PutS 
8f70			 
8f70			 
8f70			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8f70			 
8f70			 
8f70			;Converts an ASCII string to an unsigned 16-bit integer 
8f70			;Quits when it reaches a non-decimal digit 
8f70			 
8f70			string_to_uint16: 
8f70			atoui_16: 
8f70			;Input: 
8f70			;     DE points to the string 
8f70			;Outputs: 
8f70			;     HL is the result 
8f70			;     A is the 8-bit value of the number 
8f70			;     DE points to the byte after the number 
8f70			;Destroys: 
8f70			;     BC 
8f70			;       if the string is non-empty, BC is HL/10 
8f70			;Size:  24 bytes 
8f70			;Speed: 42+d(104+{0,9}) 
8f70			;       d is the number of digits in the number 
8f70			;       max is 640 cycles for a 5 digit number 
8f70			;Assuming no leading zeros: 
8f70			;1 digit:  146cc 
8f70			;2 digit:  250cc 
8f70			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8f70			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8f70			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8f70			;avg: 544.81158447265625cc (544+13297/16384) 
8f70			;=============================================================== 
8f70 21 00 00		  ld hl,0 
8f73			.u16a: 
8f73 1a			  ld a,(de) 
8f74 d6 30		  sub 30h 
8f76 fe 0a		  cp 10 
8f78 d0			  ret nc 
8f79 13			  inc de 
8f7a 44			  ld b,h 
8f7b 4d			  ld c,l 
8f7c 29			  add hl,hl 
8f7d 29			  add hl,hl 
8f7e 09			  add hl,bc 
8f7f 29			  add hl,hl 
8f80 85			  add a,l 
8f81 6f			  ld l,a 
8f82 30 ef		  jr nc,.u16a 
8f84 24			  inc h 
8f85 c3 73 8f		  jp .u16a 
8f88			 
8f88			 
8f88			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8f88			 
8f88			;written by Zeda 
8f88			;Converts a 16-bit unsigned integer to an ASCII string. 
8f88			 
8f88			uitoa_16: 
8f88			;Input: 
8f88			;   DE is the number to convert 
8f88			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8f88			;Output: 
8f88			;   HL points to the null-terminated ASCII string 
8f88			;      NOTE: This isn't necessarily the same as the input HL. 
8f88 d5			  push de 
8f89 c5			  push bc 
8f8a f5			  push af 
8f8b eb			  ex de,hl 
8f8c			 
8f8c 01 f0 d8		  ld bc,-10000 
8f8f 3e 2f		  ld a,'0'-1 
8f91 3c			  inc a 
8f92 09			  add hl,bc  
8f93 38 fc		   jr c,$-2 
8f95 12			  ld (de),a 
8f96 13			  inc de 
8f97			 
8f97 01 e8 03		  ld bc,1000 
8f9a 3e 3a		  ld a,'9'+1 
8f9c 3d			  dec a  
8f9d 09			  add hl,bc  
8f9e 30 fc		   jr nc,$-2 
8fa0 12			  ld (de),a 
8fa1 13			  inc de 
8fa2			 
8fa2 01 9c ff		  ld bc,-100 
8fa5 3e 2f		  ld a,'0'-1 
8fa7 3c			  inc a  
8fa8 09			  add hl,bc  
8fa9 38 fc		   jr c,$-2 
8fab 12			  ld (de),a 
8fac 13			  inc de 
8fad			 
8fad 7d			  ld a,l 
8fae 26 3a		  ld h,'9'+1 
8fb0 25			  dec h  
8fb1 c6 0a		  add a,10  
8fb3 30 fb		   jr nc,$-3 
8fb5 c6 30		  add a,'0' 
8fb7 eb			  ex de,hl 
8fb8 72			  ld (hl),d 
8fb9 23			  inc hl 
8fba 77			  ld (hl),a 
8fbb 23			  inc hl 
8fbc 36 00		  ld (hl),0 
8fbe			 
8fbe			;Now strip the leading zeros 
8fbe 0e fa		  ld c,-6 
8fc0 09			  add hl,bc 
8fc1 3e 30		  ld a,'0' 
8fc3 23			  inc hl  
8fc4 be			  cp (hl)  
8fc5 28 fc		  jr z,$-2 
8fc7			 
8fc7			;Make sure that the string is non-empty! 
8fc7 7e			  ld a,(hl) 
8fc8 b7			  or a 
8fc9 20 01		  jr nz,.atoub 
8fcb 2b			  dec hl 
8fcc			.atoub: 
8fcc			 
8fcc f1			  pop af 
8fcd c1			  pop bc 
8fce d1			  pop de 
8fcf c9			  ret 
8fd0			 
8fd0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8fd0			 
8fd0			toUpper: 
8fd0			;A is the char. 
8fd0			;If A is a lowercase letter, this sets it to the matching uppercase 
8fd0			;18cc or 30cc or 41cc 
8fd0			;avg: 26.75cc 
8fd0 fe 61		  cp 'a' 
8fd2 d8			  ret c 
8fd3 fe 7b		  cp 'z'+1 
8fd5 d0			  ret nc 
8fd6 d6 20		  sub 'a'-'A' 
8fd8 c9			  ret 
8fd9			 
8fd9			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8fd9			 
8fd9			; String Length 
8fd9			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8fd9			 
8fd9			; Get the length of the null-terminated string starting at $8000 hl 
8fd9			;    LD     HL, $8000 
8fd9			 
8fd9			strlenz: 
8fd9			 
8fd9 af			    XOR    A               ; Zero is the value we are looking for. 
8fda 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8fdb 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8fdc			                           ; 65, 536 bytes (the entire addressable memory space). 
8fdc ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8fde			 
8fde			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8fde 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8fdf 6f			    LD     L, A             ; number of bytes 
8fe0 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8fe2 2b			    DEC    HL              ; Compensate for null. 
8fe3 c9				ret 
8fe4			 
8fe4			; Get the length of the A terminated string starting at $8000 hl 
8fe4			;    LD     HL, $8000 
8fe4			 
8fe4			strlent: 
8fe4			 
8fe4			                  ; A is the value we are looking for. 
8fe4 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8fe6 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8fe8			                           ; 65, 536 bytes (the entire addressable memory space). 
8fe8 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8fea			 
8fea			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8fea 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8fec 2e 00		    LD     L, 0             ; number of bytes 
8fee ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ff0 2b			    DEC    HL              ; Compensate for null. 
8ff1 c9				ret 
8ff2			 
8ff2			 
8ff2			;Comparing Strings 
8ff2			 
8ff2			;IN    HL     Address of string1. 
8ff2			;      DE     Address of string2. 
8ff2			 
8ff2			; doc given but wrong??? 
8ff2			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8ff2			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8ff2			; tested 
8ff2			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8ff2			 
8ff2			strcmp_old: 
8ff2 e5			    PUSH   HL 
8ff3 d5			    PUSH   DE 
8ff4			 
8ff4 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8ff5 be			    CP     (HL)            ; (want to minimize work). 
8ff6 38 01		    JR     C, Str1IsBigger 
8ff8 7e			    LD     A, (HL) 
8ff9			 
8ff9			Str1IsBigger: 
8ff9 4f			    LD     C, A             ; Put length in BC 
8ffa 06 00		    LD     B, 0 
8ffc 13			    INC    DE              ; Increment pointers to meat of string. 
8ffd 23			    INC    HL 
8ffe			 
8ffe			CmpLoop: 
8ffe 1a			    LD     A, (DE)          ; Compare bytes. 
8fff ed a1		    CPI 
9001 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9003 13			    INC    DE              ; Update pointer. 
9004 ea fe 8f		    JP     PE, CmpLoop 
9007			 
9007 d1			    POP    DE 
9008 e1			    POP    HL 
9009 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
900a be			    CP     (HL) 
900b c9			    RET 
900c			 
900c			NoMatch: 
900c 2b			    DEC    HL 
900d be			    CP     (HL)            ; Compare again to affect carry. 
900e d1			    POP    DE 
900f e1			    POP    HL 
9010 c9			    RET 
9011			 
9011			;; test strmp 
9011			; 
9011			;ld de, .str1 
9011			;ld hl, .str2 
9011			;call strcmp 
9011			;jr z, .z1 
9011			;;this 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "NZ1" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			;.z1: 
9011			; 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "ZZ1" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			; 
9011			;ld de, .str1 
9011			;ld hl, .str1 
9011			;call strcmp 
9011			;jr z, .z2 
9011			;;this 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "NZ2" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			;.z2: 
9011			; 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "ZZ2" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			; 
9011			;ld de, .str1 
9011			;ld hl, .str2 
9011			;call strcmp 
9011			;jr c, .c1 
9011			; 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "Nc1" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			;.c1: 
9011			;;this 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "cc1" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			; 
9011			;ld de, .str1 
9011			;ld hl, .str1 
9011			;call strcmp 
9011			;jr c, .c2 
9011			;;this 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "Nc2" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			;.c2: 
9011			; 
9011			;	if DEBUG_FORTH_WORDS 
9011			;		DMARK "cc2" 
9011			;		CALLMONITOR 
9011			;	endif 
9011			;	NEXTW 
9011			;.str1:   db "string1",0 
9011			;.str2:   db "string2",0 
9011			 
9011			; only care about direct match or not 
9011			; hl and de strings 
9011			; zero set if the same 
9011			 
9011			strcmp: 
9011 1a				ld a, (de) 
9012 be				cp (hl) 
9013 28 02			jr z, .ssame 
9015 b7				or a 
9016 c9				ret 
9017			 
9017			.ssame:  
9017 fe 00			cp 0 
9019 c8				ret z 
901a			 
901a 23				inc hl 
901b 13				inc de 
901c 18 f3			jr strcmp 
901e				 
901e				 
901e			 
901e			 
901e			 
901e			 
901e			; eof 
901e			 
901e			 
901e			 
901e			 
901e			 
901e			 
# End of file firmware_strings.asm
901e			include "firmware_memory.asm"   ; malloc and free  
901e			 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e			.mallocsize: db "Wants malloc >256",0 
901e			.mallocasize: db "MALLOC gives >256",0 
901e			.malloczero: db "MALLOC gives zero",0 
901e			 
901e			malloc_guard_zerolen: 
901e				push hl 
901e				push de 
901e				push af 
901e			 
901e				ld de, 0 
901e			        call cmp16 
901e				jr nz, .lowalloz 
901e			 
901e				push hl 
901e				push de 
901e					ld hl, display_fb0 
901e					ld (display_fb_active), hl 
901e				call clear_display 
901e				ld a, 0 
901e				ld de, .malloczero 
901e				call str_at_display 
901e				call update_display 
901e				call delay1s 
901e				call delay1s 
901e				ld a, 0 
901e				ld (os_view_disable), a 
901e			 
901e				pop de 
901e				pop hl 
901e			 
901e				 
901e			 
901e				CALLMONITOR 
901e			.lowalloz: 
901e			 
901e			 
901e				pop af 
901e				pop de 
901e				pop hl 
901e			ret 
901e			 
901e			malloc_guard_entry: 
901e				push hl 
901e				push de 
901e				push af 
901e			 
901e			 	or a      ;clear carry flag 
901e				push hl 
901e				ld de, 255 
901e				sbc hl, de 
901e				jr c, .lowalloc 
901e			 
901e				push de 
901e					ld hl, display_fb0 
901e					ld (display_fb_active), hl 
901e				call clear_display 
901e				ld a, 0 
901e				ld de, .mallocsize 
901e				call str_at_display 
901e				call update_display 
901e				call delay1s 
901e				call delay1s 
901e				ld a, 0 
901e				ld (os_view_disable), a 
901e			 
901e				pop de 
901e				pop hl 
901e			 
901e				 
901e			 
901e				CALLMONITOR 
901e				jr .lowdone 
901e			.lowalloc: 
901e			 
901e			 
901e				pop hl 
901e			.lowdone:	pop af 
901e				pop de 
901e				pop hl 
901e			ret 
901e			 
901e			malloc_guard_exit: 
901e				push hl 
901e				push de 
901e				push af 
901e			 
901e			 	or a      ;clear carry flag 
901e				push hl 
901e				ld de, 255 
901e				sbc hl, de 
901e				jr c, .lowallocx 
901e			 
901e				push de 
901e					ld hl, display_fb0 
901e					ld (display_fb_active), hl 
901e				call clear_display 
901e				ld a, 0 
901e				ld de, .mallocasize 
901e				call str_at_display 
901e				call update_display 
901e				call delay1s 
901e				call delay1s 
901e				ld a, 0 
901e				ld (os_view_disable), a 
901e				pop de 
901e				pop hl 
901e			 
901e				CALLMONITOR 
901e				jr .lowdonex 
901e			.lowallocx: 
901e			 
901e				pop hl 
901e			.lowdonex:	pop af 
901e				pop de 
901e				pop hl 
901e			ret 
901e			endif 
901e			 
901e			if MALLOC_2 
901e			; Z80 Malloc and Free Functions 
901e			 
901e			; Malloc Function: 
901e			; Input: 
901e			;   HL: Size of block to allocate 
901e			; Output: 
901e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
901e			 
901e			malloc: 
901e				 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e			call malloc_guard_entry 
901e			endif 
901e			 
901e			 
901e			 
901e			 
901e					if DEBUG_FORTH_MALLOC 
901e						DMARK "mal" 
901e						CALLMONITOR 
901e					endif 
901e			    push af            ; Save AF register 
901e			    ld a, l            ; Load low byte of size into A 
901e			    or h               ; Check if size is zero 
901e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
901e			 
901e			    ; Allocate memory 
901e			    ld hl, (heap_start) ; Load start of heap into HL 
901e					if DEBUG_FORTH_MALLOC 
901e						DMARK "ma1" 
901e						CALLMONITOR 
901e					endif 
901e			    call malloc_internal ; Call internal malloc function 
901e			    pop af             ; Restore AF register 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e			call malloc_guard_exit 
901e			call malloc_guard_zerolen 
901e			endif 
901e			    ret                ; Return 
901e			 
901e			; Free Function: 
901e			; Input: 
901e			;   HL: Pointer to memory block to free 
901e			; Output: 
901e			;   None 
901e			 
901e			free: 
901e			    push af            ; Save AF register 
901e			    ld a, l            ; Load low byte of pointer into A 
901e			    or h               ; Check if pointer is NULL 
901e			    jp z, free_exit    ; If pointer is NULL, exit 
901e			 
901e			    ; Free memory 
901e			    ld hl, (heap_start) ; Load start of heap into HL 
901e			    call free_internal  ; Call internal free function 
901e			    pop af             ; Restore AF register 
901e			    ret                ; Return 
901e			 
901e			; Internal Malloc Function: 
901e			; Input: 
901e			;   HL: Size of block to allocate 
901e			; Output: 
901e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
901e			 
901e			malloc_internal: 
901e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
901e			    add hl, bc         ; Add management overhead to requested size 
901e			    ex de, hl          ; Save total size in DE, and keep it in HL 
901e					if DEBUG_FORTH_MALLOC 
901e						DMARK "ma2" 
901e						CALLMONITOR 
901e					endif 
901e			 
901e			    ; Search for free memory block 
901e			    ld de, (heap_end)  ; Load end of heap into DE 
901e			    ld bc, 0           ; Initialize counter 
901e			 
901e					if DEBUG_FORTH_MALLOC 
901e						DMARK "ma2" 
901e						CALLMONITOR 
901e					endif 
901e			malloc_search_loop: 
901e			    ; Check if current block is free 
901e			    ld a, (hl)         ; Load current block's status (free or used) 
901e			    cp 0               ; Compare with zero (free) 
901e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
901e			 
901e			    ; Check if current block is large enough 
901e			    ld a, (hl+1)       ; Load high byte of block size 
901e			    cp l               ; Compare with low byte of requested size 
901e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
901e			 
901e			    ld a, (hl+2)       ; Load low byte of block size 
901e			    cp h               ; Compare with high byte of requested size 
901e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
901e			 
901e			    ; Mark block as used 
901e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
901e			 
901e			    ; Calculate remaining space in block 
901e			    ld bc, 0           ; Clear BC 
901e			    add hl, bc         ; Increment HL to point to start of data block 
901e			    add hl, de         ; HL = HL + DE (total size) 
901e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
901e			    add hl, bc         ; Add management overhead to start of data block 
901e			 
901e			    ; Save pointer to allocated block in HL 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e						DMARK "ma5" 
901e			call malloc_guard_exit 
901e			call malloc_guard_zerolen 
901e			endif 
901e			    ret 
901e			 
901e			malloc_skip_block_check: 
901e			    ; Move to the next block 
901e			    ld bc, 3           ; Size of management overhead 
901e			    add hl, bc         ; Move to the next block 
901e			    inc de             ; Increment counter 
901e			 
901e			    ; Check if we have reached the end of heap 
901e			    ld a, e            ; Load low byte of heap end address 
901e			    cp (hl)            ; Compare with low byte of current address 
901e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
901e			    ld a, d            ; Load high byte of heap end address 
901e			    cp 0               ; Check if it's zero (end of memory) 
901e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
901e			 
901e			    ; If we reached here, allocation failed 
901e			    xor a              ; Set result to NULL 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e						DMARK "ma6" 
901e			call malloc_guard_exit 
901e			call malloc_guard_zerolen 
901e			endif 
901e			    ret 
901e			malloc_exit: 
901e			if DEBUG_FORTH_MALLOC_HIGH 
901e						DMARK "ma7" 
901e			call malloc_guard_exit 
901e			call malloc_guard_zerolen 
901e			endif 
901e			    ret 
901e			 
901e			; Internal Free Function: 
901e			; Input: 
901e			;   HL: Pointer to memory block to free 
901e			; Output: 
901e			;   None 
901e			 
901e			free_internal: 
901e			    ld de, (heap_start) ; Load start of heap into DE 
901e			    ld bc, 0            ; Initialize counter 
901e			 
901e			free_search_loop: 
901e			    ; Check if current block contains the pointer 
901e			    ld a, l             ; Load low byte of pointer 
901e			    cp (hl+1)           ; Compare with high byte of current block's address 
901e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
901e			    ld a, h             ; Load high byte of pointer 
901e			    cp (hl+2)           ; Compare with low byte of current block's address 
901e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
901e			 
901e			    ; Mark block as free 
901e			    ld (hl), 0          ; Set status byte to indicate free block 
901e			    ret                 ; Return 
901e			 
901e			free_skip_block_check: 
901e			    ; Move to the next block 
901e			    ld bc, 3            ; Size of management overhead 
901e			    add hl, bc          ; Move to the next block 
901e			    inc de              ; Increment counter 
901e			 
901e			    ; Check if we have reached the end of heap 
901e			    ld a, e             ; Load low byte of heap end address 
901e			    cp (hl)             ; Compare with low byte of current address 
901e			    jr nz, free_search_loop  ; If not equal, continue searching 
901e			    ld a, d             ; Load high byte of heap end address 
901e			    cp 0                ; Check if it's zero (end of memory) 
901e			    jr nz, free_search_loop  ; If not zero, continue searching 
901e			 
901e			    ; If we reached here, pointer is not found in heap 
901e			    ret 
901e			 
901e			free_exit: 
901e			    ret                 ; Return 
901e			 
901e			; Define heap start and end addresses 
901e			;heap_start:    .dw 0xC000   ; Start of heap 
901e			;heap_end:      .dw 0xE000   ; End of heap 
901e			 
901e			endif 
901e			 
901e			 
901e			if MALLOC_1 
901e			 
901e			 
901e			 
901e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
901e			 
901e			;moved to firmware.asm 
901e			;heap_start        .equ  0x9000      ; Starting address of heap 
901e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
901e			 
901e			;      .org 0 
901e			;      jp    main 
901e			 
901e			 
901e			;      .org  0x100 
901e			;main: 
901e			;      ld    HL, 0x8100 
901e			;      ld    SP, HL 
901e			; 
901e			;      call  heap_init 
901e			; 
901e			;      ; Make some allocations 
901e			;      ld    HL, 12 
901e			;      call  malloc            ; Allocates 0x9004 
901e			; 
901e			;      ld    HL, 12 
901e			;      call  malloc            ; Allocates 0x9014 
901e			; 
901e			;      ld    HL, 12 
901e			;      call  malloc            ; Allocates 0x9024 
901e			; 
901e			;      ; Free some allocations 
901e			;      ld    HL, 0x9014 
901e			;      call  free 
901e			; 
901e			;      ld    HL, 0x9004 
901e			;      call  free 
901e			; 
901e			;      ld    HL, 0x9024 
901e			;      call  free 
901e			; 
901e			; 
901e			;      halt 
901e			 
901e			 
901e			;------------------------------------------------------------------------------ 
901e			;     heap_init                                                               : 
901e			;                                                                             : 
901e			; Description                                                                 : 
901e			;     Initialise the heap and make it ready for malloc and free operations.   : 
901e			;                                                                             : 
901e			;     The heap is maintained as a linked list, starting with an initial       : 
901e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
901e			;     the first free block in the heap. Each block then points to the next    : 
901e			;     free block within the heap, and the free list ends at the first block   : 
901e			;     with a null pointer to the next free block.                             : 
901e			;                                                                             : 
901e			; Parameters                                                                  : 
901e			;     Inputs are compile-time only. Two defines which specify the starting    : 
901e			;     address of the heap and its size are required, along with a memory      : 
901e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
901e			;     principally stores a pointer to the first free block in the heap.       : 
901e			;                                                                             : 
901e			; Returns                                                                     : 
901e			;     Nothing                                                                 : 
901e			;------------------------------------------------------------------------------ 
901e			heap_init: 
901e e5			      push  HL 
901f			 
901f			      ; Initialise free list struct 
901f 21 fa d8		      ld    HL, heap_start 
9022 22 f5 d8		      ld    (free_list), HL 
9025 21 00 00		      ld    HL, 0 
9028 22 f7 d8		      ld    (free_list+2), HL 
902b			 
902b			      ; Insert first free block at bottom of heap, consumes entire heap 
902b 21 39 e3		      ld    HL, heap_start+heap_size-4 
902e 22 fa d8		      ld    (heap_start), HL        ; Next block (end of free list) 
9031 21 3f 0a		      ld    HL, heap_size-4 
9034 22 fc d8		      ld    (heap_start+2), HL      ; Block size 
9037			 
9037			      ; Insert end of free list block at top of heap - two null words will 
9037			      ; terminate the free list 
9037 21 00 00		      ld    HL, 0 
903a 22 3b e3		      ld    (heap_start+heap_size-2), HL 
903d 22 39 e3		      ld    (heap_start+heap_size-4), HL 
9040			 
9040 e1			      pop   HL 
9041			 
9041 c9			      ret 
9042			 
9042			 
9042			;------------------------------------------------------------------------------ 
9042			;     malloc                                                                  : 
9042			;                                                                             : 
9042			; Description                                                                 : 
9042			;     Allocates the wanted space from the heap and returns the address of the : 
9042			;     first useable byte of the allocation.                                   : 
9042			;                                                                             : 
9042			;     Allocations can happen in one of two ways:                              : 
9042			;                                                                             : 
9042			;     1. A free block may be found which is the exact size wanted. In this    : 
9042			;        case the block is removed from the free list and retuedn to the      : 
9042			;        caller.                                                              : 
9042			;     2. A free block may be found which is larger than the size wanted. In   : 
9042			;        this case, the larger block is split into two. The first portion of  : 
9042			;        this block will become the requested space by the malloc call and    : 
9042			;        is returned to the caller. The second portion becomes a new free     : 
9042			;        block, and the free list is adjusted to maintain continuity via this : 
9042			;        newly created block.                                                 : 
9042			;                                                                             : 
9042			;     malloc does not set any initial value in the allocated space, the       : 
9042			;     caller is required to do this as required.                              : 
9042			;                                                                             : 
9042			;     This implementation of malloc uses the stack exclusively, and is        : 
9042			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9042			;     advisable to disable interrupts before calling malloc, and recommended  : 
9042			;     to avoid the use of malloc inside ISRs in general.                      : 
9042			;                                                                             : 
9042			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9042			;                                                                             : 
9042			; Parameters                                                                  : 
9042			;     HL  Number of bytes wanted                                              : 
9042			;                                                                             : 
9042			; Returns                                                                     : 
9042			;     HL  Address of the first useable byte of the allocation                 : 
9042			;                                                                             : 
9042			; Flags                                                                       : 
9042			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9042			;                                                                             : 
9042			; Stack frame                                                                 : 
9042			;       |             |                                                       : 
9042			;       +-------------+                                                       : 
9042			;       |     BC      |                                                       : 
9042			;       +-------------+                                                       : 
9042			;       |     DE      |                                                       : 
9042			;       +-------------+                                                       : 
9042			;       |     IX      |                                                       : 
9042			;       +-------------+                                                       : 
9042			;       |  prev_free  |                                                       : 
9042			;   +4  +-------------+                                                       : 
9042			;       |  this_free  |                                                       : 
9042			;   +2  +-------------+                                                       : 
9042			;       |  next_free  |                                                       : 
9042			;   +0  +-------------+                                                       : 
9042			;       |             |                                                       : 
9042			;                                                                             : 
9042			;------------------------------------------------------------------------------ 
9042			 
9042			 
9042			;malloc: 
9042			; 
9042			;	SAVESP ON 1 
9042			; 
9042			;	call malloc_code 
9042			; 
9042			;	CHECKSP ON 1 
9042			;	ret 
9042			 
9042			 
9042			malloc: 
9042 c5			      push  BC 
9043 d5			      push  DE 
9044 dd e5		      push  IX 
9046			if DEBUG_FORTH_MALLOC_HIGH 
9046			call malloc_guard_entry 
9046			endif 
9046			 
9046					if DEBUG_FORTH_MALLOC 
9046						DMARK "mal" 
9046						CALLMONITOR 
9046					endif 
9046 7c			      ld    A, H                    ; Exit if no space requested 
9047 b5			      or    L 
9048 ca 07 91		      jp    Z, malloc_early_exit 
904b			 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			; 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			;inc hl 
904b			 
904b			 
904b			 
904b			 
904b					if DEBUG_FORTH_MALLOC 
904b						DMARK "maA" 
904b						CALLMONITOR 
904b					endif 
904b			      ; Set up stack frame 
904b eb			      ex    DE, HL 
904c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
904f 39			      add   HL, SP 
9050 f9			      ld    SP, HL 
9051 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9055 dd 39		      add   IX, SP 
9057			 
9057			      ; Setup initial state 
9057 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
905a 19			      add   HL, DE 
905b			 
905b 44			      ld    B, H                    ; Move want to BC 
905c 4d			      ld    C, L 
905d			 
905d 21 f5 d8		      ld    HL, free_list           ; Store prev_free ptr to stack 
9060 dd 75 04		      ld    (IX+4), L 
9063 dd 74 05		      ld    (IX+5), H 
9066			 
9066 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
9067 23			      inc   HL 
9068 56			      ld    D, (HL) 
9069 dd 73 02		      ld    (IX+2), E 
906c dd 72 03		      ld    (IX+3), D 
906f eb			      ex    DE, HL                  ; this_free ptr into HL 
9070			 
9070					if DEBUG_FORTH_MALLOC 
9070						DMARK "maB" 
9070						CALLMONITOR 
9070					endif 
9070			      ; Loop through free block list to find some space 
9070			malloc_find_space: 
9070 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9071 23			      inc   HL 
9072 56			      ld    D, (HL) 
9073			 
9073 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9074 b3			      or    E 
9075 ca 01 91		      jp    Z, malloc_no_space 
9078			 
9078 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
907b dd 72 01		      ld    (IX+1), D 
907e			 
907e			      ; Does this block have enough space to make the allocation? 
907e 23			      inc   HL                      ; Load free block size into DE 
907f 5e			      ld    E, (HL) 
9080 23			      inc   HL 
9081 56			      ld    D, (HL) 
9082			 
9082 eb			      ex    DE, HL                  ; Check size of block against want 
9083 b7			      or    A                       ; Ensure carry flag clear 
9084 ed 42		      sbc   HL, BC 
9086 e5			      push  HL                      ; Store the result for later (new block size) 
9087			 
9087 ca d6 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
908a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
908c			 
908c			      ; this_free block is not big enough, setup ptrs to test next free block 
908c e1			      pop   HL                      ; Discard previous result 
908d			 
908d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9090 dd 66 03		      ld    H, (IX+3) 
9093 dd 75 04		      ld    (IX+4), L 
9096 dd 74 05		      ld    (IX+5), H 
9099			 
9099 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
909c dd 66 01		      ld    H, (IX+1) 
909f dd 75 02		      ld    (IX+2), L 
90a2 dd 74 03		      ld    (IX+3), H 
90a5			 
90a5					if DEBUG_FORTH_MALLOC 
90a5						DMARK "MA>" 
90a5						CALLMONITOR 
90a5					endif 
90a5 18 c9		      jr    malloc_find_space 
90a7			 
90a7			      ; split a bigger block into two - requested size and remaining size 
90a7			malloc_alloc_split: 
90a7					if DEBUG_FORTH_MALLOC 
90a7						DMARK "MAs" 
90a7						CALLMONITOR 
90a7					endif 
90a7 eb			      ex    DE, HL                  ; Calculate address of new free block 
90a8 2b			      dec   HL 
90a9 2b			      dec   HL 
90aa 2b			      dec   HL 
90ab 09			      add   HL, BC 
90ac			 
90ac			      ; Create a new block and point it at next_free 
90ac dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
90af dd 56 01		      ld    D, (IX+1) 
90b2			 
90b2 73			      ld    (HL), E                 ; Store next_free ptr into new block 
90b3 23			      inc   HL 
90b4 72			      ld    (HL), D 
90b5			 
90b5 d1			      pop   DE                      ; Store size of new block into new block 
90b6 23			      inc   HL 
90b7 73			      ld    (HL), E 
90b8 23			      inc   HL 
90b9 72			      ld    (HL), D 
90ba			 
90ba			      ; Update this_free ptr to point to new block 
90ba 2b			      dec   HL 
90bb 2b			      dec   HL 
90bc 2b			      dec   HL 
90bd			 
90bd dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
90c0 dd 56 03		      ld    D, (IX+3) 
90c3			 
90c3 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
90c6 dd 74 03		      ld    (IX+3), H 
90c9			 
90c9			      ; Modify this_free block to be allocation 
90c9 eb			      ex    DE, HL 
90ca af			      xor   A                       ; Null the next block ptr of allocated block 
90cb 77			      ld    (HL), A 
90cc 23			      inc   HL 
90cd 77			      ld    (HL), A 
90ce			 
90ce 23			      inc   HL                      ; Store want size into allocated block 
90cf 71			      ld    (HL), C 
90d0 23			      inc   HL 
90d1 70			      ld    (HL), B 
90d2 23			      inc   HL 
90d3 e5			      push  HL                      ; Address of allocation to return 
90d4			 
90d4 18 19		      jr    malloc_update_links 
90d6			 
90d6			malloc_alloc_fit: 
90d6 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
90d7			 
90d7					if DEBUG_FORTH_MALLOC 
90d7						DMARK "MAf" 
90d7						CALLMONITOR 
90d7					endif 
90d7			      ; Modify this_free block to be allocation 
90d7 eb			      ex    DE, HL 
90d8 2b			      dec   HL 
90d9 2b			      dec   HL 
90da 2b			      dec   HL 
90db			 
90db af			      xor   A                       ; Null the next block ptr of allocated block 
90dc 77			      ld    (HL), A 
90dd 23			      inc   HL 
90de 77			      ld    (HL), A 
90df			 
90df 23			      inc   HL                      ; Store address of allocation to return 
90e0 23			      inc   HL 
90e1 23			      inc   HL 
90e2 e5			      push  HL 
90e3			 
90e3			      ; Copy next_free ptr to this_free, remove allocated block from free list 
90e3 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
90e6 dd 66 01		      ld    H, (IX+1) 
90e9			 
90e9 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
90ec dd 74 03		      ld    (IX+3), H 
90ef			 
90ef			 
90ef			malloc_update_links: 
90ef			      ; Update prev_free ptr to point to this_free 
90ef dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
90f2 dd 66 05		      ld    H, (IX+5) 
90f5			 
90f5 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
90f8 dd 56 03		      ld    D, (IX+3) 
90fb			 
90fb 73			      ld    (HL), E                 ; this_free ptr into prev_free 
90fc 23			      inc   HL 
90fd 72			      ld    (HL), D 
90fe			 
90fe					if DEBUG_FORTH_MALLOC 
90fe						DMARK "Mul" 
90fe						CALLMONITOR 
90fe					endif 
90fe			      ; Clear the Z flag to indicate successful allocation 
90fe 7a			      ld    A, D 
90ff b3			      or    E 
9100			 
9100 d1			      pop   DE                      ; Address of allocation 
9101					if DEBUG_FORTH_MALLOC 
9101						DMARK "MAu" 
9101						CALLMONITOR 
9101					endif 
9101			 
9101			malloc_no_space: 
9101 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9104 39			      add   HL, SP 
9105 f9			      ld    SP, HL 
9106			 
9106 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9107					if DEBUG_FORTH_MALLOC 
9107						DMARK "MAN" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			malloc_early_exit: 
9107					if DEBUG_FORTH_MALLOC 
9107						DMARK "MAx" 
9107						CALLMONITOR 
9107					endif 
9107 dd e1		      pop   IX 
9109 d1			      pop   DE 
910a c1			      pop   BC 
910b			 
910b			if DEBUG_FORTH_MALLOC_HIGH 
910b			call malloc_guard_exit 
910b			call malloc_guard_zerolen 
910b			endif 
910b c9			      ret 
910c			 
910c			 
910c			;------------------------------------------------------------------------------ 
910c			;     free                                                                    : 
910c			;                                                                             : 
910c			; Description                                                                 : 
910c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
910c			;     returned by malloc, otherwise the behaviour is undefined.               : 
910c			;                                                                             : 
910c			;     Where possible, directly adjacent free blocks will be merged together   : 
910c			;     into larger blocks to help ensure that the heap does not become         : 
910c			;     excessively fragmented.                                                 : 
910c			;                                                                             : 
910c			;     free does not clear or set any other value into the freed space, and    : 
910c			;     therefore its contents may be visible through subsequent malloc's. The  : 
910c			;     caller should clear the freed space as required.                        : 
910c			;                                                                             : 
910c			;     This implementation of free uses the stack exclusively, and is          : 
910c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
910c			;     advisable to disable interrupts before calling free, and recommended    : 
910c			;     to avoid the use of free inside ISRs in general.                        : 
910c			;                                                                             : 
910c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
910c			;                                                                             : 
910c			; Parameters                                                                  : 
910c			;     HL  Pointer to address of first byte of allocation to be freed          : 
910c			;                                                                             : 
910c			; Returns                                                                     : 
910c			;     Nothing                                                                 : 
910c			;                                                                             : 
910c			; Stack frame                                                                 : 
910c			;       |             |                                                       : 
910c			;       +-------------+                                                       : 
910c			;       |     BC      |                                                       : 
910c			;       +-------------+                                                       : 
910c			;       |     DE      |                                                       : 
910c			;       +-------------+                                                       : 
910c			;       |     IX      |                                                       : 
910c			;       +-------------+                                                       : 
910c			;       |  prev_free  |                                                       : 
910c			;   +2  +-------------+                                                       : 
910c			;       |  next_free  |                                                       : 
910c			;   +0  +-------------+                                                       : 
910c			;       |             |                                                       : 
910c			;                                                                             : 
910c			;------------------------------------------------------------------------------ 
910c			free: 
910c c5			      push  BC 
910d d5			      push  DE 
910e dd e5		      push  IX 
9110			 
9110 7c			      ld    A, H                    ; Exit if ptr is null 
9111 b5			      or    L 
9112 ca d6 91		      jp    Z, free_early_exit 
9115			 
9115			      ; Set up stack frame 
9115 eb			      ex    DE, HL 
9116 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9119 39			      add   HL, SP 
911a f9			      ld    SP, HL 
911b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
911f dd 39		      add   IX, SP 
9121			 
9121			      ; The address in HL points to the start of the useable allocated space, 
9121			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9121			      ; address of the block itself. 
9121 eb			      ex    DE, HL 
9122 11 fc ff		      ld    DE, -4 
9125 19			      add   HL, DE 
9126			 
9126			      ; An allocated block must have a null next block pointer in it 
9126 7e			      ld    A, (HL) 
9127 23			      inc   HL 
9128 b6			      or    (HL) 
9129 c2 d1 91		      jp    NZ, free_done 
912c			 
912c 2b			      dec   HL 
912d			 
912d 44			      ld    B, H                    ; Copy HL to BC 
912e 4d			      ld    C, L 
912f			 
912f			      ; Loop through the free list to find the first block with an address 
912f			      ; higher than the block being freed 
912f 21 f5 d8		      ld    HL, free_list 
9132			 
9132			free_find_higher_block: 
9132 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9133 23			      inc   HL 
9134 56			      ld    D, (HL) 
9135 2b			      dec   HL 
9136			 
9136 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9139 dd 72 01		      ld    (IX+1), D 
913c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
913f dd 74 03		      ld    (IX+3), H 
9142			 
9142 78			      ld    A, B                    ; Check if DE is greater than BC 
9143 ba			      cp    D                       ; Compare MSB first 
9144 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9146 30 04		      jr    NC, free_find_higher_block_skip 
9148 79			      ld    A, C 
9149 bb			      cp    E                       ; Then compare LSB 
914a 38 08		      jr    C, free_found_higher_block 
914c			 
914c			free_find_higher_block_skip: 
914c 7a			      ld    A, D                    ; Reached the end of the free list? 
914d b3			      or    E 
914e ca d1 91		      jp    Z, free_done 
9151			 
9151 eb			      ex    DE, HL 
9152			 
9152 18 de		      jr    free_find_higher_block 
9154			 
9154			free_found_higher_block: 
9154			      ; Insert freed block between prev and next free blocks 
9154 71			      ld    (HL), C                 ; Point prev free block to freed block 
9155 23			      inc   HL 
9156 70			      ld    (HL), B 
9157			 
9157 60			      ld    H, B                    ; Point freed block at next free block 
9158 69			      ld    L, C 
9159 73			      ld    (HL), E 
915a 23			      inc   HL 
915b 72			      ld    (HL), D 
915c			 
915c			      ; Check if the freed block is adjacent to the next free block 
915c 23			      inc   HL                      ; Load size of freed block into HL 
915d 5e			      ld    E, (HL) 
915e 23			      inc   HL 
915f 56			      ld    D, (HL) 
9160 eb			      ex    DE, HL 
9161			 
9161 09			      add   HL, BC                  ; Add addr of freed block and its size 
9162			 
9162 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9165 dd 56 01		      ld    D, (IX+1) 
9168			 
9168 b7			      or    A                       ; Clear the carry flag 
9169 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
916b 20 22		      jr    NZ, free_check_adjacent_to_prev 
916d			 
916d			      ; Freed block is adjacent to next, merge into one bigger block 
916d eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
916e 5e			      ld    E, (HL) 
916f 23			      inc   HL 
9170 56			      ld    D, (HL) 
9171 e5			      push  HL                      ; Save ptr to next block for later 
9172			 
9172 60			      ld    H, B                    ; Store ptr from next block into freed block 
9173 69			      ld    L, C 
9174 73			      ld    (HL), E 
9175 23			      inc   HL 
9176 72			      ld    (HL), D 
9177			 
9177 e1			      pop   HL                      ; Restore ptr to next block 
9178 23			      inc   HL                      ; Load size of next block into DE 
9179 5e			      ld    E, (HL) 
917a 23			      inc   HL 
917b 56			      ld    D, (HL) 
917c d5			      push  DE                      ; Save next block size for later 
917d			 
917d 60			      ld    H, B                    ; Load size of freed block into HL 
917e 69			      ld    L, C 
917f 23			      inc   HL 
9180 23			      inc   HL 
9181 5e			      ld    E, (HL) 
9182 23			      inc   HL 
9183 56			      ld    D, (HL) 
9184 eb			      ex    DE, HL 
9185			 
9185 d1			      pop   DE                      ; Restore size of next block 
9186 19			      add   HL, DE                  ; Add sizes of both blocks 
9187 eb			      ex    DE, HL 
9188			 
9188 60			      ld    H, B                    ; Store new bigger size into freed block 
9189 69			      ld    L, C 
918a 23			      inc   HL 
918b 23			      inc   HL 
918c 73			      ld    (HL), E 
918d 23			      inc   HL 
918e 72			      ld    (HL), D 
918f			 
918f			free_check_adjacent_to_prev: 
918f			      ; Check if the freed block is adjacent to the prev free block 
918f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9192 dd 66 03		      ld    H, (IX+3) 
9195			 
9195 23			      inc   HL                      ; Size of prev free block into DE 
9196 23			      inc   HL 
9197 5e			      ld    E, (HL) 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a 2b			      dec   HL 
919b 2b			      dec   HL 
919c 2b			      dec   HL 
919d			 
919d 19			      add   HL, DE                  ; Add prev block addr and size 
919e			 
919e b7			      or    A                       ; Clear the carry flag 
919f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
91a1 20 2e		      jr    NZ, free_done 
91a3			 
91a3			      ; Freed block is adjacent to prev, merge into one bigger block 
91a3 60			      ld    H, B                    ; Load next ptr from freed block into DE 
91a4 69			      ld    L, C 
91a5 5e			      ld    E, (HL) 
91a6 23			      inc   HL 
91a7 56			      ld    D, (HL) 
91a8 e5			      push  HL                      ; Save freed block ptr for later 
91a9			 
91a9 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
91ac dd 66 03		      ld    H, (IX+3) 
91af 73			      ld    (HL), E 
91b0 23			      inc   HL 
91b1 72			      ld    (HL), D 
91b2			 
91b2 e1			      pop   HL                      ; Restore freed block ptr 
91b3 23			      inc   HL                      ; Load size of freed block into DE 
91b4 5e			      ld    E, (HL) 
91b5 23			      inc   HL 
91b6 56			      ld    D, (HL) 
91b7 d5			      push  DE                      ; Save freed block size for later 
91b8			 
91b8 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
91bb dd 66 03		      ld    H, (IX+3) 
91be 23			      inc   HL 
91bf 23			      inc   HL 
91c0 5e			      ld    E, (HL) 
91c1 23			      inc   HL 
91c2 56			      ld    D, (HL) 
91c3			 
91c3 e1			      pop   HL                      ; Add sizes of both blocks 
91c4 19			      add   HL, DE 
91c5 eb			      ex    DE, HL 
91c6			 
91c6 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
91c9 dd 66 03		      ld    H, (IX+3) 
91cc 23			      inc   HL 
91cd 23			      inc   HL 
91ce 73			      ld    (HL), E 
91cf 23			      inc   HL 
91d0 72			      ld    (HL), D 
91d1			 
91d1			free_done: 
91d1 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
91d4 39			      add   HL, SP 
91d5 f9			      ld    SP, HL 
91d6			 
91d6			free_early_exit: 
91d6 dd e1		      pop   IX 
91d8 d1			      pop   DE 
91d9 c1			      pop   BC 
91da			 
91da c9			      ret 
91db			 
91db			; moved to firmware.asm 
91db			; 
91db			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
91db			;                  .dw   0 
91db			 
91db			 
91db			endif 
91db			 
91db			 
91db			if MALLOC_3 
91db			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
91db			;heap_start        .equ  0x9000      ; Starting address of heap 
91db			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
91db			; 
91db			 ;     .org 0 
91db			  ;    jp    main 
91db			; 
91db			; 
91db			 ;     .org  0x100 
91db			;main: 
91db			 ;     ld    HL, 0x8100 
91db			  ;    ld    SP, HL 
91db			; 
91db			;      call  heap_init 
91db			 
91db			      ; Make some allocations 
91db			;      ld    HL, 12 
91db			;      call  malloc            ; Allocates 0x9004 
91db			; 
91db			 ;     ld    HL, 12 
91db			;      call  malloc            ; Allocates 0x9014 
91db			 
91db			;      ld    HL, 12 
91db			;      call  malloc            ; Allocates 0x9024 
91db			 
91db			      ; Free some allocations 
91db			;      ld    HL, 0x9014 
91db			;      call  free 
91db			 
91db			;      ld    HL, 0x9004 
91db			;      call  free 
91db			; 
91db			;      ld    HL, 0x9024 
91db			;      call  free 
91db			 
91db			 
91db			 ;     halt 
91db			 
91db			 
91db			;------------------------------------------------------------------------------ 
91db			;     heap_init                                                               : 
91db			;                                                                             : 
91db			; Description                                                                 : 
91db			;     Initialise the heap and make it ready for malloc and free operations.   : 
91db			;                                                                             : 
91db			;     The heap is maintained as a linked list, starting with an initial       : 
91db			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
91db			;     the first free block in the heap. Each block then points to the next    : 
91db			;     free block within the heap, and the free list ends at the first block   : 
91db			;     with a null pointer to the next free block.                             : 
91db			;                                                                             : 
91db			; Parameters                                                                  : 
91db			;     Inputs are compile-time only. Two defines which specify the starting    : 
91db			;     address of the heap and its size are required, along with a memory      : 
91db			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
91db			;     principally stores a pointer to the first free block in the heap.       : 
91db			;                                                                             : 
91db			; Returns                                                                     : 
91db			;     Nothing                                                                 : 
91db			;------------------------------------------------------------------------------ 
91db			heap_init: 
91db			      push  HL 
91db			 
91db			      ; Initialise free list struct 
91db			      ld    HL, heap_start 
91db			      ld    (free_list), HL 
91db			      ld    HL, 0 
91db			      ld    (free_list+2), HL 
91db			 
91db			      ; Insert first free block at bottom of heap, consumes entire heap 
91db			      ld    HL, heap_start+heap_size-4 
91db			      ld    (heap_start), HL        ; Next block (end of free list) 
91db			      ld    HL, heap_size-4 
91db			      ld    (heap_start+2), HL      ; Block size 
91db			 
91db			      ; Insert end of free list block at top of heap - two null words will 
91db			      ; terminate the free list 
91db			      ld    HL, 0 
91db			      ld    (heap_start+heap_size-2), HL 
91db			      ld    (heap_start+heap_size-4), HL 
91db			 
91db			      pop   HL 
91db			 
91db			      ret 
91db			 
91db			 
91db			;------------------------------------------------------------------------------ 
91db			;     malloc                                                                  : 
91db			;                                                                             : 
91db			; Description                                                                 : 
91db			;     Allocates the wanted space from the heap and returns the address of the : 
91db			;     first useable byte of the allocation.                                   : 
91db			;                                                                             : 
91db			;     Allocations can happen in one of two ways:                              : 
91db			;                                                                             : 
91db			;     1. A free block may be found which is the exact size wanted. In this    : 
91db			;        case the block is removed from the free list and retuedn to the      : 
91db			;        caller.                                                              : 
91db			;     2. A free block may be found which is larger than the size wanted. In   : 
91db			;        this case, the larger block is split into two. The first portion of  : 
91db			;        this block will become the requested space by the malloc call and    : 
91db			;        is returned to the caller. The second portion becomes a new free     : 
91db			;        block, and the free list is adjusted to maintain continuity via this : 
91db			;        newly created block.                                                 : 
91db			;                                                                             : 
91db			;     malloc does not set any initial value in the allocated space, the       : 
91db			;     caller is required to do this as required.                              : 
91db			;                                                                             : 
91db			;     This implementation of malloc uses the stack exclusively, and is        : 
91db			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91db			;     advisable to disable interrupts before calling malloc, and recommended  : 
91db			;     to avoid the use of malloc inside ISRs in general.                      : 
91db			;                                                                             : 
91db			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91db			;                                                                             : 
91db			; Parameters                                                                  : 
91db			;     HL  Number of bytes wanted                                              : 
91db			;                                                                             : 
91db			; Returns                                                                     : 
91db			;     HL  Address of the first useable byte of the allocation                 : 
91db			;                                                                             : 
91db			; Flags                                                                       : 
91db			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91db			;                                                                             : 
91db			; Stack frame                                                                 : 
91db			;       |             |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     BC      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     DE      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     IX      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |  prev_free  |                                                       : 
91db			;   +4  +-------------+                                                       : 
91db			;       |  this_free  |                                                       : 
91db			;   +2  +-------------+                                                       : 
91db			;       |  next_free  |                                                       : 
91db			;   +0  +-------------+                                                       : 
91db			;       |             |                                                       : 
91db			;                                                                             : 
91db			;------------------------------------------------------------------------------ 
91db			malloc: 
91db			      push  BC 
91db			      push  DE 
91db			      push  IX 
91db			 
91db			      ld    A, H                    ; Exit if no space requested 
91db			      or    L 
91db			      jp    Z, malloc_early_exit 
91db			 
91db			      ; Set up stack frame 
91db			      ex    DE, HL 
91db			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91db			      add   HL, SP 
91db			      ld    SP, HL 
91db			      ld    IX, 0                   ; Use IX as a frame pointer 
91db			      add   IX, SP 
91db			 
91db			      ; Setup initial state 
91db			      ld    HL, 4                   ; want must also include space used by block struct 
91db			      add   HL, DE 
91db			 
91db			      ld    B, H                    ; Move want to BC 
91db			      ld    C, L 
91db			 
91db			      ld    HL, free_list           ; Store prev_free ptr to stack 
91db			      ld    (IX+4), L 
91db			      ld    (IX+5), H 
91db			 
91db			      ld    E, (HL)                 ; Store this_free ptr to stack 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      ld    (IX+2), E 
91db			      ld    (IX+3), D 
91db			      ex    DE, HL                  ; this_free ptr into HL 
91db			 
91db			      ; Loop through free block list to find some space 
91db			malloc_find_space: 
91db			      ld    E, (HL)                 ; Load next_free ptr into DE 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			 
91db			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91db			      or    E 
91db			      jp    Z, malloc_no_space 
91db			 
91db			      ld    (IX+0), E               ; Store next_free ptr to stack 
91db			      ld    (IX+1), D 
91db			 
91db			      ; Does this block have enough space to make the allocation? 
91db			      inc   HL                      ; Load free block size into DE 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			 
91db			      ex    DE, HL                  ; Check size of block against want 
91db			      or    A                       ; Ensure carry flag clear 
91db			      sbc   HL, BC 
91db			      push  HL                      ; Store the result for later (new block size) 
91db			 
91db			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91db			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91db			 
91db			      ; this_free block is not big enough, setup ptrs to test next free block 
91db			      pop   HL                      ; Discard previous result 
91db			 
91db			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91db			      ld    H, (IX+3) 
91db			      ld    (IX+4), L 
91db			      ld    (IX+5), H 
91db			 
91db			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91db			      ld    H, (IX+1) 
91db			      ld    (IX+2), L 
91db			      ld    (IX+3), H 
91db			 
91db			      jr    malloc_find_space 
91db			 
91db			      ; split a bigger block into two - requested size and remaining size 
91db			malloc_alloc_split: 
91db			      ex    DE, HL                  ; Calculate address of new free block 
91db			      dec   HL 
91db			      dec   HL 
91db			      dec   HL 
91db			      add   HL, BC 
91db			 
91db			      ; Create a new block and point it at next_free 
91db			      ld    E, (IX+0)               ; Load next_free ptr into DE 
91db			      ld    D, (IX+1) 
91db			 
91db			      ld    (HL), E                 ; Store next_free ptr into new block 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      pop   DE                      ; Store size of new block into new block 
91db			      inc   HL 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      ; Update this_free ptr to point to new block 
91db			      dec   HL 
91db			      dec   HL 
91db			      dec   HL 
91db			 
91db			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91db			      ld    D, (IX+3) 
91db			 
91db			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91db			      ld    (IX+3), H 
91db			 
91db			      ; Modify this_free block to be allocation 
91db			      ex    DE, HL 
91db			      xor   A                       ; Null the next block ptr of allocated block 
91db			      ld    (HL), A 
91db			      inc   HL 
91db			      ld    (HL), A 
91db			 
91db			      inc   HL                      ; Store want size into allocated block 
91db			      ld    (HL), C 
91db			      inc   HL 
91db			      ld    (HL), B 
91db			      inc   HL 
91db			      push  HL                      ; Address of allocation to return 
91db			 
91db			      jr    malloc_update_links 
91db			 
91db			malloc_alloc_fit: 
91db			      pop   HL                      ; Dont need new block size, want is exact fit 
91db			 
91db			      ; Modify this_free block to be allocation 
91db			      ex    DE, HL 
91db			      dec   HL 
91db			      dec   HL 
91db			      dec   HL 
91db			 
91db			      xor   A                       ; Null the next block ptr of allocated block 
91db			      ld    (HL), A 
91db			      inc   HL 
91db			      ld    (HL), A 
91db			 
91db			      inc   HL                      ; Store address of allocation to return 
91db			      inc   HL 
91db			      inc   HL 
91db			      push  HL 
91db			 
91db			      ; Copy next_free ptr to this_free, remove allocated block from free list 
91db			      ld    L, (IX+0)               ; next_free to HL 
91db			      ld    H, (IX+1) 
91db			 
91db			      ld    (IX+2), L               ; HL to this_free 
91db			      ld    (IX+3), H 
91db			 
91db			 
91db			malloc_update_links: 
91db			      ; Update prev_free ptr to point to this_free 
91db			      ld    L, (IX+4)               ; prev_free ptr to HL 
91db			      ld    H, (IX+5) 
91db			 
91db			      ld    E, (IX+2)               ; this_free ptr to DE 
91db			      ld    D, (IX+3) 
91db			 
91db			      ld    (HL), E                 ; this_free ptr into prev_free 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      ; Clear the Z flag to indicate successful allocation 
91db			      ld    A, D 
91db			      or    E 
91db			 
91db			      pop   DE                      ; Address of allocation 
91db			 
91db			malloc_no_space: 
91db			      ld    HL, 6                   ; Clean up stack frame 
91db			      add   HL, SP 
91db			      ld    SP, HL 
91db			 
91db			      ex    DE, HL                  ; Alloc addr into HL for return 
91db			 
91db			malloc_early_exit: 
91db			      pop   IX 
91db			      pop   DE 
91db			      pop   BC 
91db			 
91db			      ret 
91db			 
91db			 
91db			;------------------------------------------------------------------------------ 
91db			;     free                                                                    : 
91db			;                                                                             : 
91db			; Description                                                                 : 
91db			;     Return the space pointed to by HL to the heap. HL must be an address as : 
91db			;     returned by malloc, otherwise the behaviour is undefined.               : 
91db			;                                                                             : 
91db			;     Where possible, directly adjacent free blocks will be merged together   : 
91db			;     into larger blocks to help ensure that the heap does not become         : 
91db			;     excessively fragmented.                                                 : 
91db			;                                                                             : 
91db			;     free does not clear or set any other value into the freed space, and    : 
91db			;     therefore its contents may be visible through subsequent malloc's. The  : 
91db			;     caller should clear the freed space as required.                        : 
91db			;                                                                             : 
91db			;     This implementation of free uses the stack exclusively, and is          : 
91db			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91db			;     advisable to disable interrupts before calling free, and recommended    : 
91db			;     to avoid the use of free inside ISRs in general.                        : 
91db			;                                                                             : 
91db			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91db			;                                                                             : 
91db			; Parameters                                                                  : 
91db			;     HL  Pointer to address of first byte of allocation to be freed          : 
91db			;                                                                             : 
91db			; Returns                                                                     : 
91db			;     Nothing                                                                 : 
91db			;                                                                             : 
91db			; Stack frame                                                                 : 
91db			;       |             |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     BC      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     DE      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |     IX      |                                                       : 
91db			;       +-------------+                                                       : 
91db			;       |  prev_free  |                                                       : 
91db			;   +2  +-------------+                                                       : 
91db			;       |  next_free  |                                                       : 
91db			;   +0  +-------------+                                                       : 
91db			;       |             |                                                       : 
91db			;                                                                             : 
91db			;------------------------------------------------------------------------------ 
91db			free: 
91db			      push  BC 
91db			      push  DE 
91db			      push  IX 
91db			 
91db			      ld    A, H                    ; Exit if ptr is null 
91db			      or    L 
91db			      jp    Z, free_early_exit 
91db			 
91db			      ; Set up stack frame 
91db			      ex    DE, HL 
91db			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
91db			      add   HL, SP 
91db			      ld    SP, HL 
91db			      ld    IX, 0                   ; Use IX as a frame pointer 
91db			      add   IX, SP 
91db			 
91db			      ; The address in HL points to the start of the useable allocated space, 
91db			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91db			      ; address of the block itself. 
91db			      ex    DE, HL 
91db			      ld    DE, -4 
91db			      add   HL, DE 
91db			 
91db			      ; An allocated block must have a null next block pointer in it 
91db			      ld    A, (HL) 
91db			      inc   HL 
91db			      or    (HL) 
91db			      jp    NZ, free_done 
91db			 
91db			      dec   HL 
91db			 
91db			      ld    B, H                    ; Copy HL to BC 
91db			      ld    C, L 
91db			 
91db			      ; Loop through the free list to find the first block with an address 
91db			      ; higher than the block being freed 
91db			      ld    HL, free_list 
91db			 
91db			free_find_higher_block: 
91db			      ld    E, (HL)                 ; Load next ptr from free block 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      dec   HL 
91db			 
91db			      ld    (IX+0), E               ; Save ptr to next free block 
91db			      ld    (IX+1), D 
91db			      ld    (IX+2), L               ; Save ptr to prev free block 
91db			      ld    (IX+3), H 
91db			 
91db			      ld    A, B                    ; Check if DE is greater than BC 
91db			      cp    D                       ; Compare MSB first 
91db			      jr    Z, $+4                  ; MSB the same, compare LSB 
91db			      jr    NC, free_find_higher_block_skip 
91db			      ld    A, C 
91db			      cp    E                       ; Then compare LSB 
91db			      jr    C, free_found_higher_block 
91db			 
91db			free_find_higher_block_skip: 
91db			      ld    A, D                    ; Reached the end of the free list? 
91db			      or    E 
91db			      jp    Z, free_done 
91db			 
91db			      ex    DE, HL 
91db			 
91db			      jr    free_find_higher_block 
91db			 
91db			free_found_higher_block: 
91db			      ; Insert freed block between prev and next free blocks 
91db			      ld    (HL), C                 ; Point prev free block to freed block 
91db			      inc   HL 
91db			      ld    (HL), B 
91db			 
91db			      ld    H, B                    ; Point freed block at next free block 
91db			      ld    L, C 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      ; Check if the freed block is adjacent to the next free block 
91db			      inc   HL                      ; Load size of freed block into HL 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      ex    DE, HL 
91db			 
91db			      add   HL, BC                  ; Add addr of freed block and its size 
91db			 
91db			      ld    E, (IX+0)               ; Load addr of next free block into DE 
91db			      ld    D, (IX+1) 
91db			 
91db			      or    A                       ; Clear the carry flag 
91db			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91db			      jr    NZ, free_check_adjacent_to_prev 
91db			 
91db			      ; Freed block is adjacent to next, merge into one bigger block 
91db			      ex    DE, HL                  ; Load next ptr from next block into DE 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      push  HL                      ; Save ptr to next block for later 
91db			 
91db			      ld    H, B                    ; Store ptr from next block into freed block 
91db			      ld    L, C 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      pop   HL                      ; Restore ptr to next block 
91db			      inc   HL                      ; Load size of next block into DE 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      push  DE                      ; Save next block size for later 
91db			 
91db			      ld    H, B                    ; Load size of freed block into HL 
91db			      ld    L, C 
91db			      inc   HL 
91db			      inc   HL 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      ex    DE, HL 
91db			 
91db			      pop   DE                      ; Restore size of next block 
91db			      add   HL, DE                  ; Add sizes of both blocks 
91db			      ex    DE, HL 
91db			 
91db			      ld    H, B                    ; Store new bigger size into freed block 
91db			      ld    L, C 
91db			      inc   HL 
91db			      inc   HL 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			free_check_adjacent_to_prev: 
91db			      ; Check if the freed block is adjacent to the prev free block 
91db			      ld    L, (IX+2)               ; Prev free block ptr into HL 
91db			      ld    H, (IX+3) 
91db			 
91db			      inc   HL                      ; Size of prev free block into DE 
91db			      inc   HL 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      dec   HL 
91db			      dec   HL 
91db			      dec   HL 
91db			 
91db			      add   HL, DE                  ; Add prev block addr and size 
91db			 
91db			      or    A                       ; Clear the carry flag 
91db			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
91db			      jr    NZ, free_done 
91db			 
91db			      ; Freed block is adjacent to prev, merge into one bigger block 
91db			      ld    H, B                    ; Load next ptr from freed block into DE 
91db			      ld    L, C 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      push  HL                      ; Save freed block ptr for later 
91db			 
91db			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
91db			      ld    H, (IX+3) 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			      pop   HL                      ; Restore freed block ptr 
91db			      inc   HL                      ; Load size of freed block into DE 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			      push  DE                      ; Save freed block size for later 
91db			 
91db			      ld    L, (IX+2)               ; Load size of prev block into DE 
91db			      ld    H, (IX+3) 
91db			      inc   HL 
91db			      inc   HL 
91db			      ld    E, (HL) 
91db			      inc   HL 
91db			      ld    D, (HL) 
91db			 
91db			      pop   HL                      ; Add sizes of both blocks 
91db			      add   HL, DE 
91db			      ex    DE, HL 
91db			 
91db			      ld    L, (IX+2)               ; Store new bigger size into prev block 
91db			      ld    H, (IX+3) 
91db			      inc   HL 
91db			      inc   HL 
91db			      ld    (HL), E 
91db			      inc   HL 
91db			      ld    (HL), D 
91db			 
91db			free_done: 
91db			      ld    HL, 4                   ; Clean up stack frame 
91db			      add   HL, SP 
91db			      ld    SP, HL 
91db			 
91db			free_early_exit: 
91db			      pop   IX 
91db			      pop   DE 
91db			      pop   BC 
91db			 
91db			      ret 
91db			 
91db			 
91db			;      .org 0x8000 
91db			; 
91db			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
91db			 ;                 .dw   0 
91db			 
91db			endif 
91db			 
91db			 
91db			if MALLOC_4 
91db			 
91db			; My memory allocation code. Very very simple.... 
91db			; allocate space under 250 chars 
91db			 
91db			heap_init: 
91db				; init start of heap as zero 
91db				;  
91db			 
91db				ld hl, heap_start 
91db				ld a, 0 
91db				ld (hl), a      ; empty block 
91db				inc hl 
91db				ld a, 0 
91db				ld (hl), a      ; length of block 
91db				; write end of list 
91db				inc hl 
91db				ld a,(hl) 
91db				inc hl 
91db				ld a,(hl) 
91db				 
91db			 
91db				; init some malloc vars 
91db			 
91db				ld hl, 0 
91db				ld (free_list), hl       ; store last malloc location 
91db			 
91db				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
91db				ld a, 0 
91db				ld (hl), a 
91db			 
91db			 
91db				ld hl, heap_start 
91db				;  
91db				  
91db				ret 
91db			 
91db			 
91db			;    free block marker 
91db			;    requested size  
91db			;    pointer to next block 
91db			;    .... 
91db			;    next block marker 
91db			 
91db			 
91db			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
91db			; 
91db			 
91db			 
91db			malloc:  
91db				push de 
91db				push bc 
91db				push af 
91db			 
91db				; hl space required 
91db				 
91db				ld c, l    ; hold space   (TODO only a max of 255) 
91db			 
91db			;	inc c     ; TODO BUG need to fix memory leak on push str 
91db			;	inc c 
91db			;	inc c 
91db			;	inc c 
91db			;	inc c 
91db			;	inc c 
91db			;	inc c 
91db			 
91db			 
91db			 
91db				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
91db			 
91db				ld a, (free_list+3) 
91db				cp 0 
91db				jr z, .contheap 
91db			 
91db				ld hl, (free_list)     ; get last alloc 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "mrs" 
91db						CALLMONITOR 
91db					endif 
91db				jr .startalloc 
91db			 
91db			.contheap: 
91db				ld hl, heap_start 
91db			 
91db			.startalloc: 
91db			 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "mym" 
91db						CALLMONITOR 
91db					endif 
91db			.findblock: 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "mmf" 
91db						CALLMONITOR 
91db					endif 
91db			 
91db				ld a,(hl)  
91db				; if byte is zero then clear to use 
91db			 
91db				cp 0 
91db				jr z, .foundemptyblock 
91db			 
91db				; if byte is not clear 
91db				;     then byte is offset to next block 
91db			 
91db				inc hl 
91db				ld a, (hl) ; get size 
91db			.nextblock:	inc hl 
91db					ld e, (hl) 
91db					inc hl 
91db					ld d, (hl) 
91db					ex de, hl 
91db			;	inc hl  ; move past the store space 
91db			;	inc hl  ; move past zero index  
91db			 
91db				; TODO detect no more space 
91db			 
91db				push hl 
91db				ld de, heap_end 
91db				call cmp16 
91db				pop hl 
91db				jr nc, .nospace 
91db			 
91db				jr .findblock 
91db			 
91db			.nospace: ld hl, 0 
91db				jp .exit 
91db			 
91db			 
91db			.foundemptyblock:	 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "mme" 
91db						CALLMONITOR 
91db					endif 
91db			 
91db			; TODO has block enough space if reusing??? 
91db			 
91db				;  
91db			 
91db			; see if this block has been previously used 
91db				inc hl 
91db				ld a, (hl) 
91db				dec hl 
91db				cp 0 
91db				jr z, .newblock 
91db			 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "meR" 
91db						CALLMONITOR 
91db					endif 
91db			 
91db			; no reusing previously allocated block 
91db			 
91db			; is it smaller than previously used? 
91db				 
91db				inc hl    ; move to size 
91db				ld a, c 
91db				sub (hl)        ; we want c < (hl) 
91db				dec hl    ; move back to marker 
91db			        jr z, .findblock 
91db			 
91db				; update with the new size which should be lower 
91db			 
91db			        ;inc  hl   ; negate next move. move back to size  
91db			 
91db			.newblock: 
91db				; need to be at marker here 
91db			 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "meN" 
91db						CALLMONITOR 
91db					endif 
91db			 
91db			 
91db				ld a, c 
91db			 
91db				ld (free_list+3), a	 ; flag resume from last malloc  
91db				ld (free_list), hl    ; save out last location 
91db			 
91db			 
91db				;inc a     ; space for length byte 
91db				ld (hl), a     ; save block in use marker 
91db			 
91db				inc hl   ; move to space marker 
91db				ld (hl), a    ; save new space 
91db			 
91db				inc hl   ; move to start of allocated area 
91db				 
91db			;	push hl     ; save where we are - 1  
91db			 
91db			;	inc hl  ; move past zero index  
91db				; skip space to set down new marker 
91db			 
91db				; provide some extra space for now 
91db			 
91db				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
91db				inc a 
91db				inc a 
91db			 
91db				push hl   ; save where we are in the node block 
91db			 
91db				call addatohl 
91db			 
91db				; write linked list point 
91db			 
91db				pop de     ; get our node position 
91db				ex de, hl 
91db			 
91db				ld (hl), e 
91db				inc hl 
91db				ld (hl), d 
91db			 
91db				inc hl 
91db			 
91db				; now at start of allocated data so save pointer 
91db			 
91db				push hl 
91db			 
91db				; jump to position of next node and setup empty header in DE 
91db			 
91db				ex de, hl 
91db			 
91db			;	inc hl ; move past end of block 
91db			 
91db				ld a, 0 
91db				ld (hl), a   ; empty marker 
91db				inc hl 
91db				ld (hl), a   ; size 
91db				inc hl  
91db				ld (hl), a   ; ptr 
91db				inc hl 
91db				ld (hl), a   ; ptr 
91db			 
91db			 
91db				pop hl 
91db			 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "mmr" 
91db						CALLMONITOR 
91db					endif 
91db			 
91db			.exit: 
91db				pop af 
91db				pop bc 
91db				pop de  
91db				ret 
91db			 
91db			 
91db			 
91db			 
91db			free:  
91db				push hl 
91db				push af 
91db				; get address in hl 
91db			 
91db					if DEBUG_FORTH_MALLOC_INT 
91db						DMARK "fre" 
91db						CALLMONITOR 
91db					endif 
91db				; data is at hl - move to block count 
91db				dec hl 
91db				dec hl    ; get past pointer 
91db				dec hl 
91db			 
91db				ld a, (hl)    ; need this for a validation check 
91db			 
91db				dec hl    ; move to block marker 
91db			 
91db				; now check that the block count and block marker are the same  
91db			        ; this checks that we are on a malloc node and not random memory 
91db			        ; OK a faint chance this could be a problem but rare - famous last words! 
91db			 
91db				ld c, a 
91db				ld a, (hl)    
91db			 
91db				cp c 
91db				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
91db			 
91db				; yes good chance we are on a malloc node 
91db			 
91db				ld a, 0      
91db				ld (hl), a   ; mark as free 
91db			 
91db				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
91db			 
91db			.freeignore:  
91db			 
91db				pop af 
91db				pop hl 
91db			 
91db				ret 
91db			 
91db			 
91db			 
91db			endif 
91db			 
91db			; eof 
# End of file firmware_memory.asm
91db			  
91db			; device C  
91db			if SOUND_ENABLE  
91db				include "firmware_sound.asm"  
91db			endif  
91db			  
91db			include "firmware_diags.asm"  
91db			; Hardware diags menu 
91db			 
91db			 
91db			config: 
91db			 
91db 3e 00			ld a, 0 
91dd 21 0b 92			ld hl, .configmn 
91e0 cd 7f 89			call menu 
91e3			 
91e3 fe 00			cp 0 
91e5 c8				ret z 
91e6			 
91e6 fe 01			cp 1 
91e8 cc 39 92			call z, .savetostore 
91eb			 
91eb fe 02			cp 2 
91ed cc 25 92			call z, .selautoload 
91f0 fe 03			cp 3 
91f2 cc 1b 92			call z, .disautoload 
91f5 fe 04			cp 4 
91f7 cc 2f 92			call z, .selbank 
91fa fe 05			cp 5 
91fc cc 43 92			call z, .debug_tog 
91ff fe 06			cp 6 
9201 cc 86 93			call z, .bpsgo 
9204 fe 07			cp 7 
9206 cc 69 92			call z, hardware_diags 
9209			 
9209 18 d0			jr config 
920b			 
920b			.configmn: 
920b 77 95			dw prom_c3 
920d 8e 95			dw prom_c2 
920f a3 95			dw prom_c2a 
9211 b9 95			dw prom_c2b 
9213			;	dw prom_c4 
9213 d6 95			dw prom_m4 
9215 f1 95			dw prom_m4b 
9217 f9 95			dw prom_c1 
9219 00 00			dw 0 
921b				 
921b			 
921b			 
921b			 
921b			.disautoload: 
921b				if STORAGE_SE 
921b				ld a, $fe      ; bit 0 clear 
921b				ld (spi_device), a 
921b			 
921b				call storage_get_block_0 
921b			 
921b				ld a, 0 
921b				ld (store_page+STORE_0_AUTOFILE), a 
921b			 
921b					ld hl, 0 
921b					ld de, store_page 
921b				call storage_write_block	 ; save update 
921b				else 
921b			 
921b 21 08 96			ld hl, prom_notav 
921e 11 1e 96			ld de, prom_empty 
9221 cd df 88			call info_panel 
9224				endif 
9224			 
9224			 
9224 c9				ret 
9225			 
9225			 
9225			 
9225			; Select auto start 
9225			 
9225			.selautoload: 
9225			 
9225				 
9225				if STORAGE_SE 
9225			 
9225					call config_dir 
9225				        ld hl, scratch 
9225					ld a, 0 
9225					call menu 
9225			 
9225					cp 0 
9225					ret z 
9225			 
9225					dec a 
9225			 
9225			 
9225					; locate menu option 
9225			 
9225					ld hl, scratch 
9225					call table_lookup 
9225			 
9225					if DEBUG_FORTH_WORDS 
9225						DMARK "ALl" 
9225						CALLMONITOR 
9225					endif 
9225					; with the pointer to the menu it, the byte following the zero term is the file id 
9225			 
9225					ld a, 0 
9225					ld bc, 50   ; max of bytes to look at 
9225					cpir  
9225			 
9225					if DEBUG_FORTH_WORDS 
9225						DMARK "ALb" 
9225						CALLMONITOR 
9225					endif 
9225					;inc hl 
9225			 
9225					ld a, (hl)   ; file id 
9225					 
9225				        ; save bank and file ids 
9225			 
9225					push af 
9225			 
9225			; TODO need to save to block 0 on bank 1	 
9225			 
9225					call storage_get_block_0 
9225			 
9225					if DEBUG_FORTH_WORDS 
9225						DMARK "AL0" 
9225						CALLMONITOR 
9225					endif 
9225					pop af 
9225			 
9225					ld (store_page+STORE_0_FILERUN),a 
9225					 
9225					; save bank id 
9225			 
9225					ld a,(spi_device) 
9225					ld (store_page+STORE_0_BANKRUN),a 
9225			 
9225					; enable auto run of store file 
9225			 
9225					ld a, 1 
9225					ld (store_page+STORE_0_AUTOFILE),a 
9225			 
9225					; save buffer 
9225			 
9225					ld hl, 0 
9225					ld de, store_page 
9225					if DEBUG_FORTH_WORDS 
9225						DMARK "ALw" 
9225						CALLMONITOR 
9225					endif 
9225				call storage_write_block	 ; save update 
9225			  
9225			 
9225			 
9225			 
9225					ld hl, scratch 
9225					call config_fdir 
9225			 
9225				else 
9225			 
9225 21 08 96			ld hl, prom_notav 
9228 11 1e 96			ld de, prom_empty 
922b cd df 88			call info_panel 
922e			 
922e				endif 
922e c9				ret 
922f			 
922f			 
922f			 
922f			; Select storage bank 
922f			 
922f			.selbank: 
922f			 
922f				if STORAGE_SE 
922f				else 
922f			 
922f 21 08 96			ld hl, prom_notav 
9232 11 1e 96			ld de, prom_empty 
9235 cd df 88			call info_panel 
9238				endif 
9238				 
9238 c9				ret 
9239			 
9239			if STORAGE_SE 
9239			 
9239			.config_ldir:   
9239				; Load storage bank labels into menu array 
9239			 
9239				 
9239			 
9239			 
9239				ret 
9239			 
9239			 
9239			endif 
9239			 
9239			 
9239			; Save user words to storage 
9239			 
9239			.savetostore: 
9239			 
9239				if STORAGE_SE 
9239			 
9239					call config_dir 
9239				        ld hl, scratch 
9239					ld a, 0 
9239					call menu 
9239					 
9239					ld hl, scratch 
9239					call config_fdir 
9239			 
9239				else 
9239			 
9239 21 08 96			ld hl, prom_notav 
923c 11 1e 96			ld de, prom_empty 
923f cd df 88			call info_panel 
9242			 
9242				endif 
9242			 
9242 c9				ret 
9243			 
9243			 
9243			 
9243			if STORAGE_SE 
9243			 
9243			config_fdir: 
9243				; using the scratch dir go through and release the memory allocated for each string 
9243				 
9243				ld hl, scratch 
9243			.cfdir:	ld e,(hl) 
9243				inc hl 
9243				ld d,(hl) 
9243				inc hl 
9243			 
9243				ex de, hl 
9243				call ishlzero 
9243				ret z     ; return on null pointer 
9243				call free 
9243				ex de, hl 
9243				jr .cfdir 
9243			 
9243			 
9243				ret 
9243			 
9243			 
9243			config_dir: 
9243			 
9243				; for the config menus that need to build a directory of storage call this routine 
9243				; it will construct a menu in scratch to pass to menu 
9243			 
9243				; open storage device 
9243			 
9243				; execute DIR to build a list of files and their ids into scratch in menu format 
9243				; once the menu has finished then will need to call config_fdir to release the strings 
9243				 
9243				; c = number items 
9243			 
9243				 
9243				call storage_get_block_0 
9243			 
9243				ld hl, store_page     ; get current id count 
9243				ld b, (hl) 
9243				ld c, 0    ; count of files   
9243			 
9243			 
9243				ld hl, scratch 
9243				ld (store_tmp2), hl    ; location to poke strings 
9243			 
9243				; check for empty drive 
9243			 
9243				ld a, 0 
9243				cp b 
9243				jp z, .dirdone 
9243			 
9243				 
9243					if DEBUG_FORTH_WORDS 
9243						DMARK "Cdc" 
9243						CALLMONITOR 
9243					endif 
9243			 
9243			 
9243			.diritem:	 
9243				push bc 
9243				; for each of the current ids do a search for them and if found push to stack 
9243			 
9243					ld hl, STORE_BLOCK_PHY 
9243					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9243					ld e,b 
9243			 
9243					call storage_findnextid 
9243			 
9243			 
9243					; if found hl will be non zero 
9243			 
9243					call ishlzero 
9243					jr z, .dirnotfound 
9243			 
9243					; increase count 
9243			 
9243					pop bc	 
9243					inc c 
9243					push bc 
9243					 
9243			 
9243					; get file header and push the file name 
9243			 
9243					ld de, store_page 
9243					call storage_read_block 
9243			 
9243					; push file id to stack 
9243				 
9243					ld a, (store_page) 
9243					ld h, 0 
9243					ld l, a 
9243			 
9243					;call forth_push_numhl 
9243					; TODO store id 
9243			 
9243					push hl 
9243			 
9243					; push extent count to stack  
9243				 
9243					ld hl, store_page+3 
9243			 
9243					; get file name length 
9243			 
9243					call strlenz   
9243			 
9243					inc hl   ; cover zero term 
9243					inc hl  ; stick the id at the end of the area 
9243			 
9243					push hl 
9243					pop bc    ; move length to bc 
9243			 
9243					call malloc 
9243			 
9243					; TODO save malloc area to scratch 
9243			 
9243					ex de, hl 
9243					ld hl, (store_tmp2) 
9243					ld (hl), e 
9243					inc hl 
9243					ld (hl), d 
9243					inc hl 
9243					ld (store_tmp2), hl 
9243			 
9243					 
9243			 
9243					;pop hl   ; get source 
9243			;		ex de, hl    ; swap aronund	 
9243			 
9243					ld hl, store_page+3 
9243					if DEBUG_FORTH_WORDS 
9243						DMARK "CFd" 
9243						CALLMONITOR 
9243					endif 
9243					ldir 
9243			 
9243					; de is past string, move back one and store id 
9243					 
9243					dec de 
9243			 
9243					; store file id 
9243			 
9243					pop hl 
9243					ex de,hl 
9243					ld (hl), e 
9243			 
9243					if DEBUG_FORTH_WORDS 
9243						DMARK "Cdi" 
9243						CALLMONITOR 
9243					endif 
9243					 
9243			.dirnotfound: 
9243					pop bc     
9243					djnz .diritem 
9243				 
9243			.dirdone:	 
9243			 
9243					ld a, 0 
9243					ld hl, (store_tmp2) 
9243					ld (hl), a 
9243					inc hl 
9243					ld (hl), a 
9243					inc hl 
9243					; push a count of the dir items found 
9243			 
9243			;		ld h, 0 
9243			;		ld l, c 
9243			 
9243				ret 
9243			 
9243			endif 
9243			 
9243			 
9243			; Settings 
9243			; Run  
9243			 
9243			 
9243			 
9243			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9243			;;hd_menu2:   db "        2: Editor",0   
9243			;hd_menu2:   db "        2: Editor       6: Menu",0   
9243			;hd_menu3:   db "        3: Storage",0 
9243			;hd_menu4:   db "0=quit  4: Debug",0 
9243			;hd_don:     db "ON",0 
9243			;hd_doff:     db "OFF",0 
9243			; 
9243			; 
9243			; 
9243			;hardware_diags_old:       
9243			; 
9243			;.diagmenu: 
9243			;	call clear_display 
9243			;	ld a, display_row_1 
9243			;	ld de, hd_menu1 
9243			;	call str_at_display 
9243			; 
9243			;	ld a, display_row_2 
9243			;	ld de, hd_menu2 
9243			;	call str_at_display 
9243			; 
9243			;	ld a, display_row_3 
9243			;	ld de, hd_menu3 
9243			;	call str_at_display 
9243			; 
9243			;	ld a,  display_row_4 
9243			;	ld de, hd_menu4 
9243			;	call str_at_display 
9243			; 
9243			;	; display debug state 
9243			; 
9243			;	ld de, hd_don 
9243			;	ld a, (os_view_disable) 
9243			;	cp 0 
9243			;	jr z, .distog 
9243			;	ld de, hd_doff 
9243			;.distog: ld a, display_row_4+17 
9243			;	call str_at_display 
9243			; 
9243			;	call update_display 
9243			; 
9243			;	call cin_wait 
9243			; 
9243			; 
9243			; 
9243			;	cp '4' 
9243			;	jr nz, .diagn1 
9243			; 
9243			;	; debug toggle 
9243			; 
9243			;	ld a, (os_view_disable) 
9243			;	ld b, '*' 
9243			;	cp 0 
9243			;	jr z, .debtog 
9243			;	ld b, 0 
9243			;.debtog:	 
9243			;	ld a,b 
9243			;	ld (os_view_disable),a 
9243			; 
9243			;.diagn1: cp '0' 
9243			;	 ret z 
9243			; 
9243			;;	cp '1' 
9243			;;       jp z, matrix	 
9243			;;   TODO keyboard matrix test 
9243			; 
9243			;	cp '2' 
9243			;	jp z, .diagedit 
9243			; 
9243			;;	cp '6' 
9243			;;	jp z, .menutest 
9243			;;if ENABLE_BASIC 
9243			;;	cp '6' 
9243			;;	jp z, basic 
9243			;;endif 
9243			 ; 
9243			;	jp .diagmenu 
9243			; 
9243			; 
9243			;	ret 
9243			 
9243			 
9243			.debug_tog: 
9243 21 8a 92			ld hl, .menudebug 
9246				 
9246 3a 48 e3			ld a, (os_view_disable) 
9249 fe 2a			cp '*' 
924b 20 04			jr nz,.tdon  
924d 3e 01			ld a, 1 
924f 18 02			jr .tog1 
9251 3e 00		.tdon: ld a, 0 
9253			 
9253			.tog1: 
9253 cd 7f 89			call menu 
9256 fe 00			cp 0 
9258 c8				ret z 
9259 fe 01			cp 1    ; disable debug 
925b 28 04			jr z, .dtog0 
925d 3e 2a			ld a, '*' 
925f 18 02			jr .dtogset 
9261 3e 00		.dtog0: ld a, 0 
9263 32 48 e3		.dtogset:  ld (os_view_disable), a 
9266 c3 43 92			jp .debug_tog 
9269			 
9269			 
9269			hardware_diags:       
9269			 
9269			.diagm: 
9269 21 7c 92			ld hl, .menuitems 
926c 3e 00			ld a, 0 
926e cd 7f 89			call menu 
9271			 
9271 fe 00		         cp 0 
9273 c8				 ret z 
9274			 
9274 fe 02			cp 2 
9276 ca d5 92			jp z, .diagedit 
9279			 
9279			;	cp '6' 
9279			;	jp z, .menutest 
9279			;if ENABLE_BASIC 
9279			;	cp '6' 
9279			;	jp z, basic 
9279			;endif 
9279			  
9279 c3 69 92			jp .diagm 
927c			 
927c				 
927c 90 92		.menuitems:   	dw .m1 
927e 9b 92				dw .m2 
9280 a2 92				dw .m3 
9282 aa 92				dw .m5 
9284 b0 92				dw .m5a 
9286 b9 92				dw .m5b 
9288 00 00				dw 0 
928a			 
928a			.menudebug: 
928a c2 92				dw .m6 
928c cb 92				dw .m7 
928e 00 00				dw 0 
9290			 
9290 .. 00		.m1:   db "Key Matrix",0 
929b .. 00		.m2:   db "Editor",0 
92a2 .. 00		.m3:   db "Storage",0 
92aa .. 00		.m5:   db "Sound",0 
92b0 .. 00		.m5a:  db "RAM Test",0 
92b9 .. 00		.m5b:  db "LCD Test",0 
92c2			 
92c2 .. 00		.m6:   db "Debug ON",0 
92cb .. 00		.m7:   db "Debug OFF",0 
92d5			 
92d5			; debug editor 
92d5			 
92d5			.diagedit: 
92d5			 
92d5 21 57 e3			ld hl, scratch 
92d8			;	ld bc, 250 
92d8			;	ldir 
92d8				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92d8 3e 00			ld a, 0 
92da 77				ld (hl), a 
92db 23				inc hl 
92dc 77				ld (hl), a 
92dd 23				inc hl 
92de 77				ld (hl), a 
92df			 
92df cd 4e 89		        call clear_display 
92e2 cd 71 89			call update_display 
92e5				;ld a, 1 
92e5				;ld (hardware_diag), a 
92e5			.diloop: 
92e5 3e 00			ld a, display_row_1 
92e7 0e 00			ld c, 0 
92e9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92eb 1e 28			ld e, 40 
92ed			 
92ed 21 57 e3			ld hl, scratch	 
92f0 cd a8 8b			call input_str 
92f3			 
92f3 3e 28			ld a, display_row_2 
92f5 11 57 e3			ld de, scratch 
92f8 cd 61 89			call str_at_display 
92fb cd 71 89			call update_display 
92fe			 
92fe c3 e5 92			jp .diloop 
9301			 
9301			 
9301			; pass word in hl 
9301			; a has display location 
9301			display_word_at: 
9301 f5				push af 
9302 e5				push hl 
9303 7c				ld a,h 
9304 21 5c e6			ld hl, os_word_scratch 
9307 cd 7c 8e			call hexout 
930a e1				pop hl 
930b 7d				ld a,l 
930c 21 5e e6			ld hl, os_word_scratch+2 
930f cd 7c 8e			call hexout 
9312 21 60 e6			ld hl, os_word_scratch+4 
9315 3e 00			ld a,0 
9317 77				ld (hl),a 
9318 11 5c e6			ld de,os_word_scratch 
931b f1				pop af 
931c cd 61 89				call str_at_display 
931f c9				ret 
9320			 
9320			display_ptr_state: 
9320			 
9320				; to restore afterwards 
9320			 
9320 d5				push de 
9321 c5				push bc 
9322 e5				push hl 
9323 f5				push af 
9324			 
9324				; for use in here 
9324			 
9324			;	push bc 
9324			;	push de 
9324			;	push hl 
9324			;	push af 
9324			 
9324 cd 4e 89			call clear_display 
9327			 
9327 11 fa 94			ld de, .ptrstate 
932a 3e 00			ld a, display_row_1 
932c cd 61 89			call str_at_display 
932f			 
932f				; display debug step 
932f			 
932f			 
932f 11 71 ee			ld de, debug_mark 
9332 3e 26			ld a, display_row_1+display_cols-2 
9334 cd 61 89			call str_at_display 
9337			 
9337				; display a 
9337 11 04 95			ld de, .ptrcliptr 
933a 3e 28			ld a, display_row_2 
933c cd 61 89			call str_at_display 
933f			 
933f f1				pop af 
9340 2a 22 eb			ld hl,(cli_ptr) 
9343 3e 30			ld a, display_row_2+8 
9345 cd 01 93			call display_word_at 
9348			 
9348			 
9348				; display hl 
9348			 
9348			 
9348 11 0c 95			ld de, .ptrclioptr 
934b 3e 32			ld a, display_row_2+10 
934d cd 61 89			call str_at_display 
9350			; 
9350			;	pop hl 
9350 3e 35			ld a, display_row_2+13 
9352 2a 20 eb			ld hl,(cli_origptr) 
9355 cd 01 93			call display_word_at 
9358			; 
9358			;	 
9358			;	; display de 
9358			 
9358			;	ld de, .regstatede 
9358			;	ld a, display_row_3 
9358			;	call str_at_display 
9358			 
9358			;	pop de 
9358			;	ld h,d 
9358			;	ld l, e 
9358			;	ld a, display_row_3+3 
9358			;	call display_word_at 
9358			 
9358			 
9358				; display bc 
9358			 
9358			;	ld de, .regstatebc 
9358			;	ld a, display_row_3+10 
9358			;	call str_at_display 
9358			 
9358			;	pop bc 
9358			;	ld h,b 
9358			;	ld l, c 
9358			;	ld a, display_row_3+13 
9358			;	call display_word_at 
9358			 
9358			 
9358				; display dsp 
9358			 
9358			;	ld de, .regstatedsp 
9358			;	ld a, display_row_4 
9358			;	call str_at_display 
9358			 
9358				 
9358			;	ld hl,(cli_data_sp) 
9358			;	ld a, display_row_4+4 
9358			;	call display_word_at 
9358			 
9358				; display rsp 
9358			 
9358 11 3b 95			ld de, .regstatersp 
935b 3e 82			ld a, display_row_4+10 
935d cd 61 89			call str_at_display 
9360			 
9360				 
9360 2a 08 eb			ld hl,(cli_ret_sp) 
9363 3e 86			ld a, display_row_4+14 
9365 cd 01 93			call display_word_at 
9368			 
9368 cd 71 89			call update_display 
936b			 
936b cd cb 88			call delay1s 
936e cd cb 88			call delay1s 
9371 cd cb 88			call delay1s 
9374			 
9374			 
9374 cd 4e 99			call next_page_prompt 
9377			 
9377				; restore  
9377			 
9377 f1				pop af 
9378 e1				pop hl 
9379 c1				pop bc 
937a d1				pop de 
937b c9				ret 
937c			 
937c			break_point_state: 
937c f5				push af 
937d			 
937d				; see if disabled 
937d			 
937d 3a 48 e3			ld a, (os_view_disable) 
9380 fe 2a			cp '*' 
9382 20 02			jr nz, .bpsgo 
9384 f1				pop af 
9385 c9				ret 
9386			 
9386			.bpsgo: 
9386 f1				pop af 
9387 f5				push af 
9388 22 44 e3			ld (os_view_hl), hl 
938b ed 53 42 e3		ld (os_view_de), de 
938f ed 43 40 e3		ld (os_view_bc), bc 
9393 e5				push hl 
9394 6f				ld l, a 
9395 26 00			ld h, 0 
9397 22 46 e3			ld (os_view_af),hl 
939a			 
939a 21 b7 ed				ld hl, display_fb0 
939d 22 d2 eb				ld (display_fb_active), hl 
93a0 e1				pop hl	 
93a1			 
93a1 3e 31			ld a, '1' 
93a3 fe 2a		.bps1:  cp '*' 
93a5 20 03			jr nz, .bps1b 
93a7 32 48 e3			ld (os_view_disable),a 
93aa fe 31		.bps1b:  cp '1' 
93ac 20 14			jr nz, .bps2 
93ae			 
93ae				; display reg 
93ae			 
93ae				 
93ae			 
93ae 3a 46 e3			ld a, (os_view_af) 
93b1 2a 44 e3			ld hl, (os_view_hl) 
93b4 ed 5b 42 e3		ld de, (os_view_de) 
93b8 ed 4b 40 e3		ld bc, (os_view_bc) 
93bc cd 56 94			call display_reg_state 
93bf c3 42 94			jp .bpschk 
93c2			 
93c2 fe 32		.bps2:  cp '2' 
93c4 20 08			jr nz, .bps3 
93c6				 
93c6				; display hl 
93c6 2a 44 e3			ld hl, (os_view_hl) 
93c9 cd 40 95			call display_dump_at_hl 
93cc			 
93cc 18 74			jr .bpschk 
93ce			 
93ce fe 33		.bps3:  cp '3' 
93d0 20 08			jr nz, .bps4 
93d2			 
93d2			        ; display de 
93d2 2a 42 e3			ld hl, (os_view_de) 
93d5 cd 40 95			call display_dump_at_hl 
93d8			 
93d8 18 68			jr .bpschk 
93da fe 34		.bps4:  cp '4' 
93dc 20 08			jr nz, .bps5 
93de			 
93de			        ; display bc 
93de 2a 40 e3			ld hl, (os_view_bc) 
93e1 cd 40 95			call display_dump_at_hl 
93e4			 
93e4 18 5c			jr .bpschk 
93e6 fe 35		.bps5:  cp '5' 
93e8 20 08		        jr nz, .bps7 
93ea			 
93ea				; display cur ptr 
93ea 2a 22 eb			ld hl, (cli_ptr) 
93ed cd 40 95			call display_dump_at_hl 
93f0			 
93f0 18 50			jr .bpschk 
93f2 fe 36		.bps7:  cp '6' 
93f4 20 08			jr nz, .bps8b 
93f6				 
93f6				; display cur orig ptr 
93f6 2a 20 eb			ld hl, (cli_origptr) 
93f9 cd 40 95			call display_dump_at_hl 
93fc 18 44			jr .bpschk 
93fe fe 37		.bps8b:  cp '7' 
9400 20 08			jr nz, .bps9 
9402				 
9402				; display dsp 
9402 2a 04 eb			ld hl, (cli_data_sp) 
9405 cd 40 95			call display_dump_at_hl 
9408			 
9408 18 38			jr .bpschk 
940a fe 39		.bps9:  cp '9' 
940c 20 05			jr nz, .bps8c 
940e				 
940e				; display SP 
940e			;	ld hl, sp 
940e cd 40 95			call display_dump_at_hl 
9411			 
9411 18 2f			jr .bpschk 
9413 fe 38		.bps8c:  cp '8' 
9415 20 08			jr nz, .bps8d 
9417				 
9417				; display rsp 
9417 2a 08 eb			ld hl, (cli_ret_sp) 
941a cd 40 95			call display_dump_at_hl 
941d			 
941d 18 23			jr .bpschk 
941f fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9421 20 05			jr nz, .bps8 
9423 cd 44 97			call monitor 
9426			 
9426 18 1a			jr .bpschk 
9428 fe 30		.bps8:  cp '0' 
942a 20 16			jr nz, .bpschk 
942c			 
942c 21 16 ed				ld hl, display_fb1 
942f 22 d2 eb				ld (display_fb_active), hl 
9432 cd 71 89				call update_display 
9435			 
9435				;ld a, (os_view_af) 
9435 2a 44 e3			ld hl, (os_view_hl) 
9438 ed 5b 42 e3		ld de, (os_view_de) 
943c ed 4b 40 e3		ld bc, (os_view_bc) 
9440 f1				pop af 
9441 c9				ret 
9442			 
9442			.bpschk:   
9442 cd cb 88			call delay1s 
9445 3e 9f		ld a,display_row_4 + display_cols - 1 
9447 11 4c 99		        ld de, endprg 
944a cd 61 89			call str_at_display 
944d cd 71 89			call update_display 
9450 cd d6 d8			call cin_wait 
9453			 
9453 c3 a3 93			jp .bps1 
9456			 
9456			 
9456			display_reg_state: 
9456			 
9456				; to restore afterwards 
9456			 
9456 d5				push de 
9457 c5				push bc 
9458 e5				push hl 
9459 f5				push af 
945a			 
945a				; for use in here 
945a			 
945a c5				push bc 
945b d5				push de 
945c e5				push hl 
945d f5				push af 
945e			 
945e cd 4e 89			call clear_display 
9461			 
9461 11 16 95			ld de, .regstate 
9464 3e 00			ld a, display_row_1 
9466 cd 61 89			call str_at_display 
9469			 
9469				; display debug step 
9469			 
9469			 
9469 11 71 ee			ld de, debug_mark 
946c 3e 25			ld a, display_row_1+display_cols-3 
946e cd 61 89			call str_at_display 
9471			 
9471				; display a 
9471 11 32 95			ld de, .regstatea 
9474 3e 28			ld a, display_row_2 
9476 cd 61 89			call str_at_display 
9479			 
9479 e1				pop hl 
947a			;	ld h,0 
947a			;	ld l, a 
947a 3e 2b			ld a, display_row_2+3 
947c cd 01 93			call display_word_at 
947f			 
947f			 
947f				; display hl 
947f			 
947f			 
947f 11 26 95			ld de, .regstatehl 
9482 3e 32			ld a, display_row_2+10 
9484 cd 61 89			call str_at_display 
9487			 
9487 e1				pop hl 
9488 3e 35			ld a, display_row_2+13 
948a cd 01 93			call display_word_at 
948d			 
948d				 
948d				; display de 
948d			 
948d 11 2a 95			ld de, .regstatede 
9490 3e 50			ld a, display_row_3 
9492 cd 61 89			call str_at_display 
9495			 
9495 e1				pop hl 
9496			;	ld h,d 
9496			;	ld l, e 
9496 3e 53			ld a, display_row_3+3 
9498 cd 01 93			call display_word_at 
949b			 
949b			 
949b				; display bc 
949b			 
949b 11 2e 95			ld de, .regstatebc 
949e 3e 5a			ld a, display_row_3+10 
94a0 cd 61 89			call str_at_display 
94a3			 
94a3 e1				pop hl 
94a4			;	ld h,b 
94a4			;	ld l, c 
94a4 3e 5d			ld a, display_row_3+13 
94a6 cd 01 93			call display_word_at 
94a9			 
94a9			 
94a9				; display dsp 
94a9			 
94a9 11 36 95			ld de, .regstatedsp 
94ac 3e 78			ld a, display_row_4 
94ae cd 61 89			call str_at_display 
94b1			 
94b1				 
94b1 2a 04 eb			ld hl,(cli_data_sp) 
94b4 3e 7c			ld a, display_row_4+4 
94b6 cd 01 93			call display_word_at 
94b9			 
94b9				; display rsp 
94b9			 
94b9 11 3b 95			ld de, .regstatersp 
94bc 3e 82			ld a, display_row_4+10 
94be cd 61 89			call str_at_display 
94c1			 
94c1				 
94c1 2a 08 eb			ld hl,(cli_ret_sp) 
94c4 3e 86			ld a, display_row_4+14 
94c6 cd 01 93			call display_word_at 
94c9			 
94c9 cd 71 89			call update_display 
94cc			 
94cc			;	call delay1s 
94cc			;	call delay1s 
94cc			;	call delay1s 
94cc			 
94cc			 
94cc			;	call next_page_prompt 
94cc			 
94cc				; restore  
94cc			 
94cc f1				pop af 
94cd e1				pop hl 
94ce c1				pop bc 
94cf d1				pop de 
94d0 c9				ret 
94d1			 
94d1 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94e5 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94fa .. 00		.ptrstate:	db "Ptr State",0 
9504 .. 00		.ptrcliptr:     db "cli_ptr",0 
950c .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9516 .. 00		.regstate:	db "Reg State (1/0)",0 
9526 .. 00		.regstatehl:	db "HL:",0 
952a .. 00		.regstatede:	db "DE:",0 
952e .. 00		.regstatebc:	db "BC:",0 
9532 .. 00		.regstatea:	db "A :",0 
9536 .. 00		.regstatedsp:	db "DSP:",0 
953b .. 00		.regstatersp:	db "RSP:",0 
9540			 
9540			display_dump_at_hl: 
9540 e5				push hl 
9541 d5				push de 
9542 c5				push bc 
9543 f5				push af 
9544			 
9544 22 7a e6			ld (os_cur_ptr),hl	 
9547 cd 4e 89			call clear_display 
954a cd 56 98			call dumpcont 
954d			;	call delay1s 
954d			;	call next_page_prompt 
954d			 
954d			 
954d f1				pop af 
954e c1				pop bc 
954f d1				pop de 
9550 e1				pop hl 
9551 c9				ret 
9552			 
9552			;if ENABLE_BASIC 
9552			;	include "nascombasic.asm" 
9552			;	basic: 
9552			;	include "forth/FORTH.ASM" 
9552			;endif 
9552			 
9552			; eof 
9552			 
9552			 
# End of file firmware_diags.asm
9552			  
9552			include "firmware_prompts.asm"  
9552			; Prompts  
9552			 
9552			; boot messages 
9552			 
9552 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
9567 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9577			 
9577			 
9577			; config menus 
9577			 
9577 .. 00		prom_c3: db "Add Dictionary To File",0 
958e .. 00		prom_c2: db "Select Autoload File",0 
95a3 .. 00		prom_c2a: db "Disable Autoload File", 0 
95b9 .. 00		prom_c2b: db "Select Storage Bank",0 
95cd .. 00		prom_c4: db "Settings",0 
95d6 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
95f1 .. 00		prom_m4b:   db "Monitor",0 
95f9 .. 00		prom_c1: db "Hardware Diags",0 
9608			 
9608			 
9608 .. 00		prom_notav:    db "Feature not available",0 
961e .. 00		prom_empty:    db "",0 
961f			 
961f			; eof 
961f			 
# End of file firmware_prompts.asm
961f			  
961f			  
961f			; eof  
961f			  
# End of file firmware.asm
961f			 
961f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
961f			;if BASE_KEV  
961f			;baseram: equ 08000h 
961f			;endif 
961f			 
961f			;if BASE_SC114 
961f			;baseram:     equ    endofcode 
961f			;endif 
961f			 
961f			 
961f			; start system 
961f			 
961f			coldstart: 
961f				; set sp 
961f				; di/ei 
961f			 
961f f3				di 
9620 31 00 f0			ld sp, tos 
9623			;	ei 
9623			 
9623			 
9623				; disable breakpoint by default 
9623			 
9623 3e 2a			ld a,'*' 
9625 32 48 e3			ld (os_view_disable),a 
9628			 
9628				; init hardware 
9628			 
9628				; init keyboard and screen hardware 
9628			 
9628 cd 03 80			call hardware_init 
962b			 
962b			 
962b				; detect if any keys are held down to enable breakpoints at start up 
962b			 
962b cd dc d8			call cin  
962e fe 00			cp 0 
9630 28 03			jr z, .nokeys 
9632			 
9632				;call hardware_diags 
9632 cd db 91			call config 
9635			 
9635			;	ld de, .bpen 
9635			;	ld a, display_row_4 
9635			;	call str_at_display 
9635			;	call update_display 
9635			; 
9635			;	ld a,0 
9635			;	ld (os_view_disable),a 
9635			; 
9635			;.bpwait: 
9635			;	call cin 
9635			;	cp 0 
9635			;	jr z, .bpwait 
9635			;	jr .nokeys 
9635			; 
9635			; 
9635			;.bpen:  db "Break points enabled!",0 
9635			 
9635			 
9635			 
9635			 
9635			 
9635			 
9635			.nokeys: 
9635			 
9635			 
9635				 
9635			 
9635			;jp  testkey 
9635			 
9635			;call storage_get_block_0 
9635			; 
9635			;ld hl, 0 
9635			;ld de, store_page 
9635			;call storage_read_block 
9635			 
9635				 
9635			;ld hl, 10 
9635			;ld de, store_page 
9635			;call storage_read_block 
9635			 
9635			 
9635			 
9635			 
9635			 
9635			;stop:	nop 
9635			;	jp stop 
9635			 
9635			 
9635			 
9635			main: 
9635 cd 4e 89			call clear_display 
9638 cd 71 89			call update_display 
963b			 
963b			 
963b			 
963b			;	call testlcd 
963b			 
963b			 
963b			 
963b cd 14 9d			call forth_init 
963e			 
963e			 
963e			warmstart: 
963e cd ea 9c			call forth_warmstart 
9641			 
9641				; run startup word load 
9641			        ; TODO prevent this running at warmstart after crash  
9641			 
9641				if STARTUP_ENABLE 
9641					if STORAGE_SE 
9641						call forth_autoload 
9641					endif 
9641 cd 70 d5				call forth_startup 
9644			 
9644			 
9644				endif 
9644			 
9644				; show free memory after boot 
9644 11 de 96			ld de, freeram 
9647 3e 00			ld a, display_row_1 
9649 cd 61 89			call str_at_display 
964c			 
964c			; Or use heap_size word???? 
964c 21 3d e3			ld hl, heap_end 
964f 11 fa d8			ld de, heap_start 
9652 ed 52			sbc hl, de 
9654 e5				push hl 
9655 7c				ld a,h	         	 
9656 21 5c e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9659 cd 7c 8e			call hexout 
965c e1			   	pop hl 
965d			 
965d 7d				ld a,l 
965e 21 5e e6			ld hl, os_word_scratch+2 
9661 cd 7c 8e			call hexout 
9664 21 60 e6			ld hl, os_word_scratch+4 
9667 3e 00			ld a, 0 
9669 77				ld (hl),a 
966a 11 5c e6			ld de, os_word_scratch 
966d 3e 0d			ld a, display_row_1 + 13 
966f cd 61 89			call str_at_display 
9672 cd 71 89			call update_display 
9675			 
9675			 
9675				;call demo 
9675			 
9675			 
9675				; init scratch input area for cli commands 
9675			 
9675 21 7e e6			ld hl, os_cli_cmd 
9678 3e 00			ld a,0 
967a 77				ld (hl),a 
967b 23				inc hl 
967c 77				ld (hl),a 
967d			 
967d 3e 00			ld a,0 
967f 32 7d e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9682			 
9682 32 7a e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9685 32 7b e6			ld (os_cur_ptr+1),a	 
9688			 
9688 32 5c e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
968b 32 5d e6			ld (os_word_scratch+1),a	 
968e				 
968e			 
968e				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
968e 21 7e e6			ld hl, os_cli_cmd 
9691			 
9691 3e 00			ld a, 0		 ; init cli input 
9693 77				ld (hl), a 
9694 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9696			cli: 
9696				; show cli prompt 
9696				;push af 
9696				;ld a, 0 
9696				;ld de, prompt 
9696				;call str_at_display 
9696			 
9696				;call update_display 
9696				;pop af 
9696				;inc a 
9696				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9696 0e 00			ld c, 0 
9698 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
969a 1e 28			ld e, 40 
969c			 
969c 21 7e e6			ld hl, os_cli_cmd 
969f			 
969f				STACKFRAME OFF $fefe $9f9f 
969f				if DEBUG_STACK_IMB 
969f					if OFF 
969f						exx 
969f						ld de, $fefe 
969f						ld a, d 
969f						ld hl, curframe 
969f						call hexout 
969f						ld a, e 
969f						ld hl, curframe+2 
969f						call hexout 
969f						ld hl, $fefe 
969f						push hl 
969f						ld hl, $9f9f 
969f						push hl 
969f						exx 
969f					endif 
969f				endif 
969f			endm 
# End of macro STACKFRAME
969f			 
969f cd a8 8b			call input_str 
96a2			 
96a2				STACKFRAMECHK OFF $fefe $9f9f 
96a2				if DEBUG_STACK_IMB 
96a2					if OFF 
96a2						exx 
96a2						ld hl, $9f9f 
96a2						pop de   ; $9f9f 
96a2						call cmp16 
96a2						jr nz, .spnosame 
96a2						ld hl, $fefe 
96a2						pop de   ; $fefe 
96a2						call cmp16 
96a2						jr z, .spfrsame 
96a2						.spnosame: call showsperror 
96a2						.spfrsame: nop 
96a2						exx 
96a2					endif 
96a2				endif 
96a2			endm 
# End of macro STACKFRAMECHK
96a2			 
96a2				; copy input to last command 
96a2			 
96a2 21 7e e6			ld hl, os_cli_cmd 
96a5 11 7d e7			ld de, os_last_cmd 
96a8 01 ff 00			ld bc, 255 
96ab ed b0			ldir 
96ad			 
96ad				; wipe current buffer 
96ad			 
96ad			;	ld a, 0 
96ad			;	ld hl, os_cli_cmd 
96ad			;	ld de, os_cli_cmd+1 
96ad			;	ld bc, 254 
96ad			;	ldir 
96ad				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
96ad			;	call strcpy 
96ad			;	ld a, 0 
96ad			;	ld (hl), a 
96ad			;	inc hl 
96ad			;	ld (hl), a 
96ad			;	inc hl 
96ad			;	ld (hl), a 
96ad			 
96ad				; switch frame buffer to program  
96ad			 
96ad 21 16 ed				ld hl, display_fb1 
96b0 22 d2 eb				ld (display_fb_active), hl 
96b3			 
96b3			;	nop 
96b3				STACKFRAME ON $fbfe $8f9f 
96b3				if DEBUG_STACK_IMB 
96b3					if ON 
96b3						exx 
96b3						ld de, $fbfe 
96b3						ld a, d 
96b3						ld hl, curframe 
96b3						call hexout 
96b3						ld a, e 
96b3						ld hl, curframe+2 
96b3						call hexout 
96b3						ld hl, $fbfe 
96b3						push hl 
96b3						ld hl, $8f9f 
96b3						push hl 
96b3						exx 
96b3					endif 
96b3				endif 
96b3			endm 
# End of macro STACKFRAME
96b3				; first time into the parser so pass over the current scratch pad 
96b3 21 7e e6			ld hl,os_cli_cmd 
96b6				; tokenise the entered statement(s) in HL 
96b6 cd 8d 9d			call forthparse 
96b9			        ; exec forth statements in top of return stack 
96b9 cd cd 9d			call forthexec 
96bc				;call forthexec_cleanup 
96bc			;	call parsenext 
96bc			 
96bc				STACKFRAMECHK ON $fbfe $8f9f 
96bc				if DEBUG_STACK_IMB 
96bc					if ON 
96bc						exx 
96bc						ld hl, $8f9f 
96bc						pop de   ; $8f9f 
96bc						call cmp16 
96bc						jr nz, .spnosame 
96bc						ld hl, $fbfe 
96bc						pop de   ; $fbfe 
96bc						call cmp16 
96bc						jr z, .spfrsame 
96bc						.spnosame: call showsperror 
96bc						.spfrsame: nop 
96bc						exx 
96bc					endif 
96bc				endif 
96bc			endm 
# End of macro STACKFRAMECHK
96bc				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
96bc			 
96bc 3e 78			ld a, display_row_4 
96be 11 f0 96			ld de, endprog 
96c1			 
96c1 cd 71 89			call update_display		 
96c4			 
96c4 cd 4e 99			call next_page_prompt 
96c7			 
96c7				; switch frame buffer to cli 
96c7			 
96c7 21 b7 ed				ld hl, display_fb0 
96ca 22 d2 eb				ld (display_fb_active), hl 
96cd			 
96cd			 
96cd cd 4e 89		        call clear_display 
96d0 cd 71 89			call update_display		 
96d3			 
96d3 21 7e e6			ld hl, os_cli_cmd 
96d6			 
96d6 3e 00			ld a, 0		 ; init cli input 
96d8 77				ld (hl), a 
96d9			 
96d9				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
96d9			 
96d9				; now on last line 
96d9			 
96d9				; TODO scroll screen up 
96d9			 
96d9				; TODO instead just clear screen and place at top of screen 
96d9			 
96d9			;	ld a, 0 
96d9			;	ld (f_cursor_ptr),a 
96d9			 
96d9				;call clear_display 
96d9				;call update_display 
96d9			 
96d9				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96d9 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96db c3 96 96			jp cli 
96de			 
96de .. 00		freeram: db "Free bytes: $",0 
96ec ..			asc: db "1A2F" 
96f0 .. 00		endprog: db "End prog...",0 
96fc			 
96fc			testenter2:   
96fc 21 89 e3			ld hl,scratch+50 
96ff 22 7a e6			ld (os_cur_ptr),hl 
9702 c3 96 96			jp cli 
9705			 
9705			testenter:  
9705			 
9705 21 ec 96			ld hl,asc 
9708			;	ld a,(hl) 
9708			;	call nibble2val 
9708 cd d2 8e			call get_byte 
970b			 
970b			 
970b			;	ld a,(hl) 
970b			;	call atohex 
970b			 
970b			;	call fourehexhl 
970b 32 89 e3			ld (scratch+50),a 
970e			 
970e			 
970e			 
970e 21 ee 96			ld hl,asc+2 
9711			;	ld a, (hl) 
9711			;	call nibble2val 
9711 cd d2 8e			call get_byte 
9714			 
9714			;	call fourehexhl 
9714 32 8b e3			ld (scratch+52),a 
9717				 
9717 21 89 e3			ld hl,scratch+50 
971a 22 7a e6			ld (os_cur_ptr),hl 
971d c3 96 96			jp cli 
9720			 
9720			enter:	 
9720 3a 5b e3			ld a,(scratch+4) 
9723 fe 00			cp 0 
9725 28 0c			jr z, .entercont 
9727				; no, not a null term line so has an address to work out.... 
9727			 
9727 21 59 e3			ld hl,scratch+2 
972a cd 32 8f			call get_word_hl 
972d			 
972d 22 7a e6			ld (os_cur_ptr),hl	 
9730 c3 96 96			jp cli 
9733			 
9733			 
9733			.entercont:  
9733			 
9733 21 59 e3			ld hl, scratch+2 
9736 cd d2 8e			call get_byte 
9739			 
9739 2a 7a e6		   	ld hl,(os_cur_ptr) 
973c 77					ld (hl),a 
973d 23					inc hl 
973e 22 7a e6				ld (os_cur_ptr),hl 
9741				 
9741			; get byte  
9741			 
9741			 
9741 c3 96 96			jp cli 
9744			 
9744			 
9744			; basic monitor support 
9744			 
9744			monitor: 
9744				;  
9744 cd 4e 89			call clear_display 
9747 3e 00			ld a, 0 
9749 11 91 97			ld de, .monprompt 
974c cd 61 89			call str_at_display 
974f cd 71 89			call update_display 
9752			 
9752				; get a monitor command 
9752			 
9752 0e 00			ld c, 0     ; entry at top left 
9754 16 64			ld d, 100   ; max buffer size 
9756 1e 0f			ld e, 15    ; input scroll area 
9758 3e 00			ld a, 0     ; init string 
975a 21 55 e5			ld hl, os_input 
975d 77				ld (hl), a 
975e 23				inc hl 
975f 77				ld (hl), a 
9760 21 55 e5			ld hl, os_input 
9763 3e 01			ld a, 1     ; init string 
9765 cd a8 8b			call input_str 
9768			 
9768 cd 4e 89		        call clear_display 
976b cd 71 89			call update_display		 
976e			 
976e 3a 55 e5			ld a, (os_input) 
9771 cd d0 8f			call toUpper 
9774 fe 48		        cp 'H' 
9776 28 6f		        jr z, .monhelp 
9778 fe 44			cp 'D'		; dump 
977a ca 08 98			jp z, .mondump	 
977d fe 43			cp 'C'		; dump 
977f ca 22 98			jp z, .moncdump	 
9782 fe 4d			cp 'M'		; dump 
9784 ca 93 97			jp z, .moneditstart 
9787 fe 55			cp 'U'		; dump 
9789 28 14			jr z, .monedit	 
978b fe 51			cp 'Q'		; dump 
978d c8				ret z	 
978e			 
978e			 
978e				; TODO "S" to access symbol by name and not need the address 
978e				; TODO "F" to find a string in memory 
978e			 
978e c3 44 97			jp monitor 
9791			 
9791 .. 00		.monprompt: db ">", 0 
9793			 
9793			.moneditstart: 
9793				; get starting address 
9793			 
9793 21 57 e5			ld hl,os_input+2 
9796 cd 32 8f			call get_word_hl 
9799			 
9799 22 7a e6			ld (os_cur_ptr),hl	 
979c			 
979c c3 44 97			jp monitor 
979f			 
979f			.monedit: 
979f				; get byte to load 
979f			 
979f 21 57 e5			ld hl,os_input+2 
97a2 cd d2 8e			call get_byte 
97a5			 
97a5				; get address to update 
97a5 2a 7a e6			ld hl, (os_cur_ptr) 
97a8			 
97a8				; update byte 
97a8			 
97a8 77				ld (hl), a 
97a9			 
97a9				; move to next address and save it 
97a9			 
97a9 23				inc hl 
97aa 22 7a e6			ld (os_cur_ptr),hl	 
97ad			 
97ad c3 44 97			jp monitor 
97b0			 
97b0			 
97b0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
97c4 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
97e0 .. 00		.monhelptext3:  db "Q-Quit",0 
97e7			        
97e7			.monhelp: 
97e7 3e 00			ld a, display_row_1 
97e9 11 b0 97		        ld de, .monhelptext1 
97ec			 
97ec cd 61 89			call str_at_display 
97ef 3e 28			ld a, display_row_2 
97f1 11 c4 97		        ld de, .monhelptext2 
97f4					 
97f4 cd 61 89			call str_at_display 
97f7 3e 50			ld a, display_row_3 
97f9 11 e0 97		        ld de, .monhelptext3 
97fc					 
97fc cd 61 89			call str_at_display 
97ff cd 71 89			call update_display		 
9802			 
9802 cd 4e 99			call next_page_prompt 
9805 c3 44 97			jp monitor 
9808			 
9808			.mondump:    
9808 21 57 e5			ld hl,os_input+2 
980b cd 32 8f			call get_word_hl 
980e			 
980e 22 7a e6			ld (os_cur_ptr),hl	 
9811 cd 56 98			call dumpcont 
9814 3e 78			ld a, display_row_4 
9816 11 f0 96			ld de, endprog 
9819			 
9819 cd 71 89			call update_display		 
981c			 
981c cd 4e 99			call next_page_prompt 
981f c3 44 97			jp monitor 
9822			.moncdump: 
9822 cd 56 98			call dumpcont 
9825 3e 78			ld a, display_row_4 
9827 11 f0 96			ld de, endprog 
982a			 
982a cd 71 89			call update_display		 
982d			 
982d cd 4e 99			call next_page_prompt 
9830 c3 44 97			jp monitor 
9833			 
9833			 
9833			; TODO symbol access  
9833			 
9833			.symbols:     ;; A list of symbols that can be called up  
9833 b7 ed			dw display_fb0 
9835 .. 00			db "fb0",0  
9839 5c eb		     	dw store_page 
983b .. 00			db "store_page",0 
9846			 
9846			 
9846			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9846			 
9846 3a 58 e3			ld a,(scratch+1) 
9849 fe 00			cp 0 
984b 28 09			jr z, dumpcont 
984d			 
984d				; no, not a null term line so has an address to work out.... 
984d			 
984d 21 59 e3			ld hl,scratch+2 
9850 cd 32 8f			call get_word_hl 
9853			 
9853 22 7a e6			ld (os_cur_ptr),hl	 
9856			 
9856			 
9856			 
9856			dumpcont: 
9856			 
9856				; dump bytes at ptr 
9856			 
9856			 
9856 3e 00			ld a, display_row_1 
9858 2a d2 eb			ld hl, (display_fb_active) 
985b cd 7b 8b			call addatohl 
985e cd 86 98			call .dumpbyterow 
9861			 
9861 3e 28			ld a, display_row_2 
9863 2a d2 eb			ld hl, (display_fb_active) 
9866 cd 7b 8b			call addatohl 
9869 cd 86 98			call .dumpbyterow 
986c			 
986c			 
986c 3e 50			ld a, display_row_3 
986e 2a d2 eb			ld hl, (display_fb_active) 
9871 cd 7b 8b			call addatohl 
9874 cd 86 98			call .dumpbyterow 
9877			 
9877 3e 78			ld a, display_row_4 
9879 2a d2 eb			ld hl, (display_fb_active) 
987c cd 7b 8b			call addatohl 
987f cd 86 98			call .dumpbyterow 
9882			 
9882 cd 71 89			call update_display 
9885			;		jp cli 
9885 c9				ret 
9886			 
9886			.dumpbyterow: 
9886			 
9886				;push af 
9886			 
9886 e5				push hl 
9887			 
9887				; calc where to poke the ascii 
9887			if display_cols == 20 
9887				ld a, 16 
9887			else 
9887 3e 1f			ld a, 31 
9889			endif 
9889			 
9889 cd 7b 8b			call addatohl 
988c 22 5c e6			ld (os_word_scratch),hl  		; save pos for later 
988f			 
988f			 
988f			; display decoding address 
988f 2a 7a e6		   	ld hl,(os_cur_ptr) 
9892			 
9892 7c				ld a,h 
9893 e1				pop hl 
9894 e5				push hl 
9895			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9895 cd 7c 8e			call hexout 
9898 2a 7a e6		   	ld hl,(os_cur_ptr) 
989b			 
989b 7d				ld a,l 
989c e1				pop hl 
989d 23				inc hl 
989e 23				inc hl 
989f e5				push hl 
98a0			;	ld hl, os_word_scratch+2 
98a0 cd 7c 8e			call hexout 
98a3 e1				pop hl 
98a4 23				inc hl 
98a5 23				inc hl 
98a6				;ld hl, os_word_scratch+4 
98a6 3e 3a			ld a, ':' 
98a8 77				ld (hl),a 
98a9 23				inc hl 
98aa				;ld a, 0 
98aa				;ld (hl),a 
98aa				;ld de, os_word_scratch 
98aa				;pop af 
98aa				;push af 
98aa			;		ld a, display_row_2 
98aa			;		call str_at_display 
98aa			;		call update_display 
98aa			 
98aa			 
98aa			;pop af 
98aa			;	add 5 
98aa			 
98aa			if display_cols == 20 
98aa				ld b, 4 
98aa			else 
98aa 06 08			ld b, 8 
98ac			endif	 
98ac			 
98ac			.dumpbyte: 
98ac c5				push bc 
98ad e5				push hl 
98ae			 
98ae			 
98ae 2a 7a e6		   	ld hl,(os_cur_ptr) 
98b1 7e					ld a,(hl) 
98b2			 
98b2					; poke the ascii to display 
98b2 2a 5c e6				ld hl,(os_word_scratch) 
98b5 77					ld (hl),a 
98b6 23					inc hl 
98b7 22 5c e6				ld (os_word_scratch),hl 
98ba			 
98ba					 
98ba			 
98ba			 
98ba e1					pop hl 
98bb e5					push hl 
98bc			 
98bc cd 7c 8e				call hexout 
98bf			 
98bf					 
98bf 2a 7a e6		   	ld hl,(os_cur_ptr) 
98c2 23				inc hl 
98c3 22 7a e6		   	ld (os_cur_ptr),hl 
98c6			 
98c6 e1					pop hl 
98c7 23					inc hl 
98c8 23					inc hl 
98c9 23					inc hl 
98ca			 
98ca			 
98ca			 
98ca					;ld a,0 
98ca					;ld (os_word_scratch+2),a 
98ca					;pop af 
98ca					;push af 
98ca			 
98ca					;ld de, os_word_scratch 
98ca					;call str_at_display 
98ca			;		call update_display 
98ca			;		pop af 
98ca c1					pop bc 
98cb c6 03				add 3 
98cd 10 dd			djnz .dumpbyte 
98cf			 
98cf				 
98cf			 
98cf c9				ret 
98d0			 
98d0			jump:	 
98d0			 
98d0 21 59 e3			ld hl,scratch+2 
98d3 cd 32 8f			call get_word_hl 
98d6				;ld hl,(scratch+2) 
98d6				;call fourehexhl 
98d6			 
98d6 22 7a e6			ld (os_cur_ptr),hl	 
98d9			 
98d9 e9				jp (hl) 
98da			 
98da			 
98da			 
98da			; TODO implement a basic monitor mode to start with 
98da			 
98da			 
98da			 
98da			 
98da			 
98da			 
98da			 
98da			 
98da			 
98da			; testing and demo code during development 
98da			 
98da			 
98da .. 00		str1: db "Enter some text...",0 
98ed .. 00		clear: db "                    ",0 
9902			 
9902			demo: 
9902			 
9902			 
9902			 
9902			;	call update_display 
9902			 
9902				; init scratch input area for testing 
9902 21 57 e3			ld hl, scratch	 
9905 3e 00			ld a,0 
9907 77				ld (hl),a 
9908			 
9908			 
9908 3e 28		            LD   A, display_row_2 
990a			;            CALL fLCD_Pos       ;Position cursor to location in A 
990a 11 da 98		            LD   DE, str1 
990d cd 61 89			call str_at_display 
9910			 
9910			;            CALL fLCD_Str       ;Display string pointed to by DE 
9910			cloop:	 
9910 3e 50		            LD   A, display_row_3 
9912			;            CALL fLCD_Pos       ;Position cursor to location in A 
9912 11 ed 98		            LD   DE, clear 
9915			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9915 cd 61 89				call str_at_display 
9918 3e 78			ld a, display_row_4 
991a 11 4a 99			ld de, prompt 
991d			 
991d cd 61 89				call str_at_display 
9920 cd 71 89			call update_display 
9923			 
9923 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9925 16 0a			ld d, 10 
9927 21 57 e3			ld hl, scratch	 
992a cd a8 8b			call input_str 
992d			 
992d			;	call clear_display 
992d			;'	call update_display 
992d			 
992d 3e 00		            LD   A, display_row_1 
992f			;            CALL fLCD_Pos       ;Position cursor to location in A 
992f 11 ed 98		            LD   DE, clear 
9932 cd 61 89				call str_at_display 
9935			;            CALL fLCD_Str       ;Display string pointed to by DE 
9935 3e 00		            LD   A, display_row_1 
9937			;            CALL fLCD_Pos       ;Position cursor to location in A 
9937 11 57 e3		            LD   DE, scratch 
993a			;            CALL fLCD_Str       ;Display string pointed to by DE 
993a cd 61 89				call str_at_display 
993d cd 71 89			call update_display 
9940			 
9940 3e 00				ld a,0 
9942 21 57 e3			ld hl, scratch 
9945 77				ld (hl),a 
9946			 
9946 00				nop 
9947 c3 10 99			jp cloop 
994a			 
994a			 
994a			 
994a			; OS Prompt 
994a			 
994a .. 00		prompt: db ">",0 
994c .. 00		endprg: db "?",0 
994e			 
994e			 
994e			; handy next page prompt 
994e			next_page_prompt: 
994e e5				push hl 
994f d5				push de 
9950 f5				push af 
9951 c5				push bc 
9952			 
9952 3e 9f			ld a,display_row_4 + display_cols - 1 
9954 11 4c 99		        ld de, endprg 
9957 cd 61 89			call str_at_display 
995a cd 71 89			call update_display 
995d cd d6 d8			call cin_wait 
9960 c1				pop bc 
9961 f1				pop af 
9962 d1				pop de 
9963 e1				pop hl 
9964			 
9964			 
9964 c9				ret 
9965			 
9965			 
9965			; forth parser 
9965			 
9965			; My forth kernel 
9965			include "forth_kernel.asm" 
9965			; 
9965			; kernel to the forth OS 
9965			 
9965			DS_TYPE_STR: equ 1     ; string type 
9965			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9965			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9965			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9965			 
9965			FORTH_PARSEV1: equ 0 
9965			FORTH_PARSEV2: equ 0 
9965			FORTH_PARSEV3: equ 0 
9965			FORTH_PARSEV4: equ 0 
9965			FORTH_PARSEV5: equ 1 
9965			 
9965			;if FORTH_PARSEV5 
9965			;	FORTH_END_BUFFER: equ 0 
9965			;else 
9965			FORTH_END_BUFFER: equ 127 
9965			;endif 
9965			 
9965			FORTH_TRUE: equ 1 
9965			FORTH_FALSE: equ 0 
9965			 
9965			if FORTH_PARSEV4 
9965			include "forth_stackops.asm" 
9965			endif 
9965			 
9965			if FORTH_PARSEV5 
9965			include "forth_stackopsv5.asm" 
9965			 
9965			; Stack operations for v5 parser on wards 
9965			; * DATA stack 
9965			; * LOOP stack 
9965			; * RETURN stack 
9965			 
9965			 
9965			 
9965			FORTH_CHK_DSP_UNDER: macro 
9965				push hl 
9965				push de 
9965				ld hl,(cli_data_sp) 
9965				ld de, cli_data_stack 
9965				call cmp16 
9965				jp c, fault_dsp_under 
9965				pop de 
9965				pop hl 
9965				endm 
9965			 
9965			 
9965			FORTH_CHK_RSP_UNDER: macro 
9965				push hl 
9965				push de 
9965				ld hl,(cli_ret_sp) 
9965				ld de, cli_ret_stack 
9965				call cmp16 
9965				jp c, fault_rsp_under 
9965				pop de 
9965				pop hl 
9965				endm 
9965			 
9965			FORTH_CHK_LOOP_UNDER: macro 
9965				push hl 
9965				push de 
9965				ld hl,(cli_loop_sp) 
9965				ld de, cli_loop_stack 
9965				call cmp16 
9965				jp c, fault_loop_under 
9965				pop de 
9965				pop hl 
9965				endm 
9965			 
9965			FORTH_ERR_TOS_NOTSTR: macro 
9965				; TOSO might need more for checks when used 
9965				push af 
9965				ld a,(hl) 
9965				cp DS_TYPE_STR 
9965				jp nz, type_faultn   
9965				pop af 
9965				endm 
9965			 
9965			FORTH_ERR_TOS_NOTNUM: macro 
9965				push af 
9965				ld a,(hl) 
9965				cp DS_TYPE_INUM 
9965				jp nz, type_faultn   
9965				pop af 
9965				endm 
9965			 
9965			 
9965			; increase data stack pointer and save hl to it 
9965				 
9965			FORTH_DSP_NEXT: macro 
9965				call macro_forth_dsp_next 
9965				endm 
9965			 
9965			 
9965			macro_forth_dsp_next: 
9965				if DEBUG_FORTH_STACK_GUARD 
9965 cd 3a d6				call check_stacks 
9968				endif 
9968 e5				push hl 
9969 d5				push de 
996a eb				ex de,hl 
996b 2a 04 eb			ld hl,(cli_data_sp) 
996e 23				inc hl 
996f 23				inc hl 
9970			 
9970			; PARSEV5 
9970 23				inc hl 
9971 22 04 eb			ld (cli_data_sp),hl 
9974 73				ld (hl), e 
9975 23				inc hl 
9976 72				ld (hl), d 
9977 d1				pop de 
9978 e1				pop hl 
9979				if DEBUG_FORTH_STACK_GUARD 
9979 cd 3a d6				call check_stacks 
997c				endif 
997c c9				ret 
997d			 
997d			 
997d			; increase ret stack pointer and save hl to it 
997d				 
997d			FORTH_RSP_NEXT: macro 
997d				call macro_forth_rsp_next 
997d				endm 
997d			 
997d			macro_forth_rsp_next: 
997d				if DEBUG_FORTH_STACK_GUARD 
997d cd 3a d6				call check_stacks 
9980				endif 
9980 e5				push hl 
9981 d5				push de 
9982 eb				ex de,hl 
9983 2a 08 eb			ld hl,(cli_ret_sp) 
9986 23				inc hl 
9987 23				inc hl 
9988 22 08 eb			ld (cli_ret_sp),hl 
998b 73				ld (hl), e 
998c 23				inc hl 
998d 72				ld (hl), d 
998e d1				pop de 
998f e1				pop hl 
9990				if DEBUG_FORTH_STACK_GUARD 
9990 cd 3a d6				call check_stacks 
9993				endif 
9993 c9				ret 
9994			 
9994			; get current ret stack pointer and save to hl  
9994				 
9994			FORTH_RSP_TOS: macro 
9994				call macro_forth_rsp_tos 
9994				endm 
9994			 
9994			macro_forth_rsp_tos: 
9994				;push de 
9994 2a 08 eb			ld hl,(cli_ret_sp) 
9997 cd cf 99			call loadhlptrtohl 
999a				;ld e, (hl) 
999a				;inc hl 
999a				;ld d, (hl) 
999a				;ex de, hl 
999a					if DEBUG_FORTH_WORDS 
999a			;			DMARK "RST" 
999a						CALLMONITOR 
999a cd 7c 93			call break_point_state  
999d				endm  
# End of macro CALLMONITOR
999d					endif 
999d				;pop de 
999d c9				ret 
999e			 
999e			; pop ret stack pointer 
999e				 
999e			FORTH_RSP_POP: macro 
999e				call macro_forth_rsp_pop 
999e				endm 
999e			 
999e			 
999e			macro_forth_rsp_pop: 
999e				if DEBUG_FORTH_STACK_GUARD 
999e			;		DMARK "RPP" 
999e cd 3a d6				call check_stacks 
99a1					FORTH_CHK_RSP_UNDER 
99a1 e5				push hl 
99a2 d5				push de 
99a3 2a 08 eb			ld hl,(cli_ret_sp) 
99a6 11 c2 ea			ld de, cli_ret_stack 
99a9 cd 99 8b			call cmp16 
99ac da 4e d7			jp c, fault_rsp_under 
99af d1				pop de 
99b0 e1				pop hl 
99b1				endm 
# End of macro FORTH_CHK_RSP_UNDER
99b1				endif 
99b1 e5				push hl 
99b2 2a 08 eb			ld hl,(cli_ret_sp) 
99b5			 
99b5			 
99b5				if FORTH_ENABLE_FREE 
99b5			 
99b5					; get pointer 
99b5			 
99b5					push de 
99b5					push hl 
99b5			 
99b5					ld e, (hl) 
99b5					inc hl 
99b5					ld d, (hl) 
99b5			 
99b5					ex de, hl 
99b5					call free 
99b5			 
99b5					pop hl 
99b5					pop de 
99b5			 
99b5			 
99b5				endif 
99b5			 
99b5			 
99b5 2b				dec hl 
99b6 2b				dec hl 
99b7 22 08 eb			ld (cli_ret_sp), hl 
99ba				; do stack underflow checks 
99ba e1				pop hl 
99bb				if DEBUG_FORTH_STACK_GUARD 
99bb cd 3a d6				call check_stacks 
99be					FORTH_CHK_RSP_UNDER 
99be e5				push hl 
99bf d5				push de 
99c0 2a 08 eb			ld hl,(cli_ret_sp) 
99c3 11 c2 ea			ld de, cli_ret_stack 
99c6 cd 99 8b			call cmp16 
99c9 da 4e d7			jp c, fault_rsp_under 
99cc d1				pop de 
99cd e1				pop hl 
99ce				endm 
# End of macro FORTH_CHK_RSP_UNDER
99ce				endif 
99ce c9				ret 
99cf			 
99cf			 
99cf			 
99cf			; routine to load word pointed to by hl into hl 
99cf			 
99cf			loadhlptrtohl: 
99cf			 
99cf d5				push de 
99d0 5e				ld e, (hl) 
99d1 23				inc hl 
99d2 56				ld d, (hl) 
99d3 eb				ex de, hl 
99d4 d1				pop de 
99d5			 
99d5 c9				ret 
99d6			 
99d6			 
99d6			 
99d6			 
99d6			 
99d6			; push a number held in HL onto the data stack 
99d6			; entry point for pushing a value when already in hl used in function above 
99d6			 
99d6			forth_push_numhl: 
99d6			 
99d6 e5				push hl    ; save value to push 
99d7			 
99d7			if DEBUG_FORTH_PUSH 
99d7				; see if disabled 
99d7			 
99d7			 
99d7 f5				push af 
99d8 3a 48 e3			ld a, (os_view_disable) 
99db fe 2a			cp '*' 
99dd 28 34			jr z, .pskip2 
99df e5				push hl 
99e0 e5			push hl 
99e1 cd 4e 89			call clear_display 
99e4 e1			pop hl 
99e5 7c				ld a,h 
99e6 21 5c e6			ld hl, os_word_scratch 
99e9 cd 7c 8e			call hexout 
99ec e1				pop hl 
99ed 7d				ld a,l 
99ee 21 5e e6			ld hl, os_word_scratch+2 
99f1 cd 7c 8e			call hexout 
99f4			 
99f4 21 60 e6			ld hl, os_word_scratch+4 
99f7 3e 00			ld a,0 
99f9 77				ld (hl),a 
99fa 11 5c e6			ld de,os_word_scratch 
99fd 3e 28				ld a, display_row_2 
99ff cd 61 89				call str_at_display 
9a02 11 19 c5			ld de, .push_num 
9a05 3e 00			ld a, display_row_1 
9a07			 
9a07 cd 61 89				call str_at_display 
9a0a			 
9a0a			 
9a0a cd 71 89			call update_display 
9a0d cd cb 88			call delay1s 
9a10 cd cb 88			call delay1s 
9a13			.pskip2:  
9a13			 
9a13 f1				pop af 
9a14			endif	 
9a14			 
9a14			 
9a14				FORTH_DSP_NEXT 
9a14 cd 65 99			call macro_forth_dsp_next 
9a17				endm 
# End of macro FORTH_DSP_NEXT
9a17			 
9a17 2a 04 eb			ld hl, (cli_data_sp) 
9a1a			 
9a1a				; save item type 
9a1a 3e 02			ld a,  DS_TYPE_INUM 
9a1c 77				ld (hl), a 
9a1d 23				inc hl 
9a1e			 
9a1e				; get word off stack 
9a1e d1				pop de 
9a1f 7b				ld a,e 
9a20 77				ld (hl), a 
9a21 23				inc hl 
9a22 7a				ld a,d 
9a23 77				ld (hl), a 
9a24			 
9a24			if DEBUG_FORTH_PUSH 
9a24 2b				dec hl 
9a25 2b				dec hl 
9a26 2b				dec hl 
9a27						DMARK "PH5" 
9a27 f5				push af  
9a28 3a 3c 9a			ld a, (.dmark)  
9a2b 32 71 ee			ld (debug_mark),a  
9a2e 3a 3d 9a			ld a, (.dmark+1)  
9a31 32 72 ee			ld (debug_mark+1),a  
9a34 3a 3e 9a			ld a, (.dmark+2)  
9a37 32 73 ee			ld (debug_mark+2),a  
9a3a 18 03			jr .pastdmark  
9a3c ..			.dmark: db "PH5"  
9a3f f1			.pastdmark: pop af  
9a40			endm  
# End of macro DMARK
9a40				CALLMONITOR 
9a40 cd 7c 93			call break_point_state  
9a43				endm  
# End of macro CALLMONITOR
9a43			endif	 
9a43			 
9a43 c9				ret 
9a44			 
9a44			 
9a44			; Push a string to stack pointed to by hl 
9a44			 
9a44			forth_push_str: 
9a44			 
9a44			if DEBUG_FORTH_PUSH 
9a44						DMARK "PSQ" 
9a44 f5				push af  
9a45 3a 59 9a			ld a, (.dmark)  
9a48 32 71 ee			ld (debug_mark),a  
9a4b 3a 5a 9a			ld a, (.dmark+1)  
9a4e 32 72 ee			ld (debug_mark+1),a  
9a51 3a 5b 9a			ld a, (.dmark+2)  
9a54 32 73 ee			ld (debug_mark+2),a  
9a57 18 03			jr .pastdmark  
9a59 ..			.dmark: db "PSQ"  
9a5c f1			.pastdmark: pop af  
9a5d			endm  
# End of macro DMARK
9a5d				CALLMONITOR 
9a5d cd 7c 93			call break_point_state  
9a60				endm  
# End of macro CALLMONITOR
9a60			endif	 
9a60			    
9a60 e5				push hl 
9a61 e5				push hl 
9a62			 
9a62			;	ld a, 0   ; find end of string 
9a62 cd d9 8f			call strlenz 
9a65			if DEBUG_FORTH_PUSH 
9a65						DMARK "PQ2" 
9a65 f5				push af  
9a66 3a 7a 9a			ld a, (.dmark)  
9a69 32 71 ee			ld (debug_mark),a  
9a6c 3a 7b 9a			ld a, (.dmark+1)  
9a6f 32 72 ee			ld (debug_mark+1),a  
9a72 3a 7c 9a			ld a, (.dmark+2)  
9a75 32 73 ee			ld (debug_mark+2),a  
9a78 18 03			jr .pastdmark  
9a7a ..			.dmark: db "PQ2"  
9a7d f1			.pastdmark: pop af  
9a7e			endm  
# End of macro DMARK
9a7e				CALLMONITOR 
9a7e cd 7c 93			call break_point_state  
9a81				endm  
# End of macro CALLMONITOR
9a81			endif	 
9a81 eb				ex de, hl 
9a82 e1				pop hl   ; get ptr to start of string 
9a83			if DEBUG_FORTH_PUSH 
9a83						DMARK "PQ3" 
9a83 f5				push af  
9a84 3a 98 9a			ld a, (.dmark)  
9a87 32 71 ee			ld (debug_mark),a  
9a8a 3a 99 9a			ld a, (.dmark+1)  
9a8d 32 72 ee			ld (debug_mark+1),a  
9a90 3a 9a 9a			ld a, (.dmark+2)  
9a93 32 73 ee			ld (debug_mark+2),a  
9a96 18 03			jr .pastdmark  
9a98 ..			.dmark: db "PQ3"  
9a9b f1			.pastdmark: pop af  
9a9c			endm  
# End of macro DMARK
9a9c				CALLMONITOR 
9a9c cd 7c 93			call break_point_state  
9a9f				endm  
# End of macro CALLMONITOR
9a9f			endif	 
9a9f 19				add hl,de 
9aa0			if DEBUG_FORTH_PUSH 
9aa0						DMARK "PQE" 
9aa0 f5				push af  
9aa1 3a b5 9a			ld a, (.dmark)  
9aa4 32 71 ee			ld (debug_mark),a  
9aa7 3a b6 9a			ld a, (.dmark+1)  
9aaa 32 72 ee			ld (debug_mark+1),a  
9aad 3a b7 9a			ld a, (.dmark+2)  
9ab0 32 73 ee			ld (debug_mark+2),a  
9ab3 18 03			jr .pastdmark  
9ab5 ..			.dmark: db "PQE"  
9ab8 f1			.pastdmark: pop af  
9ab9			endm  
# End of macro DMARK
9ab9				CALLMONITOR 
9ab9 cd 7c 93			call break_point_state  
9abc				endm  
# End of macro CALLMONITOR
9abc			endif	 
9abc			 
9abc 2b				dec hl    ; see if there is an optional trailing double quote 
9abd 7e				ld a,(hl) 
9abe fe 22			cp '"' 
9ac0 20 03			jr nz, .strnoq 
9ac2 3e 00			ld a, 0      ; get rid of double quote 
9ac4 77				ld (hl), a 
9ac5 23			.strnoq: inc hl 
9ac6			 
9ac6 3e 00			ld a, 0 
9ac8 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9ac9			 
9ac9 13				inc de ; add one for the type string 
9aca 13				inc de ; add one for null term??? 
9acb			 
9acb				; tos is get string pointer again 
9acb				; de contains space to allocate 
9acb				 
9acb d5				push de 
9acc			 
9acc eb				ex de, hl 
9acd			 
9acd				;push af 
9acd			 
9acd			if DEBUG_FORTH_PUSH 
9acd						DMARK "PHm" 
9acd f5				push af  
9ace 3a e2 9a			ld a, (.dmark)  
9ad1 32 71 ee			ld (debug_mark),a  
9ad4 3a e3 9a			ld a, (.dmark+1)  
9ad7 32 72 ee			ld (debug_mark+1),a  
9ada 3a e4 9a			ld a, (.dmark+2)  
9add 32 73 ee			ld (debug_mark+2),a  
9ae0 18 03			jr .pastdmark  
9ae2 ..			.dmark: db "PHm"  
9ae5 f1			.pastdmark: pop af  
9ae6			endm  
# End of macro DMARK
9ae6				CALLMONITOR 
9ae6 cd 7c 93			call break_point_state  
9ae9				endm  
# End of macro CALLMONITOR
9ae9			endif	 
9ae9 cd 42 90			call malloc	; on ret hl now contains allocated memory 
9aec				if DEBUG_FORTH_MALLOC_GUARD 
9aec cc 71 c5				call z,malloc_error 
9aef				endif 
9aef			 
9aef				 
9aef c1				pop bc    ; get length 
9af0 d1				pop de   ;  get string start    
9af1			 
9af1				; hl has destination from malloc 
9af1			 
9af1 eb				ex de, hl    ; prep for ldir 
9af2			 
9af2 d5				push de   ; save malloc area for DSP later 
9af3				;push hl   ; save malloc area for DSP later 
9af3			 
9af3			if DEBUG_FORTH_PUSH 
9af3						DMARK "PHc" 
9af3 f5				push af  
9af4 3a 08 9b			ld a, (.dmark)  
9af7 32 71 ee			ld (debug_mark),a  
9afa 3a 09 9b			ld a, (.dmark+1)  
9afd 32 72 ee			ld (debug_mark+1),a  
9b00 3a 0a 9b			ld a, (.dmark+2)  
9b03 32 73 ee			ld (debug_mark+2),a  
9b06 18 03			jr .pastdmark  
9b08 ..			.dmark: db "PHc"  
9b0b f1			.pastdmark: pop af  
9b0c			endm  
# End of macro DMARK
9b0c				CALLMONITOR 
9b0c cd 7c 93			call break_point_state  
9b0f				endm  
# End of macro CALLMONITOR
9b0f			endif	 
9b0f			 
9b0f			 
9b0f ed b0			ldir 
9b11			 
9b11			 
9b11				; push malloc to data stack     macro?????  
9b11			 
9b11				FORTH_DSP_NEXT 
9b11 cd 65 99			call macro_forth_dsp_next 
9b14				endm 
# End of macro FORTH_DSP_NEXT
9b14			 
9b14				; save value and type 
9b14			 
9b14 2a 04 eb			ld hl, (cli_data_sp) 
9b17			 
9b17				; save item type 
9b17 3e 01			ld a,  DS_TYPE_STR 
9b19 77				ld (hl), a 
9b1a 23				inc hl 
9b1b			 
9b1b				; get malloc word off stack 
9b1b d1				pop de 
9b1c 73				ld (hl), e 
9b1d 23				inc hl 
9b1e 72				ld (hl), d 
9b1f			 
9b1f			 
9b1f			 
9b1f			if DEBUG_FORTH_PUSH 
9b1f 2a 04 eb			ld hl, (cli_data_sp) 
9b22						DMARK "PHS" 
9b22 f5				push af  
9b23 3a 37 9b			ld a, (.dmark)  
9b26 32 71 ee			ld (debug_mark),a  
9b29 3a 38 9b			ld a, (.dmark+1)  
9b2c 32 72 ee			ld (debug_mark+1),a  
9b2f 3a 39 9b			ld a, (.dmark+2)  
9b32 32 73 ee			ld (debug_mark+2),a  
9b35 18 03			jr .pastdmark  
9b37 ..			.dmark: db "PHS"  
9b3a f1			.pastdmark: pop af  
9b3b			endm  
# End of macro DMARK
9b3b				CALLMONITOR 
9b3b cd 7c 93			call break_point_state  
9b3e				endm  
# End of macro CALLMONITOR
9b3e			;	ex de,hl 
9b3e			endif	 
9b3e				; in case of spaces, skip the ptr past the copied string 
9b3e				;pop af 
9b3e				;ld (cli_origptr),hl 
9b3e			 
9b3e c9				ret 
9b3f			 
9b3f			 
9b3f			 
9b3f			; TODO ascii push input onto stack given hl to start of input 
9b3f			 
9b3f			; identify type 
9b3f			; if starts with a " then a string 
9b3f			; otherwise it is a number 
9b3f			;  
9b3f			; if a string 
9b3f			;     scan for ending " to get length of string to malloc for + 1 
9b3f			;     malloc 
9b3f			;     put pointer to string on stack first byte flags as string 
9b3f			; 
9b3f			; else a number 
9b3f			;    look for number format identifier 
9b3f			;    $xx hex 
9b3f			;    %xxxxx bin 
9b3f			;    xxxxx decimal 
9b3f			;    convert number to 16bit word.  
9b3f			;    malloc word + 1 with flag to identiy as num 
9b3f			;    put pointer to number on stack 
9b3f			;   
9b3f			;  
9b3f			  
9b3f			forth_apush: 
9b3f				; kernel push 
9b3f			 
9b3f			if DEBUG_FORTH_PUSH 
9b3f						DMARK "PSH" 
9b3f f5				push af  
9b40 3a 54 9b			ld a, (.dmark)  
9b43 32 71 ee			ld (debug_mark),a  
9b46 3a 55 9b			ld a, (.dmark+1)  
9b49 32 72 ee			ld (debug_mark+1),a  
9b4c 3a 56 9b			ld a, (.dmark+2)  
9b4f 32 73 ee			ld (debug_mark+2),a  
9b52 18 03			jr .pastdmark  
9b54 ..			.dmark: db "PSH"  
9b57 f1			.pastdmark: pop af  
9b58			endm  
# End of macro DMARK
9b58				CALLMONITOR 
9b58 cd 7c 93			call break_point_state  
9b5b				endm  
# End of macro CALLMONITOR
9b5b			endif	 
9b5b				; identify input type 
9b5b			 
9b5b 7e				ld a,(hl) 
9b5c fe 22			cp '"' 
9b5e 28 0a			jr z, .fapstr 
9b60 fe 24			cp '$' 
9b62 ca 8a 9b			jp z, .faphex 
9b65 fe 25			cp '%' 
9b67 ca 72 9b			jp z, .fapbin 
9b6a			;	cp 'b' 
9b6a			;	jp z, .fabin 
9b6a				; else decimal 
9b6a			 
9b6a				; TODO do decimal conversion 
9b6a				; decimal is stored as a 16bit word 
9b6a			 
9b6a				; by default everything is a string if type is not detected 
9b6a			.fapstr: ; 
9b6a fe 22			cp '"' 
9b6c 20 01			jr nz, .strnoqu 
9b6e 23				inc hl 
9b6f			.strnoqu: 
9b6f c3 44 9a			jp forth_push_str 
9b72			 
9b72			 
9b72			 
9b72			.fapbin:    ; push a binary string.  
9b72 11 00 00			ld de, 0   ; hold a 16bit value 
9b75			 
9b75 23			.fapbinshift:	inc hl  
9b76 7e				ld a,(hl) 
9b77 fe 00			cp 0     ; done scanning  
9b79 28 0b			jr z, .fapbdone  	; got it in HL so push  
9b7b			 
9b7b				; left shift de 
9b7b eb				ex de, hl	 
9b7c 29				add hl, hl 
9b7d			 
9b7d				; is 1 
9b7d fe 31			cp '1' 
9b7f 20 02			jr nz, .binzero 
9b81 cb 4d			bit 1, l 
9b83			.binzero: 
9b83 eb				ex de, hl	 ; save current de 
9b84 18 ef			jr .fapbinshift 
9b86			 
9b86			.fapbdone: 
9b86 eb				ex de, hl 
9b87 c3 d6 99			jp forth_push_numhl 
9b8a			 
9b8a			 
9b8a			.faphex:   ; hex is always stored as a 16bit word 
9b8a				; skip number prefix 
9b8a 23				inc hl 
9b8b				; turn ascii into number 
9b8b cd 32 8f			call get_word_hl	; ret 16bit word in hl 
9b8e			 
9b8e c3 d6 99			jp forth_push_numhl 
9b91			 
9b91 00				 nop 
9b92			 
9b92			.fabin:   ; TODO bin conversion 
9b92			 
9b92			 
9b92 c9				ret 
9b93			 
9b93			 
9b93			; get either a string ptr or a 16bit word from the data stack 
9b93			 
9b93			FORTH_DSP: macro 
9b93				call macro_forth_dsp 
9b93				endm 
9b93			 
9b93			macro_forth_dsp: 
9b93				; data stack pointer points to current word on tos 
9b93			 
9b93 2a 04 eb			ld hl,(cli_data_sp) 
9b96			 
9b96				if DEBUG_FORTH_PUSH 
9b96						DMARK "DSP" 
9b96 f5				push af  
9b97 3a ab 9b			ld a, (.dmark)  
9b9a 32 71 ee			ld (debug_mark),a  
9b9d 3a ac 9b			ld a, (.dmark+1)  
9ba0 32 72 ee			ld (debug_mark+1),a  
9ba3 3a ad 9b			ld a, (.dmark+2)  
9ba6 32 73 ee			ld (debug_mark+2),a  
9ba9 18 03			jr .pastdmark  
9bab ..			.dmark: db "DSP"  
9bae f1			.pastdmark: pop af  
9baf			endm  
# End of macro DMARK
9baf			 
9baf cd a6 c5				call display_data_sp 
9bb2				;call break_point_state 
9bb2				;rst 030h 
9bb2				CALLMONITOR 
9bb2 cd 7c 93			call break_point_state  
9bb5				endm  
# End of macro CALLMONITOR
9bb5				endif 
9bb5			 
9bb5 c9				ret 
9bb6			 
9bb6			; return hl to start of value on stack 
9bb6			 
9bb6			FORTH_DSP_VALUE: macro 
9bb6				call macro_forth_dsp_value 
9bb6				endm 
9bb6			 
9bb6			macro_forth_dsp_value: 
9bb6			 
9bb6				FORTH_DSP 
9bb6 cd 93 9b			call macro_forth_dsp 
9bb9				endm 
# End of macro FORTH_DSP
9bb9			 
9bb9 d5				push de 
9bba			 
9bba 23				inc hl ; skip type 
9bbb			 
9bbb 5e				ld e, (hl) 
9bbc 23				inc hl 
9bbd 56				ld d, (hl) 
9bbe eb				ex de,hl  
9bbf			 
9bbf d1				pop de 
9bc0			 
9bc0 c9				ret 
9bc1			 
9bc1			; return hl to start of value to second item on stack 
9bc1			 
9bc1			FORTH_DSP_VALUEM1: macro 
9bc1				call macro_forth_dsp_value_m1 
9bc1				endm 
9bc1			 
9bc1			macro_forth_dsp_value_m1: 
9bc1			 
9bc1				FORTH_DSP 
9bc1 cd 93 9b			call macro_forth_dsp 
9bc4				endm 
# End of macro FORTH_DSP
9bc4			 
9bc4 2b				dec hl 
9bc5 2b				dec hl 
9bc6			;	dec hl 
9bc6			 
9bc6 d5				push de 
9bc7			 
9bc7 5e				ld e, (hl) 
9bc8 23				inc hl 
9bc9 56				ld d, (hl) 
9bca eb				ex de,hl  
9bcb			 
9bcb d1				pop de 
9bcc			 
9bcc c9				ret 
9bcd			 
9bcd				 
9bcd			 
9bcd			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bcd			 
9bcd			FORTH_DSP_POP: macro 
9bcd				call macro_forth_dsp_pop 
9bcd				endm 
9bcd			 
9bcd			 
9bcd			; get the tos data type 
9bcd			 
9bcd			FORTH_DSP_TYPE:   macro 
9bcd			 
9bcd				;FORTH_DSP_VALUE 
9bcd				FORTH_DSP 
9bcd				 
9bcd				; hl points to value 
9bcd				; check type 
9bcd			 
9bcd				ld a,(hl) 
9bcd			 
9bcd				endm 
9bcd			 
9bcd			; load the tos value into hl 
9bcd			 
9bcd			 
9bcd			FORTH_DSP_VALUEHL:  macro 
9bcd				call macro_dsp_valuehl 
9bcd				endm 
9bcd			 
9bcd			 
9bcd			 
9bcd			macro_dsp_valuehl: 
9bcd				FORTH_DSP_VALUE 
9bcd cd b6 9b			call macro_forth_dsp_value 
9bd0				endm 
# End of macro FORTH_DSP_VALUE
9bd0			 
9bd0				;FORTH_ERR_TOS_NOTNUM 
9bd0			 
9bd0				;inc hl   ; skip type id 
9bd0			 
9bd0			;	push de 
9bd0			; 
9bd0			;	ld e, (hl) 
9bd0			;	inc hl 
9bd0			;	ld d, (hl) 
9bd0			;	ex de,hl  
9bd0			 
9bd0			;	pop de 
9bd0			 
9bd0				if DEBUG_FORTH_PUSH 
9bd0						DMARK "DVL" 
9bd0 f5				push af  
9bd1 3a e5 9b			ld a, (.dmark)  
9bd4 32 71 ee			ld (debug_mark),a  
9bd7 3a e6 9b			ld a, (.dmark+1)  
9bda 32 72 ee			ld (debug_mark+1),a  
9bdd 3a e7 9b			ld a, (.dmark+2)  
9be0 32 73 ee			ld (debug_mark+2),a  
9be3 18 03			jr .pastdmark  
9be5 ..			.dmark: db "DVL"  
9be8 f1			.pastdmark: pop af  
9be9			endm  
# End of macro DMARK
9be9				CALLMONITOR 
9be9 cd 7c 93			call break_point_state  
9bec				endm  
# End of macro CALLMONITOR
9bec				endif 
9bec c9				ret 
9bed			 
9bed			forth_apushstrhl:      
9bed				; push of string requires use of cli_origptr 
9bed				; bodge use 
9bed			 
9bed				; get current cli_origptr, save, update with temp pointer  
9bed ed 5b 20 eb		ld de, (cli_origptr) 
9bf1 22 20 eb			ld (cli_origptr), hl 
9bf4 d5				push de 
9bf5 cd 3f 9b			call forth_apush 
9bf8 d1				pop de 
9bf9 ed 53 20 eb		ld (cli_origptr), de 
9bfd c9			        ret	 
9bfe			 
9bfe			 
9bfe			; increase loop stack pointer and save hl to it 
9bfe				 
9bfe			FORTH_LOOP_NEXT: macro 
9bfe				call macro_forth_loop_next 
9bfe				;nop 
9bfe				endm 
9bfe			 
9bfe			macro_forth_loop_next: 
9bfe				if DEBUG_FORTH_STACK_GUARD 
9bfe cd 3a d6				call check_stacks 
9c01				endif 
9c01 e5				push hl 
9c02 d5				push de 
9c03 eb				ex de,hl 
9c04 2a 06 eb			ld hl,(cli_loop_sp) 
9c07 23				inc hl 
9c08 23				inc hl 
9c09					if DEBUG_FORTH_WORDS 
9c09						DMARK "LNX" 
9c09 f5				push af  
9c0a 3a 1e 9c			ld a, (.dmark)  
9c0d 32 71 ee			ld (debug_mark),a  
9c10 3a 1f 9c			ld a, (.dmark+1)  
9c13 32 72 ee			ld (debug_mark+1),a  
9c16 3a 20 9c			ld a, (.dmark+2)  
9c19 32 73 ee			ld (debug_mark+2),a  
9c1c 18 03			jr .pastdmark  
9c1e ..			.dmark: db "LNX"  
9c21 f1			.pastdmark: pop af  
9c22			endm  
# End of macro DMARK
9c22						CALLMONITOR 
9c22 cd 7c 93			call break_point_state  
9c25				endm  
# End of macro CALLMONITOR
9c25					endif 
9c25 22 06 eb			ld (cli_loop_sp),hl 
9c28 73				ld (hl), e 
9c29 23				inc hl 
9c2a 72				ld (hl), d 
9c2b d1				pop de    ; been reversed so save a swap on restore 
9c2c e1				pop hl 
9c2d				if DEBUG_FORTH_STACK_GUARD 
9c2d cd 3a d6				call check_stacks 
9c30				endif 
9c30 c9				ret 
9c31			 
9c31			; get current ret stack pointer and save to hl  
9c31				 
9c31			FORTH_LOOP_TOS: macro 
9c31				call macro_forth_loop_tos 
9c31				endm 
9c31			 
9c31			macro_forth_loop_tos: 
9c31 d5				push de 
9c32 2a 06 eb			ld hl,(cli_loop_sp) 
9c35 5e				ld e, (hl) 
9c36 23				inc hl 
9c37 56				ld d, (hl) 
9c38 eb				ex de, hl 
9c39 d1				pop de 
9c3a c9				ret 
9c3b			 
9c3b			; pop loop stack pointer 
9c3b				 
9c3b			FORTH_LOOP_POP: macro 
9c3b				call macro_forth_loop_pop 
9c3b				endm 
9c3b			 
9c3b			 
9c3b			macro_forth_loop_pop: 
9c3b				if DEBUG_FORTH_STACK_GUARD 
9c3b					DMARK "LPP" 
9c3b f5				push af  
9c3c 3a 50 9c			ld a, (.dmark)  
9c3f 32 71 ee			ld (debug_mark),a  
9c42 3a 51 9c			ld a, (.dmark+1)  
9c45 32 72 ee			ld (debug_mark+1),a  
9c48 3a 52 9c			ld a, (.dmark+2)  
9c4b 32 73 ee			ld (debug_mark+2),a  
9c4e 18 03			jr .pastdmark  
9c50 ..			.dmark: db "LPP"  
9c53 f1			.pastdmark: pop af  
9c54			endm  
# End of macro DMARK
9c54 cd 3a d6				call check_stacks 
9c57					FORTH_CHK_LOOP_UNDER 
9c57 e5				push hl 
9c58 d5				push de 
9c59 2a 06 eb			ld hl,(cli_loop_sp) 
9c5c 11 c0 e9			ld de, cli_loop_stack 
9c5f cd 99 8b			call cmp16 
9c62 da 54 d7			jp c, fault_loop_under 
9c65 d1				pop de 
9c66 e1				pop hl 
9c67				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c67				endif 
9c67 e5				push hl 
9c68 2a 06 eb			ld hl,(cli_loop_sp) 
9c6b 2b				dec hl 
9c6c 2b				dec hl 
9c6d 22 06 eb			ld (cli_loop_sp), hl 
9c70				; TODO do stack underflow checks 
9c70 e1				pop hl 
9c71				if DEBUG_FORTH_STACK_GUARD 
9c71 cd 3a d6				call check_stacks 
9c74					FORTH_CHK_LOOP_UNDER 
9c74 e5				push hl 
9c75 d5				push de 
9c76 2a 06 eb			ld hl,(cli_loop_sp) 
9c79 11 c0 e9			ld de, cli_loop_stack 
9c7c cd 99 8b			call cmp16 
9c7f da 54 d7			jp c, fault_loop_under 
9c82 d1				pop de 
9c83 e1				pop hl 
9c84				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c84				endif 
9c84 c9				ret 
9c85			 
9c85			macro_forth_dsp_pop: 
9c85			 
9c85 e5				push hl 
9c86			 
9c86				; release malloc data 
9c86			 
9c86				if DEBUG_FORTH_STACK_GUARD 
9c86 cd 3a d6				call check_stacks 
9c89					FORTH_CHK_DSP_UNDER 
9c89 e5				push hl 
9c8a d5				push de 
9c8b 2a 04 eb			ld hl,(cli_data_sp) 
9c8e 11 be e8			ld de, cli_data_stack 
9c91 cd 99 8b			call cmp16 
9c94 da 48 d7			jp c, fault_dsp_under 
9c97 d1				pop de 
9c98 e1				pop hl 
9c99				endm 
# End of macro FORTH_CHK_DSP_UNDER
9c99				endif 
9c99				;ld hl,(cli_data_sp) 
9c99			if DEBUG_FORTH_DOT 
9c99				DMARK "DPP" 
9c99				CALLMONITOR 
9c99			endif	 
9c99			 
9c99			 
9c99			if FORTH_ENABLE_DSPPOPFREE 
9c99			 
9c99				FORTH_DSP 
9c99 cd 93 9b			call macro_forth_dsp 
9c9c				endm 
# End of macro FORTH_DSP
9c9c			 
9c9c 7e				ld a, (hl) 
9c9d fe 01			cp DS_TYPE_STR 
9c9f 20 07			jr nz, .skippopfree 
9ca1			 
9ca1				FORTH_DSP_VALUEHL 
9ca1 cd cd 9b			call macro_dsp_valuehl 
9ca4				endm 
# End of macro FORTH_DSP_VALUEHL
9ca4 00				nop 
9ca5			if DEBUG_FORTH_DOT 
9ca5				DMARK "DPf" 
9ca5				CALLMONITOR 
9ca5			endif	 
9ca5 cd 0c 91			call free 
9ca8			.skippopfree: 
9ca8				 
9ca8			 
9ca8			endif 
9ca8			 
9ca8			if DEBUG_FORTH_DOT_KEY 
9ca8				DMARK "DP2" 
9ca8				CALLMONITOR 
9ca8			endif	 
9ca8			 
9ca8				; move pointer down 
9ca8			 
9ca8 2a 04 eb			ld hl,(cli_data_sp) 
9cab 2b				dec hl 
9cac 2b				dec hl 
9cad			; PARSEV5 
9cad 2b				dec hl 
9cae 22 04 eb			ld (cli_data_sp), hl 
9cb1			 
9cb1				if DEBUG_FORTH_STACK_GUARD 
9cb1 cd 3a d6				call check_stacks 
9cb4					FORTH_CHK_DSP_UNDER 
9cb4 e5				push hl 
9cb5 d5				push de 
9cb6 2a 04 eb			ld hl,(cli_data_sp) 
9cb9 11 be e8			ld de, cli_data_stack 
9cbc cd 99 8b			call cmp16 
9cbf da 48 d7			jp c, fault_dsp_under 
9cc2 d1				pop de 
9cc3 e1				pop hl 
9cc4				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cc4				endif 
9cc4			 
9cc4 e1				pop hl 
9cc5			 
9cc5 c9				ret 
9cc6			 
9cc6			getwordathl: 
9cc6				; hl points to an address 
9cc6				; load hl with the word at that address 
9cc6			 
9cc6 d5				push de 
9cc7			 
9cc7 5e				ld e, (hl) 
9cc8 23				inc hl 
9cc9 56				ld d, (hl) 
9cca eb				ex de, hl 
9ccb			 
9ccb d1				pop de 
9ccc c9				ret 
9ccd			 
9ccd			 
9ccd			 
9ccd			 
9ccd			 
9ccd			; eof 
9ccd			 
# End of file forth_stackopsv5.asm
9ccd			endif 
9ccd			 
9ccd			user_word_eol:  
9ccd				; hl contains the pointer to where to create a linked list item from the end 
9ccd				; of the user dict to continue on at the system word dict 
9ccd				 
9ccd				; poke the stub of the word list linked list to repoint to rom words 
9ccd			 
9ccd				; stub format 
9ccd				; db   word id 
9ccd				; dw    link to next word 
9ccd			        ; db char length of token 
9ccd				; db string + 0 term 
9ccd				; db exec code....  
9ccd			 
9ccd 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9ccf 77				ld (hl), a		; word id 
9cd0 23				inc hl 
9cd1			 
9cd1 11 97 9e			ld de, sysdict 
9cd4 73				ld (hl), e		; next word link ie system dict 
9cd5 23				inc hl 
9cd6 72				ld (hl), d		; next word link ie system dict 
9cd7 23				inc hl	 
9cd8			 
9cd8			;	ld (hl), sysdict		; next word link ie system dict 
9cd8			;	inc hl 
9cd8			;	inc hl 
9cd8			 
9cd8			;	inc hl 
9cd8			;	inc hl 
9cd8			 
9cd8 3e 02			ld a, 2			; word length is 0 
9cda 77				ld (hl), a	 
9cdb 23				inc hl 
9cdc			 
9cdc 3e 7e			ld a, '~'			; word length is 0 
9cde 77				ld (hl), a	 
9cdf 23				inc hl 
9ce0 3e 00			ld a, 0			; save empty word 
9ce2 77				ld (hl), a 
9ce3			 
9ce3 c9				ret 
9ce4			 
9ce4				 
9ce4			 
9ce4			forthexec_cleanup: 
9ce4				FORTH_RSP_POP 
9ce4 cd 9e 99			call macro_forth_rsp_pop 
9ce7				endm 
# End of macro FORTH_RSP_POP
9ce7 c9				ret 
9ce8			 
9ce8			forth_call_hl: 
9ce8				; taking hl 
9ce8 e5				push hl 
9ce9 c9				ret 
9cea			 
9cea			; this is called to reset Forth system but keep existing uwords etc 
9cea			 
9cea			forth_warmstart: 
9cea				; setup stack over/under flow checks 
9cea				if DEBUG_FORTH_STACK_GUARD 
9cea cd 20 d6				call chk_stk_init 
9ced				endif 
9ced			 
9ced				; init stack pointers  - * these stacks go upwards *  
9ced 21 c2 ea			ld hl, cli_ret_stack 
9cf0 22 08 eb			ld (cli_ret_sp), hl	 
9cf3				; set bottom of stack 
9cf3 3e 00			ld a,0 
9cf5 77				ld (hl),a 
9cf6 23				inc hl 
9cf7 77				ld (hl),a 
9cf8			 
9cf8 21 be e8			ld hl, cli_data_stack 
9cfb 22 04 eb			ld (cli_data_sp), hl	 
9cfe				; set bottom of stack 
9cfe 3e 00			ld a,0 
9d00 77				ld (hl),a 
9d01 23				inc hl 
9d02 77				ld (hl),a 
9d03			 
9d03 21 c0 e9			ld hl, cli_loop_stack 
9d06 22 06 eb			ld (cli_loop_sp), hl	 
9d09				; set bottom of stack 
9d09 3e 00			ld a,0 
9d0b 77				ld (hl),a 
9d0c 23				inc hl 
9d0d 77				ld (hl),a 
9d0e			 
9d0e				; init extent of current open file 
9d0e			 
9d0e 3e 00			ld a, 0 
9d10 32 53 eb			ld (store_openext), a 
9d13			 
9d13 c9				ret 
9d14			 
9d14			 
9d14			; Cold Start - this is called to setup the whole Forth system 
9d14			 
9d14			forth_init: 
9d14			 
9d14				; setup stack over/under flow checks 
9d14			 
9d14			;	if DEBUG_FORTH_STACK_GUARD 
9d14			;		call chk_stk_init 
9d14			;	endif 
9d14			 
9d14				; enable auto display updates (slow.....) 
9d14			 
9d14 3e 01			ld a, 1 
9d16 32 1e eb			ld (cli_autodisplay), a 
9d19			 
9d19			 
9d19			 
9d19				; show start up screen 
9d19			 
9d19 cd 4e 89			call clear_display 
9d1c			 
9d1c 3e 00			ld a,0 
9d1e 32 40 eb			ld (f_cursor_ptr), a 
9d21			 
9d21				; set start of word list in start of ram - for use when creating user words 
9d21			 
9d21 21 eb d8			ld hl, baseram 
9d24 22 54 e6			ld (os_last_new_uword), hl 
9d27 cd cd 9c			call user_word_eol 
9d2a				 
9d2a			;		call display_data_sp 
9d2a			;		call next_page_prompt 
9d2a			 
9d2a			 
9d2a			 
9d2a			 
9d2a c9				ret 
9d2b			 
9d2b .. 00		.bootforth: db " Forth Kernel Init ",0 
9d3f			 
9d3f			; TODO push to stack 
9d3f			 
9d3f			;  
9d3f			 
9d3f			if FORTH_PARSEV2 
9d3f			 
9d3f			 
9d3f				include "forth_parserv2.asm" 
9d3f			 
9d3f			endif 
9d3f			 
9d3f			 
9d3f			; parse cli version 1 
9d3f			 
9d3f			if FORTH_PARSEV1 
9d3f			 
9d3f			 
9d3f			 
9d3f			      include "forth_parserv1.asm" 
9d3f			endif 
9d3f				 
9d3f			if FORTH_PARSEV3 
9d3f			 
9d3f			 
9d3f			 
9d3f			      include "forth_parserv3.asm" 
9d3f				include "forth_wordsv3.asm" 
9d3f			endif 
9d3f			 
9d3f			if FORTH_PARSEV4 
9d3f			 
9d3f			 
9d3f			 
9d3f			      include "forth_parserv4.asm" 
9d3f				include "forth_wordsv4.asm" 
9d3f			endif 
9d3f			 
9d3f			if FORTH_PARSEV5 
9d3f			 
9d3f			 
9d3f			 
9d3f			      include "forth_parserv5.asm" 
9d3f			 
9d3f			 
9d3f			; A better parser without using malloc and string copies all over the place.  
9d3f			; Exec in situ should be faster 
9d3f			 
9d3f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9d3f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9d3f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9d3f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9d3f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9d3f			WORD_SYS_END: equ 0   ; Opcode for all user words 
9d3f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9d3f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9d3f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9d3f			 
9d3f			; Core word preamble macro 
9d3f			 
9d3f			CWHEAD:   macro nxtword opcode lit len opflags 
9d3f				db WORD_SYS_CORE+opcode             
9d3f				; internal op code number 
9d3f				dw nxtword            
9d3f				; link to next dict word block 
9d3f				db len + 1 
9d3f				; literal length of dict word inc zero term 
9d3f				db lit,0              
9d3f				; literal dict word 
9d3f			        ; TODO db opflags        
9d3f				endm 
9d3f			 
9d3f			 
9d3f			NEXTW: macro  
9d3f				jp macro_next 
9d3f				endm 
9d3f			 
9d3f			macro_next: 
9d3f			if DEBUG_FORTH_PARSE_KEY 
9d3f				DMARK "NXT" 
9d3f				CALLMONITOR 
9d3f			endif	 
9d3f			;	inc hl  ; skip token null term  
9d3f ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9d43 ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9d47 2a 58 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9d4a			if DEBUG_FORTH_PARSE_KEY 
9d4a				DMARK "}AA" 
9d4a				CALLMONITOR 
9d4a			endif	 
9d4a c3 4d 9e			jp execnext 
9d4d				;jp exec1 
9d4d			       
9d4d			 
9d4d			 
9d4d			; Another go at the parser to compile  
9d4d			 
9d4d			 
9d4d			; TODO rework parser to change all of the string words to byte tokens 
9d4d			; TODO do a search for  
9d4d			 
9d4d			; TODO first run normal parser to zero term sections 
9d4d			; TODO for each word do a token look up to get the op code 
9d4d			; TODO need some means to flag to the exec that this is a byte code form    
9d4d			 
9d4d			 
9d4d			forthcompile: 
9d4d			 
9d4d			; 
9d4d			; line parse: 
9d4d			;       parse raw input buffer 
9d4d			;       tokenise the words 
9d4d			;       malloc new copy (for looping etc) 
9d4d			;       copy to malloc + current pc in line to start of string and add line term 
9d4d			;       save on new rsp 
9d4d			; 
9d4d			 
9d4d			; hl to point to the line to tokenise 
9d4d			 
9d4d			;	push hl 
9d4d 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9d50			 
9d50			;	ld a,0		; string term on input 
9d50			;	call strlent 
9d50			 
9d50			;	ld (os_tok_len), hl	 ; save string length 
9d50			 
9d50			;if DEBUG_FORTH_TOK 
9d50			;	ex de,hl		 
9d50			;endif 
9d50			 
9d50			;	pop hl 		; get back string pointer 
9d50			 
9d50			if DEBUG_FORTH_TOK 
9d50						DMARK "TOc" 
9d50				CALLMONITOR 
9d50			endif 
9d50 7e			.cptoken2:    ld a,(hl) 
9d51 23				inc hl 
9d52 fe 7f			cp FORTH_END_BUFFER 
9d54 28 29			jr z, .cptokendone2 
9d56 fe 00			cp 0 
9d58 28 25			jr z, .cptokendone2 
9d5a fe 22			cp '"' 
9d5c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9d5e fe 20			cp ' ' 
9d60 20 ee			jr nz,  .cptoken2 
9d62			 
9d62			; TODO consume comments held between ( and ) 
9d62			 
9d62				; we have a space so change to zero term for dict match later 
9d62 2b				dec hl 
9d63 3e 00			ld a,0 
9d65 77				ld (hl), a 
9d66 23				inc hl 
9d67 18 e7			jr .cptoken2 
9d69				 
9d69			 
9d69			.cptokenstr2: 
9d69				; skip all white space until either eol (because forgot to term) or end double quote 
9d69			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9d69				;inc hl ; skip current double quote 
9d69 7e				ld a,(hl) 
9d6a 23				inc hl 
9d6b fe 22			cp '"' 
9d6d 28 e1			jr z, .cptoken2 
9d6f fe 7f			cp FORTH_END_BUFFER 
9d71 28 0c			jr z, .cptokendone2 
9d73 fe 00			cp 0 
9d75 28 08			jr z, .cptokendone2 
9d77 fe 20			cp ' ' 
9d79 28 02			jr z, .cptmp2 
9d7b 18 ec			jr .cptokenstr2 
9d7d			 
9d7d			.cptmp2:	; we have a space so change to zero term for dict match later 
9d7d				;dec hl 
9d7d				;ld a,"-"	; TODO remove this when working 
9d7d				;ld (hl), a 
9d7d				;inc hl 
9d7d 18 ea			jr .cptokenstr2 
9d7f			 
9d7f			.cptokendone2: 
9d7f				;inc hl 
9d7f 3e 7f			ld a, FORTH_END_BUFFER 
9d81 77				ld (hl),a 
9d82 23				inc hl 
9d83 3e 21			ld a, '!' 
9d85 77				ld (hl),a 
9d86			 
9d86 2a 58 e6			ld hl,(os_tok_ptr) 
9d89			         
9d89			if DEBUG_FORTH_TOK 
9d89						DMARK "Tc1" 
9d89				CALLMONITOR 
9d89			endif 
9d89			 
9d89				; push exec string to top of return stack 
9d89				FORTH_RSP_NEXT 
9d89 cd 7d 99			call macro_forth_rsp_next 
9d8c				endm 
# End of macro FORTH_RSP_NEXT
9d8c c9				ret 
9d8d			 
9d8d			; Another go at the parser need to simplify the process 
9d8d			 
9d8d			forthparse: 
9d8d			 
9d8d			; 
9d8d			; line parse: 
9d8d			;       parse raw input buffer 
9d8d			;       tokenise the words 
9d8d			;       malloc new copy (for looping etc) 
9d8d			;       copy to malloc + current pc in line to start of string and add line term 
9d8d			;       save on new rsp 
9d8d			; 
9d8d			 
9d8d			; hl to point to the line to tokenise 
9d8d			 
9d8d			;	push hl 
9d8d 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9d90			 
9d90			;	ld a,0		; string term on input 
9d90			;	call strlent 
9d90			 
9d90			;	ld (os_tok_len), hl	 ; save string length 
9d90			 
9d90			;if DEBUG_FORTH_TOK 
9d90			;	ex de,hl		 
9d90			;endif 
9d90			 
9d90			;	pop hl 		; get back string pointer 
9d90			 
9d90			if DEBUG_FORTH_TOK 
9d90						DMARK "TOK" 
9d90				CALLMONITOR 
9d90			endif 
9d90 7e			.ptoken2:    ld a,(hl) 
9d91 23				inc hl 
9d92 fe 7f			cp FORTH_END_BUFFER 
9d94 28 29			jr z, .ptokendone2 
9d96 fe 00			cp 0 
9d98 28 25			jr z, .ptokendone2 
9d9a fe 22			cp '"' 
9d9c 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9d9e fe 20			cp ' ' 
9da0 20 ee			jr nz,  .ptoken2 
9da2			 
9da2			; TODO consume comments held between ( and ) 
9da2			 
9da2				; we have a space so change to zero term for dict match later 
9da2 2b				dec hl 
9da3 3e 00			ld a,0 
9da5 77				ld (hl), a 
9da6 23				inc hl 
9da7 18 e7			jr .ptoken2 
9da9				 
9da9			 
9da9			.ptokenstr2: 
9da9				; skip all white space until either eol (because forgot to term) or end double quote 
9da9			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9da9				;inc hl ; skip current double quote 
9da9 7e				ld a,(hl) 
9daa 23				inc hl 
9dab fe 22			cp '"' 
9dad 28 e1			jr z, .ptoken2 
9daf fe 7f			cp FORTH_END_BUFFER 
9db1 28 0c			jr z, .ptokendone2 
9db3 fe 00			cp 0 
9db5 28 08			jr z, .ptokendone2 
9db7 fe 20			cp ' ' 
9db9 28 02			jr z, .ptmp2 
9dbb 18 ec			jr .ptokenstr2 
9dbd			 
9dbd			.ptmp2:	; we have a space so change to zero term for dict match later 
9dbd				;dec hl 
9dbd				;ld a,"-"	; TODO remove this when working 
9dbd				;ld (hl), a 
9dbd				;inc hl 
9dbd 18 ea			jr .ptokenstr2 
9dbf			 
9dbf			.ptokendone2: 
9dbf				;inc hl 
9dbf 3e 7f			ld a, FORTH_END_BUFFER 
9dc1 77				ld (hl),a 
9dc2 23				inc hl 
9dc3 3e 21			ld a, '!' 
9dc5 77				ld (hl),a 
9dc6			 
9dc6 2a 58 e6			ld hl,(os_tok_ptr) 
9dc9			         
9dc9			if DEBUG_FORTH_TOK 
9dc9						DMARK "TK1" 
9dc9				CALLMONITOR 
9dc9			endif 
9dc9			 
9dc9				; push exec string to top of return stack 
9dc9				FORTH_RSP_NEXT 
9dc9 cd 7d 99			call macro_forth_rsp_next 
9dcc				endm 
# End of macro FORTH_RSP_NEXT
9dcc c9				ret 
9dcd			 
9dcd			; 
9dcd			;	; malloc size + buffer pointer + if is loop flag 
9dcd			;	ld hl,(os_tok_len) 		 ; get string length 
9dcd			; 
9dcd			;	ld a,l 
9dcd			; 
9dcd			;	cp 0			; we dont want to use a null string 
9dcd			;	ret z 
9dcd			; 
9dcd			;;	add 3    ; prefix malloc with buffer for current word ptr 
9dcd			; 
9dcd			;	add 5     ; TODO when certain not over writing memory remove 
9dcd			; 
9dcd			;		 
9dcd			; 
9dcd			;if DEBUG_FORTH_TOK 
9dcd			;			DMARK "TKE" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			; 
9dcd			;	ld l,a 
9dcd			;	ld h,0 
9dcd			;;	push hl   ; save required space for the copy later 
9dcd			;	call malloc 
9dcd			;if DEBUG_FORTH_TOK 
9dcd			;			DMARK "TKM" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			;	if DEBUG_FORTH_MALLOC_GUARD 
9dcd			;		push af 
9dcd			;		call ishlzero 
9dcd			;;		ld a, l 
9dcd			;;		add h 
9dcd			;;		cp 0 
9dcd			;		pop af 
9dcd			;		 
9dcd			;		call z,malloc_error 
9dcd			;	endif 
9dcd			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9dcd			; 
9dcd			; 
9dcd			;if DEBUG_FORTH_TOK 
9dcd			;			DMARK "TKR" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			; 
9dcd			;	FORTH_RSP_NEXT 
9dcd			; 
9dcd			;	;inc hl	 ; go past current buffer pointer 
9dcd			;	;inc hl 
9dcd			;	;inc hl   ; and past if loop flag 
9dcd			;		; TODO Need to set flag  
9dcd			; 
9dcd			;	 
9dcd			;	 
9dcd			;	ex de,hl	; malloc is dest 
9dcd			;	ld hl, (os_tok_len) 
9dcd			;;	pop bc 
9dcd			;	ld c, l                
9dcd			;	ld b,0 
9dcd			;	ld hl, (os_tok_ptr) 
9dcd			; 
9dcd			;if DEBUG_FORTH_TOK 
9dcd			;			DMARK "TKT" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			; 
9dcd			;	; do str cpy 
9dcd			; 
9dcd			;	ldir      ; copy byte in hl to de 
9dcd			; 
9dcd			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9dcd			; 
9dcd			;if DEBUG_FORTH_TOK 
9dcd			; 
9dcd			;			DMARK "TKY" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			;	;ld a,0 
9dcd			;	;ld a,FORTH_END_BUFFER 
9dcd			;	ex de, hl 
9dcd			;	;dec hl			 ; go back over the space delim at the end of word 
9dcd			;	;ld (hl),a 
9dcd			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9dcd			;	ld a,FORTH_END_BUFFER 
9dcd			;	ld (hl),a 
9dcd			;	inc hl 
9dcd			;	ld a,FORTH_END_BUFFER 
9dcd			;	ld (hl),a 
9dcd			; 
9dcd			;	; init the malloc area data 
9dcd			;	; set pc for in current area 
9dcd			;	;ld hl, (os_tok_malloc) 
9dcd			;	;inc hl 
9dcd			;	;inc hl 
9dcd			;	;inc hl 
9dcd			;	;ex de,hl 
9dcd			;	;ld hl, (os_tok_malloc) 
9dcd			;	;ld (hl),e 
9dcd			;	;inc hl 
9dcd			;	;ld (hl),d 
9dcd			; 
9dcd			; 
9dcd			;	ld hl,(os_tok_malloc) 
9dcd			;if DEBUG_FORTH_PARSE_KEY 
9dcd			;			DMARK "TKU" 
9dcd			;	CALLMONITOR 
9dcd			;endif 
9dcd			; 
9dcd			;	ret 
9dcd			 
9dcd			forthexec: 
9dcd			 
9dcd			; line exec: 
9dcd			; forth parser 
9dcd			 
9dcd			; 
9dcd			;       get current exec line on rsp 
9dcd			 
9dcd				FORTH_RSP_TOS 
9dcd cd 94 99			call macro_forth_rsp_tos 
9dd0				endm 
# End of macro FORTH_RSP_TOS
9dd0			 
9dd0			;       restore current pc - hl points to malloc of data 
9dd0			 
9dd0				;ld e, (hl) 
9dd0				;inc hl 
9dd0				;ld d, (hl) 
9dd0				;ex de,hl 
9dd0			 
9dd0			 
9dd0			exec1: 
9dd0 22 58 e6			ld (os_tok_ptr), hl 
9dd3			 
9dd3				; copy our PC to working vars  
9dd3 22 22 eb			ld (cli_ptr), hl 
9dd6 22 20 eb			ld (cli_origptr), hl 
9dd9			 
9dd9 7e				ld a,(hl) 
9dda fe 7f			cp FORTH_END_BUFFER 
9ddc c8				ret z 
9ddd			 
9ddd				; skip any nulls 
9ddd			 
9ddd fe 00			cp 0 
9ddf 20 03			jr nz, .execword 
9de1 23				inc hl 
9de2 18 ec			jr exec1 
9de4			 
9de4			 
9de4			.execword: 
9de4			 
9de4			 
9de4			 
9de4			if DEBUG_FORTH_PARSE_KEY 
9de4						DMARK "KYQ" 
9de4				CALLMONITOR 
9de4			endif 
9de4			;       while at start of word: 
9de4			; get start of dict (in user area first) 
9de4			 
9de4 21 eb d8		ld hl, baseram 
9de7			;ld hl, sysdict 
9de7 22 24 eb		ld (cli_nextword),hl 
9dea			;           match word at pc 
9dea			;           exec word 
9dea			;           or push to dsp 
9dea			;           forward to next token 
9dea			;           if line term pop rsp and exit 
9dea			;        
9dea			 
9dea			if DEBUG_FORTH_PARSE_KEY 
9dea						DMARK "KYq" 
9dea				CALLMONITOR 
9dea			endif 
9dea			 
9dea			; 
9dea			; word comp 
9dea			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9dea			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9dea			;    move to start of word  
9dea			;    compare word to cli_token 
9dea			 
9dea			.execpnword:	; HL at start of a word in the dictionary to check 
9dea			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9dea			;	ld (cli_ptr), hl 
9dea			 
9dea 2a 24 eb			ld hl,(cli_nextword) 
9ded			 
9ded cd 90 9e			call forth_tok_next 
9df0			; tok next start here 
9df0			;	; TODO skip compiled symbol for now 
9df0			;	inc hl 
9df0			; 
9df0			;	; save pointer to next word 
9df0			; 
9df0			;	; hl now points to the address of the next word pointer  
9df0			;	ld e, (hl) 
9df0			;	inc hl 
9df0			;	ld d, (hl) 
9df0			;	inc l 
9df0			; 
9df0			;	ex de,hl 
9df0			;if DEBUG_FORTH_PARSE_NEXTWORD 
9df0			;	push bc 
9df0			;	ld bc, (cli_nextword) 
9df0			;			DMARK "NXW" 
9df0			;	CALLMONITOR 
9df0			;	pop bc 
9df0			;endif 
9df0			; tok next end here 
9df0 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9df3 eb				ex de, hl 
9df4			 
9df4			 
9df4				; save the pointer of the current token - 1 to check against 
9df4				 
9df4 22 28 eb			ld (cli_token), hl   
9df7				; TODO maybe remove below save if no debug 
9df7				; save token string ptr for any debug later 
9df7 23				inc hl  
9df8 22 2a eb			ld (cli_origtoken), hl 
9dfb 2b				dec hl 
9dfc				; save pointer to the start of the next dictionay word 
9dfc 7e				ld a,(hl)   ; get string length 
9dfd 47				ld b,a 
9dfe			.execpnwordinc:  
9dfe 23				inc hl 
9dff 10 fd			djnz .execpnwordinc 
9e01 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
9e04			 
9e04				; now check the word token against the string being parsed 
9e04			 
9e04 2a 28 eb			ld hl,(cli_token) 
9e07 23				inc hl     ; skip string length (use zero term instead to end) 
9e08 22 28 eb			ld (cli_token), hl 
9e0b			 
9e0b			if DEBUG_FORTH_PARSE_KEY 
9e0b						DMARK "KY2" 
9e0b			endif 
9e0b			if DEBUG_FORTH_PARSE_EXEC 
9e0b				; see if disabled 
9e0b			 
9e0b				ld a, (os_view_disable) 
9e0b				cp '*' 
9e0b				jr z, .skip 
9e0b			 
9e0b				push hl 
9e0b				push hl 
9e0b				call clear_display 
9e0b				ld de, .compword 
9e0b				ld a, display_row_1 
9e0b				call str_at_display 
9e0b				pop de 
9e0b				ld a, display_row_2 
9e0b				call str_at_display 
9e0b				ld hl,(cli_ptr) 
9e0b				ld a,(hl) 
9e0b			        ld hl, os_word_scratch 
9e0b				ld (hl),a 
9e0b				ld a,0 
9e0b				inc hl 
9e0b				ld (hl),a 	 
9e0b				ld de, os_word_scratch 
9e0b				ld a, display_row_2+10 
9e0b				call str_at_display 
9e0b				call update_display 
9e0b				ld a, 100 
9e0b				call aDelayInMS 
9e0b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e0b				call delay250ms 
9e0b				endif 
9e0b				pop hl 
9e0b			.skip:  
9e0b			endif	 
9e0b			.execpnchar:    ; compare char between token and string to parse 
9e0b			 
9e0b			if DEBUG_FORTH_PARSE_KEY 
9e0b						DMARK "Ky3" 
9e0b			endif 
9e0b			if DEBUG_FORTH_PARSE_EXEC 
9e0b				; see if disabled 
9e0b			 
9e0b				ld a, (os_view_disable) 
9e0b				cp '*' 
9e0b				jr z, .skip2 
9e0b			 
9e0b			;	call clear_display 
9e0b			ld hl,(cli_token) 
9e0b			ld a,(hl) 
9e0b			ld (os_word_scratch),a 
9e0b				ld hl,(cli_ptr) 
9e0b			ld a,(hl) 
9e0b				ld (os_word_scratch+1),a 
9e0b				ld a,0 
9e0b				ld (os_word_scratch+2),a 
9e0b				ld de,os_word_scratch 
9e0b				ld a,display_row_4 
9e0b				call str_at_display 
9e0b				call update_display 
9e0b			.skip2:  
9e0b			endif 
9e0b 2a 28 eb			ld hl,(cli_token) 
9e0e 7e				ld a, (hl)	 ; char in word token 
9e0f 23				inc hl 		; move to next char 
9e10 22 28 eb			ld (cli_token), hl ; and save it 
9e13 47				ld b,a 
9e14			 
9e14 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9e17 7e				ld a,(hl) 
9e18 23				inc hl 
9e19 22 22 eb			ld (cli_ptr), hl		; move to next char 
9e1c cd d0 8f			call toUpper 		; make sure the input string matches case 
9e1f			 
9e1f			if DEBUG_FORTH_PARSE 
9e1f			endif 
9e1f			 
9e1f				; input stream end of token is a space so get rid of it 
9e1f			 
9e1f			;	cp ' ' 
9e1f			;	jr nz, .pnskipspace 
9e1f			; 
9e1f			;	ld a, 0		; make same term as word token term 
9e1f			; 
9e1f			;.pnskipspace: 
9e1f			 
9e1f			if DEBUG_FORTH_PARSE_KEY 
9e1f						DMARK "KY7" 
9e1f			endif 
9e1f b8				cp b 
9e20 c2 36 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9e23				 
9e23			;    if same 
9e23			;       scan for string terms 0 for token and 32 for input 
9e23			 
9e23				 
9e23			if DEBUG_FORTH_PARSE_KEY 
9e23						DMARK "KY8" 
9e23			endif 
9e23			 
9e23 80				add b			 
9e24 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9e26							; TODO need to make sure last word in zero term string is accounted for 
9e26 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9e28			 
9e28			 
9e28				; at end of both strings so both are exact match 
9e28			 
9e28			;       skip ptr for next word 
9e28			 
9e28 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
9e2b 23				inc hl			 ; at next char 
9e2c 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
9e2f 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9e32				 
9e32				 
9e32			if DEBUG_FORTH_PARSE_KEY 
9e32						DMARK "KY3" 
9e32			endif 
9e32			 
9e32			 
9e32			 
9e32			;       exec code block 
9e32			if DEBUG_FORTH_JP 
9e32				call clear_display 
9e32				call update_display 
9e32				call delay1s 
9e32				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e32				ld a,h 
9e32				ld hl, os_word_scratch 
9e32				call hexout 
9e32				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e32				ld a,l 
9e32				ld hl, os_word_scratch+2 
9e32				call hexout 
9e32				ld hl, os_word_scratch+4 
9e32				ld a,0 
9e32				ld (hl),a 
9e32				ld de,os_word_scratch 
9e32				call str_at_display 
9e32					ld a, display_row_2 
9e32					call str_at_display 
9e32				ld de, (cli_origtoken) 
9e32				ld a, display_row_1+10 
9e32					call str_at_display 
9e32			 
9e32				ld a,display_row_1 
9e32				ld de, .foundword 
9e32				ld a, display_row_3 
9e32				call str_at_display 
9e32				call update_display 
9e32				call delay1s 
9e32				call delay1s 
9e32				call delay1s 
9e32			endif 
9e32			 
9e32			if DEBUG_FORTH_PARSE_KEY 
9e32						DMARK "KYj" 
9e32			endif 
9e32				; TODO save the word pointer in this exec 
9e32			 
9e32 2a 26 eb			ld hl,(cli_execword) 
9e35 e9				jp (hl) 
9e36			 
9e36			 
9e36			;    if not same 
9e36			;	scan for zero term 
9e36			;	get ptr for next word 
9e36			;	goto word comp 
9e36			 
9e36			.execpnskipword:	; get pointer to next word 
9e36 2a 24 eb			ld hl,(cli_nextword) 
9e39			 
9e39 7e				ld a,(hl) 
9e3a fe 00			cp WORD_SYS_END 
9e3c			;	cp 0 
9e3c 28 09			jr z, .execendofdict			 ; at end of words 
9e3e			 
9e3e			if DEBUG_FORTH_PARSE_KEY 
9e3e						DMARK "KY4" 
9e3e			endif 
9e3e			if DEBUG_FORTH_PARSE_EXEC 
9e3e			 
9e3e				; see if disabled 
9e3e			 
9e3e				ld a, (os_view_disable) 
9e3e				cp '*' 
9e3e				jr z, .noskip 
9e3e			 
9e3e			 
9e3e				ld de, .nowordfound 
9e3e				ld a, display_row_3 
9e3e				call str_at_display 
9e3e				call update_display 
9e3e				ld a, 100 
9e3e				call aDelayInMS 
9e3e				 
9e3e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e3e					call delay250ms 
9e3e				endif 
9e3e			.noskip:  
9e3e			 
9e3e			endif	 
9e3e			 
9e3e 2a 20 eb			ld hl,(cli_origptr) 
9e41 22 22 eb			ld (cli_ptr),hl 
9e44			 
9e44			if DEBUG_FORTH_PARSE_KEY 
9e44						DMARK "KY5" 
9e44			endif 
9e44 c3 ea 9d			jp .execpnword			; else go to next word 
9e47			 
9e47			.execendofdict:  
9e47			 
9e47			if DEBUG_FORTH_PARSE_KEY 
9e47						DMARK "KYe" 
9e47			endif 
9e47			if DEBUG_FORTH_PARSE_EXEC 
9e47				; see if disabled 
9e47			 
9e47				ld a, (os_view_disable) 
9e47				cp '*' 
9e47				jr z, .ispskip 
9e47			 
9e47				call clear_display 
9e47				call update_display 
9e47				call delay1s 
9e47				ld de, (cli_origptr) 
9e47				ld a, display_row_1 
9e47				call str_at_display 
9e47				 
9e47				ld de, .enddict 
9e47				ld a, display_row_3 
9e47				call str_at_display 
9e47				call update_display 
9e47				ld a, 100 
9e47				call aDelayInMS 
9e47				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e47				call delay1s 
9e47				call delay1s 
9e47				call delay1s 
9e47				endif 
9e47			.ispskip:  
9e47				 
9e47			endif	 
9e47			 
9e47			 
9e47			 
9e47				; if the word is not a keyword then must be a literal so push it to stack 
9e47			 
9e47			; push token to stack to end of word 
9e47			 
9e47				STACKFRAME ON $1efe $2f9f 
9e47				if DEBUG_STACK_IMB 
9e47					if ON 
9e47						exx 
9e47						ld de, $1efe 
9e47						ld a, d 
9e47						ld hl, curframe 
9e47						call hexout 
9e47						ld a, e 
9e47						ld hl, curframe+2 
9e47						call hexout 
9e47						ld hl, $1efe 
9e47						push hl 
9e47						ld hl, $2f9f 
9e47						push hl 
9e47						exx 
9e47					endif 
9e47				endif 
9e47			endm 
# End of macro STACKFRAME
9e47			 
9e47 2a 58 e6		ld hl,(os_tok_ptr) 
9e4a cd 3f 9b		call forth_apush 
9e4d			 
9e4d				STACKFRAMECHK ON $1efe $2f9f 
9e4d				if DEBUG_STACK_IMB 
9e4d					if ON 
9e4d						exx 
9e4d						ld hl, $2f9f 
9e4d						pop de   ; $2f9f 
9e4d						call cmp16 
9e4d						jr nz, .spnosame 
9e4d						ld hl, $1efe 
9e4d						pop de   ; $1efe 
9e4d						call cmp16 
9e4d						jr z, .spfrsame 
9e4d						.spnosame: call showsperror 
9e4d						.spfrsame: nop 
9e4d						exx 
9e4d					endif 
9e4d				endif 
9e4d			endm 
# End of macro STACKFRAMECHK
9e4d			 
9e4d			execnext: 
9e4d			 
9e4d			if DEBUG_FORTH_PARSE_KEY 
9e4d						DMARK "KY>" 
9e4d			endif 
9e4d			; move past token to next word 
9e4d			 
9e4d 2a 58 e6		ld hl, (os_tok_ptr) 
9e50 3e 00		ld a, 0 
9e52 01 ff 00		ld bc, 255     ; input buffer size 
9e55 ed b1		cpir 
9e57			 
9e57			if DEBUG_FORTH_PARSE_KEY 
9e57						DMARK "KY!" 
9e57				CALLMONITOR 
9e57			endif	 
9e57			; TODO this might place hl on the null, so will need to forward on??? 
9e57			;inc hl   ; see if this gets onto the next item 
9e57			 
9e57			 
9e57			; TODO pass a pointer to the buffer to push 
9e57			; TODO call function to push 
9e57			 
9e57			; look for end of input 
9e57			 
9e57			;inc hl 
9e57			;ld a,(hl) 
9e57			;cp FORTH_END_BUFFER 
9e57			;ret z 
9e57			 
9e57			 
9e57 c3 d0 9d		jp exec1 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			 
9e5a			findnexttok: 
9e5a			 
9e5a				; hl is pointer to move 
9e5a				; de is the token to locate 
9e5a			 
9e5a					if DEBUG_FORTH 
9e5a						DMARK "NTK" 
9e5a						CALLMONITOR 
9e5a					endif 
9e5a d5				push de 
9e5b			 
9e5b			.fnt1:	 
9e5b				; find first char of token to locate 
9e5b			 
9e5b 1a				ld a, (de) 
9e5c 4f				ld c,a 
9e5d 7e				ld a,(hl) 
9e5e cd d0 8f			call toUpper 
9e61					if DEBUG_FORTH 
9e61						DMARK "NT1" 
9e61						CALLMONITOR 
9e61					endif 
9e61 b9				cp c 
9e62			 
9e62 28 03			jr z, .fnt2cmpmorefirst	 
9e64			 
9e64				; first char not found move to next char 
9e64			 
9e64 23				inc hl 
9e65 18 f4			jr .fnt1 
9e67			 
9e67			.fnt2cmpmorefirst:	 
9e67				; first char of token found.  
9e67			 
9e67 e5				push hl     ; save start of token just in case it is the right one 
9e68 d9				exx 
9e69 e1				pop hl        ; save it to hl' 
9e6a d9				exx 
9e6b			 
9e6b			 
9e6b			.fnt2cmpmore:	 
9e6b				; compare the rest 
9e6b				 
9e6b 23				inc hl 
9e6c 13				inc de 
9e6d				 
9e6d 1a				ld a, (de) 
9e6e 4f				ld c,a 
9e6f 7e				ld a,(hl) 
9e70 cd d0 8f			call toUpper 
9e73			 
9e73					if DEBUG_FORTH 
9e73						DMARK "NT2" 
9e73						CALLMONITOR 
9e73					endif 
9e73				; c has the token to find char 
9e73				; a has the mem to scan char 
9e73			 
9e73 b9				cp c 
9e74 28 04			jr z,.fntmatch1 
9e76			 
9e76				; they are not the same 
9e76			 
9e76					if DEBUG_FORTH 
9e76						DMARK "NT3" 
9e76						CALLMONITOR 
9e76					endif 
9e76 d1				pop de	; reset de token to look for 
9e77 d5				push de 
9e78 18 e1			jr .fnt1 
9e7a				 
9e7a			.fntmatch1: 
9e7a			 
9e7a				; is the same char a null which means we might have a full hit? 
9e7a					if DEBUG_FORTH 
9e7a						DMARK "NT4" 
9e7a						CALLMONITOR 
9e7a					endif 
9e7a			 
9e7a fe 00			cp 0 
9e7c 28 0b			jr z, .fntmatchyes 
9e7e			 
9e7e				; are we at the end of the token to find? 
9e7e			 
9e7e					if DEBUG_FORTH 
9e7e						DMARK "NT5" 
9e7e						CALLMONITOR 
9e7e					endif 
9e7e 3e 00			ld a, 0 
9e80 b9				cp c 
9e81			 
9e81 c2 6b 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9e84			 
9e84					if DEBUG_FORTH 
9e84						DMARK "NT6" 
9e84						CALLMONITOR 
9e84					endif 
9e84				; token to find is exhusted but no match to stream 
9e84			 
9e84				; restore tok pointer and continue on 
9e84 d1				pop de 
9e85 d5				push de 
9e86 c3 5b 9e			jp .fnt1 
9e89			 
9e89			 
9e89			.fntmatchyes: 
9e89			 
9e89				; hl now contains the end of the found token 
9e89			 
9e89				; get rid of saved token pointer to find 
9e89			 
9e89 d1				pop de 
9e8a			 
9e8a					if DEBUG_FORTH 
9e8a						DMARK "NT9" 
9e8a						CALLMONITOR 
9e8a					endif 
9e8a			 
9e8a				; hl will be on the null term so forward on 
9e8a			 
9e8a				; get back the saved start of the token 
9e8a			 
9e8a d9				exx 
9e8b e5				push hl     ; save start of token just in case it is the right one 
9e8c d9				exx 
9e8d e1				pop hl        ; save it to hl 
9e8e			 
9e8e c9				ret 
9e8f			 
9e8f			 
9e8f			; LIST needs to find a specific token   
9e8f			; FORGET needs to find a spefici token 
9e8f			 
9e8f			; SAVE needs to find all tokens by flag 
9e8f			; WORDS just needs to scan through all  by flag 
9e8f			; UWORDS needs to scan through all by flag 
9e8f			 
9e8f			 
9e8f			; given hl as pointer to start of dict look up string 
9e8f			; return hl as pointer to start of word block 
9e8f			; or 0 if not found 
9e8f			 
9e8f			forth_find_tok: 
9e8f c9				ret 
9e90			 
9e90			; given hl as pointer to dict structure 
9e90			; move to the next dict block structure 
9e90			 
9e90			forth_tok_next: 
9e90				; hl now points to the address of the next word pointer  
9e90				; TODO skip compiled symbol for now 
9e90			;	push de 
9e90 23				inc hl 
9e91 5e				ld e, (hl) 
9e92 23				inc hl 
9e93 56				ld d, (hl) 
9e94 23				inc hl 
9e95			 
9e95 eb				ex de,hl 
9e96			if DEBUG_FORTH_PARSE_NEXTWORD 
9e96				push bc 
9e96				ld bc, (cli_nextword) 
9e96						DMARK "NXW" 
9e96				CALLMONITOR 
9e96				pop bc 
9e96			endif 
9e96			;	pop de	 
9e96 c9				ret 
9e97			 
9e97			 
9e97			 
9e97			; eof 
# End of file forth_parserv5.asm
9e97				include "forth_wordsv4.asm" 
9e97			 
9e97			; the core word dictionary v4 
9e97			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9e97			 
9e97			; this is a linked list for each of the system words used 
9e97			; user defined words will follow the same format but will be in ram 
9e97			 
9e97			 
9e97			; 
9e97			; 
9e97			; define linked list: 
9e97			; 
9e97			; 1. compiled byte op code 
9e97			; 2. len of text word 
9e97			; 3. text word 
9e97			; 4. ptr to next dictionary word 
9e97			; 5. asm, calls etc for the word 
9e97			; 
9e97			;  if 1 == 0 then last word in dict  
9e97			;   
9e97			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9e97			;  
9e97			;  
9e97			; create basic standard set of words 
9e97			; 
9e97			;  
9e97			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9e97			; 2DUP 2DROP 2SWAP  
9e97			; @ C@ - get byte  
9e97			; ! C! - store byte 
9e97			; 0< true if less than zero 
9e97			; 0= true if zero 
9e97			; < >  
9e97			; = true if same 
9e97			; variables 
9e97			 
9e97			 
9e97			; Hardware specific words I may need 
9e97			; 
9e97			; IN OUT  
9e97			; calls to key util functions 
9e97			; calls to hardward abstraction stuff 
9e97			; easy control of frame buffers and lcd i/o 
9e97			; keyboard  
9e97			 
9e97			 
9e97			;DICT: macro 
9e97			; op_code, len, word, next 
9e97			;    word: 
9e97			;    db op_code 
9e97			;    ds word zero term 
9e97			;    dw next 
9e97			;    endm 
9e97			 
9e97			 
9e97			 
9e97			 
9e97			; op code 1 is a flag for user define words which are to be handled differently 
9e97			 
9e97			 
9e97			; 
9e97			; 
9e97			;    TODO on entry to a word this should be the expected environment 
9e97			;    hl - tos value if number then held, if string this is the ptr 
9e97			;    de -  
9e97			 
9e97			 
9e97			; opcode ranges 
9e97			; 0 - end of word dict 
9e97			; 255 - user define words 
9e97			 
9e97			sysdict: 
9e97			include "forth_opcodes.asm" 
9e97			; op codes for forth keywords 
9e97			; free to use code 0  
9e97				OPCODE_HEAP: equ  1 
9e97				OPCODE_EXEC: equ 2 
9e97				OPCODE_DUP: equ 3 
9e97				OPCODE_SWAP: equ 4 
9e97				OPCODE_COLN: equ 5 
9e97				OPCODE_SCOLN: equ 6 
9e97				OPCODE_DROP: equ 7 
9e97				OPCODE_DUP2: equ 8 
9e97				OPCODE_DROP2: equ 9 
9e97				OPCODE_SWAP2: equ 10 
9e97				OPCODE_AT: equ 11 
9e97				OPCODE_CAT: equ 12 
9e97				OPCODE_BANG: equ 13 
9e97				OPCODE_CBANG: equ 14 
9e97				OPCODE_SCALL: equ 15 
9e97				OPCODE_DEPTH: equ 16 
9e97				OPCODE_OVER: equ 17 
9e97				OPCODE_PAUSE: equ 18 
9e97				OPCODE_PAUSES: equ 19 
9e97				OPCODE_ROT: equ 20 
9e97			;free to reuse	OPCODE_WORDS: equ 21 
9e97			        OPCODE_NOT: equ 21 
9e97				OPCODE_UWORDS: equ 22 
9e97				OPCODE_BP: equ 23 
9e97				OPCODE_MONITOR: equ 24  
9e97				OPCODE_MALLOC: equ 25 
9e97				OPCODE_FREE: equ 26 
9e97				OPCODE_LIST: equ 27 
9e97				OPCODE_FORGET: equ 28 
9e97				OPCODE_NOP: equ 29 
9e97				OPCODE_COMO: equ 30 
9e97				OPCODE_COMC: equ 31 
9e97			;free to reuse	OPCODE_ENDCORE: equ 32 
9e97				OPCODE_AFTERSOUND: equ 33 
9e97				OPCODE_GP2: equ 34 
9e97				OPCODE_GP3: equ 35 
9e97				OPCODE_GP4: equ 36 
9e97				OPCODE_SIN: equ 37 
9e97				OPCODE_SOUT: equ 38 
9e97				OPCODE_SPIO: equ 39 
9e97				OPCODE_SPICEH: equ 40 
9e97				OPCODE_SPIOb: equ 41 
9e97				OPCODE_SPII: equ 42 
9e97				OPCODE_SESEL: equ 43 
9e97				OPCODE_CARTDEV: equ 44 
9e97			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9e97				OPCODE_FB: equ 46 
9e97				OPCODE_EMIT: equ 47 
9e97				OPCODE_DOTH: equ 48 
9e97				OPCODE_DOTF: equ 49 
9e97				OPCODE_DOT: equ 50 
9e97				OPCODE_CLS: equ 51 
9e97				OPCODE_DRAW: equ 52 
9e97				OPCODE_DUMP: equ 53 
9e97				OPCODE_CDUMP: equ 54 
9e97				OPCODE_DAT: equ 55 
9e97				OPCODE_HOME: equ 56 
9e97				OPCODE_SPACE: equ 57 
9e97				OPCODE_SPACES: equ 58 
9e97				OPCODE_SCROLL: equ 59 
9e97				OPCODE_ATQ: equ 60 
9e97				OPCODE_AUTODSP: equ 61 
9e97				OPCODE_MENU: equ 62 
9e97			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9e97				OPCODE_THEN: equ 64 
9e97				OPCODE_ELSE: equ 65 
9e97				OPCODE_DO: equ 66 
9e97				OPCODE_LOOP: equ 67 
9e97				OPCODE_I: equ 68 
9e97				OPCODE_DLOOP: equ 69  
9e97				OPCODE_REPEAT: equ 70  
9e97				OPCODE_UNTIL: equ 71 
9e97				OPCODE_ENDFLOW: equ 72 
9e97				OPCODE_WAITK: equ 73 
9e97				OPCODE_ACCEPT: equ 74 
9e97				OPCODE_EDIT: equ 75 
9e97			;free to reuse	OPCODE_ENDKEY: equ 76 
9e97				OPCODE_LZERO: equ 77 
9e97				OPCODE_TZERO: equ 78 
9e97				OPCODE_LESS: equ 79 
9e97				OPCODE_GT: equ 80 
9e97				OPCODE_EQUAL: equ 81  
9e97			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9e97				OPCODE_NEG: equ 83 
9e97				OPCODE_DIV: equ 84 
9e97				OPCODE_MUL: equ 85 
9e97				OPCODE_MIN: equ 86 
9e97				OPCODE_MAX: equ 87 
9e97				OPCODE_RND16: equ 88 
9e97				OPCODE_RND8: equ 89 
9e97				OPCODE_RND: equ 90 
9e97			;free to reuse	OPCODE_ENDMATHS: equ 91  
9e97				OPCODE_BYNAME: equ 92 
9e97				OPCODE_DIR: equ 93 
9e97				OPCODE_SAVE: equ 94 
9e97				OPCODE_LOAD: equ 95 
9e97				OPCODE_BSAVE: equ 96 
9e97				OPCODE_BLOAD: equ 97 
9e97				OPCODE_SEO: equ 98  
9e97				OPCODE_SEI: equ 99 
9e97				OPCODE_SFREE: equ 100 
9e97				OPCODE_SIZE: equ 101 
9e97				OPCODE_CREATE: equ 102 
9e97				OPCODE_APPEND: equ 103 
9e97				OPCODE_SDEL: equ 104 
9e97				OPCODE_OPEN: equ 105 
9e97				OPCODE_READ: equ 106 
9e97				OPCODE_EOF: equ 106 
9e97				OPCODE_FORMAT: equ 107 
9e97				OPCODE_LABEL: equ 108 
9e97				OPCODE_LABELS: equ 109 
9e97			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9e97				OPCODE_UPPER: equ 111 
9e97				OPCODE_LOWER: equ 112 
9e97				OPCODE_SUBSTR: equ 113 
9e97				OPCODE_LEFT: equ 114 
9e97				OPCODE_RIGHT: equ 115 
9e97				OPCODE_STR2NUM: equ 116 
9e97				OPCODE_NUM2STR: equ 117 
9e97				OPCODE_CONCAT: equ 118 
9e97				OPCODE_FIND: equ 119 
9e97				OPCODE_LEN: equ 120 
9e97				OPCODE_CHAR: equ 121 
9e97			; free to reuse	OPCODE_STRLEN: equ 122 
9e97			; free to reuse	OPCODE_ENDSTR: equ 123 
9e97				OPCODE_V0S: equ 124 
9e97				OPCODE_V0Q: equ 125 
9e97				OPCODE_V1S: equ 126 
9e97				OPCODE_V1Q: equ 127 
9e97				OPCODE_V2S: equ 128 
9e97				OPCODE_V2Q: equ 129 
9e97				OPCODE_V3S: equ 130 
9e97				OPCODE_V3Q: equ 131 
9e97			;free to reuse	OPCODE_END: equ 132 
9e97				OPCODE_ZDUP: equ 133 
9e97			 
9e97			; eof 
# End of file forth_opcodes.asm
9e97			 
9e97			include "forth_words_core.asm" 
9e97			 
9e97			; | ## Core Words 
9e97			 
9e97			;if MALLOC_4 
9e97			 
9e97			.HEAP: 
9e97				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9e97 15				db WORD_SYS_CORE+OPCODE_HEAP             
9e98 d6 9e			dw .EXEC            
9e9a 05				db 4 + 1 
9e9b .. 00			db "HEAP",0              
9ea0				endm 
# End of macro CWHEAD
9ea0			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9ea0			; | | u1 - Current number of bytes in the heap 
9ea0			; | | u2 - Remaining bytes left on the heap 
9ea0			; | |  
9ea0			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9ea0			 
9ea0			 
9ea0					if DEBUG_FORTH_WORDS_KEY 
9ea0						DMARK "HEP" 
9ea0 f5				push af  
9ea1 3a b5 9e			ld a, (.dmark)  
9ea4 32 71 ee			ld (debug_mark),a  
9ea7 3a b6 9e			ld a, (.dmark+1)  
9eaa 32 72 ee			ld (debug_mark+1),a  
9ead 3a b7 9e			ld a, (.dmark+2)  
9eb0 32 73 ee			ld (debug_mark+2),a  
9eb3 18 03			jr .pastdmark  
9eb5 ..			.dmark: db "HEP"  
9eb8 f1			.pastdmark: pop af  
9eb9			endm  
# End of macro DMARK
9eb9						CALLMONITOR 
9eb9 cd 7c 93			call break_point_state  
9ebc				endm  
# End of macro CALLMONITOR
9ebc					endif 
9ebc 2a f5 d8				ld hl, (free_list )      
9ebf 11 fa d8				ld de, heap_start 
9ec2			 
9ec2 ed 52				sbc hl, de  
9ec4			 
9ec4 cd d6 99				call forth_push_numhl 
9ec7			 
9ec7			 
9ec7 ed 5b f5 d8			ld de, (free_list )      
9ecb 21 3d e3				ld hl, heap_end 
9ece			 
9ece ed 52				sbc hl, de 
9ed0			 
9ed0 cd d6 99				call forth_push_numhl 
9ed3					 
9ed3			 
9ed3					 
9ed3			 
9ed3			 
9ed3			 
9ed3					NEXTW 
9ed3 c3 3f 9d			jp macro_next 
9ed6				endm 
# End of macro NEXTW
9ed6			;endif 
9ed6			 
9ed6			.EXEC: 
9ed6			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9ed6			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9ed6			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9ed6			;; > > 
9ed6			;; > >   
9ed6			;	STACKFRAME OFF $5efe $5f9f 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS_KEY 
9ed6			;			DMARK "EXE" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			;	FORTH_DSP_VALUEHL 
9ed6			; 
9ed6			;	FORTH_DSP_POP 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX1" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;;	ld e,(hl) 
9ed6			;;	inc hl 
9ed6			;;	ld d,(hl) 
9ed6			;;	ex de,hl 
9ed6			; 
9ed6			;;		if DEBUG_FORTH_WORDS 
9ed6			;;			DMARK "EX2" 
9ed6			;;			CALLMONITOR 
9ed6			;;		endif 
9ed6			;	push hl 
9ed6			; 
9ed6			;	;ld a, 0 
9ed6			;	;ld a, FORTH_END_BUFFER 
9ed6			;	call strlenz 
9ed6			;	inc hl   ; include zero term to copy 
9ed6			;	inc hl   ; include term 
9ed6			;	inc hl   ; include term 
9ed6			;	ld b,0 
9ed6			;	ld c,l 
9ed6			;	pop hl 
9ed6			;	ld de, execscratch 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX3" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	ldir 
9ed6			; 
9ed6			; 
9ed6			;	ld hl, execscratch 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EXe" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			;	call forthparse 
9ed6			;	call forthexec 
9ed6			;;	call forthexec_cleanup 
9ed6			;;	call forthparse 
9ed6			;;	call forthexec 
9ed6			; 
9ed6			;	STACKFRAMECHK OFF $5efe $5f9f 
9ed6			; 
9ed6			;	; an immediate word so no need to process any more words 
9ed6			;	ret 
9ed6			;	NEXTW 
9ed6			 
9ed6			; dead code - old version  
9ed6			;	FORTH_RSP_NEXT 
9ed6			 
9ed6			;  
9ed6			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ed6			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ed6			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ed6			;	push hl 
9ed6			;	push de 
9ed6			;	push bc 
9ed6			; 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS_KEY 
9ed6			;			DMARK "EXR" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			; 
9ed6			; 
9ed6			;	;v5 FORTH_DSP_VALUE 
9ed6			;	FORTH_DSP_VALUEHL 
9ed6			; 
9ed6			;	; TODO do string type checks 
9ed6			; 
9ed6			;;v5	inc hl   ; skip type 
9ed6			; 
9ed6			;	push hl  ; source code  
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX1" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	ld a, 0 
9ed6			;	call strlent 
9ed6			; 
9ed6			;	inc hl 
9ed6			;	inc hl 
9ed6			;	inc hl 
9ed6			;	inc hl 
9ed6			; 
9ed6			;	push hl    ; size 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX2" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	call malloc 
9ed6			; 
9ed6			;	ex de, hl    ; de now contains malloc area 
9ed6			;	pop bc   	; get byte count 
9ed6			;	pop hl      ; get string to copy 
9ed6			; 
9ed6			;	push de     ; save malloc for free later 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX3" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	ldir       ; duplicate string 
9ed6			; 
9ed6			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9ed6			;	 
9ed6			;	; TODO fix the parse would be better than this...  
9ed6			;	ex de, hl 
9ed6			;	dec hl 
9ed6			;	ld a, 0 
9ed6			;	ld (hl), a 
9ed6			;	dec hl 
9ed6			;	ld a, ' ' 
9ed6			;	ld (hl), a 
9ed6			;	dec hl 
9ed6			;	ld (hl), a 
9ed6			; 
9ed6			;	dec hl 
9ed6			;	ld (hl), a 
9ed6			; 
9ed6			; 
9ed6			;	FORTH_DSP_POP  
9ed6			; 
9ed6			;	pop hl     
9ed6			;	push hl    ; save malloc area 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX4" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			;	call forthparse 
9ed6			;	call forthexec 
9ed6			;	 
9ed6			;	pop hl 
9ed6			;	if DEBUG_FORTH_WORDS 
9ed6			;		DMARK "EX5" 
9ed6			;		CALLMONITOR 
9ed6			;	endif 
9ed6			; 
9ed6			;	if FORTH_ENABLE_FREE 
9ed6			;	call free 
9ed6			;	endif 
9ed6			; 
9ed6			;	if DEBUG_FORTH_WORDS 
9ed6			;		DMARK "EX6" 
9ed6			;		CALLMONITOR 
9ed6			;	endif 
9ed6			; 
9ed6			;	pop bc 
9ed6			;	pop de 
9ed6			;	pop hl 
9ed6			;;	FORTH_RSP_POP	  
9ed6			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9ed6			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9ed6			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9ed6			; 
9ed6			;	if DEBUG_FORTH_WORDS 
9ed6			;		DMARK "EX7" 
9ed6			;		CALLMONITOR 
9ed6			;	endif 
9ed6			;	NEXTW 
9ed6			 
9ed6			;.STKEXEC: 
9ed6			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9ed6			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9ed6			; 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS_KEY 
9ed6			;			DMARK "STX" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			;	FORTH_DSP_VALUEHL 
9ed6			; 
9ed6			;	ld (store_tmp1), hl    ; count 
9ed6			; 
9ed6			;	FORTH_DSP_POP 
9ed6			;.stkexec1: 
9ed6			;	ld hl, (store_tmp1)   ; count 
9ed6			;	ld a, 0 
9ed6			;	cp l 
9ed6			;	ret z 
9ed6			; 
9ed6			;	dec hl 
9ed6			;	ld (store_tmp1), hl    ; count 
9ed6			;	 
9ed6			;	FORTH_DSP_VALUEHL 
9ed6			;	push hl 
9ed6			;	 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EXp" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	FORTH_DSP_POP 
9ed6			; 
9ed6			;	call strlenz 
9ed6			;	inc hl   ; include zero term to copy 
9ed6			;	inc hl   ; include zero term to copy 
9ed6			;	inc hl   ; include zero term to copy 
9ed6			;	ld b,0 
9ed6			;	ld c,l 
9ed6			;	pop hl 
9ed6			;	ld de, execscratch 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EX3" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	ldir 
9ed6			; 
9ed6			; 
9ed6			;	ld hl, execscratch 
9ed6			; 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EXP" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			; 
9ed6			;	call forthparse 
9ed6			;	ld hl, execscratch 
9ed6			;		if DEBUG_FORTH_WORDS 
9ed6			;			DMARK "EXx" 
9ed6			;			CALLMONITOR 
9ed6			;		endif 
9ed6			;	call forthexec 
9ed6			; 
9ed6			;	jp .stkexec1 
9ed6			; 
9ed6			;	ret 
9ed6			 
9ed6			 
9ed6			.DUP: 
9ed6				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9ed6 17				db WORD_SYS_CORE+OPCODE_DUP             
9ed7 4c 9f			dw .ZDUP            
9ed9 04				db 3 + 1 
9eda .. 00			db "DUP",0              
9ede				endm 
# End of macro CWHEAD
9ede			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9ede			 
9ede					if DEBUG_FORTH_WORDS_KEY 
9ede						DMARK "DUP" 
9ede f5				push af  
9edf 3a f3 9e			ld a, (.dmark)  
9ee2 32 71 ee			ld (debug_mark),a  
9ee5 3a f4 9e			ld a, (.dmark+1)  
9ee8 32 72 ee			ld (debug_mark+1),a  
9eeb 3a f5 9e			ld a, (.dmark+2)  
9eee 32 73 ee			ld (debug_mark+2),a  
9ef1 18 03			jr .pastdmark  
9ef3 ..			.dmark: db "DUP"  
9ef6 f1			.pastdmark: pop af  
9ef7			endm  
# End of macro DMARK
9ef7						CALLMONITOR 
9ef7 cd 7c 93			call break_point_state  
9efa				endm  
# End of macro CALLMONITOR
9efa					endif 
9efa			 
9efa					FORTH_DSP 
9efa cd 93 9b			call macro_forth_dsp 
9efd				endm 
# End of macro FORTH_DSP
9efd			 
9efd 7e					ld a, (HL) 
9efe fe 01				cp DS_TYPE_STR 
9f00 20 25				jr nz, .dupinum 
9f02			 
9f02					; push another string 
9f02			 
9f02					FORTH_DSP_VALUEHL     		 
9f02 cd cd 9b			call macro_dsp_valuehl 
9f05				endm 
# End of macro FORTH_DSP_VALUEHL
9f05			 
9f05				if DEBUG_FORTH_WORDS 
9f05					DMARK "DUs" 
9f05 f5				push af  
9f06 3a 1a 9f			ld a, (.dmark)  
9f09 32 71 ee			ld (debug_mark),a  
9f0c 3a 1b 9f			ld a, (.dmark+1)  
9f0f 32 72 ee			ld (debug_mark+1),a  
9f12 3a 1c 9f			ld a, (.dmark+2)  
9f15 32 73 ee			ld (debug_mark+2),a  
9f18 18 03			jr .pastdmark  
9f1a ..			.dmark: db "DUs"  
9f1d f1			.pastdmark: pop af  
9f1e			endm  
# End of macro DMARK
9f1e					CALLMONITOR 
9f1e cd 7c 93			call break_point_state  
9f21				endm  
# End of macro CALLMONITOR
9f21				endif 
9f21 cd 44 9a				call forth_push_str 
9f24			 
9f24					NEXTW 
9f24 c3 3f 9d			jp macro_next 
9f27				endm 
# End of macro NEXTW
9f27			 
9f27			 
9f27			.dupinum: 
9f27					 
9f27			 
9f27			 
9f27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f27 cd cd 9b			call macro_dsp_valuehl 
9f2a				endm 
# End of macro FORTH_DSP_VALUEHL
9f2a			 
9f2a				; TODO add floating point number detection 
9f2a			 
9f2a				if DEBUG_FORTH_WORDS 
9f2a					DMARK "DUi" 
9f2a f5				push af  
9f2b 3a 3f 9f			ld a, (.dmark)  
9f2e 32 71 ee			ld (debug_mark),a  
9f31 3a 40 9f			ld a, (.dmark+1)  
9f34 32 72 ee			ld (debug_mark+1),a  
9f37 3a 41 9f			ld a, (.dmark+2)  
9f3a 32 73 ee			ld (debug_mark+2),a  
9f3d 18 03			jr .pastdmark  
9f3f ..			.dmark: db "DUi"  
9f42 f1			.pastdmark: pop af  
9f43			endm  
# End of macro DMARK
9f43					CALLMONITOR 
9f43 cd 7c 93			call break_point_state  
9f46				endm  
# End of macro CALLMONITOR
9f46				endif 
9f46			 
9f46 cd d6 99				call forth_push_numhl 
9f49					NEXTW 
9f49 c3 3f 9d			jp macro_next 
9f4c				endm 
# End of macro NEXTW
9f4c			.ZDUP: 
9f4c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9f4c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9f4d 84 9f			dw .SWAP            
9f4f 05				db 4 + 1 
9f50 .. 00			db "?DUP",0              
9f55				endm 
# End of macro CWHEAD
9f55			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9f55			 
9f55					if DEBUG_FORTH_WORDS_KEY 
9f55						DMARK "qDU" 
9f55 f5				push af  
9f56 3a 6a 9f			ld a, (.dmark)  
9f59 32 71 ee			ld (debug_mark),a  
9f5c 3a 6b 9f			ld a, (.dmark+1)  
9f5f 32 72 ee			ld (debug_mark+1),a  
9f62 3a 6c 9f			ld a, (.dmark+2)  
9f65 32 73 ee			ld (debug_mark+2),a  
9f68 18 03			jr .pastdmark  
9f6a ..			.dmark: db "qDU"  
9f6d f1			.pastdmark: pop af  
9f6e			endm  
# End of macro DMARK
9f6e						CALLMONITOR 
9f6e cd 7c 93			call break_point_state  
9f71				endm  
# End of macro CALLMONITOR
9f71					endif 
9f71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f71 cd cd 9b			call macro_dsp_valuehl 
9f74				endm 
# End of macro FORTH_DSP_VALUEHL
9f74			 
9f74 e5					push hl 
9f75			 
9f75					; is it a zero? 
9f75			 
9f75 3e 00				ld a, 0 
9f77 84					add h 
9f78 85					add l 
9f79			 
9f79 e1					pop hl 
9f7a			 
9f7a fe 00				cp 0 
9f7c 28 03				jr z, .dup2orig 
9f7e			 
9f7e			 
9f7e cd d6 99				call forth_push_numhl 
9f81			 
9f81			 
9f81				; TODO add floating point number detection 
9f81			 
9f81			.dup2orig: 
9f81			 
9f81					NEXTW 
9f81 c3 3f 9d			jp macro_next 
9f84				endm 
# End of macro NEXTW
9f84			.SWAP: 
9f84				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9f84 18				db WORD_SYS_CORE+OPCODE_SWAP             
9f85 c3 9f			dw .COLN            
9f87 05				db 4 + 1 
9f88 .. 00			db "SWAP",0              
9f8d				endm 
# End of macro CWHEAD
9f8d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9f8d					if DEBUG_FORTH_WORDS_KEY 
9f8d						DMARK "SWP" 
9f8d f5				push af  
9f8e 3a a2 9f			ld a, (.dmark)  
9f91 32 71 ee			ld (debug_mark),a  
9f94 3a a3 9f			ld a, (.dmark+1)  
9f97 32 72 ee			ld (debug_mark+1),a  
9f9a 3a a4 9f			ld a, (.dmark+2)  
9f9d 32 73 ee			ld (debug_mark+2),a  
9fa0 18 03			jr .pastdmark  
9fa2 ..			.dmark: db "SWP"  
9fa5 f1			.pastdmark: pop af  
9fa6			endm  
# End of macro DMARK
9fa6						CALLMONITOR 
9fa6 cd 7c 93			call break_point_state  
9fa9				endm  
# End of macro CALLMONITOR
9fa9					endif 
9fa9			 
9fa9					FORTH_DSP_VALUEHL 
9fa9 cd cd 9b			call macro_dsp_valuehl 
9fac				endm 
# End of macro FORTH_DSP_VALUEHL
9fac e5					push hl     ; w2 
9fad			 
9fad					FORTH_DSP_POP 
9fad cd 85 9c			call macro_forth_dsp_pop 
9fb0				endm 
# End of macro FORTH_DSP_POP
9fb0			 
9fb0					FORTH_DSP_VALUEHL 
9fb0 cd cd 9b			call macro_dsp_valuehl 
9fb3				endm 
# End of macro FORTH_DSP_VALUEHL
9fb3			 
9fb3					FORTH_DSP_POP 
9fb3 cd 85 9c			call macro_forth_dsp_pop 
9fb6				endm 
# End of macro FORTH_DSP_POP
9fb6			 
9fb6 d1					pop de     ; w2	, hl = w1 
9fb7			 
9fb7 eb					ex de, hl 
9fb8 d5					push de 
9fb9			 
9fb9 cd d6 99				call forth_push_numhl 
9fbc			 
9fbc e1					pop hl 
9fbd			 
9fbd cd d6 99				call forth_push_numhl 
9fc0					 
9fc0			 
9fc0					NEXTW 
9fc0 c3 3f 9d			jp macro_next 
9fc3				endm 
# End of macro NEXTW
9fc3			.COLN: 
9fc3				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9fc3 19				db WORD_SYS_CORE+OPCODE_COLN             
9fc4 4f a1			dw .SCOLN            
9fc6 02				db 1 + 1 
9fc7 .. 00			db ":",0              
9fc9				endm 
# End of macro CWHEAD
9fc9			; | : ( -- )         Create new word | DONE 
9fc9			 
9fc9					if DEBUG_FORTH_WORDS_KEY 
9fc9						DMARK "CLN" 
9fc9 f5				push af  
9fca 3a de 9f			ld a, (.dmark)  
9fcd 32 71 ee			ld (debug_mark),a  
9fd0 3a df 9f			ld a, (.dmark+1)  
9fd3 32 72 ee			ld (debug_mark+1),a  
9fd6 3a e0 9f			ld a, (.dmark+2)  
9fd9 32 73 ee			ld (debug_mark+2),a  
9fdc 18 03			jr .pastdmark  
9fde ..			.dmark: db "CLN"  
9fe1 f1			.pastdmark: pop af  
9fe2			endm  
# End of macro DMARK
9fe2						CALLMONITOR 
9fe2 cd 7c 93			call break_point_state  
9fe5				endm  
# End of macro CALLMONITOR
9fe5					endif 
9fe5				STACKFRAME OFF $8efe $989f 
9fe5				if DEBUG_STACK_IMB 
9fe5					if OFF 
9fe5						exx 
9fe5						ld de, $8efe 
9fe5						ld a, d 
9fe5						ld hl, curframe 
9fe5						call hexout 
9fe5						ld a, e 
9fe5						ld hl, curframe+2 
9fe5						call hexout 
9fe5						ld hl, $8efe 
9fe5						push hl 
9fe5						ld hl, $989f 
9fe5						push hl 
9fe5						exx 
9fe5					endif 
9fe5				endif 
9fe5			endm 
# End of macro STACKFRAME
9fe5				; get parser buffer length  of new word 
9fe5			 
9fe5				 
9fe5			 
9fe5					; move tok past this to start of name defintition 
9fe5					; TODO get word to define 
9fe5					; TODO Move past word token 
9fe5					; TODO get length of string up to the ';' 
9fe5			 
9fe5 2a 58 e6			ld hl, (os_tok_ptr) 
9fe8 23				inc hl 
9fe9 23				inc hl 
9fea			 
9fea 3e 3b			ld a, ';' 
9fec cd e4 8f			call strlent 
9fef			 
9fef 7d				ld a,l 
9ff0 32 53 e3			ld (os_new_parse_len), a 
9ff3			 
9ff3			 
9ff3			if DEBUG_FORTH_UWORD 
9ff3 ed 5b 58 e6		ld de, (os_tok_ptr) 
9ff7						DMARK ":01" 
9ff7 f5				push af  
9ff8 3a 0c a0			ld a, (.dmark)  
9ffb 32 71 ee			ld (debug_mark),a  
9ffe 3a 0d a0			ld a, (.dmark+1)  
a001 32 72 ee			ld (debug_mark+1),a  
a004 3a 0e a0			ld a, (.dmark+2)  
a007 32 73 ee			ld (debug_mark+2),a  
a00a 18 03			jr .pastdmark  
a00c ..			.dmark: db ":01"  
a00f f1			.pastdmark: pop af  
a010			endm  
# End of macro DMARK
a010				CALLMONITOR 
a010 cd 7c 93			call break_point_state  
a013				endm  
# End of macro CALLMONITOR
a013			endif 
a013			 
a013			; 
a013			;  new word memory layout: 
a013			;  
a013			;    : adg 6666 ;  
a013			; 
a013			;    db   1     ; user defined word  
a013 23				inc hl    
a014			;    dw   sysdict 
a014 23				inc hl 
a015 23				inc hl 
a016			;    db <word len>+1 (for null) 
a016 23				inc hl 
a017			;    db .... <word> 
a017			; 
a017			 
a017 23				inc hl    ; some extras for the word preamble before the above 
a018 23				inc hl 
a019 23				inc hl 
a01a 23				inc hl 
a01b 23				inc hl 
a01c 23				inc hl 
a01d 23				inc hl  
a01e 23				inc hl 
a01f 23				inc hl 
a020 23				inc hl 
a021 23				inc hl 
a022 23				inc hl 
a023 23				inc hl 
a024 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a025			;       exec word buffer 
a025			;	<ptr word>   
a025 23				inc hl 
a026 23				inc hl 
a027			;       <word list><null term> 7F final term 
a027			 
a027			 
a027			if DEBUG_FORTH_UWORD 
a027						DMARK ":02" 
a027 f5				push af  
a028 3a 3c a0			ld a, (.dmark)  
a02b 32 71 ee			ld (debug_mark),a  
a02e 3a 3d a0			ld a, (.dmark+1)  
a031 32 72 ee			ld (debug_mark+1),a  
a034 3a 3e a0			ld a, (.dmark+2)  
a037 32 73 ee			ld (debug_mark+2),a  
a03a 18 03			jr .pastdmark  
a03c ..			.dmark: db ":02"  
a03f f1			.pastdmark: pop af  
a040			endm  
# End of macro DMARK
a040				CALLMONITOR 
a040 cd 7c 93			call break_point_state  
a043				endm  
# End of macro CALLMONITOR
a043			endif 
a043			 
a043				 
a043					; malloc the size 
a043			 
a043 cd 42 90				call malloc 
a046 22 55 e3				ld (os_new_malloc), hl     ; save malloc start 
a049			 
a049			;    db   1     ; user defined word  
a049 3e 01				ld a, WORD_SYS_UWORD  
a04b 77					ld (hl), a 
a04c				 
a04c 23				inc hl    
a04d			;    dw   sysdict 
a04d 11 97 9e			ld de, sysdict       ; continue on with the scan to the system dict 
a050 73				ld (hl), e 
a051 23				inc hl 
a052 72				ld (hl), d 
a053 23				inc hl 
a054			 
a054			 
a054			;    Setup dict word 
a054			 
a054 23				inc hl 
a055 22 4f e3			ld (os_new_work_ptr), hl     ; save start of dict word  
a058			 
a058				; 1. get length of dict word 
a058			 
a058			 
a058 2a 58 e6			ld hl, (os_tok_ptr) 
a05b 23				inc hl 
a05c 23				inc hl    ; position to start of dict word 
a05d 3e 00			ld a, 0 
a05f cd e4 8f			call strlent 
a062			 
a062			 
a062 23				inc hl    ; to include null??? 
a063			 
a063				; write length of dict word 
a063			 
a063 ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a067 1b				dec de 
a068 eb				ex de, hl 
a069 73				ld (hl), e 
a06a eb				ex de, hl 
a06b			 
a06b				 
a06b			 
a06b				; copy  
a06b 4d				ld c, l 
a06c 06 00			ld b, 0 
a06e ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a072 2a 58 e6			ld hl, (os_tok_ptr) 
a075 23				inc hl 
a076 23				inc hl    ; position to start of dict word 
a077				 
a077			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a077				 
a077				; TODO need to convert word to upper case 
a077			 
a077			ucasetok:	 
a077 7e				ld a,(hl) 
a078 cd d0 8f			call toUpper 
a07b 77				ld (hl),a 
a07c ed a0			ldi 
a07e f2 77 a0		 	jp p, ucasetok 
a081			 
a081			 
a081			 
a081				; de now points to start of where the word body code should be placed 
a081 ed 53 4f e3		ld (os_new_work_ptr), de 
a085				; hl now points to the words to throw at forthexec which needs to be copied 
a085 22 4d e3			ld (os_new_src_ptr), hl 
a088			 
a088				; TODO add 'call to forthexec' 
a088			 
a088			if DEBUG_FORTH_UWORD 
a088 c5				push bc 
a089 ed 4b 55 e3		ld bc, (os_new_malloc) 
a08d						DMARK ":0x" 
a08d f5				push af  
a08e 3a a2 a0			ld a, (.dmark)  
a091 32 71 ee			ld (debug_mark),a  
a094 3a a3 a0			ld a, (.dmark+1)  
a097 32 72 ee			ld (debug_mark+1),a  
a09a 3a a4 a0			ld a, (.dmark+2)  
a09d 32 73 ee			ld (debug_mark+2),a  
a0a0 18 03			jr .pastdmark  
a0a2 ..			.dmark: db ":0x"  
a0a5 f1			.pastdmark: pop af  
a0a6			endm  
# End of macro DMARK
a0a6				CALLMONITOR 
a0a6 cd 7c 93			call break_point_state  
a0a9				endm  
# End of macro CALLMONITOR
a0a9 c1				pop bc 
a0aa			endif 
a0aa			 
a0aa			 
a0aa				; create word preamble which should be: 
a0aa			 
a0aa			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a0aa			 
a0aa				;    ld hl, <word code> 
a0aa				;    jp user_exec 
a0aa			        ;    <word code bytes> 
a0aa			 
a0aa			 
a0aa			;	inc de     ; TODO ??? or are we already past the word's null 
a0aa eb				ex de, hl 
a0ab			 
a0ab 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a0ad			 
a0ad 23				inc hl 
a0ae 22 49 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a0b1 23				inc hl 
a0b2			 
a0b2 23				inc hl 
a0b3 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a0b5			 
a0b5 01 9f c4			ld bc, user_exec 
a0b8 23				inc hl 
a0b9 71				ld (hl), c     ; poke address of user_exec 
a0ba 23				inc hl 
a0bb 70				ld (hl), b     
a0bc			 ; 
a0bc			;	inc hl 
a0bc			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0bc			; 
a0bc			; 
a0bc			;	ld bc, macro_forth_rsp_next 
a0bc			;	inc hl 
a0bc			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a0bc			;	inc hl 
a0bc			;	ld (hl), b     
a0bc			 ; 
a0bc			;	inc hl 
a0bc			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0bc			; 
a0bc			; 
a0bc			;	inc hl 
a0bc			;	ld bc, forthexec 
a0bc			;	ld (hl), c     ; poke address of forthexec 
a0bc			;	inc hl 
a0bc			;	ld (hl), b      
a0bc			; 
a0bc			;	inc hl 
a0bc			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a0bc			; 
a0bc			;	ld bc, user_dict_next 
a0bc			;	inc hl 
a0bc			;	ld (hl), c     ; poke address of forthexec 
a0bc			;	inc hl 
a0bc			;	ld (hl), b      
a0bc			 
a0bc				; hl is now where we need to copy the word byte data to save this 
a0bc			 
a0bc 23				inc hl 
a0bd 22 4b e3			ld (os_new_exec), hl 
a0c0				 
a0c0				; copy definition 
a0c0			 
a0c0 eb				ex de, hl 
a0c1			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a0c1			;	inc de    ; skip the PC for this parse 
a0c1 3a 53 e3			ld a, (os_new_parse_len) 
a0c4 4f				ld c, a 
a0c5 06 00			ld b, 0 
a0c7 ed b0			ldir		 ; copy defintion 
a0c9			 
a0c9			 
a0c9				; poke the address of where the new word bytes live for forthexec 
a0c9			 
a0c9 2a 49 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a0cc			 
a0cc ed 5b 4b e3		ld de, (os_new_exec)      
a0d0				 
a0d0 73				ld (hl), e 
a0d1 23				inc hl 
a0d2 72				ld (hl), d 
a0d3			 
a0d3					; TODO copy last user dict word next link to this word 
a0d3					; TODO update last user dict word to point to this word 
a0d3			; 
a0d3			; hl f923 de 812a ; bc 811a 
a0d3			 
a0d3			if DEBUG_FORTH_UWORD 
a0d3 c5				push bc 
a0d4 ed 4b 55 e3		ld bc, (os_new_malloc) 
a0d8						DMARK ":0A" 
a0d8 f5				push af  
a0d9 3a ed a0			ld a, (.dmark)  
a0dc 32 71 ee			ld (debug_mark),a  
a0df 3a ee a0			ld a, (.dmark+1)  
a0e2 32 72 ee			ld (debug_mark+1),a  
a0e5 3a ef a0			ld a, (.dmark+2)  
a0e8 32 73 ee			ld (debug_mark+2),a  
a0eb 18 03			jr .pastdmark  
a0ed ..			.dmark: db ":0A"  
a0f0 f1			.pastdmark: pop af  
a0f1			endm  
# End of macro DMARK
a0f1				CALLMONITOR 
a0f1 cd 7c 93			call break_point_state  
a0f4				endm  
# End of macro CALLMONITOR
a0f4 c1				pop bc 
a0f5			endif 
a0f5			if DEBUG_FORTH_UWORD 
a0f5 c5				push bc 
a0f6 ed 4b 55 e3		ld bc, (os_new_malloc) 
a0fa 03				inc bc 
a0fb 03				inc bc 
a0fc 03				inc bc 
a0fd 03				inc bc 
a0fe 03				inc bc 
a0ff 03				inc bc 
a100 03				inc bc 
a101 03				inc bc 
a102			 
a102						DMARK ":0B" 
a102 f5				push af  
a103 3a 17 a1			ld a, (.dmark)  
a106 32 71 ee			ld (debug_mark),a  
a109 3a 18 a1			ld a, (.dmark+1)  
a10c 32 72 ee			ld (debug_mark+1),a  
a10f 3a 19 a1			ld a, (.dmark+2)  
a112 32 73 ee			ld (debug_mark+2),a  
a115 18 03			jr .pastdmark  
a117 ..			.dmark: db ":0B"  
a11a f1			.pastdmark: pop af  
a11b			endm  
# End of macro DMARK
a11b				CALLMONITOR 
a11b cd 7c 93			call break_point_state  
a11e				endm  
# End of macro CALLMONITOR
a11e c1				pop bc 
a11f			endif 
a11f			 
a11f			; update word dict linked list for new word 
a11f			 
a11f			 
a11f 2a 54 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a122 23			inc hl     ; move to next work linked list ptr 
a123			 
a123 ed 5b 55 e3	ld de, (os_new_malloc)		 ; new next word 
a127 73			ld (hl), e 
a128 23			inc hl 
a129 72			ld (hl), d 
a12a			 
a12a			if DEBUG_FORTH_UWORD 
a12a ed 4b 54 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a12e			endif 
a12e			 
a12e ed 53 54 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
a132			 
a132			 
a132			if DEBUG_FORTH_UWORD 
a132						DMARK ":0+" 
a132 f5				push af  
a133 3a 47 a1			ld a, (.dmark)  
a136 32 71 ee			ld (debug_mark),a  
a139 3a 48 a1			ld a, (.dmark+1)  
a13c 32 72 ee			ld (debug_mark+1),a  
a13f 3a 49 a1			ld a, (.dmark+2)  
a142 32 73 ee			ld (debug_mark+2),a  
a145 18 03			jr .pastdmark  
a147 ..			.dmark: db ":0+"  
a14a f1			.pastdmark: pop af  
a14b			endm  
# End of macro DMARK
a14b				CALLMONITOR 
a14b cd 7c 93			call break_point_state  
a14e				endm  
# End of macro CALLMONITOR
a14e			endif 
a14e			 
a14e				STACKFRAMECHK OFF $8efe $989f 
a14e				if DEBUG_STACK_IMB 
a14e					if OFF 
a14e						exx 
a14e						ld hl, $989f 
a14e						pop de   ; $989f 
a14e						call cmp16 
a14e						jr nz, .spnosame 
a14e						ld hl, $8efe 
a14e						pop de   ; $8efe 
a14e						call cmp16 
a14e						jr z, .spfrsame 
a14e						.spnosame: call showsperror 
a14e						.spfrsame: nop 
a14e						exx 
a14e					endif 
a14e				endif 
a14e			endm 
# End of macro STACKFRAMECHK
a14e			 
a14e c9			ret    ; dont process any remaining parser tokens as they form new word 
a14f			 
a14f			 
a14f			 
a14f			 
a14f			;		NEXT 
a14f			.SCOLN: 
a14f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a14f 06				db OPCODE_SCOLN 
a150 9b a1			dw .DROP 
a152 02				db 2 
a153 .. 00			db ";",0           
a155			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a155					if DEBUG_FORTH_WORDS_KEY 
a155						DMARK "SCN" 
a155 f5				push af  
a156 3a 6a a1			ld a, (.dmark)  
a159 32 71 ee			ld (debug_mark),a  
a15c 3a 6b a1			ld a, (.dmark+1)  
a15f 32 72 ee			ld (debug_mark+1),a  
a162 3a 6c a1			ld a, (.dmark+2)  
a165 32 73 ee			ld (debug_mark+2),a  
a168 18 03			jr .pastdmark  
a16a ..			.dmark: db "SCN"  
a16d f1			.pastdmark: pop af  
a16e			endm  
# End of macro DMARK
a16e						CALLMONITOR 
a16e cd 7c 93			call break_point_state  
a171				endm  
# End of macro CALLMONITOR
a171					endif 
a171					FORTH_RSP_TOS 
a171 cd 94 99			call macro_forth_rsp_tos 
a174				endm 
# End of macro FORTH_RSP_TOS
a174 e5					push hl 
a175					FORTH_RSP_POP 
a175 cd 9e 99			call macro_forth_rsp_pop 
a178				endm 
# End of macro FORTH_RSP_POP
a178 e1					pop hl 
a179			;		ex de,hl 
a179 22 58 e6				ld (os_tok_ptr),hl 
a17c			 
a17c			if DEBUG_FORTH_UWORD 
a17c						DMARK "SCL" 
a17c f5				push af  
a17d 3a 91 a1			ld a, (.dmark)  
a180 32 71 ee			ld (debug_mark),a  
a183 3a 92 a1			ld a, (.dmark+1)  
a186 32 72 ee			ld (debug_mark+1),a  
a189 3a 93 a1			ld a, (.dmark+2)  
a18c 32 73 ee			ld (debug_mark+2),a  
a18f 18 03			jr .pastdmark  
a191 ..			.dmark: db "SCL"  
a194 f1			.pastdmark: pop af  
a195			endm  
# End of macro DMARK
a195				CALLMONITOR 
a195 cd 7c 93			call break_point_state  
a198				endm  
# End of macro CALLMONITOR
a198			endif 
a198					NEXTW 
a198 c3 3f 9d			jp macro_next 
a19b				endm 
# End of macro NEXTW
a19b			 
a19b			.DROP: 
a19b				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a19b 1b				db WORD_SYS_CORE+OPCODE_DROP             
a19c c6 a1			dw .DUP2            
a19e 05				db 4 + 1 
a19f .. 00			db "DROP",0              
a1a4				endm 
# End of macro CWHEAD
a1a4			; | DROP ( w -- )   drop the TOS item   | DONE 
a1a4					if DEBUG_FORTH_WORDS_KEY 
a1a4						DMARK "DRP" 
a1a4 f5				push af  
a1a5 3a b9 a1			ld a, (.dmark)  
a1a8 32 71 ee			ld (debug_mark),a  
a1ab 3a ba a1			ld a, (.dmark+1)  
a1ae 32 72 ee			ld (debug_mark+1),a  
a1b1 3a bb a1			ld a, (.dmark+2)  
a1b4 32 73 ee			ld (debug_mark+2),a  
a1b7 18 03			jr .pastdmark  
a1b9 ..			.dmark: db "DRP"  
a1bc f1			.pastdmark: pop af  
a1bd			endm  
# End of macro DMARK
a1bd						CALLMONITOR 
a1bd cd 7c 93			call break_point_state  
a1c0				endm  
# End of macro CALLMONITOR
a1c0					endif 
a1c0					FORTH_DSP_POP 
a1c0 cd 85 9c			call macro_forth_dsp_pop 
a1c3				endm 
# End of macro FORTH_DSP_POP
a1c3					NEXTW 
a1c3 c3 3f 9d			jp macro_next 
a1c6				endm 
# End of macro NEXTW
a1c6			.DUP2: 
a1c6				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a1c6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a1c7 0b a2			dw .DROP2            
a1c9 05				db 4 + 1 
a1ca .. 00			db "2DUP",0              
a1cf				endm 
# End of macro CWHEAD
a1cf			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a1cf					if DEBUG_FORTH_WORDS_KEY 
a1cf						DMARK "2DU" 
a1cf f5				push af  
a1d0 3a e4 a1			ld a, (.dmark)  
a1d3 32 71 ee			ld (debug_mark),a  
a1d6 3a e5 a1			ld a, (.dmark+1)  
a1d9 32 72 ee			ld (debug_mark+1),a  
a1dc 3a e6 a1			ld a, (.dmark+2)  
a1df 32 73 ee			ld (debug_mark+2),a  
a1e2 18 03			jr .pastdmark  
a1e4 ..			.dmark: db "2DU"  
a1e7 f1			.pastdmark: pop af  
a1e8			endm  
# End of macro DMARK
a1e8						CALLMONITOR 
a1e8 cd 7c 93			call break_point_state  
a1eb				endm  
# End of macro CALLMONITOR
a1eb					endif 
a1eb					FORTH_DSP_VALUEHL 
a1eb cd cd 9b			call macro_dsp_valuehl 
a1ee				endm 
# End of macro FORTH_DSP_VALUEHL
a1ee e5					push hl      ; 2 
a1ef			 
a1ef					FORTH_DSP_POP 
a1ef cd 85 9c			call macro_forth_dsp_pop 
a1f2				endm 
# End of macro FORTH_DSP_POP
a1f2					 
a1f2					FORTH_DSP_VALUEHL 
a1f2 cd cd 9b			call macro_dsp_valuehl 
a1f5				endm 
# End of macro FORTH_DSP_VALUEHL
a1f5			;		push hl      ; 1 
a1f5			 
a1f5					FORTH_DSP_POP 
a1f5 cd 85 9c			call macro_forth_dsp_pop 
a1f8				endm 
# End of macro FORTH_DSP_POP
a1f8			 
a1f8			;		pop hl       ; 1 
a1f8 d1					pop de       ; 2 
a1f9			 
a1f9 cd d6 99				call forth_push_numhl 
a1fc eb					ex de, hl 
a1fd cd d6 99				call forth_push_numhl 
a200			 
a200					 
a200 eb					ex de, hl 
a201			 
a201 cd d6 99				call forth_push_numhl 
a204 eb					ex de, hl 
a205 cd d6 99				call forth_push_numhl 
a208			 
a208			 
a208					NEXTW 
a208 c3 3f 9d			jp macro_next 
a20b				endm 
# End of macro NEXTW
a20b			.DROP2: 
a20b				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a20b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a20c 3a a2			dw .SWAP2            
a20e 06				db 5 + 1 
a20f .. 00			db "2DROP",0              
a215				endm 
# End of macro CWHEAD
a215			; | 2DROP ( w w -- )    Double drop | DONE 
a215					if DEBUG_FORTH_WORDS_KEY 
a215						DMARK "2DR" 
a215 f5				push af  
a216 3a 2a a2			ld a, (.dmark)  
a219 32 71 ee			ld (debug_mark),a  
a21c 3a 2b a2			ld a, (.dmark+1)  
a21f 32 72 ee			ld (debug_mark+1),a  
a222 3a 2c a2			ld a, (.dmark+2)  
a225 32 73 ee			ld (debug_mark+2),a  
a228 18 03			jr .pastdmark  
a22a ..			.dmark: db "2DR"  
a22d f1			.pastdmark: pop af  
a22e			endm  
# End of macro DMARK
a22e						CALLMONITOR 
a22e cd 7c 93			call break_point_state  
a231				endm  
# End of macro CALLMONITOR
a231					endif 
a231					FORTH_DSP_POP 
a231 cd 85 9c			call macro_forth_dsp_pop 
a234				endm 
# End of macro FORTH_DSP_POP
a234					FORTH_DSP_POP 
a234 cd 85 9c			call macro_forth_dsp_pop 
a237				endm 
# End of macro FORTH_DSP_POP
a237					NEXTW 
a237 c3 3f 9d			jp macro_next 
a23a				endm 
# End of macro NEXTW
a23a			.SWAP2: 
a23a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a23a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a23b 63 a2			dw .AT            
a23d 06				db 5 + 1 
a23e .. 00			db "2SWAP",0              
a244				endm 
# End of macro CWHEAD
a244			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a244					if DEBUG_FORTH_WORDS_KEY 
a244						DMARK "2SW" 
a244 f5				push af  
a245 3a 59 a2			ld a, (.dmark)  
a248 32 71 ee			ld (debug_mark),a  
a24b 3a 5a a2			ld a, (.dmark+1)  
a24e 32 72 ee			ld (debug_mark+1),a  
a251 3a 5b a2			ld a, (.dmark+2)  
a254 32 73 ee			ld (debug_mark+2),a  
a257 18 03			jr .pastdmark  
a259 ..			.dmark: db "2SW"  
a25c f1			.pastdmark: pop af  
a25d			endm  
# End of macro DMARK
a25d						CALLMONITOR 
a25d cd 7c 93			call break_point_state  
a260				endm  
# End of macro CALLMONITOR
a260					endif 
a260					NEXTW 
a260 c3 3f 9d			jp macro_next 
a263				endm 
# End of macro NEXTW
a263			.AT: 
a263				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a263 1f				db WORD_SYS_CORE+OPCODE_AT             
a264 95 a2			dw .CAT            
a266 02				db 1 + 1 
a267 .. 00			db "@",0              
a269				endm 
# End of macro CWHEAD
a269			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a269			 
a269					if DEBUG_FORTH_WORDS_KEY 
a269						DMARK "AT." 
a269 f5				push af  
a26a 3a 7e a2			ld a, (.dmark)  
a26d 32 71 ee			ld (debug_mark),a  
a270 3a 7f a2			ld a, (.dmark+1)  
a273 32 72 ee			ld (debug_mark+1),a  
a276 3a 80 a2			ld a, (.dmark+2)  
a279 32 73 ee			ld (debug_mark+2),a  
a27c 18 03			jr .pastdmark  
a27e ..			.dmark: db "AT."  
a281 f1			.pastdmark: pop af  
a282			endm  
# End of macro DMARK
a282						CALLMONITOR 
a282 cd 7c 93			call break_point_state  
a285				endm  
# End of macro CALLMONITOR
a285					endif 
a285			.getbyteat:	 
a285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a285 cd cd 9b			call macro_dsp_valuehl 
a288				endm 
# End of macro FORTH_DSP_VALUEHL
a288					 
a288			;		push hl 
a288				 
a288					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a288 cd 85 9c			call macro_forth_dsp_pop 
a28b				endm 
# End of macro FORTH_DSP_POP
a28b			 
a28b			;		pop hl 
a28b			 
a28b 7e					ld a, (hl) 
a28c			 
a28c 6f					ld l, a 
a28d 26 00				ld h, 0 
a28f cd d6 99				call forth_push_numhl 
a292			 
a292					NEXTW 
a292 c3 3f 9d			jp macro_next 
a295				endm 
# End of macro NEXTW
a295			.CAT: 
a295				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a295 20				db WORD_SYS_CORE+OPCODE_CAT             
a296 be a2			dw .BANG            
a298 03				db 2 + 1 
a299 .. 00			db "C@",0              
a29c				endm 
# End of macro CWHEAD
a29c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a29c					if DEBUG_FORTH_WORDS_KEY 
a29c						DMARK "CAA" 
a29c f5				push af  
a29d 3a b1 a2			ld a, (.dmark)  
a2a0 32 71 ee			ld (debug_mark),a  
a2a3 3a b2 a2			ld a, (.dmark+1)  
a2a6 32 72 ee			ld (debug_mark+1),a  
a2a9 3a b3 a2			ld a, (.dmark+2)  
a2ac 32 73 ee			ld (debug_mark+2),a  
a2af 18 03			jr .pastdmark  
a2b1 ..			.dmark: db "CAA"  
a2b4 f1			.pastdmark: pop af  
a2b5			endm  
# End of macro DMARK
a2b5						CALLMONITOR 
a2b5 cd 7c 93			call break_point_state  
a2b8				endm  
# End of macro CALLMONITOR
a2b8					endif 
a2b8 c3 85 a2				jp .getbyteat 
a2bb					NEXTW 
a2bb c3 3f 9d			jp macro_next 
a2be				endm 
# End of macro NEXTW
a2be			.BANG: 
a2be				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a2be 21				db WORD_SYS_CORE+OPCODE_BANG             
a2bf f4 a2			dw .CBANG            
a2c1 02				db 1 + 1 
a2c2 .. 00			db "!",0              
a2c4				endm 
# End of macro CWHEAD
a2c4			; | ! ( x w -- ) Store x at address w      | DONE 
a2c4					if DEBUG_FORTH_WORDS_KEY 
a2c4						DMARK "BNG" 
a2c4 f5				push af  
a2c5 3a d9 a2			ld a, (.dmark)  
a2c8 32 71 ee			ld (debug_mark),a  
a2cb 3a da a2			ld a, (.dmark+1)  
a2ce 32 72 ee			ld (debug_mark+1),a  
a2d1 3a db a2			ld a, (.dmark+2)  
a2d4 32 73 ee			ld (debug_mark+2),a  
a2d7 18 03			jr .pastdmark  
a2d9 ..			.dmark: db "BNG"  
a2dc f1			.pastdmark: pop af  
a2dd			endm  
# End of macro DMARK
a2dd						CALLMONITOR 
a2dd cd 7c 93			call break_point_state  
a2e0				endm  
# End of macro CALLMONITOR
a2e0					endif 
a2e0			 
a2e0			.storebyteat:		 
a2e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e0 cd cd 9b			call macro_dsp_valuehl 
a2e3				endm 
# End of macro FORTH_DSP_VALUEHL
a2e3					 
a2e3 e5					push hl 
a2e4				 
a2e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e4 cd 85 9c			call macro_forth_dsp_pop 
a2e7				endm 
# End of macro FORTH_DSP_POP
a2e7			 
a2e7					; get byte to poke 
a2e7			 
a2e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e7 cd cd 9b			call macro_dsp_valuehl 
a2ea				endm 
# End of macro FORTH_DSP_VALUEHL
a2ea e5					push hl 
a2eb			 
a2eb			 
a2eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2eb cd 85 9c			call macro_forth_dsp_pop 
a2ee				endm 
# End of macro FORTH_DSP_POP
a2ee			 
a2ee			 
a2ee d1					pop de 
a2ef e1					pop hl 
a2f0			 
a2f0 73					ld (hl),e 
a2f1			 
a2f1			 
a2f1					NEXTW 
a2f1 c3 3f 9d			jp macro_next 
a2f4				endm 
# End of macro NEXTW
a2f4			.CBANG: 
a2f4				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a2f4 22				db WORD_SYS_CORE+OPCODE_CBANG             
a2f5 1d a3			dw .SCALL            
a2f7 03				db 2 + 1 
a2f8 .. 00			db "C!",0              
a2fb				endm 
# End of macro CWHEAD
a2fb			; | C!  ( x w -- ) Store x at address w  | DONE 
a2fb					if DEBUG_FORTH_WORDS_KEY 
a2fb						DMARK "CBA" 
a2fb f5				push af  
a2fc 3a 10 a3			ld a, (.dmark)  
a2ff 32 71 ee			ld (debug_mark),a  
a302 3a 11 a3			ld a, (.dmark+1)  
a305 32 72 ee			ld (debug_mark+1),a  
a308 3a 12 a3			ld a, (.dmark+2)  
a30b 32 73 ee			ld (debug_mark+2),a  
a30e 18 03			jr .pastdmark  
a310 ..			.dmark: db "CBA"  
a313 f1			.pastdmark: pop af  
a314			endm  
# End of macro DMARK
a314						CALLMONITOR 
a314 cd 7c 93			call break_point_state  
a317				endm  
# End of macro CALLMONITOR
a317					endif 
a317 c3 e0 a2				jp .storebyteat 
a31a					NEXTW 
a31a c3 3f 9d			jp macro_next 
a31d				endm 
# End of macro NEXTW
a31d			.SCALL: 
a31d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a31d 23				db WORD_SYS_CORE+OPCODE_SCALL             
a31e 51 a3			dw .DEPTH            
a320 05				db 4 + 1 
a321 .. 00			db "CALL",0              
a326				endm 
# End of macro CWHEAD
a326			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a326					if DEBUG_FORTH_WORDS_KEY 
a326						DMARK "CLL" 
a326 f5				push af  
a327 3a 3b a3			ld a, (.dmark)  
a32a 32 71 ee			ld (debug_mark),a  
a32d 3a 3c a3			ld a, (.dmark+1)  
a330 32 72 ee			ld (debug_mark+1),a  
a333 3a 3d a3			ld a, (.dmark+2)  
a336 32 73 ee			ld (debug_mark+2),a  
a339 18 03			jr .pastdmark  
a33b ..			.dmark: db "CLL"  
a33e f1			.pastdmark: pop af  
a33f			endm  
# End of macro DMARK
a33f						CALLMONITOR 
a33f cd 7c 93			call break_point_state  
a342				endm  
# End of macro CALLMONITOR
a342					endif 
a342			 
a342					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a342 cd cd 9b			call macro_dsp_valuehl 
a345				endm 
# End of macro FORTH_DSP_VALUEHL
a345			 
a345			;		push hl 
a345			 
a345					; destroy value TOS 
a345			 
a345					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a345 cd 85 9c			call macro_forth_dsp_pop 
a348				endm 
# End of macro FORTH_DSP_POP
a348			 
a348						 
a348			;		pop hl 
a348			 
a348					; how to do a call with hl???? save SP? 
a348 cd e8 9c				call forth_call_hl 
a34b			 
a34b			 
a34b					; TODO push value back onto stack for another op etc 
a34b			 
a34b cd d6 99				call forth_push_numhl 
a34e					NEXTW 
a34e c3 3f 9d			jp macro_next 
a351				endm 
# End of macro NEXTW
a351			.DEPTH: 
a351				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a351 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a352 8e a3			dw .OVER            
a354 06				db 5 + 1 
a355 .. 00			db "DEPTH",0              
a35b				endm 
# End of macro CWHEAD
a35b			; | DEPTH ( -- u ) Push count of stack | DONE 
a35b					; take current TOS and remove from base value div by two to get count 
a35b					if DEBUG_FORTH_WORDS_KEY 
a35b						DMARK "DEP" 
a35b f5				push af  
a35c 3a 70 a3			ld a, (.dmark)  
a35f 32 71 ee			ld (debug_mark),a  
a362 3a 71 a3			ld a, (.dmark+1)  
a365 32 72 ee			ld (debug_mark+1),a  
a368 3a 72 a3			ld a, (.dmark+2)  
a36b 32 73 ee			ld (debug_mark+2),a  
a36e 18 03			jr .pastdmark  
a370 ..			.dmark: db "DEP"  
a373 f1			.pastdmark: pop af  
a374			endm  
# End of macro DMARK
a374						CALLMONITOR 
a374 cd 7c 93			call break_point_state  
a377				endm  
# End of macro CALLMONITOR
a377					endif 
a377			 
a377			 
a377 2a 04 eb			ld hl, (cli_data_sp) 
a37a 11 be e8			ld de, cli_data_stack 
a37d ed 52			sbc hl,de 
a37f				 
a37f				; div by size of stack item 
a37f			 
a37f 5d				ld e,l 
a380 0e 03			ld c, 3 
a382 cd 0b 8b			call Div8 
a385			 
a385 6f				ld l,a 
a386 26 00			ld h,0 
a388			 
a388				;srl h 
a388				;rr l 
a388			 
a388 cd d6 99				call forth_push_numhl 
a38b					NEXTW 
a38b c3 3f 9d			jp macro_next 
a38e				endm 
# End of macro NEXTW
a38e			.OVER: 
a38e				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a38e 42				db WORD_SYS_CORE+46             
a38f d5 a3			dw .PAUSE            
a391 05				db 4 + 1 
a392 .. 00			db "OVER",0              
a397				endm 
# End of macro CWHEAD
a397			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a397					if DEBUG_FORTH_WORDS_KEY 
a397						DMARK "OVR" 
a397 f5				push af  
a398 3a ac a3			ld a, (.dmark)  
a39b 32 71 ee			ld (debug_mark),a  
a39e 3a ad a3			ld a, (.dmark+1)  
a3a1 32 72 ee			ld (debug_mark+1),a  
a3a4 3a ae a3			ld a, (.dmark+2)  
a3a7 32 73 ee			ld (debug_mark+2),a  
a3aa 18 03			jr .pastdmark  
a3ac ..			.dmark: db "OVR"  
a3af f1			.pastdmark: pop af  
a3b0			endm  
# End of macro DMARK
a3b0						CALLMONITOR 
a3b0 cd 7c 93			call break_point_state  
a3b3				endm  
# End of macro CALLMONITOR
a3b3					endif 
a3b3			 
a3b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3b3 cd cd 9b			call macro_dsp_valuehl 
a3b6				endm 
# End of macro FORTH_DSP_VALUEHL
a3b6 e5					push hl    ; n2 
a3b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3b7 cd 85 9c			call macro_forth_dsp_pop 
a3ba				endm 
# End of macro FORTH_DSP_POP
a3ba			 
a3ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3ba cd cd 9b			call macro_dsp_valuehl 
a3bd				endm 
# End of macro FORTH_DSP_VALUEHL
a3bd e5					push hl    ; n1 
a3be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3be cd 85 9c			call macro_forth_dsp_pop 
a3c1				endm 
# End of macro FORTH_DSP_POP
a3c1			 
a3c1 d1					pop de     ; n1 
a3c2 e1					pop hl     ; n2 
a3c3			 
a3c3 d5					push de 
a3c4 e5					push hl 
a3c5 d5					push de 
a3c6			 
a3c6					; push back  
a3c6			 
a3c6 e1					pop hl 
a3c7 cd d6 99				call forth_push_numhl 
a3ca e1					pop hl 
a3cb cd d6 99				call forth_push_numhl 
a3ce e1					pop hl 
a3cf cd d6 99				call forth_push_numhl 
a3d2					NEXTW 
a3d2 c3 3f 9d			jp macro_next 
a3d5				endm 
# End of macro NEXTW
a3d5			 
a3d5			.PAUSE: 
a3d5				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a3d5 43				db WORD_SYS_CORE+47             
a3d6 0a a4			dw .PAUSES            
a3d8 08				db 7 + 1 
a3d9 .. 00			db "PAUSEMS",0              
a3e1				endm 
# End of macro CWHEAD
a3e1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a3e1					if DEBUG_FORTH_WORDS_KEY 
a3e1						DMARK "PMS" 
a3e1 f5				push af  
a3e2 3a f6 a3			ld a, (.dmark)  
a3e5 32 71 ee			ld (debug_mark),a  
a3e8 3a f7 a3			ld a, (.dmark+1)  
a3eb 32 72 ee			ld (debug_mark+1),a  
a3ee 3a f8 a3			ld a, (.dmark+2)  
a3f1 32 73 ee			ld (debug_mark+2),a  
a3f4 18 03			jr .pastdmark  
a3f6 ..			.dmark: db "PMS"  
a3f9 f1			.pastdmark: pop af  
a3fa			endm  
# End of macro DMARK
a3fa						CALLMONITOR 
a3fa cd 7c 93			call break_point_state  
a3fd				endm  
# End of macro CALLMONITOR
a3fd					endif 
a3fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3fd cd cd 9b			call macro_dsp_valuehl 
a400				endm 
# End of macro FORTH_DSP_VALUEHL
a400			;		push hl    ; n2 
a400					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a400 cd 85 9c			call macro_forth_dsp_pop 
a403				endm 
# End of macro FORTH_DSP_POP
a403			;		pop hl 
a403			 
a403 7d					ld a, l 
a404 cd b0 88				call aDelayInMS 
a407				       NEXTW 
a407 c3 3f 9d			jp macro_next 
a40a				endm 
# End of macro NEXTW
a40a			.PAUSES:  
a40a				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a40a 44				db WORD_SYS_CORE+48             
a40b 79 a4			dw .ROT            
a40d 06				db 5 + 1 
a40e .. 00			db "PAUSE",0              
a414				endm 
# End of macro CWHEAD
a414			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a414					if DEBUG_FORTH_WORDS_KEY 
a414						DMARK "PAU" 
a414 f5				push af  
a415 3a 29 a4			ld a, (.dmark)  
a418 32 71 ee			ld (debug_mark),a  
a41b 3a 2a a4			ld a, (.dmark+1)  
a41e 32 72 ee			ld (debug_mark+1),a  
a421 3a 2b a4			ld a, (.dmark+2)  
a424 32 73 ee			ld (debug_mark+2),a  
a427 18 03			jr .pastdmark  
a429 ..			.dmark: db "PAU"  
a42c f1			.pastdmark: pop af  
a42d			endm  
# End of macro DMARK
a42d						CALLMONITOR 
a42d cd 7c 93			call break_point_state  
a430				endm  
# End of macro CALLMONITOR
a430					endif 
a430					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a430 cd cd 9b			call macro_dsp_valuehl 
a433				endm 
# End of macro FORTH_DSP_VALUEHL
a433			;		push hl    ; n2 
a433					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a433 cd 85 9c			call macro_forth_dsp_pop 
a436				endm 
# End of macro FORTH_DSP_POP
a436			;		pop hl 
a436 45					ld b, l 
a437					if DEBUG_FORTH_WORDS 
a437						DMARK "PAU" 
a437 f5				push af  
a438 3a 4c a4			ld a, (.dmark)  
a43b 32 71 ee			ld (debug_mark),a  
a43e 3a 4d a4			ld a, (.dmark+1)  
a441 32 72 ee			ld (debug_mark+1),a  
a444 3a 4e a4			ld a, (.dmark+2)  
a447 32 73 ee			ld (debug_mark+2),a  
a44a 18 03			jr .pastdmark  
a44c ..			.dmark: db "PAU"  
a44f f1			.pastdmark: pop af  
a450			endm  
# End of macro DMARK
a450						CALLMONITOR 
a450 cd 7c 93			call break_point_state  
a453				endm  
# End of macro CALLMONITOR
a453					endif 
a453 c5			.pauses1:	push bc 
a454 cd cb 88				call delay1s 
a457 c1					pop bc 
a458					if DEBUG_FORTH_WORDS 
a458						DMARK "PA1" 
a458 f5				push af  
a459 3a 6d a4			ld a, (.dmark)  
a45c 32 71 ee			ld (debug_mark),a  
a45f 3a 6e a4			ld a, (.dmark+1)  
a462 32 72 ee			ld (debug_mark+1),a  
a465 3a 6f a4			ld a, (.dmark+2)  
a468 32 73 ee			ld (debug_mark+2),a  
a46b 18 03			jr .pastdmark  
a46d ..			.dmark: db "PA1"  
a470 f1			.pastdmark: pop af  
a471			endm  
# End of macro DMARK
a471						CALLMONITOR 
a471 cd 7c 93			call break_point_state  
a474				endm  
# End of macro CALLMONITOR
a474					endif 
a474 10 dd				djnz .pauses1 
a476			 
a476				       NEXTW 
a476 c3 3f 9d			jp macro_next 
a479				endm 
# End of macro NEXTW
a479			.ROT: 
a479				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a479 45				db WORD_SYS_CORE+49             
a47a c7 a4			dw .UWORDS            
a47c 04				db 3 + 1 
a47d .. 00			db "ROT",0              
a481				endm 
# End of macro CWHEAD
a481			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a481					if DEBUG_FORTH_WORDS_KEY 
a481						DMARK "ROT" 
a481 f5				push af  
a482 3a 96 a4			ld a, (.dmark)  
a485 32 71 ee			ld (debug_mark),a  
a488 3a 97 a4			ld a, (.dmark+1)  
a48b 32 72 ee			ld (debug_mark+1),a  
a48e 3a 98 a4			ld a, (.dmark+2)  
a491 32 73 ee			ld (debug_mark+2),a  
a494 18 03			jr .pastdmark  
a496 ..			.dmark: db "ROT"  
a499 f1			.pastdmark: pop af  
a49a			endm  
# End of macro DMARK
a49a						CALLMONITOR 
a49a cd 7c 93			call break_point_state  
a49d				endm  
# End of macro CALLMONITOR
a49d					endif 
a49d			 
a49d					FORTH_DSP_VALUEHL 
a49d cd cd 9b			call macro_dsp_valuehl 
a4a0				endm 
# End of macro FORTH_DSP_VALUEHL
a4a0 e5					push hl    ; u3  
a4a1			 
a4a1					FORTH_DSP_POP 
a4a1 cd 85 9c			call macro_forth_dsp_pop 
a4a4				endm 
# End of macro FORTH_DSP_POP
a4a4			   
a4a4					FORTH_DSP_VALUEHL 
a4a4 cd cd 9b			call macro_dsp_valuehl 
a4a7				endm 
# End of macro FORTH_DSP_VALUEHL
a4a7 e5					push hl     ; u2 
a4a8			 
a4a8					FORTH_DSP_POP 
a4a8 cd 85 9c			call macro_forth_dsp_pop 
a4ab				endm 
# End of macro FORTH_DSP_POP
a4ab			 
a4ab					FORTH_DSP_VALUEHL 
a4ab cd cd 9b			call macro_dsp_valuehl 
a4ae				endm 
# End of macro FORTH_DSP_VALUEHL
a4ae e5					push hl     ; u1 
a4af			 
a4af					FORTH_DSP_POP 
a4af cd 85 9c			call macro_forth_dsp_pop 
a4b2				endm 
# End of macro FORTH_DSP_POP
a4b2			 
a4b2 c1					pop bc      ; u1 
a4b3 e1					pop hl      ; u2 
a4b4 d1					pop de      ; u3 
a4b5			 
a4b5			 
a4b5 c5					push bc 
a4b6 d5					push de 
a4b7 e5					push hl 
a4b8			 
a4b8			 
a4b8 e1					pop hl 
a4b9 cd d6 99				call forth_push_numhl 
a4bc			 
a4bc e1					pop hl 
a4bd cd d6 99				call forth_push_numhl 
a4c0			 
a4c0 e1					pop hl 
a4c1 cd d6 99				call forth_push_numhl 
a4c4					 
a4c4			 
a4c4			 
a4c4			 
a4c4			 
a4c4			 
a4c4				       NEXTW 
a4c4 c3 3f 9d			jp macro_next 
a4c7				endm 
# End of macro NEXTW
a4c7			 
a4c7			.UWORDS: 
a4c7				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a4c7 50				db WORD_SYS_CORE+60             
a4c8 89 a5			dw .BP            
a4ca 07				db 6 + 1 
a4cb .. 00			db "UWORDS",0              
a4d2				endm 
# End of macro CWHEAD
a4d2			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a4d2			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a4d2			; | | Following the count are the individual words. 
a4d2			; | | 
a4d2			; | | e.g. UWORDS 
a4d2			; | | BOX DIRLIST 2 
a4d2			; | |  
a4d2			; | | Can be used to save the words to storage via: 
a4d2			; | | UWORDS $01 DO $01 APPEND LOOP 
a4d2				if DEBUG_FORTH_WORDS_KEY 
a4d2					DMARK "UWR" 
a4d2 f5				push af  
a4d3 3a e7 a4			ld a, (.dmark)  
a4d6 32 71 ee			ld (debug_mark),a  
a4d9 3a e8 a4			ld a, (.dmark+1)  
a4dc 32 72 ee			ld (debug_mark+1),a  
a4df 3a e9 a4			ld a, (.dmark+2)  
a4e2 32 73 ee			ld (debug_mark+2),a  
a4e5 18 03			jr .pastdmark  
a4e7 ..			.dmark: db "UWR"  
a4ea f1			.pastdmark: pop af  
a4eb			endm  
# End of macro DMARK
a4eb					CALLMONITOR 
a4eb cd 7c 93			call break_point_state  
a4ee				endm  
# End of macro CALLMONITOR
a4ee				endif 
a4ee 21 eb d8				ld hl, baseram 
a4f1					;ld hl, baseusermem 
a4f1 01 00 00				ld bc, 0    ; start a counter 
a4f4			 
a4f4				; skip dict stub 
a4f4			 
a4f4 cd 90 9e				call forth_tok_next 
a4f7			 
a4f7			 
a4f7			; while we have words to look for 
a4f7			 
a4f7 7e			.douscan:	ld a, (hl)      
a4f8				if DEBUG_FORTH_WORDS 
a4f8					DMARK "UWs" 
a4f8 f5				push af  
a4f9 3a 0d a5			ld a, (.dmark)  
a4fc 32 71 ee			ld (debug_mark),a  
a4ff 3a 0e a5			ld a, (.dmark+1)  
a502 32 72 ee			ld (debug_mark+1),a  
a505 3a 0f a5			ld a, (.dmark+2)  
a508 32 73 ee			ld (debug_mark+2),a  
a50b 18 03			jr .pastdmark  
a50d ..			.dmark: db "UWs"  
a510 f1			.pastdmark: pop af  
a511			endm  
# End of macro DMARK
a511					CALLMONITOR 
a511 cd 7c 93			call break_point_state  
a514				endm  
# End of macro CALLMONITOR
a514				endif 
a514 fe 00				cp WORD_SYS_END 
a516 28 4d				jr z, .udone 
a518 fe 01				cp WORD_SYS_UWORD 
a51a 20 44				jr nz, .nuword 
a51c			 
a51c				if DEBUG_FORTH_WORDS 
a51c					DMARK "UWu" 
a51c f5				push af  
a51d 3a 31 a5			ld a, (.dmark)  
a520 32 71 ee			ld (debug_mark),a  
a523 3a 32 a5			ld a, (.dmark+1)  
a526 32 72 ee			ld (debug_mark+1),a  
a529 3a 33 a5			ld a, (.dmark+2)  
a52c 32 73 ee			ld (debug_mark+2),a  
a52f 18 03			jr .pastdmark  
a531 ..			.dmark: db "UWu"  
a534 f1			.pastdmark: pop af  
a535			endm  
# End of macro DMARK
a535					CALLMONITOR 
a535 cd 7c 93			call break_point_state  
a538				endm  
# End of macro CALLMONITOR
a538				endif 
a538					; we have a uword so push its name to the stack 
a538			 
a538 e5				   	push hl  ; save so we can move to next dict block 
a539			 
a539					; skip opcode 
a539 23					inc hl  
a53a					; skip next ptr 
a53a 23					inc hl  
a53b 23					inc hl 
a53c					; skip len 
a53c 23					inc hl 
a53d				if DEBUG_FORTH_WORDS 
a53d					DMARK "UWt" 
a53d f5				push af  
a53e 3a 52 a5			ld a, (.dmark)  
a541 32 71 ee			ld (debug_mark),a  
a544 3a 53 a5			ld a, (.dmark+1)  
a547 32 72 ee			ld (debug_mark+1),a  
a54a 3a 54 a5			ld a, (.dmark+2)  
a54d 32 73 ee			ld (debug_mark+2),a  
a550 18 03			jr .pastdmark  
a552 ..			.dmark: db "UWt"  
a555 f1			.pastdmark: pop af  
a556			endm  
# End of macro DMARK
a556					CALLMONITOR 
a556 cd 7c 93			call break_point_state  
a559				endm  
# End of macro CALLMONITOR
a559				endif 
a559 03					inc bc 
a55a			 
a55a c5					push bc 
a55b cd 44 9a				call forth_push_str 
a55e c1					pop bc 
a55f			 
a55f e1					pop hl 	 
a560			 
a560 cd 90 9e		.nuword:	call forth_tok_next 
a563 18 92				jr .douscan  
a565			 
a565			.udone:		 ; push count of uwords found 
a565 c5					push bc 
a566 e1					pop hl 
a567			 
a567				if DEBUG_FORTH_WORDS 
a567					DMARK "UWc" 
a567 f5				push af  
a568 3a 7c a5			ld a, (.dmark)  
a56b 32 71 ee			ld (debug_mark),a  
a56e 3a 7d a5			ld a, (.dmark+1)  
a571 32 72 ee			ld (debug_mark+1),a  
a574 3a 7e a5			ld a, (.dmark+2)  
a577 32 73 ee			ld (debug_mark+2),a  
a57a 18 03			jr .pastdmark  
a57c ..			.dmark: db "UWc"  
a57f f1			.pastdmark: pop af  
a580			endm  
# End of macro DMARK
a580					CALLMONITOR 
a580 cd 7c 93			call break_point_state  
a583				endm  
# End of macro CALLMONITOR
a583				endif 
a583 cd d6 99				call forth_push_numhl 
a586			 
a586			 
a586				       NEXTW 
a586 c3 3f 9d			jp macro_next 
a589				endm 
# End of macro NEXTW
a589			 
a589			.BP: 
a589				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a589 54				db WORD_SYS_CORE+64             
a58a bf a5			dw .MONITOR            
a58c 03				db 2 + 1 
a58d .. 00			db "BP",0              
a590				endm 
# End of macro CWHEAD
a590			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a590			; | | $00 Will enable the break points within specific code paths 
a590			; | | $01 Will disable break points 
a590			; | |  
a590			; | | By default break points are off. Either the above can be used to enable them 
a590			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a590			; | | and on release of the pressed key a message will be disaplayed to notify 
a590			; | | that break points are enabled. Pressing any key will then continue boot process. 
a590					; get byte count 
a590					if DEBUG_FORTH_WORDS_KEY 
a590						DMARK "BP." 
a590 f5				push af  
a591 3a a5 a5			ld a, (.dmark)  
a594 32 71 ee			ld (debug_mark),a  
a597 3a a6 a5			ld a, (.dmark+1)  
a59a 32 72 ee			ld (debug_mark+1),a  
a59d 3a a7 a5			ld a, (.dmark+2)  
a5a0 32 73 ee			ld (debug_mark+2),a  
a5a3 18 03			jr .pastdmark  
a5a5 ..			.dmark: db "BP."  
a5a8 f1			.pastdmark: pop af  
a5a9			endm  
# End of macro DMARK
a5a9						CALLMONITOR 
a5a9 cd 7c 93			call break_point_state  
a5ac				endm  
# End of macro CALLMONITOR
a5ac					endif 
a5ac			 
a5ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5ac cd cd 9b			call macro_dsp_valuehl 
a5af				endm 
# End of macro FORTH_DSP_VALUEHL
a5af			 
a5af			;		push hl 
a5af			 
a5af					; destroy value TOS 
a5af			 
a5af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5af cd 85 9c			call macro_forth_dsp_pop 
a5b2				endm 
# End of macro FORTH_DSP_POP
a5b2			 
a5b2			;		pop hl 
a5b2			 
a5b2 3e 00				ld a,0 
a5b4 bd					cp l 
a5b5 28 02				jr z, .bpset 
a5b7 3e 2a				ld a, '*' 
a5b9			 
a5b9 32 48 e3		.bpset:		ld (os_view_disable), a 
a5bc			 
a5bc			 
a5bc					NEXTW 
a5bc c3 3f 9d			jp macro_next 
a5bf				endm 
# End of macro NEXTW
a5bf			 
a5bf			 
a5bf			.MONITOR: 
a5bf				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a5bf 55				db WORD_SYS_CORE+65             
a5c0 f2 a5			dw .MALLOC            
a5c2 08				db 7 + 1 
a5c3 .. 00			db "MONITOR",0              
a5cb				endm 
# End of macro CWHEAD
a5cb			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a5cb			; | | At start the current various registers will be displayed with contents. 
a5cb			; | | Top right corner will show the most recent debug marker seen. 
a5cb			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a5cb			; | | and the return stack pointer (RSP). 
a5cb			; | | Pressing: 
a5cb			; | |    1 - Initial screen 
a5cb			; | |    2 - Display a data dump of HL 
a5cb			; | |    3 - Display a data dump of DE 
a5cb			; | |    4 - Display a data dump of BC 
a5cb			; | |    5 - Display a data dump of HL 
a5cb			; | |    6 - Display a data dump of DSP 
a5cb			; | |    7 - Display a data dump of RSP 
a5cb			; | |    8 - Display a data dump of what is at DSP 
a5cb			; | |    9 - Display a data dump of what is at RSP 
a5cb			; | |    0 - Exit monitor and continue running. This will also enable break points 
a5cb			; | |    * - Disable break points 
a5cb			; | |    # - Enter traditional monitor mode 
a5cb			; | | 
a5cb			; | | Monitor Mode 
a5cb			; | | ------------ 
a5cb			; | | A prompt of '>' will be shown for various commands: 
a5cb			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a5cb			; | |    C - Continue display a data dump from the last set address 
a5cb			; | |    M xxxx - Set start of memory edit at address xx 
a5cb			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a5cb			; | |    Q - Return to previous 
a5cb					if DEBUG_FORTH_WORDS_KEY 
a5cb						DMARK "MON" 
a5cb f5				push af  
a5cc 3a e0 a5			ld a, (.dmark)  
a5cf 32 71 ee			ld (debug_mark),a  
a5d2 3a e1 a5			ld a, (.dmark+1)  
a5d5 32 72 ee			ld (debug_mark+1),a  
a5d8 3a e2 a5			ld a, (.dmark+2)  
a5db 32 73 ee			ld (debug_mark+2),a  
a5de 18 03			jr .pastdmark  
a5e0 ..			.dmark: db "MON"  
a5e3 f1			.pastdmark: pop af  
a5e4			endm  
# End of macro DMARK
a5e4						CALLMONITOR 
a5e4 cd 7c 93			call break_point_state  
a5e7				endm  
# End of macro CALLMONITOR
a5e7					endif 
a5e7 3e 00				ld a, 0 
a5e9 32 48 e3				ld (os_view_disable), a 
a5ec			 
a5ec					CALLMONITOR 
a5ec cd 7c 93			call break_point_state  
a5ef				endm  
# End of macro CALLMONITOR
a5ef			 
a5ef			;	call monitor 
a5ef			 
a5ef					NEXTW 
a5ef c3 3f 9d			jp macro_next 
a5f2				endm 
# End of macro NEXTW
a5f2			 
a5f2			 
a5f2			.MALLOC: 
a5f2				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a5f2 56				db WORD_SYS_CORE+66             
a5f3 1b a6			dw .MALLOC2            
a5f5 06				db 5 + 1 
a5f6 .. 00			db "ALLOT",0              
a5fc				endm 
# End of macro CWHEAD
a5fc			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a5fc					if DEBUG_FORTH_WORDS_KEY 
a5fc						DMARK "ALL" 
a5fc f5				push af  
a5fd 3a 11 a6			ld a, (.dmark)  
a600 32 71 ee			ld (debug_mark),a  
a603 3a 12 a6			ld a, (.dmark+1)  
a606 32 72 ee			ld (debug_mark+1),a  
a609 3a 13 a6			ld a, (.dmark+2)  
a60c 32 73 ee			ld (debug_mark+2),a  
a60f 18 03			jr .pastdmark  
a611 ..			.dmark: db "ALL"  
a614 f1			.pastdmark: pop af  
a615			endm  
# End of macro DMARK
a615						CALLMONITOR 
a615 cd 7c 93			call break_point_state  
a618				endm  
# End of macro CALLMONITOR
a618					endif 
a618 c3 42 a6				jp .mallocc 
a61b			.MALLOC2: 
a61b				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a61b 56				db WORD_SYS_CORE+66             
a61c 59 a6			dw .FREE            
a61e 07				db 6 + 1 
a61f .. 00			db "MALLOC",0              
a626				endm 
# End of macro CWHEAD
a626			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a626					; get byte count 
a626					if DEBUG_FORTH_WORDS_KEY 
a626						DMARK "MAL" 
a626 f5				push af  
a627 3a 3b a6			ld a, (.dmark)  
a62a 32 71 ee			ld (debug_mark),a  
a62d 3a 3c a6			ld a, (.dmark+1)  
a630 32 72 ee			ld (debug_mark+1),a  
a633 3a 3d a6			ld a, (.dmark+2)  
a636 32 73 ee			ld (debug_mark+2),a  
a639 18 03			jr .pastdmark  
a63b ..			.dmark: db "MAL"  
a63e f1			.pastdmark: pop af  
a63f			endm  
# End of macro DMARK
a63f						CALLMONITOR 
a63f cd 7c 93			call break_point_state  
a642				endm  
# End of macro CALLMONITOR
a642					endif 
a642			.mallocc: 
a642					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a642 cd cd 9b			call macro_dsp_valuehl 
a645				endm 
# End of macro FORTH_DSP_VALUEHL
a645			 
a645			;		push hl 
a645			 
a645					; destroy value TOS 
a645			 
a645					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a645 cd 85 9c			call macro_forth_dsp_pop 
a648				endm 
# End of macro FORTH_DSP_POP
a648			 
a648			;		pop hl 
a648 cd 42 90				call malloc 
a64b				if DEBUG_FORTH_MALLOC_GUARD 
a64b f5					push af 
a64c cd a4 8b				call ishlzero 
a64f			;		ld a, l 
a64f			;		add h 
a64f			;		cp 0 
a64f f1					pop af 
a650					 
a650 cc 71 c5				call z,malloc_error 
a653				endif 
a653			 
a653 cd d6 99				call forth_push_numhl 
a656					NEXTW 
a656 c3 3f 9d			jp macro_next 
a659				endm 
# End of macro NEXTW
a659			 
a659			.FREE: 
a659				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a659 57				db WORD_SYS_CORE+67             
a65a 8a a6			dw .LIST            
a65c 05				db 4 + 1 
a65d .. 00			db "FREE",0              
a662				endm 
# End of macro CWHEAD
a662			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a662					if DEBUG_FORTH_WORDS_KEY 
a662						DMARK "FRE" 
a662 f5				push af  
a663 3a 77 a6			ld a, (.dmark)  
a666 32 71 ee			ld (debug_mark),a  
a669 3a 78 a6			ld a, (.dmark+1)  
a66c 32 72 ee			ld (debug_mark+1),a  
a66f 3a 79 a6			ld a, (.dmark+2)  
a672 32 73 ee			ld (debug_mark+2),a  
a675 18 03			jr .pastdmark  
a677 ..			.dmark: db "FRE"  
a67a f1			.pastdmark: pop af  
a67b			endm  
# End of macro DMARK
a67b						CALLMONITOR 
a67b cd 7c 93			call break_point_state  
a67e				endm  
# End of macro CALLMONITOR
a67e					endif 
a67e					; get address 
a67e			 
a67e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a67e cd cd 9b			call macro_dsp_valuehl 
a681				endm 
# End of macro FORTH_DSP_VALUEHL
a681			 
a681			;		push hl 
a681			 
a681					; destroy value TOS 
a681			 
a681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a681 cd 85 9c			call macro_forth_dsp_pop 
a684				endm 
# End of macro FORTH_DSP_POP
a684			 
a684			;		pop hl 
a684			if FORTH_ENABLE_MALLOCFREE 
a684 cd 0c 91				call free 
a687			endif 
a687					NEXTW 
a687 c3 3f 9d			jp macro_next 
a68a				endm 
# End of macro NEXTW
a68a			.LIST: 
a68a				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a68a 5c				db WORD_SYS_CORE+72             
a68b 78 a8			dw .FORGET            
a68d 05				db 4 + 1 
a68e .. 00			db "LIST",0              
a693				endm 
# End of macro CWHEAD
a693			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a693			; | | The quoted word must be in upper case. 
a693				if DEBUG_FORTH_WORDS_KEY 
a693					DMARK "LST" 
a693 f5				push af  
a694 3a a8 a6			ld a, (.dmark)  
a697 32 71 ee			ld (debug_mark),a  
a69a 3a a9 a6			ld a, (.dmark+1)  
a69d 32 72 ee			ld (debug_mark+1),a  
a6a0 3a aa a6			ld a, (.dmark+2)  
a6a3 32 73 ee			ld (debug_mark+2),a  
a6a6 18 03			jr .pastdmark  
a6a8 ..			.dmark: db "LST"  
a6ab f1			.pastdmark: pop af  
a6ac			endm  
# End of macro DMARK
a6ac					CALLMONITOR 
a6ac cd 7c 93			call break_point_state  
a6af				endm  
# End of macro CALLMONITOR
a6af				endif 
a6af			 
a6af					FORTH_DSP_VALUEHL 
a6af cd cd 9b			call macro_dsp_valuehl 
a6b2				endm 
# End of macro FORTH_DSP_VALUEHL
a6b2			 
a6b2 e5					push hl 
a6b3					FORTH_DSP_POP 
a6b3 cd 85 9c			call macro_forth_dsp_pop 
a6b6				endm 
# End of macro FORTH_DSP_POP
a6b6 c1					pop bc 
a6b7			 
a6b7			; Start format of scratch string 
a6b7			 
a6b7 21 57 e3				ld hl, scratch 
a6ba			 
a6ba 3e 3a				ld a, ':' 
a6bc 77					ld (hl),a 
a6bd 23					inc hl 
a6be 3e 20				ld a, ' ' 
a6c0 77					ld (hl), a 
a6c1			 
a6c1					; Get ptr to the word we need to look up 
a6c1			 
a6c1			;		FORTH_DSP_VALUEHL 
a6c1					;v5 FORTH_DSP_VALUE 
a6c1				; TODO type check 
a6c1			;		inc hl    ; Skip type check  
a6c1			;		push hl 
a6c1			;		ex de, hl    ; put into DE 
a6c1			 
a6c1			 
a6c1 21 eb d8				ld hl, baseram 
a6c4					;ld hl, baseusermem 
a6c4			 
a6c4 e5			push hl   ; sacreifical push 
a6c5			 
a6c5			.ldouscanm: 
a6c5 e1				pop hl 
a6c6			.ldouscan: 
a6c6				if DEBUG_FORTH_WORDS 
a6c6					DMARK "LSs" 
a6c6 f5				push af  
a6c7 3a db a6			ld a, (.dmark)  
a6ca 32 71 ee			ld (debug_mark),a  
a6cd 3a dc a6			ld a, (.dmark+1)  
a6d0 32 72 ee			ld (debug_mark+1),a  
a6d3 3a dd a6			ld a, (.dmark+2)  
a6d6 32 73 ee			ld (debug_mark+2),a  
a6d9 18 03			jr .pastdmark  
a6db ..			.dmark: db "LSs"  
a6de f1			.pastdmark: pop af  
a6df			endm  
# End of macro DMARK
a6df					CALLMONITOR 
a6df cd 7c 93			call break_point_state  
a6e2				endm  
# End of macro CALLMONITOR
a6e2				endif 
a6e2				; skip dict stub 
a6e2 cd 90 9e				call forth_tok_next 
a6e5			 
a6e5			 
a6e5			; while we have words to look for 
a6e5			 
a6e5 7e				ld a, (hl)      
a6e6				if DEBUG_FORTH_WORDS 
a6e6					DMARK "LSk" 
a6e6 f5				push af  
a6e7 3a fb a6			ld a, (.dmark)  
a6ea 32 71 ee			ld (debug_mark),a  
a6ed 3a fc a6			ld a, (.dmark+1)  
a6f0 32 72 ee			ld (debug_mark+1),a  
a6f3 3a fd a6			ld a, (.dmark+2)  
a6f6 32 73 ee			ld (debug_mark+2),a  
a6f9 18 03			jr .pastdmark  
a6fb ..			.dmark: db "LSk"  
a6fe f1			.pastdmark: pop af  
a6ff			endm  
# End of macro DMARK
a6ff					CALLMONITOR 
a6ff cd 7c 93			call break_point_state  
a702				endm  
# End of macro CALLMONITOR
a702				endif 
a702					;cp WORD_SYS_END 
a702					;jp z, .lunotfound 
a702			 
a702					; if we hit non uwords then gone too far 
a702 fe 01				cp WORD_SYS_UWORD 
a704 c2 34 a8				jp nz, .lunotfound 
a707			 
a707				if DEBUG_FORTH_WORDS 
a707					DMARK "LSu" 
a707 f5				push af  
a708 3a 1c a7			ld a, (.dmark)  
a70b 32 71 ee			ld (debug_mark),a  
a70e 3a 1d a7			ld a, (.dmark+1)  
a711 32 72 ee			ld (debug_mark+1),a  
a714 3a 1e a7			ld a, (.dmark+2)  
a717 32 73 ee			ld (debug_mark+2),a  
a71a 18 03			jr .pastdmark  
a71c ..			.dmark: db "LSu"  
a71f f1			.pastdmark: pop af  
a720			endm  
# End of macro DMARK
a720					CALLMONITOR 
a720 cd 7c 93			call break_point_state  
a723				endm  
# End of macro CALLMONITOR
a723				endif 
a723			 
a723					; found a uword but is it the one we want... 
a723			 
a723 c5					push bc     ; uword to find is on bc 
a724 d1					pop de 
a725			 
a725 e5					push hl  ; to save the ptr 
a726			 
a726					; skip opcode 
a726 23					inc hl  
a727					; skip next ptr 
a727 23					inc hl  
a728 23					inc hl 
a729					; skip len 
a729 23					inc hl 
a72a			 
a72a				if DEBUG_FORTH_WORDS 
a72a					DMARK "LSc" 
a72a f5				push af  
a72b 3a 3f a7			ld a, (.dmark)  
a72e 32 71 ee			ld (debug_mark),a  
a731 3a 40 a7			ld a, (.dmark+1)  
a734 32 72 ee			ld (debug_mark+1),a  
a737 3a 41 a7			ld a, (.dmark+2)  
a73a 32 73 ee			ld (debug_mark+2),a  
a73d 18 03			jr .pastdmark  
a73f ..			.dmark: db "LSc"  
a742 f1			.pastdmark: pop af  
a743			endm  
# End of macro DMARK
a743					CALLMONITOR 
a743 cd 7c 93			call break_point_state  
a746				endm  
# End of macro CALLMONITOR
a746				endif 
a746 cd 11 90				call strcmp 
a749 c2 c5 a6				jp nz, .ldouscanm 
a74c				 
a74c			 
a74c			 
a74c					; we have a uword so push its name to the stack 
a74c			 
a74c			;	   	push hl  ; save so we can move to next dict block 
a74c e1			pop hl 
a74d			 
a74d				if DEBUG_FORTH_WORDS 
a74d					DMARK "LSm" 
a74d f5				push af  
a74e 3a 62 a7			ld a, (.dmark)  
a751 32 71 ee			ld (debug_mark),a  
a754 3a 63 a7			ld a, (.dmark+1)  
a757 32 72 ee			ld (debug_mark+1),a  
a75a 3a 64 a7			ld a, (.dmark+2)  
a75d 32 73 ee			ld (debug_mark+2),a  
a760 18 03			jr .pastdmark  
a762 ..			.dmark: db "LSm"  
a765 f1			.pastdmark: pop af  
a766			endm  
# End of macro DMARK
a766					CALLMONITOR 
a766 cd 7c 93			call break_point_state  
a769				endm  
# End of macro CALLMONITOR
a769				endif 
a769			 
a769					; skip opcode 
a769 23					inc hl  
a76a					; skip next ptr 
a76a 23					inc hl  
a76b 23					inc hl 
a76c					; skip len 
a76c 7e					ld a, (hl)   ; save length to add 
a76d				if DEBUG_FORTH_WORDS 
a76d					DMARK "LS2" 
a76d f5				push af  
a76e 3a 82 a7			ld a, (.dmark)  
a771 32 71 ee			ld (debug_mark),a  
a774 3a 83 a7			ld a, (.dmark+1)  
a777 32 72 ee			ld (debug_mark+1),a  
a77a 3a 84 a7			ld a, (.dmark+2)  
a77d 32 73 ee			ld (debug_mark+2),a  
a780 18 03			jr .pastdmark  
a782 ..			.dmark: db "LS2"  
a785 f1			.pastdmark: pop af  
a786			endm  
# End of macro DMARK
a786					CALLMONITOR 
a786 cd 7c 93			call break_point_state  
a789				endm  
# End of macro CALLMONITOR
a789				endif 
a789			 
a789					; save this location 
a789				 
a789 e5					push hl 
a78a			 
a78a 23					inc hl 
a78b 11 59 e3				ld de, scratch+2 
a78e 4f					ld c, a 
a78f 06 00				ld b, 0 
a791			 
a791				if DEBUG_FORTH_WORDS 
a791					DMARK "LSn" 
a791 f5				push af  
a792 3a a6 a7			ld a, (.dmark)  
a795 32 71 ee			ld (debug_mark),a  
a798 3a a7 a7			ld a, (.dmark+1)  
a79b 32 72 ee			ld (debug_mark+1),a  
a79e 3a a8 a7			ld a, (.dmark+2)  
a7a1 32 73 ee			ld (debug_mark+2),a  
a7a4 18 03			jr .pastdmark  
a7a6 ..			.dmark: db "LSn"  
a7a9 f1			.pastdmark: pop af  
a7aa			endm  
# End of macro DMARK
a7aa					CALLMONITOR 
a7aa cd 7c 93			call break_point_state  
a7ad				endm  
# End of macro CALLMONITOR
a7ad				endif 
a7ad			 
a7ad					; copy uword name to scratch 
a7ad			 
a7ad ed b0				ldir 
a7af			 
a7af 1b					dec de 
a7b0 3e 20				ld a, ' '    ; change null to space 
a7b2 12					ld (de), a 
a7b3			 
a7b3 13					inc de 
a7b4			 
a7b4 d5					push de 
a7b5 c1					pop bc     ; move scratch pointer to end of word name and save it 
a7b6			 
a7b6 e1					pop hl 
a7b7 7e					ld a, (hl) 
a7b8					;inc hl 
a7b8					; skip word string 
a7b8 cd 7b 8b				call addatohl 
a7bb			 
a7bb 23					inc hl 
a7bc			 
a7bc				if DEBUG_FORTH_WORDS 
a7bc					DMARK "LS3" 
a7bc f5				push af  
a7bd 3a d1 a7			ld a, (.dmark)  
a7c0 32 71 ee			ld (debug_mark),a  
a7c3 3a d2 a7			ld a, (.dmark+1)  
a7c6 32 72 ee			ld (debug_mark+1),a  
a7c9 3a d3 a7			ld a, (.dmark+2)  
a7cc 32 73 ee			ld (debug_mark+2),a  
a7cf 18 03			jr .pastdmark  
a7d1 ..			.dmark: db "LS3"  
a7d4 f1			.pastdmark: pop af  
a7d5			endm  
# End of macro DMARK
a7d5					CALLMONITOR 
a7d5 cd 7c 93			call break_point_state  
a7d8				endm  
# End of macro CALLMONITOR
a7d8				endif 
a7d8					; should now be at the start of the machine code to setup the eval of the uword 
a7d8					; now locate the ptr to the string defintion 
a7d8			 
a7d8					; skip ld hl, 
a7d8					; then load the ptr 
a7d8			; TODO use get from hl ptr 
a7d8 23					inc hl 
a7d9 5e					ld e, (hl) 
a7da 23					inc hl 
a7db 56					ld d, (hl) 
a7dc eb					ex de, hl 
a7dd			 
a7dd			 
a7dd				if DEBUG_FORTH_WORDS 
a7dd					DMARK "LSt" 
a7dd f5				push af  
a7de 3a f2 a7			ld a, (.dmark)  
a7e1 32 71 ee			ld (debug_mark),a  
a7e4 3a f3 a7			ld a, (.dmark+1)  
a7e7 32 72 ee			ld (debug_mark+1),a  
a7ea 3a f4 a7			ld a, (.dmark+2)  
a7ed 32 73 ee			ld (debug_mark+2),a  
a7f0 18 03			jr .pastdmark  
a7f2 ..			.dmark: db "LSt"  
a7f5 f1			.pastdmark: pop af  
a7f6			endm  
# End of macro DMARK
a7f6					CALLMONITOR 
a7f6 cd 7c 93			call break_point_state  
a7f9				endm  
# End of macro CALLMONITOR
a7f9				endif 
a7f9			 
a7f9			; cant push right now due to tokenised strings  
a7f9			 
a7f9			; get the destination of where to copy this definition to. 
a7f9			 
a7f9 c5					push bc 
a7fa d1					pop de 
a7fb			 
a7fb 7e			.listl:         ld a,(hl) 
a7fc fe 00				cp 0 
a7fe 28 09				jr z, .lreplsp     ; replace zero with space 
a800					;cp FORTH_END_BUFFER 
a800 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a802 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a804				 
a804					; just copy this char as is then 
a804			 
a804 12					ld (de), a 
a805			 
a805 23			.listnxt:	inc hl 
a806 13					inc de 
a807 18 f2				jr .listl 
a809			 
a809 3e 20		.lreplsp:	ld a,' ' 
a80b 12					ld (de), a 
a80c 18 f7				jr .listnxt 
a80e			 
a80e			; close up uword def 
a80e			 
a80e			.listdone: 
a80e 12					ld (de), a 
a80f 13					inc de 
a810 3e 00				ld a, 0 
a812 12					ld (de), a 
a813			 
a813			; now have def so clean up and push to stack 
a813			 
a813 21 57 e3				ld hl, scratch 
a816				if DEBUG_FORTH_WORDS 
a816					DMARK "Ltp" 
a816 f5				push af  
a817 3a 2b a8			ld a, (.dmark)  
a81a 32 71 ee			ld (debug_mark),a  
a81d 3a 2c a8			ld a, (.dmark+1)  
a820 32 72 ee			ld (debug_mark+1),a  
a823 3a 2d a8			ld a, (.dmark+2)  
a826 32 73 ee			ld (debug_mark+2),a  
a829 18 03			jr .pastdmark  
a82b ..			.dmark: db "Ltp"  
a82e f1			.pastdmark: pop af  
a82f			endm  
# End of macro DMARK
a82f					CALLMONITOR 
a82f cd 7c 93			call break_point_state  
a832				endm  
# End of macro CALLMONITOR
a832				endif 
a832			 
a832 18 1f			jr .listpush 
a834			 
a834			;.lnuword:	pop hl 
a834			;		call forth_tok_next 
a834			;		jp .ldouscan  
a834			 
a834			.lunotfound:		  
a834			 
a834				if DEBUG_FORTH_WORDS 
a834					DMARK "LSn" 
a834 f5				push af  
a835 3a 49 a8			ld a, (.dmark)  
a838 32 71 ee			ld (debug_mark),a  
a83b 3a 4a a8			ld a, (.dmark+1)  
a83e 32 72 ee			ld (debug_mark+1),a  
a841 3a 4b a8			ld a, (.dmark+2)  
a844 32 73 ee			ld (debug_mark+2),a  
a847 18 03			jr .pastdmark  
a849 ..			.dmark: db "LSn"  
a84c f1			.pastdmark: pop af  
a84d			endm  
# End of macro DMARK
a84d					CALLMONITOR 
a84d cd 7c 93			call break_point_state  
a850				endm  
# End of macro CALLMONITOR
a850				endif 
a850			 
a850					 
a850			;		FORTH_DSP_POP 
a850			;		ld hl, .luno 
a850			 
a850					NEXTW			 
a850 c3 3f 9d			jp macro_next 
a853				endm 
# End of macro NEXTW
a853			 
a853			.listpush: 
a853				if DEBUG_FORTH_WORDS 
a853					DMARK "LS>" 
a853 f5				push af  
a854 3a 68 a8			ld a, (.dmark)  
a857 32 71 ee			ld (debug_mark),a  
a85a 3a 69 a8			ld a, (.dmark+1)  
a85d 32 72 ee			ld (debug_mark+1),a  
a860 3a 6a a8			ld a, (.dmark+2)  
a863 32 73 ee			ld (debug_mark+2),a  
a866 18 03			jr .pastdmark  
a868 ..			.dmark: db "LS>"  
a86b f1			.pastdmark: pop af  
a86c			endm  
# End of macro DMARK
a86c					CALLMONITOR 
a86c cd 7c 93			call break_point_state  
a86f				endm  
# End of macro CALLMONITOR
a86f				endif 
a86f cd 44 9a				call forth_push_str 
a872			 
a872			 
a872			 
a872					NEXTW 
a872 c3 3f 9d			jp macro_next 
a875				endm 
# End of macro NEXTW
a875			 
a875			;.luno:    db "Word not found",0 
a875			 
a875			 
a875			 
a875			 
a875			 
a875			;		push hl   ; save pointer to start of uword def string 
a875			; 
a875			;; look for FORTH_EOL_LINE 
a875			;		ld a, FORTH_END_BUFFER 
a875			;		call strlent 
a875			; 
a875			;		inc hl		 ; space for coln def 
a875			;		inc hl 
a875			;		inc hl          ; space for terms 
a875			;		inc hl 
a875			; 
a875			;		ld a, 20   ; TODO get actual length 
a875			;		call addatohl    ; include a random amount of room for the uword name 
a875			; 
a875			;		 
a875			;	if DEBUG_FORTH_WORDS 
a875			;		DMARK "Lt1" 
a875			;		CALLMONITOR 
a875			;	endif 
a875			;		 
a875			; 
a875			;; malloc space for the string because we cant change it 
a875			; 
a875			;		call malloc 
a875			;	if DEBUG_FORTH_MALLOC_GUARD 
a875			;		push af 
a875			;		call ishlzero 
a875			;		pop af 
a875			;		 
a875			;		call z,malloc_error 
a875			;	endif 
a875			; 
a875			;	if DEBUG_FORTH_WORDS 
a875			;		DMARK "Lt2" 
a875			;		CALLMONITOR 
a875			;	endif 
a875			;		pop de 
a875			;		push hl    ; push the malloc to release later 
a875			;		push hl   ;  push back a copy for the later stack push 
a875			;		 
a875			;; copy the string swapping out the zero terms for spaces 
a875			; 
a875			;		; de has our source 
a875			;		; hl has our dest 
a875			; 
a875			;; add the coln def 
a875			; 
a875			;		ld a, ':' 
a875			;		ld (hl), a 
a875			;		inc hl 
a875			;		ld a, ' ' 
a875			;		ld (hl), a 
a875			;		inc hl 
a875			; 
a875			;; add the uname word 
a875			;		push de   ; save our string for now 
a875			;		ex de, hl 
a875			; 
a875			;		FORTH_DSP_VALUE 
a875			;		;v5 FORTH_DSP_VALUE 
a875			; 
a875			;		inc hl   ; skip type but we know by now this is OK 
a875			; 
a875			;.luword:	ld a,(hl) 
a875			;		cp 0 
a875			;		jr z, .luword2 
a875			;		ld (de), a 
a875			;		inc de 
a875			;		inc hl 
a875			;		jr .luword 
a875			; 
a875			;.luword2:	ld a, ' ' 
a875			;		ld (de), a 
a875			;;		inc hl 
a875			;;		inc de 
a875			;;		ld (de), a 
a875			;;		inc hl 
a875			;		inc de 
a875			; 
a875			;		ex de, hl 
a875			;		pop de 
a875			;		 
a875			;		 
a875			; 
a875			;; detoken that string and copy it 
a875			; 
a875			;	if DEBUG_FORTH_WORDS 
a875			;		DMARK "Lt2" 
a875			;		CALLMONITOR 
a875			;	endif 
a875			;.ldetok:	ld a, (de) 
a875			;		cp FORTH_END_BUFFER 
a875			;		jr z, .ldetokend 
a875			;		; swap out any zero term for space 
a875			;		cp 0 
a875			;		jr nz, .ldetoknext 
a875			;		ld a, ' ' 
a875			; 
a875			;	if DEBUG_FORTH_WORDS 
a875			;		DMARK "LtS" 
a875			;		CALLMONITOR 
a875			;	endif 
a875			;.ldetoknext:	ld (hl), a 
a875			;		inc de 
a875			;		inc hl 
a875			;		jr .ldetok 
a875			; 
a875			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a875			;		ld (hl), a  
a875			; 
a875			;; free that temp malloc 
a875			; 
a875			;		pop hl    
a875			; 
a875			;	if DEBUG_FORTH_WORDS 
a875			;		DMARK "Lt4" 
a875			;		CALLMONITOR 
a875			;	endif 
a875			;		call forth_apushstrhl 
a875			; 
a875			;		; get rid of temp malloc area 
a875			; 
a875			;		pop hl 
a875			;		call free 
a875			; 
a875			;		jr .ludone 
a875			; 
a875			;.lnuword:	pop hl 
a875			;		call forth_tok_next 
a875			;		jp .ldouscan  
a875			; 
a875			;.ludone:		 pop hl 
a875			; 
a875					NEXTW 
a875 c3 3f 9d			jp macro_next 
a878				endm 
# End of macro NEXTW
a878			 
a878			.FORGET: 
a878				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a878 5d				db WORD_SYS_CORE+73             
a879 f1 a8			dw .NOP            
a87b 07				db 6 + 1 
a87c .. 00			db "FORGET",0              
a883				endm 
# End of macro CWHEAD
a883			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a883			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a883			; | |  
a883			; | | e.g. "MORE" forget 
a883					if DEBUG_FORTH_WORDS_KEY 
a883						DMARK "FRG" 
a883 f5				push af  
a884 3a 98 a8			ld a, (.dmark)  
a887 32 71 ee			ld (debug_mark),a  
a88a 3a 99 a8			ld a, (.dmark+1)  
a88d 32 72 ee			ld (debug_mark+1),a  
a890 3a 9a a8			ld a, (.dmark+2)  
a893 32 73 ee			ld (debug_mark+2),a  
a896 18 03			jr .pastdmark  
a898 ..			.dmark: db "FRG"  
a89b f1			.pastdmark: pop af  
a89c			endm  
# End of macro DMARK
a89c						CALLMONITOR 
a89c cd 7c 93			call break_point_state  
a89f				endm  
# End of macro CALLMONITOR
a89f					endif 
a89f			 
a89f				; find uword 
a89f			        ; update start of word with "_" 
a89f				; replace uword with deleted flag 
a89f			 
a89f			 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "FOG" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			 
a89f			 
a89f					; Get ptr to the word we need to look up 
a89f			 
a89f					FORTH_DSP_VALUEHL 
a89f cd cd 9b			call macro_dsp_valuehl 
a8a2				endm 
# End of macro FORTH_DSP_VALUEHL
a8a2					;v5 FORTH_DSP_VALUE 
a8a2				; TODO type check 
a8a2			;		inc hl    ; Skip type check  
a8a2 e5					push hl 
a8a3 c1					pop bc 
a8a4			;		ex de, hl    ; put into DE 
a8a4			 
a8a4			 
a8a4 21 eb d8				ld hl, baseram 
a8a7					;ld hl, baseusermem 
a8a7			 
a8a7				; skip dict stub 
a8a7			;	call forth_tok_next 
a8a7 e5			push hl   ; sacreifical push 
a8a8			 
a8a8			.fldouscanm: 
a8a8 e1				pop hl 
a8a9			.fldouscan: 
a8a9			;	if DEBUG_FORTH_WORDS 
a8a9			;		DMARK "LSs" 
a8a9			;		CALLMONITOR 
a8a9			;	endif 
a8a9				; skip dict stub 
a8a9 cd 90 9e				call forth_tok_next 
a8ac			 
a8ac			 
a8ac			; while we have words to look for 
a8ac			 
a8ac 7e				ld a, (hl)      
a8ad			;	if DEBUG_FORTH_WORDS 
a8ad			;		DMARK "LSk" 
a8ad			;		CALLMONITOR 
a8ad			;	endif 
a8ad fe 00				cp WORD_SYS_END 
a8af ca eb a8				jp z, .flunotfound 
a8b2 fe 01				cp WORD_SYS_UWORD 
a8b4 c2 a9 a8				jp nz, .fldouscan 
a8b7			 
a8b7			;	if DEBUG_FORTH_WORDS 
a8b7			;		DMARK "LSu" 
a8b7			;		CALLMONITOR 
a8b7			;	endif 
a8b7			 
a8b7					; found a uword but is it the one we want... 
a8b7			 
a8b7 c5					push bc     ; uword to find is on bc 
a8b8 d1					pop de 
a8b9			 
a8b9 e5					push hl  ; to save the ptr 
a8ba			 
a8ba					; skip opcode 
a8ba 23					inc hl  
a8bb					; skip next ptr 
a8bb 23					inc hl  
a8bc 23					inc hl 
a8bd					; skip len 
a8bd 23					inc hl 
a8be			 
a8be			;	if DEBUG_FORTH_WORDS 
a8be			;		DMARK "LSc" 
a8be			;		CALLMONITOR 
a8be			;	endif 
a8be cd 11 90				call strcmp 
a8c1 c2 a8 a8				jp nz, .fldouscanm 
a8c4			; 
a8c4			; 
a8c4			;; while we have words to look for 
a8c4			; 
a8c4			;.fdouscan:	ld a, (hl)      
a8c4			;	if DEBUG_FORTH_WORDS 
a8c4			;		DMARK "LSs" 
a8c4			;		CALLMONITOR 
a8c4			;	endif 
a8c4			;		cp WORD_SYS_END 
a8c4			;		jp z, .fudone 
a8c4			;		cp WORD_SYS_UWORD 
a8c4			;		jp nz, .fnuword 
a8c4			; 
a8c4			;	if DEBUG_FORTH_WORDS 
a8c4			;		DMARK "FGu" 
a8c4			;		CALLMONITOR 
a8c4			;	endif 
a8c4			; 
a8c4			;		; found a uword but is it the one we want... 
a8c4			; 
a8c4			; 
a8c4			;	        pop de   ; get back the dsp name 
a8c4			;		push de 
a8c4			; 
a8c4			;		push hl  ; to save the ptr 
a8c4			; 
a8c4			;		; skip opcode 
a8c4			;		inc hl  
a8c4			;		; skip next ptr 
a8c4			;		inc hl  
a8c4			;		inc hl 
a8c4			;		; skip len 
a8c4			;		inc hl 
a8c4			; 
a8c4			;	if DEBUG_FORTH_WORDS 
a8c4			;		DMARK "FGc" 
a8c4			;		CALLMONITOR 
a8c4			;	endif 
a8c4			;		call strcmp 
a8c4			;		jp nz, .fnuword 
a8c4			 
a8c4			 
a8c4 e1			pop hl 
a8c5			 
a8c5				 
a8c5				if DEBUG_FORTH_WORDS 
a8c5					DMARK "FGm" 
a8c5 f5				push af  
a8c6 3a da a8			ld a, (.dmark)  
a8c9 32 71 ee			ld (debug_mark),a  
a8cc 3a db a8			ld a, (.dmark+1)  
a8cf 32 72 ee			ld (debug_mark+1),a  
a8d2 3a dc a8			ld a, (.dmark+2)  
a8d5 32 73 ee			ld (debug_mark+2),a  
a8d8 18 03			jr .pastdmark  
a8da ..			.dmark: db "FGm"  
a8dd f1			.pastdmark: pop af  
a8de			endm  
# End of macro DMARK
a8de					CALLMONITOR 
a8de cd 7c 93			call break_point_state  
a8e1				endm  
# End of macro CALLMONITOR
a8e1				endif 
a8e1			 
a8e1			 
a8e1			 
a8e1					; we have a uword so push its name to the stack 
a8e1			 
a8e1			;	   	push hl  ; save so we can move to next dict block 
a8e1			;pop hl 
a8e1			 
a8e1					; update opcode to deleted 
a8e1 3e 03				ld a, WORD_SYS_DELETED 
a8e3 77					ld (hl), a 
a8e4			 
a8e4 23					inc hl  
a8e5					; skip next ptr 
a8e5 23					inc hl  
a8e6 23					inc hl 
a8e7					; skip len 
a8e7 23					inc hl 
a8e8			 
a8e8					; TODO change parser to skip deleted words but for now mark it out 
a8e8 3e 5f				ld a, "_" 
a8ea 77					ld  (hl),a 
a8eb			 
a8eb			;		jr .fudone 
a8eb			; 
a8eb			;.fnuword:	pop hl 
a8eb			;		call forth_tok_next 
a8eb			;		jp .fdouscan  
a8eb			 
a8eb			.flunotfound:		  
a8eb			 
a8eb			 
a8eb					 
a8eb					FORTH_DSP_POP 
a8eb cd 85 9c			call macro_forth_dsp_pop 
a8ee				endm 
# End of macro FORTH_DSP_POP
a8ee			;		ld hl, .luno 
a8ee			;.fudone:		 pop hl 
a8ee					NEXTW 
a8ee c3 3f 9d			jp macro_next 
a8f1				endm 
# End of macro NEXTW
a8f1			.NOP: 
a8f1				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a8f1 61				db WORD_SYS_CORE+77             
a8f2 18 a9			dw .COMO            
a8f4 04				db 3 + 1 
a8f5 .. 00			db "NOP",0              
a8f9				endm 
# End of macro CWHEAD
a8f9			; | NOP (  --  ) Do nothing | DONE 
a8f9					if DEBUG_FORTH_WORDS_KEY 
a8f9						DMARK "NOP" 
a8f9 f5				push af  
a8fa 3a 0e a9			ld a, (.dmark)  
a8fd 32 71 ee			ld (debug_mark),a  
a900 3a 0f a9			ld a, (.dmark+1)  
a903 32 72 ee			ld (debug_mark+1),a  
a906 3a 10 a9			ld a, (.dmark+2)  
a909 32 73 ee			ld (debug_mark+2),a  
a90c 18 03			jr .pastdmark  
a90e ..			.dmark: db "NOP"  
a911 f1			.pastdmark: pop af  
a912			endm  
# End of macro DMARK
a912						CALLMONITOR 
a912 cd 7c 93			call break_point_state  
a915				endm  
# End of macro CALLMONITOR
a915					endif 
a915				       NEXTW 
a915 c3 3f 9d			jp macro_next 
a918				endm 
# End of macro NEXTW
a918			.COMO: 
a918				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a918 6e				db WORD_SYS_CORE+90             
a919 6a a9			dw .COMC            
a91b 02				db 1 + 1 
a91c .. 00			db "(",0              
a91e				endm 
# End of macro CWHEAD
a91e			; | ( ( -- )  Start of comment | DONE 
a91e			 
a91e			 
a91e 2a 58 e6				ld hl, ( os_tok_ptr) 
a921 11 65 a9			ld de, .closepar 
a924					 
a924					if DEBUG_FORTH_WORDS 
a924						DMARK ").." 
a924 f5				push af  
a925 3a 39 a9			ld a, (.dmark)  
a928 32 71 ee			ld (debug_mark),a  
a92b 3a 3a a9			ld a, (.dmark+1)  
a92e 32 72 ee			ld (debug_mark+1),a  
a931 3a 3b a9			ld a, (.dmark+2)  
a934 32 73 ee			ld (debug_mark+2),a  
a937 18 03			jr .pastdmark  
a939 ..			.dmark: db ").."  
a93c f1			.pastdmark: pop af  
a93d			endm  
# End of macro DMARK
a93d						CALLMONITOR 
a93d cd 7c 93			call break_point_state  
a940				endm  
# End of macro CALLMONITOR
a940					endif 
a940 cd 5a 9e			call findnexttok  
a943			 
a943					if DEBUG_FORTH_WORDS 
a943						DMARK "IF5" 
a943 f5				push af  
a944 3a 58 a9			ld a, (.dmark)  
a947 32 71 ee			ld (debug_mark),a  
a94a 3a 59 a9			ld a, (.dmark+1)  
a94d 32 72 ee			ld (debug_mark+1),a  
a950 3a 5a a9			ld a, (.dmark+2)  
a953 32 73 ee			ld (debug_mark+2),a  
a956 18 03			jr .pastdmark  
a958 ..			.dmark: db "IF5"  
a95b f1			.pastdmark: pop af  
a95c			endm  
# End of macro DMARK
a95c						CALLMONITOR 
a95c cd 7c 93			call break_point_state  
a95f				endm  
# End of macro CALLMONITOR
a95f					endif 
a95f				; replace below with ) exec using tok_ptr 
a95f 22 58 e6			ld (os_tok_ptr), hl 
a962 c3 d0 9d			jp exec1 
a965			 
a965 .. 00			.closepar:   db ")",0 
a967			 
a967				       NEXTW 
a967 c3 3f 9d			jp macro_next 
a96a				endm 
# End of macro NEXTW
a96a			.COMC: 
a96a				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a96a 6f				db WORD_SYS_CORE+91             
a96b 73 a9			dw .SCRATCH            
a96d 02				db 1 + 1 
a96e .. 00			db ")",0              
a970				endm 
# End of macro CWHEAD
a970			; | ) ( -- )  End of comment |  DONE  
a970				       NEXTW 
a970 c3 3f 9d			jp macro_next 
a973				endm 
# End of macro NEXTW
a973			 
a973			.SCRATCH: 
a973				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a973 6f				db WORD_SYS_CORE+91             
a974 ae a9			dw .INC            
a976 08				db 7 + 1 
a977 .. 00			db "SCRATCH",0              
a97f				endm 
# End of macro CWHEAD
a97f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a97f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a97f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a97f			; | |  
a97f			; | | e.g.    : score $00 scratch ; 
a97f			; | |  
a97f			; | | $00 score ! 
a97f			; | | $01 score +! 
a97f			; | |  
a97f			; | | e.g.   : varword $0a scratch ;  
a97f			; | | 
a97f			; | | $8000 varword ! 
a97f					if DEBUG_FORTH_WORDS_KEY 
a97f						DMARK "SCR" 
a97f f5				push af  
a980 3a 94 a9			ld a, (.dmark)  
a983 32 71 ee			ld (debug_mark),a  
a986 3a 95 a9			ld a, (.dmark+1)  
a989 32 72 ee			ld (debug_mark+1),a  
a98c 3a 96 a9			ld a, (.dmark+2)  
a98f 32 73 ee			ld (debug_mark+2),a  
a992 18 03			jr .pastdmark  
a994 ..			.dmark: db "SCR"  
a997 f1			.pastdmark: pop af  
a998			endm  
# End of macro DMARK
a998						CALLMONITOR 
a998 cd 7c 93			call break_point_state  
a99b				endm  
# End of macro CALLMONITOR
a99b					endif 
a99b			 
a99b					FORTH_DSP_VALUEHL 
a99b cd cd 9b			call macro_dsp_valuehl 
a99e				endm 
# End of macro FORTH_DSP_VALUEHL
a99e				 
a99e					FORTH_DSP_POP 
a99e cd 85 9c			call macro_forth_dsp_pop 
a9a1				endm 
# End of macro FORTH_DSP_POP
a9a1			 
a9a1 7d					ld a, l 
a9a2 21 7c e8				ld hl, os_var_array 
a9a5 cd 7b 8b				call addatohl 
a9a8			 
a9a8 cd d6 99				call forth_push_numhl 
a9ab			 
a9ab				       NEXTW 
a9ab c3 3f 9d			jp macro_next 
a9ae				endm 
# End of macro NEXTW
a9ae			 
a9ae			.INC: 
a9ae				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a9ae 6f				db WORD_SYS_CORE+91             
a9af 02 aa			dw .DEC            
a9b1 03				db 2 + 1 
a9b2 .. 00			db "+!",0              
a9b5				endm 
# End of macro CWHEAD
a9b5			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a9b5					if DEBUG_FORTH_WORDS_KEY 
a9b5						DMARK "+s_" 
a9b5 f5				push af  
a9b6 3a ca a9			ld a, (.dmark)  
a9b9 32 71 ee			ld (debug_mark),a  
a9bc 3a cb a9			ld a, (.dmark+1)  
a9bf 32 72 ee			ld (debug_mark+1),a  
a9c2 3a cc a9			ld a, (.dmark+2)  
a9c5 32 73 ee			ld (debug_mark+2),a  
a9c8 18 03			jr .pastdmark  
a9ca ..			.dmark: db "+s_"  
a9cd f1			.pastdmark: pop af  
a9ce			endm  
# End of macro DMARK
a9ce						CALLMONITOR 
a9ce cd 7c 93			call break_point_state  
a9d1				endm  
# End of macro CALLMONITOR
a9d1					endif 
a9d1			 
a9d1					FORTH_DSP_VALUEHL 
a9d1 cd cd 9b			call macro_dsp_valuehl 
a9d4				endm 
# End of macro FORTH_DSP_VALUEHL
a9d4			 
a9d4 e5					push hl   ; save address 
a9d5			 
a9d5					FORTH_DSP_POP 
a9d5 cd 85 9c			call macro_forth_dsp_pop 
a9d8				endm 
# End of macro FORTH_DSP_POP
a9d8			 
a9d8					FORTH_DSP_VALUEHL 
a9d8 cd cd 9b			call macro_dsp_valuehl 
a9db				endm 
# End of macro FORTH_DSP_VALUEHL
a9db			 
a9db					FORTH_DSP_POP 
a9db cd 85 9c			call macro_forth_dsp_pop 
a9de				endm 
# End of macro FORTH_DSP_POP
a9de			 
a9de					; hl contains value to add to byte at a 
a9de				 
a9de eb					ex de, hl 
a9df			 
a9df e1					pop hl 
a9e0			 
a9e0					if DEBUG_FORTH_WORDS 
a9e0						DMARK "INC" 
a9e0 f5				push af  
a9e1 3a f5 a9			ld a, (.dmark)  
a9e4 32 71 ee			ld (debug_mark),a  
a9e7 3a f6 a9			ld a, (.dmark+1)  
a9ea 32 72 ee			ld (debug_mark+1),a  
a9ed 3a f7 a9			ld a, (.dmark+2)  
a9f0 32 73 ee			ld (debug_mark+2),a  
a9f3 18 03			jr .pastdmark  
a9f5 ..			.dmark: db "INC"  
a9f8 f1			.pastdmark: pop af  
a9f9			endm  
# End of macro DMARK
a9f9						CALLMONITOR 
a9f9 cd 7c 93			call break_point_state  
a9fc				endm  
# End of macro CALLMONITOR
a9fc					endif 
a9fc			 
a9fc 7e					ld a,(hl) 
a9fd 83					add e 
a9fe 77					ld (hl),a 
a9ff			 
a9ff			 
a9ff			 
a9ff				       NEXTW 
a9ff c3 3f 9d			jp macro_next 
aa02				endm 
# End of macro NEXTW
aa02			 
aa02			.DEC: 
aa02				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aa02 6f				db WORD_SYS_CORE+91             
aa03 53 aa			dw .INC2            
aa05 03				db 2 + 1 
aa06 .. 00			db "-!",0              
aa09				endm 
# End of macro CWHEAD
aa09			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aa09					if DEBUG_FORTH_WORDS_KEY 
aa09						DMARK "-s_" 
aa09 f5				push af  
aa0a 3a 1e aa			ld a, (.dmark)  
aa0d 32 71 ee			ld (debug_mark),a  
aa10 3a 1f aa			ld a, (.dmark+1)  
aa13 32 72 ee			ld (debug_mark+1),a  
aa16 3a 20 aa			ld a, (.dmark+2)  
aa19 32 73 ee			ld (debug_mark+2),a  
aa1c 18 03			jr .pastdmark  
aa1e ..			.dmark: db "-s_"  
aa21 f1			.pastdmark: pop af  
aa22			endm  
# End of macro DMARK
aa22						CALLMONITOR 
aa22 cd 7c 93			call break_point_state  
aa25				endm  
# End of macro CALLMONITOR
aa25					endif 
aa25			 
aa25					FORTH_DSP_VALUEHL 
aa25 cd cd 9b			call macro_dsp_valuehl 
aa28				endm 
# End of macro FORTH_DSP_VALUEHL
aa28			 
aa28 e5					push hl   ; save address 
aa29			 
aa29					FORTH_DSP_POP 
aa29 cd 85 9c			call macro_forth_dsp_pop 
aa2c				endm 
# End of macro FORTH_DSP_POP
aa2c			 
aa2c					FORTH_DSP_VALUEHL 
aa2c cd cd 9b			call macro_dsp_valuehl 
aa2f				endm 
# End of macro FORTH_DSP_VALUEHL
aa2f			 
aa2f					; hl contains value to add to byte at a 
aa2f				 
aa2f eb					ex de, hl 
aa30			 
aa30 e1					pop hl 
aa31			 
aa31					if DEBUG_FORTH_WORDS 
aa31						DMARK "DEC" 
aa31 f5				push af  
aa32 3a 46 aa			ld a, (.dmark)  
aa35 32 71 ee			ld (debug_mark),a  
aa38 3a 47 aa			ld a, (.dmark+1)  
aa3b 32 72 ee			ld (debug_mark+1),a  
aa3e 3a 48 aa			ld a, (.dmark+2)  
aa41 32 73 ee			ld (debug_mark+2),a  
aa44 18 03			jr .pastdmark  
aa46 ..			.dmark: db "DEC"  
aa49 f1			.pastdmark: pop af  
aa4a			endm  
# End of macro DMARK
aa4a						CALLMONITOR 
aa4a cd 7c 93			call break_point_state  
aa4d				endm  
# End of macro CALLMONITOR
aa4d					endif 
aa4d			 
aa4d 7e					ld a,(hl) 
aa4e 93					sub e 
aa4f 77					ld (hl),a 
aa50			 
aa50			 
aa50			 
aa50				       NEXTW 
aa50 c3 3f 9d			jp macro_next 
aa53				endm 
# End of macro NEXTW
aa53			 
aa53			.INC2: 
aa53				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
aa53 6f				db WORD_SYS_CORE+91             
aa54 fd aa			dw .DEC2            
aa56 04				db 3 + 1 
aa57 .. 00			db "+2!",0              
aa5b				endm 
# End of macro CWHEAD
aa5b			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
aa5b			 
aa5b					if DEBUG_FORTH_WORDS_KEY 
aa5b						DMARK "+2s" 
aa5b f5				push af  
aa5c 3a 70 aa			ld a, (.dmark)  
aa5f 32 71 ee			ld (debug_mark),a  
aa62 3a 71 aa			ld a, (.dmark+1)  
aa65 32 72 ee			ld (debug_mark+1),a  
aa68 3a 72 aa			ld a, (.dmark+2)  
aa6b 32 73 ee			ld (debug_mark+2),a  
aa6e 18 03			jr .pastdmark  
aa70 ..			.dmark: db "+2s"  
aa73 f1			.pastdmark: pop af  
aa74			endm  
# End of macro DMARK
aa74						CALLMONITOR 
aa74 cd 7c 93			call break_point_state  
aa77				endm  
# End of macro CALLMONITOR
aa77					endif 
aa77			 
aa77					; Address 
aa77			 
aa77					FORTH_DSP_VALUEHL 
aa77 cd cd 9b			call macro_dsp_valuehl 
aa7a				endm 
# End of macro FORTH_DSP_VALUEHL
aa7a			 
aa7a e5					push hl    ; save address 
aa7b			 
aa7b					; load content into de 
aa7b			 
aa7b 5e					ld e,(hl) 
aa7c 23					inc hl 
aa7d 56					ld d, (hl) 
aa7e			 
aa7e					if DEBUG_FORTH_WORDS 
aa7e						DMARK "+2a" 
aa7e f5				push af  
aa7f 3a 93 aa			ld a, (.dmark)  
aa82 32 71 ee			ld (debug_mark),a  
aa85 3a 94 aa			ld a, (.dmark+1)  
aa88 32 72 ee			ld (debug_mark+1),a  
aa8b 3a 95 aa			ld a, (.dmark+2)  
aa8e 32 73 ee			ld (debug_mark+2),a  
aa91 18 03			jr .pastdmark  
aa93 ..			.dmark: db "+2a"  
aa96 f1			.pastdmark: pop af  
aa97			endm  
# End of macro DMARK
aa97						CALLMONITOR 
aa97 cd 7c 93			call break_point_state  
aa9a				endm  
# End of macro CALLMONITOR
aa9a					endif 
aa9a			 
aa9a					FORTH_DSP_POP 
aa9a cd 85 9c			call macro_forth_dsp_pop 
aa9d				endm 
# End of macro FORTH_DSP_POP
aa9d			 
aa9d					; Get value to add 
aa9d			 
aa9d					FORTH_DSP_VALUE 
aa9d cd b6 9b			call macro_forth_dsp_value 
aaa0				endm 
# End of macro FORTH_DSP_VALUE
aaa0			 
aaa0					if DEBUG_FORTH_WORDS 
aaa0						DMARK "+2v" 
aaa0 f5				push af  
aaa1 3a b5 aa			ld a, (.dmark)  
aaa4 32 71 ee			ld (debug_mark),a  
aaa7 3a b6 aa			ld a, (.dmark+1)  
aaaa 32 72 ee			ld (debug_mark+1),a  
aaad 3a b7 aa			ld a, (.dmark+2)  
aab0 32 73 ee			ld (debug_mark+2),a  
aab3 18 03			jr .pastdmark  
aab5 ..			.dmark: db "+2v"  
aab8 f1			.pastdmark: pop af  
aab9			endm  
# End of macro DMARK
aab9						CALLMONITOR 
aab9 cd 7c 93			call break_point_state  
aabc				endm  
# End of macro CALLMONITOR
aabc					endif 
aabc			 
aabc 19					add hl, de 
aabd			 
aabd					if DEBUG_FORTH_WORDS 
aabd						DMARK "+2+" 
aabd f5				push af  
aabe 3a d2 aa			ld a, (.dmark)  
aac1 32 71 ee			ld (debug_mark),a  
aac4 3a d3 aa			ld a, (.dmark+1)  
aac7 32 72 ee			ld (debug_mark+1),a  
aaca 3a d4 aa			ld a, (.dmark+2)  
aacd 32 73 ee			ld (debug_mark+2),a  
aad0 18 03			jr .pastdmark  
aad2 ..			.dmark: db "+2+"  
aad5 f1			.pastdmark: pop af  
aad6			endm  
# End of macro DMARK
aad6						CALLMONITOR 
aad6 cd 7c 93			call break_point_state  
aad9				endm  
# End of macro CALLMONITOR
aad9					endif 
aad9			 
aad9					; move result to de 
aad9			 
aad9 eb					ex de, hl 
aada			 
aada					; Address 
aada			 
aada e1					pop hl 
aadb			 
aadb					; save it back 
aadb			 
aadb 73					ld (hl), e 
aadc 23					inc hl 
aadd 72					ld (hl), d 
aade			 
aade					if DEBUG_FORTH_WORDS 
aade						DMARK "+2e" 
aade f5				push af  
aadf 3a f3 aa			ld a, (.dmark)  
aae2 32 71 ee			ld (debug_mark),a  
aae5 3a f4 aa			ld a, (.dmark+1)  
aae8 32 72 ee			ld (debug_mark+1),a  
aaeb 3a f5 aa			ld a, (.dmark+2)  
aaee 32 73 ee			ld (debug_mark+2),a  
aaf1 18 03			jr .pastdmark  
aaf3 ..			.dmark: db "+2e"  
aaf6 f1			.pastdmark: pop af  
aaf7			endm  
# End of macro DMARK
aaf7						CALLMONITOR 
aaf7 cd 7c 93			call break_point_state  
aafa				endm  
# End of macro CALLMONITOR
aafa					endif 
aafa			 
aafa			 
aafa			 
aafa			 
aafa			 
aafa				       NEXTW 
aafa c3 3f 9d			jp macro_next 
aafd				endm 
# End of macro NEXTW
aafd			 
aafd			.DEC2: 
aafd				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aafd 6f				db WORD_SYS_CORE+91             
aafe a9 ab			dw .GET2            
ab00 04				db 3 + 1 
ab01 .. 00			db "-2!",0              
ab05				endm 
# End of macro CWHEAD
ab05			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ab05			 
ab05			 
ab05					if DEBUG_FORTH_WORDS_KEY 
ab05						DMARK "-2s" 
ab05 f5				push af  
ab06 3a 1a ab			ld a, (.dmark)  
ab09 32 71 ee			ld (debug_mark),a  
ab0c 3a 1b ab			ld a, (.dmark+1)  
ab0f 32 72 ee			ld (debug_mark+1),a  
ab12 3a 1c ab			ld a, (.dmark+2)  
ab15 32 73 ee			ld (debug_mark+2),a  
ab18 18 03			jr .pastdmark  
ab1a ..			.dmark: db "-2s"  
ab1d f1			.pastdmark: pop af  
ab1e			endm  
# End of macro DMARK
ab1e						CALLMONITOR 
ab1e cd 7c 93			call break_point_state  
ab21				endm  
# End of macro CALLMONITOR
ab21					endif 
ab21			 
ab21					; Address 
ab21			 
ab21					FORTH_DSP_VALUEHL 
ab21 cd cd 9b			call macro_dsp_valuehl 
ab24				endm 
# End of macro FORTH_DSP_VALUEHL
ab24			 
ab24 e5					push hl    ; save address 
ab25			 
ab25					; load content into de 
ab25			 
ab25 5e					ld e,(hl) 
ab26 23					inc hl 
ab27 56					ld d, (hl) 
ab28			 
ab28					if DEBUG_FORTH_WORDS 
ab28						DMARK "-2a" 
ab28 f5				push af  
ab29 3a 3d ab			ld a, (.dmark)  
ab2c 32 71 ee			ld (debug_mark),a  
ab2f 3a 3e ab			ld a, (.dmark+1)  
ab32 32 72 ee			ld (debug_mark+1),a  
ab35 3a 3f ab			ld a, (.dmark+2)  
ab38 32 73 ee			ld (debug_mark+2),a  
ab3b 18 03			jr .pastdmark  
ab3d ..			.dmark: db "-2a"  
ab40 f1			.pastdmark: pop af  
ab41			endm  
# End of macro DMARK
ab41						CALLMONITOR 
ab41 cd 7c 93			call break_point_state  
ab44				endm  
# End of macro CALLMONITOR
ab44					endif 
ab44			 
ab44					FORTH_DSP_POP 
ab44 cd 85 9c			call macro_forth_dsp_pop 
ab47				endm 
# End of macro FORTH_DSP_POP
ab47			 
ab47					; Get value to remove 
ab47			 
ab47					FORTH_DSP_VALUE 
ab47 cd b6 9b			call macro_forth_dsp_value 
ab4a				endm 
# End of macro FORTH_DSP_VALUE
ab4a			 
ab4a					if DEBUG_FORTH_WORDS 
ab4a						DMARK "-2v" 
ab4a f5				push af  
ab4b 3a 5f ab			ld a, (.dmark)  
ab4e 32 71 ee			ld (debug_mark),a  
ab51 3a 60 ab			ld a, (.dmark+1)  
ab54 32 72 ee			ld (debug_mark+1),a  
ab57 3a 61 ab			ld a, (.dmark+2)  
ab5a 32 73 ee			ld (debug_mark+2),a  
ab5d 18 03			jr .pastdmark  
ab5f ..			.dmark: db "-2v"  
ab62 f1			.pastdmark: pop af  
ab63			endm  
# End of macro DMARK
ab63						CALLMONITOR 
ab63 cd 7c 93			call break_point_state  
ab66				endm  
# End of macro CALLMONITOR
ab66					endif 
ab66			 
ab66 eb					ex de, hl 
ab67 ed 52				sbc hl, de 
ab69			 
ab69					if DEBUG_FORTH_WORDS 
ab69						DMARK "-2d" 
ab69 f5				push af  
ab6a 3a 7e ab			ld a, (.dmark)  
ab6d 32 71 ee			ld (debug_mark),a  
ab70 3a 7f ab			ld a, (.dmark+1)  
ab73 32 72 ee			ld (debug_mark+1),a  
ab76 3a 80 ab			ld a, (.dmark+2)  
ab79 32 73 ee			ld (debug_mark+2),a  
ab7c 18 03			jr .pastdmark  
ab7e ..			.dmark: db "-2d"  
ab81 f1			.pastdmark: pop af  
ab82			endm  
# End of macro DMARK
ab82						CALLMONITOR 
ab82 cd 7c 93			call break_point_state  
ab85				endm  
# End of macro CALLMONITOR
ab85					endif 
ab85			 
ab85					; move result to de 
ab85			 
ab85 eb					ex de, hl 
ab86			 
ab86					; Address 
ab86			 
ab86 e1					pop hl 
ab87			 
ab87					; save it back 
ab87			 
ab87 73					ld (hl), e 
ab88 23					inc hl 
ab89 72					ld (hl), d 
ab8a			 
ab8a					if DEBUG_FORTH_WORDS 
ab8a						DMARK "-2e" 
ab8a f5				push af  
ab8b 3a 9f ab			ld a, (.dmark)  
ab8e 32 71 ee			ld (debug_mark),a  
ab91 3a a0 ab			ld a, (.dmark+1)  
ab94 32 72 ee			ld (debug_mark+1),a  
ab97 3a a1 ab			ld a, (.dmark+2)  
ab9a 32 73 ee			ld (debug_mark+2),a  
ab9d 18 03			jr .pastdmark  
ab9f ..			.dmark: db "-2e"  
aba2 f1			.pastdmark: pop af  
aba3			endm  
# End of macro DMARK
aba3						CALLMONITOR 
aba3 cd 7c 93			call break_point_state  
aba6				endm  
# End of macro CALLMONITOR
aba6					endif 
aba6			 
aba6			 
aba6			 
aba6			 
aba6			 
aba6				       NEXTW 
aba6 c3 3f 9d			jp macro_next 
aba9				endm 
# End of macro NEXTW
aba9			.GET2: 
aba9				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aba9 6f				db WORD_SYS_CORE+91             
abaa d9 ab			dw .BANG2            
abac 03				db 2 + 1 
abad .. 00			db "2@",0              
abb0				endm 
# End of macro CWHEAD
abb0			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
abb0					if DEBUG_FORTH_WORDS_KEY 
abb0						DMARK "2A_" 
abb0 f5				push af  
abb1 3a c5 ab			ld a, (.dmark)  
abb4 32 71 ee			ld (debug_mark),a  
abb7 3a c6 ab			ld a, (.dmark+1)  
abba 32 72 ee			ld (debug_mark+1),a  
abbd 3a c7 ab			ld a, (.dmark+2)  
abc0 32 73 ee			ld (debug_mark+2),a  
abc3 18 03			jr .pastdmark  
abc5 ..			.dmark: db "2A_"  
abc8 f1			.pastdmark: pop af  
abc9			endm  
# End of macro DMARK
abc9						CALLMONITOR 
abc9 cd 7c 93			call break_point_state  
abcc				endm  
# End of macro CALLMONITOR
abcc					endif 
abcc			 
abcc					FORTH_DSP_VALUEHL 
abcc cd cd 9b			call macro_dsp_valuehl 
abcf				endm 
# End of macro FORTH_DSP_VALUEHL
abcf			 
abcf 5e					ld e, (hl) 
abd0 23					inc hl 
abd1 56					ld d, (hl) 
abd2			 
abd2 eb					ex de, hl 
abd3			 
abd3 cd d6 99				call forth_push_numhl 
abd6			 
abd6				       NEXTW 
abd6 c3 3f 9d			jp macro_next 
abd9				endm 
# End of macro NEXTW
abd9			.BANG2: 
abd9				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
abd9 6f				db WORD_SYS_CORE+91             
abda 11 ac			dw .CONFIG            
abdc 03				db 2 + 1 
abdd .. 00			db "2!",0              
abe0				endm 
# End of macro CWHEAD
abe0			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
abe0					if DEBUG_FORTH_WORDS_KEY 
abe0						DMARK "2S_" 
abe0 f5				push af  
abe1 3a f5 ab			ld a, (.dmark)  
abe4 32 71 ee			ld (debug_mark),a  
abe7 3a f6 ab			ld a, (.dmark+1)  
abea 32 72 ee			ld (debug_mark+1),a  
abed 3a f7 ab			ld a, (.dmark+2)  
abf0 32 73 ee			ld (debug_mark+2),a  
abf3 18 03			jr .pastdmark  
abf5 ..			.dmark: db "2S_"  
abf8 f1			.pastdmark: pop af  
abf9			endm  
# End of macro DMARK
abf9						CALLMONITOR 
abf9 cd 7c 93			call break_point_state  
abfc				endm  
# End of macro CALLMONITOR
abfc					endif 
abfc			 
abfc					FORTH_DSP_VALUEHL 
abfc cd cd 9b			call macro_dsp_valuehl 
abff				endm 
# End of macro FORTH_DSP_VALUEHL
abff			 
abff e5					push hl   ; save address 
ac00			 
ac00			 
ac00					FORTH_DSP_POP 
ac00 cd 85 9c			call macro_forth_dsp_pop 
ac03				endm 
# End of macro FORTH_DSP_POP
ac03			 
ac03					 
ac03					FORTH_DSP_VALUEHL 
ac03 cd cd 9b			call macro_dsp_valuehl 
ac06				endm 
# End of macro FORTH_DSP_VALUEHL
ac06			 
ac06					FORTH_DSP_POP 
ac06 cd 85 9c			call macro_forth_dsp_pop 
ac09				endm 
# End of macro FORTH_DSP_POP
ac09			 
ac09 eb					ex de, hl    ; value now in de 
ac0a			 
ac0a e1					pop hl 
ac0b			 
ac0b 73					ld (hl), e 
ac0c			 
ac0c 23					inc hl 
ac0d			 
ac0d 72					ld (hl), d 
ac0e			 
ac0e			 
ac0e				       NEXTW 
ac0e c3 3f 9d			jp macro_next 
ac11				endm 
# End of macro NEXTW
ac11			.CONFIG: 
ac11				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ac11 6f				db WORD_SYS_CORE+91             
ac12 22 ac			dw .ENDCORE            
ac14 07				db 6 + 1 
ac15 .. 00			db "CONFIG",0              
ac1c				endm 
# End of macro CWHEAD
ac1c			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ac1c			 
ac1c cd db 91				call config 
ac1f					NEXTW 
ac1f c3 3f 9d			jp macro_next 
ac22				endm 
# End of macro NEXTW
ac22			.ENDCORE: 
ac22			 
ac22			; eof 
ac22			 
ac22			 
# End of file forth_words_core.asm
ac22			include "forth_words_flow.asm" 
ac22			 
ac22			; | ## Program Flow Words 
ac22			 
ac22			.IF: 
ac22				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ac22 1e				db WORD_SYS_CORE+10             
ac23 17 ad			dw .THEN            
ac25 03				db 2 + 1 
ac26 .. 00			db "IF",0              
ac29				endm 
# End of macro CWHEAD
ac29			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ac29			; 
ac29					if DEBUG_FORTH_WORDS_KEY 
ac29						DMARK "IF." 
ac29 f5				push af  
ac2a 3a 3e ac			ld a, (.dmark)  
ac2d 32 71 ee			ld (debug_mark),a  
ac30 3a 3f ac			ld a, (.dmark+1)  
ac33 32 72 ee			ld (debug_mark+1),a  
ac36 3a 40 ac			ld a, (.dmark+2)  
ac39 32 73 ee			ld (debug_mark+2),a  
ac3c 18 03			jr .pastdmark  
ac3e ..			.dmark: db "IF."  
ac41 f1			.pastdmark: pop af  
ac42			endm  
# End of macro DMARK
ac42						CALLMONITOR 
ac42 cd 7c 93			call break_point_state  
ac45				endm  
# End of macro CALLMONITOR
ac45					endif 
ac45			; eval TOS 
ac45			 
ac45				FORTH_DSP_VALUEHL 
ac45 cd cd 9b			call macro_dsp_valuehl 
ac48				endm 
# End of macro FORTH_DSP_VALUEHL
ac48			 
ac48			;	push hl 
ac48				FORTH_DSP_POP 
ac48 cd 85 9c			call macro_forth_dsp_pop 
ac4b				endm 
# End of macro FORTH_DSP_POP
ac4b			;	pop hl 
ac4b			 
ac4b					if DEBUG_FORTH_WORDS 
ac4b						DMARK "IF1" 
ac4b f5				push af  
ac4c 3a 60 ac			ld a, (.dmark)  
ac4f 32 71 ee			ld (debug_mark),a  
ac52 3a 61 ac			ld a, (.dmark+1)  
ac55 32 72 ee			ld (debug_mark+1),a  
ac58 3a 62 ac			ld a, (.dmark+2)  
ac5b 32 73 ee			ld (debug_mark+2),a  
ac5e 18 03			jr .pastdmark  
ac60 ..			.dmark: db "IF1"  
ac63 f1			.pastdmark: pop af  
ac64			endm  
# End of macro DMARK
ac64						CALLMONITOR 
ac64 cd 7c 93			call break_point_state  
ac67				endm  
# End of macro CALLMONITOR
ac67					endif 
ac67 b7				or a        ; clear carry flag 
ac68 11 00 00			ld de, 0 
ac6b eb				ex de,hl 
ac6c ed 52			sbc hl, de 
ac6e c2 f8 ac			jp nz, .iftrue 
ac71			 
ac71					if DEBUG_FORTH_WORDS 
ac71						DMARK "IF2" 
ac71 f5				push af  
ac72 3a 86 ac			ld a, (.dmark)  
ac75 32 71 ee			ld (debug_mark),a  
ac78 3a 87 ac			ld a, (.dmark+1)  
ac7b 32 72 ee			ld (debug_mark+1),a  
ac7e 3a 88 ac			ld a, (.dmark+2)  
ac81 32 73 ee			ld (debug_mark+2),a  
ac84 18 03			jr .pastdmark  
ac86 ..			.dmark: db "IF2"  
ac89 f1			.pastdmark: pop af  
ac8a			endm  
# End of macro DMARK
ac8a						CALLMONITOR 
ac8a cd 7c 93			call break_point_state  
ac8d				endm  
# End of macro CALLMONITOR
ac8d					endif 
ac8d			 
ac8d			; if not true then skip to THEN 
ac8d			 
ac8d				; TODO get tok_ptr 
ac8d				; TODO consume toks until we get to THEN 
ac8d			 
ac8d 2a 58 e6			ld hl, (os_tok_ptr) 
ac90					if DEBUG_FORTH_WORDS 
ac90						DMARK "IF3" 
ac90 f5				push af  
ac91 3a a5 ac			ld a, (.dmark)  
ac94 32 71 ee			ld (debug_mark),a  
ac97 3a a6 ac			ld a, (.dmark+1)  
ac9a 32 72 ee			ld (debug_mark+1),a  
ac9d 3a a7 ac			ld a, (.dmark+2)  
aca0 32 73 ee			ld (debug_mark+2),a  
aca3 18 03			jr .pastdmark  
aca5 ..			.dmark: db "IF3"  
aca8 f1			.pastdmark: pop af  
aca9			endm  
# End of macro DMARK
aca9						CALLMONITOR 
aca9 cd 7c 93			call break_point_state  
acac				endm  
# End of macro CALLMONITOR
acac						 
acac					endif 
acac 11 f3 ac			ld de, .ifthen 
acaf					if DEBUG_FORTH_WORDS 
acaf						DMARK "IF4" 
acaf f5				push af  
acb0 3a c4 ac			ld a, (.dmark)  
acb3 32 71 ee			ld (debug_mark),a  
acb6 3a c5 ac			ld a, (.dmark+1)  
acb9 32 72 ee			ld (debug_mark+1),a  
acbc 3a c6 ac			ld a, (.dmark+2)  
acbf 32 73 ee			ld (debug_mark+2),a  
acc2 18 03			jr .pastdmark  
acc4 ..			.dmark: db "IF4"  
acc7 f1			.pastdmark: pop af  
acc8			endm  
# End of macro DMARK
acc8						CALLMONITOR 
acc8 cd 7c 93			call break_point_state  
accb				endm  
# End of macro CALLMONITOR
accb					endif 
accb cd 5a 9e			call findnexttok  
acce			 
acce					if DEBUG_FORTH_WORDS 
acce						DMARK "IF5" 
acce f5				push af  
accf 3a e3 ac			ld a, (.dmark)  
acd2 32 71 ee			ld (debug_mark),a  
acd5 3a e4 ac			ld a, (.dmark+1)  
acd8 32 72 ee			ld (debug_mark+1),a  
acdb 3a e5 ac			ld a, (.dmark+2)  
acde 32 73 ee			ld (debug_mark+2),a  
ace1 18 03			jr .pastdmark  
ace3 ..			.dmark: db "IF5"  
ace6 f1			.pastdmark: pop af  
ace7			endm  
# End of macro DMARK
ace7						CALLMONITOR 
ace7 cd 7c 93			call break_point_state  
acea				endm  
# End of macro CALLMONITOR
acea					endif 
acea				; TODO replace below with ; exec using tok_ptr 
acea 22 58 e6			ld (os_tok_ptr), hl 
aced c3 d0 9d			jp exec1 
acf0				NEXTW 
acf0 c3 3f 9d			jp macro_next 
acf3				endm 
# End of macro NEXTW
acf3			 
acf3 .. 00		.ifthen:  db "THEN",0 
acf8			 
acf8			.iftrue:		 
acf8				; Exec next words normally 
acf8			 
acf8				; if true then exec following IF as normal 
acf8					if DEBUG_FORTH_WORDS 
acf8						DMARK "IFT" 
acf8 f5				push af  
acf9 3a 0d ad			ld a, (.dmark)  
acfc 32 71 ee			ld (debug_mark),a  
acff 3a 0e ad			ld a, (.dmark+1)  
ad02 32 72 ee			ld (debug_mark+1),a  
ad05 3a 0f ad			ld a, (.dmark+2)  
ad08 32 73 ee			ld (debug_mark+2),a  
ad0b 18 03			jr .pastdmark  
ad0d ..			.dmark: db "IFT"  
ad10 f1			.pastdmark: pop af  
ad11			endm  
# End of macro DMARK
ad11						CALLMONITOR 
ad11 cd 7c 93			call break_point_state  
ad14				endm  
# End of macro CALLMONITOR
ad14					endif 
ad14			 
ad14					NEXTW 
ad14 c3 3f 9d			jp macro_next 
ad17				endm 
# End of macro NEXTW
ad17			.THEN: 
ad17				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ad17 1f				db WORD_SYS_CORE+11             
ad18 3f ad			dw .ELSE            
ad1a 05				db 4 + 1 
ad1b .. 00			db "THEN",0              
ad20				endm 
# End of macro CWHEAD
ad20			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ad20					if DEBUG_FORTH_WORDS_KEY 
ad20						DMARK "THN" 
ad20 f5				push af  
ad21 3a 35 ad			ld a, (.dmark)  
ad24 32 71 ee			ld (debug_mark),a  
ad27 3a 36 ad			ld a, (.dmark+1)  
ad2a 32 72 ee			ld (debug_mark+1),a  
ad2d 3a 37 ad			ld a, (.dmark+2)  
ad30 32 73 ee			ld (debug_mark+2),a  
ad33 18 03			jr .pastdmark  
ad35 ..			.dmark: db "THN"  
ad38 f1			.pastdmark: pop af  
ad39			endm  
# End of macro DMARK
ad39						CALLMONITOR 
ad39 cd 7c 93			call break_point_state  
ad3c				endm  
# End of macro CALLMONITOR
ad3c					endif 
ad3c					NEXTW 
ad3c c3 3f 9d			jp macro_next 
ad3f				endm 
# End of macro NEXTW
ad3f			.ELSE: 
ad3f				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ad3f 20				db WORD_SYS_CORE+12             
ad40 67 ad			dw .DO            
ad42 03				db 2 + 1 
ad43 .. 00			db "ELSE",0              
ad48				endm 
# End of macro CWHEAD
ad48			; | ELSE ( -- ) Not supported - does nothing | TODO 
ad48			 
ad48					if DEBUG_FORTH_WORDS_KEY 
ad48						DMARK "ELS" 
ad48 f5				push af  
ad49 3a 5d ad			ld a, (.dmark)  
ad4c 32 71 ee			ld (debug_mark),a  
ad4f 3a 5e ad			ld a, (.dmark+1)  
ad52 32 72 ee			ld (debug_mark+1),a  
ad55 3a 5f ad			ld a, (.dmark+2)  
ad58 32 73 ee			ld (debug_mark+2),a  
ad5b 18 03			jr .pastdmark  
ad5d ..			.dmark: db "ELS"  
ad60 f1			.pastdmark: pop af  
ad61			endm  
# End of macro DMARK
ad61						CALLMONITOR 
ad61 cd 7c 93			call break_point_state  
ad64				endm  
# End of macro CALLMONITOR
ad64					endif 
ad64			 
ad64			 
ad64					NEXTW 
ad64 c3 3f 9d			jp macro_next 
ad67				endm 
# End of macro NEXTW
ad67			.DO: 
ad67				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ad67 21				db WORD_SYS_CORE+13             
ad68 8e ae			dw .LOOP            
ad6a 03				db 2 + 1 
ad6b .. 00			db "DO",0              
ad6e				endm 
# End of macro CWHEAD
ad6e			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ad6e			 
ad6e					if DEBUG_FORTH_WORDS_KEY 
ad6e						DMARK "DO." 
ad6e f5				push af  
ad6f 3a 83 ad			ld a, (.dmark)  
ad72 32 71 ee			ld (debug_mark),a  
ad75 3a 84 ad			ld a, (.dmark+1)  
ad78 32 72 ee			ld (debug_mark+1),a  
ad7b 3a 85 ad			ld a, (.dmark+2)  
ad7e 32 73 ee			ld (debug_mark+2),a  
ad81 18 03			jr .pastdmark  
ad83 ..			.dmark: db "DO."  
ad86 f1			.pastdmark: pop af  
ad87			endm  
# End of macro DMARK
ad87						CALLMONITOR 
ad87 cd 7c 93			call break_point_state  
ad8a				endm  
# End of macro CALLMONITOR
ad8a					endif 
ad8a			;  push pc to rsp stack past the DO 
ad8a			 
ad8a 2a 58 e6				ld hl, (os_tok_ptr) 
ad8d 23					inc hl   ; D 
ad8e 23					inc hl  ; O 
ad8f 23					inc hl   ; null 
ad90					if DEBUG_FORTH_WORDS 
ad90						DMARK "DO2" 
ad90 f5				push af  
ad91 3a a5 ad			ld a, (.dmark)  
ad94 32 71 ee			ld (debug_mark),a  
ad97 3a a6 ad			ld a, (.dmark+1)  
ad9a 32 72 ee			ld (debug_mark+1),a  
ad9d 3a a7 ad			ld a, (.dmark+2)  
ada0 32 73 ee			ld (debug_mark+2),a  
ada3 18 03			jr .pastdmark  
ada5 ..			.dmark: db "DO2"  
ada8 f1			.pastdmark: pop af  
ada9			endm  
# End of macro DMARK
ada9						CALLMONITOR 
ada9 cd 7c 93			call break_point_state  
adac				endm  
# End of macro CALLMONITOR
adac					endif 
adac					FORTH_RSP_NEXT 
adac cd 7d 99			call macro_forth_rsp_next 
adaf				endm 
# End of macro FORTH_RSP_NEXT
adaf					if DEBUG_FORTH_WORDS 
adaf						DMARK "DO3" 
adaf f5				push af  
adb0 3a c4 ad			ld a, (.dmark)  
adb3 32 71 ee			ld (debug_mark),a  
adb6 3a c5 ad			ld a, (.dmark+1)  
adb9 32 72 ee			ld (debug_mark+1),a  
adbc 3a c6 ad			ld a, (.dmark+2)  
adbf 32 73 ee			ld (debug_mark+2),a  
adc2 18 03			jr .pastdmark  
adc4 ..			.dmark: db "DO3"  
adc7 f1			.pastdmark: pop af  
adc8			endm  
# End of macro DMARK
adc8						CALLMONITOR 
adc8 cd 7c 93			call break_point_state  
adcb				endm  
# End of macro CALLMONITOR
adcb					endif 
adcb			 
adcb					;if DEBUG_FORTH_WORDS 
adcb				;		push hl 
adcb			;		endif  
adcb			 
adcb			; get counters from data stack 
adcb			 
adcb			 
adcb					FORTH_DSP_VALUEHL 
adcb cd cd 9b			call macro_dsp_valuehl 
adce				endm 
# End of macro FORTH_DSP_VALUEHL
adce e5					push hl		 ; hl now has starting counter which needs to be tos 
adcf			 
adcf					if DEBUG_FORTH_WORDS 
adcf						DMARK "DO4" 
adcf f5				push af  
add0 3a e4 ad			ld a, (.dmark)  
add3 32 71 ee			ld (debug_mark),a  
add6 3a e5 ad			ld a, (.dmark+1)  
add9 32 72 ee			ld (debug_mark+1),a  
addc 3a e6 ad			ld a, (.dmark+2)  
addf 32 73 ee			ld (debug_mark+2),a  
ade2 18 03			jr .pastdmark  
ade4 ..			.dmark: db "DO4"  
ade7 f1			.pastdmark: pop af  
ade8			endm  
# End of macro DMARK
ade8						CALLMONITOR 
ade8 cd 7c 93			call break_point_state  
adeb				endm  
# End of macro CALLMONITOR
adeb					endif 
adeb					FORTH_DSP_POP 
adeb cd 85 9c			call macro_forth_dsp_pop 
adee				endm 
# End of macro FORTH_DSP_POP
adee			 
adee					if DEBUG_FORTH_WORDS 
adee						DMARK "DO5" 
adee f5				push af  
adef 3a 03 ae			ld a, (.dmark)  
adf2 32 71 ee			ld (debug_mark),a  
adf5 3a 04 ae			ld a, (.dmark+1)  
adf8 32 72 ee			ld (debug_mark+1),a  
adfb 3a 05 ae			ld a, (.dmark+2)  
adfe 32 73 ee			ld (debug_mark+2),a  
ae01 18 03			jr .pastdmark  
ae03 ..			.dmark: db "DO5"  
ae06 f1			.pastdmark: pop af  
ae07			endm  
# End of macro DMARK
ae07						CALLMONITOR 
ae07 cd 7c 93			call break_point_state  
ae0a				endm  
# End of macro CALLMONITOR
ae0a					endif 
ae0a			 
ae0a					FORTH_DSP_VALUEHL 
ae0a cd cd 9b			call macro_dsp_valuehl 
ae0d				endm 
# End of macro FORTH_DSP_VALUEHL
ae0d			;		push hl		 ; hl now has starting limit counter 
ae0d			 
ae0d					if DEBUG_FORTH_WORDS 
ae0d						DMARK "DO6" 
ae0d f5				push af  
ae0e 3a 22 ae			ld a, (.dmark)  
ae11 32 71 ee			ld (debug_mark),a  
ae14 3a 23 ae			ld a, (.dmark+1)  
ae17 32 72 ee			ld (debug_mark+1),a  
ae1a 3a 24 ae			ld a, (.dmark+2)  
ae1d 32 73 ee			ld (debug_mark+2),a  
ae20 18 03			jr .pastdmark  
ae22 ..			.dmark: db "DO6"  
ae25 f1			.pastdmark: pop af  
ae26			endm  
# End of macro DMARK
ae26						CALLMONITOR 
ae26 cd 7c 93			call break_point_state  
ae29				endm  
# End of macro CALLMONITOR
ae29					endif 
ae29					FORTH_DSP_POP 
ae29 cd 85 9c			call macro_forth_dsp_pop 
ae2c				endm 
# End of macro FORTH_DSP_POP
ae2c			 
ae2c			; put counters on the loop stack 
ae2c			 
ae2c			;		pop hl			 ; limit counter 
ae2c d1					pop de			; start counter 
ae2d			 
ae2d					; push limit counter 
ae2d			 
ae2d					if DEBUG_FORTH_WORDS 
ae2d						DMARK "DO7" 
ae2d f5				push af  
ae2e 3a 42 ae			ld a, (.dmark)  
ae31 32 71 ee			ld (debug_mark),a  
ae34 3a 43 ae			ld a, (.dmark+1)  
ae37 32 72 ee			ld (debug_mark+1),a  
ae3a 3a 44 ae			ld a, (.dmark+2)  
ae3d 32 73 ee			ld (debug_mark+2),a  
ae40 18 03			jr .pastdmark  
ae42 ..			.dmark: db "DO7"  
ae45 f1			.pastdmark: pop af  
ae46			endm  
# End of macro DMARK
ae46						CALLMONITOR 
ae46 cd 7c 93			call break_point_state  
ae49				endm  
# End of macro CALLMONITOR
ae49					endif 
ae49					FORTH_LOOP_NEXT 
ae49 cd fe 9b			call macro_forth_loop_next 
ae4c				endm 
# End of macro FORTH_LOOP_NEXT
ae4c			 
ae4c					; push start counter 
ae4c			 
ae4c eb					ex de, hl 
ae4d					if DEBUG_FORTH_WORDS 
ae4d						DMARK "DO7" 
ae4d f5				push af  
ae4e 3a 62 ae			ld a, (.dmark)  
ae51 32 71 ee			ld (debug_mark),a  
ae54 3a 63 ae			ld a, (.dmark+1)  
ae57 32 72 ee			ld (debug_mark+1),a  
ae5a 3a 64 ae			ld a, (.dmark+2)  
ae5d 32 73 ee			ld (debug_mark+2),a  
ae60 18 03			jr .pastdmark  
ae62 ..			.dmark: db "DO7"  
ae65 f1			.pastdmark: pop af  
ae66			endm  
# End of macro DMARK
ae66						CALLMONITOR 
ae66 cd 7c 93			call break_point_state  
ae69				endm  
# End of macro CALLMONITOR
ae69					endif 
ae69					FORTH_LOOP_NEXT 
ae69 cd fe 9b			call macro_forth_loop_next 
ae6c				endm 
# End of macro FORTH_LOOP_NEXT
ae6c			 
ae6c			 
ae6c					; init first round of I counter 
ae6c			 
ae6c 22 7c e6				ld (os_current_i), hl 
ae6f			 
ae6f					if DEBUG_FORTH_WORDS 
ae6f						DMARK "DO8" 
ae6f f5				push af  
ae70 3a 84 ae			ld a, (.dmark)  
ae73 32 71 ee			ld (debug_mark),a  
ae76 3a 85 ae			ld a, (.dmark+1)  
ae79 32 72 ee			ld (debug_mark+1),a  
ae7c 3a 86 ae			ld a, (.dmark+2)  
ae7f 32 73 ee			ld (debug_mark+2),a  
ae82 18 03			jr .pastdmark  
ae84 ..			.dmark: db "DO8"  
ae87 f1			.pastdmark: pop af  
ae88			endm  
# End of macro DMARK
ae88						CALLMONITOR 
ae88 cd 7c 93			call break_point_state  
ae8b				endm  
# End of macro CALLMONITOR
ae8b					endif 
ae8b			 
ae8b					NEXTW 
ae8b c3 3f 9d			jp macro_next 
ae8e				endm 
# End of macro NEXTW
ae8e			.LOOP: 
ae8e				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ae8e 22				db WORD_SYS_CORE+14             
ae8f a6 af			dw .I            
ae91 05				db 4 + 1 
ae92 .. 00			db "LOOP",0              
ae97				endm 
# End of macro CWHEAD
ae97			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ae97			 
ae97				; pop tos as current loop count to hl 
ae97			 
ae97				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ae97			 
ae97				FORTH_LOOP_TOS 
ae97 cd 31 9c			call macro_forth_loop_tos 
ae9a				endm 
# End of macro FORTH_LOOP_TOS
ae9a e5				push hl 
ae9b			 
ae9b					if DEBUG_FORTH_WORDS_KEY 
ae9b						DMARK "LOP" 
ae9b f5				push af  
ae9c 3a b0 ae			ld a, (.dmark)  
ae9f 32 71 ee			ld (debug_mark),a  
aea2 3a b1 ae			ld a, (.dmark+1)  
aea5 32 72 ee			ld (debug_mark+1),a  
aea8 3a b2 ae			ld a, (.dmark+2)  
aeab 32 73 ee			ld (debug_mark+2),a  
aeae 18 03			jr .pastdmark  
aeb0 ..			.dmark: db "LOP"  
aeb3 f1			.pastdmark: pop af  
aeb4			endm  
# End of macro DMARK
aeb4						CALLMONITOR 
aeb4 cd 7c 93			call break_point_state  
aeb7				endm  
# End of macro CALLMONITOR
aeb7					endif 
aeb7				; next item on the stack is the limit. get it 
aeb7			 
aeb7			 
aeb7				FORTH_LOOP_POP 
aeb7 cd 3b 9c			call macro_forth_loop_pop 
aeba				endm 
# End of macro FORTH_LOOP_POP
aeba			 
aeba				FORTH_LOOP_TOS 
aeba cd 31 9c			call macro_forth_loop_tos 
aebd				endm 
# End of macro FORTH_LOOP_TOS
aebd			 
aebd d1				pop de		 ; de = i, hl = limit 
aebe			 
aebe					if DEBUG_FORTH_WORDS 
aebe						DMARK "LP1" 
aebe f5				push af  
aebf 3a d3 ae			ld a, (.dmark)  
aec2 32 71 ee			ld (debug_mark),a  
aec5 3a d4 ae			ld a, (.dmark+1)  
aec8 32 72 ee			ld (debug_mark+1),a  
aecb 3a d5 ae			ld a, (.dmark+2)  
aece 32 73 ee			ld (debug_mark+2),a  
aed1 18 03			jr .pastdmark  
aed3 ..			.dmark: db "LP1"  
aed6 f1			.pastdmark: pop af  
aed7			endm  
# End of macro DMARK
aed7						CALLMONITOR 
aed7 cd 7c 93			call break_point_state  
aeda				endm  
# End of macro CALLMONITOR
aeda					endif 
aeda			 
aeda				; go back to previous word 
aeda			 
aeda d5				push de    ; save I for inc later 
aedb			 
aedb			 
aedb				; get limit 
aedb				;  is I at limit? 
aedb			 
aedb			 
aedb					if DEBUG_FORTH_WORDS 
aedb						DMARK "LP1" 
aedb f5				push af  
aedc 3a f0 ae			ld a, (.dmark)  
aedf 32 71 ee			ld (debug_mark),a  
aee2 3a f1 ae			ld a, (.dmark+1)  
aee5 32 72 ee			ld (debug_mark+1),a  
aee8 3a f2 ae			ld a, (.dmark+2)  
aeeb 32 73 ee			ld (debug_mark+2),a  
aeee 18 03			jr .pastdmark  
aef0 ..			.dmark: db "LP1"  
aef3 f1			.pastdmark: pop af  
aef4			endm  
# End of macro DMARK
aef4						CALLMONITOR 
aef4 cd 7c 93			call break_point_state  
aef7				endm  
# End of macro CALLMONITOR
aef7					endif 
aef7			 
aef7 ed 52			sbc hl, de 
aef9			 
aef9			 
aef9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
aef9			 
aef9 20 26				jr nz, .loopnotdone 
aefb			 
aefb e1				pop hl   ; get rid of saved I 
aefc				FORTH_LOOP_POP     ; get rid of limit 
aefc cd 3b 9c			call macro_forth_loop_pop 
aeff				endm 
# End of macro FORTH_LOOP_POP
aeff			 
aeff				FORTH_RSP_POP     ; get rid of DO ptr 
aeff cd 9e 99			call macro_forth_rsp_pop 
af02				endm 
# End of macro FORTH_RSP_POP
af02			 
af02			if DEBUG_FORTH_WORDS 
af02						DMARK "LP>" 
af02 f5				push af  
af03 3a 17 af			ld a, (.dmark)  
af06 32 71 ee			ld (debug_mark),a  
af09 3a 18 af			ld a, (.dmark+1)  
af0c 32 72 ee			ld (debug_mark+1),a  
af0f 3a 19 af			ld a, (.dmark+2)  
af12 32 73 ee			ld (debug_mark+2),a  
af15 18 03			jr .pastdmark  
af17 ..			.dmark: db "LP>"  
af1a f1			.pastdmark: pop af  
af1b			endm  
# End of macro DMARK
af1b				CALLMONITOR 
af1b cd 7c 93			call break_point_state  
af1e				endm  
# End of macro CALLMONITOR
af1e			endif 
af1e			 
af1e					NEXTW 
af1e c3 3f 9d			jp macro_next 
af21				endm 
# End of macro NEXTW
af21				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af21			 
af21			.loopnotdone: 
af21			 
af21 e1				pop hl    ; get I 
af22 23				inc hl 
af23			 
af23			   	; save new I 
af23			 
af23			 
af23					; set I counter 
af23			 
af23 22 7c e6				ld (os_current_i), hl 
af26			 
af26					if DEBUG_FORTH_WORDS 
af26						DMARK "LPN" 
af26 f5				push af  
af27 3a 3b af			ld a, (.dmark)  
af2a 32 71 ee			ld (debug_mark),a  
af2d 3a 3c af			ld a, (.dmark+1)  
af30 32 72 ee			ld (debug_mark+1),a  
af33 3a 3d af			ld a, (.dmark+2)  
af36 32 73 ee			ld (debug_mark+2),a  
af39 18 03			jr .pastdmark  
af3b ..			.dmark: db "LPN"  
af3e f1			.pastdmark: pop af  
af3f			endm  
# End of macro DMARK
af3f					CALLMONITOR 
af3f cd 7c 93			call break_point_state  
af42				endm  
# End of macro CALLMONITOR
af42					endif 
af42					 
af42				FORTH_LOOP_NEXT 
af42 cd fe 9b			call macro_forth_loop_next 
af45				endm 
# End of macro FORTH_LOOP_NEXT
af45			 
af45			 
af45					if DEBUG_FORTH_WORDS 
af45 eb						ex de,hl 
af46					endif 
af46			 
af46			;	; get DO ptr 
af46			; 
af46					if DEBUG_FORTH_WORDS 
af46						DMARK "LP7" 
af46 f5				push af  
af47 3a 5b af			ld a, (.dmark)  
af4a 32 71 ee			ld (debug_mark),a  
af4d 3a 5c af			ld a, (.dmark+1)  
af50 32 72 ee			ld (debug_mark+1),a  
af53 3a 5d af			ld a, (.dmark+2)  
af56 32 73 ee			ld (debug_mark+2),a  
af59 18 03			jr .pastdmark  
af5b ..			.dmark: db "LP7"  
af5e f1			.pastdmark: pop af  
af5f			endm  
# End of macro DMARK
af5f					CALLMONITOR 
af5f cd 7c 93			call break_point_state  
af62				endm  
# End of macro CALLMONITOR
af62					endif 
af62				FORTH_RSP_TOS 
af62 cd 94 99			call macro_forth_rsp_tos 
af65				endm 
# End of macro FORTH_RSP_TOS
af65			 
af65					if DEBUG_FORTH_WORDS 
af65						DMARK "LP8" 
af65 f5				push af  
af66 3a 7a af			ld a, (.dmark)  
af69 32 71 ee			ld (debug_mark),a  
af6c 3a 7b af			ld a, (.dmark+1)  
af6f 32 72 ee			ld (debug_mark+1),a  
af72 3a 7c af			ld a, (.dmark+2)  
af75 32 73 ee			ld (debug_mark+2),a  
af78 18 03			jr .pastdmark  
af7a ..			.dmark: db "LP8"  
af7d f1			.pastdmark: pop af  
af7e			endm  
# End of macro DMARK
af7e					CALLMONITOR 
af7e cd 7c 93			call break_point_state  
af81				endm  
# End of macro CALLMONITOR
af81					endif 
af81				;push hl 
af81			 
af81				; not going to DO any more 
af81				; get rid of the RSP pointer as DO will add it back in 
af81				;FORTH_RSP_POP 
af81				;pop hl 
af81			 
af81				;ld hl,(cli_ret_sp) 
af81				;ld e, (hl) 
af81				;inc hl 
af81				;ld d, (hl) 
af81				;ex de,hl 
af81 22 58 e6			ld (os_tok_ptr), hl 
af84					if DEBUG_FORTH_WORDS 
af84						DMARK "LP<" 
af84 f5				push af  
af85 3a 99 af			ld a, (.dmark)  
af88 32 71 ee			ld (debug_mark),a  
af8b 3a 9a af			ld a, (.dmark+1)  
af8e 32 72 ee			ld (debug_mark+1),a  
af91 3a 9b af			ld a, (.dmark+2)  
af94 32 73 ee			ld (debug_mark+2),a  
af97 18 03			jr .pastdmark  
af99 ..			.dmark: db "LP<"  
af9c f1			.pastdmark: pop af  
af9d			endm  
# End of macro DMARK
af9d					CALLMONITOR 
af9d cd 7c 93			call break_point_state  
afa0				endm  
# End of macro CALLMONITOR
afa0				endif 
afa0 c3 d0 9d			jp exec1 
afa3			 
afa3					 
afa3			 
afa3			 
afa3					NEXTW 
afa3 c3 3f 9d			jp macro_next 
afa6				endm 
# End of macro NEXTW
afa6			.I:  
afa6			 
afa6				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
afa6 5e				db WORD_SYS_CORE+74             
afa7 d1 af			dw .DLOOP            
afa9 02				db 1 + 1 
afaa .. 00			db "I",0              
afac				endm 
# End of macro CWHEAD
afac			; | I ( -- ) Current loop counter | DONE 
afac					if DEBUG_FORTH_WORDS_KEY 
afac						DMARK "I.." 
afac f5				push af  
afad 3a c1 af			ld a, (.dmark)  
afb0 32 71 ee			ld (debug_mark),a  
afb3 3a c2 af			ld a, (.dmark+1)  
afb6 32 72 ee			ld (debug_mark+1),a  
afb9 3a c3 af			ld a, (.dmark+2)  
afbc 32 73 ee			ld (debug_mark+2),a  
afbf 18 03			jr .pastdmark  
afc1 ..			.dmark: db "I.."  
afc4 f1			.pastdmark: pop af  
afc5			endm  
# End of macro DMARK
afc5						CALLMONITOR 
afc5 cd 7c 93			call break_point_state  
afc8				endm  
# End of macro CALLMONITOR
afc8					endif 
afc8			 
afc8 2a 7c e6				ld hl,(os_current_i) 
afcb cd d6 99				call forth_push_numhl 
afce			 
afce					NEXTW 
afce c3 3f 9d			jp macro_next 
afd1				endm 
# End of macro NEXTW
afd1			.DLOOP: 
afd1				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
afd1 5f				db WORD_SYS_CORE+75             
afd2 b2 b0			dw .REPEAT            
afd4 06				db 5 + 1 
afd5 .. 00			db "-LOOP",0              
afdb				endm 
# End of macro CWHEAD
afdb			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
afdb				; pop tos as current loop count to hl 
afdb					if DEBUG_FORTH_WORDS_KEY 
afdb						DMARK "-LP" 
afdb f5				push af  
afdc 3a f0 af			ld a, (.dmark)  
afdf 32 71 ee			ld (debug_mark),a  
afe2 3a f1 af			ld a, (.dmark+1)  
afe5 32 72 ee			ld (debug_mark+1),a  
afe8 3a f2 af			ld a, (.dmark+2)  
afeb 32 73 ee			ld (debug_mark+2),a  
afee 18 03			jr .pastdmark  
aff0 ..			.dmark: db "-LP"  
aff3 f1			.pastdmark: pop af  
aff4			endm  
# End of macro DMARK
aff4						CALLMONITOR 
aff4 cd 7c 93			call break_point_state  
aff7				endm  
# End of macro CALLMONITOR
aff7					endif 
aff7			 
aff7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aff7			 
aff7				FORTH_LOOP_TOS 
aff7 cd 31 9c			call macro_forth_loop_tos 
affa				endm 
# End of macro FORTH_LOOP_TOS
affa e5				push hl 
affb			 
affb					if DEBUG_FORTH_WORDS 
affb						DMARK "-LP" 
affb f5				push af  
affc 3a 10 b0			ld a, (.dmark)  
afff 32 71 ee			ld (debug_mark),a  
b002 3a 11 b0			ld a, (.dmark+1)  
b005 32 72 ee			ld (debug_mark+1),a  
b008 3a 12 b0			ld a, (.dmark+2)  
b00b 32 73 ee			ld (debug_mark+2),a  
b00e 18 03			jr .pastdmark  
b010 ..			.dmark: db "-LP"  
b013 f1			.pastdmark: pop af  
b014			endm  
# End of macro DMARK
b014						CALLMONITOR 
b014 cd 7c 93			call break_point_state  
b017				endm  
# End of macro CALLMONITOR
b017					endif 
b017				; next item on the stack is the limit. get it 
b017			 
b017			 
b017				FORTH_LOOP_POP 
b017 cd 3b 9c			call macro_forth_loop_pop 
b01a				endm 
# End of macro FORTH_LOOP_POP
b01a			 
b01a				FORTH_LOOP_TOS 
b01a cd 31 9c			call macro_forth_loop_tos 
b01d				endm 
# End of macro FORTH_LOOP_TOS
b01d			 
b01d d1				pop de		 ; de = i, hl = limit 
b01e			 
b01e					if DEBUG_FORTH_WORDS 
b01e						DMARK "-L1" 
b01e f5				push af  
b01f 3a 33 b0			ld a, (.dmark)  
b022 32 71 ee			ld (debug_mark),a  
b025 3a 34 b0			ld a, (.dmark+1)  
b028 32 72 ee			ld (debug_mark+1),a  
b02b 3a 35 b0			ld a, (.dmark+2)  
b02e 32 73 ee			ld (debug_mark+2),a  
b031 18 03			jr .pastdmark  
b033 ..			.dmark: db "-L1"  
b036 f1			.pastdmark: pop af  
b037			endm  
# End of macro DMARK
b037						CALLMONITOR 
b037 cd 7c 93			call break_point_state  
b03a				endm  
# End of macro CALLMONITOR
b03a					endif 
b03a			 
b03a				; go back to previous word 
b03a			 
b03a d5				push de    ; save I for inc later 
b03b			 
b03b			 
b03b				; get limit 
b03b				;  is I at limit? 
b03b			 
b03b			 
b03b					if DEBUG_FORTH_WORDS 
b03b						DMARK "-L1" 
b03b f5				push af  
b03c 3a 50 b0			ld a, (.dmark)  
b03f 32 71 ee			ld (debug_mark),a  
b042 3a 51 b0			ld a, (.dmark+1)  
b045 32 72 ee			ld (debug_mark+1),a  
b048 3a 52 b0			ld a, (.dmark+2)  
b04b 32 73 ee			ld (debug_mark+2),a  
b04e 18 03			jr .pastdmark  
b050 ..			.dmark: db "-L1"  
b053 f1			.pastdmark: pop af  
b054			endm  
# End of macro DMARK
b054						CALLMONITOR 
b054 cd 7c 93			call break_point_state  
b057				endm  
# End of macro CALLMONITOR
b057					endif 
b057			 
b057 ed 52			sbc hl, de 
b059			 
b059			 
b059				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b059			 
b059 20 26				jr nz, .mloopnotdone 
b05b			 
b05b e1				pop hl   ; get rid of saved I 
b05c				FORTH_LOOP_POP     ; get rid of limit 
b05c cd 3b 9c			call macro_forth_loop_pop 
b05f				endm 
# End of macro FORTH_LOOP_POP
b05f			 
b05f				FORTH_RSP_POP     ; get rid of DO ptr 
b05f cd 9e 99			call macro_forth_rsp_pop 
b062				endm 
# End of macro FORTH_RSP_POP
b062			 
b062			if DEBUG_FORTH_WORDS 
b062						DMARK "-L>" 
b062 f5				push af  
b063 3a 77 b0			ld a, (.dmark)  
b066 32 71 ee			ld (debug_mark),a  
b069 3a 78 b0			ld a, (.dmark+1)  
b06c 32 72 ee			ld (debug_mark+1),a  
b06f 3a 79 b0			ld a, (.dmark+2)  
b072 32 73 ee			ld (debug_mark+2),a  
b075 18 03			jr .pastdmark  
b077 ..			.dmark: db "-L>"  
b07a f1			.pastdmark: pop af  
b07b			endm  
# End of macro DMARK
b07b				CALLMONITOR 
b07b cd 7c 93			call break_point_state  
b07e				endm  
# End of macro CALLMONITOR
b07e			endif 
b07e			 
b07e					NEXTW 
b07e c3 3f 9d			jp macro_next 
b081				endm 
# End of macro NEXTW
b081				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b081			 
b081			.mloopnotdone: 
b081			 
b081 e1				pop hl    ; get I 
b082 2b				dec hl 
b083			 
b083			   	; save new I 
b083			 
b083			 
b083					; set I counter 
b083			 
b083 22 7c e6				ld (os_current_i), hl 
b086			 
b086					 
b086				FORTH_LOOP_NEXT 
b086 cd fe 9b			call macro_forth_loop_next 
b089				endm 
# End of macro FORTH_LOOP_NEXT
b089			 
b089			 
b089					if DEBUG_FORTH_WORDS 
b089 eb						ex de,hl 
b08a					endif 
b08a			 
b08a			;	; get DO ptr 
b08a			; 
b08a				FORTH_RSP_TOS 
b08a cd 94 99			call macro_forth_rsp_tos 
b08d				endm 
# End of macro FORTH_RSP_TOS
b08d			 
b08d				;push hl 
b08d			 
b08d				; not going to DO any more 
b08d				; get rid of the RSP pointer as DO will add it back in 
b08d				;FORTH_RSP_POP 
b08d				;pop hl 
b08d			 
b08d			 
b08d 22 58 e6			ld (os_tok_ptr), hl 
b090					if DEBUG_FORTH_WORDS 
b090						DMARK "-L<" 
b090 f5				push af  
b091 3a a5 b0			ld a, (.dmark)  
b094 32 71 ee			ld (debug_mark),a  
b097 3a a6 b0			ld a, (.dmark+1)  
b09a 32 72 ee			ld (debug_mark+1),a  
b09d 3a a7 b0			ld a, (.dmark+2)  
b0a0 32 73 ee			ld (debug_mark+2),a  
b0a3 18 03			jr .pastdmark  
b0a5 ..			.dmark: db "-L<"  
b0a8 f1			.pastdmark: pop af  
b0a9			endm  
# End of macro DMARK
b0a9					CALLMONITOR 
b0a9 cd 7c 93			call break_point_state  
b0ac				endm  
# End of macro CALLMONITOR
b0ac				endif 
b0ac c3 d0 9d			jp exec1 
b0af			 
b0af					 
b0af			 
b0af			 
b0af			 
b0af				NEXTW 
b0af c3 3f 9d			jp macro_next 
b0b2				endm 
# End of macro NEXTW
b0b2			 
b0b2			 
b0b2			 
b0b2			 
b0b2			.REPEAT: 
b0b2				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b0b2 71				db WORD_SYS_CORE+93             
b0b3 05 b1			dw .UNTIL            
b0b5 06				db 5 + 1 
b0b6 .. 00			db "REPEAT",0              
b0bd				endm 
# End of macro CWHEAD
b0bd			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b0bd			;  push pc to rsp stack past the REPEAT 
b0bd					if DEBUG_FORTH_WORDS_KEY 
b0bd						DMARK "REP" 
b0bd f5				push af  
b0be 3a d2 b0			ld a, (.dmark)  
b0c1 32 71 ee			ld (debug_mark),a  
b0c4 3a d3 b0			ld a, (.dmark+1)  
b0c7 32 72 ee			ld (debug_mark+1),a  
b0ca 3a d4 b0			ld a, (.dmark+2)  
b0cd 32 73 ee			ld (debug_mark+2),a  
b0d0 18 03			jr .pastdmark  
b0d2 ..			.dmark: db "REP"  
b0d5 f1			.pastdmark: pop af  
b0d6			endm  
# End of macro DMARK
b0d6						CALLMONITOR 
b0d6 cd 7c 93			call break_point_state  
b0d9				endm  
# End of macro CALLMONITOR
b0d9					endif 
b0d9			 
b0d9 2a 58 e6				ld hl, (os_tok_ptr) 
b0dc 23					inc hl   ; R 
b0dd 23					inc hl  ; E 
b0de 23					inc hl   ; P 
b0df 23					inc hl   ; E 
b0e0 23					inc hl   ; A 
b0e1 23					inc hl   ; T 
b0e2 23					inc hl   ; zero 
b0e3					FORTH_RSP_NEXT 
b0e3 cd 7d 99			call macro_forth_rsp_next 
b0e6				endm 
# End of macro FORTH_RSP_NEXT
b0e6			 
b0e6			 
b0e6					if DEBUG_FORTH_WORDS 
b0e6						DMARK "REP" 
b0e6 f5				push af  
b0e7 3a fb b0			ld a, (.dmark)  
b0ea 32 71 ee			ld (debug_mark),a  
b0ed 3a fc b0			ld a, (.dmark+1)  
b0f0 32 72 ee			ld (debug_mark+1),a  
b0f3 3a fd b0			ld a, (.dmark+2)  
b0f6 32 73 ee			ld (debug_mark+2),a  
b0f9 18 03			jr .pastdmark  
b0fb ..			.dmark: db "REP"  
b0fe f1			.pastdmark: pop af  
b0ff			endm  
# End of macro DMARK
b0ff						;pop bc    ; TODO BUG ?????? what is this for???? 
b0ff						CALLMONITOR 
b0ff cd 7c 93			call break_point_state  
b102				endm  
# End of macro CALLMONITOR
b102					endif 
b102			 
b102					NEXTW 
b102 c3 3f 9d			jp macro_next 
b105				endm 
# End of macro NEXTW
b105			;	       NEXTW 
b105			 
b105			.UNTIL: 
b105				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b105 72				db WORD_SYS_CORE+94             
b106 9c b1			dw .ENDFLOW            
b108 06				db 5 + 1 
b109 .. 00			db "UNTIL",0              
b10f				endm 
# End of macro CWHEAD
b10f			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b10f			 
b10f				; pop tos as check 
b10f			 
b10f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b10f			 
b10f				FORTH_DSP_VALUEHL 
b10f cd cd 9b			call macro_dsp_valuehl 
b112				endm 
# End of macro FORTH_DSP_VALUEHL
b112			 
b112					if DEBUG_FORTH_WORDS_KEY 
b112						DMARK "UNT" 
b112 f5				push af  
b113 3a 27 b1			ld a, (.dmark)  
b116 32 71 ee			ld (debug_mark),a  
b119 3a 28 b1			ld a, (.dmark+1)  
b11c 32 72 ee			ld (debug_mark+1),a  
b11f 3a 29 b1			ld a, (.dmark+2)  
b122 32 73 ee			ld (debug_mark+2),a  
b125 18 03			jr .pastdmark  
b127 ..			.dmark: db "UNT"  
b12a f1			.pastdmark: pop af  
b12b			endm  
# End of macro DMARK
b12b						CALLMONITOR 
b12b cd 7c 93			call break_point_state  
b12e				endm  
# End of macro CALLMONITOR
b12e					endif 
b12e			 
b12e			;	push hl 
b12e				FORTH_DSP_POP 
b12e cd 85 9c			call macro_forth_dsp_pop 
b131				endm 
# End of macro FORTH_DSP_POP
b131			 
b131			;	pop hl 
b131			 
b131				; test if true 
b131			 
b131 cd a4 8b			call ishlzero 
b134			;	ld a,l 
b134			;	add h 
b134			; 
b134			;	cp 0 
b134			 
b134 20 3e			jr nz, .untilnotdone 
b136			 
b136					if DEBUG_FORTH_WORDS 
b136						DMARK "UNf" 
b136 f5				push af  
b137 3a 4b b1			ld a, (.dmark)  
b13a 32 71 ee			ld (debug_mark),a  
b13d 3a 4c b1			ld a, (.dmark+1)  
b140 32 72 ee			ld (debug_mark+1),a  
b143 3a 4d b1			ld a, (.dmark+2)  
b146 32 73 ee			ld (debug_mark+2),a  
b149 18 03			jr .pastdmark  
b14b ..			.dmark: db "UNf"  
b14e f1			.pastdmark: pop af  
b14f			endm  
# End of macro DMARK
b14f						CALLMONITOR 
b14f cd 7c 93			call break_point_state  
b152				endm  
# End of macro CALLMONITOR
b152					endif 
b152			 
b152			 
b152			 
b152				FORTH_RSP_POP     ; get rid of DO ptr 
b152 cd 9e 99			call macro_forth_rsp_pop 
b155				endm 
# End of macro FORTH_RSP_POP
b155			 
b155			if DEBUG_FORTH_WORDS 
b155						DMARK "UN>" 
b155 f5				push af  
b156 3a 6a b1			ld a, (.dmark)  
b159 32 71 ee			ld (debug_mark),a  
b15c 3a 6b b1			ld a, (.dmark+1)  
b15f 32 72 ee			ld (debug_mark+1),a  
b162 3a 6c b1			ld a, (.dmark+2)  
b165 32 73 ee			ld (debug_mark+2),a  
b168 18 03			jr .pastdmark  
b16a ..			.dmark: db "UN>"  
b16d f1			.pastdmark: pop af  
b16e			endm  
# End of macro DMARK
b16e				CALLMONITOR 
b16e cd 7c 93			call break_point_state  
b171				endm  
# End of macro CALLMONITOR
b171			endif 
b171			 
b171					NEXTW 
b171 c3 3f 9d			jp macro_next 
b174				endm 
# End of macro NEXTW
b174				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b174			 
b174			.untilnotdone: 
b174			 
b174			 
b174			;	; get DO ptr 
b174			; 
b174				FORTH_RSP_TOS 
b174 cd 94 99			call macro_forth_rsp_tos 
b177				endm 
# End of macro FORTH_RSP_TOS
b177			 
b177				;push hl 
b177			 
b177				; not going to DO any more 
b177				; get rid of the RSP pointer as DO will add it back in 
b177				;FORTH_RSP_POP 
b177				;pop hl 
b177			 
b177			 
b177 22 58 e6			ld (os_tok_ptr), hl 
b17a					if DEBUG_FORTH_WORDS 
b17a						DMARK "UN<" 
b17a f5				push af  
b17b 3a 8f b1			ld a, (.dmark)  
b17e 32 71 ee			ld (debug_mark),a  
b181 3a 90 b1			ld a, (.dmark+1)  
b184 32 72 ee			ld (debug_mark+1),a  
b187 3a 91 b1			ld a, (.dmark+2)  
b18a 32 73 ee			ld (debug_mark+2),a  
b18d 18 03			jr .pastdmark  
b18f ..			.dmark: db "UN<"  
b192 f1			.pastdmark: pop af  
b193			endm  
# End of macro DMARK
b193					CALLMONITOR 
b193 cd 7c 93			call break_point_state  
b196				endm  
# End of macro CALLMONITOR
b196				endif 
b196 c3 d0 9d			jp exec1 
b199			 
b199					 
b199			 
b199			 
b199					NEXTW 
b199 c3 3f 9d			jp macro_next 
b19c				endm 
# End of macro NEXTW
b19c			 
b19c			 
b19c			.ENDFLOW: 
b19c			 
b19c			; eof 
b19c			 
# End of file forth_words_flow.asm
b19c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b19c			include "forth_words_logic.asm" 
b19c			 
b19c			; | ## Logic Words 
b19c			 
b19c			.NOT: 
b19c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b19c 2d				db WORD_SYS_CORE+25             
b19d e4 b1			dw .IS            
b19f 04				db 3 + 1 
b1a0 .. 00			db "NOT",0              
b1a4				endm 
# End of macro CWHEAD
b1a4			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b1a4					if DEBUG_FORTH_WORDS_KEY 
b1a4						DMARK "NOT" 
b1a4 f5				push af  
b1a5 3a b9 b1			ld a, (.dmark)  
b1a8 32 71 ee			ld (debug_mark),a  
b1ab 3a ba b1			ld a, (.dmark+1)  
b1ae 32 72 ee			ld (debug_mark+1),a  
b1b1 3a bb b1			ld a, (.dmark+2)  
b1b4 32 73 ee			ld (debug_mark+2),a  
b1b7 18 03			jr .pastdmark  
b1b9 ..			.dmark: db "NOT"  
b1bc f1			.pastdmark: pop af  
b1bd			endm  
# End of macro DMARK
b1bd						CALLMONITOR 
b1bd cd 7c 93			call break_point_state  
b1c0				endm  
# End of macro CALLMONITOR
b1c0					endif 
b1c0					FORTH_DSP 
b1c0 cd 93 9b			call macro_forth_dsp 
b1c3				endm 
# End of macro FORTH_DSP
b1c3 7e					ld a,(hl)	; get type of value on TOS 
b1c4 fe 02				cp DS_TYPE_INUM  
b1c6 28 03				jr z, .noti 
b1c8					NEXTW 
b1c8 c3 3f 9d			jp macro_next 
b1cb				endm 
# End of macro NEXTW
b1cb			.noti:          FORTH_DSP_VALUEHL 
b1cb cd cd 9b			call macro_dsp_valuehl 
b1ce				endm 
# End of macro FORTH_DSP_VALUEHL
b1ce			;		push hl 
b1ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1ce cd 85 9c			call macro_forth_dsp_pop 
b1d1				endm 
# End of macro FORTH_DSP_POP
b1d1			;		pop hl 
b1d1 3e 00				ld a,0 
b1d3 bd					cp l 
b1d4 28 04				jr z, .not2t 
b1d6 2e 00				ld l, 0 
b1d8 18 02				jr .notip 
b1da			 
b1da 2e ff		.not2t:		ld l, 255 
b1dc			 
b1dc 26 00		.notip:		ld h, 0	 
b1de			 
b1de cd d6 99				call forth_push_numhl 
b1e1					NEXTW 
b1e1 c3 3f 9d			jp macro_next 
b1e4				endm 
# End of macro NEXTW
b1e4			 
b1e4			.IS: 
b1e4				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b1e4 2d				db WORD_SYS_CORE+25             
b1e5 0a b2			dw .LZERO            
b1e7 03				db 2 + 1 
b1e8 .. 00			db "IS",0              
b1eb				endm 
# End of macro CWHEAD
b1eb			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b1eb					if DEBUG_FORTH_WORDS_KEY 
b1eb						DMARK "IS." 
b1eb f5				push af  
b1ec 3a 00 b2			ld a, (.dmark)  
b1ef 32 71 ee			ld (debug_mark),a  
b1f2 3a 01 b2			ld a, (.dmark+1)  
b1f5 32 72 ee			ld (debug_mark+1),a  
b1f8 3a 02 b2			ld a, (.dmark+2)  
b1fb 32 73 ee			ld (debug_mark+2),a  
b1fe 18 03			jr .pastdmark  
b200 ..			.dmark: db "IS."  
b203 f1			.pastdmark: pop af  
b204			endm  
# End of macro DMARK
b204						CALLMONITOR 
b204 cd 7c 93			call break_point_state  
b207				endm  
# End of macro CALLMONITOR
b207					endif 
b207					NEXTW 
b207 c3 3f 9d			jp macro_next 
b20a				endm 
# End of macro NEXTW
b20a			.LZERO: 
b20a				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b20a 2d				db WORD_SYS_CORE+25             
b20b 14 b2			dw .TZERO            
b20d 03				db 2 + 1 
b20e .. 00			db "0<",0              
b211				endm 
# End of macro CWHEAD
b211			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b211					NEXTW 
b211 c3 3f 9d			jp macro_next 
b214				endm 
# End of macro NEXTW
b214			.TZERO: 
b214				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b214 2e				db WORD_SYS_CORE+26             
b215 5b b2			dw .LESS            
b217 03				db 2 + 1 
b218 .. 00			db "0=",0              
b21b				endm 
# End of macro CWHEAD
b21b			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b21b				; TODO add floating point number detection 
b21b					;v5 FORTH_DSP_VALUE 
b21b					if DEBUG_FORTH_WORDS_KEY 
b21b						DMARK "0=." 
b21b f5				push af  
b21c 3a 30 b2			ld a, (.dmark)  
b21f 32 71 ee			ld (debug_mark),a  
b222 3a 31 b2			ld a, (.dmark+1)  
b225 32 72 ee			ld (debug_mark+1),a  
b228 3a 32 b2			ld a, (.dmark+2)  
b22b 32 73 ee			ld (debug_mark+2),a  
b22e 18 03			jr .pastdmark  
b230 ..			.dmark: db "0=."  
b233 f1			.pastdmark: pop af  
b234			endm  
# End of macro DMARK
b234						CALLMONITOR 
b234 cd 7c 93			call break_point_state  
b237				endm  
# End of macro CALLMONITOR
b237					endif 
b237					FORTH_DSP 
b237 cd 93 9b			call macro_forth_dsp 
b23a				endm 
# End of macro FORTH_DSP
b23a 7e					ld a,(hl)	; get type of value on TOS 
b23b fe 02				cp DS_TYPE_INUM  
b23d 28 00				jr z, .tz_inum 
b23f			 
b23f				if FORTH_ENABLE_FLOATMATH 
b23f					jr .tz_done 
b23f			 
b23f				endif 
b23f					 
b23f			 
b23f			.tz_inum: 
b23f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b23f cd cd 9b			call macro_dsp_valuehl 
b242				endm 
# End of macro FORTH_DSP_VALUEHL
b242			 
b242			;		push hl 
b242			 
b242					; destroy value TOS 
b242			 
b242					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b242 cd 85 9c			call macro_forth_dsp_pop 
b245				endm 
# End of macro FORTH_DSP_POP
b245			 
b245			;		pop hl 
b245			 
b245 3e 00				ld a,0 
b247			 
b247 bd					cp l 
b248 20 08				jr nz, .tz_notzero 
b24a			 
b24a bc					cp h 
b24b			 
b24b 20 05				jr nz, .tz_notzero 
b24d			 
b24d			 
b24d 21 01 00				ld hl, FORTH_TRUE 
b250 18 03				jr .tz_done 
b252			 
b252 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b255			 
b255					; push value back onto stack for another op etc 
b255			 
b255			.tz_done: 
b255 cd d6 99				call forth_push_numhl 
b258			 
b258					NEXTW 
b258 c3 3f 9d			jp macro_next 
b25b				endm 
# End of macro NEXTW
b25b			.LESS: 
b25b				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b25b 2f				db WORD_SYS_CORE+27             
b25c c4 b2			dw .GT            
b25e 02				db 1 + 1 
b25f .. 00			db "<",0              
b261				endm 
# End of macro CWHEAD
b261			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b261				; TODO add floating point number detection 
b261					if DEBUG_FORTH_WORDS_KEY 
b261						DMARK "LES" 
b261 f5				push af  
b262 3a 76 b2			ld a, (.dmark)  
b265 32 71 ee			ld (debug_mark),a  
b268 3a 77 b2			ld a, (.dmark+1)  
b26b 32 72 ee			ld (debug_mark+1),a  
b26e 3a 78 b2			ld a, (.dmark+2)  
b271 32 73 ee			ld (debug_mark+2),a  
b274 18 03			jr .pastdmark  
b276 ..			.dmark: db "LES"  
b279 f1			.pastdmark: pop af  
b27a			endm  
# End of macro DMARK
b27a						CALLMONITOR 
b27a cd 7c 93			call break_point_state  
b27d				endm  
# End of macro CALLMONITOR
b27d					endif 
b27d					FORTH_DSP 
b27d cd 93 9b			call macro_forth_dsp 
b280				endm 
# End of macro FORTH_DSP
b280					;v5 FORTH_DSP_VALUE 
b280 7e					ld a,(hl)	; get type of value on TOS 
b281 fe 02				cp DS_TYPE_INUM  
b283 28 00				jr z, .less_inum 
b285			 
b285				if FORTH_ENABLE_FLOATMATH 
b285					jr .less_done 
b285			 
b285				endif 
b285					 
b285			 
b285			.less_inum: 
b285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b285 cd cd 9b			call macro_dsp_valuehl 
b288				endm 
# End of macro FORTH_DSP_VALUEHL
b288			 
b288 e5					push hl  ; u2 
b289			 
b289					; destroy value TOS 
b289			 
b289					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b289 cd 85 9c			call macro_forth_dsp_pop 
b28c				endm 
# End of macro FORTH_DSP_POP
b28c			 
b28c			 
b28c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b28c cd cd 9b			call macro_dsp_valuehl 
b28f				endm 
# End of macro FORTH_DSP_VALUEHL
b28f			 
b28f e5					push hl    ; u1 
b290			 
b290					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b290 cd 85 9c			call macro_forth_dsp_pop 
b293				endm 
# End of macro FORTH_DSP_POP
b293			 
b293			 
b293 b7			 or a      ;clear carry flag 
b294 01 00 00		 ld bc, FORTH_FALSE 
b297 e1			  pop hl    ; u1 
b298 d1			  pop de    ; u2 
b299 ed 52		  sbc hl,de 
b29b 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b29d			 
b29d 01 01 00		 ld bc, FORTH_TRUE 
b2a0			.lscont:  
b2a0 c5					push bc 
b2a1 e1					pop hl 
b2a2			 
b2a2					if DEBUG_FORTH_WORDS 
b2a2						DMARK "LT1" 
b2a2 f5				push af  
b2a3 3a b7 b2			ld a, (.dmark)  
b2a6 32 71 ee			ld (debug_mark),a  
b2a9 3a b8 b2			ld a, (.dmark+1)  
b2ac 32 72 ee			ld (debug_mark+1),a  
b2af 3a b9 b2			ld a, (.dmark+2)  
b2b2 32 73 ee			ld (debug_mark+2),a  
b2b5 18 03			jr .pastdmark  
b2b7 ..			.dmark: db "LT1"  
b2ba f1			.pastdmark: pop af  
b2bb			endm  
# End of macro DMARK
b2bb						CALLMONITOR 
b2bb cd 7c 93			call break_point_state  
b2be				endm  
# End of macro CALLMONITOR
b2be					endif 
b2be cd d6 99				call forth_push_numhl 
b2c1			 
b2c1					NEXTW 
b2c1 c3 3f 9d			jp macro_next 
b2c4				endm 
# End of macro NEXTW
b2c4			.GT: 
b2c4				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b2c4 30				db WORD_SYS_CORE+28             
b2c5 2d b3			dw .EQUAL            
b2c7 02				db 1 + 1 
b2c8 .. 00			db ">",0              
b2ca				endm 
# End of macro CWHEAD
b2ca			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b2ca				; TODO add floating point number detection 
b2ca					if DEBUG_FORTH_WORDS_KEY 
b2ca						DMARK "GRT" 
b2ca f5				push af  
b2cb 3a df b2			ld a, (.dmark)  
b2ce 32 71 ee			ld (debug_mark),a  
b2d1 3a e0 b2			ld a, (.dmark+1)  
b2d4 32 72 ee			ld (debug_mark+1),a  
b2d7 3a e1 b2			ld a, (.dmark+2)  
b2da 32 73 ee			ld (debug_mark+2),a  
b2dd 18 03			jr .pastdmark  
b2df ..			.dmark: db "GRT"  
b2e2 f1			.pastdmark: pop af  
b2e3			endm  
# End of macro DMARK
b2e3						CALLMONITOR 
b2e3 cd 7c 93			call break_point_state  
b2e6				endm  
# End of macro CALLMONITOR
b2e6					endif 
b2e6					FORTH_DSP 
b2e6 cd 93 9b			call macro_forth_dsp 
b2e9				endm 
# End of macro FORTH_DSP
b2e9					;FORTH_DSP_VALUE 
b2e9 7e					ld a,(hl)	; get type of value on TOS 
b2ea fe 02				cp DS_TYPE_INUM  
b2ec 28 00				jr z, .gt_inum 
b2ee			 
b2ee				if FORTH_ENABLE_FLOATMATH 
b2ee					jr .gt_done 
b2ee			 
b2ee				endif 
b2ee					 
b2ee			 
b2ee			.gt_inum: 
b2ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2ee cd cd 9b			call macro_dsp_valuehl 
b2f1				endm 
# End of macro FORTH_DSP_VALUEHL
b2f1			 
b2f1 e5					push hl  ; u2 
b2f2			 
b2f2					; destroy value TOS 
b2f2			 
b2f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f2 cd 85 9c			call macro_forth_dsp_pop 
b2f5				endm 
# End of macro FORTH_DSP_POP
b2f5			 
b2f5			 
b2f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f5 cd cd 9b			call macro_dsp_valuehl 
b2f8				endm 
# End of macro FORTH_DSP_VALUEHL
b2f8			 
b2f8 e5					push hl    ; u1 
b2f9			 
b2f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f9 cd 85 9c			call macro_forth_dsp_pop 
b2fc				endm 
# End of macro FORTH_DSP_POP
b2fc			 
b2fc			 
b2fc b7			 or a      ;clear carry flag 
b2fd 01 00 00		 ld bc, FORTH_FALSE 
b300 e1			  pop hl    ; u1 
b301 d1			  pop de    ; u2 
b302 ed 52		  sbc hl,de 
b304 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b306			 
b306 01 01 00		 ld bc, FORTH_TRUE 
b309			.gtcont:  
b309 c5					push bc 
b30a e1					pop hl 
b30b			 
b30b					if DEBUG_FORTH_WORDS 
b30b						DMARK "GT1" 
b30b f5				push af  
b30c 3a 20 b3			ld a, (.dmark)  
b30f 32 71 ee			ld (debug_mark),a  
b312 3a 21 b3			ld a, (.dmark+1)  
b315 32 72 ee			ld (debug_mark+1),a  
b318 3a 22 b3			ld a, (.dmark+2)  
b31b 32 73 ee			ld (debug_mark+2),a  
b31e 18 03			jr .pastdmark  
b320 ..			.dmark: db "GT1"  
b323 f1			.pastdmark: pop af  
b324			endm  
# End of macro DMARK
b324						CALLMONITOR 
b324 cd 7c 93			call break_point_state  
b327				endm  
# End of macro CALLMONITOR
b327					endif 
b327 cd d6 99				call forth_push_numhl 
b32a			 
b32a					NEXTW 
b32a c3 3f 9d			jp macro_next 
b32d				endm 
# End of macro NEXTW
b32d			.EQUAL: 
b32d				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b32d 31				db WORD_SYS_CORE+29             
b32e 98 b3			dw .ENDLOGIC            
b330 02				db 1 + 1 
b331 .. 00			db "=",0              
b333				endm 
# End of macro CWHEAD
b333			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b333				; TODO add floating point number detection 
b333					if DEBUG_FORTH_WORDS_KEY 
b333						DMARK "EQ." 
b333 f5				push af  
b334 3a 48 b3			ld a, (.dmark)  
b337 32 71 ee			ld (debug_mark),a  
b33a 3a 49 b3			ld a, (.dmark+1)  
b33d 32 72 ee			ld (debug_mark+1),a  
b340 3a 4a b3			ld a, (.dmark+2)  
b343 32 73 ee			ld (debug_mark+2),a  
b346 18 03			jr .pastdmark  
b348 ..			.dmark: db "EQ."  
b34b f1			.pastdmark: pop af  
b34c			endm  
# End of macro DMARK
b34c						CALLMONITOR 
b34c cd 7c 93			call break_point_state  
b34f				endm  
# End of macro CALLMONITOR
b34f					endif 
b34f					FORTH_DSP 
b34f cd 93 9b			call macro_forth_dsp 
b352				endm 
# End of macro FORTH_DSP
b352					;v5 FORTH_DSP_VALUE 
b352 7e					ld a,(hl)	; get type of value on TOS 
b353 fe 02				cp DS_TYPE_INUM  
b355 28 00				jr z, .eq_inum 
b357			 
b357				if FORTH_ENABLE_FLOATMATH 
b357					jr .eq_done 
b357			 
b357				endif 
b357					 
b357			 
b357			.eq_inum: 
b357					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b357 cd cd 9b			call macro_dsp_valuehl 
b35a				endm 
# End of macro FORTH_DSP_VALUEHL
b35a			 
b35a e5					push hl 
b35b			 
b35b					; destroy value TOS 
b35b			 
b35b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b35b cd 85 9c			call macro_forth_dsp_pop 
b35e				endm 
# End of macro FORTH_DSP_POP
b35e			 
b35e			 
b35e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b35e cd cd 9b			call macro_dsp_valuehl 
b361				endm 
# End of macro FORTH_DSP_VALUEHL
b361			 
b361					; one value on hl get other one back 
b361			 
b361 e5					push hl 
b362			 
b362					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b362 cd 85 9c			call macro_forth_dsp_pop 
b365				endm 
# End of macro FORTH_DSP_POP
b365			 
b365 0e 00				ld c, FORTH_FALSE 
b367			 
b367 e1					pop hl 
b368 d1					pop de 
b369			 
b369 7b					ld a, e 
b36a bd					cp l 
b36b			 
b36b 20 06				jr nz, .eq_done 
b36d			 
b36d 7a					ld a, d 
b36e bc					cp h 
b36f			 
b36f 20 02				jr nz, .eq_done 
b371			 
b371 0e 01				ld c, FORTH_TRUE 
b373					 
b373			 
b373			 
b373			.eq_done: 
b373			 
b373					; TODO push value back onto stack for another op etc 
b373			 
b373 26 00				ld h, 0 
b375 69					ld l, c 
b376					if DEBUG_FORTH_WORDS 
b376						DMARK "EQ1" 
b376 f5				push af  
b377 3a 8b b3			ld a, (.dmark)  
b37a 32 71 ee			ld (debug_mark),a  
b37d 3a 8c b3			ld a, (.dmark+1)  
b380 32 72 ee			ld (debug_mark+1),a  
b383 3a 8d b3			ld a, (.dmark+2)  
b386 32 73 ee			ld (debug_mark+2),a  
b389 18 03			jr .pastdmark  
b38b ..			.dmark: db "EQ1"  
b38e f1			.pastdmark: pop af  
b38f			endm  
# End of macro DMARK
b38f						CALLMONITOR 
b38f cd 7c 93			call break_point_state  
b392				endm  
# End of macro CALLMONITOR
b392					endif 
b392 cd d6 99				call forth_push_numhl 
b395			 
b395					NEXTW 
b395 c3 3f 9d			jp macro_next 
b398				endm 
# End of macro NEXTW
b398			 
b398			 
b398			.ENDLOGIC: 
b398			; eof 
b398			 
b398			 
# End of file forth_words_logic.asm
b398			include "forth_words_maths.asm" 
b398			 
b398			; | ## Maths Words 
b398			 
b398			.PLUS:	 
b398				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b398 15				db WORD_SYS_CORE+1             
b399 da b3			dw .NEG            
b39b 02				db 1 + 1 
b39c .. 00			db "+",0              
b39e				endm 
# End of macro CWHEAD
b39e			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b39e					if DEBUG_FORTH_WORDS_KEY 
b39e						DMARK "PLU" 
b39e f5				push af  
b39f 3a b3 b3			ld a, (.dmark)  
b3a2 32 71 ee			ld (debug_mark),a  
b3a5 3a b4 b3			ld a, (.dmark+1)  
b3a8 32 72 ee			ld (debug_mark+1),a  
b3ab 3a b5 b3			ld a, (.dmark+2)  
b3ae 32 73 ee			ld (debug_mark+2),a  
b3b1 18 03			jr .pastdmark  
b3b3 ..			.dmark: db "PLU"  
b3b6 f1			.pastdmark: pop af  
b3b7			endm  
# End of macro DMARK
b3b7						CALLMONITOR 
b3b7 cd 7c 93			call break_point_state  
b3ba				endm  
# End of macro CALLMONITOR
b3ba					endif 
b3ba					; add top two values and push back result 
b3ba			 
b3ba					;for v5 FORTH_DSP_VALUE 
b3ba					FORTH_DSP 
b3ba cd 93 9b			call macro_forth_dsp 
b3bd				endm 
# End of macro FORTH_DSP
b3bd 7e					ld a,(hl)	; get type of value on TOS 
b3be fe 02				cp DS_TYPE_INUM  
b3c0 28 03				jr z, .dot_inum 
b3c2			 
b3c2					NEXTW 
b3c2 c3 3f 9d			jp macro_next 
b3c5				endm 
# End of macro NEXTW
b3c5			 
b3c5			; float maths 
b3c5			 
b3c5				if FORTH_ENABLE_FLOATMATH 
b3c5						inc hl      ; now at start of numeric as string 
b3c5			 
b3c5					if DEBUG_FORTH_MATHS 
b3c5						DMARK "ADD" 
b3c5				CALLMONITOR 
b3c5					endif 
b3c5			 
b3c5					;ld ix, hl 
b3c5					call CON 
b3c5			 
b3c5			 
b3c5					push hl 
b3c5					 
b3c5					 
b3c5			 
b3c5						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b3c5			 
b3c5					; get next number 
b3c5			 
b3c5						FORTH_DSP_VALUE 
b3c5			 
b3c5						inc hl      ; now at start of numeric as string 
b3c5			 
b3c5					;ld ix, hl 
b3c5					call CON 
b3c5			 
b3c5					push hl 
b3c5			 
b3c5			 
b3c5						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c5			 
b3c5						; TODO do add 
b3c5			 
b3c5						call IADD 
b3c5			 
b3c5						; TODO get result back as ascii 
b3c5			 
b3c5						; TODO push result  
b3c5			 
b3c5			 
b3c5			 
b3c5						jr .dot_done 
b3c5				endif 
b3c5			 
b3c5			.dot_inum: 
b3c5			 
b3c5			 
b3c5					if DEBUG_FORTH_DOT 
b3c5						DMARK "+IT" 
b3c5				CALLMONITOR 
b3c5					endif 
b3c5			 
b3c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c5 cd cd 9b			call macro_dsp_valuehl 
b3c8				endm 
# End of macro FORTH_DSP_VALUEHL
b3c8			 
b3c8				; TODO add floating point number detection 
b3c8			 
b3c8 e5					push hl 
b3c9			 
b3c9					; destroy value TOS 
b3c9			 
b3c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c9 cd 85 9c			call macro_forth_dsp_pop 
b3cc				endm 
# End of macro FORTH_DSP_POP
b3cc			 
b3cc			 
b3cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3cc cd cd 9b			call macro_dsp_valuehl 
b3cf				endm 
# End of macro FORTH_DSP_VALUEHL
b3cf			 
b3cf					; one value on hl get other one back 
b3cf			 
b3cf d1					pop de 
b3d0			 
b3d0					; do the add 
b3d0			 
b3d0 19					add hl,de 
b3d1			 
b3d1					; save it 
b3d1			 
b3d1			;		push hl	 
b3d1			 
b3d1					; 
b3d1			 
b3d1					; destroy value TOS 
b3d1			 
b3d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3d1 cd 85 9c			call macro_forth_dsp_pop 
b3d4				endm 
# End of macro FORTH_DSP_POP
b3d4			 
b3d4					; TODO push value back onto stack for another op etc 
b3d4			 
b3d4			;		pop hl 
b3d4			 
b3d4			.dot_done: 
b3d4 cd d6 99				call forth_push_numhl 
b3d7			 
b3d7					NEXTW 
b3d7 c3 3f 9d			jp macro_next 
b3da				endm 
# End of macro NEXTW
b3da			.NEG: 
b3da			 
b3da				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b3da 17				db WORD_SYS_CORE+3             
b3db 1d b4			dw .DIV            
b3dd 02				db 1 + 1 
b3de .. 00			db "-",0              
b3e0				endm 
# End of macro CWHEAD
b3e0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b3e0					if DEBUG_FORTH_WORDS_KEY 
b3e0						DMARK "SUB" 
b3e0 f5				push af  
b3e1 3a f5 b3			ld a, (.dmark)  
b3e4 32 71 ee			ld (debug_mark),a  
b3e7 3a f6 b3			ld a, (.dmark+1)  
b3ea 32 72 ee			ld (debug_mark+1),a  
b3ed 3a f7 b3			ld a, (.dmark+2)  
b3f0 32 73 ee			ld (debug_mark+2),a  
b3f3 18 03			jr .pastdmark  
b3f5 ..			.dmark: db "SUB"  
b3f8 f1			.pastdmark: pop af  
b3f9			endm  
# End of macro DMARK
b3f9						CALLMONITOR 
b3f9 cd 7c 93			call break_point_state  
b3fc				endm  
# End of macro CALLMONITOR
b3fc					endif 
b3fc			 
b3fc			 
b3fc				; TODO add floating point number detection 
b3fc					; v5 FORTH_DSP_VALUE 
b3fc					FORTH_DSP 
b3fc cd 93 9b			call macro_forth_dsp 
b3ff				endm 
# End of macro FORTH_DSP
b3ff 7e					ld a,(hl)	; get type of value on TOS 
b400 fe 02				cp DS_TYPE_INUM  
b402 28 03				jr z, .neg_inum 
b404			 
b404					NEXTW 
b404 c3 3f 9d			jp macro_next 
b407				endm 
# End of macro NEXTW
b407			 
b407			; float maths 
b407			 
b407				if FORTH_ENABLE_FLOATMATH 
b407					jr .neg_done 
b407			 
b407				endif 
b407					 
b407			 
b407			.neg_inum: 
b407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b407 cd cd 9b			call macro_dsp_valuehl 
b40a				endm 
# End of macro FORTH_DSP_VALUEHL
b40a			 
b40a e5					push hl 
b40b			 
b40b					; destroy value TOS 
b40b			 
b40b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40b cd 85 9c			call macro_forth_dsp_pop 
b40e				endm 
# End of macro FORTH_DSP_POP
b40e			 
b40e			 
b40e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b40e cd cd 9b			call macro_dsp_valuehl 
b411				endm 
# End of macro FORTH_DSP_VALUEHL
b411			 
b411					; one value on hl get other one back 
b411			 
b411 d1					pop de 
b412			 
b412					; do the sub 
b412			;		ex de, hl 
b412			 
b412 ed 52				sbc hl,de 
b414			 
b414					; save it 
b414			 
b414			;		push hl	 
b414			 
b414					; 
b414			 
b414					; destroy value TOS 
b414			 
b414					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b414 cd 85 9c			call macro_forth_dsp_pop 
b417				endm 
# End of macro FORTH_DSP_POP
b417			 
b417					; TODO push value back onto stack for another op etc 
b417			 
b417			;		pop hl 
b417			 
b417 cd d6 99				call forth_push_numhl 
b41a			.neg_done: 
b41a			 
b41a					NEXTW 
b41a c3 3f 9d			jp macro_next 
b41d				endm 
# End of macro NEXTW
b41d			.DIV: 
b41d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b41d 18				db WORD_SYS_CORE+4             
b41e 6a b4			dw .MUL            
b420 02				db 1 + 1 
b421 .. 00			db "/",0              
b423				endm 
# End of macro CWHEAD
b423			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b423					if DEBUG_FORTH_WORDS_KEY 
b423						DMARK "DIV" 
b423 f5				push af  
b424 3a 38 b4			ld a, (.dmark)  
b427 32 71 ee			ld (debug_mark),a  
b42a 3a 39 b4			ld a, (.dmark+1)  
b42d 32 72 ee			ld (debug_mark+1),a  
b430 3a 3a b4			ld a, (.dmark+2)  
b433 32 73 ee			ld (debug_mark+2),a  
b436 18 03			jr .pastdmark  
b438 ..			.dmark: db "DIV"  
b43b f1			.pastdmark: pop af  
b43c			endm  
# End of macro DMARK
b43c						CALLMONITOR 
b43c cd 7c 93			call break_point_state  
b43f				endm  
# End of macro CALLMONITOR
b43f					endif 
b43f				; TODO add floating point number detection 
b43f					; v5 FORTH_DSP_VALUE 
b43f					FORTH_DSP 
b43f cd 93 9b			call macro_forth_dsp 
b442				endm 
# End of macro FORTH_DSP
b442 7e					ld a,(hl)	; get type of value on TOS 
b443 fe 02				cp DS_TYPE_INUM  
b445 28 03				jr z, .div_inum 
b447			 
b447				if FORTH_ENABLE_FLOATMATH 
b447					jr .div_done 
b447			 
b447				endif 
b447					NEXTW 
b447 c3 3f 9d			jp macro_next 
b44a				endm 
# End of macro NEXTW
b44a			.div_inum: 
b44a			 
b44a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b44a cd cd 9b			call macro_dsp_valuehl 
b44d				endm 
# End of macro FORTH_DSP_VALUEHL
b44d			 
b44d e5					push hl    ; to go to bc 
b44e			 
b44e					; destroy value TOS 
b44e			 
b44e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44e cd 85 9c			call macro_forth_dsp_pop 
b451				endm 
# End of macro FORTH_DSP_POP
b451			 
b451			 
b451					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b451 cd cd 9b			call macro_dsp_valuehl 
b454				endm 
# End of macro FORTH_DSP_VALUEHL
b454			 
b454					; hl to go to de 
b454			 
b454 e5					push hl 
b455			 
b455 c1					pop bc 
b456 d1					pop de		 
b457			 
b457			 
b457					if DEBUG_FORTH_MATHS 
b457						DMARK "DIV" 
b457				CALLMONITOR 
b457					endif 
b457					; one value on hl but move to a get other one back 
b457			 
b457			        
b457 cd d8 8a			call Div16 
b45a			 
b45a			;	push af	 
b45a e5				push hl 
b45b c5				push bc 
b45c			 
b45c					if DEBUG_FORTH_MATHS 
b45c						DMARK "DI1" 
b45c				CALLMONITOR 
b45c					endif 
b45c			 
b45c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b45c cd 85 9c			call macro_forth_dsp_pop 
b45f				endm 
# End of macro FORTH_DSP_POP
b45f			 
b45f			 
b45f			 
b45f e1					pop hl    ; result 
b460			 
b460 cd d6 99				call forth_push_numhl 
b463			 
b463 e1					pop hl    ; reminder 
b464			;		ld h,0 
b464			;		ld l,d 
b464			 
b464 cd d6 99				call forth_push_numhl 
b467			.div_done: 
b467					NEXTW 
b467 c3 3f 9d			jp macro_next 
b46a				endm 
# End of macro NEXTW
b46a			.MUL: 
b46a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b46a 19				db WORD_SYS_CORE+5             
b46b af b4			dw .MIN            
b46d 02				db 1 + 1 
b46e .. 00			db "*",0              
b470				endm 
# End of macro CWHEAD
b470			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b470				; TODO add floating point number detection 
b470					if DEBUG_FORTH_WORDS_KEY 
b470						DMARK "MUL" 
b470 f5				push af  
b471 3a 85 b4			ld a, (.dmark)  
b474 32 71 ee			ld (debug_mark),a  
b477 3a 86 b4			ld a, (.dmark+1)  
b47a 32 72 ee			ld (debug_mark+1),a  
b47d 3a 87 b4			ld a, (.dmark+2)  
b480 32 73 ee			ld (debug_mark+2),a  
b483 18 03			jr .pastdmark  
b485 ..			.dmark: db "MUL"  
b488 f1			.pastdmark: pop af  
b489			endm  
# End of macro DMARK
b489						CALLMONITOR 
b489 cd 7c 93			call break_point_state  
b48c				endm  
# End of macro CALLMONITOR
b48c					endif 
b48c					FORTH_DSP 
b48c cd 93 9b			call macro_forth_dsp 
b48f				endm 
# End of macro FORTH_DSP
b48f					; v5 FORTH_DSP_VALUE 
b48f 7e					ld a,(hl)	; get type of value on TOS 
b490 fe 02				cp DS_TYPE_INUM  
b492 28 03				jr z, .mul_inum 
b494			 
b494				if FORTH_ENABLE_FLOATMATH 
b494					jr .mul_done 
b494			 
b494				endif 
b494			 
b494					NEXTW 
b494 c3 3f 9d			jp macro_next 
b497				endm 
# End of macro NEXTW
b497			.mul_inum:	 
b497			 
b497					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b497 cd cd 9b			call macro_dsp_valuehl 
b49a				endm 
# End of macro FORTH_DSP_VALUEHL
b49a			 
b49a e5					push hl 
b49b			 
b49b					; destroy value TOS 
b49b			 
b49b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49b cd 85 9c			call macro_forth_dsp_pop 
b49e				endm 
# End of macro FORTH_DSP_POP
b49e			 
b49e			 
b49e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b49e cd cd 9b			call macro_dsp_valuehl 
b4a1				endm 
# End of macro FORTH_DSP_VALUEHL
b4a1			 
b4a1					; one value on hl but move to a get other one back 
b4a1			 
b4a1 7d					ld a, l 
b4a2			 
b4a2 d1					pop de 
b4a3			 
b4a3					; do the mull 
b4a3			;		ex de, hl 
b4a3			 
b4a3 cd fe 8a				call Mult16 
b4a6					; save it 
b4a6			 
b4a6			;		push hl	 
b4a6			 
b4a6					; 
b4a6			 
b4a6					; destroy value TOS 
b4a6			 
b4a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4a6 cd 85 9c			call macro_forth_dsp_pop 
b4a9				endm 
# End of macro FORTH_DSP_POP
b4a9			 
b4a9					; TODO push value back onto stack for another op etc 
b4a9			 
b4a9			;		pop hl 
b4a9			 
b4a9 cd d6 99				call forth_push_numhl 
b4ac			 
b4ac			.mul_done: 
b4ac					NEXTW 
b4ac c3 3f 9d			jp macro_next 
b4af				endm 
# End of macro NEXTW
b4af			 
b4af			 
b4af			 
b4af			 
b4af			.MIN: 
b4af				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b4af 49				db WORD_SYS_CORE+53             
b4b0 30 b5			dw .MAX            
b4b2 04				db 3 + 1 
b4b3 .. 00			db "MIN",0              
b4b7				endm 
# End of macro CWHEAD
b4b7			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b4b7					if DEBUG_FORTH_WORDS_KEY 
b4b7						DMARK "MIN" 
b4b7 f5				push af  
b4b8 3a cc b4			ld a, (.dmark)  
b4bb 32 71 ee			ld (debug_mark),a  
b4be 3a cd b4			ld a, (.dmark+1)  
b4c1 32 72 ee			ld (debug_mark+1),a  
b4c4 3a ce b4			ld a, (.dmark+2)  
b4c7 32 73 ee			ld (debug_mark+2),a  
b4ca 18 03			jr .pastdmark  
b4cc ..			.dmark: db "MIN"  
b4cf f1			.pastdmark: pop af  
b4d0			endm  
# End of macro DMARK
b4d0						CALLMONITOR 
b4d0 cd 7c 93			call break_point_state  
b4d3				endm  
# End of macro CALLMONITOR
b4d3					endif 
b4d3					; get u2 
b4d3			 
b4d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d3 cd cd 9b			call macro_dsp_valuehl 
b4d6				endm 
# End of macro FORTH_DSP_VALUEHL
b4d6			 
b4d6 e5					push hl   ; u2 
b4d7			 
b4d7					; destroy value TOS 
b4d7			 
b4d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d7 cd 85 9c			call macro_forth_dsp_pop 
b4da				endm 
# End of macro FORTH_DSP_POP
b4da			 
b4da					; get u1 
b4da			 
b4da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4da cd cd 9b			call macro_dsp_valuehl 
b4dd				endm 
# End of macro FORTH_DSP_VALUEHL
b4dd			 
b4dd e5					push hl  ; u1 
b4de			 
b4de					; destroy value TOS 
b4de			 
b4de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4de cd 85 9c			call macro_forth_dsp_pop 
b4e1				endm 
# End of macro FORTH_DSP_POP
b4e1			 
b4e1 b7			 or a      ;clear carry flag 
b4e2 e1			  pop hl    ; u1 
b4e3 d1			  pop de    ; u2 
b4e4 e5				push hl   ; saved in case hl is lowest 
b4e5 ed 52		  sbc hl,de 
b4e7 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b4e9			 
b4e9 e1				pop hl 
b4ea					if DEBUG_FORTH_WORDS 
b4ea						DMARK "MIN" 
b4ea f5				push af  
b4eb 3a ff b4			ld a, (.dmark)  
b4ee 32 71 ee			ld (debug_mark),a  
b4f1 3a 00 b5			ld a, (.dmark+1)  
b4f4 32 72 ee			ld (debug_mark+1),a  
b4f7 3a 01 b5			ld a, (.dmark+2)  
b4fa 32 73 ee			ld (debug_mark+2),a  
b4fd 18 03			jr .pastdmark  
b4ff ..			.dmark: db "MIN"  
b502 f1			.pastdmark: pop af  
b503			endm  
# End of macro DMARK
b503						CALLMONITOR 
b503 cd 7c 93			call break_point_state  
b506				endm  
# End of macro CALLMONITOR
b506					endif 
b506 cd d6 99				call forth_push_numhl 
b509			 
b509				       NEXTW 
b509 c3 3f 9d			jp macro_next 
b50c				endm 
# End of macro NEXTW
b50c			 
b50c			.mincont:  
b50c c1				pop bc   ; tidy up 
b50d eb				ex de , hl  
b50e					if DEBUG_FORTH_WORDS 
b50e						DMARK "MI1" 
b50e f5				push af  
b50f 3a 23 b5			ld a, (.dmark)  
b512 32 71 ee			ld (debug_mark),a  
b515 3a 24 b5			ld a, (.dmark+1)  
b518 32 72 ee			ld (debug_mark+1),a  
b51b 3a 25 b5			ld a, (.dmark+2)  
b51e 32 73 ee			ld (debug_mark+2),a  
b521 18 03			jr .pastdmark  
b523 ..			.dmark: db "MI1"  
b526 f1			.pastdmark: pop af  
b527			endm  
# End of macro DMARK
b527						CALLMONITOR 
b527 cd 7c 93			call break_point_state  
b52a				endm  
# End of macro CALLMONITOR
b52a					endif 
b52a cd d6 99				call forth_push_numhl 
b52d			 
b52d				       NEXTW 
b52d c3 3f 9d			jp macro_next 
b530				endm 
# End of macro NEXTW
b530			.MAX: 
b530				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b530 4a				db WORD_SYS_CORE+54             
b531 b1 b5			dw .RND16            
b533 04				db 3 + 1 
b534 .. 00			db "MAX",0              
b538				endm 
# End of macro CWHEAD
b538			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b538					if DEBUG_FORTH_WORDS_KEY 
b538						DMARK "MAX" 
b538 f5				push af  
b539 3a 4d b5			ld a, (.dmark)  
b53c 32 71 ee			ld (debug_mark),a  
b53f 3a 4e b5			ld a, (.dmark+1)  
b542 32 72 ee			ld (debug_mark+1),a  
b545 3a 4f b5			ld a, (.dmark+2)  
b548 32 73 ee			ld (debug_mark+2),a  
b54b 18 03			jr .pastdmark  
b54d ..			.dmark: db "MAX"  
b550 f1			.pastdmark: pop af  
b551			endm  
# End of macro DMARK
b551						CALLMONITOR 
b551 cd 7c 93			call break_point_state  
b554				endm  
# End of macro CALLMONITOR
b554					endif 
b554					; get u2 
b554			 
b554					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b554 cd cd 9b			call macro_dsp_valuehl 
b557				endm 
# End of macro FORTH_DSP_VALUEHL
b557			 
b557 e5					push hl   ; u2 
b558			 
b558					; destroy value TOS 
b558			 
b558					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b558 cd 85 9c			call macro_forth_dsp_pop 
b55b				endm 
# End of macro FORTH_DSP_POP
b55b			 
b55b					; get u1 
b55b			 
b55b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b55b cd cd 9b			call macro_dsp_valuehl 
b55e				endm 
# End of macro FORTH_DSP_VALUEHL
b55e			 
b55e e5					push hl  ; u1 
b55f			 
b55f					; destroy value TOS 
b55f			 
b55f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b55f cd 85 9c			call macro_forth_dsp_pop 
b562				endm 
# End of macro FORTH_DSP_POP
b562			 
b562 b7			 or a      ;clear carry flag 
b563 e1			  pop hl    ; u1 
b564 d1			  pop de    ; u2 
b565 e5				push hl   ; saved in case hl is lowest 
b566 ed 52		  sbc hl,de 
b568 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b56a			 
b56a e1				pop hl 
b56b					if DEBUG_FORTH_WORDS 
b56b						DMARK "MAX" 
b56b f5				push af  
b56c 3a 80 b5			ld a, (.dmark)  
b56f 32 71 ee			ld (debug_mark),a  
b572 3a 81 b5			ld a, (.dmark+1)  
b575 32 72 ee			ld (debug_mark+1),a  
b578 3a 82 b5			ld a, (.dmark+2)  
b57b 32 73 ee			ld (debug_mark+2),a  
b57e 18 03			jr .pastdmark  
b580 ..			.dmark: db "MAX"  
b583 f1			.pastdmark: pop af  
b584			endm  
# End of macro DMARK
b584						CALLMONITOR 
b584 cd 7c 93			call break_point_state  
b587				endm  
# End of macro CALLMONITOR
b587					endif 
b587 cd d6 99				call forth_push_numhl 
b58a			 
b58a				       NEXTW 
b58a c3 3f 9d			jp macro_next 
b58d				endm 
# End of macro NEXTW
b58d			 
b58d			.maxcont:  
b58d c1				pop bc   ; tidy up 
b58e eb				ex de , hl  
b58f					if DEBUG_FORTH_WORDS 
b58f						DMARK "MA1" 
b58f f5				push af  
b590 3a a4 b5			ld a, (.dmark)  
b593 32 71 ee			ld (debug_mark),a  
b596 3a a5 b5			ld a, (.dmark+1)  
b599 32 72 ee			ld (debug_mark+1),a  
b59c 3a a6 b5			ld a, (.dmark+2)  
b59f 32 73 ee			ld (debug_mark+2),a  
b5a2 18 03			jr .pastdmark  
b5a4 ..			.dmark: db "MA1"  
b5a7 f1			.pastdmark: pop af  
b5a8			endm  
# End of macro DMARK
b5a8						CALLMONITOR 
b5a8 cd 7c 93			call break_point_state  
b5ab				endm  
# End of macro CALLMONITOR
b5ab					endif 
b5ab cd d6 99				call forth_push_numhl 
b5ae				       NEXTW 
b5ae c3 3f 9d			jp macro_next 
b5b1				endm 
# End of macro NEXTW
b5b1			 
b5b1			.RND16: 
b5b1				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b5b1 4e				db WORD_SYS_CORE+58             
b5b2 e0 b5			dw .RND8            
b5b4 06				db 5 + 1 
b5b5 .. 00			db "RND16",0              
b5bb				endm 
# End of macro CWHEAD
b5bb			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b5bb					if DEBUG_FORTH_WORDS_KEY 
b5bb						DMARK "R16" 
b5bb f5				push af  
b5bc 3a d0 b5			ld a, (.dmark)  
b5bf 32 71 ee			ld (debug_mark),a  
b5c2 3a d1 b5			ld a, (.dmark+1)  
b5c5 32 72 ee			ld (debug_mark+1),a  
b5c8 3a d2 b5			ld a, (.dmark+2)  
b5cb 32 73 ee			ld (debug_mark+2),a  
b5ce 18 03			jr .pastdmark  
b5d0 ..			.dmark: db "R16"  
b5d3 f1			.pastdmark: pop af  
b5d4			endm  
# End of macro DMARK
b5d4						CALLMONITOR 
b5d4 cd 7c 93			call break_point_state  
b5d7				endm  
# End of macro CALLMONITOR
b5d7					endif 
b5d7 cd a2 8a				call prng16  
b5da cd d6 99				call forth_push_numhl 
b5dd				       NEXTW 
b5dd c3 3f 9d			jp macro_next 
b5e0				endm 
# End of macro NEXTW
b5e0			.RND8: 
b5e0				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b5e0 60				db WORD_SYS_CORE+76             
b5e1 15 b6			dw .RND            
b5e3 05				db 4 + 1 
b5e4 .. 00			db "RND8",0              
b5e9				endm 
# End of macro CWHEAD
b5e9			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b5e9					if DEBUG_FORTH_WORDS_KEY 
b5e9						DMARK "RN8" 
b5e9 f5				push af  
b5ea 3a fe b5			ld a, (.dmark)  
b5ed 32 71 ee			ld (debug_mark),a  
b5f0 3a ff b5			ld a, (.dmark+1)  
b5f3 32 72 ee			ld (debug_mark+1),a  
b5f6 3a 00 b6			ld a, (.dmark+2)  
b5f9 32 73 ee			ld (debug_mark+2),a  
b5fc 18 03			jr .pastdmark  
b5fe ..			.dmark: db "RN8"  
b601 f1			.pastdmark: pop af  
b602			endm  
# End of macro DMARK
b602						CALLMONITOR 
b602 cd 7c 93			call break_point_state  
b605				endm  
# End of macro CALLMONITOR
b605					endif 
b605 2a b2 eb				ld hl,(xrandc) 
b608 23					inc hl 
b609 cd bc 8a				call xrnd 
b60c 6f					ld l,a	 
b60d 26 00				ld h,0 
b60f cd d6 99				call forth_push_numhl 
b612				       NEXTW 
b612 c3 3f 9d			jp macro_next 
b615				endm 
# End of macro NEXTW
b615			.RND: 
b615				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b615 60				db WORD_SYS_CORE+76             
b616 1b b7			dw .ENDMATHS            
b618 04				db 3 + 1 
b619 .. 00			db "RND",0              
b61d				endm 
# End of macro CWHEAD
b61d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b61d			 
b61d					if DEBUG_FORTH_WORDS_KEY 
b61d						DMARK "RND" 
b61d f5				push af  
b61e 3a 32 b6			ld a, (.dmark)  
b621 32 71 ee			ld (debug_mark),a  
b624 3a 33 b6			ld a, (.dmark+1)  
b627 32 72 ee			ld (debug_mark+1),a  
b62a 3a 34 b6			ld a, (.dmark+2)  
b62d 32 73 ee			ld (debug_mark+2),a  
b630 18 03			jr .pastdmark  
b632 ..			.dmark: db "RND"  
b635 f1			.pastdmark: pop af  
b636			endm  
# End of macro DMARK
b636						CALLMONITOR 
b636 cd 7c 93			call break_point_state  
b639				endm  
# End of macro CALLMONITOR
b639					endif 
b639					 
b639					FORTH_DSP_VALUEHL    ; upper range 
b639 cd cd 9b			call macro_dsp_valuehl 
b63c				endm 
# End of macro FORTH_DSP_VALUEHL
b63c			 
b63c 22 b6 eb				ld (LFSRSeed), hl	 
b63f			 
b63f					if DEBUG_FORTH_WORDS 
b63f						DMARK "RN1" 
b63f f5				push af  
b640 3a 54 b6			ld a, (.dmark)  
b643 32 71 ee			ld (debug_mark),a  
b646 3a 55 b6			ld a, (.dmark+1)  
b649 32 72 ee			ld (debug_mark+1),a  
b64c 3a 56 b6			ld a, (.dmark+2)  
b64f 32 73 ee			ld (debug_mark+2),a  
b652 18 03			jr .pastdmark  
b654 ..			.dmark: db "RN1"  
b657 f1			.pastdmark: pop af  
b658			endm  
# End of macro DMARK
b658						CALLMONITOR 
b658 cd 7c 93			call break_point_state  
b65b				endm  
# End of macro CALLMONITOR
b65b					endif 
b65b					FORTH_DSP_POP 
b65b cd 85 9c			call macro_forth_dsp_pop 
b65e				endm 
# End of macro FORTH_DSP_POP
b65e			 
b65e					FORTH_DSP_VALUEHL    ; low range 
b65e cd cd 9b			call macro_dsp_valuehl 
b661				endm 
# End of macro FORTH_DSP_VALUEHL
b661			 
b661					if DEBUG_FORTH_WORDS 
b661						DMARK "RN2" 
b661 f5				push af  
b662 3a 76 b6			ld a, (.dmark)  
b665 32 71 ee			ld (debug_mark),a  
b668 3a 77 b6			ld a, (.dmark+1)  
b66b 32 72 ee			ld (debug_mark+1),a  
b66e 3a 78 b6			ld a, (.dmark+2)  
b671 32 73 ee			ld (debug_mark+2),a  
b674 18 03			jr .pastdmark  
b676 ..			.dmark: db "RN2"  
b679 f1			.pastdmark: pop af  
b67a			endm  
# End of macro DMARK
b67a						CALLMONITOR 
b67a cd 7c 93			call break_point_state  
b67d				endm  
# End of macro CALLMONITOR
b67d					endif 
b67d 22 b8 eb				ld (LFSRSeed+2), hl 
b680			 
b680					FORTH_DSP_POP 
b680 cd 85 9c			call macro_forth_dsp_pop 
b683				endm 
# End of macro FORTH_DSP_POP
b683			 
b683 e5					push hl 
b684			 
b684 e1			.inrange:	pop hl 
b685 cd a2 8a				call prng16  
b688					if DEBUG_FORTH_WORDS 
b688						DMARK "RN3" 
b688 f5				push af  
b689 3a 9d b6			ld a, (.dmark)  
b68c 32 71 ee			ld (debug_mark),a  
b68f 3a 9e b6			ld a, (.dmark+1)  
b692 32 72 ee			ld (debug_mark+1),a  
b695 3a 9f b6			ld a, (.dmark+2)  
b698 32 73 ee			ld (debug_mark+2),a  
b69b 18 03			jr .pastdmark  
b69d ..			.dmark: db "RN3"  
b6a0 f1			.pastdmark: pop af  
b6a1			endm  
# End of macro DMARK
b6a1						CALLMONITOR 
b6a1 cd 7c 93			call break_point_state  
b6a4				endm  
# End of macro CALLMONITOR
b6a4					endif 
b6a4					 
b6a4					; if the range is 8bit knock out the high byte 
b6a4			 
b6a4 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b6a8			 
b6a8 3e 00				ld a, 0 
b6aa ba					cp d  
b6ab 20 1e				jr nz, .hirange 
b6ad 26 00				ld h, 0   ; knock it down to 8bit 
b6af			 
b6af					if DEBUG_FORTH_WORDS 
b6af						DMARK "RNk" 
b6af f5				push af  
b6b0 3a c4 b6			ld a, (.dmark)  
b6b3 32 71 ee			ld (debug_mark),a  
b6b6 3a c5 b6			ld a, (.dmark+1)  
b6b9 32 72 ee			ld (debug_mark+1),a  
b6bc 3a c6 b6			ld a, (.dmark+2)  
b6bf 32 73 ee			ld (debug_mark+2),a  
b6c2 18 03			jr .pastdmark  
b6c4 ..			.dmark: db "RNk"  
b6c7 f1			.pastdmark: pop af  
b6c8			endm  
# End of macro DMARK
b6c8						CALLMONITOR 
b6c8 cd 7c 93			call break_point_state  
b6cb				endm  
# End of macro CALLMONITOR
b6cb					endif 
b6cb			.hirange:   
b6cb e5					push hl  
b6cc b7					or a  
b6cd ed 52		                sbc hl, de 
b6cf			 
b6cf					;call cmp16 
b6cf			 
b6cf 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b6d1 e1					pop hl 
b6d2 e5					push hl 
b6d3			 
b6d3					if DEBUG_FORTH_WORDS 
b6d3						DMARK "RN4" 
b6d3 f5				push af  
b6d4 3a e8 b6			ld a, (.dmark)  
b6d7 32 71 ee			ld (debug_mark),a  
b6da 3a e9 b6			ld a, (.dmark+1)  
b6dd 32 72 ee			ld (debug_mark+1),a  
b6e0 3a ea b6			ld a, (.dmark+2)  
b6e3 32 73 ee			ld (debug_mark+2),a  
b6e6 18 03			jr .pastdmark  
b6e8 ..			.dmark: db "RN4"  
b6eb f1			.pastdmark: pop af  
b6ec			endm  
# End of macro DMARK
b6ec						CALLMONITOR 
b6ec cd 7c 93			call break_point_state  
b6ef				endm  
# End of macro CALLMONITOR
b6ef					endif 
b6ef ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b6f3					;call cmp16 
b6f3				 
b6f3 b7					or a  
b6f4 ed 52		                sbc hl, de 
b6f6 38 8c				jr c, .inrange 
b6f8			 
b6f8 e1					pop hl 
b6f9					 
b6f9					if DEBUG_FORTH_WORDS 
b6f9						DMARK "RNd" 
b6f9 f5				push af  
b6fa 3a 0e b7			ld a, (.dmark)  
b6fd 32 71 ee			ld (debug_mark),a  
b700 3a 0f b7			ld a, (.dmark+1)  
b703 32 72 ee			ld (debug_mark+1),a  
b706 3a 10 b7			ld a, (.dmark+2)  
b709 32 73 ee			ld (debug_mark+2),a  
b70c 18 03			jr .pastdmark  
b70e ..			.dmark: db "RNd"  
b711 f1			.pastdmark: pop af  
b712			endm  
# End of macro DMARK
b712						CALLMONITOR 
b712 cd 7c 93			call break_point_state  
b715				endm  
# End of macro CALLMONITOR
b715					endif 
b715			 
b715			 
b715 cd d6 99				call forth_push_numhl 
b718				       NEXTW 
b718 c3 3f 9d			jp macro_next 
b71b				endm 
# End of macro NEXTW
b71b			 
b71b			.ENDMATHS: 
b71b			 
b71b			; eof 
b71b			 
# End of file forth_words_maths.asm
b71b			include "forth_words_display.asm" 
b71b			 
b71b			; | ## Display Words 
b71b			 
b71b			.INFO: 
b71b			 
b71b				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b71b 62				db WORD_SYS_CORE+78             
b71c 38 b7			dw .ATP            
b71e 05				db 4 + 1 
b71f .. 00			db "INFO",0              
b724				endm 
# End of macro CWHEAD
b724			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b724					FORTH_DSP_VALUEHL 
b724 cd cd 9b			call macro_dsp_valuehl 
b727				endm 
# End of macro FORTH_DSP_VALUEHL
b727			 
b727					FORTH_DSP_POP 
b727 cd 85 9c			call macro_forth_dsp_pop 
b72a				endm 
# End of macro FORTH_DSP_POP
b72a			 
b72a e5					push hl 
b72b			 
b72b					FORTH_DSP_VALUEHL 
b72b cd cd 9b			call macro_dsp_valuehl 
b72e				endm 
# End of macro FORTH_DSP_VALUEHL
b72e			 
b72e					FORTH_DSP_POP 
b72e cd 85 9c			call macro_forth_dsp_pop 
b731				endm 
# End of macro FORTH_DSP_POP
b731			 
b731 d1					pop de 
b732			 
b732 cd df 88				call info_panel 
b735			 
b735			 
b735					NEXTW 
b735 c3 3f 9d			jp macro_next 
b738				endm 
# End of macro NEXTW
b738			.ATP: 
b738				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b738 62				db WORD_SYS_CORE+78             
b739 af b7			dw .FB            
b73b 04				db 3 + 1 
b73c .. 00			db "AT?",0              
b740				endm 
# End of macro CWHEAD
b740			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b740					if DEBUG_FORTH_WORDS_KEY 
b740						DMARK "AT?" 
b740 f5				push af  
b741 3a 55 b7			ld a, (.dmark)  
b744 32 71 ee			ld (debug_mark),a  
b747 3a 56 b7			ld a, (.dmark+1)  
b74a 32 72 ee			ld (debug_mark+1),a  
b74d 3a 57 b7			ld a, (.dmark+2)  
b750 32 73 ee			ld (debug_mark+2),a  
b753 18 03			jr .pastdmark  
b755 ..			.dmark: db "AT?"  
b758 f1			.pastdmark: pop af  
b759			endm  
# End of macro DMARK
b759						CALLMONITOR 
b759 cd 7c 93			call break_point_state  
b75c				endm  
# End of macro CALLMONITOR
b75c					endif 
b75c 3a 40 eb				ld a, (f_cursor_ptr) 
b75f			 
b75f			if DEBUG_FORTH_WORDS 
b75f				DMARK "AT?" 
b75f f5				push af  
b760 3a 74 b7			ld a, (.dmark)  
b763 32 71 ee			ld (debug_mark),a  
b766 3a 75 b7			ld a, (.dmark+1)  
b769 32 72 ee			ld (debug_mark+1),a  
b76c 3a 76 b7			ld a, (.dmark+2)  
b76f 32 73 ee			ld (debug_mark+2),a  
b772 18 03			jr .pastdmark  
b774 ..			.dmark: db "AT?"  
b777 f1			.pastdmark: pop af  
b778			endm  
# End of macro DMARK
b778				CALLMONITOR 
b778 cd 7c 93			call break_point_state  
b77b				endm  
# End of macro CALLMONITOR
b77b			endif	 
b77b					; count the number of rows 
b77b			 
b77b 06 00				ld b, 0 
b77d 4f			.atpr:		ld c, a    ; save in case we go below zero 
b77e d6 28				sub display_cols 
b780 f2 86 b7				jp p, .atprunder 
b783 04					inc b 
b784 18 f7				jr .atpr 
b786			.atprunder:	 
b786			if DEBUG_FORTH_WORDS 
b786				DMARK "A?2" 
b786 f5				push af  
b787 3a 9b b7			ld a, (.dmark)  
b78a 32 71 ee			ld (debug_mark),a  
b78d 3a 9c b7			ld a, (.dmark+1)  
b790 32 72 ee			ld (debug_mark+1),a  
b793 3a 9d b7			ld a, (.dmark+2)  
b796 32 73 ee			ld (debug_mark+2),a  
b799 18 03			jr .pastdmark  
b79b ..			.dmark: db "A?2"  
b79e f1			.pastdmark: pop af  
b79f			endm  
# End of macro DMARK
b79f				CALLMONITOR 
b79f cd 7c 93			call break_point_state  
b7a2				endm  
# End of macro CALLMONITOR
b7a2			endif	 
b7a2 26 00				ld h, 0 
b7a4 69					ld l, c 
b7a5 cd d6 99				call forth_push_numhl 
b7a8 68					ld l, b  
b7a9 cd d6 99				call forth_push_numhl 
b7ac			 
b7ac			 
b7ac				NEXTW 
b7ac c3 3f 9d			jp macro_next 
b7af				endm 
# End of macro NEXTW
b7af			 
b7af			.FB: 
b7af				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b7af 1b				db WORD_SYS_CORE+7             
b7b0 fd b7			dw .EMIT            
b7b2 03				db 2 + 1 
b7b3 .. 00			db "FB",0              
b7b6				endm 
# End of macro CWHEAD
b7b6			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b7b6			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b7b6			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b7b6			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b7b6					if DEBUG_FORTH_WORDS_KEY 
b7b6						DMARK "FB." 
b7b6 f5				push af  
b7b7 3a cb b7			ld a, (.dmark)  
b7ba 32 71 ee			ld (debug_mark),a  
b7bd 3a cc b7			ld a, (.dmark+1)  
b7c0 32 72 ee			ld (debug_mark+1),a  
b7c3 3a cd b7			ld a, (.dmark+2)  
b7c6 32 73 ee			ld (debug_mark+2),a  
b7c9 18 03			jr .pastdmark  
b7cb ..			.dmark: db "FB."  
b7ce f1			.pastdmark: pop af  
b7cf			endm  
# End of macro DMARK
b7cf						CALLMONITOR 
b7cf cd 7c 93			call break_point_state  
b7d2				endm  
# End of macro CALLMONITOR
b7d2					endif 
b7d2			 
b7d2					FORTH_DSP_VALUEHL 
b7d2 cd cd 9b			call macro_dsp_valuehl 
b7d5				endm 
# End of macro FORTH_DSP_VALUEHL
b7d5			 
b7d5 7d					ld a, l 
b7d6 fe 01				cp 1 
b7d8 20 05				jr nz, .fbn1 
b7da 21 16 ed				ld hl, display_fb1 
b7dd 18 15				jr .fbset 
b7df fe 02		.fbn1:		cp 2 
b7e1 20 05				jr nz, .fbn2 
b7e3 21 d4 eb				ld hl, display_fb2 
b7e6 18 0c				jr .fbset 
b7e8 fe 03		.fbn2:		cp 3 
b7ea 20 05				jr nz, .fbn3 
b7ec 21 75 ec				ld hl, display_fb3 
b7ef 18 03				jr .fbset 
b7f1			.fbn3:		 ; if invalid number select first 
b7f1 21 16 ed				ld hl, display_fb1 
b7f4 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b7f7			 
b7f7					FORTH_DSP_POP 
b7f7 cd 85 9c			call macro_forth_dsp_pop 
b7fa				endm 
# End of macro FORTH_DSP_POP
b7fa			 
b7fa					NEXTW 
b7fa c3 3f 9d			jp macro_next 
b7fd				endm 
# End of macro NEXTW
b7fd			 
b7fd			 
b7fd			.EMIT: 
b7fd				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b7fd 1b				db WORD_SYS_CORE+7             
b7fe 4e b8			dw .DOTH            
b800 05				db 4 + 1 
b801 .. 00			db "EMIT",0              
b806				endm 
# End of macro CWHEAD
b806			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b806					; get value off TOS and display it 
b806			 
b806					if DEBUG_FORTH_WORDS_KEY 
b806						DMARK "EMT" 
b806 f5				push af  
b807 3a 1b b8			ld a, (.dmark)  
b80a 32 71 ee			ld (debug_mark),a  
b80d 3a 1c b8			ld a, (.dmark+1)  
b810 32 72 ee			ld (debug_mark+1),a  
b813 3a 1d b8			ld a, (.dmark+2)  
b816 32 73 ee			ld (debug_mark+2),a  
b819 18 03			jr .pastdmark  
b81b ..			.dmark: db "EMT"  
b81e f1			.pastdmark: pop af  
b81f			endm  
# End of macro DMARK
b81f						CALLMONITOR 
b81f cd 7c 93			call break_point_state  
b822				endm  
# End of macro CALLMONITOR
b822					endif 
b822			 
b822					FORTH_DSP_VALUEHL 
b822 cd cd 9b			call macro_dsp_valuehl 
b825				endm 
# End of macro FORTH_DSP_VALUEHL
b825			 
b825 7d					ld a,l 
b826			 
b826					; TODO write to display 
b826			 
b826 32 55 e5				ld (os_input), a 
b829 3e 00				ld a, 0 
b82b 32 56 e5				ld (os_input+1), a 
b82e					 
b82e 3a 40 eb				ld a, (f_cursor_ptr) 
b831 11 55 e5				ld de, os_input 
b834 cd 61 89				call str_at_display 
b837			 
b837			 
b837 3a 1e eb				ld a,(cli_autodisplay) 
b83a fe 00				cp 0 
b83c 28 03				jr z, .enoupdate 
b83e cd 71 89						call update_display 
b841					.enoupdate: 
b841			 
b841 3a 40 eb				ld a, (f_cursor_ptr) 
b844 3c					inc a 
b845 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
b848			 
b848			 
b848					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b848 cd 85 9c			call macro_forth_dsp_pop 
b84b				endm 
# End of macro FORTH_DSP_POP
b84b			  
b84b			 
b84b					NEXTW 
b84b c3 3f 9d			jp macro_next 
b84e				endm 
# End of macro NEXTW
b84e			.DOTH: 
b84e				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b84e 1c				db WORD_SYS_CORE+8             
b84f 7e b8			dw .DOTF            
b851 03				db 2 + 1 
b852 .. 00			db ".-",0              
b855				endm 
# End of macro CWHEAD
b855			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b855					; get value off TOS and display it 
b855					if DEBUG_FORTH_WORDS_KEY 
b855						DMARK "DTD" 
b855 f5				push af  
b856 3a 6a b8			ld a, (.dmark)  
b859 32 71 ee			ld (debug_mark),a  
b85c 3a 6b b8			ld a, (.dmark+1)  
b85f 32 72 ee			ld (debug_mark+1),a  
b862 3a 6c b8			ld a, (.dmark+2)  
b865 32 73 ee			ld (debug_mark+2),a  
b868 18 03			jr .pastdmark  
b86a ..			.dmark: db "DTD"  
b86d f1			.pastdmark: pop af  
b86e			endm  
# End of macro DMARK
b86e						CALLMONITOR 
b86e cd 7c 93			call break_point_state  
b871				endm  
# End of macro CALLMONITOR
b871					endif 
b871 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b873 3e 00			ld a, 0 
b875 32 1f eb			ld (cli_mvdot), a 
b878 c3 d5 b8			jp .dotgo 
b87b				NEXTW 
b87b c3 3f 9d			jp macro_next 
b87e				endm 
# End of macro NEXTW
b87e			.DOTF: 
b87e				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b87e 1c				db WORD_SYS_CORE+8             
b87f ac b8			dw .DOT            
b881 03				db 2 + 1 
b882 .. 00			db ".>",0              
b885				endm 
# End of macro CWHEAD
b885			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b885					; get value off TOS and display it 
b885			        ; TODO BUG adds extra spaces 
b885			        ; TODO BUG handle numerics? 
b885					if DEBUG_FORTH_WORDS_KEY 
b885						DMARK "DTC" 
b885 f5				push af  
b886 3a 9a b8			ld a, (.dmark)  
b889 32 71 ee			ld (debug_mark),a  
b88c 3a 9b b8			ld a, (.dmark+1)  
b88f 32 72 ee			ld (debug_mark+1),a  
b892 3a 9c b8			ld a, (.dmark+2)  
b895 32 73 ee			ld (debug_mark+2),a  
b898 18 03			jr .pastdmark  
b89a ..			.dmark: db "DTC"  
b89d f1			.pastdmark: pop af  
b89e			endm  
# End of macro DMARK
b89e						CALLMONITOR 
b89e cd 7c 93			call break_point_state  
b8a1				endm  
# End of macro CALLMONITOR
b8a1					endif 
b8a1 3e 01			ld a, 1 
b8a3 32 1f eb			ld (cli_mvdot), a 
b8a6 c3 d5 b8			jp .dotgo 
b8a9				NEXTW 
b8a9 c3 3f 9d			jp macro_next 
b8ac				endm 
# End of macro NEXTW
b8ac			 
b8ac			.DOT: 
b8ac				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b8ac 1c				db WORD_SYS_CORE+8             
b8ad 38 b9			dw .CLS            
b8af 02				db 1 + 1 
b8b0 .. 00			db ".",0              
b8b2				endm 
# End of macro CWHEAD
b8b2			        ; | . ( u -- ) Display TOS | DONE 
b8b2					; get value off TOS and display it 
b8b2			 
b8b2					if DEBUG_FORTH_WORDS_KEY 
b8b2						DMARK "DOT" 
b8b2 f5				push af  
b8b3 3a c7 b8			ld a, (.dmark)  
b8b6 32 71 ee			ld (debug_mark),a  
b8b9 3a c8 b8			ld a, (.dmark+1)  
b8bc 32 72 ee			ld (debug_mark+1),a  
b8bf 3a c9 b8			ld a, (.dmark+2)  
b8c2 32 73 ee			ld (debug_mark+2),a  
b8c5 18 03			jr .pastdmark  
b8c7 ..			.dmark: db "DOT"  
b8ca f1			.pastdmark: pop af  
b8cb			endm  
# End of macro DMARK
b8cb						CALLMONITOR 
b8cb cd 7c 93			call break_point_state  
b8ce				endm  
# End of macro CALLMONITOR
b8ce					endif 
b8ce 3e 00			ld a, 0 
b8d0 32 1f eb			ld (cli_mvdot), a 
b8d3 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b8d5				 
b8d5			 
b8d5			.dotgo: 
b8d5			 
b8d5			; move up type to on stack for parserv5 
b8d5					FORTH_DSP 
b8d5 cd 93 9b			call macro_forth_dsp 
b8d8				endm 
# End of macro FORTH_DSP
b8d8				;FORTH_DSP_VALUE  
b8d8			 
b8d8			if DEBUG_FORTH_DOT 
b8d8				DMARK "DOT" 
b8d8				CALLMONITOR 
b8d8			endif	 
b8d8			;		.print: 
b8d8			 
b8d8 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b8d9 23				inc hl   ; position to the actual value 
b8da fe 01			cp DS_TYPE_STR 
b8dc 20 06			jr nz, .dotnum1  
b8de			 
b8de			; display string 
b8de				FORTH_DSP_VALUE  
b8de cd b6 9b			call macro_forth_dsp_value 
b8e1				endm 
# End of macro FORTH_DSP_VALUE
b8e1 eb				ex de,hl 
b8e2 18 11			jr .dotwrite 
b8e4			 
b8e4			.dotnum1: 
b8e4 fe 02			cp DS_TYPE_INUM 
b8e6 20 0c			jr nz, .dotflot 
b8e8			 
b8e8			 
b8e8			; display number 
b8e8			 
b8e8			;	push hl 
b8e8			;	call clear_display 
b8e8			;	pop hl 
b8e8			 
b8e8 5e				ld e, (hl) 
b8e9 23				inc hl 
b8ea 56				ld d, (hl) 
b8eb 21 57 e3			ld hl, scratch 
b8ee			if DEBUG_FORTH_DOT 
b8ee				DMARK "DT1" 
b8ee				CALLMONITOR 
b8ee			endif	 
b8ee			 
b8ee cd 88 8f			call uitoa_16 
b8f1 eb				ex de,hl 
b8f2			 
b8f2			if DEBUG_FORTH_DOT 
b8f2				DMARK "DT2" 
b8f2				CALLMONITOR 
b8f2			endif	 
b8f2			 
b8f2			;	ld de, os_word_scratch 
b8f2 18 01			jr .dotwrite 
b8f4			 
b8f4 00			.dotflot:   nop 
b8f5			; TODO print floating point number 
b8f5			 
b8f5			.dotwrite:		 
b8f5			 
b8f5					; if c is set then set all '-' to spaces 
b8f5					; need to also take into account .>  
b8f5			 
b8f5 3e 01				ld a, 1 
b8f7 b9					cp c 
b8f8 20 13				jr nz, .nodashswap 
b8fa			 
b8fa					; DE has the string to write, working with HL 
b8fa			 
b8fa 06 ff				ld b, 255 
b8fc d5					push de 
b8fd e1					pop hl 
b8fe			 
b8fe			if DEBUG_FORTH_DOT 
b8fe				DMARK "DT-" 
b8fe				CALLMONITOR 
b8fe			endif	 
b8fe 7e			.dashscan:	ld a, (hl) 
b8ff fe 00				cp 0 
b901 28 0a				jr z, .nodashswap 
b903 fe 2d				cp '-' 
b905 20 03				jr nz, .dashskip 
b907 3e 20				ld a, ' ' 
b909 77					ld (hl), a 
b90a 23			.dashskip:	inc hl 
b90b			if DEBUG_FORTH_DOT 
b90b				DMARK "D-2" 
b90b				CALLMONITOR 
b90b			endif	 
b90b 10 f1				djnz .dashscan 
b90d			 
b90d			if DEBUG_FORTH_DOT 
b90d				DMARK "D-1" 
b90d				CALLMONITOR 
b90d			endif	 
b90d			 
b90d			.nodashswap: 
b90d			 
b90d e5					push hl   ; save string start in case we need to advance print 
b90e			 
b90e 3a 40 eb				ld a, (f_cursor_ptr) 
b911 cd 61 89				call str_at_display 
b914 3a 1e eb				ld a,(cli_autodisplay) 
b917 fe 00				cp 0 
b919 28 03				jr z, .noupdate 
b91b cd 71 89						call update_display 
b91e					.noupdate: 
b91e			 
b91e			 
b91e					; see if we need to advance the print position 
b91e			 
b91e e1					pop hl   ; get back string 
b91f			 
b91f 3a 1f eb				ld a, (cli_mvdot) 
b922			if DEBUG_FORTH_DOT 
b922					ld e,a 
b922				DMARK "D>1" 
b922				CALLMONITOR 
b922			endif	 
b922 fe 00				cp 0 
b924 28 0c				jr z, .noadv 
b926					; yes, lets advance the print position 
b926 3e 00				ld a, 0 
b928 cd e4 8f				call strlent 
b92b 3a 40 eb				ld a, (f_cursor_ptr) 
b92e 85					add a,l 
b92f					;call addatohl 
b92f					;ld a, l 
b92f 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
b932			 
b932			if DEBUG_FORTH_DOT 
b932				DMARK "D->" 
b932				CALLMONITOR 
b932			endif	 
b932			 
b932			.noadv:	 
b932			 
b932					if DEBUG_FORTH_DOT_WAIT 
b932							call next_page_prompt 
b932					endif	 
b932			; TODO this pop off the stack causes a crash. i dont know why 
b932			 
b932			 
b932			if DEBUG_FORTH_DOT 
b932				DMARK "DTh" 
b932				CALLMONITOR 
b932			endif	 
b932			 
b932					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b932 cd 85 9c			call macro_forth_dsp_pop 
b935				endm 
# End of macro FORTH_DSP_POP
b935			 
b935			if DEBUG_FORTH_DOT 
b935				DMARK "DTi" 
b935				CALLMONITOR 
b935			endif	 
b935			 
b935			 
b935					NEXTW 
b935 c3 3f 9d			jp macro_next 
b938				endm 
# End of macro NEXTW
b938			 
b938			.CLS: 
b938				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b938 35				db WORD_SYS_CORE+33             
b939 65 b9			dw .DRAW            
b93b 04				db 3 + 1 
b93c .. 00			db "CLS",0              
b940				endm 
# End of macro CWHEAD
b940			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b940					if DEBUG_FORTH_WORDS_KEY 
b940						DMARK "CLS" 
b940 f5				push af  
b941 3a 55 b9			ld a, (.dmark)  
b944 32 71 ee			ld (debug_mark),a  
b947 3a 56 b9			ld a, (.dmark+1)  
b94a 32 72 ee			ld (debug_mark+1),a  
b94d 3a 57 b9			ld a, (.dmark+2)  
b950 32 73 ee			ld (debug_mark+2),a  
b953 18 03			jr .pastdmark  
b955 ..			.dmark: db "CLS"  
b958 f1			.pastdmark: pop af  
b959			endm  
# End of macro DMARK
b959						CALLMONITOR 
b959 cd 7c 93			call break_point_state  
b95c				endm  
# End of macro CALLMONITOR
b95c					endif 
b95c cd 4e 89				call clear_display 
b95f c3 73 ba				jp .home		; and home cursor 
b962					NEXTW 
b962 c3 3f 9d			jp macro_next 
b965				endm 
# End of macro NEXTW
b965			 
b965			.DRAW: 
b965				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b965 36				db WORD_SYS_CORE+34             
b966 90 b9			dw .DUMP            
b968 05				db 4 + 1 
b969 .. 00			db "DRAW",0              
b96e				endm 
# End of macro CWHEAD
b96e			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b96e					if DEBUG_FORTH_WORDS_KEY 
b96e						DMARK "DRW" 
b96e f5				push af  
b96f 3a 83 b9			ld a, (.dmark)  
b972 32 71 ee			ld (debug_mark),a  
b975 3a 84 b9			ld a, (.dmark+1)  
b978 32 72 ee			ld (debug_mark+1),a  
b97b 3a 85 b9			ld a, (.dmark+2)  
b97e 32 73 ee			ld (debug_mark+2),a  
b981 18 03			jr .pastdmark  
b983 ..			.dmark: db "DRW"  
b986 f1			.pastdmark: pop af  
b987			endm  
# End of macro DMARK
b987						CALLMONITOR 
b987 cd 7c 93			call break_point_state  
b98a				endm  
# End of macro CALLMONITOR
b98a					endif 
b98a cd 71 89				call update_display 
b98d					NEXTW 
b98d c3 3f 9d			jp macro_next 
b990				endm 
# End of macro NEXTW
b990			 
b990			.DUMP: 
b990				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b990 37				db WORD_SYS_CORE+35             
b991 c8 b9			dw .CDUMP            
b993 05				db 4 + 1 
b994 .. 00			db "DUMP",0              
b999				endm 
# End of macro CWHEAD
b999			; | DUMP ( x -- ) With address x display dump   | DONE 
b999			; TODO pop address to use off of the stack 
b999					if DEBUG_FORTH_WORDS_KEY 
b999						DMARK "DUM" 
b999 f5				push af  
b99a 3a ae b9			ld a, (.dmark)  
b99d 32 71 ee			ld (debug_mark),a  
b9a0 3a af b9			ld a, (.dmark+1)  
b9a3 32 72 ee			ld (debug_mark+1),a  
b9a6 3a b0 b9			ld a, (.dmark+2)  
b9a9 32 73 ee			ld (debug_mark+2),a  
b9ac 18 03			jr .pastdmark  
b9ae ..			.dmark: db "DUM"  
b9b1 f1			.pastdmark: pop af  
b9b2			endm  
# End of macro DMARK
b9b2						CALLMONITOR 
b9b2 cd 7c 93			call break_point_state  
b9b5				endm  
# End of macro CALLMONITOR
b9b5					endif 
b9b5 cd 4e 89				call clear_display 
b9b8			 
b9b8					; get address 
b9b8			 
b9b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9b8 cd cd 9b			call macro_dsp_valuehl 
b9bb				endm 
# End of macro FORTH_DSP_VALUEHL
b9bb				 
b9bb					; save it for cdump 
b9bb			 
b9bb 22 7a e6				ld (os_cur_ptr),hl 
b9be			 
b9be					; destroy value TOS 
b9be			 
b9be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9be cd 85 9c			call macro_forth_dsp_pop 
b9c1				endm 
# End of macro FORTH_DSP_POP
b9c1			 
b9c1 cd 56 98				call dumpcont	; skip old style of param parsing	 
b9c4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b9c5					NEXTW 
b9c5 c3 3f 9d			jp macro_next 
b9c8				endm 
# End of macro NEXTW
b9c8			.CDUMP: 
b9c8				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b9c8 38				db WORD_SYS_CORE+36             
b9c9 f8 b9			dw .DAT            
b9cb 06				db 5 + 1 
b9cc .. 00			db "CDUMP",0              
b9d2				endm 
# End of macro CWHEAD
b9d2			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b9d2					if DEBUG_FORTH_WORDS_KEY 
b9d2						DMARK "CDP" 
b9d2 f5				push af  
b9d3 3a e7 b9			ld a, (.dmark)  
b9d6 32 71 ee			ld (debug_mark),a  
b9d9 3a e8 b9			ld a, (.dmark+1)  
b9dc 32 72 ee			ld (debug_mark+1),a  
b9df 3a e9 b9			ld a, (.dmark+2)  
b9e2 32 73 ee			ld (debug_mark+2),a  
b9e5 18 03			jr .pastdmark  
b9e7 ..			.dmark: db "CDP"  
b9ea f1			.pastdmark: pop af  
b9eb			endm  
# End of macro DMARK
b9eb						CALLMONITOR 
b9eb cd 7c 93			call break_point_state  
b9ee				endm  
# End of macro CALLMONITOR
b9ee					endif 
b9ee cd 4e 89				call clear_display 
b9f1 cd 56 98				call dumpcont	 
b9f4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b9f5					NEXTW 
b9f5 c3 3f 9d			jp macro_next 
b9f8				endm 
# End of macro NEXTW
b9f8			 
b9f8			 
b9f8			 
b9f8			 
b9f8			.DAT: 
b9f8				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b9f8 3d				db WORD_SYS_CORE+41             
b9f9 4e ba			dw .HOME            
b9fb 03				db 2 + 1 
b9fc .. 00			db "AT",0              
b9ff				endm 
# End of macro CWHEAD
b9ff			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b9ff					if DEBUG_FORTH_WORDS_KEY 
b9ff						DMARK "AT." 
b9ff f5				push af  
ba00 3a 14 ba			ld a, (.dmark)  
ba03 32 71 ee			ld (debug_mark),a  
ba06 3a 15 ba			ld a, (.dmark+1)  
ba09 32 72 ee			ld (debug_mark+1),a  
ba0c 3a 16 ba			ld a, (.dmark+2)  
ba0f 32 73 ee			ld (debug_mark+2),a  
ba12 18 03			jr .pastdmark  
ba14 ..			.dmark: db "AT."  
ba17 f1			.pastdmark: pop af  
ba18			endm  
# End of macro DMARK
ba18						CALLMONITOR 
ba18 cd 7c 93			call break_point_state  
ba1b				endm  
# End of macro CALLMONITOR
ba1b					endif 
ba1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba1b cd cd 9b			call macro_dsp_valuehl 
ba1e				endm 
# End of macro FORTH_DSP_VALUEHL
ba1e			 
ba1e			 
ba1e					; TODO save cursor row 
ba1e 7d					ld a,l 
ba1f fe 02				cp 2 
ba21 20 04				jr nz, .crow3 
ba23 3e 28				ld a, display_row_2 
ba25 18 12				jr .ccol1 
ba27 fe 03		.crow3:		cp 3 
ba29 20 04				jr nz, .crow4 
ba2b 3e 50				ld a, display_row_3 
ba2d 18 0a				jr .ccol1 
ba2f fe 04		.crow4:		cp 4 
ba31 20 04				jr nz, .crow1 
ba33 3e 78				ld a, display_row_4 
ba35 18 02				jr .ccol1 
ba37 3e 00		.crow1:		ld a,display_row_1 
ba39 f5			.ccol1:		push af			; got row offset 
ba3a 6f					ld l,a 
ba3b 26 00				ld h,0 
ba3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba3d cd 85 9c			call macro_forth_dsp_pop 
ba40				endm 
# End of macro FORTH_DSP_POP
ba40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba40 cd cd 9b			call macro_dsp_valuehl 
ba43				endm 
# End of macro FORTH_DSP_VALUEHL
ba43					; TODO save cursor col 
ba43 f1					pop af 
ba44 85					add l		; add col offset 
ba45 32 40 eb				ld (f_cursor_ptr), a 
ba48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba48 cd 85 9c			call macro_forth_dsp_pop 
ba4b				endm 
# End of macro FORTH_DSP_POP
ba4b			 
ba4b					; calculate  
ba4b			 
ba4b					NEXTW 
ba4b c3 3f 9d			jp macro_next 
ba4e				endm 
# End of macro NEXTW
ba4e			 
ba4e			 
ba4e			.HOME: 
ba4e				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
ba4e 41				db WORD_SYS_CORE+45             
ba4f 7b ba			dw .SPACE            
ba51 05				db 4 + 1 
ba52 .. 00			db "HOME",0              
ba57				endm 
# End of macro CWHEAD
ba57			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
ba57					if DEBUG_FORTH_WORDS_KEY 
ba57						DMARK "HOM" 
ba57 f5				push af  
ba58 3a 6c ba			ld a, (.dmark)  
ba5b 32 71 ee			ld (debug_mark),a  
ba5e 3a 6d ba			ld a, (.dmark+1)  
ba61 32 72 ee			ld (debug_mark+1),a  
ba64 3a 6e ba			ld a, (.dmark+2)  
ba67 32 73 ee			ld (debug_mark+2),a  
ba6a 18 03			jr .pastdmark  
ba6c ..			.dmark: db "HOM"  
ba6f f1			.pastdmark: pop af  
ba70			endm  
# End of macro DMARK
ba70						CALLMONITOR 
ba70 cd 7c 93			call break_point_state  
ba73				endm  
# End of macro CALLMONITOR
ba73					endif 
ba73 3e 00		.home:		ld a, 0		; and home cursor 
ba75 32 40 eb				ld (f_cursor_ptr), a 
ba78					NEXTW 
ba78 c3 3f 9d			jp macro_next 
ba7b				endm 
# End of macro NEXTW
ba7b			 
ba7b			 
ba7b			.SPACE: 
ba7b				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
ba7b 46				db WORD_SYS_CORE+50             
ba7c a9 ba			dw .SPACES            
ba7e 03				db 2 + 1 
ba7f .. 00			db "BL",0              
ba82				endm 
# End of macro CWHEAD
ba82			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
ba82					if DEBUG_FORTH_WORDS_KEY 
ba82						DMARK "BL." 
ba82 f5				push af  
ba83 3a 97 ba			ld a, (.dmark)  
ba86 32 71 ee			ld (debug_mark),a  
ba89 3a 98 ba			ld a, (.dmark+1)  
ba8c 32 72 ee			ld (debug_mark+1),a  
ba8f 3a 99 ba			ld a, (.dmark+2)  
ba92 32 73 ee			ld (debug_mark+2),a  
ba95 18 03			jr .pastdmark  
ba97 ..			.dmark: db "BL."  
ba9a f1			.pastdmark: pop af  
ba9b			endm  
# End of macro DMARK
ba9b						CALLMONITOR 
ba9b cd 7c 93			call break_point_state  
ba9e				endm  
# End of macro CALLMONITOR
ba9e					endif 
ba9e 21 a7 ba				ld hl, .blstr 
baa1 cd 44 9a				call forth_push_str 
baa4					 
baa4				       NEXTW 
baa4 c3 3f 9d			jp macro_next 
baa7				endm 
# End of macro NEXTW
baa7			 
baa7 .. 00		.blstr: db " ", 0 
baa9			 
baa9			.SPACES: 
baa9				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
baa9 47				db WORD_SYS_CORE+51             
baaa 44 bb			dw .SCROLL            
baac 07				db 6 + 1 
baad .. 00			db "SPACES",0              
bab4				endm 
# End of macro CWHEAD
bab4			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bab4					if DEBUG_FORTH_WORDS_KEY 
bab4						DMARK "SPS" 
bab4 f5				push af  
bab5 3a c9 ba			ld a, (.dmark)  
bab8 32 71 ee			ld (debug_mark),a  
babb 3a ca ba			ld a, (.dmark+1)  
babe 32 72 ee			ld (debug_mark+1),a  
bac1 3a cb ba			ld a, (.dmark+2)  
bac4 32 73 ee			ld (debug_mark+2),a  
bac7 18 03			jr .pastdmark  
bac9 ..			.dmark: db "SPS"  
bacc f1			.pastdmark: pop af  
bacd			endm  
# End of macro DMARK
bacd						CALLMONITOR 
bacd cd 7c 93			call break_point_state  
bad0				endm  
# End of macro CALLMONITOR
bad0					endif 
bad0			 
bad0			 
bad0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bad0 cd cd 9b			call macro_dsp_valuehl 
bad3				endm 
# End of macro FORTH_DSP_VALUEHL
bad3			 
bad3			;		push hl    ; u 
bad3					if DEBUG_FORTH_WORDS 
bad3						DMARK "SPA" 
bad3 f5				push af  
bad4 3a e8 ba			ld a, (.dmark)  
bad7 32 71 ee			ld (debug_mark),a  
bada 3a e9 ba			ld a, (.dmark+1)  
badd 32 72 ee			ld (debug_mark+1),a  
bae0 3a ea ba			ld a, (.dmark+2)  
bae3 32 73 ee			ld (debug_mark+2),a  
bae6 18 03			jr .pastdmark  
bae8 ..			.dmark: db "SPA"  
baeb f1			.pastdmark: pop af  
baec			endm  
# End of macro DMARK
baec						CALLMONITOR 
baec cd 7c 93			call break_point_state  
baef				endm  
# End of macro CALLMONITOR
baef					endif 
baef			 
baef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baef cd 85 9c			call macro_forth_dsp_pop 
baf2				endm 
# End of macro FORTH_DSP_POP
baf2			;		pop hl 
baf2 4d					ld c, l 
baf3 06 00				ld b, 0 
baf5 21 57 e3				ld hl, scratch  
baf8			 
baf8					if DEBUG_FORTH_WORDS 
baf8						DMARK "SP2" 
baf8 f5				push af  
baf9 3a 0d bb			ld a, (.dmark)  
bafc 32 71 ee			ld (debug_mark),a  
baff 3a 0e bb			ld a, (.dmark+1)  
bb02 32 72 ee			ld (debug_mark+1),a  
bb05 3a 0f bb			ld a, (.dmark+2)  
bb08 32 73 ee			ld (debug_mark+2),a  
bb0b 18 03			jr .pastdmark  
bb0d ..			.dmark: db "SP2"  
bb10 f1			.pastdmark: pop af  
bb11			endm  
# End of macro DMARK
bb11						CALLMONITOR 
bb11 cd 7c 93			call break_point_state  
bb14				endm  
# End of macro CALLMONITOR
bb14					endif 
bb14 3e 20				ld a, ' ' 
bb16 c5			.spaces1:	push bc 
bb17 77					ld (hl),a 
bb18 23					inc hl 
bb19 c1					pop bc 
bb1a 10 fa				djnz .spaces1 
bb1c 3e 00				ld a,0 
bb1e 77					ld (hl),a 
bb1f 21 57 e3				ld hl, scratch 
bb22					if DEBUG_FORTH_WORDS 
bb22						DMARK "SP3" 
bb22 f5				push af  
bb23 3a 37 bb			ld a, (.dmark)  
bb26 32 71 ee			ld (debug_mark),a  
bb29 3a 38 bb			ld a, (.dmark+1)  
bb2c 32 72 ee			ld (debug_mark+1),a  
bb2f 3a 39 bb			ld a, (.dmark+2)  
bb32 32 73 ee			ld (debug_mark+2),a  
bb35 18 03			jr .pastdmark  
bb37 ..			.dmark: db "SP3"  
bb3a f1			.pastdmark: pop af  
bb3b			endm  
# End of macro DMARK
bb3b						CALLMONITOR 
bb3b cd 7c 93			call break_point_state  
bb3e				endm  
# End of macro CALLMONITOR
bb3e					endif 
bb3e cd 3f 9b				call forth_apush 
bb41			 
bb41				       NEXTW 
bb41 c3 3f 9d			jp macro_next 
bb44				endm 
# End of macro NEXTW
bb44			 
bb44			 
bb44			 
bb44			.SCROLL: 
bb44				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bb44 53				db WORD_SYS_CORE+63             
bb45 71 bb			dw .SCROLLD            
bb47 07				db 6 + 1 
bb48 .. 00			db "SCROLL",0              
bb4f				endm 
# End of macro CWHEAD
bb4f			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bb4f					if DEBUG_FORTH_WORDS_KEY 
bb4f						DMARK "SCR" 
bb4f f5				push af  
bb50 3a 64 bb			ld a, (.dmark)  
bb53 32 71 ee			ld (debug_mark),a  
bb56 3a 65 bb			ld a, (.dmark+1)  
bb59 32 72 ee			ld (debug_mark+1),a  
bb5c 3a 66 bb			ld a, (.dmark+2)  
bb5f 32 73 ee			ld (debug_mark+2),a  
bb62 18 03			jr .pastdmark  
bb64 ..			.dmark: db "SCR"  
bb67 f1			.pastdmark: pop af  
bb68			endm  
# End of macro DMARK
bb68						CALLMONITOR 
bb68 cd 7c 93			call break_point_state  
bb6b				endm  
# End of macro CALLMONITOR
bb6b					endif 
bb6b			 
bb6b cd 10 89			call scroll_up 
bb6e			;	call update_display 
bb6e			 
bb6e					NEXTW 
bb6e c3 3f 9d			jp macro_next 
bb71				endm 
# End of macro NEXTW
bb71			 
bb71			 
bb71			 
bb71			;		; get dir 
bb71			; 
bb71			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb71			; 
bb71			;		push hl 
bb71			; 
bb71			;		; destroy value TOS 
bb71			; 
bb71			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb71			; 
bb71			;		; get count 
bb71			; 
bb71			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb71			; 
bb71			;		push hl 
bb71			; 
bb71			;		; destroy value TOS 
bb71			; 
bb71			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb71			; 
bb71			;		; one value on hl get other one back 
bb71			; 
bb71			;		pop bc    ; count 
bb71			; 
bb71			;		pop de   ; dir 
bb71			; 
bb71			; 
bb71			;		ld b, c 
bb71			; 
bb71			;.scrolldir:     push bc 
bb71			;		push de 
bb71			; 
bb71			;		ld a, 0 
bb71			;		cp e 
bb71			;		jr z, .scrollup  
bb71			;		call scroll_down 
bb71			;		jr .scrollnext 
bb71			;.scrollup:	call scroll_up 
bb71			; 
bb71			;		 
bb71			;.scrollnext: 
bb71			;		pop de 
bb71			;		pop bc 
bb71			;		djnz .scrolldir 
bb71			; 
bb71			; 
bb71			; 
bb71			; 
bb71			; 
bb71			;		NEXTW 
bb71			 
bb71			.SCROLLD: 
bb71				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bb71 53				db WORD_SYS_CORE+63             
bb72 9f bb			dw .ATQ            
bb74 08				db 7 + 1 
bb75 .. 00			db "SCROLLD",0              
bb7d				endm 
# End of macro CWHEAD
bb7d			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bb7d					if DEBUG_FORTH_WORDS_KEY 
bb7d						DMARK "SCD" 
bb7d f5				push af  
bb7e 3a 92 bb			ld a, (.dmark)  
bb81 32 71 ee			ld (debug_mark),a  
bb84 3a 93 bb			ld a, (.dmark+1)  
bb87 32 72 ee			ld (debug_mark+1),a  
bb8a 3a 94 bb			ld a, (.dmark+2)  
bb8d 32 73 ee			ld (debug_mark+2),a  
bb90 18 03			jr .pastdmark  
bb92 ..			.dmark: db "SCD"  
bb95 f1			.pastdmark: pop af  
bb96			endm  
# End of macro DMARK
bb96						CALLMONITOR 
bb96 cd 7c 93			call break_point_state  
bb99				endm  
# End of macro CALLMONITOR
bb99					endif 
bb99			 
bb99 cd 34 89			call scroll_down 
bb9c			;	call update_display 
bb9c			 
bb9c					NEXTW 
bb9c c3 3f 9d			jp macro_next 
bb9f				endm 
# End of macro NEXTW
bb9f			 
bb9f			 
bb9f			.ATQ: 
bb9f				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bb9f 62				db WORD_SYS_CORE+78             
bba0 fd bb			dw .AUTODSP            
bba2 04				db 3 + 1 
bba3 .. 00			db "AT@",0              
bba7				endm 
# End of macro CWHEAD
bba7			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bba7					if DEBUG_FORTH_WORDS_KEY 
bba7						DMARK "ATA" 
bba7 f5				push af  
bba8 3a bc bb			ld a, (.dmark)  
bbab 32 71 ee			ld (debug_mark),a  
bbae 3a bd bb			ld a, (.dmark+1)  
bbb1 32 72 ee			ld (debug_mark+1),a  
bbb4 3a be bb			ld a, (.dmark+2)  
bbb7 32 73 ee			ld (debug_mark+2),a  
bbba 18 03			jr .pastdmark  
bbbc ..			.dmark: db "ATA"  
bbbf f1			.pastdmark: pop af  
bbc0			endm  
# End of macro DMARK
bbc0						CALLMONITOR 
bbc0 cd 7c 93			call break_point_state  
bbc3				endm  
# End of macro CALLMONITOR
bbc3					endif 
bbc3			 
bbc3			 
bbc3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbc3 cd cd 9b			call macro_dsp_valuehl 
bbc6				endm 
# End of macro FORTH_DSP_VALUEHL
bbc6			 
bbc6					; TODO save cursor row 
bbc6 7d					ld a,l 
bbc7 fe 02				cp 2 
bbc9 20 04				jr nz, .crow3aq 
bbcb 3e 28				ld a, display_row_2 
bbcd 18 12				jr .ccol1aq 
bbcf fe 03		.crow3aq:		cp 3 
bbd1 20 04				jr nz, .crow4aq 
bbd3 3e 50				ld a, display_row_3 
bbd5 18 0a				jr .ccol1aq 
bbd7 fe 04		.crow4aq:		cp 4 
bbd9 20 04				jr nz, .crow1aq 
bbdb 3e 78				ld a, display_row_4 
bbdd 18 02				jr .ccol1aq 
bbdf 3e 00		.crow1aq:		ld a,display_row_1 
bbe1 f5			.ccol1aq:		push af			; got row offset 
bbe2 6f					ld l,a 
bbe3 26 00				ld h,0 
bbe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbe5 cd 85 9c			call macro_forth_dsp_pop 
bbe8				endm 
# End of macro FORTH_DSP_POP
bbe8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbe8 cd cd 9b			call macro_dsp_valuehl 
bbeb				endm 
# End of macro FORTH_DSP_VALUEHL
bbeb					; TODO save cursor col 
bbeb f1					pop af 
bbec 85					add l		; add col offset 
bbed			 
bbed					; add current frame buffer address 
bbed 2a d2 eb				ld hl, (display_fb_active) 
bbf0 cd 7b 8b				call addatohl 
bbf3			 
bbf3			 
bbf3			 
bbf3			 
bbf3					; get char frame buffer location offset in hl 
bbf3			 
bbf3 7e					ld a,(hl) 
bbf4 26 00				ld h, 0 
bbf6 6f					ld l, a 
bbf7			 
bbf7 cd d6 99				call forth_push_numhl 
bbfa			 
bbfa			 
bbfa					NEXTW 
bbfa c3 3f 9d			jp macro_next 
bbfd				endm 
# End of macro NEXTW
bbfd			 
bbfd			.AUTODSP: 
bbfd				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bbfd 63				db WORD_SYS_CORE+79             
bbfe 13 bc			dw .MENU            
bc00 05				db 4 + 1 
bc01 .. 00			db "ADSP",0              
bc06				endm 
# End of macro CWHEAD
bc06			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bc06			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bc06			 
bc06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc06 cd cd 9b			call macro_dsp_valuehl 
bc09				endm 
# End of macro FORTH_DSP_VALUEHL
bc09			 
bc09			;		push hl 
bc09			 
bc09					; destroy value TOS 
bc09			 
bc09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc09 cd 85 9c			call macro_forth_dsp_pop 
bc0c				endm 
# End of macro FORTH_DSP_POP
bc0c			 
bc0c			;		pop hl 
bc0c			 
bc0c 7d					ld a,l 
bc0d 32 1e eb				ld (cli_autodisplay), a 
bc10				       NEXTW 
bc10 c3 3f 9d			jp macro_next 
bc13				endm 
# End of macro NEXTW
bc13			 
bc13			.MENU: 
bc13				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bc13 70				db WORD_SYS_CORE+92             
bc14 bc bc			dw .ENDDISPLAY            
bc16 05				db 4 + 1 
bc17 .. 00			db "MENU",0              
bc1c				endm 
# End of macro CWHEAD
bc1c			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bc1c			 
bc1c			;		; get number of items on the stack 
bc1c			; 
bc1c				 
bc1c					FORTH_DSP_VALUEHL 
bc1c cd cd 9b			call macro_dsp_valuehl 
bc1f				endm 
# End of macro FORTH_DSP_VALUEHL
bc1f				 
bc1f					if DEBUG_FORTH_WORDS_KEY 
bc1f						DMARK "MNU" 
bc1f f5				push af  
bc20 3a 34 bc			ld a, (.dmark)  
bc23 32 71 ee			ld (debug_mark),a  
bc26 3a 35 bc			ld a, (.dmark+1)  
bc29 32 72 ee			ld (debug_mark+1),a  
bc2c 3a 36 bc			ld a, (.dmark+2)  
bc2f 32 73 ee			ld (debug_mark+2),a  
bc32 18 03			jr .pastdmark  
bc34 ..			.dmark: db "MNU"  
bc37 f1			.pastdmark: pop af  
bc38			endm  
# End of macro DMARK
bc38						CALLMONITOR 
bc38 cd 7c 93			call break_point_state  
bc3b				endm  
# End of macro CALLMONITOR
bc3b					endif 
bc3b			 
bc3b 45					ld b, l	 
bc3c 05					dec b 
bc3d			 
bc3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc3d cd 85 9c			call macro_forth_dsp_pop 
bc40				endm 
# End of macro FORTH_DSP_POP
bc40			 
bc40			 
bc40					; go directly through the stack to pluck out the string pointers and build an array 
bc40			 
bc40			;		FORTH_DSP 
bc40			 
bc40					; hl contains top most stack item 
bc40				 
bc40 11 57 e3				ld de, scratch 
bc43			 
bc43			.mbuild: 
bc43			 
bc43					FORTH_DSP_VALUEHL 
bc43 cd cd 9b			call macro_dsp_valuehl 
bc46				endm 
# End of macro FORTH_DSP_VALUEHL
bc46			 
bc46					if DEBUG_FORTH_WORDS 
bc46						DMARK "MN3" 
bc46 f5				push af  
bc47 3a 5b bc			ld a, (.dmark)  
bc4a 32 71 ee			ld (debug_mark),a  
bc4d 3a 5c bc			ld a, (.dmark+1)  
bc50 32 72 ee			ld (debug_mark+1),a  
bc53 3a 5d bc			ld a, (.dmark+2)  
bc56 32 73 ee			ld (debug_mark+2),a  
bc59 18 03			jr .pastdmark  
bc5b ..			.dmark: db "MN3"  
bc5e f1			.pastdmark: pop af  
bc5f			endm  
# End of macro DMARK
bc5f						CALLMONITOR 
bc5f cd 7c 93			call break_point_state  
bc62				endm  
# End of macro CALLMONITOR
bc62					endif 
bc62 eb					ex de, hl 
bc63 73					ld (hl), e 
bc64 23					inc hl 
bc65 72					ld (hl), d 
bc66 23					inc hl 
bc67 eb					ex de, hl 
bc68			 
bc68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc68 cd 85 9c			call macro_forth_dsp_pop 
bc6b				endm 
# End of macro FORTH_DSP_POP
bc6b			 
bc6b 10 d6				djnz .mbuild 
bc6d			 
bc6d					; done add term 
bc6d			 
bc6d eb					ex de, hl 
bc6e 36 00				ld (hl), 0 
bc70 23					inc hl 
bc71 36 00				ld (hl), 0 
bc73			 
bc73				 
bc73					 
bc73 21 57 e3				ld hl, scratch 
bc76			 
bc76					if DEBUG_FORTH_WORDS 
bc76						DMARK "MNx" 
bc76 f5				push af  
bc77 3a 8b bc			ld a, (.dmark)  
bc7a 32 71 ee			ld (debug_mark),a  
bc7d 3a 8c bc			ld a, (.dmark+1)  
bc80 32 72 ee			ld (debug_mark+1),a  
bc83 3a 8d bc			ld a, (.dmark+2)  
bc86 32 73 ee			ld (debug_mark+2),a  
bc89 18 03			jr .pastdmark  
bc8b ..			.dmark: db "MNx"  
bc8e f1			.pastdmark: pop af  
bc8f			endm  
# End of macro DMARK
bc8f						CALLMONITOR 
bc8f cd 7c 93			call break_point_state  
bc92				endm  
# End of macro CALLMONITOR
bc92					endif 
bc92			 
bc92			 
bc92			 
bc92 3e 00				ld a, 0 
bc94 cd 7f 89				call menu 
bc97			 
bc97			 
bc97 6f					ld l, a 
bc98 26 00				ld h, 0 
bc9a			 
bc9a					if DEBUG_FORTH_WORDS 
bc9a						DMARK "MNr" 
bc9a f5				push af  
bc9b 3a af bc			ld a, (.dmark)  
bc9e 32 71 ee			ld (debug_mark),a  
bca1 3a b0 bc			ld a, (.dmark+1)  
bca4 32 72 ee			ld (debug_mark+1),a  
bca7 3a b1 bc			ld a, (.dmark+2)  
bcaa 32 73 ee			ld (debug_mark+2),a  
bcad 18 03			jr .pastdmark  
bcaf ..			.dmark: db "MNr"  
bcb2 f1			.pastdmark: pop af  
bcb3			endm  
# End of macro DMARK
bcb3						CALLMONITOR 
bcb3 cd 7c 93			call break_point_state  
bcb6				endm  
# End of macro CALLMONITOR
bcb6					endif 
bcb6			 
bcb6 cd d6 99				call forth_push_numhl 
bcb9			 
bcb9			 
bcb9			 
bcb9			 
bcb9				       NEXTW 
bcb9 c3 3f 9d			jp macro_next 
bcbc				endm 
# End of macro NEXTW
bcbc			 
bcbc			 
bcbc			.ENDDISPLAY: 
bcbc			 
bcbc			; eof 
# End of file forth_words_display.asm
bcbc			include "forth_words_str.asm" 
bcbc			 
bcbc			; | ## String Words 
bcbc			 
bcbc			.PTR:   
bcbc			 
bcbc				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bcbc 48				db WORD_SYS_CORE+52             
bcbd e9 bc			dw .STYPE            
bcbf 04				db 3 + 1 
bcc0 .. 00			db "PTR",0              
bcc4				endm 
# End of macro CWHEAD
bcc4			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bcc4			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bcc4			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bcc4			 
bcc4					if DEBUG_FORTH_WORDS_KEY 
bcc4						DMARK "PTR" 
bcc4 f5				push af  
bcc5 3a d9 bc			ld a, (.dmark)  
bcc8 32 71 ee			ld (debug_mark),a  
bccb 3a da bc			ld a, (.dmark+1)  
bcce 32 72 ee			ld (debug_mark+1),a  
bcd1 3a db bc			ld a, (.dmark+2)  
bcd4 32 73 ee			ld (debug_mark+2),a  
bcd7 18 03			jr .pastdmark  
bcd9 ..			.dmark: db "PTR"  
bcdc f1			.pastdmark: pop af  
bcdd			endm  
# End of macro DMARK
bcdd						CALLMONITOR 
bcdd cd 7c 93			call break_point_state  
bce0				endm  
# End of macro CALLMONITOR
bce0					endif 
bce0					FORTH_DSP_VALUEHL 
bce0 cd cd 9b			call macro_dsp_valuehl 
bce3				endm 
# End of macro FORTH_DSP_VALUEHL
bce3 cd d6 99				call forth_push_numhl 
bce6			 
bce6			 
bce6					NEXTW 
bce6 c3 3f 9d			jp macro_next 
bce9				endm 
# End of macro NEXTW
bce9			.STYPE: 
bce9				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bce9 48				db WORD_SYS_CORE+52             
bcea 38 bd			dw .UPPER            
bcec 06				db 5 + 1 
bced .. 00			db "STYPE",0              
bcf3				endm 
# End of macro CWHEAD
bcf3			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bcf3					if DEBUG_FORTH_WORDS_KEY 
bcf3						DMARK "STY" 
bcf3 f5				push af  
bcf4 3a 08 bd			ld a, (.dmark)  
bcf7 32 71 ee			ld (debug_mark),a  
bcfa 3a 09 bd			ld a, (.dmark+1)  
bcfd 32 72 ee			ld (debug_mark+1),a  
bd00 3a 0a bd			ld a, (.dmark+2)  
bd03 32 73 ee			ld (debug_mark+2),a  
bd06 18 03			jr .pastdmark  
bd08 ..			.dmark: db "STY"  
bd0b f1			.pastdmark: pop af  
bd0c			endm  
# End of macro DMARK
bd0c						CALLMONITOR 
bd0c cd 7c 93			call break_point_state  
bd0f				endm  
# End of macro CALLMONITOR
bd0f					endif 
bd0f					FORTH_DSP 
bd0f cd 93 9b			call macro_forth_dsp 
bd12				endm 
# End of macro FORTH_DSP
bd12					;v5 FORTH_DSP_VALUE 
bd12			 
bd12 7e					ld a, (hl) 
bd13			 
bd13 f5					push af 
bd14			 
bd14			; Dont destroy TOS		FORTH_DSP_POP 
bd14			 
bd14 f1					pop af 
bd15			 
bd15 fe 01				cp DS_TYPE_STR 
bd17 28 09				jr z, .typestr 
bd19			 
bd19 fe 02				cp DS_TYPE_INUM 
bd1b 28 0a				jr z, .typeinum 
bd1d			 
bd1d 21 36 bd				ld hl, .tna 
bd20 18 0a				jr .tpush 
bd22			 
bd22 21 32 bd		.typestr:	ld hl, .tstr 
bd25 18 05				jr .tpush 
bd27 21 34 bd		.typeinum:	ld hl, .tinum 
bd2a 18 00				jr .tpush 
bd2c			 
bd2c			.tpush: 
bd2c			 
bd2c cd 44 9a				call forth_push_str 
bd2f			 
bd2f					NEXTW 
bd2f c3 3f 9d			jp macro_next 
bd32				endm 
# End of macro NEXTW
bd32 .. 00		.tstr:	db "s",0 
bd34 .. 00		.tinum:  db "i",0 
bd36 .. 00		.tna:   db "?", 0 
bd38			 
bd38			 
bd38			.UPPER: 
bd38				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bd38 48				db WORD_SYS_CORE+52             
bd39 73 bd			dw .LOWER            
bd3b 06				db 5 + 1 
bd3c .. 00			db "UPPER",0              
bd42				endm 
# End of macro CWHEAD
bd42			; | UPPER ( s -- s ) Upper case string s  | DONE 
bd42					if DEBUG_FORTH_WORDS_KEY 
bd42						DMARK "UPR" 
bd42 f5				push af  
bd43 3a 57 bd			ld a, (.dmark)  
bd46 32 71 ee			ld (debug_mark),a  
bd49 3a 58 bd			ld a, (.dmark+1)  
bd4c 32 72 ee			ld (debug_mark+1),a  
bd4f 3a 59 bd			ld a, (.dmark+2)  
bd52 32 73 ee			ld (debug_mark+2),a  
bd55 18 03			jr .pastdmark  
bd57 ..			.dmark: db "UPR"  
bd5a f1			.pastdmark: pop af  
bd5b			endm  
# End of macro DMARK
bd5b						CALLMONITOR 
bd5b cd 7c 93			call break_point_state  
bd5e				endm  
# End of macro CALLMONITOR
bd5e					endif 
bd5e			 
bd5e					FORTH_DSP 
bd5e cd 93 9b			call macro_forth_dsp 
bd61				endm 
# End of macro FORTH_DSP
bd61					 
bd61			; TODO check is string type 
bd61			 
bd61					FORTH_DSP_VALUEHL 
bd61 cd cd 9b			call macro_dsp_valuehl 
bd64				endm 
# End of macro FORTH_DSP_VALUEHL
bd64			; get pointer to string in hl 
bd64			 
bd64 7e			.toup:		ld a, (hl) 
bd65 fe 00				cp 0 
bd67 28 07				jr z, .toupdone 
bd69			 
bd69 cd e8 8e				call to_upper 
bd6c			 
bd6c 77					ld (hl), a 
bd6d 23					inc hl 
bd6e 18 f4				jr .toup 
bd70			 
bd70					 
bd70			 
bd70			 
bd70			; for each char convert to upper 
bd70					 
bd70			.toupdone: 
bd70			 
bd70			 
bd70					NEXTW 
bd70 c3 3f 9d			jp macro_next 
bd73				endm 
# End of macro NEXTW
bd73			.LOWER: 
bd73				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bd73 48				db WORD_SYS_CORE+52             
bd74 ae bd			dw .TCASE            
bd76 06				db 5 + 1 
bd77 .. 00			db "LOWER",0              
bd7d				endm 
# End of macro CWHEAD
bd7d			; | LOWER ( s -- s ) Lower case string s  | DONE 
bd7d					if DEBUG_FORTH_WORDS_KEY 
bd7d						DMARK "LWR" 
bd7d f5				push af  
bd7e 3a 92 bd			ld a, (.dmark)  
bd81 32 71 ee			ld (debug_mark),a  
bd84 3a 93 bd			ld a, (.dmark+1)  
bd87 32 72 ee			ld (debug_mark+1),a  
bd8a 3a 94 bd			ld a, (.dmark+2)  
bd8d 32 73 ee			ld (debug_mark+2),a  
bd90 18 03			jr .pastdmark  
bd92 ..			.dmark: db "LWR"  
bd95 f1			.pastdmark: pop af  
bd96			endm  
# End of macro DMARK
bd96						CALLMONITOR 
bd96 cd 7c 93			call break_point_state  
bd99				endm  
# End of macro CALLMONITOR
bd99					endif 
bd99			 
bd99					FORTH_DSP 
bd99 cd 93 9b			call macro_forth_dsp 
bd9c				endm 
# End of macro FORTH_DSP
bd9c					 
bd9c			; TODO check is string type 
bd9c			 
bd9c					FORTH_DSP_VALUEHL 
bd9c cd cd 9b			call macro_dsp_valuehl 
bd9f				endm 
# End of macro FORTH_DSP_VALUEHL
bd9f			; get pointer to string in hl 
bd9f			 
bd9f 7e			.tolow:		ld a, (hl) 
bda0 fe 00				cp 0 
bda2 28 07				jr z, .tolowdone 
bda4			 
bda4 cd f1 8e				call to_lower 
bda7			 
bda7 77					ld (hl), a 
bda8 23					inc hl 
bda9 18 f4				jr .tolow 
bdab			 
bdab					 
bdab			 
bdab			 
bdab			; for each char convert to low 
bdab					 
bdab			.tolowdone: 
bdab					NEXTW 
bdab c3 3f 9d			jp macro_next 
bdae				endm 
# End of macro NEXTW
bdae			.TCASE: 
bdae				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bdae 48				db WORD_SYS_CORE+52             
bdaf e4 be			dw .SUBSTR            
bdb1 06				db 5 + 1 
bdb2 .. 00			db "TCASE",0              
bdb8				endm 
# End of macro CWHEAD
bdb8			; | TCASE ( s -- s ) Title case string s  | DONE 
bdb8					if DEBUG_FORTH_WORDS_KEY 
bdb8						DMARK "TCS" 
bdb8 f5				push af  
bdb9 3a cd bd			ld a, (.dmark)  
bdbc 32 71 ee			ld (debug_mark),a  
bdbf 3a ce bd			ld a, (.dmark+1)  
bdc2 32 72 ee			ld (debug_mark+1),a  
bdc5 3a cf bd			ld a, (.dmark+2)  
bdc8 32 73 ee			ld (debug_mark+2),a  
bdcb 18 03			jr .pastdmark  
bdcd ..			.dmark: db "TCS"  
bdd0 f1			.pastdmark: pop af  
bdd1			endm  
# End of macro DMARK
bdd1						CALLMONITOR 
bdd1 cd 7c 93			call break_point_state  
bdd4				endm  
# End of macro CALLMONITOR
bdd4					endif 
bdd4			 
bdd4					FORTH_DSP 
bdd4 cd 93 9b			call macro_forth_dsp 
bdd7				endm 
# End of macro FORTH_DSP
bdd7					 
bdd7			; TODO check is string type 
bdd7			 
bdd7					FORTH_DSP_VALUEHL 
bdd7 cd cd 9b			call macro_dsp_valuehl 
bdda				endm 
# End of macro FORTH_DSP_VALUEHL
bdda			; get pointer to string in hl 
bdda			 
bdda					if DEBUG_FORTH_WORDS 
bdda						DMARK "TC1" 
bdda f5				push af  
bddb 3a ef bd			ld a, (.dmark)  
bdde 32 71 ee			ld (debug_mark),a  
bde1 3a f0 bd			ld a, (.dmark+1)  
bde4 32 72 ee			ld (debug_mark+1),a  
bde7 3a f1 bd			ld a, (.dmark+2)  
bdea 32 73 ee			ld (debug_mark+2),a  
bded 18 03			jr .pastdmark  
bdef ..			.dmark: db "TC1"  
bdf2 f1			.pastdmark: pop af  
bdf3			endm  
# End of macro DMARK
bdf3						CALLMONITOR 
bdf3 cd 7c 93			call break_point_state  
bdf6				endm  
# End of macro CALLMONITOR
bdf6					endif 
bdf6			 
bdf6					; first time in turn to upper case first char 
bdf6			 
bdf6 7e					ld a, (hl) 
bdf7 c3 81 be				jp .totsiptou 
bdfa			 
bdfa			 
bdfa 7e			.tot:		ld a, (hl) 
bdfb fe 00				cp 0 
bdfd ca c5 be				jp z, .totdone 
be00			 
be00					if DEBUG_FORTH_WORDS 
be00						DMARK "TC2" 
be00 f5				push af  
be01 3a 15 be			ld a, (.dmark)  
be04 32 71 ee			ld (debug_mark),a  
be07 3a 16 be			ld a, (.dmark+1)  
be0a 32 72 ee			ld (debug_mark+1),a  
be0d 3a 17 be			ld a, (.dmark+2)  
be10 32 73 ee			ld (debug_mark+2),a  
be13 18 03			jr .pastdmark  
be15 ..			.dmark: db "TC2"  
be18 f1			.pastdmark: pop af  
be19			endm  
# End of macro DMARK
be19						CALLMONITOR 
be19 cd 7c 93			call break_point_state  
be1c				endm  
# End of macro CALLMONITOR
be1c					endif 
be1c					; check to see if current char is a space 
be1c			 
be1c fe 20				cp ' ' 
be1e 28 21				jr z, .totsp 
be20 cd f1 8e				call to_lower 
be23					if DEBUG_FORTH_WORDS 
be23						DMARK "TC3" 
be23 f5				push af  
be24 3a 38 be			ld a, (.dmark)  
be27 32 71 ee			ld (debug_mark),a  
be2a 3a 39 be			ld a, (.dmark+1)  
be2d 32 72 ee			ld (debug_mark+1),a  
be30 3a 3a be			ld a, (.dmark+2)  
be33 32 73 ee			ld (debug_mark+2),a  
be36 18 03			jr .pastdmark  
be38 ..			.dmark: db "TC3"  
be3b f1			.pastdmark: pop af  
be3c			endm  
# End of macro DMARK
be3c						CALLMONITOR 
be3c cd 7c 93			call break_point_state  
be3f				endm  
# End of macro CALLMONITOR
be3f					endif 
be3f 18 63				jr .totnxt 
be41			 
be41			.totsp:         ; on a space, find next char which should be upper 
be41			 
be41					if DEBUG_FORTH_WORDS 
be41						DMARK "TC4" 
be41 f5				push af  
be42 3a 56 be			ld a, (.dmark)  
be45 32 71 ee			ld (debug_mark),a  
be48 3a 57 be			ld a, (.dmark+1)  
be4b 32 72 ee			ld (debug_mark+1),a  
be4e 3a 58 be			ld a, (.dmark+2)  
be51 32 73 ee			ld (debug_mark+2),a  
be54 18 03			jr .pastdmark  
be56 ..			.dmark: db "TC4"  
be59 f1			.pastdmark: pop af  
be5a			endm  
# End of macro DMARK
be5a						CALLMONITOR 
be5a cd 7c 93			call break_point_state  
be5d				endm  
# End of macro CALLMONITOR
be5d					endif 
be5d					;; 
be5d			 
be5d fe 20				cp ' ' 
be5f 20 20				jr nz, .totsiptou 
be61 23					inc hl 
be62 7e					ld a, (hl) 
be63					if DEBUG_FORTH_WORDS 
be63						DMARK "TC5" 
be63 f5				push af  
be64 3a 78 be			ld a, (.dmark)  
be67 32 71 ee			ld (debug_mark),a  
be6a 3a 79 be			ld a, (.dmark+1)  
be6d 32 72 ee			ld (debug_mark+1),a  
be70 3a 7a be			ld a, (.dmark+2)  
be73 32 73 ee			ld (debug_mark+2),a  
be76 18 03			jr .pastdmark  
be78 ..			.dmark: db "TC5"  
be7b f1			.pastdmark: pop af  
be7c			endm  
# End of macro DMARK
be7c						CALLMONITOR 
be7c cd 7c 93			call break_point_state  
be7f				endm  
# End of macro CALLMONITOR
be7f					endif 
be7f 18 c0				jr .totsp 
be81 fe 00		.totsiptou:    cp 0 
be83 28 40				jr z, .totdone 
be85					; not space and not zero term so upper case it 
be85 cd e8 8e				call to_upper 
be88			 
be88					if DEBUG_FORTH_WORDS 
be88						DMARK "TC6" 
be88 f5				push af  
be89 3a 9d be			ld a, (.dmark)  
be8c 32 71 ee			ld (debug_mark),a  
be8f 3a 9e be			ld a, (.dmark+1)  
be92 32 72 ee			ld (debug_mark+1),a  
be95 3a 9f be			ld a, (.dmark+2)  
be98 32 73 ee			ld (debug_mark+2),a  
be9b 18 03			jr .pastdmark  
be9d ..			.dmark: db "TC6"  
bea0 f1			.pastdmark: pop af  
bea1			endm  
# End of macro DMARK
bea1						CALLMONITOR 
bea1 cd 7c 93			call break_point_state  
bea4				endm  
# End of macro CALLMONITOR
bea4					endif 
bea4			 
bea4			 
bea4			.totnxt: 
bea4			 
bea4 77					ld (hl), a 
bea5 23					inc hl 
bea6					if DEBUG_FORTH_WORDS 
bea6						DMARK "TC7" 
bea6 f5				push af  
bea7 3a bb be			ld a, (.dmark)  
beaa 32 71 ee			ld (debug_mark),a  
bead 3a bc be			ld a, (.dmark+1)  
beb0 32 72 ee			ld (debug_mark+1),a  
beb3 3a bd be			ld a, (.dmark+2)  
beb6 32 73 ee			ld (debug_mark+2),a  
beb9 18 03			jr .pastdmark  
bebb ..			.dmark: db "TC7"  
bebe f1			.pastdmark: pop af  
bebf			endm  
# End of macro DMARK
bebf						CALLMONITOR 
bebf cd 7c 93			call break_point_state  
bec2				endm  
# End of macro CALLMONITOR
bec2					endif 
bec2 c3 fa bd				jp .tot 
bec5			 
bec5					 
bec5			 
bec5			 
bec5			; for each char convert to low 
bec5					 
bec5			.totdone: 
bec5					if DEBUG_FORTH_WORDS 
bec5						DMARK "TCd" 
bec5 f5				push af  
bec6 3a da be			ld a, (.dmark)  
bec9 32 71 ee			ld (debug_mark),a  
becc 3a db be			ld a, (.dmark+1)  
becf 32 72 ee			ld (debug_mark+1),a  
bed2 3a dc be			ld a, (.dmark+2)  
bed5 32 73 ee			ld (debug_mark+2),a  
bed8 18 03			jr .pastdmark  
beda ..			.dmark: db "TCd"  
bedd f1			.pastdmark: pop af  
bede			endm  
# End of macro DMARK
bede						CALLMONITOR 
bede cd 7c 93			call break_point_state  
bee1				endm  
# End of macro CALLMONITOR
bee1					endif 
bee1					NEXTW 
bee1 c3 3f 9d			jp macro_next 
bee4				endm 
# End of macro NEXTW
bee4			 
bee4			.SUBSTR: 
bee4				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bee4 48				db WORD_SYS_CORE+52             
bee5 42 bf			dw .LEFT            
bee7 07				db 6 + 1 
bee8 .. 00			db "SUBSTR",0              
beef				endm 
# End of macro CWHEAD
beef			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
beef			 
beef					if DEBUG_FORTH_WORDS_KEY 
beef						DMARK "SST" 
beef f5				push af  
bef0 3a 04 bf			ld a, (.dmark)  
bef3 32 71 ee			ld (debug_mark),a  
bef6 3a 05 bf			ld a, (.dmark+1)  
bef9 32 72 ee			ld (debug_mark+1),a  
befc 3a 06 bf			ld a, (.dmark+2)  
beff 32 73 ee			ld (debug_mark+2),a  
bf02 18 03			jr .pastdmark  
bf04 ..			.dmark: db "SST"  
bf07 f1			.pastdmark: pop af  
bf08			endm  
# End of macro DMARK
bf08						CALLMONITOR 
bf08 cd 7c 93			call break_point_state  
bf0b				endm  
# End of macro CALLMONITOR
bf0b					endif 
bf0b			; TODO check string type 
bf0b					FORTH_DSP_VALUEHL 
bf0b cd cd 9b			call macro_dsp_valuehl 
bf0e				endm 
# End of macro FORTH_DSP_VALUEHL
bf0e			 
bf0e e5					push hl      ; string length 
bf0f			 
bf0f					FORTH_DSP_POP 
bf0f cd 85 9c			call macro_forth_dsp_pop 
bf12				endm 
# End of macro FORTH_DSP_POP
bf12			 
bf12					FORTH_DSP_VALUEHL 
bf12 cd cd 9b			call macro_dsp_valuehl 
bf15				endm 
# End of macro FORTH_DSP_VALUEHL
bf15			 
bf15 e5					push hl     ; start char 
bf16			 
bf16					FORTH_DSP_POP 
bf16 cd 85 9c			call macro_forth_dsp_pop 
bf19				endm 
# End of macro FORTH_DSP_POP
bf19			 
bf19			 
bf19					FORTH_DSP_VALUE 
bf19 cd b6 9b			call macro_forth_dsp_value 
bf1c				endm 
# End of macro FORTH_DSP_VALUE
bf1c			 
bf1c d1					pop de    ; get start post offset 
bf1d			 
bf1d 19					add hl, de    ; starting offset 
bf1e			 
bf1e c1					pop bc 
bf1f c5					push bc      ; grab size of string 
bf20			 
bf20 e5					push hl    ; save string start  
bf21			 
bf21 26 00				ld h, 0 
bf23 69					ld l, c 
bf24 23					inc hl 
bf25 23					inc hl 
bf26			 
bf26 cd 42 90				call malloc 
bf29				if DEBUG_FORTH_MALLOC_GUARD 
bf29 cc 71 c5				call z,malloc_error 
bf2c				endif 
bf2c			 
bf2c eb					ex de, hl      ; save malloc area for string copy 
bf2d e1					pop hl    ; get back source 
bf2e c1					pop bc    ; get length of string back 
bf2f			 
bf2f d5					push de    ; save malloc area for after we push 
bf30 ed b0				ldir     ; copy substr 
bf32			 
bf32			 
bf32 eb					ex de, hl 
bf33 3e 00				ld a, 0 
bf35 77					ld (hl), a   ; term substr 
bf36			 
bf36					 
bf36 e1					pop hl    ; get malloc so we can push it 
bf37 e5					push hl   ; save so we can free it afterwards 
bf38			 
bf38 cd 44 9a				call forth_push_str 
bf3b			 
bf3b e1					pop hl 
bf3c cd 0c 91				call free 
bf3f			 
bf3f					 
bf3f					 
bf3f			 
bf3f			 
bf3f					NEXTW 
bf3f c3 3f 9d			jp macro_next 
bf42				endm 
# End of macro NEXTW
bf42			 
bf42			.LEFT: 
bf42				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bf42 48				db WORD_SYS_CORE+52             
bf43 6a bf			dw .RIGHT            
bf45 05				db 4 + 1 
bf46 .. 00			db "LEFT",0              
bf4b				endm 
# End of macro CWHEAD
bf4b			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bf4b					if DEBUG_FORTH_WORDS_KEY 
bf4b						DMARK "LEF" 
bf4b f5				push af  
bf4c 3a 60 bf			ld a, (.dmark)  
bf4f 32 71 ee			ld (debug_mark),a  
bf52 3a 61 bf			ld a, (.dmark+1)  
bf55 32 72 ee			ld (debug_mark+1),a  
bf58 3a 62 bf			ld a, (.dmark+2)  
bf5b 32 73 ee			ld (debug_mark+2),a  
bf5e 18 03			jr .pastdmark  
bf60 ..			.dmark: db "LEF"  
bf63 f1			.pastdmark: pop af  
bf64			endm  
# End of macro DMARK
bf64						CALLMONITOR 
bf64 cd 7c 93			call break_point_state  
bf67				endm  
# End of macro CALLMONITOR
bf67					endif 
bf67			 
bf67					NEXTW 
bf67 c3 3f 9d			jp macro_next 
bf6a				endm 
# End of macro NEXTW
bf6a			.RIGHT: 
bf6a				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bf6a 48				db WORD_SYS_CORE+52             
bf6b 93 bf			dw .STR2NUM            
bf6d 06				db 5 + 1 
bf6e .. 00			db "RIGHT",0              
bf74				endm 
# End of macro CWHEAD
bf74			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bf74					if DEBUG_FORTH_WORDS_KEY 
bf74						DMARK "RIG" 
bf74 f5				push af  
bf75 3a 89 bf			ld a, (.dmark)  
bf78 32 71 ee			ld (debug_mark),a  
bf7b 3a 8a bf			ld a, (.dmark+1)  
bf7e 32 72 ee			ld (debug_mark+1),a  
bf81 3a 8b bf			ld a, (.dmark+2)  
bf84 32 73 ee			ld (debug_mark+2),a  
bf87 18 03			jr .pastdmark  
bf89 ..			.dmark: db "RIG"  
bf8c f1			.pastdmark: pop af  
bf8d			endm  
# End of macro DMARK
bf8d						CALLMONITOR 
bf8d cd 7c 93			call break_point_state  
bf90				endm  
# End of macro CALLMONITOR
bf90					endif 
bf90			 
bf90					NEXTW 
bf90 c3 3f 9d			jp macro_next 
bf93				endm 
# End of macro NEXTW
bf93			 
bf93			 
bf93			.STR2NUM: 
bf93				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bf93 48				db WORD_SYS_CORE+52             
bf94 1f c0			dw .NUM2STR            
bf96 08				db 7 + 1 
bf97 .. 00			db "STR2NUM",0              
bf9f				endm 
# End of macro CWHEAD
bf9f			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bf9f			 
bf9f			 
bf9f			; TODO STR type check to do 
bf9f					if DEBUG_FORTH_WORDS_KEY 
bf9f						DMARK "S2N" 
bf9f f5				push af  
bfa0 3a b4 bf			ld a, (.dmark)  
bfa3 32 71 ee			ld (debug_mark),a  
bfa6 3a b5 bf			ld a, (.dmark+1)  
bfa9 32 72 ee			ld (debug_mark+1),a  
bfac 3a b6 bf			ld a, (.dmark+2)  
bfaf 32 73 ee			ld (debug_mark+2),a  
bfb2 18 03			jr .pastdmark  
bfb4 ..			.dmark: db "S2N"  
bfb7 f1			.pastdmark: pop af  
bfb8			endm  
# End of macro DMARK
bfb8						CALLMONITOR 
bfb8 cd 7c 93			call break_point_state  
bfbb				endm  
# End of macro CALLMONITOR
bfbb					endif 
bfbb			 
bfbb					;FORTH_DSP 
bfbb					FORTH_DSP_VALUE 
bfbb cd b6 9b			call macro_forth_dsp_value 
bfbe				endm 
# End of macro FORTH_DSP_VALUE
bfbe					;inc hl 
bfbe			 
bfbe eb					ex de, hl 
bfbf					if DEBUG_FORTH_WORDS 
bfbf						DMARK "S2a" 
bfbf f5				push af  
bfc0 3a d4 bf			ld a, (.dmark)  
bfc3 32 71 ee			ld (debug_mark),a  
bfc6 3a d5 bf			ld a, (.dmark+1)  
bfc9 32 72 ee			ld (debug_mark+1),a  
bfcc 3a d6 bf			ld a, (.dmark+2)  
bfcf 32 73 ee			ld (debug_mark+2),a  
bfd2 18 03			jr .pastdmark  
bfd4 ..			.dmark: db "S2a"  
bfd7 f1			.pastdmark: pop af  
bfd8			endm  
# End of macro DMARK
bfd8						CALLMONITOR 
bfd8 cd 7c 93			call break_point_state  
bfdb				endm  
# End of macro CALLMONITOR
bfdb					endif 
bfdb cd 70 8f				call string_to_uint16 
bfde			 
bfde					if DEBUG_FORTH_WORDS 
bfde						DMARK "S2b" 
bfde f5				push af  
bfdf 3a f3 bf			ld a, (.dmark)  
bfe2 32 71 ee			ld (debug_mark),a  
bfe5 3a f4 bf			ld a, (.dmark+1)  
bfe8 32 72 ee			ld (debug_mark+1),a  
bfeb 3a f5 bf			ld a, (.dmark+2)  
bfee 32 73 ee			ld (debug_mark+2),a  
bff1 18 03			jr .pastdmark  
bff3 ..			.dmark: db "S2b"  
bff6 f1			.pastdmark: pop af  
bff7			endm  
# End of macro DMARK
bff7						CALLMONITOR 
bff7 cd 7c 93			call break_point_state  
bffa				endm  
# End of macro CALLMONITOR
bffa					endif 
bffa			;		push hl 
bffa					FORTH_DSP_POP 
bffa cd 85 9c			call macro_forth_dsp_pop 
bffd				endm 
# End of macro FORTH_DSP_POP
bffd			;		pop hl 
bffd					 
bffd					if DEBUG_FORTH_WORDS 
bffd						DMARK "S2b" 
bffd f5				push af  
bffe 3a 12 c0			ld a, (.dmark)  
c001 32 71 ee			ld (debug_mark),a  
c004 3a 13 c0			ld a, (.dmark+1)  
c007 32 72 ee			ld (debug_mark+1),a  
c00a 3a 14 c0			ld a, (.dmark+2)  
c00d 32 73 ee			ld (debug_mark+2),a  
c010 18 03			jr .pastdmark  
c012 ..			.dmark: db "S2b"  
c015 f1			.pastdmark: pop af  
c016			endm  
# End of macro DMARK
c016						CALLMONITOR 
c016 cd 7c 93			call break_point_state  
c019				endm  
# End of macro CALLMONITOR
c019					endif 
c019 cd d6 99				call forth_push_numhl	 
c01c			 
c01c				 
c01c				       NEXTW 
c01c c3 3f 9d			jp macro_next 
c01f				endm 
# End of macro NEXTW
c01f			.NUM2STR: 
c01f				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c01f 48				db WORD_SYS_CORE+52             
c020 2e c0			dw .CONCAT            
c022 08				db 7 + 1 
c023 .. 00			db "NUM2STR",0              
c02b				endm 
# End of macro CWHEAD
c02b			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c02b			 
c02b			;		; malloc a string to target 
c02b			;		ld hl, 10     ; TODO max string size should be fine 
c02b			;		call malloc 
c02b			;		push hl    ; save malloc location 
c02b			; 
c02b			; 
c02b			;; TODO check int type 
c02b			;		FORTH_DSP_VALUEHL 
c02b			;		ld a, l 
c02b			;		call DispAToASCII   
c02b			;;TODO need to chage above call to dump into string 
c02b			; 
c02b			; 
c02b			 
c02b				       NEXTW 
c02b c3 3f 9d			jp macro_next 
c02e				endm 
# End of macro NEXTW
c02e			 
c02e			.CONCAT: 
c02e				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c02e 48				db WORD_SYS_CORE+52             
c02f e1 c0			dw .FIND            
c031 07				db 6 + 1 
c032 .. 00			db "CONCAT",0              
c039				endm 
# End of macro CWHEAD
c039			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c039			 
c039			; TODO check string type 
c039			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c039			 
c039					if DEBUG_FORTH_WORDS_KEY 
c039						DMARK "CON" 
c039 f5				push af  
c03a 3a 4e c0			ld a, (.dmark)  
c03d 32 71 ee			ld (debug_mark),a  
c040 3a 4f c0			ld a, (.dmark+1)  
c043 32 72 ee			ld (debug_mark+1),a  
c046 3a 50 c0			ld a, (.dmark+2)  
c049 32 73 ee			ld (debug_mark+2),a  
c04c 18 03			jr .pastdmark  
c04e ..			.dmark: db "CON"  
c051 f1			.pastdmark: pop af  
c052			endm  
# End of macro DMARK
c052						CALLMONITOR 
c052 cd 7c 93			call break_point_state  
c055				endm  
# End of macro CALLMONITOR
c055					endif 
c055			 
c055			 
c055					FORTH_DSP_VALUE 
c055 cd b6 9b			call macro_forth_dsp_value 
c058				endm 
# End of macro FORTH_DSP_VALUE
c058 e5					push hl   ; s2 
c059			 
c059					FORTH_DSP_POP 
c059 cd 85 9c			call macro_forth_dsp_pop 
c05c				endm 
# End of macro FORTH_DSP_POP
c05c			 
c05c					FORTH_DSP_VALUE 
c05c cd b6 9b			call macro_forth_dsp_value 
c05f				endm 
# End of macro FORTH_DSP_VALUE
c05f			 
c05f e5					push hl   ; s1 
c060			 
c060					FORTH_DSP_POP 
c060 cd 85 9c			call macro_forth_dsp_pop 
c063				endm 
# End of macro FORTH_DSP_POP
c063					 
c063			 
c063					; copy s1 
c063			 
c063				 
c063					; save ptr 
c063 e1					pop hl  
c064 e5					push hl 
c065 3e 00				ld a, 0 
c067 cd e4 8f				call strlent 
c06a					;inc hl    ; zer0 
c06a 06 00				ld b, 0 
c06c 4d					ld c, l 
c06d e1					pop hl		 
c06e 11 57 e3				ld de, scratch	 
c071					if DEBUG_FORTH_WORDS 
c071						DMARK "CO1" 
c071 f5				push af  
c072 3a 86 c0			ld a, (.dmark)  
c075 32 71 ee			ld (debug_mark),a  
c078 3a 87 c0			ld a, (.dmark+1)  
c07b 32 72 ee			ld (debug_mark+1),a  
c07e 3a 88 c0			ld a, (.dmark+2)  
c081 32 73 ee			ld (debug_mark+2),a  
c084 18 03			jr .pastdmark  
c086 ..			.dmark: db "CO1"  
c089 f1			.pastdmark: pop af  
c08a			endm  
# End of macro DMARK
c08a						CALLMONITOR 
c08a cd 7c 93			call break_point_state  
c08d				endm  
# End of macro CALLMONITOR
c08d					endif 
c08d ed b0				ldir 
c08f			 
c08f e1					pop hl 
c090 e5					push hl 
c091 d5					push de 
c092			 
c092			 
c092 3e 00				ld a, 0 
c094 cd e4 8f				call strlent 
c097 23					inc hl    ; zer0 
c098 23					inc hl 
c099 06 00				ld b, 0 
c09b 4d					ld c, l 
c09c d1					pop de 
c09d e1					pop hl		 
c09e					if DEBUG_FORTH_WORDS 
c09e						DMARK "CO2" 
c09e f5				push af  
c09f 3a b3 c0			ld a, (.dmark)  
c0a2 32 71 ee			ld (debug_mark),a  
c0a5 3a b4 c0			ld a, (.dmark+1)  
c0a8 32 72 ee			ld (debug_mark+1),a  
c0ab 3a b5 c0			ld a, (.dmark+2)  
c0ae 32 73 ee			ld (debug_mark+2),a  
c0b1 18 03			jr .pastdmark  
c0b3 ..			.dmark: db "CO2"  
c0b6 f1			.pastdmark: pop af  
c0b7			endm  
# End of macro DMARK
c0b7						CALLMONITOR 
c0b7 cd 7c 93			call break_point_state  
c0ba				endm  
# End of macro CALLMONITOR
c0ba					endif 
c0ba ed b0				ldir 
c0bc			 
c0bc			 
c0bc			 
c0bc 21 57 e3				ld hl, scratch 
c0bf					if DEBUG_FORTH_WORDS 
c0bf						DMARK "CO5" 
c0bf f5				push af  
c0c0 3a d4 c0			ld a, (.dmark)  
c0c3 32 71 ee			ld (debug_mark),a  
c0c6 3a d5 c0			ld a, (.dmark+1)  
c0c9 32 72 ee			ld (debug_mark+1),a  
c0cc 3a d6 c0			ld a, (.dmark+2)  
c0cf 32 73 ee			ld (debug_mark+2),a  
c0d2 18 03			jr .pastdmark  
c0d4 ..			.dmark: db "CO5"  
c0d7 f1			.pastdmark: pop af  
c0d8			endm  
# End of macro DMARK
c0d8						CALLMONITOR 
c0d8 cd 7c 93			call break_point_state  
c0db				endm  
# End of macro CALLMONITOR
c0db					endif 
c0db			 
c0db cd 44 9a				call forth_push_str 
c0de			 
c0de			 
c0de			 
c0de			 
c0de				       NEXTW 
c0de c3 3f 9d			jp macro_next 
c0e1				endm 
# End of macro NEXTW
c0e1			 
c0e1			 
c0e1			.FIND: 
c0e1				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c0e1 4b				db WORD_SYS_CORE+55             
c0e2 9f c1			dw .LEN            
c0e4 05				db 4 + 1 
c0e5 .. 00			db "FIND",0              
c0ea				endm 
# End of macro CWHEAD
c0ea			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c0ea			 
c0ea					if DEBUG_FORTH_WORDS_KEY 
c0ea						DMARK "FND" 
c0ea f5				push af  
c0eb 3a ff c0			ld a, (.dmark)  
c0ee 32 71 ee			ld (debug_mark),a  
c0f1 3a 00 c1			ld a, (.dmark+1)  
c0f4 32 72 ee			ld (debug_mark+1),a  
c0f7 3a 01 c1			ld a, (.dmark+2)  
c0fa 32 73 ee			ld (debug_mark+2),a  
c0fd 18 03			jr .pastdmark  
c0ff ..			.dmark: db "FND"  
c102 f1			.pastdmark: pop af  
c103			endm  
# End of macro DMARK
c103						CALLMONITOR 
c103 cd 7c 93			call break_point_state  
c106				endm  
# End of macro CALLMONITOR
c106					endif 
c106			 
c106			; TODO check string type 
c106					FORTH_DSP_VALUE 
c106 cd b6 9b			call macro_forth_dsp_value 
c109				endm 
# End of macro FORTH_DSP_VALUE
c109			 
c109 e5					push hl    
c10a 7e					ld a,(hl)    ; char to find   
c10b			; TODO change char to substr 
c10b			 
c10b f5					push af 
c10c					 
c10c			 
c10c			 
c10c					if DEBUG_FORTH_WORDS 
c10c						DMARK "FN1" 
c10c f5				push af  
c10d 3a 21 c1			ld a, (.dmark)  
c110 32 71 ee			ld (debug_mark),a  
c113 3a 22 c1			ld a, (.dmark+1)  
c116 32 72 ee			ld (debug_mark+1),a  
c119 3a 23 c1			ld a, (.dmark+2)  
c11c 32 73 ee			ld (debug_mark+2),a  
c11f 18 03			jr .pastdmark  
c121 ..			.dmark: db "FN1"  
c124 f1			.pastdmark: pop af  
c125			endm  
# End of macro DMARK
c125						CALLMONITOR 
c125 cd 7c 93			call break_point_state  
c128				endm  
# End of macro CALLMONITOR
c128					endif 
c128			 
c128					FORTH_DSP_POP 
c128 cd 85 9c			call macro_forth_dsp_pop 
c12b				endm 
# End of macro FORTH_DSP_POP
c12b			 
c12b					; string to search 
c12b			 
c12b					FORTH_DSP_VALUE 
c12b cd b6 9b			call macro_forth_dsp_value 
c12e				endm 
# End of macro FORTH_DSP_VALUE
c12e			 
c12e d1					pop de  ; d is char to find  
c12f			 
c12f					if DEBUG_FORTH_WORDS 
c12f						DMARK "FN2" 
c12f f5				push af  
c130 3a 44 c1			ld a, (.dmark)  
c133 32 71 ee			ld (debug_mark),a  
c136 3a 45 c1			ld a, (.dmark+1)  
c139 32 72 ee			ld (debug_mark+1),a  
c13c 3a 46 c1			ld a, (.dmark+2)  
c13f 32 73 ee			ld (debug_mark+2),a  
c142 18 03			jr .pastdmark  
c144 ..			.dmark: db "FN2"  
c147 f1			.pastdmark: pop af  
c148			endm  
# End of macro DMARK
c148						CALLMONITOR 
c148 cd 7c 93			call break_point_state  
c14b				endm  
# End of macro CALLMONITOR
c14b					endif 
c14b					 
c14b 01 00 00				ld bc, 0 
c14e 7e			.findchar:      ld a,(hl) 
c14f fe 00				cp 0   		 
c151 28 27				jr z, .finddone     
c153 ba					cp d 
c154 28 20				jr z, .foundchar 
c156 03					inc bc 
c157 23					inc hl 
c158					if DEBUG_FORTH_WORDS 
c158						DMARK "FN3" 
c158 f5				push af  
c159 3a 6d c1			ld a, (.dmark)  
c15c 32 71 ee			ld (debug_mark),a  
c15f 3a 6e c1			ld a, (.dmark+1)  
c162 32 72 ee			ld (debug_mark+1),a  
c165 3a 6f c1			ld a, (.dmark+2)  
c168 32 73 ee			ld (debug_mark+2),a  
c16b 18 03			jr .pastdmark  
c16d ..			.dmark: db "FN3"  
c170 f1			.pastdmark: pop af  
c171			endm  
# End of macro DMARK
c171						CALLMONITOR 
c171 cd 7c 93			call break_point_state  
c174				endm  
# End of macro CALLMONITOR
c174					endif 
c174 18 d8				jr .findchar 
c176			 
c176			 
c176 c5			.foundchar:	push bc 
c177 e1					pop hl 
c178 18 03				jr .findexit 
c17a			 
c17a			 
c17a							 
c17a			 
c17a			.finddone:     ; got to end of string with no find 
c17a 21 00 00				ld hl, 0 
c17d			.findexit: 
c17d			 
c17d					if DEBUG_FORTH_WORDS 
c17d						DMARK "FNd" 
c17d f5				push af  
c17e 3a 92 c1			ld a, (.dmark)  
c181 32 71 ee			ld (debug_mark),a  
c184 3a 93 c1			ld a, (.dmark+1)  
c187 32 72 ee			ld (debug_mark+1),a  
c18a 3a 94 c1			ld a, (.dmark+2)  
c18d 32 73 ee			ld (debug_mark+2),a  
c190 18 03			jr .pastdmark  
c192 ..			.dmark: db "FNd"  
c195 f1			.pastdmark: pop af  
c196			endm  
# End of macro DMARK
c196						CALLMONITOR 
c196 cd 7c 93			call break_point_state  
c199				endm  
# End of macro CALLMONITOR
c199					endif 
c199 cd d6 99			call forth_push_numhl 
c19c			 
c19c				       NEXTW 
c19c c3 3f 9d			jp macro_next 
c19f				endm 
# End of macro NEXTW
c19f			 
c19f			.LEN: 
c19f				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c19f 4c				db WORD_SYS_CORE+56             
c1a0 d4 c1			dw .CHAR            
c1a2 06				db 5 + 1 
c1a3 .. 00			db "COUNT",0              
c1a9				endm 
# End of macro CWHEAD
c1a9			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c1a9			 
c1a9					if DEBUG_FORTH_WORDS_KEY 
c1a9						DMARK "CNT" 
c1a9 f5				push af  
c1aa 3a be c1			ld a, (.dmark)  
c1ad 32 71 ee			ld (debug_mark),a  
c1b0 3a bf c1			ld a, (.dmark+1)  
c1b3 32 72 ee			ld (debug_mark+1),a  
c1b6 3a c0 c1			ld a, (.dmark+2)  
c1b9 32 73 ee			ld (debug_mark+2),a  
c1bc 18 03			jr .pastdmark  
c1be ..			.dmark: db "CNT"  
c1c1 f1			.pastdmark: pop af  
c1c2			endm  
# End of macro DMARK
c1c2						CALLMONITOR 
c1c2 cd 7c 93			call break_point_state  
c1c5				endm  
# End of macro CALLMONITOR
c1c5					endif 
c1c5			; TODO check string type 
c1c5					FORTH_DSP 
c1c5 cd 93 9b			call macro_forth_dsp 
c1c8				endm 
# End of macro FORTH_DSP
c1c8					;v5FORTH_DSP_VALUE 
c1c8			 
c1c8 23					inc hl 
c1c9			 
c1c9 3e 00				ld a, 0 
c1cb cd e4 8f				call strlent 
c1ce			 
c1ce cd d6 99				call forth_push_numhl 
c1d1			 
c1d1			 
c1d1			 
c1d1				       NEXTW 
c1d1 c3 3f 9d			jp macro_next 
c1d4				endm 
# End of macro NEXTW
c1d4			.CHAR: 
c1d4				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c1d4 4d				db WORD_SYS_CORE+57             
c1d5 0a c2			dw .ENDSTR            
c1d7 05				db 4 + 1 
c1d8 .. 00			db "CHAR",0              
c1dd				endm 
# End of macro CWHEAD
c1dd			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c1dd					if DEBUG_FORTH_WORDS_KEY 
c1dd						DMARK "CHR" 
c1dd f5				push af  
c1de 3a f2 c1			ld a, (.dmark)  
c1e1 32 71 ee			ld (debug_mark),a  
c1e4 3a f3 c1			ld a, (.dmark+1)  
c1e7 32 72 ee			ld (debug_mark+1),a  
c1ea 3a f4 c1			ld a, (.dmark+2)  
c1ed 32 73 ee			ld (debug_mark+2),a  
c1f0 18 03			jr .pastdmark  
c1f2 ..			.dmark: db "CHR"  
c1f5 f1			.pastdmark: pop af  
c1f6			endm  
# End of macro DMARK
c1f6						CALLMONITOR 
c1f6 cd 7c 93			call break_point_state  
c1f9				endm  
# End of macro CALLMONITOR
c1f9					endif 
c1f9					FORTH_DSP 
c1f9 cd 93 9b			call macro_forth_dsp 
c1fc				endm 
# End of macro FORTH_DSP
c1fc					;v5 FORTH_DSP_VALUE 
c1fc 23					inc hl      ; now at start of numeric as string 
c1fd			 
c1fd			;		push hl 
c1fd			 
c1fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1fd cd 85 9c			call macro_forth_dsp_pop 
c200				endm 
# End of macro FORTH_DSP_POP
c200			 
c200			;		pop hl 
c200			 
c200					; push the content of a onto the stack as a value 
c200			 
c200 7e					ld a,(hl)   ; get char 
c201 26 00				ld h,0 
c203 6f					ld l,a 
c204 cd d6 99				call forth_push_numhl 
c207			 
c207				       NEXTW 
c207 c3 3f 9d			jp macro_next 
c20a				endm 
# End of macro NEXTW
c20a			 
c20a			 
c20a			 
c20a			 
c20a			.ENDSTR: 
c20a			; eof 
c20a			 
# End of file forth_words_str.asm
c20a			include "forth_words_key.asm" 
c20a			 
c20a			; | ## Keyboard Words 
c20a			 
c20a			.KEY: 
c20a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c20a 3e				db WORD_SYS_CORE+42             
c20b 3a c2			dw .WAITK            
c20d 04				db 3 + 1 
c20e .. 00			db "KEY",0              
c212				endm 
# End of macro CWHEAD
c212			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c212			 
c212					if DEBUG_FORTH_WORDS_KEY 
c212						DMARK "KEY" 
c212 f5				push af  
c213 3a 27 c2			ld a, (.dmark)  
c216 32 71 ee			ld (debug_mark),a  
c219 3a 28 c2			ld a, (.dmark+1)  
c21c 32 72 ee			ld (debug_mark+1),a  
c21f 3a 29 c2			ld a, (.dmark+2)  
c222 32 73 ee			ld (debug_mark+2),a  
c225 18 03			jr .pastdmark  
c227 ..			.dmark: db "KEY"  
c22a f1			.pastdmark: pop af  
c22b			endm  
# End of macro DMARK
c22b						CALLMONITOR 
c22b cd 7c 93			call break_point_state  
c22e				endm  
# End of macro CALLMONITOR
c22e					endif 
c22e			; TODO currently waits 
c22e cd dc d8				call cin 
c231					;call cin_wait 
c231 6f					ld l, a 
c232 26 00				ld h, 0 
c234 cd d6 99				call forth_push_numhl 
c237					NEXTW 
c237 c3 3f 9d			jp macro_next 
c23a				endm 
# End of macro NEXTW
c23a			.WAITK: 
c23a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c23a 3f				db WORD_SYS_CORE+43             
c23b 6c c2			dw .ACCEPT            
c23d 06				db 5 + 1 
c23e .. 00			db "WAITK",0              
c244				endm 
# End of macro CWHEAD
c244			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c244					if DEBUG_FORTH_WORDS_KEY 
c244						DMARK "WAI" 
c244 f5				push af  
c245 3a 59 c2			ld a, (.dmark)  
c248 32 71 ee			ld (debug_mark),a  
c24b 3a 5a c2			ld a, (.dmark+1)  
c24e 32 72 ee			ld (debug_mark+1),a  
c251 3a 5b c2			ld a, (.dmark+2)  
c254 32 73 ee			ld (debug_mark+2),a  
c257 18 03			jr .pastdmark  
c259 ..			.dmark: db "WAI"  
c25c f1			.pastdmark: pop af  
c25d			endm  
# End of macro DMARK
c25d						CALLMONITOR 
c25d cd 7c 93			call break_point_state  
c260				endm  
# End of macro CALLMONITOR
c260					endif 
c260 cd d6 d8				call cin_wait 
c263 6f					ld l, a 
c264 26 00				ld h, 0 
c266 cd d6 99				call forth_push_numhl 
c269					NEXTW 
c269 c3 3f 9d			jp macro_next 
c26c				endm 
# End of macro NEXTW
c26c			.ACCEPT: 
c26c				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c26c 40				db WORD_SYS_CORE+44             
c26d ca c2			dw .EDIT            
c26f 07				db 6 + 1 
c270 .. 00			db "ACCEPT",0              
c277				endm 
# End of macro CWHEAD
c277			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c277					; TODO crashes on push 
c277					if DEBUG_FORTH_WORDS_KEY 
c277						DMARK "ACC" 
c277 f5				push af  
c278 3a 8c c2			ld a, (.dmark)  
c27b 32 71 ee			ld (debug_mark),a  
c27e 3a 8d c2			ld a, (.dmark+1)  
c281 32 72 ee			ld (debug_mark+1),a  
c284 3a 8e c2			ld a, (.dmark+2)  
c287 32 73 ee			ld (debug_mark+2),a  
c28a 18 03			jr .pastdmark  
c28c ..			.dmark: db "ACC"  
c28f f1			.pastdmark: pop af  
c290			endm  
# End of macro DMARK
c290						CALLMONITOR 
c290 cd 7c 93			call break_point_state  
c293				endm  
# End of macro CALLMONITOR
c293					endif 
c293 21 55 e5				ld hl, os_input 
c296 3e 00				ld a, 0 
c298 77					ld (hl),a 
c299 3a 40 eb				ld a,(f_cursor_ptr) 
c29c 16 64				ld d, 100 
c29e 0e 00				ld c, 0 
c2a0 1e 28				ld e, 40 
c2a2 cd a8 8b				call input_str 
c2a5					; TODO perhaps do a type check and wrap in quotes if not a number 
c2a5 21 55 e5				ld hl, os_input 
c2a8					if DEBUG_FORTH_WORDS 
c2a8						DMARK "AC1" 
c2a8 f5				push af  
c2a9 3a bd c2			ld a, (.dmark)  
c2ac 32 71 ee			ld (debug_mark),a  
c2af 3a be c2			ld a, (.dmark+1)  
c2b2 32 72 ee			ld (debug_mark+1),a  
c2b5 3a bf c2			ld a, (.dmark+2)  
c2b8 32 73 ee			ld (debug_mark+2),a  
c2bb 18 03			jr .pastdmark  
c2bd ..			.dmark: db "AC1"  
c2c0 f1			.pastdmark: pop af  
c2c1			endm  
# End of macro DMARK
c2c1						CALLMONITOR 
c2c1 cd 7c 93			call break_point_state  
c2c4				endm  
# End of macro CALLMONITOR
c2c4					endif 
c2c4 cd 44 9a				call forth_push_str 
c2c7					NEXTW 
c2c7 c3 3f 9d			jp macro_next 
c2ca				endm 
# End of macro NEXTW
c2ca			 
c2ca			.EDIT: 
c2ca				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c2ca 40				db WORD_SYS_CORE+44             
c2cb 6c c3			dw .ENDKEY            
c2cd 05				db 4 + 1 
c2ce .. 00			db "EDIT",0              
c2d3				endm 
# End of macro CWHEAD
c2d3			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c2d3			 
c2d3					; TODO does not copy from stack 
c2d3					if DEBUG_FORTH_WORDS_KEY 
c2d3						DMARK "EDT" 
c2d3 f5				push af  
c2d4 3a e8 c2			ld a, (.dmark)  
c2d7 32 71 ee			ld (debug_mark),a  
c2da 3a e9 c2			ld a, (.dmark+1)  
c2dd 32 72 ee			ld (debug_mark+1),a  
c2e0 3a ea c2			ld a, (.dmark+2)  
c2e3 32 73 ee			ld (debug_mark+2),a  
c2e6 18 03			jr .pastdmark  
c2e8 ..			.dmark: db "EDT"  
c2eb f1			.pastdmark: pop af  
c2ec			endm  
# End of macro DMARK
c2ec						CALLMONITOR 
c2ec cd 7c 93			call break_point_state  
c2ef				endm  
# End of macro CALLMONITOR
c2ef					endif 
c2ef			 
c2ef					;FORTH_DSP 
c2ef					FORTH_DSP_VALUEHL 
c2ef cd cd 9b			call macro_dsp_valuehl 
c2f2				endm 
# End of macro FORTH_DSP_VALUEHL
c2f2			;		inc hl    ; TODO do type check 
c2f2			 
c2f2			;		call get_word_hl 
c2f2 e5					push hl 
c2f3					if DEBUG_FORTH_WORDS 
c2f3						DMARK "EDp" 
c2f3 f5				push af  
c2f4 3a 08 c3			ld a, (.dmark)  
c2f7 32 71 ee			ld (debug_mark),a  
c2fa 3a 09 c3			ld a, (.dmark+1)  
c2fd 32 72 ee			ld (debug_mark+1),a  
c300 3a 0a c3			ld a, (.dmark+2)  
c303 32 73 ee			ld (debug_mark+2),a  
c306 18 03			jr .pastdmark  
c308 ..			.dmark: db "EDp"  
c30b f1			.pastdmark: pop af  
c30c			endm  
# End of macro DMARK
c30c						CALLMONITOR 
c30c cd 7c 93			call break_point_state  
c30f				endm  
# End of macro CALLMONITOR
c30f					endif 
c30f				;	ld a, 0 
c30f cd d9 8f				call strlenz 
c312 23					inc hl 
c313			 
c313 06 00				ld b, 0 
c315 4d					ld c, l 
c316			 
c316 e1					pop hl 
c317 11 55 e5				ld de, os_input 
c31a					if DEBUG_FORTH_WORDS_KEY 
c31a						DMARK "EDc" 
c31a f5				push af  
c31b 3a 2f c3			ld a, (.dmark)  
c31e 32 71 ee			ld (debug_mark),a  
c321 3a 30 c3			ld a, (.dmark+1)  
c324 32 72 ee			ld (debug_mark+1),a  
c327 3a 31 c3			ld a, (.dmark+2)  
c32a 32 73 ee			ld (debug_mark+2),a  
c32d 18 03			jr .pastdmark  
c32f ..			.dmark: db "EDc"  
c332 f1			.pastdmark: pop af  
c333			endm  
# End of macro DMARK
c333						CALLMONITOR 
c333 cd 7c 93			call break_point_state  
c336				endm  
# End of macro CALLMONITOR
c336					endif 
c336 ed b0				ldir 
c338			 
c338			 
c338 21 55 e5				ld hl, os_input 
c33b					;ld a, 0 
c33b					;ld (hl),a 
c33b 3a 40 eb				ld a,(f_cursor_ptr) 
c33e 16 64				ld d, 100 
c340 0e 00				ld c, 0 
c342 1e 28				ld e, 40 
c344 cd a8 8b				call input_str 
c347					; TODO perhaps do a type check and wrap in quotes if not a number 
c347 21 55 e5				ld hl, os_input 
c34a					if DEBUG_FORTH_WORDS 
c34a						DMARK "ED1" 
c34a f5				push af  
c34b 3a 5f c3			ld a, (.dmark)  
c34e 32 71 ee			ld (debug_mark),a  
c351 3a 60 c3			ld a, (.dmark+1)  
c354 32 72 ee			ld (debug_mark+1),a  
c357 3a 61 c3			ld a, (.dmark+2)  
c35a 32 73 ee			ld (debug_mark+2),a  
c35d 18 03			jr .pastdmark  
c35f ..			.dmark: db "ED1"  
c362 f1			.pastdmark: pop af  
c363			endm  
# End of macro DMARK
c363						CALLMONITOR 
c363 cd 7c 93			call break_point_state  
c366				endm  
# End of macro CALLMONITOR
c366					endif 
c366 cd 44 9a				call forth_push_str 
c369					NEXTW 
c369 c3 3f 9d			jp macro_next 
c36c				endm 
# End of macro NEXTW
c36c			 
c36c			 
c36c			 
c36c			.ENDKEY: 
c36c			; eof 
c36c			 
# End of file forth_words_key.asm
c36c			 
c36c			if STORAGE_SE 
c36c			   	include "forth_words_storage.asm" 
c36c			endif 
c36c				include "forth_words_device.asm" 
c36c			; Device related words 
c36c			 
c36c			; | ## Device Words 
c36c			 
c36c			if SOUND_ENABLE 
c36c			.NOTE: 
c36c				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c36c			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c36c					if DEBUG_FORTH_WORDS_KEY 
c36c						DMARK "NTE" 
c36c						CALLMONITOR 
c36c					endif 
c36c			 
c36c				 
c36c			 
c36c					NEXTW 
c36c			.AFTERSOUND: 
c36c			endif 
c36c			 
c36c			 
c36c			USE_GPIO: equ 0 
c36c			 
c36c			if USE_GPIO 
c36c			.GP1: 
c36c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c36c			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c36c					NEXTW 
c36c			.GP2: 
c36c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c36c			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c36c			 
c36c					NEXTW 
c36c			 
c36c			.GP3: 
c36c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c36c			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c36c			 
c36c					NEXTW 
c36c			 
c36c			.GP4: 
c36c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c36c			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c36c			 
c36c					NEXTW 
c36c			.SIN: 
c36c			 
c36c			 
c36c			endif 
c36c			 
c36c			 
c36c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c36c 33				db WORD_SYS_CORE+31             
c36d a1 c3			dw .SOUT            
c36f 03				db 2 + 1 
c370 .. 00			db "IN",0              
c373				endm 
# End of macro CWHEAD
c373			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c373					if DEBUG_FORTH_WORDS_KEY 
c373						DMARK "IN." 
c373 f5				push af  
c374 3a 88 c3			ld a, (.dmark)  
c377 32 71 ee			ld (debug_mark),a  
c37a 3a 89 c3			ld a, (.dmark+1)  
c37d 32 72 ee			ld (debug_mark+1),a  
c380 3a 8a c3			ld a, (.dmark+2)  
c383 32 73 ee			ld (debug_mark+2),a  
c386 18 03			jr .pastdmark  
c388 ..			.dmark: db "IN."  
c38b f1			.pastdmark: pop af  
c38c			endm  
# End of macro DMARK
c38c						CALLMONITOR 
c38c cd 7c 93			call break_point_state  
c38f				endm  
# End of macro CALLMONITOR
c38f					endif 
c38f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c38f cd cd 9b			call macro_dsp_valuehl 
c392				endm 
# End of macro FORTH_DSP_VALUEHL
c392			 
c392 e5					push hl 
c393			 
c393					; destroy value TOS 
c393			 
c393					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c393 cd 85 9c			call macro_forth_dsp_pop 
c396				endm 
# End of macro FORTH_DSP_POP
c396			 
c396					; one value on hl get other one back 
c396			 
c396 c1					pop bc 
c397			 
c397					; do the sub 
c397			;		ex de, hl 
c397			 
c397 ed 68				in l,(c) 
c399			 
c399					; save it 
c399			 
c399 26 00				ld h,0 
c39b			 
c39b					; TODO push value back onto stack for another op etc 
c39b			 
c39b cd d6 99				call forth_push_numhl 
c39e					NEXTW 
c39e c3 3f 9d			jp macro_next 
c3a1				endm 
# End of macro NEXTW
c3a1			.SOUT: 
c3a1				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c3a1 34				db WORD_SYS_CORE+32             
c3a2 f4 c3			dw .SPIO            
c3a4 04				db 3 + 1 
c3a5 .. 00			db "OUT",0              
c3a9				endm 
# End of macro CWHEAD
c3a9			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c3a9					if DEBUG_FORTH_WORDS_KEY 
c3a9						DMARK "OUT" 
c3a9 f5				push af  
c3aa 3a be c3			ld a, (.dmark)  
c3ad 32 71 ee			ld (debug_mark),a  
c3b0 3a bf c3			ld a, (.dmark+1)  
c3b3 32 72 ee			ld (debug_mark+1),a  
c3b6 3a c0 c3			ld a, (.dmark+2)  
c3b9 32 73 ee			ld (debug_mark+2),a  
c3bc 18 03			jr .pastdmark  
c3be ..			.dmark: db "OUT"  
c3c1 f1			.pastdmark: pop af  
c3c2			endm  
# End of macro DMARK
c3c2						CALLMONITOR 
c3c2 cd 7c 93			call break_point_state  
c3c5				endm  
# End of macro CALLMONITOR
c3c5					endif 
c3c5			 
c3c5					; get port 
c3c5			 
c3c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3c5 cd cd 9b			call macro_dsp_valuehl 
c3c8				endm 
# End of macro FORTH_DSP_VALUEHL
c3c8			 
c3c8 e5					push hl 
c3c9			 
c3c9					; destroy value TOS 
c3c9			 
c3c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3c9 cd 85 9c			call macro_forth_dsp_pop 
c3cc				endm 
# End of macro FORTH_DSP_POP
c3cc			 
c3cc					; get byte to send 
c3cc			 
c3cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3cc cd cd 9b			call macro_dsp_valuehl 
c3cf				endm 
# End of macro FORTH_DSP_VALUEHL
c3cf			 
c3cf			;		push hl 
c3cf			 
c3cf					; destroy value TOS 
c3cf			 
c3cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3cf cd 85 9c			call macro_forth_dsp_pop 
c3d2				endm 
# End of macro FORTH_DSP_POP
c3d2			 
c3d2					; one value on hl get other one back 
c3d2			 
c3d2			;		pop hl 
c3d2			 
c3d2 c1					pop bc 
c3d3			 
c3d3					if DEBUG_FORTH_WORDS 
c3d3						DMARK "OUT" 
c3d3 f5				push af  
c3d4 3a e8 c3			ld a, (.dmark)  
c3d7 32 71 ee			ld (debug_mark),a  
c3da 3a e9 c3			ld a, (.dmark+1)  
c3dd 32 72 ee			ld (debug_mark+1),a  
c3e0 3a ea c3			ld a, (.dmark+2)  
c3e3 32 73 ee			ld (debug_mark+2),a  
c3e6 18 03			jr .pastdmark  
c3e8 ..			.dmark: db "OUT"  
c3eb f1			.pastdmark: pop af  
c3ec			endm  
# End of macro DMARK
c3ec						CALLMONITOR 
c3ec cd 7c 93			call break_point_state  
c3ef				endm  
# End of macro CALLMONITOR
c3ef					endif 
c3ef			 
c3ef ed 69				out (c), l 
c3f1			 
c3f1					NEXTW 
c3f1 c3 3f 9d			jp macro_next 
c3f4				endm 
# End of macro NEXTW
c3f4			 
c3f4			 
c3f4			.SPIO: 
c3f4			 
c3f4			if STORAGE_SE 
c3f4				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c3f4			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c3f4			 
c3f4					call spi_ce_low 
c3f4			    NEXTW 
c3f4			 
c3f4			.SPICEH: 
c3f4				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c3f4			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c3f4			 
c3f4					call spi_ce_high 
c3f4			    NEXTW 
c3f4			 
c3f4			 
c3f4			.SPIOb: 
c3f4			 
c3f4				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c3f4			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c3f4			 
c3f4					; get port 
c3f4			 
c3f4			 
c3f4					; get byte to send 
c3f4			 
c3f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3f4			 
c3f4			;		push hl    ; u1  
c3f4			 
c3f4					; destroy value TOS 
c3f4			 
c3f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f4			 
c3f4					; one value on hl get other one back 
c3f4			 
c3f4			;		pop hl   ; u2 - addr 
c3f4			 
c3f4					; TODO Send SPI byte 
c3f4			 
c3f4					ld a, l 
c3f4					call spi_send_byte 
c3f4			 
c3f4					NEXTW 
c3f4			 
c3f4			.SPII: 
c3f4				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c3f4			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c3f4			 
c3f4					; TODO Get SPI byte 
c3f4			 
c3f4					call spi_read_byte 
c3f4			 
c3f4					ld h, 0 
c3f4					ld l, a 
c3f4					call forth_push_numhl 
c3f4			 
c3f4					NEXTW 
c3f4			 
c3f4			 
c3f4			 
c3f4			.SESEL: 
c3f4				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c3f4			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c3f4					if DEBUG_FORTH_WORDS_KEY 
c3f4						DMARK "BNK" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4			 
c3f4					ld a, 255 
c3f4					ld (spi_cartdev), a 
c3f4			 
c3f4					; get bank 
c3f4			 
c3f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3f4			 
c3f4			;		push hl 
c3f4			 
c3f4					; destroy value TOS 
c3f4			 
c3f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f4			 
c3f4					; one value on hl get other one back 
c3f4			 
c3f4			;		pop hl 
c3f4			 
c3f4			 
c3f4					ld c, SPI_CE_HIGH 
c3f4					ld b, '0'    ; human readable bank number 
c3f4			 
c3f4					ld a, l 
c3f4			 
c3f4					if DEBUG_FORTH_WORDS 
c3f4						DMARK "BNK" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4			 
c3f4					; active low 
c3f4			 
c3f4					cp 0 
c3f4					jr z, .bset 
c3f4					cp 1 
c3f4					jr nz, .b2 
c3f4					res 0, c 
c3f4					ld b, '1'    ; human readable bank number 
c3f4			.b2:		cp 2 
c3f4					jr nz, .b3 
c3f4					res 1, c 
c3f4					ld b, '2'    ; human readable bank number 
c3f4			.b3:		cp 3 
c3f4					jr nz, .b4 
c3f4					res 2, c 
c3f4					ld b, '3'    ; human readable bank number 
c3f4			.b4:		cp 4 
c3f4					jr nz, .b5 
c3f4					res 3, c 
c3f4					ld b, '4'    ; human readable bank number 
c3f4			.b5:		cp 5 
c3f4					jr nz, .bset 
c3f4					res 4, c 
c3f4					ld b, '5'    ; human readable bank number 
c3f4			 
c3f4			.bset: 
c3f4					ld a, c 
c3f4					ld (spi_device),a 
c3f4					ld a, b 
c3f4					ld (spi_device_id),a 
c3f4					if DEBUG_FORTH_WORDS 
c3f4						DMARK "BN2" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4			 
c3f4					NEXTW 
c3f4			 
c3f4			.CARTDEV: 
c3f4				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c3f4			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c3f4					if DEBUG_FORTH_WORDS_KEY 
c3f4						DMARK "CDV" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4			 
c3f4					; disable se storage bank selection 
c3f4			 
c3f4					ld a, SPI_CE_HIGH		; ce high 
c3f4					ld (spi_device), a 
c3f4			 
c3f4					; get bank 
c3f4			 
c3f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3f4			 
c3f4			;		push hl 
c3f4			 
c3f4					; destroy value TOS 
c3f4			 
c3f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f4			 
c3f4					; one value on hl get other one back 
c3f4			 
c3f4			;		pop hl 
c3f4			 
c3f4					; active low 
c3f4			 
c3f4					ld c, 255 
c3f4			 
c3f4					ld a, l 
c3f4					if DEBUG_FORTH_WORDS 
c3f4						DMARK "CDV" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4					cp 0 
c3f4					jr z, .cset 
c3f4					cp 1 
c3f4					jr nz, .c2 
c3f4					res 0, c 
c3f4			.c2:		cp 2 
c3f4					jr nz, .c3 
c3f4					res 1, c 
c3f4			.c3:		cp 3 
c3f4					jr nz, .c4 
c3f4					res 2, c 
c3f4			.c4:		cp 4 
c3f4					jr nz, .c5 
c3f4					res 3, c 
c3f4			.c5:		cp 5 
c3f4					jr nz, .c6 
c3f4					res 4, c 
c3f4			.c6:		cp 6 
c3f4					jr nz, .c7 
c3f4					res 5, c 
c3f4			.c7:		cp 7 
c3f4					jr nz, .c8 
c3f4					res 6, c 
c3f4			.c8:		cp 8 
c3f4					jr nz, .cset 
c3f4					res 7, c 
c3f4			.cset:		ld a, c 
c3f4					ld (spi_cartdev),a 
c3f4			 
c3f4					if DEBUG_FORTH_WORDS 
c3f4						DMARK "CD2" 
c3f4						CALLMONITOR 
c3f4					endif 
c3f4					NEXTW 
c3f4			endif 
c3f4			 
c3f4			.ENDDEVICE: 
c3f4			; eof 
c3f4			 
# End of file forth_words_device.asm
c3f4			 
c3f4			; var handler 
c3f4			 
c3f4			 
c3f4			.VARS: 
c3f4				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c3f4 78				db WORD_SYS_CORE+100             
c3f5 0c c4			dw .V0Q            
c3f7 04				db 3 + 1 
c3f8 .. 00			db "V0!",0              
c3fc				endm 
# End of macro CWHEAD
c3fc			;| V0! ( u1 -- )  Store value to v0  | DONE 
c3fc			 
c3fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3fc cd cd 9b			call macro_dsp_valuehl 
c3ff				endm 
# End of macro FORTH_DSP_VALUEHL
c3ff			 
c3ff 11 0a eb				ld de, cli_var_array 
c402			 
c402 eb					ex de, hl 
c403 73					ld (hl), e 
c404 23					inc hl 
c405 72					ld (hl), d 
c406			 
c406					; destroy value TOS 
c406			 
c406					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c406 cd 85 9c			call macro_forth_dsp_pop 
c409				endm 
# End of macro FORTH_DSP_POP
c409			 
c409				       NEXTW 
c409 c3 3f 9d			jp macro_next 
c40c				endm 
# End of macro NEXTW
c40c			.V0Q: 
c40c				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c40c 79				db WORD_SYS_CORE+101             
c40d 1d c4			dw .V1S            
c40f 04				db 3 + 1 
c410 .. 00			db "V0@",0              
c414				endm 
# End of macro CWHEAD
c414			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c414 2a 0a eb				ld hl, (cli_var_array) 
c417 cd d6 99				call forth_push_numhl 
c41a			 
c41a				       NEXTW 
c41a c3 3f 9d			jp macro_next 
c41d				endm 
# End of macro NEXTW
c41d			.V1S: 
c41d				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c41d 7a				db WORD_SYS_CORE+102             
c41e 35 c4			dw .V1Q            
c420 04				db 3 + 1 
c421 .. 00			db "V1!",0              
c425				endm 
# End of macro CWHEAD
c425			;| V1! ( u1 -- )  Store value to v1 | DONE 
c425					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c425 cd cd 9b			call macro_dsp_valuehl 
c428				endm 
# End of macro FORTH_DSP_VALUEHL
c428			 
c428 11 0c eb				ld de, cli_var_array+2 
c42b				 
c42b eb					ex de, hl 
c42c 73					ld (hl), e 
c42d 23					inc hl 
c42e 72					ld (hl), d 
c42f			 
c42f					; destroy value TOS 
c42f			 
c42f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c42f cd 85 9c			call macro_forth_dsp_pop 
c432				endm 
# End of macro FORTH_DSP_POP
c432				       NEXTW 
c432 c3 3f 9d			jp macro_next 
c435				endm 
# End of macro NEXTW
c435			.V1Q: 
c435				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c435 7b				db WORD_SYS_CORE+103             
c436 46 c4			dw .V2S            
c438 04				db 3 + 1 
c439 .. 00			db "V1@",0              
c43d				endm 
# End of macro CWHEAD
c43d			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c43d 2a 0c eb				ld hl, (cli_var_array+2) 
c440 cd d6 99				call forth_push_numhl 
c443				       NEXTW 
c443 c3 3f 9d			jp macro_next 
c446				endm 
# End of macro NEXTW
c446			.V2S: 
c446				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c446 7c				db WORD_SYS_CORE+104             
c447 5e c4			dw .V2Q            
c449 04				db 3 + 1 
c44a .. 00			db "V2!",0              
c44e				endm 
# End of macro CWHEAD
c44e			;| V2! ( u1 -- )  Store value to v2 | DONE 
c44e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c44e cd cd 9b			call macro_dsp_valuehl 
c451				endm 
# End of macro FORTH_DSP_VALUEHL
c451			 
c451 11 0e eb				ld de, cli_var_array+4 
c454				 
c454 eb					ex de, hl 
c455 73					ld (hl), e 
c456 23					inc hl 
c457 72					ld (hl), d 
c458			 
c458					; destroy value TOS 
c458			 
c458					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c458 cd 85 9c			call macro_forth_dsp_pop 
c45b				endm 
# End of macro FORTH_DSP_POP
c45b				       NEXTW 
c45b c3 3f 9d			jp macro_next 
c45e				endm 
# End of macro NEXTW
c45e			.V2Q: 
c45e				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c45e 7d				db WORD_SYS_CORE+105             
c45f 6f c4			dw .V3S            
c461 04				db 3 + 1 
c462 .. 00			db "V2@",0              
c466				endm 
# End of macro CWHEAD
c466			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c466 2a 0e eb				ld hl, (cli_var_array+4) 
c469 cd d6 99				call forth_push_numhl 
c46c				       NEXTW 
c46c c3 3f 9d			jp macro_next 
c46f				endm 
# End of macro NEXTW
c46f			.V3S: 
c46f				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c46f 7c				db WORD_SYS_CORE+104             
c470 87 c4			dw .V3Q            
c472 04				db 3 + 1 
c473 .. 00			db "V3!",0              
c477				endm 
# End of macro CWHEAD
c477			;| V3! ( u1 -- )  Store value to v3 | DONE 
c477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c477 cd cd 9b			call macro_dsp_valuehl 
c47a				endm 
# End of macro FORTH_DSP_VALUEHL
c47a			 
c47a 11 10 eb				ld de, cli_var_array+6 
c47d				 
c47d eb					ex de, hl 
c47e 73					ld (hl), e 
c47f 23					inc hl 
c480 72					ld (hl), d 
c481			 
c481					; destroy value TOS 
c481			 
c481					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c481 cd 85 9c			call macro_forth_dsp_pop 
c484				endm 
# End of macro FORTH_DSP_POP
c484				       NEXTW 
c484 c3 3f 9d			jp macro_next 
c487				endm 
# End of macro NEXTW
c487			.V3Q: 
c487				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c487 7d				db WORD_SYS_CORE+105             
c488 98 c4			dw .END            
c48a 04				db 3 + 1 
c48b .. 00			db "V3@",0              
c48f				endm 
# End of macro CWHEAD
c48f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c48f 2a 10 eb				ld hl, (cli_var_array+6) 
c492 cd d6 99				call forth_push_numhl 
c495				       NEXTW 
c495 c3 3f 9d			jp macro_next 
c498				endm 
# End of macro NEXTW
c498			 
c498			 
c498			 
c498			 
c498			 
c498			; end of dict marker 
c498			 
c498 00			.END:    db WORD_SYS_END 
c499 00 00			dw 0 
c49b 00				db 0 
c49c			 
c49c			; use to jp here for user dict words to save on macro expansion  
c49c			 
c49c			user_dict_next: 
c49c				NEXTW 
c49c c3 3f 9d			jp macro_next 
c49f				endm 
# End of macro NEXTW
c49f			 
c49f			 
c49f			user_exec: 
c49f				;    ld hl, <word code> 
c49f				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c49f				;    call forthexec 
c49f				;    jp user_dict_next   (NEXT) 
c49f			        ;    <word code bytes> 
c49f eb				ex de, hl 
c4a0 2a 58 e6			ld hl,(os_tok_ptr) 
c4a3				 
c4a3				FORTH_RSP_NEXT 
c4a3 cd 7d 99			call macro_forth_rsp_next 
c4a6				endm 
# End of macro FORTH_RSP_NEXT
c4a6			 
c4a6			if DEBUG_FORTH_UWORD 
c4a6						DMARK "UEX" 
c4a6 f5				push af  
c4a7 3a bb c4			ld a, (.dmark)  
c4aa 32 71 ee			ld (debug_mark),a  
c4ad 3a bc c4			ld a, (.dmark+1)  
c4b0 32 72 ee			ld (debug_mark+1),a  
c4b3 3a bd c4			ld a, (.dmark+2)  
c4b6 32 73 ee			ld (debug_mark+2),a  
c4b9 18 03			jr .pastdmark  
c4bb ..			.dmark: db "UEX"  
c4be f1			.pastdmark: pop af  
c4bf			endm  
# End of macro DMARK
c4bf				CALLMONITOR 
c4bf cd 7c 93			call break_point_state  
c4c2				endm  
# End of macro CALLMONITOR
c4c2			endif 
c4c2			 
c4c2			 
c4c2			 
c4c2 eb				ex de, hl 
c4c3 22 58 e6			ld (os_tok_ptr), hl 
c4c6				 
c4c6				; Don't use next - Skips the first word in uword. 
c4c6			 
c4c6 c3 d0 9d			jp exec1 
c4c9			;	NEXT 
c4c9			 
c4c9			 
c4c9			; eof 
# End of file forth_wordsv4.asm
c4c9			endif 
c4c9			;;;;;;;;;;;;;; Debug code 
c4c9			 
c4c9			 
c4c9			;if DEBUG_FORTH_PARSE 
c4c9 .. 00		.nowordfound: db "No match",0 
c4d2 .. 00		.compword:	db "Comparing word ",0 
c4e2 .. 00		.nextwordat:	db "Next word at",0 
c4ef .. 00		.charmatch:	db "Char match",0 
c4fa			;endif 
c4fa			if DEBUG_FORTH_JP 
c4fa			.foundword:	db "Word match. Exec..",0 
c4fa			endif 
c4fa			;if DEBUG_FORTH_PUSH 
c4fa .. 00		.enddict:	db "Dict end. Push.",0 
c50a .. 00		.push_str:	db "Pushing string",0 
c519 .. 00		.push_num:	db "Pushing number",0 
c528 .. 00		.data_sp:	db "SP:",0 
c52c .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c53e .. 00		.wordinde:	db "Word in DE (3/0):",0 
c550 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c562			;endif 
c562			;if DEBUG_FORTH_MALLOC 
c562 .. 00		.push_malloc:	db "Malloc address",0 
c571			;endif 
c571			 
c571			 
c571			 
c571			; display malloc address and current data stack pointer  
c571			 
c571			malloc_error: 
c571 d5				push de 
c572 f5				push af 
c573 e5				push hl 
c574 cd 4e 89			call clear_display 
c577 11 99 c5			ld de, .mallocerr 
c57a 3e 00			ld a,0 
c57c			;	ld de,os_word_scratch 
c57c cd 61 89			call str_at_display 
c57f 3e 11			ld a, display_row_1+17 
c581 11 71 ee			ld de, debug_mark 
c584 cd 61 89			call str_at_display 
c587 cd 71 89			call update_display 
c58a				;call break_point_state 
c58a cd d6 d8			call cin_wait 
c58d			 
c58d 3e 20			ld a, ' ' 
c58f 32 48 e3			ld (os_view_disable), a 
c592 e1				pop hl 
c593 f1				pop af 
c594 d1				pop de	 
c595				CALLMONITOR 
c595 cd 7c 93			call break_point_state  
c598				endm  
# End of macro CALLMONITOR
c598 c9				ret 
c599			 
c599 .. 00		.mallocerr: 	db "Malloc Error",0 
c5a6			;if DEBUG_FORTH_PUSH 
c5a6			display_data_sp: 
c5a6 f5				push af 
c5a7			 
c5a7				; see if disabled 
c5a7			 
c5a7 3a 48 e3			ld a, (os_view_disable) 
c5aa fe 2a			cp '*' 
c5ac 28 67			jr z, .skipdsp 
c5ae			 
c5ae e5				push hl 
c5af e5				push hl 
c5b0 e5			push hl 
c5b1 cd 4e 89			call clear_display 
c5b4 e1			pop hl 
c5b5 7c				ld a,h 
c5b6 21 5c e6			ld hl, os_word_scratch 
c5b9 cd 7c 8e			call hexout 
c5bc e1				pop hl 
c5bd 7d				ld a,l 
c5be 21 5e e6			ld hl, os_word_scratch+2 
c5c1 cd 7c 8e			call hexout 
c5c4 21 60 e6			ld hl, os_word_scratch+4 
c5c7 3e 00			ld a,0 
c5c9 77				ld (hl),a 
c5ca 11 5c e6			ld de,os_word_scratch 
c5cd 3e 28				ld a, display_row_2 
c5cf cd 61 89				call str_at_display 
c5d2 11 2c c5			ld de, .wordinhl 
c5d5 3e 00			ld a, display_row_1 
c5d7			 
c5d7 cd 61 89				call str_at_display 
c5da 11 71 ee			ld de, debug_mark 
c5dd 3e 11			ld a, display_row_1+17 
c5df			 
c5df cd 61 89				call str_at_display 
c5e2			 
c5e2				; display current data stack pointer 
c5e2 11 28 c5			ld de,.data_sp 
c5e5 3e 30				ld a, display_row_2 + 8 
c5e7 cd 61 89				call str_at_display 
c5ea			 
c5ea 2a 04 eb			ld hl,(cli_data_sp) 
c5ed e5				push hl 
c5ee 7c				ld a,h 
c5ef 21 5c e6			ld hl, os_word_scratch 
c5f2 cd 7c 8e			call hexout 
c5f5 e1				pop hl 
c5f6 7d				ld a,l 
c5f7 21 5e e6			ld hl, os_word_scratch+2 
c5fa cd 7c 8e			call hexout 
c5fd 21 60 e6			ld hl, os_word_scratch+4 
c600 3e 00			ld a,0 
c602 77				ld (hl),a 
c603 11 5c e6			ld de,os_word_scratch 
c606 3e 33				ld a, display_row_2 + 11 
c608 cd 61 89				call str_at_display 
c60b			 
c60b			 
c60b cd 71 89			call update_display 
c60e cd cb 88			call delay1s 
c611 cd cb 88			call delay1s 
c614 e1				pop hl 
c615			.skipdsp: 
c615 f1				pop af 
c616 c9				ret 
c617			 
c617			display_data_malloc: 
c617			 
c617 f5				push af 
c618 e5				push hl 
c619 e5				push hl 
c61a e5			push hl 
c61b cd 4e 89			call clear_display 
c61e e1			pop hl 
c61f 7c				ld a,h 
c620 21 5c e6			ld hl, os_word_scratch 
c623 cd 7c 8e			call hexout 
c626 e1				pop hl 
c627 7d				ld a,l 
c628 21 5e e6			ld hl, os_word_scratch+2 
c62b cd 7c 8e			call hexout 
c62e 21 60 e6			ld hl, os_word_scratch+4 
c631 3e 00			ld a,0 
c633 77				ld (hl),a 
c634 11 5c e6			ld de,os_word_scratch 
c637 3e 28				ld a, display_row_2 
c639 cd 61 89				call str_at_display 
c63c 11 62 c5			ld de, .push_malloc 
c63f 3e 00			ld a, display_row_1 
c641			 
c641 cd 61 89				call str_at_display 
c644			 
c644				; display current data stack pointer 
c644 11 28 c5			ld de,.data_sp 
c647 3e 30				ld a, display_row_2 + 8 
c649 cd 61 89				call str_at_display 
c64c			 
c64c 2a 04 eb			ld hl,(cli_data_sp) 
c64f e5				push hl 
c650 7c				ld a,h 
c651 21 5c e6			ld hl, os_word_scratch 
c654 cd 7c 8e			call hexout 
c657 e1				pop hl 
c658 7d				ld a,l 
c659 21 5e e6			ld hl, os_word_scratch+2 
c65c cd 7c 8e			call hexout 
c65f 21 60 e6			ld hl, os_word_scratch+4 
c662 3e 00			ld a,0 
c664 77				ld (hl),a 
c665 11 5c e6			ld de,os_word_scratch 
c668 3e 33				ld a, display_row_2 + 11 
c66a cd 61 89				call str_at_display 
c66d			 
c66d cd 71 89			call update_display 
c670 cd cb 88			call delay1s 
c673 cd cb 88			call delay1s 
c676 e1				pop hl 
c677 f1				pop af 
c678 c9				ret 
c679			;endif 
c679			 
c679			include "forth_autostart.asm" 
c679			; list of commands to perform at system start up 
c679			 
c679			startcmds: 
c679			;	dw test11 
c679			;	dw test12 
c679			;	dw test13 
c679			;	dw test14 
c679			;	dw test15 
c679			;	dw test16 
c679			;	dw test17 
c679			;	dw ifthtest1 
c679			;	dw ifthtest2 
c679			;	dw ifthtest3 
c679			;	dw mmtest1 
c679			;	dw mmtest2 
c679			;	dw mmtest3 
c679			;	dw mmtest4 
c679			;	dw mmtest5 
c679			;	dw mmtest6 
c679			;	dw iftest1 
c679			;	dw iftest2 
c679			;	dw iftest3 
c679			;	dw looptest1 
c679			;	dw looptest2 
c679			;	dw test1 
c679			;	dw test2 
c679			;	dw test3 
c679			;	dw test4 
c679			;	dw game2r 
c679			;	dw game2b1 
c679			;	dw game2b2 
c679			 
c679				; start up words that are actually useful 
c679			 
c679 d7 c6			dw clrstack 
c67b 0a c7			dw type 
c67d fa c8			dw stest 
c67f 2e c7			dw strncpy 
c681 90 c8			dw list 
c683 8f c7			dw start1 
c685 a1 c7			dw start2 
c687			;	dw start3 
c687 b4 c7			dw start3b 
c689 30 c8			dw start3c 
c68b			 
c68b				; (unit) testing words 
c68b			 
c68b 71 c9			dw mtesta 
c68d 26 ca			dw mtestb 
c68f c9 ca			dw mtestc 
c691 7e cb			dw mtestd 
c693 22 cc			dw mteste 
c695			 
c695				; demo/game words 
c695			 
c695 2e d3		        dw game3w 
c697 5c d3		        dw game3p 
c699 7a d3		        dw game3sc 
c69b ab d3		        dw game3vsi 
c69d d7 d3		        dw game3vs 
c69f				 
c69f 21 d1			dw game2b 
c6a1 8f d1			dw game2bf 
c6a3 d9 d1			dw game2mba 
c6a5 6f d2			dw game2mbas 
c6a7 b1 d2			dw game2mb 
c6a9			 
c6a9 e2 cd			dw game1 
c6ab f3 cd			dw game1a 
c6ad 55 ce			dw game1b 
c6af 8a ce			dw game1c 
c6b1 c0 ce			dw game1d 
c6b3 f1 ce			dw game1s 
c6b5 05 cf			dw game1t 
c6b7 1a cf			dw game1f 
c6b9 4e cf			dw game1z 
c6bb 92 cf			dw game1zz 
c6bd			 
c6bd d8 cc			dw test5 
c6bf 10 cd			dw test6 
c6c1 48 cd			dw test7 
c6c3 5c cd			dw test8 
c6c5 88 cd			dw test9 
c6c7 9e cd			dw test10 
c6c9				 
c6c9 69 d0		        dw ssv5 
c6cb 4d d0		        dw ssv4 
c6cd 31 d0		        dw ssv3 
c6cf fb cf		        dw ssv2 
c6d1 82 d0		        dw ssv1 
c6d3 ca d0		        dw ssv1cpm 
c6d5			;	dw keyup 
c6d5			;	dw keydown 
c6d5			;	dw keyleft 
c6d5			;	dw keyright 
c6d5			;	dw 	keyf1 
c6d5			;	dw keyf2 
c6d5			;	dw keyf3 
c6d5			;	dw keyf4 
c6d5			;	dw keyf5 
c6d5			;	dw keyf6 
c6d5			;	dw keyf7 
c6d5			;	dw keyf8 
c6d5			;	dw keyf9 
c6d5			;	dw keyf10 
c6d5			;	dw keyf11 
c6d5			;	dw keyf12 
c6d5			;	dw keytab 
c6d5			;	dw keycr 
c6d5			;	dw keyhome 
c6d5			;	dw keyend 
c6d5			;	dw keybs 
c6d5 00 00			db 0, 0	 
c6d7			 
c6d7			 
c6d7			; clear stack  
c6d7			 
c6d7 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c70a			 
c70a			; type ( addr count - ) 
c70a .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c72e			 
c72e			; some direct memory words 
c72e			; strncpy ( len t f -- t ) 
c72e			 
c72e .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c78f			 
c78f .. 00		start1:     	db ": bpon $0000 bp ;",0 
c7a1 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c7b4 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
c830 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c890			 
c890			 
c890			; a handy word to list items on the stack 
c890			 
c890 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
c8fa			 
c8fa			 
c8fa			; test stack  
c8fa			; rnd8 stest 
c8fa			 
c8fa .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c971			 
c971			; random malloc and free cycles 
c971			 
c971 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
ca26			 
ca26			; fixed malloc and free cycles 
ca26			 
ca26 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cac9			 
cac9			; fixed double string push and drop cycle  
cac9			 
cac9 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cb7e			 
cb7e			; consistent fixed string push and drop cycle  
cb7e			 
cb7e .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cc22			 
cc22 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ccd8			 
ccd8			;test1:		db ": aa 1 2 3 ;", 0 
ccd8			;test2:     	db "111 aa 888 999",0 
ccd8			;test3:     	db ": bb 77 ;",0 
ccd8			;test4:     	db "$02 $01 do i . loop bb",0 
ccd8			 
ccd8 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cd10 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cd48 .. 00		test7:     	db ": box hline vline ;",0 
cd5c .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cd88 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cd9e .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cdc3 .. 00		test11:     	db "hello create .",0 
cdd2 .. 00		test12:     	db "hello2 create .",0 
cde2			 
cde2			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cde2			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cde2			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cde2			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cde2			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cde2			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cde2			 
cde2			;iftest1:     	db "$0001 IF cls .",0 
cde2			;iftest2:     	db "$0000 IF cls .",0 
cde2			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cde2			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cde2			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cde2			 
cde2			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cde2			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cde2			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cde2			 
cde2			 
cde2			 
cde2			; a small guess the number game 
cde2			 
cde2 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cdf3 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ce55			 
ce55 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ce8a .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cec0 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cef1 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cf05 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cf1a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cf4e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cf92			 
cf92			; Using 'ga' save a high score across multiple runs using external storage 
cf92			 
cf92 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cffb			 
cffb			 
cffb			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cffb			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cffb			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cffb			 
cffb			; simple screen saver to test code memory reuse to destruction 
cffb			 
cffb .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d031 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d04d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d069 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d082 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d0ca .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d121			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d121			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d121			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d121			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d121			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d121			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d121			 
d121			 
d121			 
d121			; minesweeper/battleship finding game 
d121			; draws a game board of random ship/mine positions 
d121			; user enters coords to see if it hits on 
d121			; game ends when all are hit 
d121			; when hit or miss says how many may be in the area 
d121			 
d121			; setup the game board and then hide it 
d121 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d18f .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d1d9			; prompt for where to target 
d1d9 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d26f .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d294			; TODO see if the entered coords hits or misses pushes char hit of miss 
d294 .. 00		game2mbht:      db ": mbckht nop ;",0 
d2a3 .. 00		game2mbms:      db ": mbcms nop ;",0 
d2b1			; TODO how many might be near by 
d2b1 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d32e			 
d32e			; Game 3 
d32e			 
d32e			; Vert scroller ski game - avoid the trees! 
d32e			 
d32e			; v0 score (ie turns) 
d32e			; v1 player pos 
d32e			; v2 left wall 
d32e			; v3 right wall 
d32e			 
d32e			; Draw side walls randomly 
d32e			 
d32e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d35c			 
d35c			; Draw player 
d35c .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d37a			 
d37a			; TODO Get Key 
d37a			 
d37a			; TODO Move left right 
d37a			 
d37a			; scroll and move walls a bit 
d37a			 
d37a .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d3ab			 
d3ab			; main game loop 
d3ab			 
d3ab .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d3d7 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d416			 
d416			; key board defs 
d416			 
d416 .. 00		keyup:       db ": keyup $05 ;",0 
d424 .. 00		keydown:       db ": keydown $0a ;",0 
d434 .. 00		keyleft:       db ": keyleft $0b ;",0 
d444 .. 00		keyright:       db ": keyright $0c ;",0 
d455 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d463 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d471 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d47f .. 00		keyf4:       db ": keyf4 $13 ;",0 
d48d .. 00		keyf5:       db ": keyf5 $14 ;",0 
d49b .. 00		keyf6:       db ": keyf6 $15 ;",0 
d4a9 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d4b7 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d4c5 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d4d3 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d4e2 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d4f1 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d500			 
d500 .. 00		keytab:       db ": keytab $09 ;",0 
d50f .. 00		keycr:       db ": keycr $0d ;",0 
d51d .. 00		keyhome:       db ": keyhome $0e ;",0 
d52d .. 00		keyend:       db ": keyend $0f ;",0 
d53c .. 00		keybs:       db ": keybs $08 ;",0 
d54a			 
d54a			   
d54a			 
d54a			 
d54a			 
d54a			; eof 
# End of file forth_autostart.asm
d54a			 
d54a .. 00		sprompt1: db "Startup load...",0 
d55a .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d570			 
d570			 
d570			 
d570			 
d570			forth_startup: 
d570 21 79 c6			ld hl, startcmds 
d573 3e 00			ld a, 0 
d575 32 7d e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d578			 
d578 e5			.start1:	push hl 
d579 cd 4e 89			call clear_display 
d57c 11 4a d5			ld de, sprompt1 
d57f 3e 00		        ld a, display_row_1 
d581 cd 61 89			call str_at_display 
d584 11 5a d5			ld de, sprompt2 
d587 3e 28		        ld a, display_row_2 
d589 cd 61 89			call str_at_display 
d58c e1				pop hl 
d58d e5				push hl 
d58e 5e				ld e,(hl) 
d58f 23				inc hl 
d590 56				ld d,(hl) 
d591 3e 50		        ld a, display_row_3 
d593 cd 61 89			call str_at_display 
d596 cd 71 89			call update_display 
d599			 
d599			 
d599 3a 7d e7			ld a, (os_last_cmd) 
d59c fe 00			cp 0 
d59e 28 05			jr z, .startprompt 
d5a0 cd bf 88			call delay250ms 
d5a3 18 24			jr .startdo 
d5a5				 
d5a5				 
d5a5			 
d5a5			.startprompt: 
d5a5			 
d5a5 3e 9f			ld a,display_row_4 + display_cols - 1 
d5a7 11 4c 99		        ld de, endprg 
d5aa cd 61 89			call str_at_display 
d5ad cd 71 89			call update_display 
d5b0 cd cb 88			call delay1s 
d5b3 cd d6 d8			call cin_wait 
d5b6						 
d5b6 fe 2a			cp '*' 
d5b8 28 5e			jr z, .startupend1 
d5ba fe 23			cp '#' 
d5bc 20 07			jr nz, .startno 
d5be 3e 01			ld a, 1 
d5c0 32 7d e7			ld (os_last_cmd),a 
d5c3 18 04			jr .startdo 
d5c5 fe 31		.startno:	cp '1' 
d5c7 28 3a			jr z,.startnxt  
d5c9			 
d5c9				; exec startup line 
d5c9			.startdo:	 
d5c9 e1				pop hl 
d5ca e5				push hl 
d5cb				 
d5cb 5e				ld e,(hl) 
d5cc 23				inc hl 
d5cd 56				ld d,(hl) 
d5ce eb				ex de,hl 
d5cf			 
d5cf e5				push hl 
d5d0			 
d5d0 3e 00			ld a, 0 
d5d2				;ld a, FORTH_END_BUFFER 
d5d2 cd e4 8f			call strlent 
d5d5 23				inc hl   ; include zero term to copy 
d5d6 06 00			ld b,0 
d5d8 4d				ld c,l 
d5d9 e1				pop hl 
d5da 11 57 e3			ld de, scratch 
d5dd ed b0			ldir 
d5df			 
d5df			 
d5df 21 57 e3			ld hl, scratch 
d5e2 cd 8d 9d			call forthparse 
d5e5 cd cd 9d			call forthexec 
d5e8 cd e4 9c			call forthexec_cleanup 
d5eb			 
d5eb 3e 78			ld a, display_row_4 
d5ed 11 f0 96			ld de, endprog 
d5f0			 
d5f0 cd 71 89			call update_display		 
d5f3			 
d5f3 3a 7d e7			ld a, (os_last_cmd) 
d5f6 fe 00			cp 0 
d5f8 20 09			jr nz, .startnxt 
d5fa cd 4e 99			call next_page_prompt 
d5fd cd 4e 89		        call clear_display 
d600 cd 71 89			call update_display		 
d603			 
d603				; move onto next startup line? 
d603			.startnxt: 
d603			 
d603 cd bf 88			call delay250ms 
d606 e1				pop hl 
d607			 
d607 23				inc hl 
d608 23				inc hl 
d609			 
d609 e5				push hl 
d60a 5e				ld e, (hl) 
d60b 23				inc hl 
d60c 56				ld d, (hl) 
d60d e1				pop hl 
d60e				; TODO replace 0 test 
d60e			 
d60e eb				ex de, hl 
d60f cd a4 8b			call ishlzero 
d612			;	ld a,e 
d612			;	add d 
d612			;	cp 0    ; any left to do? 
d612 eb				ex de, hl 
d613 c2 78 d5			jp nz, .start1 
d616 18 01			jr .startupend 
d618			 
d618 e1			.startupend1: pop hl 
d619			.startupend: 
d619			 
d619 cd 4e 89			call clear_display 
d61c cd 71 89			call update_display 
d61f c9				ret 
d620			 
d620			 
d620			; stack over and underflow checks 
d620			 
d620			; init the words to detect the under/overflow 
d620			 
d620			chk_stk_init: 
d620				; a vague random number to check so we dont get any "lucky" hits 
d620 3e 2d			ld a, 45 
d622 6f				ld l, a 
d623 00				nop 
d624 3e 17			ld a, 23 
d626 67				ld h, a 
d627			 
d627 22 3e e3			ld (chk_word), hl     ; the word we need to check against 
d62a			 
d62a			;	ld (chk_stund), hl	; stack points.... 
d62a 22 00 ef			ld (chk_stovr), hl 
d62d 22 02 eb			ld (chk_ret_und), hl 
d630 22 c0 ea			ld (chk_ret_ovr), hl 
d633 22 be e9			ld (chk_loop_ovr), hl 
d636 22 bc e8			ld (chk_data_ovr), hl 
d639 c9				ret 
d63a				 
d63a			check_stacks: 
d63a				; check all stack words 
d63a			 
d63a e5				push hl 
d63b d5				push de 
d63c			 
d63c			;	ld de,(chk_word) 
d63c			;	ld hl, (chk_stund)	; stack points.... 
d63c			;	if DEBUG_STK_FAULT 
d63c			;		DMARK "FAa" 
d63c			;		CALLMONITOR 
d63c			;	endif 
d63c			;	call cmp16 
d63c			;	jp z, .chk_faulta 
d63c			; 
d63c			;	ld de, sfaultsu 
d63c			;	jp .chk_fault 
d63c			 
d63c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d63f ed 5b 3e e3		ld de,(chk_word) 
d643				if DEBUG_STK_FAULT 
d643					DMARK "FAb" 
d643					CALLMONITOR 
d643				endif 
d643 cd 99 8b			call cmp16 
d646 28 06			jr z, .chk_fault1 
d648 11 e9 d6			ld de, sfaultso 
d64b c3 9d d6			jp .chk_fault 
d64e			.chk_fault1:  
d64e 2a 02 eb			ld hl, (chk_ret_und) 
d651 ed 5b 3e e3		ld de,(chk_word) 
d655				if DEBUG_STK_FAULT 
d655					DMARK "FAU" 
d655					CALLMONITOR 
d655				endif 
d655 cd 99 8b			call cmp16 
d658 ca 61 d6			jp z, .chk_fault2 
d65b 11 f9 d6			ld de, sfaultru 
d65e c3 9d d6			jp .chk_fault 
d661			.chk_fault2:  
d661 2a c0 ea			ld hl, (chk_ret_ovr) 
d664 ed 5b 3e e3		ld de,(chk_word) 
d668				if DEBUG_STK_FAULT 
d668					DMARK "FA1" 
d668					CALLMONITOR 
d668				endif 
d668 cd 99 8b			call cmp16 
d66b ca 74 d6			jp z, .chk_fault3 
d66e 11 07 d7			ld de, sfaultro 
d671 c3 9d d6			jp .chk_fault 
d674			.chk_fault3:  
d674 2a be e9			ld hl, (chk_loop_ovr) 
d677 ed 5b 3e e3		ld de,(chk_word) 
d67b				if DEBUG_STK_FAULT 
d67b					DMARK "FA2" 
d67b					CALLMONITOR 
d67b				endif 
d67b cd 99 8b			call cmp16 
d67e ca 87 d6			jp z, .chk_fault4 
d681 11 21 d7			ld de, sfaultlo 
d684 c3 9d d6			jp .chk_fault 
d687			.chk_fault4:  
d687 2a bc e8			ld hl, (chk_data_ovr) 
d68a ed 5b 3e e3		ld de,(chk_word) 
d68e				if DEBUG_STK_FAULT 
d68e					DMARK "FA3" 
d68e					CALLMONITOR 
d68e				endif 
d68e cd 99 8b			call cmp16 
d691 ca 9a d6			jp z, .chk_fault5 
d694 11 3b d7			ld de, sfaultdo 
d697 c3 9d d6			jp .chk_fault 
d69a			 
d69a			 
d69a			.chk_fault5:  
d69a d1				pop de 
d69b e1				pop hl 
d69c			 
d69c c9				ret 
d69d			 
d69d cd 4e 89		.chk_fault: 	call clear_display 
d6a0 3e 28				ld a, display_row_2 
d6a2 cd 61 89				call str_at_display 
d6a5 11 cb d6				   ld de, .stackfault 
d6a8 3e 00				ld a, display_row_1 
d6aa cd 61 89				call str_at_display 
d6ad 11 71 ee				    ld de, debug_mark 
d6b0 3e 11				ld a, display_row_1+17 
d6b2 cd 61 89				call str_at_display 
d6b5 cd 71 89				call update_display 
d6b8			 
d6b8				; prompt before entering montior for investigating issue 
d6b8			 
d6b8 3e 78			ld a, display_row_4 
d6ba 11 f0 96			ld de, endprog 
d6bd			 
d6bd cd 71 89			call update_display		 
d6c0			 
d6c0 cd 4e 99			call next_page_prompt 
d6c3			 
d6c3 d1				pop de 
d6c4 e1				pop hl 
d6c5 cd 44 97				call monitor 
d6c8 c3 3e 96				jp warmstart 
d6cb					;jp 0 
d6cb					;halt 
d6cb			 
d6cb			 
d6cb			 
d6cb .. 00		.stackfault: 	db "Stack fault:",0 
d6d8			 
d6d8 .. 00		sfaultsu: 	db	"Stack under flow",0 
d6e9 .. 00		sfaultso: 	db	"Stack over flow",0 
d6f9 .. 00		sfaultru:	db "RTS underflow",0 
d707 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d721 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d73b .. 00		sfaultdo:	db "DTS overflow", 0 
d748			 
d748			 
d748			fault_dsp_under: 
d748 11 5a d7			ld de, .dsp_under 
d74b c3 0a d8			jp .show_fault 
d74e			 
d74e			fault_rsp_under: 
d74e 11 68 d7			ld de, .rsp_under 
d751 c3 0a d8			jp .show_fault 
d754			fault_loop_under: 
d754 11 76 d7			ld de, .loop_under 
d757 c3 0a d8			jp .show_fault 
d75a			 
d75a .. 00		.dsp_under: db "DSP Underflow",0 
d768 .. 00		.rsp_under: db "RSP Underflow",0 
d776 .. 00		.loop_under: db "LOOP Underflow",0 
d785			 
d785			 
d785 d5			type_faultn: 	push de 
d786 e5					push hl 
d787 cd 4e 89				call clear_display 
d78a 11 b1 d7				   ld de, .typefaultn 
d78d 3e 00				ld a, display_row_1 
d78f cd 61 89				call str_at_display 
d792 11 71 ee				    ld de, debug_mark 
d795 3e 11				ld a, display_row_1+17 
d797 cd 61 89				call str_at_display 
d79a cd 71 89				call update_display 
d79d			 
d79d				; prompt before entering montior for investigating issue 
d79d			 
d79d 3e 78			ld a, display_row_4 
d79f 11 f0 96			ld de, endprog 
d7a2			 
d7a2 cd 71 89			call update_display		 
d7a5			 
d7a5 cd 4e 99			call next_page_prompt 
d7a8			 
d7a8 e5					push hl 
d7a9 d5					push de 
d7aa cd 44 97				call monitor 
d7ad c3 3e 96				jp warmstart 
d7b0 76					halt 
d7b1			 
d7b1			 
d7b1 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d7c8			 
d7c8 d5			type_faults: 	push de 
d7c9 e5					push hl 
d7ca cd 4e 89				call clear_display 
d7cd 11 f3 d7				   ld de, .typefaults 
d7d0 3e 00				ld a, display_row_1 
d7d2 cd 61 89				call str_at_display 
d7d5 11 71 ee				    ld de, debug_mark 
d7d8 3e 11				ld a, display_row_1+17 
d7da cd 61 89				call str_at_display 
d7dd cd 71 89				call update_display 
d7e0			 
d7e0				; prompt before entering montior for investigating issue 
d7e0			 
d7e0 3e 78			ld a, display_row_4 
d7e2 11 f0 96			ld de, endprog 
d7e5			 
d7e5 cd 71 89			call update_display		 
d7e8			 
d7e8 cd 4e 99			call next_page_prompt 
d7eb			 
d7eb e1					pop hl 
d7ec d1					pop de 
d7ed cd 44 97				call monitor 
d7f0 c3 3e 96				jp warmstart 
d7f3			 
d7f3			 
d7f3 .. 00		.typefaults: db "STR Type Expected TOS!",0 
d80a			 
d80a			.show_fault: 	 
d80a d5					push de 
d80b cd 4e 89				call clear_display 
d80e d1					pop de 
d80f 3e 00				ld a, display_row_1 
d811 cd 61 89				call str_at_display 
d814 11 71 ee				    ld de, debug_mark 
d817 3e 11				ld a, display_row_1+17 
d819 cd 61 89				call str_at_display 
d81c cd 71 89				call update_display 
d81f			 
d81f				; prompt before entering montior for investigating issue 
d81f			 
d81f 3e 78			ld a, display_row_4 
d821 11 f0 96			ld de, endprog 
d824			 
d824 cd 71 89			call update_display		 
d827			 
d827 cd 4e 99			call next_page_prompt 
d82a			 
d82a e1					pop hl 
d82b d1					pop de 
d82c cd 44 97				call monitor 
d82f			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d82f			; TODO Make optional fault restart to cli or warm boot? 
d82f					;jp warmstart 
d82f c3 96 96				jp cli 
d832 76					halt 
d833			 
d833			; handle the auto run of code from files in storage 
d833			 
d833			 
d833			if STORAGE_SE 
d833			 
d833			sprompt3: db "Loading from start-up file?:",0 
d833			sprompt4: db "(Y=Any key/N=No)",0 
d833			 
d833			 
d833			forth_autoload: 
d833			 
d833				; load block 0 of store 1 
d833				 
d833				ld a, $fe      ; bit 0 clear 
d833				ld (spi_device), a 
d833			 
d833				call storage_get_block_0 
d833			 
d833				ld a, (store_page+STORE_0_AUTOFILE) 
d833			 
d833				cp 0 
d833				ret z     ; auto start not enabled 
d833			 
d833				call clear_display 
d833			 
d833				; set bank 
d833			 
d833					ld a, (store_page+STORE_0_BANKRUN) 
d833					ld (spi_device), a 
d833			 
d833				; get file id to load from and get the file name to display 
d833			 
d833					ld a, (store_page+STORE_0_FILERUN) 
d833			 
d833					ld l, 0 
d833					ld h, a 
d833					ld de, store_page 
d833			 
d833					if DEBUG_FORTH_WORDS 
d833						DMARK "ASp" 
d833						CALLMONITOR 
d833					endif 
d833					call storage_read 
d833			 
d833					if DEBUG_FORTH_WORDS 
d833						DMARK "ASr" 
d833						CALLMONITOR 
d833					endif 
d833			 
d833					call ishlzero 
d833					ret z             ; file not found 
d833			 
d833					ld a, display_row_2 + 10 
d833					ld de, store_page+3 
d833					call str_at_display 
d833				 
d833			; 
d833			 
d833				ld a, display_row_1+5 
d833				ld de, sprompt3 
d833				call str_at_display 
d833				ld a, display_row_3+15 
d833				ld de, sprompt4 
d833				call str_at_display 
d833			 
d833				call update_display 
d833			 
d833				call cin_wait 
d833				cp 'n' 
d833				ret z 
d833				cp 'N' 
d833				ret z 
d833			 
d833				call delay1s 
d833			 
d833				ld a, (store_page+2) 
d833				ld (store_openmaxext), a    ; save count of ext 
d833				ld a, 1  
d833				ld (store_openext), a    ; save count of ext 
d833			 
d833			.autof:  
d833				ld l , a 
d833				 
d833				ld a, (store_page) 
d833				ld h, a	 
d833				ld de, store_page 
d833					if DEBUG_FORTH_WORDS 
d833						DMARK "ASl" 
d833						CALLMONITOR 
d833					endif 
d833					call storage_read 
d833				call ishlzero 
d833				ret z 
d833			;	jr z, .autoend 
d833			 
d833					if DEBUG_FORTH_WORDS 
d833						DMARK "ASc" 
d833						CALLMONITOR 
d833					endif 
d833				ld de, store_page+2 
d833				ld a, display_row_4 
d833				call str_at_display 
d833			 
d833				call update_display 
d833				call delay250ms 
d833			 
d833			 
d833			 
d833				ld hl, store_page+2 
d833				call forthparse 
d833				call forthexec 
d833				call forthexec_cleanup 
d833			 
d833				 
d833				ld a, (store_openext) 
d833				inc a 
d833				ld (store_openext), a    ; save count of ext 
d833			 
d833				jr .autof 
d833			;.autofdone: 
d833			; 
d833			;		if DEBUG_FORTH_WORDS 
d833			;			DMARK "ASx" 
d833			;			CALLMONITOR 
d833			;		endif 
d833			;;	call clear_display 
d833			;	ret 
d833			 
d833			 
d833			 
d833			endif 
d833			 
d833			 
d833			; eof 
# End of file forth_kernel.asm
d833			;include "nascombasic.asm" 
d833			 
d833			 
d833			; find out where the code ends if loaded into RAM (for SC114) 
d833			;endofcode:  
d833			;	nop 
d833			 
d833			 
d833			; eof 
d833			 
# End of file main.asm
d833			;include "firmware_lcd_4x40.asm" 
d833			;;include "firmware_lcd_4x20.asm" 
d833			include "firmware_serial_display.asm" 
d833			 
d833			; Serial display interface for SC114 
d833			 
d833			 
d833			display_row_1: equ 0 
d833			display_row_2: equ display_row_1+display_cols 
d833			display_row_3: equ display_row_2 + display_cols 
d833			display_row_4: equ display_row_3 + display_cols 
d833			 
d833			kLCDWidth:  EQU display_cols             ;Width in characters 
d833			kLCD_Line1: EQU 0x00  
d833			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d833			; E1 
d833			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d833			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d833			 
d833			lcd_init: 
d833				; no init as handled by the SCM bios 
d833 c9				ret 
d834			 
d834			 
d834			; low level functions for direct screen writes 
d834			 
d834			; output char at pos? 
d834			fLCD_Str: 
d834			        ;out (SC114_SIO_1_OUT),a 
d834 c5				push bc 
d835 0e 02			ld c, $02 
d837 f7				rst $30 
d838 c1				pop bc 
d839 c9				ret 
d83a			 
d83a			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d83a			fLCD_Pos: 
d83a				; use ASCII escape to position 
d83a			        ;out (SC114_SIO_1_OUT),a 
d83a c5				push bc 
d83b 0e 02			ld c, $02 
d83d f7				rst $30 
d83e c1				pop bc 
d83f			 
d83f c9				ret 
d840			 
d840			; output char at pos 
d840			fLCD_Data: 
d840			      ;  out (SC114_SIO_1_OUT),a 
d840 c5				push bc 
d841 0e 02			ld c, $02 
d843 f7				rst $30 
d844 c1				pop bc 
d845			 
d845 c9				ret 
d846			 
d846			; ascii cls  
d846			 
d846 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d84a			 
d84a			; write the frame buffer given in hl to hardware  
d84a			write_display: 
d84a			 
d84a			API: equ 0 
d84a			 
d84a			if API 
d84a				push bc 
d84a				ld b, 4 
d84a			 
d84a			        ld (display_write_tmp), hl 	  
d84a			 
d84a				; clear and home cursor 
d84a			 
d84a				ld c, 6 
d84a				ld de, .cls 
d84a				rst $30 
d84a			 
d84a			 
d84a			.writeln: 
d84a			 
d84a				ld de, (display_write_tmp) 
d84a				ld c, 6 
d84a				rst $30 
d84a				ld c, 7 
d84a				rst $30 
d84a			 
d84a				ld hl, (display_write_tmp) 
d84a				ld de, display_cols 
d84a				add hl,de 
d84a				ld (display_write_tmp),hl 
d84a			 
d84a				djnz  .writeln 
d84a			 
d84a				pop bc 
d84a			 
d84a			 
d84a				ret 
d84a			endif 
d84a e5				push hl 
d84b c5				push bc 
d84c d5				push de 
d84d			 
d84d			;	ld c, 2 
d84d			;	;ld de, .cls 
d84d			;	ld a, 27 
d84d			;	rst $30 
d84d			;	ld c, 2 
d84d			;	;ld de, .cls 
d84d			;	ld a, '[' 
d84d			;	rst $30 
d84d			; 
d84d			;	ld c, 2 
d84d			;	;ld de, .cls 
d84d			;	ld a, 'H' 
d84d			;	rst $30 
d84d			; 
d84d			 
d84d 0e 02			ld c, 2 
d84f				;ld de, .cls 
d84f 3e 1b			ld a, 27 
d851 f7				rst $30 
d852			 
d852			 
d852 0e 02			ld c, 2 
d854				;ld de, .cls 
d854 3e 5b			ld a, '[' 
d856 f7				rst $30 
d857 0e 02			ld c, 2 
d859				;ld de, .cls 
d859 3e 32			ld a, '2' 
d85b f7				rst $30 
d85c 0e 02			ld c, 2 
d85e				;ld de, .cls 
d85e 3e 4a			ld a, 'J' 
d860 f7				rst $30 
d861 d1				pop de 
d862 c1				pop bc 
d863 e1				pop hl 
d864			 
d864			 
d864 22 cf eb		        ld (display_write_tmp), hl 	  
d867 3e 00			ld a, kLCD_Line1 
d869			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d869 06 28			ld b, display_cols 
d86b ed 5b cf eb		ld de, (display_write_tmp) 
d86f cd cd d8			call write_len_string 
d872				 
d872			 
d872 e5			push hl 
d873 d5			push de 
d874 c5			push bc 
d875 0e 07			ld c, 7 
d877 f7				rst $30 
d878 c1			pop bc 
d879 d1			pop de 
d87a e1			pop hl 
d87b			 
d87b				 
d87b 2a cf eb			ld hl, (display_write_tmp) 
d87e 11 28 00			ld de, display_cols 
d881 19				add hl,de 
d882 22 cf eb			ld (display_write_tmp),hl 
d885			 
d885				 
d885 3e 28			ld a, kLCD_Line2 
d887			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d887 06 28			ld b, display_cols 
d889 ed 5b cf eb		ld de, (display_write_tmp) 
d88d cd cd d8			call write_len_string 
d890				 
d890 2a cf eb			ld hl, (display_write_tmp) 
d893 11 28 00			ld de, display_cols 
d896 19				add hl,de 
d897 22 cf eb			ld (display_write_tmp),hl 
d89a			 
d89a e5			push hl 
d89b d5			push de 
d89c c5			push bc 
d89d 0e 07			ld c, 7 
d89f f7				rst $30 
d8a0 c1			pop bc 
d8a1 d1			pop de 
d8a2 e1			pop hl 
d8a3			 
d8a3				 
d8a3 3e 50			ld a, kLCD_Line3 
d8a5			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d8a5 06 28			ld b, display_cols 
d8a7 ed 5b cf eb		ld de, (display_write_tmp) 
d8ab cd cd d8			call write_len_string 
d8ae				 
d8ae 2a cf eb			ld hl, (display_write_tmp) 
d8b1 11 28 00			ld de, display_cols 
d8b4 19				add hl,de 
d8b5 22 cf eb			ld (display_write_tmp),hl 
d8b8			 
d8b8 e5			push hl 
d8b9 d5			push de 
d8ba c5			push bc 
d8bb 0e 07			ld c, 7 
d8bd f7				rst $30 
d8be c1			pop bc 
d8bf d1			pop de 
d8c0 e1			pop hl 
d8c1			 
d8c1				 
d8c1 3e 78			ld a, kLCD_Line4 
d8c3			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d8c3 06 28			ld b, display_cols 
d8c5 ed 5b cf eb		ld de, (display_write_tmp) 
d8c9 cd cd d8			call write_len_string 
d8cc c9					ret 
d8cd			 
d8cd			 
d8cd				; write out a fixed length string given in b from de 
d8cd			 
d8cd 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d8ce cd 40 d8		            CALL fLCD_Data      ;Write character to display 
d8d1 13				inc de 
d8d2 10 f9			djnz write_len_string 
d8d4 c9				ret 
d8d5			 
d8d5			 
d8d5			; eof 
# End of file firmware_serial_display.asm
d8d5			;include "firmware_key_5x10.asm" 
d8d5			;;include "firmware_key_4x10.asm" 
d8d5			include "firmware_key_serial.asm" 
d8d5			; Serial keyboard interface for SC114 
d8d5			 
d8d5			key_init: 
d8d5				; no init as handled by the SCM bios 
d8d5 c9				ret 
d8d6			 
d8d6			 
d8d6			cin_wait: 
d8d6			;	ld a, 0 
d8d6			;	ret 
d8d6			 
d8d6				;in a,(SC114_SIO_1_IN) 
d8d6			        ; Use SCM API to get from whatever console device we are using 
d8d6 c5				push bc 
d8d7 0e 01			ld c, $01 
d8d9 f7				rst $30 
d8da c1				pop bc 
d8db c9				ret 
d8dc			 
d8dc			cin: 
d8dc			 
d8dc			 
d8dc c5				push bc 
d8dd			 
d8dd				; any key waiting to process? 
d8dd 0e 03			ld c, $03 
d8df f7				rst $30 
d8e0 28 05			jr z, .cin_skip 
d8e2			 
d8e2				; yep, get it 
d8e2			 
d8e2 0e 01			ld c, $01 
d8e4 f7				rst $30 
d8e5 c1				pop bc 
d8e6 c9				ret 
d8e7			.cin_skip: 
d8e7 3e 00			ld a, 0 
d8e9 c1				pop bc 
d8ea c9				ret 
d8eb			 
d8eb			 
d8eb			 
d8eb			 
# End of file firmware_key_serial.asm
d8eb			endofcode:  
d8eb			baseram:  
d8eb 00				nop 
d8ec			 
d8ec			heap_start: equ baseram+15  ; Starting address of heap 
d8ec			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d8ec			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d8ec			;VDU:  EQU     endofcode           ; BASIC Work space 
d8ec			; eof 
d8ec			 
# End of file os_mega_sc114.asm
d8ec
