# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 43 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		.buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 0  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 72 0a				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 72 0a				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 72 0a				call clear_display  
0137			  
0137			  
0137 cd 68 59				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 56 5a			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 42 11				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd 95 0a			call update_display  
0146 cd e4 09			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 77 0a			call fill_display  
014e cd 95 0a			call update_display  
0151 cd e4 09			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 77 0a			call fill_display  
0159 cd 95 0a			call update_display  
015c cd e4 09			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 77 0a			call fill_display  
0164 cd 95 0a			call update_display  
0167 cd e4 09			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 76 16			ld de, prom_bootmsg  
016f cd 85 0a			call str_at_display  
0172 cd 95 0a			call update_display  
0175			  
0175			  
0175 cd e4 09			call delay1s  
0178 cd e4 09			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 8b 16			ld de, prom_bootmsg1  
0180 cd 85 0a			call str_at_display  
0183 cd 95 0a			call update_display  
0186 cd e4 09			call delay1s  
0189 cd e4 09			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 5a eb			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd a0 14			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 5c eb			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd a0 14			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 5c eb				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd a0 14			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd c8 0c				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 5a eb				ld hl, (store_tmp1) 
0210 11 5f eb				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd a0 14			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 35 11				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd a0 14			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd a0 14			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd a0 14			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd a0 14			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd c8 0c			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 5c eb			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd a0 14			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd a0 14			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 5c eb			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 5c eb				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd a0 14			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 5d eb			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd a0 14			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd a0 14			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd a7 09			call storage_clear_page 
039b			 
039b 21 5c eb			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 5d eb		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 5f eb		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 68 eb			ld hl, store_page+3+9 
03b5 3a 41 eb			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 5c eb			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd a0 14			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd a0 14			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd c9 09			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd c9 09			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd 9f 0c				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd c9 09			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd c9 09			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd 9f 0c				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd a0 14			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 5f eb		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd a0 14			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 5c eb			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd a0 14			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd a0 14			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd c8 0c			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 5c eb			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd c8 0c			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd a0 14			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 5c eb			ld a, (store_page)	; get file id 
0510 32 55 eb			ld (store_tmpid), a 
0513			 
0513 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
0516 32 54 eb			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 5c eb			ld (store_page), a 
051f 32 5d eb			ld (store_page+1),a 
0522 11 5c eb			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd a0 14			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 54 eb			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 55 eb			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd a0 14			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd c8 0c			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 5c eb			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 5c eb			ld (store_page), a 
0582 32 5d eb			ld (store_page+1),a 
0585 11 5c eb			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd a0 14			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd a0 14			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd bd 0c				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd 9f 0c				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd bd 0c				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd 9f 0c				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd a0 14			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd a0 14			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd 9f 0c				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd 9f 0c				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd a0 14			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 5c eb			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 5c eb			ld (store_page),a 
06a3				 
06a3 32 55 eb			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 5c eb			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd a0 14			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 5c eb				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd a0 14			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd a0 14			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 46 eb			ld (store_tmppageid), hl 
0715				 
0715 3a 55 eb			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 5c eb			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 5d eb			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 5e eb			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd a0 14			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 08 11			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd a0 14			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd a0 14			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 46 eb			ld hl,(store_tmppageid) 
078b 11 5c eb			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd a0 14			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 55 eb			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd a0 14			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5 21 40 00			ld hl, STORE_BLOCK_PHY 
07d8				if DEBUG_STORESE 
07d8					DMARK "SRE" 
07d8 f5				push af  
07d9 3a ed 07			ld a, (.dmark)  
07dc 32 71 ee			ld (debug_mark),a  
07df 3a ee 07			ld a, (.dmark+1)  
07e2 32 72 ee			ld (debug_mark+1),a  
07e5 3a ef 07			ld a, (.dmark+2)  
07e8 32 73 ee			ld (debug_mark+2),a  
07eb 18 03			jr .pastdmark  
07ed ..			.dmark: db "SRE"  
07f0 f1			.pastdmark: pop af  
07f1			endm  
# End of macro DMARK
07f1					CALLMONITOR 
07f1 cd a0 14			call break_point_state  
07f4				endm  
# End of macro CALLMONITOR
07f4				endif 
07f4 cd ac 05			call storage_findnextid 
07f7			 
07f7				if DEBUG_STORESE 
07f7					DMARK "SRf" 
07f7 f5				push af  
07f8 3a 0c 08			ld a, (.dmark)  
07fb 32 71 ee			ld (debug_mark),a  
07fe 3a 0d 08			ld a, (.dmark+1)  
0801 32 72 ee			ld (debug_mark+1),a  
0804 3a 0e 08			ld a, (.dmark+2)  
0807 32 73 ee			ld (debug_mark+2),a  
080a 18 03			jr .pastdmark  
080c ..			.dmark: db "SRf"  
080f f1			.pastdmark: pop af  
0810			endm  
# End of macro DMARK
0810					CALLMONITOR 
0810 cd a0 14			call break_point_state  
0813				endm  
# End of macro CALLMONITOR
0813				endif 
0813 cd c8 0c			call ishlzero 
0816			;	ld a, l 
0816			;	add h 
0816			;	cp 0 
0816 28 b8			jr z,.sr_fail			; block not found so EOF 
0818			 
0818				; hl contains page number to load 
0818 d1				pop de   ; get storage 
0819 d5				push de 
081a				if DEBUG_STORESE 
081a					DMARK "SRg" 
081a f5				push af  
081b 3a 2f 08			ld a, (.dmark)  
081e 32 71 ee			ld (debug_mark),a  
0821 3a 30 08			ld a, (.dmark+1)  
0824 32 72 ee			ld (debug_mark+1),a  
0827 3a 31 08			ld a, (.dmark+2)  
082a 32 73 ee			ld (debug_mark+2),a  
082d 18 03			jr .pastdmark  
082f ..			.dmark: db "SRg"  
0832 f1			.pastdmark: pop af  
0833			endm  
# End of macro DMARK
0833					CALLMONITOR 
0833 cd a0 14			call break_point_state  
0836				endm  
# End of macro CALLMONITOR
0836				endif 
0836 cd 79 02			call storage_read_block 
0839			 
0839			 
0839			; TODO if block has no zeros then need to read next block  
0839			 
0839			 
0839					 
0839 e1				pop hl 		 ; return start of data to show as not EOF 
083a 23				inc hl   ; past file id 
083b 23				inc hl   ; past ext 
083c				if DEBUG_STORESE 
083c					DMARK "SRe" 
083c f5				push af  
083d 3a 51 08			ld a, (.dmark)  
0840 32 71 ee			ld (debug_mark),a  
0843 3a 52 08			ld a, (.dmark+1)  
0846 32 72 ee			ld (debug_mark+1),a  
0849 3a 53 08			ld a, (.dmark+2)  
084c 32 73 ee			ld (debug_mark+2),a  
084f 18 03			jr .pastdmark  
0851 ..			.dmark: db "SRe"  
0854 f1			.pastdmark: pop af  
0855			endm  
# End of macro DMARK
0855					CALLMONITOR 
0855 cd a0 14			call break_point_state  
0858				endm  
# End of macro CALLMONITOR
0858				endif 
0858 c9					ret 
0859			 
0859			 
0859			 
0859			; 
0859			; Append File 
0859			; 
0859			; hl - file id to locate 
0859			; de - pointer to (multi block) string to write 
0859			 
0859			.sa_notfound: 
0859 d1				pop de 
085a c9				ret 
085b			 
085b			 
085b			storage_append: 
085b				; hl -  file id to append to 
085b				; de - string to append 
085b			 
085b d5				push de 
085c				 
085c				if DEBUG_STORESE 
085c					DMARK "AP1" 
085c f5				push af  
085d 3a 71 08			ld a, (.dmark)  
0860 32 71 ee			ld (debug_mark),a  
0863 3a 72 08			ld a, (.dmark+1)  
0866 32 72 ee			ld (debug_mark+1),a  
0869 3a 73 08			ld a, (.dmark+2)  
086c 32 73 ee			ld (debug_mark+2),a  
086f 18 03			jr .pastdmark  
0871 ..			.dmark: db "AP1"  
0874 f1			.pastdmark: pop af  
0875			endm  
# End of macro DMARK
0875					CALLMONITOR 
0875 cd a0 14			call break_point_state  
0878				endm  
# End of macro CALLMONITOR
0878				endif 
0878			 
0878 7d				ld a, l 
0879 32 55 eb			ld (store_tmpid), a 
087c			 
087c				; get file header  
087c			 
087c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
087e 3a 55 eb			ld a, (store_tmpid) 
0881 5f				ld e, a 
0882			 
0882 21 40 00				ld hl, STORE_BLOCK_PHY 
0885 cd ac 05				call storage_findnextid 
0888			 
0888 cd c8 0c			call ishlzero 
088b 28 cc			jr z, .sa_notfound 
088d			 
088d 22 46 eb			ld (store_tmppageid), hl 
0890			 
0890				; TODO handle file id not found 
0890			 
0890				if DEBUG_STORESE 
0890					DMARK "AP2" 
0890 f5				push af  
0891 3a a5 08			ld a, (.dmark)  
0894 32 71 ee			ld (debug_mark),a  
0897 3a a6 08			ld a, (.dmark+1)  
089a 32 72 ee			ld (debug_mark+1),a  
089d 3a a7 08			ld a, (.dmark+2)  
08a0 32 73 ee			ld (debug_mark+2),a  
08a3 18 03			jr .pastdmark  
08a5 ..			.dmark: db "AP2"  
08a8 f1			.pastdmark: pop af  
08a9			endm  
# End of macro DMARK
08a9					CALLMONITOR 
08a9 cd a0 14			call break_point_state  
08ac				endm  
# End of macro CALLMONITOR
08ac				endif 
08ac			 
08ac				; update file extent count 
08ac			 
08ac 11 5c eb			ld de, store_page 
08af			 
08af cd 79 02			call storage_read_block 
08b2			 
08b2				if DEBUG_STORESE 
08b2					DMARK "AP3" 
08b2 f5				push af  
08b3 3a c7 08			ld a, (.dmark)  
08b6 32 71 ee			ld (debug_mark),a  
08b9 3a c8 08			ld a, (.dmark+1)  
08bc 32 72 ee			ld (debug_mark+1),a  
08bf 3a c9 08			ld a, (.dmark+2)  
08c2 32 73 ee			ld (debug_mark+2),a  
08c5 18 03			jr .pastdmark  
08c7 ..			.dmark: db "AP3"  
08ca f1			.pastdmark: pop af  
08cb			endm  
# End of macro DMARK
08cb					CALLMONITOR 
08cb cd a0 14			call break_point_state  
08ce				endm  
# End of macro CALLMONITOR
08ce				endif 
08ce			;	ld (store_tmppageid), hl 
08ce			 
08ce 3a 5e eb			ld a, (store_page+2) 
08d1 3c				inc a 
08d2 32 5e eb			ld (store_page+2), a 
08d5 32 54 eb			ld (store_tmpext), a 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP3" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 71 ee			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 72 ee			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 73 ee			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP3"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd a0 14			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4 2a 46 eb			ld hl, (store_tmppageid) 
08f7 11 5c eb			ld de, store_page 
08fa cd de 02			call storage_write_block 
08fd			 
08fd				; find free block 
08fd			 
08fd 11 00 00			ld de, 0			 ; file extent to locate 
0900			 
0900 21 40 00				ld hl, STORE_BLOCK_PHY 
0903 cd ac 05				call storage_findnextid 
0906 cd c8 0c			call ishlzero 
0909 ca 59 08			jp z, .sa_notfound 
090c			 
090c					; TODO handle no space left 
090c					 
090c 22 46 eb				ld (store_tmppageid), hl 
090f			 
090f				if DEBUG_STORESE 
090f					DMARK "AP4" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 71 ee			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 72 ee			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 73 ee			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "AP4"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd a0 14			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b					; init the buffer with zeros so we can id if the buffer is full or not 
092b			 
092b e5					push hl 
092c c5					push bc 
092d			 
092d 21 5c eb				ld hl, store_page 
0930 06 40				ld b, STORE_BLOCK_PHY 
0932 3e 00				ld a, 0 
0934 77			.zeroblock:	ld (hl), a 
0935 23					inc hl 
0936 10 fc				djnz .zeroblock 
0938			 
0938 c1					pop bc 
0939 e1					pop hl 
093a			 
093a					; construct block 
093a			 
093a 3a 55 eb				ld a, (store_tmpid) 
093d 32 5c eb				ld (store_page), a   ; file id 
0940 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
0943 32 5d eb				ld (store_page+1), a 
0946			 
0946 e1					pop hl    ; get string to write 
0947 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0949 11 5e eb				ld de, store_page+2 
094c			 
094c				if DEBUG_STORESE 
094c					DMARK "AP5" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 71 ee			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 72 ee			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 73 ee			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP5"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd a0 14			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968			 
0968			 
0968			 
0968					; fill buffer with data until end of string or full block 
0968			 
0968 7e			.appd:		ld a, (hl) 
0969 12					ld (de), a 
096a fe 00				cp 0 
096c 28 04				jr z, .appdone 
096e 23					inc hl 
096f 13					inc de 
0970 10 f6				djnz .appd 
0972			 
0972 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0973 f5					push af   		; save last byte dumped 
0974			 
0974			 
0974 2a 46 eb			ld hl, (store_tmppageid) 
0977 11 5c eb			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "AP6" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 71 ee			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 72 ee			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 73 ee			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "AP6"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					CALLMONITOR 
0993 cd a0 14			call break_point_state  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd de 02				call storage_write_block 
0999			 
0999			 
0999				; was that a full block of data written? 
0999				; any more to write out? 
0999			 
0999				; if yes then set vars and jump to start of function again 
0999			 
0999 f1					pop af 
099a d1					pop de 
099b			 
099b fe 00				cp 0		 ; no, string was fully written 
099d c8					ret z 
099e			 
099e					; setup vars for next cycle 
099e			 
099e 3a 55 eb				ld a, (store_tmpid) 
09a1 6f					ld l, a 
09a2 26 00				ld h, 0 
09a4			 
09a4 c3 5b 08			 	jp storage_append	 ; yes, need to write out some more 
09a7			 
09a7			 
09a7			 
09a7			 
09a7			 
09a7			 
09a7			 
09a7			if DEBUG_STORECF 
09a7			storageput:	 
09a7					ret 
09a7			storageread: 
09a7					ld hl, store_page 
09a7					ld b, 200 
09a7					ld a,0 
09a7			.src:		ld (hl),a 
09a7					inc hl 
09a7					djnz .src 
09a7					 
09a7			 
09a7					ld de, 0 
09a7					ld bc, 1 
09a7					ld hl, store_page 
09a7					call cfRead 
09a7			 
09a7				call cfGetError 
09a7				ld hl,scratch 
09a7				call hexout 
09a7				ld hl, scratch+2 
09a7				ld a, 0 
09a7				ld (hl),a 
09a7				ld de, scratch 
09a7				ld a,display_row_1 
09a7				call str_at_display 
09a7				call update_display 
09a7			 
09a7					ld hl, store_page 
09a7					ld (os_cur_ptr),hl 
09a7			 
09a7					ret 
09a7			endif 
09a7			 
09a7			 
09a7			; Clear out the main buffer store (used to remove junk before writing a new block) 
09a7			 
09a7			storage_clear_page: 
09a7 e5				push hl 
09a8 d5				push de 
09a9 c5				push bc 
09aa 21 5c eb			ld hl, store_page 
09ad 3e 00			ld a, 0 
09af 77				ld (hl), a 
09b0			 
09b0 11 5d eb			ld de, store_page+1 
09b3 01 40 00			ld bc, STORE_BLOCK_PHY 
09b6			 
09b6 ed b0			ldir 
09b8				 
09b8 c1				pop bc 
09b9 d1				pop de 
09ba e1				pop hl 
09bb c9				ret 
09bc			 
09bc			; eof 
# End of file firmware_storage.asm
09bc			  
09bc			; support routines for above hardware abstraction layer  
09bc			  
09bc			include "firmware_general.asm"        ; general support functions  
09bc			 
09bc			; word look up 
09bc			 
09bc			; in 
09bc			; a is the index 
09bc			; hl is pointer start of array 
09bc			; 
09bc			; returns 
09bc			; hl to the word 
09bc			; 
09bc			 
09bc			table_lookup:  
09bc d5					push de 
09bd eb					ex de, hl 
09be			 
09be 6f					ld l, a 
09bf 26 00				ld h, 0 
09c1 29					add hl, hl 
09c2 19					add hl, de 
09c3 7e					ld a, (hl) 
09c4 23					inc hl 
09c5 66					ld h,(hl) 
09c6 6f					ld l, a 
09c7			 
09c7 d1					pop de 
09c8 c9					ret 
09c9			 
09c9			; Delay loops 
09c9			 
09c9			 
09c9			 
09c9			aDelayInMS: 
09c9 c5				push bc 
09ca 47				ld b,a 
09cb			msdelay: 
09cb c5				push bc 
09cc				 
09cc			 
09cc 01 41 00			ld bc,041h 
09cf cd e7 09			call delayloop 
09d2 c1				pop bc 
09d3 05				dec b 
09d4 20 f5			jr nz,msdelay 
09d6			 
09d6			;if CPU_CLOCK_8MHZ 
09d6			;msdelay8: 
09d6			;	push bc 
09d6			;	 
09d6			; 
09d6			;	ld bc,041h 
09d6			;	call delayloop 
09d6			;	pop bc 
09d6			;	dec b 
09d6			;	jr nz,msdelay8 
09d6			;endif 
09d6			 
09d6			 
09d6 c1				pop bc 
09d7 c9				ret 
09d8			 
09d8			 
09d8			delay250ms: 
09d8				;push de 
09d8 01 00 40			ld bc, 04000h 
09db c3 e7 09			jp delayloop 
09de			delay500ms: 
09de				;push de 
09de 01 00 80			ld bc, 08000h 
09e1 c3 e7 09			jp delayloop 
09e4			delay1s: 
09e4				;push bc 
09e4			   ; Clobbers A, d and e 
09e4 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
09e7			delayloop: 
09e7 c5			    push bc 
09e8			 
09e8			if BASE_CPM 
09e8 01 a0 0f			ld bc, CPM_DELAY_TUNE 
09eb			.cpmloop: 
09eb c5				push bc 
09ec			 
09ec			endif 
09ec			 
09ec			 
09ec			 
09ec			delayloopi: 
09ec			;	push bc 
09ec			;.dl: 
09ec cb 47		    bit     0,a    	; 8 
09ee cb 47		    bit     0,a    	; 8 
09f0 cb 47		    bit     0,a    	; 8 
09f2 e6 ff		    and     255  	; 7 
09f4 0b			    dec     bc      	; 6 
09f5 79			    ld      a,c     	; 4 
09f6 b0			    or      b     	; 4 
09f7 c2 ec 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
09fa			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
09fa				;pop de 
09fa			;pop bc 
09fa			 
09fa			if BASE_CPM 
09fa c1				pop bc 
09fb				 
09fb 0b			    dec     bc      	; 6 
09fc 79			    ld      a,c     	; 4 
09fd b0			    or      b     	; 4 
09fe c2 eb 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a01				 
0a01			 
0a01			endif 
0a01			;if CPU_CLOCK_8MHZ 
0a01			;    pop bc 
0a01			;    push bc 
0a01			;.dl8: 
0a01			;    bit     0,a    	; 8 
0a01			;    bit     0,a    	; 8 
0a01			;    bit     0,a    	; 8 
0a01			;    and     255  	; 7 
0a01			;    dec     bc      	; 6 
0a01			;    ld      a,c     	; 4 
0a01			;    or      b     	; 4 
0a01			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a01			;endif 
0a01			 
0a01			;if CPU_CLOCK_10MHZ 
0a01			;    pop bc 
0a01			;    push bc 
0a01			;.dl8: 
0a01			;    bit     0,a    	; 8 
0a01			;    bit     0,a    	; 8 
0a01			;    bit     0,a    	; 8 
0a01			;    and     255  	; 7 
0a01			;    dec     bc      	; 6 
0a01			;    ld      a,c     	; 4 
0a01			;    or      b     	; 4 
0a01			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a01			;endif 
0a01 c1			    pop bc 
0a02			 
0a02 c9				ret 
0a03			 
0a03			 
0a03			 
0a03			; eof 
# End of file firmware_general.asm
0a03			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a03			; display routines that use the physical hardware abstraction layer 
0a03			 
0a03			 
0a03			; information window 
0a03			 
0a03			; pass hl with 1st string to display 
0a03			; pass de with 2nd string to display 
0a03			 
0a03			info_panel: 
0a03 e5				push hl 
0a04			 
0a04 2a d2 eb			ld hl, (display_fb_active) 
0a07 e5				push hl    ; future de destination 
0a08 21 b7 ed				ld hl, display_fb0 
0a0b 22 d2 eb				ld (display_fb_active), hl 
0a0e			 
0a0e			;	call clear_display 
0a0e			 
0a0e				if BASE_CPM 
0a0e 3e 2e			ld a, '.' 
0a10				else 
0a10				ld a, 165 
0a10				endif 
0a10 cd 77 0a			call fill_display 
0a13			 
0a13			 
0a13 3e 55			ld a, display_row_3 + 5 
0a15 cd 85 0a			call str_at_display 
0a18			 
0a18 e1				pop hl 
0a19 d1				pop de 
0a1a			 
0a1a e5				push hl 
0a1b			 
0a1b			 
0a1b 3e 2d			ld a, display_row_2 + 5 
0a1d cd 85 0a			call str_at_display 
0a20			 
0a20			 
0a20 cd 95 0a			call update_display 
0a23 cd 83 1a			call next_page_prompt 
0a26 cd 72 0a			call clear_display 
0a29			 
0a29				 
0a29 21 16 ed				ld hl, display_fb1 
0a2c 22 d2 eb				ld (display_fb_active), hl 
0a2f cd 95 0a			call update_display 
0a32			 
0a32 e1				pop hl 
0a33			 
0a33 c9				ret 
0a34			 
0a34			 
0a34			 
0a34			 
0a34			; TODO windowing? 
0a34			 
0a34			; TODO scroll line up 
0a34			 
0a34			scroll_up: 
0a34			 
0a34 e5				push hl 
0a35 d5				push de 
0a36 c5				push bc 
0a37			 
0a37				; get frame buffer  
0a37			 
0a37 2a d2 eb			ld hl, (display_fb_active) 
0a3a e5				push hl    ; future de destination 
0a3b			 
0a3b 11 28 00			ld  de, display_cols 
0a3e 19				add hl, de 
0a3f			 
0a3f d1				pop de 
0a40			 
0a40				;ex de, hl 
0a40 01 9f 00			ld bc, display_fb_len -1  
0a43			;if DEBUG_FORTH_WORDS 
0a43			;	DMARK "SCL" 
0a43			;	CALLMONITOR 
0a43			;endif	 
0a43 ed b0			ldir 
0a45			 
0a45				; wipe bottom row 
0a45			 
0a45			 
0a45 2a d2 eb			ld hl, (display_fb_active) 
0a48 11 a0 00			ld de, display_cols*display_rows 
0a4b 19				add hl, de 
0a4c 06 28			ld b, display_cols 
0a4e 3e 20			ld a, ' ' 
0a50			.scwipe: 
0a50 77				ld (hl), a 
0a51 2b				dec hl 
0a52 10 fc			djnz .scwipe 
0a54			 
0a54				;pop hl 
0a54			 
0a54 c1				pop bc 
0a55 d1				pop de 
0a56 e1				pop hl 
0a57			 
0a57 c9				ret 
0a58			 
0a58			 
0a58			;scroll_upo: 
0a58			;	ld de, display_row_1 
0a58			 ;	ld hl, display_row_2 
0a58			;	ld bc, display_cols 
0a58			;	ldir 
0a58			;	ld de, display_row_2 
0a58			 ;	ld hl, display_row_3 
0a58			;	ld bc, display_cols 
0a58			;	ldir 
0a58			;	ld de, display_row_3 
0a58			 ;	ld hl, display_row_4 
0a58			;	ld bc, display_cols 
0a58			;	ldir 
0a58			 
0a58			; TODO clear row 4 
0a58			 
0a58			;	ret 
0a58			 
0a58				 
0a58			scroll_down: 
0a58			 
0a58 e5				push hl 
0a59 d5				push de 
0a5a c5				push bc 
0a5b			 
0a5b				; get frame buffer  
0a5b			 
0a5b 2a d2 eb			ld hl, (display_fb_active) 
0a5e			 
0a5e 11 9f 00			ld de, display_fb_len - 1 
0a61 19				add hl, de 
0a62			 
0a62 e5			push hl    ; future de destination 
0a63			 
0a63 11 28 00			ld  de, display_cols 
0a66 ed 52			sbc hl, de 
0a68			 
0a68			 
0a68 d1				pop de 
0a69			 
0a69			;	ex de, hl 
0a69 01 9f 00			ld bc, display_fb_len -1  
0a6c			 
0a6c			 
0a6c				 
0a6c			 
0a6c ed b0			ldir 
0a6e			 
0a6e				; wipe bottom row 
0a6e			 
0a6e			 
0a6e			;	ld hl, (display_fb_active) 
0a6e			;;	ld de, display_cols*display_rows 
0a6e			;;	add hl, de 
0a6e			;	ld b, display_cols 
0a6e			;	ld a, ' ' 
0a6e			;.scwiped: 
0a6e			;	ld (hl), a 
0a6e			;	dec hl 
0a6e			;	djnz .scwiped 
0a6e			 
0a6e				;pop hl 
0a6e			 
0a6e c1				pop bc 
0a6f d1				pop de 
0a70 e1				pop hl 
0a71			 
0a71 c9				ret 
0a72			;scroll_down: 
0a72			;	ld de, display_row_4 
0a72			;	ld hl, display_row_3 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			;	ld de, display_row_3 
0a72			; 	ld hl, display_row_2 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			;	ld de, display_row_2 
0a72			;	ld hl, display_row_1 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			;;; TODO clear row 1 
0a72			;	ret 
0a72			 
0a72			 
0a72			 
0a72			 
0a72			 
0a72			; clear active frame buffer 
0a72			 
0a72			clear_display: 
0a72 3e 20			ld a, ' ' 
0a74 c3 77 0a			jp fill_display 
0a77			 
0a77			; fill active frame buffer with a char in A 
0a77			 
0a77			fill_display: 
0a77 06 a0			ld b,display_fb_len 
0a79 2a d2 eb			ld hl, (display_fb_active) 
0a7c 77			.fd1:	ld (hl),a 
0a7d 23				inc hl 
0a7e 10 fc			djnz .fd1 
0a80 23				inc hl 
0a81 3e 00			ld a,0 
0a83 77				ld (hl),a 
0a84			 
0a84			 
0a84 c9				ret 
0a85			; Write string (DE) at pos (A) to active frame buffer 
0a85			 
0a85 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0a88 06 00					ld b,0 
0a8a 4f					ld c,a 
0a8b 09					add hl,bc 
0a8c 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0a8d b7			            OR   A              ;Null terminator? 
0a8e c8			            RET  Z              ;Yes, so finished 
0a8f 77					ld (hl),a 
0a90 23				inc hl 
0a91 13			            INC  DE             ;Point to next character 
0a92 18 f8		            JR   .sad1     ;Repeat 
0a94 c9					ret 
0a95			 
0a95			; using current frame buffer write to physical display 
0a95			 
0a95			update_display: 
0a95 e5				push hl 
0a96 2a d2 eb			ld hl, (display_fb_active) 
0a99 cd a5 59			call write_display 
0a9c e1				pop hl 
0a9d c9				ret 
0a9e			 
0a9e			; TODO scrolling 
0a9e			 
0a9e			 
0a9e			; move cursor right one char 
0a9e			cursor_right: 
0a9e			 
0a9e				; TODO shift right 
0a9e				; TODO if beyond max col 
0a9e				; TODO       cursor_next_line 
0a9e			 
0a9e c9				ret 
0a9f			 
0a9f			 
0a9f			cursor_next_line: 
0a9f				; TODO first char 
0a9f				; TODO line down 
0a9f				; TODO if past last row 
0a9f				; TODO    scroll up 
0a9f			 
0a9f c9				ret 
0aa0			 
0aa0			cursor_left: 
0aa0				; TODO shift left 
0aa0				; TODO if beyond left  
0aa0				; TODO     cursor prev line 
0aa0				 
0aa0 c9				ret 
0aa1			 
0aa1			cursor_prev_line: 
0aa1				; TODO last char 
0aa1				; TODO line up 
0aa1				; TODO if past first row 
0aa1				; TODO   scroll down 
0aa1			 
0aa1 c9				ret 
0aa2			 
0aa2			 
0aa2			cout: 
0aa2				; A - char 
0aa2 c9				ret 
0aa3			 
0aa3			 
0aa3			; Display a menu and allow item selection (optional toggle items) 
0aa3			; 
0aa3			; format: 
0aa3			; hl pointer to word array with zero term for items 
0aa3			; e.g.    db item1 
0aa3			;         db .... 
0aa3			;         db 0 
0aa3			; 
0aa3			; a = starting menu item  
0aa3			; 
0aa3			; de = pointer item toggle array   (todo) 
0aa3			; 
0aa3			; returns item selected in a 1-... 
0aa3			; returns 0 if back button pressed 
0aa3			; 
0aa3			; NOTE: Uses system frame buffer to display 
0aa3			; 
0aa3			; LEFT, Q = go back 
0aa3			; RIGHT, SPACE, CR = select 
0aa3			; UP, A - Up 
0aa3			; DOWN, Z - Down 
0aa3			 
0aa3			 
0aa3			 
0aa3			 
0aa3			 
0aa3			menu: 
0aa3			 
0aa3					; keep array pointer 
0aa3			 
0aa3 22 5a eb				ld (store_tmp1), hl 
0aa6 32 58 eb				ld (store_tmp2), a 
0aa9			 
0aa9					; check for key bounce 
0aa9			 
0aa9			if BASE_KEV 
0aa9			 
0aa9			.mbounce:	call cin 
0aa9					cp 0 
0aa9					jr nz, .mbounce 
0aa9			endif 
0aa9					; for ease use ex 
0aa9			 
0aa9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0aa9 21 b7 ed				ld hl, display_fb0 
0aac 22 d2 eb				ld (display_fb_active), hl 
0aaf			 
0aaf cd 72 0a		.mloop:		call clear_display 
0ab2 cd 95 0a				call update_display 
0ab5			 
0ab5					; draw selection id '>' at 1 
0ab5			 
0ab5					; init start of list display 
0ab5			 
0ab5 3e 05				ld a, 5 
0ab7 32 56 eb				ld (store_tmp3), a   ; display row count 
0aba 3a 58 eb				ld a,( store_tmp2) 
0abd 32 59 eb				ld (store_tmp2+1), a   ; display item count 
0ac0			 
0ac0					 
0ac0			.mitem:	 
0ac0			 
0ac0			 
0ac0 3a 59 eb				ld a,(store_tmp2+1) 
0ac3 6f					ld l, a 
0ac4 26 00				ld h, 0 
0ac6 29					add hl, hl 
0ac7 ed 5b 5a eb			ld de, (store_tmp1) 
0acb 19					add hl, de 
0acc 7e					ld a, (hl) 
0acd 23					inc hl 
0ace 66					ld h,(hl) 
0acf 6f					ld l, a 
0ad0			 
0ad0 cd c8 0c				call ishlzero 
0ad3 28 1a				jr z, .mdone 
0ad5			 
0ad5 eb					ex de, hl 
0ad6 3a 56 eb				ld a, (store_tmp3) 
0ad9 cd 85 0a				call str_at_display 
0adc					 
0adc			 
0adc					; next item 
0adc 3a 59 eb				ld a, (store_tmp2+1) 
0adf 3c					inc a 
0ae0 32 59 eb				ld (store_tmp2+1), a   ; display item count 
0ae3			 
0ae3			 		; next row 
0ae3			 
0ae3 3a 56 eb				ld a, (store_tmp3) 
0ae6 c6 28				add display_cols 
0ae8 32 56 eb				ld (store_tmp3), a 
0aeb			 
0aeb					; at end of screen? 
0aeb			 
0aeb fe 10				cp display_rows*4 
0aed 20 d1				jr nz, .mitem 
0aef			 
0aef			 
0aef			.mdone: 
0aef cd c8 0c				call ishlzero 
0af2 28 08				jr z, .nodn 
0af4			 
0af4 3e 78				ld a, display_row_4 
0af6 11 75 0b				ld de, .mdown 
0af9 cd 85 0a				call str_at_display 
0afc			 
0afc					; draw options to fill the screens with active item on line 1 
0afc					; if current option is 2 or more then display ^ in top 
0afc			 
0afc 3a 58 eb		.nodn:		ld a, (store_tmp2) 
0aff fe 00				cp 0 
0b01 28 08				jr z, .noup 
0b03			 
0b03 3e 00				ld a, 0 
0b05 11 73 0b				ld de, .mup 
0b08 cd 85 0a				call str_at_display 
0b0b			 
0b0b 3e 02		.noup:		ld a, 2 
0b0d 11 71 0b				ld de, .msel 
0b10 cd 85 0a				call str_at_display 
0b13			 
0b13					; if current option + 1 is not null then display V in bottom 
0b13					; get key 
0b13 cd 95 0a				call update_display 
0b16			 
0b16			 
0b16					; handle key 
0b16			 
0b16 cd 57 5a				call cin_wait 
0b19			 
0b19 fe 05				cp KEY_UP 
0b1b 28 2b				jr z, .mgoup 
0b1d fe 61				cp 'a' 
0b1f 28 27				jr z, .mgoup 
0b21 fe 0a				cp KEY_DOWN 
0b23 28 32				jr z, .mgod 
0b25 fe 7a				cp 'z' 
0b27 28 2e				jr z, .mgod 
0b29 fe 20				cp ' ' 
0b2b 28 34				jr z, .goend 
0b2d fe 0c				cp KEY_RIGHT 
0b2f 28 30				jr z, .goend 
0b31 fe 0d				cp KEY_CR 
0b33 28 2c				jr z, .goend 
0b35 fe 71				cp 'q' 
0b37 28 0b				jr z, .goback 
0b39			 
0b39 fe 0b				cp KEY_LEFT 
0b3b 28 07				jr z, .goback 
0b3d fe 08				cp KEY_BS 
0b3f 28 03				jr z, .goback 
0b41 c3 af 0a				jp .mloop 
0b44			 
0b44			.goback: 
0b44 3e 00			ld a, 0 
0b46 18 1d			jr .goend2 
0b48			 
0b48				; move up one 
0b48			.mgoup: 
0b48 3a 58 eb				ld a, (store_tmp2) 
0b4b fe 00				cp 0 
0b4d ca af 0a				jp z, .mloop 
0b50 3d					dec a 
0b51 32 58 eb				ld (store_tmp2), a 
0b54 c3 af 0a				jp .mloop 
0b57			 
0b57				; move down one 
0b57			.mgod: 
0b57 3a 58 eb				ld a, (store_tmp2) 
0b5a 3c					inc a 
0b5b 32 58 eb				ld (store_tmp2), a 
0b5e c3 af 0a				jp .mloop 
0b61			 
0b61			 
0b61			.goend: 
0b61					; get selected item number 
0b61			 
0b61 3a 58 eb				ld a, (store_tmp2) 
0b64 3c					inc a 
0b65			 
0b65			.goend2: 
0b65 f5					push af 
0b66			 
0b66					; restore active fb 
0b66					; TODO BUG assumes fb1 
0b66			 
0b66 21 16 ed				ld hl, display_fb1 
0b69 22 d2 eb				ld (display_fb_active), hl 
0b6c			 
0b6c					; restore main regs 
0b6c			 
0b6c			 
0b6c cd 95 0a				call update_display 
0b6f			 
0b6f f1					pop af 
0b70			 
0b70 c9				ret 
0b71			 
0b71 .. 00		.msel:   db ">",0 
0b73 .. 00		.mup:   db "^",0 
0b75 .. 00		.mdown:   db "v",0 
0b77			 
0b77			 
0b77			; eof 
0b77			 
# End of file firmware_display.asm
0b77			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0b77			; random number generators 
0b77			 
0b77			 
0b77			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0b77			 
0b77			 
0b77			;-----> Generate a random number 
0b77			; output a=answer 0<=a<=255 
0b77			; all registers are preserved except: af 
0b77			random: 
0b77 e5			        push    hl 
0b78 d5			        push    de 
0b79 2a b4 eb		        ld      hl,(randData) 
0b7c ed 5f		        ld      a,r 
0b7e 57			        ld      d,a 
0b7f 5e			        ld      e,(hl) 
0b80 19			        add     hl,de 
0b81 85			        add     a,l 
0b82 ac			        xor     h 
0b83 22 b4 eb		        ld      (randData),hl 
0b86 d1			        pop     de 
0b87 e1			        pop     hl 
0b88 c9			        ret 
0b89			 
0b89			 
0b89			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0b89			 
0b89			 
0b89			 
0b89			;------LFSR------ 
0b89			;James Montelongo 
0b89			;optimized by Spencer Putt 
0b89			;out: 
0b89			; a = 8 bit random number 
0b89			RandLFSR: 
0b89 21 ba eb		        ld hl,LFSRSeed+4 
0b8c 5e			        ld e,(hl) 
0b8d 23			        inc hl 
0b8e 56			        ld d,(hl) 
0b8f 23			        inc hl 
0b90 4e			        ld c,(hl) 
0b91 23			        inc hl 
0b92 7e			        ld a,(hl) 
0b93 47			        ld b,a 
0b94 cb 13		        rl e  
0b96 cb 12			rl d 
0b98 cb 11		        rl c  
0b9a 17				rla 
0b9b cb 13		        rl e  
0b9d cb 12			rl d 
0b9f cb 11		        rl c  
0ba1 17				rla 
0ba2 cb 13		        rl e  
0ba4 cb 12			rl d 
0ba6 cb 11		        rl c  
0ba8 17				rla 
0ba9 67			        ld h,a 
0baa cb 13		        rl e  
0bac cb 12			rl d 
0bae cb 11		        rl c  
0bb0 17				rla 
0bb1 a8			        xor b 
0bb2 cb 13		        rl e  
0bb4 cb 12			rl d 
0bb6 ac			        xor h 
0bb7 a9			        xor c 
0bb8 aa			        xor d 
0bb9 21 bc eb		        ld hl,LFSRSeed+6 
0bbc 11 bd eb		        ld de,LFSRSeed+7 
0bbf 01 07 00		        ld bc,7 
0bc2 ed b8		        lddr 
0bc4 12			        ld (de),a 
0bc5 c9			        ret 
0bc6			 
0bc6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0bc6			 
0bc6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0bc6			 
0bc6			 
0bc6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0bc6			 
0bc6			prng16: 
0bc6			;Inputs: 
0bc6			;   (seed1) contains a 16-bit seed value 
0bc6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0bc6			;Outputs: 
0bc6			;   HL is the result 
0bc6			;   BC is the result of the LCG, so not that great of quality 
0bc6			;   DE is preserved 
0bc6			;Destroys: 
0bc6			;   AF 
0bc6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0bc6			;160cc 
0bc6			;26 bytes 
0bc6 2a ae eb		    ld hl,(seed1) 
0bc9 44			    ld b,h 
0bca 4d			    ld c,l 
0bcb 29			    add hl,hl 
0bcc 29			    add hl,hl 
0bcd 2c			    inc l 
0bce 09			    add hl,bc 
0bcf 22 ae eb		    ld (seed1),hl 
0bd2 2a ac eb		    ld hl,(seed2) 
0bd5 29			    add hl,hl 
0bd6 9f			    sbc a,a 
0bd7 e6 2d		    and %00101101 
0bd9 ad			    xor l 
0bda 6f			    ld l,a 
0bdb 22 ac eb		    ld (seed2),hl 
0bde 09			    add hl,bc 
0bdf c9			    ret 
0be0			 
0be0			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0be0			 
0be0			rand32: 
0be0			;Inputs: 
0be0			;   (seed1_0) holds the lower 16 bits of the first seed 
0be0			;   (seed1_1) holds the upper 16 bits of the first seed 
0be0			;   (seed2_0) holds the lower 16 bits of the second seed 
0be0			;   (seed2_1) holds the upper 16 bits of the second seed 
0be0			;   **NOTE: seed2 must be non-zero 
0be0			;Outputs: 
0be0			;   HL is the result 
0be0			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0be0			;Destroys: 
0be0			;   AF 
0be0			;Tested and passes all CAcert tests 
0be0			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0be0			;it has a period of 18,446,744,069,414,584,320 
0be0			;roughly 18.4 quintillion. 
0be0			;LFSR taps: 0,2,6,7  = 11000101 
0be0			;291cc 
0be0			;seed1_0=$+1 
0be0			;    ld hl,12345 
0be0			;seed1_1=$+1 
0be0			;    ld de,6789 
0be0			;    ld b,h 
0be0			;    ld c,l 
0be0			;    add hl,hl \ rl e \ rl d 
0be0			;    add hl,hl \ rl e \ rl d 
0be0			;    inc l 
0be0			;    add hl,bc 
0be0			;    ld (seed1_0),hl 
0be0			;    ld hl,(seed1_1) 
0be0			;    adc hl,de 
0be0			;    ld (seed1_1),hl 
0be0			;    ex de,hl 
0be0			;seed2_0=$+1 
0be0			;    ld hl,9876 
0be0			;seed2_1=$+1 
0be0			;    ld bc,54321 
0be0			;    add hl,hl \ rl c \ rl b 
0be0			;    ld (seed2_1),bc 
0be0			;    sbc a,a 
0be0			;    and %11000101 
0be0			;    xor l 
0be0			;    ld l,a 
0be0			;    ld (seed2_0),hl 
0be0			;    ex de,hl 
0be0			;    add hl,bc 
0be0			;    ret 
0be0			; 
0be0			 
0be0			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0be0			; 20 bytes, 86 cycles (excluding ret) 
0be0			 
0be0			; returns   hl = pseudorandom number 
0be0			; corrupts   a 
0be0			 
0be0			; generates 16-bit pseudorandom numbers with a period of 65535 
0be0			; using the xorshift method: 
0be0			 
0be0			; hl ^= hl << 7 
0be0			; hl ^= hl >> 9 
0be0			; hl ^= hl << 8 
0be0			 
0be0			; some alternative shift triplets which also perform well are: 
0be0			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0be0			 
0be0			;  org 32768 
0be0			 
0be0			xrnd: 
0be0 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0be3 3e 00		  ld a,0 
0be5 bd			  cp l 
0be6 20 02		  jr nz, .xrnd1 
0be8 2e 01		  ld l, 1 
0bea			.xrnd1: 
0bea			 
0bea 7c			  ld a,h 
0beb 1f			  rra 
0bec 7d			  ld a,l 
0bed 1f			  rra 
0bee ac			  xor h 
0bef 67			  ld h,a 
0bf0 7d			  ld a,l 
0bf1 1f			  rra 
0bf2 7c			  ld a,h 
0bf3 1f			  rra 
0bf4 ad			  xor l 
0bf5 6f			  ld l,a 
0bf6 ac			  xor h 
0bf7 67			  ld h,a 
0bf8			 
0bf8 22 b2 eb		  ld (xrandc),hl 
0bfb			 
0bfb c9			  ret 
0bfc			;  
0bfc			 
0bfc			 
0bfc			;;;; int maths 
0bfc			 
0bfc			; https://map.grauw.nl/articles/mult_div_shifts.php 
0bfc			; Divide 16-bit values (with 16-bit result) 
0bfc			; In: Divide BC by divider DE 
0bfc			; Out: BC = result, HL = rest 
0bfc			; 
0bfc			Div16: 
0bfc 21 00 00		    ld hl,0 
0bff 78			    ld a,b 
0c00 06 08		    ld b,8 
0c02			Div16_Loop1: 
0c02 17			    rla 
0c03 ed 6a		    adc hl,hl 
0c05 ed 52		    sbc hl,de 
0c07 30 01		    jr nc,Div16_NoAdd1 
0c09 19			    add hl,de 
0c0a			Div16_NoAdd1: 
0c0a 10 f6		    djnz Div16_Loop1 
0c0c 17			    rla 
0c0d 2f			    cpl 
0c0e 47			    ld b,a 
0c0f 79			    ld a,c 
0c10 48			    ld c,b 
0c11 06 08		    ld b,8 
0c13			Div16_Loop2: 
0c13 17			    rla 
0c14 ed 6a		    adc hl,hl 
0c16 ed 52		    sbc hl,de 
0c18 30 01		    jr nc,Div16_NoAdd2 
0c1a 19			    add hl,de 
0c1b			Div16_NoAdd2: 
0c1b 10 f6		    djnz Div16_Loop2 
0c1d 17			    rla 
0c1e 2f			    cpl 
0c1f 41			    ld b,c 
0c20 4f			    ld c,a 
0c21 c9			ret 
0c22			 
0c22			 
0c22			;http://z80-heaven.wikidot.com/math 
0c22			; 
0c22			;Inputs: 
0c22			;     DE and A are factors 
0c22			;Outputs: 
0c22			;     A is not changed 
0c22			;     B is 0 
0c22			;     C is not changed 
0c22			;     DE is not changed 
0c22			;     HL is the product 
0c22			;Time: 
0c22			;     342+6x 
0c22			; 
0c22			Mult16: 
0c22			 
0c22 06 08		     ld b,8          ;7           7 
0c24 21 00 00		     ld hl,0         ;10         10 
0c27 29			       add hl,hl     ;11*8       88 
0c28 07			       rlca          ;4*8        32 
0c29 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c2b 19			         add hl,de   ;--         -- 
0c2c 10 f9		       djnz $-5      ;13*7+8     99 
0c2e c9			ret 
0c2f			 
0c2f			; 
0c2f			; Square root of 16-bit value 
0c2f			; In:  HL = value 
0c2f			; Out:  D = result (rounded down) 
0c2f			; 
0c2f			;Sqr16: 
0c2f			;    ld de,#0040 
0c2f			;    ld a,l 
0c2f			;    ld l,h 
0c2f			;    ld h,d 
0c2f			;    or a 
0c2f			;    ld b,8 
0c2f			;Sqr16_Loop: 
0c2f			;    sbc hl,de 
0c2f			;    jr nc,Sqr16_Skip 
0c2f			;    add hl,de 
0c2f			;Sqr16_Skip: 
0c2f			;    ccf 
0c2f			;    rl d 
0c2f			;    add a,a 
0c2f			;    adc hl,hl 
0c2f			;    add a,a 
0c2f			;    adc hl,hl 
0c2f			;    djnz Sqr16_Loop 
0c2f			;    ret 
0c2f			; 
0c2f			; 
0c2f			; Divide 8-bit values 
0c2f			; In: Divide E by divider C 
0c2f			; Out: A = result, B = rest 
0c2f			; 
0c2f			Div8: 
0c2f af			    xor a 
0c30 06 08		    ld b,8 
0c32			Div8_Loop: 
0c32 cb 13		    rl e 
0c34 17			    rla 
0c35 91			    sub c 
0c36 30 01		    jr nc,Div8_NoAdd 
0c38 81			    add a,c 
0c39			Div8_NoAdd: 
0c39 10 f7		    djnz Div8_Loop 
0c3b 47			    ld b,a 
0c3c 7b			    ld a,e 
0c3d 17			    rla 
0c3e 2f			    cpl 
0c3f c9			    ret 
0c40			 
0c40			; 
0c40			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c40			; In: Multiply A with DE 
0c40			; Out: HL = result 
0c40			; 
0c40			Mult12U: 
0c40 2e 00		    ld l,0 
0c42 87			    add a,a 
0c43 30 01		    jr nc,Mult12U_NoAdd0 
0c45 19			    add hl,de 
0c46			Mult12U_NoAdd0: 
0c46 29			    add hl,hl 
0c47 87			    add a,a 
0c48 30 01		    jr nc,Mult12U_NoAdd1 
0c4a 19			    add hl,de 
0c4b			Mult12U_NoAdd1: 
0c4b 29			    add hl,hl 
0c4c 87			    add a,a 
0c4d 30 01		    jr nc,Mult12U_NoAdd2 
0c4f 19			    add hl,de 
0c50			Mult12U_NoAdd2: 
0c50 29			    add hl,hl 
0c51 87			    add a,a 
0c52 30 01		    jr nc,Mult12U_NoAdd3 
0c54 19			    add hl,de 
0c55			Mult12U_NoAdd3: 
0c55 29			    add hl,hl 
0c56 87			    add a,a 
0c57 30 01		    jr nc,Mult12U_NoAdd4 
0c59 19			    add hl,de 
0c5a			Mult12U_NoAdd4: 
0c5a 29			    add hl,hl 
0c5b 87			    add a,a 
0c5c 30 01		    jr nc,Mult12U_NoAdd5 
0c5e 19			    add hl,de 
0c5f			Mult12U_NoAdd5: 
0c5f 29			    add hl,hl 
0c60 87			    add a,a 
0c61 30 01		    jr nc,Mult12U_NoAdd6 
0c63 19			    add hl,de 
0c64			Mult12U_NoAdd6: 
0c64 29			    add hl,hl 
0c65 87			    add a,a 
0c66 d0			    ret nc 
0c67 19			    add hl,de 
0c68 c9			    ret 
0c69			 
0c69			; 
0c69			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c69			; In: Multiply A with DE 
0c69			;      Put lowest value in A for most efficient calculation 
0c69			; Out: HL = result 
0c69			; 
0c69			Mult12R: 
0c69 21 00 00		    ld hl,0 
0c6c			Mult12R_Loop: 
0c6c cb 3f		    srl a 
0c6e 30 01		    jr nc,Mult12R_NoAdd 
0c70 19			    add hl,de 
0c71			Mult12R_NoAdd: 
0c71 cb 23		    sla e 
0c73 cb 12		    rl d 
0c75 b7			    or a 
0c76 c2 6c 0c		    jp nz,Mult12R_Loop 
0c79 c9			    ret 
0c7a			 
0c7a			; 
0c7a			; Multiply 16-bit values (with 32-bit result) 
0c7a			; In: Multiply BC with DE 
0c7a			; Out: BCHL = result 
0c7a			; 
0c7a			Mult32: 
0c7a 79			    ld a,c 
0c7b 48			    ld c,b 
0c7c 21 00 00		    ld hl,0 
0c7f 06 10		    ld b,16 
0c81			Mult32_Loop: 
0c81 29			    add hl,hl 
0c82 17			    rla 
0c83 cb 11		    rl c 
0c85 30 07		    jr nc,Mult32_NoAdd 
0c87 19			    add hl,de 
0c88 ce 00		    adc a,0 
0c8a d2 8e 0c		    jp nc,Mult32_NoAdd 
0c8d 0c			    inc c 
0c8e			Mult32_NoAdd: 
0c8e 10 f1		    djnz Mult32_Loop 
0c90 41			    ld b,c 
0c91 4f			    ld c,a 
0c92 c9			    ret 
0c93			 
0c93			 
0c93			 
0c93			; 
0c93			; Multiply 8-bit values 
0c93			; In:  Multiply H with E 
0c93			; Out: HL = result 
0c93			; 
0c93			Mult8: 
0c93 16 00		    ld d,0 
0c95 6a			    ld l,d 
0c96 06 08		    ld b,8 
0c98			Mult8_Loop: 
0c98 29			    add hl,hl 
0c99 30 01		    jr nc,Mult8_NoAdd 
0c9b 19			    add hl,de 
0c9c			Mult8_NoAdd: 
0c9c 10 fa		    djnz Mult8_Loop 
0c9e c9			    ret 
0c9f			 
0c9f			 
0c9f			 
0c9f			 
0c9f			 
0c9f			 
0c9f			 
0c9f			 
0c9f			;;http://z80-heaven.wikidot.com/math 
0c9f			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c9f			; 
0c9f			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c9f			;     ld a,16        ;7 
0c9f			;     ld hl,0        ;10 
0c9f			;     jp $+5         ;10 
0c9f			;.DivLoop: 
0c9f			;       add hl,bc    ;-- 
0c9f			;       dec a        ;64 
0c9f			;       jr z,.DivLoopEnd        ;86 
0c9f			; 
0c9f			;       sla e        ;128 
0c9f			;       rl d         ;128 
0c9f			;       adc hl,hl    ;240 
0c9f			;       sbc hl,bc    ;240 
0c9f			;       jr nc,.DivLoop ;23|21 
0c9f			;       inc e        ;-- 
0c9f			;       jp .DivLoop+1 
0c9f			; 
0c9f			;.DivLoopEnd: 
0c9f			 
0c9f			;HL_Div_C: 
0c9f			;Inputs: 
0c9f			;     HL is the numerator 
0c9f			;     C is the denominator 
0c9f			;Outputs: 
0c9f			;     A is the remainder 
0c9f			;     B is 0 
0c9f			;     C is not changed 
0c9f			;     DE is not changed 
0c9f			;     HL is the quotient 
0c9f			; 
0c9f			;       ld b,16 
0c9f			;       xor a 
0c9f			;         add hl,hl 
0c9f			;         rla 
0c9f			;         cp c 
0c9f			;         jr c,$+4 
0c9f			;           inc l 
0c9f			;           sub c 
0c9f			;         djnz $-7 
0c9f			 
0c9f			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c9f			 
0c9f			addatohl: 
0c9f 85			    add   a, l    ; A = A+L 
0ca0 6f			    ld    l, a    ; L = A+L 
0ca1 8c			    adc   a, h    ; A = A+L+H+carry 
0ca2 95			    sub   l       ; A = H+carry 
0ca3 67			    ld    h, a    ; H = H+carry 
0ca4 c9			ret 
0ca5			 
0ca5			addatode: 
0ca5 83			    add   a, e    ; A = A+L 
0ca6 5f			    ld    e, a    ; L = A+L 
0ca7 8a			    adc   a, d    ; A = A+L+H+carry 
0ca8 93			    sub   e       ; A = H+carry 
0ca9 57			    ld    d, a    ; H = H+carry 
0caa c9			ret 
0cab			 
0cab			 
0cab			addatobc: 
0cab 81			    add   a, c    ; A = A+L 
0cac 4f			    ld    c, a    ; L = A+L 
0cad 88			    adc   a, b    ; A = A+L+H+carry 
0cae 91			    sub   c       ; A = H+carry 
0caf 47			    ld    b, a    ; H = H+carry 
0cb0 c9			ret 
0cb1			 
0cb1			subafromhl: 
0cb1			   ; If A=0 do nothing 
0cb1			    ; Otherwise flip A's sign. Since 
0cb1			    ; the upper byte becomes -1, also 
0cb1			    ; substract 1 from H. 
0cb1 ed 44		    neg 
0cb3 ca bc 0c		    jp    z, Skip 
0cb6 25			    dec   h 
0cb7			     
0cb7			    ; Now add the low byte as usual 
0cb7			    ; Two's complement takes care of 
0cb7			    ; ensuring the result is correct 
0cb7 85			    add   a, l 
0cb8 6f			    ld    l, a 
0cb9 8c			    adc   a, h 
0cba 95			    sub   l 
0cbb 67			    ld    h, a 
0cbc			Skip: 
0cbc c9				ret 
0cbd			 
0cbd			 
0cbd			; compare hl and de 
0cbd			; returns:  
0cbd			; if hl = de, z=1, s=0, c0=0 
0cbd			; if hl > de, z=0, s=0, c=0 
0cbd			; if hl < de, z=0, s=1, c=1 
0cbd			cmp16:	 
0cbd b7				or a 
0cbe ed 52			sbc hl,de 
0cc0 e0				ret po 
0cc1 7c				ld a,h 
0cc2 1f				rra 
0cc3 ee 40			xor 01000000B 
0cc5 37				scf 
0cc6 8f				adc a,a 
0cc7 c9				ret 
0cc8			 
0cc8			 
0cc8			; test if hl contains zero   - A is destroyed 
0cc8			 
0cc8			ishlzero:    
0cc8 b7				or a     ; reset flags 
0cc9 7c				ld a, h 
0cca b5				or l        	 
0ccb			 
0ccb c9				ret 
0ccc			 
0ccc			 
0ccc			 
0ccc			 
0ccc			if FORTH_ENABLE_FLOATMATH 
0ccc			;include "float/bbcmath.z80" 
0ccc			include "float/lpfpcalc.asm" 
0ccc			endif 
0ccc			 
0ccc			 
0ccc			; eof 
0ccc			 
# End of file firmware_maths.asm
0ccc			include "firmware_strings.asm"   ; string handling  
0ccc			 
0ccc			 
0ccc			; TODO string len 
0ccc			; input text string, end on cr with zero term 
0ccc			; a offset into frame buffer to start prompt 
0ccc			; d is max length 
0ccc			; e is display size TODO 
0ccc			; c is current cursor position 
0ccc			; hl is ptr to where string will be stored 
0ccc			 
0ccc			 
0ccc			; TODO check limit of buffer for new inserts 
0ccc			; TODO check insert does not push beyond buffer 
0ccc			; TODO scroll in a limited display area 
0ccc			; TODO scroll whole screen on page wrap 
0ccc			 
0ccc			 
0ccc			; TODO handle KEY_PREVWORD 
0ccc			; TODO handle KEY_NEXTWORD 
0ccc			; TODO handle KEY_HOME 
0ccc			; TODO handle KEY_END 
0ccc			; TODO use LCD cursor? 
0ccc			 
0ccc 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ccf 81					add c 
0cd0 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0cd3 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0cd6 79					ld a, c 
0cd7 cd 9f 0c				call addatohl 
0cda 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0cdd 7a					ld a,d 
0cde 32 6c ee			        ld (input_size), a       ; save length of input area 
0ce1 79					ld a, c 
0ce2 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0ce5 7b					ld a,e 
0ce6 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ce9					 
0ce9					 
0ce9			 
0ce9			;		ld a,(input_ptr) 
0ce9			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ce9			 
0ce9			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ce9					; init cursor shape if not set by the cin routines 
0ce9 21 ca eb				ld hl, cursor_shape 
0cec 3e ff				ld a, 255 
0cee 77					ld (hl), a 
0cef 23					inc hl 
0cf0 3e 00				ld a, 0 
0cf2 77					ld (hl), a 
0cf3			 
0cf3 3e 0f				ld a, CUR_BLINK_RATE 
0cf5 32 66 ee				ld (input_cur_flash), a 
0cf8 3e 01				ld a, 1 
0cfa 32 65 ee				ld (input_cur_onoff),a 
0cfd			 
0cfd			;	if DEBUG_INPUT 
0cfd			;		push af 
0cfd			;		ld a, 'I' 
0cfd			;		ld (debug_mark),a 
0cfd			;		pop af 
0cfd			;		CALLMONITOR 
0cfd			;	endif 
0cfd			.is1:		; main entry loop 
0cfd			 
0cfd			 
0cfd			 
0cfd					; pause 1ms 
0cfd			 
0cfd 3e 01				ld a, 1 
0cff cd c9 09				call aDelayInMS 
0d02			 
0d02					; dec flash counter 
0d02 3a 66 ee				ld a, (input_cur_flash) 
0d05 3d					dec a 
0d06 32 66 ee				ld (input_cur_flash), a 
0d09 fe 00				cp 0 
0d0b 20 0d				jr nz, .nochgstate 
0d0d			 
0d0d			 
0d0d					; change state 
0d0d 3a 65 ee				ld a,(input_cur_onoff) 
0d10 ed 44				neg 
0d12 32 65 ee				ld (input_cur_onoff),a 
0d15			 
0d15			 
0d15					; reset on change of state 
0d15 3e 0f				ld a, CUR_BLINK_RATE 
0d17 32 66 ee				ld (input_cur_flash), a 
0d1a			 
0d1a			.nochgstate: 
0d1a					 
0d1a					 
0d1a			 
0d1a					; display cursor  
0d1a			 
0d1a			;		ld hl, (input_start) 
0d1a			;		ld a, (input_cursor) 
0d1a			;		call addatohl 
0d1a			 
0d1a					; get char under cursor and replace with cursor 
0d1a 2a 6f ee		ld hl, (input_ptr) 
0d1d			;		ld a, (hl) 
0d1d			;		ld (input_under_cursor),a 
0d1d			;		ld a, '_' 
0d1d			;		ld (hl), a 
0d1d			 
0d1d					; display string 
0d1d			 
0d1d ed 5b 6d ee			ld de, (input_start) 
0d21 3a 6a ee				ld a, (input_at_pos) 
0d24 cd 85 0a				call str_at_display 
0d27			;	        call update_display 
0d27			 
0d27					; find place to put the cursor 
0d27			;		add h 
0d27			;		ld l, display_row_1 
0d27			;		sub l 
0d27			; (input_at_pos) 
0d27					;ld c, a 
0d27			;		ld a, (input_cursor) 
0d27			;		ld l, (input_at_pos) 
0d27			;		;ld b, h 
0d27			;		add l 
0d27			;		ld (input_at_cursor),a 
0d27					;ld l,h 
0d27			 
0d27			;		ld h, 0 
0d27			;		ld l,(input_at_pos) 
0d27			;		ld a, (input_cursor) 
0d27			;		call addatohl 
0d27			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d27			;		call subafromhl 
0d27			;		ld a,l 
0d27			;		ld (input_at_cursor), a 
0d27			 
0d27				if DEBUG_INPUT 
0d27					ld a, (hardware_diag) 
0d27					cp 0 
0d27					jr z, .skip_input_diag 
0d27			 
0d27					ld a,(input_at_pos) 
0d27					ld hl, LFSRSeed 
0d27					call hexout 
0d27					ld a, (input_cursor) 
0d27					ld hl, LFSRSeed+2 
0d27					call hexout 
0d27					ld a,(input_at_cursor) 
0d27					ld hl, LFSRSeed+4 
0d27					call hexout 
0d27			 
0d27					ld a,(input_cur_onoff) 
0d27					ld hl, LFSRSeed+6 
0d27					call hexout 
0d27			 
0d27					ld a,(input_cur_flash) 
0d27					ld hl, LFSRSeed+8 
0d27					call hexout 
0d27			 
0d27					ld a,(input_len) 
0d27					ld hl, LFSRSeed+10 
0d27					call hexout 
0d27					ld hl, LFSRSeed+12 
0d27					ld a, 0 
0d27					ld (hl),a 
0d27					ld a, display_row_4 
0d27					ld de, LFSRSeed 
0d27					call str_at_display 
0d27					.skip_input_diag: 
0d27				endif 
0d27			 
0d27					; decide on if we are showing the cursor this time round 
0d27			 
0d27 3a 65 ee				ld a, (input_cur_onoff) 
0d2a fe ff				cp 255 
0d2c 28 13				jr z, .skipcur 
0d2e			 
0d2e			 
0d2e 3a 68 ee				ld a,(input_at_cursor) 
0d31 11 ca eb				ld de, cursor_shape 
0d34 cd 85 0a				call str_at_display 
0d37			 
0d37					; save length of current input string 
0d37 2a 6d ee				ld hl, (input_start) 
0d3a cd fd 10				call strlenz 
0d3d 7d					ld a,l 
0d3e 32 60 ee				ld (input_len),a 
0d41			 
0d41			.skipcur: 
0d41			 
0d41 cd 95 0a			        call update_display 
0d44					 
0d44			 
0d44			 
0d44					; wait 
0d44				 
0d44					; TODO loop without wait to flash the cursor and char under cursor	 
0d44 cd 5f 5a				call cin    ; _wait 
0d47			 
0d47 fe 00				cp 0 
0d49 ca fd 0c				jp z, .is1 
0d4c			 
0d4c					; get ptr to char to input into 
0d4c			 
0d4c 4f					ld c,a 
0d4d 2a 6d ee				ld hl, (input_start) 
0d50 3a 5b ee				ld a, (input_cursor) 
0d53 cd 9f 0c				call addatohl 
0d56 22 6f ee				ld (input_ptr), hl 
0d59 79					ld a,c 
0d5a			 
0d5a					; replace char under cursor 
0d5a			 
0d5a			;		ld hl, (input_ptr) 
0d5a			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d5a			;		ld (hl), a 
0d5a			 
0d5a			;	if DEBUG_INPUT 
0d5a			;		push af 
0d5a			;		ld a, 'i' 
0d5a			;		ld (debug_mark),a 
0d5a			;		pop af 
0d5a			;		CALLMONITOR 
0d5a			;	endif 
0d5a fe 0e				cp KEY_HOME 
0d5c 20 0e				jr nz, .iske 
0d5e			 
0d5e 3a 6a ee				ld a, (input_at_pos) 
0d61 32 68 ee				ld (input_at_cursor),a 
0d64 3e 00				ld a, 0 
0d66 32 5b ee				ld (input_cursor), a 
0d69 c3 fd 0c				jp .is1 
0d6c					 
0d6c fe 0f		.iske:		cp KEY_END 
0d6e 20 03				jr nz, .isknw 
0d70 c3 fd 0c				jp .is1 
0d73			 
0d73 fe 06		.isknw:		cp KEY_NEXTWORD 
0d75 20 1b				jr nz, .iskpw 
0d77			 
0d77 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0d7a 7e					ld a,(hl)	 
0d7b fe 00				cp 0 
0d7d ca fd 0c				jp z, .is1    ; end of string 
0d80 fe 20				cp ' ' 
0d82 ca fd 0c				jp z, .is1    ; end of word 
0d85 23					inc hl 
0d86 22 6f ee				ld (input_ptr), hl 
0d89 3a 68 ee				ld a, (input_at_cursor) 
0d8c 3c					inc a 
0d8d 32 68 ee				ld (input_at_cursor), a 
0d90 18 e5				jr .isknwm 
0d92			 
0d92 fe 07		.iskpw:		cp KEY_PREVWORD 
0d94 20 1b				jr nz, .iskl 
0d96			.iskpwm:	 
0d96 2a 6f ee				ld hl, (input_ptr) 
0d99 7e					ld a,(hl)	 
0d9a fe 00				cp 0  
0d9c ca fd 0c				jp z, .is1    ; end of string 
0d9f fe 20				cp ' ' 
0da1 ca fd 0c				jp z, .is1    ; end of word 
0da4 2b					dec hl 
0da5 22 6f ee				ld (input_ptr), hl 
0da8 3a 68 ee				ld a, (input_at_cursor) 
0dab 3d					dec a 
0dac 32 68 ee				ld (input_at_cursor), a 
0daf 18 e5				jr .iskpwm 
0db1			 
0db1			 
0db1 fe 0b		.iskl:		cp KEY_LEFT 
0db3 20 27				jr nz, .isk1 
0db5			 
0db5 3a 5b ee				ld a, (input_cursor) 
0db8			 
0db8 fe 00				cp 0 
0dba ca fd 0c				jp z, .is1 		; at start of line to ignore  
0dbd			 
0dbd 3d					dec  a 		; TODO check underflow 
0dbe 32 5b ee				ld (input_cursor), a 
0dc1			 
0dc1 2a 6f ee				ld hl, (input_ptr) 
0dc4 2b					dec hl 
0dc5 22 6f ee				ld (input_ptr), hl 
0dc8					 
0dc8 3a 68 ee				ld a, (input_at_cursor) 
0dcb 3d					dec a 
0dcc 32 68 ee				ld (input_at_cursor), a 
0dcf			 
0dcf 3e 01				ld a, 1		; show cursor moving 
0dd1 32 65 ee				ld (input_cur_onoff),a 
0dd4 3e 0f				ld a, CUR_BLINK_RATE 
0dd6 32 66 ee				ld (input_cur_flash), a 
0dd9			 
0dd9 c3 fd 0c				jp .is1 
0ddc			 
0ddc fe 0c		.isk1:		cp KEY_RIGHT 
0dde 20 2a				jr nz, .isk2 
0de0			 
0de0 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0de3 5f					ld e,a 
0de4 3a 5b ee				ld a, (input_cursor) 
0de7 bb					cp e 
0de8 ca fd 0c				jp z, .is1		; at the end of string so dont go right 
0deb			 
0deb 3c					inc  a 		; TODO check overflow 
0dec 32 5b ee				ld (input_cursor), a 
0def			 
0def 3a 68 ee				ld a, (input_at_cursor) 
0df2 3c					inc a 
0df3 32 68 ee				ld (input_at_cursor), a 
0df6			 
0df6 2a 6f ee				ld hl, (input_ptr) 
0df9 23					inc hl 
0dfa 22 6f ee				ld (input_ptr), hl 
0dfd			 
0dfd 3e 01				ld a, 1		; show cursor moving 
0dff 32 65 ee				ld (input_cur_onoff),a 
0e02 3e 0f				ld a, CUR_BLINK_RATE 
0e04 32 66 ee				ld (input_cur_flash), a 
0e07			 
0e07 c3 fd 0c				jp .is1 
0e0a			 
0e0a fe 05		.isk2:		cp KEY_UP 
0e0c			 
0e0c 20 26				jr nz, .isk3 
0e0e			 
0e0e					; swap last command with the current on 
0e0e			 
0e0e					; move cursor to start of string 
0e0e 2a 6d ee				ld hl, (input_start) 
0e11 22 6f ee				ld (input_ptr), hl 
0e14			 
0e14 3a 6a ee				ld a, (input_at_pos) 
0e17 32 68 ee				ld (input_at_cursor), a 
0e1a			 
0e1a 3e 00				ld a, 0 
0e1c 32 5b ee				ld (input_cursor), a 
0e1f					 
0e1f					; swap input and last command buffers 
0e1f			 
0e1f 21 fe e6				ld hl, os_cli_cmd 
0e22 11 fd e7				ld de, os_last_cmd 
0e25 06 ff				ld b, 255 
0e27 7e			.swap1:		ld a, (hl) 
0e28 4f					ld c,a 
0e29 1a					ld a, (de) 
0e2a 77					ld (hl), a 
0e2b 79					ld a,c 
0e2c 12					ld (de),a 
0e2d 23					inc hl 
0e2e 13					inc de 
0e2f 10 f6				djnz .swap1 
0e31			 
0e31			 
0e31			 
0e31			 
0e31			 
0e31 c3 fd 0c				jp .is1 
0e34			 
0e34 fe 08		.isk3:		cp KEY_BS 
0e36 20 3c				jr nz, .isk4 
0e38			 
0e38 3a 5b ee				ld a, (input_cursor) 
0e3b			 
0e3b fe 00				cp 0 
0e3d ca fd 0c				jp z, .is1 		; at start of line to ignore  
0e40			 
0e40 3d					dec  a 		; TODO check underflow 
0e41 32 5b ee				ld (input_cursor), a 
0e44			 
0e44					; hl is source 
0e44					; de needs to be source - 1 
0e44			 
0e44			;		ld a, 0 
0e44			;		dec hl 
0e44			;		ld (hl), a 
0e44			 
0e44 2a 6f ee				ld hl, (input_ptr) 
0e47 2b					dec hl 
0e48 22 6f ee				ld (input_ptr), hl 
0e4b			 
0e4b					; shift all data 
0e4b			 
0e4b e5					push hl 
0e4c 23					inc hl 
0e4d d1					pop de 
0e4e 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e51 4f					ld c,a 
0e52 06 00				ld b,0 
0e54 ed b0				ldir  
0e56			 
0e56			 
0e56			 
0e56			 
0e56 3a 68 ee				ld a, (input_at_cursor) 
0e59 3d					dec a 
0e5a 32 68 ee				ld (input_at_cursor), a 
0e5d			 
0e5d			 
0e5d 3e 01				ld a, 1		; show cursor moving 
0e5f 32 65 ee				ld (input_cur_onoff),a 
0e62 3e 0f				ld a, CUR_BLINK_RATE 
0e64 32 66 ee				ld (input_cur_flash), a 
0e67			 
0e67					; remove char 
0e67 3a 68 ee				ld a, (input_at_cursor) 
0e6a 3c					inc a 
0e6b 11 f5 0e				ld de,.iblank 
0e6e cd 85 0a				call str_at_display 
0e71			 
0e71 c3 fd 0c				jp .is1 
0e74			 
0e74 fe 0d		.isk4:		cp KEY_CR 
0e76 28 6c				jr z, .endinput 
0e78			 
0e78					; else add the key press to the end 
0e78			 
0e78 4f					ld c, a			; save key pressed 
0e79			 
0e79 7e					ld a,(hl)		; get what is currently under char 
0e7a			 
0e7a fe 00				cp 0			; we are at the end of the string 
0e7c 20 2f				jr nz, .onchar 
0e7e					 
0e7e					; add a char to the end of the string 
0e7e				 
0e7e 71					ld (hl),c 
0e7f 23					inc hl 
0e80			;		ld a,' ' 
0e80			;		ld (hl),a 
0e80			;		inc hl 
0e80 3e 00				ld a,0 
0e82 77					ld (hl),a 
0e83 2b					dec hl 
0e84			 
0e84 3a 5b ee				ld a, (input_cursor) 
0e87 3c					inc a				; TODO check max string length and scroll  
0e88 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0e8b							 
0e8b 3a 68 ee				ld a, (input_at_cursor) 
0e8e 3c					inc a 
0e8f 32 68 ee				ld (input_at_cursor), a 
0e92			 
0e92 2a 6f ee				ld hl, (input_ptr) 
0e95 23					inc hl 
0e96 22 6f ee				ld (input_ptr), hl 
0e99			 
0e99 2a 6f ee				ld hl, (input_ptr) 
0e9c 23					inc hl 
0e9d 22 6f ee				ld (input_ptr), hl 
0ea0			;	if DEBUG_INPUT 
0ea0			;		push af 
0ea0			;		ld a, '+' 
0ea0			;		ld (debug_mark),a 
0ea0			;		pop af 
0ea0			;		CALLMONITOR 
0ea0			;	endif 
0ea0 3e 01				ld a, 1		; show cursor moving 
0ea2 32 65 ee				ld (input_cur_onoff),a 
0ea5 3e 0f				ld a, CUR_BLINK_RATE 
0ea7 32 66 ee				ld (input_cur_flash), a 
0eaa c3 fd 0c				jp .is1 
0ead					 
0ead			 
0ead			 
0ead					; if on a char then insert 
0ead			.onchar: 
0ead			 
0ead					; TODO over flow check: make sure insert does not blow out buffer 
0ead			 
0ead					; need to do some maths to use lddr 
0ead			 
0ead e5					push hl   ; save char pos 
0eae c5					push bc 
0eaf			 
0eaf 2a 6d ee				ld hl, (input_start) 
0eb2 3a 60 ee				ld a, (input_len) 
0eb5 cd 9f 0c				call addatohl  		; end of string 
0eb8 23					inc hl 
0eb9 23					inc hl		; past zero term 
0eba e5					push hl 
0ebb 23					inc hl 
0ebc e5					push hl  
0ebd			 
0ebd								; start and end of lddr set, now how much to move? 
0ebd			 
0ebd							 
0ebd 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ec0 47					ld b,a 
0ec1 3a 60 ee				ld a,(input_len) 
0ec4 5f					ld e,a 
0ec5 90					sub b 
0ec6 3c					inc a		;?? 
0ec7 3c					inc a		;?? 
0ec8 3c					inc a		;?? 
0ec9			 
0ec9 06 00				ld b,0 
0ecb 4f					ld c,a 
0ecc			 
0ecc				if DEBUG_INPUT 
0ecc					push af 
0ecc					ld a, 'i' 
0ecc					ld (debug_mark),a 
0ecc					pop af 
0ecc			;		CALLMONITOR 
0ecc				endif 
0ecc d1					pop de 
0ecd e1					pop hl 
0ece				if DEBUG_INPUT 
0ece					push af 
0ece					ld a, 'I' 
0ece					ld (debug_mark),a 
0ece					pop af 
0ece			;		CALLMONITOR 
0ece				endif 
0ece ed b8				lddr 
0ed0				 
0ed0			 
0ed0			 
0ed0					; TODO have a key for insert/overwrite mode???? 
0ed0 c1					pop bc 
0ed1 e1					pop hl 
0ed2 71					ld (hl), c		; otherwise overwrite current char 
0ed3					 
0ed3			 
0ed3			 
0ed3			 
0ed3 3a 5b ee				ld a, (input_cursor) 
0ed6 3c					inc  a 		; TODO check overflow 
0ed7 32 5b ee				ld (input_cursor), a 
0eda			 
0eda 3a 68 ee				ld a, (input_at_cursor) 
0edd 3c					inc a 
0ede 32 68 ee				ld (input_at_cursor), a 
0ee1			 
0ee1 c3 fd 0c				jp .is1 
0ee4			 
0ee4			.endinput:	; TODO look for end of string 
0ee4			 
0ee4					; add trailing space for end of token 
0ee4			 
0ee4 2a 6d ee				ld hl, (input_start) 
0ee7 3a 60 ee				ld a,(input_len) 
0eea cd 9f 0c				call addatohl 
0eed 3e 20				ld a, ' ' 
0eef 77					ld (hl),a 
0ef0					; TODO eof of parse marker 
0ef0			 
0ef0 23					inc hl 
0ef1 3e 00				ld a, 0 
0ef3 77					ld (hl),a 
0ef4			 
0ef4			 
0ef4 c9					ret 
0ef5			 
0ef5 .. 00		.iblank: db " ",0 
0ef7			 
0ef7			 
0ef7 32 6a ee		input_str_prev:	ld (input_at_pos), a 
0efa 22 6d ee				ld (input_start), hl 
0efd 3e 01				ld a,1			; add cursor 
0eff 77					ld (hl),a 
0f00 23					inc hl 
0f01 3e 00				ld a,0 
0f03 77					ld (hl),a 
0f04 22 6f ee				ld (input_ptr), hl 
0f07 7a					ld a,d 
0f08 32 6c ee				ld (input_size), a 
0f0b 3e 00				ld a,0 
0f0d 32 5b ee				ld (input_cursor),a 
0f10			.instr1:	 
0f10			 
0f10					; TODO do block cursor 
0f10					; TODO switch cursor depending on the modifer key 
0f10			 
0f10					; update cursor shape change on key hold 
0f10			 
0f10 2a 6f ee				ld hl, (input_ptr) 
0f13 2b					dec hl 
0f14 3a ca eb				ld a,(cursor_shape) 
0f17 77					ld (hl), a 
0f18			 
0f18					; display entered text 
0f18 3a 6a ee				ld a,(input_at_pos) 
0f1b cd 74 59		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f1e ed 5b 6d ee	            	LD   de, (input_start) 
0f22 cd 69 59		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f25			 
0f25 cd 5f 5a				call cin 
0f28 fe 00				cp 0 
0f2a 28 e4				jr z, .instr1 
0f2c			 
0f2c					; proecess keyboard controls first 
0f2c			 
0f2c 2a 6f ee				ld hl,(input_ptr) 
0f2f			 
0f2f fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f31 28 5a				jr z, .instrcr 
0f33			 
0f33 fe 08				cp KEY_BS 	; back space 
0f35 20 0f				jr nz, .instr2 
0f37					; process back space 
0f37			 
0f37					; TODO stop back space if at start of string 
0f37 2b					dec hl 
0f38 2b					dec hl ; to over write cursor 
0f39 3a ca eb				ld a,(cursor_shape) 
0f3c					;ld a,0 
0f3c 77					ld (hl),a 
0f3d 23					inc hl 
0f3e 3e 20				ld a," " 
0f40 77					ld (hl),a 
0f41 22 6f ee				ld (input_ptr),hl 
0f44					 
0f44			 
0f44 18 ca				jr .instr1 
0f46			 
0f46 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f48 20 06				jr nz, .instr3 
0f4a 2b					dec hl 
0f4b 22 6f ee				ld (input_ptr),hl 
0f4e 18 c0				jr .instr1 
0f50				 
0f50 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f52 20 06				jr nz, .instr4 
0f54 23					inc hl 
0f55 22 6f ee				ld (input_ptr),hl 
0f58 18 b6				jr .instr1 
0f5a			 
0f5a fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f5c 20 06				jr nz, .instr5 
0f5e 2b					dec hl 
0f5f 22 6f ee				ld (input_ptr),hl 
0f62 18 ac				jr .instr1 
0f64			 
0f64 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f66 20 06				jr nz, .instr6 
0f68 2b					dec hl 
0f69 22 6f ee				ld (input_ptr),hl 
0f6c 18 a2				jr .instr1 
0f6e fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f70 20 0b				jr nz, .instrnew 
0f72			 
0f72 21 d7 e3			ld hl, scratch 
0f75 11 fd e7			ld de, os_last_cmd 
0f78 cd 96 0f			call strcpy 
0f7b 18 93				jr .instr1 
0f7d			 
0f7d			 
0f7d			.instrnew:	; no special key pressed to see if we have room to store it 
0f7d			 
0f7d					; TODO do string size test 
0f7d			 
0f7d 2b					dec hl ; to over write cursor 
0f7e 77					ld (hl),a 
0f7f 23					inc hl 
0f80 3a ca eb				ld a,(cursor_shape) 
0f83 77					ld (hl),a 
0f84 23					inc hl 
0f85 3e 00				ld a,0 
0f87 77					ld (hl),a 
0f88			 
0f88 22 6f ee				ld (input_ptr),hl 
0f8b					 
0f8b 18 83				jr .instr1 
0f8d 2b			.instrcr:	dec hl		; remove cursor 
0f8e 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f90 77					ld (hl),a 
0f91 23					inc hl 
0f92 3e 00				ld a,0 
0f94 77					ld (hl),a 
0f95			 
0f95			 
0f95					; if at end of line scroll up    
0f95					; TODO detecting only end of line 4 for scroll up  
0f95			 
0f95					;ld   
0f95			 
0f95 c9					ret 
0f96			 
0f96			 
0f96			; strcpy hl = dest, de source 
0f96			 
0f96 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f97 b7			            OR   A              ;Null terminator? 
0f98 c8			            RET  Z              ;Yes, so finished 
0f99 1a					ld a,(de) 
0f9a 77					ld (hl),a 
0f9b 13			            INC  DE             ;Point to next character 
0f9c 23					inc hl 
0f9d 18 f7		            JR   strcpy       ;Repeat 
0f9f c9					ret 
0fa0			 
0fa0			 
0fa0			; TODO string_at  
0fa0			; pass string which starts with lcd offset address and then null term string 
0fa0			 
0fa0			; TODO string to dec 
0fa0			; TODO string to hex 
0fa0			; TODO byte to string hex 
0fa0			; TODO byte to string dec 
0fa0			 
0fa0			 
0fa0			 
0fa0			; from z80uartmonitor 
0fa0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fa0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fa0			; pass hl for where to put the text 
0fa0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fa0 c5			hexout:	PUSH BC 
0fa1 f5					PUSH AF 
0fa2 47					LD B, A 
0fa3					; Upper nybble 
0fa3 cb 3f				SRL A 
0fa5 cb 3f				SRL A 
0fa7 cb 3f				SRL A 
0fa9 cb 3f				SRL A 
0fab cd bb 0f				CALL tohex 
0fae 77					ld (hl),a 
0faf 23					inc hl	 
0fb0					 
0fb0					; Lower nybble 
0fb0 78					LD A, B 
0fb1 e6 0f				AND 0FH 
0fb3 cd bb 0f				CALL tohex 
0fb6 77					ld (hl),a 
0fb7 23					inc hl	 
0fb8					 
0fb8 f1					POP AF 
0fb9 c1					POP BC 
0fba c9					RET 
0fbb					 
0fbb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fbb			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fbb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fbb			tohex: 
0fbb e5					PUSH HL 
0fbc d5					PUSH DE 
0fbd 16 00				LD D, 0 
0fbf 5f					LD E, A 
0fc0 21 c8 0f				LD HL, .DATA 
0fc3 19					ADD HL, DE 
0fc4 7e					LD A, (HL) 
0fc5 d1					POP DE 
0fc6 e1					POP HL 
0fc7 c9					RET 
0fc8			 
0fc8			.DATA: 
0fc8 30					DEFB	30h	; 0 
0fc9 31					DEFB	31h	; 1 
0fca 32					DEFB	32h	; 2 
0fcb 33					DEFB	33h	; 3 
0fcc 34					DEFB	34h	; 4 
0fcd 35					DEFB	35h	; 5 
0fce 36					DEFB	36h	; 6 
0fcf 37					DEFB	37h	; 7 
0fd0 38					DEFB	38h	; 8 
0fd1 39					DEFB	39h	; 9 
0fd2 41					DEFB	41h	; A 
0fd3 42					DEFB	42h	; B 
0fd4 43					DEFB	43h	; C 
0fd5 44					DEFB	44h	; D 
0fd6 45					DEFB	45h	; E 
0fd7 46					DEFB	46h	; F 
0fd8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0fd8			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0fd8			;;    subtract $30, if result > 9 then subtract $7 more 
0fd8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0fd8			atohex: 
0fd8 d6 30				SUB $30 
0fda fe 0a				CP 10 
0fdc f8					RET M		; If result negative it was 0-9 so we're done 
0fdd d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0fdf c9					RET		 
0fe0			 
0fe0			 
0fe0			 
0fe0			 
0fe0			; Get 2 ASCII characters as hex byte from pointer in hl 
0fe0			 
0fe0			BYTERD: 
0fe0 16 00			LD	D,00h		;Set up 
0fe2 cd ea 0f			CALL	HEXCON		;Get byte and convert to hex 
0fe5 87				ADD	A,A		;First nibble so 
0fe6 87				ADD	A,A		;multiply by 16 
0fe7 87				ADD	A,A		; 
0fe8 87				ADD	A,A		; 
0fe9 57				LD	D,A		;Save hi nibble in D 
0fea			HEXCON: 
0fea 7e				ld a, (hl)		;Get next chr 
0feb 23				inc hl 
0fec d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0fee fe 0a			CP	00Ah		;Is it 0-9 ? 
0ff0 38 02			JR	C,NALPHA	;If so miss next bit 
0ff2 d6 07			SUB	007h		;Else convert alpha 
0ff4			NALPHA: 
0ff4 b2				OR	D		;Add hi nibble back 
0ff5 c9				RET			; 
0ff6			 
0ff6			 
0ff6			; 
0ff6			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0ff6			; Since the routines get_byte and therefore get_nibble are called, only valid 
0ff6			; characters (0-9a-f) are accepted. 
0ff6			; 
0ff6			;get_word        push    af 
0ff6			;                call    get_byte        ; Get the upper byte 
0ff6			;                ld      h, a 
0ff6			;                call    get_byte        ; Get the lower byte 
0ff6			;                ld      l, a 
0ff6			;                pop     af 
0ff6			;                ret 
0ff6			; 
0ff6			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0ff6			; the routine get_nibble is used only valid characters are accepted - the  
0ff6			; input routine only accepts characters 0-9a-f. 
0ff6			; 
0ff6 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0ff7 7e					ld a,(hl) 
0ff8 23					inc hl 
0ff9 cd 1e 10		                call    nibble2val      ; Get upper nibble 
0ffc cb 07		                rlc     a 
0ffe cb 07		                rlc     a 
1000 cb 07		                rlc     a 
1002 cb 07		                rlc     a 
1004 47			                ld      b, a            ; Save upper four bits 
1005 7e					ld a,(hl) 
1006 cd 1e 10		                call    nibble2val      ; Get lower nibble 
1009 b0			                or      b               ; Combine both nibbles 
100a c1			                pop     bc              ; Restore B (and C) 
100b c9			                ret 
100c			; 
100c			; Get a hexadecimal digit from the serial line. This routine blocks until 
100c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
100c			; to the serial line interface. The lower 4 bits of A contain the value of  
100c			; that particular digit. 
100c			; 
100c			;get_nibble      ld a,(hl)           ; Read a character 
100c			;                call    to_upper        ; Convert to upper case 
100c			;                call    is_hex          ; Was it a hex digit? 
100c			;                jr      nc, get_nibble  ; No, get another character 
100c			 ;               call    nibble2val      ; Convert nibble to value 
100c			 ;               call    print_nibble 
100c			 ;               ret 
100c			; 
100c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
100c			; A valid hexadecimal digit is denoted by a set C flag. 
100c			; 
100c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
100c			;                ret     nc              ; Yes 
100c			;                cp      '0'             ; Less than '0'? 
100c			;                jr      nc, is_hex_1    ; No, continue 
100c			;                ccf                     ; Complement carry (i.e. clear it) 
100c			;                ret 
100c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
100c			;                ret     c               ; Yes 
100c			;                cp      'A'             ; Less than 'A'? 
100c			;                jr      nc, is_hex_2    ; No, continue 
100c			;                ccf                     ; Yes - clear carry and return 
100c			;                ret 
100c			;is_hex_2        scf                     ; Set carry 
100c			;                ret 
100c			; 
100c			; Convert a single character contained in A to upper case: 
100c			; 
100c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
100e d8			                ret     c 
100f fe 7b		                cp      'z' + 1         ; > 'z'? 
1011 d0			                ret     nc              ; Nothing to do, either 
1012 e6 5f		                and     $5f             ; Convert to upper case 
1014 c9			                ret 
1015			 
1015			 
1015			to_lower: 
1015			 
1015			   ; if char is in [A-Z] make it lower case 
1015			 
1015			   ; enter : a = char 
1015			   ; exit  : a = lower case char 
1015			   ; uses  : af 
1015			 
1015 fe 41		   cp 'A' 
1017 d8			   ret c 
1018			    
1018 fe 5b		   cp 'Z'+1 
101a d0			   ret nc 
101b			    
101b f6 20		   or $20 
101d c9			   ret 
101e			 
101e			; 
101e			; Expects a hexadecimal digit (upper case!) in A and returns the 
101e			; corresponding value in A. 
101e			; 
101e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1020 38 02		                jr      c, nibble2val_1 ; Yes 
1022 d6 07		                sub     7               ; Adjust for A-F 
1024 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1026 e6 0f		                and     $f              ; Only return lower 4 bits 
1028 c9			                ret 
1029			; 
1029			; Print_nibble prints a single hex nibble which is contained in the lower  
1029			; four bits of A: 
1029			; 
1029			;print_nibble    push    af              ; We won't destroy the contents of A 
1029			;                and     $f              ; Just in case... 
1029			;                add     a, '0'             ; If we have a digit we are done here. 
1029			;                cp      '9' + 1         ; Is the result > 9? 
1029			;                jr      c, print_nibble_1 
1029			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1029			;print_nibble_1  call    putc            ; Print the nibble and 
1029			;                pop     af              ; restore the original value of A 
1029			;                ret 
1029			;; 
1029			;; Send a CR/LF pair: 
1029			; 
1029			;crlf            push    af 
1029			;                ld      a, cr 
1029			;                call    putc 
1029			;                ld      a, lf 
1029			;                call    putc 
1029			;                pop     af 
1029			;                ret 
1029			; 
1029			; Print_word prints the four hex digits of a word to the serial line. The  
1029			; word is expected to be in HL. 
1029			; 
1029			;print_word      push    hl 
1029			;                push    af 
1029			;                ld      a, h 
1029			;                call    print_byte 
1029			;                ld      a, l 
1029			;                call    print_byte 
1029			;                pop     af 
1029			;                pop     hl 
1029			;                ret 
1029			; 
1029			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1029			; The byte to be printed is expected to be in A. 
1029			; 
1029			;print_byte      push    af              ; Save the contents of the registers 
1029			;                push    bc 
1029			;                ld      b, a 
1029			;                rrca 
1029			;                rrca 
1029			;                rrca 
1029			;                rrca 
1029			;                call    print_nibble    ; Print high nibble 
1029			;                ld      a, b 
1029			;                call    print_nibble    ; Print low nibble 
1029			;                pop     bc              ; Restore original register contents 
1029			;                pop     af 
1029			;                ret 
1029			 
1029			 
1029			 
1029			 
1029			 
1029			fourehexhl:  
1029 7e				ld a,(hl) 
102a cd d8 0f			call atohex 
102d cb 3f				SRL A 
102f cb 3f				SRL A 
1031 cb 3f				SRL A 
1033 cb 3f				SRL A 
1035 47				ld b, a 
1036 23				inc hl 
1037 7e				ld a,(hl) 
1038 23				inc hl 
1039 cd d8 0f			call atohex 
103c 80				add b 
103d 57				ld d,a 
103e 7e				ld a,(hl) 
103f cd d8 0f			call atohex 
1042 cb 3f				SRL A 
1044 cb 3f				SRL A 
1046 cb 3f				SRL A 
1048 cb 3f				SRL A 
104a 47				ld b, a 
104b 23				inc hl 
104c 7e				ld a,(hl) 
104d 23				inc hl 
104e cd d8 0f			call atohex 
1051 80				add b 
1052 5f				ld e, a 
1053 d5				push de 
1054 e1				pop hl 
1055 c9				ret 
1056			 
1056			; pass hl. returns z set if the byte at hl is a digit 
1056			;isdigithl:  
1056			;	push bc 
1056			;	ld a,(hl) 
1056			;	cp ':' 
1056			;	jr nc, .isdf 		; > 
1056			;	cp '0' 
1056			;	jr c, .isdf		; < 
1056			; 
1056			;	; TODO find a better way to set z 
1056			; 
1056			;	ld b,a 
1056			;	cp b 
1056			;	pop bc 
1056			;	ret 
1056			; 
1056			;.isdf:	; not digit so clear z 
1056			; 
1056			;	; TODO find a better way to unset z 
1056			; 
1056			;	ld b,a 
1056			;	inc b 
1056			;	cp b 
1056			; 
1056			;	pop bc 
1056			;	ret 
1056				 
1056				 
1056			 
1056			 
1056			; pass hl as the four byte address to load 
1056			 
1056			get_word_hl:  
1056 e5				push hl 
1057 cd f6 0f			call get_byte 
105a				 
105a 47				ld b, a 
105b			 
105b e1				pop hl 
105c 23				inc hl 
105d 23				inc hl 
105e			 
105e			; TODO not able to handle a-f  
105e 7e				ld a,(hl) 
105f			;	;cp ':' 
105f			;	cp 'g' 
105f			;	jr nc, .single_byte_hl 		; > 
105f			;	cp 'G' 
105f			;	jr nc, .single_byte_hl 		; > 
105f			;	cp '0' 
105f			;	jr c, .single_byte_hl		; < 
105f			 
105f				;call isdigithl 
105f fe 00			cp 0 
1061 28 06			jr z, .single_byte_hl 
1063			 
1063			.getwhln:   ; hex word so get next byte 
1063			 
1063 cd f6 0f			call get_byte 
1066 6f				ld l, a 
1067 60				ld h,b 
1068 c9				ret 
1069 68			.single_byte_hl:   ld l,b 
106a 26 00				ld h,0 
106c c9					ret 
106d			 
106d			 
106d			 
106d			 
106d 21 22 18			ld hl,asc+1 
1070			;	ld a, (hl) 
1070			;	call nibble2val 
1070 cd f6 0f			call get_byte 
1073			 
1073			;	call fourehexhl 
1073 32 0b e4			ld (scratch+52),a 
1076				 
1076 21 09 e4			ld hl,scratch+50 
1079 22 fa e6			ld (os_cur_ptr),hl 
107c			 
107c c9				ret 
107d			 
107d			 
107d			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
107d			 
107d			; Decimal Unsigned Version 
107d			 
107d			;Number in a to decimal ASCII 
107d			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
107d			;Example: display a=56 as "056" 
107d			;input: a = number 
107d			;Output: a=0,value of a in the screen 
107d			;destroys af,bc (don't know about hl and de) 
107d			DispAToASCII: 
107d 0e 9c			ld	c,-100 
107f cd 89 10			call	.Na1 
1082 0e f6			ld	c,-10 
1084 cd 89 10			call	.Na1 
1087 0e ff			ld	c,-1 
1089 06 2f		.Na1:	ld	b,'0'-1 
108b 04			.Na2:	inc	b 
108c 81				add	a,c 
108d 38 fc			jr	c,.Na2 
108f 91				sub	c		;works as add 100/10/1 
1090 f5				push af		;safer than ld c,a 
1091 78				ld	a,b		;char is in b 
1092			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1092 f1				pop af		;safer than ld a,c 
1093 c9				ret 
1094			 
1094			; Decimal Signed Version 
1094			 
1094			; DispA 
1094			; -------------------------------------------------------------- 
1094			; Converts a signed integer value to a zero-terminated ASCII 
1094			; string representative of that value (using radix 10). 
1094			; -------------------------------------------------------------- 
1094			; INPUTS: 
1094			;     HL     Value to convert (two's complement integer). 
1094			;     DE     Base address of string destination. (pointer). 
1094			; -------------------------------------------------------------- 
1094			; OUTPUTS: 
1094			;     None 
1094			; -------------------------------------------------------------- 
1094			; REGISTERS/MEMORY DESTROYED 
1094			; AF HL 
1094			; -------------------------------------------------------------- 
1094			 
1094			;DispHLToASCII: 
1094			;   push    de 
1094			;   push    bc 
1094			; 
1094			;; Detect sign of HL. 
1094			;    bit    7, h 
1094			;    jr     z, ._DoConvert 
1094			; 
1094			;; HL is negative. Output '-' to string and negate HL. 
1094			;    ld     a, '-' 
1094			;    ld     (de), a 
1094			;    inc    de 
1094			; 
1094			;; Negate HL (using two's complement) 
1094			;    xor    a 
1094			;    sub    l 
1094			;    ld     l, a 
1094			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1094			;    sbc    a, h 
1094			;    ld     h, a 
1094			; 
1094			;; Convert HL to digit characters 
1094			;._DoConvert: 
1094			;    ld     b, 0     ; B will count character length of number 
1094			;-   ld     a, 10 
1094			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1094			;    push   af 
1094			;    inc    b 
1094			;    ld     a, h 
1094			;    or     l 
1094			;    jr     nz, - 
1094			; 
1094			;; Retrieve digits from stack 
1094			;-   pop    af 
1094			;    or     $30 
1094			;    ld     (de), a 
1094			;    inc    de 
1094			;    djnz   - 
1094			; 
1094			;; Terminate string with NULL 
1094			;    xor    a 
1094			;    ld     (de), a 
1094			; 
1094			;    pop    bc 
1094			;    pop    de 
1094			;    ret 
1094			 
1094			;Comments 
1094			; 
1094			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1094			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1094			;    Note that the output string will not be fixed-width. 
1094			; 
1094			;Example Usage 
1094			; 
1094			;    ld    hl, -1004 
1094			;    ld    de, OP1 
1094			;    call  DispA 
1094			;    ld    hl, OP1 
1094			;    syscall  PutS 
1094			 
1094			 
1094			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1094			 
1094			 
1094			;Converts an ASCII string to an unsigned 16-bit integer 
1094			;Quits when it reaches a non-decimal digit 
1094			 
1094			string_to_uint16: 
1094			atoui_16: 
1094			;Input: 
1094			;     DE points to the string 
1094			;Outputs: 
1094			;     HL is the result 
1094			;     A is the 8-bit value of the number 
1094			;     DE points to the byte after the number 
1094			;Destroys: 
1094			;     BC 
1094			;       if the string is non-empty, BC is HL/10 
1094			;Size:  24 bytes 
1094			;Speed: 42+d(104+{0,9}) 
1094			;       d is the number of digits in the number 
1094			;       max is 640 cycles for a 5 digit number 
1094			;Assuming no leading zeros: 
1094			;1 digit:  146cc 
1094			;2 digit:  250cc 
1094			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1094			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1094			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1094			;avg: 544.81158447265625cc (544+13297/16384) 
1094			;=============================================================== 
1094 21 00 00		  ld hl,0 
1097			.u16a: 
1097 1a			  ld a,(de) 
1098 d6 30		  sub 30h 
109a fe 0a		  cp 10 
109c d0			  ret nc 
109d 13			  inc de 
109e 44			  ld b,h 
109f 4d			  ld c,l 
10a0 29			  add hl,hl 
10a1 29			  add hl,hl 
10a2 09			  add hl,bc 
10a3 29			  add hl,hl 
10a4 85			  add a,l 
10a5 6f			  ld l,a 
10a6 30 ef		  jr nc,.u16a 
10a8 24			  inc h 
10a9 c3 97 10		  jp .u16a 
10ac			 
10ac			 
10ac			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10ac			 
10ac			;written by Zeda 
10ac			;Converts a 16-bit unsigned integer to an ASCII string. 
10ac			 
10ac			uitoa_16: 
10ac			;Input: 
10ac			;   DE is the number to convert 
10ac			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10ac			;Output: 
10ac			;   HL points to the null-terminated ASCII string 
10ac			;      NOTE: This isn't necessarily the same as the input HL. 
10ac d5			  push de 
10ad c5			  push bc 
10ae f5			  push af 
10af eb			  ex de,hl 
10b0			 
10b0 01 f0 d8		  ld bc,-10000 
10b3 3e 2f		  ld a,'0'-1 
10b5 3c			  inc a 
10b6 09			  add hl,bc  
10b7 38 fc		   jr c,$-2 
10b9 12			  ld (de),a 
10ba 13			  inc de 
10bb			 
10bb 01 e8 03		  ld bc,1000 
10be 3e 3a		  ld a,'9'+1 
10c0 3d			  dec a  
10c1 09			  add hl,bc  
10c2 30 fc		   jr nc,$-2 
10c4 12			  ld (de),a 
10c5 13			  inc de 
10c6			 
10c6 01 9c ff		  ld bc,-100 
10c9 3e 2f		  ld a,'0'-1 
10cb 3c			  inc a  
10cc 09			  add hl,bc  
10cd 38 fc		   jr c,$-2 
10cf 12			  ld (de),a 
10d0 13			  inc de 
10d1			 
10d1 7d			  ld a,l 
10d2 26 3a		  ld h,'9'+1 
10d4 25			  dec h  
10d5 c6 0a		  add a,10  
10d7 30 fb		   jr nc,$-3 
10d9 c6 30		  add a,'0' 
10db eb			  ex de,hl 
10dc 72			  ld (hl),d 
10dd 23			  inc hl 
10de 77			  ld (hl),a 
10df 23			  inc hl 
10e0 36 00		  ld (hl),0 
10e2			 
10e2			;Now strip the leading zeros 
10e2 0e fa		  ld c,-6 
10e4 09			  add hl,bc 
10e5 3e 30		  ld a,'0' 
10e7 23			  inc hl  
10e8 be			  cp (hl)  
10e9 28 fc		  jr z,$-2 
10eb			 
10eb			;Make sure that the string is non-empty! 
10eb 7e			  ld a,(hl) 
10ec b7			  or a 
10ed 20 01		  jr nz,.atoub 
10ef 2b			  dec hl 
10f0			.atoub: 
10f0			 
10f0 f1			  pop af 
10f1 c1			  pop bc 
10f2 d1			  pop de 
10f3 c9			  ret 
10f4			 
10f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
10f4			 
10f4			toUpper: 
10f4			;A is the char. 
10f4			;If A is a lowercase letter, this sets it to the matching uppercase 
10f4			;18cc or 30cc or 41cc 
10f4			;avg: 26.75cc 
10f4 fe 61		  cp 'a' 
10f6 d8			  ret c 
10f7 fe 7b		  cp 'z'+1 
10f9 d0			  ret nc 
10fa d6 20		  sub 'a'-'A' 
10fc c9			  ret 
10fd			 
10fd			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
10fd			 
10fd			; String Length 
10fd			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
10fd			 
10fd			; Get the length of the null-terminated string starting at $8000 hl 
10fd			;    LD     HL, $8000 
10fd			 
10fd			strlenz: 
10fd			 
10fd af			    XOR    A               ; Zero is the value we are looking for. 
10fe 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
10ff 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1100			                           ; 65, 536 bytes (the entire addressable memory space). 
1100 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1102			 
1102			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1102 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1103 6f			    LD     L, A             ; number of bytes 
1104 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1106 2b			    DEC    HL              ; Compensate for null. 
1107 c9				ret 
1108			 
1108			; Get the length of the A terminated string starting at $8000 hl 
1108			;    LD     HL, $8000 
1108			 
1108			strlent: 
1108			 
1108			                  ; A is the value we are looking for. 
1108 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
110a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
110c			                           ; 65, 536 bytes (the entire addressable memory space). 
110c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
110e			 
110e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
110e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1110 2e 00		    LD     L, 0             ; number of bytes 
1112 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1114 2b			    DEC    HL              ; Compensate for null. 
1115 c9				ret 
1116			 
1116			 
1116			;Comparing Strings 
1116			 
1116			;IN    HL     Address of string1. 
1116			;      DE     Address of string2. 
1116			 
1116			; doc given but wrong??? 
1116			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1116			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1116			; tested 
1116			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1116			 
1116			strcmp_old: 
1116 e5			    PUSH   HL 
1117 d5			    PUSH   DE 
1118			 
1118 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1119 be			    CP     (HL)            ; (want to minimize work). 
111a 38 01		    JR     C, Str1IsBigger 
111c 7e			    LD     A, (HL) 
111d			 
111d			Str1IsBigger: 
111d 4f			    LD     C, A             ; Put length in BC 
111e 06 00		    LD     B, 0 
1120 13			    INC    DE              ; Increment pointers to meat of string. 
1121 23			    INC    HL 
1122			 
1122			CmpLoop: 
1122 1a			    LD     A, (DE)          ; Compare bytes. 
1123 ed a1		    CPI 
1125 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1127 13			    INC    DE              ; Update pointer. 
1128 ea 22 11		    JP     PE, CmpLoop 
112b			 
112b d1			    POP    DE 
112c e1			    POP    HL 
112d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
112e be			    CP     (HL) 
112f c9			    RET 
1130			 
1130			NoMatch: 
1130 2b			    DEC    HL 
1131 be			    CP     (HL)            ; Compare again to affect carry. 
1132 d1			    POP    DE 
1133 e1			    POP    HL 
1134 c9			    RET 
1135			 
1135			;; test strmp 
1135			; 
1135			;ld de, .str1 
1135			;ld hl, .str2 
1135			;call strcmp 
1135			;jr z, .z1 
1135			;;this 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "NZ1" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			;.z1: 
1135			; 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "ZZ1" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			; 
1135			;ld de, .str1 
1135			;ld hl, .str1 
1135			;call strcmp 
1135			;jr z, .z2 
1135			;;this 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "NZ2" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			;.z2: 
1135			; 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "ZZ2" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			; 
1135			;ld de, .str1 
1135			;ld hl, .str2 
1135			;call strcmp 
1135			;jr c, .c1 
1135			; 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "Nc1" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			;.c1: 
1135			;;this 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "cc1" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			; 
1135			;ld de, .str1 
1135			;ld hl, .str1 
1135			;call strcmp 
1135			;jr c, .c2 
1135			;;this 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "Nc2" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			;.c2: 
1135			; 
1135			;	if DEBUG_FORTH_WORDS 
1135			;		DMARK "cc2" 
1135			;		CALLMONITOR 
1135			;	endif 
1135			;	NEXTW 
1135			;.str1:   db "string1",0 
1135			;.str2:   db "string2",0 
1135			 
1135			; only care about direct match or not 
1135			; hl and de strings 
1135			; zero set if the same 
1135			 
1135			strcmp: 
1135 1a				ld a, (de) 
1136 be				cp (hl) 
1137 28 02			jr z, .ssame 
1139 b7				or a 
113a c9				ret 
113b			 
113b			.ssame:  
113b fe 00			cp 0 
113d c8				ret z 
113e			 
113e 23				inc hl 
113f 13				inc de 
1140 18 f3			jr strcmp 
1142				 
1142				 
1142			 
1142			 
1142			 
1142			 
1142			; eof 
1142			 
1142			 
1142			 
1142			 
1142			 
1142			 
# End of file firmware_strings.asm
1142			include "firmware_memory.asm"   ; malloc and free  
1142			 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			.mallocsize: db "Wants malloc >256",0 
1142			.mallocasize: db "MALLOC gives >256",0 
1142			.malloczero: db "MALLOC gives zero",0 
1142			 
1142			malloc_guard_zerolen: 
1142				push hl 
1142				push de 
1142				push af 
1142			 
1142				ld de, 0 
1142			        call cmp16 
1142				jr nz, .lowalloz 
1142			 
1142				push hl 
1142				push de 
1142					ld hl, display_fb0 
1142					ld (display_fb_active), hl 
1142				call clear_display 
1142				ld a, 0 
1142				ld de, .malloczero 
1142				call str_at_display 
1142				call update_display 
1142				call delay1s 
1142				call delay1s 
1142				ld a, 0 
1142				ld (os_view_disable), a 
1142			 
1142				pop de 
1142				pop hl 
1142			 
1142				 
1142			 
1142				CALLMONITOR 
1142			.lowalloz: 
1142			 
1142			 
1142				pop af 
1142				pop de 
1142				pop hl 
1142			ret 
1142			 
1142			malloc_guard_entry: 
1142				push hl 
1142				push de 
1142				push af 
1142			 
1142			 	or a      ;clear carry flag 
1142				push hl 
1142				ld de, 255 
1142				sbc hl, de 
1142				jr c, .lowalloc 
1142			 
1142				push de 
1142					ld hl, display_fb0 
1142					ld (display_fb_active), hl 
1142				call clear_display 
1142				ld a, 0 
1142				ld de, .mallocsize 
1142				call str_at_display 
1142				call update_display 
1142				call delay1s 
1142				call delay1s 
1142				ld a, 0 
1142				ld (os_view_disable), a 
1142			 
1142				pop de 
1142				pop hl 
1142			 
1142				 
1142			 
1142				CALLMONITOR 
1142				jr .lowdone 
1142			.lowalloc: 
1142			 
1142			 
1142				pop hl 
1142			.lowdone:	pop af 
1142				pop de 
1142				pop hl 
1142			ret 
1142			 
1142			malloc_guard_exit: 
1142				push hl 
1142				push de 
1142				push af 
1142			 
1142			 	or a      ;clear carry flag 
1142				push hl 
1142				ld de, 255 
1142				sbc hl, de 
1142				jr c, .lowallocx 
1142			 
1142				push de 
1142					ld hl, display_fb0 
1142					ld (display_fb_active), hl 
1142				call clear_display 
1142				ld a, 0 
1142				ld de, .mallocasize 
1142				call str_at_display 
1142				call update_display 
1142				call delay1s 
1142				call delay1s 
1142				ld a, 0 
1142				ld (os_view_disable), a 
1142				pop de 
1142				pop hl 
1142			 
1142				CALLMONITOR 
1142				jr .lowdonex 
1142			.lowallocx: 
1142			 
1142				pop hl 
1142			.lowdonex:	pop af 
1142				pop de 
1142				pop hl 
1142			ret 
1142			endif 
1142			 
1142			if MALLOC_2 
1142			; Z80 Malloc and Free Functions 
1142			 
1142			; Malloc Function: 
1142			; Input: 
1142			;   HL: Size of block to allocate 
1142			; Output: 
1142			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1142			 
1142			malloc: 
1142				 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			call malloc_guard_entry 
1142			endif 
1142			 
1142			 
1142			 
1142			 
1142					if DEBUG_FORTH_MALLOC 
1142						DMARK "mal" 
1142						CALLMONITOR 
1142					endif 
1142			    push af            ; Save AF register 
1142			    ld a, l            ; Load low byte of size into A 
1142			    or h               ; Check if size is zero 
1142			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1142			 
1142			    ; Allocate memory 
1142			    ld hl, (heap_start) ; Load start of heap into HL 
1142					if DEBUG_FORTH_MALLOC 
1142						DMARK "ma1" 
1142						CALLMONITOR 
1142					endif 
1142			    call malloc_internal ; Call internal malloc function 
1142			    pop af             ; Restore AF register 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142			    ret                ; Return 
1142			 
1142			; Free Function: 
1142			; Input: 
1142			;   HL: Pointer to memory block to free 
1142			; Output: 
1142			;   None 
1142			 
1142			free: 
1142			    push af            ; Save AF register 
1142			    ld a, l            ; Load low byte of pointer into A 
1142			    or h               ; Check if pointer is NULL 
1142			    jp z, free_exit    ; If pointer is NULL, exit 
1142			 
1142			    ; Free memory 
1142			    ld hl, (heap_start) ; Load start of heap into HL 
1142			    call free_internal  ; Call internal free function 
1142			    pop af             ; Restore AF register 
1142			    ret                ; Return 
1142			 
1142			; Internal Malloc Function: 
1142			; Input: 
1142			;   HL: Size of block to allocate 
1142			; Output: 
1142			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1142			 
1142			malloc_internal: 
1142			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1142			    add hl, bc         ; Add management overhead to requested size 
1142			    ex de, hl          ; Save total size in DE, and keep it in HL 
1142					if DEBUG_FORTH_MALLOC 
1142						DMARK "ma2" 
1142						CALLMONITOR 
1142					endif 
1142			 
1142			    ; Search for free memory block 
1142			    ld de, (heap_end)  ; Load end of heap into DE 
1142			    ld bc, 0           ; Initialize counter 
1142			 
1142					if DEBUG_FORTH_MALLOC 
1142						DMARK "ma2" 
1142						CALLMONITOR 
1142					endif 
1142			malloc_search_loop: 
1142			    ; Check if current block is free 
1142			    ld a, (hl)         ; Load current block's status (free or used) 
1142			    cp 0               ; Compare with zero (free) 
1142			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1142			 
1142			    ; Check if current block is large enough 
1142			    ld a, (hl+1)       ; Load high byte of block size 
1142			    cp l               ; Compare with low byte of requested size 
1142			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1142			 
1142			    ld a, (hl+2)       ; Load low byte of block size 
1142			    cp h               ; Compare with high byte of requested size 
1142			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1142			 
1142			    ; Mark block as used 
1142			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1142			 
1142			    ; Calculate remaining space in block 
1142			    ld bc, 0           ; Clear BC 
1142			    add hl, bc         ; Increment HL to point to start of data block 
1142			    add hl, de         ; HL = HL + DE (total size) 
1142			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1142			    add hl, bc         ; Add management overhead to start of data block 
1142			 
1142			    ; Save pointer to allocated block in HL 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142						DMARK "ma5" 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142			    ret 
1142			 
1142			malloc_skip_block_check: 
1142			    ; Move to the next block 
1142			    ld bc, 3           ; Size of management overhead 
1142			    add hl, bc         ; Move to the next block 
1142			    inc de             ; Increment counter 
1142			 
1142			    ; Check if we have reached the end of heap 
1142			    ld a, e            ; Load low byte of heap end address 
1142			    cp (hl)            ; Compare with low byte of current address 
1142			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1142			    ld a, d            ; Load high byte of heap end address 
1142			    cp 0               ; Check if it's zero (end of memory) 
1142			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1142			 
1142			    ; If we reached here, allocation failed 
1142			    xor a              ; Set result to NULL 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142						DMARK "ma6" 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142			    ret 
1142			malloc_exit: 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142						DMARK "ma7" 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142			    ret 
1142			 
1142			; Internal Free Function: 
1142			; Input: 
1142			;   HL: Pointer to memory block to free 
1142			; Output: 
1142			;   None 
1142			 
1142			free_internal: 
1142			    ld de, (heap_start) ; Load start of heap into DE 
1142			    ld bc, 0            ; Initialize counter 
1142			 
1142			free_search_loop: 
1142			    ; Check if current block contains the pointer 
1142			    ld a, l             ; Load low byte of pointer 
1142			    cp (hl+1)           ; Compare with high byte of current block's address 
1142			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1142			    ld a, h             ; Load high byte of pointer 
1142			    cp (hl+2)           ; Compare with low byte of current block's address 
1142			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1142			 
1142			    ; Mark block as free 
1142			    ld (hl), 0          ; Set status byte to indicate free block 
1142			    ret                 ; Return 
1142			 
1142			free_skip_block_check: 
1142			    ; Move to the next block 
1142			    ld bc, 3            ; Size of management overhead 
1142			    add hl, bc          ; Move to the next block 
1142			    inc de              ; Increment counter 
1142			 
1142			    ; Check if we have reached the end of heap 
1142			    ld a, e             ; Load low byte of heap end address 
1142			    cp (hl)             ; Compare with low byte of current address 
1142			    jr nz, free_search_loop  ; If not equal, continue searching 
1142			    ld a, d             ; Load high byte of heap end address 
1142			    cp 0                ; Check if it's zero (end of memory) 
1142			    jr nz, free_search_loop  ; If not zero, continue searching 
1142			 
1142			    ; If we reached here, pointer is not found in heap 
1142			    ret 
1142			 
1142			free_exit: 
1142			    ret                 ; Return 
1142			 
1142			; Define heap start and end addresses 
1142			;heap_start:    .dw 0xC000   ; Start of heap 
1142			;heap_end:      .dw 0xE000   ; End of heap 
1142			 
1142			endif 
1142			 
1142			 
1142			if MALLOC_1 
1142			 
1142			 
1142			 
1142			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1142			 
1142			;moved to firmware.asm 
1142			;heap_start        .equ  0x9000      ; Starting address of heap 
1142			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1142			 
1142			;      .org 0 
1142			;      jp    main 
1142			 
1142			 
1142			;      .org  0x100 
1142			;main: 
1142			;      ld    HL, 0x8100 
1142			;      ld    SP, HL 
1142			; 
1142			;      call  heap_init 
1142			; 
1142			;      ; Make some allocations 
1142			;      ld    HL, 12 
1142			;      call  malloc            ; Allocates 0x9004 
1142			; 
1142			;      ld    HL, 12 
1142			;      call  malloc            ; Allocates 0x9014 
1142			; 
1142			;      ld    HL, 12 
1142			;      call  malloc            ; Allocates 0x9024 
1142			; 
1142			;      ; Free some allocations 
1142			;      ld    HL, 0x9014 
1142			;      call  free 
1142			; 
1142			;      ld    HL, 0x9004 
1142			;      call  free 
1142			; 
1142			;      ld    HL, 0x9024 
1142			;      call  free 
1142			; 
1142			; 
1142			;      halt 
1142			 
1142			 
1142			;------------------------------------------------------------------------------ 
1142			;     heap_init                                                               : 
1142			;                                                                             : 
1142			; Description                                                                 : 
1142			;     Initialise the heap and make it ready for malloc and free operations.   : 
1142			;                                                                             : 
1142			;     The heap is maintained as a linked list, starting with an initial       : 
1142			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1142			;     the first free block in the heap. Each block then points to the next    : 
1142			;     free block within the heap, and the free list ends at the first block   : 
1142			;     with a null pointer to the next free block.                             : 
1142			;                                                                             : 
1142			; Parameters                                                                  : 
1142			;     Inputs are compile-time only. Two defines which specify the starting    : 
1142			;     address of the heap and its size are required, along with a memory      : 
1142			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1142			;     principally stores a pointer to the first free block in the heap.       : 
1142			;                                                                             : 
1142			; Returns                                                                     : 
1142			;     Nothing                                                                 : 
1142			;------------------------------------------------------------------------------ 
1142			heap_init: 
1142 e5			      push  HL 
1143			 
1143			      ; Initialise free list struct 
1143 21 87 5a		      ld    HL, heap_start 
1146 22 82 5a		      ld    (free_list), HL 
1149 21 00 00		      ld    HL, 0 
114c 22 84 5a		      ld    (free_list+2), HL 
114f			 
114f			      ; Insert first free block at bottom of heap, consumes entire heap 
114f 21 b9 e3		      ld    HL, heap_start+heap_size-4 
1152 22 87 5a		      ld    (heap_start), HL        ; Next block (end of free list) 
1155 21 32 89		      ld    HL, heap_size-4 
1158 22 89 5a		      ld    (heap_start+2), HL      ; Block size 
115b			 
115b			      ; Insert end of free list block at top of heap - two null words will 
115b			      ; terminate the free list 
115b 21 00 00		      ld    HL, 0 
115e 22 bb e3		      ld    (heap_start+heap_size-2), HL 
1161 22 b9 e3		      ld    (heap_start+heap_size-4), HL 
1164			 
1164 e1			      pop   HL 
1165			 
1165 c9			      ret 
1166			 
1166			 
1166			;------------------------------------------------------------------------------ 
1166			;     malloc                                                                  : 
1166			;                                                                             : 
1166			; Description                                                                 : 
1166			;     Allocates the wanted space from the heap and returns the address of the : 
1166			;     first useable byte of the allocation.                                   : 
1166			;                                                                             : 
1166			;     Allocations can happen in one of two ways:                              : 
1166			;                                                                             : 
1166			;     1. A free block may be found which is the exact size wanted. In this    : 
1166			;        case the block is removed from the free list and retuedn to the      : 
1166			;        caller.                                                              : 
1166			;     2. A free block may be found which is larger than the size wanted. In   : 
1166			;        this case, the larger block is split into two. The first portion of  : 
1166			;        this block will become the requested space by the malloc call and    : 
1166			;        is returned to the caller. The second portion becomes a new free     : 
1166			;        block, and the free list is adjusted to maintain continuity via this : 
1166			;        newly created block.                                                 : 
1166			;                                                                             : 
1166			;     malloc does not set any initial value in the allocated space, the       : 
1166			;     caller is required to do this as required.                              : 
1166			;                                                                             : 
1166			;     This implementation of malloc uses the stack exclusively, and is        : 
1166			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1166			;     advisable to disable interrupts before calling malloc, and recommended  : 
1166			;     to avoid the use of malloc inside ISRs in general.                      : 
1166			;                                                                             : 
1166			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1166			;                                                                             : 
1166			; Parameters                                                                  : 
1166			;     HL  Number of bytes wanted                                              : 
1166			;                                                                             : 
1166			; Returns                                                                     : 
1166			;     HL  Address of the first useable byte of the allocation                 : 
1166			;                                                                             : 
1166			; Flags                                                                       : 
1166			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1166			;                                                                             : 
1166			; Stack frame                                                                 : 
1166			;       |             |                                                       : 
1166			;       +-------------+                                                       : 
1166			;       |     BC      |                                                       : 
1166			;       +-------------+                                                       : 
1166			;       |     DE      |                                                       : 
1166			;       +-------------+                                                       : 
1166			;       |     IX      |                                                       : 
1166			;       +-------------+                                                       : 
1166			;       |  prev_free  |                                                       : 
1166			;   +4  +-------------+                                                       : 
1166			;       |  this_free  |                                                       : 
1166			;   +2  +-------------+                                                       : 
1166			;       |  next_free  |                                                       : 
1166			;   +0  +-------------+                                                       : 
1166			;       |             |                                                       : 
1166			;                                                                             : 
1166			;------------------------------------------------------------------------------ 
1166			 
1166			 
1166			;malloc: 
1166			; 
1166			;	SAVESP ON 1 
1166			; 
1166			;	call malloc_code 
1166			; 
1166			;	CHECKSP ON 1 
1166			;	ret 
1166			 
1166			 
1166			malloc: 
1166 c5			      push  BC 
1167 d5			      push  DE 
1168 dd e5		      push  IX 
116a			if DEBUG_FORTH_MALLOC_HIGH 
116a			call malloc_guard_entry 
116a			endif 
116a			 
116a					if DEBUG_FORTH_MALLOC 
116a						DMARK "mal" 
116a						CALLMONITOR 
116a					endif 
116a 7c			      ld    A, H                    ; Exit if no space requested 
116b b5			      or    L 
116c ca 2b 12		      jp    Z, malloc_early_exit 
116f			 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			; 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			;inc hl 
116f			 
116f			 
116f			 
116f			 
116f					if DEBUG_FORTH_MALLOC 
116f						DMARK "maA" 
116f						CALLMONITOR 
116f					endif 
116f			      ; Set up stack frame 
116f eb			      ex    DE, HL 
1170 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1173 39			      add   HL, SP 
1174 f9			      ld    SP, HL 
1175 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1179 dd 39		      add   IX, SP 
117b			 
117b			      ; Setup initial state 
117b 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
117e 19			      add   HL, DE 
117f			 
117f 44			      ld    B, H                    ; Move want to BC 
1180 4d			      ld    C, L 
1181			 
1181 21 82 5a		      ld    HL, free_list           ; Store prev_free ptr to stack 
1184 dd 75 04		      ld    (IX+4), L 
1187 dd 74 05		      ld    (IX+5), H 
118a			 
118a 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
118b 23			      inc   HL 
118c 56			      ld    D, (HL) 
118d dd 73 02		      ld    (IX+2), E 
1190 dd 72 03		      ld    (IX+3), D 
1193 eb			      ex    DE, HL                  ; this_free ptr into HL 
1194			 
1194					if DEBUG_FORTH_MALLOC 
1194						DMARK "maB" 
1194						CALLMONITOR 
1194					endif 
1194			      ; Loop through free block list to find some space 
1194			malloc_find_space: 
1194 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1195 23			      inc   HL 
1196 56			      ld    D, (HL) 
1197			 
1197 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1198 b3			      or    E 
1199 ca 25 12		      jp    Z, malloc_no_space 
119c			 
119c dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
119f dd 72 01		      ld    (IX+1), D 
11a2			 
11a2			      ; Does this block have enough space to make the allocation? 
11a2 23			      inc   HL                      ; Load free block size into DE 
11a3 5e			      ld    E, (HL) 
11a4 23			      inc   HL 
11a5 56			      ld    D, (HL) 
11a6			 
11a6 eb			      ex    DE, HL                  ; Check size of block against want 
11a7 b7			      or    A                       ; Ensure carry flag clear 
11a8 ed 42		      sbc   HL, BC 
11aa e5			      push  HL                      ; Store the result for later (new block size) 
11ab			 
11ab ca fa 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11ae 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11b0			 
11b0			      ; this_free block is not big enough, setup ptrs to test next free block 
11b0 e1			      pop   HL                      ; Discard previous result 
11b1			 
11b1 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11b4 dd 66 03		      ld    H, (IX+3) 
11b7 dd 75 04		      ld    (IX+4), L 
11ba dd 74 05		      ld    (IX+5), H 
11bd			 
11bd dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11c0 dd 66 01		      ld    H, (IX+1) 
11c3 dd 75 02		      ld    (IX+2), L 
11c6 dd 74 03		      ld    (IX+3), H 
11c9			 
11c9					if DEBUG_FORTH_MALLOC 
11c9						DMARK "MA>" 
11c9						CALLMONITOR 
11c9					endif 
11c9 18 c9		      jr    malloc_find_space 
11cb			 
11cb			      ; split a bigger block into two - requested size and remaining size 
11cb			malloc_alloc_split: 
11cb					if DEBUG_FORTH_MALLOC 
11cb						DMARK "MAs" 
11cb						CALLMONITOR 
11cb					endif 
11cb eb			      ex    DE, HL                  ; Calculate address of new free block 
11cc 2b			      dec   HL 
11cd 2b			      dec   HL 
11ce 2b			      dec   HL 
11cf 09			      add   HL, BC 
11d0			 
11d0			      ; Create a new block and point it at next_free 
11d0 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11d3 dd 56 01		      ld    D, (IX+1) 
11d6			 
11d6 73			      ld    (HL), E                 ; Store next_free ptr into new block 
11d7 23			      inc   HL 
11d8 72			      ld    (HL), D 
11d9			 
11d9 d1			      pop   DE                      ; Store size of new block into new block 
11da 23			      inc   HL 
11db 73			      ld    (HL), E 
11dc 23			      inc   HL 
11dd 72			      ld    (HL), D 
11de			 
11de			      ; Update this_free ptr to point to new block 
11de 2b			      dec   HL 
11df 2b			      dec   HL 
11e0 2b			      dec   HL 
11e1			 
11e1 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
11e4 dd 56 03		      ld    D, (IX+3) 
11e7			 
11e7 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
11ea dd 74 03		      ld    (IX+3), H 
11ed			 
11ed			      ; Modify this_free block to be allocation 
11ed eb			      ex    DE, HL 
11ee af			      xor   A                       ; Null the next block ptr of allocated block 
11ef 77			      ld    (HL), A 
11f0 23			      inc   HL 
11f1 77			      ld    (HL), A 
11f2			 
11f2 23			      inc   HL                      ; Store want size into allocated block 
11f3 71			      ld    (HL), C 
11f4 23			      inc   HL 
11f5 70			      ld    (HL), B 
11f6 23			      inc   HL 
11f7 e5			      push  HL                      ; Address of allocation to return 
11f8			 
11f8 18 19		      jr    malloc_update_links 
11fa			 
11fa			malloc_alloc_fit: 
11fa e1			      pop   HL                      ; Dont need new block size, want is exact fit 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "MAf" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Modify this_free block to be allocation 
11fb eb			      ex    DE, HL 
11fc 2b			      dec   HL 
11fd 2b			      dec   HL 
11fe 2b			      dec   HL 
11ff			 
11ff af			      xor   A                       ; Null the next block ptr of allocated block 
1200 77			      ld    (HL), A 
1201 23			      inc   HL 
1202 77			      ld    (HL), A 
1203			 
1203 23			      inc   HL                      ; Store address of allocation to return 
1204 23			      inc   HL 
1205 23			      inc   HL 
1206 e5			      push  HL 
1207			 
1207			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1207 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
120a dd 66 01		      ld    H, (IX+1) 
120d			 
120d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1210 dd 74 03		      ld    (IX+3), H 
1213			 
1213			 
1213			malloc_update_links: 
1213			      ; Update prev_free ptr to point to this_free 
1213 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1216 dd 66 05		      ld    H, (IX+5) 
1219			 
1219 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
121c dd 56 03		      ld    D, (IX+3) 
121f			 
121f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1220 23			      inc   HL 
1221 72			      ld    (HL), D 
1222			 
1222					if DEBUG_FORTH_MALLOC 
1222						DMARK "Mul" 
1222						CALLMONITOR 
1222					endif 
1222			      ; Clear the Z flag to indicate successful allocation 
1222 7a			      ld    A, D 
1223 b3			      or    E 
1224			 
1224 d1			      pop   DE                      ; Address of allocation 
1225					if DEBUG_FORTH_MALLOC 
1225						DMARK "MAu" 
1225						CALLMONITOR 
1225					endif 
1225			 
1225			malloc_no_space: 
1225 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1228 39			      add   HL, SP 
1229 f9			      ld    SP, HL 
122a			 
122a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
122b					if DEBUG_FORTH_MALLOC 
122b						DMARK "MAN" 
122b						CALLMONITOR 
122b					endif 
122b			 
122b			malloc_early_exit: 
122b					if DEBUG_FORTH_MALLOC 
122b						DMARK "MAx" 
122b						CALLMONITOR 
122b					endif 
122b dd e1		      pop   IX 
122d d1			      pop   DE 
122e c1			      pop   BC 
122f			 
122f			if DEBUG_FORTH_MALLOC_HIGH 
122f			call malloc_guard_exit 
122f			call malloc_guard_zerolen 
122f			endif 
122f c9			      ret 
1230			 
1230			 
1230			;------------------------------------------------------------------------------ 
1230			;     free                                                                    : 
1230			;                                                                             : 
1230			; Description                                                                 : 
1230			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1230			;     returned by malloc, otherwise the behaviour is undefined.               : 
1230			;                                                                             : 
1230			;     Where possible, directly adjacent free blocks will be merged together   : 
1230			;     into larger blocks to help ensure that the heap does not become         : 
1230			;     excessively fragmented.                                                 : 
1230			;                                                                             : 
1230			;     free does not clear or set any other value into the freed space, and    : 
1230			;     therefore its contents may be visible through subsequent malloc's. The  : 
1230			;     caller should clear the freed space as required.                        : 
1230			;                                                                             : 
1230			;     This implementation of free uses the stack exclusively, and is          : 
1230			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1230			;     advisable to disable interrupts before calling free, and recommended    : 
1230			;     to avoid the use of free inside ISRs in general.                        : 
1230			;                                                                             : 
1230			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1230			;                                                                             : 
1230			; Parameters                                                                  : 
1230			;     HL  Pointer to address of first byte of allocation to be freed          : 
1230			;                                                                             : 
1230			; Returns                                                                     : 
1230			;     Nothing                                                                 : 
1230			;                                                                             : 
1230			; Stack frame                                                                 : 
1230			;       |             |                                                       : 
1230			;       +-------------+                                                       : 
1230			;       |     BC      |                                                       : 
1230			;       +-------------+                                                       : 
1230			;       |     DE      |                                                       : 
1230			;       +-------------+                                                       : 
1230			;       |     IX      |                                                       : 
1230			;       +-------------+                                                       : 
1230			;       |  prev_free  |                                                       : 
1230			;   +2  +-------------+                                                       : 
1230			;       |  next_free  |                                                       : 
1230			;   +0  +-------------+                                                       : 
1230			;       |             |                                                       : 
1230			;                                                                             : 
1230			;------------------------------------------------------------------------------ 
1230			free: 
1230 c5			      push  BC 
1231 d5			      push  DE 
1232 dd e5		      push  IX 
1234			 
1234 7c			      ld    A, H                    ; Exit if ptr is null 
1235 b5			      or    L 
1236 ca fa 12		      jp    Z, free_early_exit 
1239			 
1239			      ; Set up stack frame 
1239 eb			      ex    DE, HL 
123a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
123d 39			      add   HL, SP 
123e f9			      ld    SP, HL 
123f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1243 dd 39		      add   IX, SP 
1245			 
1245			      ; The address in HL points to the start of the useable allocated space, 
1245			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1245			      ; address of the block itself. 
1245 eb			      ex    DE, HL 
1246 11 fc ff		      ld    DE, -4 
1249 19			      add   HL, DE 
124a			 
124a			      ; An allocated block must have a null next block pointer in it 
124a 7e			      ld    A, (HL) 
124b 23			      inc   HL 
124c b6			      or    (HL) 
124d c2 f5 12		      jp    NZ, free_done 
1250			 
1250 2b			      dec   HL 
1251			 
1251 44			      ld    B, H                    ; Copy HL to BC 
1252 4d			      ld    C, L 
1253			 
1253			      ; Loop through the free list to find the first block with an address 
1253			      ; higher than the block being freed 
1253 21 82 5a		      ld    HL, free_list 
1256			 
1256			free_find_higher_block: 
1256 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1257 23			      inc   HL 
1258 56			      ld    D, (HL) 
1259 2b			      dec   HL 
125a			 
125a dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
125d dd 72 01		      ld    (IX+1), D 
1260 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1263 dd 74 03		      ld    (IX+3), H 
1266			 
1266 78			      ld    A, B                    ; Check if DE is greater than BC 
1267 ba			      cp    D                       ; Compare MSB first 
1268 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
126a 30 04		      jr    NC, free_find_higher_block_skip 
126c 79			      ld    A, C 
126d bb			      cp    E                       ; Then compare LSB 
126e 38 08		      jr    C, free_found_higher_block 
1270			 
1270			free_find_higher_block_skip: 
1270 7a			      ld    A, D                    ; Reached the end of the free list? 
1271 b3			      or    E 
1272 ca f5 12		      jp    Z, free_done 
1275			 
1275 eb			      ex    DE, HL 
1276			 
1276 18 de		      jr    free_find_higher_block 
1278			 
1278			free_found_higher_block: 
1278			      ; Insert freed block between prev and next free blocks 
1278 71			      ld    (HL), C                 ; Point prev free block to freed block 
1279 23			      inc   HL 
127a 70			      ld    (HL), B 
127b			 
127b 60			      ld    H, B                    ; Point freed block at next free block 
127c 69			      ld    L, C 
127d 73			      ld    (HL), E 
127e 23			      inc   HL 
127f 72			      ld    (HL), D 
1280			 
1280			      ; Check if the freed block is adjacent to the next free block 
1280 23			      inc   HL                      ; Load size of freed block into HL 
1281 5e			      ld    E, (HL) 
1282 23			      inc   HL 
1283 56			      ld    D, (HL) 
1284 eb			      ex    DE, HL 
1285			 
1285 09			      add   HL, BC                  ; Add addr of freed block and its size 
1286			 
1286 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1289 dd 56 01		      ld    D, (IX+1) 
128c			 
128c b7			      or    A                       ; Clear the carry flag 
128d ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
128f 20 22		      jr    NZ, free_check_adjacent_to_prev 
1291			 
1291			      ; Freed block is adjacent to next, merge into one bigger block 
1291 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1292 5e			      ld    E, (HL) 
1293 23			      inc   HL 
1294 56			      ld    D, (HL) 
1295 e5			      push  HL                      ; Save ptr to next block for later 
1296			 
1296 60			      ld    H, B                    ; Store ptr from next block into freed block 
1297 69			      ld    L, C 
1298 73			      ld    (HL), E 
1299 23			      inc   HL 
129a 72			      ld    (HL), D 
129b			 
129b e1			      pop   HL                      ; Restore ptr to next block 
129c 23			      inc   HL                      ; Load size of next block into DE 
129d 5e			      ld    E, (HL) 
129e 23			      inc   HL 
129f 56			      ld    D, (HL) 
12a0 d5			      push  DE                      ; Save next block size for later 
12a1			 
12a1 60			      ld    H, B                    ; Load size of freed block into HL 
12a2 69			      ld    L, C 
12a3 23			      inc   HL 
12a4 23			      inc   HL 
12a5 5e			      ld    E, (HL) 
12a6 23			      inc   HL 
12a7 56			      ld    D, (HL) 
12a8 eb			      ex    DE, HL 
12a9			 
12a9 d1			      pop   DE                      ; Restore size of next block 
12aa 19			      add   HL, DE                  ; Add sizes of both blocks 
12ab eb			      ex    DE, HL 
12ac			 
12ac 60			      ld    H, B                    ; Store new bigger size into freed block 
12ad 69			      ld    L, C 
12ae 23			      inc   HL 
12af 23			      inc   HL 
12b0 73			      ld    (HL), E 
12b1 23			      inc   HL 
12b2 72			      ld    (HL), D 
12b3			 
12b3			free_check_adjacent_to_prev: 
12b3			      ; Check if the freed block is adjacent to the prev free block 
12b3 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12b6 dd 66 03		      ld    H, (IX+3) 
12b9			 
12b9 23			      inc   HL                      ; Size of prev free block into DE 
12ba 23			      inc   HL 
12bb 5e			      ld    E, (HL) 
12bc 23			      inc   HL 
12bd 56			      ld    D, (HL) 
12be 2b			      dec   HL 
12bf 2b			      dec   HL 
12c0 2b			      dec   HL 
12c1			 
12c1 19			      add   HL, DE                  ; Add prev block addr and size 
12c2			 
12c2 b7			      or    A                       ; Clear the carry flag 
12c3 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12c5 20 2e		      jr    NZ, free_done 
12c7			 
12c7			      ; Freed block is adjacent to prev, merge into one bigger block 
12c7 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12c8 69			      ld    L, C 
12c9 5e			      ld    E, (HL) 
12ca 23			      inc   HL 
12cb 56			      ld    D, (HL) 
12cc e5			      push  HL                      ; Save freed block ptr for later 
12cd			 
12cd dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12d0 dd 66 03		      ld    H, (IX+3) 
12d3 73			      ld    (HL), E 
12d4 23			      inc   HL 
12d5 72			      ld    (HL), D 
12d6			 
12d6 e1			      pop   HL                      ; Restore freed block ptr 
12d7 23			      inc   HL                      ; Load size of freed block into DE 
12d8 5e			      ld    E, (HL) 
12d9 23			      inc   HL 
12da 56			      ld    D, (HL) 
12db d5			      push  DE                      ; Save freed block size for later 
12dc			 
12dc dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
12df dd 66 03		      ld    H, (IX+3) 
12e2 23			      inc   HL 
12e3 23			      inc   HL 
12e4 5e			      ld    E, (HL) 
12e5 23			      inc   HL 
12e6 56			      ld    D, (HL) 
12e7			 
12e7 e1			      pop   HL                      ; Add sizes of both blocks 
12e8 19			      add   HL, DE 
12e9 eb			      ex    DE, HL 
12ea			 
12ea dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
12ed dd 66 03		      ld    H, (IX+3) 
12f0 23			      inc   HL 
12f1 23			      inc   HL 
12f2 73			      ld    (HL), E 
12f3 23			      inc   HL 
12f4 72			      ld    (HL), D 
12f5			 
12f5			free_done: 
12f5 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
12f8 39			      add   HL, SP 
12f9 f9			      ld    SP, HL 
12fa			 
12fa			free_early_exit: 
12fa dd e1		      pop   IX 
12fc d1			      pop   DE 
12fd c1			      pop   BC 
12fe			 
12fe c9			      ret 
12ff			 
12ff			; moved to firmware.asm 
12ff			; 
12ff			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
12ff			;                  .dw   0 
12ff			 
12ff			 
12ff			endif 
12ff			 
12ff			 
12ff			if MALLOC_3 
12ff			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
12ff			;heap_start        .equ  0x9000      ; Starting address of heap 
12ff			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
12ff			; 
12ff			 ;     .org 0 
12ff			  ;    jp    main 
12ff			; 
12ff			; 
12ff			 ;     .org  0x100 
12ff			;main: 
12ff			 ;     ld    HL, 0x8100 
12ff			  ;    ld    SP, HL 
12ff			; 
12ff			;      call  heap_init 
12ff			 
12ff			      ; Make some allocations 
12ff			;      ld    HL, 12 
12ff			;      call  malloc            ; Allocates 0x9004 
12ff			; 
12ff			 ;     ld    HL, 12 
12ff			;      call  malloc            ; Allocates 0x9014 
12ff			 
12ff			;      ld    HL, 12 
12ff			;      call  malloc            ; Allocates 0x9024 
12ff			 
12ff			      ; Free some allocations 
12ff			;      ld    HL, 0x9014 
12ff			;      call  free 
12ff			 
12ff			;      ld    HL, 0x9004 
12ff			;      call  free 
12ff			; 
12ff			;      ld    HL, 0x9024 
12ff			;      call  free 
12ff			 
12ff			 
12ff			 ;     halt 
12ff			 
12ff			 
12ff			;------------------------------------------------------------------------------ 
12ff			;     heap_init                                                               : 
12ff			;                                                                             : 
12ff			; Description                                                                 : 
12ff			;     Initialise the heap and make it ready for malloc and free operations.   : 
12ff			;                                                                             : 
12ff			;     The heap is maintained as a linked list, starting with an initial       : 
12ff			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
12ff			;     the first free block in the heap. Each block then points to the next    : 
12ff			;     free block within the heap, and the free list ends at the first block   : 
12ff			;     with a null pointer to the next free block.                             : 
12ff			;                                                                             : 
12ff			; Parameters                                                                  : 
12ff			;     Inputs are compile-time only. Two defines which specify the starting    : 
12ff			;     address of the heap and its size are required, along with a memory      : 
12ff			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
12ff			;     principally stores a pointer to the first free block in the heap.       : 
12ff			;                                                                             : 
12ff			; Returns                                                                     : 
12ff			;     Nothing                                                                 : 
12ff			;------------------------------------------------------------------------------ 
12ff			heap_init: 
12ff			      push  HL 
12ff			 
12ff			      ; Initialise free list struct 
12ff			      ld    HL, heap_start 
12ff			      ld    (free_list), HL 
12ff			      ld    HL, 0 
12ff			      ld    (free_list+2), HL 
12ff			 
12ff			      ; Insert first free block at bottom of heap, consumes entire heap 
12ff			      ld    HL, heap_start+heap_size-4 
12ff			      ld    (heap_start), HL        ; Next block (end of free list) 
12ff			      ld    HL, heap_size-4 
12ff			      ld    (heap_start+2), HL      ; Block size 
12ff			 
12ff			      ; Insert end of free list block at top of heap - two null words will 
12ff			      ; terminate the free list 
12ff			      ld    HL, 0 
12ff			      ld    (heap_start+heap_size-2), HL 
12ff			      ld    (heap_start+heap_size-4), HL 
12ff			 
12ff			      pop   HL 
12ff			 
12ff			      ret 
12ff			 
12ff			 
12ff			;------------------------------------------------------------------------------ 
12ff			;     malloc                                                                  : 
12ff			;                                                                             : 
12ff			; Description                                                                 : 
12ff			;     Allocates the wanted space from the heap and returns the address of the : 
12ff			;     first useable byte of the allocation.                                   : 
12ff			;                                                                             : 
12ff			;     Allocations can happen in one of two ways:                              : 
12ff			;                                                                             : 
12ff			;     1. A free block may be found which is the exact size wanted. In this    : 
12ff			;        case the block is removed from the free list and retuedn to the      : 
12ff			;        caller.                                                              : 
12ff			;     2. A free block may be found which is larger than the size wanted. In   : 
12ff			;        this case, the larger block is split into two. The first portion of  : 
12ff			;        this block will become the requested space by the malloc call and    : 
12ff			;        is returned to the caller. The second portion becomes a new free     : 
12ff			;        block, and the free list is adjusted to maintain continuity via this : 
12ff			;        newly created block.                                                 : 
12ff			;                                                                             : 
12ff			;     malloc does not set any initial value in the allocated space, the       : 
12ff			;     caller is required to do this as required.                              : 
12ff			;                                                                             : 
12ff			;     This implementation of malloc uses the stack exclusively, and is        : 
12ff			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ff			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ff			;     to avoid the use of malloc inside ISRs in general.                      : 
12ff			;                                                                             : 
12ff			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ff			;                                                                             : 
12ff			; Parameters                                                                  : 
12ff			;     HL  Number of bytes wanted                                              : 
12ff			;                                                                             : 
12ff			; Returns                                                                     : 
12ff			;     HL  Address of the first useable byte of the allocation                 : 
12ff			;                                                                             : 
12ff			; Flags                                                                       : 
12ff			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ff			;                                                                             : 
12ff			; Stack frame                                                                 : 
12ff			;       |             |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     BC      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     DE      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     IX      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |  prev_free  |                                                       : 
12ff			;   +4  +-------------+                                                       : 
12ff			;       |  this_free  |                                                       : 
12ff			;   +2  +-------------+                                                       : 
12ff			;       |  next_free  |                                                       : 
12ff			;   +0  +-------------+                                                       : 
12ff			;       |             |                                                       : 
12ff			;                                                                             : 
12ff			;------------------------------------------------------------------------------ 
12ff			malloc: 
12ff			      push  BC 
12ff			      push  DE 
12ff			      push  IX 
12ff			 
12ff			      ld    A, H                    ; Exit if no space requested 
12ff			      or    L 
12ff			      jp    Z, malloc_early_exit 
12ff			 
12ff			      ; Set up stack frame 
12ff			      ex    DE, HL 
12ff			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12ff			      add   HL, SP 
12ff			      ld    SP, HL 
12ff			      ld    IX, 0                   ; Use IX as a frame pointer 
12ff			      add   IX, SP 
12ff			 
12ff			      ; Setup initial state 
12ff			      ld    HL, 4                   ; want must also include space used by block struct 
12ff			      add   HL, DE 
12ff			 
12ff			      ld    B, H                    ; Move want to BC 
12ff			      ld    C, L 
12ff			 
12ff			      ld    HL, free_list           ; Store prev_free ptr to stack 
12ff			      ld    (IX+4), L 
12ff			      ld    (IX+5), H 
12ff			 
12ff			      ld    E, (HL)                 ; Store this_free ptr to stack 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      ld    (IX+2), E 
12ff			      ld    (IX+3), D 
12ff			      ex    DE, HL                  ; this_free ptr into HL 
12ff			 
12ff			      ; Loop through free block list to find some space 
12ff			malloc_find_space: 
12ff			      ld    E, (HL)                 ; Load next_free ptr into DE 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			 
12ff			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12ff			      or    E 
12ff			      jp    Z, malloc_no_space 
12ff			 
12ff			      ld    (IX+0), E               ; Store next_free ptr to stack 
12ff			      ld    (IX+1), D 
12ff			 
12ff			      ; Does this block have enough space to make the allocation? 
12ff			      inc   HL                      ; Load free block size into DE 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			 
12ff			      ex    DE, HL                  ; Check size of block against want 
12ff			      or    A                       ; Ensure carry flag clear 
12ff			      sbc   HL, BC 
12ff			      push  HL                      ; Store the result for later (new block size) 
12ff			 
12ff			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12ff			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12ff			 
12ff			      ; this_free block is not big enough, setup ptrs to test next free block 
12ff			      pop   HL                      ; Discard previous result 
12ff			 
12ff			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12ff			      ld    H, (IX+3) 
12ff			      ld    (IX+4), L 
12ff			      ld    (IX+5), H 
12ff			 
12ff			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12ff			      ld    H, (IX+1) 
12ff			      ld    (IX+2), L 
12ff			      ld    (IX+3), H 
12ff			 
12ff			      jr    malloc_find_space 
12ff			 
12ff			      ; split a bigger block into two - requested size and remaining size 
12ff			malloc_alloc_split: 
12ff			      ex    DE, HL                  ; Calculate address of new free block 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			      add   HL, BC 
12ff			 
12ff			      ; Create a new block and point it at next_free 
12ff			      ld    E, (IX+0)               ; Load next_free ptr into DE 
12ff			      ld    D, (IX+1) 
12ff			 
12ff			      ld    (HL), E                 ; Store next_free ptr into new block 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      pop   DE                      ; Store size of new block into new block 
12ff			      inc   HL 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      ; Update this_free ptr to point to new block 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			 
12ff			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12ff			      ld    D, (IX+3) 
12ff			 
12ff			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12ff			      ld    (IX+3), H 
12ff			 
12ff			      ; Modify this_free block to be allocation 
12ff			      ex    DE, HL 
12ff			      xor   A                       ; Null the next block ptr of allocated block 
12ff			      ld    (HL), A 
12ff			      inc   HL 
12ff			      ld    (HL), A 
12ff			 
12ff			      inc   HL                      ; Store want size into allocated block 
12ff			      ld    (HL), C 
12ff			      inc   HL 
12ff			      ld    (HL), B 
12ff			      inc   HL 
12ff			      push  HL                      ; Address of allocation to return 
12ff			 
12ff			      jr    malloc_update_links 
12ff			 
12ff			malloc_alloc_fit: 
12ff			      pop   HL                      ; Dont need new block size, want is exact fit 
12ff			 
12ff			      ; Modify this_free block to be allocation 
12ff			      ex    DE, HL 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			 
12ff			      xor   A                       ; Null the next block ptr of allocated block 
12ff			      ld    (HL), A 
12ff			      inc   HL 
12ff			      ld    (HL), A 
12ff			 
12ff			      inc   HL                      ; Store address of allocation to return 
12ff			      inc   HL 
12ff			      inc   HL 
12ff			      push  HL 
12ff			 
12ff			      ; Copy next_free ptr to this_free, remove allocated block from free list 
12ff			      ld    L, (IX+0)               ; next_free to HL 
12ff			      ld    H, (IX+1) 
12ff			 
12ff			      ld    (IX+2), L               ; HL to this_free 
12ff			      ld    (IX+3), H 
12ff			 
12ff			 
12ff			malloc_update_links: 
12ff			      ; Update prev_free ptr to point to this_free 
12ff			      ld    L, (IX+4)               ; prev_free ptr to HL 
12ff			      ld    H, (IX+5) 
12ff			 
12ff			      ld    E, (IX+2)               ; this_free ptr to DE 
12ff			      ld    D, (IX+3) 
12ff			 
12ff			      ld    (HL), E                 ; this_free ptr into prev_free 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      ; Clear the Z flag to indicate successful allocation 
12ff			      ld    A, D 
12ff			      or    E 
12ff			 
12ff			      pop   DE                      ; Address of allocation 
12ff			 
12ff			malloc_no_space: 
12ff			      ld    HL, 6                   ; Clean up stack frame 
12ff			      add   HL, SP 
12ff			      ld    SP, HL 
12ff			 
12ff			      ex    DE, HL                  ; Alloc addr into HL for return 
12ff			 
12ff			malloc_early_exit: 
12ff			      pop   IX 
12ff			      pop   DE 
12ff			      pop   BC 
12ff			 
12ff			      ret 
12ff			 
12ff			 
12ff			;------------------------------------------------------------------------------ 
12ff			;     free                                                                    : 
12ff			;                                                                             : 
12ff			; Description                                                                 : 
12ff			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12ff			;     returned by malloc, otherwise the behaviour is undefined.               : 
12ff			;                                                                             : 
12ff			;     Where possible, directly adjacent free blocks will be merged together   : 
12ff			;     into larger blocks to help ensure that the heap does not become         : 
12ff			;     excessively fragmented.                                                 : 
12ff			;                                                                             : 
12ff			;     free does not clear or set any other value into the freed space, and    : 
12ff			;     therefore its contents may be visible through subsequent malloc's. The  : 
12ff			;     caller should clear the freed space as required.                        : 
12ff			;                                                                             : 
12ff			;     This implementation of free uses the stack exclusively, and is          : 
12ff			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ff			;     advisable to disable interrupts before calling free, and recommended    : 
12ff			;     to avoid the use of free inside ISRs in general.                        : 
12ff			;                                                                             : 
12ff			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ff			;                                                                             : 
12ff			; Parameters                                                                  : 
12ff			;     HL  Pointer to address of first byte of allocation to be freed          : 
12ff			;                                                                             : 
12ff			; Returns                                                                     : 
12ff			;     Nothing                                                                 : 
12ff			;                                                                             : 
12ff			; Stack frame                                                                 : 
12ff			;       |             |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     BC      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     DE      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |     IX      |                                                       : 
12ff			;       +-------------+                                                       : 
12ff			;       |  prev_free  |                                                       : 
12ff			;   +2  +-------------+                                                       : 
12ff			;       |  next_free  |                                                       : 
12ff			;   +0  +-------------+                                                       : 
12ff			;       |             |                                                       : 
12ff			;                                                                             : 
12ff			;------------------------------------------------------------------------------ 
12ff			free: 
12ff			      push  BC 
12ff			      push  DE 
12ff			      push  IX 
12ff			 
12ff			      ld    A, H                    ; Exit if ptr is null 
12ff			      or    L 
12ff			      jp    Z, free_early_exit 
12ff			 
12ff			      ; Set up stack frame 
12ff			      ex    DE, HL 
12ff			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12ff			      add   HL, SP 
12ff			      ld    SP, HL 
12ff			      ld    IX, 0                   ; Use IX as a frame pointer 
12ff			      add   IX, SP 
12ff			 
12ff			      ; The address in HL points to the start of the useable allocated space, 
12ff			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ff			      ; address of the block itself. 
12ff			      ex    DE, HL 
12ff			      ld    DE, -4 
12ff			      add   HL, DE 
12ff			 
12ff			      ; An allocated block must have a null next block pointer in it 
12ff			      ld    A, (HL) 
12ff			      inc   HL 
12ff			      or    (HL) 
12ff			      jp    NZ, free_done 
12ff			 
12ff			      dec   HL 
12ff			 
12ff			      ld    B, H                    ; Copy HL to BC 
12ff			      ld    C, L 
12ff			 
12ff			      ; Loop through the free list to find the first block with an address 
12ff			      ; higher than the block being freed 
12ff			      ld    HL, free_list 
12ff			 
12ff			free_find_higher_block: 
12ff			      ld    E, (HL)                 ; Load next ptr from free block 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      dec   HL 
12ff			 
12ff			      ld    (IX+0), E               ; Save ptr to next free block 
12ff			      ld    (IX+1), D 
12ff			      ld    (IX+2), L               ; Save ptr to prev free block 
12ff			      ld    (IX+3), H 
12ff			 
12ff			      ld    A, B                    ; Check if DE is greater than BC 
12ff			      cp    D                       ; Compare MSB first 
12ff			      jr    Z, $+4                  ; MSB the same, compare LSB 
12ff			      jr    NC, free_find_higher_block_skip 
12ff			      ld    A, C 
12ff			      cp    E                       ; Then compare LSB 
12ff			      jr    C, free_found_higher_block 
12ff			 
12ff			free_find_higher_block_skip: 
12ff			      ld    A, D                    ; Reached the end of the free list? 
12ff			      or    E 
12ff			      jp    Z, free_done 
12ff			 
12ff			      ex    DE, HL 
12ff			 
12ff			      jr    free_find_higher_block 
12ff			 
12ff			free_found_higher_block: 
12ff			      ; Insert freed block between prev and next free blocks 
12ff			      ld    (HL), C                 ; Point prev free block to freed block 
12ff			      inc   HL 
12ff			      ld    (HL), B 
12ff			 
12ff			      ld    H, B                    ; Point freed block at next free block 
12ff			      ld    L, C 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      ; Check if the freed block is adjacent to the next free block 
12ff			      inc   HL                      ; Load size of freed block into HL 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      ex    DE, HL 
12ff			 
12ff			      add   HL, BC                  ; Add addr of freed block and its size 
12ff			 
12ff			      ld    E, (IX+0)               ; Load addr of next free block into DE 
12ff			      ld    D, (IX+1) 
12ff			 
12ff			      or    A                       ; Clear the carry flag 
12ff			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12ff			      jr    NZ, free_check_adjacent_to_prev 
12ff			 
12ff			      ; Freed block is adjacent to next, merge into one bigger block 
12ff			      ex    DE, HL                  ; Load next ptr from next block into DE 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      push  HL                      ; Save ptr to next block for later 
12ff			 
12ff			      ld    H, B                    ; Store ptr from next block into freed block 
12ff			      ld    L, C 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      pop   HL                      ; Restore ptr to next block 
12ff			      inc   HL                      ; Load size of next block into DE 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      push  DE                      ; Save next block size for later 
12ff			 
12ff			      ld    H, B                    ; Load size of freed block into HL 
12ff			      ld    L, C 
12ff			      inc   HL 
12ff			      inc   HL 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      ex    DE, HL 
12ff			 
12ff			      pop   DE                      ; Restore size of next block 
12ff			      add   HL, DE                  ; Add sizes of both blocks 
12ff			      ex    DE, HL 
12ff			 
12ff			      ld    H, B                    ; Store new bigger size into freed block 
12ff			      ld    L, C 
12ff			      inc   HL 
12ff			      inc   HL 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			free_check_adjacent_to_prev: 
12ff			      ; Check if the freed block is adjacent to the prev free block 
12ff			      ld    L, (IX+2)               ; Prev free block ptr into HL 
12ff			      ld    H, (IX+3) 
12ff			 
12ff			      inc   HL                      ; Size of prev free block into DE 
12ff			      inc   HL 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			      dec   HL 
12ff			 
12ff			      add   HL, DE                  ; Add prev block addr and size 
12ff			 
12ff			      or    A                       ; Clear the carry flag 
12ff			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12ff			      jr    NZ, free_done 
12ff			 
12ff			      ; Freed block is adjacent to prev, merge into one bigger block 
12ff			      ld    H, B                    ; Load next ptr from freed block into DE 
12ff			      ld    L, C 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      push  HL                      ; Save freed block ptr for later 
12ff			 
12ff			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12ff			      ld    H, (IX+3) 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			      pop   HL                      ; Restore freed block ptr 
12ff			      inc   HL                      ; Load size of freed block into DE 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			      push  DE                      ; Save freed block size for later 
12ff			 
12ff			      ld    L, (IX+2)               ; Load size of prev block into DE 
12ff			      ld    H, (IX+3) 
12ff			      inc   HL 
12ff			      inc   HL 
12ff			      ld    E, (HL) 
12ff			      inc   HL 
12ff			      ld    D, (HL) 
12ff			 
12ff			      pop   HL                      ; Add sizes of both blocks 
12ff			      add   HL, DE 
12ff			      ex    DE, HL 
12ff			 
12ff			      ld    L, (IX+2)               ; Store new bigger size into prev block 
12ff			      ld    H, (IX+3) 
12ff			      inc   HL 
12ff			      inc   HL 
12ff			      ld    (HL), E 
12ff			      inc   HL 
12ff			      ld    (HL), D 
12ff			 
12ff			free_done: 
12ff			      ld    HL, 4                   ; Clean up stack frame 
12ff			      add   HL, SP 
12ff			      ld    SP, HL 
12ff			 
12ff			free_early_exit: 
12ff			      pop   IX 
12ff			      pop   DE 
12ff			      pop   BC 
12ff			 
12ff			      ret 
12ff			 
12ff			 
12ff			;      .org 0x8000 
12ff			; 
12ff			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
12ff			 ;                 .dw   0 
12ff			 
12ff			endif 
12ff			 
12ff			 
12ff			if MALLOC_4 
12ff			 
12ff			; My memory allocation code. Very very simple.... 
12ff			; allocate space under 250 chars 
12ff			 
12ff			heap_init: 
12ff				; init start of heap as zero 
12ff				;  
12ff			 
12ff				ld hl, heap_start 
12ff				ld a, 0 
12ff				ld (hl), a      ; empty block 
12ff				inc hl 
12ff				ld a, 0 
12ff				ld (hl), a      ; length of block 
12ff				; write end of list 
12ff				inc hl 
12ff				ld a,(hl) 
12ff				inc hl 
12ff				ld a,(hl) 
12ff				 
12ff			 
12ff				; init some malloc vars 
12ff			 
12ff				ld hl, 0 
12ff				ld (free_list), hl       ; store last malloc location 
12ff			 
12ff				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
12ff				ld a, 0 
12ff				ld (hl), a 
12ff			 
12ff			 
12ff				ld hl, heap_start 
12ff				;  
12ff				  
12ff				ret 
12ff			 
12ff			 
12ff			;    free block marker 
12ff			;    requested size  
12ff			;    pointer to next block 
12ff			;    .... 
12ff			;    next block marker 
12ff			 
12ff			 
12ff			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
12ff			; 
12ff			 
12ff			 
12ff			malloc:  
12ff				push de 
12ff				push bc 
12ff				push af 
12ff			 
12ff				; hl space required 
12ff				 
12ff				ld c, l    ; hold space   (TODO only a max of 255) 
12ff			 
12ff			;	inc c     ; TODO BUG need to fix memory leak on push str 
12ff			;	inc c 
12ff			;	inc c 
12ff			;	inc c 
12ff			;	inc c 
12ff			;	inc c 
12ff			;	inc c 
12ff			 
12ff			 
12ff			 
12ff				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
12ff			 
12ff				ld a, (free_list+3) 
12ff				cp 0 
12ff				jr z, .contheap 
12ff			 
12ff				ld hl, (free_list)     ; get last alloc 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "mrs" 
12ff						CALLMONITOR 
12ff					endif 
12ff				jr .startalloc 
12ff			 
12ff			.contheap: 
12ff				ld hl, heap_start 
12ff			 
12ff			.startalloc: 
12ff			 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "mym" 
12ff						CALLMONITOR 
12ff					endif 
12ff			.findblock: 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "mmf" 
12ff						CALLMONITOR 
12ff					endif 
12ff			 
12ff				ld a,(hl)  
12ff				; if byte is zero then clear to use 
12ff			 
12ff				cp 0 
12ff				jr z, .foundemptyblock 
12ff			 
12ff				; if byte is not clear 
12ff				;     then byte is offset to next block 
12ff			 
12ff				inc hl 
12ff				ld a, (hl) ; get size 
12ff			.nextblock:	inc hl 
12ff					ld e, (hl) 
12ff					inc hl 
12ff					ld d, (hl) 
12ff					ex de, hl 
12ff			;	inc hl  ; move past the store space 
12ff			;	inc hl  ; move past zero index  
12ff			 
12ff				; TODO detect no more space 
12ff			 
12ff				push hl 
12ff				ld de, heap_end 
12ff				call cmp16 
12ff				pop hl 
12ff				jr nc, .nospace 
12ff			 
12ff				jr .findblock 
12ff			 
12ff			.nospace: ld hl, 0 
12ff				jp .exit 
12ff			 
12ff			 
12ff			.foundemptyblock:	 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "mme" 
12ff						CALLMONITOR 
12ff					endif 
12ff			 
12ff			; TODO has block enough space if reusing??? 
12ff			 
12ff				;  
12ff			 
12ff			; see if this block has been previously used 
12ff				inc hl 
12ff				ld a, (hl) 
12ff				dec hl 
12ff				cp 0 
12ff				jr z, .newblock 
12ff			 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "meR" 
12ff						CALLMONITOR 
12ff					endif 
12ff			 
12ff			; no reusing previously allocated block 
12ff			 
12ff			; is it smaller than previously used? 
12ff				 
12ff				inc hl    ; move to size 
12ff				ld a, c 
12ff				sub (hl)        ; we want c < (hl) 
12ff				dec hl    ; move back to marker 
12ff			        jr z, .findblock 
12ff			 
12ff				; update with the new size which should be lower 
12ff			 
12ff			        ;inc  hl   ; negate next move. move back to size  
12ff			 
12ff			.newblock: 
12ff				; need to be at marker here 
12ff			 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "meN" 
12ff						CALLMONITOR 
12ff					endif 
12ff			 
12ff			 
12ff				ld a, c 
12ff			 
12ff				ld (free_list+3), a	 ; flag resume from last malloc  
12ff				ld (free_list), hl    ; save out last location 
12ff			 
12ff			 
12ff				;inc a     ; space for length byte 
12ff				ld (hl), a     ; save block in use marker 
12ff			 
12ff				inc hl   ; move to space marker 
12ff				ld (hl), a    ; save new space 
12ff			 
12ff				inc hl   ; move to start of allocated area 
12ff				 
12ff			;	push hl     ; save where we are - 1  
12ff			 
12ff			;	inc hl  ; move past zero index  
12ff				; skip space to set down new marker 
12ff			 
12ff				; provide some extra space for now 
12ff			 
12ff				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
12ff				inc a 
12ff				inc a 
12ff			 
12ff				push hl   ; save where we are in the node block 
12ff			 
12ff				call addatohl 
12ff			 
12ff				; write linked list point 
12ff			 
12ff				pop de     ; get our node position 
12ff				ex de, hl 
12ff			 
12ff				ld (hl), e 
12ff				inc hl 
12ff				ld (hl), d 
12ff			 
12ff				inc hl 
12ff			 
12ff				; now at start of allocated data so save pointer 
12ff			 
12ff				push hl 
12ff			 
12ff				; jump to position of next node and setup empty header in DE 
12ff			 
12ff				ex de, hl 
12ff			 
12ff			;	inc hl ; move past end of block 
12ff			 
12ff				ld a, 0 
12ff				ld (hl), a   ; empty marker 
12ff				inc hl 
12ff				ld (hl), a   ; size 
12ff				inc hl  
12ff				ld (hl), a   ; ptr 
12ff				inc hl 
12ff				ld (hl), a   ; ptr 
12ff			 
12ff			 
12ff				pop hl 
12ff			 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "mmr" 
12ff						CALLMONITOR 
12ff					endif 
12ff			 
12ff			.exit: 
12ff				pop af 
12ff				pop bc 
12ff				pop de  
12ff				ret 
12ff			 
12ff			 
12ff			 
12ff			 
12ff			free:  
12ff				push hl 
12ff				push af 
12ff				; get address in hl 
12ff			 
12ff					if DEBUG_FORTH_MALLOC_INT 
12ff						DMARK "fre" 
12ff						CALLMONITOR 
12ff					endif 
12ff				; data is at hl - move to block count 
12ff				dec hl 
12ff				dec hl    ; get past pointer 
12ff				dec hl 
12ff			 
12ff				ld a, (hl)    ; need this for a validation check 
12ff			 
12ff				dec hl    ; move to block marker 
12ff			 
12ff				; now check that the block count and block marker are the same  
12ff			        ; this checks that we are on a malloc node and not random memory 
12ff			        ; OK a faint chance this could be a problem but rare - famous last words! 
12ff			 
12ff				ld c, a 
12ff				ld a, (hl)    
12ff			 
12ff				cp c 
12ff				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
12ff			 
12ff				; yes good chance we are on a malloc node 
12ff			 
12ff				ld a, 0      
12ff				ld (hl), a   ; mark as free 
12ff			 
12ff				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
12ff			 
12ff			.freeignore:  
12ff			 
12ff				pop af 
12ff				pop hl 
12ff			 
12ff				ret 
12ff			 
12ff			 
12ff			 
12ff			endif 
12ff			 
12ff			; eof 
# End of file firmware_memory.asm
12ff			  
12ff			; device C  
12ff			if SOUND_ENABLE  
12ff				include "firmware_sound.asm"  
12ff			endif  
12ff			  
12ff			include "firmware_diags.asm"  
12ff			; Hardware diags menu 
12ff			 
12ff			 
12ff			config: 
12ff			 
12ff 3e 00			ld a, 0 
1301 21 2f 13			ld hl, .configmn 
1304 cd a3 0a			call menu 
1307			 
1307 fe 00			cp 0 
1309 c8				ret z 
130a			 
130a fe 01			cp 1 
130c cc 5d 13			call z, .savetostore 
130f			 
130f fe 02			cp 2 
1311 cc 49 13			call z, .selautoload 
1314 fe 03			cp 3 
1316 cc 3f 13			call z, .disautoload 
1319 fe 04			cp 4 
131b cc 53 13			call z, .selbank 
131e fe 05			cp 5 
1320 cc 67 13			call z, .debug_tog 
1323 fe 06			cp 6 
1325 cc aa 14			call z, .bpsgo 
1328 fe 07			cp 7 
132a cc 8d 13			call z, hardware_diags 
132d			 
132d 18 d0			jr config 
132f			 
132f			.configmn: 
132f 9b 16			dw prom_c3 
1331 b2 16			dw prom_c2 
1333 c7 16			dw prom_c2a 
1335 dd 16			dw prom_c2b 
1337			;	dw prom_c4 
1337 fa 16			dw prom_m4 
1339 15 17			dw prom_m4b 
133b 1d 17			dw prom_c1 
133d 00 00			dw 0 
133f				 
133f			 
133f			 
133f			 
133f			.disautoload: 
133f				if STORAGE_SE 
133f				ld a, $fe      ; bit 0 clear 
133f				ld (spi_device), a 
133f			 
133f				call storage_get_block_0 
133f			 
133f				ld a, 0 
133f				ld (store_page+STORE_0_AUTOFILE), a 
133f			 
133f					ld hl, 0 
133f					ld de, store_page 
133f				call storage_write_block	 ; save update 
133f				else 
133f			 
133f 21 2c 17			ld hl, prom_notav 
1342 11 42 17			ld de, prom_empty 
1345 cd 03 0a			call info_panel 
1348				endif 
1348			 
1348			 
1348 c9				ret 
1349			 
1349			 
1349			 
1349			; Select auto start 
1349			 
1349			.selautoload: 
1349			 
1349				 
1349				if STORAGE_SE 
1349			 
1349					call config_dir 
1349				        ld hl, scratch 
1349					ld a, 0 
1349					call menu 
1349			 
1349					cp 0 
1349					ret z 
1349			 
1349					dec a 
1349			 
1349			 
1349					; locate menu option 
1349			 
1349					ld hl, scratch 
1349					call table_lookup 
1349			 
1349					if DEBUG_FORTH_WORDS 
1349						DMARK "ALl" 
1349						CALLMONITOR 
1349					endif 
1349					; with the pointer to the menu it, the byte following the zero term is the file id 
1349			 
1349					ld a, 0 
1349					ld bc, 50   ; max of bytes to look at 
1349					cpir  
1349			 
1349					if DEBUG_FORTH_WORDS 
1349						DMARK "ALb" 
1349						CALLMONITOR 
1349					endif 
1349					;inc hl 
1349			 
1349					ld a, (hl)   ; file id 
1349					 
1349				        ; save bank and file ids 
1349			 
1349					push af 
1349			 
1349			; TODO need to save to block 0 on bank 1	 
1349			 
1349					call storage_get_block_0 
1349			 
1349					if DEBUG_FORTH_WORDS 
1349						DMARK "AL0" 
1349						CALLMONITOR 
1349					endif 
1349					pop af 
1349			 
1349					ld (store_page+STORE_0_FILERUN),a 
1349					 
1349					; save bank id 
1349			 
1349					ld a,(spi_device) 
1349					ld (store_page+STORE_0_BANKRUN),a 
1349			 
1349					; enable auto run of store file 
1349			 
1349					ld a, 1 
1349					ld (store_page+STORE_0_AUTOFILE),a 
1349			 
1349					; save buffer 
1349			 
1349					ld hl, 0 
1349					ld de, store_page 
1349					if DEBUG_FORTH_WORDS 
1349						DMARK "ALw" 
1349						CALLMONITOR 
1349					endif 
1349				call storage_write_block	 ; save update 
1349			  
1349			 
1349			 
1349			 
1349					ld hl, scratch 
1349					call config_fdir 
1349			 
1349				else 
1349			 
1349 21 2c 17			ld hl, prom_notav 
134c 11 42 17			ld de, prom_empty 
134f cd 03 0a			call info_panel 
1352			 
1352				endif 
1352 c9				ret 
1353			 
1353			 
1353			 
1353			; Select storage bank 
1353			 
1353			.selbank: 
1353			 
1353				if STORAGE_SE 
1353				else 
1353			 
1353 21 2c 17			ld hl, prom_notav 
1356 11 42 17			ld de, prom_empty 
1359 cd 03 0a			call info_panel 
135c				endif 
135c				 
135c c9				ret 
135d			 
135d			if STORAGE_SE 
135d			 
135d			.config_ldir:   
135d				; Load storage bank labels into menu array 
135d			 
135d				 
135d			 
135d			 
135d				ret 
135d			 
135d			 
135d			endif 
135d			 
135d			 
135d			; Save user words to storage 
135d			 
135d			.savetostore: 
135d			 
135d				if STORAGE_SE 
135d			 
135d					call config_dir 
135d				        ld hl, scratch 
135d					ld a, 0 
135d					call menu 
135d					 
135d					ld hl, scratch 
135d					call config_fdir 
135d			 
135d				else 
135d			 
135d 21 2c 17			ld hl, prom_notav 
1360 11 42 17			ld de, prom_empty 
1363 cd 03 0a			call info_panel 
1366			 
1366				endif 
1366			 
1366 c9				ret 
1367			 
1367			 
1367			 
1367			if STORAGE_SE 
1367			 
1367			config_fdir: 
1367				; using the scratch dir go through and release the memory allocated for each string 
1367				 
1367				ld hl, scratch 
1367			.cfdir:	ld e,(hl) 
1367				inc hl 
1367				ld d,(hl) 
1367				inc hl 
1367			 
1367				ex de, hl 
1367				call ishlzero 
1367				ret z     ; return on null pointer 
1367				call free 
1367				ex de, hl 
1367				jr .cfdir 
1367			 
1367			 
1367				ret 
1367			 
1367			 
1367			config_dir: 
1367			 
1367				; for the config menus that need to build a directory of storage call this routine 
1367				; it will construct a menu in scratch to pass to menu 
1367			 
1367				; open storage device 
1367			 
1367				; execute DIR to build a list of files and their ids into scratch in menu format 
1367				; once the menu has finished then will need to call config_fdir to release the strings 
1367				 
1367				; c = number items 
1367			 
1367				 
1367				call storage_get_block_0 
1367			 
1367				ld hl, store_page     ; get current id count 
1367				ld b, (hl) 
1367				ld c, 0    ; count of files   
1367			 
1367			 
1367				ld hl, scratch 
1367				ld (store_tmp2), hl    ; location to poke strings 
1367			 
1367				; check for empty drive 
1367			 
1367				ld a, 0 
1367				cp b 
1367				jp z, .dirdone 
1367			 
1367				 
1367					if DEBUG_FORTH_WORDS 
1367						DMARK "Cdc" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367			 
1367			.diritem:	 
1367				push bc 
1367				; for each of the current ids do a search for them and if found push to stack 
1367			 
1367					ld hl, STORE_BLOCK_PHY 
1367					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1367					ld e,b 
1367			 
1367					call storage_findnextid 
1367			 
1367			 
1367					; if found hl will be non zero 
1367			 
1367					call ishlzero 
1367					jr z, .dirnotfound 
1367			 
1367					; increase count 
1367			 
1367					pop bc	 
1367					inc c 
1367					push bc 
1367					 
1367			 
1367					; get file header and push the file name 
1367			 
1367					ld de, store_page 
1367					call storage_read_block 
1367			 
1367					; push file id to stack 
1367				 
1367					ld a, (store_page) 
1367					ld h, 0 
1367					ld l, a 
1367			 
1367					;call forth_push_numhl 
1367					; TODO store id 
1367			 
1367					push hl 
1367			 
1367					; push extent count to stack  
1367				 
1367					ld hl, store_page+3 
1367			 
1367					; get file name length 
1367			 
1367					call strlenz   
1367			 
1367					inc hl   ; cover zero term 
1367					inc hl  ; stick the id at the end of the area 
1367			 
1367					push hl 
1367					pop bc    ; move length to bc 
1367			 
1367					call malloc 
1367			 
1367					; TODO save malloc area to scratch 
1367			 
1367					ex de, hl 
1367					ld hl, (store_tmp2) 
1367					ld (hl), e 
1367					inc hl 
1367					ld (hl), d 
1367					inc hl 
1367					ld (store_tmp2), hl 
1367			 
1367					 
1367			 
1367					;pop hl   ; get source 
1367			;		ex de, hl    ; swap aronund	 
1367			 
1367					ld hl, store_page+3 
1367					if DEBUG_FORTH_WORDS 
1367						DMARK "CFd" 
1367						CALLMONITOR 
1367					endif 
1367					ldir 
1367			 
1367					; de is past string, move back one and store id 
1367					 
1367					dec de 
1367			 
1367					; store file id 
1367			 
1367					pop hl 
1367					ex de,hl 
1367					ld (hl), e 
1367			 
1367					if DEBUG_FORTH_WORDS 
1367						DMARK "Cdi" 
1367						CALLMONITOR 
1367					endif 
1367					 
1367			.dirnotfound: 
1367					pop bc     
1367					djnz .diritem 
1367				 
1367			.dirdone:	 
1367			 
1367					ld a, 0 
1367					ld hl, (store_tmp2) 
1367					ld (hl), a 
1367					inc hl 
1367					ld (hl), a 
1367					inc hl 
1367					; push a count of the dir items found 
1367			 
1367			;		ld h, 0 
1367			;		ld l, c 
1367			 
1367				ret 
1367			 
1367			endif 
1367			 
1367			 
1367			; Settings 
1367			; Run  
1367			 
1367			 
1367			 
1367			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1367			;;hd_menu2:   db "        2: Editor",0   
1367			;hd_menu2:   db "        2: Editor       6: Menu",0   
1367			;hd_menu3:   db "        3: Storage",0 
1367			;hd_menu4:   db "0=quit  4: Debug",0 
1367			;hd_don:     db "ON",0 
1367			;hd_doff:     db "OFF",0 
1367			; 
1367			; 
1367			; 
1367			;hardware_diags_old:       
1367			; 
1367			;.diagmenu: 
1367			;	call clear_display 
1367			;	ld a, display_row_1 
1367			;	ld de, hd_menu1 
1367			;	call str_at_display 
1367			; 
1367			;	ld a, display_row_2 
1367			;	ld de, hd_menu2 
1367			;	call str_at_display 
1367			; 
1367			;	ld a, display_row_3 
1367			;	ld de, hd_menu3 
1367			;	call str_at_display 
1367			; 
1367			;	ld a,  display_row_4 
1367			;	ld de, hd_menu4 
1367			;	call str_at_display 
1367			; 
1367			;	; display debug state 
1367			; 
1367			;	ld de, hd_don 
1367			;	ld a, (os_view_disable) 
1367			;	cp 0 
1367			;	jr z, .distog 
1367			;	ld de, hd_doff 
1367			;.distog: ld a, display_row_4+17 
1367			;	call str_at_display 
1367			; 
1367			;	call update_display 
1367			; 
1367			;	call cin_wait 
1367			; 
1367			; 
1367			; 
1367			;	cp '4' 
1367			;	jr nz, .diagn1 
1367			; 
1367			;	; debug toggle 
1367			; 
1367			;	ld a, (os_view_disable) 
1367			;	ld b, '*' 
1367			;	cp 0 
1367			;	jr z, .debtog 
1367			;	ld b, 0 
1367			;.debtog:	 
1367			;	ld a,b 
1367			;	ld (os_view_disable),a 
1367			; 
1367			;.diagn1: cp '0' 
1367			;	 ret z 
1367			; 
1367			;;	cp '1' 
1367			;;       jp z, matrix	 
1367			;;   TODO keyboard matrix test 
1367			; 
1367			;	cp '2' 
1367			;	jp z, .diagedit 
1367			; 
1367			;;	cp '6' 
1367			;;	jp z, .menutest 
1367			;;if ENABLE_BASIC 
1367			;;	cp '6' 
1367			;;	jp z, basic 
1367			;;endif 
1367			 ; 
1367			;	jp .diagmenu 
1367			; 
1367			; 
1367			;	ret 
1367			 
1367			 
1367			.debug_tog: 
1367 21 ae 13			ld hl, .menudebug 
136a				 
136a 3a c8 e3			ld a, (os_view_disable) 
136d fe 2a			cp '*' 
136f 20 04			jr nz,.tdon  
1371 3e 01			ld a, 1 
1373 18 02			jr .tog1 
1375 3e 00		.tdon: ld a, 0 
1377			 
1377			.tog1: 
1377 cd a3 0a			call menu 
137a fe 00			cp 0 
137c c8				ret z 
137d fe 01			cp 1    ; disable debug 
137f 28 04			jr z, .dtog0 
1381 3e 2a			ld a, '*' 
1383 18 02			jr .dtogset 
1385 3e 00		.dtog0: ld a, 0 
1387 32 c8 e3		.dtogset:  ld (os_view_disable), a 
138a c3 67 13			jp .debug_tog 
138d			 
138d			 
138d			hardware_diags:       
138d			 
138d			.diagm: 
138d 21 a0 13			ld hl, .menuitems 
1390 3e 00			ld a, 0 
1392 cd a3 0a			call menu 
1395			 
1395 fe 00		         cp 0 
1397 c8				 ret z 
1398			 
1398 fe 02			cp 2 
139a ca f9 13			jp z, .diagedit 
139d			 
139d			;	cp '6' 
139d			;	jp z, .menutest 
139d			;if ENABLE_BASIC 
139d			;	cp '6' 
139d			;	jp z, basic 
139d			;endif 
139d			  
139d c3 8d 13			jp .diagm 
13a0			 
13a0				 
13a0 b4 13		.menuitems:   	dw .m1 
13a2 bf 13				dw .m2 
13a4 c6 13				dw .m3 
13a6 ce 13				dw .m5 
13a8 d4 13				dw .m5a 
13aa dd 13				dw .m5b 
13ac 00 00				dw 0 
13ae			 
13ae			.menudebug: 
13ae e6 13				dw .m6 
13b0 ef 13				dw .m7 
13b2 00 00				dw 0 
13b4			 
13b4 .. 00		.m1:   db "Key Matrix",0 
13bf .. 00		.m2:   db "Editor",0 
13c6 .. 00		.m3:   db "Storage",0 
13ce .. 00		.m5:   db "Sound",0 
13d4 .. 00		.m5a:  db "RAM Test",0 
13dd .. 00		.m5b:  db "LCD Test",0 
13e6			 
13e6 .. 00		.m6:   db "Debug ON",0 
13ef .. 00		.m7:   db "Debug OFF",0 
13f9			 
13f9			; debug editor 
13f9			 
13f9			.diagedit: 
13f9			 
13f9 21 d7 e3			ld hl, scratch 
13fc			;	ld bc, 250 
13fc			;	ldir 
13fc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13fc 3e 00			ld a, 0 
13fe 77				ld (hl), a 
13ff 23				inc hl 
1400 77				ld (hl), a 
1401 23				inc hl 
1402 77				ld (hl), a 
1403			 
1403 cd 72 0a		        call clear_display 
1406 cd 95 0a			call update_display 
1409				;ld a, 1 
1409				;ld (hardware_diag), a 
1409			.diloop: 
1409 3e 00			ld a, display_row_1 
140b 0e 00			ld c, 0 
140d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
140f 1e 28			ld e, 40 
1411			 
1411 21 d7 e3			ld hl, scratch	 
1414 cd cc 0c			call input_str 
1417			 
1417 3e 28			ld a, display_row_2 
1419 11 d7 e3			ld de, scratch 
141c cd 85 0a			call str_at_display 
141f cd 95 0a			call update_display 
1422			 
1422 c3 09 14			jp .diloop 
1425			 
1425			 
1425			; pass word in hl 
1425			; a has display location 
1425			display_word_at: 
1425 f5				push af 
1426 e5				push hl 
1427 7c				ld a,h 
1428 21 dc e6			ld hl, os_word_scratch 
142b cd a0 0f			call hexout 
142e e1				pop hl 
142f 7d				ld a,l 
1430 21 de e6			ld hl, os_word_scratch+2 
1433 cd a0 0f			call hexout 
1436 21 e0 e6			ld hl, os_word_scratch+4 
1439 3e 00			ld a,0 
143b 77				ld (hl),a 
143c 11 dc e6			ld de,os_word_scratch 
143f f1				pop af 
1440 cd 85 0a				call str_at_display 
1443 c9				ret 
1444			 
1444			display_ptr_state: 
1444			 
1444				; to restore afterwards 
1444			 
1444 d5				push de 
1445 c5				push bc 
1446 e5				push hl 
1447 f5				push af 
1448			 
1448				; for use in here 
1448			 
1448			;	push bc 
1448			;	push de 
1448			;	push hl 
1448			;	push af 
1448			 
1448 cd 72 0a			call clear_display 
144b			 
144b 11 1e 16			ld de, .ptrstate 
144e 3e 00			ld a, display_row_1 
1450 cd 85 0a			call str_at_display 
1453			 
1453				; display debug step 
1453			 
1453			 
1453 11 71 ee			ld de, debug_mark 
1456 3e 26			ld a, display_row_1+display_cols-2 
1458 cd 85 0a			call str_at_display 
145b			 
145b				; display a 
145b 11 28 16			ld de, .ptrcliptr 
145e 3e 28			ld a, display_row_2 
1460 cd 85 0a			call str_at_display 
1463			 
1463 f1				pop af 
1464 2a 22 eb			ld hl,(cli_ptr) 
1467 3e 30			ld a, display_row_2+8 
1469 cd 25 14			call display_word_at 
146c			 
146c			 
146c				; display hl 
146c			 
146c			 
146c 11 30 16			ld de, .ptrclioptr 
146f 3e 32			ld a, display_row_2+10 
1471 cd 85 0a			call str_at_display 
1474			; 
1474			;	pop hl 
1474 3e 35			ld a, display_row_2+13 
1476 2a 20 eb			ld hl,(cli_origptr) 
1479 cd 25 14			call display_word_at 
147c			; 
147c			;	 
147c			;	; display de 
147c			 
147c			;	ld de, .regstatede 
147c			;	ld a, display_row_3 
147c			;	call str_at_display 
147c			 
147c			;	pop de 
147c			;	ld h,d 
147c			;	ld l, e 
147c			;	ld a, display_row_3+3 
147c			;	call display_word_at 
147c			 
147c			 
147c				; display bc 
147c			 
147c			;	ld de, .regstatebc 
147c			;	ld a, display_row_3+10 
147c			;	call str_at_display 
147c			 
147c			;	pop bc 
147c			;	ld h,b 
147c			;	ld l, c 
147c			;	ld a, display_row_3+13 
147c			;	call display_word_at 
147c			 
147c			 
147c				; display dsp 
147c			 
147c			;	ld de, .regstatedsp 
147c			;	ld a, display_row_4 
147c			;	call str_at_display 
147c			 
147c				 
147c			;	ld hl,(cli_data_sp) 
147c			;	ld a, display_row_4+4 
147c			;	call display_word_at 
147c			 
147c				; display rsp 
147c			 
147c 11 5f 16			ld de, .regstatersp 
147f 3e 82			ld a, display_row_4+10 
1481 cd 85 0a			call str_at_display 
1484			 
1484				 
1484 2a 08 eb			ld hl,(cli_ret_sp) 
1487 3e 86			ld a, display_row_4+14 
1489 cd 25 14			call display_word_at 
148c			 
148c cd 95 0a			call update_display 
148f			 
148f cd e4 09			call delay1s 
1492 cd e4 09			call delay1s 
1495 cd e4 09			call delay1s 
1498			 
1498			 
1498 cd 83 1a			call next_page_prompt 
149b			 
149b				; restore  
149b			 
149b f1				pop af 
149c e1				pop hl 
149d c1				pop bc 
149e d1				pop de 
149f c9				ret 
14a0			 
14a0			break_point_state: 
14a0 f5				push af 
14a1			 
14a1				; see if disabled 
14a1			 
14a1 3a c8 e3			ld a, (os_view_disable) 
14a4 fe 2a			cp '*' 
14a6 20 02			jr nz, .bpsgo 
14a8 f1				pop af 
14a9 c9				ret 
14aa			 
14aa			.bpsgo: 
14aa f1				pop af 
14ab f5				push af 
14ac 22 c4 e3			ld (os_view_hl), hl 
14af ed 53 c2 e3		ld (os_view_de), de 
14b3 ed 43 c0 e3		ld (os_view_bc), bc 
14b7 e5				push hl 
14b8 6f				ld l, a 
14b9 26 00			ld h, 0 
14bb 22 c6 e3			ld (os_view_af),hl 
14be			 
14be 21 b7 ed				ld hl, display_fb0 
14c1 22 d2 eb				ld (display_fb_active), hl 
14c4 e1				pop hl	 
14c5			 
14c5 3e 31			ld a, '1' 
14c7 fe 2a		.bps1:  cp '*' 
14c9 20 03			jr nz, .bps1b 
14cb 32 c8 e3			ld (os_view_disable),a 
14ce fe 31		.bps1b:  cp '1' 
14d0 20 14			jr nz, .bps2 
14d2			 
14d2				; display reg 
14d2			 
14d2				 
14d2			 
14d2 3a c6 e3			ld a, (os_view_af) 
14d5 2a c4 e3			ld hl, (os_view_hl) 
14d8 ed 5b c2 e3		ld de, (os_view_de) 
14dc ed 4b c0 e3		ld bc, (os_view_bc) 
14e0 cd 7a 15			call display_reg_state 
14e3 c3 66 15			jp .bpschk 
14e6			 
14e6 fe 32		.bps2:  cp '2' 
14e8 20 08			jr nz, .bps3 
14ea				 
14ea				; display hl 
14ea 2a c4 e3			ld hl, (os_view_hl) 
14ed cd 64 16			call display_dump_at_hl 
14f0			 
14f0 18 74			jr .bpschk 
14f2			 
14f2 fe 33		.bps3:  cp '3' 
14f4 20 08			jr nz, .bps4 
14f6			 
14f6			        ; display de 
14f6 2a c2 e3			ld hl, (os_view_de) 
14f9 cd 64 16			call display_dump_at_hl 
14fc			 
14fc 18 68			jr .bpschk 
14fe fe 34		.bps4:  cp '4' 
1500 20 08			jr nz, .bps5 
1502			 
1502			        ; display bc 
1502 2a c0 e3			ld hl, (os_view_bc) 
1505 cd 64 16			call display_dump_at_hl 
1508			 
1508 18 5c			jr .bpschk 
150a fe 35		.bps5:  cp '5' 
150c 20 08		        jr nz, .bps7 
150e			 
150e				; display cur ptr 
150e 2a 22 eb			ld hl, (cli_ptr) 
1511 cd 64 16			call display_dump_at_hl 
1514			 
1514 18 50			jr .bpschk 
1516 fe 36		.bps7:  cp '6' 
1518 20 08			jr nz, .bps8b 
151a				 
151a				; display cur orig ptr 
151a 2a 20 eb			ld hl, (cli_origptr) 
151d cd 64 16			call display_dump_at_hl 
1520 18 44			jr .bpschk 
1522 fe 37		.bps8b:  cp '7' 
1524 20 08			jr nz, .bps9 
1526				 
1526				; display dsp 
1526 2a 04 eb			ld hl, (cli_data_sp) 
1529 cd 64 16			call display_dump_at_hl 
152c			 
152c 18 38			jr .bpschk 
152e fe 39		.bps9:  cp '9' 
1530 20 05			jr nz, .bps8c 
1532				 
1532				; display SP 
1532			;	ld hl, sp 
1532 cd 64 16			call display_dump_at_hl 
1535			 
1535 18 2f			jr .bpschk 
1537 fe 38		.bps8c:  cp '8' 
1539 20 08			jr nz, .bps8d 
153b				 
153b				; display rsp 
153b 2a 08 eb			ld hl, (cli_ret_sp) 
153e cd 64 16			call display_dump_at_hl 
1541			 
1541 18 23			jr .bpschk 
1543 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1545 20 05			jr nz, .bps8 
1547 cd 79 18			call monitor 
154a			 
154a 18 1a			jr .bpschk 
154c fe 30		.bps8:  cp '0' 
154e 20 16			jr nz, .bpschk 
1550			 
1550 21 16 ed				ld hl, display_fb1 
1553 22 d2 eb				ld (display_fb_active), hl 
1556 cd 95 0a				call update_display 
1559			 
1559				;ld a, (os_view_af) 
1559 2a c4 e3			ld hl, (os_view_hl) 
155c ed 5b c2 e3		ld de, (os_view_de) 
1560 ed 4b c0 e3		ld bc, (os_view_bc) 
1564 f1				pop af 
1565 c9				ret 
1566			 
1566			.bpschk:   
1566 cd e4 09			call delay1s 
1569 3e 9f		ld a,display_row_4 + display_cols - 1 
156b 11 81 1a		        ld de, endprg 
156e cd 85 0a			call str_at_display 
1571 cd 95 0a			call update_display 
1574 cd 57 5a			call cin_wait 
1577			 
1577 c3 c7 14			jp .bps1 
157a			 
157a			 
157a			display_reg_state: 
157a			 
157a				; to restore afterwards 
157a			 
157a d5				push de 
157b c5				push bc 
157c e5				push hl 
157d f5				push af 
157e			 
157e				; for use in here 
157e			 
157e c5				push bc 
157f d5				push de 
1580 e5				push hl 
1581 f5				push af 
1582			 
1582 cd 72 0a			call clear_display 
1585			 
1585 11 3a 16			ld de, .regstate 
1588 3e 00			ld a, display_row_1 
158a cd 85 0a			call str_at_display 
158d			 
158d				; display debug step 
158d			 
158d			 
158d 11 71 ee			ld de, debug_mark 
1590 3e 25			ld a, display_row_1+display_cols-3 
1592 cd 85 0a			call str_at_display 
1595			 
1595				; display a 
1595 11 56 16			ld de, .regstatea 
1598 3e 28			ld a, display_row_2 
159a cd 85 0a			call str_at_display 
159d			 
159d e1				pop hl 
159e			;	ld h,0 
159e			;	ld l, a 
159e 3e 2b			ld a, display_row_2+3 
15a0 cd 25 14			call display_word_at 
15a3			 
15a3			 
15a3				; display hl 
15a3			 
15a3			 
15a3 11 4a 16			ld de, .regstatehl 
15a6 3e 32			ld a, display_row_2+10 
15a8 cd 85 0a			call str_at_display 
15ab			 
15ab e1				pop hl 
15ac 3e 35			ld a, display_row_2+13 
15ae cd 25 14			call display_word_at 
15b1			 
15b1				 
15b1				; display de 
15b1			 
15b1 11 4e 16			ld de, .regstatede 
15b4 3e 50			ld a, display_row_3 
15b6 cd 85 0a			call str_at_display 
15b9			 
15b9 e1				pop hl 
15ba			;	ld h,d 
15ba			;	ld l, e 
15ba 3e 53			ld a, display_row_3+3 
15bc cd 25 14			call display_word_at 
15bf			 
15bf			 
15bf				; display bc 
15bf			 
15bf 11 52 16			ld de, .regstatebc 
15c2 3e 5a			ld a, display_row_3+10 
15c4 cd 85 0a			call str_at_display 
15c7			 
15c7 e1				pop hl 
15c8			;	ld h,b 
15c8			;	ld l, c 
15c8 3e 5d			ld a, display_row_3+13 
15ca cd 25 14			call display_word_at 
15cd			 
15cd			 
15cd				; display dsp 
15cd			 
15cd 11 5a 16			ld de, .regstatedsp 
15d0 3e 78			ld a, display_row_4 
15d2 cd 85 0a			call str_at_display 
15d5			 
15d5				 
15d5 2a 04 eb			ld hl,(cli_data_sp) 
15d8 3e 7c			ld a, display_row_4+4 
15da cd 25 14			call display_word_at 
15dd			 
15dd				; display rsp 
15dd			 
15dd 11 5f 16			ld de, .regstatersp 
15e0 3e 82			ld a, display_row_4+10 
15e2 cd 85 0a			call str_at_display 
15e5			 
15e5				 
15e5 2a 08 eb			ld hl,(cli_ret_sp) 
15e8 3e 86			ld a, display_row_4+14 
15ea cd 25 14			call display_word_at 
15ed			 
15ed cd 95 0a			call update_display 
15f0			 
15f0			;	call delay1s 
15f0			;	call delay1s 
15f0			;	call delay1s 
15f0			 
15f0			 
15f0			;	call next_page_prompt 
15f0			 
15f0				; restore  
15f0			 
15f0 f1				pop af 
15f1 e1				pop hl 
15f2 c1				pop bc 
15f3 d1				pop de 
15f4 c9				ret 
15f5			 
15f5 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1609 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
161e .. 00		.ptrstate:	db "Ptr State",0 
1628 .. 00		.ptrcliptr:     db "cli_ptr",0 
1630 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
163a .. 00		.regstate:	db "Reg State (1/0)",0 
164a .. 00		.regstatehl:	db "HL:",0 
164e .. 00		.regstatede:	db "DE:",0 
1652 .. 00		.regstatebc:	db "BC:",0 
1656 .. 00		.regstatea:	db "A :",0 
165a .. 00		.regstatedsp:	db "DSP:",0 
165f .. 00		.regstatersp:	db "RSP:",0 
1664			 
1664			display_dump_at_hl: 
1664 e5				push hl 
1665 d5				push de 
1666 c5				push bc 
1667 f5				push af 
1668			 
1668 22 fa e6			ld (os_cur_ptr),hl	 
166b cd 72 0a			call clear_display 
166e cd 8b 19			call dumpcont 
1671			;	call delay1s 
1671			;	call next_page_prompt 
1671			 
1671			 
1671 f1				pop af 
1672 c1				pop bc 
1673 d1				pop de 
1674 e1				pop hl 
1675 c9				ret 
1676			 
1676			;if ENABLE_BASIC 
1676			;	include "nascombasic.asm" 
1676			;	basic: 
1676			;	include "forth/FORTH.ASM" 
1676			;endif 
1676			 
1676			; eof 
1676			 
1676			 
# End of file firmware_diags.asm
1676			  
1676			include "firmware_prompts.asm"  
1676			; Prompts  
1676			 
1676			; boot messages 
1676			 
1676 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
168b .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
169b			 
169b			 
169b			; config menus 
169b			 
169b .. 00		prom_c3: db "Add Dictionary To File",0 
16b2 .. 00		prom_c2: db "Select Autoload File",0 
16c7 .. 00		prom_c2a: db "Disable Autoload File", 0 
16dd .. 00		prom_c2b: db "Select Storage Bank",0 
16f1 .. 00		prom_c4: db "Settings",0 
16fa .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1715 .. 00		prom_m4b:   db "Monitor",0 
171d .. 00		prom_c1: db "Hardware Diags",0 
172c			 
172c			 
172c .. 00		prom_notav:    db "Feature not available",0 
1742 .. 00		prom_empty:    db "",0 
1743			 
1743			; eof 
1743			 
# End of file firmware_prompts.asm
1743			  
1743			  
1743			; eof  
1743			  
# End of file firmware.asm
1743			 
1743			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1743			;if BASE_KEV  
1743			;baseram: equ 08000h 
1743			;endif 
1743			 
1743			;if BASE_SC114 
1743			;baseram:     equ    endofcode 
1743			;endif 
1743			 
1743			 
1743			; start system 
1743			 
1743			coldstart: 
1743				; set sp 
1743				; di/ei 
1743			 
1743 f3				di 
1744 31 00 f0			ld sp, tos 
1747			;	ei 
1747			 
1747			 
1747				; disable breakpoint by default 
1747			 
1747 3e 2a			ld a,'*' 
1749 32 c8 e3			ld (os_view_disable),a 
174c			 
174c				; init hardware 
174c			 
174c				; init keyboard and screen hardware 
174c			 
174c cd 1c 01			call hardware_init 
174f			 
174f			 
174f cd e4 09			call delay1s 
1752 3e 58			ld a, display_row_3+8 
1754 11 03 01			ld de, .buildtime 
1757 cd 85 0a			call str_at_display 
175a cd 95 0a			call update_display 
175d			 
175d cd e4 09			call delay1s 
1760			 
1760				; detect if any keys are held down to enable breakpoints at start up 
1760			 
1760 cd 5f 5a			call cin  
1763 fe 00			cp 0 
1765 28 03			jr z, .nokeys 
1767			 
1767				;call hardware_diags 
1767 cd ff 12			call config 
176a			 
176a			;	ld de, .bpen 
176a			;	ld a, display_row_4 
176a			;	call str_at_display 
176a			;	call update_display 
176a			; 
176a			;	ld a,0 
176a			;	ld (os_view_disable),a 
176a			; 
176a			;.bpwait: 
176a			;	call cin 
176a			;	cp 0 
176a			;	jr z, .bpwait 
176a			;	jr .nokeys 
176a			; 
176a			; 
176a			;.bpen:  db "Break points enabled!",0 
176a			 
176a			 
176a			 
176a			 
176a			 
176a			 
176a			.nokeys: 
176a			 
176a			 
176a				 
176a			 
176a			;jp  testkey 
176a			 
176a			;call storage_get_block_0 
176a			; 
176a			;ld hl, 0 
176a			;ld de, store_page 
176a			;call storage_read_block 
176a			 
176a				 
176a			;ld hl, 10 
176a			;ld de, store_page 
176a			;call storage_read_block 
176a			 
176a			 
176a			 
176a			 
176a			 
176a			;stop:	nop 
176a			;	jp stop 
176a			 
176a			 
176a			 
176a			main: 
176a cd 72 0a			call clear_display 
176d cd 95 0a			call update_display 
1770			 
1770			 
1770			 
1770			;	call testlcd 
1770			 
1770			 
1770			 
1770 cd 49 1e			call forth_init 
1773			 
1773			 
1773			warmstart: 
1773 cd 1f 1e			call forth_warmstart 
1776			 
1776				; run startup word load 
1776			        ; TODO prevent this running at warmstart after crash  
1776			 
1776				if STARTUP_ENABLE 
1776					if STORAGE_SE 
1776						call forth_autoload 
1776					endif 
1776 cd a5 56				call forth_startup 
1779			 
1779			 
1779				endif 
1779			 
1779				; show free memory after boot 
1779 11 13 18			ld de, freeram 
177c 3e 00			ld a, display_row_1 
177e cd 85 0a			call str_at_display 
1781			 
1781			; Or use heap_size word???? 
1781 21 bd e3			ld hl, heap_end 
1784 11 87 5a			ld de, heap_start 
1787 ed 52			sbc hl, de 
1789 e5				push hl 
178a 7c				ld a,h	         	 
178b 21 dc e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
178e cd a0 0f			call hexout 
1791 e1			   	pop hl 
1792			 
1792 7d				ld a,l 
1793 21 de e6			ld hl, os_word_scratch+2 
1796 cd a0 0f			call hexout 
1799 21 e0 e6			ld hl, os_word_scratch+4 
179c 3e 00			ld a, 0 
179e 77				ld (hl),a 
179f 11 dc e6			ld de, os_word_scratch 
17a2 3e 0d			ld a, display_row_1 + 13 
17a4 cd 85 0a			call str_at_display 
17a7 cd 95 0a			call update_display 
17aa			 
17aa			 
17aa				;call demo 
17aa			 
17aa			 
17aa				; init scratch input area for cli commands 
17aa			 
17aa 21 fe e6			ld hl, os_cli_cmd 
17ad 3e 00			ld a,0 
17af 77				ld (hl),a 
17b0 23				inc hl 
17b1 77				ld (hl),a 
17b2			 
17b2 3e 00			ld a,0 
17b4 32 fd e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17b7			 
17b7 32 fa e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17ba 32 fb e6			ld (os_cur_ptr+1),a	 
17bd			 
17bd 32 dc e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17c0 32 dd e6			ld (os_word_scratch+1),a	 
17c3				 
17c3			 
17c3				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17c3 21 fe e6			ld hl, os_cli_cmd 
17c6			 
17c6 3e 00			ld a, 0		 ; init cli input 
17c8 77				ld (hl), a 
17c9 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17cb			cli: 
17cb				; show cli prompt 
17cb				;push af 
17cb				;ld a, 0 
17cb				;ld de, prompt 
17cb				;call str_at_display 
17cb			 
17cb				;call update_display 
17cb				;pop af 
17cb				;inc a 
17cb				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17cb 0e 00			ld c, 0 
17cd 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17cf 1e 28			ld e, 40 
17d1			 
17d1 21 fe e6			ld hl, os_cli_cmd 
17d4			 
17d4				STACKFRAME OFF $fefe $9f9f 
17d4				if DEBUG_STACK_IMB 
17d4					if OFF 
17d4						exx 
17d4						ld de, $fefe 
17d4						ld a, d 
17d4						ld hl, curframe 
17d4						call hexout 
17d4						ld a, e 
17d4						ld hl, curframe+2 
17d4						call hexout 
17d4						ld hl, $fefe 
17d4						push hl 
17d4						ld hl, $9f9f 
17d4						push hl 
17d4						exx 
17d4					endif 
17d4				endif 
17d4			endm 
# End of macro STACKFRAME
17d4			 
17d4 cd cc 0c			call input_str 
17d7			 
17d7				STACKFRAMECHK OFF $fefe $9f9f 
17d7				if DEBUG_STACK_IMB 
17d7					if OFF 
17d7						exx 
17d7						ld hl, $9f9f 
17d7						pop de   ; $9f9f 
17d7						call cmp16 
17d7						jr nz, .spnosame 
17d7						ld hl, $fefe 
17d7						pop de   ; $fefe 
17d7						call cmp16 
17d7						jr z, .spfrsame 
17d7						.spnosame: call showsperror 
17d7						.spfrsame: nop 
17d7						exx 
17d7					endif 
17d7				endif 
17d7			endm 
# End of macro STACKFRAMECHK
17d7			 
17d7				; copy input to last command 
17d7			 
17d7 21 fe e6			ld hl, os_cli_cmd 
17da 11 fd e7			ld de, os_last_cmd 
17dd 01 ff 00			ld bc, 255 
17e0 ed b0			ldir 
17e2			 
17e2				; wipe current buffer 
17e2			 
17e2			;	ld a, 0 
17e2			;	ld hl, os_cli_cmd 
17e2			;	ld de, os_cli_cmd+1 
17e2			;	ld bc, 254 
17e2			;	ldir 
17e2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17e2			;	call strcpy 
17e2			;	ld a, 0 
17e2			;	ld (hl), a 
17e2			;	inc hl 
17e2			;	ld (hl), a 
17e2			;	inc hl 
17e2			;	ld (hl), a 
17e2			 
17e2				; switch frame buffer to program  
17e2			 
17e2 21 16 ed				ld hl, display_fb1 
17e5 22 d2 eb				ld (display_fb_active), hl 
17e8			 
17e8			;	nop 
17e8				STACKFRAME ON $fbfe $8f9f 
17e8				if DEBUG_STACK_IMB 
17e8					if ON 
17e8						exx 
17e8						ld de, $fbfe 
17e8						ld a, d 
17e8						ld hl, curframe 
17e8						call hexout 
17e8						ld a, e 
17e8						ld hl, curframe+2 
17e8						call hexout 
17e8						ld hl, $fbfe 
17e8						push hl 
17e8						ld hl, $8f9f 
17e8						push hl 
17e8						exx 
17e8					endif 
17e8				endif 
17e8			endm 
# End of macro STACKFRAME
17e8				; first time into the parser so pass over the current scratch pad 
17e8 21 fe e6			ld hl,os_cli_cmd 
17eb				; tokenise the entered statement(s) in HL 
17eb cd c2 1e			call forthparse 
17ee			        ; exec forth statements in top of return stack 
17ee cd 02 1f			call forthexec 
17f1				;call forthexec_cleanup 
17f1			;	call parsenext 
17f1			 
17f1				STACKFRAMECHK ON $fbfe $8f9f 
17f1				if DEBUG_STACK_IMB 
17f1					if ON 
17f1						exx 
17f1						ld hl, $8f9f 
17f1						pop de   ; $8f9f 
17f1						call cmp16 
17f1						jr nz, .spnosame 
17f1						ld hl, $fbfe 
17f1						pop de   ; $fbfe 
17f1						call cmp16 
17f1						jr z, .spfrsame 
17f1						.spnosame: call showsperror 
17f1						.spfrsame: nop 
17f1						exx 
17f1					endif 
17f1				endif 
17f1			endm 
# End of macro STACKFRAMECHK
17f1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
17f1			 
17f1 3e 78			ld a, display_row_4 
17f3 11 25 18			ld de, endprog 
17f6			 
17f6 cd 95 0a			call update_display		 
17f9			 
17f9 cd 83 1a			call next_page_prompt 
17fc			 
17fc				; switch frame buffer to cli 
17fc			 
17fc 21 b7 ed				ld hl, display_fb0 
17ff 22 d2 eb				ld (display_fb_active), hl 
1802			 
1802			 
1802 cd 72 0a		        call clear_display 
1805 cd 95 0a			call update_display		 
1808			 
1808 21 fe e6			ld hl, os_cli_cmd 
180b			 
180b 3e 00			ld a, 0		 ; init cli input 
180d 77				ld (hl), a 
180e			 
180e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
180e			 
180e				; now on last line 
180e			 
180e				; TODO scroll screen up 
180e			 
180e				; TODO instead just clear screen and place at top of screen 
180e			 
180e			;	ld a, 0 
180e			;	ld (f_cursor_ptr),a 
180e			 
180e				;call clear_display 
180e				;call update_display 
180e			 
180e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
180e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1810 c3 cb 17			jp cli 
1813			 
1813 .. 00		freeram: db "Free bytes: $",0 
1821 ..			asc: db "1A2F" 
1825 .. 00		endprog: db "End prog...",0 
1831			 
1831			testenter2:   
1831 21 09 e4			ld hl,scratch+50 
1834 22 fa e6			ld (os_cur_ptr),hl 
1837 c3 cb 17			jp cli 
183a			 
183a			testenter:  
183a			 
183a 21 21 18			ld hl,asc 
183d			;	ld a,(hl) 
183d			;	call nibble2val 
183d cd f6 0f			call get_byte 
1840			 
1840			 
1840			;	ld a,(hl) 
1840			;	call atohex 
1840			 
1840			;	call fourehexhl 
1840 32 09 e4			ld (scratch+50),a 
1843			 
1843			 
1843			 
1843 21 23 18			ld hl,asc+2 
1846			;	ld a, (hl) 
1846			;	call nibble2val 
1846 cd f6 0f			call get_byte 
1849			 
1849			;	call fourehexhl 
1849 32 0b e4			ld (scratch+52),a 
184c				 
184c 21 09 e4			ld hl,scratch+50 
184f 22 fa e6			ld (os_cur_ptr),hl 
1852 c3 cb 17			jp cli 
1855			 
1855			enter:	 
1855 3a db e3			ld a,(scratch+4) 
1858 fe 00			cp 0 
185a 28 0c			jr z, .entercont 
185c				; no, not a null term line so has an address to work out.... 
185c			 
185c 21 d9 e3			ld hl,scratch+2 
185f cd 56 10			call get_word_hl 
1862			 
1862 22 fa e6			ld (os_cur_ptr),hl	 
1865 c3 cb 17			jp cli 
1868			 
1868			 
1868			.entercont:  
1868			 
1868 21 d9 e3			ld hl, scratch+2 
186b cd f6 0f			call get_byte 
186e			 
186e 2a fa e6		   	ld hl,(os_cur_ptr) 
1871 77					ld (hl),a 
1872 23					inc hl 
1873 22 fa e6				ld (os_cur_ptr),hl 
1876				 
1876			; get byte  
1876			 
1876			 
1876 c3 cb 17			jp cli 
1879			 
1879			 
1879			; basic monitor support 
1879			 
1879			monitor: 
1879				;  
1879 cd 72 0a			call clear_display 
187c 3e 00			ld a, 0 
187e 11 c6 18			ld de, .monprompt 
1881 cd 85 0a			call str_at_display 
1884 cd 95 0a			call update_display 
1887			 
1887				; get a monitor command 
1887			 
1887 0e 00			ld c, 0     ; entry at top left 
1889 16 64			ld d, 100   ; max buffer size 
188b 1e 0f			ld e, 15    ; input scroll area 
188d 3e 00			ld a, 0     ; init string 
188f 21 d5 e5			ld hl, os_input 
1892 77				ld (hl), a 
1893 23				inc hl 
1894 77				ld (hl), a 
1895 21 d5 e5			ld hl, os_input 
1898 3e 01			ld a, 1     ; init string 
189a cd cc 0c			call input_str 
189d			 
189d cd 72 0a		        call clear_display 
18a0 cd 95 0a			call update_display		 
18a3			 
18a3 3a d5 e5			ld a, (os_input) 
18a6 cd f4 10			call toUpper 
18a9 fe 48		        cp 'H' 
18ab 28 6f		        jr z, .monhelp 
18ad fe 44			cp 'D'		; dump 
18af ca 3d 19			jp z, .mondump	 
18b2 fe 43			cp 'C'		; dump 
18b4 ca 57 19			jp z, .moncdump	 
18b7 fe 4d			cp 'M'		; dump 
18b9 ca c8 18			jp z, .moneditstart 
18bc fe 55			cp 'U'		; dump 
18be 28 14			jr z, .monedit	 
18c0 fe 51			cp 'Q'		; dump 
18c2 c8				ret z	 
18c3			 
18c3			 
18c3				; TODO "S" to access symbol by name and not need the address 
18c3				; TODO "F" to find a string in memory 
18c3			 
18c3 c3 79 18			jp monitor 
18c6			 
18c6 .. 00		.monprompt: db ">", 0 
18c8			 
18c8			.moneditstart: 
18c8				; get starting address 
18c8			 
18c8 21 d7 e5			ld hl,os_input+2 
18cb cd 56 10			call get_word_hl 
18ce			 
18ce 22 fa e6			ld (os_cur_ptr),hl	 
18d1			 
18d1 c3 79 18			jp monitor 
18d4			 
18d4			.monedit: 
18d4				; get byte to load 
18d4			 
18d4 21 d7 e5			ld hl,os_input+2 
18d7 cd f6 0f			call get_byte 
18da			 
18da				; get address to update 
18da 2a fa e6			ld hl, (os_cur_ptr) 
18dd			 
18dd				; update byte 
18dd			 
18dd 77				ld (hl), a 
18de			 
18de				; move to next address and save it 
18de			 
18de 23				inc hl 
18df 22 fa e6			ld (os_cur_ptr),hl	 
18e2			 
18e2 c3 79 18			jp monitor 
18e5			 
18e5			 
18e5 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
18f9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1915 .. 00		.monhelptext3:  db "Q-Quit",0 
191c			        
191c			.monhelp: 
191c 3e 00			ld a, display_row_1 
191e 11 e5 18		        ld de, .monhelptext1 
1921			 
1921 cd 85 0a			call str_at_display 
1924 3e 28			ld a, display_row_2 
1926 11 f9 18		        ld de, .monhelptext2 
1929					 
1929 cd 85 0a			call str_at_display 
192c 3e 50			ld a, display_row_3 
192e 11 15 19		        ld de, .monhelptext3 
1931					 
1931 cd 85 0a			call str_at_display 
1934 cd 95 0a			call update_display		 
1937			 
1937 cd 83 1a			call next_page_prompt 
193a c3 79 18			jp monitor 
193d			 
193d			.mondump:    
193d 21 d7 e5			ld hl,os_input+2 
1940 cd 56 10			call get_word_hl 
1943			 
1943 22 fa e6			ld (os_cur_ptr),hl	 
1946 cd 8b 19			call dumpcont 
1949 3e 78			ld a, display_row_4 
194b 11 25 18			ld de, endprog 
194e			 
194e cd 95 0a			call update_display		 
1951			 
1951 cd 83 1a			call next_page_prompt 
1954 c3 79 18			jp monitor 
1957			.moncdump: 
1957 cd 8b 19			call dumpcont 
195a 3e 78			ld a, display_row_4 
195c 11 25 18			ld de, endprog 
195f			 
195f cd 95 0a			call update_display		 
1962			 
1962 cd 83 1a			call next_page_prompt 
1965 c3 79 18			jp monitor 
1968			 
1968			 
1968			; TODO symbol access  
1968			 
1968			.symbols:     ;; A list of symbols that can be called up  
1968 b7 ed			dw display_fb0 
196a .. 00			db "fb0",0  
196e 5c eb		     	dw store_page 
1970 .. 00			db "store_page",0 
197b			 
197b			 
197b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
197b			 
197b 3a d8 e3			ld a,(scratch+1) 
197e fe 00			cp 0 
1980 28 09			jr z, dumpcont 
1982			 
1982				; no, not a null term line so has an address to work out.... 
1982			 
1982 21 d9 e3			ld hl,scratch+2 
1985 cd 56 10			call get_word_hl 
1988			 
1988 22 fa e6			ld (os_cur_ptr),hl	 
198b			 
198b			 
198b			 
198b			dumpcont: 
198b			 
198b				; dump bytes at ptr 
198b			 
198b			 
198b 3e 00			ld a, display_row_1 
198d 2a d2 eb			ld hl, (display_fb_active) 
1990 cd 9f 0c			call addatohl 
1993 cd bb 19			call .dumpbyterow 
1996			 
1996 3e 28			ld a, display_row_2 
1998 2a d2 eb			ld hl, (display_fb_active) 
199b cd 9f 0c			call addatohl 
199e cd bb 19			call .dumpbyterow 
19a1			 
19a1			 
19a1 3e 50			ld a, display_row_3 
19a3 2a d2 eb			ld hl, (display_fb_active) 
19a6 cd 9f 0c			call addatohl 
19a9 cd bb 19			call .dumpbyterow 
19ac			 
19ac 3e 78			ld a, display_row_4 
19ae 2a d2 eb			ld hl, (display_fb_active) 
19b1 cd 9f 0c			call addatohl 
19b4 cd bb 19			call .dumpbyterow 
19b7			 
19b7 cd 95 0a			call update_display 
19ba			;		jp cli 
19ba c9				ret 
19bb			 
19bb			.dumpbyterow: 
19bb			 
19bb				;push af 
19bb			 
19bb e5				push hl 
19bc			 
19bc				; calc where to poke the ascii 
19bc			if display_cols == 20 
19bc				ld a, 16 
19bc			else 
19bc 3e 1f			ld a, 31 
19be			endif 
19be			 
19be cd 9f 0c			call addatohl 
19c1 22 dc e6			ld (os_word_scratch),hl  		; save pos for later 
19c4			 
19c4			 
19c4			; display decoding address 
19c4 2a fa e6		   	ld hl,(os_cur_ptr) 
19c7			 
19c7 7c				ld a,h 
19c8 e1				pop hl 
19c9 e5				push hl 
19ca			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
19ca cd a0 0f			call hexout 
19cd 2a fa e6		   	ld hl,(os_cur_ptr) 
19d0			 
19d0 7d				ld a,l 
19d1 e1				pop hl 
19d2 23				inc hl 
19d3 23				inc hl 
19d4 e5				push hl 
19d5			;	ld hl, os_word_scratch+2 
19d5 cd a0 0f			call hexout 
19d8 e1				pop hl 
19d9 23				inc hl 
19da 23				inc hl 
19db				;ld hl, os_word_scratch+4 
19db 3e 3a			ld a, ':' 
19dd 77				ld (hl),a 
19de 23				inc hl 
19df				;ld a, 0 
19df				;ld (hl),a 
19df				;ld de, os_word_scratch 
19df				;pop af 
19df				;push af 
19df			;		ld a, display_row_2 
19df			;		call str_at_display 
19df			;		call update_display 
19df			 
19df			 
19df			;pop af 
19df			;	add 5 
19df			 
19df			if display_cols == 20 
19df				ld b, 4 
19df			else 
19df 06 08			ld b, 8 
19e1			endif	 
19e1			 
19e1			.dumpbyte: 
19e1 c5				push bc 
19e2 e5				push hl 
19e3			 
19e3			 
19e3 2a fa e6		   	ld hl,(os_cur_ptr) 
19e6 7e					ld a,(hl) 
19e7			 
19e7					; poke the ascii to display 
19e7 2a dc e6				ld hl,(os_word_scratch) 
19ea 77					ld (hl),a 
19eb 23					inc hl 
19ec 22 dc e6				ld (os_word_scratch),hl 
19ef			 
19ef					 
19ef			 
19ef			 
19ef e1					pop hl 
19f0 e5					push hl 
19f1			 
19f1 cd a0 0f				call hexout 
19f4			 
19f4					 
19f4 2a fa e6		   	ld hl,(os_cur_ptr) 
19f7 23				inc hl 
19f8 22 fa e6		   	ld (os_cur_ptr),hl 
19fb			 
19fb e1					pop hl 
19fc 23					inc hl 
19fd 23					inc hl 
19fe 23					inc hl 
19ff			 
19ff			 
19ff			 
19ff					;ld a,0 
19ff					;ld (os_word_scratch+2),a 
19ff					;pop af 
19ff					;push af 
19ff			 
19ff					;ld de, os_word_scratch 
19ff					;call str_at_display 
19ff			;		call update_display 
19ff			;		pop af 
19ff c1					pop bc 
1a00 c6 03				add 3 
1a02 10 dd			djnz .dumpbyte 
1a04			 
1a04				 
1a04			 
1a04 c9				ret 
1a05			 
1a05			jump:	 
1a05			 
1a05 21 d9 e3			ld hl,scratch+2 
1a08 cd 56 10			call get_word_hl 
1a0b				;ld hl,(scratch+2) 
1a0b				;call fourehexhl 
1a0b			 
1a0b 22 fa e6			ld (os_cur_ptr),hl	 
1a0e			 
1a0e e9				jp (hl) 
1a0f			 
1a0f			 
1a0f			 
1a0f			; TODO implement a basic monitor mode to start with 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			 
1a0f			; testing and demo code during development 
1a0f			 
1a0f			 
1a0f .. 00		str1: db "Enter some text...",0 
1a22 .. 00		clear: db "                    ",0 
1a37			 
1a37			demo: 
1a37			 
1a37			 
1a37			 
1a37			;	call update_display 
1a37			 
1a37				; init scratch input area for testing 
1a37 21 d7 e3			ld hl, scratch	 
1a3a 3e 00			ld a,0 
1a3c 77				ld (hl),a 
1a3d			 
1a3d			 
1a3d 3e 28		            LD   A, display_row_2 
1a3f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a3f 11 0f 1a		            LD   DE, str1 
1a42 cd 85 0a			call str_at_display 
1a45			 
1a45			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a45			cloop:	 
1a45 3e 50		            LD   A, display_row_3 
1a47			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a47 11 22 1a		            LD   DE, clear 
1a4a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a4a cd 85 0a				call str_at_display 
1a4d 3e 78			ld a, display_row_4 
1a4f 11 7f 1a			ld de, prompt 
1a52			 
1a52 cd 85 0a				call str_at_display 
1a55 cd 95 0a			call update_display 
1a58			 
1a58 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a5a 16 0a			ld d, 10 
1a5c 21 d7 e3			ld hl, scratch	 
1a5f cd cc 0c			call input_str 
1a62			 
1a62			;	call clear_display 
1a62			;'	call update_display 
1a62			 
1a62 3e 00		            LD   A, display_row_1 
1a64			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a64 11 22 1a		            LD   DE, clear 
1a67 cd 85 0a				call str_at_display 
1a6a			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a6a 3e 00		            LD   A, display_row_1 
1a6c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a6c 11 d7 e3		            LD   DE, scratch 
1a6f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a6f cd 85 0a				call str_at_display 
1a72 cd 95 0a			call update_display 
1a75			 
1a75 3e 00				ld a,0 
1a77 21 d7 e3			ld hl, scratch 
1a7a 77				ld (hl),a 
1a7b			 
1a7b 00				nop 
1a7c c3 45 1a			jp cloop 
1a7f			 
1a7f			 
1a7f			 
1a7f			; OS Prompt 
1a7f			 
1a7f .. 00		prompt: db ">",0 
1a81 .. 00		endprg: db "?",0 
1a83			 
1a83			 
1a83			; handy next page prompt 
1a83			next_page_prompt: 
1a83 e5				push hl 
1a84 d5				push de 
1a85 f5				push af 
1a86 c5				push bc 
1a87			 
1a87 3e 9f			ld a,display_row_4 + display_cols - 1 
1a89 11 81 1a		        ld de, endprg 
1a8c cd 85 0a			call str_at_display 
1a8f cd 95 0a			call update_display 
1a92 cd 57 5a			call cin_wait 
1a95 c1				pop bc 
1a96 f1				pop af 
1a97 d1				pop de 
1a98 e1				pop hl 
1a99			 
1a99			 
1a99 c9				ret 
1a9a			 
1a9a			 
1a9a			; forth parser 
1a9a			 
1a9a			; My forth kernel 
1a9a			include "forth_kernel.asm" 
1a9a			; 
1a9a			; kernel to the forth OS 
1a9a			 
1a9a			DS_TYPE_STR: equ 1     ; string type 
1a9a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a9a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a9a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a9a			 
1a9a			FORTH_PARSEV1: equ 0 
1a9a			FORTH_PARSEV2: equ 0 
1a9a			FORTH_PARSEV3: equ 0 
1a9a			FORTH_PARSEV4: equ 0 
1a9a			FORTH_PARSEV5: equ 1 
1a9a			 
1a9a			;if FORTH_PARSEV5 
1a9a			;	FORTH_END_BUFFER: equ 0 
1a9a			;else 
1a9a			FORTH_END_BUFFER: equ 127 
1a9a			;endif 
1a9a			 
1a9a			FORTH_TRUE: equ 1 
1a9a			FORTH_FALSE: equ 0 
1a9a			 
1a9a			if FORTH_PARSEV4 
1a9a			include "forth_stackops.asm" 
1a9a			endif 
1a9a			 
1a9a			if FORTH_PARSEV5 
1a9a			include "forth_stackopsv5.asm" 
1a9a			 
1a9a			; Stack operations for v5 parser on wards 
1a9a			; * DATA stack 
1a9a			; * LOOP stack 
1a9a			; * RETURN stack 
1a9a			 
1a9a			 
1a9a			 
1a9a			FORTH_CHK_DSP_UNDER: macro 
1a9a				push hl 
1a9a				push de 
1a9a				ld hl,(cli_data_sp) 
1a9a				ld de, cli_data_stack 
1a9a				call cmp16 
1a9a				jp c, fault_dsp_under 
1a9a				pop de 
1a9a				pop hl 
1a9a				endm 
1a9a			 
1a9a			 
1a9a			FORTH_CHK_RSP_UNDER: macro 
1a9a				push hl 
1a9a				push de 
1a9a				ld hl,(cli_ret_sp) 
1a9a				ld de, cli_ret_stack 
1a9a				call cmp16 
1a9a				jp c, fault_rsp_under 
1a9a				pop de 
1a9a				pop hl 
1a9a				endm 
1a9a			 
1a9a			FORTH_CHK_LOOP_UNDER: macro 
1a9a				push hl 
1a9a				push de 
1a9a				ld hl,(cli_loop_sp) 
1a9a				ld de, cli_loop_stack 
1a9a				call cmp16 
1a9a				jp c, fault_loop_under 
1a9a				pop de 
1a9a				pop hl 
1a9a				endm 
1a9a			 
1a9a			FORTH_ERR_TOS_NOTSTR: macro 
1a9a				; TOSO might need more for checks when used 
1a9a				push af 
1a9a				ld a,(hl) 
1a9a				cp DS_TYPE_STR 
1a9a				jp nz, type_faultn   
1a9a				pop af 
1a9a				endm 
1a9a			 
1a9a			FORTH_ERR_TOS_NOTNUM: macro 
1a9a				push af 
1a9a				ld a,(hl) 
1a9a				cp DS_TYPE_INUM 
1a9a				jp nz, type_faultn   
1a9a				pop af 
1a9a				endm 
1a9a			 
1a9a			 
1a9a			; increase data stack pointer and save hl to it 
1a9a				 
1a9a			FORTH_DSP_NEXT: macro 
1a9a				call macro_forth_dsp_next 
1a9a				endm 
1a9a			 
1a9a			 
1a9a			macro_forth_dsp_next: 
1a9a				if DEBUG_FORTH_STACK_GUARD 
1a9a cd 6f 57				call check_stacks 
1a9d				endif 
1a9d e5				push hl 
1a9e d5				push de 
1a9f eb				ex de,hl 
1aa0 2a 04 eb			ld hl,(cli_data_sp) 
1aa3 23				inc hl 
1aa4 23				inc hl 
1aa5			 
1aa5			; PARSEV5 
1aa5 23				inc hl 
1aa6 22 04 eb			ld (cli_data_sp),hl 
1aa9 73				ld (hl), e 
1aaa 23				inc hl 
1aab 72				ld (hl), d 
1aac d1				pop de 
1aad e1				pop hl 
1aae				if DEBUG_FORTH_STACK_GUARD 
1aae cd 6f 57				call check_stacks 
1ab1				endif 
1ab1 c9				ret 
1ab2			 
1ab2			 
1ab2			; increase ret stack pointer and save hl to it 
1ab2				 
1ab2			FORTH_RSP_NEXT: macro 
1ab2				call macro_forth_rsp_next 
1ab2				endm 
1ab2			 
1ab2			macro_forth_rsp_next: 
1ab2				if DEBUG_FORTH_STACK_GUARD 
1ab2 cd 6f 57				call check_stacks 
1ab5				endif 
1ab5 e5				push hl 
1ab6 d5				push de 
1ab7 eb				ex de,hl 
1ab8 2a 08 eb			ld hl,(cli_ret_sp) 
1abb 23				inc hl 
1abc 23				inc hl 
1abd 22 08 eb			ld (cli_ret_sp),hl 
1ac0 73				ld (hl), e 
1ac1 23				inc hl 
1ac2 72				ld (hl), d 
1ac3 d1				pop de 
1ac4 e1				pop hl 
1ac5				if DEBUG_FORTH_STACK_GUARD 
1ac5 cd 6f 57				call check_stacks 
1ac8				endif 
1ac8 c9				ret 
1ac9			 
1ac9			; get current ret stack pointer and save to hl  
1ac9				 
1ac9			FORTH_RSP_TOS: macro 
1ac9				call macro_forth_rsp_tos 
1ac9				endm 
1ac9			 
1ac9			macro_forth_rsp_tos: 
1ac9				;push de 
1ac9 2a 08 eb			ld hl,(cli_ret_sp) 
1acc cd 04 1b			call loadhlptrtohl 
1acf				;ld e, (hl) 
1acf				;inc hl 
1acf				;ld d, (hl) 
1acf				;ex de, hl 
1acf					if DEBUG_FORTH_WORDS 
1acf			;			DMARK "RST" 
1acf						CALLMONITOR 
1acf cd a0 14			call break_point_state  
1ad2				endm  
# End of macro CALLMONITOR
1ad2					endif 
1ad2				;pop de 
1ad2 c9				ret 
1ad3			 
1ad3			; pop ret stack pointer 
1ad3				 
1ad3			FORTH_RSP_POP: macro 
1ad3				call macro_forth_rsp_pop 
1ad3				endm 
1ad3			 
1ad3			 
1ad3			macro_forth_rsp_pop: 
1ad3				if DEBUG_FORTH_STACK_GUARD 
1ad3			;		DMARK "RPP" 
1ad3 cd 6f 57				call check_stacks 
1ad6					FORTH_CHK_RSP_UNDER 
1ad6 e5				push hl 
1ad7 d5				push de 
1ad8 2a 08 eb			ld hl,(cli_ret_sp) 
1adb 11 c2 ea			ld de, cli_ret_stack 
1ade cd bd 0c			call cmp16 
1ae1 da 83 58			jp c, fault_rsp_under 
1ae4 d1				pop de 
1ae5 e1				pop hl 
1ae6				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ae6				endif 
1ae6 e5				push hl 
1ae7 2a 08 eb			ld hl,(cli_ret_sp) 
1aea			 
1aea			 
1aea				if FORTH_ENABLE_FREE 
1aea			 
1aea					; get pointer 
1aea			 
1aea					push de 
1aea					push hl 
1aea			 
1aea					ld e, (hl) 
1aea					inc hl 
1aea					ld d, (hl) 
1aea			 
1aea					ex de, hl 
1aea					call free 
1aea			 
1aea					pop hl 
1aea					pop de 
1aea			 
1aea			 
1aea				endif 
1aea			 
1aea			 
1aea 2b				dec hl 
1aeb 2b				dec hl 
1aec 22 08 eb			ld (cli_ret_sp), hl 
1aef				; do stack underflow checks 
1aef e1				pop hl 
1af0				if DEBUG_FORTH_STACK_GUARD 
1af0 cd 6f 57				call check_stacks 
1af3					FORTH_CHK_RSP_UNDER 
1af3 e5				push hl 
1af4 d5				push de 
1af5 2a 08 eb			ld hl,(cli_ret_sp) 
1af8 11 c2 ea			ld de, cli_ret_stack 
1afb cd bd 0c			call cmp16 
1afe da 83 58			jp c, fault_rsp_under 
1b01 d1				pop de 
1b02 e1				pop hl 
1b03				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b03				endif 
1b03 c9				ret 
1b04			 
1b04			 
1b04			 
1b04			; routine to load word pointed to by hl into hl 
1b04			 
1b04			loadhlptrtohl: 
1b04			 
1b04 d5				push de 
1b05 5e				ld e, (hl) 
1b06 23				inc hl 
1b07 56				ld d, (hl) 
1b08 eb				ex de, hl 
1b09 d1				pop de 
1b0a			 
1b0a c9				ret 
1b0b			 
1b0b			 
1b0b			 
1b0b			 
1b0b			 
1b0b			; push a number held in HL onto the data stack 
1b0b			; entry point for pushing a value when already in hl used in function above 
1b0b			 
1b0b			forth_push_numhl: 
1b0b			 
1b0b e5				push hl    ; save value to push 
1b0c			 
1b0c			if DEBUG_FORTH_PUSH 
1b0c				; see if disabled 
1b0c			 
1b0c			 
1b0c f5				push af 
1b0d 3a c8 e3			ld a, (os_view_disable) 
1b10 fe 2a			cp '*' 
1b12 28 34			jr z, .pskip2 
1b14 e5				push hl 
1b15 e5			push hl 
1b16 cd 72 0a			call clear_display 
1b19 e1			pop hl 
1b1a 7c				ld a,h 
1b1b 21 dc e6			ld hl, os_word_scratch 
1b1e cd a0 0f			call hexout 
1b21 e1				pop hl 
1b22 7d				ld a,l 
1b23 21 de e6			ld hl, os_word_scratch+2 
1b26 cd a0 0f			call hexout 
1b29			 
1b29 21 e0 e6			ld hl, os_word_scratch+4 
1b2c 3e 00			ld a,0 
1b2e 77				ld (hl),a 
1b2f 11 dc e6			ld de,os_word_scratch 
1b32 3e 28				ld a, display_row_2 
1b34 cd 85 0a				call str_at_display 
1b37 11 4e 46			ld de, .push_num 
1b3a 3e 00			ld a, display_row_1 
1b3c			 
1b3c cd 85 0a				call str_at_display 
1b3f			 
1b3f			 
1b3f cd 95 0a			call update_display 
1b42 cd e4 09			call delay1s 
1b45 cd e4 09			call delay1s 
1b48			.pskip2:  
1b48			 
1b48 f1				pop af 
1b49			endif	 
1b49			 
1b49			 
1b49				FORTH_DSP_NEXT 
1b49 cd 9a 1a			call macro_forth_dsp_next 
1b4c				endm 
# End of macro FORTH_DSP_NEXT
1b4c			 
1b4c 2a 04 eb			ld hl, (cli_data_sp) 
1b4f			 
1b4f				; save item type 
1b4f 3e 02			ld a,  DS_TYPE_INUM 
1b51 77				ld (hl), a 
1b52 23				inc hl 
1b53			 
1b53				; get word off stack 
1b53 d1				pop de 
1b54 7b				ld a,e 
1b55 77				ld (hl), a 
1b56 23				inc hl 
1b57 7a				ld a,d 
1b58 77				ld (hl), a 
1b59			 
1b59			if DEBUG_FORTH_PUSH 
1b59 2b				dec hl 
1b5a 2b				dec hl 
1b5b 2b				dec hl 
1b5c						DMARK "PH5" 
1b5c f5				push af  
1b5d 3a 71 1b			ld a, (.dmark)  
1b60 32 71 ee			ld (debug_mark),a  
1b63 3a 72 1b			ld a, (.dmark+1)  
1b66 32 72 ee			ld (debug_mark+1),a  
1b69 3a 73 1b			ld a, (.dmark+2)  
1b6c 32 73 ee			ld (debug_mark+2),a  
1b6f 18 03			jr .pastdmark  
1b71 ..			.dmark: db "PH5"  
1b74 f1			.pastdmark: pop af  
1b75			endm  
# End of macro DMARK
1b75				CALLMONITOR 
1b75 cd a0 14			call break_point_state  
1b78				endm  
# End of macro CALLMONITOR
1b78			endif	 
1b78			 
1b78 c9				ret 
1b79			 
1b79			 
1b79			; Push a string to stack pointed to by hl 
1b79			 
1b79			forth_push_str: 
1b79			 
1b79			if DEBUG_FORTH_PUSH 
1b79						DMARK "PSQ" 
1b79 f5				push af  
1b7a 3a 8e 1b			ld a, (.dmark)  
1b7d 32 71 ee			ld (debug_mark),a  
1b80 3a 8f 1b			ld a, (.dmark+1)  
1b83 32 72 ee			ld (debug_mark+1),a  
1b86 3a 90 1b			ld a, (.dmark+2)  
1b89 32 73 ee			ld (debug_mark+2),a  
1b8c 18 03			jr .pastdmark  
1b8e ..			.dmark: db "PSQ"  
1b91 f1			.pastdmark: pop af  
1b92			endm  
# End of macro DMARK
1b92				CALLMONITOR 
1b92 cd a0 14			call break_point_state  
1b95				endm  
# End of macro CALLMONITOR
1b95			endif	 
1b95			    
1b95 e5				push hl 
1b96 e5				push hl 
1b97			 
1b97			;	ld a, 0   ; find end of string 
1b97 cd fd 10			call strlenz 
1b9a			if DEBUG_FORTH_PUSH 
1b9a						DMARK "PQ2" 
1b9a f5				push af  
1b9b 3a af 1b			ld a, (.dmark)  
1b9e 32 71 ee			ld (debug_mark),a  
1ba1 3a b0 1b			ld a, (.dmark+1)  
1ba4 32 72 ee			ld (debug_mark+1),a  
1ba7 3a b1 1b			ld a, (.dmark+2)  
1baa 32 73 ee			ld (debug_mark+2),a  
1bad 18 03			jr .pastdmark  
1baf ..			.dmark: db "PQ2"  
1bb2 f1			.pastdmark: pop af  
1bb3			endm  
# End of macro DMARK
1bb3				CALLMONITOR 
1bb3 cd a0 14			call break_point_state  
1bb6				endm  
# End of macro CALLMONITOR
1bb6			endif	 
1bb6 eb				ex de, hl 
1bb7 e1				pop hl   ; get ptr to start of string 
1bb8			if DEBUG_FORTH_PUSH 
1bb8						DMARK "PQ3" 
1bb8 f5				push af  
1bb9 3a cd 1b			ld a, (.dmark)  
1bbc 32 71 ee			ld (debug_mark),a  
1bbf 3a ce 1b			ld a, (.dmark+1)  
1bc2 32 72 ee			ld (debug_mark+1),a  
1bc5 3a cf 1b			ld a, (.dmark+2)  
1bc8 32 73 ee			ld (debug_mark+2),a  
1bcb 18 03			jr .pastdmark  
1bcd ..			.dmark: db "PQ3"  
1bd0 f1			.pastdmark: pop af  
1bd1			endm  
# End of macro DMARK
1bd1				CALLMONITOR 
1bd1 cd a0 14			call break_point_state  
1bd4				endm  
# End of macro CALLMONITOR
1bd4			endif	 
1bd4 19				add hl,de 
1bd5			if DEBUG_FORTH_PUSH 
1bd5						DMARK "PQE" 
1bd5 f5				push af  
1bd6 3a ea 1b			ld a, (.dmark)  
1bd9 32 71 ee			ld (debug_mark),a  
1bdc 3a eb 1b			ld a, (.dmark+1)  
1bdf 32 72 ee			ld (debug_mark+1),a  
1be2 3a ec 1b			ld a, (.dmark+2)  
1be5 32 73 ee			ld (debug_mark+2),a  
1be8 18 03			jr .pastdmark  
1bea ..			.dmark: db "PQE"  
1bed f1			.pastdmark: pop af  
1bee			endm  
# End of macro DMARK
1bee				CALLMONITOR 
1bee cd a0 14			call break_point_state  
1bf1				endm  
# End of macro CALLMONITOR
1bf1			endif	 
1bf1			 
1bf1 2b				dec hl    ; see if there is an optional trailing double quote 
1bf2 7e				ld a,(hl) 
1bf3 fe 22			cp '"' 
1bf5 20 03			jr nz, .strnoq 
1bf7 3e 00			ld a, 0      ; get rid of double quote 
1bf9 77				ld (hl), a 
1bfa 23			.strnoq: inc hl 
1bfb			 
1bfb 3e 00			ld a, 0 
1bfd 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1bfe			 
1bfe 13				inc de ; add one for the type string 
1bff 13				inc de ; add one for null term??? 
1c00			 
1c00				; tos is get string pointer again 
1c00				; de contains space to allocate 
1c00				 
1c00 d5				push de 
1c01			 
1c01 eb				ex de, hl 
1c02			 
1c02				;push af 
1c02			 
1c02			if DEBUG_FORTH_PUSH 
1c02						DMARK "PHm" 
1c02 f5				push af  
1c03 3a 17 1c			ld a, (.dmark)  
1c06 32 71 ee			ld (debug_mark),a  
1c09 3a 18 1c			ld a, (.dmark+1)  
1c0c 32 72 ee			ld (debug_mark+1),a  
1c0f 3a 19 1c			ld a, (.dmark+2)  
1c12 32 73 ee			ld (debug_mark+2),a  
1c15 18 03			jr .pastdmark  
1c17 ..			.dmark: db "PHm"  
1c1a f1			.pastdmark: pop af  
1c1b			endm  
# End of macro DMARK
1c1b				CALLMONITOR 
1c1b cd a0 14			call break_point_state  
1c1e				endm  
# End of macro CALLMONITOR
1c1e			endif	 
1c1e cd 66 11			call malloc	; on ret hl now contains allocated memory 
1c21				if DEBUG_FORTH_MALLOC_GUARD 
1c21 cc a6 46				call z,malloc_error 
1c24				endif 
1c24			 
1c24				 
1c24 c1				pop bc    ; get length 
1c25 d1				pop de   ;  get string start    
1c26			 
1c26				; hl has destination from malloc 
1c26			 
1c26 eb				ex de, hl    ; prep for ldir 
1c27			 
1c27 d5				push de   ; save malloc area for DSP later 
1c28				;push hl   ; save malloc area for DSP later 
1c28			 
1c28			if DEBUG_FORTH_PUSH 
1c28						DMARK "PHc" 
1c28 f5				push af  
1c29 3a 3d 1c			ld a, (.dmark)  
1c2c 32 71 ee			ld (debug_mark),a  
1c2f 3a 3e 1c			ld a, (.dmark+1)  
1c32 32 72 ee			ld (debug_mark+1),a  
1c35 3a 3f 1c			ld a, (.dmark+2)  
1c38 32 73 ee			ld (debug_mark+2),a  
1c3b 18 03			jr .pastdmark  
1c3d ..			.dmark: db "PHc"  
1c40 f1			.pastdmark: pop af  
1c41			endm  
# End of macro DMARK
1c41				CALLMONITOR 
1c41 cd a0 14			call break_point_state  
1c44				endm  
# End of macro CALLMONITOR
1c44			endif	 
1c44			 
1c44			 
1c44 ed b0			ldir 
1c46			 
1c46			 
1c46				; push malloc to data stack     macro?????  
1c46			 
1c46				FORTH_DSP_NEXT 
1c46 cd 9a 1a			call macro_forth_dsp_next 
1c49				endm 
# End of macro FORTH_DSP_NEXT
1c49			 
1c49				; save value and type 
1c49			 
1c49 2a 04 eb			ld hl, (cli_data_sp) 
1c4c			 
1c4c				; save item type 
1c4c 3e 01			ld a,  DS_TYPE_STR 
1c4e 77				ld (hl), a 
1c4f 23				inc hl 
1c50			 
1c50				; get malloc word off stack 
1c50 d1				pop de 
1c51 73				ld (hl), e 
1c52 23				inc hl 
1c53 72				ld (hl), d 
1c54			 
1c54			 
1c54			 
1c54			if DEBUG_FORTH_PUSH 
1c54 2a 04 eb			ld hl, (cli_data_sp) 
1c57						DMARK "PHS" 
1c57 f5				push af  
1c58 3a 6c 1c			ld a, (.dmark)  
1c5b 32 71 ee			ld (debug_mark),a  
1c5e 3a 6d 1c			ld a, (.dmark+1)  
1c61 32 72 ee			ld (debug_mark+1),a  
1c64 3a 6e 1c			ld a, (.dmark+2)  
1c67 32 73 ee			ld (debug_mark+2),a  
1c6a 18 03			jr .pastdmark  
1c6c ..			.dmark: db "PHS"  
1c6f f1			.pastdmark: pop af  
1c70			endm  
# End of macro DMARK
1c70				CALLMONITOR 
1c70 cd a0 14			call break_point_state  
1c73				endm  
# End of macro CALLMONITOR
1c73			;	ex de,hl 
1c73			endif	 
1c73				; in case of spaces, skip the ptr past the copied string 
1c73				;pop af 
1c73				;ld (cli_origptr),hl 
1c73			 
1c73 c9				ret 
1c74			 
1c74			 
1c74			 
1c74			; TODO ascii push input onto stack given hl to start of input 
1c74			 
1c74			; identify type 
1c74			; if starts with a " then a string 
1c74			; otherwise it is a number 
1c74			;  
1c74			; if a string 
1c74			;     scan for ending " to get length of string to malloc for + 1 
1c74			;     malloc 
1c74			;     put pointer to string on stack first byte flags as string 
1c74			; 
1c74			; else a number 
1c74			;    look for number format identifier 
1c74			;    $xx hex 
1c74			;    %xxxxx bin 
1c74			;    xxxxx decimal 
1c74			;    convert number to 16bit word.  
1c74			;    malloc word + 1 with flag to identiy as num 
1c74			;    put pointer to number on stack 
1c74			;   
1c74			;  
1c74			  
1c74			forth_apush: 
1c74				; kernel push 
1c74			 
1c74			if DEBUG_FORTH_PUSH 
1c74						DMARK "PSH" 
1c74 f5				push af  
1c75 3a 89 1c			ld a, (.dmark)  
1c78 32 71 ee			ld (debug_mark),a  
1c7b 3a 8a 1c			ld a, (.dmark+1)  
1c7e 32 72 ee			ld (debug_mark+1),a  
1c81 3a 8b 1c			ld a, (.dmark+2)  
1c84 32 73 ee			ld (debug_mark+2),a  
1c87 18 03			jr .pastdmark  
1c89 ..			.dmark: db "PSH"  
1c8c f1			.pastdmark: pop af  
1c8d			endm  
# End of macro DMARK
1c8d				CALLMONITOR 
1c8d cd a0 14			call break_point_state  
1c90				endm  
# End of macro CALLMONITOR
1c90			endif	 
1c90				; identify input type 
1c90			 
1c90 7e				ld a,(hl) 
1c91 fe 22			cp '"' 
1c93 28 0a			jr z, .fapstr 
1c95 fe 24			cp '$' 
1c97 ca bf 1c			jp z, .faphex 
1c9a fe 25			cp '%' 
1c9c ca a7 1c			jp z, .fapbin 
1c9f			;	cp 'b' 
1c9f			;	jp z, .fabin 
1c9f				; else decimal 
1c9f			 
1c9f				; TODO do decimal conversion 
1c9f				; decimal is stored as a 16bit word 
1c9f			 
1c9f				; by default everything is a string if type is not detected 
1c9f			.fapstr: ; 
1c9f fe 22			cp '"' 
1ca1 20 01			jr nz, .strnoqu 
1ca3 23				inc hl 
1ca4			.strnoqu: 
1ca4 c3 79 1b			jp forth_push_str 
1ca7			 
1ca7			 
1ca7			 
1ca7			.fapbin:    ; push a binary string.  
1ca7 11 00 00			ld de, 0   ; hold a 16bit value 
1caa			 
1caa 23			.fapbinshift:	inc hl  
1cab 7e				ld a,(hl) 
1cac fe 00			cp 0     ; done scanning  
1cae 28 0b			jr z, .fapbdone  	; got it in HL so push  
1cb0			 
1cb0				; left shift de 
1cb0 eb				ex de, hl	 
1cb1 29				add hl, hl 
1cb2			 
1cb2				; is 1 
1cb2 fe 31			cp '1' 
1cb4 20 02			jr nz, .binzero 
1cb6 cb 4d			bit 1, l 
1cb8			.binzero: 
1cb8 eb				ex de, hl	 ; save current de 
1cb9 18 ef			jr .fapbinshift 
1cbb			 
1cbb			.fapbdone: 
1cbb eb				ex de, hl 
1cbc c3 0b 1b			jp forth_push_numhl 
1cbf			 
1cbf			 
1cbf			.faphex:   ; hex is always stored as a 16bit word 
1cbf				; skip number prefix 
1cbf 23				inc hl 
1cc0				; turn ascii into number 
1cc0 cd 56 10			call get_word_hl	; ret 16bit word in hl 
1cc3			 
1cc3 c3 0b 1b			jp forth_push_numhl 
1cc6			 
1cc6 00				 nop 
1cc7			 
1cc7			.fabin:   ; TODO bin conversion 
1cc7			 
1cc7			 
1cc7 c9				ret 
1cc8			 
1cc8			 
1cc8			; get either a string ptr or a 16bit word from the data stack 
1cc8			 
1cc8			FORTH_DSP: macro 
1cc8				call macro_forth_dsp 
1cc8				endm 
1cc8			 
1cc8			macro_forth_dsp: 
1cc8				; data stack pointer points to current word on tos 
1cc8			 
1cc8 2a 04 eb			ld hl,(cli_data_sp) 
1ccb			 
1ccb				if DEBUG_FORTH_PUSH 
1ccb						DMARK "DSP" 
1ccb f5				push af  
1ccc 3a e0 1c			ld a, (.dmark)  
1ccf 32 71 ee			ld (debug_mark),a  
1cd2 3a e1 1c			ld a, (.dmark+1)  
1cd5 32 72 ee			ld (debug_mark+1),a  
1cd8 3a e2 1c			ld a, (.dmark+2)  
1cdb 32 73 ee			ld (debug_mark+2),a  
1cde 18 03			jr .pastdmark  
1ce0 ..			.dmark: db "DSP"  
1ce3 f1			.pastdmark: pop af  
1ce4			endm  
# End of macro DMARK
1ce4			 
1ce4 cd db 46				call display_data_sp 
1ce7				;call break_point_state 
1ce7				;rst 030h 
1ce7				CALLMONITOR 
1ce7 cd a0 14			call break_point_state  
1cea				endm  
# End of macro CALLMONITOR
1cea				endif 
1cea			 
1cea c9				ret 
1ceb			 
1ceb			; return hl to start of value on stack 
1ceb			 
1ceb			FORTH_DSP_VALUE: macro 
1ceb				call macro_forth_dsp_value 
1ceb				endm 
1ceb			 
1ceb			macro_forth_dsp_value: 
1ceb			 
1ceb				FORTH_DSP 
1ceb cd c8 1c			call macro_forth_dsp 
1cee				endm 
# End of macro FORTH_DSP
1cee			 
1cee d5				push de 
1cef			 
1cef 23				inc hl ; skip type 
1cf0			 
1cf0 5e				ld e, (hl) 
1cf1 23				inc hl 
1cf2 56				ld d, (hl) 
1cf3 eb				ex de,hl  
1cf4			 
1cf4 d1				pop de 
1cf5			 
1cf5 c9				ret 
1cf6			 
1cf6			; return hl to start of value to second item on stack 
1cf6			 
1cf6			FORTH_DSP_VALUEM1: macro 
1cf6				call macro_forth_dsp_value_m1 
1cf6				endm 
1cf6			 
1cf6			macro_forth_dsp_value_m1: 
1cf6			 
1cf6				FORTH_DSP 
1cf6 cd c8 1c			call macro_forth_dsp 
1cf9				endm 
# End of macro FORTH_DSP
1cf9			 
1cf9 2b				dec hl 
1cfa 2b				dec hl 
1cfb			;	dec hl 
1cfb			 
1cfb d5				push de 
1cfc			 
1cfc 5e				ld e, (hl) 
1cfd 23				inc hl 
1cfe 56				ld d, (hl) 
1cff eb				ex de,hl  
1d00			 
1d00 d1				pop de 
1d01			 
1d01 c9				ret 
1d02			 
1d02				 
1d02			 
1d02			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d02			 
1d02			FORTH_DSP_POP: macro 
1d02				call macro_forth_dsp_pop 
1d02				endm 
1d02			 
1d02			 
1d02			; get the tos data type 
1d02			 
1d02			FORTH_DSP_TYPE:   macro 
1d02			 
1d02				;FORTH_DSP_VALUE 
1d02				FORTH_DSP 
1d02				 
1d02				; hl points to value 
1d02				; check type 
1d02			 
1d02				ld a,(hl) 
1d02			 
1d02				endm 
1d02			 
1d02			; load the tos value into hl 
1d02			 
1d02			 
1d02			FORTH_DSP_VALUEHL:  macro 
1d02				call macro_dsp_valuehl 
1d02				endm 
1d02			 
1d02			 
1d02			 
1d02			macro_dsp_valuehl: 
1d02				FORTH_DSP_VALUE 
1d02 cd eb 1c			call macro_forth_dsp_value 
1d05				endm 
# End of macro FORTH_DSP_VALUE
1d05			 
1d05				;FORTH_ERR_TOS_NOTNUM 
1d05			 
1d05				;inc hl   ; skip type id 
1d05			 
1d05			;	push de 
1d05			; 
1d05			;	ld e, (hl) 
1d05			;	inc hl 
1d05			;	ld d, (hl) 
1d05			;	ex de,hl  
1d05			 
1d05			;	pop de 
1d05			 
1d05				if DEBUG_FORTH_PUSH 
1d05						DMARK "DVL" 
1d05 f5				push af  
1d06 3a 1a 1d			ld a, (.dmark)  
1d09 32 71 ee			ld (debug_mark),a  
1d0c 3a 1b 1d			ld a, (.dmark+1)  
1d0f 32 72 ee			ld (debug_mark+1),a  
1d12 3a 1c 1d			ld a, (.dmark+2)  
1d15 32 73 ee			ld (debug_mark+2),a  
1d18 18 03			jr .pastdmark  
1d1a ..			.dmark: db "DVL"  
1d1d f1			.pastdmark: pop af  
1d1e			endm  
# End of macro DMARK
1d1e				CALLMONITOR 
1d1e cd a0 14			call break_point_state  
1d21				endm  
# End of macro CALLMONITOR
1d21				endif 
1d21 c9				ret 
1d22			 
1d22			forth_apushstrhl:      
1d22				; push of string requires use of cli_origptr 
1d22				; bodge use 
1d22			 
1d22				; get current cli_origptr, save, update with temp pointer  
1d22 ed 5b 20 eb		ld de, (cli_origptr) 
1d26 22 20 eb			ld (cli_origptr), hl 
1d29 d5				push de 
1d2a cd 74 1c			call forth_apush 
1d2d d1				pop de 
1d2e ed 53 20 eb		ld (cli_origptr), de 
1d32 c9			        ret	 
1d33			 
1d33			 
1d33			; increase loop stack pointer and save hl to it 
1d33				 
1d33			FORTH_LOOP_NEXT: macro 
1d33				call macro_forth_loop_next 
1d33				;nop 
1d33				endm 
1d33			 
1d33			macro_forth_loop_next: 
1d33				if DEBUG_FORTH_STACK_GUARD 
1d33 cd 6f 57				call check_stacks 
1d36				endif 
1d36 e5				push hl 
1d37 d5				push de 
1d38 eb				ex de,hl 
1d39 2a 06 eb			ld hl,(cli_loop_sp) 
1d3c 23				inc hl 
1d3d 23				inc hl 
1d3e					if DEBUG_FORTH_WORDS 
1d3e						DMARK "LNX" 
1d3e f5				push af  
1d3f 3a 53 1d			ld a, (.dmark)  
1d42 32 71 ee			ld (debug_mark),a  
1d45 3a 54 1d			ld a, (.dmark+1)  
1d48 32 72 ee			ld (debug_mark+1),a  
1d4b 3a 55 1d			ld a, (.dmark+2)  
1d4e 32 73 ee			ld (debug_mark+2),a  
1d51 18 03			jr .pastdmark  
1d53 ..			.dmark: db "LNX"  
1d56 f1			.pastdmark: pop af  
1d57			endm  
# End of macro DMARK
1d57						CALLMONITOR 
1d57 cd a0 14			call break_point_state  
1d5a				endm  
# End of macro CALLMONITOR
1d5a					endif 
1d5a 22 06 eb			ld (cli_loop_sp),hl 
1d5d 73				ld (hl), e 
1d5e 23				inc hl 
1d5f 72				ld (hl), d 
1d60 d1				pop de    ; been reversed so save a swap on restore 
1d61 e1				pop hl 
1d62				if DEBUG_FORTH_STACK_GUARD 
1d62 cd 6f 57				call check_stacks 
1d65				endif 
1d65 c9				ret 
1d66			 
1d66			; get current ret stack pointer and save to hl  
1d66				 
1d66			FORTH_LOOP_TOS: macro 
1d66				call macro_forth_loop_tos 
1d66				endm 
1d66			 
1d66			macro_forth_loop_tos: 
1d66 d5				push de 
1d67 2a 06 eb			ld hl,(cli_loop_sp) 
1d6a 5e				ld e, (hl) 
1d6b 23				inc hl 
1d6c 56				ld d, (hl) 
1d6d eb				ex de, hl 
1d6e d1				pop de 
1d6f c9				ret 
1d70			 
1d70			; pop loop stack pointer 
1d70				 
1d70			FORTH_LOOP_POP: macro 
1d70				call macro_forth_loop_pop 
1d70				endm 
1d70			 
1d70			 
1d70			macro_forth_loop_pop: 
1d70				if DEBUG_FORTH_STACK_GUARD 
1d70					DMARK "LPP" 
1d70 f5				push af  
1d71 3a 85 1d			ld a, (.dmark)  
1d74 32 71 ee			ld (debug_mark),a  
1d77 3a 86 1d			ld a, (.dmark+1)  
1d7a 32 72 ee			ld (debug_mark+1),a  
1d7d 3a 87 1d			ld a, (.dmark+2)  
1d80 32 73 ee			ld (debug_mark+2),a  
1d83 18 03			jr .pastdmark  
1d85 ..			.dmark: db "LPP"  
1d88 f1			.pastdmark: pop af  
1d89			endm  
# End of macro DMARK
1d89 cd 6f 57				call check_stacks 
1d8c					FORTH_CHK_LOOP_UNDER 
1d8c e5				push hl 
1d8d d5				push de 
1d8e 2a 06 eb			ld hl,(cli_loop_sp) 
1d91 11 40 ea			ld de, cli_loop_stack 
1d94 cd bd 0c			call cmp16 
1d97 da 89 58			jp c, fault_loop_under 
1d9a d1				pop de 
1d9b e1				pop hl 
1d9c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d9c				endif 
1d9c e5				push hl 
1d9d 2a 06 eb			ld hl,(cli_loop_sp) 
1da0 2b				dec hl 
1da1 2b				dec hl 
1da2 22 06 eb			ld (cli_loop_sp), hl 
1da5				; TODO do stack underflow checks 
1da5 e1				pop hl 
1da6				if DEBUG_FORTH_STACK_GUARD 
1da6 cd 6f 57				call check_stacks 
1da9					FORTH_CHK_LOOP_UNDER 
1da9 e5				push hl 
1daa d5				push de 
1dab 2a 06 eb			ld hl,(cli_loop_sp) 
1dae 11 40 ea			ld de, cli_loop_stack 
1db1 cd bd 0c			call cmp16 
1db4 da 89 58			jp c, fault_loop_under 
1db7 d1				pop de 
1db8 e1				pop hl 
1db9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1db9				endif 
1db9 c9				ret 
1dba			 
1dba			macro_forth_dsp_pop: 
1dba			 
1dba e5				push hl 
1dbb			 
1dbb				; release malloc data 
1dbb			 
1dbb				if DEBUG_FORTH_STACK_GUARD 
1dbb cd 6f 57				call check_stacks 
1dbe					FORTH_CHK_DSP_UNDER 
1dbe e5				push hl 
1dbf d5				push de 
1dc0 2a 04 eb			ld hl,(cli_data_sp) 
1dc3 11 3e e9			ld de, cli_data_stack 
1dc6 cd bd 0c			call cmp16 
1dc9 da 7d 58			jp c, fault_dsp_under 
1dcc d1				pop de 
1dcd e1				pop hl 
1dce				endm 
# End of macro FORTH_CHK_DSP_UNDER
1dce				endif 
1dce				;ld hl,(cli_data_sp) 
1dce			if DEBUG_FORTH_DOT 
1dce				DMARK "DPP" 
1dce				CALLMONITOR 
1dce			endif	 
1dce			 
1dce			 
1dce			if FORTH_ENABLE_DSPPOPFREE 
1dce			 
1dce				FORTH_DSP 
1dce cd c8 1c			call macro_forth_dsp 
1dd1				endm 
# End of macro FORTH_DSP
1dd1			 
1dd1 7e				ld a, (hl) 
1dd2 fe 01			cp DS_TYPE_STR 
1dd4 20 07			jr nz, .skippopfree 
1dd6			 
1dd6				FORTH_DSP_VALUEHL 
1dd6 cd 02 1d			call macro_dsp_valuehl 
1dd9				endm 
# End of macro FORTH_DSP_VALUEHL
1dd9 00				nop 
1dda			if DEBUG_FORTH_DOT 
1dda				DMARK "DPf" 
1dda				CALLMONITOR 
1dda			endif	 
1dda cd 30 12			call free 
1ddd			.skippopfree: 
1ddd				 
1ddd			 
1ddd			endif 
1ddd			 
1ddd			if DEBUG_FORTH_DOT_KEY 
1ddd				DMARK "DP2" 
1ddd				CALLMONITOR 
1ddd			endif	 
1ddd			 
1ddd				; move pointer down 
1ddd			 
1ddd 2a 04 eb			ld hl,(cli_data_sp) 
1de0 2b				dec hl 
1de1 2b				dec hl 
1de2			; PARSEV5 
1de2 2b				dec hl 
1de3 22 04 eb			ld (cli_data_sp), hl 
1de6			 
1de6				if DEBUG_FORTH_STACK_GUARD 
1de6 cd 6f 57				call check_stacks 
1de9					FORTH_CHK_DSP_UNDER 
1de9 e5				push hl 
1dea d5				push de 
1deb 2a 04 eb			ld hl,(cli_data_sp) 
1dee 11 3e e9			ld de, cli_data_stack 
1df1 cd bd 0c			call cmp16 
1df4 da 7d 58			jp c, fault_dsp_under 
1df7 d1				pop de 
1df8 e1				pop hl 
1df9				endm 
# End of macro FORTH_CHK_DSP_UNDER
1df9				endif 
1df9			 
1df9 e1				pop hl 
1dfa			 
1dfa c9				ret 
1dfb			 
1dfb			getwordathl: 
1dfb				; hl points to an address 
1dfb				; load hl with the word at that address 
1dfb			 
1dfb d5				push de 
1dfc			 
1dfc 5e				ld e, (hl) 
1dfd 23				inc hl 
1dfe 56				ld d, (hl) 
1dff eb				ex de, hl 
1e00			 
1e00 d1				pop de 
1e01 c9				ret 
1e02			 
1e02			 
1e02			 
1e02			 
1e02			 
1e02			; eof 
1e02			 
# End of file forth_stackopsv5.asm
1e02			endif 
1e02			 
1e02			user_word_eol:  
1e02				; hl contains the pointer to where to create a linked list item from the end 
1e02				; of the user dict to continue on at the system word dict 
1e02				 
1e02				; poke the stub of the word list linked list to repoint to rom words 
1e02			 
1e02				; stub format 
1e02				; db   word id 
1e02				; dw    link to next word 
1e02			        ; db char length of token 
1e02				; db string + 0 term 
1e02				; db exec code....  
1e02			 
1e02 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1e04 77				ld (hl), a		; word id 
1e05 23				inc hl 
1e06			 
1e06 11 cc 1f			ld de, sysdict 
1e09 73				ld (hl), e		; next word link ie system dict 
1e0a 23				inc hl 
1e0b 72				ld (hl), d		; next word link ie system dict 
1e0c 23				inc hl	 
1e0d			 
1e0d			;	ld (hl), sysdict		; next word link ie system dict 
1e0d			;	inc hl 
1e0d			;	inc hl 
1e0d			 
1e0d			;	inc hl 
1e0d			;	inc hl 
1e0d			 
1e0d 3e 02			ld a, 2			; word length is 0 
1e0f 77				ld (hl), a	 
1e10 23				inc hl 
1e11			 
1e11 3e 7e			ld a, '~'			; word length is 0 
1e13 77				ld (hl), a	 
1e14 23				inc hl 
1e15 3e 00			ld a, 0			; save empty word 
1e17 77				ld (hl), a 
1e18			 
1e18 c9				ret 
1e19			 
1e19				 
1e19			 
1e19			forthexec_cleanup: 
1e19				FORTH_RSP_POP 
1e19 cd d3 1a			call macro_forth_rsp_pop 
1e1c				endm 
# End of macro FORTH_RSP_POP
1e1c c9				ret 
1e1d			 
1e1d			forth_call_hl: 
1e1d				; taking hl 
1e1d e5				push hl 
1e1e c9				ret 
1e1f			 
1e1f			; this is called to reset Forth system but keep existing uwords etc 
1e1f			 
1e1f			forth_warmstart: 
1e1f				; setup stack over/under flow checks 
1e1f				if DEBUG_FORTH_STACK_GUARD 
1e1f cd 55 57				call chk_stk_init 
1e22				endif 
1e22			 
1e22				; init stack pointers  - * these stacks go upwards *  
1e22 21 c2 ea			ld hl, cli_ret_stack 
1e25 22 08 eb			ld (cli_ret_sp), hl	 
1e28				; set bottom of stack 
1e28 3e 00			ld a,0 
1e2a 77				ld (hl),a 
1e2b 23				inc hl 
1e2c 77				ld (hl),a 
1e2d			 
1e2d 21 3e e9			ld hl, cli_data_stack 
1e30 22 04 eb			ld (cli_data_sp), hl	 
1e33				; set bottom of stack 
1e33 3e 00			ld a,0 
1e35 77				ld (hl),a 
1e36 23				inc hl 
1e37 77				ld (hl),a 
1e38			 
1e38 21 40 ea			ld hl, cli_loop_stack 
1e3b 22 06 eb			ld (cli_loop_sp), hl	 
1e3e				; set bottom of stack 
1e3e 3e 00			ld a,0 
1e40 77				ld (hl),a 
1e41 23				inc hl 
1e42 77				ld (hl),a 
1e43			 
1e43				; init extent of current open file 
1e43			 
1e43 3e 00			ld a, 0 
1e45 32 53 eb			ld (store_openext), a 
1e48			 
1e48 c9				ret 
1e49			 
1e49			 
1e49			; Cold Start - this is called to setup the whole Forth system 
1e49			 
1e49			forth_init: 
1e49			 
1e49				; setup stack over/under flow checks 
1e49			 
1e49			;	if DEBUG_FORTH_STACK_GUARD 
1e49			;		call chk_stk_init 
1e49			;	endif 
1e49			 
1e49				; enable auto display updates (slow.....) 
1e49			 
1e49 3e 01			ld a, 1 
1e4b 32 1e eb			ld (cli_autodisplay), a 
1e4e			 
1e4e			 
1e4e			 
1e4e				; show start up screen 
1e4e			 
1e4e cd 72 0a			call clear_display 
1e51			 
1e51 3e 00			ld a,0 
1e53 32 40 eb			ld (f_cursor_ptr), a 
1e56			 
1e56				; set start of word list in start of ram - for use when creating user words 
1e56			 
1e56 21 78 5a			ld hl, baseram 
1e59 22 d4 e6			ld (os_last_new_uword), hl 
1e5c cd 02 1e			call user_word_eol 
1e5f				 
1e5f			;		call display_data_sp 
1e5f			;		call next_page_prompt 
1e5f			 
1e5f			 
1e5f			 
1e5f			 
1e5f c9				ret 
1e60			 
1e60 .. 00		.bootforth: db " Forth Kernel Init ",0 
1e74			 
1e74			; TODO push to stack 
1e74			 
1e74			;  
1e74			 
1e74			if FORTH_PARSEV2 
1e74			 
1e74			 
1e74				include "forth_parserv2.asm" 
1e74			 
1e74			endif 
1e74			 
1e74			 
1e74			; parse cli version 1 
1e74			 
1e74			if FORTH_PARSEV1 
1e74			 
1e74			 
1e74			 
1e74			      include "forth_parserv1.asm" 
1e74			endif 
1e74				 
1e74			if FORTH_PARSEV3 
1e74			 
1e74			 
1e74			 
1e74			      include "forth_parserv3.asm" 
1e74				include "forth_wordsv3.asm" 
1e74			endif 
1e74			 
1e74			if FORTH_PARSEV4 
1e74			 
1e74			 
1e74			 
1e74			      include "forth_parserv4.asm" 
1e74				include "forth_wordsv4.asm" 
1e74			endif 
1e74			 
1e74			if FORTH_PARSEV5 
1e74			 
1e74			 
1e74			 
1e74			      include "forth_parserv5.asm" 
1e74			 
1e74			 
1e74			; A better parser without using malloc and string copies all over the place.  
1e74			; Exec in situ should be faster 
1e74			 
1e74			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1e74			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1e74			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1e74			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1e74			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1e74			WORD_SYS_END: equ 0   ; Opcode for all user words 
1e74			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1e74			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1e74			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1e74			 
1e74			; Core word preamble macro 
1e74			 
1e74			CWHEAD:   macro nxtword opcode lit len opflags 
1e74				db WORD_SYS_CORE+opcode             
1e74				; internal op code number 
1e74				dw nxtword            
1e74				; link to next dict word block 
1e74				db len + 1 
1e74				; literal length of dict word inc zero term 
1e74				db lit,0              
1e74				; literal dict word 
1e74			        ; TODO db opflags        
1e74				endm 
1e74			 
1e74			 
1e74			NEXTW: macro  
1e74				jp macro_next 
1e74				endm 
1e74			 
1e74			macro_next: 
1e74			if DEBUG_FORTH_PARSE_KEY 
1e74				DMARK "NXT" 
1e74				CALLMONITOR 
1e74			endif	 
1e74			;	inc hl  ; skip token null term  
1e74 ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1e78 ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1e7c 2a d8 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1e7f			if DEBUG_FORTH_PARSE_KEY 
1e7f				DMARK "}AA" 
1e7f				CALLMONITOR 
1e7f			endif	 
1e7f c3 82 1f			jp execnext 
1e82				;jp exec1 
1e82			       
1e82			 
1e82			 
1e82			; Another go at the parser to compile  
1e82			 
1e82			 
1e82			; TODO rework parser to change all of the string words to byte tokens 
1e82			; TODO do a search for  
1e82			 
1e82			; TODO first run normal parser to zero term sections 
1e82			; TODO for each word do a token look up to get the op code 
1e82			; TODO need some means to flag to the exec that this is a byte code form    
1e82			 
1e82			 
1e82			forthcompile: 
1e82			 
1e82			; 
1e82			; line parse: 
1e82			;       parse raw input buffer 
1e82			;       tokenise the words 
1e82			;       malloc new copy (for looping etc) 
1e82			;       copy to malloc + current pc in line to start of string and add line term 
1e82			;       save on new rsp 
1e82			; 
1e82			 
1e82			; hl to point to the line to tokenise 
1e82			 
1e82			;	push hl 
1e82 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1e85			 
1e85			;	ld a,0		; string term on input 
1e85			;	call strlent 
1e85			 
1e85			;	ld (os_tok_len), hl	 ; save string length 
1e85			 
1e85			;if DEBUG_FORTH_TOK 
1e85			;	ex de,hl		 
1e85			;endif 
1e85			 
1e85			;	pop hl 		; get back string pointer 
1e85			 
1e85			if DEBUG_FORTH_TOK 
1e85						DMARK "TOc" 
1e85				CALLMONITOR 
1e85			endif 
1e85 7e			.cptoken2:    ld a,(hl) 
1e86 23				inc hl 
1e87 fe 7f			cp FORTH_END_BUFFER 
1e89 28 29			jr z, .cptokendone2 
1e8b fe 00			cp 0 
1e8d 28 25			jr z, .cptokendone2 
1e8f fe 22			cp '"' 
1e91 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1e93 fe 20			cp ' ' 
1e95 20 ee			jr nz,  .cptoken2 
1e97			 
1e97			; TODO consume comments held between ( and ) 
1e97			 
1e97				; we have a space so change to zero term for dict match later 
1e97 2b				dec hl 
1e98 3e 00			ld a,0 
1e9a 77				ld (hl), a 
1e9b 23				inc hl 
1e9c 18 e7			jr .cptoken2 
1e9e				 
1e9e			 
1e9e			.cptokenstr2: 
1e9e				; skip all white space until either eol (because forgot to term) or end double quote 
1e9e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1e9e				;inc hl ; skip current double quote 
1e9e 7e				ld a,(hl) 
1e9f 23				inc hl 
1ea0 fe 22			cp '"' 
1ea2 28 e1			jr z, .cptoken2 
1ea4 fe 7f			cp FORTH_END_BUFFER 
1ea6 28 0c			jr z, .cptokendone2 
1ea8 fe 00			cp 0 
1eaa 28 08			jr z, .cptokendone2 
1eac fe 20			cp ' ' 
1eae 28 02			jr z, .cptmp2 
1eb0 18 ec			jr .cptokenstr2 
1eb2			 
1eb2			.cptmp2:	; we have a space so change to zero term for dict match later 
1eb2				;dec hl 
1eb2				;ld a,"-"	; TODO remove this when working 
1eb2				;ld (hl), a 
1eb2				;inc hl 
1eb2 18 ea			jr .cptokenstr2 
1eb4			 
1eb4			.cptokendone2: 
1eb4				;inc hl 
1eb4 3e 7f			ld a, FORTH_END_BUFFER 
1eb6 77				ld (hl),a 
1eb7 23				inc hl 
1eb8 3e 21			ld a, '!' 
1eba 77				ld (hl),a 
1ebb			 
1ebb 2a d8 e6			ld hl,(os_tok_ptr) 
1ebe			         
1ebe			if DEBUG_FORTH_TOK 
1ebe						DMARK "Tc1" 
1ebe				CALLMONITOR 
1ebe			endif 
1ebe			 
1ebe				; push exec string to top of return stack 
1ebe				FORTH_RSP_NEXT 
1ebe cd b2 1a			call macro_forth_rsp_next 
1ec1				endm 
# End of macro FORTH_RSP_NEXT
1ec1 c9				ret 
1ec2			 
1ec2			; Another go at the parser need to simplify the process 
1ec2			 
1ec2			forthparse: 
1ec2			 
1ec2			; 
1ec2			; line parse: 
1ec2			;       parse raw input buffer 
1ec2			;       tokenise the words 
1ec2			;       malloc new copy (for looping etc) 
1ec2			;       copy to malloc + current pc in line to start of string and add line term 
1ec2			;       save on new rsp 
1ec2			; 
1ec2			 
1ec2			; hl to point to the line to tokenise 
1ec2			 
1ec2			;	push hl 
1ec2 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1ec5			 
1ec5			;	ld a,0		; string term on input 
1ec5			;	call strlent 
1ec5			 
1ec5			;	ld (os_tok_len), hl	 ; save string length 
1ec5			 
1ec5			;if DEBUG_FORTH_TOK 
1ec5			;	ex de,hl		 
1ec5			;endif 
1ec5			 
1ec5			;	pop hl 		; get back string pointer 
1ec5			 
1ec5			if DEBUG_FORTH_TOK 
1ec5						DMARK "TOK" 
1ec5				CALLMONITOR 
1ec5			endif 
1ec5 7e			.ptoken2:    ld a,(hl) 
1ec6 23				inc hl 
1ec7 fe 7f			cp FORTH_END_BUFFER 
1ec9 28 29			jr z, .ptokendone2 
1ecb fe 00			cp 0 
1ecd 28 25			jr z, .ptokendone2 
1ecf fe 22			cp '"' 
1ed1 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1ed3 fe 20			cp ' ' 
1ed5 20 ee			jr nz,  .ptoken2 
1ed7			 
1ed7			; TODO consume comments held between ( and ) 
1ed7			 
1ed7				; we have a space so change to zero term for dict match later 
1ed7 2b				dec hl 
1ed8 3e 00			ld a,0 
1eda 77				ld (hl), a 
1edb 23				inc hl 
1edc 18 e7			jr .ptoken2 
1ede				 
1ede			 
1ede			.ptokenstr2: 
1ede				; skip all white space until either eol (because forgot to term) or end double quote 
1ede			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ede				;inc hl ; skip current double quote 
1ede 7e				ld a,(hl) 
1edf 23				inc hl 
1ee0 fe 22			cp '"' 
1ee2 28 e1			jr z, .ptoken2 
1ee4 fe 7f			cp FORTH_END_BUFFER 
1ee6 28 0c			jr z, .ptokendone2 
1ee8 fe 00			cp 0 
1eea 28 08			jr z, .ptokendone2 
1eec fe 20			cp ' ' 
1eee 28 02			jr z, .ptmp2 
1ef0 18 ec			jr .ptokenstr2 
1ef2			 
1ef2			.ptmp2:	; we have a space so change to zero term for dict match later 
1ef2				;dec hl 
1ef2				;ld a,"-"	; TODO remove this when working 
1ef2				;ld (hl), a 
1ef2				;inc hl 
1ef2 18 ea			jr .ptokenstr2 
1ef4			 
1ef4			.ptokendone2: 
1ef4				;inc hl 
1ef4 3e 7f			ld a, FORTH_END_BUFFER 
1ef6 77				ld (hl),a 
1ef7 23				inc hl 
1ef8 3e 21			ld a, '!' 
1efa 77				ld (hl),a 
1efb			 
1efb 2a d8 e6			ld hl,(os_tok_ptr) 
1efe			         
1efe			if DEBUG_FORTH_TOK 
1efe						DMARK "TK1" 
1efe				CALLMONITOR 
1efe			endif 
1efe			 
1efe				; push exec string to top of return stack 
1efe				FORTH_RSP_NEXT 
1efe cd b2 1a			call macro_forth_rsp_next 
1f01				endm 
# End of macro FORTH_RSP_NEXT
1f01 c9				ret 
1f02			 
1f02			; 
1f02			;	; malloc size + buffer pointer + if is loop flag 
1f02			;	ld hl,(os_tok_len) 		 ; get string length 
1f02			; 
1f02			;	ld a,l 
1f02			; 
1f02			;	cp 0			; we dont want to use a null string 
1f02			;	ret z 
1f02			; 
1f02			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f02			; 
1f02			;	add 5     ; TODO when certain not over writing memory remove 
1f02			; 
1f02			;		 
1f02			; 
1f02			;if DEBUG_FORTH_TOK 
1f02			;			DMARK "TKE" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			; 
1f02			;	ld l,a 
1f02			;	ld h,0 
1f02			;;	push hl   ; save required space for the copy later 
1f02			;	call malloc 
1f02			;if DEBUG_FORTH_TOK 
1f02			;			DMARK "TKM" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			;	if DEBUG_FORTH_MALLOC_GUARD 
1f02			;		push af 
1f02			;		call ishlzero 
1f02			;;		ld a, l 
1f02			;;		add h 
1f02			;;		cp 0 
1f02			;		pop af 
1f02			;		 
1f02			;		call z,malloc_error 
1f02			;	endif 
1f02			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f02			; 
1f02			; 
1f02			;if DEBUG_FORTH_TOK 
1f02			;			DMARK "TKR" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			; 
1f02			;	FORTH_RSP_NEXT 
1f02			; 
1f02			;	;inc hl	 ; go past current buffer pointer 
1f02			;	;inc hl 
1f02			;	;inc hl   ; and past if loop flag 
1f02			;		; TODO Need to set flag  
1f02			; 
1f02			;	 
1f02			;	 
1f02			;	ex de,hl	; malloc is dest 
1f02			;	ld hl, (os_tok_len) 
1f02			;;	pop bc 
1f02			;	ld c, l                
1f02			;	ld b,0 
1f02			;	ld hl, (os_tok_ptr) 
1f02			; 
1f02			;if DEBUG_FORTH_TOK 
1f02			;			DMARK "TKT" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			; 
1f02			;	; do str cpy 
1f02			; 
1f02			;	ldir      ; copy byte in hl to de 
1f02			; 
1f02			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f02			; 
1f02			;if DEBUG_FORTH_TOK 
1f02			; 
1f02			;			DMARK "TKY" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			;	;ld a,0 
1f02			;	;ld a,FORTH_END_BUFFER 
1f02			;	ex de, hl 
1f02			;	;dec hl			 ; go back over the space delim at the end of word 
1f02			;	;ld (hl),a 
1f02			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f02			;	ld a,FORTH_END_BUFFER 
1f02			;	ld (hl),a 
1f02			;	inc hl 
1f02			;	ld a,FORTH_END_BUFFER 
1f02			;	ld (hl),a 
1f02			; 
1f02			;	; init the malloc area data 
1f02			;	; set pc for in current area 
1f02			;	;ld hl, (os_tok_malloc) 
1f02			;	;inc hl 
1f02			;	;inc hl 
1f02			;	;inc hl 
1f02			;	;ex de,hl 
1f02			;	;ld hl, (os_tok_malloc) 
1f02			;	;ld (hl),e 
1f02			;	;inc hl 
1f02			;	;ld (hl),d 
1f02			; 
1f02			; 
1f02			;	ld hl,(os_tok_malloc) 
1f02			;if DEBUG_FORTH_PARSE_KEY 
1f02			;			DMARK "TKU" 
1f02			;	CALLMONITOR 
1f02			;endif 
1f02			; 
1f02			;	ret 
1f02			 
1f02			forthexec: 
1f02			 
1f02			; line exec: 
1f02			; forth parser 
1f02			 
1f02			; 
1f02			;       get current exec line on rsp 
1f02			 
1f02				FORTH_RSP_TOS 
1f02 cd c9 1a			call macro_forth_rsp_tos 
1f05				endm 
# End of macro FORTH_RSP_TOS
1f05			 
1f05			;       restore current pc - hl points to malloc of data 
1f05			 
1f05				;ld e, (hl) 
1f05				;inc hl 
1f05				;ld d, (hl) 
1f05				;ex de,hl 
1f05			 
1f05			 
1f05			exec1: 
1f05 22 d8 e6			ld (os_tok_ptr), hl 
1f08			 
1f08				; copy our PC to working vars  
1f08 22 22 eb			ld (cli_ptr), hl 
1f0b 22 20 eb			ld (cli_origptr), hl 
1f0e			 
1f0e 7e				ld a,(hl) 
1f0f fe 7f			cp FORTH_END_BUFFER 
1f11 c8				ret z 
1f12			 
1f12				; skip any nulls 
1f12			 
1f12 fe 00			cp 0 
1f14 20 03			jr nz, .execword 
1f16 23				inc hl 
1f17 18 ec			jr exec1 
1f19			 
1f19			 
1f19			.execword: 
1f19			 
1f19			 
1f19			 
1f19			if DEBUG_FORTH_PARSE_KEY 
1f19						DMARK "KYQ" 
1f19				CALLMONITOR 
1f19			endif 
1f19			;       while at start of word: 
1f19			; get start of dict (in user area first) 
1f19			 
1f19 21 78 5a		ld hl, baseram 
1f1c			;ld hl, sysdict 
1f1c 22 24 eb		ld (cli_nextword),hl 
1f1f			;           match word at pc 
1f1f			;           exec word 
1f1f			;           or push to dsp 
1f1f			;           forward to next token 
1f1f			;           if line term pop rsp and exit 
1f1f			;        
1f1f			 
1f1f			if DEBUG_FORTH_PARSE_KEY 
1f1f						DMARK "KYq" 
1f1f				CALLMONITOR 
1f1f			endif 
1f1f			 
1f1f			; 
1f1f			; word comp 
1f1f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f1f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f1f			;    move to start of word  
1f1f			;    compare word to cli_token 
1f1f			 
1f1f			.execpnword:	; HL at start of a word in the dictionary to check 
1f1f			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1f1f			;	ld (cli_ptr), hl 
1f1f			 
1f1f 2a 24 eb			ld hl,(cli_nextword) 
1f22			 
1f22 cd c5 1f			call forth_tok_next 
1f25			; tok next start here 
1f25			;	; TODO skip compiled symbol for now 
1f25			;	inc hl 
1f25			; 
1f25			;	; save pointer to next word 
1f25			; 
1f25			;	; hl now points to the address of the next word pointer  
1f25			;	ld e, (hl) 
1f25			;	inc hl 
1f25			;	ld d, (hl) 
1f25			;	inc l 
1f25			; 
1f25			;	ex de,hl 
1f25			;if DEBUG_FORTH_PARSE_NEXTWORD 
1f25			;	push bc 
1f25			;	ld bc, (cli_nextword) 
1f25			;			DMARK "NXW" 
1f25			;	CALLMONITOR 
1f25			;	pop bc 
1f25			;endif 
1f25			; tok next end here 
1f25 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f28 eb				ex de, hl 
1f29			 
1f29			 
1f29				; save the pointer of the current token - 1 to check against 
1f29				 
1f29 22 28 eb			ld (cli_token), hl   
1f2c				; TODO maybe remove below save if no debug 
1f2c				; save token string ptr for any debug later 
1f2c 23				inc hl  
1f2d 22 2a eb			ld (cli_origtoken), hl 
1f30 2b				dec hl 
1f31				; save pointer to the start of the next dictionay word 
1f31 7e				ld a,(hl)   ; get string length 
1f32 47				ld b,a 
1f33			.execpnwordinc:  
1f33 23				inc hl 
1f34 10 fd			djnz .execpnwordinc 
1f36 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
1f39			 
1f39				; now check the word token against the string being parsed 
1f39			 
1f39 2a 28 eb			ld hl,(cli_token) 
1f3c 23				inc hl     ; skip string length (use zero term instead to end) 
1f3d 22 28 eb			ld (cli_token), hl 
1f40			 
1f40			if DEBUG_FORTH_PARSE_KEY 
1f40						DMARK "KY2" 
1f40			endif 
1f40			if DEBUG_FORTH_PARSE_EXEC 
1f40				; see if disabled 
1f40			 
1f40				ld a, (os_view_disable) 
1f40				cp '*' 
1f40				jr z, .skip 
1f40			 
1f40				push hl 
1f40				push hl 
1f40				call clear_display 
1f40				ld de, .compword 
1f40				ld a, display_row_1 
1f40				call str_at_display 
1f40				pop de 
1f40				ld a, display_row_2 
1f40				call str_at_display 
1f40				ld hl,(cli_ptr) 
1f40				ld a,(hl) 
1f40			        ld hl, os_word_scratch 
1f40				ld (hl),a 
1f40				ld a,0 
1f40				inc hl 
1f40				ld (hl),a 	 
1f40				ld de, os_word_scratch 
1f40				ld a, display_row_2+10 
1f40				call str_at_display 
1f40				call update_display 
1f40				ld a, 100 
1f40				call aDelayInMS 
1f40				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f40				call delay250ms 
1f40				endif 
1f40				pop hl 
1f40			.skip:  
1f40			endif	 
1f40			.execpnchar:    ; compare char between token and string to parse 
1f40			 
1f40			if DEBUG_FORTH_PARSE_KEY 
1f40						DMARK "Ky3" 
1f40			endif 
1f40			if DEBUG_FORTH_PARSE_EXEC 
1f40				; see if disabled 
1f40			 
1f40				ld a, (os_view_disable) 
1f40				cp '*' 
1f40				jr z, .skip2 
1f40			 
1f40			;	call clear_display 
1f40			ld hl,(cli_token) 
1f40			ld a,(hl) 
1f40			ld (os_word_scratch),a 
1f40				ld hl,(cli_ptr) 
1f40			ld a,(hl) 
1f40				ld (os_word_scratch+1),a 
1f40				ld a,0 
1f40				ld (os_word_scratch+2),a 
1f40				ld de,os_word_scratch 
1f40				ld a,display_row_4 
1f40				call str_at_display 
1f40				call update_display 
1f40			.skip2:  
1f40			endif 
1f40 2a 28 eb			ld hl,(cli_token) 
1f43 7e				ld a, (hl)	 ; char in word token 
1f44 23				inc hl 		; move to next char 
1f45 22 28 eb			ld (cli_token), hl ; and save it 
1f48 47				ld b,a 
1f49			 
1f49 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1f4c 7e				ld a,(hl) 
1f4d 23				inc hl 
1f4e 22 22 eb			ld (cli_ptr), hl		; move to next char 
1f51 cd f4 10			call toUpper 		; make sure the input string matches case 
1f54			 
1f54			if DEBUG_FORTH_PARSE 
1f54			endif 
1f54			 
1f54				; input stream end of token is a space so get rid of it 
1f54			 
1f54			;	cp ' ' 
1f54			;	jr nz, .pnskipspace 
1f54			; 
1f54			;	ld a, 0		; make same term as word token term 
1f54			; 
1f54			;.pnskipspace: 
1f54			 
1f54			if DEBUG_FORTH_PARSE_KEY 
1f54						DMARK "KY7" 
1f54			endif 
1f54 b8				cp b 
1f55 c2 6b 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1f58				 
1f58			;    if same 
1f58			;       scan for string terms 0 for token and 32 for input 
1f58			 
1f58				 
1f58			if DEBUG_FORTH_PARSE_KEY 
1f58						DMARK "KY8" 
1f58			endif 
1f58			 
1f58 80				add b			 
1f59 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1f5b							; TODO need to make sure last word in zero term string is accounted for 
1f5b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1f5d			 
1f5d			 
1f5d				; at end of both strings so both are exact match 
1f5d			 
1f5d			;       skip ptr for next word 
1f5d			 
1f5d 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
1f60 23				inc hl			 ; at next char 
1f61 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1f64 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1f67				 
1f67				 
1f67			if DEBUG_FORTH_PARSE_KEY 
1f67						DMARK "KY3" 
1f67			endif 
1f67			 
1f67			 
1f67			 
1f67			;       exec code block 
1f67			if DEBUG_FORTH_JP 
1f67				call clear_display 
1f67				call update_display 
1f67				call delay1s 
1f67				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f67				ld a,h 
1f67				ld hl, os_word_scratch 
1f67				call hexout 
1f67				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f67				ld a,l 
1f67				ld hl, os_word_scratch+2 
1f67				call hexout 
1f67				ld hl, os_word_scratch+4 
1f67				ld a,0 
1f67				ld (hl),a 
1f67				ld de,os_word_scratch 
1f67				call str_at_display 
1f67					ld a, display_row_2 
1f67					call str_at_display 
1f67				ld de, (cli_origtoken) 
1f67				ld a, display_row_1+10 
1f67					call str_at_display 
1f67			 
1f67				ld a,display_row_1 
1f67				ld de, .foundword 
1f67				ld a, display_row_3 
1f67				call str_at_display 
1f67				call update_display 
1f67				call delay1s 
1f67				call delay1s 
1f67				call delay1s 
1f67			endif 
1f67			 
1f67			if DEBUG_FORTH_PARSE_KEY 
1f67						DMARK "KYj" 
1f67			endif 
1f67				; TODO save the word pointer in this exec 
1f67			 
1f67 2a 26 eb			ld hl,(cli_execword) 
1f6a e9				jp (hl) 
1f6b			 
1f6b			 
1f6b			;    if not same 
1f6b			;	scan for zero term 
1f6b			;	get ptr for next word 
1f6b			;	goto word comp 
1f6b			 
1f6b			.execpnskipword:	; get pointer to next word 
1f6b 2a 24 eb			ld hl,(cli_nextword) 
1f6e			 
1f6e 7e				ld a,(hl) 
1f6f fe 00			cp WORD_SYS_END 
1f71			;	cp 0 
1f71 28 09			jr z, .execendofdict			 ; at end of words 
1f73			 
1f73			if DEBUG_FORTH_PARSE_KEY 
1f73						DMARK "KY4" 
1f73			endif 
1f73			if DEBUG_FORTH_PARSE_EXEC 
1f73			 
1f73				; see if disabled 
1f73			 
1f73				ld a, (os_view_disable) 
1f73				cp '*' 
1f73				jr z, .noskip 
1f73			 
1f73			 
1f73				ld de, .nowordfound 
1f73				ld a, display_row_3 
1f73				call str_at_display 
1f73				call update_display 
1f73				ld a, 100 
1f73				call aDelayInMS 
1f73				 
1f73				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f73					call delay250ms 
1f73				endif 
1f73			.noskip:  
1f73			 
1f73			endif	 
1f73			 
1f73 2a 20 eb			ld hl,(cli_origptr) 
1f76 22 22 eb			ld (cli_ptr),hl 
1f79			 
1f79			if DEBUG_FORTH_PARSE_KEY 
1f79						DMARK "KY5" 
1f79			endif 
1f79 c3 1f 1f			jp .execpnword			; else go to next word 
1f7c			 
1f7c			.execendofdict:  
1f7c			 
1f7c			if DEBUG_FORTH_PARSE_KEY 
1f7c						DMARK "KYe" 
1f7c			endif 
1f7c			if DEBUG_FORTH_PARSE_EXEC 
1f7c				; see if disabled 
1f7c			 
1f7c				ld a, (os_view_disable) 
1f7c				cp '*' 
1f7c				jr z, .ispskip 
1f7c			 
1f7c				call clear_display 
1f7c				call update_display 
1f7c				call delay1s 
1f7c				ld de, (cli_origptr) 
1f7c				ld a, display_row_1 
1f7c				call str_at_display 
1f7c				 
1f7c				ld de, .enddict 
1f7c				ld a, display_row_3 
1f7c				call str_at_display 
1f7c				call update_display 
1f7c				ld a, 100 
1f7c				call aDelayInMS 
1f7c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f7c				call delay1s 
1f7c				call delay1s 
1f7c				call delay1s 
1f7c				endif 
1f7c			.ispskip:  
1f7c				 
1f7c			endif	 
1f7c			 
1f7c			 
1f7c			 
1f7c				; if the word is not a keyword then must be a literal so push it to stack 
1f7c			 
1f7c			; push token to stack to end of word 
1f7c			 
1f7c				STACKFRAME ON $1efe $2f9f 
1f7c				if DEBUG_STACK_IMB 
1f7c					if ON 
1f7c						exx 
1f7c						ld de, $1efe 
1f7c						ld a, d 
1f7c						ld hl, curframe 
1f7c						call hexout 
1f7c						ld a, e 
1f7c						ld hl, curframe+2 
1f7c						call hexout 
1f7c						ld hl, $1efe 
1f7c						push hl 
1f7c						ld hl, $2f9f 
1f7c						push hl 
1f7c						exx 
1f7c					endif 
1f7c				endif 
1f7c			endm 
# End of macro STACKFRAME
1f7c			 
1f7c 2a d8 e6		ld hl,(os_tok_ptr) 
1f7f cd 74 1c		call forth_apush 
1f82			 
1f82				STACKFRAMECHK ON $1efe $2f9f 
1f82				if DEBUG_STACK_IMB 
1f82					if ON 
1f82						exx 
1f82						ld hl, $2f9f 
1f82						pop de   ; $2f9f 
1f82						call cmp16 
1f82						jr nz, .spnosame 
1f82						ld hl, $1efe 
1f82						pop de   ; $1efe 
1f82						call cmp16 
1f82						jr z, .spfrsame 
1f82						.spnosame: call showsperror 
1f82						.spfrsame: nop 
1f82						exx 
1f82					endif 
1f82				endif 
1f82			endm 
# End of macro STACKFRAMECHK
1f82			 
1f82			execnext: 
1f82			 
1f82			if DEBUG_FORTH_PARSE_KEY 
1f82						DMARK "KY>" 
1f82			endif 
1f82			; move past token to next word 
1f82			 
1f82 2a d8 e6		ld hl, (os_tok_ptr) 
1f85 3e 00		ld a, 0 
1f87 01 ff 00		ld bc, 255     ; input buffer size 
1f8a ed b1		cpir 
1f8c			 
1f8c			if DEBUG_FORTH_PARSE_KEY 
1f8c						DMARK "KY!" 
1f8c				CALLMONITOR 
1f8c			endif	 
1f8c			; TODO this might place hl on the null, so will need to forward on??? 
1f8c			;inc hl   ; see if this gets onto the next item 
1f8c			 
1f8c			 
1f8c			; TODO pass a pointer to the buffer to push 
1f8c			; TODO call function to push 
1f8c			 
1f8c			; look for end of input 
1f8c			 
1f8c			;inc hl 
1f8c			;ld a,(hl) 
1f8c			;cp FORTH_END_BUFFER 
1f8c			;ret z 
1f8c			 
1f8c			 
1f8c c3 05 1f		jp exec1 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			 
1f8f			findnexttok: 
1f8f			 
1f8f				; hl is pointer to move 
1f8f				; de is the token to locate 
1f8f			 
1f8f					if DEBUG_FORTH 
1f8f						DMARK "NTK" 
1f8f						CALLMONITOR 
1f8f					endif 
1f8f d5				push de 
1f90			 
1f90			.fnt1:	 
1f90				; find first char of token to locate 
1f90			 
1f90 1a				ld a, (de) 
1f91 4f				ld c,a 
1f92 7e				ld a,(hl) 
1f93 cd f4 10			call toUpper 
1f96					if DEBUG_FORTH 
1f96						DMARK "NT1" 
1f96						CALLMONITOR 
1f96					endif 
1f96 b9				cp c 
1f97			 
1f97 28 03			jr z, .fnt2cmpmorefirst	 
1f99			 
1f99				; first char not found move to next char 
1f99			 
1f99 23				inc hl 
1f9a 18 f4			jr .fnt1 
1f9c			 
1f9c			.fnt2cmpmorefirst:	 
1f9c				; first char of token found.  
1f9c			 
1f9c e5				push hl     ; save start of token just in case it is the right one 
1f9d d9				exx 
1f9e e1				pop hl        ; save it to hl' 
1f9f d9				exx 
1fa0			 
1fa0			 
1fa0			.fnt2cmpmore:	 
1fa0				; compare the rest 
1fa0				 
1fa0 23				inc hl 
1fa1 13				inc de 
1fa2				 
1fa2 1a				ld a, (de) 
1fa3 4f				ld c,a 
1fa4 7e				ld a,(hl) 
1fa5 cd f4 10			call toUpper 
1fa8			 
1fa8					if DEBUG_FORTH 
1fa8						DMARK "NT2" 
1fa8						CALLMONITOR 
1fa8					endif 
1fa8				; c has the token to find char 
1fa8				; a has the mem to scan char 
1fa8			 
1fa8 b9				cp c 
1fa9 28 04			jr z,.fntmatch1 
1fab			 
1fab				; they are not the same 
1fab			 
1fab					if DEBUG_FORTH 
1fab						DMARK "NT3" 
1fab						CALLMONITOR 
1fab					endif 
1fab d1				pop de	; reset de token to look for 
1fac d5				push de 
1fad 18 e1			jr .fnt1 
1faf				 
1faf			.fntmatch1: 
1faf			 
1faf				; is the same char a null which means we might have a full hit? 
1faf					if DEBUG_FORTH 
1faf						DMARK "NT4" 
1faf						CALLMONITOR 
1faf					endif 
1faf			 
1faf fe 00			cp 0 
1fb1 28 0b			jr z, .fntmatchyes 
1fb3			 
1fb3				; are we at the end of the token to find? 
1fb3			 
1fb3					if DEBUG_FORTH 
1fb3						DMARK "NT5" 
1fb3						CALLMONITOR 
1fb3					endif 
1fb3 3e 00			ld a, 0 
1fb5 b9				cp c 
1fb6			 
1fb6 c2 a0 1f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1fb9			 
1fb9					if DEBUG_FORTH 
1fb9						DMARK "NT6" 
1fb9						CALLMONITOR 
1fb9					endif 
1fb9				; token to find is exhusted but no match to stream 
1fb9			 
1fb9				; restore tok pointer and continue on 
1fb9 d1				pop de 
1fba d5				push de 
1fbb c3 90 1f			jp .fnt1 
1fbe			 
1fbe			 
1fbe			.fntmatchyes: 
1fbe			 
1fbe				; hl now contains the end of the found token 
1fbe			 
1fbe				; get rid of saved token pointer to find 
1fbe			 
1fbe d1				pop de 
1fbf			 
1fbf					if DEBUG_FORTH 
1fbf						DMARK "NT9" 
1fbf						CALLMONITOR 
1fbf					endif 
1fbf			 
1fbf				; hl will be on the null term so forward on 
1fbf			 
1fbf				; get back the saved start of the token 
1fbf			 
1fbf d9				exx 
1fc0 e5				push hl     ; save start of token just in case it is the right one 
1fc1 d9				exx 
1fc2 e1				pop hl        ; save it to hl 
1fc3			 
1fc3 c9				ret 
1fc4			 
1fc4			 
1fc4			; LIST needs to find a specific token   
1fc4			; FORGET needs to find a spefici token 
1fc4			 
1fc4			; SAVE needs to find all tokens by flag 
1fc4			; WORDS just needs to scan through all  by flag 
1fc4			; UWORDS needs to scan through all by flag 
1fc4			 
1fc4			 
1fc4			; given hl as pointer to start of dict look up string 
1fc4			; return hl as pointer to start of word block 
1fc4			; or 0 if not found 
1fc4			 
1fc4			forth_find_tok: 
1fc4 c9				ret 
1fc5			 
1fc5			; given hl as pointer to dict structure 
1fc5			; move to the next dict block structure 
1fc5			 
1fc5			forth_tok_next: 
1fc5				; hl now points to the address of the next word pointer  
1fc5				; TODO skip compiled symbol for now 
1fc5			;	push de 
1fc5 23				inc hl 
1fc6 5e				ld e, (hl) 
1fc7 23				inc hl 
1fc8 56				ld d, (hl) 
1fc9 23				inc hl 
1fca			 
1fca eb				ex de,hl 
1fcb			if DEBUG_FORTH_PARSE_NEXTWORD 
1fcb				push bc 
1fcb				ld bc, (cli_nextword) 
1fcb						DMARK "NXW" 
1fcb				CALLMONITOR 
1fcb				pop bc 
1fcb			endif 
1fcb			;	pop de	 
1fcb c9				ret 
1fcc			 
1fcc			 
1fcc			 
1fcc			; eof 
# End of file forth_parserv5.asm
1fcc				include "forth_wordsv4.asm" 
1fcc			 
1fcc			; the core word dictionary v4 
1fcc			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1fcc			 
1fcc			; this is a linked list for each of the system words used 
1fcc			; user defined words will follow the same format but will be in ram 
1fcc			 
1fcc			 
1fcc			; 
1fcc			; 
1fcc			; define linked list: 
1fcc			; 
1fcc			; 1. compiled byte op code 
1fcc			; 2. len of text word 
1fcc			; 3. text word 
1fcc			; 4. ptr to next dictionary word 
1fcc			; 5. asm, calls etc for the word 
1fcc			; 
1fcc			;  if 1 == 0 then last word in dict  
1fcc			;   
1fcc			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1fcc			;  
1fcc			;  
1fcc			; create basic standard set of words 
1fcc			; 
1fcc			;  
1fcc			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1fcc			; 2DUP 2DROP 2SWAP  
1fcc			; @ C@ - get byte  
1fcc			; ! C! - store byte 
1fcc			; 0< true if less than zero 
1fcc			; 0= true if zero 
1fcc			; < >  
1fcc			; = true if same 
1fcc			; variables 
1fcc			 
1fcc			 
1fcc			; Hardware specific words I may need 
1fcc			; 
1fcc			; IN OUT  
1fcc			; calls to key util functions 
1fcc			; calls to hardward abstraction stuff 
1fcc			; easy control of frame buffers and lcd i/o 
1fcc			; keyboard  
1fcc			 
1fcc			 
1fcc			;DICT: macro 
1fcc			; op_code, len, word, next 
1fcc			;    word: 
1fcc			;    db op_code 
1fcc			;    ds word zero term 
1fcc			;    dw next 
1fcc			;    endm 
1fcc			 
1fcc			 
1fcc			 
1fcc			 
1fcc			; op code 1 is a flag for user define words which are to be handled differently 
1fcc			 
1fcc			 
1fcc			; 
1fcc			; 
1fcc			;    TODO on entry to a word this should be the expected environment 
1fcc			;    hl - tos value if number then held, if string this is the ptr 
1fcc			;    de -  
1fcc			 
1fcc			 
1fcc			; opcode ranges 
1fcc			; 0 - end of word dict 
1fcc			; 255 - user define words 
1fcc			 
1fcc			sysdict: 
1fcc			include "forth_opcodes.asm" 
1fcc			; op codes for forth keywords 
1fcc			; free to use code 0  
1fcc				OPCODE_HEAP: equ  1 
1fcc				OPCODE_EXEC: equ 2 
1fcc				OPCODE_DUP: equ 3 
1fcc				OPCODE_SWAP: equ 4 
1fcc				OPCODE_COLN: equ 5 
1fcc				OPCODE_SCOLN: equ 6 
1fcc				OPCODE_DROP: equ 7 
1fcc				OPCODE_DUP2: equ 8 
1fcc				OPCODE_DROP2: equ 9 
1fcc				OPCODE_SWAP2: equ 10 
1fcc				OPCODE_AT: equ 11 
1fcc				OPCODE_CAT: equ 12 
1fcc				OPCODE_BANG: equ 13 
1fcc				OPCODE_CBANG: equ 14 
1fcc				OPCODE_SCALL: equ 15 
1fcc				OPCODE_DEPTH: equ 16 
1fcc				OPCODE_OVER: equ 17 
1fcc				OPCODE_PAUSE: equ 18 
1fcc				OPCODE_PAUSES: equ 19 
1fcc				OPCODE_ROT: equ 20 
1fcc			;free to reuse	OPCODE_WORDS: equ 21 
1fcc			        OPCODE_NOT: equ 21 
1fcc				OPCODE_UWORDS: equ 22 
1fcc				OPCODE_BP: equ 23 
1fcc				OPCODE_MONITOR: equ 24  
1fcc				OPCODE_MALLOC: equ 25 
1fcc				OPCODE_FREE: equ 26 
1fcc				OPCODE_LIST: equ 27 
1fcc				OPCODE_FORGET: equ 28 
1fcc				OPCODE_NOP: equ 29 
1fcc				OPCODE_COMO: equ 30 
1fcc				OPCODE_COMC: equ 31 
1fcc			;free to reuse	OPCODE_ENDCORE: equ 32 
1fcc				OPCODE_AFTERSOUND: equ 33 
1fcc				OPCODE_GP2: equ 34 
1fcc				OPCODE_GP3: equ 35 
1fcc				OPCODE_GP4: equ 36 
1fcc				OPCODE_SIN: equ 37 
1fcc				OPCODE_SOUT: equ 38 
1fcc				OPCODE_SPIO: equ 39 
1fcc				OPCODE_SPICEH: equ 40 
1fcc				OPCODE_SPIOb: equ 41 
1fcc				OPCODE_SPII: equ 42 
1fcc				OPCODE_SESEL: equ 43 
1fcc				OPCODE_CARTDEV: equ 44 
1fcc			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1fcc				OPCODE_FB: equ 46 
1fcc				OPCODE_EMIT: equ 47 
1fcc				OPCODE_DOTH: equ 48 
1fcc				OPCODE_DOTF: equ 49 
1fcc				OPCODE_DOT: equ 50 
1fcc				OPCODE_CLS: equ 51 
1fcc				OPCODE_DRAW: equ 52 
1fcc				OPCODE_DUMP: equ 53 
1fcc				OPCODE_CDUMP: equ 54 
1fcc				OPCODE_DAT: equ 55 
1fcc				OPCODE_HOME: equ 56 
1fcc				OPCODE_SPACE: equ 57 
1fcc				OPCODE_SPACES: equ 58 
1fcc				OPCODE_SCROLL: equ 59 
1fcc				OPCODE_ATQ: equ 60 
1fcc				OPCODE_AUTODSP: equ 61 
1fcc				OPCODE_MENU: equ 62 
1fcc			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1fcc				OPCODE_THEN: equ 64 
1fcc				OPCODE_ELSE: equ 65 
1fcc				OPCODE_DO: equ 66 
1fcc				OPCODE_LOOP: equ 67 
1fcc				OPCODE_I: equ 68 
1fcc				OPCODE_DLOOP: equ 69  
1fcc				OPCODE_REPEAT: equ 70  
1fcc				OPCODE_UNTIL: equ 71 
1fcc				OPCODE_ENDFLOW: equ 72 
1fcc				OPCODE_WAITK: equ 73 
1fcc				OPCODE_ACCEPT: equ 74 
1fcc				OPCODE_EDIT: equ 75 
1fcc			;free to reuse	OPCODE_ENDKEY: equ 76 
1fcc				OPCODE_LZERO: equ 77 
1fcc				OPCODE_TZERO: equ 78 
1fcc				OPCODE_LESS: equ 79 
1fcc				OPCODE_GT: equ 80 
1fcc				OPCODE_EQUAL: equ 81  
1fcc			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1fcc				OPCODE_NEG: equ 83 
1fcc				OPCODE_DIV: equ 84 
1fcc				OPCODE_MUL: equ 85 
1fcc				OPCODE_MIN: equ 86 
1fcc				OPCODE_MAX: equ 87 
1fcc				OPCODE_RND16: equ 88 
1fcc				OPCODE_RND8: equ 89 
1fcc				OPCODE_RND: equ 90 
1fcc			;free to reuse	OPCODE_ENDMATHS: equ 91  
1fcc				OPCODE_BYNAME: equ 92 
1fcc				OPCODE_DIR: equ 93 
1fcc				OPCODE_SAVE: equ 94 
1fcc				OPCODE_LOAD: equ 95 
1fcc				OPCODE_BSAVE: equ 96 
1fcc				OPCODE_BLOAD: equ 97 
1fcc				OPCODE_SEO: equ 98  
1fcc				OPCODE_SEI: equ 99 
1fcc				OPCODE_SFREE: equ 100 
1fcc				OPCODE_SIZE: equ 101 
1fcc				OPCODE_CREATE: equ 102 
1fcc				OPCODE_APPEND: equ 103 
1fcc				OPCODE_SDEL: equ 104 
1fcc				OPCODE_OPEN: equ 105 
1fcc				OPCODE_READ: equ 106 
1fcc				OPCODE_EOF: equ 106 
1fcc				OPCODE_FORMAT: equ 107 
1fcc				OPCODE_LABEL: equ 108 
1fcc				OPCODE_LABELS: equ 109 
1fcc			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1fcc				OPCODE_UPPER: equ 111 
1fcc				OPCODE_LOWER: equ 112 
1fcc				OPCODE_SUBSTR: equ 113 
1fcc				OPCODE_LEFT: equ 114 
1fcc				OPCODE_RIGHT: equ 115 
1fcc				OPCODE_STR2NUM: equ 116 
1fcc				OPCODE_NUM2STR: equ 117 
1fcc				OPCODE_CONCAT: equ 118 
1fcc				OPCODE_FIND: equ 119 
1fcc				OPCODE_LEN: equ 120 
1fcc				OPCODE_CHAR: equ 121 
1fcc			; free to reuse	OPCODE_STRLEN: equ 122 
1fcc			; free to reuse	OPCODE_ENDSTR: equ 123 
1fcc				OPCODE_V0S: equ 124 
1fcc				OPCODE_V0Q: equ 125 
1fcc				OPCODE_V1S: equ 126 
1fcc				OPCODE_V1Q: equ 127 
1fcc				OPCODE_V2S: equ 128 
1fcc				OPCODE_V2Q: equ 129 
1fcc				OPCODE_V3S: equ 130 
1fcc				OPCODE_V3Q: equ 131 
1fcc			;free to reuse	OPCODE_END: equ 132 
1fcc				OPCODE_ZDUP: equ 133 
1fcc			 
1fcc			; eof 
# End of file forth_opcodes.asm
1fcc			 
1fcc			include "forth_words_core.asm" 
1fcc			 
1fcc			; | ## Core Words 
1fcc			 
1fcc			;if MALLOC_4 
1fcc			 
1fcc			.HEAP: 
1fcc				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1fcc 15				db WORD_SYS_CORE+OPCODE_HEAP             
1fcd 0b 20			dw .EXEC            
1fcf 05				db 4 + 1 
1fd0 .. 00			db "HEAP",0              
1fd5				endm 
# End of macro CWHEAD
1fd5			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1fd5			; | | u1 - Current number of bytes in the heap 
1fd5			; | | u2 - Remaining bytes left on the heap 
1fd5			; | |  
1fd5			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1fd5			 
1fd5			 
1fd5					if DEBUG_FORTH_WORDS_KEY 
1fd5						DMARK "HEP" 
1fd5 f5				push af  
1fd6 3a ea 1f			ld a, (.dmark)  
1fd9 32 71 ee			ld (debug_mark),a  
1fdc 3a eb 1f			ld a, (.dmark+1)  
1fdf 32 72 ee			ld (debug_mark+1),a  
1fe2 3a ec 1f			ld a, (.dmark+2)  
1fe5 32 73 ee			ld (debug_mark+2),a  
1fe8 18 03			jr .pastdmark  
1fea ..			.dmark: db "HEP"  
1fed f1			.pastdmark: pop af  
1fee			endm  
# End of macro DMARK
1fee						CALLMONITOR 
1fee cd a0 14			call break_point_state  
1ff1				endm  
# End of macro CALLMONITOR
1ff1					endif 
1ff1 2a 82 5a				ld hl, (free_list )      
1ff4 11 87 5a				ld de, heap_start 
1ff7			 
1ff7 ed 52				sbc hl, de  
1ff9			 
1ff9 cd 0b 1b				call forth_push_numhl 
1ffc			 
1ffc			 
1ffc ed 5b 82 5a			ld de, (free_list )      
2000 21 bd e3				ld hl, heap_end 
2003			 
2003 ed 52				sbc hl, de 
2005			 
2005 cd 0b 1b				call forth_push_numhl 
2008					 
2008			 
2008					 
2008			 
2008			 
2008			 
2008					NEXTW 
2008 c3 74 1e			jp macro_next 
200b				endm 
# End of macro NEXTW
200b			;endif 
200b			 
200b			.EXEC: 
200b			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
200b			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
200b			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
200b			;; > > 
200b			;; > >   
200b			;	STACKFRAME OFF $5efe $5f9f 
200b			; 
200b			;		if DEBUG_FORTH_WORDS_KEY 
200b			;			DMARK "EXE" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			;	FORTH_DSP_VALUEHL 
200b			; 
200b			;	FORTH_DSP_POP 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX1" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;;	ld e,(hl) 
200b			;;	inc hl 
200b			;;	ld d,(hl) 
200b			;;	ex de,hl 
200b			; 
200b			;;		if DEBUG_FORTH_WORDS 
200b			;;			DMARK "EX2" 
200b			;;			CALLMONITOR 
200b			;;		endif 
200b			;	push hl 
200b			; 
200b			;	;ld a, 0 
200b			;	;ld a, FORTH_END_BUFFER 
200b			;	call strlenz 
200b			;	inc hl   ; include zero term to copy 
200b			;	inc hl   ; include term 
200b			;	inc hl   ; include term 
200b			;	ld b,0 
200b			;	ld c,l 
200b			;	pop hl 
200b			;	ld de, execscratch 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX3" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	ldir 
200b			; 
200b			; 
200b			;	ld hl, execscratch 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EXe" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			;	call forthparse 
200b			;	call forthexec 
200b			;;	call forthexec_cleanup 
200b			;;	call forthparse 
200b			;;	call forthexec 
200b			; 
200b			;	STACKFRAMECHK OFF $5efe $5f9f 
200b			; 
200b			;	; an immediate word so no need to process any more words 
200b			;	ret 
200b			;	NEXTW 
200b			 
200b			; dead code - old version  
200b			;	FORTH_RSP_NEXT 
200b			 
200b			;  
200b			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
200b			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
200b			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
200b			;	push hl 
200b			;	push de 
200b			;	push bc 
200b			; 
200b			; 
200b			;		if DEBUG_FORTH_WORDS_KEY 
200b			;			DMARK "EXR" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			; 
200b			; 
200b			;	;v5 FORTH_DSP_VALUE 
200b			;	FORTH_DSP_VALUEHL 
200b			; 
200b			;	; TODO do string type checks 
200b			; 
200b			;;v5	inc hl   ; skip type 
200b			; 
200b			;	push hl  ; source code  
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX1" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	ld a, 0 
200b			;	call strlent 
200b			; 
200b			;	inc hl 
200b			;	inc hl 
200b			;	inc hl 
200b			;	inc hl 
200b			; 
200b			;	push hl    ; size 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX2" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	call malloc 
200b			; 
200b			;	ex de, hl    ; de now contains malloc area 
200b			;	pop bc   	; get byte count 
200b			;	pop hl      ; get string to copy 
200b			; 
200b			;	push de     ; save malloc for free later 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX3" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	ldir       ; duplicate string 
200b			; 
200b			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
200b			;	 
200b			;	; TODO fix the parse would be better than this...  
200b			;	ex de, hl 
200b			;	dec hl 
200b			;	ld a, 0 
200b			;	ld (hl), a 
200b			;	dec hl 
200b			;	ld a, ' ' 
200b			;	ld (hl), a 
200b			;	dec hl 
200b			;	ld (hl), a 
200b			; 
200b			;	dec hl 
200b			;	ld (hl), a 
200b			; 
200b			; 
200b			;	FORTH_DSP_POP  
200b			; 
200b			;	pop hl     
200b			;	push hl    ; save malloc area 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX4" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			;	call forthparse 
200b			;	call forthexec 
200b			;	 
200b			;	pop hl 
200b			;	if DEBUG_FORTH_WORDS 
200b			;		DMARK "EX5" 
200b			;		CALLMONITOR 
200b			;	endif 
200b			; 
200b			;	if FORTH_ENABLE_FREE 
200b			;	call free 
200b			;	endif 
200b			; 
200b			;	if DEBUG_FORTH_WORDS 
200b			;		DMARK "EX6" 
200b			;		CALLMONITOR 
200b			;	endif 
200b			; 
200b			;	pop bc 
200b			;	pop de 
200b			;	pop hl 
200b			;;	FORTH_RSP_POP	  
200b			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
200b			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
200b			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
200b			; 
200b			;	if DEBUG_FORTH_WORDS 
200b			;		DMARK "EX7" 
200b			;		CALLMONITOR 
200b			;	endif 
200b			;	NEXTW 
200b			 
200b			;.STKEXEC: 
200b			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
200b			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
200b			; 
200b			; 
200b			;		if DEBUG_FORTH_WORDS_KEY 
200b			;			DMARK "STX" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			;	FORTH_DSP_VALUEHL 
200b			; 
200b			;	ld (store_tmp1), hl    ; count 
200b			; 
200b			;	FORTH_DSP_POP 
200b			;.stkexec1: 
200b			;	ld hl, (store_tmp1)   ; count 
200b			;	ld a, 0 
200b			;	cp l 
200b			;	ret z 
200b			; 
200b			;	dec hl 
200b			;	ld (store_tmp1), hl    ; count 
200b			;	 
200b			;	FORTH_DSP_VALUEHL 
200b			;	push hl 
200b			;	 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EXp" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	FORTH_DSP_POP 
200b			; 
200b			;	call strlenz 
200b			;	inc hl   ; include zero term to copy 
200b			;	inc hl   ; include zero term to copy 
200b			;	inc hl   ; include zero term to copy 
200b			;	ld b,0 
200b			;	ld c,l 
200b			;	pop hl 
200b			;	ld de, execscratch 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EX3" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	ldir 
200b			; 
200b			; 
200b			;	ld hl, execscratch 
200b			; 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EXP" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			; 
200b			;	call forthparse 
200b			;	ld hl, execscratch 
200b			;		if DEBUG_FORTH_WORDS 
200b			;			DMARK "EXx" 
200b			;			CALLMONITOR 
200b			;		endif 
200b			;	call forthexec 
200b			; 
200b			;	jp .stkexec1 
200b			; 
200b			;	ret 
200b			 
200b			 
200b			.DUP: 
200b				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
200b 17				db WORD_SYS_CORE+OPCODE_DUP             
200c 81 20			dw .ZDUP            
200e 04				db 3 + 1 
200f .. 00			db "DUP",0              
2013				endm 
# End of macro CWHEAD
2013			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2013			 
2013					if DEBUG_FORTH_WORDS_KEY 
2013						DMARK "DUP" 
2013 f5				push af  
2014 3a 28 20			ld a, (.dmark)  
2017 32 71 ee			ld (debug_mark),a  
201a 3a 29 20			ld a, (.dmark+1)  
201d 32 72 ee			ld (debug_mark+1),a  
2020 3a 2a 20			ld a, (.dmark+2)  
2023 32 73 ee			ld (debug_mark+2),a  
2026 18 03			jr .pastdmark  
2028 ..			.dmark: db "DUP"  
202b f1			.pastdmark: pop af  
202c			endm  
# End of macro DMARK
202c						CALLMONITOR 
202c cd a0 14			call break_point_state  
202f				endm  
# End of macro CALLMONITOR
202f					endif 
202f			 
202f					FORTH_DSP 
202f cd c8 1c			call macro_forth_dsp 
2032				endm 
# End of macro FORTH_DSP
2032			 
2032 7e					ld a, (HL) 
2033 fe 01				cp DS_TYPE_STR 
2035 20 25				jr nz, .dupinum 
2037			 
2037					; push another string 
2037			 
2037					FORTH_DSP_VALUEHL     		 
2037 cd 02 1d			call macro_dsp_valuehl 
203a				endm 
# End of macro FORTH_DSP_VALUEHL
203a			 
203a				if DEBUG_FORTH_WORDS 
203a					DMARK "DUs" 
203a f5				push af  
203b 3a 4f 20			ld a, (.dmark)  
203e 32 71 ee			ld (debug_mark),a  
2041 3a 50 20			ld a, (.dmark+1)  
2044 32 72 ee			ld (debug_mark+1),a  
2047 3a 51 20			ld a, (.dmark+2)  
204a 32 73 ee			ld (debug_mark+2),a  
204d 18 03			jr .pastdmark  
204f ..			.dmark: db "DUs"  
2052 f1			.pastdmark: pop af  
2053			endm  
# End of macro DMARK
2053					CALLMONITOR 
2053 cd a0 14			call break_point_state  
2056				endm  
# End of macro CALLMONITOR
2056				endif 
2056 cd 79 1b				call forth_push_str 
2059			 
2059					NEXTW 
2059 c3 74 1e			jp macro_next 
205c				endm 
# End of macro NEXTW
205c			 
205c			 
205c			.dupinum: 
205c					 
205c			 
205c			 
205c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
205c cd 02 1d			call macro_dsp_valuehl 
205f				endm 
# End of macro FORTH_DSP_VALUEHL
205f			 
205f				; TODO add floating point number detection 
205f			 
205f				if DEBUG_FORTH_WORDS 
205f					DMARK "DUi" 
205f f5				push af  
2060 3a 74 20			ld a, (.dmark)  
2063 32 71 ee			ld (debug_mark),a  
2066 3a 75 20			ld a, (.dmark+1)  
2069 32 72 ee			ld (debug_mark+1),a  
206c 3a 76 20			ld a, (.dmark+2)  
206f 32 73 ee			ld (debug_mark+2),a  
2072 18 03			jr .pastdmark  
2074 ..			.dmark: db "DUi"  
2077 f1			.pastdmark: pop af  
2078			endm  
# End of macro DMARK
2078					CALLMONITOR 
2078 cd a0 14			call break_point_state  
207b				endm  
# End of macro CALLMONITOR
207b				endif 
207b			 
207b cd 0b 1b				call forth_push_numhl 
207e					NEXTW 
207e c3 74 1e			jp macro_next 
2081				endm 
# End of macro NEXTW
2081			.ZDUP: 
2081				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2081 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2082 b9 20			dw .SWAP            
2084 05				db 4 + 1 
2085 .. 00			db "?DUP",0              
208a				endm 
# End of macro CWHEAD
208a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
208a			 
208a					if DEBUG_FORTH_WORDS_KEY 
208a						DMARK "qDU" 
208a f5				push af  
208b 3a 9f 20			ld a, (.dmark)  
208e 32 71 ee			ld (debug_mark),a  
2091 3a a0 20			ld a, (.dmark+1)  
2094 32 72 ee			ld (debug_mark+1),a  
2097 3a a1 20			ld a, (.dmark+2)  
209a 32 73 ee			ld (debug_mark+2),a  
209d 18 03			jr .pastdmark  
209f ..			.dmark: db "qDU"  
20a2 f1			.pastdmark: pop af  
20a3			endm  
# End of macro DMARK
20a3						CALLMONITOR 
20a3 cd a0 14			call break_point_state  
20a6				endm  
# End of macro CALLMONITOR
20a6					endif 
20a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20a6 cd 02 1d			call macro_dsp_valuehl 
20a9				endm 
# End of macro FORTH_DSP_VALUEHL
20a9			 
20a9 e5					push hl 
20aa			 
20aa					; is it a zero? 
20aa			 
20aa 3e 00				ld a, 0 
20ac 84					add h 
20ad 85					add l 
20ae			 
20ae e1					pop hl 
20af			 
20af fe 00				cp 0 
20b1 28 03				jr z, .dup2orig 
20b3			 
20b3			 
20b3 cd 0b 1b				call forth_push_numhl 
20b6			 
20b6			 
20b6				; TODO add floating point number detection 
20b6			 
20b6			.dup2orig: 
20b6			 
20b6					NEXTW 
20b6 c3 74 1e			jp macro_next 
20b9				endm 
# End of macro NEXTW
20b9			.SWAP: 
20b9				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
20b9 18				db WORD_SYS_CORE+OPCODE_SWAP             
20ba f8 20			dw .COLN            
20bc 05				db 4 + 1 
20bd .. 00			db "SWAP",0              
20c2				endm 
# End of macro CWHEAD
20c2			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
20c2					if DEBUG_FORTH_WORDS_KEY 
20c2						DMARK "SWP" 
20c2 f5				push af  
20c3 3a d7 20			ld a, (.dmark)  
20c6 32 71 ee			ld (debug_mark),a  
20c9 3a d8 20			ld a, (.dmark+1)  
20cc 32 72 ee			ld (debug_mark+1),a  
20cf 3a d9 20			ld a, (.dmark+2)  
20d2 32 73 ee			ld (debug_mark+2),a  
20d5 18 03			jr .pastdmark  
20d7 ..			.dmark: db "SWP"  
20da f1			.pastdmark: pop af  
20db			endm  
# End of macro DMARK
20db						CALLMONITOR 
20db cd a0 14			call break_point_state  
20de				endm  
# End of macro CALLMONITOR
20de					endif 
20de			 
20de					FORTH_DSP_VALUEHL 
20de cd 02 1d			call macro_dsp_valuehl 
20e1				endm 
# End of macro FORTH_DSP_VALUEHL
20e1 e5					push hl     ; w2 
20e2			 
20e2					FORTH_DSP_POP 
20e2 cd ba 1d			call macro_forth_dsp_pop 
20e5				endm 
# End of macro FORTH_DSP_POP
20e5			 
20e5					FORTH_DSP_VALUEHL 
20e5 cd 02 1d			call macro_dsp_valuehl 
20e8				endm 
# End of macro FORTH_DSP_VALUEHL
20e8			 
20e8					FORTH_DSP_POP 
20e8 cd ba 1d			call macro_forth_dsp_pop 
20eb				endm 
# End of macro FORTH_DSP_POP
20eb			 
20eb d1					pop de     ; w2	, hl = w1 
20ec			 
20ec eb					ex de, hl 
20ed d5					push de 
20ee			 
20ee cd 0b 1b				call forth_push_numhl 
20f1			 
20f1 e1					pop hl 
20f2			 
20f2 cd 0b 1b				call forth_push_numhl 
20f5					 
20f5			 
20f5					NEXTW 
20f5 c3 74 1e			jp macro_next 
20f8				endm 
# End of macro NEXTW
20f8			.COLN: 
20f8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
20f8 19				db WORD_SYS_CORE+OPCODE_COLN             
20f9 84 22			dw .SCOLN            
20fb 02				db 1 + 1 
20fc .. 00			db ":",0              
20fe				endm 
# End of macro CWHEAD
20fe			; | : ( -- )         Create new word | DONE 
20fe			 
20fe					if DEBUG_FORTH_WORDS_KEY 
20fe						DMARK "CLN" 
20fe f5				push af  
20ff 3a 13 21			ld a, (.dmark)  
2102 32 71 ee			ld (debug_mark),a  
2105 3a 14 21			ld a, (.dmark+1)  
2108 32 72 ee			ld (debug_mark+1),a  
210b 3a 15 21			ld a, (.dmark+2)  
210e 32 73 ee			ld (debug_mark+2),a  
2111 18 03			jr .pastdmark  
2113 ..			.dmark: db "CLN"  
2116 f1			.pastdmark: pop af  
2117			endm  
# End of macro DMARK
2117						CALLMONITOR 
2117 cd a0 14			call break_point_state  
211a				endm  
# End of macro CALLMONITOR
211a					endif 
211a				STACKFRAME OFF $8efe $989f 
211a				if DEBUG_STACK_IMB 
211a					if OFF 
211a						exx 
211a						ld de, $8efe 
211a						ld a, d 
211a						ld hl, curframe 
211a						call hexout 
211a						ld a, e 
211a						ld hl, curframe+2 
211a						call hexout 
211a						ld hl, $8efe 
211a						push hl 
211a						ld hl, $989f 
211a						push hl 
211a						exx 
211a					endif 
211a				endif 
211a			endm 
# End of macro STACKFRAME
211a				; get parser buffer length  of new word 
211a			 
211a				 
211a			 
211a					; move tok past this to start of name defintition 
211a					; TODO get word to define 
211a					; TODO Move past word token 
211a					; TODO get length of string up to the ';' 
211a			 
211a 2a d8 e6			ld hl, (os_tok_ptr) 
211d 23				inc hl 
211e 23				inc hl 
211f			 
211f 3e 3b			ld a, ';' 
2121 cd 08 11			call strlent 
2124			 
2124 7d				ld a,l 
2125 32 d3 e3			ld (os_new_parse_len), a 
2128			 
2128			 
2128			if DEBUG_FORTH_UWORD 
2128 ed 5b d8 e6		ld de, (os_tok_ptr) 
212c						DMARK ":01" 
212c f5				push af  
212d 3a 41 21			ld a, (.dmark)  
2130 32 71 ee			ld (debug_mark),a  
2133 3a 42 21			ld a, (.dmark+1)  
2136 32 72 ee			ld (debug_mark+1),a  
2139 3a 43 21			ld a, (.dmark+2)  
213c 32 73 ee			ld (debug_mark+2),a  
213f 18 03			jr .pastdmark  
2141 ..			.dmark: db ":01"  
2144 f1			.pastdmark: pop af  
2145			endm  
# End of macro DMARK
2145				CALLMONITOR 
2145 cd a0 14			call break_point_state  
2148				endm  
# End of macro CALLMONITOR
2148			endif 
2148			 
2148			; 
2148			;  new word memory layout: 
2148			;  
2148			;    : adg 6666 ;  
2148			; 
2148			;    db   1     ; user defined word  
2148 23				inc hl    
2149			;    dw   sysdict 
2149 23				inc hl 
214a 23				inc hl 
214b			;    db <word len>+1 (for null) 
214b 23				inc hl 
214c			;    db .... <word> 
214c			; 
214c			 
214c 23				inc hl    ; some extras for the word preamble before the above 
214d 23				inc hl 
214e 23				inc hl 
214f 23				inc hl 
2150 23				inc hl 
2151 23				inc hl 
2152 23				inc hl  
2153 23				inc hl 
2154 23				inc hl 
2155 23				inc hl 
2156 23				inc hl 
2157 23				inc hl 
2158 23				inc hl 
2159 23				inc hl     ; TODO how many do we really need?     maybe only 6 
215a			;       exec word buffer 
215a			;	<ptr word>   
215a 23				inc hl 
215b 23				inc hl 
215c			;       <word list><null term> 7F final term 
215c			 
215c			 
215c			if DEBUG_FORTH_UWORD 
215c						DMARK ":02" 
215c f5				push af  
215d 3a 71 21			ld a, (.dmark)  
2160 32 71 ee			ld (debug_mark),a  
2163 3a 72 21			ld a, (.dmark+1)  
2166 32 72 ee			ld (debug_mark+1),a  
2169 3a 73 21			ld a, (.dmark+2)  
216c 32 73 ee			ld (debug_mark+2),a  
216f 18 03			jr .pastdmark  
2171 ..			.dmark: db ":02"  
2174 f1			.pastdmark: pop af  
2175			endm  
# End of macro DMARK
2175				CALLMONITOR 
2175 cd a0 14			call break_point_state  
2178				endm  
# End of macro CALLMONITOR
2178			endif 
2178			 
2178				 
2178					; malloc the size 
2178			 
2178 cd 66 11				call malloc 
217b 22 d5 e3				ld (os_new_malloc), hl     ; save malloc start 
217e			 
217e			;    db   1     ; user defined word  
217e 3e 01				ld a, WORD_SYS_UWORD  
2180 77					ld (hl), a 
2181				 
2181 23				inc hl    
2182			;    dw   sysdict 
2182 11 cc 1f			ld de, sysdict       ; continue on with the scan to the system dict 
2185 73				ld (hl), e 
2186 23				inc hl 
2187 72				ld (hl), d 
2188 23				inc hl 
2189			 
2189			 
2189			;    Setup dict word 
2189			 
2189 23				inc hl 
218a 22 cf e3			ld (os_new_work_ptr), hl     ; save start of dict word  
218d			 
218d				; 1. get length of dict word 
218d			 
218d			 
218d 2a d8 e6			ld hl, (os_tok_ptr) 
2190 23				inc hl 
2191 23				inc hl    ; position to start of dict word 
2192 3e 00			ld a, 0 
2194 cd 08 11			call strlent 
2197			 
2197			 
2197 23				inc hl    ; to include null??? 
2198			 
2198				; write length of dict word 
2198			 
2198 ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
219c 1b				dec de 
219d eb				ex de, hl 
219e 73				ld (hl), e 
219f eb				ex de, hl 
21a0			 
21a0				 
21a0			 
21a0				; copy  
21a0 4d				ld c, l 
21a1 06 00			ld b, 0 
21a3 ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
21a7 2a d8 e6			ld hl, (os_tok_ptr) 
21aa 23				inc hl 
21ab 23				inc hl    ; position to start of dict word 
21ac				 
21ac			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
21ac				 
21ac				; TODO need to convert word to upper case 
21ac			 
21ac			ucasetok:	 
21ac 7e				ld a,(hl) 
21ad cd f4 10			call toUpper 
21b0 77				ld (hl),a 
21b1 ed a0			ldi 
21b3 f2 ac 21		 	jp p, ucasetok 
21b6			 
21b6			 
21b6			 
21b6				; de now points to start of where the word body code should be placed 
21b6 ed 53 cf e3		ld (os_new_work_ptr), de 
21ba				; hl now points to the words to throw at forthexec which needs to be copied 
21ba 22 cd e3			ld (os_new_src_ptr), hl 
21bd			 
21bd				; TODO add 'call to forthexec' 
21bd			 
21bd			if DEBUG_FORTH_UWORD 
21bd c5				push bc 
21be ed 4b d5 e3		ld bc, (os_new_malloc) 
21c2						DMARK ":0x" 
21c2 f5				push af  
21c3 3a d7 21			ld a, (.dmark)  
21c6 32 71 ee			ld (debug_mark),a  
21c9 3a d8 21			ld a, (.dmark+1)  
21cc 32 72 ee			ld (debug_mark+1),a  
21cf 3a d9 21			ld a, (.dmark+2)  
21d2 32 73 ee			ld (debug_mark+2),a  
21d5 18 03			jr .pastdmark  
21d7 ..			.dmark: db ":0x"  
21da f1			.pastdmark: pop af  
21db			endm  
# End of macro DMARK
21db				CALLMONITOR 
21db cd a0 14			call break_point_state  
21de				endm  
# End of macro CALLMONITOR
21de c1				pop bc 
21df			endif 
21df			 
21df			 
21df				; create word preamble which should be: 
21df			 
21df			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
21df			 
21df				;    ld hl, <word code> 
21df				;    jp user_exec 
21df			        ;    <word code bytes> 
21df			 
21df			 
21df			;	inc de     ; TODO ??? or are we already past the word's null 
21df eb				ex de, hl 
21e0			 
21e0 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
21e2			 
21e2 23				inc hl 
21e3 22 c9 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
21e6 23				inc hl 
21e7			 
21e7 23				inc hl 
21e8 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
21ea			 
21ea 01 d4 45			ld bc, user_exec 
21ed 23				inc hl 
21ee 71				ld (hl), c     ; poke address of user_exec 
21ef 23				inc hl 
21f0 70				ld (hl), b     
21f1			 ; 
21f1			;	inc hl 
21f1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21f1			; 
21f1			; 
21f1			;	ld bc, macro_forth_rsp_next 
21f1			;	inc hl 
21f1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
21f1			;	inc hl 
21f1			;	ld (hl), b     
21f1			 ; 
21f1			;	inc hl 
21f1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21f1			; 
21f1			; 
21f1			;	inc hl 
21f1			;	ld bc, forthexec 
21f1			;	ld (hl), c     ; poke address of forthexec 
21f1			;	inc hl 
21f1			;	ld (hl), b      
21f1			; 
21f1			;	inc hl 
21f1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
21f1			; 
21f1			;	ld bc, user_dict_next 
21f1			;	inc hl 
21f1			;	ld (hl), c     ; poke address of forthexec 
21f1			;	inc hl 
21f1			;	ld (hl), b      
21f1			 
21f1				; hl is now where we need to copy the word byte data to save this 
21f1			 
21f1 23				inc hl 
21f2 22 cb e3			ld (os_new_exec), hl 
21f5				 
21f5				; copy definition 
21f5			 
21f5 eb				ex de, hl 
21f6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
21f6			;	inc de    ; skip the PC for this parse 
21f6 3a d3 e3			ld a, (os_new_parse_len) 
21f9 4f				ld c, a 
21fa 06 00			ld b, 0 
21fc ed b0			ldir		 ; copy defintion 
21fe			 
21fe			 
21fe				; poke the address of where the new word bytes live for forthexec 
21fe			 
21fe 2a c9 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2201			 
2201 ed 5b cb e3		ld de, (os_new_exec)      
2205				 
2205 73				ld (hl), e 
2206 23				inc hl 
2207 72				ld (hl), d 
2208			 
2208					; TODO copy last user dict word next link to this word 
2208					; TODO update last user dict word to point to this word 
2208			; 
2208			; hl f923 de 812a ; bc 811a 
2208			 
2208			if DEBUG_FORTH_UWORD 
2208 c5				push bc 
2209 ed 4b d5 e3		ld bc, (os_new_malloc) 
220d						DMARK ":0A" 
220d f5				push af  
220e 3a 22 22			ld a, (.dmark)  
2211 32 71 ee			ld (debug_mark),a  
2214 3a 23 22			ld a, (.dmark+1)  
2217 32 72 ee			ld (debug_mark+1),a  
221a 3a 24 22			ld a, (.dmark+2)  
221d 32 73 ee			ld (debug_mark+2),a  
2220 18 03			jr .pastdmark  
2222 ..			.dmark: db ":0A"  
2225 f1			.pastdmark: pop af  
2226			endm  
# End of macro DMARK
2226				CALLMONITOR 
2226 cd a0 14			call break_point_state  
2229				endm  
# End of macro CALLMONITOR
2229 c1				pop bc 
222a			endif 
222a			if DEBUG_FORTH_UWORD 
222a c5				push bc 
222b ed 4b d5 e3		ld bc, (os_new_malloc) 
222f 03				inc bc 
2230 03				inc bc 
2231 03				inc bc 
2232 03				inc bc 
2233 03				inc bc 
2234 03				inc bc 
2235 03				inc bc 
2236 03				inc bc 
2237			 
2237						DMARK ":0B" 
2237 f5				push af  
2238 3a 4c 22			ld a, (.dmark)  
223b 32 71 ee			ld (debug_mark),a  
223e 3a 4d 22			ld a, (.dmark+1)  
2241 32 72 ee			ld (debug_mark+1),a  
2244 3a 4e 22			ld a, (.dmark+2)  
2247 32 73 ee			ld (debug_mark+2),a  
224a 18 03			jr .pastdmark  
224c ..			.dmark: db ":0B"  
224f f1			.pastdmark: pop af  
2250			endm  
# End of macro DMARK
2250				CALLMONITOR 
2250 cd a0 14			call break_point_state  
2253				endm  
# End of macro CALLMONITOR
2253 c1				pop bc 
2254			endif 
2254			 
2254			; update word dict linked list for new word 
2254			 
2254			 
2254 2a d4 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2257 23			inc hl     ; move to next work linked list ptr 
2258			 
2258 ed 5b d5 e3	ld de, (os_new_malloc)		 ; new next word 
225c 73			ld (hl), e 
225d 23			inc hl 
225e 72			ld (hl), d 
225f			 
225f			if DEBUG_FORTH_UWORD 
225f ed 4b d4 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2263			endif 
2263			 
2263 ed 53 d4 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2267			 
2267			 
2267			if DEBUG_FORTH_UWORD 
2267						DMARK ":0+" 
2267 f5				push af  
2268 3a 7c 22			ld a, (.dmark)  
226b 32 71 ee			ld (debug_mark),a  
226e 3a 7d 22			ld a, (.dmark+1)  
2271 32 72 ee			ld (debug_mark+1),a  
2274 3a 7e 22			ld a, (.dmark+2)  
2277 32 73 ee			ld (debug_mark+2),a  
227a 18 03			jr .pastdmark  
227c ..			.dmark: db ":0+"  
227f f1			.pastdmark: pop af  
2280			endm  
# End of macro DMARK
2280				CALLMONITOR 
2280 cd a0 14			call break_point_state  
2283				endm  
# End of macro CALLMONITOR
2283			endif 
2283			 
2283				STACKFRAMECHK OFF $8efe $989f 
2283				if DEBUG_STACK_IMB 
2283					if OFF 
2283						exx 
2283						ld hl, $989f 
2283						pop de   ; $989f 
2283						call cmp16 
2283						jr nz, .spnosame 
2283						ld hl, $8efe 
2283						pop de   ; $8efe 
2283						call cmp16 
2283						jr z, .spfrsame 
2283						.spnosame: call showsperror 
2283						.spfrsame: nop 
2283						exx 
2283					endif 
2283				endif 
2283			endm 
# End of macro STACKFRAMECHK
2283			 
2283 c9			ret    ; dont process any remaining parser tokens as they form new word 
2284			 
2284			 
2284			 
2284			 
2284			;		NEXT 
2284			.SCOLN: 
2284			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2284 06				db OPCODE_SCOLN 
2285 d0 22			dw .DROP 
2287 02				db 2 
2288 .. 00			db ";",0           
228a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
228a					if DEBUG_FORTH_WORDS_KEY 
228a						DMARK "SCN" 
228a f5				push af  
228b 3a 9f 22			ld a, (.dmark)  
228e 32 71 ee			ld (debug_mark),a  
2291 3a a0 22			ld a, (.dmark+1)  
2294 32 72 ee			ld (debug_mark+1),a  
2297 3a a1 22			ld a, (.dmark+2)  
229a 32 73 ee			ld (debug_mark+2),a  
229d 18 03			jr .pastdmark  
229f ..			.dmark: db "SCN"  
22a2 f1			.pastdmark: pop af  
22a3			endm  
# End of macro DMARK
22a3						CALLMONITOR 
22a3 cd a0 14			call break_point_state  
22a6				endm  
# End of macro CALLMONITOR
22a6					endif 
22a6					FORTH_RSP_TOS 
22a6 cd c9 1a			call macro_forth_rsp_tos 
22a9				endm 
# End of macro FORTH_RSP_TOS
22a9 e5					push hl 
22aa					FORTH_RSP_POP 
22aa cd d3 1a			call macro_forth_rsp_pop 
22ad				endm 
# End of macro FORTH_RSP_POP
22ad e1					pop hl 
22ae			;		ex de,hl 
22ae 22 d8 e6				ld (os_tok_ptr),hl 
22b1			 
22b1			if DEBUG_FORTH_UWORD 
22b1						DMARK "SCL" 
22b1 f5				push af  
22b2 3a c6 22			ld a, (.dmark)  
22b5 32 71 ee			ld (debug_mark),a  
22b8 3a c7 22			ld a, (.dmark+1)  
22bb 32 72 ee			ld (debug_mark+1),a  
22be 3a c8 22			ld a, (.dmark+2)  
22c1 32 73 ee			ld (debug_mark+2),a  
22c4 18 03			jr .pastdmark  
22c6 ..			.dmark: db "SCL"  
22c9 f1			.pastdmark: pop af  
22ca			endm  
# End of macro DMARK
22ca				CALLMONITOR 
22ca cd a0 14			call break_point_state  
22cd				endm  
# End of macro CALLMONITOR
22cd			endif 
22cd					NEXTW 
22cd c3 74 1e			jp macro_next 
22d0				endm 
# End of macro NEXTW
22d0			 
22d0			.DROP: 
22d0				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
22d0 1b				db WORD_SYS_CORE+OPCODE_DROP             
22d1 fb 22			dw .DUP2            
22d3 05				db 4 + 1 
22d4 .. 00			db "DROP",0              
22d9				endm 
# End of macro CWHEAD
22d9			; | DROP ( w -- )   drop the TOS item   | DONE 
22d9					if DEBUG_FORTH_WORDS_KEY 
22d9						DMARK "DRP" 
22d9 f5				push af  
22da 3a ee 22			ld a, (.dmark)  
22dd 32 71 ee			ld (debug_mark),a  
22e0 3a ef 22			ld a, (.dmark+1)  
22e3 32 72 ee			ld (debug_mark+1),a  
22e6 3a f0 22			ld a, (.dmark+2)  
22e9 32 73 ee			ld (debug_mark+2),a  
22ec 18 03			jr .pastdmark  
22ee ..			.dmark: db "DRP"  
22f1 f1			.pastdmark: pop af  
22f2			endm  
# End of macro DMARK
22f2						CALLMONITOR 
22f2 cd a0 14			call break_point_state  
22f5				endm  
# End of macro CALLMONITOR
22f5					endif 
22f5					FORTH_DSP_POP 
22f5 cd ba 1d			call macro_forth_dsp_pop 
22f8				endm 
# End of macro FORTH_DSP_POP
22f8					NEXTW 
22f8 c3 74 1e			jp macro_next 
22fb				endm 
# End of macro NEXTW
22fb			.DUP2: 
22fb				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
22fb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
22fc 40 23			dw .DROP2            
22fe 05				db 4 + 1 
22ff .. 00			db "2DUP",0              
2304				endm 
# End of macro CWHEAD
2304			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2304					if DEBUG_FORTH_WORDS_KEY 
2304						DMARK "2DU" 
2304 f5				push af  
2305 3a 19 23			ld a, (.dmark)  
2308 32 71 ee			ld (debug_mark),a  
230b 3a 1a 23			ld a, (.dmark+1)  
230e 32 72 ee			ld (debug_mark+1),a  
2311 3a 1b 23			ld a, (.dmark+2)  
2314 32 73 ee			ld (debug_mark+2),a  
2317 18 03			jr .pastdmark  
2319 ..			.dmark: db "2DU"  
231c f1			.pastdmark: pop af  
231d			endm  
# End of macro DMARK
231d						CALLMONITOR 
231d cd a0 14			call break_point_state  
2320				endm  
# End of macro CALLMONITOR
2320					endif 
2320					FORTH_DSP_VALUEHL 
2320 cd 02 1d			call macro_dsp_valuehl 
2323				endm 
# End of macro FORTH_DSP_VALUEHL
2323 e5					push hl      ; 2 
2324			 
2324					FORTH_DSP_POP 
2324 cd ba 1d			call macro_forth_dsp_pop 
2327				endm 
# End of macro FORTH_DSP_POP
2327					 
2327					FORTH_DSP_VALUEHL 
2327 cd 02 1d			call macro_dsp_valuehl 
232a				endm 
# End of macro FORTH_DSP_VALUEHL
232a			;		push hl      ; 1 
232a			 
232a					FORTH_DSP_POP 
232a cd ba 1d			call macro_forth_dsp_pop 
232d				endm 
# End of macro FORTH_DSP_POP
232d			 
232d			;		pop hl       ; 1 
232d d1					pop de       ; 2 
232e			 
232e cd 0b 1b				call forth_push_numhl 
2331 eb					ex de, hl 
2332 cd 0b 1b				call forth_push_numhl 
2335			 
2335					 
2335 eb					ex de, hl 
2336			 
2336 cd 0b 1b				call forth_push_numhl 
2339 eb					ex de, hl 
233a cd 0b 1b				call forth_push_numhl 
233d			 
233d			 
233d					NEXTW 
233d c3 74 1e			jp macro_next 
2340				endm 
# End of macro NEXTW
2340			.DROP2: 
2340				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2340 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2341 6f 23			dw .SWAP2            
2343 06				db 5 + 1 
2344 .. 00			db "2DROP",0              
234a				endm 
# End of macro CWHEAD
234a			; | 2DROP ( w w -- )    Double drop | DONE 
234a					if DEBUG_FORTH_WORDS_KEY 
234a						DMARK "2DR" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 71 ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 72 ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 73 ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db "2DR"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363						CALLMONITOR 
2363 cd a0 14			call break_point_state  
2366				endm  
# End of macro CALLMONITOR
2366					endif 
2366					FORTH_DSP_POP 
2366 cd ba 1d			call macro_forth_dsp_pop 
2369				endm 
# End of macro FORTH_DSP_POP
2369					FORTH_DSP_POP 
2369 cd ba 1d			call macro_forth_dsp_pop 
236c				endm 
# End of macro FORTH_DSP_POP
236c					NEXTW 
236c c3 74 1e			jp macro_next 
236f				endm 
# End of macro NEXTW
236f			.SWAP2: 
236f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
236f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2370 98 23			dw .AT            
2372 06				db 5 + 1 
2373 .. 00			db "2SWAP",0              
2379				endm 
# End of macro CWHEAD
2379			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2379					if DEBUG_FORTH_WORDS_KEY 
2379						DMARK "2SW" 
2379 f5				push af  
237a 3a 8e 23			ld a, (.dmark)  
237d 32 71 ee			ld (debug_mark),a  
2380 3a 8f 23			ld a, (.dmark+1)  
2383 32 72 ee			ld (debug_mark+1),a  
2386 3a 90 23			ld a, (.dmark+2)  
2389 32 73 ee			ld (debug_mark+2),a  
238c 18 03			jr .pastdmark  
238e ..			.dmark: db "2SW"  
2391 f1			.pastdmark: pop af  
2392			endm  
# End of macro DMARK
2392						CALLMONITOR 
2392 cd a0 14			call break_point_state  
2395				endm  
# End of macro CALLMONITOR
2395					endif 
2395					NEXTW 
2395 c3 74 1e			jp macro_next 
2398				endm 
# End of macro NEXTW
2398			.AT: 
2398				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2398 1f				db WORD_SYS_CORE+OPCODE_AT             
2399 ca 23			dw .CAT            
239b 02				db 1 + 1 
239c .. 00			db "@",0              
239e				endm 
# End of macro CWHEAD
239e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
239e			 
239e					if DEBUG_FORTH_WORDS_KEY 
239e						DMARK "AT." 
239e f5				push af  
239f 3a b3 23			ld a, (.dmark)  
23a2 32 71 ee			ld (debug_mark),a  
23a5 3a b4 23			ld a, (.dmark+1)  
23a8 32 72 ee			ld (debug_mark+1),a  
23ab 3a b5 23			ld a, (.dmark+2)  
23ae 32 73 ee			ld (debug_mark+2),a  
23b1 18 03			jr .pastdmark  
23b3 ..			.dmark: db "AT."  
23b6 f1			.pastdmark: pop af  
23b7			endm  
# End of macro DMARK
23b7						CALLMONITOR 
23b7 cd a0 14			call break_point_state  
23ba				endm  
# End of macro CALLMONITOR
23ba					endif 
23ba			.getbyteat:	 
23ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ba cd 02 1d			call macro_dsp_valuehl 
23bd				endm 
# End of macro FORTH_DSP_VALUEHL
23bd					 
23bd			;		push hl 
23bd				 
23bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23bd cd ba 1d			call macro_forth_dsp_pop 
23c0				endm 
# End of macro FORTH_DSP_POP
23c0			 
23c0			;		pop hl 
23c0			 
23c0 7e					ld a, (hl) 
23c1			 
23c1 6f					ld l, a 
23c2 26 00				ld h, 0 
23c4 cd 0b 1b				call forth_push_numhl 
23c7			 
23c7					NEXTW 
23c7 c3 74 1e			jp macro_next 
23ca				endm 
# End of macro NEXTW
23ca			.CAT: 
23ca				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
23ca 20				db WORD_SYS_CORE+OPCODE_CAT             
23cb f3 23			dw .BANG            
23cd 03				db 2 + 1 
23ce .. 00			db "C@",0              
23d1				endm 
# End of macro CWHEAD
23d1			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
23d1					if DEBUG_FORTH_WORDS_KEY 
23d1						DMARK "CAA" 
23d1 f5				push af  
23d2 3a e6 23			ld a, (.dmark)  
23d5 32 71 ee			ld (debug_mark),a  
23d8 3a e7 23			ld a, (.dmark+1)  
23db 32 72 ee			ld (debug_mark+1),a  
23de 3a e8 23			ld a, (.dmark+2)  
23e1 32 73 ee			ld (debug_mark+2),a  
23e4 18 03			jr .pastdmark  
23e6 ..			.dmark: db "CAA"  
23e9 f1			.pastdmark: pop af  
23ea			endm  
# End of macro DMARK
23ea						CALLMONITOR 
23ea cd a0 14			call break_point_state  
23ed				endm  
# End of macro CALLMONITOR
23ed					endif 
23ed c3 ba 23				jp .getbyteat 
23f0					NEXTW 
23f0 c3 74 1e			jp macro_next 
23f3				endm 
# End of macro NEXTW
23f3			.BANG: 
23f3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
23f3 21				db WORD_SYS_CORE+OPCODE_BANG             
23f4 29 24			dw .CBANG            
23f6 02				db 1 + 1 
23f7 .. 00			db "!",0              
23f9				endm 
# End of macro CWHEAD
23f9			; | ! ( x w -- ) Store x at address w      | DONE 
23f9					if DEBUG_FORTH_WORDS_KEY 
23f9						DMARK "BNG" 
23f9 f5				push af  
23fa 3a 0e 24			ld a, (.dmark)  
23fd 32 71 ee			ld (debug_mark),a  
2400 3a 0f 24			ld a, (.dmark+1)  
2403 32 72 ee			ld (debug_mark+1),a  
2406 3a 10 24			ld a, (.dmark+2)  
2409 32 73 ee			ld (debug_mark+2),a  
240c 18 03			jr .pastdmark  
240e ..			.dmark: db "BNG"  
2411 f1			.pastdmark: pop af  
2412			endm  
# End of macro DMARK
2412						CALLMONITOR 
2412 cd a0 14			call break_point_state  
2415				endm  
# End of macro CALLMONITOR
2415					endif 
2415			 
2415			.storebyteat:		 
2415					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2415 cd 02 1d			call macro_dsp_valuehl 
2418				endm 
# End of macro FORTH_DSP_VALUEHL
2418					 
2418 e5					push hl 
2419				 
2419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2419 cd ba 1d			call macro_forth_dsp_pop 
241c				endm 
# End of macro FORTH_DSP_POP
241c			 
241c					; get byte to poke 
241c			 
241c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
241c cd 02 1d			call macro_dsp_valuehl 
241f				endm 
# End of macro FORTH_DSP_VALUEHL
241f e5					push hl 
2420			 
2420			 
2420					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2420 cd ba 1d			call macro_forth_dsp_pop 
2423				endm 
# End of macro FORTH_DSP_POP
2423			 
2423			 
2423 d1					pop de 
2424 e1					pop hl 
2425			 
2425 73					ld (hl),e 
2426			 
2426			 
2426					NEXTW 
2426 c3 74 1e			jp macro_next 
2429				endm 
# End of macro NEXTW
2429			.CBANG: 
2429				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2429 22				db WORD_SYS_CORE+OPCODE_CBANG             
242a 52 24			dw .SCALL            
242c 03				db 2 + 1 
242d .. 00			db "C!",0              
2430				endm 
# End of macro CWHEAD
2430			; | C!  ( x w -- ) Store x at address w  | DONE 
2430					if DEBUG_FORTH_WORDS_KEY 
2430						DMARK "CBA" 
2430 f5				push af  
2431 3a 45 24			ld a, (.dmark)  
2434 32 71 ee			ld (debug_mark),a  
2437 3a 46 24			ld a, (.dmark+1)  
243a 32 72 ee			ld (debug_mark+1),a  
243d 3a 47 24			ld a, (.dmark+2)  
2440 32 73 ee			ld (debug_mark+2),a  
2443 18 03			jr .pastdmark  
2445 ..			.dmark: db "CBA"  
2448 f1			.pastdmark: pop af  
2449			endm  
# End of macro DMARK
2449						CALLMONITOR 
2449 cd a0 14			call break_point_state  
244c				endm  
# End of macro CALLMONITOR
244c					endif 
244c c3 15 24				jp .storebyteat 
244f					NEXTW 
244f c3 74 1e			jp macro_next 
2452				endm 
# End of macro NEXTW
2452			.SCALL: 
2452				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2452 23				db WORD_SYS_CORE+OPCODE_SCALL             
2453 86 24			dw .DEPTH            
2455 05				db 4 + 1 
2456 .. 00			db "CALL",0              
245b				endm 
# End of macro CWHEAD
245b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
245b					if DEBUG_FORTH_WORDS_KEY 
245b						DMARK "CLL" 
245b f5				push af  
245c 3a 70 24			ld a, (.dmark)  
245f 32 71 ee			ld (debug_mark),a  
2462 3a 71 24			ld a, (.dmark+1)  
2465 32 72 ee			ld (debug_mark+1),a  
2468 3a 72 24			ld a, (.dmark+2)  
246b 32 73 ee			ld (debug_mark+2),a  
246e 18 03			jr .pastdmark  
2470 ..			.dmark: db "CLL"  
2473 f1			.pastdmark: pop af  
2474			endm  
# End of macro DMARK
2474						CALLMONITOR 
2474 cd a0 14			call break_point_state  
2477				endm  
# End of macro CALLMONITOR
2477					endif 
2477			 
2477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2477 cd 02 1d			call macro_dsp_valuehl 
247a				endm 
# End of macro FORTH_DSP_VALUEHL
247a			 
247a			;		push hl 
247a			 
247a					; destroy value TOS 
247a			 
247a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
247a cd ba 1d			call macro_forth_dsp_pop 
247d				endm 
# End of macro FORTH_DSP_POP
247d			 
247d						 
247d			;		pop hl 
247d			 
247d					; how to do a call with hl???? save SP? 
247d cd 1d 1e				call forth_call_hl 
2480			 
2480			 
2480					; TODO push value back onto stack for another op etc 
2480			 
2480 cd 0b 1b				call forth_push_numhl 
2483					NEXTW 
2483 c3 74 1e			jp macro_next 
2486				endm 
# End of macro NEXTW
2486			.DEPTH: 
2486				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2486 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2487 c3 24			dw .OVER            
2489 06				db 5 + 1 
248a .. 00			db "DEPTH",0              
2490				endm 
# End of macro CWHEAD
2490			; | DEPTH ( -- u ) Push count of stack | DONE 
2490					; take current TOS and remove from base value div by two to get count 
2490					if DEBUG_FORTH_WORDS_KEY 
2490						DMARK "DEP" 
2490 f5				push af  
2491 3a a5 24			ld a, (.dmark)  
2494 32 71 ee			ld (debug_mark),a  
2497 3a a6 24			ld a, (.dmark+1)  
249a 32 72 ee			ld (debug_mark+1),a  
249d 3a a7 24			ld a, (.dmark+2)  
24a0 32 73 ee			ld (debug_mark+2),a  
24a3 18 03			jr .pastdmark  
24a5 ..			.dmark: db "DEP"  
24a8 f1			.pastdmark: pop af  
24a9			endm  
# End of macro DMARK
24a9						CALLMONITOR 
24a9 cd a0 14			call break_point_state  
24ac				endm  
# End of macro CALLMONITOR
24ac					endif 
24ac			 
24ac			 
24ac 2a 04 eb			ld hl, (cli_data_sp) 
24af 11 3e e9			ld de, cli_data_stack 
24b2 ed 52			sbc hl,de 
24b4				 
24b4				; div by size of stack item 
24b4			 
24b4 5d				ld e,l 
24b5 0e 03			ld c, 3 
24b7 cd 2f 0c			call Div8 
24ba			 
24ba 6f				ld l,a 
24bb 26 00			ld h,0 
24bd			 
24bd				;srl h 
24bd				;rr l 
24bd			 
24bd cd 0b 1b				call forth_push_numhl 
24c0					NEXTW 
24c0 c3 74 1e			jp macro_next 
24c3				endm 
# End of macro NEXTW
24c3			.OVER: 
24c3				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
24c3 42				db WORD_SYS_CORE+46             
24c4 0a 25			dw .PAUSE            
24c6 05				db 4 + 1 
24c7 .. 00			db "OVER",0              
24cc				endm 
# End of macro CWHEAD
24cc			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
24cc					if DEBUG_FORTH_WORDS_KEY 
24cc						DMARK "OVR" 
24cc f5				push af  
24cd 3a e1 24			ld a, (.dmark)  
24d0 32 71 ee			ld (debug_mark),a  
24d3 3a e2 24			ld a, (.dmark+1)  
24d6 32 72 ee			ld (debug_mark+1),a  
24d9 3a e3 24			ld a, (.dmark+2)  
24dc 32 73 ee			ld (debug_mark+2),a  
24df 18 03			jr .pastdmark  
24e1 ..			.dmark: db "OVR"  
24e4 f1			.pastdmark: pop af  
24e5			endm  
# End of macro DMARK
24e5						CALLMONITOR 
24e5 cd a0 14			call break_point_state  
24e8				endm  
# End of macro CALLMONITOR
24e8					endif 
24e8			 
24e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24e8 cd 02 1d			call macro_dsp_valuehl 
24eb				endm 
# End of macro FORTH_DSP_VALUEHL
24eb e5					push hl    ; n2 
24ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24ec cd ba 1d			call macro_forth_dsp_pop 
24ef				endm 
# End of macro FORTH_DSP_POP
24ef			 
24ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24ef cd 02 1d			call macro_dsp_valuehl 
24f2				endm 
# End of macro FORTH_DSP_VALUEHL
24f2 e5					push hl    ; n1 
24f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24f3 cd ba 1d			call macro_forth_dsp_pop 
24f6				endm 
# End of macro FORTH_DSP_POP
24f6			 
24f6 d1					pop de     ; n1 
24f7 e1					pop hl     ; n2 
24f8			 
24f8 d5					push de 
24f9 e5					push hl 
24fa d5					push de 
24fb			 
24fb					; push back  
24fb			 
24fb e1					pop hl 
24fc cd 0b 1b				call forth_push_numhl 
24ff e1					pop hl 
2500 cd 0b 1b				call forth_push_numhl 
2503 e1					pop hl 
2504 cd 0b 1b				call forth_push_numhl 
2507					NEXTW 
2507 c3 74 1e			jp macro_next 
250a				endm 
# End of macro NEXTW
250a			 
250a			.PAUSE: 
250a				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
250a 43				db WORD_SYS_CORE+47             
250b 3f 25			dw .PAUSES            
250d 08				db 7 + 1 
250e .. 00			db "PAUSEMS",0              
2516				endm 
# End of macro CWHEAD
2516			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2516					if DEBUG_FORTH_WORDS_KEY 
2516						DMARK "PMS" 
2516 f5				push af  
2517 3a 2b 25			ld a, (.dmark)  
251a 32 71 ee			ld (debug_mark),a  
251d 3a 2c 25			ld a, (.dmark+1)  
2520 32 72 ee			ld (debug_mark+1),a  
2523 3a 2d 25			ld a, (.dmark+2)  
2526 32 73 ee			ld (debug_mark+2),a  
2529 18 03			jr .pastdmark  
252b ..			.dmark: db "PMS"  
252e f1			.pastdmark: pop af  
252f			endm  
# End of macro DMARK
252f						CALLMONITOR 
252f cd a0 14			call break_point_state  
2532				endm  
# End of macro CALLMONITOR
2532					endif 
2532					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2532 cd 02 1d			call macro_dsp_valuehl 
2535				endm 
# End of macro FORTH_DSP_VALUEHL
2535			;		push hl    ; n2 
2535					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2535 cd ba 1d			call macro_forth_dsp_pop 
2538				endm 
# End of macro FORTH_DSP_POP
2538			;		pop hl 
2538			 
2538 7d					ld a, l 
2539 cd c9 09				call aDelayInMS 
253c				       NEXTW 
253c c3 74 1e			jp macro_next 
253f				endm 
# End of macro NEXTW
253f			.PAUSES:  
253f				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
253f 44				db WORD_SYS_CORE+48             
2540 ae 25			dw .ROT            
2542 06				db 5 + 1 
2543 .. 00			db "PAUSE",0              
2549				endm 
# End of macro CWHEAD
2549			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2549					if DEBUG_FORTH_WORDS_KEY 
2549						DMARK "PAU" 
2549 f5				push af  
254a 3a 5e 25			ld a, (.dmark)  
254d 32 71 ee			ld (debug_mark),a  
2550 3a 5f 25			ld a, (.dmark+1)  
2553 32 72 ee			ld (debug_mark+1),a  
2556 3a 60 25			ld a, (.dmark+2)  
2559 32 73 ee			ld (debug_mark+2),a  
255c 18 03			jr .pastdmark  
255e ..			.dmark: db "PAU"  
2561 f1			.pastdmark: pop af  
2562			endm  
# End of macro DMARK
2562						CALLMONITOR 
2562 cd a0 14			call break_point_state  
2565				endm  
# End of macro CALLMONITOR
2565					endif 
2565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2565 cd 02 1d			call macro_dsp_valuehl 
2568				endm 
# End of macro FORTH_DSP_VALUEHL
2568			;		push hl    ; n2 
2568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2568 cd ba 1d			call macro_forth_dsp_pop 
256b				endm 
# End of macro FORTH_DSP_POP
256b			;		pop hl 
256b 45					ld b, l 
256c					if DEBUG_FORTH_WORDS 
256c						DMARK "PAU" 
256c f5				push af  
256d 3a 81 25			ld a, (.dmark)  
2570 32 71 ee			ld (debug_mark),a  
2573 3a 82 25			ld a, (.dmark+1)  
2576 32 72 ee			ld (debug_mark+1),a  
2579 3a 83 25			ld a, (.dmark+2)  
257c 32 73 ee			ld (debug_mark+2),a  
257f 18 03			jr .pastdmark  
2581 ..			.dmark: db "PAU"  
2584 f1			.pastdmark: pop af  
2585			endm  
# End of macro DMARK
2585						CALLMONITOR 
2585 cd a0 14			call break_point_state  
2588				endm  
# End of macro CALLMONITOR
2588					endif 
2588 c5			.pauses1:	push bc 
2589 cd e4 09				call delay1s 
258c c1					pop bc 
258d					if DEBUG_FORTH_WORDS 
258d						DMARK "PA1" 
258d f5				push af  
258e 3a a2 25			ld a, (.dmark)  
2591 32 71 ee			ld (debug_mark),a  
2594 3a a3 25			ld a, (.dmark+1)  
2597 32 72 ee			ld (debug_mark+1),a  
259a 3a a4 25			ld a, (.dmark+2)  
259d 32 73 ee			ld (debug_mark+2),a  
25a0 18 03			jr .pastdmark  
25a2 ..			.dmark: db "PA1"  
25a5 f1			.pastdmark: pop af  
25a6			endm  
# End of macro DMARK
25a6						CALLMONITOR 
25a6 cd a0 14			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9					endif 
25a9 10 dd				djnz .pauses1 
25ab			 
25ab				       NEXTW 
25ab c3 74 1e			jp macro_next 
25ae				endm 
# End of macro NEXTW
25ae			.ROT: 
25ae				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
25ae 45				db WORD_SYS_CORE+49             
25af fc 25			dw .UWORDS            
25b1 04				db 3 + 1 
25b2 .. 00			db "ROT",0              
25b6				endm 
# End of macro CWHEAD
25b6			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
25b6					if DEBUG_FORTH_WORDS_KEY 
25b6						DMARK "ROT" 
25b6 f5				push af  
25b7 3a cb 25			ld a, (.dmark)  
25ba 32 71 ee			ld (debug_mark),a  
25bd 3a cc 25			ld a, (.dmark+1)  
25c0 32 72 ee			ld (debug_mark+1),a  
25c3 3a cd 25			ld a, (.dmark+2)  
25c6 32 73 ee			ld (debug_mark+2),a  
25c9 18 03			jr .pastdmark  
25cb ..			.dmark: db "ROT"  
25ce f1			.pastdmark: pop af  
25cf			endm  
# End of macro DMARK
25cf						CALLMONITOR 
25cf cd a0 14			call break_point_state  
25d2				endm  
# End of macro CALLMONITOR
25d2					endif 
25d2			 
25d2					FORTH_DSP_VALUEHL 
25d2 cd 02 1d			call macro_dsp_valuehl 
25d5				endm 
# End of macro FORTH_DSP_VALUEHL
25d5 e5					push hl    ; u3  
25d6			 
25d6					FORTH_DSP_POP 
25d6 cd ba 1d			call macro_forth_dsp_pop 
25d9				endm 
# End of macro FORTH_DSP_POP
25d9			   
25d9					FORTH_DSP_VALUEHL 
25d9 cd 02 1d			call macro_dsp_valuehl 
25dc				endm 
# End of macro FORTH_DSP_VALUEHL
25dc e5					push hl     ; u2 
25dd			 
25dd					FORTH_DSP_POP 
25dd cd ba 1d			call macro_forth_dsp_pop 
25e0				endm 
# End of macro FORTH_DSP_POP
25e0			 
25e0					FORTH_DSP_VALUEHL 
25e0 cd 02 1d			call macro_dsp_valuehl 
25e3				endm 
# End of macro FORTH_DSP_VALUEHL
25e3 e5					push hl     ; u1 
25e4			 
25e4					FORTH_DSP_POP 
25e4 cd ba 1d			call macro_forth_dsp_pop 
25e7				endm 
# End of macro FORTH_DSP_POP
25e7			 
25e7 c1					pop bc      ; u1 
25e8 e1					pop hl      ; u2 
25e9 d1					pop de      ; u3 
25ea			 
25ea			 
25ea c5					push bc 
25eb d5					push de 
25ec e5					push hl 
25ed			 
25ed			 
25ed e1					pop hl 
25ee cd 0b 1b				call forth_push_numhl 
25f1			 
25f1 e1					pop hl 
25f2 cd 0b 1b				call forth_push_numhl 
25f5			 
25f5 e1					pop hl 
25f6 cd 0b 1b				call forth_push_numhl 
25f9					 
25f9			 
25f9			 
25f9			 
25f9			 
25f9			 
25f9				       NEXTW 
25f9 c3 74 1e			jp macro_next 
25fc				endm 
# End of macro NEXTW
25fc			 
25fc			.UWORDS: 
25fc				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
25fc 50				db WORD_SYS_CORE+60             
25fd be 26			dw .BP            
25ff 07				db 6 + 1 
2600 .. 00			db "UWORDS",0              
2607				endm 
# End of macro CWHEAD
2607			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2607			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2607			; | | Following the count are the individual words. 
2607			; | | 
2607			; | | e.g. UWORDS 
2607			; | | BOX DIRLIST 2 
2607			; | |  
2607			; | | Can be used to save the words to storage via: 
2607			; | | UWORDS $01 DO $01 APPEND LOOP 
2607				if DEBUG_FORTH_WORDS_KEY 
2607					DMARK "UWR" 
2607 f5				push af  
2608 3a 1c 26			ld a, (.dmark)  
260b 32 71 ee			ld (debug_mark),a  
260e 3a 1d 26			ld a, (.dmark+1)  
2611 32 72 ee			ld (debug_mark+1),a  
2614 3a 1e 26			ld a, (.dmark+2)  
2617 32 73 ee			ld (debug_mark+2),a  
261a 18 03			jr .pastdmark  
261c ..			.dmark: db "UWR"  
261f f1			.pastdmark: pop af  
2620			endm  
# End of macro DMARK
2620					CALLMONITOR 
2620 cd a0 14			call break_point_state  
2623				endm  
# End of macro CALLMONITOR
2623				endif 
2623 21 78 5a				ld hl, baseram 
2626					;ld hl, baseusermem 
2626 01 00 00				ld bc, 0    ; start a counter 
2629			 
2629				; skip dict stub 
2629			 
2629 cd c5 1f				call forth_tok_next 
262c			 
262c			 
262c			; while we have words to look for 
262c			 
262c 7e			.douscan:	ld a, (hl)      
262d				if DEBUG_FORTH_WORDS 
262d					DMARK "UWs" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 71 ee			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 72 ee			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 73 ee			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "UWs"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646					CALLMONITOR 
2646 cd a0 14			call break_point_state  
2649				endm  
# End of macro CALLMONITOR
2649				endif 
2649 fe 00				cp WORD_SYS_END 
264b 28 4d				jr z, .udone 
264d fe 01				cp WORD_SYS_UWORD 
264f 20 44				jr nz, .nuword 
2651			 
2651				if DEBUG_FORTH_WORDS 
2651					DMARK "UWu" 
2651 f5				push af  
2652 3a 66 26			ld a, (.dmark)  
2655 32 71 ee			ld (debug_mark),a  
2658 3a 67 26			ld a, (.dmark+1)  
265b 32 72 ee			ld (debug_mark+1),a  
265e 3a 68 26			ld a, (.dmark+2)  
2661 32 73 ee			ld (debug_mark+2),a  
2664 18 03			jr .pastdmark  
2666 ..			.dmark: db "UWu"  
2669 f1			.pastdmark: pop af  
266a			endm  
# End of macro DMARK
266a					CALLMONITOR 
266a cd a0 14			call break_point_state  
266d				endm  
# End of macro CALLMONITOR
266d				endif 
266d					; we have a uword so push its name to the stack 
266d			 
266d e5				   	push hl  ; save so we can move to next dict block 
266e			 
266e					; skip opcode 
266e 23					inc hl  
266f					; skip next ptr 
266f 23					inc hl  
2670 23					inc hl 
2671					; skip len 
2671 23					inc hl 
2672				if DEBUG_FORTH_WORDS 
2672					DMARK "UWt" 
2672 f5				push af  
2673 3a 87 26			ld a, (.dmark)  
2676 32 71 ee			ld (debug_mark),a  
2679 3a 88 26			ld a, (.dmark+1)  
267c 32 72 ee			ld (debug_mark+1),a  
267f 3a 89 26			ld a, (.dmark+2)  
2682 32 73 ee			ld (debug_mark+2),a  
2685 18 03			jr .pastdmark  
2687 ..			.dmark: db "UWt"  
268a f1			.pastdmark: pop af  
268b			endm  
# End of macro DMARK
268b					CALLMONITOR 
268b cd a0 14			call break_point_state  
268e				endm  
# End of macro CALLMONITOR
268e				endif 
268e 03					inc bc 
268f			 
268f c5					push bc 
2690 cd 79 1b				call forth_push_str 
2693 c1					pop bc 
2694			 
2694 e1					pop hl 	 
2695			 
2695 cd c5 1f		.nuword:	call forth_tok_next 
2698 18 92				jr .douscan  
269a			 
269a			.udone:		 ; push count of uwords found 
269a c5					push bc 
269b e1					pop hl 
269c			 
269c				if DEBUG_FORTH_WORDS 
269c					DMARK "UWc" 
269c f5				push af  
269d 3a b1 26			ld a, (.dmark)  
26a0 32 71 ee			ld (debug_mark),a  
26a3 3a b2 26			ld a, (.dmark+1)  
26a6 32 72 ee			ld (debug_mark+1),a  
26a9 3a b3 26			ld a, (.dmark+2)  
26ac 32 73 ee			ld (debug_mark+2),a  
26af 18 03			jr .pastdmark  
26b1 ..			.dmark: db "UWc"  
26b4 f1			.pastdmark: pop af  
26b5			endm  
# End of macro DMARK
26b5					CALLMONITOR 
26b5 cd a0 14			call break_point_state  
26b8				endm  
# End of macro CALLMONITOR
26b8				endif 
26b8 cd 0b 1b				call forth_push_numhl 
26bb			 
26bb			 
26bb				       NEXTW 
26bb c3 74 1e			jp macro_next 
26be				endm 
# End of macro NEXTW
26be			 
26be			.BP: 
26be				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
26be 54				db WORD_SYS_CORE+64             
26bf f4 26			dw .MONITOR            
26c1 03				db 2 + 1 
26c2 .. 00			db "BP",0              
26c5				endm 
# End of macro CWHEAD
26c5			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
26c5			; | | $00 Will enable the break points within specific code paths 
26c5			; | | $01 Will disable break points 
26c5			; | |  
26c5			; | | By default break points are off. Either the above can be used to enable them 
26c5			; | | or if a key is held down during start up the spashscreen will appear to freeze 
26c5			; | | and on release of the pressed key a message will be disaplayed to notify 
26c5			; | | that break points are enabled. Pressing any key will then continue boot process. 
26c5					; get byte count 
26c5					if DEBUG_FORTH_WORDS_KEY 
26c5						DMARK "BP." 
26c5 f5				push af  
26c6 3a da 26			ld a, (.dmark)  
26c9 32 71 ee			ld (debug_mark),a  
26cc 3a db 26			ld a, (.dmark+1)  
26cf 32 72 ee			ld (debug_mark+1),a  
26d2 3a dc 26			ld a, (.dmark+2)  
26d5 32 73 ee			ld (debug_mark+2),a  
26d8 18 03			jr .pastdmark  
26da ..			.dmark: db "BP."  
26dd f1			.pastdmark: pop af  
26de			endm  
# End of macro DMARK
26de						CALLMONITOR 
26de cd a0 14			call break_point_state  
26e1				endm  
# End of macro CALLMONITOR
26e1					endif 
26e1			 
26e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e1 cd 02 1d			call macro_dsp_valuehl 
26e4				endm 
# End of macro FORTH_DSP_VALUEHL
26e4			 
26e4			;		push hl 
26e4			 
26e4					; destroy value TOS 
26e4			 
26e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e4 cd ba 1d			call macro_forth_dsp_pop 
26e7				endm 
# End of macro FORTH_DSP_POP
26e7			 
26e7			;		pop hl 
26e7			 
26e7 3e 00				ld a,0 
26e9 bd					cp l 
26ea 28 02				jr z, .bpset 
26ec 3e 2a				ld a, '*' 
26ee			 
26ee 32 c8 e3		.bpset:		ld (os_view_disable), a 
26f1			 
26f1			 
26f1					NEXTW 
26f1 c3 74 1e			jp macro_next 
26f4				endm 
# End of macro NEXTW
26f4			 
26f4			 
26f4			.MONITOR: 
26f4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
26f4 55				db WORD_SYS_CORE+65             
26f5 27 27			dw .MALLOC            
26f7 08				db 7 + 1 
26f8 .. 00			db "MONITOR",0              
2700				endm 
# End of macro CWHEAD
2700			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2700			; | | At start the current various registers will be displayed with contents. 
2700			; | | Top right corner will show the most recent debug marker seen. 
2700			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2700			; | | and the return stack pointer (RSP). 
2700			; | | Pressing: 
2700			; | |    1 - Initial screen 
2700			; | |    2 - Display a data dump of HL 
2700			; | |    3 - Display a data dump of DE 
2700			; | |    4 - Display a data dump of BC 
2700			; | |    5 - Display a data dump of HL 
2700			; | |    6 - Display a data dump of DSP 
2700			; | |    7 - Display a data dump of RSP 
2700			; | |    8 - Display a data dump of what is at DSP 
2700			; | |    9 - Display a data dump of what is at RSP 
2700			; | |    0 - Exit monitor and continue running. This will also enable break points 
2700			; | |    * - Disable break points 
2700			; | |    # - Enter traditional monitor mode 
2700			; | | 
2700			; | | Monitor Mode 
2700			; | | ------------ 
2700			; | | A prompt of '>' will be shown for various commands: 
2700			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2700			; | |    C - Continue display a data dump from the last set address 
2700			; | |    M xxxx - Set start of memory edit at address xx 
2700			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2700			; | |    Q - Return to previous 
2700					if DEBUG_FORTH_WORDS_KEY 
2700						DMARK "MON" 
2700 f5				push af  
2701 3a 15 27			ld a, (.dmark)  
2704 32 71 ee			ld (debug_mark),a  
2707 3a 16 27			ld a, (.dmark+1)  
270a 32 72 ee			ld (debug_mark+1),a  
270d 3a 17 27			ld a, (.dmark+2)  
2710 32 73 ee			ld (debug_mark+2),a  
2713 18 03			jr .pastdmark  
2715 ..			.dmark: db "MON"  
2718 f1			.pastdmark: pop af  
2719			endm  
# End of macro DMARK
2719						CALLMONITOR 
2719 cd a0 14			call break_point_state  
271c				endm  
# End of macro CALLMONITOR
271c					endif 
271c 3e 00				ld a, 0 
271e 32 c8 e3				ld (os_view_disable), a 
2721			 
2721					CALLMONITOR 
2721 cd a0 14			call break_point_state  
2724				endm  
# End of macro CALLMONITOR
2724			 
2724			;	call monitor 
2724			 
2724					NEXTW 
2724 c3 74 1e			jp macro_next 
2727				endm 
# End of macro NEXTW
2727			 
2727			 
2727			.MALLOC: 
2727				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2727 56				db WORD_SYS_CORE+66             
2728 50 27			dw .MALLOC2            
272a 06				db 5 + 1 
272b .. 00			db "ALLOT",0              
2731				endm 
# End of macro CWHEAD
2731			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2731					if DEBUG_FORTH_WORDS_KEY 
2731						DMARK "ALL" 
2731 f5				push af  
2732 3a 46 27			ld a, (.dmark)  
2735 32 71 ee			ld (debug_mark),a  
2738 3a 47 27			ld a, (.dmark+1)  
273b 32 72 ee			ld (debug_mark+1),a  
273e 3a 48 27			ld a, (.dmark+2)  
2741 32 73 ee			ld (debug_mark+2),a  
2744 18 03			jr .pastdmark  
2746 ..			.dmark: db "ALL"  
2749 f1			.pastdmark: pop af  
274a			endm  
# End of macro DMARK
274a						CALLMONITOR 
274a cd a0 14			call break_point_state  
274d				endm  
# End of macro CALLMONITOR
274d					endif 
274d c3 77 27				jp .mallocc 
2750			.MALLOC2: 
2750				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2750 56				db WORD_SYS_CORE+66             
2751 8e 27			dw .FREE            
2753 07				db 6 + 1 
2754 .. 00			db "MALLOC",0              
275b				endm 
# End of macro CWHEAD
275b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
275b					; get byte count 
275b					if DEBUG_FORTH_WORDS_KEY 
275b						DMARK "MAL" 
275b f5				push af  
275c 3a 70 27			ld a, (.dmark)  
275f 32 71 ee			ld (debug_mark),a  
2762 3a 71 27			ld a, (.dmark+1)  
2765 32 72 ee			ld (debug_mark+1),a  
2768 3a 72 27			ld a, (.dmark+2)  
276b 32 73 ee			ld (debug_mark+2),a  
276e 18 03			jr .pastdmark  
2770 ..			.dmark: db "MAL"  
2773 f1			.pastdmark: pop af  
2774			endm  
# End of macro DMARK
2774						CALLMONITOR 
2774 cd a0 14			call break_point_state  
2777				endm  
# End of macro CALLMONITOR
2777					endif 
2777			.mallocc: 
2777					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2777 cd 02 1d			call macro_dsp_valuehl 
277a				endm 
# End of macro FORTH_DSP_VALUEHL
277a			 
277a			;		push hl 
277a			 
277a					; destroy value TOS 
277a			 
277a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
277a cd ba 1d			call macro_forth_dsp_pop 
277d				endm 
# End of macro FORTH_DSP_POP
277d			 
277d			;		pop hl 
277d cd 66 11				call malloc 
2780				if DEBUG_FORTH_MALLOC_GUARD 
2780 f5					push af 
2781 cd c8 0c				call ishlzero 
2784			;		ld a, l 
2784			;		add h 
2784			;		cp 0 
2784 f1					pop af 
2785					 
2785 cc a6 46				call z,malloc_error 
2788				endif 
2788			 
2788 cd 0b 1b				call forth_push_numhl 
278b					NEXTW 
278b c3 74 1e			jp macro_next 
278e				endm 
# End of macro NEXTW
278e			 
278e			.FREE: 
278e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
278e 57				db WORD_SYS_CORE+67             
278f bf 27			dw .LIST            
2791 05				db 4 + 1 
2792 .. 00			db "FREE",0              
2797				endm 
# End of macro CWHEAD
2797			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2797					if DEBUG_FORTH_WORDS_KEY 
2797						DMARK "FRE" 
2797 f5				push af  
2798 3a ac 27			ld a, (.dmark)  
279b 32 71 ee			ld (debug_mark),a  
279e 3a ad 27			ld a, (.dmark+1)  
27a1 32 72 ee			ld (debug_mark+1),a  
27a4 3a ae 27			ld a, (.dmark+2)  
27a7 32 73 ee			ld (debug_mark+2),a  
27aa 18 03			jr .pastdmark  
27ac ..			.dmark: db "FRE"  
27af f1			.pastdmark: pop af  
27b0			endm  
# End of macro DMARK
27b0						CALLMONITOR 
27b0 cd a0 14			call break_point_state  
27b3				endm  
# End of macro CALLMONITOR
27b3					endif 
27b3					; get address 
27b3			 
27b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27b3 cd 02 1d			call macro_dsp_valuehl 
27b6				endm 
# End of macro FORTH_DSP_VALUEHL
27b6			 
27b6			;		push hl 
27b6			 
27b6					; destroy value TOS 
27b6			 
27b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27b6 cd ba 1d			call macro_forth_dsp_pop 
27b9				endm 
# End of macro FORTH_DSP_POP
27b9			 
27b9			;		pop hl 
27b9			if FORTH_ENABLE_MALLOCFREE 
27b9 cd 30 12				call free 
27bc			endif 
27bc					NEXTW 
27bc c3 74 1e			jp macro_next 
27bf				endm 
# End of macro NEXTW
27bf			.LIST: 
27bf				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
27bf 5c				db WORD_SYS_CORE+72             
27c0 ad 29			dw .FORGET            
27c2 05				db 4 + 1 
27c3 .. 00			db "LIST",0              
27c8				endm 
# End of macro CWHEAD
27c8			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
27c8			; | | The quoted word must be in upper case. 
27c8				if DEBUG_FORTH_WORDS_KEY 
27c8					DMARK "LST" 
27c8 f5				push af  
27c9 3a dd 27			ld a, (.dmark)  
27cc 32 71 ee			ld (debug_mark),a  
27cf 3a de 27			ld a, (.dmark+1)  
27d2 32 72 ee			ld (debug_mark+1),a  
27d5 3a df 27			ld a, (.dmark+2)  
27d8 32 73 ee			ld (debug_mark+2),a  
27db 18 03			jr .pastdmark  
27dd ..			.dmark: db "LST"  
27e0 f1			.pastdmark: pop af  
27e1			endm  
# End of macro DMARK
27e1					CALLMONITOR 
27e1 cd a0 14			call break_point_state  
27e4				endm  
# End of macro CALLMONITOR
27e4				endif 
27e4			 
27e4					FORTH_DSP_VALUEHL 
27e4 cd 02 1d			call macro_dsp_valuehl 
27e7				endm 
# End of macro FORTH_DSP_VALUEHL
27e7			 
27e7 e5					push hl 
27e8					FORTH_DSP_POP 
27e8 cd ba 1d			call macro_forth_dsp_pop 
27eb				endm 
# End of macro FORTH_DSP_POP
27eb c1					pop bc 
27ec			 
27ec			; Start format of scratch string 
27ec			 
27ec 21 d7 e3				ld hl, scratch 
27ef			 
27ef 3e 3a				ld a, ':' 
27f1 77					ld (hl),a 
27f2 23					inc hl 
27f3 3e 20				ld a, ' ' 
27f5 77					ld (hl), a 
27f6			 
27f6					; Get ptr to the word we need to look up 
27f6			 
27f6			;		FORTH_DSP_VALUEHL 
27f6					;v5 FORTH_DSP_VALUE 
27f6				; TODO type check 
27f6			;		inc hl    ; Skip type check  
27f6			;		push hl 
27f6			;		ex de, hl    ; put into DE 
27f6			 
27f6			 
27f6 21 78 5a				ld hl, baseram 
27f9					;ld hl, baseusermem 
27f9			 
27f9 e5			push hl   ; sacreifical push 
27fa			 
27fa			.ldouscanm: 
27fa e1				pop hl 
27fb			.ldouscan: 
27fb				if DEBUG_FORTH_WORDS 
27fb					DMARK "LSs" 
27fb f5				push af  
27fc 3a 10 28			ld a, (.dmark)  
27ff 32 71 ee			ld (debug_mark),a  
2802 3a 11 28			ld a, (.dmark+1)  
2805 32 72 ee			ld (debug_mark+1),a  
2808 3a 12 28			ld a, (.dmark+2)  
280b 32 73 ee			ld (debug_mark+2),a  
280e 18 03			jr .pastdmark  
2810 ..			.dmark: db "LSs"  
2813 f1			.pastdmark: pop af  
2814			endm  
# End of macro DMARK
2814					CALLMONITOR 
2814 cd a0 14			call break_point_state  
2817				endm  
# End of macro CALLMONITOR
2817				endif 
2817				; skip dict stub 
2817 cd c5 1f				call forth_tok_next 
281a			 
281a			 
281a			; while we have words to look for 
281a			 
281a 7e				ld a, (hl)      
281b				if DEBUG_FORTH_WORDS 
281b					DMARK "LSk" 
281b f5				push af  
281c 3a 30 28			ld a, (.dmark)  
281f 32 71 ee			ld (debug_mark),a  
2822 3a 31 28			ld a, (.dmark+1)  
2825 32 72 ee			ld (debug_mark+1),a  
2828 3a 32 28			ld a, (.dmark+2)  
282b 32 73 ee			ld (debug_mark+2),a  
282e 18 03			jr .pastdmark  
2830 ..			.dmark: db "LSk"  
2833 f1			.pastdmark: pop af  
2834			endm  
# End of macro DMARK
2834					CALLMONITOR 
2834 cd a0 14			call break_point_state  
2837				endm  
# End of macro CALLMONITOR
2837				endif 
2837					;cp WORD_SYS_END 
2837					;jp z, .lunotfound 
2837			 
2837					; if we hit non uwords then gone too far 
2837 fe 01				cp WORD_SYS_UWORD 
2839 c2 69 29				jp nz, .lunotfound 
283c			 
283c				if DEBUG_FORTH_WORDS 
283c					DMARK "LSu" 
283c f5				push af  
283d 3a 51 28			ld a, (.dmark)  
2840 32 71 ee			ld (debug_mark),a  
2843 3a 52 28			ld a, (.dmark+1)  
2846 32 72 ee			ld (debug_mark+1),a  
2849 3a 53 28			ld a, (.dmark+2)  
284c 32 73 ee			ld (debug_mark+2),a  
284f 18 03			jr .pastdmark  
2851 ..			.dmark: db "LSu"  
2854 f1			.pastdmark: pop af  
2855			endm  
# End of macro DMARK
2855					CALLMONITOR 
2855 cd a0 14			call break_point_state  
2858				endm  
# End of macro CALLMONITOR
2858				endif 
2858			 
2858					; found a uword but is it the one we want... 
2858			 
2858 c5					push bc     ; uword to find is on bc 
2859 d1					pop de 
285a			 
285a e5					push hl  ; to save the ptr 
285b			 
285b					; skip opcode 
285b 23					inc hl  
285c					; skip next ptr 
285c 23					inc hl  
285d 23					inc hl 
285e					; skip len 
285e 23					inc hl 
285f			 
285f				if DEBUG_FORTH_WORDS 
285f					DMARK "LSc" 
285f f5				push af  
2860 3a 74 28			ld a, (.dmark)  
2863 32 71 ee			ld (debug_mark),a  
2866 3a 75 28			ld a, (.dmark+1)  
2869 32 72 ee			ld (debug_mark+1),a  
286c 3a 76 28			ld a, (.dmark+2)  
286f 32 73 ee			ld (debug_mark+2),a  
2872 18 03			jr .pastdmark  
2874 ..			.dmark: db "LSc"  
2877 f1			.pastdmark: pop af  
2878			endm  
# End of macro DMARK
2878					CALLMONITOR 
2878 cd a0 14			call break_point_state  
287b				endm  
# End of macro CALLMONITOR
287b				endif 
287b cd 35 11				call strcmp 
287e c2 fa 27				jp nz, .ldouscanm 
2881				 
2881			 
2881			 
2881					; we have a uword so push its name to the stack 
2881			 
2881			;	   	push hl  ; save so we can move to next dict block 
2881 e1			pop hl 
2882			 
2882				if DEBUG_FORTH_WORDS 
2882					DMARK "LSm" 
2882 f5				push af  
2883 3a 97 28			ld a, (.dmark)  
2886 32 71 ee			ld (debug_mark),a  
2889 3a 98 28			ld a, (.dmark+1)  
288c 32 72 ee			ld (debug_mark+1),a  
288f 3a 99 28			ld a, (.dmark+2)  
2892 32 73 ee			ld (debug_mark+2),a  
2895 18 03			jr .pastdmark  
2897 ..			.dmark: db "LSm"  
289a f1			.pastdmark: pop af  
289b			endm  
# End of macro DMARK
289b					CALLMONITOR 
289b cd a0 14			call break_point_state  
289e				endm  
# End of macro CALLMONITOR
289e				endif 
289e			 
289e					; skip opcode 
289e 23					inc hl  
289f					; skip next ptr 
289f 23					inc hl  
28a0 23					inc hl 
28a1					; skip len 
28a1 7e					ld a, (hl)   ; save length to add 
28a2				if DEBUG_FORTH_WORDS 
28a2					DMARK "LS2" 
28a2 f5				push af  
28a3 3a b7 28			ld a, (.dmark)  
28a6 32 71 ee			ld (debug_mark),a  
28a9 3a b8 28			ld a, (.dmark+1)  
28ac 32 72 ee			ld (debug_mark+1),a  
28af 3a b9 28			ld a, (.dmark+2)  
28b2 32 73 ee			ld (debug_mark+2),a  
28b5 18 03			jr .pastdmark  
28b7 ..			.dmark: db "LS2"  
28ba f1			.pastdmark: pop af  
28bb			endm  
# End of macro DMARK
28bb					CALLMONITOR 
28bb cd a0 14			call break_point_state  
28be				endm  
# End of macro CALLMONITOR
28be				endif 
28be			 
28be					; save this location 
28be				 
28be e5					push hl 
28bf			 
28bf 23					inc hl 
28c0 11 d9 e3				ld de, scratch+2 
28c3 4f					ld c, a 
28c4 06 00				ld b, 0 
28c6			 
28c6				if DEBUG_FORTH_WORDS 
28c6					DMARK "LSn" 
28c6 f5				push af  
28c7 3a db 28			ld a, (.dmark)  
28ca 32 71 ee			ld (debug_mark),a  
28cd 3a dc 28			ld a, (.dmark+1)  
28d0 32 72 ee			ld (debug_mark+1),a  
28d3 3a dd 28			ld a, (.dmark+2)  
28d6 32 73 ee			ld (debug_mark+2),a  
28d9 18 03			jr .pastdmark  
28db ..			.dmark: db "LSn"  
28de f1			.pastdmark: pop af  
28df			endm  
# End of macro DMARK
28df					CALLMONITOR 
28df cd a0 14			call break_point_state  
28e2				endm  
# End of macro CALLMONITOR
28e2				endif 
28e2			 
28e2					; copy uword name to scratch 
28e2			 
28e2 ed b0				ldir 
28e4			 
28e4 1b					dec de 
28e5 3e 20				ld a, ' '    ; change null to space 
28e7 12					ld (de), a 
28e8			 
28e8 13					inc de 
28e9			 
28e9 d5					push de 
28ea c1					pop bc     ; move scratch pointer to end of word name and save it 
28eb			 
28eb e1					pop hl 
28ec 7e					ld a, (hl) 
28ed					;inc hl 
28ed					; skip word string 
28ed cd 9f 0c				call addatohl 
28f0			 
28f0 23					inc hl 
28f1			 
28f1				if DEBUG_FORTH_WORDS 
28f1					DMARK "LS3" 
28f1 f5				push af  
28f2 3a 06 29			ld a, (.dmark)  
28f5 32 71 ee			ld (debug_mark),a  
28f8 3a 07 29			ld a, (.dmark+1)  
28fb 32 72 ee			ld (debug_mark+1),a  
28fe 3a 08 29			ld a, (.dmark+2)  
2901 32 73 ee			ld (debug_mark+2),a  
2904 18 03			jr .pastdmark  
2906 ..			.dmark: db "LS3"  
2909 f1			.pastdmark: pop af  
290a			endm  
# End of macro DMARK
290a					CALLMONITOR 
290a cd a0 14			call break_point_state  
290d				endm  
# End of macro CALLMONITOR
290d				endif 
290d					; should now be at the start of the machine code to setup the eval of the uword 
290d					; now locate the ptr to the string defintion 
290d			 
290d					; skip ld hl, 
290d					; then load the ptr 
290d			; TODO use get from hl ptr 
290d 23					inc hl 
290e 5e					ld e, (hl) 
290f 23					inc hl 
2910 56					ld d, (hl) 
2911 eb					ex de, hl 
2912			 
2912			 
2912				if DEBUG_FORTH_WORDS 
2912					DMARK "LSt" 
2912 f5				push af  
2913 3a 27 29			ld a, (.dmark)  
2916 32 71 ee			ld (debug_mark),a  
2919 3a 28 29			ld a, (.dmark+1)  
291c 32 72 ee			ld (debug_mark+1),a  
291f 3a 29 29			ld a, (.dmark+2)  
2922 32 73 ee			ld (debug_mark+2),a  
2925 18 03			jr .pastdmark  
2927 ..			.dmark: db "LSt"  
292a f1			.pastdmark: pop af  
292b			endm  
# End of macro DMARK
292b					CALLMONITOR 
292b cd a0 14			call break_point_state  
292e				endm  
# End of macro CALLMONITOR
292e				endif 
292e			 
292e			; cant push right now due to tokenised strings  
292e			 
292e			; get the destination of where to copy this definition to. 
292e			 
292e c5					push bc 
292f d1					pop de 
2930			 
2930 7e			.listl:         ld a,(hl) 
2931 fe 00				cp 0 
2933 28 09				jr z, .lreplsp     ; replace zero with space 
2935					;cp FORTH_END_BUFFER 
2935 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2937 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2939				 
2939					; just copy this char as is then 
2939			 
2939 12					ld (de), a 
293a			 
293a 23			.listnxt:	inc hl 
293b 13					inc de 
293c 18 f2				jr .listl 
293e			 
293e 3e 20		.lreplsp:	ld a,' ' 
2940 12					ld (de), a 
2941 18 f7				jr .listnxt 
2943			 
2943			; close up uword def 
2943			 
2943			.listdone: 
2943 12					ld (de), a 
2944 13					inc de 
2945 3e 00				ld a, 0 
2947 12					ld (de), a 
2948			 
2948			; now have def so clean up and push to stack 
2948			 
2948 21 d7 e3				ld hl, scratch 
294b				if DEBUG_FORTH_WORDS 
294b					DMARK "Ltp" 
294b f5				push af  
294c 3a 60 29			ld a, (.dmark)  
294f 32 71 ee			ld (debug_mark),a  
2952 3a 61 29			ld a, (.dmark+1)  
2955 32 72 ee			ld (debug_mark+1),a  
2958 3a 62 29			ld a, (.dmark+2)  
295b 32 73 ee			ld (debug_mark+2),a  
295e 18 03			jr .pastdmark  
2960 ..			.dmark: db "Ltp"  
2963 f1			.pastdmark: pop af  
2964			endm  
# End of macro DMARK
2964					CALLMONITOR 
2964 cd a0 14			call break_point_state  
2967				endm  
# End of macro CALLMONITOR
2967				endif 
2967			 
2967 18 1f			jr .listpush 
2969			 
2969			;.lnuword:	pop hl 
2969			;		call forth_tok_next 
2969			;		jp .ldouscan  
2969			 
2969			.lunotfound:		  
2969			 
2969				if DEBUG_FORTH_WORDS 
2969					DMARK "LSn" 
2969 f5				push af  
296a 3a 7e 29			ld a, (.dmark)  
296d 32 71 ee			ld (debug_mark),a  
2970 3a 7f 29			ld a, (.dmark+1)  
2973 32 72 ee			ld (debug_mark+1),a  
2976 3a 80 29			ld a, (.dmark+2)  
2979 32 73 ee			ld (debug_mark+2),a  
297c 18 03			jr .pastdmark  
297e ..			.dmark: db "LSn"  
2981 f1			.pastdmark: pop af  
2982			endm  
# End of macro DMARK
2982					CALLMONITOR 
2982 cd a0 14			call break_point_state  
2985				endm  
# End of macro CALLMONITOR
2985				endif 
2985			 
2985					 
2985			;		FORTH_DSP_POP 
2985			;		ld hl, .luno 
2985			 
2985					NEXTW			 
2985 c3 74 1e			jp macro_next 
2988				endm 
# End of macro NEXTW
2988			 
2988			.listpush: 
2988				if DEBUG_FORTH_WORDS 
2988					DMARK "LS>" 
2988 f5				push af  
2989 3a 9d 29			ld a, (.dmark)  
298c 32 71 ee			ld (debug_mark),a  
298f 3a 9e 29			ld a, (.dmark+1)  
2992 32 72 ee			ld (debug_mark+1),a  
2995 3a 9f 29			ld a, (.dmark+2)  
2998 32 73 ee			ld (debug_mark+2),a  
299b 18 03			jr .pastdmark  
299d ..			.dmark: db "LS>"  
29a0 f1			.pastdmark: pop af  
29a1			endm  
# End of macro DMARK
29a1					CALLMONITOR 
29a1 cd a0 14			call break_point_state  
29a4				endm  
# End of macro CALLMONITOR
29a4				endif 
29a4 cd 79 1b				call forth_push_str 
29a7			 
29a7			 
29a7			 
29a7					NEXTW 
29a7 c3 74 1e			jp macro_next 
29aa				endm 
# End of macro NEXTW
29aa			 
29aa			;.luno:    db "Word not found",0 
29aa			 
29aa			 
29aa			 
29aa			 
29aa			 
29aa			;		push hl   ; save pointer to start of uword def string 
29aa			; 
29aa			;; look for FORTH_EOL_LINE 
29aa			;		ld a, FORTH_END_BUFFER 
29aa			;		call strlent 
29aa			; 
29aa			;		inc hl		 ; space for coln def 
29aa			;		inc hl 
29aa			;		inc hl          ; space for terms 
29aa			;		inc hl 
29aa			; 
29aa			;		ld a, 20   ; TODO get actual length 
29aa			;		call addatohl    ; include a random amount of room for the uword name 
29aa			; 
29aa			;		 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "Lt1" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			;		 
29aa			; 
29aa			;; malloc space for the string because we cant change it 
29aa			; 
29aa			;		call malloc 
29aa			;	if DEBUG_FORTH_MALLOC_GUARD 
29aa			;		push af 
29aa			;		call ishlzero 
29aa			;		pop af 
29aa			;		 
29aa			;		call z,malloc_error 
29aa			;	endif 
29aa			; 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "Lt2" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			;		pop de 
29aa			;		push hl    ; push the malloc to release later 
29aa			;		push hl   ;  push back a copy for the later stack push 
29aa			;		 
29aa			;; copy the string swapping out the zero terms for spaces 
29aa			; 
29aa			;		; de has our source 
29aa			;		; hl has our dest 
29aa			; 
29aa			;; add the coln def 
29aa			; 
29aa			;		ld a, ':' 
29aa			;		ld (hl), a 
29aa			;		inc hl 
29aa			;		ld a, ' ' 
29aa			;		ld (hl), a 
29aa			;		inc hl 
29aa			; 
29aa			;; add the uname word 
29aa			;		push de   ; save our string for now 
29aa			;		ex de, hl 
29aa			; 
29aa			;		FORTH_DSP_VALUE 
29aa			;		;v5 FORTH_DSP_VALUE 
29aa			; 
29aa			;		inc hl   ; skip type but we know by now this is OK 
29aa			; 
29aa			;.luword:	ld a,(hl) 
29aa			;		cp 0 
29aa			;		jr z, .luword2 
29aa			;		ld (de), a 
29aa			;		inc de 
29aa			;		inc hl 
29aa			;		jr .luword 
29aa			; 
29aa			;.luword2:	ld a, ' ' 
29aa			;		ld (de), a 
29aa			;;		inc hl 
29aa			;;		inc de 
29aa			;;		ld (de), a 
29aa			;;		inc hl 
29aa			;		inc de 
29aa			; 
29aa			;		ex de, hl 
29aa			;		pop de 
29aa			;		 
29aa			;		 
29aa			; 
29aa			;; detoken that string and copy it 
29aa			; 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "Lt2" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			;.ldetok:	ld a, (de) 
29aa			;		cp FORTH_END_BUFFER 
29aa			;		jr z, .ldetokend 
29aa			;		; swap out any zero term for space 
29aa			;		cp 0 
29aa			;		jr nz, .ldetoknext 
29aa			;		ld a, ' ' 
29aa			; 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "LtS" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			;.ldetoknext:	ld (hl), a 
29aa			;		inc de 
29aa			;		inc hl 
29aa			;		jr .ldetok 
29aa			; 
29aa			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
29aa			;		ld (hl), a  
29aa			; 
29aa			;; free that temp malloc 
29aa			; 
29aa			;		pop hl    
29aa			; 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "Lt4" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			;		call forth_apushstrhl 
29aa			; 
29aa			;		; get rid of temp malloc area 
29aa			; 
29aa			;		pop hl 
29aa			;		call free 
29aa			; 
29aa			;		jr .ludone 
29aa			; 
29aa			;.lnuword:	pop hl 
29aa			;		call forth_tok_next 
29aa			;		jp .ldouscan  
29aa			; 
29aa			;.ludone:		 pop hl 
29aa			; 
29aa					NEXTW 
29aa c3 74 1e			jp macro_next 
29ad				endm 
# End of macro NEXTW
29ad			 
29ad			.FORGET: 
29ad				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
29ad 5d				db WORD_SYS_CORE+73             
29ae 26 2a			dw .NOP            
29b0 07				db 6 + 1 
29b1 .. 00			db "FORGET",0              
29b8				endm 
# End of macro CWHEAD
29b8			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
29b8			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
29b8			; | |  
29b8			; | | e.g. "MORE" forget 
29b8					if DEBUG_FORTH_WORDS_KEY 
29b8						DMARK "FRG" 
29b8 f5				push af  
29b9 3a cd 29			ld a, (.dmark)  
29bc 32 71 ee			ld (debug_mark),a  
29bf 3a ce 29			ld a, (.dmark+1)  
29c2 32 72 ee			ld (debug_mark+1),a  
29c5 3a cf 29			ld a, (.dmark+2)  
29c8 32 73 ee			ld (debug_mark+2),a  
29cb 18 03			jr .pastdmark  
29cd ..			.dmark: db "FRG"  
29d0 f1			.pastdmark: pop af  
29d1			endm  
# End of macro DMARK
29d1						CALLMONITOR 
29d1 cd a0 14			call break_point_state  
29d4				endm  
# End of macro CALLMONITOR
29d4					endif 
29d4			 
29d4				; find uword 
29d4			        ; update start of word with "_" 
29d4				; replace uword with deleted flag 
29d4			 
29d4			 
29d4			;	if DEBUG_FORTH_WORDS 
29d4			;		DMARK "FOG" 
29d4			;		CALLMONITOR 
29d4			;	endif 
29d4			 
29d4			 
29d4					; Get ptr to the word we need to look up 
29d4			 
29d4					FORTH_DSP_VALUEHL 
29d4 cd 02 1d			call macro_dsp_valuehl 
29d7				endm 
# End of macro FORTH_DSP_VALUEHL
29d7					;v5 FORTH_DSP_VALUE 
29d7				; TODO type check 
29d7			;		inc hl    ; Skip type check  
29d7 e5					push hl 
29d8 c1					pop bc 
29d9			;		ex de, hl    ; put into DE 
29d9			 
29d9			 
29d9 21 78 5a				ld hl, baseram 
29dc					;ld hl, baseusermem 
29dc			 
29dc				; skip dict stub 
29dc			;	call forth_tok_next 
29dc e5			push hl   ; sacreifical push 
29dd			 
29dd			.fldouscanm: 
29dd e1				pop hl 
29de			.fldouscan: 
29de			;	if DEBUG_FORTH_WORDS 
29de			;		DMARK "LSs" 
29de			;		CALLMONITOR 
29de			;	endif 
29de				; skip dict stub 
29de cd c5 1f				call forth_tok_next 
29e1			 
29e1			 
29e1			; while we have words to look for 
29e1			 
29e1 7e				ld a, (hl)      
29e2			;	if DEBUG_FORTH_WORDS 
29e2			;		DMARK "LSk" 
29e2			;		CALLMONITOR 
29e2			;	endif 
29e2 fe 00				cp WORD_SYS_END 
29e4 ca 20 2a				jp z, .flunotfound 
29e7 fe 01				cp WORD_SYS_UWORD 
29e9 c2 de 29				jp nz, .fldouscan 
29ec			 
29ec			;	if DEBUG_FORTH_WORDS 
29ec			;		DMARK "LSu" 
29ec			;		CALLMONITOR 
29ec			;	endif 
29ec			 
29ec					; found a uword but is it the one we want... 
29ec			 
29ec c5					push bc     ; uword to find is on bc 
29ed d1					pop de 
29ee			 
29ee e5					push hl  ; to save the ptr 
29ef			 
29ef					; skip opcode 
29ef 23					inc hl  
29f0					; skip next ptr 
29f0 23					inc hl  
29f1 23					inc hl 
29f2					; skip len 
29f2 23					inc hl 
29f3			 
29f3			;	if DEBUG_FORTH_WORDS 
29f3			;		DMARK "LSc" 
29f3			;		CALLMONITOR 
29f3			;	endif 
29f3 cd 35 11				call strcmp 
29f6 c2 dd 29				jp nz, .fldouscanm 
29f9			; 
29f9			; 
29f9			;; while we have words to look for 
29f9			; 
29f9			;.fdouscan:	ld a, (hl)      
29f9			;	if DEBUG_FORTH_WORDS 
29f9			;		DMARK "LSs" 
29f9			;		CALLMONITOR 
29f9			;	endif 
29f9			;		cp WORD_SYS_END 
29f9			;		jp z, .fudone 
29f9			;		cp WORD_SYS_UWORD 
29f9			;		jp nz, .fnuword 
29f9			; 
29f9			;	if DEBUG_FORTH_WORDS 
29f9			;		DMARK "FGu" 
29f9			;		CALLMONITOR 
29f9			;	endif 
29f9			; 
29f9			;		; found a uword but is it the one we want... 
29f9			; 
29f9			; 
29f9			;	        pop de   ; get back the dsp name 
29f9			;		push de 
29f9			; 
29f9			;		push hl  ; to save the ptr 
29f9			; 
29f9			;		; skip opcode 
29f9			;		inc hl  
29f9			;		; skip next ptr 
29f9			;		inc hl  
29f9			;		inc hl 
29f9			;		; skip len 
29f9			;		inc hl 
29f9			; 
29f9			;	if DEBUG_FORTH_WORDS 
29f9			;		DMARK "FGc" 
29f9			;		CALLMONITOR 
29f9			;	endif 
29f9			;		call strcmp 
29f9			;		jp nz, .fnuword 
29f9			 
29f9			 
29f9 e1			pop hl 
29fa			 
29fa				 
29fa				if DEBUG_FORTH_WORDS 
29fa					DMARK "FGm" 
29fa f5				push af  
29fb 3a 0f 2a			ld a, (.dmark)  
29fe 32 71 ee			ld (debug_mark),a  
2a01 3a 10 2a			ld a, (.dmark+1)  
2a04 32 72 ee			ld (debug_mark+1),a  
2a07 3a 11 2a			ld a, (.dmark+2)  
2a0a 32 73 ee			ld (debug_mark+2),a  
2a0d 18 03			jr .pastdmark  
2a0f ..			.dmark: db "FGm"  
2a12 f1			.pastdmark: pop af  
2a13			endm  
# End of macro DMARK
2a13					CALLMONITOR 
2a13 cd a0 14			call break_point_state  
2a16				endm  
# End of macro CALLMONITOR
2a16				endif 
2a16			 
2a16			 
2a16			 
2a16					; we have a uword so push its name to the stack 
2a16			 
2a16			;	   	push hl  ; save so we can move to next dict block 
2a16			;pop hl 
2a16			 
2a16					; update opcode to deleted 
2a16 3e 03				ld a, WORD_SYS_DELETED 
2a18 77					ld (hl), a 
2a19			 
2a19 23					inc hl  
2a1a					; skip next ptr 
2a1a 23					inc hl  
2a1b 23					inc hl 
2a1c					; skip len 
2a1c 23					inc hl 
2a1d			 
2a1d					; TODO change parser to skip deleted words but for now mark it out 
2a1d 3e 5f				ld a, "_" 
2a1f 77					ld  (hl),a 
2a20			 
2a20			;		jr .fudone 
2a20			; 
2a20			;.fnuword:	pop hl 
2a20			;		call forth_tok_next 
2a20			;		jp .fdouscan  
2a20			 
2a20			.flunotfound:		  
2a20			 
2a20			 
2a20					 
2a20					FORTH_DSP_POP 
2a20 cd ba 1d			call macro_forth_dsp_pop 
2a23				endm 
# End of macro FORTH_DSP_POP
2a23			;		ld hl, .luno 
2a23			;.fudone:		 pop hl 
2a23					NEXTW 
2a23 c3 74 1e			jp macro_next 
2a26				endm 
# End of macro NEXTW
2a26			.NOP: 
2a26				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2a26 61				db WORD_SYS_CORE+77             
2a27 4d 2a			dw .COMO            
2a29 04				db 3 + 1 
2a2a .. 00			db "NOP",0              
2a2e				endm 
# End of macro CWHEAD
2a2e			; | NOP (  --  ) Do nothing | DONE 
2a2e					if DEBUG_FORTH_WORDS_KEY 
2a2e						DMARK "NOP" 
2a2e f5				push af  
2a2f 3a 43 2a			ld a, (.dmark)  
2a32 32 71 ee			ld (debug_mark),a  
2a35 3a 44 2a			ld a, (.dmark+1)  
2a38 32 72 ee			ld (debug_mark+1),a  
2a3b 3a 45 2a			ld a, (.dmark+2)  
2a3e 32 73 ee			ld (debug_mark+2),a  
2a41 18 03			jr .pastdmark  
2a43 ..			.dmark: db "NOP"  
2a46 f1			.pastdmark: pop af  
2a47			endm  
# End of macro DMARK
2a47						CALLMONITOR 
2a47 cd a0 14			call break_point_state  
2a4a				endm  
# End of macro CALLMONITOR
2a4a					endif 
2a4a				       NEXTW 
2a4a c3 74 1e			jp macro_next 
2a4d				endm 
# End of macro NEXTW
2a4d			.COMO: 
2a4d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2a4d 6e				db WORD_SYS_CORE+90             
2a4e 9f 2a			dw .COMC            
2a50 02				db 1 + 1 
2a51 .. 00			db "(",0              
2a53				endm 
# End of macro CWHEAD
2a53			; | ( ( -- )  Start of comment | DONE 
2a53			 
2a53			 
2a53 2a d8 e6				ld hl, ( os_tok_ptr) 
2a56 11 9a 2a			ld de, .closepar 
2a59					 
2a59					if DEBUG_FORTH_WORDS 
2a59						DMARK ").." 
2a59 f5				push af  
2a5a 3a 6e 2a			ld a, (.dmark)  
2a5d 32 71 ee			ld (debug_mark),a  
2a60 3a 6f 2a			ld a, (.dmark+1)  
2a63 32 72 ee			ld (debug_mark+1),a  
2a66 3a 70 2a			ld a, (.dmark+2)  
2a69 32 73 ee			ld (debug_mark+2),a  
2a6c 18 03			jr .pastdmark  
2a6e ..			.dmark: db ").."  
2a71 f1			.pastdmark: pop af  
2a72			endm  
# End of macro DMARK
2a72						CALLMONITOR 
2a72 cd a0 14			call break_point_state  
2a75				endm  
# End of macro CALLMONITOR
2a75					endif 
2a75 cd 8f 1f			call findnexttok  
2a78			 
2a78					if DEBUG_FORTH_WORDS 
2a78						DMARK "IF5" 
2a78 f5				push af  
2a79 3a 8d 2a			ld a, (.dmark)  
2a7c 32 71 ee			ld (debug_mark),a  
2a7f 3a 8e 2a			ld a, (.dmark+1)  
2a82 32 72 ee			ld (debug_mark+1),a  
2a85 3a 8f 2a			ld a, (.dmark+2)  
2a88 32 73 ee			ld (debug_mark+2),a  
2a8b 18 03			jr .pastdmark  
2a8d ..			.dmark: db "IF5"  
2a90 f1			.pastdmark: pop af  
2a91			endm  
# End of macro DMARK
2a91						CALLMONITOR 
2a91 cd a0 14			call break_point_state  
2a94				endm  
# End of macro CALLMONITOR
2a94					endif 
2a94				; replace below with ) exec using tok_ptr 
2a94 22 d8 e6			ld (os_tok_ptr), hl 
2a97 c3 05 1f			jp exec1 
2a9a			 
2a9a .. 00			.closepar:   db ")",0 
2a9c			 
2a9c				       NEXTW 
2a9c c3 74 1e			jp macro_next 
2a9f				endm 
# End of macro NEXTW
2a9f			.COMC: 
2a9f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2a9f 6f				db WORD_SYS_CORE+91             
2aa0 a8 2a			dw .SCRATCH            
2aa2 02				db 1 + 1 
2aa3 .. 00			db ")",0              
2aa5				endm 
# End of macro CWHEAD
2aa5			; | ) ( -- )  End of comment |  DONE  
2aa5				       NEXTW 
2aa5 c3 74 1e			jp macro_next 
2aa8				endm 
# End of macro NEXTW
2aa8			 
2aa8			.SCRATCH: 
2aa8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2aa8 6f				db WORD_SYS_CORE+91             
2aa9 e3 2a			dw .INC            
2aab 08				db 7 + 1 
2aac .. 00			db "SCRATCH",0              
2ab4				endm 
# End of macro CWHEAD
2ab4			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ab4			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ab4			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ab4			; | |  
2ab4			; | | e.g.    : score $00 scratch ; 
2ab4			; | |  
2ab4			; | | $00 score ! 
2ab4			; | | $01 score +! 
2ab4			; | |  
2ab4			; | | e.g.   : varword $0a scratch ;  
2ab4			; | | 
2ab4			; | | $8000 varword ! 
2ab4					if DEBUG_FORTH_WORDS_KEY 
2ab4						DMARK "SCR" 
2ab4 f5				push af  
2ab5 3a c9 2a			ld a, (.dmark)  
2ab8 32 71 ee			ld (debug_mark),a  
2abb 3a ca 2a			ld a, (.dmark+1)  
2abe 32 72 ee			ld (debug_mark+1),a  
2ac1 3a cb 2a			ld a, (.dmark+2)  
2ac4 32 73 ee			ld (debug_mark+2),a  
2ac7 18 03			jr .pastdmark  
2ac9 ..			.dmark: db "SCR"  
2acc f1			.pastdmark: pop af  
2acd			endm  
# End of macro DMARK
2acd						CALLMONITOR 
2acd cd a0 14			call break_point_state  
2ad0				endm  
# End of macro CALLMONITOR
2ad0					endif 
2ad0			 
2ad0					FORTH_DSP_VALUEHL 
2ad0 cd 02 1d			call macro_dsp_valuehl 
2ad3				endm 
# End of macro FORTH_DSP_VALUEHL
2ad3				 
2ad3					FORTH_DSP_POP 
2ad3 cd ba 1d			call macro_forth_dsp_pop 
2ad6				endm 
# End of macro FORTH_DSP_POP
2ad6			 
2ad6 7d					ld a, l 
2ad7 21 fc e8				ld hl, os_var_array 
2ada cd 9f 0c				call addatohl 
2add			 
2add cd 0b 1b				call forth_push_numhl 
2ae0			 
2ae0				       NEXTW 
2ae0 c3 74 1e			jp macro_next 
2ae3				endm 
# End of macro NEXTW
2ae3			 
2ae3			.INC: 
2ae3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ae3 6f				db WORD_SYS_CORE+91             
2ae4 37 2b			dw .DEC            
2ae6 03				db 2 + 1 
2ae7 .. 00			db "+!",0              
2aea				endm 
# End of macro CWHEAD
2aea			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2aea					if DEBUG_FORTH_WORDS_KEY 
2aea						DMARK "+s_" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 71 ee			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 72 ee			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 73 ee			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "+s_"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03						CALLMONITOR 
2b03 cd a0 14			call break_point_state  
2b06				endm  
# End of macro CALLMONITOR
2b06					endif 
2b06			 
2b06					FORTH_DSP_VALUEHL 
2b06 cd 02 1d			call macro_dsp_valuehl 
2b09				endm 
# End of macro FORTH_DSP_VALUEHL
2b09			 
2b09 e5					push hl   ; save address 
2b0a			 
2b0a					FORTH_DSP_POP 
2b0a cd ba 1d			call macro_forth_dsp_pop 
2b0d				endm 
# End of macro FORTH_DSP_POP
2b0d			 
2b0d					FORTH_DSP_VALUEHL 
2b0d cd 02 1d			call macro_dsp_valuehl 
2b10				endm 
# End of macro FORTH_DSP_VALUEHL
2b10			 
2b10					FORTH_DSP_POP 
2b10 cd ba 1d			call macro_forth_dsp_pop 
2b13				endm 
# End of macro FORTH_DSP_POP
2b13			 
2b13					; hl contains value to add to byte at a 
2b13				 
2b13 eb					ex de, hl 
2b14			 
2b14 e1					pop hl 
2b15			 
2b15					if DEBUG_FORTH_WORDS 
2b15						DMARK "INC" 
2b15 f5				push af  
2b16 3a 2a 2b			ld a, (.dmark)  
2b19 32 71 ee			ld (debug_mark),a  
2b1c 3a 2b 2b			ld a, (.dmark+1)  
2b1f 32 72 ee			ld (debug_mark+1),a  
2b22 3a 2c 2b			ld a, (.dmark+2)  
2b25 32 73 ee			ld (debug_mark+2),a  
2b28 18 03			jr .pastdmark  
2b2a ..			.dmark: db "INC"  
2b2d f1			.pastdmark: pop af  
2b2e			endm  
# End of macro DMARK
2b2e						CALLMONITOR 
2b2e cd a0 14			call break_point_state  
2b31				endm  
# End of macro CALLMONITOR
2b31					endif 
2b31			 
2b31 7e					ld a,(hl) 
2b32 83					add e 
2b33 77					ld (hl),a 
2b34			 
2b34			 
2b34			 
2b34				       NEXTW 
2b34 c3 74 1e			jp macro_next 
2b37				endm 
# End of macro NEXTW
2b37			 
2b37			.DEC: 
2b37				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2b37 6f				db WORD_SYS_CORE+91             
2b38 88 2b			dw .INC2            
2b3a 03				db 2 + 1 
2b3b .. 00			db "-!",0              
2b3e				endm 
# End of macro CWHEAD
2b3e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2b3e					if DEBUG_FORTH_WORDS_KEY 
2b3e						DMARK "-s_" 
2b3e f5				push af  
2b3f 3a 53 2b			ld a, (.dmark)  
2b42 32 71 ee			ld (debug_mark),a  
2b45 3a 54 2b			ld a, (.dmark+1)  
2b48 32 72 ee			ld (debug_mark+1),a  
2b4b 3a 55 2b			ld a, (.dmark+2)  
2b4e 32 73 ee			ld (debug_mark+2),a  
2b51 18 03			jr .pastdmark  
2b53 ..			.dmark: db "-s_"  
2b56 f1			.pastdmark: pop af  
2b57			endm  
# End of macro DMARK
2b57						CALLMONITOR 
2b57 cd a0 14			call break_point_state  
2b5a				endm  
# End of macro CALLMONITOR
2b5a					endif 
2b5a			 
2b5a					FORTH_DSP_VALUEHL 
2b5a cd 02 1d			call macro_dsp_valuehl 
2b5d				endm 
# End of macro FORTH_DSP_VALUEHL
2b5d			 
2b5d e5					push hl   ; save address 
2b5e			 
2b5e					FORTH_DSP_POP 
2b5e cd ba 1d			call macro_forth_dsp_pop 
2b61				endm 
# End of macro FORTH_DSP_POP
2b61			 
2b61					FORTH_DSP_VALUEHL 
2b61 cd 02 1d			call macro_dsp_valuehl 
2b64				endm 
# End of macro FORTH_DSP_VALUEHL
2b64			 
2b64					; hl contains value to add to byte at a 
2b64				 
2b64 eb					ex de, hl 
2b65			 
2b65 e1					pop hl 
2b66			 
2b66					if DEBUG_FORTH_WORDS 
2b66						DMARK "DEC" 
2b66 f5				push af  
2b67 3a 7b 2b			ld a, (.dmark)  
2b6a 32 71 ee			ld (debug_mark),a  
2b6d 3a 7c 2b			ld a, (.dmark+1)  
2b70 32 72 ee			ld (debug_mark+1),a  
2b73 3a 7d 2b			ld a, (.dmark+2)  
2b76 32 73 ee			ld (debug_mark+2),a  
2b79 18 03			jr .pastdmark  
2b7b ..			.dmark: db "DEC"  
2b7e f1			.pastdmark: pop af  
2b7f			endm  
# End of macro DMARK
2b7f						CALLMONITOR 
2b7f cd a0 14			call break_point_state  
2b82				endm  
# End of macro CALLMONITOR
2b82					endif 
2b82			 
2b82 7e					ld a,(hl) 
2b83 93					sub e 
2b84 77					ld (hl),a 
2b85			 
2b85			 
2b85			 
2b85				       NEXTW 
2b85 c3 74 1e			jp macro_next 
2b88				endm 
# End of macro NEXTW
2b88			 
2b88			.INC2: 
2b88				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2b88 6f				db WORD_SYS_CORE+91             
2b89 32 2c			dw .DEC2            
2b8b 04				db 3 + 1 
2b8c .. 00			db "+2!",0              
2b90				endm 
# End of macro CWHEAD
2b90			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2b90			 
2b90					if DEBUG_FORTH_WORDS_KEY 
2b90						DMARK "+2s" 
2b90 f5				push af  
2b91 3a a5 2b			ld a, (.dmark)  
2b94 32 71 ee			ld (debug_mark),a  
2b97 3a a6 2b			ld a, (.dmark+1)  
2b9a 32 72 ee			ld (debug_mark+1),a  
2b9d 3a a7 2b			ld a, (.dmark+2)  
2ba0 32 73 ee			ld (debug_mark+2),a  
2ba3 18 03			jr .pastdmark  
2ba5 ..			.dmark: db "+2s"  
2ba8 f1			.pastdmark: pop af  
2ba9			endm  
# End of macro DMARK
2ba9						CALLMONITOR 
2ba9 cd a0 14			call break_point_state  
2bac				endm  
# End of macro CALLMONITOR
2bac					endif 
2bac			 
2bac					; Address 
2bac			 
2bac					FORTH_DSP_VALUEHL 
2bac cd 02 1d			call macro_dsp_valuehl 
2baf				endm 
# End of macro FORTH_DSP_VALUEHL
2baf			 
2baf e5					push hl    ; save address 
2bb0			 
2bb0					; load content into de 
2bb0			 
2bb0 5e					ld e,(hl) 
2bb1 23					inc hl 
2bb2 56					ld d, (hl) 
2bb3			 
2bb3					if DEBUG_FORTH_WORDS 
2bb3						DMARK "+2a" 
2bb3 f5				push af  
2bb4 3a c8 2b			ld a, (.dmark)  
2bb7 32 71 ee			ld (debug_mark),a  
2bba 3a c9 2b			ld a, (.dmark+1)  
2bbd 32 72 ee			ld (debug_mark+1),a  
2bc0 3a ca 2b			ld a, (.dmark+2)  
2bc3 32 73 ee			ld (debug_mark+2),a  
2bc6 18 03			jr .pastdmark  
2bc8 ..			.dmark: db "+2a"  
2bcb f1			.pastdmark: pop af  
2bcc			endm  
# End of macro DMARK
2bcc						CALLMONITOR 
2bcc cd a0 14			call break_point_state  
2bcf				endm  
# End of macro CALLMONITOR
2bcf					endif 
2bcf			 
2bcf					FORTH_DSP_POP 
2bcf cd ba 1d			call macro_forth_dsp_pop 
2bd2				endm 
# End of macro FORTH_DSP_POP
2bd2			 
2bd2					; Get value to add 
2bd2			 
2bd2					FORTH_DSP_VALUE 
2bd2 cd eb 1c			call macro_forth_dsp_value 
2bd5				endm 
# End of macro FORTH_DSP_VALUE
2bd5			 
2bd5					if DEBUG_FORTH_WORDS 
2bd5						DMARK "+2v" 
2bd5 f5				push af  
2bd6 3a ea 2b			ld a, (.dmark)  
2bd9 32 71 ee			ld (debug_mark),a  
2bdc 3a eb 2b			ld a, (.dmark+1)  
2bdf 32 72 ee			ld (debug_mark+1),a  
2be2 3a ec 2b			ld a, (.dmark+2)  
2be5 32 73 ee			ld (debug_mark+2),a  
2be8 18 03			jr .pastdmark  
2bea ..			.dmark: db "+2v"  
2bed f1			.pastdmark: pop af  
2bee			endm  
# End of macro DMARK
2bee						CALLMONITOR 
2bee cd a0 14			call break_point_state  
2bf1				endm  
# End of macro CALLMONITOR
2bf1					endif 
2bf1			 
2bf1 19					add hl, de 
2bf2			 
2bf2					if DEBUG_FORTH_WORDS 
2bf2						DMARK "+2+" 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 71 ee			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 72 ee			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 73 ee			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "+2+"  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b						CALLMONITOR 
2c0b cd a0 14			call break_point_state  
2c0e				endm  
# End of macro CALLMONITOR
2c0e					endif 
2c0e			 
2c0e					; move result to de 
2c0e			 
2c0e eb					ex de, hl 
2c0f			 
2c0f					; Address 
2c0f			 
2c0f e1					pop hl 
2c10			 
2c10					; save it back 
2c10			 
2c10 73					ld (hl), e 
2c11 23					inc hl 
2c12 72					ld (hl), d 
2c13			 
2c13					if DEBUG_FORTH_WORDS 
2c13						DMARK "+2e" 
2c13 f5				push af  
2c14 3a 28 2c			ld a, (.dmark)  
2c17 32 71 ee			ld (debug_mark),a  
2c1a 3a 29 2c			ld a, (.dmark+1)  
2c1d 32 72 ee			ld (debug_mark+1),a  
2c20 3a 2a 2c			ld a, (.dmark+2)  
2c23 32 73 ee			ld (debug_mark+2),a  
2c26 18 03			jr .pastdmark  
2c28 ..			.dmark: db "+2e"  
2c2b f1			.pastdmark: pop af  
2c2c			endm  
# End of macro DMARK
2c2c						CALLMONITOR 
2c2c cd a0 14			call break_point_state  
2c2f				endm  
# End of macro CALLMONITOR
2c2f					endif 
2c2f			 
2c2f			 
2c2f			 
2c2f			 
2c2f			 
2c2f				       NEXTW 
2c2f c3 74 1e			jp macro_next 
2c32				endm 
# End of macro NEXTW
2c32			 
2c32			.DEC2: 
2c32				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2c32 6f				db WORD_SYS_CORE+91             
2c33 de 2c			dw .GET2            
2c35 04				db 3 + 1 
2c36 .. 00			db "-2!",0              
2c3a				endm 
# End of macro CWHEAD
2c3a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2c3a			 
2c3a			 
2c3a					if DEBUG_FORTH_WORDS_KEY 
2c3a						DMARK "-2s" 
2c3a f5				push af  
2c3b 3a 4f 2c			ld a, (.dmark)  
2c3e 32 71 ee			ld (debug_mark),a  
2c41 3a 50 2c			ld a, (.dmark+1)  
2c44 32 72 ee			ld (debug_mark+1),a  
2c47 3a 51 2c			ld a, (.dmark+2)  
2c4a 32 73 ee			ld (debug_mark+2),a  
2c4d 18 03			jr .pastdmark  
2c4f ..			.dmark: db "-2s"  
2c52 f1			.pastdmark: pop af  
2c53			endm  
# End of macro DMARK
2c53						CALLMONITOR 
2c53 cd a0 14			call break_point_state  
2c56				endm  
# End of macro CALLMONITOR
2c56					endif 
2c56			 
2c56					; Address 
2c56			 
2c56					FORTH_DSP_VALUEHL 
2c56 cd 02 1d			call macro_dsp_valuehl 
2c59				endm 
# End of macro FORTH_DSP_VALUEHL
2c59			 
2c59 e5					push hl    ; save address 
2c5a			 
2c5a					; load content into de 
2c5a			 
2c5a 5e					ld e,(hl) 
2c5b 23					inc hl 
2c5c 56					ld d, (hl) 
2c5d			 
2c5d					if DEBUG_FORTH_WORDS 
2c5d						DMARK "-2a" 
2c5d f5				push af  
2c5e 3a 72 2c			ld a, (.dmark)  
2c61 32 71 ee			ld (debug_mark),a  
2c64 3a 73 2c			ld a, (.dmark+1)  
2c67 32 72 ee			ld (debug_mark+1),a  
2c6a 3a 74 2c			ld a, (.dmark+2)  
2c6d 32 73 ee			ld (debug_mark+2),a  
2c70 18 03			jr .pastdmark  
2c72 ..			.dmark: db "-2a"  
2c75 f1			.pastdmark: pop af  
2c76			endm  
# End of macro DMARK
2c76						CALLMONITOR 
2c76 cd a0 14			call break_point_state  
2c79				endm  
# End of macro CALLMONITOR
2c79					endif 
2c79			 
2c79					FORTH_DSP_POP 
2c79 cd ba 1d			call macro_forth_dsp_pop 
2c7c				endm 
# End of macro FORTH_DSP_POP
2c7c			 
2c7c					; Get value to remove 
2c7c			 
2c7c					FORTH_DSP_VALUE 
2c7c cd eb 1c			call macro_forth_dsp_value 
2c7f				endm 
# End of macro FORTH_DSP_VALUE
2c7f			 
2c7f					if DEBUG_FORTH_WORDS 
2c7f						DMARK "-2v" 
2c7f f5				push af  
2c80 3a 94 2c			ld a, (.dmark)  
2c83 32 71 ee			ld (debug_mark),a  
2c86 3a 95 2c			ld a, (.dmark+1)  
2c89 32 72 ee			ld (debug_mark+1),a  
2c8c 3a 96 2c			ld a, (.dmark+2)  
2c8f 32 73 ee			ld (debug_mark+2),a  
2c92 18 03			jr .pastdmark  
2c94 ..			.dmark: db "-2v"  
2c97 f1			.pastdmark: pop af  
2c98			endm  
# End of macro DMARK
2c98						CALLMONITOR 
2c98 cd a0 14			call break_point_state  
2c9b				endm  
# End of macro CALLMONITOR
2c9b					endif 
2c9b			 
2c9b eb					ex de, hl 
2c9c ed 52				sbc hl, de 
2c9e			 
2c9e					if DEBUG_FORTH_WORDS 
2c9e						DMARK "-2d" 
2c9e f5				push af  
2c9f 3a b3 2c			ld a, (.dmark)  
2ca2 32 71 ee			ld (debug_mark),a  
2ca5 3a b4 2c			ld a, (.dmark+1)  
2ca8 32 72 ee			ld (debug_mark+1),a  
2cab 3a b5 2c			ld a, (.dmark+2)  
2cae 32 73 ee			ld (debug_mark+2),a  
2cb1 18 03			jr .pastdmark  
2cb3 ..			.dmark: db "-2d"  
2cb6 f1			.pastdmark: pop af  
2cb7			endm  
# End of macro DMARK
2cb7						CALLMONITOR 
2cb7 cd a0 14			call break_point_state  
2cba				endm  
# End of macro CALLMONITOR
2cba					endif 
2cba			 
2cba					; move result to de 
2cba			 
2cba eb					ex de, hl 
2cbb			 
2cbb					; Address 
2cbb			 
2cbb e1					pop hl 
2cbc			 
2cbc					; save it back 
2cbc			 
2cbc 73					ld (hl), e 
2cbd 23					inc hl 
2cbe 72					ld (hl), d 
2cbf			 
2cbf					if DEBUG_FORTH_WORDS 
2cbf						DMARK "-2e" 
2cbf f5				push af  
2cc0 3a d4 2c			ld a, (.dmark)  
2cc3 32 71 ee			ld (debug_mark),a  
2cc6 3a d5 2c			ld a, (.dmark+1)  
2cc9 32 72 ee			ld (debug_mark+1),a  
2ccc 3a d6 2c			ld a, (.dmark+2)  
2ccf 32 73 ee			ld (debug_mark+2),a  
2cd2 18 03			jr .pastdmark  
2cd4 ..			.dmark: db "-2e"  
2cd7 f1			.pastdmark: pop af  
2cd8			endm  
# End of macro DMARK
2cd8						CALLMONITOR 
2cd8 cd a0 14			call break_point_state  
2cdb				endm  
# End of macro CALLMONITOR
2cdb					endif 
2cdb			 
2cdb			 
2cdb			 
2cdb			 
2cdb			 
2cdb				       NEXTW 
2cdb c3 74 1e			jp macro_next 
2cde				endm 
# End of macro NEXTW
2cde			.GET2: 
2cde				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2cde 6f				db WORD_SYS_CORE+91             
2cdf 0e 2d			dw .BANG2            
2ce1 03				db 2 + 1 
2ce2 .. 00			db "2@",0              
2ce5				endm 
# End of macro CWHEAD
2ce5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ce5					if DEBUG_FORTH_WORDS_KEY 
2ce5						DMARK "2A_" 
2ce5 f5				push af  
2ce6 3a fa 2c			ld a, (.dmark)  
2ce9 32 71 ee			ld (debug_mark),a  
2cec 3a fb 2c			ld a, (.dmark+1)  
2cef 32 72 ee			ld (debug_mark+1),a  
2cf2 3a fc 2c			ld a, (.dmark+2)  
2cf5 32 73 ee			ld (debug_mark+2),a  
2cf8 18 03			jr .pastdmark  
2cfa ..			.dmark: db "2A_"  
2cfd f1			.pastdmark: pop af  
2cfe			endm  
# End of macro DMARK
2cfe						CALLMONITOR 
2cfe cd a0 14			call break_point_state  
2d01				endm  
# End of macro CALLMONITOR
2d01					endif 
2d01			 
2d01					FORTH_DSP_VALUEHL 
2d01 cd 02 1d			call macro_dsp_valuehl 
2d04				endm 
# End of macro FORTH_DSP_VALUEHL
2d04			 
2d04 5e					ld e, (hl) 
2d05 23					inc hl 
2d06 56					ld d, (hl) 
2d07			 
2d07 eb					ex de, hl 
2d08			 
2d08 cd 0b 1b				call forth_push_numhl 
2d0b			 
2d0b				       NEXTW 
2d0b c3 74 1e			jp macro_next 
2d0e				endm 
# End of macro NEXTW
2d0e			.BANG2: 
2d0e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2d0e 6f				db WORD_SYS_CORE+91             
2d0f 46 2d			dw .CONFIG            
2d11 03				db 2 + 1 
2d12 .. 00			db "2!",0              
2d15				endm 
# End of macro CWHEAD
2d15			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2d15					if DEBUG_FORTH_WORDS_KEY 
2d15						DMARK "2S_" 
2d15 f5				push af  
2d16 3a 2a 2d			ld a, (.dmark)  
2d19 32 71 ee			ld (debug_mark),a  
2d1c 3a 2b 2d			ld a, (.dmark+1)  
2d1f 32 72 ee			ld (debug_mark+1),a  
2d22 3a 2c 2d			ld a, (.dmark+2)  
2d25 32 73 ee			ld (debug_mark+2),a  
2d28 18 03			jr .pastdmark  
2d2a ..			.dmark: db "2S_"  
2d2d f1			.pastdmark: pop af  
2d2e			endm  
# End of macro DMARK
2d2e						CALLMONITOR 
2d2e cd a0 14			call break_point_state  
2d31				endm  
# End of macro CALLMONITOR
2d31					endif 
2d31			 
2d31					FORTH_DSP_VALUEHL 
2d31 cd 02 1d			call macro_dsp_valuehl 
2d34				endm 
# End of macro FORTH_DSP_VALUEHL
2d34			 
2d34 e5					push hl   ; save address 
2d35			 
2d35			 
2d35					FORTH_DSP_POP 
2d35 cd ba 1d			call macro_forth_dsp_pop 
2d38				endm 
# End of macro FORTH_DSP_POP
2d38			 
2d38					 
2d38					FORTH_DSP_VALUEHL 
2d38 cd 02 1d			call macro_dsp_valuehl 
2d3b				endm 
# End of macro FORTH_DSP_VALUEHL
2d3b			 
2d3b					FORTH_DSP_POP 
2d3b cd ba 1d			call macro_forth_dsp_pop 
2d3e				endm 
# End of macro FORTH_DSP_POP
2d3e			 
2d3e eb					ex de, hl    ; value now in de 
2d3f			 
2d3f e1					pop hl 
2d40			 
2d40 73					ld (hl), e 
2d41			 
2d41 23					inc hl 
2d42			 
2d42 72					ld (hl), d 
2d43			 
2d43			 
2d43				       NEXTW 
2d43 c3 74 1e			jp macro_next 
2d46				endm 
# End of macro NEXTW
2d46			.CONFIG: 
2d46				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2d46 6f				db WORD_SYS_CORE+91             
2d47 57 2d			dw .ENDCORE            
2d49 07				db 6 + 1 
2d4a .. 00			db "CONFIG",0              
2d51				endm 
# End of macro CWHEAD
2d51			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2d51			 
2d51 cd ff 12				call config 
2d54					NEXTW 
2d54 c3 74 1e			jp macro_next 
2d57				endm 
# End of macro NEXTW
2d57			.ENDCORE: 
2d57			 
2d57			; eof 
2d57			 
2d57			 
# End of file forth_words_core.asm
2d57			include "forth_words_flow.asm" 
2d57			 
2d57			; | ## Program Flow Words 
2d57			 
2d57			.IF: 
2d57				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2d57 1e				db WORD_SYS_CORE+10             
2d58 4c 2e			dw .THEN            
2d5a 03				db 2 + 1 
2d5b .. 00			db "IF",0              
2d5e				endm 
# End of macro CWHEAD
2d5e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2d5e			; 
2d5e					if DEBUG_FORTH_WORDS_KEY 
2d5e						DMARK "IF." 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 71 ee			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 72 ee			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 73 ee			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "IF."  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77						CALLMONITOR 
2d77 cd a0 14			call break_point_state  
2d7a				endm  
# End of macro CALLMONITOR
2d7a					endif 
2d7a			; eval TOS 
2d7a			 
2d7a				FORTH_DSP_VALUEHL 
2d7a cd 02 1d			call macro_dsp_valuehl 
2d7d				endm 
# End of macro FORTH_DSP_VALUEHL
2d7d			 
2d7d			;	push hl 
2d7d				FORTH_DSP_POP 
2d7d cd ba 1d			call macro_forth_dsp_pop 
2d80				endm 
# End of macro FORTH_DSP_POP
2d80			;	pop hl 
2d80			 
2d80					if DEBUG_FORTH_WORDS 
2d80						DMARK "IF1" 
2d80 f5				push af  
2d81 3a 95 2d			ld a, (.dmark)  
2d84 32 71 ee			ld (debug_mark),a  
2d87 3a 96 2d			ld a, (.dmark+1)  
2d8a 32 72 ee			ld (debug_mark+1),a  
2d8d 3a 97 2d			ld a, (.dmark+2)  
2d90 32 73 ee			ld (debug_mark+2),a  
2d93 18 03			jr .pastdmark  
2d95 ..			.dmark: db "IF1"  
2d98 f1			.pastdmark: pop af  
2d99			endm  
# End of macro DMARK
2d99						CALLMONITOR 
2d99 cd a0 14			call break_point_state  
2d9c				endm  
# End of macro CALLMONITOR
2d9c					endif 
2d9c b7				or a        ; clear carry flag 
2d9d 11 00 00			ld de, 0 
2da0 eb				ex de,hl 
2da1 ed 52			sbc hl, de 
2da3 c2 2d 2e			jp nz, .iftrue 
2da6			 
2da6					if DEBUG_FORTH_WORDS 
2da6						DMARK "IF2" 
2da6 f5				push af  
2da7 3a bb 2d			ld a, (.dmark)  
2daa 32 71 ee			ld (debug_mark),a  
2dad 3a bc 2d			ld a, (.dmark+1)  
2db0 32 72 ee			ld (debug_mark+1),a  
2db3 3a bd 2d			ld a, (.dmark+2)  
2db6 32 73 ee			ld (debug_mark+2),a  
2db9 18 03			jr .pastdmark  
2dbb ..			.dmark: db "IF2"  
2dbe f1			.pastdmark: pop af  
2dbf			endm  
# End of macro DMARK
2dbf						CALLMONITOR 
2dbf cd a0 14			call break_point_state  
2dc2				endm  
# End of macro CALLMONITOR
2dc2					endif 
2dc2			 
2dc2			; if not true then skip to THEN 
2dc2			 
2dc2				; TODO get tok_ptr 
2dc2				; TODO consume toks until we get to THEN 
2dc2			 
2dc2 2a d8 e6			ld hl, (os_tok_ptr) 
2dc5					if DEBUG_FORTH_WORDS 
2dc5						DMARK "IF3" 
2dc5 f5				push af  
2dc6 3a da 2d			ld a, (.dmark)  
2dc9 32 71 ee			ld (debug_mark),a  
2dcc 3a db 2d			ld a, (.dmark+1)  
2dcf 32 72 ee			ld (debug_mark+1),a  
2dd2 3a dc 2d			ld a, (.dmark+2)  
2dd5 32 73 ee			ld (debug_mark+2),a  
2dd8 18 03			jr .pastdmark  
2dda ..			.dmark: db "IF3"  
2ddd f1			.pastdmark: pop af  
2dde			endm  
# End of macro DMARK
2dde						CALLMONITOR 
2dde cd a0 14			call break_point_state  
2de1				endm  
# End of macro CALLMONITOR
2de1						 
2de1					endif 
2de1 11 28 2e			ld de, .ifthen 
2de4					if DEBUG_FORTH_WORDS 
2de4						DMARK "IF4" 
2de4 f5				push af  
2de5 3a f9 2d			ld a, (.dmark)  
2de8 32 71 ee			ld (debug_mark),a  
2deb 3a fa 2d			ld a, (.dmark+1)  
2dee 32 72 ee			ld (debug_mark+1),a  
2df1 3a fb 2d			ld a, (.dmark+2)  
2df4 32 73 ee			ld (debug_mark+2),a  
2df7 18 03			jr .pastdmark  
2df9 ..			.dmark: db "IF4"  
2dfc f1			.pastdmark: pop af  
2dfd			endm  
# End of macro DMARK
2dfd						CALLMONITOR 
2dfd cd a0 14			call break_point_state  
2e00				endm  
# End of macro CALLMONITOR
2e00					endif 
2e00 cd 8f 1f			call findnexttok  
2e03			 
2e03					if DEBUG_FORTH_WORDS 
2e03						DMARK "IF5" 
2e03 f5				push af  
2e04 3a 18 2e			ld a, (.dmark)  
2e07 32 71 ee			ld (debug_mark),a  
2e0a 3a 19 2e			ld a, (.dmark+1)  
2e0d 32 72 ee			ld (debug_mark+1),a  
2e10 3a 1a 2e			ld a, (.dmark+2)  
2e13 32 73 ee			ld (debug_mark+2),a  
2e16 18 03			jr .pastdmark  
2e18 ..			.dmark: db "IF5"  
2e1b f1			.pastdmark: pop af  
2e1c			endm  
# End of macro DMARK
2e1c						CALLMONITOR 
2e1c cd a0 14			call break_point_state  
2e1f				endm  
# End of macro CALLMONITOR
2e1f					endif 
2e1f				; TODO replace below with ; exec using tok_ptr 
2e1f 22 d8 e6			ld (os_tok_ptr), hl 
2e22 c3 05 1f			jp exec1 
2e25				NEXTW 
2e25 c3 74 1e			jp macro_next 
2e28				endm 
# End of macro NEXTW
2e28			 
2e28 .. 00		.ifthen:  db "THEN",0 
2e2d			 
2e2d			.iftrue:		 
2e2d				; Exec next words normally 
2e2d			 
2e2d				; if true then exec following IF as normal 
2e2d					if DEBUG_FORTH_WORDS 
2e2d						DMARK "IFT" 
2e2d f5				push af  
2e2e 3a 42 2e			ld a, (.dmark)  
2e31 32 71 ee			ld (debug_mark),a  
2e34 3a 43 2e			ld a, (.dmark+1)  
2e37 32 72 ee			ld (debug_mark+1),a  
2e3a 3a 44 2e			ld a, (.dmark+2)  
2e3d 32 73 ee			ld (debug_mark+2),a  
2e40 18 03			jr .pastdmark  
2e42 ..			.dmark: db "IFT"  
2e45 f1			.pastdmark: pop af  
2e46			endm  
# End of macro DMARK
2e46						CALLMONITOR 
2e46 cd a0 14			call break_point_state  
2e49				endm  
# End of macro CALLMONITOR
2e49					endif 
2e49			 
2e49					NEXTW 
2e49 c3 74 1e			jp macro_next 
2e4c				endm 
# End of macro NEXTW
2e4c			.THEN: 
2e4c				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2e4c 1f				db WORD_SYS_CORE+11             
2e4d 74 2e			dw .ELSE            
2e4f 05				db 4 + 1 
2e50 .. 00			db "THEN",0              
2e55				endm 
# End of macro CWHEAD
2e55			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2e55					if DEBUG_FORTH_WORDS_KEY 
2e55						DMARK "THN" 
2e55 f5				push af  
2e56 3a 6a 2e			ld a, (.dmark)  
2e59 32 71 ee			ld (debug_mark),a  
2e5c 3a 6b 2e			ld a, (.dmark+1)  
2e5f 32 72 ee			ld (debug_mark+1),a  
2e62 3a 6c 2e			ld a, (.dmark+2)  
2e65 32 73 ee			ld (debug_mark+2),a  
2e68 18 03			jr .pastdmark  
2e6a ..			.dmark: db "THN"  
2e6d f1			.pastdmark: pop af  
2e6e			endm  
# End of macro DMARK
2e6e						CALLMONITOR 
2e6e cd a0 14			call break_point_state  
2e71				endm  
# End of macro CALLMONITOR
2e71					endif 
2e71					NEXTW 
2e71 c3 74 1e			jp macro_next 
2e74				endm 
# End of macro NEXTW
2e74			.ELSE: 
2e74				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2e74 20				db WORD_SYS_CORE+12             
2e75 9c 2e			dw .DO            
2e77 03				db 2 + 1 
2e78 .. 00			db "ELSE",0              
2e7d				endm 
# End of macro CWHEAD
2e7d			; | ELSE ( -- ) Not supported - does nothing | TODO 
2e7d			 
2e7d					if DEBUG_FORTH_WORDS_KEY 
2e7d						DMARK "ELS" 
2e7d f5				push af  
2e7e 3a 92 2e			ld a, (.dmark)  
2e81 32 71 ee			ld (debug_mark),a  
2e84 3a 93 2e			ld a, (.dmark+1)  
2e87 32 72 ee			ld (debug_mark+1),a  
2e8a 3a 94 2e			ld a, (.dmark+2)  
2e8d 32 73 ee			ld (debug_mark+2),a  
2e90 18 03			jr .pastdmark  
2e92 ..			.dmark: db "ELS"  
2e95 f1			.pastdmark: pop af  
2e96			endm  
# End of macro DMARK
2e96						CALLMONITOR 
2e96 cd a0 14			call break_point_state  
2e99				endm  
# End of macro CALLMONITOR
2e99					endif 
2e99			 
2e99			 
2e99					NEXTW 
2e99 c3 74 1e			jp macro_next 
2e9c				endm 
# End of macro NEXTW
2e9c			.DO: 
2e9c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2e9c 21				db WORD_SYS_CORE+13             
2e9d c3 2f			dw .LOOP            
2e9f 03				db 2 + 1 
2ea0 .. 00			db "DO",0              
2ea3				endm 
# End of macro CWHEAD
2ea3			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2ea3			 
2ea3					if DEBUG_FORTH_WORDS_KEY 
2ea3						DMARK "DO." 
2ea3 f5				push af  
2ea4 3a b8 2e			ld a, (.dmark)  
2ea7 32 71 ee			ld (debug_mark),a  
2eaa 3a b9 2e			ld a, (.dmark+1)  
2ead 32 72 ee			ld (debug_mark+1),a  
2eb0 3a ba 2e			ld a, (.dmark+2)  
2eb3 32 73 ee			ld (debug_mark+2),a  
2eb6 18 03			jr .pastdmark  
2eb8 ..			.dmark: db "DO."  
2ebb f1			.pastdmark: pop af  
2ebc			endm  
# End of macro DMARK
2ebc						CALLMONITOR 
2ebc cd a0 14			call break_point_state  
2ebf				endm  
# End of macro CALLMONITOR
2ebf					endif 
2ebf			;  push pc to rsp stack past the DO 
2ebf			 
2ebf 2a d8 e6				ld hl, (os_tok_ptr) 
2ec2 23					inc hl   ; D 
2ec3 23					inc hl  ; O 
2ec4 23					inc hl   ; null 
2ec5					if DEBUG_FORTH_WORDS 
2ec5						DMARK "DO2" 
2ec5 f5				push af  
2ec6 3a da 2e			ld a, (.dmark)  
2ec9 32 71 ee			ld (debug_mark),a  
2ecc 3a db 2e			ld a, (.dmark+1)  
2ecf 32 72 ee			ld (debug_mark+1),a  
2ed2 3a dc 2e			ld a, (.dmark+2)  
2ed5 32 73 ee			ld (debug_mark+2),a  
2ed8 18 03			jr .pastdmark  
2eda ..			.dmark: db "DO2"  
2edd f1			.pastdmark: pop af  
2ede			endm  
# End of macro DMARK
2ede						CALLMONITOR 
2ede cd a0 14			call break_point_state  
2ee1				endm  
# End of macro CALLMONITOR
2ee1					endif 
2ee1					FORTH_RSP_NEXT 
2ee1 cd b2 1a			call macro_forth_rsp_next 
2ee4				endm 
# End of macro FORTH_RSP_NEXT
2ee4					if DEBUG_FORTH_WORDS 
2ee4						DMARK "DO3" 
2ee4 f5				push af  
2ee5 3a f9 2e			ld a, (.dmark)  
2ee8 32 71 ee			ld (debug_mark),a  
2eeb 3a fa 2e			ld a, (.dmark+1)  
2eee 32 72 ee			ld (debug_mark+1),a  
2ef1 3a fb 2e			ld a, (.dmark+2)  
2ef4 32 73 ee			ld (debug_mark+2),a  
2ef7 18 03			jr .pastdmark  
2ef9 ..			.dmark: db "DO3"  
2efc f1			.pastdmark: pop af  
2efd			endm  
# End of macro DMARK
2efd						CALLMONITOR 
2efd cd a0 14			call break_point_state  
2f00				endm  
# End of macro CALLMONITOR
2f00					endif 
2f00			 
2f00					;if DEBUG_FORTH_WORDS 
2f00				;		push hl 
2f00			;		endif  
2f00			 
2f00			; get counters from data stack 
2f00			 
2f00			 
2f00					FORTH_DSP_VALUEHL 
2f00 cd 02 1d			call macro_dsp_valuehl 
2f03				endm 
# End of macro FORTH_DSP_VALUEHL
2f03 e5					push hl		 ; hl now has starting counter which needs to be tos 
2f04			 
2f04					if DEBUG_FORTH_WORDS 
2f04						DMARK "DO4" 
2f04 f5				push af  
2f05 3a 19 2f			ld a, (.dmark)  
2f08 32 71 ee			ld (debug_mark),a  
2f0b 3a 1a 2f			ld a, (.dmark+1)  
2f0e 32 72 ee			ld (debug_mark+1),a  
2f11 3a 1b 2f			ld a, (.dmark+2)  
2f14 32 73 ee			ld (debug_mark+2),a  
2f17 18 03			jr .pastdmark  
2f19 ..			.dmark: db "DO4"  
2f1c f1			.pastdmark: pop af  
2f1d			endm  
# End of macro DMARK
2f1d						CALLMONITOR 
2f1d cd a0 14			call break_point_state  
2f20				endm  
# End of macro CALLMONITOR
2f20					endif 
2f20					FORTH_DSP_POP 
2f20 cd ba 1d			call macro_forth_dsp_pop 
2f23				endm 
# End of macro FORTH_DSP_POP
2f23			 
2f23					if DEBUG_FORTH_WORDS 
2f23						DMARK "DO5" 
2f23 f5				push af  
2f24 3a 38 2f			ld a, (.dmark)  
2f27 32 71 ee			ld (debug_mark),a  
2f2a 3a 39 2f			ld a, (.dmark+1)  
2f2d 32 72 ee			ld (debug_mark+1),a  
2f30 3a 3a 2f			ld a, (.dmark+2)  
2f33 32 73 ee			ld (debug_mark+2),a  
2f36 18 03			jr .pastdmark  
2f38 ..			.dmark: db "DO5"  
2f3b f1			.pastdmark: pop af  
2f3c			endm  
# End of macro DMARK
2f3c						CALLMONITOR 
2f3c cd a0 14			call break_point_state  
2f3f				endm  
# End of macro CALLMONITOR
2f3f					endif 
2f3f			 
2f3f					FORTH_DSP_VALUEHL 
2f3f cd 02 1d			call macro_dsp_valuehl 
2f42				endm 
# End of macro FORTH_DSP_VALUEHL
2f42			;		push hl		 ; hl now has starting limit counter 
2f42			 
2f42					if DEBUG_FORTH_WORDS 
2f42						DMARK "DO6" 
2f42 f5				push af  
2f43 3a 57 2f			ld a, (.dmark)  
2f46 32 71 ee			ld (debug_mark),a  
2f49 3a 58 2f			ld a, (.dmark+1)  
2f4c 32 72 ee			ld (debug_mark+1),a  
2f4f 3a 59 2f			ld a, (.dmark+2)  
2f52 32 73 ee			ld (debug_mark+2),a  
2f55 18 03			jr .pastdmark  
2f57 ..			.dmark: db "DO6"  
2f5a f1			.pastdmark: pop af  
2f5b			endm  
# End of macro DMARK
2f5b						CALLMONITOR 
2f5b cd a0 14			call break_point_state  
2f5e				endm  
# End of macro CALLMONITOR
2f5e					endif 
2f5e					FORTH_DSP_POP 
2f5e cd ba 1d			call macro_forth_dsp_pop 
2f61				endm 
# End of macro FORTH_DSP_POP
2f61			 
2f61			; put counters on the loop stack 
2f61			 
2f61			;		pop hl			 ; limit counter 
2f61 d1					pop de			; start counter 
2f62			 
2f62					; push limit counter 
2f62			 
2f62					if DEBUG_FORTH_WORDS 
2f62						DMARK "DO7" 
2f62 f5				push af  
2f63 3a 77 2f			ld a, (.dmark)  
2f66 32 71 ee			ld (debug_mark),a  
2f69 3a 78 2f			ld a, (.dmark+1)  
2f6c 32 72 ee			ld (debug_mark+1),a  
2f6f 3a 79 2f			ld a, (.dmark+2)  
2f72 32 73 ee			ld (debug_mark+2),a  
2f75 18 03			jr .pastdmark  
2f77 ..			.dmark: db "DO7"  
2f7a f1			.pastdmark: pop af  
2f7b			endm  
# End of macro DMARK
2f7b						CALLMONITOR 
2f7b cd a0 14			call break_point_state  
2f7e				endm  
# End of macro CALLMONITOR
2f7e					endif 
2f7e					FORTH_LOOP_NEXT 
2f7e cd 33 1d			call macro_forth_loop_next 
2f81				endm 
# End of macro FORTH_LOOP_NEXT
2f81			 
2f81					; push start counter 
2f81			 
2f81 eb					ex de, hl 
2f82					if DEBUG_FORTH_WORDS 
2f82						DMARK "DO7" 
2f82 f5				push af  
2f83 3a 97 2f			ld a, (.dmark)  
2f86 32 71 ee			ld (debug_mark),a  
2f89 3a 98 2f			ld a, (.dmark+1)  
2f8c 32 72 ee			ld (debug_mark+1),a  
2f8f 3a 99 2f			ld a, (.dmark+2)  
2f92 32 73 ee			ld (debug_mark+2),a  
2f95 18 03			jr .pastdmark  
2f97 ..			.dmark: db "DO7"  
2f9a f1			.pastdmark: pop af  
2f9b			endm  
# End of macro DMARK
2f9b						CALLMONITOR 
2f9b cd a0 14			call break_point_state  
2f9e				endm  
# End of macro CALLMONITOR
2f9e					endif 
2f9e					FORTH_LOOP_NEXT 
2f9e cd 33 1d			call macro_forth_loop_next 
2fa1				endm 
# End of macro FORTH_LOOP_NEXT
2fa1			 
2fa1			 
2fa1					; init first round of I counter 
2fa1			 
2fa1 22 fc e6				ld (os_current_i), hl 
2fa4			 
2fa4					if DEBUG_FORTH_WORDS 
2fa4						DMARK "DO8" 
2fa4 f5				push af  
2fa5 3a b9 2f			ld a, (.dmark)  
2fa8 32 71 ee			ld (debug_mark),a  
2fab 3a ba 2f			ld a, (.dmark+1)  
2fae 32 72 ee			ld (debug_mark+1),a  
2fb1 3a bb 2f			ld a, (.dmark+2)  
2fb4 32 73 ee			ld (debug_mark+2),a  
2fb7 18 03			jr .pastdmark  
2fb9 ..			.dmark: db "DO8"  
2fbc f1			.pastdmark: pop af  
2fbd			endm  
# End of macro DMARK
2fbd						CALLMONITOR 
2fbd cd a0 14			call break_point_state  
2fc0				endm  
# End of macro CALLMONITOR
2fc0					endif 
2fc0			 
2fc0					NEXTW 
2fc0 c3 74 1e			jp macro_next 
2fc3				endm 
# End of macro NEXTW
2fc3			.LOOP: 
2fc3				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2fc3 22				db WORD_SYS_CORE+14             
2fc4 db 30			dw .I            
2fc6 05				db 4 + 1 
2fc7 .. 00			db "LOOP",0              
2fcc				endm 
# End of macro CWHEAD
2fcc			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2fcc			 
2fcc				; pop tos as current loop count to hl 
2fcc			 
2fcc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2fcc			 
2fcc				FORTH_LOOP_TOS 
2fcc cd 66 1d			call macro_forth_loop_tos 
2fcf				endm 
# End of macro FORTH_LOOP_TOS
2fcf e5				push hl 
2fd0			 
2fd0					if DEBUG_FORTH_WORDS_KEY 
2fd0						DMARK "LOP" 
2fd0 f5				push af  
2fd1 3a e5 2f			ld a, (.dmark)  
2fd4 32 71 ee			ld (debug_mark),a  
2fd7 3a e6 2f			ld a, (.dmark+1)  
2fda 32 72 ee			ld (debug_mark+1),a  
2fdd 3a e7 2f			ld a, (.dmark+2)  
2fe0 32 73 ee			ld (debug_mark+2),a  
2fe3 18 03			jr .pastdmark  
2fe5 ..			.dmark: db "LOP"  
2fe8 f1			.pastdmark: pop af  
2fe9			endm  
# End of macro DMARK
2fe9						CALLMONITOR 
2fe9 cd a0 14			call break_point_state  
2fec				endm  
# End of macro CALLMONITOR
2fec					endif 
2fec				; next item on the stack is the limit. get it 
2fec			 
2fec			 
2fec				FORTH_LOOP_POP 
2fec cd 70 1d			call macro_forth_loop_pop 
2fef				endm 
# End of macro FORTH_LOOP_POP
2fef			 
2fef				FORTH_LOOP_TOS 
2fef cd 66 1d			call macro_forth_loop_tos 
2ff2				endm 
# End of macro FORTH_LOOP_TOS
2ff2			 
2ff2 d1				pop de		 ; de = i, hl = limit 
2ff3			 
2ff3					if DEBUG_FORTH_WORDS 
2ff3						DMARK "LP1" 
2ff3 f5				push af  
2ff4 3a 08 30			ld a, (.dmark)  
2ff7 32 71 ee			ld (debug_mark),a  
2ffa 3a 09 30			ld a, (.dmark+1)  
2ffd 32 72 ee			ld (debug_mark+1),a  
3000 3a 0a 30			ld a, (.dmark+2)  
3003 32 73 ee			ld (debug_mark+2),a  
3006 18 03			jr .pastdmark  
3008 ..			.dmark: db "LP1"  
300b f1			.pastdmark: pop af  
300c			endm  
# End of macro DMARK
300c						CALLMONITOR 
300c cd a0 14			call break_point_state  
300f				endm  
# End of macro CALLMONITOR
300f					endif 
300f			 
300f				; go back to previous word 
300f			 
300f d5				push de    ; save I for inc later 
3010			 
3010			 
3010				; get limit 
3010				;  is I at limit? 
3010			 
3010			 
3010					if DEBUG_FORTH_WORDS 
3010						DMARK "LP1" 
3010 f5				push af  
3011 3a 25 30			ld a, (.dmark)  
3014 32 71 ee			ld (debug_mark),a  
3017 3a 26 30			ld a, (.dmark+1)  
301a 32 72 ee			ld (debug_mark+1),a  
301d 3a 27 30			ld a, (.dmark+2)  
3020 32 73 ee			ld (debug_mark+2),a  
3023 18 03			jr .pastdmark  
3025 ..			.dmark: db "LP1"  
3028 f1			.pastdmark: pop af  
3029			endm  
# End of macro DMARK
3029						CALLMONITOR 
3029 cd a0 14			call break_point_state  
302c				endm  
# End of macro CALLMONITOR
302c					endif 
302c			 
302c ed 52			sbc hl, de 
302e			 
302e			 
302e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
302e			 
302e 20 26				jr nz, .loopnotdone 
3030			 
3030 e1				pop hl   ; get rid of saved I 
3031				FORTH_LOOP_POP     ; get rid of limit 
3031 cd 70 1d			call macro_forth_loop_pop 
3034				endm 
# End of macro FORTH_LOOP_POP
3034			 
3034				FORTH_RSP_POP     ; get rid of DO ptr 
3034 cd d3 1a			call macro_forth_rsp_pop 
3037				endm 
# End of macro FORTH_RSP_POP
3037			 
3037			if DEBUG_FORTH_WORDS 
3037						DMARK "LP>" 
3037 f5				push af  
3038 3a 4c 30			ld a, (.dmark)  
303b 32 71 ee			ld (debug_mark),a  
303e 3a 4d 30			ld a, (.dmark+1)  
3041 32 72 ee			ld (debug_mark+1),a  
3044 3a 4e 30			ld a, (.dmark+2)  
3047 32 73 ee			ld (debug_mark+2),a  
304a 18 03			jr .pastdmark  
304c ..			.dmark: db "LP>"  
304f f1			.pastdmark: pop af  
3050			endm  
# End of macro DMARK
3050				CALLMONITOR 
3050 cd a0 14			call break_point_state  
3053				endm  
# End of macro CALLMONITOR
3053			endif 
3053			 
3053					NEXTW 
3053 c3 74 1e			jp macro_next 
3056				endm 
# End of macro NEXTW
3056				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3056			 
3056			.loopnotdone: 
3056			 
3056 e1				pop hl    ; get I 
3057 23				inc hl 
3058			 
3058			   	; save new I 
3058			 
3058			 
3058					; set I counter 
3058			 
3058 22 fc e6				ld (os_current_i), hl 
305b			 
305b					if DEBUG_FORTH_WORDS 
305b						DMARK "LPN" 
305b f5				push af  
305c 3a 70 30			ld a, (.dmark)  
305f 32 71 ee			ld (debug_mark),a  
3062 3a 71 30			ld a, (.dmark+1)  
3065 32 72 ee			ld (debug_mark+1),a  
3068 3a 72 30			ld a, (.dmark+2)  
306b 32 73 ee			ld (debug_mark+2),a  
306e 18 03			jr .pastdmark  
3070 ..			.dmark: db "LPN"  
3073 f1			.pastdmark: pop af  
3074			endm  
# End of macro DMARK
3074					CALLMONITOR 
3074 cd a0 14			call break_point_state  
3077				endm  
# End of macro CALLMONITOR
3077					endif 
3077					 
3077				FORTH_LOOP_NEXT 
3077 cd 33 1d			call macro_forth_loop_next 
307a				endm 
# End of macro FORTH_LOOP_NEXT
307a			 
307a			 
307a					if DEBUG_FORTH_WORDS 
307a eb						ex de,hl 
307b					endif 
307b			 
307b			;	; get DO ptr 
307b			; 
307b					if DEBUG_FORTH_WORDS 
307b						DMARK "LP7" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 71 ee			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 72 ee			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 73 ee			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "LP7"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094					CALLMONITOR 
3094 cd a0 14			call break_point_state  
3097				endm  
# End of macro CALLMONITOR
3097					endif 
3097				FORTH_RSP_TOS 
3097 cd c9 1a			call macro_forth_rsp_tos 
309a				endm 
# End of macro FORTH_RSP_TOS
309a			 
309a					if DEBUG_FORTH_WORDS 
309a						DMARK "LP8" 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 71 ee			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 72 ee			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 73 ee			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db "LP8"  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3					CALLMONITOR 
30b3 cd a0 14			call break_point_state  
30b6				endm  
# End of macro CALLMONITOR
30b6					endif 
30b6				;push hl 
30b6			 
30b6				; not going to DO any more 
30b6				; get rid of the RSP pointer as DO will add it back in 
30b6				;FORTH_RSP_POP 
30b6				;pop hl 
30b6			 
30b6				;ld hl,(cli_ret_sp) 
30b6				;ld e, (hl) 
30b6				;inc hl 
30b6				;ld d, (hl) 
30b6				;ex de,hl 
30b6 22 d8 e6			ld (os_tok_ptr), hl 
30b9					if DEBUG_FORTH_WORDS 
30b9						DMARK "LP<" 
30b9 f5				push af  
30ba 3a ce 30			ld a, (.dmark)  
30bd 32 71 ee			ld (debug_mark),a  
30c0 3a cf 30			ld a, (.dmark+1)  
30c3 32 72 ee			ld (debug_mark+1),a  
30c6 3a d0 30			ld a, (.dmark+2)  
30c9 32 73 ee			ld (debug_mark+2),a  
30cc 18 03			jr .pastdmark  
30ce ..			.dmark: db "LP<"  
30d1 f1			.pastdmark: pop af  
30d2			endm  
# End of macro DMARK
30d2					CALLMONITOR 
30d2 cd a0 14			call break_point_state  
30d5				endm  
# End of macro CALLMONITOR
30d5				endif 
30d5 c3 05 1f			jp exec1 
30d8			 
30d8					 
30d8			 
30d8			 
30d8					NEXTW 
30d8 c3 74 1e			jp macro_next 
30db				endm 
# End of macro NEXTW
30db			.I:  
30db			 
30db				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
30db 5e				db WORD_SYS_CORE+74             
30dc 06 31			dw .DLOOP            
30de 02				db 1 + 1 
30df .. 00			db "I",0              
30e1				endm 
# End of macro CWHEAD
30e1			; | I ( -- ) Current loop counter | DONE 
30e1					if DEBUG_FORTH_WORDS_KEY 
30e1						DMARK "I.." 
30e1 f5				push af  
30e2 3a f6 30			ld a, (.dmark)  
30e5 32 71 ee			ld (debug_mark),a  
30e8 3a f7 30			ld a, (.dmark+1)  
30eb 32 72 ee			ld (debug_mark+1),a  
30ee 3a f8 30			ld a, (.dmark+2)  
30f1 32 73 ee			ld (debug_mark+2),a  
30f4 18 03			jr .pastdmark  
30f6 ..			.dmark: db "I.."  
30f9 f1			.pastdmark: pop af  
30fa			endm  
# End of macro DMARK
30fa						CALLMONITOR 
30fa cd a0 14			call break_point_state  
30fd				endm  
# End of macro CALLMONITOR
30fd					endif 
30fd			 
30fd 2a fc e6				ld hl,(os_current_i) 
3100 cd 0b 1b				call forth_push_numhl 
3103			 
3103					NEXTW 
3103 c3 74 1e			jp macro_next 
3106				endm 
# End of macro NEXTW
3106			.DLOOP: 
3106				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3106 5f				db WORD_SYS_CORE+75             
3107 e7 31			dw .REPEAT            
3109 06				db 5 + 1 
310a .. 00			db "-LOOP",0              
3110				endm 
# End of macro CWHEAD
3110			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3110				; pop tos as current loop count to hl 
3110					if DEBUG_FORTH_WORDS_KEY 
3110						DMARK "-LP" 
3110 f5				push af  
3111 3a 25 31			ld a, (.dmark)  
3114 32 71 ee			ld (debug_mark),a  
3117 3a 26 31			ld a, (.dmark+1)  
311a 32 72 ee			ld (debug_mark+1),a  
311d 3a 27 31			ld a, (.dmark+2)  
3120 32 73 ee			ld (debug_mark+2),a  
3123 18 03			jr .pastdmark  
3125 ..			.dmark: db "-LP"  
3128 f1			.pastdmark: pop af  
3129			endm  
# End of macro DMARK
3129						CALLMONITOR 
3129 cd a0 14			call break_point_state  
312c				endm  
# End of macro CALLMONITOR
312c					endif 
312c			 
312c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
312c			 
312c				FORTH_LOOP_TOS 
312c cd 66 1d			call macro_forth_loop_tos 
312f				endm 
# End of macro FORTH_LOOP_TOS
312f e5				push hl 
3130			 
3130					if DEBUG_FORTH_WORDS 
3130						DMARK "-LP" 
3130 f5				push af  
3131 3a 45 31			ld a, (.dmark)  
3134 32 71 ee			ld (debug_mark),a  
3137 3a 46 31			ld a, (.dmark+1)  
313a 32 72 ee			ld (debug_mark+1),a  
313d 3a 47 31			ld a, (.dmark+2)  
3140 32 73 ee			ld (debug_mark+2),a  
3143 18 03			jr .pastdmark  
3145 ..			.dmark: db "-LP"  
3148 f1			.pastdmark: pop af  
3149			endm  
# End of macro DMARK
3149						CALLMONITOR 
3149 cd a0 14			call break_point_state  
314c				endm  
# End of macro CALLMONITOR
314c					endif 
314c				; next item on the stack is the limit. get it 
314c			 
314c			 
314c				FORTH_LOOP_POP 
314c cd 70 1d			call macro_forth_loop_pop 
314f				endm 
# End of macro FORTH_LOOP_POP
314f			 
314f				FORTH_LOOP_TOS 
314f cd 66 1d			call macro_forth_loop_tos 
3152				endm 
# End of macro FORTH_LOOP_TOS
3152			 
3152 d1				pop de		 ; de = i, hl = limit 
3153			 
3153					if DEBUG_FORTH_WORDS 
3153						DMARK "-L1" 
3153 f5				push af  
3154 3a 68 31			ld a, (.dmark)  
3157 32 71 ee			ld (debug_mark),a  
315a 3a 69 31			ld a, (.dmark+1)  
315d 32 72 ee			ld (debug_mark+1),a  
3160 3a 6a 31			ld a, (.dmark+2)  
3163 32 73 ee			ld (debug_mark+2),a  
3166 18 03			jr .pastdmark  
3168 ..			.dmark: db "-L1"  
316b f1			.pastdmark: pop af  
316c			endm  
# End of macro DMARK
316c						CALLMONITOR 
316c cd a0 14			call break_point_state  
316f				endm  
# End of macro CALLMONITOR
316f					endif 
316f			 
316f				; go back to previous word 
316f			 
316f d5				push de    ; save I for inc later 
3170			 
3170			 
3170				; get limit 
3170				;  is I at limit? 
3170			 
3170			 
3170					if DEBUG_FORTH_WORDS 
3170						DMARK "-L1" 
3170 f5				push af  
3171 3a 85 31			ld a, (.dmark)  
3174 32 71 ee			ld (debug_mark),a  
3177 3a 86 31			ld a, (.dmark+1)  
317a 32 72 ee			ld (debug_mark+1),a  
317d 3a 87 31			ld a, (.dmark+2)  
3180 32 73 ee			ld (debug_mark+2),a  
3183 18 03			jr .pastdmark  
3185 ..			.dmark: db "-L1"  
3188 f1			.pastdmark: pop af  
3189			endm  
# End of macro DMARK
3189						CALLMONITOR 
3189 cd a0 14			call break_point_state  
318c				endm  
# End of macro CALLMONITOR
318c					endif 
318c			 
318c ed 52			sbc hl, de 
318e			 
318e			 
318e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
318e			 
318e 20 26				jr nz, .mloopnotdone 
3190			 
3190 e1				pop hl   ; get rid of saved I 
3191				FORTH_LOOP_POP     ; get rid of limit 
3191 cd 70 1d			call macro_forth_loop_pop 
3194				endm 
# End of macro FORTH_LOOP_POP
3194			 
3194				FORTH_RSP_POP     ; get rid of DO ptr 
3194 cd d3 1a			call macro_forth_rsp_pop 
3197				endm 
# End of macro FORTH_RSP_POP
3197			 
3197			if DEBUG_FORTH_WORDS 
3197						DMARK "-L>" 
3197 f5				push af  
3198 3a ac 31			ld a, (.dmark)  
319b 32 71 ee			ld (debug_mark),a  
319e 3a ad 31			ld a, (.dmark+1)  
31a1 32 72 ee			ld (debug_mark+1),a  
31a4 3a ae 31			ld a, (.dmark+2)  
31a7 32 73 ee			ld (debug_mark+2),a  
31aa 18 03			jr .pastdmark  
31ac ..			.dmark: db "-L>"  
31af f1			.pastdmark: pop af  
31b0			endm  
# End of macro DMARK
31b0				CALLMONITOR 
31b0 cd a0 14			call break_point_state  
31b3				endm  
# End of macro CALLMONITOR
31b3			endif 
31b3			 
31b3					NEXTW 
31b3 c3 74 1e			jp macro_next 
31b6				endm 
# End of macro NEXTW
31b6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31b6			 
31b6			.mloopnotdone: 
31b6			 
31b6 e1				pop hl    ; get I 
31b7 2b				dec hl 
31b8			 
31b8			   	; save new I 
31b8			 
31b8			 
31b8					; set I counter 
31b8			 
31b8 22 fc e6				ld (os_current_i), hl 
31bb			 
31bb					 
31bb				FORTH_LOOP_NEXT 
31bb cd 33 1d			call macro_forth_loop_next 
31be				endm 
# End of macro FORTH_LOOP_NEXT
31be			 
31be			 
31be					if DEBUG_FORTH_WORDS 
31be eb						ex de,hl 
31bf					endif 
31bf			 
31bf			;	; get DO ptr 
31bf			; 
31bf				FORTH_RSP_TOS 
31bf cd c9 1a			call macro_forth_rsp_tos 
31c2				endm 
# End of macro FORTH_RSP_TOS
31c2			 
31c2				;push hl 
31c2			 
31c2				; not going to DO any more 
31c2				; get rid of the RSP pointer as DO will add it back in 
31c2				;FORTH_RSP_POP 
31c2				;pop hl 
31c2			 
31c2			 
31c2 22 d8 e6			ld (os_tok_ptr), hl 
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "-L<" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 71 ee			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 72 ee			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 73 ee			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "-L<"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de					CALLMONITOR 
31de cd a0 14			call break_point_state  
31e1				endm  
# End of macro CALLMONITOR
31e1				endif 
31e1 c3 05 1f			jp exec1 
31e4			 
31e4					 
31e4			 
31e4			 
31e4			 
31e4				NEXTW 
31e4 c3 74 1e			jp macro_next 
31e7				endm 
# End of macro NEXTW
31e7			 
31e7			 
31e7			 
31e7			 
31e7			.REPEAT: 
31e7				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
31e7 71				db WORD_SYS_CORE+93             
31e8 3a 32			dw .UNTIL            
31ea 06				db 5 + 1 
31eb .. 00			db "REPEAT",0              
31f2				endm 
# End of macro CWHEAD
31f2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
31f2			;  push pc to rsp stack past the REPEAT 
31f2					if DEBUG_FORTH_WORDS_KEY 
31f2						DMARK "REP" 
31f2 f5				push af  
31f3 3a 07 32			ld a, (.dmark)  
31f6 32 71 ee			ld (debug_mark),a  
31f9 3a 08 32			ld a, (.dmark+1)  
31fc 32 72 ee			ld (debug_mark+1),a  
31ff 3a 09 32			ld a, (.dmark+2)  
3202 32 73 ee			ld (debug_mark+2),a  
3205 18 03			jr .pastdmark  
3207 ..			.dmark: db "REP"  
320a f1			.pastdmark: pop af  
320b			endm  
# End of macro DMARK
320b						CALLMONITOR 
320b cd a0 14			call break_point_state  
320e				endm  
# End of macro CALLMONITOR
320e					endif 
320e			 
320e 2a d8 e6				ld hl, (os_tok_ptr) 
3211 23					inc hl   ; R 
3212 23					inc hl  ; E 
3213 23					inc hl   ; P 
3214 23					inc hl   ; E 
3215 23					inc hl   ; A 
3216 23					inc hl   ; T 
3217 23					inc hl   ; zero 
3218					FORTH_RSP_NEXT 
3218 cd b2 1a			call macro_forth_rsp_next 
321b				endm 
# End of macro FORTH_RSP_NEXT
321b			 
321b			 
321b					if DEBUG_FORTH_WORDS 
321b						DMARK "REP" 
321b f5				push af  
321c 3a 30 32			ld a, (.dmark)  
321f 32 71 ee			ld (debug_mark),a  
3222 3a 31 32			ld a, (.dmark+1)  
3225 32 72 ee			ld (debug_mark+1),a  
3228 3a 32 32			ld a, (.dmark+2)  
322b 32 73 ee			ld (debug_mark+2),a  
322e 18 03			jr .pastdmark  
3230 ..			.dmark: db "REP"  
3233 f1			.pastdmark: pop af  
3234			endm  
# End of macro DMARK
3234						;pop bc    ; TODO BUG ?????? what is this for???? 
3234						CALLMONITOR 
3234 cd a0 14			call break_point_state  
3237				endm  
# End of macro CALLMONITOR
3237					endif 
3237			 
3237					NEXTW 
3237 c3 74 1e			jp macro_next 
323a				endm 
# End of macro NEXTW
323a			;	       NEXTW 
323a			 
323a			.UNTIL: 
323a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
323a 72				db WORD_SYS_CORE+94             
323b d1 32			dw .ENDFLOW            
323d 06				db 5 + 1 
323e .. 00			db "UNTIL",0              
3244				endm 
# End of macro CWHEAD
3244			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3244			 
3244				; pop tos as check 
3244			 
3244				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3244			 
3244				FORTH_DSP_VALUEHL 
3244 cd 02 1d			call macro_dsp_valuehl 
3247				endm 
# End of macro FORTH_DSP_VALUEHL
3247			 
3247					if DEBUG_FORTH_WORDS_KEY 
3247						DMARK "UNT" 
3247 f5				push af  
3248 3a 5c 32			ld a, (.dmark)  
324b 32 71 ee			ld (debug_mark),a  
324e 3a 5d 32			ld a, (.dmark+1)  
3251 32 72 ee			ld (debug_mark+1),a  
3254 3a 5e 32			ld a, (.dmark+2)  
3257 32 73 ee			ld (debug_mark+2),a  
325a 18 03			jr .pastdmark  
325c ..			.dmark: db "UNT"  
325f f1			.pastdmark: pop af  
3260			endm  
# End of macro DMARK
3260						CALLMONITOR 
3260 cd a0 14			call break_point_state  
3263				endm  
# End of macro CALLMONITOR
3263					endif 
3263			 
3263			;	push hl 
3263				FORTH_DSP_POP 
3263 cd ba 1d			call macro_forth_dsp_pop 
3266				endm 
# End of macro FORTH_DSP_POP
3266			 
3266			;	pop hl 
3266			 
3266				; test if true 
3266			 
3266 cd c8 0c			call ishlzero 
3269			;	ld a,l 
3269			;	add h 
3269			; 
3269			;	cp 0 
3269			 
3269 20 3e			jr nz, .untilnotdone 
326b			 
326b					if DEBUG_FORTH_WORDS 
326b						DMARK "UNf" 
326b f5				push af  
326c 3a 80 32			ld a, (.dmark)  
326f 32 71 ee			ld (debug_mark),a  
3272 3a 81 32			ld a, (.dmark+1)  
3275 32 72 ee			ld (debug_mark+1),a  
3278 3a 82 32			ld a, (.dmark+2)  
327b 32 73 ee			ld (debug_mark+2),a  
327e 18 03			jr .pastdmark  
3280 ..			.dmark: db "UNf"  
3283 f1			.pastdmark: pop af  
3284			endm  
# End of macro DMARK
3284						CALLMONITOR 
3284 cd a0 14			call break_point_state  
3287				endm  
# End of macro CALLMONITOR
3287					endif 
3287			 
3287			 
3287			 
3287				FORTH_RSP_POP     ; get rid of DO ptr 
3287 cd d3 1a			call macro_forth_rsp_pop 
328a				endm 
# End of macro FORTH_RSP_POP
328a			 
328a			if DEBUG_FORTH_WORDS 
328a						DMARK "UN>" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 71 ee			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 72 ee			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 73 ee			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "UN>"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3				CALLMONITOR 
32a3 cd a0 14			call break_point_state  
32a6				endm  
# End of macro CALLMONITOR
32a6			endif 
32a6			 
32a6					NEXTW 
32a6 c3 74 1e			jp macro_next 
32a9				endm 
# End of macro NEXTW
32a9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32a9			 
32a9			.untilnotdone: 
32a9			 
32a9			 
32a9			;	; get DO ptr 
32a9			; 
32a9				FORTH_RSP_TOS 
32a9 cd c9 1a			call macro_forth_rsp_tos 
32ac				endm 
# End of macro FORTH_RSP_TOS
32ac			 
32ac				;push hl 
32ac			 
32ac				; not going to DO any more 
32ac				; get rid of the RSP pointer as DO will add it back in 
32ac				;FORTH_RSP_POP 
32ac				;pop hl 
32ac			 
32ac			 
32ac 22 d8 e6			ld (os_tok_ptr), hl 
32af					if DEBUG_FORTH_WORDS 
32af						DMARK "UN<" 
32af f5				push af  
32b0 3a c4 32			ld a, (.dmark)  
32b3 32 71 ee			ld (debug_mark),a  
32b6 3a c5 32			ld a, (.dmark+1)  
32b9 32 72 ee			ld (debug_mark+1),a  
32bc 3a c6 32			ld a, (.dmark+2)  
32bf 32 73 ee			ld (debug_mark+2),a  
32c2 18 03			jr .pastdmark  
32c4 ..			.dmark: db "UN<"  
32c7 f1			.pastdmark: pop af  
32c8			endm  
# End of macro DMARK
32c8					CALLMONITOR 
32c8 cd a0 14			call break_point_state  
32cb				endm  
# End of macro CALLMONITOR
32cb				endif 
32cb c3 05 1f			jp exec1 
32ce			 
32ce					 
32ce			 
32ce			 
32ce					NEXTW 
32ce c3 74 1e			jp macro_next 
32d1				endm 
# End of macro NEXTW
32d1			 
32d1			 
32d1			.ENDFLOW: 
32d1			 
32d1			; eof 
32d1			 
# End of file forth_words_flow.asm
32d1			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
32d1			include "forth_words_logic.asm" 
32d1			 
32d1			; | ## Logic Words 
32d1			 
32d1			.NOT: 
32d1				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
32d1 2d				db WORD_SYS_CORE+25             
32d2 19 33			dw .IS            
32d4 04				db 3 + 1 
32d5 .. 00			db "NOT",0              
32d9				endm 
# End of macro CWHEAD
32d9			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
32d9					if DEBUG_FORTH_WORDS_KEY 
32d9						DMARK "NOT" 
32d9 f5				push af  
32da 3a ee 32			ld a, (.dmark)  
32dd 32 71 ee			ld (debug_mark),a  
32e0 3a ef 32			ld a, (.dmark+1)  
32e3 32 72 ee			ld (debug_mark+1),a  
32e6 3a f0 32			ld a, (.dmark+2)  
32e9 32 73 ee			ld (debug_mark+2),a  
32ec 18 03			jr .pastdmark  
32ee ..			.dmark: db "NOT"  
32f1 f1			.pastdmark: pop af  
32f2			endm  
# End of macro DMARK
32f2						CALLMONITOR 
32f2 cd a0 14			call break_point_state  
32f5				endm  
# End of macro CALLMONITOR
32f5					endif 
32f5					FORTH_DSP 
32f5 cd c8 1c			call macro_forth_dsp 
32f8				endm 
# End of macro FORTH_DSP
32f8 7e					ld a,(hl)	; get type of value on TOS 
32f9 fe 02				cp DS_TYPE_INUM  
32fb 28 03				jr z, .noti 
32fd					NEXTW 
32fd c3 74 1e			jp macro_next 
3300				endm 
# End of macro NEXTW
3300			.noti:          FORTH_DSP_VALUEHL 
3300 cd 02 1d			call macro_dsp_valuehl 
3303				endm 
# End of macro FORTH_DSP_VALUEHL
3303			;		push hl 
3303					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3303 cd ba 1d			call macro_forth_dsp_pop 
3306				endm 
# End of macro FORTH_DSP_POP
3306			;		pop hl 
3306 3e 00				ld a,0 
3308 bd					cp l 
3309 28 04				jr z, .not2t 
330b 2e 00				ld l, 0 
330d 18 02				jr .notip 
330f			 
330f 2e ff		.not2t:		ld l, 255 
3311			 
3311 26 00		.notip:		ld h, 0	 
3313			 
3313 cd 0b 1b				call forth_push_numhl 
3316					NEXTW 
3316 c3 74 1e			jp macro_next 
3319				endm 
# End of macro NEXTW
3319			 
3319			.IS: 
3319				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3319 2d				db WORD_SYS_CORE+25             
331a 3f 33			dw .LZERO            
331c 03				db 2 + 1 
331d .. 00			db "IS",0              
3320				endm 
# End of macro CWHEAD
3320			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3320					if DEBUG_FORTH_WORDS_KEY 
3320						DMARK "IS." 
3320 f5				push af  
3321 3a 35 33			ld a, (.dmark)  
3324 32 71 ee			ld (debug_mark),a  
3327 3a 36 33			ld a, (.dmark+1)  
332a 32 72 ee			ld (debug_mark+1),a  
332d 3a 37 33			ld a, (.dmark+2)  
3330 32 73 ee			ld (debug_mark+2),a  
3333 18 03			jr .pastdmark  
3335 ..			.dmark: db "IS."  
3338 f1			.pastdmark: pop af  
3339			endm  
# End of macro DMARK
3339						CALLMONITOR 
3339 cd a0 14			call break_point_state  
333c				endm  
# End of macro CALLMONITOR
333c					endif 
333c					NEXTW 
333c c3 74 1e			jp macro_next 
333f				endm 
# End of macro NEXTW
333f			.LZERO: 
333f				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
333f 2d				db WORD_SYS_CORE+25             
3340 49 33			dw .TZERO            
3342 03				db 2 + 1 
3343 .. 00			db "0<",0              
3346				endm 
# End of macro CWHEAD
3346			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3346					NEXTW 
3346 c3 74 1e			jp macro_next 
3349				endm 
# End of macro NEXTW
3349			.TZERO: 
3349				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3349 2e				db WORD_SYS_CORE+26             
334a 90 33			dw .LESS            
334c 03				db 2 + 1 
334d .. 00			db "0=",0              
3350				endm 
# End of macro CWHEAD
3350			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3350				; TODO add floating point number detection 
3350					;v5 FORTH_DSP_VALUE 
3350					if DEBUG_FORTH_WORDS_KEY 
3350						DMARK "0=." 
3350 f5				push af  
3351 3a 65 33			ld a, (.dmark)  
3354 32 71 ee			ld (debug_mark),a  
3357 3a 66 33			ld a, (.dmark+1)  
335a 32 72 ee			ld (debug_mark+1),a  
335d 3a 67 33			ld a, (.dmark+2)  
3360 32 73 ee			ld (debug_mark+2),a  
3363 18 03			jr .pastdmark  
3365 ..			.dmark: db "0=."  
3368 f1			.pastdmark: pop af  
3369			endm  
# End of macro DMARK
3369						CALLMONITOR 
3369 cd a0 14			call break_point_state  
336c				endm  
# End of macro CALLMONITOR
336c					endif 
336c					FORTH_DSP 
336c cd c8 1c			call macro_forth_dsp 
336f				endm 
# End of macro FORTH_DSP
336f 7e					ld a,(hl)	; get type of value on TOS 
3370 fe 02				cp DS_TYPE_INUM  
3372 28 00				jr z, .tz_inum 
3374			 
3374				if FORTH_ENABLE_FLOATMATH 
3374					jr .tz_done 
3374			 
3374				endif 
3374					 
3374			 
3374			.tz_inum: 
3374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3374 cd 02 1d			call macro_dsp_valuehl 
3377				endm 
# End of macro FORTH_DSP_VALUEHL
3377			 
3377			;		push hl 
3377			 
3377					; destroy value TOS 
3377			 
3377					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3377 cd ba 1d			call macro_forth_dsp_pop 
337a				endm 
# End of macro FORTH_DSP_POP
337a			 
337a			;		pop hl 
337a			 
337a 3e 00				ld a,0 
337c			 
337c bd					cp l 
337d 20 08				jr nz, .tz_notzero 
337f			 
337f bc					cp h 
3380			 
3380 20 05				jr nz, .tz_notzero 
3382			 
3382			 
3382 21 01 00				ld hl, FORTH_TRUE 
3385 18 03				jr .tz_done 
3387			 
3387 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
338a			 
338a					; push value back onto stack for another op etc 
338a			 
338a			.tz_done: 
338a cd 0b 1b				call forth_push_numhl 
338d			 
338d					NEXTW 
338d c3 74 1e			jp macro_next 
3390				endm 
# End of macro NEXTW
3390			.LESS: 
3390				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3390 2f				db WORD_SYS_CORE+27             
3391 f9 33			dw .GT            
3393 02				db 1 + 1 
3394 .. 00			db "<",0              
3396				endm 
# End of macro CWHEAD
3396			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3396				; TODO add floating point number detection 
3396					if DEBUG_FORTH_WORDS_KEY 
3396						DMARK "LES" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 71 ee			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 72 ee			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 73 ee			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "LES"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd a0 14			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2					FORTH_DSP 
33b2 cd c8 1c			call macro_forth_dsp 
33b5				endm 
# End of macro FORTH_DSP
33b5					;v5 FORTH_DSP_VALUE 
33b5 7e					ld a,(hl)	; get type of value on TOS 
33b6 fe 02				cp DS_TYPE_INUM  
33b8 28 00				jr z, .less_inum 
33ba			 
33ba				if FORTH_ENABLE_FLOATMATH 
33ba					jr .less_done 
33ba			 
33ba				endif 
33ba					 
33ba			 
33ba			.less_inum: 
33ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ba cd 02 1d			call macro_dsp_valuehl 
33bd				endm 
# End of macro FORTH_DSP_VALUEHL
33bd			 
33bd e5					push hl  ; u2 
33be			 
33be					; destroy value TOS 
33be			 
33be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33be cd ba 1d			call macro_forth_dsp_pop 
33c1				endm 
# End of macro FORTH_DSP_POP
33c1			 
33c1			 
33c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c1 cd 02 1d			call macro_dsp_valuehl 
33c4				endm 
# End of macro FORTH_DSP_VALUEHL
33c4			 
33c4 e5					push hl    ; u1 
33c5			 
33c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33c5 cd ba 1d			call macro_forth_dsp_pop 
33c8				endm 
# End of macro FORTH_DSP_POP
33c8			 
33c8			 
33c8 b7			 or a      ;clear carry flag 
33c9 01 00 00		 ld bc, FORTH_FALSE 
33cc e1			  pop hl    ; u1 
33cd d1			  pop de    ; u2 
33ce ed 52		  sbc hl,de 
33d0 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
33d2			 
33d2 01 01 00		 ld bc, FORTH_TRUE 
33d5			.lscont:  
33d5 c5					push bc 
33d6 e1					pop hl 
33d7			 
33d7					if DEBUG_FORTH_WORDS 
33d7						DMARK "LT1" 
33d7 f5				push af  
33d8 3a ec 33			ld a, (.dmark)  
33db 32 71 ee			ld (debug_mark),a  
33de 3a ed 33			ld a, (.dmark+1)  
33e1 32 72 ee			ld (debug_mark+1),a  
33e4 3a ee 33			ld a, (.dmark+2)  
33e7 32 73 ee			ld (debug_mark+2),a  
33ea 18 03			jr .pastdmark  
33ec ..			.dmark: db "LT1"  
33ef f1			.pastdmark: pop af  
33f0			endm  
# End of macro DMARK
33f0						CALLMONITOR 
33f0 cd a0 14			call break_point_state  
33f3				endm  
# End of macro CALLMONITOR
33f3					endif 
33f3 cd 0b 1b				call forth_push_numhl 
33f6			 
33f6					NEXTW 
33f6 c3 74 1e			jp macro_next 
33f9				endm 
# End of macro NEXTW
33f9			.GT: 
33f9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
33f9 30				db WORD_SYS_CORE+28             
33fa 62 34			dw .EQUAL            
33fc 02				db 1 + 1 
33fd .. 00			db ">",0              
33ff				endm 
# End of macro CWHEAD
33ff			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
33ff				; TODO add floating point number detection 
33ff					if DEBUG_FORTH_WORDS_KEY 
33ff						DMARK "GRT" 
33ff f5				push af  
3400 3a 14 34			ld a, (.dmark)  
3403 32 71 ee			ld (debug_mark),a  
3406 3a 15 34			ld a, (.dmark+1)  
3409 32 72 ee			ld (debug_mark+1),a  
340c 3a 16 34			ld a, (.dmark+2)  
340f 32 73 ee			ld (debug_mark+2),a  
3412 18 03			jr .pastdmark  
3414 ..			.dmark: db "GRT"  
3417 f1			.pastdmark: pop af  
3418			endm  
# End of macro DMARK
3418						CALLMONITOR 
3418 cd a0 14			call break_point_state  
341b				endm  
# End of macro CALLMONITOR
341b					endif 
341b					FORTH_DSP 
341b cd c8 1c			call macro_forth_dsp 
341e				endm 
# End of macro FORTH_DSP
341e					;FORTH_DSP_VALUE 
341e 7e					ld a,(hl)	; get type of value on TOS 
341f fe 02				cp DS_TYPE_INUM  
3421 28 00				jr z, .gt_inum 
3423			 
3423				if FORTH_ENABLE_FLOATMATH 
3423					jr .gt_done 
3423			 
3423				endif 
3423					 
3423			 
3423			.gt_inum: 
3423					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3423 cd 02 1d			call macro_dsp_valuehl 
3426				endm 
# End of macro FORTH_DSP_VALUEHL
3426			 
3426 e5					push hl  ; u2 
3427			 
3427					; destroy value TOS 
3427			 
3427					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3427 cd ba 1d			call macro_forth_dsp_pop 
342a				endm 
# End of macro FORTH_DSP_POP
342a			 
342a			 
342a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
342a cd 02 1d			call macro_dsp_valuehl 
342d				endm 
# End of macro FORTH_DSP_VALUEHL
342d			 
342d e5					push hl    ; u1 
342e			 
342e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
342e cd ba 1d			call macro_forth_dsp_pop 
3431				endm 
# End of macro FORTH_DSP_POP
3431			 
3431			 
3431 b7			 or a      ;clear carry flag 
3432 01 00 00		 ld bc, FORTH_FALSE 
3435 e1			  pop hl    ; u1 
3436 d1			  pop de    ; u2 
3437 ed 52		  sbc hl,de 
3439 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
343b			 
343b 01 01 00		 ld bc, FORTH_TRUE 
343e			.gtcont:  
343e c5					push bc 
343f e1					pop hl 
3440			 
3440					if DEBUG_FORTH_WORDS 
3440						DMARK "GT1" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 71 ee			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 72 ee			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 73 ee			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "GT1"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459						CALLMONITOR 
3459 cd a0 14			call break_point_state  
345c				endm  
# End of macro CALLMONITOR
345c					endif 
345c cd 0b 1b				call forth_push_numhl 
345f			 
345f					NEXTW 
345f c3 74 1e			jp macro_next 
3462				endm 
# End of macro NEXTW
3462			.EQUAL: 
3462				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3462 31				db WORD_SYS_CORE+29             
3463 cd 34			dw .ENDLOGIC            
3465 02				db 1 + 1 
3466 .. 00			db "=",0              
3468				endm 
# End of macro CWHEAD
3468			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3468				; TODO add floating point number detection 
3468					if DEBUG_FORTH_WORDS_KEY 
3468						DMARK "EQ." 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 71 ee			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 72 ee			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 73 ee			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "EQ."  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd a0 14			call break_point_state  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484					FORTH_DSP 
3484 cd c8 1c			call macro_forth_dsp 
3487				endm 
# End of macro FORTH_DSP
3487					;v5 FORTH_DSP_VALUE 
3487 7e					ld a,(hl)	; get type of value on TOS 
3488 fe 02				cp DS_TYPE_INUM  
348a 28 00				jr z, .eq_inum 
348c			 
348c				if FORTH_ENABLE_FLOATMATH 
348c					jr .eq_done 
348c			 
348c				endif 
348c					 
348c			 
348c			.eq_inum: 
348c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
348c cd 02 1d			call macro_dsp_valuehl 
348f				endm 
# End of macro FORTH_DSP_VALUEHL
348f			 
348f e5					push hl 
3490			 
3490					; destroy value TOS 
3490			 
3490					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3490 cd ba 1d			call macro_forth_dsp_pop 
3493				endm 
# End of macro FORTH_DSP_POP
3493			 
3493			 
3493					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3493 cd 02 1d			call macro_dsp_valuehl 
3496				endm 
# End of macro FORTH_DSP_VALUEHL
3496			 
3496					; one value on hl get other one back 
3496			 
3496 e5					push hl 
3497			 
3497					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3497 cd ba 1d			call macro_forth_dsp_pop 
349a				endm 
# End of macro FORTH_DSP_POP
349a			 
349a 0e 00				ld c, FORTH_FALSE 
349c			 
349c e1					pop hl 
349d d1					pop de 
349e			 
349e 7b					ld a, e 
349f bd					cp l 
34a0			 
34a0 20 06				jr nz, .eq_done 
34a2			 
34a2 7a					ld a, d 
34a3 bc					cp h 
34a4			 
34a4 20 02				jr nz, .eq_done 
34a6			 
34a6 0e 01				ld c, FORTH_TRUE 
34a8					 
34a8			 
34a8			 
34a8			.eq_done: 
34a8			 
34a8					; TODO push value back onto stack for another op etc 
34a8			 
34a8 26 00				ld h, 0 
34aa 69					ld l, c 
34ab					if DEBUG_FORTH_WORDS 
34ab						DMARK "EQ1" 
34ab f5				push af  
34ac 3a c0 34			ld a, (.dmark)  
34af 32 71 ee			ld (debug_mark),a  
34b2 3a c1 34			ld a, (.dmark+1)  
34b5 32 72 ee			ld (debug_mark+1),a  
34b8 3a c2 34			ld a, (.dmark+2)  
34bb 32 73 ee			ld (debug_mark+2),a  
34be 18 03			jr .pastdmark  
34c0 ..			.dmark: db "EQ1"  
34c3 f1			.pastdmark: pop af  
34c4			endm  
# End of macro DMARK
34c4						CALLMONITOR 
34c4 cd a0 14			call break_point_state  
34c7				endm  
# End of macro CALLMONITOR
34c7					endif 
34c7 cd 0b 1b				call forth_push_numhl 
34ca			 
34ca					NEXTW 
34ca c3 74 1e			jp macro_next 
34cd				endm 
# End of macro NEXTW
34cd			 
34cd			 
34cd			.ENDLOGIC: 
34cd			; eof 
34cd			 
34cd			 
# End of file forth_words_logic.asm
34cd			include "forth_words_maths.asm" 
34cd			 
34cd			; | ## Maths Words 
34cd			 
34cd			.PLUS:	 
34cd				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
34cd 15				db WORD_SYS_CORE+1             
34ce 0f 35			dw .NEG            
34d0 02				db 1 + 1 
34d1 .. 00			db "+",0              
34d3				endm 
# End of macro CWHEAD
34d3			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
34d3					if DEBUG_FORTH_WORDS_KEY 
34d3						DMARK "PLU" 
34d3 f5				push af  
34d4 3a e8 34			ld a, (.dmark)  
34d7 32 71 ee			ld (debug_mark),a  
34da 3a e9 34			ld a, (.dmark+1)  
34dd 32 72 ee			ld (debug_mark+1),a  
34e0 3a ea 34			ld a, (.dmark+2)  
34e3 32 73 ee			ld (debug_mark+2),a  
34e6 18 03			jr .pastdmark  
34e8 ..			.dmark: db "PLU"  
34eb f1			.pastdmark: pop af  
34ec			endm  
# End of macro DMARK
34ec						CALLMONITOR 
34ec cd a0 14			call break_point_state  
34ef				endm  
# End of macro CALLMONITOR
34ef					endif 
34ef					; add top two values and push back result 
34ef			 
34ef					;for v5 FORTH_DSP_VALUE 
34ef					FORTH_DSP 
34ef cd c8 1c			call macro_forth_dsp 
34f2				endm 
# End of macro FORTH_DSP
34f2 7e					ld a,(hl)	; get type of value on TOS 
34f3 fe 02				cp DS_TYPE_INUM  
34f5 28 03				jr z, .dot_inum 
34f7			 
34f7					NEXTW 
34f7 c3 74 1e			jp macro_next 
34fa				endm 
# End of macro NEXTW
34fa			 
34fa			; float maths 
34fa			 
34fa				if FORTH_ENABLE_FLOATMATH 
34fa						inc hl      ; now at start of numeric as string 
34fa			 
34fa					if DEBUG_FORTH_MATHS 
34fa						DMARK "ADD" 
34fa				CALLMONITOR 
34fa					endif 
34fa			 
34fa					;ld ix, hl 
34fa					call CON 
34fa			 
34fa			 
34fa					push hl 
34fa					 
34fa					 
34fa			 
34fa						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
34fa			 
34fa					; get next number 
34fa			 
34fa						FORTH_DSP_VALUE 
34fa			 
34fa						inc hl      ; now at start of numeric as string 
34fa			 
34fa					;ld ix, hl 
34fa					call CON 
34fa			 
34fa					push hl 
34fa			 
34fa			 
34fa						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34fa			 
34fa						; TODO do add 
34fa			 
34fa						call IADD 
34fa			 
34fa						; TODO get result back as ascii 
34fa			 
34fa						; TODO push result  
34fa			 
34fa			 
34fa			 
34fa						jr .dot_done 
34fa				endif 
34fa			 
34fa			.dot_inum: 
34fa			 
34fa			 
34fa					if DEBUG_FORTH_DOT 
34fa						DMARK "+IT" 
34fa				CALLMONITOR 
34fa					endif 
34fa			 
34fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34fa cd 02 1d			call macro_dsp_valuehl 
34fd				endm 
# End of macro FORTH_DSP_VALUEHL
34fd			 
34fd				; TODO add floating point number detection 
34fd			 
34fd e5					push hl 
34fe			 
34fe					; destroy value TOS 
34fe			 
34fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34fe cd ba 1d			call macro_forth_dsp_pop 
3501				endm 
# End of macro FORTH_DSP_POP
3501			 
3501			 
3501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3501 cd 02 1d			call macro_dsp_valuehl 
3504				endm 
# End of macro FORTH_DSP_VALUEHL
3504			 
3504					; one value on hl get other one back 
3504			 
3504 d1					pop de 
3505			 
3505					; do the add 
3505			 
3505 19					add hl,de 
3506			 
3506					; save it 
3506			 
3506			;		push hl	 
3506			 
3506					; 
3506			 
3506					; destroy value TOS 
3506			 
3506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3506 cd ba 1d			call macro_forth_dsp_pop 
3509				endm 
# End of macro FORTH_DSP_POP
3509			 
3509					; TODO push value back onto stack for another op etc 
3509			 
3509			;		pop hl 
3509			 
3509			.dot_done: 
3509 cd 0b 1b				call forth_push_numhl 
350c			 
350c					NEXTW 
350c c3 74 1e			jp macro_next 
350f				endm 
# End of macro NEXTW
350f			.NEG: 
350f			 
350f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
350f 17				db WORD_SYS_CORE+3             
3510 52 35			dw .DIV            
3512 02				db 1 + 1 
3513 .. 00			db "-",0              
3515				endm 
# End of macro CWHEAD
3515			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3515					if DEBUG_FORTH_WORDS_KEY 
3515						DMARK "SUB" 
3515 f5				push af  
3516 3a 2a 35			ld a, (.dmark)  
3519 32 71 ee			ld (debug_mark),a  
351c 3a 2b 35			ld a, (.dmark+1)  
351f 32 72 ee			ld (debug_mark+1),a  
3522 3a 2c 35			ld a, (.dmark+2)  
3525 32 73 ee			ld (debug_mark+2),a  
3528 18 03			jr .pastdmark  
352a ..			.dmark: db "SUB"  
352d f1			.pastdmark: pop af  
352e			endm  
# End of macro DMARK
352e						CALLMONITOR 
352e cd a0 14			call break_point_state  
3531				endm  
# End of macro CALLMONITOR
3531					endif 
3531			 
3531			 
3531				; TODO add floating point number detection 
3531					; v5 FORTH_DSP_VALUE 
3531					FORTH_DSP 
3531 cd c8 1c			call macro_forth_dsp 
3534				endm 
# End of macro FORTH_DSP
3534 7e					ld a,(hl)	; get type of value on TOS 
3535 fe 02				cp DS_TYPE_INUM  
3537 28 03				jr z, .neg_inum 
3539			 
3539					NEXTW 
3539 c3 74 1e			jp macro_next 
353c				endm 
# End of macro NEXTW
353c			 
353c			; float maths 
353c			 
353c				if FORTH_ENABLE_FLOATMATH 
353c					jr .neg_done 
353c			 
353c				endif 
353c					 
353c			 
353c			.neg_inum: 
353c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353c cd 02 1d			call macro_dsp_valuehl 
353f				endm 
# End of macro FORTH_DSP_VALUEHL
353f			 
353f e5					push hl 
3540			 
3540					; destroy value TOS 
3540			 
3540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3540 cd ba 1d			call macro_forth_dsp_pop 
3543				endm 
# End of macro FORTH_DSP_POP
3543			 
3543			 
3543					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3543 cd 02 1d			call macro_dsp_valuehl 
3546				endm 
# End of macro FORTH_DSP_VALUEHL
3546			 
3546					; one value on hl get other one back 
3546			 
3546 d1					pop de 
3547			 
3547					; do the sub 
3547			;		ex de, hl 
3547			 
3547 ed 52				sbc hl,de 
3549			 
3549					; save it 
3549			 
3549			;		push hl	 
3549			 
3549					; 
3549			 
3549					; destroy value TOS 
3549			 
3549					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3549 cd ba 1d			call macro_forth_dsp_pop 
354c				endm 
# End of macro FORTH_DSP_POP
354c			 
354c					; TODO push value back onto stack for another op etc 
354c			 
354c			;		pop hl 
354c			 
354c cd 0b 1b				call forth_push_numhl 
354f			.neg_done: 
354f			 
354f					NEXTW 
354f c3 74 1e			jp macro_next 
3552				endm 
# End of macro NEXTW
3552			.DIV: 
3552				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3552 18				db WORD_SYS_CORE+4             
3553 9f 35			dw .MUL            
3555 02				db 1 + 1 
3556 .. 00			db "/",0              
3558				endm 
# End of macro CWHEAD
3558			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3558					if DEBUG_FORTH_WORDS_KEY 
3558						DMARK "DIV" 
3558 f5				push af  
3559 3a 6d 35			ld a, (.dmark)  
355c 32 71 ee			ld (debug_mark),a  
355f 3a 6e 35			ld a, (.dmark+1)  
3562 32 72 ee			ld (debug_mark+1),a  
3565 3a 6f 35			ld a, (.dmark+2)  
3568 32 73 ee			ld (debug_mark+2),a  
356b 18 03			jr .pastdmark  
356d ..			.dmark: db "DIV"  
3570 f1			.pastdmark: pop af  
3571			endm  
# End of macro DMARK
3571						CALLMONITOR 
3571 cd a0 14			call break_point_state  
3574				endm  
# End of macro CALLMONITOR
3574					endif 
3574				; TODO add floating point number detection 
3574					; v5 FORTH_DSP_VALUE 
3574					FORTH_DSP 
3574 cd c8 1c			call macro_forth_dsp 
3577				endm 
# End of macro FORTH_DSP
3577 7e					ld a,(hl)	; get type of value on TOS 
3578 fe 02				cp DS_TYPE_INUM  
357a 28 03				jr z, .div_inum 
357c			 
357c				if FORTH_ENABLE_FLOATMATH 
357c					jr .div_done 
357c			 
357c				endif 
357c					NEXTW 
357c c3 74 1e			jp macro_next 
357f				endm 
# End of macro NEXTW
357f			.div_inum: 
357f			 
357f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357f cd 02 1d			call macro_dsp_valuehl 
3582				endm 
# End of macro FORTH_DSP_VALUEHL
3582			 
3582 e5					push hl    ; to go to bc 
3583			 
3583					; destroy value TOS 
3583			 
3583					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3583 cd ba 1d			call macro_forth_dsp_pop 
3586				endm 
# End of macro FORTH_DSP_POP
3586			 
3586			 
3586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3586 cd 02 1d			call macro_dsp_valuehl 
3589				endm 
# End of macro FORTH_DSP_VALUEHL
3589			 
3589					; hl to go to de 
3589			 
3589 e5					push hl 
358a			 
358a c1					pop bc 
358b d1					pop de		 
358c			 
358c			 
358c					if DEBUG_FORTH_MATHS 
358c						DMARK "DIV" 
358c				CALLMONITOR 
358c					endif 
358c					; one value on hl but move to a get other one back 
358c			 
358c			        
358c cd fc 0b			call Div16 
358f			 
358f			;	push af	 
358f e5				push hl 
3590 c5				push bc 
3591			 
3591					if DEBUG_FORTH_MATHS 
3591						DMARK "DI1" 
3591				CALLMONITOR 
3591					endif 
3591			 
3591					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3591 cd ba 1d			call macro_forth_dsp_pop 
3594				endm 
# End of macro FORTH_DSP_POP
3594			 
3594			 
3594			 
3594 e1					pop hl    ; result 
3595			 
3595 cd 0b 1b				call forth_push_numhl 
3598			 
3598 e1					pop hl    ; reminder 
3599			;		ld h,0 
3599			;		ld l,d 
3599			 
3599 cd 0b 1b				call forth_push_numhl 
359c			.div_done: 
359c					NEXTW 
359c c3 74 1e			jp macro_next 
359f				endm 
# End of macro NEXTW
359f			.MUL: 
359f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
359f 19				db WORD_SYS_CORE+5             
35a0 e4 35			dw .MIN            
35a2 02				db 1 + 1 
35a3 .. 00			db "*",0              
35a5				endm 
# End of macro CWHEAD
35a5			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
35a5				; TODO add floating point number detection 
35a5					if DEBUG_FORTH_WORDS_KEY 
35a5						DMARK "MUL" 
35a5 f5				push af  
35a6 3a ba 35			ld a, (.dmark)  
35a9 32 71 ee			ld (debug_mark),a  
35ac 3a bb 35			ld a, (.dmark+1)  
35af 32 72 ee			ld (debug_mark+1),a  
35b2 3a bc 35			ld a, (.dmark+2)  
35b5 32 73 ee			ld (debug_mark+2),a  
35b8 18 03			jr .pastdmark  
35ba ..			.dmark: db "MUL"  
35bd f1			.pastdmark: pop af  
35be			endm  
# End of macro DMARK
35be						CALLMONITOR 
35be cd a0 14			call break_point_state  
35c1				endm  
# End of macro CALLMONITOR
35c1					endif 
35c1					FORTH_DSP 
35c1 cd c8 1c			call macro_forth_dsp 
35c4				endm 
# End of macro FORTH_DSP
35c4					; v5 FORTH_DSP_VALUE 
35c4 7e					ld a,(hl)	; get type of value on TOS 
35c5 fe 02				cp DS_TYPE_INUM  
35c7 28 03				jr z, .mul_inum 
35c9			 
35c9				if FORTH_ENABLE_FLOATMATH 
35c9					jr .mul_done 
35c9			 
35c9				endif 
35c9			 
35c9					NEXTW 
35c9 c3 74 1e			jp macro_next 
35cc				endm 
# End of macro NEXTW
35cc			.mul_inum:	 
35cc			 
35cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35cc cd 02 1d			call macro_dsp_valuehl 
35cf				endm 
# End of macro FORTH_DSP_VALUEHL
35cf			 
35cf e5					push hl 
35d0			 
35d0					; destroy value TOS 
35d0			 
35d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d0 cd ba 1d			call macro_forth_dsp_pop 
35d3				endm 
# End of macro FORTH_DSP_POP
35d3			 
35d3			 
35d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d3 cd 02 1d			call macro_dsp_valuehl 
35d6				endm 
# End of macro FORTH_DSP_VALUEHL
35d6			 
35d6					; one value on hl but move to a get other one back 
35d6			 
35d6 7d					ld a, l 
35d7			 
35d7 d1					pop de 
35d8			 
35d8					; do the mull 
35d8			;		ex de, hl 
35d8			 
35d8 cd 22 0c				call Mult16 
35db					; save it 
35db			 
35db			;		push hl	 
35db			 
35db					; 
35db			 
35db					; destroy value TOS 
35db			 
35db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35db cd ba 1d			call macro_forth_dsp_pop 
35de				endm 
# End of macro FORTH_DSP_POP
35de			 
35de					; TODO push value back onto stack for another op etc 
35de			 
35de			;		pop hl 
35de			 
35de cd 0b 1b				call forth_push_numhl 
35e1			 
35e1			.mul_done: 
35e1					NEXTW 
35e1 c3 74 1e			jp macro_next 
35e4				endm 
# End of macro NEXTW
35e4			 
35e4			 
35e4			 
35e4			 
35e4			.MIN: 
35e4				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
35e4 49				db WORD_SYS_CORE+53             
35e5 65 36			dw .MAX            
35e7 04				db 3 + 1 
35e8 .. 00			db "MIN",0              
35ec				endm 
# End of macro CWHEAD
35ec			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
35ec					if DEBUG_FORTH_WORDS_KEY 
35ec						DMARK "MIN" 
35ec f5				push af  
35ed 3a 01 36			ld a, (.dmark)  
35f0 32 71 ee			ld (debug_mark),a  
35f3 3a 02 36			ld a, (.dmark+1)  
35f6 32 72 ee			ld (debug_mark+1),a  
35f9 3a 03 36			ld a, (.dmark+2)  
35fc 32 73 ee			ld (debug_mark+2),a  
35ff 18 03			jr .pastdmark  
3601 ..			.dmark: db "MIN"  
3604 f1			.pastdmark: pop af  
3605			endm  
# End of macro DMARK
3605						CALLMONITOR 
3605 cd a0 14			call break_point_state  
3608				endm  
# End of macro CALLMONITOR
3608					endif 
3608					; get u2 
3608			 
3608					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3608 cd 02 1d			call macro_dsp_valuehl 
360b				endm 
# End of macro FORTH_DSP_VALUEHL
360b			 
360b e5					push hl   ; u2 
360c			 
360c					; destroy value TOS 
360c			 
360c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360c cd ba 1d			call macro_forth_dsp_pop 
360f				endm 
# End of macro FORTH_DSP_POP
360f			 
360f					; get u1 
360f			 
360f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360f cd 02 1d			call macro_dsp_valuehl 
3612				endm 
# End of macro FORTH_DSP_VALUEHL
3612			 
3612 e5					push hl  ; u1 
3613			 
3613					; destroy value TOS 
3613			 
3613					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3613 cd ba 1d			call macro_forth_dsp_pop 
3616				endm 
# End of macro FORTH_DSP_POP
3616			 
3616 b7			 or a      ;clear carry flag 
3617 e1			  pop hl    ; u1 
3618 d1			  pop de    ; u2 
3619 e5				push hl   ; saved in case hl is lowest 
361a ed 52		  sbc hl,de 
361c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
361e			 
361e e1				pop hl 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "MIN" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 71 ee			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 72 ee			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 73 ee			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "MIN"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd a0 14			call break_point_state  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b cd 0b 1b				call forth_push_numhl 
363e			 
363e				       NEXTW 
363e c3 74 1e			jp macro_next 
3641				endm 
# End of macro NEXTW
3641			 
3641			.mincont:  
3641 c1				pop bc   ; tidy up 
3642 eb				ex de , hl  
3643					if DEBUG_FORTH_WORDS 
3643						DMARK "MI1" 
3643 f5				push af  
3644 3a 58 36			ld a, (.dmark)  
3647 32 71 ee			ld (debug_mark),a  
364a 3a 59 36			ld a, (.dmark+1)  
364d 32 72 ee			ld (debug_mark+1),a  
3650 3a 5a 36			ld a, (.dmark+2)  
3653 32 73 ee			ld (debug_mark+2),a  
3656 18 03			jr .pastdmark  
3658 ..			.dmark: db "MI1"  
365b f1			.pastdmark: pop af  
365c			endm  
# End of macro DMARK
365c						CALLMONITOR 
365c cd a0 14			call break_point_state  
365f				endm  
# End of macro CALLMONITOR
365f					endif 
365f cd 0b 1b				call forth_push_numhl 
3662			 
3662				       NEXTW 
3662 c3 74 1e			jp macro_next 
3665				endm 
# End of macro NEXTW
3665			.MAX: 
3665				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3665 4a				db WORD_SYS_CORE+54             
3666 e6 36			dw .RND16            
3668 04				db 3 + 1 
3669 .. 00			db "MAX",0              
366d				endm 
# End of macro CWHEAD
366d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
366d					if DEBUG_FORTH_WORDS_KEY 
366d						DMARK "MAX" 
366d f5				push af  
366e 3a 82 36			ld a, (.dmark)  
3671 32 71 ee			ld (debug_mark),a  
3674 3a 83 36			ld a, (.dmark+1)  
3677 32 72 ee			ld (debug_mark+1),a  
367a 3a 84 36			ld a, (.dmark+2)  
367d 32 73 ee			ld (debug_mark+2),a  
3680 18 03			jr .pastdmark  
3682 ..			.dmark: db "MAX"  
3685 f1			.pastdmark: pop af  
3686			endm  
# End of macro DMARK
3686						CALLMONITOR 
3686 cd a0 14			call break_point_state  
3689				endm  
# End of macro CALLMONITOR
3689					endif 
3689					; get u2 
3689			 
3689					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3689 cd 02 1d			call macro_dsp_valuehl 
368c				endm 
# End of macro FORTH_DSP_VALUEHL
368c			 
368c e5					push hl   ; u2 
368d			 
368d					; destroy value TOS 
368d			 
368d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368d cd ba 1d			call macro_forth_dsp_pop 
3690				endm 
# End of macro FORTH_DSP_POP
3690			 
3690					; get u1 
3690			 
3690					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3690 cd 02 1d			call macro_dsp_valuehl 
3693				endm 
# End of macro FORTH_DSP_VALUEHL
3693			 
3693 e5					push hl  ; u1 
3694			 
3694					; destroy value TOS 
3694			 
3694					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3694 cd ba 1d			call macro_forth_dsp_pop 
3697				endm 
# End of macro FORTH_DSP_POP
3697			 
3697 b7			 or a      ;clear carry flag 
3698 e1			  pop hl    ; u1 
3699 d1			  pop de    ; u2 
369a e5				push hl   ; saved in case hl is lowest 
369b ed 52		  sbc hl,de 
369d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
369f			 
369f e1				pop hl 
36a0					if DEBUG_FORTH_WORDS 
36a0						DMARK "MAX" 
36a0 f5				push af  
36a1 3a b5 36			ld a, (.dmark)  
36a4 32 71 ee			ld (debug_mark),a  
36a7 3a b6 36			ld a, (.dmark+1)  
36aa 32 72 ee			ld (debug_mark+1),a  
36ad 3a b7 36			ld a, (.dmark+2)  
36b0 32 73 ee			ld (debug_mark+2),a  
36b3 18 03			jr .pastdmark  
36b5 ..			.dmark: db "MAX"  
36b8 f1			.pastdmark: pop af  
36b9			endm  
# End of macro DMARK
36b9						CALLMONITOR 
36b9 cd a0 14			call break_point_state  
36bc				endm  
# End of macro CALLMONITOR
36bc					endif 
36bc cd 0b 1b				call forth_push_numhl 
36bf			 
36bf				       NEXTW 
36bf c3 74 1e			jp macro_next 
36c2				endm 
# End of macro NEXTW
36c2			 
36c2			.maxcont:  
36c2 c1				pop bc   ; tidy up 
36c3 eb				ex de , hl  
36c4					if DEBUG_FORTH_WORDS 
36c4						DMARK "MA1" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 71 ee			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 72 ee			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 73 ee			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "MA1"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						CALLMONITOR 
36dd cd a0 14			call break_point_state  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0 cd 0b 1b				call forth_push_numhl 
36e3				       NEXTW 
36e3 c3 74 1e			jp macro_next 
36e6				endm 
# End of macro NEXTW
36e6			 
36e6			.RND16: 
36e6				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
36e6 4e				db WORD_SYS_CORE+58             
36e7 15 37			dw .RND8            
36e9 06				db 5 + 1 
36ea .. 00			db "RND16",0              
36f0				endm 
# End of macro CWHEAD
36f0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
36f0					if DEBUG_FORTH_WORDS_KEY 
36f0						DMARK "R16" 
36f0 f5				push af  
36f1 3a 05 37			ld a, (.dmark)  
36f4 32 71 ee			ld (debug_mark),a  
36f7 3a 06 37			ld a, (.dmark+1)  
36fa 32 72 ee			ld (debug_mark+1),a  
36fd 3a 07 37			ld a, (.dmark+2)  
3700 32 73 ee			ld (debug_mark+2),a  
3703 18 03			jr .pastdmark  
3705 ..			.dmark: db "R16"  
3708 f1			.pastdmark: pop af  
3709			endm  
# End of macro DMARK
3709						CALLMONITOR 
3709 cd a0 14			call break_point_state  
370c				endm  
# End of macro CALLMONITOR
370c					endif 
370c cd c6 0b				call prng16  
370f cd 0b 1b				call forth_push_numhl 
3712				       NEXTW 
3712 c3 74 1e			jp macro_next 
3715				endm 
# End of macro NEXTW
3715			.RND8: 
3715				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3715 60				db WORD_SYS_CORE+76             
3716 4a 37			dw .RND            
3718 05				db 4 + 1 
3719 .. 00			db "RND8",0              
371e				endm 
# End of macro CWHEAD
371e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
371e					if DEBUG_FORTH_WORDS_KEY 
371e						DMARK "RN8" 
371e f5				push af  
371f 3a 33 37			ld a, (.dmark)  
3722 32 71 ee			ld (debug_mark),a  
3725 3a 34 37			ld a, (.dmark+1)  
3728 32 72 ee			ld (debug_mark+1),a  
372b 3a 35 37			ld a, (.dmark+2)  
372e 32 73 ee			ld (debug_mark+2),a  
3731 18 03			jr .pastdmark  
3733 ..			.dmark: db "RN8"  
3736 f1			.pastdmark: pop af  
3737			endm  
# End of macro DMARK
3737						CALLMONITOR 
3737 cd a0 14			call break_point_state  
373a				endm  
# End of macro CALLMONITOR
373a					endif 
373a 2a b2 eb				ld hl,(xrandc) 
373d 23					inc hl 
373e cd e0 0b				call xrnd 
3741 6f					ld l,a	 
3742 26 00				ld h,0 
3744 cd 0b 1b				call forth_push_numhl 
3747				       NEXTW 
3747 c3 74 1e			jp macro_next 
374a				endm 
# End of macro NEXTW
374a			.RND: 
374a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
374a 60				db WORD_SYS_CORE+76             
374b 50 38			dw .ENDMATHS            
374d 04				db 3 + 1 
374e .. 00			db "RND",0              
3752				endm 
# End of macro CWHEAD
3752			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3752			 
3752					if DEBUG_FORTH_WORDS_KEY 
3752						DMARK "RND" 
3752 f5				push af  
3753 3a 67 37			ld a, (.dmark)  
3756 32 71 ee			ld (debug_mark),a  
3759 3a 68 37			ld a, (.dmark+1)  
375c 32 72 ee			ld (debug_mark+1),a  
375f 3a 69 37			ld a, (.dmark+2)  
3762 32 73 ee			ld (debug_mark+2),a  
3765 18 03			jr .pastdmark  
3767 ..			.dmark: db "RND"  
376a f1			.pastdmark: pop af  
376b			endm  
# End of macro DMARK
376b						CALLMONITOR 
376b cd a0 14			call break_point_state  
376e				endm  
# End of macro CALLMONITOR
376e					endif 
376e					 
376e					FORTH_DSP_VALUEHL    ; upper range 
376e cd 02 1d			call macro_dsp_valuehl 
3771				endm 
# End of macro FORTH_DSP_VALUEHL
3771			 
3771 22 b6 eb				ld (LFSRSeed), hl	 
3774			 
3774					if DEBUG_FORTH_WORDS 
3774						DMARK "RN1" 
3774 f5				push af  
3775 3a 89 37			ld a, (.dmark)  
3778 32 71 ee			ld (debug_mark),a  
377b 3a 8a 37			ld a, (.dmark+1)  
377e 32 72 ee			ld (debug_mark+1),a  
3781 3a 8b 37			ld a, (.dmark+2)  
3784 32 73 ee			ld (debug_mark+2),a  
3787 18 03			jr .pastdmark  
3789 ..			.dmark: db "RN1"  
378c f1			.pastdmark: pop af  
378d			endm  
# End of macro DMARK
378d						CALLMONITOR 
378d cd a0 14			call break_point_state  
3790				endm  
# End of macro CALLMONITOR
3790					endif 
3790					FORTH_DSP_POP 
3790 cd ba 1d			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793					FORTH_DSP_VALUEHL    ; low range 
3793 cd 02 1d			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796					if DEBUG_FORTH_WORDS 
3796						DMARK "RN2" 
3796 f5				push af  
3797 3a ab 37			ld a, (.dmark)  
379a 32 71 ee			ld (debug_mark),a  
379d 3a ac 37			ld a, (.dmark+1)  
37a0 32 72 ee			ld (debug_mark+1),a  
37a3 3a ad 37			ld a, (.dmark+2)  
37a6 32 73 ee			ld (debug_mark+2),a  
37a9 18 03			jr .pastdmark  
37ab ..			.dmark: db "RN2"  
37ae f1			.pastdmark: pop af  
37af			endm  
# End of macro DMARK
37af						CALLMONITOR 
37af cd a0 14			call break_point_state  
37b2				endm  
# End of macro CALLMONITOR
37b2					endif 
37b2 22 b8 eb				ld (LFSRSeed+2), hl 
37b5			 
37b5					FORTH_DSP_POP 
37b5 cd ba 1d			call macro_forth_dsp_pop 
37b8				endm 
# End of macro FORTH_DSP_POP
37b8			 
37b8 e5					push hl 
37b9			 
37b9 e1			.inrange:	pop hl 
37ba cd c6 0b				call prng16  
37bd					if DEBUG_FORTH_WORDS 
37bd						DMARK "RN3" 
37bd f5				push af  
37be 3a d2 37			ld a, (.dmark)  
37c1 32 71 ee			ld (debug_mark),a  
37c4 3a d3 37			ld a, (.dmark+1)  
37c7 32 72 ee			ld (debug_mark+1),a  
37ca 3a d4 37			ld a, (.dmark+2)  
37cd 32 73 ee			ld (debug_mark+2),a  
37d0 18 03			jr .pastdmark  
37d2 ..			.dmark: db "RN3"  
37d5 f1			.pastdmark: pop af  
37d6			endm  
# End of macro DMARK
37d6						CALLMONITOR 
37d6 cd a0 14			call break_point_state  
37d9				endm  
# End of macro CALLMONITOR
37d9					endif 
37d9					 
37d9					; if the range is 8bit knock out the high byte 
37d9			 
37d9 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
37dd			 
37dd 3e 00				ld a, 0 
37df ba					cp d  
37e0 20 1e				jr nz, .hirange 
37e2 26 00				ld h, 0   ; knock it down to 8bit 
37e4			 
37e4					if DEBUG_FORTH_WORDS 
37e4						DMARK "RNk" 
37e4 f5				push af  
37e5 3a f9 37			ld a, (.dmark)  
37e8 32 71 ee			ld (debug_mark),a  
37eb 3a fa 37			ld a, (.dmark+1)  
37ee 32 72 ee			ld (debug_mark+1),a  
37f1 3a fb 37			ld a, (.dmark+2)  
37f4 32 73 ee			ld (debug_mark+2),a  
37f7 18 03			jr .pastdmark  
37f9 ..			.dmark: db "RNk"  
37fc f1			.pastdmark: pop af  
37fd			endm  
# End of macro DMARK
37fd						CALLMONITOR 
37fd cd a0 14			call break_point_state  
3800				endm  
# End of macro CALLMONITOR
3800					endif 
3800			.hirange:   
3800 e5					push hl  
3801 b7					or a  
3802 ed 52		                sbc hl, de 
3804			 
3804					;call cmp16 
3804			 
3804 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3806 e1					pop hl 
3807 e5					push hl 
3808			 
3808					if DEBUG_FORTH_WORDS 
3808						DMARK "RN4" 
3808 f5				push af  
3809 3a 1d 38			ld a, (.dmark)  
380c 32 71 ee			ld (debug_mark),a  
380f 3a 1e 38			ld a, (.dmark+1)  
3812 32 72 ee			ld (debug_mark+1),a  
3815 3a 1f 38			ld a, (.dmark+2)  
3818 32 73 ee			ld (debug_mark+2),a  
381b 18 03			jr .pastdmark  
381d ..			.dmark: db "RN4"  
3820 f1			.pastdmark: pop af  
3821			endm  
# End of macro DMARK
3821						CALLMONITOR 
3821 cd a0 14			call break_point_state  
3824				endm  
# End of macro CALLMONITOR
3824					endif 
3824 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3828					;call cmp16 
3828				 
3828 b7					or a  
3829 ed 52		                sbc hl, de 
382b 38 8c				jr c, .inrange 
382d			 
382d e1					pop hl 
382e					 
382e					if DEBUG_FORTH_WORDS 
382e						DMARK "RNd" 
382e f5				push af  
382f 3a 43 38			ld a, (.dmark)  
3832 32 71 ee			ld (debug_mark),a  
3835 3a 44 38			ld a, (.dmark+1)  
3838 32 72 ee			ld (debug_mark+1),a  
383b 3a 45 38			ld a, (.dmark+2)  
383e 32 73 ee			ld (debug_mark+2),a  
3841 18 03			jr .pastdmark  
3843 ..			.dmark: db "RNd"  
3846 f1			.pastdmark: pop af  
3847			endm  
# End of macro DMARK
3847						CALLMONITOR 
3847 cd a0 14			call break_point_state  
384a				endm  
# End of macro CALLMONITOR
384a					endif 
384a			 
384a			 
384a cd 0b 1b				call forth_push_numhl 
384d				       NEXTW 
384d c3 74 1e			jp macro_next 
3850				endm 
# End of macro NEXTW
3850			 
3850			.ENDMATHS: 
3850			 
3850			; eof 
3850			 
# End of file forth_words_maths.asm
3850			include "forth_words_display.asm" 
3850			 
3850			; | ## Display Words 
3850			 
3850			.INFO: 
3850			 
3850				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3850 62				db WORD_SYS_CORE+78             
3851 6d 38			dw .ATP            
3853 05				db 4 + 1 
3854 .. 00			db "INFO",0              
3859				endm 
# End of macro CWHEAD
3859			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3859					FORTH_DSP_VALUEHL 
3859 cd 02 1d			call macro_dsp_valuehl 
385c				endm 
# End of macro FORTH_DSP_VALUEHL
385c			 
385c					FORTH_DSP_POP 
385c cd ba 1d			call macro_forth_dsp_pop 
385f				endm 
# End of macro FORTH_DSP_POP
385f			 
385f e5					push hl 
3860			 
3860					FORTH_DSP_VALUEHL 
3860 cd 02 1d			call macro_dsp_valuehl 
3863				endm 
# End of macro FORTH_DSP_VALUEHL
3863			 
3863					FORTH_DSP_POP 
3863 cd ba 1d			call macro_forth_dsp_pop 
3866				endm 
# End of macro FORTH_DSP_POP
3866			 
3866 d1					pop de 
3867			 
3867 cd 03 0a				call info_panel 
386a			 
386a			 
386a					NEXTW 
386a c3 74 1e			jp macro_next 
386d				endm 
# End of macro NEXTW
386d			.ATP: 
386d				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
386d 62				db WORD_SYS_CORE+78             
386e e4 38			dw .FB            
3870 04				db 3 + 1 
3871 .. 00			db "AT?",0              
3875				endm 
# End of macro CWHEAD
3875			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3875					if DEBUG_FORTH_WORDS_KEY 
3875						DMARK "AT?" 
3875 f5				push af  
3876 3a 8a 38			ld a, (.dmark)  
3879 32 71 ee			ld (debug_mark),a  
387c 3a 8b 38			ld a, (.dmark+1)  
387f 32 72 ee			ld (debug_mark+1),a  
3882 3a 8c 38			ld a, (.dmark+2)  
3885 32 73 ee			ld (debug_mark+2),a  
3888 18 03			jr .pastdmark  
388a ..			.dmark: db "AT?"  
388d f1			.pastdmark: pop af  
388e			endm  
# End of macro DMARK
388e						CALLMONITOR 
388e cd a0 14			call break_point_state  
3891				endm  
# End of macro CALLMONITOR
3891					endif 
3891 3a 40 eb				ld a, (f_cursor_ptr) 
3894			 
3894			if DEBUG_FORTH_WORDS 
3894				DMARK "AT?" 
3894 f5				push af  
3895 3a a9 38			ld a, (.dmark)  
3898 32 71 ee			ld (debug_mark),a  
389b 3a aa 38			ld a, (.dmark+1)  
389e 32 72 ee			ld (debug_mark+1),a  
38a1 3a ab 38			ld a, (.dmark+2)  
38a4 32 73 ee			ld (debug_mark+2),a  
38a7 18 03			jr .pastdmark  
38a9 ..			.dmark: db "AT?"  
38ac f1			.pastdmark: pop af  
38ad			endm  
# End of macro DMARK
38ad				CALLMONITOR 
38ad cd a0 14			call break_point_state  
38b0				endm  
# End of macro CALLMONITOR
38b0			endif	 
38b0					; count the number of rows 
38b0			 
38b0 06 00				ld b, 0 
38b2 4f			.atpr:		ld c, a    ; save in case we go below zero 
38b3 d6 28				sub display_cols 
38b5 f2 bb 38				jp p, .atprunder 
38b8 04					inc b 
38b9 18 f7				jr .atpr 
38bb			.atprunder:	 
38bb			if DEBUG_FORTH_WORDS 
38bb				DMARK "A?2" 
38bb f5				push af  
38bc 3a d0 38			ld a, (.dmark)  
38bf 32 71 ee			ld (debug_mark),a  
38c2 3a d1 38			ld a, (.dmark+1)  
38c5 32 72 ee			ld (debug_mark+1),a  
38c8 3a d2 38			ld a, (.dmark+2)  
38cb 32 73 ee			ld (debug_mark+2),a  
38ce 18 03			jr .pastdmark  
38d0 ..			.dmark: db "A?2"  
38d3 f1			.pastdmark: pop af  
38d4			endm  
# End of macro DMARK
38d4				CALLMONITOR 
38d4 cd a0 14			call break_point_state  
38d7				endm  
# End of macro CALLMONITOR
38d7			endif	 
38d7 26 00				ld h, 0 
38d9 69					ld l, c 
38da cd 0b 1b				call forth_push_numhl 
38dd 68					ld l, b  
38de cd 0b 1b				call forth_push_numhl 
38e1			 
38e1			 
38e1				NEXTW 
38e1 c3 74 1e			jp macro_next 
38e4				endm 
# End of macro NEXTW
38e4			 
38e4			.FB: 
38e4				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
38e4 1b				db WORD_SYS_CORE+7             
38e5 32 39			dw .EMIT            
38e7 03				db 2 + 1 
38e8 .. 00			db "FB",0              
38eb				endm 
# End of macro CWHEAD
38eb			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
38eb			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
38eb			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
38eb			; | | If automatic display is off then updates will not be shown until DRAW is used. 
38eb					if DEBUG_FORTH_WORDS_KEY 
38eb						DMARK "FB." 
38eb f5				push af  
38ec 3a 00 39			ld a, (.dmark)  
38ef 32 71 ee			ld (debug_mark),a  
38f2 3a 01 39			ld a, (.dmark+1)  
38f5 32 72 ee			ld (debug_mark+1),a  
38f8 3a 02 39			ld a, (.dmark+2)  
38fb 32 73 ee			ld (debug_mark+2),a  
38fe 18 03			jr .pastdmark  
3900 ..			.dmark: db "FB."  
3903 f1			.pastdmark: pop af  
3904			endm  
# End of macro DMARK
3904						CALLMONITOR 
3904 cd a0 14			call break_point_state  
3907				endm  
# End of macro CALLMONITOR
3907					endif 
3907			 
3907					FORTH_DSP_VALUEHL 
3907 cd 02 1d			call macro_dsp_valuehl 
390a				endm 
# End of macro FORTH_DSP_VALUEHL
390a			 
390a 7d					ld a, l 
390b fe 01				cp 1 
390d 20 05				jr nz, .fbn1 
390f 21 16 ed				ld hl, display_fb1 
3912 18 15				jr .fbset 
3914 fe 02		.fbn1:		cp 2 
3916 20 05				jr nz, .fbn2 
3918 21 d4 eb				ld hl, display_fb2 
391b 18 0c				jr .fbset 
391d fe 03		.fbn2:		cp 3 
391f 20 05				jr nz, .fbn3 
3921 21 75 ec				ld hl, display_fb3 
3924 18 03				jr .fbset 
3926			.fbn3:		 ; if invalid number select first 
3926 21 16 ed				ld hl, display_fb1 
3929 22 d2 eb		.fbset:		ld (display_fb_active), hl 
392c			 
392c					FORTH_DSP_POP 
392c cd ba 1d			call macro_forth_dsp_pop 
392f				endm 
# End of macro FORTH_DSP_POP
392f			 
392f					NEXTW 
392f c3 74 1e			jp macro_next 
3932				endm 
# End of macro NEXTW
3932			 
3932			 
3932			.EMIT: 
3932				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3932 1b				db WORD_SYS_CORE+7             
3933 83 39			dw .DOTH            
3935 05				db 4 + 1 
3936 .. 00			db "EMIT",0              
393b				endm 
# End of macro CWHEAD
393b			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
393b					; get value off TOS and display it 
393b			 
393b					if DEBUG_FORTH_WORDS_KEY 
393b						DMARK "EMT" 
393b f5				push af  
393c 3a 50 39			ld a, (.dmark)  
393f 32 71 ee			ld (debug_mark),a  
3942 3a 51 39			ld a, (.dmark+1)  
3945 32 72 ee			ld (debug_mark+1),a  
3948 3a 52 39			ld a, (.dmark+2)  
394b 32 73 ee			ld (debug_mark+2),a  
394e 18 03			jr .pastdmark  
3950 ..			.dmark: db "EMT"  
3953 f1			.pastdmark: pop af  
3954			endm  
# End of macro DMARK
3954						CALLMONITOR 
3954 cd a0 14			call break_point_state  
3957				endm  
# End of macro CALLMONITOR
3957					endif 
3957			 
3957					FORTH_DSP_VALUEHL 
3957 cd 02 1d			call macro_dsp_valuehl 
395a				endm 
# End of macro FORTH_DSP_VALUEHL
395a			 
395a 7d					ld a,l 
395b			 
395b					; TODO write to display 
395b			 
395b 32 d5 e5				ld (os_input), a 
395e 3e 00				ld a, 0 
3960 32 d6 e5				ld (os_input+1), a 
3963					 
3963 3a 40 eb				ld a, (f_cursor_ptr) 
3966 11 d5 e5				ld de, os_input 
3969 cd 85 0a				call str_at_display 
396c			 
396c			 
396c 3a 1e eb				ld a,(cli_autodisplay) 
396f fe 00				cp 0 
3971 28 03				jr z, .enoupdate 
3973 cd 95 0a						call update_display 
3976					.enoupdate: 
3976			 
3976 3a 40 eb				ld a, (f_cursor_ptr) 
3979 3c					inc a 
397a 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
397d			 
397d			 
397d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397d cd ba 1d			call macro_forth_dsp_pop 
3980				endm 
# End of macro FORTH_DSP_POP
3980			  
3980			 
3980					NEXTW 
3980 c3 74 1e			jp macro_next 
3983				endm 
# End of macro NEXTW
3983			.DOTH: 
3983				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3983 1c				db WORD_SYS_CORE+8             
3984 b3 39			dw .DOTF            
3986 03				db 2 + 1 
3987 .. 00			db ".-",0              
398a				endm 
# End of macro CWHEAD
398a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
398a					; get value off TOS and display it 
398a					if DEBUG_FORTH_WORDS_KEY 
398a						DMARK "DTD" 
398a f5				push af  
398b 3a 9f 39			ld a, (.dmark)  
398e 32 71 ee			ld (debug_mark),a  
3991 3a a0 39			ld a, (.dmark+1)  
3994 32 72 ee			ld (debug_mark+1),a  
3997 3a a1 39			ld a, (.dmark+2)  
399a 32 73 ee			ld (debug_mark+2),a  
399d 18 03			jr .pastdmark  
399f ..			.dmark: db "DTD"  
39a2 f1			.pastdmark: pop af  
39a3			endm  
# End of macro DMARK
39a3						CALLMONITOR 
39a3 cd a0 14			call break_point_state  
39a6				endm  
# End of macro CALLMONITOR
39a6					endif 
39a6 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
39a8 3e 00			ld a, 0 
39aa 32 1f eb			ld (cli_mvdot), a 
39ad c3 0a 3a			jp .dotgo 
39b0				NEXTW 
39b0 c3 74 1e			jp macro_next 
39b3				endm 
# End of macro NEXTW
39b3			.DOTF: 
39b3				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
39b3 1c				db WORD_SYS_CORE+8             
39b4 e1 39			dw .DOT            
39b6 03				db 2 + 1 
39b7 .. 00			db ".>",0              
39ba				endm 
# End of macro CWHEAD
39ba			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
39ba					; get value off TOS and display it 
39ba			        ; TODO BUG adds extra spaces 
39ba			        ; TODO BUG handle numerics? 
39ba					if DEBUG_FORTH_WORDS_KEY 
39ba						DMARK "DTC" 
39ba f5				push af  
39bb 3a cf 39			ld a, (.dmark)  
39be 32 71 ee			ld (debug_mark),a  
39c1 3a d0 39			ld a, (.dmark+1)  
39c4 32 72 ee			ld (debug_mark+1),a  
39c7 3a d1 39			ld a, (.dmark+2)  
39ca 32 73 ee			ld (debug_mark+2),a  
39cd 18 03			jr .pastdmark  
39cf ..			.dmark: db "DTC"  
39d2 f1			.pastdmark: pop af  
39d3			endm  
# End of macro DMARK
39d3						CALLMONITOR 
39d3 cd a0 14			call break_point_state  
39d6				endm  
# End of macro CALLMONITOR
39d6					endif 
39d6 3e 01			ld a, 1 
39d8 32 1f eb			ld (cli_mvdot), a 
39db c3 0a 3a			jp .dotgo 
39de				NEXTW 
39de c3 74 1e			jp macro_next 
39e1				endm 
# End of macro NEXTW
39e1			 
39e1			.DOT: 
39e1				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
39e1 1c				db WORD_SYS_CORE+8             
39e2 6d 3a			dw .CLS            
39e4 02				db 1 + 1 
39e5 .. 00			db ".",0              
39e7				endm 
# End of macro CWHEAD
39e7			        ; | . ( u -- ) Display TOS | DONE 
39e7					; get value off TOS and display it 
39e7			 
39e7					if DEBUG_FORTH_WORDS_KEY 
39e7						DMARK "DOT" 
39e7 f5				push af  
39e8 3a fc 39			ld a, (.dmark)  
39eb 32 71 ee			ld (debug_mark),a  
39ee 3a fd 39			ld a, (.dmark+1)  
39f1 32 72 ee			ld (debug_mark+1),a  
39f4 3a fe 39			ld a, (.dmark+2)  
39f7 32 73 ee			ld (debug_mark+2),a  
39fa 18 03			jr .pastdmark  
39fc ..			.dmark: db "DOT"  
39ff f1			.pastdmark: pop af  
3a00			endm  
# End of macro DMARK
3a00						CALLMONITOR 
3a00 cd a0 14			call break_point_state  
3a03				endm  
# End of macro CALLMONITOR
3a03					endif 
3a03 3e 00			ld a, 0 
3a05 32 1f eb			ld (cli_mvdot), a 
3a08 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3a0a				 
3a0a			 
3a0a			.dotgo: 
3a0a			 
3a0a			; move up type to on stack for parserv5 
3a0a					FORTH_DSP 
3a0a cd c8 1c			call macro_forth_dsp 
3a0d				endm 
# End of macro FORTH_DSP
3a0d				;FORTH_DSP_VALUE  
3a0d			 
3a0d			if DEBUG_FORTH_DOT 
3a0d				DMARK "DOT" 
3a0d				CALLMONITOR 
3a0d			endif	 
3a0d			;		.print: 
3a0d			 
3a0d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3a0e 23				inc hl   ; position to the actual value 
3a0f fe 01			cp DS_TYPE_STR 
3a11 20 06			jr nz, .dotnum1  
3a13			 
3a13			; display string 
3a13				FORTH_DSP_VALUE  
3a13 cd eb 1c			call macro_forth_dsp_value 
3a16				endm 
# End of macro FORTH_DSP_VALUE
3a16 eb				ex de,hl 
3a17 18 11			jr .dotwrite 
3a19			 
3a19			.dotnum1: 
3a19 fe 02			cp DS_TYPE_INUM 
3a1b 20 0c			jr nz, .dotflot 
3a1d			 
3a1d			 
3a1d			; display number 
3a1d			 
3a1d			;	push hl 
3a1d			;	call clear_display 
3a1d			;	pop hl 
3a1d			 
3a1d 5e				ld e, (hl) 
3a1e 23				inc hl 
3a1f 56				ld d, (hl) 
3a20 21 d7 e3			ld hl, scratch 
3a23			if DEBUG_FORTH_DOT 
3a23				DMARK "DT1" 
3a23				CALLMONITOR 
3a23			endif	 
3a23			 
3a23 cd ac 10			call uitoa_16 
3a26 eb				ex de,hl 
3a27			 
3a27			if DEBUG_FORTH_DOT 
3a27				DMARK "DT2" 
3a27				CALLMONITOR 
3a27			endif	 
3a27			 
3a27			;	ld de, os_word_scratch 
3a27 18 01			jr .dotwrite 
3a29			 
3a29 00			.dotflot:   nop 
3a2a			; TODO print floating point number 
3a2a			 
3a2a			.dotwrite:		 
3a2a			 
3a2a					; if c is set then set all '-' to spaces 
3a2a					; need to also take into account .>  
3a2a			 
3a2a 3e 01				ld a, 1 
3a2c b9					cp c 
3a2d 20 13				jr nz, .nodashswap 
3a2f			 
3a2f					; DE has the string to write, working with HL 
3a2f			 
3a2f 06 ff				ld b, 255 
3a31 d5					push de 
3a32 e1					pop hl 
3a33			 
3a33			if DEBUG_FORTH_DOT 
3a33				DMARK "DT-" 
3a33				CALLMONITOR 
3a33			endif	 
3a33 7e			.dashscan:	ld a, (hl) 
3a34 fe 00				cp 0 
3a36 28 0a				jr z, .nodashswap 
3a38 fe 2d				cp '-' 
3a3a 20 03				jr nz, .dashskip 
3a3c 3e 20				ld a, ' ' 
3a3e 77					ld (hl), a 
3a3f 23			.dashskip:	inc hl 
3a40			if DEBUG_FORTH_DOT 
3a40				DMARK "D-2" 
3a40				CALLMONITOR 
3a40			endif	 
3a40 10 f1				djnz .dashscan 
3a42			 
3a42			if DEBUG_FORTH_DOT 
3a42				DMARK "D-1" 
3a42				CALLMONITOR 
3a42			endif	 
3a42			 
3a42			.nodashswap: 
3a42			 
3a42 e5					push hl   ; save string start in case we need to advance print 
3a43			 
3a43 3a 40 eb				ld a, (f_cursor_ptr) 
3a46 cd 85 0a				call str_at_display 
3a49 3a 1e eb				ld a,(cli_autodisplay) 
3a4c fe 00				cp 0 
3a4e 28 03				jr z, .noupdate 
3a50 cd 95 0a						call update_display 
3a53					.noupdate: 
3a53			 
3a53			 
3a53					; see if we need to advance the print position 
3a53			 
3a53 e1					pop hl   ; get back string 
3a54			 
3a54 3a 1f eb				ld a, (cli_mvdot) 
3a57			if DEBUG_FORTH_DOT 
3a57					ld e,a 
3a57				DMARK "D>1" 
3a57				CALLMONITOR 
3a57			endif	 
3a57 fe 00				cp 0 
3a59 28 0c				jr z, .noadv 
3a5b					; yes, lets advance the print position 
3a5b 3e 00				ld a, 0 
3a5d cd 08 11				call strlent 
3a60 3a 40 eb				ld a, (f_cursor_ptr) 
3a63 85					add a,l 
3a64					;call addatohl 
3a64					;ld a, l 
3a64 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
3a67			 
3a67			if DEBUG_FORTH_DOT 
3a67				DMARK "D->" 
3a67				CALLMONITOR 
3a67			endif	 
3a67			 
3a67			.noadv:	 
3a67			 
3a67					if DEBUG_FORTH_DOT_WAIT 
3a67							call next_page_prompt 
3a67					endif	 
3a67			; TODO this pop off the stack causes a crash. i dont know why 
3a67			 
3a67			 
3a67			if DEBUG_FORTH_DOT 
3a67				DMARK "DTh" 
3a67				CALLMONITOR 
3a67			endif	 
3a67			 
3a67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a67 cd ba 1d			call macro_forth_dsp_pop 
3a6a				endm 
# End of macro FORTH_DSP_POP
3a6a			 
3a6a			if DEBUG_FORTH_DOT 
3a6a				DMARK "DTi" 
3a6a				CALLMONITOR 
3a6a			endif	 
3a6a			 
3a6a			 
3a6a					NEXTW 
3a6a c3 74 1e			jp macro_next 
3a6d				endm 
# End of macro NEXTW
3a6d			 
3a6d			.CLS: 
3a6d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3a6d 35				db WORD_SYS_CORE+33             
3a6e 9a 3a			dw .DRAW            
3a70 04				db 3 + 1 
3a71 .. 00			db "CLS",0              
3a75				endm 
# End of macro CWHEAD
3a75			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3a75					if DEBUG_FORTH_WORDS_KEY 
3a75						DMARK "CLS" 
3a75 f5				push af  
3a76 3a 8a 3a			ld a, (.dmark)  
3a79 32 71 ee			ld (debug_mark),a  
3a7c 3a 8b 3a			ld a, (.dmark+1)  
3a7f 32 72 ee			ld (debug_mark+1),a  
3a82 3a 8c 3a			ld a, (.dmark+2)  
3a85 32 73 ee			ld (debug_mark+2),a  
3a88 18 03			jr .pastdmark  
3a8a ..			.dmark: db "CLS"  
3a8d f1			.pastdmark: pop af  
3a8e			endm  
# End of macro DMARK
3a8e						CALLMONITOR 
3a8e cd a0 14			call break_point_state  
3a91				endm  
# End of macro CALLMONITOR
3a91					endif 
3a91 cd 72 0a				call clear_display 
3a94 c3 a8 3b				jp .home		; and home cursor 
3a97					NEXTW 
3a97 c3 74 1e			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			 
3a9a			.DRAW: 
3a9a				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3a9a 36				db WORD_SYS_CORE+34             
3a9b c5 3a			dw .DUMP            
3a9d 05				db 4 + 1 
3a9e .. 00			db "DRAW",0              
3aa3				endm 
# End of macro CWHEAD
3aa3			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3aa3					if DEBUG_FORTH_WORDS_KEY 
3aa3						DMARK "DRW" 
3aa3 f5				push af  
3aa4 3a b8 3a			ld a, (.dmark)  
3aa7 32 71 ee			ld (debug_mark),a  
3aaa 3a b9 3a			ld a, (.dmark+1)  
3aad 32 72 ee			ld (debug_mark+1),a  
3ab0 3a ba 3a			ld a, (.dmark+2)  
3ab3 32 73 ee			ld (debug_mark+2),a  
3ab6 18 03			jr .pastdmark  
3ab8 ..			.dmark: db "DRW"  
3abb f1			.pastdmark: pop af  
3abc			endm  
# End of macro DMARK
3abc						CALLMONITOR 
3abc cd a0 14			call break_point_state  
3abf				endm  
# End of macro CALLMONITOR
3abf					endif 
3abf cd 95 0a				call update_display 
3ac2					NEXTW 
3ac2 c3 74 1e			jp macro_next 
3ac5				endm 
# End of macro NEXTW
3ac5			 
3ac5			.DUMP: 
3ac5				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ac5 37				db WORD_SYS_CORE+35             
3ac6 fd 3a			dw .CDUMP            
3ac8 05				db 4 + 1 
3ac9 .. 00			db "DUMP",0              
3ace				endm 
# End of macro CWHEAD
3ace			; | DUMP ( x -- ) With address x display dump   | DONE 
3ace			; TODO pop address to use off of the stack 
3ace					if DEBUG_FORTH_WORDS_KEY 
3ace						DMARK "DUM" 
3ace f5				push af  
3acf 3a e3 3a			ld a, (.dmark)  
3ad2 32 71 ee			ld (debug_mark),a  
3ad5 3a e4 3a			ld a, (.dmark+1)  
3ad8 32 72 ee			ld (debug_mark+1),a  
3adb 3a e5 3a			ld a, (.dmark+2)  
3ade 32 73 ee			ld (debug_mark+2),a  
3ae1 18 03			jr .pastdmark  
3ae3 ..			.dmark: db "DUM"  
3ae6 f1			.pastdmark: pop af  
3ae7			endm  
# End of macro DMARK
3ae7						CALLMONITOR 
3ae7 cd a0 14			call break_point_state  
3aea				endm  
# End of macro CALLMONITOR
3aea					endif 
3aea cd 72 0a				call clear_display 
3aed			 
3aed					; get address 
3aed			 
3aed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aed cd 02 1d			call macro_dsp_valuehl 
3af0				endm 
# End of macro FORTH_DSP_VALUEHL
3af0				 
3af0					; save it for cdump 
3af0			 
3af0 22 fa e6				ld (os_cur_ptr),hl 
3af3			 
3af3					; destroy value TOS 
3af3			 
3af3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af3 cd ba 1d			call macro_forth_dsp_pop 
3af6				endm 
# End of macro FORTH_DSP_POP
3af6			 
3af6 cd 8b 19				call dumpcont	; skip old style of param parsing	 
3af9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3afa					NEXTW 
3afa c3 74 1e			jp macro_next 
3afd				endm 
# End of macro NEXTW
3afd			.CDUMP: 
3afd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3afd 38				db WORD_SYS_CORE+36             
3afe 2d 3b			dw .DAT            
3b00 06				db 5 + 1 
3b01 .. 00			db "CDUMP",0              
3b07				endm 
# End of macro CWHEAD
3b07			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3b07					if DEBUG_FORTH_WORDS_KEY 
3b07						DMARK "CDP" 
3b07 f5				push af  
3b08 3a 1c 3b			ld a, (.dmark)  
3b0b 32 71 ee			ld (debug_mark),a  
3b0e 3a 1d 3b			ld a, (.dmark+1)  
3b11 32 72 ee			ld (debug_mark+1),a  
3b14 3a 1e 3b			ld a, (.dmark+2)  
3b17 32 73 ee			ld (debug_mark+2),a  
3b1a 18 03			jr .pastdmark  
3b1c ..			.dmark: db "CDP"  
3b1f f1			.pastdmark: pop af  
3b20			endm  
# End of macro DMARK
3b20						CALLMONITOR 
3b20 cd a0 14			call break_point_state  
3b23				endm  
# End of macro CALLMONITOR
3b23					endif 
3b23 cd 72 0a				call clear_display 
3b26 cd 8b 19				call dumpcont	 
3b29 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3b2a					NEXTW 
3b2a c3 74 1e			jp macro_next 
3b2d				endm 
# End of macro NEXTW
3b2d			 
3b2d			 
3b2d			 
3b2d			 
3b2d			.DAT: 
3b2d				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3b2d 3d				db WORD_SYS_CORE+41             
3b2e 83 3b			dw .HOME            
3b30 03				db 2 + 1 
3b31 .. 00			db "AT",0              
3b34				endm 
# End of macro CWHEAD
3b34			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3b34					if DEBUG_FORTH_WORDS_KEY 
3b34						DMARK "AT." 
3b34 f5				push af  
3b35 3a 49 3b			ld a, (.dmark)  
3b38 32 71 ee			ld (debug_mark),a  
3b3b 3a 4a 3b			ld a, (.dmark+1)  
3b3e 32 72 ee			ld (debug_mark+1),a  
3b41 3a 4b 3b			ld a, (.dmark+2)  
3b44 32 73 ee			ld (debug_mark+2),a  
3b47 18 03			jr .pastdmark  
3b49 ..			.dmark: db "AT."  
3b4c f1			.pastdmark: pop af  
3b4d			endm  
# End of macro DMARK
3b4d						CALLMONITOR 
3b4d cd a0 14			call break_point_state  
3b50				endm  
# End of macro CALLMONITOR
3b50					endif 
3b50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b50 cd 02 1d			call macro_dsp_valuehl 
3b53				endm 
# End of macro FORTH_DSP_VALUEHL
3b53			 
3b53			 
3b53					; TODO save cursor row 
3b53 7d					ld a,l 
3b54 fe 02				cp 2 
3b56 20 04				jr nz, .crow3 
3b58 3e 28				ld a, display_row_2 
3b5a 18 12				jr .ccol1 
3b5c fe 03		.crow3:		cp 3 
3b5e 20 04				jr nz, .crow4 
3b60 3e 50				ld a, display_row_3 
3b62 18 0a				jr .ccol1 
3b64 fe 04		.crow4:		cp 4 
3b66 20 04				jr nz, .crow1 
3b68 3e 78				ld a, display_row_4 
3b6a 18 02				jr .ccol1 
3b6c 3e 00		.crow1:		ld a,display_row_1 
3b6e f5			.ccol1:		push af			; got row offset 
3b6f 6f					ld l,a 
3b70 26 00				ld h,0 
3b72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b72 cd ba 1d			call macro_forth_dsp_pop 
3b75				endm 
# End of macro FORTH_DSP_POP
3b75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b75 cd 02 1d			call macro_dsp_valuehl 
3b78				endm 
# End of macro FORTH_DSP_VALUEHL
3b78					; TODO save cursor col 
3b78 f1					pop af 
3b79 85					add l		; add col offset 
3b7a 32 40 eb				ld (f_cursor_ptr), a 
3b7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7d cd ba 1d			call macro_forth_dsp_pop 
3b80				endm 
# End of macro FORTH_DSP_POP
3b80			 
3b80					; calculate  
3b80			 
3b80					NEXTW 
3b80 c3 74 1e			jp macro_next 
3b83				endm 
# End of macro NEXTW
3b83			 
3b83			 
3b83			.HOME: 
3b83				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3b83 41				db WORD_SYS_CORE+45             
3b84 b0 3b			dw .SPACE            
3b86 05				db 4 + 1 
3b87 .. 00			db "HOME",0              
3b8c				endm 
# End of macro CWHEAD
3b8c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3b8c					if DEBUG_FORTH_WORDS_KEY 
3b8c						DMARK "HOM" 
3b8c f5				push af  
3b8d 3a a1 3b			ld a, (.dmark)  
3b90 32 71 ee			ld (debug_mark),a  
3b93 3a a2 3b			ld a, (.dmark+1)  
3b96 32 72 ee			ld (debug_mark+1),a  
3b99 3a a3 3b			ld a, (.dmark+2)  
3b9c 32 73 ee			ld (debug_mark+2),a  
3b9f 18 03			jr .pastdmark  
3ba1 ..			.dmark: db "HOM"  
3ba4 f1			.pastdmark: pop af  
3ba5			endm  
# End of macro DMARK
3ba5						CALLMONITOR 
3ba5 cd a0 14			call break_point_state  
3ba8				endm  
# End of macro CALLMONITOR
3ba8					endif 
3ba8 3e 00		.home:		ld a, 0		; and home cursor 
3baa 32 40 eb				ld (f_cursor_ptr), a 
3bad					NEXTW 
3bad c3 74 1e			jp macro_next 
3bb0				endm 
# End of macro NEXTW
3bb0			 
3bb0			 
3bb0			.SPACE: 
3bb0				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3bb0 46				db WORD_SYS_CORE+50             
3bb1 de 3b			dw .SPACES            
3bb3 03				db 2 + 1 
3bb4 .. 00			db "BL",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3bb7					if DEBUG_FORTH_WORDS_KEY 
3bb7						DMARK "BL." 
3bb7 f5				push af  
3bb8 3a cc 3b			ld a, (.dmark)  
3bbb 32 71 ee			ld (debug_mark),a  
3bbe 3a cd 3b			ld a, (.dmark+1)  
3bc1 32 72 ee			ld (debug_mark+1),a  
3bc4 3a ce 3b			ld a, (.dmark+2)  
3bc7 32 73 ee			ld (debug_mark+2),a  
3bca 18 03			jr .pastdmark  
3bcc ..			.dmark: db "BL."  
3bcf f1			.pastdmark: pop af  
3bd0			endm  
# End of macro DMARK
3bd0						CALLMONITOR 
3bd0 cd a0 14			call break_point_state  
3bd3				endm  
# End of macro CALLMONITOR
3bd3					endif 
3bd3 21 dc 3b				ld hl, .blstr 
3bd6 cd 79 1b				call forth_push_str 
3bd9					 
3bd9				       NEXTW 
3bd9 c3 74 1e			jp macro_next 
3bdc				endm 
# End of macro NEXTW
3bdc			 
3bdc .. 00		.blstr: db " ", 0 
3bde			 
3bde			.SPACES: 
3bde				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3bde 47				db WORD_SYS_CORE+51             
3bdf 79 3c			dw .SCROLL            
3be1 07				db 6 + 1 
3be2 .. 00			db "SPACES",0              
3be9				endm 
# End of macro CWHEAD
3be9			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3be9					if DEBUG_FORTH_WORDS_KEY 
3be9						DMARK "SPS" 
3be9 f5				push af  
3bea 3a fe 3b			ld a, (.dmark)  
3bed 32 71 ee			ld (debug_mark),a  
3bf0 3a ff 3b			ld a, (.dmark+1)  
3bf3 32 72 ee			ld (debug_mark+1),a  
3bf6 3a 00 3c			ld a, (.dmark+2)  
3bf9 32 73 ee			ld (debug_mark+2),a  
3bfc 18 03			jr .pastdmark  
3bfe ..			.dmark: db "SPS"  
3c01 f1			.pastdmark: pop af  
3c02			endm  
# End of macro DMARK
3c02						CALLMONITOR 
3c02 cd a0 14			call break_point_state  
3c05				endm  
# End of macro CALLMONITOR
3c05					endif 
3c05			 
3c05			 
3c05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c05 cd 02 1d			call macro_dsp_valuehl 
3c08				endm 
# End of macro FORTH_DSP_VALUEHL
3c08			 
3c08			;		push hl    ; u 
3c08					if DEBUG_FORTH_WORDS 
3c08						DMARK "SPA" 
3c08 f5				push af  
3c09 3a 1d 3c			ld a, (.dmark)  
3c0c 32 71 ee			ld (debug_mark),a  
3c0f 3a 1e 3c			ld a, (.dmark+1)  
3c12 32 72 ee			ld (debug_mark+1),a  
3c15 3a 1f 3c			ld a, (.dmark+2)  
3c18 32 73 ee			ld (debug_mark+2),a  
3c1b 18 03			jr .pastdmark  
3c1d ..			.dmark: db "SPA"  
3c20 f1			.pastdmark: pop af  
3c21			endm  
# End of macro DMARK
3c21						CALLMONITOR 
3c21 cd a0 14			call break_point_state  
3c24				endm  
# End of macro CALLMONITOR
3c24					endif 
3c24			 
3c24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c24 cd ba 1d			call macro_forth_dsp_pop 
3c27				endm 
# End of macro FORTH_DSP_POP
3c27			;		pop hl 
3c27 4d					ld c, l 
3c28 06 00				ld b, 0 
3c2a 21 d7 e3				ld hl, scratch  
3c2d			 
3c2d					if DEBUG_FORTH_WORDS 
3c2d						DMARK "SP2" 
3c2d f5				push af  
3c2e 3a 42 3c			ld a, (.dmark)  
3c31 32 71 ee			ld (debug_mark),a  
3c34 3a 43 3c			ld a, (.dmark+1)  
3c37 32 72 ee			ld (debug_mark+1),a  
3c3a 3a 44 3c			ld a, (.dmark+2)  
3c3d 32 73 ee			ld (debug_mark+2),a  
3c40 18 03			jr .pastdmark  
3c42 ..			.dmark: db "SP2"  
3c45 f1			.pastdmark: pop af  
3c46			endm  
# End of macro DMARK
3c46						CALLMONITOR 
3c46 cd a0 14			call break_point_state  
3c49				endm  
# End of macro CALLMONITOR
3c49					endif 
3c49 3e 20				ld a, ' ' 
3c4b c5			.spaces1:	push bc 
3c4c 77					ld (hl),a 
3c4d 23					inc hl 
3c4e c1					pop bc 
3c4f 10 fa				djnz .spaces1 
3c51 3e 00				ld a,0 
3c53 77					ld (hl),a 
3c54 21 d7 e3				ld hl, scratch 
3c57					if DEBUG_FORTH_WORDS 
3c57						DMARK "SP3" 
3c57 f5				push af  
3c58 3a 6c 3c			ld a, (.dmark)  
3c5b 32 71 ee			ld (debug_mark),a  
3c5e 3a 6d 3c			ld a, (.dmark+1)  
3c61 32 72 ee			ld (debug_mark+1),a  
3c64 3a 6e 3c			ld a, (.dmark+2)  
3c67 32 73 ee			ld (debug_mark+2),a  
3c6a 18 03			jr .pastdmark  
3c6c ..			.dmark: db "SP3"  
3c6f f1			.pastdmark: pop af  
3c70			endm  
# End of macro DMARK
3c70						CALLMONITOR 
3c70 cd a0 14			call break_point_state  
3c73				endm  
# End of macro CALLMONITOR
3c73					endif 
3c73 cd 74 1c				call forth_apush 
3c76			 
3c76				       NEXTW 
3c76 c3 74 1e			jp macro_next 
3c79				endm 
# End of macro NEXTW
3c79			 
3c79			 
3c79			 
3c79			.SCROLL: 
3c79				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3c79 53				db WORD_SYS_CORE+63             
3c7a a6 3c			dw .SCROLLD            
3c7c 07				db 6 + 1 
3c7d .. 00			db "SCROLL",0              
3c84				endm 
# End of macro CWHEAD
3c84			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3c84					if DEBUG_FORTH_WORDS_KEY 
3c84						DMARK "SCR" 
3c84 f5				push af  
3c85 3a 99 3c			ld a, (.dmark)  
3c88 32 71 ee			ld (debug_mark),a  
3c8b 3a 9a 3c			ld a, (.dmark+1)  
3c8e 32 72 ee			ld (debug_mark+1),a  
3c91 3a 9b 3c			ld a, (.dmark+2)  
3c94 32 73 ee			ld (debug_mark+2),a  
3c97 18 03			jr .pastdmark  
3c99 ..			.dmark: db "SCR"  
3c9c f1			.pastdmark: pop af  
3c9d			endm  
# End of macro DMARK
3c9d						CALLMONITOR 
3c9d cd a0 14			call break_point_state  
3ca0				endm  
# End of macro CALLMONITOR
3ca0					endif 
3ca0			 
3ca0 cd 34 0a			call scroll_up 
3ca3			;	call update_display 
3ca3			 
3ca3					NEXTW 
3ca3 c3 74 1e			jp macro_next 
3ca6				endm 
# End of macro NEXTW
3ca6			 
3ca6			 
3ca6			 
3ca6			;		; get dir 
3ca6			; 
3ca6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca6			; 
3ca6			;		push hl 
3ca6			; 
3ca6			;		; destroy value TOS 
3ca6			; 
3ca6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca6			; 
3ca6			;		; get count 
3ca6			; 
3ca6			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca6			; 
3ca6			;		push hl 
3ca6			; 
3ca6			;		; destroy value TOS 
3ca6			; 
3ca6			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca6			; 
3ca6			;		; one value on hl get other one back 
3ca6			; 
3ca6			;		pop bc    ; count 
3ca6			; 
3ca6			;		pop de   ; dir 
3ca6			; 
3ca6			; 
3ca6			;		ld b, c 
3ca6			; 
3ca6			;.scrolldir:     push bc 
3ca6			;		push de 
3ca6			; 
3ca6			;		ld a, 0 
3ca6			;		cp e 
3ca6			;		jr z, .scrollup  
3ca6			;		call scroll_down 
3ca6			;		jr .scrollnext 
3ca6			;.scrollup:	call scroll_up 
3ca6			; 
3ca6			;		 
3ca6			;.scrollnext: 
3ca6			;		pop de 
3ca6			;		pop bc 
3ca6			;		djnz .scrolldir 
3ca6			; 
3ca6			; 
3ca6			; 
3ca6			; 
3ca6			; 
3ca6			;		NEXTW 
3ca6			 
3ca6			.SCROLLD: 
3ca6				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ca6 53				db WORD_SYS_CORE+63             
3ca7 d4 3c			dw .ATQ            
3ca9 08				db 7 + 1 
3caa .. 00			db "SCROLLD",0              
3cb2				endm 
# End of macro CWHEAD
3cb2			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3cb2					if DEBUG_FORTH_WORDS_KEY 
3cb2						DMARK "SCD" 
3cb2 f5				push af  
3cb3 3a c7 3c			ld a, (.dmark)  
3cb6 32 71 ee			ld (debug_mark),a  
3cb9 3a c8 3c			ld a, (.dmark+1)  
3cbc 32 72 ee			ld (debug_mark+1),a  
3cbf 3a c9 3c			ld a, (.dmark+2)  
3cc2 32 73 ee			ld (debug_mark+2),a  
3cc5 18 03			jr .pastdmark  
3cc7 ..			.dmark: db "SCD"  
3cca f1			.pastdmark: pop af  
3ccb			endm  
# End of macro DMARK
3ccb						CALLMONITOR 
3ccb cd a0 14			call break_point_state  
3cce				endm  
# End of macro CALLMONITOR
3cce					endif 
3cce			 
3cce cd 58 0a			call scroll_down 
3cd1			;	call update_display 
3cd1			 
3cd1					NEXTW 
3cd1 c3 74 1e			jp macro_next 
3cd4				endm 
# End of macro NEXTW
3cd4			 
3cd4			 
3cd4			.ATQ: 
3cd4				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3cd4 62				db WORD_SYS_CORE+78             
3cd5 32 3d			dw .AUTODSP            
3cd7 04				db 3 + 1 
3cd8 .. 00			db "AT@",0              
3cdc				endm 
# End of macro CWHEAD
3cdc			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3cdc					if DEBUG_FORTH_WORDS_KEY 
3cdc						DMARK "ATA" 
3cdc f5				push af  
3cdd 3a f1 3c			ld a, (.dmark)  
3ce0 32 71 ee			ld (debug_mark),a  
3ce3 3a f2 3c			ld a, (.dmark+1)  
3ce6 32 72 ee			ld (debug_mark+1),a  
3ce9 3a f3 3c			ld a, (.dmark+2)  
3cec 32 73 ee			ld (debug_mark+2),a  
3cef 18 03			jr .pastdmark  
3cf1 ..			.dmark: db "ATA"  
3cf4 f1			.pastdmark: pop af  
3cf5			endm  
# End of macro DMARK
3cf5						CALLMONITOR 
3cf5 cd a0 14			call break_point_state  
3cf8				endm  
# End of macro CALLMONITOR
3cf8					endif 
3cf8			 
3cf8			 
3cf8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cf8 cd 02 1d			call macro_dsp_valuehl 
3cfb				endm 
# End of macro FORTH_DSP_VALUEHL
3cfb			 
3cfb					; TODO save cursor row 
3cfb 7d					ld a,l 
3cfc fe 02				cp 2 
3cfe 20 04				jr nz, .crow3aq 
3d00 3e 28				ld a, display_row_2 
3d02 18 12				jr .ccol1aq 
3d04 fe 03		.crow3aq:		cp 3 
3d06 20 04				jr nz, .crow4aq 
3d08 3e 50				ld a, display_row_3 
3d0a 18 0a				jr .ccol1aq 
3d0c fe 04		.crow4aq:		cp 4 
3d0e 20 04				jr nz, .crow1aq 
3d10 3e 78				ld a, display_row_4 
3d12 18 02				jr .ccol1aq 
3d14 3e 00		.crow1aq:		ld a,display_row_1 
3d16 f5			.ccol1aq:		push af			; got row offset 
3d17 6f					ld l,a 
3d18 26 00				ld h,0 
3d1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d1a cd ba 1d			call macro_forth_dsp_pop 
3d1d				endm 
# End of macro FORTH_DSP_POP
3d1d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d1d cd 02 1d			call macro_dsp_valuehl 
3d20				endm 
# End of macro FORTH_DSP_VALUEHL
3d20					; TODO save cursor col 
3d20 f1					pop af 
3d21 85					add l		; add col offset 
3d22			 
3d22					; add current frame buffer address 
3d22 2a d2 eb				ld hl, (display_fb_active) 
3d25 cd 9f 0c				call addatohl 
3d28			 
3d28			 
3d28			 
3d28			 
3d28					; get char frame buffer location offset in hl 
3d28			 
3d28 7e					ld a,(hl) 
3d29 26 00				ld h, 0 
3d2b 6f					ld l, a 
3d2c			 
3d2c cd 0b 1b				call forth_push_numhl 
3d2f			 
3d2f			 
3d2f					NEXTW 
3d2f c3 74 1e			jp macro_next 
3d32				endm 
# End of macro NEXTW
3d32			 
3d32			.AUTODSP: 
3d32				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3d32 63				db WORD_SYS_CORE+79             
3d33 48 3d			dw .MENU            
3d35 05				db 4 + 1 
3d36 .. 00			db "ADSP",0              
3d3b				endm 
# End of macro CWHEAD
3d3b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3d3b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3d3b			 
3d3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d3b cd 02 1d			call macro_dsp_valuehl 
3d3e				endm 
# End of macro FORTH_DSP_VALUEHL
3d3e			 
3d3e			;		push hl 
3d3e			 
3d3e					; destroy value TOS 
3d3e			 
3d3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3e cd ba 1d			call macro_forth_dsp_pop 
3d41				endm 
# End of macro FORTH_DSP_POP
3d41			 
3d41			;		pop hl 
3d41			 
3d41 7d					ld a,l 
3d42 32 1e eb				ld (cli_autodisplay), a 
3d45				       NEXTW 
3d45 c3 74 1e			jp macro_next 
3d48				endm 
# End of macro NEXTW
3d48			 
3d48			.MENU: 
3d48				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3d48 70				db WORD_SYS_CORE+92             
3d49 f1 3d			dw .ENDDISPLAY            
3d4b 05				db 4 + 1 
3d4c .. 00			db "MENU",0              
3d51				endm 
# End of macro CWHEAD
3d51			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3d51			 
3d51			;		; get number of items on the stack 
3d51			; 
3d51				 
3d51					FORTH_DSP_VALUEHL 
3d51 cd 02 1d			call macro_dsp_valuehl 
3d54				endm 
# End of macro FORTH_DSP_VALUEHL
3d54				 
3d54					if DEBUG_FORTH_WORDS_KEY 
3d54						DMARK "MNU" 
3d54 f5				push af  
3d55 3a 69 3d			ld a, (.dmark)  
3d58 32 71 ee			ld (debug_mark),a  
3d5b 3a 6a 3d			ld a, (.dmark+1)  
3d5e 32 72 ee			ld (debug_mark+1),a  
3d61 3a 6b 3d			ld a, (.dmark+2)  
3d64 32 73 ee			ld (debug_mark+2),a  
3d67 18 03			jr .pastdmark  
3d69 ..			.dmark: db "MNU"  
3d6c f1			.pastdmark: pop af  
3d6d			endm  
# End of macro DMARK
3d6d						CALLMONITOR 
3d6d cd a0 14			call break_point_state  
3d70				endm  
# End of macro CALLMONITOR
3d70					endif 
3d70			 
3d70 45					ld b, l	 
3d71 05					dec b 
3d72			 
3d72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d72 cd ba 1d			call macro_forth_dsp_pop 
3d75				endm 
# End of macro FORTH_DSP_POP
3d75			 
3d75			 
3d75					; go directly through the stack to pluck out the string pointers and build an array 
3d75			 
3d75			;		FORTH_DSP 
3d75			 
3d75					; hl contains top most stack item 
3d75				 
3d75 11 d7 e3				ld de, scratch 
3d78			 
3d78			.mbuild: 
3d78			 
3d78					FORTH_DSP_VALUEHL 
3d78 cd 02 1d			call macro_dsp_valuehl 
3d7b				endm 
# End of macro FORTH_DSP_VALUEHL
3d7b			 
3d7b					if DEBUG_FORTH_WORDS 
3d7b						DMARK "MN3" 
3d7b f5				push af  
3d7c 3a 90 3d			ld a, (.dmark)  
3d7f 32 71 ee			ld (debug_mark),a  
3d82 3a 91 3d			ld a, (.dmark+1)  
3d85 32 72 ee			ld (debug_mark+1),a  
3d88 3a 92 3d			ld a, (.dmark+2)  
3d8b 32 73 ee			ld (debug_mark+2),a  
3d8e 18 03			jr .pastdmark  
3d90 ..			.dmark: db "MN3"  
3d93 f1			.pastdmark: pop af  
3d94			endm  
# End of macro DMARK
3d94						CALLMONITOR 
3d94 cd a0 14			call break_point_state  
3d97				endm  
# End of macro CALLMONITOR
3d97					endif 
3d97 eb					ex de, hl 
3d98 73					ld (hl), e 
3d99 23					inc hl 
3d9a 72					ld (hl), d 
3d9b 23					inc hl 
3d9c eb					ex de, hl 
3d9d			 
3d9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d9d cd ba 1d			call macro_forth_dsp_pop 
3da0				endm 
# End of macro FORTH_DSP_POP
3da0			 
3da0 10 d6				djnz .mbuild 
3da2			 
3da2					; done add term 
3da2			 
3da2 eb					ex de, hl 
3da3 36 00				ld (hl), 0 
3da5 23					inc hl 
3da6 36 00				ld (hl), 0 
3da8			 
3da8				 
3da8					 
3da8 21 d7 e3				ld hl, scratch 
3dab			 
3dab					if DEBUG_FORTH_WORDS 
3dab						DMARK "MNx" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 71 ee			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 72 ee			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 73 ee			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "MNx"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd a0 14			call break_point_state  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7			 
3dc7			 
3dc7			 
3dc7 3e 00				ld a, 0 
3dc9 cd a3 0a				call menu 
3dcc			 
3dcc			 
3dcc 6f					ld l, a 
3dcd 26 00				ld h, 0 
3dcf			 
3dcf					if DEBUG_FORTH_WORDS 
3dcf						DMARK "MNr" 
3dcf f5				push af  
3dd0 3a e4 3d			ld a, (.dmark)  
3dd3 32 71 ee			ld (debug_mark),a  
3dd6 3a e5 3d			ld a, (.dmark+1)  
3dd9 32 72 ee			ld (debug_mark+1),a  
3ddc 3a e6 3d			ld a, (.dmark+2)  
3ddf 32 73 ee			ld (debug_mark+2),a  
3de2 18 03			jr .pastdmark  
3de4 ..			.dmark: db "MNr"  
3de7 f1			.pastdmark: pop af  
3de8			endm  
# End of macro DMARK
3de8						CALLMONITOR 
3de8 cd a0 14			call break_point_state  
3deb				endm  
# End of macro CALLMONITOR
3deb					endif 
3deb			 
3deb cd 0b 1b				call forth_push_numhl 
3dee			 
3dee			 
3dee			 
3dee			 
3dee				       NEXTW 
3dee c3 74 1e			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1			 
3df1			.ENDDISPLAY: 
3df1			 
3df1			; eof 
# End of file forth_words_display.asm
3df1			include "forth_words_str.asm" 
3df1			 
3df1			; | ## String Words 
3df1			 
3df1			.PTR:   
3df1			 
3df1				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3df1 48				db WORD_SYS_CORE+52             
3df2 1e 3e			dw .STYPE            
3df4 04				db 3 + 1 
3df5 .. 00			db "PTR",0              
3df9				endm 
# End of macro CWHEAD
3df9			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3df9			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3df9			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3df9			 
3df9					if DEBUG_FORTH_WORDS_KEY 
3df9						DMARK "PTR" 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 71 ee			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 72 ee			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 73 ee			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "PTR"  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd a0 14			call break_point_state  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15					FORTH_DSP_VALUEHL 
3e15 cd 02 1d			call macro_dsp_valuehl 
3e18				endm 
# End of macro FORTH_DSP_VALUEHL
3e18 cd 0b 1b				call forth_push_numhl 
3e1b			 
3e1b			 
3e1b					NEXTW 
3e1b c3 74 1e			jp macro_next 
3e1e				endm 
# End of macro NEXTW
3e1e			.STYPE: 
3e1e				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3e1e 48				db WORD_SYS_CORE+52             
3e1f 6d 3e			dw .UPPER            
3e21 06				db 5 + 1 
3e22 .. 00			db "STYPE",0              
3e28				endm 
# End of macro CWHEAD
3e28			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3e28					if DEBUG_FORTH_WORDS_KEY 
3e28						DMARK "STY" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 71 ee			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 72 ee			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 73 ee			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "STY"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd a0 14			call break_point_state  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44					FORTH_DSP 
3e44 cd c8 1c			call macro_forth_dsp 
3e47				endm 
# End of macro FORTH_DSP
3e47					;v5 FORTH_DSP_VALUE 
3e47			 
3e47 7e					ld a, (hl) 
3e48			 
3e48 f5					push af 
3e49			 
3e49			; Dont destroy TOS		FORTH_DSP_POP 
3e49			 
3e49 f1					pop af 
3e4a			 
3e4a fe 01				cp DS_TYPE_STR 
3e4c 28 09				jr z, .typestr 
3e4e			 
3e4e fe 02				cp DS_TYPE_INUM 
3e50 28 0a				jr z, .typeinum 
3e52			 
3e52 21 6b 3e				ld hl, .tna 
3e55 18 0a				jr .tpush 
3e57			 
3e57 21 67 3e		.typestr:	ld hl, .tstr 
3e5a 18 05				jr .tpush 
3e5c 21 69 3e		.typeinum:	ld hl, .tinum 
3e5f 18 00				jr .tpush 
3e61			 
3e61			.tpush: 
3e61			 
3e61 cd 79 1b				call forth_push_str 
3e64			 
3e64					NEXTW 
3e64 c3 74 1e			jp macro_next 
3e67				endm 
# End of macro NEXTW
3e67 .. 00		.tstr:	db "s",0 
3e69 .. 00		.tinum:  db "i",0 
3e6b .. 00		.tna:   db "?", 0 
3e6d			 
3e6d			 
3e6d			.UPPER: 
3e6d				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3e6d 48				db WORD_SYS_CORE+52             
3e6e a8 3e			dw .LOWER            
3e70 06				db 5 + 1 
3e71 .. 00			db "UPPER",0              
3e77				endm 
# End of macro CWHEAD
3e77			; | UPPER ( s -- s ) Upper case string s  | DONE 
3e77					if DEBUG_FORTH_WORDS_KEY 
3e77						DMARK "UPR" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 71 ee			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 72 ee			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 73 ee			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "UPR"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd a0 14			call break_point_state  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93			 
3e93					FORTH_DSP 
3e93 cd c8 1c			call macro_forth_dsp 
3e96				endm 
# End of macro FORTH_DSP
3e96					 
3e96			; TODO check is string type 
3e96			 
3e96					FORTH_DSP_VALUEHL 
3e96 cd 02 1d			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99			; get pointer to string in hl 
3e99			 
3e99 7e			.toup:		ld a, (hl) 
3e9a fe 00				cp 0 
3e9c 28 07				jr z, .toupdone 
3e9e			 
3e9e cd 0c 10				call to_upper 
3ea1			 
3ea1 77					ld (hl), a 
3ea2 23					inc hl 
3ea3 18 f4				jr .toup 
3ea5			 
3ea5					 
3ea5			 
3ea5			 
3ea5			; for each char convert to upper 
3ea5					 
3ea5			.toupdone: 
3ea5			 
3ea5			 
3ea5					NEXTW 
3ea5 c3 74 1e			jp macro_next 
3ea8				endm 
# End of macro NEXTW
3ea8			.LOWER: 
3ea8				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3ea8 48				db WORD_SYS_CORE+52             
3ea9 e3 3e			dw .TCASE            
3eab 06				db 5 + 1 
3eac .. 00			db "LOWER",0              
3eb2				endm 
# End of macro CWHEAD
3eb2			; | LOWER ( s -- s ) Lower case string s  | DONE 
3eb2					if DEBUG_FORTH_WORDS_KEY 
3eb2						DMARK "LWR" 
3eb2 f5				push af  
3eb3 3a c7 3e			ld a, (.dmark)  
3eb6 32 71 ee			ld (debug_mark),a  
3eb9 3a c8 3e			ld a, (.dmark+1)  
3ebc 32 72 ee			ld (debug_mark+1),a  
3ebf 3a c9 3e			ld a, (.dmark+2)  
3ec2 32 73 ee			ld (debug_mark+2),a  
3ec5 18 03			jr .pastdmark  
3ec7 ..			.dmark: db "LWR"  
3eca f1			.pastdmark: pop af  
3ecb			endm  
# End of macro DMARK
3ecb						CALLMONITOR 
3ecb cd a0 14			call break_point_state  
3ece				endm  
# End of macro CALLMONITOR
3ece					endif 
3ece			 
3ece					FORTH_DSP 
3ece cd c8 1c			call macro_forth_dsp 
3ed1				endm 
# End of macro FORTH_DSP
3ed1					 
3ed1			; TODO check is string type 
3ed1			 
3ed1					FORTH_DSP_VALUEHL 
3ed1 cd 02 1d			call macro_dsp_valuehl 
3ed4				endm 
# End of macro FORTH_DSP_VALUEHL
3ed4			; get pointer to string in hl 
3ed4			 
3ed4 7e			.tolow:		ld a, (hl) 
3ed5 fe 00				cp 0 
3ed7 28 07				jr z, .tolowdone 
3ed9			 
3ed9 cd 15 10				call to_lower 
3edc			 
3edc 77					ld (hl), a 
3edd 23					inc hl 
3ede 18 f4				jr .tolow 
3ee0			 
3ee0					 
3ee0			 
3ee0			 
3ee0			; for each char convert to low 
3ee0					 
3ee0			.tolowdone: 
3ee0					NEXTW 
3ee0 c3 74 1e			jp macro_next 
3ee3				endm 
# End of macro NEXTW
3ee3			.TCASE: 
3ee3				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3ee3 48				db WORD_SYS_CORE+52             
3ee4 19 40			dw .SUBSTR            
3ee6 06				db 5 + 1 
3ee7 .. 00			db "TCASE",0              
3eed				endm 
# End of macro CWHEAD
3eed			; | TCASE ( s -- s ) Title case string s  | DONE 
3eed					if DEBUG_FORTH_WORDS_KEY 
3eed						DMARK "TCS" 
3eed f5				push af  
3eee 3a 02 3f			ld a, (.dmark)  
3ef1 32 71 ee			ld (debug_mark),a  
3ef4 3a 03 3f			ld a, (.dmark+1)  
3ef7 32 72 ee			ld (debug_mark+1),a  
3efa 3a 04 3f			ld a, (.dmark+2)  
3efd 32 73 ee			ld (debug_mark+2),a  
3f00 18 03			jr .pastdmark  
3f02 ..			.dmark: db "TCS"  
3f05 f1			.pastdmark: pop af  
3f06			endm  
# End of macro DMARK
3f06						CALLMONITOR 
3f06 cd a0 14			call break_point_state  
3f09				endm  
# End of macro CALLMONITOR
3f09					endif 
3f09			 
3f09					FORTH_DSP 
3f09 cd c8 1c			call macro_forth_dsp 
3f0c				endm 
# End of macro FORTH_DSP
3f0c					 
3f0c			; TODO check is string type 
3f0c			 
3f0c					FORTH_DSP_VALUEHL 
3f0c cd 02 1d			call macro_dsp_valuehl 
3f0f				endm 
# End of macro FORTH_DSP_VALUEHL
3f0f			; get pointer to string in hl 
3f0f			 
3f0f					if DEBUG_FORTH_WORDS 
3f0f						DMARK "TC1" 
3f0f f5				push af  
3f10 3a 24 3f			ld a, (.dmark)  
3f13 32 71 ee			ld (debug_mark),a  
3f16 3a 25 3f			ld a, (.dmark+1)  
3f19 32 72 ee			ld (debug_mark+1),a  
3f1c 3a 26 3f			ld a, (.dmark+2)  
3f1f 32 73 ee			ld (debug_mark+2),a  
3f22 18 03			jr .pastdmark  
3f24 ..			.dmark: db "TC1"  
3f27 f1			.pastdmark: pop af  
3f28			endm  
# End of macro DMARK
3f28						CALLMONITOR 
3f28 cd a0 14			call break_point_state  
3f2b				endm  
# End of macro CALLMONITOR
3f2b					endif 
3f2b			 
3f2b					; first time in turn to upper case first char 
3f2b			 
3f2b 7e					ld a, (hl) 
3f2c c3 b6 3f				jp .totsiptou 
3f2f			 
3f2f			 
3f2f 7e			.tot:		ld a, (hl) 
3f30 fe 00				cp 0 
3f32 ca fa 3f				jp z, .totdone 
3f35			 
3f35					if DEBUG_FORTH_WORDS 
3f35						DMARK "TC2" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 71 ee			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 72 ee			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 73 ee			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "TC2"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd a0 14			call break_point_state  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51					; check to see if current char is a space 
3f51			 
3f51 fe 20				cp ' ' 
3f53 28 21				jr z, .totsp 
3f55 cd 15 10				call to_lower 
3f58					if DEBUG_FORTH_WORDS 
3f58						DMARK "TC3" 
3f58 f5				push af  
3f59 3a 6d 3f			ld a, (.dmark)  
3f5c 32 71 ee			ld (debug_mark),a  
3f5f 3a 6e 3f			ld a, (.dmark+1)  
3f62 32 72 ee			ld (debug_mark+1),a  
3f65 3a 6f 3f			ld a, (.dmark+2)  
3f68 32 73 ee			ld (debug_mark+2),a  
3f6b 18 03			jr .pastdmark  
3f6d ..			.dmark: db "TC3"  
3f70 f1			.pastdmark: pop af  
3f71			endm  
# End of macro DMARK
3f71						CALLMONITOR 
3f71 cd a0 14			call break_point_state  
3f74				endm  
# End of macro CALLMONITOR
3f74					endif 
3f74 18 63				jr .totnxt 
3f76			 
3f76			.totsp:         ; on a space, find next char which should be upper 
3f76			 
3f76					if DEBUG_FORTH_WORDS 
3f76						DMARK "TC4" 
3f76 f5				push af  
3f77 3a 8b 3f			ld a, (.dmark)  
3f7a 32 71 ee			ld (debug_mark),a  
3f7d 3a 8c 3f			ld a, (.dmark+1)  
3f80 32 72 ee			ld (debug_mark+1),a  
3f83 3a 8d 3f			ld a, (.dmark+2)  
3f86 32 73 ee			ld (debug_mark+2),a  
3f89 18 03			jr .pastdmark  
3f8b ..			.dmark: db "TC4"  
3f8e f1			.pastdmark: pop af  
3f8f			endm  
# End of macro DMARK
3f8f						CALLMONITOR 
3f8f cd a0 14			call break_point_state  
3f92				endm  
# End of macro CALLMONITOR
3f92					endif 
3f92					;; 
3f92			 
3f92 fe 20				cp ' ' 
3f94 20 20				jr nz, .totsiptou 
3f96 23					inc hl 
3f97 7e					ld a, (hl) 
3f98					if DEBUG_FORTH_WORDS 
3f98						DMARK "TC5" 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 71 ee			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 72 ee			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 73 ee			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "TC5"  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1						CALLMONITOR 
3fb1 cd a0 14			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4					endif 
3fb4 18 c0				jr .totsp 
3fb6 fe 00		.totsiptou:    cp 0 
3fb8 28 40				jr z, .totdone 
3fba					; not space and not zero term so upper case it 
3fba cd 0c 10				call to_upper 
3fbd			 
3fbd					if DEBUG_FORTH_WORDS 
3fbd						DMARK "TC6" 
3fbd f5				push af  
3fbe 3a d2 3f			ld a, (.dmark)  
3fc1 32 71 ee			ld (debug_mark),a  
3fc4 3a d3 3f			ld a, (.dmark+1)  
3fc7 32 72 ee			ld (debug_mark+1),a  
3fca 3a d4 3f			ld a, (.dmark+2)  
3fcd 32 73 ee			ld (debug_mark+2),a  
3fd0 18 03			jr .pastdmark  
3fd2 ..			.dmark: db "TC6"  
3fd5 f1			.pastdmark: pop af  
3fd6			endm  
# End of macro DMARK
3fd6						CALLMONITOR 
3fd6 cd a0 14			call break_point_state  
3fd9				endm  
# End of macro CALLMONITOR
3fd9					endif 
3fd9			 
3fd9			 
3fd9			.totnxt: 
3fd9			 
3fd9 77					ld (hl), a 
3fda 23					inc hl 
3fdb					if DEBUG_FORTH_WORDS 
3fdb						DMARK "TC7" 
3fdb f5				push af  
3fdc 3a f0 3f			ld a, (.dmark)  
3fdf 32 71 ee			ld (debug_mark),a  
3fe2 3a f1 3f			ld a, (.dmark+1)  
3fe5 32 72 ee			ld (debug_mark+1),a  
3fe8 3a f2 3f			ld a, (.dmark+2)  
3feb 32 73 ee			ld (debug_mark+2),a  
3fee 18 03			jr .pastdmark  
3ff0 ..			.dmark: db "TC7"  
3ff3 f1			.pastdmark: pop af  
3ff4			endm  
# End of macro DMARK
3ff4						CALLMONITOR 
3ff4 cd a0 14			call break_point_state  
3ff7				endm  
# End of macro CALLMONITOR
3ff7					endif 
3ff7 c3 2f 3f				jp .tot 
3ffa			 
3ffa					 
3ffa			 
3ffa			 
3ffa			; for each char convert to low 
3ffa					 
3ffa			.totdone: 
3ffa					if DEBUG_FORTH_WORDS 
3ffa						DMARK "TCd" 
3ffa f5				push af  
3ffb 3a 0f 40			ld a, (.dmark)  
3ffe 32 71 ee			ld (debug_mark),a  
4001 3a 10 40			ld a, (.dmark+1)  
4004 32 72 ee			ld (debug_mark+1),a  
4007 3a 11 40			ld a, (.dmark+2)  
400a 32 73 ee			ld (debug_mark+2),a  
400d 18 03			jr .pastdmark  
400f ..			.dmark: db "TCd"  
4012 f1			.pastdmark: pop af  
4013			endm  
# End of macro DMARK
4013						CALLMONITOR 
4013 cd a0 14			call break_point_state  
4016				endm  
# End of macro CALLMONITOR
4016					endif 
4016					NEXTW 
4016 c3 74 1e			jp macro_next 
4019				endm 
# End of macro NEXTW
4019			 
4019			.SUBSTR: 
4019				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4019 48				db WORD_SYS_CORE+52             
401a 77 40			dw .LEFT            
401c 07				db 6 + 1 
401d .. 00			db "SUBSTR",0              
4024				endm 
# End of macro CWHEAD
4024			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4024			 
4024					if DEBUG_FORTH_WORDS_KEY 
4024						DMARK "SST" 
4024 f5				push af  
4025 3a 39 40			ld a, (.dmark)  
4028 32 71 ee			ld (debug_mark),a  
402b 3a 3a 40			ld a, (.dmark+1)  
402e 32 72 ee			ld (debug_mark+1),a  
4031 3a 3b 40			ld a, (.dmark+2)  
4034 32 73 ee			ld (debug_mark+2),a  
4037 18 03			jr .pastdmark  
4039 ..			.dmark: db "SST"  
403c f1			.pastdmark: pop af  
403d			endm  
# End of macro DMARK
403d						CALLMONITOR 
403d cd a0 14			call break_point_state  
4040				endm  
# End of macro CALLMONITOR
4040					endif 
4040			; TODO check string type 
4040					FORTH_DSP_VALUEHL 
4040 cd 02 1d			call macro_dsp_valuehl 
4043				endm 
# End of macro FORTH_DSP_VALUEHL
4043			 
4043 e5					push hl      ; string length 
4044			 
4044					FORTH_DSP_POP 
4044 cd ba 1d			call macro_forth_dsp_pop 
4047				endm 
# End of macro FORTH_DSP_POP
4047			 
4047					FORTH_DSP_VALUEHL 
4047 cd 02 1d			call macro_dsp_valuehl 
404a				endm 
# End of macro FORTH_DSP_VALUEHL
404a			 
404a e5					push hl     ; start char 
404b			 
404b					FORTH_DSP_POP 
404b cd ba 1d			call macro_forth_dsp_pop 
404e				endm 
# End of macro FORTH_DSP_POP
404e			 
404e			 
404e					FORTH_DSP_VALUE 
404e cd eb 1c			call macro_forth_dsp_value 
4051				endm 
# End of macro FORTH_DSP_VALUE
4051			 
4051 d1					pop de    ; get start post offset 
4052			 
4052 19					add hl, de    ; starting offset 
4053			 
4053 c1					pop bc 
4054 c5					push bc      ; grab size of string 
4055			 
4055 e5					push hl    ; save string start  
4056			 
4056 26 00				ld h, 0 
4058 69					ld l, c 
4059 23					inc hl 
405a 23					inc hl 
405b			 
405b cd 66 11				call malloc 
405e				if DEBUG_FORTH_MALLOC_GUARD 
405e cc a6 46				call z,malloc_error 
4061				endif 
4061			 
4061 eb					ex de, hl      ; save malloc area for string copy 
4062 e1					pop hl    ; get back source 
4063 c1					pop bc    ; get length of string back 
4064			 
4064 d5					push de    ; save malloc area for after we push 
4065 ed b0				ldir     ; copy substr 
4067			 
4067			 
4067 eb					ex de, hl 
4068 3e 00				ld a, 0 
406a 77					ld (hl), a   ; term substr 
406b			 
406b					 
406b e1					pop hl    ; get malloc so we can push it 
406c e5					push hl   ; save so we can free it afterwards 
406d			 
406d cd 79 1b				call forth_push_str 
4070			 
4070 e1					pop hl 
4071 cd 30 12				call free 
4074			 
4074					 
4074					 
4074			 
4074			 
4074					NEXTW 
4074 c3 74 1e			jp macro_next 
4077				endm 
# End of macro NEXTW
4077			 
4077			.LEFT: 
4077				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4077 48				db WORD_SYS_CORE+52             
4078 9f 40			dw .RIGHT            
407a 05				db 4 + 1 
407b .. 00			db "LEFT",0              
4080				endm 
# End of macro CWHEAD
4080			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4080					if DEBUG_FORTH_WORDS_KEY 
4080						DMARK "LEF" 
4080 f5				push af  
4081 3a 95 40			ld a, (.dmark)  
4084 32 71 ee			ld (debug_mark),a  
4087 3a 96 40			ld a, (.dmark+1)  
408a 32 72 ee			ld (debug_mark+1),a  
408d 3a 97 40			ld a, (.dmark+2)  
4090 32 73 ee			ld (debug_mark+2),a  
4093 18 03			jr .pastdmark  
4095 ..			.dmark: db "LEF"  
4098 f1			.pastdmark: pop af  
4099			endm  
# End of macro DMARK
4099						CALLMONITOR 
4099 cd a0 14			call break_point_state  
409c				endm  
# End of macro CALLMONITOR
409c					endif 
409c			 
409c					NEXTW 
409c c3 74 1e			jp macro_next 
409f				endm 
# End of macro NEXTW
409f			.RIGHT: 
409f				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
409f 48				db WORD_SYS_CORE+52             
40a0 c8 40			dw .STR2NUM            
40a2 06				db 5 + 1 
40a3 .. 00			db "RIGHT",0              
40a9				endm 
# End of macro CWHEAD
40a9			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
40a9					if DEBUG_FORTH_WORDS_KEY 
40a9						DMARK "RIG" 
40a9 f5				push af  
40aa 3a be 40			ld a, (.dmark)  
40ad 32 71 ee			ld (debug_mark),a  
40b0 3a bf 40			ld a, (.dmark+1)  
40b3 32 72 ee			ld (debug_mark+1),a  
40b6 3a c0 40			ld a, (.dmark+2)  
40b9 32 73 ee			ld (debug_mark+2),a  
40bc 18 03			jr .pastdmark  
40be ..			.dmark: db "RIG"  
40c1 f1			.pastdmark: pop af  
40c2			endm  
# End of macro DMARK
40c2						CALLMONITOR 
40c2 cd a0 14			call break_point_state  
40c5				endm  
# End of macro CALLMONITOR
40c5					endif 
40c5			 
40c5					NEXTW 
40c5 c3 74 1e			jp macro_next 
40c8				endm 
# End of macro NEXTW
40c8			 
40c8			 
40c8			.STR2NUM: 
40c8				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
40c8 48				db WORD_SYS_CORE+52             
40c9 54 41			dw .NUM2STR            
40cb 08				db 7 + 1 
40cc .. 00			db "STR2NUM",0              
40d4				endm 
# End of macro CWHEAD
40d4			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
40d4			 
40d4			 
40d4			; TODO STR type check to do 
40d4					if DEBUG_FORTH_WORDS_KEY 
40d4						DMARK "S2N" 
40d4 f5				push af  
40d5 3a e9 40			ld a, (.dmark)  
40d8 32 71 ee			ld (debug_mark),a  
40db 3a ea 40			ld a, (.dmark+1)  
40de 32 72 ee			ld (debug_mark+1),a  
40e1 3a eb 40			ld a, (.dmark+2)  
40e4 32 73 ee			ld (debug_mark+2),a  
40e7 18 03			jr .pastdmark  
40e9 ..			.dmark: db "S2N"  
40ec f1			.pastdmark: pop af  
40ed			endm  
# End of macro DMARK
40ed						CALLMONITOR 
40ed cd a0 14			call break_point_state  
40f0				endm  
# End of macro CALLMONITOR
40f0					endif 
40f0			 
40f0					;FORTH_DSP 
40f0					FORTH_DSP_VALUE 
40f0 cd eb 1c			call macro_forth_dsp_value 
40f3				endm 
# End of macro FORTH_DSP_VALUE
40f3					;inc hl 
40f3			 
40f3 eb					ex de, hl 
40f4					if DEBUG_FORTH_WORDS 
40f4						DMARK "S2a" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 71 ee			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 72 ee			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 73 ee			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "S2a"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd a0 14			call break_point_state  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110 cd 94 10				call string_to_uint16 
4113			 
4113					if DEBUG_FORTH_WORDS 
4113						DMARK "S2b" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 71 ee			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 72 ee			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 73 ee			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "S2b"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd a0 14			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f			;		push hl 
412f					FORTH_DSP_POP 
412f cd ba 1d			call macro_forth_dsp_pop 
4132				endm 
# End of macro FORTH_DSP_POP
4132			;		pop hl 
4132					 
4132					if DEBUG_FORTH_WORDS 
4132						DMARK "S2b" 
4132 f5				push af  
4133 3a 47 41			ld a, (.dmark)  
4136 32 71 ee			ld (debug_mark),a  
4139 3a 48 41			ld a, (.dmark+1)  
413c 32 72 ee			ld (debug_mark+1),a  
413f 3a 49 41			ld a, (.dmark+2)  
4142 32 73 ee			ld (debug_mark+2),a  
4145 18 03			jr .pastdmark  
4147 ..			.dmark: db "S2b"  
414a f1			.pastdmark: pop af  
414b			endm  
# End of macro DMARK
414b						CALLMONITOR 
414b cd a0 14			call break_point_state  
414e				endm  
# End of macro CALLMONITOR
414e					endif 
414e cd 0b 1b				call forth_push_numhl	 
4151			 
4151				 
4151				       NEXTW 
4151 c3 74 1e			jp macro_next 
4154				endm 
# End of macro NEXTW
4154			.NUM2STR: 
4154				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4154 48				db WORD_SYS_CORE+52             
4155 63 41			dw .CONCAT            
4157 08				db 7 + 1 
4158 .. 00			db "NUM2STR",0              
4160				endm 
# End of macro CWHEAD
4160			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4160			 
4160			;		; malloc a string to target 
4160			;		ld hl, 10     ; TODO max string size should be fine 
4160			;		call malloc 
4160			;		push hl    ; save malloc location 
4160			; 
4160			; 
4160			;; TODO check int type 
4160			;		FORTH_DSP_VALUEHL 
4160			;		ld a, l 
4160			;		call DispAToASCII   
4160			;;TODO need to chage above call to dump into string 
4160			; 
4160			; 
4160			 
4160				       NEXTW 
4160 c3 74 1e			jp macro_next 
4163				endm 
# End of macro NEXTW
4163			 
4163			.CONCAT: 
4163				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4163 48				db WORD_SYS_CORE+52             
4164 16 42			dw .FIND            
4166 07				db 6 + 1 
4167 .. 00			db "CONCAT",0              
416e				endm 
# End of macro CWHEAD
416e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
416e			 
416e			; TODO check string type 
416e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
416e			 
416e					if DEBUG_FORTH_WORDS_KEY 
416e						DMARK "CON" 
416e f5				push af  
416f 3a 83 41			ld a, (.dmark)  
4172 32 71 ee			ld (debug_mark),a  
4175 3a 84 41			ld a, (.dmark+1)  
4178 32 72 ee			ld (debug_mark+1),a  
417b 3a 85 41			ld a, (.dmark+2)  
417e 32 73 ee			ld (debug_mark+2),a  
4181 18 03			jr .pastdmark  
4183 ..			.dmark: db "CON"  
4186 f1			.pastdmark: pop af  
4187			endm  
# End of macro DMARK
4187						CALLMONITOR 
4187 cd a0 14			call break_point_state  
418a				endm  
# End of macro CALLMONITOR
418a					endif 
418a			 
418a			 
418a					FORTH_DSP_VALUE 
418a cd eb 1c			call macro_forth_dsp_value 
418d				endm 
# End of macro FORTH_DSP_VALUE
418d e5					push hl   ; s2 
418e			 
418e					FORTH_DSP_POP 
418e cd ba 1d			call macro_forth_dsp_pop 
4191				endm 
# End of macro FORTH_DSP_POP
4191			 
4191					FORTH_DSP_VALUE 
4191 cd eb 1c			call macro_forth_dsp_value 
4194				endm 
# End of macro FORTH_DSP_VALUE
4194			 
4194 e5					push hl   ; s1 
4195			 
4195					FORTH_DSP_POP 
4195 cd ba 1d			call macro_forth_dsp_pop 
4198				endm 
# End of macro FORTH_DSP_POP
4198					 
4198			 
4198					; copy s1 
4198			 
4198				 
4198					; save ptr 
4198 e1					pop hl  
4199 e5					push hl 
419a 3e 00				ld a, 0 
419c cd 08 11				call strlent 
419f					;inc hl    ; zer0 
419f 06 00				ld b, 0 
41a1 4d					ld c, l 
41a2 e1					pop hl		 
41a3 11 d7 e3				ld de, scratch	 
41a6					if DEBUG_FORTH_WORDS 
41a6						DMARK "CO1" 
41a6 f5				push af  
41a7 3a bb 41			ld a, (.dmark)  
41aa 32 71 ee			ld (debug_mark),a  
41ad 3a bc 41			ld a, (.dmark+1)  
41b0 32 72 ee			ld (debug_mark+1),a  
41b3 3a bd 41			ld a, (.dmark+2)  
41b6 32 73 ee			ld (debug_mark+2),a  
41b9 18 03			jr .pastdmark  
41bb ..			.dmark: db "CO1"  
41be f1			.pastdmark: pop af  
41bf			endm  
# End of macro DMARK
41bf						CALLMONITOR 
41bf cd a0 14			call break_point_state  
41c2				endm  
# End of macro CALLMONITOR
41c2					endif 
41c2 ed b0				ldir 
41c4			 
41c4 e1					pop hl 
41c5 e5					push hl 
41c6 d5					push de 
41c7			 
41c7			 
41c7 3e 00				ld a, 0 
41c9 cd 08 11				call strlent 
41cc 23					inc hl    ; zer0 
41cd 23					inc hl 
41ce 06 00				ld b, 0 
41d0 4d					ld c, l 
41d1 d1					pop de 
41d2 e1					pop hl		 
41d3					if DEBUG_FORTH_WORDS 
41d3						DMARK "CO2" 
41d3 f5				push af  
41d4 3a e8 41			ld a, (.dmark)  
41d7 32 71 ee			ld (debug_mark),a  
41da 3a e9 41			ld a, (.dmark+1)  
41dd 32 72 ee			ld (debug_mark+1),a  
41e0 3a ea 41			ld a, (.dmark+2)  
41e3 32 73 ee			ld (debug_mark+2),a  
41e6 18 03			jr .pastdmark  
41e8 ..			.dmark: db "CO2"  
41eb f1			.pastdmark: pop af  
41ec			endm  
# End of macro DMARK
41ec						CALLMONITOR 
41ec cd a0 14			call break_point_state  
41ef				endm  
# End of macro CALLMONITOR
41ef					endif 
41ef ed b0				ldir 
41f1			 
41f1			 
41f1			 
41f1 21 d7 e3				ld hl, scratch 
41f4					if DEBUG_FORTH_WORDS 
41f4						DMARK "CO5" 
41f4 f5				push af  
41f5 3a 09 42			ld a, (.dmark)  
41f8 32 71 ee			ld (debug_mark),a  
41fb 3a 0a 42			ld a, (.dmark+1)  
41fe 32 72 ee			ld (debug_mark+1),a  
4201 3a 0b 42			ld a, (.dmark+2)  
4204 32 73 ee			ld (debug_mark+2),a  
4207 18 03			jr .pastdmark  
4209 ..			.dmark: db "CO5"  
420c f1			.pastdmark: pop af  
420d			endm  
# End of macro DMARK
420d						CALLMONITOR 
420d cd a0 14			call break_point_state  
4210				endm  
# End of macro CALLMONITOR
4210					endif 
4210			 
4210 cd 79 1b				call forth_push_str 
4213			 
4213			 
4213			 
4213			 
4213				       NEXTW 
4213 c3 74 1e			jp macro_next 
4216				endm 
# End of macro NEXTW
4216			 
4216			 
4216			.FIND: 
4216				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4216 4b				db WORD_SYS_CORE+55             
4217 d4 42			dw .LEN            
4219 05				db 4 + 1 
421a .. 00			db "FIND",0              
421f				endm 
# End of macro CWHEAD
421f			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
421f			 
421f					if DEBUG_FORTH_WORDS_KEY 
421f						DMARK "FND" 
421f f5				push af  
4220 3a 34 42			ld a, (.dmark)  
4223 32 71 ee			ld (debug_mark),a  
4226 3a 35 42			ld a, (.dmark+1)  
4229 32 72 ee			ld (debug_mark+1),a  
422c 3a 36 42			ld a, (.dmark+2)  
422f 32 73 ee			ld (debug_mark+2),a  
4232 18 03			jr .pastdmark  
4234 ..			.dmark: db "FND"  
4237 f1			.pastdmark: pop af  
4238			endm  
# End of macro DMARK
4238						CALLMONITOR 
4238 cd a0 14			call break_point_state  
423b				endm  
# End of macro CALLMONITOR
423b					endif 
423b			 
423b			; TODO check string type 
423b					FORTH_DSP_VALUE 
423b cd eb 1c			call macro_forth_dsp_value 
423e				endm 
# End of macro FORTH_DSP_VALUE
423e			 
423e e5					push hl    
423f 7e					ld a,(hl)    ; char to find   
4240			; TODO change char to substr 
4240			 
4240 f5					push af 
4241					 
4241			 
4241			 
4241					if DEBUG_FORTH_WORDS 
4241						DMARK "FN1" 
4241 f5				push af  
4242 3a 56 42			ld a, (.dmark)  
4245 32 71 ee			ld (debug_mark),a  
4248 3a 57 42			ld a, (.dmark+1)  
424b 32 72 ee			ld (debug_mark+1),a  
424e 3a 58 42			ld a, (.dmark+2)  
4251 32 73 ee			ld (debug_mark+2),a  
4254 18 03			jr .pastdmark  
4256 ..			.dmark: db "FN1"  
4259 f1			.pastdmark: pop af  
425a			endm  
# End of macro DMARK
425a						CALLMONITOR 
425a cd a0 14			call break_point_state  
425d				endm  
# End of macro CALLMONITOR
425d					endif 
425d			 
425d					FORTH_DSP_POP 
425d cd ba 1d			call macro_forth_dsp_pop 
4260				endm 
# End of macro FORTH_DSP_POP
4260			 
4260					; string to search 
4260			 
4260					FORTH_DSP_VALUE 
4260 cd eb 1c			call macro_forth_dsp_value 
4263				endm 
# End of macro FORTH_DSP_VALUE
4263			 
4263 d1					pop de  ; d is char to find  
4264			 
4264					if DEBUG_FORTH_WORDS 
4264						DMARK "FN2" 
4264 f5				push af  
4265 3a 79 42			ld a, (.dmark)  
4268 32 71 ee			ld (debug_mark),a  
426b 3a 7a 42			ld a, (.dmark+1)  
426e 32 72 ee			ld (debug_mark+1),a  
4271 3a 7b 42			ld a, (.dmark+2)  
4274 32 73 ee			ld (debug_mark+2),a  
4277 18 03			jr .pastdmark  
4279 ..			.dmark: db "FN2"  
427c f1			.pastdmark: pop af  
427d			endm  
# End of macro DMARK
427d						CALLMONITOR 
427d cd a0 14			call break_point_state  
4280				endm  
# End of macro CALLMONITOR
4280					endif 
4280					 
4280 01 00 00				ld bc, 0 
4283 7e			.findchar:      ld a,(hl) 
4284 fe 00				cp 0   		 
4286 28 27				jr z, .finddone     
4288 ba					cp d 
4289 28 20				jr z, .foundchar 
428b 03					inc bc 
428c 23					inc hl 
428d					if DEBUG_FORTH_WORDS 
428d						DMARK "FN3" 
428d f5				push af  
428e 3a a2 42			ld a, (.dmark)  
4291 32 71 ee			ld (debug_mark),a  
4294 3a a3 42			ld a, (.dmark+1)  
4297 32 72 ee			ld (debug_mark+1),a  
429a 3a a4 42			ld a, (.dmark+2)  
429d 32 73 ee			ld (debug_mark+2),a  
42a0 18 03			jr .pastdmark  
42a2 ..			.dmark: db "FN3"  
42a5 f1			.pastdmark: pop af  
42a6			endm  
# End of macro DMARK
42a6						CALLMONITOR 
42a6 cd a0 14			call break_point_state  
42a9				endm  
# End of macro CALLMONITOR
42a9					endif 
42a9 18 d8				jr .findchar 
42ab			 
42ab			 
42ab c5			.foundchar:	push bc 
42ac e1					pop hl 
42ad 18 03				jr .findexit 
42af			 
42af			 
42af							 
42af			 
42af			.finddone:     ; got to end of string with no find 
42af 21 00 00				ld hl, 0 
42b2			.findexit: 
42b2			 
42b2					if DEBUG_FORTH_WORDS 
42b2						DMARK "FNd" 
42b2 f5				push af  
42b3 3a c7 42			ld a, (.dmark)  
42b6 32 71 ee			ld (debug_mark),a  
42b9 3a c8 42			ld a, (.dmark+1)  
42bc 32 72 ee			ld (debug_mark+1),a  
42bf 3a c9 42			ld a, (.dmark+2)  
42c2 32 73 ee			ld (debug_mark+2),a  
42c5 18 03			jr .pastdmark  
42c7 ..			.dmark: db "FNd"  
42ca f1			.pastdmark: pop af  
42cb			endm  
# End of macro DMARK
42cb						CALLMONITOR 
42cb cd a0 14			call break_point_state  
42ce				endm  
# End of macro CALLMONITOR
42ce					endif 
42ce cd 0b 1b			call forth_push_numhl 
42d1			 
42d1				       NEXTW 
42d1 c3 74 1e			jp macro_next 
42d4				endm 
# End of macro NEXTW
42d4			 
42d4			.LEN: 
42d4				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
42d4 4c				db WORD_SYS_CORE+56             
42d5 09 43			dw .CHAR            
42d7 06				db 5 + 1 
42d8 .. 00			db "COUNT",0              
42de				endm 
# End of macro CWHEAD
42de			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
42de			 
42de					if DEBUG_FORTH_WORDS_KEY 
42de						DMARK "CNT" 
42de f5				push af  
42df 3a f3 42			ld a, (.dmark)  
42e2 32 71 ee			ld (debug_mark),a  
42e5 3a f4 42			ld a, (.dmark+1)  
42e8 32 72 ee			ld (debug_mark+1),a  
42eb 3a f5 42			ld a, (.dmark+2)  
42ee 32 73 ee			ld (debug_mark+2),a  
42f1 18 03			jr .pastdmark  
42f3 ..			.dmark: db "CNT"  
42f6 f1			.pastdmark: pop af  
42f7			endm  
# End of macro DMARK
42f7						CALLMONITOR 
42f7 cd a0 14			call break_point_state  
42fa				endm  
# End of macro CALLMONITOR
42fa					endif 
42fa			; TODO check string type 
42fa					FORTH_DSP 
42fa cd c8 1c			call macro_forth_dsp 
42fd				endm 
# End of macro FORTH_DSP
42fd					;v5FORTH_DSP_VALUE 
42fd			 
42fd 23					inc hl 
42fe			 
42fe 3e 00				ld a, 0 
4300 cd 08 11				call strlent 
4303			 
4303 cd 0b 1b				call forth_push_numhl 
4306			 
4306			 
4306			 
4306				       NEXTW 
4306 c3 74 1e			jp macro_next 
4309				endm 
# End of macro NEXTW
4309			.CHAR: 
4309				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4309 4d				db WORD_SYS_CORE+57             
430a 3f 43			dw .ENDSTR            
430c 05				db 4 + 1 
430d .. 00			db "CHAR",0              
4312				endm 
# End of macro CWHEAD
4312			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4312					if DEBUG_FORTH_WORDS_KEY 
4312						DMARK "CHR" 
4312 f5				push af  
4313 3a 27 43			ld a, (.dmark)  
4316 32 71 ee			ld (debug_mark),a  
4319 3a 28 43			ld a, (.dmark+1)  
431c 32 72 ee			ld (debug_mark+1),a  
431f 3a 29 43			ld a, (.dmark+2)  
4322 32 73 ee			ld (debug_mark+2),a  
4325 18 03			jr .pastdmark  
4327 ..			.dmark: db "CHR"  
432a f1			.pastdmark: pop af  
432b			endm  
# End of macro DMARK
432b						CALLMONITOR 
432b cd a0 14			call break_point_state  
432e				endm  
# End of macro CALLMONITOR
432e					endif 
432e					FORTH_DSP 
432e cd c8 1c			call macro_forth_dsp 
4331				endm 
# End of macro FORTH_DSP
4331					;v5 FORTH_DSP_VALUE 
4331 23					inc hl      ; now at start of numeric as string 
4332			 
4332			;		push hl 
4332			 
4332					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4332 cd ba 1d			call macro_forth_dsp_pop 
4335				endm 
# End of macro FORTH_DSP_POP
4335			 
4335			;		pop hl 
4335			 
4335					; push the content of a onto the stack as a value 
4335			 
4335 7e					ld a,(hl)   ; get char 
4336 26 00				ld h,0 
4338 6f					ld l,a 
4339 cd 0b 1b				call forth_push_numhl 
433c			 
433c				       NEXTW 
433c c3 74 1e			jp macro_next 
433f				endm 
# End of macro NEXTW
433f			 
433f			 
433f			 
433f			 
433f			.ENDSTR: 
433f			; eof 
433f			 
# End of file forth_words_str.asm
433f			include "forth_words_key.asm" 
433f			 
433f			; | ## Keyboard Words 
433f			 
433f			.KEY: 
433f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
433f 3e				db WORD_SYS_CORE+42             
4340 6f 43			dw .WAITK            
4342 04				db 3 + 1 
4343 .. 00			db "KEY",0              
4347				endm 
# End of macro CWHEAD
4347			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4347			 
4347					if DEBUG_FORTH_WORDS_KEY 
4347						DMARK "KEY" 
4347 f5				push af  
4348 3a 5c 43			ld a, (.dmark)  
434b 32 71 ee			ld (debug_mark),a  
434e 3a 5d 43			ld a, (.dmark+1)  
4351 32 72 ee			ld (debug_mark+1),a  
4354 3a 5e 43			ld a, (.dmark+2)  
4357 32 73 ee			ld (debug_mark+2),a  
435a 18 03			jr .pastdmark  
435c ..			.dmark: db "KEY"  
435f f1			.pastdmark: pop af  
4360			endm  
# End of macro DMARK
4360						CALLMONITOR 
4360 cd a0 14			call break_point_state  
4363				endm  
# End of macro CALLMONITOR
4363					endif 
4363			; TODO currently waits 
4363 cd 5f 5a				call cin 
4366					;call cin_wait 
4366 6f					ld l, a 
4367 26 00				ld h, 0 
4369 cd 0b 1b				call forth_push_numhl 
436c					NEXTW 
436c c3 74 1e			jp macro_next 
436f				endm 
# End of macro NEXTW
436f			.WAITK: 
436f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
436f 3f				db WORD_SYS_CORE+43             
4370 a1 43			dw .ACCEPT            
4372 06				db 5 + 1 
4373 .. 00			db "WAITK",0              
4379				endm 
# End of macro CWHEAD
4379			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4379					if DEBUG_FORTH_WORDS_KEY 
4379						DMARK "WAI" 
4379 f5				push af  
437a 3a 8e 43			ld a, (.dmark)  
437d 32 71 ee			ld (debug_mark),a  
4380 3a 8f 43			ld a, (.dmark+1)  
4383 32 72 ee			ld (debug_mark+1),a  
4386 3a 90 43			ld a, (.dmark+2)  
4389 32 73 ee			ld (debug_mark+2),a  
438c 18 03			jr .pastdmark  
438e ..			.dmark: db "WAI"  
4391 f1			.pastdmark: pop af  
4392			endm  
# End of macro DMARK
4392						CALLMONITOR 
4392 cd a0 14			call break_point_state  
4395				endm  
# End of macro CALLMONITOR
4395					endif 
4395 cd 57 5a				call cin_wait 
4398 6f					ld l, a 
4399 26 00				ld h, 0 
439b cd 0b 1b				call forth_push_numhl 
439e					NEXTW 
439e c3 74 1e			jp macro_next 
43a1				endm 
# End of macro NEXTW
43a1			.ACCEPT: 
43a1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
43a1 40				db WORD_SYS_CORE+44             
43a2 ff 43			dw .EDIT            
43a4 07				db 6 + 1 
43a5 .. 00			db "ACCEPT",0              
43ac				endm 
# End of macro CWHEAD
43ac			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
43ac					; TODO crashes on push 
43ac					if DEBUG_FORTH_WORDS_KEY 
43ac						DMARK "ACC" 
43ac f5				push af  
43ad 3a c1 43			ld a, (.dmark)  
43b0 32 71 ee			ld (debug_mark),a  
43b3 3a c2 43			ld a, (.dmark+1)  
43b6 32 72 ee			ld (debug_mark+1),a  
43b9 3a c3 43			ld a, (.dmark+2)  
43bc 32 73 ee			ld (debug_mark+2),a  
43bf 18 03			jr .pastdmark  
43c1 ..			.dmark: db "ACC"  
43c4 f1			.pastdmark: pop af  
43c5			endm  
# End of macro DMARK
43c5						CALLMONITOR 
43c5 cd a0 14			call break_point_state  
43c8				endm  
# End of macro CALLMONITOR
43c8					endif 
43c8 21 d5 e5				ld hl, os_input 
43cb 3e 00				ld a, 0 
43cd 77					ld (hl),a 
43ce 3a 40 eb				ld a,(f_cursor_ptr) 
43d1 16 64				ld d, 100 
43d3 0e 00				ld c, 0 
43d5 1e 28				ld e, 40 
43d7 cd cc 0c				call input_str 
43da					; TODO perhaps do a type check and wrap in quotes if not a number 
43da 21 d5 e5				ld hl, os_input 
43dd					if DEBUG_FORTH_WORDS 
43dd						DMARK "AC1" 
43dd f5				push af  
43de 3a f2 43			ld a, (.dmark)  
43e1 32 71 ee			ld (debug_mark),a  
43e4 3a f3 43			ld a, (.dmark+1)  
43e7 32 72 ee			ld (debug_mark+1),a  
43ea 3a f4 43			ld a, (.dmark+2)  
43ed 32 73 ee			ld (debug_mark+2),a  
43f0 18 03			jr .pastdmark  
43f2 ..			.dmark: db "AC1"  
43f5 f1			.pastdmark: pop af  
43f6			endm  
# End of macro DMARK
43f6						CALLMONITOR 
43f6 cd a0 14			call break_point_state  
43f9				endm  
# End of macro CALLMONITOR
43f9					endif 
43f9 cd 79 1b				call forth_push_str 
43fc					NEXTW 
43fc c3 74 1e			jp macro_next 
43ff				endm 
# End of macro NEXTW
43ff			 
43ff			.EDIT: 
43ff				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
43ff 40				db WORD_SYS_CORE+44             
4400 a1 44			dw .ENDKEY            
4402 05				db 4 + 1 
4403 .. 00			db "EDIT",0              
4408				endm 
# End of macro CWHEAD
4408			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4408			 
4408					; TODO does not copy from stack 
4408					if DEBUG_FORTH_WORDS_KEY 
4408						DMARK "EDT" 
4408 f5				push af  
4409 3a 1d 44			ld a, (.dmark)  
440c 32 71 ee			ld (debug_mark),a  
440f 3a 1e 44			ld a, (.dmark+1)  
4412 32 72 ee			ld (debug_mark+1),a  
4415 3a 1f 44			ld a, (.dmark+2)  
4418 32 73 ee			ld (debug_mark+2),a  
441b 18 03			jr .pastdmark  
441d ..			.dmark: db "EDT"  
4420 f1			.pastdmark: pop af  
4421			endm  
# End of macro DMARK
4421						CALLMONITOR 
4421 cd a0 14			call break_point_state  
4424				endm  
# End of macro CALLMONITOR
4424					endif 
4424			 
4424					;FORTH_DSP 
4424					FORTH_DSP_VALUEHL 
4424 cd 02 1d			call macro_dsp_valuehl 
4427				endm 
# End of macro FORTH_DSP_VALUEHL
4427			;		inc hl    ; TODO do type check 
4427			 
4427			;		call get_word_hl 
4427 e5					push hl 
4428					if DEBUG_FORTH_WORDS 
4428						DMARK "EDp" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 71 ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 72 ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 73 ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "EDp"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd a0 14			call break_point_state  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444				;	ld a, 0 
4444 cd fd 10				call strlenz 
4447 23					inc hl 
4448			 
4448 06 00				ld b, 0 
444a 4d					ld c, l 
444b			 
444b e1					pop hl 
444c 11 d5 e5				ld de, os_input 
444f					if DEBUG_FORTH_WORDS_KEY 
444f						DMARK "EDc" 
444f f5				push af  
4450 3a 64 44			ld a, (.dmark)  
4453 32 71 ee			ld (debug_mark),a  
4456 3a 65 44			ld a, (.dmark+1)  
4459 32 72 ee			ld (debug_mark+1),a  
445c 3a 66 44			ld a, (.dmark+2)  
445f 32 73 ee			ld (debug_mark+2),a  
4462 18 03			jr .pastdmark  
4464 ..			.dmark: db "EDc"  
4467 f1			.pastdmark: pop af  
4468			endm  
# End of macro DMARK
4468						CALLMONITOR 
4468 cd a0 14			call break_point_state  
446b				endm  
# End of macro CALLMONITOR
446b					endif 
446b ed b0				ldir 
446d			 
446d			 
446d 21 d5 e5				ld hl, os_input 
4470					;ld a, 0 
4470					;ld (hl),a 
4470 3a 40 eb				ld a,(f_cursor_ptr) 
4473 16 64				ld d, 100 
4475 0e 00				ld c, 0 
4477 1e 28				ld e, 40 
4479 cd cc 0c				call input_str 
447c					; TODO perhaps do a type check and wrap in quotes if not a number 
447c 21 d5 e5				ld hl, os_input 
447f					if DEBUG_FORTH_WORDS 
447f						DMARK "ED1" 
447f f5				push af  
4480 3a 94 44			ld a, (.dmark)  
4483 32 71 ee			ld (debug_mark),a  
4486 3a 95 44			ld a, (.dmark+1)  
4489 32 72 ee			ld (debug_mark+1),a  
448c 3a 96 44			ld a, (.dmark+2)  
448f 32 73 ee			ld (debug_mark+2),a  
4492 18 03			jr .pastdmark  
4494 ..			.dmark: db "ED1"  
4497 f1			.pastdmark: pop af  
4498			endm  
# End of macro DMARK
4498						CALLMONITOR 
4498 cd a0 14			call break_point_state  
449b				endm  
# End of macro CALLMONITOR
449b					endif 
449b cd 79 1b				call forth_push_str 
449e					NEXTW 
449e c3 74 1e			jp macro_next 
44a1				endm 
# End of macro NEXTW
44a1			 
44a1			 
44a1			 
44a1			.ENDKEY: 
44a1			; eof 
44a1			 
# End of file forth_words_key.asm
44a1			 
44a1			if STORAGE_SE 
44a1			   	include "forth_words_storage.asm" 
44a1			endif 
44a1				include "forth_words_device.asm" 
44a1			; Device related words 
44a1			 
44a1			; | ## Device Words 
44a1			 
44a1			if SOUND_ENABLE 
44a1			.NOTE: 
44a1				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
44a1			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
44a1					if DEBUG_FORTH_WORDS_KEY 
44a1						DMARK "NTE" 
44a1						CALLMONITOR 
44a1					endif 
44a1			 
44a1				 
44a1			 
44a1					NEXTW 
44a1			.AFTERSOUND: 
44a1			endif 
44a1			 
44a1			 
44a1			USE_GPIO: equ 0 
44a1			 
44a1			if USE_GPIO 
44a1			.GP1: 
44a1				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
44a1			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
44a1					NEXTW 
44a1			.GP2: 
44a1				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
44a1			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
44a1			 
44a1					NEXTW 
44a1			 
44a1			.GP3: 
44a1				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
44a1			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
44a1			 
44a1					NEXTW 
44a1			 
44a1			.GP4: 
44a1				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
44a1			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
44a1			 
44a1					NEXTW 
44a1			.SIN: 
44a1			 
44a1			 
44a1			endif 
44a1			 
44a1			 
44a1				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
44a1 33				db WORD_SYS_CORE+31             
44a2 d6 44			dw .SOUT            
44a4 03				db 2 + 1 
44a5 .. 00			db "IN",0              
44a8				endm 
# End of macro CWHEAD
44a8			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
44a8					if DEBUG_FORTH_WORDS_KEY 
44a8						DMARK "IN." 
44a8 f5				push af  
44a9 3a bd 44			ld a, (.dmark)  
44ac 32 71 ee			ld (debug_mark),a  
44af 3a be 44			ld a, (.dmark+1)  
44b2 32 72 ee			ld (debug_mark+1),a  
44b5 3a bf 44			ld a, (.dmark+2)  
44b8 32 73 ee			ld (debug_mark+2),a  
44bb 18 03			jr .pastdmark  
44bd ..			.dmark: db "IN."  
44c0 f1			.pastdmark: pop af  
44c1			endm  
# End of macro DMARK
44c1						CALLMONITOR 
44c1 cd a0 14			call break_point_state  
44c4				endm  
# End of macro CALLMONITOR
44c4					endif 
44c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44c4 cd 02 1d			call macro_dsp_valuehl 
44c7				endm 
# End of macro FORTH_DSP_VALUEHL
44c7			 
44c7 e5					push hl 
44c8			 
44c8					; destroy value TOS 
44c8			 
44c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c8 cd ba 1d			call macro_forth_dsp_pop 
44cb				endm 
# End of macro FORTH_DSP_POP
44cb			 
44cb					; one value on hl get other one back 
44cb			 
44cb c1					pop bc 
44cc			 
44cc					; do the sub 
44cc			;		ex de, hl 
44cc			 
44cc ed 68				in l,(c) 
44ce			 
44ce					; save it 
44ce			 
44ce 26 00				ld h,0 
44d0			 
44d0					; TODO push value back onto stack for another op etc 
44d0			 
44d0 cd 0b 1b				call forth_push_numhl 
44d3					NEXTW 
44d3 c3 74 1e			jp macro_next 
44d6				endm 
# End of macro NEXTW
44d6			.SOUT: 
44d6				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
44d6 34				db WORD_SYS_CORE+32             
44d7 29 45			dw .SPIO            
44d9 04				db 3 + 1 
44da .. 00			db "OUT",0              
44de				endm 
# End of macro CWHEAD
44de			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
44de					if DEBUG_FORTH_WORDS_KEY 
44de						DMARK "OUT" 
44de f5				push af  
44df 3a f3 44			ld a, (.dmark)  
44e2 32 71 ee			ld (debug_mark),a  
44e5 3a f4 44			ld a, (.dmark+1)  
44e8 32 72 ee			ld (debug_mark+1),a  
44eb 3a f5 44			ld a, (.dmark+2)  
44ee 32 73 ee			ld (debug_mark+2),a  
44f1 18 03			jr .pastdmark  
44f3 ..			.dmark: db "OUT"  
44f6 f1			.pastdmark: pop af  
44f7			endm  
# End of macro DMARK
44f7						CALLMONITOR 
44f7 cd a0 14			call break_point_state  
44fa				endm  
# End of macro CALLMONITOR
44fa					endif 
44fa			 
44fa					; get port 
44fa			 
44fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44fa cd 02 1d			call macro_dsp_valuehl 
44fd				endm 
# End of macro FORTH_DSP_VALUEHL
44fd			 
44fd e5					push hl 
44fe			 
44fe					; destroy value TOS 
44fe			 
44fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44fe cd ba 1d			call macro_forth_dsp_pop 
4501				endm 
# End of macro FORTH_DSP_POP
4501			 
4501					; get byte to send 
4501			 
4501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4501 cd 02 1d			call macro_dsp_valuehl 
4504				endm 
# End of macro FORTH_DSP_VALUEHL
4504			 
4504			;		push hl 
4504			 
4504					; destroy value TOS 
4504			 
4504					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4504 cd ba 1d			call macro_forth_dsp_pop 
4507				endm 
# End of macro FORTH_DSP_POP
4507			 
4507					; one value on hl get other one back 
4507			 
4507			;		pop hl 
4507			 
4507 c1					pop bc 
4508			 
4508					if DEBUG_FORTH_WORDS 
4508						DMARK "OUT" 
4508 f5				push af  
4509 3a 1d 45			ld a, (.dmark)  
450c 32 71 ee			ld (debug_mark),a  
450f 3a 1e 45			ld a, (.dmark+1)  
4512 32 72 ee			ld (debug_mark+1),a  
4515 3a 1f 45			ld a, (.dmark+2)  
4518 32 73 ee			ld (debug_mark+2),a  
451b 18 03			jr .pastdmark  
451d ..			.dmark: db "OUT"  
4520 f1			.pastdmark: pop af  
4521			endm  
# End of macro DMARK
4521						CALLMONITOR 
4521 cd a0 14			call break_point_state  
4524				endm  
# End of macro CALLMONITOR
4524					endif 
4524			 
4524 ed 69				out (c), l 
4526			 
4526					NEXTW 
4526 c3 74 1e			jp macro_next 
4529				endm 
# End of macro NEXTW
4529			 
4529			 
4529			.SPIO: 
4529			 
4529			if STORAGE_SE 
4529				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4529			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4529			 
4529					call spi_ce_low 
4529			    NEXTW 
4529			 
4529			.SPICEH: 
4529				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4529			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4529			 
4529					call spi_ce_high 
4529			    NEXTW 
4529			 
4529			 
4529			.SPIOb: 
4529			 
4529				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4529			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4529			 
4529					; get port 
4529			 
4529			 
4529					; get byte to send 
4529			 
4529					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4529			 
4529			;		push hl    ; u1  
4529			 
4529					; destroy value TOS 
4529			 
4529					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4529			 
4529					; one value on hl get other one back 
4529			 
4529			;		pop hl   ; u2 - addr 
4529			 
4529					; TODO Send SPI byte 
4529			 
4529					ld a, l 
4529					call spi_send_byte 
4529			 
4529					NEXTW 
4529			 
4529			.SPII: 
4529				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4529			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4529			 
4529					; TODO Get SPI byte 
4529			 
4529					call spi_read_byte 
4529			 
4529					ld h, 0 
4529					ld l, a 
4529					call forth_push_numhl 
4529			 
4529					NEXTW 
4529			 
4529			 
4529			 
4529			.SESEL: 
4529				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4529			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4529					if DEBUG_FORTH_WORDS_KEY 
4529						DMARK "BNK" 
4529						CALLMONITOR 
4529					endif 
4529			 
4529					ld a, 255 
4529					ld (spi_cartdev), a 
4529			 
4529					; get bank 
4529			 
4529					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4529			 
4529			;		push hl 
4529			 
4529					; destroy value TOS 
4529			 
4529					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4529			 
4529					; one value on hl get other one back 
4529			 
4529			;		pop hl 
4529			 
4529			 
4529					ld c, SPI_CE_HIGH 
4529					ld b, '0'    ; human readable bank number 
4529			 
4529					ld a, l 
4529			 
4529					if DEBUG_FORTH_WORDS 
4529						DMARK "BNK" 
4529						CALLMONITOR 
4529					endif 
4529			 
4529					; active low 
4529			 
4529					cp 0 
4529					jr z, .bset 
4529					cp 1 
4529					jr nz, .b2 
4529					res 0, c 
4529					ld b, '1'    ; human readable bank number 
4529			.b2:		cp 2 
4529					jr nz, .b3 
4529					res 1, c 
4529					ld b, '2'    ; human readable bank number 
4529			.b3:		cp 3 
4529					jr nz, .b4 
4529					res 2, c 
4529					ld b, '3'    ; human readable bank number 
4529			.b4:		cp 4 
4529					jr nz, .b5 
4529					res 3, c 
4529					ld b, '4'    ; human readable bank number 
4529			.b5:		cp 5 
4529					jr nz, .bset 
4529					res 4, c 
4529					ld b, '5'    ; human readable bank number 
4529			 
4529			.bset: 
4529					ld a, c 
4529					ld (spi_device),a 
4529					ld a, b 
4529					ld (spi_device_id),a 
4529					if DEBUG_FORTH_WORDS 
4529						DMARK "BN2" 
4529						CALLMONITOR 
4529					endif 
4529			 
4529					NEXTW 
4529			 
4529			.CARTDEV: 
4529				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4529			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4529					if DEBUG_FORTH_WORDS_KEY 
4529						DMARK "CDV" 
4529						CALLMONITOR 
4529					endif 
4529			 
4529					; disable se storage bank selection 
4529			 
4529					ld a, SPI_CE_HIGH		; ce high 
4529					ld (spi_device), a 
4529			 
4529					; get bank 
4529			 
4529					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4529			 
4529			;		push hl 
4529			 
4529					; destroy value TOS 
4529			 
4529					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4529			 
4529					; one value on hl get other one back 
4529			 
4529			;		pop hl 
4529			 
4529					; active low 
4529			 
4529					ld c, 255 
4529			 
4529					ld a, l 
4529					if DEBUG_FORTH_WORDS 
4529						DMARK "CDV" 
4529						CALLMONITOR 
4529					endif 
4529					cp 0 
4529					jr z, .cset 
4529					cp 1 
4529					jr nz, .c2 
4529					res 0, c 
4529			.c2:		cp 2 
4529					jr nz, .c3 
4529					res 1, c 
4529			.c3:		cp 3 
4529					jr nz, .c4 
4529					res 2, c 
4529			.c4:		cp 4 
4529					jr nz, .c5 
4529					res 3, c 
4529			.c5:		cp 5 
4529					jr nz, .c6 
4529					res 4, c 
4529			.c6:		cp 6 
4529					jr nz, .c7 
4529					res 5, c 
4529			.c7:		cp 7 
4529					jr nz, .c8 
4529					res 6, c 
4529			.c8:		cp 8 
4529					jr nz, .cset 
4529					res 7, c 
4529			.cset:		ld a, c 
4529					ld (spi_cartdev),a 
4529			 
4529					if DEBUG_FORTH_WORDS 
4529						DMARK "CD2" 
4529						CALLMONITOR 
4529					endif 
4529					NEXTW 
4529			endif 
4529			 
4529			.ENDDEVICE: 
4529			; eof 
4529			 
# End of file forth_words_device.asm
4529			 
4529			; var handler 
4529			 
4529			 
4529			.VARS: 
4529				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4529 78				db WORD_SYS_CORE+100             
452a 41 45			dw .V0Q            
452c 04				db 3 + 1 
452d .. 00			db "V0!",0              
4531				endm 
# End of macro CWHEAD
4531			;| V0! ( u1 -- )  Store value to v0  | DONE 
4531			 
4531					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4531 cd 02 1d			call macro_dsp_valuehl 
4534				endm 
# End of macro FORTH_DSP_VALUEHL
4534			 
4534 11 0a eb				ld de, cli_var_array 
4537			 
4537 eb					ex de, hl 
4538 73					ld (hl), e 
4539 23					inc hl 
453a 72					ld (hl), d 
453b			 
453b					; destroy value TOS 
453b			 
453b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
453b cd ba 1d			call macro_forth_dsp_pop 
453e				endm 
# End of macro FORTH_DSP_POP
453e			 
453e				       NEXTW 
453e c3 74 1e			jp macro_next 
4541				endm 
# End of macro NEXTW
4541			.V0Q: 
4541				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4541 79				db WORD_SYS_CORE+101             
4542 52 45			dw .V1S            
4544 04				db 3 + 1 
4545 .. 00			db "V0@",0              
4549				endm 
# End of macro CWHEAD
4549			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4549 2a 0a eb				ld hl, (cli_var_array) 
454c cd 0b 1b				call forth_push_numhl 
454f			 
454f				       NEXTW 
454f c3 74 1e			jp macro_next 
4552				endm 
# End of macro NEXTW
4552			.V1S: 
4552				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4552 7a				db WORD_SYS_CORE+102             
4553 6a 45			dw .V1Q            
4555 04				db 3 + 1 
4556 .. 00			db "V1!",0              
455a				endm 
# End of macro CWHEAD
455a			;| V1! ( u1 -- )  Store value to v1 | DONE 
455a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
455a cd 02 1d			call macro_dsp_valuehl 
455d				endm 
# End of macro FORTH_DSP_VALUEHL
455d			 
455d 11 0c eb				ld de, cli_var_array+2 
4560				 
4560 eb					ex de, hl 
4561 73					ld (hl), e 
4562 23					inc hl 
4563 72					ld (hl), d 
4564			 
4564					; destroy value TOS 
4564			 
4564					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4564 cd ba 1d			call macro_forth_dsp_pop 
4567				endm 
# End of macro FORTH_DSP_POP
4567				       NEXTW 
4567 c3 74 1e			jp macro_next 
456a				endm 
# End of macro NEXTW
456a			.V1Q: 
456a				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
456a 7b				db WORD_SYS_CORE+103             
456b 7b 45			dw .V2S            
456d 04				db 3 + 1 
456e .. 00			db "V1@",0              
4572				endm 
# End of macro CWHEAD
4572			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4572 2a 0c eb				ld hl, (cli_var_array+2) 
4575 cd 0b 1b				call forth_push_numhl 
4578				       NEXTW 
4578 c3 74 1e			jp macro_next 
457b				endm 
# End of macro NEXTW
457b			.V2S: 
457b				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
457b 7c				db WORD_SYS_CORE+104             
457c 93 45			dw .V2Q            
457e 04				db 3 + 1 
457f .. 00			db "V2!",0              
4583				endm 
# End of macro CWHEAD
4583			;| V2! ( u1 -- )  Store value to v2 | DONE 
4583					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4583 cd 02 1d			call macro_dsp_valuehl 
4586				endm 
# End of macro FORTH_DSP_VALUEHL
4586			 
4586 11 0e eb				ld de, cli_var_array+4 
4589				 
4589 eb					ex de, hl 
458a 73					ld (hl), e 
458b 23					inc hl 
458c 72					ld (hl), d 
458d			 
458d					; destroy value TOS 
458d			 
458d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
458d cd ba 1d			call macro_forth_dsp_pop 
4590				endm 
# End of macro FORTH_DSP_POP
4590				       NEXTW 
4590 c3 74 1e			jp macro_next 
4593				endm 
# End of macro NEXTW
4593			.V2Q: 
4593				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4593 7d				db WORD_SYS_CORE+105             
4594 a4 45			dw .V3S            
4596 04				db 3 + 1 
4597 .. 00			db "V2@",0              
459b				endm 
# End of macro CWHEAD
459b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
459b 2a 0e eb				ld hl, (cli_var_array+4) 
459e cd 0b 1b				call forth_push_numhl 
45a1				       NEXTW 
45a1 c3 74 1e			jp macro_next 
45a4				endm 
# End of macro NEXTW
45a4			.V3S: 
45a4				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
45a4 7c				db WORD_SYS_CORE+104             
45a5 bc 45			dw .V3Q            
45a7 04				db 3 + 1 
45a8 .. 00			db "V3!",0              
45ac				endm 
# End of macro CWHEAD
45ac			;| V3! ( u1 -- )  Store value to v3 | DONE 
45ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ac cd 02 1d			call macro_dsp_valuehl 
45af				endm 
# End of macro FORTH_DSP_VALUEHL
45af			 
45af 11 10 eb				ld de, cli_var_array+6 
45b2				 
45b2 eb					ex de, hl 
45b3 73					ld (hl), e 
45b4 23					inc hl 
45b5 72					ld (hl), d 
45b6			 
45b6					; destroy value TOS 
45b6			 
45b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45b6 cd ba 1d			call macro_forth_dsp_pop 
45b9				endm 
# End of macro FORTH_DSP_POP
45b9				       NEXTW 
45b9 c3 74 1e			jp macro_next 
45bc				endm 
# End of macro NEXTW
45bc			.V3Q: 
45bc				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
45bc 7d				db WORD_SYS_CORE+105             
45bd cd 45			dw .END            
45bf 04				db 3 + 1 
45c0 .. 00			db "V3@",0              
45c4				endm 
# End of macro CWHEAD
45c4			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
45c4 2a 10 eb				ld hl, (cli_var_array+6) 
45c7 cd 0b 1b				call forth_push_numhl 
45ca				       NEXTW 
45ca c3 74 1e			jp macro_next 
45cd				endm 
# End of macro NEXTW
45cd			 
45cd			 
45cd			 
45cd			 
45cd			 
45cd			; end of dict marker 
45cd			 
45cd 00			.END:    db WORD_SYS_END 
45ce 00 00			dw 0 
45d0 00				db 0 
45d1			 
45d1			; use to jp here for user dict words to save on macro expansion  
45d1			 
45d1			user_dict_next: 
45d1				NEXTW 
45d1 c3 74 1e			jp macro_next 
45d4				endm 
# End of macro NEXTW
45d4			 
45d4			 
45d4			user_exec: 
45d4				;    ld hl, <word code> 
45d4				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
45d4				;    call forthexec 
45d4				;    jp user_dict_next   (NEXT) 
45d4			        ;    <word code bytes> 
45d4 eb				ex de, hl 
45d5 2a d8 e6			ld hl,(os_tok_ptr) 
45d8				 
45d8				FORTH_RSP_NEXT 
45d8 cd b2 1a			call macro_forth_rsp_next 
45db				endm 
# End of macro FORTH_RSP_NEXT
45db			 
45db			if DEBUG_FORTH_UWORD 
45db						DMARK "UEX" 
45db f5				push af  
45dc 3a f0 45			ld a, (.dmark)  
45df 32 71 ee			ld (debug_mark),a  
45e2 3a f1 45			ld a, (.dmark+1)  
45e5 32 72 ee			ld (debug_mark+1),a  
45e8 3a f2 45			ld a, (.dmark+2)  
45eb 32 73 ee			ld (debug_mark+2),a  
45ee 18 03			jr .pastdmark  
45f0 ..			.dmark: db "UEX"  
45f3 f1			.pastdmark: pop af  
45f4			endm  
# End of macro DMARK
45f4				CALLMONITOR 
45f4 cd a0 14			call break_point_state  
45f7				endm  
# End of macro CALLMONITOR
45f7			endif 
45f7			 
45f7			 
45f7			 
45f7 eb				ex de, hl 
45f8 22 d8 e6			ld (os_tok_ptr), hl 
45fb				 
45fb				; Don't use next - Skips the first word in uword. 
45fb			 
45fb c3 05 1f			jp exec1 
45fe			;	NEXT 
45fe			 
45fe			 
45fe			; eof 
# End of file forth_wordsv4.asm
45fe			endif 
45fe			;;;;;;;;;;;;;; Debug code 
45fe			 
45fe			 
45fe			;if DEBUG_FORTH_PARSE 
45fe .. 00		.nowordfound: db "No match",0 
4607 .. 00		.compword:	db "Comparing word ",0 
4617 .. 00		.nextwordat:	db "Next word at",0 
4624 .. 00		.charmatch:	db "Char match",0 
462f			;endif 
462f			if DEBUG_FORTH_JP 
462f			.foundword:	db "Word match. Exec..",0 
462f			endif 
462f			;if DEBUG_FORTH_PUSH 
462f .. 00		.enddict:	db "Dict end. Push.",0 
463f .. 00		.push_str:	db "Pushing string",0 
464e .. 00		.push_num:	db "Pushing number",0 
465d .. 00		.data_sp:	db "SP:",0 
4661 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4673 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4685 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4697			;endif 
4697			;if DEBUG_FORTH_MALLOC 
4697 .. 00		.push_malloc:	db "Malloc address",0 
46a6			;endif 
46a6			 
46a6			 
46a6			 
46a6			; display malloc address and current data stack pointer  
46a6			 
46a6			malloc_error: 
46a6 d5				push de 
46a7 f5				push af 
46a8 e5				push hl 
46a9 cd 72 0a			call clear_display 
46ac 11 ce 46			ld de, .mallocerr 
46af 3e 00			ld a,0 
46b1			;	ld de,os_word_scratch 
46b1 cd 85 0a			call str_at_display 
46b4 3e 11			ld a, display_row_1+17 
46b6 11 71 ee			ld de, debug_mark 
46b9 cd 85 0a			call str_at_display 
46bc cd 95 0a			call update_display 
46bf				;call break_point_state 
46bf cd 57 5a			call cin_wait 
46c2			 
46c2 3e 20			ld a, ' ' 
46c4 32 c8 e3			ld (os_view_disable), a 
46c7 e1				pop hl 
46c8 f1				pop af 
46c9 d1				pop de	 
46ca				CALLMONITOR 
46ca cd a0 14			call break_point_state  
46cd				endm  
# End of macro CALLMONITOR
46cd c9				ret 
46ce			 
46ce .. 00		.mallocerr: 	db "Malloc Error",0 
46db			;if DEBUG_FORTH_PUSH 
46db			display_data_sp: 
46db f5				push af 
46dc			 
46dc				; see if disabled 
46dc			 
46dc 3a c8 e3			ld a, (os_view_disable) 
46df fe 2a			cp '*' 
46e1 28 67			jr z, .skipdsp 
46e3			 
46e3 e5				push hl 
46e4 e5				push hl 
46e5 e5			push hl 
46e6 cd 72 0a			call clear_display 
46e9 e1			pop hl 
46ea 7c				ld a,h 
46eb 21 dc e6			ld hl, os_word_scratch 
46ee cd a0 0f			call hexout 
46f1 e1				pop hl 
46f2 7d				ld a,l 
46f3 21 de e6			ld hl, os_word_scratch+2 
46f6 cd a0 0f			call hexout 
46f9 21 e0 e6			ld hl, os_word_scratch+4 
46fc 3e 00			ld a,0 
46fe 77				ld (hl),a 
46ff 11 dc e6			ld de,os_word_scratch 
4702 3e 28				ld a, display_row_2 
4704 cd 85 0a				call str_at_display 
4707 11 61 46			ld de, .wordinhl 
470a 3e 00			ld a, display_row_1 
470c			 
470c cd 85 0a				call str_at_display 
470f 11 71 ee			ld de, debug_mark 
4712 3e 11			ld a, display_row_1+17 
4714			 
4714 cd 85 0a				call str_at_display 
4717			 
4717				; display current data stack pointer 
4717 11 5d 46			ld de,.data_sp 
471a 3e 30				ld a, display_row_2 + 8 
471c cd 85 0a				call str_at_display 
471f			 
471f 2a 04 eb			ld hl,(cli_data_sp) 
4722 e5				push hl 
4723 7c				ld a,h 
4724 21 dc e6			ld hl, os_word_scratch 
4727 cd a0 0f			call hexout 
472a e1				pop hl 
472b 7d				ld a,l 
472c 21 de e6			ld hl, os_word_scratch+2 
472f cd a0 0f			call hexout 
4732 21 e0 e6			ld hl, os_word_scratch+4 
4735 3e 00			ld a,0 
4737 77				ld (hl),a 
4738 11 dc e6			ld de,os_word_scratch 
473b 3e 33				ld a, display_row_2 + 11 
473d cd 85 0a				call str_at_display 
4740			 
4740			 
4740 cd 95 0a			call update_display 
4743 cd e4 09			call delay1s 
4746 cd e4 09			call delay1s 
4749 e1				pop hl 
474a			.skipdsp: 
474a f1				pop af 
474b c9				ret 
474c			 
474c			display_data_malloc: 
474c			 
474c f5				push af 
474d e5				push hl 
474e e5				push hl 
474f e5			push hl 
4750 cd 72 0a			call clear_display 
4753 e1			pop hl 
4754 7c				ld a,h 
4755 21 dc e6			ld hl, os_word_scratch 
4758 cd a0 0f			call hexout 
475b e1				pop hl 
475c 7d				ld a,l 
475d 21 de e6			ld hl, os_word_scratch+2 
4760 cd a0 0f			call hexout 
4763 21 e0 e6			ld hl, os_word_scratch+4 
4766 3e 00			ld a,0 
4768 77				ld (hl),a 
4769 11 dc e6			ld de,os_word_scratch 
476c 3e 28				ld a, display_row_2 
476e cd 85 0a				call str_at_display 
4771 11 97 46			ld de, .push_malloc 
4774 3e 00			ld a, display_row_1 
4776			 
4776 cd 85 0a				call str_at_display 
4779			 
4779				; display current data stack pointer 
4779 11 5d 46			ld de,.data_sp 
477c 3e 30				ld a, display_row_2 + 8 
477e cd 85 0a				call str_at_display 
4781			 
4781 2a 04 eb			ld hl,(cli_data_sp) 
4784 e5				push hl 
4785 7c				ld a,h 
4786 21 dc e6			ld hl, os_word_scratch 
4789 cd a0 0f			call hexout 
478c e1				pop hl 
478d 7d				ld a,l 
478e 21 de e6			ld hl, os_word_scratch+2 
4791 cd a0 0f			call hexout 
4794 21 e0 e6			ld hl, os_word_scratch+4 
4797 3e 00			ld a,0 
4799 77				ld (hl),a 
479a 11 dc e6			ld de,os_word_scratch 
479d 3e 33				ld a, display_row_2 + 11 
479f cd 85 0a				call str_at_display 
47a2			 
47a2 cd 95 0a			call update_display 
47a5 cd e4 09			call delay1s 
47a8 cd e4 09			call delay1s 
47ab e1				pop hl 
47ac f1				pop af 
47ad c9				ret 
47ae			;endif 
47ae			 
47ae			include "forth_autostart.asm" 
47ae			; list of commands to perform at system start up 
47ae			 
47ae			startcmds: 
47ae			;	dw test11 
47ae			;	dw test12 
47ae			;	dw test13 
47ae			;	dw test14 
47ae			;	dw test15 
47ae			;	dw test16 
47ae			;	dw test17 
47ae			;	dw ifthtest1 
47ae			;	dw ifthtest2 
47ae			;	dw ifthtest3 
47ae			;	dw mmtest1 
47ae			;	dw mmtest2 
47ae			;	dw mmtest3 
47ae			;	dw mmtest4 
47ae			;	dw mmtest5 
47ae			;	dw mmtest6 
47ae			;	dw iftest1 
47ae			;	dw iftest2 
47ae			;	dw iftest3 
47ae			;	dw looptest1 
47ae			;	dw looptest2 
47ae			;	dw test1 
47ae			;	dw test2 
47ae			;	dw test3 
47ae			;	dw test4 
47ae			;	dw game2r 
47ae			;	dw game2b1 
47ae			;	dw game2b2 
47ae			 
47ae				; start up words that are actually useful 
47ae			 
47ae 0c 48			dw clrstack 
47b0 3f 48			dw type 
47b2 2f 4a			dw stest 
47b4 63 48			dw strncpy 
47b6 c5 49			dw list 
47b8 c4 48			dw start1 
47ba d6 48			dw start2 
47bc			;	dw start3 
47bc e9 48			dw start3b 
47be 65 49			dw start3c 
47c0			 
47c0				; (unit) testing words 
47c0			 
47c0 a6 4a			dw mtesta 
47c2 5b 4b			dw mtestb 
47c4 fe 4b			dw mtestc 
47c6 b3 4c			dw mtestd 
47c8 57 4d			dw mteste 
47ca			 
47ca				; demo/game words 
47ca			 
47ca 63 54		        dw game3w 
47cc 91 54		        dw game3p 
47ce af 54		        dw game3sc 
47d0 e0 54		        dw game3vsi 
47d2 0c 55		        dw game3vs 
47d4				 
47d4 56 52			dw game2b 
47d6 c4 52			dw game2bf 
47d8 0e 53			dw game2mba 
47da a4 53			dw game2mbas 
47dc e6 53			dw game2mb 
47de			 
47de 17 4f			dw game1 
47e0 28 4f			dw game1a 
47e2 8a 4f			dw game1b 
47e4 bf 4f			dw game1c 
47e6 f5 4f			dw game1d 
47e8 26 50			dw game1s 
47ea 3a 50			dw game1t 
47ec 4f 50			dw game1f 
47ee 83 50			dw game1z 
47f0 c7 50			dw game1zz 
47f2			 
47f2 0d 4e			dw test5 
47f4 45 4e			dw test6 
47f6 7d 4e			dw test7 
47f8 91 4e			dw test8 
47fa bd 4e			dw test9 
47fc d3 4e			dw test10 
47fe				 
47fe 9e 51		        dw ssv5 
4800 82 51		        dw ssv4 
4802 66 51		        dw ssv3 
4804 30 51		        dw ssv2 
4806 b7 51		        dw ssv1 
4808 ff 51		        dw ssv1cpm 
480a			;	dw keyup 
480a			;	dw keydown 
480a			;	dw keyleft 
480a			;	dw keyright 
480a			;	dw 	keyf1 
480a			;	dw keyf2 
480a			;	dw keyf3 
480a			;	dw keyf4 
480a			;	dw keyf5 
480a			;	dw keyf6 
480a			;	dw keyf7 
480a			;	dw keyf8 
480a			;	dw keyf9 
480a			;	dw keyf10 
480a			;	dw keyf11 
480a			;	dw keyf12 
480a			;	dw keytab 
480a			;	dw keycr 
480a			;	dw keyhome 
480a			;	dw keyend 
480a			;	dw keybs 
480a 00 00			db 0, 0	 
480c			 
480c			 
480c			; clear stack  
480c			 
480c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
483f			 
483f			; type ( addr count - ) 
483f .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4863			 
4863			; some direct memory words 
4863			; strncpy ( len t f -- t ) 
4863			 
4863 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
48c4			 
48c4 .. 00		start1:     	db ": bpon $0000 bp ;",0 
48d6 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
48e9 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
4965 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
49c5			 
49c5			 
49c5			; a handy word to list items on the stack 
49c5			 
49c5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
4a2f			 
4a2f			 
4a2f			; test stack  
4a2f			; rnd8 stest 
4a2f			 
4a2f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4aa6			 
4aa6			; random malloc and free cycles 
4aa6			 
4aa6 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4b5b			 
4b5b			; fixed malloc and free cycles 
4b5b			 
4b5b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4bfe			 
4bfe			; fixed double string push and drop cycle  
4bfe			 
4bfe .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4cb3			 
4cb3			; consistent fixed string push and drop cycle  
4cb3			 
4cb3 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4d57			 
4d57 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4e0d			 
4e0d			;test1:		db ": aa 1 2 3 ;", 0 
4e0d			;test2:     	db "111 aa 888 999",0 
4e0d			;test3:     	db ": bb 77 ;",0 
4e0d			;test4:     	db "$02 $01 do i . loop bb",0 
4e0d			 
4e0d .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4e45 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4e7d .. 00		test7:     	db ": box hline vline ;",0 
4e91 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4ebd .. 00		test9:     	db ": sw $01 adsp world ;",0 
4ed3 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4ef8 .. 00		test11:     	db "hello create .",0 
4f07 .. 00		test12:     	db "hello2 create .",0 
4f17			 
4f17			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4f17			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4f17			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4f17			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4f17			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4f17			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4f17			 
4f17			;iftest1:     	db "$0001 IF cls .",0 
4f17			;iftest2:     	db "$0000 IF cls .",0 
4f17			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4f17			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4f17			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4f17			 
4f17			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4f17			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4f17			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4f17			 
4f17			 
4f17			 
4f17			; a small guess the number game 
4f17			 
4f17 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4f28 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4f8a			 
4f8a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4fbf .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4ff5 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5026 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
503a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
504f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5083 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
50c7			 
50c7			; Using 'ga' save a high score across multiple runs using external storage 
50c7			 
50c7 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5130			 
5130			 
5130			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5130			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5130			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5130			 
5130			; simple screen saver to test code memory reuse to destruction 
5130			 
5130 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5166 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5182 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
519e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
51b7 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
51ff .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5256			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5256			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5256			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5256			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5256			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5256			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5256			 
5256			 
5256			 
5256			; minesweeper/battleship finding game 
5256			; draws a game board of random ship/mine positions 
5256			; user enters coords to see if it hits on 
5256			; game ends when all are hit 
5256			; when hit or miss says how many may be in the area 
5256			 
5256			; setup the game board and then hide it 
5256 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
52c4 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
530e			; prompt for where to target 
530e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
53a4 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
53c9			; TODO see if the entered coords hits or misses pushes char hit of miss 
53c9 .. 00		game2mbht:      db ": mbckht nop ;",0 
53d8 .. 00		game2mbms:      db ": mbcms nop ;",0 
53e6			; TODO how many might be near by 
53e6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5463			 
5463			; Game 3 
5463			 
5463			; Vert scroller ski game - avoid the trees! 
5463			 
5463			; v0 score (ie turns) 
5463			; v1 player pos 
5463			; v2 left wall 
5463			; v3 right wall 
5463			 
5463			; Draw side walls randomly 
5463			 
5463 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5491			 
5491			; Draw player 
5491 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
54af			 
54af			; TODO Get Key 
54af			 
54af			; TODO Move left right 
54af			 
54af			; scroll and move walls a bit 
54af			 
54af .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
54e0			 
54e0			; main game loop 
54e0			 
54e0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
550c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
554b			 
554b			; key board defs 
554b			 
554b .. 00		keyup:       db ": keyup $05 ;",0 
5559 .. 00		keydown:       db ": keydown $0a ;",0 
5569 .. 00		keyleft:       db ": keyleft $0b ;",0 
5579 .. 00		keyright:       db ": keyright $0c ;",0 
558a .. 00		keyf1:       db ": keyf1 $10 ;",0 
5598 .. 00		keyf2:       db ": keyf2 $11 ;",0 
55a6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
55b4 .. 00		keyf4:       db ": keyf4 $13 ;",0 
55c2 .. 00		keyf5:       db ": keyf5 $14 ;",0 
55d0 .. 00		keyf6:       db ": keyf6 $15 ;",0 
55de .. 00		keyf7:       db ": keyf7 $16 ;",0 
55ec .. 00		keyf8:       db ": keyf8 $17 ;",0 
55fa .. 00		keyf9:       db ": keyf9 $18 ;",0 
5608 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5617 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5626 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5635			 
5635 .. 00		keytab:       db ": keytab $09 ;",0 
5644 .. 00		keycr:       db ": keycr $0d ;",0 
5652 .. 00		keyhome:       db ": keyhome $0e ;",0 
5662 .. 00		keyend:       db ": keyend $0f ;",0 
5671 .. 00		keybs:       db ": keybs $08 ;",0 
567f			 
567f			   
567f			 
567f			 
567f			 
567f			; eof 
# End of file forth_autostart.asm
567f			 
567f .. 00		sprompt1: db "Startup load...",0 
568f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
56a5			 
56a5			 
56a5			 
56a5			 
56a5			forth_startup: 
56a5 21 ae 47			ld hl, startcmds 
56a8 3e 00			ld a, 0 
56aa 32 fd e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
56ad			 
56ad e5			.start1:	push hl 
56ae cd 72 0a			call clear_display 
56b1 11 7f 56			ld de, sprompt1 
56b4 3e 00		        ld a, display_row_1 
56b6 cd 85 0a			call str_at_display 
56b9 11 8f 56			ld de, sprompt2 
56bc 3e 28		        ld a, display_row_2 
56be cd 85 0a			call str_at_display 
56c1 e1				pop hl 
56c2 e5				push hl 
56c3 5e				ld e,(hl) 
56c4 23				inc hl 
56c5 56				ld d,(hl) 
56c6 3e 50		        ld a, display_row_3 
56c8 cd 85 0a			call str_at_display 
56cb cd 95 0a			call update_display 
56ce			 
56ce			 
56ce 3a fd e7			ld a, (os_last_cmd) 
56d1 fe 00			cp 0 
56d3 28 05			jr z, .startprompt 
56d5 cd d8 09			call delay250ms 
56d8 18 24			jr .startdo 
56da				 
56da				 
56da			 
56da			.startprompt: 
56da			 
56da 3e 9f			ld a,display_row_4 + display_cols - 1 
56dc 11 81 1a		        ld de, endprg 
56df cd 85 0a			call str_at_display 
56e2 cd 95 0a			call update_display 
56e5 cd e4 09			call delay1s 
56e8 cd 57 5a			call cin_wait 
56eb						 
56eb fe 2a			cp '*' 
56ed 28 5e			jr z, .startupend1 
56ef fe 23			cp '#' 
56f1 20 07			jr nz, .startno 
56f3 3e 01			ld a, 1 
56f5 32 fd e7			ld (os_last_cmd),a 
56f8 18 04			jr .startdo 
56fa fe 31		.startno:	cp '1' 
56fc 28 3a			jr z,.startnxt  
56fe			 
56fe				; exec startup line 
56fe			.startdo:	 
56fe e1				pop hl 
56ff e5				push hl 
5700				 
5700 5e				ld e,(hl) 
5701 23				inc hl 
5702 56				ld d,(hl) 
5703 eb				ex de,hl 
5704			 
5704 e5				push hl 
5705			 
5705 3e 00			ld a, 0 
5707				;ld a, FORTH_END_BUFFER 
5707 cd 08 11			call strlent 
570a 23				inc hl   ; include zero term to copy 
570b 06 00			ld b,0 
570d 4d				ld c,l 
570e e1				pop hl 
570f 11 d7 e3			ld de, scratch 
5712 ed b0			ldir 
5714			 
5714			 
5714 21 d7 e3			ld hl, scratch 
5717 cd c2 1e			call forthparse 
571a cd 02 1f			call forthexec 
571d cd 19 1e			call forthexec_cleanup 
5720			 
5720 3e 78			ld a, display_row_4 
5722 11 25 18			ld de, endprog 
5725			 
5725 cd 95 0a			call update_display		 
5728			 
5728 3a fd e7			ld a, (os_last_cmd) 
572b fe 00			cp 0 
572d 20 09			jr nz, .startnxt 
572f cd 83 1a			call next_page_prompt 
5732 cd 72 0a		        call clear_display 
5735 cd 95 0a			call update_display		 
5738			 
5738				; move onto next startup line? 
5738			.startnxt: 
5738			 
5738 cd d8 09			call delay250ms 
573b e1				pop hl 
573c			 
573c 23				inc hl 
573d 23				inc hl 
573e			 
573e e5				push hl 
573f 5e				ld e, (hl) 
5740 23				inc hl 
5741 56				ld d, (hl) 
5742 e1				pop hl 
5743				; TODO replace 0 test 
5743			 
5743 eb				ex de, hl 
5744 cd c8 0c			call ishlzero 
5747			;	ld a,e 
5747			;	add d 
5747			;	cp 0    ; any left to do? 
5747 eb				ex de, hl 
5748 c2 ad 56			jp nz, .start1 
574b 18 01			jr .startupend 
574d			 
574d e1			.startupend1: pop hl 
574e			.startupend: 
574e			 
574e cd 72 0a			call clear_display 
5751 cd 95 0a			call update_display 
5754 c9				ret 
5755			 
5755			 
5755			; stack over and underflow checks 
5755			 
5755			; init the words to detect the under/overflow 
5755			 
5755			chk_stk_init: 
5755				; a vague random number to check so we dont get any "lucky" hits 
5755 3e 2d			ld a, 45 
5757 6f				ld l, a 
5758 00				nop 
5759 3e 17			ld a, 23 
575b 67				ld h, a 
575c			 
575c 22 be e3			ld (chk_word), hl     ; the word we need to check against 
575f			 
575f			;	ld (chk_stund), hl	; stack points.... 
575f 22 00 ef			ld (chk_stovr), hl 
5762 22 02 eb			ld (chk_ret_und), hl 
5765 22 c0 ea			ld (chk_ret_ovr), hl 
5768 22 3e ea			ld (chk_loop_ovr), hl 
576b 22 3c e9			ld (chk_data_ovr), hl 
576e c9				ret 
576f				 
576f			check_stacks: 
576f				; check all stack words 
576f			 
576f e5				push hl 
5770 d5				push de 
5771			 
5771			;	ld de,(chk_word) 
5771			;	ld hl, (chk_stund)	; stack points.... 
5771			;	if DEBUG_STK_FAULT 
5771			;		DMARK "FAa" 
5771			;		CALLMONITOR 
5771			;	endif 
5771			;	call cmp16 
5771			;	jp z, .chk_faulta 
5771			; 
5771			;	ld de, sfaultsu 
5771			;	jp .chk_fault 
5771			 
5771 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5774 ed 5b be e3		ld de,(chk_word) 
5778				if DEBUG_STK_FAULT 
5778					DMARK "FAb" 
5778					CALLMONITOR 
5778				endif 
5778 cd bd 0c			call cmp16 
577b 28 06			jr z, .chk_fault1 
577d 11 1e 58			ld de, sfaultso 
5780 c3 d2 57			jp .chk_fault 
5783			.chk_fault1:  
5783 2a 02 eb			ld hl, (chk_ret_und) 
5786 ed 5b be e3		ld de,(chk_word) 
578a				if DEBUG_STK_FAULT 
578a					DMARK "FAU" 
578a					CALLMONITOR 
578a				endif 
578a cd bd 0c			call cmp16 
578d ca 96 57			jp z, .chk_fault2 
5790 11 2e 58			ld de, sfaultru 
5793 c3 d2 57			jp .chk_fault 
5796			.chk_fault2:  
5796 2a c0 ea			ld hl, (chk_ret_ovr) 
5799 ed 5b be e3		ld de,(chk_word) 
579d				if DEBUG_STK_FAULT 
579d					DMARK "FA1" 
579d					CALLMONITOR 
579d				endif 
579d cd bd 0c			call cmp16 
57a0 ca a9 57			jp z, .chk_fault3 
57a3 11 3c 58			ld de, sfaultro 
57a6 c3 d2 57			jp .chk_fault 
57a9			.chk_fault3:  
57a9 2a 3e ea			ld hl, (chk_loop_ovr) 
57ac ed 5b be e3		ld de,(chk_word) 
57b0				if DEBUG_STK_FAULT 
57b0					DMARK "FA2" 
57b0					CALLMONITOR 
57b0				endif 
57b0 cd bd 0c			call cmp16 
57b3 ca bc 57			jp z, .chk_fault4 
57b6 11 56 58			ld de, sfaultlo 
57b9 c3 d2 57			jp .chk_fault 
57bc			.chk_fault4:  
57bc 2a 3c e9			ld hl, (chk_data_ovr) 
57bf ed 5b be e3		ld de,(chk_word) 
57c3				if DEBUG_STK_FAULT 
57c3					DMARK "FA3" 
57c3					CALLMONITOR 
57c3				endif 
57c3 cd bd 0c			call cmp16 
57c6 ca cf 57			jp z, .chk_fault5 
57c9 11 70 58			ld de, sfaultdo 
57cc c3 d2 57			jp .chk_fault 
57cf			 
57cf			 
57cf			.chk_fault5:  
57cf d1				pop de 
57d0 e1				pop hl 
57d1			 
57d1 c9				ret 
57d2			 
57d2 cd 72 0a		.chk_fault: 	call clear_display 
57d5 3e 28				ld a, display_row_2 
57d7 cd 85 0a				call str_at_display 
57da 11 00 58				   ld de, .stackfault 
57dd 3e 00				ld a, display_row_1 
57df cd 85 0a				call str_at_display 
57e2 11 71 ee				    ld de, debug_mark 
57e5 3e 11				ld a, display_row_1+17 
57e7 cd 85 0a				call str_at_display 
57ea cd 95 0a				call update_display 
57ed			 
57ed				; prompt before entering montior for investigating issue 
57ed			 
57ed 3e 78			ld a, display_row_4 
57ef 11 25 18			ld de, endprog 
57f2			 
57f2 cd 95 0a			call update_display		 
57f5			 
57f5 cd 83 1a			call next_page_prompt 
57f8			 
57f8 d1				pop de 
57f9 e1				pop hl 
57fa cd 79 18				call monitor 
57fd c3 73 17				jp warmstart 
5800					;jp 0 
5800					;halt 
5800			 
5800			 
5800			 
5800 .. 00		.stackfault: 	db "Stack fault:",0 
580d			 
580d .. 00		sfaultsu: 	db	"Stack under flow",0 
581e .. 00		sfaultso: 	db	"Stack over flow",0 
582e .. 00		sfaultru:	db "RTS underflow",0 
583c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5856 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5870 .. 00		sfaultdo:	db "DTS overflow", 0 
587d			 
587d			 
587d			fault_dsp_under: 
587d 11 8f 58			ld de, .dsp_under 
5880 c3 3f 59			jp .show_fault 
5883			 
5883			fault_rsp_under: 
5883 11 9d 58			ld de, .rsp_under 
5886 c3 3f 59			jp .show_fault 
5889			fault_loop_under: 
5889 11 ab 58			ld de, .loop_under 
588c c3 3f 59			jp .show_fault 
588f			 
588f .. 00		.dsp_under: db "DSP Underflow",0 
589d .. 00		.rsp_under: db "RSP Underflow",0 
58ab .. 00		.loop_under: db "LOOP Underflow",0 
58ba			 
58ba			 
58ba d5			type_faultn: 	push de 
58bb e5					push hl 
58bc cd 72 0a				call clear_display 
58bf 11 e6 58				   ld de, .typefaultn 
58c2 3e 00				ld a, display_row_1 
58c4 cd 85 0a				call str_at_display 
58c7 11 71 ee				    ld de, debug_mark 
58ca 3e 11				ld a, display_row_1+17 
58cc cd 85 0a				call str_at_display 
58cf cd 95 0a				call update_display 
58d2			 
58d2				; prompt before entering montior for investigating issue 
58d2			 
58d2 3e 78			ld a, display_row_4 
58d4 11 25 18			ld de, endprog 
58d7			 
58d7 cd 95 0a			call update_display		 
58da			 
58da cd 83 1a			call next_page_prompt 
58dd			 
58dd e5					push hl 
58de d5					push de 
58df cd 79 18				call monitor 
58e2 c3 73 17				jp warmstart 
58e5 76					halt 
58e6			 
58e6			 
58e6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
58fd			 
58fd d5			type_faults: 	push de 
58fe e5					push hl 
58ff cd 72 0a				call clear_display 
5902 11 28 59				   ld de, .typefaults 
5905 3e 00				ld a, display_row_1 
5907 cd 85 0a				call str_at_display 
590a 11 71 ee				    ld de, debug_mark 
590d 3e 11				ld a, display_row_1+17 
590f cd 85 0a				call str_at_display 
5912 cd 95 0a				call update_display 
5915			 
5915				; prompt before entering montior for investigating issue 
5915			 
5915 3e 78			ld a, display_row_4 
5917 11 25 18			ld de, endprog 
591a			 
591a cd 95 0a			call update_display		 
591d			 
591d cd 83 1a			call next_page_prompt 
5920			 
5920 e1					pop hl 
5921 d1					pop de 
5922 cd 79 18				call monitor 
5925 c3 73 17				jp warmstart 
5928			 
5928			 
5928 .. 00		.typefaults: db "STR Type Expected TOS!",0 
593f			 
593f			.show_fault: 	 
593f d5					push de 
5940 cd 72 0a				call clear_display 
5943 d1					pop de 
5944 3e 00				ld a, display_row_1 
5946 cd 85 0a				call str_at_display 
5949 11 71 ee				    ld de, debug_mark 
594c 3e 11				ld a, display_row_1+17 
594e cd 85 0a				call str_at_display 
5951 cd 95 0a				call update_display 
5954			 
5954				; prompt before entering montior for investigating issue 
5954			 
5954 3e 78			ld a, display_row_4 
5956 11 25 18			ld de, endprog 
5959			 
5959 cd 95 0a			call update_display		 
595c			 
595c cd 83 1a			call next_page_prompt 
595f			 
595f e1					pop hl 
5960 d1					pop de 
5961 cd 79 18				call monitor 
5964			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5964			; TODO Make optional fault restart to cli or warm boot? 
5964					;jp warmstart 
5964 c3 cb 17				jp cli 
5967 76					halt 
5968			 
5968			; handle the auto run of code from files in storage 
5968			 
5968			 
5968			if STORAGE_SE 
5968			 
5968			sprompt3: db "Loading from start-up file?:",0 
5968			sprompt4: db "(Y=Any key/N=No)",0 
5968			 
5968			 
5968			forth_autoload: 
5968			 
5968				; load block 0 of store 1 
5968				 
5968				ld a, $fe      ; bit 0 clear 
5968				ld (spi_device), a 
5968			 
5968				call storage_get_block_0 
5968			 
5968				ld a, (store_page+STORE_0_AUTOFILE) 
5968			 
5968				cp 0 
5968				ret z     ; auto start not enabled 
5968			 
5968				call clear_display 
5968			 
5968				; set bank 
5968			 
5968					ld a, (store_page+STORE_0_BANKRUN) 
5968					ld (spi_device), a 
5968			 
5968				; get file id to load from and get the file name to display 
5968			 
5968					ld a, (store_page+STORE_0_FILERUN) 
5968			 
5968					ld l, 0 
5968					ld h, a 
5968					ld de, store_page 
5968			 
5968					if DEBUG_FORTH_WORDS 
5968						DMARK "ASp" 
5968						CALLMONITOR 
5968					endif 
5968					call storage_read 
5968			 
5968					if DEBUG_FORTH_WORDS 
5968						DMARK "ASr" 
5968						CALLMONITOR 
5968					endif 
5968			 
5968					call ishlzero 
5968					ret z             ; file not found 
5968			 
5968					ld a, display_row_2 + 10 
5968					ld de, store_page+3 
5968					call str_at_display 
5968				 
5968			; 
5968			 
5968				ld a, display_row_1+5 
5968				ld de, sprompt3 
5968				call str_at_display 
5968				ld a, display_row_3+15 
5968				ld de, sprompt4 
5968				call str_at_display 
5968			 
5968				call update_display 
5968			 
5968				call cin_wait 
5968				cp 'n' 
5968				ret z 
5968				cp 'N' 
5968				ret z 
5968			 
5968				call delay1s 
5968			 
5968				ld a, (store_page+2) 
5968				ld (store_openmaxext), a    ; save count of ext 
5968				ld a, 1  
5968				ld (store_openext), a    ; save count of ext 
5968			 
5968			.autof:  
5968				ld l , a 
5968				 
5968				ld a, (store_page) 
5968				ld h, a	 
5968				ld de, store_page 
5968					if DEBUG_FORTH_WORDS 
5968						DMARK "ASl" 
5968						CALLMONITOR 
5968					endif 
5968					call storage_read 
5968				call ishlzero 
5968				ret z 
5968			;	jr z, .autoend 
5968			 
5968					if DEBUG_FORTH_WORDS 
5968						DMARK "ASc" 
5968						CALLMONITOR 
5968					endif 
5968				ld de, store_page+2 
5968				ld a, display_row_4 
5968				call str_at_display 
5968			 
5968				call update_display 
5968				call delay250ms 
5968			 
5968			 
5968			 
5968				ld hl, store_page+2 
5968				call forthparse 
5968				call forthexec 
5968				call forthexec_cleanup 
5968			 
5968				 
5968				ld a, (store_openext) 
5968				inc a 
5968				ld (store_openext), a    ; save count of ext 
5968			 
5968				jr .autof 
5968			;.autofdone: 
5968			; 
5968			;		if DEBUG_FORTH_WORDS 
5968			;			DMARK "ASx" 
5968			;			CALLMONITOR 
5968			;		endif 
5968			;;	call clear_display 
5968			;	ret 
5968			 
5968			 
5968			 
5968			endif 
5968			 
5968			 
5968			; eof 
# End of file forth_kernel.asm
5968			;include "nascombasic.asm" 
5968			 
5968			 
5968			; find out where the code ends if loaded into RAM (for SC114) 
5968			;endofcode:  
5968			;	nop 
5968			 
5968			 
5968			; eof 
5968			 
# End of file main.asm
5968			;include "firmware_lcd_4x40.asm" 
5968			;;include "firmware_lcd_4x20.asm" 
5968			include "firmware_cpm_display.asm" 
5968			 
5968			; Serial display interface for SC114 
5968			 
5968			 
5968			display_row_1: equ 0 
5968			display_row_2: equ display_row_1+display_cols 
5968			display_row_3: equ display_row_2 + display_cols 
5968			display_row_4: equ display_row_3 + display_cols 
5968			 
5968			kLCDWidth:  EQU display_cols             ;Width in characters 
5968			kLCD_Line1: EQU 0x00  
5968			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5968			; E1 
5968			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5968			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5968			 
5968			lcd_init: 
5968				; no init as handled by the SCM bios 
5968 c9				ret 
5969			 
5969			 
5969			; low level functions for direct screen writes 
5969			 
5969			; output char at pos? 
5969			fLCD_Str: 
5969			        ;out (SC114_SIO_1_OUT),a 
5969 c5				push bc 
596a d5				push de 
596b 5f				ld e, a 
596c			; TODO Replace with CP/M BIOS call 
596c 0e 02			ld c, $02 
596e cd 05 00			call 5 
5971 d1				pop de 
5972 c1				pop bc 
5973 c9				ret 
5974			 
5974			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5974			fLCD_Pos: 
5974				; use ASCII escape to position 
5974			        ;out (SC114_SIO_1_OUT),a 
5974 c5				push bc 
5975 d5				push de 
5976 5f				ld e, a 
5977 0e 02			ld c, $02 
5979			; TODO Replace with CP/M BIOS call 
5979 cd 05 00			call 5 
597c d1				pop de 
597d c1				pop bc 
597e			 
597e c9				ret 
597f			 
597f			; output char at pos 
597f			fLCD_Data: 
597f			      ;  out (SC114_SIO_1_OUT),a 
597f c5				push bc 
5980 d5				push de 
5981 0e 02			ld c, $02 
5983 5f				ld e, a 
5984			; TODO Replace with CP/M BIOS call 
5984 cd 05 00			call 5 
5987 d1				pop de 
5988 c1				pop bc 
5989			 
5989 c9				ret 
598a			 
598a			; ascii cls  
598a			 
598a 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
598e			 
598e 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
59a5			;.clscpm: db 3, $3c,"$" 
59a5			 
59a5			; write the frame buffer given in hl to hardware  
59a5			write_display: 
59a5			 
59a5			API: equ 0 
59a5			 
59a5			if API 
59a5				push bc 
59a5				ld b, 4 
59a5			 
59a5			        ld (display_write_tmp), hl 	  
59a5			 
59a5				; clear and home cursor 
59a5			 
59a5				ld c, 9 
59a5				ld de, .cls 
59a5			; TODO Replace with CP/M BIOS call 
59a5				call 5 
59a5			 
59a5			 
59a5			.writeln: 
59a5			 
59a5				ld de, (display_write_tmp) 
59a5				ld c, 6 
59a5			; TODO Replace with CP/M BIOS call 
59a5				rst $30 
59a5				ld c, 7 
59a5				rst $30 
59a5			 
59a5				ld hl, (display_write_tmp) 
59a5				ld de, display_cols 
59a5				add hl,de 
59a5				ld (display_write_tmp),hl 
59a5			 
59a5				djnz  .writeln 
59a5			 
59a5				pop bc 
59a5			 
59a5			 
59a5				ret 
59a5			endif 
59a5 e5				push hl 
59a6 c5				push bc 
59a7 d5				push de 
59a8			 
59a8			;	ld c, 2 
59a8			;	;ld de, .cls 
59a8			;	ld a, 27 
59a8			;	rst $30 
59a8			;	ld c, 2 
59a8			;	;ld de, .cls 
59a8			;	ld a, '[' 
59a8			;	rst $30 
59a8			; 
59a8			;	ld c, 2 
59a8			;	;ld de, .cls 
59a8			;	ld a, 'H' 
59a8			;	rst $30 
59a8			; 
59a8			 
59a8			 
59a8			; lots of CR/LF 
59a8			;	ld c, 9 
59a8			;	ld de, .clscpm 
59a8			;	call 5 
59a8			 
59a8			; xterm cls 
59a8 0e 02			ld c, 2 
59aa 1e 1b			ld e, 27 
59ac cd 05 00			call 5 
59af			; cls causes too much flicker 
59af			;	ld c, 2 
59af			;	ld e, 'c' 
59af			;	call 5 
59af			 
59af			; use xterm home instead 
59af 0e 02			ld c, 2 
59b1 1e 5b			ld e, '[' 
59b3 cd 05 00			call 5 
59b6 0e 02			ld c, 2 
59b8 1e 48			ld e, 'H' 
59ba cd 05 00			call 5 
59bd			LLL: equ 0 
59bd			 
59bd			if LLL 
59bd			 
59bd				ld c, 2 
59bd				;ld de, .cls 
59bd				ld e, 27 
59bd			; TODO Replace with CP/M BIOS call 
59bd				call 5 
59bd			 
59bd			 
59bd				ld c, 2 
59bd				;ld de, .cls 
59bd				ld e, '[' 
59bd			; TODO Replace with CP/M BIOS call 
59bd				call 5 
59bd				ld c, 2 
59bd				;ld de, .cls 
59bd				ld e, '2' 
59bd			; TODO Replace with CP/M BIOS call 
59bd				call 5 
59bd				ld c, 2 
59bd				;ld de, .cls 
59bd				ld e, 'J' 
59bd			; TODO Replace with CP/M BIOS call 
59bd				call 5 
59bd			 
59bd			endif 
59bd			 
59bd d1				pop de 
59be c1				pop bc 
59bf e1				pop hl 
59c0			 
59c0			 
59c0 22 cf eb		        ld (display_write_tmp), hl 	  
59c3 3e 00			ld a, kLCD_Line1 
59c5			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
59c5 06 28			ld b, display_cols 
59c7 ed 5b cf eb		ld de, (display_write_tmp) 
59cb cd 4e 5a			call write_len_string 
59ce				 
59ce			 
59ce e5			push hl 
59cf d5			push de 
59d0 c5			push bc 
59d1 0e 02			ld c, 2 
59d3 1e 0a			ld e, 10 
59d5 cd 05 00			call 5 
59d8 0e 02			ld c, 2 
59da 1e 0d			ld e, 13 
59dc cd 05 00			call 5 
59df			; TODO Replace with CP/M BIOS call 
59df				;rst $30 
59df c1			pop bc 
59e0 d1			pop de 
59e1 e1			pop hl 
59e2			 
59e2				 
59e2 2a cf eb			ld hl, (display_write_tmp) 
59e5 11 28 00			ld de, display_cols 
59e8 19				add hl,de 
59e9 22 cf eb			ld (display_write_tmp),hl 
59ec			 
59ec				 
59ec 3e 28			ld a, kLCD_Line2 
59ee			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
59ee 06 28			ld b, display_cols 
59f0 ed 5b cf eb		ld de, (display_write_tmp) 
59f4 cd 4e 5a			call write_len_string 
59f7				 
59f7 2a cf eb			ld hl, (display_write_tmp) 
59fa 11 28 00			ld de, display_cols 
59fd 19				add hl,de 
59fe 22 cf eb			ld (display_write_tmp),hl 
5a01			 
5a01 e5			push hl 
5a02 d5			push de 
5a03 c5			push bc 
5a04 0e 07			ld c, 7 
5a06			; TODO Replace with CP/M BIOS call 
5a06				;rst $30 
5a06 0e 02			ld c, 2 
5a08 1e 0a			ld e, 10 
5a0a cd 05 00			call 5 
5a0d 0e 02			ld c, 2 
5a0f 1e 0d			ld e, 13 
5a11 cd 05 00			call 5 
5a14 c1			pop bc 
5a15 d1			pop de 
5a16 e1			pop hl 
5a17			 
5a17				 
5a17 3e 50			ld a, kLCD_Line3 
5a19			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5a19 06 28			ld b, display_cols 
5a1b ed 5b cf eb		ld de, (display_write_tmp) 
5a1f cd 4e 5a			call write_len_string 
5a22				 
5a22 2a cf eb			ld hl, (display_write_tmp) 
5a25 11 28 00			ld de, display_cols 
5a28 19				add hl,de 
5a29 22 cf eb			ld (display_write_tmp),hl 
5a2c			 
5a2c e5			push hl 
5a2d d5			push de 
5a2e c5			push bc 
5a2f 0e 07			ld c, 7 
5a31			; TODO Replace with CP/M BIOS call 
5a31				;rst $30 
5a31 0e 02			ld c, 2 
5a33 1e 0a			ld e, 10 
5a35 cd 05 00			call 5 
5a38 0e 02			ld c, 2 
5a3a 1e 0d			ld e, 13 
5a3c cd 05 00			call 5 
5a3f c1			pop bc 
5a40 d1			pop de 
5a41 e1			pop hl 
5a42			 
5a42				 
5a42 3e 78			ld a, kLCD_Line4 
5a44			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5a44 06 28			ld b, display_cols 
5a46 ed 5b cf eb		ld de, (display_write_tmp) 
5a4a cd 4e 5a			call write_len_string 
5a4d c9					ret 
5a4e			 
5a4e			 
5a4e				; write out a fixed length string given in b from de 
5a4e			 
5a4e 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5a4f cd 7f 59		            CALL fLCD_Data      ;Write character to display 
5a52 13				inc de 
5a53 10 f9			djnz write_len_string 
5a55 c9				ret 
5a56			 
5a56			 
5a56			; eof 
# End of file firmware_cpm_display.asm
5a56			;include "firmware_key_5x10.asm" 
5a56			;;include "firmware_key_4x10.asm" 
5a56			include "firmware_key_cpm.asm" 
5a56			; Serial keyboard interface for SC114 
5a56			 
5a56			 
5a56			key_init: 
5a56				; no init as handled by the SCM bios 
5a56 c9				ret 
5a57			 
5a57			 
5a57			cin_wait: 
5a57			;	ld a, 0 
5a57			;	ret 
5a57			 
5a57				;in a,(SC114_SIO_1_IN) 
5a57			        ; Use SCM API to get from whatever console device we are using 
5a57			 
5a57			; TODO Replace with CP/M BIOS call 
5a57 c5				push bc 
5a58 0e 01			ld c, $01 
5a5a cd 05 00			call 5 
5a5d c1				pop bc 
5a5e c9				ret 
5a5f			 
5a5f			cin: 
5a5f			 
5a5f			 
5a5f c5				push bc 
5a60			 
5a60				; any key waiting to process? 
5a60			; TODO Replace with CP/M BIOS call 
5a60 0e 06			ld c, $06 
5a62 cd 05 00			call 5 
5a65 28 0d			jr z, .cin_skip 
5a67			 
5a67				; yep, get it 
5a67			 
5a67 0e 01			ld c, $01 
5a69			; TODO Replace with CP/M BIOS call 
5a69 cd 05 00			call 5 
5a6c			 
5a6c fe 7f			cp $7f     ; back space 
5a6e 20 02			jr nz, .skipbs 
5a70 3e 08			ld a, KEY_BS 
5a72			.skipbs: 
5a72			 
5a72 c1				pop bc 
5a73 c9				ret 
5a74			.cin_skip: 
5a74 3e 00			ld a, 0 
5a76 c1				pop bc 
5a77 c9				ret 
5a78			 
5a78			 
5a78			 
5a78			 
# End of file firmware_key_cpm.asm
5a78			endofcode:  
5a78			baseram:  
5a78 00				nop 
5a79			 
5a79			heap_start: equ baseram+15  ; Starting address of heap 
5a79			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5a79			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5a79			;VDU:  EQU     endofcode           ; BASIC Work space 
5a79			; eof 
5a79			 
# End of file os_mega_cpm.asm
5a79
