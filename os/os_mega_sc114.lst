# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 b3 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-09 10:39' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			; cursor blink rate  
801b			CUR_BLINK_RATE: equ $09  
801b			;CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 85 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd 27 e4			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd e3 90				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 11 96			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 26 96			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd ca 90				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 9d 90			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd cf 9d			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd 18 9a			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd 9c e3			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd 28 e4				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			 
8d08 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 66 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 c1 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d					ld a, 255 
8d1d			else 
8d1d 3e 23				ld a, '#' 
8d1f			endif 
8d1f 77					ld (hl), a 
8d20 23					inc hl 
8d21 3e 00				ld a, 0 
8d23 77					ld (hl), a 
8d24			 
8d24 3e 09				ld a, CUR_BLINK_RATE 
8d26 32 60 ee				ld (input_cur_flash), a 
8d29 3e 01				ld a, 1 
8d2b 32 5f ee				ld (input_cur_onoff),a 
8d2e			.inmain:	 
8d2e			 
8d2e cd a7 8e				call input_disp_ref 
8d31			 
8d31					; save current length of string 
8d31			 
8d31 2a 67 ee				ld hl, (input_start) 
8d34 3e 00				ld a, 0 
8d36 cd 9d 90				call strlent 
8d39 7d					ld a,l 
8d3a 32 5a ee				ld (input_len), a 
8d3d			 
8d3d					;call input_disp_oncur 
8d3d			 
8d3d					; display current state of input buffer 
8d3d			 
8d3d					; clean any backspace chars 
8d3d			 
8d3d 3e 20				ld a, " " 
8d3f 32 c1 e2				ld (scratch),a 
8d42 3e 00				ld a, 0 
8d44 32 c2 e2				ld (scratch+1),a 
8d47 3a 64 ee				ld a,(input_at_pos) 
8d4a 85					add l 
8d4b 11 c1 e2				ld de, scratch 
8d4e cd c1 8a				call str_at_display 
8d51			 
8d51					; pause 1ms 
8d51			 
8d51 3e 01				ld a, 1 
8d53 cd d6 89				call aDelayInMS 
8d56			 
8d56			; display cursor if visible on this cycle 
8d56			 
8d56					; dec flash counter 
8d56 3a 60 ee				ld a, (input_cur_flash) 
8d59 3d					dec a 
8d5a 32 60 ee				ld (input_cur_flash), a 
8d5d fe 00				cp 0 
8d5f 20 0d				jr nz, .inochgstate 
8d61			 
8d61			 
8d61					; reset on change of state 
8d61 3e 09				ld a, CUR_BLINK_RATE 
8d63 32 60 ee				ld (input_cur_flash), a 
8d66			 
8d66					; change state 
8d66 3a 5f ee				ld a,(input_cur_onoff) 
8d69 ed 44				neg 
8d6b 32 5f ee				ld (input_cur_onoff),a 
8d6e			 
8d6e			 
8d6e			 
8d6e			 
8d6e					; TODO is cursor visible? 
8d6e					; TODO if so then over write the char at curspos pos with the cursor shape 
8d6e			 
8d6e								 
8d6e			 
8d6e			.inochgstate: 
8d6e 3a 5f ee				ld a,(input_cur_onoff) 
8d71 fe ff				cp 255 
8d73 28 0e				jr z, .skipcursor 
8d75 3a 64 ee				ld a, (input_at_pos) 
8d78 47					ld b, a 
8d79 3a 55 ee				ld a, (input_cursor) 
8d7c 80					add b 
8d7d 11 c1 eb				ld de, cursor_shape 
8d80					 
8d80 cd c1 8a				call str_at_display 
8d83			 
8d83			.skipcursor: 
8d83				if DEBUG_INPUTV2 
8d83			 
8d83 3a 64 ee				ld a,(input_at_pos) 
8d86 21 ad eb				ld hl, LFSRSeed 
8d89 cd 35 8f				call hexout 
8d8c 3a 55 ee				ld a, (input_cursor) 
8d8f 21 af eb				ld hl, LFSRSeed+2 
8d92 cd 35 8f				call hexout 
8d95 3a 66 ee				ld a,(input_size) 
8d98 21 b1 eb				ld hl, LFSRSeed+4 
8d9b cd 35 8f				call hexout 
8d9e			 
8d9e 3a 5f ee				ld a,(input_cur_onoff) 
8da1 21 b3 eb				ld hl, LFSRSeed+6 
8da4 cd 35 8f				call hexout 
8da7			 
8da7 3a 60 ee				ld a,(input_cur_flash) 
8daa 21 b5 eb				ld hl, LFSRSeed+8 
8dad cd 35 8f				call hexout 
8db0			 
8db0 3a 5a ee				ld a,(input_len) 
8db3 21 b7 eb				ld hl, LFSRSeed+10 
8db6 cd 35 8f				call hexout 
8db9 21 b9 eb				ld hl, LFSRSeed+12 
8dbc 3e 00				ld a, 0 
8dbe 77					ld (hl),a 
8dbf 3e 78				ld a, display_row_4 
8dc1 11 ad eb				ld de, LFSRSeed 
8dc4 cd c1 8a				call str_at_display 
8dc7				endif 
8dc7 cd d1 8a				call update_display 
8dca			 
8dca					; TODO keyboard processing 
8dca			 
8dca			if BASE_CPM 
8dca					call cin_wait 
8dca			else 
8dca cd 2e e4				call cin    ; _wait 
8dcd			endif 
8dcd fe 00				cp 0 
8dcf ca 2e 8d				jp z, .inmain 
8dd2			 
8dd2 fe 0b				cp KEY_LEFT    ; cursor left 
8dd4 ca 99 8e				jp z, input_left 
8dd7				 
8dd7 fe 0c				cp KEY_RIGHT      ; cursor right 
8dd9 ca a0 8e				jp z, input_right 
8ddc			 
8ddc fe 0d				cp KEY_CR 
8dde c8					ret z 
8ddf			 
8ddf fe 08				cp KEY_BS 
8de1 ca 0e 8f				jp z, input_delchar 
8de4			 
8de4 fe 06				cp KEY_NEXTWORD 
8de6 ca 1a 8e				jp z, input_nxtword 
8de9			 
8de9 fe 07				cp KEY_PREVWORD 
8deb ca 41 8e				jp z, input_prvword 
8dee			 
8dee fe 0e				cp KEY_HOME    ; jump to start of line 
8df0 20 08				jr nz, .ikh 
8df2 3e 00				ld a, 0 
8df4 32 55 ee				ld (input_cursor), a 
8df7 ca 2e 8d				jp z, .inmain 
8dfa			.ikh: 
8dfa			 
8dfa fe 0f				cp KEY_END     ; jump to end of line 
8dfc 20 09				jr nz, .ike 
8dfe 3a 5a ee				ld a, (input_len) 
8e01 32 55 ee				ld (input_cursor),a 
8e04 ca 2e 8d				jp z, .inmain 
8e07			.ike: 
8e07 fe 05			        cp KEY_UP      ; recall last command 
8e09 20 0c				jr nz, .irec 
8e0b			; TODO next word 
8e0b			; TODO prev word 
8e0b			;  
8e0b			; 
8e0b 21 c1 e2			ld hl, scratch 
8e0e 11 e7 e6			ld de, os_last_cmd 
8e11 cd 2b 8f			call strcpy 
8e14 ca 2e 8d				jp z, .inmain 
8e17			.irec: 
8e17			;		jr .instr1 
8e17			 
8e17			 
8e17					; if no special key then insert as a char 
8e17			 
8e17 c3 e0 8e				jp input_inschr 
8e1a			 
8e1a				 
8e1a			input_nxtword: 
8e1a				; jump to start next word after the cursor 
8e1a			 
8e1a			.insknwn:	 
8e1a cd d6 8e				call input_curptr	 
8e1d 7e					ld a,(hl)	 
8e1e fe 00				cp 0 
8e20 ca 2e 8d				jp z, .inmain    ; end of string 
8e23			 
8e23			; if we are on a word, then move off of it 
8e23			 
8e23 fe 20				cp ' ' 
8e25 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8e27 21 55 ee				ld hl, input_cursor 
8e2a 34					inc (hl) 
8e2b 18 ed				jr .insknwn 
8e2d			 
8e2d			.inspace: 
8e2d			 
8e2d cd d6 8e				call input_curptr	 
8e30 7e					ld a,(hl)	 
8e31 fe 00				cp 0 
8e33 ca 2e 8d				jp z, .inmain    ; end of string 
8e36			 
8e36			; if we are on a word, then move off of it 
8e36			 
8e36 fe 20				cp ' ' 
8e38 c2 2e 8d				jp nz, .inmain     ; we are on non space so at next word 
8e3b 21 55 ee				ld hl, input_cursor 
8e3e 34					inc (hl) 
8e3f 18 ec				jr .inspace 
8e41			 
8e41			 
8e41			 
8e41			 
8e41			input_prvword: 
8e41				; jump to the start of previous word before the cursor 
8e41			 
8e41			; where are we to start with currently? 
8e41			 
8e41 cd d6 8e				call input_curptr	 
8e44 7e					ld a, (hl) 
8e45 fe 20				cp ' ' 
8e47 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e49			 
8e49			 
8e49			 
8e49			.inskpwn:	 
8e49 3a 55 ee				ld a,(input_cursor) 
8e4c fe 00				cp 0 
8e4e ca 2e 8d				jp z, .inmain    ; start of string 
8e51			 
8e51			;if we are on a word, then move off of it 
8e51			 
8e51 cd d6 8e				call input_curptr	 
8e54 7e					ld a, (hl) 
8e55 fe 20				cp ' ' 
8e57 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e59					;jp z, .inmain    ; start of string 
8e59 21 55 ee				ld hl, input_cursor 
8e5c 35					dec (hl) 
8e5d 18 ea				jr .inskpwn 
8e5f			.iwstart: 
8e5f 21 55 ee				ld hl, input_cursor 
8e62 34					inc (hl) 
8e63 c3 2e 8d				jp .inmain 
8e66					 
8e66			 
8e66			.inspacep: 
8e66			 
8e66					;jp .inmain    ; start of string 
8e66			 
8e66			 
8e66			 
8e66 3a 55 ee				ld a,(input_cursor) 
8e69 fe 00				cp 0 
8e6b ca 2e 8d				jp z, .inmain    ; start of string 
8e6e			 
8e6e			; if we are on a word, then move off of it 
8e6e			 
8e6e cd d6 8e				call input_curptr	 
8e71 7e					ld a, (hl) 
8e72 fe 20				cp ' ' 
8e74 c2 7d 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e77 21 55 ee				ld hl, input_cursor 
8e7a 35					dec (hl) 
8e7b 18 e9				jr .inspacep 
8e7d			 
8e7d			 
8e7d			.incharp:	 
8e7d					; eat the word to get to the start 
8e7d 3a 55 ee				ld a,(input_cursor) 
8e80 fe 00				cp 0 
8e82 ca 2e 8d				jp z, .inmain    ; start of string 
8e85			 
8e85			; if we are on a word, then move off of it 
8e85			 
8e85 cd d6 8e				call input_curptr	 
8e88 7e					ld a, (hl) 
8e89 fe 20				cp ' ' 
8e8b 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e8d 21 55 ee				ld hl, input_cursor 
8e90 35					dec (hl) 
8e91 18 ea				jr .incharp 
8e93			.ipwordst: 
8e93					; at space before the prev word so reposition over it 
8e93 21 55 ee				ld hl, input_cursor 
8e96 34					inc (hl) 
8e97 18 b0				jr .inskpwn 
8e99					 
8e99			 
8e99			 
8e99			input_left: 
8e99				; move cursor left 
8e99 21 55 ee			ld hl, input_cursor 
8e9c 35				dec (hl) 
8e9d			;	cp 0 
8e9d			;	jp z, .inmain    ; ignore left as at the start of the string 
8e9d c3 2e 8d			jp .inmain 
8ea0			 
8ea0			input_right: 
8ea0				; move cursor right 
8ea0				 
8ea0				;ld a, (input_size) 
8ea0				;ld b, a 
8ea0 21 55 ee			ld hl, input_cursor 
8ea3 34				inc (hl) 
8ea4				;dec b 
8ea4				;cp 0 
8ea4				;jp z, .inmain   ; ignore as at end of the string buffer 
8ea4				;ld a, b 
8ea4				;inc a 
8ea4				;ld (input_cursor), a 
8ea4 c3 2e 8d			jp .inmain 
8ea7			 
8ea7			 
8ea7			 
8ea7			input_disp_ref: 
8ea7				; display the text from start of buffer (ie full refresh) 
8ea7 3a 64 ee			ld a, (input_at_pos) 
8eaa 2a 67 ee			ld hl,(input_start) 
8ead eb				ex de, hl 
8eae cd c1 8a			call str_at_display  
8eb1 c9				ret 
8eb2			input_disp_oncur: 
8eb2				; display the text from cursor position to end of buffer 
8eb2				; TODO position start of string at cursor position on screen 
8eb2				; TODO draw from that point on 
8eb2 3a 55 ee			ld a, (input_cursor) 
8eb5 47				ld b, a 
8eb6 3a 64 ee			ld a, (input_at_pos) 
8eb9 80				add b 
8eba 48				ld c, b     ; save a 
8ebb 78				ld a, b     ; inc string start for cursor 
8ebc 2a 67 ee			ld hl,(input_start) 
8ebf cd db 8c			call addatohl 
8ec2 eb				ex de, hl 
8ec3 79				ld a, c 
8ec4 cd c1 8a			call str_at_display  
8ec7 c9				ret 
8ec8			 
8ec8			input_nxtw: 
8ec8				; Find next word 
8ec8 c9				ret 
8ec9			 
8ec9			input_prvw: 
8ec9				; Find previous word 
8ec9 c9				ret 
8eca			 
8eca			input_lenrem:   
8eca				; Calculate the length of string remaining from current cursor 
8eca				; position to end of buffer (exc null term) 
8eca				 
8eca 3a 55 ee			ld a, (input_cursor) 
8ecd 4f				ld c, a 
8ece 3a 66 ee			ld a, (input_size) 
8ed1 91				sub c 
8ed2 06 00			ld b, 0 
8ed4 0d				dec c 
8ed5 c9				ret	 
8ed6			 
8ed6			input_curptr: 
8ed6				; calc address of the character under the cursor 
8ed6				 
8ed6 2a 67 ee			ld hl, (input_start) 
8ed9 3a 55 ee			ld a, (input_cursor) 
8edc cd db 8c			call addatohl 
8edf c9				ret 
8ee0			 
8ee0			input_inschr: 
8ee0				; Insert char at cursor position 
8ee0 f5				push af   ; save char 
8ee1				;call input_lenrem    ; get bc length of remaining string 
8ee1			 
8ee1				 
8ee1 cd d6 8e			call input_curptr 
8ee4			;	ld hl, (input_start) 
8ee4			;	ld a, (input_cursor) 
8ee4			;	call addatohl 
8ee4				;push hl   ; save to come back to 
8ee4			 
8ee4				; shift everything up one to end of buffer 
8ee4			 
8ee4				;push hl 
8ee4				;dec de 
8ee4				;inc de 
8ee4			;	ldir 
8ee4				 
8ee4				;pop hl 
8ee4			 
8ee4				; are we adding to the end of line? 
8ee4			 
8ee4 3a 55 ee			ld a, (input_cursor) 
8ee7 47				ld b, a 
8ee8 3a 5a ee			ld a, (input_len) 
8eeb b8				cp b 
8eec 20 09			jr nz, .insmid   ; no, insert in middle of text 
8eee			 
8eee				; tack on the end of the line 
8eee f1				pop af 
8eef 77				ld (hl), a   ; save new char 
8ef0 23				inc hl 
8ef1 3e 00			ld a, 0 
8ef3 77				ld (hl), a 
8ef4 c3 a0 8e			jp input_right 
8ef7				 
8ef7			.insmid: 
8ef7				; hl has insertion point so move everything up one to allow for insertion 
8ef7				;call input_shiftright 
8ef7 f1				pop af 
8ef8			 
8ef8			.shufinsmid: 
8ef8 47				ld b, a     ; b contains new char, c prev char at this position  
8ef9 7e				ld a, (hl) 
8efa			 
8efa fe 00			cp 0    ; at end of string need to then dump new char and add term 
8efc 28 07			jr z, .endinsmid 
8efe 4f				ld c, a 
8eff 78				ld a, b 
8f00 77				ld (hl), a 
8f01 23				inc hl 
8f02 79				ld a, c 
8f03 18 f3			jr .shufinsmid 
8f05				 
8f05			 
8f05			 
8f05			 
8f05			.endinsmid: 
8f05 78				ld a, b 
8f06 77				ld (hl), a 
8f07 23				inc hl 
8f08 3e 00			ld a, 0 
8f0a 77				ld (hl), a 
8f0b			 
8f0b			 
8f0b			;	ld (hl), a   ; save new char 
8f0b			 
8f0b c3 a0 8e			jp input_right 
8f0e			 
8f0e			;input_shiftright: 
8f0e			;	; shift text right at cursor, hl has shift start 
8f0e			;	push hl 
8f0e			;	push de 
8f0e			;	push bc 
8f0e			; 
8f0e			; 
8f0e			;	; move to end of string past zero term 
8f0e			;	ld hl,(input_start) 
8f0e			;	ld a, (input_len) 
8f0e			;	call addatohl 
8f0e			;	inc hl 
8f0e			;;	inc hl 
8f0e			;;	inc hl 
8f0e			;	ld a, 0 
8f0e			;	ld (hl), a 
8f0e			;;	dec hl 
8f0e			;	 
8f0e			;;	ld (hl), a 
8f0e			;;	dec hl 
8f0e			; 
8f0e			;	push hl 
8f0e			;	pop de 
8f0e			;	inc de 
8f0e			;	 
8f0e			; 
8f0e			;;	ld hl,(input_start) 
8f0e			;;	ld a, (input_cursor) 
8f0e			;;	call addatohl 
8f0e			; 
8f0e			; 
8f0e			;	; calc how many bytes from cursor pos to end of string we need to shift 
8f0e			;	call input_lenrem    ; get bc length of remaining string 
8f0e			;	;ld a, (input_cursor) 
8f0e			;	;ld c, a 
8f0e			;	ld a, (input_len) 
8f0e			;	cp 2 
8f0e			;	jr z, .iskipzero	 
8f0e			;	;sub c 
8f0e			;	;inc a 
8f0e			;	;ld c, a 
8f0e			;	;ld b, 0 
8f0e			;	inc c 
8f0e			;	inc c 
8f0e			;	; move data 
8f0e			;	lddr 
8f0e			;.iskipzero: 
8f0e			; 
8f0e			;	pop bc 
8f0e			;	pop de 
8f0e			;	pop hl 
8f0e			;	ret	 
8f0e			 
8f0e			input_delchar: 
8f0e				; Delete char at cursor position 
8f0e cd ca 8e			call input_lenrem    ; get bc length of remaining string 
8f11 2a 67 ee			ld hl, (input_start) 
8f14 3a 55 ee			ld a, (input_cursor) 
8f17 cd db 8c			call addatohl 
8f1a			 
8f1a e5				push hl 
8f1b d1				pop de 
8f1c 1b				dec de 
8f1d			 
8f1d			.dl:	 
8f1d ed a0			ldi  
8f1f 7e				ld a, (hl) 
8f20 fe 00			cp 0 
8f22 28 02			jr z, .dldone 
8f24 18 f7			jr .dl 
8f26			.dldone: 
8f26 ed a0			ldi 
8f28			 
8f28 c3 99 8e			jp input_left 
8f2b			 
8f2b			 
8f2b			endif 
8f2b			 
8f2b			 
8f2b			 
8f2b			if EDIT_V1 
8f2b			input_str: 
8f2b			 
8f2b				    	ld (input_at_pos),a      ; save display position to start 
8f2b					add c 
8f2b					ld (input_at_cursor),a	; save draw pos of cursor 
8f2b					ld (input_start), hl     ; save ptr to buffer 
8f2b					ld a, c 
8f2b					call addatohl 
8f2b					ld (input_ptr), hl     ; save ptr to point under the cursor 
8f2b					ld a,d 
8f2b				        ld (input_size), a       ; save length of input area 
8f2b					ld a, c 
8f2b					ld (input_cursor),a      ; init cursor start position  
8f2b					ld a,e 
8f2b				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8f2b					 
8f2b					 
8f2b			 
8f2b			;		ld a,(input_ptr) 
8f2b			;		ld (input_under_cursor),a 	; save what is under the cursor 
8f2b			 
8f2b			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8f2b					; init cursor shape if not set by the cin routines 
8f2b					ld hl, cursor_shape 
8f2b			if BASE_KEV 
8f2b					ld a, 255 
8f2b			else 
8f2b					ld a, '#' 
8f2b			endif 
8f2b					ld (hl), a 
8f2b					inc hl 
8f2b					ld a, 0 
8f2b					ld (hl), a 
8f2b			 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b					ld a, 1 
8f2b					ld (input_cur_onoff),a 
8f2b			 
8f2b			;	if DEBUG_INPUT 
8f2b			;		push af 
8f2b			;		ld a, 'I' 
8f2b			;		ld (debug_mark),a 
8f2b			;		pop af 
8f2b			;		CALLMONITOR 
8f2b			;	endif 
8f2b			.is1:		; main entry loop 
8f2b			 
8f2b			 
8f2b			 
8f2b					; pause 1ms 
8f2b			 
8f2b					ld a, 1 
8f2b					call aDelayInMS 
8f2b			 
8f2b					; dec flash counter 
8f2b					ld a, (input_cur_flash) 
8f2b					dec a 
8f2b					ld (input_cur_flash), a 
8f2b					cp 0 
8f2b					jr nz, .nochgstate 
8f2b			 
8f2b			 
8f2b					; change state 
8f2b					ld a,(input_cur_onoff) 
8f2b					neg 
8f2b					ld (input_cur_onoff),a 
8f2b			 
8f2b			 
8f2b					; reset on change of state 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b			 
8f2b			.nochgstate: 
8f2b					 
8f2b					 
8f2b			 
8f2b					; display cursor  
8f2b			 
8f2b			;		ld hl, (input_start) 
8f2b			;		ld a, (input_cursor) 
8f2b			;		call addatohl 
8f2b			 
8f2b					; get char under cursor and replace with cursor 
8f2b			ld hl, (input_ptr) 
8f2b			;		ld a, (hl) 
8f2b			;		ld (input_under_cursor),a 
8f2b			;		ld a, '_' 
8f2b			;		ld (hl), a 
8f2b			 
8f2b					; display string 
8f2b			 
8f2b					ld de, (input_start) 
8f2b					ld a, (input_at_pos) 
8f2b					call str_at_display 
8f2b			;	        call update_display 
8f2b			 
8f2b					; find place to put the cursor 
8f2b			;		add h 
8f2b			;		ld l, display_row_1 
8f2b			;		sub l 
8f2b			; (input_at_pos) 
8f2b					;ld c, a 
8f2b			;		ld a, (input_cursor) 
8f2b			;		ld l, (input_at_pos) 
8f2b			;		;ld b, h 
8f2b			;		add l 
8f2b			;		ld (input_at_cursor),a 
8f2b					;ld l,h 
8f2b			 
8f2b			;		ld h, 0 
8f2b			;		ld l,(input_at_pos) 
8f2b			;		ld a, (input_cursor) 
8f2b			;		call addatohl 
8f2b			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8f2b			;		call subafromhl 
8f2b			;		ld a,l 
8f2b			;		ld (input_at_cursor), a 
8f2b			 
8f2b				if DEBUG_INPUT 
8f2b					ld a, (hardware_diag) 
8f2b					cp 0 
8f2b					jr z, .skip_input_diag 
8f2b			 
8f2b					ld a,(input_at_pos) 
8f2b					ld hl, LFSRSeed 
8f2b					call hexout 
8f2b					ld a, (input_cursor) 
8f2b					ld hl, LFSRSeed+2 
8f2b					call hexout 
8f2b					ld a,(input_at_cursor) 
8f2b					ld hl, LFSRSeed+4 
8f2b					call hexout 
8f2b			 
8f2b					ld a,(input_cur_onoff) 
8f2b					ld hl, LFSRSeed+6 
8f2b					call hexout 
8f2b			 
8f2b					ld a,(input_cur_flash) 
8f2b					ld hl, LFSRSeed+8 
8f2b					call hexout 
8f2b			 
8f2b					ld a,(input_len) 
8f2b					ld hl, LFSRSeed+10 
8f2b					call hexout 
8f2b					ld hl, LFSRSeed+12 
8f2b					ld a, 0 
8f2b					ld (hl),a 
8f2b					ld a, display_row_4 
8f2b					ld de, LFSRSeed 
8f2b					call str_at_display 
8f2b					.skip_input_diag: 
8f2b				endif 
8f2b			 
8f2b					; decide on if we are showing the cursor this time round 
8f2b			 
8f2b					ld a, (input_cur_onoff) 
8f2b					cp 255 
8f2b					jr z, .skipcur 
8f2b			 
8f2b			 
8f2b					ld a,(input_at_cursor) 
8f2b					ld de, cursor_shape 
8f2b					call str_at_display 
8f2b			 
8f2b					; save length of current input string 
8f2b					ld hl, (input_start) 
8f2b					ld a, 0 
8f2b					call strlent 
8f2b					ld a,l 
8f2b					ld (input_len),a 
8f2b			 
8f2b			.skipcur: 
8f2b			 
8f2b				        call update_display 
8f2b					 
8f2b			 
8f2b			 
8f2b					; wait 
8f2b				 
8f2b					; TODO loop without wait to flash the cursor and char under cursor	 
8f2b					call cin    ; _wait 
8f2b			 
8f2b					cp 0 
8f2b					jp z, .is1 
8f2b			 
8f2b					; get ptr to char to input into 
8f2b			 
8f2b					ld c,a 
8f2b					ld hl, (input_start) 
8f2b					ld a, (input_cursor) 
8f2b					call addatohl 
8f2b					ld (input_ptr), hl 
8f2b					ld a,c 
8f2b			 
8f2b					; replace char under cursor 
8f2b			 
8f2b			;		ld hl, (input_ptr) 
8f2b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8f2b			;		ld (hl), a 
8f2b			 
8f2b			;	if DEBUG_INPUT 
8f2b			;		push af 
8f2b			;		ld a, 'i' 
8f2b			;		ld (debug_mark),a 
8f2b			;		pop af 
8f2b			;		CALLMONITOR 
8f2b			;	endif 
8f2b					cp KEY_HOME 
8f2b					jr nz, .iske 
8f2b			 
8f2b					ld a, (input_at_pos) 
8f2b					ld (input_at_cursor),a 
8f2b					ld a, 0 
8f2b					ld (input_cursor), a 
8f2b					jp .is1 
8f2b					 
8f2b			.iske:		cp KEY_END 
8f2b					jr nz, .isknw 
8f2b					jp .is1 
8f2b			 
8f2b			.isknw:		cp KEY_NEXTWORD 
8f2b					jr nz, .iskpw 
8f2b			 
8f2b			.isknwm:	ld hl, (input_ptr) 
8f2b					ld a,(hl)	 
8f2b					cp 0 
8f2b					jp z, .is1    ; end of string 
8f2b					cp ' ' 
8f2b					jp z, .is1    ; end of word 
8f2b					inc hl 
8f2b					ld (input_ptr), hl 
8f2b					ld a, (input_at_cursor) 
8f2b					inc a 
8f2b					ld (input_at_cursor), a 
8f2b					jr .isknwm 
8f2b			 
8f2b			.iskpw:		cp KEY_PREVWORD 
8f2b					jr nz, .iskl 
8f2b			.iskpwm:	 
8f2b					ld hl, (input_ptr) 
8f2b					ld a,(hl)	 
8f2b					cp 0  
8f2b					jp z, .is1    ; end of string 
8f2b					cp ' ' 
8f2b					jp z, .is1    ; end of word 
8f2b					dec hl 
8f2b					ld (input_ptr), hl 
8f2b					ld a, (input_at_cursor) 
8f2b					dec a 
8f2b					ld (input_at_cursor), a 
8f2b					jr .iskpwm 
8f2b			 
8f2b			 
8f2b			.iskl:		cp KEY_LEFT 
8f2b					jr nz, .isk1 
8f2b			 
8f2b					ld a, (input_cursor) 
8f2b			 
8f2b					cp 0 
8f2b					jp z, .is1 		; at start of line to ignore  
8f2b			 
8f2b					dec  a 		; TODO check underflow 
8f2b					ld (input_cursor), a 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					dec hl 
8f2b					ld (input_ptr), hl 
8f2b					 
8f2b					ld a, (input_at_cursor) 
8f2b					dec a 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b					ld a, 1		; show cursor moving 
8f2b					ld (input_cur_onoff),a 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b			 
8f2b					jp .is1 
8f2b			 
8f2b			.isk1:		cp KEY_RIGHT 
8f2b					jr nz, .isk2 
8f2b			 
8f2b					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8f2b					ld e,a 
8f2b					ld a, (input_cursor) 
8f2b					cp e 
8f2b					jp z, .is1		; at the end of string so dont go right 
8f2b			 
8f2b					inc  a 		; TODO check overflow 
8f2b					ld (input_cursor), a 
8f2b			 
8f2b					ld a, (input_at_cursor) 
8f2b					inc a 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					inc hl 
8f2b					ld (input_ptr), hl 
8f2b			 
8f2b					ld a, 1		; show cursor moving 
8f2b					ld (input_cur_onoff),a 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b			 
8f2b					jp .is1 
8f2b			 
8f2b			.isk2:		cp KEY_UP 
8f2b			 
8f2b					jr nz, .isk3 
8f2b			 
8f2b					; swap last command with the current on 
8f2b			 
8f2b					; move cursor to start of string 
8f2b					ld hl, (input_start) 
8f2b					ld (input_ptr), hl 
8f2b			 
8f2b					ld a, (input_at_pos) 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b					ld a, 0 
8f2b					ld (input_cursor), a 
8f2b					 
8f2b					; swap input and last command buffers 
8f2b			 
8f2b					ld hl, os_cli_cmd 
8f2b					ld de, os_last_cmd 
8f2b					ld b, 255 
8f2b			.swap1:		ld a, (hl) 
8f2b					ld c,a 
8f2b					ld a, (de) 
8f2b					ld (hl), a 
8f2b					ld a,c 
8f2b					ld (de),a 
8f2b					inc hl 
8f2b					inc de 
8f2b					djnz .swap1 
8f2b			 
8f2b			 
8f2b			 
8f2b			 
8f2b			 
8f2b					jp .is1 
8f2b			 
8f2b			.isk3:		cp KEY_BS 
8f2b					jr nz, .isk4 
8f2b			 
8f2b					ld a, (input_cursor) 
8f2b			 
8f2b					cp 0 
8f2b					jp z, .is1 		; at start of line to ignore  
8f2b			 
8f2b					dec  a 		; TODO check underflow 
8f2b					ld (input_cursor), a 
8f2b			 
8f2b					; hl is source 
8f2b					; de needs to be source - 1 
8f2b			 
8f2b			;		ld a, 0 
8f2b			;		dec hl 
8f2b			;		ld (hl), a 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					dec hl 
8f2b					ld (input_ptr), hl 
8f2b			 
8f2b					; shift all data 
8f2b			 
8f2b					push hl 
8f2b					inc hl 
8f2b					pop de 
8f2b					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8f2b					ld c,a 
8f2b					ld b,0 
8f2b					ldir  
8f2b			 
8f2b			 
8f2b			 
8f2b			 
8f2b					ld a, (input_at_cursor) 
8f2b					dec a 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b			 
8f2b					ld a, 1		; show cursor moving 
8f2b					ld (input_cur_onoff),a 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b			 
8f2b					; remove char 
8f2b					ld a, (input_at_cursor) 
8f2b					inc a 
8f2b					ld de,.iblank 
8f2b					call str_at_display 
8f2b			 
8f2b					jp .is1 
8f2b			 
8f2b			.isk4:		cp KEY_CR 
8f2b					jr z, .endinput 
8f2b			 
8f2b					; else add the key press to the end 
8f2b			 
8f2b					ld c, a			; save key pressed 
8f2b			 
8f2b					ld a,(hl)		; get what is currently under char 
8f2b			 
8f2b					cp 0			; we are at the end of the string 
8f2b					jr nz, .onchar 
8f2b					 
8f2b					; add a char to the end of the string 
8f2b				 
8f2b					ld (hl),c 
8f2b					inc hl 
8f2b			;		ld a,' ' 
8f2b			;		ld (hl),a 
8f2b			;		inc hl 
8f2b					ld a,0 
8f2b					ld (hl),a 
8f2b					dec hl 
8f2b			 
8f2b					ld a, (input_cursor) 
8f2b					inc a				; TODO check max string length and scroll  
8f2b					ld (input_cursor), a		; inc cursor pos 
8f2b							 
8f2b					ld a, (input_at_cursor) 
8f2b					inc a 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					inc hl 
8f2b					ld (input_ptr), hl 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					inc hl 
8f2b					ld (input_ptr), hl 
8f2b			;	if DEBUG_INPUT 
8f2b			;		push af 
8f2b			;		ld a, '+' 
8f2b			;		ld (debug_mark),a 
8f2b			;		pop af 
8f2b			;		CALLMONITOR 
8f2b			;	endif 
8f2b					ld a, 1		; show cursor moving 
8f2b					ld (input_cur_onoff),a 
8f2b					ld a, CUR_BLINK_RATE 
8f2b					ld (input_cur_flash), a 
8f2b					jp .is1 
8f2b					 
8f2b			 
8f2b			 
8f2b					; if on a char then insert 
8f2b			.onchar: 
8f2b			 
8f2b					; TODO over flow check: make sure insert does not blow out buffer 
8f2b			 
8f2b					; need to do some maths to use lddr 
8f2b			 
8f2b					push hl   ; save char pos 
8f2b					push bc 
8f2b			 
8f2b					ld hl, (input_start) 
8f2b					ld a, (input_len) 
8f2b					call addatohl  		; end of string 
8f2b					inc hl 
8f2b					inc hl		; past zero term 
8f2b					push hl 
8f2b					inc hl 
8f2b					push hl  
8f2b			 
8f2b								; start and end of lddr set, now how much to move? 
8f2b			 
8f2b							 
8f2b					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8f2b					ld b,a 
8f2b					ld a,(input_len) 
8f2b					ld e,a 
8f2b					sub b 
8f2b					inc a		;?? 
8f2b					inc a		;?? 
8f2b					inc a		;?? 
8f2b			 
8f2b					ld b,0 
8f2b					ld c,a 
8f2b			 
8f2b				if DEBUG_INPUT 
8f2b					push af 
8f2b					ld a, 'i' 
8f2b					ld (debug_mark),a 
8f2b					pop af 
8f2b			;		CALLMONITOR 
8f2b				endif 
8f2b					pop de 
8f2b					pop hl 
8f2b				if DEBUG_INPUT 
8f2b					push af 
8f2b					ld a, 'I' 
8f2b					ld (debug_mark),a 
8f2b					pop af 
8f2b			;		CALLMONITOR 
8f2b				endif 
8f2b					lddr 
8f2b				 
8f2b			 
8f2b			 
8f2b					; TODO have a key for insert/overwrite mode???? 
8f2b					pop bc 
8f2b					pop hl 
8f2b					ld (hl), c		; otherwise overwrite current char 
8f2b					 
8f2b			 
8f2b			 
8f2b			 
8f2b					ld a, (input_cursor) 
8f2b					inc  a 		; TODO check overflow 
8f2b					ld (input_cursor), a 
8f2b			 
8f2b					ld a, (input_at_cursor) 
8f2b					inc a 
8f2b					ld (input_at_cursor), a 
8f2b			 
8f2b					jp .is1 
8f2b			 
8f2b			.endinput:	; TODO look for end of string 
8f2b			 
8f2b					; add trailing space for end of token 
8f2b			 
8f2b					ld hl, (input_start) 
8f2b					ld a,(input_len) 
8f2b					call addatohl 
8f2b					ld a, ' ' 
8f2b					ld (hl),a 
8f2b					; TODO eof of parse marker 
8f2b			 
8f2b					inc hl 
8f2b					ld a, 0 
8f2b					ld (hl),a 
8f2b			 
8f2b			 
8f2b					ret 
8f2b			 
8f2b			.iblank: db " ",0 
8f2b			 
8f2b			 
8f2b			input_str_prev:	ld (input_at_pos), a 
8f2b					ld (input_start), hl 
8f2b					ld a,1			; add cursor 
8f2b					ld (hl),a 
8f2b					inc hl 
8f2b					ld a,0 
8f2b					ld (hl),a 
8f2b					ld (input_ptr), hl 
8f2b					ld a,d 
8f2b					ld (input_size), a 
8f2b					ld a,0 
8f2b					ld (input_cursor),a 
8f2b			.instr1:	 
8f2b			 
8f2b					; TODO do block cursor 
8f2b					; TODO switch cursor depending on the modifer key 
8f2b			 
8f2b					; update cursor shape change on key hold 
8f2b			 
8f2b					ld hl, (input_ptr) 
8f2b					dec hl 
8f2b					ld a,(cursor_shape) 
8f2b					ld (hl), a 
8f2b			 
8f2b					; display entered text 
8f2b					ld a,(input_at_pos) 
8f2b			            	CALL fLCD_Pos       ;Position cursor to location in A 
8f2b			            	LD   de, (input_start) 
8f2b			            	CALL fLCD_Str       ;Display string pointed to by DE 
8f2b			 
8f2b					call cin 
8f2b					cp 0 
8f2b					jr z, .instr1 
8f2b			 
8f2b					; proecess keyboard controls first 
8f2b			 
8f2b					ld hl,(input_ptr) 
8f2b			 
8f2b					cp KEY_CR	 ; pressing enter ends input 
8f2b					jr z, .instrcr 
8f2b			 
8f2b					cp KEY_BS 	; back space 
8f2b					jr nz, .instr2 
8f2b					; process back space 
8f2b			 
8f2b					; TODO stop back space if at start of string 
8f2b					dec hl 
8f2b					dec hl ; to over write cursor 
8f2b					ld a,(cursor_shape) 
8f2b					;ld a,0 
8f2b					ld (hl),a 
8f2b					inc hl 
8f2b					ld a," " 
8f2b					ld (hl),a 
8f2b					ld (input_ptr),hl 
8f2b					 
8f2b			 
8f2b					jr .instr1 
8f2b			 
8f2b			.instr2:	cp KEY_LEFT    ; cursor left 
8f2b					jr nz, .instr3 
8f2b					dec hl 
8f2b					ld (input_ptr),hl 
8f2b					jr .instr1 
8f2b				 
8f2b			.instr3:	cp KEY_RIGHT      ; cursor right 
8f2b					jr nz, .instr4 
8f2b					inc hl 
8f2b					ld (input_ptr),hl 
8f2b					jr .instr1 
8f2b			 
8f2b			.instr4:	cp KEY_HOME    ; jump to start of line 
8f2b					jr nz, .instr5 
8f2b					dec hl 
8f2b					ld (input_ptr),hl 
8f2b					jr .instr1 
8f2b			 
8f2b			.instr5:	cp KEY_END     ; jump to end of line 
8f2b					jr nz, .instr6 
8f2b					dec hl 
8f2b					ld (input_ptr),hl 
8f2b					jr .instr1 
8f2b			.instr6:        cp KEY_UP      ; recall last command 
8f2b					jr nz, .instrnew 
8f2b			 
8f2b				ld hl, scratch 
8f2b				ld de, os_last_cmd 
8f2b				call strcpy 
8f2b					jr .instr1 
8f2b			 
8f2b			 
8f2b			.instrnew:	; no special key pressed to see if we have room to store it 
8f2b			 
8f2b					; TODO do string size test 
8f2b			 
8f2b					dec hl ; to over write cursor 
8f2b					ld (hl),a 
8f2b					inc hl 
8f2b					ld a,(cursor_shape) 
8f2b					ld (hl),a 
8f2b					inc hl 
8f2b					ld a,0 
8f2b					ld (hl),a 
8f2b			 
8f2b					ld (input_ptr),hl 
8f2b					 
8f2b					jr .instr1 
8f2b			.instrcr:	dec hl		; remove cursor 
8f2b					ld a,' '	; TODO add a trailing space for safety 
8f2b					ld (hl),a 
8f2b					inc hl 
8f2b					ld a,0 
8f2b					ld (hl),a 
8f2b			 
8f2b			 
8f2b					; if at end of line scroll up    
8f2b					; TODO detecting only end of line 4 for scroll up  
8f2b			 
8f2b					;ld   
8f2b			 
8f2b					ret 
8f2b			 
8f2b			 
8f2b			endif 
8f2b			; strcpy hl = dest, de source 
8f2b			 
8f2b 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f2c b7			            OR   A              ;Null terminator? 
8f2d c8			            RET  Z              ;Yes, so finished 
8f2e 1a					ld a,(de) 
8f2f 77					ld (hl),a 
8f30 13			            INC  DE             ;Point to next character 
8f31 23					inc hl 
8f32 18 f7		            JR   strcpy       ;Repeat 
8f34 c9					ret 
8f35			 
8f35			 
8f35			; TODO string_at  
8f35			; pass string which starts with lcd offset address and then null term string 
8f35			 
8f35			; TODO string to dec 
8f35			; TODO string to hex 
8f35			; TODO byte to string hex 
8f35			; TODO byte to string dec 
8f35			 
8f35			 
8f35			 
8f35			; from z80uartmonitor 
8f35			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f35			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8f35			; pass hl for where to put the text 
8f35			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f35 c5			hexout:	PUSH BC 
8f36 f5					PUSH AF 
8f37 47					LD B, A 
8f38					; Upper nybble 
8f38 cb 3f				SRL A 
8f3a cb 3f				SRL A 
8f3c cb 3f				SRL A 
8f3e cb 3f				SRL A 
8f40 cd 50 8f				CALL tohex 
8f43 77					ld (hl),a 
8f44 23					inc hl	 
8f45					 
8f45					; Lower nybble 
8f45 78					LD A, B 
8f46 e6 0f				AND 0FH 
8f48 cd 50 8f				CALL tohex 
8f4b 77					ld (hl),a 
8f4c 23					inc hl	 
8f4d					 
8f4d f1					POP AF 
8f4e c1					POP BC 
8f4f c9					RET 
8f50					 
8f50			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f50			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f50			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f50			tohex: 
8f50 e5					PUSH HL 
8f51 d5					PUSH DE 
8f52 16 00				LD D, 0 
8f54 5f					LD E, A 
8f55 21 5d 8f				LD HL, .DATA 
8f58 19					ADD HL, DE 
8f59 7e					LD A, (HL) 
8f5a d1					POP DE 
8f5b e1					POP HL 
8f5c c9					RET 
8f5d			 
8f5d			.DATA: 
8f5d 30					DEFB	30h	; 0 
8f5e 31					DEFB	31h	; 1 
8f5f 32					DEFB	32h	; 2 
8f60 33					DEFB	33h	; 3 
8f61 34					DEFB	34h	; 4 
8f62 35					DEFB	35h	; 5 
8f63 36					DEFB	36h	; 6 
8f64 37					DEFB	37h	; 7 
8f65 38					DEFB	38h	; 8 
8f66 39					DEFB	39h	; 9 
8f67 41					DEFB	41h	; A 
8f68 42					DEFB	42h	; B 
8f69 43					DEFB	43h	; C 
8f6a 44					DEFB	44h	; D 
8f6b 45					DEFB	45h	; E 
8f6c 46					DEFB	46h	; F 
8f6d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f6d			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f6d			;;    subtract $30, if result > 9 then subtract $7 more 
8f6d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f6d			atohex: 
8f6d d6 30				SUB $30 
8f6f fe 0a				CP 10 
8f71 f8					RET M		; If result negative it was 0-9 so we're done 
8f72 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f74 c9					RET		 
8f75			 
8f75			 
8f75			 
8f75			 
8f75			; Get 2 ASCII characters as hex byte from pointer in hl 
8f75			 
8f75			BYTERD: 
8f75 16 00			LD	D,00h		;Set up 
8f77 cd 7f 8f			CALL	HEXCON		;Get byte and convert to hex 
8f7a 87				ADD	A,A		;First nibble so 
8f7b 87				ADD	A,A		;multiply by 16 
8f7c 87				ADD	A,A		; 
8f7d 87				ADD	A,A		; 
8f7e 57				LD	D,A		;Save hi nibble in D 
8f7f			HEXCON: 
8f7f 7e				ld a, (hl)		;Get next chr 
8f80 23				inc hl 
8f81 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f83 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f85 38 02			JR	C,NALPHA	;If so miss next bit 
8f87 d6 07			SUB	007h		;Else convert alpha 
8f89			NALPHA: 
8f89 b2				OR	D		;Add hi nibble back 
8f8a c9				RET			; 
8f8b			 
8f8b			 
8f8b			; 
8f8b			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f8b			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f8b			; characters (0-9a-f) are accepted. 
8f8b			; 
8f8b			;get_word        push    af 
8f8b			;                call    get_byte        ; Get the upper byte 
8f8b			;                ld      h, a 
8f8b			;                call    get_byte        ; Get the lower byte 
8f8b			;                ld      l, a 
8f8b			;                pop     af 
8f8b			;                ret 
8f8b			; 
8f8b			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f8b			; the routine get_nibble is used only valid characters are accepted - the  
8f8b			; input routine only accepts characters 0-9a-f. 
8f8b			; 
8f8b c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f8c 7e					ld a,(hl) 
8f8d 23					inc hl 
8f8e cd b3 8f		                call    nibble2val      ; Get upper nibble 
8f91 cb 07		                rlc     a 
8f93 cb 07		                rlc     a 
8f95 cb 07		                rlc     a 
8f97 cb 07		                rlc     a 
8f99 47			                ld      b, a            ; Save upper four bits 
8f9a 7e					ld a,(hl) 
8f9b cd b3 8f		                call    nibble2val      ; Get lower nibble 
8f9e b0			                or      b               ; Combine both nibbles 
8f9f c1			                pop     bc              ; Restore B (and C) 
8fa0 c9			                ret 
8fa1			; 
8fa1			; Get a hexadecimal digit from the serial line. This routine blocks until 
8fa1			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8fa1			; to the serial line interface. The lower 4 bits of A contain the value of  
8fa1			; that particular digit. 
8fa1			; 
8fa1			;get_nibble      ld a,(hl)           ; Read a character 
8fa1			;                call    to_upper        ; Convert to upper case 
8fa1			;                call    is_hex          ; Was it a hex digit? 
8fa1			;                jr      nc, get_nibble  ; No, get another character 
8fa1			 ;               call    nibble2val      ; Convert nibble to value 
8fa1			 ;               call    print_nibble 
8fa1			 ;               ret 
8fa1			; 
8fa1			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8fa1			; A valid hexadecimal digit is denoted by a set C flag. 
8fa1			; 
8fa1			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8fa1			;                ret     nc              ; Yes 
8fa1			;                cp      '0'             ; Less than '0'? 
8fa1			;                jr      nc, is_hex_1    ; No, continue 
8fa1			;                ccf                     ; Complement carry (i.e. clear it) 
8fa1			;                ret 
8fa1			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8fa1			;                ret     c               ; Yes 
8fa1			;                cp      'A'             ; Less than 'A'? 
8fa1			;                jr      nc, is_hex_2    ; No, continue 
8fa1			;                ccf                     ; Yes - clear carry and return 
8fa1			;                ret 
8fa1			;is_hex_2        scf                     ; Set carry 
8fa1			;                ret 
8fa1			; 
8fa1			; Convert a single character contained in A to upper case: 
8fa1			; 
8fa1 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8fa3 d8			                ret     c 
8fa4 fe 7b		                cp      'z' + 1         ; > 'z'? 
8fa6 d0			                ret     nc              ; Nothing to do, either 
8fa7 e6 5f		                and     $5f             ; Convert to upper case 
8fa9 c9			                ret 
8faa			 
8faa			 
8faa			to_lower: 
8faa			 
8faa			   ; if char is in [A-Z] make it lower case 
8faa			 
8faa			   ; enter : a = char 
8faa			   ; exit  : a = lower case char 
8faa			   ; uses  : af 
8faa			 
8faa fe 41		   cp 'A' 
8fac d8			   ret c 
8fad			    
8fad fe 5b		   cp 'Z'+1 
8faf d0			   ret nc 
8fb0			    
8fb0 f6 20		   or $20 
8fb2 c9			   ret 
8fb3			 
8fb3			; 
8fb3			; Expects a hexadecimal digit (upper case!) in A and returns the 
8fb3			; corresponding value in A. 
8fb3			; 
8fb3 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8fb5 38 02		                jr      c, nibble2val_1 ; Yes 
8fb7 d6 07		                sub     7               ; Adjust for A-F 
8fb9 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8fbb e6 0f		                and     $f              ; Only return lower 4 bits 
8fbd c9			                ret 
8fbe			; 
8fbe			; Print_nibble prints a single hex nibble which is contained in the lower  
8fbe			; four bits of A: 
8fbe			; 
8fbe			;print_nibble    push    af              ; We won't destroy the contents of A 
8fbe			;                and     $f              ; Just in case... 
8fbe			;                add     a, '0'             ; If we have a digit we are done here. 
8fbe			;                cp      '9' + 1         ; Is the result > 9? 
8fbe			;                jr      c, print_nibble_1 
8fbe			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8fbe			;print_nibble_1  call    putc            ; Print the nibble and 
8fbe			;                pop     af              ; restore the original value of A 
8fbe			;                ret 
8fbe			;; 
8fbe			;; Send a CR/LF pair: 
8fbe			; 
8fbe			;crlf            push    af 
8fbe			;                ld      a, cr 
8fbe			;                call    putc 
8fbe			;                ld      a, lf 
8fbe			;                call    putc 
8fbe			;                pop     af 
8fbe			;                ret 
8fbe			; 
8fbe			; Print_word prints the four hex digits of a word to the serial line. The  
8fbe			; word is expected to be in HL. 
8fbe			; 
8fbe			;print_word      push    hl 
8fbe			;                push    af 
8fbe			;                ld      a, h 
8fbe			;                call    print_byte 
8fbe			;                ld      a, l 
8fbe			;                call    print_byte 
8fbe			;                pop     af 
8fbe			;                pop     hl 
8fbe			;                ret 
8fbe			; 
8fbe			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8fbe			; The byte to be printed is expected to be in A. 
8fbe			; 
8fbe			;print_byte      push    af              ; Save the contents of the registers 
8fbe			;                push    bc 
8fbe			;                ld      b, a 
8fbe			;                rrca 
8fbe			;                rrca 
8fbe			;                rrca 
8fbe			;                rrca 
8fbe			;                call    print_nibble    ; Print high nibble 
8fbe			;                ld      a, b 
8fbe			;                call    print_nibble    ; Print low nibble 
8fbe			;                pop     bc              ; Restore original register contents 
8fbe			;                pop     af 
8fbe			;                ret 
8fbe			 
8fbe			 
8fbe			 
8fbe			 
8fbe			 
8fbe			fourehexhl:  
8fbe 7e				ld a,(hl) 
8fbf cd 6d 8f			call atohex 
8fc2 cb 3f				SRL A 
8fc4 cb 3f				SRL A 
8fc6 cb 3f				SRL A 
8fc8 cb 3f				SRL A 
8fca 47				ld b, a 
8fcb 23				inc hl 
8fcc 7e				ld a,(hl) 
8fcd 23				inc hl 
8fce cd 6d 8f			call atohex 
8fd1 80				add b 
8fd2 57				ld d,a 
8fd3 7e				ld a,(hl) 
8fd4 cd 6d 8f			call atohex 
8fd7 cb 3f				SRL A 
8fd9 cb 3f				SRL A 
8fdb cb 3f				SRL A 
8fdd cb 3f				SRL A 
8fdf 47				ld b, a 
8fe0 23				inc hl 
8fe1 7e				ld a,(hl) 
8fe2 23				inc hl 
8fe3 cd 6d 8f			call atohex 
8fe6 80				add b 
8fe7 5f				ld e, a 
8fe8 d5				push de 
8fe9 e1				pop hl 
8fea c9				ret 
8feb			 
8feb			; pass hl. returns z set if the byte at hl is a digit 
8feb			;isdigithl:  
8feb			;	push bc 
8feb			;	ld a,(hl) 
8feb			;	cp ':' 
8feb			;	jr nc, .isdf 		; > 
8feb			;	cp '0' 
8feb			;	jr c, .isdf		; < 
8feb			; 
8feb			;	; TODO find a better way to set z 
8feb			; 
8feb			;	ld b,a 
8feb			;	cp b 
8feb			;	pop bc 
8feb			;	ret 
8feb			; 
8feb			;.isdf:	; not digit so clear z 
8feb			; 
8feb			;	; TODO find a better way to unset z 
8feb			; 
8feb			;	ld b,a 
8feb			;	inc b 
8feb			;	cp b 
8feb			; 
8feb			;	pop bc 
8feb			;	ret 
8feb				 
8feb				 
8feb			 
8feb			 
8feb			; pass hl as the four byte address to load 
8feb			 
8feb			get_word_hl:  
8feb e5				push hl 
8fec cd 8b 8f			call get_byte 
8fef				 
8fef 47				ld b, a 
8ff0			 
8ff0 e1				pop hl 
8ff1 23				inc hl 
8ff2 23				inc hl 
8ff3			 
8ff3			; TODO not able to handle a-f  
8ff3 7e				ld a,(hl) 
8ff4			;	;cp ':' 
8ff4			;	cp 'g' 
8ff4			;	jr nc, .single_byte_hl 		; > 
8ff4			;	cp 'G' 
8ff4			;	jr nc, .single_byte_hl 		; > 
8ff4			;	cp '0' 
8ff4			;	jr c, .single_byte_hl		; < 
8ff4			 
8ff4				;call isdigithl 
8ff4 fe 00			cp 0 
8ff6 28 06			jr z, .single_byte_hl 
8ff8			 
8ff8			.getwhln:   ; hex word so get next byte 
8ff8			 
8ff8 cd 8b 8f			call get_byte 
8ffb 6f				ld l, a 
8ffc 60				ld h,b 
8ffd c9				ret 
8ffe 68			.single_byte_hl:   ld l,b 
8fff 26 00				ld h,0 
9001 c9					ret 
9002			 
9002			 
9002			 
9002			 
9002 21 8f 97			ld hl,asc+1 
9005			;	ld a, (hl) 
9005			;	call nibble2val 
9005 cd 8b 8f			call get_byte 
9008			 
9008			;	call fourehexhl 
9008 32 f5 e2			ld (scratch+52),a 
900b				 
900b 21 f3 e2			ld hl,scratch+50 
900e 22 e4 e5			ld (os_cur_ptr),hl 
9011			 
9011 c9				ret 
9012			 
9012			 
9012			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9012			 
9012			; Decimal Unsigned Version 
9012			 
9012			;Number in a to decimal ASCII 
9012			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9012			;Example: display a=56 as "056" 
9012			;input: a = number 
9012			;Output: a=0,value of a in the screen 
9012			;destroys af,bc (don't know about hl and de) 
9012			DispAToASCII: 
9012 0e 9c			ld	c,-100 
9014 cd 1e 90			call	.Na1 
9017 0e f6			ld	c,-10 
9019 cd 1e 90			call	.Na1 
901c 0e ff			ld	c,-1 
901e 06 2f		.Na1:	ld	b,'0'-1 
9020 04			.Na2:	inc	b 
9021 81				add	a,c 
9022 38 fc			jr	c,.Na2 
9024 91				sub	c		;works as add 100/10/1 
9025 f5				push af		;safer than ld c,a 
9026 78				ld	a,b		;char is in b 
9027			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
9027 f1				pop af		;safer than ld a,c 
9028 c9				ret 
9029			 
9029			; Decimal Signed Version 
9029			 
9029			; DispA 
9029			; -------------------------------------------------------------- 
9029			; Converts a signed integer value to a zero-terminated ASCII 
9029			; string representative of that value (using radix 10). 
9029			; -------------------------------------------------------------- 
9029			; INPUTS: 
9029			;     HL     Value to convert (two's complement integer). 
9029			;     DE     Base address of string destination. (pointer). 
9029			; -------------------------------------------------------------- 
9029			; OUTPUTS: 
9029			;     None 
9029			; -------------------------------------------------------------- 
9029			; REGISTERS/MEMORY DESTROYED 
9029			; AF HL 
9029			; -------------------------------------------------------------- 
9029			 
9029			;DispHLToASCII: 
9029			;   push    de 
9029			;   push    bc 
9029			; 
9029			;; Detect sign of HL. 
9029			;    bit    7, h 
9029			;    jr     z, ._DoConvert 
9029			; 
9029			;; HL is negative. Output '-' to string and negate HL. 
9029			;    ld     a, '-' 
9029			;    ld     (de), a 
9029			;    inc    de 
9029			; 
9029			;; Negate HL (using two's complement) 
9029			;    xor    a 
9029			;    sub    l 
9029			;    ld     l, a 
9029			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9029			;    sbc    a, h 
9029			;    ld     h, a 
9029			; 
9029			;; Convert HL to digit characters 
9029			;._DoConvert: 
9029			;    ld     b, 0     ; B will count character length of number 
9029			;-   ld     a, 10 
9029			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9029			;    push   af 
9029			;    inc    b 
9029			;    ld     a, h 
9029			;    or     l 
9029			;    jr     nz, - 
9029			; 
9029			;; Retrieve digits from stack 
9029			;-   pop    af 
9029			;    or     $30 
9029			;    ld     (de), a 
9029			;    inc    de 
9029			;    djnz   - 
9029			; 
9029			;; Terminate string with NULL 
9029			;    xor    a 
9029			;    ld     (de), a 
9029			; 
9029			;    pop    bc 
9029			;    pop    de 
9029			;    ret 
9029			 
9029			;Comments 
9029			; 
9029			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9029			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9029			;    Note that the output string will not be fixed-width. 
9029			; 
9029			;Example Usage 
9029			; 
9029			;    ld    hl, -1004 
9029			;    ld    de, OP1 
9029			;    call  DispA 
9029			;    ld    hl, OP1 
9029			;    syscall  PutS 
9029			 
9029			 
9029			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9029			 
9029			 
9029			;Converts an ASCII string to an unsigned 16-bit integer 
9029			;Quits when it reaches a non-decimal digit 
9029			 
9029			string_to_uint16: 
9029			atoui_16: 
9029			;Input: 
9029			;     DE points to the string 
9029			;Outputs: 
9029			;     HL is the result 
9029			;     A is the 8-bit value of the number 
9029			;     DE points to the byte after the number 
9029			;Destroys: 
9029			;     BC 
9029			;       if the string is non-empty, BC is HL/10 
9029			;Size:  24 bytes 
9029			;Speed: 42+d(104+{0,9}) 
9029			;       d is the number of digits in the number 
9029			;       max is 640 cycles for a 5 digit number 
9029			;Assuming no leading zeros: 
9029			;1 digit:  146cc 
9029			;2 digit:  250cc 
9029			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9029			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9029			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9029			;avg: 544.81158447265625cc (544+13297/16384) 
9029			;=============================================================== 
9029 21 00 00		  ld hl,0 
902c			.u16a: 
902c 1a			  ld a,(de) 
902d d6 30		  sub 30h 
902f fe 0a		  cp 10 
9031 d0			  ret nc 
9032 13			  inc de 
9033 44			  ld b,h 
9034 4d			  ld c,l 
9035 29			  add hl,hl 
9036 29			  add hl,hl 
9037 09			  add hl,bc 
9038 29			  add hl,hl 
9039 85			  add a,l 
903a 6f			  ld l,a 
903b 30 ef		  jr nc,.u16a 
903d 24			  inc h 
903e c3 2c 90		  jp .u16a 
9041			 
9041			 
9041			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9041			 
9041			;written by Zeda 
9041			;Converts a 16-bit unsigned integer to an ASCII string. 
9041			 
9041			uitoa_16: 
9041			;Input: 
9041			;   DE is the number to convert 
9041			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
9041			;Output: 
9041			;   HL points to the null-terminated ASCII string 
9041			;      NOTE: This isn't necessarily the same as the input HL. 
9041 d5			  push de 
9042 c5			  push bc 
9043 f5			  push af 
9044 eb			  ex de,hl 
9045			 
9045 01 f0 d8		  ld bc,-10000 
9048 3e 2f		  ld a,'0'-1 
904a 3c			  inc a 
904b 09			  add hl,bc  
904c 38 fc		   jr c,$-2 
904e 12			  ld (de),a 
904f 13			  inc de 
9050			 
9050 01 e8 03		  ld bc,1000 
9053 3e 3a		  ld a,'9'+1 
9055 3d			  dec a  
9056 09			  add hl,bc  
9057 30 fc		   jr nc,$-2 
9059 12			  ld (de),a 
905a 13			  inc de 
905b			 
905b 01 9c ff		  ld bc,-100 
905e 3e 2f		  ld a,'0'-1 
9060 3c			  inc a  
9061 09			  add hl,bc  
9062 38 fc		   jr c,$-2 
9064 12			  ld (de),a 
9065 13			  inc de 
9066			 
9066 7d			  ld a,l 
9067 26 3a		  ld h,'9'+1 
9069 25			  dec h  
906a c6 0a		  add a,10  
906c 30 fb		   jr nc,$-3 
906e c6 30		  add a,'0' 
9070 eb			  ex de,hl 
9071 72			  ld (hl),d 
9072 23			  inc hl 
9073 77			  ld (hl),a 
9074 23			  inc hl 
9075 36 00		  ld (hl),0 
9077			 
9077			;Now strip the leading zeros 
9077 0e fa		  ld c,-6 
9079 09			  add hl,bc 
907a 3e 30		  ld a,'0' 
907c 23			  inc hl  
907d be			  cp (hl)  
907e 28 fc		  jr z,$-2 
9080			 
9080			;Make sure that the string is non-empty! 
9080 7e			  ld a,(hl) 
9081 b7			  or a 
9082 20 01		  jr nz,.atoub 
9084 2b			  dec hl 
9085			.atoub: 
9085			 
9085 f1			  pop af 
9086 c1			  pop bc 
9087 d1			  pop de 
9088 c9			  ret 
9089			 
9089			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9089			 
9089			toUpper: 
9089			;A is the char. 
9089			;If A is a lowercase letter, this sets it to the matching uppercase 
9089			;18cc or 30cc or 41cc 
9089			;avg: 26.75cc 
9089 fe 61		  cp 'a' 
908b d8			  ret c 
908c fe 7b		  cp 'z'+1 
908e d0			  ret nc 
908f d6 20		  sub 'a'-'A' 
9091 c9			  ret 
9092			 
9092			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9092			 
9092			; String Length 
9092			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9092			 
9092			; Get the length of the null-terminated string starting at $8000 hl 
9092			;    LD     HL, $8000 
9092			 
9092			strlenz: 
9092			 
9092 af			    XOR    A               ; Zero is the value we are looking for. 
9093 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9094 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9095			                           ; 65, 536 bytes (the entire addressable memory space). 
9095 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9097			 
9097			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9097 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9098 6f			    LD     L, A             ; number of bytes 
9099 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
909b 2b			    DEC    HL              ; Compensate for null. 
909c c9				ret 
909d			 
909d			; Get the length of the A terminated string starting at $8000 hl 
909d			;    LD     HL, $8000 
909d			 
909d			strlent: 
909d			 
909d			                  ; A is the value we are looking for. 
909d 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
909f 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
90a1			                           ; 65, 536 bytes (the entire addressable memory space). 
90a1 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
90a3			 
90a3			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
90a3 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
90a5 2e 00		    LD     L, 0             ; number of bytes 
90a7 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
90a9 2b			    DEC    HL              ; Compensate for null. 
90aa c9				ret 
90ab			 
90ab			 
90ab			;Comparing Strings 
90ab			 
90ab			;IN    HL     Address of string1. 
90ab			;      DE     Address of string2. 
90ab			 
90ab			; doc given but wrong??? 
90ab			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
90ab			;      carry  Set if string1 > string2, reset if string1 <= string2. 
90ab			; tested 
90ab			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
90ab			 
90ab			strcmp_old: 
90ab e5			    PUSH   HL 
90ac d5			    PUSH   DE 
90ad			 
90ad 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
90ae be			    CP     (HL)            ; (want to minimize work). 
90af 38 01		    JR     C, Str1IsBigger 
90b1 7e			    LD     A, (HL) 
90b2			 
90b2			Str1IsBigger: 
90b2 4f			    LD     C, A             ; Put length in BC 
90b3 06 00		    LD     B, 0 
90b5 13			    INC    DE              ; Increment pointers to meat of string. 
90b6 23			    INC    HL 
90b7			 
90b7			CmpLoop: 
90b7 1a			    LD     A, (DE)          ; Compare bytes. 
90b8 ed a1		    CPI 
90ba 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
90bc 13			    INC    DE              ; Update pointer. 
90bd ea b7 90		    JP     PE, CmpLoop 
90c0			 
90c0 d1			    POP    DE 
90c1 e1			    POP    HL 
90c2 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
90c3 be			    CP     (HL) 
90c4 c9			    RET 
90c5			 
90c5			NoMatch: 
90c5 2b			    DEC    HL 
90c6 be			    CP     (HL)            ; Compare again to affect carry. 
90c7 d1			    POP    DE 
90c8 e1			    POP    HL 
90c9 c9			    RET 
90ca			 
90ca			;; test strmp 
90ca			; 
90ca			;ld de, .str1 
90ca			;ld hl, .str2 
90ca			;call strcmp 
90ca			;jr z, .z1 
90ca			;;this 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "NZ1" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			;.z1: 
90ca			; 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "ZZ1" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			; 
90ca			;ld de, .str1 
90ca			;ld hl, .str1 
90ca			;call strcmp 
90ca			;jr z, .z2 
90ca			;;this 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "NZ2" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			;.z2: 
90ca			; 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "ZZ2" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			; 
90ca			;ld de, .str1 
90ca			;ld hl, .str2 
90ca			;call strcmp 
90ca			;jr c, .c1 
90ca			; 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "Nc1" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			;.c1: 
90ca			;;this 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "cc1" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			; 
90ca			;ld de, .str1 
90ca			;ld hl, .str1 
90ca			;call strcmp 
90ca			;jr c, .c2 
90ca			;;this 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "Nc2" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			;.c2: 
90ca			; 
90ca			;	if DEBUG_FORTH_WORDS 
90ca			;		DMARK "cc2" 
90ca			;		CALLMONITOR 
90ca			;	endif 
90ca			;	NEXTW 
90ca			;.str1:   db "string1",0 
90ca			;.str2:   db "string2",0 
90ca			 
90ca			; only care about direct match or not 
90ca			; hl and de strings 
90ca			; zero set if the same 
90ca			 
90ca			strcmp: 
90ca 1a				ld a, (de) 
90cb be				cp (hl) 
90cc 28 02			jr z, .ssame 
90ce b7				or a 
90cf c9				ret 
90d0			 
90d0			.ssame:  
90d0 fe 00			cp 0 
90d2 c8				ret z 
90d3			 
90d3 23				inc hl 
90d4 13				inc de 
90d5 18 f3			jr strcmp 
90d7				 
90d7				 
90d7			 
90d7			;Copyright (c) 2014, Luke Maurits 
90d7			;All rights reserved. 
90d7			; 
90d7			;Redistribution and use in source and binary forms, with or without 
90d7			;modification, are permitted provided that the following conditions are met: 
90d7			; 
90d7			;* Redistributions of source code must retain the above copyright notice, this 
90d7			;  list of conditions and the following disclaimer. 
90d7			; 
90d7			;* Redistributions in binary form must reproduce the above copyright notice, 
90d7			;  this list of conditions and the following disclaimer in the documentation 
90d7			;  and/or other materials provided with the distribution. 
90d7			; 
90d7			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
90d7			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
90d7			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
90d7			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
90d7			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
90d7			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
90d7			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
90d7			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
90d7			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
90d7			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
90d7			 
90d7			; https://github.com/lmaurits/lm512/blob/master/string.z80 
90d7			 
90d7			StrictStrCmp: 
90d7				; Load next chars of each string 
90d7 1a				ld a, (de) 
90d8 47				ld b, a 
90d9 7e				ld a, (hl) 
90da				; Compare 
90da b8				cp b 
90db				; Return non-zero if chars don't match 
90db c0				ret nz 
90dc				; Check for end of both strings 
90dc fe 00			cp "\0" 
90de				; Return if strings have ended 
90de c8				ret z 
90df				; Otherwise, advance to next chars 
90df 23				inc hl 
90e0 13				inc de 
90e1 18 f4			jr StrictStrCmp 
90e3			 
90e3			;end 
90e3			; eof 
90e3			 
90e3			 
90e3			 
90e3			 
90e3			 
90e3			 
# End of file firmware_strings.asm
90e3			include "firmware_memory.asm"   ; malloc and free  
90e3			 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3			.mallocsize: db "Wants malloc >256",0 
90e3			.mallocasize: db "MALLOC gives >256",0 
90e3			.malloczero: db "MALLOC gives zero",0 
90e3			 
90e3			malloc_guard_zerolen: 
90e3				push hl 
90e3				push de 
90e3				push af 
90e3			 
90e3				ld de, 0 
90e3			        call cmp16 
90e3				jr nz, .lowalloz 
90e3			 
90e3				push hl 
90e3				push de 
90e3					ld hl, display_fb0 
90e3					ld (display_fb_active), hl 
90e3				call clear_display 
90e3				ld a, 0 
90e3				ld de, .malloczero 
90e3				call str_at_display 
90e3				call update_display 
90e3				call delay1s 
90e3				call delay1s 
90e3				call bp_on 
90e3			;	ld a, 0 
90e3			;	ld (os_view_disable), a 
90e3			 
90e3				pop de 
90e3				pop hl 
90e3			 
90e3				 
90e3			 
90e3				CALLMONITOR 
90e3			.lowalloz: 
90e3			 
90e3			 
90e3				pop af 
90e3				pop de 
90e3				pop hl 
90e3			ret 
90e3			 
90e3			malloc_guard_entry: 
90e3				push hl 
90e3				push de 
90e3				push af 
90e3			 
90e3			 	or a      ;clear carry flag 
90e3				push hl 
90e3				ld de, 255 
90e3				sbc hl, de 
90e3				jr c, .lowalloc 
90e3			 
90e3				push de 
90e3					ld hl, display_fb0 
90e3					ld (display_fb_active), hl 
90e3				call clear_display 
90e3				ld a, 0 
90e3				ld de, .mallocsize 
90e3				call str_at_display 
90e3				call update_display 
90e3				call delay1s 
90e3				call delay1s 
90e3			;	ld a, 0 
90e3			;	ld (os_view_disable), a 
90e3				call bp_on 
90e3			 
90e3				pop de 
90e3				pop hl 
90e3			 
90e3				 
90e3			 
90e3				CALLMONITOR 
90e3				jr .lowdone 
90e3			.lowalloc: 
90e3			 
90e3			 
90e3				pop hl 
90e3			.lowdone:	pop af 
90e3				pop de 
90e3				pop hl 
90e3			ret 
90e3			 
90e3			malloc_guard_exit: 
90e3				push hl 
90e3				push de 
90e3				push af 
90e3			 
90e3			 	or a      ;clear carry flag 
90e3				push hl 
90e3				ld de, 255 
90e3				sbc hl, de 
90e3				jr c, .lowallocx 
90e3			 
90e3				push de 
90e3					ld hl, display_fb0 
90e3					ld (display_fb_active), hl 
90e3				call clear_display 
90e3				ld a, 0 
90e3				ld de, .mallocasize 
90e3				call str_at_display 
90e3				call update_display 
90e3				call delay1s 
90e3				call delay1s 
90e3			;	ld a, 0 
90e3			;	ld (os_view_disable), a 
90e3				call bp_on 
90e3				pop de 
90e3				pop hl 
90e3			 
90e3				CALLMONITOR 
90e3				jr .lowdonex 
90e3			.lowallocx: 
90e3			 
90e3				pop hl 
90e3			.lowdonex:	pop af 
90e3				pop de 
90e3				pop hl 
90e3			ret 
90e3			endif 
90e3			 
90e3			if MALLOC_2 
90e3			; Z80 Malloc and Free Functions 
90e3			 
90e3			; Malloc Function: 
90e3			; Input: 
90e3			;   HL: Size of block to allocate 
90e3			; Output: 
90e3			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90e3			 
90e3			malloc: 
90e3				 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3			call malloc_guard_entry 
90e3			endif 
90e3			 
90e3			 
90e3			 
90e3			 
90e3					if DEBUG_FORTH_MALLOC 
90e3						DMARK "mal" 
90e3						CALLMONITOR 
90e3					endif 
90e3			    push af            ; Save AF register 
90e3			    ld a, l            ; Load low byte of size into A 
90e3			    or h               ; Check if size is zero 
90e3			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
90e3			 
90e3			    ; Allocate memory 
90e3			    ld hl, (heap_start) ; Load start of heap into HL 
90e3					if DEBUG_FORTH_MALLOC 
90e3						DMARK "ma1" 
90e3						CALLMONITOR 
90e3					endif 
90e3			    call malloc_internal ; Call internal malloc function 
90e3			    pop af             ; Restore AF register 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3			call malloc_guard_exit 
90e3			call malloc_guard_zerolen 
90e3			endif 
90e3			    ret                ; Return 
90e3			 
90e3			; Free Function: 
90e3			; Input: 
90e3			;   HL: Pointer to memory block to free 
90e3			; Output: 
90e3			;   None 
90e3			 
90e3			free: 
90e3			    push af            ; Save AF register 
90e3			    ld a, l            ; Load low byte of pointer into A 
90e3			    or h               ; Check if pointer is NULL 
90e3			    jp z, free_exit    ; If pointer is NULL, exit 
90e3			 
90e3			    ; Free memory 
90e3			    ld hl, (heap_start) ; Load start of heap into HL 
90e3			    call free_internal  ; Call internal free function 
90e3			    pop af             ; Restore AF register 
90e3			    ret                ; Return 
90e3			 
90e3			; Internal Malloc Function: 
90e3			; Input: 
90e3			;   HL: Size of block to allocate 
90e3			; Output: 
90e3			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90e3			 
90e3			malloc_internal: 
90e3			    ld bc, 2           ; Number of bytes to allocate for management overhead 
90e3			    add hl, bc         ; Add management overhead to requested size 
90e3			    ex de, hl          ; Save total size in DE, and keep it in HL 
90e3					if DEBUG_FORTH_MALLOC 
90e3						DMARK "ma2" 
90e3						CALLMONITOR 
90e3					endif 
90e3			 
90e3			    ; Search for free memory block 
90e3			    ld de, (heap_end)  ; Load end of heap into DE 
90e3			    ld bc, 0           ; Initialize counter 
90e3			 
90e3					if DEBUG_FORTH_MALLOC 
90e3						DMARK "ma2" 
90e3						CALLMONITOR 
90e3					endif 
90e3			malloc_search_loop: 
90e3			    ; Check if current block is free 
90e3			    ld a, (hl)         ; Load current block's status (free or used) 
90e3			    cp 0               ; Compare with zero (free) 
90e3			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
90e3			 
90e3			    ; Check if current block is large enough 
90e3			    ld a, (hl+1)       ; Load high byte of block size 
90e3			    cp l               ; Compare with low byte of requested size 
90e3			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
90e3			 
90e3			    ld a, (hl+2)       ; Load low byte of block size 
90e3			    cp h               ; Compare with high byte of requested size 
90e3			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
90e3			 
90e3			    ; Mark block as used 
90e3			    ld (hl), 0xFF      ; Set status byte to indicate used block 
90e3			 
90e3			    ; Calculate remaining space in block 
90e3			    ld bc, 0           ; Clear BC 
90e3			    add hl, bc         ; Increment HL to point to start of data block 
90e3			    add hl, de         ; HL = HL + DE (total size) 
90e3			    ld bc, 1           ; Number of bytes to allocate for management overhead 
90e3			    add hl, bc         ; Add management overhead to start of data block 
90e3			 
90e3			    ; Save pointer to allocated block in HL 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3						DMARK "ma5" 
90e3			call malloc_guard_exit 
90e3			call malloc_guard_zerolen 
90e3			endif 
90e3			    ret 
90e3			 
90e3			malloc_skip_block_check: 
90e3			    ; Move to the next block 
90e3			    ld bc, 3           ; Size of management overhead 
90e3			    add hl, bc         ; Move to the next block 
90e3			    inc de             ; Increment counter 
90e3			 
90e3			    ; Check if we have reached the end of heap 
90e3			    ld a, e            ; Load low byte of heap end address 
90e3			    cp (hl)            ; Compare with low byte of current address 
90e3			    jr nz, malloc_search_loop  ; If not equal, continue searching 
90e3			    ld a, d            ; Load high byte of heap end address 
90e3			    cp 0               ; Check if it's zero (end of memory) 
90e3			    jr nz, malloc_search_loop  ; If not zero, continue searching 
90e3			 
90e3			    ; If we reached here, allocation failed 
90e3			    xor a              ; Set result to NULL 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3						DMARK "ma6" 
90e3			call malloc_guard_exit 
90e3			call malloc_guard_zerolen 
90e3			endif 
90e3			    ret 
90e3			malloc_exit: 
90e3			if DEBUG_FORTH_MALLOC_HIGH 
90e3						DMARK "ma7" 
90e3			call malloc_guard_exit 
90e3			call malloc_guard_zerolen 
90e3			endif 
90e3			    ret 
90e3			 
90e3			; Internal Free Function: 
90e3			; Input: 
90e3			;   HL: Pointer to memory block to free 
90e3			; Output: 
90e3			;   None 
90e3			 
90e3			free_internal: 
90e3			    ld de, (heap_start) ; Load start of heap into DE 
90e3			    ld bc, 0            ; Initialize counter 
90e3			 
90e3			free_search_loop: 
90e3			    ; Check if current block contains the pointer 
90e3			    ld a, l             ; Load low byte of pointer 
90e3			    cp (hl+1)           ; Compare with high byte of current block's address 
90e3			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90e3			    ld a, h             ; Load high byte of pointer 
90e3			    cp (hl+2)           ; Compare with low byte of current block's address 
90e3			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90e3			 
90e3			    ; Mark block as free 
90e3			    ld (hl), 0          ; Set status byte to indicate free block 
90e3			    ret                 ; Return 
90e3			 
90e3			free_skip_block_check: 
90e3			    ; Move to the next block 
90e3			    ld bc, 3            ; Size of management overhead 
90e3			    add hl, bc          ; Move to the next block 
90e3			    inc de              ; Increment counter 
90e3			 
90e3			    ; Check if we have reached the end of heap 
90e3			    ld a, e             ; Load low byte of heap end address 
90e3			    cp (hl)             ; Compare with low byte of current address 
90e3			    jr nz, free_search_loop  ; If not equal, continue searching 
90e3			    ld a, d             ; Load high byte of heap end address 
90e3			    cp 0                ; Check if it's zero (end of memory) 
90e3			    jr nz, free_search_loop  ; If not zero, continue searching 
90e3			 
90e3			    ; If we reached here, pointer is not found in heap 
90e3			    ret 
90e3			 
90e3			free_exit: 
90e3			    ret                 ; Return 
90e3			 
90e3			; Define heap start and end addresses 
90e3			;heap_start:    .dw 0xC000   ; Start of heap 
90e3			;heap_end:      .dw 0xE000   ; End of heap 
90e3			 
90e3			endif 
90e3			 
90e3			 
90e3			if MALLOC_1 
90e3			 
90e3			 
90e3			 
90e3			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
90e3			 
90e3			;moved to firmware.asm 
90e3			;heap_start        .equ  0x9000      ; Starting address of heap 
90e3			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90e3			 
90e3			;      .org 0 
90e3			;      jp    main 
90e3			 
90e3			 
90e3			;      .org  0x100 
90e3			;main: 
90e3			;      ld    HL, 0x8100 
90e3			;      ld    SP, HL 
90e3			; 
90e3			;      call  heap_init 
90e3			; 
90e3			;      ; Make some allocations 
90e3			;      ld    HL, 12 
90e3			;      call  malloc            ; Allocates 0x9004 
90e3			; 
90e3			;      ld    HL, 12 
90e3			;      call  malloc            ; Allocates 0x9014 
90e3			; 
90e3			;      ld    HL, 12 
90e3			;      call  malloc            ; Allocates 0x9024 
90e3			; 
90e3			;      ; Free some allocations 
90e3			;      ld    HL, 0x9014 
90e3			;      call  free 
90e3			; 
90e3			;      ld    HL, 0x9004 
90e3			;      call  free 
90e3			; 
90e3			;      ld    HL, 0x9024 
90e3			;      call  free 
90e3			; 
90e3			; 
90e3			;      halt 
90e3			 
90e3			 
90e3			;------------------------------------------------------------------------------ 
90e3			;     heap_init                                                               : 
90e3			;                                                                             : 
90e3			; Description                                                                 : 
90e3			;     Initialise the heap and make it ready for malloc and free operations.   : 
90e3			;                                                                             : 
90e3			;     The heap is maintained as a linked list, starting with an initial       : 
90e3			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90e3			;     the first free block in the heap. Each block then points to the next    : 
90e3			;     free block within the heap, and the free list ends at the first block   : 
90e3			;     with a null pointer to the next free block.                             : 
90e3			;                                                                             : 
90e3			; Parameters                                                                  : 
90e3			;     Inputs are compile-time only. Two defines which specify the starting    : 
90e3			;     address of the heap and its size are required, along with a memory      : 
90e3			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90e3			;     principally stores a pointer to the first free block in the heap.       : 
90e3			;                                                                             : 
90e3			; Returns                                                                     : 
90e3			;     Nothing                                                                 : 
90e3			;------------------------------------------------------------------------------ 
90e3			heap_init: 
90e3 e5			      push  HL 
90e4			 
90e4			      ; Initialise free list struct 
90e4 21 4c e4		      ld    HL, heap_start 
90e7 22 47 e4		      ld    (free_list), HL 
90ea 21 00 00		      ld    HL, 0 
90ed 22 49 e4		      ld    (free_list+2), HL 
90f0			 
90f0			      ; Insert first free block at bottom of heap, consumes entire heap 
90f0 21 98 e2		      ld    HL, heap_start+heap_size-4 
90f3 22 4c e4		      ld    (heap_start), HL        ; Next block (end of free list) 
90f6 21 4c fe		      ld    HL, heap_size-4 
90f9 22 4e e4		      ld    (heap_start+2), HL      ; Block size 
90fc			 
90fc			      ; Insert end of free list block at top of heap - two null words will 
90fc			      ; terminate the free list 
90fc 21 00 00		      ld    HL, 0 
90ff 22 9a e2		      ld    (heap_start+heap_size-2), HL 
9102 22 98 e2		      ld    (heap_start+heap_size-4), HL 
9105			 
9105 e1			      pop   HL 
9106			 
9106 c9			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     malloc                                                                  : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Allocates the wanted space from the heap and returns the address of the : 
9107			;     first useable byte of the allocation.                                   : 
9107			;                                                                             : 
9107			;     Allocations can happen in one of two ways:                              : 
9107			;                                                                             : 
9107			;     1. A free block may be found which is the exact size wanted. In this    : 
9107			;        case the block is removed from the free list and retuedn to the      : 
9107			;        caller.                                                              : 
9107			;     2. A free block may be found which is larger than the size wanted. In   : 
9107			;        this case, the larger block is split into two. The first portion of  : 
9107			;        this block will become the requested space by the malloc call and    : 
9107			;        is returned to the caller. The second portion becomes a new free     : 
9107			;        block, and the free list is adjusted to maintain continuity via this : 
9107			;        newly created block.                                                 : 
9107			;                                                                             : 
9107			;     malloc does not set any initial value in the allocated space, the       : 
9107			;     caller is required to do this as required.                              : 
9107			;                                                                             : 
9107			;     This implementation of malloc uses the stack exclusively, and is        : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling malloc, and recommended  : 
9107			;     to avoid the use of malloc inside ISRs in general.                      : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Number of bytes wanted                                              : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     HL  Address of the first useable byte of the allocation                 : 
9107			;                                                                             : 
9107			; Flags                                                                       : 
9107			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +4  +-------------+                                                       : 
9107			;       |  this_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			 
9107			 
9107			;malloc: 
9107			; 
9107			;	SAVESP ON 1 
9107			; 
9107			;	call malloc_code 
9107			; 
9107			;	CHECKSP ON 1 
9107			;	ret 
9107			 
9107			 
9107			malloc: 
9107 c5			      push  BC 
9108 d5			      push  DE 
9109 dd e5		      push  IX 
910b			if DEBUG_FORTH_MALLOC_HIGH 
910b			call malloc_guard_entry 
910b			endif 
910b			 
910b					if DEBUG_FORTH_MALLOC 
910b						DMARK "mal" 
910b						CALLMONITOR 
910b					endif 
910b 7c			      ld    A, H                    ; Exit if no space requested 
910c b5			      or    L 
910d ca cc 91		      jp    Z, malloc_early_exit 
9110			 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			; 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			;inc hl 
9110			 
9110			 
9110			 
9110			 
9110					if DEBUG_FORTH_MALLOC 
9110						DMARK "maA" 
9110						CALLMONITOR 
9110					endif 
9110			      ; Set up stack frame 
9110 eb			      ex    DE, HL 
9111 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9114 39			      add   HL, SP 
9115 f9			      ld    SP, HL 
9116 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
911a dd 39		      add   IX, SP 
911c			 
911c			      ; Setup initial state 
911c 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
911f 19			      add   HL, DE 
9120			 
9120 44			      ld    B, H                    ; Move want to BC 
9121 4d			      ld    C, L 
9122			 
9122 21 47 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
9125 dd 75 04		      ld    (IX+4), L 
9128 dd 74 05		      ld    (IX+5), H 
912b			 
912b 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
912c 23			      inc   HL 
912d 56			      ld    D, (HL) 
912e dd 73 02		      ld    (IX+2), E 
9131 dd 72 03		      ld    (IX+3), D 
9134 eb			      ex    DE, HL                  ; this_free ptr into HL 
9135			 
9135					if DEBUG_FORTH_MALLOC 
9135						DMARK "maB" 
9135						CALLMONITOR 
9135					endif 
9135			      ; Loop through free block list to find some space 
9135			malloc_find_space: 
9135 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9136 23			      inc   HL 
9137 56			      ld    D, (HL) 
9138			 
9138 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9139 b3			      or    E 
913a ca c6 91		      jp    Z, malloc_no_space 
913d			 
913d dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
9140 dd 72 01		      ld    (IX+1), D 
9143			 
9143			      ; Does this block have enough space to make the allocation? 
9143 23			      inc   HL                      ; Load free block size into DE 
9144 5e			      ld    E, (HL) 
9145 23			      inc   HL 
9146 56			      ld    D, (HL) 
9147			 
9147 eb			      ex    DE, HL                  ; Check size of block against want 
9148 b7			      or    A                       ; Ensure carry flag clear 
9149 ed 42		      sbc   HL, BC 
914b e5			      push  HL                      ; Store the result for later (new block size) 
914c			 
914c ca 9b 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
914f 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9151			 
9151			      ; this_free block is not big enough, setup ptrs to test next free block 
9151 e1			      pop   HL                      ; Discard previous result 
9152			 
9152 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9155 dd 66 03		      ld    H, (IX+3) 
9158 dd 75 04		      ld    (IX+4), L 
915b dd 74 05		      ld    (IX+5), H 
915e			 
915e dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9161 dd 66 01		      ld    H, (IX+1) 
9164 dd 75 02		      ld    (IX+2), L 
9167 dd 74 03		      ld    (IX+3), H 
916a			 
916a					if DEBUG_FORTH_MALLOC 
916a						DMARK "MA>" 
916a						CALLMONITOR 
916a					endif 
916a 18 c9		      jr    malloc_find_space 
916c			 
916c			      ; split a bigger block into two - requested size and remaining size 
916c			malloc_alloc_split: 
916c					if DEBUG_FORTH_MALLOC 
916c						DMARK "MAs" 
916c						CALLMONITOR 
916c					endif 
916c eb			      ex    DE, HL                  ; Calculate address of new free block 
916d 2b			      dec   HL 
916e 2b			      dec   HL 
916f 2b			      dec   HL 
9170 09			      add   HL, BC 
9171			 
9171			      ; Create a new block and point it at next_free 
9171 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9174 dd 56 01		      ld    D, (IX+1) 
9177			 
9177 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9178 23			      inc   HL 
9179 72			      ld    (HL), D 
917a			 
917a d1			      pop   DE                      ; Store size of new block into new block 
917b 23			      inc   HL 
917c 73			      ld    (HL), E 
917d 23			      inc   HL 
917e 72			      ld    (HL), D 
917f			 
917f			      ; Update this_free ptr to point to new block 
917f 2b			      dec   HL 
9180 2b			      dec   HL 
9181 2b			      dec   HL 
9182			 
9182 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9185 dd 56 03		      ld    D, (IX+3) 
9188			 
9188 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
918b dd 74 03		      ld    (IX+3), H 
918e			 
918e			      ; Modify this_free block to be allocation 
918e eb			      ex    DE, HL 
918f af			      xor   A                       ; Null the next block ptr of allocated block 
9190 77			      ld    (HL), A 
9191 23			      inc   HL 
9192 77			      ld    (HL), A 
9193			 
9193 23			      inc   HL                      ; Store want size into allocated block 
9194 71			      ld    (HL), C 
9195 23			      inc   HL 
9196 70			      ld    (HL), B 
9197 23			      inc   HL 
9198 e5			      push  HL                      ; Address of allocation to return 
9199			 
9199 18 19		      jr    malloc_update_links 
919b			 
919b			malloc_alloc_fit: 
919b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
919c			 
919c					if DEBUG_FORTH_MALLOC 
919c						DMARK "MAf" 
919c						CALLMONITOR 
919c					endif 
919c			      ; Modify this_free block to be allocation 
919c eb			      ex    DE, HL 
919d 2b			      dec   HL 
919e 2b			      dec   HL 
919f 2b			      dec   HL 
91a0			 
91a0 af			      xor   A                       ; Null the next block ptr of allocated block 
91a1 77			      ld    (HL), A 
91a2 23			      inc   HL 
91a3 77			      ld    (HL), A 
91a4			 
91a4 23			      inc   HL                      ; Store address of allocation to return 
91a5 23			      inc   HL 
91a6 23			      inc   HL 
91a7 e5			      push  HL 
91a8			 
91a8			      ; Copy next_free ptr to this_free, remove allocated block from free list 
91a8 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
91ab dd 66 01		      ld    H, (IX+1) 
91ae			 
91ae dd 75 02		      ld    (IX+2), L               ; HL to this_free 
91b1 dd 74 03		      ld    (IX+3), H 
91b4			 
91b4			 
91b4			malloc_update_links: 
91b4			      ; Update prev_free ptr to point to this_free 
91b4 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
91b7 dd 66 05		      ld    H, (IX+5) 
91ba			 
91ba dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
91bd dd 56 03		      ld    D, (IX+3) 
91c0			 
91c0 73			      ld    (HL), E                 ; this_free ptr into prev_free 
91c1 23			      inc   HL 
91c2 72			      ld    (HL), D 
91c3			 
91c3					if DEBUG_FORTH_MALLOC 
91c3						DMARK "Mul" 
91c3						CALLMONITOR 
91c3					endif 
91c3			      ; Clear the Z flag to indicate successful allocation 
91c3 7a			      ld    A, D 
91c4 b3			      or    E 
91c5			 
91c5 d1			      pop   DE                      ; Address of allocation 
91c6					if DEBUG_FORTH_MALLOC 
91c6						DMARK "MAu" 
91c6						CALLMONITOR 
91c6					endif 
91c6			 
91c6			malloc_no_space: 
91c6 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
91c9 39			      add   HL, SP 
91ca f9			      ld    SP, HL 
91cb			 
91cb eb			      ex    DE, HL                  ; Alloc addr into HL for return 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MAN" 
91cc						CALLMONITOR 
91cc					endif 
91cc			 
91cc			malloc_early_exit: 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MAx" 
91cc						CALLMONITOR 
91cc					endif 
91cc dd e1		      pop   IX 
91ce d1			      pop   DE 
91cf c1			      pop   BC 
91d0			 
91d0			if DEBUG_FORTH_MALLOC_HIGH 
91d0			call malloc_guard_exit 
91d0			call malloc_guard_zerolen 
91d0			endif 
91d0 c9			      ret 
91d1			 
91d1			 
91d1			;------------------------------------------------------------------------------ 
91d1			;     free                                                                    : 
91d1			;                                                                             : 
91d1			; Description                                                                 : 
91d1			;     Return the space pointed to by HL to the heap. HL must be an address as : 
91d1			;     returned by malloc, otherwise the behaviour is undefined.               : 
91d1			;                                                                             : 
91d1			;     Where possible, directly adjacent free blocks will be merged together   : 
91d1			;     into larger blocks to help ensure that the heap does not become         : 
91d1			;     excessively fragmented.                                                 : 
91d1			;                                                                             : 
91d1			;     free does not clear or set any other value into the freed space, and    : 
91d1			;     therefore its contents may be visible through subsequent malloc's. The  : 
91d1			;     caller should clear the freed space as required.                        : 
91d1			;                                                                             : 
91d1			;     This implementation of free uses the stack exclusively, and is          : 
91d1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91d1			;     advisable to disable interrupts before calling free, and recommended    : 
91d1			;     to avoid the use of free inside ISRs in general.                        : 
91d1			;                                                                             : 
91d1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91d1			;                                                                             : 
91d1			; Parameters                                                                  : 
91d1			;     HL  Pointer to address of first byte of allocation to be freed          : 
91d1			;                                                                             : 
91d1			; Returns                                                                     : 
91d1			;     Nothing                                                                 : 
91d1			;                                                                             : 
91d1			; Stack frame                                                                 : 
91d1			;       |             |                                                       : 
91d1			;       +-------------+                                                       : 
91d1			;       |     BC      |                                                       : 
91d1			;       +-------------+                                                       : 
91d1			;       |     DE      |                                                       : 
91d1			;       +-------------+                                                       : 
91d1			;       |     IX      |                                                       : 
91d1			;       +-------------+                                                       : 
91d1			;       |  prev_free  |                                                       : 
91d1			;   +2  +-------------+                                                       : 
91d1			;       |  next_free  |                                                       : 
91d1			;   +0  +-------------+                                                       : 
91d1			;       |             |                                                       : 
91d1			;                                                                             : 
91d1			;------------------------------------------------------------------------------ 
91d1			free: 
91d1 c5			      push  BC 
91d2 d5			      push  DE 
91d3 dd e5		      push  IX 
91d5			 
91d5 7c			      ld    A, H                    ; Exit if ptr is null 
91d6 b5			      or    L 
91d7 ca 9b 92		      jp    Z, free_early_exit 
91da			 
91da			      ; Set up stack frame 
91da eb			      ex    DE, HL 
91db 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
91de 39			      add   HL, SP 
91df f9			      ld    SP, HL 
91e0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91e4 dd 39		      add   IX, SP 
91e6			 
91e6			      ; The address in HL points to the start of the useable allocated space, 
91e6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91e6			      ; address of the block itself. 
91e6 eb			      ex    DE, HL 
91e7 11 fc ff		      ld    DE, -4 
91ea 19			      add   HL, DE 
91eb			 
91eb			      ; An allocated block must have a null next block pointer in it 
91eb 7e			      ld    A, (HL) 
91ec 23			      inc   HL 
91ed b6			      or    (HL) 
91ee c2 96 92		      jp    NZ, free_done 
91f1			 
91f1 2b			      dec   HL 
91f2			 
91f2 44			      ld    B, H                    ; Copy HL to BC 
91f3 4d			      ld    C, L 
91f4			 
91f4			      ; Loop through the free list to find the first block with an address 
91f4			      ; higher than the block being freed 
91f4 21 47 e4		      ld    HL, free_list 
91f7			 
91f7			free_find_higher_block: 
91f7 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91f8 23			      inc   HL 
91f9 56			      ld    D, (HL) 
91fa 2b			      dec   HL 
91fb			 
91fb dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91fe dd 72 01		      ld    (IX+1), D 
9201 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9204 dd 74 03		      ld    (IX+3), H 
9207			 
9207 78			      ld    A, B                    ; Check if DE is greater than BC 
9208 ba			      cp    D                       ; Compare MSB first 
9209 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
920b 30 04		      jr    NC, free_find_higher_block_skip 
920d 79			      ld    A, C 
920e bb			      cp    E                       ; Then compare LSB 
920f 38 08		      jr    C, free_found_higher_block 
9211			 
9211			free_find_higher_block_skip: 
9211 7a			      ld    A, D                    ; Reached the end of the free list? 
9212 b3			      or    E 
9213 ca 96 92		      jp    Z, free_done 
9216			 
9216 eb			      ex    DE, HL 
9217			 
9217 18 de		      jr    free_find_higher_block 
9219			 
9219			free_found_higher_block: 
9219			      ; Insert freed block between prev and next free blocks 
9219 71			      ld    (HL), C                 ; Point prev free block to freed block 
921a 23			      inc   HL 
921b 70			      ld    (HL), B 
921c			 
921c 60			      ld    H, B                    ; Point freed block at next free block 
921d 69			      ld    L, C 
921e 73			      ld    (HL), E 
921f 23			      inc   HL 
9220 72			      ld    (HL), D 
9221			 
9221			      ; Check if the freed block is adjacent to the next free block 
9221 23			      inc   HL                      ; Load size of freed block into HL 
9222 5e			      ld    E, (HL) 
9223 23			      inc   HL 
9224 56			      ld    D, (HL) 
9225 eb			      ex    DE, HL 
9226			 
9226 09			      add   HL, BC                  ; Add addr of freed block and its size 
9227			 
9227 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
922a dd 56 01		      ld    D, (IX+1) 
922d			 
922d b7			      or    A                       ; Clear the carry flag 
922e ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9230 20 22		      jr    NZ, free_check_adjacent_to_prev 
9232			 
9232			      ; Freed block is adjacent to next, merge into one bigger block 
9232 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9233 5e			      ld    E, (HL) 
9234 23			      inc   HL 
9235 56			      ld    D, (HL) 
9236 e5			      push  HL                      ; Save ptr to next block for later 
9237			 
9237 60			      ld    H, B                    ; Store ptr from next block into freed block 
9238 69			      ld    L, C 
9239 73			      ld    (HL), E 
923a 23			      inc   HL 
923b 72			      ld    (HL), D 
923c			 
923c e1			      pop   HL                      ; Restore ptr to next block 
923d 23			      inc   HL                      ; Load size of next block into DE 
923e 5e			      ld    E, (HL) 
923f 23			      inc   HL 
9240 56			      ld    D, (HL) 
9241 d5			      push  DE                      ; Save next block size for later 
9242			 
9242 60			      ld    H, B                    ; Load size of freed block into HL 
9243 69			      ld    L, C 
9244 23			      inc   HL 
9245 23			      inc   HL 
9246 5e			      ld    E, (HL) 
9247 23			      inc   HL 
9248 56			      ld    D, (HL) 
9249 eb			      ex    DE, HL 
924a			 
924a d1			      pop   DE                      ; Restore size of next block 
924b 19			      add   HL, DE                  ; Add sizes of both blocks 
924c eb			      ex    DE, HL 
924d			 
924d 60			      ld    H, B                    ; Store new bigger size into freed block 
924e 69			      ld    L, C 
924f 23			      inc   HL 
9250 23			      inc   HL 
9251 73			      ld    (HL), E 
9252 23			      inc   HL 
9253 72			      ld    (HL), D 
9254			 
9254			free_check_adjacent_to_prev: 
9254			      ; Check if the freed block is adjacent to the prev free block 
9254 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9257 dd 66 03		      ld    H, (IX+3) 
925a			 
925a 23			      inc   HL                      ; Size of prev free block into DE 
925b 23			      inc   HL 
925c 5e			      ld    E, (HL) 
925d 23			      inc   HL 
925e 56			      ld    D, (HL) 
925f 2b			      dec   HL 
9260 2b			      dec   HL 
9261 2b			      dec   HL 
9262			 
9262 19			      add   HL, DE                  ; Add prev block addr and size 
9263			 
9263 b7			      or    A                       ; Clear the carry flag 
9264 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9266 20 2e		      jr    NZ, free_done 
9268			 
9268			      ; Freed block is adjacent to prev, merge into one bigger block 
9268 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9269 69			      ld    L, C 
926a 5e			      ld    E, (HL) 
926b 23			      inc   HL 
926c 56			      ld    D, (HL) 
926d e5			      push  HL                      ; Save freed block ptr for later 
926e			 
926e dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9271 dd 66 03		      ld    H, (IX+3) 
9274 73			      ld    (HL), E 
9275 23			      inc   HL 
9276 72			      ld    (HL), D 
9277			 
9277 e1			      pop   HL                      ; Restore freed block ptr 
9278 23			      inc   HL                      ; Load size of freed block into DE 
9279 5e			      ld    E, (HL) 
927a 23			      inc   HL 
927b 56			      ld    D, (HL) 
927c d5			      push  DE                      ; Save freed block size for later 
927d			 
927d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
9280 dd 66 03		      ld    H, (IX+3) 
9283 23			      inc   HL 
9284 23			      inc   HL 
9285 5e			      ld    E, (HL) 
9286 23			      inc   HL 
9287 56			      ld    D, (HL) 
9288			 
9288 e1			      pop   HL                      ; Add sizes of both blocks 
9289 19			      add   HL, DE 
928a eb			      ex    DE, HL 
928b			 
928b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
928e dd 66 03		      ld    H, (IX+3) 
9291 23			      inc   HL 
9292 23			      inc   HL 
9293 73			      ld    (HL), E 
9294 23			      inc   HL 
9295 72			      ld    (HL), D 
9296			 
9296			free_done: 
9296 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9299 39			      add   HL, SP 
929a f9			      ld    SP, HL 
929b			 
929b			free_early_exit: 
929b dd e1		      pop   IX 
929d d1			      pop   DE 
929e c1			      pop   BC 
929f			 
929f c9			      ret 
92a0			 
92a0			; moved to firmware.asm 
92a0			; 
92a0			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92a0			;                  .dw   0 
92a0			 
92a0			 
92a0			endif 
92a0			 
92a0			 
92a0			if MALLOC_3 
92a0			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
92a0			;heap_start        .equ  0x9000      ; Starting address of heap 
92a0			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
92a0			; 
92a0			 ;     .org 0 
92a0			  ;    jp    main 
92a0			; 
92a0			; 
92a0			 ;     .org  0x100 
92a0			;main: 
92a0			 ;     ld    HL, 0x8100 
92a0			  ;    ld    SP, HL 
92a0			; 
92a0			;      call  heap_init 
92a0			 
92a0			      ; Make some allocations 
92a0			;      ld    HL, 12 
92a0			;      call  malloc            ; Allocates 0x9004 
92a0			; 
92a0			 ;     ld    HL, 12 
92a0			;      call  malloc            ; Allocates 0x9014 
92a0			 
92a0			;      ld    HL, 12 
92a0			;      call  malloc            ; Allocates 0x9024 
92a0			 
92a0			      ; Free some allocations 
92a0			;      ld    HL, 0x9014 
92a0			;      call  free 
92a0			 
92a0			;      ld    HL, 0x9004 
92a0			;      call  free 
92a0			; 
92a0			;      ld    HL, 0x9024 
92a0			;      call  free 
92a0			 
92a0			 
92a0			 ;     halt 
92a0			 
92a0			 
92a0			;------------------------------------------------------------------------------ 
92a0			;     heap_init                                                               : 
92a0			;                                                                             : 
92a0			; Description                                                                 : 
92a0			;     Initialise the heap and make it ready for malloc and free operations.   : 
92a0			;                                                                             : 
92a0			;     The heap is maintained as a linked list, starting with an initial       : 
92a0			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
92a0			;     the first free block in the heap. Each block then points to the next    : 
92a0			;     free block within the heap, and the free list ends at the first block   : 
92a0			;     with a null pointer to the next free block.                             : 
92a0			;                                                                             : 
92a0			; Parameters                                                                  : 
92a0			;     Inputs are compile-time only. Two defines which specify the starting    : 
92a0			;     address of the heap and its size are required, along with a memory      : 
92a0			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
92a0			;     principally stores a pointer to the first free block in the heap.       : 
92a0			;                                                                             : 
92a0			; Returns                                                                     : 
92a0			;     Nothing                                                                 : 
92a0			;------------------------------------------------------------------------------ 
92a0			heap_init: 
92a0			      push  HL 
92a0			 
92a0			      ; Initialise free list struct 
92a0			      ld    HL, heap_start 
92a0			      ld    (free_list), HL 
92a0			      ld    HL, 0 
92a0			      ld    (free_list+2), HL 
92a0			 
92a0			      ; Insert first free block at bottom of heap, consumes entire heap 
92a0			      ld    HL, heap_start+heap_size-4 
92a0			      ld    (heap_start), HL        ; Next block (end of free list) 
92a0			      ld    HL, heap_size-4 
92a0			      ld    (heap_start+2), HL      ; Block size 
92a0			 
92a0			      ; Insert end of free list block at top of heap - two null words will 
92a0			      ; terminate the free list 
92a0			      ld    HL, 0 
92a0			      ld    (heap_start+heap_size-2), HL 
92a0			      ld    (heap_start+heap_size-4), HL 
92a0			 
92a0			      pop   HL 
92a0			 
92a0			      ret 
92a0			 
92a0			 
92a0			;------------------------------------------------------------------------------ 
92a0			;     malloc                                                                  : 
92a0			;                                                                             : 
92a0			; Description                                                                 : 
92a0			;     Allocates the wanted space from the heap and returns the address of the : 
92a0			;     first useable byte of the allocation.                                   : 
92a0			;                                                                             : 
92a0			;     Allocations can happen in one of two ways:                              : 
92a0			;                                                                             : 
92a0			;     1. A free block may be found which is the exact size wanted. In this    : 
92a0			;        case the block is removed from the free list and retuedn to the      : 
92a0			;        caller.                                                              : 
92a0			;     2. A free block may be found which is larger than the size wanted. In   : 
92a0			;        this case, the larger block is split into two. The first portion of  : 
92a0			;        this block will become the requested space by the malloc call and    : 
92a0			;        is returned to the caller. The second portion becomes a new free     : 
92a0			;        block, and the free list is adjusted to maintain continuity via this : 
92a0			;        newly created block.                                                 : 
92a0			;                                                                             : 
92a0			;     malloc does not set any initial value in the allocated space, the       : 
92a0			;     caller is required to do this as required.                              : 
92a0			;                                                                             : 
92a0			;     This implementation of malloc uses the stack exclusively, and is        : 
92a0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92a0			;     advisable to disable interrupts before calling malloc, and recommended  : 
92a0			;     to avoid the use of malloc inside ISRs in general.                      : 
92a0			;                                                                             : 
92a0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92a0			;                                                                             : 
92a0			; Parameters                                                                  : 
92a0			;     HL  Number of bytes wanted                                              : 
92a0			;                                                                             : 
92a0			; Returns                                                                     : 
92a0			;     HL  Address of the first useable byte of the allocation                 : 
92a0			;                                                                             : 
92a0			; Flags                                                                       : 
92a0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
92a0			;                                                                             : 
92a0			; Stack frame                                                                 : 
92a0			;       |             |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     BC      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     DE      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     IX      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |  prev_free  |                                                       : 
92a0			;   +4  +-------------+                                                       : 
92a0			;       |  this_free  |                                                       : 
92a0			;   +2  +-------------+                                                       : 
92a0			;       |  next_free  |                                                       : 
92a0			;   +0  +-------------+                                                       : 
92a0			;       |             |                                                       : 
92a0			;                                                                             : 
92a0			;------------------------------------------------------------------------------ 
92a0			malloc: 
92a0			      push  BC 
92a0			      push  DE 
92a0			      push  IX 
92a0			 
92a0			      ld    A, H                    ; Exit if no space requested 
92a0			      or    L 
92a0			      jp    Z, malloc_early_exit 
92a0			 
92a0			      ; Set up stack frame 
92a0			      ex    DE, HL 
92a0			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
92a0			      add   HL, SP 
92a0			      ld    SP, HL 
92a0			      ld    IX, 0                   ; Use IX as a frame pointer 
92a0			      add   IX, SP 
92a0			 
92a0			      ; Setup initial state 
92a0			      ld    HL, 4                   ; want must also include space used by block struct 
92a0			      add   HL, DE 
92a0			 
92a0			      ld    B, H                    ; Move want to BC 
92a0			      ld    C, L 
92a0			 
92a0			      ld    HL, free_list           ; Store prev_free ptr to stack 
92a0			      ld    (IX+4), L 
92a0			      ld    (IX+5), H 
92a0			 
92a0			      ld    E, (HL)                 ; Store this_free ptr to stack 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      ld    (IX+2), E 
92a0			      ld    (IX+3), D 
92a0			      ex    DE, HL                  ; this_free ptr into HL 
92a0			 
92a0			      ; Loop through free block list to find some space 
92a0			malloc_find_space: 
92a0			      ld    E, (HL)                 ; Load next_free ptr into DE 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			 
92a0			      ld    A, D                    ; Check for null next_free ptr - end of free list 
92a0			      or    E 
92a0			      jp    Z, malloc_no_space 
92a0			 
92a0			      ld    (IX+0), E               ; Store next_free ptr to stack 
92a0			      ld    (IX+1), D 
92a0			 
92a0			      ; Does this block have enough space to make the allocation? 
92a0			      inc   HL                      ; Load free block size into DE 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			 
92a0			      ex    DE, HL                  ; Check size of block against want 
92a0			      or    A                       ; Ensure carry flag clear 
92a0			      sbc   HL, BC 
92a0			      push  HL                      ; Store the result for later (new block size) 
92a0			 
92a0			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
92a0			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
92a0			 
92a0			      ; this_free block is not big enough, setup ptrs to test next free block 
92a0			      pop   HL                      ; Discard previous result 
92a0			 
92a0			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
92a0			      ld    H, (IX+3) 
92a0			      ld    (IX+4), L 
92a0			      ld    (IX+5), H 
92a0			 
92a0			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
92a0			      ld    H, (IX+1) 
92a0			      ld    (IX+2), L 
92a0			      ld    (IX+3), H 
92a0			 
92a0			      jr    malloc_find_space 
92a0			 
92a0			      ; split a bigger block into two - requested size and remaining size 
92a0			malloc_alloc_split: 
92a0			      ex    DE, HL                  ; Calculate address of new free block 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			      add   HL, BC 
92a0			 
92a0			      ; Create a new block and point it at next_free 
92a0			      ld    E, (IX+0)               ; Load next_free ptr into DE 
92a0			      ld    D, (IX+1) 
92a0			 
92a0			      ld    (HL), E                 ; Store next_free ptr into new block 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      pop   DE                      ; Store size of new block into new block 
92a0			      inc   HL 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      ; Update this_free ptr to point to new block 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			 
92a0			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
92a0			      ld    D, (IX+3) 
92a0			 
92a0			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
92a0			      ld    (IX+3), H 
92a0			 
92a0			      ; Modify this_free block to be allocation 
92a0			      ex    DE, HL 
92a0			      xor   A                       ; Null the next block ptr of allocated block 
92a0			      ld    (HL), A 
92a0			      inc   HL 
92a0			      ld    (HL), A 
92a0			 
92a0			      inc   HL                      ; Store want size into allocated block 
92a0			      ld    (HL), C 
92a0			      inc   HL 
92a0			      ld    (HL), B 
92a0			      inc   HL 
92a0			      push  HL                      ; Address of allocation to return 
92a0			 
92a0			      jr    malloc_update_links 
92a0			 
92a0			malloc_alloc_fit: 
92a0			      pop   HL                      ; Dont need new block size, want is exact fit 
92a0			 
92a0			      ; Modify this_free block to be allocation 
92a0			      ex    DE, HL 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			 
92a0			      xor   A                       ; Null the next block ptr of allocated block 
92a0			      ld    (HL), A 
92a0			      inc   HL 
92a0			      ld    (HL), A 
92a0			 
92a0			      inc   HL                      ; Store address of allocation to return 
92a0			      inc   HL 
92a0			      inc   HL 
92a0			      push  HL 
92a0			 
92a0			      ; Copy next_free ptr to this_free, remove allocated block from free list 
92a0			      ld    L, (IX+0)               ; next_free to HL 
92a0			      ld    H, (IX+1) 
92a0			 
92a0			      ld    (IX+2), L               ; HL to this_free 
92a0			      ld    (IX+3), H 
92a0			 
92a0			 
92a0			malloc_update_links: 
92a0			      ; Update prev_free ptr to point to this_free 
92a0			      ld    L, (IX+4)               ; prev_free ptr to HL 
92a0			      ld    H, (IX+5) 
92a0			 
92a0			      ld    E, (IX+2)               ; this_free ptr to DE 
92a0			      ld    D, (IX+3) 
92a0			 
92a0			      ld    (HL), E                 ; this_free ptr into prev_free 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      ; Clear the Z flag to indicate successful allocation 
92a0			      ld    A, D 
92a0			      or    E 
92a0			 
92a0			      pop   DE                      ; Address of allocation 
92a0			 
92a0			malloc_no_space: 
92a0			      ld    HL, 6                   ; Clean up stack frame 
92a0			      add   HL, SP 
92a0			      ld    SP, HL 
92a0			 
92a0			      ex    DE, HL                  ; Alloc addr into HL for return 
92a0			 
92a0			malloc_early_exit: 
92a0			      pop   IX 
92a0			      pop   DE 
92a0			      pop   BC 
92a0			 
92a0			      ret 
92a0			 
92a0			 
92a0			;------------------------------------------------------------------------------ 
92a0			;     free                                                                    : 
92a0			;                                                                             : 
92a0			; Description                                                                 : 
92a0			;     Return the space pointed to by HL to the heap. HL must be an address as : 
92a0			;     returned by malloc, otherwise the behaviour is undefined.               : 
92a0			;                                                                             : 
92a0			;     Where possible, directly adjacent free blocks will be merged together   : 
92a0			;     into larger blocks to help ensure that the heap does not become         : 
92a0			;     excessively fragmented.                                                 : 
92a0			;                                                                             : 
92a0			;     free does not clear or set any other value into the freed space, and    : 
92a0			;     therefore its contents may be visible through subsequent malloc's. The  : 
92a0			;     caller should clear the freed space as required.                        : 
92a0			;                                                                             : 
92a0			;     This implementation of free uses the stack exclusively, and is          : 
92a0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92a0			;     advisable to disable interrupts before calling free, and recommended    : 
92a0			;     to avoid the use of free inside ISRs in general.                        : 
92a0			;                                                                             : 
92a0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92a0			;                                                                             : 
92a0			; Parameters                                                                  : 
92a0			;     HL  Pointer to address of first byte of allocation to be freed          : 
92a0			;                                                                             : 
92a0			; Returns                                                                     : 
92a0			;     Nothing                                                                 : 
92a0			;                                                                             : 
92a0			; Stack frame                                                                 : 
92a0			;       |             |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     BC      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     DE      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |     IX      |                                                       : 
92a0			;       +-------------+                                                       : 
92a0			;       |  prev_free  |                                                       : 
92a0			;   +2  +-------------+                                                       : 
92a0			;       |  next_free  |                                                       : 
92a0			;   +0  +-------------+                                                       : 
92a0			;       |             |                                                       : 
92a0			;                                                                             : 
92a0			;------------------------------------------------------------------------------ 
92a0			free: 
92a0			      push  BC 
92a0			      push  DE 
92a0			      push  IX 
92a0			 
92a0			      ld    A, H                    ; Exit if ptr is null 
92a0			      or    L 
92a0			      jp    Z, free_early_exit 
92a0			 
92a0			      ; Set up stack frame 
92a0			      ex    DE, HL 
92a0			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
92a0			      add   HL, SP 
92a0			      ld    SP, HL 
92a0			      ld    IX, 0                   ; Use IX as a frame pointer 
92a0			      add   IX, SP 
92a0			 
92a0			      ; The address in HL points to the start of the useable allocated space, 
92a0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
92a0			      ; address of the block itself. 
92a0			      ex    DE, HL 
92a0			      ld    DE, -4 
92a0			      add   HL, DE 
92a0			 
92a0			      ; An allocated block must have a null next block pointer in it 
92a0			      ld    A, (HL) 
92a0			      inc   HL 
92a0			      or    (HL) 
92a0			      jp    NZ, free_done 
92a0			 
92a0			      dec   HL 
92a0			 
92a0			      ld    B, H                    ; Copy HL to BC 
92a0			      ld    C, L 
92a0			 
92a0			      ; Loop through the free list to find the first block with an address 
92a0			      ; higher than the block being freed 
92a0			      ld    HL, free_list 
92a0			 
92a0			free_find_higher_block: 
92a0			      ld    E, (HL)                 ; Load next ptr from free block 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      dec   HL 
92a0			 
92a0			      ld    (IX+0), E               ; Save ptr to next free block 
92a0			      ld    (IX+1), D 
92a0			      ld    (IX+2), L               ; Save ptr to prev free block 
92a0			      ld    (IX+3), H 
92a0			 
92a0			      ld    A, B                    ; Check if DE is greater than BC 
92a0			      cp    D                       ; Compare MSB first 
92a0			      jr    Z, $+4                  ; MSB the same, compare LSB 
92a0			      jr    NC, free_find_higher_block_skip 
92a0			      ld    A, C 
92a0			      cp    E                       ; Then compare LSB 
92a0			      jr    C, free_found_higher_block 
92a0			 
92a0			free_find_higher_block_skip: 
92a0			      ld    A, D                    ; Reached the end of the free list? 
92a0			      or    E 
92a0			      jp    Z, free_done 
92a0			 
92a0			      ex    DE, HL 
92a0			 
92a0			      jr    free_find_higher_block 
92a0			 
92a0			free_found_higher_block: 
92a0			      ; Insert freed block between prev and next free blocks 
92a0			      ld    (HL), C                 ; Point prev free block to freed block 
92a0			      inc   HL 
92a0			      ld    (HL), B 
92a0			 
92a0			      ld    H, B                    ; Point freed block at next free block 
92a0			      ld    L, C 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      ; Check if the freed block is adjacent to the next free block 
92a0			      inc   HL                      ; Load size of freed block into HL 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      ex    DE, HL 
92a0			 
92a0			      add   HL, BC                  ; Add addr of freed block and its size 
92a0			 
92a0			      ld    E, (IX+0)               ; Load addr of next free block into DE 
92a0			      ld    D, (IX+1) 
92a0			 
92a0			      or    A                       ; Clear the carry flag 
92a0			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92a0			      jr    NZ, free_check_adjacent_to_prev 
92a0			 
92a0			      ; Freed block is adjacent to next, merge into one bigger block 
92a0			      ex    DE, HL                  ; Load next ptr from next block into DE 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      push  HL                      ; Save ptr to next block for later 
92a0			 
92a0			      ld    H, B                    ; Store ptr from next block into freed block 
92a0			      ld    L, C 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      pop   HL                      ; Restore ptr to next block 
92a0			      inc   HL                      ; Load size of next block into DE 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      push  DE                      ; Save next block size for later 
92a0			 
92a0			      ld    H, B                    ; Load size of freed block into HL 
92a0			      ld    L, C 
92a0			      inc   HL 
92a0			      inc   HL 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      ex    DE, HL 
92a0			 
92a0			      pop   DE                      ; Restore size of next block 
92a0			      add   HL, DE                  ; Add sizes of both blocks 
92a0			      ex    DE, HL 
92a0			 
92a0			      ld    H, B                    ; Store new bigger size into freed block 
92a0			      ld    L, C 
92a0			      inc   HL 
92a0			      inc   HL 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			free_check_adjacent_to_prev: 
92a0			      ; Check if the freed block is adjacent to the prev free block 
92a0			      ld    L, (IX+2)               ; Prev free block ptr into HL 
92a0			      ld    H, (IX+3) 
92a0			 
92a0			      inc   HL                      ; Size of prev free block into DE 
92a0			      inc   HL 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			      dec   HL 
92a0			 
92a0			      add   HL, DE                  ; Add prev block addr and size 
92a0			 
92a0			      or    A                       ; Clear the carry flag 
92a0			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92a0			      jr    NZ, free_done 
92a0			 
92a0			      ; Freed block is adjacent to prev, merge into one bigger block 
92a0			      ld    H, B                    ; Load next ptr from freed block into DE 
92a0			      ld    L, C 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      push  HL                      ; Save freed block ptr for later 
92a0			 
92a0			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92a0			      ld    H, (IX+3) 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			      pop   HL                      ; Restore freed block ptr 
92a0			      inc   HL                      ; Load size of freed block into DE 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			      push  DE                      ; Save freed block size for later 
92a0			 
92a0			      ld    L, (IX+2)               ; Load size of prev block into DE 
92a0			      ld    H, (IX+3) 
92a0			      inc   HL 
92a0			      inc   HL 
92a0			      ld    E, (HL) 
92a0			      inc   HL 
92a0			      ld    D, (HL) 
92a0			 
92a0			      pop   HL                      ; Add sizes of both blocks 
92a0			      add   HL, DE 
92a0			      ex    DE, HL 
92a0			 
92a0			      ld    L, (IX+2)               ; Store new bigger size into prev block 
92a0			      ld    H, (IX+3) 
92a0			      inc   HL 
92a0			      inc   HL 
92a0			      ld    (HL), E 
92a0			      inc   HL 
92a0			      ld    (HL), D 
92a0			 
92a0			free_done: 
92a0			      ld    HL, 4                   ; Clean up stack frame 
92a0			      add   HL, SP 
92a0			      ld    SP, HL 
92a0			 
92a0			free_early_exit: 
92a0			      pop   IX 
92a0			      pop   DE 
92a0			      pop   BC 
92a0			 
92a0			      ret 
92a0			 
92a0			 
92a0			;      .org 0x8000 
92a0			; 
92a0			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92a0			 ;                 .dw   0 
92a0			 
92a0			endif 
92a0			 
92a0			 
92a0			if MALLOC_4 
92a0			 
92a0			; My memory allocation code. Very very simple.... 
92a0			; allocate space under 250 chars 
92a0			 
92a0			heap_init: 
92a0				; init start of heap as zero 
92a0				;  
92a0			 
92a0				ld hl, heap_start 
92a0				ld a, 0 
92a0				ld (hl), a      ; empty block 
92a0				inc hl 
92a0				ld a, 0 
92a0				ld (hl), a      ; length of block 
92a0				; write end of list 
92a0				inc hl 
92a0				ld a,(hl) 
92a0				inc hl 
92a0				ld a,(hl) 
92a0				 
92a0			 
92a0				; init some malloc vars 
92a0			 
92a0				ld hl, 0 
92a0				ld (free_list), hl       ; store last malloc location 
92a0			 
92a0				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
92a0				ld a, 0 
92a0				ld (hl), a 
92a0			 
92a0			 
92a0				ld hl, heap_start 
92a0				;  
92a0				  
92a0				ret 
92a0			 
92a0			 
92a0			;    free block marker 
92a0			;    requested size  
92a0			;    pointer to next block 
92a0			;    .... 
92a0			;    next block marker 
92a0			 
92a0			 
92a0			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
92a0			; 
92a0			 
92a0			 
92a0			malloc:  
92a0				push de 
92a0				push bc 
92a0				push af 
92a0			 
92a0				; hl space required 
92a0				 
92a0				ld c, l    ; hold space   (TODO only a max of 255) 
92a0			 
92a0			;	inc c     ; TODO BUG need to fix memory leak on push str 
92a0			;	inc c 
92a0			;	inc c 
92a0			;	inc c 
92a0			;	inc c 
92a0			;	inc c 
92a0			;	inc c 
92a0			 
92a0			 
92a0			 
92a0				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
92a0			 
92a0				ld a, (free_list+3) 
92a0				cp 0 
92a0				jr z, .contheap 
92a0			 
92a0				ld hl, (free_list)     ; get last alloc 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "mrs" 
92a0						CALLMONITOR 
92a0					endif 
92a0				jr .startalloc 
92a0			 
92a0			.contheap: 
92a0				ld hl, heap_start 
92a0			 
92a0			.startalloc: 
92a0			 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "mym" 
92a0						CALLMONITOR 
92a0					endif 
92a0			.findblock: 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "mmf" 
92a0						CALLMONITOR 
92a0					endif 
92a0			 
92a0				ld a,(hl)  
92a0				; if byte is zero then clear to use 
92a0			 
92a0				cp 0 
92a0				jr z, .foundemptyblock 
92a0			 
92a0				; if byte is not clear 
92a0				;     then byte is offset to next block 
92a0			 
92a0				inc hl 
92a0				ld a, (hl) ; get size 
92a0			.nextblock:	inc hl 
92a0					ld e, (hl) 
92a0					inc hl 
92a0					ld d, (hl) 
92a0					ex de, hl 
92a0			;	inc hl  ; move past the store space 
92a0			;	inc hl  ; move past zero index  
92a0			 
92a0				; TODO detect no more space 
92a0			 
92a0				push hl 
92a0				ld de, heap_end 
92a0				call cmp16 
92a0				pop hl 
92a0				jr nc, .nospace 
92a0			 
92a0				jr .findblock 
92a0			 
92a0			.nospace: ld hl, 0 
92a0				jp .exit 
92a0			 
92a0			 
92a0			.foundemptyblock:	 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "mme" 
92a0						CALLMONITOR 
92a0					endif 
92a0			 
92a0			; TODO has block enough space if reusing??? 
92a0			 
92a0				;  
92a0			 
92a0			; see if this block has been previously used 
92a0				inc hl 
92a0				ld a, (hl) 
92a0				dec hl 
92a0				cp 0 
92a0				jr z, .newblock 
92a0			 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "meR" 
92a0						CALLMONITOR 
92a0					endif 
92a0			 
92a0			; no reusing previously allocated block 
92a0			 
92a0			; is it smaller than previously used? 
92a0				 
92a0				inc hl    ; move to size 
92a0				ld a, c 
92a0				sub (hl)        ; we want c < (hl) 
92a0				dec hl    ; move back to marker 
92a0			        jr z, .findblock 
92a0			 
92a0				; update with the new size which should be lower 
92a0			 
92a0			        ;inc  hl   ; negate next move. move back to size  
92a0			 
92a0			.newblock: 
92a0				; need to be at marker here 
92a0			 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "meN" 
92a0						CALLMONITOR 
92a0					endif 
92a0			 
92a0			 
92a0				ld a, c 
92a0			 
92a0				ld (free_list+3), a	 ; flag resume from last malloc  
92a0				ld (free_list), hl    ; save out last location 
92a0			 
92a0			 
92a0				;inc a     ; space for length byte 
92a0				ld (hl), a     ; save block in use marker 
92a0			 
92a0				inc hl   ; move to space marker 
92a0				ld (hl), a    ; save new space 
92a0			 
92a0				inc hl   ; move to start of allocated area 
92a0				 
92a0			;	push hl     ; save where we are - 1  
92a0			 
92a0			;	inc hl  ; move past zero index  
92a0				; skip space to set down new marker 
92a0			 
92a0				; provide some extra space for now 
92a0			 
92a0				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
92a0				inc a 
92a0				inc a 
92a0			 
92a0				push hl   ; save where we are in the node block 
92a0			 
92a0				call addatohl 
92a0			 
92a0				; write linked list point 
92a0			 
92a0				pop de     ; get our node position 
92a0				ex de, hl 
92a0			 
92a0				ld (hl), e 
92a0				inc hl 
92a0				ld (hl), d 
92a0			 
92a0				inc hl 
92a0			 
92a0				; now at start of allocated data so save pointer 
92a0			 
92a0				push hl 
92a0			 
92a0				; jump to position of next node and setup empty header in DE 
92a0			 
92a0				ex de, hl 
92a0			 
92a0			;	inc hl ; move past end of block 
92a0			 
92a0				ld a, 0 
92a0				ld (hl), a   ; empty marker 
92a0				inc hl 
92a0				ld (hl), a   ; size 
92a0				inc hl  
92a0				ld (hl), a   ; ptr 
92a0				inc hl 
92a0				ld (hl), a   ; ptr 
92a0			 
92a0			 
92a0				pop hl 
92a0			 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "mmr" 
92a0						CALLMONITOR 
92a0					endif 
92a0			 
92a0			.exit: 
92a0				pop af 
92a0				pop bc 
92a0				pop de  
92a0				ret 
92a0			 
92a0			 
92a0			 
92a0			 
92a0			free:  
92a0				push hl 
92a0				push af 
92a0				; get address in hl 
92a0			 
92a0					if DEBUG_FORTH_MALLOC_INT 
92a0						DMARK "fre" 
92a0						CALLMONITOR 
92a0					endif 
92a0				; data is at hl - move to block count 
92a0				dec hl 
92a0				dec hl    ; get past pointer 
92a0				dec hl 
92a0			 
92a0				ld a, (hl)    ; need this for a validation check 
92a0			 
92a0				dec hl    ; move to block marker 
92a0			 
92a0				; now check that the block count and block marker are the same  
92a0			        ; this checks that we are on a malloc node and not random memory 
92a0			        ; OK a faint chance this could be a problem but rare - famous last words! 
92a0			 
92a0				ld c, a 
92a0				ld a, (hl)    
92a0			 
92a0				cp c 
92a0				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
92a0			 
92a0				; yes good chance we are on a malloc node 
92a0			 
92a0				ld a, 0      
92a0				ld (hl), a   ; mark as free 
92a0			 
92a0				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
92a0			 
92a0			.freeignore:  
92a0			 
92a0				pop af 
92a0				pop hl 
92a0			 
92a0				ret 
92a0			 
92a0			 
92a0			 
92a0			endif 
92a0			 
92a0			; eof 
# End of file firmware_memory.asm
92a0			  
92a0			; device C  
92a0			; Now handled by SPI  
92a0			;if SOUND_ENABLE  
92a0			;	include "firmware_sound.asm"  
92a0			;endif  
92a0			  
92a0			include "firmware_diags.asm"  
92a0			; Hardware diags menu 
92a0			 
92a0			 
92a0			config: 
92a0			 
92a0 3e 00			ld a, 0 
92a2 21 c6 92			ld hl, .configmn 
92a5 cd df 8a			call menu 
92a8			 
92a8 fe 00			cp 0 
92aa c8				ret z 
92ab			 
92ab			;	cp 1 
92ab			;	call z, .savetostore 
92ab			 
92ab fe 01			cp 1 
92ad			if STARTUP_V1 
92ad cc dc 92			call z, .selautoload 
92b0			endif 
92b0			 
92b0			if STARTUP_V2 
92b0				call z, .enautoload 
92b0			endif 
92b0 fe 02			cp 2 
92b2 cc d2 92			call z, .disautoload 
92b5			;	cp 3 
92b5			;	call z, .selbank 
92b5 fe 03			cp 3 
92b7 cc fa 92			call z, .debug_tog 
92ba fe 04			cp 4 
92bc cc 48 94			call z, .bpsgo 
92bf fe 05			cp 5 
92c1 cc 23 93			call z, hardware_diags 
92c4			if STARTUP_V2 
92c4				cp 6 
92c4				call z, create_startup 
92c4			endif 
92c4 18 da			jr config 
92c6			 
92c6			.configmn: 
92c6			;	dw prom_c3 
92c6 36 96			dw prom_c2 
92c8 4b 96			dw prom_c2a 
92ca			;	dw prom_c2b 
92ca			;	dw prom_c4 
92ca 6a 96			dw prom_m4 
92cc 85 96			dw prom_m4b 
92ce 8d 96			dw prom_c1 
92d0			if STARTUP_V2 
92d0				dw prom_c9 
92d0			endif 
92d0 00 00			dw 0 
92d2				 
92d2			 
92d2			if STARTUP_V2 
92d2			.enautoload: 
92d2				if STORAGE_SE 
92d2				ld a, $fe      ; bit 0 clear 
92d2				ld (spi_device), a 
92d2			 
92d2				call storage_get_block_0 
92d2			 
92d2				ld a, 1 
92d2				ld (store_page+STORE_0_AUTOFILE), a 
92d2			 
92d2					ld hl, 0 
92d2					ld de, store_page 
92d2				call storage_write_block	 ; save update 
92d2				else 
92d2			 
92d2				ld hl, prom_notav 
92d2				ld de, prom_empty 
92d2				call info_panel 
92d2				endif 
92d2			 
92d2			 
92d2				ret 
92d2			endif 
92d2			 
92d2			.disautoload: 
92d2				if STORAGE_SE 
92d2				ld a, $fe      ; bit 0 clear 
92d2				ld (spi_device), a 
92d2			 
92d2				call storage_get_block_0 
92d2			 
92d2				ld a, 0 
92d2				ld (store_page+STORE_0_AUTOFILE), a 
92d2			 
92d2					ld hl, 0 
92d2					ld de, store_page 
92d2				call storage_write_block	 ; save update 
92d2				else 
92d2			 
92d2 21 9c 96			ld hl, prom_notav 
92d5 11 b2 96			ld de, prom_empty 
92d8 cd 3f 8a			call info_panel 
92db				endif 
92db			 
92db			 
92db c9				ret 
92dc			 
92dc			if STARTUP_V1 
92dc			 
92dc			; Select auto start 
92dc			 
92dc			.selautoload: 
92dc			 
92dc				 
92dc				if STORAGE_SE 
92dc			 
92dc					call config_dir 
92dc				        ld hl, scratch 
92dc					ld a, 0 
92dc					call menu 
92dc			 
92dc					cp 0 
92dc					ret z 
92dc			 
92dc					dec a 
92dc			 
92dc			 
92dc					; locate menu option 
92dc			 
92dc					ld hl, scratch 
92dc					call table_lookup 
92dc			 
92dc					if DEBUG_FORTH_WORDS 
92dc						DMARK "ALl" 
92dc						CALLMONITOR 
92dc					endif 
92dc					; with the pointer to the menu it, the byte following the zero term is the file id 
92dc			 
92dc					ld a, 0 
92dc					ld bc, 50   ; max of bytes to look at 
92dc					cpir  
92dc			 
92dc					if DEBUG_FORTH_WORDS 
92dc						DMARK "ALb" 
92dc						CALLMONITOR 
92dc					endif 
92dc					;inc hl 
92dc			 
92dc					ld a, (hl)   ; file id 
92dc					 
92dc				        ; save bank and file ids 
92dc			 
92dc					push af 
92dc			 
92dc			; TODO need to save to block 0 on bank 1	 
92dc			 
92dc					call storage_get_block_0 
92dc			 
92dc					if DEBUG_FORTH_WORDS 
92dc						DMARK "AL0" 
92dc						CALLMONITOR 
92dc					endif 
92dc					pop af 
92dc			 
92dc					ld (store_page+STORE_0_FILERUN),a 
92dc					 
92dc					; save bank id 
92dc			 
92dc					ld a,(spi_device) 
92dc					ld (store_page+STORE_0_BANKRUN),a 
92dc			 
92dc					; enable auto run of store file 
92dc			 
92dc					ld a, 1 
92dc					ld (store_page+STORE_0_AUTOFILE),a 
92dc			 
92dc					; save buffer 
92dc			 
92dc					ld hl, 0 
92dc					ld de, store_page 
92dc					if DEBUG_FORTH_WORDS 
92dc						DMARK "ALw" 
92dc						CALLMONITOR 
92dc					endif 
92dc				call storage_write_block	 ; save update 
92dc			  
92dc			 
92dc			 
92dc			 
92dc					ld hl, scratch 
92dc					call config_fdir 
92dc			 
92dc				else 
92dc			 
92dc 21 9c 96			ld hl, prom_notav 
92df 11 b2 96			ld de, prom_empty 
92e2 cd 3f 8a			call info_panel 
92e5			 
92e5				endif 
92e5 c9				ret 
92e6			endif 
92e6			 
92e6			 
92e6			; Select storage bank 
92e6			 
92e6			.selbank: 
92e6			 
92e6			;	if STORAGE_SE 
92e6			;	else 
92e6			 
92e6 21 9c 96			ld hl, prom_notav 
92e9 11 b2 96			ld de, prom_empty 
92ec cd 3f 8a			call info_panel 
92ef			;	endif 
92ef				 
92ef c9				ret 
92f0			 
92f0			if STORAGE_SE 
92f0			 
92f0			.config_ldir:   
92f0				; Load storage bank labels into menu array 
92f0			 
92f0				 
92f0			 
92f0			 
92f0				ret 
92f0			 
92f0			 
92f0			endif 
92f0			 
92f0			 
92f0			; Save user words to storage 
92f0			 
92f0			.savetostore: 
92f0			 
92f0			;	if STORAGE_SE 
92f0			; 
92f0			;		call config_dir 
92f0			;	        ld hl, scratch 
92f0			;		ld a, 0 
92f0			;		call menu 
92f0			;		 
92f0			;		ld hl, scratch 
92f0			;		call config_fdir 
92f0			; 
92f0			;	else 
92f0			 
92f0 21 9c 96			ld hl, prom_notav 
92f3 11 b2 96			ld de, prom_empty 
92f6 cd 3f 8a			call info_panel 
92f9			 
92f9			;	endif 
92f9			 
92f9 c9				ret 
92fa			 
92fa			if STARTUP_V2 
92fa			 
92fa			create_startup: 
92fa			 
92fa				ld a, 0 
92fa				ld hl, .crstart 
92fa				call menu 
92fa			 
92fa				cp 0 
92fa				ret z 
92fa			 
92fa				cp 1 
92fa				call z, .genlsword 
92fa				cp 2 
92fa				call z, .genedword 
92fa			 
92fa				cp 3 
92fa				call z, .gendemword 
92fa			 
92fa				cp 4 
92fa				call z, .genutlword 
92fa				cp 5 
92fa				call z, .genspiword 
92fa				cp 6 
92fa				call z, .genkeyword 
92fa				cp 7 
92fa				call z, .gensoundword 
92fa				jr create_startup 
92fa			 
92fa			.gensoundword: 
92fa				ld hl, crs_sound 
92fa				ld de, .soundworddef 
92fa				call .genfile 
92fa				ret 
92fa			.genlsword: 
92fa				ld hl, crs_s1 
92fa				ld de, .lsworddef 
92fa				call .genfile 
92fa				ret 
92fa			 
92fa			.genedword: 
92fa				ld de, .edworddef 
92fa				ld hl, crs_s2 
92fa				call .genfile 
92fa				ret 
92fa			 
92fa			.gendemword: 
92fa				ld de, .demoworddef 
92fa				ld hl, crs_s3 
92fa				call .genfile 
92fa				ret 
92fa			 
92fa			.genutlword: 
92fa				ld hl, crs_s4 
92fa				ld de, .utilwordef 
92fa				call .genfile 
92fa				ret 
92fa			.genspiword: 
92fa				ld hl, crs_s5 
92fa				ld de, .spiworddef 
92fa				call .genfile 
92fa				ret 
92fa			.genkeyword: 
92fa				ld hl, crs_s6 
92fa				ld de, .keyworddef 
92fa				call .genfile 
92fa				ret 
92fa			 
92fa			; hl - points to file name 
92fa			; de - points to strings to add to file 
92fa			 
92fa			.genfile: 
92fa				push hl 
92fa				push de 
92fa			 
92fa				call clear_display 
92fa				ld a, display_row_1 
92fa				ld de, .genfiletxt 
92fa				call str_at_display 
92fa				call update_display 
92fa			 
92fa				pop de 
92fa				pop hl 
92fa			 
92fa			 
92fa				push de 
92fa				call storage_create 
92fa				; id in hl 
92fa				pop de   ; table of strings to add 
92fa			 
92fa			.genloop: 
92fa			 
92fa				push hl ; save id for next time around 
92fa				push de ; save de for next time around 
92fa			 
92fa				ex de, hl 
92fa				call loadwordinhl 
92fa				ex de, hl 
92fa			 
92fa				; need hl to be the id 
92fa				; need de to be the string ptr 
92fa				 
92fa				call storage_append 
92fa			 
92fa				pop de 
92fa				pop hl 
92fa			 
92fa				inc de 
92fa				inc de 
92fa			 
92fa				ld a,(de) 
92fa				cp 0 
92fa				jr nz, .genloop 
92fa				inc de 
92fa				ld a, (de) 
92fa				dec de 
92fa				cp 0 
92fa				jr nz, .genloop	 
92fa			 
92fa				ret 
92fa			 
92fa			.genfiletxt:  db "Creating file...",0 
92fa			 
92fa			.soundworddef: 
92fa				dw sound1 
92fa				dw sound2 
92fa				dw sound3 
92fa				dw sound4 
92fa				dw sound5 
92fa				dw sound6 
92fa				dw sound7 
92fa				dw sound8 
92fa				dw sound9 
92fa				dw 0 
92fa			 
92fa			.utilwordef: 
92fa				dw strncpy 
92fa				dw type 
92fa				dw clrstack 
92fa				dw longread 
92fa				dw start1 
92fa				dw start2 
92fa			; duplicated 
92fa			;	dw start3b 
92fa			;	dw start3c 
92fa				dw list 
92fa				dw 0 
92fa			 
92fa			.lsworddef: 
92fa				dw start3b 
92fa				dw 0 
92fa			 
92fa			.edworddef: 
92fa				dw edit1 
92fa				dw edit2 
92fa				dw edit3 
92fa				dw 0 
92fa			 
92fa			.demoworddef: 
92fa				dw test5 
92fa				dw test6 
92fa				dw test7 
92fa				dw test8 
92fa				dw test9 
92fa				dw test10 
92fa				dw game1 
92fa				dw game1a 
92fa				dw game1b 
92fa				dw game1c 
92fa				dw game1d 
92fa				dw game1s 
92fa				dw game1t 
92fa				dw game1f 
92fa				dw game1z 
92fa				dw game1zz 
92fa				dw ssv2 
92fa				dw ssv3 
92fa				dw ssv4 
92fa				dw ssv5 
92fa				dw ssv1 
92fa				dw ssv1cpm	 
92fa				dw game2b 
92fa				dw game2bf 
92fa				dw game2mba 
92fa				dw game2mbas	 
92fa				dw game2mbht 
92fa				dw game2mbms 
92fa				dw game2mb 
92fa				dw game3w 
92fa				dw game3p 
92fa				dw game3sc 
92fa				dw game3vsi 
92fa				dw game3vs 
92fa				dw 0 
92fa			 
92fa			 
92fa			.spiworddef: 
92fa			 
92fa			    dw spi1 
92fa			    dw spi2 
92fa			    dw spi2b 
92fa			    dw spi3 
92fa			    dw spi4 
92fa			    dw spi5 
92fa			;    dw spi6 
92fa			;    dw spi7 
92fa			 
92fa			;    dw spi8 
92fa			;    dw spi9 
92fa			;    dw spi10 
92fa			    dw 0 
92fa			 
92fa			.keyworddef: 
92fa			 
92fa				dw keyup 
92fa				dw keydown 
92fa				dw keyleft 
92fa				dw keyright 
92fa				dw 	keyf1 
92fa				dw keyf2 
92fa				dw keyf3 
92fa				dw keyf4 
92fa				dw keyf5 
92fa				dw keyf6 
92fa				dw keyf7 
92fa				dw keyf8 
92fa				dw keyf9 
92fa				dw keyf10 
92fa				dw keyf11 
92fa				dw keyf12 
92fa				dw keytab 
92fa				dw keycr 
92fa				dw keyhome 
92fa				dw keyend 
92fa				dw keybs 
92fa				dw 0 
92fa			 
92fa			.crstart: 
92fa				dw crs_s1 
92fa				dw crs_s2 
92fa				dw crs_s3 
92fa				dw crs_s4 
92fa				dw crs_s5 
92fa				dw crs_s6 
92fa				dw crs_sound 
92fa				dw 0 
92fa			 
92fa			endif 
92fa			 
92fa			 
92fa			if STORAGE_SE 
92fa			 
92fa			config_fdir: 
92fa				; using the scratch dir go through and release the memory allocated for each string 
92fa				 
92fa				ld hl, scratch 
92fa			.cfdir:	ld e,(hl) 
92fa				inc hl 
92fa				ld d,(hl) 
92fa				inc hl 
92fa			 
92fa				ex de, hl 
92fa				call ishlzero 
92fa				ret z     ; return on null pointer 
92fa				call free 
92fa				ex de, hl 
92fa				jr .cfdir 
92fa			 
92fa			 
92fa				ret 
92fa			 
92fa			 
92fa			config_dir: 
92fa			 
92fa				; for the config menus that need to build a directory of storage call this routine 
92fa				; it will construct a menu in scratch to pass to menu 
92fa			 
92fa				; open storage device 
92fa			 
92fa				; execute DIR to build a list of files and their ids into scratch in menu format 
92fa				; once the menu has finished then will need to call config_fdir to release the strings 
92fa				 
92fa				; c = number items 
92fa			 
92fa				 
92fa				call storage_get_block_0 
92fa			 
92fa				ld hl, store_page     ; get current id count 
92fa				ld b, (hl) 
92fa				ld c, 0    ; count of files   
92fa			 
92fa			 
92fa				ld hl, scratch 
92fa				ld (store_tmp2), hl    ; location to poke strings 
92fa			 
92fa				; check for empty drive 
92fa			 
92fa				ld a, 0 
92fa				cp b 
92fa				jp z, .dirdone 
92fa			 
92fa				 
92fa					if DEBUG_FORTH_WORDS 
92fa						DMARK "Cdc" 
92fa						CALLMONITOR 
92fa					endif 
92fa			 
92fa			 
92fa			.diritem:	 
92fa				push bc 
92fa				; for each of the current ids do a search for them and if found push to stack 
92fa			 
92fa					ld hl, STORE_BLOCK_PHY 
92fa					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92fa					ld e,b 
92fa			 
92fa					call storage_findnextid 
92fa			 
92fa			 
92fa					; if found hl will be non zero 
92fa			 
92fa					call ishlzero 
92fa					jr z, .dirnotfound 
92fa			 
92fa					; increase count 
92fa			 
92fa					pop bc	 
92fa					inc c 
92fa					push bc 
92fa					 
92fa			 
92fa					; get file header and push the file name 
92fa			 
92fa					ld de, store_page 
92fa					call storage_read_block 
92fa			 
92fa					; push file id to stack 
92fa				 
92fa					ld a, (store_page) 
92fa					ld h, 0 
92fa					ld l, a 
92fa			 
92fa					;call forth_push_numhl 
92fa					; TODO store id 
92fa			 
92fa					push hl 
92fa			 
92fa					; push extent count to stack  
92fa				 
92fa					ld hl, store_page+3 
92fa			 
92fa					; get file name length 
92fa			 
92fa					call strlenz   
92fa			 
92fa					inc hl   ; cover zero term 
92fa					inc hl  ; stick the id at the end of the area 
92fa			 
92fa					push hl 
92fa					pop bc    ; move length to bc 
92fa			 
92fa					call malloc 
92fa			 
92fa					; TODO save malloc area to scratch 
92fa			 
92fa					ex de, hl 
92fa					ld hl, (store_tmp2) 
92fa					ld (hl), e 
92fa					inc hl 
92fa					ld (hl), d 
92fa					inc hl 
92fa					ld (store_tmp2), hl 
92fa			 
92fa					 
92fa			 
92fa					;pop hl   ; get source 
92fa			;		ex de, hl    ; swap aronund	 
92fa			 
92fa					ld hl, store_page+3 
92fa					if DEBUG_FORTH_WORDS 
92fa						DMARK "CFd" 
92fa						CALLMONITOR 
92fa					endif 
92fa					ldir 
92fa			 
92fa					; de is past string, move back one and store id 
92fa					 
92fa					dec de 
92fa			 
92fa					; store file id 
92fa			 
92fa					pop hl 
92fa					ex de,hl 
92fa					ld (hl), e 
92fa			 
92fa					if DEBUG_FORTH_WORDS 
92fa						DMARK "Cdi" 
92fa						CALLMONITOR 
92fa					endif 
92fa					 
92fa			.dirnotfound: 
92fa					pop bc     
92fa					djnz .diritem 
92fa				 
92fa			.dirdone:	 
92fa			 
92fa					ld a, 0 
92fa					ld hl, (store_tmp2) 
92fa					ld (hl), a 
92fa					inc hl 
92fa					ld (hl), a 
92fa					inc hl 
92fa					; push a count of the dir items found 
92fa			 
92fa			;		ld h, 0 
92fa			;		ld l, c 
92fa			 
92fa				ret 
92fa			 
92fa			endif 
92fa			 
92fa			 
92fa			; Settings 
92fa			; Run  
92fa			 
92fa			 
92fa			 
92fa			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92fa			;;hd_menu2:   db "        2: Editor",0   
92fa			;hd_menu2:   db "        2: Editor       6: Menu",0   
92fa			;hd_menu3:   db "        3: Storage",0 
92fa			;hd_menu4:   db "0=quit  4: Debug",0 
92fa			;hd_don:     db "ON",0 
92fa			;hd_doff:     db "OFF",0 
92fa			; 
92fa			; 
92fa			; 
92fa			;hardware_diags_old:       
92fa			; 
92fa			;.diagmenu: 
92fa			;	call clear_display 
92fa			;	ld a, display_row_1 
92fa			;	ld de, hd_menu1 
92fa			;	call str_at_display 
92fa			; 
92fa			;	ld a, display_row_2 
92fa			;	ld de, hd_menu2 
92fa			;	call str_at_display 
92fa			; 
92fa			;	ld a, display_row_3 
92fa			;	ld de, hd_menu3 
92fa			;	call str_at_display 
92fa			; 
92fa			;	ld a,  display_row_4 
92fa			;	ld de, hd_menu4 
92fa			;	call str_at_display 
92fa			; 
92fa			;	; display debug state 
92fa			; 
92fa			;	ld de, hd_don 
92fa			;	ld a, (os_view_disable) 
92fa			;	cp 0 
92fa			;	jr z, .distog 
92fa			;	ld de, hd_doff 
92fa			;.distog: ld a, display_row_4+17 
92fa			;	call str_at_display 
92fa			; 
92fa			;	call update_display 
92fa			; 
92fa			;	call cin_wait 
92fa			; 
92fa			; 
92fa			; 
92fa			;	cp '4' 
92fa			;	jr nz, .diagn1 
92fa			; 
92fa			;	; debug toggle 
92fa			; 
92fa			;	ld a, (os_view_disable) 
92fa			;	ld b, '*' 
92fa			;	cp 0 
92fa			;	jr z, .debtog 
92fa			;	ld b, 0 
92fa			;.debtog:	 
92fa			;	ld a,b 
92fa			;	ld (os_view_disable),a 
92fa			; 
92fa			;.diagn1: cp '0' 
92fa			;	 ret z 
92fa			; 
92fa			;;	cp '1' 
92fa			;;       jp z, matrix	 
92fa			;;   TODO keyboard matrix test 
92fa			; 
92fa			;	cp '2' 
92fa			;	jp z, .diagedit 
92fa			; 
92fa			;;	cp '6' 
92fa			;;	jp z, .menutest 
92fa			;;if ENABLE_BASIC 
92fa			;;	cp '6' 
92fa			;;	jp z, basic 
92fa			;;endif 
92fa			 ; 
92fa			;	jp .diagmenu 
92fa			; 
92fa			; 
92fa			;	ret 
92fa			 
92fa			 
92fa			.debug_tog: 
92fa 21 44 93			ld hl, .menudebug 
92fd				 
92fd			;	ld a, (os_view_disable) 
92fd			;	cp '*' 
92fd 3a 6f ee			ld a,(debug_vector) 
9300 fe c9			cp $C9   ; RET 
9302 20 04			jr nz,.tdon  
9304 3e 01			ld a, 1 
9306 18 02			jr .tog1 
9308 3e 00		.tdon: ld a, 0 
930a			 
930a			.tog1: 
930a cd df 8a			call menu 
930d fe 00			cp 0 
930f c8				ret z 
9310 fe 01			cp 1    ; disable debug 
9312 28 04			jr z, .dtog0 
9314 3e 2a			ld a, '*' 
9316 18 05			jr .dtogset 
9318			.dtog0:  
9318				;ld a, 0 
9318 cd 36 94			call bp_on 
931b 18 dd			jr .debug_tog 
931d			.dtogset:  
931d				; ld (os_view_disable), a 
931d cd 42 94			call bp_off 
9320 c3 fa 92			jp .debug_tog 
9323			 
9323			 
9323			hardware_diags:       
9323			 
9323			.diagm: 
9323 21 36 93			ld hl, .menuitems 
9326 3e 00			ld a, 0 
9328 cd df 8a			call menu 
932b			 
932b fe 00		         cp 0 
932d c8				 ret z 
932e			 
932e fe 02			cp 2 
9330 ca 8f 93			jp z, .diagedit 
9333			 
9333			;	cp '6' 
9333			;	jp z, .menutest 
9333			;if ENABLE_BASIC 
9333			;	cp '6' 
9333			;	jp z, basic 
9333			;endif 
9333			  
9333 c3 23 93			jp .diagm 
9336			 
9336				 
9336 4a 93		.menuitems:   	dw .m1 
9338 55 93				dw .m2 
933a 5c 93				dw .m3 
933c 64 93				dw .m5 
933e 6a 93				dw .m5a 
9340 73 93				dw .m5b 
9342 00 00				dw 0 
9344			 
9344			.menudebug: 
9344 7c 93				dw .m6 
9346 85 93				dw .m7 
9348 00 00				dw 0 
934a			 
934a .. 00		.m1:   db "Key Matrix",0 
9355 .. 00		.m2:   db "Editor",0 
935c .. 00		.m3:   db "Storage",0 
9364 .. 00		.m5:   db "Sound",0 
936a .. 00		.m5a:  db "RAM Test",0 
9373 .. 00		.m5b:  db "LCD Test",0 
937c			 
937c .. 00		.m6:   db "Debug ON",0 
9385 .. 00		.m7:   db "Debug OFF",0 
938f			 
938f			; debug editor 
938f			 
938f			.diagedit: 
938f			 
938f 21 c1 e2			ld hl, scratch 
9392			;	ld bc, 250 
9392			;	ldir 
9392				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9392 3e 00			ld a, 0 
9394 77				ld (hl), a 
9395 23				inc hl 
9396 77				ld (hl), a 
9397 23				inc hl 
9398 77				ld (hl), a 
9399			 
9399 cd ae 8a		        call clear_display 
939c cd d1 8a			call update_display 
939f				;ld a, 1 
939f				;ld (hardware_diag), a 
939f			.diloop: 
939f 3e 00			ld a, display_row_1 
93a1 0e 00			ld c, 0 
93a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
93a5 1e 28			ld e, 40 
93a7			 
93a7 21 c1 e2			ld hl, scratch	 
93aa cd 08 8d			call input_str 
93ad			 
93ad 3e 28			ld a, display_row_2 
93af 11 c1 e2			ld de, scratch 
93b2 cd c1 8a			call str_at_display 
93b5 cd d1 8a			call update_display 
93b8			 
93b8 c3 9f 93			jp .diloop 
93bb			 
93bb			 
93bb			; pass word in hl 
93bb			; a has display location 
93bb			display_word_at: 
93bb f5				push af 
93bc e5				push hl 
93bd 7c				ld a,h 
93be 21 c6 e5			ld hl, os_word_scratch 
93c1 cd 35 8f			call hexout 
93c4 e1				pop hl 
93c5 7d				ld a,l 
93c6 21 c8 e5			ld hl, os_word_scratch+2 
93c9 cd 35 8f			call hexout 
93cc 21 ca e5			ld hl, os_word_scratch+4 
93cf 3e 00			ld a,0 
93d1 77				ld (hl),a 
93d2 11 c6 e5			ld de,os_word_scratch 
93d5 f1				pop af 
93d6 cd c1 8a				call str_at_display 
93d9 c9				ret 
93da			 
93da			display_ptr_state: 
93da			 
93da				; to restore afterwards 
93da			 
93da d5				push de 
93db c5				push bc 
93dc e5				push hl 
93dd f5				push af 
93de			 
93de				; for use in here 
93de			 
93de			;	push bc 
93de			;	push de 
93de			;	push hl 
93de			;	push af 
93de			 
93de cd ae 8a			call clear_display 
93e1			 
93e1 11 b9 95			ld de, .ptrstate 
93e4 3e 00			ld a, display_row_1 
93e6 cd c1 8a			call str_at_display 
93e9			 
93e9				; display debug step 
93e9			 
93e9			 
93e9 11 6b ee			ld de, debug_mark 
93ec 3e 26			ld a, display_row_1+display_cols-2 
93ee cd c1 8a			call str_at_display 
93f1			 
93f1				; display a 
93f1 11 c3 95			ld de, .ptrcliptr 
93f4 3e 28			ld a, display_row_2 
93f6 cd c1 8a			call str_at_display 
93f9			 
93f9 f1				pop af 
93fa 2a 40 ea			ld hl,(cli_ptr) 
93fd 3e 30			ld a, display_row_2+8 
93ff cd bb 93			call display_word_at 
9402			 
9402			 
9402				; display hl 
9402			 
9402			 
9402 11 cb 95			ld de, .ptrclioptr 
9405 3e 32			ld a, display_row_2+10 
9407 cd c1 8a			call str_at_display 
940a			; 
940a			;	pop hl 
940a 3e 35			ld a, display_row_2+13 
940c 2a 3e ea			ld hl,(cli_origptr) 
940f cd bb 93			call display_word_at 
9412			; 
9412			;	 
9412			;	; display de 
9412			 
9412			;	ld de, .regstatede 
9412			;	ld a, display_row_3 
9412			;	call str_at_display 
9412			 
9412			;	pop de 
9412			;	ld h,d 
9412			;	ld l, e 
9412			;	ld a, display_row_3+3 
9412			;	call display_word_at 
9412			 
9412			 
9412				; display bc 
9412			 
9412			;	ld de, .regstatebc 
9412			;	ld a, display_row_3+10 
9412			;	call str_at_display 
9412			 
9412			;	pop bc 
9412			;	ld h,b 
9412			;	ld l, c 
9412			;	ld a, display_row_3+13 
9412			;	call display_word_at 
9412			 
9412			 
9412				; display dsp 
9412			 
9412			;	ld de, .regstatedsp 
9412			;	ld a, display_row_4 
9412			;	call str_at_display 
9412			 
9412				 
9412			;	ld hl,(cli_data_sp) 
9412			;	ld a, display_row_4+4 
9412			;	call display_word_at 
9412			 
9412				; display rsp 
9412			 
9412 11 fa 95			ld de, .regstatersp 
9415 3e 82			ld a, display_row_4+10 
9417 cd c1 8a			call str_at_display 
941a			 
941a				 
941a 2a f2 e9			ld hl,(cli_ret_sp) 
941d 3e 86			ld a, display_row_4+14 
941f cd bb 93			call display_word_at 
9422			 
9422 cd d1 8a			call update_display 
9425			 
9425 cd f1 89			call delay1s 
9428 cd f1 89			call delay1s 
942b cd f1 89			call delay1s 
942e			 
942e			 
942e cd 18 9a			call next_page_prompt 
9431			 
9431				; restore  
9431			 
9431 f1				pop af 
9432 e1				pop hl 
9433 c1				pop bc 
9434 d1				pop de 
9435 c9				ret 
9436			 
9436			; Update the break point vector so that the user can hook a new routine 
9436			 
9436			bp_on: 
9436 3e c3			ld a, $c3    ; JP 
9438 32 6f ee			ld (debug_vector), a 
943b 21 48 94			ld hl, break_point_state 
943e 22 70 ee			ld (debug_vector+1), hl 
9441 c9				ret 
9442			 
9442			bp_off: 
9442 3e c9			ld a, $c9    ; RET 
9444 32 6f ee			ld (debug_vector), a 
9447 c9				ret 
9448			 
9448			 
9448			break_point_state: 
9448			;	push af 
9448			; 
9448			;	; see if disabled 
9448			; 
9448			;	ld a, (os_view_disable) 
9448			;	cp '*' 
9448			;	jr nz, .bpsgo 
9448			;	pop af 
9448			;	ret 
9448			 
9448			.bpsgo: 
9448			;	pop af 
9448 f5				push af 
9449 22 a3 e2			ld (os_view_hl), hl 
944c ed 53 a1 e2		ld (os_view_de), de 
9450 ed 43 9f e2		ld (os_view_bc), bc 
9454 e5				push hl 
9455 6f				ld l, a 
9456 26 00			ld h, 0 
9458 22 a5 e2			ld (os_view_af),hl 
945b			 
945b 21 b1 ed				ld hl, display_fb0 
945e 22 cc eb				ld (display_fb_active), hl 
9461 e1				pop hl	 
9462			 
9462 3e 31			ld a, '1' 
9464 fe 2a		.bps1:  cp '*' 
9466 cc 42 94			call z, bp_off 
9469			;	jr nz, .bps1b 
9469			;	ld (os_view_disable),a 
9469 fe 31		.bps1b:  cp '1' 
946b 20 14			jr nz, .bps2 
946d			 
946d				; display reg 
946d			 
946d				 
946d			 
946d 3a a5 e2			ld a, (os_view_af) 
9470 2a a3 e2			ld hl, (os_view_hl) 
9473 ed 5b a1 e2		ld de, (os_view_de) 
9477 ed 4b 9f e2		ld bc, (os_view_bc) 
947b cd 15 95			call display_reg_state 
947e c3 01 95			jp .bpschk 
9481			 
9481 fe 32		.bps2:  cp '2' 
9483 20 08			jr nz, .bps3 
9485				 
9485				; display hl 
9485 2a a3 e2			ld hl, (os_view_hl) 
9488 cd ff 95			call display_dump_at_hl 
948b			 
948b 18 74			jr .bpschk 
948d			 
948d fe 33		.bps3:  cp '3' 
948f 20 08			jr nz, .bps4 
9491			 
9491			        ; display de 
9491 2a a1 e2			ld hl, (os_view_de) 
9494 cd ff 95			call display_dump_at_hl 
9497			 
9497 18 68			jr .bpschk 
9499 fe 34		.bps4:  cp '4' 
949b 20 08			jr nz, .bps5 
949d			 
949d			        ; display bc 
949d 2a 9f e2			ld hl, (os_view_bc) 
94a0 cd ff 95			call display_dump_at_hl 
94a3			 
94a3 18 5c			jr .bpschk 
94a5 fe 35		.bps5:  cp '5' 
94a7 20 08		        jr nz, .bps7 
94a9			 
94a9				; display cur ptr 
94a9 2a 40 ea			ld hl, (cli_ptr) 
94ac cd ff 95			call display_dump_at_hl 
94af			 
94af 18 50			jr .bpschk 
94b1 fe 36		.bps7:  cp '6' 
94b3 20 08			jr nz, .bps8b 
94b5				 
94b5				; display cur orig ptr 
94b5 2a 3e ea			ld hl, (cli_origptr) 
94b8 cd ff 95			call display_dump_at_hl 
94bb 18 44			jr .bpschk 
94bd fe 37		.bps8b:  cp '7' 
94bf 20 08			jr nz, .bps9 
94c1				 
94c1				; display dsp 
94c1 2a ee e9			ld hl, (cli_data_sp) 
94c4 cd ff 95			call display_dump_at_hl 
94c7			 
94c7 18 38			jr .bpschk 
94c9 fe 39		.bps9:  cp '9' 
94cb 20 05			jr nz, .bps8c 
94cd				 
94cd				; display SP 
94cd			;	ld hl, sp 
94cd cd ff 95			call display_dump_at_hl 
94d0			 
94d0 18 2f			jr .bpschk 
94d2 fe 38		.bps8c:  cp '8' 
94d4 20 08			jr nz, .bps8d 
94d6				 
94d6				; display rsp 
94d6 2a f2 e9			ld hl, (cli_ret_sp) 
94d9 cd ff 95			call display_dump_at_hl 
94dc			 
94dc 18 23			jr .bpschk 
94de fe 23		.bps8d:  cp '#'     ; access monitor sub system 
94e0 20 05			jr nz, .bps8 
94e2 cd e6 97			call monitor 
94e5			 
94e5 18 1a			jr .bpschk 
94e7 fe 30		.bps8:  cp '0' 
94e9 20 16			jr nz, .bpschk 
94eb			 
94eb 21 10 ed				ld hl, display_fb1 
94ee 22 cc eb				ld (display_fb_active), hl 
94f1 cd d1 8a				call update_display 
94f4			 
94f4				;ld a, (os_view_af) 
94f4 2a a3 e2			ld hl, (os_view_hl) 
94f7 ed 5b a1 e2		ld de, (os_view_de) 
94fb ed 4b 9f e2		ld bc, (os_view_bc) 
94ff f1				pop af 
9500 c9				ret 
9501			 
9501			.bpschk:   
9501 cd f1 89			call delay1s 
9504 3e 9f		ld a,display_row_4 + display_cols - 1 
9506 11 16 9a		        ld de, endprg 
9509 cd c1 8a			call str_at_display 
950c cd d1 8a			call update_display 
950f cd 28 e4			call cin_wait 
9512			 
9512 c3 64 94			jp .bps1 
9515			 
9515			 
9515			display_reg_state: 
9515			 
9515				; to restore afterwards 
9515			 
9515 d5				push de 
9516 c5				push bc 
9517 e5				push hl 
9518 f5				push af 
9519			 
9519				; for use in here 
9519			 
9519 c5				push bc 
951a d5				push de 
951b e5				push hl 
951c f5				push af 
951d			 
951d cd ae 8a			call clear_display 
9520			 
9520 11 d5 95			ld de, .regstate 
9523 3e 00			ld a, display_row_1 
9525 cd c1 8a			call str_at_display 
9528			 
9528				; display debug step 
9528			 
9528			 
9528 11 6b ee			ld de, debug_mark 
952b 3e 25			ld a, display_row_1+display_cols-3 
952d cd c1 8a			call str_at_display 
9530			 
9530				; display a 
9530 11 f1 95			ld de, .regstatea 
9533 3e 28			ld a, display_row_2 
9535 cd c1 8a			call str_at_display 
9538			 
9538 e1				pop hl 
9539			;	ld h,0 
9539			;	ld l, a 
9539 3e 2b			ld a, display_row_2+3 
953b cd bb 93			call display_word_at 
953e			 
953e			 
953e				; display hl 
953e			 
953e			 
953e 11 e5 95			ld de, .regstatehl 
9541 3e 32			ld a, display_row_2+10 
9543 cd c1 8a			call str_at_display 
9546			 
9546 e1				pop hl 
9547 3e 35			ld a, display_row_2+13 
9549 cd bb 93			call display_word_at 
954c			 
954c				 
954c				; display de 
954c			 
954c 11 e9 95			ld de, .regstatede 
954f 3e 50			ld a, display_row_3 
9551 cd c1 8a			call str_at_display 
9554			 
9554 e1				pop hl 
9555			;	ld h,d 
9555			;	ld l, e 
9555 3e 53			ld a, display_row_3+3 
9557 cd bb 93			call display_word_at 
955a			 
955a			 
955a				; display bc 
955a			 
955a 11 ed 95			ld de, .regstatebc 
955d 3e 5a			ld a, display_row_3+10 
955f cd c1 8a			call str_at_display 
9562			 
9562 e1				pop hl 
9563			;	ld h,b 
9563			;	ld l, c 
9563 3e 5d			ld a, display_row_3+13 
9565 cd bb 93			call display_word_at 
9568			 
9568			 
9568				; display dsp 
9568			 
9568 11 f5 95			ld de, .regstatedsp 
956b 3e 78			ld a, display_row_4 
956d cd c1 8a			call str_at_display 
9570			 
9570				 
9570 2a ee e9			ld hl,(cli_data_sp) 
9573 3e 7c			ld a, display_row_4+4 
9575 cd bb 93			call display_word_at 
9578			 
9578				; display rsp 
9578			 
9578 11 fa 95			ld de, .regstatersp 
957b 3e 82			ld a, display_row_4+10 
957d cd c1 8a			call str_at_display 
9580			 
9580				 
9580 2a f2 e9			ld hl,(cli_ret_sp) 
9583 3e 86			ld a, display_row_4+14 
9585 cd bb 93			call display_word_at 
9588			 
9588 cd d1 8a			call update_display 
958b			 
958b			;	call delay1s 
958b			;	call delay1s 
958b			;	call delay1s 
958b			 
958b			 
958b			;	call next_page_prompt 
958b			 
958b				; restore  
958b			 
958b f1				pop af 
958c e1				pop hl 
958d c1				pop bc 
958e d1				pop de 
958f c9				ret 
9590			 
9590 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
95a4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
95b9 .. 00		.ptrstate:	db "Ptr State",0 
95c3 .. 00		.ptrcliptr:     db "cli_ptr",0 
95cb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
95d5 .. 00		.regstate:	db "Reg State (1/0)",0 
95e5 .. 00		.regstatehl:	db "HL:",0 
95e9 .. 00		.regstatede:	db "DE:",0 
95ed .. 00		.regstatebc:	db "BC:",0 
95f1 .. 00		.regstatea:	db "A :",0 
95f5 .. 00		.regstatedsp:	db "DSP:",0 
95fa .. 00		.regstatersp:	db "RSP:",0 
95ff			 
95ff			display_dump_at_hl: 
95ff e5				push hl 
9600 d5				push de 
9601 c5				push bc 
9602 f5				push af 
9603			 
9603 22 e4 e5			ld (os_cur_ptr),hl	 
9606 cd ae 8a			call clear_display 
9609 cd 20 99			call dumpcont 
960c			;	call delay1s 
960c			;	call next_page_prompt 
960c			 
960c			 
960c f1				pop af 
960d c1				pop bc 
960e d1				pop de 
960f e1				pop hl 
9610 c9				ret 
9611			 
9611			;if ENABLE_BASIC 
9611			;	include "nascombasic.asm" 
9611			;	basic: 
9611			;	include "forth/FORTH.ASM" 
9611			;endif 
9611			 
9611			; eof 
9611			 
9611			 
# End of file firmware_diags.asm
9611			  
9611			include "firmware_prompts.asm"  
9611			; Prompts  
9611			 
9611			; boot messages 
9611			 
9611 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
9626 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9636			 
9636			 
9636			; config menus 
9636			 
9636			;prom_c3: db "Add Dictionary To File",0 
9636			 
9636			if STARTUP_V1 
9636 .. 00		prom_c2: db "Select Autoload File",0 
964b .. 00		prom_c2a: db "Disable Autoload File", 0 
9661			endif 
9661			 
9661			if STARTUP_V2 
9661			prom_c2: db "Enable Autoload Files",0 
9661			prom_c2a: db "Disable Autoload Files", 0 
9661			 
9661			crs_s1: db "*ls-word", 0 
9661			crs_s2: db "*ed-word", 0 
9661			crs_s3: db "*Demo-Programs", 0 
9661			crs_s4: db "*Utils", 0 
9661			crs_s5: db "*SPI-Util", 0 
9661			crs_s6: db "*Key-constants", 0 
9661			crs_sound: db "*Sound-Util", 0 
9661			 
9661			 
9661			 
9661			endif 
9661			;prom_c2b: db "Select Storage Bank",0 
9661 .. 00		prom_c4: db "Settings",0 
966a .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9685 .. 00		prom_m4b:   db "Monitor",0 
968d .. 00		prom_c1: db "Hardware Diags",0 
969c			 
969c			 
969c			if STARTUP_V2 
969c			prom_c9: db "Create Startup Files",0 
969c			endif 
969c			 
969c .. 00		prom_notav:    db "Feature not available",0 
96b2 .. 00		prom_empty:    db "",0 
96b3			 
96b3			; eof 
96b3			 
# End of file firmware_prompts.asm
96b3			  
96b3			  
96b3			; eof  
96b3			  
# End of file firmware.asm
96b3			 
96b3			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
96b3			;if BASE_KEV  
96b3			;baseram: equ 08000h 
96b3			;endif 
96b3			 
96b3			;if BASE_SC114 
96b3			;baseram:     equ    endofcode 
96b3			;endif 
96b3			 
96b3			 
96b3			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
96b3			 
96b3			; start system 
96b3			 
96b3			coldstart: 
96b3				; set sp 
96b3				; di/ei 
96b3			 
96b3 f3				di 
96b4 31 00 f0			ld sp, tos 
96b7 cd 72 e3			call init_nmi 
96ba			;	ei 
96ba			 
96ba				; init spinner 
96ba 3e 00			ld a,0 
96bc 32 c6 eb			ld (display_active), a 
96bf			 
96bf				; disable breakpoint by default 
96bf			 
96bf				;ld a,'*' 
96bf			;	ld a,' ' 
96bf			;	ld (os_view_disable),a 
96bf			 
96bf				; set break point vector as new break point on or off 
96bf cd 42 94			call bp_off 
96c2			 
96c2				; init hardware 
96c2			 
96c2				; init keyboard and screen hardware 
96c2			 
96c2 cd 1b 80			call hardware_init 
96c5			 
96c5			 
96c5 cd f1 89			call delay1s 
96c8 3e 58			ld a, display_row_3+8 
96ca 11 03 80			ld de, buildtime 
96cd cd c1 8a			call str_at_display 
96d0 cd d1 8a			call update_display 
96d3			 
96d3 cd f1 89			call delay1s 
96d6 cd f1 89			call delay1s 
96d9 cd f1 89			call delay1s 
96dc			 
96dc				; detect if any keys are held down to enable breakpoints at start up 
96dc			 
96dc cd 2e e4			call cin  
96df fe 00			cp 0 
96e1 28 03			jr z, .nokeys 
96e3			 
96e3				;call hardware_diags 
96e3 cd a0 92			call config 
96e6			 
96e6			;	ld de, .bpen 
96e6			;	ld a, display_row_4 
96e6			;	call str_at_display 
96e6			;	call update_display 
96e6			; 
96e6			;	ld a,0 
96e6			;	ld (os_view_disable),a 
96e6			; 
96e6			;.bpwait: 
96e6			;	call cin 
96e6			;	cp 0 
96e6			;	jr z, .bpwait 
96e6			;	jr .nokeys 
96e6			; 
96e6			; 
96e6			;.bpen:  db "Break points enabled!",0 
96e6			 
96e6			 
96e6			 
96e6			 
96e6			 
96e6			 
96e6			.nokeys: 
96e6			 
96e6			 
96e6				 
96e6			 
96e6			;jp  testkey 
96e6			 
96e6			;call storage_get_block_0 
96e6			; 
96e6			;ld hl, 0 
96e6			;ld de, store_page 
96e6			;call storage_read_block 
96e6			 
96e6				 
96e6			;ld hl, 10 
96e6			;ld de, store_page 
96e6			;call storage_read_block 
96e6			 
96e6			 
96e6			 
96e6			 
96e6			 
96e6			;stop:	nop 
96e6			;	jp stop 
96e6			 
96e6			 
96e6			 
96e6			main: 
96e6 cd ae 8a			call clear_display 
96e9 cd d1 8a			call update_display 
96ec			 
96ec			 
96ec			 
96ec			;	call testlcd 
96ec			 
96ec			 
96ec			 
96ec cd 1d 9e			call forth_init 
96ef			 
96ef			 
96ef			warmstart: 
96ef cd f3 9d			call forth_warmstart 
96f2			 
96f2				; run startup word load 
96f2			        ; TODO prevent this running at warmstart after crash  
96f2			 
96f2				if STARTUP_ENABLE 
96f2			 
96f2					if STARTUP_V1 
96f2			 
96f2						if STORAGE_SE 
96f2							call forth_autoload 
96f2						endif 
96f2 cd c2 e2					call forth_startup 
96f5					endif 
96f5			 
96f5					if STARTUP_V2 
96f5			 
96f5						if STORAGE_SE 
96f5							call forth_autoload 
96f5						else 
96f5							call forth_startup 
96f5						endif 
96f5			 
96f5			 
96f5					endif 
96f5			 
96f5				endif 
96f5			 
96f5				; show free memory after boot 
96f5 11 81 97			ld de, freeram 
96f8 3e 00			ld a, display_row_1 
96fa cd c1 8a			call str_at_display 
96fd			 
96fd				; get current heap start after loading any uwords 
96fd			 
96fd				;ld de, (os_last_new_uword) 
96fd				;ex de, hl 
96fd			 
96fd			; Or use heap_size word???? 
96fd				;ld hl, heap_end 
96fd				;ld hl, heap_size 
96fd				;ld de, topusermem 
96fd				;ld de, heap_start 
96fd ed 5b 47 e4			ld de, (free_list )      
9701 21 9c e2				ld hl, heap_end 
9704 ed 52			sbc hl, de 
9706				;push hl 
9706				;ld a,h	         	 
9706				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9706				;call hexout 
9706			   	;pop hl 
9706			; 
9706			;	ld a,l 
9706			;	ld hl, os_word_scratch+2 
9706			;	call hexout 
9706			;	ld hl, os_word_scratch+4 
9706			;	ld a, 0 
9706			;	ld (hl),a 
9706 eb				ex de, hl 
9707 21 c6 e5			ld hl, os_word_scratch 
970a cd 41 90			call uitoa_16 
970d			 
970d			 
970d 11 c6 e5			ld de, os_word_scratch 
9710 3e 0d			ld a, display_row_1 + 13 
9712 cd c1 8a			call str_at_display 
9715 cd d1 8a			call update_display 
9718			 
9718			 
9718				;call demo 
9718			 
9718			 
9718				; init scratch input area for cli commands 
9718			 
9718 21 e8 e5			ld hl, os_cli_cmd 
971b 3e 00			ld a,0 
971d 77				ld (hl),a 
971e 23				inc hl 
971f 77				ld (hl),a 
9720			 
9720 3e 00			ld a,0 
9722 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9725			 
9725 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9728 32 e5 e5			ld (os_cur_ptr+1),a	 
972b			 
972b 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
972e 32 c7 e5			ld (os_word_scratch+1),a	 
9731				 
9731			 
9731				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9731 21 e8 e5			ld hl, os_cli_cmd 
9734			 
9734 3e 00			ld a, 0		 ; init cli input 
9736 77				ld (hl), a 
9737 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9739			cli: 
9739				; show cli prompt 
9739				;push af 
9739				;ld a, 0 
9739				;ld de, prompt 
9739				;call str_at_display 
9739			 
9739				;call update_display 
9739				;pop af 
9739				;inc a 
9739				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9739 0e 00			ld c, 0 
973b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
973d 1e 28			ld e, 40 
973f			 
973f 21 e8 e5			ld hl, os_cli_cmd 
9742			 
9742				STACKFRAME OFF $fefe $9f9f 
9742				if DEBUG_STACK_IMB 
9742					if OFF 
9742						exx 
9742						ld de, $fefe 
9742						ld a, d 
9742						ld hl, curframe 
9742						call hexout 
9742						ld a, e 
9742						ld hl, curframe+2 
9742						call hexout 
9742						ld hl, $fefe 
9742						push hl 
9742						ld hl, $9f9f 
9742						push hl 
9742						exx 
9742					endif 
9742				endif 
9742			endm 
# End of macro STACKFRAME
9742			 
9742 cd 08 8d			call input_str 
9745			 
9745				STACKFRAMECHK OFF $fefe $9f9f 
9745				if DEBUG_STACK_IMB 
9745					if OFF 
9745						exx 
9745						ld hl, $9f9f 
9745						pop de   ; $9f9f 
9745						call cmp16 
9745						jr nz, .spnosame 
9745						ld hl, $fefe 
9745						pop de   ; $fefe 
9745						call cmp16 
9745						jr z, .spfrsame 
9745						.spnosame: call showsperror 
9745						.spfrsame: nop 
9745						exx 
9745					endif 
9745				endif 
9745			endm 
# End of macro STACKFRAMECHK
9745			 
9745				; copy input to last command 
9745			 
9745 21 e8 e5			ld hl, os_cli_cmd 
9748 11 e7 e6			ld de, os_last_cmd 
974b 01 ff 00			ld bc, 255 
974e ed b0			ldir 
9750			 
9750				; wipe current buffer 
9750			 
9750			;	ld a, 0 
9750			;	ld hl, os_cli_cmd 
9750			;	ld de, os_cli_cmd+1 
9750			;	ld bc, 254 
9750			;	ldir 
9750				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9750			;	call strcpy 
9750			;	ld a, 0 
9750			;	ld (hl), a 
9750			;	inc hl 
9750			;	ld (hl), a 
9750			;	inc hl 
9750			;	ld (hl), a 
9750			 
9750				; switch frame buffer to program  
9750			 
9750 21 10 ed				ld hl, display_fb1 
9753 22 cc eb				ld (display_fb_active), hl 
9756			 
9756			;	nop 
9756				STACKFRAME ON $fbfe $8f9f 
9756				if DEBUG_STACK_IMB 
9756					if ON 
9756						exx 
9756						ld de, $fbfe 
9756						ld a, d 
9756						ld hl, curframe 
9756						call hexout 
9756						ld a, e 
9756						ld hl, curframe+2 
9756						call hexout 
9756						ld hl, $fbfe 
9756						push hl 
9756						ld hl, $8f9f 
9756						push hl 
9756						exx 
9756					endif 
9756				endif 
9756			endm 
# End of macro STACKFRAME
9756				; first time into the parser so pass over the current scratch pad 
9756 21 e8 e5			ld hl,os_cli_cmd 
9759				; tokenise the entered statement(s) in HL 
9759 cd 9b 9e			call forthparse 
975c			        ; exec forth statements in top of return stack 
975c cd db 9e			call forthexec 
975f				;call forthexec_cleanup 
975f			;	call parsenext 
975f			 
975f				STACKFRAMECHK ON $fbfe $8f9f 
975f				if DEBUG_STACK_IMB 
975f					if ON 
975f						exx 
975f						ld hl, $8f9f 
975f						pop de   ; $8f9f 
975f						call cmp16 
975f						jr nz, .spnosame 
975f						ld hl, $fbfe 
975f						pop de   ; $fbfe 
975f						call cmp16 
975f						jr z, .spfrsame 
975f						.spnosame: call showsperror 
975f						.spfrsame: nop 
975f						exx 
975f					endif 
975f				endif 
975f			endm 
# End of macro STACKFRAMECHK
975f				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
975f			 
975f 3e 78			ld a, display_row_4 
9761 11 92 97			ld de, endprog 
9764			 
9764 cd d1 8a			call update_display		 
9767			 
9767 cd 18 9a			call next_page_prompt 
976a			 
976a				; switch frame buffer to cli 
976a			 
976a 21 b1 ed				ld hl, display_fb0 
976d 22 cc eb				ld (display_fb_active), hl 
9770			 
9770			 
9770 cd ae 8a		        call clear_display 
9773 cd d1 8a			call update_display		 
9776			 
9776 21 e8 e5			ld hl, os_cli_cmd 
9779			 
9779 3e 00			ld a, 0		 ; init cli input 
977b 77				ld (hl), a 
977c			 
977c				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
977c			 
977c				; now on last line 
977c			 
977c				; TODO scroll screen up 
977c			 
977c				; TODO instead just clear screen and place at top of screen 
977c			 
977c			;	ld a, 0 
977c			;	ld (f_cursor_ptr),a 
977c			 
977c				;call clear_display 
977c				;call update_display 
977c			 
977c				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
977c 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
977e c3 39 97			jp cli 
9781			 
9781 .. 00		freeram: db "Free bytes: ",0 
978e ..			asc: db "1A2F" 
9792 .. 00		endprog: db "End prog...",0 
979e			 
979e			testenter2:   
979e 21 f3 e2			ld hl,scratch+50 
97a1 22 e4 e5			ld (os_cur_ptr),hl 
97a4 c3 39 97			jp cli 
97a7			 
97a7			testenter:  
97a7			 
97a7 21 8e 97			ld hl,asc 
97aa			;	ld a,(hl) 
97aa			;	call nibble2val 
97aa cd 8b 8f			call get_byte 
97ad			 
97ad			 
97ad			;	ld a,(hl) 
97ad			;	call atohex 
97ad			 
97ad			;	call fourehexhl 
97ad 32 f3 e2			ld (scratch+50),a 
97b0			 
97b0			 
97b0			 
97b0 21 90 97			ld hl,asc+2 
97b3			;	ld a, (hl) 
97b3			;	call nibble2val 
97b3 cd 8b 8f			call get_byte 
97b6			 
97b6			;	call fourehexhl 
97b6 32 f5 e2			ld (scratch+52),a 
97b9				 
97b9 21 f3 e2			ld hl,scratch+50 
97bc 22 e4 e5			ld (os_cur_ptr),hl 
97bf c3 39 97			jp cli 
97c2			 
97c2			enter:	 
97c2 3a c5 e2			ld a,(scratch+4) 
97c5 fe 00			cp 0 
97c7 28 0c			jr z, .entercont 
97c9				; no, not a null term line so has an address to work out.... 
97c9			 
97c9 21 c3 e2			ld hl,scratch+2 
97cc cd eb 8f			call get_word_hl 
97cf			 
97cf 22 e4 e5			ld (os_cur_ptr),hl	 
97d2 c3 39 97			jp cli 
97d5			 
97d5			 
97d5			.entercont:  
97d5			 
97d5 21 c3 e2			ld hl, scratch+2 
97d8 cd 8b 8f			call get_byte 
97db			 
97db 2a e4 e5		   	ld hl,(os_cur_ptr) 
97de 77					ld (hl),a 
97df 23					inc hl 
97e0 22 e4 e5				ld (os_cur_ptr),hl 
97e3				 
97e3			; get byte  
97e3			 
97e3			 
97e3 c3 39 97			jp cli 
97e6			 
97e6			 
97e6			; basic monitor support 
97e6			 
97e6			monitor: 
97e6				;  
97e6 cd ae 8a			call clear_display 
97e9 3e 00			ld a, 0 
97eb 11 3a 98			ld de, .monprompt 
97ee cd c1 8a			call str_at_display 
97f1 cd d1 8a			call update_display 
97f4			 
97f4				; get a monitor command 
97f4			 
97f4 0e 00			ld c, 0     ; entry at top left 
97f6 16 64			ld d, 100   ; max buffer size 
97f8 1e 0f			ld e, 15    ; input scroll area 
97fa 3e 00			ld a, 0     ; init string 
97fc 21 bf e4			ld hl, os_input 
97ff 77				ld (hl), a 
9800 23				inc hl 
9801 77				ld (hl), a 
9802 21 bf e4			ld hl, os_input 
9805 3e 01			ld a, 1     ; init string 
9807 cd 08 8d			call input_str 
980a			 
980a cd ae 8a		        call clear_display 
980d cd d1 8a			call update_display		 
9810			 
9810 3a bf e4			ld a, (os_input) 
9813 cd 89 90			call toUpper 
9816 fe 48		        cp 'H' 
9818 ca 9f 98		        jp z, .monhelp 
981b fe 44			cp 'D'		; dump 
981d ca d2 98			jp z, .mondump	 
9820 fe 43			cp 'C'		; dump 
9822 ca ec 98			jp z, .moncdump	 
9825 fe 4d			cp 'M'		; dump 
9827 ca 3c 98			jp z, .moneditstart 
982a fe 55			cp 'U'		; dump 
982c ca 48 98			jp z, .monedit	 
982f fe 47			cp 'G'		; dump 
9831 ca c8 98			jp z, .monjump 
9834 fe 51			cp 'Q'		; dump 
9836 c8				ret z	 
9837			 
9837			 
9837				; TODO "S" to access symbol by name and not need the address 
9837				; TODO "F" to find a string in memory 
9837			 
9837 c3 e6 97			jp monitor 
983a			 
983a .. 00		.monprompt: db ">", 0 
983c			 
983c			.moneditstart: 
983c				; get starting address 
983c			 
983c 21 c1 e4			ld hl,os_input+2 
983f cd eb 8f			call get_word_hl 
9842			 
9842 22 e4 e5			ld (os_cur_ptr),hl	 
9845			 
9845 c3 e6 97			jp monitor 
9848			 
9848			.monedit: 
9848				; get byte to load 
9848			 
9848 21 c1 e4			ld hl,os_input+2 
984b cd 8b 8f			call get_byte 
984e			 
984e				; get address to update 
984e 2a e4 e5			ld hl, (os_cur_ptr) 
9851			 
9851				; update byte 
9851			 
9851 77				ld (hl), a 
9852			 
9852				; move to next address and save it 
9852			 
9852 23				inc hl 
9853 22 e4 e5			ld (os_cur_ptr),hl	 
9856			 
9856 c3 e6 97			jp monitor 
9859			 
9859			 
9859 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
986d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9889 .. 00		.monhelptext3:  db "G-Call address",0 
9898 .. 00		.monhelptext4:  db "Q-Quit",0 
989f			        
989f			.monhelp: 
989f 3e 00			ld a, display_row_1 
98a1 11 59 98		        ld de, .monhelptext1 
98a4			 
98a4 cd c1 8a			call str_at_display 
98a7 3e 28			ld a, display_row_2 
98a9 11 6d 98		        ld de, .monhelptext2 
98ac					 
98ac cd c1 8a			call str_at_display 
98af 3e 50			ld a, display_row_3 
98b1 11 89 98		        ld de, .monhelptext3 
98b4					 
98b4 cd c1 8a			call str_at_display 
98b7 3e 78			ld a, display_row_4 
98b9 11 98 98		        ld de, .monhelptext4 
98bc cd c1 8a			call str_at_display 
98bf			 
98bf cd d1 8a			call update_display		 
98c2			 
98c2 cd 18 9a			call next_page_prompt 
98c5 c3 e6 97			jp monitor 
98c8			 
98c8			.monjump:    
98c8 21 c1 e4			ld hl,os_input+2 
98cb cd eb 8f			call get_word_hl 
98ce			 
98ce e9				jp (hl) 
98cf c3 e6 97			jp monitor 
98d2			 
98d2			.mondump:    
98d2 21 c1 e4			ld hl,os_input+2 
98d5 cd eb 8f			call get_word_hl 
98d8			 
98d8 22 e4 e5			ld (os_cur_ptr),hl	 
98db cd 20 99			call dumpcont 
98de 3e 78			ld a, display_row_4 
98e0 11 92 97			ld de, endprog 
98e3			 
98e3 cd d1 8a			call update_display		 
98e6			 
98e6 cd 18 9a			call next_page_prompt 
98e9 c3 e6 97			jp monitor 
98ec			.moncdump: 
98ec cd 20 99			call dumpcont 
98ef 3e 78			ld a, display_row_4 
98f1 11 92 97			ld de, endprog 
98f4			 
98f4 cd d1 8a			call update_display		 
98f7			 
98f7 cd 18 9a			call next_page_prompt 
98fa c3 e6 97			jp monitor 
98fd			 
98fd			 
98fd			; TODO symbol access  
98fd			 
98fd			.symbols:     ;; A list of symbols that can be called up  
98fd b1 ed			dw display_fb0 
98ff .. 00			db "fb0",0  
9903 7a ea		     	dw store_page 
9905 .. 00			db "store_page",0 
9910			 
9910			 
9910			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9910			 
9910 3a c2 e2			ld a,(scratch+1) 
9913 fe 00			cp 0 
9915 28 09			jr z, dumpcont 
9917			 
9917				; no, not a null term line so has an address to work out.... 
9917			 
9917 21 c3 e2			ld hl,scratch+2 
991a cd eb 8f			call get_word_hl 
991d			 
991d 22 e4 e5			ld (os_cur_ptr),hl	 
9920			 
9920			 
9920			 
9920			dumpcont: 
9920			 
9920				; dump bytes at ptr 
9920			 
9920			 
9920 3e 00			ld a, display_row_1 
9922 2a cc eb			ld hl, (display_fb_active) 
9925 cd db 8c			call addatohl 
9928 cd 50 99			call .dumpbyterow 
992b			 
992b 3e 28			ld a, display_row_2 
992d 2a cc eb			ld hl, (display_fb_active) 
9930 cd db 8c			call addatohl 
9933 cd 50 99			call .dumpbyterow 
9936			 
9936			 
9936 3e 50			ld a, display_row_3 
9938 2a cc eb			ld hl, (display_fb_active) 
993b cd db 8c			call addatohl 
993e cd 50 99			call .dumpbyterow 
9941			 
9941 3e 78			ld a, display_row_4 
9943 2a cc eb			ld hl, (display_fb_active) 
9946 cd db 8c			call addatohl 
9949 cd 50 99			call .dumpbyterow 
994c			 
994c cd d1 8a			call update_display 
994f			;		jp cli 
994f c9				ret 
9950			 
9950			.dumpbyterow: 
9950			 
9950				;push af 
9950			 
9950 e5				push hl 
9951			 
9951				; calc where to poke the ascii 
9951			if display_cols == 20 
9951				ld a, 16 
9951			else 
9951 3e 1f			ld a, 31 
9953			endif 
9953			 
9953 cd db 8c			call addatohl 
9956 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9959			 
9959			 
9959			; display decoding address 
9959 2a e4 e5		   	ld hl,(os_cur_ptr) 
995c			 
995c 7c				ld a,h 
995d e1				pop hl 
995e e5				push hl 
995f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
995f cd 35 8f			call hexout 
9962 2a e4 e5		   	ld hl,(os_cur_ptr) 
9965			 
9965 7d				ld a,l 
9966 e1				pop hl 
9967 23				inc hl 
9968 23				inc hl 
9969 e5				push hl 
996a			;	ld hl, os_word_scratch+2 
996a cd 35 8f			call hexout 
996d e1				pop hl 
996e 23				inc hl 
996f 23				inc hl 
9970				;ld hl, os_word_scratch+4 
9970 3e 3a			ld a, ':' 
9972 77				ld (hl),a 
9973 23				inc hl 
9974				;ld a, 0 
9974				;ld (hl),a 
9974				;ld de, os_word_scratch 
9974				;pop af 
9974				;push af 
9974			;		ld a, display_row_2 
9974			;		call str_at_display 
9974			;		call update_display 
9974			 
9974			 
9974			;pop af 
9974			;	add 5 
9974			 
9974			if display_cols == 20 
9974				ld b, 4 
9974			else 
9974 06 08			ld b, 8 
9976			endif	 
9976			 
9976			.dumpbyte: 
9976 c5				push bc 
9977 e5				push hl 
9978			 
9978			 
9978 2a e4 e5		   	ld hl,(os_cur_ptr) 
997b 7e					ld a,(hl) 
997c			 
997c					; poke the ascii to display 
997c 2a c6 e5				ld hl,(os_word_scratch) 
997f 77					ld (hl),a 
9980 23					inc hl 
9981 22 c6 e5				ld (os_word_scratch),hl 
9984			 
9984					 
9984			 
9984			 
9984 e1					pop hl 
9985 e5					push hl 
9986			 
9986 cd 35 8f				call hexout 
9989			 
9989					 
9989 2a e4 e5		   	ld hl,(os_cur_ptr) 
998c 23				inc hl 
998d 22 e4 e5		   	ld (os_cur_ptr),hl 
9990			 
9990 e1					pop hl 
9991 23					inc hl 
9992 23					inc hl 
9993 23					inc hl 
9994			 
9994			 
9994			 
9994					;ld a,0 
9994					;ld (os_word_scratch+2),a 
9994					;pop af 
9994					;push af 
9994			 
9994					;ld de, os_word_scratch 
9994					;call str_at_display 
9994			;		call update_display 
9994			;		pop af 
9994 c1					pop bc 
9995 c6 03				add 3 
9997 10 dd			djnz .dumpbyte 
9999			 
9999				 
9999			 
9999 c9				ret 
999a			 
999a			jump:	 
999a			 
999a 21 c3 e2			ld hl,scratch+2 
999d cd eb 8f			call get_word_hl 
99a0				;ld hl,(scratch+2) 
99a0				;call fourehexhl 
99a0			 
99a0 22 e4 e5			ld (os_cur_ptr),hl	 
99a3			 
99a3 e9				jp (hl) 
99a4			 
99a4			 
99a4			 
99a4			; TODO implement a basic monitor mode to start with 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			 
99a4			; testing and demo code during development 
99a4			 
99a4			 
99a4 .. 00		str1: db "Enter some text...",0 
99b7 .. 00		clear: db "                    ",0 
99cc			 
99cc			demo: 
99cc			 
99cc			 
99cc			 
99cc			;	call update_display 
99cc			 
99cc				; init scratch input area for testing 
99cc 21 c1 e2			ld hl, scratch	 
99cf 3e 00			ld a,0 
99d1 77				ld (hl),a 
99d2			 
99d2			 
99d2 3e 28		            LD   A, display_row_2 
99d4			;            CALL fLCD_Pos       ;Position cursor to location in A 
99d4 11 a4 99		            LD   DE, str1 
99d7 cd c1 8a			call str_at_display 
99da			 
99da			;            CALL fLCD_Str       ;Display string pointed to by DE 
99da			cloop:	 
99da 3e 50		            LD   A, display_row_3 
99dc			;            CALL fLCD_Pos       ;Position cursor to location in A 
99dc 11 b7 99		            LD   DE, clear 
99df			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99df cd c1 8a				call str_at_display 
99e2 3e 78			ld a, display_row_4 
99e4 11 14 9a			ld de, prompt 
99e7			 
99e7 cd c1 8a				call str_at_display 
99ea cd d1 8a			call update_display 
99ed			 
99ed 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99ef 16 0a			ld d, 10 
99f1 21 c1 e2			ld hl, scratch	 
99f4 cd 08 8d			call input_str 
99f7			 
99f7			;	call clear_display 
99f7			;'	call update_display 
99f7			 
99f7 3e 00		            LD   A, display_row_1 
99f9			;            CALL fLCD_Pos       ;Position cursor to location in A 
99f9 11 b7 99		            LD   DE, clear 
99fc cd c1 8a				call str_at_display 
99ff			;            CALL fLCD_Str       ;Display string pointed to by DE 
99ff 3e 00		            LD   A, display_row_1 
9a01			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a01 11 c1 e2		            LD   DE, scratch 
9a04			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a04 cd c1 8a				call str_at_display 
9a07 cd d1 8a			call update_display 
9a0a			 
9a0a 3e 00				ld a,0 
9a0c 21 c1 e2			ld hl, scratch 
9a0f 77				ld (hl),a 
9a10			 
9a10 00				nop 
9a11 c3 da 99			jp cloop 
9a14			 
9a14			 
9a14			 
9a14			; OS Prompt 
9a14			 
9a14 .. 00		prompt: db ">",0 
9a16 .. 00		endprg: db "?",0 
9a18			 
9a18			 
9a18			; handy next page prompt 
9a18			next_page_prompt: 
9a18 e5				push hl 
9a19 d5				push de 
9a1a f5				push af 
9a1b c5				push bc 
9a1c			 
9a1c 3e 9f			ld a,display_row_4 + display_cols - 1 
9a1e 11 16 9a		        ld de, endprg 
9a21 cd c1 8a			call str_at_display 
9a24 cd d1 8a			call update_display 
9a27 cd 28 e4			call cin_wait 
9a2a c1				pop bc 
9a2b f1				pop af 
9a2c d1				pop de 
9a2d e1				pop hl 
9a2e			 
9a2e			 
9a2e c9				ret 
9a2f			 
9a2f			 
9a2f			; forth parser 
9a2f			 
9a2f			; My forth kernel 
9a2f			include "forth_kernel.asm" 
9a2f			; 
9a2f			; kernel to the forth OS 
9a2f			 
9a2f			DS_TYPE_STR: equ 1     ; string type 
9a2f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9a2f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9a2f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9a2f			 
9a2f			FORTH_PARSEV1: equ 0 
9a2f			FORTH_PARSEV2: equ 0 
9a2f			FORTH_PARSEV3: equ 0 
9a2f			FORTH_PARSEV4: equ 0 
9a2f			FORTH_PARSEV5: equ 1 
9a2f			 
9a2f			;if FORTH_PARSEV5 
9a2f			;	FORTH_END_BUFFER: equ 0 
9a2f			;else 
9a2f			FORTH_END_BUFFER: equ 127 
9a2f			;endif 
9a2f			 
9a2f			FORTH_TRUE: equ 1 
9a2f			FORTH_FALSE: equ 0 
9a2f			 
9a2f			if FORTH_PARSEV4 
9a2f			include "forth_stackops.asm" 
9a2f			endif 
9a2f			 
9a2f			if FORTH_PARSEV5 
9a2f			include "forth_stackopsv5.asm" 
9a2f			 
9a2f			; Stack operations for v5 parser on wards 
9a2f			; * DATA stack 
9a2f			; * LOOP stack 
9a2f			; * RETURN stack 
9a2f			 
9a2f			 
9a2f			 
9a2f			FORTH_CHK_DSP_UNDER: macro 
9a2f				push hl 
9a2f				push de 
9a2f				ld hl,(cli_data_sp) 
9a2f				ld de, cli_data_stack 
9a2f				call cmp16 
9a2f				jp c, fault_dsp_under 
9a2f				pop de 
9a2f				pop hl 
9a2f				endm 
9a2f			 
9a2f			 
9a2f			FORTH_CHK_RSP_UNDER: macro 
9a2f				push hl 
9a2f				push de 
9a2f				ld hl,(cli_ret_sp) 
9a2f				ld de, cli_ret_stack 
9a2f				call cmp16 
9a2f				jp c, fault_rsp_under 
9a2f				pop de 
9a2f				pop hl 
9a2f				endm 
9a2f			 
9a2f			FORTH_CHK_LOOP_UNDER: macro 
9a2f				push hl 
9a2f				push de 
9a2f				ld hl,(cli_loop_sp) 
9a2f				ld de, cli_loop_stack 
9a2f				call cmp16 
9a2f				jp c, fault_loop_under 
9a2f				pop de 
9a2f				pop hl 
9a2f				endm 
9a2f			 
9a2f			FORTH_ERR_TOS_NOTSTR: macro 
9a2f				; TOSO might need more for checks when used 
9a2f				push af 
9a2f				ld a,(hl) 
9a2f				cp DS_TYPE_STR 
9a2f				jp nz, type_faultn   
9a2f				pop af 
9a2f				endm 
9a2f			 
9a2f			FORTH_ERR_TOS_NOTNUM: macro 
9a2f				push af 
9a2f				ld a,(hl) 
9a2f				cp DS_TYPE_INUM 
9a2f				jp nz, type_faultn   
9a2f				pop af 
9a2f				endm 
9a2f			 
9a2f			 
9a2f			; increase data stack pointer and save hl to it 
9a2f				 
9a2f			FORTH_DSP_NEXT: macro 
9a2f				call macro_forth_dsp_next 
9a2f				endm 
9a2f			 
9a2f			 
9a2f			macro_forth_dsp_next: 
9a2f				if DEBUG_FORTH_STACK_GUARD 
9a2f cd a3 e0				call check_stacks 
9a32				endif 
9a32 e5				push hl 
9a33 d5				push de 
9a34 eb				ex de,hl 
9a35 2a ee e9			ld hl,(cli_data_sp) 
9a38 23				inc hl 
9a39 23				inc hl 
9a3a			 
9a3a			; PARSEV5 
9a3a 23				inc hl 
9a3b 22 ee e9			ld (cli_data_sp),hl 
9a3e 73				ld (hl), e 
9a3f 23				inc hl 
9a40 72				ld (hl), d 
9a41 d1				pop de 
9a42 e1				pop hl 
9a43				if DEBUG_FORTH_STACK_GUARD 
9a43 cd a3 e0				call check_stacks 
9a46				endif 
9a46 c9				ret 
9a47			 
9a47			 
9a47			; increase ret stack pointer and save hl to it 
9a47				 
9a47			FORTH_RSP_NEXT: macro 
9a47				call macro_forth_rsp_next 
9a47				endm 
9a47			 
9a47			macro_forth_rsp_next: 
9a47				if DEBUG_FORTH_STACK_GUARD 
9a47 cd a3 e0				call check_stacks 
9a4a				endif 
9a4a e5				push hl 
9a4b d5				push de 
9a4c eb				ex de,hl 
9a4d 2a f2 e9			ld hl,(cli_ret_sp) 
9a50 23				inc hl 
9a51 23				inc hl 
9a52 22 f2 e9			ld (cli_ret_sp),hl 
9a55 73				ld (hl), e 
9a56 23				inc hl 
9a57 72				ld (hl), d 
9a58 d1				pop de 
9a59 e1				pop hl 
9a5a				if DEBUG_FORTH_STACK_GUARD 
9a5a cd a3 e0				call check_stacks 
9a5d				endif 
9a5d c9				ret 
9a5e			 
9a5e			; get current ret stack pointer and save to hl  
9a5e				 
9a5e			FORTH_RSP_TOS: macro 
9a5e				call macro_forth_rsp_tos 
9a5e				endm 
9a5e			 
9a5e			macro_forth_rsp_tos: 
9a5e				;push de 
9a5e 2a f2 e9			ld hl,(cli_ret_sp) 
9a61 cd 99 9a			call loadhlptrtohl 
9a64				;ld e, (hl) 
9a64				;inc hl 
9a64				;ld d, (hl) 
9a64				;ex de, hl 
9a64					if DEBUG_FORTH_WORDS 
9a64			;			DMARK "RST" 
9a64						CALLMONITOR 
9a64 cd 6f ee			call debug_vector  
9a67				endm  
# End of macro CALLMONITOR
9a67					endif 
9a67				;pop de 
9a67 c9				ret 
9a68			 
9a68			; pop ret stack pointer 
9a68				 
9a68			FORTH_RSP_POP: macro 
9a68				call macro_forth_rsp_pop 
9a68				endm 
9a68			 
9a68			 
9a68			macro_forth_rsp_pop: 
9a68				if DEBUG_FORTH_STACK_GUARD 
9a68			;		DMARK "RPP" 
9a68 cd a3 e0				call check_stacks 
9a6b					FORTH_CHK_RSP_UNDER 
9a6b e5				push hl 
9a6c d5				push de 
9a6d 2a f2 e9			ld hl,(cli_ret_sp) 
9a70 11 ac e9			ld de, cli_ret_stack 
9a73 cd f9 8c			call cmp16 
9a76 da b7 e1			jp c, fault_rsp_under 
9a79 d1				pop de 
9a7a e1				pop hl 
9a7b				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a7b				endif 
9a7b e5				push hl 
9a7c 2a f2 e9			ld hl,(cli_ret_sp) 
9a7f			 
9a7f			 
9a7f				if FORTH_ENABLE_FREE 
9a7f			 
9a7f					; get pointer 
9a7f			 
9a7f					push de 
9a7f					push hl 
9a7f			 
9a7f					ld e, (hl) 
9a7f					inc hl 
9a7f					ld d, (hl) 
9a7f			 
9a7f					ex de, hl 
9a7f					call free 
9a7f			 
9a7f					pop hl 
9a7f					pop de 
9a7f			 
9a7f			 
9a7f				endif 
9a7f			 
9a7f			 
9a7f 2b				dec hl 
9a80 2b				dec hl 
9a81 22 f2 e9			ld (cli_ret_sp), hl 
9a84				; do stack underflow checks 
9a84 e1				pop hl 
9a85				if DEBUG_FORTH_STACK_GUARD 
9a85 cd a3 e0				call check_stacks 
9a88					FORTH_CHK_RSP_UNDER 
9a88 e5				push hl 
9a89 d5				push de 
9a8a 2a f2 e9			ld hl,(cli_ret_sp) 
9a8d 11 ac e9			ld de, cli_ret_stack 
9a90 cd f9 8c			call cmp16 
9a93 da b7 e1			jp c, fault_rsp_under 
9a96 d1				pop de 
9a97 e1				pop hl 
9a98				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a98				endif 
9a98 c9				ret 
9a99			 
9a99			 
9a99			 
9a99			; routine to load word pointed to by hl into hl 
9a99			 
9a99			loadhlptrtohl: 
9a99			 
9a99 d5				push de 
9a9a 5e				ld e, (hl) 
9a9b 23				inc hl 
9a9c 56				ld d, (hl) 
9a9d eb				ex de, hl 
9a9e d1				pop de 
9a9f			 
9a9f c9				ret 
9aa0			 
9aa0			 
9aa0			 
9aa0			 
9aa0			 
9aa0			; push a number held in HL onto the data stack 
9aa0			; entry point for pushing a value when already in hl used in function above 
9aa0			 
9aa0			forth_push_numhl: 
9aa0			 
9aa0 e5				push hl    ; save value to push 
9aa1			 
9aa1			if DEBUG_FORTH_PUSH 
9aa1				; see if disabled 
9aa1			 
9aa1			 
9aa1 f5				push af 
9aa2 3a 6f ee			ld a,(debug_vector) 
9aa5 fe c9			cp $c9   ; ret 
9aa7			;	ld a, (os_view_disable) 
9aa7			;	cp '*' 
9aa7 28 34			jr z, .pskip2 
9aa9 e5				push hl 
9aaa e5			push hl 
9aab cd ae 8a			call clear_display 
9aae e1			pop hl 
9aaf 7c				ld a,h 
9ab0 21 c6 e5			ld hl, os_word_scratch 
9ab3 cd 35 8f			call hexout 
9ab6 e1				pop hl 
9ab7 7d				ld a,l 
9ab8 21 c8 e5			ld hl, os_word_scratch+2 
9abb cd 35 8f			call hexout 
9abe			 
9abe 21 ca e5			ld hl, os_word_scratch+4 
9ac1 3e 00			ld a,0 
9ac3 77				ld (hl),a 
9ac4 11 c6 e5			ld de,os_word_scratch 
9ac7 3e 28				ld a, display_row_2 
9ac9 cd c1 8a				call str_at_display 
9acc 11 b5 cb			ld de, .push_num 
9acf 3e 00			ld a, display_row_1 
9ad1			 
9ad1 cd c1 8a				call str_at_display 
9ad4			 
9ad4			 
9ad4 cd d1 8a			call update_display 
9ad7 cd f1 89			call delay1s 
9ada cd f1 89			call delay1s 
9add			.pskip2:  
9add			 
9add f1				pop af 
9ade			endif	 
9ade			 
9ade			 
9ade				FORTH_DSP_NEXT 
9ade cd 2f 9a			call macro_forth_dsp_next 
9ae1				endm 
# End of macro FORTH_DSP_NEXT
9ae1			 
9ae1 2a ee e9			ld hl, (cli_data_sp) 
9ae4			 
9ae4				; save item type 
9ae4 3e 02			ld a,  DS_TYPE_INUM 
9ae6 77				ld (hl), a 
9ae7 23				inc hl 
9ae8			 
9ae8				; get word off stack 
9ae8 d1				pop de 
9ae9 7b				ld a,e 
9aea 77				ld (hl), a 
9aeb 23				inc hl 
9aec 7a				ld a,d 
9aed 77				ld (hl), a 
9aee			 
9aee			if DEBUG_FORTH_PUSH 
9aee 2b				dec hl 
9aef 2b				dec hl 
9af0 2b				dec hl 
9af1						DMARK "PH5" 
9af1 f5				push af  
9af2 3a 06 9b			ld a, (.dmark)  
9af5 32 6b ee			ld (debug_mark),a  
9af8 3a 07 9b			ld a, (.dmark+1)  
9afb 32 6c ee			ld (debug_mark+1),a  
9afe 3a 08 9b			ld a, (.dmark+2)  
9b01 32 6d ee			ld (debug_mark+2),a  
9b04 18 03			jr .pastdmark  
9b06 ..			.dmark: db "PH5"  
9b09 f1			.pastdmark: pop af  
9b0a			endm  
# End of macro DMARK
9b0a				CALLMONITOR 
9b0a cd 6f ee			call debug_vector  
9b0d				endm  
# End of macro CALLMONITOR
9b0d			endif	 
9b0d			 
9b0d c9				ret 
9b0e			 
9b0e			 
9b0e			; Push a string to stack pointed to by hl 
9b0e			 
9b0e			forth_push_str: 
9b0e			 
9b0e			if DEBUG_FORTH_PUSH 
9b0e						DMARK "PSQ" 
9b0e f5				push af  
9b0f 3a 23 9b			ld a, (.dmark)  
9b12 32 6b ee			ld (debug_mark),a  
9b15 3a 24 9b			ld a, (.dmark+1)  
9b18 32 6c ee			ld (debug_mark+1),a  
9b1b 3a 25 9b			ld a, (.dmark+2)  
9b1e 32 6d ee			ld (debug_mark+2),a  
9b21 18 03			jr .pastdmark  
9b23 ..			.dmark: db "PSQ"  
9b26 f1			.pastdmark: pop af  
9b27			endm  
# End of macro DMARK
9b27				CALLMONITOR 
9b27 cd 6f ee			call debug_vector  
9b2a				endm  
# End of macro CALLMONITOR
9b2a			endif	 
9b2a			    
9b2a e5				push hl 
9b2b e5				push hl 
9b2c			 
9b2c			;	ld a, 0   ; find end of string 
9b2c cd 92 90			call strlenz 
9b2f			if DEBUG_FORTH_PUSH 
9b2f						DMARK "PQ2" 
9b2f f5				push af  
9b30 3a 44 9b			ld a, (.dmark)  
9b33 32 6b ee			ld (debug_mark),a  
9b36 3a 45 9b			ld a, (.dmark+1)  
9b39 32 6c ee			ld (debug_mark+1),a  
9b3c 3a 46 9b			ld a, (.dmark+2)  
9b3f 32 6d ee			ld (debug_mark+2),a  
9b42 18 03			jr .pastdmark  
9b44 ..			.dmark: db "PQ2"  
9b47 f1			.pastdmark: pop af  
9b48			endm  
# End of macro DMARK
9b48				CALLMONITOR 
9b48 cd 6f ee			call debug_vector  
9b4b				endm  
# End of macro CALLMONITOR
9b4b			endif	 
9b4b eb				ex de, hl 
9b4c e1				pop hl   ; get ptr to start of string 
9b4d			if DEBUG_FORTH_PUSH 
9b4d						DMARK "PQ3" 
9b4d f5				push af  
9b4e 3a 62 9b			ld a, (.dmark)  
9b51 32 6b ee			ld (debug_mark),a  
9b54 3a 63 9b			ld a, (.dmark+1)  
9b57 32 6c ee			ld (debug_mark+1),a  
9b5a 3a 64 9b			ld a, (.dmark+2)  
9b5d 32 6d ee			ld (debug_mark+2),a  
9b60 18 03			jr .pastdmark  
9b62 ..			.dmark: db "PQ3"  
9b65 f1			.pastdmark: pop af  
9b66			endm  
# End of macro DMARK
9b66				CALLMONITOR 
9b66 cd 6f ee			call debug_vector  
9b69				endm  
# End of macro CALLMONITOR
9b69			endif	 
9b69 19				add hl,de 
9b6a			if DEBUG_FORTH_PUSH 
9b6a						DMARK "PQE" 
9b6a f5				push af  
9b6b 3a 7f 9b			ld a, (.dmark)  
9b6e 32 6b ee			ld (debug_mark),a  
9b71 3a 80 9b			ld a, (.dmark+1)  
9b74 32 6c ee			ld (debug_mark+1),a  
9b77 3a 81 9b			ld a, (.dmark+2)  
9b7a 32 6d ee			ld (debug_mark+2),a  
9b7d 18 03			jr .pastdmark  
9b7f ..			.dmark: db "PQE"  
9b82 f1			.pastdmark: pop af  
9b83			endm  
# End of macro DMARK
9b83				CALLMONITOR 
9b83 cd 6f ee			call debug_vector  
9b86				endm  
# End of macro CALLMONITOR
9b86			endif	 
9b86			 
9b86 2b				dec hl    ; see if there is an optional trailing double quote 
9b87 7e				ld a,(hl) 
9b88 fe 22			cp '"' 
9b8a 20 03			jr nz, .strnoq 
9b8c 3e 00			ld a, 0      ; get rid of double quote 
9b8e 77				ld (hl), a 
9b8f 23			.strnoq: inc hl 
9b90			 
9b90 3e 00			ld a, 0 
9b92 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b93			 
9b93 13				inc de ; add one for the type string 
9b94 13				inc de ; add one for null term??? 
9b95			 
9b95				; tos is get string pointer again 
9b95				; de contains space to allocate 
9b95				 
9b95 d5				push de 
9b96			 
9b96 eb				ex de, hl 
9b97			 
9b97				;push af 
9b97			 
9b97			if DEBUG_FORTH_PUSH 
9b97						DMARK "PHm" 
9b97 f5				push af  
9b98 3a ac 9b			ld a, (.dmark)  
9b9b 32 6b ee			ld (debug_mark),a  
9b9e 3a ad 9b			ld a, (.dmark+1)  
9ba1 32 6c ee			ld (debug_mark+1),a  
9ba4 3a ae 9b			ld a, (.dmark+2)  
9ba7 32 6d ee			ld (debug_mark+2),a  
9baa 18 03			jr .pastdmark  
9bac ..			.dmark: db "PHm"  
9baf f1			.pastdmark: pop af  
9bb0			endm  
# End of macro DMARK
9bb0				CALLMONITOR 
9bb0 cd 6f ee			call debug_vector  
9bb3				endm  
# End of macro CALLMONITOR
9bb3			endif	 
9bb3 cd 07 91			call malloc	; on ret hl now contains allocated memory 
9bb6				if DEBUG_FORTH_MALLOC_GUARD 
9bb6 cc 0d cc				call z,malloc_error 
9bb9				endif 
9bb9			 
9bb9				 
9bb9 c1				pop bc    ; get length 
9bba d1				pop de   ;  get string start    
9bbb			 
9bbb				; hl has destination from malloc 
9bbb			 
9bbb eb				ex de, hl    ; prep for ldir 
9bbc			 
9bbc d5				push de   ; save malloc area for DSP later 
9bbd				;push hl   ; save malloc area for DSP later 
9bbd			 
9bbd			if DEBUG_FORTH_PUSH 
9bbd						DMARK "PHc" 
9bbd f5				push af  
9bbe 3a d2 9b			ld a, (.dmark)  
9bc1 32 6b ee			ld (debug_mark),a  
9bc4 3a d3 9b			ld a, (.dmark+1)  
9bc7 32 6c ee			ld (debug_mark+1),a  
9bca 3a d4 9b			ld a, (.dmark+2)  
9bcd 32 6d ee			ld (debug_mark+2),a  
9bd0 18 03			jr .pastdmark  
9bd2 ..			.dmark: db "PHc"  
9bd5 f1			.pastdmark: pop af  
9bd6			endm  
# End of macro DMARK
9bd6				CALLMONITOR 
9bd6 cd 6f ee			call debug_vector  
9bd9				endm  
# End of macro CALLMONITOR
9bd9			endif	 
9bd9			 
9bd9			 
9bd9 ed b0			ldir 
9bdb			 
9bdb			 
9bdb				; push malloc to data stack     macro?????  
9bdb			 
9bdb				FORTH_DSP_NEXT 
9bdb cd 2f 9a			call macro_forth_dsp_next 
9bde				endm 
# End of macro FORTH_DSP_NEXT
9bde			 
9bde				; save value and type 
9bde			 
9bde 2a ee e9			ld hl, (cli_data_sp) 
9be1			 
9be1				; save item type 
9be1 3e 01			ld a,  DS_TYPE_STR 
9be3 77				ld (hl), a 
9be4 23				inc hl 
9be5			 
9be5				; get malloc word off stack 
9be5 d1				pop de 
9be6 73				ld (hl), e 
9be7 23				inc hl 
9be8 72				ld (hl), d 
9be9			 
9be9			 
9be9			 
9be9			if DEBUG_FORTH_PUSH 
9be9 2a ee e9			ld hl, (cli_data_sp) 
9bec						DMARK "PHS" 
9bec f5				push af  
9bed 3a 01 9c			ld a, (.dmark)  
9bf0 32 6b ee			ld (debug_mark),a  
9bf3 3a 02 9c			ld a, (.dmark+1)  
9bf6 32 6c ee			ld (debug_mark+1),a  
9bf9 3a 03 9c			ld a, (.dmark+2)  
9bfc 32 6d ee			ld (debug_mark+2),a  
9bff 18 03			jr .pastdmark  
9c01 ..			.dmark: db "PHS"  
9c04 f1			.pastdmark: pop af  
9c05			endm  
# End of macro DMARK
9c05				CALLMONITOR 
9c05 cd 6f ee			call debug_vector  
9c08				endm  
# End of macro CALLMONITOR
9c08			;	ex de,hl 
9c08			endif	 
9c08				; in case of spaces, skip the ptr past the copied string 
9c08				;pop af 
9c08				;ld (cli_origptr),hl 
9c08			 
9c08 c9				ret 
9c09			 
9c09			 
9c09			 
9c09			; TODO ascii push input onto stack given hl to start of input 
9c09			 
9c09			; identify type 
9c09			; if starts with a " then a string 
9c09			; otherwise it is a number 
9c09			;  
9c09			; if a string 
9c09			;     scan for ending " to get length of string to malloc for + 1 
9c09			;     malloc 
9c09			;     put pointer to string on stack first byte flags as string 
9c09			; 
9c09			; else a number 
9c09			;    look for number format identifier 
9c09			;    $xx hex 
9c09			;    %xxxxx bin 
9c09			;    xxxxx decimal 
9c09			;    convert number to 16bit word.  
9c09			;    malloc word + 1 with flag to identiy as num 
9c09			;    put pointer to number on stack 
9c09			;   
9c09			;  
9c09			  
9c09			forth_apush: 
9c09				; kernel push 
9c09			 
9c09			if DEBUG_FORTH_PUSH 
9c09						DMARK "PSH" 
9c09 f5				push af  
9c0a 3a 1e 9c			ld a, (.dmark)  
9c0d 32 6b ee			ld (debug_mark),a  
9c10 3a 1f 9c			ld a, (.dmark+1)  
9c13 32 6c ee			ld (debug_mark+1),a  
9c16 3a 20 9c			ld a, (.dmark+2)  
9c19 32 6d ee			ld (debug_mark+2),a  
9c1c 18 03			jr .pastdmark  
9c1e ..			.dmark: db "PSH"  
9c21 f1			.pastdmark: pop af  
9c22			endm  
# End of macro DMARK
9c22				CALLMONITOR 
9c22 cd 6f ee			call debug_vector  
9c25				endm  
# End of macro CALLMONITOR
9c25			endif	 
9c25				; identify input type 
9c25			 
9c25 7e				ld a,(hl) 
9c26 fe 22			cp '"' 
9c28 28 0a			jr z, .fapstr 
9c2a fe 24			cp '$' 
9c2c ca 54 9c			jp z, .faphex 
9c2f fe 25			cp '%' 
9c31 ca 3c 9c			jp z, .fapbin 
9c34			;	cp 'b' 
9c34			;	jp z, .fabin 
9c34				; else decimal 
9c34			 
9c34				; TODO do decimal conversion 
9c34				; decimal is stored as a 16bit word 
9c34			 
9c34				; by default everything is a string if type is not detected 
9c34			.fapstr: ; 
9c34 fe 22			cp '"' 
9c36 20 01			jr nz, .strnoqu 
9c38 23				inc hl 
9c39			.strnoqu: 
9c39 c3 0e 9b			jp forth_push_str 
9c3c			 
9c3c			 
9c3c			 
9c3c			.fapbin:    ; push a binary string.  
9c3c 11 00 00			ld de, 0   ; hold a 16bit value 
9c3f			 
9c3f 23			.fapbinshift:	inc hl  
9c40 7e				ld a,(hl) 
9c41 fe 00			cp 0     ; done scanning  
9c43 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c45			 
9c45				; left shift de 
9c45 eb				ex de, hl	 
9c46 29				add hl, hl 
9c47			 
9c47				; is 1 
9c47 fe 31			cp '1' 
9c49 20 02			jr nz, .binzero 
9c4b cb 4d			bit 1, l 
9c4d			.binzero: 
9c4d eb				ex de, hl	 ; save current de 
9c4e 18 ef			jr .fapbinshift 
9c50			 
9c50			.fapbdone: 
9c50 eb				ex de, hl 
9c51 c3 a0 9a			jp forth_push_numhl 
9c54			 
9c54			 
9c54			.faphex:   ; hex is always stored as a 16bit word 
9c54				; skip number prefix 
9c54 23				inc hl 
9c55				; turn ascii into number 
9c55 cd eb 8f			call get_word_hl	; ret 16bit word in hl 
9c58			 
9c58 c3 a0 9a			jp forth_push_numhl 
9c5b			 
9c5b 00				 nop 
9c5c			 
9c5c			.fabin:   ; TODO bin conversion 
9c5c			 
9c5c			 
9c5c c9				ret 
9c5d			 
9c5d			 
9c5d			; get either a string ptr or a 16bit word from the data stack 
9c5d			 
9c5d			FORTH_DSP: macro 
9c5d				call macro_forth_dsp 
9c5d				endm 
9c5d			 
9c5d			macro_forth_dsp: 
9c5d				; data stack pointer points to current word on tos 
9c5d			 
9c5d 2a ee e9			ld hl,(cli_data_sp) 
9c60			 
9c60				if DEBUG_FORTH_PUSH 
9c60						DMARK "DSP" 
9c60 f5				push af  
9c61 3a 75 9c			ld a, (.dmark)  
9c64 32 6b ee			ld (debug_mark),a  
9c67 3a 76 9c			ld a, (.dmark+1)  
9c6a 32 6c ee			ld (debug_mark+1),a  
9c6d 3a 77 9c			ld a, (.dmark+2)  
9c70 32 6d ee			ld (debug_mark+2),a  
9c73 18 03			jr .pastdmark  
9c75 ..			.dmark: db "DSP"  
9c78 f1			.pastdmark: pop af  
9c79			endm  
# End of macro DMARK
9c79			 
9c79 cd 40 cc				call display_data_sp 
9c7c				;call break_point_state 
9c7c				;rst 030h 
9c7c				CALLMONITOR 
9c7c cd 6f ee			call debug_vector  
9c7f				endm  
# End of macro CALLMONITOR
9c7f				endif 
9c7f			 
9c7f c9				ret 
9c80			 
9c80			; return hl to start of value on stack 
9c80			 
9c80			FORTH_DSP_VALUE: macro 
9c80				call macro_forth_dsp_value 
9c80				endm 
9c80			 
9c80			macro_forth_dsp_value: 
9c80			 
9c80				FORTH_DSP 
9c80 cd 5d 9c			call macro_forth_dsp 
9c83				endm 
# End of macro FORTH_DSP
9c83			 
9c83 d5				push de 
9c84			 
9c84 23				inc hl ; skip type 
9c85			 
9c85 5e				ld e, (hl) 
9c86 23				inc hl 
9c87 56				ld d, (hl) 
9c88 eb				ex de,hl  
9c89			 
9c89 d1				pop de 
9c8a			 
9c8a c9				ret 
9c8b			 
9c8b			; return hl to start of value to second item on stack 
9c8b			 
9c8b			FORTH_DSP_VALUEM1: macro 
9c8b				call macro_forth_dsp_value_m1 
9c8b				endm 
9c8b			 
9c8b			macro_forth_dsp_value_m1: 
9c8b			 
9c8b				FORTH_DSP 
9c8b cd 5d 9c			call macro_forth_dsp 
9c8e				endm 
# End of macro FORTH_DSP
9c8e			 
9c8e 2b				dec hl 
9c8f 2b				dec hl 
9c90			;	dec hl 
9c90			 
9c90 d5				push de 
9c91			 
9c91 5e				ld e, (hl) 
9c92 23				inc hl 
9c93 56				ld d, (hl) 
9c94 eb				ex de,hl  
9c95			 
9c95 d1				pop de 
9c96			 
9c96 c9				ret 
9c97			 
9c97				 
9c97			 
9c97			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c97			 
9c97			FORTH_DSP_POP: macro 
9c97				call macro_forth_dsp_pop 
9c97				endm 
9c97			 
9c97			 
9c97			; get the tos data type 
9c97			 
9c97			FORTH_DSP_TYPE:   macro 
9c97			 
9c97				;FORTH_DSP_VALUE 
9c97				FORTH_DSP 
9c97				 
9c97				; hl points to value 
9c97				; check type 
9c97			 
9c97				ld a,(hl) 
9c97			 
9c97				endm 
9c97			 
9c97			; load the tos value into hl 
9c97			 
9c97			 
9c97			FORTH_DSP_VALUEHL:  macro 
9c97				call macro_dsp_valuehl 
9c97				endm 
9c97			 
9c97			 
9c97			 
9c97			macro_dsp_valuehl: 
9c97				FORTH_DSP_VALUE 
9c97 cd 80 9c			call macro_forth_dsp_value 
9c9a				endm 
# End of macro FORTH_DSP_VALUE
9c9a			 
9c9a				;FORTH_ERR_TOS_NOTNUM 
9c9a			 
9c9a				;inc hl   ; skip type id 
9c9a			 
9c9a			;	push de 
9c9a			; 
9c9a			;	ld e, (hl) 
9c9a			;	inc hl 
9c9a			;	ld d, (hl) 
9c9a			;	ex de,hl  
9c9a			 
9c9a			;	pop de 
9c9a			 
9c9a				if DEBUG_FORTH_PUSH 
9c9a						DMARK "DVL" 
9c9a f5				push af  
9c9b 3a af 9c			ld a, (.dmark)  
9c9e 32 6b ee			ld (debug_mark),a  
9ca1 3a b0 9c			ld a, (.dmark+1)  
9ca4 32 6c ee			ld (debug_mark+1),a  
9ca7 3a b1 9c			ld a, (.dmark+2)  
9caa 32 6d ee			ld (debug_mark+2),a  
9cad 18 03			jr .pastdmark  
9caf ..			.dmark: db "DVL"  
9cb2 f1			.pastdmark: pop af  
9cb3			endm  
# End of macro DMARK
9cb3				CALLMONITOR 
9cb3 cd 6f ee			call debug_vector  
9cb6				endm  
# End of macro CALLMONITOR
9cb6				endif 
9cb6 c9				ret 
9cb7			 
9cb7			forth_apushstrhl:      
9cb7				; push of string requires use of cli_origptr 
9cb7				; bodge use 
9cb7			 
9cb7				; get current cli_origptr, save, update with temp pointer  
9cb7 ed 5b 3e ea		ld de, (cli_origptr) 
9cbb 22 3e ea			ld (cli_origptr), hl 
9cbe d5				push de 
9cbf cd 09 9c			call forth_apush 
9cc2 d1				pop de 
9cc3 ed 53 3e ea		ld (cli_origptr), de 
9cc7 c9			        ret	 
9cc8			 
9cc8			 
9cc8			; increase loop stack pointer and save hl to it 
9cc8				 
9cc8			FORTH_LOOP_NEXT: macro 
9cc8				call macro_forth_loop_next 
9cc8				;nop 
9cc8				endm 
9cc8			 
9cc8			macro_forth_loop_next: 
9cc8				if DEBUG_FORTH_STACK_GUARD 
9cc8 cd a3 e0				call check_stacks 
9ccb				endif 
9ccb e5				push hl 
9ccc d5				push de 
9ccd eb				ex de,hl 
9cce 2a f0 e9			ld hl,(cli_loop_sp) 
9cd1 23				inc hl 
9cd2 23				inc hl 
9cd3					if DEBUG_FORTH_WORDS 
9cd3						DMARK "LNX" 
9cd3 f5				push af  
9cd4 3a e8 9c			ld a, (.dmark)  
9cd7 32 6b ee			ld (debug_mark),a  
9cda 3a e9 9c			ld a, (.dmark+1)  
9cdd 32 6c ee			ld (debug_mark+1),a  
9ce0 3a ea 9c			ld a, (.dmark+2)  
9ce3 32 6d ee			ld (debug_mark+2),a  
9ce6 18 03			jr .pastdmark  
9ce8 ..			.dmark: db "LNX"  
9ceb f1			.pastdmark: pop af  
9cec			endm  
# End of macro DMARK
9cec						CALLMONITOR 
9cec cd 6f ee			call debug_vector  
9cef				endm  
# End of macro CALLMONITOR
9cef					endif 
9cef 22 f0 e9			ld (cli_loop_sp),hl 
9cf2 73				ld (hl), e 
9cf3 23				inc hl 
9cf4 72				ld (hl), d 
9cf5 d1				pop de    ; been reversed so save a swap on restore 
9cf6 e1				pop hl 
9cf7				if DEBUG_FORTH_STACK_GUARD 
9cf7 cd a3 e0				call check_stacks 
9cfa				endif 
9cfa c9				ret 
9cfb			 
9cfb			; get current ret stack pointer and save to hl  
9cfb				 
9cfb			FORTH_LOOP_TOS: macro 
9cfb				call macro_forth_loop_tos 
9cfb				endm 
9cfb			 
9cfb			macro_forth_loop_tos: 
9cfb d5				push de 
9cfc 2a f0 e9			ld hl,(cli_loop_sp) 
9cff 5e				ld e, (hl) 
9d00 23				inc hl 
9d01 56				ld d, (hl) 
9d02 eb				ex de, hl 
9d03 d1				pop de 
9d04 c9				ret 
9d05			 
9d05			; pop loop stack pointer 
9d05				 
9d05			FORTH_LOOP_POP: macro 
9d05				call macro_forth_loop_pop 
9d05				endm 
9d05			 
9d05			 
9d05			macro_forth_loop_pop: 
9d05				if DEBUG_FORTH_STACK_GUARD 
9d05					DMARK "LPP" 
9d05 f5				push af  
9d06 3a 1a 9d			ld a, (.dmark)  
9d09 32 6b ee			ld (debug_mark),a  
9d0c 3a 1b 9d			ld a, (.dmark+1)  
9d0f 32 6c ee			ld (debug_mark+1),a  
9d12 3a 1c 9d			ld a, (.dmark+2)  
9d15 32 6d ee			ld (debug_mark+2),a  
9d18 18 03			jr .pastdmark  
9d1a ..			.dmark: db "LPP"  
9d1d f1			.pastdmark: pop af  
9d1e			endm  
# End of macro DMARK
9d1e cd a3 e0				call check_stacks 
9d21					FORTH_CHK_LOOP_UNDER 
9d21 e5				push hl 
9d22 d5				push de 
9d23 2a f0 e9			ld hl,(cli_loop_sp) 
9d26 11 2a e9			ld de, cli_loop_stack 
9d29 cd f9 8c			call cmp16 
9d2c da bd e1			jp c, fault_loop_under 
9d2f d1				pop de 
9d30 e1				pop hl 
9d31				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d31				endif 
9d31 e5				push hl 
9d32 2a f0 e9			ld hl,(cli_loop_sp) 
9d35 2b				dec hl 
9d36 2b				dec hl 
9d37 22 f0 e9			ld (cli_loop_sp), hl 
9d3a				; TODO do stack underflow checks 
9d3a e1				pop hl 
9d3b				if DEBUG_FORTH_STACK_GUARD 
9d3b cd a3 e0				call check_stacks 
9d3e					FORTH_CHK_LOOP_UNDER 
9d3e e5				push hl 
9d3f d5				push de 
9d40 2a f0 e9			ld hl,(cli_loop_sp) 
9d43 11 2a e9			ld de, cli_loop_stack 
9d46 cd f9 8c			call cmp16 
9d49 da bd e1			jp c, fault_loop_under 
9d4c d1				pop de 
9d4d e1				pop hl 
9d4e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d4e				endif 
9d4e c9				ret 
9d4f			 
9d4f			macro_forth_dsp_pop: 
9d4f			 
9d4f e5				push hl 
9d50			 
9d50				; release malloc data 
9d50			 
9d50				if DEBUG_FORTH_STACK_GUARD 
9d50 cd a3 e0				call check_stacks 
9d53					FORTH_CHK_DSP_UNDER 
9d53 e5				push hl 
9d54 d5				push de 
9d55 2a ee e9			ld hl,(cli_data_sp) 
9d58 11 28 e8			ld de, cli_data_stack 
9d5b cd f9 8c			call cmp16 
9d5e da b1 e1			jp c, fault_dsp_under 
9d61 d1				pop de 
9d62 e1				pop hl 
9d63				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d63				endif 
9d63				;ld hl,(cli_data_sp) 
9d63			if DEBUG_FORTH_DOT 
9d63				DMARK "DPP" 
9d63 f5				push af  
9d64 3a 78 9d			ld a, (.dmark)  
9d67 32 6b ee			ld (debug_mark),a  
9d6a 3a 79 9d			ld a, (.dmark+1)  
9d6d 32 6c ee			ld (debug_mark+1),a  
9d70 3a 7a 9d			ld a, (.dmark+2)  
9d73 32 6d ee			ld (debug_mark+2),a  
9d76 18 03			jr .pastdmark  
9d78 ..			.dmark: db "DPP"  
9d7b f1			.pastdmark: pop af  
9d7c			endm  
# End of macro DMARK
9d7c				CALLMONITOR 
9d7c cd 6f ee			call debug_vector  
9d7f				endm  
# End of macro CALLMONITOR
9d7f			endif	 
9d7f			 
9d7f			 
9d7f			if FORTH_ENABLE_DSPPOPFREE 
9d7f			 
9d7f				FORTH_DSP 
9d7f cd 5d 9c			call macro_forth_dsp 
9d82				endm 
# End of macro FORTH_DSP
9d82			 
9d82 7e				ld a, (hl) 
9d83 fe 01			cp DS_TYPE_STR 
9d85 20 23			jr nz, .skippopfree 
9d87			 
9d87				FORTH_DSP_VALUEHL 
9d87 cd 97 9c			call macro_dsp_valuehl 
9d8a				endm 
# End of macro FORTH_DSP_VALUEHL
9d8a 00				nop 
9d8b			if DEBUG_FORTH_DOT 
9d8b				DMARK "DPf" 
9d8b f5				push af  
9d8c 3a a0 9d			ld a, (.dmark)  
9d8f 32 6b ee			ld (debug_mark),a  
9d92 3a a1 9d			ld a, (.dmark+1)  
9d95 32 6c ee			ld (debug_mark+1),a  
9d98 3a a2 9d			ld a, (.dmark+2)  
9d9b 32 6d ee			ld (debug_mark+2),a  
9d9e 18 03			jr .pastdmark  
9da0 ..			.dmark: db "DPf"  
9da3 f1			.pastdmark: pop af  
9da4			endm  
# End of macro DMARK
9da4				CALLMONITOR 
9da4 cd 6f ee			call debug_vector  
9da7				endm  
# End of macro CALLMONITOR
9da7			endif	 
9da7 cd d1 91			call free 
9daa			.skippopfree: 
9daa				 
9daa			 
9daa			endif 
9daa			 
9daa			if DEBUG_FORTH_DOT_KEY 
9daa				DMARK "DP2" 
9daa				CALLMONITOR 
9daa			endif	 
9daa			 
9daa				; move pointer down 
9daa			 
9daa 2a ee e9			ld hl,(cli_data_sp) 
9dad 2b				dec hl 
9dae 2b				dec hl 
9daf			; PARSEV5 
9daf 2b				dec hl 
9db0 22 ee e9			ld (cli_data_sp), hl 
9db3			 
9db3				if DEBUG_FORTH_STACK_GUARD 
9db3 cd a3 e0				call check_stacks 
9db6					FORTH_CHK_DSP_UNDER 
9db6 e5				push hl 
9db7 d5				push de 
9db8 2a ee e9			ld hl,(cli_data_sp) 
9dbb 11 28 e8			ld de, cli_data_stack 
9dbe cd f9 8c			call cmp16 
9dc1 da b1 e1			jp c, fault_dsp_under 
9dc4 d1				pop de 
9dc5 e1				pop hl 
9dc6				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dc6				endif 
9dc6			 
9dc6 e1				pop hl 
9dc7			 
9dc7 c9				ret 
9dc8			 
9dc8			getwordathl: 
9dc8				; hl points to an address 
9dc8				; load hl with the word at that address 
9dc8			 
9dc8 d5				push de 
9dc9			 
9dc9 5e				ld e, (hl) 
9dca 23				inc hl 
9dcb 56				ld d, (hl) 
9dcc eb				ex de, hl 
9dcd			 
9dcd d1				pop de 
9dce c9				ret 
9dcf			 
9dcf			 
9dcf			 
9dcf			 
9dcf			 
9dcf			; eof 
9dcf			 
# End of file forth_stackopsv5.asm
9dcf			endif 
9dcf			 
9dcf			loadwordinhl:	 
9dcf			 
9dcf d5				push de 
9dd0			 
9dd0 5e				ld e, (hl) 
9dd1 23				inc hl 
9dd2 56				ld d, (hl) 
9dd3 eb				ex de,hl  
9dd4			 
9dd4 d1				pop de 
9dd5			 
9dd5 c9				ret 
9dd6			 
9dd6			user_word_eol:  
9dd6				; hl contains the pointer to where to create a linked list item from the end 
9dd6				; of the user dict to continue on at the system word dict 
9dd6				 
9dd6				; poke the stub of the word list linked list to repoint to rom words 
9dd6			 
9dd6				; stub format 
9dd6				; db   word id 
9dd6				; dw    link to next word 
9dd6			        ; db char length of token 
9dd6				; db string + 0 term 
9dd6				; db exec code....  
9dd6			 
9dd6 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9dd8 77				ld (hl), a		; word id 
9dd9 23				inc hl 
9dda			 
9dda 11 a5 9f			ld de, sysdict 
9ddd 73				ld (hl), e		; next word link ie system dict 
9dde 23				inc hl 
9ddf 72				ld (hl), d		; next word link ie system dict 
9de0 23				inc hl	 
9de1			 
9de1			;	ld (hl), sysdict		; next word link ie system dict 
9de1			;	inc hl 
9de1			;	inc hl 
9de1			 
9de1			;	inc hl 
9de1			;	inc hl 
9de1			 
9de1 3e 02			ld a, 2			; word length is 0 
9de3 77				ld (hl), a	 
9de4 23				inc hl 
9de5			 
9de5 3e 7e			ld a, '~'			; word length is 0 
9de7 77				ld (hl), a	 
9de8 23				inc hl 
9de9 3e 00			ld a, 0			; save empty word 
9deb 77				ld (hl), a 
9dec			 
9dec c9				ret 
9ded			 
9ded				 
9ded			 
9ded			forthexec_cleanup: 
9ded				FORTH_RSP_POP 
9ded cd 68 9a			call macro_forth_rsp_pop 
9df0				endm 
# End of macro FORTH_RSP_POP
9df0 c9				ret 
9df1			 
9df1			forth_call_hl: 
9df1				; taking hl 
9df1 e5				push hl 
9df2 c9				ret 
9df3			 
9df3			; this is called to reset Forth system but keep existing uwords etc 
9df3			 
9df3			forth_warmstart: 
9df3				; setup stack over/under flow checks 
9df3				if DEBUG_FORTH_STACK_GUARD 
9df3 cd 89 e0				call chk_stk_init 
9df6				endif 
9df6			 
9df6				; init stack pointers  - * these stacks go upwards *  
9df6 21 ac e9			ld hl, cli_ret_stack 
9df9 22 f2 e9			ld (cli_ret_sp), hl	 
9dfc				; set bottom of stack 
9dfc 3e 00			ld a,0 
9dfe 77				ld (hl),a 
9dff 23				inc hl 
9e00 77				ld (hl),a 
9e01			 
9e01 21 28 e8			ld hl, cli_data_stack 
9e04 22 ee e9			ld (cli_data_sp), hl	 
9e07				; set bottom of stack 
9e07 3e 00			ld a,0 
9e09 77				ld (hl),a 
9e0a 23				inc hl 
9e0b 77				ld (hl),a 
9e0c			 
9e0c 21 2a e9			ld hl, cli_loop_stack 
9e0f 22 f0 e9			ld (cli_loop_sp), hl	 
9e12				; set bottom of stack 
9e12 3e 00			ld a,0 
9e14 77				ld (hl),a 
9e15 23				inc hl 
9e16 77				ld (hl),a 
9e17			 
9e17				; init extent of current open file 
9e17			 
9e17 3e 00			ld a, 0 
9e19 32 6a ea			ld (store_openext), a 
9e1c			 
9e1c c9				ret 
9e1d			 
9e1d			 
9e1d			 
9e1d			; Cold Start - this is called to setup the whole Forth system 
9e1d			 
9e1d			forth_init: 
9e1d			 
9e1d				; setup stack over/under flow checks 
9e1d			 
9e1d			;	if DEBUG_FORTH_STACK_GUARD 
9e1d			;		call chk_stk_init 
9e1d			;	endif 
9e1d			 
9e1d				; enable auto display updates (slow.....) 
9e1d			 
9e1d 3e 01			ld a, 1 
9e1f 32 3c ea			ld (cli_autodisplay), a 
9e22			 
9e22				; if storage is in use disable long reads for now 
9e22 3e 00			ld a, 0 
9e24 32 75 ea			ld (store_longread), a 
9e27			 
9e27			 
9e27				; show start up screen 
9e27			 
9e27 cd ae 8a			call clear_display 
9e2a			 
9e2a 3e 00			ld a,0 
9e2c 32 5e ea			ld (f_cursor_ptr), a 
9e2f			 
9e2f				; set start of word list in start of ram - for use when creating user words 
9e2f			 
9e2f 21 3d e4			ld hl, baseram 
9e32 22 be e5			ld (os_last_new_uword), hl 
9e35 cd d6 9d			call user_word_eol 
9e38				 
9e38			;		call display_data_sp 
9e38			;		call next_page_prompt 
9e38			 
9e38			 
9e38			 
9e38			 
9e38 c9				ret 
9e39			 
9e39 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e4d			 
9e4d			; TODO push to stack 
9e4d			 
9e4d			;  
9e4d			 
9e4d			if FORTH_PARSEV2 
9e4d			 
9e4d			 
9e4d				include "forth_parserv2.asm" 
9e4d			 
9e4d			endif 
9e4d			 
9e4d			 
9e4d			; parse cli version 1 
9e4d			 
9e4d			if FORTH_PARSEV1 
9e4d			 
9e4d			 
9e4d			 
9e4d			      include "forth_parserv1.asm" 
9e4d			endif 
9e4d				 
9e4d			if FORTH_PARSEV3 
9e4d			 
9e4d			 
9e4d			 
9e4d			      include "forth_parserv3.asm" 
9e4d				include "forth_wordsv3.asm" 
9e4d			endif 
9e4d			 
9e4d			if FORTH_PARSEV4 
9e4d			 
9e4d			 
9e4d			 
9e4d			      include "forth_parserv4.asm" 
9e4d				include "forth_wordsv4.asm" 
9e4d			endif 
9e4d			 
9e4d			if FORTH_PARSEV5 
9e4d			 
9e4d			 
9e4d			 
9e4d			      include "forth_parserv5.asm" 
9e4d			 
9e4d			 
9e4d			; A better parser without using malloc and string copies all over the place.  
9e4d			; Exec in situ should be faster 
9e4d			 
9e4d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e4d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e4d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e4d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e4d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e4d			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e4d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e4d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e4d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e4d			 
9e4d			; Core word preamble macro 
9e4d			 
9e4d			CWHEAD:   macro nxtword opcode lit len opflags 
9e4d				db WORD_SYS_CORE+opcode             
9e4d				; internal op code number 
9e4d				dw nxtword            
9e4d				; link to next dict word block 
9e4d				db len + 1 
9e4d				; literal length of dict word inc zero term 
9e4d				db lit,0              
9e4d				; literal dict word 
9e4d			        ; TODO db opflags        
9e4d				endm 
9e4d			 
9e4d			 
9e4d			NEXTW: macro  
9e4d				jp macro_next 
9e4d				endm 
9e4d			 
9e4d			macro_next: 
9e4d			if DEBUG_FORTH_PARSE_KEY 
9e4d				DMARK "NXT" 
9e4d				CALLMONITOR 
9e4d			endif	 
9e4d			;	inc hl  ; skip token null term  
9e4d ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e51 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e55 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e58			if DEBUG_FORTH_PARSE_KEY 
9e58				DMARK "}AA" 
9e58				CALLMONITOR 
9e58			endif	 
9e58 c3 5b 9f			jp execnext 
9e5b				;jp exec1 
9e5b			       
9e5b			 
9e5b			 
9e5b			; Another go at the parser to compile  
9e5b			 
9e5b			 
9e5b			; TODO rework parser to change all of the string words to byte tokens 
9e5b			; TODO do a search for  
9e5b			 
9e5b			; TODO first run normal parser to zero term sections 
9e5b			; TODO for each word do a token look up to get the op code 
9e5b			; TODO need some means to flag to the exec that this is a byte code form    
9e5b			 
9e5b			 
9e5b			forthcompile: 
9e5b			 
9e5b			; 
9e5b			; line parse: 
9e5b			;       parse raw input buffer 
9e5b			;       tokenise the words 
9e5b			;       malloc new copy (for looping etc) 
9e5b			;       copy to malloc + current pc in line to start of string and add line term 
9e5b			;       save on new rsp 
9e5b			; 
9e5b			 
9e5b			; hl to point to the line to tokenise 
9e5b			 
9e5b			;	push hl 
9e5b 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e5e			 
9e5e			;	ld a,0		; string term on input 
9e5e			;	call strlent 
9e5e			 
9e5e			;	ld (os_tok_len), hl	 ; save string length 
9e5e			 
9e5e			;if DEBUG_FORTH_TOK 
9e5e			;	ex de,hl		 
9e5e			;endif 
9e5e			 
9e5e			;	pop hl 		; get back string pointer 
9e5e			 
9e5e			if DEBUG_FORTH_TOK 
9e5e						DMARK "TOc" 
9e5e				CALLMONITOR 
9e5e			endif 
9e5e 7e			.cptoken2:    ld a,(hl) 
9e5f 23				inc hl 
9e60 fe 7f			cp FORTH_END_BUFFER 
9e62 28 29			jr z, .cptokendone2 
9e64 fe 00			cp 0 
9e66 28 25			jr z, .cptokendone2 
9e68 fe 22			cp '"' 
9e6a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e6c fe 20			cp ' ' 
9e6e 20 ee			jr nz,  .cptoken2 
9e70			 
9e70			; TODO consume comments held between ( and ) 
9e70			 
9e70				; we have a space so change to zero term for dict match later 
9e70 2b				dec hl 
9e71 3e 00			ld a,0 
9e73 77				ld (hl), a 
9e74 23				inc hl 
9e75 18 e7			jr .cptoken2 
9e77				 
9e77			 
9e77			.cptokenstr2: 
9e77				; skip all white space until either eol (because forgot to term) or end double quote 
9e77			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e77				;inc hl ; skip current double quote 
9e77 7e				ld a,(hl) 
9e78 23				inc hl 
9e79 fe 22			cp '"' 
9e7b 28 e1			jr z, .cptoken2 
9e7d fe 7f			cp FORTH_END_BUFFER 
9e7f 28 0c			jr z, .cptokendone2 
9e81 fe 00			cp 0 
9e83 28 08			jr z, .cptokendone2 
9e85 fe 20			cp ' ' 
9e87 28 02			jr z, .cptmp2 
9e89 18 ec			jr .cptokenstr2 
9e8b			 
9e8b			.cptmp2:	; we have a space so change to zero term for dict match later 
9e8b				;dec hl 
9e8b				;ld a,"-"	; TODO remove this when working 
9e8b				;ld (hl), a 
9e8b				;inc hl 
9e8b 18 ea			jr .cptokenstr2 
9e8d			 
9e8d			.cptokendone2: 
9e8d				;inc hl 
9e8d 3e 7f			ld a, FORTH_END_BUFFER 
9e8f 77				ld (hl),a 
9e90 23				inc hl 
9e91 3e 21			ld a, '!' 
9e93 77				ld (hl),a 
9e94			 
9e94 2a c2 e5			ld hl,(os_tok_ptr) 
9e97			         
9e97			if DEBUG_FORTH_TOK 
9e97						DMARK "Tc1" 
9e97				CALLMONITOR 
9e97			endif 
9e97			 
9e97				; push exec string to top of return stack 
9e97				FORTH_RSP_NEXT 
9e97 cd 47 9a			call macro_forth_rsp_next 
9e9a				endm 
# End of macro FORTH_RSP_NEXT
9e9a c9				ret 
9e9b			 
9e9b			; Another go at the parser need to simplify the process 
9e9b			 
9e9b			forthparse: 
9e9b			 
9e9b			; 
9e9b			; line parse: 
9e9b			;       parse raw input buffer 
9e9b			;       tokenise the words 
9e9b			;       malloc new copy (for looping etc) 
9e9b			;       copy to malloc + current pc in line to start of string and add line term 
9e9b			;       save on new rsp 
9e9b			; 
9e9b			 
9e9b			; hl to point to the line to tokenise 
9e9b			 
9e9b			;	push hl 
9e9b 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e9e			 
9e9e			;	ld a,0		; string term on input 
9e9e			;	call strlent 
9e9e			 
9e9e			;	ld (os_tok_len), hl	 ; save string length 
9e9e			 
9e9e			;if DEBUG_FORTH_TOK 
9e9e			;	ex de,hl		 
9e9e			;endif 
9e9e			 
9e9e			;	pop hl 		; get back string pointer 
9e9e			 
9e9e			if DEBUG_FORTH_TOK 
9e9e						DMARK "TOK" 
9e9e				CALLMONITOR 
9e9e			endif 
9e9e 7e			.ptoken2:    ld a,(hl) 
9e9f 23				inc hl 
9ea0 fe 7f			cp FORTH_END_BUFFER 
9ea2 28 29			jr z, .ptokendone2 
9ea4 fe 00			cp 0 
9ea6 28 25			jr z, .ptokendone2 
9ea8 fe 22			cp '"' 
9eaa 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9eac fe 20			cp ' ' 
9eae 20 ee			jr nz,  .ptoken2 
9eb0			 
9eb0			; TODO consume comments held between ( and ) 
9eb0			 
9eb0				; we have a space so change to zero term for dict match later 
9eb0 2b				dec hl 
9eb1 3e 00			ld a,0 
9eb3 77				ld (hl), a 
9eb4 23				inc hl 
9eb5 18 e7			jr .ptoken2 
9eb7				 
9eb7			 
9eb7			.ptokenstr2: 
9eb7				; skip all white space until either eol (because forgot to term) or end double quote 
9eb7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eb7				;inc hl ; skip current double quote 
9eb7 7e				ld a,(hl) 
9eb8 23				inc hl 
9eb9 fe 22			cp '"' 
9ebb 28 e1			jr z, .ptoken2 
9ebd fe 7f			cp FORTH_END_BUFFER 
9ebf 28 0c			jr z, .ptokendone2 
9ec1 fe 00			cp 0 
9ec3 28 08			jr z, .ptokendone2 
9ec5 fe 20			cp ' ' 
9ec7 28 02			jr z, .ptmp2 
9ec9 18 ec			jr .ptokenstr2 
9ecb			 
9ecb			.ptmp2:	; we have a space so change to zero term for dict match later 
9ecb				;dec hl 
9ecb				;ld a,"-"	; TODO remove this when working 
9ecb				;ld (hl), a 
9ecb				;inc hl 
9ecb 18 ea			jr .ptokenstr2 
9ecd			 
9ecd			.ptokendone2: 
9ecd				;inc hl 
9ecd 3e 7f			ld a, FORTH_END_BUFFER 
9ecf 77				ld (hl),a 
9ed0 23				inc hl 
9ed1 3e 21			ld a, '!' 
9ed3 77				ld (hl),a 
9ed4			 
9ed4 2a c2 e5			ld hl,(os_tok_ptr) 
9ed7			         
9ed7			if DEBUG_FORTH_TOK 
9ed7						DMARK "TK1" 
9ed7				CALLMONITOR 
9ed7			endif 
9ed7			 
9ed7				; push exec string to top of return stack 
9ed7				FORTH_RSP_NEXT 
9ed7 cd 47 9a			call macro_forth_rsp_next 
9eda				endm 
# End of macro FORTH_RSP_NEXT
9eda c9				ret 
9edb			 
9edb			; 
9edb			;	; malloc size + buffer pointer + if is loop flag 
9edb			;	ld hl,(os_tok_len) 		 ; get string length 
9edb			; 
9edb			;	ld a,l 
9edb			; 
9edb			;	cp 0			; we dont want to use a null string 
9edb			;	ret z 
9edb			; 
9edb			;;	add 3    ; prefix malloc with buffer for current word ptr 
9edb			; 
9edb			;	add 5     ; TODO when certain not over writing memory remove 
9edb			; 
9edb			;		 
9edb			; 
9edb			;if DEBUG_FORTH_TOK 
9edb			;			DMARK "TKE" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			; 
9edb			;	ld l,a 
9edb			;	ld h,0 
9edb			;;	push hl   ; save required space for the copy later 
9edb			;	call malloc 
9edb			;if DEBUG_FORTH_TOK 
9edb			;			DMARK "TKM" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			;	if DEBUG_FORTH_MALLOC_GUARD 
9edb			;		push af 
9edb			;		call ishlzero 
9edb			;;		ld a, l 
9edb			;;		add h 
9edb			;;		cp 0 
9edb			;		pop af 
9edb			;		 
9edb			;		call z,malloc_error 
9edb			;	endif 
9edb			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9edb			; 
9edb			; 
9edb			;if DEBUG_FORTH_TOK 
9edb			;			DMARK "TKR" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			; 
9edb			;	FORTH_RSP_NEXT 
9edb			; 
9edb			;	;inc hl	 ; go past current buffer pointer 
9edb			;	;inc hl 
9edb			;	;inc hl   ; and past if loop flag 
9edb			;		; TODO Need to set flag  
9edb			; 
9edb			;	 
9edb			;	 
9edb			;	ex de,hl	; malloc is dest 
9edb			;	ld hl, (os_tok_len) 
9edb			;;	pop bc 
9edb			;	ld c, l                
9edb			;	ld b,0 
9edb			;	ld hl, (os_tok_ptr) 
9edb			; 
9edb			;if DEBUG_FORTH_TOK 
9edb			;			DMARK "TKT" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			; 
9edb			;	; do str cpy 
9edb			; 
9edb			;	ldir      ; copy byte in hl to de 
9edb			; 
9edb			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9edb			; 
9edb			;if DEBUG_FORTH_TOK 
9edb			; 
9edb			;			DMARK "TKY" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			;	;ld a,0 
9edb			;	;ld a,FORTH_END_BUFFER 
9edb			;	ex de, hl 
9edb			;	;dec hl			 ; go back over the space delim at the end of word 
9edb			;	;ld (hl),a 
9edb			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9edb			;	ld a,FORTH_END_BUFFER 
9edb			;	ld (hl),a 
9edb			;	inc hl 
9edb			;	ld a,FORTH_END_BUFFER 
9edb			;	ld (hl),a 
9edb			; 
9edb			;	; init the malloc area data 
9edb			;	; set pc for in current area 
9edb			;	;ld hl, (os_tok_malloc) 
9edb			;	;inc hl 
9edb			;	;inc hl 
9edb			;	;inc hl 
9edb			;	;ex de,hl 
9edb			;	;ld hl, (os_tok_malloc) 
9edb			;	;ld (hl),e 
9edb			;	;inc hl 
9edb			;	;ld (hl),d 
9edb			; 
9edb			; 
9edb			;	ld hl,(os_tok_malloc) 
9edb			;if DEBUG_FORTH_PARSE_KEY 
9edb			;			DMARK "TKU" 
9edb			;	CALLMONITOR 
9edb			;endif 
9edb			; 
9edb			;	ret 
9edb			 
9edb			forthexec: 
9edb			 
9edb			; line exec: 
9edb			; forth parser 
9edb			 
9edb			; 
9edb			;       get current exec line on rsp 
9edb			 
9edb				FORTH_RSP_TOS 
9edb cd 5e 9a			call macro_forth_rsp_tos 
9ede				endm 
# End of macro FORTH_RSP_TOS
9ede			 
9ede			;       restore current pc - hl points to malloc of data 
9ede			 
9ede				;ld e, (hl) 
9ede				;inc hl 
9ede				;ld d, (hl) 
9ede				;ex de,hl 
9ede			 
9ede			 
9ede			exec1: 
9ede 22 c2 e5			ld (os_tok_ptr), hl 
9ee1			 
9ee1				; copy our PC to working vars  
9ee1 22 40 ea			ld (cli_ptr), hl 
9ee4 22 3e ea			ld (cli_origptr), hl 
9ee7			 
9ee7 7e				ld a,(hl) 
9ee8 fe 7f			cp FORTH_END_BUFFER 
9eea c8				ret z 
9eeb			 
9eeb				; skip any nulls 
9eeb			 
9eeb fe 00			cp 0 
9eed 20 03			jr nz, .execword 
9eef 23				inc hl 
9ef0 18 ec			jr exec1 
9ef2			 
9ef2			 
9ef2			.execword: 
9ef2			 
9ef2			 
9ef2			 
9ef2			if DEBUG_FORTH_PARSE_KEY 
9ef2						DMARK "KYQ" 
9ef2				CALLMONITOR 
9ef2			endif 
9ef2			;       while at start of word: 
9ef2			; get start of dict (in user area first) 
9ef2			 
9ef2 21 3d e4		ld hl, baseram 
9ef5			;ld hl, sysdict 
9ef5 22 42 ea		ld (cli_nextword),hl 
9ef8			;           match word at pc 
9ef8			;           exec word 
9ef8			;           or push to dsp 
9ef8			;           forward to next token 
9ef8			;           if line term pop rsp and exit 
9ef8			;        
9ef8			 
9ef8			if DEBUG_FORTH_PARSE_KEY 
9ef8						DMARK "KYq" 
9ef8				CALLMONITOR 
9ef8			endif 
9ef8			 
9ef8			; 
9ef8			; word comp 
9ef8			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ef8			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ef8			;    move to start of word  
9ef8			;    compare word to cli_token 
9ef8			 
9ef8			.execpnword:	; HL at start of a word in the dictionary to check 
9ef8			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ef8			;	ld (cli_ptr), hl 
9ef8			 
9ef8 2a 42 ea			ld hl,(cli_nextword) 
9efb			 
9efb cd 9e 9f			call forth_tok_next 
9efe			; tok next start here 
9efe			;	; TODO skip compiled symbol for now 
9efe			;	inc hl 
9efe			; 
9efe			;	; save pointer to next word 
9efe			; 
9efe			;	; hl now points to the address of the next word pointer  
9efe			;	ld e, (hl) 
9efe			;	inc hl 
9efe			;	ld d, (hl) 
9efe			;	inc l 
9efe			; 
9efe			;	ex de,hl 
9efe			;if DEBUG_FORTH_PARSE_NEXTWORD 
9efe			;	push bc 
9efe			;	ld bc, (cli_nextword) 
9efe			;			DMARK "NXW" 
9efe			;	CALLMONITOR 
9efe			;	pop bc 
9efe			;endif 
9efe			; tok next end here 
9efe 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f01 eb				ex de, hl 
9f02			 
9f02			 
9f02				; save the pointer of the current token - 1 to check against 
9f02				 
9f02 22 46 ea			ld (cli_token), hl   
9f05				; TODO maybe remove below save if no debug 
9f05				; save token string ptr for any debug later 
9f05 23				inc hl  
9f06 22 48 ea			ld (cli_origtoken), hl 
9f09 2b				dec hl 
9f0a				; save pointer to the start of the next dictionay word 
9f0a 7e				ld a,(hl)   ; get string length 
9f0b 47				ld b,a 
9f0c			.execpnwordinc:  
9f0c 23				inc hl 
9f0d 10 fd			djnz .execpnwordinc 
9f0f 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9f12			 
9f12				; now check the word token against the string being parsed 
9f12			 
9f12 2a 46 ea			ld hl,(cli_token) 
9f15 23				inc hl     ; skip string length (use zero term instead to end) 
9f16 22 46 ea			ld (cli_token), hl 
9f19			 
9f19			if DEBUG_FORTH_PARSE_KEY 
9f19						DMARK "KY2" 
9f19			endif 
9f19			if DEBUG_FORTH_PARSE_EXEC 
9f19				; see if disabled 
9f19			 
9f19			;	ld a, (os_view_disable) 
9f19			;	cp '*' 
9f19				ld a, (debug_vector) 
9f19				cp $c9   ; RET  
9f19				jr z, .skip 
9f19			 
9f19				push hl 
9f19				push hl 
9f19				call clear_display 
9f19				ld de, .compword 
9f19				ld a, display_row_1 
9f19				call str_at_display 
9f19				pop de 
9f19				ld a, display_row_2 
9f19				call str_at_display 
9f19				ld hl,(cli_ptr) 
9f19				ld a,(hl) 
9f19			        ld hl, os_word_scratch 
9f19				ld (hl),a 
9f19				ld a,0 
9f19				inc hl 
9f19				ld (hl),a 	 
9f19				ld de, os_word_scratch 
9f19				ld a, display_row_2+10 
9f19				call str_at_display 
9f19				call update_display 
9f19				ld a, 100 
9f19				call aDelayInMS 
9f19				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f19				call delay250ms 
9f19				endif 
9f19				pop hl 
9f19			.skip:  
9f19			endif	 
9f19			.execpnchar:    ; compare char between token and string to parse 
9f19			 
9f19			if DEBUG_FORTH_PARSE_KEY 
9f19						DMARK "Ky3" 
9f19			endif 
9f19			if DEBUG_FORTH_PARSE_EXEC 
9f19				; see if disabled 
9f19			 
9f19			;	ld a, (os_view_disable) 
9f19			;	cp '*' 
9f19				ld a, (debug_vector) 
9f19				cp $C9  ; RET 
9f19				jr z, .skip2 
9f19			 
9f19			;	call clear_display 
9f19			ld hl,(cli_token) 
9f19			ld a,(hl) 
9f19			ld (os_word_scratch),a 
9f19				ld hl,(cli_ptr) 
9f19			ld a,(hl) 
9f19				ld (os_word_scratch+1),a 
9f19				ld a,0 
9f19				ld (os_word_scratch+2),a 
9f19				ld de,os_word_scratch 
9f19				ld a,display_row_4 
9f19				call str_at_display 
9f19				call update_display 
9f19			.skip2:  
9f19			endif 
9f19 2a 46 ea			ld hl,(cli_token) 
9f1c 7e				ld a, (hl)	 ; char in word token 
9f1d 23				inc hl 		; move to next char 
9f1e 22 46 ea			ld (cli_token), hl ; and save it 
9f21 47				ld b,a 
9f22			 
9f22 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f25 7e				ld a,(hl) 
9f26 23				inc hl 
9f27 22 40 ea			ld (cli_ptr), hl		; move to next char 
9f2a cd 89 90			call toUpper 		; make sure the input string matches case 
9f2d			 
9f2d			if DEBUG_FORTH_PARSE 
9f2d			endif 
9f2d			 
9f2d				; input stream end of token is a space so get rid of it 
9f2d			 
9f2d			;	cp ' ' 
9f2d			;	jr nz, .pnskipspace 
9f2d			; 
9f2d			;	ld a, 0		; make same term as word token term 
9f2d			; 
9f2d			;.pnskipspace: 
9f2d			 
9f2d			if DEBUG_FORTH_PARSE_KEY 
9f2d						DMARK "KY7" 
9f2d			endif 
9f2d b8				cp b 
9f2e c2 44 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f31				 
9f31			;    if same 
9f31			;       scan for string terms 0 for token and 32 for input 
9f31			 
9f31				 
9f31			if DEBUG_FORTH_PARSE_KEY 
9f31						DMARK "KY8" 
9f31			endif 
9f31			 
9f31 80				add b			 
9f32 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f34							; TODO need to make sure last word in zero term string is accounted for 
9f34 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f36			 
9f36			 
9f36				; at end of both strings so both are exact match 
9f36			 
9f36			;       skip ptr for next word 
9f36			 
9f36 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9f39 23				inc hl			 ; at next char 
9f3a 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f3d 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f40				 
9f40				 
9f40			if DEBUG_FORTH_PARSE_KEY 
9f40						DMARK "KY3" 
9f40			endif 
9f40			 
9f40			 
9f40			 
9f40			;       exec code block 
9f40			if DEBUG_FORTH_JP 
9f40				call clear_display 
9f40				call update_display 
9f40				call delay1s 
9f40				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f40				ld a,h 
9f40				ld hl, os_word_scratch 
9f40				call hexout 
9f40				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f40				ld a,l 
9f40				ld hl, os_word_scratch+2 
9f40				call hexout 
9f40				ld hl, os_word_scratch+4 
9f40				ld a,0 
9f40				ld (hl),a 
9f40				ld de,os_word_scratch 
9f40				call str_at_display 
9f40					ld a, display_row_2 
9f40					call str_at_display 
9f40				ld de, (cli_origtoken) 
9f40				ld a, display_row_1+10 
9f40					call str_at_display 
9f40			 
9f40				ld a,display_row_1 
9f40				ld de, .foundword 
9f40				ld a, display_row_3 
9f40				call str_at_display 
9f40				call update_display 
9f40				call delay1s 
9f40				call delay1s 
9f40				call delay1s 
9f40			endif 
9f40			 
9f40			if DEBUG_FORTH_PARSE_KEY 
9f40						DMARK "KYj" 
9f40			endif 
9f40				; TODO save the word pointer in this exec 
9f40			 
9f40 2a 44 ea			ld hl,(cli_execword) 
9f43 e9				jp (hl) 
9f44			 
9f44			 
9f44			;    if not same 
9f44			;	scan for zero term 
9f44			;	get ptr for next word 
9f44			;	goto word comp 
9f44			 
9f44			.execpnskipword:	; get pointer to next word 
9f44 2a 42 ea			ld hl,(cli_nextword) 
9f47			 
9f47 7e				ld a,(hl) 
9f48 fe 00			cp WORD_SYS_END 
9f4a			;	cp 0 
9f4a 28 09			jr z, .execendofdict			 ; at end of words 
9f4c			 
9f4c			if DEBUG_FORTH_PARSE_KEY 
9f4c						DMARK "KY4" 
9f4c			endif 
9f4c			if DEBUG_FORTH_PARSE_EXEC 
9f4c			 
9f4c				; see if disabled 
9f4c			 
9f4c			;	ld a, (os_view_disable) 
9f4c			;	cp '*' 
9f4c				ld a,(debug_vector) 
9f4c				cp $c9   ; RET 
9f4c				jr z, .noskip 
9f4c			 
9f4c			 
9f4c				ld de, .nowordfound 
9f4c				ld a, display_row_3 
9f4c				call str_at_display 
9f4c				call update_display 
9f4c				ld a, 100 
9f4c				call aDelayInMS 
9f4c				 
9f4c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f4c					call delay250ms 
9f4c				endif 
9f4c			.noskip:  
9f4c			 
9f4c			endif	 
9f4c			 
9f4c 2a 3e ea			ld hl,(cli_origptr) 
9f4f 22 40 ea			ld (cli_ptr),hl 
9f52			 
9f52			if DEBUG_FORTH_PARSE_KEY 
9f52						DMARK "KY5" 
9f52			endif 
9f52 c3 f8 9e			jp .execpnword			; else go to next word 
9f55			 
9f55			.execendofdict:  
9f55			 
9f55			if DEBUG_FORTH_PARSE_KEY 
9f55						DMARK "KYe" 
9f55			endif 
9f55			if DEBUG_FORTH_PARSE_EXEC 
9f55				; see if disabled 
9f55			 
9f55			;	ld a, (os_view_disable) 
9f55			;	cp '*' 
9f55				ld a,(debug_vector) 
9f55				cp $c9   ; ret 
9f55				jr z, .ispskip 
9f55			 
9f55				call clear_display 
9f55				call update_display 
9f55				call delay1s 
9f55				ld de, (cli_origptr) 
9f55				ld a, display_row_1 
9f55				call str_at_display 
9f55				 
9f55				ld de, .enddict 
9f55				ld a, display_row_3 
9f55				call str_at_display 
9f55				call update_display 
9f55				ld a, 100 
9f55				call aDelayInMS 
9f55				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f55				call delay1s 
9f55				call delay1s 
9f55				call delay1s 
9f55				endif 
9f55			.ispskip:  
9f55				 
9f55			endif	 
9f55			 
9f55			 
9f55			 
9f55				; if the word is not a keyword then must be a literal so push it to stack 
9f55			 
9f55			; push token to stack to end of word 
9f55			 
9f55				STACKFRAME ON $1efe $2f9f 
9f55				if DEBUG_STACK_IMB 
9f55					if ON 
9f55						exx 
9f55						ld de, $1efe 
9f55						ld a, d 
9f55						ld hl, curframe 
9f55						call hexout 
9f55						ld a, e 
9f55						ld hl, curframe+2 
9f55						call hexout 
9f55						ld hl, $1efe 
9f55						push hl 
9f55						ld hl, $2f9f 
9f55						push hl 
9f55						exx 
9f55					endif 
9f55				endif 
9f55			endm 
# End of macro STACKFRAME
9f55			 
9f55 2a c2 e5		ld hl,(os_tok_ptr) 
9f58 cd 09 9c		call forth_apush 
9f5b			 
9f5b				STACKFRAMECHK ON $1efe $2f9f 
9f5b				if DEBUG_STACK_IMB 
9f5b					if ON 
9f5b						exx 
9f5b						ld hl, $2f9f 
9f5b						pop de   ; $2f9f 
9f5b						call cmp16 
9f5b						jr nz, .spnosame 
9f5b						ld hl, $1efe 
9f5b						pop de   ; $1efe 
9f5b						call cmp16 
9f5b						jr z, .spfrsame 
9f5b						.spnosame: call showsperror 
9f5b						.spfrsame: nop 
9f5b						exx 
9f5b					endif 
9f5b				endif 
9f5b			endm 
# End of macro STACKFRAMECHK
9f5b			 
9f5b			execnext: 
9f5b			 
9f5b			if DEBUG_FORTH_PARSE_KEY 
9f5b						DMARK "KY>" 
9f5b			endif 
9f5b			; move past token to next word 
9f5b			 
9f5b 2a c2 e5		ld hl, (os_tok_ptr) 
9f5e 3e 00		ld a, 0 
9f60 01 ff 00		ld bc, 255     ; input buffer size 
9f63 ed b1		cpir 
9f65			 
9f65			if DEBUG_FORTH_PARSE_KEY 
9f65						DMARK "KY!" 
9f65				CALLMONITOR 
9f65			endif	 
9f65			; TODO this might place hl on the null, so will need to forward on??? 
9f65			;inc hl   ; see if this gets onto the next item 
9f65			 
9f65			 
9f65			; TODO pass a pointer to the buffer to push 
9f65			; TODO call function to push 
9f65			 
9f65			; look for end of input 
9f65			 
9f65			;inc hl 
9f65			;ld a,(hl) 
9f65			;cp FORTH_END_BUFFER 
9f65			;ret z 
9f65			 
9f65			 
9f65 c3 de 9e		jp exec1 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			 
9f68			findnexttok: 
9f68			 
9f68				; hl is pointer to move 
9f68				; de is the token to locate 
9f68			 
9f68					if DEBUG_FORTH 
9f68						DMARK "NTK" 
9f68						CALLMONITOR 
9f68					endif 
9f68 d5				push de 
9f69			 
9f69			.fnt1:	 
9f69				; find first char of token to locate 
9f69			 
9f69 1a				ld a, (de) 
9f6a 4f				ld c,a 
9f6b 7e				ld a,(hl) 
9f6c cd 89 90			call toUpper 
9f6f					if DEBUG_FORTH 
9f6f						DMARK "NT1" 
9f6f						CALLMONITOR 
9f6f					endif 
9f6f b9				cp c 
9f70			 
9f70 28 03			jr z, .fnt2cmpmorefirst	 
9f72			 
9f72				; first char not found move to next char 
9f72			 
9f72 23				inc hl 
9f73 18 f4			jr .fnt1 
9f75			 
9f75			.fnt2cmpmorefirst:	 
9f75				; first char of token found.  
9f75			 
9f75 e5				push hl     ; save start of token just in case it is the right one 
9f76 d9				exx 
9f77 e1				pop hl        ; save it to hl' 
9f78 d9				exx 
9f79			 
9f79			 
9f79			.fnt2cmpmore:	 
9f79				; compare the rest 
9f79				 
9f79 23				inc hl 
9f7a 13				inc de 
9f7b				 
9f7b 1a				ld a, (de) 
9f7c 4f				ld c,a 
9f7d 7e				ld a,(hl) 
9f7e cd 89 90			call toUpper 
9f81			 
9f81					if DEBUG_FORTH 
9f81						DMARK "NT2" 
9f81						CALLMONITOR 
9f81					endif 
9f81				; c has the token to find char 
9f81				; a has the mem to scan char 
9f81			 
9f81 b9				cp c 
9f82 28 04			jr z,.fntmatch1 
9f84			 
9f84				; they are not the same 
9f84			 
9f84					if DEBUG_FORTH 
9f84						DMARK "NT3" 
9f84						CALLMONITOR 
9f84					endif 
9f84 d1				pop de	; reset de token to look for 
9f85 d5				push de 
9f86 18 e1			jr .fnt1 
9f88				 
9f88			.fntmatch1: 
9f88			 
9f88				; is the same char a null which means we might have a full hit? 
9f88					if DEBUG_FORTH 
9f88						DMARK "NT4" 
9f88						CALLMONITOR 
9f88					endif 
9f88			 
9f88 fe 00			cp 0 
9f8a 28 0b			jr z, .fntmatchyes 
9f8c			 
9f8c				; are we at the end of the token to find? 
9f8c			 
9f8c					if DEBUG_FORTH 
9f8c						DMARK "NT5" 
9f8c						CALLMONITOR 
9f8c					endif 
9f8c 3e 00			ld a, 0 
9f8e b9				cp c 
9f8f			 
9f8f c2 79 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f92			 
9f92					if DEBUG_FORTH 
9f92						DMARK "NT6" 
9f92						CALLMONITOR 
9f92					endif 
9f92				; token to find is exhusted but no match to stream 
9f92			 
9f92				; restore tok pointer and continue on 
9f92 d1				pop de 
9f93 d5				push de 
9f94 c3 69 9f			jp .fnt1 
9f97			 
9f97			 
9f97			.fntmatchyes: 
9f97			 
9f97				; hl now contains the end of the found token 
9f97			 
9f97				; get rid of saved token pointer to find 
9f97			 
9f97 d1				pop de 
9f98			 
9f98					if DEBUG_FORTH 
9f98						DMARK "NT9" 
9f98						CALLMONITOR 
9f98					endif 
9f98			 
9f98				; hl will be on the null term so forward on 
9f98			 
9f98				; get back the saved start of the token 
9f98			 
9f98 d9				exx 
9f99 e5				push hl     ; save start of token just in case it is the right one 
9f9a d9				exx 
9f9b e1				pop hl        ; save it to hl 
9f9c			 
9f9c c9				ret 
9f9d			 
9f9d			 
9f9d			; LIST needs to find a specific token   
9f9d			; FORGET needs to find a spefici token 
9f9d			 
9f9d			; SAVE needs to find all tokens by flag 
9f9d			; WORDS just needs to scan through all  by flag 
9f9d			; UWORDS needs to scan through all by flag 
9f9d			 
9f9d			 
9f9d			; given hl as pointer to start of dict look up string 
9f9d			; return hl as pointer to start of word block 
9f9d			; or 0 if not found 
9f9d			 
9f9d			forth_find_tok: 
9f9d c9				ret 
9f9e			 
9f9e			; given hl as pointer to dict structure 
9f9e			; move to the next dict block structure 
9f9e			 
9f9e			forth_tok_next: 
9f9e				; hl now points to the address of the next word pointer  
9f9e				; TODO skip compiled symbol for now 
9f9e			;	push de 
9f9e 23				inc hl 
9f9f 5e				ld e, (hl) 
9fa0 23				inc hl 
9fa1 56				ld d, (hl) 
9fa2 23				inc hl 
9fa3			 
9fa3 eb				ex de,hl 
9fa4			if DEBUG_FORTH_PARSE_NEXTWORD 
9fa4				push bc 
9fa4				ld bc, (cli_nextword) 
9fa4						DMARK "NXW" 
9fa4				CALLMONITOR 
9fa4				pop bc 
9fa4			endif 
9fa4			;	pop de	 
9fa4 c9				ret 
9fa5			 
9fa5			 
9fa5			 
9fa5			; eof 
# End of file forth_parserv5.asm
9fa5				include "forth_wordsv4.asm" 
9fa5			 
9fa5			; the core word dictionary v4 
9fa5			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fa5			 
9fa5			; this is a linked list for each of the system words used 
9fa5			; user defined words will follow the same format but will be in ram 
9fa5			 
9fa5			 
9fa5			; 
9fa5			; 
9fa5			; define linked list: 
9fa5			; 
9fa5			; 1. compiled byte op code 
9fa5			; 2. len of text word 
9fa5			; 3. text word 
9fa5			; 4. ptr to next dictionary word 
9fa5			; 5. asm, calls etc for the word 
9fa5			; 
9fa5			;  if 1 == 0 then last word in dict  
9fa5			;   
9fa5			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fa5			;  
9fa5			;  
9fa5			; create basic standard set of words 
9fa5			; 
9fa5			;  
9fa5			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fa5			; 2DUP 2DROP 2SWAP  
9fa5			; @ C@ - get byte  
9fa5			; ! C! - store byte 
9fa5			; 0< true if less than zero 
9fa5			; 0= true if zero 
9fa5			; < >  
9fa5			; = true if same 
9fa5			; variables 
9fa5			 
9fa5			 
9fa5			; Hardware specific words I may need 
9fa5			; 
9fa5			; IN OUT  
9fa5			; calls to key util functions 
9fa5			; calls to hardward abstraction stuff 
9fa5			; easy control of frame buffers and lcd i/o 
9fa5			; keyboard  
9fa5			 
9fa5			 
9fa5			;DICT: macro 
9fa5			; op_code, len, word, next 
9fa5			;    word: 
9fa5			;    db op_code 
9fa5			;    ds word zero term 
9fa5			;    dw next 
9fa5			;    endm 
9fa5			 
9fa5			 
9fa5			 
9fa5			 
9fa5			; op code 1 is a flag for user define words which are to be handled differently 
9fa5			 
9fa5			 
9fa5			; 
9fa5			; 
9fa5			;    TODO on entry to a word this should be the expected environment 
9fa5			;    hl - tos value if number then held, if string this is the ptr 
9fa5			;    de -  
9fa5			 
9fa5			 
9fa5			; opcode ranges 
9fa5			; 0 - end of word dict 
9fa5			; 255 - user define words 
9fa5			 
9fa5			sysdict: 
9fa5			include "forth_opcodes.asm" 
9fa5			; op codes for forth keywords 
9fa5			; free to use code 0  
9fa5				OPCODE_HEAP: equ  1 
9fa5				OPCODE_EXEC: equ 2 
9fa5				OPCODE_DUP: equ 3 
9fa5				OPCODE_SWAP: equ 4 
9fa5				OPCODE_COLN: equ 5 
9fa5				OPCODE_SCOLN: equ 6 
9fa5				OPCODE_DROP: equ 7 
9fa5				OPCODE_DUP2: equ 8 
9fa5				OPCODE_DROP2: equ 9 
9fa5				OPCODE_SWAP2: equ 10 
9fa5				OPCODE_AT: equ 11 
9fa5				OPCODE_CAT: equ 12 
9fa5				OPCODE_BANG: equ 13 
9fa5				OPCODE_CBANG: equ 14 
9fa5				OPCODE_SCALL: equ 15 
9fa5				OPCODE_DEPTH: equ 16 
9fa5				OPCODE_OVER: equ 17 
9fa5				OPCODE_PAUSE: equ 18 
9fa5				OPCODE_PAUSES: equ 19 
9fa5				OPCODE_ROT: equ 20 
9fa5			;free to reuse	OPCODE_WORDS: equ 21 
9fa5			        OPCODE_NOT: equ 21 
9fa5				OPCODE_UWORDS: equ 22 
9fa5				OPCODE_BP: equ 23 
9fa5				OPCODE_MONITOR: equ 24  
9fa5				OPCODE_MALLOC: equ 25 
9fa5				OPCODE_FREE: equ 26 
9fa5				OPCODE_LIST: equ 27 
9fa5				OPCODE_FORGET: equ 28 
9fa5				OPCODE_NOP: equ 29 
9fa5				OPCODE_COMO: equ 30 
9fa5				OPCODE_COMC: equ 31 
9fa5			;free to reuse	OPCODE_ENDCORE: equ 32 
9fa5				OPCODE_AFTERSOUND: equ 33 
9fa5				OPCODE_GP2: equ 34 
9fa5				OPCODE_GP3: equ 35 
9fa5				OPCODE_GP4: equ 36 
9fa5				OPCODE_SIN: equ 37 
9fa5				OPCODE_SOUT: equ 38 
9fa5				OPCODE_SPIO: equ 39 
9fa5				OPCODE_SPICEH: equ 40 
9fa5				OPCODE_SPIOb: equ 41 
9fa5				OPCODE_SPII: equ 42 
9fa5				OPCODE_SESEL: equ 43 
9fa5				OPCODE_CARTDEV: equ 44 
9fa5			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fa5				OPCODE_FB: equ 46 
9fa5				OPCODE_EMIT: equ 47 
9fa5				OPCODE_DOTH: equ 48 
9fa5				OPCODE_DOTF: equ 49 
9fa5				OPCODE_DOT: equ 50 
9fa5				OPCODE_CLS: equ 51 
9fa5				OPCODE_DRAW: equ 52 
9fa5				OPCODE_DUMP: equ 53 
9fa5				OPCODE_CDUMP: equ 54 
9fa5				OPCODE_DAT: equ 55 
9fa5				OPCODE_HOME: equ 56 
9fa5				OPCODE_SPACE: equ 57 
9fa5				OPCODE_SPACES: equ 58 
9fa5				OPCODE_SCROLL: equ 59 
9fa5				OPCODE_ATQ: equ 60 
9fa5				OPCODE_AUTODSP: equ 61 
9fa5				OPCODE_MENU: equ 62 
9fa5			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fa5				OPCODE_THEN: equ 64 
9fa5				OPCODE_ELSE: equ 65 
9fa5				OPCODE_DO: equ 66 
9fa5				OPCODE_LOOP: equ 67 
9fa5				OPCODE_I: equ 68 
9fa5				OPCODE_DLOOP: equ 69  
9fa5				OPCODE_REPEAT: equ 70  
9fa5				OPCODE_UNTIL: equ 71 
9fa5				OPCODE_ENDFLOW: equ 72 
9fa5				OPCODE_WAITK: equ 73 
9fa5				OPCODE_ACCEPT: equ 74 
9fa5				OPCODE_EDIT: equ 75 
9fa5			;free to reuse	OPCODE_ENDKEY: equ 76 
9fa5				OPCODE_LZERO: equ 77 
9fa5				OPCODE_TZERO: equ 78 
9fa5				OPCODE_LESS: equ 79 
9fa5				OPCODE_GT: equ 80 
9fa5				OPCODE_EQUAL: equ 81  
9fa5			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fa5				OPCODE_NEG: equ 83 
9fa5				OPCODE_DIV: equ 84 
9fa5				OPCODE_MUL: equ 85 
9fa5				OPCODE_MIN: equ 86 
9fa5				OPCODE_MAX: equ 87 
9fa5				OPCODE_RND16: equ 88 
9fa5				OPCODE_RND8: equ 89 
9fa5				OPCODE_RND: equ 90 
9fa5			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fa5				OPCODE_BYNAME: equ 92 
9fa5				OPCODE_DIR: equ 93 
9fa5				OPCODE_SAVE: equ 94 
9fa5				OPCODE_LOAD: equ 95 
9fa5				OPCODE_BSAVE: equ 96 
9fa5				OPCODE_BLOAD: equ 97 
9fa5				OPCODE_SEO: equ 98  
9fa5				OPCODE_SEI: equ 99 
9fa5				OPCODE_SFREE: equ 100 
9fa5				OPCODE_SIZE: equ 101 
9fa5				OPCODE_CREATE: equ 102 
9fa5				OPCODE_APPEND: equ 103 
9fa5				OPCODE_SDEL: equ 104 
9fa5				OPCODE_OPEN: equ 105 
9fa5				OPCODE_READ: equ 106 
9fa5				OPCODE_EOF: equ 106 
9fa5				OPCODE_FORMAT: equ 107 
9fa5				OPCODE_LABEL: equ 108 
9fa5				OPCODE_LABELS: equ 109 
9fa5			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fa5				OPCODE_UPPER: equ 111 
9fa5				OPCODE_LOWER: equ 112 
9fa5				OPCODE_SUBSTR: equ 113 
9fa5				OPCODE_LEFT: equ 114 
9fa5				OPCODE_RIGHT: equ 115 
9fa5				OPCODE_STR2NUM: equ 116 
9fa5				OPCODE_NUM2STR: equ 117 
9fa5				OPCODE_CONCAT: equ 118 
9fa5				OPCODE_FIND: equ 119 
9fa5				OPCODE_LEN: equ 120 
9fa5				OPCODE_CHAR: equ 121 
9fa5			; free to reuse	OPCODE_STRLEN: equ 122 
9fa5			; free to reuse	OPCODE_ENDSTR: equ 123 
9fa5				OPCODE_V0S: equ 124 
9fa5				OPCODE_V0Q: equ 125 
9fa5				OPCODE_V1S: equ 126 
9fa5				OPCODE_V1Q: equ 127 
9fa5				OPCODE_V2S: equ 128 
9fa5				OPCODE_V2Q: equ 129 
9fa5				OPCODE_V3S: equ 130 
9fa5				OPCODE_V3Q: equ 131 
9fa5			;free to reuse	OPCODE_END: equ 132 
9fa5				OPCODE_ZDUP: equ 133 
9fa5			 
9fa5			; eof 
# End of file forth_opcodes.asm
9fa5			 
9fa5			include "forth_words_core.asm" 
9fa5			 
9fa5			; | ## Core Words 
9fa5			 
9fa5			;if MALLOC_4 
9fa5			 
9fa5			.HEAP: 
9fa5			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fa5 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fa6 e4 9f			dw .EXEC            
9fa8 05				db 4 + 1 
9fa9 .. 00			db "HEAP",0              
9fae				endm 
# End of macro CWHEAD
9fae			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fae			; | | u1 - Current number of bytes in the heap 
9fae			; | | u2 - Remaining bytes left on the heap 
9fae			; | |  
9fae			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fae			 
9fae			 
9fae				if DEBUG_FORTH_WORDS_KEY 
9fae					DMARK "HEP" 
9fae f5				push af  
9faf 3a c3 9f			ld a, (.dmark)  
9fb2 32 6b ee			ld (debug_mark),a  
9fb5 3a c4 9f			ld a, (.dmark+1)  
9fb8 32 6c ee			ld (debug_mark+1),a  
9fbb 3a c5 9f			ld a, (.dmark+2)  
9fbe 32 6d ee			ld (debug_mark+2),a  
9fc1 18 03			jr .pastdmark  
9fc3 ..			.dmark: db "HEP"  
9fc6 f1			.pastdmark: pop af  
9fc7			endm  
# End of macro DMARK
9fc7					CALLMONITOR 
9fc7 cd 6f ee			call debug_vector  
9fca				endm  
# End of macro CALLMONITOR
9fca				endif 
9fca 2a 47 e4			ld hl, (free_list )      
9fcd 11 4c e4			ld de, heap_start 
9fd0			 
9fd0 ed 52			sbc hl, de  
9fd2			 
9fd2 cd a0 9a			call forth_push_numhl 
9fd5			 
9fd5			 
9fd5 ed 5b 47 e4		ld de, (free_list )      
9fd9 21 9c e2			ld hl, heap_end 
9fdc			 
9fdc ed 52			sbc hl, de 
9fde			 
9fde cd a0 9a			call forth_push_numhl 
9fe1				 
9fe1			 
9fe1				 
9fe1			 
9fe1			 
9fe1			 
9fe1				NEXTW 
9fe1 c3 4d 9e			jp macro_next 
9fe4				endm 
# End of macro NEXTW
9fe4			;endif 
9fe4			 
9fe4			.EXEC: 
9fe4			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fe4			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fe4			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fe4			;; > > 
9fe4			;; > >   
9fe4			;	STACKFRAME OFF $5efe $5f9f 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS_KEY 
9fe4			;			DMARK "EXE" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			;	FORTH_DSP_VALUEHL 
9fe4			; 
9fe4			;	FORTH_DSP_POP 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX1" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;;	ld e,(hl) 
9fe4			;;	inc hl 
9fe4			;;	ld d,(hl) 
9fe4			;;	ex de,hl 
9fe4			; 
9fe4			;;		if DEBUG_FORTH_WORDS 
9fe4			;;			DMARK "EX2" 
9fe4			;;			CALLMONITOR 
9fe4			;;		endif 
9fe4			;	push hl 
9fe4			; 
9fe4			;	;ld a, 0 
9fe4			;	;ld a, FORTH_END_BUFFER 
9fe4			;	call strlenz 
9fe4			;	inc hl   ; include zero term to copy 
9fe4			;	inc hl   ; include term 
9fe4			;	inc hl   ; include term 
9fe4			;	ld b,0 
9fe4			;	ld c,l 
9fe4			;	pop hl 
9fe4			;	ld de, execscratch 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX3" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	ldir 
9fe4			; 
9fe4			; 
9fe4			;	ld hl, execscratch 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EXe" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			;	call forthparse 
9fe4			;	call forthexec 
9fe4			;;	call forthexec_cleanup 
9fe4			;;	call forthparse 
9fe4			;;	call forthexec 
9fe4			; 
9fe4			;	STACKFRAMECHK OFF $5efe $5f9f 
9fe4			; 
9fe4			;	; an immediate word so no need to process any more words 
9fe4			;	ret 
9fe4			;	NEXTW 
9fe4			 
9fe4			; dead code - old version  
9fe4			;	FORTH_RSP_NEXT 
9fe4			 
9fe4			;  
9fe4			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fe4			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fe4			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fe4			;	push hl 
9fe4			;	push de 
9fe4			;	push bc 
9fe4			; 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS_KEY 
9fe4			;			DMARK "EXR" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			; 
9fe4			; 
9fe4			;	;v5 FORTH_DSP_VALUE 
9fe4			;	FORTH_DSP_VALUEHL 
9fe4			; 
9fe4			;	; TODO do string type checks 
9fe4			; 
9fe4			;;v5	inc hl   ; skip type 
9fe4			; 
9fe4			;	push hl  ; source code  
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX1" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	ld a, 0 
9fe4			;	call strlent 
9fe4			; 
9fe4			;	inc hl 
9fe4			;	inc hl 
9fe4			;	inc hl 
9fe4			;	inc hl 
9fe4			; 
9fe4			;	push hl    ; size 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX2" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	call malloc 
9fe4			; 
9fe4			;	ex de, hl    ; de now contains malloc area 
9fe4			;	pop bc   	; get byte count 
9fe4			;	pop hl      ; get string to copy 
9fe4			; 
9fe4			;	push de     ; save malloc for free later 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX3" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	ldir       ; duplicate string 
9fe4			; 
9fe4			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fe4			;	 
9fe4			;	; TODO fix the parse would be better than this...  
9fe4			;	ex de, hl 
9fe4			;	dec hl 
9fe4			;	ld a, 0 
9fe4			;	ld (hl), a 
9fe4			;	dec hl 
9fe4			;	ld a, ' ' 
9fe4			;	ld (hl), a 
9fe4			;	dec hl 
9fe4			;	ld (hl), a 
9fe4			; 
9fe4			;	dec hl 
9fe4			;	ld (hl), a 
9fe4			; 
9fe4			; 
9fe4			;	FORTH_DSP_POP  
9fe4			; 
9fe4			;	pop hl     
9fe4			;	push hl    ; save malloc area 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX4" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			;	call forthparse 
9fe4			;	call forthexec 
9fe4			;	 
9fe4			;	pop hl 
9fe4			;	if DEBUG_FORTH_WORDS 
9fe4			;		DMARK "EX5" 
9fe4			;		CALLMONITOR 
9fe4			;	endif 
9fe4			; 
9fe4			;	if FORTH_ENABLE_FREE 
9fe4			;	call free 
9fe4			;	endif 
9fe4			; 
9fe4			;	if DEBUG_FORTH_WORDS 
9fe4			;		DMARK "EX6" 
9fe4			;		CALLMONITOR 
9fe4			;	endif 
9fe4			; 
9fe4			;	pop bc 
9fe4			;	pop de 
9fe4			;	pop hl 
9fe4			;;	FORTH_RSP_POP	  
9fe4			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fe4			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fe4			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fe4			; 
9fe4			;	if DEBUG_FORTH_WORDS 
9fe4			;		DMARK "EX7" 
9fe4			;		CALLMONITOR 
9fe4			;	endif 
9fe4			;	NEXTW 
9fe4			 
9fe4			;.STKEXEC: 
9fe4			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fe4			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fe4			; 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS_KEY 
9fe4			;			DMARK "STX" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			;	FORTH_DSP_VALUEHL 
9fe4			; 
9fe4			;	ld (store_tmp1), hl    ; count 
9fe4			; 
9fe4			;	FORTH_DSP_POP 
9fe4			;.stkexec1: 
9fe4			;	ld hl, (store_tmp1)   ; count 
9fe4			;	ld a, 0 
9fe4			;	cp l 
9fe4			;	ret z 
9fe4			; 
9fe4			;	dec hl 
9fe4			;	ld (store_tmp1), hl    ; count 
9fe4			;	 
9fe4			;	FORTH_DSP_VALUEHL 
9fe4			;	push hl 
9fe4			;	 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EXp" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	FORTH_DSP_POP 
9fe4			; 
9fe4			;	call strlenz 
9fe4			;	inc hl   ; include zero term to copy 
9fe4			;	inc hl   ; include zero term to copy 
9fe4			;	inc hl   ; include zero term to copy 
9fe4			;	ld b,0 
9fe4			;	ld c,l 
9fe4			;	pop hl 
9fe4			;	ld de, execscratch 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EX3" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	ldir 
9fe4			; 
9fe4			; 
9fe4			;	ld hl, execscratch 
9fe4			; 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EXP" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			; 
9fe4			;	call forthparse 
9fe4			;	ld hl, execscratch 
9fe4			;		if DEBUG_FORTH_WORDS 
9fe4			;			DMARK "EXx" 
9fe4			;			CALLMONITOR 
9fe4			;		endif 
9fe4			;	call forthexec 
9fe4			; 
9fe4			;	jp .stkexec1 
9fe4			; 
9fe4			;	ret 
9fe4			 
9fe4			 
9fe4			.DUP: 
9fe4			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fe4 17				db WORD_SYS_CORE+OPCODE_DUP             
9fe5 5a a0			dw .ZDUP            
9fe7 04				db 3 + 1 
9fe8 .. 00			db "DUP",0              
9fec				endm 
# End of macro CWHEAD
9fec			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fec			 
9fec				if DEBUG_FORTH_WORDS_KEY 
9fec					DMARK "DUP" 
9fec f5				push af  
9fed 3a 01 a0			ld a, (.dmark)  
9ff0 32 6b ee			ld (debug_mark),a  
9ff3 3a 02 a0			ld a, (.dmark+1)  
9ff6 32 6c ee			ld (debug_mark+1),a  
9ff9 3a 03 a0			ld a, (.dmark+2)  
9ffc 32 6d ee			ld (debug_mark+2),a  
9fff 18 03			jr .pastdmark  
a001 ..			.dmark: db "DUP"  
a004 f1			.pastdmark: pop af  
a005			endm  
# End of macro DMARK
a005					CALLMONITOR 
a005 cd 6f ee			call debug_vector  
a008				endm  
# End of macro CALLMONITOR
a008				endif 
a008			 
a008				FORTH_DSP 
a008 cd 5d 9c			call macro_forth_dsp 
a00b				endm 
# End of macro FORTH_DSP
a00b			 
a00b 7e				ld a, (HL) 
a00c fe 01			cp DS_TYPE_STR 
a00e 20 25			jr nz, .dupinum 
a010			 
a010				; push another string 
a010			 
a010				FORTH_DSP_VALUEHL     		 
a010 cd 97 9c			call macro_dsp_valuehl 
a013				endm 
# End of macro FORTH_DSP_VALUEHL
a013			 
a013			if DEBUG_FORTH_WORDS 
a013				DMARK "DUs" 
a013 f5				push af  
a014 3a 28 a0			ld a, (.dmark)  
a017 32 6b ee			ld (debug_mark),a  
a01a 3a 29 a0			ld a, (.dmark+1)  
a01d 32 6c ee			ld (debug_mark+1),a  
a020 3a 2a a0			ld a, (.dmark+2)  
a023 32 6d ee			ld (debug_mark+2),a  
a026 18 03			jr .pastdmark  
a028 ..			.dmark: db "DUs"  
a02b f1			.pastdmark: pop af  
a02c			endm  
# End of macro DMARK
a02c				CALLMONITOR 
a02c cd 6f ee			call debug_vector  
a02f				endm  
# End of macro CALLMONITOR
a02f			endif 
a02f cd 0e 9b			call forth_push_str 
a032			 
a032				NEXTW 
a032 c3 4d 9e			jp macro_next 
a035				endm 
# End of macro NEXTW
a035			 
a035			 
a035			.dupinum: 
a035				 
a035			 
a035			 
a035				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a035 cd 97 9c			call macro_dsp_valuehl 
a038				endm 
# End of macro FORTH_DSP_VALUEHL
a038			 
a038			; TODO add floating point number detection 
a038			 
a038			if DEBUG_FORTH_WORDS 
a038				DMARK "DUi" 
a038 f5				push af  
a039 3a 4d a0			ld a, (.dmark)  
a03c 32 6b ee			ld (debug_mark),a  
a03f 3a 4e a0			ld a, (.dmark+1)  
a042 32 6c ee			ld (debug_mark+1),a  
a045 3a 4f a0			ld a, (.dmark+2)  
a048 32 6d ee			ld (debug_mark+2),a  
a04b 18 03			jr .pastdmark  
a04d ..			.dmark: db "DUi"  
a050 f1			.pastdmark: pop af  
a051			endm  
# End of macro DMARK
a051				CALLMONITOR 
a051 cd 6f ee			call debug_vector  
a054				endm  
# End of macro CALLMONITOR
a054			endif 
a054			 
a054 cd a0 9a			call forth_push_numhl 
a057				NEXTW 
a057 c3 4d 9e			jp macro_next 
a05a				endm 
# End of macro NEXTW
a05a			.ZDUP: 
a05a			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a05a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a05b 92 a0			dw .SWAP            
a05d 05				db 4 + 1 
a05e .. 00			db "?DUP",0              
a063				endm 
# End of macro CWHEAD
a063			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a063			 
a063				if DEBUG_FORTH_WORDS_KEY 
a063					DMARK "qDU" 
a063 f5				push af  
a064 3a 78 a0			ld a, (.dmark)  
a067 32 6b ee			ld (debug_mark),a  
a06a 3a 79 a0			ld a, (.dmark+1)  
a06d 32 6c ee			ld (debug_mark+1),a  
a070 3a 7a a0			ld a, (.dmark+2)  
a073 32 6d ee			ld (debug_mark+2),a  
a076 18 03			jr .pastdmark  
a078 ..			.dmark: db "qDU"  
a07b f1			.pastdmark: pop af  
a07c			endm  
# End of macro DMARK
a07c					CALLMONITOR 
a07c cd 6f ee			call debug_vector  
a07f				endm  
# End of macro CALLMONITOR
a07f				endif 
a07f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a07f cd 97 9c			call macro_dsp_valuehl 
a082				endm 
# End of macro FORTH_DSP_VALUEHL
a082			 
a082 e5				push hl 
a083			 
a083				; is it a zero? 
a083			 
a083 3e 00			ld a, 0 
a085 84				add h 
a086 85				add l 
a087			 
a087 e1				pop hl 
a088			 
a088 fe 00			cp 0 
a08a 28 03			jr z, .dup2orig 
a08c			 
a08c			 
a08c cd a0 9a			call forth_push_numhl 
a08f			 
a08f			 
a08f			; TODO add floating point number detection 
a08f			 
a08f			.dup2orig: 
a08f			 
a08f				NEXTW 
a08f c3 4d 9e			jp macro_next 
a092				endm 
# End of macro NEXTW
a092			.SWAP: 
a092			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a092 18				db WORD_SYS_CORE+OPCODE_SWAP             
a093 d1 a0			dw .COLN            
a095 05				db 4 + 1 
a096 .. 00			db "SWAP",0              
a09b				endm 
# End of macro CWHEAD
a09b			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a09b				if DEBUG_FORTH_WORDS_KEY 
a09b					DMARK "SWP" 
a09b f5				push af  
a09c 3a b0 a0			ld a, (.dmark)  
a09f 32 6b ee			ld (debug_mark),a  
a0a2 3a b1 a0			ld a, (.dmark+1)  
a0a5 32 6c ee			ld (debug_mark+1),a  
a0a8 3a b2 a0			ld a, (.dmark+2)  
a0ab 32 6d ee			ld (debug_mark+2),a  
a0ae 18 03			jr .pastdmark  
a0b0 ..			.dmark: db "SWP"  
a0b3 f1			.pastdmark: pop af  
a0b4			endm  
# End of macro DMARK
a0b4					CALLMONITOR 
a0b4 cd 6f ee			call debug_vector  
a0b7				endm  
# End of macro CALLMONITOR
a0b7				endif 
a0b7			 
a0b7			; TODO Use os stack swap memory 
a0b7				FORTH_DSP_VALUEHL 
a0b7 cd 97 9c			call macro_dsp_valuehl 
a0ba				endm 
# End of macro FORTH_DSP_VALUEHL
a0ba e5				push hl     ; w2 
a0bb			 
a0bb				FORTH_DSP_POP 
a0bb cd 4f 9d			call macro_forth_dsp_pop 
a0be				endm 
# End of macro FORTH_DSP_POP
a0be			 
a0be				FORTH_DSP_VALUEHL 
a0be cd 97 9c			call macro_dsp_valuehl 
a0c1				endm 
# End of macro FORTH_DSP_VALUEHL
a0c1			 
a0c1				FORTH_DSP_POP 
a0c1 cd 4f 9d			call macro_forth_dsp_pop 
a0c4				endm 
# End of macro FORTH_DSP_POP
a0c4			 
a0c4 d1				pop de     ; w2	, hl = w1 
a0c5			 
a0c5 eb				ex de, hl 
a0c6 d5				push de 
a0c7			 
a0c7 cd a0 9a			call forth_push_numhl 
a0ca			 
a0ca e1				pop hl 
a0cb			 
a0cb cd a0 9a			call forth_push_numhl 
a0ce				 
a0ce			 
a0ce				NEXTW 
a0ce c3 4d 9e			jp macro_next 
a0d1				endm 
# End of macro NEXTW
a0d1			.COLN: 
a0d1			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0d1 19				db WORD_SYS_CORE+OPCODE_COLN             
a0d2 5d a2			dw .SCOLN            
a0d4 02				db 1 + 1 
a0d5 .. 00			db ":",0              
a0d7				endm 
# End of macro CWHEAD
a0d7			; | : ( -- )         Create new word | DONE 
a0d7			 
a0d7				if DEBUG_FORTH_WORDS_KEY 
a0d7					DMARK "CLN" 
a0d7 f5				push af  
a0d8 3a ec a0			ld a, (.dmark)  
a0db 32 6b ee			ld (debug_mark),a  
a0de 3a ed a0			ld a, (.dmark+1)  
a0e1 32 6c ee			ld (debug_mark+1),a  
a0e4 3a ee a0			ld a, (.dmark+2)  
a0e7 32 6d ee			ld (debug_mark+2),a  
a0ea 18 03			jr .pastdmark  
a0ec ..			.dmark: db "CLN"  
a0ef f1			.pastdmark: pop af  
a0f0			endm  
# End of macro DMARK
a0f0					CALLMONITOR 
a0f0 cd 6f ee			call debug_vector  
a0f3				endm  
# End of macro CALLMONITOR
a0f3				endif 
a0f3			STACKFRAME OFF $8efe $989f 
a0f3				if DEBUG_STACK_IMB 
a0f3					if OFF 
a0f3						exx 
a0f3						ld de, $8efe 
a0f3						ld a, d 
a0f3						ld hl, curframe 
a0f3						call hexout 
a0f3						ld a, e 
a0f3						ld hl, curframe+2 
a0f3						call hexout 
a0f3						ld hl, $8efe 
a0f3						push hl 
a0f3						ld hl, $989f 
a0f3						push hl 
a0f3						exx 
a0f3					endif 
a0f3				endif 
a0f3			endm 
# End of macro STACKFRAME
a0f3			; get parser buffer length  of new word 
a0f3			 
a0f3			 
a0f3			 
a0f3				; move tok past this to start of name defintition 
a0f3				; TODO get word to define 
a0f3				; TODO Move past word token 
a0f3				; TODO get length of string up to the ';' 
a0f3			 
a0f3 2a c2 e5		ld hl, (os_tok_ptr) 
a0f6 23			inc hl 
a0f7 23			inc hl 
a0f8			 
a0f8 3e 3b		ld a, ';' 
a0fa cd 9d 90		call strlent 
a0fd			 
a0fd 7d			ld a,l 
a0fe 32 b1 e2		ld (os_new_parse_len), a 
a101			 
a101			 
a101			if DEBUG_FORTH_UWORD 
a101 ed 5b c2 e5	ld de, (os_tok_ptr) 
a105					DMARK ":01" 
a105 f5				push af  
a106 3a 1a a1			ld a, (.dmark)  
a109 32 6b ee			ld (debug_mark),a  
a10c 3a 1b a1			ld a, (.dmark+1)  
a10f 32 6c ee			ld (debug_mark+1),a  
a112 3a 1c a1			ld a, (.dmark+2)  
a115 32 6d ee			ld (debug_mark+2),a  
a118 18 03			jr .pastdmark  
a11a ..			.dmark: db ":01"  
a11d f1			.pastdmark: pop af  
a11e			endm  
# End of macro DMARK
a11e			CALLMONITOR 
a11e cd 6f ee			call debug_vector  
a121				endm  
# End of macro CALLMONITOR
a121			endif 
a121			 
a121			; 
a121			;  new word memory layout: 
a121			;  
a121			;    : adg 6666 ;  
a121			; 
a121			;    db   1     ; user defined word  
a121 23			inc hl    
a122			;    dw   sysdict 
a122 23			inc hl 
a123 23			inc hl 
a124			;    db <word len>+1 (for null) 
a124 23			inc hl 
a125			;    db .... <word> 
a125			; 
a125			 
a125 23			inc hl    ; some extras for the word preamble before the above 
a126 23			inc hl 
a127 23			inc hl 
a128 23			inc hl 
a129 23			inc hl 
a12a 23			inc hl 
a12b 23			inc hl  
a12c 23			inc hl 
a12d 23			inc hl 
a12e 23			inc hl 
a12f 23			inc hl 
a130 23			inc hl 
a131 23			inc hl 
a132 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a133			;       exec word buffer 
a133			;	<ptr word>   
a133 23			inc hl 
a134 23			inc hl 
a135			;       <word list><null term> 7F final term 
a135			 
a135			 
a135			if DEBUG_FORTH_UWORD 
a135					DMARK ":02" 
a135 f5				push af  
a136 3a 4a a1			ld a, (.dmark)  
a139 32 6b ee			ld (debug_mark),a  
a13c 3a 4b a1			ld a, (.dmark+1)  
a13f 32 6c ee			ld (debug_mark+1),a  
a142 3a 4c a1			ld a, (.dmark+2)  
a145 32 6d ee			ld (debug_mark+2),a  
a148 18 03			jr .pastdmark  
a14a ..			.dmark: db ":02"  
a14d f1			.pastdmark: pop af  
a14e			endm  
# End of macro DMARK
a14e			CALLMONITOR 
a14e cd 6f ee			call debug_vector  
a151				endm  
# End of macro CALLMONITOR
a151			endif 
a151			 
a151			 
a151				; malloc the size 
a151			 
a151 cd 07 91			call malloc 
a154 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a157			 
a157			;    db   1     ; user defined word  
a157 3e 01			ld a, WORD_SYS_UWORD  
a159 77				ld (hl), a 
a15a			 
a15a 23			inc hl    
a15b			;    dw   sysdict 
a15b 11 a5 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a15e 73			ld (hl), e 
a15f 23			inc hl 
a160 72			ld (hl), d 
a161 23			inc hl 
a162			 
a162			 
a162			;    Setup dict word 
a162			 
a162 23			inc hl 
a163 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a166			 
a166			; 1. get length of dict word 
a166			 
a166			 
a166 2a c2 e5		ld hl, (os_tok_ptr) 
a169 23			inc hl 
a16a 23			inc hl    ; position to start of dict word 
a16b 3e 00		ld a, 0 
a16d cd 9d 90		call strlent 
a170			 
a170			 
a170 23			inc hl    ; to include null??? 
a171			 
a171			; write length of dict word 
a171			 
a171 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a175 1b			dec de 
a176 eb			ex de, hl 
a177 73			ld (hl), e 
a178 eb			ex de, hl 
a179			 
a179			 
a179			 
a179			; copy  
a179 4d			ld c, l 
a17a 06 00		ld b, 0 
a17c ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a180 2a c2 e5		ld hl, (os_tok_ptr) 
a183 23			inc hl 
a184 23			inc hl    ; position to start of dict word 
a185			 
a185			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a185			 
a185			; TODO need to convert word to upper case 
a185			 
a185			ucasetok:	 
a185 7e			ld a,(hl) 
a186 cd 89 90		call toUpper 
a189 77			ld (hl),a 
a18a ed a0		ldi 
a18c f2 85 a1		jp p, ucasetok 
a18f			 
a18f			 
a18f			 
a18f			; de now points to start of where the word body code should be placed 
a18f ed 53 ad e2	ld (os_new_work_ptr), de 
a193			; hl now points to the words to throw at forthexec which needs to be copied 
a193 22 ab e2		ld (os_new_src_ptr), hl 
a196			 
a196			; TODO add 'call to forthexec' 
a196			 
a196			if DEBUG_FORTH_UWORD 
a196 c5			push bc 
a197 ed 4b b3 e2	ld bc, (os_new_malloc) 
a19b					DMARK ":0x" 
a19b f5				push af  
a19c 3a b0 a1			ld a, (.dmark)  
a19f 32 6b ee			ld (debug_mark),a  
a1a2 3a b1 a1			ld a, (.dmark+1)  
a1a5 32 6c ee			ld (debug_mark+1),a  
a1a8 3a b2 a1			ld a, (.dmark+2)  
a1ab 32 6d ee			ld (debug_mark+2),a  
a1ae 18 03			jr .pastdmark  
a1b0 ..			.dmark: db ":0x"  
a1b3 f1			.pastdmark: pop af  
a1b4			endm  
# End of macro DMARK
a1b4			CALLMONITOR 
a1b4 cd 6f ee			call debug_vector  
a1b7				endm  
# End of macro CALLMONITOR
a1b7 c1			pop bc 
a1b8			endif 
a1b8			 
a1b8			 
a1b8			; create word preamble which should be: 
a1b8			 
a1b8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1b8			 
a1b8			;    ld hl, <word code> 
a1b8			;    jp user_exec 
a1b8			;    <word code bytes> 
a1b8			 
a1b8			 
a1b8			;	inc de     ; TODO ??? or are we already past the word's null 
a1b8 eb			ex de, hl 
a1b9			 
a1b9 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1bb			 
a1bb 23			inc hl 
a1bc 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1bf 23			inc hl 
a1c0			 
a1c0 23			inc hl 
a1c1 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1c3			 
a1c3 01 3b cb		ld bc, user_exec 
a1c6 23			inc hl 
a1c7 71			ld (hl), c     ; poke address of user_exec 
a1c8 23			inc hl 
a1c9 70			ld (hl), b     
a1ca			; 
a1ca			;	inc hl 
a1ca			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1ca			; 
a1ca			; 
a1ca			;	ld bc, macro_forth_rsp_next 
a1ca			;	inc hl 
a1ca			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1ca			;	inc hl 
a1ca			;	ld (hl), b     
a1ca			; 
a1ca			;	inc hl 
a1ca			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1ca			; 
a1ca			; 
a1ca			;	inc hl 
a1ca			;	ld bc, forthexec 
a1ca			;	ld (hl), c     ; poke address of forthexec 
a1ca			;	inc hl 
a1ca			;	ld (hl), b      
a1ca			; 
a1ca			;	inc hl 
a1ca			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1ca			; 
a1ca			;	ld bc, user_dict_next 
a1ca			;	inc hl 
a1ca			;	ld (hl), c     ; poke address of forthexec 
a1ca			;	inc hl 
a1ca			;	ld (hl), b      
a1ca			 
a1ca			; hl is now where we need to copy the word byte data to save this 
a1ca			 
a1ca 23			inc hl 
a1cb 22 a9 e2		ld (os_new_exec), hl 
a1ce			 
a1ce			; copy definition 
a1ce			 
a1ce eb			ex de, hl 
a1cf			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1cf			;	inc de    ; skip the PC for this parse 
a1cf 3a b1 e2		ld a, (os_new_parse_len) 
a1d2 4f			ld c, a 
a1d3 06 00		ld b, 0 
a1d5 ed b0		ldir		 ; copy defintion 
a1d7			 
a1d7			 
a1d7			; poke the address of where the new word bytes live for forthexec 
a1d7			 
a1d7 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1da			 
a1da ed 5b a9 e2	ld de, (os_new_exec)      
a1de			 
a1de 73			ld (hl), e 
a1df 23			inc hl 
a1e0 72			ld (hl), d 
a1e1			 
a1e1				; TODO copy last user dict word next link to this word 
a1e1				; TODO update last user dict word to point to this word 
a1e1			; 
a1e1			; hl f923 de 812a ; bc 811a 
a1e1			 
a1e1			if DEBUG_FORTH_UWORD 
a1e1 c5			push bc 
a1e2 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1e6					DMARK ":0A" 
a1e6 f5				push af  
a1e7 3a fb a1			ld a, (.dmark)  
a1ea 32 6b ee			ld (debug_mark),a  
a1ed 3a fc a1			ld a, (.dmark+1)  
a1f0 32 6c ee			ld (debug_mark+1),a  
a1f3 3a fd a1			ld a, (.dmark+2)  
a1f6 32 6d ee			ld (debug_mark+2),a  
a1f9 18 03			jr .pastdmark  
a1fb ..			.dmark: db ":0A"  
a1fe f1			.pastdmark: pop af  
a1ff			endm  
# End of macro DMARK
a1ff			CALLMONITOR 
a1ff cd 6f ee			call debug_vector  
a202				endm  
# End of macro CALLMONITOR
a202 c1			pop bc 
a203			endif 
a203			if DEBUG_FORTH_UWORD 
a203 c5			push bc 
a204 ed 4b b3 e2	ld bc, (os_new_malloc) 
a208 03			inc bc 
a209 03			inc bc 
a20a 03			inc bc 
a20b 03			inc bc 
a20c 03			inc bc 
a20d 03			inc bc 
a20e 03			inc bc 
a20f 03			inc bc 
a210			 
a210					DMARK ":0B" 
a210 f5				push af  
a211 3a 25 a2			ld a, (.dmark)  
a214 32 6b ee			ld (debug_mark),a  
a217 3a 26 a2			ld a, (.dmark+1)  
a21a 32 6c ee			ld (debug_mark+1),a  
a21d 3a 27 a2			ld a, (.dmark+2)  
a220 32 6d ee			ld (debug_mark+2),a  
a223 18 03			jr .pastdmark  
a225 ..			.dmark: db ":0B"  
a228 f1			.pastdmark: pop af  
a229			endm  
# End of macro DMARK
a229			CALLMONITOR 
a229 cd 6f ee			call debug_vector  
a22c				endm  
# End of macro CALLMONITOR
a22c c1			pop bc 
a22d			endif 
a22d			 
a22d			; update word dict linked list for new word 
a22d			 
a22d			 
a22d 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a230 23			inc hl     ; move to next work linked list ptr 
a231			 
a231 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a235 73			ld (hl), e 
a236 23			inc hl 
a237 72			ld (hl), d 
a238			 
a238			if DEBUG_FORTH_UWORD 
a238 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a23c			endif 
a23c			 
a23c ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a240			 
a240			 
a240			if DEBUG_FORTH_UWORD 
a240					DMARK ":0+" 
a240 f5				push af  
a241 3a 55 a2			ld a, (.dmark)  
a244 32 6b ee			ld (debug_mark),a  
a247 3a 56 a2			ld a, (.dmark+1)  
a24a 32 6c ee			ld (debug_mark+1),a  
a24d 3a 57 a2			ld a, (.dmark+2)  
a250 32 6d ee			ld (debug_mark+2),a  
a253 18 03			jr .pastdmark  
a255 ..			.dmark: db ":0+"  
a258 f1			.pastdmark: pop af  
a259			endm  
# End of macro DMARK
a259			CALLMONITOR 
a259 cd 6f ee			call debug_vector  
a25c				endm  
# End of macro CALLMONITOR
a25c			endif 
a25c			 
a25c			STACKFRAMECHK OFF $8efe $989f 
a25c				if DEBUG_STACK_IMB 
a25c					if OFF 
a25c						exx 
a25c						ld hl, $989f 
a25c						pop de   ; $989f 
a25c						call cmp16 
a25c						jr nz, .spnosame 
a25c						ld hl, $8efe 
a25c						pop de   ; $8efe 
a25c						call cmp16 
a25c						jr z, .spfrsame 
a25c						.spnosame: call showsperror 
a25c						.spfrsame: nop 
a25c						exx 
a25c					endif 
a25c				endif 
a25c			endm 
# End of macro STACKFRAMECHK
a25c			 
a25c c9			ret    ; dont process any remaining parser tokens as they form new word 
a25d			 
a25d			 
a25d			 
a25d			 
a25d			;		NEXT 
a25d			.SCOLN: 
a25d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a25d 06			db OPCODE_SCOLN 
a25e a9 a2		dw .DROP 
a260 02			db 2 
a261 .. 00		db ";",0           
a263			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a263				if DEBUG_FORTH_WORDS_KEY 
a263					DMARK "SCN" 
a263 f5				push af  
a264 3a 78 a2			ld a, (.dmark)  
a267 32 6b ee			ld (debug_mark),a  
a26a 3a 79 a2			ld a, (.dmark+1)  
a26d 32 6c ee			ld (debug_mark+1),a  
a270 3a 7a a2			ld a, (.dmark+2)  
a273 32 6d ee			ld (debug_mark+2),a  
a276 18 03			jr .pastdmark  
a278 ..			.dmark: db "SCN"  
a27b f1			.pastdmark: pop af  
a27c			endm  
# End of macro DMARK
a27c					CALLMONITOR 
a27c cd 6f ee			call debug_vector  
a27f				endm  
# End of macro CALLMONITOR
a27f				endif 
a27f				FORTH_RSP_TOS 
a27f cd 5e 9a			call macro_forth_rsp_tos 
a282				endm 
# End of macro FORTH_RSP_TOS
a282 e5				push hl 
a283				FORTH_RSP_POP 
a283 cd 68 9a			call macro_forth_rsp_pop 
a286				endm 
# End of macro FORTH_RSP_POP
a286 e1				pop hl 
a287			;		ex de,hl 
a287 22 c2 e5			ld (os_tok_ptr),hl 
a28a			 
a28a			if DEBUG_FORTH_UWORD 
a28a					DMARK "SCL" 
a28a f5				push af  
a28b 3a 9f a2			ld a, (.dmark)  
a28e 32 6b ee			ld (debug_mark),a  
a291 3a a0 a2			ld a, (.dmark+1)  
a294 32 6c ee			ld (debug_mark+1),a  
a297 3a a1 a2			ld a, (.dmark+2)  
a29a 32 6d ee			ld (debug_mark+2),a  
a29d 18 03			jr .pastdmark  
a29f ..			.dmark: db "SCL"  
a2a2 f1			.pastdmark: pop af  
a2a3			endm  
# End of macro DMARK
a2a3			CALLMONITOR 
a2a3 cd 6f ee			call debug_vector  
a2a6				endm  
# End of macro CALLMONITOR
a2a6			endif 
a2a6				NEXTW 
a2a6 c3 4d 9e			jp macro_next 
a2a9				endm 
# End of macro NEXTW
a2a9			 
a2a9			.DROP: 
a2a9			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2a9 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2aa d4 a2			dw .DUP2            
a2ac 05				db 4 + 1 
a2ad .. 00			db "DROP",0              
a2b2				endm 
# End of macro CWHEAD
a2b2			; | DROP ( w -- )   drop the TOS item   | DONE 
a2b2				if DEBUG_FORTH_WORDS_KEY 
a2b2					DMARK "DRP" 
a2b2 f5				push af  
a2b3 3a c7 a2			ld a, (.dmark)  
a2b6 32 6b ee			ld (debug_mark),a  
a2b9 3a c8 a2			ld a, (.dmark+1)  
a2bc 32 6c ee			ld (debug_mark+1),a  
a2bf 3a c9 a2			ld a, (.dmark+2)  
a2c2 32 6d ee			ld (debug_mark+2),a  
a2c5 18 03			jr .pastdmark  
a2c7 ..			.dmark: db "DRP"  
a2ca f1			.pastdmark: pop af  
a2cb			endm  
# End of macro DMARK
a2cb					CALLMONITOR 
a2cb cd 6f ee			call debug_vector  
a2ce				endm  
# End of macro CALLMONITOR
a2ce				endif 
a2ce				FORTH_DSP_POP 
a2ce cd 4f 9d			call macro_forth_dsp_pop 
a2d1				endm 
# End of macro FORTH_DSP_POP
a2d1				NEXTW 
a2d1 c3 4d 9e			jp macro_next 
a2d4				endm 
# End of macro NEXTW
a2d4			.DUP2: 
a2d4			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2d4 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2d5 19 a3			dw .DROP2            
a2d7 05				db 4 + 1 
a2d8 .. 00			db "2DUP",0              
a2dd				endm 
# End of macro CWHEAD
a2dd			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a2dd				if DEBUG_FORTH_WORDS_KEY 
a2dd					DMARK "2DU" 
a2dd f5				push af  
a2de 3a f2 a2			ld a, (.dmark)  
a2e1 32 6b ee			ld (debug_mark),a  
a2e4 3a f3 a2			ld a, (.dmark+1)  
a2e7 32 6c ee			ld (debug_mark+1),a  
a2ea 3a f4 a2			ld a, (.dmark+2)  
a2ed 32 6d ee			ld (debug_mark+2),a  
a2f0 18 03			jr .pastdmark  
a2f2 ..			.dmark: db "2DU"  
a2f5 f1			.pastdmark: pop af  
a2f6			endm  
# End of macro DMARK
a2f6					CALLMONITOR 
a2f6 cd 6f ee			call debug_vector  
a2f9				endm  
# End of macro CALLMONITOR
a2f9				endif 
a2f9				FORTH_DSP_VALUEHL 
a2f9 cd 97 9c			call macro_dsp_valuehl 
a2fc				endm 
# End of macro FORTH_DSP_VALUEHL
a2fc e5				push hl      ; 2 
a2fd			 
a2fd				FORTH_DSP_POP 
a2fd cd 4f 9d			call macro_forth_dsp_pop 
a300				endm 
# End of macro FORTH_DSP_POP
a300				 
a300				FORTH_DSP_VALUEHL 
a300 cd 97 9c			call macro_dsp_valuehl 
a303				endm 
# End of macro FORTH_DSP_VALUEHL
a303			;		push hl      ; 1 
a303			 
a303				FORTH_DSP_POP 
a303 cd 4f 9d			call macro_forth_dsp_pop 
a306				endm 
# End of macro FORTH_DSP_POP
a306			 
a306			;		pop hl       ; 1 
a306 d1				pop de       ; 2 
a307			 
a307 cd a0 9a			call forth_push_numhl 
a30a eb				ex de, hl 
a30b cd a0 9a			call forth_push_numhl 
a30e			 
a30e				 
a30e eb				ex de, hl 
a30f			 
a30f cd a0 9a			call forth_push_numhl 
a312 eb				ex de, hl 
a313 cd a0 9a			call forth_push_numhl 
a316			 
a316			 
a316				NEXTW 
a316 c3 4d 9e			jp macro_next 
a319				endm 
# End of macro NEXTW
a319			.DROP2: 
a319			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a319 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a31a 48 a3			dw .SWAP2            
a31c 06				db 5 + 1 
a31d .. 00			db "2DROP",0              
a323				endm 
# End of macro CWHEAD
a323			; | 2DROP ( w w -- )    Double drop | DONE 
a323				if DEBUG_FORTH_WORDS_KEY 
a323					DMARK "2DR" 
a323 f5				push af  
a324 3a 38 a3			ld a, (.dmark)  
a327 32 6b ee			ld (debug_mark),a  
a32a 3a 39 a3			ld a, (.dmark+1)  
a32d 32 6c ee			ld (debug_mark+1),a  
a330 3a 3a a3			ld a, (.dmark+2)  
a333 32 6d ee			ld (debug_mark+2),a  
a336 18 03			jr .pastdmark  
a338 ..			.dmark: db "2DR"  
a33b f1			.pastdmark: pop af  
a33c			endm  
# End of macro DMARK
a33c					CALLMONITOR 
a33c cd 6f ee			call debug_vector  
a33f				endm  
# End of macro CALLMONITOR
a33f				endif 
a33f				FORTH_DSP_POP 
a33f cd 4f 9d			call macro_forth_dsp_pop 
a342				endm 
# End of macro FORTH_DSP_POP
a342				FORTH_DSP_POP 
a342 cd 4f 9d			call macro_forth_dsp_pop 
a345				endm 
# End of macro FORTH_DSP_POP
a345				NEXTW 
a345 c3 4d 9e			jp macro_next 
a348				endm 
# End of macro NEXTW
a348			.SWAP2: 
a348			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a348 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a349 71 a3			dw .AT            
a34b 06				db 5 + 1 
a34c .. 00			db "2SWAP",0              
a352				endm 
# End of macro CWHEAD
a352			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a352				if DEBUG_FORTH_WORDS_KEY 
a352					DMARK "2SW" 
a352 f5				push af  
a353 3a 67 a3			ld a, (.dmark)  
a356 32 6b ee			ld (debug_mark),a  
a359 3a 68 a3			ld a, (.dmark+1)  
a35c 32 6c ee			ld (debug_mark+1),a  
a35f 3a 69 a3			ld a, (.dmark+2)  
a362 32 6d ee			ld (debug_mark+2),a  
a365 18 03			jr .pastdmark  
a367 ..			.dmark: db "2SW"  
a36a f1			.pastdmark: pop af  
a36b			endm  
# End of macro DMARK
a36b					CALLMONITOR 
a36b cd 6f ee			call debug_vector  
a36e				endm  
# End of macro CALLMONITOR
a36e				endif 
a36e			; TODO Use os stack swap memory 
a36e				NEXTW 
a36e c3 4d 9e			jp macro_next 
a371				endm 
# End of macro NEXTW
a371			.AT: 
a371			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a371 1f				db WORD_SYS_CORE+OPCODE_AT             
a372 a3 a3			dw .CAT            
a374 02				db 1 + 1 
a375 .. 00			db "@",0              
a377				endm 
# End of macro CWHEAD
a377			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a377			 
a377				if DEBUG_FORTH_WORDS_KEY 
a377					DMARK "AT." 
a377 f5				push af  
a378 3a 8c a3			ld a, (.dmark)  
a37b 32 6b ee			ld (debug_mark),a  
a37e 3a 8d a3			ld a, (.dmark+1)  
a381 32 6c ee			ld (debug_mark+1),a  
a384 3a 8e a3			ld a, (.dmark+2)  
a387 32 6d ee			ld (debug_mark+2),a  
a38a 18 03			jr .pastdmark  
a38c ..			.dmark: db "AT."  
a38f f1			.pastdmark: pop af  
a390			endm  
# End of macro DMARK
a390					CALLMONITOR 
a390 cd 6f ee			call debug_vector  
a393				endm  
# End of macro CALLMONITOR
a393				endif 
a393			.getbyteat:	 
a393				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a393 cd 97 9c			call macro_dsp_valuehl 
a396				endm 
# End of macro FORTH_DSP_VALUEHL
a396				 
a396			;		push hl 
a396			 
a396				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a396 cd 4f 9d			call macro_forth_dsp_pop 
a399				endm 
# End of macro FORTH_DSP_POP
a399			 
a399			;		pop hl 
a399			 
a399 7e				ld a, (hl) 
a39a			 
a39a 6f				ld l, a 
a39b 26 00			ld h, 0 
a39d cd a0 9a			call forth_push_numhl 
a3a0			 
a3a0				NEXTW 
a3a0 c3 4d 9e			jp macro_next 
a3a3				endm 
# End of macro NEXTW
a3a3			.CAT: 
a3a3			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a3a3 20				db WORD_SYS_CORE+OPCODE_CAT             
a3a4 cc a3			dw .BANG            
a3a6 03				db 2 + 1 
a3a7 .. 00			db "C@",0              
a3aa				endm 
# End of macro CWHEAD
a3aa			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a3aa				if DEBUG_FORTH_WORDS_KEY 
a3aa					DMARK "CAA" 
a3aa f5				push af  
a3ab 3a bf a3			ld a, (.dmark)  
a3ae 32 6b ee			ld (debug_mark),a  
a3b1 3a c0 a3			ld a, (.dmark+1)  
a3b4 32 6c ee			ld (debug_mark+1),a  
a3b7 3a c1 a3			ld a, (.dmark+2)  
a3ba 32 6d ee			ld (debug_mark+2),a  
a3bd 18 03			jr .pastdmark  
a3bf ..			.dmark: db "CAA"  
a3c2 f1			.pastdmark: pop af  
a3c3			endm  
# End of macro DMARK
a3c3					CALLMONITOR 
a3c3 cd 6f ee			call debug_vector  
a3c6				endm  
# End of macro CALLMONITOR
a3c6				endif 
a3c6 c3 93 a3			jp .getbyteat 
a3c9				NEXTW 
a3c9 c3 4d 9e			jp macro_next 
a3cc				endm 
# End of macro NEXTW
a3cc			.BANG: 
a3cc			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a3cc 21				db WORD_SYS_CORE+OPCODE_BANG             
a3cd 02 a4			dw .CBANG            
a3cf 02				db 1 + 1 
a3d0 .. 00			db "!",0              
a3d2				endm 
# End of macro CWHEAD
a3d2			; | ! ( x w -- ) Store x at address w      | DONE 
a3d2				if DEBUG_FORTH_WORDS_KEY 
a3d2					DMARK "BNG" 
a3d2 f5				push af  
a3d3 3a e7 a3			ld a, (.dmark)  
a3d6 32 6b ee			ld (debug_mark),a  
a3d9 3a e8 a3			ld a, (.dmark+1)  
a3dc 32 6c ee			ld (debug_mark+1),a  
a3df 3a e9 a3			ld a, (.dmark+2)  
a3e2 32 6d ee			ld (debug_mark+2),a  
a3e5 18 03			jr .pastdmark  
a3e7 ..			.dmark: db "BNG"  
a3ea f1			.pastdmark: pop af  
a3eb			endm  
# End of macro DMARK
a3eb					CALLMONITOR 
a3eb cd 6f ee			call debug_vector  
a3ee				endm  
# End of macro CALLMONITOR
a3ee				endif 
a3ee			 
a3ee			.storebyteat:		 
a3ee				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3ee cd 97 9c			call macro_dsp_valuehl 
a3f1				endm 
# End of macro FORTH_DSP_VALUEHL
a3f1				 
a3f1 e5				push hl 
a3f2			 
a3f2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3f2 cd 4f 9d			call macro_forth_dsp_pop 
a3f5				endm 
# End of macro FORTH_DSP_POP
a3f5			 
a3f5				; get byte to poke 
a3f5			 
a3f5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3f5 cd 97 9c			call macro_dsp_valuehl 
a3f8				endm 
# End of macro FORTH_DSP_VALUEHL
a3f8 e5				push hl 
a3f9			 
a3f9			 
a3f9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3f9 cd 4f 9d			call macro_forth_dsp_pop 
a3fc				endm 
# End of macro FORTH_DSP_POP
a3fc			 
a3fc			 
a3fc d1				pop de 
a3fd e1				pop hl 
a3fe			 
a3fe 73				ld (hl),e 
a3ff			 
a3ff			 
a3ff				NEXTW 
a3ff c3 4d 9e			jp macro_next 
a402				endm 
# End of macro NEXTW
a402			.CBANG: 
a402			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a402 22				db WORD_SYS_CORE+OPCODE_CBANG             
a403 2b a4			dw .SCALL            
a405 03				db 2 + 1 
a406 .. 00			db "C!",0              
a409				endm 
# End of macro CWHEAD
a409			; | C!  ( x w -- ) Store x at address w  | DONE 
a409				if DEBUG_FORTH_WORDS_KEY 
a409					DMARK "CBA" 
a409 f5				push af  
a40a 3a 1e a4			ld a, (.dmark)  
a40d 32 6b ee			ld (debug_mark),a  
a410 3a 1f a4			ld a, (.dmark+1)  
a413 32 6c ee			ld (debug_mark+1),a  
a416 3a 20 a4			ld a, (.dmark+2)  
a419 32 6d ee			ld (debug_mark+2),a  
a41c 18 03			jr .pastdmark  
a41e ..			.dmark: db "CBA"  
a421 f1			.pastdmark: pop af  
a422			endm  
# End of macro DMARK
a422					CALLMONITOR 
a422 cd 6f ee			call debug_vector  
a425				endm  
# End of macro CALLMONITOR
a425				endif 
a425 c3 ee a3			jp .storebyteat 
a428				NEXTW 
a428 c3 4d 9e			jp macro_next 
a42b				endm 
# End of macro NEXTW
a42b			.SCALL: 
a42b			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a42b 23				db WORD_SYS_CORE+OPCODE_SCALL             
a42c 5f a4			dw .DEPTH            
a42e 05				db 4 + 1 
a42f .. 00			db "CALL",0              
a434				endm 
# End of macro CWHEAD
a434			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a434				if DEBUG_FORTH_WORDS_KEY 
a434					DMARK "CLL" 
a434 f5				push af  
a435 3a 49 a4			ld a, (.dmark)  
a438 32 6b ee			ld (debug_mark),a  
a43b 3a 4a a4			ld a, (.dmark+1)  
a43e 32 6c ee			ld (debug_mark+1),a  
a441 3a 4b a4			ld a, (.dmark+2)  
a444 32 6d ee			ld (debug_mark+2),a  
a447 18 03			jr .pastdmark  
a449 ..			.dmark: db "CLL"  
a44c f1			.pastdmark: pop af  
a44d			endm  
# End of macro DMARK
a44d					CALLMONITOR 
a44d cd 6f ee			call debug_vector  
a450				endm  
# End of macro CALLMONITOR
a450				endif 
a450			 
a450				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a450 cd 97 9c			call macro_dsp_valuehl 
a453				endm 
# End of macro FORTH_DSP_VALUEHL
a453			 
a453			;		push hl 
a453			 
a453				; destroy value TOS 
a453			 
a453				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a453 cd 4f 9d			call macro_forth_dsp_pop 
a456				endm 
# End of macro FORTH_DSP_POP
a456			 
a456					 
a456			;		pop hl 
a456			 
a456				; how to do a call with hl???? save SP? 
a456 cd f1 9d			call forth_call_hl 
a459			 
a459			 
a459				; TODO push value back onto stack for another op etc 
a459			 
a459 cd a0 9a			call forth_push_numhl 
a45c				NEXTW 
a45c c3 4d 9e			jp macro_next 
a45f				endm 
# End of macro NEXTW
a45f			.DEPTH: 
a45f			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a45f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a460 9c a4			dw .OVER            
a462 06				db 5 + 1 
a463 .. 00			db "DEPTH",0              
a469				endm 
# End of macro CWHEAD
a469			; | DEPTH ( -- u ) Push count of stack | DONE 
a469				; take current TOS and remove from base value div by two to get count 
a469				if DEBUG_FORTH_WORDS_KEY 
a469					DMARK "DEP" 
a469 f5				push af  
a46a 3a 7e a4			ld a, (.dmark)  
a46d 32 6b ee			ld (debug_mark),a  
a470 3a 7f a4			ld a, (.dmark+1)  
a473 32 6c ee			ld (debug_mark+1),a  
a476 3a 80 a4			ld a, (.dmark+2)  
a479 32 6d ee			ld (debug_mark+2),a  
a47c 18 03			jr .pastdmark  
a47e ..			.dmark: db "DEP"  
a481 f1			.pastdmark: pop af  
a482			endm  
# End of macro DMARK
a482					CALLMONITOR 
a482 cd 6f ee			call debug_vector  
a485				endm  
# End of macro CALLMONITOR
a485				endif 
a485			 
a485			 
a485 2a ee e9		ld hl, (cli_data_sp) 
a488 11 28 e8		ld de, cli_data_stack 
a48b ed 52		sbc hl,de 
a48d			 
a48d			; div by size of stack item 
a48d			 
a48d 5d			ld e,l 
a48e 0e 03		ld c, 3 
a490 cd 6b 8c		call Div8 
a493			 
a493 6f			ld l,a 
a494 26 00		ld h,0 
a496			 
a496			;srl h 
a496			;rr l 
a496			 
a496 cd a0 9a			call forth_push_numhl 
a499				NEXTW 
a499 c3 4d 9e			jp macro_next 
a49c				endm 
# End of macro NEXTW
a49c			.OVER: 
a49c			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a49c 42				db WORD_SYS_CORE+46             
a49d e3 a4			dw .PAUSE            
a49f 05				db 4 + 1 
a4a0 .. 00			db "OVER",0              
a4a5				endm 
# End of macro CWHEAD
a4a5			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a4a5				if DEBUG_FORTH_WORDS_KEY 
a4a5					DMARK "OVR" 
a4a5 f5				push af  
a4a6 3a ba a4			ld a, (.dmark)  
a4a9 32 6b ee			ld (debug_mark),a  
a4ac 3a bb a4			ld a, (.dmark+1)  
a4af 32 6c ee			ld (debug_mark+1),a  
a4b2 3a bc a4			ld a, (.dmark+2)  
a4b5 32 6d ee			ld (debug_mark+2),a  
a4b8 18 03			jr .pastdmark  
a4ba ..			.dmark: db "OVR"  
a4bd f1			.pastdmark: pop af  
a4be			endm  
# End of macro DMARK
a4be					CALLMONITOR 
a4be cd 6f ee			call debug_vector  
a4c1				endm  
# End of macro CALLMONITOR
a4c1				endif 
a4c1			 
a4c1			; TODO Use os stack swap memory 
a4c1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c1 cd 97 9c			call macro_dsp_valuehl 
a4c4				endm 
# End of macro FORTH_DSP_VALUEHL
a4c4 e5				push hl    ; n2 
a4c5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c5 cd 4f 9d			call macro_forth_dsp_pop 
a4c8				endm 
# End of macro FORTH_DSP_POP
a4c8			 
a4c8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c8 cd 97 9c			call macro_dsp_valuehl 
a4cb				endm 
# End of macro FORTH_DSP_VALUEHL
a4cb e5				push hl    ; n1 
a4cc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4cc cd 4f 9d			call macro_forth_dsp_pop 
a4cf				endm 
# End of macro FORTH_DSP_POP
a4cf			 
a4cf d1				pop de     ; n1 
a4d0 e1				pop hl     ; n2 
a4d1			 
a4d1 d5				push de 
a4d2 e5				push hl 
a4d3 d5				push de 
a4d4			 
a4d4				; push back  
a4d4			 
a4d4 e1				pop hl 
a4d5 cd a0 9a			call forth_push_numhl 
a4d8 e1				pop hl 
a4d9 cd a0 9a			call forth_push_numhl 
a4dc e1				pop hl 
a4dd cd a0 9a			call forth_push_numhl 
a4e0				NEXTW 
a4e0 c3 4d 9e			jp macro_next 
a4e3				endm 
# End of macro NEXTW
a4e3			 
a4e3			.PAUSE: 
a4e3			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a4e3 43				db WORD_SYS_CORE+47             
a4e4 18 a5			dw .PAUSES            
a4e6 08				db 7 + 1 
a4e7 .. 00			db "PAUSEMS",0              
a4ef				endm 
# End of macro CWHEAD
a4ef			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4ef				if DEBUG_FORTH_WORDS_KEY 
a4ef					DMARK "PMS" 
a4ef f5				push af  
a4f0 3a 04 a5			ld a, (.dmark)  
a4f3 32 6b ee			ld (debug_mark),a  
a4f6 3a 05 a5			ld a, (.dmark+1)  
a4f9 32 6c ee			ld (debug_mark+1),a  
a4fc 3a 06 a5			ld a, (.dmark+2)  
a4ff 32 6d ee			ld (debug_mark+2),a  
a502 18 03			jr .pastdmark  
a504 ..			.dmark: db "PMS"  
a507 f1			.pastdmark: pop af  
a508			endm  
# End of macro DMARK
a508					CALLMONITOR 
a508 cd 6f ee			call debug_vector  
a50b				endm  
# End of macro CALLMONITOR
a50b				endif 
a50b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a50b cd 97 9c			call macro_dsp_valuehl 
a50e				endm 
# End of macro FORTH_DSP_VALUEHL
a50e			;		push hl    ; n2 
a50e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a50e cd 4f 9d			call macro_forth_dsp_pop 
a511				endm 
# End of macro FORTH_DSP_POP
a511			;		pop hl 
a511			 
a511 7d				ld a, l 
a512 cd d6 89			call aDelayInMS 
a515			       NEXTW 
a515 c3 4d 9e			jp macro_next 
a518				endm 
# End of macro NEXTW
a518			.PAUSES:  
a518			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a518 44				db WORD_SYS_CORE+48             
a519 87 a5			dw .ROT            
a51b 06				db 5 + 1 
a51c .. 00			db "PAUSE",0              
a522				endm 
# End of macro CWHEAD
a522			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a522				if DEBUG_FORTH_WORDS_KEY 
a522					DMARK "PAU" 
a522 f5				push af  
a523 3a 37 a5			ld a, (.dmark)  
a526 32 6b ee			ld (debug_mark),a  
a529 3a 38 a5			ld a, (.dmark+1)  
a52c 32 6c ee			ld (debug_mark+1),a  
a52f 3a 39 a5			ld a, (.dmark+2)  
a532 32 6d ee			ld (debug_mark+2),a  
a535 18 03			jr .pastdmark  
a537 ..			.dmark: db "PAU"  
a53a f1			.pastdmark: pop af  
a53b			endm  
# End of macro DMARK
a53b					CALLMONITOR 
a53b cd 6f ee			call debug_vector  
a53e				endm  
# End of macro CALLMONITOR
a53e				endif 
a53e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a53e cd 97 9c			call macro_dsp_valuehl 
a541				endm 
# End of macro FORTH_DSP_VALUEHL
a541			;		push hl    ; n2 
a541				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a541 cd 4f 9d			call macro_forth_dsp_pop 
a544				endm 
# End of macro FORTH_DSP_POP
a544			;		pop hl 
a544 45				ld b, l 
a545				if DEBUG_FORTH_WORDS 
a545					DMARK "PAU" 
a545 f5				push af  
a546 3a 5a a5			ld a, (.dmark)  
a549 32 6b ee			ld (debug_mark),a  
a54c 3a 5b a5			ld a, (.dmark+1)  
a54f 32 6c ee			ld (debug_mark+1),a  
a552 3a 5c a5			ld a, (.dmark+2)  
a555 32 6d ee			ld (debug_mark+2),a  
a558 18 03			jr .pastdmark  
a55a ..			.dmark: db "PAU"  
a55d f1			.pastdmark: pop af  
a55e			endm  
# End of macro DMARK
a55e					CALLMONITOR 
a55e cd 6f ee			call debug_vector  
a561				endm  
# End of macro CALLMONITOR
a561				endif 
a561 c5			.pauses1:	push bc 
a562 cd f1 89			call delay1s 
a565 c1				pop bc 
a566				if DEBUG_FORTH_WORDS 
a566					DMARK "PA1" 
a566 f5				push af  
a567 3a 7b a5			ld a, (.dmark)  
a56a 32 6b ee			ld (debug_mark),a  
a56d 3a 7c a5			ld a, (.dmark+1)  
a570 32 6c ee			ld (debug_mark+1),a  
a573 3a 7d a5			ld a, (.dmark+2)  
a576 32 6d ee			ld (debug_mark+2),a  
a579 18 03			jr .pastdmark  
a57b ..			.dmark: db "PA1"  
a57e f1			.pastdmark: pop af  
a57f			endm  
# End of macro DMARK
a57f					CALLMONITOR 
a57f cd 6f ee			call debug_vector  
a582				endm  
# End of macro CALLMONITOR
a582				endif 
a582 10 dd			djnz .pauses1 
a584			 
a584			       NEXTW 
a584 c3 4d 9e			jp macro_next 
a587				endm 
# End of macro NEXTW
a587			.ROT: 
a587			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a587 45				db WORD_SYS_CORE+49             
a588 d5 a5			dw .UWORDS            
a58a 04				db 3 + 1 
a58b .. 00			db "ROT",0              
a58f				endm 
# End of macro CWHEAD
a58f			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a58f				if DEBUG_FORTH_WORDS_KEY 
a58f					DMARK "ROT" 
a58f f5				push af  
a590 3a a4 a5			ld a, (.dmark)  
a593 32 6b ee			ld (debug_mark),a  
a596 3a a5 a5			ld a, (.dmark+1)  
a599 32 6c ee			ld (debug_mark+1),a  
a59c 3a a6 a5			ld a, (.dmark+2)  
a59f 32 6d ee			ld (debug_mark+2),a  
a5a2 18 03			jr .pastdmark  
a5a4 ..			.dmark: db "ROT"  
a5a7 f1			.pastdmark: pop af  
a5a8			endm  
# End of macro DMARK
a5a8					CALLMONITOR 
a5a8 cd 6f ee			call debug_vector  
a5ab				endm  
# End of macro CALLMONITOR
a5ab				endif 
a5ab			 
a5ab			; TODO Use os stack swap memory 
a5ab				FORTH_DSP_VALUEHL 
a5ab cd 97 9c			call macro_dsp_valuehl 
a5ae				endm 
# End of macro FORTH_DSP_VALUEHL
a5ae e5				push hl    ; u3  
a5af			 
a5af				FORTH_DSP_POP 
a5af cd 4f 9d			call macro_forth_dsp_pop 
a5b2				endm 
# End of macro FORTH_DSP_POP
a5b2			 
a5b2				FORTH_DSP_VALUEHL 
a5b2 cd 97 9c			call macro_dsp_valuehl 
a5b5				endm 
# End of macro FORTH_DSP_VALUEHL
a5b5 e5				push hl     ; u2 
a5b6			 
a5b6				FORTH_DSP_POP 
a5b6 cd 4f 9d			call macro_forth_dsp_pop 
a5b9				endm 
# End of macro FORTH_DSP_POP
a5b9			 
a5b9				FORTH_DSP_VALUEHL 
a5b9 cd 97 9c			call macro_dsp_valuehl 
a5bc				endm 
# End of macro FORTH_DSP_VALUEHL
a5bc e5				push hl     ; u1 
a5bd			 
a5bd				FORTH_DSP_POP 
a5bd cd 4f 9d			call macro_forth_dsp_pop 
a5c0				endm 
# End of macro FORTH_DSP_POP
a5c0			 
a5c0 c1				pop bc      ; u1 
a5c1 e1				pop hl      ; u2 
a5c2 d1				pop de      ; u3 
a5c3			 
a5c3			 
a5c3 c5				push bc 
a5c4 d5				push de 
a5c5 e5				push hl 
a5c6			 
a5c6			 
a5c6 e1				pop hl 
a5c7 cd a0 9a			call forth_push_numhl 
a5ca			 
a5ca e1				pop hl 
a5cb cd a0 9a			call forth_push_numhl 
a5ce			 
a5ce e1				pop hl 
a5cf cd a0 9a			call forth_push_numhl 
a5d2				 
a5d2			 
a5d2			 
a5d2			 
a5d2			 
a5d2			 
a5d2			       NEXTW 
a5d2 c3 4d 9e			jp macro_next 
a5d5				endm 
# End of macro NEXTW
a5d5			 
a5d5			.UWORDS: 
a5d5			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a5d5 50				db WORD_SYS_CORE+60             
a5d6 97 a6			dw .BP            
a5d8 07				db 6 + 1 
a5d9 .. 00			db "UWORDS",0              
a5e0				endm 
# End of macro CWHEAD
a5e0			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a5e0			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a5e0			; | | Following the count are the individual words. 
a5e0			; | | 
a5e0			; | | e.g. UWORDS 
a5e0			; | | BOX DIRLIST 2 
a5e0			; | |  
a5e0			; | | Can be used to save the words to storage via: 
a5e0			; | | UWORDS $01 DO $01 APPEND LOOP 
a5e0			if DEBUG_FORTH_WORDS_KEY 
a5e0				DMARK "UWR" 
a5e0 f5				push af  
a5e1 3a f5 a5			ld a, (.dmark)  
a5e4 32 6b ee			ld (debug_mark),a  
a5e7 3a f6 a5			ld a, (.dmark+1)  
a5ea 32 6c ee			ld (debug_mark+1),a  
a5ed 3a f7 a5			ld a, (.dmark+2)  
a5f0 32 6d ee			ld (debug_mark+2),a  
a5f3 18 03			jr .pastdmark  
a5f5 ..			.dmark: db "UWR"  
a5f8 f1			.pastdmark: pop af  
a5f9			endm  
# End of macro DMARK
a5f9				CALLMONITOR 
a5f9 cd 6f ee			call debug_vector  
a5fc				endm  
# End of macro CALLMONITOR
a5fc			endif 
a5fc 21 3d e4			ld hl, baseram 
a5ff				;ld hl, baseusermem 
a5ff 01 00 00			ld bc, 0    ; start a counter 
a602			 
a602			; skip dict stub 
a602			 
a602 cd 9e 9f			call forth_tok_next 
a605			 
a605			 
a605			; while we have words to look for 
a605			 
a605 7e			.douscan:	ld a, (hl)      
a606			if DEBUG_FORTH_WORDS 
a606				DMARK "UWs" 
a606 f5				push af  
a607 3a 1b a6			ld a, (.dmark)  
a60a 32 6b ee			ld (debug_mark),a  
a60d 3a 1c a6			ld a, (.dmark+1)  
a610 32 6c ee			ld (debug_mark+1),a  
a613 3a 1d a6			ld a, (.dmark+2)  
a616 32 6d ee			ld (debug_mark+2),a  
a619 18 03			jr .pastdmark  
a61b ..			.dmark: db "UWs"  
a61e f1			.pastdmark: pop af  
a61f			endm  
# End of macro DMARK
a61f				CALLMONITOR 
a61f cd 6f ee			call debug_vector  
a622				endm  
# End of macro CALLMONITOR
a622			endif 
a622 fe 00			cp WORD_SYS_END 
a624 28 4d			jr z, .udone 
a626 fe 01			cp WORD_SYS_UWORD 
a628 20 44			jr nz, .nuword 
a62a			 
a62a			if DEBUG_FORTH_WORDS 
a62a				DMARK "UWu" 
a62a f5				push af  
a62b 3a 3f a6			ld a, (.dmark)  
a62e 32 6b ee			ld (debug_mark),a  
a631 3a 40 a6			ld a, (.dmark+1)  
a634 32 6c ee			ld (debug_mark+1),a  
a637 3a 41 a6			ld a, (.dmark+2)  
a63a 32 6d ee			ld (debug_mark+2),a  
a63d 18 03			jr .pastdmark  
a63f ..			.dmark: db "UWu"  
a642 f1			.pastdmark: pop af  
a643			endm  
# End of macro DMARK
a643				CALLMONITOR 
a643 cd 6f ee			call debug_vector  
a646				endm  
# End of macro CALLMONITOR
a646			endif 
a646				; we have a uword so push its name to the stack 
a646			 
a646 e5				push hl  ; save so we can move to next dict block 
a647			 
a647				; skip opcode 
a647 23				inc hl  
a648				; skip next ptr 
a648 23				inc hl  
a649 23				inc hl 
a64a				; skip len 
a64a 23				inc hl 
a64b			if DEBUG_FORTH_WORDS 
a64b				DMARK "UWt" 
a64b f5				push af  
a64c 3a 60 a6			ld a, (.dmark)  
a64f 32 6b ee			ld (debug_mark),a  
a652 3a 61 a6			ld a, (.dmark+1)  
a655 32 6c ee			ld (debug_mark+1),a  
a658 3a 62 a6			ld a, (.dmark+2)  
a65b 32 6d ee			ld (debug_mark+2),a  
a65e 18 03			jr .pastdmark  
a660 ..			.dmark: db "UWt"  
a663 f1			.pastdmark: pop af  
a664			endm  
# End of macro DMARK
a664				CALLMONITOR 
a664 cd 6f ee			call debug_vector  
a667				endm  
# End of macro CALLMONITOR
a667			endif 
a667 03				inc bc 
a668			 
a668 c5				push bc 
a669 cd 0e 9b			call forth_push_str 
a66c c1				pop bc 
a66d			 
a66d e1				pop hl 	 
a66e			 
a66e cd 9e 9f		.nuword:	call forth_tok_next 
a671 18 92			jr .douscan  
a673			 
a673			.udone:		 ; push count of uwords found 
a673 c5				push bc 
a674 e1				pop hl 
a675			 
a675			if DEBUG_FORTH_WORDS 
a675				DMARK "UWc" 
a675 f5				push af  
a676 3a 8a a6			ld a, (.dmark)  
a679 32 6b ee			ld (debug_mark),a  
a67c 3a 8b a6			ld a, (.dmark+1)  
a67f 32 6c ee			ld (debug_mark+1),a  
a682 3a 8c a6			ld a, (.dmark+2)  
a685 32 6d ee			ld (debug_mark+2),a  
a688 18 03			jr .pastdmark  
a68a ..			.dmark: db "UWc"  
a68d f1			.pastdmark: pop af  
a68e			endm  
# End of macro DMARK
a68e				CALLMONITOR 
a68e cd 6f ee			call debug_vector  
a691				endm  
# End of macro CALLMONITOR
a691			endif 
a691 cd a0 9a			call forth_push_numhl 
a694			 
a694			 
a694			       NEXTW 
a694 c3 4d 9e			jp macro_next 
a697				endm 
# End of macro NEXTW
a697			 
a697			.BP: 
a697			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a697 54				db WORD_SYS_CORE+64             
a698 d1 a6			dw .MONITOR            
a69a 03				db 2 + 1 
a69b .. 00			db "BP",0              
a69e				endm 
# End of macro CWHEAD
a69e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a69e			; | | $00 Will enable the break points within specific code paths 
a69e			; | | $01 Will disable break points 
a69e			; | |  
a69e			; | | By default break points are off. Either the above can be used to enable them 
a69e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a69e			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a69e			; | | can disable break points. Exiting will then continue boot process. 
a69e				; get byte count 
a69e				if DEBUG_FORTH_WORDS_KEY 
a69e					DMARK "BP." 
a69e f5				push af  
a69f 3a b3 a6			ld a, (.dmark)  
a6a2 32 6b ee			ld (debug_mark),a  
a6a5 3a b4 a6			ld a, (.dmark+1)  
a6a8 32 6c ee			ld (debug_mark+1),a  
a6ab 3a b5 a6			ld a, (.dmark+2)  
a6ae 32 6d ee			ld (debug_mark+2),a  
a6b1 18 03			jr .pastdmark  
a6b3 ..			.dmark: db "BP."  
a6b6 f1			.pastdmark: pop af  
a6b7			endm  
# End of macro DMARK
a6b7					CALLMONITOR 
a6b7 cd 6f ee			call debug_vector  
a6ba				endm  
# End of macro CALLMONITOR
a6ba				endif 
a6ba			 
a6ba				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ba cd 97 9c			call macro_dsp_valuehl 
a6bd				endm 
# End of macro FORTH_DSP_VALUEHL
a6bd			 
a6bd			;		push hl 
a6bd			 
a6bd				; destroy value TOS 
a6bd			 
a6bd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6bd cd 4f 9d			call macro_forth_dsp_pop 
a6c0				endm 
# End of macro FORTH_DSP_POP
a6c0			 
a6c0			;		pop hl 
a6c0			 
a6c0 3e 00			ld a,0 
a6c2 bd				cp l 
a6c3 28 06			jr z, .bpset 
a6c5			;		ld a, '*' 
a6c5 cd 42 94			call bp_off 
a6c8				NEXTW 
a6c8 c3 4d 9e			jp macro_next 
a6cb				endm 
# End of macro NEXTW
a6cb			 
a6cb			.bpset:	 
a6cb				;	ld (os_view_disable), a 
a6cb cd 36 94			call bp_on 
a6ce			 
a6ce			 
a6ce				NEXTW 
a6ce c3 4d 9e			jp macro_next 
a6d1				endm 
# End of macro NEXTW
a6d1			 
a6d1			 
a6d1			.MONITOR: 
a6d1			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6d1 55				db WORD_SYS_CORE+65             
a6d2 02 a7			dw .MALLOC            
a6d4 08				db 7 + 1 
a6d5 .. 00			db "MONITOR",0              
a6dd				endm 
# End of macro CWHEAD
a6dd			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a6dd			; | | At start the current various registers will be displayed with contents. 
a6dd			; | | Top right corner will show the most recent debug marker seen. 
a6dd			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a6dd			; | | and the return stack pointer (RSP). 
a6dd			; | | Pressing: 
a6dd			; | |    1 - Initial screen 
a6dd			; | |    2 - Display a data dump of HL 
a6dd			; | |    3 - Display a data dump of DE 
a6dd			; | |    4 - Display a data dump of BC 
a6dd			; | |    5 - Display a data dump of HL 
a6dd			; | |    6 - Display a data dump of DSP 
a6dd			; | |    7 - Display a data dump of RSP 
a6dd			; | |    8 - Display a data dump of what is at DSP 
a6dd			; | |    9 - Display a data dump of what is at RSP 
a6dd			; | |    0 - Exit monitor and continue running. This will also enable break points 
a6dd			; | |    * - Disable break points 
a6dd			; | |    # - Enter traditional monitor mode 
a6dd			; | | 
a6dd			; | | Monitor Mode 
a6dd			; | | ------------ 
a6dd			; | | A prompt of '>' will be shown for various commands: 
a6dd			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a6dd			; | |    C - Continue display a data dump from the last set address 
a6dd			; | |    M xxxx - Set start of memory edit at address xx 
a6dd			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a6dd			; | |    G xxxx - Exec code at specific address 
a6dd			; | |    Q - Return to previous 
a6dd				if DEBUG_FORTH_WORDS_KEY 
a6dd					DMARK "MON" 
a6dd f5				push af  
a6de 3a f2 a6			ld a, (.dmark)  
a6e1 32 6b ee			ld (debug_mark),a  
a6e4 3a f3 a6			ld a, (.dmark+1)  
a6e7 32 6c ee			ld (debug_mark+1),a  
a6ea 3a f4 a6			ld a, (.dmark+2)  
a6ed 32 6d ee			ld (debug_mark+2),a  
a6f0 18 03			jr .pastdmark  
a6f2 ..			.dmark: db "MON"  
a6f5 f1			.pastdmark: pop af  
a6f6			endm  
# End of macro DMARK
a6f6					CALLMONITOR 
a6f6 cd 6f ee			call debug_vector  
a6f9				endm  
# End of macro CALLMONITOR
a6f9				endif 
a6f9			;		ld a, 0 
a6f9			;		ld (os_view_disable), a 
a6f9 cd 36 94			call bp_on 
a6fc			 
a6fc				CALLMONITOR 
a6fc cd 6f ee			call debug_vector  
a6ff				endm  
# End of macro CALLMONITOR
a6ff			 
a6ff			;	call monitor 
a6ff			 
a6ff				NEXTW 
a6ff c3 4d 9e			jp macro_next 
a702				endm 
# End of macro NEXTW
a702			 
a702			 
a702			.MALLOC: 
a702			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a702 56				db WORD_SYS_CORE+66             
a703 2b a7			dw .MALLOC2            
a705 06				db 5 + 1 
a706 .. 00			db "ALLOT",0              
a70c				endm 
# End of macro CWHEAD
a70c			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a70c				if DEBUG_FORTH_WORDS_KEY 
a70c					DMARK "ALL" 
a70c f5				push af  
a70d 3a 21 a7			ld a, (.dmark)  
a710 32 6b ee			ld (debug_mark),a  
a713 3a 22 a7			ld a, (.dmark+1)  
a716 32 6c ee			ld (debug_mark+1),a  
a719 3a 23 a7			ld a, (.dmark+2)  
a71c 32 6d ee			ld (debug_mark+2),a  
a71f 18 03			jr .pastdmark  
a721 ..			.dmark: db "ALL"  
a724 f1			.pastdmark: pop af  
a725			endm  
# End of macro DMARK
a725					CALLMONITOR 
a725 cd 6f ee			call debug_vector  
a728				endm  
# End of macro CALLMONITOR
a728				endif 
a728 c3 52 a7			jp .mallocc 
a72b			.MALLOC2: 
a72b			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a72b 56				db WORD_SYS_CORE+66             
a72c 69 a7			dw .FREE            
a72e 07				db 6 + 1 
a72f .. 00			db "MALLOC",0              
a736				endm 
# End of macro CWHEAD
a736			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a736				; get byte count 
a736				if DEBUG_FORTH_WORDS_KEY 
a736					DMARK "MAL" 
a736 f5				push af  
a737 3a 4b a7			ld a, (.dmark)  
a73a 32 6b ee			ld (debug_mark),a  
a73d 3a 4c a7			ld a, (.dmark+1)  
a740 32 6c ee			ld (debug_mark+1),a  
a743 3a 4d a7			ld a, (.dmark+2)  
a746 32 6d ee			ld (debug_mark+2),a  
a749 18 03			jr .pastdmark  
a74b ..			.dmark: db "MAL"  
a74e f1			.pastdmark: pop af  
a74f			endm  
# End of macro DMARK
a74f					CALLMONITOR 
a74f cd 6f ee			call debug_vector  
a752				endm  
# End of macro CALLMONITOR
a752				endif 
a752			.mallocc: 
a752				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a752 cd 97 9c			call macro_dsp_valuehl 
a755				endm 
# End of macro FORTH_DSP_VALUEHL
a755			 
a755			;		push hl 
a755			 
a755				; destroy value TOS 
a755			 
a755				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a755 cd 4f 9d			call macro_forth_dsp_pop 
a758				endm 
# End of macro FORTH_DSP_POP
a758			 
a758			;		pop hl 
a758 cd 07 91			call malloc 
a75b			if DEBUG_FORTH_MALLOC_GUARD 
a75b f5				push af 
a75c cd 04 8d			call ishlzero 
a75f			;		ld a, l 
a75f			;		add h 
a75f			;		cp 0 
a75f f1				pop af 
a760				 
a760 cc 0d cc			call z,malloc_error 
a763			endif 
a763			 
a763 cd a0 9a			call forth_push_numhl 
a766				NEXTW 
a766 c3 4d 9e			jp macro_next 
a769				endm 
# End of macro NEXTW
a769			 
a769			.FREE: 
a769			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a769 57				db WORD_SYS_CORE+67             
a76a 9a a7			dw .LIST            
a76c 05				db 4 + 1 
a76d .. 00			db "FREE",0              
a772				endm 
# End of macro CWHEAD
a772			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a772				if DEBUG_FORTH_WORDS_KEY 
a772					DMARK "FRE" 
a772 f5				push af  
a773 3a 87 a7			ld a, (.dmark)  
a776 32 6b ee			ld (debug_mark),a  
a779 3a 88 a7			ld a, (.dmark+1)  
a77c 32 6c ee			ld (debug_mark+1),a  
a77f 3a 89 a7			ld a, (.dmark+2)  
a782 32 6d ee			ld (debug_mark+2),a  
a785 18 03			jr .pastdmark  
a787 ..			.dmark: db "FRE"  
a78a f1			.pastdmark: pop af  
a78b			endm  
# End of macro DMARK
a78b					CALLMONITOR 
a78b cd 6f ee			call debug_vector  
a78e				endm  
# End of macro CALLMONITOR
a78e				endif 
a78e				; get address 
a78e			 
a78e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a78e cd 97 9c			call macro_dsp_valuehl 
a791				endm 
# End of macro FORTH_DSP_VALUEHL
a791			 
a791			;		push hl 
a791			 
a791				; destroy value TOS 
a791			 
a791				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a791 cd 4f 9d			call macro_forth_dsp_pop 
a794				endm 
# End of macro FORTH_DSP_POP
a794			 
a794			;		pop hl 
a794			if FORTH_ENABLE_MALLOCFREE 
a794 cd d1 91			call free 
a797			endif 
a797				NEXTW 
a797 c3 4d 9e			jp macro_next 
a79a				endm 
# End of macro NEXTW
a79a			.LIST: 
a79a			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a79a 5c				db WORD_SYS_CORE+72             
a79b 8a a9			dw .FORGET            
a79d 05				db 4 + 1 
a79e .. 00			db "LIST",0              
a7a3				endm 
# End of macro CWHEAD
a7a3			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a7a3			; | | The quoted word must be in upper case. 
a7a3			if DEBUG_FORTH_WORDS_KEY 
a7a3				DMARK "LST" 
a7a3 f5				push af  
a7a4 3a b8 a7			ld a, (.dmark)  
a7a7 32 6b ee			ld (debug_mark),a  
a7aa 3a b9 a7			ld a, (.dmark+1)  
a7ad 32 6c ee			ld (debug_mark+1),a  
a7b0 3a ba a7			ld a, (.dmark+2)  
a7b3 32 6d ee			ld (debug_mark+2),a  
a7b6 18 03			jr .pastdmark  
a7b8 ..			.dmark: db "LST"  
a7bb f1			.pastdmark: pop af  
a7bc			endm  
# End of macro DMARK
a7bc				CALLMONITOR 
a7bc cd 6f ee			call debug_vector  
a7bf				endm  
# End of macro CALLMONITOR
a7bf			endif 
a7bf			 
a7bf				FORTH_DSP_VALUEHL 
a7bf cd 97 9c			call macro_dsp_valuehl 
a7c2				endm 
# End of macro FORTH_DSP_VALUEHL
a7c2			 
a7c2 e5				push hl 
a7c3				FORTH_DSP_POP 
a7c3 cd 4f 9d			call macro_forth_dsp_pop 
a7c6				endm 
# End of macro FORTH_DSP_POP
a7c6 c1				pop bc 
a7c7			 
a7c7			; Start format of scratch string 
a7c7			 
a7c7 21 c1 e2			ld hl, scratch 
a7ca			 
a7ca 3e 3a			ld a, ':' 
a7cc 77				ld (hl),a 
a7cd 23				inc hl 
a7ce 3e 20			ld a, ' ' 
a7d0 77				ld (hl), a 
a7d1			 
a7d1				; Get ptr to the word we need to look up 
a7d1			 
a7d1			;		FORTH_DSP_VALUEHL 
a7d1				;v5 FORTH_DSP_VALUE 
a7d1			; TODO type check 
a7d1			;		inc hl    ; Skip type check  
a7d1			;		push hl 
a7d1			;		ex de, hl    ; put into DE 
a7d1			 
a7d1			 
a7d1 21 3d e4			ld hl, baseram 
a7d4				;ld hl, baseusermem 
a7d4			 
a7d4 e5			push hl   ; sacreifical push 
a7d5			 
a7d5			.ldouscanm: 
a7d5 e1			pop hl 
a7d6			.ldouscan: 
a7d6			if DEBUG_FORTH_WORDS 
a7d6				DMARK "LSs" 
a7d6 f5				push af  
a7d7 3a eb a7			ld a, (.dmark)  
a7da 32 6b ee			ld (debug_mark),a  
a7dd 3a ec a7			ld a, (.dmark+1)  
a7e0 32 6c ee			ld (debug_mark+1),a  
a7e3 3a ed a7			ld a, (.dmark+2)  
a7e6 32 6d ee			ld (debug_mark+2),a  
a7e9 18 03			jr .pastdmark  
a7eb ..			.dmark: db "LSs"  
a7ee f1			.pastdmark: pop af  
a7ef			endm  
# End of macro DMARK
a7ef				CALLMONITOR 
a7ef cd 6f ee			call debug_vector  
a7f2				endm  
# End of macro CALLMONITOR
a7f2			endif 
a7f2			; skip dict stub 
a7f2 cd 9e 9f			call forth_tok_next 
a7f5			 
a7f5			 
a7f5			; while we have words to look for 
a7f5			 
a7f5 7e			ld a, (hl)      
a7f6			if DEBUG_FORTH_WORDS 
a7f6				DMARK "LSk" 
a7f6 f5				push af  
a7f7 3a 0b a8			ld a, (.dmark)  
a7fa 32 6b ee			ld (debug_mark),a  
a7fd 3a 0c a8			ld a, (.dmark+1)  
a800 32 6c ee			ld (debug_mark+1),a  
a803 3a 0d a8			ld a, (.dmark+2)  
a806 32 6d ee			ld (debug_mark+2),a  
a809 18 03			jr .pastdmark  
a80b ..			.dmark: db "LSk"  
a80e f1			.pastdmark: pop af  
a80f			endm  
# End of macro DMARK
a80f				CALLMONITOR 
a80f cd 6f ee			call debug_vector  
a812				endm  
# End of macro CALLMONITOR
a812			endif 
a812				;cp WORD_SYS_END 
a812				;jp z, .lunotfound 
a812			 
a812					; if we hit non uwords then gone too far 
a812 fe 01				cp WORD_SYS_UWORD 
a814 c2 46 a9				jp nz, .lunotfound 
a817			 
a817				if DEBUG_FORTH_WORDS 
a817					DMARK "LSu" 
a817 f5				push af  
a818 3a 2c a8			ld a, (.dmark)  
a81b 32 6b ee			ld (debug_mark),a  
a81e 3a 2d a8			ld a, (.dmark+1)  
a821 32 6c ee			ld (debug_mark+1),a  
a824 3a 2e a8			ld a, (.dmark+2)  
a827 32 6d ee			ld (debug_mark+2),a  
a82a 18 03			jr .pastdmark  
a82c ..			.dmark: db "LSu"  
a82f f1			.pastdmark: pop af  
a830			endm  
# End of macro DMARK
a830					CALLMONITOR 
a830 cd 6f ee			call debug_vector  
a833				endm  
# End of macro CALLMONITOR
a833				endif 
a833			 
a833					; found a uword but is it the one we want... 
a833			 
a833 c5					push bc     ; uword to find is on bc 
a834 d1					pop de 
a835			 
a835 e5					push hl  ; to save the ptr 
a836			 
a836					; skip opcode 
a836 23					inc hl  
a837					; skip next ptr 
a837 23					inc hl  
a838 23					inc hl 
a839					; skip len 
a839 23					inc hl 
a83a			 
a83a				if DEBUG_FORTH_WORDS 
a83a					DMARK "LSc" 
a83a f5				push af  
a83b 3a 4f a8			ld a, (.dmark)  
a83e 32 6b ee			ld (debug_mark),a  
a841 3a 50 a8			ld a, (.dmark+1)  
a844 32 6c ee			ld (debug_mark+1),a  
a847 3a 51 a8			ld a, (.dmark+2)  
a84a 32 6d ee			ld (debug_mark+2),a  
a84d 18 03			jr .pastdmark  
a84f ..			.dmark: db "LSc"  
a852 f1			.pastdmark: pop af  
a853			endm  
# End of macro DMARK
a853					CALLMONITOR 
a853 cd 6f ee			call debug_vector  
a856				endm  
# End of macro CALLMONITOR
a856				endif 
a856			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a856			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a856			; Nope that has gone the other way. It needs to be exact not on first zero 
a856			;		call strcmp 
a856 c5					push bc 
a857 cd d7 90				call StrictStrCmp 
a85a c1					pop bc 
a85b c2 d5 a7				jp nz, .ldouscanm 
a85e				 
a85e			 
a85e			 
a85e					; we have a uword so push its name to the stack 
a85e			 
a85e			;	   	push hl  ; save so we can move to next dict block 
a85e e1			pop hl 
a85f			 
a85f				if DEBUG_FORTH_WORDS 
a85f					DMARK "LSm" 
a85f f5				push af  
a860 3a 74 a8			ld a, (.dmark)  
a863 32 6b ee			ld (debug_mark),a  
a866 3a 75 a8			ld a, (.dmark+1)  
a869 32 6c ee			ld (debug_mark+1),a  
a86c 3a 76 a8			ld a, (.dmark+2)  
a86f 32 6d ee			ld (debug_mark+2),a  
a872 18 03			jr .pastdmark  
a874 ..			.dmark: db "LSm"  
a877 f1			.pastdmark: pop af  
a878			endm  
# End of macro DMARK
a878					CALLMONITOR 
a878 cd 6f ee			call debug_vector  
a87b				endm  
# End of macro CALLMONITOR
a87b				endif 
a87b			 
a87b					; skip opcode 
a87b 23					inc hl  
a87c					; skip next ptr 
a87c 23					inc hl  
a87d 23					inc hl 
a87e					; skip len 
a87e 7e					ld a, (hl)   ; save length to add 
a87f				if DEBUG_FORTH_WORDS 
a87f					DMARK "LS2" 
a87f f5				push af  
a880 3a 94 a8			ld a, (.dmark)  
a883 32 6b ee			ld (debug_mark),a  
a886 3a 95 a8			ld a, (.dmark+1)  
a889 32 6c ee			ld (debug_mark+1),a  
a88c 3a 96 a8			ld a, (.dmark+2)  
a88f 32 6d ee			ld (debug_mark+2),a  
a892 18 03			jr .pastdmark  
a894 ..			.dmark: db "LS2"  
a897 f1			.pastdmark: pop af  
a898			endm  
# End of macro DMARK
a898					CALLMONITOR 
a898 cd 6f ee			call debug_vector  
a89b				endm  
# End of macro CALLMONITOR
a89b				endif 
a89b			 
a89b					; save this location 
a89b				 
a89b e5					push hl 
a89c			 
a89c 23					inc hl 
a89d 11 c3 e2				ld de, scratch+2 
a8a0 4f					ld c, a 
a8a1 06 00				ld b, 0 
a8a3			 
a8a3				if DEBUG_FORTH_WORDS 
a8a3					DMARK "LSn" 
a8a3 f5				push af  
a8a4 3a b8 a8			ld a, (.dmark)  
a8a7 32 6b ee			ld (debug_mark),a  
a8aa 3a b9 a8			ld a, (.dmark+1)  
a8ad 32 6c ee			ld (debug_mark+1),a  
a8b0 3a ba a8			ld a, (.dmark+2)  
a8b3 32 6d ee			ld (debug_mark+2),a  
a8b6 18 03			jr .pastdmark  
a8b8 ..			.dmark: db "LSn"  
a8bb f1			.pastdmark: pop af  
a8bc			endm  
# End of macro DMARK
a8bc					CALLMONITOR 
a8bc cd 6f ee			call debug_vector  
a8bf				endm  
# End of macro CALLMONITOR
a8bf				endif 
a8bf			 
a8bf					; copy uword name to scratch 
a8bf			 
a8bf ed b0				ldir 
a8c1			 
a8c1 1b					dec de 
a8c2 3e 20				ld a, ' '    ; change null to space 
a8c4 12					ld (de), a 
a8c5			 
a8c5 13					inc de 
a8c6			 
a8c6 d5					push de 
a8c7 c1					pop bc     ; move scratch pointer to end of word name and save it 
a8c8			 
a8c8 e1					pop hl 
a8c9 7e					ld a, (hl) 
a8ca					;inc hl 
a8ca					; skip word string 
a8ca cd db 8c				call addatohl 
a8cd			 
a8cd 23					inc hl 
a8ce			 
a8ce				if DEBUG_FORTH_WORDS 
a8ce					DMARK "LS3" 
a8ce f5				push af  
a8cf 3a e3 a8			ld a, (.dmark)  
a8d2 32 6b ee			ld (debug_mark),a  
a8d5 3a e4 a8			ld a, (.dmark+1)  
a8d8 32 6c ee			ld (debug_mark+1),a  
a8db 3a e5 a8			ld a, (.dmark+2)  
a8de 32 6d ee			ld (debug_mark+2),a  
a8e1 18 03			jr .pastdmark  
a8e3 ..			.dmark: db "LS3"  
a8e6 f1			.pastdmark: pop af  
a8e7			endm  
# End of macro DMARK
a8e7					CALLMONITOR 
a8e7 cd 6f ee			call debug_vector  
a8ea				endm  
# End of macro CALLMONITOR
a8ea				endif 
a8ea					; should now be at the start of the machine code to setup the eval of the uword 
a8ea					; now locate the ptr to the string defintion 
a8ea			 
a8ea					; skip ld hl, 
a8ea					; then load the ptr 
a8ea			; TODO use get from hl ptr 
a8ea 23					inc hl 
a8eb 5e					ld e, (hl) 
a8ec 23					inc hl 
a8ed 56					ld d, (hl) 
a8ee eb					ex de, hl 
a8ef			 
a8ef			 
a8ef				if DEBUG_FORTH_WORDS 
a8ef					DMARK "LSt" 
a8ef f5				push af  
a8f0 3a 04 a9			ld a, (.dmark)  
a8f3 32 6b ee			ld (debug_mark),a  
a8f6 3a 05 a9			ld a, (.dmark+1)  
a8f9 32 6c ee			ld (debug_mark+1),a  
a8fc 3a 06 a9			ld a, (.dmark+2)  
a8ff 32 6d ee			ld (debug_mark+2),a  
a902 18 03			jr .pastdmark  
a904 ..			.dmark: db "LSt"  
a907 f1			.pastdmark: pop af  
a908			endm  
# End of macro DMARK
a908					CALLMONITOR 
a908 cd 6f ee			call debug_vector  
a90b				endm  
# End of macro CALLMONITOR
a90b				endif 
a90b			 
a90b			; cant push right now due to tokenised strings  
a90b			 
a90b			; get the destination of where to copy this definition to. 
a90b			 
a90b c5					push bc 
a90c d1					pop de 
a90d			 
a90d 7e			.listl:         ld a,(hl) 
a90e fe 00				cp 0 
a910 28 09				jr z, .lreplsp     ; replace zero with space 
a912					;cp FORTH_END_BUFFER 
a912 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a914 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a916				 
a916					; just copy this char as is then 
a916			 
a916 12					ld (de), a 
a917			 
a917 23			.listnxt:	inc hl 
a918 13					inc de 
a919 18 f2				jr .listl 
a91b			 
a91b 3e 20		.lreplsp:	ld a,' ' 
a91d 12					ld (de), a 
a91e 18 f7				jr .listnxt 
a920			 
a920			; close up uword def 
a920			 
a920			.listdone: 
a920 12					ld (de), a 
a921 13					inc de 
a922 3e 00				ld a, 0 
a924 12					ld (de), a 
a925			 
a925			; now have def so clean up and push to stack 
a925			 
a925 21 c1 e2				ld hl, scratch 
a928				if DEBUG_FORTH_WORDS 
a928					DMARK "Ltp" 
a928 f5				push af  
a929 3a 3d a9			ld a, (.dmark)  
a92c 32 6b ee			ld (debug_mark),a  
a92f 3a 3e a9			ld a, (.dmark+1)  
a932 32 6c ee			ld (debug_mark+1),a  
a935 3a 3f a9			ld a, (.dmark+2)  
a938 32 6d ee			ld (debug_mark+2),a  
a93b 18 03			jr .pastdmark  
a93d ..			.dmark: db "Ltp"  
a940 f1			.pastdmark: pop af  
a941			endm  
# End of macro DMARK
a941					CALLMONITOR 
a941 cd 6f ee			call debug_vector  
a944				endm  
# End of macro CALLMONITOR
a944				endif 
a944			 
a944 18 1f			jr .listpush 
a946			 
a946			;.lnuword:	pop hl 
a946			;		call forth_tok_next 
a946			;		jp .ldouscan  
a946			 
a946			.lunotfound:		  
a946			 
a946				if DEBUG_FORTH_WORDS 
a946					DMARK "LSn" 
a946 f5				push af  
a947 3a 5b a9			ld a, (.dmark)  
a94a 32 6b ee			ld (debug_mark),a  
a94d 3a 5c a9			ld a, (.dmark+1)  
a950 32 6c ee			ld (debug_mark+1),a  
a953 3a 5d a9			ld a, (.dmark+2)  
a956 32 6d ee			ld (debug_mark+2),a  
a959 18 03			jr .pastdmark  
a95b ..			.dmark: db "LSn"  
a95e f1			.pastdmark: pop af  
a95f			endm  
# End of macro DMARK
a95f					CALLMONITOR 
a95f cd 6f ee			call debug_vector  
a962				endm  
# End of macro CALLMONITOR
a962				endif 
a962			 
a962					 
a962			;		FORTH_DSP_POP 
a962			;		ld hl, .luno 
a962			 
a962					NEXTW			 
a962 c3 4d 9e			jp macro_next 
a965				endm 
# End of macro NEXTW
a965			 
a965			.listpush: 
a965				if DEBUG_FORTH_WORDS 
a965					DMARK "LS>" 
a965 f5				push af  
a966 3a 7a a9			ld a, (.dmark)  
a969 32 6b ee			ld (debug_mark),a  
a96c 3a 7b a9			ld a, (.dmark+1)  
a96f 32 6c ee			ld (debug_mark+1),a  
a972 3a 7c a9			ld a, (.dmark+2)  
a975 32 6d ee			ld (debug_mark+2),a  
a978 18 03			jr .pastdmark  
a97a ..			.dmark: db "LS>"  
a97d f1			.pastdmark: pop af  
a97e			endm  
# End of macro DMARK
a97e					CALLMONITOR 
a97e cd 6f ee			call debug_vector  
a981				endm  
# End of macro CALLMONITOR
a981				endif 
a981 cd 0e 9b				call forth_push_str 
a984			 
a984			 
a984			 
a984					NEXTW 
a984 c3 4d 9e			jp macro_next 
a987				endm 
# End of macro NEXTW
a987			 
a987			;.luno:    db "Word not found",0 
a987			 
a987			 
a987			 
a987			 
a987			 
a987			;		push hl   ; save pointer to start of uword def string 
a987			; 
a987			;; look for FORTH_EOL_LINE 
a987			;		ld a, FORTH_END_BUFFER 
a987			;		call strlent 
a987			; 
a987			;		inc hl		 ; space for coln def 
a987			;		inc hl 
a987			;		inc hl          ; space for terms 
a987			;		inc hl 
a987			; 
a987			;		ld a, 20   ; TODO get actual length 
a987			;		call addatohl    ; include a random amount of room for the uword name 
a987			; 
a987			;		 
a987			;	if DEBUG_FORTH_WORDS 
a987			;		DMARK "Lt1" 
a987			;		CALLMONITOR 
a987			;	endif 
a987			;		 
a987			; 
a987			;; malloc space for the string because we cant change it 
a987			; 
a987			;		call malloc 
a987			;	if DEBUG_FORTH_MALLOC_GUARD 
a987			;		push af 
a987			;		call ishlzero 
a987			;		pop af 
a987			;		 
a987			;		call z,malloc_error 
a987			;	endif 
a987			; 
a987			;	if DEBUG_FORTH_WORDS 
a987			;		DMARK "Lt2" 
a987			;		CALLMONITOR 
a987			;	endif 
a987			;		pop de 
a987			;		push hl    ; push the malloc to release later 
a987			;		push hl   ;  push back a copy for the later stack push 
a987			;		 
a987			;; copy the string swapping out the zero terms for spaces 
a987			; 
a987			;		; de has our source 
a987			;		; hl has our dest 
a987			; 
a987			;; add the coln def 
a987			; 
a987			;		ld a, ':' 
a987			;		ld (hl), a 
a987			;		inc hl 
a987			;		ld a, ' ' 
a987			;		ld (hl), a 
a987			;		inc hl 
a987			; 
a987			;; add the uname word 
a987			;		push de   ; save our string for now 
a987			;		ex de, hl 
a987			; 
a987			;		FORTH_DSP_VALUE 
a987			;		;v5 FORTH_DSP_VALUE 
a987			; 
a987			;		inc hl   ; skip type but we know by now this is OK 
a987			; 
a987			;.luword:	ld a,(hl) 
a987			;		cp 0 
a987			;		jr z, .luword2 
a987			;		ld (de), a 
a987			;		inc de 
a987			;		inc hl 
a987			;		jr .luword 
a987			; 
a987			;.luword2:	ld a, ' ' 
a987			;		ld (de), a 
a987			;;		inc hl 
a987			;;		inc de 
a987			;;		ld (de), a 
a987			;;		inc hl 
a987			;		inc de 
a987			; 
a987			;		ex de, hl 
a987			;		pop de 
a987			;		 
a987			;		 
a987			; 
a987			;; detoken that string and copy it 
a987			; 
a987			;	if DEBUG_FORTH_WORDS 
a987			;		DMARK "Lt2" 
a987			;		CALLMONITOR 
a987			;	endif 
a987			;.ldetok:	ld a, (de) 
a987			;		cp FORTH_END_BUFFER 
a987			;		jr z, .ldetokend 
a987			;		; swap out any zero term for space 
a987			;		cp 0 
a987			;		jr nz, .ldetoknext 
a987			;		ld a, ' ' 
a987			; 
a987			;	if DEBUG_FORTH_WORDS 
a987			;		DMARK "LtS" 
a987			;		CALLMONITOR 
a987			;	endif 
a987			;.ldetoknext:	ld (hl), a 
a987			;		inc de 
a987			;		inc hl 
a987			;		jr .ldetok 
a987			; 
a987			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a987			;		ld (hl), a  
a987			; 
a987			;; free that temp malloc 
a987			; 
a987			;		pop hl    
a987			; 
a987			;	if DEBUG_FORTH_WORDS 
a987			;		DMARK "Lt4" 
a987			;		CALLMONITOR 
a987			;	endif 
a987			;		call forth_apushstrhl 
a987			; 
a987			;		; get rid of temp malloc area 
a987			; 
a987			;		pop hl 
a987			;		call free 
a987			; 
a987			;		jr .ludone 
a987			; 
a987			;.lnuword:	pop hl 
a987			;		call forth_tok_next 
a987			;		jp .ldouscan  
a987			; 
a987			;.ludone:		 pop hl 
a987			; 
a987					NEXTW 
a987 c3 4d 9e			jp macro_next 
a98a				endm 
# End of macro NEXTW
a98a			 
a98a			.FORGET: 
a98a				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a98a 5d				db WORD_SYS_CORE+73             
a98b 03 aa			dw .NOP            
a98d 07				db 6 + 1 
a98e .. 00			db "FORGET",0              
a995				endm 
# End of macro CWHEAD
a995			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a995			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
a995			; | |  
a995			; | | e.g. "MORE" forget 
a995					if DEBUG_FORTH_WORDS_KEY 
a995						DMARK "FRG" 
a995 f5				push af  
a996 3a aa a9			ld a, (.dmark)  
a999 32 6b ee			ld (debug_mark),a  
a99c 3a ab a9			ld a, (.dmark+1)  
a99f 32 6c ee			ld (debug_mark+1),a  
a9a2 3a ac a9			ld a, (.dmark+2)  
a9a5 32 6d ee			ld (debug_mark+2),a  
a9a8 18 03			jr .pastdmark  
a9aa ..			.dmark: db "FRG"  
a9ad f1			.pastdmark: pop af  
a9ae			endm  
# End of macro DMARK
a9ae						CALLMONITOR 
a9ae cd 6f ee			call debug_vector  
a9b1				endm  
# End of macro CALLMONITOR
a9b1					endif 
a9b1			 
a9b1				; find uword 
a9b1			        ; update start of word with "_" 
a9b1				; replace uword with deleted flag 
a9b1			 
a9b1			 
a9b1			;	if DEBUG_FORTH_WORDS 
a9b1			;		DMARK "FOG" 
a9b1			;		CALLMONITOR 
a9b1			;	endif 
a9b1			 
a9b1			 
a9b1					; Get ptr to the word we need to look up 
a9b1			 
a9b1					FORTH_DSP_VALUEHL 
a9b1 cd 97 9c			call macro_dsp_valuehl 
a9b4				endm 
# End of macro FORTH_DSP_VALUEHL
a9b4					;v5 FORTH_DSP_VALUE 
a9b4				; TODO type check 
a9b4			;		inc hl    ; Skip type check  
a9b4 e5					push hl 
a9b5 c1					pop bc 
a9b6			;		ex de, hl    ; put into DE 
a9b6			 
a9b6			 
a9b6 21 3d e4				ld hl, baseram 
a9b9					;ld hl, baseusermem 
a9b9			 
a9b9				; skip dict stub 
a9b9			;	call forth_tok_next 
a9b9 e5			push hl   ; sacreifical push 
a9ba			 
a9ba			.fldouscanm: 
a9ba e1				pop hl 
a9bb			.fldouscan: 
a9bb			;	if DEBUG_FORTH_WORDS 
a9bb			;		DMARK "LSs" 
a9bb			;		CALLMONITOR 
a9bb			;	endif 
a9bb				; skip dict stub 
a9bb cd 9e 9f				call forth_tok_next 
a9be			 
a9be			 
a9be			; while we have words to look for 
a9be			 
a9be 7e				ld a, (hl)      
a9bf			;	if DEBUG_FORTH_WORDS 
a9bf			;		DMARK "LSk" 
a9bf			;		CALLMONITOR 
a9bf			;	endif 
a9bf fe 00				cp WORD_SYS_END 
a9c1 ca fd a9				jp z, .flunotfound 
a9c4 fe 01				cp WORD_SYS_UWORD 
a9c6 c2 bb a9				jp nz, .fldouscan 
a9c9			 
a9c9			;	if DEBUG_FORTH_WORDS 
a9c9			;		DMARK "LSu" 
a9c9			;		CALLMONITOR 
a9c9			;	endif 
a9c9			 
a9c9					; found a uword but is it the one we want... 
a9c9			 
a9c9 c5					push bc     ; uword to find is on bc 
a9ca d1					pop de 
a9cb			 
a9cb e5					push hl  ; to save the ptr 
a9cc			 
a9cc					; skip opcode 
a9cc 23					inc hl  
a9cd					; skip next ptr 
a9cd 23					inc hl  
a9ce 23					inc hl 
a9cf					; skip len 
a9cf 23					inc hl 
a9d0			 
a9d0			;	if DEBUG_FORTH_WORDS 
a9d0			;		DMARK "LSc" 
a9d0			;		CALLMONITOR 
a9d0			;	endif 
a9d0 cd ca 90				call strcmp 
a9d3 c2 ba a9				jp nz, .fldouscanm 
a9d6			; 
a9d6			; 
a9d6			;; while we have words to look for 
a9d6			; 
a9d6			;.fdouscan:	ld a, (hl)      
a9d6			;	if DEBUG_FORTH_WORDS 
a9d6			;		DMARK "LSs" 
a9d6			;		CALLMONITOR 
a9d6			;	endif 
a9d6			;		cp WORD_SYS_END 
a9d6			;		jp z, .fudone 
a9d6			;		cp WORD_SYS_UWORD 
a9d6			;		jp nz, .fnuword 
a9d6			; 
a9d6			;	if DEBUG_FORTH_WORDS 
a9d6			;		DMARK "FGu" 
a9d6			;		CALLMONITOR 
a9d6			;	endif 
a9d6			; 
a9d6			;		; found a uword but is it the one we want... 
a9d6			; 
a9d6			; 
a9d6			;	        pop de   ; get back the dsp name 
a9d6			;		push de 
a9d6			; 
a9d6			;		push hl  ; to save the ptr 
a9d6			; 
a9d6			;		; skip opcode 
a9d6			;		inc hl  
a9d6			;		; skip next ptr 
a9d6			;		inc hl  
a9d6			;		inc hl 
a9d6			;		; skip len 
a9d6			;		inc hl 
a9d6			; 
a9d6			;	if DEBUG_FORTH_WORDS 
a9d6			;		DMARK "FGc" 
a9d6			;		CALLMONITOR 
a9d6			;	endif 
a9d6			;		call strcmp 
a9d6			;		jp nz, .fnuword 
a9d6			 
a9d6			 
a9d6 e1			pop hl 
a9d7			 
a9d7				 
a9d7				if DEBUG_FORTH_WORDS 
a9d7					DMARK "FGm" 
a9d7 f5				push af  
a9d8 3a ec a9			ld a, (.dmark)  
a9db 32 6b ee			ld (debug_mark),a  
a9de 3a ed a9			ld a, (.dmark+1)  
a9e1 32 6c ee			ld (debug_mark+1),a  
a9e4 3a ee a9			ld a, (.dmark+2)  
a9e7 32 6d ee			ld (debug_mark+2),a  
a9ea 18 03			jr .pastdmark  
a9ec ..			.dmark: db "FGm"  
a9ef f1			.pastdmark: pop af  
a9f0			endm  
# End of macro DMARK
a9f0					CALLMONITOR 
a9f0 cd 6f ee			call debug_vector  
a9f3				endm  
# End of macro CALLMONITOR
a9f3				endif 
a9f3			 
a9f3			 
a9f3			 
a9f3					; we have a uword so push its name to the stack 
a9f3			 
a9f3			;	   	push hl  ; save so we can move to next dict block 
a9f3			;pop hl 
a9f3			 
a9f3					; update opcode to deleted 
a9f3 3e 03				ld a, WORD_SYS_DELETED 
a9f5 77					ld (hl), a 
a9f6			 
a9f6 23					inc hl  
a9f7					; skip next ptr 
a9f7 23					inc hl  
a9f8 23					inc hl 
a9f9					; skip len 
a9f9 23					inc hl 
a9fa			 
a9fa					; TODO change parser to skip deleted words but for now mark it out 
a9fa 3e 5f				ld a, "_" 
a9fc 77					ld  (hl),a 
a9fd			 
a9fd			;		jr .fudone 
a9fd			; 
a9fd			;.fnuword:	pop hl 
a9fd			;		call forth_tok_next 
a9fd			;		jp .fdouscan  
a9fd			 
a9fd			.flunotfound:		  
a9fd			 
a9fd			 
a9fd					 
a9fd					FORTH_DSP_POP 
a9fd cd 4f 9d			call macro_forth_dsp_pop 
aa00				endm 
# End of macro FORTH_DSP_POP
aa00			;		ld hl, .luno 
aa00			;.fudone:		 pop hl 
aa00					NEXTW 
aa00 c3 4d 9e			jp macro_next 
aa03				endm 
# End of macro NEXTW
aa03			.NOP: 
aa03				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa03 61				db WORD_SYS_CORE+77             
aa04 2a aa			dw .COMO            
aa06 04				db 3 + 1 
aa07 .. 00			db "NOP",0              
aa0b				endm 
# End of macro CWHEAD
aa0b			; | NOP (  --  ) Do nothing | DONE 
aa0b					if DEBUG_FORTH_WORDS_KEY 
aa0b						DMARK "NOP" 
aa0b f5				push af  
aa0c 3a 20 aa			ld a, (.dmark)  
aa0f 32 6b ee			ld (debug_mark),a  
aa12 3a 21 aa			ld a, (.dmark+1)  
aa15 32 6c ee			ld (debug_mark+1),a  
aa18 3a 22 aa			ld a, (.dmark+2)  
aa1b 32 6d ee			ld (debug_mark+2),a  
aa1e 18 03			jr .pastdmark  
aa20 ..			.dmark: db "NOP"  
aa23 f1			.pastdmark: pop af  
aa24			endm  
# End of macro DMARK
aa24						CALLMONITOR 
aa24 cd 6f ee			call debug_vector  
aa27				endm  
# End of macro CALLMONITOR
aa27					endif 
aa27				       NEXTW 
aa27 c3 4d 9e			jp macro_next 
aa2a				endm 
# End of macro NEXTW
aa2a			.COMO: 
aa2a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa2a 6e				db WORD_SYS_CORE+90             
aa2b 7c aa			dw .COMC            
aa2d 02				db 1 + 1 
aa2e .. 00			db "(",0              
aa30				endm 
# End of macro CWHEAD
aa30			; | ( ( -- )  Start of comment | DONE 
aa30			 
aa30			 
aa30 2a c2 e5				ld hl, ( os_tok_ptr) 
aa33 11 77 aa			ld de, .closepar 
aa36					 
aa36					if DEBUG_FORTH_WORDS 
aa36						DMARK ").." 
aa36 f5				push af  
aa37 3a 4b aa			ld a, (.dmark)  
aa3a 32 6b ee			ld (debug_mark),a  
aa3d 3a 4c aa			ld a, (.dmark+1)  
aa40 32 6c ee			ld (debug_mark+1),a  
aa43 3a 4d aa			ld a, (.dmark+2)  
aa46 32 6d ee			ld (debug_mark+2),a  
aa49 18 03			jr .pastdmark  
aa4b ..			.dmark: db ").."  
aa4e f1			.pastdmark: pop af  
aa4f			endm  
# End of macro DMARK
aa4f						CALLMONITOR 
aa4f cd 6f ee			call debug_vector  
aa52				endm  
# End of macro CALLMONITOR
aa52					endif 
aa52 cd 68 9f			call findnexttok  
aa55			 
aa55					if DEBUG_FORTH_WORDS 
aa55						DMARK "IF5" 
aa55 f5				push af  
aa56 3a 6a aa			ld a, (.dmark)  
aa59 32 6b ee			ld (debug_mark),a  
aa5c 3a 6b aa			ld a, (.dmark+1)  
aa5f 32 6c ee			ld (debug_mark+1),a  
aa62 3a 6c aa			ld a, (.dmark+2)  
aa65 32 6d ee			ld (debug_mark+2),a  
aa68 18 03			jr .pastdmark  
aa6a ..			.dmark: db "IF5"  
aa6d f1			.pastdmark: pop af  
aa6e			endm  
# End of macro DMARK
aa6e						CALLMONITOR 
aa6e cd 6f ee			call debug_vector  
aa71				endm  
# End of macro CALLMONITOR
aa71					endif 
aa71				; replace below with ) exec using tok_ptr 
aa71 22 c2 e5			ld (os_tok_ptr), hl 
aa74 c3 de 9e			jp exec1 
aa77			 
aa77 .. 00			.closepar:   db ")",0 
aa79			 
aa79				       NEXTW 
aa79 c3 4d 9e			jp macro_next 
aa7c				endm 
# End of macro NEXTW
aa7c			.COMC: 
aa7c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa7c 6f				db WORD_SYS_CORE+91             
aa7d 85 aa			dw .SCRATCH            
aa7f 02				db 1 + 1 
aa80 .. 00			db ")",0              
aa82				endm 
# End of macro CWHEAD
aa82			; | ) ( -- )  End of comment |  DONE  
aa82				       NEXTW 
aa82 c3 4d 9e			jp macro_next 
aa85				endm 
# End of macro NEXTW
aa85			 
aa85			.SCRATCH: 
aa85				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa85 6f				db WORD_SYS_CORE+91             
aa86 c0 aa			dw .INC            
aa88 08				db 7 + 1 
aa89 .. 00			db "SCRATCH",0              
aa91				endm 
# End of macro CWHEAD
aa91			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa91			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa91			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa91			; | |  
aa91			; | | e.g.    : score $00 scratch ; 
aa91			; | |  
aa91			; | | $00 score ! 
aa91			; | | $01 score +! 
aa91			; | |  
aa91			; | | e.g.   : varword $0a scratch ;  
aa91			; | | 
aa91			; | | $8000 varword ! 
aa91					if DEBUG_FORTH_WORDS_KEY 
aa91						DMARK "SCR" 
aa91 f5				push af  
aa92 3a a6 aa			ld a, (.dmark)  
aa95 32 6b ee			ld (debug_mark),a  
aa98 3a a7 aa			ld a, (.dmark+1)  
aa9b 32 6c ee			ld (debug_mark+1),a  
aa9e 3a a8 aa			ld a, (.dmark+2)  
aaa1 32 6d ee			ld (debug_mark+2),a  
aaa4 18 03			jr .pastdmark  
aaa6 ..			.dmark: db "SCR"  
aaa9 f1			.pastdmark: pop af  
aaaa			endm  
# End of macro DMARK
aaaa						CALLMONITOR 
aaaa cd 6f ee			call debug_vector  
aaad				endm  
# End of macro CALLMONITOR
aaad					endif 
aaad			 
aaad					FORTH_DSP_VALUEHL 
aaad cd 97 9c			call macro_dsp_valuehl 
aab0				endm 
# End of macro FORTH_DSP_VALUEHL
aab0				 
aab0					FORTH_DSP_POP 
aab0 cd 4f 9d			call macro_forth_dsp_pop 
aab3				endm 
# End of macro FORTH_DSP_POP
aab3			 
aab3 7d					ld a, l 
aab4 21 e6 e7				ld hl, os_var_array 
aab7 cd db 8c				call addatohl 
aaba			 
aaba cd a0 9a				call forth_push_numhl 
aabd			 
aabd				       NEXTW 
aabd c3 4d 9e			jp macro_next 
aac0				endm 
# End of macro NEXTW
aac0			 
aac0			.INC: 
aac0				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aac0 6f				db WORD_SYS_CORE+91             
aac1 16 ab			dw .DEC            
aac3 03				db 2 + 1 
aac4 .. 00			db "+!",0              
aac7				endm 
# End of macro CWHEAD
aac7			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aac7					if DEBUG_FORTH_WORDS_KEY 
aac7						DMARK "+s_" 
aac7 f5				push af  
aac8 3a dc aa			ld a, (.dmark)  
aacb 32 6b ee			ld (debug_mark),a  
aace 3a dd aa			ld a, (.dmark+1)  
aad1 32 6c ee			ld (debug_mark+1),a  
aad4 3a de aa			ld a, (.dmark+2)  
aad7 32 6d ee			ld (debug_mark+2),a  
aada 18 03			jr .pastdmark  
aadc ..			.dmark: db "+s_"  
aadf f1			.pastdmark: pop af  
aae0			endm  
# End of macro DMARK
aae0						CALLMONITOR 
aae0 cd 6f ee			call debug_vector  
aae3				endm  
# End of macro CALLMONITOR
aae3					endif 
aae3			 
aae3					FORTH_DSP_VALUEHL 
aae3 cd 97 9c			call macro_dsp_valuehl 
aae6				endm 
# End of macro FORTH_DSP_VALUEHL
aae6			 
aae6 e5					push hl   ; save address 
aae7			 
aae7					FORTH_DSP_POP 
aae7 cd 4f 9d			call macro_forth_dsp_pop 
aaea				endm 
# End of macro FORTH_DSP_POP
aaea			 
aaea					FORTH_DSP_VALUEHL 
aaea cd 97 9c			call macro_dsp_valuehl 
aaed				endm 
# End of macro FORTH_DSP_VALUEHL
aaed			 
aaed e5					push hl 
aaee					FORTH_DSP_POP 
aaee cd 4f 9d			call macro_forth_dsp_pop 
aaf1				endm 
# End of macro FORTH_DSP_POP
aaf1 e1					pop hl 
aaf2			 
aaf2					; hl contains value to add to byte at a 
aaf2				 
aaf2 eb					ex de, hl 
aaf3			 
aaf3 e1					pop hl 
aaf4			 
aaf4					if DEBUG_FORTH_WORDS 
aaf4						DMARK "INC" 
aaf4 f5				push af  
aaf5 3a 09 ab			ld a, (.dmark)  
aaf8 32 6b ee			ld (debug_mark),a  
aafb 3a 0a ab			ld a, (.dmark+1)  
aafe 32 6c ee			ld (debug_mark+1),a  
ab01 3a 0b ab			ld a, (.dmark+2)  
ab04 32 6d ee			ld (debug_mark+2),a  
ab07 18 03			jr .pastdmark  
ab09 ..			.dmark: db "INC"  
ab0c f1			.pastdmark: pop af  
ab0d			endm  
# End of macro DMARK
ab0d						CALLMONITOR 
ab0d cd 6f ee			call debug_vector  
ab10				endm  
# End of macro CALLMONITOR
ab10					endif 
ab10			 
ab10 7e					ld a,(hl) 
ab11 83					add e 
ab12 77					ld (hl),a 
ab13			 
ab13			 
ab13			 
ab13				       NEXTW 
ab13 c3 4d 9e			jp macro_next 
ab16				endm 
# End of macro NEXTW
ab16			 
ab16			.DEC: 
ab16				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab16 6f				db WORD_SYS_CORE+91             
ab17 6a ab			dw .INC2            
ab19 03				db 2 + 1 
ab1a .. 00			db "-!",0              
ab1d				endm 
# End of macro CWHEAD
ab1d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab1d					if DEBUG_FORTH_WORDS_KEY 
ab1d						DMARK "-s_" 
ab1d f5				push af  
ab1e 3a 32 ab			ld a, (.dmark)  
ab21 32 6b ee			ld (debug_mark),a  
ab24 3a 33 ab			ld a, (.dmark+1)  
ab27 32 6c ee			ld (debug_mark+1),a  
ab2a 3a 34 ab			ld a, (.dmark+2)  
ab2d 32 6d ee			ld (debug_mark+2),a  
ab30 18 03			jr .pastdmark  
ab32 ..			.dmark: db "-s_"  
ab35 f1			.pastdmark: pop af  
ab36			endm  
# End of macro DMARK
ab36						CALLMONITOR 
ab36 cd 6f ee			call debug_vector  
ab39				endm  
# End of macro CALLMONITOR
ab39					endif 
ab39			 
ab39					FORTH_DSP_VALUEHL 
ab39 cd 97 9c			call macro_dsp_valuehl 
ab3c				endm 
# End of macro FORTH_DSP_VALUEHL
ab3c			 
ab3c e5					push hl   ; save address 
ab3d			 
ab3d					FORTH_DSP_POP 
ab3d cd 4f 9d			call macro_forth_dsp_pop 
ab40				endm 
# End of macro FORTH_DSP_POP
ab40			 
ab40					FORTH_DSP_VALUEHL 
ab40 cd 97 9c			call macro_dsp_valuehl 
ab43				endm 
# End of macro FORTH_DSP_VALUEHL
ab43			 
ab43					; hl contains value to add to byte at a 
ab43				 
ab43 eb					ex de, hl 
ab44			 
ab44 e1					pop hl 
ab45			 
ab45					if DEBUG_FORTH_WORDS 
ab45						DMARK "DEC" 
ab45 f5				push af  
ab46 3a 5a ab			ld a, (.dmark)  
ab49 32 6b ee			ld (debug_mark),a  
ab4c 3a 5b ab			ld a, (.dmark+1)  
ab4f 32 6c ee			ld (debug_mark+1),a  
ab52 3a 5c ab			ld a, (.dmark+2)  
ab55 32 6d ee			ld (debug_mark+2),a  
ab58 18 03			jr .pastdmark  
ab5a ..			.dmark: db "DEC"  
ab5d f1			.pastdmark: pop af  
ab5e			endm  
# End of macro DMARK
ab5e						CALLMONITOR 
ab5e cd 6f ee			call debug_vector  
ab61				endm  
# End of macro CALLMONITOR
ab61					endif 
ab61			 
ab61 7e					ld a,(hl) 
ab62 93					sub e 
ab63 77					ld (hl),a 
ab64			 
ab64			 
ab64					FORTH_DSP_POP 
ab64 cd 4f 9d			call macro_forth_dsp_pop 
ab67				endm 
# End of macro FORTH_DSP_POP
ab67			 
ab67				       NEXTW 
ab67 c3 4d 9e			jp macro_next 
ab6a				endm 
# End of macro NEXTW
ab6a			 
ab6a			.INC2: 
ab6a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab6a 6f				db WORD_SYS_CORE+91             
ab6b 17 ac			dw .DEC2            
ab6d 04				db 3 + 1 
ab6e .. 00			db "+2!",0              
ab72				endm 
# End of macro CWHEAD
ab72			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab72			 
ab72					if DEBUG_FORTH_WORDS_KEY 
ab72						DMARK "+2s" 
ab72 f5				push af  
ab73 3a 87 ab			ld a, (.dmark)  
ab76 32 6b ee			ld (debug_mark),a  
ab79 3a 88 ab			ld a, (.dmark+1)  
ab7c 32 6c ee			ld (debug_mark+1),a  
ab7f 3a 89 ab			ld a, (.dmark+2)  
ab82 32 6d ee			ld (debug_mark+2),a  
ab85 18 03			jr .pastdmark  
ab87 ..			.dmark: db "+2s"  
ab8a f1			.pastdmark: pop af  
ab8b			endm  
# End of macro DMARK
ab8b						CALLMONITOR 
ab8b cd 6f ee			call debug_vector  
ab8e				endm  
# End of macro CALLMONITOR
ab8e					endif 
ab8e			 
ab8e					; Address 
ab8e			 
ab8e					FORTH_DSP_VALUEHL 
ab8e cd 97 9c			call macro_dsp_valuehl 
ab91				endm 
# End of macro FORTH_DSP_VALUEHL
ab91			 
ab91 e5					push hl    ; save address 
ab92			 
ab92					; load content into de 
ab92			 
ab92 5e					ld e,(hl) 
ab93 23					inc hl 
ab94 56					ld d, (hl) 
ab95			 
ab95					if DEBUG_FORTH_WORDS 
ab95						DMARK "+2a" 
ab95 f5				push af  
ab96 3a aa ab			ld a, (.dmark)  
ab99 32 6b ee			ld (debug_mark),a  
ab9c 3a ab ab			ld a, (.dmark+1)  
ab9f 32 6c ee			ld (debug_mark+1),a  
aba2 3a ac ab			ld a, (.dmark+2)  
aba5 32 6d ee			ld (debug_mark+2),a  
aba8 18 03			jr .pastdmark  
abaa ..			.dmark: db "+2a"  
abad f1			.pastdmark: pop af  
abae			endm  
# End of macro DMARK
abae						CALLMONITOR 
abae cd 6f ee			call debug_vector  
abb1				endm  
# End of macro CALLMONITOR
abb1					endif 
abb1			 
abb1					FORTH_DSP_POP 
abb1 cd 4f 9d			call macro_forth_dsp_pop 
abb4				endm 
# End of macro FORTH_DSP_POP
abb4			 
abb4					; Get value to add 
abb4			 
abb4					FORTH_DSP_VALUE 
abb4 cd 80 9c			call macro_forth_dsp_value 
abb7				endm 
# End of macro FORTH_DSP_VALUE
abb7			 
abb7					if DEBUG_FORTH_WORDS 
abb7						DMARK "+2v" 
abb7 f5				push af  
abb8 3a cc ab			ld a, (.dmark)  
abbb 32 6b ee			ld (debug_mark),a  
abbe 3a cd ab			ld a, (.dmark+1)  
abc1 32 6c ee			ld (debug_mark+1),a  
abc4 3a ce ab			ld a, (.dmark+2)  
abc7 32 6d ee			ld (debug_mark+2),a  
abca 18 03			jr .pastdmark  
abcc ..			.dmark: db "+2v"  
abcf f1			.pastdmark: pop af  
abd0			endm  
# End of macro DMARK
abd0						CALLMONITOR 
abd0 cd 6f ee			call debug_vector  
abd3				endm  
# End of macro CALLMONITOR
abd3					endif 
abd3			 
abd3 19					add hl, de 
abd4			 
abd4					if DEBUG_FORTH_WORDS 
abd4						DMARK "+2+" 
abd4 f5				push af  
abd5 3a e9 ab			ld a, (.dmark)  
abd8 32 6b ee			ld (debug_mark),a  
abdb 3a ea ab			ld a, (.dmark+1)  
abde 32 6c ee			ld (debug_mark+1),a  
abe1 3a eb ab			ld a, (.dmark+2)  
abe4 32 6d ee			ld (debug_mark+2),a  
abe7 18 03			jr .pastdmark  
abe9 ..			.dmark: db "+2+"  
abec f1			.pastdmark: pop af  
abed			endm  
# End of macro DMARK
abed						CALLMONITOR 
abed cd 6f ee			call debug_vector  
abf0				endm  
# End of macro CALLMONITOR
abf0					endif 
abf0			 
abf0					; move result to de 
abf0			 
abf0 eb					ex de, hl 
abf1			 
abf1					; Address 
abf1			 
abf1 e1					pop hl 
abf2			 
abf2					; save it back 
abf2			 
abf2 73					ld (hl), e 
abf3 23					inc hl 
abf4 72					ld (hl), d 
abf5			 
abf5					if DEBUG_FORTH_WORDS 
abf5						DMARK "+2e" 
abf5 f5				push af  
abf6 3a 0a ac			ld a, (.dmark)  
abf9 32 6b ee			ld (debug_mark),a  
abfc 3a 0b ac			ld a, (.dmark+1)  
abff 32 6c ee			ld (debug_mark+1),a  
ac02 3a 0c ac			ld a, (.dmark+2)  
ac05 32 6d ee			ld (debug_mark+2),a  
ac08 18 03			jr .pastdmark  
ac0a ..			.dmark: db "+2e"  
ac0d f1			.pastdmark: pop af  
ac0e			endm  
# End of macro DMARK
ac0e						CALLMONITOR 
ac0e cd 6f ee			call debug_vector  
ac11				endm  
# End of macro CALLMONITOR
ac11					endif 
ac11			 
ac11			 
ac11			 
ac11					FORTH_DSP_POP 
ac11 cd 4f 9d			call macro_forth_dsp_pop 
ac14				endm 
# End of macro FORTH_DSP_POP
ac14			 
ac14			 
ac14				       NEXTW 
ac14 c3 4d 9e			jp macro_next 
ac17				endm 
# End of macro NEXTW
ac17			 
ac17			.DEC2: 
ac17				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac17 6f				db WORD_SYS_CORE+91             
ac18 c6 ac			dw .GET2            
ac1a 04				db 3 + 1 
ac1b .. 00			db "-2!",0              
ac1f				endm 
# End of macro CWHEAD
ac1f			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac1f			 
ac1f			 
ac1f					if DEBUG_FORTH_WORDS_KEY 
ac1f						DMARK "-2s" 
ac1f f5				push af  
ac20 3a 34 ac			ld a, (.dmark)  
ac23 32 6b ee			ld (debug_mark),a  
ac26 3a 35 ac			ld a, (.dmark+1)  
ac29 32 6c ee			ld (debug_mark+1),a  
ac2c 3a 36 ac			ld a, (.dmark+2)  
ac2f 32 6d ee			ld (debug_mark+2),a  
ac32 18 03			jr .pastdmark  
ac34 ..			.dmark: db "-2s"  
ac37 f1			.pastdmark: pop af  
ac38			endm  
# End of macro DMARK
ac38						CALLMONITOR 
ac38 cd 6f ee			call debug_vector  
ac3b				endm  
# End of macro CALLMONITOR
ac3b					endif 
ac3b			 
ac3b					; Address 
ac3b			 
ac3b					FORTH_DSP_VALUEHL 
ac3b cd 97 9c			call macro_dsp_valuehl 
ac3e				endm 
# End of macro FORTH_DSP_VALUEHL
ac3e			 
ac3e e5					push hl    ; save address 
ac3f			 
ac3f					; load content into de 
ac3f			 
ac3f 5e					ld e,(hl) 
ac40 23					inc hl 
ac41 56					ld d, (hl) 
ac42			 
ac42					if DEBUG_FORTH_WORDS 
ac42						DMARK "-2a" 
ac42 f5				push af  
ac43 3a 57 ac			ld a, (.dmark)  
ac46 32 6b ee			ld (debug_mark),a  
ac49 3a 58 ac			ld a, (.dmark+1)  
ac4c 32 6c ee			ld (debug_mark+1),a  
ac4f 3a 59 ac			ld a, (.dmark+2)  
ac52 32 6d ee			ld (debug_mark+2),a  
ac55 18 03			jr .pastdmark  
ac57 ..			.dmark: db "-2a"  
ac5a f1			.pastdmark: pop af  
ac5b			endm  
# End of macro DMARK
ac5b						CALLMONITOR 
ac5b cd 6f ee			call debug_vector  
ac5e				endm  
# End of macro CALLMONITOR
ac5e					endif 
ac5e			 
ac5e					FORTH_DSP_POP 
ac5e cd 4f 9d			call macro_forth_dsp_pop 
ac61				endm 
# End of macro FORTH_DSP_POP
ac61			 
ac61					; Get value to remove 
ac61			 
ac61					FORTH_DSP_VALUE 
ac61 cd 80 9c			call macro_forth_dsp_value 
ac64				endm 
# End of macro FORTH_DSP_VALUE
ac64			 
ac64					if DEBUG_FORTH_WORDS 
ac64						DMARK "-2v" 
ac64 f5				push af  
ac65 3a 79 ac			ld a, (.dmark)  
ac68 32 6b ee			ld (debug_mark),a  
ac6b 3a 7a ac			ld a, (.dmark+1)  
ac6e 32 6c ee			ld (debug_mark+1),a  
ac71 3a 7b ac			ld a, (.dmark+2)  
ac74 32 6d ee			ld (debug_mark+2),a  
ac77 18 03			jr .pastdmark  
ac79 ..			.dmark: db "-2v"  
ac7c f1			.pastdmark: pop af  
ac7d			endm  
# End of macro DMARK
ac7d						CALLMONITOR 
ac7d cd 6f ee			call debug_vector  
ac80				endm  
# End of macro CALLMONITOR
ac80					endif 
ac80			 
ac80 eb					ex de, hl 
ac81 ed 52				sbc hl, de 
ac83			 
ac83					if DEBUG_FORTH_WORDS 
ac83						DMARK "-2d" 
ac83 f5				push af  
ac84 3a 98 ac			ld a, (.dmark)  
ac87 32 6b ee			ld (debug_mark),a  
ac8a 3a 99 ac			ld a, (.dmark+1)  
ac8d 32 6c ee			ld (debug_mark+1),a  
ac90 3a 9a ac			ld a, (.dmark+2)  
ac93 32 6d ee			ld (debug_mark+2),a  
ac96 18 03			jr .pastdmark  
ac98 ..			.dmark: db "-2d"  
ac9b f1			.pastdmark: pop af  
ac9c			endm  
# End of macro DMARK
ac9c						CALLMONITOR 
ac9c cd 6f ee			call debug_vector  
ac9f				endm  
# End of macro CALLMONITOR
ac9f					endif 
ac9f			 
ac9f					; move result to de 
ac9f			 
ac9f eb					ex de, hl 
aca0			 
aca0					; Address 
aca0			 
aca0 e1					pop hl 
aca1			 
aca1					; save it back 
aca1			 
aca1 73					ld (hl), e 
aca2 23					inc hl 
aca3 72					ld (hl), d 
aca4			 
aca4					if DEBUG_FORTH_WORDS 
aca4						DMARK "-2e" 
aca4 f5				push af  
aca5 3a b9 ac			ld a, (.dmark)  
aca8 32 6b ee			ld (debug_mark),a  
acab 3a ba ac			ld a, (.dmark+1)  
acae 32 6c ee			ld (debug_mark+1),a  
acb1 3a bb ac			ld a, (.dmark+2)  
acb4 32 6d ee			ld (debug_mark+2),a  
acb7 18 03			jr .pastdmark  
acb9 ..			.dmark: db "-2e"  
acbc f1			.pastdmark: pop af  
acbd			endm  
# End of macro DMARK
acbd						CALLMONITOR 
acbd cd 6f ee			call debug_vector  
acc0				endm  
# End of macro CALLMONITOR
acc0					endif 
acc0			 
acc0			 
acc0					FORTH_DSP_POP 
acc0 cd 4f 9d			call macro_forth_dsp_pop 
acc3				endm 
# End of macro FORTH_DSP_POP
acc3			 
acc3			 
acc3			 
acc3				       NEXTW 
acc3 c3 4d 9e			jp macro_next 
acc6				endm 
# End of macro NEXTW
acc6			.GET2: 
acc6				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
acc6 6f				db WORD_SYS_CORE+91             
acc7 fb ac			dw .BANG2            
acc9 03				db 2 + 1 
acca .. 00			db "2@",0              
accd				endm 
# End of macro CWHEAD
accd			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
accd					if DEBUG_FORTH_WORDS_KEY 
accd						DMARK "2A_" 
accd f5				push af  
acce 3a e2 ac			ld a, (.dmark)  
acd1 32 6b ee			ld (debug_mark),a  
acd4 3a e3 ac			ld a, (.dmark+1)  
acd7 32 6c ee			ld (debug_mark+1),a  
acda 3a e4 ac			ld a, (.dmark+2)  
acdd 32 6d ee			ld (debug_mark+2),a  
ace0 18 03			jr .pastdmark  
ace2 ..			.dmark: db "2A_"  
ace5 f1			.pastdmark: pop af  
ace6			endm  
# End of macro DMARK
ace6						CALLMONITOR 
ace6 cd 6f ee			call debug_vector  
ace9				endm  
# End of macro CALLMONITOR
ace9					endif 
ace9			 
ace9					FORTH_DSP_VALUEHL 
ace9 cd 97 9c			call macro_dsp_valuehl 
acec				endm 
# End of macro FORTH_DSP_VALUEHL
acec			 
acec e5					push hl   ; save address 
aced			 
aced					FORTH_DSP_POP 
aced cd 4f 9d			call macro_forth_dsp_pop 
acf0				endm 
# End of macro FORTH_DSP_POP
acf0			 
acf0 e1					pop hl 
acf1			 
acf1 5e					ld e, (hl) 
acf2 23					inc hl 
acf3 56					ld d, (hl) 
acf4			 
acf4 eb					ex de, hl 
acf5			 
acf5 cd a0 9a				call forth_push_numhl 
acf8			 
acf8				       NEXTW 
acf8 c3 4d 9e			jp macro_next 
acfb				endm 
# End of macro NEXTW
acfb			.BANG2: 
acfb				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
acfb 6f				db WORD_SYS_CORE+91             
acfc 33 ad			dw .CONFIG            
acfe 03				db 2 + 1 
acff .. 00			db "2!",0              
ad02				endm 
# End of macro CWHEAD
ad02			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad02					if DEBUG_FORTH_WORDS_KEY 
ad02						DMARK "2S_" 
ad02 f5				push af  
ad03 3a 17 ad			ld a, (.dmark)  
ad06 32 6b ee			ld (debug_mark),a  
ad09 3a 18 ad			ld a, (.dmark+1)  
ad0c 32 6c ee			ld (debug_mark+1),a  
ad0f 3a 19 ad			ld a, (.dmark+2)  
ad12 32 6d ee			ld (debug_mark+2),a  
ad15 18 03			jr .pastdmark  
ad17 ..			.dmark: db "2S_"  
ad1a f1			.pastdmark: pop af  
ad1b			endm  
# End of macro DMARK
ad1b						CALLMONITOR 
ad1b cd 6f ee			call debug_vector  
ad1e				endm  
# End of macro CALLMONITOR
ad1e					endif 
ad1e			 
ad1e					FORTH_DSP_VALUEHL 
ad1e cd 97 9c			call macro_dsp_valuehl 
ad21				endm 
# End of macro FORTH_DSP_VALUEHL
ad21			 
ad21 e5					push hl   ; save address 
ad22			 
ad22			 
ad22					FORTH_DSP_POP 
ad22 cd 4f 9d			call macro_forth_dsp_pop 
ad25				endm 
# End of macro FORTH_DSP_POP
ad25			 
ad25					 
ad25					FORTH_DSP_VALUEHL 
ad25 cd 97 9c			call macro_dsp_valuehl 
ad28				endm 
# End of macro FORTH_DSP_VALUEHL
ad28			 
ad28					FORTH_DSP_POP 
ad28 cd 4f 9d			call macro_forth_dsp_pop 
ad2b				endm 
# End of macro FORTH_DSP_POP
ad2b			 
ad2b eb					ex de, hl    ; value now in de 
ad2c			 
ad2c e1					pop hl 
ad2d			 
ad2d 73					ld (hl), e 
ad2e			 
ad2e 23					inc hl 
ad2f			 
ad2f 72					ld (hl), d 
ad30			 
ad30			 
ad30				       NEXTW 
ad30 c3 4d 9e			jp macro_next 
ad33				endm 
# End of macro NEXTW
ad33			.CONFIG: 
ad33				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
ad33 6f				db WORD_SYS_CORE+91             
ad34 44 ad			dw .ADTOS            
ad36 07				db 6 + 1 
ad37 .. 00			db "CONFIG",0              
ad3e				endm 
# End of macro CWHEAD
ad3e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad3e			 
ad3e cd a0 92				call config 
ad41					NEXTW 
ad41 c3 4d 9e			jp macro_next 
ad44				endm 
# End of macro NEXTW
ad44			 
ad44			.ADTOS: 
ad44				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
ad44 6f				db WORD_SYS_CORE+91             
ad45 5a ad			dw .SBTOS            
ad47 03				db 2 + 1 
ad48 .. 00			db "1+",0              
ad4b				endm 
# End of macro CWHEAD
ad4b			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ad4b			 
ad4b					FORTH_DSP_VALUEHL 
ad4b cd 97 9c			call macro_dsp_valuehl 
ad4e				endm 
# End of macro FORTH_DSP_VALUEHL
ad4e e5					push hl 
ad4f			 
ad4f					FORTH_DSP_POP 
ad4f cd 4f 9d			call macro_forth_dsp_pop 
ad52				endm 
# End of macro FORTH_DSP_POP
ad52 e1					pop hl 
ad53			 
ad53 23					inc hl 
ad54 cd a0 9a				call forth_push_numhl 
ad57					 
ad57					NEXTW 
ad57 c3 4d 9e			jp macro_next 
ad5a				endm 
# End of macro NEXTW
ad5a			.SBTOS: 
ad5a				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ad5a 6f				db WORD_SYS_CORE+91             
ad5b 70 ad			dw .ADSTORE            
ad5d 03				db 2 + 1 
ad5e .. 00			db "1-",0              
ad61				endm 
# End of macro CWHEAD
ad61			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ad61			 
ad61					FORTH_DSP_VALUEHL 
ad61 cd 97 9c			call macro_dsp_valuehl 
ad64				endm 
# End of macro FORTH_DSP_VALUEHL
ad64 e5					push hl 
ad65			 
ad65					FORTH_DSP_POP 
ad65 cd 4f 9d			call macro_forth_dsp_pop 
ad68				endm 
# End of macro FORTH_DSP_POP
ad68 e1					pop hl 
ad69			 
ad69 2b					dec hl 
ad6a cd a0 9a				call forth_push_numhl 
ad6d					 
ad6d					NEXTW 
ad6d c3 4d 9e			jp macro_next 
ad70				endm 
# End of macro NEXTW
ad70			.ADSTORE: 
ad70				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ad70 6f				db WORD_SYS_CORE+91             
ad71 86 ad			dw .ADWSTORE            
ad73 04				db 3 + 1 
ad74 .. 00			db "1+!",0              
ad78				endm 
# End of macro CWHEAD
ad78			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ad78			 
ad78					FORTH_DSP_VALUEHL 
ad78 cd 97 9c			call macro_dsp_valuehl 
ad7b				endm 
# End of macro FORTH_DSP_VALUEHL
ad7b e5					push hl 
ad7c			 
ad7c					FORTH_DSP_POP 
ad7c cd 4f 9d			call macro_forth_dsp_pop 
ad7f				endm 
# End of macro FORTH_DSP_POP
ad7f e1					pop hl 
ad80			 
ad80 7e					ld a, (hl) 
ad81 3c					inc a 
ad82 77					ld (hl), a 
ad83					 
ad83					NEXTW 
ad83 c3 4d 9e			jp macro_next 
ad86				endm 
# End of macro NEXTW
ad86			.ADWSTORE: 
ad86				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ad86 6f				db WORD_SYS_CORE+91             
ad87 a4 ad			dw .SBSTORE            
ad89 05				db 4 + 1 
ad8a .. 00			db "1+2!",0              
ad8f				endm 
# End of macro CWHEAD
ad8f			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ad8f			 
ad8f					FORTH_DSP_VALUEHL 
ad8f cd 97 9c			call macro_dsp_valuehl 
ad92				endm 
# End of macro FORTH_DSP_VALUEHL
ad92 e5					push hl 
ad93			 
ad93					FORTH_DSP_POP 
ad93 cd 4f 9d			call macro_forth_dsp_pop 
ad96				endm 
# End of macro FORTH_DSP_POP
ad96 e1					pop hl 
ad97			 
ad97 e5					push hl 
ad98			 
ad98 cd cf 9d				call loadwordinhl 
ad9b 23					inc hl 
ad9c			 
ad9c d1					pop de 
ad9d eb					ex de, hl 
ad9e 73					ld (hl), e 
ad9f 23					inc hl 
ada0 72					ld (hl), d 
ada1					 
ada1					NEXTW 
ada1 c3 4d 9e			jp macro_next 
ada4				endm 
# End of macro NEXTW
ada4			.SBSTORE: 
ada4				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ada4 6f				db WORD_SYS_CORE+91             
ada5 ba ad			dw .SBWSTORE            
ada7 04				db 3 + 1 
ada8 .. 00			db "1-!",0              
adac				endm 
# End of macro CWHEAD
adac			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
adac			 
adac					FORTH_DSP_VALUEHL 
adac cd 97 9c			call macro_dsp_valuehl 
adaf				endm 
# End of macro FORTH_DSP_VALUEHL
adaf e5					push hl 
adb0			 
adb0					FORTH_DSP_POP 
adb0 cd 4f 9d			call macro_forth_dsp_pop 
adb3				endm 
# End of macro FORTH_DSP_POP
adb3 e1					pop hl 
adb4			 
adb4 7e					ld a, (hl) 
adb5 3d					dec a 
adb6 77					ld (hl), a 
adb7					 
adb7					NEXTW 
adb7 c3 4d 9e			jp macro_next 
adba				endm 
# End of macro NEXTW
adba			.SBWSTORE: 
adba				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
adba 6f				db WORD_SYS_CORE+91             
adbb d8 ad			dw .ENDCORE            
adbd 05				db 4 + 1 
adbe .. 00			db "1-2!",0              
adc3				endm 
# End of macro CWHEAD
adc3			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
adc3			 
adc3					FORTH_DSP_VALUEHL 
adc3 cd 97 9c			call macro_dsp_valuehl 
adc6				endm 
# End of macro FORTH_DSP_VALUEHL
adc6 e5					push hl 
adc7			 
adc7					FORTH_DSP_POP 
adc7 cd 4f 9d			call macro_forth_dsp_pop 
adca				endm 
# End of macro FORTH_DSP_POP
adca e1					pop hl 
adcb			 
adcb e5					push hl 
adcc			 
adcc cd cf 9d				call loadwordinhl 
adcf 2b					dec hl 
add0			 
add0 d1					pop de 
add1 eb					ex de, hl 
add2 73					ld (hl), e 
add3 23					inc hl 
add4 72					ld (hl), d 
add5					 
add5					NEXTW 
add5 c3 4d 9e			jp macro_next 
add8				endm 
# End of macro NEXTW
add8			.ENDCORE: 
add8			 
add8			; eof 
add8			 
add8			 
# End of file forth_words_core.asm
add8			include "forth_words_flow.asm" 
add8			 
add8			; | ## Program Flow Words 
add8			 
add8			.IF: 
add8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
add8 1e				db WORD_SYS_CORE+10             
add9 cd ae			dw .THEN            
addb 03				db 2 + 1 
addc .. 00			db "IF",0              
addf				endm 
# End of macro CWHEAD
addf			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
addf			; 
addf					if DEBUG_FORTH_WORDS_KEY 
addf						DMARK "IF." 
addf f5				push af  
ade0 3a f4 ad			ld a, (.dmark)  
ade3 32 6b ee			ld (debug_mark),a  
ade6 3a f5 ad			ld a, (.dmark+1)  
ade9 32 6c ee			ld (debug_mark+1),a  
adec 3a f6 ad			ld a, (.dmark+2)  
adef 32 6d ee			ld (debug_mark+2),a  
adf2 18 03			jr .pastdmark  
adf4 ..			.dmark: db "IF."  
adf7 f1			.pastdmark: pop af  
adf8			endm  
# End of macro DMARK
adf8						CALLMONITOR 
adf8 cd 6f ee			call debug_vector  
adfb				endm  
# End of macro CALLMONITOR
adfb					endif 
adfb			; eval TOS 
adfb			 
adfb				FORTH_DSP_VALUEHL 
adfb cd 97 9c			call macro_dsp_valuehl 
adfe				endm 
# End of macro FORTH_DSP_VALUEHL
adfe			 
adfe			;	push hl 
adfe				FORTH_DSP_POP 
adfe cd 4f 9d			call macro_forth_dsp_pop 
ae01				endm 
# End of macro FORTH_DSP_POP
ae01			;	pop hl 
ae01			 
ae01					if DEBUG_FORTH_WORDS 
ae01						DMARK "IF1" 
ae01 f5				push af  
ae02 3a 16 ae			ld a, (.dmark)  
ae05 32 6b ee			ld (debug_mark),a  
ae08 3a 17 ae			ld a, (.dmark+1)  
ae0b 32 6c ee			ld (debug_mark+1),a  
ae0e 3a 18 ae			ld a, (.dmark+2)  
ae11 32 6d ee			ld (debug_mark+2),a  
ae14 18 03			jr .pastdmark  
ae16 ..			.dmark: db "IF1"  
ae19 f1			.pastdmark: pop af  
ae1a			endm  
# End of macro DMARK
ae1a						CALLMONITOR 
ae1a cd 6f ee			call debug_vector  
ae1d				endm  
# End of macro CALLMONITOR
ae1d					endif 
ae1d b7				or a        ; clear carry flag 
ae1e 11 00 00			ld de, 0 
ae21 eb				ex de,hl 
ae22 ed 52			sbc hl, de 
ae24 c2 ae ae			jp nz, .iftrue 
ae27			 
ae27					if DEBUG_FORTH_WORDS 
ae27						DMARK "IF2" 
ae27 f5				push af  
ae28 3a 3c ae			ld a, (.dmark)  
ae2b 32 6b ee			ld (debug_mark),a  
ae2e 3a 3d ae			ld a, (.dmark+1)  
ae31 32 6c ee			ld (debug_mark+1),a  
ae34 3a 3e ae			ld a, (.dmark+2)  
ae37 32 6d ee			ld (debug_mark+2),a  
ae3a 18 03			jr .pastdmark  
ae3c ..			.dmark: db "IF2"  
ae3f f1			.pastdmark: pop af  
ae40			endm  
# End of macro DMARK
ae40						CALLMONITOR 
ae40 cd 6f ee			call debug_vector  
ae43				endm  
# End of macro CALLMONITOR
ae43					endif 
ae43			 
ae43			; if not true then skip to THEN 
ae43			 
ae43				; TODO get tok_ptr 
ae43				; TODO consume toks until we get to THEN 
ae43			 
ae43 2a c2 e5			ld hl, (os_tok_ptr) 
ae46					if DEBUG_FORTH_WORDS 
ae46						DMARK "IF3" 
ae46 f5				push af  
ae47 3a 5b ae			ld a, (.dmark)  
ae4a 32 6b ee			ld (debug_mark),a  
ae4d 3a 5c ae			ld a, (.dmark+1)  
ae50 32 6c ee			ld (debug_mark+1),a  
ae53 3a 5d ae			ld a, (.dmark+2)  
ae56 32 6d ee			ld (debug_mark+2),a  
ae59 18 03			jr .pastdmark  
ae5b ..			.dmark: db "IF3"  
ae5e f1			.pastdmark: pop af  
ae5f			endm  
# End of macro DMARK
ae5f						CALLMONITOR 
ae5f cd 6f ee			call debug_vector  
ae62				endm  
# End of macro CALLMONITOR
ae62						 
ae62					endif 
ae62 11 a9 ae			ld de, .ifthen 
ae65					if DEBUG_FORTH_WORDS 
ae65						DMARK "IF4" 
ae65 f5				push af  
ae66 3a 7a ae			ld a, (.dmark)  
ae69 32 6b ee			ld (debug_mark),a  
ae6c 3a 7b ae			ld a, (.dmark+1)  
ae6f 32 6c ee			ld (debug_mark+1),a  
ae72 3a 7c ae			ld a, (.dmark+2)  
ae75 32 6d ee			ld (debug_mark+2),a  
ae78 18 03			jr .pastdmark  
ae7a ..			.dmark: db "IF4"  
ae7d f1			.pastdmark: pop af  
ae7e			endm  
# End of macro DMARK
ae7e						CALLMONITOR 
ae7e cd 6f ee			call debug_vector  
ae81				endm  
# End of macro CALLMONITOR
ae81					endif 
ae81 cd 68 9f			call findnexttok  
ae84			 
ae84					if DEBUG_FORTH_WORDS 
ae84						DMARK "IF5" 
ae84 f5				push af  
ae85 3a 99 ae			ld a, (.dmark)  
ae88 32 6b ee			ld (debug_mark),a  
ae8b 3a 9a ae			ld a, (.dmark+1)  
ae8e 32 6c ee			ld (debug_mark+1),a  
ae91 3a 9b ae			ld a, (.dmark+2)  
ae94 32 6d ee			ld (debug_mark+2),a  
ae97 18 03			jr .pastdmark  
ae99 ..			.dmark: db "IF5"  
ae9c f1			.pastdmark: pop af  
ae9d			endm  
# End of macro DMARK
ae9d						CALLMONITOR 
ae9d cd 6f ee			call debug_vector  
aea0				endm  
# End of macro CALLMONITOR
aea0					endif 
aea0				; TODO replace below with ; exec using tok_ptr 
aea0 22 c2 e5			ld (os_tok_ptr), hl 
aea3 c3 de 9e			jp exec1 
aea6				NEXTW 
aea6 c3 4d 9e			jp macro_next 
aea9				endm 
# End of macro NEXTW
aea9			 
aea9 .. 00		.ifthen:  db "THEN",0 
aeae			 
aeae			.iftrue:		 
aeae				; Exec next words normally 
aeae			 
aeae				; if true then exec following IF as normal 
aeae					if DEBUG_FORTH_WORDS 
aeae						DMARK "IFT" 
aeae f5				push af  
aeaf 3a c3 ae			ld a, (.dmark)  
aeb2 32 6b ee			ld (debug_mark),a  
aeb5 3a c4 ae			ld a, (.dmark+1)  
aeb8 32 6c ee			ld (debug_mark+1),a  
aebb 3a c5 ae			ld a, (.dmark+2)  
aebe 32 6d ee			ld (debug_mark+2),a  
aec1 18 03			jr .pastdmark  
aec3 ..			.dmark: db "IFT"  
aec6 f1			.pastdmark: pop af  
aec7			endm  
# End of macro DMARK
aec7						CALLMONITOR 
aec7 cd 6f ee			call debug_vector  
aeca				endm  
# End of macro CALLMONITOR
aeca					endif 
aeca			 
aeca					NEXTW 
aeca c3 4d 9e			jp macro_next 
aecd				endm 
# End of macro NEXTW
aecd			.THEN: 
aecd				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aecd 1f				db WORD_SYS_CORE+11             
aece f5 ae			dw .ELSE            
aed0 05				db 4 + 1 
aed1 .. 00			db "THEN",0              
aed6				endm 
# End of macro CWHEAD
aed6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aed6					if DEBUG_FORTH_WORDS_KEY 
aed6						DMARK "THN" 
aed6 f5				push af  
aed7 3a eb ae			ld a, (.dmark)  
aeda 32 6b ee			ld (debug_mark),a  
aedd 3a ec ae			ld a, (.dmark+1)  
aee0 32 6c ee			ld (debug_mark+1),a  
aee3 3a ed ae			ld a, (.dmark+2)  
aee6 32 6d ee			ld (debug_mark+2),a  
aee9 18 03			jr .pastdmark  
aeeb ..			.dmark: db "THN"  
aeee f1			.pastdmark: pop af  
aeef			endm  
# End of macro DMARK
aeef						CALLMONITOR 
aeef cd 6f ee			call debug_vector  
aef2				endm  
# End of macro CALLMONITOR
aef2					endif 
aef2					NEXTW 
aef2 c3 4d 9e			jp macro_next 
aef5				endm 
# End of macro NEXTW
aef5			.ELSE: 
aef5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aef5 20				db WORD_SYS_CORE+12             
aef6 1d af			dw .DO            
aef8 03				db 2 + 1 
aef9 .. 00			db "ELSE",0              
aefe				endm 
# End of macro CWHEAD
aefe			; | ELSE ( -- ) Not supported - does nothing | TODO 
aefe			 
aefe					if DEBUG_FORTH_WORDS_KEY 
aefe						DMARK "ELS" 
aefe f5				push af  
aeff 3a 13 af			ld a, (.dmark)  
af02 32 6b ee			ld (debug_mark),a  
af05 3a 14 af			ld a, (.dmark+1)  
af08 32 6c ee			ld (debug_mark+1),a  
af0b 3a 15 af			ld a, (.dmark+2)  
af0e 32 6d ee			ld (debug_mark+2),a  
af11 18 03			jr .pastdmark  
af13 ..			.dmark: db "ELS"  
af16 f1			.pastdmark: pop af  
af17			endm  
# End of macro DMARK
af17						CALLMONITOR 
af17 cd 6f ee			call debug_vector  
af1a				endm  
# End of macro CALLMONITOR
af1a					endif 
af1a			 
af1a			 
af1a					NEXTW 
af1a c3 4d 9e			jp macro_next 
af1d				endm 
# End of macro NEXTW
af1d			.DO: 
af1d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af1d 21				db WORD_SYS_CORE+13             
af1e 44 b0			dw .LOOP            
af20 03				db 2 + 1 
af21 .. 00			db "DO",0              
af24				endm 
# End of macro CWHEAD
af24			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af24			 
af24					if DEBUG_FORTH_WORDS_KEY 
af24						DMARK "DO." 
af24 f5				push af  
af25 3a 39 af			ld a, (.dmark)  
af28 32 6b ee			ld (debug_mark),a  
af2b 3a 3a af			ld a, (.dmark+1)  
af2e 32 6c ee			ld (debug_mark+1),a  
af31 3a 3b af			ld a, (.dmark+2)  
af34 32 6d ee			ld (debug_mark+2),a  
af37 18 03			jr .pastdmark  
af39 ..			.dmark: db "DO."  
af3c f1			.pastdmark: pop af  
af3d			endm  
# End of macro DMARK
af3d						CALLMONITOR 
af3d cd 6f ee			call debug_vector  
af40				endm  
# End of macro CALLMONITOR
af40					endif 
af40			;  push pc to rsp stack past the DO 
af40			 
af40 2a c2 e5				ld hl, (os_tok_ptr) 
af43 23					inc hl   ; D 
af44 23					inc hl  ; O 
af45 23					inc hl   ; null 
af46					if DEBUG_FORTH_WORDS 
af46						DMARK "DO2" 
af46 f5				push af  
af47 3a 5b af			ld a, (.dmark)  
af4a 32 6b ee			ld (debug_mark),a  
af4d 3a 5c af			ld a, (.dmark+1)  
af50 32 6c ee			ld (debug_mark+1),a  
af53 3a 5d af			ld a, (.dmark+2)  
af56 32 6d ee			ld (debug_mark+2),a  
af59 18 03			jr .pastdmark  
af5b ..			.dmark: db "DO2"  
af5e f1			.pastdmark: pop af  
af5f			endm  
# End of macro DMARK
af5f						CALLMONITOR 
af5f cd 6f ee			call debug_vector  
af62				endm  
# End of macro CALLMONITOR
af62					endif 
af62					FORTH_RSP_NEXT 
af62 cd 47 9a			call macro_forth_rsp_next 
af65				endm 
# End of macro FORTH_RSP_NEXT
af65					if DEBUG_FORTH_WORDS 
af65						DMARK "DO3" 
af65 f5				push af  
af66 3a 7a af			ld a, (.dmark)  
af69 32 6b ee			ld (debug_mark),a  
af6c 3a 7b af			ld a, (.dmark+1)  
af6f 32 6c ee			ld (debug_mark+1),a  
af72 3a 7c af			ld a, (.dmark+2)  
af75 32 6d ee			ld (debug_mark+2),a  
af78 18 03			jr .pastdmark  
af7a ..			.dmark: db "DO3"  
af7d f1			.pastdmark: pop af  
af7e			endm  
# End of macro DMARK
af7e						CALLMONITOR 
af7e cd 6f ee			call debug_vector  
af81				endm  
# End of macro CALLMONITOR
af81					endif 
af81			 
af81					;if DEBUG_FORTH_WORDS 
af81				;		push hl 
af81			;		endif  
af81			 
af81			; get counters from data stack 
af81			 
af81			 
af81					FORTH_DSP_VALUEHL 
af81 cd 97 9c			call macro_dsp_valuehl 
af84				endm 
# End of macro FORTH_DSP_VALUEHL
af84 e5					push hl		 ; hl now has starting counter which needs to be tos 
af85			 
af85					if DEBUG_FORTH_WORDS 
af85						DMARK "DO4" 
af85 f5				push af  
af86 3a 9a af			ld a, (.dmark)  
af89 32 6b ee			ld (debug_mark),a  
af8c 3a 9b af			ld a, (.dmark+1)  
af8f 32 6c ee			ld (debug_mark+1),a  
af92 3a 9c af			ld a, (.dmark+2)  
af95 32 6d ee			ld (debug_mark+2),a  
af98 18 03			jr .pastdmark  
af9a ..			.dmark: db "DO4"  
af9d f1			.pastdmark: pop af  
af9e			endm  
# End of macro DMARK
af9e						CALLMONITOR 
af9e cd 6f ee			call debug_vector  
afa1				endm  
# End of macro CALLMONITOR
afa1					endif 
afa1					FORTH_DSP_POP 
afa1 cd 4f 9d			call macro_forth_dsp_pop 
afa4				endm 
# End of macro FORTH_DSP_POP
afa4			 
afa4					if DEBUG_FORTH_WORDS 
afa4						DMARK "DO5" 
afa4 f5				push af  
afa5 3a b9 af			ld a, (.dmark)  
afa8 32 6b ee			ld (debug_mark),a  
afab 3a ba af			ld a, (.dmark+1)  
afae 32 6c ee			ld (debug_mark+1),a  
afb1 3a bb af			ld a, (.dmark+2)  
afb4 32 6d ee			ld (debug_mark+2),a  
afb7 18 03			jr .pastdmark  
afb9 ..			.dmark: db "DO5"  
afbc f1			.pastdmark: pop af  
afbd			endm  
# End of macro DMARK
afbd						CALLMONITOR 
afbd cd 6f ee			call debug_vector  
afc0				endm  
# End of macro CALLMONITOR
afc0					endif 
afc0			 
afc0					FORTH_DSP_VALUEHL 
afc0 cd 97 9c			call macro_dsp_valuehl 
afc3				endm 
# End of macro FORTH_DSP_VALUEHL
afc3			;		push hl		 ; hl now has starting limit counter 
afc3			 
afc3					if DEBUG_FORTH_WORDS 
afc3						DMARK "DO6" 
afc3 f5				push af  
afc4 3a d8 af			ld a, (.dmark)  
afc7 32 6b ee			ld (debug_mark),a  
afca 3a d9 af			ld a, (.dmark+1)  
afcd 32 6c ee			ld (debug_mark+1),a  
afd0 3a da af			ld a, (.dmark+2)  
afd3 32 6d ee			ld (debug_mark+2),a  
afd6 18 03			jr .pastdmark  
afd8 ..			.dmark: db "DO6"  
afdb f1			.pastdmark: pop af  
afdc			endm  
# End of macro DMARK
afdc						CALLMONITOR 
afdc cd 6f ee			call debug_vector  
afdf				endm  
# End of macro CALLMONITOR
afdf					endif 
afdf					FORTH_DSP_POP 
afdf cd 4f 9d			call macro_forth_dsp_pop 
afe2				endm 
# End of macro FORTH_DSP_POP
afe2			 
afe2			; put counters on the loop stack 
afe2			 
afe2			;		pop hl			 ; limit counter 
afe2 d1					pop de			; start counter 
afe3			 
afe3					; push limit counter 
afe3			 
afe3					if DEBUG_FORTH_WORDS 
afe3						DMARK "DO7" 
afe3 f5				push af  
afe4 3a f8 af			ld a, (.dmark)  
afe7 32 6b ee			ld (debug_mark),a  
afea 3a f9 af			ld a, (.dmark+1)  
afed 32 6c ee			ld (debug_mark+1),a  
aff0 3a fa af			ld a, (.dmark+2)  
aff3 32 6d ee			ld (debug_mark+2),a  
aff6 18 03			jr .pastdmark  
aff8 ..			.dmark: db "DO7"  
affb f1			.pastdmark: pop af  
affc			endm  
# End of macro DMARK
affc						CALLMONITOR 
affc cd 6f ee			call debug_vector  
afff				endm  
# End of macro CALLMONITOR
afff					endif 
afff					FORTH_LOOP_NEXT 
afff cd c8 9c			call macro_forth_loop_next 
b002				endm 
# End of macro FORTH_LOOP_NEXT
b002			 
b002					; push start counter 
b002			 
b002 eb					ex de, hl 
b003					if DEBUG_FORTH_WORDS 
b003						DMARK "DO7" 
b003 f5				push af  
b004 3a 18 b0			ld a, (.dmark)  
b007 32 6b ee			ld (debug_mark),a  
b00a 3a 19 b0			ld a, (.dmark+1)  
b00d 32 6c ee			ld (debug_mark+1),a  
b010 3a 1a b0			ld a, (.dmark+2)  
b013 32 6d ee			ld (debug_mark+2),a  
b016 18 03			jr .pastdmark  
b018 ..			.dmark: db "DO7"  
b01b f1			.pastdmark: pop af  
b01c			endm  
# End of macro DMARK
b01c						CALLMONITOR 
b01c cd 6f ee			call debug_vector  
b01f				endm  
# End of macro CALLMONITOR
b01f					endif 
b01f					FORTH_LOOP_NEXT 
b01f cd c8 9c			call macro_forth_loop_next 
b022				endm 
# End of macro FORTH_LOOP_NEXT
b022			 
b022			 
b022					; init first round of I counter 
b022			 
b022 22 e6 e5				ld (os_current_i), hl 
b025			 
b025					if DEBUG_FORTH_WORDS 
b025						DMARK "DO8" 
b025 f5				push af  
b026 3a 3a b0			ld a, (.dmark)  
b029 32 6b ee			ld (debug_mark),a  
b02c 3a 3b b0			ld a, (.dmark+1)  
b02f 32 6c ee			ld (debug_mark+1),a  
b032 3a 3c b0			ld a, (.dmark+2)  
b035 32 6d ee			ld (debug_mark+2),a  
b038 18 03			jr .pastdmark  
b03a ..			.dmark: db "DO8"  
b03d f1			.pastdmark: pop af  
b03e			endm  
# End of macro DMARK
b03e						CALLMONITOR 
b03e cd 6f ee			call debug_vector  
b041				endm  
# End of macro CALLMONITOR
b041					endif 
b041			 
b041					NEXTW 
b041 c3 4d 9e			jp macro_next 
b044				endm 
# End of macro NEXTW
b044			.LOOP: 
b044				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b044 22				db WORD_SYS_CORE+14             
b045 5c b1			dw .I            
b047 05				db 4 + 1 
b048 .. 00			db "LOOP",0              
b04d				endm 
# End of macro CWHEAD
b04d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b04d			 
b04d				; pop tos as current loop count to hl 
b04d			 
b04d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b04d			 
b04d				FORTH_LOOP_TOS 
b04d cd fb 9c			call macro_forth_loop_tos 
b050				endm 
# End of macro FORTH_LOOP_TOS
b050 e5				push hl 
b051			 
b051					if DEBUG_FORTH_WORDS_KEY 
b051						DMARK "LOP" 
b051 f5				push af  
b052 3a 66 b0			ld a, (.dmark)  
b055 32 6b ee			ld (debug_mark),a  
b058 3a 67 b0			ld a, (.dmark+1)  
b05b 32 6c ee			ld (debug_mark+1),a  
b05e 3a 68 b0			ld a, (.dmark+2)  
b061 32 6d ee			ld (debug_mark+2),a  
b064 18 03			jr .pastdmark  
b066 ..			.dmark: db "LOP"  
b069 f1			.pastdmark: pop af  
b06a			endm  
# End of macro DMARK
b06a						CALLMONITOR 
b06a cd 6f ee			call debug_vector  
b06d				endm  
# End of macro CALLMONITOR
b06d					endif 
b06d				; next item on the stack is the limit. get it 
b06d			 
b06d			 
b06d				FORTH_LOOP_POP 
b06d cd 05 9d			call macro_forth_loop_pop 
b070				endm 
# End of macro FORTH_LOOP_POP
b070			 
b070				FORTH_LOOP_TOS 
b070 cd fb 9c			call macro_forth_loop_tos 
b073				endm 
# End of macro FORTH_LOOP_TOS
b073			 
b073 d1				pop de		 ; de = i, hl = limit 
b074			 
b074					if DEBUG_FORTH_WORDS 
b074						DMARK "LP1" 
b074 f5				push af  
b075 3a 89 b0			ld a, (.dmark)  
b078 32 6b ee			ld (debug_mark),a  
b07b 3a 8a b0			ld a, (.dmark+1)  
b07e 32 6c ee			ld (debug_mark+1),a  
b081 3a 8b b0			ld a, (.dmark+2)  
b084 32 6d ee			ld (debug_mark+2),a  
b087 18 03			jr .pastdmark  
b089 ..			.dmark: db "LP1"  
b08c f1			.pastdmark: pop af  
b08d			endm  
# End of macro DMARK
b08d						CALLMONITOR 
b08d cd 6f ee			call debug_vector  
b090				endm  
# End of macro CALLMONITOR
b090					endif 
b090			 
b090				; go back to previous word 
b090			 
b090 d5				push de    ; save I for inc later 
b091			 
b091			 
b091				; get limit 
b091				;  is I at limit? 
b091			 
b091			 
b091					if DEBUG_FORTH_WORDS 
b091						DMARK "LP1" 
b091 f5				push af  
b092 3a a6 b0			ld a, (.dmark)  
b095 32 6b ee			ld (debug_mark),a  
b098 3a a7 b0			ld a, (.dmark+1)  
b09b 32 6c ee			ld (debug_mark+1),a  
b09e 3a a8 b0			ld a, (.dmark+2)  
b0a1 32 6d ee			ld (debug_mark+2),a  
b0a4 18 03			jr .pastdmark  
b0a6 ..			.dmark: db "LP1"  
b0a9 f1			.pastdmark: pop af  
b0aa			endm  
# End of macro DMARK
b0aa						CALLMONITOR 
b0aa cd 6f ee			call debug_vector  
b0ad				endm  
# End of macro CALLMONITOR
b0ad					endif 
b0ad			 
b0ad ed 52			sbc hl, de 
b0af			 
b0af			 
b0af				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b0af			 
b0af 20 26				jr nz, .loopnotdone 
b0b1			 
b0b1 e1				pop hl   ; get rid of saved I 
b0b2				FORTH_LOOP_POP     ; get rid of limit 
b0b2 cd 05 9d			call macro_forth_loop_pop 
b0b5				endm 
# End of macro FORTH_LOOP_POP
b0b5			 
b0b5				FORTH_RSP_POP     ; get rid of DO ptr 
b0b5 cd 68 9a			call macro_forth_rsp_pop 
b0b8				endm 
# End of macro FORTH_RSP_POP
b0b8			 
b0b8			if DEBUG_FORTH_WORDS 
b0b8						DMARK "LP>" 
b0b8 f5				push af  
b0b9 3a cd b0			ld a, (.dmark)  
b0bc 32 6b ee			ld (debug_mark),a  
b0bf 3a ce b0			ld a, (.dmark+1)  
b0c2 32 6c ee			ld (debug_mark+1),a  
b0c5 3a cf b0			ld a, (.dmark+2)  
b0c8 32 6d ee			ld (debug_mark+2),a  
b0cb 18 03			jr .pastdmark  
b0cd ..			.dmark: db "LP>"  
b0d0 f1			.pastdmark: pop af  
b0d1			endm  
# End of macro DMARK
b0d1				CALLMONITOR 
b0d1 cd 6f ee			call debug_vector  
b0d4				endm  
# End of macro CALLMONITOR
b0d4			endif 
b0d4			 
b0d4					NEXTW 
b0d4 c3 4d 9e			jp macro_next 
b0d7				endm 
# End of macro NEXTW
b0d7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0d7			 
b0d7			.loopnotdone: 
b0d7			 
b0d7 e1				pop hl    ; get I 
b0d8 23				inc hl 
b0d9			 
b0d9			   	; save new I 
b0d9			 
b0d9			 
b0d9					; set I counter 
b0d9			 
b0d9 22 e6 e5				ld (os_current_i), hl 
b0dc			 
b0dc					if DEBUG_FORTH_WORDS 
b0dc						DMARK "LPN" 
b0dc f5				push af  
b0dd 3a f1 b0			ld a, (.dmark)  
b0e0 32 6b ee			ld (debug_mark),a  
b0e3 3a f2 b0			ld a, (.dmark+1)  
b0e6 32 6c ee			ld (debug_mark+1),a  
b0e9 3a f3 b0			ld a, (.dmark+2)  
b0ec 32 6d ee			ld (debug_mark+2),a  
b0ef 18 03			jr .pastdmark  
b0f1 ..			.dmark: db "LPN"  
b0f4 f1			.pastdmark: pop af  
b0f5			endm  
# End of macro DMARK
b0f5					CALLMONITOR 
b0f5 cd 6f ee			call debug_vector  
b0f8				endm  
# End of macro CALLMONITOR
b0f8					endif 
b0f8					 
b0f8				FORTH_LOOP_NEXT 
b0f8 cd c8 9c			call macro_forth_loop_next 
b0fb				endm 
# End of macro FORTH_LOOP_NEXT
b0fb			 
b0fb			 
b0fb					if DEBUG_FORTH_WORDS 
b0fb eb						ex de,hl 
b0fc					endif 
b0fc			 
b0fc			;	; get DO ptr 
b0fc			; 
b0fc					if DEBUG_FORTH_WORDS 
b0fc						DMARK "LP7" 
b0fc f5				push af  
b0fd 3a 11 b1			ld a, (.dmark)  
b100 32 6b ee			ld (debug_mark),a  
b103 3a 12 b1			ld a, (.dmark+1)  
b106 32 6c ee			ld (debug_mark+1),a  
b109 3a 13 b1			ld a, (.dmark+2)  
b10c 32 6d ee			ld (debug_mark+2),a  
b10f 18 03			jr .pastdmark  
b111 ..			.dmark: db "LP7"  
b114 f1			.pastdmark: pop af  
b115			endm  
# End of macro DMARK
b115					CALLMONITOR 
b115 cd 6f ee			call debug_vector  
b118				endm  
# End of macro CALLMONITOR
b118					endif 
b118				FORTH_RSP_TOS 
b118 cd 5e 9a			call macro_forth_rsp_tos 
b11b				endm 
# End of macro FORTH_RSP_TOS
b11b			 
b11b					if DEBUG_FORTH_WORDS 
b11b						DMARK "LP8" 
b11b f5				push af  
b11c 3a 30 b1			ld a, (.dmark)  
b11f 32 6b ee			ld (debug_mark),a  
b122 3a 31 b1			ld a, (.dmark+1)  
b125 32 6c ee			ld (debug_mark+1),a  
b128 3a 32 b1			ld a, (.dmark+2)  
b12b 32 6d ee			ld (debug_mark+2),a  
b12e 18 03			jr .pastdmark  
b130 ..			.dmark: db "LP8"  
b133 f1			.pastdmark: pop af  
b134			endm  
# End of macro DMARK
b134					CALLMONITOR 
b134 cd 6f ee			call debug_vector  
b137				endm  
# End of macro CALLMONITOR
b137					endif 
b137				;push hl 
b137			 
b137				; not going to DO any more 
b137				; get rid of the RSP pointer as DO will add it back in 
b137				;FORTH_RSP_POP 
b137				;pop hl 
b137			 
b137				;ld hl,(cli_ret_sp) 
b137				;ld e, (hl) 
b137				;inc hl 
b137				;ld d, (hl) 
b137				;ex de,hl 
b137 22 c2 e5			ld (os_tok_ptr), hl 
b13a					if DEBUG_FORTH_WORDS 
b13a						DMARK "LP<" 
b13a f5				push af  
b13b 3a 4f b1			ld a, (.dmark)  
b13e 32 6b ee			ld (debug_mark),a  
b141 3a 50 b1			ld a, (.dmark+1)  
b144 32 6c ee			ld (debug_mark+1),a  
b147 3a 51 b1			ld a, (.dmark+2)  
b14a 32 6d ee			ld (debug_mark+2),a  
b14d 18 03			jr .pastdmark  
b14f ..			.dmark: db "LP<"  
b152 f1			.pastdmark: pop af  
b153			endm  
# End of macro DMARK
b153					CALLMONITOR 
b153 cd 6f ee			call debug_vector  
b156				endm  
# End of macro CALLMONITOR
b156				endif 
b156 c3 de 9e			jp exec1 
b159			 
b159					 
b159			 
b159			 
b159					NEXTW 
b159 c3 4d 9e			jp macro_next 
b15c				endm 
# End of macro NEXTW
b15c			.I:  
b15c			 
b15c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b15c 5e				db WORD_SYS_CORE+74             
b15d 87 b1			dw .DLOOP            
b15f 02				db 1 + 1 
b160 .. 00			db "I",0              
b162				endm 
# End of macro CWHEAD
b162			; | I ( -- ) Current loop counter | DONE 
b162					if DEBUG_FORTH_WORDS_KEY 
b162						DMARK "I.." 
b162 f5				push af  
b163 3a 77 b1			ld a, (.dmark)  
b166 32 6b ee			ld (debug_mark),a  
b169 3a 78 b1			ld a, (.dmark+1)  
b16c 32 6c ee			ld (debug_mark+1),a  
b16f 3a 79 b1			ld a, (.dmark+2)  
b172 32 6d ee			ld (debug_mark+2),a  
b175 18 03			jr .pastdmark  
b177 ..			.dmark: db "I.."  
b17a f1			.pastdmark: pop af  
b17b			endm  
# End of macro DMARK
b17b						CALLMONITOR 
b17b cd 6f ee			call debug_vector  
b17e				endm  
# End of macro CALLMONITOR
b17e					endif 
b17e			 
b17e 2a e6 e5				ld hl,(os_current_i) 
b181 cd a0 9a				call forth_push_numhl 
b184			 
b184					NEXTW 
b184 c3 4d 9e			jp macro_next 
b187				endm 
# End of macro NEXTW
b187			.DLOOP: 
b187				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b187 5f				db WORD_SYS_CORE+75             
b188 68 b2			dw .REPEAT            
b18a 06				db 5 + 1 
b18b .. 00			db "-LOOP",0              
b191				endm 
# End of macro CWHEAD
b191			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b191				; pop tos as current loop count to hl 
b191					if DEBUG_FORTH_WORDS_KEY 
b191						DMARK "-LP" 
b191 f5				push af  
b192 3a a6 b1			ld a, (.dmark)  
b195 32 6b ee			ld (debug_mark),a  
b198 3a a7 b1			ld a, (.dmark+1)  
b19b 32 6c ee			ld (debug_mark+1),a  
b19e 3a a8 b1			ld a, (.dmark+2)  
b1a1 32 6d ee			ld (debug_mark+2),a  
b1a4 18 03			jr .pastdmark  
b1a6 ..			.dmark: db "-LP"  
b1a9 f1			.pastdmark: pop af  
b1aa			endm  
# End of macro DMARK
b1aa						CALLMONITOR 
b1aa cd 6f ee			call debug_vector  
b1ad				endm  
# End of macro CALLMONITOR
b1ad					endif 
b1ad			 
b1ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b1ad			 
b1ad				FORTH_LOOP_TOS 
b1ad cd fb 9c			call macro_forth_loop_tos 
b1b0				endm 
# End of macro FORTH_LOOP_TOS
b1b0 e5				push hl 
b1b1			 
b1b1					if DEBUG_FORTH_WORDS 
b1b1						DMARK "-LP" 
b1b1 f5				push af  
b1b2 3a c6 b1			ld a, (.dmark)  
b1b5 32 6b ee			ld (debug_mark),a  
b1b8 3a c7 b1			ld a, (.dmark+1)  
b1bb 32 6c ee			ld (debug_mark+1),a  
b1be 3a c8 b1			ld a, (.dmark+2)  
b1c1 32 6d ee			ld (debug_mark+2),a  
b1c4 18 03			jr .pastdmark  
b1c6 ..			.dmark: db "-LP"  
b1c9 f1			.pastdmark: pop af  
b1ca			endm  
# End of macro DMARK
b1ca						CALLMONITOR 
b1ca cd 6f ee			call debug_vector  
b1cd				endm  
# End of macro CALLMONITOR
b1cd					endif 
b1cd				; next item on the stack is the limit. get it 
b1cd			 
b1cd			 
b1cd				FORTH_LOOP_POP 
b1cd cd 05 9d			call macro_forth_loop_pop 
b1d0				endm 
# End of macro FORTH_LOOP_POP
b1d0			 
b1d0				FORTH_LOOP_TOS 
b1d0 cd fb 9c			call macro_forth_loop_tos 
b1d3				endm 
# End of macro FORTH_LOOP_TOS
b1d3			 
b1d3 d1				pop de		 ; de = i, hl = limit 
b1d4			 
b1d4					if DEBUG_FORTH_WORDS 
b1d4						DMARK "-L1" 
b1d4 f5				push af  
b1d5 3a e9 b1			ld a, (.dmark)  
b1d8 32 6b ee			ld (debug_mark),a  
b1db 3a ea b1			ld a, (.dmark+1)  
b1de 32 6c ee			ld (debug_mark+1),a  
b1e1 3a eb b1			ld a, (.dmark+2)  
b1e4 32 6d ee			ld (debug_mark+2),a  
b1e7 18 03			jr .pastdmark  
b1e9 ..			.dmark: db "-L1"  
b1ec f1			.pastdmark: pop af  
b1ed			endm  
# End of macro DMARK
b1ed						CALLMONITOR 
b1ed cd 6f ee			call debug_vector  
b1f0				endm  
# End of macro CALLMONITOR
b1f0					endif 
b1f0			 
b1f0				; go back to previous word 
b1f0			 
b1f0 d5				push de    ; save I for inc later 
b1f1			 
b1f1			 
b1f1				; get limit 
b1f1				;  is I at limit? 
b1f1			 
b1f1			 
b1f1					if DEBUG_FORTH_WORDS 
b1f1						DMARK "-L1" 
b1f1 f5				push af  
b1f2 3a 06 b2			ld a, (.dmark)  
b1f5 32 6b ee			ld (debug_mark),a  
b1f8 3a 07 b2			ld a, (.dmark+1)  
b1fb 32 6c ee			ld (debug_mark+1),a  
b1fe 3a 08 b2			ld a, (.dmark+2)  
b201 32 6d ee			ld (debug_mark+2),a  
b204 18 03			jr .pastdmark  
b206 ..			.dmark: db "-L1"  
b209 f1			.pastdmark: pop af  
b20a			endm  
# End of macro DMARK
b20a						CALLMONITOR 
b20a cd 6f ee			call debug_vector  
b20d				endm  
# End of macro CALLMONITOR
b20d					endif 
b20d			 
b20d ed 52			sbc hl, de 
b20f			 
b20f			 
b20f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b20f			 
b20f 20 26				jr nz, .mloopnotdone 
b211			 
b211 e1				pop hl   ; get rid of saved I 
b212				FORTH_LOOP_POP     ; get rid of limit 
b212 cd 05 9d			call macro_forth_loop_pop 
b215				endm 
# End of macro FORTH_LOOP_POP
b215			 
b215				FORTH_RSP_POP     ; get rid of DO ptr 
b215 cd 68 9a			call macro_forth_rsp_pop 
b218				endm 
# End of macro FORTH_RSP_POP
b218			 
b218			if DEBUG_FORTH_WORDS 
b218						DMARK "-L>" 
b218 f5				push af  
b219 3a 2d b2			ld a, (.dmark)  
b21c 32 6b ee			ld (debug_mark),a  
b21f 3a 2e b2			ld a, (.dmark+1)  
b222 32 6c ee			ld (debug_mark+1),a  
b225 3a 2f b2			ld a, (.dmark+2)  
b228 32 6d ee			ld (debug_mark+2),a  
b22b 18 03			jr .pastdmark  
b22d ..			.dmark: db "-L>"  
b230 f1			.pastdmark: pop af  
b231			endm  
# End of macro DMARK
b231				CALLMONITOR 
b231 cd 6f ee			call debug_vector  
b234				endm  
# End of macro CALLMONITOR
b234			endif 
b234			 
b234					NEXTW 
b234 c3 4d 9e			jp macro_next 
b237				endm 
# End of macro NEXTW
b237				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b237			 
b237			.mloopnotdone: 
b237			 
b237 e1				pop hl    ; get I 
b238 2b				dec hl 
b239			 
b239			   	; save new I 
b239			 
b239			 
b239					; set I counter 
b239			 
b239 22 e6 e5				ld (os_current_i), hl 
b23c			 
b23c					 
b23c				FORTH_LOOP_NEXT 
b23c cd c8 9c			call macro_forth_loop_next 
b23f				endm 
# End of macro FORTH_LOOP_NEXT
b23f			 
b23f			 
b23f					if DEBUG_FORTH_WORDS 
b23f eb						ex de,hl 
b240					endif 
b240			 
b240			;	; get DO ptr 
b240			; 
b240				FORTH_RSP_TOS 
b240 cd 5e 9a			call macro_forth_rsp_tos 
b243				endm 
# End of macro FORTH_RSP_TOS
b243			 
b243				;push hl 
b243			 
b243				; not going to DO any more 
b243				; get rid of the RSP pointer as DO will add it back in 
b243				;FORTH_RSP_POP 
b243				;pop hl 
b243			 
b243			 
b243 22 c2 e5			ld (os_tok_ptr), hl 
b246					if DEBUG_FORTH_WORDS 
b246						DMARK "-L<" 
b246 f5				push af  
b247 3a 5b b2			ld a, (.dmark)  
b24a 32 6b ee			ld (debug_mark),a  
b24d 3a 5c b2			ld a, (.dmark+1)  
b250 32 6c ee			ld (debug_mark+1),a  
b253 3a 5d b2			ld a, (.dmark+2)  
b256 32 6d ee			ld (debug_mark+2),a  
b259 18 03			jr .pastdmark  
b25b ..			.dmark: db "-L<"  
b25e f1			.pastdmark: pop af  
b25f			endm  
# End of macro DMARK
b25f					CALLMONITOR 
b25f cd 6f ee			call debug_vector  
b262				endm  
# End of macro CALLMONITOR
b262				endif 
b262 c3 de 9e			jp exec1 
b265			 
b265					 
b265			 
b265			 
b265			 
b265				NEXTW 
b265 c3 4d 9e			jp macro_next 
b268				endm 
# End of macro NEXTW
b268			 
b268			 
b268			 
b268			 
b268			.REPEAT: 
b268				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b268 71				db WORD_SYS_CORE+93             
b269 bb b2			dw .UNTIL            
b26b 06				db 5 + 1 
b26c .. 00			db "REPEAT",0              
b273				endm 
# End of macro CWHEAD
b273			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b273			;  push pc to rsp stack past the REPEAT 
b273					if DEBUG_FORTH_WORDS_KEY 
b273						DMARK "REP" 
b273 f5				push af  
b274 3a 88 b2			ld a, (.dmark)  
b277 32 6b ee			ld (debug_mark),a  
b27a 3a 89 b2			ld a, (.dmark+1)  
b27d 32 6c ee			ld (debug_mark+1),a  
b280 3a 8a b2			ld a, (.dmark+2)  
b283 32 6d ee			ld (debug_mark+2),a  
b286 18 03			jr .pastdmark  
b288 ..			.dmark: db "REP"  
b28b f1			.pastdmark: pop af  
b28c			endm  
# End of macro DMARK
b28c						CALLMONITOR 
b28c cd 6f ee			call debug_vector  
b28f				endm  
# End of macro CALLMONITOR
b28f					endif 
b28f			 
b28f 2a c2 e5				ld hl, (os_tok_ptr) 
b292 23					inc hl   ; R 
b293 23					inc hl  ; E 
b294 23					inc hl   ; P 
b295 23					inc hl   ; E 
b296 23					inc hl   ; A 
b297 23					inc hl   ; T 
b298 23					inc hl   ; zero 
b299					FORTH_RSP_NEXT 
b299 cd 47 9a			call macro_forth_rsp_next 
b29c				endm 
# End of macro FORTH_RSP_NEXT
b29c			 
b29c			 
b29c					if DEBUG_FORTH_WORDS 
b29c						DMARK "REP" 
b29c f5				push af  
b29d 3a b1 b2			ld a, (.dmark)  
b2a0 32 6b ee			ld (debug_mark),a  
b2a3 3a b2 b2			ld a, (.dmark+1)  
b2a6 32 6c ee			ld (debug_mark+1),a  
b2a9 3a b3 b2			ld a, (.dmark+2)  
b2ac 32 6d ee			ld (debug_mark+2),a  
b2af 18 03			jr .pastdmark  
b2b1 ..			.dmark: db "REP"  
b2b4 f1			.pastdmark: pop af  
b2b5			endm  
# End of macro DMARK
b2b5						;pop bc    ; TODO BUG ?????? what is this for???? 
b2b5						CALLMONITOR 
b2b5 cd 6f ee			call debug_vector  
b2b8				endm  
# End of macro CALLMONITOR
b2b8					endif 
b2b8			 
b2b8					NEXTW 
b2b8 c3 4d 9e			jp macro_next 
b2bb				endm 
# End of macro NEXTW
b2bb			;	       NEXTW 
b2bb			 
b2bb			.UNTIL: 
b2bb				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2bb 72				db WORD_SYS_CORE+94             
b2bc 52 b3			dw .ENDFLOW            
b2be 06				db 5 + 1 
b2bf .. 00			db "UNTIL",0              
b2c5				endm 
# End of macro CWHEAD
b2c5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2c5			 
b2c5				; pop tos as check 
b2c5			 
b2c5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2c5			 
b2c5				FORTH_DSP_VALUEHL 
b2c5 cd 97 9c			call macro_dsp_valuehl 
b2c8				endm 
# End of macro FORTH_DSP_VALUEHL
b2c8			 
b2c8					if DEBUG_FORTH_WORDS_KEY 
b2c8						DMARK "UNT" 
b2c8 f5				push af  
b2c9 3a dd b2			ld a, (.dmark)  
b2cc 32 6b ee			ld (debug_mark),a  
b2cf 3a de b2			ld a, (.dmark+1)  
b2d2 32 6c ee			ld (debug_mark+1),a  
b2d5 3a df b2			ld a, (.dmark+2)  
b2d8 32 6d ee			ld (debug_mark+2),a  
b2db 18 03			jr .pastdmark  
b2dd ..			.dmark: db "UNT"  
b2e0 f1			.pastdmark: pop af  
b2e1			endm  
# End of macro DMARK
b2e1						CALLMONITOR 
b2e1 cd 6f ee			call debug_vector  
b2e4				endm  
# End of macro CALLMONITOR
b2e4					endif 
b2e4			 
b2e4			;	push hl 
b2e4				FORTH_DSP_POP 
b2e4 cd 4f 9d			call macro_forth_dsp_pop 
b2e7				endm 
# End of macro FORTH_DSP_POP
b2e7			 
b2e7			;	pop hl 
b2e7			 
b2e7				; test if true 
b2e7			 
b2e7 cd 04 8d			call ishlzero 
b2ea			;	ld a,l 
b2ea			;	add h 
b2ea			; 
b2ea			;	cp 0 
b2ea			 
b2ea 20 3e			jr nz, .untilnotdone 
b2ec			 
b2ec					if DEBUG_FORTH_WORDS 
b2ec						DMARK "UNf" 
b2ec f5				push af  
b2ed 3a 01 b3			ld a, (.dmark)  
b2f0 32 6b ee			ld (debug_mark),a  
b2f3 3a 02 b3			ld a, (.dmark+1)  
b2f6 32 6c ee			ld (debug_mark+1),a  
b2f9 3a 03 b3			ld a, (.dmark+2)  
b2fc 32 6d ee			ld (debug_mark+2),a  
b2ff 18 03			jr .pastdmark  
b301 ..			.dmark: db "UNf"  
b304 f1			.pastdmark: pop af  
b305			endm  
# End of macro DMARK
b305						CALLMONITOR 
b305 cd 6f ee			call debug_vector  
b308				endm  
# End of macro CALLMONITOR
b308					endif 
b308			 
b308			 
b308			 
b308				FORTH_RSP_POP     ; get rid of DO ptr 
b308 cd 68 9a			call macro_forth_rsp_pop 
b30b				endm 
# End of macro FORTH_RSP_POP
b30b			 
b30b			if DEBUG_FORTH_WORDS 
b30b						DMARK "UN>" 
b30b f5				push af  
b30c 3a 20 b3			ld a, (.dmark)  
b30f 32 6b ee			ld (debug_mark),a  
b312 3a 21 b3			ld a, (.dmark+1)  
b315 32 6c ee			ld (debug_mark+1),a  
b318 3a 22 b3			ld a, (.dmark+2)  
b31b 32 6d ee			ld (debug_mark+2),a  
b31e 18 03			jr .pastdmark  
b320 ..			.dmark: db "UN>"  
b323 f1			.pastdmark: pop af  
b324			endm  
# End of macro DMARK
b324				CALLMONITOR 
b324 cd 6f ee			call debug_vector  
b327				endm  
# End of macro CALLMONITOR
b327			endif 
b327			 
b327					NEXTW 
b327 c3 4d 9e			jp macro_next 
b32a				endm 
# End of macro NEXTW
b32a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b32a			 
b32a			.untilnotdone: 
b32a			 
b32a			 
b32a			;	; get DO ptr 
b32a			; 
b32a				FORTH_RSP_TOS 
b32a cd 5e 9a			call macro_forth_rsp_tos 
b32d				endm 
# End of macro FORTH_RSP_TOS
b32d			 
b32d				;push hl 
b32d			 
b32d				; not going to DO any more 
b32d				; get rid of the RSP pointer as DO will add it back in 
b32d				;FORTH_RSP_POP 
b32d				;pop hl 
b32d			 
b32d			 
b32d 22 c2 e5			ld (os_tok_ptr), hl 
b330					if DEBUG_FORTH_WORDS 
b330						DMARK "UN<" 
b330 f5				push af  
b331 3a 45 b3			ld a, (.dmark)  
b334 32 6b ee			ld (debug_mark),a  
b337 3a 46 b3			ld a, (.dmark+1)  
b33a 32 6c ee			ld (debug_mark+1),a  
b33d 3a 47 b3			ld a, (.dmark+2)  
b340 32 6d ee			ld (debug_mark+2),a  
b343 18 03			jr .pastdmark  
b345 ..			.dmark: db "UN<"  
b348 f1			.pastdmark: pop af  
b349			endm  
# End of macro DMARK
b349					CALLMONITOR 
b349 cd 6f ee			call debug_vector  
b34c				endm  
# End of macro CALLMONITOR
b34c				endif 
b34c c3 de 9e			jp exec1 
b34f			 
b34f					 
b34f			 
b34f			 
b34f					NEXTW 
b34f c3 4d 9e			jp macro_next 
b352				endm 
# End of macro NEXTW
b352			 
b352			 
b352			.ENDFLOW: 
b352			 
b352			; eof 
b352			 
# End of file forth_words_flow.asm
b352			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b352			include "forth_words_logic.asm" 
b352			 
b352			; | ## Logic Words 
b352			 
b352			.NOT: 
b352				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b352 2d				db WORD_SYS_CORE+25             
b353 9a b3			dw .IS            
b355 04				db 3 + 1 
b356 .. 00			db "NOT",0              
b35a				endm 
# End of macro CWHEAD
b35a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b35a					if DEBUG_FORTH_WORDS_KEY 
b35a						DMARK "NOT" 
b35a f5				push af  
b35b 3a 6f b3			ld a, (.dmark)  
b35e 32 6b ee			ld (debug_mark),a  
b361 3a 70 b3			ld a, (.dmark+1)  
b364 32 6c ee			ld (debug_mark+1),a  
b367 3a 71 b3			ld a, (.dmark+2)  
b36a 32 6d ee			ld (debug_mark+2),a  
b36d 18 03			jr .pastdmark  
b36f ..			.dmark: db "NOT"  
b372 f1			.pastdmark: pop af  
b373			endm  
# End of macro DMARK
b373						CALLMONITOR 
b373 cd 6f ee			call debug_vector  
b376				endm  
# End of macro CALLMONITOR
b376					endif 
b376					FORTH_DSP 
b376 cd 5d 9c			call macro_forth_dsp 
b379				endm 
# End of macro FORTH_DSP
b379 7e					ld a,(hl)	; get type of value on TOS 
b37a fe 02				cp DS_TYPE_INUM  
b37c 28 03				jr z, .noti 
b37e					NEXTW 
b37e c3 4d 9e			jp macro_next 
b381				endm 
# End of macro NEXTW
b381			.noti:          FORTH_DSP_VALUEHL 
b381 cd 97 9c			call macro_dsp_valuehl 
b384				endm 
# End of macro FORTH_DSP_VALUEHL
b384			;		push hl 
b384					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b384 cd 4f 9d			call macro_forth_dsp_pop 
b387				endm 
# End of macro FORTH_DSP_POP
b387			;		pop hl 
b387 3e 00				ld a,0 
b389 bd					cp l 
b38a 28 04				jr z, .not2t 
b38c 2e 00				ld l, 0 
b38e 18 02				jr .notip 
b390			 
b390 2e ff		.not2t:		ld l, 255 
b392			 
b392 26 00		.notip:		ld h, 0	 
b394			 
b394 cd a0 9a				call forth_push_numhl 
b397					NEXTW 
b397 c3 4d 9e			jp macro_next 
b39a				endm 
# End of macro NEXTW
b39a			 
b39a			.IS: 
b39a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b39a 2d				db WORD_SYS_CORE+25             
b39b c0 b3			dw .LZERO            
b39d 03				db 2 + 1 
b39e .. 00			db "IS",0              
b3a1				endm 
# End of macro CWHEAD
b3a1			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3a1					if DEBUG_FORTH_WORDS_KEY 
b3a1						DMARK "IS." 
b3a1 f5				push af  
b3a2 3a b6 b3			ld a, (.dmark)  
b3a5 32 6b ee			ld (debug_mark),a  
b3a8 3a b7 b3			ld a, (.dmark+1)  
b3ab 32 6c ee			ld (debug_mark+1),a  
b3ae 3a b8 b3			ld a, (.dmark+2)  
b3b1 32 6d ee			ld (debug_mark+2),a  
b3b4 18 03			jr .pastdmark  
b3b6 ..			.dmark: db "IS."  
b3b9 f1			.pastdmark: pop af  
b3ba			endm  
# End of macro DMARK
b3ba						CALLMONITOR 
b3ba cd 6f ee			call debug_vector  
b3bd				endm  
# End of macro CALLMONITOR
b3bd					endif 
b3bd					NEXTW 
b3bd c3 4d 9e			jp macro_next 
b3c0				endm 
# End of macro NEXTW
b3c0			.LZERO: 
b3c0				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3c0 2d				db WORD_SYS_CORE+25             
b3c1 ca b3			dw .TZERO            
b3c3 03				db 2 + 1 
b3c4 .. 00			db "0<",0              
b3c7				endm 
# End of macro CWHEAD
b3c7			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3c7					NEXTW 
b3c7 c3 4d 9e			jp macro_next 
b3ca				endm 
# End of macro NEXTW
b3ca			.TZERO: 
b3ca				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3ca 2e				db WORD_SYS_CORE+26             
b3cb 11 b4			dw .LESS            
b3cd 03				db 2 + 1 
b3ce .. 00			db "0=",0              
b3d1				endm 
# End of macro CWHEAD
b3d1			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b3d1				; TODO add floating point number detection 
b3d1					;v5 FORTH_DSP_VALUE 
b3d1					if DEBUG_FORTH_WORDS_KEY 
b3d1						DMARK "0=." 
b3d1 f5				push af  
b3d2 3a e6 b3			ld a, (.dmark)  
b3d5 32 6b ee			ld (debug_mark),a  
b3d8 3a e7 b3			ld a, (.dmark+1)  
b3db 32 6c ee			ld (debug_mark+1),a  
b3de 3a e8 b3			ld a, (.dmark+2)  
b3e1 32 6d ee			ld (debug_mark+2),a  
b3e4 18 03			jr .pastdmark  
b3e6 ..			.dmark: db "0=."  
b3e9 f1			.pastdmark: pop af  
b3ea			endm  
# End of macro DMARK
b3ea						CALLMONITOR 
b3ea cd 6f ee			call debug_vector  
b3ed				endm  
# End of macro CALLMONITOR
b3ed					endif 
b3ed					FORTH_DSP 
b3ed cd 5d 9c			call macro_forth_dsp 
b3f0				endm 
# End of macro FORTH_DSP
b3f0 7e					ld a,(hl)	; get type of value on TOS 
b3f1 fe 02				cp DS_TYPE_INUM  
b3f3 28 00				jr z, .tz_inum 
b3f5			 
b3f5				if FORTH_ENABLE_FLOATMATH 
b3f5					jr .tz_done 
b3f5			 
b3f5				endif 
b3f5					 
b3f5			 
b3f5			.tz_inum: 
b3f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f5 cd 97 9c			call macro_dsp_valuehl 
b3f8				endm 
# End of macro FORTH_DSP_VALUEHL
b3f8			 
b3f8			;		push hl 
b3f8			 
b3f8					; destroy value TOS 
b3f8			 
b3f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f8 cd 4f 9d			call macro_forth_dsp_pop 
b3fb				endm 
# End of macro FORTH_DSP_POP
b3fb			 
b3fb			;		pop hl 
b3fb			 
b3fb 3e 00				ld a,0 
b3fd			 
b3fd bd					cp l 
b3fe 20 08				jr nz, .tz_notzero 
b400			 
b400 bc					cp h 
b401			 
b401 20 05				jr nz, .tz_notzero 
b403			 
b403			 
b403 21 01 00				ld hl, FORTH_TRUE 
b406 18 03				jr .tz_done 
b408			 
b408 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b40b			 
b40b					; push value back onto stack for another op etc 
b40b			 
b40b			.tz_done: 
b40b cd a0 9a				call forth_push_numhl 
b40e			 
b40e					NEXTW 
b40e c3 4d 9e			jp macro_next 
b411				endm 
# End of macro NEXTW
b411			.LESS: 
b411				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b411 2f				db WORD_SYS_CORE+27             
b412 7a b4			dw .GT            
b414 02				db 1 + 1 
b415 .. 00			db "<",0              
b417				endm 
# End of macro CWHEAD
b417			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b417				; TODO add floating point number detection 
b417					if DEBUG_FORTH_WORDS_KEY 
b417						DMARK "LES" 
b417 f5				push af  
b418 3a 2c b4			ld a, (.dmark)  
b41b 32 6b ee			ld (debug_mark),a  
b41e 3a 2d b4			ld a, (.dmark+1)  
b421 32 6c ee			ld (debug_mark+1),a  
b424 3a 2e b4			ld a, (.dmark+2)  
b427 32 6d ee			ld (debug_mark+2),a  
b42a 18 03			jr .pastdmark  
b42c ..			.dmark: db "LES"  
b42f f1			.pastdmark: pop af  
b430			endm  
# End of macro DMARK
b430						CALLMONITOR 
b430 cd 6f ee			call debug_vector  
b433				endm  
# End of macro CALLMONITOR
b433					endif 
b433					FORTH_DSP 
b433 cd 5d 9c			call macro_forth_dsp 
b436				endm 
# End of macro FORTH_DSP
b436					;v5 FORTH_DSP_VALUE 
b436 7e					ld a,(hl)	; get type of value on TOS 
b437 fe 02				cp DS_TYPE_INUM  
b439 28 00				jr z, .less_inum 
b43b			 
b43b				if FORTH_ENABLE_FLOATMATH 
b43b					jr .less_done 
b43b			 
b43b				endif 
b43b					 
b43b			 
b43b			.less_inum: 
b43b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b43b cd 97 9c			call macro_dsp_valuehl 
b43e				endm 
# End of macro FORTH_DSP_VALUEHL
b43e			 
b43e e5					push hl  ; u2 
b43f			 
b43f					; destroy value TOS 
b43f			 
b43f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b43f cd 4f 9d			call macro_forth_dsp_pop 
b442				endm 
# End of macro FORTH_DSP_POP
b442			 
b442			 
b442					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b442 cd 97 9c			call macro_dsp_valuehl 
b445				endm 
# End of macro FORTH_DSP_VALUEHL
b445			 
b445 e5					push hl    ; u1 
b446			 
b446					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b446 cd 4f 9d			call macro_forth_dsp_pop 
b449				endm 
# End of macro FORTH_DSP_POP
b449			 
b449			 
b449 b7			 or a      ;clear carry flag 
b44a 01 00 00		 ld bc, FORTH_FALSE 
b44d e1			  pop hl    ; u1 
b44e d1			  pop de    ; u2 
b44f ed 52		  sbc hl,de 
b451 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b453			 
b453 01 01 00		 ld bc, FORTH_TRUE 
b456			.lscont:  
b456 c5					push bc 
b457 e1					pop hl 
b458			 
b458					if DEBUG_FORTH_WORDS 
b458						DMARK "LT1" 
b458 f5				push af  
b459 3a 6d b4			ld a, (.dmark)  
b45c 32 6b ee			ld (debug_mark),a  
b45f 3a 6e b4			ld a, (.dmark+1)  
b462 32 6c ee			ld (debug_mark+1),a  
b465 3a 6f b4			ld a, (.dmark+2)  
b468 32 6d ee			ld (debug_mark+2),a  
b46b 18 03			jr .pastdmark  
b46d ..			.dmark: db "LT1"  
b470 f1			.pastdmark: pop af  
b471			endm  
# End of macro DMARK
b471						CALLMONITOR 
b471 cd 6f ee			call debug_vector  
b474				endm  
# End of macro CALLMONITOR
b474					endif 
b474 cd a0 9a				call forth_push_numhl 
b477			 
b477					NEXTW 
b477 c3 4d 9e			jp macro_next 
b47a				endm 
# End of macro NEXTW
b47a			.GT: 
b47a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b47a 30				db WORD_SYS_CORE+28             
b47b e3 b4			dw .EQUAL            
b47d 02				db 1 + 1 
b47e .. 00			db ">",0              
b480				endm 
# End of macro CWHEAD
b480			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b480				; TODO add floating point number detection 
b480					if DEBUG_FORTH_WORDS_KEY 
b480						DMARK "GRT" 
b480 f5				push af  
b481 3a 95 b4			ld a, (.dmark)  
b484 32 6b ee			ld (debug_mark),a  
b487 3a 96 b4			ld a, (.dmark+1)  
b48a 32 6c ee			ld (debug_mark+1),a  
b48d 3a 97 b4			ld a, (.dmark+2)  
b490 32 6d ee			ld (debug_mark+2),a  
b493 18 03			jr .pastdmark  
b495 ..			.dmark: db "GRT"  
b498 f1			.pastdmark: pop af  
b499			endm  
# End of macro DMARK
b499						CALLMONITOR 
b499 cd 6f ee			call debug_vector  
b49c				endm  
# End of macro CALLMONITOR
b49c					endif 
b49c					FORTH_DSP 
b49c cd 5d 9c			call macro_forth_dsp 
b49f				endm 
# End of macro FORTH_DSP
b49f					;FORTH_DSP_VALUE 
b49f 7e					ld a,(hl)	; get type of value on TOS 
b4a0 fe 02				cp DS_TYPE_INUM  
b4a2 28 00				jr z, .gt_inum 
b4a4			 
b4a4				if FORTH_ENABLE_FLOATMATH 
b4a4					jr .gt_done 
b4a4			 
b4a4				endif 
b4a4					 
b4a4			 
b4a4			.gt_inum: 
b4a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a4 cd 97 9c			call macro_dsp_valuehl 
b4a7				endm 
# End of macro FORTH_DSP_VALUEHL
b4a7			 
b4a7 e5					push hl  ; u2 
b4a8			 
b4a8					; destroy value TOS 
b4a8			 
b4a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4a8 cd 4f 9d			call macro_forth_dsp_pop 
b4ab				endm 
# End of macro FORTH_DSP_POP
b4ab			 
b4ab			 
b4ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4ab cd 97 9c			call macro_dsp_valuehl 
b4ae				endm 
# End of macro FORTH_DSP_VALUEHL
b4ae			 
b4ae e5					push hl    ; u1 
b4af			 
b4af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4af cd 4f 9d			call macro_forth_dsp_pop 
b4b2				endm 
# End of macro FORTH_DSP_POP
b4b2			 
b4b2			 
b4b2 b7			 or a      ;clear carry flag 
b4b3 01 00 00		 ld bc, FORTH_FALSE 
b4b6 e1			  pop hl    ; u1 
b4b7 d1			  pop de    ; u2 
b4b8 ed 52		  sbc hl,de 
b4ba 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4bc			 
b4bc 01 01 00		 ld bc, FORTH_TRUE 
b4bf			.gtcont:  
b4bf c5					push bc 
b4c0 e1					pop hl 
b4c1			 
b4c1					if DEBUG_FORTH_WORDS 
b4c1						DMARK "GT1" 
b4c1 f5				push af  
b4c2 3a d6 b4			ld a, (.dmark)  
b4c5 32 6b ee			ld (debug_mark),a  
b4c8 3a d7 b4			ld a, (.dmark+1)  
b4cb 32 6c ee			ld (debug_mark+1),a  
b4ce 3a d8 b4			ld a, (.dmark+2)  
b4d1 32 6d ee			ld (debug_mark+2),a  
b4d4 18 03			jr .pastdmark  
b4d6 ..			.dmark: db "GT1"  
b4d9 f1			.pastdmark: pop af  
b4da			endm  
# End of macro DMARK
b4da						CALLMONITOR 
b4da cd 6f ee			call debug_vector  
b4dd				endm  
# End of macro CALLMONITOR
b4dd					endif 
b4dd cd a0 9a				call forth_push_numhl 
b4e0			 
b4e0					NEXTW 
b4e0 c3 4d 9e			jp macro_next 
b4e3				endm 
# End of macro NEXTW
b4e3			.EQUAL: 
b4e3				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4e3 31				db WORD_SYS_CORE+29             
b4e4 4e b5			dw .ENDLOGIC            
b4e6 02				db 1 + 1 
b4e7 .. 00			db "=",0              
b4e9				endm 
# End of macro CWHEAD
b4e9			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4e9				; TODO add floating point number detection 
b4e9					if DEBUG_FORTH_WORDS_KEY 
b4e9						DMARK "EQ." 
b4e9 f5				push af  
b4ea 3a fe b4			ld a, (.dmark)  
b4ed 32 6b ee			ld (debug_mark),a  
b4f0 3a ff b4			ld a, (.dmark+1)  
b4f3 32 6c ee			ld (debug_mark+1),a  
b4f6 3a 00 b5			ld a, (.dmark+2)  
b4f9 32 6d ee			ld (debug_mark+2),a  
b4fc 18 03			jr .pastdmark  
b4fe ..			.dmark: db "EQ."  
b501 f1			.pastdmark: pop af  
b502			endm  
# End of macro DMARK
b502						CALLMONITOR 
b502 cd 6f ee			call debug_vector  
b505				endm  
# End of macro CALLMONITOR
b505					endif 
b505					FORTH_DSP 
b505 cd 5d 9c			call macro_forth_dsp 
b508				endm 
# End of macro FORTH_DSP
b508					;v5 FORTH_DSP_VALUE 
b508 7e					ld a,(hl)	; get type of value on TOS 
b509 fe 02				cp DS_TYPE_INUM  
b50b 28 00				jr z, .eq_inum 
b50d			 
b50d				if FORTH_ENABLE_FLOATMATH 
b50d					jr .eq_done 
b50d			 
b50d				endif 
b50d					 
b50d			 
b50d			.eq_inum: 
b50d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b50d cd 97 9c			call macro_dsp_valuehl 
b510				endm 
# End of macro FORTH_DSP_VALUEHL
b510			 
b510 e5					push hl 
b511			 
b511					; destroy value TOS 
b511			 
b511					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b511 cd 4f 9d			call macro_forth_dsp_pop 
b514				endm 
# End of macro FORTH_DSP_POP
b514			 
b514			 
b514					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b514 cd 97 9c			call macro_dsp_valuehl 
b517				endm 
# End of macro FORTH_DSP_VALUEHL
b517			 
b517					; one value on hl get other one back 
b517			 
b517 e5					push hl 
b518			 
b518					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b518 cd 4f 9d			call macro_forth_dsp_pop 
b51b				endm 
# End of macro FORTH_DSP_POP
b51b			 
b51b 0e 00				ld c, FORTH_FALSE 
b51d			 
b51d e1					pop hl 
b51e d1					pop de 
b51f			 
b51f 7b					ld a, e 
b520 bd					cp l 
b521			 
b521 20 06				jr nz, .eq_done 
b523			 
b523 7a					ld a, d 
b524 bc					cp h 
b525			 
b525 20 02				jr nz, .eq_done 
b527			 
b527 0e 01				ld c, FORTH_TRUE 
b529					 
b529			 
b529			 
b529			.eq_done: 
b529			 
b529					; TODO push value back onto stack for another op etc 
b529			 
b529 26 00				ld h, 0 
b52b 69					ld l, c 
b52c					if DEBUG_FORTH_WORDS 
b52c						DMARK "EQ1" 
b52c f5				push af  
b52d 3a 41 b5			ld a, (.dmark)  
b530 32 6b ee			ld (debug_mark),a  
b533 3a 42 b5			ld a, (.dmark+1)  
b536 32 6c ee			ld (debug_mark+1),a  
b539 3a 43 b5			ld a, (.dmark+2)  
b53c 32 6d ee			ld (debug_mark+2),a  
b53f 18 03			jr .pastdmark  
b541 ..			.dmark: db "EQ1"  
b544 f1			.pastdmark: pop af  
b545			endm  
# End of macro DMARK
b545						CALLMONITOR 
b545 cd 6f ee			call debug_vector  
b548				endm  
# End of macro CALLMONITOR
b548					endif 
b548 cd a0 9a				call forth_push_numhl 
b54b			 
b54b					NEXTW 
b54b c3 4d 9e			jp macro_next 
b54e				endm 
# End of macro NEXTW
b54e			 
b54e			 
b54e			.ENDLOGIC: 
b54e			; eof 
b54e			 
b54e			 
# End of file forth_words_logic.asm
b54e			include "forth_words_maths.asm" 
b54e			 
b54e			; | ## Maths Words 
b54e			 
b54e			.PLUS:	 
b54e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b54e 15				db WORD_SYS_CORE+1             
b54f ac b5			dw .NEG            
b551 02				db 1 + 1 
b552 .. 00			db "+",0              
b554				endm 
# End of macro CWHEAD
b554			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b554					if DEBUG_FORTH_WORDS_KEY 
b554						DMARK "PLU" 
b554 f5				push af  
b555 3a 69 b5			ld a, (.dmark)  
b558 32 6b ee			ld (debug_mark),a  
b55b 3a 6a b5			ld a, (.dmark+1)  
b55e 32 6c ee			ld (debug_mark+1),a  
b561 3a 6b b5			ld a, (.dmark+2)  
b564 32 6d ee			ld (debug_mark+2),a  
b567 18 03			jr .pastdmark  
b569 ..			.dmark: db "PLU"  
b56c f1			.pastdmark: pop af  
b56d			endm  
# End of macro DMARK
b56d						CALLMONITOR 
b56d cd 6f ee			call debug_vector  
b570				endm  
# End of macro CALLMONITOR
b570					endif 
b570					; add top two values and push back result 
b570			 
b570					;for v5 FORTH_DSP_VALUE 
b570					FORTH_DSP 
b570 cd 5d 9c			call macro_forth_dsp 
b573				endm 
# End of macro FORTH_DSP
b573 7e					ld a,(hl)	; get type of value on TOS 
b574 fe 02				cp DS_TYPE_INUM  
b576 28 03				jr z, .dot_inum 
b578			 
b578					NEXTW 
b578 c3 4d 9e			jp macro_next 
b57b				endm 
# End of macro NEXTW
b57b			 
b57b			; float maths 
b57b			 
b57b				if FORTH_ENABLE_FLOATMATH 
b57b						inc hl      ; now at start of numeric as string 
b57b			 
b57b					if DEBUG_FORTH_MATHS 
b57b						DMARK "ADD" 
b57b				CALLMONITOR 
b57b					endif 
b57b			 
b57b					;ld ix, hl 
b57b					call CON 
b57b			 
b57b			 
b57b					push hl 
b57b					 
b57b					 
b57b			 
b57b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b57b			 
b57b					; get next number 
b57b			 
b57b						FORTH_DSP_VALUE 
b57b			 
b57b						inc hl      ; now at start of numeric as string 
b57b			 
b57b					;ld ix, hl 
b57b					call CON 
b57b			 
b57b					push hl 
b57b			 
b57b			 
b57b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b57b			 
b57b						; TODO do add 
b57b			 
b57b						call IADD 
b57b			 
b57b						; TODO get result back as ascii 
b57b			 
b57b						; TODO push result  
b57b			 
b57b			 
b57b			 
b57b						jr .dot_done 
b57b				endif 
b57b			 
b57b			.dot_inum: 
b57b			 
b57b			 
b57b					if DEBUG_FORTH_DOT 
b57b						DMARK "+IT" 
b57b f5				push af  
b57c 3a 90 b5			ld a, (.dmark)  
b57f 32 6b ee			ld (debug_mark),a  
b582 3a 91 b5			ld a, (.dmark+1)  
b585 32 6c ee			ld (debug_mark+1),a  
b588 3a 92 b5			ld a, (.dmark+2)  
b58b 32 6d ee			ld (debug_mark+2),a  
b58e 18 03			jr .pastdmark  
b590 ..			.dmark: db "+IT"  
b593 f1			.pastdmark: pop af  
b594			endm  
# End of macro DMARK
b594				CALLMONITOR 
b594 cd 6f ee			call debug_vector  
b597				endm  
# End of macro CALLMONITOR
b597					endif 
b597			 
b597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b597 cd 97 9c			call macro_dsp_valuehl 
b59a				endm 
# End of macro FORTH_DSP_VALUEHL
b59a			 
b59a				; TODO add floating point number detection 
b59a			 
b59a e5					push hl 
b59b			 
b59b					; destroy value TOS 
b59b			 
b59b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b59b cd 4f 9d			call macro_forth_dsp_pop 
b59e				endm 
# End of macro FORTH_DSP_POP
b59e			 
b59e			 
b59e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59e cd 97 9c			call macro_dsp_valuehl 
b5a1				endm 
# End of macro FORTH_DSP_VALUEHL
b5a1			 
b5a1					; one value on hl get other one back 
b5a1			 
b5a1 d1					pop de 
b5a2			 
b5a2					; do the add 
b5a2			 
b5a2 19					add hl,de 
b5a3			 
b5a3					; save it 
b5a3			 
b5a3			;		push hl	 
b5a3			 
b5a3					; 
b5a3			 
b5a3					; destroy value TOS 
b5a3			 
b5a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a3 cd 4f 9d			call macro_forth_dsp_pop 
b5a6				endm 
# End of macro FORTH_DSP_POP
b5a6			 
b5a6					; TODO push value back onto stack for another op etc 
b5a6			 
b5a6			;		pop hl 
b5a6			 
b5a6			.dot_done: 
b5a6 cd a0 9a				call forth_push_numhl 
b5a9			 
b5a9					NEXTW 
b5a9 c3 4d 9e			jp macro_next 
b5ac				endm 
# End of macro NEXTW
b5ac			.NEG: 
b5ac			 
b5ac				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b5ac 17				db WORD_SYS_CORE+3             
b5ad ef b5			dw .DIV            
b5af 02				db 1 + 1 
b5b0 .. 00			db "-",0              
b5b2				endm 
# End of macro CWHEAD
b5b2			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b5b2					if DEBUG_FORTH_WORDS_KEY 
b5b2						DMARK "SUB" 
b5b2 f5				push af  
b5b3 3a c7 b5			ld a, (.dmark)  
b5b6 32 6b ee			ld (debug_mark),a  
b5b9 3a c8 b5			ld a, (.dmark+1)  
b5bc 32 6c ee			ld (debug_mark+1),a  
b5bf 3a c9 b5			ld a, (.dmark+2)  
b5c2 32 6d ee			ld (debug_mark+2),a  
b5c5 18 03			jr .pastdmark  
b5c7 ..			.dmark: db "SUB"  
b5ca f1			.pastdmark: pop af  
b5cb			endm  
# End of macro DMARK
b5cb						CALLMONITOR 
b5cb cd 6f ee			call debug_vector  
b5ce				endm  
# End of macro CALLMONITOR
b5ce					endif 
b5ce			 
b5ce			 
b5ce				; TODO add floating point number detection 
b5ce					; v5 FORTH_DSP_VALUE 
b5ce					FORTH_DSP 
b5ce cd 5d 9c			call macro_forth_dsp 
b5d1				endm 
# End of macro FORTH_DSP
b5d1 7e					ld a,(hl)	; get type of value on TOS 
b5d2 fe 02				cp DS_TYPE_INUM  
b5d4 28 03				jr z, .neg_inum 
b5d6			 
b5d6					NEXTW 
b5d6 c3 4d 9e			jp macro_next 
b5d9				endm 
# End of macro NEXTW
b5d9			 
b5d9			; float maths 
b5d9			 
b5d9				if FORTH_ENABLE_FLOATMATH 
b5d9					jr .neg_done 
b5d9			 
b5d9				endif 
b5d9					 
b5d9			 
b5d9			.neg_inum: 
b5d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5d9 cd 97 9c			call macro_dsp_valuehl 
b5dc				endm 
# End of macro FORTH_DSP_VALUEHL
b5dc			 
b5dc e5					push hl 
b5dd			 
b5dd					; destroy value TOS 
b5dd			 
b5dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5dd cd 4f 9d			call macro_forth_dsp_pop 
b5e0				endm 
# End of macro FORTH_DSP_POP
b5e0			 
b5e0			 
b5e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e0 cd 97 9c			call macro_dsp_valuehl 
b5e3				endm 
# End of macro FORTH_DSP_VALUEHL
b5e3			 
b5e3					; one value on hl get other one back 
b5e3			 
b5e3 d1					pop de 
b5e4			 
b5e4					; do the sub 
b5e4			;		ex de, hl 
b5e4			 
b5e4 ed 52				sbc hl,de 
b5e6			 
b5e6					; save it 
b5e6			 
b5e6			;		push hl	 
b5e6			 
b5e6					; 
b5e6			 
b5e6					; destroy value TOS 
b5e6			 
b5e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e6 cd 4f 9d			call macro_forth_dsp_pop 
b5e9				endm 
# End of macro FORTH_DSP_POP
b5e9			 
b5e9					; TODO push value back onto stack for another op etc 
b5e9			 
b5e9			;		pop hl 
b5e9			 
b5e9 cd a0 9a				call forth_push_numhl 
b5ec			.neg_done: 
b5ec			 
b5ec					NEXTW 
b5ec c3 4d 9e			jp macro_next 
b5ef				endm 
# End of macro NEXTW
b5ef			.DIV: 
b5ef				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5ef 18				db WORD_SYS_CORE+4             
b5f0 3c b6			dw .MUL            
b5f2 02				db 1 + 1 
b5f3 .. 00			db "/",0              
b5f5				endm 
# End of macro CWHEAD
b5f5			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5f5					if DEBUG_FORTH_WORDS_KEY 
b5f5						DMARK "DIV" 
b5f5 f5				push af  
b5f6 3a 0a b6			ld a, (.dmark)  
b5f9 32 6b ee			ld (debug_mark),a  
b5fc 3a 0b b6			ld a, (.dmark+1)  
b5ff 32 6c ee			ld (debug_mark+1),a  
b602 3a 0c b6			ld a, (.dmark+2)  
b605 32 6d ee			ld (debug_mark+2),a  
b608 18 03			jr .pastdmark  
b60a ..			.dmark: db "DIV"  
b60d f1			.pastdmark: pop af  
b60e			endm  
# End of macro DMARK
b60e						CALLMONITOR 
b60e cd 6f ee			call debug_vector  
b611				endm  
# End of macro CALLMONITOR
b611					endif 
b611				; TODO add floating point number detection 
b611					; v5 FORTH_DSP_VALUE 
b611					FORTH_DSP 
b611 cd 5d 9c			call macro_forth_dsp 
b614				endm 
# End of macro FORTH_DSP
b614 7e					ld a,(hl)	; get type of value on TOS 
b615 fe 02				cp DS_TYPE_INUM  
b617 28 03				jr z, .div_inum 
b619			 
b619				if FORTH_ENABLE_FLOATMATH 
b619					jr .div_done 
b619			 
b619				endif 
b619					NEXTW 
b619 c3 4d 9e			jp macro_next 
b61c				endm 
# End of macro NEXTW
b61c			.div_inum: 
b61c			 
b61c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b61c cd 97 9c			call macro_dsp_valuehl 
b61f				endm 
# End of macro FORTH_DSP_VALUEHL
b61f			 
b61f e5					push hl    ; to go to bc 
b620			 
b620					; destroy value TOS 
b620			 
b620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b620 cd 4f 9d			call macro_forth_dsp_pop 
b623				endm 
# End of macro FORTH_DSP_POP
b623			 
b623			 
b623					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b623 cd 97 9c			call macro_dsp_valuehl 
b626				endm 
# End of macro FORTH_DSP_VALUEHL
b626			 
b626					; hl to go to de 
b626			 
b626 e5					push hl 
b627			 
b627 c1					pop bc 
b628 d1					pop de		 
b629			 
b629			 
b629					if DEBUG_FORTH_MATHS 
b629						DMARK "DIV" 
b629				CALLMONITOR 
b629					endif 
b629					; one value on hl but move to a get other one back 
b629			 
b629			        
b629 cd 38 8c			call Div16 
b62c			 
b62c			;	push af	 
b62c e5				push hl 
b62d c5				push bc 
b62e			 
b62e					if DEBUG_FORTH_MATHS 
b62e						DMARK "DI1" 
b62e				CALLMONITOR 
b62e					endif 
b62e			 
b62e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b62e cd 4f 9d			call macro_forth_dsp_pop 
b631				endm 
# End of macro FORTH_DSP_POP
b631			 
b631			 
b631			 
b631 e1					pop hl    ; result 
b632			 
b632 cd a0 9a				call forth_push_numhl 
b635			 
b635 e1					pop hl    ; reminder 
b636			;		ld h,0 
b636			;		ld l,d 
b636			 
b636 cd a0 9a				call forth_push_numhl 
b639			.div_done: 
b639					NEXTW 
b639 c3 4d 9e			jp macro_next 
b63c				endm 
# End of macro NEXTW
b63c			.MUL: 
b63c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b63c 19				db WORD_SYS_CORE+5             
b63d 81 b6			dw .MIN            
b63f 02				db 1 + 1 
b640 .. 00			db "*",0              
b642				endm 
# End of macro CWHEAD
b642			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b642				; TODO add floating point number detection 
b642					if DEBUG_FORTH_WORDS_KEY 
b642						DMARK "MUL" 
b642 f5				push af  
b643 3a 57 b6			ld a, (.dmark)  
b646 32 6b ee			ld (debug_mark),a  
b649 3a 58 b6			ld a, (.dmark+1)  
b64c 32 6c ee			ld (debug_mark+1),a  
b64f 3a 59 b6			ld a, (.dmark+2)  
b652 32 6d ee			ld (debug_mark+2),a  
b655 18 03			jr .pastdmark  
b657 ..			.dmark: db "MUL"  
b65a f1			.pastdmark: pop af  
b65b			endm  
# End of macro DMARK
b65b						CALLMONITOR 
b65b cd 6f ee			call debug_vector  
b65e				endm  
# End of macro CALLMONITOR
b65e					endif 
b65e					FORTH_DSP 
b65e cd 5d 9c			call macro_forth_dsp 
b661				endm 
# End of macro FORTH_DSP
b661					; v5 FORTH_DSP_VALUE 
b661 7e					ld a,(hl)	; get type of value on TOS 
b662 fe 02				cp DS_TYPE_INUM  
b664 28 03				jr z, .mul_inum 
b666			 
b666				if FORTH_ENABLE_FLOATMATH 
b666					jr .mul_done 
b666			 
b666				endif 
b666			 
b666					NEXTW 
b666 c3 4d 9e			jp macro_next 
b669				endm 
# End of macro NEXTW
b669			.mul_inum:	 
b669			 
b669					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b669 cd 97 9c			call macro_dsp_valuehl 
b66c				endm 
# End of macro FORTH_DSP_VALUEHL
b66c			 
b66c e5					push hl 
b66d			 
b66d					; destroy value TOS 
b66d			 
b66d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b66d cd 4f 9d			call macro_forth_dsp_pop 
b670				endm 
# End of macro FORTH_DSP_POP
b670			 
b670			 
b670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b670 cd 97 9c			call macro_dsp_valuehl 
b673				endm 
# End of macro FORTH_DSP_VALUEHL
b673			 
b673					; one value on hl but move to a get other one back 
b673			 
b673 7d					ld a, l 
b674			 
b674 d1					pop de 
b675			 
b675					; do the mull 
b675			;		ex de, hl 
b675			 
b675 cd 5e 8c				call Mult16 
b678					; save it 
b678			 
b678			;		push hl	 
b678			 
b678					; 
b678			 
b678					; destroy value TOS 
b678			 
b678					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b678 cd 4f 9d			call macro_forth_dsp_pop 
b67b				endm 
# End of macro FORTH_DSP_POP
b67b			 
b67b					; TODO push value back onto stack for another op etc 
b67b			 
b67b			;		pop hl 
b67b			 
b67b cd a0 9a				call forth_push_numhl 
b67e			 
b67e			.mul_done: 
b67e					NEXTW 
b67e c3 4d 9e			jp macro_next 
b681				endm 
# End of macro NEXTW
b681			 
b681			 
b681			 
b681			 
b681			.MIN: 
b681				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b681 49				db WORD_SYS_CORE+53             
b682 02 b7			dw .MAX            
b684 04				db 3 + 1 
b685 .. 00			db "MIN",0              
b689				endm 
# End of macro CWHEAD
b689			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b689					if DEBUG_FORTH_WORDS_KEY 
b689						DMARK "MIN" 
b689 f5				push af  
b68a 3a 9e b6			ld a, (.dmark)  
b68d 32 6b ee			ld (debug_mark),a  
b690 3a 9f b6			ld a, (.dmark+1)  
b693 32 6c ee			ld (debug_mark+1),a  
b696 3a a0 b6			ld a, (.dmark+2)  
b699 32 6d ee			ld (debug_mark+2),a  
b69c 18 03			jr .pastdmark  
b69e ..			.dmark: db "MIN"  
b6a1 f1			.pastdmark: pop af  
b6a2			endm  
# End of macro DMARK
b6a2						CALLMONITOR 
b6a2 cd 6f ee			call debug_vector  
b6a5				endm  
# End of macro CALLMONITOR
b6a5					endif 
b6a5					; get u2 
b6a5			 
b6a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6a5 cd 97 9c			call macro_dsp_valuehl 
b6a8				endm 
# End of macro FORTH_DSP_VALUEHL
b6a8			 
b6a8 e5					push hl   ; u2 
b6a9			 
b6a9					; destroy value TOS 
b6a9			 
b6a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6a9 cd 4f 9d			call macro_forth_dsp_pop 
b6ac				endm 
# End of macro FORTH_DSP_POP
b6ac			 
b6ac					; get u1 
b6ac			 
b6ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6ac cd 97 9c			call macro_dsp_valuehl 
b6af				endm 
# End of macro FORTH_DSP_VALUEHL
b6af			 
b6af e5					push hl  ; u1 
b6b0			 
b6b0					; destroy value TOS 
b6b0			 
b6b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b0 cd 4f 9d			call macro_forth_dsp_pop 
b6b3				endm 
# End of macro FORTH_DSP_POP
b6b3			 
b6b3 b7			 or a      ;clear carry flag 
b6b4 e1			  pop hl    ; u1 
b6b5 d1			  pop de    ; u2 
b6b6 e5				push hl   ; saved in case hl is lowest 
b6b7 ed 52		  sbc hl,de 
b6b9 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6bb			 
b6bb e1				pop hl 
b6bc					if DEBUG_FORTH_WORDS 
b6bc						DMARK "MIN" 
b6bc f5				push af  
b6bd 3a d1 b6			ld a, (.dmark)  
b6c0 32 6b ee			ld (debug_mark),a  
b6c3 3a d2 b6			ld a, (.dmark+1)  
b6c6 32 6c ee			ld (debug_mark+1),a  
b6c9 3a d3 b6			ld a, (.dmark+2)  
b6cc 32 6d ee			ld (debug_mark+2),a  
b6cf 18 03			jr .pastdmark  
b6d1 ..			.dmark: db "MIN"  
b6d4 f1			.pastdmark: pop af  
b6d5			endm  
# End of macro DMARK
b6d5						CALLMONITOR 
b6d5 cd 6f ee			call debug_vector  
b6d8				endm  
# End of macro CALLMONITOR
b6d8					endif 
b6d8 cd a0 9a				call forth_push_numhl 
b6db			 
b6db				       NEXTW 
b6db c3 4d 9e			jp macro_next 
b6de				endm 
# End of macro NEXTW
b6de			 
b6de			.mincont:  
b6de c1				pop bc   ; tidy up 
b6df eb				ex de , hl  
b6e0					if DEBUG_FORTH_WORDS 
b6e0						DMARK "MI1" 
b6e0 f5				push af  
b6e1 3a f5 b6			ld a, (.dmark)  
b6e4 32 6b ee			ld (debug_mark),a  
b6e7 3a f6 b6			ld a, (.dmark+1)  
b6ea 32 6c ee			ld (debug_mark+1),a  
b6ed 3a f7 b6			ld a, (.dmark+2)  
b6f0 32 6d ee			ld (debug_mark+2),a  
b6f3 18 03			jr .pastdmark  
b6f5 ..			.dmark: db "MI1"  
b6f8 f1			.pastdmark: pop af  
b6f9			endm  
# End of macro DMARK
b6f9						CALLMONITOR 
b6f9 cd 6f ee			call debug_vector  
b6fc				endm  
# End of macro CALLMONITOR
b6fc					endif 
b6fc cd a0 9a				call forth_push_numhl 
b6ff			 
b6ff				       NEXTW 
b6ff c3 4d 9e			jp macro_next 
b702				endm 
# End of macro NEXTW
b702			.MAX: 
b702				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b702 4a				db WORD_SYS_CORE+54             
b703 83 b7			dw .RND16            
b705 04				db 3 + 1 
b706 .. 00			db "MAX",0              
b70a				endm 
# End of macro CWHEAD
b70a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b70a					if DEBUG_FORTH_WORDS_KEY 
b70a						DMARK "MAX" 
b70a f5				push af  
b70b 3a 1f b7			ld a, (.dmark)  
b70e 32 6b ee			ld (debug_mark),a  
b711 3a 20 b7			ld a, (.dmark+1)  
b714 32 6c ee			ld (debug_mark+1),a  
b717 3a 21 b7			ld a, (.dmark+2)  
b71a 32 6d ee			ld (debug_mark+2),a  
b71d 18 03			jr .pastdmark  
b71f ..			.dmark: db "MAX"  
b722 f1			.pastdmark: pop af  
b723			endm  
# End of macro DMARK
b723						CALLMONITOR 
b723 cd 6f ee			call debug_vector  
b726				endm  
# End of macro CALLMONITOR
b726					endif 
b726					; get u2 
b726			 
b726					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b726 cd 97 9c			call macro_dsp_valuehl 
b729				endm 
# End of macro FORTH_DSP_VALUEHL
b729			 
b729 e5					push hl   ; u2 
b72a			 
b72a					; destroy value TOS 
b72a			 
b72a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b72a cd 4f 9d			call macro_forth_dsp_pop 
b72d				endm 
# End of macro FORTH_DSP_POP
b72d			 
b72d					; get u1 
b72d			 
b72d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b72d cd 97 9c			call macro_dsp_valuehl 
b730				endm 
# End of macro FORTH_DSP_VALUEHL
b730			 
b730 e5					push hl  ; u1 
b731			 
b731					; destroy value TOS 
b731			 
b731					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b731 cd 4f 9d			call macro_forth_dsp_pop 
b734				endm 
# End of macro FORTH_DSP_POP
b734			 
b734 b7			 or a      ;clear carry flag 
b735 e1			  pop hl    ; u1 
b736 d1			  pop de    ; u2 
b737 e5				push hl   ; saved in case hl is lowest 
b738 ed 52		  sbc hl,de 
b73a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b73c			 
b73c e1				pop hl 
b73d					if DEBUG_FORTH_WORDS 
b73d						DMARK "MAX" 
b73d f5				push af  
b73e 3a 52 b7			ld a, (.dmark)  
b741 32 6b ee			ld (debug_mark),a  
b744 3a 53 b7			ld a, (.dmark+1)  
b747 32 6c ee			ld (debug_mark+1),a  
b74a 3a 54 b7			ld a, (.dmark+2)  
b74d 32 6d ee			ld (debug_mark+2),a  
b750 18 03			jr .pastdmark  
b752 ..			.dmark: db "MAX"  
b755 f1			.pastdmark: pop af  
b756			endm  
# End of macro DMARK
b756						CALLMONITOR 
b756 cd 6f ee			call debug_vector  
b759				endm  
# End of macro CALLMONITOR
b759					endif 
b759 cd a0 9a				call forth_push_numhl 
b75c			 
b75c				       NEXTW 
b75c c3 4d 9e			jp macro_next 
b75f				endm 
# End of macro NEXTW
b75f			 
b75f			.maxcont:  
b75f c1				pop bc   ; tidy up 
b760 eb				ex de , hl  
b761					if DEBUG_FORTH_WORDS 
b761						DMARK "MA1" 
b761 f5				push af  
b762 3a 76 b7			ld a, (.dmark)  
b765 32 6b ee			ld (debug_mark),a  
b768 3a 77 b7			ld a, (.dmark+1)  
b76b 32 6c ee			ld (debug_mark+1),a  
b76e 3a 78 b7			ld a, (.dmark+2)  
b771 32 6d ee			ld (debug_mark+2),a  
b774 18 03			jr .pastdmark  
b776 ..			.dmark: db "MA1"  
b779 f1			.pastdmark: pop af  
b77a			endm  
# End of macro DMARK
b77a						CALLMONITOR 
b77a cd 6f ee			call debug_vector  
b77d				endm  
# End of macro CALLMONITOR
b77d					endif 
b77d cd a0 9a				call forth_push_numhl 
b780				       NEXTW 
b780 c3 4d 9e			jp macro_next 
b783				endm 
# End of macro NEXTW
b783			 
b783			.RND16: 
b783				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b783 4e				db WORD_SYS_CORE+58             
b784 b2 b7			dw .RND8            
b786 06				db 5 + 1 
b787 .. 00			db "RND16",0              
b78d				endm 
# End of macro CWHEAD
b78d			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b78d					if DEBUG_FORTH_WORDS_KEY 
b78d						DMARK "R16" 
b78d f5				push af  
b78e 3a a2 b7			ld a, (.dmark)  
b791 32 6b ee			ld (debug_mark),a  
b794 3a a3 b7			ld a, (.dmark+1)  
b797 32 6c ee			ld (debug_mark+1),a  
b79a 3a a4 b7			ld a, (.dmark+2)  
b79d 32 6d ee			ld (debug_mark+2),a  
b7a0 18 03			jr .pastdmark  
b7a2 ..			.dmark: db "R16"  
b7a5 f1			.pastdmark: pop af  
b7a6			endm  
# End of macro DMARK
b7a6						CALLMONITOR 
b7a6 cd 6f ee			call debug_vector  
b7a9				endm  
# End of macro CALLMONITOR
b7a9					endif 
b7a9 cd 02 8c				call prng16  
b7ac cd a0 9a				call forth_push_numhl 
b7af				       NEXTW 
b7af c3 4d 9e			jp macro_next 
b7b2				endm 
# End of macro NEXTW
b7b2			.RND8: 
b7b2				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b7b2 60				db WORD_SYS_CORE+76             
b7b3 e7 b7			dw .RND            
b7b5 05				db 4 + 1 
b7b6 .. 00			db "RND8",0              
b7bb				endm 
# End of macro CWHEAD
b7bb			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7bb					if DEBUG_FORTH_WORDS_KEY 
b7bb						DMARK "RN8" 
b7bb f5				push af  
b7bc 3a d0 b7			ld a, (.dmark)  
b7bf 32 6b ee			ld (debug_mark),a  
b7c2 3a d1 b7			ld a, (.dmark+1)  
b7c5 32 6c ee			ld (debug_mark+1),a  
b7c8 3a d2 b7			ld a, (.dmark+2)  
b7cb 32 6d ee			ld (debug_mark+2),a  
b7ce 18 03			jr .pastdmark  
b7d0 ..			.dmark: db "RN8"  
b7d3 f1			.pastdmark: pop af  
b7d4			endm  
# End of macro DMARK
b7d4						CALLMONITOR 
b7d4 cd 6f ee			call debug_vector  
b7d7				endm  
# End of macro CALLMONITOR
b7d7					endif 
b7d7 2a a9 eb				ld hl,(xrandc) 
b7da 23					inc hl 
b7db cd 1c 8c				call xrnd 
b7de 6f					ld l,a	 
b7df 26 00				ld h,0 
b7e1 cd a0 9a				call forth_push_numhl 
b7e4				       NEXTW 
b7e4 c3 4d 9e			jp macro_next 
b7e7				endm 
# End of macro NEXTW
b7e7			.RND: 
b7e7				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7e7 60				db WORD_SYS_CORE+76             
b7e8 ed b8			dw .ENDMATHS            
b7ea 04				db 3 + 1 
b7eb .. 00			db "RND",0              
b7ef				endm 
# End of macro CWHEAD
b7ef			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7ef			 
b7ef					if DEBUG_FORTH_WORDS_KEY 
b7ef						DMARK "RND" 
b7ef f5				push af  
b7f0 3a 04 b8			ld a, (.dmark)  
b7f3 32 6b ee			ld (debug_mark),a  
b7f6 3a 05 b8			ld a, (.dmark+1)  
b7f9 32 6c ee			ld (debug_mark+1),a  
b7fc 3a 06 b8			ld a, (.dmark+2)  
b7ff 32 6d ee			ld (debug_mark+2),a  
b802 18 03			jr .pastdmark  
b804 ..			.dmark: db "RND"  
b807 f1			.pastdmark: pop af  
b808			endm  
# End of macro DMARK
b808						CALLMONITOR 
b808 cd 6f ee			call debug_vector  
b80b				endm  
# End of macro CALLMONITOR
b80b					endif 
b80b					 
b80b					FORTH_DSP_VALUEHL    ; upper range 
b80b cd 97 9c			call macro_dsp_valuehl 
b80e				endm 
# End of macro FORTH_DSP_VALUEHL
b80e			 
b80e 22 ad eb				ld (LFSRSeed), hl	 
b811			 
b811					if DEBUG_FORTH_WORDS 
b811						DMARK "RN1" 
b811 f5				push af  
b812 3a 26 b8			ld a, (.dmark)  
b815 32 6b ee			ld (debug_mark),a  
b818 3a 27 b8			ld a, (.dmark+1)  
b81b 32 6c ee			ld (debug_mark+1),a  
b81e 3a 28 b8			ld a, (.dmark+2)  
b821 32 6d ee			ld (debug_mark+2),a  
b824 18 03			jr .pastdmark  
b826 ..			.dmark: db "RN1"  
b829 f1			.pastdmark: pop af  
b82a			endm  
# End of macro DMARK
b82a						CALLMONITOR 
b82a cd 6f ee			call debug_vector  
b82d				endm  
# End of macro CALLMONITOR
b82d					endif 
b82d					FORTH_DSP_POP 
b82d cd 4f 9d			call macro_forth_dsp_pop 
b830				endm 
# End of macro FORTH_DSP_POP
b830			 
b830					FORTH_DSP_VALUEHL    ; low range 
b830 cd 97 9c			call macro_dsp_valuehl 
b833				endm 
# End of macro FORTH_DSP_VALUEHL
b833			 
b833					if DEBUG_FORTH_WORDS 
b833						DMARK "RN2" 
b833 f5				push af  
b834 3a 48 b8			ld a, (.dmark)  
b837 32 6b ee			ld (debug_mark),a  
b83a 3a 49 b8			ld a, (.dmark+1)  
b83d 32 6c ee			ld (debug_mark+1),a  
b840 3a 4a b8			ld a, (.dmark+2)  
b843 32 6d ee			ld (debug_mark+2),a  
b846 18 03			jr .pastdmark  
b848 ..			.dmark: db "RN2"  
b84b f1			.pastdmark: pop af  
b84c			endm  
# End of macro DMARK
b84c						CALLMONITOR 
b84c cd 6f ee			call debug_vector  
b84f				endm  
# End of macro CALLMONITOR
b84f					endif 
b84f 22 af eb				ld (LFSRSeed+2), hl 
b852			 
b852					FORTH_DSP_POP 
b852 cd 4f 9d			call macro_forth_dsp_pop 
b855				endm 
# End of macro FORTH_DSP_POP
b855			 
b855 e5					push hl 
b856			 
b856 e1			.inrange:	pop hl 
b857 cd 02 8c				call prng16  
b85a					if DEBUG_FORTH_WORDS 
b85a						DMARK "RN3" 
b85a f5				push af  
b85b 3a 6f b8			ld a, (.dmark)  
b85e 32 6b ee			ld (debug_mark),a  
b861 3a 70 b8			ld a, (.dmark+1)  
b864 32 6c ee			ld (debug_mark+1),a  
b867 3a 71 b8			ld a, (.dmark+2)  
b86a 32 6d ee			ld (debug_mark+2),a  
b86d 18 03			jr .pastdmark  
b86f ..			.dmark: db "RN3"  
b872 f1			.pastdmark: pop af  
b873			endm  
# End of macro DMARK
b873						CALLMONITOR 
b873 cd 6f ee			call debug_vector  
b876				endm  
# End of macro CALLMONITOR
b876					endif 
b876					 
b876					; if the range is 8bit knock out the high byte 
b876			 
b876 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b87a			 
b87a 3e 00				ld a, 0 
b87c ba					cp d  
b87d 20 1e				jr nz, .hirange 
b87f 26 00				ld h, 0   ; knock it down to 8bit 
b881			 
b881					if DEBUG_FORTH_WORDS 
b881						DMARK "RNk" 
b881 f5				push af  
b882 3a 96 b8			ld a, (.dmark)  
b885 32 6b ee			ld (debug_mark),a  
b888 3a 97 b8			ld a, (.dmark+1)  
b88b 32 6c ee			ld (debug_mark+1),a  
b88e 3a 98 b8			ld a, (.dmark+2)  
b891 32 6d ee			ld (debug_mark+2),a  
b894 18 03			jr .pastdmark  
b896 ..			.dmark: db "RNk"  
b899 f1			.pastdmark: pop af  
b89a			endm  
# End of macro DMARK
b89a						CALLMONITOR 
b89a cd 6f ee			call debug_vector  
b89d				endm  
# End of macro CALLMONITOR
b89d					endif 
b89d			.hirange:   
b89d e5					push hl  
b89e b7					or a  
b89f ed 52		                sbc hl, de 
b8a1			 
b8a1					;call cmp16 
b8a1			 
b8a1 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8a3 e1					pop hl 
b8a4 e5					push hl 
b8a5			 
b8a5					if DEBUG_FORTH_WORDS 
b8a5						DMARK "RN4" 
b8a5 f5				push af  
b8a6 3a ba b8			ld a, (.dmark)  
b8a9 32 6b ee			ld (debug_mark),a  
b8ac 3a bb b8			ld a, (.dmark+1)  
b8af 32 6c ee			ld (debug_mark+1),a  
b8b2 3a bc b8			ld a, (.dmark+2)  
b8b5 32 6d ee			ld (debug_mark+2),a  
b8b8 18 03			jr .pastdmark  
b8ba ..			.dmark: db "RN4"  
b8bd f1			.pastdmark: pop af  
b8be			endm  
# End of macro DMARK
b8be						CALLMONITOR 
b8be cd 6f ee			call debug_vector  
b8c1				endm  
# End of macro CALLMONITOR
b8c1					endif 
b8c1 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b8c5					;call cmp16 
b8c5				 
b8c5 b7					or a  
b8c6 ed 52		                sbc hl, de 
b8c8 38 8c				jr c, .inrange 
b8ca			 
b8ca e1					pop hl 
b8cb					 
b8cb					if DEBUG_FORTH_WORDS 
b8cb						DMARK "RNd" 
b8cb f5				push af  
b8cc 3a e0 b8			ld a, (.dmark)  
b8cf 32 6b ee			ld (debug_mark),a  
b8d2 3a e1 b8			ld a, (.dmark+1)  
b8d5 32 6c ee			ld (debug_mark+1),a  
b8d8 3a e2 b8			ld a, (.dmark+2)  
b8db 32 6d ee			ld (debug_mark+2),a  
b8de 18 03			jr .pastdmark  
b8e0 ..			.dmark: db "RNd"  
b8e3 f1			.pastdmark: pop af  
b8e4			endm  
# End of macro DMARK
b8e4						CALLMONITOR 
b8e4 cd 6f ee			call debug_vector  
b8e7				endm  
# End of macro CALLMONITOR
b8e7					endif 
b8e7			 
b8e7			 
b8e7 cd a0 9a				call forth_push_numhl 
b8ea				       NEXTW 
b8ea c3 4d 9e			jp macro_next 
b8ed				endm 
# End of macro NEXTW
b8ed			 
b8ed			.ENDMATHS: 
b8ed			 
b8ed			; eof 
b8ed			 
# End of file forth_words_maths.asm
b8ed			include "forth_words_display.asm" 
b8ed			 
b8ed			; | ## Display Words 
b8ed			 
b8ed			.ACT: 
b8ed			 
b8ed				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8ed 62				db WORD_SYS_CORE+78             
b8ee 39 b9			dw .INFO            
b8f0 07				db 6 + 1 
b8f1 .. 00			db "ACTIVE",0              
b8f8				endm 
# End of macro CWHEAD
b8f8			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8f8			;  
b8f8			; | | To display a pulsing activity indicator in a processing loop do this... 
b8f8			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b8f8			 
b8f8					if DEBUG_FORTH_WORDS_KEY 
b8f8						DMARK "ACT" 
b8f8 f5				push af  
b8f9 3a 0d b9			ld a, (.dmark)  
b8fc 32 6b ee			ld (debug_mark),a  
b8ff 3a 0e b9			ld a, (.dmark+1)  
b902 32 6c ee			ld (debug_mark+1),a  
b905 3a 0f b9			ld a, (.dmark+2)  
b908 32 6d ee			ld (debug_mark+2),a  
b90b 18 03			jr .pastdmark  
b90d ..			.dmark: db "ACT"  
b910 f1			.pastdmark: pop af  
b911			endm  
# End of macro DMARK
b911						CALLMONITOR 
b911 cd 6f ee			call debug_vector  
b914				endm  
# End of macro CALLMONITOR
b914					endif 
b914 cd 05 8a				call active 
b917					if DEBUG_FORTH_WORDS 
b917						DMARK "ACp" 
b917 f5				push af  
b918 3a 2c b9			ld a, (.dmark)  
b91b 32 6b ee			ld (debug_mark),a  
b91e 3a 2d b9			ld a, (.dmark+1)  
b921 32 6c ee			ld (debug_mark+1),a  
b924 3a 2e b9			ld a, (.dmark+2)  
b927 32 6d ee			ld (debug_mark+2),a  
b92a 18 03			jr .pastdmark  
b92c ..			.dmark: db "ACp"  
b92f f1			.pastdmark: pop af  
b930			endm  
# End of macro DMARK
b930						CALLMONITOR 
b930 cd 6f ee			call debug_vector  
b933				endm  
# End of macro CALLMONITOR
b933					endif 
b933 cd 0e 9b				call forth_push_str 
b936			 
b936					NEXTW 
b936 c3 4d 9e			jp macro_next 
b939				endm 
# End of macro NEXTW
b939			.INFO: 
b939			 
b939				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b939 62				db WORD_SYS_CORE+78             
b93a 56 b9			dw .ATP            
b93c 05				db 4 + 1 
b93d .. 00			db "INFO",0              
b942				endm 
# End of macro CWHEAD
b942			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b942					FORTH_DSP_VALUEHL 
b942 cd 97 9c			call macro_dsp_valuehl 
b945				endm 
# End of macro FORTH_DSP_VALUEHL
b945			 
b945					FORTH_DSP_POP 
b945 cd 4f 9d			call macro_forth_dsp_pop 
b948				endm 
# End of macro FORTH_DSP_POP
b948			 
b948 e5					push hl 
b949			 
b949					FORTH_DSP_VALUEHL 
b949 cd 97 9c			call macro_dsp_valuehl 
b94c				endm 
# End of macro FORTH_DSP_VALUEHL
b94c			 
b94c					FORTH_DSP_POP 
b94c cd 4f 9d			call macro_forth_dsp_pop 
b94f				endm 
# End of macro FORTH_DSP_POP
b94f			 
b94f d1					pop de 
b950			 
b950 cd 3f 8a				call info_panel 
b953			 
b953			 
b953					NEXTW 
b953 c3 4d 9e			jp macro_next 
b956				endm 
# End of macro NEXTW
b956			.ATP: 
b956				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b956 62				db WORD_SYS_CORE+78             
b957 cd b9			dw .FB            
b959 04				db 3 + 1 
b95a .. 00			db "AT?",0              
b95e				endm 
# End of macro CWHEAD
b95e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b95e					if DEBUG_FORTH_WORDS_KEY 
b95e						DMARK "AT?" 
b95e f5				push af  
b95f 3a 73 b9			ld a, (.dmark)  
b962 32 6b ee			ld (debug_mark),a  
b965 3a 74 b9			ld a, (.dmark+1)  
b968 32 6c ee			ld (debug_mark+1),a  
b96b 3a 75 b9			ld a, (.dmark+2)  
b96e 32 6d ee			ld (debug_mark+2),a  
b971 18 03			jr .pastdmark  
b973 ..			.dmark: db "AT?"  
b976 f1			.pastdmark: pop af  
b977			endm  
# End of macro DMARK
b977						CALLMONITOR 
b977 cd 6f ee			call debug_vector  
b97a				endm  
# End of macro CALLMONITOR
b97a					endif 
b97a 3a 5e ea				ld a, (f_cursor_ptr) 
b97d			 
b97d			if DEBUG_FORTH_WORDS 
b97d				DMARK "AT?" 
b97d f5				push af  
b97e 3a 92 b9			ld a, (.dmark)  
b981 32 6b ee			ld (debug_mark),a  
b984 3a 93 b9			ld a, (.dmark+1)  
b987 32 6c ee			ld (debug_mark+1),a  
b98a 3a 94 b9			ld a, (.dmark+2)  
b98d 32 6d ee			ld (debug_mark+2),a  
b990 18 03			jr .pastdmark  
b992 ..			.dmark: db "AT?"  
b995 f1			.pastdmark: pop af  
b996			endm  
# End of macro DMARK
b996				CALLMONITOR 
b996 cd 6f ee			call debug_vector  
b999				endm  
# End of macro CALLMONITOR
b999			endif	 
b999					; count the number of rows 
b999			 
b999 06 00				ld b, 0 
b99b 4f			.atpr:		ld c, a    ; save in case we go below zero 
b99c d6 28				sub display_cols 
b99e f2 a4 b9				jp p, .atprunder 
b9a1 04					inc b 
b9a2 18 f7				jr .atpr 
b9a4			.atprunder:	 
b9a4			if DEBUG_FORTH_WORDS 
b9a4				DMARK "A?2" 
b9a4 f5				push af  
b9a5 3a b9 b9			ld a, (.dmark)  
b9a8 32 6b ee			ld (debug_mark),a  
b9ab 3a ba b9			ld a, (.dmark+1)  
b9ae 32 6c ee			ld (debug_mark+1),a  
b9b1 3a bb b9			ld a, (.dmark+2)  
b9b4 32 6d ee			ld (debug_mark+2),a  
b9b7 18 03			jr .pastdmark  
b9b9 ..			.dmark: db "A?2"  
b9bc f1			.pastdmark: pop af  
b9bd			endm  
# End of macro DMARK
b9bd				CALLMONITOR 
b9bd cd 6f ee			call debug_vector  
b9c0				endm  
# End of macro CALLMONITOR
b9c0			endif	 
b9c0 26 00				ld h, 0 
b9c2 69					ld l, c 
b9c3 cd a0 9a				call forth_push_numhl 
b9c6 68					ld l, b  
b9c7 cd a0 9a				call forth_push_numhl 
b9ca			 
b9ca			 
b9ca				NEXTW 
b9ca c3 4d 9e			jp macro_next 
b9cd				endm 
# End of macro NEXTW
b9cd			 
b9cd			.FB: 
b9cd				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9cd 1b				db WORD_SYS_CORE+7             
b9ce 1b ba			dw .EMIT            
b9d0 03				db 2 + 1 
b9d1 .. 00			db "FB",0              
b9d4				endm 
# End of macro CWHEAD
b9d4			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9d4			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9d4			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9d4			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9d4					if DEBUG_FORTH_WORDS_KEY 
b9d4						DMARK "FB." 
b9d4 f5				push af  
b9d5 3a e9 b9			ld a, (.dmark)  
b9d8 32 6b ee			ld (debug_mark),a  
b9db 3a ea b9			ld a, (.dmark+1)  
b9de 32 6c ee			ld (debug_mark+1),a  
b9e1 3a eb b9			ld a, (.dmark+2)  
b9e4 32 6d ee			ld (debug_mark+2),a  
b9e7 18 03			jr .pastdmark  
b9e9 ..			.dmark: db "FB."  
b9ec f1			.pastdmark: pop af  
b9ed			endm  
# End of macro DMARK
b9ed						CALLMONITOR 
b9ed cd 6f ee			call debug_vector  
b9f0				endm  
# End of macro CALLMONITOR
b9f0					endif 
b9f0			 
b9f0					FORTH_DSP_VALUEHL 
b9f0 cd 97 9c			call macro_dsp_valuehl 
b9f3				endm 
# End of macro FORTH_DSP_VALUEHL
b9f3			 
b9f3 7d					ld a, l 
b9f4 fe 01				cp 1 
b9f6 20 05				jr nz, .fbn1 
b9f8 21 10 ed				ld hl, display_fb1 
b9fb 18 15				jr .fbset 
b9fd fe 02		.fbn1:		cp 2 
b9ff 20 05				jr nz, .fbn2 
ba01 21 ce eb				ld hl, display_fb2 
ba04 18 0c				jr .fbset 
ba06 fe 03		.fbn2:		cp 3 
ba08 20 05				jr nz, .fbn3 
ba0a 21 6f ec				ld hl, display_fb3 
ba0d 18 03				jr .fbset 
ba0f			.fbn3:		 ; if invalid number select first 
ba0f 21 10 ed				ld hl, display_fb1 
ba12 22 cc eb		.fbset:		ld (display_fb_active), hl 
ba15			 
ba15					FORTH_DSP_POP 
ba15 cd 4f 9d			call macro_forth_dsp_pop 
ba18				endm 
# End of macro FORTH_DSP_POP
ba18			 
ba18					NEXTW 
ba18 c3 4d 9e			jp macro_next 
ba1b				endm 
# End of macro NEXTW
ba1b			 
ba1b			 
ba1b			.EMIT: 
ba1b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba1b 1b				db WORD_SYS_CORE+7             
ba1c 6c ba			dw .DOTH            
ba1e 05				db 4 + 1 
ba1f .. 00			db "EMIT",0              
ba24				endm 
# End of macro CWHEAD
ba24			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba24					; get value off TOS and display it 
ba24			 
ba24					if DEBUG_FORTH_WORDS_KEY 
ba24						DMARK "EMT" 
ba24 f5				push af  
ba25 3a 39 ba			ld a, (.dmark)  
ba28 32 6b ee			ld (debug_mark),a  
ba2b 3a 3a ba			ld a, (.dmark+1)  
ba2e 32 6c ee			ld (debug_mark+1),a  
ba31 3a 3b ba			ld a, (.dmark+2)  
ba34 32 6d ee			ld (debug_mark+2),a  
ba37 18 03			jr .pastdmark  
ba39 ..			.dmark: db "EMT"  
ba3c f1			.pastdmark: pop af  
ba3d			endm  
# End of macro DMARK
ba3d						CALLMONITOR 
ba3d cd 6f ee			call debug_vector  
ba40				endm  
# End of macro CALLMONITOR
ba40					endif 
ba40			 
ba40					FORTH_DSP_VALUEHL 
ba40 cd 97 9c			call macro_dsp_valuehl 
ba43				endm 
# End of macro FORTH_DSP_VALUEHL
ba43			 
ba43 7d					ld a,l 
ba44			 
ba44					; TODO write to display 
ba44			 
ba44 32 bf e4				ld (os_input), a 
ba47 3e 00				ld a, 0 
ba49 32 c0 e4				ld (os_input+1), a 
ba4c					 
ba4c 3a 5e ea				ld a, (f_cursor_ptr) 
ba4f 11 bf e4				ld de, os_input 
ba52 cd c1 8a				call str_at_display 
ba55			 
ba55			 
ba55 3a 3c ea				ld a,(cli_autodisplay) 
ba58 fe 00				cp 0 
ba5a 28 03				jr z, .enoupdate 
ba5c cd d1 8a						call update_display 
ba5f					.enoupdate: 
ba5f			 
ba5f 3a 5e ea				ld a, (f_cursor_ptr) 
ba62 3c					inc a 
ba63 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba66			 
ba66			 
ba66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba66 cd 4f 9d			call macro_forth_dsp_pop 
ba69				endm 
# End of macro FORTH_DSP_POP
ba69			  
ba69			 
ba69					NEXTW 
ba69 c3 4d 9e			jp macro_next 
ba6c				endm 
# End of macro NEXTW
ba6c			.DOTH: 
ba6c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba6c 1c				db WORD_SYS_CORE+8             
ba6d 9c ba			dw .DOTF            
ba6f 03				db 2 + 1 
ba70 .. 00			db ".-",0              
ba73				endm 
# End of macro CWHEAD
ba73			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba73					; get value off TOS and display it 
ba73					if DEBUG_FORTH_WORDS_KEY 
ba73						DMARK "DTD" 
ba73 f5				push af  
ba74 3a 88 ba			ld a, (.dmark)  
ba77 32 6b ee			ld (debug_mark),a  
ba7a 3a 89 ba			ld a, (.dmark+1)  
ba7d 32 6c ee			ld (debug_mark+1),a  
ba80 3a 8a ba			ld a, (.dmark+2)  
ba83 32 6d ee			ld (debug_mark+2),a  
ba86 18 03			jr .pastdmark  
ba88 ..			.dmark: db "DTD"  
ba8b f1			.pastdmark: pop af  
ba8c			endm  
# End of macro DMARK
ba8c						CALLMONITOR 
ba8c cd 6f ee			call debug_vector  
ba8f				endm  
# End of macro CALLMONITOR
ba8f					endif 
ba8f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba91 3e 00			ld a, 0 
ba93 32 3d ea			ld (cli_mvdot), a 
ba96 c3 f3 ba			jp .dotgo 
ba99				NEXTW 
ba99 c3 4d 9e			jp macro_next 
ba9c				endm 
# End of macro NEXTW
ba9c			.DOTF: 
ba9c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba9c 1c				db WORD_SYS_CORE+8             
ba9d ca ba			dw .DOT            
ba9f 03				db 2 + 1 
baa0 .. 00			db ".>",0              
baa3				endm 
# End of macro CWHEAD
baa3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
baa3					; get value off TOS and display it 
baa3			        ; TODO BUG adds extra spaces 
baa3			        ; TODO BUG handle numerics? 
baa3					if DEBUG_FORTH_WORDS_KEY 
baa3						DMARK "DTC" 
baa3 f5				push af  
baa4 3a b8 ba			ld a, (.dmark)  
baa7 32 6b ee			ld (debug_mark),a  
baaa 3a b9 ba			ld a, (.dmark+1)  
baad 32 6c ee			ld (debug_mark+1),a  
bab0 3a ba ba			ld a, (.dmark+2)  
bab3 32 6d ee			ld (debug_mark+2),a  
bab6 18 03			jr .pastdmark  
bab8 ..			.dmark: db "DTC"  
babb f1			.pastdmark: pop af  
babc			endm  
# End of macro DMARK
babc						CALLMONITOR 
babc cd 6f ee			call debug_vector  
babf				endm  
# End of macro CALLMONITOR
babf					endif 
babf 3e 01			ld a, 1 
bac1 32 3d ea			ld (cli_mvdot), a 
bac4 c3 f3 ba			jp .dotgo 
bac7				NEXTW 
bac7 c3 4d 9e			jp macro_next 
baca				endm 
# End of macro NEXTW
baca			 
baca			.DOT: 
baca				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
baca 1c				db WORD_SYS_CORE+8             
bacb a6 bc			dw .CLS            
bacd 02				db 1 + 1 
bace .. 00			db ".",0              
bad0				endm 
# End of macro CWHEAD
bad0			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bad0					; get value off TOS and display it 
bad0			 
bad0					if DEBUG_FORTH_WORDS_KEY 
bad0						DMARK "DOT" 
bad0 f5				push af  
bad1 3a e5 ba			ld a, (.dmark)  
bad4 32 6b ee			ld (debug_mark),a  
bad7 3a e6 ba			ld a, (.dmark+1)  
bada 32 6c ee			ld (debug_mark+1),a  
badd 3a e7 ba			ld a, (.dmark+2)  
bae0 32 6d ee			ld (debug_mark+2),a  
bae3 18 03			jr .pastdmark  
bae5 ..			.dmark: db "DOT"  
bae8 f1			.pastdmark: pop af  
bae9			endm  
# End of macro DMARK
bae9						CALLMONITOR 
bae9 cd 6f ee			call debug_vector  
baec				endm  
# End of macro CALLMONITOR
baec					endif 
baec 3e 00			ld a, 0 
baee 32 3d ea			ld (cli_mvdot), a 
baf1 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
baf3				 
baf3			 
baf3			.dotgo: 
baf3			 
baf3			; move up type to on stack for parserv5 
baf3					FORTH_DSP 
baf3 cd 5d 9c			call macro_forth_dsp 
baf6				endm 
# End of macro FORTH_DSP
baf6				;FORTH_DSP_VALUE  
baf6			 
baf6			if DEBUG_FORTH_DOT 
baf6				DMARK "DOT" 
baf6 f5				push af  
baf7 3a 0b bb			ld a, (.dmark)  
bafa 32 6b ee			ld (debug_mark),a  
bafd 3a 0c bb			ld a, (.dmark+1)  
bb00 32 6c ee			ld (debug_mark+1),a  
bb03 3a 0d bb			ld a, (.dmark+2)  
bb06 32 6d ee			ld (debug_mark+2),a  
bb09 18 03			jr .pastdmark  
bb0b ..			.dmark: db "DOT"  
bb0e f1			.pastdmark: pop af  
bb0f			endm  
# End of macro DMARK
bb0f				CALLMONITOR 
bb0f cd 6f ee			call debug_vector  
bb12				endm  
# End of macro CALLMONITOR
bb12			endif	 
bb12			;		.print: 
bb12			 
bb12 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb13 23				inc hl   ; position to the actual value 
bb14 fe 01			cp DS_TYPE_STR 
bb16 20 06			jr nz, .dotnum1  
bb18			 
bb18			; display string 
bb18				FORTH_DSP_VALUE  
bb18 cd 80 9c			call macro_forth_dsp_value 
bb1b				endm 
# End of macro FORTH_DSP_VALUE
bb1b eb				ex de,hl 
bb1c 18 49			jr .dotwrite 
bb1e			 
bb1e			.dotnum1: 
bb1e fe 02			cp DS_TYPE_INUM 
bb20 20 44			jr nz, .dotflot 
bb22			 
bb22			 
bb22			; display number 
bb22			 
bb22			;	push hl 
bb22			;	call clear_display 
bb22			;	pop hl 
bb22			 
bb22 5e				ld e, (hl) 
bb23 23				inc hl 
bb24 56				ld d, (hl) 
bb25 21 c1 e2			ld hl, scratch 
bb28			if DEBUG_FORTH_DOT 
bb28				DMARK "DT1" 
bb28 f5				push af  
bb29 3a 3d bb			ld a, (.dmark)  
bb2c 32 6b ee			ld (debug_mark),a  
bb2f 3a 3e bb			ld a, (.dmark+1)  
bb32 32 6c ee			ld (debug_mark+1),a  
bb35 3a 3f bb			ld a, (.dmark+2)  
bb38 32 6d ee			ld (debug_mark+2),a  
bb3b 18 03			jr .pastdmark  
bb3d ..			.dmark: db "DT1"  
bb40 f1			.pastdmark: pop af  
bb41			endm  
# End of macro DMARK
bb41				CALLMONITOR 
bb41 cd 6f ee			call debug_vector  
bb44				endm  
# End of macro CALLMONITOR
bb44			endif	 
bb44			 
bb44 cd 41 90			call uitoa_16 
bb47 eb				ex de,hl 
bb48			 
bb48			if DEBUG_FORTH_DOT 
bb48				DMARK "DT2" 
bb48 f5				push af  
bb49 3a 5d bb			ld a, (.dmark)  
bb4c 32 6b ee			ld (debug_mark),a  
bb4f 3a 5e bb			ld a, (.dmark+1)  
bb52 32 6c ee			ld (debug_mark+1),a  
bb55 3a 5f bb			ld a, (.dmark+2)  
bb58 32 6d ee			ld (debug_mark+2),a  
bb5b 18 03			jr .pastdmark  
bb5d ..			.dmark: db "DT2"  
bb60 f1			.pastdmark: pop af  
bb61			endm  
# End of macro DMARK
bb61				CALLMONITOR 
bb61 cd 6f ee			call debug_vector  
bb64				endm  
# End of macro CALLMONITOR
bb64			endif	 
bb64			 
bb64			;	ld de, os_word_scratch 
bb64 18 01			jr .dotwrite 
bb66			 
bb66 00			.dotflot:   nop 
bb67			; TODO print floating point number 
bb67			 
bb67			.dotwrite:		 
bb67			 
bb67					; if c is set then set all '-' to spaces 
bb67					; need to also take into account .>  
bb67			 
bb67 3e 01				ld a, 1 
bb69 b9					cp c 
bb6a 20 67				jr nz, .nodashswap 
bb6c			 
bb6c					; DE has the string to write, working with HL 
bb6c			 
bb6c 06 ff				ld b, 255 
bb6e d5					push de 
bb6f e1					pop hl 
bb70			 
bb70			if DEBUG_FORTH_DOT 
bb70				DMARK "DT-" 
bb70 f5				push af  
bb71 3a 85 bb			ld a, (.dmark)  
bb74 32 6b ee			ld (debug_mark),a  
bb77 3a 86 bb			ld a, (.dmark+1)  
bb7a 32 6c ee			ld (debug_mark+1),a  
bb7d 3a 87 bb			ld a, (.dmark+2)  
bb80 32 6d ee			ld (debug_mark+2),a  
bb83 18 03			jr .pastdmark  
bb85 ..			.dmark: db "DT-"  
bb88 f1			.pastdmark: pop af  
bb89			endm  
# End of macro DMARK
bb89				CALLMONITOR 
bb89 cd 6f ee			call debug_vector  
bb8c				endm  
# End of macro CALLMONITOR
bb8c			endif	 
bb8c 7e			.dashscan:	ld a, (hl) 
bb8d fe 00				cp 0 
bb8f 28 42				jr z, .nodashswap 
bb91 fe 2d				cp '-' 
bb93 20 03				jr nz, .dashskip 
bb95 3e 20				ld a, ' ' 
bb97 77					ld (hl), a 
bb98 23			.dashskip:	inc hl 
bb99			if DEBUG_FORTH_DOT 
bb99				DMARK "D-2" 
bb99 f5				push af  
bb9a 3a ae bb			ld a, (.dmark)  
bb9d 32 6b ee			ld (debug_mark),a  
bba0 3a af bb			ld a, (.dmark+1)  
bba3 32 6c ee			ld (debug_mark+1),a  
bba6 3a b0 bb			ld a, (.dmark+2)  
bba9 32 6d ee			ld (debug_mark+2),a  
bbac 18 03			jr .pastdmark  
bbae ..			.dmark: db "D-2"  
bbb1 f1			.pastdmark: pop af  
bbb2			endm  
# End of macro DMARK
bbb2				CALLMONITOR 
bbb2 cd 6f ee			call debug_vector  
bbb5				endm  
# End of macro CALLMONITOR
bbb5			endif	 
bbb5 10 d5				djnz .dashscan 
bbb7			 
bbb7			if DEBUG_FORTH_DOT 
bbb7				DMARK "D-1" 
bbb7 f5				push af  
bbb8 3a cc bb			ld a, (.dmark)  
bbbb 32 6b ee			ld (debug_mark),a  
bbbe 3a cd bb			ld a, (.dmark+1)  
bbc1 32 6c ee			ld (debug_mark+1),a  
bbc4 3a ce bb			ld a, (.dmark+2)  
bbc7 32 6d ee			ld (debug_mark+2),a  
bbca 18 03			jr .pastdmark  
bbcc ..			.dmark: db "D-1"  
bbcf f1			.pastdmark: pop af  
bbd0			endm  
# End of macro DMARK
bbd0				CALLMONITOR 
bbd0 cd 6f ee			call debug_vector  
bbd3				endm  
# End of macro CALLMONITOR
bbd3			endif	 
bbd3			 
bbd3			.nodashswap: 
bbd3			 
bbd3			if DEBUG_FORTH_DOT 
bbd3				DMARK "D-o" 
bbd3 f5				push af  
bbd4 3a e8 bb			ld a, (.dmark)  
bbd7 32 6b ee			ld (debug_mark),a  
bbda 3a e9 bb			ld a, (.dmark+1)  
bbdd 32 6c ee			ld (debug_mark+1),a  
bbe0 3a ea bb			ld a, (.dmark+2)  
bbe3 32 6d ee			ld (debug_mark+2),a  
bbe6 18 03			jr .pastdmark  
bbe8 ..			.dmark: db "D-o"  
bbeb f1			.pastdmark: pop af  
bbec			endm  
# End of macro DMARK
bbec				CALLMONITOR 
bbec cd 6f ee			call debug_vector  
bbef				endm  
# End of macro CALLMONITOR
bbef			endif	 
bbef			 
bbef d5					push de   ; save string start in case we need to advance print 
bbf0			 
bbf0 3a 5e ea				ld a, (f_cursor_ptr) 
bbf3 cd c1 8a				call str_at_display 
bbf6 3a 3c ea				ld a,(cli_autodisplay) 
bbf9 fe 00				cp 0 
bbfb 28 03				jr z, .noupdate 
bbfd cd d1 8a						call update_display 
bc00					.noupdate: 
bc00			 
bc00			 
bc00					; see if we need to advance the print position 
bc00			 
bc00 e1					pop hl   ; get back string 
bc01			;		ex de,hl 
bc01			 
bc01 3a 3d ea				ld a, (cli_mvdot) 
bc04			if DEBUG_FORTH_DOT 
bc04			;		ld e,a 
bc04				DMARK "D>1" 
bc04 f5				push af  
bc05 3a 19 bc			ld a, (.dmark)  
bc08 32 6b ee			ld (debug_mark),a  
bc0b 3a 1a bc			ld a, (.dmark+1)  
bc0e 32 6c ee			ld (debug_mark+1),a  
bc11 3a 1b bc			ld a, (.dmark+2)  
bc14 32 6d ee			ld (debug_mark+2),a  
bc17 18 03			jr .pastdmark  
bc19 ..			.dmark: db "D>1"  
bc1c f1			.pastdmark: pop af  
bc1d			endm  
# End of macro DMARK
bc1d				CALLMONITOR 
bc1d cd 6f ee			call debug_vector  
bc20				endm  
# End of macro CALLMONITOR
bc20			endif	 
bc20 fe 00				cp 0 
bc22 28 44				jr z, .noadv 
bc24					; yes, lets advance the print position 
bc24 3e 00				ld a, 0 
bc26 cd 9d 90				call strlent 
bc29			if DEBUG_FORTH_DOT 
bc29				DMARK "D-?" 
bc29 f5				push af  
bc2a 3a 3e bc			ld a, (.dmark)  
bc2d 32 6b ee			ld (debug_mark),a  
bc30 3a 3f bc			ld a, (.dmark+1)  
bc33 32 6c ee			ld (debug_mark+1),a  
bc36 3a 40 bc			ld a, (.dmark+2)  
bc39 32 6d ee			ld (debug_mark+2),a  
bc3c 18 03			jr .pastdmark  
bc3e ..			.dmark: db "D-?"  
bc41 f1			.pastdmark: pop af  
bc42			endm  
# End of macro DMARK
bc42				CALLMONITOR 
bc42 cd 6f ee			call debug_vector  
bc45				endm  
# End of macro CALLMONITOR
bc45			endif	 
bc45 3a 5e ea				ld a, (f_cursor_ptr) 
bc48 85					add a,l 
bc49					;call addatohl 
bc49					;ld a, l 
bc49 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc4c			 
bc4c			if DEBUG_FORTH_DOT 
bc4c				DMARK "D->" 
bc4c f5				push af  
bc4d 3a 61 bc			ld a, (.dmark)  
bc50 32 6b ee			ld (debug_mark),a  
bc53 3a 62 bc			ld a, (.dmark+1)  
bc56 32 6c ee			ld (debug_mark+1),a  
bc59 3a 63 bc			ld a, (.dmark+2)  
bc5c 32 6d ee			ld (debug_mark+2),a  
bc5f 18 03			jr .pastdmark  
bc61 ..			.dmark: db "D->"  
bc64 f1			.pastdmark: pop af  
bc65			endm  
# End of macro DMARK
bc65				CALLMONITOR 
bc65 cd 6f ee			call debug_vector  
bc68				endm  
# End of macro CALLMONITOR
bc68			endif	 
bc68			 
bc68			.noadv:	 
bc68			 
bc68					if DEBUG_FORTH_DOT_WAIT 
bc68							call next_page_prompt 
bc68					endif	 
bc68			; TODO this pop off the stack causes a crash. i dont know why 
bc68			 
bc68			 
bc68			if DEBUG_FORTH_DOT 
bc68				DMARK "DTh" 
bc68 f5				push af  
bc69 3a 7d bc			ld a, (.dmark)  
bc6c 32 6b ee			ld (debug_mark),a  
bc6f 3a 7e bc			ld a, (.dmark+1)  
bc72 32 6c ee			ld (debug_mark+1),a  
bc75 3a 7f bc			ld a, (.dmark+2)  
bc78 32 6d ee			ld (debug_mark+2),a  
bc7b 18 03			jr .pastdmark  
bc7d ..			.dmark: db "DTh"  
bc80 f1			.pastdmark: pop af  
bc81			endm  
# End of macro DMARK
bc81				CALLMONITOR 
bc81 cd 6f ee			call debug_vector  
bc84				endm  
# End of macro CALLMONITOR
bc84			endif	 
bc84			 
bc84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc84 cd 4f 9d			call macro_forth_dsp_pop 
bc87				endm 
# End of macro FORTH_DSP_POP
bc87			 
bc87			if DEBUG_FORTH_DOT 
bc87				DMARK "DTi" 
bc87 f5				push af  
bc88 3a 9c bc			ld a, (.dmark)  
bc8b 32 6b ee			ld (debug_mark),a  
bc8e 3a 9d bc			ld a, (.dmark+1)  
bc91 32 6c ee			ld (debug_mark+1),a  
bc94 3a 9e bc			ld a, (.dmark+2)  
bc97 32 6d ee			ld (debug_mark+2),a  
bc9a 18 03			jr .pastdmark  
bc9c ..			.dmark: db "DTi"  
bc9f f1			.pastdmark: pop af  
bca0			endm  
# End of macro DMARK
bca0				CALLMONITOR 
bca0 cd 6f ee			call debug_vector  
bca3				endm  
# End of macro CALLMONITOR
bca3			endif	 
bca3			 
bca3			 
bca3					NEXTW 
bca3 c3 4d 9e			jp macro_next 
bca6				endm 
# End of macro NEXTW
bca6			 
bca6			.CLS: 
bca6				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bca6 35				db WORD_SYS_CORE+33             
bca7 d3 bc			dw .DRAW            
bca9 04				db 3 + 1 
bcaa .. 00			db "CLS",0              
bcae				endm 
# End of macro CWHEAD
bcae			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bcae					if DEBUG_FORTH_WORDS_KEY 
bcae						DMARK "CLS" 
bcae f5				push af  
bcaf 3a c3 bc			ld a, (.dmark)  
bcb2 32 6b ee			ld (debug_mark),a  
bcb5 3a c4 bc			ld a, (.dmark+1)  
bcb8 32 6c ee			ld (debug_mark+1),a  
bcbb 3a c5 bc			ld a, (.dmark+2)  
bcbe 32 6d ee			ld (debug_mark+2),a  
bcc1 18 03			jr .pastdmark  
bcc3 ..			.dmark: db "CLS"  
bcc6 f1			.pastdmark: pop af  
bcc7			endm  
# End of macro DMARK
bcc7						CALLMONITOR 
bcc7 cd 6f ee			call debug_vector  
bcca				endm  
# End of macro CALLMONITOR
bcca					endif 
bcca cd ae 8a				call clear_display 
bccd c3 e1 bd				jp .home		; and home cursor 
bcd0					NEXTW 
bcd0 c3 4d 9e			jp macro_next 
bcd3				endm 
# End of macro NEXTW
bcd3			 
bcd3			.DRAW: 
bcd3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcd3 36				db WORD_SYS_CORE+34             
bcd4 fe bc			dw .DUMP            
bcd6 05				db 4 + 1 
bcd7 .. 00			db "DRAW",0              
bcdc				endm 
# End of macro CWHEAD
bcdc			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bcdc					if DEBUG_FORTH_WORDS_KEY 
bcdc						DMARK "DRW" 
bcdc f5				push af  
bcdd 3a f1 bc			ld a, (.dmark)  
bce0 32 6b ee			ld (debug_mark),a  
bce3 3a f2 bc			ld a, (.dmark+1)  
bce6 32 6c ee			ld (debug_mark+1),a  
bce9 3a f3 bc			ld a, (.dmark+2)  
bcec 32 6d ee			ld (debug_mark+2),a  
bcef 18 03			jr .pastdmark  
bcf1 ..			.dmark: db "DRW"  
bcf4 f1			.pastdmark: pop af  
bcf5			endm  
# End of macro DMARK
bcf5						CALLMONITOR 
bcf5 cd 6f ee			call debug_vector  
bcf8				endm  
# End of macro CALLMONITOR
bcf8					endif 
bcf8 cd d1 8a				call update_display 
bcfb					NEXTW 
bcfb c3 4d 9e			jp macro_next 
bcfe				endm 
# End of macro NEXTW
bcfe			 
bcfe			.DUMP: 
bcfe				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bcfe 37				db WORD_SYS_CORE+35             
bcff 36 bd			dw .CDUMP            
bd01 05				db 4 + 1 
bd02 .. 00			db "DUMP",0              
bd07				endm 
# End of macro CWHEAD
bd07			; | DUMP ( x -- ) With address x display dump   | DONE 
bd07			; TODO pop address to use off of the stack 
bd07					if DEBUG_FORTH_WORDS_KEY 
bd07						DMARK "DUM" 
bd07 f5				push af  
bd08 3a 1c bd			ld a, (.dmark)  
bd0b 32 6b ee			ld (debug_mark),a  
bd0e 3a 1d bd			ld a, (.dmark+1)  
bd11 32 6c ee			ld (debug_mark+1),a  
bd14 3a 1e bd			ld a, (.dmark+2)  
bd17 32 6d ee			ld (debug_mark+2),a  
bd1a 18 03			jr .pastdmark  
bd1c ..			.dmark: db "DUM"  
bd1f f1			.pastdmark: pop af  
bd20			endm  
# End of macro DMARK
bd20						CALLMONITOR 
bd20 cd 6f ee			call debug_vector  
bd23				endm  
# End of macro CALLMONITOR
bd23					endif 
bd23 cd ae 8a				call clear_display 
bd26			 
bd26					; get address 
bd26			 
bd26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd26 cd 97 9c			call macro_dsp_valuehl 
bd29				endm 
# End of macro FORTH_DSP_VALUEHL
bd29				 
bd29					; save it for cdump 
bd29			 
bd29 22 e4 e5				ld (os_cur_ptr),hl 
bd2c			 
bd2c					; destroy value TOS 
bd2c			 
bd2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2c cd 4f 9d			call macro_forth_dsp_pop 
bd2f				endm 
# End of macro FORTH_DSP_POP
bd2f			 
bd2f cd 20 99				call dumpcont	; skip old style of param parsing	 
bd32 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd33					NEXTW 
bd33 c3 4d 9e			jp macro_next 
bd36				endm 
# End of macro NEXTW
bd36			.CDUMP: 
bd36				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd36 38				db WORD_SYS_CORE+36             
bd37 66 bd			dw .DAT            
bd39 06				db 5 + 1 
bd3a .. 00			db "CDUMP",0              
bd40				endm 
# End of macro CWHEAD
bd40			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd40					if DEBUG_FORTH_WORDS_KEY 
bd40						DMARK "CDP" 
bd40 f5				push af  
bd41 3a 55 bd			ld a, (.dmark)  
bd44 32 6b ee			ld (debug_mark),a  
bd47 3a 56 bd			ld a, (.dmark+1)  
bd4a 32 6c ee			ld (debug_mark+1),a  
bd4d 3a 57 bd			ld a, (.dmark+2)  
bd50 32 6d ee			ld (debug_mark+2),a  
bd53 18 03			jr .pastdmark  
bd55 ..			.dmark: db "CDP"  
bd58 f1			.pastdmark: pop af  
bd59			endm  
# End of macro DMARK
bd59						CALLMONITOR 
bd59 cd 6f ee			call debug_vector  
bd5c				endm  
# End of macro CALLMONITOR
bd5c					endif 
bd5c cd ae 8a				call clear_display 
bd5f cd 20 99				call dumpcont	 
bd62 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd63					NEXTW 
bd63 c3 4d 9e			jp macro_next 
bd66				endm 
# End of macro NEXTW
bd66			 
bd66			 
bd66			 
bd66			 
bd66			.DAT: 
bd66				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd66 3d				db WORD_SYS_CORE+41             
bd67 bc bd			dw .HOME            
bd69 03				db 2 + 1 
bd6a .. 00			db "AT",0              
bd6d				endm 
# End of macro CWHEAD
bd6d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd6d					if DEBUG_FORTH_WORDS_KEY 
bd6d						DMARK "AT." 
bd6d f5				push af  
bd6e 3a 82 bd			ld a, (.dmark)  
bd71 32 6b ee			ld (debug_mark),a  
bd74 3a 83 bd			ld a, (.dmark+1)  
bd77 32 6c ee			ld (debug_mark+1),a  
bd7a 3a 84 bd			ld a, (.dmark+2)  
bd7d 32 6d ee			ld (debug_mark+2),a  
bd80 18 03			jr .pastdmark  
bd82 ..			.dmark: db "AT."  
bd85 f1			.pastdmark: pop af  
bd86			endm  
# End of macro DMARK
bd86						CALLMONITOR 
bd86 cd 6f ee			call debug_vector  
bd89				endm  
# End of macro CALLMONITOR
bd89					endif 
bd89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd89 cd 97 9c			call macro_dsp_valuehl 
bd8c				endm 
# End of macro FORTH_DSP_VALUEHL
bd8c			 
bd8c			 
bd8c					; TODO save cursor row 
bd8c 7d					ld a,l 
bd8d fe 02				cp 2 
bd8f 20 04				jr nz, .crow3 
bd91 3e 28				ld a, display_row_2 
bd93 18 12				jr .ccol1 
bd95 fe 03		.crow3:		cp 3 
bd97 20 04				jr nz, .crow4 
bd99 3e 50				ld a, display_row_3 
bd9b 18 0a				jr .ccol1 
bd9d fe 04		.crow4:		cp 4 
bd9f 20 04				jr nz, .crow1 
bda1 3e 78				ld a, display_row_4 
bda3 18 02				jr .ccol1 
bda5 3e 00		.crow1:		ld a,display_row_1 
bda7 f5			.ccol1:		push af			; got row offset 
bda8 6f					ld l,a 
bda9 26 00				ld h,0 
bdab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdab cd 4f 9d			call macro_forth_dsp_pop 
bdae				endm 
# End of macro FORTH_DSP_POP
bdae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdae cd 97 9c			call macro_dsp_valuehl 
bdb1				endm 
# End of macro FORTH_DSP_VALUEHL
bdb1					; TODO save cursor col 
bdb1 f1					pop af 
bdb2 85					add l		; add col offset 
bdb3 32 5e ea				ld (f_cursor_ptr), a 
bdb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdb6 cd 4f 9d			call macro_forth_dsp_pop 
bdb9				endm 
# End of macro FORTH_DSP_POP
bdb9			 
bdb9					; calculate  
bdb9			 
bdb9					NEXTW 
bdb9 c3 4d 9e			jp macro_next 
bdbc				endm 
# End of macro NEXTW
bdbc			 
bdbc			 
bdbc			.HOME: 
bdbc				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bdbc 41				db WORD_SYS_CORE+45             
bdbd e9 bd			dw .CR            
bdbf 05				db 4 + 1 
bdc0 .. 00			db "HOME",0              
bdc5				endm 
# End of macro CWHEAD
bdc5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdc5					if DEBUG_FORTH_WORDS_KEY 
bdc5						DMARK "HOM" 
bdc5 f5				push af  
bdc6 3a da bd			ld a, (.dmark)  
bdc9 32 6b ee			ld (debug_mark),a  
bdcc 3a db bd			ld a, (.dmark+1)  
bdcf 32 6c ee			ld (debug_mark+1),a  
bdd2 3a dc bd			ld a, (.dmark+2)  
bdd5 32 6d ee			ld (debug_mark+2),a  
bdd8 18 03			jr .pastdmark  
bdda ..			.dmark: db "HOM"  
bddd f1			.pastdmark: pop af  
bdde			endm  
# End of macro DMARK
bdde						CALLMONITOR 
bdde cd 6f ee			call debug_vector  
bde1				endm  
# End of macro CALLMONITOR
bde1					endif 
bde1 3e 00		.home:		ld a, 0		; and home cursor 
bde3 32 5e ea				ld (f_cursor_ptr), a 
bde6					NEXTW 
bde6 c3 4d 9e			jp macro_next 
bde9				endm 
# End of macro NEXTW
bde9			 
bde9			 
bde9			.CR: 
bde9				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bde9 46				db WORD_SYS_CORE+50             
bdea 24 be			dw .SPACE            
bdec 03				db 2 + 1 
bded .. 00			db "CR",0              
bdf0				endm 
# End of macro CWHEAD
bdf0			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bdf0					if DEBUG_FORTH_WORDS_KEY 
bdf0						DMARK "CR." 
bdf0 f5				push af  
bdf1 3a 05 be			ld a, (.dmark)  
bdf4 32 6b ee			ld (debug_mark),a  
bdf7 3a 06 be			ld a, (.dmark+1)  
bdfa 32 6c ee			ld (debug_mark+1),a  
bdfd 3a 07 be			ld a, (.dmark+2)  
be00 32 6d ee			ld (debug_mark+2),a  
be03 18 03			jr .pastdmark  
be05 ..			.dmark: db "CR."  
be08 f1			.pastdmark: pop af  
be09			endm  
# End of macro DMARK
be09						CALLMONITOR 
be09 cd 6f ee			call debug_vector  
be0c				endm  
# End of macro CALLMONITOR
be0c					endif 
be0c 3e 0d				ld a, 13 
be0e 32 c1 e2				ld (scratch),a 
be11 3e 0a				ld a, 10 
be13 32 c2 e2				ld (scratch+1),a 
be16 3e 00				ld a, 0 
be18 32 c3 e2				ld (scratch+2),a 
be1b 21 c1 e2				ld hl, scratch 
be1e cd 0e 9b				call forth_push_str 
be21					 
be21				       NEXTW 
be21 c3 4d 9e			jp macro_next 
be24				endm 
# End of macro NEXTW
be24			.SPACE: 
be24				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be24 46				db WORD_SYS_CORE+50             
be25 5a be			dw .SPACES            
be27 03				db 2 + 1 
be28 .. 00			db "BL",0              
be2b				endm 
# End of macro CWHEAD
be2b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be2b					if DEBUG_FORTH_WORDS_KEY 
be2b						DMARK "BL." 
be2b f5				push af  
be2c 3a 40 be			ld a, (.dmark)  
be2f 32 6b ee			ld (debug_mark),a  
be32 3a 41 be			ld a, (.dmark+1)  
be35 32 6c ee			ld (debug_mark+1),a  
be38 3a 42 be			ld a, (.dmark+2)  
be3b 32 6d ee			ld (debug_mark+2),a  
be3e 18 03			jr .pastdmark  
be40 ..			.dmark: db "BL."  
be43 f1			.pastdmark: pop af  
be44			endm  
# End of macro DMARK
be44						CALLMONITOR 
be44 cd 6f ee			call debug_vector  
be47				endm  
# End of macro CALLMONITOR
be47					endif 
be47 3e 20				ld a, " " 
be49 32 c1 e2				ld (scratch),a 
be4c 3e 00				ld a, 0 
be4e 32 c2 e2				ld (scratch+1),a 
be51 21 c1 e2				ld hl, scratch 
be54 cd 0e 9b				call forth_push_str 
be57					 
be57				       NEXTW 
be57 c3 4d 9e			jp macro_next 
be5a				endm 
# End of macro NEXTW
be5a			 
be5a			;.blstr: db " ", 0 
be5a			 
be5a			.SPACES: 
be5a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be5a 47				db WORD_SYS_CORE+51             
be5b f5 be			dw .SCROLL            
be5d 07				db 6 + 1 
be5e .. 00			db "SPACES",0              
be65				endm 
# End of macro CWHEAD
be65			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be65					if DEBUG_FORTH_WORDS_KEY 
be65						DMARK "SPS" 
be65 f5				push af  
be66 3a 7a be			ld a, (.dmark)  
be69 32 6b ee			ld (debug_mark),a  
be6c 3a 7b be			ld a, (.dmark+1)  
be6f 32 6c ee			ld (debug_mark+1),a  
be72 3a 7c be			ld a, (.dmark+2)  
be75 32 6d ee			ld (debug_mark+2),a  
be78 18 03			jr .pastdmark  
be7a ..			.dmark: db "SPS"  
be7d f1			.pastdmark: pop af  
be7e			endm  
# End of macro DMARK
be7e						CALLMONITOR 
be7e cd 6f ee			call debug_vector  
be81				endm  
# End of macro CALLMONITOR
be81					endif 
be81			 
be81			 
be81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be81 cd 97 9c			call macro_dsp_valuehl 
be84				endm 
# End of macro FORTH_DSP_VALUEHL
be84			 
be84 e5					push hl    ; u 
be85					if DEBUG_FORTH_WORDS 
be85						DMARK "SPA" 
be85 f5				push af  
be86 3a 9a be			ld a, (.dmark)  
be89 32 6b ee			ld (debug_mark),a  
be8c 3a 9b be			ld a, (.dmark+1)  
be8f 32 6c ee			ld (debug_mark+1),a  
be92 3a 9c be			ld a, (.dmark+2)  
be95 32 6d ee			ld (debug_mark+2),a  
be98 18 03			jr .pastdmark  
be9a ..			.dmark: db "SPA"  
be9d f1			.pastdmark: pop af  
be9e			endm  
# End of macro DMARK
be9e						CALLMONITOR 
be9e cd 6f ee			call debug_vector  
bea1				endm  
# End of macro CALLMONITOR
bea1					endif 
bea1			 
bea1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bea1 cd 4f 9d			call macro_forth_dsp_pop 
bea4				endm 
# End of macro FORTH_DSP_POP
bea4 e1					pop hl 
bea5 0e 00				ld c, 0 
bea7 45					ld b, l 
bea8 21 c1 e2				ld hl, scratch  
beab			 
beab					if DEBUG_FORTH_WORDS 
beab						DMARK "SP2" 
beab f5				push af  
beac 3a c0 be			ld a, (.dmark)  
beaf 32 6b ee			ld (debug_mark),a  
beb2 3a c1 be			ld a, (.dmark+1)  
beb5 32 6c ee			ld (debug_mark+1),a  
beb8 3a c2 be			ld a, (.dmark+2)  
bebb 32 6d ee			ld (debug_mark+2),a  
bebe 18 03			jr .pastdmark  
bec0 ..			.dmark: db "SP2"  
bec3 f1			.pastdmark: pop af  
bec4			endm  
# End of macro DMARK
bec4						CALLMONITOR 
bec4 cd 6f ee			call debug_vector  
bec7				endm  
# End of macro CALLMONITOR
bec7					endif 
bec7 3e 20				ld a, ' ' 
bec9			.spaces1:	 
bec9 77					ld (hl),a 
beca 23					inc hl 
becb					 
becb 10 fc				djnz .spaces1 
becd 3e 00				ld a,0 
becf 77					ld (hl),a 
bed0 21 c1 e2				ld hl, scratch 
bed3					if DEBUG_FORTH_WORDS 
bed3						DMARK "SP3" 
bed3 f5				push af  
bed4 3a e8 be			ld a, (.dmark)  
bed7 32 6b ee			ld (debug_mark),a  
beda 3a e9 be			ld a, (.dmark+1)  
bedd 32 6c ee			ld (debug_mark+1),a  
bee0 3a ea be			ld a, (.dmark+2)  
bee3 32 6d ee			ld (debug_mark+2),a  
bee6 18 03			jr .pastdmark  
bee8 ..			.dmark: db "SP3"  
beeb f1			.pastdmark: pop af  
beec			endm  
# End of macro DMARK
beec						CALLMONITOR 
beec cd 6f ee			call debug_vector  
beef				endm  
# End of macro CALLMONITOR
beef					endif 
beef cd 0e 9b				call forth_push_str 
bef2			 
bef2				       NEXTW 
bef2 c3 4d 9e			jp macro_next 
bef5				endm 
# End of macro NEXTW
bef5			 
bef5			 
bef5			 
bef5			.SCROLL: 
bef5				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bef5 53				db WORD_SYS_CORE+63             
bef6 22 bf			dw .SCROLLD            
bef8 07				db 6 + 1 
bef9 .. 00			db "SCROLL",0              
bf00				endm 
# End of macro CWHEAD
bf00			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf00					if DEBUG_FORTH_WORDS_KEY 
bf00						DMARK "SCR" 
bf00 f5				push af  
bf01 3a 15 bf			ld a, (.dmark)  
bf04 32 6b ee			ld (debug_mark),a  
bf07 3a 16 bf			ld a, (.dmark+1)  
bf0a 32 6c ee			ld (debug_mark+1),a  
bf0d 3a 17 bf			ld a, (.dmark+2)  
bf10 32 6d ee			ld (debug_mark+2),a  
bf13 18 03			jr .pastdmark  
bf15 ..			.dmark: db "SCR"  
bf18 f1			.pastdmark: pop af  
bf19			endm  
# End of macro DMARK
bf19						CALLMONITOR 
bf19 cd 6f ee			call debug_vector  
bf1c				endm  
# End of macro CALLMONITOR
bf1c					endif 
bf1c			 
bf1c cd 70 8a			call scroll_up 
bf1f			;	call update_display 
bf1f			 
bf1f					NEXTW 
bf1f c3 4d 9e			jp macro_next 
bf22				endm 
# End of macro NEXTW
bf22			 
bf22			 
bf22			 
bf22			;		; get dir 
bf22			; 
bf22			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf22			; 
bf22			;		push hl 
bf22			; 
bf22			;		; destroy value TOS 
bf22			; 
bf22			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf22			; 
bf22			;		; get count 
bf22			; 
bf22			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf22			; 
bf22			;		push hl 
bf22			; 
bf22			;		; destroy value TOS 
bf22			; 
bf22			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf22			; 
bf22			;		; one value on hl get other one back 
bf22			; 
bf22			;		pop bc    ; count 
bf22			; 
bf22			;		pop de   ; dir 
bf22			; 
bf22			; 
bf22			;		ld b, c 
bf22			; 
bf22			;.scrolldir:     push bc 
bf22			;		push de 
bf22			; 
bf22			;		ld a, 0 
bf22			;		cp e 
bf22			;		jr z, .scrollup  
bf22			;		call scroll_down 
bf22			;		jr .scrollnext 
bf22			;.scrollup:	call scroll_up 
bf22			; 
bf22			;		 
bf22			;.scrollnext: 
bf22			;		pop de 
bf22			;		pop bc 
bf22			;		djnz .scrolldir 
bf22			; 
bf22			; 
bf22			; 
bf22			; 
bf22			; 
bf22			;		NEXTW 
bf22			 
bf22			.SCROLLD: 
bf22				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf22 53				db WORD_SYS_CORE+63             
bf23 50 bf			dw .ATQ            
bf25 08				db 7 + 1 
bf26 .. 00			db "SCROLLD",0              
bf2e				endm 
# End of macro CWHEAD
bf2e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf2e					if DEBUG_FORTH_WORDS_KEY 
bf2e						DMARK "SCD" 
bf2e f5				push af  
bf2f 3a 43 bf			ld a, (.dmark)  
bf32 32 6b ee			ld (debug_mark),a  
bf35 3a 44 bf			ld a, (.dmark+1)  
bf38 32 6c ee			ld (debug_mark+1),a  
bf3b 3a 45 bf			ld a, (.dmark+2)  
bf3e 32 6d ee			ld (debug_mark+2),a  
bf41 18 03			jr .pastdmark  
bf43 ..			.dmark: db "SCD"  
bf46 f1			.pastdmark: pop af  
bf47			endm  
# End of macro DMARK
bf47						CALLMONITOR 
bf47 cd 6f ee			call debug_vector  
bf4a				endm  
# End of macro CALLMONITOR
bf4a					endif 
bf4a			 
bf4a cd 94 8a			call scroll_down 
bf4d			;	call update_display 
bf4d			 
bf4d					NEXTW 
bf4d c3 4d 9e			jp macro_next 
bf50				endm 
# End of macro NEXTW
bf50			 
bf50			 
bf50			.ATQ: 
bf50				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf50 62				db WORD_SYS_CORE+78             
bf51 ae bf			dw .AUTODSP            
bf53 04				db 3 + 1 
bf54 .. 00			db "AT@",0              
bf58				endm 
# End of macro CWHEAD
bf58			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf58					if DEBUG_FORTH_WORDS_KEY 
bf58						DMARK "ATA" 
bf58 f5				push af  
bf59 3a 6d bf			ld a, (.dmark)  
bf5c 32 6b ee			ld (debug_mark),a  
bf5f 3a 6e bf			ld a, (.dmark+1)  
bf62 32 6c ee			ld (debug_mark+1),a  
bf65 3a 6f bf			ld a, (.dmark+2)  
bf68 32 6d ee			ld (debug_mark+2),a  
bf6b 18 03			jr .pastdmark  
bf6d ..			.dmark: db "ATA"  
bf70 f1			.pastdmark: pop af  
bf71			endm  
# End of macro DMARK
bf71						CALLMONITOR 
bf71 cd 6f ee			call debug_vector  
bf74				endm  
# End of macro CALLMONITOR
bf74					endif 
bf74			 
bf74			 
bf74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf74 cd 97 9c			call macro_dsp_valuehl 
bf77				endm 
# End of macro FORTH_DSP_VALUEHL
bf77			 
bf77					; TODO save cursor row 
bf77 7d					ld a,l 
bf78 fe 02				cp 2 
bf7a 20 04				jr nz, .crow3aq 
bf7c 3e 28				ld a, display_row_2 
bf7e 18 12				jr .ccol1aq 
bf80 fe 03		.crow3aq:		cp 3 
bf82 20 04				jr nz, .crow4aq 
bf84 3e 50				ld a, display_row_3 
bf86 18 0a				jr .ccol1aq 
bf88 fe 04		.crow4aq:		cp 4 
bf8a 20 04				jr nz, .crow1aq 
bf8c 3e 78				ld a, display_row_4 
bf8e 18 02				jr .ccol1aq 
bf90 3e 00		.crow1aq:		ld a,display_row_1 
bf92 f5			.ccol1aq:		push af			; got row offset 
bf93 6f					ld l,a 
bf94 26 00				ld h,0 
bf96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf96 cd 4f 9d			call macro_forth_dsp_pop 
bf99				endm 
# End of macro FORTH_DSP_POP
bf99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf99 cd 97 9c			call macro_dsp_valuehl 
bf9c				endm 
# End of macro FORTH_DSP_VALUEHL
bf9c					; TODO save cursor col 
bf9c f1					pop af 
bf9d 85					add l		; add col offset 
bf9e			 
bf9e					; add current frame buffer address 
bf9e 2a cc eb				ld hl, (display_fb_active) 
bfa1 cd db 8c				call addatohl 
bfa4			 
bfa4			 
bfa4			 
bfa4			 
bfa4					; get char frame buffer location offset in hl 
bfa4			 
bfa4 7e					ld a,(hl) 
bfa5 26 00				ld h, 0 
bfa7 6f					ld l, a 
bfa8			 
bfa8 cd a0 9a				call forth_push_numhl 
bfab			 
bfab			 
bfab					NEXTW 
bfab c3 4d 9e			jp macro_next 
bfae				endm 
# End of macro NEXTW
bfae			 
bfae			.AUTODSP: 
bfae				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bfae 63				db WORD_SYS_CORE+79             
bfaf c4 bf			dw .MENU            
bfb1 05				db 4 + 1 
bfb2 .. 00			db "ADSP",0              
bfb7				endm 
# End of macro CWHEAD
bfb7			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bfb7			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bfb7			 
bfb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb7 cd 97 9c			call macro_dsp_valuehl 
bfba				endm 
# End of macro FORTH_DSP_VALUEHL
bfba			 
bfba			;		push hl 
bfba			 
bfba					; destroy value TOS 
bfba			 
bfba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfba cd 4f 9d			call macro_forth_dsp_pop 
bfbd				endm 
# End of macro FORTH_DSP_POP
bfbd			 
bfbd			;		pop hl 
bfbd			 
bfbd 7d					ld a,l 
bfbe 32 3c ea				ld (cli_autodisplay), a 
bfc1				       NEXTW 
bfc1 c3 4d 9e			jp macro_next 
bfc4				endm 
# End of macro NEXTW
bfc4			 
bfc4			.MENU: 
bfc4				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfc4 70				db WORD_SYS_CORE+92             
bfc5 6d c0			dw .ENDDISPLAY            
bfc7 05				db 4 + 1 
bfc8 .. 00			db "MENU",0              
bfcd				endm 
# End of macro CWHEAD
bfcd			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
bfcd			 
bfcd			;		; get number of items on the stack 
bfcd			; 
bfcd				 
bfcd					FORTH_DSP_VALUEHL 
bfcd cd 97 9c			call macro_dsp_valuehl 
bfd0				endm 
# End of macro FORTH_DSP_VALUEHL
bfd0				 
bfd0					if DEBUG_FORTH_WORDS_KEY 
bfd0						DMARK "MNU" 
bfd0 f5				push af  
bfd1 3a e5 bf			ld a, (.dmark)  
bfd4 32 6b ee			ld (debug_mark),a  
bfd7 3a e6 bf			ld a, (.dmark+1)  
bfda 32 6c ee			ld (debug_mark+1),a  
bfdd 3a e7 bf			ld a, (.dmark+2)  
bfe0 32 6d ee			ld (debug_mark+2),a  
bfe3 18 03			jr .pastdmark  
bfe5 ..			.dmark: db "MNU"  
bfe8 f1			.pastdmark: pop af  
bfe9			endm  
# End of macro DMARK
bfe9						CALLMONITOR 
bfe9 cd 6f ee			call debug_vector  
bfec				endm  
# End of macro CALLMONITOR
bfec					endif 
bfec			 
bfec 45					ld b, l	 
bfed 05					dec b 
bfee			 
bfee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfee cd 4f 9d			call macro_forth_dsp_pop 
bff1				endm 
# End of macro FORTH_DSP_POP
bff1			 
bff1			 
bff1					; go directly through the stack to pluck out the string pointers and build an array 
bff1			 
bff1			;		FORTH_DSP 
bff1			 
bff1					; hl contains top most stack item 
bff1				 
bff1 11 c1 e2				ld de, scratch 
bff4			 
bff4			.mbuild: 
bff4			 
bff4					FORTH_DSP_VALUEHL 
bff4 cd 97 9c			call macro_dsp_valuehl 
bff7				endm 
# End of macro FORTH_DSP_VALUEHL
bff7			 
bff7					if DEBUG_FORTH_WORDS 
bff7						DMARK "MN3" 
bff7 f5				push af  
bff8 3a 0c c0			ld a, (.dmark)  
bffb 32 6b ee			ld (debug_mark),a  
bffe 3a 0d c0			ld a, (.dmark+1)  
c001 32 6c ee			ld (debug_mark+1),a  
c004 3a 0e c0			ld a, (.dmark+2)  
c007 32 6d ee			ld (debug_mark+2),a  
c00a 18 03			jr .pastdmark  
c00c ..			.dmark: db "MN3"  
c00f f1			.pastdmark: pop af  
c010			endm  
# End of macro DMARK
c010						CALLMONITOR 
c010 cd 6f ee			call debug_vector  
c013				endm  
# End of macro CALLMONITOR
c013					endif 
c013 eb					ex de, hl 
c014 73					ld (hl), e 
c015 23					inc hl 
c016 72					ld (hl), d 
c017 23					inc hl 
c018 eb					ex de, hl 
c019			 
c019					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c019 cd 4f 9d			call macro_forth_dsp_pop 
c01c				endm 
# End of macro FORTH_DSP_POP
c01c			 
c01c 10 d6				djnz .mbuild 
c01e			 
c01e					; done add term 
c01e			 
c01e eb					ex de, hl 
c01f 36 00				ld (hl), 0 
c021 23					inc hl 
c022 36 00				ld (hl), 0 
c024			 
c024				 
c024					 
c024 21 c1 e2				ld hl, scratch 
c027			 
c027					if DEBUG_FORTH_WORDS 
c027						DMARK "MNx" 
c027 f5				push af  
c028 3a 3c c0			ld a, (.dmark)  
c02b 32 6b ee			ld (debug_mark),a  
c02e 3a 3d c0			ld a, (.dmark+1)  
c031 32 6c ee			ld (debug_mark+1),a  
c034 3a 3e c0			ld a, (.dmark+2)  
c037 32 6d ee			ld (debug_mark+2),a  
c03a 18 03			jr .pastdmark  
c03c ..			.dmark: db "MNx"  
c03f f1			.pastdmark: pop af  
c040			endm  
# End of macro DMARK
c040						CALLMONITOR 
c040 cd 6f ee			call debug_vector  
c043				endm  
# End of macro CALLMONITOR
c043					endif 
c043			 
c043			 
c043			 
c043 3e 00				ld a, 0 
c045 cd df 8a				call menu 
c048			 
c048			 
c048 6f					ld l, a 
c049 26 00				ld h, 0 
c04b			 
c04b					if DEBUG_FORTH_WORDS 
c04b						DMARK "MNr" 
c04b f5				push af  
c04c 3a 60 c0			ld a, (.dmark)  
c04f 32 6b ee			ld (debug_mark),a  
c052 3a 61 c0			ld a, (.dmark+1)  
c055 32 6c ee			ld (debug_mark+1),a  
c058 3a 62 c0			ld a, (.dmark+2)  
c05b 32 6d ee			ld (debug_mark+2),a  
c05e 18 03			jr .pastdmark  
c060 ..			.dmark: db "MNr"  
c063 f1			.pastdmark: pop af  
c064			endm  
# End of macro DMARK
c064						CALLMONITOR 
c064 cd 6f ee			call debug_vector  
c067				endm  
# End of macro CALLMONITOR
c067					endif 
c067			 
c067 cd a0 9a				call forth_push_numhl 
c06a			 
c06a			 
c06a			 
c06a			 
c06a				       NEXTW 
c06a c3 4d 9e			jp macro_next 
c06d				endm 
# End of macro NEXTW
c06d			 
c06d			 
c06d			.ENDDISPLAY: 
c06d			 
c06d			; eof 
# End of file forth_words_display.asm
c06d			include "forth_words_str.asm" 
c06d			 
c06d			; | ## String Words 
c06d			 
c06d			.PTR:   
c06d			 
c06d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c06d 48				db WORD_SYS_CORE+52             
c06e 9a c0			dw .STYPE            
c070 04				db 3 + 1 
c071 .. 00			db "PTR",0              
c075				endm 
# End of macro CWHEAD
c075			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c075			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c075			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c075			 
c075					if DEBUG_FORTH_WORDS_KEY 
c075						DMARK "PTR" 
c075 f5				push af  
c076 3a 8a c0			ld a, (.dmark)  
c079 32 6b ee			ld (debug_mark),a  
c07c 3a 8b c0			ld a, (.dmark+1)  
c07f 32 6c ee			ld (debug_mark+1),a  
c082 3a 8c c0			ld a, (.dmark+2)  
c085 32 6d ee			ld (debug_mark+2),a  
c088 18 03			jr .pastdmark  
c08a ..			.dmark: db "PTR"  
c08d f1			.pastdmark: pop af  
c08e			endm  
# End of macro DMARK
c08e						CALLMONITOR 
c08e cd 6f ee			call debug_vector  
c091				endm  
# End of macro CALLMONITOR
c091					endif 
c091					FORTH_DSP_VALUEHL 
c091 cd 97 9c			call macro_dsp_valuehl 
c094				endm 
# End of macro FORTH_DSP_VALUEHL
c094 cd a0 9a				call forth_push_numhl 
c097			 
c097			 
c097					NEXTW 
c097 c3 4d 9e			jp macro_next 
c09a				endm 
# End of macro NEXTW
c09a			.STYPE: 
c09a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c09a 48				db WORD_SYS_CORE+52             
c09b e9 c0			dw .UPPER            
c09d 06				db 5 + 1 
c09e .. 00			db "STYPE",0              
c0a4				endm 
# End of macro CWHEAD
c0a4			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c0a4					if DEBUG_FORTH_WORDS_KEY 
c0a4						DMARK "STY" 
c0a4 f5				push af  
c0a5 3a b9 c0			ld a, (.dmark)  
c0a8 32 6b ee			ld (debug_mark),a  
c0ab 3a ba c0			ld a, (.dmark+1)  
c0ae 32 6c ee			ld (debug_mark+1),a  
c0b1 3a bb c0			ld a, (.dmark+2)  
c0b4 32 6d ee			ld (debug_mark+2),a  
c0b7 18 03			jr .pastdmark  
c0b9 ..			.dmark: db "STY"  
c0bc f1			.pastdmark: pop af  
c0bd			endm  
# End of macro DMARK
c0bd						CALLMONITOR 
c0bd cd 6f ee			call debug_vector  
c0c0				endm  
# End of macro CALLMONITOR
c0c0					endif 
c0c0					FORTH_DSP 
c0c0 cd 5d 9c			call macro_forth_dsp 
c0c3				endm 
# End of macro FORTH_DSP
c0c3					;v5 FORTH_DSP_VALUE 
c0c3			 
c0c3 7e					ld a, (hl) 
c0c4			 
c0c4 f5					push af 
c0c5			 
c0c5			; Dont destroy TOS		FORTH_DSP_POP 
c0c5			 
c0c5 f1					pop af 
c0c6			 
c0c6 fe 01				cp DS_TYPE_STR 
c0c8 28 09				jr z, .typestr 
c0ca			 
c0ca fe 02				cp DS_TYPE_INUM 
c0cc 28 0a				jr z, .typeinum 
c0ce			 
c0ce 21 e7 c0				ld hl, .tna 
c0d1 18 0a				jr .tpush 
c0d3			 
c0d3 21 e3 c0		.typestr:	ld hl, .tstr 
c0d6 18 05				jr .tpush 
c0d8 21 e5 c0		.typeinum:	ld hl, .tinum 
c0db 18 00				jr .tpush 
c0dd			 
c0dd			.tpush: 
c0dd			 
c0dd cd 0e 9b				call forth_push_str 
c0e0			 
c0e0					NEXTW 
c0e0 c3 4d 9e			jp macro_next 
c0e3				endm 
# End of macro NEXTW
c0e3 .. 00		.tstr:	db "s",0 
c0e5 .. 00		.tinum:  db "i",0 
c0e7 .. 00		.tna:   db "?", 0 
c0e9			 
c0e9			 
c0e9			.UPPER: 
c0e9				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0e9 48				db WORD_SYS_CORE+52             
c0ea 24 c1			dw .LOWER            
c0ec 06				db 5 + 1 
c0ed .. 00			db "UPPER",0              
c0f3				endm 
# End of macro CWHEAD
c0f3			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0f3					if DEBUG_FORTH_WORDS_KEY 
c0f3						DMARK "UPR" 
c0f3 f5				push af  
c0f4 3a 08 c1			ld a, (.dmark)  
c0f7 32 6b ee			ld (debug_mark),a  
c0fa 3a 09 c1			ld a, (.dmark+1)  
c0fd 32 6c ee			ld (debug_mark+1),a  
c100 3a 0a c1			ld a, (.dmark+2)  
c103 32 6d ee			ld (debug_mark+2),a  
c106 18 03			jr .pastdmark  
c108 ..			.dmark: db "UPR"  
c10b f1			.pastdmark: pop af  
c10c			endm  
# End of macro DMARK
c10c						CALLMONITOR 
c10c cd 6f ee			call debug_vector  
c10f				endm  
# End of macro CALLMONITOR
c10f					endif 
c10f			 
c10f					FORTH_DSP 
c10f cd 5d 9c			call macro_forth_dsp 
c112				endm 
# End of macro FORTH_DSP
c112					 
c112			; TODO check is string type 
c112			 
c112					FORTH_DSP_VALUEHL 
c112 cd 97 9c			call macro_dsp_valuehl 
c115				endm 
# End of macro FORTH_DSP_VALUEHL
c115			; get pointer to string in hl 
c115			 
c115 7e			.toup:		ld a, (hl) 
c116 fe 00				cp 0 
c118 28 07				jr z, .toupdone 
c11a			 
c11a cd a1 8f				call to_upper 
c11d			 
c11d 77					ld (hl), a 
c11e 23					inc hl 
c11f 18 f4				jr .toup 
c121			 
c121					 
c121			 
c121			 
c121			; for each char convert to upper 
c121					 
c121			.toupdone: 
c121			 
c121			 
c121					NEXTW 
c121 c3 4d 9e			jp macro_next 
c124				endm 
# End of macro NEXTW
c124			.LOWER: 
c124				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c124 48				db WORD_SYS_CORE+52             
c125 5f c1			dw .TCASE            
c127 06				db 5 + 1 
c128 .. 00			db "LOWER",0              
c12e				endm 
# End of macro CWHEAD
c12e			; | LOWER ( s -- s ) Lower case string s  | DONE 
c12e					if DEBUG_FORTH_WORDS_KEY 
c12e						DMARK "LWR" 
c12e f5				push af  
c12f 3a 43 c1			ld a, (.dmark)  
c132 32 6b ee			ld (debug_mark),a  
c135 3a 44 c1			ld a, (.dmark+1)  
c138 32 6c ee			ld (debug_mark+1),a  
c13b 3a 45 c1			ld a, (.dmark+2)  
c13e 32 6d ee			ld (debug_mark+2),a  
c141 18 03			jr .pastdmark  
c143 ..			.dmark: db "LWR"  
c146 f1			.pastdmark: pop af  
c147			endm  
# End of macro DMARK
c147						CALLMONITOR 
c147 cd 6f ee			call debug_vector  
c14a				endm  
# End of macro CALLMONITOR
c14a					endif 
c14a			 
c14a					FORTH_DSP 
c14a cd 5d 9c			call macro_forth_dsp 
c14d				endm 
# End of macro FORTH_DSP
c14d					 
c14d			; TODO check is string type 
c14d			 
c14d					FORTH_DSP_VALUEHL 
c14d cd 97 9c			call macro_dsp_valuehl 
c150				endm 
# End of macro FORTH_DSP_VALUEHL
c150			; get pointer to string in hl 
c150			 
c150 7e			.tolow:		ld a, (hl) 
c151 fe 00				cp 0 
c153 28 07				jr z, .tolowdone 
c155			 
c155 cd aa 8f				call to_lower 
c158			 
c158 77					ld (hl), a 
c159 23					inc hl 
c15a 18 f4				jr .tolow 
c15c			 
c15c					 
c15c			 
c15c			 
c15c			; for each char convert to low 
c15c					 
c15c			.tolowdone: 
c15c					NEXTW 
c15c c3 4d 9e			jp macro_next 
c15f				endm 
# End of macro NEXTW
c15f			.TCASE: 
c15f				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c15f 48				db WORD_SYS_CORE+52             
c160 95 c2			dw .SUBSTR            
c162 06				db 5 + 1 
c163 .. 00			db "TCASE",0              
c169				endm 
# End of macro CWHEAD
c169			; | TCASE ( s -- s ) Title case string s  | DONE 
c169					if DEBUG_FORTH_WORDS_KEY 
c169						DMARK "TCS" 
c169 f5				push af  
c16a 3a 7e c1			ld a, (.dmark)  
c16d 32 6b ee			ld (debug_mark),a  
c170 3a 7f c1			ld a, (.dmark+1)  
c173 32 6c ee			ld (debug_mark+1),a  
c176 3a 80 c1			ld a, (.dmark+2)  
c179 32 6d ee			ld (debug_mark+2),a  
c17c 18 03			jr .pastdmark  
c17e ..			.dmark: db "TCS"  
c181 f1			.pastdmark: pop af  
c182			endm  
# End of macro DMARK
c182						CALLMONITOR 
c182 cd 6f ee			call debug_vector  
c185				endm  
# End of macro CALLMONITOR
c185					endif 
c185			 
c185					FORTH_DSP 
c185 cd 5d 9c			call macro_forth_dsp 
c188				endm 
# End of macro FORTH_DSP
c188					 
c188			; TODO check is string type 
c188			 
c188					FORTH_DSP_VALUEHL 
c188 cd 97 9c			call macro_dsp_valuehl 
c18b				endm 
# End of macro FORTH_DSP_VALUEHL
c18b			; get pointer to string in hl 
c18b			 
c18b					if DEBUG_FORTH_WORDS 
c18b						DMARK "TC1" 
c18b f5				push af  
c18c 3a a0 c1			ld a, (.dmark)  
c18f 32 6b ee			ld (debug_mark),a  
c192 3a a1 c1			ld a, (.dmark+1)  
c195 32 6c ee			ld (debug_mark+1),a  
c198 3a a2 c1			ld a, (.dmark+2)  
c19b 32 6d ee			ld (debug_mark+2),a  
c19e 18 03			jr .pastdmark  
c1a0 ..			.dmark: db "TC1"  
c1a3 f1			.pastdmark: pop af  
c1a4			endm  
# End of macro DMARK
c1a4						CALLMONITOR 
c1a4 cd 6f ee			call debug_vector  
c1a7				endm  
# End of macro CALLMONITOR
c1a7					endif 
c1a7			 
c1a7					; first time in turn to upper case first char 
c1a7			 
c1a7 7e					ld a, (hl) 
c1a8 c3 32 c2				jp .totsiptou 
c1ab			 
c1ab			 
c1ab 7e			.tot:		ld a, (hl) 
c1ac fe 00				cp 0 
c1ae ca 76 c2				jp z, .totdone 
c1b1			 
c1b1					if DEBUG_FORTH_WORDS 
c1b1						DMARK "TC2" 
c1b1 f5				push af  
c1b2 3a c6 c1			ld a, (.dmark)  
c1b5 32 6b ee			ld (debug_mark),a  
c1b8 3a c7 c1			ld a, (.dmark+1)  
c1bb 32 6c ee			ld (debug_mark+1),a  
c1be 3a c8 c1			ld a, (.dmark+2)  
c1c1 32 6d ee			ld (debug_mark+2),a  
c1c4 18 03			jr .pastdmark  
c1c6 ..			.dmark: db "TC2"  
c1c9 f1			.pastdmark: pop af  
c1ca			endm  
# End of macro DMARK
c1ca						CALLMONITOR 
c1ca cd 6f ee			call debug_vector  
c1cd				endm  
# End of macro CALLMONITOR
c1cd					endif 
c1cd					; check to see if current char is a space 
c1cd			 
c1cd fe 20				cp ' ' 
c1cf 28 21				jr z, .totsp 
c1d1 cd aa 8f				call to_lower 
c1d4					if DEBUG_FORTH_WORDS 
c1d4						DMARK "TC3" 
c1d4 f5				push af  
c1d5 3a e9 c1			ld a, (.dmark)  
c1d8 32 6b ee			ld (debug_mark),a  
c1db 3a ea c1			ld a, (.dmark+1)  
c1de 32 6c ee			ld (debug_mark+1),a  
c1e1 3a eb c1			ld a, (.dmark+2)  
c1e4 32 6d ee			ld (debug_mark+2),a  
c1e7 18 03			jr .pastdmark  
c1e9 ..			.dmark: db "TC3"  
c1ec f1			.pastdmark: pop af  
c1ed			endm  
# End of macro DMARK
c1ed						CALLMONITOR 
c1ed cd 6f ee			call debug_vector  
c1f0				endm  
# End of macro CALLMONITOR
c1f0					endif 
c1f0 18 63				jr .totnxt 
c1f2			 
c1f2			.totsp:         ; on a space, find next char which should be upper 
c1f2			 
c1f2					if DEBUG_FORTH_WORDS 
c1f2						DMARK "TC4" 
c1f2 f5				push af  
c1f3 3a 07 c2			ld a, (.dmark)  
c1f6 32 6b ee			ld (debug_mark),a  
c1f9 3a 08 c2			ld a, (.dmark+1)  
c1fc 32 6c ee			ld (debug_mark+1),a  
c1ff 3a 09 c2			ld a, (.dmark+2)  
c202 32 6d ee			ld (debug_mark+2),a  
c205 18 03			jr .pastdmark  
c207 ..			.dmark: db "TC4"  
c20a f1			.pastdmark: pop af  
c20b			endm  
# End of macro DMARK
c20b						CALLMONITOR 
c20b cd 6f ee			call debug_vector  
c20e				endm  
# End of macro CALLMONITOR
c20e					endif 
c20e					;; 
c20e			 
c20e fe 20				cp ' ' 
c210 20 20				jr nz, .totsiptou 
c212 23					inc hl 
c213 7e					ld a, (hl) 
c214					if DEBUG_FORTH_WORDS 
c214						DMARK "TC5" 
c214 f5				push af  
c215 3a 29 c2			ld a, (.dmark)  
c218 32 6b ee			ld (debug_mark),a  
c21b 3a 2a c2			ld a, (.dmark+1)  
c21e 32 6c ee			ld (debug_mark+1),a  
c221 3a 2b c2			ld a, (.dmark+2)  
c224 32 6d ee			ld (debug_mark+2),a  
c227 18 03			jr .pastdmark  
c229 ..			.dmark: db "TC5"  
c22c f1			.pastdmark: pop af  
c22d			endm  
# End of macro DMARK
c22d						CALLMONITOR 
c22d cd 6f ee			call debug_vector  
c230				endm  
# End of macro CALLMONITOR
c230					endif 
c230 18 c0				jr .totsp 
c232 fe 00		.totsiptou:    cp 0 
c234 28 40				jr z, .totdone 
c236					; not space and not zero term so upper case it 
c236 cd a1 8f				call to_upper 
c239			 
c239					if DEBUG_FORTH_WORDS 
c239						DMARK "TC6" 
c239 f5				push af  
c23a 3a 4e c2			ld a, (.dmark)  
c23d 32 6b ee			ld (debug_mark),a  
c240 3a 4f c2			ld a, (.dmark+1)  
c243 32 6c ee			ld (debug_mark+1),a  
c246 3a 50 c2			ld a, (.dmark+2)  
c249 32 6d ee			ld (debug_mark+2),a  
c24c 18 03			jr .pastdmark  
c24e ..			.dmark: db "TC6"  
c251 f1			.pastdmark: pop af  
c252			endm  
# End of macro DMARK
c252						CALLMONITOR 
c252 cd 6f ee			call debug_vector  
c255				endm  
# End of macro CALLMONITOR
c255					endif 
c255			 
c255			 
c255			.totnxt: 
c255			 
c255 77					ld (hl), a 
c256 23					inc hl 
c257					if DEBUG_FORTH_WORDS 
c257						DMARK "TC7" 
c257 f5				push af  
c258 3a 6c c2			ld a, (.dmark)  
c25b 32 6b ee			ld (debug_mark),a  
c25e 3a 6d c2			ld a, (.dmark+1)  
c261 32 6c ee			ld (debug_mark+1),a  
c264 3a 6e c2			ld a, (.dmark+2)  
c267 32 6d ee			ld (debug_mark+2),a  
c26a 18 03			jr .pastdmark  
c26c ..			.dmark: db "TC7"  
c26f f1			.pastdmark: pop af  
c270			endm  
# End of macro DMARK
c270						CALLMONITOR 
c270 cd 6f ee			call debug_vector  
c273				endm  
# End of macro CALLMONITOR
c273					endif 
c273 c3 ab c1				jp .tot 
c276			 
c276					 
c276			 
c276			 
c276			; for each char convert to low 
c276					 
c276			.totdone: 
c276					if DEBUG_FORTH_WORDS 
c276						DMARK "TCd" 
c276 f5				push af  
c277 3a 8b c2			ld a, (.dmark)  
c27a 32 6b ee			ld (debug_mark),a  
c27d 3a 8c c2			ld a, (.dmark+1)  
c280 32 6c ee			ld (debug_mark+1),a  
c283 3a 8d c2			ld a, (.dmark+2)  
c286 32 6d ee			ld (debug_mark+2),a  
c289 18 03			jr .pastdmark  
c28b ..			.dmark: db "TCd"  
c28e f1			.pastdmark: pop af  
c28f			endm  
# End of macro DMARK
c28f						CALLMONITOR 
c28f cd 6f ee			call debug_vector  
c292				endm  
# End of macro CALLMONITOR
c292					endif 
c292					NEXTW 
c292 c3 4d 9e			jp macro_next 
c295				endm 
# End of macro NEXTW
c295			 
c295			.SUBSTR: 
c295				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c295 48				db WORD_SYS_CORE+52             
c296 f3 c2			dw .LEFT            
c298 07				db 6 + 1 
c299 .. 00			db "SUBSTR",0              
c2a0				endm 
# End of macro CWHEAD
c2a0			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c2a0			 
c2a0					if DEBUG_FORTH_WORDS_KEY 
c2a0						DMARK "SST" 
c2a0 f5				push af  
c2a1 3a b5 c2			ld a, (.dmark)  
c2a4 32 6b ee			ld (debug_mark),a  
c2a7 3a b6 c2			ld a, (.dmark+1)  
c2aa 32 6c ee			ld (debug_mark+1),a  
c2ad 3a b7 c2			ld a, (.dmark+2)  
c2b0 32 6d ee			ld (debug_mark+2),a  
c2b3 18 03			jr .pastdmark  
c2b5 ..			.dmark: db "SST"  
c2b8 f1			.pastdmark: pop af  
c2b9			endm  
# End of macro DMARK
c2b9						CALLMONITOR 
c2b9 cd 6f ee			call debug_vector  
c2bc				endm  
# End of macro CALLMONITOR
c2bc					endif 
c2bc			; TODO check string type 
c2bc					FORTH_DSP_VALUEHL 
c2bc cd 97 9c			call macro_dsp_valuehl 
c2bf				endm 
# End of macro FORTH_DSP_VALUEHL
c2bf			 
c2bf e5					push hl      ; string length 
c2c0			 
c2c0					FORTH_DSP_POP 
c2c0 cd 4f 9d			call macro_forth_dsp_pop 
c2c3				endm 
# End of macro FORTH_DSP_POP
c2c3			 
c2c3					FORTH_DSP_VALUEHL 
c2c3 cd 97 9c			call macro_dsp_valuehl 
c2c6				endm 
# End of macro FORTH_DSP_VALUEHL
c2c6			 
c2c6 e5					push hl     ; start char 
c2c7			 
c2c7					FORTH_DSP_POP 
c2c7 cd 4f 9d			call macro_forth_dsp_pop 
c2ca				endm 
# End of macro FORTH_DSP_POP
c2ca			 
c2ca			 
c2ca					FORTH_DSP_VALUE 
c2ca cd 80 9c			call macro_forth_dsp_value 
c2cd				endm 
# End of macro FORTH_DSP_VALUE
c2cd			 
c2cd d1					pop de    ; get start post offset 
c2ce			 
c2ce 19					add hl, de    ; starting offset 
c2cf			 
c2cf c1					pop bc 
c2d0 c5					push bc      ; grab size of string 
c2d1			 
c2d1 e5					push hl    ; save string start  
c2d2			 
c2d2 26 00				ld h, 0 
c2d4 69					ld l, c 
c2d5 23					inc hl 
c2d6 23					inc hl 
c2d7			 
c2d7 cd 07 91				call malloc 
c2da				if DEBUG_FORTH_MALLOC_GUARD 
c2da cc 0d cc				call z,malloc_error 
c2dd				endif 
c2dd			 
c2dd eb					ex de, hl      ; save malloc area for string copy 
c2de e1					pop hl    ; get back source 
c2df c1					pop bc    ; get length of string back 
c2e0			 
c2e0 d5					push de    ; save malloc area for after we push 
c2e1 ed b0				ldir     ; copy substr 
c2e3			 
c2e3			 
c2e3 eb					ex de, hl 
c2e4 3e 00				ld a, 0 
c2e6 77					ld (hl), a   ; term substr 
c2e7			 
c2e7					 
c2e7 e1					pop hl    ; get malloc so we can push it 
c2e8 e5					push hl   ; save so we can free it afterwards 
c2e9			 
c2e9 cd 0e 9b				call forth_push_str 
c2ec			 
c2ec e1					pop hl 
c2ed cd d1 91				call free 
c2f0			 
c2f0					 
c2f0					 
c2f0			 
c2f0			 
c2f0					NEXTW 
c2f0 c3 4d 9e			jp macro_next 
c2f3				endm 
# End of macro NEXTW
c2f3			 
c2f3			.LEFT: 
c2f3				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2f3 48				db WORD_SYS_CORE+52             
c2f4 1b c3			dw .RIGHT            
c2f6 05				db 4 + 1 
c2f7 .. 00			db "LEFT",0              
c2fc				endm 
# End of macro CWHEAD
c2fc			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2fc					if DEBUG_FORTH_WORDS_KEY 
c2fc						DMARK "LEF" 
c2fc f5				push af  
c2fd 3a 11 c3			ld a, (.dmark)  
c300 32 6b ee			ld (debug_mark),a  
c303 3a 12 c3			ld a, (.dmark+1)  
c306 32 6c ee			ld (debug_mark+1),a  
c309 3a 13 c3			ld a, (.dmark+2)  
c30c 32 6d ee			ld (debug_mark+2),a  
c30f 18 03			jr .pastdmark  
c311 ..			.dmark: db "LEF"  
c314 f1			.pastdmark: pop af  
c315			endm  
# End of macro DMARK
c315						CALLMONITOR 
c315 cd 6f ee			call debug_vector  
c318				endm  
# End of macro CALLMONITOR
c318					endif 
c318			 
c318					NEXTW 
c318 c3 4d 9e			jp macro_next 
c31b				endm 
# End of macro NEXTW
c31b			.RIGHT: 
c31b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c31b 48				db WORD_SYS_CORE+52             
c31c 44 c3			dw .STR2NUM            
c31e 06				db 5 + 1 
c31f .. 00			db "RIGHT",0              
c325				endm 
# End of macro CWHEAD
c325			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c325					if DEBUG_FORTH_WORDS_KEY 
c325						DMARK "RIG" 
c325 f5				push af  
c326 3a 3a c3			ld a, (.dmark)  
c329 32 6b ee			ld (debug_mark),a  
c32c 3a 3b c3			ld a, (.dmark+1)  
c32f 32 6c ee			ld (debug_mark+1),a  
c332 3a 3c c3			ld a, (.dmark+2)  
c335 32 6d ee			ld (debug_mark+2),a  
c338 18 03			jr .pastdmark  
c33a ..			.dmark: db "RIG"  
c33d f1			.pastdmark: pop af  
c33e			endm  
# End of macro DMARK
c33e						CALLMONITOR 
c33e cd 6f ee			call debug_vector  
c341				endm  
# End of macro CALLMONITOR
c341					endif 
c341			 
c341					NEXTW 
c341 c3 4d 9e			jp macro_next 
c344				endm 
# End of macro NEXTW
c344			 
c344			 
c344			.STR2NUM: 
c344				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c344 48				db WORD_SYS_CORE+52             
c345 d0 c3			dw .NUM2STR            
c347 08				db 7 + 1 
c348 .. 00			db "STR2NUM",0              
c350				endm 
# End of macro CWHEAD
c350			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c350			 
c350			 
c350			; TODO STR type check to do 
c350					if DEBUG_FORTH_WORDS_KEY 
c350						DMARK "S2N" 
c350 f5				push af  
c351 3a 65 c3			ld a, (.dmark)  
c354 32 6b ee			ld (debug_mark),a  
c357 3a 66 c3			ld a, (.dmark+1)  
c35a 32 6c ee			ld (debug_mark+1),a  
c35d 3a 67 c3			ld a, (.dmark+2)  
c360 32 6d ee			ld (debug_mark+2),a  
c363 18 03			jr .pastdmark  
c365 ..			.dmark: db "S2N"  
c368 f1			.pastdmark: pop af  
c369			endm  
# End of macro DMARK
c369						CALLMONITOR 
c369 cd 6f ee			call debug_vector  
c36c				endm  
# End of macro CALLMONITOR
c36c					endif 
c36c			 
c36c					;FORTH_DSP 
c36c					FORTH_DSP_VALUE 
c36c cd 80 9c			call macro_forth_dsp_value 
c36f				endm 
# End of macro FORTH_DSP_VALUE
c36f					;inc hl 
c36f			 
c36f eb					ex de, hl 
c370					if DEBUG_FORTH_WORDS 
c370						DMARK "S2a" 
c370 f5				push af  
c371 3a 85 c3			ld a, (.dmark)  
c374 32 6b ee			ld (debug_mark),a  
c377 3a 86 c3			ld a, (.dmark+1)  
c37a 32 6c ee			ld (debug_mark+1),a  
c37d 3a 87 c3			ld a, (.dmark+2)  
c380 32 6d ee			ld (debug_mark+2),a  
c383 18 03			jr .pastdmark  
c385 ..			.dmark: db "S2a"  
c388 f1			.pastdmark: pop af  
c389			endm  
# End of macro DMARK
c389						CALLMONITOR 
c389 cd 6f ee			call debug_vector  
c38c				endm  
# End of macro CALLMONITOR
c38c					endif 
c38c cd 29 90				call string_to_uint16 
c38f			 
c38f					if DEBUG_FORTH_WORDS 
c38f						DMARK "S2b" 
c38f f5				push af  
c390 3a a4 c3			ld a, (.dmark)  
c393 32 6b ee			ld (debug_mark),a  
c396 3a a5 c3			ld a, (.dmark+1)  
c399 32 6c ee			ld (debug_mark+1),a  
c39c 3a a6 c3			ld a, (.dmark+2)  
c39f 32 6d ee			ld (debug_mark+2),a  
c3a2 18 03			jr .pastdmark  
c3a4 ..			.dmark: db "S2b"  
c3a7 f1			.pastdmark: pop af  
c3a8			endm  
# End of macro DMARK
c3a8						CALLMONITOR 
c3a8 cd 6f ee			call debug_vector  
c3ab				endm  
# End of macro CALLMONITOR
c3ab					endif 
c3ab			;		push hl 
c3ab					FORTH_DSP_POP 
c3ab cd 4f 9d			call macro_forth_dsp_pop 
c3ae				endm 
# End of macro FORTH_DSP_POP
c3ae			;		pop hl 
c3ae					 
c3ae					if DEBUG_FORTH_WORDS 
c3ae						DMARK "S2b" 
c3ae f5				push af  
c3af 3a c3 c3			ld a, (.dmark)  
c3b2 32 6b ee			ld (debug_mark),a  
c3b5 3a c4 c3			ld a, (.dmark+1)  
c3b8 32 6c ee			ld (debug_mark+1),a  
c3bb 3a c5 c3			ld a, (.dmark+2)  
c3be 32 6d ee			ld (debug_mark+2),a  
c3c1 18 03			jr .pastdmark  
c3c3 ..			.dmark: db "S2b"  
c3c6 f1			.pastdmark: pop af  
c3c7			endm  
# End of macro DMARK
c3c7						CALLMONITOR 
c3c7 cd 6f ee			call debug_vector  
c3ca				endm  
# End of macro CALLMONITOR
c3ca					endif 
c3ca cd a0 9a				call forth_push_numhl	 
c3cd			 
c3cd				 
c3cd				       NEXTW 
c3cd c3 4d 9e			jp macro_next 
c3d0				endm 
# End of macro NEXTW
c3d0			.NUM2STR: 
c3d0				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3d0 48				db WORD_SYS_CORE+52             
c3d1 df c3			dw .CONCAT            
c3d3 08				db 7 + 1 
c3d4 .. 00			db "NUM2STR",0              
c3dc				endm 
# End of macro CWHEAD
c3dc			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c3dc			 
c3dc			;		; malloc a string to target 
c3dc			;		ld hl, 10     ; TODO max string size should be fine 
c3dc			;		call malloc 
c3dc			;		push hl    ; save malloc location 
c3dc			; 
c3dc			; 
c3dc			;; TODO check int type 
c3dc			;		FORTH_DSP_VALUEHL 
c3dc			;		ld a, l 
c3dc			;		call DispAToASCII   
c3dc			;;TODO need to chage above call to dump into string 
c3dc			; 
c3dc			; 
c3dc			 
c3dc				       NEXTW 
c3dc c3 4d 9e			jp macro_next 
c3df				endm 
# End of macro NEXTW
c3df			 
c3df			.CONCAT: 
c3df				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3df 48				db WORD_SYS_CORE+52             
c3e0 92 c4			dw .FIND            
c3e2 07				db 6 + 1 
c3e3 .. 00			db "CONCAT",0              
c3ea				endm 
# End of macro CWHEAD
c3ea			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3ea			 
c3ea			; TODO check string type 
c3ea			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3ea			 
c3ea					if DEBUG_FORTH_WORDS_KEY 
c3ea						DMARK "CON" 
c3ea f5				push af  
c3eb 3a ff c3			ld a, (.dmark)  
c3ee 32 6b ee			ld (debug_mark),a  
c3f1 3a 00 c4			ld a, (.dmark+1)  
c3f4 32 6c ee			ld (debug_mark+1),a  
c3f7 3a 01 c4			ld a, (.dmark+2)  
c3fa 32 6d ee			ld (debug_mark+2),a  
c3fd 18 03			jr .pastdmark  
c3ff ..			.dmark: db "CON"  
c402 f1			.pastdmark: pop af  
c403			endm  
# End of macro DMARK
c403						CALLMONITOR 
c403 cd 6f ee			call debug_vector  
c406				endm  
# End of macro CALLMONITOR
c406					endif 
c406			 
c406			 
c406					FORTH_DSP_VALUE 
c406 cd 80 9c			call macro_forth_dsp_value 
c409				endm 
# End of macro FORTH_DSP_VALUE
c409 e5					push hl   ; s2 
c40a			 
c40a					FORTH_DSP_POP 
c40a cd 4f 9d			call macro_forth_dsp_pop 
c40d				endm 
# End of macro FORTH_DSP_POP
c40d			 
c40d					FORTH_DSP_VALUE 
c40d cd 80 9c			call macro_forth_dsp_value 
c410				endm 
# End of macro FORTH_DSP_VALUE
c410			 
c410 e5					push hl   ; s1 
c411			 
c411					FORTH_DSP_POP 
c411 cd 4f 9d			call macro_forth_dsp_pop 
c414				endm 
# End of macro FORTH_DSP_POP
c414					 
c414			 
c414					; copy s1 
c414			 
c414				 
c414					; save ptr 
c414 e1					pop hl  
c415 e5					push hl 
c416 3e 00				ld a, 0 
c418 cd 9d 90				call strlent 
c41b					;inc hl    ; zer0 
c41b 06 00				ld b, 0 
c41d 4d					ld c, l 
c41e e1					pop hl		 
c41f 11 c1 e2				ld de, scratch	 
c422					if DEBUG_FORTH_WORDS 
c422						DMARK "CO1" 
c422 f5				push af  
c423 3a 37 c4			ld a, (.dmark)  
c426 32 6b ee			ld (debug_mark),a  
c429 3a 38 c4			ld a, (.dmark+1)  
c42c 32 6c ee			ld (debug_mark+1),a  
c42f 3a 39 c4			ld a, (.dmark+2)  
c432 32 6d ee			ld (debug_mark+2),a  
c435 18 03			jr .pastdmark  
c437 ..			.dmark: db "CO1"  
c43a f1			.pastdmark: pop af  
c43b			endm  
# End of macro DMARK
c43b						CALLMONITOR 
c43b cd 6f ee			call debug_vector  
c43e				endm  
# End of macro CALLMONITOR
c43e					endif 
c43e ed b0				ldir 
c440			 
c440 e1					pop hl 
c441 e5					push hl 
c442 d5					push de 
c443			 
c443			 
c443 3e 00				ld a, 0 
c445 cd 9d 90				call strlent 
c448 23					inc hl    ; zer0 
c449 23					inc hl 
c44a 06 00				ld b, 0 
c44c 4d					ld c, l 
c44d d1					pop de 
c44e e1					pop hl		 
c44f					if DEBUG_FORTH_WORDS 
c44f						DMARK "CO2" 
c44f f5				push af  
c450 3a 64 c4			ld a, (.dmark)  
c453 32 6b ee			ld (debug_mark),a  
c456 3a 65 c4			ld a, (.dmark+1)  
c459 32 6c ee			ld (debug_mark+1),a  
c45c 3a 66 c4			ld a, (.dmark+2)  
c45f 32 6d ee			ld (debug_mark+2),a  
c462 18 03			jr .pastdmark  
c464 ..			.dmark: db "CO2"  
c467 f1			.pastdmark: pop af  
c468			endm  
# End of macro DMARK
c468						CALLMONITOR 
c468 cd 6f ee			call debug_vector  
c46b				endm  
# End of macro CALLMONITOR
c46b					endif 
c46b ed b0				ldir 
c46d			 
c46d			 
c46d			 
c46d 21 c1 e2				ld hl, scratch 
c470					if DEBUG_FORTH_WORDS 
c470						DMARK "CO5" 
c470 f5				push af  
c471 3a 85 c4			ld a, (.dmark)  
c474 32 6b ee			ld (debug_mark),a  
c477 3a 86 c4			ld a, (.dmark+1)  
c47a 32 6c ee			ld (debug_mark+1),a  
c47d 3a 87 c4			ld a, (.dmark+2)  
c480 32 6d ee			ld (debug_mark+2),a  
c483 18 03			jr .pastdmark  
c485 ..			.dmark: db "CO5"  
c488 f1			.pastdmark: pop af  
c489			endm  
# End of macro DMARK
c489						CALLMONITOR 
c489 cd 6f ee			call debug_vector  
c48c				endm  
# End of macro CALLMONITOR
c48c					endif 
c48c			 
c48c cd 0e 9b				call forth_push_str 
c48f			 
c48f			 
c48f			 
c48f			 
c48f				       NEXTW 
c48f c3 4d 9e			jp macro_next 
c492				endm 
# End of macro NEXTW
c492			 
c492			 
c492			.FIND: 
c492				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c492 4b				db WORD_SYS_CORE+55             
c493 50 c5			dw .LEN            
c495 05				db 4 + 1 
c496 .. 00			db "FIND",0              
c49b				endm 
# End of macro CWHEAD
c49b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c49b			 
c49b					if DEBUG_FORTH_WORDS_KEY 
c49b						DMARK "FND" 
c49b f5				push af  
c49c 3a b0 c4			ld a, (.dmark)  
c49f 32 6b ee			ld (debug_mark),a  
c4a2 3a b1 c4			ld a, (.dmark+1)  
c4a5 32 6c ee			ld (debug_mark+1),a  
c4a8 3a b2 c4			ld a, (.dmark+2)  
c4ab 32 6d ee			ld (debug_mark+2),a  
c4ae 18 03			jr .pastdmark  
c4b0 ..			.dmark: db "FND"  
c4b3 f1			.pastdmark: pop af  
c4b4			endm  
# End of macro DMARK
c4b4						CALLMONITOR 
c4b4 cd 6f ee			call debug_vector  
c4b7				endm  
# End of macro CALLMONITOR
c4b7					endif 
c4b7			 
c4b7			; TODO check string type 
c4b7					FORTH_DSP_VALUE 
c4b7 cd 80 9c			call macro_forth_dsp_value 
c4ba				endm 
# End of macro FORTH_DSP_VALUE
c4ba			 
c4ba e5					push hl    
c4bb 7e					ld a,(hl)    ; char to find   
c4bc			; TODO change char to substr 
c4bc			 
c4bc f5					push af 
c4bd					 
c4bd			 
c4bd			 
c4bd					if DEBUG_FORTH_WORDS 
c4bd						DMARK "FN1" 
c4bd f5				push af  
c4be 3a d2 c4			ld a, (.dmark)  
c4c1 32 6b ee			ld (debug_mark),a  
c4c4 3a d3 c4			ld a, (.dmark+1)  
c4c7 32 6c ee			ld (debug_mark+1),a  
c4ca 3a d4 c4			ld a, (.dmark+2)  
c4cd 32 6d ee			ld (debug_mark+2),a  
c4d0 18 03			jr .pastdmark  
c4d2 ..			.dmark: db "FN1"  
c4d5 f1			.pastdmark: pop af  
c4d6			endm  
# End of macro DMARK
c4d6						CALLMONITOR 
c4d6 cd 6f ee			call debug_vector  
c4d9				endm  
# End of macro CALLMONITOR
c4d9					endif 
c4d9			 
c4d9					FORTH_DSP_POP 
c4d9 cd 4f 9d			call macro_forth_dsp_pop 
c4dc				endm 
# End of macro FORTH_DSP_POP
c4dc			 
c4dc					; string to search 
c4dc			 
c4dc					FORTH_DSP_VALUE 
c4dc cd 80 9c			call macro_forth_dsp_value 
c4df				endm 
# End of macro FORTH_DSP_VALUE
c4df			 
c4df d1					pop de  ; d is char to find  
c4e0			 
c4e0					if DEBUG_FORTH_WORDS 
c4e0						DMARK "FN2" 
c4e0 f5				push af  
c4e1 3a f5 c4			ld a, (.dmark)  
c4e4 32 6b ee			ld (debug_mark),a  
c4e7 3a f6 c4			ld a, (.dmark+1)  
c4ea 32 6c ee			ld (debug_mark+1),a  
c4ed 3a f7 c4			ld a, (.dmark+2)  
c4f0 32 6d ee			ld (debug_mark+2),a  
c4f3 18 03			jr .pastdmark  
c4f5 ..			.dmark: db "FN2"  
c4f8 f1			.pastdmark: pop af  
c4f9			endm  
# End of macro DMARK
c4f9						CALLMONITOR 
c4f9 cd 6f ee			call debug_vector  
c4fc				endm  
# End of macro CALLMONITOR
c4fc					endif 
c4fc					 
c4fc 01 00 00				ld bc, 0 
c4ff 7e			.findchar:      ld a,(hl) 
c500 fe 00				cp 0   		 
c502 28 27				jr z, .finddone     
c504 ba					cp d 
c505 28 20				jr z, .foundchar 
c507 03					inc bc 
c508 23					inc hl 
c509					if DEBUG_FORTH_WORDS 
c509						DMARK "FN3" 
c509 f5				push af  
c50a 3a 1e c5			ld a, (.dmark)  
c50d 32 6b ee			ld (debug_mark),a  
c510 3a 1f c5			ld a, (.dmark+1)  
c513 32 6c ee			ld (debug_mark+1),a  
c516 3a 20 c5			ld a, (.dmark+2)  
c519 32 6d ee			ld (debug_mark+2),a  
c51c 18 03			jr .pastdmark  
c51e ..			.dmark: db "FN3"  
c521 f1			.pastdmark: pop af  
c522			endm  
# End of macro DMARK
c522						CALLMONITOR 
c522 cd 6f ee			call debug_vector  
c525				endm  
# End of macro CALLMONITOR
c525					endif 
c525 18 d8				jr .findchar 
c527			 
c527			 
c527 c5			.foundchar:	push bc 
c528 e1					pop hl 
c529 18 03				jr .findexit 
c52b			 
c52b			 
c52b							 
c52b			 
c52b			.finddone:     ; got to end of string with no find 
c52b 21 00 00				ld hl, 0 
c52e			.findexit: 
c52e			 
c52e					if DEBUG_FORTH_WORDS 
c52e						DMARK "FNd" 
c52e f5				push af  
c52f 3a 43 c5			ld a, (.dmark)  
c532 32 6b ee			ld (debug_mark),a  
c535 3a 44 c5			ld a, (.dmark+1)  
c538 32 6c ee			ld (debug_mark+1),a  
c53b 3a 45 c5			ld a, (.dmark+2)  
c53e 32 6d ee			ld (debug_mark+2),a  
c541 18 03			jr .pastdmark  
c543 ..			.dmark: db "FNd"  
c546 f1			.pastdmark: pop af  
c547			endm  
# End of macro DMARK
c547						CALLMONITOR 
c547 cd 6f ee			call debug_vector  
c54a				endm  
# End of macro CALLMONITOR
c54a					endif 
c54a cd a0 9a			call forth_push_numhl 
c54d			 
c54d				       NEXTW 
c54d c3 4d 9e			jp macro_next 
c550				endm 
# End of macro NEXTW
c550			 
c550			.LEN: 
c550				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c550 4c				db WORD_SYS_CORE+56             
c551 ba c5			dw .ASC            
c553 06				db 5 + 1 
c554 .. 00			db "COUNT",0              
c55a				endm 
# End of macro CWHEAD
c55a			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c55a			 
c55a					if DEBUG_FORTH_WORDS_KEY 
c55a						DMARK "CNT" 
c55a f5				push af  
c55b 3a 6f c5			ld a, (.dmark)  
c55e 32 6b ee			ld (debug_mark),a  
c561 3a 70 c5			ld a, (.dmark+1)  
c564 32 6c ee			ld (debug_mark+1),a  
c567 3a 71 c5			ld a, (.dmark+2)  
c56a 32 6d ee			ld (debug_mark+2),a  
c56d 18 03			jr .pastdmark  
c56f ..			.dmark: db "CNT"  
c572 f1			.pastdmark: pop af  
c573			endm  
# End of macro DMARK
c573						CALLMONITOR 
c573 cd 6f ee			call debug_vector  
c576				endm  
# End of macro CALLMONITOR
c576					endif 
c576			; TODO check string type 
c576					FORTH_DSP_VALUE 
c576 cd 80 9c			call macro_forth_dsp_value 
c579				endm 
# End of macro FORTH_DSP_VALUE
c579			 
c579			 
c579					if DEBUG_FORTH_WORDS 
c579						DMARK "CN?" 
c579 f5				push af  
c57a 3a 8e c5			ld a, (.dmark)  
c57d 32 6b ee			ld (debug_mark),a  
c580 3a 8f c5			ld a, (.dmark+1)  
c583 32 6c ee			ld (debug_mark+1),a  
c586 3a 90 c5			ld a, (.dmark+2)  
c589 32 6d ee			ld (debug_mark+2),a  
c58c 18 03			jr .pastdmark  
c58e ..			.dmark: db "CN?"  
c591 f1			.pastdmark: pop af  
c592			endm  
# End of macro DMARK
c592						CALLMONITOR 
c592 cd 6f ee			call debug_vector  
c595				endm  
# End of macro CALLMONITOR
c595					endif 
c595 cd 92 90				call strlenz 
c598					if DEBUG_FORTH_WORDS 
c598						DMARK "CNl" 
c598 f5				push af  
c599 3a ad c5			ld a, (.dmark)  
c59c 32 6b ee			ld (debug_mark),a  
c59f 3a ae c5			ld a, (.dmark+1)  
c5a2 32 6c ee			ld (debug_mark+1),a  
c5a5 3a af c5			ld a, (.dmark+2)  
c5a8 32 6d ee			ld (debug_mark+2),a  
c5ab 18 03			jr .pastdmark  
c5ad ..			.dmark: db "CNl"  
c5b0 f1			.pastdmark: pop af  
c5b1			endm  
# End of macro DMARK
c5b1						CALLMONITOR 
c5b1 cd 6f ee			call debug_vector  
c5b4				endm  
# End of macro CALLMONITOR
c5b4					endif 
c5b4			 
c5b4 cd a0 9a				call forth_push_numhl 
c5b7			 
c5b7			 
c5b7			 
c5b7				       NEXTW 
c5b7 c3 4d 9e			jp macro_next 
c5ba				endm 
# End of macro NEXTW
c5ba			.ASC: 
c5ba				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5ba 4d				db WORD_SYS_CORE+57             
c5bb 28 c6			dw .CHR            
c5bd 04				db 3 + 1 
c5be .. 00			db "ASC",0              
c5c2				endm 
# End of macro CWHEAD
c5c2			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c5c2					if DEBUG_FORTH_WORDS_KEY 
c5c2						DMARK "ASC" 
c5c2 f5				push af  
c5c3 3a d7 c5			ld a, (.dmark)  
c5c6 32 6b ee			ld (debug_mark),a  
c5c9 3a d8 c5			ld a, (.dmark+1)  
c5cc 32 6c ee			ld (debug_mark+1),a  
c5cf 3a d9 c5			ld a, (.dmark+2)  
c5d2 32 6d ee			ld (debug_mark+2),a  
c5d5 18 03			jr .pastdmark  
c5d7 ..			.dmark: db "ASC"  
c5da f1			.pastdmark: pop af  
c5db			endm  
# End of macro DMARK
c5db						CALLMONITOR 
c5db cd 6f ee			call debug_vector  
c5de				endm  
# End of macro CALLMONITOR
c5de					endif 
c5de					FORTH_DSP_VALUE 
c5de cd 80 9c			call macro_forth_dsp_value 
c5e1				endm 
# End of macro FORTH_DSP_VALUE
c5e1					;v5 FORTH_DSP_VALUE 
c5e1			;		inc hl      ; now at start of numeric as string 
c5e1			 
c5e1 e5					push hl 
c5e2			 
c5e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5e2 cd 4f 9d			call macro_forth_dsp_pop 
c5e5				endm 
# End of macro FORTH_DSP_POP
c5e5			 
c5e5 e1					pop hl 
c5e6			 
c5e6					if DEBUG_FORTH_WORDS 
c5e6						DMARK "AS1" 
c5e6 f5				push af  
c5e7 3a fb c5			ld a, (.dmark)  
c5ea 32 6b ee			ld (debug_mark),a  
c5ed 3a fc c5			ld a, (.dmark+1)  
c5f0 32 6c ee			ld (debug_mark+1),a  
c5f3 3a fd c5			ld a, (.dmark+2)  
c5f6 32 6d ee			ld (debug_mark+2),a  
c5f9 18 03			jr .pastdmark  
c5fb ..			.dmark: db "AS1"  
c5fe f1			.pastdmark: pop af  
c5ff			endm  
# End of macro DMARK
c5ff						CALLMONITOR 
c5ff cd 6f ee			call debug_vector  
c602				endm  
# End of macro CALLMONITOR
c602					endif 
c602					; push the content of a onto the stack as a value 
c602			 
c602 7e					ld a,(hl)   ; get char 
c603 26 00				ld h,0 
c605 6f					ld l,a 
c606					if DEBUG_FORTH_WORDS 
c606						DMARK "AS2" 
c606 f5				push af  
c607 3a 1b c6			ld a, (.dmark)  
c60a 32 6b ee			ld (debug_mark),a  
c60d 3a 1c c6			ld a, (.dmark+1)  
c610 32 6c ee			ld (debug_mark+1),a  
c613 3a 1d c6			ld a, (.dmark+2)  
c616 32 6d ee			ld (debug_mark+2),a  
c619 18 03			jr .pastdmark  
c61b ..			.dmark: db "AS2"  
c61e f1			.pastdmark: pop af  
c61f			endm  
# End of macro DMARK
c61f						CALLMONITOR 
c61f cd 6f ee			call debug_vector  
c622				endm  
# End of macro CALLMONITOR
c622					endif 
c622 cd a0 9a				call forth_push_numhl 
c625			 
c625				       NEXTW 
c625 c3 4d 9e			jp macro_next 
c628				endm 
# End of macro NEXTW
c628			 
c628			.CHR: 
c628				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c628 4d				db WORD_SYS_CORE+57             
c629 64 c6			dw .ENDSTR            
c62b 04				db 3 + 1 
c62c .. 00			db "CHR",0              
c630				endm 
# End of macro CWHEAD
c630			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c630					if DEBUG_FORTH_WORDS_KEY 
c630						DMARK "CHR" 
c630 f5				push af  
c631 3a 45 c6			ld a, (.dmark)  
c634 32 6b ee			ld (debug_mark),a  
c637 3a 46 c6			ld a, (.dmark+1)  
c63a 32 6c ee			ld (debug_mark+1),a  
c63d 3a 47 c6			ld a, (.dmark+2)  
c640 32 6d ee			ld (debug_mark+2),a  
c643 18 03			jr .pastdmark  
c645 ..			.dmark: db "CHR"  
c648 f1			.pastdmark: pop af  
c649			endm  
# End of macro DMARK
c649						CALLMONITOR 
c649 cd 6f ee			call debug_vector  
c64c				endm  
# End of macro CALLMONITOR
c64c					endif 
c64c					FORTH_DSP_VALUEHL 
c64c cd 97 9c			call macro_dsp_valuehl 
c64f				endm 
# End of macro FORTH_DSP_VALUEHL
c64f			 
c64f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c64f cd 4f 9d			call macro_forth_dsp_pop 
c652				endm 
# End of macro FORTH_DSP_POP
c652			 
c652					; save asci byte as a zero term string and push string 
c652			 
c652 7d					ld a,l 
c653 32 c1 e2				ld (scratch), a 
c656			 
c656 3e 00				ld a, 0 
c658 32 c2 e2				ld (scratch+1), a 
c65b			 
c65b 21 c1 e2				ld hl, scratch 
c65e cd 0e 9b				call forth_push_str 
c661			 
c661			 
c661				       NEXTW 
c661 c3 4d 9e			jp macro_next 
c664				endm 
# End of macro NEXTW
c664			 
c664			 
c664			 
c664			 
c664			.ENDSTR: 
c664			; eof 
c664			 
# End of file forth_words_str.asm
c664			include "forth_words_key.asm" 
c664			 
c664			; | ## Keyboard Words 
c664			 
c664			.KEY: 
c664				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c664 3e				db WORD_SYS_CORE+42             
c665 94 c6			dw .WAITK            
c667 04				db 3 + 1 
c668 .. 00			db "KEY",0              
c66c				endm 
# End of macro CWHEAD
c66c			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c66c			 
c66c					if DEBUG_FORTH_WORDS_KEY 
c66c						DMARK "KEY" 
c66c f5				push af  
c66d 3a 81 c6			ld a, (.dmark)  
c670 32 6b ee			ld (debug_mark),a  
c673 3a 82 c6			ld a, (.dmark+1)  
c676 32 6c ee			ld (debug_mark+1),a  
c679 3a 83 c6			ld a, (.dmark+2)  
c67c 32 6d ee			ld (debug_mark+2),a  
c67f 18 03			jr .pastdmark  
c681 ..			.dmark: db "KEY"  
c684 f1			.pastdmark: pop af  
c685			endm  
# End of macro DMARK
c685						CALLMONITOR 
c685 cd 6f ee			call debug_vector  
c688				endm  
# End of macro CALLMONITOR
c688					endif 
c688			; TODO currently waits 
c688 cd 2e e4				call cin 
c68b					;call cin_wait 
c68b 6f					ld l, a 
c68c 26 00				ld h, 0 
c68e cd a0 9a				call forth_push_numhl 
c691					NEXTW 
c691 c3 4d 9e			jp macro_next 
c694				endm 
# End of macro NEXTW
c694			.WAITK: 
c694				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c694 3f				db WORD_SYS_CORE+43             
c695 c6 c6			dw .ACCEPT            
c697 06				db 5 + 1 
c698 .. 00			db "WAITK",0              
c69e				endm 
# End of macro CWHEAD
c69e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c69e					if DEBUG_FORTH_WORDS_KEY 
c69e						DMARK "WAI" 
c69e f5				push af  
c69f 3a b3 c6			ld a, (.dmark)  
c6a2 32 6b ee			ld (debug_mark),a  
c6a5 3a b4 c6			ld a, (.dmark+1)  
c6a8 32 6c ee			ld (debug_mark+1),a  
c6ab 3a b5 c6			ld a, (.dmark+2)  
c6ae 32 6d ee			ld (debug_mark+2),a  
c6b1 18 03			jr .pastdmark  
c6b3 ..			.dmark: db "WAI"  
c6b6 f1			.pastdmark: pop af  
c6b7			endm  
# End of macro DMARK
c6b7						CALLMONITOR 
c6b7 cd 6f ee			call debug_vector  
c6ba				endm  
# End of macro CALLMONITOR
c6ba					endif 
c6ba cd 28 e4				call cin_wait 
c6bd 6f					ld l, a 
c6be 26 00				ld h, 0 
c6c0 cd a0 9a				call forth_push_numhl 
c6c3					NEXTW 
c6c3 c3 4d 9e			jp macro_next 
c6c6				endm 
# End of macro NEXTW
c6c6			.ACCEPT: 
c6c6				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6c6 40				db WORD_SYS_CORE+44             
c6c7 24 c7			dw .EDIT            
c6c9 07				db 6 + 1 
c6ca .. 00			db "ACCEPT",0              
c6d1				endm 
# End of macro CWHEAD
c6d1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6d1					; TODO crashes on push 
c6d1					if DEBUG_FORTH_WORDS_KEY 
c6d1						DMARK "ACC" 
c6d1 f5				push af  
c6d2 3a e6 c6			ld a, (.dmark)  
c6d5 32 6b ee			ld (debug_mark),a  
c6d8 3a e7 c6			ld a, (.dmark+1)  
c6db 32 6c ee			ld (debug_mark+1),a  
c6de 3a e8 c6			ld a, (.dmark+2)  
c6e1 32 6d ee			ld (debug_mark+2),a  
c6e4 18 03			jr .pastdmark  
c6e6 ..			.dmark: db "ACC"  
c6e9 f1			.pastdmark: pop af  
c6ea			endm  
# End of macro DMARK
c6ea						CALLMONITOR 
c6ea cd 6f ee			call debug_vector  
c6ed				endm  
# End of macro CALLMONITOR
c6ed					endif 
c6ed 21 bf e4				ld hl, os_input 
c6f0 3e 00				ld a, 0 
c6f2 77					ld (hl),a 
c6f3 3a 5e ea				ld a,(f_cursor_ptr) 
c6f6 16 64				ld d, 100 
c6f8 0e 00				ld c, 0 
c6fa 1e 28				ld e, 40 
c6fc cd 08 8d				call input_str 
c6ff					; TODO perhaps do a type check and wrap in quotes if not a number 
c6ff 21 bf e4				ld hl, os_input 
c702					if DEBUG_FORTH_WORDS 
c702						DMARK "AC1" 
c702 f5				push af  
c703 3a 17 c7			ld a, (.dmark)  
c706 32 6b ee			ld (debug_mark),a  
c709 3a 18 c7			ld a, (.dmark+1)  
c70c 32 6c ee			ld (debug_mark+1),a  
c70f 3a 19 c7			ld a, (.dmark+2)  
c712 32 6d ee			ld (debug_mark+2),a  
c715 18 03			jr .pastdmark  
c717 ..			.dmark: db "AC1"  
c71a f1			.pastdmark: pop af  
c71b			endm  
# End of macro DMARK
c71b						CALLMONITOR 
c71b cd 6f ee			call debug_vector  
c71e				endm  
# End of macro CALLMONITOR
c71e					endif 
c71e cd 0e 9b				call forth_push_str 
c721					NEXTW 
c721 c3 4d 9e			jp macro_next 
c724				endm 
# End of macro NEXTW
c724			 
c724			.EDIT: 
c724				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c724 40				db WORD_SYS_CORE+44             
c725 c6 c7			dw .DEDIT            
c727 05				db 4 + 1 
c728 .. 00			db "EDIT",0              
c72d				endm 
# End of macro CWHEAD
c72d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c72d			 
c72d					; TODO does not copy from stack 
c72d					if DEBUG_FORTH_WORDS_KEY 
c72d						DMARK "EDT" 
c72d f5				push af  
c72e 3a 42 c7			ld a, (.dmark)  
c731 32 6b ee			ld (debug_mark),a  
c734 3a 43 c7			ld a, (.dmark+1)  
c737 32 6c ee			ld (debug_mark+1),a  
c73a 3a 44 c7			ld a, (.dmark+2)  
c73d 32 6d ee			ld (debug_mark+2),a  
c740 18 03			jr .pastdmark  
c742 ..			.dmark: db "EDT"  
c745 f1			.pastdmark: pop af  
c746			endm  
# End of macro DMARK
c746						CALLMONITOR 
c746 cd 6f ee			call debug_vector  
c749				endm  
# End of macro CALLMONITOR
c749					endif 
c749			 
c749					;FORTH_DSP 
c749					FORTH_DSP_VALUEHL 
c749 cd 97 9c			call macro_dsp_valuehl 
c74c				endm 
# End of macro FORTH_DSP_VALUEHL
c74c			;		inc hl    ; TODO do type check 
c74c			 
c74c			;		call get_word_hl 
c74c e5					push hl 
c74d					if DEBUG_FORTH_WORDS 
c74d						DMARK "EDp" 
c74d f5				push af  
c74e 3a 62 c7			ld a, (.dmark)  
c751 32 6b ee			ld (debug_mark),a  
c754 3a 63 c7			ld a, (.dmark+1)  
c757 32 6c ee			ld (debug_mark+1),a  
c75a 3a 64 c7			ld a, (.dmark+2)  
c75d 32 6d ee			ld (debug_mark+2),a  
c760 18 03			jr .pastdmark  
c762 ..			.dmark: db "EDp"  
c765 f1			.pastdmark: pop af  
c766			endm  
# End of macro DMARK
c766						CALLMONITOR 
c766 cd 6f ee			call debug_vector  
c769				endm  
# End of macro CALLMONITOR
c769					endif 
c769				;	ld a, 0 
c769 cd 92 90				call strlenz 
c76c 23					inc hl 
c76d			 
c76d 06 00				ld b, 0 
c76f 4d					ld c, l 
c770			 
c770 e1					pop hl 
c771 11 bf e4				ld de, os_input 
c774					if DEBUG_FORTH_WORDS_KEY 
c774						DMARK "EDc" 
c774 f5				push af  
c775 3a 89 c7			ld a, (.dmark)  
c778 32 6b ee			ld (debug_mark),a  
c77b 3a 8a c7			ld a, (.dmark+1)  
c77e 32 6c ee			ld (debug_mark+1),a  
c781 3a 8b c7			ld a, (.dmark+2)  
c784 32 6d ee			ld (debug_mark+2),a  
c787 18 03			jr .pastdmark  
c789 ..			.dmark: db "EDc"  
c78c f1			.pastdmark: pop af  
c78d			endm  
# End of macro DMARK
c78d						CALLMONITOR 
c78d cd 6f ee			call debug_vector  
c790				endm  
# End of macro CALLMONITOR
c790					endif 
c790 ed b0				ldir 
c792			 
c792			 
c792 21 bf e4				ld hl, os_input 
c795					;ld a, 0 
c795					;ld (hl),a 
c795 3a 5e ea				ld a,(f_cursor_ptr) 
c798 16 64				ld d, 100 
c79a 0e 00				ld c, 0 
c79c 1e 28				ld e, 40 
c79e cd 08 8d				call input_str 
c7a1					; TODO perhaps do a type check and wrap in quotes if not a number 
c7a1 21 bf e4				ld hl, os_input 
c7a4					if DEBUG_FORTH_WORDS 
c7a4						DMARK "ED1" 
c7a4 f5				push af  
c7a5 3a b9 c7			ld a, (.dmark)  
c7a8 32 6b ee			ld (debug_mark),a  
c7ab 3a ba c7			ld a, (.dmark+1)  
c7ae 32 6c ee			ld (debug_mark+1),a  
c7b1 3a bb c7			ld a, (.dmark+2)  
c7b4 32 6d ee			ld (debug_mark+2),a  
c7b7 18 03			jr .pastdmark  
c7b9 ..			.dmark: db "ED1"  
c7bc f1			.pastdmark: pop af  
c7bd			endm  
# End of macro DMARK
c7bd						CALLMONITOR 
c7bd cd 6f ee			call debug_vector  
c7c0				endm  
# End of macro CALLMONITOR
c7c0					endif 
c7c0 cd 0e 9b				call forth_push_str 
c7c3					NEXTW 
c7c3 c3 4d 9e			jp macro_next 
c7c6				endm 
# End of macro NEXTW
c7c6			 
c7c6			.DEDIT: 
c7c6				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7c6 40				db WORD_SYS_CORE+44             
c7c7 28 c8			dw .ENDKEY            
c7c9 06				db 5 + 1 
c7ca .. 00			db "DEDIT",0              
c7d0				endm 
# End of macro CWHEAD
c7d0			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7d0			 
c7d0					; TODO does not copy from stack 
c7d0					if DEBUG_FORTH_WORDS_KEY 
c7d0						DMARK "DED" 
c7d0 f5				push af  
c7d1 3a e5 c7			ld a, (.dmark)  
c7d4 32 6b ee			ld (debug_mark),a  
c7d7 3a e6 c7			ld a, (.dmark+1)  
c7da 32 6c ee			ld (debug_mark+1),a  
c7dd 3a e7 c7			ld a, (.dmark+2)  
c7e0 32 6d ee			ld (debug_mark+2),a  
c7e3 18 03			jr .pastdmark  
c7e5 ..			.dmark: db "DED"  
c7e8 f1			.pastdmark: pop af  
c7e9			endm  
# End of macro DMARK
c7e9						CALLMONITOR 
c7e9 cd 6f ee			call debug_vector  
c7ec				endm  
# End of macro CALLMONITOR
c7ec					endif 
c7ec			 
c7ec					;FORTH_DSP 
c7ec					FORTH_DSP_VALUEHL 
c7ec cd 97 9c			call macro_dsp_valuehl 
c7ef				endm 
# End of macro FORTH_DSP_VALUEHL
c7ef			;		inc hl    ; TODO do type check 
c7ef			 
c7ef			;		call get_word_hl 
c7ef e5					push hl 
c7f0 e5					push hl 
c7f1					FORTH_DSP_POP 
c7f1 cd 4f 9d			call macro_forth_dsp_pop 
c7f4				endm 
# End of macro FORTH_DSP_POP
c7f4 e1					pop hl 
c7f5					if DEBUG_FORTH_WORDS 
c7f5						DMARK "EDp" 
c7f5 f5				push af  
c7f6 3a 0a c8			ld a, (.dmark)  
c7f9 32 6b ee			ld (debug_mark),a  
c7fc 3a 0b c8			ld a, (.dmark+1)  
c7ff 32 6c ee			ld (debug_mark+1),a  
c802 3a 0c c8			ld a, (.dmark+2)  
c805 32 6d ee			ld (debug_mark+2),a  
c808 18 03			jr .pastdmark  
c80a ..			.dmark: db "EDp"  
c80d f1			.pastdmark: pop af  
c80e			endm  
# End of macro DMARK
c80e						CALLMONITOR 
c80e cd 6f ee			call debug_vector  
c811				endm  
# End of macro CALLMONITOR
c811					endif 
c811				;	ld a, 0 
c811 cd 92 90				call strlenz 
c814 23					inc hl 
c815			 
c815 06 00				ld b, 0 
c817 4d					ld c, l 
c818			 
c818 e1					pop hl 
c819			 
c819					;ld a, 0 
c819					;ld (hl),a 
c819 3a 5e ea				ld a,(f_cursor_ptr) 
c81c 16 64				ld d, 100 
c81e 0e 00				ld c, 0 
c820 1e 28				ld e, 40 
c822 cd 08 8d				call input_str 
c825					; TODO perhaps do a type check and wrap in quotes if not a number 
c825					NEXTW 
c825 c3 4d 9e			jp macro_next 
c828				endm 
# End of macro NEXTW
c828			 
c828			 
c828			.ENDKEY: 
c828			; eof 
c828			 
# End of file forth_words_key.asm
c828			include "forth_words_const.asm" 
c828			 
c828			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c828			 
c828			 
c828			.SPITIME: 
c828				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c828 77				db WORD_SYS_CORE+99             
c829 3d c8			dw .VA            
c82b 08				db 7 + 1 
c82c .. 00			db "SPITIME",0              
c834				endm 
# End of macro CWHEAD
c834			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c834			; 
c834			; | | If using BANK devices then leave as is. 
c834			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c834			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c834			 
c834 21 64 ea				ld hl, spi_clktime  
c837 cd a0 9a				call forth_push_numhl 
c83a			 
c83a					NEXTW 
c83a c3 4d 9e			jp macro_next 
c83d				endm 
# End of macro NEXTW
c83d			 
c83d			 
c83d			.VA: 
c83d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c83d 77				db WORD_SYS_CORE+99             
c83e 4d c8			dw .SYMBOL            
c840 03				db 2 + 1 
c841 .. 00			db "VA",0              
c844				endm 
# End of macro CWHEAD
c844			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c844 21 28 ea				ld hl, cli_var_array 
c847 cd a0 9a				call forth_push_numhl 
c84a			 
c84a					NEXTW 
c84a c3 4d 9e			jp macro_next 
c84d				endm 
# End of macro NEXTW
c84d			 
c84d			.SYMBOL: 
c84d				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c84d 77				db WORD_SYS_CORE+99             
c84e 57 c9			dw .ENDCONST            
c850 07				db 6 + 1 
c851 .. 00			db "SYMBOL",0              
c858				endm 
# End of macro CWHEAD
c858			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c858			; | 
c858			; | | The value is the number reference and the final address is pushed to stack 
c858			 
c858			; | | ``` 
c858			; | | dw sym_table 
c858			; | | dw nmi_vector 
c858			; | | dw cli_autodisplay 
c858			; | | dw cli_data_sp 
c858			; | | dw cli_data_stack 
c858			; | | dw cli_loop_sp 
c858			; | | dw cli_loop_stack 
c858			; | | dw cli_var_array 
c858			; | | dw cursor_col 
c858			; | | dw cursor_ptr 
c858			; | | ; 10 
c858			; | | dw cursor_row 
c858			; | | dw debug_mark 
c858			; | | dw display_fb0 
c858			; | | dw display_fb1 
c858			; | | dw display_fb2 
c858			; | | dw display_fb3 
c858			; | | dw display_fb_active 
c858			; | | dw execscratch 
c858			; | | dw f_cursor_ptr 
c858			; | | dw hardware_word 
c858			; | | ;20 
c858			; | | dw input_at_cursor 
c858			; | | dw input_at_pos 
c858			; | | dw input_cur_flash 
c858			; | | dw input_cur_onoff 
c858			; | | dw input_cursor 
c858			; | | dw input_display_size 
c858			; | | dw input_len 
c858			; | | dw input_ptr 
c858			; | | dw input_size 
c858			; | | dw input_start 
c858			; | | ; 30 
c858			; | | dw input_str 
c858			; | | dw input_under_cursor 
c858			; | | dw os_cli_cmd 
c858			; | | dw os_cur_ptr 
c858			; | | dw os_current_i 
c858			; | | dw os_input 
c858			; | | dw os_last_cmd 
c858			; | | dw os_last_new_uword 
c858			; | | dw debug_vector 
c858			; | | dw os_view_hl 
c858			; | | ;40 
c858			; | | dw os_word_scratch 
c858			; | | dw portbctl 
c858			; | | dw portbdata 
c858			; | | dw spi_cartdev 
c858			; | | dw spi_cartdev2 
c858			; | | dw spi_clktime 
c858			; | | dw spi_device 
c858			; | | dw spi_device_id 
c858			; | | dw spi_portbyte 
c858			; | | dw stackstore 
c858			; | | ; 50 
c858			; | | if STORAGE_SE 
c858			; | | dw storage_actl 
c858			; | | dw storage_adata 
c858			; | | else 
c858			; | | dw 0 
c858			; | | dw 0 
c858			; | | endif 
c858			; | | dw storage_append 
c858			; | | if STORAGE_SE 
c858			; | | dw storage_bctl 
c858			; | | else 
c858			; | | dw 0 
c858			; | | endif 
c858			; | | dw store_bank_active 
c858			; | | dw store_filecache 
c858			; | | dw store_longread 
c858			; | | dw store_openaddr 
c858			; | | dw store_openext 
c858			; | | dw store_openmaxext 
c858			; | | ; 60 
c858			; | | dw store_page 
c858			; | | dw store_readbuf 
c858			; | | dw store_readcont 
c858			; | | dw store_readptr 
c858			; | | dw store_tmpext 
c858			; | | dw store_tmpid 
c858			; | | dw store_tmppageid 
c858			; | | dw malloc 
c858			; | | dw free 
c858			; | | dw cin 
c858			; | | ; 70 
c858			; | | dw cin_wait 
c858			; | | dw forth_push_numhl 
c858			; | | dw forth_push_str 
c858			; | | ``` 
c858			 
c858					if DEBUG_FORTH_WORDS_KEY 
c858						DMARK "SYM" 
c858 f5				push af  
c859 3a 6d c8			ld a, (.dmark)  
c85c 32 6b ee			ld (debug_mark),a  
c85f 3a 6e c8			ld a, (.dmark+1)  
c862 32 6c ee			ld (debug_mark+1),a  
c865 3a 6f c8			ld a, (.dmark+2)  
c868 32 6d ee			ld (debug_mark+2),a  
c86b 18 03			jr .pastdmark  
c86d ..			.dmark: db "SYM"  
c870 f1			.pastdmark: pop af  
c871			endm  
# End of macro DMARK
c871						CALLMONITOR 
c871 cd 6f ee			call debug_vector  
c874				endm  
# End of macro CALLMONITOR
c874					endif 
c874			 
c874					FORTH_DSP_VALUEHL 
c874 cd 97 9c			call macro_dsp_valuehl 
c877				endm 
# End of macro FORTH_DSP_VALUEHL
c877			 
c877 7d					ld a, l     
c878			 
c878			 
c878					if DEBUG_FORTH_WORDS 
c878						DMARK "SY1" 
c878 f5				push af  
c879 3a 8d c8			ld a, (.dmark)  
c87c 32 6b ee			ld (debug_mark),a  
c87f 3a 8e c8			ld a, (.dmark+1)  
c882 32 6c ee			ld (debug_mark+1),a  
c885 3a 8f c8			ld a, (.dmark+2)  
c888 32 6d ee			ld (debug_mark+2),a  
c88b 18 03			jr .pastdmark  
c88d ..			.dmark: db "SY1"  
c890 f1			.pastdmark: pop af  
c891			endm  
# End of macro DMARK
c891						CALLMONITOR 
c891 cd 6f ee			call debug_vector  
c894				endm  
# End of macro CALLMONITOR
c894					endif 
c894					 
c894 f5					push af	 
c895					FORTH_DSP_POP 
c895 cd 4f 9d			call macro_forth_dsp_pop 
c898				endm 
# End of macro FORTH_DSP_POP
c898 f1					pop af 
c899			 
c899 cb 27				sla a  
c89b				 
c89b					 
c89b					if DEBUG_FORTH_WORDS 
c89b						DMARK "SY" 
c89b f5				push af  
c89c 3a b0 c8			ld a, (.dmark)  
c89f 32 6b ee			ld (debug_mark),a  
c8a2 3a b1 c8			ld a, (.dmark+1)  
c8a5 32 6c ee			ld (debug_mark+1),a  
c8a8 3a b2 c8			ld a, (.dmark+2)  
c8ab 32 6d ee			ld (debug_mark+2),a  
c8ae 18 02			jr .pastdmark  
c8b0 ..			.dmark: db "SY"  
c8b2 f1			.pastdmark: pop af  
c8b3			endm  
# End of macro DMARK
c8b3						CALLMONITOR 
c8b3 cd 6f ee			call debug_vector  
c8b6				endm  
# End of macro CALLMONITOR
c8b6					endif 
c8b6			 
c8b6 21 c5 c8				ld hl, sym_table 
c8b9 cd db 8c				call addatohl 
c8bc cd cf 9d				call loadwordinhl 
c8bf cd a0 9a				call forth_push_numhl 
c8c2			 
c8c2			 
c8c2				       NEXTW 
c8c2 c3 4d 9e			jp macro_next 
c8c5				endm 
# End of macro NEXTW
c8c5			 
c8c5			sym_table: 
c8c5			 
c8c5			; 0 
c8c5 c5 c8		dw sym_table 
c8c7 72 ee		dw nmi_vector 
c8c9 3c ea		dw cli_autodisplay 
c8cb ee e9		dw cli_data_sp 
c8cd 28 e8		dw cli_data_stack 
c8cf f0 e9		dw cli_loop_sp 
c8d1 2a e9		dw cli_loop_stack 
c8d3 28 ea		dw cli_var_array 
c8d5 c5 eb		dw cursor_col 
c8d7 c3 eb		dw cursor_ptr 
c8d9			; 10 
c8d9 c4 eb		dw cursor_row 
c8db 6b ee		dw debug_mark 
c8dd b1 ed		dw display_fb0 
c8df 10 ed		dw display_fb1 
c8e1 ce eb		dw display_fb2 
c8e3 6f ec		dw display_fb3 
c8e5 cc eb		dw display_fb_active 
c8e7 c0 e3		dw execscratch 
c8e9 5e ea		dw f_cursor_ptr 
c8eb 75 ee		dw hardware_word 
c8ed			;20 
c8ed 62 ee		dw input_at_cursor 
c8ef 64 ee		dw input_at_pos 
c8f1 60 ee		dw input_cur_flash 
c8f3 5f ee		dw input_cur_onoff 
c8f5 55 ee		dw input_cursor 
c8f7 65 ee		dw input_display_size 
c8f9 5a ee		dw input_len 
c8fb 69 ee		dw input_ptr 
c8fd 66 ee		dw input_size 
c8ff 67 ee		dw input_start 
c901			; 30 
c901 08 8d		dw input_str 
c903 63 ee		dw input_under_cursor 
c905 e8 e5		dw os_cli_cmd 
c907 e4 e5		dw os_cur_ptr 
c909 e6 e5		dw os_current_i 
c90b bf e4		dw os_input 
c90d e7 e6		dw os_last_cmd 
c90f be e5		dw os_last_new_uword 
c911 6f ee		dw debug_vector 
c913 a3 e2		dw os_view_hl 
c915			;40 
c915 c6 e5		dw os_word_scratch 
c917 c3 00		dw portbctl 
c919 c1 00		dw portbdata 
c91b 63 ea		dw spi_cartdev 
c91d 62 ea		dw spi_cartdev2 
c91f 64 ea		dw spi_clktime 
c921 60 ea		dw spi_device 
c923 5f ea		dw spi_device_id 
c925 61 ea		dw spi_portbyte 
c927 a7 eb		dw stackstore 
c929			; 50 
c929			if STORAGE_SE 
c929			dw storage_actl 
c929			dw storage_adata 
c929			else 
c929 00 00		dw 0 
c92b 00 00		dw 0 
c92d			endif 
c92d 68 88		dw storage_append 
c92f			if STORAGE_SE 
c92f			dw storage_bctl 
c92f			else 
c92f 00 00		dw 0 
c931			endif 
c931 93 eb		dw store_bank_active 
c933 67 ea		dw store_filecache 
c935 75 ea		dw store_longread 
c937 6b ea		dw store_openaddr 
c939 6a ea		dw store_openext 
c93b 69 ea		dw store_openmaxext 
c93d			; 60 
c93d 7a ea		dw store_page 
c93f 76 ea		dw store_readbuf 
c941 6d ea		dw store_readcont 
c943 78 ea		dw store_readptr 
c945 6d ea		dw store_tmpext 
c947 6e ea		dw store_tmpid 
c949 65 ea		dw store_tmppageid 
c94b 07 91		dw malloc 
c94d d1 91		dw free 
c94f 2e e4		dw cin 
c951			; 70 
c951 28 e4		dw cin_wait 
c953 a0 9a		dw forth_push_numhl 
c955 0e 9b		dw forth_push_str 
c957			 
c957			 
c957			.ENDCONST: 
c957			 
c957			; eof 
c957			 
c957			 
# End of file forth_words_const.asm
c957			 
c957			if STORAGE_SE 
c957			   	include "forth_words_storage.asm" 
c957			endif 
c957				include "forth_words_device.asm" 
c957			; Device related words 
c957			 
c957			; | ## Device Words 
c957			 
c957			;if SOUND_ENABLE 
c957			;.NOTE: 
c957			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c957			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c957			;		if DEBUG_FORTH_WORDS_KEY 
c957			;			DMARK "NTE" 
c957			;			CALLMONITOR 
c957			;		endif 
c957			; 
c957			;	 
c957			; 
c957			;		NEXTW 
c957			;.AFTERSOUND: 
c957			;endif 
c957			 
c957			 
c957			USE_GPIO: equ 0 
c957			 
c957			if USE_GPIO 
c957			.GP1: 
c957				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c957			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c957					NEXTW 
c957			.GP2: 
c957				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c957			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c957			 
c957					NEXTW 
c957			 
c957			.GP3: 
c957				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c957			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c957			 
c957					NEXTW 
c957			 
c957			.GP4: 
c957				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c957			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c957			 
c957					NEXTW 
c957			.SIN: 
c957			 
c957			 
c957			endif 
c957			 
c957			 
c957				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c957 33				db WORD_SYS_CORE+31             
c958 8c c9			dw .SOUT            
c95a 03				db 2 + 1 
c95b .. 00			db "IN",0              
c95e				endm 
# End of macro CWHEAD
c95e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c95e					if DEBUG_FORTH_WORDS_KEY 
c95e						DMARK "IN." 
c95e f5				push af  
c95f 3a 73 c9			ld a, (.dmark)  
c962 32 6b ee			ld (debug_mark),a  
c965 3a 74 c9			ld a, (.dmark+1)  
c968 32 6c ee			ld (debug_mark+1),a  
c96b 3a 75 c9			ld a, (.dmark+2)  
c96e 32 6d ee			ld (debug_mark+2),a  
c971 18 03			jr .pastdmark  
c973 ..			.dmark: db "IN."  
c976 f1			.pastdmark: pop af  
c977			endm  
# End of macro DMARK
c977						CALLMONITOR 
c977 cd 6f ee			call debug_vector  
c97a				endm  
# End of macro CALLMONITOR
c97a					endif 
c97a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c97a cd 97 9c			call macro_dsp_valuehl 
c97d				endm 
# End of macro FORTH_DSP_VALUEHL
c97d			 
c97d e5					push hl 
c97e			 
c97e					; destroy value TOS 
c97e			 
c97e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c97e cd 4f 9d			call macro_forth_dsp_pop 
c981				endm 
# End of macro FORTH_DSP_POP
c981			 
c981					; one value on hl get other one back 
c981			 
c981 c1					pop bc 
c982			 
c982					; do the sub 
c982			;		ex de, hl 
c982			 
c982 ed 68				in l,(c) 
c984			 
c984					; save it 
c984			 
c984 26 00				ld h,0 
c986			 
c986					; TODO push value back onto stack for another op etc 
c986			 
c986 cd a0 9a				call forth_push_numhl 
c989					NEXTW 
c989 c3 4d 9e			jp macro_next 
c98c				endm 
# End of macro NEXTW
c98c			.SOUT: 
c98c				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c98c 34				db WORD_SYS_CORE+32             
c98d df c9			dw .SPIO            
c98f 04				db 3 + 1 
c990 .. 00			db "OUT",0              
c994				endm 
# End of macro CWHEAD
c994			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c994					if DEBUG_FORTH_WORDS_KEY 
c994						DMARK "OUT" 
c994 f5				push af  
c995 3a a9 c9			ld a, (.dmark)  
c998 32 6b ee			ld (debug_mark),a  
c99b 3a aa c9			ld a, (.dmark+1)  
c99e 32 6c ee			ld (debug_mark+1),a  
c9a1 3a ab c9			ld a, (.dmark+2)  
c9a4 32 6d ee			ld (debug_mark+2),a  
c9a7 18 03			jr .pastdmark  
c9a9 ..			.dmark: db "OUT"  
c9ac f1			.pastdmark: pop af  
c9ad			endm  
# End of macro DMARK
c9ad						CALLMONITOR 
c9ad cd 6f ee			call debug_vector  
c9b0				endm  
# End of macro CALLMONITOR
c9b0					endif 
c9b0			 
c9b0					; get port 
c9b0			 
c9b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9b0 cd 97 9c			call macro_dsp_valuehl 
c9b3				endm 
# End of macro FORTH_DSP_VALUEHL
c9b3			 
c9b3 e5					push hl 
c9b4			 
c9b4					; destroy value TOS 
c9b4			 
c9b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9b4 cd 4f 9d			call macro_forth_dsp_pop 
c9b7				endm 
# End of macro FORTH_DSP_POP
c9b7			 
c9b7					; get byte to send 
c9b7			 
c9b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9b7 cd 97 9c			call macro_dsp_valuehl 
c9ba				endm 
# End of macro FORTH_DSP_VALUEHL
c9ba			 
c9ba			;		push hl 
c9ba			 
c9ba					; destroy value TOS 
c9ba			 
c9ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9ba cd 4f 9d			call macro_forth_dsp_pop 
c9bd				endm 
# End of macro FORTH_DSP_POP
c9bd			 
c9bd					; one value on hl get other one back 
c9bd			 
c9bd			;		pop hl 
c9bd			 
c9bd c1					pop bc 
c9be			 
c9be					if DEBUG_FORTH_WORDS 
c9be						DMARK "OUT" 
c9be f5				push af  
c9bf 3a d3 c9			ld a, (.dmark)  
c9c2 32 6b ee			ld (debug_mark),a  
c9c5 3a d4 c9			ld a, (.dmark+1)  
c9c8 32 6c ee			ld (debug_mark+1),a  
c9cb 3a d5 c9			ld a, (.dmark+2)  
c9ce 32 6d ee			ld (debug_mark+2),a  
c9d1 18 03			jr .pastdmark  
c9d3 ..			.dmark: db "OUT"  
c9d6 f1			.pastdmark: pop af  
c9d7			endm  
# End of macro DMARK
c9d7						CALLMONITOR 
c9d7 cd 6f ee			call debug_vector  
c9da				endm  
# End of macro CALLMONITOR
c9da					endif 
c9da			 
c9da ed 69				out (c), l 
c9dc			 
c9dc					NEXTW 
c9dc c3 4d 9e			jp macro_next 
c9df				endm 
# End of macro NEXTW
c9df			 
c9df			 
c9df			.SPIO: 
c9df			 
c9df			if STORAGE_SE 
c9df				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9df			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9df			 
c9df					call spi_ce_low 
c9df			    NEXTW 
c9df			 
c9df			.SPICEH: 
c9df				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9df			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9df			 
c9df					call spi_ce_high 
c9df			    NEXTW 
c9df			 
c9df			 
c9df			.SPIOb: 
c9df			 
c9df				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9df			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9df			 
c9df					if DEBUG_FORTH_WORDS_KEY 
c9df						DMARK "SPo" 
c9df						CALLMONITOR 
c9df					endif 
c9df					; get port 
c9df			 
c9df			 
c9df					; get byte to send 
c9df			 
c9df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9df			 
c9df			;		push hl    ; u1  
c9df			 
c9df					; destroy value TOS 
c9df			 
c9df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9df			 
c9df					; one value on hl get other one back 
c9df			 
c9df			;		pop hl   ; u2 - addr 
c9df			 
c9df					; TODO Send SPI byte 
c9df			 
c9df			;		push hl 
c9df			;		call spi_ce_low 
c9df			;		pop hl 
c9df					ld a, l 
c9df					call spi_send_byte 
c9df			;		call spi_ce_high 
c9df			 
c9df					NEXTW 
c9df			 
c9df			.SPII: 
c9df				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9df			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9df					if DEBUG_FORTH_WORDS_KEY 
c9df						DMARK "SPi" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					; TODO Get SPI byte 
c9df			 
c9df					call spi_read_byte 
c9df			 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "Si2" 
c9df						CALLMONITOR 
c9df					endif 
c9df					ld h, 0 
c9df					ld l, a 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "Si3" 
c9df						CALLMONITOR 
c9df					endif 
c9df					call forth_push_numhl 
c9df			 
c9df					NEXTW 
c9df			 
c9df			 
c9df			 
c9df			.SESEL: 
c9df				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9df			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9df					if DEBUG_FORTH_WORDS_KEY 
c9df						DMARK "BNK" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					ld a, 255 
c9df					ld (spi_cartdev), a 
c9df			 
c9df					; get bank 
c9df			 
c9df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9df			 
c9df			;		push hl 
c9df			 
c9df					; destroy value TOS 
c9df			 
c9df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9df			 
c9df					; one value on hl get other one back 
c9df			 
c9df			;		pop hl 
c9df			 
c9df			 
c9df					ld c, SPI_CE_HIGH 
c9df					ld b, '0'    ; human readable bank number 
c9df			 
c9df					ld a, l 
c9df			 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "BNK" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					; active low 
c9df			 
c9df					cp 0 
c9df					jr z, .bset 
c9df					cp 1 
c9df					jr nz, .b2 
c9df					res 0, c 
c9df					ld b, '1'    ; human readable bank number 
c9df			.b2:		cp 2 
c9df					jr nz, .b3 
c9df					res 1, c 
c9df					ld b, '2'    ; human readable bank number 
c9df			.b3:		cp 3 
c9df					jr nz, .b4 
c9df					res 2, c 
c9df					ld b, '3'    ; human readable bank number 
c9df			.b4:		cp 4 
c9df					jr nz, .b5 
c9df					res 3, c 
c9df					ld b, '4'    ; human readable bank number 
c9df			.b5:		cp 5 
c9df					jr nz, .bset 
c9df					res 4, c 
c9df					ld b, '5'    ; human readable bank number 
c9df			 
c9df			.bset: 
c9df					ld a, c 
c9df					ld (spi_device),a 
c9df					ld a, b 
c9df					ld (spi_device_id),a 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "BN2" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					; set default SPI clk pulse time as disabled for BANK use 
c9df			 
c9df					ld a, 0 
c9df					ld (spi_clktime), a 
c9df			 
c9df					NEXTW 
c9df			 
c9df			.CARTDEV: 
c9df				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9df			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9df					if DEBUG_FORTH_WORDS_KEY 
c9df						DMARK "CDV" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					; disable se storage bank selection 
c9df			 
c9df					ld a, SPI_CE_HIGH		; ce high 
c9df					ld (spi_device), a 
c9df			 
c9df					; get bank 
c9df			 
c9df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9df			 
c9df			;		push hl 
c9df			 
c9df					; destroy value TOS 
c9df			 
c9df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9df			 
c9df					; one value on hl get other one back 
c9df			 
c9df			;		pop hl 
c9df			 
c9df					; active low 
c9df			 
c9df					ld c, 255 
c9df			 
c9df					ld a, l 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "CDV" 
c9df						CALLMONITOR 
c9df					endif 
c9df					cp 0 
c9df					jr z, .cset 
c9df					cp 1 
c9df					jr nz, .c2 
c9df					res 0, c 
c9df			.c2:		cp 2 
c9df					jr nz, .c3 
c9df					res 1, c 
c9df			.c3:		cp 3 
c9df					jr nz, .c4 
c9df					res 2, c 
c9df			.c4:		cp 4 
c9df					jr nz, .c5 
c9df					res 3, c 
c9df			.c5:		cp 5 
c9df					jr nz, .c6 
c9df					res 4, c 
c9df			.c6:		cp 6 
c9df					jr nz, .c7 
c9df					res 5, c 
c9df			.c7:		cp 7 
c9df					jr nz, .c8 
c9df					res 6, c 
c9df			.c8:		cp 8 
c9df					jr nz, .cset 
c9df					res 7, c 
c9df			.cset:		ld a, c 
c9df					ld (spi_cartdev),a 
c9df			 
c9df					if DEBUG_FORTH_WORDS 
c9df						DMARK "CD2" 
c9df						CALLMONITOR 
c9df					endif 
c9df			 
c9df					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9df			 
c9df					ld a, $0a 
c9df					ld (spi_clktime), a 
c9df					NEXTW 
c9df			endif 
c9df			 
c9df			.ENDDEVICE: 
c9df			; eof 
c9df			 
# End of file forth_words_device.asm
c9df			 
c9df			; var handler 
c9df			 
c9df			 
c9df			.VARS: 
c9df				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9df 77				db WORD_SYS_CORE+99             
c9e0 90 ca			dw .V0            
c9e2 04				db 3 + 1 
c9e3 .. 00			db "VAR",0              
c9e7				endm 
# End of macro CWHEAD
c9e7			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9e7			;| 
c9e7			;| The variable name should consist of a single letter. e.g. "a" 
c9e7			;! If a full string is passed then only the first char is looked at 
c9e7			;| Any other char could exceed bounds checks!  
c9e7			 
c9e7					if DEBUG_FORTH_WORDS_KEY 
c9e7						DMARK "VAR" 
c9e7 f5				push af  
c9e8 3a fc c9			ld a, (.dmark)  
c9eb 32 6b ee			ld (debug_mark),a  
c9ee 3a fd c9			ld a, (.dmark+1)  
c9f1 32 6c ee			ld (debug_mark+1),a  
c9f4 3a fe c9			ld a, (.dmark+2)  
c9f7 32 6d ee			ld (debug_mark+2),a  
c9fa 18 03			jr .pastdmark  
c9fc ..			.dmark: db "VAR"  
c9ff f1			.pastdmark: pop af  
ca00			endm  
# End of macro DMARK
ca00						CALLMONITOR 
ca00 cd 6f ee			call debug_vector  
ca03				endm  
# End of macro CALLMONITOR
ca03					endif 
ca03			 
ca03					FORTH_DSP_VALUEHL 
ca03 cd 97 9c			call macro_dsp_valuehl 
ca06				endm 
# End of macro FORTH_DSP_VALUEHL
ca06			 
ca06 7e					ld a, (hl)    ; get first char on of the string 
ca07			 
ca07			 
ca07					if DEBUG_FORTH_WORDS 
ca07						DMARK "VR1" 
ca07 f5				push af  
ca08 3a 1c ca			ld a, (.dmark)  
ca0b 32 6b ee			ld (debug_mark),a  
ca0e 3a 1d ca			ld a, (.dmark+1)  
ca11 32 6c ee			ld (debug_mark+1),a  
ca14 3a 1e ca			ld a, (.dmark+2)  
ca17 32 6d ee			ld (debug_mark+2),a  
ca1a 18 03			jr .pastdmark  
ca1c ..			.dmark: db "VR1"  
ca1f f1			.pastdmark: pop af  
ca20			endm  
# End of macro DMARK
ca20						CALLMONITOR 
ca20 cd 6f ee			call debug_vector  
ca23				endm  
# End of macro CALLMONITOR
ca23					endif 
ca23					 
ca23 f5					push af	 
ca24					FORTH_DSP_POP 
ca24 cd 4f 9d			call macro_forth_dsp_pop 
ca27				endm 
# End of macro FORTH_DSP_POP
ca27 f1					pop af 
ca28			 
ca28					; convert to upper 
ca28			 
ca28 cd a1 8f				call to_upper 
ca2b					if DEBUG_FORTH_WORDS 
ca2b						DMARK "Vaa" 
ca2b f5				push af  
ca2c 3a 40 ca			ld a, (.dmark)  
ca2f 32 6b ee			ld (debug_mark),a  
ca32 3a 41 ca			ld a, (.dmark+1)  
ca35 32 6c ee			ld (debug_mark+1),a  
ca38 3a 42 ca			ld a, (.dmark+2)  
ca3b 32 6d ee			ld (debug_mark+2),a  
ca3e 18 03			jr .pastdmark  
ca40 ..			.dmark: db "Vaa"  
ca43 f1			.pastdmark: pop af  
ca44			endm  
# End of macro DMARK
ca44						CALLMONITOR 
ca44 cd 6f ee			call debug_vector  
ca47				endm  
# End of macro CALLMONITOR
ca47					endif 
ca47 06 41				ld b, 'A' 
ca49 90					sub b			; set offset 
ca4a					if DEBUG_FORTH_WORDS 
ca4a						DMARK "Vbb" 
ca4a f5				push af  
ca4b 3a 5f ca			ld a, (.dmark)  
ca4e 32 6b ee			ld (debug_mark),a  
ca51 3a 60 ca			ld a, (.dmark+1)  
ca54 32 6c ee			ld (debug_mark+1),a  
ca57 3a 61 ca			ld a, (.dmark+2)  
ca5a 32 6d ee			ld (debug_mark+2),a  
ca5d 18 03			jr .pastdmark  
ca5f ..			.dmark: db "Vbb"  
ca62 f1			.pastdmark: pop af  
ca63			endm  
# End of macro DMARK
ca63						CALLMONITOR 
ca63 cd 6f ee			call debug_vector  
ca66				endm  
# End of macro CALLMONITOR
ca66					endif 
ca66 cb 27				sla a  
ca68				 
ca68					 
ca68					if DEBUG_FORTH_WORDS 
ca68						DMARK "VR2" 
ca68 f5				push af  
ca69 3a 7d ca			ld a, (.dmark)  
ca6c 32 6b ee			ld (debug_mark),a  
ca6f 3a 7e ca			ld a, (.dmark+1)  
ca72 32 6c ee			ld (debug_mark+1),a  
ca75 3a 7f ca			ld a, (.dmark+2)  
ca78 32 6d ee			ld (debug_mark+2),a  
ca7b 18 03			jr .pastdmark  
ca7d ..			.dmark: db "VR2"  
ca80 f1			.pastdmark: pop af  
ca81			endm  
# End of macro DMARK
ca81						CALLMONITOR 
ca81 cd 6f ee			call debug_vector  
ca84				endm  
# End of macro CALLMONITOR
ca84					endif 
ca84			 
ca84 21 f4 e9				ld hl, cli_var_array2 
ca87 cd db 8c				call addatohl 
ca8a cd a0 9a				call forth_push_numhl 
ca8d			 
ca8d			 
ca8d				       NEXTW 
ca8d c3 4d 9e			jp macro_next 
ca90				endm 
# End of macro NEXTW
ca90			.V0: 
ca90				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca90 78				db WORD_SYS_CORE+100             
ca91 a8 ca			dw .V0Q            
ca93 04				db 3 + 1 
ca94 .. 00			db "V0!",0              
ca98				endm 
# End of macro CWHEAD
ca98			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca98			 
ca98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca98 cd 97 9c			call macro_dsp_valuehl 
ca9b				endm 
# End of macro FORTH_DSP_VALUEHL
ca9b			 
ca9b 11 28 ea				ld de, cli_var_array 
ca9e			 
ca9e eb					ex de, hl 
ca9f 73					ld (hl), e 
caa0 23					inc hl 
caa1 72					ld (hl), d 
caa2			 
caa2					; destroy value TOS 
caa2			 
caa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caa2 cd 4f 9d			call macro_forth_dsp_pop 
caa5				endm 
# End of macro FORTH_DSP_POP
caa5			 
caa5				       NEXTW 
caa5 c3 4d 9e			jp macro_next 
caa8				endm 
# End of macro NEXTW
caa8			.V0Q: 
caa8				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
caa8 79				db WORD_SYS_CORE+101             
caa9 b9 ca			dw .V1S            
caab 04				db 3 + 1 
caac .. 00			db "V0@",0              
cab0				endm 
# End of macro CWHEAD
cab0			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cab0 2a 28 ea				ld hl, (cli_var_array) 
cab3 cd a0 9a				call forth_push_numhl 
cab6			 
cab6				       NEXTW 
cab6 c3 4d 9e			jp macro_next 
cab9				endm 
# End of macro NEXTW
cab9			.V1S: 
cab9				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cab9 7a				db WORD_SYS_CORE+102             
caba d1 ca			dw .V1Q            
cabc 04				db 3 + 1 
cabd .. 00			db "V1!",0              
cac1				endm 
# End of macro CWHEAD
cac1			;| V1! ( u1 -- )  Store value to v1 | DONE 
cac1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cac1 cd 97 9c			call macro_dsp_valuehl 
cac4				endm 
# End of macro FORTH_DSP_VALUEHL
cac4			 
cac4 11 2a ea				ld de, cli_var_array+2 
cac7				 
cac7 eb					ex de, hl 
cac8 73					ld (hl), e 
cac9 23					inc hl 
caca 72					ld (hl), d 
cacb			 
cacb					; destroy value TOS 
cacb			 
cacb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cacb cd 4f 9d			call macro_forth_dsp_pop 
cace				endm 
# End of macro FORTH_DSP_POP
cace				       NEXTW 
cace c3 4d 9e			jp macro_next 
cad1				endm 
# End of macro NEXTW
cad1			.V1Q: 
cad1				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cad1 7b				db WORD_SYS_CORE+103             
cad2 e2 ca			dw .V2S            
cad4 04				db 3 + 1 
cad5 .. 00			db "V1@",0              
cad9				endm 
# End of macro CWHEAD
cad9			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cad9 2a 2a ea				ld hl, (cli_var_array+2) 
cadc cd a0 9a				call forth_push_numhl 
cadf				       NEXTW 
cadf c3 4d 9e			jp macro_next 
cae2				endm 
# End of macro NEXTW
cae2			.V2S: 
cae2				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cae2 7c				db WORD_SYS_CORE+104             
cae3 fa ca			dw .V2Q            
cae5 04				db 3 + 1 
cae6 .. 00			db "V2!",0              
caea				endm 
# End of macro CWHEAD
caea			;| V2! ( u1 -- )  Store value to v2 | DONE 
caea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caea cd 97 9c			call macro_dsp_valuehl 
caed				endm 
# End of macro FORTH_DSP_VALUEHL
caed			 
caed 11 2c ea				ld de, cli_var_array+4 
caf0				 
caf0 eb					ex de, hl 
caf1 73					ld (hl), e 
caf2 23					inc hl 
caf3 72					ld (hl), d 
caf4			 
caf4					; destroy value TOS 
caf4			 
caf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caf4 cd 4f 9d			call macro_forth_dsp_pop 
caf7				endm 
# End of macro FORTH_DSP_POP
caf7				       NEXTW 
caf7 c3 4d 9e			jp macro_next 
cafa				endm 
# End of macro NEXTW
cafa			.V2Q: 
cafa				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cafa 7d				db WORD_SYS_CORE+105             
cafb 0b cb			dw .V3S            
cafd 04				db 3 + 1 
cafe .. 00			db "V2@",0              
cb02				endm 
# End of macro CWHEAD
cb02			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb02 2a 2c ea				ld hl, (cli_var_array+4) 
cb05 cd a0 9a				call forth_push_numhl 
cb08				       NEXTW 
cb08 c3 4d 9e			jp macro_next 
cb0b				endm 
# End of macro NEXTW
cb0b			.V3S: 
cb0b				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb0b 7c				db WORD_SYS_CORE+104             
cb0c 23 cb			dw .V3Q            
cb0e 04				db 3 + 1 
cb0f .. 00			db "V3!",0              
cb13				endm 
# End of macro CWHEAD
cb13			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb13 cd 97 9c			call macro_dsp_valuehl 
cb16				endm 
# End of macro FORTH_DSP_VALUEHL
cb16			 
cb16 11 2e ea				ld de, cli_var_array+6 
cb19				 
cb19 eb					ex de, hl 
cb1a 73					ld (hl), e 
cb1b 23					inc hl 
cb1c 72					ld (hl), d 
cb1d			 
cb1d					; destroy value TOS 
cb1d			 
cb1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb1d cd 4f 9d			call macro_forth_dsp_pop 
cb20				endm 
# End of macro FORTH_DSP_POP
cb20				       NEXTW 
cb20 c3 4d 9e			jp macro_next 
cb23				endm 
# End of macro NEXTW
cb23			.V3Q: 
cb23				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb23 7d				db WORD_SYS_CORE+105             
cb24 34 cb			dw .END            
cb26 04				db 3 + 1 
cb27 .. 00			db "V3@",0              
cb2b				endm 
# End of macro CWHEAD
cb2b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb2b 2a 2e ea				ld hl, (cli_var_array+6) 
cb2e cd a0 9a				call forth_push_numhl 
cb31				       NEXTW 
cb31 c3 4d 9e			jp macro_next 
cb34				endm 
# End of macro NEXTW
cb34			 
cb34			 
cb34			 
cb34			 
cb34			 
cb34			; end of dict marker 
cb34			 
cb34 00			.END:    db WORD_SYS_END 
cb35 00 00			dw 0 
cb37 00				db 0 
cb38			 
cb38			; use to jp here for user dict words to save on macro expansion  
cb38			 
cb38			user_dict_next: 
cb38				NEXTW 
cb38 c3 4d 9e			jp macro_next 
cb3b				endm 
# End of macro NEXTW
cb3b			 
cb3b			 
cb3b			user_exec: 
cb3b				;    ld hl, <word code> 
cb3b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb3b				;    call forthexec 
cb3b				;    jp user_dict_next   (NEXT) 
cb3b			        ;    <word code bytes> 
cb3b eb				ex de, hl 
cb3c 2a c2 e5			ld hl,(os_tok_ptr) 
cb3f				 
cb3f				FORTH_RSP_NEXT 
cb3f cd 47 9a			call macro_forth_rsp_next 
cb42				endm 
# End of macro FORTH_RSP_NEXT
cb42			 
cb42			if DEBUG_FORTH_UWORD 
cb42						DMARK "UEX" 
cb42 f5				push af  
cb43 3a 57 cb			ld a, (.dmark)  
cb46 32 6b ee			ld (debug_mark),a  
cb49 3a 58 cb			ld a, (.dmark+1)  
cb4c 32 6c ee			ld (debug_mark+1),a  
cb4f 3a 59 cb			ld a, (.dmark+2)  
cb52 32 6d ee			ld (debug_mark+2),a  
cb55 18 03			jr .pastdmark  
cb57 ..			.dmark: db "UEX"  
cb5a f1			.pastdmark: pop af  
cb5b			endm  
# End of macro DMARK
cb5b				CALLMONITOR 
cb5b cd 6f ee			call debug_vector  
cb5e				endm  
# End of macro CALLMONITOR
cb5e			endif 
cb5e			 
cb5e			 
cb5e			 
cb5e eb				ex de, hl 
cb5f 22 c2 e5			ld (os_tok_ptr), hl 
cb62				 
cb62				; Don't use next - Skips the first word in uword. 
cb62			 
cb62 c3 de 9e			jp exec1 
cb65			;	NEXT 
cb65			 
cb65			 
cb65			; eof 
# End of file forth_wordsv4.asm
cb65			endif 
cb65			;;;;;;;;;;;;;; Debug code 
cb65			 
cb65			 
cb65			;if DEBUG_FORTH_PARSE 
cb65 .. 00		.nowordfound: db "No match",0 
cb6e .. 00		.compword:	db "Comparing word ",0 
cb7e .. 00		.nextwordat:	db "Next word at",0 
cb8b .. 00		.charmatch:	db "Char match",0 
cb96			;endif 
cb96			if DEBUG_FORTH_JP 
cb96			.foundword:	db "Word match. Exec..",0 
cb96			endif 
cb96			;if DEBUG_FORTH_PUSH 
cb96 .. 00		.enddict:	db "Dict end. Push.",0 
cba6 .. 00		.push_str:	db "Pushing string",0 
cbb5 .. 00		.push_num:	db "Pushing number",0 
cbc4 .. 00		.data_sp:	db "SP:",0 
cbc8 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbda .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbec .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbfe			;endif 
cbfe			;if DEBUG_FORTH_MALLOC 
cbfe .. 00		.push_malloc:	db "Malloc address",0 
cc0d			;endif 
cc0d			 
cc0d			 
cc0d			 
cc0d			; display malloc address and current data stack pointer  
cc0d			 
cc0d			malloc_error: 
cc0d d5				push de 
cc0e f5				push af 
cc0f e5				push hl 
cc10 cd ae 8a			call clear_display 
cc13 11 33 cc			ld de, .mallocerr 
cc16 3e 00			ld a,0 
cc18			;	ld de,os_word_scratch 
cc18 cd c1 8a			call str_at_display 
cc1b 3e 11			ld a, display_row_1+17 
cc1d 11 6b ee			ld de, debug_mark 
cc20 cd c1 8a			call str_at_display 
cc23 cd d1 8a			call update_display 
cc26				;call break_point_state 
cc26 cd 28 e4			call cin_wait 
cc29			 
cc29			;	ld a, ' ' 
cc29			;	ld (os_view_disable), a 
cc29 cd 36 94			call bp_on 
cc2c e1				pop hl 
cc2d f1				pop af 
cc2e d1				pop de	 
cc2f				CALLMONITOR 
cc2f cd 6f ee			call debug_vector  
cc32				endm  
# End of macro CALLMONITOR
cc32 c9				ret 
cc33			 
cc33 .. 00		.mallocerr: 	db "Malloc Error",0 
cc40			;if DEBUG_FORTH_PUSH 
cc40			display_data_sp: 
cc40 f5				push af 
cc41			 
cc41				; see if disabled 
cc41			 
cc41			 
cc41 3a 6f ee			ld a, (debug_vector) 
cc44 fe c9			cp $C9  ; RET 
cc46				;ld a, (os_view_disable) 
cc46				;cp '*' 
cc46 28 67			jr z, .skipdsp 
cc48			 
cc48 e5				push hl 
cc49 e5				push hl 
cc4a e5			push hl 
cc4b cd ae 8a			call clear_display 
cc4e e1			pop hl 
cc4f 7c				ld a,h 
cc50 21 c6 e5			ld hl, os_word_scratch 
cc53 cd 35 8f			call hexout 
cc56 e1				pop hl 
cc57 7d				ld a,l 
cc58 21 c8 e5			ld hl, os_word_scratch+2 
cc5b cd 35 8f			call hexout 
cc5e 21 ca e5			ld hl, os_word_scratch+4 
cc61 3e 00			ld a,0 
cc63 77				ld (hl),a 
cc64 11 c6 e5			ld de,os_word_scratch 
cc67 3e 28				ld a, display_row_2 
cc69 cd c1 8a				call str_at_display 
cc6c 11 c8 cb			ld de, .wordinhl 
cc6f 3e 00			ld a, display_row_1 
cc71			 
cc71 cd c1 8a				call str_at_display 
cc74 11 6b ee			ld de, debug_mark 
cc77 3e 11			ld a, display_row_1+17 
cc79			 
cc79 cd c1 8a				call str_at_display 
cc7c			 
cc7c				; display current data stack pointer 
cc7c 11 c4 cb			ld de,.data_sp 
cc7f 3e 30				ld a, display_row_2 + 8 
cc81 cd c1 8a				call str_at_display 
cc84			 
cc84 2a ee e9			ld hl,(cli_data_sp) 
cc87 e5				push hl 
cc88 7c				ld a,h 
cc89 21 c6 e5			ld hl, os_word_scratch 
cc8c cd 35 8f			call hexout 
cc8f e1				pop hl 
cc90 7d				ld a,l 
cc91 21 c8 e5			ld hl, os_word_scratch+2 
cc94 cd 35 8f			call hexout 
cc97 21 ca e5			ld hl, os_word_scratch+4 
cc9a 3e 00			ld a,0 
cc9c 77				ld (hl),a 
cc9d 11 c6 e5			ld de,os_word_scratch 
cca0 3e 33				ld a, display_row_2 + 11 
cca2 cd c1 8a				call str_at_display 
cca5			 
cca5			 
cca5 cd d1 8a			call update_display 
cca8 cd f1 89			call delay1s 
ccab cd f1 89			call delay1s 
ccae e1				pop hl 
ccaf			.skipdsp: 
ccaf f1				pop af 
ccb0 c9				ret 
ccb1			 
ccb1			display_data_malloc: 
ccb1			 
ccb1 f5				push af 
ccb2 e5				push hl 
ccb3 e5				push hl 
ccb4 e5			push hl 
ccb5 cd ae 8a			call clear_display 
ccb8 e1			pop hl 
ccb9 7c				ld a,h 
ccba 21 c6 e5			ld hl, os_word_scratch 
ccbd cd 35 8f			call hexout 
ccc0 e1				pop hl 
ccc1 7d				ld a,l 
ccc2 21 c8 e5			ld hl, os_word_scratch+2 
ccc5 cd 35 8f			call hexout 
ccc8 21 ca e5			ld hl, os_word_scratch+4 
cccb 3e 00			ld a,0 
cccd 77				ld (hl),a 
ccce 11 c6 e5			ld de,os_word_scratch 
ccd1 3e 28				ld a, display_row_2 
ccd3 cd c1 8a				call str_at_display 
ccd6 11 fe cb			ld de, .push_malloc 
ccd9 3e 00			ld a, display_row_1 
ccdb			 
ccdb cd c1 8a				call str_at_display 
ccde			 
ccde				; display current data stack pointer 
ccde 11 c4 cb			ld de,.data_sp 
cce1 3e 30				ld a, display_row_2 + 8 
cce3 cd c1 8a				call str_at_display 
cce6			 
cce6 2a ee e9			ld hl,(cli_data_sp) 
cce9 e5				push hl 
ccea 7c				ld a,h 
cceb 21 c6 e5			ld hl, os_word_scratch 
ccee cd 35 8f			call hexout 
ccf1 e1				pop hl 
ccf2 7d				ld a,l 
ccf3 21 c8 e5			ld hl, os_word_scratch+2 
ccf6 cd 35 8f			call hexout 
ccf9 21 ca e5			ld hl, os_word_scratch+4 
ccfc 3e 00			ld a,0 
ccfe 77				ld (hl),a 
ccff 11 c6 e5			ld de,os_word_scratch 
cd02 3e 33				ld a, display_row_2 + 11 
cd04 cd c1 8a				call str_at_display 
cd07			 
cd07 cd d1 8a			call update_display 
cd0a cd f1 89			call delay1s 
cd0d cd f1 89			call delay1s 
cd10 e1				pop hl 
cd11 f1				pop af 
cd12 c9				ret 
cd13			;endif 
cd13			 
cd13			include "forth_autostart.asm" 
cd13			; list of commands to perform at system start up 
cd13			 
cd13			startcmds: 
cd13			;	dw test11 
cd13			;	dw test12 
cd13			;	dw test13 
cd13			;	dw test14 
cd13			;	dw test15 
cd13			;	dw test16 
cd13			;	dw test17 
cd13			;	dw ifthtest1 
cd13			;	dw ifthtest2 
cd13			;	dw ifthtest3 
cd13			;	dw mmtest1 
cd13			;	dw mmtest2 
cd13			;	dw mmtest3 
cd13			;	dw mmtest4 
cd13			;	dw mmtest5 
cd13			;	dw mmtest6 
cd13			;	dw iftest1 
cd13			;	dw iftest2 
cd13			;	dw iftest3 
cd13			;	dw looptest1 
cd13			;	dw looptest2 
cd13			;	dw test1 
cd13			;	dw test2 
cd13			;	dw test3 
cd13			;	dw test4 
cd13			;	dw game2r 
cd13			;	dw game2b1 
cd13			;	dw game2b2 
cd13			 
cd13				; start up words that are actually useful 
cd13			 
cd13			;    dw spi1 
cd13			;    dw spi2 
cd13			;    dw spi3 
cd13			;    dw spi4 
cd13			;    dw spi5 
cd13			;    dw spi6 
cd13			;    dw spi7 
cd13			; 
cd13			;    dw spi8 
cd13			;    dw spi9 
cd13			;    dw spi10 
cd13			 
cd13			; file editor 
cd13			;	dw edit1 
cd13			;	dw edit2 
cd13			;	dw edit3 
cd13			 
cd13			;	dw longread 
cd13 3d d1			dw clrstack 
cd15 71 d1			dw type 
cd17			;	dw stest 
cd17 96 d1			dw strncpy 
cd19			;	dw list 
cd19 f7 d1			dw start1 
cd1b 07 d2			dw start2 
cd1d			;	dw start3 
cd1d			;	dw start3b 
cd1d			;	dw start3c 
cd1d			 
cd1d				; (unit) testing words 
cd1d			 
cd1d			;	dw mtesta 
cd1d			;	dw mtestb 
cd1d			;	dw mtestc 
cd1d			;	dw mtestd 
cd1d			;	dw mteste 
cd1d			 
cd1d				; demo/game words 
cd1d			 
cd1d			;        dw game3w 
cd1d			;        dw game3p 
cd1d			;        dw game3sc 
cd1d			;        dw game3vsi 
cd1d			;        dw game3vs 
cd1d				 
cd1d 60 dc			dw game2b 
cd1f ce dc			dw game2bf 
cd21 18 dd			dw game2mba 
cd23 ae dd			dw game2mbas 
cd25 f0 dd			dw game2mb 
cd27			 
cd27 21 d9			dw game1 
cd29 32 d9			dw game1a 
cd2b 94 d9			dw game1b 
cd2d c9 d9			dw game1c 
cd2f ff d9			dw game1d 
cd31 30 da			dw game1s 
cd33 44 da			dw game1t 
cd35 59 da			dw game1f 
cd37 8d da			dw game1z 
cd39 d1 da			dw game1zz 
cd3b			 
cd3b 3b d7			dw test5 
cd3d 73 d7			dw test6 
cd3f ab d7			dw test7 
cd41 bf d7			dw test8 
cd43 eb d7			dw test9 
cd45 01 d8			dw test10 
cd47				 
cd47 a8 db		        dw ssv5 
cd49 8c db		        dw ssv4 
cd4b 70 db		        dw ssv3 
cd4d 3a db		        dw ssv2 
cd4f c1 db		        dw ssv1 
cd51 09 dc		        dw ssv1cpm 
cd53			;	dw keyup 
cd53			;	dw keydown 
cd53			;	dw keyleft 
cd53			;	dw keyright 
cd53			;	dw 	keyf1 
cd53			;	dw keyf2 
cd53			;	dw keyf3 
cd53			;	dw keyf4 
cd53			;	dw keyf5 
cd53			;	dw keyf6 
cd53			;	dw keyf7 
cd53			;	dw keyf8 
cd53			;	dw keyf9 
cd53			;	dw keyf10 
cd53			;	dw keyf11 
cd53			;	dw keyf12 
cd53			;	dw keytab 
cd53			;	dw keycr 
cd53			;	dw keyhome 
cd53			;	dw keyend 
cd53			;	dw keybs 
cd53 00 00			db 0, 0	 
cd55			 
cd55			 
cd55			; File Editor 
cd55			 
cd55			; ( id - ) use 'e' to edit the displayed line 
cd55 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd76 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdab			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdab .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cde3			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cde3			 
cde3			; SPI Net support words 
cde3			 
cde3			; v0! = node to send to 
cde3			; ( str count - ) 
cde3 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce3c			 
ce3c			; spiputc ( char node - ) 
ce3c .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce70			; spiputc ( u node - ) 
ce70 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
ce9e			 
ce9e			; spigetc ( - n ) 
ce9e .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
cec7			 
cec7			; getnode ( - n ) 
cec7 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cef4			 
cef4			; ( str node - )  
cef4 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf5a			; store string ( str i - ) 
cf5a			 
cf5a			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf5a .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfaf			 
cfaf			; get string ( addr i -  )    TO FIX 
cfaf			 
cfaf .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d007			 
d007			 
d007			; NETCHAT (TODO) 
d007			; Program to allow two nodes to chat with eachother 
d007			; 
d007			; v0 - target node 
d007			;  
d007			; accept input at 0,0 
d007			; if input is string send spitype to target node 
d007			; starting at row 2,0 , while spigetchr is not zero ->  
d007			; 
d007			; 
d007			; TODO add paging of get request 
d007			 
d007			; ( node - ) 
d007 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d026 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d07e .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0f6			 
d0f6			 
d0f6			; Long read of currently open file 
d0f6 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d13d			 
d13d			; clear stack  
d13d			 
d13d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d171			 
d171			; type ( addr count - ) 
d171 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d196			 
d196			; some direct memory words 
d196			; strncpy ( len t f -- t ) 
d196			 
d196 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1f7			 
d1f7 .. 00		start1:     	db ": bpon $00 bp ;",0 
d207 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d218 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d293 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2f3			 
d2f3			 
d2f3			; a handy word to list items on the stack 
d2f3			 
d2f3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d35d			 
d35d			 
d35d			; test stack  
d35d			; rnd8 stest 
d35d			 
d35d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3d4			 
d3d4			; random malloc and free cycles 
d3d4			 
d3d4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d489			 
d489			; fixed malloc and free cycles 
d489			 
d489 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d52c			 
d52c			; fixed double string push and drop cycle  
d52c			 
d52c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5e1			 
d5e1			; consistent fixed string push and drop cycle  
d5e1			 
d5e1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d685			 
d685 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d73b			 
d73b			;test1:		db ": aa 1 2 3 ;", 0 
d73b			;test2:     	db "111 aa 888 999",0 
d73b			;test3:     	db ": bb 77 ;",0 
d73b			;test4:     	db "$02 $01 do i . loop bb",0 
d73b			 
d73b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d773 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7ab .. 00		test7:     	db ": box hline vline ;",0 
d7bf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7eb .. 00		test9:     	db ": sw $01 adsp world ;",0 
d801 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d826 .. 00		test11:     	db "hello create .",0 
d835 .. 00		test12:     	db "hello2 create .",0 
d845			 
d845			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d845			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d845			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d845			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d845			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d845			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d845			 
d845			;iftest1:     	db "$0001 IF cls .",0 
d845			;iftest2:     	db "$0000 IF cls .",0 
d845			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d845			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d845			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d845			 
d845			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d845			 
d845			 
d845 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d869 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d899 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d8be .. 00		sound4: db ": cha $00 ; ",0 
d8cb .. 00		sound5: db ": chb $20 ; ",0 
d8d8 .. 00		sound6: db ": chc $40 ; ",0 
d8e5 .. 00		sound7: db ": chd $60 ; ",0 
d8f2 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d90a .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d921			 
d921			 
d921			 
d921			 
d921			; a small guess the number game 
d921			 
d921 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d932 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d994			 
d994 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d9c9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d9ff .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
da30 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da44 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da59 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da8d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dad1			 
dad1			; Using 'ga' save a high score across multiple runs using external storage 
dad1			 
dad1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
db3a			 
db3a			 
db3a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
db3a			 
db3a			; simple screen saver to test code memory reuse to destruction 
db3a			 
db3a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db70 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db8c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dba8 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dbc1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc09 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc60			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc60			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc60			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc60			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc60			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc60			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc60			 
dc60			 
dc60			 
dc60			; minesweeper/battleship finding game 
dc60			; draws a game board of random ship/mine positions 
dc60			; user enters coords to see if it hits on 
dc60			; game ends when all are hit 
dc60			; when hit or miss says how many may be in the area 
dc60			 
dc60			; setup the game board and then hide it 
dc60 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dcce .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dd18			; prompt for where to target 
dd18 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
ddae .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ddd3			; TODO see if the entered coords hits or misses pushes char hit of miss 
ddd3 .. 00		game2mbht:      db ": mbckht nop ;",0 
dde2 .. 00		game2mbms:      db ": mbcms nop ;",0 
ddf0			; TODO how many might be near by 
ddf0 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de6d			 
de6d			; Game 3 
de6d			 
de6d			; Vert scroller ski game - avoid the trees! 
de6d			 
de6d			; v0 score (ie turns) 
de6d			; v1 player pos 
de6d			; v2 left wall 
de6d			; v3 right wall 
de6d			 
de6d			; Draw side walls randomly 
de6d			 
de6d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de9b			 
de9b			; Draw player 
de9b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
deb9			 
deb9			; TODO Get Key 
deb9			 
deb9			; TODO Move left right 
deb9			 
deb9			; scroll and move walls a bit 
deb9			 
deb9 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
deea			 
deea			; main game loop 
deea			 
deea .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df16 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df55			 
df55			; key board defs 
df55			 
df55 .. 00		keyup:       db ": keyup $05 ;",0 
df63 .. 00		keydown:       db ": keydown $0a ;",0 
df73 .. 00		keyleft:       db ": keyleft $0b ;",0 
df83 .. 00		keyright:       db ": keyright $0c ;",0 
df94 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dfa2 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dfb0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dfbe .. 00		keyf4:       db ": keyf4 $13 ;",0 
dfcc .. 00		keyf5:       db ": keyf5 $14 ;",0 
dfda .. 00		keyf6:       db ": keyf6 $15 ;",0 
dfe8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dff6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
e004 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e012 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e021 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e030 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e03f			 
e03f .. 00		keytab:       db ": keytab $09 ;",0 
e04e .. 00		keycr:       db ": keycr $0d ;",0 
e05c .. 00		keyhome:       db ": keyhome $0e ;",0 
e06c .. 00		keyend:       db ": keyend $0f ;",0 
e07b .. 00		keybs:       db ": keybs $08 ;",0 
e089			 
e089			   
e089			 
e089			 
e089			 
e089			; eof 
# End of file forth_autostart.asm
e089			 
e089			 
e089			 
e089			; stack over and underflow checks 
e089			 
e089			; init the words to detect the under/overflow 
e089			 
e089			chk_stk_init: 
e089				; a vague random number to check so we dont get any "lucky" hits 
e089 3e 2d			ld a, 45 
e08b 6f				ld l, a 
e08c 00				nop 
e08d 3e 17			ld a, 23 
e08f 67				ld h, a 
e090			 
e090 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e093			 
e093			;	ld (chk_stund), hl	; stack points.... 
e093 22 00 ef			ld (chk_stovr), hl 
e096 22 ec e9			ld (chk_ret_und), hl 
e099 22 aa e9			ld (chk_ret_ovr), hl 
e09c 22 28 e9			ld (chk_loop_ovr), hl 
e09f 22 26 e8			ld (chk_data_ovr), hl 
e0a2 c9				ret 
e0a3				 
e0a3			check_stacks: 
e0a3				; check all stack words 
e0a3			 
e0a3 e5				push hl 
e0a4 d5				push de 
e0a5			 
e0a5			;	ld de,(chk_word) 
e0a5			;	ld hl, (chk_stund)	; stack points.... 
e0a5			;	if DEBUG_STK_FAULT 
e0a5			;		DMARK "FAa" 
e0a5			;		CALLMONITOR 
e0a5			;	endif 
e0a5			;	call cmp16 
e0a5			;	jp z, .chk_faulta 
e0a5			; 
e0a5			;	ld de, sfaultsu 
e0a5			;	jp .chk_fault 
e0a5			 
e0a5 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e0a8 ed 5b 9d e2		ld de,(chk_word) 
e0ac				if DEBUG_STK_FAULT 
e0ac					DMARK "FAb" 
e0ac					CALLMONITOR 
e0ac				endif 
e0ac cd f9 8c			call cmp16 
e0af 28 06			jr z, .chk_fault1 
e0b1 11 52 e1			ld de, sfaultso 
e0b4 c3 06 e1			jp .chk_fault 
e0b7			.chk_fault1:  
e0b7 2a ec e9			ld hl, (chk_ret_und) 
e0ba ed 5b 9d e2		ld de,(chk_word) 
e0be				if DEBUG_STK_FAULT 
e0be					DMARK "FAU" 
e0be					CALLMONITOR 
e0be				endif 
e0be cd f9 8c			call cmp16 
e0c1 ca ca e0			jp z, .chk_fault2 
e0c4 11 62 e1			ld de, sfaultru 
e0c7 c3 06 e1			jp .chk_fault 
e0ca			.chk_fault2:  
e0ca 2a aa e9			ld hl, (chk_ret_ovr) 
e0cd ed 5b 9d e2		ld de,(chk_word) 
e0d1				if DEBUG_STK_FAULT 
e0d1					DMARK "FA1" 
e0d1					CALLMONITOR 
e0d1				endif 
e0d1 cd f9 8c			call cmp16 
e0d4 ca dd e0			jp z, .chk_fault3 
e0d7 11 70 e1			ld de, sfaultro 
e0da c3 06 e1			jp .chk_fault 
e0dd			.chk_fault3:  
e0dd 2a 28 e9			ld hl, (chk_loop_ovr) 
e0e0 ed 5b 9d e2		ld de,(chk_word) 
e0e4				if DEBUG_STK_FAULT 
e0e4					DMARK "FA2" 
e0e4					CALLMONITOR 
e0e4				endif 
e0e4 cd f9 8c			call cmp16 
e0e7 ca f0 e0			jp z, .chk_fault4 
e0ea 11 8a e1			ld de, sfaultlo 
e0ed c3 06 e1			jp .chk_fault 
e0f0			.chk_fault4:  
e0f0 2a 26 e8			ld hl, (chk_data_ovr) 
e0f3 ed 5b 9d e2		ld de,(chk_word) 
e0f7				if DEBUG_STK_FAULT 
e0f7					DMARK "FA3" 
e0f7					CALLMONITOR 
e0f7				endif 
e0f7 cd f9 8c			call cmp16 
e0fa ca 03 e1			jp z, .chk_fault5 
e0fd 11 a4 e1			ld de, sfaultdo 
e100 c3 06 e1			jp .chk_fault 
e103			 
e103			 
e103			.chk_fault5:  
e103 d1				pop de 
e104 e1				pop hl 
e105			 
e105 c9				ret 
e106			 
e106 cd ae 8a		.chk_fault: 	call clear_display 
e109 3e 28				ld a, display_row_2 
e10b cd c1 8a				call str_at_display 
e10e 11 34 e1				   ld de, .stackfault 
e111 3e 00				ld a, display_row_1 
e113 cd c1 8a				call str_at_display 
e116 11 6b ee				    ld de, debug_mark 
e119 3e 11				ld a, display_row_1+17 
e11b cd c1 8a				call str_at_display 
e11e cd d1 8a				call update_display 
e121			 
e121				; prompt before entering montior for investigating issue 
e121			 
e121 3e 78			ld a, display_row_4 
e123 11 92 97			ld de, endprog 
e126			 
e126 cd d1 8a			call update_display		 
e129			 
e129 cd 18 9a			call next_page_prompt 
e12c			 
e12c d1				pop de 
e12d e1				pop hl 
e12e cd e6 97				call monitor 
e131 c3 ef 96				jp warmstart 
e134					;jp 0 
e134					;halt 
e134			 
e134			 
e134			 
e134 .. 00		.stackfault: 	db "Stack fault:",0 
e141			 
e141 .. 00		sfaultsu: 	db	"Stack under flow",0 
e152 .. 00		sfaultso: 	db	"Stack over flow",0 
e162 .. 00		sfaultru:	db "RTS underflow",0 
e170 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e18a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e1a4 .. 00		sfaultdo:	db "DTS overflow", 0 
e1b1			 
e1b1			 
e1b1			fault_dsp_under: 
e1b1 11 c3 e1			ld de, .dsp_under 
e1b4 c3 73 e2			jp .show_fault 
e1b7			 
e1b7			fault_rsp_under: 
e1b7 11 d1 e1			ld de, .rsp_under 
e1ba c3 73 e2			jp .show_fault 
e1bd			fault_loop_under: 
e1bd 11 df e1			ld de, .loop_under 
e1c0 c3 73 e2			jp .show_fault 
e1c3			 
e1c3 .. 00		.dsp_under: db "DSP Underflow",0 
e1d1 .. 00		.rsp_under: db "RSP Underflow",0 
e1df .. 00		.loop_under: db "LOOP Underflow",0 
e1ee			 
e1ee			 
e1ee d5			type_faultn: 	push de 
e1ef e5					push hl 
e1f0 cd ae 8a				call clear_display 
e1f3 11 1a e2				   ld de, .typefaultn 
e1f6 3e 00				ld a, display_row_1 
e1f8 cd c1 8a				call str_at_display 
e1fb 11 6b ee				    ld de, debug_mark 
e1fe 3e 11				ld a, display_row_1+17 
e200 cd c1 8a				call str_at_display 
e203 cd d1 8a				call update_display 
e206			 
e206				; prompt before entering montior for investigating issue 
e206			 
e206 3e 78			ld a, display_row_4 
e208 11 92 97			ld de, endprog 
e20b			 
e20b cd d1 8a			call update_display		 
e20e			 
e20e cd 18 9a			call next_page_prompt 
e211			 
e211 e5					push hl 
e212 d5					push de 
e213 cd e6 97				call monitor 
e216 c3 ef 96				jp warmstart 
e219 76					halt 
e21a			 
e21a			 
e21a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e231			 
e231 d5			type_faults: 	push de 
e232 e5					push hl 
e233 cd ae 8a				call clear_display 
e236 11 5c e2				   ld de, .typefaults 
e239 3e 00				ld a, display_row_1 
e23b cd c1 8a				call str_at_display 
e23e 11 6b ee				    ld de, debug_mark 
e241 3e 11				ld a, display_row_1+17 
e243 cd c1 8a				call str_at_display 
e246 cd d1 8a				call update_display 
e249			 
e249				; prompt before entering montior for investigating issue 
e249			 
e249 3e 78			ld a, display_row_4 
e24b 11 92 97			ld de, endprog 
e24e			 
e24e cd d1 8a			call update_display		 
e251			 
e251 cd 18 9a			call next_page_prompt 
e254			 
e254 e1					pop hl 
e255 d1					pop de 
e256 cd e6 97				call monitor 
e259 c3 ef 96				jp warmstart 
e25c			 
e25c			 
e25c .. 00		.typefaults: db "STR Type Expected TOS!",0 
e273			 
e273			.show_fault: 	 
e273 d5					push de 
e274 cd ae 8a				call clear_display 
e277 d1					pop de 
e278 3e 00				ld a, display_row_1 
e27a cd c1 8a				call str_at_display 
e27d 11 6b ee				    ld de, debug_mark 
e280 3e 11				ld a, display_row_1+17 
e282 cd c1 8a				call str_at_display 
e285 cd d1 8a				call update_display 
e288			 
e288				; prompt before entering montior for investigating issue 
e288			 
e288 3e 78			ld a, display_row_4 
e28a 11 92 97			ld de, endprog 
e28d			 
e28d cd d1 8a			call update_display		 
e290			 
e290 cd 18 9a			call next_page_prompt 
e293			 
e293 e1					pop hl 
e294 d1					pop de 
e295 cd e6 97				call monitor 
e298			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e298			; TODO Make optional fault restart to cli or warm boot? 
e298					;jp warmstart 
e298 c3 39 97				jp cli 
e29b 76					halt 
e29c			 
e29c			; handle the auto run of code from files in storage 
e29c			 
e29c			 
e29c			include "forth_startup.asm" 
e29c			; Which startup method to use? 
e29c			; 
e29c			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e29c			; followed by loading of a list of scripts in eeprom 
e29c			 
e29c			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e29c			; from eeprom 
e29c			 
e29c			; Select with define in main stubs 
e29c			 
e29c			if STARTUP_V1 
e29c				include "forth_startupv1.asm" 
e29c			; Startup script loading version 1 
e29c			 
e29c			; If SE storage is available first stage is to use the selected file 
e29c			; then go through the eeprom list 
e29c			 
e29c .. 00		sprompt1: db "Startup load...",0 
e2ac .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2c2			 
e2c2			 
e2c2			 
e2c2			 
e2c2			forth_startup: 
e2c2 21 13 cd			ld hl, startcmds 
e2c5 3e 00			ld a, 0 
e2c7 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2ca			 
e2ca e5			.start1:	push hl 
e2cb cd ae 8a			call clear_display 
e2ce 11 9c e2			ld de, sprompt1 
e2d1 3e 00		        ld a, display_row_1 
e2d3 cd c1 8a			call str_at_display 
e2d6 11 ac e2			ld de, sprompt2 
e2d9 3e 28		        ld a, display_row_2 
e2db cd c1 8a			call str_at_display 
e2de e1				pop hl 
e2df e5				push hl 
e2e0 5e				ld e,(hl) 
e2e1 23				inc hl 
e2e2 56				ld d,(hl) 
e2e3 3e 50		        ld a, display_row_3 
e2e5 cd c1 8a			call str_at_display 
e2e8 cd d1 8a			call update_display 
e2eb			 
e2eb			 
e2eb 3a e7 e6			ld a, (os_last_cmd) 
e2ee fe 00			cp 0 
e2f0 28 05			jr z, .startprompt 
e2f2 cd e5 89			call delay250ms 
e2f5 18 24			jr .startdo 
e2f7				 
e2f7				 
e2f7			 
e2f7			.startprompt: 
e2f7			 
e2f7 3e 9f			ld a,display_row_4 + display_cols - 1 
e2f9 11 16 9a		        ld de, endprg 
e2fc cd c1 8a			call str_at_display 
e2ff cd d1 8a			call update_display 
e302 cd f1 89			call delay1s 
e305 cd 28 e4			call cin_wait 
e308						 
e308 fe 2a			cp '*' 
e30a 28 5e			jr z, .startupend1 
e30c fe 23			cp '#' 
e30e 20 07			jr nz, .startno 
e310 3e 01			ld a, 1 
e312 32 e7 e6			ld (os_last_cmd),a 
e315 18 04			jr .startdo 
e317 fe 31		.startno:	cp '1' 
e319 28 3a			jr z,.startnxt  
e31b			 
e31b				; exec startup line 
e31b			.startdo:	 
e31b e1				pop hl 
e31c e5				push hl 
e31d				 
e31d 5e				ld e,(hl) 
e31e 23				inc hl 
e31f 56				ld d,(hl) 
e320 eb				ex de,hl 
e321			 
e321 e5				push hl 
e322			 
e322 3e 00			ld a, 0 
e324				;ld a, FORTH_END_BUFFER 
e324 cd 9d 90			call strlent 
e327 23				inc hl   ; include zero term to copy 
e328 06 00			ld b,0 
e32a 4d				ld c,l 
e32b e1				pop hl 
e32c 11 c1 e2			ld de, scratch 
e32f ed b0			ldir 
e331			 
e331			 
e331 21 c1 e2			ld hl, scratch 
e334 cd 9b 9e			call forthparse 
e337 cd db 9e			call forthexec 
e33a cd ed 9d			call forthexec_cleanup 
e33d			 
e33d 3e 78			ld a, display_row_4 
e33f 11 92 97			ld de, endprog 
e342			 
e342 cd d1 8a			call update_display		 
e345			 
e345 3a e7 e6			ld a, (os_last_cmd) 
e348 fe 00			cp 0 
e34a 20 09			jr nz, .startnxt 
e34c cd 18 9a			call next_page_prompt 
e34f cd ae 8a		        call clear_display 
e352 cd d1 8a			call update_display		 
e355			 
e355				; move onto next startup line? 
e355			.startnxt: 
e355			 
e355 cd e5 89			call delay250ms 
e358 e1				pop hl 
e359			 
e359 23				inc hl 
e35a 23				inc hl 
e35b			 
e35b e5				push hl 
e35c 5e				ld e, (hl) 
e35d 23				inc hl 
e35e 56				ld d, (hl) 
e35f e1				pop hl 
e360				; TODO replace 0 test 
e360			 
e360 eb				ex de, hl 
e361 cd 04 8d			call ishlzero 
e364			;	ld a,e 
e364			;	add d 
e364			;	cp 0    ; any left to do? 
e364 eb				ex de, hl 
e365 c2 ca e2			jp nz, .start1 
e368 18 01			jr .startupend 
e36a			 
e36a e1			.startupend1: pop hl 
e36b			.startupend: 
e36b			 
e36b cd ae 8a			call clear_display 
e36e cd d1 8a			call update_display 
e371 c9				ret 
e372			if STORAGE_SE 
e372			 
e372			sprompt3: db "Loading from start-up file?:",0 
e372			sprompt4: db "(Y=Any key/N=No)",0 
e372			 
e372			 
e372			forth_autoload: 
e372			 
e372				; load block 0 of store 1 
e372				 
e372				ld a, $fe      ; bit 0 clear 
e372				ld (spi_device), a 
e372			 
e372				call storage_get_block_0 
e372			 
e372				ld a, (store_page+STORE_0_AUTOFILE) 
e372			 
e372				cp 0 
e372				ret z     ; auto start not enabled 
e372			 
e372				call clear_display 
e372			 
e372				; set bank 
e372			 
e372					ld a, (store_page+STORE_0_BANKRUN) 
e372					ld (spi_device), a 
e372			 
e372				; get file id to load from and get the file name to display 
e372			 
e372					ld a, (store_page+STORE_0_FILERUN) 
e372			 
e372					ld l, 0 
e372					ld h, a 
e372					ld de, store_page 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASp" 
e372						CALLMONITOR 
e372					endif 
e372					call storage_read 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASr" 
e372						CALLMONITOR 
e372					endif 
e372			 
e372					call ishlzero 
e372					ret z             ; file not found 
e372			 
e372					ld a, display_row_2 + 10 
e372					ld de, store_page+3 
e372					call str_at_display 
e372				 
e372			; 
e372			 
e372				ld a, display_row_1+5 
e372				ld de, sprompt3 
e372				call str_at_display 
e372				ld a, display_row_3+15 
e372				ld de, sprompt4 
e372				call str_at_display 
e372			 
e372				call update_display 
e372			 
e372				call cin_wait 
e372				cp 'n' 
e372				ret z 
e372				cp 'N' 
e372				ret z 
e372			 
e372				call delay1s 
e372			 
e372				ld a, (store_page+2) 
e372				ld (store_openmaxext), a    ; save count of ext 
e372				ld a, 1  
e372				ld (store_openext), a    ; save count of ext 
e372			 
e372			.autof:  
e372				ld l , a 
e372				 
e372				ld a, (store_page) 
e372				ld h, a	 
e372				ld de, store_page 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASl" 
e372						CALLMONITOR 
e372					endif 
e372					call storage_read 
e372				call ishlzero 
e372				ret z 
e372			;	jr z, .autoend 
e372			 
e372					if DEBUG_FORTH_WORDS 
e372						DMARK "ASc" 
e372						CALLMONITOR 
e372					endif 
e372				ld de, store_page+2 
e372				ld a, display_row_4 
e372				call str_at_display 
e372			 
e372				call update_display 
e372				call delay250ms 
e372			 
e372			 
e372			 
e372				ld hl, store_page+2 
e372				call forthparse 
e372				call forthexec 
e372				call forthexec_cleanup 
e372			 
e372				 
e372				ld a, (store_openext) 
e372				inc a 
e372				ld (store_openext), a    ; save count of ext 
e372			 
e372				jr .autof 
e372			;.autofdone: 
e372			; 
e372			;		if DEBUG_FORTH_WORDS 
e372			;			DMARK "ASx" 
e372			;			CALLMONITOR 
e372			;		endif 
e372			;;	call clear_display 
e372			;	ret 
e372			 
e372			 
e372			 
e372			endif 
# End of file forth_startupv1.asm
e372			endif 
e372			if STARTUP_V2 
e372				include "forth_startupv2.asm" 
e372			endif 
e372			 
# End of file forth_startup.asm
e372			 
e372			; eof 
# End of file forth_kernel.asm
e372			;include "nascombasic.asm" 
e372			 
e372			 
e372			; find out where the code ends if loaded into RAM (for SC114) 
e372			;endofcode:  
e372			;	nop 
e372			 
e372			 
e372			; jump to nmi vector 
e372			 
e372			init_nmi: 
e372 3e c9			ld a, $c9   ; RET 
e374 32 72 ee			ld (nmi_vector), a 
e377 c9				ret 
e378			nmi: 
e378 e5				push hl 
e379 d5				push de 
e37a c5				push bc 
e37b f5				push af 
e37c cd 72 ee			call nmi_vector 
e37f f5				push af 
e380 c5				push bc 
e381 d5				push de 
e382 e5				push hl 
e383 ed 4d			reti 
e385			 
e385			 
e385			; eof 
e385			 
# End of file main.asm
e385			;include "firmware_lcd_4x40.asm" 
e385			;;include "firmware_lcd_4x20.asm" 
e385			include "firmware_serial_display.asm" 
e385			 
e385			; Serial display interface for SC114 
e385			 
e385			 
e385			display_row_1: equ 0 
e385			display_row_2: equ display_row_1+display_cols 
e385			display_row_3: equ display_row_2 + display_cols 
e385			display_row_4: equ display_row_3 + display_cols 
e385			 
e385			kLCDWidth:  EQU display_cols             ;Width in characters 
e385			kLCD_Line1: EQU 0x00  
e385			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e385			; E1 
e385			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e385			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e385			 
e385			lcd_init: 
e385				; no init as handled by the SCM bios 
e385 c9				ret 
e386			 
e386			 
e386			; low level functions for direct screen writes 
e386			 
e386			; output char at pos? 
e386			fLCD_Str: 
e386			        ;out (SC114_SIO_1_OUT),a 
e386 c5				push bc 
e387 0e 02			ld c, $02 
e389 f7				rst $30 
e38a c1				pop bc 
e38b c9				ret 
e38c			 
e38c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e38c			fLCD_Pos: 
e38c				; use ASCII escape to position 
e38c			        ;out (SC114_SIO_1_OUT),a 
e38c c5				push bc 
e38d 0e 02			ld c, $02 
e38f f7				rst $30 
e390 c1				pop bc 
e391			 
e391 c9				ret 
e392			 
e392			; output char at pos 
e392			fLCD_Data: 
e392			      ;  out (SC114_SIO_1_OUT),a 
e392 c5				push bc 
e393 0e 02			ld c, $02 
e395 f7				rst $30 
e396 c1				pop bc 
e397			 
e397 c9				ret 
e398			 
e398			; ascii cls  
e398			 
e398 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e39c			 
e39c			; write the frame buffer given in hl to hardware  
e39c			write_display: 
e39c			 
e39c			API: equ 0 
e39c			 
e39c			if API 
e39c				push bc 
e39c				ld b, 4 
e39c			 
e39c			        ld (display_write_tmp), hl 	  
e39c			 
e39c				; clear and home cursor 
e39c			 
e39c				ld c, 6 
e39c				ld de, .cls 
e39c				rst $30 
e39c			 
e39c			 
e39c			.writeln: 
e39c			 
e39c				ld de, (display_write_tmp) 
e39c				ld c, 6 
e39c				rst $30 
e39c				ld c, 7 
e39c				rst $30 
e39c			 
e39c				ld hl, (display_write_tmp) 
e39c				ld de, display_cols 
e39c				add hl,de 
e39c				ld (display_write_tmp),hl 
e39c			 
e39c				djnz  .writeln 
e39c			 
e39c				pop bc 
e39c			 
e39c			 
e39c				ret 
e39c			endif 
e39c e5				push hl 
e39d c5				push bc 
e39e d5				push de 
e39f			 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, 27 
e39f			;	rst $30 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, '[' 
e39f			;	rst $30 
e39f			; 
e39f			;	ld c, 2 
e39f			;	;ld de, .cls 
e39f			;	ld a, 'H' 
e39f			;	rst $30 
e39f			; 
e39f			 
e39f 0e 02			ld c, 2 
e3a1				;ld de, .cls 
e3a1 3e 1b			ld a, 27 
e3a3 f7				rst $30 
e3a4			 
e3a4			 
e3a4 0e 02			ld c, 2 
e3a6				;ld de, .cls 
e3a6 3e 5b			ld a, '[' 
e3a8 f7				rst $30 
e3a9 0e 02			ld c, 2 
e3ab				;ld de, .cls 
e3ab 3e 32			ld a, '2' 
e3ad f7				rst $30 
e3ae 0e 02			ld c, 2 
e3b0				;ld de, .cls 
e3b0 3e 4a			ld a, 'J' 
e3b2 f7				rst $30 
e3b3 d1				pop de 
e3b4 c1				pop bc 
e3b5 e1				pop hl 
e3b6			 
e3b6			 
e3b6 22 c9 eb		        ld (display_write_tmp), hl 	  
e3b9 3e 00			ld a, kLCD_Line1 
e3bb			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3bb 06 28			ld b, display_cols 
e3bd ed 5b c9 eb		ld de, (display_write_tmp) 
e3c1 cd 1f e4			call write_len_string 
e3c4				 
e3c4			 
e3c4 e5			push hl 
e3c5 d5			push de 
e3c6 c5			push bc 
e3c7 0e 07			ld c, 7 
e3c9 f7				rst $30 
e3ca c1			pop bc 
e3cb d1			pop de 
e3cc e1			pop hl 
e3cd			 
e3cd				 
e3cd 2a c9 eb			ld hl, (display_write_tmp) 
e3d0 11 28 00			ld de, display_cols 
e3d3 19				add hl,de 
e3d4 22 c9 eb			ld (display_write_tmp),hl 
e3d7			 
e3d7				 
e3d7 3e 28			ld a, kLCD_Line2 
e3d9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3d9 06 28			ld b, display_cols 
e3db ed 5b c9 eb		ld de, (display_write_tmp) 
e3df cd 1f e4			call write_len_string 
e3e2				 
e3e2 2a c9 eb			ld hl, (display_write_tmp) 
e3e5 11 28 00			ld de, display_cols 
e3e8 19				add hl,de 
e3e9 22 c9 eb			ld (display_write_tmp),hl 
e3ec			 
e3ec e5			push hl 
e3ed d5			push de 
e3ee c5			push bc 
e3ef 0e 07			ld c, 7 
e3f1 f7				rst $30 
e3f2 c1			pop bc 
e3f3 d1			pop de 
e3f4 e1			pop hl 
e3f5			 
e3f5				 
e3f5 3e 50			ld a, kLCD_Line3 
e3f7			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3f7 06 28			ld b, display_cols 
e3f9 ed 5b c9 eb		ld de, (display_write_tmp) 
e3fd cd 1f e4			call write_len_string 
e400				 
e400 2a c9 eb			ld hl, (display_write_tmp) 
e403 11 28 00			ld de, display_cols 
e406 19				add hl,de 
e407 22 c9 eb			ld (display_write_tmp),hl 
e40a			 
e40a e5			push hl 
e40b d5			push de 
e40c c5			push bc 
e40d 0e 07			ld c, 7 
e40f f7				rst $30 
e410 c1			pop bc 
e411 d1			pop de 
e412 e1			pop hl 
e413			 
e413				 
e413 3e 78			ld a, kLCD_Line4 
e415			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e415 06 28			ld b, display_cols 
e417 ed 5b c9 eb		ld de, (display_write_tmp) 
e41b cd 1f e4			call write_len_string 
e41e c9					ret 
e41f			 
e41f			 
e41f				; write out a fixed length string given in b from de 
e41f			 
e41f 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e420 cd 92 e3		            CALL fLCD_Data      ;Write character to display 
e423 13				inc de 
e424 10 f9			djnz write_len_string 
e426 c9				ret 
e427			 
e427			 
e427			; eof 
# End of file firmware_serial_display.asm
e427			;include "firmware_key_5x10.asm" 
e427			;;include "firmware_key_4x10.asm" 
e427			include "firmware_key_serial.asm" 
e427			; Serial keyboard interface for SC114 
e427			 
e427			key_init: 
e427				; no init as handled by the SCM bios 
e427 c9				ret 
e428			 
e428			 
e428			cin_wait: 
e428			;	ld a, 0 
e428			;	ret 
e428			 
e428				;in a,(SC114_SIO_1_IN) 
e428			        ; Use SCM API to get from whatever console device we are using 
e428 c5				push bc 
e429 0e 01			ld c, $01 
e42b f7				rst $30 
e42c c1				pop bc 
e42d c9				ret 
e42e			 
e42e			cin: 
e42e			 
e42e			 
e42e c5				push bc 
e42f			 
e42f				; any key waiting to process? 
e42f 0e 03			ld c, $03 
e431 f7				rst $30 
e432 28 05			jr z, .cin_skip 
e434			 
e434				; yep, get it 
e434			 
e434 0e 01			ld c, $01 
e436 f7				rst $30 
e437 c1				pop bc 
e438 c9				ret 
e439			.cin_skip: 
e439 3e 00			ld a, 0 
e43b c1				pop bc 
e43c c9				ret 
e43d			 
e43d			 
e43d			 
e43d			 
# End of file firmware_key_serial.asm
e43d			endofcode:  
e43d			baseram:  
e43d 00				nop 
e43e			 
e43e			heap_start: equ baseram+15  ; Starting address of heap 
e43e			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e43e			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e43e			;VDU:  EQU     endofcode           ; BASIC Work space 
e43e			; eof 
e43e			 
# End of file os_mega_sc114.asm
e43e
