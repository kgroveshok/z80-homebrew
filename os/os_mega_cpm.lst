# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 0f 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 99 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 99 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 99 09				call clear_display  
0123			  
0123			  
0123 cd d7 57				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd c5 58			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 69 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd bc 09			call update_display  
0132 cd 0e 09			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 9e 09			call fill_display  
013a cd bc 09			call update_display  
013d cd 0e 09			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 9e 09			call fill_display  
0145 cd bc 09			call update_display  
0148 cd 0e 09			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 9e 09			call fill_display  
0150 cd bc 09			call update_display  
0153 cd 0e 09			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd ac 09			call str_at_display  
015e cd bc 09			call update_display  
0161			  
0161			  
0161 cd 0e 09			call delay1s  
0164 cd 0e 09			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd ac 09			call str_at_display  
016f cd bc 09			call update_display  
0172 cd 0e 09			call delay1s  
0175 cd 0e 09			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 39 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 39 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d6 04			call storage_findnextid 
0205			 
0205 cd ef 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 39 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 39 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 39 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 39 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 39 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd d1 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 39 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 39 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd f3 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd f3 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd c6 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd f3 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd f3 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd c6 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 39 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 39 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 39 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 39 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d6 04			call storage_findnextid 
0416 cd ef 0b			call ishlzero 
0419 c8				ret z 
041a			 
041a e5				push hl 
041b			 
041b				; TODO check file not found 
041b			 
041b 11 65 eb			ld de, store_page 
041e cd b1 01			call storage_read_block 
0421			 
0421					if DEBUG_FORTH_WORDS 
0421						DMARK "ER1" 
0421 f5				push af  
0422 3a 36 04			ld a, (.dmark)  
0425 32 7a ee			ld (debug_mark),a  
0428 3a 37 04			ld a, (.dmark+1)  
042b 32 7b ee			ld (debug_mark+1),a  
042e 3a 38 04			ld a, (.dmark+2)  
0431 32 7c ee			ld (debug_mark+2),a  
0434 18 03			jr .pastdmark  
0436 ..			.dmark: db "ER1"  
0439 f1			.pastdmark: pop af  
043a			endm  
# End of macro DMARK
043a						CALLMONITOR 
043a cd 39 14			call break_point_state  
043d				endm  
# End of macro CALLMONITOR
043d					endif 
043d 3a 65 eb			ld a, (store_page)	; get file id 
0440 32 5e eb			ld (store_tmpid), a 
0443			 
0443 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0446 32 5d eb			ld (store_tmpext), a 
0449			 
0449				; wipe file header 
0449			 
0449 e1				pop hl 
044a 3e 00			ld a, 0 
044c 32 65 eb			ld (store_page), a 
044f 32 66 eb			ld (store_page+1),a 
0452 11 65 eb			ld de, store_page 
0455					if DEBUG_FORTH_WORDS 
0455						DMARK "ER2" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 7a ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 7b ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 7c ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "ER2"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e						CALLMONITOR 
046e cd 39 14			call break_point_state  
0471				endm  
# End of macro CALLMONITOR
0471					endif 
0471 cd 16 02			call storage_write_block 
0474			 
0474			 
0474				; wipe file extents 
0474			 
0474 3a 5d eb			ld a, (store_tmpext) 
0477 47				ld b, a 
0478			 
0478			.eraext:	  
0478 c5				push bc 
0479			 
0479 21 40 00			ld hl, STORE_BLOCK_PHY 
047c 3a 5e eb			ld a,(store_tmpid) 
047f 5f				ld e, a 
0480 50				ld d, b	 
0481					if DEBUG_FORTH_WORDS 
0481						DMARK "ER3" 
0481 f5				push af  
0482 3a 96 04			ld a, (.dmark)  
0485 32 7a ee			ld (debug_mark),a  
0488 3a 97 04			ld a, (.dmark+1)  
048b 32 7b ee			ld (debug_mark+1),a  
048e 3a 98 04			ld a, (.dmark+2)  
0491 32 7c ee			ld (debug_mark+2),a  
0494 18 03			jr .pastdmark  
0496 ..			.dmark: db "ER3"  
0499 f1			.pastdmark: pop af  
049a			endm  
# End of macro DMARK
049a						CALLMONITOR 
049a cd 39 14			call break_point_state  
049d				endm  
# End of macro CALLMONITOR
049d					endif 
049d cd d6 04			call storage_findnextid 
04a0			 
04a0 e5				push hl 
04a1 11 65 eb			ld de, store_page 
04a4 cd b1 01			call storage_read_block 
04a7			 
04a7				; free block	 
04a7			 
04a7 3e 00			ld a, 0 
04a9 32 65 eb			ld (store_page), a 
04ac 32 66 eb			ld (store_page+1),a 
04af 11 65 eb			ld de, store_page 
04b2 e1				pop hl 
04b3					if DEBUG_FORTH_WORDS 
04b3						DMARK "ER4" 
04b3 f5				push af  
04b4 3a c8 04			ld a, (.dmark)  
04b7 32 7a ee			ld (debug_mark),a  
04ba 3a c9 04			ld a, (.dmark+1)  
04bd 32 7b ee			ld (debug_mark+1),a  
04c0 3a ca 04			ld a, (.dmark+2)  
04c3 32 7c ee			ld (debug_mark+2),a  
04c6 18 03			jr .pastdmark  
04c8 ..			.dmark: db "ER4"  
04cb f1			.pastdmark: pop af  
04cc			endm  
# End of macro DMARK
04cc						CALLMONITOR 
04cc cd 39 14			call break_point_state  
04cf				endm  
# End of macro CALLMONITOR
04cf					endif 
04cf cd 16 02			call storage_write_block 
04d2			 
04d2 c1				pop bc 
04d3 10 a3			djnz .eraext 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			; Find Free Block 
04d6			; --------------- 
04d6			; 
04d6			; With current bank 
04d6			;  
04d6			; From given starting logical block 
04d6			;    Read block  
04d6			;    If no file id 
04d6			;         Return block id 
04d6			 
04d6			 
04d6			; hl starting page number 
04d6			; hl contains free page number or zero if no pages free 
04d6			; e contains the file id to locate 
04d6			; d contains the block number 
04d6			 
04d6			; TODO change to find file id and use zero for free block 
04d6			 
04d6			storage_findnextid: 
04d6			 
04d6				; now locate first 0 page to mark as a free block 
04d6			 
04d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d8			;	ld hl, STORE_BLOCK_PHY 
04d8			 
04d8					if DEBUG_FORTH_WORDS 
04d8					DMARK "FNI" 
04d8 f5				push af  
04d9 3a ed 04			ld a, (.dmark)  
04dc 32 7a ee			ld (debug_mark),a  
04df 3a ee 04			ld a, (.dmark+1)  
04e2 32 7b ee			ld (debug_mark+1),a  
04e5 3a ef 04			ld a, (.dmark+2)  
04e8 32 7c ee			ld (debug_mark+2),a  
04eb 18 03			jr .pastdmark  
04ed ..			.dmark: db "FNI"  
04f0 f1			.pastdmark: pop af  
04f1			endm  
# End of macro DMARK
04f1						CALLMONITOR 
04f1 cd 39 14			call break_point_state  
04f4				endm  
# End of macro CALLMONITOR
04f4					endif 
04f4			.ff1:   	 
04f4 e5					push hl 
04f5 c5					push bc 
04f6 d5					push de 
04f7 cd ae 01				call se_readbyte 
04fa 5f					ld e,a 
04fb 23					inc hl 
04fc cd ae 01				call se_readbyte 
04ff 57					ld d, a 
0500 e1					pop hl 
0501 e5					push hl 
0502 cd e4 0b				call cmp16 
0505 28 49				jr z, .fffound 
0507			 
0507 d1					pop de 
0508 c1					pop bc 
0509 e1					pop hl 
050a			 
050a					; is found? 
050a					;cp e 
050a					;ret z 
050a			 
050a 3e 40				ld a, STORE_BLOCK_PHY 
050c cd c6 0b				call addatohl 
050f 10 e3				djnz .ff1 
0511			 
0511 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0513			.ff2:   	 
0513			 
0513 e5					push hl 
0514 c5					push bc 
0515 d5					push de 
0516 cd ae 01				call se_readbyte 
0519 5f					ld e,a 
051a 23					inc hl 
051b cd ae 01				call se_readbyte 
051e 57					ld d, a 
051f			 
051f e1					pop hl 
0520 e5					push hl 
0521 cd e4 0b				call cmp16 
0524 28 2a				jr z, .fffound 
0526			 
0526 d1					pop de 
0527 c1					pop bc 
0528 e1					pop hl 
0529					; is found? 
0529					;cp e 
0529					;ret z 
0529			 
0529 3e 40				ld a, STORE_BLOCK_PHY 
052b cd c6 0b				call addatohl 
052e 10 e3				djnz .ff2 
0530			 
0530			 
0530					if DEBUG_FORTH_WORDS 
0530					DMARK "FN-" 
0530 f5				push af  
0531 3a 45 05			ld a, (.dmark)  
0534 32 7a ee			ld (debug_mark),a  
0537 3a 46 05			ld a, (.dmark+1)  
053a 32 7b ee			ld (debug_mark+1),a  
053d 3a 47 05			ld a, (.dmark+2)  
0540 32 7c ee			ld (debug_mark+2),a  
0543 18 03			jr .pastdmark  
0545 ..			.dmark: db "FN-"  
0548 f1			.pastdmark: pop af  
0549			endm  
# End of macro DMARK
0549					;	push af 
0549					;	ld a, 'n' 
0549					;	ld (debug_mark),a 
0549					;	pop af 
0549						CALLMONITOR 
0549 cd 39 14			call break_point_state  
054c				endm  
# End of macro CALLMONITOR
054c					endif 
054c				; no free marks! 
054c 21 00 00				ld hl, 0 
054f c9				ret 
0550			.fffound: 
0550				 
0550			 
0550 d1					pop de 
0551 c1					pop bc 
0552 e1					pop hl 
0553					if DEBUG_FORTH_WORDS 
0553					DMARK "FNF" 
0553 f5				push af  
0554 3a 68 05			ld a, (.dmark)  
0557 32 7a ee			ld (debug_mark),a  
055a 3a 69 05			ld a, (.dmark+1)  
055d 32 7b ee			ld (debug_mark+1),a  
0560 3a 6a 05			ld a, (.dmark+2)  
0563 32 7c ee			ld (debug_mark+2),a  
0566 18 03			jr .pastdmark  
0568 ..			.dmark: db "FNF"  
056b f1			.pastdmark: pop af  
056c			endm  
# End of macro DMARK
056c					;	push af 
056c					;	ld a, 'n' 
056c					;	ld (debug_mark),a 
056c					;	pop af 
056c						CALLMONITOR 
056c cd 39 14			call break_point_state  
056f				endm  
# End of macro CALLMONITOR
056f					endif 
056f c9				ret 
0570			 
0570			 
0570			 
0570			; Free Space 
0570			; ---------- 
0570			; 
0570			; With current bank 
0570			; 
0570			; Set block count to zero 
0570			; Starting with first logical block 
0570			;      Find free block  
0570			;      If block id given, increment block count 
0570			; 
0570			;  
0570			 
0570			 
0570			; hl contains count of free blocks 
0570			 
0570			storage_freeblocks: 
0570			 
0570				; now locate first 0 page to mark as a free block 
0570			 
0570 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0572 21 40 00			ld hl, STORE_BLOCK_PHY 
0575 11 00 00			ld de, 0 
0578			 
0578			.fb1:   	 
0578 e5					push hl 
0579 c5					push bc 
057a d5					push de 
057b cd ae 01				call se_readbyte 
057e d1					pop de 
057f c1					pop bc 
0580 e1					pop hl 
0581			 
0581					; is free? 
0581 fe 00				cp 0 
0583 20 01				jr nz, .ff1cont 
0585 13					inc de 
0586			 
0586			.ff1cont: 
0586			 
0586			 
0586 3e 40				ld a, STORE_BLOCK_PHY 
0588 cd c6 0b				call addatohl 
058b 10 eb				djnz .fb1 
058d			 
058d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058f			.fb2:   	 
058f e5					push hl 
0590 c5					push bc 
0591 d5					push de 
0592 cd ae 01				call se_readbyte 
0595 d1					pop de 
0596 c1					pop bc 
0597 e1					pop hl 
0598			 
0598					; is free? 
0598 fe 00				cp 0 
059a 20 01				jr nz, .ff2cont 
059c 13					inc de 
059d			 
059d			.ff2cont: 
059d			 
059d 3e 40				ld a, STORE_BLOCK_PHY 
059f cd c6 0b				call addatohl 
05a2 10 eb				djnz .fb2 
05a4			 
05a4 eb				ex de, hl 
05a5 c9				ret 
05a6			 
05a6			; Get File ID 
05a6			; ----------- 
05a6			; 
05a6			; With current bank 
05a6			;  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; For each logical block 
05a6			;    Read block file id 
05a6			;      If first block of file and dont have file id 
05a6			;         if file get id and exit 
05a6			 
05a6			 
05a6			 
05a6			 
05a6			; Create File 
05a6			; ----------- 
05a6			; 
05a6			; With current bank  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; Increment file id number 
05a6			; Save Config 
05a6			; Find free block 
05a6			; Set buffer with file name and file id 
05a6			; Write buffer to free block  
05a6			 
05a6			 
05a6			; hl point to file name 
05a6			; hl returns file id 
05a6			 
05a6			; file format: 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent number 
05a6			; byte 2-> data 
05a6			 
05a6			; format for extent number 0: 
05a6			; 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent 0 
05a6			; byte 2 - extent count 
05a6			; byte 3 -> file name and meta data 
05a6			 
05a6			 
05a6			storage_create: 
05a6				if DEBUG_STORESE 
05a6					DMARK "SCR" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 7a ee			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 7b ee			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 7c ee			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "SCR"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 39 14			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl		; save file name pointer 
05c3			 
05c3 cd 62 02			call storage_get_block_0 
05c6			 
05c6 3a 65 eb			ld a,(store_page)	; get current file id 
05c9 3c				inc a 
05ca 32 65 eb			ld (store_page),a 
05cd				 
05cd 32 5e eb			ld (store_tmpid),a			; save id 
05d0			 
05d0 21 00 00			ld hl, 0 
05d3 11 65 eb			ld de, store_page 
05d6				if DEBUG_STORESE 
05d6					DMARK "SCw" 
05d6 f5				push af  
05d7 3a eb 05			ld a, (.dmark)  
05da 32 7a ee			ld (debug_mark),a  
05dd 3a ec 05			ld a, (.dmark+1)  
05e0 32 7b ee			ld (debug_mark+1),a  
05e3 3a ed 05			ld a, (.dmark+2)  
05e6 32 7c ee			ld (debug_mark+2),a  
05e9 18 03			jr .pastdmark  
05eb ..			.dmark: db "SCw"  
05ee f1			.pastdmark: pop af  
05ef			endm  
# End of macro DMARK
05ef					CALLMONITOR 
05ef cd 39 14			call break_point_state  
05f2				endm  
# End of macro CALLMONITOR
05f2				endif 
05f2 cd 16 02			call storage_write_block	 ; save update 
05f5			 
05f5				if DEBUG_STORESE 
05f5 11 65 eb				ld de, store_page 
05f8					DMARK "SCC" 
05f8 f5				push af  
05f9 3a 0d 06			ld a, (.dmark)  
05fc 32 7a ee			ld (debug_mark),a  
05ff 3a 0e 06			ld a, (.dmark+1)  
0602 32 7b ee			ld (debug_mark+1),a  
0605 3a 0f 06			ld a, (.dmark+2)  
0608 32 7c ee			ld (debug_mark+2),a  
060b 18 03			jr .pastdmark  
060d ..			.dmark: db "SCC"  
0610 f1			.pastdmark: pop af  
0611			endm  
# End of macro DMARK
0611					CALLMONITOR 
0611 cd 39 14			call break_point_state  
0614				endm  
# End of macro CALLMONITOR
0614				endif 
0614				;  
0614				 
0614 21 40 00			ld hl, STORE_BLOCK_PHY 
0617 11 00 00			ld de, 0 
061a cd d6 04			call storage_findnextid 
061d			 
061d 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
0620			 
0620				; TODO detect 0 = no spare blocks 
0620			 
0620				; hl now contains the free page to use for the file header page 
0620			 
0620				if DEBUG_STORESE 
0620				DMARK "SCF" 
0620 f5				push af  
0621 3a 35 06			ld a, (.dmark)  
0624 32 7a ee			ld (debug_mark),a  
0627 3a 36 06			ld a, (.dmark+1)  
062a 32 7b ee			ld (debug_mark+1),a  
062d 3a 37 06			ld a, (.dmark+2)  
0630 32 7c ee			ld (debug_mark+2),a  
0633 18 03			jr .pastdmark  
0635 ..			.dmark: db "SCF"  
0638 f1			.pastdmark: pop af  
0639			endm  
# End of macro DMARK
0639					CALLMONITOR 
0639 cd 39 14			call break_point_state  
063c				endm  
# End of macro CALLMONITOR
063c				endif 
063c			 
063c 22 4f eb			ld (store_tmppageid), hl 
063f				 
063f 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0642			;	ld a, (store_filecache)			; save to cache 
0642			 
0642 32 65 eb			ld (store_page),a    ; set page id 
0645 3e 00			ld a, 0			 ; extent 0 is file header 
0647 32 66 eb			ld (store_page+1), a   ; set file extent 
064a			 
064a 32 67 eb			ld (store_page+2), a   ; extent count for the file 
064d			 
064d			;	inc hl 		; init block 0 of file 
064d			;	inc hl   		; skip file and extent id 
064d			 ;       ld a, 0 
064d			;	ld (hl),a 
064d			;	ld a, (store_filecache+1)  	; save to cache 
064d			 
064d			;	inc hl    ; file name 
064d				 
064d				 
064d 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0650				if DEBUG_STORESE 
0650					DMARK "SCc" 
0650 f5				push af  
0651 3a 65 06			ld a, (.dmark)  
0654 32 7a ee			ld (debug_mark),a  
0657 3a 66 06			ld a, (.dmark+1)  
065a 32 7b ee			ld (debug_mark+1),a  
065d 3a 67 06			ld a, (.dmark+2)  
0660 32 7c ee			ld (debug_mark+2),a  
0663 18 03			jr .pastdmark  
0665 ..			.dmark: db "SCc"  
0668 f1			.pastdmark: pop af  
0669			endm  
# End of macro DMARK
0669					CALLMONITOR 
0669 cd 39 14			call break_point_state  
066c				endm  
# End of macro CALLMONITOR
066c				endif 
066c e1				pop hl    ; get zero term string 
066d e5				push hl 
066e 3e 00			ld a, 0 
0670 cd 2f 10			call strlent 
0673 23				inc hl   ; cover zero term 
0674 06 00			ld b,0 
0676 4d				ld c,l 
0677 e1				pop hl 
0678				;ex de, hl 
0678				if DEBUG_STORESE 
0678					DMARK "SCa" 
0678 f5				push af  
0679 3a 8d 06			ld a, (.dmark)  
067c 32 7a ee			ld (debug_mark),a  
067f 3a 8e 06			ld a, (.dmark+1)  
0682 32 7b ee			ld (debug_mark+1),a  
0685 3a 8f 06			ld a, (.dmark+2)  
0688 32 7c ee			ld (debug_mark+2),a  
068b 18 03			jr .pastdmark  
068d ..			.dmark: db "SCa"  
0690 f1			.pastdmark: pop af  
0691			endm  
# End of macro DMARK
0691					;push af 
0691					;ld a, 'a' 
0691					;ld (debug_mark),a 
0691					;pop af 
0691					CALLMONITOR 
0691 cd 39 14			call break_point_state  
0694				endm  
# End of macro CALLMONITOR
0694				endif 
0694 ed b0			ldir    ; copy zero term string 
0696				if DEBUG_STORESE 
0696					DMARK "SCA" 
0696 f5				push af  
0697 3a ab 06			ld a, (.dmark)  
069a 32 7a ee			ld (debug_mark),a  
069d 3a ac 06			ld a, (.dmark+1)  
06a0 32 7b ee			ld (debug_mark+1),a  
06a3 3a ad 06			ld a, (.dmark+2)  
06a6 32 7c ee			ld (debug_mark+2),a  
06a9 18 03			jr .pastdmark  
06ab ..			.dmark: db "SCA"  
06ae f1			.pastdmark: pop af  
06af			endm  
# End of macro DMARK
06af					CALLMONITOR 
06af cd 39 14			call break_point_state  
06b2				endm  
# End of macro CALLMONITOR
06b2				endif 
06b2			 
06b2				; write file header page 
06b2			 
06b2 2a 4f eb			ld hl,(store_tmppageid) 
06b5 11 65 eb			ld de, store_page 
06b8				if DEBUG_STORESE 
06b8					DMARK "SCb" 
06b8 f5				push af  
06b9 3a cd 06			ld a, (.dmark)  
06bc 32 7a ee			ld (debug_mark),a  
06bf 3a ce 06			ld a, (.dmark+1)  
06c2 32 7b ee			ld (debug_mark+1),a  
06c5 3a cf 06			ld a, (.dmark+2)  
06c8 32 7c ee			ld (debug_mark+2),a  
06cb 18 03			jr .pastdmark  
06cd ..			.dmark: db "SCb"  
06d0 f1			.pastdmark: pop af  
06d1			endm  
# End of macro DMARK
06d1					;push af 
06d1					;ld a, 'b' 
06d1					;ld (debug_mark),a 
06d1					;pop af 
06d1					CALLMONITOR 
06d1 cd 39 14			call break_point_state  
06d4				endm  
# End of macro CALLMONITOR
06d4				endif 
06d4 cd 16 02			call storage_write_block 
06d7			 
06d7 3a 5e eb			ld a, (store_tmpid) 
06da 6f				ld l, a 
06db 26 00			ld h,0 
06dd				if DEBUG_STORESE 
06dd					DMARK "SCz" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 7a ee			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 7b ee			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 7c ee			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "SCz"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6					CALLMONITOR 
06f6 cd 39 14			call break_point_state  
06f9				endm  
# End of macro CALLMONITOR
06f9				endif 
06f9 c9				ret 
06fa				 
06fa			 
06fa			 
06fa			; 
06fa			; Read File 
06fa			; 
06fa			; h - file id to locate 
06fa			; l - extent to locate 
06fa			; de - pointer to string to read into 
06fa			; 
06fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06fa			 
06fa			.sr_fail: 
06fa d1				pop de 
06fb c9				ret 
06fc			 
06fc			storage_read: 
06fc d5				push de 
06fd			 
06fd			; TODO BUG the above push is it popped before the RET Z? 
06fd			 
06fd			; TODO how to handle multiple part blocks 
06fd			 
06fd				; locate file extent to read 
06fd			 
06fd 5c				ld e, h 
06fe 55				ld d, l 
06ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0702				if DEBUG_STORESE 
0702					DMARK "SRE" 
0702 f5				push af  
0703 3a 17 07			ld a, (.dmark)  
0706 32 7a ee			ld (debug_mark),a  
0709 3a 18 07			ld a, (.dmark+1)  
070c 32 7b ee			ld (debug_mark+1),a  
070f 3a 19 07			ld a, (.dmark+2)  
0712 32 7c ee			ld (debug_mark+2),a  
0715 18 03			jr .pastdmark  
0717 ..			.dmark: db "SRE"  
071a f1			.pastdmark: pop af  
071b			endm  
# End of macro DMARK
071b					CALLMONITOR 
071b cd 39 14			call break_point_state  
071e				endm  
# End of macro CALLMONITOR
071e				endif 
071e cd d6 04			call storage_findnextid 
0721			 
0721				if DEBUG_STORESE 
0721					DMARK "SRf" 
0721 f5				push af  
0722 3a 36 07			ld a, (.dmark)  
0725 32 7a ee			ld (debug_mark),a  
0728 3a 37 07			ld a, (.dmark+1)  
072b 32 7b ee			ld (debug_mark+1),a  
072e 3a 38 07			ld a, (.dmark+2)  
0731 32 7c ee			ld (debug_mark+2),a  
0734 18 03			jr .pastdmark  
0736 ..			.dmark: db "SRf"  
0739 f1			.pastdmark: pop af  
073a			endm  
# End of macro DMARK
073a					CALLMONITOR 
073a cd 39 14			call break_point_state  
073d				endm  
# End of macro CALLMONITOR
073d				endif 
073d cd ef 0b			call ishlzero 
0740			;	ld a, l 
0740			;	add h 
0740			;	cp 0 
0740 28 b8			jr z,.sr_fail			; block not found so EOF 
0742			 
0742				; hl contains page number to load 
0742 d1				pop de   ; get storage 
0743 d5				push de 
0744				if DEBUG_STORESE 
0744					DMARK "SRg" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 7a ee			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 7b ee			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 7c ee			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SRg"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 39 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760 cd b1 01			call storage_read_block 
0763			 
0763			 
0763			; TODO if block has no zeros then need to read next block  
0763			 
0763			 
0763					 
0763 e1				pop hl 		 ; return start of data to show as not EOF 
0764 23				inc hl   ; past file id 
0765 23				inc hl   ; past ext 
0766				if DEBUG_STORESE 
0766					DMARK "SRe" 
0766 f5				push af  
0767 3a 7b 07			ld a, (.dmark)  
076a 32 7a ee			ld (debug_mark),a  
076d 3a 7c 07			ld a, (.dmark+1)  
0770 32 7b ee			ld (debug_mark+1),a  
0773 3a 7d 07			ld a, (.dmark+2)  
0776 32 7c ee			ld (debug_mark+2),a  
0779 18 03			jr .pastdmark  
077b ..			.dmark: db "SRe"  
077e f1			.pastdmark: pop af  
077f			endm  
# End of macro DMARK
077f					CALLMONITOR 
077f cd 39 14			call break_point_state  
0782				endm  
# End of macro CALLMONITOR
0782				endif 
0782 c9					ret 
0783			 
0783			 
0783			 
0783			; 
0783			; Append File 
0783			; 
0783			; hl - file id to locate 
0783			; de - pointer to (multi block) string to write 
0783			 
0783			.sa_notfound: 
0783 d1				pop de 
0784 c9				ret 
0785			 
0785			 
0785			storage_append: 
0785				; hl -  file id to append to 
0785				; de - string to append 
0785			 
0785 d5				push de 
0786				 
0786				if DEBUG_STORESE 
0786					DMARK "AP1" 
0786 f5				push af  
0787 3a 9b 07			ld a, (.dmark)  
078a 32 7a ee			ld (debug_mark),a  
078d 3a 9c 07			ld a, (.dmark+1)  
0790 32 7b ee			ld (debug_mark+1),a  
0793 3a 9d 07			ld a, (.dmark+2)  
0796 32 7c ee			ld (debug_mark+2),a  
0799 18 03			jr .pastdmark  
079b ..			.dmark: db "AP1"  
079e f1			.pastdmark: pop af  
079f			endm  
# End of macro DMARK
079f					CALLMONITOR 
079f cd 39 14			call break_point_state  
07a2				endm  
# End of macro CALLMONITOR
07a2				endif 
07a2			 
07a2 7d				ld a, l 
07a3 32 5e eb			ld (store_tmpid), a 
07a6			 
07a6				; get file header  
07a6			 
07a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07a8 3a 5e eb			ld a, (store_tmpid) 
07ab 5f				ld e, a 
07ac			 
07ac 21 40 00				ld hl, STORE_BLOCK_PHY 
07af cd d6 04				call storage_findnextid 
07b2			 
07b2 cd ef 0b			call ishlzero 
07b5 28 cc			jr z, .sa_notfound 
07b7			 
07b7 22 4f eb			ld (store_tmppageid), hl 
07ba			 
07ba				; TODO handle file id not found 
07ba			 
07ba				if DEBUG_STORESE 
07ba					DMARK "AP2" 
07ba f5				push af  
07bb 3a cf 07			ld a, (.dmark)  
07be 32 7a ee			ld (debug_mark),a  
07c1 3a d0 07			ld a, (.dmark+1)  
07c4 32 7b ee			ld (debug_mark+1),a  
07c7 3a d1 07			ld a, (.dmark+2)  
07ca 32 7c ee			ld (debug_mark+2),a  
07cd 18 03			jr .pastdmark  
07cf ..			.dmark: db "AP2"  
07d2 f1			.pastdmark: pop af  
07d3			endm  
# End of macro DMARK
07d3					CALLMONITOR 
07d3 cd 39 14			call break_point_state  
07d6				endm  
# End of macro CALLMONITOR
07d6				endif 
07d6			 
07d6				; update file extent count 
07d6			 
07d6 11 65 eb			ld de, store_page 
07d9			 
07d9 cd b1 01			call storage_read_block 
07dc			 
07dc				if DEBUG_STORESE 
07dc					DMARK "AP3" 
07dc f5				push af  
07dd 3a f1 07			ld a, (.dmark)  
07e0 32 7a ee			ld (debug_mark),a  
07e3 3a f2 07			ld a, (.dmark+1)  
07e6 32 7b ee			ld (debug_mark+1),a  
07e9 3a f3 07			ld a, (.dmark+2)  
07ec 32 7c ee			ld (debug_mark+2),a  
07ef 18 03			jr .pastdmark  
07f1 ..			.dmark: db "AP3"  
07f4 f1			.pastdmark: pop af  
07f5			endm  
# End of macro DMARK
07f5					CALLMONITOR 
07f5 cd 39 14			call break_point_state  
07f8				endm  
# End of macro CALLMONITOR
07f8				endif 
07f8			;	ld (store_tmppageid), hl 
07f8			 
07f8 3a 67 eb			ld a, (store_page+2) 
07fb 3c				inc a 
07fc 32 67 eb			ld (store_page+2), a 
07ff 32 5d eb			ld (store_tmpext), a 
0802				 
0802				if DEBUG_STORESE 
0802					DMARK "AP3" 
0802 f5				push af  
0803 3a 17 08			ld a, (.dmark)  
0806 32 7a ee			ld (debug_mark),a  
0809 3a 18 08			ld a, (.dmark+1)  
080c 32 7b ee			ld (debug_mark+1),a  
080f 3a 19 08			ld a, (.dmark+2)  
0812 32 7c ee			ld (debug_mark+2),a  
0815 18 03			jr .pastdmark  
0817 ..			.dmark: db "AP3"  
081a f1			.pastdmark: pop af  
081b			endm  
# End of macro DMARK
081b					CALLMONITOR 
081b cd 39 14			call break_point_state  
081e				endm  
# End of macro CALLMONITOR
081e				endif 
081e 2a 4f eb			ld hl, (store_tmppageid) 
0821 11 65 eb			ld de, store_page 
0824 cd 16 02			call storage_write_block 
0827			 
0827				; find free block 
0827			 
0827 11 00 00			ld de, 0			 ; file extent to locate 
082a			 
082a 21 40 00				ld hl, STORE_BLOCK_PHY 
082d cd d6 04				call storage_findnextid 
0830 cd ef 0b			call ishlzero 
0833 ca 83 07			jp z, .sa_notfound 
0836			 
0836					; TODO handle no space left 
0836					 
0836 22 4f eb				ld (store_tmppageid), hl 
0839			 
0839				if DEBUG_STORESE 
0839					DMARK "AP4" 
0839 f5				push af  
083a 3a 4e 08			ld a, (.dmark)  
083d 32 7a ee			ld (debug_mark),a  
0840 3a 4f 08			ld a, (.dmark+1)  
0843 32 7b ee			ld (debug_mark+1),a  
0846 3a 50 08			ld a, (.dmark+2)  
0849 32 7c ee			ld (debug_mark+2),a  
084c 18 03			jr .pastdmark  
084e ..			.dmark: db "AP4"  
0851 f1			.pastdmark: pop af  
0852			endm  
# End of macro DMARK
0852					CALLMONITOR 
0852 cd 39 14			call break_point_state  
0855				endm  
# End of macro CALLMONITOR
0855				endif 
0855					; init the buffer with zeros so we can id if the buffer is full or not 
0855			 
0855 e5					push hl 
0856 c5					push bc 
0857			 
0857 21 65 eb				ld hl, store_page 
085a 06 40				ld b, STORE_BLOCK_PHY 
085c 3e 00				ld a, 0 
085e 77			.zeroblock:	ld (hl), a 
085f 23					inc hl 
0860 10 fc				djnz .zeroblock 
0862			 
0862 c1					pop bc 
0863 e1					pop hl 
0864			 
0864					; construct block 
0864			 
0864 3a 5e eb				ld a, (store_tmpid) 
0867 32 65 eb				ld (store_page), a   ; file id 
086a 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
086d 32 66 eb				ld (store_page+1), a 
0870			 
0870 e1					pop hl    ; get string to write 
0871 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0873 11 67 eb				ld de, store_page+2 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "AP5" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 7a ee			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 7b ee			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 7c ee			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "AP5"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 39 14			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892			 
0892			 
0892			 
0892					; fill buffer with data until end of string or full block 
0892			 
0892 7e			.appd:		ld a, (hl) 
0893 12					ld (de), a 
0894 fe 00				cp 0 
0896 28 04				jr z, .appdone 
0898 23					inc hl 
0899 13					inc de 
089a 10 f6				djnz .appd 
089c			 
089c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
089d f5					push af   		; save last byte dumped 
089e			 
089e			 
089e 2a 4f eb			ld hl, (store_tmppageid) 
08a1 11 65 eb			ld de, store_page 
08a4				if DEBUG_STORESE 
08a4					DMARK "AP6" 
08a4 f5				push af  
08a5 3a b9 08			ld a, (.dmark)  
08a8 32 7a ee			ld (debug_mark),a  
08ab 3a ba 08			ld a, (.dmark+1)  
08ae 32 7b ee			ld (debug_mark+1),a  
08b1 3a bb 08			ld a, (.dmark+2)  
08b4 32 7c ee			ld (debug_mark+2),a  
08b7 18 03			jr .pastdmark  
08b9 ..			.dmark: db "AP6"  
08bc f1			.pastdmark: pop af  
08bd			endm  
# End of macro DMARK
08bd					CALLMONITOR 
08bd cd 39 14			call break_point_state  
08c0				endm  
# End of macro CALLMONITOR
08c0				endif 
08c0 cd 16 02				call storage_write_block 
08c3			 
08c3			 
08c3				; was that a full block of data written? 
08c3				; any more to write out? 
08c3			 
08c3				; if yes then set vars and jump to start of function again 
08c3			 
08c3 f1					pop af 
08c4 d1					pop de 
08c5			 
08c5 fe 00				cp 0		 ; no, string was fully written 
08c7 c8					ret z 
08c8			 
08c8					; setup vars for next cycle 
08c8			 
08c8 3a 5e eb				ld a, (store_tmpid) 
08cb 6f					ld l, a 
08cc 26 00				ld h, 0 
08ce			 
08ce c3 85 07			 	jp storage_append	 ; yes, need to write out some more 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			if DEBUG_STORECF 
08d1			storageput:	 
08d1					ret 
08d1			storageread: 
08d1					ld hl, store_page 
08d1					ld b, 200 
08d1					ld a,0 
08d1			.src:		ld (hl),a 
08d1					inc hl 
08d1					djnz .src 
08d1					 
08d1			 
08d1					ld de, 0 
08d1					ld bc, 1 
08d1					ld hl, store_page 
08d1					call cfRead 
08d1			 
08d1				call cfGetError 
08d1				ld hl,scratch 
08d1				call hexout 
08d1				ld hl, scratch+2 
08d1				ld a, 0 
08d1				ld (hl),a 
08d1				ld de, scratch 
08d1				ld a,display_row_1 
08d1				call str_at_display 
08d1				call update_display 
08d1			 
08d1					ld hl, store_page 
08d1					ld (os_cur_ptr),hl 
08d1			 
08d1					ret 
08d1			endif 
08d1			 
08d1			 
08d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
08d1			 
08d1			storage_clear_page: 
08d1 e5				push hl 
08d2 d5				push de 
08d3 c5				push bc 
08d4 21 65 eb			ld hl, store_page 
08d7 3e 00			ld a, 0 
08d9 77				ld (hl), a 
08da			 
08da 11 66 eb			ld de, store_page+1 
08dd 01 40 00			ld bc, STORE_BLOCK_PHY 
08e0			 
08e0 ed b0			ldir 
08e2				 
08e2 c1				pop bc 
08e3 d1				pop de 
08e4 e1				pop hl 
08e5 c9				ret 
08e6			 
08e6			; eof 
# End of file firmware_storage.asm
08e6			  
08e6			; support routines for above hardware abstraction layer  
08e6			  
08e6			include "firmware_general.asm"        ; general support functions  
08e6			 
08e6			; word look up 
08e6			 
08e6			; in 
08e6			; a is the index 
08e6			; hl is pointer start of array 
08e6			; 
08e6			; returns 
08e6			; hl to the word 
08e6			; 
08e6			 
08e6			table_lookup:  
08e6 d5					push de 
08e7 eb					ex de, hl 
08e8			 
08e8 6f					ld l, a 
08e9 26 00				ld h, 0 
08eb 29					add hl, hl 
08ec 19					add hl, de 
08ed 7e					ld a, (hl) 
08ee 23					inc hl 
08ef 66					ld h,(hl) 
08f0 6f					ld l, a 
08f1			 
08f1 d1					pop de 
08f2 c9					ret 
08f3			 
08f3			; Delay loops 
08f3			 
08f3			 
08f3			 
08f3			aDelayInMS: 
08f3 c5				push bc 
08f4 47				ld b,a 
08f5			msdelay: 
08f5 c5				push bc 
08f6				 
08f6			 
08f6 01 41 00			ld bc,041h 
08f9 cd 11 09			call delayloop 
08fc c1				pop bc 
08fd 05				dec b 
08fe 20 f5			jr nz,msdelay 
0900			 
0900			;if CPU_CLOCK_8MHZ 
0900			;msdelay8: 
0900			;	push bc 
0900			;	 
0900			; 
0900			;	ld bc,041h 
0900			;	call delayloop 
0900			;	pop bc 
0900			;	dec b 
0900			;	jr nz,msdelay8 
0900			;endif 
0900			 
0900			 
0900 c1				pop bc 
0901 c9				ret 
0902			 
0902			 
0902			delay250ms: 
0902				;push de 
0902 01 00 40			ld bc, 04000h 
0905 c3 11 09			jp delayloop 
0908			delay500ms: 
0908				;push de 
0908 01 00 80			ld bc, 08000h 
090b c3 11 09			jp delayloop 
090e			delay1s: 
090e				;push bc 
090e			   ; Clobbers A, d and e 
090e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0911			delayloop: 
0911 c5			    push bc 
0912			 
0912			if BASE_CPM 
0912 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0915			.cpmloop: 
0915 c5				push bc 
0916			 
0916			endif 
0916			 
0916			 
0916			 
0916			delayloopi: 
0916			;	push bc 
0916			;.dl: 
0916 cb 47		    bit     0,a    	; 8 
0918 cb 47		    bit     0,a    	; 8 
091a cb 47		    bit     0,a    	; 8 
091c e6 ff		    and     255  	; 7 
091e 0b			    dec     bc      	; 6 
091f 79			    ld      a,c     	; 4 
0920 b0			    or      b     	; 4 
0921 c2 16 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0924			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0924				;pop de 
0924			;pop bc 
0924			 
0924			if BASE_CPM 
0924 c1				pop bc 
0925				 
0925 0b			    dec     bc      	; 6 
0926 79			    ld      a,c     	; 4 
0927 b0			    or      b     	; 4 
0928 c2 15 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
092b				 
092b			 
092b			endif 
092b			;if CPU_CLOCK_8MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b			 
092b			;if CPU_CLOCK_10MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b c1			    pop bc 
092c			 
092c c9				ret 
092d			 
092d			 
092d			 
092d			; eof 
# End of file firmware_general.asm
092d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
092d			; display routines that use the physical hardware abstraction layer 
092d			 
092d			 
092d			; information window 
092d			 
092d			; pass hl with 1st string to display 
092d			; pass de with 2nd string to display 
092d			 
092d			info_panel: 
092d e5				push hl 
092e			 
092e 2a db eb			ld hl, (display_fb_active) 
0931 e5				push hl    ; future de destination 
0932 21 c0 ed				ld hl, display_fb0 
0935 22 db eb				ld (display_fb_active), hl 
0938			 
0938 cd 99 09			call clear_display 
093b			 
093b			 
093b 3e 55			ld a, display_row_3 + 5 
093d cd ac 09			call str_at_display 
0940			 
0940 e1				pop hl 
0941 d1				pop de 
0942			 
0942 e5				push hl 
0943			 
0943			 
0943 3e 2d			ld a, display_row_2 + 5 
0945 cd ac 09			call str_at_display 
0948			 
0948			 
0948 cd bc 09			call update_display 
094b cd 3e 19			call next_page_prompt 
094e cd 99 09			call clear_display 
0951			 
0951				 
0951 21 1f ed				ld hl, display_fb1 
0954 22 db eb				ld (display_fb_active), hl 
0957 cd bc 09			call update_display 
095a			 
095a			 
095a c9				ret 
095b			 
095b			 
095b			 
095b			 
095b			; TODO windowing? 
095b			 
095b			; TODO scroll line up 
095b			 
095b			scroll_up: 
095b			 
095b e5				push hl 
095c d5				push de 
095d c5				push bc 
095e			 
095e				; get frame buffer  
095e			 
095e 2a db eb			ld hl, (display_fb_active) 
0961 e5				push hl    ; future de destination 
0962			 
0962 11 28 00			ld  de, display_cols 
0965 19				add hl, de 
0966			 
0966 d1				pop de 
0967			 
0967				;ex de, hl 
0967 01 9f 00			ld bc, display_fb_len -1  
096a			;if DEBUG_FORTH_WORDS 
096a			;	DMARK "SCL" 
096a			;	CALLMONITOR 
096a			;endif	 
096a ed b0			ldir 
096c			 
096c				; wipe bottom row 
096c			 
096c			 
096c 2a db eb			ld hl, (display_fb_active) 
096f 11 a0 00			ld de, display_cols*display_rows 
0972 19				add hl, de 
0973 06 28			ld b, display_cols 
0975 3e 20			ld a, ' ' 
0977			.scwipe: 
0977 77				ld (hl), a 
0978 2b				dec hl 
0979 10 fc			djnz .scwipe 
097b			 
097b				;pop hl 
097b			 
097b c1				pop bc 
097c d1				pop de 
097d e1				pop hl 
097e			 
097e c9				ret 
097f			 
097f			 
097f			;scroll_upo: 
097f			;	ld de, display_row_1 
097f			 ;	ld hl, display_row_2 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			;	ld de, display_row_2 
097f			 ;	ld hl, display_row_3 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			;	ld de, display_row_3 
097f			 ;	ld hl, display_row_4 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			 
097f			; TODO clear row 4 
097f			 
097f			;	ret 
097f			 
097f				 
097f			scroll_down: 
097f			 
097f e5				push hl 
0980 d5				push de 
0981 c5				push bc 
0982			 
0982				; get frame buffer  
0982			 
0982 2a db eb			ld hl, (display_fb_active) 
0985			 
0985 11 9f 00			ld de, display_fb_len - 1 
0988 19				add hl, de 
0989			 
0989 e5			push hl    ; future de destination 
098a			 
098a 11 28 00			ld  de, display_cols 
098d ed 52			sbc hl, de 
098f			 
098f			 
098f d1				pop de 
0990			 
0990			;	ex de, hl 
0990 01 9f 00			ld bc, display_fb_len -1  
0993			 
0993			 
0993				 
0993			 
0993 ed b0			ldir 
0995			 
0995				; wipe bottom row 
0995			 
0995			 
0995			;	ld hl, (display_fb_active) 
0995			;;	ld de, display_cols*display_rows 
0995			;;	add hl, de 
0995			;	ld b, display_cols 
0995			;	ld a, ' ' 
0995			;.scwiped: 
0995			;	ld (hl), a 
0995			;	dec hl 
0995			;	djnz .scwiped 
0995			 
0995				;pop hl 
0995			 
0995 c1				pop bc 
0996 d1				pop de 
0997 e1				pop hl 
0998			 
0998 c9				ret 
0999			;scroll_down: 
0999			;	ld de, display_row_4 
0999			;	ld hl, display_row_3 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;	ld de, display_row_3 
0999			; 	ld hl, display_row_2 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;	ld de, display_row_2 
0999			;	ld hl, display_row_1 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;;; TODO clear row 1 
0999			;	ret 
0999			 
0999			 
0999			 
0999			 
0999			 
0999			; clear active frame buffer 
0999			 
0999			clear_display: 
0999 3e 20			ld a, ' ' 
099b c3 9e 09			jp fill_display 
099e			 
099e			; fill active frame buffer with a char in A 
099e			 
099e			fill_display: 
099e 06 a0			ld b,display_fb_len 
09a0 2a db eb			ld hl, (display_fb_active) 
09a3 77			.fd1:	ld (hl),a 
09a4 23				inc hl 
09a5 10 fc			djnz .fd1 
09a7 23				inc hl 
09a8 3e 00			ld a,0 
09aa 77				ld (hl),a 
09ab			 
09ab			 
09ab c9				ret 
09ac			; Write string (DE) at pos (A) to active frame buffer 
09ac			 
09ac 2a db eb		str_at_display:    ld hl,(display_fb_active) 
09af 06 00					ld b,0 
09b1 4f					ld c,a 
09b2 09					add hl,bc 
09b3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09b4 b7			            OR   A              ;Null terminator? 
09b5 c8			            RET  Z              ;Yes, so finished 
09b6 77					ld (hl),a 
09b7 23				inc hl 
09b8 13			            INC  DE             ;Point to next character 
09b9 18 f8		            JR   .sad1     ;Repeat 
09bb c9					ret 
09bc			 
09bc			; using current frame buffer write to physical display 
09bc			 
09bc			update_display: 
09bc e5				push hl 
09bd 2a db eb			ld hl, (display_fb_active) 
09c0 cd 14 58			call write_display 
09c3 e1				pop hl 
09c4 c9				ret 
09c5			 
09c5			; TODO scrolling 
09c5			 
09c5			 
09c5			; move cursor right one char 
09c5			cursor_right: 
09c5			 
09c5				; TODO shift right 
09c5				; TODO if beyond max col 
09c5				; TODO       cursor_next_line 
09c5			 
09c5 c9				ret 
09c6			 
09c6			 
09c6			cursor_next_line: 
09c6				; TODO first char 
09c6				; TODO line down 
09c6				; TODO if past last row 
09c6				; TODO    scroll up 
09c6			 
09c6 c9				ret 
09c7			 
09c7			cursor_left: 
09c7				; TODO shift left 
09c7				; TODO if beyond left  
09c7				; TODO     cursor prev line 
09c7				 
09c7 c9				ret 
09c8			 
09c8			cursor_prev_line: 
09c8				; TODO last char 
09c8				; TODO line up 
09c8				; TODO if past first row 
09c8				; TODO   scroll down 
09c8			 
09c8 c9				ret 
09c9			 
09c9			 
09c9			cout: 
09c9				; A - char 
09c9 c9				ret 
09ca			 
09ca			 
09ca			; Display a menu and allow item selection (optional toggle items) 
09ca			; 
09ca			; format: 
09ca			; hl pointer to word array with zero term for items 
09ca			; e.g.    db item1 
09ca			;         db .... 
09ca			;         db 0 
09ca			; 
09ca			; a = starting menu item  
09ca			; 
09ca			; de = pointer item toggle array   (todo) 
09ca			; 
09ca			; returns item selected in a 1-... 
09ca			; returns 0 if back button pressed 
09ca			; 
09ca			; NOTE: Uses system frame buffer to display 
09ca			; 
09ca			; LEFT, Q = go back 
09ca			; RIGHT, SPACE, CR = select 
09ca			; UP, A - Up 
09ca			; DOWN, Z - Down 
09ca			 
09ca			 
09ca			 
09ca			 
09ca			 
09ca			menu: 
09ca			 
09ca					; keep array pointer 
09ca			 
09ca 22 63 eb				ld (store_tmp1), hl 
09cd 32 61 eb				ld (store_tmp2), a 
09d0			 
09d0					; check for key bounce 
09d0			 
09d0			if BASE_KEV 
09d0			 
09d0			.mbounce:	call cin 
09d0					cp 0 
09d0					jr nz, .mbounce 
09d0			endif 
09d0					; for ease use ex 
09d0			 
09d0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09d0 21 c0 ed				ld hl, display_fb0 
09d3 22 db eb				ld (display_fb_active), hl 
09d6			 
09d6 cd 99 09		.mloop:		call clear_display 
09d9 cd bc 09				call update_display 
09dc			 
09dc					; draw selection id '>' at 1 
09dc			 
09dc					; init start of list display 
09dc			 
09dc 3e 05				ld a, 5 
09de 32 5f eb				ld (store_tmp3), a   ; display row count 
09e1 3a 61 eb				ld a,( store_tmp2) 
09e4 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09e7			 
09e7					 
09e7			.mitem:	 
09e7			 
09e7			 
09e7 3a 62 eb				ld a,(store_tmp2+1) 
09ea 6f					ld l, a 
09eb 26 00				ld h, 0 
09ed 29					add hl, hl 
09ee ed 5b 63 eb			ld de, (store_tmp1) 
09f2 19					add hl, de 
09f3 7e					ld a, (hl) 
09f4 23					inc hl 
09f5 66					ld h,(hl) 
09f6 6f					ld l, a 
09f7			 
09f7 cd ef 0b				call ishlzero 
09fa 28 1a				jr z, .mdone 
09fc			 
09fc eb					ex de, hl 
09fd 3a 5f eb				ld a, (store_tmp3) 
0a00 cd ac 09				call str_at_display 
0a03					 
0a03			 
0a03					; next item 
0a03 3a 62 eb				ld a, (store_tmp2+1) 
0a06 3c					inc a 
0a07 32 62 eb				ld (store_tmp2+1), a   ; display item count 
0a0a			 
0a0a			 		; next row 
0a0a			 
0a0a 3a 5f eb				ld a, (store_tmp3) 
0a0d c6 28				add display_cols 
0a0f 32 5f eb				ld (store_tmp3), a 
0a12			 
0a12					; at end of screen? 
0a12			 
0a12 fe 10				cp display_rows*4 
0a14 20 d1				jr nz, .mitem 
0a16			 
0a16			 
0a16			.mdone: 
0a16 cd ef 0b				call ishlzero 
0a19 28 08				jr z, .nodn 
0a1b			 
0a1b 3e 78				ld a, display_row_4 
0a1d 11 9c 0a				ld de, .mdown 
0a20 cd ac 09				call str_at_display 
0a23			 
0a23					; draw options to fill the screens with active item on line 1 
0a23					; if current option is 2 or more then display ^ in top 
0a23			 
0a23 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a26 fe 00				cp 0 
0a28 28 08				jr z, .noup 
0a2a			 
0a2a 3e 00				ld a, 0 
0a2c 11 9a 0a				ld de, .mup 
0a2f cd ac 09				call str_at_display 
0a32			 
0a32 3e 02		.noup:		ld a, 2 
0a34 11 98 0a				ld de, .msel 
0a37 cd ac 09				call str_at_display 
0a3a			 
0a3a					; if current option + 1 is not null then display V in bottom 
0a3a					; get key 
0a3a cd bc 09				call update_display 
0a3d			 
0a3d			 
0a3d					; handle key 
0a3d			 
0a3d cd c6 58				call cin_wait 
0a40			 
0a40 fe 05				cp KEY_UP 
0a42 28 2b				jr z, .mgoup 
0a44 fe 61				cp 'a' 
0a46 28 27				jr z, .mgoup 
0a48 fe 0a				cp KEY_DOWN 
0a4a 28 32				jr z, .mgod 
0a4c fe 7a				cp 'z' 
0a4e 28 2e				jr z, .mgod 
0a50 fe 20				cp ' ' 
0a52 28 34				jr z, .goend 
0a54 fe 0c				cp KEY_RIGHT 
0a56 28 30				jr z, .goend 
0a58 fe 0d				cp KEY_CR 
0a5a 28 2c				jr z, .goend 
0a5c fe 71				cp 'q' 
0a5e 28 0b				jr z, .goback 
0a60			 
0a60 fe 0b				cp KEY_LEFT 
0a62 28 07				jr z, .goback 
0a64 fe 08				cp KEY_BS 
0a66 28 03				jr z, .goback 
0a68 c3 d6 09				jp .mloop 
0a6b			 
0a6b			.goback: 
0a6b 3e 00			ld a, 0 
0a6d 18 1d			jr .goend2 
0a6f			 
0a6f				; move up one 
0a6f			.mgoup: 
0a6f 3a 61 eb				ld a, (store_tmp2) 
0a72 fe 00				cp 0 
0a74 ca d6 09				jp z, .mloop 
0a77 3d					dec a 
0a78 32 61 eb				ld (store_tmp2), a 
0a7b c3 d6 09				jp .mloop 
0a7e			 
0a7e				; move down one 
0a7e			.mgod: 
0a7e 3a 61 eb				ld a, (store_tmp2) 
0a81 3c					inc a 
0a82 32 61 eb				ld (store_tmp2), a 
0a85 c3 d6 09				jp .mloop 
0a88			 
0a88			 
0a88			.goend: 
0a88					; get selected item number 
0a88			 
0a88 3a 61 eb				ld a, (store_tmp2) 
0a8b 3c					inc a 
0a8c			 
0a8c			.goend2: 
0a8c f5					push af 
0a8d			 
0a8d					; restore active fb 
0a8d					; TODO BUG assumes fb1 
0a8d			 
0a8d 21 1f ed				ld hl, display_fb1 
0a90 22 db eb				ld (display_fb_active), hl 
0a93			 
0a93					; restore main regs 
0a93			 
0a93			 
0a93 cd bc 09				call update_display 
0a96			 
0a96 f1					pop af 
0a97			 
0a97 c9				ret 
0a98			 
0a98 .. 00		.msel:   db ">",0 
0a9a .. 00		.mup:   db "^",0 
0a9c .. 00		.mdown:   db "v",0 
0a9e			 
0a9e			 
0a9e			; eof 
0a9e			 
# End of file firmware_display.asm
0a9e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a9e			; random number generators 
0a9e			 
0a9e			 
0a9e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a9e			 
0a9e			 
0a9e			;-----> Generate a random number 
0a9e			; output a=answer 0<=a<=255 
0a9e			; all registers are preserved except: af 
0a9e			random: 
0a9e e5			        push    hl 
0a9f d5			        push    de 
0aa0 2a bd eb		        ld      hl,(randData) 
0aa3 ed 5f		        ld      a,r 
0aa5 57			        ld      d,a 
0aa6 5e			        ld      e,(hl) 
0aa7 19			        add     hl,de 
0aa8 85			        add     a,l 
0aa9 ac			        xor     h 
0aaa 22 bd eb		        ld      (randData),hl 
0aad d1			        pop     de 
0aae e1			        pop     hl 
0aaf c9			        ret 
0ab0			 
0ab0			 
0ab0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ab0			 
0ab0			 
0ab0			 
0ab0			;------LFSR------ 
0ab0			;James Montelongo 
0ab0			;optimized by Spencer Putt 
0ab0			;out: 
0ab0			; a = 8 bit random number 
0ab0			RandLFSR: 
0ab0 21 c3 eb		        ld hl,LFSRSeed+4 
0ab3 5e			        ld e,(hl) 
0ab4 23			        inc hl 
0ab5 56			        ld d,(hl) 
0ab6 23			        inc hl 
0ab7 4e			        ld c,(hl) 
0ab8 23			        inc hl 
0ab9 7e			        ld a,(hl) 
0aba 47			        ld b,a 
0abb cb 13		        rl e  
0abd cb 12			rl d 
0abf cb 11		        rl c  
0ac1 17				rla 
0ac2 cb 13		        rl e  
0ac4 cb 12			rl d 
0ac6 cb 11		        rl c  
0ac8 17				rla 
0ac9 cb 13		        rl e  
0acb cb 12			rl d 
0acd cb 11		        rl c  
0acf 17				rla 
0ad0 67			        ld h,a 
0ad1 cb 13		        rl e  
0ad3 cb 12			rl d 
0ad5 cb 11		        rl c  
0ad7 17				rla 
0ad8 a8			        xor b 
0ad9 cb 13		        rl e  
0adb cb 12			rl d 
0add ac			        xor h 
0ade a9			        xor c 
0adf aa			        xor d 
0ae0 21 c5 eb		        ld hl,LFSRSeed+6 
0ae3 11 c6 eb		        ld de,LFSRSeed+7 
0ae6 01 07 00		        ld bc,7 
0ae9 ed b8		        lddr 
0aeb 12			        ld (de),a 
0aec c9			        ret 
0aed			 
0aed			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0aed			 
0aed			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0aed			 
0aed			 
0aed			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0aed			 
0aed			prng16: 
0aed			;Inputs: 
0aed			;   (seed1) contains a 16-bit seed value 
0aed			;   (seed2) contains a NON-ZERO 16-bit seed value 
0aed			;Outputs: 
0aed			;   HL is the result 
0aed			;   BC is the result of the LCG, so not that great of quality 
0aed			;   DE is preserved 
0aed			;Destroys: 
0aed			;   AF 
0aed			;cycle: 4,294,901,760 (almost 4.3 billion) 
0aed			;160cc 
0aed			;26 bytes 
0aed 2a b7 eb		    ld hl,(seed1) 
0af0 44			    ld b,h 
0af1 4d			    ld c,l 
0af2 29			    add hl,hl 
0af3 29			    add hl,hl 
0af4 2c			    inc l 
0af5 09			    add hl,bc 
0af6 22 b7 eb		    ld (seed1),hl 
0af9 2a b5 eb		    ld hl,(seed2) 
0afc 29			    add hl,hl 
0afd 9f			    sbc a,a 
0afe e6 2d		    and %00101101 
0b00 ad			    xor l 
0b01 6f			    ld l,a 
0b02 22 b5 eb		    ld (seed2),hl 
0b05 09			    add hl,bc 
0b06 c9			    ret 
0b07			 
0b07			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b07			 
0b07			rand32: 
0b07			;Inputs: 
0b07			;   (seed1_0) holds the lower 16 bits of the first seed 
0b07			;   (seed1_1) holds the upper 16 bits of the first seed 
0b07			;   (seed2_0) holds the lower 16 bits of the second seed 
0b07			;   (seed2_1) holds the upper 16 bits of the second seed 
0b07			;   **NOTE: seed2 must be non-zero 
0b07			;Outputs: 
0b07			;   HL is the result 
0b07			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b07			;Destroys: 
0b07			;   AF 
0b07			;Tested and passes all CAcert tests 
0b07			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b07			;it has a period of 18,446,744,069,414,584,320 
0b07			;roughly 18.4 quintillion. 
0b07			;LFSR taps: 0,2,6,7  = 11000101 
0b07			;291cc 
0b07			;seed1_0=$+1 
0b07			;    ld hl,12345 
0b07			;seed1_1=$+1 
0b07			;    ld de,6789 
0b07			;    ld b,h 
0b07			;    ld c,l 
0b07			;    add hl,hl \ rl e \ rl d 
0b07			;    add hl,hl \ rl e \ rl d 
0b07			;    inc l 
0b07			;    add hl,bc 
0b07			;    ld (seed1_0),hl 
0b07			;    ld hl,(seed1_1) 
0b07			;    adc hl,de 
0b07			;    ld (seed1_1),hl 
0b07			;    ex de,hl 
0b07			;seed2_0=$+1 
0b07			;    ld hl,9876 
0b07			;seed2_1=$+1 
0b07			;    ld bc,54321 
0b07			;    add hl,hl \ rl c \ rl b 
0b07			;    ld (seed2_1),bc 
0b07			;    sbc a,a 
0b07			;    and %11000101 
0b07			;    xor l 
0b07			;    ld l,a 
0b07			;    ld (seed2_0),hl 
0b07			;    ex de,hl 
0b07			;    add hl,bc 
0b07			;    ret 
0b07			; 
0b07			 
0b07			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b07			; 20 bytes, 86 cycles (excluding ret) 
0b07			 
0b07			; returns   hl = pseudorandom number 
0b07			; corrupts   a 
0b07			 
0b07			; generates 16-bit pseudorandom numbers with a period of 65535 
0b07			; using the xorshift method: 
0b07			 
0b07			; hl ^= hl << 7 
0b07			; hl ^= hl >> 9 
0b07			; hl ^= hl << 8 
0b07			 
0b07			; some alternative shift triplets which also perform well are: 
0b07			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b07			 
0b07			;  org 32768 
0b07			 
0b07			xrnd: 
0b07 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0b0a 3e 00		  ld a,0 
0b0c bd			  cp l 
0b0d 20 02		  jr nz, .xrnd1 
0b0f 2e 01		  ld l, 1 
0b11			.xrnd1: 
0b11			 
0b11 7c			  ld a,h 
0b12 1f			  rra 
0b13 7d			  ld a,l 
0b14 1f			  rra 
0b15 ac			  xor h 
0b16 67			  ld h,a 
0b17 7d			  ld a,l 
0b18 1f			  rra 
0b19 7c			  ld a,h 
0b1a 1f			  rra 
0b1b ad			  xor l 
0b1c 6f			  ld l,a 
0b1d ac			  xor h 
0b1e 67			  ld h,a 
0b1f			 
0b1f 22 bb eb		  ld (xrandc),hl 
0b22			 
0b22 c9			  ret 
0b23			;  
0b23			 
0b23			 
0b23			;;;; int maths 
0b23			 
0b23			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b23			; Divide 16-bit values (with 16-bit result) 
0b23			; In: Divide BC by divider DE 
0b23			; Out: BC = result, HL = rest 
0b23			; 
0b23			Div16: 
0b23 21 00 00		    ld hl,0 
0b26 78			    ld a,b 
0b27 06 08		    ld b,8 
0b29			Div16_Loop1: 
0b29 17			    rla 
0b2a ed 6a		    adc hl,hl 
0b2c ed 52		    sbc hl,de 
0b2e 30 01		    jr nc,Div16_NoAdd1 
0b30 19			    add hl,de 
0b31			Div16_NoAdd1: 
0b31 10 f6		    djnz Div16_Loop1 
0b33 17			    rla 
0b34 2f			    cpl 
0b35 47			    ld b,a 
0b36 79			    ld a,c 
0b37 48			    ld c,b 
0b38 06 08		    ld b,8 
0b3a			Div16_Loop2: 
0b3a 17			    rla 
0b3b ed 6a		    adc hl,hl 
0b3d ed 52		    sbc hl,de 
0b3f 30 01		    jr nc,Div16_NoAdd2 
0b41 19			    add hl,de 
0b42			Div16_NoAdd2: 
0b42 10 f6		    djnz Div16_Loop2 
0b44 17			    rla 
0b45 2f			    cpl 
0b46 41			    ld b,c 
0b47 4f			    ld c,a 
0b48 c9			ret 
0b49			 
0b49			 
0b49			;http://z80-heaven.wikidot.com/math 
0b49			; 
0b49			;Inputs: 
0b49			;     DE and A are factors 
0b49			;Outputs: 
0b49			;     A is not changed 
0b49			;     B is 0 
0b49			;     C is not changed 
0b49			;     DE is not changed 
0b49			;     HL is the product 
0b49			;Time: 
0b49			;     342+6x 
0b49			; 
0b49			Mult16: 
0b49			 
0b49 06 08		     ld b,8          ;7           7 
0b4b 21 00 00		     ld hl,0         ;10         10 
0b4e 29			       add hl,hl     ;11*8       88 
0b4f 07			       rlca          ;4*8        32 
0b50 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b52 19			         add hl,de   ;--         -- 
0b53 10 f9		       djnz $-5      ;13*7+8     99 
0b55 c9			ret 
0b56			 
0b56			; 
0b56			; Square root of 16-bit value 
0b56			; In:  HL = value 
0b56			; Out:  D = result (rounded down) 
0b56			; 
0b56			;Sqr16: 
0b56			;    ld de,#0040 
0b56			;    ld a,l 
0b56			;    ld l,h 
0b56			;    ld h,d 
0b56			;    or a 
0b56			;    ld b,8 
0b56			;Sqr16_Loop: 
0b56			;    sbc hl,de 
0b56			;    jr nc,Sqr16_Skip 
0b56			;    add hl,de 
0b56			;Sqr16_Skip: 
0b56			;    ccf 
0b56			;    rl d 
0b56			;    add a,a 
0b56			;    adc hl,hl 
0b56			;    add a,a 
0b56			;    adc hl,hl 
0b56			;    djnz Sqr16_Loop 
0b56			;    ret 
0b56			; 
0b56			; 
0b56			; Divide 8-bit values 
0b56			; In: Divide E by divider C 
0b56			; Out: A = result, B = rest 
0b56			; 
0b56			Div8: 
0b56 af			    xor a 
0b57 06 08		    ld b,8 
0b59			Div8_Loop: 
0b59 cb 13		    rl e 
0b5b 17			    rla 
0b5c 91			    sub c 
0b5d 30 01		    jr nc,Div8_NoAdd 
0b5f 81			    add a,c 
0b60			Div8_NoAdd: 
0b60 10 f7		    djnz Div8_Loop 
0b62 47			    ld b,a 
0b63 7b			    ld a,e 
0b64 17			    rla 
0b65 2f			    cpl 
0b66 c9			    ret 
0b67			 
0b67			; 
0b67			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b67			; In: Multiply A with DE 
0b67			; Out: HL = result 
0b67			; 
0b67			Mult12U: 
0b67 2e 00		    ld l,0 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd0 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd0: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd1 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd1: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 30 01		    jr nc,Mult12U_NoAdd2 
0b76 19			    add hl,de 
0b77			Mult12U_NoAdd2: 
0b77 29			    add hl,hl 
0b78 87			    add a,a 
0b79 30 01		    jr nc,Mult12U_NoAdd3 
0b7b 19			    add hl,de 
0b7c			Mult12U_NoAdd3: 
0b7c 29			    add hl,hl 
0b7d 87			    add a,a 
0b7e 30 01		    jr nc,Mult12U_NoAdd4 
0b80 19			    add hl,de 
0b81			Mult12U_NoAdd4: 
0b81 29			    add hl,hl 
0b82 87			    add a,a 
0b83 30 01		    jr nc,Mult12U_NoAdd5 
0b85 19			    add hl,de 
0b86			Mult12U_NoAdd5: 
0b86 29			    add hl,hl 
0b87 87			    add a,a 
0b88 30 01		    jr nc,Mult12U_NoAdd6 
0b8a 19			    add hl,de 
0b8b			Mult12U_NoAdd6: 
0b8b 29			    add hl,hl 
0b8c 87			    add a,a 
0b8d d0			    ret nc 
0b8e 19			    add hl,de 
0b8f c9			    ret 
0b90			 
0b90			; 
0b90			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b90			; In: Multiply A with DE 
0b90			;      Put lowest value in A for most efficient calculation 
0b90			; Out: HL = result 
0b90			; 
0b90			Mult12R: 
0b90 21 00 00		    ld hl,0 
0b93			Mult12R_Loop: 
0b93 cb 3f		    srl a 
0b95 30 01		    jr nc,Mult12R_NoAdd 
0b97 19			    add hl,de 
0b98			Mult12R_NoAdd: 
0b98 cb 23		    sla e 
0b9a cb 12		    rl d 
0b9c b7			    or a 
0b9d c2 93 0b		    jp nz,Mult12R_Loop 
0ba0 c9			    ret 
0ba1			 
0ba1			; 
0ba1			; Multiply 16-bit values (with 32-bit result) 
0ba1			; In: Multiply BC with DE 
0ba1			; Out: BCHL = result 
0ba1			; 
0ba1			Mult32: 
0ba1 79			    ld a,c 
0ba2 48			    ld c,b 
0ba3 21 00 00		    ld hl,0 
0ba6 06 10		    ld b,16 
0ba8			Mult32_Loop: 
0ba8 29			    add hl,hl 
0ba9 17			    rla 
0baa cb 11		    rl c 
0bac 30 07		    jr nc,Mult32_NoAdd 
0bae 19			    add hl,de 
0baf ce 00		    adc a,0 
0bb1 d2 b5 0b		    jp nc,Mult32_NoAdd 
0bb4 0c			    inc c 
0bb5			Mult32_NoAdd: 
0bb5 10 f1		    djnz Mult32_Loop 
0bb7 41			    ld b,c 
0bb8 4f			    ld c,a 
0bb9 c9			    ret 
0bba			 
0bba			 
0bba			 
0bba			; 
0bba			; Multiply 8-bit values 
0bba			; In:  Multiply H with E 
0bba			; Out: HL = result 
0bba			; 
0bba			Mult8: 
0bba 16 00		    ld d,0 
0bbc 6a			    ld l,d 
0bbd 06 08		    ld b,8 
0bbf			Mult8_Loop: 
0bbf 29			    add hl,hl 
0bc0 30 01		    jr nc,Mult8_NoAdd 
0bc2 19			    add hl,de 
0bc3			Mult8_NoAdd: 
0bc3 10 fa		    djnz Mult8_Loop 
0bc5 c9			    ret 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			;;http://z80-heaven.wikidot.com/math 
0bc6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bc6			; 
0bc6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bc6			;     ld a,16        ;7 
0bc6			;     ld hl,0        ;10 
0bc6			;     jp $+5         ;10 
0bc6			;.DivLoop: 
0bc6			;       add hl,bc    ;-- 
0bc6			;       dec a        ;64 
0bc6			;       jr z,.DivLoopEnd        ;86 
0bc6			; 
0bc6			;       sla e        ;128 
0bc6			;       rl d         ;128 
0bc6			;       adc hl,hl    ;240 
0bc6			;       sbc hl,bc    ;240 
0bc6			;       jr nc,.DivLoop ;23|21 
0bc6			;       inc e        ;-- 
0bc6			;       jp .DivLoop+1 
0bc6			; 
0bc6			;.DivLoopEnd: 
0bc6			 
0bc6			;HL_Div_C: 
0bc6			;Inputs: 
0bc6			;     HL is the numerator 
0bc6			;     C is the denominator 
0bc6			;Outputs: 
0bc6			;     A is the remainder 
0bc6			;     B is 0 
0bc6			;     C is not changed 
0bc6			;     DE is not changed 
0bc6			;     HL is the quotient 
0bc6			; 
0bc6			;       ld b,16 
0bc6			;       xor a 
0bc6			;         add hl,hl 
0bc6			;         rla 
0bc6			;         cp c 
0bc6			;         jr c,$+4 
0bc6			;           inc l 
0bc6			;           sub c 
0bc6			;         djnz $-7 
0bc6			 
0bc6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bc6			 
0bc6			addatohl: 
0bc6 85			    add   a, l    ; A = A+L 
0bc7 6f			    ld    l, a    ; L = A+L 
0bc8 8c			    adc   a, h    ; A = A+L+H+carry 
0bc9 95			    sub   l       ; A = H+carry 
0bca 67			    ld    h, a    ; H = H+carry 
0bcb c9			ret 
0bcc			 
0bcc			addatode: 
0bcc 83			    add   a, e    ; A = A+L 
0bcd 5f			    ld    e, a    ; L = A+L 
0bce 8a			    adc   a, d    ; A = A+L+H+carry 
0bcf 93			    sub   e       ; A = H+carry 
0bd0 57			    ld    d, a    ; H = H+carry 
0bd1 c9			ret 
0bd2			 
0bd2			 
0bd2			addatobc: 
0bd2 81			    add   a, c    ; A = A+L 
0bd3 4f			    ld    c, a    ; L = A+L 
0bd4 88			    adc   a, b    ; A = A+L+H+carry 
0bd5 91			    sub   c       ; A = H+carry 
0bd6 47			    ld    b, a    ; H = H+carry 
0bd7 c9			ret 
0bd8			 
0bd8			subafromhl: 
0bd8			   ; If A=0 do nothing 
0bd8			    ; Otherwise flip A's sign. Since 
0bd8			    ; the upper byte becomes -1, also 
0bd8			    ; substract 1 from H. 
0bd8 ed 44		    neg 
0bda ca e3 0b		    jp    z, Skip 
0bdd 25			    dec   h 
0bde			     
0bde			    ; Now add the low byte as usual 
0bde			    ; Two's complement takes care of 
0bde			    ; ensuring the result is correct 
0bde 85			    add   a, l 
0bdf 6f			    ld    l, a 
0be0 8c			    adc   a, h 
0be1 95			    sub   l 
0be2 67			    ld    h, a 
0be3			Skip: 
0be3 c9				ret 
0be4			 
0be4			 
0be4			; compare hl and de 
0be4			; returns:  
0be4			; if hl = de, z=1, s=0, c0=0 
0be4			; if hl > de, z=0, s=0, c=0 
0be4			; if hl < de, z=0, s=1, c=1 
0be4			cmp16:	 
0be4 b7				or a 
0be5 ed 52			sbc hl,de 
0be7 e0				ret po 
0be8 7c				ld a,h 
0be9 1f				rra 
0bea ee 40			xor 01000000B 
0bec 37				scf 
0bed 8f				adc a,a 
0bee c9				ret 
0bef			 
0bef			 
0bef			; test if hl contains zero   - A is destroyed 
0bef			 
0bef			ishlzero:    
0bef b7				or a     ; reset flags 
0bf0 7c				ld a, h 
0bf1 b5				or l        	 
0bf2			 
0bf2 c9				ret 
0bf3			 
0bf3			 
0bf3			 
0bf3			 
0bf3			if FORTH_ENABLE_FLOATMATH 
0bf3			;include "float/bbcmath.z80" 
0bf3			include "float/lpfpcalc.asm" 
0bf3			endif 
0bf3			 
0bf3			 
0bf3			; eof 
0bf3			 
# End of file firmware_maths.asm
0bf3			include "firmware_strings.asm"   ; string handling  
0bf3			 
0bf3			 
0bf3			; TODO string len 
0bf3			; input text string, end on cr with zero term 
0bf3			; a offset into frame buffer to start prompt 
0bf3			; d is max length 
0bf3			; e is display size TODO 
0bf3			; c is current cursor position 
0bf3			; hl is ptr to where string will be stored 
0bf3			 
0bf3			 
0bf3			; TODO check limit of buffer for new inserts 
0bf3			; TODO check insert does not push beyond buffer 
0bf3			; TODO scroll in a limited display area 
0bf3			; TODO scroll whole screen on page wrap 
0bf3			 
0bf3			 
0bf3			; TODO handle KEY_PREVWORD 
0bf3			; TODO handle KEY_NEXTWORD 
0bf3			; TODO handle KEY_HOME 
0bf3			; TODO handle KEY_END 
0bf3			; TODO use LCD cursor? 
0bf3			 
0bf3 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0bf6 81					add c 
0bf7 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0bfa 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0bfd 79					ld a, c 
0bfe cd c6 0b				call addatohl 
0c01 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c04 7a					ld a,d 
0c05 32 75 ee			        ld (input_size), a       ; save length of input area 
0c08 79					ld a, c 
0c09 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0c0c 7b					ld a,e 
0c0d 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c10					 
0c10					 
0c10			 
0c10			;		ld a,(input_ptr) 
0c10			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c10			 
0c10			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c10					; init cursor shape if not set by the cin routines 
0c10 21 d3 eb				ld hl, cursor_shape 
0c13 3e ff				ld a, 255 
0c15 77					ld (hl), a 
0c16 23					inc hl 
0c17 3e 00				ld a, 0 
0c19 77					ld (hl), a 
0c1a			 
0c1a 3e 0f				ld a, CUR_BLINK_RATE 
0c1c 32 6f ee				ld (input_cur_flash), a 
0c1f 3e 01				ld a, 1 
0c21 32 6e ee				ld (input_cur_onoff),a 
0c24			 
0c24			;	if DEBUG_INPUT 
0c24			;		push af 
0c24			;		ld a, 'I' 
0c24			;		ld (debug_mark),a 
0c24			;		pop af 
0c24			;		CALLMONITOR 
0c24			;	endif 
0c24			.is1:		; main entry loop 
0c24			 
0c24			 
0c24			 
0c24					; pause 1ms 
0c24			 
0c24 3e 01				ld a, 1 
0c26 cd f3 08				call aDelayInMS 
0c29			 
0c29					; dec flash counter 
0c29 3a 6f ee				ld a, (input_cur_flash) 
0c2c 3d					dec a 
0c2d 32 6f ee				ld (input_cur_flash), a 
0c30 fe 00				cp 0 
0c32 20 0d				jr nz, .nochgstate 
0c34			 
0c34			 
0c34					; change state 
0c34 3a 6e ee				ld a,(input_cur_onoff) 
0c37 ed 44				neg 
0c39 32 6e ee				ld (input_cur_onoff),a 
0c3c			 
0c3c			 
0c3c					; reset on change of state 
0c3c 3e 0f				ld a, CUR_BLINK_RATE 
0c3e 32 6f ee				ld (input_cur_flash), a 
0c41			 
0c41			.nochgstate: 
0c41					 
0c41					 
0c41			 
0c41					; display cursor  
0c41			 
0c41			;		ld hl, (input_start) 
0c41			;		ld a, (input_cursor) 
0c41			;		call addatohl 
0c41			 
0c41					; get char under cursor and replace with cursor 
0c41 2a 78 ee		ld hl, (input_ptr) 
0c44			;		ld a, (hl) 
0c44			;		ld (input_under_cursor),a 
0c44			;		ld a, '_' 
0c44			;		ld (hl), a 
0c44			 
0c44					; display string 
0c44			 
0c44 ed 5b 76 ee			ld de, (input_start) 
0c48 3a 73 ee				ld a, (input_at_pos) 
0c4b cd ac 09				call str_at_display 
0c4e			;	        call update_display 
0c4e			 
0c4e					; find place to put the cursor 
0c4e			;		add h 
0c4e			;		ld l, display_row_1 
0c4e			;		sub l 
0c4e			; (input_at_pos) 
0c4e					;ld c, a 
0c4e			;		ld a, (input_cursor) 
0c4e			;		ld l, (input_at_pos) 
0c4e			;		;ld b, h 
0c4e			;		add l 
0c4e			;		ld (input_at_cursor),a 
0c4e					;ld l,h 
0c4e			 
0c4e			;		ld h, 0 
0c4e			;		ld l,(input_at_pos) 
0c4e			;		ld a, (input_cursor) 
0c4e			;		call addatohl 
0c4e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c4e			;		call subafromhl 
0c4e			;		ld a,l 
0c4e			;		ld (input_at_cursor), a 
0c4e			 
0c4e				if DEBUG_INPUT 
0c4e					ld a, (hardware_diag) 
0c4e					cp 0 
0c4e					jr z, .skip_input_diag 
0c4e			 
0c4e					ld a,(input_at_pos) 
0c4e					ld hl, LFSRSeed 
0c4e					call hexout 
0c4e					ld a, (input_cursor) 
0c4e					ld hl, LFSRSeed+2 
0c4e					call hexout 
0c4e					ld a,(input_at_cursor) 
0c4e					ld hl, LFSRSeed+4 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_cur_onoff) 
0c4e					ld hl, LFSRSeed+6 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_cur_flash) 
0c4e					ld hl, LFSRSeed+8 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_len) 
0c4e					ld hl, LFSRSeed+10 
0c4e					call hexout 
0c4e					ld hl, LFSRSeed+12 
0c4e					ld a, 0 
0c4e					ld (hl),a 
0c4e					ld a, display_row_4 
0c4e					ld de, LFSRSeed 
0c4e					call str_at_display 
0c4e					.skip_input_diag: 
0c4e				endif 
0c4e			 
0c4e					; decide on if we are showing the cursor this time round 
0c4e			 
0c4e 3a 6e ee				ld a, (input_cur_onoff) 
0c51 fe ff				cp 255 
0c53 28 13				jr z, .skipcur 
0c55			 
0c55			 
0c55 3a 71 ee				ld a,(input_at_cursor) 
0c58 11 d3 eb				ld de, cursor_shape 
0c5b cd ac 09				call str_at_display 
0c5e			 
0c5e					; save length of current input string 
0c5e 2a 76 ee				ld hl, (input_start) 
0c61 cd 24 10				call strlenz 
0c64 7d					ld a,l 
0c65 32 69 ee				ld (input_len),a 
0c68			 
0c68			.skipcur: 
0c68			 
0c68 cd bc 09			        call update_display 
0c6b					 
0c6b			 
0c6b			 
0c6b					; wait 
0c6b				 
0c6b					; TODO loop without wait to flash the cursor and char under cursor	 
0c6b cd ce 58				call cin    ; _wait 
0c6e			 
0c6e fe 00				cp 0 
0c70 ca 24 0c				jp z, .is1 
0c73			 
0c73					; get ptr to char to input into 
0c73			 
0c73 4f					ld c,a 
0c74 2a 76 ee				ld hl, (input_start) 
0c77 3a 64 ee				ld a, (input_cursor) 
0c7a cd c6 0b				call addatohl 
0c7d 22 78 ee				ld (input_ptr), hl 
0c80 79					ld a,c 
0c81			 
0c81					; replace char under cursor 
0c81			 
0c81			;		ld hl, (input_ptr) 
0c81			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c81			;		ld (hl), a 
0c81			 
0c81			;	if DEBUG_INPUT 
0c81			;		push af 
0c81			;		ld a, 'i' 
0c81			;		ld (debug_mark),a 
0c81			;		pop af 
0c81			;		CALLMONITOR 
0c81			;	endif 
0c81 fe 0e				cp KEY_HOME 
0c83 20 0e				jr nz, .iske 
0c85			 
0c85 3a 73 ee				ld a, (input_at_pos) 
0c88 32 71 ee				ld (input_at_cursor),a 
0c8b 3e 00				ld a, 0 
0c8d 32 64 ee				ld (input_cursor), a 
0c90 c3 24 0c				jp .is1 
0c93					 
0c93 fe 0f		.iske:		cp KEY_END 
0c95 20 03				jr nz, .isknw 
0c97 c3 24 0c				jp .is1 
0c9a			 
0c9a fe 06		.isknw:		cp KEY_NEXTWORD 
0c9c 20 1b				jr nz, .iskpw 
0c9e			 
0c9e 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0ca1 7e					ld a,(hl)	 
0ca2 fe 00				cp 0 
0ca4 ca 24 0c				jp z, .is1    ; end of string 
0ca7 fe 20				cp ' ' 
0ca9 ca 24 0c				jp z, .is1    ; end of word 
0cac 23					inc hl 
0cad 22 78 ee				ld (input_ptr), hl 
0cb0 3a 71 ee				ld a, (input_at_cursor) 
0cb3 3c					inc a 
0cb4 32 71 ee				ld (input_at_cursor), a 
0cb7 18 e5				jr .isknwm 
0cb9			 
0cb9 fe 07		.iskpw:		cp KEY_PREVWORD 
0cbb 20 1b				jr nz, .iskl 
0cbd			.iskpwm:	 
0cbd 2a 78 ee				ld hl, (input_ptr) 
0cc0 7e					ld a,(hl)	 
0cc1 fe 00				cp 0  
0cc3 ca 24 0c				jp z, .is1    ; end of string 
0cc6 fe 20				cp ' ' 
0cc8 ca 24 0c				jp z, .is1    ; end of word 
0ccb 2b					dec hl 
0ccc 22 78 ee				ld (input_ptr), hl 
0ccf 3a 71 ee				ld a, (input_at_cursor) 
0cd2 3d					dec a 
0cd3 32 71 ee				ld (input_at_cursor), a 
0cd6 18 e5				jr .iskpwm 
0cd8			 
0cd8			 
0cd8 fe 0b		.iskl:		cp KEY_LEFT 
0cda 20 27				jr nz, .isk1 
0cdc			 
0cdc 3a 64 ee				ld a, (input_cursor) 
0cdf			 
0cdf fe 00				cp 0 
0ce1 ca 24 0c				jp z, .is1 		; at start of line to ignore  
0ce4			 
0ce4 3d					dec  a 		; TODO check underflow 
0ce5 32 64 ee				ld (input_cursor), a 
0ce8			 
0ce8 2a 78 ee				ld hl, (input_ptr) 
0ceb 2b					dec hl 
0cec 22 78 ee				ld (input_ptr), hl 
0cef					 
0cef 3a 71 ee				ld a, (input_at_cursor) 
0cf2 3d					dec a 
0cf3 32 71 ee				ld (input_at_cursor), a 
0cf6			 
0cf6 3e 01				ld a, 1		; show cursor moving 
0cf8 32 6e ee				ld (input_cur_onoff),a 
0cfb 3e 0f				ld a, CUR_BLINK_RATE 
0cfd 32 6f ee				ld (input_cur_flash), a 
0d00			 
0d00 c3 24 0c				jp .is1 
0d03			 
0d03 fe 0c		.isk1:		cp KEY_RIGHT 
0d05 20 2a				jr nz, .isk2 
0d07			 
0d07 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d0a 5f					ld e,a 
0d0b 3a 64 ee				ld a, (input_cursor) 
0d0e bb					cp e 
0d0f ca 24 0c				jp z, .is1		; at the end of string so dont go right 
0d12			 
0d12 3c					inc  a 		; TODO check overflow 
0d13 32 64 ee				ld (input_cursor), a 
0d16			 
0d16 3a 71 ee				ld a, (input_at_cursor) 
0d19 3c					inc a 
0d1a 32 71 ee				ld (input_at_cursor), a 
0d1d			 
0d1d 2a 78 ee				ld hl, (input_ptr) 
0d20 23					inc hl 
0d21 22 78 ee				ld (input_ptr), hl 
0d24			 
0d24 3e 01				ld a, 1		; show cursor moving 
0d26 32 6e ee				ld (input_cur_onoff),a 
0d29 3e 0f				ld a, CUR_BLINK_RATE 
0d2b 32 6f ee				ld (input_cur_flash), a 
0d2e			 
0d2e c3 24 0c				jp .is1 
0d31			 
0d31 fe 05		.isk2:		cp KEY_UP 
0d33			 
0d33 20 26				jr nz, .isk3 
0d35			 
0d35					; swap last command with the current on 
0d35			 
0d35					; move cursor to start of string 
0d35 2a 76 ee				ld hl, (input_start) 
0d38 22 78 ee				ld (input_ptr), hl 
0d3b			 
0d3b 3a 73 ee				ld a, (input_at_pos) 
0d3e 32 71 ee				ld (input_at_cursor), a 
0d41			 
0d41 3e 00				ld a, 0 
0d43 32 64 ee				ld (input_cursor), a 
0d46					 
0d46					; swap input and last command buffers 
0d46			 
0d46 21 87 e6				ld hl, os_cli_cmd 
0d49 11 86 e7				ld de, os_last_cmd 
0d4c 06 ff				ld b, 255 
0d4e 7e			.swap1:		ld a, (hl) 
0d4f 4f					ld c,a 
0d50 1a					ld a, (de) 
0d51 77					ld (hl), a 
0d52 79					ld a,c 
0d53 12					ld (de),a 
0d54 23					inc hl 
0d55 13					inc de 
0d56 10 f6				djnz .swap1 
0d58			 
0d58			 
0d58			 
0d58			 
0d58			 
0d58 c3 24 0c				jp .is1 
0d5b			 
0d5b fe 08		.isk3:		cp KEY_BS 
0d5d 20 3c				jr nz, .isk4 
0d5f			 
0d5f 3a 64 ee				ld a, (input_cursor) 
0d62			 
0d62 fe 00				cp 0 
0d64 ca 24 0c				jp z, .is1 		; at start of line to ignore  
0d67			 
0d67 3d					dec  a 		; TODO check underflow 
0d68 32 64 ee				ld (input_cursor), a 
0d6b			 
0d6b					; hl is source 
0d6b					; de needs to be source - 1 
0d6b			 
0d6b			;		ld a, 0 
0d6b			;		dec hl 
0d6b			;		ld (hl), a 
0d6b			 
0d6b 2a 78 ee				ld hl, (input_ptr) 
0d6e 2b					dec hl 
0d6f 22 78 ee				ld (input_ptr), hl 
0d72			 
0d72					; shift all data 
0d72			 
0d72 e5					push hl 
0d73 23					inc hl 
0d74 d1					pop de 
0d75 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d78 4f					ld c,a 
0d79 06 00				ld b,0 
0d7b ed b0				ldir  
0d7d			 
0d7d			 
0d7d			 
0d7d			 
0d7d 3a 71 ee				ld a, (input_at_cursor) 
0d80 3d					dec a 
0d81 32 71 ee				ld (input_at_cursor), a 
0d84			 
0d84			 
0d84 3e 01				ld a, 1		; show cursor moving 
0d86 32 6e ee				ld (input_cur_onoff),a 
0d89 3e 0f				ld a, CUR_BLINK_RATE 
0d8b 32 6f ee				ld (input_cur_flash), a 
0d8e			 
0d8e					; remove char 
0d8e 3a 71 ee				ld a, (input_at_cursor) 
0d91 3c					inc a 
0d92 11 1c 0e				ld de,.iblank 
0d95 cd ac 09				call str_at_display 
0d98			 
0d98 c3 24 0c				jp .is1 
0d9b			 
0d9b fe 0d		.isk4:		cp KEY_CR 
0d9d 28 6c				jr z, .endinput 
0d9f			 
0d9f					; else add the key press to the end 
0d9f			 
0d9f 4f					ld c, a			; save key pressed 
0da0			 
0da0 7e					ld a,(hl)		; get what is currently under char 
0da1			 
0da1 fe 00				cp 0			; we are at the end of the string 
0da3 20 2f				jr nz, .onchar 
0da5					 
0da5					; add a char to the end of the string 
0da5				 
0da5 71					ld (hl),c 
0da6 23					inc hl 
0da7			;		ld a,' ' 
0da7			;		ld (hl),a 
0da7			;		inc hl 
0da7 3e 00				ld a,0 
0da9 77					ld (hl),a 
0daa 2b					dec hl 
0dab			 
0dab 3a 64 ee				ld a, (input_cursor) 
0dae 3c					inc a				; TODO check max string length and scroll  
0daf 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0db2							 
0db2 3a 71 ee				ld a, (input_at_cursor) 
0db5 3c					inc a 
0db6 32 71 ee				ld (input_at_cursor), a 
0db9			 
0db9 2a 78 ee				ld hl, (input_ptr) 
0dbc 23					inc hl 
0dbd 22 78 ee				ld (input_ptr), hl 
0dc0			 
0dc0 2a 78 ee				ld hl, (input_ptr) 
0dc3 23					inc hl 
0dc4 22 78 ee				ld (input_ptr), hl 
0dc7			;	if DEBUG_INPUT 
0dc7			;		push af 
0dc7			;		ld a, '+' 
0dc7			;		ld (debug_mark),a 
0dc7			;		pop af 
0dc7			;		CALLMONITOR 
0dc7			;	endif 
0dc7 3e 01				ld a, 1		; show cursor moving 
0dc9 32 6e ee				ld (input_cur_onoff),a 
0dcc 3e 0f				ld a, CUR_BLINK_RATE 
0dce 32 6f ee				ld (input_cur_flash), a 
0dd1 c3 24 0c				jp .is1 
0dd4					 
0dd4			 
0dd4			 
0dd4					; if on a char then insert 
0dd4			.onchar: 
0dd4			 
0dd4					; TODO over flow check: make sure insert does not blow out buffer 
0dd4			 
0dd4					; need to do some maths to use lddr 
0dd4			 
0dd4 e5					push hl   ; save char pos 
0dd5 c5					push bc 
0dd6			 
0dd6 2a 76 ee				ld hl, (input_start) 
0dd9 3a 69 ee				ld a, (input_len) 
0ddc cd c6 0b				call addatohl  		; end of string 
0ddf 23					inc hl 
0de0 23					inc hl		; past zero term 
0de1 e5					push hl 
0de2 23					inc hl 
0de3 e5					push hl  
0de4			 
0de4								; start and end of lddr set, now how much to move? 
0de4			 
0de4							 
0de4 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0de7 47					ld b,a 
0de8 3a 69 ee				ld a,(input_len) 
0deb 5f					ld e,a 
0dec 90					sub b 
0ded 3c					inc a		;?? 
0dee 3c					inc a		;?? 
0def 3c					inc a		;?? 
0df0			 
0df0 06 00				ld b,0 
0df2 4f					ld c,a 
0df3			 
0df3				if DEBUG_INPUT 
0df3					push af 
0df3					ld a, 'i' 
0df3					ld (debug_mark),a 
0df3					pop af 
0df3			;		CALLMONITOR 
0df3				endif 
0df3 d1					pop de 
0df4 e1					pop hl 
0df5				if DEBUG_INPUT 
0df5					push af 
0df5					ld a, 'I' 
0df5					ld (debug_mark),a 
0df5					pop af 
0df5			;		CALLMONITOR 
0df5				endif 
0df5 ed b8				lddr 
0df7				 
0df7			 
0df7			 
0df7					; TODO have a key for insert/overwrite mode???? 
0df7 c1					pop bc 
0df8 e1					pop hl 
0df9 71					ld (hl), c		; otherwise overwrite current char 
0dfa					 
0dfa			 
0dfa			 
0dfa			 
0dfa 3a 64 ee				ld a, (input_cursor) 
0dfd 3c					inc  a 		; TODO check overflow 
0dfe 32 64 ee				ld (input_cursor), a 
0e01			 
0e01 3a 71 ee				ld a, (input_at_cursor) 
0e04 3c					inc a 
0e05 32 71 ee				ld (input_at_cursor), a 
0e08			 
0e08 c3 24 0c				jp .is1 
0e0b			 
0e0b			.endinput:	; TODO look for end of string 
0e0b			 
0e0b					; add trailing space for end of token 
0e0b			 
0e0b 2a 76 ee				ld hl, (input_start) 
0e0e 3a 69 ee				ld a,(input_len) 
0e11 cd c6 0b				call addatohl 
0e14 3e 20				ld a, ' ' 
0e16 77					ld (hl),a 
0e17					; TODO eof of parse marker 
0e17			 
0e17 23					inc hl 
0e18 3e 00				ld a, 0 
0e1a 77					ld (hl),a 
0e1b			 
0e1b			 
0e1b c9					ret 
0e1c			 
0e1c .. 00		.iblank: db " ",0 
0e1e			 
0e1e			 
0e1e 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e21 22 76 ee				ld (input_start), hl 
0e24 3e 01				ld a,1			; add cursor 
0e26 77					ld (hl),a 
0e27 23					inc hl 
0e28 3e 00				ld a,0 
0e2a 77					ld (hl),a 
0e2b 22 78 ee				ld (input_ptr), hl 
0e2e 7a					ld a,d 
0e2f 32 75 ee				ld (input_size), a 
0e32 3e 00				ld a,0 
0e34 32 64 ee				ld (input_cursor),a 
0e37			.instr1:	 
0e37			 
0e37					; TODO do block cursor 
0e37					; TODO switch cursor depending on the modifer key 
0e37			 
0e37					; update cursor shape change on key hold 
0e37			 
0e37 2a 78 ee				ld hl, (input_ptr) 
0e3a 2b					dec hl 
0e3b 3a d3 eb				ld a,(cursor_shape) 
0e3e 77					ld (hl), a 
0e3f			 
0e3f					; display entered text 
0e3f 3a 73 ee				ld a,(input_at_pos) 
0e42 cd e3 57		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e45 ed 5b 76 ee	            	LD   de, (input_start) 
0e49 cd d8 57		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e4c			 
0e4c cd ce 58				call cin 
0e4f fe 00				cp 0 
0e51 28 e4				jr z, .instr1 
0e53			 
0e53					; proecess keyboard controls first 
0e53			 
0e53 2a 78 ee				ld hl,(input_ptr) 
0e56			 
0e56 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e58 28 5a				jr z, .instrcr 
0e5a			 
0e5a fe 08				cp KEY_BS 	; back space 
0e5c 20 0f				jr nz, .instr2 
0e5e					; process back space 
0e5e			 
0e5e					; TODO stop back space if at start of string 
0e5e 2b					dec hl 
0e5f 2b					dec hl ; to over write cursor 
0e60 3a d3 eb				ld a,(cursor_shape) 
0e63					;ld a,0 
0e63 77					ld (hl),a 
0e64 23					inc hl 
0e65 3e 20				ld a," " 
0e67 77					ld (hl),a 
0e68 22 78 ee				ld (input_ptr),hl 
0e6b					 
0e6b			 
0e6b 18 ca				jr .instr1 
0e6d			 
0e6d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e6f 20 06				jr nz, .instr3 
0e71 2b					dec hl 
0e72 22 78 ee				ld (input_ptr),hl 
0e75 18 c0				jr .instr1 
0e77				 
0e77 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e79 20 06				jr nz, .instr4 
0e7b 23					inc hl 
0e7c 22 78 ee				ld (input_ptr),hl 
0e7f 18 b6				jr .instr1 
0e81			 
0e81 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e83 20 06				jr nz, .instr5 
0e85 2b					dec hl 
0e86 22 78 ee				ld (input_ptr),hl 
0e89 18 ac				jr .instr1 
0e8b			 
0e8b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e8d 20 06				jr nz, .instr6 
0e8f 2b					dec hl 
0e90 22 78 ee				ld (input_ptr),hl 
0e93 18 a2				jr .instr1 
0e95 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e97 20 0b				jr nz, .instrnew 
0e99			 
0e99 21 60 e3			ld hl, scratch 
0e9c 11 86 e7			ld de, os_last_cmd 
0e9f cd bd 0e			call strcpy 
0ea2 18 93				jr .instr1 
0ea4			 
0ea4			 
0ea4			.instrnew:	; no special key pressed to see if we have room to store it 
0ea4			 
0ea4					; TODO do string size test 
0ea4			 
0ea4 2b					dec hl ; to over write cursor 
0ea5 77					ld (hl),a 
0ea6 23					inc hl 
0ea7 3a d3 eb				ld a,(cursor_shape) 
0eaa 77					ld (hl),a 
0eab 23					inc hl 
0eac 3e 00				ld a,0 
0eae 77					ld (hl),a 
0eaf			 
0eaf 22 78 ee				ld (input_ptr),hl 
0eb2					 
0eb2 18 83				jr .instr1 
0eb4 2b			.instrcr:	dec hl		; remove cursor 
0eb5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0eb7 77					ld (hl),a 
0eb8 23					inc hl 
0eb9 3e 00				ld a,0 
0ebb 77					ld (hl),a 
0ebc			 
0ebc			 
0ebc					; if at end of line scroll up    
0ebc					; TODO detecting only end of line 4 for scroll up  
0ebc			 
0ebc					;ld   
0ebc			 
0ebc c9					ret 
0ebd			 
0ebd			 
0ebd			; strcpy hl = dest, de source 
0ebd			 
0ebd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ebe b7			            OR   A              ;Null terminator? 
0ebf c8			            RET  Z              ;Yes, so finished 
0ec0 1a					ld a,(de) 
0ec1 77					ld (hl),a 
0ec2 13			            INC  DE             ;Point to next character 
0ec3 23					inc hl 
0ec4 18 f7		            JR   strcpy       ;Repeat 
0ec6 c9					ret 
0ec7			 
0ec7			 
0ec7			; TODO string_at  
0ec7			; pass string which starts with lcd offset address and then null term string 
0ec7			 
0ec7			; TODO string to dec 
0ec7			; TODO string to hex 
0ec7			; TODO byte to string hex 
0ec7			; TODO byte to string dec 
0ec7			 
0ec7			 
0ec7			 
0ec7			; from z80uartmonitor 
0ec7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ec7			; pass hl for where to put the text 
0ec7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec7 c5			hexout:	PUSH BC 
0ec8 f5					PUSH AF 
0ec9 47					LD B, A 
0eca					; Upper nybble 
0eca cb 3f				SRL A 
0ecc cb 3f				SRL A 
0ece cb 3f				SRL A 
0ed0 cb 3f				SRL A 
0ed2 cd e2 0e				CALL tohex 
0ed5 77					ld (hl),a 
0ed6 23					inc hl	 
0ed7					 
0ed7					; Lower nybble 
0ed7 78					LD A, B 
0ed8 e6 0f				AND 0FH 
0eda cd e2 0e				CALL tohex 
0edd 77					ld (hl),a 
0ede 23					inc hl	 
0edf					 
0edf f1					POP AF 
0ee0 c1					POP BC 
0ee1 c9					RET 
0ee2					 
0ee2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ee2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee2			tohex: 
0ee2 e5					PUSH HL 
0ee3 d5					PUSH DE 
0ee4 16 00				LD D, 0 
0ee6 5f					LD E, A 
0ee7 21 ef 0e				LD HL, .DATA 
0eea 19					ADD HL, DE 
0eeb 7e					LD A, (HL) 
0eec d1					POP DE 
0eed e1					POP HL 
0eee c9					RET 
0eef			 
0eef			.DATA: 
0eef 30					DEFB	30h	; 0 
0ef0 31					DEFB	31h	; 1 
0ef1 32					DEFB	32h	; 2 
0ef2 33					DEFB	33h	; 3 
0ef3 34					DEFB	34h	; 4 
0ef4 35					DEFB	35h	; 5 
0ef5 36					DEFB	36h	; 6 
0ef6 37					DEFB	37h	; 7 
0ef7 38					DEFB	38h	; 8 
0ef8 39					DEFB	39h	; 9 
0ef9 41					DEFB	41h	; A 
0efa 42					DEFB	42h	; B 
0efb 43					DEFB	43h	; C 
0efc 44					DEFB	44h	; D 
0efd 45					DEFB	45h	; E 
0efe 46					DEFB	46h	; F 
0eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eff			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eff			;;    subtract $30, if result > 9 then subtract $7 more 
0eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eff			atohex: 
0eff d6 30				SUB $30 
0f01 fe 0a				CP 10 
0f03 f8					RET M		; If result negative it was 0-9 so we're done 
0f04 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f06 c9					RET		 
0f07			 
0f07			 
0f07			 
0f07			 
0f07			; Get 2 ASCII characters as hex byte from pointer in hl 
0f07			 
0f07			BYTERD: 
0f07 16 00			LD	D,00h		;Set up 
0f09 cd 11 0f			CALL	HEXCON		;Get byte and convert to hex 
0f0c 87				ADD	A,A		;First nibble so 
0f0d 87				ADD	A,A		;multiply by 16 
0f0e 87				ADD	A,A		; 
0f0f 87				ADD	A,A		; 
0f10 57				LD	D,A		;Save hi nibble in D 
0f11			HEXCON: 
0f11 7e				ld a, (hl)		;Get next chr 
0f12 23				inc hl 
0f13 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f15 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f17 38 02			JR	C,NALPHA	;If so miss next bit 
0f19 d6 07			SUB	007h		;Else convert alpha 
0f1b			NALPHA: 
0f1b b2				OR	D		;Add hi nibble back 
0f1c c9				RET			; 
0f1d			 
0f1d			 
0f1d			; 
0f1d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f1d			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f1d			; characters (0-9a-f) are accepted. 
0f1d			; 
0f1d			;get_word        push    af 
0f1d			;                call    get_byte        ; Get the upper byte 
0f1d			;                ld      h, a 
0f1d			;                call    get_byte        ; Get the lower byte 
0f1d			;                ld      l, a 
0f1d			;                pop     af 
0f1d			;                ret 
0f1d			; 
0f1d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f1d			; the routine get_nibble is used only valid characters are accepted - the  
0f1d			; input routine only accepts characters 0-9a-f. 
0f1d			; 
0f1d c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f1e 7e					ld a,(hl) 
0f1f 23					inc hl 
0f20 cd 45 0f		                call    nibble2val      ; Get upper nibble 
0f23 cb 07		                rlc     a 
0f25 cb 07		                rlc     a 
0f27 cb 07		                rlc     a 
0f29 cb 07		                rlc     a 
0f2b 47			                ld      b, a            ; Save upper four bits 
0f2c 7e					ld a,(hl) 
0f2d cd 45 0f		                call    nibble2val      ; Get lower nibble 
0f30 b0			                or      b               ; Combine both nibbles 
0f31 c1			                pop     bc              ; Restore B (and C) 
0f32 c9			                ret 
0f33			; 
0f33			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f33			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f33			; to the serial line interface. The lower 4 bits of A contain the value of  
0f33			; that particular digit. 
0f33			; 
0f33			;get_nibble      ld a,(hl)           ; Read a character 
0f33			;                call    to_upper        ; Convert to upper case 
0f33			;                call    is_hex          ; Was it a hex digit? 
0f33			;                jr      nc, get_nibble  ; No, get another character 
0f33			 ;               call    nibble2val      ; Convert nibble to value 
0f33			 ;               call    print_nibble 
0f33			 ;               ret 
0f33			; 
0f33			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f33			; A valid hexadecimal digit is denoted by a set C flag. 
0f33			; 
0f33			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f33			;                ret     nc              ; Yes 
0f33			;                cp      '0'             ; Less than '0'? 
0f33			;                jr      nc, is_hex_1    ; No, continue 
0f33			;                ccf                     ; Complement carry (i.e. clear it) 
0f33			;                ret 
0f33			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f33			;                ret     c               ; Yes 
0f33			;                cp      'A'             ; Less than 'A'? 
0f33			;                jr      nc, is_hex_2    ; No, continue 
0f33			;                ccf                     ; Yes - clear carry and return 
0f33			;                ret 
0f33			;is_hex_2        scf                     ; Set carry 
0f33			;                ret 
0f33			; 
0f33			; Convert a single character contained in A to upper case: 
0f33			; 
0f33 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f35 d8			                ret     c 
0f36 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f38 d0			                ret     nc              ; Nothing to do, either 
0f39 e6 5f		                and     $5f             ; Convert to upper case 
0f3b c9			                ret 
0f3c			 
0f3c			 
0f3c			to_lower: 
0f3c			 
0f3c			   ; if char is in [A-Z] make it lower case 
0f3c			 
0f3c			   ; enter : a = char 
0f3c			   ; exit  : a = lower case char 
0f3c			   ; uses  : af 
0f3c			 
0f3c fe 41		   cp 'A' 
0f3e d8			   ret c 
0f3f			    
0f3f fe 5b		   cp 'Z'+1 
0f41 d0			   ret nc 
0f42			    
0f42 f6 20		   or $20 
0f44 c9			   ret 
0f45			 
0f45			; 
0f45			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f45			; corresponding value in A. 
0f45			; 
0f45 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f47 38 02		                jr      c, nibble2val_1 ; Yes 
0f49 d6 07		                sub     7               ; Adjust for A-F 
0f4b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f4d e6 0f		                and     $f              ; Only return lower 4 bits 
0f4f c9			                ret 
0f50			; 
0f50			; Print_nibble prints a single hex nibble which is contained in the lower  
0f50			; four bits of A: 
0f50			; 
0f50			;print_nibble    push    af              ; We won't destroy the contents of A 
0f50			;                and     $f              ; Just in case... 
0f50			;                add     a, '0'             ; If we have a digit we are done here. 
0f50			;                cp      '9' + 1         ; Is the result > 9? 
0f50			;                jr      c, print_nibble_1 
0f50			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f50			;print_nibble_1  call    putc            ; Print the nibble and 
0f50			;                pop     af              ; restore the original value of A 
0f50			;                ret 
0f50			;; 
0f50			;; Send a CR/LF pair: 
0f50			; 
0f50			;crlf            push    af 
0f50			;                ld      a, cr 
0f50			;                call    putc 
0f50			;                ld      a, lf 
0f50			;                call    putc 
0f50			;                pop     af 
0f50			;                ret 
0f50			; 
0f50			; Print_word prints the four hex digits of a word to the serial line. The  
0f50			; word is expected to be in HL. 
0f50			; 
0f50			;print_word      push    hl 
0f50			;                push    af 
0f50			;                ld      a, h 
0f50			;                call    print_byte 
0f50			;                ld      a, l 
0f50			;                call    print_byte 
0f50			;                pop     af 
0f50			;                pop     hl 
0f50			;                ret 
0f50			; 
0f50			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f50			; The byte to be printed is expected to be in A. 
0f50			; 
0f50			;print_byte      push    af              ; Save the contents of the registers 
0f50			;                push    bc 
0f50			;                ld      b, a 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                call    print_nibble    ; Print high nibble 
0f50			;                ld      a, b 
0f50			;                call    print_nibble    ; Print low nibble 
0f50			;                pop     bc              ; Restore original register contents 
0f50			;                pop     af 
0f50			;                ret 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			fourehexhl:  
0f50 7e				ld a,(hl) 
0f51 cd ff 0e			call atohex 
0f54 cb 3f				SRL A 
0f56 cb 3f				SRL A 
0f58 cb 3f				SRL A 
0f5a cb 3f				SRL A 
0f5c 47				ld b, a 
0f5d 23				inc hl 
0f5e 7e				ld a,(hl) 
0f5f 23				inc hl 
0f60 cd ff 0e			call atohex 
0f63 80				add b 
0f64 57				ld d,a 
0f65 7e				ld a,(hl) 
0f66 cd ff 0e			call atohex 
0f69 cb 3f				SRL A 
0f6b cb 3f				SRL A 
0f6d cb 3f				SRL A 
0f6f cb 3f				SRL A 
0f71 47				ld b, a 
0f72 23				inc hl 
0f73 7e				ld a,(hl) 
0f74 23				inc hl 
0f75 cd ff 0e			call atohex 
0f78 80				add b 
0f79 5f				ld e, a 
0f7a d5				push de 
0f7b e1				pop hl 
0f7c c9				ret 
0f7d			 
0f7d			; pass hl. returns z set if the byte at hl is a digit 
0f7d			;isdigithl:  
0f7d			;	push bc 
0f7d			;	ld a,(hl) 
0f7d			;	cp ':' 
0f7d			;	jr nc, .isdf 		; > 
0f7d			;	cp '0' 
0f7d			;	jr c, .isdf		; < 
0f7d			; 
0f7d			;	; TODO find a better way to set z 
0f7d			; 
0f7d			;	ld b,a 
0f7d			;	cp b 
0f7d			;	pop bc 
0f7d			;	ret 
0f7d			; 
0f7d			;.isdf:	; not digit so clear z 
0f7d			; 
0f7d			;	; TODO find a better way to unset z 
0f7d			; 
0f7d			;	ld b,a 
0f7d			;	inc b 
0f7d			;	cp b 
0f7d			; 
0f7d			;	pop bc 
0f7d			;	ret 
0f7d				 
0f7d				 
0f7d			 
0f7d			 
0f7d			; pass hl as the four byte address to load 
0f7d			 
0f7d			get_word_hl:  
0f7d e5				push hl 
0f7e cd 1d 0f			call get_byte 
0f81				 
0f81 47				ld b, a 
0f82			 
0f82 e1				pop hl 
0f83 23				inc hl 
0f84 23				inc hl 
0f85			 
0f85			; TODO not able to handle a-f  
0f85 7e				ld a,(hl) 
0f86			;	;cp ':' 
0f86			;	cp 'g' 
0f86			;	jr nc, .single_byte_hl 		; > 
0f86			;	cp 'G' 
0f86			;	jr nc, .single_byte_hl 		; > 
0f86			;	cp '0' 
0f86			;	jr c, .single_byte_hl		; < 
0f86			 
0f86				;call isdigithl 
0f86 fe 00			cp 0 
0f88 28 06			jr z, .single_byte_hl 
0f8a			 
0f8a			.getwhln:   ; hex word so get next byte 
0f8a			 
0f8a cd 1d 0f			call get_byte 
0f8d 6f				ld l, a 
0f8e 60				ld h,b 
0f8f c9				ret 
0f90 68			.single_byte_hl:   ld l,b 
0f91 26 00				ld h,0 
0f93 c9					ret 
0f94			 
0f94			 
0f94			 
0f94			 
0f94 21 dd 16			ld hl,asc+1 
0f97			;	ld a, (hl) 
0f97			;	call nibble2val 
0f97 cd 1d 0f			call get_byte 
0f9a			 
0f9a			;	call fourehexhl 
0f9a 32 94 e3			ld (scratch+52),a 
0f9d				 
0f9d 21 92 e3			ld hl,scratch+50 
0fa0 22 83 e6			ld (os_cur_ptr),hl 
0fa3			 
0fa3 c9				ret 
0fa4			 
0fa4			 
0fa4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fa4			 
0fa4			; Decimal Unsigned Version 
0fa4			 
0fa4			;Number in a to decimal ASCII 
0fa4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fa4			;Example: display a=56 as "056" 
0fa4			;input: a = number 
0fa4			;Output: a=0,value of a in the screen 
0fa4			;destroys af,bc (don't know about hl and de) 
0fa4			DispAToASCII: 
0fa4 0e 9c			ld	c,-100 
0fa6 cd b0 0f			call	.Na1 
0fa9 0e f6			ld	c,-10 
0fab cd b0 0f			call	.Na1 
0fae 0e ff			ld	c,-1 
0fb0 06 2f		.Na1:	ld	b,'0'-1 
0fb2 04			.Na2:	inc	b 
0fb3 81				add	a,c 
0fb4 38 fc			jr	c,.Na2 
0fb6 91				sub	c		;works as add 100/10/1 
0fb7 f5				push af		;safer than ld c,a 
0fb8 78				ld	a,b		;char is in b 
0fb9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fb9 f1				pop af		;safer than ld a,c 
0fba c9				ret 
0fbb			 
0fbb			; Decimal Signed Version 
0fbb			 
0fbb			; DispA 
0fbb			; -------------------------------------------------------------- 
0fbb			; Converts a signed integer value to a zero-terminated ASCII 
0fbb			; string representative of that value (using radix 10). 
0fbb			; -------------------------------------------------------------- 
0fbb			; INPUTS: 
0fbb			;     HL     Value to convert (two's complement integer). 
0fbb			;     DE     Base address of string destination. (pointer). 
0fbb			; -------------------------------------------------------------- 
0fbb			; OUTPUTS: 
0fbb			;     None 
0fbb			; -------------------------------------------------------------- 
0fbb			; REGISTERS/MEMORY DESTROYED 
0fbb			; AF HL 
0fbb			; -------------------------------------------------------------- 
0fbb			 
0fbb			;DispHLToASCII: 
0fbb			;   push    de 
0fbb			;   push    bc 
0fbb			; 
0fbb			;; Detect sign of HL. 
0fbb			;    bit    7, h 
0fbb			;    jr     z, ._DoConvert 
0fbb			; 
0fbb			;; HL is negative. Output '-' to string and negate HL. 
0fbb			;    ld     a, '-' 
0fbb			;    ld     (de), a 
0fbb			;    inc    de 
0fbb			; 
0fbb			;; Negate HL (using two's complement) 
0fbb			;    xor    a 
0fbb			;    sub    l 
0fbb			;    ld     l, a 
0fbb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fbb			;    sbc    a, h 
0fbb			;    ld     h, a 
0fbb			; 
0fbb			;; Convert HL to digit characters 
0fbb			;._DoConvert: 
0fbb			;    ld     b, 0     ; B will count character length of number 
0fbb			;-   ld     a, 10 
0fbb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fbb			;    push   af 
0fbb			;    inc    b 
0fbb			;    ld     a, h 
0fbb			;    or     l 
0fbb			;    jr     nz, - 
0fbb			; 
0fbb			;; Retrieve digits from stack 
0fbb			;-   pop    af 
0fbb			;    or     $30 
0fbb			;    ld     (de), a 
0fbb			;    inc    de 
0fbb			;    djnz   - 
0fbb			; 
0fbb			;; Terminate string with NULL 
0fbb			;    xor    a 
0fbb			;    ld     (de), a 
0fbb			; 
0fbb			;    pop    bc 
0fbb			;    pop    de 
0fbb			;    ret 
0fbb			 
0fbb			;Comments 
0fbb			; 
0fbb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fbb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fbb			;    Note that the output string will not be fixed-width. 
0fbb			; 
0fbb			;Example Usage 
0fbb			; 
0fbb			;    ld    hl, -1004 
0fbb			;    ld    de, OP1 
0fbb			;    call  DispA 
0fbb			;    ld    hl, OP1 
0fbb			;    syscall  PutS 
0fbb			 
0fbb			 
0fbb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbb			 
0fbb			 
0fbb			;Converts an ASCII string to an unsigned 16-bit integer 
0fbb			;Quits when it reaches a non-decimal digit 
0fbb			 
0fbb			string_to_uint16: 
0fbb			atoui_16: 
0fbb			;Input: 
0fbb			;     DE points to the string 
0fbb			;Outputs: 
0fbb			;     HL is the result 
0fbb			;     A is the 8-bit value of the number 
0fbb			;     DE points to the byte after the number 
0fbb			;Destroys: 
0fbb			;     BC 
0fbb			;       if the string is non-empty, BC is HL/10 
0fbb			;Size:  24 bytes 
0fbb			;Speed: 42+d(104+{0,9}) 
0fbb			;       d is the number of digits in the number 
0fbb			;       max is 640 cycles for a 5 digit number 
0fbb			;Assuming no leading zeros: 
0fbb			;1 digit:  146cc 
0fbb			;2 digit:  250cc 
0fbb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fbb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fbb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fbb			;avg: 544.81158447265625cc (544+13297/16384) 
0fbb			;=============================================================== 
0fbb 21 00 00		  ld hl,0 
0fbe			.u16a: 
0fbe 1a			  ld a,(de) 
0fbf d6 30		  sub 30h 
0fc1 fe 0a		  cp 10 
0fc3 d0			  ret nc 
0fc4 13			  inc de 
0fc5 44			  ld b,h 
0fc6 4d			  ld c,l 
0fc7 29			  add hl,hl 
0fc8 29			  add hl,hl 
0fc9 09			  add hl,bc 
0fca 29			  add hl,hl 
0fcb 85			  add a,l 
0fcc 6f			  ld l,a 
0fcd 30 ef		  jr nc,.u16a 
0fcf 24			  inc h 
0fd0 c3 be 0f		  jp .u16a 
0fd3			 
0fd3			 
0fd3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fd3			 
0fd3			;written by Zeda 
0fd3			;Converts a 16-bit unsigned integer to an ASCII string. 
0fd3			 
0fd3			uitoa_16: 
0fd3			;Input: 
0fd3			;   DE is the number to convert 
0fd3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fd3			;Output: 
0fd3			;   HL points to the null-terminated ASCII string 
0fd3			;      NOTE: This isn't necessarily the same as the input HL. 
0fd3 d5			  push de 
0fd4 c5			  push bc 
0fd5 f5			  push af 
0fd6 eb			  ex de,hl 
0fd7			 
0fd7 01 f0 d8		  ld bc,-10000 
0fda 3e 2f		  ld a,'0'-1 
0fdc 3c			  inc a 
0fdd 09			  add hl,bc  
0fde 38 fc		   jr c,$-2 
0fe0 12			  ld (de),a 
0fe1 13			  inc de 
0fe2			 
0fe2 01 e8 03		  ld bc,1000 
0fe5 3e 3a		  ld a,'9'+1 
0fe7 3d			  dec a  
0fe8 09			  add hl,bc  
0fe9 30 fc		   jr nc,$-2 
0feb 12			  ld (de),a 
0fec 13			  inc de 
0fed			 
0fed 01 9c ff		  ld bc,-100 
0ff0 3e 2f		  ld a,'0'-1 
0ff2 3c			  inc a  
0ff3 09			  add hl,bc  
0ff4 38 fc		   jr c,$-2 
0ff6 12			  ld (de),a 
0ff7 13			  inc de 
0ff8			 
0ff8 7d			  ld a,l 
0ff9 26 3a		  ld h,'9'+1 
0ffb 25			  dec h  
0ffc c6 0a		  add a,10  
0ffe 30 fb		   jr nc,$-3 
1000 c6 30		  add a,'0' 
1002 eb			  ex de,hl 
1003 72			  ld (hl),d 
1004 23			  inc hl 
1005 77			  ld (hl),a 
1006 23			  inc hl 
1007 36 00		  ld (hl),0 
1009			 
1009			;Now strip the leading zeros 
1009 0e fa		  ld c,-6 
100b 09			  add hl,bc 
100c 3e 30		  ld a,'0' 
100e 23			  inc hl  
100f be			  cp (hl)  
1010 28 fc		  jr z,$-2 
1012			 
1012			;Make sure that the string is non-empty! 
1012 7e			  ld a,(hl) 
1013 b7			  or a 
1014 20 01		  jr nz,.atoub 
1016 2b			  dec hl 
1017			.atoub: 
1017			 
1017 f1			  pop af 
1018 c1			  pop bc 
1019 d1			  pop de 
101a c9			  ret 
101b			 
101b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
101b			 
101b			toUpper: 
101b			;A is the char. 
101b			;If A is a lowercase letter, this sets it to the matching uppercase 
101b			;18cc or 30cc or 41cc 
101b			;avg: 26.75cc 
101b fe 61		  cp 'a' 
101d d8			  ret c 
101e fe 7b		  cp 'z'+1 
1020 d0			  ret nc 
1021 d6 20		  sub 'a'-'A' 
1023 c9			  ret 
1024			 
1024			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1024			 
1024			; String Length 
1024			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1024			 
1024			; Get the length of the null-terminated string starting at $8000 hl 
1024			;    LD     HL, $8000 
1024			 
1024			strlenz: 
1024			 
1024 af			    XOR    A               ; Zero is the value we are looking for. 
1025 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1026 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1027			                           ; 65, 536 bytes (the entire addressable memory space). 
1027 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1029			 
1029			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1029 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
102a 6f			    LD     L, A             ; number of bytes 
102b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
102d 2b			    DEC    HL              ; Compensate for null. 
102e c9				ret 
102f			 
102f			; Get the length of the A terminated string starting at $8000 hl 
102f			;    LD     HL, $8000 
102f			 
102f			strlent: 
102f			 
102f			                  ; A is the value we are looking for. 
102f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1031 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1033			                           ; 65, 536 bytes (the entire addressable memory space). 
1033 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1035			 
1035			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1035 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1037 2e 00		    LD     L, 0             ; number of bytes 
1039 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
103b 2b			    DEC    HL              ; Compensate for null. 
103c c9				ret 
103d			 
103d			 
103d			;Comparing Strings 
103d			 
103d			;IN    HL     Address of string1. 
103d			;      DE     Address of string2. 
103d			 
103d			; doc given but wrong??? 
103d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
103d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
103d			; tested 
103d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
103d			 
103d			strcmp_old: 
103d e5			    PUSH   HL 
103e d5			    PUSH   DE 
103f			 
103f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1040 be			    CP     (HL)            ; (want to minimize work). 
1041 38 01		    JR     C, Str1IsBigger 
1043 7e			    LD     A, (HL) 
1044			 
1044			Str1IsBigger: 
1044 4f			    LD     C, A             ; Put length in BC 
1045 06 00		    LD     B, 0 
1047 13			    INC    DE              ; Increment pointers to meat of string. 
1048 23			    INC    HL 
1049			 
1049			CmpLoop: 
1049 1a			    LD     A, (DE)          ; Compare bytes. 
104a ed a1		    CPI 
104c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
104e 13			    INC    DE              ; Update pointer. 
104f ea 49 10		    JP     PE, CmpLoop 
1052			 
1052 d1			    POP    DE 
1053 e1			    POP    HL 
1054 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1055 be			    CP     (HL) 
1056 c9			    RET 
1057			 
1057			NoMatch: 
1057 2b			    DEC    HL 
1058 be			    CP     (HL)            ; Compare again to affect carry. 
1059 d1			    POP    DE 
105a e1			    POP    HL 
105b c9			    RET 
105c			 
105c			;; test strmp 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str2 
105c			;call strcmp 
105c			;jr z, .z1 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "NZ1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.z1: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "ZZ1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str1 
105c			;call strcmp 
105c			;jr z, .z2 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "NZ2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.z2: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "ZZ2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str2 
105c			;call strcmp 
105c			;jr c, .c1 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "Nc1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.c1: 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "cc1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str1 
105c			;call strcmp 
105c			;jr c, .c2 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "Nc2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.c2: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "cc2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;	NEXTW 
105c			;.str1:   db "string1",0 
105c			;.str2:   db "string2",0 
105c			 
105c			; only care about direct match or not 
105c			; hl and de strings 
105c			; zero set if the same 
105c			 
105c			strcmp: 
105c 1a				ld a, (de) 
105d be				cp (hl) 
105e 28 02			jr z, .ssame 
1060 b7				or a 
1061 c9				ret 
1062			 
1062			.ssame:  
1062 fe 00			cp 0 
1064 c8				ret z 
1065			 
1065 23				inc hl 
1066 13				inc de 
1067 18 f3			jr strcmp 
1069				 
1069				 
1069			 
1069			 
1069			 
1069			 
1069			; eof 
1069			 
1069			 
1069			 
1069			 
1069			 
1069			 
# End of file firmware_strings.asm
1069			include "firmware_memory.asm"   ; malloc and free  
1069			 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			.mallocsize: db "Wants malloc >256",0 
1069			.mallocasize: db "MALLOC gives >256",0 
1069			.malloczero: db "MALLOC gives zero",0 
1069			 
1069			malloc_guard_zerolen: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069				ld de, 0 
1069			        call cmp16 
1069				jr nz, .lowalloz 
1069			 
1069				push hl 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .malloczero 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069			 
1069				pop de 
1069				pop hl 
1069			 
1069				 
1069			 
1069				CALLMONITOR 
1069			.lowalloz: 
1069			 
1069			 
1069				pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			 
1069			malloc_guard_entry: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069			 	or a      ;clear carry flag 
1069				push hl 
1069				ld de, 255 
1069				sbc hl, de 
1069				jr c, .lowalloc 
1069			 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .mallocsize 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069			 
1069				pop de 
1069				pop hl 
1069			 
1069				 
1069			 
1069				CALLMONITOR 
1069				jr .lowdone 
1069			.lowalloc: 
1069			 
1069			 
1069				pop hl 
1069			.lowdone:	pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			 
1069			malloc_guard_exit: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069			 	or a      ;clear carry flag 
1069				push hl 
1069				ld de, 255 
1069				sbc hl, de 
1069				jr c, .lowallocx 
1069			 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .mallocasize 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069				pop de 
1069				pop hl 
1069			 
1069				CALLMONITOR 
1069				jr .lowdonex 
1069			.lowallocx: 
1069			 
1069				pop hl 
1069			.lowdonex:	pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			endif 
1069			 
1069			if MALLOC_2 
1069			; Z80 Malloc and Free Functions 
1069			 
1069			; Malloc Function: 
1069			; Input: 
1069			;   HL: Size of block to allocate 
1069			; Output: 
1069			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1069			 
1069			malloc: 
1069				 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			call malloc_guard_entry 
1069			endif 
1069			 
1069			 
1069			 
1069			 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "mal" 
1069						CALLMONITOR 
1069					endif 
1069			    push af            ; Save AF register 
1069			    ld a, l            ; Load low byte of size into A 
1069			    or h               ; Check if size is zero 
1069			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1069			 
1069			    ; Allocate memory 
1069			    ld hl, (heap_start) ; Load start of heap into HL 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma1" 
1069						CALLMONITOR 
1069					endif 
1069			    call malloc_internal ; Call internal malloc function 
1069			    pop af             ; Restore AF register 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret                ; Return 
1069			 
1069			; Free Function: 
1069			; Input: 
1069			;   HL: Pointer to memory block to free 
1069			; Output: 
1069			;   None 
1069			 
1069			free: 
1069			    push af            ; Save AF register 
1069			    ld a, l            ; Load low byte of pointer into A 
1069			    or h               ; Check if pointer is NULL 
1069			    jp z, free_exit    ; If pointer is NULL, exit 
1069			 
1069			    ; Free memory 
1069			    ld hl, (heap_start) ; Load start of heap into HL 
1069			    call free_internal  ; Call internal free function 
1069			    pop af             ; Restore AF register 
1069			    ret                ; Return 
1069			 
1069			; Internal Malloc Function: 
1069			; Input: 
1069			;   HL: Size of block to allocate 
1069			; Output: 
1069			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1069			 
1069			malloc_internal: 
1069			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1069			    add hl, bc         ; Add management overhead to requested size 
1069			    ex de, hl          ; Save total size in DE, and keep it in HL 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma2" 
1069						CALLMONITOR 
1069					endif 
1069			 
1069			    ; Search for free memory block 
1069			    ld de, (heap_end)  ; Load end of heap into DE 
1069			    ld bc, 0           ; Initialize counter 
1069			 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma2" 
1069						CALLMONITOR 
1069					endif 
1069			malloc_search_loop: 
1069			    ; Check if current block is free 
1069			    ld a, (hl)         ; Load current block's status (free or used) 
1069			    cp 0               ; Compare with zero (free) 
1069			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1069			 
1069			    ; Check if current block is large enough 
1069			    ld a, (hl+1)       ; Load high byte of block size 
1069			    cp l               ; Compare with low byte of requested size 
1069			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1069			 
1069			    ld a, (hl+2)       ; Load low byte of block size 
1069			    cp h               ; Compare with high byte of requested size 
1069			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1069			 
1069			    ; Mark block as used 
1069			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1069			 
1069			    ; Calculate remaining space in block 
1069			    ld bc, 0           ; Clear BC 
1069			    add hl, bc         ; Increment HL to point to start of data block 
1069			    add hl, de         ; HL = HL + DE (total size) 
1069			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1069			    add hl, bc         ; Add management overhead to start of data block 
1069			 
1069			    ; Save pointer to allocated block in HL 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma5" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			 
1069			malloc_skip_block_check: 
1069			    ; Move to the next block 
1069			    ld bc, 3           ; Size of management overhead 
1069			    add hl, bc         ; Move to the next block 
1069			    inc de             ; Increment counter 
1069			 
1069			    ; Check if we have reached the end of heap 
1069			    ld a, e            ; Load low byte of heap end address 
1069			    cp (hl)            ; Compare with low byte of current address 
1069			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1069			    ld a, d            ; Load high byte of heap end address 
1069			    cp 0               ; Check if it's zero (end of memory) 
1069			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1069			 
1069			    ; If we reached here, allocation failed 
1069			    xor a              ; Set result to NULL 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma6" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			malloc_exit: 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma7" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			 
1069			; Internal Free Function: 
1069			; Input: 
1069			;   HL: Pointer to memory block to free 
1069			; Output: 
1069			;   None 
1069			 
1069			free_internal: 
1069			    ld de, (heap_start) ; Load start of heap into DE 
1069			    ld bc, 0            ; Initialize counter 
1069			 
1069			free_search_loop: 
1069			    ; Check if current block contains the pointer 
1069			    ld a, l             ; Load low byte of pointer 
1069			    cp (hl+1)           ; Compare with high byte of current block's address 
1069			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1069			    ld a, h             ; Load high byte of pointer 
1069			    cp (hl+2)           ; Compare with low byte of current block's address 
1069			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1069			 
1069			    ; Mark block as free 
1069			    ld (hl), 0          ; Set status byte to indicate free block 
1069			    ret                 ; Return 
1069			 
1069			free_skip_block_check: 
1069			    ; Move to the next block 
1069			    ld bc, 3            ; Size of management overhead 
1069			    add hl, bc          ; Move to the next block 
1069			    inc de              ; Increment counter 
1069			 
1069			    ; Check if we have reached the end of heap 
1069			    ld a, e             ; Load low byte of heap end address 
1069			    cp (hl)             ; Compare with low byte of current address 
1069			    jr nz, free_search_loop  ; If not equal, continue searching 
1069			    ld a, d             ; Load high byte of heap end address 
1069			    cp 0                ; Check if it's zero (end of memory) 
1069			    jr nz, free_search_loop  ; If not zero, continue searching 
1069			 
1069			    ; If we reached here, pointer is not found in heap 
1069			    ret 
1069			 
1069			free_exit: 
1069			    ret                 ; Return 
1069			 
1069			; Define heap start and end addresses 
1069			;heap_start:    .dw 0xC000   ; Start of heap 
1069			;heap_end:      .dw 0xE000   ; End of heap 
1069			 
1069			endif 
1069			 
1069			 
1069			if MALLOC_1 
1069			 
1069			 
1069			 
1069			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1069			 
1069			;moved to firmware.asm 
1069			;heap_start        .equ  0x9000      ; Starting address of heap 
1069			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1069			 
1069			;      .org 0 
1069			;      jp    main 
1069			 
1069			 
1069			;      .org  0x100 
1069			;main: 
1069			;      ld    HL, 0x8100 
1069			;      ld    SP, HL 
1069			; 
1069			;      call  heap_init 
1069			; 
1069			;      ; Make some allocations 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9004 
1069			; 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9014 
1069			; 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9024 
1069			; 
1069			;      ; Free some allocations 
1069			;      ld    HL, 0x9014 
1069			;      call  free 
1069			; 
1069			;      ld    HL, 0x9004 
1069			;      call  free 
1069			; 
1069			;      ld    HL, 0x9024 
1069			;      call  free 
1069			; 
1069			; 
1069			;      halt 
1069			 
1069			 
1069			;------------------------------------------------------------------------------ 
1069			;     heap_init                                                               : 
1069			;                                                                             : 
1069			; Description                                                                 : 
1069			;     Initialise the heap and make it ready for malloc and free operations.   : 
1069			;                                                                             : 
1069			;     The heap is maintained as a linked list, starting with an initial       : 
1069			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1069			;     the first free block in the heap. Each block then points to the next    : 
1069			;     free block within the heap, and the free list ends at the first block   : 
1069			;     with a null pointer to the next free block.                             : 
1069			;                                                                             : 
1069			; Parameters                                                                  : 
1069			;     Inputs are compile-time only. Two defines which specify the starting    : 
1069			;     address of the heap and its size are required, along with a memory      : 
1069			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1069			;     principally stores a pointer to the first free block in the heap.       : 
1069			;                                                                             : 
1069			; Returns                                                                     : 
1069			;     Nothing                                                                 : 
1069			;------------------------------------------------------------------------------ 
1069			heap_init: 
1069 e5			      push  HL 
106a			 
106a			      ; Initialise free list struct 
106a 21 f6 58		      ld    HL, heap_start 
106d 22 f1 58		      ld    (free_list), HL 
1070 21 00 00		      ld    HL, 0 
1073 22 f3 58		      ld    (free_list+2), HL 
1076			 
1076			      ; Insert first free block at bottom of heap, consumes entire heap 
1076 21 42 e3		      ld    HL, heap_start+heap_size-4 
1079 22 f6 58		      ld    (heap_start), HL        ; Next block (end of free list) 
107c 21 4c 8a		      ld    HL, heap_size-4 
107f 22 f8 58		      ld    (heap_start+2), HL      ; Block size 
1082			 
1082			      ; Insert end of free list block at top of heap - two null words will 
1082			      ; terminate the free list 
1082 21 00 00		      ld    HL, 0 
1085 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1088 22 42 e3		      ld    (heap_start+heap_size-4), HL 
108b			 
108b e1			      pop   HL 
108c			 
108c c9			      ret 
108d			 
108d			 
108d			;------------------------------------------------------------------------------ 
108d			;     malloc                                                                  : 
108d			;                                                                             : 
108d			; Description                                                                 : 
108d			;     Allocates the wanted space from the heap and returns the address of the : 
108d			;     first useable byte of the allocation.                                   : 
108d			;                                                                             : 
108d			;     Allocations can happen in one of two ways:                              : 
108d			;                                                                             : 
108d			;     1. A free block may be found which is the exact size wanted. In this    : 
108d			;        case the block is removed from the free list and retuedn to the      : 
108d			;        caller.                                                              : 
108d			;     2. A free block may be found which is larger than the size wanted. In   : 
108d			;        this case, the larger block is split into two. The first portion of  : 
108d			;        this block will become the requested space by the malloc call and    : 
108d			;        is returned to the caller. The second portion becomes a new free     : 
108d			;        block, and the free list is adjusted to maintain continuity via this : 
108d			;        newly created block.                                                 : 
108d			;                                                                             : 
108d			;     malloc does not set any initial value in the allocated space, the       : 
108d			;     caller is required to do this as required.                              : 
108d			;                                                                             : 
108d			;     This implementation of malloc uses the stack exclusively, and is        : 
108d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
108d			;     advisable to disable interrupts before calling malloc, and recommended  : 
108d			;     to avoid the use of malloc inside ISRs in general.                      : 
108d			;                                                                             : 
108d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
108d			;                                                                             : 
108d			; Parameters                                                                  : 
108d			;     HL  Number of bytes wanted                                              : 
108d			;                                                                             : 
108d			; Returns                                                                     : 
108d			;     HL  Address of the first useable byte of the allocation                 : 
108d			;                                                                             : 
108d			; Flags                                                                       : 
108d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
108d			;                                                                             : 
108d			; Stack frame                                                                 : 
108d			;       |             |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     BC      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     DE      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     IX      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |  prev_free  |                                                       : 
108d			;   +4  +-------------+                                                       : 
108d			;       |  this_free  |                                                       : 
108d			;   +2  +-------------+                                                       : 
108d			;       |  next_free  |                                                       : 
108d			;   +0  +-------------+                                                       : 
108d			;       |             |                                                       : 
108d			;                                                                             : 
108d			;------------------------------------------------------------------------------ 
108d			 
108d			 
108d			;malloc: 
108d			; 
108d			;	SAVESP ON 1 
108d			; 
108d			;	call malloc_code 
108d			; 
108d			;	CHECKSP ON 1 
108d			;	ret 
108d			 
108d			 
108d			malloc: 
108d c5			      push  BC 
108e d5			      push  DE 
108f dd e5		      push  IX 
1091			if DEBUG_FORTH_MALLOC_HIGH 
1091			call malloc_guard_entry 
1091			endif 
1091			 
1091					if DEBUG_FORTH_MALLOC 
1091						DMARK "mal" 
1091						CALLMONITOR 
1091					endif 
1091 7c			      ld    A, H                    ; Exit if no space requested 
1092 b5			      or    L 
1093 ca 52 11		      jp    Z, malloc_early_exit 
1096			 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			; 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			 
1096			 
1096			 
1096			 
1096					if DEBUG_FORTH_MALLOC 
1096						DMARK "maA" 
1096						CALLMONITOR 
1096					endif 
1096			      ; Set up stack frame 
1096 eb			      ex    DE, HL 
1097 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
109a 39			      add   HL, SP 
109b f9			      ld    SP, HL 
109c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10a0 dd 39		      add   IX, SP 
10a2			 
10a2			      ; Setup initial state 
10a2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10a5 19			      add   HL, DE 
10a6			 
10a6 44			      ld    B, H                    ; Move want to BC 
10a7 4d			      ld    C, L 
10a8			 
10a8 21 f1 58		      ld    HL, free_list           ; Store prev_free ptr to stack 
10ab dd 75 04		      ld    (IX+4), L 
10ae dd 74 05		      ld    (IX+5), H 
10b1			 
10b1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10b2 23			      inc   HL 
10b3 56			      ld    D, (HL) 
10b4 dd 73 02		      ld    (IX+2), E 
10b7 dd 72 03		      ld    (IX+3), D 
10ba eb			      ex    DE, HL                  ; this_free ptr into HL 
10bb			 
10bb					if DEBUG_FORTH_MALLOC 
10bb						DMARK "maB" 
10bb						CALLMONITOR 
10bb					endif 
10bb			      ; Loop through free block list to find some space 
10bb			malloc_find_space: 
10bb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10bc 23			      inc   HL 
10bd 56			      ld    D, (HL) 
10be			 
10be 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10bf b3			      or    E 
10c0 ca 4c 11		      jp    Z, malloc_no_space 
10c3			 
10c3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10c6 dd 72 01		      ld    (IX+1), D 
10c9			 
10c9			      ; Does this block have enough space to make the allocation? 
10c9 23			      inc   HL                      ; Load free block size into DE 
10ca 5e			      ld    E, (HL) 
10cb 23			      inc   HL 
10cc 56			      ld    D, (HL) 
10cd			 
10cd eb			      ex    DE, HL                  ; Check size of block against want 
10ce b7			      or    A                       ; Ensure carry flag clear 
10cf ed 42		      sbc   HL, BC 
10d1 e5			      push  HL                      ; Store the result for later (new block size) 
10d2			 
10d2 ca 21 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10d5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10d7			 
10d7			      ; this_free block is not big enough, setup ptrs to test next free block 
10d7 e1			      pop   HL                      ; Discard previous result 
10d8			 
10d8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10db dd 66 03		      ld    H, (IX+3) 
10de dd 75 04		      ld    (IX+4), L 
10e1 dd 74 05		      ld    (IX+5), H 
10e4			 
10e4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10e7 dd 66 01		      ld    H, (IX+1) 
10ea dd 75 02		      ld    (IX+2), L 
10ed dd 74 03		      ld    (IX+3), H 
10f0			 
10f0					if DEBUG_FORTH_MALLOC 
10f0						DMARK "MA>" 
10f0						CALLMONITOR 
10f0					endif 
10f0 18 c9		      jr    malloc_find_space 
10f2			 
10f2			      ; split a bigger block into two - requested size and remaining size 
10f2			malloc_alloc_split: 
10f2					if DEBUG_FORTH_MALLOC 
10f2						DMARK "MAs" 
10f2						CALLMONITOR 
10f2					endif 
10f2 eb			      ex    DE, HL                  ; Calculate address of new free block 
10f3 2b			      dec   HL 
10f4 2b			      dec   HL 
10f5 2b			      dec   HL 
10f6 09			      add   HL, BC 
10f7			 
10f7			      ; Create a new block and point it at next_free 
10f7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10fa dd 56 01		      ld    D, (IX+1) 
10fd			 
10fd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10fe 23			      inc   HL 
10ff 72			      ld    (HL), D 
1100			 
1100 d1			      pop   DE                      ; Store size of new block into new block 
1101 23			      inc   HL 
1102 73			      ld    (HL), E 
1103 23			      inc   HL 
1104 72			      ld    (HL), D 
1105			 
1105			      ; Update this_free ptr to point to new block 
1105 2b			      dec   HL 
1106 2b			      dec   HL 
1107 2b			      dec   HL 
1108			 
1108 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
110b dd 56 03		      ld    D, (IX+3) 
110e			 
110e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1111 dd 74 03		      ld    (IX+3), H 
1114			 
1114			      ; Modify this_free block to be allocation 
1114 eb			      ex    DE, HL 
1115 af			      xor   A                       ; Null the next block ptr of allocated block 
1116 77			      ld    (HL), A 
1117 23			      inc   HL 
1118 77			      ld    (HL), A 
1119			 
1119 23			      inc   HL                      ; Store want size into allocated block 
111a 71			      ld    (HL), C 
111b 23			      inc   HL 
111c 70			      ld    (HL), B 
111d 23			      inc   HL 
111e e5			      push  HL                      ; Address of allocation to return 
111f			 
111f 18 19		      jr    malloc_update_links 
1121			 
1121			malloc_alloc_fit: 
1121 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1122			 
1122					if DEBUG_FORTH_MALLOC 
1122						DMARK "MAf" 
1122						CALLMONITOR 
1122					endif 
1122			      ; Modify this_free block to be allocation 
1122 eb			      ex    DE, HL 
1123 2b			      dec   HL 
1124 2b			      dec   HL 
1125 2b			      dec   HL 
1126			 
1126 af			      xor   A                       ; Null the next block ptr of allocated block 
1127 77			      ld    (HL), A 
1128 23			      inc   HL 
1129 77			      ld    (HL), A 
112a			 
112a 23			      inc   HL                      ; Store address of allocation to return 
112b 23			      inc   HL 
112c 23			      inc   HL 
112d e5			      push  HL 
112e			 
112e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
112e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1131 dd 66 01		      ld    H, (IX+1) 
1134			 
1134 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1137 dd 74 03		      ld    (IX+3), H 
113a			 
113a			 
113a			malloc_update_links: 
113a			      ; Update prev_free ptr to point to this_free 
113a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
113d dd 66 05		      ld    H, (IX+5) 
1140			 
1140 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1143 dd 56 03		      ld    D, (IX+3) 
1146			 
1146 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1147 23			      inc   HL 
1148 72			      ld    (HL), D 
1149			 
1149					if DEBUG_FORTH_MALLOC 
1149						DMARK "Mul" 
1149						CALLMONITOR 
1149					endif 
1149			      ; Clear the Z flag to indicate successful allocation 
1149 7a			      ld    A, D 
114a b3			      or    E 
114b			 
114b d1			      pop   DE                      ; Address of allocation 
114c					if DEBUG_FORTH_MALLOC 
114c						DMARK "MAu" 
114c						CALLMONITOR 
114c					endif 
114c			 
114c			malloc_no_space: 
114c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
114f 39			      add   HL, SP 
1150 f9			      ld    SP, HL 
1151			 
1151 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1152					if DEBUG_FORTH_MALLOC 
1152						DMARK "MAN" 
1152						CALLMONITOR 
1152					endif 
1152			 
1152			malloc_early_exit: 
1152					if DEBUG_FORTH_MALLOC 
1152						DMARK "MAx" 
1152						CALLMONITOR 
1152					endif 
1152 dd e1		      pop   IX 
1154 d1			      pop   DE 
1155 c1			      pop   BC 
1156			 
1156			if DEBUG_FORTH_MALLOC_HIGH 
1156			call malloc_guard_exit 
1156			call malloc_guard_zerolen 
1156			endif 
1156 c9			      ret 
1157			 
1157			 
1157			;------------------------------------------------------------------------------ 
1157			;     free                                                                    : 
1157			;                                                                             : 
1157			; Description                                                                 : 
1157			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1157			;     returned by malloc, otherwise the behaviour is undefined.               : 
1157			;                                                                             : 
1157			;     Where possible, directly adjacent free blocks will be merged together   : 
1157			;     into larger blocks to help ensure that the heap does not become         : 
1157			;     excessively fragmented.                                                 : 
1157			;                                                                             : 
1157			;     free does not clear or set any other value into the freed space, and    : 
1157			;     therefore its contents may be visible through subsequent malloc's. The  : 
1157			;     caller should clear the freed space as required.                        : 
1157			;                                                                             : 
1157			;     This implementation of free uses the stack exclusively, and is          : 
1157			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1157			;     advisable to disable interrupts before calling free, and recommended    : 
1157			;     to avoid the use of free inside ISRs in general.                        : 
1157			;                                                                             : 
1157			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1157			;                                                                             : 
1157			; Parameters                                                                  : 
1157			;     HL  Pointer to address of first byte of allocation to be freed          : 
1157			;                                                                             : 
1157			; Returns                                                                     : 
1157			;     Nothing                                                                 : 
1157			;                                                                             : 
1157			; Stack frame                                                                 : 
1157			;       |             |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     BC      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     DE      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     IX      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |  prev_free  |                                                       : 
1157			;   +2  +-------------+                                                       : 
1157			;       |  next_free  |                                                       : 
1157			;   +0  +-------------+                                                       : 
1157			;       |             |                                                       : 
1157			;                                                                             : 
1157			;------------------------------------------------------------------------------ 
1157			free: 
1157 c5			      push  BC 
1158 d5			      push  DE 
1159 dd e5		      push  IX 
115b			 
115b 7c			      ld    A, H                    ; Exit if ptr is null 
115c b5			      or    L 
115d ca 21 12		      jp    Z, free_early_exit 
1160			 
1160			      ; Set up stack frame 
1160 eb			      ex    DE, HL 
1161 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1164 39			      add   HL, SP 
1165 f9			      ld    SP, HL 
1166 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
116a dd 39		      add   IX, SP 
116c			 
116c			      ; The address in HL points to the start of the useable allocated space, 
116c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
116c			      ; address of the block itself. 
116c eb			      ex    DE, HL 
116d 11 fc ff		      ld    DE, -4 
1170 19			      add   HL, DE 
1171			 
1171			      ; An allocated block must have a null next block pointer in it 
1171 7e			      ld    A, (HL) 
1172 23			      inc   HL 
1173 b6			      or    (HL) 
1174 c2 1c 12		      jp    NZ, free_done 
1177			 
1177 2b			      dec   HL 
1178			 
1178 44			      ld    B, H                    ; Copy HL to BC 
1179 4d			      ld    C, L 
117a			 
117a			      ; Loop through the free list to find the first block with an address 
117a			      ; higher than the block being freed 
117a 21 f1 58		      ld    HL, free_list 
117d			 
117d			free_find_higher_block: 
117d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
117e 23			      inc   HL 
117f 56			      ld    D, (HL) 
1180 2b			      dec   HL 
1181			 
1181 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1184 dd 72 01		      ld    (IX+1), D 
1187 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
118a dd 74 03		      ld    (IX+3), H 
118d			 
118d 78			      ld    A, B                    ; Check if DE is greater than BC 
118e ba			      cp    D                       ; Compare MSB first 
118f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1191 30 04		      jr    NC, free_find_higher_block_skip 
1193 79			      ld    A, C 
1194 bb			      cp    E                       ; Then compare LSB 
1195 38 08		      jr    C, free_found_higher_block 
1197			 
1197			free_find_higher_block_skip: 
1197 7a			      ld    A, D                    ; Reached the end of the free list? 
1198 b3			      or    E 
1199 ca 1c 12		      jp    Z, free_done 
119c			 
119c eb			      ex    DE, HL 
119d			 
119d 18 de		      jr    free_find_higher_block 
119f			 
119f			free_found_higher_block: 
119f			      ; Insert freed block between prev and next free blocks 
119f 71			      ld    (HL), C                 ; Point prev free block to freed block 
11a0 23			      inc   HL 
11a1 70			      ld    (HL), B 
11a2			 
11a2 60			      ld    H, B                    ; Point freed block at next free block 
11a3 69			      ld    L, C 
11a4 73			      ld    (HL), E 
11a5 23			      inc   HL 
11a6 72			      ld    (HL), D 
11a7			 
11a7			      ; Check if the freed block is adjacent to the next free block 
11a7 23			      inc   HL                      ; Load size of freed block into HL 
11a8 5e			      ld    E, (HL) 
11a9 23			      inc   HL 
11aa 56			      ld    D, (HL) 
11ab eb			      ex    DE, HL 
11ac			 
11ac 09			      add   HL, BC                  ; Add addr of freed block and its size 
11ad			 
11ad dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11b0 dd 56 01		      ld    D, (IX+1) 
11b3			 
11b3 b7			      or    A                       ; Clear the carry flag 
11b4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11b6 20 22		      jr    NZ, free_check_adjacent_to_prev 
11b8			 
11b8			      ; Freed block is adjacent to next, merge into one bigger block 
11b8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11b9 5e			      ld    E, (HL) 
11ba 23			      inc   HL 
11bb 56			      ld    D, (HL) 
11bc e5			      push  HL                      ; Save ptr to next block for later 
11bd			 
11bd 60			      ld    H, B                    ; Store ptr from next block into freed block 
11be 69			      ld    L, C 
11bf 73			      ld    (HL), E 
11c0 23			      inc   HL 
11c1 72			      ld    (HL), D 
11c2			 
11c2 e1			      pop   HL                      ; Restore ptr to next block 
11c3 23			      inc   HL                      ; Load size of next block into DE 
11c4 5e			      ld    E, (HL) 
11c5 23			      inc   HL 
11c6 56			      ld    D, (HL) 
11c7 d5			      push  DE                      ; Save next block size for later 
11c8			 
11c8 60			      ld    H, B                    ; Load size of freed block into HL 
11c9 69			      ld    L, C 
11ca 23			      inc   HL 
11cb 23			      inc   HL 
11cc 5e			      ld    E, (HL) 
11cd 23			      inc   HL 
11ce 56			      ld    D, (HL) 
11cf eb			      ex    DE, HL 
11d0			 
11d0 d1			      pop   DE                      ; Restore size of next block 
11d1 19			      add   HL, DE                  ; Add sizes of both blocks 
11d2 eb			      ex    DE, HL 
11d3			 
11d3 60			      ld    H, B                    ; Store new bigger size into freed block 
11d4 69			      ld    L, C 
11d5 23			      inc   HL 
11d6 23			      inc   HL 
11d7 73			      ld    (HL), E 
11d8 23			      inc   HL 
11d9 72			      ld    (HL), D 
11da			 
11da			free_check_adjacent_to_prev: 
11da			      ; Check if the freed block is adjacent to the prev free block 
11da dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11dd dd 66 03		      ld    H, (IX+3) 
11e0			 
11e0 23			      inc   HL                      ; Size of prev free block into DE 
11e1 23			      inc   HL 
11e2 5e			      ld    E, (HL) 
11e3 23			      inc   HL 
11e4 56			      ld    D, (HL) 
11e5 2b			      dec   HL 
11e6 2b			      dec   HL 
11e7 2b			      dec   HL 
11e8			 
11e8 19			      add   HL, DE                  ; Add prev block addr and size 
11e9			 
11e9 b7			      or    A                       ; Clear the carry flag 
11ea ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11ec 20 2e		      jr    NZ, free_done 
11ee			 
11ee			      ; Freed block is adjacent to prev, merge into one bigger block 
11ee 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11ef 69			      ld    L, C 
11f0 5e			      ld    E, (HL) 
11f1 23			      inc   HL 
11f2 56			      ld    D, (HL) 
11f3 e5			      push  HL                      ; Save freed block ptr for later 
11f4			 
11f4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11f7 dd 66 03		      ld    H, (IX+3) 
11fa 73			      ld    (HL), E 
11fb 23			      inc   HL 
11fc 72			      ld    (HL), D 
11fd			 
11fd e1			      pop   HL                      ; Restore freed block ptr 
11fe 23			      inc   HL                      ; Load size of freed block into DE 
11ff 5e			      ld    E, (HL) 
1200 23			      inc   HL 
1201 56			      ld    D, (HL) 
1202 d5			      push  DE                      ; Save freed block size for later 
1203			 
1203 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1206 dd 66 03		      ld    H, (IX+3) 
1209 23			      inc   HL 
120a 23			      inc   HL 
120b 5e			      ld    E, (HL) 
120c 23			      inc   HL 
120d 56			      ld    D, (HL) 
120e			 
120e e1			      pop   HL                      ; Add sizes of both blocks 
120f 19			      add   HL, DE 
1210 eb			      ex    DE, HL 
1211			 
1211 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1214 dd 66 03		      ld    H, (IX+3) 
1217 23			      inc   HL 
1218 23			      inc   HL 
1219 73			      ld    (HL), E 
121a 23			      inc   HL 
121b 72			      ld    (HL), D 
121c			 
121c			free_done: 
121c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
121f 39			      add   HL, SP 
1220 f9			      ld    SP, HL 
1221			 
1221			free_early_exit: 
1221 dd e1		      pop   IX 
1223 d1			      pop   DE 
1224 c1			      pop   BC 
1225			 
1225 c9			      ret 
1226			 
1226			; moved to firmware.asm 
1226			; 
1226			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1226			;                  .dw   0 
1226			 
1226			 
1226			endif 
1226			 
1226			 
1226			if MALLOC_3 
1226			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1226			;heap_start        .equ  0x9000      ; Starting address of heap 
1226			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1226			; 
1226			 ;     .org 0 
1226			  ;    jp    main 
1226			; 
1226			; 
1226			 ;     .org  0x100 
1226			;main: 
1226			 ;     ld    HL, 0x8100 
1226			  ;    ld    SP, HL 
1226			; 
1226			;      call  heap_init 
1226			 
1226			      ; Make some allocations 
1226			;      ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9004 
1226			; 
1226			 ;     ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9014 
1226			 
1226			;      ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9024 
1226			 
1226			      ; Free some allocations 
1226			;      ld    HL, 0x9014 
1226			;      call  free 
1226			 
1226			;      ld    HL, 0x9004 
1226			;      call  free 
1226			; 
1226			;      ld    HL, 0x9024 
1226			;      call  free 
1226			 
1226			 
1226			 ;     halt 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     heap_init                                                               : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Initialise the heap and make it ready for malloc and free operations.   : 
1226			;                                                                             : 
1226			;     The heap is maintained as a linked list, starting with an initial       : 
1226			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1226			;     the first free block in the heap. Each block then points to the next    : 
1226			;     free block within the heap, and the free list ends at the first block   : 
1226			;     with a null pointer to the next free block.                             : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     Inputs are compile-time only. Two defines which specify the starting    : 
1226			;     address of the heap and its size are required, along with a memory      : 
1226			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1226			;     principally stores a pointer to the first free block in the heap.       : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     Nothing                                                                 : 
1226			;------------------------------------------------------------------------------ 
1226			heap_init: 
1226			      push  HL 
1226			 
1226			      ; Initialise free list struct 
1226			      ld    HL, heap_start 
1226			      ld    (free_list), HL 
1226			      ld    HL, 0 
1226			      ld    (free_list+2), HL 
1226			 
1226			      ; Insert first free block at bottom of heap, consumes entire heap 
1226			      ld    HL, heap_start+heap_size-4 
1226			      ld    (heap_start), HL        ; Next block (end of free list) 
1226			      ld    HL, heap_size-4 
1226			      ld    (heap_start+2), HL      ; Block size 
1226			 
1226			      ; Insert end of free list block at top of heap - two null words will 
1226			      ; terminate the free list 
1226			      ld    HL, 0 
1226			      ld    (heap_start+heap_size-2), HL 
1226			      ld    (heap_start+heap_size-4), HL 
1226			 
1226			      pop   HL 
1226			 
1226			      ret 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     malloc                                                                  : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Allocates the wanted space from the heap and returns the address of the : 
1226			;     first useable byte of the allocation.                                   : 
1226			;                                                                             : 
1226			;     Allocations can happen in one of two ways:                              : 
1226			;                                                                             : 
1226			;     1. A free block may be found which is the exact size wanted. In this    : 
1226			;        case the block is removed from the free list and retuedn to the      : 
1226			;        caller.                                                              : 
1226			;     2. A free block may be found which is larger than the size wanted. In   : 
1226			;        this case, the larger block is split into two. The first portion of  : 
1226			;        this block will become the requested space by the malloc call and    : 
1226			;        is returned to the caller. The second portion becomes a new free     : 
1226			;        block, and the free list is adjusted to maintain continuity via this : 
1226			;        newly created block.                                                 : 
1226			;                                                                             : 
1226			;     malloc does not set any initial value in the allocated space, the       : 
1226			;     caller is required to do this as required.                              : 
1226			;                                                                             : 
1226			;     This implementation of malloc uses the stack exclusively, and is        : 
1226			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1226			;     advisable to disable interrupts before calling malloc, and recommended  : 
1226			;     to avoid the use of malloc inside ISRs in general.                      : 
1226			;                                                                             : 
1226			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     HL  Number of bytes wanted                                              : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     HL  Address of the first useable byte of the allocation                 : 
1226			;                                                                             : 
1226			; Flags                                                                       : 
1226			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1226			;                                                                             : 
1226			; Stack frame                                                                 : 
1226			;       |             |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     BC      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     DE      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     IX      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |  prev_free  |                                                       : 
1226			;   +4  +-------------+                                                       : 
1226			;       |  this_free  |                                                       : 
1226			;   +2  +-------------+                                                       : 
1226			;       |  next_free  |                                                       : 
1226			;   +0  +-------------+                                                       : 
1226			;       |             |                                                       : 
1226			;                                                                             : 
1226			;------------------------------------------------------------------------------ 
1226			malloc: 
1226			      push  BC 
1226			      push  DE 
1226			      push  IX 
1226			 
1226			      ld    A, H                    ; Exit if no space requested 
1226			      or    L 
1226			      jp    Z, malloc_early_exit 
1226			 
1226			      ; Set up stack frame 
1226			      ex    DE, HL 
1226			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			      ld    IX, 0                   ; Use IX as a frame pointer 
1226			      add   IX, SP 
1226			 
1226			      ; Setup initial state 
1226			      ld    HL, 4                   ; want must also include space used by block struct 
1226			      add   HL, DE 
1226			 
1226			      ld    B, H                    ; Move want to BC 
1226			      ld    C, L 
1226			 
1226			      ld    HL, free_list           ; Store prev_free ptr to stack 
1226			      ld    (IX+4), L 
1226			      ld    (IX+5), H 
1226			 
1226			      ld    E, (HL)                 ; Store this_free ptr to stack 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ld    (IX+2), E 
1226			      ld    (IX+3), D 
1226			      ex    DE, HL                  ; this_free ptr into HL 
1226			 
1226			      ; Loop through free block list to find some space 
1226			malloc_find_space: 
1226			      ld    E, (HL)                 ; Load next_free ptr into DE 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1226			      or    E 
1226			      jp    Z, malloc_no_space 
1226			 
1226			      ld    (IX+0), E               ; Store next_free ptr to stack 
1226			      ld    (IX+1), D 
1226			 
1226			      ; Does this block have enough space to make the allocation? 
1226			      inc   HL                      ; Load free block size into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      ex    DE, HL                  ; Check size of block against want 
1226			      or    A                       ; Ensure carry flag clear 
1226			      sbc   HL, BC 
1226			      push  HL                      ; Store the result for later (new block size) 
1226			 
1226			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1226			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1226			 
1226			      ; this_free block is not big enough, setup ptrs to test next free block 
1226			      pop   HL                      ; Discard previous result 
1226			 
1226			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1226			      ld    H, (IX+3) 
1226			      ld    (IX+4), L 
1226			      ld    (IX+5), H 
1226			 
1226			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1226			      ld    H, (IX+1) 
1226			      ld    (IX+2), L 
1226			      ld    (IX+3), H 
1226			 
1226			      jr    malloc_find_space 
1226			 
1226			      ; split a bigger block into two - requested size and remaining size 
1226			malloc_alloc_split: 
1226			      ex    DE, HL                  ; Calculate address of new free block 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			      add   HL, BC 
1226			 
1226			      ; Create a new block and point it at next_free 
1226			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1226			      ld    D, (IX+1) 
1226			 
1226			      ld    (HL), E                 ; Store next_free ptr into new block 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   DE                      ; Store size of new block into new block 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Update this_free ptr to point to new block 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1226			      ld    D, (IX+3) 
1226			 
1226			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1226			      ld    (IX+3), H 
1226			 
1226			      ; Modify this_free block to be allocation 
1226			      ex    DE, HL 
1226			      xor   A                       ; Null the next block ptr of allocated block 
1226			      ld    (HL), A 
1226			      inc   HL 
1226			      ld    (HL), A 
1226			 
1226			      inc   HL                      ; Store want size into allocated block 
1226			      ld    (HL), C 
1226			      inc   HL 
1226			      ld    (HL), B 
1226			      inc   HL 
1226			      push  HL                      ; Address of allocation to return 
1226			 
1226			      jr    malloc_update_links 
1226			 
1226			malloc_alloc_fit: 
1226			      pop   HL                      ; Dont need new block size, want is exact fit 
1226			 
1226			      ; Modify this_free block to be allocation 
1226			      ex    DE, HL 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      xor   A                       ; Null the next block ptr of allocated block 
1226			      ld    (HL), A 
1226			      inc   HL 
1226			      ld    (HL), A 
1226			 
1226			      inc   HL                      ; Store address of allocation to return 
1226			      inc   HL 
1226			      inc   HL 
1226			      push  HL 
1226			 
1226			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1226			      ld    L, (IX+0)               ; next_free to HL 
1226			      ld    H, (IX+1) 
1226			 
1226			      ld    (IX+2), L               ; HL to this_free 
1226			      ld    (IX+3), H 
1226			 
1226			 
1226			malloc_update_links: 
1226			      ; Update prev_free ptr to point to this_free 
1226			      ld    L, (IX+4)               ; prev_free ptr to HL 
1226			      ld    H, (IX+5) 
1226			 
1226			      ld    E, (IX+2)               ; this_free ptr to DE 
1226			      ld    D, (IX+3) 
1226			 
1226			      ld    (HL), E                 ; this_free ptr into prev_free 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Clear the Z flag to indicate successful allocation 
1226			      ld    A, D 
1226			      or    E 
1226			 
1226			      pop   DE                      ; Address of allocation 
1226			 
1226			malloc_no_space: 
1226			      ld    HL, 6                   ; Clean up stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			 
1226			      ex    DE, HL                  ; Alloc addr into HL for return 
1226			 
1226			malloc_early_exit: 
1226			      pop   IX 
1226			      pop   DE 
1226			      pop   BC 
1226			 
1226			      ret 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     free                                                                    : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1226			;     returned by malloc, otherwise the behaviour is undefined.               : 
1226			;                                                                             : 
1226			;     Where possible, directly adjacent free blocks will be merged together   : 
1226			;     into larger blocks to help ensure that the heap does not become         : 
1226			;     excessively fragmented.                                                 : 
1226			;                                                                             : 
1226			;     free does not clear or set any other value into the freed space, and    : 
1226			;     therefore its contents may be visible through subsequent malloc's. The  : 
1226			;     caller should clear the freed space as required.                        : 
1226			;                                                                             : 
1226			;     This implementation of free uses the stack exclusively, and is          : 
1226			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1226			;     advisable to disable interrupts before calling free, and recommended    : 
1226			;     to avoid the use of free inside ISRs in general.                        : 
1226			;                                                                             : 
1226			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     HL  Pointer to address of first byte of allocation to be freed          : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     Nothing                                                                 : 
1226			;                                                                             : 
1226			; Stack frame                                                                 : 
1226			;       |             |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     BC      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     DE      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     IX      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |  prev_free  |                                                       : 
1226			;   +2  +-------------+                                                       : 
1226			;       |  next_free  |                                                       : 
1226			;   +0  +-------------+                                                       : 
1226			;       |             |                                                       : 
1226			;                                                                             : 
1226			;------------------------------------------------------------------------------ 
1226			free: 
1226			      push  BC 
1226			      push  DE 
1226			      push  IX 
1226			 
1226			      ld    A, H                    ; Exit if ptr is null 
1226			      or    L 
1226			      jp    Z, free_early_exit 
1226			 
1226			      ; Set up stack frame 
1226			      ex    DE, HL 
1226			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			      ld    IX, 0                   ; Use IX as a frame pointer 
1226			      add   IX, SP 
1226			 
1226			      ; The address in HL points to the start of the useable allocated space, 
1226			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1226			      ; address of the block itself. 
1226			      ex    DE, HL 
1226			      ld    DE, -4 
1226			      add   HL, DE 
1226			 
1226			      ; An allocated block must have a null next block pointer in it 
1226			      ld    A, (HL) 
1226			      inc   HL 
1226			      or    (HL) 
1226			      jp    NZ, free_done 
1226			 
1226			      dec   HL 
1226			 
1226			      ld    B, H                    ; Copy HL to BC 
1226			      ld    C, L 
1226			 
1226			      ; Loop through the free list to find the first block with an address 
1226			      ; higher than the block being freed 
1226			      ld    HL, free_list 
1226			 
1226			free_find_higher_block: 
1226			      ld    E, (HL)                 ; Load next ptr from free block 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      dec   HL 
1226			 
1226			      ld    (IX+0), E               ; Save ptr to next free block 
1226			      ld    (IX+1), D 
1226			      ld    (IX+2), L               ; Save ptr to prev free block 
1226			      ld    (IX+3), H 
1226			 
1226			      ld    A, B                    ; Check if DE is greater than BC 
1226			      cp    D                       ; Compare MSB first 
1226			      jr    Z, $+4                  ; MSB the same, compare LSB 
1226			      jr    NC, free_find_higher_block_skip 
1226			      ld    A, C 
1226			      cp    E                       ; Then compare LSB 
1226			      jr    C, free_found_higher_block 
1226			 
1226			free_find_higher_block_skip: 
1226			      ld    A, D                    ; Reached the end of the free list? 
1226			      or    E 
1226			      jp    Z, free_done 
1226			 
1226			      ex    DE, HL 
1226			 
1226			      jr    free_find_higher_block 
1226			 
1226			free_found_higher_block: 
1226			      ; Insert freed block between prev and next free blocks 
1226			      ld    (HL), C                 ; Point prev free block to freed block 
1226			      inc   HL 
1226			      ld    (HL), B 
1226			 
1226			      ld    H, B                    ; Point freed block at next free block 
1226			      ld    L, C 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Check if the freed block is adjacent to the next free block 
1226			      inc   HL                      ; Load size of freed block into HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ex    DE, HL 
1226			 
1226			      add   HL, BC                  ; Add addr of freed block and its size 
1226			 
1226			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1226			      ld    D, (IX+1) 
1226			 
1226			      or    A                       ; Clear the carry flag 
1226			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1226			      jr    NZ, free_check_adjacent_to_prev 
1226			 
1226			      ; Freed block is adjacent to next, merge into one bigger block 
1226			      ex    DE, HL                  ; Load next ptr from next block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  HL                      ; Save ptr to next block for later 
1226			 
1226			      ld    H, B                    ; Store ptr from next block into freed block 
1226			      ld    L, C 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   HL                      ; Restore ptr to next block 
1226			      inc   HL                      ; Load size of next block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  DE                      ; Save next block size for later 
1226			 
1226			      ld    H, B                    ; Load size of freed block into HL 
1226			      ld    L, C 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ex    DE, HL 
1226			 
1226			      pop   DE                      ; Restore size of next block 
1226			      add   HL, DE                  ; Add sizes of both blocks 
1226			      ex    DE, HL 
1226			 
1226			      ld    H, B                    ; Store new bigger size into freed block 
1226			      ld    L, C 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			free_check_adjacent_to_prev: 
1226			      ; Check if the freed block is adjacent to the prev free block 
1226			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1226			      ld    H, (IX+3) 
1226			 
1226			      inc   HL                      ; Size of prev free block into DE 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      add   HL, DE                  ; Add prev block addr and size 
1226			 
1226			      or    A                       ; Clear the carry flag 
1226			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1226			      jr    NZ, free_done 
1226			 
1226			      ; Freed block is adjacent to prev, merge into one bigger block 
1226			      ld    H, B                    ; Load next ptr from freed block into DE 
1226			      ld    L, C 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  HL                      ; Save freed block ptr for later 
1226			 
1226			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1226			      ld    H, (IX+3) 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   HL                      ; Restore freed block ptr 
1226			      inc   HL                      ; Load size of freed block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  DE                      ; Save freed block size for later 
1226			 
1226			      ld    L, (IX+2)               ; Load size of prev block into DE 
1226			      ld    H, (IX+3) 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      pop   HL                      ; Add sizes of both blocks 
1226			      add   HL, DE 
1226			      ex    DE, HL 
1226			 
1226			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1226			      ld    H, (IX+3) 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			free_done: 
1226			      ld    HL, 4                   ; Clean up stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			 
1226			free_early_exit: 
1226			      pop   IX 
1226			      pop   DE 
1226			      pop   BC 
1226			 
1226			      ret 
1226			 
1226			 
1226			;      .org 0x8000 
1226			; 
1226			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1226			 ;                 .dw   0 
1226			 
1226			endif 
1226			 
1226			 
1226			if MALLOC_4 
1226			 
1226			; My memory allocation code. Very very simple.... 
1226			; allocate space under 250 chars 
1226			 
1226			heap_init: 
1226				; init start of heap as zero 
1226				;  
1226			 
1226				ld hl, heap_start 
1226				ld a, 0 
1226				ld (hl), a      ; empty block 
1226				inc hl 
1226				ld a, 0 
1226				ld (hl), a      ; length of block 
1226				; write end of list 
1226				inc hl 
1226				ld a,(hl) 
1226				inc hl 
1226				ld a,(hl) 
1226				 
1226			 
1226				; init some malloc vars 
1226			 
1226				ld hl, 0 
1226				ld (free_list), hl       ; store last malloc location 
1226			 
1226				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1226				ld a, 0 
1226				ld (hl), a 
1226			 
1226			 
1226				ld hl, heap_start 
1226				;  
1226				  
1226				ret 
1226			 
1226			 
1226			;    free block marker 
1226			;    requested size  
1226			;    pointer to next block 
1226			;    .... 
1226			;    next block marker 
1226			 
1226			 
1226			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1226			; 
1226			 
1226			 
1226			malloc:  
1226				push de 
1226				push bc 
1226				push af 
1226			 
1226				; hl space required 
1226				 
1226				ld c, l    ; hold space   (TODO only a max of 255) 
1226			 
1226			;	inc c     ; TODO BUG need to fix memory leak on push str 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			 
1226			 
1226			 
1226				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1226			 
1226				ld a, (free_list+3) 
1226				cp 0 
1226				jr z, .contheap 
1226			 
1226				ld hl, (free_list)     ; get last alloc 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mrs" 
1226						CALLMONITOR 
1226					endif 
1226				jr .startalloc 
1226			 
1226			.contheap: 
1226				ld hl, heap_start 
1226			 
1226			.startalloc: 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mym" 
1226						CALLMONITOR 
1226					endif 
1226			.findblock: 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mmf" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226				ld a,(hl)  
1226				; if byte is zero then clear to use 
1226			 
1226				cp 0 
1226				jr z, .foundemptyblock 
1226			 
1226				; if byte is not clear 
1226				;     then byte is offset to next block 
1226			 
1226				inc hl 
1226				ld a, (hl) ; get size 
1226			.nextblock:	inc hl 
1226					ld e, (hl) 
1226					inc hl 
1226					ld d, (hl) 
1226					ex de, hl 
1226			;	inc hl  ; move past the store space 
1226			;	inc hl  ; move past zero index  
1226			 
1226				; TODO detect no more space 
1226			 
1226				push hl 
1226				ld de, heap_end 
1226				call cmp16 
1226				pop hl 
1226				jr nc, .nospace 
1226			 
1226				jr .findblock 
1226			 
1226			.nospace: ld hl, 0 
1226				jp .exit 
1226			 
1226			 
1226			.foundemptyblock:	 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mme" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			; TODO has block enough space if reusing??? 
1226			 
1226				;  
1226			 
1226			; see if this block has been previously used 
1226				inc hl 
1226				ld a, (hl) 
1226				dec hl 
1226				cp 0 
1226				jr z, .newblock 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "meR" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			; no reusing previously allocated block 
1226			 
1226			; is it smaller than previously used? 
1226				 
1226				inc hl    ; move to size 
1226				ld a, c 
1226				sub (hl)        ; we want c < (hl) 
1226				dec hl    ; move back to marker 
1226			        jr z, .findblock 
1226			 
1226				; update with the new size which should be lower 
1226			 
1226			        ;inc  hl   ; negate next move. move back to size  
1226			 
1226			.newblock: 
1226				; need to be at marker here 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "meN" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			 
1226				ld a, c 
1226			 
1226				ld (free_list+3), a	 ; flag resume from last malloc  
1226				ld (free_list), hl    ; save out last location 
1226			 
1226			 
1226				;inc a     ; space for length byte 
1226				ld (hl), a     ; save block in use marker 
1226			 
1226				inc hl   ; move to space marker 
1226				ld (hl), a    ; save new space 
1226			 
1226				inc hl   ; move to start of allocated area 
1226				 
1226			;	push hl     ; save where we are - 1  
1226			 
1226			;	inc hl  ; move past zero index  
1226				; skip space to set down new marker 
1226			 
1226				; provide some extra space for now 
1226			 
1226				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1226				inc a 
1226				inc a 
1226			 
1226				push hl   ; save where we are in the node block 
1226			 
1226				call addatohl 
1226			 
1226				; write linked list point 
1226			 
1226				pop de     ; get our node position 
1226				ex de, hl 
1226			 
1226				ld (hl), e 
1226				inc hl 
1226				ld (hl), d 
1226			 
1226				inc hl 
1226			 
1226				; now at start of allocated data so save pointer 
1226			 
1226				push hl 
1226			 
1226				; jump to position of next node and setup empty header in DE 
1226			 
1226				ex de, hl 
1226			 
1226			;	inc hl ; move past end of block 
1226			 
1226				ld a, 0 
1226				ld (hl), a   ; empty marker 
1226				inc hl 
1226				ld (hl), a   ; size 
1226				inc hl  
1226				ld (hl), a   ; ptr 
1226				inc hl 
1226				ld (hl), a   ; ptr 
1226			 
1226			 
1226				pop hl 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mmr" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			.exit: 
1226				pop af 
1226				pop bc 
1226				pop de  
1226				ret 
1226			 
1226			 
1226			 
1226			 
1226			free:  
1226				push hl 
1226				push af 
1226				; get address in hl 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "fre" 
1226						CALLMONITOR 
1226					endif 
1226				; data is at hl - move to block count 
1226				dec hl 
1226				dec hl    ; get past pointer 
1226				dec hl 
1226			 
1226				ld a, (hl)    ; need this for a validation check 
1226			 
1226				dec hl    ; move to block marker 
1226			 
1226				; now check that the block count and block marker are the same  
1226			        ; this checks that we are on a malloc node and not random memory 
1226			        ; OK a faint chance this could be a problem but rare - famous last words! 
1226			 
1226				ld c, a 
1226				ld a, (hl)    
1226			 
1226				cp c 
1226				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1226			 
1226				; yes good chance we are on a malloc node 
1226			 
1226				ld a, 0      
1226				ld (hl), a   ; mark as free 
1226			 
1226				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1226			 
1226			.freeignore:  
1226			 
1226				pop af 
1226				pop hl 
1226			 
1226				ret 
1226			 
1226			 
1226			 
1226			endif 
1226			 
1226			; eof 
# End of file firmware_memory.asm
1226			  
1226			; device C  
1226			if SOUND_ENABLE  
1226				include "firmware_sound.asm"  
1226			endif  
1226			  
1226			include "firmware_diags.asm"  
1226			; Hardware diags menu 
1226			 
1226			 
1226			config: 
1226			 
1226 3e 00			ld a, 0 
1228 21 56 12			ld hl, .configmn 
122b cd ca 09			call menu 
122e			 
122e fe 00			cp 0 
1230 c8				ret z 
1231			 
1231 fe 01			cp 1 
1233 cc fa 12			call z, .savetostore 
1236			 
1236 fe 02			cp 2 
1238 cc f8 12			call z, .selautoload 
123b fe 03			cp 3 
123d cc f7 12			call z, .disautoload 
1240 fe 04			cp 4 
1242 cc f9 12			call z, .selbank 
1245 fe 05			cp 5 
1247 cc fb 12			call z, .debug_tog 
124a fe 06			cp 6 
124c cc 43 14			call z, .bpsgo 
124f fe 07			cp 7 
1251 cc 21 13			call z, hardware_diags 
1254			 
1254 18 d0			jr config 
1256			 
1256			.configmn: 
1256 66 12			dw .c3 
1258 7d 12			dw .c2 
125a 92 12			dw .c2a 
125c a8 12			dw .c2b 
125e			;	dw .c4 
125e c5 12			dw .m4 
1260 e0 12			dw .m4b 
1262 e8 12			dw .c1 
1264 00 00			dw 0 
1266				 
1266			 
1266 .. 00		.c3: db "Add Dictionary To File",0 
127d .. 00		.c2: db "Select Autoload File",0 
1292 .. 00		.c2a: db "Disable Autoload File", 0 
12a8 .. 00		.c2b: db "Select Storage Bank",0 
12bc .. 00		.c4: db "Settings",0 
12c5 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12e0 .. 00		.m4b:   db "Monitor",0 
12e8 .. 00		.c1: db "Hardware Diags",0 
12f7			 
12f7			 
12f7			.disautoload: 
12f7				if STORAGE_SE 
12f7				ld a, $fe      ; bit 0 clear 
12f7				ld (spi_device), a 
12f7			 
12f7				call storage_get_block_0 
12f7			 
12f7				ld a, 0 
12f7				ld (store_page+STORE_0_AUTOFILE), a 
12f7			 
12f7					ld hl, 0 
12f7					ld de, store_page 
12f7				call storage_write_block	 ; save update 
12f7				endif 
12f7			 
12f7			 
12f7 c9				ret 
12f8			 
12f8			 
12f8			 
12f8			; Select auto start 
12f8			 
12f8			.selautoload: 
12f8			 
12f8				 
12f8				if STORAGE_SE 
12f8			 
12f8					call config_dir 
12f8				        ld hl, scratch 
12f8					ld a, 0 
12f8					call menu 
12f8			 
12f8					cp 0 
12f8					ret z 
12f8			 
12f8					dec a 
12f8			 
12f8			 
12f8					; locate menu option 
12f8			 
12f8					ld hl, scratch 
12f8					call table_lookup 
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALl" 
12f8						CALLMONITOR 
12f8					endif 
12f8					; with the pointer to the menu it, the byte following the zero term is the file id 
12f8			 
12f8					ld a, 0 
12f8					ld bc, 50   ; max of bytes to look at 
12f8					cpir  
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALb" 
12f8						CALLMONITOR 
12f8					endif 
12f8					;inc hl 
12f8			 
12f8					ld a, (hl)   ; file id 
12f8					 
12f8				        ; save bank and file ids 
12f8			 
12f8					push af 
12f8			 
12f8			; TODO need to save to block 0 on bank 1	 
12f8			 
12f8					call storage_get_block_0 
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "AL0" 
12f8						CALLMONITOR 
12f8					endif 
12f8					pop af 
12f8			 
12f8					ld (store_page+STORE_0_FILERUN),a 
12f8					 
12f8					; save bank id 
12f8			 
12f8					ld a,(spi_device) 
12f8					ld (store_page+STORE_0_BANKRUN),a 
12f8			 
12f8					; enable auto run of store file 
12f8			 
12f8					ld a, 1 
12f8					ld (store_page+STORE_0_AUTOFILE),a 
12f8			 
12f8					; save buffer 
12f8			 
12f8					ld hl, 0 
12f8					ld de, store_page 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALw" 
12f8						CALLMONITOR 
12f8					endif 
12f8				call storage_write_block	 ; save update 
12f8			  
12f8			 
12f8			 
12f8			 
12f8					ld hl, scratch 
12f8					call config_fdir 
12f8			 
12f8			 
12f8				endif 
12f8 c9				ret 
12f9			 
12f9			 
12f9			 
12f9			; Select storage bank 
12f9			 
12f9			.selbank: 
12f9			 
12f9				if STORAGE_SE 
12f9				endif 
12f9				 
12f9 c9				ret 
12fa			 
12fa			if STORAGE_SE 
12fa			 
12fa			.config_ldir:   
12fa				; Load storage bank labels into menu array 
12fa			 
12fa				 
12fa			 
12fa			 
12fa				ret 
12fa			 
12fa			 
12fa			endif 
12fa			 
12fa			 
12fa			; Save user words to storage 
12fa			 
12fa			.savetostore: 
12fa			 
12fa				if STORAGE_SE 
12fa			 
12fa					call config_dir 
12fa				        ld hl, scratch 
12fa					ld a, 0 
12fa					call menu 
12fa					 
12fa					ld hl, scratch 
12fa					call config_fdir 
12fa			 
12fa			 
12fa				endif 
12fa			 
12fa c9				ret 
12fb			 
12fb			 
12fb			 
12fb			if STORAGE_SE 
12fb			 
12fb			config_fdir: 
12fb				; using the scratch dir go through and release the memory allocated for each string 
12fb				 
12fb				ld hl, scratch 
12fb			.cfdir:	ld e,(hl) 
12fb				inc hl 
12fb				ld d,(hl) 
12fb				inc hl 
12fb			 
12fb				ex de, hl 
12fb				call ishlzero 
12fb				ret z     ; return on null pointer 
12fb				call free 
12fb				ex de, hl 
12fb				jr .cfdir 
12fb			 
12fb			 
12fb				ret 
12fb			 
12fb			 
12fb			config_dir: 
12fb			 
12fb				; for the config menus that need to build a directory of storage call this routine 
12fb				; it will construct a menu in scratch to pass to menu 
12fb			 
12fb				; open storage device 
12fb			 
12fb				; execute DIR to build a list of files and their ids into scratch in menu format 
12fb				; once the menu has finished then will need to call config_fdir to release the strings 
12fb				 
12fb				; c = number items 
12fb			 
12fb				 
12fb				call storage_get_block_0 
12fb			 
12fb				ld hl, store_page     ; get current id count 
12fb				ld b, (hl) 
12fb				ld c, 0    ; count of files   
12fb			 
12fb			 
12fb				ld hl, scratch 
12fb				ld (store_tmp2), hl    ; location to poke strings 
12fb			 
12fb				; check for empty drive 
12fb			 
12fb				ld a, 0 
12fb				cp b 
12fb				jp z, .dirdone 
12fb			 
12fb				 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "Cdc" 
12fb						CALLMONITOR 
12fb					endif 
12fb			 
12fb			 
12fb			.diritem:	 
12fb				push bc 
12fb				; for each of the current ids do a search for them and if found push to stack 
12fb			 
12fb					ld hl, STORE_BLOCK_PHY 
12fb					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12fb					ld e,b 
12fb			 
12fb					call storage_findnextid 
12fb			 
12fb			 
12fb					; if found hl will be non zero 
12fb			 
12fb					call ishlzero 
12fb					jr z, .dirnotfound 
12fb			 
12fb					; increase count 
12fb			 
12fb					pop bc	 
12fb					inc c 
12fb					push bc 
12fb					 
12fb			 
12fb					; get file header and push the file name 
12fb			 
12fb					ld de, store_page 
12fb					call storage_read_block 
12fb			 
12fb					; push file id to stack 
12fb				 
12fb					ld a, (store_page) 
12fb					ld h, 0 
12fb					ld l, a 
12fb			 
12fb					;call forth_push_numhl 
12fb					; TODO store id 
12fb			 
12fb					push hl 
12fb			 
12fb					; push extent count to stack  
12fb				 
12fb					ld hl, store_page+3 
12fb			 
12fb					; get file name length 
12fb			 
12fb					call strlenz   
12fb			 
12fb					inc hl   ; cover zero term 
12fb					inc hl  ; stick the id at the end of the area 
12fb			 
12fb					push hl 
12fb					pop bc    ; move length to bc 
12fb			 
12fb					call malloc 
12fb			 
12fb					; TODO save malloc area to scratch 
12fb			 
12fb					ex de, hl 
12fb					ld hl, (store_tmp2) 
12fb					ld (hl), e 
12fb					inc hl 
12fb					ld (hl), d 
12fb					inc hl 
12fb					ld (store_tmp2), hl 
12fb			 
12fb					 
12fb			 
12fb					;pop hl   ; get source 
12fb			;		ex de, hl    ; swap aronund	 
12fb			 
12fb					ld hl, store_page+3 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "CFd" 
12fb						CALLMONITOR 
12fb					endif 
12fb					ldir 
12fb			 
12fb					; de is past string, move back one and store id 
12fb					 
12fb					dec de 
12fb			 
12fb					; store file id 
12fb			 
12fb					pop hl 
12fb					ex de,hl 
12fb					ld (hl), e 
12fb			 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "Cdi" 
12fb						CALLMONITOR 
12fb					endif 
12fb					 
12fb			.dirnotfound: 
12fb					pop bc     
12fb					djnz .diritem 
12fb				 
12fb			.dirdone:	 
12fb			 
12fb					ld a, 0 
12fb					ld hl, (store_tmp2) 
12fb					ld (hl), a 
12fb					inc hl 
12fb					ld (hl), a 
12fb					inc hl 
12fb					; push a count of the dir items found 
12fb			 
12fb			;		ld h, 0 
12fb			;		ld l, c 
12fb			 
12fb				ret 
12fb			 
12fb			endif 
12fb			 
12fb			 
12fb			; Settings 
12fb			; Run  
12fb			 
12fb			 
12fb			 
12fb			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12fb			;;hd_menu2:   db "        2: Editor",0   
12fb			;hd_menu2:   db "        2: Editor       6: Menu",0   
12fb			;hd_menu3:   db "        3: Storage",0 
12fb			;hd_menu4:   db "0=quit  4: Debug",0 
12fb			;hd_don:     db "ON",0 
12fb			;hd_doff:     db "OFF",0 
12fb			; 
12fb			; 
12fb			; 
12fb			;hardware_diags_old:       
12fb			; 
12fb			;.diagmenu: 
12fb			;	call clear_display 
12fb			;	ld a, display_row_1 
12fb			;	ld de, hd_menu1 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a, display_row_2 
12fb			;	ld de, hd_menu2 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a, display_row_3 
12fb			;	ld de, hd_menu3 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a,  display_row_4 
12fb			;	ld de, hd_menu4 
12fb			;	call str_at_display 
12fb			; 
12fb			;	; display debug state 
12fb			; 
12fb			;	ld de, hd_don 
12fb			;	ld a, (os_view_disable) 
12fb			;	cp 0 
12fb			;	jr z, .distog 
12fb			;	ld de, hd_doff 
12fb			;.distog: ld a, display_row_4+17 
12fb			;	call str_at_display 
12fb			; 
12fb			;	call update_display 
12fb			; 
12fb			;	call cin_wait 
12fb			; 
12fb			; 
12fb			; 
12fb			;	cp '4' 
12fb			;	jr nz, .diagn1 
12fb			; 
12fb			;	; debug toggle 
12fb			; 
12fb			;	ld a, (os_view_disable) 
12fb			;	ld b, '*' 
12fb			;	cp 0 
12fb			;	jr z, .debtog 
12fb			;	ld b, 0 
12fb			;.debtog:	 
12fb			;	ld a,b 
12fb			;	ld (os_view_disable),a 
12fb			; 
12fb			;.diagn1: cp '0' 
12fb			;	 ret z 
12fb			; 
12fb			;;	cp '1' 
12fb			;;       jp z, matrix	 
12fb			;;   TODO keyboard matrix test 
12fb			; 
12fb			;	cp '2' 
12fb			;	jp z, .diagedit 
12fb			; 
12fb			;;	cp '6' 
12fb			;;	jp z, .menutest 
12fb			;;if ENABLE_BASIC 
12fb			;;	cp '6' 
12fb			;;	jp z, basic 
12fb			;;endif 
12fb			 ; 
12fb			;	jp .diagmenu 
12fb			; 
12fb			; 
12fb			;	ret 
12fb			 
12fb			 
12fb			.debug_tog: 
12fb 21 42 13			ld hl, .menudebug 
12fe				 
12fe 3a 51 e3			ld a, (os_view_disable) 
1301 fe 2a			cp '*' 
1303 20 04			jr nz,.tdon  
1305 3e 01			ld a, 1 
1307 18 02			jr .tog1 
1309 3e 00		.tdon: ld a, 0 
130b			 
130b			.tog1: 
130b cd ca 09			call menu 
130e fe 00			cp 0 
1310 c8				ret z 
1311 fe 01			cp 1    ; disable debug 
1313 28 04			jr z, .dtog0 
1315 3e 2a			ld a, '*' 
1317 18 02			jr .dtogset 
1319 3e 00		.dtog0: ld a, 0 
131b 32 51 e3		.dtogset:  ld (os_view_disable), a 
131e c3 fb 12			jp .debug_tog 
1321			 
1321			 
1321			hardware_diags:       
1321			 
1321			.diagm: 
1321 21 34 13			ld hl, .menuitems 
1324 3e 00			ld a, 0 
1326 cd ca 09			call menu 
1329			 
1329 fe 00		         cp 0 
132b c8				 ret z 
132c			 
132c fe 02			cp 2 
132e ca 8d 13			jp z, .diagedit 
1331			 
1331			;	cp '6' 
1331			;	jp z, .menutest 
1331			;if ENABLE_BASIC 
1331			;	cp '6' 
1331			;	jp z, basic 
1331			;endif 
1331			  
1331 c3 21 13			jp .diagm 
1334			 
1334				 
1334 48 13		.menuitems:   	dw .m1 
1336 53 13				dw .m2 
1338 5a 13				dw .m3 
133a 62 13				dw .m5 
133c 68 13				dw .m5a 
133e 71 13				dw .m5b 
1340 00 00				dw 0 
1342			 
1342			.menudebug: 
1342 7a 13				dw .m6 
1344 83 13				dw .m7 
1346 00 00				dw 0 
1348			 
1348 .. 00		.m1:   db "Key Matrix",0 
1353 .. 00		.m2:   db "Editor",0 
135a .. 00		.m3:   db "Storage",0 
1362 .. 00		.m5:   db "Sound",0 
1368 .. 00		.m5a:  db "RAM Test",0 
1371 .. 00		.m5b:  db "LCD Test",0 
137a			 
137a .. 00		.m6:   db "Debug ON",0 
1383 .. 00		.m7:   db "Debug OFF",0 
138d			 
138d			; debug editor 
138d			 
138d			.diagedit: 
138d			 
138d 21 60 e3			ld hl, scratch 
1390			;	ld bc, 250 
1390			;	ldir 
1390				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1390 3e 00			ld a, 0 
1392 77				ld (hl), a 
1393 23				inc hl 
1394 77				ld (hl), a 
1395 23				inc hl 
1396 77				ld (hl), a 
1397			 
1397 cd 99 09		        call clear_display 
139a cd bc 09			call update_display 
139d 3e 01			ld a, 1 
139f 32 80 ee			ld (hardware_diag), a 
13a2			.diloop: 
13a2 3e 00			ld a, display_row_1 
13a4 0e 00			ld c, 0 
13a6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13a8 1e 28			ld e, 40 
13aa			 
13aa 21 60 e3			ld hl, scratch	 
13ad cd f3 0b			call input_str 
13b0			 
13b0 3e 28			ld a, display_row_2 
13b2 11 60 e3			ld de, scratch 
13b5 cd ac 09			call str_at_display 
13b8 cd bc 09			call update_display 
13bb			 
13bb c3 a2 13			jp .diloop 
13be			 
13be			 
13be			; pass word in hl 
13be			; a has display location 
13be			display_word_at: 
13be f5				push af 
13bf e5				push hl 
13c0 7c				ld a,h 
13c1 21 65 e6			ld hl, os_word_scratch 
13c4 cd c7 0e			call hexout 
13c7 e1				pop hl 
13c8 7d				ld a,l 
13c9 21 67 e6			ld hl, os_word_scratch+2 
13cc cd c7 0e			call hexout 
13cf 21 69 e6			ld hl, os_word_scratch+4 
13d2 3e 00			ld a,0 
13d4 77				ld (hl),a 
13d5 11 65 e6			ld de,os_word_scratch 
13d8 f1				pop af 
13d9 cd ac 09				call str_at_display 
13dc c9				ret 
13dd			 
13dd			display_ptr_state: 
13dd			 
13dd				; to restore afterwards 
13dd			 
13dd d5				push de 
13de c5				push bc 
13df e5				push hl 
13e0 f5				push af 
13e1			 
13e1				; for use in here 
13e1			 
13e1			;	push bc 
13e1			;	push de 
13e1			;	push hl 
13e1			;	push af 
13e1			 
13e1 cd 99 09			call clear_display 
13e4			 
13e4 11 b7 15			ld de, .ptrstate 
13e7 3e 00			ld a, display_row_1 
13e9 cd ac 09			call str_at_display 
13ec			 
13ec				; display debug step 
13ec			 
13ec			 
13ec 11 7a ee			ld de, debug_mark 
13ef 3e 26			ld a, display_row_1+display_cols-2 
13f1 cd ac 09			call str_at_display 
13f4			 
13f4				; display a 
13f4 11 c1 15			ld de, .ptrcliptr 
13f7 3e 28			ld a, display_row_2 
13f9 cd ac 09			call str_at_display 
13fc			 
13fc f1				pop af 
13fd 2a 2b eb			ld hl,(cli_ptr) 
1400 3e 30			ld a, display_row_2+8 
1402 cd be 13			call display_word_at 
1405			 
1405			 
1405				; display hl 
1405			 
1405			 
1405 11 c9 15			ld de, .ptrclioptr 
1408 3e 32			ld a, display_row_2+10 
140a cd ac 09			call str_at_display 
140d			; 
140d			;	pop hl 
140d 3e 35			ld a, display_row_2+13 
140f 2a 29 eb			ld hl,(cli_origptr) 
1412 cd be 13			call display_word_at 
1415			; 
1415			;	 
1415			;	; display de 
1415			 
1415			;	ld de, .regstatede 
1415			;	ld a, display_row_3 
1415			;	call str_at_display 
1415			 
1415			;	pop de 
1415			;	ld h,d 
1415			;	ld l, e 
1415			;	ld a, display_row_3+3 
1415			;	call display_word_at 
1415			 
1415			 
1415				; display bc 
1415			 
1415			;	ld de, .regstatebc 
1415			;	ld a, display_row_3+10 
1415			;	call str_at_display 
1415			 
1415			;	pop bc 
1415			;	ld h,b 
1415			;	ld l, c 
1415			;	ld a, display_row_3+13 
1415			;	call display_word_at 
1415			 
1415			 
1415				; display dsp 
1415			 
1415			;	ld de, .regstatedsp 
1415			;	ld a, display_row_4 
1415			;	call str_at_display 
1415			 
1415				 
1415			;	ld hl,(cli_data_sp) 
1415			;	ld a, display_row_4+4 
1415			;	call display_word_at 
1415			 
1415				; display rsp 
1415			 
1415 11 f8 15			ld de, .regstatersp 
1418 3e 82			ld a, display_row_4+10 
141a cd ac 09			call str_at_display 
141d			 
141d				 
141d 2a 11 eb			ld hl,(cli_ret_sp) 
1420 3e 86			ld a, display_row_4+14 
1422 cd be 13			call display_word_at 
1425			 
1425 cd bc 09			call update_display 
1428			 
1428 cd 0e 09			call delay1s 
142b cd 0e 09			call delay1s 
142e cd 0e 09			call delay1s 
1431			 
1431			 
1431 cd 3e 19			call next_page_prompt 
1434			 
1434				; restore  
1434			 
1434 f1				pop af 
1435 e1				pop hl 
1436 c1				pop bc 
1437 d1				pop de 
1438 c9				ret 
1439			 
1439			break_point_state: 
1439 f5				push af 
143a			 
143a				; see if disabled 
143a			 
143a 3a 51 e3			ld a, (os_view_disable) 
143d fe 2a			cp '*' 
143f 20 02			jr nz, .bpsgo 
1441 f1				pop af 
1442 c9				ret 
1443			 
1443			.bpsgo: 
1443 f1				pop af 
1444 f5				push af 
1445 22 4d e3			ld (os_view_hl), hl 
1448 ed 53 4b e3		ld (os_view_de), de 
144c ed 43 49 e3		ld (os_view_bc), bc 
1450 e5				push hl 
1451 6f				ld l, a 
1452 26 00			ld h, 0 
1454 22 4f e3			ld (os_view_af),hl 
1457			 
1457 21 c0 ed				ld hl, display_fb0 
145a 22 db eb				ld (display_fb_active), hl 
145d e1				pop hl	 
145e			 
145e 3e 31			ld a, '1' 
1460 fe 2a		.bps1:  cp '*' 
1462 20 03			jr nz, .bps1b 
1464 32 51 e3			ld (os_view_disable),a 
1467 fe 31		.bps1b:  cp '1' 
1469 20 14			jr nz, .bps2 
146b			 
146b				; display reg 
146b			 
146b				 
146b			 
146b 3a 4f e3			ld a, (os_view_af) 
146e 2a 4d e3			ld hl, (os_view_hl) 
1471 ed 5b 4b e3		ld de, (os_view_de) 
1475 ed 4b 49 e3		ld bc, (os_view_bc) 
1479 cd 13 15			call display_reg_state 
147c c3 ff 14			jp .bpschk 
147f			 
147f fe 32		.bps2:  cp '2' 
1481 20 08			jr nz, .bps3 
1483				 
1483				; display hl 
1483 2a 4d e3			ld hl, (os_view_hl) 
1486 cd fd 15			call display_dump_at_hl 
1489			 
1489 18 74			jr .bpschk 
148b			 
148b fe 33		.bps3:  cp '3' 
148d 20 08			jr nz, .bps4 
148f			 
148f			        ; display de 
148f 2a 4b e3			ld hl, (os_view_de) 
1492 cd fd 15			call display_dump_at_hl 
1495			 
1495 18 68			jr .bpschk 
1497 fe 34		.bps4:  cp '4' 
1499 20 08			jr nz, .bps5 
149b			 
149b			        ; display bc 
149b 2a 49 e3			ld hl, (os_view_bc) 
149e cd fd 15			call display_dump_at_hl 
14a1			 
14a1 18 5c			jr .bpschk 
14a3 fe 35		.bps5:  cp '5' 
14a5 20 08		        jr nz, .bps7 
14a7			 
14a7				; display cur ptr 
14a7 2a 2b eb			ld hl, (cli_ptr) 
14aa cd fd 15			call display_dump_at_hl 
14ad			 
14ad 18 50			jr .bpschk 
14af fe 36		.bps7:  cp '6' 
14b1 20 08			jr nz, .bps8b 
14b3				 
14b3				; display cur orig ptr 
14b3 2a 29 eb			ld hl, (cli_origptr) 
14b6 cd fd 15			call display_dump_at_hl 
14b9 18 44			jr .bpschk 
14bb fe 37		.bps8b:  cp '7' 
14bd 20 08			jr nz, .bps9 
14bf				 
14bf				; display dsp 
14bf 2a 0d eb			ld hl, (cli_data_sp) 
14c2 cd fd 15			call display_dump_at_hl 
14c5			 
14c5 18 38			jr .bpschk 
14c7 fe 39		.bps9:  cp '9' 
14c9 20 05			jr nz, .bps8c 
14cb				 
14cb				; display SP 
14cb			;	ld hl, sp 
14cb cd fd 15			call display_dump_at_hl 
14ce			 
14ce 18 2f			jr .bpschk 
14d0 fe 38		.bps8c:  cp '8' 
14d2 20 08			jr nz, .bps8d 
14d4				 
14d4				; display rsp 
14d4 2a 11 eb			ld hl, (cli_ret_sp) 
14d7 cd fd 15			call display_dump_at_hl 
14da			 
14da 18 23			jr .bpschk 
14dc fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14de 20 05			jr nz, .bps8 
14e0 cd 34 17			call monitor 
14e3			 
14e3 18 1a			jr .bpschk 
14e5 fe 30		.bps8:  cp '0' 
14e7 20 16			jr nz, .bpschk 
14e9			 
14e9 21 1f ed				ld hl, display_fb1 
14ec 22 db eb				ld (display_fb_active), hl 
14ef cd bc 09				call update_display 
14f2			 
14f2				;ld a, (os_view_af) 
14f2 2a 4d e3			ld hl, (os_view_hl) 
14f5 ed 5b 4b e3		ld de, (os_view_de) 
14f9 ed 4b 49 e3		ld bc, (os_view_bc) 
14fd f1				pop af 
14fe c9				ret 
14ff			 
14ff			.bpschk:   
14ff cd 0e 09			call delay1s 
1502 3e 9f		ld a,display_row_4 + display_cols - 1 
1504 11 3c 19		        ld de, endprg 
1507 cd ac 09			call str_at_display 
150a cd bc 09			call update_display 
150d cd c6 58			call cin_wait 
1510			 
1510 c3 60 14			jp .bps1 
1513			 
1513			 
1513			display_reg_state: 
1513			 
1513				; to restore afterwards 
1513			 
1513 d5				push de 
1514 c5				push bc 
1515 e5				push hl 
1516 f5				push af 
1517			 
1517				; for use in here 
1517			 
1517 c5				push bc 
1518 d5				push de 
1519 e5				push hl 
151a f5				push af 
151b			 
151b cd 99 09			call clear_display 
151e			 
151e 11 d3 15			ld de, .regstate 
1521 3e 00			ld a, display_row_1 
1523 cd ac 09			call str_at_display 
1526			 
1526				; display debug step 
1526			 
1526			 
1526 11 7a ee			ld de, debug_mark 
1529 3e 25			ld a, display_row_1+display_cols-3 
152b cd ac 09			call str_at_display 
152e			 
152e				; display a 
152e 11 ef 15			ld de, .regstatea 
1531 3e 28			ld a, display_row_2 
1533 cd ac 09			call str_at_display 
1536			 
1536 e1				pop hl 
1537			;	ld h,0 
1537			;	ld l, a 
1537 3e 2b			ld a, display_row_2+3 
1539 cd be 13			call display_word_at 
153c			 
153c			 
153c				; display hl 
153c			 
153c			 
153c 11 e3 15			ld de, .regstatehl 
153f 3e 32			ld a, display_row_2+10 
1541 cd ac 09			call str_at_display 
1544			 
1544 e1				pop hl 
1545 3e 35			ld a, display_row_2+13 
1547 cd be 13			call display_word_at 
154a			 
154a				 
154a				; display de 
154a			 
154a 11 e7 15			ld de, .regstatede 
154d 3e 50			ld a, display_row_3 
154f cd ac 09			call str_at_display 
1552			 
1552 e1				pop hl 
1553			;	ld h,d 
1553			;	ld l, e 
1553 3e 53			ld a, display_row_3+3 
1555 cd be 13			call display_word_at 
1558			 
1558			 
1558				; display bc 
1558			 
1558 11 eb 15			ld de, .regstatebc 
155b 3e 5a			ld a, display_row_3+10 
155d cd ac 09			call str_at_display 
1560			 
1560 e1				pop hl 
1561			;	ld h,b 
1561			;	ld l, c 
1561 3e 5d			ld a, display_row_3+13 
1563 cd be 13			call display_word_at 
1566			 
1566			 
1566				; display dsp 
1566			 
1566 11 f3 15			ld de, .regstatedsp 
1569 3e 78			ld a, display_row_4 
156b cd ac 09			call str_at_display 
156e			 
156e				 
156e 2a 0d eb			ld hl,(cli_data_sp) 
1571 3e 7c			ld a, display_row_4+4 
1573 cd be 13			call display_word_at 
1576			 
1576				; display rsp 
1576			 
1576 11 f8 15			ld de, .regstatersp 
1579 3e 82			ld a, display_row_4+10 
157b cd ac 09			call str_at_display 
157e			 
157e				 
157e 2a 11 eb			ld hl,(cli_ret_sp) 
1581 3e 86			ld a, display_row_4+14 
1583 cd be 13			call display_word_at 
1586			 
1586 cd bc 09			call update_display 
1589			 
1589			;	call delay1s 
1589			;	call delay1s 
1589			;	call delay1s 
1589			 
1589			 
1589			;	call next_page_prompt 
1589			 
1589				; restore  
1589			 
1589 f1				pop af 
158a e1				pop hl 
158b c1				pop bc 
158c d1				pop de 
158d c9				ret 
158e			 
158e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15a2 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15b7 .. 00		.ptrstate:	db "Ptr State",0 
15c1 .. 00		.ptrcliptr:     db "cli_ptr",0 
15c9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15d3 .. 00		.regstate:	db "Reg State (1/0)",0 
15e3 .. 00		.regstatehl:	db "HL:",0 
15e7 .. 00		.regstatede:	db "DE:",0 
15eb .. 00		.regstatebc:	db "BC:",0 
15ef .. 00		.regstatea:	db "A :",0 
15f3 .. 00		.regstatedsp:	db "DSP:",0 
15f8 .. 00		.regstatersp:	db "RSP:",0 
15fd			 
15fd			display_dump_at_hl: 
15fd e5				push hl 
15fe d5				push de 
15ff c5				push bc 
1600 f5				push af 
1601			 
1601 22 83 e6			ld (os_cur_ptr),hl	 
1604 cd 99 09			call clear_display 
1607 cd 46 18			call dumpcont 
160a			;	call delay1s 
160a			;	call next_page_prompt 
160a			 
160a			 
160a f1				pop af 
160b c1				pop bc 
160c d1				pop de 
160d e1				pop hl 
160e c9				ret 
160f			 
160f			;if ENABLE_BASIC 
160f			;	include "nascombasic.asm" 
160f			;	basic: 
160f			;	include "forth/FORTH.ASM" 
160f			;endif 
160f			 
160f			; eof 
160f			 
160f			 
# End of file firmware_diags.asm
160f			  
160f			  
160f			  
160f			  
160f			; eof  
160f			  
# End of file firmware.asm
160f			 
160f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
160f			;if BASE_KEV  
160f			;baseram: equ 08000h 
160f			;endif 
160f			 
160f			;if BASE_SC114 
160f			;baseram:     equ    endofcode 
160f			;endif 
160f			 
160f			 
160f			; start system 
160f			 
160f			coldstart: 
160f				; set sp 
160f				; di/ei 
160f			 
160f f3				di 
1610 31 00 f0			ld sp, tos 
1613			;	ei 
1613			 
1613			 
1613				; disable breakpoint by default 
1613			 
1613 3e 2a			ld a,'*' 
1615 32 51 e3			ld (os_view_disable),a 
1618			 
1618				; init hardware 
1618			 
1618				; init keyboard and screen hardware 
1618			 
1618 cd 03 01			call hardware_init 
161b			 
161b			 
161b				; detect if any keys are held down to enable breakpoints at start up 
161b			 
161b cd ce 58			call cin  
161e fe 00			cp 0 
1620 28 03			jr z, .nokeys 
1622			 
1622				;call hardware_diags 
1622 cd 26 12			call config 
1625			 
1625			;	ld de, .bpen 
1625			;	ld a, display_row_4 
1625			;	call str_at_display 
1625			;	call update_display 
1625			; 
1625			;	ld a,0 
1625			;	ld (os_view_disable),a 
1625			; 
1625			;.bpwait: 
1625			;	call cin 
1625			;	cp 0 
1625			;	jr z, .bpwait 
1625			;	jr .nokeys 
1625			; 
1625			; 
1625			;.bpen:  db "Break points enabled!",0 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			.nokeys: 
1625			 
1625			 
1625				 
1625			 
1625			;jp  testkey 
1625			 
1625			;call storage_get_block_0 
1625			; 
1625			;ld hl, 0 
1625			;ld de, store_page 
1625			;call storage_read_block 
1625			 
1625				 
1625			;ld hl, 10 
1625			;ld de, store_page 
1625			;call storage_read_block 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			;stop:	nop 
1625			;	jp stop 
1625			 
1625			 
1625			 
1625			main: 
1625 cd 99 09			call clear_display 
1628 cd bc 09			call update_display 
162b			 
162b			 
162b			 
162b			;	call testlcd 
162b			 
162b			 
162b			 
162b cd 04 1d			call forth_init 
162e			 
162e			 
162e			warmstart: 
162e cd da 1c			call forth_warmstart 
1631			 
1631				; run startup word load 
1631			        ; TODO prevent this running at warmstart after crash  
1631			 
1631				if STARTUP_ENABLE 
1631					if STORAGE_SE 
1631						call forth_autoload 
1631					endif 
1631 cd 14 55				call forth_startup 
1634			 
1634			 
1634				endif 
1634			 
1634				; show free memory after boot 
1634 11 ce 16			ld de, freeram 
1637 3e 00			ld a, display_row_1 
1639 cd ac 09			call str_at_display 
163c			 
163c			; Or use heap_size word???? 
163c 21 46 e3			ld hl, heap_end 
163f 11 f6 58			ld de, heap_start 
1642 ed 52			sbc hl, de 
1644 e5				push hl 
1645 7c				ld a,h	         	 
1646 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1649 cd c7 0e			call hexout 
164c e1			   	pop hl 
164d			 
164d 7d				ld a,l 
164e 21 67 e6			ld hl, os_word_scratch+2 
1651 cd c7 0e			call hexout 
1654 21 69 e6			ld hl, os_word_scratch+4 
1657 3e 00			ld a, 0 
1659 77				ld (hl),a 
165a 11 65 e6			ld de, os_word_scratch 
165d 3e 0d			ld a, display_row_1 + 13 
165f cd ac 09			call str_at_display 
1662 cd bc 09			call update_display 
1665			 
1665			 
1665				;call demo 
1665			 
1665			 
1665				; init scratch input area for cli commands 
1665			 
1665 21 87 e6			ld hl, os_cli_cmd 
1668 3e 00			ld a,0 
166a 77				ld (hl),a 
166b 23				inc hl 
166c 77				ld (hl),a 
166d			 
166d 3e 00			ld a,0 
166f 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1672			 
1672 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1675 32 84 e6			ld (os_cur_ptr+1),a	 
1678			 
1678 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
167b 32 66 e6			ld (os_word_scratch+1),a	 
167e				 
167e			 
167e				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
167e 21 87 e6			ld hl, os_cli_cmd 
1681			 
1681 3e 00			ld a, 0		 ; init cli input 
1683 77				ld (hl), a 
1684 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1686			cli: 
1686				; show cli prompt 
1686				;push af 
1686				;ld a, 0 
1686				;ld de, prompt 
1686				;call str_at_display 
1686			 
1686				;call update_display 
1686				;pop af 
1686				;inc a 
1686				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1686 0e 00			ld c, 0 
1688 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
168a 1e 28			ld e, 40 
168c			 
168c 21 87 e6			ld hl, os_cli_cmd 
168f			 
168f				STACKFRAME OFF $fefe $9f9f 
168f				if DEBUG_STACK_IMB 
168f					if OFF 
168f						exx 
168f						ld de, $fefe 
168f						ld a, d 
168f						ld hl, curframe 
168f						call hexout 
168f						ld a, e 
168f						ld hl, curframe+2 
168f						call hexout 
168f						ld hl, $fefe 
168f						push hl 
168f						ld hl, $9f9f 
168f						push hl 
168f						exx 
168f					endif 
168f				endif 
168f			endm 
# End of macro STACKFRAME
168f			 
168f cd f3 0b			call input_str 
1692			 
1692				STACKFRAMECHK OFF $fefe $9f9f 
1692				if DEBUG_STACK_IMB 
1692					if OFF 
1692						exx 
1692						ld hl, $9f9f 
1692						pop de   ; $9f9f 
1692						call cmp16 
1692						jr nz, .spnosame 
1692						ld hl, $fefe 
1692						pop de   ; $fefe 
1692						call cmp16 
1692						jr z, .spfrsame 
1692						.spnosame: call showsperror 
1692						.spfrsame: nop 
1692						exx 
1692					endif 
1692				endif 
1692			endm 
# End of macro STACKFRAMECHK
1692			 
1692				; copy input to last command 
1692			 
1692 21 87 e6			ld hl, os_cli_cmd 
1695 11 86 e7			ld de, os_last_cmd 
1698 01 ff 00			ld bc, 255 
169b ed b0			ldir 
169d			 
169d				; wipe current buffer 
169d			 
169d			;	ld a, 0 
169d			;	ld hl, os_cli_cmd 
169d			;	ld de, os_cli_cmd+1 
169d			;	ld bc, 254 
169d			;	ldir 
169d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
169d			;	call strcpy 
169d			;	ld a, 0 
169d			;	ld (hl), a 
169d			;	inc hl 
169d			;	ld (hl), a 
169d			;	inc hl 
169d			;	ld (hl), a 
169d			 
169d				; switch frame buffer to program  
169d			 
169d 21 1f ed				ld hl, display_fb1 
16a0 22 db eb				ld (display_fb_active), hl 
16a3			 
16a3			;	nop 
16a3				STACKFRAME ON $fbfe $8f9f 
16a3				if DEBUG_STACK_IMB 
16a3					if ON 
16a3						exx 
16a3						ld de, $fbfe 
16a3						ld a, d 
16a3						ld hl, curframe 
16a3						call hexout 
16a3						ld a, e 
16a3						ld hl, curframe+2 
16a3						call hexout 
16a3						ld hl, $fbfe 
16a3						push hl 
16a3						ld hl, $8f9f 
16a3						push hl 
16a3						exx 
16a3					endif 
16a3				endif 
16a3			endm 
# End of macro STACKFRAME
16a3				; first time into the parser so pass over the current scratch pad 
16a3 21 87 e6			ld hl,os_cli_cmd 
16a6				; tokenise the entered statement(s) in HL 
16a6 cd 7d 1d			call forthparse 
16a9			        ; exec forth statements in top of return stack 
16a9 cd bd 1d			call forthexec 
16ac				;call forthexec_cleanup 
16ac			;	call parsenext 
16ac			 
16ac				STACKFRAMECHK ON $fbfe $8f9f 
16ac				if DEBUG_STACK_IMB 
16ac					if ON 
16ac						exx 
16ac						ld hl, $8f9f 
16ac						pop de   ; $8f9f 
16ac						call cmp16 
16ac						jr nz, .spnosame 
16ac						ld hl, $fbfe 
16ac						pop de   ; $fbfe 
16ac						call cmp16 
16ac						jr z, .spfrsame 
16ac						.spnosame: call showsperror 
16ac						.spfrsame: nop 
16ac						exx 
16ac					endif 
16ac				endif 
16ac			endm 
# End of macro STACKFRAMECHK
16ac				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
16ac			 
16ac 3e 78			ld a, display_row_4 
16ae 11 e0 16			ld de, endprog 
16b1			 
16b1 cd bc 09			call update_display		 
16b4			 
16b4 cd 3e 19			call next_page_prompt 
16b7			 
16b7				; switch frame buffer to cli 
16b7			 
16b7 21 c0 ed				ld hl, display_fb0 
16ba 22 db eb				ld (display_fb_active), hl 
16bd			 
16bd			 
16bd cd 99 09		        call clear_display 
16c0 cd bc 09			call update_display		 
16c3			 
16c3 21 87 e6			ld hl, os_cli_cmd 
16c6			 
16c6 3e 00			ld a, 0		 ; init cli input 
16c8 77				ld (hl), a 
16c9			 
16c9				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
16c9			 
16c9				; now on last line 
16c9			 
16c9				; TODO scroll screen up 
16c9			 
16c9				; TODO instead just clear screen and place at top of screen 
16c9			 
16c9			;	ld a, 0 
16c9			;	ld (f_cursor_ptr),a 
16c9			 
16c9				;call clear_display 
16c9				;call update_display 
16c9			 
16c9				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16c9 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16cb c3 86 16			jp cli 
16ce			 
16ce .. 00		freeram: db "Free bytes: $",0 
16dc ..			asc: db "1A2F" 
16e0 .. 00		endprog: db "End prog...",0 
16ec			 
16ec			testenter2:   
16ec 21 92 e3			ld hl,scratch+50 
16ef 22 83 e6			ld (os_cur_ptr),hl 
16f2 c3 86 16			jp cli 
16f5			 
16f5			testenter:  
16f5			 
16f5 21 dc 16			ld hl,asc 
16f8			;	ld a,(hl) 
16f8			;	call nibble2val 
16f8 cd 1d 0f			call get_byte 
16fb			 
16fb			 
16fb			;	ld a,(hl) 
16fb			;	call atohex 
16fb			 
16fb			;	call fourehexhl 
16fb 32 92 e3			ld (scratch+50),a 
16fe			 
16fe			 
16fe			 
16fe 21 de 16			ld hl,asc+2 
1701			;	ld a, (hl) 
1701			;	call nibble2val 
1701 cd 1d 0f			call get_byte 
1704			 
1704			;	call fourehexhl 
1704 32 94 e3			ld (scratch+52),a 
1707				 
1707 21 92 e3			ld hl,scratch+50 
170a 22 83 e6			ld (os_cur_ptr),hl 
170d c3 86 16			jp cli 
1710			 
1710			enter:	 
1710 3a 64 e3			ld a,(scratch+4) 
1713 fe 00			cp 0 
1715 28 0c			jr z, .entercont 
1717				; no, not a null term line so has an address to work out.... 
1717			 
1717 21 62 e3			ld hl,scratch+2 
171a cd 7d 0f			call get_word_hl 
171d			 
171d 22 83 e6			ld (os_cur_ptr),hl	 
1720 c3 86 16			jp cli 
1723			 
1723			 
1723			.entercont:  
1723			 
1723 21 62 e3			ld hl, scratch+2 
1726 cd 1d 0f			call get_byte 
1729			 
1729 2a 83 e6		   	ld hl,(os_cur_ptr) 
172c 77					ld (hl),a 
172d 23					inc hl 
172e 22 83 e6				ld (os_cur_ptr),hl 
1731				 
1731			; get byte  
1731			 
1731			 
1731 c3 86 16			jp cli 
1734			 
1734			 
1734			; basic monitor support 
1734			 
1734			monitor: 
1734				;  
1734 cd 99 09			call clear_display 
1737 3e 00			ld a, 0 
1739 11 81 17			ld de, .monprompt 
173c cd ac 09			call str_at_display 
173f cd bc 09			call update_display 
1742			 
1742				; get a monitor command 
1742			 
1742 0e 00			ld c, 0     ; entry at top left 
1744 16 64			ld d, 100   ; max buffer size 
1746 1e 0f			ld e, 15    ; input scroll area 
1748 3e 00			ld a, 0     ; init string 
174a 21 5e e5			ld hl, os_input 
174d 77				ld (hl), a 
174e 23				inc hl 
174f 77				ld (hl), a 
1750 21 5e e5			ld hl, os_input 
1753 3e 01			ld a, 1     ; init string 
1755 cd f3 0b			call input_str 
1758			 
1758 cd 99 09		        call clear_display 
175b cd bc 09			call update_display		 
175e			 
175e 3a 5e e5			ld a, (os_input) 
1761 cd 1b 10			call toUpper 
1764 fe 48		        cp 'H' 
1766 28 6f		        jr z, .monhelp 
1768 fe 44			cp 'D'		; dump 
176a ca f8 17			jp z, .mondump	 
176d fe 43			cp 'C'		; dump 
176f ca 12 18			jp z, .moncdump	 
1772 fe 4d			cp 'M'		; dump 
1774 ca 83 17			jp z, .moneditstart 
1777 fe 55			cp 'U'		; dump 
1779 28 14			jr z, .monedit	 
177b fe 51			cp 'Q'		; dump 
177d c8				ret z	 
177e			 
177e			 
177e				; TODO "S" to access symbol by name and not need the address 
177e				; TODO "F" to find a string in memory 
177e			 
177e c3 34 17			jp monitor 
1781			 
1781 .. 00		.monprompt: db ">", 0 
1783			 
1783			.moneditstart: 
1783				; get starting address 
1783			 
1783 21 60 e5			ld hl,os_input+2 
1786 cd 7d 0f			call get_word_hl 
1789			 
1789 22 83 e6			ld (os_cur_ptr),hl	 
178c			 
178c c3 34 17			jp monitor 
178f			 
178f			.monedit: 
178f				; get byte to load 
178f			 
178f 21 60 e5			ld hl,os_input+2 
1792 cd 1d 0f			call get_byte 
1795			 
1795				; get address to update 
1795 2a 83 e6			ld hl, (os_cur_ptr) 
1798			 
1798				; update byte 
1798			 
1798 77				ld (hl), a 
1799			 
1799				; move to next address and save it 
1799			 
1799 23				inc hl 
179a 22 83 e6			ld (os_cur_ptr),hl	 
179d			 
179d c3 34 17			jp monitor 
17a0			 
17a0			 
17a0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17b4 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17d0 .. 00		.monhelptext3:  db "Q-Quit",0 
17d7			        
17d7			.monhelp: 
17d7 3e 00			ld a, display_row_1 
17d9 11 a0 17		        ld de, .monhelptext1 
17dc			 
17dc cd ac 09			call str_at_display 
17df 3e 28			ld a, display_row_2 
17e1 11 b4 17		        ld de, .monhelptext2 
17e4					 
17e4 cd ac 09			call str_at_display 
17e7 3e 50			ld a, display_row_3 
17e9 11 d0 17		        ld de, .monhelptext3 
17ec					 
17ec cd ac 09			call str_at_display 
17ef cd bc 09			call update_display		 
17f2			 
17f2 cd 3e 19			call next_page_prompt 
17f5 c3 34 17			jp monitor 
17f8			 
17f8			.mondump:    
17f8 21 60 e5			ld hl,os_input+2 
17fb cd 7d 0f			call get_word_hl 
17fe			 
17fe 22 83 e6			ld (os_cur_ptr),hl	 
1801 cd 46 18			call dumpcont 
1804 3e 78			ld a, display_row_4 
1806 11 e0 16			ld de, endprog 
1809			 
1809 cd bc 09			call update_display		 
180c			 
180c cd 3e 19			call next_page_prompt 
180f c3 34 17			jp monitor 
1812			.moncdump: 
1812 cd 46 18			call dumpcont 
1815 3e 78			ld a, display_row_4 
1817 11 e0 16			ld de, endprog 
181a			 
181a cd bc 09			call update_display		 
181d			 
181d cd 3e 19			call next_page_prompt 
1820 c3 34 17			jp monitor 
1823			 
1823			 
1823			; TODO symbol access  
1823			 
1823			.symbols:     ;; A list of symbols that can be called up  
1823 c0 ed			dw display_fb0 
1825 .. 00			db "fb0",0  
1829 65 eb		     	dw store_page 
182b .. 00			db "store_page",0 
1836			 
1836			 
1836			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1836			 
1836 3a 61 e3			ld a,(scratch+1) 
1839 fe 00			cp 0 
183b 28 09			jr z, dumpcont 
183d			 
183d				; no, not a null term line so has an address to work out.... 
183d			 
183d 21 62 e3			ld hl,scratch+2 
1840 cd 7d 0f			call get_word_hl 
1843			 
1843 22 83 e6			ld (os_cur_ptr),hl	 
1846			 
1846			 
1846			 
1846			dumpcont: 
1846			 
1846				; dump bytes at ptr 
1846			 
1846			 
1846 3e 00			ld a, display_row_1 
1848 2a db eb			ld hl, (display_fb_active) 
184b cd c6 0b			call addatohl 
184e cd 76 18			call .dumpbyterow 
1851			 
1851 3e 28			ld a, display_row_2 
1853 2a db eb			ld hl, (display_fb_active) 
1856 cd c6 0b			call addatohl 
1859 cd 76 18			call .dumpbyterow 
185c			 
185c			 
185c 3e 50			ld a, display_row_3 
185e 2a db eb			ld hl, (display_fb_active) 
1861 cd c6 0b			call addatohl 
1864 cd 76 18			call .dumpbyterow 
1867			 
1867 3e 78			ld a, display_row_4 
1869 2a db eb			ld hl, (display_fb_active) 
186c cd c6 0b			call addatohl 
186f cd 76 18			call .dumpbyterow 
1872			 
1872 cd bc 09			call update_display 
1875			;		jp cli 
1875 c9				ret 
1876			 
1876			.dumpbyterow: 
1876			 
1876				;push af 
1876			 
1876 e5				push hl 
1877			 
1877				; calc where to poke the ascii 
1877			if display_cols == 20 
1877				ld a, 16 
1877			else 
1877 3e 1f			ld a, 31 
1879			endif 
1879			 
1879 cd c6 0b			call addatohl 
187c 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
187f			 
187f			 
187f			; display decoding address 
187f 2a 83 e6		   	ld hl,(os_cur_ptr) 
1882			 
1882 7c				ld a,h 
1883 e1				pop hl 
1884 e5				push hl 
1885			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1885 cd c7 0e			call hexout 
1888 2a 83 e6		   	ld hl,(os_cur_ptr) 
188b			 
188b 7d				ld a,l 
188c e1				pop hl 
188d 23				inc hl 
188e 23				inc hl 
188f e5				push hl 
1890			;	ld hl, os_word_scratch+2 
1890 cd c7 0e			call hexout 
1893 e1				pop hl 
1894 23				inc hl 
1895 23				inc hl 
1896				;ld hl, os_word_scratch+4 
1896 3e 3a			ld a, ':' 
1898 77				ld (hl),a 
1899 23				inc hl 
189a				;ld a, 0 
189a				;ld (hl),a 
189a				;ld de, os_word_scratch 
189a				;pop af 
189a				;push af 
189a			;		ld a, display_row_2 
189a			;		call str_at_display 
189a			;		call update_display 
189a			 
189a			 
189a			;pop af 
189a			;	add 5 
189a			 
189a			if display_cols == 20 
189a				ld b, 4 
189a			else 
189a 06 08			ld b, 8 
189c			endif	 
189c			 
189c			.dumpbyte: 
189c c5				push bc 
189d e5				push hl 
189e			 
189e			 
189e 2a 83 e6		   	ld hl,(os_cur_ptr) 
18a1 7e					ld a,(hl) 
18a2			 
18a2					; poke the ascii to display 
18a2 2a 65 e6				ld hl,(os_word_scratch) 
18a5 77					ld (hl),a 
18a6 23					inc hl 
18a7 22 65 e6				ld (os_word_scratch),hl 
18aa			 
18aa					 
18aa			 
18aa			 
18aa e1					pop hl 
18ab e5					push hl 
18ac			 
18ac cd c7 0e				call hexout 
18af			 
18af					 
18af 2a 83 e6		   	ld hl,(os_cur_ptr) 
18b2 23				inc hl 
18b3 22 83 e6		   	ld (os_cur_ptr),hl 
18b6			 
18b6 e1					pop hl 
18b7 23					inc hl 
18b8 23					inc hl 
18b9 23					inc hl 
18ba			 
18ba			 
18ba			 
18ba					;ld a,0 
18ba					;ld (os_word_scratch+2),a 
18ba					;pop af 
18ba					;push af 
18ba			 
18ba					;ld de, os_word_scratch 
18ba					;call str_at_display 
18ba			;		call update_display 
18ba			;		pop af 
18ba c1					pop bc 
18bb c6 03				add 3 
18bd 10 dd			djnz .dumpbyte 
18bf			 
18bf				 
18bf			 
18bf c9				ret 
18c0			 
18c0			jump:	 
18c0			 
18c0 21 62 e3			ld hl,scratch+2 
18c3 cd 7d 0f			call get_word_hl 
18c6				;ld hl,(scratch+2) 
18c6				;call fourehexhl 
18c6			 
18c6 22 83 e6			ld (os_cur_ptr),hl	 
18c9			 
18c9 e9				jp (hl) 
18ca			 
18ca			 
18ca			 
18ca			; TODO implement a basic monitor mode to start with 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			; testing and demo code during development 
18ca			 
18ca			 
18ca .. 00		str1: db "Enter some text...",0 
18dd .. 00		clear: db "                    ",0 
18f2			 
18f2			demo: 
18f2			 
18f2			 
18f2			 
18f2			;	call update_display 
18f2			 
18f2				; init scratch input area for testing 
18f2 21 60 e3			ld hl, scratch	 
18f5 3e 00			ld a,0 
18f7 77				ld (hl),a 
18f8			 
18f8			 
18f8 3e 28		            LD   A, display_row_2 
18fa			;            CALL fLCD_Pos       ;Position cursor to location in A 
18fa 11 ca 18		            LD   DE, str1 
18fd cd ac 09			call str_at_display 
1900			 
1900			;            CALL fLCD_Str       ;Display string pointed to by DE 
1900			cloop:	 
1900 3e 50		            LD   A, display_row_3 
1902			;            CALL fLCD_Pos       ;Position cursor to location in A 
1902 11 dd 18		            LD   DE, clear 
1905			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1905 cd ac 09				call str_at_display 
1908 3e 78			ld a, display_row_4 
190a 11 3a 19			ld de, prompt 
190d			 
190d cd ac 09				call str_at_display 
1910 cd bc 09			call update_display 
1913			 
1913 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1915 16 0a			ld d, 10 
1917 21 60 e3			ld hl, scratch	 
191a cd f3 0b			call input_str 
191d			 
191d			;	call clear_display 
191d			;'	call update_display 
191d			 
191d 3e 00		            LD   A, display_row_1 
191f			;            CALL fLCD_Pos       ;Position cursor to location in A 
191f 11 dd 18		            LD   DE, clear 
1922 cd ac 09				call str_at_display 
1925			;            CALL fLCD_Str       ;Display string pointed to by DE 
1925 3e 00		            LD   A, display_row_1 
1927			;            CALL fLCD_Pos       ;Position cursor to location in A 
1927 11 60 e3		            LD   DE, scratch 
192a			;            CALL fLCD_Str       ;Display string pointed to by DE 
192a cd ac 09				call str_at_display 
192d cd bc 09			call update_display 
1930			 
1930 3e 00				ld a,0 
1932 21 60 e3			ld hl, scratch 
1935 77				ld (hl),a 
1936			 
1936 00				nop 
1937 c3 00 19			jp cloop 
193a			 
193a			 
193a			 
193a			; OS Prompt 
193a			 
193a .. 00		prompt: db ">",0 
193c .. 00		endprg: db "?",0 
193e			 
193e			 
193e			; handy next page prompt 
193e			next_page_prompt: 
193e e5				push hl 
193f d5				push de 
1940 f5				push af 
1941 c5				push bc 
1942			 
1942 3e 9f			ld a,display_row_4 + display_cols - 1 
1944 11 3c 19		        ld de, endprg 
1947 cd ac 09			call str_at_display 
194a cd bc 09			call update_display 
194d cd c6 58			call cin_wait 
1950 c1				pop bc 
1951 f1				pop af 
1952 d1				pop de 
1953 e1				pop hl 
1954			 
1954			 
1954 c9				ret 
1955			 
1955			 
1955			; forth parser 
1955			 
1955			; My forth kernel 
1955			include "forth_kernel.asm" 
1955			; 
1955			; kernel to the forth OS 
1955			 
1955			DS_TYPE_STR: equ 1     ; string type 
1955			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1955			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1955			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1955			 
1955			FORTH_PARSEV1: equ 0 
1955			FORTH_PARSEV2: equ 0 
1955			FORTH_PARSEV3: equ 0 
1955			FORTH_PARSEV4: equ 0 
1955			FORTH_PARSEV5: equ 1 
1955			 
1955			;if FORTH_PARSEV5 
1955			;	FORTH_END_BUFFER: equ 0 
1955			;else 
1955			FORTH_END_BUFFER: equ 127 
1955			;endif 
1955			 
1955			FORTH_TRUE: equ 1 
1955			FORTH_FALSE: equ 0 
1955			 
1955			if FORTH_PARSEV4 
1955			include "forth_stackops.asm" 
1955			endif 
1955			 
1955			if FORTH_PARSEV5 
1955			include "forth_stackopsv5.asm" 
1955			 
1955			; Stack operations for v5 parser on wards 
1955			; * DATA stack 
1955			; * LOOP stack 
1955			; * RETURN stack 
1955			 
1955			 
1955			 
1955			FORTH_CHK_DSP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_data_sp) 
1955				ld de, cli_data_stack 
1955				call cmp16 
1955				jp c, fault_dsp_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			 
1955			FORTH_CHK_RSP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_ret_sp) 
1955				ld de, cli_ret_stack 
1955				call cmp16 
1955				jp c, fault_rsp_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			FORTH_CHK_LOOP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_loop_sp) 
1955				ld de, cli_loop_stack 
1955				call cmp16 
1955				jp c, fault_loop_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			FORTH_ERR_TOS_NOTSTR: macro 
1955				; TOSO might need more for checks when used 
1955				push af 
1955				ld a,(hl) 
1955				cp DS_TYPE_STR 
1955				jp nz, type_faultn   
1955				pop af 
1955				endm 
1955			 
1955			FORTH_ERR_TOS_NOTNUM: macro 
1955				push af 
1955				ld a,(hl) 
1955				cp DS_TYPE_INUM 
1955				jp nz, type_faultn   
1955				pop af 
1955				endm 
1955			 
1955			 
1955			; increase data stack pointer and save hl to it 
1955				 
1955			FORTH_DSP_NEXT: macro 
1955				call macro_forth_dsp_next 
1955				endm 
1955			 
1955			 
1955			macro_forth_dsp_next: 
1955				if DEBUG_FORTH_STACK_GUARD 
1955 cd de 55				call check_stacks 
1958				endif 
1958 e5				push hl 
1959 d5				push de 
195a eb				ex de,hl 
195b 2a 0d eb			ld hl,(cli_data_sp) 
195e 23				inc hl 
195f 23				inc hl 
1960			 
1960			; PARSEV5 
1960 23				inc hl 
1961 22 0d eb			ld (cli_data_sp),hl 
1964 73				ld (hl), e 
1965 23				inc hl 
1966 72				ld (hl), d 
1967 d1				pop de 
1968 e1				pop hl 
1969				if DEBUG_FORTH_STACK_GUARD 
1969 cd de 55				call check_stacks 
196c				endif 
196c c9				ret 
196d			 
196d			 
196d			; increase ret stack pointer and save hl to it 
196d				 
196d			FORTH_RSP_NEXT: macro 
196d				call macro_forth_rsp_next 
196d				endm 
196d			 
196d			macro_forth_rsp_next: 
196d				if DEBUG_FORTH_STACK_GUARD 
196d cd de 55				call check_stacks 
1970				endif 
1970 e5				push hl 
1971 d5				push de 
1972 eb				ex de,hl 
1973 2a 11 eb			ld hl,(cli_ret_sp) 
1976 23				inc hl 
1977 23				inc hl 
1978 22 11 eb			ld (cli_ret_sp),hl 
197b 73				ld (hl), e 
197c 23				inc hl 
197d 72				ld (hl), d 
197e d1				pop de 
197f e1				pop hl 
1980				if DEBUG_FORTH_STACK_GUARD 
1980 cd de 55				call check_stacks 
1983				endif 
1983 c9				ret 
1984			 
1984			; get current ret stack pointer and save to hl  
1984				 
1984			FORTH_RSP_TOS: macro 
1984				call macro_forth_rsp_tos 
1984				endm 
1984			 
1984			macro_forth_rsp_tos: 
1984				;push de 
1984 2a 11 eb			ld hl,(cli_ret_sp) 
1987 cd bf 19			call loadhlptrtohl 
198a				;ld e, (hl) 
198a				;inc hl 
198a				;ld d, (hl) 
198a				;ex de, hl 
198a					if DEBUG_FORTH_WORDS 
198a			;			DMARK "RST" 
198a						CALLMONITOR 
198a cd 39 14			call break_point_state  
198d				endm  
# End of macro CALLMONITOR
198d					endif 
198d				;pop de 
198d c9				ret 
198e			 
198e			; pop ret stack pointer 
198e				 
198e			FORTH_RSP_POP: macro 
198e				call macro_forth_rsp_pop 
198e				endm 
198e			 
198e			 
198e			macro_forth_rsp_pop: 
198e				if DEBUG_FORTH_STACK_GUARD 
198e			;		DMARK "RPP" 
198e cd de 55				call check_stacks 
1991					FORTH_CHK_RSP_UNDER 
1991 e5				push hl 
1992 d5				push de 
1993 2a 11 eb			ld hl,(cli_ret_sp) 
1996 11 cb ea			ld de, cli_ret_stack 
1999 cd e4 0b			call cmp16 
199c da f2 56			jp c, fault_rsp_under 
199f d1				pop de 
19a0 e1				pop hl 
19a1				endm 
# End of macro FORTH_CHK_RSP_UNDER
19a1				endif 
19a1 e5				push hl 
19a2 2a 11 eb			ld hl,(cli_ret_sp) 
19a5			 
19a5			 
19a5				if FORTH_ENABLE_FREE 
19a5			 
19a5					; get pointer 
19a5			 
19a5					push de 
19a5					push hl 
19a5			 
19a5					ld e, (hl) 
19a5					inc hl 
19a5					ld d, (hl) 
19a5			 
19a5					ex de, hl 
19a5					call free 
19a5			 
19a5					pop hl 
19a5					pop de 
19a5			 
19a5			 
19a5				endif 
19a5			 
19a5			 
19a5 2b				dec hl 
19a6 2b				dec hl 
19a7 22 11 eb			ld (cli_ret_sp), hl 
19aa				; do stack underflow checks 
19aa e1				pop hl 
19ab				if DEBUG_FORTH_STACK_GUARD 
19ab cd de 55				call check_stacks 
19ae					FORTH_CHK_RSP_UNDER 
19ae e5				push hl 
19af d5				push de 
19b0 2a 11 eb			ld hl,(cli_ret_sp) 
19b3 11 cb ea			ld de, cli_ret_stack 
19b6 cd e4 0b			call cmp16 
19b9 da f2 56			jp c, fault_rsp_under 
19bc d1				pop de 
19bd e1				pop hl 
19be				endm 
# End of macro FORTH_CHK_RSP_UNDER
19be				endif 
19be c9				ret 
19bf			 
19bf			 
19bf			 
19bf			; routine to load word pointed to by hl into hl 
19bf			 
19bf			loadhlptrtohl: 
19bf			 
19bf d5				push de 
19c0 5e				ld e, (hl) 
19c1 23				inc hl 
19c2 56				ld d, (hl) 
19c3 eb				ex de, hl 
19c4 d1				pop de 
19c5			 
19c5 c9				ret 
19c6			 
19c6			 
19c6			 
19c6			 
19c6			 
19c6			; push a number held in HL onto the data stack 
19c6			; entry point for pushing a value when already in hl used in function above 
19c6			 
19c6			forth_push_numhl: 
19c6			 
19c6 e5				push hl    ; save value to push 
19c7			 
19c7			if DEBUG_FORTH_PUSH 
19c7				; see if disabled 
19c7			 
19c7			 
19c7 f5				push af 
19c8 3a 51 e3			ld a, (os_view_disable) 
19cb fe 2a			cp '*' 
19cd 28 34			jr z, .pskip2 
19cf e5				push hl 
19d0 e5			push hl 
19d1 cd 99 09			call clear_display 
19d4 e1			pop hl 
19d5 7c				ld a,h 
19d6 21 65 e6			ld hl, os_word_scratch 
19d9 cd c7 0e			call hexout 
19dc e1				pop hl 
19dd 7d				ld a,l 
19de 21 67 e6			ld hl, os_word_scratch+2 
19e1 cd c7 0e			call hexout 
19e4			 
19e4 21 69 e6			ld hl, os_word_scratch+4 
19e7 3e 00			ld a,0 
19e9 77				ld (hl),a 
19ea 11 65 e6			ld de,os_word_scratch 
19ed 3e 28				ld a, display_row_2 
19ef cd ac 09				call str_at_display 
19f2 11 ec 44			ld de, .push_num 
19f5 3e 00			ld a, display_row_1 
19f7			 
19f7 cd ac 09				call str_at_display 
19fa			 
19fa			 
19fa cd bc 09			call update_display 
19fd cd 0e 09			call delay1s 
1a00 cd 0e 09			call delay1s 
1a03			.pskip2:  
1a03			 
1a03 f1				pop af 
1a04			endif	 
1a04			 
1a04			 
1a04				FORTH_DSP_NEXT 
1a04 cd 55 19			call macro_forth_dsp_next 
1a07				endm 
# End of macro FORTH_DSP_NEXT
1a07			 
1a07 2a 0d eb			ld hl, (cli_data_sp) 
1a0a			 
1a0a				; save item type 
1a0a 3e 02			ld a,  DS_TYPE_INUM 
1a0c 77				ld (hl), a 
1a0d 23				inc hl 
1a0e			 
1a0e				; get word off stack 
1a0e d1				pop de 
1a0f 7b				ld a,e 
1a10 77				ld (hl), a 
1a11 23				inc hl 
1a12 7a				ld a,d 
1a13 77				ld (hl), a 
1a14			 
1a14			if DEBUG_FORTH_PUSH 
1a14 2b				dec hl 
1a15 2b				dec hl 
1a16 2b				dec hl 
1a17						DMARK "PH5" 
1a17 f5				push af  
1a18 3a 2c 1a			ld a, (.dmark)  
1a1b 32 7a ee			ld (debug_mark),a  
1a1e 3a 2d 1a			ld a, (.dmark+1)  
1a21 32 7b ee			ld (debug_mark+1),a  
1a24 3a 2e 1a			ld a, (.dmark+2)  
1a27 32 7c ee			ld (debug_mark+2),a  
1a2a 18 03			jr .pastdmark  
1a2c ..			.dmark: db "PH5"  
1a2f f1			.pastdmark: pop af  
1a30			endm  
# End of macro DMARK
1a30				CALLMONITOR 
1a30 cd 39 14			call break_point_state  
1a33				endm  
# End of macro CALLMONITOR
1a33			endif	 
1a33			 
1a33 c9				ret 
1a34			 
1a34			 
1a34			; Push a string to stack pointed to by hl 
1a34			 
1a34			forth_push_str: 
1a34			 
1a34			if DEBUG_FORTH_PUSH 
1a34						DMARK "PSQ" 
1a34 f5				push af  
1a35 3a 49 1a			ld a, (.dmark)  
1a38 32 7a ee			ld (debug_mark),a  
1a3b 3a 4a 1a			ld a, (.dmark+1)  
1a3e 32 7b ee			ld (debug_mark+1),a  
1a41 3a 4b 1a			ld a, (.dmark+2)  
1a44 32 7c ee			ld (debug_mark+2),a  
1a47 18 03			jr .pastdmark  
1a49 ..			.dmark: db "PSQ"  
1a4c f1			.pastdmark: pop af  
1a4d			endm  
# End of macro DMARK
1a4d				CALLMONITOR 
1a4d cd 39 14			call break_point_state  
1a50				endm  
# End of macro CALLMONITOR
1a50			endif	 
1a50			    
1a50 e5				push hl 
1a51 e5				push hl 
1a52			 
1a52			;	ld a, 0   ; find end of string 
1a52 cd 24 10			call strlenz 
1a55			if DEBUG_FORTH_PUSH 
1a55						DMARK "PQ2" 
1a55 f5				push af  
1a56 3a 6a 1a			ld a, (.dmark)  
1a59 32 7a ee			ld (debug_mark),a  
1a5c 3a 6b 1a			ld a, (.dmark+1)  
1a5f 32 7b ee			ld (debug_mark+1),a  
1a62 3a 6c 1a			ld a, (.dmark+2)  
1a65 32 7c ee			ld (debug_mark+2),a  
1a68 18 03			jr .pastdmark  
1a6a ..			.dmark: db "PQ2"  
1a6d f1			.pastdmark: pop af  
1a6e			endm  
# End of macro DMARK
1a6e				CALLMONITOR 
1a6e cd 39 14			call break_point_state  
1a71				endm  
# End of macro CALLMONITOR
1a71			endif	 
1a71 eb				ex de, hl 
1a72 e1				pop hl   ; get ptr to start of string 
1a73			if DEBUG_FORTH_PUSH 
1a73						DMARK "PQ3" 
1a73 f5				push af  
1a74 3a 88 1a			ld a, (.dmark)  
1a77 32 7a ee			ld (debug_mark),a  
1a7a 3a 89 1a			ld a, (.dmark+1)  
1a7d 32 7b ee			ld (debug_mark+1),a  
1a80 3a 8a 1a			ld a, (.dmark+2)  
1a83 32 7c ee			ld (debug_mark+2),a  
1a86 18 03			jr .pastdmark  
1a88 ..			.dmark: db "PQ3"  
1a8b f1			.pastdmark: pop af  
1a8c			endm  
# End of macro DMARK
1a8c				CALLMONITOR 
1a8c cd 39 14			call break_point_state  
1a8f				endm  
# End of macro CALLMONITOR
1a8f			endif	 
1a8f 19				add hl,de 
1a90			if DEBUG_FORTH_PUSH 
1a90						DMARK "PQE" 
1a90 f5				push af  
1a91 3a a5 1a			ld a, (.dmark)  
1a94 32 7a ee			ld (debug_mark),a  
1a97 3a a6 1a			ld a, (.dmark+1)  
1a9a 32 7b ee			ld (debug_mark+1),a  
1a9d 3a a7 1a			ld a, (.dmark+2)  
1aa0 32 7c ee			ld (debug_mark+2),a  
1aa3 18 03			jr .pastdmark  
1aa5 ..			.dmark: db "PQE"  
1aa8 f1			.pastdmark: pop af  
1aa9			endm  
# End of macro DMARK
1aa9				CALLMONITOR 
1aa9 cd 39 14			call break_point_state  
1aac				endm  
# End of macro CALLMONITOR
1aac			endif	 
1aac			 
1aac 2b				dec hl    ; see if there is an optional trailing double quote 
1aad 7e				ld a,(hl) 
1aae fe 22			cp '"' 
1ab0 20 03			jr nz, .strnoq 
1ab2 3e 00			ld a, 0      ; get rid of double quote 
1ab4 77				ld (hl), a 
1ab5 23			.strnoq: inc hl 
1ab6			 
1ab6 3e 00			ld a, 0 
1ab8 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ab9			 
1ab9 13				inc de ; add one for the type string 
1aba 13				inc de ; add one for null term??? 
1abb			 
1abb				; tos is get string pointer again 
1abb				; de contains space to allocate 
1abb				 
1abb d5				push de 
1abc			 
1abc eb				ex de, hl 
1abd			 
1abd				;push af 
1abd			 
1abd			if DEBUG_FORTH_PUSH 
1abd						DMARK "PHm" 
1abd f5				push af  
1abe 3a d2 1a			ld a, (.dmark)  
1ac1 32 7a ee			ld (debug_mark),a  
1ac4 3a d3 1a			ld a, (.dmark+1)  
1ac7 32 7b ee			ld (debug_mark+1),a  
1aca 3a d4 1a			ld a, (.dmark+2)  
1acd 32 7c ee			ld (debug_mark+2),a  
1ad0 18 03			jr .pastdmark  
1ad2 ..			.dmark: db "PHm"  
1ad5 f1			.pastdmark: pop af  
1ad6			endm  
# End of macro DMARK
1ad6				CALLMONITOR 
1ad6 cd 39 14			call break_point_state  
1ad9				endm  
# End of macro CALLMONITOR
1ad9			endif	 
1ad9 cd 8d 10			call malloc	; on ret hl now contains allocated memory 
1adc				if DEBUG_FORTH_MALLOC_GUARD 
1adc cc 44 45				call z,malloc_error 
1adf				endif 
1adf			 
1adf				 
1adf c1				pop bc    ; get length 
1ae0 d1				pop de   ;  get string start    
1ae1			 
1ae1				; hl has destination from malloc 
1ae1			 
1ae1 eb				ex de, hl    ; prep for ldir 
1ae2			 
1ae2 d5				push de   ; save malloc area for DSP later 
1ae3				;push hl   ; save malloc area for DSP later 
1ae3			 
1ae3			if DEBUG_FORTH_PUSH 
1ae3						DMARK "PHc" 
1ae3 f5				push af  
1ae4 3a f8 1a			ld a, (.dmark)  
1ae7 32 7a ee			ld (debug_mark),a  
1aea 3a f9 1a			ld a, (.dmark+1)  
1aed 32 7b ee			ld (debug_mark+1),a  
1af0 3a fa 1a			ld a, (.dmark+2)  
1af3 32 7c ee			ld (debug_mark+2),a  
1af6 18 03			jr .pastdmark  
1af8 ..			.dmark: db "PHc"  
1afb f1			.pastdmark: pop af  
1afc			endm  
# End of macro DMARK
1afc				CALLMONITOR 
1afc cd 39 14			call break_point_state  
1aff				endm  
# End of macro CALLMONITOR
1aff			endif	 
1aff			 
1aff			 
1aff ed b0			ldir 
1b01			 
1b01			 
1b01				; push malloc to data stack     macro?????  
1b01			 
1b01				FORTH_DSP_NEXT 
1b01 cd 55 19			call macro_forth_dsp_next 
1b04				endm 
# End of macro FORTH_DSP_NEXT
1b04			 
1b04				; save value and type 
1b04			 
1b04 2a 0d eb			ld hl, (cli_data_sp) 
1b07			 
1b07				; save item type 
1b07 3e 01			ld a,  DS_TYPE_STR 
1b09 77				ld (hl), a 
1b0a 23				inc hl 
1b0b			 
1b0b				; get malloc word off stack 
1b0b d1				pop de 
1b0c 73				ld (hl), e 
1b0d 23				inc hl 
1b0e 72				ld (hl), d 
1b0f			 
1b0f			 
1b0f			 
1b0f			if DEBUG_FORTH_PUSH 
1b0f 2a 0d eb			ld hl, (cli_data_sp) 
1b12						DMARK "PHS" 
1b12 f5				push af  
1b13 3a 27 1b			ld a, (.dmark)  
1b16 32 7a ee			ld (debug_mark),a  
1b19 3a 28 1b			ld a, (.dmark+1)  
1b1c 32 7b ee			ld (debug_mark+1),a  
1b1f 3a 29 1b			ld a, (.dmark+2)  
1b22 32 7c ee			ld (debug_mark+2),a  
1b25 18 03			jr .pastdmark  
1b27 ..			.dmark: db "PHS"  
1b2a f1			.pastdmark: pop af  
1b2b			endm  
# End of macro DMARK
1b2b				CALLMONITOR 
1b2b cd 39 14			call break_point_state  
1b2e				endm  
# End of macro CALLMONITOR
1b2e			;	ex de,hl 
1b2e			endif	 
1b2e				; in case of spaces, skip the ptr past the copied string 
1b2e				;pop af 
1b2e				;ld (cli_origptr),hl 
1b2e			 
1b2e c9				ret 
1b2f			 
1b2f			 
1b2f			 
1b2f			; TODO ascii push input onto stack given hl to start of input 
1b2f			 
1b2f			; identify type 
1b2f			; if starts with a " then a string 
1b2f			; otherwise it is a number 
1b2f			;  
1b2f			; if a string 
1b2f			;     scan for ending " to get length of string to malloc for + 1 
1b2f			;     malloc 
1b2f			;     put pointer to string on stack first byte flags as string 
1b2f			; 
1b2f			; else a number 
1b2f			;    look for number format identifier 
1b2f			;    $xx hex 
1b2f			;    %xxxxx bin 
1b2f			;    xxxxx decimal 
1b2f			;    convert number to 16bit word.  
1b2f			;    malloc word + 1 with flag to identiy as num 
1b2f			;    put pointer to number on stack 
1b2f			;   
1b2f			;  
1b2f			  
1b2f			forth_apush: 
1b2f				; kernel push 
1b2f			 
1b2f			if DEBUG_FORTH_PUSH 
1b2f						DMARK "PSH" 
1b2f f5				push af  
1b30 3a 44 1b			ld a, (.dmark)  
1b33 32 7a ee			ld (debug_mark),a  
1b36 3a 45 1b			ld a, (.dmark+1)  
1b39 32 7b ee			ld (debug_mark+1),a  
1b3c 3a 46 1b			ld a, (.dmark+2)  
1b3f 32 7c ee			ld (debug_mark+2),a  
1b42 18 03			jr .pastdmark  
1b44 ..			.dmark: db "PSH"  
1b47 f1			.pastdmark: pop af  
1b48			endm  
# End of macro DMARK
1b48				CALLMONITOR 
1b48 cd 39 14			call break_point_state  
1b4b				endm  
# End of macro CALLMONITOR
1b4b			endif	 
1b4b				; identify input type 
1b4b			 
1b4b 7e				ld a,(hl) 
1b4c fe 22			cp '"' 
1b4e 28 0a			jr z, .fapstr 
1b50 fe 24			cp '$' 
1b52 ca 7a 1b			jp z, .faphex 
1b55 fe 25			cp '%' 
1b57 ca 62 1b			jp z, .fapbin 
1b5a			;	cp 'b' 
1b5a			;	jp z, .fabin 
1b5a				; else decimal 
1b5a			 
1b5a				; TODO do decimal conversion 
1b5a				; decimal is stored as a 16bit word 
1b5a			 
1b5a				; by default everything is a string if type is not detected 
1b5a			.fapstr: ; 
1b5a fe 22			cp '"' 
1b5c 20 01			jr nz, .strnoqu 
1b5e 23				inc hl 
1b5f			.strnoqu: 
1b5f c3 34 1a			jp forth_push_str 
1b62			 
1b62			 
1b62			 
1b62			.fapbin:    ; push a binary string.  
1b62 11 00 00			ld de, 0   ; hold a 16bit value 
1b65			 
1b65 23			.fapbinshift:	inc hl  
1b66 7e				ld a,(hl) 
1b67 fe 00			cp 0     ; done scanning  
1b69 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b6b			 
1b6b				; left shift de 
1b6b eb				ex de, hl	 
1b6c 29				add hl, hl 
1b6d			 
1b6d				; is 1 
1b6d fe 31			cp '1' 
1b6f 20 02			jr nz, .binzero 
1b71 cb 4d			bit 1, l 
1b73			.binzero: 
1b73 eb				ex de, hl	 ; save current de 
1b74 18 ef			jr .fapbinshift 
1b76			 
1b76			.fapbdone: 
1b76 eb				ex de, hl 
1b77 c3 c6 19			jp forth_push_numhl 
1b7a			 
1b7a			 
1b7a			.faphex:   ; hex is always stored as a 16bit word 
1b7a				; skip number prefix 
1b7a 23				inc hl 
1b7b				; turn ascii into number 
1b7b cd 7d 0f			call get_word_hl	; ret 16bit word in hl 
1b7e			 
1b7e c3 c6 19			jp forth_push_numhl 
1b81			 
1b81 00				 nop 
1b82			 
1b82			.fabin:   ; TODO bin conversion 
1b82			 
1b82			 
1b82 c9				ret 
1b83			 
1b83			 
1b83			; get either a string ptr or a 16bit word from the data stack 
1b83			 
1b83			FORTH_DSP: macro 
1b83				call macro_forth_dsp 
1b83				endm 
1b83			 
1b83			macro_forth_dsp: 
1b83				; data stack pointer points to current word on tos 
1b83			 
1b83 2a 0d eb			ld hl,(cli_data_sp) 
1b86			 
1b86				if DEBUG_FORTH_PUSH 
1b86						DMARK "DSP" 
1b86 f5				push af  
1b87 3a 9b 1b			ld a, (.dmark)  
1b8a 32 7a ee			ld (debug_mark),a  
1b8d 3a 9c 1b			ld a, (.dmark+1)  
1b90 32 7b ee			ld (debug_mark+1),a  
1b93 3a 9d 1b			ld a, (.dmark+2)  
1b96 32 7c ee			ld (debug_mark+2),a  
1b99 18 03			jr .pastdmark  
1b9b ..			.dmark: db "DSP"  
1b9e f1			.pastdmark: pop af  
1b9f			endm  
# End of macro DMARK
1b9f			 
1b9f cd 79 45				call display_data_sp 
1ba2				;call break_point_state 
1ba2				;rst 030h 
1ba2				CALLMONITOR 
1ba2 cd 39 14			call break_point_state  
1ba5				endm  
# End of macro CALLMONITOR
1ba5				endif 
1ba5			 
1ba5 c9				ret 
1ba6			 
1ba6			; return hl to start of value on stack 
1ba6			 
1ba6			FORTH_DSP_VALUE: macro 
1ba6				call macro_forth_dsp_value 
1ba6				endm 
1ba6			 
1ba6			macro_forth_dsp_value: 
1ba6			 
1ba6				FORTH_DSP 
1ba6 cd 83 1b			call macro_forth_dsp 
1ba9				endm 
# End of macro FORTH_DSP
1ba9			 
1ba9 d5				push de 
1baa			 
1baa 23				inc hl ; skip type 
1bab			 
1bab 5e				ld e, (hl) 
1bac 23				inc hl 
1bad 56				ld d, (hl) 
1bae eb				ex de,hl  
1baf			 
1baf d1				pop de 
1bb0			 
1bb0 c9				ret 
1bb1			 
1bb1			; return hl to start of value to second item on stack 
1bb1			 
1bb1			FORTH_DSP_VALUEM1: macro 
1bb1				call macro_forth_dsp_value_m1 
1bb1				endm 
1bb1			 
1bb1			macro_forth_dsp_value_m1: 
1bb1			 
1bb1				FORTH_DSP 
1bb1 cd 83 1b			call macro_forth_dsp 
1bb4				endm 
# End of macro FORTH_DSP
1bb4			 
1bb4 2b				dec hl 
1bb5 2b				dec hl 
1bb6			;	dec hl 
1bb6			 
1bb6 d5				push de 
1bb7			 
1bb7 5e				ld e, (hl) 
1bb8 23				inc hl 
1bb9 56				ld d, (hl) 
1bba eb				ex de,hl  
1bbb			 
1bbb d1				pop de 
1bbc			 
1bbc c9				ret 
1bbd			 
1bbd				 
1bbd			 
1bbd			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bbd			 
1bbd			FORTH_DSP_POP: macro 
1bbd				call macro_forth_dsp_pop 
1bbd				endm 
1bbd			 
1bbd			 
1bbd			; get the tos data type 
1bbd			 
1bbd			FORTH_DSP_TYPE:   macro 
1bbd			 
1bbd				;FORTH_DSP_VALUE 
1bbd				FORTH_DSP 
1bbd				 
1bbd				; hl points to value 
1bbd				; check type 
1bbd			 
1bbd				ld a,(hl) 
1bbd			 
1bbd				endm 
1bbd			 
1bbd			; load the tos value into hl 
1bbd			 
1bbd			 
1bbd			FORTH_DSP_VALUEHL:  macro 
1bbd				call macro_dsp_valuehl 
1bbd				endm 
1bbd			 
1bbd			 
1bbd			 
1bbd			macro_dsp_valuehl: 
1bbd				FORTH_DSP_VALUE 
1bbd cd a6 1b			call macro_forth_dsp_value 
1bc0				endm 
# End of macro FORTH_DSP_VALUE
1bc0			 
1bc0				;FORTH_ERR_TOS_NOTNUM 
1bc0			 
1bc0				;inc hl   ; skip type id 
1bc0			 
1bc0			;	push de 
1bc0			; 
1bc0			;	ld e, (hl) 
1bc0			;	inc hl 
1bc0			;	ld d, (hl) 
1bc0			;	ex de,hl  
1bc0			 
1bc0			;	pop de 
1bc0			 
1bc0				if DEBUG_FORTH_PUSH 
1bc0						DMARK "DVL" 
1bc0 f5				push af  
1bc1 3a d5 1b			ld a, (.dmark)  
1bc4 32 7a ee			ld (debug_mark),a  
1bc7 3a d6 1b			ld a, (.dmark+1)  
1bca 32 7b ee			ld (debug_mark+1),a  
1bcd 3a d7 1b			ld a, (.dmark+2)  
1bd0 32 7c ee			ld (debug_mark+2),a  
1bd3 18 03			jr .pastdmark  
1bd5 ..			.dmark: db "DVL"  
1bd8 f1			.pastdmark: pop af  
1bd9			endm  
# End of macro DMARK
1bd9				CALLMONITOR 
1bd9 cd 39 14			call break_point_state  
1bdc				endm  
# End of macro CALLMONITOR
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			forth_apushstrhl:      
1bdd				; push of string requires use of cli_origptr 
1bdd				; bodge use 
1bdd			 
1bdd				; get current cli_origptr, save, update with temp pointer  
1bdd ed 5b 29 eb		ld de, (cli_origptr) 
1be1 22 29 eb			ld (cli_origptr), hl 
1be4 d5				push de 
1be5 cd 2f 1b			call forth_apush 
1be8 d1				pop de 
1be9 ed 53 29 eb		ld (cli_origptr), de 
1bed c9			        ret	 
1bee			 
1bee			 
1bee			; increase loop stack pointer and save hl to it 
1bee				 
1bee			FORTH_LOOP_NEXT: macro 
1bee				call macro_forth_loop_next 
1bee				;nop 
1bee				endm 
1bee			 
1bee			macro_forth_loop_next: 
1bee				if DEBUG_FORTH_STACK_GUARD 
1bee cd de 55				call check_stacks 
1bf1				endif 
1bf1 e5				push hl 
1bf2 d5				push de 
1bf3 eb				ex de,hl 
1bf4 2a 0f eb			ld hl,(cli_loop_sp) 
1bf7 23				inc hl 
1bf8 23				inc hl 
1bf9					if DEBUG_FORTH_WORDS 
1bf9						DMARK "LNX" 
1bf9 f5				push af  
1bfa 3a 0e 1c			ld a, (.dmark)  
1bfd 32 7a ee			ld (debug_mark),a  
1c00 3a 0f 1c			ld a, (.dmark+1)  
1c03 32 7b ee			ld (debug_mark+1),a  
1c06 3a 10 1c			ld a, (.dmark+2)  
1c09 32 7c ee			ld (debug_mark+2),a  
1c0c 18 03			jr .pastdmark  
1c0e ..			.dmark: db "LNX"  
1c11 f1			.pastdmark: pop af  
1c12			endm  
# End of macro DMARK
1c12						CALLMONITOR 
1c12 cd 39 14			call break_point_state  
1c15				endm  
# End of macro CALLMONITOR
1c15					endif 
1c15 22 0f eb			ld (cli_loop_sp),hl 
1c18 73				ld (hl), e 
1c19 23				inc hl 
1c1a 72				ld (hl), d 
1c1b d1				pop de    ; been reversed so save a swap on restore 
1c1c e1				pop hl 
1c1d				if DEBUG_FORTH_STACK_GUARD 
1c1d cd de 55				call check_stacks 
1c20				endif 
1c20 c9				ret 
1c21			 
1c21			; get current ret stack pointer and save to hl  
1c21				 
1c21			FORTH_LOOP_TOS: macro 
1c21				call macro_forth_loop_tos 
1c21				endm 
1c21			 
1c21			macro_forth_loop_tos: 
1c21 d5				push de 
1c22 2a 0f eb			ld hl,(cli_loop_sp) 
1c25 5e				ld e, (hl) 
1c26 23				inc hl 
1c27 56				ld d, (hl) 
1c28 eb				ex de, hl 
1c29 d1				pop de 
1c2a c9				ret 
1c2b			 
1c2b			; pop loop stack pointer 
1c2b				 
1c2b			FORTH_LOOP_POP: macro 
1c2b				call macro_forth_loop_pop 
1c2b				endm 
1c2b			 
1c2b			 
1c2b			macro_forth_loop_pop: 
1c2b				if DEBUG_FORTH_STACK_GUARD 
1c2b					DMARK "LPP" 
1c2b f5				push af  
1c2c 3a 40 1c			ld a, (.dmark)  
1c2f 32 7a ee			ld (debug_mark),a  
1c32 3a 41 1c			ld a, (.dmark+1)  
1c35 32 7b ee			ld (debug_mark+1),a  
1c38 3a 42 1c			ld a, (.dmark+2)  
1c3b 32 7c ee			ld (debug_mark+2),a  
1c3e 18 03			jr .pastdmark  
1c40 ..			.dmark: db "LPP"  
1c43 f1			.pastdmark: pop af  
1c44			endm  
# End of macro DMARK
1c44 cd de 55				call check_stacks 
1c47					FORTH_CHK_LOOP_UNDER 
1c47 e5				push hl 
1c48 d5				push de 
1c49 2a 0f eb			ld hl,(cli_loop_sp) 
1c4c 11 c9 e9			ld de, cli_loop_stack 
1c4f cd e4 0b			call cmp16 
1c52 da f8 56			jp c, fault_loop_under 
1c55 d1				pop de 
1c56 e1				pop hl 
1c57				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c57				endif 
1c57 e5				push hl 
1c58 2a 0f eb			ld hl,(cli_loop_sp) 
1c5b 2b				dec hl 
1c5c 2b				dec hl 
1c5d 22 0f eb			ld (cli_loop_sp), hl 
1c60				; TODO do stack underflow checks 
1c60 e1				pop hl 
1c61				if DEBUG_FORTH_STACK_GUARD 
1c61 cd de 55				call check_stacks 
1c64					FORTH_CHK_LOOP_UNDER 
1c64 e5				push hl 
1c65 d5				push de 
1c66 2a 0f eb			ld hl,(cli_loop_sp) 
1c69 11 c9 e9			ld de, cli_loop_stack 
1c6c cd e4 0b			call cmp16 
1c6f da f8 56			jp c, fault_loop_under 
1c72 d1				pop de 
1c73 e1				pop hl 
1c74				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c74				endif 
1c74 c9				ret 
1c75			 
1c75			macro_forth_dsp_pop: 
1c75			 
1c75 e5				push hl 
1c76			 
1c76				; release malloc data 
1c76			 
1c76				if DEBUG_FORTH_STACK_GUARD 
1c76 cd de 55				call check_stacks 
1c79					FORTH_CHK_DSP_UNDER 
1c79 e5				push hl 
1c7a d5				push de 
1c7b 2a 0d eb			ld hl,(cli_data_sp) 
1c7e 11 c7 e8			ld de, cli_data_stack 
1c81 cd e4 0b			call cmp16 
1c84 da ec 56			jp c, fault_dsp_under 
1c87 d1				pop de 
1c88 e1				pop hl 
1c89				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c89				endif 
1c89				;ld hl,(cli_data_sp) 
1c89			if DEBUG_FORTH_DOT 
1c89				DMARK "DPP" 
1c89				CALLMONITOR 
1c89			endif	 
1c89			 
1c89			 
1c89			if FORTH_ENABLE_DSPPOPFREE 
1c89			 
1c89				FORTH_DSP 
1c89 cd 83 1b			call macro_forth_dsp 
1c8c				endm 
# End of macro FORTH_DSP
1c8c			 
1c8c 7e				ld a, (hl) 
1c8d fe 01			cp DS_TYPE_STR 
1c8f 20 07			jr nz, .skippopfree 
1c91			 
1c91				FORTH_DSP_VALUEHL 
1c91 cd bd 1b			call macro_dsp_valuehl 
1c94				endm 
# End of macro FORTH_DSP_VALUEHL
1c94 00				nop 
1c95			if DEBUG_FORTH_DOT 
1c95				DMARK "DPf" 
1c95				CALLMONITOR 
1c95			endif	 
1c95 cd 57 11			call free 
1c98			.skippopfree: 
1c98				 
1c98			 
1c98			endif 
1c98			 
1c98			if DEBUG_FORTH_DOT_KEY 
1c98				DMARK "DP2" 
1c98				CALLMONITOR 
1c98			endif	 
1c98			 
1c98				; move pointer down 
1c98			 
1c98 2a 0d eb			ld hl,(cli_data_sp) 
1c9b 2b				dec hl 
1c9c 2b				dec hl 
1c9d			; PARSEV5 
1c9d 2b				dec hl 
1c9e 22 0d eb			ld (cli_data_sp), hl 
1ca1			 
1ca1				if DEBUG_FORTH_STACK_GUARD 
1ca1 cd de 55				call check_stacks 
1ca4					FORTH_CHK_DSP_UNDER 
1ca4 e5				push hl 
1ca5 d5				push de 
1ca6 2a 0d eb			ld hl,(cli_data_sp) 
1ca9 11 c7 e8			ld de, cli_data_stack 
1cac cd e4 0b			call cmp16 
1caf da ec 56			jp c, fault_dsp_under 
1cb2 d1				pop de 
1cb3 e1				pop hl 
1cb4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cb4				endif 
1cb4			 
1cb4 e1				pop hl 
1cb5			 
1cb5 c9				ret 
1cb6			 
1cb6			getwordathl: 
1cb6				; hl points to an address 
1cb6				; load hl with the word at that address 
1cb6			 
1cb6 d5				push de 
1cb7			 
1cb7 5e				ld e, (hl) 
1cb8 23				inc hl 
1cb9 56				ld d, (hl) 
1cba eb				ex de, hl 
1cbb			 
1cbb d1				pop de 
1cbc c9				ret 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			; eof 
1cbd			 
# End of file forth_stackopsv5.asm
1cbd			endif 
1cbd			 
1cbd			user_word_eol:  
1cbd				; hl contains the pointer to where to create a linked list item from the end 
1cbd				; of the user dict to continue on at the system word dict 
1cbd				 
1cbd				; poke the stub of the word list linked list to repoint to rom words 
1cbd			 
1cbd				; stub format 
1cbd				; db   word id 
1cbd				; dw    link to next word 
1cbd			        ; db char length of token 
1cbd				; db string + 0 term 
1cbd				; db exec code....  
1cbd			 
1cbd 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cbf 77				ld (hl), a		; word id 
1cc0 23				inc hl 
1cc1			 
1cc1 11 87 1e			ld de, sysdict 
1cc4 73				ld (hl), e		; next word link ie system dict 
1cc5 23				inc hl 
1cc6 72				ld (hl), d		; next word link ie system dict 
1cc7 23				inc hl	 
1cc8			 
1cc8			;	ld (hl), sysdict		; next word link ie system dict 
1cc8			;	inc hl 
1cc8			;	inc hl 
1cc8			 
1cc8			;	inc hl 
1cc8			;	inc hl 
1cc8			 
1cc8 3e 02			ld a, 2			; word length is 0 
1cca 77				ld (hl), a	 
1ccb 23				inc hl 
1ccc			 
1ccc 3e 7e			ld a, '~'			; word length is 0 
1cce 77				ld (hl), a	 
1ccf 23				inc hl 
1cd0 3e 00			ld a, 0			; save empty word 
1cd2 77				ld (hl), a 
1cd3			 
1cd3 c9				ret 
1cd4			 
1cd4				 
1cd4			 
1cd4			forthexec_cleanup: 
1cd4				FORTH_RSP_POP 
1cd4 cd 8e 19			call macro_forth_rsp_pop 
1cd7				endm 
# End of macro FORTH_RSP_POP
1cd7 c9				ret 
1cd8			 
1cd8			forth_call_hl: 
1cd8				; taking hl 
1cd8 e5				push hl 
1cd9 c9				ret 
1cda			 
1cda			; this is called to reset Forth system but keep existing uwords etc 
1cda			 
1cda			forth_warmstart: 
1cda				; setup stack over/under flow checks 
1cda				if DEBUG_FORTH_STACK_GUARD 
1cda cd c4 55				call chk_stk_init 
1cdd				endif 
1cdd			 
1cdd				; init stack pointers  - * these stacks go upwards *  
1cdd 21 cb ea			ld hl, cli_ret_stack 
1ce0 22 11 eb			ld (cli_ret_sp), hl	 
1ce3				; set bottom of stack 
1ce3 3e 00			ld a,0 
1ce5 77				ld (hl),a 
1ce6 23				inc hl 
1ce7 77				ld (hl),a 
1ce8			 
1ce8 21 c7 e8			ld hl, cli_data_stack 
1ceb 22 0d eb			ld (cli_data_sp), hl	 
1cee				; set bottom of stack 
1cee 3e 00			ld a,0 
1cf0 77				ld (hl),a 
1cf1 23				inc hl 
1cf2 77				ld (hl),a 
1cf3			 
1cf3 21 c9 e9			ld hl, cli_loop_stack 
1cf6 22 0f eb			ld (cli_loop_sp), hl	 
1cf9				; set bottom of stack 
1cf9 3e 00			ld a,0 
1cfb 77				ld (hl),a 
1cfc 23				inc hl 
1cfd 77				ld (hl),a 
1cfe			 
1cfe				; init extent of current open file 
1cfe			 
1cfe 3e 00			ld a, 0 
1d00 32 5c eb			ld (store_openext), a 
1d03			 
1d03 c9				ret 
1d04			 
1d04			 
1d04			; Cold Start - this is called to setup the whole Forth system 
1d04			 
1d04			forth_init: 
1d04			 
1d04				; setup stack over/under flow checks 
1d04			 
1d04			;	if DEBUG_FORTH_STACK_GUARD 
1d04			;		call chk_stk_init 
1d04			;	endif 
1d04			 
1d04				; enable auto display updates (slow.....) 
1d04			 
1d04 3e 01			ld a, 1 
1d06 32 27 eb			ld (cli_autodisplay), a 
1d09			 
1d09			 
1d09			 
1d09				; show start up screen 
1d09			 
1d09 cd 99 09			call clear_display 
1d0c			 
1d0c 3e 00			ld a,0 
1d0e 32 49 eb			ld (f_cursor_ptr), a 
1d11			 
1d11				; set start of word list in start of ram - for use when creating user words 
1d11			 
1d11 21 e7 58			ld hl, baseram 
1d14 22 5d e6			ld (os_last_new_uword), hl 
1d17 cd bd 1c			call user_word_eol 
1d1a				 
1d1a			;		call display_data_sp 
1d1a			;		call next_page_prompt 
1d1a			 
1d1a			 
1d1a			 
1d1a			 
1d1a c9				ret 
1d1b			 
1d1b .. 00		.bootforth: db " Forth Kernel Init ",0 
1d2f			 
1d2f			; TODO push to stack 
1d2f			 
1d2f			;  
1d2f			 
1d2f			if FORTH_PARSEV2 
1d2f			 
1d2f			 
1d2f				include "forth_parserv2.asm" 
1d2f			 
1d2f			endif 
1d2f			 
1d2f			 
1d2f			; parse cli version 1 
1d2f			 
1d2f			if FORTH_PARSEV1 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv1.asm" 
1d2f			endif 
1d2f				 
1d2f			if FORTH_PARSEV3 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv3.asm" 
1d2f				include "forth_wordsv3.asm" 
1d2f			endif 
1d2f			 
1d2f			if FORTH_PARSEV4 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv4.asm" 
1d2f				include "forth_wordsv4.asm" 
1d2f			endif 
1d2f			 
1d2f			if FORTH_PARSEV5 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv5.asm" 
1d2f			 
1d2f			 
1d2f			; A better parser without using malloc and string copies all over the place.  
1d2f			; Exec in situ should be faster 
1d2f			 
1d2f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d2f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d2f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d2f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d2f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d2f			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d2f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d2f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d2f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d2f			 
1d2f			; Core word preamble macro 
1d2f			 
1d2f			CWHEAD:   macro nxtword opcode lit len opflags 
1d2f				db WORD_SYS_CORE+opcode             
1d2f				; internal op code number 
1d2f				dw nxtword            
1d2f				; link to next dict word block 
1d2f				db len + 1 
1d2f				; literal length of dict word inc zero term 
1d2f				db lit,0              
1d2f				; literal dict word 
1d2f			        ; TODO db opflags        
1d2f				endm 
1d2f			 
1d2f			 
1d2f			NEXTW: macro  
1d2f				jp macro_next 
1d2f				endm 
1d2f			 
1d2f			macro_next: 
1d2f			if DEBUG_FORTH_PARSE_KEY 
1d2f				DMARK "NXT" 
1d2f				CALLMONITOR 
1d2f			endif	 
1d2f			;	inc hl  ; skip token null term  
1d2f ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d33 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d37 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d3a			if DEBUG_FORTH_PARSE_KEY 
1d3a				DMARK "}AA" 
1d3a				CALLMONITOR 
1d3a			endif	 
1d3a c3 3d 1e			jp execnext 
1d3d				;jp exec1 
1d3d			       
1d3d			 
1d3d			 
1d3d			; Another go at the parser to compile  
1d3d			 
1d3d			 
1d3d			; TODO rework parser to change all of the string words to byte tokens 
1d3d			; TODO do a search for  
1d3d			 
1d3d			; TODO first run normal parser to zero term sections 
1d3d			; TODO for each word do a token look up to get the op code 
1d3d			; TODO need some means to flag to the exec that this is a byte code form    
1d3d			 
1d3d			 
1d3d			forthcompile: 
1d3d			 
1d3d			; 
1d3d			; line parse: 
1d3d			;       parse raw input buffer 
1d3d			;       tokenise the words 
1d3d			;       malloc new copy (for looping etc) 
1d3d			;       copy to malloc + current pc in line to start of string and add line term 
1d3d			;       save on new rsp 
1d3d			; 
1d3d			 
1d3d			; hl to point to the line to tokenise 
1d3d			 
1d3d			;	push hl 
1d3d 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d40			 
1d40			;	ld a,0		; string term on input 
1d40			;	call strlent 
1d40			 
1d40			;	ld (os_tok_len), hl	 ; save string length 
1d40			 
1d40			;if DEBUG_FORTH_TOK 
1d40			;	ex de,hl		 
1d40			;endif 
1d40			 
1d40			;	pop hl 		; get back string pointer 
1d40			 
1d40			if DEBUG_FORTH_TOK 
1d40						DMARK "TOc" 
1d40				CALLMONITOR 
1d40			endif 
1d40 7e			.cptoken2:    ld a,(hl) 
1d41 23				inc hl 
1d42 fe 7f			cp FORTH_END_BUFFER 
1d44 28 29			jr z, .cptokendone2 
1d46 fe 00			cp 0 
1d48 28 25			jr z, .cptokendone2 
1d4a fe 22			cp '"' 
1d4c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d4e fe 20			cp ' ' 
1d50 20 ee			jr nz,  .cptoken2 
1d52			 
1d52			; TODO consume comments held between ( and ) 
1d52			 
1d52				; we have a space so change to zero term for dict match later 
1d52 2b				dec hl 
1d53 3e 00			ld a,0 
1d55 77				ld (hl), a 
1d56 23				inc hl 
1d57 18 e7			jr .cptoken2 
1d59				 
1d59			 
1d59			.cptokenstr2: 
1d59				; skip all white space until either eol (because forgot to term) or end double quote 
1d59			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d59				;inc hl ; skip current double quote 
1d59 7e				ld a,(hl) 
1d5a 23				inc hl 
1d5b fe 22			cp '"' 
1d5d 28 e1			jr z, .cptoken2 
1d5f fe 7f			cp FORTH_END_BUFFER 
1d61 28 0c			jr z, .cptokendone2 
1d63 fe 00			cp 0 
1d65 28 08			jr z, .cptokendone2 
1d67 fe 20			cp ' ' 
1d69 28 02			jr z, .cptmp2 
1d6b 18 ec			jr .cptokenstr2 
1d6d			 
1d6d			.cptmp2:	; we have a space so change to zero term for dict match later 
1d6d				;dec hl 
1d6d				;ld a,"-"	; TODO remove this when working 
1d6d				;ld (hl), a 
1d6d				;inc hl 
1d6d 18 ea			jr .cptokenstr2 
1d6f			 
1d6f			.cptokendone2: 
1d6f				;inc hl 
1d6f 3e 7f			ld a, FORTH_END_BUFFER 
1d71 77				ld (hl),a 
1d72 23				inc hl 
1d73 3e 21			ld a, '!' 
1d75 77				ld (hl),a 
1d76			 
1d76 2a 61 e6			ld hl,(os_tok_ptr) 
1d79			         
1d79			if DEBUG_FORTH_TOK 
1d79						DMARK "Tc1" 
1d79				CALLMONITOR 
1d79			endif 
1d79			 
1d79				; push exec string to top of return stack 
1d79				FORTH_RSP_NEXT 
1d79 cd 6d 19			call macro_forth_rsp_next 
1d7c				endm 
# End of macro FORTH_RSP_NEXT
1d7c c9				ret 
1d7d			 
1d7d			; Another go at the parser need to simplify the process 
1d7d			 
1d7d			forthparse: 
1d7d			 
1d7d			; 
1d7d			; line parse: 
1d7d			;       parse raw input buffer 
1d7d			;       tokenise the words 
1d7d			;       malloc new copy (for looping etc) 
1d7d			;       copy to malloc + current pc in line to start of string and add line term 
1d7d			;       save on new rsp 
1d7d			; 
1d7d			 
1d7d			; hl to point to the line to tokenise 
1d7d			 
1d7d			;	push hl 
1d7d 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d80			 
1d80			;	ld a,0		; string term on input 
1d80			;	call strlent 
1d80			 
1d80			;	ld (os_tok_len), hl	 ; save string length 
1d80			 
1d80			;if DEBUG_FORTH_TOK 
1d80			;	ex de,hl		 
1d80			;endif 
1d80			 
1d80			;	pop hl 		; get back string pointer 
1d80			 
1d80			if DEBUG_FORTH_TOK 
1d80						DMARK "TOK" 
1d80				CALLMONITOR 
1d80			endif 
1d80 7e			.ptoken2:    ld a,(hl) 
1d81 23				inc hl 
1d82 fe 7f			cp FORTH_END_BUFFER 
1d84 28 29			jr z, .ptokendone2 
1d86 fe 00			cp 0 
1d88 28 25			jr z, .ptokendone2 
1d8a fe 22			cp '"' 
1d8c 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d8e fe 20			cp ' ' 
1d90 20 ee			jr nz,  .ptoken2 
1d92			 
1d92			; TODO consume comments held between ( and ) 
1d92			 
1d92				; we have a space so change to zero term for dict match later 
1d92 2b				dec hl 
1d93 3e 00			ld a,0 
1d95 77				ld (hl), a 
1d96 23				inc hl 
1d97 18 e7			jr .ptoken2 
1d99				 
1d99			 
1d99			.ptokenstr2: 
1d99				; skip all white space until either eol (because forgot to term) or end double quote 
1d99			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d99				;inc hl ; skip current double quote 
1d99 7e				ld a,(hl) 
1d9a 23				inc hl 
1d9b fe 22			cp '"' 
1d9d 28 e1			jr z, .ptoken2 
1d9f fe 7f			cp FORTH_END_BUFFER 
1da1 28 0c			jr z, .ptokendone2 
1da3 fe 00			cp 0 
1da5 28 08			jr z, .ptokendone2 
1da7 fe 20			cp ' ' 
1da9 28 02			jr z, .ptmp2 
1dab 18 ec			jr .ptokenstr2 
1dad			 
1dad			.ptmp2:	; we have a space so change to zero term for dict match later 
1dad				;dec hl 
1dad				;ld a,"-"	; TODO remove this when working 
1dad				;ld (hl), a 
1dad				;inc hl 
1dad 18 ea			jr .ptokenstr2 
1daf			 
1daf			.ptokendone2: 
1daf				;inc hl 
1daf 3e 7f			ld a, FORTH_END_BUFFER 
1db1 77				ld (hl),a 
1db2 23				inc hl 
1db3 3e 21			ld a, '!' 
1db5 77				ld (hl),a 
1db6			 
1db6 2a 61 e6			ld hl,(os_tok_ptr) 
1db9			         
1db9			if DEBUG_FORTH_TOK 
1db9						DMARK "TK1" 
1db9				CALLMONITOR 
1db9			endif 
1db9			 
1db9				; push exec string to top of return stack 
1db9				FORTH_RSP_NEXT 
1db9 cd 6d 19			call macro_forth_rsp_next 
1dbc				endm 
# End of macro FORTH_RSP_NEXT
1dbc c9				ret 
1dbd			 
1dbd			; 
1dbd			;	; malloc size + buffer pointer + if is loop flag 
1dbd			;	ld hl,(os_tok_len) 		 ; get string length 
1dbd			; 
1dbd			;	ld a,l 
1dbd			; 
1dbd			;	cp 0			; we dont want to use a null string 
1dbd			;	ret z 
1dbd			; 
1dbd			;;	add 3    ; prefix malloc with buffer for current word ptr 
1dbd			; 
1dbd			;	add 5     ; TODO when certain not over writing memory remove 
1dbd			; 
1dbd			;		 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKE" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	ld l,a 
1dbd			;	ld h,0 
1dbd			;;	push hl   ; save required space for the copy later 
1dbd			;	call malloc 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKM" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			;	if DEBUG_FORTH_MALLOC_GUARD 
1dbd			;		push af 
1dbd			;		call ishlzero 
1dbd			;;		ld a, l 
1dbd			;;		add h 
1dbd			;;		cp 0 
1dbd			;		pop af 
1dbd			;		 
1dbd			;		call z,malloc_error 
1dbd			;	endif 
1dbd			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1dbd			; 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKR" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	FORTH_RSP_NEXT 
1dbd			; 
1dbd			;	;inc hl	 ; go past current buffer pointer 
1dbd			;	;inc hl 
1dbd			;	;inc hl   ; and past if loop flag 
1dbd			;		; TODO Need to set flag  
1dbd			; 
1dbd			;	 
1dbd			;	 
1dbd			;	ex de,hl	; malloc is dest 
1dbd			;	ld hl, (os_tok_len) 
1dbd			;;	pop bc 
1dbd			;	ld c, l                
1dbd			;	ld b,0 
1dbd			;	ld hl, (os_tok_ptr) 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKT" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	; do str cpy 
1dbd			; 
1dbd			;	ldir      ; copy byte in hl to de 
1dbd			; 
1dbd			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			; 
1dbd			;			DMARK "TKY" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			;	;ld a,0 
1dbd			;	;ld a,FORTH_END_BUFFER 
1dbd			;	ex de, hl 
1dbd			;	;dec hl			 ; go back over the space delim at the end of word 
1dbd			;	;ld (hl),a 
1dbd			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1dbd			;	ld a,FORTH_END_BUFFER 
1dbd			;	ld (hl),a 
1dbd			;	inc hl 
1dbd			;	ld a,FORTH_END_BUFFER 
1dbd			;	ld (hl),a 
1dbd			; 
1dbd			;	; init the malloc area data 
1dbd			;	; set pc for in current area 
1dbd			;	;ld hl, (os_tok_malloc) 
1dbd			;	;inc hl 
1dbd			;	;inc hl 
1dbd			;	;inc hl 
1dbd			;	;ex de,hl 
1dbd			;	;ld hl, (os_tok_malloc) 
1dbd			;	;ld (hl),e 
1dbd			;	;inc hl 
1dbd			;	;ld (hl),d 
1dbd			; 
1dbd			; 
1dbd			;	ld hl,(os_tok_malloc) 
1dbd			;if DEBUG_FORTH_PARSE_KEY 
1dbd			;			DMARK "TKU" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	ret 
1dbd			 
1dbd			forthexec: 
1dbd			 
1dbd			; line exec: 
1dbd			; forth parser 
1dbd			 
1dbd			; 
1dbd			;       get current exec line on rsp 
1dbd			 
1dbd				FORTH_RSP_TOS 
1dbd cd 84 19			call macro_forth_rsp_tos 
1dc0				endm 
# End of macro FORTH_RSP_TOS
1dc0			 
1dc0			;       restore current pc - hl points to malloc of data 
1dc0			 
1dc0				;ld e, (hl) 
1dc0				;inc hl 
1dc0				;ld d, (hl) 
1dc0				;ex de,hl 
1dc0			 
1dc0			 
1dc0			exec1: 
1dc0 22 61 e6			ld (os_tok_ptr), hl 
1dc3			 
1dc3				; copy our PC to working vars  
1dc3 22 2b eb			ld (cli_ptr), hl 
1dc6 22 29 eb			ld (cli_origptr), hl 
1dc9			 
1dc9 7e				ld a,(hl) 
1dca fe 7f			cp FORTH_END_BUFFER 
1dcc c8				ret z 
1dcd			 
1dcd				; skip any nulls 
1dcd			 
1dcd fe 00			cp 0 
1dcf 20 03			jr nz, .execword 
1dd1 23				inc hl 
1dd2 18 ec			jr exec1 
1dd4			 
1dd4			 
1dd4			.execword: 
1dd4			 
1dd4			 
1dd4			 
1dd4			if DEBUG_FORTH_PARSE_KEY 
1dd4						DMARK "KYQ" 
1dd4				CALLMONITOR 
1dd4			endif 
1dd4			;       while at start of word: 
1dd4			; get start of dict (in user area first) 
1dd4			 
1dd4 21 e7 58		ld hl, baseram 
1dd7			;ld hl, sysdict 
1dd7 22 2d eb		ld (cli_nextword),hl 
1dda			;           match word at pc 
1dda			;           exec word 
1dda			;           or push to dsp 
1dda			;           forward to next token 
1dda			;           if line term pop rsp and exit 
1dda			;        
1dda			 
1dda			if DEBUG_FORTH_PARSE_KEY 
1dda						DMARK "KYq" 
1dda				CALLMONITOR 
1dda			endif 
1dda			 
1dda			; 
1dda			; word comp 
1dda			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1dda			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1dda			;    move to start of word  
1dda			;    compare word to cli_token 
1dda			 
1dda			.execpnword:	; HL at start of a word in the dictionary to check 
1dda			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1dda			;	ld (cli_ptr), hl 
1dda			 
1dda 2a 2d eb			ld hl,(cli_nextword) 
1ddd			 
1ddd cd 80 1e			call forth_tok_next 
1de0			; tok next start here 
1de0			;	; TODO skip compiled symbol for now 
1de0			;	inc hl 
1de0			; 
1de0			;	; save pointer to next word 
1de0			; 
1de0			;	; hl now points to the address of the next word pointer  
1de0			;	ld e, (hl) 
1de0			;	inc hl 
1de0			;	ld d, (hl) 
1de0			;	inc l 
1de0			; 
1de0			;	ex de,hl 
1de0			;if DEBUG_FORTH_PARSE_NEXTWORD 
1de0			;	push bc 
1de0			;	ld bc, (cli_nextword) 
1de0			;			DMARK "NXW" 
1de0			;	CALLMONITOR 
1de0			;	pop bc 
1de0			;endif 
1de0			; tok next end here 
1de0 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1de3 eb				ex de, hl 
1de4			 
1de4			 
1de4				; save the pointer of the current token - 1 to check against 
1de4				 
1de4 22 31 eb			ld (cli_token), hl   
1de7				; TODO maybe remove below save if no debug 
1de7				; save token string ptr for any debug later 
1de7 23				inc hl  
1de8 22 33 eb			ld (cli_origtoken), hl 
1deb 2b				dec hl 
1dec				; save pointer to the start of the next dictionay word 
1dec 7e				ld a,(hl)   ; get string length 
1ded 47				ld b,a 
1dee			.execpnwordinc:  
1dee 23				inc hl 
1def 10 fd			djnz .execpnwordinc 
1df1 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1df4			 
1df4				; now check the word token against the string being parsed 
1df4			 
1df4 2a 31 eb			ld hl,(cli_token) 
1df7 23				inc hl     ; skip string length (use zero term instead to end) 
1df8 22 31 eb			ld (cli_token), hl 
1dfb			 
1dfb			if DEBUG_FORTH_PARSE_KEY 
1dfb						DMARK "KY2" 
1dfb			endif 
1dfb			if DEBUG_FORTH_PARSE_EXEC 
1dfb				; see if disabled 
1dfb			 
1dfb				ld a, (os_view_disable) 
1dfb				cp '*' 
1dfb				jr z, .skip 
1dfb			 
1dfb				push hl 
1dfb				push hl 
1dfb				call clear_display 
1dfb				ld de, .compword 
1dfb				ld a, display_row_1 
1dfb				call str_at_display 
1dfb				pop de 
1dfb				ld a, display_row_2 
1dfb				call str_at_display 
1dfb				ld hl,(cli_ptr) 
1dfb				ld a,(hl) 
1dfb			        ld hl, os_word_scratch 
1dfb				ld (hl),a 
1dfb				ld a,0 
1dfb				inc hl 
1dfb				ld (hl),a 	 
1dfb				ld de, os_word_scratch 
1dfb				ld a, display_row_2+10 
1dfb				call str_at_display 
1dfb				call update_display 
1dfb				ld a, 100 
1dfb				call aDelayInMS 
1dfb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dfb				call delay250ms 
1dfb				endif 
1dfb				pop hl 
1dfb			.skip:  
1dfb			endif	 
1dfb			.execpnchar:    ; compare char between token and string to parse 
1dfb			 
1dfb			if DEBUG_FORTH_PARSE_KEY 
1dfb						DMARK "Ky3" 
1dfb			endif 
1dfb			if DEBUG_FORTH_PARSE_EXEC 
1dfb				; see if disabled 
1dfb			 
1dfb				ld a, (os_view_disable) 
1dfb				cp '*' 
1dfb				jr z, .skip2 
1dfb			 
1dfb			;	call clear_display 
1dfb			ld hl,(cli_token) 
1dfb			ld a,(hl) 
1dfb			ld (os_word_scratch),a 
1dfb				ld hl,(cli_ptr) 
1dfb			ld a,(hl) 
1dfb				ld (os_word_scratch+1),a 
1dfb				ld a,0 
1dfb				ld (os_word_scratch+2),a 
1dfb				ld de,os_word_scratch 
1dfb				ld a,display_row_4 
1dfb				call str_at_display 
1dfb				call update_display 
1dfb			.skip2:  
1dfb			endif 
1dfb 2a 31 eb			ld hl,(cli_token) 
1dfe 7e				ld a, (hl)	 ; char in word token 
1dff 23				inc hl 		; move to next char 
1e00 22 31 eb			ld (cli_token), hl ; and save it 
1e03 47				ld b,a 
1e04			 
1e04 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1e07 7e				ld a,(hl) 
1e08 23				inc hl 
1e09 22 2b eb			ld (cli_ptr), hl		; move to next char 
1e0c cd 1b 10			call toUpper 		; make sure the input string matches case 
1e0f			 
1e0f			if DEBUG_FORTH_PARSE 
1e0f			endif 
1e0f			 
1e0f				; input stream end of token is a space so get rid of it 
1e0f			 
1e0f			;	cp ' ' 
1e0f			;	jr nz, .pnskipspace 
1e0f			; 
1e0f			;	ld a, 0		; make same term as word token term 
1e0f			; 
1e0f			;.pnskipspace: 
1e0f			 
1e0f			if DEBUG_FORTH_PARSE_KEY 
1e0f						DMARK "KY7" 
1e0f			endif 
1e0f b8				cp b 
1e10 c2 26 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e13				 
1e13			;    if same 
1e13			;       scan for string terms 0 for token and 32 for input 
1e13			 
1e13				 
1e13			if DEBUG_FORTH_PARSE_KEY 
1e13						DMARK "KY8" 
1e13			endif 
1e13			 
1e13 80				add b			 
1e14 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e16							; TODO need to make sure last word in zero term string is accounted for 
1e16 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e18			 
1e18			 
1e18				; at end of both strings so both are exact match 
1e18			 
1e18			;       skip ptr for next word 
1e18			 
1e18 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1e1b 23				inc hl			 ; at next char 
1e1c 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e1f 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e22				 
1e22				 
1e22			if DEBUG_FORTH_PARSE_KEY 
1e22						DMARK "KY3" 
1e22			endif 
1e22			 
1e22			 
1e22			 
1e22			;       exec code block 
1e22			if DEBUG_FORTH_JP 
1e22				call clear_display 
1e22				call update_display 
1e22				call delay1s 
1e22				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e22				ld a,h 
1e22				ld hl, os_word_scratch 
1e22				call hexout 
1e22				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e22				ld a,l 
1e22				ld hl, os_word_scratch+2 
1e22				call hexout 
1e22				ld hl, os_word_scratch+4 
1e22				ld a,0 
1e22				ld (hl),a 
1e22				ld de,os_word_scratch 
1e22				call str_at_display 
1e22					ld a, display_row_2 
1e22					call str_at_display 
1e22				ld de, (cli_origtoken) 
1e22				ld a, display_row_1+10 
1e22					call str_at_display 
1e22			 
1e22				ld a,display_row_1 
1e22				ld de, .foundword 
1e22				ld a, display_row_3 
1e22				call str_at_display 
1e22				call update_display 
1e22				call delay1s 
1e22				call delay1s 
1e22				call delay1s 
1e22			endif 
1e22			 
1e22			if DEBUG_FORTH_PARSE_KEY 
1e22						DMARK "KYj" 
1e22			endif 
1e22				; TODO save the word pointer in this exec 
1e22			 
1e22 2a 2f eb			ld hl,(cli_execword) 
1e25 e9				jp (hl) 
1e26			 
1e26			 
1e26			;    if not same 
1e26			;	scan for zero term 
1e26			;	get ptr for next word 
1e26			;	goto word comp 
1e26			 
1e26			.execpnskipword:	; get pointer to next word 
1e26 2a 2d eb			ld hl,(cli_nextword) 
1e29			 
1e29 7e				ld a,(hl) 
1e2a fe 00			cp WORD_SYS_END 
1e2c			;	cp 0 
1e2c 28 09			jr z, .execendofdict			 ; at end of words 
1e2e			 
1e2e			if DEBUG_FORTH_PARSE_KEY 
1e2e						DMARK "KY4" 
1e2e			endif 
1e2e			if DEBUG_FORTH_PARSE_EXEC 
1e2e			 
1e2e				; see if disabled 
1e2e			 
1e2e				ld a, (os_view_disable) 
1e2e				cp '*' 
1e2e				jr z, .noskip 
1e2e			 
1e2e			 
1e2e				ld de, .nowordfound 
1e2e				ld a, display_row_3 
1e2e				call str_at_display 
1e2e				call update_display 
1e2e				ld a, 100 
1e2e				call aDelayInMS 
1e2e				 
1e2e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e2e					call delay250ms 
1e2e				endif 
1e2e			.noskip:  
1e2e			 
1e2e			endif	 
1e2e			 
1e2e 2a 29 eb			ld hl,(cli_origptr) 
1e31 22 2b eb			ld (cli_ptr),hl 
1e34			 
1e34			if DEBUG_FORTH_PARSE_KEY 
1e34						DMARK "KY5" 
1e34			endif 
1e34 c3 da 1d			jp .execpnword			; else go to next word 
1e37			 
1e37			.execendofdict:  
1e37			 
1e37			if DEBUG_FORTH_PARSE_KEY 
1e37						DMARK "KYe" 
1e37			endif 
1e37			if DEBUG_FORTH_PARSE_EXEC 
1e37				; see if disabled 
1e37			 
1e37				ld a, (os_view_disable) 
1e37				cp '*' 
1e37				jr z, .ispskip 
1e37			 
1e37				call clear_display 
1e37				call update_display 
1e37				call delay1s 
1e37				ld de, (cli_origptr) 
1e37				ld a, display_row_1 
1e37				call str_at_display 
1e37				 
1e37				ld de, .enddict 
1e37				ld a, display_row_3 
1e37				call str_at_display 
1e37				call update_display 
1e37				ld a, 100 
1e37				call aDelayInMS 
1e37				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e37				call delay1s 
1e37				call delay1s 
1e37				call delay1s 
1e37				endif 
1e37			.ispskip:  
1e37				 
1e37			endif	 
1e37			 
1e37			 
1e37			 
1e37				; if the word is not a keyword then must be a literal so push it to stack 
1e37			 
1e37			; push token to stack to end of word 
1e37			 
1e37				STACKFRAME ON $1efe $2f9f 
1e37				if DEBUG_STACK_IMB 
1e37					if ON 
1e37						exx 
1e37						ld de, $1efe 
1e37						ld a, d 
1e37						ld hl, curframe 
1e37						call hexout 
1e37						ld a, e 
1e37						ld hl, curframe+2 
1e37						call hexout 
1e37						ld hl, $1efe 
1e37						push hl 
1e37						ld hl, $2f9f 
1e37						push hl 
1e37						exx 
1e37					endif 
1e37				endif 
1e37			endm 
# End of macro STACKFRAME
1e37			 
1e37 2a 61 e6		ld hl,(os_tok_ptr) 
1e3a cd 2f 1b		call forth_apush 
1e3d			 
1e3d				STACKFRAMECHK ON $1efe $2f9f 
1e3d				if DEBUG_STACK_IMB 
1e3d					if ON 
1e3d						exx 
1e3d						ld hl, $2f9f 
1e3d						pop de   ; $2f9f 
1e3d						call cmp16 
1e3d						jr nz, .spnosame 
1e3d						ld hl, $1efe 
1e3d						pop de   ; $1efe 
1e3d						call cmp16 
1e3d						jr z, .spfrsame 
1e3d						.spnosame: call showsperror 
1e3d						.spfrsame: nop 
1e3d						exx 
1e3d					endif 
1e3d				endif 
1e3d			endm 
# End of macro STACKFRAMECHK
1e3d			 
1e3d			execnext: 
1e3d			 
1e3d			if DEBUG_FORTH_PARSE_KEY 
1e3d						DMARK "KY>" 
1e3d			endif 
1e3d			; move past token to next word 
1e3d			 
1e3d 2a 61 e6		ld hl, (os_tok_ptr) 
1e40 3e 00		ld a, 0 
1e42 01 ff 00		ld bc, 255     ; input buffer size 
1e45 ed b1		cpir 
1e47			 
1e47			if DEBUG_FORTH_PARSE_KEY 
1e47						DMARK "KY!" 
1e47				CALLMONITOR 
1e47			endif	 
1e47			; TODO this might place hl on the null, so will need to forward on??? 
1e47			;inc hl   ; see if this gets onto the next item 
1e47			 
1e47			 
1e47			; TODO pass a pointer to the buffer to push 
1e47			; TODO call function to push 
1e47			 
1e47			; look for end of input 
1e47			 
1e47			;inc hl 
1e47			;ld a,(hl) 
1e47			;cp FORTH_END_BUFFER 
1e47			;ret z 
1e47			 
1e47			 
1e47 c3 c0 1d		jp exec1 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			findnexttok: 
1e4a			 
1e4a				; hl is pointer to move 
1e4a				; de is the token to locate 
1e4a			 
1e4a					if DEBUG_FORTH 
1e4a						DMARK "NTK" 
1e4a						CALLMONITOR 
1e4a					endif 
1e4a d5				push de 
1e4b			 
1e4b			.fnt1:	 
1e4b				; find first char of token to locate 
1e4b			 
1e4b 1a				ld a, (de) 
1e4c 4f				ld c,a 
1e4d 7e				ld a,(hl) 
1e4e cd 1b 10			call toUpper 
1e51					if DEBUG_FORTH 
1e51						DMARK "NT1" 
1e51						CALLMONITOR 
1e51					endif 
1e51 b9				cp c 
1e52			 
1e52 28 03			jr z, .fnt2cmpmorefirst	 
1e54			 
1e54				; first char not found move to next char 
1e54			 
1e54 23				inc hl 
1e55 18 f4			jr .fnt1 
1e57			 
1e57			.fnt2cmpmorefirst:	 
1e57				; first char of token found.  
1e57			 
1e57 e5				push hl     ; save start of token just in case it is the right one 
1e58 d9				exx 
1e59 e1				pop hl        ; save it to hl' 
1e5a d9				exx 
1e5b			 
1e5b			 
1e5b			.fnt2cmpmore:	 
1e5b				; compare the rest 
1e5b				 
1e5b 23				inc hl 
1e5c 13				inc de 
1e5d				 
1e5d 1a				ld a, (de) 
1e5e 4f				ld c,a 
1e5f 7e				ld a,(hl) 
1e60 cd 1b 10			call toUpper 
1e63			 
1e63					if DEBUG_FORTH 
1e63						DMARK "NT2" 
1e63						CALLMONITOR 
1e63					endif 
1e63				; c has the token to find char 
1e63				; a has the mem to scan char 
1e63			 
1e63 b9				cp c 
1e64 28 04			jr z,.fntmatch1 
1e66			 
1e66				; they are not the same 
1e66			 
1e66					if DEBUG_FORTH 
1e66						DMARK "NT3" 
1e66						CALLMONITOR 
1e66					endif 
1e66 d1				pop de	; reset de token to look for 
1e67 d5				push de 
1e68 18 e1			jr .fnt1 
1e6a				 
1e6a			.fntmatch1: 
1e6a			 
1e6a				; is the same char a null which means we might have a full hit? 
1e6a					if DEBUG_FORTH 
1e6a						DMARK "NT4" 
1e6a						CALLMONITOR 
1e6a					endif 
1e6a			 
1e6a fe 00			cp 0 
1e6c 28 0b			jr z, .fntmatchyes 
1e6e			 
1e6e				; are we at the end of the token to find? 
1e6e			 
1e6e					if DEBUG_FORTH 
1e6e						DMARK "NT5" 
1e6e						CALLMONITOR 
1e6e					endif 
1e6e 3e 00			ld a, 0 
1e70 b9				cp c 
1e71			 
1e71 c2 5b 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e74			 
1e74					if DEBUG_FORTH 
1e74						DMARK "NT6" 
1e74						CALLMONITOR 
1e74					endif 
1e74				; token to find is exhusted but no match to stream 
1e74			 
1e74				; restore tok pointer and continue on 
1e74 d1				pop de 
1e75 d5				push de 
1e76 c3 4b 1e			jp .fnt1 
1e79			 
1e79			 
1e79			.fntmatchyes: 
1e79			 
1e79				; hl now contains the end of the found token 
1e79			 
1e79				; get rid of saved token pointer to find 
1e79			 
1e79 d1				pop de 
1e7a			 
1e7a					if DEBUG_FORTH 
1e7a						DMARK "NT9" 
1e7a						CALLMONITOR 
1e7a					endif 
1e7a			 
1e7a				; hl will be on the null term so forward on 
1e7a			 
1e7a				; get back the saved start of the token 
1e7a			 
1e7a d9				exx 
1e7b e5				push hl     ; save start of token just in case it is the right one 
1e7c d9				exx 
1e7d e1				pop hl        ; save it to hl 
1e7e			 
1e7e c9				ret 
1e7f			 
1e7f			 
1e7f			; LIST needs to find a specific token   
1e7f			; FORGET needs to find a spefici token 
1e7f			 
1e7f			; SAVE needs to find all tokens by flag 
1e7f			; WORDS just needs to scan through all  by flag 
1e7f			; UWORDS needs to scan through all by flag 
1e7f			 
1e7f			 
1e7f			; given hl as pointer to start of dict look up string 
1e7f			; return hl as pointer to start of word block 
1e7f			; or 0 if not found 
1e7f			 
1e7f			forth_find_tok: 
1e7f c9				ret 
1e80			 
1e80			; given hl as pointer to dict structure 
1e80			; move to the next dict block structure 
1e80			 
1e80			forth_tok_next: 
1e80				; hl now points to the address of the next word pointer  
1e80				; TODO skip compiled symbol for now 
1e80			;	push de 
1e80 23				inc hl 
1e81 5e				ld e, (hl) 
1e82 23				inc hl 
1e83 56				ld d, (hl) 
1e84 23				inc hl 
1e85			 
1e85 eb				ex de,hl 
1e86			if DEBUG_FORTH_PARSE_NEXTWORD 
1e86				push bc 
1e86				ld bc, (cli_nextword) 
1e86						DMARK "NXW" 
1e86				CALLMONITOR 
1e86				pop bc 
1e86			endif 
1e86			;	pop de	 
1e86 c9				ret 
1e87			 
1e87			 
1e87			 
1e87			; eof 
# End of file forth_parserv5.asm
1e87				include "forth_wordsv4.asm" 
1e87			 
1e87			; the core word dictionary v4 
1e87			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e87			 
1e87			; this is a linked list for each of the system words used 
1e87			; user defined words will follow the same format but will be in ram 
1e87			 
1e87			 
1e87			; 
1e87			; 
1e87			; define linked list: 
1e87			; 
1e87			; 1. compiled byte op code 
1e87			; 2. len of text word 
1e87			; 3. text word 
1e87			; 4. ptr to next dictionary word 
1e87			; 5. asm, calls etc for the word 
1e87			; 
1e87			;  if 1 == 0 then last word in dict  
1e87			;   
1e87			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e87			;  
1e87			;  
1e87			; create basic standard set of words 
1e87			; 
1e87			;  
1e87			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e87			; 2DUP 2DROP 2SWAP  
1e87			; @ C@ - get byte  
1e87			; ! C! - store byte 
1e87			; 0< true if less than zero 
1e87			; 0= true if zero 
1e87			; < >  
1e87			; = true if same 
1e87			; variables 
1e87			 
1e87			 
1e87			; Hardware specific words I may need 
1e87			; 
1e87			; IN OUT  
1e87			; calls to key util functions 
1e87			; calls to hardward abstraction stuff 
1e87			; easy control of frame buffers and lcd i/o 
1e87			; keyboard  
1e87			 
1e87			 
1e87			;DICT: macro 
1e87			; op_code, len, word, next 
1e87			;    word: 
1e87			;    db op_code 
1e87			;    ds word zero term 
1e87			;    dw next 
1e87			;    endm 
1e87			 
1e87			 
1e87			 
1e87			 
1e87			; op code 1 is a flag for user define words which are to be handled differently 
1e87			 
1e87			 
1e87			; 
1e87			; 
1e87			;    TODO on entry to a word this should be the expected environment 
1e87			;    hl - tos value if number then held, if string this is the ptr 
1e87			;    de -  
1e87			 
1e87			 
1e87			; opcode ranges 
1e87			; 0 - end of word dict 
1e87			; 255 - user define words 
1e87			 
1e87			sysdict: 
1e87			include "forth_opcodes.asm" 
1e87			; op codes for forth keywords 
1e87			; free to use code 0  
1e87				OPCODE_HEAP: equ  1 
1e87				OPCODE_EXEC: equ 2 
1e87				OPCODE_DUP: equ 3 
1e87				OPCODE_SWAP: equ 4 
1e87				OPCODE_COLN: equ 5 
1e87				OPCODE_SCOLN: equ 6 
1e87				OPCODE_DROP: equ 7 
1e87				OPCODE_DUP2: equ 8 
1e87				OPCODE_DROP2: equ 9 
1e87				OPCODE_SWAP2: equ 10 
1e87				OPCODE_AT: equ 11 
1e87				OPCODE_CAT: equ 12 
1e87				OPCODE_BANG: equ 13 
1e87				OPCODE_CBANG: equ 14 
1e87				OPCODE_SCALL: equ 15 
1e87				OPCODE_DEPTH: equ 16 
1e87				OPCODE_OVER: equ 17 
1e87				OPCODE_PAUSE: equ 18 
1e87				OPCODE_PAUSES: equ 19 
1e87				OPCODE_ROT: equ 20 
1e87			;free to reuse	OPCODE_WORDS: equ 21 
1e87			        OPCODE_NOT: equ 21 
1e87				OPCODE_UWORDS: equ 22 
1e87				OPCODE_BP: equ 23 
1e87				OPCODE_MONITOR: equ 24  
1e87				OPCODE_MALLOC: equ 25 
1e87				OPCODE_FREE: equ 26 
1e87				OPCODE_LIST: equ 27 
1e87				OPCODE_FORGET: equ 28 
1e87				OPCODE_NOP: equ 29 
1e87				OPCODE_COMO: equ 30 
1e87				OPCODE_COMC: equ 31 
1e87			;free to reuse	OPCODE_ENDCORE: equ 32 
1e87				OPCODE_AFTERSOUND: equ 33 
1e87				OPCODE_GP2: equ 34 
1e87				OPCODE_GP3: equ 35 
1e87				OPCODE_GP4: equ 36 
1e87				OPCODE_SIN: equ 37 
1e87				OPCODE_SOUT: equ 38 
1e87				OPCODE_SPIO: equ 39 
1e87				OPCODE_SPICEH: equ 40 
1e87				OPCODE_SPIOb: equ 41 
1e87				OPCODE_SPII: equ 42 
1e87				OPCODE_SESEL: equ 43 
1e87				OPCODE_CARTDEV: equ 44 
1e87			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e87				OPCODE_FB: equ 46 
1e87				OPCODE_EMIT: equ 47 
1e87				OPCODE_DOTH: equ 48 
1e87				OPCODE_DOTF: equ 49 
1e87				OPCODE_DOT: equ 50 
1e87				OPCODE_CLS: equ 51 
1e87				OPCODE_DRAW: equ 52 
1e87				OPCODE_DUMP: equ 53 
1e87				OPCODE_CDUMP: equ 54 
1e87				OPCODE_DAT: equ 55 
1e87				OPCODE_HOME: equ 56 
1e87				OPCODE_SPACE: equ 57 
1e87				OPCODE_SPACES: equ 58 
1e87				OPCODE_SCROLL: equ 59 
1e87				OPCODE_ATQ: equ 60 
1e87				OPCODE_AUTODSP: equ 61 
1e87				OPCODE_MENU: equ 62 
1e87			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e87				OPCODE_THEN: equ 64 
1e87				OPCODE_ELSE: equ 65 
1e87				OPCODE_DO: equ 66 
1e87				OPCODE_LOOP: equ 67 
1e87				OPCODE_I: equ 68 
1e87				OPCODE_DLOOP: equ 69  
1e87				OPCODE_REPEAT: equ 70  
1e87				OPCODE_UNTIL: equ 71 
1e87				OPCODE_ENDFLOW: equ 72 
1e87				OPCODE_WAITK: equ 73 
1e87				OPCODE_ACCEPT: equ 74 
1e87				OPCODE_EDIT: equ 75 
1e87			;free to reuse	OPCODE_ENDKEY: equ 76 
1e87				OPCODE_LZERO: equ 77 
1e87				OPCODE_TZERO: equ 78 
1e87				OPCODE_LESS: equ 79 
1e87				OPCODE_GT: equ 80 
1e87				OPCODE_EQUAL: equ 81  
1e87			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e87				OPCODE_NEG: equ 83 
1e87				OPCODE_DIV: equ 84 
1e87				OPCODE_MUL: equ 85 
1e87				OPCODE_MIN: equ 86 
1e87				OPCODE_MAX: equ 87 
1e87				OPCODE_RND16: equ 88 
1e87				OPCODE_RND8: equ 89 
1e87				OPCODE_RND: equ 90 
1e87			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e87				OPCODE_BYNAME: equ 92 
1e87				OPCODE_DIR: equ 93 
1e87				OPCODE_SAVE: equ 94 
1e87				OPCODE_LOAD: equ 95 
1e87				OPCODE_BSAVE: equ 96 
1e87				OPCODE_BLOAD: equ 97 
1e87				OPCODE_SEO: equ 98  
1e87				OPCODE_SEI: equ 99 
1e87				OPCODE_SFREE: equ 100 
1e87				OPCODE_SIZE: equ 101 
1e87				OPCODE_CREATE: equ 102 
1e87				OPCODE_APPEND: equ 103 
1e87				OPCODE_SDEL: equ 104 
1e87				OPCODE_OPEN: equ 105 
1e87				OPCODE_READ: equ 106 
1e87				OPCODE_EOF: equ 106 
1e87				OPCODE_FORMAT: equ 107 
1e87				OPCODE_LABEL: equ 108 
1e87				OPCODE_LABELS: equ 109 
1e87			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e87				OPCODE_UPPER: equ 111 
1e87				OPCODE_LOWER: equ 112 
1e87				OPCODE_SUBSTR: equ 113 
1e87				OPCODE_LEFT: equ 114 
1e87				OPCODE_RIGHT: equ 115 
1e87				OPCODE_STR2NUM: equ 116 
1e87				OPCODE_NUM2STR: equ 117 
1e87				OPCODE_CONCAT: equ 118 
1e87				OPCODE_FIND: equ 119 
1e87				OPCODE_LEN: equ 120 
1e87				OPCODE_CHAR: equ 121 
1e87			; free to reuse	OPCODE_STRLEN: equ 122 
1e87			; free to reuse	OPCODE_ENDSTR: equ 123 
1e87				OPCODE_V0S: equ 124 
1e87				OPCODE_V0Q: equ 125 
1e87				OPCODE_V1S: equ 126 
1e87				OPCODE_V1Q: equ 127 
1e87				OPCODE_V2S: equ 128 
1e87				OPCODE_V2Q: equ 129 
1e87				OPCODE_V3S: equ 130 
1e87				OPCODE_V3Q: equ 131 
1e87			;free to reuse	OPCODE_END: equ 132 
1e87				OPCODE_ZDUP: equ 133 
1e87			 
1e87			; eof 
# End of file forth_opcodes.asm
1e87			 
1e87			include "forth_words_core.asm" 
1e87			 
1e87			; | ## Core Words 
1e87			 
1e87			;if MALLOC_4 
1e87			 
1e87			.HEAP: 
1e87				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e87 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e88 c6 1e			dw .EXEC            
1e8a 05				db 4 + 1 
1e8b .. 00			db "HEAP",0              
1e90				endm 
# End of macro CWHEAD
1e90			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e90			; | | u1 - Current number of bytes in the heap 
1e90			; | | u2 - Remaining bytes left on the heap 
1e90			; | |  
1e90			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e90			 
1e90			 
1e90					if DEBUG_FORTH_WORDS_KEY 
1e90						DMARK "HEP" 
1e90 f5				push af  
1e91 3a a5 1e			ld a, (.dmark)  
1e94 32 7a ee			ld (debug_mark),a  
1e97 3a a6 1e			ld a, (.dmark+1)  
1e9a 32 7b ee			ld (debug_mark+1),a  
1e9d 3a a7 1e			ld a, (.dmark+2)  
1ea0 32 7c ee			ld (debug_mark+2),a  
1ea3 18 03			jr .pastdmark  
1ea5 ..			.dmark: db "HEP"  
1ea8 f1			.pastdmark: pop af  
1ea9			endm  
# End of macro DMARK
1ea9						CALLMONITOR 
1ea9 cd 39 14			call break_point_state  
1eac				endm  
# End of macro CALLMONITOR
1eac					endif 
1eac 2a f1 58				ld hl, (free_list )      
1eaf 11 f6 58				ld de, heap_start 
1eb2			 
1eb2 ed 52				sbc hl, de  
1eb4			 
1eb4 cd c6 19				call forth_push_numhl 
1eb7			 
1eb7			 
1eb7 ed 5b f1 58			ld de, (free_list )      
1ebb 21 46 e3				ld hl, heap_end 
1ebe			 
1ebe ed 52				sbc hl, de 
1ec0			 
1ec0 cd c6 19				call forth_push_numhl 
1ec3					 
1ec3			 
1ec3					 
1ec3			 
1ec3			 
1ec3			 
1ec3					NEXTW 
1ec3 c3 2f 1d			jp macro_next 
1ec6				endm 
# End of macro NEXTW
1ec6			;endif 
1ec6			 
1ec6			.EXEC: 
1ec6			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1ec6			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1ec6			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1ec6			;; > > 
1ec6			;; > >   
1ec6			;	STACKFRAME OFF $5efe $5f9f 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "EXE" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	FORTH_DSP_POP 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX1" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;;	ld e,(hl) 
1ec6			;;	inc hl 
1ec6			;;	ld d,(hl) 
1ec6			;;	ex de,hl 
1ec6			; 
1ec6			;;		if DEBUG_FORTH_WORDS 
1ec6			;;			DMARK "EX2" 
1ec6			;;			CALLMONITOR 
1ec6			;;		endif 
1ec6			;	push hl 
1ec6			; 
1ec6			;	;ld a, 0 
1ec6			;	;ld a, FORTH_END_BUFFER 
1ec6			;	call strlenz 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include term 
1ec6			;	inc hl   ; include term 
1ec6			;	ld b,0 
1ec6			;	ld c,l 
1ec6			;	pop hl 
1ec6			;	ld de, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir 
1ec6			; 
1ec6			; 
1ec6			;	ld hl, execscratch 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXe" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	call forthexec 
1ec6			;;	call forthexec_cleanup 
1ec6			;;	call forthparse 
1ec6			;;	call forthexec 
1ec6			; 
1ec6			;	STACKFRAMECHK OFF $5efe $5f9f 
1ec6			; 
1ec6			;	; an immediate word so no need to process any more words 
1ec6			;	ret 
1ec6			;	NEXTW 
1ec6			 
1ec6			; dead code - old version  
1ec6			;	FORTH_RSP_NEXT 
1ec6			 
1ec6			;  
1ec6			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ec6			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ec6			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ec6			;	push hl 
1ec6			;	push de 
1ec6			;	push bc 
1ec6			; 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "EXR" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			; 
1ec6			; 
1ec6			;	;v5 FORTH_DSP_VALUE 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	; TODO do string type checks 
1ec6			; 
1ec6			;;v5	inc hl   ; skip type 
1ec6			; 
1ec6			;	push hl  ; source code  
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX1" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ld a, 0 
1ec6			;	call strlent 
1ec6			; 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			; 
1ec6			;	push hl    ; size 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX2" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	call malloc 
1ec6			; 
1ec6			;	ex de, hl    ; de now contains malloc area 
1ec6			;	pop bc   	; get byte count 
1ec6			;	pop hl      ; get string to copy 
1ec6			; 
1ec6			;	push de     ; save malloc for free later 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir       ; duplicate string 
1ec6			; 
1ec6			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1ec6			;	 
1ec6			;	; TODO fix the parse would be better than this...  
1ec6			;	ex de, hl 
1ec6			;	dec hl 
1ec6			;	ld a, 0 
1ec6			;	ld (hl), a 
1ec6			;	dec hl 
1ec6			;	ld a, ' ' 
1ec6			;	ld (hl), a 
1ec6			;	dec hl 
1ec6			;	ld (hl), a 
1ec6			; 
1ec6			;	dec hl 
1ec6			;	ld (hl), a 
1ec6			; 
1ec6			; 
1ec6			;	FORTH_DSP_POP  
1ec6			; 
1ec6			;	pop hl     
1ec6			;	push hl    ; save malloc area 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX4" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	call forthexec 
1ec6			;	 
1ec6			;	pop hl 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX5" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			; 
1ec6			;	if FORTH_ENABLE_FREE 
1ec6			;	call free 
1ec6			;	endif 
1ec6			; 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX6" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			; 
1ec6			;	pop bc 
1ec6			;	pop de 
1ec6			;	pop hl 
1ec6			;;	FORTH_RSP_POP	  
1ec6			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1ec6			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1ec6			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1ec6			; 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX7" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			;	NEXTW 
1ec6			 
1ec6			;.STKEXEC: 
1ec6			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1ec6			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1ec6			; 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "STX" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	ld (store_tmp1), hl    ; count 
1ec6			; 
1ec6			;	FORTH_DSP_POP 
1ec6			;.stkexec1: 
1ec6			;	ld hl, (store_tmp1)   ; count 
1ec6			;	ld a, 0 
1ec6			;	cp l 
1ec6			;	ret z 
1ec6			; 
1ec6			;	dec hl 
1ec6			;	ld (store_tmp1), hl    ; count 
1ec6			;	 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			;	push hl 
1ec6			;	 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXp" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	FORTH_DSP_POP 
1ec6			; 
1ec6			;	call strlenz 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	ld b,0 
1ec6			;	ld c,l 
1ec6			;	pop hl 
1ec6			;	ld de, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir 
1ec6			; 
1ec6			; 
1ec6			;	ld hl, execscratch 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXP" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	ld hl, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXx" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	call forthexec 
1ec6			; 
1ec6			;	jp .stkexec1 
1ec6			; 
1ec6			;	ret 
1ec6			 
1ec6			 
1ec6			.DUP: 
1ec6				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1ec6 17				db WORD_SYS_CORE+OPCODE_DUP             
1ec7 3c 1f			dw .ZDUP            
1ec9 04				db 3 + 1 
1eca .. 00			db "DUP",0              
1ece				endm 
# End of macro CWHEAD
1ece			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1ece			 
1ece					if DEBUG_FORTH_WORDS_KEY 
1ece						DMARK "DUP" 
1ece f5				push af  
1ecf 3a e3 1e			ld a, (.dmark)  
1ed2 32 7a ee			ld (debug_mark),a  
1ed5 3a e4 1e			ld a, (.dmark+1)  
1ed8 32 7b ee			ld (debug_mark+1),a  
1edb 3a e5 1e			ld a, (.dmark+2)  
1ede 32 7c ee			ld (debug_mark+2),a  
1ee1 18 03			jr .pastdmark  
1ee3 ..			.dmark: db "DUP"  
1ee6 f1			.pastdmark: pop af  
1ee7			endm  
# End of macro DMARK
1ee7						CALLMONITOR 
1ee7 cd 39 14			call break_point_state  
1eea				endm  
# End of macro CALLMONITOR
1eea					endif 
1eea			 
1eea					FORTH_DSP 
1eea cd 83 1b			call macro_forth_dsp 
1eed				endm 
# End of macro FORTH_DSP
1eed			 
1eed 7e					ld a, (HL) 
1eee fe 01				cp DS_TYPE_STR 
1ef0 20 25				jr nz, .dupinum 
1ef2			 
1ef2					; push another string 
1ef2			 
1ef2					FORTH_DSP_VALUEHL     		 
1ef2 cd bd 1b			call macro_dsp_valuehl 
1ef5				endm 
# End of macro FORTH_DSP_VALUEHL
1ef5			 
1ef5				if DEBUG_FORTH_WORDS 
1ef5					DMARK "DUs" 
1ef5 f5				push af  
1ef6 3a 0a 1f			ld a, (.dmark)  
1ef9 32 7a ee			ld (debug_mark),a  
1efc 3a 0b 1f			ld a, (.dmark+1)  
1eff 32 7b ee			ld (debug_mark+1),a  
1f02 3a 0c 1f			ld a, (.dmark+2)  
1f05 32 7c ee			ld (debug_mark+2),a  
1f08 18 03			jr .pastdmark  
1f0a ..			.dmark: db "DUs"  
1f0d f1			.pastdmark: pop af  
1f0e			endm  
# End of macro DMARK
1f0e					CALLMONITOR 
1f0e cd 39 14			call break_point_state  
1f11				endm  
# End of macro CALLMONITOR
1f11				endif 
1f11 cd 34 1a				call forth_push_str 
1f14			 
1f14					NEXTW 
1f14 c3 2f 1d			jp macro_next 
1f17				endm 
# End of macro NEXTW
1f17			 
1f17			 
1f17			.dupinum: 
1f17					 
1f17			 
1f17			 
1f17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f17 cd bd 1b			call macro_dsp_valuehl 
1f1a				endm 
# End of macro FORTH_DSP_VALUEHL
1f1a			 
1f1a				; TODO add floating point number detection 
1f1a			 
1f1a				if DEBUG_FORTH_WORDS 
1f1a					DMARK "DUi" 
1f1a f5				push af  
1f1b 3a 2f 1f			ld a, (.dmark)  
1f1e 32 7a ee			ld (debug_mark),a  
1f21 3a 30 1f			ld a, (.dmark+1)  
1f24 32 7b ee			ld (debug_mark+1),a  
1f27 3a 31 1f			ld a, (.dmark+2)  
1f2a 32 7c ee			ld (debug_mark+2),a  
1f2d 18 03			jr .pastdmark  
1f2f ..			.dmark: db "DUi"  
1f32 f1			.pastdmark: pop af  
1f33			endm  
# End of macro DMARK
1f33					CALLMONITOR 
1f33 cd 39 14			call break_point_state  
1f36				endm  
# End of macro CALLMONITOR
1f36				endif 
1f36			 
1f36 cd c6 19				call forth_push_numhl 
1f39					NEXTW 
1f39 c3 2f 1d			jp macro_next 
1f3c				endm 
# End of macro NEXTW
1f3c			.ZDUP: 
1f3c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f3c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f3d 74 1f			dw .SWAP            
1f3f 05				db 4 + 1 
1f40 .. 00			db "?DUP",0              
1f45				endm 
# End of macro CWHEAD
1f45			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f45			 
1f45					if DEBUG_FORTH_WORDS_KEY 
1f45						DMARK "qDU" 
1f45 f5				push af  
1f46 3a 5a 1f			ld a, (.dmark)  
1f49 32 7a ee			ld (debug_mark),a  
1f4c 3a 5b 1f			ld a, (.dmark+1)  
1f4f 32 7b ee			ld (debug_mark+1),a  
1f52 3a 5c 1f			ld a, (.dmark+2)  
1f55 32 7c ee			ld (debug_mark+2),a  
1f58 18 03			jr .pastdmark  
1f5a ..			.dmark: db "qDU"  
1f5d f1			.pastdmark: pop af  
1f5e			endm  
# End of macro DMARK
1f5e						CALLMONITOR 
1f5e cd 39 14			call break_point_state  
1f61				endm  
# End of macro CALLMONITOR
1f61					endif 
1f61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f61 cd bd 1b			call macro_dsp_valuehl 
1f64				endm 
# End of macro FORTH_DSP_VALUEHL
1f64			 
1f64 e5					push hl 
1f65			 
1f65					; is it a zero? 
1f65			 
1f65 3e 00				ld a, 0 
1f67 84					add h 
1f68 85					add l 
1f69			 
1f69 e1					pop hl 
1f6a			 
1f6a fe 00				cp 0 
1f6c 28 03				jr z, .dup2orig 
1f6e			 
1f6e			 
1f6e cd c6 19				call forth_push_numhl 
1f71			 
1f71			 
1f71				; TODO add floating point number detection 
1f71			 
1f71			.dup2orig: 
1f71			 
1f71					NEXTW 
1f71 c3 2f 1d			jp macro_next 
1f74				endm 
# End of macro NEXTW
1f74			.SWAP: 
1f74				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f74 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f75 b3 1f			dw .COLN            
1f77 05				db 4 + 1 
1f78 .. 00			db "SWAP",0              
1f7d				endm 
# End of macro CWHEAD
1f7d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f7d					if DEBUG_FORTH_WORDS_KEY 
1f7d						DMARK "SWP" 
1f7d f5				push af  
1f7e 3a 92 1f			ld a, (.dmark)  
1f81 32 7a ee			ld (debug_mark),a  
1f84 3a 93 1f			ld a, (.dmark+1)  
1f87 32 7b ee			ld (debug_mark+1),a  
1f8a 3a 94 1f			ld a, (.dmark+2)  
1f8d 32 7c ee			ld (debug_mark+2),a  
1f90 18 03			jr .pastdmark  
1f92 ..			.dmark: db "SWP"  
1f95 f1			.pastdmark: pop af  
1f96			endm  
# End of macro DMARK
1f96						CALLMONITOR 
1f96 cd 39 14			call break_point_state  
1f99				endm  
# End of macro CALLMONITOR
1f99					endif 
1f99			 
1f99					FORTH_DSP_VALUEHL 
1f99 cd bd 1b			call macro_dsp_valuehl 
1f9c				endm 
# End of macro FORTH_DSP_VALUEHL
1f9c e5					push hl     ; w2 
1f9d			 
1f9d					FORTH_DSP_POP 
1f9d cd 75 1c			call macro_forth_dsp_pop 
1fa0				endm 
# End of macro FORTH_DSP_POP
1fa0			 
1fa0					FORTH_DSP_VALUEHL 
1fa0 cd bd 1b			call macro_dsp_valuehl 
1fa3				endm 
# End of macro FORTH_DSP_VALUEHL
1fa3			 
1fa3					FORTH_DSP_POP 
1fa3 cd 75 1c			call macro_forth_dsp_pop 
1fa6				endm 
# End of macro FORTH_DSP_POP
1fa6			 
1fa6 d1					pop de     ; w2	, hl = w1 
1fa7			 
1fa7 eb					ex de, hl 
1fa8 d5					push de 
1fa9			 
1fa9 cd c6 19				call forth_push_numhl 
1fac			 
1fac e1					pop hl 
1fad			 
1fad cd c6 19				call forth_push_numhl 
1fb0					 
1fb0			 
1fb0					NEXTW 
1fb0 c3 2f 1d			jp macro_next 
1fb3				endm 
# End of macro NEXTW
1fb3			.COLN: 
1fb3				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1fb3 19				db WORD_SYS_CORE+OPCODE_COLN             
1fb4 3f 21			dw .SCOLN            
1fb6 02				db 1 + 1 
1fb7 .. 00			db ":",0              
1fb9				endm 
# End of macro CWHEAD
1fb9			; | : ( -- )         Create new word | DONE 
1fb9			 
1fb9					if DEBUG_FORTH_WORDS_KEY 
1fb9						DMARK "CLN" 
1fb9 f5				push af  
1fba 3a ce 1f			ld a, (.dmark)  
1fbd 32 7a ee			ld (debug_mark),a  
1fc0 3a cf 1f			ld a, (.dmark+1)  
1fc3 32 7b ee			ld (debug_mark+1),a  
1fc6 3a d0 1f			ld a, (.dmark+2)  
1fc9 32 7c ee			ld (debug_mark+2),a  
1fcc 18 03			jr .pastdmark  
1fce ..			.dmark: db "CLN"  
1fd1 f1			.pastdmark: pop af  
1fd2			endm  
# End of macro DMARK
1fd2						CALLMONITOR 
1fd2 cd 39 14			call break_point_state  
1fd5				endm  
# End of macro CALLMONITOR
1fd5					endif 
1fd5				STACKFRAME OFF $8efe $989f 
1fd5				if DEBUG_STACK_IMB 
1fd5					if OFF 
1fd5						exx 
1fd5						ld de, $8efe 
1fd5						ld a, d 
1fd5						ld hl, curframe 
1fd5						call hexout 
1fd5						ld a, e 
1fd5						ld hl, curframe+2 
1fd5						call hexout 
1fd5						ld hl, $8efe 
1fd5						push hl 
1fd5						ld hl, $989f 
1fd5						push hl 
1fd5						exx 
1fd5					endif 
1fd5				endif 
1fd5			endm 
# End of macro STACKFRAME
1fd5				; get parser buffer length  of new word 
1fd5			 
1fd5				 
1fd5			 
1fd5					; move tok past this to start of name defintition 
1fd5					; TODO get word to define 
1fd5					; TODO Move past word token 
1fd5					; TODO get length of string up to the ';' 
1fd5			 
1fd5 2a 61 e6			ld hl, (os_tok_ptr) 
1fd8 23				inc hl 
1fd9 23				inc hl 
1fda			 
1fda 3e 3b			ld a, ';' 
1fdc cd 2f 10			call strlent 
1fdf			 
1fdf 7d				ld a,l 
1fe0 32 5c e3			ld (os_new_parse_len), a 
1fe3			 
1fe3			 
1fe3			if DEBUG_FORTH_UWORD 
1fe3 ed 5b 61 e6		ld de, (os_tok_ptr) 
1fe7						DMARK ":01" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 7a ee			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 7b ee			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 7c ee			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db ":01"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd 39 14			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif 
2003			 
2003			; 
2003			;  new word memory layout: 
2003			;  
2003			;    : adg 6666 ;  
2003			; 
2003			;    db   1     ; user defined word  
2003 23				inc hl    
2004			;    dw   sysdict 
2004 23				inc hl 
2005 23				inc hl 
2006			;    db <word len>+1 (for null) 
2006 23				inc hl 
2007			;    db .... <word> 
2007			; 
2007			 
2007 23				inc hl    ; some extras for the word preamble before the above 
2008 23				inc hl 
2009 23				inc hl 
200a 23				inc hl 
200b 23				inc hl 
200c 23				inc hl 
200d 23				inc hl  
200e 23				inc hl 
200f 23				inc hl 
2010 23				inc hl 
2011 23				inc hl 
2012 23				inc hl 
2013 23				inc hl 
2014 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2015			;       exec word buffer 
2015			;	<ptr word>   
2015 23				inc hl 
2016 23				inc hl 
2017			;       <word list><null term> 7F final term 
2017			 
2017			 
2017			if DEBUG_FORTH_UWORD 
2017						DMARK ":02" 
2017 f5				push af  
2018 3a 2c 20			ld a, (.dmark)  
201b 32 7a ee			ld (debug_mark),a  
201e 3a 2d 20			ld a, (.dmark+1)  
2021 32 7b ee			ld (debug_mark+1),a  
2024 3a 2e 20			ld a, (.dmark+2)  
2027 32 7c ee			ld (debug_mark+2),a  
202a 18 03			jr .pastdmark  
202c ..			.dmark: db ":02"  
202f f1			.pastdmark: pop af  
2030			endm  
# End of macro DMARK
2030				CALLMONITOR 
2030 cd 39 14			call break_point_state  
2033				endm  
# End of macro CALLMONITOR
2033			endif 
2033			 
2033				 
2033					; malloc the size 
2033			 
2033 cd 8d 10				call malloc 
2036 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
2039			 
2039			;    db   1     ; user defined word  
2039 3e 01				ld a, WORD_SYS_UWORD  
203b 77					ld (hl), a 
203c				 
203c 23				inc hl    
203d			;    dw   sysdict 
203d 11 87 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2040 73				ld (hl), e 
2041 23				inc hl 
2042 72				ld (hl), d 
2043 23				inc hl 
2044			 
2044			 
2044			;    Setup dict word 
2044			 
2044 23				inc hl 
2045 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2048			 
2048				; 1. get length of dict word 
2048			 
2048			 
2048 2a 61 e6			ld hl, (os_tok_ptr) 
204b 23				inc hl 
204c 23				inc hl    ; position to start of dict word 
204d 3e 00			ld a, 0 
204f cd 2f 10			call strlent 
2052			 
2052			 
2052 23				inc hl    ; to include null??? 
2053			 
2053				; write length of dict word 
2053			 
2053 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2057 1b				dec de 
2058 eb				ex de, hl 
2059 73				ld (hl), e 
205a eb				ex de, hl 
205b			 
205b				 
205b			 
205b				; copy  
205b 4d				ld c, l 
205c 06 00			ld b, 0 
205e ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2062 2a 61 e6			ld hl, (os_tok_ptr) 
2065 23				inc hl 
2066 23				inc hl    ; position to start of dict word 
2067				 
2067			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2067				 
2067				; TODO need to convert word to upper case 
2067			 
2067			ucasetok:	 
2067 7e				ld a,(hl) 
2068 cd 1b 10			call toUpper 
206b 77				ld (hl),a 
206c ed a0			ldi 
206e f2 67 20		 	jp p, ucasetok 
2071			 
2071			 
2071			 
2071				; de now points to start of where the word body code should be placed 
2071 ed 53 58 e3		ld (os_new_work_ptr), de 
2075				; hl now points to the words to throw at forthexec which needs to be copied 
2075 22 56 e3			ld (os_new_src_ptr), hl 
2078			 
2078				; TODO add 'call to forthexec' 
2078			 
2078			if DEBUG_FORTH_UWORD 
2078 c5				push bc 
2079 ed 4b 5e e3		ld bc, (os_new_malloc) 
207d						DMARK ":0x" 
207d f5				push af  
207e 3a 92 20			ld a, (.dmark)  
2081 32 7a ee			ld (debug_mark),a  
2084 3a 93 20			ld a, (.dmark+1)  
2087 32 7b ee			ld (debug_mark+1),a  
208a 3a 94 20			ld a, (.dmark+2)  
208d 32 7c ee			ld (debug_mark+2),a  
2090 18 03			jr .pastdmark  
2092 ..			.dmark: db ":0x"  
2095 f1			.pastdmark: pop af  
2096			endm  
# End of macro DMARK
2096				CALLMONITOR 
2096 cd 39 14			call break_point_state  
2099				endm  
# End of macro CALLMONITOR
2099 c1				pop bc 
209a			endif 
209a			 
209a			 
209a				; create word preamble which should be: 
209a			 
209a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
209a			 
209a				;    ld hl, <word code> 
209a				;    jp user_exec 
209a			        ;    <word code bytes> 
209a			 
209a			 
209a			;	inc de     ; TODO ??? or are we already past the word's null 
209a eb				ex de, hl 
209b			 
209b 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
209d			 
209d 23				inc hl 
209e 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
20a1 23				inc hl 
20a2			 
20a2 23				inc hl 
20a3 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
20a5			 
20a5 01 72 44			ld bc, user_exec 
20a8 23				inc hl 
20a9 71				ld (hl), c     ; poke address of user_exec 
20aa 23				inc hl 
20ab 70				ld (hl), b     
20ac			 ; 
20ac			;	inc hl 
20ac			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ac			; 
20ac			; 
20ac			;	ld bc, macro_forth_rsp_next 
20ac			;	inc hl 
20ac			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
20ac			;	inc hl 
20ac			;	ld (hl), b     
20ac			 ; 
20ac			;	inc hl 
20ac			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ac			; 
20ac			; 
20ac			;	inc hl 
20ac			;	ld bc, forthexec 
20ac			;	ld (hl), c     ; poke address of forthexec 
20ac			;	inc hl 
20ac			;	ld (hl), b      
20ac			; 
20ac			;	inc hl 
20ac			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
20ac			; 
20ac			;	ld bc, user_dict_next 
20ac			;	inc hl 
20ac			;	ld (hl), c     ; poke address of forthexec 
20ac			;	inc hl 
20ac			;	ld (hl), b      
20ac			 
20ac				; hl is now where we need to copy the word byte data to save this 
20ac			 
20ac 23				inc hl 
20ad 22 54 e3			ld (os_new_exec), hl 
20b0				 
20b0				; copy definition 
20b0			 
20b0 eb				ex de, hl 
20b1			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20b1			;	inc de    ; skip the PC for this parse 
20b1 3a 5c e3			ld a, (os_new_parse_len) 
20b4 4f				ld c, a 
20b5 06 00			ld b, 0 
20b7 ed b0			ldir		 ; copy defintion 
20b9			 
20b9			 
20b9				; poke the address of where the new word bytes live for forthexec 
20b9			 
20b9 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20bc			 
20bc ed 5b 54 e3		ld de, (os_new_exec)      
20c0				 
20c0 73				ld (hl), e 
20c1 23				inc hl 
20c2 72				ld (hl), d 
20c3			 
20c3					; TODO copy last user dict word next link to this word 
20c3					; TODO update last user dict word to point to this word 
20c3			; 
20c3			; hl f923 de 812a ; bc 811a 
20c3			 
20c3			if DEBUG_FORTH_UWORD 
20c3 c5				push bc 
20c4 ed 4b 5e e3		ld bc, (os_new_malloc) 
20c8						DMARK ":0A" 
20c8 f5				push af  
20c9 3a dd 20			ld a, (.dmark)  
20cc 32 7a ee			ld (debug_mark),a  
20cf 3a de 20			ld a, (.dmark+1)  
20d2 32 7b ee			ld (debug_mark+1),a  
20d5 3a df 20			ld a, (.dmark+2)  
20d8 32 7c ee			ld (debug_mark+2),a  
20db 18 03			jr .pastdmark  
20dd ..			.dmark: db ":0A"  
20e0 f1			.pastdmark: pop af  
20e1			endm  
# End of macro DMARK
20e1				CALLMONITOR 
20e1 cd 39 14			call break_point_state  
20e4				endm  
# End of macro CALLMONITOR
20e4 c1				pop bc 
20e5			endif 
20e5			if DEBUG_FORTH_UWORD 
20e5 c5				push bc 
20e6 ed 4b 5e e3		ld bc, (os_new_malloc) 
20ea 03				inc bc 
20eb 03				inc bc 
20ec 03				inc bc 
20ed 03				inc bc 
20ee 03				inc bc 
20ef 03				inc bc 
20f0 03				inc bc 
20f1 03				inc bc 
20f2			 
20f2						DMARK ":0B" 
20f2 f5				push af  
20f3 3a 07 21			ld a, (.dmark)  
20f6 32 7a ee			ld (debug_mark),a  
20f9 3a 08 21			ld a, (.dmark+1)  
20fc 32 7b ee			ld (debug_mark+1),a  
20ff 3a 09 21			ld a, (.dmark+2)  
2102 32 7c ee			ld (debug_mark+2),a  
2105 18 03			jr .pastdmark  
2107 ..			.dmark: db ":0B"  
210a f1			.pastdmark: pop af  
210b			endm  
# End of macro DMARK
210b				CALLMONITOR 
210b cd 39 14			call break_point_state  
210e				endm  
# End of macro CALLMONITOR
210e c1				pop bc 
210f			endif 
210f			 
210f			; update word dict linked list for new word 
210f			 
210f			 
210f 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2112 23			inc hl     ; move to next work linked list ptr 
2113			 
2113 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
2117 73			ld (hl), e 
2118 23			inc hl 
2119 72			ld (hl), d 
211a			 
211a			if DEBUG_FORTH_UWORD 
211a ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
211e			endif 
211e			 
211e ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2122			 
2122			 
2122			if DEBUG_FORTH_UWORD 
2122						DMARK ":0+" 
2122 f5				push af  
2123 3a 37 21			ld a, (.dmark)  
2126 32 7a ee			ld (debug_mark),a  
2129 3a 38 21			ld a, (.dmark+1)  
212c 32 7b ee			ld (debug_mark+1),a  
212f 3a 39 21			ld a, (.dmark+2)  
2132 32 7c ee			ld (debug_mark+2),a  
2135 18 03			jr .pastdmark  
2137 ..			.dmark: db ":0+"  
213a f1			.pastdmark: pop af  
213b			endm  
# End of macro DMARK
213b				CALLMONITOR 
213b cd 39 14			call break_point_state  
213e				endm  
# End of macro CALLMONITOR
213e			endif 
213e			 
213e				STACKFRAMECHK OFF $8efe $989f 
213e				if DEBUG_STACK_IMB 
213e					if OFF 
213e						exx 
213e						ld hl, $989f 
213e						pop de   ; $989f 
213e						call cmp16 
213e						jr nz, .spnosame 
213e						ld hl, $8efe 
213e						pop de   ; $8efe 
213e						call cmp16 
213e						jr z, .spfrsame 
213e						.spnosame: call showsperror 
213e						.spfrsame: nop 
213e						exx 
213e					endif 
213e				endif 
213e			endm 
# End of macro STACKFRAMECHK
213e			 
213e c9			ret    ; dont process any remaining parser tokens as they form new word 
213f			 
213f			 
213f			 
213f			 
213f			;		NEXT 
213f			.SCOLN: 
213f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
213f 06				db OPCODE_SCOLN 
2140 8b 21			dw .DROP 
2142 02				db 2 
2143 .. 00			db ";",0           
2145			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2145					if DEBUG_FORTH_WORDS_KEY 
2145						DMARK "SCN" 
2145 f5				push af  
2146 3a 5a 21			ld a, (.dmark)  
2149 32 7a ee			ld (debug_mark),a  
214c 3a 5b 21			ld a, (.dmark+1)  
214f 32 7b ee			ld (debug_mark+1),a  
2152 3a 5c 21			ld a, (.dmark+2)  
2155 32 7c ee			ld (debug_mark+2),a  
2158 18 03			jr .pastdmark  
215a ..			.dmark: db "SCN"  
215d f1			.pastdmark: pop af  
215e			endm  
# End of macro DMARK
215e						CALLMONITOR 
215e cd 39 14			call break_point_state  
2161				endm  
# End of macro CALLMONITOR
2161					endif 
2161					FORTH_RSP_TOS 
2161 cd 84 19			call macro_forth_rsp_tos 
2164				endm 
# End of macro FORTH_RSP_TOS
2164 e5					push hl 
2165					FORTH_RSP_POP 
2165 cd 8e 19			call macro_forth_rsp_pop 
2168				endm 
# End of macro FORTH_RSP_POP
2168 e1					pop hl 
2169			;		ex de,hl 
2169 22 61 e6				ld (os_tok_ptr),hl 
216c			 
216c			if DEBUG_FORTH_UWORD 
216c						DMARK "SCL" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 7a ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 7b ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 7c ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "SCL"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185				CALLMONITOR 
2185 cd 39 14			call break_point_state  
2188				endm  
# End of macro CALLMONITOR
2188			endif 
2188					NEXTW 
2188 c3 2f 1d			jp macro_next 
218b				endm 
# End of macro NEXTW
218b			 
218b			.DROP: 
218b				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
218b 1b				db WORD_SYS_CORE+OPCODE_DROP             
218c b6 21			dw .DUP2            
218e 05				db 4 + 1 
218f .. 00			db "DROP",0              
2194				endm 
# End of macro CWHEAD
2194			; | DROP ( w -- )   drop the TOS item   | DONE 
2194					if DEBUG_FORTH_WORDS_KEY 
2194						DMARK "DRP" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 7a ee			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 7b ee			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 7c ee			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "DRP"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad						CALLMONITOR 
21ad cd 39 14			call break_point_state  
21b0				endm  
# End of macro CALLMONITOR
21b0					endif 
21b0					FORTH_DSP_POP 
21b0 cd 75 1c			call macro_forth_dsp_pop 
21b3				endm 
# End of macro FORTH_DSP_POP
21b3					NEXTW 
21b3 c3 2f 1d			jp macro_next 
21b6				endm 
# End of macro NEXTW
21b6			.DUP2: 
21b6				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21b6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21b7 fb 21			dw .DROP2            
21b9 05				db 4 + 1 
21ba .. 00			db "2DUP",0              
21bf				endm 
# End of macro CWHEAD
21bf			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21bf					if DEBUG_FORTH_WORDS_KEY 
21bf						DMARK "2DU" 
21bf f5				push af  
21c0 3a d4 21			ld a, (.dmark)  
21c3 32 7a ee			ld (debug_mark),a  
21c6 3a d5 21			ld a, (.dmark+1)  
21c9 32 7b ee			ld (debug_mark+1),a  
21cc 3a d6 21			ld a, (.dmark+2)  
21cf 32 7c ee			ld (debug_mark+2),a  
21d2 18 03			jr .pastdmark  
21d4 ..			.dmark: db "2DU"  
21d7 f1			.pastdmark: pop af  
21d8			endm  
# End of macro DMARK
21d8						CALLMONITOR 
21d8 cd 39 14			call break_point_state  
21db				endm  
# End of macro CALLMONITOR
21db					endif 
21db					FORTH_DSP_VALUEHL 
21db cd bd 1b			call macro_dsp_valuehl 
21de				endm 
# End of macro FORTH_DSP_VALUEHL
21de e5					push hl      ; 2 
21df			 
21df					FORTH_DSP_POP 
21df cd 75 1c			call macro_forth_dsp_pop 
21e2				endm 
# End of macro FORTH_DSP_POP
21e2					 
21e2					FORTH_DSP_VALUEHL 
21e2 cd bd 1b			call macro_dsp_valuehl 
21e5				endm 
# End of macro FORTH_DSP_VALUEHL
21e5			;		push hl      ; 1 
21e5			 
21e5					FORTH_DSP_POP 
21e5 cd 75 1c			call macro_forth_dsp_pop 
21e8				endm 
# End of macro FORTH_DSP_POP
21e8			 
21e8			;		pop hl       ; 1 
21e8 d1					pop de       ; 2 
21e9			 
21e9 cd c6 19				call forth_push_numhl 
21ec eb					ex de, hl 
21ed cd c6 19				call forth_push_numhl 
21f0			 
21f0					 
21f0 eb					ex de, hl 
21f1			 
21f1 cd c6 19				call forth_push_numhl 
21f4 eb					ex de, hl 
21f5 cd c6 19				call forth_push_numhl 
21f8			 
21f8			 
21f8					NEXTW 
21f8 c3 2f 1d			jp macro_next 
21fb				endm 
# End of macro NEXTW
21fb			.DROP2: 
21fb				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21fb 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21fc 2a 22			dw .SWAP2            
21fe 06				db 5 + 1 
21ff .. 00			db "2DROP",0              
2205				endm 
# End of macro CWHEAD
2205			; | 2DROP ( w w -- )    Double drop | DONE 
2205					if DEBUG_FORTH_WORDS_KEY 
2205						DMARK "2DR" 
2205 f5				push af  
2206 3a 1a 22			ld a, (.dmark)  
2209 32 7a ee			ld (debug_mark),a  
220c 3a 1b 22			ld a, (.dmark+1)  
220f 32 7b ee			ld (debug_mark+1),a  
2212 3a 1c 22			ld a, (.dmark+2)  
2215 32 7c ee			ld (debug_mark+2),a  
2218 18 03			jr .pastdmark  
221a ..			.dmark: db "2DR"  
221d f1			.pastdmark: pop af  
221e			endm  
# End of macro DMARK
221e						CALLMONITOR 
221e cd 39 14			call break_point_state  
2221				endm  
# End of macro CALLMONITOR
2221					endif 
2221					FORTH_DSP_POP 
2221 cd 75 1c			call macro_forth_dsp_pop 
2224				endm 
# End of macro FORTH_DSP_POP
2224					FORTH_DSP_POP 
2224 cd 75 1c			call macro_forth_dsp_pop 
2227				endm 
# End of macro FORTH_DSP_POP
2227					NEXTW 
2227 c3 2f 1d			jp macro_next 
222a				endm 
# End of macro NEXTW
222a			.SWAP2: 
222a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
222a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
222b 53 22			dw .AT            
222d 06				db 5 + 1 
222e .. 00			db "2SWAP",0              
2234				endm 
# End of macro CWHEAD
2234			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2234					if DEBUG_FORTH_WORDS_KEY 
2234						DMARK "2SW" 
2234 f5				push af  
2235 3a 49 22			ld a, (.dmark)  
2238 32 7a ee			ld (debug_mark),a  
223b 3a 4a 22			ld a, (.dmark+1)  
223e 32 7b ee			ld (debug_mark+1),a  
2241 3a 4b 22			ld a, (.dmark+2)  
2244 32 7c ee			ld (debug_mark+2),a  
2247 18 03			jr .pastdmark  
2249 ..			.dmark: db "2SW"  
224c f1			.pastdmark: pop af  
224d			endm  
# End of macro DMARK
224d						CALLMONITOR 
224d cd 39 14			call break_point_state  
2250				endm  
# End of macro CALLMONITOR
2250					endif 
2250					NEXTW 
2250 c3 2f 1d			jp macro_next 
2253				endm 
# End of macro NEXTW
2253			.AT: 
2253				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2253 1f				db WORD_SYS_CORE+OPCODE_AT             
2254 85 22			dw .CAT            
2256 02				db 1 + 1 
2257 .. 00			db "@",0              
2259				endm 
# End of macro CWHEAD
2259			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2259			 
2259					if DEBUG_FORTH_WORDS_KEY 
2259						DMARK "AT." 
2259 f5				push af  
225a 3a 6e 22			ld a, (.dmark)  
225d 32 7a ee			ld (debug_mark),a  
2260 3a 6f 22			ld a, (.dmark+1)  
2263 32 7b ee			ld (debug_mark+1),a  
2266 3a 70 22			ld a, (.dmark+2)  
2269 32 7c ee			ld (debug_mark+2),a  
226c 18 03			jr .pastdmark  
226e ..			.dmark: db "AT."  
2271 f1			.pastdmark: pop af  
2272			endm  
# End of macro DMARK
2272						CALLMONITOR 
2272 cd 39 14			call break_point_state  
2275				endm  
# End of macro CALLMONITOR
2275					endif 
2275			.getbyteat:	 
2275					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2275 cd bd 1b			call macro_dsp_valuehl 
2278				endm 
# End of macro FORTH_DSP_VALUEHL
2278					 
2278			;		push hl 
2278				 
2278					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2278 cd 75 1c			call macro_forth_dsp_pop 
227b				endm 
# End of macro FORTH_DSP_POP
227b			 
227b			;		pop hl 
227b			 
227b 7e					ld a, (hl) 
227c			 
227c 6f					ld l, a 
227d 26 00				ld h, 0 
227f cd c6 19				call forth_push_numhl 
2282			 
2282					NEXTW 
2282 c3 2f 1d			jp macro_next 
2285				endm 
# End of macro NEXTW
2285			.CAT: 
2285				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2285 20				db WORD_SYS_CORE+OPCODE_CAT             
2286 ae 22			dw .BANG            
2288 03				db 2 + 1 
2289 .. 00			db "C@",0              
228c				endm 
# End of macro CWHEAD
228c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
228c					if DEBUG_FORTH_WORDS_KEY 
228c						DMARK "CAA" 
228c f5				push af  
228d 3a a1 22			ld a, (.dmark)  
2290 32 7a ee			ld (debug_mark),a  
2293 3a a2 22			ld a, (.dmark+1)  
2296 32 7b ee			ld (debug_mark+1),a  
2299 3a a3 22			ld a, (.dmark+2)  
229c 32 7c ee			ld (debug_mark+2),a  
229f 18 03			jr .pastdmark  
22a1 ..			.dmark: db "CAA"  
22a4 f1			.pastdmark: pop af  
22a5			endm  
# End of macro DMARK
22a5						CALLMONITOR 
22a5 cd 39 14			call break_point_state  
22a8				endm  
# End of macro CALLMONITOR
22a8					endif 
22a8 c3 75 22				jp .getbyteat 
22ab					NEXTW 
22ab c3 2f 1d			jp macro_next 
22ae				endm 
# End of macro NEXTW
22ae			.BANG: 
22ae				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22ae 21				db WORD_SYS_CORE+OPCODE_BANG             
22af e4 22			dw .CBANG            
22b1 02				db 1 + 1 
22b2 .. 00			db "!",0              
22b4				endm 
# End of macro CWHEAD
22b4			; | ! ( x w -- ) Store x at address w      | DONE 
22b4					if DEBUG_FORTH_WORDS_KEY 
22b4						DMARK "BNG" 
22b4 f5				push af  
22b5 3a c9 22			ld a, (.dmark)  
22b8 32 7a ee			ld (debug_mark),a  
22bb 3a ca 22			ld a, (.dmark+1)  
22be 32 7b ee			ld (debug_mark+1),a  
22c1 3a cb 22			ld a, (.dmark+2)  
22c4 32 7c ee			ld (debug_mark+2),a  
22c7 18 03			jr .pastdmark  
22c9 ..			.dmark: db "BNG"  
22cc f1			.pastdmark: pop af  
22cd			endm  
# End of macro DMARK
22cd						CALLMONITOR 
22cd cd 39 14			call break_point_state  
22d0				endm  
# End of macro CALLMONITOR
22d0					endif 
22d0			 
22d0			.storebyteat:		 
22d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22d0 cd bd 1b			call macro_dsp_valuehl 
22d3				endm 
# End of macro FORTH_DSP_VALUEHL
22d3					 
22d3 e5					push hl 
22d4				 
22d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22d4 cd 75 1c			call macro_forth_dsp_pop 
22d7				endm 
# End of macro FORTH_DSP_POP
22d7			 
22d7					; get byte to poke 
22d7			 
22d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22d7 cd bd 1b			call macro_dsp_valuehl 
22da				endm 
# End of macro FORTH_DSP_VALUEHL
22da e5					push hl 
22db			 
22db			 
22db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22db cd 75 1c			call macro_forth_dsp_pop 
22de				endm 
# End of macro FORTH_DSP_POP
22de			 
22de			 
22de d1					pop de 
22df e1					pop hl 
22e0			 
22e0 73					ld (hl),e 
22e1			 
22e1			 
22e1					NEXTW 
22e1 c3 2f 1d			jp macro_next 
22e4				endm 
# End of macro NEXTW
22e4			.CBANG: 
22e4				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22e4 22				db WORD_SYS_CORE+OPCODE_CBANG             
22e5 0d 23			dw .SCALL            
22e7 03				db 2 + 1 
22e8 .. 00			db "C!",0              
22eb				endm 
# End of macro CWHEAD
22eb			; | C!  ( x w -- ) Store x at address w  | DONE 
22eb					if DEBUG_FORTH_WORDS_KEY 
22eb						DMARK "CBA" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 7a ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 7b ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 7c ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db "CBA"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304						CALLMONITOR 
2304 cd 39 14			call break_point_state  
2307				endm  
# End of macro CALLMONITOR
2307					endif 
2307 c3 d0 22				jp .storebyteat 
230a					NEXTW 
230a c3 2f 1d			jp macro_next 
230d				endm 
# End of macro NEXTW
230d			.SCALL: 
230d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
230d 23				db WORD_SYS_CORE+OPCODE_SCALL             
230e 41 23			dw .DEPTH            
2310 05				db 4 + 1 
2311 .. 00			db "CALL",0              
2316				endm 
# End of macro CWHEAD
2316			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2316					if DEBUG_FORTH_WORDS_KEY 
2316						DMARK "CLL" 
2316 f5				push af  
2317 3a 2b 23			ld a, (.dmark)  
231a 32 7a ee			ld (debug_mark),a  
231d 3a 2c 23			ld a, (.dmark+1)  
2320 32 7b ee			ld (debug_mark+1),a  
2323 3a 2d 23			ld a, (.dmark+2)  
2326 32 7c ee			ld (debug_mark+2),a  
2329 18 03			jr .pastdmark  
232b ..			.dmark: db "CLL"  
232e f1			.pastdmark: pop af  
232f			endm  
# End of macro DMARK
232f						CALLMONITOR 
232f cd 39 14			call break_point_state  
2332				endm  
# End of macro CALLMONITOR
2332					endif 
2332			 
2332					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2332 cd bd 1b			call macro_dsp_valuehl 
2335				endm 
# End of macro FORTH_DSP_VALUEHL
2335			 
2335			;		push hl 
2335			 
2335					; destroy value TOS 
2335			 
2335					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2335 cd 75 1c			call macro_forth_dsp_pop 
2338				endm 
# End of macro FORTH_DSP_POP
2338			 
2338						 
2338			;		pop hl 
2338			 
2338					; how to do a call with hl???? save SP? 
2338 cd d8 1c				call forth_call_hl 
233b			 
233b			 
233b					; TODO push value back onto stack for another op etc 
233b			 
233b cd c6 19				call forth_push_numhl 
233e					NEXTW 
233e c3 2f 1d			jp macro_next 
2341				endm 
# End of macro NEXTW
2341			.DEPTH: 
2341				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2341 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2342 7e 23			dw .OVER            
2344 06				db 5 + 1 
2345 .. 00			db "DEPTH",0              
234b				endm 
# End of macro CWHEAD
234b			; | DEPTH ( -- u ) Push count of stack | DONE 
234b					; take current TOS and remove from base value div by two to get count 
234b					if DEBUG_FORTH_WORDS_KEY 
234b						DMARK "DEP" 
234b f5				push af  
234c 3a 60 23			ld a, (.dmark)  
234f 32 7a ee			ld (debug_mark),a  
2352 3a 61 23			ld a, (.dmark+1)  
2355 32 7b ee			ld (debug_mark+1),a  
2358 3a 62 23			ld a, (.dmark+2)  
235b 32 7c ee			ld (debug_mark+2),a  
235e 18 03			jr .pastdmark  
2360 ..			.dmark: db "DEP"  
2363 f1			.pastdmark: pop af  
2364			endm  
# End of macro DMARK
2364						CALLMONITOR 
2364 cd 39 14			call break_point_state  
2367				endm  
# End of macro CALLMONITOR
2367					endif 
2367			 
2367			 
2367 2a 0d eb			ld hl, (cli_data_sp) 
236a 11 c7 e8			ld de, cli_data_stack 
236d ed 52			sbc hl,de 
236f				 
236f				; div by size of stack item 
236f			 
236f 5d				ld e,l 
2370 0e 03			ld c, 3 
2372 cd 56 0b			call Div8 
2375			 
2375 6f				ld l,a 
2376 26 00			ld h,0 
2378			 
2378				;srl h 
2378				;rr l 
2378			 
2378 cd c6 19				call forth_push_numhl 
237b					NEXTW 
237b c3 2f 1d			jp macro_next 
237e				endm 
# End of macro NEXTW
237e			.OVER: 
237e				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
237e 42				db WORD_SYS_CORE+46             
237f c5 23			dw .PAUSE            
2381 05				db 4 + 1 
2382 .. 00			db "OVER",0              
2387				endm 
# End of macro CWHEAD
2387			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2387					if DEBUG_FORTH_WORDS_KEY 
2387						DMARK "OVR" 
2387 f5				push af  
2388 3a 9c 23			ld a, (.dmark)  
238b 32 7a ee			ld (debug_mark),a  
238e 3a 9d 23			ld a, (.dmark+1)  
2391 32 7b ee			ld (debug_mark+1),a  
2394 3a 9e 23			ld a, (.dmark+2)  
2397 32 7c ee			ld (debug_mark+2),a  
239a 18 03			jr .pastdmark  
239c ..			.dmark: db "OVR"  
239f f1			.pastdmark: pop af  
23a0			endm  
# End of macro DMARK
23a0						CALLMONITOR 
23a0 cd 39 14			call break_point_state  
23a3				endm  
# End of macro CALLMONITOR
23a3					endif 
23a3			 
23a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23a3 cd bd 1b			call macro_dsp_valuehl 
23a6				endm 
# End of macro FORTH_DSP_VALUEHL
23a6 e5					push hl    ; n2 
23a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23a7 cd 75 1c			call macro_forth_dsp_pop 
23aa				endm 
# End of macro FORTH_DSP_POP
23aa			 
23aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23aa cd bd 1b			call macro_dsp_valuehl 
23ad				endm 
# End of macro FORTH_DSP_VALUEHL
23ad e5					push hl    ; n1 
23ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ae cd 75 1c			call macro_forth_dsp_pop 
23b1				endm 
# End of macro FORTH_DSP_POP
23b1			 
23b1 d1					pop de     ; n1 
23b2 e1					pop hl     ; n2 
23b3			 
23b3 d5					push de 
23b4 e5					push hl 
23b5 d5					push de 
23b6			 
23b6					; push back  
23b6			 
23b6 e1					pop hl 
23b7 cd c6 19				call forth_push_numhl 
23ba e1					pop hl 
23bb cd c6 19				call forth_push_numhl 
23be e1					pop hl 
23bf cd c6 19				call forth_push_numhl 
23c2					NEXTW 
23c2 c3 2f 1d			jp macro_next 
23c5				endm 
# End of macro NEXTW
23c5			 
23c5			.PAUSE: 
23c5				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
23c5 43				db WORD_SYS_CORE+47             
23c6 fa 23			dw .PAUSES            
23c8 08				db 7 + 1 
23c9 .. 00			db "PAUSEMS",0              
23d1				endm 
# End of macro CWHEAD
23d1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
23d1					if DEBUG_FORTH_WORDS_KEY 
23d1						DMARK "PMS" 
23d1 f5				push af  
23d2 3a e6 23			ld a, (.dmark)  
23d5 32 7a ee			ld (debug_mark),a  
23d8 3a e7 23			ld a, (.dmark+1)  
23db 32 7b ee			ld (debug_mark+1),a  
23de 3a e8 23			ld a, (.dmark+2)  
23e1 32 7c ee			ld (debug_mark+2),a  
23e4 18 03			jr .pastdmark  
23e6 ..			.dmark: db "PMS"  
23e9 f1			.pastdmark: pop af  
23ea			endm  
# End of macro DMARK
23ea						CALLMONITOR 
23ea cd 39 14			call break_point_state  
23ed				endm  
# End of macro CALLMONITOR
23ed					endif 
23ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ed cd bd 1b			call macro_dsp_valuehl 
23f0				endm 
# End of macro FORTH_DSP_VALUEHL
23f0			;		push hl    ; n2 
23f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23f0 cd 75 1c			call macro_forth_dsp_pop 
23f3				endm 
# End of macro FORTH_DSP_POP
23f3			;		pop hl 
23f3			 
23f3 7d					ld a, l 
23f4 cd f3 08				call aDelayInMS 
23f7				       NEXTW 
23f7 c3 2f 1d			jp macro_next 
23fa				endm 
# End of macro NEXTW
23fa			.PAUSES:  
23fa				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23fa 44				db WORD_SYS_CORE+48             
23fb 69 24			dw .ROT            
23fd 06				db 5 + 1 
23fe .. 00			db "PAUSE",0              
2404				endm 
# End of macro CWHEAD
2404			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2404					if DEBUG_FORTH_WORDS_KEY 
2404						DMARK "PAU" 
2404 f5				push af  
2405 3a 19 24			ld a, (.dmark)  
2408 32 7a ee			ld (debug_mark),a  
240b 3a 1a 24			ld a, (.dmark+1)  
240e 32 7b ee			ld (debug_mark+1),a  
2411 3a 1b 24			ld a, (.dmark+2)  
2414 32 7c ee			ld (debug_mark+2),a  
2417 18 03			jr .pastdmark  
2419 ..			.dmark: db "PAU"  
241c f1			.pastdmark: pop af  
241d			endm  
# End of macro DMARK
241d						CALLMONITOR 
241d cd 39 14			call break_point_state  
2420				endm  
# End of macro CALLMONITOR
2420					endif 
2420					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2420 cd bd 1b			call macro_dsp_valuehl 
2423				endm 
# End of macro FORTH_DSP_VALUEHL
2423			;		push hl    ; n2 
2423					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2423 cd 75 1c			call macro_forth_dsp_pop 
2426				endm 
# End of macro FORTH_DSP_POP
2426			;		pop hl 
2426 45					ld b, l 
2427					if DEBUG_FORTH_WORDS 
2427						DMARK "PAU" 
2427 f5				push af  
2428 3a 3c 24			ld a, (.dmark)  
242b 32 7a ee			ld (debug_mark),a  
242e 3a 3d 24			ld a, (.dmark+1)  
2431 32 7b ee			ld (debug_mark+1),a  
2434 3a 3e 24			ld a, (.dmark+2)  
2437 32 7c ee			ld (debug_mark+2),a  
243a 18 03			jr .pastdmark  
243c ..			.dmark: db "PAU"  
243f f1			.pastdmark: pop af  
2440			endm  
# End of macro DMARK
2440						CALLMONITOR 
2440 cd 39 14			call break_point_state  
2443				endm  
# End of macro CALLMONITOR
2443					endif 
2443 c5			.pauses1:	push bc 
2444 cd 0e 09				call delay1s 
2447 c1					pop bc 
2448					if DEBUG_FORTH_WORDS 
2448						DMARK "PA1" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 7a ee			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 7b ee			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 7c ee			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "PA1"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461						CALLMONITOR 
2461 cd 39 14			call break_point_state  
2464				endm  
# End of macro CALLMONITOR
2464					endif 
2464 10 dd				djnz .pauses1 
2466			 
2466				       NEXTW 
2466 c3 2f 1d			jp macro_next 
2469				endm 
# End of macro NEXTW
2469			.ROT: 
2469				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2469 45				db WORD_SYS_CORE+49             
246a b7 24			dw .UWORDS            
246c 04				db 3 + 1 
246d .. 00			db "ROT",0              
2471				endm 
# End of macro CWHEAD
2471			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2471					if DEBUG_FORTH_WORDS_KEY 
2471						DMARK "ROT" 
2471 f5				push af  
2472 3a 86 24			ld a, (.dmark)  
2475 32 7a ee			ld (debug_mark),a  
2478 3a 87 24			ld a, (.dmark+1)  
247b 32 7b ee			ld (debug_mark+1),a  
247e 3a 88 24			ld a, (.dmark+2)  
2481 32 7c ee			ld (debug_mark+2),a  
2484 18 03			jr .pastdmark  
2486 ..			.dmark: db "ROT"  
2489 f1			.pastdmark: pop af  
248a			endm  
# End of macro DMARK
248a						CALLMONITOR 
248a cd 39 14			call break_point_state  
248d				endm  
# End of macro CALLMONITOR
248d					endif 
248d			 
248d					FORTH_DSP_VALUEHL 
248d cd bd 1b			call macro_dsp_valuehl 
2490				endm 
# End of macro FORTH_DSP_VALUEHL
2490 e5					push hl    ; u3  
2491			 
2491					FORTH_DSP_POP 
2491 cd 75 1c			call macro_forth_dsp_pop 
2494				endm 
# End of macro FORTH_DSP_POP
2494			   
2494					FORTH_DSP_VALUEHL 
2494 cd bd 1b			call macro_dsp_valuehl 
2497				endm 
# End of macro FORTH_DSP_VALUEHL
2497 e5					push hl     ; u2 
2498			 
2498					FORTH_DSP_POP 
2498 cd 75 1c			call macro_forth_dsp_pop 
249b				endm 
# End of macro FORTH_DSP_POP
249b			 
249b					FORTH_DSP_VALUEHL 
249b cd bd 1b			call macro_dsp_valuehl 
249e				endm 
# End of macro FORTH_DSP_VALUEHL
249e e5					push hl     ; u1 
249f			 
249f					FORTH_DSP_POP 
249f cd 75 1c			call macro_forth_dsp_pop 
24a2				endm 
# End of macro FORTH_DSP_POP
24a2			 
24a2 c1					pop bc      ; u1 
24a3 e1					pop hl      ; u2 
24a4 d1					pop de      ; u3 
24a5			 
24a5			 
24a5 c5					push bc 
24a6 d5					push de 
24a7 e5					push hl 
24a8			 
24a8			 
24a8 e1					pop hl 
24a9 cd c6 19				call forth_push_numhl 
24ac			 
24ac e1					pop hl 
24ad cd c6 19				call forth_push_numhl 
24b0			 
24b0 e1					pop hl 
24b1 cd c6 19				call forth_push_numhl 
24b4					 
24b4			 
24b4			 
24b4			 
24b4			 
24b4			 
24b4				       NEXTW 
24b4 c3 2f 1d			jp macro_next 
24b7				endm 
# End of macro NEXTW
24b7			 
24b7			.UWORDS: 
24b7				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24b7 50				db WORD_SYS_CORE+60             
24b8 79 25			dw .BP            
24ba 07				db 6 + 1 
24bb .. 00			db "UWORDS",0              
24c2				endm 
# End of macro CWHEAD
24c2			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
24c2			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
24c2			; | | Following the count are the individual words. 
24c2			; | | 
24c2			; | | e.g. UWORDS 
24c2			; | | BOX DIRLIST 2 
24c2			; | |  
24c2			; | | Can be used to save the words to storage via: 
24c2			; | | UWORDS $01 DO $01 APPEND LOOP 
24c2				if DEBUG_FORTH_WORDS_KEY 
24c2					DMARK "UWR" 
24c2 f5				push af  
24c3 3a d7 24			ld a, (.dmark)  
24c6 32 7a ee			ld (debug_mark),a  
24c9 3a d8 24			ld a, (.dmark+1)  
24cc 32 7b ee			ld (debug_mark+1),a  
24cf 3a d9 24			ld a, (.dmark+2)  
24d2 32 7c ee			ld (debug_mark+2),a  
24d5 18 03			jr .pastdmark  
24d7 ..			.dmark: db "UWR"  
24da f1			.pastdmark: pop af  
24db			endm  
# End of macro DMARK
24db					CALLMONITOR 
24db cd 39 14			call break_point_state  
24de				endm  
# End of macro CALLMONITOR
24de				endif 
24de 21 e7 58				ld hl, baseram 
24e1					;ld hl, baseusermem 
24e1 01 00 00				ld bc, 0    ; start a counter 
24e4			 
24e4				; skip dict stub 
24e4			 
24e4 cd 80 1e				call forth_tok_next 
24e7			 
24e7			 
24e7			; while we have words to look for 
24e7			 
24e7 7e			.douscan:	ld a, (hl)      
24e8				if DEBUG_FORTH_WORDS 
24e8					DMARK "UWs" 
24e8 f5				push af  
24e9 3a fd 24			ld a, (.dmark)  
24ec 32 7a ee			ld (debug_mark),a  
24ef 3a fe 24			ld a, (.dmark+1)  
24f2 32 7b ee			ld (debug_mark+1),a  
24f5 3a ff 24			ld a, (.dmark+2)  
24f8 32 7c ee			ld (debug_mark+2),a  
24fb 18 03			jr .pastdmark  
24fd ..			.dmark: db "UWs"  
2500 f1			.pastdmark: pop af  
2501			endm  
# End of macro DMARK
2501					CALLMONITOR 
2501 cd 39 14			call break_point_state  
2504				endm  
# End of macro CALLMONITOR
2504				endif 
2504 fe 00				cp WORD_SYS_END 
2506 28 4d				jr z, .udone 
2508 fe 01				cp WORD_SYS_UWORD 
250a 20 44				jr nz, .nuword 
250c			 
250c				if DEBUG_FORTH_WORDS 
250c					DMARK "UWu" 
250c f5				push af  
250d 3a 21 25			ld a, (.dmark)  
2510 32 7a ee			ld (debug_mark),a  
2513 3a 22 25			ld a, (.dmark+1)  
2516 32 7b ee			ld (debug_mark+1),a  
2519 3a 23 25			ld a, (.dmark+2)  
251c 32 7c ee			ld (debug_mark+2),a  
251f 18 03			jr .pastdmark  
2521 ..			.dmark: db "UWu"  
2524 f1			.pastdmark: pop af  
2525			endm  
# End of macro DMARK
2525					CALLMONITOR 
2525 cd 39 14			call break_point_state  
2528				endm  
# End of macro CALLMONITOR
2528				endif 
2528					; we have a uword so push its name to the stack 
2528			 
2528 e5				   	push hl  ; save so we can move to next dict block 
2529			 
2529					; skip opcode 
2529 23					inc hl  
252a					; skip next ptr 
252a 23					inc hl  
252b 23					inc hl 
252c					; skip len 
252c 23					inc hl 
252d				if DEBUG_FORTH_WORDS 
252d					DMARK "UWt" 
252d f5				push af  
252e 3a 42 25			ld a, (.dmark)  
2531 32 7a ee			ld (debug_mark),a  
2534 3a 43 25			ld a, (.dmark+1)  
2537 32 7b ee			ld (debug_mark+1),a  
253a 3a 44 25			ld a, (.dmark+2)  
253d 32 7c ee			ld (debug_mark+2),a  
2540 18 03			jr .pastdmark  
2542 ..			.dmark: db "UWt"  
2545 f1			.pastdmark: pop af  
2546			endm  
# End of macro DMARK
2546					CALLMONITOR 
2546 cd 39 14			call break_point_state  
2549				endm  
# End of macro CALLMONITOR
2549				endif 
2549 03					inc bc 
254a			 
254a c5					push bc 
254b cd 34 1a				call forth_push_str 
254e c1					pop bc 
254f			 
254f e1					pop hl 	 
2550			 
2550 cd 80 1e		.nuword:	call forth_tok_next 
2553 18 92				jr .douscan  
2555			 
2555			.udone:		 ; push count of uwords found 
2555 c5					push bc 
2556 e1					pop hl 
2557			 
2557				if DEBUG_FORTH_WORDS 
2557					DMARK "UWc" 
2557 f5				push af  
2558 3a 6c 25			ld a, (.dmark)  
255b 32 7a ee			ld (debug_mark),a  
255e 3a 6d 25			ld a, (.dmark+1)  
2561 32 7b ee			ld (debug_mark+1),a  
2564 3a 6e 25			ld a, (.dmark+2)  
2567 32 7c ee			ld (debug_mark+2),a  
256a 18 03			jr .pastdmark  
256c ..			.dmark: db "UWc"  
256f f1			.pastdmark: pop af  
2570			endm  
# End of macro DMARK
2570					CALLMONITOR 
2570 cd 39 14			call break_point_state  
2573				endm  
# End of macro CALLMONITOR
2573				endif 
2573 cd c6 19				call forth_push_numhl 
2576			 
2576			 
2576				       NEXTW 
2576 c3 2f 1d			jp macro_next 
2579				endm 
# End of macro NEXTW
2579			 
2579			.BP: 
2579				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2579 54				db WORD_SYS_CORE+64             
257a af 25			dw .MONITOR            
257c 03				db 2 + 1 
257d .. 00			db "BP",0              
2580				endm 
# End of macro CWHEAD
2580			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2580			; | | $00 Will enable the break points within specific code paths 
2580			; | | $01 Will disable break points 
2580			; | |  
2580			; | | By default break points are off. Either the above can be used to enable them 
2580			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2580			; | | and on release of the pressed key a message will be disaplayed to notify 
2580			; | | that break points are enabled. Pressing any key will then continue boot process. 
2580					; get byte count 
2580					if DEBUG_FORTH_WORDS_KEY 
2580						DMARK "BP." 
2580 f5				push af  
2581 3a 95 25			ld a, (.dmark)  
2584 32 7a ee			ld (debug_mark),a  
2587 3a 96 25			ld a, (.dmark+1)  
258a 32 7b ee			ld (debug_mark+1),a  
258d 3a 97 25			ld a, (.dmark+2)  
2590 32 7c ee			ld (debug_mark+2),a  
2593 18 03			jr .pastdmark  
2595 ..			.dmark: db "BP."  
2598 f1			.pastdmark: pop af  
2599			endm  
# End of macro DMARK
2599						CALLMONITOR 
2599 cd 39 14			call break_point_state  
259c				endm  
# End of macro CALLMONITOR
259c					endif 
259c			 
259c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259c cd bd 1b			call macro_dsp_valuehl 
259f				endm 
# End of macro FORTH_DSP_VALUEHL
259f			 
259f			;		push hl 
259f			 
259f					; destroy value TOS 
259f			 
259f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259f cd 75 1c			call macro_forth_dsp_pop 
25a2				endm 
# End of macro FORTH_DSP_POP
25a2			 
25a2			;		pop hl 
25a2			 
25a2 3e 00				ld a,0 
25a4 bd					cp l 
25a5 28 02				jr z, .bpset 
25a7 3e 2a				ld a, '*' 
25a9			 
25a9 32 51 e3		.bpset:		ld (os_view_disable), a 
25ac			 
25ac			 
25ac					NEXTW 
25ac c3 2f 1d			jp macro_next 
25af				endm 
# End of macro NEXTW
25af			 
25af			 
25af			.MONITOR: 
25af				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25af 55				db WORD_SYS_CORE+65             
25b0 e2 25			dw .MALLOC            
25b2 08				db 7 + 1 
25b3 .. 00			db "MONITOR",0              
25bb				endm 
# End of macro CWHEAD
25bb			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25bb			; | | At start the current various registers will be displayed with contents. 
25bb			; | | Top right corner will show the most recent debug marker seen. 
25bb			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25bb			; | | and the return stack pointer (RSP). 
25bb			; | | Pressing: 
25bb			; | |    1 - Initial screen 
25bb			; | |    2 - Display a data dump of HL 
25bb			; | |    3 - Display a data dump of DE 
25bb			; | |    4 - Display a data dump of BC 
25bb			; | |    5 - Display a data dump of HL 
25bb			; | |    6 - Display a data dump of DSP 
25bb			; | |    7 - Display a data dump of RSP 
25bb			; | |    8 - Display a data dump of what is at DSP 
25bb			; | |    9 - Display a data dump of what is at RSP 
25bb			; | |    0 - Exit monitor and continue running. This will also enable break points 
25bb			; | |    * - Disable break points 
25bb			; | |    # - Enter traditional monitor mode 
25bb			; | | 
25bb			; | | Monitor Mode 
25bb			; | | ------------ 
25bb			; | | A prompt of '>' will be shown for various commands: 
25bb			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25bb			; | |    C - Continue display a data dump from the last set address 
25bb			; | |    M xxxx - Set start of memory edit at address xx 
25bb			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25bb			; | |    Q - Return to previous 
25bb					if DEBUG_FORTH_WORDS_KEY 
25bb						DMARK "MON" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 7a ee			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 7b ee			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 7c ee			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "MON"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4						CALLMONITOR 
25d4 cd 39 14			call break_point_state  
25d7				endm  
# End of macro CALLMONITOR
25d7					endif 
25d7 3e 00				ld a, 0 
25d9 32 51 e3				ld (os_view_disable), a 
25dc			 
25dc					CALLMONITOR 
25dc cd 39 14			call break_point_state  
25df				endm  
# End of macro CALLMONITOR
25df			 
25df			;	call monitor 
25df			 
25df					NEXTW 
25df c3 2f 1d			jp macro_next 
25e2				endm 
# End of macro NEXTW
25e2			 
25e2			 
25e2			.MALLOC: 
25e2				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25e2 56				db WORD_SYS_CORE+66             
25e3 0b 26			dw .MALLOC2            
25e5 06				db 5 + 1 
25e6 .. 00			db "ALLOT",0              
25ec				endm 
# End of macro CWHEAD
25ec			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25ec					if DEBUG_FORTH_WORDS_KEY 
25ec						DMARK "ALL" 
25ec f5				push af  
25ed 3a 01 26			ld a, (.dmark)  
25f0 32 7a ee			ld (debug_mark),a  
25f3 3a 02 26			ld a, (.dmark+1)  
25f6 32 7b ee			ld (debug_mark+1),a  
25f9 3a 03 26			ld a, (.dmark+2)  
25fc 32 7c ee			ld (debug_mark+2),a  
25ff 18 03			jr .pastdmark  
2601 ..			.dmark: db "ALL"  
2604 f1			.pastdmark: pop af  
2605			endm  
# End of macro DMARK
2605						CALLMONITOR 
2605 cd 39 14			call break_point_state  
2608				endm  
# End of macro CALLMONITOR
2608					endif 
2608 c3 32 26				jp .mallocc 
260b			.MALLOC2: 
260b				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
260b 56				db WORD_SYS_CORE+66             
260c 49 26			dw .FREE            
260e 07				db 6 + 1 
260f .. 00			db "MALLOC",0              
2616				endm 
# End of macro CWHEAD
2616			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2616					; get byte count 
2616					if DEBUG_FORTH_WORDS_KEY 
2616						DMARK "MAL" 
2616 f5				push af  
2617 3a 2b 26			ld a, (.dmark)  
261a 32 7a ee			ld (debug_mark),a  
261d 3a 2c 26			ld a, (.dmark+1)  
2620 32 7b ee			ld (debug_mark+1),a  
2623 3a 2d 26			ld a, (.dmark+2)  
2626 32 7c ee			ld (debug_mark+2),a  
2629 18 03			jr .pastdmark  
262b ..			.dmark: db "MAL"  
262e f1			.pastdmark: pop af  
262f			endm  
# End of macro DMARK
262f						CALLMONITOR 
262f cd 39 14			call break_point_state  
2632				endm  
# End of macro CALLMONITOR
2632					endif 
2632			.mallocc: 
2632					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2632 cd bd 1b			call macro_dsp_valuehl 
2635				endm 
# End of macro FORTH_DSP_VALUEHL
2635			 
2635			;		push hl 
2635			 
2635					; destroy value TOS 
2635			 
2635					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2635 cd 75 1c			call macro_forth_dsp_pop 
2638				endm 
# End of macro FORTH_DSP_POP
2638			 
2638			;		pop hl 
2638 cd 8d 10				call malloc 
263b				if DEBUG_FORTH_MALLOC_GUARD 
263b f5					push af 
263c cd ef 0b				call ishlzero 
263f			;		ld a, l 
263f			;		add h 
263f			;		cp 0 
263f f1					pop af 
2640					 
2640 cc 44 45				call z,malloc_error 
2643				endif 
2643			 
2643 cd c6 19				call forth_push_numhl 
2646					NEXTW 
2646 c3 2f 1d			jp macro_next 
2649				endm 
# End of macro NEXTW
2649			 
2649			.FREE: 
2649				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2649 57				db WORD_SYS_CORE+67             
264a 7a 26			dw .LIST            
264c 05				db 4 + 1 
264d .. 00			db "FREE",0              
2652				endm 
# End of macro CWHEAD
2652			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2652					if DEBUG_FORTH_WORDS_KEY 
2652						DMARK "FRE" 
2652 f5				push af  
2653 3a 67 26			ld a, (.dmark)  
2656 32 7a ee			ld (debug_mark),a  
2659 3a 68 26			ld a, (.dmark+1)  
265c 32 7b ee			ld (debug_mark+1),a  
265f 3a 69 26			ld a, (.dmark+2)  
2662 32 7c ee			ld (debug_mark+2),a  
2665 18 03			jr .pastdmark  
2667 ..			.dmark: db "FRE"  
266a f1			.pastdmark: pop af  
266b			endm  
# End of macro DMARK
266b						CALLMONITOR 
266b cd 39 14			call break_point_state  
266e				endm  
# End of macro CALLMONITOR
266e					endif 
266e					; get address 
266e			 
266e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266e cd bd 1b			call macro_dsp_valuehl 
2671				endm 
# End of macro FORTH_DSP_VALUEHL
2671			 
2671			;		push hl 
2671			 
2671					; destroy value TOS 
2671			 
2671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2671 cd 75 1c			call macro_forth_dsp_pop 
2674				endm 
# End of macro FORTH_DSP_POP
2674			 
2674			;		pop hl 
2674			if FORTH_ENABLE_MALLOCFREE 
2674 cd 57 11				call free 
2677			endif 
2677					NEXTW 
2677 c3 2f 1d			jp macro_next 
267a				endm 
# End of macro NEXTW
267a			.LIST: 
267a				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
267a 5c				db WORD_SYS_CORE+72             
267b 68 28			dw .FORGET            
267d 05				db 4 + 1 
267e .. 00			db "LIST",0              
2683				endm 
# End of macro CWHEAD
2683			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2683			; | | The quoted word must be in upper case. 
2683				if DEBUG_FORTH_WORDS_KEY 
2683					DMARK "LST" 
2683 f5				push af  
2684 3a 98 26			ld a, (.dmark)  
2687 32 7a ee			ld (debug_mark),a  
268a 3a 99 26			ld a, (.dmark+1)  
268d 32 7b ee			ld (debug_mark+1),a  
2690 3a 9a 26			ld a, (.dmark+2)  
2693 32 7c ee			ld (debug_mark+2),a  
2696 18 03			jr .pastdmark  
2698 ..			.dmark: db "LST"  
269b f1			.pastdmark: pop af  
269c			endm  
# End of macro DMARK
269c					CALLMONITOR 
269c cd 39 14			call break_point_state  
269f				endm  
# End of macro CALLMONITOR
269f				endif 
269f			 
269f					FORTH_DSP_VALUEHL 
269f cd bd 1b			call macro_dsp_valuehl 
26a2				endm 
# End of macro FORTH_DSP_VALUEHL
26a2			 
26a2 e5					push hl 
26a3					FORTH_DSP_POP 
26a3 cd 75 1c			call macro_forth_dsp_pop 
26a6				endm 
# End of macro FORTH_DSP_POP
26a6 c1					pop bc 
26a7			 
26a7			; Start format of scratch string 
26a7			 
26a7 21 60 e3				ld hl, scratch 
26aa			 
26aa 3e 3a				ld a, ':' 
26ac 77					ld (hl),a 
26ad 23					inc hl 
26ae 3e 20				ld a, ' ' 
26b0 77					ld (hl), a 
26b1			 
26b1					; Get ptr to the word we need to look up 
26b1			 
26b1			;		FORTH_DSP_VALUEHL 
26b1					;v5 FORTH_DSP_VALUE 
26b1				; TODO type check 
26b1			;		inc hl    ; Skip type check  
26b1			;		push hl 
26b1			;		ex de, hl    ; put into DE 
26b1			 
26b1			 
26b1 21 e7 58				ld hl, baseram 
26b4					;ld hl, baseusermem 
26b4			 
26b4 e5			push hl   ; sacreifical push 
26b5			 
26b5			.ldouscanm: 
26b5 e1				pop hl 
26b6			.ldouscan: 
26b6				if DEBUG_FORTH_WORDS 
26b6					DMARK "LSs" 
26b6 f5				push af  
26b7 3a cb 26			ld a, (.dmark)  
26ba 32 7a ee			ld (debug_mark),a  
26bd 3a cc 26			ld a, (.dmark+1)  
26c0 32 7b ee			ld (debug_mark+1),a  
26c3 3a cd 26			ld a, (.dmark+2)  
26c6 32 7c ee			ld (debug_mark+2),a  
26c9 18 03			jr .pastdmark  
26cb ..			.dmark: db "LSs"  
26ce f1			.pastdmark: pop af  
26cf			endm  
# End of macro DMARK
26cf					CALLMONITOR 
26cf cd 39 14			call break_point_state  
26d2				endm  
# End of macro CALLMONITOR
26d2				endif 
26d2				; skip dict stub 
26d2 cd 80 1e				call forth_tok_next 
26d5			 
26d5			 
26d5			; while we have words to look for 
26d5			 
26d5 7e				ld a, (hl)      
26d6				if DEBUG_FORTH_WORDS 
26d6					DMARK "LSk" 
26d6 f5				push af  
26d7 3a eb 26			ld a, (.dmark)  
26da 32 7a ee			ld (debug_mark),a  
26dd 3a ec 26			ld a, (.dmark+1)  
26e0 32 7b ee			ld (debug_mark+1),a  
26e3 3a ed 26			ld a, (.dmark+2)  
26e6 32 7c ee			ld (debug_mark+2),a  
26e9 18 03			jr .pastdmark  
26eb ..			.dmark: db "LSk"  
26ee f1			.pastdmark: pop af  
26ef			endm  
# End of macro DMARK
26ef					CALLMONITOR 
26ef cd 39 14			call break_point_state  
26f2				endm  
# End of macro CALLMONITOR
26f2				endif 
26f2					;cp WORD_SYS_END 
26f2					;jp z, .lunotfound 
26f2			 
26f2					; if we hit non uwords then gone too far 
26f2 fe 01				cp WORD_SYS_UWORD 
26f4 c2 24 28				jp nz, .lunotfound 
26f7			 
26f7				if DEBUG_FORTH_WORDS 
26f7					DMARK "LSu" 
26f7 f5				push af  
26f8 3a 0c 27			ld a, (.dmark)  
26fb 32 7a ee			ld (debug_mark),a  
26fe 3a 0d 27			ld a, (.dmark+1)  
2701 32 7b ee			ld (debug_mark+1),a  
2704 3a 0e 27			ld a, (.dmark+2)  
2707 32 7c ee			ld (debug_mark+2),a  
270a 18 03			jr .pastdmark  
270c ..			.dmark: db "LSu"  
270f f1			.pastdmark: pop af  
2710			endm  
# End of macro DMARK
2710					CALLMONITOR 
2710 cd 39 14			call break_point_state  
2713				endm  
# End of macro CALLMONITOR
2713				endif 
2713			 
2713					; found a uword but is it the one we want... 
2713			 
2713 c5					push bc     ; uword to find is on bc 
2714 d1					pop de 
2715			 
2715 e5					push hl  ; to save the ptr 
2716			 
2716					; skip opcode 
2716 23					inc hl  
2717					; skip next ptr 
2717 23					inc hl  
2718 23					inc hl 
2719					; skip len 
2719 23					inc hl 
271a			 
271a				if DEBUG_FORTH_WORDS 
271a					DMARK "LSc" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 7a ee			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 7b ee			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 7c ee			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "LSc"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733					CALLMONITOR 
2733 cd 39 14			call break_point_state  
2736				endm  
# End of macro CALLMONITOR
2736				endif 
2736 cd 5c 10				call strcmp 
2739 c2 b5 26				jp nz, .ldouscanm 
273c				 
273c			 
273c			 
273c					; we have a uword so push its name to the stack 
273c			 
273c			;	   	push hl  ; save so we can move to next dict block 
273c e1			pop hl 
273d			 
273d				if DEBUG_FORTH_WORDS 
273d					DMARK "LSm" 
273d f5				push af  
273e 3a 52 27			ld a, (.dmark)  
2741 32 7a ee			ld (debug_mark),a  
2744 3a 53 27			ld a, (.dmark+1)  
2747 32 7b ee			ld (debug_mark+1),a  
274a 3a 54 27			ld a, (.dmark+2)  
274d 32 7c ee			ld (debug_mark+2),a  
2750 18 03			jr .pastdmark  
2752 ..			.dmark: db "LSm"  
2755 f1			.pastdmark: pop af  
2756			endm  
# End of macro DMARK
2756					CALLMONITOR 
2756 cd 39 14			call break_point_state  
2759				endm  
# End of macro CALLMONITOR
2759				endif 
2759			 
2759					; skip opcode 
2759 23					inc hl  
275a					; skip next ptr 
275a 23					inc hl  
275b 23					inc hl 
275c					; skip len 
275c 7e					ld a, (hl)   ; save length to add 
275d				if DEBUG_FORTH_WORDS 
275d					DMARK "LS2" 
275d f5				push af  
275e 3a 72 27			ld a, (.dmark)  
2761 32 7a ee			ld (debug_mark),a  
2764 3a 73 27			ld a, (.dmark+1)  
2767 32 7b ee			ld (debug_mark+1),a  
276a 3a 74 27			ld a, (.dmark+2)  
276d 32 7c ee			ld (debug_mark+2),a  
2770 18 03			jr .pastdmark  
2772 ..			.dmark: db "LS2"  
2775 f1			.pastdmark: pop af  
2776			endm  
# End of macro DMARK
2776					CALLMONITOR 
2776 cd 39 14			call break_point_state  
2779				endm  
# End of macro CALLMONITOR
2779				endif 
2779			 
2779					; save this location 
2779				 
2779 e5					push hl 
277a			 
277a 23					inc hl 
277b 11 62 e3				ld de, scratch+2 
277e 4f					ld c, a 
277f 06 00				ld b, 0 
2781			 
2781				if DEBUG_FORTH_WORDS 
2781					DMARK "LSn" 
2781 f5				push af  
2782 3a 96 27			ld a, (.dmark)  
2785 32 7a ee			ld (debug_mark),a  
2788 3a 97 27			ld a, (.dmark+1)  
278b 32 7b ee			ld (debug_mark+1),a  
278e 3a 98 27			ld a, (.dmark+2)  
2791 32 7c ee			ld (debug_mark+2),a  
2794 18 03			jr .pastdmark  
2796 ..			.dmark: db "LSn"  
2799 f1			.pastdmark: pop af  
279a			endm  
# End of macro DMARK
279a					CALLMONITOR 
279a cd 39 14			call break_point_state  
279d				endm  
# End of macro CALLMONITOR
279d				endif 
279d			 
279d					; copy uword name to scratch 
279d			 
279d ed b0				ldir 
279f			 
279f 1b					dec de 
27a0 3e 20				ld a, ' '    ; change null to space 
27a2 12					ld (de), a 
27a3			 
27a3 13					inc de 
27a4			 
27a4 d5					push de 
27a5 c1					pop bc     ; move scratch pointer to end of word name and save it 
27a6			 
27a6 e1					pop hl 
27a7 7e					ld a, (hl) 
27a8					;inc hl 
27a8					; skip word string 
27a8 cd c6 0b				call addatohl 
27ab			 
27ab 23					inc hl 
27ac			 
27ac				if DEBUG_FORTH_WORDS 
27ac					DMARK "LS3" 
27ac f5				push af  
27ad 3a c1 27			ld a, (.dmark)  
27b0 32 7a ee			ld (debug_mark),a  
27b3 3a c2 27			ld a, (.dmark+1)  
27b6 32 7b ee			ld (debug_mark+1),a  
27b9 3a c3 27			ld a, (.dmark+2)  
27bc 32 7c ee			ld (debug_mark+2),a  
27bf 18 03			jr .pastdmark  
27c1 ..			.dmark: db "LS3"  
27c4 f1			.pastdmark: pop af  
27c5			endm  
# End of macro DMARK
27c5					CALLMONITOR 
27c5 cd 39 14			call break_point_state  
27c8				endm  
# End of macro CALLMONITOR
27c8				endif 
27c8					; should now be at the start of the machine code to setup the eval of the uword 
27c8					; now locate the ptr to the string defintion 
27c8			 
27c8					; skip ld hl, 
27c8					; then load the ptr 
27c8			; TODO use get from hl ptr 
27c8 23					inc hl 
27c9 5e					ld e, (hl) 
27ca 23					inc hl 
27cb 56					ld d, (hl) 
27cc eb					ex de, hl 
27cd			 
27cd			 
27cd				if DEBUG_FORTH_WORDS 
27cd					DMARK "LSt" 
27cd f5				push af  
27ce 3a e2 27			ld a, (.dmark)  
27d1 32 7a ee			ld (debug_mark),a  
27d4 3a e3 27			ld a, (.dmark+1)  
27d7 32 7b ee			ld (debug_mark+1),a  
27da 3a e4 27			ld a, (.dmark+2)  
27dd 32 7c ee			ld (debug_mark+2),a  
27e0 18 03			jr .pastdmark  
27e2 ..			.dmark: db "LSt"  
27e5 f1			.pastdmark: pop af  
27e6			endm  
# End of macro DMARK
27e6					CALLMONITOR 
27e6 cd 39 14			call break_point_state  
27e9				endm  
# End of macro CALLMONITOR
27e9				endif 
27e9			 
27e9			; cant push right now due to tokenised strings  
27e9			 
27e9			; get the destination of where to copy this definition to. 
27e9			 
27e9 c5					push bc 
27ea d1					pop de 
27eb			 
27eb 7e			.listl:         ld a,(hl) 
27ec fe 00				cp 0 
27ee 28 09				jr z, .lreplsp     ; replace zero with space 
27f0					;cp FORTH_END_BUFFER 
27f0 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
27f2 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27f4				 
27f4					; just copy this char as is then 
27f4			 
27f4 12					ld (de), a 
27f5			 
27f5 23			.listnxt:	inc hl 
27f6 13					inc de 
27f7 18 f2				jr .listl 
27f9			 
27f9 3e 20		.lreplsp:	ld a,' ' 
27fb 12					ld (de), a 
27fc 18 f7				jr .listnxt 
27fe			 
27fe			; close up uword def 
27fe			 
27fe			.listdone: 
27fe 12					ld (de), a 
27ff 13					inc de 
2800 3e 00				ld a, 0 
2802 12					ld (de), a 
2803			 
2803			; now have def so clean up and push to stack 
2803			 
2803 21 60 e3				ld hl, scratch 
2806				if DEBUG_FORTH_WORDS 
2806					DMARK "Ltp" 
2806 f5				push af  
2807 3a 1b 28			ld a, (.dmark)  
280a 32 7a ee			ld (debug_mark),a  
280d 3a 1c 28			ld a, (.dmark+1)  
2810 32 7b ee			ld (debug_mark+1),a  
2813 3a 1d 28			ld a, (.dmark+2)  
2816 32 7c ee			ld (debug_mark+2),a  
2819 18 03			jr .pastdmark  
281b ..			.dmark: db "Ltp"  
281e f1			.pastdmark: pop af  
281f			endm  
# End of macro DMARK
281f					CALLMONITOR 
281f cd 39 14			call break_point_state  
2822				endm  
# End of macro CALLMONITOR
2822				endif 
2822			 
2822 18 1f			jr .listpush 
2824			 
2824			;.lnuword:	pop hl 
2824			;		call forth_tok_next 
2824			;		jp .ldouscan  
2824			 
2824			.lunotfound:		  
2824			 
2824				if DEBUG_FORTH_WORDS 
2824					DMARK "LSn" 
2824 f5				push af  
2825 3a 39 28			ld a, (.dmark)  
2828 32 7a ee			ld (debug_mark),a  
282b 3a 3a 28			ld a, (.dmark+1)  
282e 32 7b ee			ld (debug_mark+1),a  
2831 3a 3b 28			ld a, (.dmark+2)  
2834 32 7c ee			ld (debug_mark+2),a  
2837 18 03			jr .pastdmark  
2839 ..			.dmark: db "LSn"  
283c f1			.pastdmark: pop af  
283d			endm  
# End of macro DMARK
283d					CALLMONITOR 
283d cd 39 14			call break_point_state  
2840				endm  
# End of macro CALLMONITOR
2840				endif 
2840			 
2840					 
2840			;		FORTH_DSP_POP 
2840			;		ld hl, .luno 
2840			 
2840					NEXTW			 
2840 c3 2f 1d			jp macro_next 
2843				endm 
# End of macro NEXTW
2843			 
2843			.listpush: 
2843				if DEBUG_FORTH_WORDS 
2843					DMARK "LS>" 
2843 f5				push af  
2844 3a 58 28			ld a, (.dmark)  
2847 32 7a ee			ld (debug_mark),a  
284a 3a 59 28			ld a, (.dmark+1)  
284d 32 7b ee			ld (debug_mark+1),a  
2850 3a 5a 28			ld a, (.dmark+2)  
2853 32 7c ee			ld (debug_mark+2),a  
2856 18 03			jr .pastdmark  
2858 ..			.dmark: db "LS>"  
285b f1			.pastdmark: pop af  
285c			endm  
# End of macro DMARK
285c					CALLMONITOR 
285c cd 39 14			call break_point_state  
285f				endm  
# End of macro CALLMONITOR
285f				endif 
285f cd 34 1a				call forth_push_str 
2862			 
2862			 
2862			 
2862					NEXTW 
2862 c3 2f 1d			jp macro_next 
2865				endm 
# End of macro NEXTW
2865			 
2865			;.luno:    db "Word not found",0 
2865			 
2865			 
2865			 
2865			 
2865			 
2865			;		push hl   ; save pointer to start of uword def string 
2865			; 
2865			;; look for FORTH_EOL_LINE 
2865			;		ld a, FORTH_END_BUFFER 
2865			;		call strlent 
2865			; 
2865			;		inc hl		 ; space for coln def 
2865			;		inc hl 
2865			;		inc hl          ; space for terms 
2865			;		inc hl 
2865			; 
2865			;		ld a, 20   ; TODO get actual length 
2865			;		call addatohl    ; include a random amount of room for the uword name 
2865			; 
2865			;		 
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "Lt1" 
2865			;		CALLMONITOR 
2865			;	endif 
2865			;		 
2865			; 
2865			;; malloc space for the string because we cant change it 
2865			; 
2865			;		call malloc 
2865			;	if DEBUG_FORTH_MALLOC_GUARD 
2865			;		push af 
2865			;		call ishlzero 
2865			;		pop af 
2865			;		 
2865			;		call z,malloc_error 
2865			;	endif 
2865			; 
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "Lt2" 
2865			;		CALLMONITOR 
2865			;	endif 
2865			;		pop de 
2865			;		push hl    ; push the malloc to release later 
2865			;		push hl   ;  push back a copy for the later stack push 
2865			;		 
2865			;; copy the string swapping out the zero terms for spaces 
2865			; 
2865			;		; de has our source 
2865			;		; hl has our dest 
2865			; 
2865			;; add the coln def 
2865			; 
2865			;		ld a, ':' 
2865			;		ld (hl), a 
2865			;		inc hl 
2865			;		ld a, ' ' 
2865			;		ld (hl), a 
2865			;		inc hl 
2865			; 
2865			;; add the uname word 
2865			;		push de   ; save our string for now 
2865			;		ex de, hl 
2865			; 
2865			;		FORTH_DSP_VALUE 
2865			;		;v5 FORTH_DSP_VALUE 
2865			; 
2865			;		inc hl   ; skip type but we know by now this is OK 
2865			; 
2865			;.luword:	ld a,(hl) 
2865			;		cp 0 
2865			;		jr z, .luword2 
2865			;		ld (de), a 
2865			;		inc de 
2865			;		inc hl 
2865			;		jr .luword 
2865			; 
2865			;.luword2:	ld a, ' ' 
2865			;		ld (de), a 
2865			;;		inc hl 
2865			;;		inc de 
2865			;;		ld (de), a 
2865			;;		inc hl 
2865			;		inc de 
2865			; 
2865			;		ex de, hl 
2865			;		pop de 
2865			;		 
2865			;		 
2865			; 
2865			;; detoken that string and copy it 
2865			; 
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "Lt2" 
2865			;		CALLMONITOR 
2865			;	endif 
2865			;.ldetok:	ld a, (de) 
2865			;		cp FORTH_END_BUFFER 
2865			;		jr z, .ldetokend 
2865			;		; swap out any zero term for space 
2865			;		cp 0 
2865			;		jr nz, .ldetoknext 
2865			;		ld a, ' ' 
2865			; 
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "LtS" 
2865			;		CALLMONITOR 
2865			;	endif 
2865			;.ldetoknext:	ld (hl), a 
2865			;		inc de 
2865			;		inc hl 
2865			;		jr .ldetok 
2865			; 
2865			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2865			;		ld (hl), a  
2865			; 
2865			;; free that temp malloc 
2865			; 
2865			;		pop hl    
2865			; 
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "Lt4" 
2865			;		CALLMONITOR 
2865			;	endif 
2865			;		call forth_apushstrhl 
2865			; 
2865			;		; get rid of temp malloc area 
2865			; 
2865			;		pop hl 
2865			;		call free 
2865			; 
2865			;		jr .ludone 
2865			; 
2865			;.lnuword:	pop hl 
2865			;		call forth_tok_next 
2865			;		jp .ldouscan  
2865			; 
2865			;.ludone:		 pop hl 
2865			; 
2865					NEXTW 
2865 c3 2f 1d			jp macro_next 
2868				endm 
# End of macro NEXTW
2868			 
2868			.FORGET: 
2868				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2868 5d				db WORD_SYS_CORE+73             
2869 e1 28			dw .NOP            
286b 07				db 6 + 1 
286c .. 00			db "FORGET",0              
2873				endm 
# End of macro CWHEAD
2873			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2873			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2873			; | |  
2873			; | | e.g. "MORE" forget 
2873					if DEBUG_FORTH_WORDS_KEY 
2873						DMARK "FRG" 
2873 f5				push af  
2874 3a 88 28			ld a, (.dmark)  
2877 32 7a ee			ld (debug_mark),a  
287a 3a 89 28			ld a, (.dmark+1)  
287d 32 7b ee			ld (debug_mark+1),a  
2880 3a 8a 28			ld a, (.dmark+2)  
2883 32 7c ee			ld (debug_mark+2),a  
2886 18 03			jr .pastdmark  
2888 ..			.dmark: db "FRG"  
288b f1			.pastdmark: pop af  
288c			endm  
# End of macro DMARK
288c						CALLMONITOR 
288c cd 39 14			call break_point_state  
288f				endm  
# End of macro CALLMONITOR
288f					endif 
288f			 
288f				; find uword 
288f			        ; update start of word with "_" 
288f				; replace uword with deleted flag 
288f			 
288f			 
288f			;	if DEBUG_FORTH_WORDS 
288f			;		DMARK "FOG" 
288f			;		CALLMONITOR 
288f			;	endif 
288f			 
288f			 
288f					; Get ptr to the word we need to look up 
288f			 
288f					FORTH_DSP_VALUEHL 
288f cd bd 1b			call macro_dsp_valuehl 
2892				endm 
# End of macro FORTH_DSP_VALUEHL
2892					;v5 FORTH_DSP_VALUE 
2892				; TODO type check 
2892			;		inc hl    ; Skip type check  
2892 e5					push hl 
2893 c1					pop bc 
2894			;		ex de, hl    ; put into DE 
2894			 
2894			 
2894 21 e7 58				ld hl, baseram 
2897					;ld hl, baseusermem 
2897			 
2897				; skip dict stub 
2897			;	call forth_tok_next 
2897 e5			push hl   ; sacreifical push 
2898			 
2898			.fldouscanm: 
2898 e1				pop hl 
2899			.fldouscan: 
2899			;	if DEBUG_FORTH_WORDS 
2899			;		DMARK "LSs" 
2899			;		CALLMONITOR 
2899			;	endif 
2899				; skip dict stub 
2899 cd 80 1e				call forth_tok_next 
289c			 
289c			 
289c			; while we have words to look for 
289c			 
289c 7e				ld a, (hl)      
289d			;	if DEBUG_FORTH_WORDS 
289d			;		DMARK "LSk" 
289d			;		CALLMONITOR 
289d			;	endif 
289d fe 00				cp WORD_SYS_END 
289f ca db 28				jp z, .flunotfound 
28a2 fe 01				cp WORD_SYS_UWORD 
28a4 c2 99 28				jp nz, .fldouscan 
28a7			 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "LSu" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			 
28a7					; found a uword but is it the one we want... 
28a7			 
28a7 c5					push bc     ; uword to find is on bc 
28a8 d1					pop de 
28a9			 
28a9 e5					push hl  ; to save the ptr 
28aa			 
28aa					; skip opcode 
28aa 23					inc hl  
28ab					; skip next ptr 
28ab 23					inc hl  
28ac 23					inc hl 
28ad					; skip len 
28ad 23					inc hl 
28ae			 
28ae			;	if DEBUG_FORTH_WORDS 
28ae			;		DMARK "LSc" 
28ae			;		CALLMONITOR 
28ae			;	endif 
28ae cd 5c 10				call strcmp 
28b1 c2 98 28				jp nz, .fldouscanm 
28b4			; 
28b4			; 
28b4			;; while we have words to look for 
28b4			; 
28b4			;.fdouscan:	ld a, (hl)      
28b4			;	if DEBUG_FORTH_WORDS 
28b4			;		DMARK "LSs" 
28b4			;		CALLMONITOR 
28b4			;	endif 
28b4			;		cp WORD_SYS_END 
28b4			;		jp z, .fudone 
28b4			;		cp WORD_SYS_UWORD 
28b4			;		jp nz, .fnuword 
28b4			; 
28b4			;	if DEBUG_FORTH_WORDS 
28b4			;		DMARK "FGu" 
28b4			;		CALLMONITOR 
28b4			;	endif 
28b4			; 
28b4			;		; found a uword but is it the one we want... 
28b4			; 
28b4			; 
28b4			;	        pop de   ; get back the dsp name 
28b4			;		push de 
28b4			; 
28b4			;		push hl  ; to save the ptr 
28b4			; 
28b4			;		; skip opcode 
28b4			;		inc hl  
28b4			;		; skip next ptr 
28b4			;		inc hl  
28b4			;		inc hl 
28b4			;		; skip len 
28b4			;		inc hl 
28b4			; 
28b4			;	if DEBUG_FORTH_WORDS 
28b4			;		DMARK "FGc" 
28b4			;		CALLMONITOR 
28b4			;	endif 
28b4			;		call strcmp 
28b4			;		jp nz, .fnuword 
28b4			 
28b4			 
28b4 e1			pop hl 
28b5			 
28b5				 
28b5				if DEBUG_FORTH_WORDS 
28b5					DMARK "FGm" 
28b5 f5				push af  
28b6 3a ca 28			ld a, (.dmark)  
28b9 32 7a ee			ld (debug_mark),a  
28bc 3a cb 28			ld a, (.dmark+1)  
28bf 32 7b ee			ld (debug_mark+1),a  
28c2 3a cc 28			ld a, (.dmark+2)  
28c5 32 7c ee			ld (debug_mark+2),a  
28c8 18 03			jr .pastdmark  
28ca ..			.dmark: db "FGm"  
28cd f1			.pastdmark: pop af  
28ce			endm  
# End of macro DMARK
28ce					CALLMONITOR 
28ce cd 39 14			call break_point_state  
28d1				endm  
# End of macro CALLMONITOR
28d1				endif 
28d1			 
28d1			 
28d1			 
28d1					; we have a uword so push its name to the stack 
28d1			 
28d1			;	   	push hl  ; save so we can move to next dict block 
28d1			;pop hl 
28d1			 
28d1					; update opcode to deleted 
28d1 3e 03				ld a, WORD_SYS_DELETED 
28d3 77					ld (hl), a 
28d4			 
28d4 23					inc hl  
28d5					; skip next ptr 
28d5 23					inc hl  
28d6 23					inc hl 
28d7					; skip len 
28d7 23					inc hl 
28d8			 
28d8					; TODO change parser to skip deleted words but for now mark it out 
28d8 3e 5f				ld a, "_" 
28da 77					ld  (hl),a 
28db			 
28db			;		jr .fudone 
28db			; 
28db			;.fnuword:	pop hl 
28db			;		call forth_tok_next 
28db			;		jp .fdouscan  
28db			 
28db			.flunotfound:		  
28db			 
28db			 
28db					 
28db					FORTH_DSP_POP 
28db cd 75 1c			call macro_forth_dsp_pop 
28de				endm 
# End of macro FORTH_DSP_POP
28de			;		ld hl, .luno 
28de			;.fudone:		 pop hl 
28de					NEXTW 
28de c3 2f 1d			jp macro_next 
28e1				endm 
# End of macro NEXTW
28e1			.NOP: 
28e1				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
28e1 61				db WORD_SYS_CORE+77             
28e2 08 29			dw .COMO            
28e4 04				db 3 + 1 
28e5 .. 00			db "NOP",0              
28e9				endm 
# End of macro CWHEAD
28e9			; | NOP (  --  ) Do nothing | DONE 
28e9					if DEBUG_FORTH_WORDS_KEY 
28e9						DMARK "NOP" 
28e9 f5				push af  
28ea 3a fe 28			ld a, (.dmark)  
28ed 32 7a ee			ld (debug_mark),a  
28f0 3a ff 28			ld a, (.dmark+1)  
28f3 32 7b ee			ld (debug_mark+1),a  
28f6 3a 00 29			ld a, (.dmark+2)  
28f9 32 7c ee			ld (debug_mark+2),a  
28fc 18 03			jr .pastdmark  
28fe ..			.dmark: db "NOP"  
2901 f1			.pastdmark: pop af  
2902			endm  
# End of macro DMARK
2902						CALLMONITOR 
2902 cd 39 14			call break_point_state  
2905				endm  
# End of macro CALLMONITOR
2905					endif 
2905				       NEXTW 
2905 c3 2f 1d			jp macro_next 
2908				endm 
# End of macro NEXTW
2908			.COMO: 
2908				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2908 6e				db WORD_SYS_CORE+90             
2909 5a 29			dw .COMC            
290b 02				db 1 + 1 
290c .. 00			db "(",0              
290e				endm 
# End of macro CWHEAD
290e			; | ( ( -- )  Start of comment | DONE 
290e			 
290e			 
290e 2a 61 e6				ld hl, ( os_tok_ptr) 
2911 11 55 29			ld de, .closepar 
2914					 
2914					if DEBUG_FORTH_WORDS 
2914						DMARK ").." 
2914 f5				push af  
2915 3a 29 29			ld a, (.dmark)  
2918 32 7a ee			ld (debug_mark),a  
291b 3a 2a 29			ld a, (.dmark+1)  
291e 32 7b ee			ld (debug_mark+1),a  
2921 3a 2b 29			ld a, (.dmark+2)  
2924 32 7c ee			ld (debug_mark+2),a  
2927 18 03			jr .pastdmark  
2929 ..			.dmark: db ").."  
292c f1			.pastdmark: pop af  
292d			endm  
# End of macro DMARK
292d						CALLMONITOR 
292d cd 39 14			call break_point_state  
2930				endm  
# End of macro CALLMONITOR
2930					endif 
2930 cd 4a 1e			call findnexttok  
2933			 
2933					if DEBUG_FORTH_WORDS 
2933						DMARK "IF5" 
2933 f5				push af  
2934 3a 48 29			ld a, (.dmark)  
2937 32 7a ee			ld (debug_mark),a  
293a 3a 49 29			ld a, (.dmark+1)  
293d 32 7b ee			ld (debug_mark+1),a  
2940 3a 4a 29			ld a, (.dmark+2)  
2943 32 7c ee			ld (debug_mark+2),a  
2946 18 03			jr .pastdmark  
2948 ..			.dmark: db "IF5"  
294b f1			.pastdmark: pop af  
294c			endm  
# End of macro DMARK
294c						CALLMONITOR 
294c cd 39 14			call break_point_state  
294f				endm  
# End of macro CALLMONITOR
294f					endif 
294f				; replace below with ) exec using tok_ptr 
294f 22 61 e6			ld (os_tok_ptr), hl 
2952 c3 c0 1d			jp exec1 
2955			 
2955 .. 00			.closepar:   db ")",0 
2957			 
2957				       NEXTW 
2957 c3 2f 1d			jp macro_next 
295a				endm 
# End of macro NEXTW
295a			.COMC: 
295a				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
295a 6f				db WORD_SYS_CORE+91             
295b 63 29			dw .SCRATCH            
295d 02				db 1 + 1 
295e .. 00			db ")",0              
2960				endm 
# End of macro CWHEAD
2960			; | ) ( -- )  End of comment |  DONE  
2960				       NEXTW 
2960 c3 2f 1d			jp macro_next 
2963				endm 
# End of macro NEXTW
2963			 
2963			.SCRATCH: 
2963				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2963 6f				db WORD_SYS_CORE+91             
2964 9e 29			dw .INC            
2966 08				db 7 + 1 
2967 .. 00			db "SCRATCH",0              
296f				endm 
# End of macro CWHEAD
296f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
296f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
296f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
296f			; | |  
296f			; | | e.g.    : score $00 scratch ; 
296f			; | |  
296f			; | | $00 score ! 
296f			; | | $01 score +! 
296f			; | |  
296f			; | | e.g.   : varword $0a scratch ;  
296f			; | | 
296f			; | | $8000 varword ! 
296f					if DEBUG_FORTH_WORDS_KEY 
296f						DMARK "SCR" 
296f f5				push af  
2970 3a 84 29			ld a, (.dmark)  
2973 32 7a ee			ld (debug_mark),a  
2976 3a 85 29			ld a, (.dmark+1)  
2979 32 7b ee			ld (debug_mark+1),a  
297c 3a 86 29			ld a, (.dmark+2)  
297f 32 7c ee			ld (debug_mark+2),a  
2982 18 03			jr .pastdmark  
2984 ..			.dmark: db "SCR"  
2987 f1			.pastdmark: pop af  
2988			endm  
# End of macro DMARK
2988						CALLMONITOR 
2988 cd 39 14			call break_point_state  
298b				endm  
# End of macro CALLMONITOR
298b					endif 
298b			 
298b					FORTH_DSP_VALUEHL 
298b cd bd 1b			call macro_dsp_valuehl 
298e				endm 
# End of macro FORTH_DSP_VALUEHL
298e				 
298e					FORTH_DSP_POP 
298e cd 75 1c			call macro_forth_dsp_pop 
2991				endm 
# End of macro FORTH_DSP_POP
2991			 
2991 7d					ld a, l 
2992 21 85 e8				ld hl, os_var_array 
2995 cd c6 0b				call addatohl 
2998			 
2998 cd c6 19				call forth_push_numhl 
299b			 
299b				       NEXTW 
299b c3 2f 1d			jp macro_next 
299e				endm 
# End of macro NEXTW
299e			 
299e			.INC: 
299e				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
299e 6f				db WORD_SYS_CORE+91             
299f f2 29			dw .DEC            
29a1 03				db 2 + 1 
29a2 .. 00			db "+!",0              
29a5				endm 
# End of macro CWHEAD
29a5			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
29a5					if DEBUG_FORTH_WORDS_KEY 
29a5						DMARK "+s_" 
29a5 f5				push af  
29a6 3a ba 29			ld a, (.dmark)  
29a9 32 7a ee			ld (debug_mark),a  
29ac 3a bb 29			ld a, (.dmark+1)  
29af 32 7b ee			ld (debug_mark+1),a  
29b2 3a bc 29			ld a, (.dmark+2)  
29b5 32 7c ee			ld (debug_mark+2),a  
29b8 18 03			jr .pastdmark  
29ba ..			.dmark: db "+s_"  
29bd f1			.pastdmark: pop af  
29be			endm  
# End of macro DMARK
29be						CALLMONITOR 
29be cd 39 14			call break_point_state  
29c1				endm  
# End of macro CALLMONITOR
29c1					endif 
29c1			 
29c1					FORTH_DSP_VALUEHL 
29c1 cd bd 1b			call macro_dsp_valuehl 
29c4				endm 
# End of macro FORTH_DSP_VALUEHL
29c4			 
29c4 e5					push hl   ; save address 
29c5			 
29c5					FORTH_DSP_POP 
29c5 cd 75 1c			call macro_forth_dsp_pop 
29c8				endm 
# End of macro FORTH_DSP_POP
29c8			 
29c8					FORTH_DSP_VALUEHL 
29c8 cd bd 1b			call macro_dsp_valuehl 
29cb				endm 
# End of macro FORTH_DSP_VALUEHL
29cb			 
29cb					FORTH_DSP_POP 
29cb cd 75 1c			call macro_forth_dsp_pop 
29ce				endm 
# End of macro FORTH_DSP_POP
29ce			 
29ce					; hl contains value to add to byte at a 
29ce				 
29ce eb					ex de, hl 
29cf			 
29cf e1					pop hl 
29d0			 
29d0					if DEBUG_FORTH_WORDS 
29d0						DMARK "INC" 
29d0 f5				push af  
29d1 3a e5 29			ld a, (.dmark)  
29d4 32 7a ee			ld (debug_mark),a  
29d7 3a e6 29			ld a, (.dmark+1)  
29da 32 7b ee			ld (debug_mark+1),a  
29dd 3a e7 29			ld a, (.dmark+2)  
29e0 32 7c ee			ld (debug_mark+2),a  
29e3 18 03			jr .pastdmark  
29e5 ..			.dmark: db "INC"  
29e8 f1			.pastdmark: pop af  
29e9			endm  
# End of macro DMARK
29e9						CALLMONITOR 
29e9 cd 39 14			call break_point_state  
29ec				endm  
# End of macro CALLMONITOR
29ec					endif 
29ec			 
29ec 7e					ld a,(hl) 
29ed 83					add e 
29ee 77					ld (hl),a 
29ef			 
29ef			 
29ef			 
29ef				       NEXTW 
29ef c3 2f 1d			jp macro_next 
29f2				endm 
# End of macro NEXTW
29f2			 
29f2			.DEC: 
29f2				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
29f2 6f				db WORD_SYS_CORE+91             
29f3 43 2a			dw .INC2            
29f5 03				db 2 + 1 
29f6 .. 00			db "-!",0              
29f9				endm 
# End of macro CWHEAD
29f9			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
29f9					if DEBUG_FORTH_WORDS_KEY 
29f9						DMARK "-s_" 
29f9 f5				push af  
29fa 3a 0e 2a			ld a, (.dmark)  
29fd 32 7a ee			ld (debug_mark),a  
2a00 3a 0f 2a			ld a, (.dmark+1)  
2a03 32 7b ee			ld (debug_mark+1),a  
2a06 3a 10 2a			ld a, (.dmark+2)  
2a09 32 7c ee			ld (debug_mark+2),a  
2a0c 18 03			jr .pastdmark  
2a0e ..			.dmark: db "-s_"  
2a11 f1			.pastdmark: pop af  
2a12			endm  
# End of macro DMARK
2a12						CALLMONITOR 
2a12 cd 39 14			call break_point_state  
2a15				endm  
# End of macro CALLMONITOR
2a15					endif 
2a15			 
2a15					FORTH_DSP_VALUEHL 
2a15 cd bd 1b			call macro_dsp_valuehl 
2a18				endm 
# End of macro FORTH_DSP_VALUEHL
2a18			 
2a18 e5					push hl   ; save address 
2a19			 
2a19					FORTH_DSP_POP 
2a19 cd 75 1c			call macro_forth_dsp_pop 
2a1c				endm 
# End of macro FORTH_DSP_POP
2a1c			 
2a1c					FORTH_DSP_VALUEHL 
2a1c cd bd 1b			call macro_dsp_valuehl 
2a1f				endm 
# End of macro FORTH_DSP_VALUEHL
2a1f			 
2a1f					; hl contains value to add to byte at a 
2a1f				 
2a1f eb					ex de, hl 
2a20			 
2a20 e1					pop hl 
2a21			 
2a21					if DEBUG_FORTH_WORDS 
2a21						DMARK "DEC" 
2a21 f5				push af  
2a22 3a 36 2a			ld a, (.dmark)  
2a25 32 7a ee			ld (debug_mark),a  
2a28 3a 37 2a			ld a, (.dmark+1)  
2a2b 32 7b ee			ld (debug_mark+1),a  
2a2e 3a 38 2a			ld a, (.dmark+2)  
2a31 32 7c ee			ld (debug_mark+2),a  
2a34 18 03			jr .pastdmark  
2a36 ..			.dmark: db "DEC"  
2a39 f1			.pastdmark: pop af  
2a3a			endm  
# End of macro DMARK
2a3a						CALLMONITOR 
2a3a cd 39 14			call break_point_state  
2a3d				endm  
# End of macro CALLMONITOR
2a3d					endif 
2a3d			 
2a3d 7e					ld a,(hl) 
2a3e 93					sub e 
2a3f 77					ld (hl),a 
2a40			 
2a40			 
2a40			 
2a40				       NEXTW 
2a40 c3 2f 1d			jp macro_next 
2a43				endm 
# End of macro NEXTW
2a43			 
2a43			.INC2: 
2a43				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a43 6f				db WORD_SYS_CORE+91             
2a44 ed 2a			dw .DEC2            
2a46 04				db 3 + 1 
2a47 .. 00			db "+2!",0              
2a4b				endm 
# End of macro CWHEAD
2a4b			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a4b			 
2a4b					if DEBUG_FORTH_WORDS_KEY 
2a4b						DMARK "+2s" 
2a4b f5				push af  
2a4c 3a 60 2a			ld a, (.dmark)  
2a4f 32 7a ee			ld (debug_mark),a  
2a52 3a 61 2a			ld a, (.dmark+1)  
2a55 32 7b ee			ld (debug_mark+1),a  
2a58 3a 62 2a			ld a, (.dmark+2)  
2a5b 32 7c ee			ld (debug_mark+2),a  
2a5e 18 03			jr .pastdmark  
2a60 ..			.dmark: db "+2s"  
2a63 f1			.pastdmark: pop af  
2a64			endm  
# End of macro DMARK
2a64						CALLMONITOR 
2a64 cd 39 14			call break_point_state  
2a67				endm  
# End of macro CALLMONITOR
2a67					endif 
2a67			 
2a67					; Address 
2a67			 
2a67					FORTH_DSP_VALUEHL 
2a67 cd bd 1b			call macro_dsp_valuehl 
2a6a				endm 
# End of macro FORTH_DSP_VALUEHL
2a6a			 
2a6a e5					push hl    ; save address 
2a6b			 
2a6b					; load content into de 
2a6b			 
2a6b 5e					ld e,(hl) 
2a6c 23					inc hl 
2a6d 56					ld d, (hl) 
2a6e			 
2a6e					if DEBUG_FORTH_WORDS 
2a6e						DMARK "+2a" 
2a6e f5				push af  
2a6f 3a 83 2a			ld a, (.dmark)  
2a72 32 7a ee			ld (debug_mark),a  
2a75 3a 84 2a			ld a, (.dmark+1)  
2a78 32 7b ee			ld (debug_mark+1),a  
2a7b 3a 85 2a			ld a, (.dmark+2)  
2a7e 32 7c ee			ld (debug_mark+2),a  
2a81 18 03			jr .pastdmark  
2a83 ..			.dmark: db "+2a"  
2a86 f1			.pastdmark: pop af  
2a87			endm  
# End of macro DMARK
2a87						CALLMONITOR 
2a87 cd 39 14			call break_point_state  
2a8a				endm  
# End of macro CALLMONITOR
2a8a					endif 
2a8a			 
2a8a					FORTH_DSP_POP 
2a8a cd 75 1c			call macro_forth_dsp_pop 
2a8d				endm 
# End of macro FORTH_DSP_POP
2a8d			 
2a8d					; Get value to add 
2a8d			 
2a8d					FORTH_DSP_VALUE 
2a8d cd a6 1b			call macro_forth_dsp_value 
2a90				endm 
# End of macro FORTH_DSP_VALUE
2a90			 
2a90					if DEBUG_FORTH_WORDS 
2a90						DMARK "+2v" 
2a90 f5				push af  
2a91 3a a5 2a			ld a, (.dmark)  
2a94 32 7a ee			ld (debug_mark),a  
2a97 3a a6 2a			ld a, (.dmark+1)  
2a9a 32 7b ee			ld (debug_mark+1),a  
2a9d 3a a7 2a			ld a, (.dmark+2)  
2aa0 32 7c ee			ld (debug_mark+2),a  
2aa3 18 03			jr .pastdmark  
2aa5 ..			.dmark: db "+2v"  
2aa8 f1			.pastdmark: pop af  
2aa9			endm  
# End of macro DMARK
2aa9						CALLMONITOR 
2aa9 cd 39 14			call break_point_state  
2aac				endm  
# End of macro CALLMONITOR
2aac					endif 
2aac			 
2aac 19					add hl, de 
2aad			 
2aad					if DEBUG_FORTH_WORDS 
2aad						DMARK "+2+" 
2aad f5				push af  
2aae 3a c2 2a			ld a, (.dmark)  
2ab1 32 7a ee			ld (debug_mark),a  
2ab4 3a c3 2a			ld a, (.dmark+1)  
2ab7 32 7b ee			ld (debug_mark+1),a  
2aba 3a c4 2a			ld a, (.dmark+2)  
2abd 32 7c ee			ld (debug_mark+2),a  
2ac0 18 03			jr .pastdmark  
2ac2 ..			.dmark: db "+2+"  
2ac5 f1			.pastdmark: pop af  
2ac6			endm  
# End of macro DMARK
2ac6						CALLMONITOR 
2ac6 cd 39 14			call break_point_state  
2ac9				endm  
# End of macro CALLMONITOR
2ac9					endif 
2ac9			 
2ac9					; move result to de 
2ac9			 
2ac9 eb					ex de, hl 
2aca			 
2aca					; Address 
2aca			 
2aca e1					pop hl 
2acb			 
2acb					; save it back 
2acb			 
2acb 73					ld (hl), e 
2acc 23					inc hl 
2acd 72					ld (hl), d 
2ace			 
2ace					if DEBUG_FORTH_WORDS 
2ace						DMARK "+2e" 
2ace f5				push af  
2acf 3a e3 2a			ld a, (.dmark)  
2ad2 32 7a ee			ld (debug_mark),a  
2ad5 3a e4 2a			ld a, (.dmark+1)  
2ad8 32 7b ee			ld (debug_mark+1),a  
2adb 3a e5 2a			ld a, (.dmark+2)  
2ade 32 7c ee			ld (debug_mark+2),a  
2ae1 18 03			jr .pastdmark  
2ae3 ..			.dmark: db "+2e"  
2ae6 f1			.pastdmark: pop af  
2ae7			endm  
# End of macro DMARK
2ae7						CALLMONITOR 
2ae7 cd 39 14			call break_point_state  
2aea				endm  
# End of macro CALLMONITOR
2aea					endif 
2aea			 
2aea			 
2aea			 
2aea			 
2aea			 
2aea				       NEXTW 
2aea c3 2f 1d			jp macro_next 
2aed				endm 
# End of macro NEXTW
2aed			 
2aed			.DEC2: 
2aed				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2aed 6f				db WORD_SYS_CORE+91             
2aee 99 2b			dw .GET2            
2af0 04				db 3 + 1 
2af1 .. 00			db "-2!",0              
2af5				endm 
# End of macro CWHEAD
2af5			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2af5			 
2af5			 
2af5					if DEBUG_FORTH_WORDS_KEY 
2af5						DMARK "-2s" 
2af5 f5				push af  
2af6 3a 0a 2b			ld a, (.dmark)  
2af9 32 7a ee			ld (debug_mark),a  
2afc 3a 0b 2b			ld a, (.dmark+1)  
2aff 32 7b ee			ld (debug_mark+1),a  
2b02 3a 0c 2b			ld a, (.dmark+2)  
2b05 32 7c ee			ld (debug_mark+2),a  
2b08 18 03			jr .pastdmark  
2b0a ..			.dmark: db "-2s"  
2b0d f1			.pastdmark: pop af  
2b0e			endm  
# End of macro DMARK
2b0e						CALLMONITOR 
2b0e cd 39 14			call break_point_state  
2b11				endm  
# End of macro CALLMONITOR
2b11					endif 
2b11			 
2b11					; Address 
2b11			 
2b11					FORTH_DSP_VALUEHL 
2b11 cd bd 1b			call macro_dsp_valuehl 
2b14				endm 
# End of macro FORTH_DSP_VALUEHL
2b14			 
2b14 e5					push hl    ; save address 
2b15			 
2b15					; load content into de 
2b15			 
2b15 5e					ld e,(hl) 
2b16 23					inc hl 
2b17 56					ld d, (hl) 
2b18			 
2b18					if DEBUG_FORTH_WORDS 
2b18						DMARK "-2a" 
2b18 f5				push af  
2b19 3a 2d 2b			ld a, (.dmark)  
2b1c 32 7a ee			ld (debug_mark),a  
2b1f 3a 2e 2b			ld a, (.dmark+1)  
2b22 32 7b ee			ld (debug_mark+1),a  
2b25 3a 2f 2b			ld a, (.dmark+2)  
2b28 32 7c ee			ld (debug_mark+2),a  
2b2b 18 03			jr .pastdmark  
2b2d ..			.dmark: db "-2a"  
2b30 f1			.pastdmark: pop af  
2b31			endm  
# End of macro DMARK
2b31						CALLMONITOR 
2b31 cd 39 14			call break_point_state  
2b34				endm  
# End of macro CALLMONITOR
2b34					endif 
2b34			 
2b34					FORTH_DSP_POP 
2b34 cd 75 1c			call macro_forth_dsp_pop 
2b37				endm 
# End of macro FORTH_DSP_POP
2b37			 
2b37					; Get value to remove 
2b37			 
2b37					FORTH_DSP_VALUE 
2b37 cd a6 1b			call macro_forth_dsp_value 
2b3a				endm 
# End of macro FORTH_DSP_VALUE
2b3a			 
2b3a					if DEBUG_FORTH_WORDS 
2b3a						DMARK "-2v" 
2b3a f5				push af  
2b3b 3a 4f 2b			ld a, (.dmark)  
2b3e 32 7a ee			ld (debug_mark),a  
2b41 3a 50 2b			ld a, (.dmark+1)  
2b44 32 7b ee			ld (debug_mark+1),a  
2b47 3a 51 2b			ld a, (.dmark+2)  
2b4a 32 7c ee			ld (debug_mark+2),a  
2b4d 18 03			jr .pastdmark  
2b4f ..			.dmark: db "-2v"  
2b52 f1			.pastdmark: pop af  
2b53			endm  
# End of macro DMARK
2b53						CALLMONITOR 
2b53 cd 39 14			call break_point_state  
2b56				endm  
# End of macro CALLMONITOR
2b56					endif 
2b56			 
2b56 eb					ex de, hl 
2b57 ed 52				sbc hl, de 
2b59			 
2b59					if DEBUG_FORTH_WORDS 
2b59						DMARK "-2d" 
2b59 f5				push af  
2b5a 3a 6e 2b			ld a, (.dmark)  
2b5d 32 7a ee			ld (debug_mark),a  
2b60 3a 6f 2b			ld a, (.dmark+1)  
2b63 32 7b ee			ld (debug_mark+1),a  
2b66 3a 70 2b			ld a, (.dmark+2)  
2b69 32 7c ee			ld (debug_mark+2),a  
2b6c 18 03			jr .pastdmark  
2b6e ..			.dmark: db "-2d"  
2b71 f1			.pastdmark: pop af  
2b72			endm  
# End of macro DMARK
2b72						CALLMONITOR 
2b72 cd 39 14			call break_point_state  
2b75				endm  
# End of macro CALLMONITOR
2b75					endif 
2b75			 
2b75					; move result to de 
2b75			 
2b75 eb					ex de, hl 
2b76			 
2b76					; Address 
2b76			 
2b76 e1					pop hl 
2b77			 
2b77					; save it back 
2b77			 
2b77 73					ld (hl), e 
2b78 23					inc hl 
2b79 72					ld (hl), d 
2b7a			 
2b7a					if DEBUG_FORTH_WORDS 
2b7a						DMARK "-2e" 
2b7a f5				push af  
2b7b 3a 8f 2b			ld a, (.dmark)  
2b7e 32 7a ee			ld (debug_mark),a  
2b81 3a 90 2b			ld a, (.dmark+1)  
2b84 32 7b ee			ld (debug_mark+1),a  
2b87 3a 91 2b			ld a, (.dmark+2)  
2b8a 32 7c ee			ld (debug_mark+2),a  
2b8d 18 03			jr .pastdmark  
2b8f ..			.dmark: db "-2e"  
2b92 f1			.pastdmark: pop af  
2b93			endm  
# End of macro DMARK
2b93						CALLMONITOR 
2b93 cd 39 14			call break_point_state  
2b96				endm  
# End of macro CALLMONITOR
2b96					endif 
2b96			 
2b96			 
2b96			 
2b96			 
2b96			 
2b96				       NEXTW 
2b96 c3 2f 1d			jp macro_next 
2b99				endm 
# End of macro NEXTW
2b99			.GET2: 
2b99				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b99 6f				db WORD_SYS_CORE+91             
2b9a c9 2b			dw .BANG2            
2b9c 03				db 2 + 1 
2b9d .. 00			db "2@",0              
2ba0				endm 
# End of macro CWHEAD
2ba0			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ba0					if DEBUG_FORTH_WORDS_KEY 
2ba0						DMARK "2A_" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 7a ee			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 7b ee			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 7c ee			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "2A_"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9						CALLMONITOR 
2bb9 cd 39 14			call break_point_state  
2bbc				endm  
# End of macro CALLMONITOR
2bbc					endif 
2bbc			 
2bbc					FORTH_DSP_VALUEHL 
2bbc cd bd 1b			call macro_dsp_valuehl 
2bbf				endm 
# End of macro FORTH_DSP_VALUEHL
2bbf			 
2bbf 5e					ld e, (hl) 
2bc0 23					inc hl 
2bc1 56					ld d, (hl) 
2bc2			 
2bc2 eb					ex de, hl 
2bc3			 
2bc3 cd c6 19				call forth_push_numhl 
2bc6			 
2bc6				       NEXTW 
2bc6 c3 2f 1d			jp macro_next 
2bc9				endm 
# End of macro NEXTW
2bc9			.BANG2: 
2bc9				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2bc9 6f				db WORD_SYS_CORE+91             
2bca 01 2c			dw .CONFIG            
2bcc 03				db 2 + 1 
2bcd .. 00			db "2!",0              
2bd0				endm 
# End of macro CWHEAD
2bd0			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2bd0					if DEBUG_FORTH_WORDS_KEY 
2bd0						DMARK "2S_" 
2bd0 f5				push af  
2bd1 3a e5 2b			ld a, (.dmark)  
2bd4 32 7a ee			ld (debug_mark),a  
2bd7 3a e6 2b			ld a, (.dmark+1)  
2bda 32 7b ee			ld (debug_mark+1),a  
2bdd 3a e7 2b			ld a, (.dmark+2)  
2be0 32 7c ee			ld (debug_mark+2),a  
2be3 18 03			jr .pastdmark  
2be5 ..			.dmark: db "2S_"  
2be8 f1			.pastdmark: pop af  
2be9			endm  
# End of macro DMARK
2be9						CALLMONITOR 
2be9 cd 39 14			call break_point_state  
2bec				endm  
# End of macro CALLMONITOR
2bec					endif 
2bec			 
2bec					FORTH_DSP_VALUEHL 
2bec cd bd 1b			call macro_dsp_valuehl 
2bef				endm 
# End of macro FORTH_DSP_VALUEHL
2bef			 
2bef e5					push hl   ; save address 
2bf0			 
2bf0			 
2bf0					FORTH_DSP_POP 
2bf0 cd 75 1c			call macro_forth_dsp_pop 
2bf3				endm 
# End of macro FORTH_DSP_POP
2bf3			 
2bf3					 
2bf3					FORTH_DSP_VALUEHL 
2bf3 cd bd 1b			call macro_dsp_valuehl 
2bf6				endm 
# End of macro FORTH_DSP_VALUEHL
2bf6			 
2bf6					FORTH_DSP_POP 
2bf6 cd 75 1c			call macro_forth_dsp_pop 
2bf9				endm 
# End of macro FORTH_DSP_POP
2bf9			 
2bf9 eb					ex de, hl    ; value now in de 
2bfa			 
2bfa e1					pop hl 
2bfb			 
2bfb 73					ld (hl), e 
2bfc			 
2bfc 23					inc hl 
2bfd			 
2bfd 72					ld (hl), d 
2bfe			 
2bfe			 
2bfe				       NEXTW 
2bfe c3 2f 1d			jp macro_next 
2c01				endm 
# End of macro NEXTW
2c01			.CONFIG: 
2c01				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2c01 6f				db WORD_SYS_CORE+91             
2c02 12 2c			dw .ENDCORE            
2c04 07				db 6 + 1 
2c05 .. 00			db "CONFIG",0              
2c0c				endm 
# End of macro CWHEAD
2c0c			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2c0c			 
2c0c cd 26 12				call config 
2c0f					NEXTW 
2c0f c3 2f 1d			jp macro_next 
2c12				endm 
# End of macro NEXTW
2c12			.ENDCORE: 
2c12			 
2c12			; eof 
2c12			 
2c12			 
# End of file forth_words_core.asm
2c12			include "forth_words_flow.asm" 
2c12			 
2c12			; | ## Program Flow Words 
2c12			 
2c12			.IF: 
2c12				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c12 1e				db WORD_SYS_CORE+10             
2c13 07 2d			dw .THEN            
2c15 03				db 2 + 1 
2c16 .. 00			db "IF",0              
2c19				endm 
# End of macro CWHEAD
2c19			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c19			; 
2c19					if DEBUG_FORTH_WORDS_KEY 
2c19						DMARK "IF." 
2c19 f5				push af  
2c1a 3a 2e 2c			ld a, (.dmark)  
2c1d 32 7a ee			ld (debug_mark),a  
2c20 3a 2f 2c			ld a, (.dmark+1)  
2c23 32 7b ee			ld (debug_mark+1),a  
2c26 3a 30 2c			ld a, (.dmark+2)  
2c29 32 7c ee			ld (debug_mark+2),a  
2c2c 18 03			jr .pastdmark  
2c2e ..			.dmark: db "IF."  
2c31 f1			.pastdmark: pop af  
2c32			endm  
# End of macro DMARK
2c32						CALLMONITOR 
2c32 cd 39 14			call break_point_state  
2c35				endm  
# End of macro CALLMONITOR
2c35					endif 
2c35			; eval TOS 
2c35			 
2c35				FORTH_DSP_VALUEHL 
2c35 cd bd 1b			call macro_dsp_valuehl 
2c38				endm 
# End of macro FORTH_DSP_VALUEHL
2c38			 
2c38			;	push hl 
2c38				FORTH_DSP_POP 
2c38 cd 75 1c			call macro_forth_dsp_pop 
2c3b				endm 
# End of macro FORTH_DSP_POP
2c3b			;	pop hl 
2c3b			 
2c3b					if DEBUG_FORTH_WORDS 
2c3b						DMARK "IF1" 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 7a ee			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 7b ee			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 7c ee			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "IF1"  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54						CALLMONITOR 
2c54 cd 39 14			call break_point_state  
2c57				endm  
# End of macro CALLMONITOR
2c57					endif 
2c57 b7				or a        ; clear carry flag 
2c58 11 00 00			ld de, 0 
2c5b eb				ex de,hl 
2c5c ed 52			sbc hl, de 
2c5e c2 e8 2c			jp nz, .iftrue 
2c61			 
2c61					if DEBUG_FORTH_WORDS 
2c61						DMARK "IF2" 
2c61 f5				push af  
2c62 3a 76 2c			ld a, (.dmark)  
2c65 32 7a ee			ld (debug_mark),a  
2c68 3a 77 2c			ld a, (.dmark+1)  
2c6b 32 7b ee			ld (debug_mark+1),a  
2c6e 3a 78 2c			ld a, (.dmark+2)  
2c71 32 7c ee			ld (debug_mark+2),a  
2c74 18 03			jr .pastdmark  
2c76 ..			.dmark: db "IF2"  
2c79 f1			.pastdmark: pop af  
2c7a			endm  
# End of macro DMARK
2c7a						CALLMONITOR 
2c7a cd 39 14			call break_point_state  
2c7d				endm  
# End of macro CALLMONITOR
2c7d					endif 
2c7d			 
2c7d			; if not true then skip to THEN 
2c7d			 
2c7d				; TODO get tok_ptr 
2c7d				; TODO consume toks until we get to THEN 
2c7d			 
2c7d 2a 61 e6			ld hl, (os_tok_ptr) 
2c80					if DEBUG_FORTH_WORDS 
2c80						DMARK "IF3" 
2c80 f5				push af  
2c81 3a 95 2c			ld a, (.dmark)  
2c84 32 7a ee			ld (debug_mark),a  
2c87 3a 96 2c			ld a, (.dmark+1)  
2c8a 32 7b ee			ld (debug_mark+1),a  
2c8d 3a 97 2c			ld a, (.dmark+2)  
2c90 32 7c ee			ld (debug_mark+2),a  
2c93 18 03			jr .pastdmark  
2c95 ..			.dmark: db "IF3"  
2c98 f1			.pastdmark: pop af  
2c99			endm  
# End of macro DMARK
2c99						CALLMONITOR 
2c99 cd 39 14			call break_point_state  
2c9c				endm  
# End of macro CALLMONITOR
2c9c						 
2c9c					endif 
2c9c 11 e3 2c			ld de, .ifthen 
2c9f					if DEBUG_FORTH_WORDS 
2c9f						DMARK "IF4" 
2c9f f5				push af  
2ca0 3a b4 2c			ld a, (.dmark)  
2ca3 32 7a ee			ld (debug_mark),a  
2ca6 3a b5 2c			ld a, (.dmark+1)  
2ca9 32 7b ee			ld (debug_mark+1),a  
2cac 3a b6 2c			ld a, (.dmark+2)  
2caf 32 7c ee			ld (debug_mark+2),a  
2cb2 18 03			jr .pastdmark  
2cb4 ..			.dmark: db "IF4"  
2cb7 f1			.pastdmark: pop af  
2cb8			endm  
# End of macro DMARK
2cb8						CALLMONITOR 
2cb8 cd 39 14			call break_point_state  
2cbb				endm  
# End of macro CALLMONITOR
2cbb					endif 
2cbb cd 4a 1e			call findnexttok  
2cbe			 
2cbe					if DEBUG_FORTH_WORDS 
2cbe						DMARK "IF5" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 7a ee			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 7b ee			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 7c ee			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "IF5"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7						CALLMONITOR 
2cd7 cd 39 14			call break_point_state  
2cda				endm  
# End of macro CALLMONITOR
2cda					endif 
2cda				; TODO replace below with ; exec using tok_ptr 
2cda 22 61 e6			ld (os_tok_ptr), hl 
2cdd c3 c0 1d			jp exec1 
2ce0				NEXTW 
2ce0 c3 2f 1d			jp macro_next 
2ce3				endm 
# End of macro NEXTW
2ce3			 
2ce3 .. 00		.ifthen:  db "THEN",0 
2ce8			 
2ce8			.iftrue:		 
2ce8				; Exec next words normally 
2ce8			 
2ce8				; if true then exec following IF as normal 
2ce8					if DEBUG_FORTH_WORDS 
2ce8						DMARK "IFT" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 7a ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 7b ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 7c ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "IFT"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd 39 14			call break_point_state  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04					NEXTW 
2d04 c3 2f 1d			jp macro_next 
2d07				endm 
# End of macro NEXTW
2d07			.THEN: 
2d07				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2d07 1f				db WORD_SYS_CORE+11             
2d08 2f 2d			dw .ELSE            
2d0a 05				db 4 + 1 
2d0b .. 00			db "THEN",0              
2d10				endm 
# End of macro CWHEAD
2d10			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d10					if DEBUG_FORTH_WORDS_KEY 
2d10						DMARK "THN" 
2d10 f5				push af  
2d11 3a 25 2d			ld a, (.dmark)  
2d14 32 7a ee			ld (debug_mark),a  
2d17 3a 26 2d			ld a, (.dmark+1)  
2d1a 32 7b ee			ld (debug_mark+1),a  
2d1d 3a 27 2d			ld a, (.dmark+2)  
2d20 32 7c ee			ld (debug_mark+2),a  
2d23 18 03			jr .pastdmark  
2d25 ..			.dmark: db "THN"  
2d28 f1			.pastdmark: pop af  
2d29			endm  
# End of macro DMARK
2d29						CALLMONITOR 
2d29 cd 39 14			call break_point_state  
2d2c				endm  
# End of macro CALLMONITOR
2d2c					endif 
2d2c					NEXTW 
2d2c c3 2f 1d			jp macro_next 
2d2f				endm 
# End of macro NEXTW
2d2f			.ELSE: 
2d2f				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2d2f 20				db WORD_SYS_CORE+12             
2d30 57 2d			dw .DO            
2d32 03				db 2 + 1 
2d33 .. 00			db "ELSE",0              
2d38				endm 
# End of macro CWHEAD
2d38			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d38			 
2d38					if DEBUG_FORTH_WORDS_KEY 
2d38						DMARK "ELS" 
2d38 f5				push af  
2d39 3a 4d 2d			ld a, (.dmark)  
2d3c 32 7a ee			ld (debug_mark),a  
2d3f 3a 4e 2d			ld a, (.dmark+1)  
2d42 32 7b ee			ld (debug_mark+1),a  
2d45 3a 4f 2d			ld a, (.dmark+2)  
2d48 32 7c ee			ld (debug_mark+2),a  
2d4b 18 03			jr .pastdmark  
2d4d ..			.dmark: db "ELS"  
2d50 f1			.pastdmark: pop af  
2d51			endm  
# End of macro DMARK
2d51						CALLMONITOR 
2d51 cd 39 14			call break_point_state  
2d54				endm  
# End of macro CALLMONITOR
2d54					endif 
2d54			 
2d54			 
2d54					NEXTW 
2d54 c3 2f 1d			jp macro_next 
2d57				endm 
# End of macro NEXTW
2d57			.DO: 
2d57				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d57 21				db WORD_SYS_CORE+13             
2d58 7e 2e			dw .LOOP            
2d5a 03				db 2 + 1 
2d5b .. 00			db "DO",0              
2d5e				endm 
# End of macro CWHEAD
2d5e			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d5e			 
2d5e					if DEBUG_FORTH_WORDS_KEY 
2d5e						DMARK "DO." 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 7a ee			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 7b ee			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 7c ee			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "DO."  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77						CALLMONITOR 
2d77 cd 39 14			call break_point_state  
2d7a				endm  
# End of macro CALLMONITOR
2d7a					endif 
2d7a			;  push pc to rsp stack past the DO 
2d7a			 
2d7a 2a 61 e6				ld hl, (os_tok_ptr) 
2d7d 23					inc hl   ; D 
2d7e 23					inc hl  ; O 
2d7f 23					inc hl   ; null 
2d80					if DEBUG_FORTH_WORDS 
2d80						DMARK "DO2" 
2d80 f5				push af  
2d81 3a 95 2d			ld a, (.dmark)  
2d84 32 7a ee			ld (debug_mark),a  
2d87 3a 96 2d			ld a, (.dmark+1)  
2d8a 32 7b ee			ld (debug_mark+1),a  
2d8d 3a 97 2d			ld a, (.dmark+2)  
2d90 32 7c ee			ld (debug_mark+2),a  
2d93 18 03			jr .pastdmark  
2d95 ..			.dmark: db "DO2"  
2d98 f1			.pastdmark: pop af  
2d99			endm  
# End of macro DMARK
2d99						CALLMONITOR 
2d99 cd 39 14			call break_point_state  
2d9c				endm  
# End of macro CALLMONITOR
2d9c					endif 
2d9c					FORTH_RSP_NEXT 
2d9c cd 6d 19			call macro_forth_rsp_next 
2d9f				endm 
# End of macro FORTH_RSP_NEXT
2d9f					if DEBUG_FORTH_WORDS 
2d9f						DMARK "DO3" 
2d9f f5				push af  
2da0 3a b4 2d			ld a, (.dmark)  
2da3 32 7a ee			ld (debug_mark),a  
2da6 3a b5 2d			ld a, (.dmark+1)  
2da9 32 7b ee			ld (debug_mark+1),a  
2dac 3a b6 2d			ld a, (.dmark+2)  
2daf 32 7c ee			ld (debug_mark+2),a  
2db2 18 03			jr .pastdmark  
2db4 ..			.dmark: db "DO3"  
2db7 f1			.pastdmark: pop af  
2db8			endm  
# End of macro DMARK
2db8						CALLMONITOR 
2db8 cd 39 14			call break_point_state  
2dbb				endm  
# End of macro CALLMONITOR
2dbb					endif 
2dbb			 
2dbb					;if DEBUG_FORTH_WORDS 
2dbb				;		push hl 
2dbb			;		endif  
2dbb			 
2dbb			; get counters from data stack 
2dbb			 
2dbb			 
2dbb					FORTH_DSP_VALUEHL 
2dbb cd bd 1b			call macro_dsp_valuehl 
2dbe				endm 
# End of macro FORTH_DSP_VALUEHL
2dbe e5					push hl		 ; hl now has starting counter which needs to be tos 
2dbf			 
2dbf					if DEBUG_FORTH_WORDS 
2dbf						DMARK "DO4" 
2dbf f5				push af  
2dc0 3a d4 2d			ld a, (.dmark)  
2dc3 32 7a ee			ld (debug_mark),a  
2dc6 3a d5 2d			ld a, (.dmark+1)  
2dc9 32 7b ee			ld (debug_mark+1),a  
2dcc 3a d6 2d			ld a, (.dmark+2)  
2dcf 32 7c ee			ld (debug_mark+2),a  
2dd2 18 03			jr .pastdmark  
2dd4 ..			.dmark: db "DO4"  
2dd7 f1			.pastdmark: pop af  
2dd8			endm  
# End of macro DMARK
2dd8						CALLMONITOR 
2dd8 cd 39 14			call break_point_state  
2ddb				endm  
# End of macro CALLMONITOR
2ddb					endif 
2ddb					FORTH_DSP_POP 
2ddb cd 75 1c			call macro_forth_dsp_pop 
2dde				endm 
# End of macro FORTH_DSP_POP
2dde			 
2dde					if DEBUG_FORTH_WORDS 
2dde						DMARK "DO5" 
2dde f5				push af  
2ddf 3a f3 2d			ld a, (.dmark)  
2de2 32 7a ee			ld (debug_mark),a  
2de5 3a f4 2d			ld a, (.dmark+1)  
2de8 32 7b ee			ld (debug_mark+1),a  
2deb 3a f5 2d			ld a, (.dmark+2)  
2dee 32 7c ee			ld (debug_mark+2),a  
2df1 18 03			jr .pastdmark  
2df3 ..			.dmark: db "DO5"  
2df6 f1			.pastdmark: pop af  
2df7			endm  
# End of macro DMARK
2df7						CALLMONITOR 
2df7 cd 39 14			call break_point_state  
2dfa				endm  
# End of macro CALLMONITOR
2dfa					endif 
2dfa			 
2dfa					FORTH_DSP_VALUEHL 
2dfa cd bd 1b			call macro_dsp_valuehl 
2dfd				endm 
# End of macro FORTH_DSP_VALUEHL
2dfd			;		push hl		 ; hl now has starting limit counter 
2dfd			 
2dfd					if DEBUG_FORTH_WORDS 
2dfd						DMARK "DO6" 
2dfd f5				push af  
2dfe 3a 12 2e			ld a, (.dmark)  
2e01 32 7a ee			ld (debug_mark),a  
2e04 3a 13 2e			ld a, (.dmark+1)  
2e07 32 7b ee			ld (debug_mark+1),a  
2e0a 3a 14 2e			ld a, (.dmark+2)  
2e0d 32 7c ee			ld (debug_mark+2),a  
2e10 18 03			jr .pastdmark  
2e12 ..			.dmark: db "DO6"  
2e15 f1			.pastdmark: pop af  
2e16			endm  
# End of macro DMARK
2e16						CALLMONITOR 
2e16 cd 39 14			call break_point_state  
2e19				endm  
# End of macro CALLMONITOR
2e19					endif 
2e19					FORTH_DSP_POP 
2e19 cd 75 1c			call macro_forth_dsp_pop 
2e1c				endm 
# End of macro FORTH_DSP_POP
2e1c			 
2e1c			; put counters on the loop stack 
2e1c			 
2e1c			;		pop hl			 ; limit counter 
2e1c d1					pop de			; start counter 
2e1d			 
2e1d					; push limit counter 
2e1d			 
2e1d					if DEBUG_FORTH_WORDS 
2e1d						DMARK "DO7" 
2e1d f5				push af  
2e1e 3a 32 2e			ld a, (.dmark)  
2e21 32 7a ee			ld (debug_mark),a  
2e24 3a 33 2e			ld a, (.dmark+1)  
2e27 32 7b ee			ld (debug_mark+1),a  
2e2a 3a 34 2e			ld a, (.dmark+2)  
2e2d 32 7c ee			ld (debug_mark+2),a  
2e30 18 03			jr .pastdmark  
2e32 ..			.dmark: db "DO7"  
2e35 f1			.pastdmark: pop af  
2e36			endm  
# End of macro DMARK
2e36						CALLMONITOR 
2e36 cd 39 14			call break_point_state  
2e39				endm  
# End of macro CALLMONITOR
2e39					endif 
2e39					FORTH_LOOP_NEXT 
2e39 cd ee 1b			call macro_forth_loop_next 
2e3c				endm 
# End of macro FORTH_LOOP_NEXT
2e3c			 
2e3c					; push start counter 
2e3c			 
2e3c eb					ex de, hl 
2e3d					if DEBUG_FORTH_WORDS 
2e3d						DMARK "DO7" 
2e3d f5				push af  
2e3e 3a 52 2e			ld a, (.dmark)  
2e41 32 7a ee			ld (debug_mark),a  
2e44 3a 53 2e			ld a, (.dmark+1)  
2e47 32 7b ee			ld (debug_mark+1),a  
2e4a 3a 54 2e			ld a, (.dmark+2)  
2e4d 32 7c ee			ld (debug_mark+2),a  
2e50 18 03			jr .pastdmark  
2e52 ..			.dmark: db "DO7"  
2e55 f1			.pastdmark: pop af  
2e56			endm  
# End of macro DMARK
2e56						CALLMONITOR 
2e56 cd 39 14			call break_point_state  
2e59				endm  
# End of macro CALLMONITOR
2e59					endif 
2e59					FORTH_LOOP_NEXT 
2e59 cd ee 1b			call macro_forth_loop_next 
2e5c				endm 
# End of macro FORTH_LOOP_NEXT
2e5c			 
2e5c			 
2e5c					; init first round of I counter 
2e5c			 
2e5c 22 85 e6				ld (os_current_i), hl 
2e5f			 
2e5f					if DEBUG_FORTH_WORDS 
2e5f						DMARK "DO8" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 7a ee			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 7b ee			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 7c ee			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "DO8"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78						CALLMONITOR 
2e78 cd 39 14			call break_point_state  
2e7b				endm  
# End of macro CALLMONITOR
2e7b					endif 
2e7b			 
2e7b					NEXTW 
2e7b c3 2f 1d			jp macro_next 
2e7e				endm 
# End of macro NEXTW
2e7e			.LOOP: 
2e7e				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e7e 22				db WORD_SYS_CORE+14             
2e7f 96 2f			dw .I            
2e81 05				db 4 + 1 
2e82 .. 00			db "LOOP",0              
2e87				endm 
# End of macro CWHEAD
2e87			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e87			 
2e87				; pop tos as current loop count to hl 
2e87			 
2e87				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e87			 
2e87				FORTH_LOOP_TOS 
2e87 cd 21 1c			call macro_forth_loop_tos 
2e8a				endm 
# End of macro FORTH_LOOP_TOS
2e8a e5				push hl 
2e8b			 
2e8b					if DEBUG_FORTH_WORDS_KEY 
2e8b						DMARK "LOP" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 7a ee			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 7b ee			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 7c ee			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "LOP"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd 39 14			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7				; next item on the stack is the limit. get it 
2ea7			 
2ea7			 
2ea7				FORTH_LOOP_POP 
2ea7 cd 2b 1c			call macro_forth_loop_pop 
2eaa				endm 
# End of macro FORTH_LOOP_POP
2eaa			 
2eaa				FORTH_LOOP_TOS 
2eaa cd 21 1c			call macro_forth_loop_tos 
2ead				endm 
# End of macro FORTH_LOOP_TOS
2ead			 
2ead d1				pop de		 ; de = i, hl = limit 
2eae			 
2eae					if DEBUG_FORTH_WORDS 
2eae						DMARK "LP1" 
2eae f5				push af  
2eaf 3a c3 2e			ld a, (.dmark)  
2eb2 32 7a ee			ld (debug_mark),a  
2eb5 3a c4 2e			ld a, (.dmark+1)  
2eb8 32 7b ee			ld (debug_mark+1),a  
2ebb 3a c5 2e			ld a, (.dmark+2)  
2ebe 32 7c ee			ld (debug_mark+2),a  
2ec1 18 03			jr .pastdmark  
2ec3 ..			.dmark: db "LP1"  
2ec6 f1			.pastdmark: pop af  
2ec7			endm  
# End of macro DMARK
2ec7						CALLMONITOR 
2ec7 cd 39 14			call break_point_state  
2eca				endm  
# End of macro CALLMONITOR
2eca					endif 
2eca			 
2eca				; go back to previous word 
2eca			 
2eca d5				push de    ; save I for inc later 
2ecb			 
2ecb			 
2ecb				; get limit 
2ecb				;  is I at limit? 
2ecb			 
2ecb			 
2ecb					if DEBUG_FORTH_WORDS 
2ecb						DMARK "LP1" 
2ecb f5				push af  
2ecc 3a e0 2e			ld a, (.dmark)  
2ecf 32 7a ee			ld (debug_mark),a  
2ed2 3a e1 2e			ld a, (.dmark+1)  
2ed5 32 7b ee			ld (debug_mark+1),a  
2ed8 3a e2 2e			ld a, (.dmark+2)  
2edb 32 7c ee			ld (debug_mark+2),a  
2ede 18 03			jr .pastdmark  
2ee0 ..			.dmark: db "LP1"  
2ee3 f1			.pastdmark: pop af  
2ee4			endm  
# End of macro DMARK
2ee4						CALLMONITOR 
2ee4 cd 39 14			call break_point_state  
2ee7				endm  
# End of macro CALLMONITOR
2ee7					endif 
2ee7			 
2ee7 ed 52			sbc hl, de 
2ee9			 
2ee9			 
2ee9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2ee9			 
2ee9 20 26				jr nz, .loopnotdone 
2eeb			 
2eeb e1				pop hl   ; get rid of saved I 
2eec				FORTH_LOOP_POP     ; get rid of limit 
2eec cd 2b 1c			call macro_forth_loop_pop 
2eef				endm 
# End of macro FORTH_LOOP_POP
2eef			 
2eef				FORTH_RSP_POP     ; get rid of DO ptr 
2eef cd 8e 19			call macro_forth_rsp_pop 
2ef2				endm 
# End of macro FORTH_RSP_POP
2ef2			 
2ef2			if DEBUG_FORTH_WORDS 
2ef2						DMARK "LP>" 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 7a ee			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 7b ee			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 7c ee			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db "LP>"  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b				CALLMONITOR 
2f0b cd 39 14			call break_point_state  
2f0e				endm  
# End of macro CALLMONITOR
2f0e			endif 
2f0e			 
2f0e					NEXTW 
2f0e c3 2f 1d			jp macro_next 
2f11				endm 
# End of macro NEXTW
2f11				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f11			 
2f11			.loopnotdone: 
2f11			 
2f11 e1				pop hl    ; get I 
2f12 23				inc hl 
2f13			 
2f13			   	; save new I 
2f13			 
2f13			 
2f13					; set I counter 
2f13			 
2f13 22 85 e6				ld (os_current_i), hl 
2f16			 
2f16					if DEBUG_FORTH_WORDS 
2f16						DMARK "LPN" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 7a ee			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 7b ee			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 7c ee			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "LPN"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f					CALLMONITOR 
2f2f cd 39 14			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32					endif 
2f32					 
2f32				FORTH_LOOP_NEXT 
2f32 cd ee 1b			call macro_forth_loop_next 
2f35				endm 
# End of macro FORTH_LOOP_NEXT
2f35			 
2f35			 
2f35					if DEBUG_FORTH_WORDS 
2f35 eb						ex de,hl 
2f36					endif 
2f36			 
2f36			;	; get DO ptr 
2f36			; 
2f36					if DEBUG_FORTH_WORDS 
2f36						DMARK "LP7" 
2f36 f5				push af  
2f37 3a 4b 2f			ld a, (.dmark)  
2f3a 32 7a ee			ld (debug_mark),a  
2f3d 3a 4c 2f			ld a, (.dmark+1)  
2f40 32 7b ee			ld (debug_mark+1),a  
2f43 3a 4d 2f			ld a, (.dmark+2)  
2f46 32 7c ee			ld (debug_mark+2),a  
2f49 18 03			jr .pastdmark  
2f4b ..			.dmark: db "LP7"  
2f4e f1			.pastdmark: pop af  
2f4f			endm  
# End of macro DMARK
2f4f					CALLMONITOR 
2f4f cd 39 14			call break_point_state  
2f52				endm  
# End of macro CALLMONITOR
2f52					endif 
2f52				FORTH_RSP_TOS 
2f52 cd 84 19			call macro_forth_rsp_tos 
2f55				endm 
# End of macro FORTH_RSP_TOS
2f55			 
2f55					if DEBUG_FORTH_WORDS 
2f55						DMARK "LP8" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 7a ee			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 7b ee			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 7c ee			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "LP8"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e					CALLMONITOR 
2f6e cd 39 14			call break_point_state  
2f71				endm  
# End of macro CALLMONITOR
2f71					endif 
2f71				;push hl 
2f71			 
2f71				; not going to DO any more 
2f71				; get rid of the RSP pointer as DO will add it back in 
2f71				;FORTH_RSP_POP 
2f71				;pop hl 
2f71			 
2f71				;ld hl,(cli_ret_sp) 
2f71				;ld e, (hl) 
2f71				;inc hl 
2f71				;ld d, (hl) 
2f71				;ex de,hl 
2f71 22 61 e6			ld (os_tok_ptr), hl 
2f74					if DEBUG_FORTH_WORDS 
2f74						DMARK "LP<" 
2f74 f5				push af  
2f75 3a 89 2f			ld a, (.dmark)  
2f78 32 7a ee			ld (debug_mark),a  
2f7b 3a 8a 2f			ld a, (.dmark+1)  
2f7e 32 7b ee			ld (debug_mark+1),a  
2f81 3a 8b 2f			ld a, (.dmark+2)  
2f84 32 7c ee			ld (debug_mark+2),a  
2f87 18 03			jr .pastdmark  
2f89 ..			.dmark: db "LP<"  
2f8c f1			.pastdmark: pop af  
2f8d			endm  
# End of macro DMARK
2f8d					CALLMONITOR 
2f8d cd 39 14			call break_point_state  
2f90				endm  
# End of macro CALLMONITOR
2f90				endif 
2f90 c3 c0 1d			jp exec1 
2f93			 
2f93					 
2f93			 
2f93			 
2f93					NEXTW 
2f93 c3 2f 1d			jp macro_next 
2f96				endm 
# End of macro NEXTW
2f96			.I:  
2f96			 
2f96				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f96 5e				db WORD_SYS_CORE+74             
2f97 c1 2f			dw .DLOOP            
2f99 02				db 1 + 1 
2f9a .. 00			db "I",0              
2f9c				endm 
# End of macro CWHEAD
2f9c			; | I ( -- ) Current loop counter | DONE 
2f9c					if DEBUG_FORTH_WORDS_KEY 
2f9c						DMARK "I.." 
2f9c f5				push af  
2f9d 3a b1 2f			ld a, (.dmark)  
2fa0 32 7a ee			ld (debug_mark),a  
2fa3 3a b2 2f			ld a, (.dmark+1)  
2fa6 32 7b ee			ld (debug_mark+1),a  
2fa9 3a b3 2f			ld a, (.dmark+2)  
2fac 32 7c ee			ld (debug_mark+2),a  
2faf 18 03			jr .pastdmark  
2fb1 ..			.dmark: db "I.."  
2fb4 f1			.pastdmark: pop af  
2fb5			endm  
# End of macro DMARK
2fb5						CALLMONITOR 
2fb5 cd 39 14			call break_point_state  
2fb8				endm  
# End of macro CALLMONITOR
2fb8					endif 
2fb8			 
2fb8 2a 85 e6				ld hl,(os_current_i) 
2fbb cd c6 19				call forth_push_numhl 
2fbe			 
2fbe					NEXTW 
2fbe c3 2f 1d			jp macro_next 
2fc1				endm 
# End of macro NEXTW
2fc1			.DLOOP: 
2fc1				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2fc1 5f				db WORD_SYS_CORE+75             
2fc2 a2 30			dw .REPEAT            
2fc4 06				db 5 + 1 
2fc5 .. 00			db "-LOOP",0              
2fcb				endm 
# End of macro CWHEAD
2fcb			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2fcb				; pop tos as current loop count to hl 
2fcb					if DEBUG_FORTH_WORDS_KEY 
2fcb						DMARK "-LP" 
2fcb f5				push af  
2fcc 3a e0 2f			ld a, (.dmark)  
2fcf 32 7a ee			ld (debug_mark),a  
2fd2 3a e1 2f			ld a, (.dmark+1)  
2fd5 32 7b ee			ld (debug_mark+1),a  
2fd8 3a e2 2f			ld a, (.dmark+2)  
2fdb 32 7c ee			ld (debug_mark+2),a  
2fde 18 03			jr .pastdmark  
2fe0 ..			.dmark: db "-LP"  
2fe3 f1			.pastdmark: pop af  
2fe4			endm  
# End of macro DMARK
2fe4						CALLMONITOR 
2fe4 cd 39 14			call break_point_state  
2fe7				endm  
# End of macro CALLMONITOR
2fe7					endif 
2fe7			 
2fe7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2fe7			 
2fe7				FORTH_LOOP_TOS 
2fe7 cd 21 1c			call macro_forth_loop_tos 
2fea				endm 
# End of macro FORTH_LOOP_TOS
2fea e5				push hl 
2feb			 
2feb					if DEBUG_FORTH_WORDS 
2feb						DMARK "-LP" 
2feb f5				push af  
2fec 3a 00 30			ld a, (.dmark)  
2fef 32 7a ee			ld (debug_mark),a  
2ff2 3a 01 30			ld a, (.dmark+1)  
2ff5 32 7b ee			ld (debug_mark+1),a  
2ff8 3a 02 30			ld a, (.dmark+2)  
2ffb 32 7c ee			ld (debug_mark+2),a  
2ffe 18 03			jr .pastdmark  
3000 ..			.dmark: db "-LP"  
3003 f1			.pastdmark: pop af  
3004			endm  
# End of macro DMARK
3004						CALLMONITOR 
3004 cd 39 14			call break_point_state  
3007				endm  
# End of macro CALLMONITOR
3007					endif 
3007				; next item on the stack is the limit. get it 
3007			 
3007			 
3007				FORTH_LOOP_POP 
3007 cd 2b 1c			call macro_forth_loop_pop 
300a				endm 
# End of macro FORTH_LOOP_POP
300a			 
300a				FORTH_LOOP_TOS 
300a cd 21 1c			call macro_forth_loop_tos 
300d				endm 
# End of macro FORTH_LOOP_TOS
300d			 
300d d1				pop de		 ; de = i, hl = limit 
300e			 
300e					if DEBUG_FORTH_WORDS 
300e						DMARK "-L1" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 7a ee			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 7b ee			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 7c ee			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "-L1"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027						CALLMONITOR 
3027 cd 39 14			call break_point_state  
302a				endm  
# End of macro CALLMONITOR
302a					endif 
302a			 
302a				; go back to previous word 
302a			 
302a d5				push de    ; save I for inc later 
302b			 
302b			 
302b				; get limit 
302b				;  is I at limit? 
302b			 
302b			 
302b					if DEBUG_FORTH_WORDS 
302b						DMARK "-L1" 
302b f5				push af  
302c 3a 40 30			ld a, (.dmark)  
302f 32 7a ee			ld (debug_mark),a  
3032 3a 41 30			ld a, (.dmark+1)  
3035 32 7b ee			ld (debug_mark+1),a  
3038 3a 42 30			ld a, (.dmark+2)  
303b 32 7c ee			ld (debug_mark+2),a  
303e 18 03			jr .pastdmark  
3040 ..			.dmark: db "-L1"  
3043 f1			.pastdmark: pop af  
3044			endm  
# End of macro DMARK
3044						CALLMONITOR 
3044 cd 39 14			call break_point_state  
3047				endm  
# End of macro CALLMONITOR
3047					endif 
3047			 
3047 ed 52			sbc hl, de 
3049			 
3049			 
3049				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3049			 
3049 20 26				jr nz, .mloopnotdone 
304b			 
304b e1				pop hl   ; get rid of saved I 
304c				FORTH_LOOP_POP     ; get rid of limit 
304c cd 2b 1c			call macro_forth_loop_pop 
304f				endm 
# End of macro FORTH_LOOP_POP
304f			 
304f				FORTH_RSP_POP     ; get rid of DO ptr 
304f cd 8e 19			call macro_forth_rsp_pop 
3052				endm 
# End of macro FORTH_RSP_POP
3052			 
3052			if DEBUG_FORTH_WORDS 
3052						DMARK "-L>" 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 7a ee			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 7b ee			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 7c ee			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "-L>"  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b				CALLMONITOR 
306b cd 39 14			call break_point_state  
306e				endm  
# End of macro CALLMONITOR
306e			endif 
306e			 
306e					NEXTW 
306e c3 2f 1d			jp macro_next 
3071				endm 
# End of macro NEXTW
3071				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3071			 
3071			.mloopnotdone: 
3071			 
3071 e1				pop hl    ; get I 
3072 2b				dec hl 
3073			 
3073			   	; save new I 
3073			 
3073			 
3073					; set I counter 
3073			 
3073 22 85 e6				ld (os_current_i), hl 
3076			 
3076					 
3076				FORTH_LOOP_NEXT 
3076 cd ee 1b			call macro_forth_loop_next 
3079				endm 
# End of macro FORTH_LOOP_NEXT
3079			 
3079			 
3079					if DEBUG_FORTH_WORDS 
3079 eb						ex de,hl 
307a					endif 
307a			 
307a			;	; get DO ptr 
307a			; 
307a				FORTH_RSP_TOS 
307a cd 84 19			call macro_forth_rsp_tos 
307d				endm 
# End of macro FORTH_RSP_TOS
307d			 
307d				;push hl 
307d			 
307d				; not going to DO any more 
307d				; get rid of the RSP pointer as DO will add it back in 
307d				;FORTH_RSP_POP 
307d				;pop hl 
307d			 
307d			 
307d 22 61 e6			ld (os_tok_ptr), hl 
3080					if DEBUG_FORTH_WORDS 
3080						DMARK "-L<" 
3080 f5				push af  
3081 3a 95 30			ld a, (.dmark)  
3084 32 7a ee			ld (debug_mark),a  
3087 3a 96 30			ld a, (.dmark+1)  
308a 32 7b ee			ld (debug_mark+1),a  
308d 3a 97 30			ld a, (.dmark+2)  
3090 32 7c ee			ld (debug_mark+2),a  
3093 18 03			jr .pastdmark  
3095 ..			.dmark: db "-L<"  
3098 f1			.pastdmark: pop af  
3099			endm  
# End of macro DMARK
3099					CALLMONITOR 
3099 cd 39 14			call break_point_state  
309c				endm  
# End of macro CALLMONITOR
309c				endif 
309c c3 c0 1d			jp exec1 
309f			 
309f					 
309f			 
309f			 
309f			 
309f				NEXTW 
309f c3 2f 1d			jp macro_next 
30a2				endm 
# End of macro NEXTW
30a2			 
30a2			 
30a2			 
30a2			 
30a2			.REPEAT: 
30a2				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
30a2 71				db WORD_SYS_CORE+93             
30a3 f5 30			dw .UNTIL            
30a5 06				db 5 + 1 
30a6 .. 00			db "REPEAT",0              
30ad				endm 
# End of macro CWHEAD
30ad			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
30ad			;  push pc to rsp stack past the REPEAT 
30ad					if DEBUG_FORTH_WORDS_KEY 
30ad						DMARK "REP" 
30ad f5				push af  
30ae 3a c2 30			ld a, (.dmark)  
30b1 32 7a ee			ld (debug_mark),a  
30b4 3a c3 30			ld a, (.dmark+1)  
30b7 32 7b ee			ld (debug_mark+1),a  
30ba 3a c4 30			ld a, (.dmark+2)  
30bd 32 7c ee			ld (debug_mark+2),a  
30c0 18 03			jr .pastdmark  
30c2 ..			.dmark: db "REP"  
30c5 f1			.pastdmark: pop af  
30c6			endm  
# End of macro DMARK
30c6						CALLMONITOR 
30c6 cd 39 14			call break_point_state  
30c9				endm  
# End of macro CALLMONITOR
30c9					endif 
30c9			 
30c9 2a 61 e6				ld hl, (os_tok_ptr) 
30cc 23					inc hl   ; R 
30cd 23					inc hl  ; E 
30ce 23					inc hl   ; P 
30cf 23					inc hl   ; E 
30d0 23					inc hl   ; A 
30d1 23					inc hl   ; T 
30d2 23					inc hl   ; zero 
30d3					FORTH_RSP_NEXT 
30d3 cd 6d 19			call macro_forth_rsp_next 
30d6				endm 
# End of macro FORTH_RSP_NEXT
30d6			 
30d6			 
30d6					if DEBUG_FORTH_WORDS 
30d6						DMARK "REP" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 7a ee			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 7b ee			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 7c ee			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "REP"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						;pop bc    ; TODO BUG ?????? what is this for???? 
30ef						CALLMONITOR 
30ef cd 39 14			call break_point_state  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2			 
30f2					NEXTW 
30f2 c3 2f 1d			jp macro_next 
30f5				endm 
# End of macro NEXTW
30f5			;	       NEXTW 
30f5			 
30f5			.UNTIL: 
30f5				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
30f5 72				db WORD_SYS_CORE+94             
30f6 8c 31			dw .ENDFLOW            
30f8 06				db 5 + 1 
30f9 .. 00			db "UNTIL",0              
30ff				endm 
# End of macro CWHEAD
30ff			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
30ff			 
30ff				; pop tos as check 
30ff			 
30ff				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30ff			 
30ff				FORTH_DSP_VALUEHL 
30ff cd bd 1b			call macro_dsp_valuehl 
3102				endm 
# End of macro FORTH_DSP_VALUEHL
3102			 
3102					if DEBUG_FORTH_WORDS_KEY 
3102						DMARK "UNT" 
3102 f5				push af  
3103 3a 17 31			ld a, (.dmark)  
3106 32 7a ee			ld (debug_mark),a  
3109 3a 18 31			ld a, (.dmark+1)  
310c 32 7b ee			ld (debug_mark+1),a  
310f 3a 19 31			ld a, (.dmark+2)  
3112 32 7c ee			ld (debug_mark+2),a  
3115 18 03			jr .pastdmark  
3117 ..			.dmark: db "UNT"  
311a f1			.pastdmark: pop af  
311b			endm  
# End of macro DMARK
311b						CALLMONITOR 
311b cd 39 14			call break_point_state  
311e				endm  
# End of macro CALLMONITOR
311e					endif 
311e			 
311e			;	push hl 
311e				FORTH_DSP_POP 
311e cd 75 1c			call macro_forth_dsp_pop 
3121				endm 
# End of macro FORTH_DSP_POP
3121			 
3121			;	pop hl 
3121			 
3121				; test if true 
3121			 
3121 cd ef 0b			call ishlzero 
3124			;	ld a,l 
3124			;	add h 
3124			; 
3124			;	cp 0 
3124			 
3124 20 3e			jr nz, .untilnotdone 
3126			 
3126					if DEBUG_FORTH_WORDS 
3126						DMARK "UNf" 
3126 f5				push af  
3127 3a 3b 31			ld a, (.dmark)  
312a 32 7a ee			ld (debug_mark),a  
312d 3a 3c 31			ld a, (.dmark+1)  
3130 32 7b ee			ld (debug_mark+1),a  
3133 3a 3d 31			ld a, (.dmark+2)  
3136 32 7c ee			ld (debug_mark+2),a  
3139 18 03			jr .pastdmark  
313b ..			.dmark: db "UNf"  
313e f1			.pastdmark: pop af  
313f			endm  
# End of macro DMARK
313f						CALLMONITOR 
313f cd 39 14			call break_point_state  
3142				endm  
# End of macro CALLMONITOR
3142					endif 
3142			 
3142			 
3142			 
3142				FORTH_RSP_POP     ; get rid of DO ptr 
3142 cd 8e 19			call macro_forth_rsp_pop 
3145				endm 
# End of macro FORTH_RSP_POP
3145			 
3145			if DEBUG_FORTH_WORDS 
3145						DMARK "UN>" 
3145 f5				push af  
3146 3a 5a 31			ld a, (.dmark)  
3149 32 7a ee			ld (debug_mark),a  
314c 3a 5b 31			ld a, (.dmark+1)  
314f 32 7b ee			ld (debug_mark+1),a  
3152 3a 5c 31			ld a, (.dmark+2)  
3155 32 7c ee			ld (debug_mark+2),a  
3158 18 03			jr .pastdmark  
315a ..			.dmark: db "UN>"  
315d f1			.pastdmark: pop af  
315e			endm  
# End of macro DMARK
315e				CALLMONITOR 
315e cd 39 14			call break_point_state  
3161				endm  
# End of macro CALLMONITOR
3161			endif 
3161			 
3161					NEXTW 
3161 c3 2f 1d			jp macro_next 
3164				endm 
# End of macro NEXTW
3164				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3164			 
3164			.untilnotdone: 
3164			 
3164			 
3164			;	; get DO ptr 
3164			; 
3164				FORTH_RSP_TOS 
3164 cd 84 19			call macro_forth_rsp_tos 
3167				endm 
# End of macro FORTH_RSP_TOS
3167			 
3167				;push hl 
3167			 
3167				; not going to DO any more 
3167				; get rid of the RSP pointer as DO will add it back in 
3167				;FORTH_RSP_POP 
3167				;pop hl 
3167			 
3167			 
3167 22 61 e6			ld (os_tok_ptr), hl 
316a					if DEBUG_FORTH_WORDS 
316a						DMARK "UN<" 
316a f5				push af  
316b 3a 7f 31			ld a, (.dmark)  
316e 32 7a ee			ld (debug_mark),a  
3171 3a 80 31			ld a, (.dmark+1)  
3174 32 7b ee			ld (debug_mark+1),a  
3177 3a 81 31			ld a, (.dmark+2)  
317a 32 7c ee			ld (debug_mark+2),a  
317d 18 03			jr .pastdmark  
317f ..			.dmark: db "UN<"  
3182 f1			.pastdmark: pop af  
3183			endm  
# End of macro DMARK
3183					CALLMONITOR 
3183 cd 39 14			call break_point_state  
3186				endm  
# End of macro CALLMONITOR
3186				endif 
3186 c3 c0 1d			jp exec1 
3189			 
3189					 
3189			 
3189			 
3189					NEXTW 
3189 c3 2f 1d			jp macro_next 
318c				endm 
# End of macro NEXTW
318c			 
318c			 
318c			.ENDFLOW: 
318c			 
318c			; eof 
318c			 
# End of file forth_words_flow.asm
318c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
318c			include "forth_words_logic.asm" 
318c			 
318c			; | ## Logic Words 
318c			 
318c			.NOT: 
318c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
318c 2d				db WORD_SYS_CORE+25             
318d d4 31			dw .IS            
318f 04				db 3 + 1 
3190 .. 00			db "NOT",0              
3194				endm 
# End of macro CWHEAD
3194			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3194					if DEBUG_FORTH_WORDS_KEY 
3194						DMARK "NOT" 
3194 f5				push af  
3195 3a a9 31			ld a, (.dmark)  
3198 32 7a ee			ld (debug_mark),a  
319b 3a aa 31			ld a, (.dmark+1)  
319e 32 7b ee			ld (debug_mark+1),a  
31a1 3a ab 31			ld a, (.dmark+2)  
31a4 32 7c ee			ld (debug_mark+2),a  
31a7 18 03			jr .pastdmark  
31a9 ..			.dmark: db "NOT"  
31ac f1			.pastdmark: pop af  
31ad			endm  
# End of macro DMARK
31ad						CALLMONITOR 
31ad cd 39 14			call break_point_state  
31b0				endm  
# End of macro CALLMONITOR
31b0					endif 
31b0					FORTH_DSP 
31b0 cd 83 1b			call macro_forth_dsp 
31b3				endm 
# End of macro FORTH_DSP
31b3 7e					ld a,(hl)	; get type of value on TOS 
31b4 fe 02				cp DS_TYPE_INUM  
31b6 28 03				jr z, .noti 
31b8					NEXTW 
31b8 c3 2f 1d			jp macro_next 
31bb				endm 
# End of macro NEXTW
31bb			.noti:          FORTH_DSP_VALUEHL 
31bb cd bd 1b			call macro_dsp_valuehl 
31be				endm 
# End of macro FORTH_DSP_VALUEHL
31be			;		push hl 
31be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31be cd 75 1c			call macro_forth_dsp_pop 
31c1				endm 
# End of macro FORTH_DSP_POP
31c1			;		pop hl 
31c1 3e 00				ld a,0 
31c3 bd					cp l 
31c4 28 04				jr z, .not2t 
31c6 2e 00				ld l, 0 
31c8 18 02				jr .notip 
31ca			 
31ca 2e ff		.not2t:		ld l, 255 
31cc			 
31cc 26 00		.notip:		ld h, 0	 
31ce			 
31ce cd c6 19				call forth_push_numhl 
31d1					NEXTW 
31d1 c3 2f 1d			jp macro_next 
31d4				endm 
# End of macro NEXTW
31d4			 
31d4			.IS: 
31d4				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
31d4 2d				db WORD_SYS_CORE+25             
31d5 fa 31			dw .LZERO            
31d7 03				db 2 + 1 
31d8 .. 00			db "IS",0              
31db				endm 
# End of macro CWHEAD
31db			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
31db					if DEBUG_FORTH_WORDS_KEY 
31db						DMARK "IS." 
31db f5				push af  
31dc 3a f0 31			ld a, (.dmark)  
31df 32 7a ee			ld (debug_mark),a  
31e2 3a f1 31			ld a, (.dmark+1)  
31e5 32 7b ee			ld (debug_mark+1),a  
31e8 3a f2 31			ld a, (.dmark+2)  
31eb 32 7c ee			ld (debug_mark+2),a  
31ee 18 03			jr .pastdmark  
31f0 ..			.dmark: db "IS."  
31f3 f1			.pastdmark: pop af  
31f4			endm  
# End of macro DMARK
31f4						CALLMONITOR 
31f4 cd 39 14			call break_point_state  
31f7				endm  
# End of macro CALLMONITOR
31f7					endif 
31f7					NEXTW 
31f7 c3 2f 1d			jp macro_next 
31fa				endm 
# End of macro NEXTW
31fa			.LZERO: 
31fa				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
31fa 2d				db WORD_SYS_CORE+25             
31fb 04 32			dw .TZERO            
31fd 03				db 2 + 1 
31fe .. 00			db "0<",0              
3201				endm 
# End of macro CWHEAD
3201			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3201					NEXTW 
3201 c3 2f 1d			jp macro_next 
3204				endm 
# End of macro NEXTW
3204			.TZERO: 
3204				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3204 2e				db WORD_SYS_CORE+26             
3205 4b 32			dw .LESS            
3207 03				db 2 + 1 
3208 .. 00			db "0=",0              
320b				endm 
# End of macro CWHEAD
320b			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
320b				; TODO add floating point number detection 
320b					;v5 FORTH_DSP_VALUE 
320b					if DEBUG_FORTH_WORDS_KEY 
320b						DMARK "0=." 
320b f5				push af  
320c 3a 20 32			ld a, (.dmark)  
320f 32 7a ee			ld (debug_mark),a  
3212 3a 21 32			ld a, (.dmark+1)  
3215 32 7b ee			ld (debug_mark+1),a  
3218 3a 22 32			ld a, (.dmark+2)  
321b 32 7c ee			ld (debug_mark+2),a  
321e 18 03			jr .pastdmark  
3220 ..			.dmark: db "0=."  
3223 f1			.pastdmark: pop af  
3224			endm  
# End of macro DMARK
3224						CALLMONITOR 
3224 cd 39 14			call break_point_state  
3227				endm  
# End of macro CALLMONITOR
3227					endif 
3227					FORTH_DSP 
3227 cd 83 1b			call macro_forth_dsp 
322a				endm 
# End of macro FORTH_DSP
322a 7e					ld a,(hl)	; get type of value on TOS 
322b fe 02				cp DS_TYPE_INUM  
322d 28 00				jr z, .tz_inum 
322f			 
322f				if FORTH_ENABLE_FLOATMATH 
322f					jr .tz_done 
322f			 
322f				endif 
322f					 
322f			 
322f			.tz_inum: 
322f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
322f cd bd 1b			call macro_dsp_valuehl 
3232				endm 
# End of macro FORTH_DSP_VALUEHL
3232			 
3232			;		push hl 
3232			 
3232					; destroy value TOS 
3232			 
3232					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3232 cd 75 1c			call macro_forth_dsp_pop 
3235				endm 
# End of macro FORTH_DSP_POP
3235			 
3235			;		pop hl 
3235			 
3235 3e 00				ld a,0 
3237			 
3237 bd					cp l 
3238 20 08				jr nz, .tz_notzero 
323a			 
323a bc					cp h 
323b			 
323b 20 05				jr nz, .tz_notzero 
323d			 
323d			 
323d 21 01 00				ld hl, FORTH_TRUE 
3240 18 03				jr .tz_done 
3242			 
3242 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3245			 
3245					; push value back onto stack for another op etc 
3245			 
3245			.tz_done: 
3245 cd c6 19				call forth_push_numhl 
3248			 
3248					NEXTW 
3248 c3 2f 1d			jp macro_next 
324b				endm 
# End of macro NEXTW
324b			.LESS: 
324b				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
324b 2f				db WORD_SYS_CORE+27             
324c b4 32			dw .GT            
324e 02				db 1 + 1 
324f .. 00			db "<",0              
3251				endm 
# End of macro CWHEAD
3251			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3251				; TODO add floating point number detection 
3251					if DEBUG_FORTH_WORDS_KEY 
3251						DMARK "LES" 
3251 f5				push af  
3252 3a 66 32			ld a, (.dmark)  
3255 32 7a ee			ld (debug_mark),a  
3258 3a 67 32			ld a, (.dmark+1)  
325b 32 7b ee			ld (debug_mark+1),a  
325e 3a 68 32			ld a, (.dmark+2)  
3261 32 7c ee			ld (debug_mark+2),a  
3264 18 03			jr .pastdmark  
3266 ..			.dmark: db "LES"  
3269 f1			.pastdmark: pop af  
326a			endm  
# End of macro DMARK
326a						CALLMONITOR 
326a cd 39 14			call break_point_state  
326d				endm  
# End of macro CALLMONITOR
326d					endif 
326d					FORTH_DSP 
326d cd 83 1b			call macro_forth_dsp 
3270				endm 
# End of macro FORTH_DSP
3270					;v5 FORTH_DSP_VALUE 
3270 7e					ld a,(hl)	; get type of value on TOS 
3271 fe 02				cp DS_TYPE_INUM  
3273 28 00				jr z, .less_inum 
3275			 
3275				if FORTH_ENABLE_FLOATMATH 
3275					jr .less_done 
3275			 
3275				endif 
3275					 
3275			 
3275			.less_inum: 
3275					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3275 cd bd 1b			call macro_dsp_valuehl 
3278				endm 
# End of macro FORTH_DSP_VALUEHL
3278			 
3278 e5					push hl  ; u2 
3279			 
3279					; destroy value TOS 
3279			 
3279					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3279 cd 75 1c			call macro_forth_dsp_pop 
327c				endm 
# End of macro FORTH_DSP_POP
327c			 
327c			 
327c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
327c cd bd 1b			call macro_dsp_valuehl 
327f				endm 
# End of macro FORTH_DSP_VALUEHL
327f			 
327f e5					push hl    ; u1 
3280			 
3280					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3280 cd 75 1c			call macro_forth_dsp_pop 
3283				endm 
# End of macro FORTH_DSP_POP
3283			 
3283			 
3283 b7			 or a      ;clear carry flag 
3284 01 00 00		 ld bc, FORTH_FALSE 
3287 e1			  pop hl    ; u1 
3288 d1			  pop de    ; u2 
3289 ed 52		  sbc hl,de 
328b 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
328d			 
328d 01 01 00		 ld bc, FORTH_TRUE 
3290			.lscont:  
3290 c5					push bc 
3291 e1					pop hl 
3292			 
3292					if DEBUG_FORTH_WORDS 
3292						DMARK "LT1" 
3292 f5				push af  
3293 3a a7 32			ld a, (.dmark)  
3296 32 7a ee			ld (debug_mark),a  
3299 3a a8 32			ld a, (.dmark+1)  
329c 32 7b ee			ld (debug_mark+1),a  
329f 3a a9 32			ld a, (.dmark+2)  
32a2 32 7c ee			ld (debug_mark+2),a  
32a5 18 03			jr .pastdmark  
32a7 ..			.dmark: db "LT1"  
32aa f1			.pastdmark: pop af  
32ab			endm  
# End of macro DMARK
32ab						CALLMONITOR 
32ab cd 39 14			call break_point_state  
32ae				endm  
# End of macro CALLMONITOR
32ae					endif 
32ae cd c6 19				call forth_push_numhl 
32b1			 
32b1					NEXTW 
32b1 c3 2f 1d			jp macro_next 
32b4				endm 
# End of macro NEXTW
32b4			.GT: 
32b4				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
32b4 30				db WORD_SYS_CORE+28             
32b5 1d 33			dw .EQUAL            
32b7 02				db 1 + 1 
32b8 .. 00			db ">",0              
32ba				endm 
# End of macro CWHEAD
32ba			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
32ba				; TODO add floating point number detection 
32ba					if DEBUG_FORTH_WORDS_KEY 
32ba						DMARK "GRT" 
32ba f5				push af  
32bb 3a cf 32			ld a, (.dmark)  
32be 32 7a ee			ld (debug_mark),a  
32c1 3a d0 32			ld a, (.dmark+1)  
32c4 32 7b ee			ld (debug_mark+1),a  
32c7 3a d1 32			ld a, (.dmark+2)  
32ca 32 7c ee			ld (debug_mark+2),a  
32cd 18 03			jr .pastdmark  
32cf ..			.dmark: db "GRT"  
32d2 f1			.pastdmark: pop af  
32d3			endm  
# End of macro DMARK
32d3						CALLMONITOR 
32d3 cd 39 14			call break_point_state  
32d6				endm  
# End of macro CALLMONITOR
32d6					endif 
32d6					FORTH_DSP 
32d6 cd 83 1b			call macro_forth_dsp 
32d9				endm 
# End of macro FORTH_DSP
32d9					;FORTH_DSP_VALUE 
32d9 7e					ld a,(hl)	; get type of value on TOS 
32da fe 02				cp DS_TYPE_INUM  
32dc 28 00				jr z, .gt_inum 
32de			 
32de				if FORTH_ENABLE_FLOATMATH 
32de					jr .gt_done 
32de			 
32de				endif 
32de					 
32de			 
32de			.gt_inum: 
32de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32de cd bd 1b			call macro_dsp_valuehl 
32e1				endm 
# End of macro FORTH_DSP_VALUEHL
32e1			 
32e1 e5					push hl  ; u2 
32e2			 
32e2					; destroy value TOS 
32e2			 
32e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e2 cd 75 1c			call macro_forth_dsp_pop 
32e5				endm 
# End of macro FORTH_DSP_POP
32e5			 
32e5			 
32e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32e5 cd bd 1b			call macro_dsp_valuehl 
32e8				endm 
# End of macro FORTH_DSP_VALUEHL
32e8			 
32e8 e5					push hl    ; u1 
32e9			 
32e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e9 cd 75 1c			call macro_forth_dsp_pop 
32ec				endm 
# End of macro FORTH_DSP_POP
32ec			 
32ec			 
32ec b7			 or a      ;clear carry flag 
32ed 01 00 00		 ld bc, FORTH_FALSE 
32f0 e1			  pop hl    ; u1 
32f1 d1			  pop de    ; u2 
32f2 ed 52		  sbc hl,de 
32f4 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
32f6			 
32f6 01 01 00		 ld bc, FORTH_TRUE 
32f9			.gtcont:  
32f9 c5					push bc 
32fa e1					pop hl 
32fb			 
32fb					if DEBUG_FORTH_WORDS 
32fb						DMARK "GT1" 
32fb f5				push af  
32fc 3a 10 33			ld a, (.dmark)  
32ff 32 7a ee			ld (debug_mark),a  
3302 3a 11 33			ld a, (.dmark+1)  
3305 32 7b ee			ld (debug_mark+1),a  
3308 3a 12 33			ld a, (.dmark+2)  
330b 32 7c ee			ld (debug_mark+2),a  
330e 18 03			jr .pastdmark  
3310 ..			.dmark: db "GT1"  
3313 f1			.pastdmark: pop af  
3314			endm  
# End of macro DMARK
3314						CALLMONITOR 
3314 cd 39 14			call break_point_state  
3317				endm  
# End of macro CALLMONITOR
3317					endif 
3317 cd c6 19				call forth_push_numhl 
331a			 
331a					NEXTW 
331a c3 2f 1d			jp macro_next 
331d				endm 
# End of macro NEXTW
331d			.EQUAL: 
331d				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
331d 31				db WORD_SYS_CORE+29             
331e 88 33			dw .ENDLOGIC            
3320 02				db 1 + 1 
3321 .. 00			db "=",0              
3323				endm 
# End of macro CWHEAD
3323			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3323				; TODO add floating point number detection 
3323					if DEBUG_FORTH_WORDS_KEY 
3323						DMARK "EQ." 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 7a ee			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 7b ee			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 7c ee			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "EQ."  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd 39 14			call break_point_state  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f					FORTH_DSP 
333f cd 83 1b			call macro_forth_dsp 
3342				endm 
# End of macro FORTH_DSP
3342					;v5 FORTH_DSP_VALUE 
3342 7e					ld a,(hl)	; get type of value on TOS 
3343 fe 02				cp DS_TYPE_INUM  
3345 28 00				jr z, .eq_inum 
3347			 
3347				if FORTH_ENABLE_FLOATMATH 
3347					jr .eq_done 
3347			 
3347				endif 
3347					 
3347			 
3347			.eq_inum: 
3347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3347 cd bd 1b			call macro_dsp_valuehl 
334a				endm 
# End of macro FORTH_DSP_VALUEHL
334a			 
334a e5					push hl 
334b			 
334b					; destroy value TOS 
334b			 
334b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334b cd 75 1c			call macro_forth_dsp_pop 
334e				endm 
# End of macro FORTH_DSP_POP
334e			 
334e			 
334e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334e cd bd 1b			call macro_dsp_valuehl 
3351				endm 
# End of macro FORTH_DSP_VALUEHL
3351			 
3351					; one value on hl get other one back 
3351			 
3351 e5					push hl 
3352			 
3352					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3352 cd 75 1c			call macro_forth_dsp_pop 
3355				endm 
# End of macro FORTH_DSP_POP
3355			 
3355 0e 00				ld c, FORTH_FALSE 
3357			 
3357 e1					pop hl 
3358 d1					pop de 
3359			 
3359 7b					ld a, e 
335a bd					cp l 
335b			 
335b 20 06				jr nz, .eq_done 
335d			 
335d 7a					ld a, d 
335e bc					cp h 
335f			 
335f 20 02				jr nz, .eq_done 
3361			 
3361 0e 01				ld c, FORTH_TRUE 
3363					 
3363			 
3363			 
3363			.eq_done: 
3363			 
3363					; TODO push value back onto stack for another op etc 
3363			 
3363 26 00				ld h, 0 
3365 69					ld l, c 
3366					if DEBUG_FORTH_WORDS 
3366						DMARK "EQ1" 
3366 f5				push af  
3367 3a 7b 33			ld a, (.dmark)  
336a 32 7a ee			ld (debug_mark),a  
336d 3a 7c 33			ld a, (.dmark+1)  
3370 32 7b ee			ld (debug_mark+1),a  
3373 3a 7d 33			ld a, (.dmark+2)  
3376 32 7c ee			ld (debug_mark+2),a  
3379 18 03			jr .pastdmark  
337b ..			.dmark: db "EQ1"  
337e f1			.pastdmark: pop af  
337f			endm  
# End of macro DMARK
337f						CALLMONITOR 
337f cd 39 14			call break_point_state  
3382				endm  
# End of macro CALLMONITOR
3382					endif 
3382 cd c6 19				call forth_push_numhl 
3385			 
3385					NEXTW 
3385 c3 2f 1d			jp macro_next 
3388				endm 
# End of macro NEXTW
3388			 
3388			 
3388			.ENDLOGIC: 
3388			; eof 
3388			 
3388			 
# End of file forth_words_logic.asm
3388			include "forth_words_maths.asm" 
3388			 
3388			; | ## Maths Words 
3388			 
3388			.PLUS:	 
3388				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3388 15				db WORD_SYS_CORE+1             
3389 ca 33			dw .NEG            
338b 02				db 1 + 1 
338c .. 00			db "+",0              
338e				endm 
# End of macro CWHEAD
338e			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
338e					if DEBUG_FORTH_WORDS_KEY 
338e						DMARK "PLU" 
338e f5				push af  
338f 3a a3 33			ld a, (.dmark)  
3392 32 7a ee			ld (debug_mark),a  
3395 3a a4 33			ld a, (.dmark+1)  
3398 32 7b ee			ld (debug_mark+1),a  
339b 3a a5 33			ld a, (.dmark+2)  
339e 32 7c ee			ld (debug_mark+2),a  
33a1 18 03			jr .pastdmark  
33a3 ..			.dmark: db "PLU"  
33a6 f1			.pastdmark: pop af  
33a7			endm  
# End of macro DMARK
33a7						CALLMONITOR 
33a7 cd 39 14			call break_point_state  
33aa				endm  
# End of macro CALLMONITOR
33aa					endif 
33aa					; add top two values and push back result 
33aa			 
33aa					;for v5 FORTH_DSP_VALUE 
33aa					FORTH_DSP 
33aa cd 83 1b			call macro_forth_dsp 
33ad				endm 
# End of macro FORTH_DSP
33ad 7e					ld a,(hl)	; get type of value on TOS 
33ae fe 02				cp DS_TYPE_INUM  
33b0 28 03				jr z, .dot_inum 
33b2			 
33b2					NEXTW 
33b2 c3 2f 1d			jp macro_next 
33b5				endm 
# End of macro NEXTW
33b5			 
33b5			; float maths 
33b5			 
33b5				if FORTH_ENABLE_FLOATMATH 
33b5						inc hl      ; now at start of numeric as string 
33b5			 
33b5					if DEBUG_FORTH_MATHS 
33b5						DMARK "ADD" 
33b5				CALLMONITOR 
33b5					endif 
33b5			 
33b5					;ld ix, hl 
33b5					call CON 
33b5			 
33b5			 
33b5					push hl 
33b5					 
33b5					 
33b5			 
33b5						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
33b5			 
33b5					; get next number 
33b5			 
33b5						FORTH_DSP_VALUE 
33b5			 
33b5						inc hl      ; now at start of numeric as string 
33b5			 
33b5					;ld ix, hl 
33b5					call CON 
33b5			 
33b5					push hl 
33b5			 
33b5			 
33b5						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33b5			 
33b5						; TODO do add 
33b5			 
33b5						call IADD 
33b5			 
33b5						; TODO get result back as ascii 
33b5			 
33b5						; TODO push result  
33b5			 
33b5			 
33b5			 
33b5						jr .dot_done 
33b5				endif 
33b5			 
33b5			.dot_inum: 
33b5			 
33b5			 
33b5					if DEBUG_FORTH_DOT 
33b5						DMARK "+IT" 
33b5				CALLMONITOR 
33b5					endif 
33b5			 
33b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33b5 cd bd 1b			call macro_dsp_valuehl 
33b8				endm 
# End of macro FORTH_DSP_VALUEHL
33b8			 
33b8				; TODO add floating point number detection 
33b8			 
33b8 e5					push hl 
33b9			 
33b9					; destroy value TOS 
33b9			 
33b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33b9 cd 75 1c			call macro_forth_dsp_pop 
33bc				endm 
# End of macro FORTH_DSP_POP
33bc			 
33bc			 
33bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33bc cd bd 1b			call macro_dsp_valuehl 
33bf				endm 
# End of macro FORTH_DSP_VALUEHL
33bf			 
33bf					; one value on hl get other one back 
33bf			 
33bf d1					pop de 
33c0			 
33c0					; do the add 
33c0			 
33c0 19					add hl,de 
33c1			 
33c1					; save it 
33c1			 
33c1			;		push hl	 
33c1			 
33c1					; 
33c1			 
33c1					; destroy value TOS 
33c1			 
33c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33c1 cd 75 1c			call macro_forth_dsp_pop 
33c4				endm 
# End of macro FORTH_DSP_POP
33c4			 
33c4					; TODO push value back onto stack for another op etc 
33c4			 
33c4			;		pop hl 
33c4			 
33c4			.dot_done: 
33c4 cd c6 19				call forth_push_numhl 
33c7			 
33c7					NEXTW 
33c7 c3 2f 1d			jp macro_next 
33ca				endm 
# End of macro NEXTW
33ca			.NEG: 
33ca			 
33ca				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
33ca 17				db WORD_SYS_CORE+3             
33cb 0d 34			dw .DIV            
33cd 02				db 1 + 1 
33ce .. 00			db "-",0              
33d0				endm 
# End of macro CWHEAD
33d0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
33d0					if DEBUG_FORTH_WORDS_KEY 
33d0						DMARK "SUB" 
33d0 f5				push af  
33d1 3a e5 33			ld a, (.dmark)  
33d4 32 7a ee			ld (debug_mark),a  
33d7 3a e6 33			ld a, (.dmark+1)  
33da 32 7b ee			ld (debug_mark+1),a  
33dd 3a e7 33			ld a, (.dmark+2)  
33e0 32 7c ee			ld (debug_mark+2),a  
33e3 18 03			jr .pastdmark  
33e5 ..			.dmark: db "SUB"  
33e8 f1			.pastdmark: pop af  
33e9			endm  
# End of macro DMARK
33e9						CALLMONITOR 
33e9 cd 39 14			call break_point_state  
33ec				endm  
# End of macro CALLMONITOR
33ec					endif 
33ec			 
33ec			 
33ec				; TODO add floating point number detection 
33ec					; v5 FORTH_DSP_VALUE 
33ec					FORTH_DSP 
33ec cd 83 1b			call macro_forth_dsp 
33ef				endm 
# End of macro FORTH_DSP
33ef 7e					ld a,(hl)	; get type of value on TOS 
33f0 fe 02				cp DS_TYPE_INUM  
33f2 28 03				jr z, .neg_inum 
33f4			 
33f4					NEXTW 
33f4 c3 2f 1d			jp macro_next 
33f7				endm 
# End of macro NEXTW
33f7			 
33f7			; float maths 
33f7			 
33f7				if FORTH_ENABLE_FLOATMATH 
33f7					jr .neg_done 
33f7			 
33f7				endif 
33f7					 
33f7			 
33f7			.neg_inum: 
33f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f7 cd bd 1b			call macro_dsp_valuehl 
33fa				endm 
# End of macro FORTH_DSP_VALUEHL
33fa			 
33fa e5					push hl 
33fb			 
33fb					; destroy value TOS 
33fb			 
33fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33fb cd 75 1c			call macro_forth_dsp_pop 
33fe				endm 
# End of macro FORTH_DSP_POP
33fe			 
33fe			 
33fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33fe cd bd 1b			call macro_dsp_valuehl 
3401				endm 
# End of macro FORTH_DSP_VALUEHL
3401			 
3401					; one value on hl get other one back 
3401			 
3401 d1					pop de 
3402			 
3402					; do the sub 
3402			;		ex de, hl 
3402			 
3402 ed 52				sbc hl,de 
3404			 
3404					; save it 
3404			 
3404			;		push hl	 
3404			 
3404					; 
3404			 
3404					; destroy value TOS 
3404			 
3404					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3404 cd 75 1c			call macro_forth_dsp_pop 
3407				endm 
# End of macro FORTH_DSP_POP
3407			 
3407					; TODO push value back onto stack for another op etc 
3407			 
3407			;		pop hl 
3407			 
3407 cd c6 19				call forth_push_numhl 
340a			.neg_done: 
340a			 
340a					NEXTW 
340a c3 2f 1d			jp macro_next 
340d				endm 
# End of macro NEXTW
340d			.DIV: 
340d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
340d 18				db WORD_SYS_CORE+4             
340e 5a 34			dw .MUL            
3410 02				db 1 + 1 
3411 .. 00			db "/",0              
3413				endm 
# End of macro CWHEAD
3413			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3413					if DEBUG_FORTH_WORDS_KEY 
3413						DMARK "DIV" 
3413 f5				push af  
3414 3a 28 34			ld a, (.dmark)  
3417 32 7a ee			ld (debug_mark),a  
341a 3a 29 34			ld a, (.dmark+1)  
341d 32 7b ee			ld (debug_mark+1),a  
3420 3a 2a 34			ld a, (.dmark+2)  
3423 32 7c ee			ld (debug_mark+2),a  
3426 18 03			jr .pastdmark  
3428 ..			.dmark: db "DIV"  
342b f1			.pastdmark: pop af  
342c			endm  
# End of macro DMARK
342c						CALLMONITOR 
342c cd 39 14			call break_point_state  
342f				endm  
# End of macro CALLMONITOR
342f					endif 
342f				; TODO add floating point number detection 
342f					; v5 FORTH_DSP_VALUE 
342f					FORTH_DSP 
342f cd 83 1b			call macro_forth_dsp 
3432				endm 
# End of macro FORTH_DSP
3432 7e					ld a,(hl)	; get type of value on TOS 
3433 fe 02				cp DS_TYPE_INUM  
3435 28 03				jr z, .div_inum 
3437			 
3437				if FORTH_ENABLE_FLOATMATH 
3437					jr .div_done 
3437			 
3437				endif 
3437					NEXTW 
3437 c3 2f 1d			jp macro_next 
343a				endm 
# End of macro NEXTW
343a			.div_inum: 
343a			 
343a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
343a cd bd 1b			call macro_dsp_valuehl 
343d				endm 
# End of macro FORTH_DSP_VALUEHL
343d			 
343d e5					push hl    ; to go to bc 
343e			 
343e					; destroy value TOS 
343e			 
343e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
343e cd 75 1c			call macro_forth_dsp_pop 
3441				endm 
# End of macro FORTH_DSP_POP
3441			 
3441			 
3441					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3441 cd bd 1b			call macro_dsp_valuehl 
3444				endm 
# End of macro FORTH_DSP_VALUEHL
3444			 
3444					; hl to go to de 
3444			 
3444 e5					push hl 
3445			 
3445 c1					pop bc 
3446 d1					pop de		 
3447			 
3447			 
3447					if DEBUG_FORTH_MATHS 
3447						DMARK "DIV" 
3447				CALLMONITOR 
3447					endif 
3447					; one value on hl but move to a get other one back 
3447			 
3447			        
3447 cd 23 0b			call Div16 
344a			 
344a			;	push af	 
344a e5				push hl 
344b c5				push bc 
344c			 
344c					if DEBUG_FORTH_MATHS 
344c						DMARK "DI1" 
344c				CALLMONITOR 
344c					endif 
344c			 
344c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
344c cd 75 1c			call macro_forth_dsp_pop 
344f				endm 
# End of macro FORTH_DSP_POP
344f			 
344f			 
344f			 
344f e1					pop hl    ; result 
3450			 
3450 cd c6 19				call forth_push_numhl 
3453			 
3453 e1					pop hl    ; reminder 
3454			;		ld h,0 
3454			;		ld l,d 
3454			 
3454 cd c6 19				call forth_push_numhl 
3457			.div_done: 
3457					NEXTW 
3457 c3 2f 1d			jp macro_next 
345a				endm 
# End of macro NEXTW
345a			.MUL: 
345a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
345a 19				db WORD_SYS_CORE+5             
345b 9f 34			dw .MIN            
345d 02				db 1 + 1 
345e .. 00			db "*",0              
3460				endm 
# End of macro CWHEAD
3460			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3460				; TODO add floating point number detection 
3460					if DEBUG_FORTH_WORDS_KEY 
3460						DMARK "MUL" 
3460 f5				push af  
3461 3a 75 34			ld a, (.dmark)  
3464 32 7a ee			ld (debug_mark),a  
3467 3a 76 34			ld a, (.dmark+1)  
346a 32 7b ee			ld (debug_mark+1),a  
346d 3a 77 34			ld a, (.dmark+2)  
3470 32 7c ee			ld (debug_mark+2),a  
3473 18 03			jr .pastdmark  
3475 ..			.dmark: db "MUL"  
3478 f1			.pastdmark: pop af  
3479			endm  
# End of macro DMARK
3479						CALLMONITOR 
3479 cd 39 14			call break_point_state  
347c				endm  
# End of macro CALLMONITOR
347c					endif 
347c					FORTH_DSP 
347c cd 83 1b			call macro_forth_dsp 
347f				endm 
# End of macro FORTH_DSP
347f					; v5 FORTH_DSP_VALUE 
347f 7e					ld a,(hl)	; get type of value on TOS 
3480 fe 02				cp DS_TYPE_INUM  
3482 28 03				jr z, .mul_inum 
3484			 
3484				if FORTH_ENABLE_FLOATMATH 
3484					jr .mul_done 
3484			 
3484				endif 
3484			 
3484					NEXTW 
3484 c3 2f 1d			jp macro_next 
3487				endm 
# End of macro NEXTW
3487			.mul_inum:	 
3487			 
3487					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3487 cd bd 1b			call macro_dsp_valuehl 
348a				endm 
# End of macro FORTH_DSP_VALUEHL
348a			 
348a e5					push hl 
348b			 
348b					; destroy value TOS 
348b			 
348b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348b cd 75 1c			call macro_forth_dsp_pop 
348e				endm 
# End of macro FORTH_DSP_POP
348e			 
348e			 
348e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
348e cd bd 1b			call macro_dsp_valuehl 
3491				endm 
# End of macro FORTH_DSP_VALUEHL
3491			 
3491					; one value on hl but move to a get other one back 
3491			 
3491 7d					ld a, l 
3492			 
3492 d1					pop de 
3493			 
3493					; do the mull 
3493			;		ex de, hl 
3493			 
3493 cd 49 0b				call Mult16 
3496					; save it 
3496			 
3496			;		push hl	 
3496			 
3496					; 
3496			 
3496					; destroy value TOS 
3496			 
3496					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3496 cd 75 1c			call macro_forth_dsp_pop 
3499				endm 
# End of macro FORTH_DSP_POP
3499			 
3499					; TODO push value back onto stack for another op etc 
3499			 
3499			;		pop hl 
3499			 
3499 cd c6 19				call forth_push_numhl 
349c			 
349c			.mul_done: 
349c					NEXTW 
349c c3 2f 1d			jp macro_next 
349f				endm 
# End of macro NEXTW
349f			 
349f			 
349f			 
349f			 
349f			.MIN: 
349f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
349f 49				db WORD_SYS_CORE+53             
34a0 20 35			dw .MAX            
34a2 04				db 3 + 1 
34a3 .. 00			db "MIN",0              
34a7				endm 
# End of macro CWHEAD
34a7			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
34a7					if DEBUG_FORTH_WORDS_KEY 
34a7						DMARK "MIN" 
34a7 f5				push af  
34a8 3a bc 34			ld a, (.dmark)  
34ab 32 7a ee			ld (debug_mark),a  
34ae 3a bd 34			ld a, (.dmark+1)  
34b1 32 7b ee			ld (debug_mark+1),a  
34b4 3a be 34			ld a, (.dmark+2)  
34b7 32 7c ee			ld (debug_mark+2),a  
34ba 18 03			jr .pastdmark  
34bc ..			.dmark: db "MIN"  
34bf f1			.pastdmark: pop af  
34c0			endm  
# End of macro DMARK
34c0						CALLMONITOR 
34c0 cd 39 14			call break_point_state  
34c3				endm  
# End of macro CALLMONITOR
34c3					endif 
34c3					; get u2 
34c3			 
34c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c3 cd bd 1b			call macro_dsp_valuehl 
34c6				endm 
# End of macro FORTH_DSP_VALUEHL
34c6			 
34c6 e5					push hl   ; u2 
34c7			 
34c7					; destroy value TOS 
34c7			 
34c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c7 cd 75 1c			call macro_forth_dsp_pop 
34ca				endm 
# End of macro FORTH_DSP_POP
34ca			 
34ca					; get u1 
34ca			 
34ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ca cd bd 1b			call macro_dsp_valuehl 
34cd				endm 
# End of macro FORTH_DSP_VALUEHL
34cd			 
34cd e5					push hl  ; u1 
34ce			 
34ce					; destroy value TOS 
34ce			 
34ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34ce cd 75 1c			call macro_forth_dsp_pop 
34d1				endm 
# End of macro FORTH_DSP_POP
34d1			 
34d1 b7			 or a      ;clear carry flag 
34d2 e1			  pop hl    ; u1 
34d3 d1			  pop de    ; u2 
34d4 e5				push hl   ; saved in case hl is lowest 
34d5 ed 52		  sbc hl,de 
34d7 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
34d9			 
34d9 e1				pop hl 
34da					if DEBUG_FORTH_WORDS 
34da						DMARK "MIN" 
34da f5				push af  
34db 3a ef 34			ld a, (.dmark)  
34de 32 7a ee			ld (debug_mark),a  
34e1 3a f0 34			ld a, (.dmark+1)  
34e4 32 7b ee			ld (debug_mark+1),a  
34e7 3a f1 34			ld a, (.dmark+2)  
34ea 32 7c ee			ld (debug_mark+2),a  
34ed 18 03			jr .pastdmark  
34ef ..			.dmark: db "MIN"  
34f2 f1			.pastdmark: pop af  
34f3			endm  
# End of macro DMARK
34f3						CALLMONITOR 
34f3 cd 39 14			call break_point_state  
34f6				endm  
# End of macro CALLMONITOR
34f6					endif 
34f6 cd c6 19				call forth_push_numhl 
34f9			 
34f9				       NEXTW 
34f9 c3 2f 1d			jp macro_next 
34fc				endm 
# End of macro NEXTW
34fc			 
34fc			.mincont:  
34fc c1				pop bc   ; tidy up 
34fd eb				ex de , hl  
34fe					if DEBUG_FORTH_WORDS 
34fe						DMARK "MI1" 
34fe f5				push af  
34ff 3a 13 35			ld a, (.dmark)  
3502 32 7a ee			ld (debug_mark),a  
3505 3a 14 35			ld a, (.dmark+1)  
3508 32 7b ee			ld (debug_mark+1),a  
350b 3a 15 35			ld a, (.dmark+2)  
350e 32 7c ee			ld (debug_mark+2),a  
3511 18 03			jr .pastdmark  
3513 ..			.dmark: db "MI1"  
3516 f1			.pastdmark: pop af  
3517			endm  
# End of macro DMARK
3517						CALLMONITOR 
3517 cd 39 14			call break_point_state  
351a				endm  
# End of macro CALLMONITOR
351a					endif 
351a cd c6 19				call forth_push_numhl 
351d			 
351d				       NEXTW 
351d c3 2f 1d			jp macro_next 
3520				endm 
# End of macro NEXTW
3520			.MAX: 
3520				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3520 4a				db WORD_SYS_CORE+54             
3521 a1 35			dw .RND16            
3523 04				db 3 + 1 
3524 .. 00			db "MAX",0              
3528				endm 
# End of macro CWHEAD
3528			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3528					if DEBUG_FORTH_WORDS_KEY 
3528						DMARK "MAX" 
3528 f5				push af  
3529 3a 3d 35			ld a, (.dmark)  
352c 32 7a ee			ld (debug_mark),a  
352f 3a 3e 35			ld a, (.dmark+1)  
3532 32 7b ee			ld (debug_mark+1),a  
3535 3a 3f 35			ld a, (.dmark+2)  
3538 32 7c ee			ld (debug_mark+2),a  
353b 18 03			jr .pastdmark  
353d ..			.dmark: db "MAX"  
3540 f1			.pastdmark: pop af  
3541			endm  
# End of macro DMARK
3541						CALLMONITOR 
3541 cd 39 14			call break_point_state  
3544				endm  
# End of macro CALLMONITOR
3544					endif 
3544					; get u2 
3544			 
3544					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3544 cd bd 1b			call macro_dsp_valuehl 
3547				endm 
# End of macro FORTH_DSP_VALUEHL
3547			 
3547 e5					push hl   ; u2 
3548			 
3548					; destroy value TOS 
3548			 
3548					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3548 cd 75 1c			call macro_forth_dsp_pop 
354b				endm 
# End of macro FORTH_DSP_POP
354b			 
354b					; get u1 
354b			 
354b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
354b cd bd 1b			call macro_dsp_valuehl 
354e				endm 
# End of macro FORTH_DSP_VALUEHL
354e			 
354e e5					push hl  ; u1 
354f			 
354f					; destroy value TOS 
354f			 
354f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
354f cd 75 1c			call macro_forth_dsp_pop 
3552				endm 
# End of macro FORTH_DSP_POP
3552			 
3552 b7			 or a      ;clear carry flag 
3553 e1			  pop hl    ; u1 
3554 d1			  pop de    ; u2 
3555 e5				push hl   ; saved in case hl is lowest 
3556 ed 52		  sbc hl,de 
3558 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
355a			 
355a e1				pop hl 
355b					if DEBUG_FORTH_WORDS 
355b						DMARK "MAX" 
355b f5				push af  
355c 3a 70 35			ld a, (.dmark)  
355f 32 7a ee			ld (debug_mark),a  
3562 3a 71 35			ld a, (.dmark+1)  
3565 32 7b ee			ld (debug_mark+1),a  
3568 3a 72 35			ld a, (.dmark+2)  
356b 32 7c ee			ld (debug_mark+2),a  
356e 18 03			jr .pastdmark  
3570 ..			.dmark: db "MAX"  
3573 f1			.pastdmark: pop af  
3574			endm  
# End of macro DMARK
3574						CALLMONITOR 
3574 cd 39 14			call break_point_state  
3577				endm  
# End of macro CALLMONITOR
3577					endif 
3577 cd c6 19				call forth_push_numhl 
357a			 
357a				       NEXTW 
357a c3 2f 1d			jp macro_next 
357d				endm 
# End of macro NEXTW
357d			 
357d			.maxcont:  
357d c1				pop bc   ; tidy up 
357e eb				ex de , hl  
357f					if DEBUG_FORTH_WORDS 
357f						DMARK "MA1" 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 7a ee			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 7b ee			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 7c ee			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "MA1"  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd 39 14			call break_point_state  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b cd c6 19				call forth_push_numhl 
359e				       NEXTW 
359e c3 2f 1d			jp macro_next 
35a1				endm 
# End of macro NEXTW
35a1			 
35a1			.RND16: 
35a1				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
35a1 4e				db WORD_SYS_CORE+58             
35a2 d0 35			dw .RND8            
35a4 06				db 5 + 1 
35a5 .. 00			db "RND16",0              
35ab				endm 
# End of macro CWHEAD
35ab			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
35ab					if DEBUG_FORTH_WORDS_KEY 
35ab						DMARK "R16" 
35ab f5				push af  
35ac 3a c0 35			ld a, (.dmark)  
35af 32 7a ee			ld (debug_mark),a  
35b2 3a c1 35			ld a, (.dmark+1)  
35b5 32 7b ee			ld (debug_mark+1),a  
35b8 3a c2 35			ld a, (.dmark+2)  
35bb 32 7c ee			ld (debug_mark+2),a  
35be 18 03			jr .pastdmark  
35c0 ..			.dmark: db "R16"  
35c3 f1			.pastdmark: pop af  
35c4			endm  
# End of macro DMARK
35c4						CALLMONITOR 
35c4 cd 39 14			call break_point_state  
35c7				endm  
# End of macro CALLMONITOR
35c7					endif 
35c7 cd ed 0a				call prng16  
35ca cd c6 19				call forth_push_numhl 
35cd				       NEXTW 
35cd c3 2f 1d			jp macro_next 
35d0				endm 
# End of macro NEXTW
35d0			.RND8: 
35d0				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
35d0 60				db WORD_SYS_CORE+76             
35d1 05 36			dw .RND            
35d3 05				db 4 + 1 
35d4 .. 00			db "RND8",0              
35d9				endm 
# End of macro CWHEAD
35d9			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
35d9					if DEBUG_FORTH_WORDS_KEY 
35d9						DMARK "RN8" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 7a ee			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 7b ee			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 7c ee			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "RN8"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2						CALLMONITOR 
35f2 cd 39 14			call break_point_state  
35f5				endm  
# End of macro CALLMONITOR
35f5					endif 
35f5 2a bb eb				ld hl,(xrandc) 
35f8 23					inc hl 
35f9 cd 07 0b				call xrnd 
35fc 6f					ld l,a	 
35fd 26 00				ld h,0 
35ff cd c6 19				call forth_push_numhl 
3602				       NEXTW 
3602 c3 2f 1d			jp macro_next 
3605				endm 
# End of macro NEXTW
3605			.RND: 
3605				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3605 60				db WORD_SYS_CORE+76             
3606 0b 37			dw .ENDMATHS            
3608 04				db 3 + 1 
3609 .. 00			db "RND",0              
360d				endm 
# End of macro CWHEAD
360d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
360d			 
360d					if DEBUG_FORTH_WORDS_KEY 
360d						DMARK "RND" 
360d f5				push af  
360e 3a 22 36			ld a, (.dmark)  
3611 32 7a ee			ld (debug_mark),a  
3614 3a 23 36			ld a, (.dmark+1)  
3617 32 7b ee			ld (debug_mark+1),a  
361a 3a 24 36			ld a, (.dmark+2)  
361d 32 7c ee			ld (debug_mark+2),a  
3620 18 03			jr .pastdmark  
3622 ..			.dmark: db "RND"  
3625 f1			.pastdmark: pop af  
3626			endm  
# End of macro DMARK
3626						CALLMONITOR 
3626 cd 39 14			call break_point_state  
3629				endm  
# End of macro CALLMONITOR
3629					endif 
3629					 
3629					FORTH_DSP_VALUEHL    ; upper range 
3629 cd bd 1b			call macro_dsp_valuehl 
362c				endm 
# End of macro FORTH_DSP_VALUEHL
362c			 
362c 22 bf eb				ld (LFSRSeed), hl	 
362f			 
362f					if DEBUG_FORTH_WORDS 
362f						DMARK "RN1" 
362f f5				push af  
3630 3a 44 36			ld a, (.dmark)  
3633 32 7a ee			ld (debug_mark),a  
3636 3a 45 36			ld a, (.dmark+1)  
3639 32 7b ee			ld (debug_mark+1),a  
363c 3a 46 36			ld a, (.dmark+2)  
363f 32 7c ee			ld (debug_mark+2),a  
3642 18 03			jr .pastdmark  
3644 ..			.dmark: db "RN1"  
3647 f1			.pastdmark: pop af  
3648			endm  
# End of macro DMARK
3648						CALLMONITOR 
3648 cd 39 14			call break_point_state  
364b				endm  
# End of macro CALLMONITOR
364b					endif 
364b					FORTH_DSP_POP 
364b cd 75 1c			call macro_forth_dsp_pop 
364e				endm 
# End of macro FORTH_DSP_POP
364e			 
364e					FORTH_DSP_VALUEHL    ; low range 
364e cd bd 1b			call macro_dsp_valuehl 
3651				endm 
# End of macro FORTH_DSP_VALUEHL
3651			 
3651					if DEBUG_FORTH_WORDS 
3651						DMARK "RN2" 
3651 f5				push af  
3652 3a 66 36			ld a, (.dmark)  
3655 32 7a ee			ld (debug_mark),a  
3658 3a 67 36			ld a, (.dmark+1)  
365b 32 7b ee			ld (debug_mark+1),a  
365e 3a 68 36			ld a, (.dmark+2)  
3661 32 7c ee			ld (debug_mark+2),a  
3664 18 03			jr .pastdmark  
3666 ..			.dmark: db "RN2"  
3669 f1			.pastdmark: pop af  
366a			endm  
# End of macro DMARK
366a						CALLMONITOR 
366a cd 39 14			call break_point_state  
366d				endm  
# End of macro CALLMONITOR
366d					endif 
366d 22 c1 eb				ld (LFSRSeed+2), hl 
3670			 
3670					FORTH_DSP_POP 
3670 cd 75 1c			call macro_forth_dsp_pop 
3673				endm 
# End of macro FORTH_DSP_POP
3673			 
3673 e5					push hl 
3674			 
3674 e1			.inrange:	pop hl 
3675 cd ed 0a				call prng16  
3678					if DEBUG_FORTH_WORDS 
3678						DMARK "RN3" 
3678 f5				push af  
3679 3a 8d 36			ld a, (.dmark)  
367c 32 7a ee			ld (debug_mark),a  
367f 3a 8e 36			ld a, (.dmark+1)  
3682 32 7b ee			ld (debug_mark+1),a  
3685 3a 8f 36			ld a, (.dmark+2)  
3688 32 7c ee			ld (debug_mark+2),a  
368b 18 03			jr .pastdmark  
368d ..			.dmark: db "RN3"  
3690 f1			.pastdmark: pop af  
3691			endm  
# End of macro DMARK
3691						CALLMONITOR 
3691 cd 39 14			call break_point_state  
3694				endm  
# End of macro CALLMONITOR
3694					endif 
3694					 
3694					; if the range is 8bit knock out the high byte 
3694			 
3694 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
3698			 
3698 3e 00				ld a, 0 
369a ba					cp d  
369b 20 1e				jr nz, .hirange 
369d 26 00				ld h, 0   ; knock it down to 8bit 
369f			 
369f					if DEBUG_FORTH_WORDS 
369f						DMARK "RNk" 
369f f5				push af  
36a0 3a b4 36			ld a, (.dmark)  
36a3 32 7a ee			ld (debug_mark),a  
36a6 3a b5 36			ld a, (.dmark+1)  
36a9 32 7b ee			ld (debug_mark+1),a  
36ac 3a b6 36			ld a, (.dmark+2)  
36af 32 7c ee			ld (debug_mark+2),a  
36b2 18 03			jr .pastdmark  
36b4 ..			.dmark: db "RNk"  
36b7 f1			.pastdmark: pop af  
36b8			endm  
# End of macro DMARK
36b8						CALLMONITOR 
36b8 cd 39 14			call break_point_state  
36bb				endm  
# End of macro CALLMONITOR
36bb					endif 
36bb			.hirange:   
36bb e5					push hl  
36bc b7					or a  
36bd ed 52		                sbc hl, de 
36bf			 
36bf					;call cmp16 
36bf			 
36bf 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
36c1 e1					pop hl 
36c2 e5					push hl 
36c3			 
36c3					if DEBUG_FORTH_WORDS 
36c3						DMARK "RN4" 
36c3 f5				push af  
36c4 3a d8 36			ld a, (.dmark)  
36c7 32 7a ee			ld (debug_mark),a  
36ca 3a d9 36			ld a, (.dmark+1)  
36cd 32 7b ee			ld (debug_mark+1),a  
36d0 3a da 36			ld a, (.dmark+2)  
36d3 32 7c ee			ld (debug_mark+2),a  
36d6 18 03			jr .pastdmark  
36d8 ..			.dmark: db "RN4"  
36db f1			.pastdmark: pop af  
36dc			endm  
# End of macro DMARK
36dc						CALLMONITOR 
36dc cd 39 14			call break_point_state  
36df				endm  
# End of macro CALLMONITOR
36df					endif 
36df ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
36e3					;call cmp16 
36e3				 
36e3 b7					or a  
36e4 ed 52		                sbc hl, de 
36e6 38 8c				jr c, .inrange 
36e8			 
36e8 e1					pop hl 
36e9					 
36e9					if DEBUG_FORTH_WORDS 
36e9						DMARK "RNd" 
36e9 f5				push af  
36ea 3a fe 36			ld a, (.dmark)  
36ed 32 7a ee			ld (debug_mark),a  
36f0 3a ff 36			ld a, (.dmark+1)  
36f3 32 7b ee			ld (debug_mark+1),a  
36f6 3a 00 37			ld a, (.dmark+2)  
36f9 32 7c ee			ld (debug_mark+2),a  
36fc 18 03			jr .pastdmark  
36fe ..			.dmark: db "RNd"  
3701 f1			.pastdmark: pop af  
3702			endm  
# End of macro DMARK
3702						CALLMONITOR 
3702 cd 39 14			call break_point_state  
3705				endm  
# End of macro CALLMONITOR
3705					endif 
3705			 
3705			 
3705 cd c6 19				call forth_push_numhl 
3708				       NEXTW 
3708 c3 2f 1d			jp macro_next 
370b				endm 
# End of macro NEXTW
370b			 
370b			.ENDMATHS: 
370b			 
370b			; eof 
370b			 
# End of file forth_words_maths.asm
370b			include "forth_words_display.asm" 
370b			 
370b			; | ## Display Words 
370b			 
370b			.ATP: 
370b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
370b 62				db WORD_SYS_CORE+78             
370c 82 37			dw .FB            
370e 04				db 3 + 1 
370f .. 00			db "AT?",0              
3713				endm 
# End of macro CWHEAD
3713			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3713					if DEBUG_FORTH_WORDS_KEY 
3713						DMARK "AT?" 
3713 f5				push af  
3714 3a 28 37			ld a, (.dmark)  
3717 32 7a ee			ld (debug_mark),a  
371a 3a 29 37			ld a, (.dmark+1)  
371d 32 7b ee			ld (debug_mark+1),a  
3720 3a 2a 37			ld a, (.dmark+2)  
3723 32 7c ee			ld (debug_mark+2),a  
3726 18 03			jr .pastdmark  
3728 ..			.dmark: db "AT?"  
372b f1			.pastdmark: pop af  
372c			endm  
# End of macro DMARK
372c						CALLMONITOR 
372c cd 39 14			call break_point_state  
372f				endm  
# End of macro CALLMONITOR
372f					endif 
372f 3a 49 eb				ld a, (f_cursor_ptr) 
3732			 
3732			if DEBUG_FORTH_WORDS 
3732				DMARK "AT?" 
3732 f5				push af  
3733 3a 47 37			ld a, (.dmark)  
3736 32 7a ee			ld (debug_mark),a  
3739 3a 48 37			ld a, (.dmark+1)  
373c 32 7b ee			ld (debug_mark+1),a  
373f 3a 49 37			ld a, (.dmark+2)  
3742 32 7c ee			ld (debug_mark+2),a  
3745 18 03			jr .pastdmark  
3747 ..			.dmark: db "AT?"  
374a f1			.pastdmark: pop af  
374b			endm  
# End of macro DMARK
374b				CALLMONITOR 
374b cd 39 14			call break_point_state  
374e				endm  
# End of macro CALLMONITOR
374e			endif	 
374e					; count the number of rows 
374e			 
374e 06 00				ld b, 0 
3750 4f			.atpr:		ld c, a    ; save in case we go below zero 
3751 d6 28				sub display_cols 
3753 f2 59 37				jp p, .atprunder 
3756 04					inc b 
3757 18 f7				jr .atpr 
3759			.atprunder:	 
3759			if DEBUG_FORTH_WORDS 
3759				DMARK "A?2" 
3759 f5				push af  
375a 3a 6e 37			ld a, (.dmark)  
375d 32 7a ee			ld (debug_mark),a  
3760 3a 6f 37			ld a, (.dmark+1)  
3763 32 7b ee			ld (debug_mark+1),a  
3766 3a 70 37			ld a, (.dmark+2)  
3769 32 7c ee			ld (debug_mark+2),a  
376c 18 03			jr .pastdmark  
376e ..			.dmark: db "A?2"  
3771 f1			.pastdmark: pop af  
3772			endm  
# End of macro DMARK
3772				CALLMONITOR 
3772 cd 39 14			call break_point_state  
3775				endm  
# End of macro CALLMONITOR
3775			endif	 
3775 26 00				ld h, 0 
3777 69					ld l, c 
3778 cd c6 19				call forth_push_numhl 
377b 68					ld l, b  
377c cd c6 19				call forth_push_numhl 
377f			 
377f			 
377f				NEXTW 
377f c3 2f 1d			jp macro_next 
3782				endm 
# End of macro NEXTW
3782			 
3782			.FB: 
3782				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3782 1b				db WORD_SYS_CORE+7             
3783 d0 37			dw .EMIT            
3785 03				db 2 + 1 
3786 .. 00			db "FB",0              
3789				endm 
# End of macro CWHEAD
3789			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3789			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3789			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3789			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3789					if DEBUG_FORTH_WORDS_KEY 
3789						DMARK "FB." 
3789 f5				push af  
378a 3a 9e 37			ld a, (.dmark)  
378d 32 7a ee			ld (debug_mark),a  
3790 3a 9f 37			ld a, (.dmark+1)  
3793 32 7b ee			ld (debug_mark+1),a  
3796 3a a0 37			ld a, (.dmark+2)  
3799 32 7c ee			ld (debug_mark+2),a  
379c 18 03			jr .pastdmark  
379e ..			.dmark: db "FB."  
37a1 f1			.pastdmark: pop af  
37a2			endm  
# End of macro DMARK
37a2						CALLMONITOR 
37a2 cd 39 14			call break_point_state  
37a5				endm  
# End of macro CALLMONITOR
37a5					endif 
37a5			 
37a5					FORTH_DSP_VALUEHL 
37a5 cd bd 1b			call macro_dsp_valuehl 
37a8				endm 
# End of macro FORTH_DSP_VALUEHL
37a8			 
37a8 7d					ld a, l 
37a9 fe 01				cp 1 
37ab 20 05				jr nz, .fbn1 
37ad 21 1f ed				ld hl, display_fb1 
37b0 18 15				jr .fbset 
37b2 fe 02		.fbn1:		cp 2 
37b4 20 05				jr nz, .fbn2 
37b6 21 dd eb				ld hl, display_fb2 
37b9 18 0c				jr .fbset 
37bb fe 03		.fbn2:		cp 3 
37bd 20 05				jr nz, .fbn3 
37bf 21 7e ec				ld hl, display_fb3 
37c2 18 03				jr .fbset 
37c4			.fbn3:		 ; if invalid number select first 
37c4 21 1f ed				ld hl, display_fb1 
37c7 22 db eb		.fbset:		ld (display_fb_active), hl 
37ca			 
37ca					FORTH_DSP_POP 
37ca cd 75 1c			call macro_forth_dsp_pop 
37cd				endm 
# End of macro FORTH_DSP_POP
37cd			 
37cd					NEXTW 
37cd c3 2f 1d			jp macro_next 
37d0				endm 
# End of macro NEXTW
37d0			 
37d0			 
37d0			.EMIT: 
37d0				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
37d0 1b				db WORD_SYS_CORE+7             
37d1 21 38			dw .DOTH            
37d3 05				db 4 + 1 
37d4 .. 00			db "EMIT",0              
37d9				endm 
# End of macro CWHEAD
37d9			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
37d9					; get value off TOS and display it 
37d9			 
37d9					if DEBUG_FORTH_WORDS_KEY 
37d9						DMARK "EMT" 
37d9 f5				push af  
37da 3a ee 37			ld a, (.dmark)  
37dd 32 7a ee			ld (debug_mark),a  
37e0 3a ef 37			ld a, (.dmark+1)  
37e3 32 7b ee			ld (debug_mark+1),a  
37e6 3a f0 37			ld a, (.dmark+2)  
37e9 32 7c ee			ld (debug_mark+2),a  
37ec 18 03			jr .pastdmark  
37ee ..			.dmark: db "EMT"  
37f1 f1			.pastdmark: pop af  
37f2			endm  
# End of macro DMARK
37f2						CALLMONITOR 
37f2 cd 39 14			call break_point_state  
37f5				endm  
# End of macro CALLMONITOR
37f5					endif 
37f5			 
37f5					FORTH_DSP_VALUEHL 
37f5 cd bd 1b			call macro_dsp_valuehl 
37f8				endm 
# End of macro FORTH_DSP_VALUEHL
37f8			 
37f8 7d					ld a,l 
37f9			 
37f9					; TODO write to display 
37f9			 
37f9 32 5e e5				ld (os_input), a 
37fc 3e 00				ld a, 0 
37fe 32 5f e5				ld (os_input+1), a 
3801					 
3801 3a 49 eb				ld a, (f_cursor_ptr) 
3804 11 5e e5				ld de, os_input 
3807 cd ac 09				call str_at_display 
380a			 
380a			 
380a 3a 27 eb				ld a,(cli_autodisplay) 
380d fe 00				cp 0 
380f 28 03				jr z, .enoupdate 
3811 cd bc 09						call update_display 
3814					.enoupdate: 
3814			 
3814 3a 49 eb				ld a, (f_cursor_ptr) 
3817 3c					inc a 
3818 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
381b			 
381b			 
381b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381b cd 75 1c			call macro_forth_dsp_pop 
381e				endm 
# End of macro FORTH_DSP_POP
381e			  
381e			 
381e					NEXTW 
381e c3 2f 1d			jp macro_next 
3821				endm 
# End of macro NEXTW
3821			.DOTH: 
3821				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3821 1c				db WORD_SYS_CORE+8             
3822 51 38			dw .DOTF            
3824 03				db 2 + 1 
3825 .. 00			db ".-",0              
3828				endm 
# End of macro CWHEAD
3828			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3828					; get value off TOS and display it 
3828					if DEBUG_FORTH_WORDS_KEY 
3828						DMARK "DTD" 
3828 f5				push af  
3829 3a 3d 38			ld a, (.dmark)  
382c 32 7a ee			ld (debug_mark),a  
382f 3a 3e 38			ld a, (.dmark+1)  
3832 32 7b ee			ld (debug_mark+1),a  
3835 3a 3f 38			ld a, (.dmark+2)  
3838 32 7c ee			ld (debug_mark+2),a  
383b 18 03			jr .pastdmark  
383d ..			.dmark: db "DTD"  
3840 f1			.pastdmark: pop af  
3841			endm  
# End of macro DMARK
3841						CALLMONITOR 
3841 cd 39 14			call break_point_state  
3844				endm  
# End of macro CALLMONITOR
3844					endif 
3844 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3846 3e 00			ld a, 0 
3848 32 28 eb			ld (cli_mvdot), a 
384b c3 a8 38			jp .dotgo 
384e				NEXTW 
384e c3 2f 1d			jp macro_next 
3851				endm 
# End of macro NEXTW
3851			.DOTF: 
3851				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3851 1c				db WORD_SYS_CORE+8             
3852 7f 38			dw .DOT            
3854 03				db 2 + 1 
3855 .. 00			db ".>",0              
3858				endm 
# End of macro CWHEAD
3858			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3858					; get value off TOS and display it 
3858			        ; TODO BUG adds extra spaces 
3858			        ; TODO BUG handle numerics? 
3858					if DEBUG_FORTH_WORDS_KEY 
3858						DMARK "DTC" 
3858 f5				push af  
3859 3a 6d 38			ld a, (.dmark)  
385c 32 7a ee			ld (debug_mark),a  
385f 3a 6e 38			ld a, (.dmark+1)  
3862 32 7b ee			ld (debug_mark+1),a  
3865 3a 6f 38			ld a, (.dmark+2)  
3868 32 7c ee			ld (debug_mark+2),a  
386b 18 03			jr .pastdmark  
386d ..			.dmark: db "DTC"  
3870 f1			.pastdmark: pop af  
3871			endm  
# End of macro DMARK
3871						CALLMONITOR 
3871 cd 39 14			call break_point_state  
3874				endm  
# End of macro CALLMONITOR
3874					endif 
3874 3e 01			ld a, 1 
3876 32 28 eb			ld (cli_mvdot), a 
3879 c3 a8 38			jp .dotgo 
387c				NEXTW 
387c c3 2f 1d			jp macro_next 
387f				endm 
# End of macro NEXTW
387f			 
387f			.DOT: 
387f				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
387f 1c				db WORD_SYS_CORE+8             
3880 0b 39			dw .CLS            
3882 02				db 1 + 1 
3883 .. 00			db ".",0              
3885				endm 
# End of macro CWHEAD
3885			        ; | . ( u -- ) Display TOS | DONE 
3885					; get value off TOS and display it 
3885			 
3885					if DEBUG_FORTH_WORDS_KEY 
3885						DMARK "DOT" 
3885 f5				push af  
3886 3a 9a 38			ld a, (.dmark)  
3889 32 7a ee			ld (debug_mark),a  
388c 3a 9b 38			ld a, (.dmark+1)  
388f 32 7b ee			ld (debug_mark+1),a  
3892 3a 9c 38			ld a, (.dmark+2)  
3895 32 7c ee			ld (debug_mark+2),a  
3898 18 03			jr .pastdmark  
389a ..			.dmark: db "DOT"  
389d f1			.pastdmark: pop af  
389e			endm  
# End of macro DMARK
389e						CALLMONITOR 
389e cd 39 14			call break_point_state  
38a1				endm  
# End of macro CALLMONITOR
38a1					endif 
38a1 3e 00			ld a, 0 
38a3 32 28 eb			ld (cli_mvdot), a 
38a6 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
38a8				 
38a8			 
38a8			.dotgo: 
38a8			 
38a8			; move up type to on stack for parserv5 
38a8					FORTH_DSP 
38a8 cd 83 1b			call macro_forth_dsp 
38ab				endm 
# End of macro FORTH_DSP
38ab				;FORTH_DSP_VALUE  
38ab			 
38ab			if DEBUG_FORTH_DOT 
38ab				DMARK "DOT" 
38ab				CALLMONITOR 
38ab			endif	 
38ab			;		.print: 
38ab			 
38ab 7e				ld a,(hl)  ; work out what type of value is on the TOS 
38ac 23				inc hl   ; position to the actual value 
38ad fe 01			cp DS_TYPE_STR 
38af 20 06			jr nz, .dotnum1  
38b1			 
38b1			; display string 
38b1				FORTH_DSP_VALUE  
38b1 cd a6 1b			call macro_forth_dsp_value 
38b4				endm 
# End of macro FORTH_DSP_VALUE
38b4 eb				ex de,hl 
38b5 18 11			jr .dotwrite 
38b7			 
38b7			.dotnum1: 
38b7 fe 02			cp DS_TYPE_INUM 
38b9 20 0c			jr nz, .dotflot 
38bb			 
38bb			 
38bb			; display number 
38bb			 
38bb			;	push hl 
38bb			;	call clear_display 
38bb			;	pop hl 
38bb			 
38bb 5e				ld e, (hl) 
38bc 23				inc hl 
38bd 56				ld d, (hl) 
38be 21 60 e3			ld hl, scratch 
38c1			if DEBUG_FORTH_DOT 
38c1				DMARK "DT1" 
38c1				CALLMONITOR 
38c1			endif	 
38c1			 
38c1 cd d3 0f			call uitoa_16 
38c4 eb				ex de,hl 
38c5			 
38c5			if DEBUG_FORTH_DOT 
38c5				DMARK "DT2" 
38c5				CALLMONITOR 
38c5			endif	 
38c5			 
38c5			;	ld de, os_word_scratch 
38c5 18 01			jr .dotwrite 
38c7			 
38c7 00			.dotflot:   nop 
38c8			; TODO print floating point number 
38c8			 
38c8			.dotwrite:		 
38c8			 
38c8					; if c is set then set all '-' to spaces 
38c8					; need to also take into account .>  
38c8			 
38c8 3e 01				ld a, 1 
38ca b9					cp c 
38cb 20 13				jr nz, .nodashswap 
38cd			 
38cd					; DE has the string to write, working with HL 
38cd			 
38cd 06 ff				ld b, 255 
38cf d5					push de 
38d0 e1					pop hl 
38d1			 
38d1			if DEBUG_FORTH_DOT 
38d1				DMARK "DT-" 
38d1				CALLMONITOR 
38d1			endif	 
38d1 7e			.dashscan:	ld a, (hl) 
38d2 fe 00				cp 0 
38d4 28 0a				jr z, .nodashswap 
38d6 fe 2d				cp '-' 
38d8 20 03				jr nz, .dashskip 
38da 3e 20				ld a, ' ' 
38dc 77					ld (hl), a 
38dd 23			.dashskip:	inc hl 
38de			if DEBUG_FORTH_DOT 
38de				DMARK "D-2" 
38de				CALLMONITOR 
38de			endif	 
38de 10 f1				djnz .dashscan 
38e0			 
38e0			if DEBUG_FORTH_DOT 
38e0				DMARK "D-1" 
38e0				CALLMONITOR 
38e0			endif	 
38e0			 
38e0			.nodashswap: 
38e0			 
38e0 e5					push hl   ; save string start in case we need to advance print 
38e1			 
38e1 3a 49 eb				ld a, (f_cursor_ptr) 
38e4 cd ac 09				call str_at_display 
38e7 3a 27 eb				ld a,(cli_autodisplay) 
38ea fe 00				cp 0 
38ec 28 03				jr z, .noupdate 
38ee cd bc 09						call update_display 
38f1					.noupdate: 
38f1			 
38f1			 
38f1					; see if we need to advance the print position 
38f1			 
38f1 e1					pop hl   ; get back string 
38f2			 
38f2 3a 28 eb				ld a, (cli_mvdot) 
38f5			if DEBUG_FORTH_DOT 
38f5					ld e,a 
38f5				DMARK "D>1" 
38f5				CALLMONITOR 
38f5			endif	 
38f5 fe 00				cp 0 
38f7 28 0c				jr z, .noadv 
38f9					; yes, lets advance the print position 
38f9 3e 00				ld a, 0 
38fb cd 2f 10				call strlent 
38fe 3a 49 eb				ld a, (f_cursor_ptr) 
3901 85					add a,l 
3902					;call addatohl 
3902					;ld a, l 
3902 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3905			 
3905			if DEBUG_FORTH_DOT 
3905				DMARK "D->" 
3905				CALLMONITOR 
3905			endif	 
3905			 
3905			.noadv:	 
3905			 
3905					if DEBUG_FORTH_DOT_WAIT 
3905							call next_page_prompt 
3905					endif	 
3905			; TODO this pop off the stack causes a crash. i dont know why 
3905			 
3905			 
3905			if DEBUG_FORTH_DOT 
3905				DMARK "DTh" 
3905				CALLMONITOR 
3905			endif	 
3905			 
3905					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3905 cd 75 1c			call macro_forth_dsp_pop 
3908				endm 
# End of macro FORTH_DSP_POP
3908			 
3908			if DEBUG_FORTH_DOT 
3908				DMARK "DTi" 
3908				CALLMONITOR 
3908			endif	 
3908			 
3908			 
3908					NEXTW 
3908 c3 2f 1d			jp macro_next 
390b				endm 
# End of macro NEXTW
390b			 
390b			.CLS: 
390b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
390b 35				db WORD_SYS_CORE+33             
390c 38 39			dw .DRAW            
390e 04				db 3 + 1 
390f .. 00			db "CLS",0              
3913				endm 
# End of macro CWHEAD
3913			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3913					if DEBUG_FORTH_WORDS_KEY 
3913						DMARK "CLS" 
3913 f5				push af  
3914 3a 28 39			ld a, (.dmark)  
3917 32 7a ee			ld (debug_mark),a  
391a 3a 29 39			ld a, (.dmark+1)  
391d 32 7b ee			ld (debug_mark+1),a  
3920 3a 2a 39			ld a, (.dmark+2)  
3923 32 7c ee			ld (debug_mark+2),a  
3926 18 03			jr .pastdmark  
3928 ..			.dmark: db "CLS"  
392b f1			.pastdmark: pop af  
392c			endm  
# End of macro DMARK
392c						CALLMONITOR 
392c cd 39 14			call break_point_state  
392f				endm  
# End of macro CALLMONITOR
392f					endif 
392f cd 99 09				call clear_display 
3932 c3 46 3a				jp .home		; and home cursor 
3935					NEXTW 
3935 c3 2f 1d			jp macro_next 
3938				endm 
# End of macro NEXTW
3938			 
3938			.DRAW: 
3938				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3938 36				db WORD_SYS_CORE+34             
3939 63 39			dw .DUMP            
393b 05				db 4 + 1 
393c .. 00			db "DRAW",0              
3941				endm 
# End of macro CWHEAD
3941			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3941					if DEBUG_FORTH_WORDS_KEY 
3941						DMARK "DRW" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 7a ee			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 7b ee			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 7c ee			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "DRW"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd 39 14			call break_point_state  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d cd bc 09				call update_display 
3960					NEXTW 
3960 c3 2f 1d			jp macro_next 
3963				endm 
# End of macro NEXTW
3963			 
3963			.DUMP: 
3963				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3963 37				db WORD_SYS_CORE+35             
3964 9b 39			dw .CDUMP            
3966 05				db 4 + 1 
3967 .. 00			db "DUMP",0              
396c				endm 
# End of macro CWHEAD
396c			; | DUMP ( x -- ) With address x display dump   | DONE 
396c			; TODO pop address to use off of the stack 
396c					if DEBUG_FORTH_WORDS_KEY 
396c						DMARK "DUM" 
396c f5				push af  
396d 3a 81 39			ld a, (.dmark)  
3970 32 7a ee			ld (debug_mark),a  
3973 3a 82 39			ld a, (.dmark+1)  
3976 32 7b ee			ld (debug_mark+1),a  
3979 3a 83 39			ld a, (.dmark+2)  
397c 32 7c ee			ld (debug_mark+2),a  
397f 18 03			jr .pastdmark  
3981 ..			.dmark: db "DUM"  
3984 f1			.pastdmark: pop af  
3985			endm  
# End of macro DMARK
3985						CALLMONITOR 
3985 cd 39 14			call break_point_state  
3988				endm  
# End of macro CALLMONITOR
3988					endif 
3988 cd 99 09				call clear_display 
398b			 
398b					; get address 
398b			 
398b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
398b cd bd 1b			call macro_dsp_valuehl 
398e				endm 
# End of macro FORTH_DSP_VALUEHL
398e				 
398e					; save it for cdump 
398e			 
398e 22 83 e6				ld (os_cur_ptr),hl 
3991			 
3991					; destroy value TOS 
3991			 
3991					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3991 cd 75 1c			call macro_forth_dsp_pop 
3994				endm 
# End of macro FORTH_DSP_POP
3994			 
3994 cd 46 18				call dumpcont	; skip old style of param parsing	 
3997 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3998					NEXTW 
3998 c3 2f 1d			jp macro_next 
399b				endm 
# End of macro NEXTW
399b			.CDUMP: 
399b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
399b 38				db WORD_SYS_CORE+36             
399c cb 39			dw .DAT            
399e 06				db 5 + 1 
399f .. 00			db "CDUMP",0              
39a5				endm 
# End of macro CWHEAD
39a5			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
39a5					if DEBUG_FORTH_WORDS_KEY 
39a5						DMARK "CDP" 
39a5 f5				push af  
39a6 3a ba 39			ld a, (.dmark)  
39a9 32 7a ee			ld (debug_mark),a  
39ac 3a bb 39			ld a, (.dmark+1)  
39af 32 7b ee			ld (debug_mark+1),a  
39b2 3a bc 39			ld a, (.dmark+2)  
39b5 32 7c ee			ld (debug_mark+2),a  
39b8 18 03			jr .pastdmark  
39ba ..			.dmark: db "CDP"  
39bd f1			.pastdmark: pop af  
39be			endm  
# End of macro DMARK
39be						CALLMONITOR 
39be cd 39 14			call break_point_state  
39c1				endm  
# End of macro CALLMONITOR
39c1					endif 
39c1 cd 99 09				call clear_display 
39c4 cd 46 18				call dumpcont	 
39c7 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
39c8					NEXTW 
39c8 c3 2f 1d			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			 
39cb			 
39cb			 
39cb			 
39cb			.DAT: 
39cb				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
39cb 3d				db WORD_SYS_CORE+41             
39cc 21 3a			dw .HOME            
39ce 03				db 2 + 1 
39cf .. 00			db "AT",0              
39d2				endm 
# End of macro CWHEAD
39d2			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
39d2					if DEBUG_FORTH_WORDS_KEY 
39d2						DMARK "AT." 
39d2 f5				push af  
39d3 3a e7 39			ld a, (.dmark)  
39d6 32 7a ee			ld (debug_mark),a  
39d9 3a e8 39			ld a, (.dmark+1)  
39dc 32 7b ee			ld (debug_mark+1),a  
39df 3a e9 39			ld a, (.dmark+2)  
39e2 32 7c ee			ld (debug_mark+2),a  
39e5 18 03			jr .pastdmark  
39e7 ..			.dmark: db "AT."  
39ea f1			.pastdmark: pop af  
39eb			endm  
# End of macro DMARK
39eb						CALLMONITOR 
39eb cd 39 14			call break_point_state  
39ee				endm  
# End of macro CALLMONITOR
39ee					endif 
39ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ee cd bd 1b			call macro_dsp_valuehl 
39f1				endm 
# End of macro FORTH_DSP_VALUEHL
39f1			 
39f1			 
39f1					; TODO save cursor row 
39f1 7d					ld a,l 
39f2 fe 02				cp 2 
39f4 20 04				jr nz, .crow3 
39f6 3e 28				ld a, display_row_2 
39f8 18 12				jr .ccol1 
39fa fe 03		.crow3:		cp 3 
39fc 20 04				jr nz, .crow4 
39fe 3e 50				ld a, display_row_3 
3a00 18 0a				jr .ccol1 
3a02 fe 04		.crow4:		cp 4 
3a04 20 04				jr nz, .crow1 
3a06 3e 78				ld a, display_row_4 
3a08 18 02				jr .ccol1 
3a0a 3e 00		.crow1:		ld a,display_row_1 
3a0c f5			.ccol1:		push af			; got row offset 
3a0d 6f					ld l,a 
3a0e 26 00				ld h,0 
3a10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a10 cd 75 1c			call macro_forth_dsp_pop 
3a13				endm 
# End of macro FORTH_DSP_POP
3a13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a13 cd bd 1b			call macro_dsp_valuehl 
3a16				endm 
# End of macro FORTH_DSP_VALUEHL
3a16					; TODO save cursor col 
3a16 f1					pop af 
3a17 85					add l		; add col offset 
3a18 32 49 eb				ld (f_cursor_ptr), a 
3a1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a1b cd 75 1c			call macro_forth_dsp_pop 
3a1e				endm 
# End of macro FORTH_DSP_POP
3a1e			 
3a1e					; calculate  
3a1e			 
3a1e					NEXTW 
3a1e c3 2f 1d			jp macro_next 
3a21				endm 
# End of macro NEXTW
3a21			 
3a21			 
3a21			.HOME: 
3a21				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a21 41				db WORD_SYS_CORE+45             
3a22 4e 3a			dw .SPACE            
3a24 05				db 4 + 1 
3a25 .. 00			db "HOME",0              
3a2a				endm 
# End of macro CWHEAD
3a2a			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a2a					if DEBUG_FORTH_WORDS_KEY 
3a2a						DMARK "HOM" 
3a2a f5				push af  
3a2b 3a 3f 3a			ld a, (.dmark)  
3a2e 32 7a ee			ld (debug_mark),a  
3a31 3a 40 3a			ld a, (.dmark+1)  
3a34 32 7b ee			ld (debug_mark+1),a  
3a37 3a 41 3a			ld a, (.dmark+2)  
3a3a 32 7c ee			ld (debug_mark+2),a  
3a3d 18 03			jr .pastdmark  
3a3f ..			.dmark: db "HOM"  
3a42 f1			.pastdmark: pop af  
3a43			endm  
# End of macro DMARK
3a43						CALLMONITOR 
3a43 cd 39 14			call break_point_state  
3a46				endm  
# End of macro CALLMONITOR
3a46					endif 
3a46 3e 00		.home:		ld a, 0		; and home cursor 
3a48 32 49 eb				ld (f_cursor_ptr), a 
3a4b					NEXTW 
3a4b c3 2f 1d			jp macro_next 
3a4e				endm 
# End of macro NEXTW
3a4e			 
3a4e			 
3a4e			.SPACE: 
3a4e				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3a4e 46				db WORD_SYS_CORE+50             
3a4f 7c 3a			dw .SPACES            
3a51 03				db 2 + 1 
3a52 .. 00			db "BL",0              
3a55				endm 
# End of macro CWHEAD
3a55			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3a55					if DEBUG_FORTH_WORDS_KEY 
3a55						DMARK "BL." 
3a55 f5				push af  
3a56 3a 6a 3a			ld a, (.dmark)  
3a59 32 7a ee			ld (debug_mark),a  
3a5c 3a 6b 3a			ld a, (.dmark+1)  
3a5f 32 7b ee			ld (debug_mark+1),a  
3a62 3a 6c 3a			ld a, (.dmark+2)  
3a65 32 7c ee			ld (debug_mark+2),a  
3a68 18 03			jr .pastdmark  
3a6a ..			.dmark: db "BL."  
3a6d f1			.pastdmark: pop af  
3a6e			endm  
# End of macro DMARK
3a6e						CALLMONITOR 
3a6e cd 39 14			call break_point_state  
3a71				endm  
# End of macro CALLMONITOR
3a71					endif 
3a71 21 7a 3a				ld hl, .blstr 
3a74 cd 34 1a				call forth_push_str 
3a77					 
3a77				       NEXTW 
3a77 c3 2f 1d			jp macro_next 
3a7a				endm 
# End of macro NEXTW
3a7a			 
3a7a .. 00		.blstr: db " ", 0 
3a7c			 
3a7c			.SPACES: 
3a7c				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a7c 47				db WORD_SYS_CORE+51             
3a7d 17 3b			dw .SCROLL            
3a7f 07				db 6 + 1 
3a80 .. 00			db "SPACES",0              
3a87				endm 
# End of macro CWHEAD
3a87			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a87					if DEBUG_FORTH_WORDS_KEY 
3a87						DMARK "SPS" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 7a ee			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 7b ee			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 7c ee			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "SPS"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0						CALLMONITOR 
3aa0 cd 39 14			call break_point_state  
3aa3				endm  
# End of macro CALLMONITOR
3aa3					endif 
3aa3			 
3aa3			 
3aa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa3 cd bd 1b			call macro_dsp_valuehl 
3aa6				endm 
# End of macro FORTH_DSP_VALUEHL
3aa6			 
3aa6			;		push hl    ; u 
3aa6					if DEBUG_FORTH_WORDS 
3aa6						DMARK "SPA" 
3aa6 f5				push af  
3aa7 3a bb 3a			ld a, (.dmark)  
3aaa 32 7a ee			ld (debug_mark),a  
3aad 3a bc 3a			ld a, (.dmark+1)  
3ab0 32 7b ee			ld (debug_mark+1),a  
3ab3 3a bd 3a			ld a, (.dmark+2)  
3ab6 32 7c ee			ld (debug_mark+2),a  
3ab9 18 03			jr .pastdmark  
3abb ..			.dmark: db "SPA"  
3abe f1			.pastdmark: pop af  
3abf			endm  
# End of macro DMARK
3abf						CALLMONITOR 
3abf cd 39 14			call break_point_state  
3ac2				endm  
# End of macro CALLMONITOR
3ac2					endif 
3ac2			 
3ac2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac2 cd 75 1c			call macro_forth_dsp_pop 
3ac5				endm 
# End of macro FORTH_DSP_POP
3ac5			;		pop hl 
3ac5 4d					ld c, l 
3ac6 06 00				ld b, 0 
3ac8 21 60 e3				ld hl, scratch  
3acb			 
3acb					if DEBUG_FORTH_WORDS 
3acb						DMARK "SP2" 
3acb f5				push af  
3acc 3a e0 3a			ld a, (.dmark)  
3acf 32 7a ee			ld (debug_mark),a  
3ad2 3a e1 3a			ld a, (.dmark+1)  
3ad5 32 7b ee			ld (debug_mark+1),a  
3ad8 3a e2 3a			ld a, (.dmark+2)  
3adb 32 7c ee			ld (debug_mark+2),a  
3ade 18 03			jr .pastdmark  
3ae0 ..			.dmark: db "SP2"  
3ae3 f1			.pastdmark: pop af  
3ae4			endm  
# End of macro DMARK
3ae4						CALLMONITOR 
3ae4 cd 39 14			call break_point_state  
3ae7				endm  
# End of macro CALLMONITOR
3ae7					endif 
3ae7 3e 20				ld a, ' ' 
3ae9 c5			.spaces1:	push bc 
3aea 77					ld (hl),a 
3aeb 23					inc hl 
3aec c1					pop bc 
3aed 10 fa				djnz .spaces1 
3aef 3e 00				ld a,0 
3af1 77					ld (hl),a 
3af2 21 60 e3				ld hl, scratch 
3af5					if DEBUG_FORTH_WORDS 
3af5						DMARK "SP3" 
3af5 f5				push af  
3af6 3a 0a 3b			ld a, (.dmark)  
3af9 32 7a ee			ld (debug_mark),a  
3afc 3a 0b 3b			ld a, (.dmark+1)  
3aff 32 7b ee			ld (debug_mark+1),a  
3b02 3a 0c 3b			ld a, (.dmark+2)  
3b05 32 7c ee			ld (debug_mark+2),a  
3b08 18 03			jr .pastdmark  
3b0a ..			.dmark: db "SP3"  
3b0d f1			.pastdmark: pop af  
3b0e			endm  
# End of macro DMARK
3b0e						CALLMONITOR 
3b0e cd 39 14			call break_point_state  
3b11				endm  
# End of macro CALLMONITOR
3b11					endif 
3b11 cd 2f 1b				call forth_apush 
3b14			 
3b14				       NEXTW 
3b14 c3 2f 1d			jp macro_next 
3b17				endm 
# End of macro NEXTW
3b17			 
3b17			 
3b17			 
3b17			.SCROLL: 
3b17				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b17 53				db WORD_SYS_CORE+63             
3b18 44 3b			dw .SCROLLD            
3b1a 07				db 6 + 1 
3b1b .. 00			db "SCROLL",0              
3b22				endm 
# End of macro CWHEAD
3b22			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b22					if DEBUG_FORTH_WORDS_KEY 
3b22						DMARK "SCR" 
3b22 f5				push af  
3b23 3a 37 3b			ld a, (.dmark)  
3b26 32 7a ee			ld (debug_mark),a  
3b29 3a 38 3b			ld a, (.dmark+1)  
3b2c 32 7b ee			ld (debug_mark+1),a  
3b2f 3a 39 3b			ld a, (.dmark+2)  
3b32 32 7c ee			ld (debug_mark+2),a  
3b35 18 03			jr .pastdmark  
3b37 ..			.dmark: db "SCR"  
3b3a f1			.pastdmark: pop af  
3b3b			endm  
# End of macro DMARK
3b3b						CALLMONITOR 
3b3b cd 39 14			call break_point_state  
3b3e				endm  
# End of macro CALLMONITOR
3b3e					endif 
3b3e			 
3b3e cd 5b 09			call scroll_up 
3b41			;	call update_display 
3b41			 
3b41					NEXTW 
3b41 c3 2f 1d			jp macro_next 
3b44				endm 
# End of macro NEXTW
3b44			 
3b44			 
3b44			 
3b44			;		; get dir 
3b44			; 
3b44			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b44			; 
3b44			;		push hl 
3b44			; 
3b44			;		; destroy value TOS 
3b44			; 
3b44			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b44			; 
3b44			;		; get count 
3b44			; 
3b44			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b44			; 
3b44			;		push hl 
3b44			; 
3b44			;		; destroy value TOS 
3b44			; 
3b44			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b44			; 
3b44			;		; one value on hl get other one back 
3b44			; 
3b44			;		pop bc    ; count 
3b44			; 
3b44			;		pop de   ; dir 
3b44			; 
3b44			; 
3b44			;		ld b, c 
3b44			; 
3b44			;.scrolldir:     push bc 
3b44			;		push de 
3b44			; 
3b44			;		ld a, 0 
3b44			;		cp e 
3b44			;		jr z, .scrollup  
3b44			;		call scroll_down 
3b44			;		jr .scrollnext 
3b44			;.scrollup:	call scroll_up 
3b44			; 
3b44			;		 
3b44			;.scrollnext: 
3b44			;		pop de 
3b44			;		pop bc 
3b44			;		djnz .scrolldir 
3b44			; 
3b44			; 
3b44			; 
3b44			; 
3b44			; 
3b44			;		NEXTW 
3b44			 
3b44			.SCROLLD: 
3b44				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b44 53				db WORD_SYS_CORE+63             
3b45 72 3b			dw .ATQ            
3b47 08				db 7 + 1 
3b48 .. 00			db "SCROLLD",0              
3b50				endm 
# End of macro CWHEAD
3b50			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3b50					if DEBUG_FORTH_WORDS_KEY 
3b50						DMARK "SCD" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 7a ee			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 7b ee			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 7c ee			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "SCD"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd 39 14			call break_point_state  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c			 
3b6c cd 7f 09			call scroll_down 
3b6f			;	call update_display 
3b6f			 
3b6f					NEXTW 
3b6f c3 2f 1d			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			 
3b72			 
3b72			.ATQ: 
3b72				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3b72 62				db WORD_SYS_CORE+78             
3b73 d0 3b			dw .AUTODSP            
3b75 04				db 3 + 1 
3b76 .. 00			db "AT@",0              
3b7a				endm 
# End of macro CWHEAD
3b7a			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3b7a					if DEBUG_FORTH_WORDS_KEY 
3b7a						DMARK "ATA" 
3b7a f5				push af  
3b7b 3a 8f 3b			ld a, (.dmark)  
3b7e 32 7a ee			ld (debug_mark),a  
3b81 3a 90 3b			ld a, (.dmark+1)  
3b84 32 7b ee			ld (debug_mark+1),a  
3b87 3a 91 3b			ld a, (.dmark+2)  
3b8a 32 7c ee			ld (debug_mark+2),a  
3b8d 18 03			jr .pastdmark  
3b8f ..			.dmark: db "ATA"  
3b92 f1			.pastdmark: pop af  
3b93			endm  
# End of macro DMARK
3b93						CALLMONITOR 
3b93 cd 39 14			call break_point_state  
3b96				endm  
# End of macro CALLMONITOR
3b96					endif 
3b96			 
3b96			 
3b96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b96 cd bd 1b			call macro_dsp_valuehl 
3b99				endm 
# End of macro FORTH_DSP_VALUEHL
3b99			 
3b99					; TODO save cursor row 
3b99 7d					ld a,l 
3b9a fe 02				cp 2 
3b9c 20 04				jr nz, .crow3aq 
3b9e 3e 28				ld a, display_row_2 
3ba0 18 12				jr .ccol1aq 
3ba2 fe 03		.crow3aq:		cp 3 
3ba4 20 04				jr nz, .crow4aq 
3ba6 3e 50				ld a, display_row_3 
3ba8 18 0a				jr .ccol1aq 
3baa fe 04		.crow4aq:		cp 4 
3bac 20 04				jr nz, .crow1aq 
3bae 3e 78				ld a, display_row_4 
3bb0 18 02				jr .ccol1aq 
3bb2 3e 00		.crow1aq:		ld a,display_row_1 
3bb4 f5			.ccol1aq:		push af			; got row offset 
3bb5 6f					ld l,a 
3bb6 26 00				ld h,0 
3bb8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb8 cd 75 1c			call macro_forth_dsp_pop 
3bbb				endm 
# End of macro FORTH_DSP_POP
3bbb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bbb cd bd 1b			call macro_dsp_valuehl 
3bbe				endm 
# End of macro FORTH_DSP_VALUEHL
3bbe					; TODO save cursor col 
3bbe f1					pop af 
3bbf 85					add l		; add col offset 
3bc0			 
3bc0					; add current frame buffer address 
3bc0 2a db eb				ld hl, (display_fb_active) 
3bc3 cd c6 0b				call addatohl 
3bc6			 
3bc6			 
3bc6			 
3bc6			 
3bc6					; get char frame buffer location offset in hl 
3bc6			 
3bc6 7e					ld a,(hl) 
3bc7 26 00				ld h, 0 
3bc9 6f					ld l, a 
3bca			 
3bca cd c6 19				call forth_push_numhl 
3bcd			 
3bcd			 
3bcd					NEXTW 
3bcd c3 2f 1d			jp macro_next 
3bd0				endm 
# End of macro NEXTW
3bd0			 
3bd0			.AUTODSP: 
3bd0				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3bd0 63				db WORD_SYS_CORE+79             
3bd1 e6 3b			dw .MENU            
3bd3 05				db 4 + 1 
3bd4 .. 00			db "ADSP",0              
3bd9				endm 
# End of macro CWHEAD
3bd9			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3bd9			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3bd9			 
3bd9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bd9 cd bd 1b			call macro_dsp_valuehl 
3bdc				endm 
# End of macro FORTH_DSP_VALUEHL
3bdc			 
3bdc			;		push hl 
3bdc			 
3bdc					; destroy value TOS 
3bdc			 
3bdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bdc cd 75 1c			call macro_forth_dsp_pop 
3bdf				endm 
# End of macro FORTH_DSP_POP
3bdf			 
3bdf			;		pop hl 
3bdf			 
3bdf 7d					ld a,l 
3be0 32 27 eb				ld (cli_autodisplay), a 
3be3				       NEXTW 
3be3 c3 2f 1d			jp macro_next 
3be6				endm 
# End of macro NEXTW
3be6			 
3be6			.MENU: 
3be6				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3be6 70				db WORD_SYS_CORE+92             
3be7 8f 3c			dw .ENDDISPLAY            
3be9 05				db 4 + 1 
3bea .. 00			db "MENU",0              
3bef				endm 
# End of macro CWHEAD
3bef			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3bef			 
3bef			;		; get number of items on the stack 
3bef			; 
3bef				 
3bef					FORTH_DSP_VALUEHL 
3bef cd bd 1b			call macro_dsp_valuehl 
3bf2				endm 
# End of macro FORTH_DSP_VALUEHL
3bf2				 
3bf2					if DEBUG_FORTH_WORDS_KEY 
3bf2						DMARK "MNU" 
3bf2 f5				push af  
3bf3 3a 07 3c			ld a, (.dmark)  
3bf6 32 7a ee			ld (debug_mark),a  
3bf9 3a 08 3c			ld a, (.dmark+1)  
3bfc 32 7b ee			ld (debug_mark+1),a  
3bff 3a 09 3c			ld a, (.dmark+2)  
3c02 32 7c ee			ld (debug_mark+2),a  
3c05 18 03			jr .pastdmark  
3c07 ..			.dmark: db "MNU"  
3c0a f1			.pastdmark: pop af  
3c0b			endm  
# End of macro DMARK
3c0b						CALLMONITOR 
3c0b cd 39 14			call break_point_state  
3c0e				endm  
# End of macro CALLMONITOR
3c0e					endif 
3c0e			 
3c0e 45					ld b, l	 
3c0f 05					dec b 
3c10			 
3c10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c10 cd 75 1c			call macro_forth_dsp_pop 
3c13				endm 
# End of macro FORTH_DSP_POP
3c13			 
3c13			 
3c13					; go directly through the stack to pluck out the string pointers and build an array 
3c13			 
3c13			;		FORTH_DSP 
3c13			 
3c13					; hl contains top most stack item 
3c13				 
3c13 11 60 e3				ld de, scratch 
3c16			 
3c16			.mbuild: 
3c16			 
3c16					FORTH_DSP_VALUEHL 
3c16 cd bd 1b			call macro_dsp_valuehl 
3c19				endm 
# End of macro FORTH_DSP_VALUEHL
3c19			 
3c19					if DEBUG_FORTH_WORDS 
3c19						DMARK "MN3" 
3c19 f5				push af  
3c1a 3a 2e 3c			ld a, (.dmark)  
3c1d 32 7a ee			ld (debug_mark),a  
3c20 3a 2f 3c			ld a, (.dmark+1)  
3c23 32 7b ee			ld (debug_mark+1),a  
3c26 3a 30 3c			ld a, (.dmark+2)  
3c29 32 7c ee			ld (debug_mark+2),a  
3c2c 18 03			jr .pastdmark  
3c2e ..			.dmark: db "MN3"  
3c31 f1			.pastdmark: pop af  
3c32			endm  
# End of macro DMARK
3c32						CALLMONITOR 
3c32 cd 39 14			call break_point_state  
3c35				endm  
# End of macro CALLMONITOR
3c35					endif 
3c35 eb					ex de, hl 
3c36 73					ld (hl), e 
3c37 23					inc hl 
3c38 72					ld (hl), d 
3c39 23					inc hl 
3c3a eb					ex de, hl 
3c3b			 
3c3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3b cd 75 1c			call macro_forth_dsp_pop 
3c3e				endm 
# End of macro FORTH_DSP_POP
3c3e			 
3c3e 10 d6				djnz .mbuild 
3c40			 
3c40					; done add term 
3c40			 
3c40 eb					ex de, hl 
3c41 36 00				ld (hl), 0 
3c43 23					inc hl 
3c44 36 00				ld (hl), 0 
3c46			 
3c46				 
3c46					 
3c46 21 60 e3				ld hl, scratch 
3c49			 
3c49					if DEBUG_FORTH_WORDS 
3c49						DMARK "MNx" 
3c49 f5				push af  
3c4a 3a 5e 3c			ld a, (.dmark)  
3c4d 32 7a ee			ld (debug_mark),a  
3c50 3a 5f 3c			ld a, (.dmark+1)  
3c53 32 7b ee			ld (debug_mark+1),a  
3c56 3a 60 3c			ld a, (.dmark+2)  
3c59 32 7c ee			ld (debug_mark+2),a  
3c5c 18 03			jr .pastdmark  
3c5e ..			.dmark: db "MNx"  
3c61 f1			.pastdmark: pop af  
3c62			endm  
# End of macro DMARK
3c62						CALLMONITOR 
3c62 cd 39 14			call break_point_state  
3c65				endm  
# End of macro CALLMONITOR
3c65					endif 
3c65			 
3c65			 
3c65			 
3c65 3e 00				ld a, 0 
3c67 cd ca 09				call menu 
3c6a			 
3c6a			 
3c6a 6f					ld l, a 
3c6b 26 00				ld h, 0 
3c6d			 
3c6d					if DEBUG_FORTH_WORDS 
3c6d						DMARK "MNr" 
3c6d f5				push af  
3c6e 3a 82 3c			ld a, (.dmark)  
3c71 32 7a ee			ld (debug_mark),a  
3c74 3a 83 3c			ld a, (.dmark+1)  
3c77 32 7b ee			ld (debug_mark+1),a  
3c7a 3a 84 3c			ld a, (.dmark+2)  
3c7d 32 7c ee			ld (debug_mark+2),a  
3c80 18 03			jr .pastdmark  
3c82 ..			.dmark: db "MNr"  
3c85 f1			.pastdmark: pop af  
3c86			endm  
# End of macro DMARK
3c86						CALLMONITOR 
3c86 cd 39 14			call break_point_state  
3c89				endm  
# End of macro CALLMONITOR
3c89					endif 
3c89			 
3c89 cd c6 19				call forth_push_numhl 
3c8c			 
3c8c			 
3c8c			 
3c8c			 
3c8c				       NEXTW 
3c8c c3 2f 1d			jp macro_next 
3c8f				endm 
# End of macro NEXTW
3c8f			 
3c8f			 
3c8f			.ENDDISPLAY: 
3c8f			 
3c8f			; eof 
# End of file forth_words_display.asm
3c8f			include "forth_words_str.asm" 
3c8f			 
3c8f			; | ## String Words 
3c8f			 
3c8f			.PTR:   
3c8f			 
3c8f				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3c8f 48				db WORD_SYS_CORE+52             
3c90 bc 3c			dw .STYPE            
3c92 04				db 3 + 1 
3c93 .. 00			db "PTR",0              
3c97				endm 
# End of macro CWHEAD
3c97			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3c97			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3c97			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3c97			 
3c97					if DEBUG_FORTH_WORDS_KEY 
3c97						DMARK "PTR" 
3c97 f5				push af  
3c98 3a ac 3c			ld a, (.dmark)  
3c9b 32 7a ee			ld (debug_mark),a  
3c9e 3a ad 3c			ld a, (.dmark+1)  
3ca1 32 7b ee			ld (debug_mark+1),a  
3ca4 3a ae 3c			ld a, (.dmark+2)  
3ca7 32 7c ee			ld (debug_mark+2),a  
3caa 18 03			jr .pastdmark  
3cac ..			.dmark: db "PTR"  
3caf f1			.pastdmark: pop af  
3cb0			endm  
# End of macro DMARK
3cb0						CALLMONITOR 
3cb0 cd 39 14			call break_point_state  
3cb3				endm  
# End of macro CALLMONITOR
3cb3					endif 
3cb3					FORTH_DSP_VALUEHL 
3cb3 cd bd 1b			call macro_dsp_valuehl 
3cb6				endm 
# End of macro FORTH_DSP_VALUEHL
3cb6 cd c6 19				call forth_push_numhl 
3cb9			 
3cb9			 
3cb9					NEXTW 
3cb9 c3 2f 1d			jp macro_next 
3cbc				endm 
# End of macro NEXTW
3cbc			.STYPE: 
3cbc				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3cbc 48				db WORD_SYS_CORE+52             
3cbd 0b 3d			dw .UPPER            
3cbf 06				db 5 + 1 
3cc0 .. 00			db "STYPE",0              
3cc6				endm 
# End of macro CWHEAD
3cc6			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3cc6					if DEBUG_FORTH_WORDS_KEY 
3cc6						DMARK "STY" 
3cc6 f5				push af  
3cc7 3a db 3c			ld a, (.dmark)  
3cca 32 7a ee			ld (debug_mark),a  
3ccd 3a dc 3c			ld a, (.dmark+1)  
3cd0 32 7b ee			ld (debug_mark+1),a  
3cd3 3a dd 3c			ld a, (.dmark+2)  
3cd6 32 7c ee			ld (debug_mark+2),a  
3cd9 18 03			jr .pastdmark  
3cdb ..			.dmark: db "STY"  
3cde f1			.pastdmark: pop af  
3cdf			endm  
# End of macro DMARK
3cdf						CALLMONITOR 
3cdf cd 39 14			call break_point_state  
3ce2				endm  
# End of macro CALLMONITOR
3ce2					endif 
3ce2					FORTH_DSP 
3ce2 cd 83 1b			call macro_forth_dsp 
3ce5				endm 
# End of macro FORTH_DSP
3ce5					;v5 FORTH_DSP_VALUE 
3ce5			 
3ce5 7e					ld a, (hl) 
3ce6			 
3ce6 f5					push af 
3ce7			 
3ce7			; Dont destroy TOS		FORTH_DSP_POP 
3ce7			 
3ce7 f1					pop af 
3ce8			 
3ce8 fe 01				cp DS_TYPE_STR 
3cea 28 09				jr z, .typestr 
3cec			 
3cec fe 02				cp DS_TYPE_INUM 
3cee 28 0a				jr z, .typeinum 
3cf0			 
3cf0 21 09 3d				ld hl, .tna 
3cf3 18 0a				jr .tpush 
3cf5			 
3cf5 21 05 3d		.typestr:	ld hl, .tstr 
3cf8 18 05				jr .tpush 
3cfa 21 07 3d		.typeinum:	ld hl, .tinum 
3cfd 18 00				jr .tpush 
3cff			 
3cff			.tpush: 
3cff			 
3cff cd 34 1a				call forth_push_str 
3d02			 
3d02					NEXTW 
3d02 c3 2f 1d			jp macro_next 
3d05				endm 
# End of macro NEXTW
3d05 .. 00		.tstr:	db "s",0 
3d07 .. 00		.tinum:  db "i",0 
3d09 .. 00		.tna:   db "?", 0 
3d0b			 
3d0b			 
3d0b			.UPPER: 
3d0b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3d0b 48				db WORD_SYS_CORE+52             
3d0c 46 3d			dw .LOWER            
3d0e 06				db 5 + 1 
3d0f .. 00			db "UPPER",0              
3d15				endm 
# End of macro CWHEAD
3d15			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d15					if DEBUG_FORTH_WORDS_KEY 
3d15						DMARK "UPR" 
3d15 f5				push af  
3d16 3a 2a 3d			ld a, (.dmark)  
3d19 32 7a ee			ld (debug_mark),a  
3d1c 3a 2b 3d			ld a, (.dmark+1)  
3d1f 32 7b ee			ld (debug_mark+1),a  
3d22 3a 2c 3d			ld a, (.dmark+2)  
3d25 32 7c ee			ld (debug_mark+2),a  
3d28 18 03			jr .pastdmark  
3d2a ..			.dmark: db "UPR"  
3d2d f1			.pastdmark: pop af  
3d2e			endm  
# End of macro DMARK
3d2e						CALLMONITOR 
3d2e cd 39 14			call break_point_state  
3d31				endm  
# End of macro CALLMONITOR
3d31					endif 
3d31			 
3d31					FORTH_DSP 
3d31 cd 83 1b			call macro_forth_dsp 
3d34				endm 
# End of macro FORTH_DSP
3d34					 
3d34			; TODO check is string type 
3d34			 
3d34					FORTH_DSP_VALUEHL 
3d34 cd bd 1b			call macro_dsp_valuehl 
3d37				endm 
# End of macro FORTH_DSP_VALUEHL
3d37			; get pointer to string in hl 
3d37			 
3d37 7e			.toup:		ld a, (hl) 
3d38 fe 00				cp 0 
3d3a 28 07				jr z, .toupdone 
3d3c			 
3d3c cd 33 0f				call to_upper 
3d3f			 
3d3f 77					ld (hl), a 
3d40 23					inc hl 
3d41 18 f4				jr .toup 
3d43			 
3d43					 
3d43			 
3d43			 
3d43			; for each char convert to upper 
3d43					 
3d43			.toupdone: 
3d43			 
3d43			 
3d43					NEXTW 
3d43 c3 2f 1d			jp macro_next 
3d46				endm 
# End of macro NEXTW
3d46			.LOWER: 
3d46				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3d46 48				db WORD_SYS_CORE+52             
3d47 81 3d			dw .TCASE            
3d49 06				db 5 + 1 
3d4a .. 00			db "LOWER",0              
3d50				endm 
# End of macro CWHEAD
3d50			; | LOWER ( s -- s ) Lower case string s  | DONE 
3d50					if DEBUG_FORTH_WORDS_KEY 
3d50						DMARK "LWR" 
3d50 f5				push af  
3d51 3a 65 3d			ld a, (.dmark)  
3d54 32 7a ee			ld (debug_mark),a  
3d57 3a 66 3d			ld a, (.dmark+1)  
3d5a 32 7b ee			ld (debug_mark+1),a  
3d5d 3a 67 3d			ld a, (.dmark+2)  
3d60 32 7c ee			ld (debug_mark+2),a  
3d63 18 03			jr .pastdmark  
3d65 ..			.dmark: db "LWR"  
3d68 f1			.pastdmark: pop af  
3d69			endm  
# End of macro DMARK
3d69						CALLMONITOR 
3d69 cd 39 14			call break_point_state  
3d6c				endm  
# End of macro CALLMONITOR
3d6c					endif 
3d6c			 
3d6c					FORTH_DSP 
3d6c cd 83 1b			call macro_forth_dsp 
3d6f				endm 
# End of macro FORTH_DSP
3d6f					 
3d6f			; TODO check is string type 
3d6f			 
3d6f					FORTH_DSP_VALUEHL 
3d6f cd bd 1b			call macro_dsp_valuehl 
3d72				endm 
# End of macro FORTH_DSP_VALUEHL
3d72			; get pointer to string in hl 
3d72			 
3d72 7e			.tolow:		ld a, (hl) 
3d73 fe 00				cp 0 
3d75 28 07				jr z, .tolowdone 
3d77			 
3d77 cd 3c 0f				call to_lower 
3d7a			 
3d7a 77					ld (hl), a 
3d7b 23					inc hl 
3d7c 18 f4				jr .tolow 
3d7e			 
3d7e					 
3d7e			 
3d7e			 
3d7e			; for each char convert to low 
3d7e					 
3d7e			.tolowdone: 
3d7e					NEXTW 
3d7e c3 2f 1d			jp macro_next 
3d81				endm 
# End of macro NEXTW
3d81			.TCASE: 
3d81				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3d81 48				db WORD_SYS_CORE+52             
3d82 b7 3e			dw .SUBSTR            
3d84 06				db 5 + 1 
3d85 .. 00			db "TCASE",0              
3d8b				endm 
# End of macro CWHEAD
3d8b			; | TCASE ( s -- s ) Title case string s  | DONE 
3d8b					if DEBUG_FORTH_WORDS_KEY 
3d8b						DMARK "TCS" 
3d8b f5				push af  
3d8c 3a a0 3d			ld a, (.dmark)  
3d8f 32 7a ee			ld (debug_mark),a  
3d92 3a a1 3d			ld a, (.dmark+1)  
3d95 32 7b ee			ld (debug_mark+1),a  
3d98 3a a2 3d			ld a, (.dmark+2)  
3d9b 32 7c ee			ld (debug_mark+2),a  
3d9e 18 03			jr .pastdmark  
3da0 ..			.dmark: db "TCS"  
3da3 f1			.pastdmark: pop af  
3da4			endm  
# End of macro DMARK
3da4						CALLMONITOR 
3da4 cd 39 14			call break_point_state  
3da7				endm  
# End of macro CALLMONITOR
3da7					endif 
3da7			 
3da7					FORTH_DSP 
3da7 cd 83 1b			call macro_forth_dsp 
3daa				endm 
# End of macro FORTH_DSP
3daa					 
3daa			; TODO check is string type 
3daa			 
3daa					FORTH_DSP_VALUEHL 
3daa cd bd 1b			call macro_dsp_valuehl 
3dad				endm 
# End of macro FORTH_DSP_VALUEHL
3dad			; get pointer to string in hl 
3dad			 
3dad					if DEBUG_FORTH_WORDS 
3dad						DMARK "TC1" 
3dad f5				push af  
3dae 3a c2 3d			ld a, (.dmark)  
3db1 32 7a ee			ld (debug_mark),a  
3db4 3a c3 3d			ld a, (.dmark+1)  
3db7 32 7b ee			ld (debug_mark+1),a  
3dba 3a c4 3d			ld a, (.dmark+2)  
3dbd 32 7c ee			ld (debug_mark+2),a  
3dc0 18 03			jr .pastdmark  
3dc2 ..			.dmark: db "TC1"  
3dc5 f1			.pastdmark: pop af  
3dc6			endm  
# End of macro DMARK
3dc6						CALLMONITOR 
3dc6 cd 39 14			call break_point_state  
3dc9				endm  
# End of macro CALLMONITOR
3dc9					endif 
3dc9			 
3dc9					; first time in turn to upper case first char 
3dc9			 
3dc9 7e					ld a, (hl) 
3dca c3 54 3e				jp .totsiptou 
3dcd			 
3dcd			 
3dcd 7e			.tot:		ld a, (hl) 
3dce fe 00				cp 0 
3dd0 ca 98 3e				jp z, .totdone 
3dd3			 
3dd3					if DEBUG_FORTH_WORDS 
3dd3						DMARK "TC2" 
3dd3 f5				push af  
3dd4 3a e8 3d			ld a, (.dmark)  
3dd7 32 7a ee			ld (debug_mark),a  
3dda 3a e9 3d			ld a, (.dmark+1)  
3ddd 32 7b ee			ld (debug_mark+1),a  
3de0 3a ea 3d			ld a, (.dmark+2)  
3de3 32 7c ee			ld (debug_mark+2),a  
3de6 18 03			jr .pastdmark  
3de8 ..			.dmark: db "TC2"  
3deb f1			.pastdmark: pop af  
3dec			endm  
# End of macro DMARK
3dec						CALLMONITOR 
3dec cd 39 14			call break_point_state  
3def				endm  
# End of macro CALLMONITOR
3def					endif 
3def					; check to see if current char is a space 
3def			 
3def fe 20				cp ' ' 
3df1 28 21				jr z, .totsp 
3df3 cd 3c 0f				call to_lower 
3df6					if DEBUG_FORTH_WORDS 
3df6						DMARK "TC3" 
3df6 f5				push af  
3df7 3a 0b 3e			ld a, (.dmark)  
3dfa 32 7a ee			ld (debug_mark),a  
3dfd 3a 0c 3e			ld a, (.dmark+1)  
3e00 32 7b ee			ld (debug_mark+1),a  
3e03 3a 0d 3e			ld a, (.dmark+2)  
3e06 32 7c ee			ld (debug_mark+2),a  
3e09 18 03			jr .pastdmark  
3e0b ..			.dmark: db "TC3"  
3e0e f1			.pastdmark: pop af  
3e0f			endm  
# End of macro DMARK
3e0f						CALLMONITOR 
3e0f cd 39 14			call break_point_state  
3e12				endm  
# End of macro CALLMONITOR
3e12					endif 
3e12 18 63				jr .totnxt 
3e14			 
3e14			.totsp:         ; on a space, find next char which should be upper 
3e14			 
3e14					if DEBUG_FORTH_WORDS 
3e14						DMARK "TC4" 
3e14 f5				push af  
3e15 3a 29 3e			ld a, (.dmark)  
3e18 32 7a ee			ld (debug_mark),a  
3e1b 3a 2a 3e			ld a, (.dmark+1)  
3e1e 32 7b ee			ld (debug_mark+1),a  
3e21 3a 2b 3e			ld a, (.dmark+2)  
3e24 32 7c ee			ld (debug_mark+2),a  
3e27 18 03			jr .pastdmark  
3e29 ..			.dmark: db "TC4"  
3e2c f1			.pastdmark: pop af  
3e2d			endm  
# End of macro DMARK
3e2d						CALLMONITOR 
3e2d cd 39 14			call break_point_state  
3e30				endm  
# End of macro CALLMONITOR
3e30					endif 
3e30					;; 
3e30			 
3e30 fe 20				cp ' ' 
3e32 20 20				jr nz, .totsiptou 
3e34 23					inc hl 
3e35 7e					ld a, (hl) 
3e36					if DEBUG_FORTH_WORDS 
3e36						DMARK "TC5" 
3e36 f5				push af  
3e37 3a 4b 3e			ld a, (.dmark)  
3e3a 32 7a ee			ld (debug_mark),a  
3e3d 3a 4c 3e			ld a, (.dmark+1)  
3e40 32 7b ee			ld (debug_mark+1),a  
3e43 3a 4d 3e			ld a, (.dmark+2)  
3e46 32 7c ee			ld (debug_mark+2),a  
3e49 18 03			jr .pastdmark  
3e4b ..			.dmark: db "TC5"  
3e4e f1			.pastdmark: pop af  
3e4f			endm  
# End of macro DMARK
3e4f						CALLMONITOR 
3e4f cd 39 14			call break_point_state  
3e52				endm  
# End of macro CALLMONITOR
3e52					endif 
3e52 18 c0				jr .totsp 
3e54 fe 00		.totsiptou:    cp 0 
3e56 28 40				jr z, .totdone 
3e58					; not space and not zero term so upper case it 
3e58 cd 33 0f				call to_upper 
3e5b			 
3e5b					if DEBUG_FORTH_WORDS 
3e5b						DMARK "TC6" 
3e5b f5				push af  
3e5c 3a 70 3e			ld a, (.dmark)  
3e5f 32 7a ee			ld (debug_mark),a  
3e62 3a 71 3e			ld a, (.dmark+1)  
3e65 32 7b ee			ld (debug_mark+1),a  
3e68 3a 72 3e			ld a, (.dmark+2)  
3e6b 32 7c ee			ld (debug_mark+2),a  
3e6e 18 03			jr .pastdmark  
3e70 ..			.dmark: db "TC6"  
3e73 f1			.pastdmark: pop af  
3e74			endm  
# End of macro DMARK
3e74						CALLMONITOR 
3e74 cd 39 14			call break_point_state  
3e77				endm  
# End of macro CALLMONITOR
3e77					endif 
3e77			 
3e77			 
3e77			.totnxt: 
3e77			 
3e77 77					ld (hl), a 
3e78 23					inc hl 
3e79					if DEBUG_FORTH_WORDS 
3e79						DMARK "TC7" 
3e79 f5				push af  
3e7a 3a 8e 3e			ld a, (.dmark)  
3e7d 32 7a ee			ld (debug_mark),a  
3e80 3a 8f 3e			ld a, (.dmark+1)  
3e83 32 7b ee			ld (debug_mark+1),a  
3e86 3a 90 3e			ld a, (.dmark+2)  
3e89 32 7c ee			ld (debug_mark+2),a  
3e8c 18 03			jr .pastdmark  
3e8e ..			.dmark: db "TC7"  
3e91 f1			.pastdmark: pop af  
3e92			endm  
# End of macro DMARK
3e92						CALLMONITOR 
3e92 cd 39 14			call break_point_state  
3e95				endm  
# End of macro CALLMONITOR
3e95					endif 
3e95 c3 cd 3d				jp .tot 
3e98			 
3e98					 
3e98			 
3e98			 
3e98			; for each char convert to low 
3e98					 
3e98			.totdone: 
3e98					if DEBUG_FORTH_WORDS 
3e98						DMARK "TCd" 
3e98 f5				push af  
3e99 3a ad 3e			ld a, (.dmark)  
3e9c 32 7a ee			ld (debug_mark),a  
3e9f 3a ae 3e			ld a, (.dmark+1)  
3ea2 32 7b ee			ld (debug_mark+1),a  
3ea5 3a af 3e			ld a, (.dmark+2)  
3ea8 32 7c ee			ld (debug_mark+2),a  
3eab 18 03			jr .pastdmark  
3ead ..			.dmark: db "TCd"  
3eb0 f1			.pastdmark: pop af  
3eb1			endm  
# End of macro DMARK
3eb1						CALLMONITOR 
3eb1 cd 39 14			call break_point_state  
3eb4				endm  
# End of macro CALLMONITOR
3eb4					endif 
3eb4					NEXTW 
3eb4 c3 2f 1d			jp macro_next 
3eb7				endm 
# End of macro NEXTW
3eb7			 
3eb7			.SUBSTR: 
3eb7				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3eb7 48				db WORD_SYS_CORE+52             
3eb8 15 3f			dw .LEFT            
3eba 07				db 6 + 1 
3ebb .. 00			db "SUBSTR",0              
3ec2				endm 
# End of macro CWHEAD
3ec2			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3ec2			 
3ec2					if DEBUG_FORTH_WORDS_KEY 
3ec2						DMARK "SST" 
3ec2 f5				push af  
3ec3 3a d7 3e			ld a, (.dmark)  
3ec6 32 7a ee			ld (debug_mark),a  
3ec9 3a d8 3e			ld a, (.dmark+1)  
3ecc 32 7b ee			ld (debug_mark+1),a  
3ecf 3a d9 3e			ld a, (.dmark+2)  
3ed2 32 7c ee			ld (debug_mark+2),a  
3ed5 18 03			jr .pastdmark  
3ed7 ..			.dmark: db "SST"  
3eda f1			.pastdmark: pop af  
3edb			endm  
# End of macro DMARK
3edb						CALLMONITOR 
3edb cd 39 14			call break_point_state  
3ede				endm  
# End of macro CALLMONITOR
3ede					endif 
3ede			; TODO check string type 
3ede					FORTH_DSP_VALUEHL 
3ede cd bd 1b			call macro_dsp_valuehl 
3ee1				endm 
# End of macro FORTH_DSP_VALUEHL
3ee1			 
3ee1 e5					push hl      ; string length 
3ee2			 
3ee2					FORTH_DSP_POP 
3ee2 cd 75 1c			call macro_forth_dsp_pop 
3ee5				endm 
# End of macro FORTH_DSP_POP
3ee5			 
3ee5					FORTH_DSP_VALUEHL 
3ee5 cd bd 1b			call macro_dsp_valuehl 
3ee8				endm 
# End of macro FORTH_DSP_VALUEHL
3ee8			 
3ee8 e5					push hl     ; start char 
3ee9			 
3ee9					FORTH_DSP_POP 
3ee9 cd 75 1c			call macro_forth_dsp_pop 
3eec				endm 
# End of macro FORTH_DSP_POP
3eec			 
3eec			 
3eec					FORTH_DSP_VALUE 
3eec cd a6 1b			call macro_forth_dsp_value 
3eef				endm 
# End of macro FORTH_DSP_VALUE
3eef			 
3eef d1					pop de    ; get start post offset 
3ef0			 
3ef0 19					add hl, de    ; starting offset 
3ef1			 
3ef1 c1					pop bc 
3ef2 c5					push bc      ; grab size of string 
3ef3			 
3ef3 e5					push hl    ; save string start  
3ef4			 
3ef4 26 00				ld h, 0 
3ef6 69					ld l, c 
3ef7 23					inc hl 
3ef8 23					inc hl 
3ef9			 
3ef9 cd 8d 10				call malloc 
3efc				if DEBUG_FORTH_MALLOC_GUARD 
3efc cc 44 45				call z,malloc_error 
3eff				endif 
3eff			 
3eff eb					ex de, hl      ; save malloc area for string copy 
3f00 e1					pop hl    ; get back source 
3f01 c1					pop bc    ; get length of string back 
3f02			 
3f02 d5					push de    ; save malloc area for after we push 
3f03 ed b0				ldir     ; copy substr 
3f05			 
3f05			 
3f05 eb					ex de, hl 
3f06 3e 00				ld a, 0 
3f08 77					ld (hl), a   ; term substr 
3f09			 
3f09					 
3f09 e1					pop hl    ; get malloc so we can push it 
3f0a e5					push hl   ; save so we can free it afterwards 
3f0b			 
3f0b cd 34 1a				call forth_push_str 
3f0e			 
3f0e e1					pop hl 
3f0f cd 57 11				call free 
3f12			 
3f12					 
3f12					 
3f12			 
3f12			 
3f12					NEXTW 
3f12 c3 2f 1d			jp macro_next 
3f15				endm 
# End of macro NEXTW
3f15			 
3f15			.LEFT: 
3f15				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f15 48				db WORD_SYS_CORE+52             
3f16 3d 3f			dw .RIGHT            
3f18 05				db 4 + 1 
3f19 .. 00			db "LEFT",0              
3f1e				endm 
# End of macro CWHEAD
3f1e			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f1e					if DEBUG_FORTH_WORDS_KEY 
3f1e						DMARK "LEF" 
3f1e f5				push af  
3f1f 3a 33 3f			ld a, (.dmark)  
3f22 32 7a ee			ld (debug_mark),a  
3f25 3a 34 3f			ld a, (.dmark+1)  
3f28 32 7b ee			ld (debug_mark+1),a  
3f2b 3a 35 3f			ld a, (.dmark+2)  
3f2e 32 7c ee			ld (debug_mark+2),a  
3f31 18 03			jr .pastdmark  
3f33 ..			.dmark: db "LEF"  
3f36 f1			.pastdmark: pop af  
3f37			endm  
# End of macro DMARK
3f37						CALLMONITOR 
3f37 cd 39 14			call break_point_state  
3f3a				endm  
# End of macro CALLMONITOR
3f3a					endif 
3f3a			 
3f3a					NEXTW 
3f3a c3 2f 1d			jp macro_next 
3f3d				endm 
# End of macro NEXTW
3f3d			.RIGHT: 
3f3d				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f3d 48				db WORD_SYS_CORE+52             
3f3e 66 3f			dw .STR2NUM            
3f40 06				db 5 + 1 
3f41 .. 00			db "RIGHT",0              
3f47				endm 
# End of macro CWHEAD
3f47			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3f47					if DEBUG_FORTH_WORDS_KEY 
3f47						DMARK "RIG" 
3f47 f5				push af  
3f48 3a 5c 3f			ld a, (.dmark)  
3f4b 32 7a ee			ld (debug_mark),a  
3f4e 3a 5d 3f			ld a, (.dmark+1)  
3f51 32 7b ee			ld (debug_mark+1),a  
3f54 3a 5e 3f			ld a, (.dmark+2)  
3f57 32 7c ee			ld (debug_mark+2),a  
3f5a 18 03			jr .pastdmark  
3f5c ..			.dmark: db "RIG"  
3f5f f1			.pastdmark: pop af  
3f60			endm  
# End of macro DMARK
3f60						CALLMONITOR 
3f60 cd 39 14			call break_point_state  
3f63				endm  
# End of macro CALLMONITOR
3f63					endif 
3f63			 
3f63					NEXTW 
3f63 c3 2f 1d			jp macro_next 
3f66				endm 
# End of macro NEXTW
3f66			 
3f66			 
3f66			.STR2NUM: 
3f66				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3f66 48				db WORD_SYS_CORE+52             
3f67 f2 3f			dw .NUM2STR            
3f69 08				db 7 + 1 
3f6a .. 00			db "STR2NUM",0              
3f72				endm 
# End of macro CWHEAD
3f72			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3f72			 
3f72			 
3f72			; TODO STR type check to do 
3f72					if DEBUG_FORTH_WORDS_KEY 
3f72						DMARK "S2N" 
3f72 f5				push af  
3f73 3a 87 3f			ld a, (.dmark)  
3f76 32 7a ee			ld (debug_mark),a  
3f79 3a 88 3f			ld a, (.dmark+1)  
3f7c 32 7b ee			ld (debug_mark+1),a  
3f7f 3a 89 3f			ld a, (.dmark+2)  
3f82 32 7c ee			ld (debug_mark+2),a  
3f85 18 03			jr .pastdmark  
3f87 ..			.dmark: db "S2N"  
3f8a f1			.pastdmark: pop af  
3f8b			endm  
# End of macro DMARK
3f8b						CALLMONITOR 
3f8b cd 39 14			call break_point_state  
3f8e				endm  
# End of macro CALLMONITOR
3f8e					endif 
3f8e			 
3f8e					;FORTH_DSP 
3f8e					FORTH_DSP_VALUE 
3f8e cd a6 1b			call macro_forth_dsp_value 
3f91				endm 
# End of macro FORTH_DSP_VALUE
3f91					;inc hl 
3f91			 
3f91 eb					ex de, hl 
3f92					if DEBUG_FORTH_WORDS 
3f92						DMARK "S2a" 
3f92 f5				push af  
3f93 3a a7 3f			ld a, (.dmark)  
3f96 32 7a ee			ld (debug_mark),a  
3f99 3a a8 3f			ld a, (.dmark+1)  
3f9c 32 7b ee			ld (debug_mark+1),a  
3f9f 3a a9 3f			ld a, (.dmark+2)  
3fa2 32 7c ee			ld (debug_mark+2),a  
3fa5 18 03			jr .pastdmark  
3fa7 ..			.dmark: db "S2a"  
3faa f1			.pastdmark: pop af  
3fab			endm  
# End of macro DMARK
3fab						CALLMONITOR 
3fab cd 39 14			call break_point_state  
3fae				endm  
# End of macro CALLMONITOR
3fae					endif 
3fae cd bb 0f				call string_to_uint16 
3fb1			 
3fb1					if DEBUG_FORTH_WORDS 
3fb1						DMARK "S2b" 
3fb1 f5				push af  
3fb2 3a c6 3f			ld a, (.dmark)  
3fb5 32 7a ee			ld (debug_mark),a  
3fb8 3a c7 3f			ld a, (.dmark+1)  
3fbb 32 7b ee			ld (debug_mark+1),a  
3fbe 3a c8 3f			ld a, (.dmark+2)  
3fc1 32 7c ee			ld (debug_mark+2),a  
3fc4 18 03			jr .pastdmark  
3fc6 ..			.dmark: db "S2b"  
3fc9 f1			.pastdmark: pop af  
3fca			endm  
# End of macro DMARK
3fca						CALLMONITOR 
3fca cd 39 14			call break_point_state  
3fcd				endm  
# End of macro CALLMONITOR
3fcd					endif 
3fcd			;		push hl 
3fcd					FORTH_DSP_POP 
3fcd cd 75 1c			call macro_forth_dsp_pop 
3fd0				endm 
# End of macro FORTH_DSP_POP
3fd0			;		pop hl 
3fd0					 
3fd0					if DEBUG_FORTH_WORDS 
3fd0						DMARK "S2b" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 7a ee			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 7b ee			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 7c ee			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "S2b"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd 39 14			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec cd c6 19				call forth_push_numhl	 
3fef			 
3fef				 
3fef				       NEXTW 
3fef c3 2f 1d			jp macro_next 
3ff2				endm 
# End of macro NEXTW
3ff2			.NUM2STR: 
3ff2				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3ff2 48				db WORD_SYS_CORE+52             
3ff3 01 40			dw .CONCAT            
3ff5 08				db 7 + 1 
3ff6 .. 00			db "NUM2STR",0              
3ffe				endm 
# End of macro CWHEAD
3ffe			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3ffe			 
3ffe			;		; malloc a string to target 
3ffe			;		ld hl, 10     ; TODO max string size should be fine 
3ffe			;		call malloc 
3ffe			;		push hl    ; save malloc location 
3ffe			; 
3ffe			; 
3ffe			;; TODO check int type 
3ffe			;		FORTH_DSP_VALUEHL 
3ffe			;		ld a, l 
3ffe			;		call DispAToASCII   
3ffe			;;TODO need to chage above call to dump into string 
3ffe			; 
3ffe			; 
3ffe			 
3ffe				       NEXTW 
3ffe c3 2f 1d			jp macro_next 
4001				endm 
# End of macro NEXTW
4001			 
4001			.CONCAT: 
4001				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4001 48				db WORD_SYS_CORE+52             
4002 b4 40			dw .FIND            
4004 07				db 6 + 1 
4005 .. 00			db "CONCAT",0              
400c				endm 
# End of macro CWHEAD
400c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
400c			 
400c			; TODO check string type 
400c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
400c			 
400c					if DEBUG_FORTH_WORDS_KEY 
400c						DMARK "CON" 
400c f5				push af  
400d 3a 21 40			ld a, (.dmark)  
4010 32 7a ee			ld (debug_mark),a  
4013 3a 22 40			ld a, (.dmark+1)  
4016 32 7b ee			ld (debug_mark+1),a  
4019 3a 23 40			ld a, (.dmark+2)  
401c 32 7c ee			ld (debug_mark+2),a  
401f 18 03			jr .pastdmark  
4021 ..			.dmark: db "CON"  
4024 f1			.pastdmark: pop af  
4025			endm  
# End of macro DMARK
4025						CALLMONITOR 
4025 cd 39 14			call break_point_state  
4028				endm  
# End of macro CALLMONITOR
4028					endif 
4028			 
4028			 
4028					FORTH_DSP_VALUE 
4028 cd a6 1b			call macro_forth_dsp_value 
402b				endm 
# End of macro FORTH_DSP_VALUE
402b e5					push hl   ; s2 
402c			 
402c					FORTH_DSP_POP 
402c cd 75 1c			call macro_forth_dsp_pop 
402f				endm 
# End of macro FORTH_DSP_POP
402f			 
402f					FORTH_DSP_VALUE 
402f cd a6 1b			call macro_forth_dsp_value 
4032				endm 
# End of macro FORTH_DSP_VALUE
4032			 
4032 e5					push hl   ; s1 
4033			 
4033					FORTH_DSP_POP 
4033 cd 75 1c			call macro_forth_dsp_pop 
4036				endm 
# End of macro FORTH_DSP_POP
4036					 
4036			 
4036					; copy s1 
4036			 
4036				 
4036					; save ptr 
4036 e1					pop hl  
4037 e5					push hl 
4038 3e 00				ld a, 0 
403a cd 2f 10				call strlent 
403d					;inc hl    ; zer0 
403d 06 00				ld b, 0 
403f 4d					ld c, l 
4040 e1					pop hl		 
4041 11 60 e3				ld de, scratch	 
4044					if DEBUG_FORTH_WORDS 
4044						DMARK "CO1" 
4044 f5				push af  
4045 3a 59 40			ld a, (.dmark)  
4048 32 7a ee			ld (debug_mark),a  
404b 3a 5a 40			ld a, (.dmark+1)  
404e 32 7b ee			ld (debug_mark+1),a  
4051 3a 5b 40			ld a, (.dmark+2)  
4054 32 7c ee			ld (debug_mark+2),a  
4057 18 03			jr .pastdmark  
4059 ..			.dmark: db "CO1"  
405c f1			.pastdmark: pop af  
405d			endm  
# End of macro DMARK
405d						CALLMONITOR 
405d cd 39 14			call break_point_state  
4060				endm  
# End of macro CALLMONITOR
4060					endif 
4060 ed b0				ldir 
4062			 
4062 e1					pop hl 
4063 e5					push hl 
4064 d5					push de 
4065			 
4065			 
4065 3e 00				ld a, 0 
4067 cd 2f 10				call strlent 
406a 23					inc hl    ; zer0 
406b 23					inc hl 
406c 06 00				ld b, 0 
406e 4d					ld c, l 
406f d1					pop de 
4070 e1					pop hl		 
4071					if DEBUG_FORTH_WORDS 
4071						DMARK "CO2" 
4071 f5				push af  
4072 3a 86 40			ld a, (.dmark)  
4075 32 7a ee			ld (debug_mark),a  
4078 3a 87 40			ld a, (.dmark+1)  
407b 32 7b ee			ld (debug_mark+1),a  
407e 3a 88 40			ld a, (.dmark+2)  
4081 32 7c ee			ld (debug_mark+2),a  
4084 18 03			jr .pastdmark  
4086 ..			.dmark: db "CO2"  
4089 f1			.pastdmark: pop af  
408a			endm  
# End of macro DMARK
408a						CALLMONITOR 
408a cd 39 14			call break_point_state  
408d				endm  
# End of macro CALLMONITOR
408d					endif 
408d ed b0				ldir 
408f			 
408f			 
408f			 
408f 21 60 e3				ld hl, scratch 
4092					if DEBUG_FORTH_WORDS 
4092						DMARK "CO5" 
4092 f5				push af  
4093 3a a7 40			ld a, (.dmark)  
4096 32 7a ee			ld (debug_mark),a  
4099 3a a8 40			ld a, (.dmark+1)  
409c 32 7b ee			ld (debug_mark+1),a  
409f 3a a9 40			ld a, (.dmark+2)  
40a2 32 7c ee			ld (debug_mark+2),a  
40a5 18 03			jr .pastdmark  
40a7 ..			.dmark: db "CO5"  
40aa f1			.pastdmark: pop af  
40ab			endm  
# End of macro DMARK
40ab						CALLMONITOR 
40ab cd 39 14			call break_point_state  
40ae				endm  
# End of macro CALLMONITOR
40ae					endif 
40ae			 
40ae cd 34 1a				call forth_push_str 
40b1			 
40b1			 
40b1			 
40b1			 
40b1				       NEXTW 
40b1 c3 2f 1d			jp macro_next 
40b4				endm 
# End of macro NEXTW
40b4			 
40b4			 
40b4			.FIND: 
40b4				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
40b4 4b				db WORD_SYS_CORE+55             
40b5 72 41			dw .LEN            
40b7 05				db 4 + 1 
40b8 .. 00			db "FIND",0              
40bd				endm 
# End of macro CWHEAD
40bd			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
40bd			 
40bd					if DEBUG_FORTH_WORDS_KEY 
40bd						DMARK "FND" 
40bd f5				push af  
40be 3a d2 40			ld a, (.dmark)  
40c1 32 7a ee			ld (debug_mark),a  
40c4 3a d3 40			ld a, (.dmark+1)  
40c7 32 7b ee			ld (debug_mark+1),a  
40ca 3a d4 40			ld a, (.dmark+2)  
40cd 32 7c ee			ld (debug_mark+2),a  
40d0 18 03			jr .pastdmark  
40d2 ..			.dmark: db "FND"  
40d5 f1			.pastdmark: pop af  
40d6			endm  
# End of macro DMARK
40d6						CALLMONITOR 
40d6 cd 39 14			call break_point_state  
40d9				endm  
# End of macro CALLMONITOR
40d9					endif 
40d9			 
40d9			; TODO check string type 
40d9					FORTH_DSP_VALUE 
40d9 cd a6 1b			call macro_forth_dsp_value 
40dc				endm 
# End of macro FORTH_DSP_VALUE
40dc			 
40dc e5					push hl    
40dd 7e					ld a,(hl)    ; char to find   
40de			; TODO change char to substr 
40de			 
40de f5					push af 
40df					 
40df			 
40df			 
40df					if DEBUG_FORTH_WORDS 
40df						DMARK "FN1" 
40df f5				push af  
40e0 3a f4 40			ld a, (.dmark)  
40e3 32 7a ee			ld (debug_mark),a  
40e6 3a f5 40			ld a, (.dmark+1)  
40e9 32 7b ee			ld (debug_mark+1),a  
40ec 3a f6 40			ld a, (.dmark+2)  
40ef 32 7c ee			ld (debug_mark+2),a  
40f2 18 03			jr .pastdmark  
40f4 ..			.dmark: db "FN1"  
40f7 f1			.pastdmark: pop af  
40f8			endm  
# End of macro DMARK
40f8						CALLMONITOR 
40f8 cd 39 14			call break_point_state  
40fb				endm  
# End of macro CALLMONITOR
40fb					endif 
40fb			 
40fb					FORTH_DSP_POP 
40fb cd 75 1c			call macro_forth_dsp_pop 
40fe				endm 
# End of macro FORTH_DSP_POP
40fe			 
40fe					; string to search 
40fe			 
40fe					FORTH_DSP_VALUE 
40fe cd a6 1b			call macro_forth_dsp_value 
4101				endm 
# End of macro FORTH_DSP_VALUE
4101			 
4101 d1					pop de  ; d is char to find  
4102			 
4102					if DEBUG_FORTH_WORDS 
4102						DMARK "FN2" 
4102 f5				push af  
4103 3a 17 41			ld a, (.dmark)  
4106 32 7a ee			ld (debug_mark),a  
4109 3a 18 41			ld a, (.dmark+1)  
410c 32 7b ee			ld (debug_mark+1),a  
410f 3a 19 41			ld a, (.dmark+2)  
4112 32 7c ee			ld (debug_mark+2),a  
4115 18 03			jr .pastdmark  
4117 ..			.dmark: db "FN2"  
411a f1			.pastdmark: pop af  
411b			endm  
# End of macro DMARK
411b						CALLMONITOR 
411b cd 39 14			call break_point_state  
411e				endm  
# End of macro CALLMONITOR
411e					endif 
411e					 
411e 01 00 00				ld bc, 0 
4121 7e			.findchar:      ld a,(hl) 
4122 fe 00				cp 0   		 
4124 28 27				jr z, .finddone     
4126 ba					cp d 
4127 28 20				jr z, .foundchar 
4129 03					inc bc 
412a 23					inc hl 
412b					if DEBUG_FORTH_WORDS 
412b						DMARK "FN3" 
412b f5				push af  
412c 3a 40 41			ld a, (.dmark)  
412f 32 7a ee			ld (debug_mark),a  
4132 3a 41 41			ld a, (.dmark+1)  
4135 32 7b ee			ld (debug_mark+1),a  
4138 3a 42 41			ld a, (.dmark+2)  
413b 32 7c ee			ld (debug_mark+2),a  
413e 18 03			jr .pastdmark  
4140 ..			.dmark: db "FN3"  
4143 f1			.pastdmark: pop af  
4144			endm  
# End of macro DMARK
4144						CALLMONITOR 
4144 cd 39 14			call break_point_state  
4147				endm  
# End of macro CALLMONITOR
4147					endif 
4147 18 d8				jr .findchar 
4149			 
4149			 
4149 c5			.foundchar:	push bc 
414a e1					pop hl 
414b 18 03				jr .findexit 
414d			 
414d			 
414d							 
414d			 
414d			.finddone:     ; got to end of string with no find 
414d 21 00 00				ld hl, 0 
4150			.findexit: 
4150			 
4150					if DEBUG_FORTH_WORDS 
4150						DMARK "FNd" 
4150 f5				push af  
4151 3a 65 41			ld a, (.dmark)  
4154 32 7a ee			ld (debug_mark),a  
4157 3a 66 41			ld a, (.dmark+1)  
415a 32 7b ee			ld (debug_mark+1),a  
415d 3a 67 41			ld a, (.dmark+2)  
4160 32 7c ee			ld (debug_mark+2),a  
4163 18 03			jr .pastdmark  
4165 ..			.dmark: db "FNd"  
4168 f1			.pastdmark: pop af  
4169			endm  
# End of macro DMARK
4169						CALLMONITOR 
4169 cd 39 14			call break_point_state  
416c				endm  
# End of macro CALLMONITOR
416c					endif 
416c cd c6 19			call forth_push_numhl 
416f			 
416f				       NEXTW 
416f c3 2f 1d			jp macro_next 
4172				endm 
# End of macro NEXTW
4172			 
4172			.LEN: 
4172				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4172 4c				db WORD_SYS_CORE+56             
4173 a7 41			dw .CHAR            
4175 06				db 5 + 1 
4176 .. 00			db "COUNT",0              
417c				endm 
# End of macro CWHEAD
417c			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
417c			 
417c					if DEBUG_FORTH_WORDS_KEY 
417c						DMARK "CNT" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 7a ee			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 7b ee			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 7c ee			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "CNT"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195						CALLMONITOR 
4195 cd 39 14			call break_point_state  
4198				endm  
# End of macro CALLMONITOR
4198					endif 
4198			; TODO check string type 
4198					FORTH_DSP 
4198 cd 83 1b			call macro_forth_dsp 
419b				endm 
# End of macro FORTH_DSP
419b					;v5FORTH_DSP_VALUE 
419b			 
419b 23					inc hl 
419c			 
419c 3e 00				ld a, 0 
419e cd 2f 10				call strlent 
41a1			 
41a1 cd c6 19				call forth_push_numhl 
41a4			 
41a4			 
41a4			 
41a4				       NEXTW 
41a4 c3 2f 1d			jp macro_next 
41a7				endm 
# End of macro NEXTW
41a7			.CHAR: 
41a7				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
41a7 4d				db WORD_SYS_CORE+57             
41a8 dd 41			dw .ENDSTR            
41aa 05				db 4 + 1 
41ab .. 00			db "CHAR",0              
41b0				endm 
# End of macro CWHEAD
41b0			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
41b0					if DEBUG_FORTH_WORDS_KEY 
41b0						DMARK "CHR" 
41b0 f5				push af  
41b1 3a c5 41			ld a, (.dmark)  
41b4 32 7a ee			ld (debug_mark),a  
41b7 3a c6 41			ld a, (.dmark+1)  
41ba 32 7b ee			ld (debug_mark+1),a  
41bd 3a c7 41			ld a, (.dmark+2)  
41c0 32 7c ee			ld (debug_mark+2),a  
41c3 18 03			jr .pastdmark  
41c5 ..			.dmark: db "CHR"  
41c8 f1			.pastdmark: pop af  
41c9			endm  
# End of macro DMARK
41c9						CALLMONITOR 
41c9 cd 39 14			call break_point_state  
41cc				endm  
# End of macro CALLMONITOR
41cc					endif 
41cc					FORTH_DSP 
41cc cd 83 1b			call macro_forth_dsp 
41cf				endm 
# End of macro FORTH_DSP
41cf					;v5 FORTH_DSP_VALUE 
41cf 23					inc hl      ; now at start of numeric as string 
41d0			 
41d0			;		push hl 
41d0			 
41d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41d0 cd 75 1c			call macro_forth_dsp_pop 
41d3				endm 
# End of macro FORTH_DSP_POP
41d3			 
41d3			;		pop hl 
41d3			 
41d3					; push the content of a onto the stack as a value 
41d3			 
41d3 7e					ld a,(hl)   ; get char 
41d4 26 00				ld h,0 
41d6 6f					ld l,a 
41d7 cd c6 19				call forth_push_numhl 
41da			 
41da				       NEXTW 
41da c3 2f 1d			jp macro_next 
41dd				endm 
# End of macro NEXTW
41dd			 
41dd			 
41dd			 
41dd			 
41dd			.ENDSTR: 
41dd			; eof 
41dd			 
# End of file forth_words_str.asm
41dd			include "forth_words_key.asm" 
41dd			 
41dd			; | ## Keyboard Words 
41dd			 
41dd			.KEY: 
41dd				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
41dd 3e				db WORD_SYS_CORE+42             
41de 0d 42			dw .WAITK            
41e0 04				db 3 + 1 
41e1 .. 00			db "KEY",0              
41e5				endm 
# End of macro CWHEAD
41e5			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
41e5			 
41e5					if DEBUG_FORTH_WORDS_KEY 
41e5						DMARK "KEY" 
41e5 f5				push af  
41e6 3a fa 41			ld a, (.dmark)  
41e9 32 7a ee			ld (debug_mark),a  
41ec 3a fb 41			ld a, (.dmark+1)  
41ef 32 7b ee			ld (debug_mark+1),a  
41f2 3a fc 41			ld a, (.dmark+2)  
41f5 32 7c ee			ld (debug_mark+2),a  
41f8 18 03			jr .pastdmark  
41fa ..			.dmark: db "KEY"  
41fd f1			.pastdmark: pop af  
41fe			endm  
# End of macro DMARK
41fe						CALLMONITOR 
41fe cd 39 14			call break_point_state  
4201				endm  
# End of macro CALLMONITOR
4201					endif 
4201			; TODO currently waits 
4201 cd ce 58				call cin 
4204					;call cin_wait 
4204 6f					ld l, a 
4205 26 00				ld h, 0 
4207 cd c6 19				call forth_push_numhl 
420a					NEXTW 
420a c3 2f 1d			jp macro_next 
420d				endm 
# End of macro NEXTW
420d			.WAITK: 
420d				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
420d 3f				db WORD_SYS_CORE+43             
420e 3f 42			dw .ACCEPT            
4210 06				db 5 + 1 
4211 .. 00			db "WAITK",0              
4217				endm 
# End of macro CWHEAD
4217			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4217					if DEBUG_FORTH_WORDS_KEY 
4217						DMARK "WAI" 
4217 f5				push af  
4218 3a 2c 42			ld a, (.dmark)  
421b 32 7a ee			ld (debug_mark),a  
421e 3a 2d 42			ld a, (.dmark+1)  
4221 32 7b ee			ld (debug_mark+1),a  
4224 3a 2e 42			ld a, (.dmark+2)  
4227 32 7c ee			ld (debug_mark+2),a  
422a 18 03			jr .pastdmark  
422c ..			.dmark: db "WAI"  
422f f1			.pastdmark: pop af  
4230			endm  
# End of macro DMARK
4230						CALLMONITOR 
4230 cd 39 14			call break_point_state  
4233				endm  
# End of macro CALLMONITOR
4233					endif 
4233 cd c6 58				call cin_wait 
4236 6f					ld l, a 
4237 26 00				ld h, 0 
4239 cd c6 19				call forth_push_numhl 
423c					NEXTW 
423c c3 2f 1d			jp macro_next 
423f				endm 
# End of macro NEXTW
423f			.ACCEPT: 
423f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
423f 40				db WORD_SYS_CORE+44             
4240 9d 42			dw .EDIT            
4242 07				db 6 + 1 
4243 .. 00			db "ACCEPT",0              
424a				endm 
# End of macro CWHEAD
424a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
424a					; TODO crashes on push 
424a					if DEBUG_FORTH_WORDS_KEY 
424a						DMARK "ACC" 
424a f5				push af  
424b 3a 5f 42			ld a, (.dmark)  
424e 32 7a ee			ld (debug_mark),a  
4251 3a 60 42			ld a, (.dmark+1)  
4254 32 7b ee			ld (debug_mark+1),a  
4257 3a 61 42			ld a, (.dmark+2)  
425a 32 7c ee			ld (debug_mark+2),a  
425d 18 03			jr .pastdmark  
425f ..			.dmark: db "ACC"  
4262 f1			.pastdmark: pop af  
4263			endm  
# End of macro DMARK
4263						CALLMONITOR 
4263 cd 39 14			call break_point_state  
4266				endm  
# End of macro CALLMONITOR
4266					endif 
4266 21 5e e5				ld hl, os_input 
4269 3e 00				ld a, 0 
426b 77					ld (hl),a 
426c 3a 49 eb				ld a,(f_cursor_ptr) 
426f 16 64				ld d, 100 
4271 0e 00				ld c, 0 
4273 1e 28				ld e, 40 
4275 cd f3 0b				call input_str 
4278					; TODO perhaps do a type check and wrap in quotes if not a number 
4278 21 5e e5				ld hl, os_input 
427b					if DEBUG_FORTH_WORDS 
427b						DMARK "AC1" 
427b f5				push af  
427c 3a 90 42			ld a, (.dmark)  
427f 32 7a ee			ld (debug_mark),a  
4282 3a 91 42			ld a, (.dmark+1)  
4285 32 7b ee			ld (debug_mark+1),a  
4288 3a 92 42			ld a, (.dmark+2)  
428b 32 7c ee			ld (debug_mark+2),a  
428e 18 03			jr .pastdmark  
4290 ..			.dmark: db "AC1"  
4293 f1			.pastdmark: pop af  
4294			endm  
# End of macro DMARK
4294						CALLMONITOR 
4294 cd 39 14			call break_point_state  
4297				endm  
# End of macro CALLMONITOR
4297					endif 
4297 cd 34 1a				call forth_push_str 
429a					NEXTW 
429a c3 2f 1d			jp macro_next 
429d				endm 
# End of macro NEXTW
429d			 
429d			.EDIT: 
429d				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
429d 40				db WORD_SYS_CORE+44             
429e 3f 43			dw .ENDKEY            
42a0 05				db 4 + 1 
42a1 .. 00			db "EDIT",0              
42a6				endm 
# End of macro CWHEAD
42a6			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
42a6			 
42a6					; TODO does not copy from stack 
42a6					if DEBUG_FORTH_WORDS_KEY 
42a6						DMARK "EDT" 
42a6 f5				push af  
42a7 3a bb 42			ld a, (.dmark)  
42aa 32 7a ee			ld (debug_mark),a  
42ad 3a bc 42			ld a, (.dmark+1)  
42b0 32 7b ee			ld (debug_mark+1),a  
42b3 3a bd 42			ld a, (.dmark+2)  
42b6 32 7c ee			ld (debug_mark+2),a  
42b9 18 03			jr .pastdmark  
42bb ..			.dmark: db "EDT"  
42be f1			.pastdmark: pop af  
42bf			endm  
# End of macro DMARK
42bf						CALLMONITOR 
42bf cd 39 14			call break_point_state  
42c2				endm  
# End of macro CALLMONITOR
42c2					endif 
42c2			 
42c2					;FORTH_DSP 
42c2					FORTH_DSP_VALUEHL 
42c2 cd bd 1b			call macro_dsp_valuehl 
42c5				endm 
# End of macro FORTH_DSP_VALUEHL
42c5			;		inc hl    ; TODO do type check 
42c5			 
42c5			;		call get_word_hl 
42c5 e5					push hl 
42c6					if DEBUG_FORTH_WORDS 
42c6						DMARK "EDp" 
42c6 f5				push af  
42c7 3a db 42			ld a, (.dmark)  
42ca 32 7a ee			ld (debug_mark),a  
42cd 3a dc 42			ld a, (.dmark+1)  
42d0 32 7b ee			ld (debug_mark+1),a  
42d3 3a dd 42			ld a, (.dmark+2)  
42d6 32 7c ee			ld (debug_mark+2),a  
42d9 18 03			jr .pastdmark  
42db ..			.dmark: db "EDp"  
42de f1			.pastdmark: pop af  
42df			endm  
# End of macro DMARK
42df						CALLMONITOR 
42df cd 39 14			call break_point_state  
42e2				endm  
# End of macro CALLMONITOR
42e2					endif 
42e2				;	ld a, 0 
42e2 cd 24 10				call strlenz 
42e5 23					inc hl 
42e6			 
42e6 06 00				ld b, 0 
42e8 4d					ld c, l 
42e9			 
42e9 e1					pop hl 
42ea 11 5e e5				ld de, os_input 
42ed					if DEBUG_FORTH_WORDS_KEY 
42ed						DMARK "EDc" 
42ed f5				push af  
42ee 3a 02 43			ld a, (.dmark)  
42f1 32 7a ee			ld (debug_mark),a  
42f4 3a 03 43			ld a, (.dmark+1)  
42f7 32 7b ee			ld (debug_mark+1),a  
42fa 3a 04 43			ld a, (.dmark+2)  
42fd 32 7c ee			ld (debug_mark+2),a  
4300 18 03			jr .pastdmark  
4302 ..			.dmark: db "EDc"  
4305 f1			.pastdmark: pop af  
4306			endm  
# End of macro DMARK
4306						CALLMONITOR 
4306 cd 39 14			call break_point_state  
4309				endm  
# End of macro CALLMONITOR
4309					endif 
4309 ed b0				ldir 
430b			 
430b			 
430b 21 5e e5				ld hl, os_input 
430e					;ld a, 0 
430e					;ld (hl),a 
430e 3a 49 eb				ld a,(f_cursor_ptr) 
4311 16 64				ld d, 100 
4313 0e 00				ld c, 0 
4315 1e 28				ld e, 40 
4317 cd f3 0b				call input_str 
431a					; TODO perhaps do a type check and wrap in quotes if not a number 
431a 21 5e e5				ld hl, os_input 
431d					if DEBUG_FORTH_WORDS 
431d						DMARK "ED1" 
431d f5				push af  
431e 3a 32 43			ld a, (.dmark)  
4321 32 7a ee			ld (debug_mark),a  
4324 3a 33 43			ld a, (.dmark+1)  
4327 32 7b ee			ld (debug_mark+1),a  
432a 3a 34 43			ld a, (.dmark+2)  
432d 32 7c ee			ld (debug_mark+2),a  
4330 18 03			jr .pastdmark  
4332 ..			.dmark: db "ED1"  
4335 f1			.pastdmark: pop af  
4336			endm  
# End of macro DMARK
4336						CALLMONITOR 
4336 cd 39 14			call break_point_state  
4339				endm  
# End of macro CALLMONITOR
4339					endif 
4339 cd 34 1a				call forth_push_str 
433c					NEXTW 
433c c3 2f 1d			jp macro_next 
433f				endm 
# End of macro NEXTW
433f			 
433f			 
433f			 
433f			.ENDKEY: 
433f			; eof 
433f			 
# End of file forth_words_key.asm
433f			 
433f			if STORAGE_SE 
433f			   	include "forth_words_storage.asm" 
433f			endif 
433f				include "forth_words_device.asm" 
433f			; Device related words 
433f			 
433f			; | ## Device Words 
433f			 
433f			if SOUND_ENABLE 
433f			.NOTE: 
433f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
433f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
433f					if DEBUG_FORTH_WORDS_KEY 
433f						DMARK "NTE" 
433f						CALLMONITOR 
433f					endif 
433f			 
433f				 
433f			 
433f					NEXTW 
433f			.AFTERSOUND: 
433f			endif 
433f			 
433f			 
433f			USE_GPIO: equ 0 
433f			 
433f			if USE_GPIO 
433f			.GP1: 
433f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
433f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
433f					NEXTW 
433f			.GP2: 
433f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
433f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
433f			 
433f					NEXTW 
433f			 
433f			.GP3: 
433f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
433f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
433f			 
433f					NEXTW 
433f			 
433f			.GP4: 
433f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
433f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
433f			 
433f					NEXTW 
433f			.SIN: 
433f			 
433f			 
433f			endif 
433f			 
433f			 
433f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
433f 33				db WORD_SYS_CORE+31             
4340 74 43			dw .SOUT            
4342 03				db 2 + 1 
4343 .. 00			db "IN",0              
4346				endm 
# End of macro CWHEAD
4346			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4346					if DEBUG_FORTH_WORDS_KEY 
4346						DMARK "IN." 
4346 f5				push af  
4347 3a 5b 43			ld a, (.dmark)  
434a 32 7a ee			ld (debug_mark),a  
434d 3a 5c 43			ld a, (.dmark+1)  
4350 32 7b ee			ld (debug_mark+1),a  
4353 3a 5d 43			ld a, (.dmark+2)  
4356 32 7c ee			ld (debug_mark+2),a  
4359 18 03			jr .pastdmark  
435b ..			.dmark: db "IN."  
435e f1			.pastdmark: pop af  
435f			endm  
# End of macro DMARK
435f						CALLMONITOR 
435f cd 39 14			call break_point_state  
4362				endm  
# End of macro CALLMONITOR
4362					endif 
4362					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4362 cd bd 1b			call macro_dsp_valuehl 
4365				endm 
# End of macro FORTH_DSP_VALUEHL
4365			 
4365 e5					push hl 
4366			 
4366					; destroy value TOS 
4366			 
4366					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4366 cd 75 1c			call macro_forth_dsp_pop 
4369				endm 
# End of macro FORTH_DSP_POP
4369			 
4369					; one value on hl get other one back 
4369			 
4369 c1					pop bc 
436a			 
436a					; do the sub 
436a			;		ex de, hl 
436a			 
436a ed 68				in l,(c) 
436c			 
436c					; save it 
436c			 
436c 26 00				ld h,0 
436e			 
436e					; TODO push value back onto stack for another op etc 
436e			 
436e cd c6 19				call forth_push_numhl 
4371					NEXTW 
4371 c3 2f 1d			jp macro_next 
4374				endm 
# End of macro NEXTW
4374			.SOUT: 
4374				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4374 34				db WORD_SYS_CORE+32             
4375 c7 43			dw .SPIO            
4377 04				db 3 + 1 
4378 .. 00			db "OUT",0              
437c				endm 
# End of macro CWHEAD
437c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
437c					if DEBUG_FORTH_WORDS_KEY 
437c						DMARK "OUT" 
437c f5				push af  
437d 3a 91 43			ld a, (.dmark)  
4380 32 7a ee			ld (debug_mark),a  
4383 3a 92 43			ld a, (.dmark+1)  
4386 32 7b ee			ld (debug_mark+1),a  
4389 3a 93 43			ld a, (.dmark+2)  
438c 32 7c ee			ld (debug_mark+2),a  
438f 18 03			jr .pastdmark  
4391 ..			.dmark: db "OUT"  
4394 f1			.pastdmark: pop af  
4395			endm  
# End of macro DMARK
4395						CALLMONITOR 
4395 cd 39 14			call break_point_state  
4398				endm  
# End of macro CALLMONITOR
4398					endif 
4398			 
4398					; get port 
4398			 
4398					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4398 cd bd 1b			call macro_dsp_valuehl 
439b				endm 
# End of macro FORTH_DSP_VALUEHL
439b			 
439b e5					push hl 
439c			 
439c					; destroy value TOS 
439c			 
439c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439c cd 75 1c			call macro_forth_dsp_pop 
439f				endm 
# End of macro FORTH_DSP_POP
439f			 
439f					; get byte to send 
439f			 
439f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
439f cd bd 1b			call macro_dsp_valuehl 
43a2				endm 
# End of macro FORTH_DSP_VALUEHL
43a2			 
43a2			;		push hl 
43a2			 
43a2					; destroy value TOS 
43a2			 
43a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43a2 cd 75 1c			call macro_forth_dsp_pop 
43a5				endm 
# End of macro FORTH_DSP_POP
43a5			 
43a5					; one value on hl get other one back 
43a5			 
43a5			;		pop hl 
43a5			 
43a5 c1					pop bc 
43a6			 
43a6					if DEBUG_FORTH_WORDS 
43a6						DMARK "OUT" 
43a6 f5				push af  
43a7 3a bb 43			ld a, (.dmark)  
43aa 32 7a ee			ld (debug_mark),a  
43ad 3a bc 43			ld a, (.dmark+1)  
43b0 32 7b ee			ld (debug_mark+1),a  
43b3 3a bd 43			ld a, (.dmark+2)  
43b6 32 7c ee			ld (debug_mark+2),a  
43b9 18 03			jr .pastdmark  
43bb ..			.dmark: db "OUT"  
43be f1			.pastdmark: pop af  
43bf			endm  
# End of macro DMARK
43bf						CALLMONITOR 
43bf cd 39 14			call break_point_state  
43c2				endm  
# End of macro CALLMONITOR
43c2					endif 
43c2			 
43c2 ed 69				out (c), l 
43c4			 
43c4					NEXTW 
43c4 c3 2f 1d			jp macro_next 
43c7				endm 
# End of macro NEXTW
43c7			 
43c7			 
43c7			.SPIO: 
43c7			 
43c7			if STORAGE_SE 
43c7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
43c7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
43c7			 
43c7					call spi_ce_low 
43c7			    NEXTW 
43c7			 
43c7			.SPICEH: 
43c7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
43c7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
43c7			 
43c7					call spi_ce_high 
43c7			    NEXTW 
43c7			 
43c7			 
43c7			.SPIOb: 
43c7			 
43c7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
43c7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
43c7			 
43c7					; get port 
43c7			 
43c7			 
43c7					; get byte to send 
43c7			 
43c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c7			 
43c7			;		push hl    ; u1  
43c7			 
43c7					; destroy value TOS 
43c7			 
43c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c7			 
43c7					; one value on hl get other one back 
43c7			 
43c7			;		pop hl   ; u2 - addr 
43c7			 
43c7					; TODO Send SPI byte 
43c7			 
43c7					ld a, l 
43c7					call spi_send_byte 
43c7			 
43c7					NEXTW 
43c7			 
43c7			.SPII: 
43c7				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
43c7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
43c7			 
43c7					; TODO Get SPI byte 
43c7			 
43c7					call spi_read_byte 
43c7			 
43c7					ld h, 0 
43c7					ld l, a 
43c7					call forth_push_numhl 
43c7			 
43c7					NEXTW 
43c7			 
43c7			 
43c7			 
43c7			.SESEL: 
43c7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
43c7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
43c7					if DEBUG_FORTH_WORDS_KEY 
43c7						DMARK "BNK" 
43c7						CALLMONITOR 
43c7					endif 
43c7			 
43c7					ld a, 255 
43c7					ld (spi_cartdev), a 
43c7			 
43c7					; get bank 
43c7			 
43c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c7			 
43c7			;		push hl 
43c7			 
43c7					; destroy value TOS 
43c7			 
43c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c7			 
43c7					; one value on hl get other one back 
43c7			 
43c7			;		pop hl 
43c7			 
43c7			 
43c7					ld c, SPI_CE_HIGH 
43c7					ld b, '0'    ; human readable bank number 
43c7			 
43c7					ld a, l 
43c7			 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "BNK" 
43c7						CALLMONITOR 
43c7					endif 
43c7			 
43c7					; active low 
43c7			 
43c7					cp 0 
43c7					jr z, .bset 
43c7					cp 1 
43c7					jr nz, .b2 
43c7					res 0, c 
43c7					ld b, '1'    ; human readable bank number 
43c7			.b2:		cp 2 
43c7					jr nz, .b3 
43c7					res 1, c 
43c7					ld b, '2'    ; human readable bank number 
43c7			.b3:		cp 3 
43c7					jr nz, .b4 
43c7					res 2, c 
43c7					ld b, '3'    ; human readable bank number 
43c7			.b4:		cp 4 
43c7					jr nz, .b5 
43c7					res 3, c 
43c7					ld b, '4'    ; human readable bank number 
43c7			.b5:		cp 5 
43c7					jr nz, .bset 
43c7					res 4, c 
43c7					ld b, '5'    ; human readable bank number 
43c7			 
43c7			.bset: 
43c7					ld a, c 
43c7					ld (spi_device),a 
43c7					ld a, b 
43c7					ld (spi_device_id),a 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "BN2" 
43c7						CALLMONITOR 
43c7					endif 
43c7			 
43c7					NEXTW 
43c7			 
43c7			.CARTDEV: 
43c7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
43c7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
43c7					if DEBUG_FORTH_WORDS_KEY 
43c7						DMARK "CDV" 
43c7						CALLMONITOR 
43c7					endif 
43c7			 
43c7					; disable se storage bank selection 
43c7			 
43c7					ld a, SPI_CE_HIGH		; ce high 
43c7					ld (spi_device), a 
43c7			 
43c7					; get bank 
43c7			 
43c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c7			 
43c7			;		push hl 
43c7			 
43c7					; destroy value TOS 
43c7			 
43c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c7			 
43c7					; one value on hl get other one back 
43c7			 
43c7			;		pop hl 
43c7			 
43c7					; active low 
43c7			 
43c7					ld c, 255 
43c7			 
43c7					ld a, l 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "CDV" 
43c7						CALLMONITOR 
43c7					endif 
43c7					cp 0 
43c7					jr z, .cset 
43c7					cp 1 
43c7					jr nz, .c2 
43c7					res 0, c 
43c7			.c2:		cp 2 
43c7					jr nz, .c3 
43c7					res 1, c 
43c7			.c3:		cp 3 
43c7					jr nz, .c4 
43c7					res 2, c 
43c7			.c4:		cp 4 
43c7					jr nz, .c5 
43c7					res 3, c 
43c7			.c5:		cp 5 
43c7					jr nz, .c6 
43c7					res 4, c 
43c7			.c6:		cp 6 
43c7					jr nz, .c7 
43c7					res 5, c 
43c7			.c7:		cp 7 
43c7					jr nz, .c8 
43c7					res 6, c 
43c7			.c8:		cp 8 
43c7					jr nz, .cset 
43c7					res 7, c 
43c7			.cset:		ld a, c 
43c7					ld (spi_cartdev),a 
43c7			 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "CD2" 
43c7						CALLMONITOR 
43c7					endif 
43c7					NEXTW 
43c7			endif 
43c7			 
43c7			.ENDDEVICE: 
43c7			; eof 
43c7			 
# End of file forth_words_device.asm
43c7			 
43c7			; var handler 
43c7			 
43c7			 
43c7			.VARS: 
43c7				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
43c7 78				db WORD_SYS_CORE+100             
43c8 df 43			dw .V0Q            
43ca 04				db 3 + 1 
43cb .. 00			db "V0!",0              
43cf				endm 
# End of macro CWHEAD
43cf			;| V0! ( u1 -- )  Store value to v0  | DONE 
43cf			 
43cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43cf cd bd 1b			call macro_dsp_valuehl 
43d2				endm 
# End of macro FORTH_DSP_VALUEHL
43d2			 
43d2 11 13 eb				ld de, cli_var_array 
43d5			 
43d5 eb					ex de, hl 
43d6 73					ld (hl), e 
43d7 23					inc hl 
43d8 72					ld (hl), d 
43d9			 
43d9					; destroy value TOS 
43d9			 
43d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43d9 cd 75 1c			call macro_forth_dsp_pop 
43dc				endm 
# End of macro FORTH_DSP_POP
43dc			 
43dc				       NEXTW 
43dc c3 2f 1d			jp macro_next 
43df				endm 
# End of macro NEXTW
43df			.V0Q: 
43df				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
43df 79				db WORD_SYS_CORE+101             
43e0 f0 43			dw .V1S            
43e2 04				db 3 + 1 
43e3 .. 00			db "V0@",0              
43e7				endm 
# End of macro CWHEAD
43e7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
43e7 2a 13 eb				ld hl, (cli_var_array) 
43ea cd c6 19				call forth_push_numhl 
43ed			 
43ed				       NEXTW 
43ed c3 2f 1d			jp macro_next 
43f0				endm 
# End of macro NEXTW
43f0			.V1S: 
43f0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
43f0 7a				db WORD_SYS_CORE+102             
43f1 08 44			dw .V1Q            
43f3 04				db 3 + 1 
43f4 .. 00			db "V1!",0              
43f8				endm 
# End of macro CWHEAD
43f8			;| V1! ( u1 -- )  Store value to v1 | DONE 
43f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f8 cd bd 1b			call macro_dsp_valuehl 
43fb				endm 
# End of macro FORTH_DSP_VALUEHL
43fb			 
43fb 11 15 eb				ld de, cli_var_array+2 
43fe				 
43fe eb					ex de, hl 
43ff 73					ld (hl), e 
4400 23					inc hl 
4401 72					ld (hl), d 
4402			 
4402					; destroy value TOS 
4402			 
4402					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4402 cd 75 1c			call macro_forth_dsp_pop 
4405				endm 
# End of macro FORTH_DSP_POP
4405				       NEXTW 
4405 c3 2f 1d			jp macro_next 
4408				endm 
# End of macro NEXTW
4408			.V1Q: 
4408				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4408 7b				db WORD_SYS_CORE+103             
4409 19 44			dw .V2S            
440b 04				db 3 + 1 
440c .. 00			db "V1@",0              
4410				endm 
# End of macro CWHEAD
4410			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4410 2a 15 eb				ld hl, (cli_var_array+2) 
4413 cd c6 19				call forth_push_numhl 
4416				       NEXTW 
4416 c3 2f 1d			jp macro_next 
4419				endm 
# End of macro NEXTW
4419			.V2S: 
4419				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4419 7c				db WORD_SYS_CORE+104             
441a 31 44			dw .V2Q            
441c 04				db 3 + 1 
441d .. 00			db "V2!",0              
4421				endm 
# End of macro CWHEAD
4421			;| V2! ( u1 -- )  Store value to v2 | DONE 
4421					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4421 cd bd 1b			call macro_dsp_valuehl 
4424				endm 
# End of macro FORTH_DSP_VALUEHL
4424			 
4424 11 17 eb				ld de, cli_var_array+4 
4427				 
4427 eb					ex de, hl 
4428 73					ld (hl), e 
4429 23					inc hl 
442a 72					ld (hl), d 
442b			 
442b					; destroy value TOS 
442b			 
442b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
442b cd 75 1c			call macro_forth_dsp_pop 
442e				endm 
# End of macro FORTH_DSP_POP
442e				       NEXTW 
442e c3 2f 1d			jp macro_next 
4431				endm 
# End of macro NEXTW
4431			.V2Q: 
4431				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4431 7d				db WORD_SYS_CORE+105             
4432 42 44			dw .V3S            
4434 04				db 3 + 1 
4435 .. 00			db "V2@",0              
4439				endm 
# End of macro CWHEAD
4439			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4439 2a 17 eb				ld hl, (cli_var_array+4) 
443c cd c6 19				call forth_push_numhl 
443f				       NEXTW 
443f c3 2f 1d			jp macro_next 
4442				endm 
# End of macro NEXTW
4442			.V3S: 
4442				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4442 7c				db WORD_SYS_CORE+104             
4443 5a 44			dw .V3Q            
4445 04				db 3 + 1 
4446 .. 00			db "V3!",0              
444a				endm 
# End of macro CWHEAD
444a			;| V3! ( u1 -- )  Store value to v3 | DONE 
444a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
444a cd bd 1b			call macro_dsp_valuehl 
444d				endm 
# End of macro FORTH_DSP_VALUEHL
444d			 
444d 11 19 eb				ld de, cli_var_array+6 
4450				 
4450 eb					ex de, hl 
4451 73					ld (hl), e 
4452 23					inc hl 
4453 72					ld (hl), d 
4454			 
4454					; destroy value TOS 
4454			 
4454					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4454 cd 75 1c			call macro_forth_dsp_pop 
4457				endm 
# End of macro FORTH_DSP_POP
4457				       NEXTW 
4457 c3 2f 1d			jp macro_next 
445a				endm 
# End of macro NEXTW
445a			.V3Q: 
445a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
445a 7d				db WORD_SYS_CORE+105             
445b 6b 44			dw .END            
445d 04				db 3 + 1 
445e .. 00			db "V3@",0              
4462				endm 
# End of macro CWHEAD
4462			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4462 2a 19 eb				ld hl, (cli_var_array+6) 
4465 cd c6 19				call forth_push_numhl 
4468				       NEXTW 
4468 c3 2f 1d			jp macro_next 
446b				endm 
# End of macro NEXTW
446b			 
446b			 
446b			 
446b			 
446b			 
446b			; end of dict marker 
446b			 
446b 00			.END:    db WORD_SYS_END 
446c 00 00			dw 0 
446e 00				db 0 
446f			 
446f			; use to jp here for user dict words to save on macro expansion  
446f			 
446f			user_dict_next: 
446f				NEXTW 
446f c3 2f 1d			jp macro_next 
4472				endm 
# End of macro NEXTW
4472			 
4472			 
4472			user_exec: 
4472				;    ld hl, <word code> 
4472				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4472				;    call forthexec 
4472				;    jp user_dict_next   (NEXT) 
4472			        ;    <word code bytes> 
4472 eb				ex de, hl 
4473 2a 61 e6			ld hl,(os_tok_ptr) 
4476				 
4476				FORTH_RSP_NEXT 
4476 cd 6d 19			call macro_forth_rsp_next 
4479				endm 
# End of macro FORTH_RSP_NEXT
4479			 
4479			if DEBUG_FORTH_UWORD 
4479						DMARK "UEX" 
4479 f5				push af  
447a 3a 8e 44			ld a, (.dmark)  
447d 32 7a ee			ld (debug_mark),a  
4480 3a 8f 44			ld a, (.dmark+1)  
4483 32 7b ee			ld (debug_mark+1),a  
4486 3a 90 44			ld a, (.dmark+2)  
4489 32 7c ee			ld (debug_mark+2),a  
448c 18 03			jr .pastdmark  
448e ..			.dmark: db "UEX"  
4491 f1			.pastdmark: pop af  
4492			endm  
# End of macro DMARK
4492				CALLMONITOR 
4492 cd 39 14			call break_point_state  
4495				endm  
# End of macro CALLMONITOR
4495			endif 
4495			 
4495			 
4495			 
4495 eb				ex de, hl 
4496 22 61 e6			ld (os_tok_ptr), hl 
4499				 
4499				; Don't use next - Skips the first word in uword. 
4499			 
4499 c3 c0 1d			jp exec1 
449c			;	NEXT 
449c			 
449c			 
449c			; eof 
# End of file forth_wordsv4.asm
449c			endif 
449c			;;;;;;;;;;;;;; Debug code 
449c			 
449c			 
449c			;if DEBUG_FORTH_PARSE 
449c .. 00		.nowordfound: db "No match",0 
44a5 .. 00		.compword:	db "Comparing word ",0 
44b5 .. 00		.nextwordat:	db "Next word at",0 
44c2 .. 00		.charmatch:	db "Char match",0 
44cd			;endif 
44cd			if DEBUG_FORTH_JP 
44cd			.foundword:	db "Word match. Exec..",0 
44cd			endif 
44cd			;if DEBUG_FORTH_PUSH 
44cd .. 00		.enddict:	db "Dict end. Push.",0 
44dd .. 00		.push_str:	db "Pushing string",0 
44ec .. 00		.push_num:	db "Pushing number",0 
44fb .. 00		.data_sp:	db "SP:",0 
44ff .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4511 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4523 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4535			;endif 
4535			;if DEBUG_FORTH_MALLOC 
4535 .. 00		.push_malloc:	db "Malloc address",0 
4544			;endif 
4544			 
4544			 
4544			 
4544			; display malloc address and current data stack pointer  
4544			 
4544			malloc_error: 
4544 d5				push de 
4545 f5				push af 
4546 e5				push hl 
4547 cd 99 09			call clear_display 
454a 11 6c 45			ld de, .mallocerr 
454d 3e 00			ld a,0 
454f			;	ld de,os_word_scratch 
454f cd ac 09			call str_at_display 
4552 3e 11			ld a, display_row_1+17 
4554 11 7a ee			ld de, debug_mark 
4557 cd ac 09			call str_at_display 
455a cd bc 09			call update_display 
455d				;call break_point_state 
455d cd c6 58			call cin_wait 
4560			 
4560 3e 20			ld a, ' ' 
4562 32 51 e3			ld (os_view_disable), a 
4565 e1				pop hl 
4566 f1				pop af 
4567 d1				pop de	 
4568				CALLMONITOR 
4568 cd 39 14			call break_point_state  
456b				endm  
# End of macro CALLMONITOR
456b c9				ret 
456c			 
456c .. 00		.mallocerr: 	db "Malloc Error",0 
4579			;if DEBUG_FORTH_PUSH 
4579			display_data_sp: 
4579 f5				push af 
457a			 
457a				; see if disabled 
457a			 
457a 3a 51 e3			ld a, (os_view_disable) 
457d fe 2a			cp '*' 
457f 28 67			jr z, .skipdsp 
4581			 
4581 e5				push hl 
4582 e5				push hl 
4583 e5			push hl 
4584 cd 99 09			call clear_display 
4587 e1			pop hl 
4588 7c				ld a,h 
4589 21 65 e6			ld hl, os_word_scratch 
458c cd c7 0e			call hexout 
458f e1				pop hl 
4590 7d				ld a,l 
4591 21 67 e6			ld hl, os_word_scratch+2 
4594 cd c7 0e			call hexout 
4597 21 69 e6			ld hl, os_word_scratch+4 
459a 3e 00			ld a,0 
459c 77				ld (hl),a 
459d 11 65 e6			ld de,os_word_scratch 
45a0 3e 28				ld a, display_row_2 
45a2 cd ac 09				call str_at_display 
45a5 11 ff 44			ld de, .wordinhl 
45a8 3e 00			ld a, display_row_1 
45aa			 
45aa cd ac 09				call str_at_display 
45ad 11 7a ee			ld de, debug_mark 
45b0 3e 11			ld a, display_row_1+17 
45b2			 
45b2 cd ac 09				call str_at_display 
45b5			 
45b5				; display current data stack pointer 
45b5 11 fb 44			ld de,.data_sp 
45b8 3e 30				ld a, display_row_2 + 8 
45ba cd ac 09				call str_at_display 
45bd			 
45bd 2a 0d eb			ld hl,(cli_data_sp) 
45c0 e5				push hl 
45c1 7c				ld a,h 
45c2 21 65 e6			ld hl, os_word_scratch 
45c5 cd c7 0e			call hexout 
45c8 e1				pop hl 
45c9 7d				ld a,l 
45ca 21 67 e6			ld hl, os_word_scratch+2 
45cd cd c7 0e			call hexout 
45d0 21 69 e6			ld hl, os_word_scratch+4 
45d3 3e 00			ld a,0 
45d5 77				ld (hl),a 
45d6 11 65 e6			ld de,os_word_scratch 
45d9 3e 33				ld a, display_row_2 + 11 
45db cd ac 09				call str_at_display 
45de			 
45de			 
45de cd bc 09			call update_display 
45e1 cd 0e 09			call delay1s 
45e4 cd 0e 09			call delay1s 
45e7 e1				pop hl 
45e8			.skipdsp: 
45e8 f1				pop af 
45e9 c9				ret 
45ea			 
45ea			display_data_malloc: 
45ea			 
45ea f5				push af 
45eb e5				push hl 
45ec e5				push hl 
45ed e5			push hl 
45ee cd 99 09			call clear_display 
45f1 e1			pop hl 
45f2 7c				ld a,h 
45f3 21 65 e6			ld hl, os_word_scratch 
45f6 cd c7 0e			call hexout 
45f9 e1				pop hl 
45fa 7d				ld a,l 
45fb 21 67 e6			ld hl, os_word_scratch+2 
45fe cd c7 0e			call hexout 
4601 21 69 e6			ld hl, os_word_scratch+4 
4604 3e 00			ld a,0 
4606 77				ld (hl),a 
4607 11 65 e6			ld de,os_word_scratch 
460a 3e 28				ld a, display_row_2 
460c cd ac 09				call str_at_display 
460f 11 35 45			ld de, .push_malloc 
4612 3e 00			ld a, display_row_1 
4614			 
4614 cd ac 09				call str_at_display 
4617			 
4617				; display current data stack pointer 
4617 11 fb 44			ld de,.data_sp 
461a 3e 30				ld a, display_row_2 + 8 
461c cd ac 09				call str_at_display 
461f			 
461f 2a 0d eb			ld hl,(cli_data_sp) 
4622 e5				push hl 
4623 7c				ld a,h 
4624 21 65 e6			ld hl, os_word_scratch 
4627 cd c7 0e			call hexout 
462a e1				pop hl 
462b 7d				ld a,l 
462c 21 67 e6			ld hl, os_word_scratch+2 
462f cd c7 0e			call hexout 
4632 21 69 e6			ld hl, os_word_scratch+4 
4635 3e 00			ld a,0 
4637 77				ld (hl),a 
4638 11 65 e6			ld de,os_word_scratch 
463b 3e 33				ld a, display_row_2 + 11 
463d cd ac 09				call str_at_display 
4640			 
4640 cd bc 09			call update_display 
4643 cd 0e 09			call delay1s 
4646 cd 0e 09			call delay1s 
4649 e1				pop hl 
464a f1				pop af 
464b c9				ret 
464c			;endif 
464c			 
464c			include "forth_autostart.asm" 
464c			; list of commands to perform at system start up 
464c			 
464c			startcmds: 
464c			;	dw test11 
464c			;	dw test12 
464c			;	dw test13 
464c			;	dw test14 
464c			;	dw test15 
464c			;	dw test16 
464c			;	dw test17 
464c			;	dw ifthtest1 
464c			;	dw ifthtest2 
464c			;	dw ifthtest3 
464c			;	dw mmtest1 
464c			;	dw mmtest2 
464c			;	dw mmtest3 
464c			;	dw mmtest4 
464c			;	dw mmtest5 
464c			;	dw mmtest6 
464c			;	dw iftest1 
464c			;	dw iftest2 
464c			;	dw iftest3 
464c			;	dw looptest1 
464c			;	dw looptest2 
464c			;	dw test1 
464c			;	dw test2 
464c			;	dw test3 
464c			;	dw test4 
464c			;	dw game2r 
464c			;	dw game2b1 
464c			;	dw game2b2 
464c			 
464c				; start up words that are actually useful 
464c			 
464c aa 46			dw clrstack 
464e dd 46			dw type 
4650 9e 48			dw stest 
4652 01 47			dw strncpy 
4654 3f 48			dw list 
4656 62 47			dw start1 
4658 74 47			dw start2 
465a			;	dw start3 
465a 87 47			dw start3b 
465c df 47			dw start3c 
465e			 
465e				; (unit) testing words 
465e			 
465e 15 49			dw mtesta 
4660 ca 49			dw mtestb 
4662 6d 4a			dw mtestc 
4664 22 4b			dw mtestd 
4666 c6 4b			dw mteste 
4668			 
4668				; demo/game words 
4668			 
4668 d2 52		        dw game3w 
466a 00 53		        dw game3p 
466c 1e 53		        dw game3sc 
466e 4f 53		        dw game3vsi 
4670 7b 53		        dw game3vs 
4672				 
4672 c5 50			dw game2b 
4674 33 51			dw game2bf 
4676 7d 51			dw game2mba 
4678 13 52			dw game2mbas 
467a 55 52			dw game2mb 
467c			 
467c 86 4d			dw game1 
467e 97 4d			dw game1a 
4680 f9 4d			dw game1b 
4682 2e 4e			dw game1c 
4684 64 4e			dw game1d 
4686 95 4e			dw game1s 
4688 a9 4e			dw game1t 
468a be 4e			dw game1f 
468c f2 4e			dw game1z 
468e 36 4f			dw game1zz 
4690			 
4690 7c 4c			dw test5 
4692 b4 4c			dw test6 
4694 ec 4c			dw test7 
4696 00 4d			dw test8 
4698 2c 4d			dw test9 
469a 42 4d			dw test10 
469c				 
469c 0d 50		        dw ssv5 
469e f1 4f		        dw ssv4 
46a0 d5 4f		        dw ssv3 
46a2 9f 4f		        dw ssv2 
46a4 26 50		        dw ssv1 
46a6 6e 50		        dw ssv1cpm 
46a8			;	dw keyup 
46a8			;	dw keydown 
46a8			;	dw keyleft 
46a8			;	dw keyright 
46a8			;	dw 	keyf1 
46a8			;	dw keyf2 
46a8			;	dw keyf3 
46a8			;	dw keyf4 
46a8			;	dw keyf5 
46a8			;	dw keyf6 
46a8			;	dw keyf7 
46a8			;	dw keyf8 
46a8			;	dw keyf9 
46a8			;	dw keyf10 
46a8			;	dw keyf11 
46a8			;	dw keyf12 
46a8			;	dw keytab 
46a8			;	dw keycr 
46a8			;	dw keyhome 
46a8			;	dw keyend 
46a8			;	dw keybs 
46a8 00 00			db 0, 0	 
46aa			 
46aa			 
46aa			; clear stack  
46aa			 
46aa .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
46dd			 
46dd			; type ( addr count - ) 
46dd .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4701			 
4701			; some direct memory words 
4701			; strncpy ( len t f -- t ) 
4701			 
4701 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4762			 
4762 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4774 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4787			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4787 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
47df .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
483f			 
483f			 
483f			; a handy word to list items on the stack 
483f			 
483f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
489e			 
489e			 
489e			; test stack  
489e			; rnd8 stest 
489e			 
489e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4915			 
4915			; random malloc and free cycles 
4915			 
4915 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
49ca			 
49ca			; fixed malloc and free cycles 
49ca			 
49ca .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a6d			 
4a6d			; fixed double string push and drop cycle  
4a6d			 
4a6d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4b22			 
4b22			; consistent fixed string push and drop cycle  
4b22			 
4b22 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4bc6			 
4bc6 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c7c			 
4c7c			;test1:		db ": aa 1 2 3 ;", 0 
4c7c			;test2:     	db "111 aa 888 999",0 
4c7c			;test3:     	db ": bb 77 ;",0 
4c7c			;test4:     	db "$02 $01 do i . loop bb",0 
4c7c			 
4c7c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4cb4 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4cec .. 00		test7:     	db ": box hline vline ;",0 
4d00 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4d2c .. 00		test9:     	db ": sw $01 adsp world ;",0 
4d42 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4d67 .. 00		test11:     	db "hello create .",0 
4d76 .. 00		test12:     	db "hello2 create .",0 
4d86			 
4d86			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4d86			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4d86			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4d86			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4d86			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4d86			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4d86			 
4d86			;iftest1:     	db "$0001 IF cls .",0 
4d86			;iftest2:     	db "$0000 IF cls .",0 
4d86			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4d86			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4d86			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4d86			 
4d86			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d86			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d86			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d86			 
4d86			 
4d86			 
4d86			; a small guess the number game 
4d86			 
4d86 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4d97 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4df9			 
4df9 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4e2e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4e64 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4e95 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4ea9 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4ebe .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4ef2 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4f36			 
4f36			; Using 'ga' save a high score across multiple runs using external storage 
4f36			 
4f36 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4f9f			 
4f9f			 
4f9f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4f9f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f9f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f9f			 
4f9f			; simple screen saver to test code memory reuse to destruction 
4f9f			 
4f9f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4fd5 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4ff1 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
500d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5026 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
506e .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
50c5			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
50c5			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
50c5			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
50c5			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
50c5			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
50c5			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
50c5			 
50c5			 
50c5			 
50c5			; minesweeper/battleship finding game 
50c5			; draws a game board of random ship/mine positions 
50c5			; user enters coords to see if it hits on 
50c5			; game ends when all are hit 
50c5			; when hit or miss says how many may be in the area 
50c5			 
50c5			; setup the game board and then hide it 
50c5 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5133 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
517d			; prompt for where to target 
517d .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5213 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5238			; TODO see if the entered coords hits or misses pushes char hit of miss 
5238 .. 00		game2mbht:      db ": mbckht nop ;",0 
5247 .. 00		game2mbms:      db ": mbcms nop ;",0 
5255			; TODO how many might be near by 
5255 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
52d2			 
52d2			; Game 3 
52d2			 
52d2			; Vert scroller ski game - avoid the trees! 
52d2			 
52d2			; v0 score (ie turns) 
52d2			; v1 player pos 
52d2			; v2 left wall 
52d2			; v3 right wall 
52d2			 
52d2			; Draw side walls randomly 
52d2			 
52d2 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5300			 
5300			; Draw player 
5300 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
531e			 
531e			; TODO Get Key 
531e			 
531e			; TODO Move left right 
531e			 
531e			; scroll and move walls a bit 
531e			 
531e .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
534f			 
534f			; main game loop 
534f			 
534f .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
537b .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
53ba			 
53ba			; key board defs 
53ba			 
53ba .. 00		keyup:       db ": keyup $05 ;",0 
53c8 .. 00		keydown:       db ": keydown $0a ;",0 
53d8 .. 00		keyleft:       db ": keyleft $0b ;",0 
53e8 .. 00		keyright:       db ": keyright $0c ;",0 
53f9 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5407 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5415 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5423 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5431 .. 00		keyf5:       db ": keyf5 $14 ;",0 
543f .. 00		keyf6:       db ": keyf6 $15 ;",0 
544d .. 00		keyf7:       db ": keyf7 $16 ;",0 
545b .. 00		keyf8:       db ": keyf8 $17 ;",0 
5469 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5477 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5486 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5495 .. 00		keyf12:       db ": keyf12 $1b ;",0 
54a4			 
54a4 .. 00		keytab:       db ": keytab $09 ;",0 
54b3 .. 00		keycr:       db ": keycr $0d ;",0 
54c1 .. 00		keyhome:       db ": keyhome $0e ;",0 
54d1 .. 00		keyend:       db ": keyend $0f ;",0 
54e0 .. 00		keybs:       db ": keybs $08 ;",0 
54ee			 
54ee			   
54ee			 
54ee			 
54ee			 
54ee			; eof 
# End of file forth_autostart.asm
54ee			 
54ee .. 00		sprompt1: db "Startup load...",0 
54fe .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5514			 
5514			 
5514			 
5514			 
5514			forth_startup: 
5514 21 4c 46			ld hl, startcmds 
5517 3e 00			ld a, 0 
5519 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
551c			 
551c e5			.start1:	push hl 
551d cd 99 09			call clear_display 
5520 11 ee 54			ld de, sprompt1 
5523 3e 00		        ld a, display_row_1 
5525 cd ac 09			call str_at_display 
5528 11 fe 54			ld de, sprompt2 
552b 3e 28		        ld a, display_row_2 
552d cd ac 09			call str_at_display 
5530 e1				pop hl 
5531 e5				push hl 
5532 5e				ld e,(hl) 
5533 23				inc hl 
5534 56				ld d,(hl) 
5535 3e 50		        ld a, display_row_3 
5537 cd ac 09			call str_at_display 
553a cd bc 09			call update_display 
553d			 
553d			 
553d 3a 86 e7			ld a, (os_last_cmd) 
5540 fe 00			cp 0 
5542 28 05			jr z, .startprompt 
5544 cd 02 09			call delay250ms 
5547 18 24			jr .startdo 
5549				 
5549				 
5549			 
5549			.startprompt: 
5549			 
5549 3e 9f			ld a,display_row_4 + display_cols - 1 
554b 11 3c 19		        ld de, endprg 
554e cd ac 09			call str_at_display 
5551 cd bc 09			call update_display 
5554 cd 0e 09			call delay1s 
5557 cd c6 58			call cin_wait 
555a						 
555a fe 2a			cp '*' 
555c 28 5e			jr z, .startupend1 
555e fe 23			cp '#' 
5560 20 07			jr nz, .startno 
5562 3e 01			ld a, 1 
5564 32 86 e7			ld (os_last_cmd),a 
5567 18 04			jr .startdo 
5569 fe 31		.startno:	cp '1' 
556b 28 3a			jr z,.startnxt  
556d			 
556d				; exec startup line 
556d			.startdo:	 
556d e1				pop hl 
556e e5				push hl 
556f				 
556f 5e				ld e,(hl) 
5570 23				inc hl 
5571 56				ld d,(hl) 
5572 eb				ex de,hl 
5573			 
5573 e5				push hl 
5574			 
5574 3e 00			ld a, 0 
5576				;ld a, FORTH_END_BUFFER 
5576 cd 2f 10			call strlent 
5579 23				inc hl   ; include zero term to copy 
557a 06 00			ld b,0 
557c 4d				ld c,l 
557d e1				pop hl 
557e 11 60 e3			ld de, scratch 
5581 ed b0			ldir 
5583			 
5583			 
5583 21 60 e3			ld hl, scratch 
5586 cd 7d 1d			call forthparse 
5589 cd bd 1d			call forthexec 
558c cd d4 1c			call forthexec_cleanup 
558f			 
558f 3e 78			ld a, display_row_4 
5591 11 e0 16			ld de, endprog 
5594			 
5594 cd bc 09			call update_display		 
5597			 
5597 3a 86 e7			ld a, (os_last_cmd) 
559a fe 00			cp 0 
559c 20 09			jr nz, .startnxt 
559e cd 3e 19			call next_page_prompt 
55a1 cd 99 09		        call clear_display 
55a4 cd bc 09			call update_display		 
55a7			 
55a7				; move onto next startup line? 
55a7			.startnxt: 
55a7			 
55a7 cd 02 09			call delay250ms 
55aa e1				pop hl 
55ab			 
55ab 23				inc hl 
55ac 23				inc hl 
55ad			 
55ad e5				push hl 
55ae 5e				ld e, (hl) 
55af 23				inc hl 
55b0 56				ld d, (hl) 
55b1 e1				pop hl 
55b2				; TODO replace 0 test 
55b2			 
55b2 eb				ex de, hl 
55b3 cd ef 0b			call ishlzero 
55b6			;	ld a,e 
55b6			;	add d 
55b6			;	cp 0    ; any left to do? 
55b6 eb				ex de, hl 
55b7 c2 1c 55			jp nz, .start1 
55ba 18 01			jr .startupend 
55bc			 
55bc e1			.startupend1: pop hl 
55bd			.startupend: 
55bd			 
55bd cd 99 09			call clear_display 
55c0 cd bc 09			call update_display 
55c3 c9				ret 
55c4			 
55c4			 
55c4			; stack over and underflow checks 
55c4			 
55c4			; init the words to detect the under/overflow 
55c4			 
55c4			chk_stk_init: 
55c4				; a vague random number to check so we dont get any "lucky" hits 
55c4 3e 2d			ld a, 45 
55c6 6f				ld l, a 
55c7 00				nop 
55c8 3e 17			ld a, 23 
55ca 67				ld h, a 
55cb			 
55cb 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
55ce			 
55ce			;	ld (chk_stund), hl	; stack points.... 
55ce 22 00 ef			ld (chk_stovr), hl 
55d1 22 0b eb			ld (chk_ret_und), hl 
55d4 22 c9 ea			ld (chk_ret_ovr), hl 
55d7 22 c7 e9			ld (chk_loop_ovr), hl 
55da 22 c5 e8			ld (chk_data_ovr), hl 
55dd c9				ret 
55de				 
55de			check_stacks: 
55de				; check all stack words 
55de			 
55de e5				push hl 
55df d5				push de 
55e0			 
55e0			;	ld de,(chk_word) 
55e0			;	ld hl, (chk_stund)	; stack points.... 
55e0			;	if DEBUG_STK_FAULT 
55e0			;		DMARK "FAa" 
55e0			;		CALLMONITOR 
55e0			;	endif 
55e0			;	call cmp16 
55e0			;	jp z, .chk_faulta 
55e0			; 
55e0			;	ld de, sfaultsu 
55e0			;	jp .chk_fault 
55e0			 
55e0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
55e3 ed 5b 47 e3		ld de,(chk_word) 
55e7				if DEBUG_STK_FAULT 
55e7					DMARK "FAb" 
55e7					CALLMONITOR 
55e7				endif 
55e7 cd e4 0b			call cmp16 
55ea 28 06			jr z, .chk_fault1 
55ec 11 8d 56			ld de, sfaultso 
55ef c3 41 56			jp .chk_fault 
55f2			.chk_fault1:  
55f2 2a 0b eb			ld hl, (chk_ret_und) 
55f5 ed 5b 47 e3		ld de,(chk_word) 
55f9				if DEBUG_STK_FAULT 
55f9					DMARK "FAU" 
55f9					CALLMONITOR 
55f9				endif 
55f9 cd e4 0b			call cmp16 
55fc ca 05 56			jp z, .chk_fault2 
55ff 11 9d 56			ld de, sfaultru 
5602 c3 41 56			jp .chk_fault 
5605			.chk_fault2:  
5605 2a c9 ea			ld hl, (chk_ret_ovr) 
5608 ed 5b 47 e3		ld de,(chk_word) 
560c				if DEBUG_STK_FAULT 
560c					DMARK "FA1" 
560c					CALLMONITOR 
560c				endif 
560c cd e4 0b			call cmp16 
560f ca 18 56			jp z, .chk_fault3 
5612 11 ab 56			ld de, sfaultro 
5615 c3 41 56			jp .chk_fault 
5618			.chk_fault3:  
5618 2a c7 e9			ld hl, (chk_loop_ovr) 
561b ed 5b 47 e3		ld de,(chk_word) 
561f				if DEBUG_STK_FAULT 
561f					DMARK "FA2" 
561f					CALLMONITOR 
561f				endif 
561f cd e4 0b			call cmp16 
5622 ca 2b 56			jp z, .chk_fault4 
5625 11 c5 56			ld de, sfaultlo 
5628 c3 41 56			jp .chk_fault 
562b			.chk_fault4:  
562b 2a c5 e8			ld hl, (chk_data_ovr) 
562e ed 5b 47 e3		ld de,(chk_word) 
5632				if DEBUG_STK_FAULT 
5632					DMARK "FA3" 
5632					CALLMONITOR 
5632				endif 
5632 cd e4 0b			call cmp16 
5635 ca 3e 56			jp z, .chk_fault5 
5638 11 df 56			ld de, sfaultdo 
563b c3 41 56			jp .chk_fault 
563e			 
563e			 
563e			.chk_fault5:  
563e d1				pop de 
563f e1				pop hl 
5640			 
5640 c9				ret 
5641			 
5641 cd 99 09		.chk_fault: 	call clear_display 
5644 3e 28				ld a, display_row_2 
5646 cd ac 09				call str_at_display 
5649 11 6f 56				   ld de, .stackfault 
564c 3e 00				ld a, display_row_1 
564e cd ac 09				call str_at_display 
5651 11 7a ee				    ld de, debug_mark 
5654 3e 11				ld a, display_row_1+17 
5656 cd ac 09				call str_at_display 
5659 cd bc 09				call update_display 
565c			 
565c				; prompt before entering montior for investigating issue 
565c			 
565c 3e 78			ld a, display_row_4 
565e 11 e0 16			ld de, endprog 
5661			 
5661 cd bc 09			call update_display		 
5664			 
5664 cd 3e 19			call next_page_prompt 
5667			 
5667 d1				pop de 
5668 e1				pop hl 
5669 cd 34 17				call monitor 
566c c3 2e 16				jp warmstart 
566f					;jp 0 
566f					;halt 
566f			 
566f			 
566f			 
566f .. 00		.stackfault: 	db "Stack fault:",0 
567c			 
567c .. 00		sfaultsu: 	db	"Stack under flow",0 
568d .. 00		sfaultso: 	db	"Stack over flow",0 
569d .. 00		sfaultru:	db "RTS underflow",0 
56ab .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
56c5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
56df .. 00		sfaultdo:	db "DTS overflow", 0 
56ec			 
56ec			 
56ec			fault_dsp_under: 
56ec 11 fe 56			ld de, .dsp_under 
56ef c3 ae 57			jp .show_fault 
56f2			 
56f2			fault_rsp_under: 
56f2 11 0c 57			ld de, .rsp_under 
56f5 c3 ae 57			jp .show_fault 
56f8			fault_loop_under: 
56f8 11 1a 57			ld de, .loop_under 
56fb c3 ae 57			jp .show_fault 
56fe			 
56fe .. 00		.dsp_under: db "DSP Underflow",0 
570c .. 00		.rsp_under: db "RSP Underflow",0 
571a .. 00		.loop_under: db "LOOP Underflow",0 
5729			 
5729			 
5729 d5			type_faultn: 	push de 
572a e5					push hl 
572b cd 99 09				call clear_display 
572e 11 55 57				   ld de, .typefaultn 
5731 3e 00				ld a, display_row_1 
5733 cd ac 09				call str_at_display 
5736 11 7a ee				    ld de, debug_mark 
5739 3e 11				ld a, display_row_1+17 
573b cd ac 09				call str_at_display 
573e cd bc 09				call update_display 
5741			 
5741				; prompt before entering montior for investigating issue 
5741			 
5741 3e 78			ld a, display_row_4 
5743 11 e0 16			ld de, endprog 
5746			 
5746 cd bc 09			call update_display		 
5749			 
5749 cd 3e 19			call next_page_prompt 
574c			 
574c e5					push hl 
574d d5					push de 
574e cd 34 17				call monitor 
5751 c3 2e 16				jp warmstart 
5754 76					halt 
5755			 
5755			 
5755 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
576c			 
576c d5			type_faults: 	push de 
576d e5					push hl 
576e cd 99 09				call clear_display 
5771 11 97 57				   ld de, .typefaults 
5774 3e 00				ld a, display_row_1 
5776 cd ac 09				call str_at_display 
5779 11 7a ee				    ld de, debug_mark 
577c 3e 11				ld a, display_row_1+17 
577e cd ac 09				call str_at_display 
5781 cd bc 09				call update_display 
5784			 
5784				; prompt before entering montior for investigating issue 
5784			 
5784 3e 78			ld a, display_row_4 
5786 11 e0 16			ld de, endprog 
5789			 
5789 cd bc 09			call update_display		 
578c			 
578c cd 3e 19			call next_page_prompt 
578f			 
578f e1					pop hl 
5790 d1					pop de 
5791 cd 34 17				call monitor 
5794 c3 2e 16				jp warmstart 
5797			 
5797			 
5797 .. 00		.typefaults: db "STR Type Expected TOS!",0 
57ae			 
57ae			.show_fault: 	 
57ae d5					push de 
57af cd 99 09				call clear_display 
57b2 d1					pop de 
57b3 3e 00				ld a, display_row_1 
57b5 cd ac 09				call str_at_display 
57b8 11 7a ee				    ld de, debug_mark 
57bb 3e 11				ld a, display_row_1+17 
57bd cd ac 09				call str_at_display 
57c0 cd bc 09				call update_display 
57c3			 
57c3				; prompt before entering montior for investigating issue 
57c3			 
57c3 3e 78			ld a, display_row_4 
57c5 11 e0 16			ld de, endprog 
57c8			 
57c8 cd bc 09			call update_display		 
57cb			 
57cb cd 3e 19			call next_page_prompt 
57ce			 
57ce e1					pop hl 
57cf d1					pop de 
57d0 cd 34 17				call monitor 
57d3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
57d3			; TODO Make optional fault restart to cli or warm boot? 
57d3					;jp warmstart 
57d3 c3 86 16				jp cli 
57d6 76					halt 
57d7			 
57d7			; handle the auto run of code from files in storage 
57d7			 
57d7			 
57d7			if STORAGE_SE 
57d7			 
57d7			sprompt3: db "Loading from start-up file?:",0 
57d7			sprompt4: db "(Y=Any key/N=No)",0 
57d7			 
57d7			 
57d7			forth_autoload: 
57d7			 
57d7				; load block 0 of store 1 
57d7				 
57d7				ld a, $fe      ; bit 0 clear 
57d7				ld (spi_device), a 
57d7			 
57d7				call storage_get_block_0 
57d7			 
57d7				ld a, (store_page+STORE_0_AUTOFILE) 
57d7			 
57d7				cp 0 
57d7				ret z     ; auto start not enabled 
57d7			 
57d7				call clear_display 
57d7			 
57d7				; set bank 
57d7			 
57d7					ld a, (store_page+STORE_0_BANKRUN) 
57d7					ld (spi_device), a 
57d7			 
57d7				; get file id to load from and get the file name to display 
57d7			 
57d7					ld a, (store_page+STORE_0_FILERUN) 
57d7			 
57d7					ld l, 0 
57d7					ld h, a 
57d7					ld de, store_page 
57d7			 
57d7					if DEBUG_FORTH_WORDS 
57d7						DMARK "ASp" 
57d7						CALLMONITOR 
57d7					endif 
57d7					call storage_read 
57d7			 
57d7					if DEBUG_FORTH_WORDS 
57d7						DMARK "ASr" 
57d7						CALLMONITOR 
57d7					endif 
57d7			 
57d7					call ishlzero 
57d7					ret z             ; file not found 
57d7			 
57d7					ld a, display_row_2 + 10 
57d7					ld de, store_page+3 
57d7					call str_at_display 
57d7				 
57d7			; 
57d7			 
57d7				ld a, display_row_1+5 
57d7				ld de, sprompt3 
57d7				call str_at_display 
57d7				ld a, display_row_3+15 
57d7				ld de, sprompt4 
57d7				call str_at_display 
57d7			 
57d7				call update_display 
57d7			 
57d7				call cin_wait 
57d7				cp 'n' 
57d7				ret z 
57d7				cp 'N' 
57d7				ret z 
57d7			 
57d7				call delay1s 
57d7			 
57d7				ld a, (store_page+2) 
57d7				ld (store_openmaxext), a    ; save count of ext 
57d7				ld a, 1  
57d7				ld (store_openext), a    ; save count of ext 
57d7			 
57d7			.autof:  
57d7				ld l , a 
57d7				 
57d7				ld a, (store_page) 
57d7				ld h, a	 
57d7				ld de, store_page 
57d7					if DEBUG_FORTH_WORDS 
57d7						DMARK "ASl" 
57d7						CALLMONITOR 
57d7					endif 
57d7					call storage_read 
57d7				call ishlzero 
57d7				ret z 
57d7			;	jr z, .autoend 
57d7			 
57d7					if DEBUG_FORTH_WORDS 
57d7						DMARK "ASc" 
57d7						CALLMONITOR 
57d7					endif 
57d7				ld de, store_page+2 
57d7				ld a, display_row_4 
57d7				call str_at_display 
57d7			 
57d7				call update_display 
57d7				call delay250ms 
57d7			 
57d7			 
57d7			 
57d7				ld hl, store_page+2 
57d7				call forthparse 
57d7				call forthexec 
57d7				call forthexec_cleanup 
57d7			 
57d7				 
57d7				ld a, (store_openext) 
57d7				inc a 
57d7				ld (store_openext), a    ; save count of ext 
57d7			 
57d7				jr .autof 
57d7			;.autofdone: 
57d7			; 
57d7			;		if DEBUG_FORTH_WORDS 
57d7			;			DMARK "ASx" 
57d7			;			CALLMONITOR 
57d7			;		endif 
57d7			;;	call clear_display 
57d7			;	ret 
57d7			 
57d7			 
57d7			 
57d7			endif 
57d7			 
57d7			 
57d7			; eof 
# End of file forth_kernel.asm
57d7			;include "nascombasic.asm" 
57d7			 
57d7			 
57d7			; find out where the code ends if loaded into RAM (for SC114) 
57d7			;endofcode:  
57d7			;	nop 
57d7			 
57d7			 
57d7			; eof 
57d7			 
# End of file main.asm
57d7			;include "firmware_lcd_4x40.asm" 
57d7			;;include "firmware_lcd_4x20.asm" 
57d7			include "firmware_cpm_display.asm" 
57d7			 
57d7			; Serial display interface for SC114 
57d7			 
57d7			 
57d7			display_row_1: equ 0 
57d7			display_row_2: equ display_row_1+display_cols 
57d7			display_row_3: equ display_row_2 + display_cols 
57d7			display_row_4: equ display_row_3 + display_cols 
57d7			 
57d7			kLCDWidth:  EQU display_cols             ;Width in characters 
57d7			kLCD_Line1: EQU 0x00  
57d7			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
57d7			; E1 
57d7			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
57d7			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
57d7			 
57d7			lcd_init: 
57d7				; no init as handled by the SCM bios 
57d7 c9				ret 
57d8			 
57d8			 
57d8			; low level functions for direct screen writes 
57d8			 
57d8			; output char at pos? 
57d8			fLCD_Str: 
57d8			        ;out (SC114_SIO_1_OUT),a 
57d8 c5				push bc 
57d9 d5				push de 
57da 5f				ld e, a 
57db			; TODO Replace with CP/M BIOS call 
57db 0e 02			ld c, $02 
57dd cd 05 00			call 5 
57e0 d1				pop de 
57e1 c1				pop bc 
57e2 c9				ret 
57e3			 
57e3			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
57e3			fLCD_Pos: 
57e3				; use ASCII escape to position 
57e3			        ;out (SC114_SIO_1_OUT),a 
57e3 c5				push bc 
57e4 d5				push de 
57e5 5f				ld e, a 
57e6 0e 02			ld c, $02 
57e8			; TODO Replace with CP/M BIOS call 
57e8 cd 05 00			call 5 
57eb d1				pop de 
57ec c1				pop bc 
57ed			 
57ed c9				ret 
57ee			 
57ee			; output char at pos 
57ee			fLCD_Data: 
57ee			      ;  out (SC114_SIO_1_OUT),a 
57ee c5				push bc 
57ef d5				push de 
57f0 0e 02			ld c, $02 
57f2 5f				ld e, a 
57f3			; TODO Replace with CP/M BIOS call 
57f3 cd 05 00			call 5 
57f6 d1				pop de 
57f7 c1				pop bc 
57f8			 
57f8 c9				ret 
57f9			 
57f9			; ascii cls  
57f9			 
57f9 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
57fd			 
57fd 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5814			;.clscpm: db 3, $3c,"$" 
5814			 
5814			; write the frame buffer given in hl to hardware  
5814			write_display: 
5814			 
5814			API: equ 0 
5814			 
5814			if API 
5814				push bc 
5814				ld b, 4 
5814			 
5814			        ld (display_write_tmp), hl 	  
5814			 
5814				; clear and home cursor 
5814			 
5814				ld c, 9 
5814				ld de, .cls 
5814			; TODO Replace with CP/M BIOS call 
5814				call 5 
5814			 
5814			 
5814			.writeln: 
5814			 
5814				ld de, (display_write_tmp) 
5814				ld c, 6 
5814			; TODO Replace with CP/M BIOS call 
5814				rst $30 
5814				ld c, 7 
5814				rst $30 
5814			 
5814				ld hl, (display_write_tmp) 
5814				ld de, display_cols 
5814				add hl,de 
5814				ld (display_write_tmp),hl 
5814			 
5814				djnz  .writeln 
5814			 
5814				pop bc 
5814			 
5814			 
5814				ret 
5814			endif 
5814 e5				push hl 
5815 c5				push bc 
5816 d5				push de 
5817			 
5817			;	ld c, 2 
5817			;	;ld de, .cls 
5817			;	ld a, 27 
5817			;	rst $30 
5817			;	ld c, 2 
5817			;	;ld de, .cls 
5817			;	ld a, '[' 
5817			;	rst $30 
5817			; 
5817			;	ld c, 2 
5817			;	;ld de, .cls 
5817			;	ld a, 'H' 
5817			;	rst $30 
5817			; 
5817			 
5817			 
5817			; lots of CR/LF 
5817			;	ld c, 9 
5817			;	ld de, .clscpm 
5817			;	call 5 
5817			 
5817			; xterm cls 
5817 0e 02			ld c, 2 
5819 1e 1b			ld e, 27 
581b cd 05 00			call 5 
581e			; cls causes too much flicker 
581e			;	ld c, 2 
581e			;	ld e, 'c' 
581e			;	call 5 
581e			 
581e			; use xterm home instead 
581e 0e 02			ld c, 2 
5820 1e 5b			ld e, '[' 
5822 cd 05 00			call 5 
5825 0e 02			ld c, 2 
5827 1e 48			ld e, 'H' 
5829 cd 05 00			call 5 
582c			LLL: equ 0 
582c			 
582c			if LLL 
582c			 
582c				ld c, 2 
582c				;ld de, .cls 
582c				ld e, 27 
582c			; TODO Replace with CP/M BIOS call 
582c				call 5 
582c			 
582c			 
582c				ld c, 2 
582c				;ld de, .cls 
582c				ld e, '[' 
582c			; TODO Replace with CP/M BIOS call 
582c				call 5 
582c				ld c, 2 
582c				;ld de, .cls 
582c				ld e, '2' 
582c			; TODO Replace with CP/M BIOS call 
582c				call 5 
582c				ld c, 2 
582c				;ld de, .cls 
582c				ld e, 'J' 
582c			; TODO Replace with CP/M BIOS call 
582c				call 5 
582c			 
582c			endif 
582c			 
582c d1				pop de 
582d c1				pop bc 
582e e1				pop hl 
582f			 
582f			 
582f 22 d8 eb		        ld (display_write_tmp), hl 	  
5832 3e 00			ld a, kLCD_Line1 
5834			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5834 06 28			ld b, display_cols 
5836 ed 5b d8 eb		ld de, (display_write_tmp) 
583a cd bd 58			call write_len_string 
583d				 
583d			 
583d e5			push hl 
583e d5			push de 
583f c5			push bc 
5840 0e 02			ld c, 2 
5842 1e 0a			ld e, 10 
5844 cd 05 00			call 5 
5847 0e 02			ld c, 2 
5849 1e 0d			ld e, 13 
584b cd 05 00			call 5 
584e			; TODO Replace with CP/M BIOS call 
584e				;rst $30 
584e c1			pop bc 
584f d1			pop de 
5850 e1			pop hl 
5851			 
5851				 
5851 2a d8 eb			ld hl, (display_write_tmp) 
5854 11 28 00			ld de, display_cols 
5857 19				add hl,de 
5858 22 d8 eb			ld (display_write_tmp),hl 
585b			 
585b				 
585b 3e 28			ld a, kLCD_Line2 
585d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
585d 06 28			ld b, display_cols 
585f ed 5b d8 eb		ld de, (display_write_tmp) 
5863 cd bd 58			call write_len_string 
5866				 
5866 2a d8 eb			ld hl, (display_write_tmp) 
5869 11 28 00			ld de, display_cols 
586c 19				add hl,de 
586d 22 d8 eb			ld (display_write_tmp),hl 
5870			 
5870 e5			push hl 
5871 d5			push de 
5872 c5			push bc 
5873 0e 07			ld c, 7 
5875			; TODO Replace with CP/M BIOS call 
5875				;rst $30 
5875 0e 02			ld c, 2 
5877 1e 0a			ld e, 10 
5879 cd 05 00			call 5 
587c 0e 02			ld c, 2 
587e 1e 0d			ld e, 13 
5880 cd 05 00			call 5 
5883 c1			pop bc 
5884 d1			pop de 
5885 e1			pop hl 
5886			 
5886				 
5886 3e 50			ld a, kLCD_Line3 
5888			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5888 06 28			ld b, display_cols 
588a ed 5b d8 eb		ld de, (display_write_tmp) 
588e cd bd 58			call write_len_string 
5891				 
5891 2a d8 eb			ld hl, (display_write_tmp) 
5894 11 28 00			ld de, display_cols 
5897 19				add hl,de 
5898 22 d8 eb			ld (display_write_tmp),hl 
589b			 
589b e5			push hl 
589c d5			push de 
589d c5			push bc 
589e 0e 07			ld c, 7 
58a0			; TODO Replace with CP/M BIOS call 
58a0				;rst $30 
58a0 0e 02			ld c, 2 
58a2 1e 0a			ld e, 10 
58a4 cd 05 00			call 5 
58a7 0e 02			ld c, 2 
58a9 1e 0d			ld e, 13 
58ab cd 05 00			call 5 
58ae c1			pop bc 
58af d1			pop de 
58b0 e1			pop hl 
58b1			 
58b1				 
58b1 3e 78			ld a, kLCD_Line4 
58b3			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
58b3 06 28			ld b, display_cols 
58b5 ed 5b d8 eb		ld de, (display_write_tmp) 
58b9 cd bd 58			call write_len_string 
58bc c9					ret 
58bd			 
58bd			 
58bd				; write out a fixed length string given in b from de 
58bd			 
58bd 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
58be cd ee 57		            CALL fLCD_Data      ;Write character to display 
58c1 13				inc de 
58c2 10 f9			djnz write_len_string 
58c4 c9				ret 
58c5			 
58c5			 
58c5			; eof 
# End of file firmware_cpm_display.asm
58c5			;include "firmware_key_5x10.asm" 
58c5			;;include "firmware_key_4x10.asm" 
58c5			include "firmware_key_cpm.asm" 
58c5			; Serial keyboard interface for SC114 
58c5			 
58c5			 
58c5			key_init: 
58c5				; no init as handled by the SCM bios 
58c5 c9				ret 
58c6			 
58c6			 
58c6			cin_wait: 
58c6			;	ld a, 0 
58c6			;	ret 
58c6			 
58c6				;in a,(SC114_SIO_1_IN) 
58c6			        ; Use SCM API to get from whatever console device we are using 
58c6			 
58c6			; TODO Replace with CP/M BIOS call 
58c6 c5				push bc 
58c7 0e 01			ld c, $01 
58c9 cd 05 00			call 5 
58cc c1				pop bc 
58cd c9				ret 
58ce			 
58ce			cin: 
58ce			 
58ce			 
58ce c5				push bc 
58cf			 
58cf				; any key waiting to process? 
58cf			; TODO Replace with CP/M BIOS call 
58cf 0e 06			ld c, $06 
58d1 cd 05 00			call 5 
58d4 28 0d			jr z, .cin_skip 
58d6			 
58d6				; yep, get it 
58d6			 
58d6 0e 01			ld c, $01 
58d8			; TODO Replace with CP/M BIOS call 
58d8 cd 05 00			call 5 
58db			 
58db fe 7f			cp $7f     ; back space 
58dd 20 02			jr nz, .skipbs 
58df 3e 08			ld a, KEY_BS 
58e1			.skipbs: 
58e1			 
58e1 c1				pop bc 
58e2 c9				ret 
58e3			.cin_skip: 
58e3 3e 00			ld a, 0 
58e5 c1				pop bc 
58e6 c9				ret 
58e7			 
58e7			 
58e7			 
58e7			 
# End of file firmware_key_cpm.asm
58e7			endofcode:  
58e7			baseram:  
58e7 00				nop 
58e8			 
58e8			heap_start: equ baseram+15  ; Starting address of heap 
58e8			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
58e8			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
58e8			;VDU:  EQU     endofcode           ; BASIC Work space 
58e8			; eof 
58e8			 
# End of file os_mega_cpm.asm
58e8
