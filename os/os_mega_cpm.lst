# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 8b 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd d0 63				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd be 64			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 be 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 d3 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 79 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd e8 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 80 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd e8 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 80 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd e8 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 79 ea				ld hl, (store_tmp1) 
0210 11 83 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd e8 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd e8 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd e8 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd e8 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd e8 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 80 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 82 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd e8 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd e8 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 80 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 80 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd e8 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 81 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd e8 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd e8 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 80 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 81 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 83 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 8c ea			ld hl, store_page+3+9 
03b5 3a 65 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 80 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd e8 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd e8 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd e8 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 83 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd e8 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 80 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd e8 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd e8 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 80 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd e8 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 80 ea			ld a, (store_page)	; get file id 
0510 32 74 ea			ld (store_tmpid), a 
0513			 
0513 3a 82 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 73 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 80 ea			ld (store_page), a 
051f 32 81 ea			ld (store_page+1),a 
0522 11 80 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd e8 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 73 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 74 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd e8 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 80 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 80 ea			ld (store_page), a 
0582 32 81 ea			ld (store_page+1),a 
0585 11 80 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd e8 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd e8 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd e8 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd e8 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd e8 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 80 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 80 ea			ld (store_page),a 
06a3				 
06a3 32 74 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 80 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd e8 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 80 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd e8 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 6b ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd e8 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 6b ea			ld (store_tmppageid), hl 
0715				 
0715 3a 74 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 80 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 81 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 82 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 83 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd e8 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd e8 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd e8 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 6b ea			ld hl,(store_tmppageid) 
078b 11 80 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd e8 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 74 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd e8 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 7e ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 7c ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd e8 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd e8 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 71 ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 7c ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 71 ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 72 ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 73 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd e8 15			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 73 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 71 ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 72 ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 73 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd e8 15			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 7b ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 71 ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 72 ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 73 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd e8 15			call break_point_state  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 7c ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 7e ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 7e ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 71 ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 72 ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 73 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd e8 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 71 ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 72 ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 73 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd e8 15			call break_point_state  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 71 ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 7c ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 7c ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 71 ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 72 ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 73 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd e8 15			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 71 ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 72 ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 73 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd e8 15			call break_point_state  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 71 ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 72 ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 73 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd e8 15			call break_point_state  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 71 ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 72 ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 73 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd e8 15			call break_point_state  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 74 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 74 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 6b ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 71 ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 72 ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 73 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd e8 15			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 80 ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 71 ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 72 ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 73 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd e8 15			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 82 ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 82 ea			ld (store_page+2), a 
09e3 32 73 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 71 ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 72 ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 73 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd e8 15			call break_point_state  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 6b ea			ld hl, (store_tmppageid) 
0a05 11 80 ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 6b ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 71 ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 72 ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 73 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd e8 15			call break_point_state  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 80 ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 74 ea				ld a, (store_tmpid) 
0a4b 32 80 ea				ld (store_page), a   ; file id 
0a4e 3a 73 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 81 ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 82 ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 71 ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 72 ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 73 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd e8 15			call break_point_state  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 6b ea			ld hl, (store_tmppageid) 
0a85 11 80 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 71 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 72 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 73 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd e8 15			call break_point_state  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 74 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 80 ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 81 ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a cc eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 cc eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd b5 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 cd eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 cd eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a d2 eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b7 ed				ld hl, display_fb0 
0b53 22 d2 eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd fe 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 16 ed				ld hl, display_fb1 
0b74 22 d2 eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a d2 eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a d2 eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a d2 eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a d2 eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a d2 eb			ld hl, (display_fb_active) 
0be1 cd 0d 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 79 ea				ld (store_tmp1), hl 
0bee 32 77 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b7 ed				ld hl, display_fb0 
0bf4 22 d2 eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 75 ea				ld (store_tmp3), a   ; display row count 
0c02 3a 77 ea				ld a,( store_tmp2) 
0c05 32 78 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 78 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 79 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 75 ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 78 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 78 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 75 ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 75 ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 77 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd bf 64				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 77 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 77 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 77 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 77 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 77 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 16 ed				ld hl, display_fb1 
0cb1 22 d2 eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a b1 eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 b1 eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b7 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b9 eb		        ld hl,LFSRSeed+6 
0d04 11 ba eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a ab eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 ab eb		    ld (seed1),hl 
0d1a 2a a9 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a9 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a af eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 af eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 6c ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c7 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 66 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 65 ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 66 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 66 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 65 ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 65 ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 66 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 6f ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 6d ee			ld de, (input_start) 
0e69 3a 6a ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 65 ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 68 ee				ld a,(input_at_cursor) 
0e79 11 c7 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 6d ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 60 ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd c7 64				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 6d ee				ld hl, (input_start) 
0e98 3a 5b ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 6f ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 6a ee				ld a, (input_at_pos) 
0ea9 32 68 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 5b ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 6f ee				ld (input_ptr), hl 
0ed1 3a 68 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 68 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 6f ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 6f ee				ld (input_ptr), hl 
0ef0 3a 68 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 68 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 5b ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 5b ee				ld (input_cursor), a 
0f09			 
0f09 2a 6f ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 6f ee				ld (input_ptr), hl 
0f10					 
0f10 3a 68 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 68 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 65 ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 66 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 5b ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 5b ee				ld (input_cursor), a 
0f37			 
0f37 3a 68 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 68 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 6f ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 6f ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 65 ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 66 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 6d ee				ld hl, (input_start) 
0f59 22 6f ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 6a ee				ld a, (input_at_pos) 
0f5f 32 68 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 5b ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 ee e5				ld hl, os_cli_cmd 
0f6a 11 ed e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 5b ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 5b ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 6f ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 6f ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 68 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 68 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 65 ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 66 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 68 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 5b ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 68 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 68 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 6f ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 6f ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 6f ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 6f ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 65 ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 66 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 6d ee				ld hl, (input_start) 
0ffa 3a 60 ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 60 ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 5b ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 5b ee				ld (input_cursor), a 
1022			 
1022 3a 68 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 68 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 6d ee				ld hl, (input_start) 
102f 3a 60 ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1042 22 6d ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 6f ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 6c ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 5b ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 6f ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c7 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 6a ee				ld a,(input_at_pos) 
1063 cd dc 63		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 6d ee	            	LD   de, (input_start) 
106a cd d1 63		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd c7 64				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 6f ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c7 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 6f ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 6f ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 6f ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 6f ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 6f ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c7 e2			ld hl, scratch 
10bd 11 ed e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c7 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 6f ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 75 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 fb e2			ld (scratch+52),a 
11be				 
11be 21 f9 e2			ld hl,scratch+50 
11c1 22 ea e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 ef 64		      ld    HL, heap_start 
128e 22 ea 64		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 ec 64		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a9 e2		      ld    HL, heap_start+heap_size-4 
129a 22 ef 64		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 ba 7d		      ld    HL, heap_size-4 
12a0 22 f1 64		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 ab e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a9 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 ea 64		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 ea 64		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			if SOUND_ENABLE  
1447				include "firmware_sound.asm"  
1447			endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 77 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452 fe 01			cp 1 
1454 cc a5 14			call z, .savetostore 
1457			 
1457 fe 02			cp 2 
1459			if STARTUP_V1 
1459 cc 91 14			call z, .selautoload 
145c			endif 
145c			 
145c			if STARTUP_V2 
145c				call z, .enautoload 
145c			endif 
145c fe 03			cp 3 
145e cc 87 14			call z, .disautoload 
1461 fe 04			cp 4 
1463 cc 9b 14			call z, .selbank 
1466 fe 05			cp 5 
1468 cc af 14			call z, .debug_tog 
146b fe 06			cp 6 
146d cc f2 15			call z, .bpsgo 
1470 fe 07			cp 7 
1472 cc d5 14			call z, hardware_diags 
1475			if STARTUP_V2 
1475				cp 8 
1475				call z, create_startup 
1475			endif 
1475 18 d0			jr config 
1477			 
1477			.configmn: 
1477 e3 17			dw prom_c3 
1479 fa 17			dw prom_c2 
147b 0f 18			dw prom_c2a 
147d 25 18			dw prom_c2b 
147f			;	dw prom_c4 
147f 42 18			dw prom_m4 
1481 5d 18			dw prom_m4b 
1483 65 18			dw prom_c1 
1485			if STARTUP_V2 
1485				dw prom_c9 
1485			endif 
1485 00 00			dw 0 
1487				 
1487			 
1487			if STARTUP_V2 
1487			.enautoload: 
1487				if STORAGE_SE 
1487				ld a, $fe      ; bit 0 clear 
1487				ld (spi_device), a 
1487			 
1487				call storage_get_block_0 
1487			 
1487				ld a, 1 
1487				ld (store_page+STORE_0_AUTOFILE), a 
1487			 
1487					ld hl, 0 
1487					ld de, store_page 
1487				call storage_write_block	 ; save update 
1487				else 
1487			 
1487				ld hl, prom_notav 
1487				ld de, prom_empty 
1487				call info_panel 
1487				endif 
1487			 
1487			 
1487				ret 
1487			endif 
1487			 
1487			.disautoload: 
1487				if STORAGE_SE 
1487				ld a, $fe      ; bit 0 clear 
1487				ld (spi_device), a 
1487			 
1487				call storage_get_block_0 
1487			 
1487				ld a, 0 
1487				ld (store_page+STORE_0_AUTOFILE), a 
1487			 
1487					ld hl, 0 
1487					ld de, store_page 
1487				call storage_write_block	 ; save update 
1487				else 
1487			 
1487 21 74 18			ld hl, prom_notav 
148a 11 8a 18			ld de, prom_empty 
148d cd 4b 0b			call info_panel 
1490				endif 
1490			 
1490			 
1490 c9				ret 
1491			 
1491			if STARTUP_V1 
1491			 
1491			; Select auto start 
1491			 
1491			.selautoload: 
1491			 
1491				 
1491				if STORAGE_SE 
1491			 
1491					call config_dir 
1491				        ld hl, scratch 
1491					ld a, 0 
1491					call menu 
1491			 
1491					cp 0 
1491					ret z 
1491			 
1491					dec a 
1491			 
1491			 
1491					; locate menu option 
1491			 
1491					ld hl, scratch 
1491					call table_lookup 
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALl" 
1491						CALLMONITOR 
1491					endif 
1491					; with the pointer to the menu it, the byte following the zero term is the file id 
1491			 
1491					ld a, 0 
1491					ld bc, 50   ; max of bytes to look at 
1491					cpir  
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALb" 
1491						CALLMONITOR 
1491					endif 
1491					;inc hl 
1491			 
1491					ld a, (hl)   ; file id 
1491					 
1491				        ; save bank and file ids 
1491			 
1491					push af 
1491			 
1491			; TODO need to save to block 0 on bank 1	 
1491			 
1491					call storage_get_block_0 
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "AL0" 
1491						CALLMONITOR 
1491					endif 
1491					pop af 
1491			 
1491					ld (store_page+STORE_0_FILERUN),a 
1491					 
1491					; save bank id 
1491			 
1491					ld a,(spi_device) 
1491					ld (store_page+STORE_0_BANKRUN),a 
1491			 
1491					; enable auto run of store file 
1491			 
1491					ld a, 1 
1491					ld (store_page+STORE_0_AUTOFILE),a 
1491			 
1491					; save buffer 
1491			 
1491					ld hl, 0 
1491					ld de, store_page 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALw" 
1491						CALLMONITOR 
1491					endif 
1491				call storage_write_block	 ; save update 
1491			  
1491			 
1491			 
1491			 
1491					ld hl, scratch 
1491					call config_fdir 
1491			 
1491				else 
1491			 
1491 21 74 18			ld hl, prom_notav 
1494 11 8a 18			ld de, prom_empty 
1497 cd 4b 0b			call info_panel 
149a			 
149a				endif 
149a c9				ret 
149b			endif 
149b			 
149b			 
149b			; Select storage bank 
149b			 
149b			.selbank: 
149b			 
149b				if STORAGE_SE 
149b				else 
149b			 
149b 21 74 18			ld hl, prom_notav 
149e 11 8a 18			ld de, prom_empty 
14a1 cd 4b 0b			call info_panel 
14a4				endif 
14a4				 
14a4 c9				ret 
14a5			 
14a5			if STORAGE_SE 
14a5			 
14a5			.config_ldir:   
14a5				; Load storage bank labels into menu array 
14a5			 
14a5				 
14a5			 
14a5			 
14a5				ret 
14a5			 
14a5			 
14a5			endif 
14a5			 
14a5			 
14a5			; Save user words to storage 
14a5			 
14a5			.savetostore: 
14a5			 
14a5				if STORAGE_SE 
14a5			 
14a5					call config_dir 
14a5				        ld hl, scratch 
14a5					ld a, 0 
14a5					call menu 
14a5					 
14a5					ld hl, scratch 
14a5					call config_fdir 
14a5			 
14a5				else 
14a5			 
14a5 21 74 18			ld hl, prom_notav 
14a8 11 8a 18			ld de, prom_empty 
14ab cd 4b 0b			call info_panel 
14ae			 
14ae				endif 
14ae			 
14ae c9				ret 
14af			 
14af			if STARTUP_V2 
14af			 
14af			create_startup: 
14af			 
14af				ld a, 0 
14af				ld hl, .crstart 
14af				call menu 
14af			 
14af				cp 0 
14af				ret z 
14af			 
14af				cp 1 
14af				call z, .genlsword 
14af				cp 2 
14af				call z, .genedword 
14af			 
14af				cp 3 
14af				call z, .gendemword 
14af			 
14af				cp 4 
14af				call z, .genutlword 
14af				cp 5 
14af				call z, .genspiword 
14af				cp 6 
14af				call z, .genkeyword 
14af				jr create_startup 
14af			 
14af			.genlsword: 
14af				ld hl, crs_s1 
14af				ld de, .lsworddef 
14af				call .genfile 
14af				ret 
14af			 
14af			.genedword: 
14af				ld de, .edworddef 
14af				ld hl, crs_s2 
14af				call .genfile 
14af				ret 
14af			 
14af			.gendemword: 
14af				ld de, .demoworddef 
14af				ld hl, crs_s3 
14af				call .genfile 
14af				ret 
14af			 
14af			.genutlword: 
14af				ld hl, crs_s4 
14af				ld de, .utilwordef 
14af				call .genfile 
14af				ret 
14af			.genspiword: 
14af				ld hl, crs_s5 
14af				ld de, .spiworddef 
14af				call .genfile 
14af				ret 
14af			.genkeyword: 
14af				ld hl, crs_s6 
14af				ld de, .keyworddef 
14af				call .genfile 
14af				ret 
14af			 
14af			; hl - points to file name 
14af			; de - points to strings to add to file 
14af			 
14af			.genfile: 
14af				push hl 
14af				push de 
14af			 
14af				call clear_display 
14af				ld a, display_row_1 
14af				ld de, .genfiletxt 
14af				call str_at_display 
14af				call update_display 
14af			 
14af				pop de 
14af				pop hl 
14af			 
14af			 
14af				push de 
14af				call storage_create 
14af				; id in hl 
14af				pop de   ; table of strings to add 
14af			 
14af			.genloop: 
14af			 
14af				push hl ; save id for next time around 
14af				push de ; save de for next time around 
14af			 
14af				ex de, hl 
14af				call loadwordinhl 
14af				ex de, hl 
14af			 
14af				; need hl to be the id 
14af				; need de to be the string ptr 
14af				 
14af				call storage_append 
14af			 
14af				pop de 
14af				pop hl 
14af			 
14af				inc de 
14af				inc de 
14af			 
14af				ld a,(de) 
14af				cp 0 
14af				jr nz, .genloop 
14af				inc de 
14af				ld a, (de) 
14af				dec de 
14af				cp 0 
14af				jr nz, .genloop	 
14af			 
14af				ret 
14af			 
14af			.genfiletxt:  db "Creating file...",0 
14af			 
14af			.utilwordef: 
14af				dw strncpy 
14af				dw type 
14af				dw clrstack 
14af				dw longread 
14af				dw start1 
14af				dw start2 
14af				dw start3b 
14af				dw start3c 
14af				dw list 
14af				dw 0 
14af			 
14af			.lsworddef: 
14af				dw start3b 
14af				dw 0 
14af			 
14af			.edworddef: 
14af				dw edit1 
14af				dw edit2 
14af				dw edit3 
14af				dw 0 
14af			 
14af			.demoworddef: 
14af				dw test5 
14af				dw test6 
14af				dw test7 
14af				dw test8 
14af				dw test9 
14af				dw test10 
14af				dw game1 
14af				dw game1a 
14af				dw game1b 
14af				dw game1c 
14af				dw game1d 
14af				dw game1s 
14af				dw game1t 
14af				dw game1f 
14af				dw game1z 
14af				dw game1zz 
14af				dw ssv2 
14af				dw ssv3 
14af				dw ssv4 
14af				dw ssv5 
14af				dw ssv1 
14af				dw ssv1cpm	 
14af				dw game2b 
14af				dw game2bf 
14af				dw game2mba 
14af				dw game2mbas	 
14af				dw game2mbht 
14af				dw game2mbms 
14af				dw game2mb 
14af				dw game3w 
14af				dw game3p 
14af				dw game3sc 
14af				dw game3vsi 
14af				dw game3vs 
14af				dw 0 
14af			 
14af			 
14af			.spiworddef: 
14af			 
14af			    dw spi1 
14af			    dw spi2 
14af			    dw spi3 
14af			    dw spi4 
14af			    dw spi5 
14af			    dw spi6 
14af			    dw spi7 
14af			 
14af			    dw spi8 
14af			    dw spi9 
14af			    dw spi10 
14af			    dw 0 
14af			 
14af			.keyworddef: 
14af			 
14af				dw keyup 
14af				dw keydown 
14af				dw keyleft 
14af				dw keyright 
14af				dw 	keyf1 
14af				dw keyf2 
14af				dw keyf3 
14af				dw keyf4 
14af				dw keyf5 
14af				dw keyf6 
14af				dw keyf7 
14af				dw keyf8 
14af				dw keyf9 
14af				dw keyf10 
14af				dw keyf11 
14af				dw keyf12 
14af				dw keytab 
14af				dw keycr 
14af				dw keyhome 
14af				dw keyend 
14af				dw keybs 
14af				dw 0 
14af			 
14af			.crstart: 
14af				dw crs_s1 
14af				dw crs_s2 
14af				dw crs_s3 
14af				dw crs_s4 
14af				dw crs_s5 
14af				dw crs_s6 
14af				dw 0 
14af			 
14af			endif 
14af			 
14af			 
14af			if STORAGE_SE 
14af			 
14af			config_fdir: 
14af				; using the scratch dir go through and release the memory allocated for each string 
14af				 
14af				ld hl, scratch 
14af			.cfdir:	ld e,(hl) 
14af				inc hl 
14af				ld d,(hl) 
14af				inc hl 
14af			 
14af				ex de, hl 
14af				call ishlzero 
14af				ret z     ; return on null pointer 
14af				call free 
14af				ex de, hl 
14af				jr .cfdir 
14af			 
14af			 
14af				ret 
14af			 
14af			 
14af			config_dir: 
14af			 
14af				; for the config menus that need to build a directory of storage call this routine 
14af				; it will construct a menu in scratch to pass to menu 
14af			 
14af				; open storage device 
14af			 
14af				; execute DIR to build a list of files and their ids into scratch in menu format 
14af				; once the menu has finished then will need to call config_fdir to release the strings 
14af				 
14af				; c = number items 
14af			 
14af				 
14af				call storage_get_block_0 
14af			 
14af				ld hl, store_page     ; get current id count 
14af				ld b, (hl) 
14af				ld c, 0    ; count of files   
14af			 
14af			 
14af				ld hl, scratch 
14af				ld (store_tmp2), hl    ; location to poke strings 
14af			 
14af				; check for empty drive 
14af			 
14af				ld a, 0 
14af				cp b 
14af				jp z, .dirdone 
14af			 
14af				 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "Cdc" 
14af						CALLMONITOR 
14af					endif 
14af			 
14af			 
14af			.diritem:	 
14af				push bc 
14af				; for each of the current ids do a search for them and if found push to stack 
14af			 
14af					ld hl, STORE_BLOCK_PHY 
14af					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14af					ld e,b 
14af			 
14af					call storage_findnextid 
14af			 
14af			 
14af					; if found hl will be non zero 
14af			 
14af					call ishlzero 
14af					jr z, .dirnotfound 
14af			 
14af					; increase count 
14af			 
14af					pop bc	 
14af					inc c 
14af					push bc 
14af					 
14af			 
14af					; get file header and push the file name 
14af			 
14af					ld de, store_page 
14af					call storage_read_block 
14af			 
14af					; push file id to stack 
14af				 
14af					ld a, (store_page) 
14af					ld h, 0 
14af					ld l, a 
14af			 
14af					;call forth_push_numhl 
14af					; TODO store id 
14af			 
14af					push hl 
14af			 
14af					; push extent count to stack  
14af				 
14af					ld hl, store_page+3 
14af			 
14af					; get file name length 
14af			 
14af					call strlenz   
14af			 
14af					inc hl   ; cover zero term 
14af					inc hl  ; stick the id at the end of the area 
14af			 
14af					push hl 
14af					pop bc    ; move length to bc 
14af			 
14af					call malloc 
14af			 
14af					; TODO save malloc area to scratch 
14af			 
14af					ex de, hl 
14af					ld hl, (store_tmp2) 
14af					ld (hl), e 
14af					inc hl 
14af					ld (hl), d 
14af					inc hl 
14af					ld (store_tmp2), hl 
14af			 
14af					 
14af			 
14af					;pop hl   ; get source 
14af			;		ex de, hl    ; swap aronund	 
14af			 
14af					ld hl, store_page+3 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "CFd" 
14af						CALLMONITOR 
14af					endif 
14af					ldir 
14af			 
14af					; de is past string, move back one and store id 
14af					 
14af					dec de 
14af			 
14af					; store file id 
14af			 
14af					pop hl 
14af					ex de,hl 
14af					ld (hl), e 
14af			 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "Cdi" 
14af						CALLMONITOR 
14af					endif 
14af					 
14af			.dirnotfound: 
14af					pop bc     
14af					djnz .diritem 
14af				 
14af			.dirdone:	 
14af			 
14af					ld a, 0 
14af					ld hl, (store_tmp2) 
14af					ld (hl), a 
14af					inc hl 
14af					ld (hl), a 
14af					inc hl 
14af					; push a count of the dir items found 
14af			 
14af			;		ld h, 0 
14af			;		ld l, c 
14af			 
14af				ret 
14af			 
14af			endif 
14af			 
14af			 
14af			; Settings 
14af			; Run  
14af			 
14af			 
14af			 
14af			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14af			;;hd_menu2:   db "        2: Editor",0   
14af			;hd_menu2:   db "        2: Editor       6: Menu",0   
14af			;hd_menu3:   db "        3: Storage",0 
14af			;hd_menu4:   db "0=quit  4: Debug",0 
14af			;hd_don:     db "ON",0 
14af			;hd_doff:     db "OFF",0 
14af			; 
14af			; 
14af			; 
14af			;hardware_diags_old:       
14af			; 
14af			;.diagmenu: 
14af			;	call clear_display 
14af			;	ld a, display_row_1 
14af			;	ld de, hd_menu1 
14af			;	call str_at_display 
14af			; 
14af			;	ld a, display_row_2 
14af			;	ld de, hd_menu2 
14af			;	call str_at_display 
14af			; 
14af			;	ld a, display_row_3 
14af			;	ld de, hd_menu3 
14af			;	call str_at_display 
14af			; 
14af			;	ld a,  display_row_4 
14af			;	ld de, hd_menu4 
14af			;	call str_at_display 
14af			; 
14af			;	; display debug state 
14af			; 
14af			;	ld de, hd_don 
14af			;	ld a, (os_view_disable) 
14af			;	cp 0 
14af			;	jr z, .distog 
14af			;	ld de, hd_doff 
14af			;.distog: ld a, display_row_4+17 
14af			;	call str_at_display 
14af			; 
14af			;	call update_display 
14af			; 
14af			;	call cin_wait 
14af			; 
14af			; 
14af			; 
14af			;	cp '4' 
14af			;	jr nz, .diagn1 
14af			; 
14af			;	; debug toggle 
14af			; 
14af			;	ld a, (os_view_disable) 
14af			;	ld b, '*' 
14af			;	cp 0 
14af			;	jr z, .debtog 
14af			;	ld b, 0 
14af			;.debtog:	 
14af			;	ld a,b 
14af			;	ld (os_view_disable),a 
14af			; 
14af			;.diagn1: cp '0' 
14af			;	 ret z 
14af			; 
14af			;;	cp '1' 
14af			;;       jp z, matrix	 
14af			;;   TODO keyboard matrix test 
14af			; 
14af			;	cp '2' 
14af			;	jp z, .diagedit 
14af			; 
14af			;;	cp '6' 
14af			;;	jp z, .menutest 
14af			;;if ENABLE_BASIC 
14af			;;	cp '6' 
14af			;;	jp z, basic 
14af			;;endif 
14af			 ; 
14af			;	jp .diagmenu 
14af			; 
14af			; 
14af			;	ret 
14af			 
14af			 
14af			.debug_tog: 
14af 21 f6 14			ld hl, .menudebug 
14b2				 
14b2 3a b8 e2			ld a, (os_view_disable) 
14b5 fe 2a			cp '*' 
14b7 20 04			jr nz,.tdon  
14b9 3e 01			ld a, 1 
14bb 18 02			jr .tog1 
14bd 3e 00		.tdon: ld a, 0 
14bf			 
14bf			.tog1: 
14bf cd eb 0b			call menu 
14c2 fe 00			cp 0 
14c4 c8				ret z 
14c5 fe 01			cp 1    ; disable debug 
14c7 28 04			jr z, .dtog0 
14c9 3e 2a			ld a, '*' 
14cb 18 02			jr .dtogset 
14cd 3e 00		.dtog0: ld a, 0 
14cf 32 b8 e2		.dtogset:  ld (os_view_disable), a 
14d2 c3 af 14			jp .debug_tog 
14d5			 
14d5			 
14d5			hardware_diags:       
14d5			 
14d5			.diagm: 
14d5 21 e8 14			ld hl, .menuitems 
14d8 3e 00			ld a, 0 
14da cd eb 0b			call menu 
14dd			 
14dd fe 00		         cp 0 
14df c8				 ret z 
14e0			 
14e0 fe 02			cp 2 
14e2 ca 41 15			jp z, .diagedit 
14e5			 
14e5			;	cp '6' 
14e5			;	jp z, .menutest 
14e5			;if ENABLE_BASIC 
14e5			;	cp '6' 
14e5			;	jp z, basic 
14e5			;endif 
14e5			  
14e5 c3 d5 14			jp .diagm 
14e8			 
14e8				 
14e8 fc 14		.menuitems:   	dw .m1 
14ea 07 15				dw .m2 
14ec 0e 15				dw .m3 
14ee 16 15				dw .m5 
14f0 1c 15				dw .m5a 
14f2 25 15				dw .m5b 
14f4 00 00				dw 0 
14f6			 
14f6			.menudebug: 
14f6 2e 15				dw .m6 
14f8 37 15				dw .m7 
14fa 00 00				dw 0 
14fc			 
14fc .. 00		.m1:   db "Key Matrix",0 
1507 .. 00		.m2:   db "Editor",0 
150e .. 00		.m3:   db "Storage",0 
1516 .. 00		.m5:   db "Sound",0 
151c .. 00		.m5a:  db "RAM Test",0 
1525 .. 00		.m5b:  db "LCD Test",0 
152e			 
152e .. 00		.m6:   db "Debug ON",0 
1537 .. 00		.m7:   db "Debug OFF",0 
1541			 
1541			; debug editor 
1541			 
1541			.diagedit: 
1541			 
1541 21 c7 e2			ld hl, scratch 
1544			;	ld bc, 250 
1544			;	ldir 
1544				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1544 3e 00			ld a, 0 
1546 77				ld (hl), a 
1547 23				inc hl 
1548 77				ld (hl), a 
1549 23				inc hl 
154a 77				ld (hl), a 
154b			 
154b cd ba 0b		        call clear_display 
154e cd dd 0b			call update_display 
1551				;ld a, 1 
1551				;ld (hardware_diag), a 
1551			.diloop: 
1551 3e 00			ld a, display_row_1 
1553 0e 00			ld c, 0 
1555 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1557 1e 28			ld e, 40 
1559			 
1559 21 c7 e2			ld hl, scratch	 
155c cd 14 0e			call input_str 
155f			 
155f 3e 28			ld a, display_row_2 
1561 11 c7 e2			ld de, scratch 
1564 cd cd 0b			call str_at_display 
1567 cd dd 0b			call update_display 
156a			 
156a c3 51 15			jp .diloop 
156d			 
156d			 
156d			; pass word in hl 
156d			; a has display location 
156d			display_word_at: 
156d f5				push af 
156e e5				push hl 
156f 7c				ld a,h 
1570 21 cc e5			ld hl, os_word_scratch 
1573 cd e8 10			call hexout 
1576 e1				pop hl 
1577 7d				ld a,l 
1578 21 ce e5			ld hl, os_word_scratch+2 
157b cd e8 10			call hexout 
157e 21 d0 e5			ld hl, os_word_scratch+4 
1581 3e 00			ld a,0 
1583 77				ld (hl),a 
1584 11 cc e5			ld de,os_word_scratch 
1587 f1				pop af 
1588 cd cd 0b				call str_at_display 
158b c9				ret 
158c			 
158c			display_ptr_state: 
158c			 
158c				; to restore afterwards 
158c			 
158c d5				push de 
158d c5				push bc 
158e e5				push hl 
158f f5				push af 
1590			 
1590				; for use in here 
1590			 
1590			;	push bc 
1590			;	push de 
1590			;	push hl 
1590			;	push af 
1590			 
1590 cd ba 0b			call clear_display 
1593			 
1593 11 66 17			ld de, .ptrstate 
1596 3e 00			ld a, display_row_1 
1598 cd cd 0b			call str_at_display 
159b			 
159b				; display debug step 
159b			 
159b			 
159b 11 71 ee			ld de, debug_mark 
159e 3e 26			ld a, display_row_1+display_cols-2 
15a0 cd cd 0b			call str_at_display 
15a3			 
15a3				; display a 
15a3 11 70 17			ld de, .ptrcliptr 
15a6 3e 28			ld a, display_row_2 
15a8 cd cd 0b			call str_at_display 
15ab			 
15ab f1				pop af 
15ac 2a 46 ea			ld hl,(cli_ptr) 
15af 3e 30			ld a, display_row_2+8 
15b1 cd 6d 15			call display_word_at 
15b4			 
15b4			 
15b4				; display hl 
15b4			 
15b4			 
15b4 11 78 17			ld de, .ptrclioptr 
15b7 3e 32			ld a, display_row_2+10 
15b9 cd cd 0b			call str_at_display 
15bc			; 
15bc			;	pop hl 
15bc 3e 35			ld a, display_row_2+13 
15be 2a 44 ea			ld hl,(cli_origptr) 
15c1 cd 6d 15			call display_word_at 
15c4			; 
15c4			;	 
15c4			;	; display de 
15c4			 
15c4			;	ld de, .regstatede 
15c4			;	ld a, display_row_3 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop de 
15c4			;	ld h,d 
15c4			;	ld l, e 
15c4			;	ld a, display_row_3+3 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display bc 
15c4			 
15c4			;	ld de, .regstatebc 
15c4			;	ld a, display_row_3+10 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop bc 
15c4			;	ld h,b 
15c4			;	ld l, c 
15c4			;	ld a, display_row_3+13 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display dsp 
15c4			 
15c4			;	ld de, .regstatedsp 
15c4			;	ld a, display_row_4 
15c4			;	call str_at_display 
15c4			 
15c4				 
15c4			;	ld hl,(cli_data_sp) 
15c4			;	ld a, display_row_4+4 
15c4			;	call display_word_at 
15c4			 
15c4				; display rsp 
15c4			 
15c4 11 a7 17			ld de, .regstatersp 
15c7 3e 82			ld a, display_row_4+10 
15c9 cd cd 0b			call str_at_display 
15cc			 
15cc				 
15cc 2a f8 e9			ld hl,(cli_ret_sp) 
15cf 3e 86			ld a, display_row_4+14 
15d1 cd 6d 15			call display_word_at 
15d4			 
15d4 cd dd 0b			call update_display 
15d7			 
15d7 cd f2 0a			call delay1s 
15da cd f2 0a			call delay1s 
15dd cd f2 0a			call delay1s 
15e0			 
15e0			 
15e0 cd fe 1b			call next_page_prompt 
15e3			 
15e3				; restore  
15e3			 
15e3 f1				pop af 
15e4 e1				pop hl 
15e5 c1				pop bc 
15e6 d1				pop de 
15e7 c9				ret 
15e8			 
15e8			break_point_state: 
15e8 f5				push af 
15e9			 
15e9				; see if disabled 
15e9			 
15e9 3a b8 e2			ld a, (os_view_disable) 
15ec fe 2a			cp '*' 
15ee 20 02			jr nz, .bpsgo 
15f0 f1				pop af 
15f1 c9				ret 
15f2			 
15f2			.bpsgo: 
15f2 f1				pop af 
15f3 f5				push af 
15f4 22 b4 e2			ld (os_view_hl), hl 
15f7 ed 53 b2 e2		ld (os_view_de), de 
15fb ed 43 b0 e2		ld (os_view_bc), bc 
15ff e5				push hl 
1600 6f				ld l, a 
1601 26 00			ld h, 0 
1603 22 b6 e2			ld (os_view_af),hl 
1606			 
1606 21 b7 ed				ld hl, display_fb0 
1609 22 d2 eb				ld (display_fb_active), hl 
160c e1				pop hl	 
160d			 
160d 3e 31			ld a, '1' 
160f fe 2a		.bps1:  cp '*' 
1611 20 03			jr nz, .bps1b 
1613 32 b8 e2			ld (os_view_disable),a 
1616 fe 31		.bps1b:  cp '1' 
1618 20 14			jr nz, .bps2 
161a			 
161a				; display reg 
161a			 
161a				 
161a			 
161a 3a b6 e2			ld a, (os_view_af) 
161d 2a b4 e2			ld hl, (os_view_hl) 
1620 ed 5b b2 e2		ld de, (os_view_de) 
1624 ed 4b b0 e2		ld bc, (os_view_bc) 
1628 cd c2 16			call display_reg_state 
162b c3 ae 16			jp .bpschk 
162e			 
162e fe 32		.bps2:  cp '2' 
1630 20 08			jr nz, .bps3 
1632				 
1632				; display hl 
1632 2a b4 e2			ld hl, (os_view_hl) 
1635 cd ac 17			call display_dump_at_hl 
1638			 
1638 18 74			jr .bpschk 
163a			 
163a fe 33		.bps3:  cp '3' 
163c 20 08			jr nz, .bps4 
163e			 
163e			        ; display de 
163e 2a b2 e2			ld hl, (os_view_de) 
1641 cd ac 17			call display_dump_at_hl 
1644			 
1644 18 68			jr .bpschk 
1646 fe 34		.bps4:  cp '4' 
1648 20 08			jr nz, .bps5 
164a			 
164a			        ; display bc 
164a 2a b0 e2			ld hl, (os_view_bc) 
164d cd ac 17			call display_dump_at_hl 
1650			 
1650 18 5c			jr .bpschk 
1652 fe 35		.bps5:  cp '5' 
1654 20 08		        jr nz, .bps7 
1656			 
1656				; display cur ptr 
1656 2a 46 ea			ld hl, (cli_ptr) 
1659 cd ac 17			call display_dump_at_hl 
165c			 
165c 18 50			jr .bpschk 
165e fe 36		.bps7:  cp '6' 
1660 20 08			jr nz, .bps8b 
1662				 
1662				; display cur orig ptr 
1662 2a 44 ea			ld hl, (cli_origptr) 
1665 cd ac 17			call display_dump_at_hl 
1668 18 44			jr .bpschk 
166a fe 37		.bps8b:  cp '7' 
166c 20 08			jr nz, .bps9 
166e				 
166e				; display dsp 
166e 2a f4 e9			ld hl, (cli_data_sp) 
1671 cd ac 17			call display_dump_at_hl 
1674			 
1674 18 38			jr .bpschk 
1676 fe 39		.bps9:  cp '9' 
1678 20 05			jr nz, .bps8c 
167a				 
167a				; display SP 
167a			;	ld hl, sp 
167a cd ac 17			call display_dump_at_hl 
167d			 
167d 18 2f			jr .bpschk 
167f fe 38		.bps8c:  cp '8' 
1681 20 08			jr nz, .bps8d 
1683				 
1683				; display rsp 
1683 2a f8 e9			ld hl, (cli_ret_sp) 
1686 cd ac 17			call display_dump_at_hl 
1689			 
1689 18 23			jr .bpschk 
168b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
168d 20 05			jr nz, .bps8 
168f cd cc 19			call monitor 
1692			 
1692 18 1a			jr .bpschk 
1694 fe 30		.bps8:  cp '0' 
1696 20 16			jr nz, .bpschk 
1698			 
1698 21 16 ed				ld hl, display_fb1 
169b 22 d2 eb				ld (display_fb_active), hl 
169e cd dd 0b				call update_display 
16a1			 
16a1				;ld a, (os_view_af) 
16a1 2a b4 e2			ld hl, (os_view_hl) 
16a4 ed 5b b2 e2		ld de, (os_view_de) 
16a8 ed 4b b0 e2		ld bc, (os_view_bc) 
16ac f1				pop af 
16ad c9				ret 
16ae			 
16ae			.bpschk:   
16ae cd f2 0a			call delay1s 
16b1 3e 9f		ld a,display_row_4 + display_cols - 1 
16b3 11 fc 1b		        ld de, endprg 
16b6 cd cd 0b			call str_at_display 
16b9 cd dd 0b			call update_display 
16bc cd bf 64			call cin_wait 
16bf			 
16bf c3 0f 16			jp .bps1 
16c2			 
16c2			 
16c2			display_reg_state: 
16c2			 
16c2				; to restore afterwards 
16c2			 
16c2 d5				push de 
16c3 c5				push bc 
16c4 e5				push hl 
16c5 f5				push af 
16c6			 
16c6				; for use in here 
16c6			 
16c6 c5				push bc 
16c7 d5				push de 
16c8 e5				push hl 
16c9 f5				push af 
16ca			 
16ca cd ba 0b			call clear_display 
16cd			 
16cd 11 82 17			ld de, .regstate 
16d0 3e 00			ld a, display_row_1 
16d2 cd cd 0b			call str_at_display 
16d5			 
16d5				; display debug step 
16d5			 
16d5			 
16d5 11 71 ee			ld de, debug_mark 
16d8 3e 25			ld a, display_row_1+display_cols-3 
16da cd cd 0b			call str_at_display 
16dd			 
16dd				; display a 
16dd 11 9e 17			ld de, .regstatea 
16e0 3e 28			ld a, display_row_2 
16e2 cd cd 0b			call str_at_display 
16e5			 
16e5 e1				pop hl 
16e6			;	ld h,0 
16e6			;	ld l, a 
16e6 3e 2b			ld a, display_row_2+3 
16e8 cd 6d 15			call display_word_at 
16eb			 
16eb			 
16eb				; display hl 
16eb			 
16eb			 
16eb 11 92 17			ld de, .regstatehl 
16ee 3e 32			ld a, display_row_2+10 
16f0 cd cd 0b			call str_at_display 
16f3			 
16f3 e1				pop hl 
16f4 3e 35			ld a, display_row_2+13 
16f6 cd 6d 15			call display_word_at 
16f9			 
16f9				 
16f9				; display de 
16f9			 
16f9 11 96 17			ld de, .regstatede 
16fc 3e 50			ld a, display_row_3 
16fe cd cd 0b			call str_at_display 
1701			 
1701 e1				pop hl 
1702			;	ld h,d 
1702			;	ld l, e 
1702 3e 53			ld a, display_row_3+3 
1704 cd 6d 15			call display_word_at 
1707			 
1707			 
1707				; display bc 
1707			 
1707 11 9a 17			ld de, .regstatebc 
170a 3e 5a			ld a, display_row_3+10 
170c cd cd 0b			call str_at_display 
170f			 
170f e1				pop hl 
1710			;	ld h,b 
1710			;	ld l, c 
1710 3e 5d			ld a, display_row_3+13 
1712 cd 6d 15			call display_word_at 
1715			 
1715			 
1715				; display dsp 
1715			 
1715 11 a2 17			ld de, .regstatedsp 
1718 3e 78			ld a, display_row_4 
171a cd cd 0b			call str_at_display 
171d			 
171d				 
171d 2a f4 e9			ld hl,(cli_data_sp) 
1720 3e 7c			ld a, display_row_4+4 
1722 cd 6d 15			call display_word_at 
1725			 
1725				; display rsp 
1725			 
1725 11 a7 17			ld de, .regstatersp 
1728 3e 82			ld a, display_row_4+10 
172a cd cd 0b			call str_at_display 
172d			 
172d				 
172d 2a f8 e9			ld hl,(cli_ret_sp) 
1730 3e 86			ld a, display_row_4+14 
1732 cd 6d 15			call display_word_at 
1735			 
1735 cd dd 0b			call update_display 
1738			 
1738			;	call delay1s 
1738			;	call delay1s 
1738			;	call delay1s 
1738			 
1738			 
1738			;	call next_page_prompt 
1738			 
1738				; restore  
1738			 
1738 f1				pop af 
1739 e1				pop hl 
173a c1				pop bc 
173b d1				pop de 
173c c9				ret 
173d			 
173d .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1751 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1766 .. 00		.ptrstate:	db "Ptr State",0 
1770 .. 00		.ptrcliptr:     db "cli_ptr",0 
1778 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1782 .. 00		.regstate:	db "Reg State (1/0)",0 
1792 .. 00		.regstatehl:	db "HL:",0 
1796 .. 00		.regstatede:	db "DE:",0 
179a .. 00		.regstatebc:	db "BC:",0 
179e .. 00		.regstatea:	db "A :",0 
17a2 .. 00		.regstatedsp:	db "DSP:",0 
17a7 .. 00		.regstatersp:	db "RSP:",0 
17ac			 
17ac			display_dump_at_hl: 
17ac e5				push hl 
17ad d5				push de 
17ae c5				push bc 
17af f5				push af 
17b0			 
17b0 22 ea e5			ld (os_cur_ptr),hl	 
17b3 cd ba 0b			call clear_display 
17b6 cd 06 1b			call dumpcont 
17b9			;	call delay1s 
17b9			;	call next_page_prompt 
17b9			 
17b9			 
17b9 f1				pop af 
17ba c1				pop bc 
17bb d1				pop de 
17bc e1				pop hl 
17bd c9				ret 
17be			 
17be			;if ENABLE_BASIC 
17be			;	include "nascombasic.asm" 
17be			;	basic: 
17be			;	include "forth/FORTH.ASM" 
17be			;endif 
17be			 
17be			; eof 
17be			 
17be			 
# End of file firmware_diags.asm
17be			  
17be			include "firmware_prompts.asm"  
17be			; Prompts  
17be			 
17be			; boot messages 
17be			 
17be .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17d3 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17e3			 
17e3			 
17e3			; config menus 
17e3			 
17e3 .. 00		prom_c3: db "Add Dictionary To File",0 
17fa			 
17fa			if STARTUP_V1 
17fa .. 00		prom_c2: db "Select Autoload File",0 
180f .. 00		prom_c2a: db "Disable Autoload File", 0 
1825			endif 
1825			 
1825			if STARTUP_V2 
1825			prom_c2: db "Enable Autoload Files",0 
1825			prom_c2a: db "Disable Autoload Files", 0 
1825			 
1825			crs_s1: db "*ls-word", 0 
1825			crs_s2: db "*ed-word", 0 
1825			crs_s3: db "*Demo-Programs", 0 
1825			crs_s4: db "*Utils", 0 
1825			crs_s5: db "*SPI-Addons", 0 
1825			crs_s6: db "*Key-constants", 0 
1825			 
1825			 
1825			 
1825			endif 
1825 .. 00		prom_c2b: db "Select Storage Bank",0 
1839 .. 00		prom_c4: db "Settings",0 
1842 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
185d .. 00		prom_m4b:   db "Monitor",0 
1865 .. 00		prom_c1: db "Hardware Diags",0 
1874			 
1874			 
1874			if STARTUP_V2 
1874			prom_c9: db "Create Startup Files",0 
1874			endif 
1874			 
1874 .. 00		prom_notav:    db "Feature not available",0 
188a .. 00		prom_empty:    db "",0 
188b			 
188b			; eof 
188b			 
# End of file firmware_prompts.asm
188b			  
188b			  
188b			; eof  
188b			  
# End of file firmware.asm
188b			 
188b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
188b			;if BASE_KEV  
188b			;baseram: equ 08000h 
188b			;endif 
188b			 
188b			;if BASE_SC114 
188b			;baseram:     equ    endofcode 
188b			;endif 
188b			 
188b			 
188b			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
188b			 
188b			; start system 
188b			 
188b			coldstart: 
188b				; set sp 
188b				; di/ei 
188b			 
188b f3				di 
188c 31 00 f0			ld sp, tos 
188f			;	ei 
188f			 
188f				; init spinner 
188f 3e 00			ld a,0 
1891 32 cc eb			ld (display_active), a 
1894			 
1894				; disable breakpoint by default 
1894			 
1894 3e 2a			ld a,'*' 
1896 32 b8 e2			ld (os_view_disable),a 
1899			 
1899				; init hardware 
1899			 
1899				; init keyboard and screen hardware 
1899			 
1899 cd 1c 01			call hardware_init 
189c			 
189c			 
189c cd f2 0a			call delay1s 
189f 3e 58			ld a, display_row_3+8 
18a1 11 03 01			ld de, buildtime 
18a4 cd cd 0b			call str_at_display 
18a7 cd dd 0b			call update_display 
18aa			 
18aa cd f2 0a			call delay1s 
18ad cd f2 0a			call delay1s 
18b0 cd f2 0a			call delay1s 
18b3			 
18b3				; detect if any keys are held down to enable breakpoints at start up 
18b3			 
18b3 cd c7 64			call cin  
18b6 fe 00			cp 0 
18b8 28 03			jr z, .nokeys 
18ba			 
18ba				;call hardware_diags 
18ba cd 47 14			call config 
18bd			 
18bd			;	ld de, .bpen 
18bd			;	ld a, display_row_4 
18bd			;	call str_at_display 
18bd			;	call update_display 
18bd			; 
18bd			;	ld a,0 
18bd			;	ld (os_view_disable),a 
18bd			; 
18bd			;.bpwait: 
18bd			;	call cin 
18bd			;	cp 0 
18bd			;	jr z, .bpwait 
18bd			;	jr .nokeys 
18bd			; 
18bd			; 
18bd			;.bpen:  db "Break points enabled!",0 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			.nokeys: 
18bd			 
18bd			 
18bd				 
18bd			 
18bd			;jp  testkey 
18bd			 
18bd			;call storage_get_block_0 
18bd			; 
18bd			;ld hl, 0 
18bd			;ld de, store_page 
18bd			;call storage_read_block 
18bd			 
18bd				 
18bd			;ld hl, 10 
18bd			;ld de, store_page 
18bd			;call storage_read_block 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			;stop:	nop 
18bd			;	jp stop 
18bd			 
18bd			 
18bd			 
18bd			main: 
18bd cd ba 0b			call clear_display 
18c0 cd dd 0b			call update_display 
18c3			 
18c3			 
18c3			 
18c3			;	call testlcd 
18c3			 
18c3			 
18c3			 
18c3 cd 03 20			call forth_init 
18c6			 
18c6			 
18c6			warmstart: 
18c6 cd d9 1f			call forth_warmstart 
18c9			 
18c9				; run startup word load 
18c9			        ; TODO prevent this running at warmstart after crash  
18c9			 
18c9				if STARTUP_ENABLE 
18c9			 
18c9					if STARTUP_V1 
18c9			 
18c9						if STORAGE_SE 
18c9							call forth_autoload 
18c9						endif 
18c9 cd 20 63					call forth_startup 
18cc					endif 
18cc			 
18cc					if STARTUP_V2 
18cc			 
18cc						if STORAGE_SE 
18cc							call forth_autoload 
18cc						else 
18cc							call forth_startup 
18cc						endif 
18cc			 
18cc			 
18cc					endif 
18cc			 
18cc				endif 
18cc			 
18cc				; show free memory after boot 
18cc 11 66 19			ld de, freeram 
18cf 3e 00			ld a, display_row_1 
18d1 cd cd 0b			call str_at_display 
18d4			 
18d4			; Or use heap_size word???? 
18d4 21 ad e2			ld hl, heap_end 
18d7 11 ef 64			ld de, heap_start 
18da ed 52			sbc hl, de 
18dc e5				push hl 
18dd 7c				ld a,h	         	 
18de 21 cc e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18e1 cd e8 10			call hexout 
18e4 e1			   	pop hl 
18e5			 
18e5 7d				ld a,l 
18e6 21 ce e5			ld hl, os_word_scratch+2 
18e9 cd e8 10			call hexout 
18ec 21 d0 e5			ld hl, os_word_scratch+4 
18ef 3e 00			ld a, 0 
18f1 77				ld (hl),a 
18f2 11 cc e5			ld de, os_word_scratch 
18f5 3e 0d			ld a, display_row_1 + 13 
18f7 cd cd 0b			call str_at_display 
18fa cd dd 0b			call update_display 
18fd			 
18fd			 
18fd				;call demo 
18fd			 
18fd			 
18fd				; init scratch input area for cli commands 
18fd			 
18fd 21 ee e5			ld hl, os_cli_cmd 
1900 3e 00			ld a,0 
1902 77				ld (hl),a 
1903 23				inc hl 
1904 77				ld (hl),a 
1905			 
1905 3e 00			ld a,0 
1907 32 ed e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
190a			 
190a 32 ea e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
190d 32 eb e5			ld (os_cur_ptr+1),a	 
1910			 
1910 32 cc e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1913 32 cd e5			ld (os_word_scratch+1),a	 
1916				 
1916			 
1916				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1916 21 ee e5			ld hl, os_cli_cmd 
1919			 
1919 3e 00			ld a, 0		 ; init cli input 
191b 77				ld (hl), a 
191c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
191e			cli: 
191e				; show cli prompt 
191e				;push af 
191e				;ld a, 0 
191e				;ld de, prompt 
191e				;call str_at_display 
191e			 
191e				;call update_display 
191e				;pop af 
191e				;inc a 
191e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
191e 0e 00			ld c, 0 
1920 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1922 1e 28			ld e, 40 
1924			 
1924 21 ee e5			ld hl, os_cli_cmd 
1927			 
1927				STACKFRAME OFF $fefe $9f9f 
1927				if DEBUG_STACK_IMB 
1927					if OFF 
1927						exx 
1927						ld de, $fefe 
1927						ld a, d 
1927						ld hl, curframe 
1927						call hexout 
1927						ld a, e 
1927						ld hl, curframe+2 
1927						call hexout 
1927						ld hl, $fefe 
1927						push hl 
1927						ld hl, $9f9f 
1927						push hl 
1927						exx 
1927					endif 
1927				endif 
1927			endm 
# End of macro STACKFRAME
1927			 
1927 cd 14 0e			call input_str 
192a			 
192a				STACKFRAMECHK OFF $fefe $9f9f 
192a				if DEBUG_STACK_IMB 
192a					if OFF 
192a						exx 
192a						ld hl, $9f9f 
192a						pop de   ; $9f9f 
192a						call cmp16 
192a						jr nz, .spnosame 
192a						ld hl, $fefe 
192a						pop de   ; $fefe 
192a						call cmp16 
192a						jr z, .spfrsame 
192a						.spnosame: call showsperror 
192a						.spfrsame: nop 
192a						exx 
192a					endif 
192a				endif 
192a			endm 
# End of macro STACKFRAMECHK
192a			 
192a				; copy input to last command 
192a			 
192a 21 ee e5			ld hl, os_cli_cmd 
192d 11 ed e6			ld de, os_last_cmd 
1930 01 ff 00			ld bc, 255 
1933 ed b0			ldir 
1935			 
1935				; wipe current buffer 
1935			 
1935			;	ld a, 0 
1935			;	ld hl, os_cli_cmd 
1935			;	ld de, os_cli_cmd+1 
1935			;	ld bc, 254 
1935			;	ldir 
1935				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1935			;	call strcpy 
1935			;	ld a, 0 
1935			;	ld (hl), a 
1935			;	inc hl 
1935			;	ld (hl), a 
1935			;	inc hl 
1935			;	ld (hl), a 
1935			 
1935				; switch frame buffer to program  
1935			 
1935 21 16 ed				ld hl, display_fb1 
1938 22 d2 eb				ld (display_fb_active), hl 
193b			 
193b			;	nop 
193b				STACKFRAME ON $fbfe $8f9f 
193b				if DEBUG_STACK_IMB 
193b					if ON 
193b						exx 
193b						ld de, $fbfe 
193b						ld a, d 
193b						ld hl, curframe 
193b						call hexout 
193b						ld a, e 
193b						ld hl, curframe+2 
193b						call hexout 
193b						ld hl, $fbfe 
193b						push hl 
193b						ld hl, $8f9f 
193b						push hl 
193b						exx 
193b					endif 
193b				endif 
193b			endm 
# End of macro STACKFRAME
193b				; first time into the parser so pass over the current scratch pad 
193b 21 ee e5			ld hl,os_cli_cmd 
193e				; tokenise the entered statement(s) in HL 
193e cd 81 20			call forthparse 
1941			        ; exec forth statements in top of return stack 
1941 cd c1 20			call forthexec 
1944				;call forthexec_cleanup 
1944			;	call parsenext 
1944			 
1944				STACKFRAMECHK ON $fbfe $8f9f 
1944				if DEBUG_STACK_IMB 
1944					if ON 
1944						exx 
1944						ld hl, $8f9f 
1944						pop de   ; $8f9f 
1944						call cmp16 
1944						jr nz, .spnosame 
1944						ld hl, $fbfe 
1944						pop de   ; $fbfe 
1944						call cmp16 
1944						jr z, .spfrsame 
1944						.spnosame: call showsperror 
1944						.spfrsame: nop 
1944						exx 
1944					endif 
1944				endif 
1944			endm 
# End of macro STACKFRAMECHK
1944				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1944			 
1944 3e 78			ld a, display_row_4 
1946 11 78 19			ld de, endprog 
1949			 
1949 cd dd 0b			call update_display		 
194c			 
194c cd fe 1b			call next_page_prompt 
194f			 
194f				; switch frame buffer to cli 
194f			 
194f 21 b7 ed				ld hl, display_fb0 
1952 22 d2 eb				ld (display_fb_active), hl 
1955			 
1955			 
1955 cd ba 0b		        call clear_display 
1958 cd dd 0b			call update_display		 
195b			 
195b 21 ee e5			ld hl, os_cli_cmd 
195e			 
195e 3e 00			ld a, 0		 ; init cli input 
1960 77				ld (hl), a 
1961			 
1961				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1961			 
1961				; now on last line 
1961			 
1961				; TODO scroll screen up 
1961			 
1961				; TODO instead just clear screen and place at top of screen 
1961			 
1961			;	ld a, 0 
1961			;	ld (f_cursor_ptr),a 
1961			 
1961				;call clear_display 
1961				;call update_display 
1961			 
1961				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1961 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1963 c3 1e 19			jp cli 
1966			 
1966 .. 00		freeram: db "Free bytes: $",0 
1974 ..			asc: db "1A2F" 
1978 .. 00		endprog: db "End prog...",0 
1984			 
1984			testenter2:   
1984 21 f9 e2			ld hl,scratch+50 
1987 22 ea e5			ld (os_cur_ptr),hl 
198a c3 1e 19			jp cli 
198d			 
198d			testenter:  
198d			 
198d 21 74 19			ld hl,asc 
1990			;	ld a,(hl) 
1990			;	call nibble2val 
1990 cd 3e 11			call get_byte 
1993			 
1993			 
1993			;	ld a,(hl) 
1993			;	call atohex 
1993			 
1993			;	call fourehexhl 
1993 32 f9 e2			ld (scratch+50),a 
1996			 
1996			 
1996			 
1996 21 76 19			ld hl,asc+2 
1999			;	ld a, (hl) 
1999			;	call nibble2val 
1999 cd 3e 11			call get_byte 
199c			 
199c			;	call fourehexhl 
199c 32 fb e2			ld (scratch+52),a 
199f				 
199f 21 f9 e2			ld hl,scratch+50 
19a2 22 ea e5			ld (os_cur_ptr),hl 
19a5 c3 1e 19			jp cli 
19a8			 
19a8			enter:	 
19a8 3a cb e2			ld a,(scratch+4) 
19ab fe 00			cp 0 
19ad 28 0c			jr z, .entercont 
19af				; no, not a null term line so has an address to work out.... 
19af			 
19af 21 c9 e2			ld hl,scratch+2 
19b2 cd 9e 11			call get_word_hl 
19b5			 
19b5 22 ea e5			ld (os_cur_ptr),hl	 
19b8 c3 1e 19			jp cli 
19bb			 
19bb			 
19bb			.entercont:  
19bb			 
19bb 21 c9 e2			ld hl, scratch+2 
19be cd 3e 11			call get_byte 
19c1			 
19c1 2a ea e5		   	ld hl,(os_cur_ptr) 
19c4 77					ld (hl),a 
19c5 23					inc hl 
19c6 22 ea e5				ld (os_cur_ptr),hl 
19c9				 
19c9			; get byte  
19c9			 
19c9			 
19c9 c3 1e 19			jp cli 
19cc			 
19cc			 
19cc			; basic monitor support 
19cc			 
19cc			monitor: 
19cc				;  
19cc cd ba 0b			call clear_display 
19cf 3e 00			ld a, 0 
19d1 11 20 1a			ld de, .monprompt 
19d4 cd cd 0b			call str_at_display 
19d7 cd dd 0b			call update_display 
19da			 
19da				; get a monitor command 
19da			 
19da 0e 00			ld c, 0     ; entry at top left 
19dc 16 64			ld d, 100   ; max buffer size 
19de 1e 0f			ld e, 15    ; input scroll area 
19e0 3e 00			ld a, 0     ; init string 
19e2 21 c5 e4			ld hl, os_input 
19e5 77				ld (hl), a 
19e6 23				inc hl 
19e7 77				ld (hl), a 
19e8 21 c5 e4			ld hl, os_input 
19eb 3e 01			ld a, 1     ; init string 
19ed cd 14 0e			call input_str 
19f0			 
19f0 cd ba 0b		        call clear_display 
19f3 cd dd 0b			call update_display		 
19f6			 
19f6 3a c5 e4			ld a, (os_input) 
19f9 cd 3c 12			call toUpper 
19fc fe 48		        cp 'H' 
19fe ca 85 1a		        jp z, .monhelp 
1a01 fe 44			cp 'D'		; dump 
1a03 ca b8 1a			jp z, .mondump	 
1a06 fe 43			cp 'C'		; dump 
1a08 ca d2 1a			jp z, .moncdump	 
1a0b fe 4d			cp 'M'		; dump 
1a0d ca 22 1a			jp z, .moneditstart 
1a10 fe 55			cp 'U'		; dump 
1a12 ca 2e 1a			jp z, .monedit	 
1a15 fe 47			cp 'G'		; dump 
1a17 ca ae 1a			jp z, .monjump 
1a1a fe 51			cp 'Q'		; dump 
1a1c c8				ret z	 
1a1d			 
1a1d			 
1a1d				; TODO "S" to access symbol by name and not need the address 
1a1d				; TODO "F" to find a string in memory 
1a1d			 
1a1d c3 cc 19			jp monitor 
1a20			 
1a20 .. 00		.monprompt: db ">", 0 
1a22			 
1a22			.moneditstart: 
1a22				; get starting address 
1a22			 
1a22 21 c7 e4			ld hl,os_input+2 
1a25 cd 9e 11			call get_word_hl 
1a28			 
1a28 22 ea e5			ld (os_cur_ptr),hl	 
1a2b			 
1a2b c3 cc 19			jp monitor 
1a2e			 
1a2e			.monedit: 
1a2e				; get byte to load 
1a2e			 
1a2e 21 c7 e4			ld hl,os_input+2 
1a31 cd 3e 11			call get_byte 
1a34			 
1a34				; get address to update 
1a34 2a ea e5			ld hl, (os_cur_ptr) 
1a37			 
1a37				; update byte 
1a37			 
1a37 77				ld (hl), a 
1a38			 
1a38				; move to next address and save it 
1a38			 
1a38 23				inc hl 
1a39 22 ea e5			ld (os_cur_ptr),hl	 
1a3c			 
1a3c c3 cc 19			jp monitor 
1a3f			 
1a3f			 
1a3f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a53 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a6f .. 00		.monhelptext3:  db "G-Call address",0 
1a7e .. 00		.monhelptext4:  db "Q-Quit",0 
1a85			        
1a85			.monhelp: 
1a85 3e 00			ld a, display_row_1 
1a87 11 3f 1a		        ld de, .monhelptext1 
1a8a			 
1a8a cd cd 0b			call str_at_display 
1a8d 3e 28			ld a, display_row_2 
1a8f 11 53 1a		        ld de, .monhelptext2 
1a92					 
1a92 cd cd 0b			call str_at_display 
1a95 3e 50			ld a, display_row_3 
1a97 11 6f 1a		        ld de, .monhelptext3 
1a9a					 
1a9a cd cd 0b			call str_at_display 
1a9d 3e 78			ld a, display_row_4 
1a9f 11 7e 1a		        ld de, .monhelptext4 
1aa2 cd cd 0b			call str_at_display 
1aa5			 
1aa5 cd dd 0b			call update_display		 
1aa8			 
1aa8 cd fe 1b			call next_page_prompt 
1aab c3 cc 19			jp monitor 
1aae			 
1aae			.monjump:    
1aae 21 c7 e4			ld hl,os_input+2 
1ab1 cd 9e 11			call get_word_hl 
1ab4			 
1ab4 e9				jp (hl) 
1ab5 c3 cc 19			jp monitor 
1ab8			 
1ab8			.mondump:    
1ab8 21 c7 e4			ld hl,os_input+2 
1abb cd 9e 11			call get_word_hl 
1abe			 
1abe 22 ea e5			ld (os_cur_ptr),hl	 
1ac1 cd 06 1b			call dumpcont 
1ac4 3e 78			ld a, display_row_4 
1ac6 11 78 19			ld de, endprog 
1ac9			 
1ac9 cd dd 0b			call update_display		 
1acc			 
1acc cd fe 1b			call next_page_prompt 
1acf c3 cc 19			jp monitor 
1ad2			.moncdump: 
1ad2 cd 06 1b			call dumpcont 
1ad5 3e 78			ld a, display_row_4 
1ad7 11 78 19			ld de, endprog 
1ada			 
1ada cd dd 0b			call update_display		 
1add			 
1add cd fe 1b			call next_page_prompt 
1ae0 c3 cc 19			jp monitor 
1ae3			 
1ae3			 
1ae3			; TODO symbol access  
1ae3			 
1ae3			.symbols:     ;; A list of symbols that can be called up  
1ae3 b7 ed			dw display_fb0 
1ae5 .. 00			db "fb0",0  
1ae9 80 ea		     	dw store_page 
1aeb .. 00			db "store_page",0 
1af6			 
1af6			 
1af6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1af6			 
1af6 3a c8 e2			ld a,(scratch+1) 
1af9 fe 00			cp 0 
1afb 28 09			jr z, dumpcont 
1afd			 
1afd				; no, not a null term line so has an address to work out.... 
1afd			 
1afd 21 c9 e2			ld hl,scratch+2 
1b00 cd 9e 11			call get_word_hl 
1b03			 
1b03 22 ea e5			ld (os_cur_ptr),hl	 
1b06			 
1b06			 
1b06			 
1b06			dumpcont: 
1b06			 
1b06				; dump bytes at ptr 
1b06			 
1b06			 
1b06 3e 00			ld a, display_row_1 
1b08 2a d2 eb			ld hl, (display_fb_active) 
1b0b cd e7 0d			call addatohl 
1b0e cd 36 1b			call .dumpbyterow 
1b11			 
1b11 3e 28			ld a, display_row_2 
1b13 2a d2 eb			ld hl, (display_fb_active) 
1b16 cd e7 0d			call addatohl 
1b19 cd 36 1b			call .dumpbyterow 
1b1c			 
1b1c			 
1b1c 3e 50			ld a, display_row_3 
1b1e 2a d2 eb			ld hl, (display_fb_active) 
1b21 cd e7 0d			call addatohl 
1b24 cd 36 1b			call .dumpbyterow 
1b27			 
1b27 3e 78			ld a, display_row_4 
1b29 2a d2 eb			ld hl, (display_fb_active) 
1b2c cd e7 0d			call addatohl 
1b2f cd 36 1b			call .dumpbyterow 
1b32			 
1b32 cd dd 0b			call update_display 
1b35			;		jp cli 
1b35 c9				ret 
1b36			 
1b36			.dumpbyterow: 
1b36			 
1b36				;push af 
1b36			 
1b36 e5				push hl 
1b37			 
1b37				; calc where to poke the ascii 
1b37			if display_cols == 20 
1b37				ld a, 16 
1b37			else 
1b37 3e 1f			ld a, 31 
1b39			endif 
1b39			 
1b39 cd e7 0d			call addatohl 
1b3c 22 cc e5			ld (os_word_scratch),hl  		; save pos for later 
1b3f			 
1b3f			 
1b3f			; display decoding address 
1b3f 2a ea e5		   	ld hl,(os_cur_ptr) 
1b42			 
1b42 7c				ld a,h 
1b43 e1				pop hl 
1b44 e5				push hl 
1b45			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b45 cd e8 10			call hexout 
1b48 2a ea e5		   	ld hl,(os_cur_ptr) 
1b4b			 
1b4b 7d				ld a,l 
1b4c e1				pop hl 
1b4d 23				inc hl 
1b4e 23				inc hl 
1b4f e5				push hl 
1b50			;	ld hl, os_word_scratch+2 
1b50 cd e8 10			call hexout 
1b53 e1				pop hl 
1b54 23				inc hl 
1b55 23				inc hl 
1b56				;ld hl, os_word_scratch+4 
1b56 3e 3a			ld a, ':' 
1b58 77				ld (hl),a 
1b59 23				inc hl 
1b5a				;ld a, 0 
1b5a				;ld (hl),a 
1b5a				;ld de, os_word_scratch 
1b5a				;pop af 
1b5a				;push af 
1b5a			;		ld a, display_row_2 
1b5a			;		call str_at_display 
1b5a			;		call update_display 
1b5a			 
1b5a			 
1b5a			;pop af 
1b5a			;	add 5 
1b5a			 
1b5a			if display_cols == 20 
1b5a				ld b, 4 
1b5a			else 
1b5a 06 08			ld b, 8 
1b5c			endif	 
1b5c			 
1b5c			.dumpbyte: 
1b5c c5				push bc 
1b5d e5				push hl 
1b5e			 
1b5e			 
1b5e 2a ea e5		   	ld hl,(os_cur_ptr) 
1b61 7e					ld a,(hl) 
1b62			 
1b62					; poke the ascii to display 
1b62 2a cc e5				ld hl,(os_word_scratch) 
1b65 77					ld (hl),a 
1b66 23					inc hl 
1b67 22 cc e5				ld (os_word_scratch),hl 
1b6a			 
1b6a					 
1b6a			 
1b6a			 
1b6a e1					pop hl 
1b6b e5					push hl 
1b6c			 
1b6c cd e8 10				call hexout 
1b6f			 
1b6f					 
1b6f 2a ea e5		   	ld hl,(os_cur_ptr) 
1b72 23				inc hl 
1b73 22 ea e5		   	ld (os_cur_ptr),hl 
1b76			 
1b76 e1					pop hl 
1b77 23					inc hl 
1b78 23					inc hl 
1b79 23					inc hl 
1b7a			 
1b7a			 
1b7a			 
1b7a					;ld a,0 
1b7a					;ld (os_word_scratch+2),a 
1b7a					;pop af 
1b7a					;push af 
1b7a			 
1b7a					;ld de, os_word_scratch 
1b7a					;call str_at_display 
1b7a			;		call update_display 
1b7a			;		pop af 
1b7a c1					pop bc 
1b7b c6 03				add 3 
1b7d 10 dd			djnz .dumpbyte 
1b7f			 
1b7f				 
1b7f			 
1b7f c9				ret 
1b80			 
1b80			jump:	 
1b80			 
1b80 21 c9 e2			ld hl,scratch+2 
1b83 cd 9e 11			call get_word_hl 
1b86				;ld hl,(scratch+2) 
1b86				;call fourehexhl 
1b86			 
1b86 22 ea e5			ld (os_cur_ptr),hl	 
1b89			 
1b89 e9				jp (hl) 
1b8a			 
1b8a			 
1b8a			 
1b8a			; TODO implement a basic monitor mode to start with 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			 
1b8a			; testing and demo code during development 
1b8a			 
1b8a			 
1b8a .. 00		str1: db "Enter some text...",0 
1b9d .. 00		clear: db "                    ",0 
1bb2			 
1bb2			demo: 
1bb2			 
1bb2			 
1bb2			 
1bb2			;	call update_display 
1bb2			 
1bb2				; init scratch input area for testing 
1bb2 21 c7 e2			ld hl, scratch	 
1bb5 3e 00			ld a,0 
1bb7 77				ld (hl),a 
1bb8			 
1bb8			 
1bb8 3e 28		            LD   A, display_row_2 
1bba			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bba 11 8a 1b		            LD   DE, str1 
1bbd cd cd 0b			call str_at_display 
1bc0			 
1bc0			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bc0			cloop:	 
1bc0 3e 50		            LD   A, display_row_3 
1bc2			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bc2 11 9d 1b		            LD   DE, clear 
1bc5			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1bc5 cd cd 0b				call str_at_display 
1bc8 3e 78			ld a, display_row_4 
1bca 11 fa 1b			ld de, prompt 
1bcd			 
1bcd cd cd 0b				call str_at_display 
1bd0 cd dd 0b			call update_display 
1bd3			 
1bd3 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bd5 16 0a			ld d, 10 
1bd7 21 c7 e2			ld hl, scratch	 
1bda cd 14 0e			call input_str 
1bdd			 
1bdd			;	call clear_display 
1bdd			;'	call update_display 
1bdd			 
1bdd 3e 00		            LD   A, display_row_1 
1bdf			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bdf 11 9d 1b		            LD   DE, clear 
1be2 cd cd 0b				call str_at_display 
1be5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1be5 3e 00		            LD   A, display_row_1 
1be7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1be7 11 c7 e2		            LD   DE, scratch 
1bea			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bea cd cd 0b				call str_at_display 
1bed cd dd 0b			call update_display 
1bf0			 
1bf0 3e 00				ld a,0 
1bf2 21 c7 e2			ld hl, scratch 
1bf5 77				ld (hl),a 
1bf6			 
1bf6 00				nop 
1bf7 c3 c0 1b			jp cloop 
1bfa			 
1bfa			 
1bfa			 
1bfa			; OS Prompt 
1bfa			 
1bfa .. 00		prompt: db ">",0 
1bfc .. 00		endprg: db "?",0 
1bfe			 
1bfe			 
1bfe			; handy next page prompt 
1bfe			next_page_prompt: 
1bfe e5				push hl 
1bff d5				push de 
1c00 f5				push af 
1c01 c5				push bc 
1c02			 
1c02 3e 9f			ld a,display_row_4 + display_cols - 1 
1c04 11 fc 1b		        ld de, endprg 
1c07 cd cd 0b			call str_at_display 
1c0a cd dd 0b			call update_display 
1c0d cd bf 64			call cin_wait 
1c10 c1				pop bc 
1c11 f1				pop af 
1c12 d1				pop de 
1c13 e1				pop hl 
1c14			 
1c14			 
1c14 c9				ret 
1c15			 
1c15			 
1c15			; forth parser 
1c15			 
1c15			; My forth kernel 
1c15			include "forth_kernel.asm" 
1c15			; 
1c15			; kernel to the forth OS 
1c15			 
1c15			DS_TYPE_STR: equ 1     ; string type 
1c15			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c15			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c15			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c15			 
1c15			FORTH_PARSEV1: equ 0 
1c15			FORTH_PARSEV2: equ 0 
1c15			FORTH_PARSEV3: equ 0 
1c15			FORTH_PARSEV4: equ 0 
1c15			FORTH_PARSEV5: equ 1 
1c15			 
1c15			;if FORTH_PARSEV5 
1c15			;	FORTH_END_BUFFER: equ 0 
1c15			;else 
1c15			FORTH_END_BUFFER: equ 127 
1c15			;endif 
1c15			 
1c15			FORTH_TRUE: equ 1 
1c15			FORTH_FALSE: equ 0 
1c15			 
1c15			if FORTH_PARSEV4 
1c15			include "forth_stackops.asm" 
1c15			endif 
1c15			 
1c15			if FORTH_PARSEV5 
1c15			include "forth_stackopsv5.asm" 
1c15			 
1c15			; Stack operations for v5 parser on wards 
1c15			; * DATA stack 
1c15			; * LOOP stack 
1c15			; * RETURN stack 
1c15			 
1c15			 
1c15			 
1c15			FORTH_CHK_DSP_UNDER: macro 
1c15				push hl 
1c15				push de 
1c15				ld hl,(cli_data_sp) 
1c15				ld de, cli_data_stack 
1c15				call cmp16 
1c15				jp c, fault_dsp_under 
1c15				pop de 
1c15				pop hl 
1c15				endm 
1c15			 
1c15			 
1c15			FORTH_CHK_RSP_UNDER: macro 
1c15				push hl 
1c15				push de 
1c15				ld hl,(cli_ret_sp) 
1c15				ld de, cli_ret_stack 
1c15				call cmp16 
1c15				jp c, fault_rsp_under 
1c15				pop de 
1c15				pop hl 
1c15				endm 
1c15			 
1c15			FORTH_CHK_LOOP_UNDER: macro 
1c15				push hl 
1c15				push de 
1c15				ld hl,(cli_loop_sp) 
1c15				ld de, cli_loop_stack 
1c15				call cmp16 
1c15				jp c, fault_loop_under 
1c15				pop de 
1c15				pop hl 
1c15				endm 
1c15			 
1c15			FORTH_ERR_TOS_NOTSTR: macro 
1c15				; TOSO might need more for checks when used 
1c15				push af 
1c15				ld a,(hl) 
1c15				cp DS_TYPE_STR 
1c15				jp nz, type_faultn   
1c15				pop af 
1c15				endm 
1c15			 
1c15			FORTH_ERR_TOS_NOTNUM: macro 
1c15				push af 
1c15				ld a,(hl) 
1c15				cp DS_TYPE_INUM 
1c15				jp nz, type_faultn   
1c15				pop af 
1c15				endm 
1c15			 
1c15			 
1c15			; increase data stack pointer and save hl to it 
1c15				 
1c15			FORTH_DSP_NEXT: macro 
1c15				call macro_forth_dsp_next 
1c15				endm 
1c15			 
1c15			 
1c15			macro_forth_dsp_next: 
1c15				if DEBUG_FORTH_STACK_GUARD 
1c15 cd 01 61				call check_stacks 
1c18				endif 
1c18 e5				push hl 
1c19 d5				push de 
1c1a eb				ex de,hl 
1c1b 2a f4 e9			ld hl,(cli_data_sp) 
1c1e 23				inc hl 
1c1f 23				inc hl 
1c20			 
1c20			; PARSEV5 
1c20 23				inc hl 
1c21 22 f4 e9			ld (cli_data_sp),hl 
1c24 73				ld (hl), e 
1c25 23				inc hl 
1c26 72				ld (hl), d 
1c27 d1				pop de 
1c28 e1				pop hl 
1c29				if DEBUG_FORTH_STACK_GUARD 
1c29 cd 01 61				call check_stacks 
1c2c				endif 
1c2c c9				ret 
1c2d			 
1c2d			 
1c2d			; increase ret stack pointer and save hl to it 
1c2d				 
1c2d			FORTH_RSP_NEXT: macro 
1c2d				call macro_forth_rsp_next 
1c2d				endm 
1c2d			 
1c2d			macro_forth_rsp_next: 
1c2d				if DEBUG_FORTH_STACK_GUARD 
1c2d cd 01 61				call check_stacks 
1c30				endif 
1c30 e5				push hl 
1c31 d5				push de 
1c32 eb				ex de,hl 
1c33 2a f8 e9			ld hl,(cli_ret_sp) 
1c36 23				inc hl 
1c37 23				inc hl 
1c38 22 f8 e9			ld (cli_ret_sp),hl 
1c3b 73				ld (hl), e 
1c3c 23				inc hl 
1c3d 72				ld (hl), d 
1c3e d1				pop de 
1c3f e1				pop hl 
1c40				if DEBUG_FORTH_STACK_GUARD 
1c40 cd 01 61				call check_stacks 
1c43				endif 
1c43 c9				ret 
1c44			 
1c44			; get current ret stack pointer and save to hl  
1c44				 
1c44			FORTH_RSP_TOS: macro 
1c44				call macro_forth_rsp_tos 
1c44				endm 
1c44			 
1c44			macro_forth_rsp_tos: 
1c44				;push de 
1c44 2a f8 e9			ld hl,(cli_ret_sp) 
1c47 cd 7f 1c			call loadhlptrtohl 
1c4a				;ld e, (hl) 
1c4a				;inc hl 
1c4a				;ld d, (hl) 
1c4a				;ex de, hl 
1c4a					if DEBUG_FORTH_WORDS 
1c4a			;			DMARK "RST" 
1c4a						CALLMONITOR 
1c4a cd e8 15			call break_point_state  
1c4d				endm  
# End of macro CALLMONITOR
1c4d					endif 
1c4d				;pop de 
1c4d c9				ret 
1c4e			 
1c4e			; pop ret stack pointer 
1c4e				 
1c4e			FORTH_RSP_POP: macro 
1c4e				call macro_forth_rsp_pop 
1c4e				endm 
1c4e			 
1c4e			 
1c4e			macro_forth_rsp_pop: 
1c4e				if DEBUG_FORTH_STACK_GUARD 
1c4e			;		DMARK "RPP" 
1c4e cd 01 61				call check_stacks 
1c51					FORTH_CHK_RSP_UNDER 
1c51 e5				push hl 
1c52 d5				push de 
1c53 2a f8 e9			ld hl,(cli_ret_sp) 
1c56 11 b2 e9			ld de, cli_ret_stack 
1c59 cd 05 0e			call cmp16 
1c5c da 15 62			jp c, fault_rsp_under 
1c5f d1				pop de 
1c60 e1				pop hl 
1c61				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c61				endif 
1c61 e5				push hl 
1c62 2a f8 e9			ld hl,(cli_ret_sp) 
1c65			 
1c65			 
1c65				if FORTH_ENABLE_FREE 
1c65			 
1c65					; get pointer 
1c65			 
1c65					push de 
1c65					push hl 
1c65			 
1c65					ld e, (hl) 
1c65					inc hl 
1c65					ld d, (hl) 
1c65			 
1c65					ex de, hl 
1c65					call free 
1c65			 
1c65					pop hl 
1c65					pop de 
1c65			 
1c65			 
1c65				endif 
1c65			 
1c65			 
1c65 2b				dec hl 
1c66 2b				dec hl 
1c67 22 f8 e9			ld (cli_ret_sp), hl 
1c6a				; do stack underflow checks 
1c6a e1				pop hl 
1c6b				if DEBUG_FORTH_STACK_GUARD 
1c6b cd 01 61				call check_stacks 
1c6e					FORTH_CHK_RSP_UNDER 
1c6e e5				push hl 
1c6f d5				push de 
1c70 2a f8 e9			ld hl,(cli_ret_sp) 
1c73 11 b2 e9			ld de, cli_ret_stack 
1c76 cd 05 0e			call cmp16 
1c79 da 15 62			jp c, fault_rsp_under 
1c7c d1				pop de 
1c7d e1				pop hl 
1c7e				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c7e				endif 
1c7e c9				ret 
1c7f			 
1c7f			 
1c7f			 
1c7f			; routine to load word pointed to by hl into hl 
1c7f			 
1c7f			loadhlptrtohl: 
1c7f			 
1c7f d5				push de 
1c80 5e				ld e, (hl) 
1c81 23				inc hl 
1c82 56				ld d, (hl) 
1c83 eb				ex de, hl 
1c84 d1				pop de 
1c85			 
1c85 c9				ret 
1c86			 
1c86			 
1c86			 
1c86			 
1c86			 
1c86			; push a number held in HL onto the data stack 
1c86			; entry point for pushing a value when already in hl used in function above 
1c86			 
1c86			forth_push_numhl: 
1c86			 
1c86 e5				push hl    ; save value to push 
1c87			 
1c87			if DEBUG_FORTH_PUSH 
1c87				; see if disabled 
1c87			 
1c87			 
1c87 f5				push af 
1c88 3a b8 e2			ld a, (os_view_disable) 
1c8b fe 2a			cp '*' 
1c8d 28 34			jr z, .pskip2 
1c8f e5				push hl 
1c90 e5			push hl 
1c91 cd ba 0b			call clear_display 
1c94 e1			pop hl 
1c95 7c				ld a,h 
1c96 21 cc e5			ld hl, os_word_scratch 
1c99 cd e8 10			call hexout 
1c9c e1				pop hl 
1c9d 7d				ld a,l 
1c9e 21 ce e5			ld hl, os_word_scratch+2 
1ca1 cd e8 10			call hexout 
1ca4			 
1ca4 21 d0 e5			ld hl, os_word_scratch+4 
1ca7 3e 00			ld a,0 
1ca9 77				ld (hl),a 
1caa 11 cc e5			ld de,os_word_scratch 
1cad 3e 28				ld a, display_row_2 
1caf cd cd 0b				call str_at_display 
1cb2 11 e6 4c			ld de, .push_num 
1cb5 3e 00			ld a, display_row_1 
1cb7			 
1cb7 cd cd 0b				call str_at_display 
1cba			 
1cba			 
1cba cd dd 0b			call update_display 
1cbd cd f2 0a			call delay1s 
1cc0 cd f2 0a			call delay1s 
1cc3			.pskip2:  
1cc3			 
1cc3 f1				pop af 
1cc4			endif	 
1cc4			 
1cc4			 
1cc4				FORTH_DSP_NEXT 
1cc4 cd 15 1c			call macro_forth_dsp_next 
1cc7				endm 
# End of macro FORTH_DSP_NEXT
1cc7			 
1cc7 2a f4 e9			ld hl, (cli_data_sp) 
1cca			 
1cca				; save item type 
1cca 3e 02			ld a,  DS_TYPE_INUM 
1ccc 77				ld (hl), a 
1ccd 23				inc hl 
1cce			 
1cce				; get word off stack 
1cce d1				pop de 
1ccf 7b				ld a,e 
1cd0 77				ld (hl), a 
1cd1 23				inc hl 
1cd2 7a				ld a,d 
1cd3 77				ld (hl), a 
1cd4			 
1cd4			if DEBUG_FORTH_PUSH 
1cd4 2b				dec hl 
1cd5 2b				dec hl 
1cd6 2b				dec hl 
1cd7						DMARK "PH5" 
1cd7 f5				push af  
1cd8 3a ec 1c			ld a, (.dmark)  
1cdb 32 71 ee			ld (debug_mark),a  
1cde 3a ed 1c			ld a, (.dmark+1)  
1ce1 32 72 ee			ld (debug_mark+1),a  
1ce4 3a ee 1c			ld a, (.dmark+2)  
1ce7 32 73 ee			ld (debug_mark+2),a  
1cea 18 03			jr .pastdmark  
1cec ..			.dmark: db "PH5"  
1cef f1			.pastdmark: pop af  
1cf0			endm  
# End of macro DMARK
1cf0				CALLMONITOR 
1cf0 cd e8 15			call break_point_state  
1cf3				endm  
# End of macro CALLMONITOR
1cf3			endif	 
1cf3			 
1cf3 c9				ret 
1cf4			 
1cf4			 
1cf4			; Push a string to stack pointed to by hl 
1cf4			 
1cf4			forth_push_str: 
1cf4			 
1cf4			if DEBUG_FORTH_PUSH 
1cf4						DMARK "PSQ" 
1cf4 f5				push af  
1cf5 3a 09 1d			ld a, (.dmark)  
1cf8 32 71 ee			ld (debug_mark),a  
1cfb 3a 0a 1d			ld a, (.dmark+1)  
1cfe 32 72 ee			ld (debug_mark+1),a  
1d01 3a 0b 1d			ld a, (.dmark+2)  
1d04 32 73 ee			ld (debug_mark+2),a  
1d07 18 03			jr .pastdmark  
1d09 ..			.dmark: db "PSQ"  
1d0c f1			.pastdmark: pop af  
1d0d			endm  
# End of macro DMARK
1d0d				CALLMONITOR 
1d0d cd e8 15			call break_point_state  
1d10				endm  
# End of macro CALLMONITOR
1d10			endif	 
1d10			    
1d10 e5				push hl 
1d11 e5				push hl 
1d12			 
1d12			;	ld a, 0   ; find end of string 
1d12 cd 45 12			call strlenz 
1d15			if DEBUG_FORTH_PUSH 
1d15						DMARK "PQ2" 
1d15 f5				push af  
1d16 3a 2a 1d			ld a, (.dmark)  
1d19 32 71 ee			ld (debug_mark),a  
1d1c 3a 2b 1d			ld a, (.dmark+1)  
1d1f 32 72 ee			ld (debug_mark+1),a  
1d22 3a 2c 1d			ld a, (.dmark+2)  
1d25 32 73 ee			ld (debug_mark+2),a  
1d28 18 03			jr .pastdmark  
1d2a ..			.dmark: db "PQ2"  
1d2d f1			.pastdmark: pop af  
1d2e			endm  
# End of macro DMARK
1d2e				CALLMONITOR 
1d2e cd e8 15			call break_point_state  
1d31				endm  
# End of macro CALLMONITOR
1d31			endif	 
1d31 eb				ex de, hl 
1d32 e1				pop hl   ; get ptr to start of string 
1d33			if DEBUG_FORTH_PUSH 
1d33						DMARK "PQ3" 
1d33 f5				push af  
1d34 3a 48 1d			ld a, (.dmark)  
1d37 32 71 ee			ld (debug_mark),a  
1d3a 3a 49 1d			ld a, (.dmark+1)  
1d3d 32 72 ee			ld (debug_mark+1),a  
1d40 3a 4a 1d			ld a, (.dmark+2)  
1d43 32 73 ee			ld (debug_mark+2),a  
1d46 18 03			jr .pastdmark  
1d48 ..			.dmark: db "PQ3"  
1d4b f1			.pastdmark: pop af  
1d4c			endm  
# End of macro DMARK
1d4c				CALLMONITOR 
1d4c cd e8 15			call break_point_state  
1d4f				endm  
# End of macro CALLMONITOR
1d4f			endif	 
1d4f 19				add hl,de 
1d50			if DEBUG_FORTH_PUSH 
1d50						DMARK "PQE" 
1d50 f5				push af  
1d51 3a 65 1d			ld a, (.dmark)  
1d54 32 71 ee			ld (debug_mark),a  
1d57 3a 66 1d			ld a, (.dmark+1)  
1d5a 32 72 ee			ld (debug_mark+1),a  
1d5d 3a 67 1d			ld a, (.dmark+2)  
1d60 32 73 ee			ld (debug_mark+2),a  
1d63 18 03			jr .pastdmark  
1d65 ..			.dmark: db "PQE"  
1d68 f1			.pastdmark: pop af  
1d69			endm  
# End of macro DMARK
1d69				CALLMONITOR 
1d69 cd e8 15			call break_point_state  
1d6c				endm  
# End of macro CALLMONITOR
1d6c			endif	 
1d6c			 
1d6c 2b				dec hl    ; see if there is an optional trailing double quote 
1d6d 7e				ld a,(hl) 
1d6e fe 22			cp '"' 
1d70 20 03			jr nz, .strnoq 
1d72 3e 00			ld a, 0      ; get rid of double quote 
1d74 77				ld (hl), a 
1d75 23			.strnoq: inc hl 
1d76			 
1d76 3e 00			ld a, 0 
1d78 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d79			 
1d79 13				inc de ; add one for the type string 
1d7a 13				inc de ; add one for null term??? 
1d7b			 
1d7b				; tos is get string pointer again 
1d7b				; de contains space to allocate 
1d7b				 
1d7b d5				push de 
1d7c			 
1d7c eb				ex de, hl 
1d7d			 
1d7d				;push af 
1d7d			 
1d7d			if DEBUG_FORTH_PUSH 
1d7d						DMARK "PHm" 
1d7d f5				push af  
1d7e 3a 92 1d			ld a, (.dmark)  
1d81 32 71 ee			ld (debug_mark),a  
1d84 3a 93 1d			ld a, (.dmark+1)  
1d87 32 72 ee			ld (debug_mark+1),a  
1d8a 3a 94 1d			ld a, (.dmark+2)  
1d8d 32 73 ee			ld (debug_mark+2),a  
1d90 18 03			jr .pastdmark  
1d92 ..			.dmark: db "PHm"  
1d95 f1			.pastdmark: pop af  
1d96			endm  
# End of macro DMARK
1d96				CALLMONITOR 
1d96 cd e8 15			call break_point_state  
1d99				endm  
# End of macro CALLMONITOR
1d99			endif	 
1d99 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d9c				if DEBUG_FORTH_MALLOC_GUARD 
1d9c cc 3e 4d				call z,malloc_error 
1d9f				endif 
1d9f			 
1d9f				 
1d9f c1				pop bc    ; get length 
1da0 d1				pop de   ;  get string start    
1da1			 
1da1				; hl has destination from malloc 
1da1			 
1da1 eb				ex de, hl    ; prep for ldir 
1da2			 
1da2 d5				push de   ; save malloc area for DSP later 
1da3				;push hl   ; save malloc area for DSP later 
1da3			 
1da3			if DEBUG_FORTH_PUSH 
1da3						DMARK "PHc" 
1da3 f5				push af  
1da4 3a b8 1d			ld a, (.dmark)  
1da7 32 71 ee			ld (debug_mark),a  
1daa 3a b9 1d			ld a, (.dmark+1)  
1dad 32 72 ee			ld (debug_mark+1),a  
1db0 3a ba 1d			ld a, (.dmark+2)  
1db3 32 73 ee			ld (debug_mark+2),a  
1db6 18 03			jr .pastdmark  
1db8 ..			.dmark: db "PHc"  
1dbb f1			.pastdmark: pop af  
1dbc			endm  
# End of macro DMARK
1dbc				CALLMONITOR 
1dbc cd e8 15			call break_point_state  
1dbf				endm  
# End of macro CALLMONITOR
1dbf			endif	 
1dbf			 
1dbf			 
1dbf ed b0			ldir 
1dc1			 
1dc1			 
1dc1				; push malloc to data stack     macro?????  
1dc1			 
1dc1				FORTH_DSP_NEXT 
1dc1 cd 15 1c			call macro_forth_dsp_next 
1dc4				endm 
# End of macro FORTH_DSP_NEXT
1dc4			 
1dc4				; save value and type 
1dc4			 
1dc4 2a f4 e9			ld hl, (cli_data_sp) 
1dc7			 
1dc7				; save item type 
1dc7 3e 01			ld a,  DS_TYPE_STR 
1dc9 77				ld (hl), a 
1dca 23				inc hl 
1dcb			 
1dcb				; get malloc word off stack 
1dcb d1				pop de 
1dcc 73				ld (hl), e 
1dcd 23				inc hl 
1dce 72				ld (hl), d 
1dcf			 
1dcf			 
1dcf			 
1dcf			if DEBUG_FORTH_PUSH 
1dcf 2a f4 e9			ld hl, (cli_data_sp) 
1dd2						DMARK "PHS" 
1dd2 f5				push af  
1dd3 3a e7 1d			ld a, (.dmark)  
1dd6 32 71 ee			ld (debug_mark),a  
1dd9 3a e8 1d			ld a, (.dmark+1)  
1ddc 32 72 ee			ld (debug_mark+1),a  
1ddf 3a e9 1d			ld a, (.dmark+2)  
1de2 32 73 ee			ld (debug_mark+2),a  
1de5 18 03			jr .pastdmark  
1de7 ..			.dmark: db "PHS"  
1dea f1			.pastdmark: pop af  
1deb			endm  
# End of macro DMARK
1deb				CALLMONITOR 
1deb cd e8 15			call break_point_state  
1dee				endm  
# End of macro CALLMONITOR
1dee			;	ex de,hl 
1dee			endif	 
1dee				; in case of spaces, skip the ptr past the copied string 
1dee				;pop af 
1dee				;ld (cli_origptr),hl 
1dee			 
1dee c9				ret 
1def			 
1def			 
1def			 
1def			; TODO ascii push input onto stack given hl to start of input 
1def			 
1def			; identify type 
1def			; if starts with a " then a string 
1def			; otherwise it is a number 
1def			;  
1def			; if a string 
1def			;     scan for ending " to get length of string to malloc for + 1 
1def			;     malloc 
1def			;     put pointer to string on stack first byte flags as string 
1def			; 
1def			; else a number 
1def			;    look for number format identifier 
1def			;    $xx hex 
1def			;    %xxxxx bin 
1def			;    xxxxx decimal 
1def			;    convert number to 16bit word.  
1def			;    malloc word + 1 with flag to identiy as num 
1def			;    put pointer to number on stack 
1def			;   
1def			;  
1def			  
1def			forth_apush: 
1def				; kernel push 
1def			 
1def			if DEBUG_FORTH_PUSH 
1def						DMARK "PSH" 
1def f5				push af  
1df0 3a 04 1e			ld a, (.dmark)  
1df3 32 71 ee			ld (debug_mark),a  
1df6 3a 05 1e			ld a, (.dmark+1)  
1df9 32 72 ee			ld (debug_mark+1),a  
1dfc 3a 06 1e			ld a, (.dmark+2)  
1dff 32 73 ee			ld (debug_mark+2),a  
1e02 18 03			jr .pastdmark  
1e04 ..			.dmark: db "PSH"  
1e07 f1			.pastdmark: pop af  
1e08			endm  
# End of macro DMARK
1e08				CALLMONITOR 
1e08 cd e8 15			call break_point_state  
1e0b				endm  
# End of macro CALLMONITOR
1e0b			endif	 
1e0b				; identify input type 
1e0b			 
1e0b 7e				ld a,(hl) 
1e0c fe 22			cp '"' 
1e0e 28 0a			jr z, .fapstr 
1e10 fe 24			cp '$' 
1e12 ca 3a 1e			jp z, .faphex 
1e15 fe 25			cp '%' 
1e17 ca 22 1e			jp z, .fapbin 
1e1a			;	cp 'b' 
1e1a			;	jp z, .fabin 
1e1a				; else decimal 
1e1a			 
1e1a				; TODO do decimal conversion 
1e1a				; decimal is stored as a 16bit word 
1e1a			 
1e1a				; by default everything is a string if type is not detected 
1e1a			.fapstr: ; 
1e1a fe 22			cp '"' 
1e1c 20 01			jr nz, .strnoqu 
1e1e 23				inc hl 
1e1f			.strnoqu: 
1e1f c3 f4 1c			jp forth_push_str 
1e22			 
1e22			 
1e22			 
1e22			.fapbin:    ; push a binary string.  
1e22 11 00 00			ld de, 0   ; hold a 16bit value 
1e25			 
1e25 23			.fapbinshift:	inc hl  
1e26 7e				ld a,(hl) 
1e27 fe 00			cp 0     ; done scanning  
1e29 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e2b			 
1e2b				; left shift de 
1e2b eb				ex de, hl	 
1e2c 29				add hl, hl 
1e2d			 
1e2d				; is 1 
1e2d fe 31			cp '1' 
1e2f 20 02			jr nz, .binzero 
1e31 cb 4d			bit 1, l 
1e33			.binzero: 
1e33 eb				ex de, hl	 ; save current de 
1e34 18 ef			jr .fapbinshift 
1e36			 
1e36			.fapbdone: 
1e36 eb				ex de, hl 
1e37 c3 86 1c			jp forth_push_numhl 
1e3a			 
1e3a			 
1e3a			.faphex:   ; hex is always stored as a 16bit word 
1e3a				; skip number prefix 
1e3a 23				inc hl 
1e3b				; turn ascii into number 
1e3b cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1e3e			 
1e3e c3 86 1c			jp forth_push_numhl 
1e41			 
1e41 00				 nop 
1e42			 
1e42			.fabin:   ; TODO bin conversion 
1e42			 
1e42			 
1e42 c9				ret 
1e43			 
1e43			 
1e43			; get either a string ptr or a 16bit word from the data stack 
1e43			 
1e43			FORTH_DSP: macro 
1e43				call macro_forth_dsp 
1e43				endm 
1e43			 
1e43			macro_forth_dsp: 
1e43				; data stack pointer points to current word on tos 
1e43			 
1e43 2a f4 e9			ld hl,(cli_data_sp) 
1e46			 
1e46				if DEBUG_FORTH_PUSH 
1e46						DMARK "DSP" 
1e46 f5				push af  
1e47 3a 5b 1e			ld a, (.dmark)  
1e4a 32 71 ee			ld (debug_mark),a  
1e4d 3a 5c 1e			ld a, (.dmark+1)  
1e50 32 72 ee			ld (debug_mark+1),a  
1e53 3a 5d 1e			ld a, (.dmark+2)  
1e56 32 73 ee			ld (debug_mark+2),a  
1e59 18 03			jr .pastdmark  
1e5b ..			.dmark: db "DSP"  
1e5e f1			.pastdmark: pop af  
1e5f			endm  
# End of macro DMARK
1e5f			 
1e5f cd 73 4d				call display_data_sp 
1e62				;call break_point_state 
1e62				;rst 030h 
1e62				CALLMONITOR 
1e62 cd e8 15			call break_point_state  
1e65				endm  
# End of macro CALLMONITOR
1e65				endif 
1e65			 
1e65 c9				ret 
1e66			 
1e66			; return hl to start of value on stack 
1e66			 
1e66			FORTH_DSP_VALUE: macro 
1e66				call macro_forth_dsp_value 
1e66				endm 
1e66			 
1e66			macro_forth_dsp_value: 
1e66			 
1e66				FORTH_DSP 
1e66 cd 43 1e			call macro_forth_dsp 
1e69				endm 
# End of macro FORTH_DSP
1e69			 
1e69 d5				push de 
1e6a			 
1e6a 23				inc hl ; skip type 
1e6b			 
1e6b 5e				ld e, (hl) 
1e6c 23				inc hl 
1e6d 56				ld d, (hl) 
1e6e eb				ex de,hl  
1e6f			 
1e6f d1				pop de 
1e70			 
1e70 c9				ret 
1e71			 
1e71			; return hl to start of value to second item on stack 
1e71			 
1e71			FORTH_DSP_VALUEM1: macro 
1e71				call macro_forth_dsp_value_m1 
1e71				endm 
1e71			 
1e71			macro_forth_dsp_value_m1: 
1e71			 
1e71				FORTH_DSP 
1e71 cd 43 1e			call macro_forth_dsp 
1e74				endm 
# End of macro FORTH_DSP
1e74			 
1e74 2b				dec hl 
1e75 2b				dec hl 
1e76			;	dec hl 
1e76			 
1e76 d5				push de 
1e77			 
1e77 5e				ld e, (hl) 
1e78 23				inc hl 
1e79 56				ld d, (hl) 
1e7a eb				ex de,hl  
1e7b			 
1e7b d1				pop de 
1e7c			 
1e7c c9				ret 
1e7d			 
1e7d				 
1e7d			 
1e7d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e7d			 
1e7d			FORTH_DSP_POP: macro 
1e7d				call macro_forth_dsp_pop 
1e7d				endm 
1e7d			 
1e7d			 
1e7d			; get the tos data type 
1e7d			 
1e7d			FORTH_DSP_TYPE:   macro 
1e7d			 
1e7d				;FORTH_DSP_VALUE 
1e7d				FORTH_DSP 
1e7d				 
1e7d				; hl points to value 
1e7d				; check type 
1e7d			 
1e7d				ld a,(hl) 
1e7d			 
1e7d				endm 
1e7d			 
1e7d			; load the tos value into hl 
1e7d			 
1e7d			 
1e7d			FORTH_DSP_VALUEHL:  macro 
1e7d				call macro_dsp_valuehl 
1e7d				endm 
1e7d			 
1e7d			 
1e7d			 
1e7d			macro_dsp_valuehl: 
1e7d				FORTH_DSP_VALUE 
1e7d cd 66 1e			call macro_forth_dsp_value 
1e80				endm 
# End of macro FORTH_DSP_VALUE
1e80			 
1e80				;FORTH_ERR_TOS_NOTNUM 
1e80			 
1e80				;inc hl   ; skip type id 
1e80			 
1e80			;	push de 
1e80			; 
1e80			;	ld e, (hl) 
1e80			;	inc hl 
1e80			;	ld d, (hl) 
1e80			;	ex de,hl  
1e80			 
1e80			;	pop de 
1e80			 
1e80				if DEBUG_FORTH_PUSH 
1e80						DMARK "DVL" 
1e80 f5				push af  
1e81 3a 95 1e			ld a, (.dmark)  
1e84 32 71 ee			ld (debug_mark),a  
1e87 3a 96 1e			ld a, (.dmark+1)  
1e8a 32 72 ee			ld (debug_mark+1),a  
1e8d 3a 97 1e			ld a, (.dmark+2)  
1e90 32 73 ee			ld (debug_mark+2),a  
1e93 18 03			jr .pastdmark  
1e95 ..			.dmark: db "DVL"  
1e98 f1			.pastdmark: pop af  
1e99			endm  
# End of macro DMARK
1e99				CALLMONITOR 
1e99 cd e8 15			call break_point_state  
1e9c				endm  
# End of macro CALLMONITOR
1e9c				endif 
1e9c c9				ret 
1e9d			 
1e9d			forth_apushstrhl:      
1e9d				; push of string requires use of cli_origptr 
1e9d				; bodge use 
1e9d			 
1e9d				; get current cli_origptr, save, update with temp pointer  
1e9d ed 5b 44 ea		ld de, (cli_origptr) 
1ea1 22 44 ea			ld (cli_origptr), hl 
1ea4 d5				push de 
1ea5 cd ef 1d			call forth_apush 
1ea8 d1				pop de 
1ea9 ed 53 44 ea		ld (cli_origptr), de 
1ead c9			        ret	 
1eae			 
1eae			 
1eae			; increase loop stack pointer and save hl to it 
1eae				 
1eae			FORTH_LOOP_NEXT: macro 
1eae				call macro_forth_loop_next 
1eae				;nop 
1eae				endm 
1eae			 
1eae			macro_forth_loop_next: 
1eae				if DEBUG_FORTH_STACK_GUARD 
1eae cd 01 61				call check_stacks 
1eb1				endif 
1eb1 e5				push hl 
1eb2 d5				push de 
1eb3 eb				ex de,hl 
1eb4 2a f6 e9			ld hl,(cli_loop_sp) 
1eb7 23				inc hl 
1eb8 23				inc hl 
1eb9					if DEBUG_FORTH_WORDS 
1eb9						DMARK "LNX" 
1eb9 f5				push af  
1eba 3a ce 1e			ld a, (.dmark)  
1ebd 32 71 ee			ld (debug_mark),a  
1ec0 3a cf 1e			ld a, (.dmark+1)  
1ec3 32 72 ee			ld (debug_mark+1),a  
1ec6 3a d0 1e			ld a, (.dmark+2)  
1ec9 32 73 ee			ld (debug_mark+2),a  
1ecc 18 03			jr .pastdmark  
1ece ..			.dmark: db "LNX"  
1ed1 f1			.pastdmark: pop af  
1ed2			endm  
# End of macro DMARK
1ed2						CALLMONITOR 
1ed2 cd e8 15			call break_point_state  
1ed5				endm  
# End of macro CALLMONITOR
1ed5					endif 
1ed5 22 f6 e9			ld (cli_loop_sp),hl 
1ed8 73				ld (hl), e 
1ed9 23				inc hl 
1eda 72				ld (hl), d 
1edb d1				pop de    ; been reversed so save a swap on restore 
1edc e1				pop hl 
1edd				if DEBUG_FORTH_STACK_GUARD 
1edd cd 01 61				call check_stacks 
1ee0				endif 
1ee0 c9				ret 
1ee1			 
1ee1			; get current ret stack pointer and save to hl  
1ee1				 
1ee1			FORTH_LOOP_TOS: macro 
1ee1				call macro_forth_loop_tos 
1ee1				endm 
1ee1			 
1ee1			macro_forth_loop_tos: 
1ee1 d5				push de 
1ee2 2a f6 e9			ld hl,(cli_loop_sp) 
1ee5 5e				ld e, (hl) 
1ee6 23				inc hl 
1ee7 56				ld d, (hl) 
1ee8 eb				ex de, hl 
1ee9 d1				pop de 
1eea c9				ret 
1eeb			 
1eeb			; pop loop stack pointer 
1eeb				 
1eeb			FORTH_LOOP_POP: macro 
1eeb				call macro_forth_loop_pop 
1eeb				endm 
1eeb			 
1eeb			 
1eeb			macro_forth_loop_pop: 
1eeb				if DEBUG_FORTH_STACK_GUARD 
1eeb					DMARK "LPP" 
1eeb f5				push af  
1eec 3a 00 1f			ld a, (.dmark)  
1eef 32 71 ee			ld (debug_mark),a  
1ef2 3a 01 1f			ld a, (.dmark+1)  
1ef5 32 72 ee			ld (debug_mark+1),a  
1ef8 3a 02 1f			ld a, (.dmark+2)  
1efb 32 73 ee			ld (debug_mark+2),a  
1efe 18 03			jr .pastdmark  
1f00 ..			.dmark: db "LPP"  
1f03 f1			.pastdmark: pop af  
1f04			endm  
# End of macro DMARK
1f04 cd 01 61				call check_stacks 
1f07					FORTH_CHK_LOOP_UNDER 
1f07 e5				push hl 
1f08 d5				push de 
1f09 2a f6 e9			ld hl,(cli_loop_sp) 
1f0c 11 30 e9			ld de, cli_loop_stack 
1f0f cd 05 0e			call cmp16 
1f12 da 1b 62			jp c, fault_loop_under 
1f15 d1				pop de 
1f16 e1				pop hl 
1f17				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f17				endif 
1f17 e5				push hl 
1f18 2a f6 e9			ld hl,(cli_loop_sp) 
1f1b 2b				dec hl 
1f1c 2b				dec hl 
1f1d 22 f6 e9			ld (cli_loop_sp), hl 
1f20				; TODO do stack underflow checks 
1f20 e1				pop hl 
1f21				if DEBUG_FORTH_STACK_GUARD 
1f21 cd 01 61				call check_stacks 
1f24					FORTH_CHK_LOOP_UNDER 
1f24 e5				push hl 
1f25 d5				push de 
1f26 2a f6 e9			ld hl,(cli_loop_sp) 
1f29 11 30 e9			ld de, cli_loop_stack 
1f2c cd 05 0e			call cmp16 
1f2f da 1b 62			jp c, fault_loop_under 
1f32 d1				pop de 
1f33 e1				pop hl 
1f34				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f34				endif 
1f34 c9				ret 
1f35			 
1f35			macro_forth_dsp_pop: 
1f35			 
1f35 e5				push hl 
1f36			 
1f36				; release malloc data 
1f36			 
1f36				if DEBUG_FORTH_STACK_GUARD 
1f36 cd 01 61				call check_stacks 
1f39					FORTH_CHK_DSP_UNDER 
1f39 e5				push hl 
1f3a d5				push de 
1f3b 2a f4 e9			ld hl,(cli_data_sp) 
1f3e 11 2e e8			ld de, cli_data_stack 
1f41 cd 05 0e			call cmp16 
1f44 da 0f 62			jp c, fault_dsp_under 
1f47 d1				pop de 
1f48 e1				pop hl 
1f49				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f49				endif 
1f49				;ld hl,(cli_data_sp) 
1f49			if DEBUG_FORTH_DOT 
1f49				DMARK "DPP" 
1f49 f5				push af  
1f4a 3a 5e 1f			ld a, (.dmark)  
1f4d 32 71 ee			ld (debug_mark),a  
1f50 3a 5f 1f			ld a, (.dmark+1)  
1f53 32 72 ee			ld (debug_mark+1),a  
1f56 3a 60 1f			ld a, (.dmark+2)  
1f59 32 73 ee			ld (debug_mark+2),a  
1f5c 18 03			jr .pastdmark  
1f5e ..			.dmark: db "DPP"  
1f61 f1			.pastdmark: pop af  
1f62			endm  
# End of macro DMARK
1f62				CALLMONITOR 
1f62 cd e8 15			call break_point_state  
1f65				endm  
# End of macro CALLMONITOR
1f65			endif	 
1f65			 
1f65			 
1f65			if FORTH_ENABLE_DSPPOPFREE 
1f65			 
1f65				FORTH_DSP 
1f65 cd 43 1e			call macro_forth_dsp 
1f68				endm 
# End of macro FORTH_DSP
1f68			 
1f68 7e				ld a, (hl) 
1f69 fe 01			cp DS_TYPE_STR 
1f6b 20 23			jr nz, .skippopfree 
1f6d			 
1f6d				FORTH_DSP_VALUEHL 
1f6d cd 7d 1e			call macro_dsp_valuehl 
1f70				endm 
# End of macro FORTH_DSP_VALUEHL
1f70 00				nop 
1f71			if DEBUG_FORTH_DOT 
1f71				DMARK "DPf" 
1f71 f5				push af  
1f72 3a 86 1f			ld a, (.dmark)  
1f75 32 71 ee			ld (debug_mark),a  
1f78 3a 87 1f			ld a, (.dmark+1)  
1f7b 32 72 ee			ld (debug_mark+1),a  
1f7e 3a 88 1f			ld a, (.dmark+2)  
1f81 32 73 ee			ld (debug_mark+2),a  
1f84 18 03			jr .pastdmark  
1f86 ..			.dmark: db "DPf"  
1f89 f1			.pastdmark: pop af  
1f8a			endm  
# End of macro DMARK
1f8a				CALLMONITOR 
1f8a cd e8 15			call break_point_state  
1f8d				endm  
# End of macro CALLMONITOR
1f8d			endif	 
1f8d cd 78 13			call free 
1f90			.skippopfree: 
1f90				 
1f90			 
1f90			endif 
1f90			 
1f90			if DEBUG_FORTH_DOT_KEY 
1f90				DMARK "DP2" 
1f90				CALLMONITOR 
1f90			endif	 
1f90			 
1f90				; move pointer down 
1f90			 
1f90 2a f4 e9			ld hl,(cli_data_sp) 
1f93 2b				dec hl 
1f94 2b				dec hl 
1f95			; PARSEV5 
1f95 2b				dec hl 
1f96 22 f4 e9			ld (cli_data_sp), hl 
1f99			 
1f99				if DEBUG_FORTH_STACK_GUARD 
1f99 cd 01 61				call check_stacks 
1f9c					FORTH_CHK_DSP_UNDER 
1f9c e5				push hl 
1f9d d5				push de 
1f9e 2a f4 e9			ld hl,(cli_data_sp) 
1fa1 11 2e e8			ld de, cli_data_stack 
1fa4 cd 05 0e			call cmp16 
1fa7 da 0f 62			jp c, fault_dsp_under 
1faa d1				pop de 
1fab e1				pop hl 
1fac				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fac				endif 
1fac			 
1fac e1				pop hl 
1fad			 
1fad c9				ret 
1fae			 
1fae			getwordathl: 
1fae				; hl points to an address 
1fae				; load hl with the word at that address 
1fae			 
1fae d5				push de 
1faf			 
1faf 5e				ld e, (hl) 
1fb0 23				inc hl 
1fb1 56				ld d, (hl) 
1fb2 eb				ex de, hl 
1fb3			 
1fb3 d1				pop de 
1fb4 c9				ret 
1fb5			 
1fb5			 
1fb5			 
1fb5			 
1fb5			 
1fb5			; eof 
1fb5			 
# End of file forth_stackopsv5.asm
1fb5			endif 
1fb5			 
1fb5			loadwordinhl:	 
1fb5			 
1fb5 d5				push de 
1fb6			 
1fb6 5e				ld e, (hl) 
1fb7 23				inc hl 
1fb8 56				ld d, (hl) 
1fb9 eb				ex de,hl  
1fba			 
1fba d1				pop de 
1fbb			 
1fbb c9				ret 
1fbc			 
1fbc			user_word_eol:  
1fbc				; hl contains the pointer to where to create a linked list item from the end 
1fbc				; of the user dict to continue on at the system word dict 
1fbc				 
1fbc				; poke the stub of the word list linked list to repoint to rom words 
1fbc			 
1fbc				; stub format 
1fbc				; db   word id 
1fbc				; dw    link to next word 
1fbc			        ; db char length of token 
1fbc				; db string + 0 term 
1fbc				; db exec code....  
1fbc			 
1fbc 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fbe 77				ld (hl), a		; word id 
1fbf 23				inc hl 
1fc0			 
1fc0 11 8b 21			ld de, sysdict 
1fc3 73				ld (hl), e		; next word link ie system dict 
1fc4 23				inc hl 
1fc5 72				ld (hl), d		; next word link ie system dict 
1fc6 23				inc hl	 
1fc7			 
1fc7			;	ld (hl), sysdict		; next word link ie system dict 
1fc7			;	inc hl 
1fc7			;	inc hl 
1fc7			 
1fc7			;	inc hl 
1fc7			;	inc hl 
1fc7			 
1fc7 3e 02			ld a, 2			; word length is 0 
1fc9 77				ld (hl), a	 
1fca 23				inc hl 
1fcb			 
1fcb 3e 7e			ld a, '~'			; word length is 0 
1fcd 77				ld (hl), a	 
1fce 23				inc hl 
1fcf 3e 00			ld a, 0			; save empty word 
1fd1 77				ld (hl), a 
1fd2			 
1fd2 c9				ret 
1fd3			 
1fd3				 
1fd3			 
1fd3			forthexec_cleanup: 
1fd3				FORTH_RSP_POP 
1fd3 cd 4e 1c			call macro_forth_rsp_pop 
1fd6				endm 
# End of macro FORTH_RSP_POP
1fd6 c9				ret 
1fd7			 
1fd7			forth_call_hl: 
1fd7				; taking hl 
1fd7 e5				push hl 
1fd8 c9				ret 
1fd9			 
1fd9			; this is called to reset Forth system but keep existing uwords etc 
1fd9			 
1fd9			forth_warmstart: 
1fd9				; setup stack over/under flow checks 
1fd9				if DEBUG_FORTH_STACK_GUARD 
1fd9 cd e7 60				call chk_stk_init 
1fdc				endif 
1fdc			 
1fdc				; init stack pointers  - * these stacks go upwards *  
1fdc 21 b2 e9			ld hl, cli_ret_stack 
1fdf 22 f8 e9			ld (cli_ret_sp), hl	 
1fe2				; set bottom of stack 
1fe2 3e 00			ld a,0 
1fe4 77				ld (hl),a 
1fe5 23				inc hl 
1fe6 77				ld (hl),a 
1fe7			 
1fe7 21 2e e8			ld hl, cli_data_stack 
1fea 22 f4 e9			ld (cli_data_sp), hl	 
1fed				; set bottom of stack 
1fed 3e 00			ld a,0 
1fef 77				ld (hl),a 
1ff0 23				inc hl 
1ff1 77				ld (hl),a 
1ff2			 
1ff2 21 30 e9			ld hl, cli_loop_stack 
1ff5 22 f6 e9			ld (cli_loop_sp), hl	 
1ff8				; set bottom of stack 
1ff8 3e 00			ld a,0 
1ffa 77				ld (hl),a 
1ffb 23				inc hl 
1ffc 77				ld (hl),a 
1ffd			 
1ffd				; init extent of current open file 
1ffd			 
1ffd 3e 00			ld a, 0 
1fff 32 70 ea			ld (store_openext), a 
2002			 
2002 c9				ret 
2003			 
2003			 
2003			; Cold Start - this is called to setup the whole Forth system 
2003			 
2003			forth_init: 
2003			 
2003				; setup stack over/under flow checks 
2003			 
2003			;	if DEBUG_FORTH_STACK_GUARD 
2003			;		call chk_stk_init 
2003			;	endif 
2003			 
2003				; enable auto display updates (slow.....) 
2003			 
2003 3e 01			ld a, 1 
2005 32 42 ea			ld (cli_autodisplay), a 
2008			 
2008				; if storage is in use disable long reads for now 
2008 3e 00			ld a, 0 
200a 32 7b ea			ld (store_longread), a 
200d			 
200d			 
200d				; show start up screen 
200d			 
200d cd ba 0b			call clear_display 
2010			 
2010 3e 00			ld a,0 
2012 32 64 ea			ld (f_cursor_ptr), a 
2015			 
2015				; set start of word list in start of ram - for use when creating user words 
2015			 
2015 21 e0 64			ld hl, baseram 
2018 22 c4 e5			ld (os_last_new_uword), hl 
201b cd bc 1f			call user_word_eol 
201e				 
201e			;		call display_data_sp 
201e			;		call next_page_prompt 
201e			 
201e			 
201e			 
201e			 
201e c9				ret 
201f			 
201f .. 00		.bootforth: db " Forth Kernel Init ",0 
2033			 
2033			; TODO push to stack 
2033			 
2033			;  
2033			 
2033			if FORTH_PARSEV2 
2033			 
2033			 
2033				include "forth_parserv2.asm" 
2033			 
2033			endif 
2033			 
2033			 
2033			; parse cli version 1 
2033			 
2033			if FORTH_PARSEV1 
2033			 
2033			 
2033			 
2033			      include "forth_parserv1.asm" 
2033			endif 
2033				 
2033			if FORTH_PARSEV3 
2033			 
2033			 
2033			 
2033			      include "forth_parserv3.asm" 
2033				include "forth_wordsv3.asm" 
2033			endif 
2033			 
2033			if FORTH_PARSEV4 
2033			 
2033			 
2033			 
2033			      include "forth_parserv4.asm" 
2033				include "forth_wordsv4.asm" 
2033			endif 
2033			 
2033			if FORTH_PARSEV5 
2033			 
2033			 
2033			 
2033			      include "forth_parserv5.asm" 
2033			 
2033			 
2033			; A better parser without using malloc and string copies all over the place.  
2033			; Exec in situ should be faster 
2033			 
2033			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2033			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2033			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2033			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2033			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2033			WORD_SYS_END: equ 0   ; Opcode for all user words 
2033			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2033			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2033			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2033			 
2033			; Core word preamble macro 
2033			 
2033			CWHEAD:   macro nxtword opcode lit len opflags 
2033				db WORD_SYS_CORE+opcode             
2033				; internal op code number 
2033				dw nxtword            
2033				; link to next dict word block 
2033				db len + 1 
2033				; literal length of dict word inc zero term 
2033				db lit,0              
2033				; literal dict word 
2033			        ; TODO db opflags        
2033				endm 
2033			 
2033			 
2033			NEXTW: macro  
2033				jp macro_next 
2033				endm 
2033			 
2033			macro_next: 
2033			if DEBUG_FORTH_PARSE_KEY 
2033				DMARK "NXT" 
2033				CALLMONITOR 
2033			endif	 
2033			;	inc hl  ; skip token null term  
2033 ed 4b 46 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2037 ed 5b 44 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
203b 2a c8 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
203e			if DEBUG_FORTH_PARSE_KEY 
203e				DMARK "}AA" 
203e				CALLMONITOR 
203e			endif	 
203e c3 41 21			jp execnext 
2041				;jp exec1 
2041			       
2041			 
2041			 
2041			; Another go at the parser to compile  
2041			 
2041			 
2041			; TODO rework parser to change all of the string words to byte tokens 
2041			; TODO do a search for  
2041			 
2041			; TODO first run normal parser to zero term sections 
2041			; TODO for each word do a token look up to get the op code 
2041			; TODO need some means to flag to the exec that this is a byte code form    
2041			 
2041			 
2041			forthcompile: 
2041			 
2041			; 
2041			; line parse: 
2041			;       parse raw input buffer 
2041			;       tokenise the words 
2041			;       malloc new copy (for looping etc) 
2041			;       copy to malloc + current pc in line to start of string and add line term 
2041			;       save on new rsp 
2041			; 
2041			 
2041			; hl to point to the line to tokenise 
2041			 
2041			;	push hl 
2041 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2044			 
2044			;	ld a,0		; string term on input 
2044			;	call strlent 
2044			 
2044			;	ld (os_tok_len), hl	 ; save string length 
2044			 
2044			;if DEBUG_FORTH_TOK 
2044			;	ex de,hl		 
2044			;endif 
2044			 
2044			;	pop hl 		; get back string pointer 
2044			 
2044			if DEBUG_FORTH_TOK 
2044						DMARK "TOc" 
2044				CALLMONITOR 
2044			endif 
2044 7e			.cptoken2:    ld a,(hl) 
2045 23				inc hl 
2046 fe 7f			cp FORTH_END_BUFFER 
2048 28 29			jr z, .cptokendone2 
204a fe 00			cp 0 
204c 28 25			jr z, .cptokendone2 
204e fe 22			cp '"' 
2050 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2052 fe 20			cp ' ' 
2054 20 ee			jr nz,  .cptoken2 
2056			 
2056			; TODO consume comments held between ( and ) 
2056			 
2056				; we have a space so change to zero term for dict match later 
2056 2b				dec hl 
2057 3e 00			ld a,0 
2059 77				ld (hl), a 
205a 23				inc hl 
205b 18 e7			jr .cptoken2 
205d				 
205d			 
205d			.cptokenstr2: 
205d				; skip all white space until either eol (because forgot to term) or end double quote 
205d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
205d				;inc hl ; skip current double quote 
205d 7e				ld a,(hl) 
205e 23				inc hl 
205f fe 22			cp '"' 
2061 28 e1			jr z, .cptoken2 
2063 fe 7f			cp FORTH_END_BUFFER 
2065 28 0c			jr z, .cptokendone2 
2067 fe 00			cp 0 
2069 28 08			jr z, .cptokendone2 
206b fe 20			cp ' ' 
206d 28 02			jr z, .cptmp2 
206f 18 ec			jr .cptokenstr2 
2071			 
2071			.cptmp2:	; we have a space so change to zero term for dict match later 
2071				;dec hl 
2071				;ld a,"-"	; TODO remove this when working 
2071				;ld (hl), a 
2071				;inc hl 
2071 18 ea			jr .cptokenstr2 
2073			 
2073			.cptokendone2: 
2073				;inc hl 
2073 3e 7f			ld a, FORTH_END_BUFFER 
2075 77				ld (hl),a 
2076 23				inc hl 
2077 3e 21			ld a, '!' 
2079 77				ld (hl),a 
207a			 
207a 2a c8 e5			ld hl,(os_tok_ptr) 
207d			         
207d			if DEBUG_FORTH_TOK 
207d						DMARK "Tc1" 
207d				CALLMONITOR 
207d			endif 
207d			 
207d				; push exec string to top of return stack 
207d				FORTH_RSP_NEXT 
207d cd 2d 1c			call macro_forth_rsp_next 
2080				endm 
# End of macro FORTH_RSP_NEXT
2080 c9				ret 
2081			 
2081			; Another go at the parser need to simplify the process 
2081			 
2081			forthparse: 
2081			 
2081			; 
2081			; line parse: 
2081			;       parse raw input buffer 
2081			;       tokenise the words 
2081			;       malloc new copy (for looping etc) 
2081			;       copy to malloc + current pc in line to start of string and add line term 
2081			;       save on new rsp 
2081			; 
2081			 
2081			; hl to point to the line to tokenise 
2081			 
2081			;	push hl 
2081 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2084			 
2084			;	ld a,0		; string term on input 
2084			;	call strlent 
2084			 
2084			;	ld (os_tok_len), hl	 ; save string length 
2084			 
2084			;if DEBUG_FORTH_TOK 
2084			;	ex de,hl		 
2084			;endif 
2084			 
2084			;	pop hl 		; get back string pointer 
2084			 
2084			if DEBUG_FORTH_TOK 
2084						DMARK "TOK" 
2084				CALLMONITOR 
2084			endif 
2084 7e			.ptoken2:    ld a,(hl) 
2085 23				inc hl 
2086 fe 7f			cp FORTH_END_BUFFER 
2088 28 29			jr z, .ptokendone2 
208a fe 00			cp 0 
208c 28 25			jr z, .ptokendone2 
208e fe 22			cp '"' 
2090 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2092 fe 20			cp ' ' 
2094 20 ee			jr nz,  .ptoken2 
2096			 
2096			; TODO consume comments held between ( and ) 
2096			 
2096				; we have a space so change to zero term for dict match later 
2096 2b				dec hl 
2097 3e 00			ld a,0 
2099 77				ld (hl), a 
209a 23				inc hl 
209b 18 e7			jr .ptoken2 
209d				 
209d			 
209d			.ptokenstr2: 
209d				; skip all white space until either eol (because forgot to term) or end double quote 
209d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
209d				;inc hl ; skip current double quote 
209d 7e				ld a,(hl) 
209e 23				inc hl 
209f fe 22			cp '"' 
20a1 28 e1			jr z, .ptoken2 
20a3 fe 7f			cp FORTH_END_BUFFER 
20a5 28 0c			jr z, .ptokendone2 
20a7 fe 00			cp 0 
20a9 28 08			jr z, .ptokendone2 
20ab fe 20			cp ' ' 
20ad 28 02			jr z, .ptmp2 
20af 18 ec			jr .ptokenstr2 
20b1			 
20b1			.ptmp2:	; we have a space so change to zero term for dict match later 
20b1				;dec hl 
20b1				;ld a,"-"	; TODO remove this when working 
20b1				;ld (hl), a 
20b1				;inc hl 
20b1 18 ea			jr .ptokenstr2 
20b3			 
20b3			.ptokendone2: 
20b3				;inc hl 
20b3 3e 7f			ld a, FORTH_END_BUFFER 
20b5 77				ld (hl),a 
20b6 23				inc hl 
20b7 3e 21			ld a, '!' 
20b9 77				ld (hl),a 
20ba			 
20ba 2a c8 e5			ld hl,(os_tok_ptr) 
20bd			         
20bd			if DEBUG_FORTH_TOK 
20bd						DMARK "TK1" 
20bd				CALLMONITOR 
20bd			endif 
20bd			 
20bd				; push exec string to top of return stack 
20bd				FORTH_RSP_NEXT 
20bd cd 2d 1c			call macro_forth_rsp_next 
20c0				endm 
# End of macro FORTH_RSP_NEXT
20c0 c9				ret 
20c1			 
20c1			; 
20c1			;	; malloc size + buffer pointer + if is loop flag 
20c1			;	ld hl,(os_tok_len) 		 ; get string length 
20c1			; 
20c1			;	ld a,l 
20c1			; 
20c1			;	cp 0			; we dont want to use a null string 
20c1			;	ret z 
20c1			; 
20c1			;;	add 3    ; prefix malloc with buffer for current word ptr 
20c1			; 
20c1			;	add 5     ; TODO when certain not over writing memory remove 
20c1			; 
20c1			;		 
20c1			; 
20c1			;if DEBUG_FORTH_TOK 
20c1			;			DMARK "TKE" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			; 
20c1			;	ld l,a 
20c1			;	ld h,0 
20c1			;;	push hl   ; save required space for the copy later 
20c1			;	call malloc 
20c1			;if DEBUG_FORTH_TOK 
20c1			;			DMARK "TKM" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			;	if DEBUG_FORTH_MALLOC_GUARD 
20c1			;		push af 
20c1			;		call ishlzero 
20c1			;;		ld a, l 
20c1			;;		add h 
20c1			;;		cp 0 
20c1			;		pop af 
20c1			;		 
20c1			;		call z,malloc_error 
20c1			;	endif 
20c1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20c1			; 
20c1			; 
20c1			;if DEBUG_FORTH_TOK 
20c1			;			DMARK "TKR" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			; 
20c1			;	FORTH_RSP_NEXT 
20c1			; 
20c1			;	;inc hl	 ; go past current buffer pointer 
20c1			;	;inc hl 
20c1			;	;inc hl   ; and past if loop flag 
20c1			;		; TODO Need to set flag  
20c1			; 
20c1			;	 
20c1			;	 
20c1			;	ex de,hl	; malloc is dest 
20c1			;	ld hl, (os_tok_len) 
20c1			;;	pop bc 
20c1			;	ld c, l                
20c1			;	ld b,0 
20c1			;	ld hl, (os_tok_ptr) 
20c1			; 
20c1			;if DEBUG_FORTH_TOK 
20c1			;			DMARK "TKT" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			; 
20c1			;	; do str cpy 
20c1			; 
20c1			;	ldir      ; copy byte in hl to de 
20c1			; 
20c1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20c1			; 
20c1			;if DEBUG_FORTH_TOK 
20c1			; 
20c1			;			DMARK "TKY" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			;	;ld a,0 
20c1			;	;ld a,FORTH_END_BUFFER 
20c1			;	ex de, hl 
20c1			;	;dec hl			 ; go back over the space delim at the end of word 
20c1			;	;ld (hl),a 
20c1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20c1			;	ld a,FORTH_END_BUFFER 
20c1			;	ld (hl),a 
20c1			;	inc hl 
20c1			;	ld a,FORTH_END_BUFFER 
20c1			;	ld (hl),a 
20c1			; 
20c1			;	; init the malloc area data 
20c1			;	; set pc for in current area 
20c1			;	;ld hl, (os_tok_malloc) 
20c1			;	;inc hl 
20c1			;	;inc hl 
20c1			;	;inc hl 
20c1			;	;ex de,hl 
20c1			;	;ld hl, (os_tok_malloc) 
20c1			;	;ld (hl),e 
20c1			;	;inc hl 
20c1			;	;ld (hl),d 
20c1			; 
20c1			; 
20c1			;	ld hl,(os_tok_malloc) 
20c1			;if DEBUG_FORTH_PARSE_KEY 
20c1			;			DMARK "TKU" 
20c1			;	CALLMONITOR 
20c1			;endif 
20c1			; 
20c1			;	ret 
20c1			 
20c1			forthexec: 
20c1			 
20c1			; line exec: 
20c1			; forth parser 
20c1			 
20c1			; 
20c1			;       get current exec line on rsp 
20c1			 
20c1				FORTH_RSP_TOS 
20c1 cd 44 1c			call macro_forth_rsp_tos 
20c4				endm 
# End of macro FORTH_RSP_TOS
20c4			 
20c4			;       restore current pc - hl points to malloc of data 
20c4			 
20c4				;ld e, (hl) 
20c4				;inc hl 
20c4				;ld d, (hl) 
20c4				;ex de,hl 
20c4			 
20c4			 
20c4			exec1: 
20c4 22 c8 e5			ld (os_tok_ptr), hl 
20c7			 
20c7				; copy our PC to working vars  
20c7 22 46 ea			ld (cli_ptr), hl 
20ca 22 44 ea			ld (cli_origptr), hl 
20cd			 
20cd 7e				ld a,(hl) 
20ce fe 7f			cp FORTH_END_BUFFER 
20d0 c8				ret z 
20d1			 
20d1				; skip any nulls 
20d1			 
20d1 fe 00			cp 0 
20d3 20 03			jr nz, .execword 
20d5 23				inc hl 
20d6 18 ec			jr exec1 
20d8			 
20d8			 
20d8			.execword: 
20d8			 
20d8			 
20d8			 
20d8			if DEBUG_FORTH_PARSE_KEY 
20d8						DMARK "KYQ" 
20d8				CALLMONITOR 
20d8			endif 
20d8			;       while at start of word: 
20d8			; get start of dict (in user area first) 
20d8			 
20d8 21 e0 64		ld hl, baseram 
20db			;ld hl, sysdict 
20db 22 48 ea		ld (cli_nextword),hl 
20de			;           match word at pc 
20de			;           exec word 
20de			;           or push to dsp 
20de			;           forward to next token 
20de			;           if line term pop rsp and exit 
20de			;        
20de			 
20de			if DEBUG_FORTH_PARSE_KEY 
20de						DMARK "KYq" 
20de				CALLMONITOR 
20de			endif 
20de			 
20de			; 
20de			; word comp 
20de			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20de			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20de			;    move to start of word  
20de			;    compare word to cli_token 
20de			 
20de			.execpnword:	; HL at start of a word in the dictionary to check 
20de			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20de			;	ld (cli_ptr), hl 
20de			 
20de 2a 48 ea			ld hl,(cli_nextword) 
20e1			 
20e1 cd 84 21			call forth_tok_next 
20e4			; tok next start here 
20e4			;	; TODO skip compiled symbol for now 
20e4			;	inc hl 
20e4			; 
20e4			;	; save pointer to next word 
20e4			; 
20e4			;	; hl now points to the address of the next word pointer  
20e4			;	ld e, (hl) 
20e4			;	inc hl 
20e4			;	ld d, (hl) 
20e4			;	inc l 
20e4			; 
20e4			;	ex de,hl 
20e4			;if DEBUG_FORTH_PARSE_NEXTWORD 
20e4			;	push bc 
20e4			;	ld bc, (cli_nextword) 
20e4			;			DMARK "NXW" 
20e4			;	CALLMONITOR 
20e4			;	pop bc 
20e4			;endif 
20e4			; tok next end here 
20e4 22 48 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20e7 eb				ex de, hl 
20e8			 
20e8			 
20e8				; save the pointer of the current token - 1 to check against 
20e8				 
20e8 22 4c ea			ld (cli_token), hl   
20eb				; TODO maybe remove below save if no debug 
20eb				; save token string ptr for any debug later 
20eb 23				inc hl  
20ec 22 4e ea			ld (cli_origtoken), hl 
20ef 2b				dec hl 
20f0				; save pointer to the start of the next dictionay word 
20f0 7e				ld a,(hl)   ; get string length 
20f1 47				ld b,a 
20f2			.execpnwordinc:  
20f2 23				inc hl 
20f3 10 fd			djnz .execpnwordinc 
20f5 22 4a ea			ld (cli_execword), hl      ; save start of this words code 
20f8			 
20f8				; now check the word token against the string being parsed 
20f8			 
20f8 2a 4c ea			ld hl,(cli_token) 
20fb 23				inc hl     ; skip string length (use zero term instead to end) 
20fc 22 4c ea			ld (cli_token), hl 
20ff			 
20ff			if DEBUG_FORTH_PARSE_KEY 
20ff						DMARK "KY2" 
20ff			endif 
20ff			if DEBUG_FORTH_PARSE_EXEC 
20ff				; see if disabled 
20ff			 
20ff				ld a, (os_view_disable) 
20ff				cp '*' 
20ff				jr z, .skip 
20ff			 
20ff				push hl 
20ff				push hl 
20ff				call clear_display 
20ff				ld de, .compword 
20ff				ld a, display_row_1 
20ff				call str_at_display 
20ff				pop de 
20ff				ld a, display_row_2 
20ff				call str_at_display 
20ff				ld hl,(cli_ptr) 
20ff				ld a,(hl) 
20ff			        ld hl, os_word_scratch 
20ff				ld (hl),a 
20ff				ld a,0 
20ff				inc hl 
20ff				ld (hl),a 	 
20ff				ld de, os_word_scratch 
20ff				ld a, display_row_2+10 
20ff				call str_at_display 
20ff				call update_display 
20ff				ld a, 100 
20ff				call aDelayInMS 
20ff				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20ff				call delay250ms 
20ff				endif 
20ff				pop hl 
20ff			.skip:  
20ff			endif	 
20ff			.execpnchar:    ; compare char between token and string to parse 
20ff			 
20ff			if DEBUG_FORTH_PARSE_KEY 
20ff						DMARK "Ky3" 
20ff			endif 
20ff			if DEBUG_FORTH_PARSE_EXEC 
20ff				; see if disabled 
20ff			 
20ff				ld a, (os_view_disable) 
20ff				cp '*' 
20ff				jr z, .skip2 
20ff			 
20ff			;	call clear_display 
20ff			ld hl,(cli_token) 
20ff			ld a,(hl) 
20ff			ld (os_word_scratch),a 
20ff				ld hl,(cli_ptr) 
20ff			ld a,(hl) 
20ff				ld (os_word_scratch+1),a 
20ff				ld a,0 
20ff				ld (os_word_scratch+2),a 
20ff				ld de,os_word_scratch 
20ff				ld a,display_row_4 
20ff				call str_at_display 
20ff				call update_display 
20ff			.skip2:  
20ff			endif 
20ff 2a 4c ea			ld hl,(cli_token) 
2102 7e				ld a, (hl)	 ; char in word token 
2103 23				inc hl 		; move to next char 
2104 22 4c ea			ld (cli_token), hl ; and save it 
2107 47				ld b,a 
2108			 
2108 2a 46 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
210b 7e				ld a,(hl) 
210c 23				inc hl 
210d 22 46 ea			ld (cli_ptr), hl		; move to next char 
2110 cd 3c 12			call toUpper 		; make sure the input string matches case 
2113			 
2113			if DEBUG_FORTH_PARSE 
2113			endif 
2113			 
2113				; input stream end of token is a space so get rid of it 
2113			 
2113			;	cp ' ' 
2113			;	jr nz, .pnskipspace 
2113			; 
2113			;	ld a, 0		; make same term as word token term 
2113			; 
2113			;.pnskipspace: 
2113			 
2113			if DEBUG_FORTH_PARSE_KEY 
2113						DMARK "KY7" 
2113			endif 
2113 b8				cp b 
2114 c2 2a 21			jp nz, .execpnskipword	 ; no match so move to next word 
2117				 
2117			;    if same 
2117			;       scan for string terms 0 for token and 32 for input 
2117			 
2117				 
2117			if DEBUG_FORTH_PARSE_KEY 
2117						DMARK "KY8" 
2117			endif 
2117			 
2117 80				add b			 
2118 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
211a							; TODO need to make sure last word in zero term string is accounted for 
211a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
211c			 
211c			 
211c				; at end of both strings so both are exact match 
211c			 
211c			;       skip ptr for next word 
211c			 
211c 2a 46 ea			ld hl,(cli_ptr) 	; at input string term 
211f 23				inc hl			 ; at next char 
2120 22 46 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2123 22 44 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2126				 
2126				 
2126			if DEBUG_FORTH_PARSE_KEY 
2126						DMARK "KY3" 
2126			endif 
2126			 
2126			 
2126			 
2126			;       exec code block 
2126			if DEBUG_FORTH_JP 
2126				call clear_display 
2126				call update_display 
2126				call delay1s 
2126				ld hl, (cli_execword)     ; save for next check if no match on this word 
2126				ld a,h 
2126				ld hl, os_word_scratch 
2126				call hexout 
2126				ld hl, (cli_execword)     ; save for next check if no match on this word 
2126				ld a,l 
2126				ld hl, os_word_scratch+2 
2126				call hexout 
2126				ld hl, os_word_scratch+4 
2126				ld a,0 
2126				ld (hl),a 
2126				ld de,os_word_scratch 
2126				call str_at_display 
2126					ld a, display_row_2 
2126					call str_at_display 
2126				ld de, (cli_origtoken) 
2126				ld a, display_row_1+10 
2126					call str_at_display 
2126			 
2126				ld a,display_row_1 
2126				ld de, .foundword 
2126				ld a, display_row_3 
2126				call str_at_display 
2126				call update_display 
2126				call delay1s 
2126				call delay1s 
2126				call delay1s 
2126			endif 
2126			 
2126			if DEBUG_FORTH_PARSE_KEY 
2126						DMARK "KYj" 
2126			endif 
2126				; TODO save the word pointer in this exec 
2126			 
2126 2a 4a ea			ld hl,(cli_execword) 
2129 e9				jp (hl) 
212a			 
212a			 
212a			;    if not same 
212a			;	scan for zero term 
212a			;	get ptr for next word 
212a			;	goto word comp 
212a			 
212a			.execpnskipword:	; get pointer to next word 
212a 2a 48 ea			ld hl,(cli_nextword) 
212d			 
212d 7e				ld a,(hl) 
212e fe 00			cp WORD_SYS_END 
2130			;	cp 0 
2130 28 09			jr z, .execendofdict			 ; at end of words 
2132			 
2132			if DEBUG_FORTH_PARSE_KEY 
2132						DMARK "KY4" 
2132			endif 
2132			if DEBUG_FORTH_PARSE_EXEC 
2132			 
2132				; see if disabled 
2132			 
2132				ld a, (os_view_disable) 
2132				cp '*' 
2132				jr z, .noskip 
2132			 
2132			 
2132				ld de, .nowordfound 
2132				ld a, display_row_3 
2132				call str_at_display 
2132				call update_display 
2132				ld a, 100 
2132				call aDelayInMS 
2132				 
2132				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2132					call delay250ms 
2132				endif 
2132			.noskip:  
2132			 
2132			endif	 
2132			 
2132 2a 44 ea			ld hl,(cli_origptr) 
2135 22 46 ea			ld (cli_ptr),hl 
2138			 
2138			if DEBUG_FORTH_PARSE_KEY 
2138						DMARK "KY5" 
2138			endif 
2138 c3 de 20			jp .execpnword			; else go to next word 
213b			 
213b			.execendofdict:  
213b			 
213b			if DEBUG_FORTH_PARSE_KEY 
213b						DMARK "KYe" 
213b			endif 
213b			if DEBUG_FORTH_PARSE_EXEC 
213b				; see if disabled 
213b			 
213b				ld a, (os_view_disable) 
213b				cp '*' 
213b				jr z, .ispskip 
213b			 
213b				call clear_display 
213b				call update_display 
213b				call delay1s 
213b				ld de, (cli_origptr) 
213b				ld a, display_row_1 
213b				call str_at_display 
213b				 
213b				ld de, .enddict 
213b				ld a, display_row_3 
213b				call str_at_display 
213b				call update_display 
213b				ld a, 100 
213b				call aDelayInMS 
213b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
213b				call delay1s 
213b				call delay1s 
213b				call delay1s 
213b				endif 
213b			.ispskip:  
213b				 
213b			endif	 
213b			 
213b			 
213b			 
213b				; if the word is not a keyword then must be a literal so push it to stack 
213b			 
213b			; push token to stack to end of word 
213b			 
213b				STACKFRAME ON $1efe $2f9f 
213b				if DEBUG_STACK_IMB 
213b					if ON 
213b						exx 
213b						ld de, $1efe 
213b						ld a, d 
213b						ld hl, curframe 
213b						call hexout 
213b						ld a, e 
213b						ld hl, curframe+2 
213b						call hexout 
213b						ld hl, $1efe 
213b						push hl 
213b						ld hl, $2f9f 
213b						push hl 
213b						exx 
213b					endif 
213b				endif 
213b			endm 
# End of macro STACKFRAME
213b			 
213b 2a c8 e5		ld hl,(os_tok_ptr) 
213e cd ef 1d		call forth_apush 
2141			 
2141				STACKFRAMECHK ON $1efe $2f9f 
2141				if DEBUG_STACK_IMB 
2141					if ON 
2141						exx 
2141						ld hl, $2f9f 
2141						pop de   ; $2f9f 
2141						call cmp16 
2141						jr nz, .spnosame 
2141						ld hl, $1efe 
2141						pop de   ; $1efe 
2141						call cmp16 
2141						jr z, .spfrsame 
2141						.spnosame: call showsperror 
2141						.spfrsame: nop 
2141						exx 
2141					endif 
2141				endif 
2141			endm 
# End of macro STACKFRAMECHK
2141			 
2141			execnext: 
2141			 
2141			if DEBUG_FORTH_PARSE_KEY 
2141						DMARK "KY>" 
2141			endif 
2141			; move past token to next word 
2141			 
2141 2a c8 e5		ld hl, (os_tok_ptr) 
2144 3e 00		ld a, 0 
2146 01 ff 00		ld bc, 255     ; input buffer size 
2149 ed b1		cpir 
214b			 
214b			if DEBUG_FORTH_PARSE_KEY 
214b						DMARK "KY!" 
214b				CALLMONITOR 
214b			endif	 
214b			; TODO this might place hl on the null, so will need to forward on??? 
214b			;inc hl   ; see if this gets onto the next item 
214b			 
214b			 
214b			; TODO pass a pointer to the buffer to push 
214b			; TODO call function to push 
214b			 
214b			; look for end of input 
214b			 
214b			;inc hl 
214b			;ld a,(hl) 
214b			;cp FORTH_END_BUFFER 
214b			;ret z 
214b			 
214b			 
214b c3 c4 20		jp exec1 
214e			 
214e			 
214e			 
214e			 
214e			 
214e			 
214e			 
214e			 
214e			 
214e			findnexttok: 
214e			 
214e				; hl is pointer to move 
214e				; de is the token to locate 
214e			 
214e					if DEBUG_FORTH 
214e						DMARK "NTK" 
214e						CALLMONITOR 
214e					endif 
214e d5				push de 
214f			 
214f			.fnt1:	 
214f				; find first char of token to locate 
214f			 
214f 1a				ld a, (de) 
2150 4f				ld c,a 
2151 7e				ld a,(hl) 
2152 cd 3c 12			call toUpper 
2155					if DEBUG_FORTH 
2155						DMARK "NT1" 
2155						CALLMONITOR 
2155					endif 
2155 b9				cp c 
2156			 
2156 28 03			jr z, .fnt2cmpmorefirst	 
2158			 
2158				; first char not found move to next char 
2158			 
2158 23				inc hl 
2159 18 f4			jr .fnt1 
215b			 
215b			.fnt2cmpmorefirst:	 
215b				; first char of token found.  
215b			 
215b e5				push hl     ; save start of token just in case it is the right one 
215c d9				exx 
215d e1				pop hl        ; save it to hl' 
215e d9				exx 
215f			 
215f			 
215f			.fnt2cmpmore:	 
215f				; compare the rest 
215f				 
215f 23				inc hl 
2160 13				inc de 
2161				 
2161 1a				ld a, (de) 
2162 4f				ld c,a 
2163 7e				ld a,(hl) 
2164 cd 3c 12			call toUpper 
2167			 
2167					if DEBUG_FORTH 
2167						DMARK "NT2" 
2167						CALLMONITOR 
2167					endif 
2167				; c has the token to find char 
2167				; a has the mem to scan char 
2167			 
2167 b9				cp c 
2168 28 04			jr z,.fntmatch1 
216a			 
216a				; they are not the same 
216a			 
216a					if DEBUG_FORTH 
216a						DMARK "NT3" 
216a						CALLMONITOR 
216a					endif 
216a d1				pop de	; reset de token to look for 
216b d5				push de 
216c 18 e1			jr .fnt1 
216e				 
216e			.fntmatch1: 
216e			 
216e				; is the same char a null which means we might have a full hit? 
216e					if DEBUG_FORTH 
216e						DMARK "NT4" 
216e						CALLMONITOR 
216e					endif 
216e			 
216e fe 00			cp 0 
2170 28 0b			jr z, .fntmatchyes 
2172			 
2172				; are we at the end of the token to find? 
2172			 
2172					if DEBUG_FORTH 
2172						DMARK "NT5" 
2172						CALLMONITOR 
2172					endif 
2172 3e 00			ld a, 0 
2174 b9				cp c 
2175			 
2175 c2 5f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2178			 
2178					if DEBUG_FORTH 
2178						DMARK "NT6" 
2178						CALLMONITOR 
2178					endif 
2178				; token to find is exhusted but no match to stream 
2178			 
2178				; restore tok pointer and continue on 
2178 d1				pop de 
2179 d5				push de 
217a c3 4f 21			jp .fnt1 
217d			 
217d			 
217d			.fntmatchyes: 
217d			 
217d				; hl now contains the end of the found token 
217d			 
217d				; get rid of saved token pointer to find 
217d			 
217d d1				pop de 
217e			 
217e					if DEBUG_FORTH 
217e						DMARK "NT9" 
217e						CALLMONITOR 
217e					endif 
217e			 
217e				; hl will be on the null term so forward on 
217e			 
217e				; get back the saved start of the token 
217e			 
217e d9				exx 
217f e5				push hl     ; save start of token just in case it is the right one 
2180 d9				exx 
2181 e1				pop hl        ; save it to hl 
2182			 
2182 c9				ret 
2183			 
2183			 
2183			; LIST needs to find a specific token   
2183			; FORGET needs to find a spefici token 
2183			 
2183			; SAVE needs to find all tokens by flag 
2183			; WORDS just needs to scan through all  by flag 
2183			; UWORDS needs to scan through all by flag 
2183			 
2183			 
2183			; given hl as pointer to start of dict look up string 
2183			; return hl as pointer to start of word block 
2183			; or 0 if not found 
2183			 
2183			forth_find_tok: 
2183 c9				ret 
2184			 
2184			; given hl as pointer to dict structure 
2184			; move to the next dict block structure 
2184			 
2184			forth_tok_next: 
2184				; hl now points to the address of the next word pointer  
2184				; TODO skip compiled symbol for now 
2184			;	push de 
2184 23				inc hl 
2185 5e				ld e, (hl) 
2186 23				inc hl 
2187 56				ld d, (hl) 
2188 23				inc hl 
2189			 
2189 eb				ex de,hl 
218a			if DEBUG_FORTH_PARSE_NEXTWORD 
218a				push bc 
218a				ld bc, (cli_nextword) 
218a						DMARK "NXW" 
218a				CALLMONITOR 
218a				pop bc 
218a			endif 
218a			;	pop de	 
218a c9				ret 
218b			 
218b			 
218b			 
218b			; eof 
# End of file forth_parserv5.asm
218b				include "forth_wordsv4.asm" 
218b			 
218b			; the core word dictionary v4 
218b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
218b			 
218b			; this is a linked list for each of the system words used 
218b			; user defined words will follow the same format but will be in ram 
218b			 
218b			 
218b			; 
218b			; 
218b			; define linked list: 
218b			; 
218b			; 1. compiled byte op code 
218b			; 2. len of text word 
218b			; 3. text word 
218b			; 4. ptr to next dictionary word 
218b			; 5. asm, calls etc for the word 
218b			; 
218b			;  if 1 == 0 then last word in dict  
218b			;   
218b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
218b			;  
218b			;  
218b			; create basic standard set of words 
218b			; 
218b			;  
218b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
218b			; 2DUP 2DROP 2SWAP  
218b			; @ C@ - get byte  
218b			; ! C! - store byte 
218b			; 0< true if less than zero 
218b			; 0= true if zero 
218b			; < >  
218b			; = true if same 
218b			; variables 
218b			 
218b			 
218b			; Hardware specific words I may need 
218b			; 
218b			; IN OUT  
218b			; calls to key util functions 
218b			; calls to hardward abstraction stuff 
218b			; easy control of frame buffers and lcd i/o 
218b			; keyboard  
218b			 
218b			 
218b			;DICT: macro 
218b			; op_code, len, word, next 
218b			;    word: 
218b			;    db op_code 
218b			;    ds word zero term 
218b			;    dw next 
218b			;    endm 
218b			 
218b			 
218b			 
218b			 
218b			; op code 1 is a flag for user define words which are to be handled differently 
218b			 
218b			 
218b			; 
218b			; 
218b			;    TODO on entry to a word this should be the expected environment 
218b			;    hl - tos value if number then held, if string this is the ptr 
218b			;    de -  
218b			 
218b			 
218b			; opcode ranges 
218b			; 0 - end of word dict 
218b			; 255 - user define words 
218b			 
218b			sysdict: 
218b			include "forth_opcodes.asm" 
218b			; op codes for forth keywords 
218b			; free to use code 0  
218b				OPCODE_HEAP: equ  1 
218b				OPCODE_EXEC: equ 2 
218b				OPCODE_DUP: equ 3 
218b				OPCODE_SWAP: equ 4 
218b				OPCODE_COLN: equ 5 
218b				OPCODE_SCOLN: equ 6 
218b				OPCODE_DROP: equ 7 
218b				OPCODE_DUP2: equ 8 
218b				OPCODE_DROP2: equ 9 
218b				OPCODE_SWAP2: equ 10 
218b				OPCODE_AT: equ 11 
218b				OPCODE_CAT: equ 12 
218b				OPCODE_BANG: equ 13 
218b				OPCODE_CBANG: equ 14 
218b				OPCODE_SCALL: equ 15 
218b				OPCODE_DEPTH: equ 16 
218b				OPCODE_OVER: equ 17 
218b				OPCODE_PAUSE: equ 18 
218b				OPCODE_PAUSES: equ 19 
218b				OPCODE_ROT: equ 20 
218b			;free to reuse	OPCODE_WORDS: equ 21 
218b			        OPCODE_NOT: equ 21 
218b				OPCODE_UWORDS: equ 22 
218b				OPCODE_BP: equ 23 
218b				OPCODE_MONITOR: equ 24  
218b				OPCODE_MALLOC: equ 25 
218b				OPCODE_FREE: equ 26 
218b				OPCODE_LIST: equ 27 
218b				OPCODE_FORGET: equ 28 
218b				OPCODE_NOP: equ 29 
218b				OPCODE_COMO: equ 30 
218b				OPCODE_COMC: equ 31 
218b			;free to reuse	OPCODE_ENDCORE: equ 32 
218b				OPCODE_AFTERSOUND: equ 33 
218b				OPCODE_GP2: equ 34 
218b				OPCODE_GP3: equ 35 
218b				OPCODE_GP4: equ 36 
218b				OPCODE_SIN: equ 37 
218b				OPCODE_SOUT: equ 38 
218b				OPCODE_SPIO: equ 39 
218b				OPCODE_SPICEH: equ 40 
218b				OPCODE_SPIOb: equ 41 
218b				OPCODE_SPII: equ 42 
218b				OPCODE_SESEL: equ 43 
218b				OPCODE_CARTDEV: equ 44 
218b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
218b				OPCODE_FB: equ 46 
218b				OPCODE_EMIT: equ 47 
218b				OPCODE_DOTH: equ 48 
218b				OPCODE_DOTF: equ 49 
218b				OPCODE_DOT: equ 50 
218b				OPCODE_CLS: equ 51 
218b				OPCODE_DRAW: equ 52 
218b				OPCODE_DUMP: equ 53 
218b				OPCODE_CDUMP: equ 54 
218b				OPCODE_DAT: equ 55 
218b				OPCODE_HOME: equ 56 
218b				OPCODE_SPACE: equ 57 
218b				OPCODE_SPACES: equ 58 
218b				OPCODE_SCROLL: equ 59 
218b				OPCODE_ATQ: equ 60 
218b				OPCODE_AUTODSP: equ 61 
218b				OPCODE_MENU: equ 62 
218b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
218b				OPCODE_THEN: equ 64 
218b				OPCODE_ELSE: equ 65 
218b				OPCODE_DO: equ 66 
218b				OPCODE_LOOP: equ 67 
218b				OPCODE_I: equ 68 
218b				OPCODE_DLOOP: equ 69  
218b				OPCODE_REPEAT: equ 70  
218b				OPCODE_UNTIL: equ 71 
218b				OPCODE_ENDFLOW: equ 72 
218b				OPCODE_WAITK: equ 73 
218b				OPCODE_ACCEPT: equ 74 
218b				OPCODE_EDIT: equ 75 
218b			;free to reuse	OPCODE_ENDKEY: equ 76 
218b				OPCODE_LZERO: equ 77 
218b				OPCODE_TZERO: equ 78 
218b				OPCODE_LESS: equ 79 
218b				OPCODE_GT: equ 80 
218b				OPCODE_EQUAL: equ 81  
218b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
218b				OPCODE_NEG: equ 83 
218b				OPCODE_DIV: equ 84 
218b				OPCODE_MUL: equ 85 
218b				OPCODE_MIN: equ 86 
218b				OPCODE_MAX: equ 87 
218b				OPCODE_RND16: equ 88 
218b				OPCODE_RND8: equ 89 
218b				OPCODE_RND: equ 90 
218b			;free to reuse	OPCODE_ENDMATHS: equ 91  
218b				OPCODE_BYNAME: equ 92 
218b				OPCODE_DIR: equ 93 
218b				OPCODE_SAVE: equ 94 
218b				OPCODE_LOAD: equ 95 
218b				OPCODE_BSAVE: equ 96 
218b				OPCODE_BLOAD: equ 97 
218b				OPCODE_SEO: equ 98  
218b				OPCODE_SEI: equ 99 
218b				OPCODE_SFREE: equ 100 
218b				OPCODE_SIZE: equ 101 
218b				OPCODE_CREATE: equ 102 
218b				OPCODE_APPEND: equ 103 
218b				OPCODE_SDEL: equ 104 
218b				OPCODE_OPEN: equ 105 
218b				OPCODE_READ: equ 106 
218b				OPCODE_EOF: equ 106 
218b				OPCODE_FORMAT: equ 107 
218b				OPCODE_LABEL: equ 108 
218b				OPCODE_LABELS: equ 109 
218b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
218b				OPCODE_UPPER: equ 111 
218b				OPCODE_LOWER: equ 112 
218b				OPCODE_SUBSTR: equ 113 
218b				OPCODE_LEFT: equ 114 
218b				OPCODE_RIGHT: equ 115 
218b				OPCODE_STR2NUM: equ 116 
218b				OPCODE_NUM2STR: equ 117 
218b				OPCODE_CONCAT: equ 118 
218b				OPCODE_FIND: equ 119 
218b				OPCODE_LEN: equ 120 
218b				OPCODE_CHAR: equ 121 
218b			; free to reuse	OPCODE_STRLEN: equ 122 
218b			; free to reuse	OPCODE_ENDSTR: equ 123 
218b				OPCODE_V0S: equ 124 
218b				OPCODE_V0Q: equ 125 
218b				OPCODE_V1S: equ 126 
218b				OPCODE_V1Q: equ 127 
218b				OPCODE_V2S: equ 128 
218b				OPCODE_V2Q: equ 129 
218b				OPCODE_V3S: equ 130 
218b				OPCODE_V3Q: equ 131 
218b			;free to reuse	OPCODE_END: equ 132 
218b				OPCODE_ZDUP: equ 133 
218b			 
218b			; eof 
# End of file forth_opcodes.asm
218b			 
218b			include "forth_words_core.asm" 
218b			 
218b			; | ## Core Words 
218b			 
218b			;if MALLOC_4 
218b			 
218b			.HEAP: 
218b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
218b 15				db WORD_SYS_CORE+OPCODE_HEAP             
218c ca 21			dw .EXEC            
218e 05				db 4 + 1 
218f .. 00			db "HEAP",0              
2194				endm 
# End of macro CWHEAD
2194			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2194			; | | u1 - Current number of bytes in the heap 
2194			; | | u2 - Remaining bytes left on the heap 
2194			; | |  
2194			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2194			 
2194			 
2194					if DEBUG_FORTH_WORDS_KEY 
2194						DMARK "HEP" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 71 ee			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 72 ee			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 73 ee			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "HEP"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad						CALLMONITOR 
21ad cd e8 15			call break_point_state  
21b0				endm  
# End of macro CALLMONITOR
21b0					endif 
21b0 2a ea 64				ld hl, (free_list )      
21b3 11 ef 64				ld de, heap_start 
21b6			 
21b6 ed 52				sbc hl, de  
21b8			 
21b8 cd 86 1c				call forth_push_numhl 
21bb			 
21bb			 
21bb ed 5b ea 64			ld de, (free_list )      
21bf 21 ad e2				ld hl, heap_end 
21c2			 
21c2 ed 52				sbc hl, de 
21c4			 
21c4 cd 86 1c				call forth_push_numhl 
21c7					 
21c7			 
21c7					 
21c7			 
21c7			 
21c7			 
21c7					NEXTW 
21c7 c3 33 20			jp macro_next 
21ca				endm 
# End of macro NEXTW
21ca			;endif 
21ca			 
21ca			.EXEC: 
21ca			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21ca			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21ca			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21ca			;; > > 
21ca			;; > >   
21ca			;	STACKFRAME OFF $5efe $5f9f 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS_KEY 
21ca			;			DMARK "EXE" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			;	FORTH_DSP_VALUEHL 
21ca			; 
21ca			;	FORTH_DSP_POP 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX1" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;;	ld e,(hl) 
21ca			;;	inc hl 
21ca			;;	ld d,(hl) 
21ca			;;	ex de,hl 
21ca			; 
21ca			;;		if DEBUG_FORTH_WORDS 
21ca			;;			DMARK "EX2" 
21ca			;;			CALLMONITOR 
21ca			;;		endif 
21ca			;	push hl 
21ca			; 
21ca			;	;ld a, 0 
21ca			;	;ld a, FORTH_END_BUFFER 
21ca			;	call strlenz 
21ca			;	inc hl   ; include zero term to copy 
21ca			;	inc hl   ; include term 
21ca			;	inc hl   ; include term 
21ca			;	ld b,0 
21ca			;	ld c,l 
21ca			;	pop hl 
21ca			;	ld de, execscratch 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX3" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	ldir 
21ca			; 
21ca			; 
21ca			;	ld hl, execscratch 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EXe" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			;	call forthparse 
21ca			;	call forthexec 
21ca			;;	call forthexec_cleanup 
21ca			;;	call forthparse 
21ca			;;	call forthexec 
21ca			; 
21ca			;	STACKFRAMECHK OFF $5efe $5f9f 
21ca			; 
21ca			;	; an immediate word so no need to process any more words 
21ca			;	ret 
21ca			;	NEXTW 
21ca			 
21ca			; dead code - old version  
21ca			;	FORTH_RSP_NEXT 
21ca			 
21ca			;  
21ca			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21ca			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21ca			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21ca			;	push hl 
21ca			;	push de 
21ca			;	push bc 
21ca			; 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS_KEY 
21ca			;			DMARK "EXR" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			; 
21ca			; 
21ca			;	;v5 FORTH_DSP_VALUE 
21ca			;	FORTH_DSP_VALUEHL 
21ca			; 
21ca			;	; TODO do string type checks 
21ca			; 
21ca			;;v5	inc hl   ; skip type 
21ca			; 
21ca			;	push hl  ; source code  
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX1" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	ld a, 0 
21ca			;	call strlent 
21ca			; 
21ca			;	inc hl 
21ca			;	inc hl 
21ca			;	inc hl 
21ca			;	inc hl 
21ca			; 
21ca			;	push hl    ; size 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX2" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	call malloc 
21ca			; 
21ca			;	ex de, hl    ; de now contains malloc area 
21ca			;	pop bc   	; get byte count 
21ca			;	pop hl      ; get string to copy 
21ca			; 
21ca			;	push de     ; save malloc for free later 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX3" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	ldir       ; duplicate string 
21ca			; 
21ca			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21ca			;	 
21ca			;	; TODO fix the parse would be better than this...  
21ca			;	ex de, hl 
21ca			;	dec hl 
21ca			;	ld a, 0 
21ca			;	ld (hl), a 
21ca			;	dec hl 
21ca			;	ld a, ' ' 
21ca			;	ld (hl), a 
21ca			;	dec hl 
21ca			;	ld (hl), a 
21ca			; 
21ca			;	dec hl 
21ca			;	ld (hl), a 
21ca			; 
21ca			; 
21ca			;	FORTH_DSP_POP  
21ca			; 
21ca			;	pop hl     
21ca			;	push hl    ; save malloc area 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX4" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			;	call forthparse 
21ca			;	call forthexec 
21ca			;	 
21ca			;	pop hl 
21ca			;	if DEBUG_FORTH_WORDS 
21ca			;		DMARK "EX5" 
21ca			;		CALLMONITOR 
21ca			;	endif 
21ca			; 
21ca			;	if FORTH_ENABLE_FREE 
21ca			;	call free 
21ca			;	endif 
21ca			; 
21ca			;	if DEBUG_FORTH_WORDS 
21ca			;		DMARK "EX6" 
21ca			;		CALLMONITOR 
21ca			;	endif 
21ca			; 
21ca			;	pop bc 
21ca			;	pop de 
21ca			;	pop hl 
21ca			;;	FORTH_RSP_POP	  
21ca			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21ca			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21ca			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21ca			; 
21ca			;	if DEBUG_FORTH_WORDS 
21ca			;		DMARK "EX7" 
21ca			;		CALLMONITOR 
21ca			;	endif 
21ca			;	NEXTW 
21ca			 
21ca			;.STKEXEC: 
21ca			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21ca			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21ca			; 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS_KEY 
21ca			;			DMARK "STX" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			;	FORTH_DSP_VALUEHL 
21ca			; 
21ca			;	ld (store_tmp1), hl    ; count 
21ca			; 
21ca			;	FORTH_DSP_POP 
21ca			;.stkexec1: 
21ca			;	ld hl, (store_tmp1)   ; count 
21ca			;	ld a, 0 
21ca			;	cp l 
21ca			;	ret z 
21ca			; 
21ca			;	dec hl 
21ca			;	ld (store_tmp1), hl    ; count 
21ca			;	 
21ca			;	FORTH_DSP_VALUEHL 
21ca			;	push hl 
21ca			;	 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EXp" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	FORTH_DSP_POP 
21ca			; 
21ca			;	call strlenz 
21ca			;	inc hl   ; include zero term to copy 
21ca			;	inc hl   ; include zero term to copy 
21ca			;	inc hl   ; include zero term to copy 
21ca			;	ld b,0 
21ca			;	ld c,l 
21ca			;	pop hl 
21ca			;	ld de, execscratch 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EX3" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	ldir 
21ca			; 
21ca			; 
21ca			;	ld hl, execscratch 
21ca			; 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EXP" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			; 
21ca			;	call forthparse 
21ca			;	ld hl, execscratch 
21ca			;		if DEBUG_FORTH_WORDS 
21ca			;			DMARK "EXx" 
21ca			;			CALLMONITOR 
21ca			;		endif 
21ca			;	call forthexec 
21ca			; 
21ca			;	jp .stkexec1 
21ca			; 
21ca			;	ret 
21ca			 
21ca			 
21ca			.DUP: 
21ca				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21ca 17				db WORD_SYS_CORE+OPCODE_DUP             
21cb 40 22			dw .ZDUP            
21cd 04				db 3 + 1 
21ce .. 00			db "DUP",0              
21d2				endm 
# End of macro CWHEAD
21d2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21d2			 
21d2					if DEBUG_FORTH_WORDS_KEY 
21d2						DMARK "DUP" 
21d2 f5				push af  
21d3 3a e7 21			ld a, (.dmark)  
21d6 32 71 ee			ld (debug_mark),a  
21d9 3a e8 21			ld a, (.dmark+1)  
21dc 32 72 ee			ld (debug_mark+1),a  
21df 3a e9 21			ld a, (.dmark+2)  
21e2 32 73 ee			ld (debug_mark+2),a  
21e5 18 03			jr .pastdmark  
21e7 ..			.dmark: db "DUP"  
21ea f1			.pastdmark: pop af  
21eb			endm  
# End of macro DMARK
21eb						CALLMONITOR 
21eb cd e8 15			call break_point_state  
21ee				endm  
# End of macro CALLMONITOR
21ee					endif 
21ee			 
21ee					FORTH_DSP 
21ee cd 43 1e			call macro_forth_dsp 
21f1				endm 
# End of macro FORTH_DSP
21f1			 
21f1 7e					ld a, (HL) 
21f2 fe 01				cp DS_TYPE_STR 
21f4 20 25				jr nz, .dupinum 
21f6			 
21f6					; push another string 
21f6			 
21f6					FORTH_DSP_VALUEHL     		 
21f6 cd 7d 1e			call macro_dsp_valuehl 
21f9				endm 
# End of macro FORTH_DSP_VALUEHL
21f9			 
21f9				if DEBUG_FORTH_WORDS 
21f9					DMARK "DUs" 
21f9 f5				push af  
21fa 3a 0e 22			ld a, (.dmark)  
21fd 32 71 ee			ld (debug_mark),a  
2200 3a 0f 22			ld a, (.dmark+1)  
2203 32 72 ee			ld (debug_mark+1),a  
2206 3a 10 22			ld a, (.dmark+2)  
2209 32 73 ee			ld (debug_mark+2),a  
220c 18 03			jr .pastdmark  
220e ..			.dmark: db "DUs"  
2211 f1			.pastdmark: pop af  
2212			endm  
# End of macro DMARK
2212					CALLMONITOR 
2212 cd e8 15			call break_point_state  
2215				endm  
# End of macro CALLMONITOR
2215				endif 
2215 cd f4 1c				call forth_push_str 
2218			 
2218					NEXTW 
2218 c3 33 20			jp macro_next 
221b				endm 
# End of macro NEXTW
221b			 
221b			 
221b			.dupinum: 
221b					 
221b			 
221b			 
221b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
221b cd 7d 1e			call macro_dsp_valuehl 
221e				endm 
# End of macro FORTH_DSP_VALUEHL
221e			 
221e				; TODO add floating point number detection 
221e			 
221e				if DEBUG_FORTH_WORDS 
221e					DMARK "DUi" 
221e f5				push af  
221f 3a 33 22			ld a, (.dmark)  
2222 32 71 ee			ld (debug_mark),a  
2225 3a 34 22			ld a, (.dmark+1)  
2228 32 72 ee			ld (debug_mark+1),a  
222b 3a 35 22			ld a, (.dmark+2)  
222e 32 73 ee			ld (debug_mark+2),a  
2231 18 03			jr .pastdmark  
2233 ..			.dmark: db "DUi"  
2236 f1			.pastdmark: pop af  
2237			endm  
# End of macro DMARK
2237					CALLMONITOR 
2237 cd e8 15			call break_point_state  
223a				endm  
# End of macro CALLMONITOR
223a				endif 
223a			 
223a cd 86 1c				call forth_push_numhl 
223d					NEXTW 
223d c3 33 20			jp macro_next 
2240				endm 
# End of macro NEXTW
2240			.ZDUP: 
2240				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2240 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2241 78 22			dw .SWAP            
2243 05				db 4 + 1 
2244 .. 00			db "?DUP",0              
2249				endm 
# End of macro CWHEAD
2249			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2249			 
2249					if DEBUG_FORTH_WORDS_KEY 
2249						DMARK "qDU" 
2249 f5				push af  
224a 3a 5e 22			ld a, (.dmark)  
224d 32 71 ee			ld (debug_mark),a  
2250 3a 5f 22			ld a, (.dmark+1)  
2253 32 72 ee			ld (debug_mark+1),a  
2256 3a 60 22			ld a, (.dmark+2)  
2259 32 73 ee			ld (debug_mark+2),a  
225c 18 03			jr .pastdmark  
225e ..			.dmark: db "qDU"  
2261 f1			.pastdmark: pop af  
2262			endm  
# End of macro DMARK
2262						CALLMONITOR 
2262 cd e8 15			call break_point_state  
2265				endm  
# End of macro CALLMONITOR
2265					endif 
2265					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2265 cd 7d 1e			call macro_dsp_valuehl 
2268				endm 
# End of macro FORTH_DSP_VALUEHL
2268			 
2268 e5					push hl 
2269			 
2269					; is it a zero? 
2269			 
2269 3e 00				ld a, 0 
226b 84					add h 
226c 85					add l 
226d			 
226d e1					pop hl 
226e			 
226e fe 00				cp 0 
2270 28 03				jr z, .dup2orig 
2272			 
2272			 
2272 cd 86 1c				call forth_push_numhl 
2275			 
2275			 
2275				; TODO add floating point number detection 
2275			 
2275			.dup2orig: 
2275			 
2275					NEXTW 
2275 c3 33 20			jp macro_next 
2278				endm 
# End of macro NEXTW
2278			.SWAP: 
2278				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2278 18				db WORD_SYS_CORE+OPCODE_SWAP             
2279 b7 22			dw .COLN            
227b 05				db 4 + 1 
227c .. 00			db "SWAP",0              
2281				endm 
# End of macro CWHEAD
2281			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2281					if DEBUG_FORTH_WORDS_KEY 
2281						DMARK "SWP" 
2281 f5				push af  
2282 3a 96 22			ld a, (.dmark)  
2285 32 71 ee			ld (debug_mark),a  
2288 3a 97 22			ld a, (.dmark+1)  
228b 32 72 ee			ld (debug_mark+1),a  
228e 3a 98 22			ld a, (.dmark+2)  
2291 32 73 ee			ld (debug_mark+2),a  
2294 18 03			jr .pastdmark  
2296 ..			.dmark: db "SWP"  
2299 f1			.pastdmark: pop af  
229a			endm  
# End of macro DMARK
229a						CALLMONITOR 
229a cd e8 15			call break_point_state  
229d				endm  
# End of macro CALLMONITOR
229d					endif 
229d			 
229d					FORTH_DSP_VALUEHL 
229d cd 7d 1e			call macro_dsp_valuehl 
22a0				endm 
# End of macro FORTH_DSP_VALUEHL
22a0 e5					push hl     ; w2 
22a1			 
22a1					FORTH_DSP_POP 
22a1 cd 35 1f			call macro_forth_dsp_pop 
22a4				endm 
# End of macro FORTH_DSP_POP
22a4			 
22a4					FORTH_DSP_VALUEHL 
22a4 cd 7d 1e			call macro_dsp_valuehl 
22a7				endm 
# End of macro FORTH_DSP_VALUEHL
22a7			 
22a7					FORTH_DSP_POP 
22a7 cd 35 1f			call macro_forth_dsp_pop 
22aa				endm 
# End of macro FORTH_DSP_POP
22aa			 
22aa d1					pop de     ; w2	, hl = w1 
22ab			 
22ab eb					ex de, hl 
22ac d5					push de 
22ad			 
22ad cd 86 1c				call forth_push_numhl 
22b0			 
22b0 e1					pop hl 
22b1			 
22b1 cd 86 1c				call forth_push_numhl 
22b4					 
22b4			 
22b4					NEXTW 
22b4 c3 33 20			jp macro_next 
22b7				endm 
# End of macro NEXTW
22b7			.COLN: 
22b7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22b7 19				db WORD_SYS_CORE+OPCODE_COLN             
22b8 43 24			dw .SCOLN            
22ba 02				db 1 + 1 
22bb .. 00			db ":",0              
22bd				endm 
# End of macro CWHEAD
22bd			; | : ( -- )         Create new word | DONE 
22bd			 
22bd					if DEBUG_FORTH_WORDS_KEY 
22bd						DMARK "CLN" 
22bd f5				push af  
22be 3a d2 22			ld a, (.dmark)  
22c1 32 71 ee			ld (debug_mark),a  
22c4 3a d3 22			ld a, (.dmark+1)  
22c7 32 72 ee			ld (debug_mark+1),a  
22ca 3a d4 22			ld a, (.dmark+2)  
22cd 32 73 ee			ld (debug_mark+2),a  
22d0 18 03			jr .pastdmark  
22d2 ..			.dmark: db "CLN"  
22d5 f1			.pastdmark: pop af  
22d6			endm  
# End of macro DMARK
22d6						CALLMONITOR 
22d6 cd e8 15			call break_point_state  
22d9				endm  
# End of macro CALLMONITOR
22d9					endif 
22d9				STACKFRAME OFF $8efe $989f 
22d9				if DEBUG_STACK_IMB 
22d9					if OFF 
22d9						exx 
22d9						ld de, $8efe 
22d9						ld a, d 
22d9						ld hl, curframe 
22d9						call hexout 
22d9						ld a, e 
22d9						ld hl, curframe+2 
22d9						call hexout 
22d9						ld hl, $8efe 
22d9						push hl 
22d9						ld hl, $989f 
22d9						push hl 
22d9						exx 
22d9					endif 
22d9				endif 
22d9			endm 
# End of macro STACKFRAME
22d9				; get parser buffer length  of new word 
22d9			 
22d9				 
22d9			 
22d9					; move tok past this to start of name defintition 
22d9					; TODO get word to define 
22d9					; TODO Move past word token 
22d9					; TODO get length of string up to the ';' 
22d9			 
22d9 2a c8 e5			ld hl, (os_tok_ptr) 
22dc 23				inc hl 
22dd 23				inc hl 
22de			 
22de 3e 3b			ld a, ';' 
22e0 cd 50 12			call strlent 
22e3			 
22e3 7d				ld a,l 
22e4 32 c3 e2			ld (os_new_parse_len), a 
22e7			 
22e7			 
22e7			if DEBUG_FORTH_UWORD 
22e7 ed 5b c8 e5		ld de, (os_tok_ptr) 
22eb						DMARK ":01" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 71 ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 72 ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 73 ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db ":01"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304				CALLMONITOR 
2304 cd e8 15			call break_point_state  
2307				endm  
# End of macro CALLMONITOR
2307			endif 
2307			 
2307			; 
2307			;  new word memory layout: 
2307			;  
2307			;    : adg 6666 ;  
2307			; 
2307			;    db   1     ; user defined word  
2307 23				inc hl    
2308			;    dw   sysdict 
2308 23				inc hl 
2309 23				inc hl 
230a			;    db <word len>+1 (for null) 
230a 23				inc hl 
230b			;    db .... <word> 
230b			; 
230b			 
230b 23				inc hl    ; some extras for the word preamble before the above 
230c 23				inc hl 
230d 23				inc hl 
230e 23				inc hl 
230f 23				inc hl 
2310 23				inc hl 
2311 23				inc hl  
2312 23				inc hl 
2313 23				inc hl 
2314 23				inc hl 
2315 23				inc hl 
2316 23				inc hl 
2317 23				inc hl 
2318 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2319			;       exec word buffer 
2319			;	<ptr word>   
2319 23				inc hl 
231a 23				inc hl 
231b			;       <word list><null term> 7F final term 
231b			 
231b			 
231b			if DEBUG_FORTH_UWORD 
231b						DMARK ":02" 
231b f5				push af  
231c 3a 30 23			ld a, (.dmark)  
231f 32 71 ee			ld (debug_mark),a  
2322 3a 31 23			ld a, (.dmark+1)  
2325 32 72 ee			ld (debug_mark+1),a  
2328 3a 32 23			ld a, (.dmark+2)  
232b 32 73 ee			ld (debug_mark+2),a  
232e 18 03			jr .pastdmark  
2330 ..			.dmark: db ":02"  
2333 f1			.pastdmark: pop af  
2334			endm  
# End of macro DMARK
2334				CALLMONITOR 
2334 cd e8 15			call break_point_state  
2337				endm  
# End of macro CALLMONITOR
2337			endif 
2337			 
2337				 
2337					; malloc the size 
2337			 
2337 cd ae 12				call malloc 
233a 22 c5 e2				ld (os_new_malloc), hl     ; save malloc start 
233d			 
233d			;    db   1     ; user defined word  
233d 3e 01				ld a, WORD_SYS_UWORD  
233f 77					ld (hl), a 
2340				 
2340 23				inc hl    
2341			;    dw   sysdict 
2341 11 8b 21			ld de, sysdict       ; continue on with the scan to the system dict 
2344 73				ld (hl), e 
2345 23				inc hl 
2346 72				ld (hl), d 
2347 23				inc hl 
2348			 
2348			 
2348			;    Setup dict word 
2348			 
2348 23				inc hl 
2349 22 bf e2			ld (os_new_work_ptr), hl     ; save start of dict word  
234c			 
234c				; 1. get length of dict word 
234c			 
234c			 
234c 2a c8 e5			ld hl, (os_tok_ptr) 
234f 23				inc hl 
2350 23				inc hl    ; position to start of dict word 
2351 3e 00			ld a, 0 
2353 cd 50 12			call strlent 
2356			 
2356			 
2356 23				inc hl    ; to include null??? 
2357			 
2357				; write length of dict word 
2357			 
2357 ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
235b 1b				dec de 
235c eb				ex de, hl 
235d 73				ld (hl), e 
235e eb				ex de, hl 
235f			 
235f				 
235f			 
235f				; copy  
235f 4d				ld c, l 
2360 06 00			ld b, 0 
2362 ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2366 2a c8 e5			ld hl, (os_tok_ptr) 
2369 23				inc hl 
236a 23				inc hl    ; position to start of dict word 
236b				 
236b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
236b				 
236b				; TODO need to convert word to upper case 
236b			 
236b			ucasetok:	 
236b 7e				ld a,(hl) 
236c cd 3c 12			call toUpper 
236f 77				ld (hl),a 
2370 ed a0			ldi 
2372 f2 6b 23		 	jp p, ucasetok 
2375			 
2375			 
2375			 
2375				; de now points to start of where the word body code should be placed 
2375 ed 53 bf e2		ld (os_new_work_ptr), de 
2379				; hl now points to the words to throw at forthexec which needs to be copied 
2379 22 bd e2			ld (os_new_src_ptr), hl 
237c			 
237c				; TODO add 'call to forthexec' 
237c			 
237c			if DEBUG_FORTH_UWORD 
237c c5				push bc 
237d ed 4b c5 e2		ld bc, (os_new_malloc) 
2381						DMARK ":0x" 
2381 f5				push af  
2382 3a 96 23			ld a, (.dmark)  
2385 32 71 ee			ld (debug_mark),a  
2388 3a 97 23			ld a, (.dmark+1)  
238b 32 72 ee			ld (debug_mark+1),a  
238e 3a 98 23			ld a, (.dmark+2)  
2391 32 73 ee			ld (debug_mark+2),a  
2394 18 03			jr .pastdmark  
2396 ..			.dmark: db ":0x"  
2399 f1			.pastdmark: pop af  
239a			endm  
# End of macro DMARK
239a				CALLMONITOR 
239a cd e8 15			call break_point_state  
239d				endm  
# End of macro CALLMONITOR
239d c1				pop bc 
239e			endif 
239e			 
239e			 
239e				; create word preamble which should be: 
239e			 
239e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
239e			 
239e				;    ld hl, <word code> 
239e				;    jp user_exec 
239e			        ;    <word code bytes> 
239e			 
239e			 
239e			;	inc de     ; TODO ??? or are we already past the word's null 
239e eb				ex de, hl 
239f			 
239f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23a1			 
23a1 23				inc hl 
23a2 22 b9 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23a5 23				inc hl 
23a6			 
23a6 23				inc hl 
23a7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23a9			 
23a9 01 6c 4c			ld bc, user_exec 
23ac 23				inc hl 
23ad 71				ld (hl), c     ; poke address of user_exec 
23ae 23				inc hl 
23af 70				ld (hl), b     
23b0			 ; 
23b0			;	inc hl 
23b0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23b0			; 
23b0			; 
23b0			;	ld bc, macro_forth_rsp_next 
23b0			;	inc hl 
23b0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23b0			;	inc hl 
23b0			;	ld (hl), b     
23b0			 ; 
23b0			;	inc hl 
23b0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23b0			; 
23b0			; 
23b0			;	inc hl 
23b0			;	ld bc, forthexec 
23b0			;	ld (hl), c     ; poke address of forthexec 
23b0			;	inc hl 
23b0			;	ld (hl), b      
23b0			; 
23b0			;	inc hl 
23b0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23b0			; 
23b0			;	ld bc, user_dict_next 
23b0			;	inc hl 
23b0			;	ld (hl), c     ; poke address of forthexec 
23b0			;	inc hl 
23b0			;	ld (hl), b      
23b0			 
23b0				; hl is now where we need to copy the word byte data to save this 
23b0			 
23b0 23				inc hl 
23b1 22 bb e2			ld (os_new_exec), hl 
23b4				 
23b4				; copy definition 
23b4			 
23b4 eb				ex de, hl 
23b5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23b5			;	inc de    ; skip the PC for this parse 
23b5 3a c3 e2			ld a, (os_new_parse_len) 
23b8 4f				ld c, a 
23b9 06 00			ld b, 0 
23bb ed b0			ldir		 ; copy defintion 
23bd			 
23bd			 
23bd				; poke the address of where the new word bytes live for forthexec 
23bd			 
23bd 2a b9 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23c0			 
23c0 ed 5b bb e2		ld de, (os_new_exec)      
23c4				 
23c4 73				ld (hl), e 
23c5 23				inc hl 
23c6 72				ld (hl), d 
23c7			 
23c7					; TODO copy last user dict word next link to this word 
23c7					; TODO update last user dict word to point to this word 
23c7			; 
23c7			; hl f923 de 812a ; bc 811a 
23c7			 
23c7			if DEBUG_FORTH_UWORD 
23c7 c5				push bc 
23c8 ed 4b c5 e2		ld bc, (os_new_malloc) 
23cc						DMARK ":0A" 
23cc f5				push af  
23cd 3a e1 23			ld a, (.dmark)  
23d0 32 71 ee			ld (debug_mark),a  
23d3 3a e2 23			ld a, (.dmark+1)  
23d6 32 72 ee			ld (debug_mark+1),a  
23d9 3a e3 23			ld a, (.dmark+2)  
23dc 32 73 ee			ld (debug_mark+2),a  
23df 18 03			jr .pastdmark  
23e1 ..			.dmark: db ":0A"  
23e4 f1			.pastdmark: pop af  
23e5			endm  
# End of macro DMARK
23e5				CALLMONITOR 
23e5 cd e8 15			call break_point_state  
23e8				endm  
# End of macro CALLMONITOR
23e8 c1				pop bc 
23e9			endif 
23e9			if DEBUG_FORTH_UWORD 
23e9 c5				push bc 
23ea ed 4b c5 e2		ld bc, (os_new_malloc) 
23ee 03				inc bc 
23ef 03				inc bc 
23f0 03				inc bc 
23f1 03				inc bc 
23f2 03				inc bc 
23f3 03				inc bc 
23f4 03				inc bc 
23f5 03				inc bc 
23f6			 
23f6						DMARK ":0B" 
23f6 f5				push af  
23f7 3a 0b 24			ld a, (.dmark)  
23fa 32 71 ee			ld (debug_mark),a  
23fd 3a 0c 24			ld a, (.dmark+1)  
2400 32 72 ee			ld (debug_mark+1),a  
2403 3a 0d 24			ld a, (.dmark+2)  
2406 32 73 ee			ld (debug_mark+2),a  
2409 18 03			jr .pastdmark  
240b ..			.dmark: db ":0B"  
240e f1			.pastdmark: pop af  
240f			endm  
# End of macro DMARK
240f				CALLMONITOR 
240f cd e8 15			call break_point_state  
2412				endm  
# End of macro CALLMONITOR
2412 c1				pop bc 
2413			endif 
2413			 
2413			; update word dict linked list for new word 
2413			 
2413			 
2413 2a c4 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2416 23			inc hl     ; move to next work linked list ptr 
2417			 
2417 ed 5b c5 e2	ld de, (os_new_malloc)		 ; new next word 
241b 73			ld (hl), e 
241c 23			inc hl 
241d 72			ld (hl), d 
241e			 
241e			if DEBUG_FORTH_UWORD 
241e ed 4b c4 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2422			endif 
2422			 
2422 ed 53 c4 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2426			 
2426			 
2426			if DEBUG_FORTH_UWORD 
2426						DMARK ":0+" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 71 ee			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 72 ee			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 73 ee			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db ":0+"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f				CALLMONITOR 
243f cd e8 15			call break_point_state  
2442				endm  
# End of macro CALLMONITOR
2442			endif 
2442			 
2442				STACKFRAMECHK OFF $8efe $989f 
2442				if DEBUG_STACK_IMB 
2442					if OFF 
2442						exx 
2442						ld hl, $989f 
2442						pop de   ; $989f 
2442						call cmp16 
2442						jr nz, .spnosame 
2442						ld hl, $8efe 
2442						pop de   ; $8efe 
2442						call cmp16 
2442						jr z, .spfrsame 
2442						.spnosame: call showsperror 
2442						.spfrsame: nop 
2442						exx 
2442					endif 
2442				endif 
2442			endm 
# End of macro STACKFRAMECHK
2442			 
2442 c9			ret    ; dont process any remaining parser tokens as they form new word 
2443			 
2443			 
2443			 
2443			 
2443			;		NEXT 
2443			.SCOLN: 
2443			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2443 06				db OPCODE_SCOLN 
2444 8f 24			dw .DROP 
2446 02				db 2 
2447 .. 00			db ";",0           
2449			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2449					if DEBUG_FORTH_WORDS_KEY 
2449						DMARK "SCN" 
2449 f5				push af  
244a 3a 5e 24			ld a, (.dmark)  
244d 32 71 ee			ld (debug_mark),a  
2450 3a 5f 24			ld a, (.dmark+1)  
2453 32 72 ee			ld (debug_mark+1),a  
2456 3a 60 24			ld a, (.dmark+2)  
2459 32 73 ee			ld (debug_mark+2),a  
245c 18 03			jr .pastdmark  
245e ..			.dmark: db "SCN"  
2461 f1			.pastdmark: pop af  
2462			endm  
# End of macro DMARK
2462						CALLMONITOR 
2462 cd e8 15			call break_point_state  
2465				endm  
# End of macro CALLMONITOR
2465					endif 
2465					FORTH_RSP_TOS 
2465 cd 44 1c			call macro_forth_rsp_tos 
2468				endm 
# End of macro FORTH_RSP_TOS
2468 e5					push hl 
2469					FORTH_RSP_POP 
2469 cd 4e 1c			call macro_forth_rsp_pop 
246c				endm 
# End of macro FORTH_RSP_POP
246c e1					pop hl 
246d			;		ex de,hl 
246d 22 c8 e5				ld (os_tok_ptr),hl 
2470			 
2470			if DEBUG_FORTH_UWORD 
2470						DMARK "SCL" 
2470 f5				push af  
2471 3a 85 24			ld a, (.dmark)  
2474 32 71 ee			ld (debug_mark),a  
2477 3a 86 24			ld a, (.dmark+1)  
247a 32 72 ee			ld (debug_mark+1),a  
247d 3a 87 24			ld a, (.dmark+2)  
2480 32 73 ee			ld (debug_mark+2),a  
2483 18 03			jr .pastdmark  
2485 ..			.dmark: db "SCL"  
2488 f1			.pastdmark: pop af  
2489			endm  
# End of macro DMARK
2489				CALLMONITOR 
2489 cd e8 15			call break_point_state  
248c				endm  
# End of macro CALLMONITOR
248c			endif 
248c					NEXTW 
248c c3 33 20			jp macro_next 
248f				endm 
# End of macro NEXTW
248f			 
248f			.DROP: 
248f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
248f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2490 ba 24			dw .DUP2            
2492 05				db 4 + 1 
2493 .. 00			db "DROP",0              
2498				endm 
# End of macro CWHEAD
2498			; | DROP ( w -- )   drop the TOS item   | DONE 
2498					if DEBUG_FORTH_WORDS_KEY 
2498						DMARK "DRP" 
2498 f5				push af  
2499 3a ad 24			ld a, (.dmark)  
249c 32 71 ee			ld (debug_mark),a  
249f 3a ae 24			ld a, (.dmark+1)  
24a2 32 72 ee			ld (debug_mark+1),a  
24a5 3a af 24			ld a, (.dmark+2)  
24a8 32 73 ee			ld (debug_mark+2),a  
24ab 18 03			jr .pastdmark  
24ad ..			.dmark: db "DRP"  
24b0 f1			.pastdmark: pop af  
24b1			endm  
# End of macro DMARK
24b1						CALLMONITOR 
24b1 cd e8 15			call break_point_state  
24b4				endm  
# End of macro CALLMONITOR
24b4					endif 
24b4					FORTH_DSP_POP 
24b4 cd 35 1f			call macro_forth_dsp_pop 
24b7				endm 
# End of macro FORTH_DSP_POP
24b7					NEXTW 
24b7 c3 33 20			jp macro_next 
24ba				endm 
# End of macro NEXTW
24ba			.DUP2: 
24ba				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24ba 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24bb ff 24			dw .DROP2            
24bd 05				db 4 + 1 
24be .. 00			db "2DUP",0              
24c3				endm 
# End of macro CWHEAD
24c3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24c3					if DEBUG_FORTH_WORDS_KEY 
24c3						DMARK "2DU" 
24c3 f5				push af  
24c4 3a d8 24			ld a, (.dmark)  
24c7 32 71 ee			ld (debug_mark),a  
24ca 3a d9 24			ld a, (.dmark+1)  
24cd 32 72 ee			ld (debug_mark+1),a  
24d0 3a da 24			ld a, (.dmark+2)  
24d3 32 73 ee			ld (debug_mark+2),a  
24d6 18 03			jr .pastdmark  
24d8 ..			.dmark: db "2DU"  
24db f1			.pastdmark: pop af  
24dc			endm  
# End of macro DMARK
24dc						CALLMONITOR 
24dc cd e8 15			call break_point_state  
24df				endm  
# End of macro CALLMONITOR
24df					endif 
24df					FORTH_DSP_VALUEHL 
24df cd 7d 1e			call macro_dsp_valuehl 
24e2				endm 
# End of macro FORTH_DSP_VALUEHL
24e2 e5					push hl      ; 2 
24e3			 
24e3					FORTH_DSP_POP 
24e3 cd 35 1f			call macro_forth_dsp_pop 
24e6				endm 
# End of macro FORTH_DSP_POP
24e6					 
24e6					FORTH_DSP_VALUEHL 
24e6 cd 7d 1e			call macro_dsp_valuehl 
24e9				endm 
# End of macro FORTH_DSP_VALUEHL
24e9			;		push hl      ; 1 
24e9			 
24e9					FORTH_DSP_POP 
24e9 cd 35 1f			call macro_forth_dsp_pop 
24ec				endm 
# End of macro FORTH_DSP_POP
24ec			 
24ec			;		pop hl       ; 1 
24ec d1					pop de       ; 2 
24ed			 
24ed cd 86 1c				call forth_push_numhl 
24f0 eb					ex de, hl 
24f1 cd 86 1c				call forth_push_numhl 
24f4			 
24f4					 
24f4 eb					ex de, hl 
24f5			 
24f5 cd 86 1c				call forth_push_numhl 
24f8 eb					ex de, hl 
24f9 cd 86 1c				call forth_push_numhl 
24fc			 
24fc			 
24fc					NEXTW 
24fc c3 33 20			jp macro_next 
24ff				endm 
# End of macro NEXTW
24ff			.DROP2: 
24ff				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24ff 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2500 2e 25			dw .SWAP2            
2502 06				db 5 + 1 
2503 .. 00			db "2DROP",0              
2509				endm 
# End of macro CWHEAD
2509			; | 2DROP ( w w -- )    Double drop | DONE 
2509					if DEBUG_FORTH_WORDS_KEY 
2509						DMARK "2DR" 
2509 f5				push af  
250a 3a 1e 25			ld a, (.dmark)  
250d 32 71 ee			ld (debug_mark),a  
2510 3a 1f 25			ld a, (.dmark+1)  
2513 32 72 ee			ld (debug_mark+1),a  
2516 3a 20 25			ld a, (.dmark+2)  
2519 32 73 ee			ld (debug_mark+2),a  
251c 18 03			jr .pastdmark  
251e ..			.dmark: db "2DR"  
2521 f1			.pastdmark: pop af  
2522			endm  
# End of macro DMARK
2522						CALLMONITOR 
2522 cd e8 15			call break_point_state  
2525				endm  
# End of macro CALLMONITOR
2525					endif 
2525					FORTH_DSP_POP 
2525 cd 35 1f			call macro_forth_dsp_pop 
2528				endm 
# End of macro FORTH_DSP_POP
2528					FORTH_DSP_POP 
2528 cd 35 1f			call macro_forth_dsp_pop 
252b				endm 
# End of macro FORTH_DSP_POP
252b					NEXTW 
252b c3 33 20			jp macro_next 
252e				endm 
# End of macro NEXTW
252e			.SWAP2: 
252e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
252e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
252f 57 25			dw .AT            
2531 06				db 5 + 1 
2532 .. 00			db "2SWAP",0              
2538				endm 
# End of macro CWHEAD
2538			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2538					if DEBUG_FORTH_WORDS_KEY 
2538						DMARK "2SW" 
2538 f5				push af  
2539 3a 4d 25			ld a, (.dmark)  
253c 32 71 ee			ld (debug_mark),a  
253f 3a 4e 25			ld a, (.dmark+1)  
2542 32 72 ee			ld (debug_mark+1),a  
2545 3a 4f 25			ld a, (.dmark+2)  
2548 32 73 ee			ld (debug_mark+2),a  
254b 18 03			jr .pastdmark  
254d ..			.dmark: db "2SW"  
2550 f1			.pastdmark: pop af  
2551			endm  
# End of macro DMARK
2551						CALLMONITOR 
2551 cd e8 15			call break_point_state  
2554				endm  
# End of macro CALLMONITOR
2554					endif 
2554					NEXTW 
2554 c3 33 20			jp macro_next 
2557				endm 
# End of macro NEXTW
2557			.AT: 
2557				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2557 1f				db WORD_SYS_CORE+OPCODE_AT             
2558 89 25			dw .CAT            
255a 02				db 1 + 1 
255b .. 00			db "@",0              
255d				endm 
# End of macro CWHEAD
255d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
255d			 
255d					if DEBUG_FORTH_WORDS_KEY 
255d						DMARK "AT." 
255d f5				push af  
255e 3a 72 25			ld a, (.dmark)  
2561 32 71 ee			ld (debug_mark),a  
2564 3a 73 25			ld a, (.dmark+1)  
2567 32 72 ee			ld (debug_mark+1),a  
256a 3a 74 25			ld a, (.dmark+2)  
256d 32 73 ee			ld (debug_mark+2),a  
2570 18 03			jr .pastdmark  
2572 ..			.dmark: db "AT."  
2575 f1			.pastdmark: pop af  
2576			endm  
# End of macro DMARK
2576						CALLMONITOR 
2576 cd e8 15			call break_point_state  
2579				endm  
# End of macro CALLMONITOR
2579					endif 
2579			.getbyteat:	 
2579					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2579 cd 7d 1e			call macro_dsp_valuehl 
257c				endm 
# End of macro FORTH_DSP_VALUEHL
257c					 
257c			;		push hl 
257c				 
257c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
257c cd 35 1f			call macro_forth_dsp_pop 
257f				endm 
# End of macro FORTH_DSP_POP
257f			 
257f			;		pop hl 
257f			 
257f 7e					ld a, (hl) 
2580			 
2580 6f					ld l, a 
2581 26 00				ld h, 0 
2583 cd 86 1c				call forth_push_numhl 
2586			 
2586					NEXTW 
2586 c3 33 20			jp macro_next 
2589				endm 
# End of macro NEXTW
2589			.CAT: 
2589				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2589 20				db WORD_SYS_CORE+OPCODE_CAT             
258a b2 25			dw .BANG            
258c 03				db 2 + 1 
258d .. 00			db "C@",0              
2590				endm 
# End of macro CWHEAD
2590			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2590					if DEBUG_FORTH_WORDS_KEY 
2590						DMARK "CAA" 
2590 f5				push af  
2591 3a a5 25			ld a, (.dmark)  
2594 32 71 ee			ld (debug_mark),a  
2597 3a a6 25			ld a, (.dmark+1)  
259a 32 72 ee			ld (debug_mark+1),a  
259d 3a a7 25			ld a, (.dmark+2)  
25a0 32 73 ee			ld (debug_mark+2),a  
25a3 18 03			jr .pastdmark  
25a5 ..			.dmark: db "CAA"  
25a8 f1			.pastdmark: pop af  
25a9			endm  
# End of macro DMARK
25a9						CALLMONITOR 
25a9 cd e8 15			call break_point_state  
25ac				endm  
# End of macro CALLMONITOR
25ac					endif 
25ac c3 79 25				jp .getbyteat 
25af					NEXTW 
25af c3 33 20			jp macro_next 
25b2				endm 
# End of macro NEXTW
25b2			.BANG: 
25b2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25b2 21				db WORD_SYS_CORE+OPCODE_BANG             
25b3 e8 25			dw .CBANG            
25b5 02				db 1 + 1 
25b6 .. 00			db "!",0              
25b8				endm 
# End of macro CWHEAD
25b8			; | ! ( x w -- ) Store x at address w      | DONE 
25b8					if DEBUG_FORTH_WORDS_KEY 
25b8						DMARK "BNG" 
25b8 f5				push af  
25b9 3a cd 25			ld a, (.dmark)  
25bc 32 71 ee			ld (debug_mark),a  
25bf 3a ce 25			ld a, (.dmark+1)  
25c2 32 72 ee			ld (debug_mark+1),a  
25c5 3a cf 25			ld a, (.dmark+2)  
25c8 32 73 ee			ld (debug_mark+2),a  
25cb 18 03			jr .pastdmark  
25cd ..			.dmark: db "BNG"  
25d0 f1			.pastdmark: pop af  
25d1			endm  
# End of macro DMARK
25d1						CALLMONITOR 
25d1 cd e8 15			call break_point_state  
25d4				endm  
# End of macro CALLMONITOR
25d4					endif 
25d4			 
25d4			.storebyteat:		 
25d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d4 cd 7d 1e			call macro_dsp_valuehl 
25d7				endm 
# End of macro FORTH_DSP_VALUEHL
25d7					 
25d7 e5					push hl 
25d8				 
25d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d8 cd 35 1f			call macro_forth_dsp_pop 
25db				endm 
# End of macro FORTH_DSP_POP
25db			 
25db					; get byte to poke 
25db			 
25db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25db cd 7d 1e			call macro_dsp_valuehl 
25de				endm 
# End of macro FORTH_DSP_VALUEHL
25de e5					push hl 
25df			 
25df			 
25df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25df cd 35 1f			call macro_forth_dsp_pop 
25e2				endm 
# End of macro FORTH_DSP_POP
25e2			 
25e2			 
25e2 d1					pop de 
25e3 e1					pop hl 
25e4			 
25e4 73					ld (hl),e 
25e5			 
25e5			 
25e5					NEXTW 
25e5 c3 33 20			jp macro_next 
25e8				endm 
# End of macro NEXTW
25e8			.CBANG: 
25e8				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25e8 22				db WORD_SYS_CORE+OPCODE_CBANG             
25e9 11 26			dw .SCALL            
25eb 03				db 2 + 1 
25ec .. 00			db "C!",0              
25ef				endm 
# End of macro CWHEAD
25ef			; | C!  ( x w -- ) Store x at address w  | DONE 
25ef					if DEBUG_FORTH_WORDS_KEY 
25ef						DMARK "CBA" 
25ef f5				push af  
25f0 3a 04 26			ld a, (.dmark)  
25f3 32 71 ee			ld (debug_mark),a  
25f6 3a 05 26			ld a, (.dmark+1)  
25f9 32 72 ee			ld (debug_mark+1),a  
25fc 3a 06 26			ld a, (.dmark+2)  
25ff 32 73 ee			ld (debug_mark+2),a  
2602 18 03			jr .pastdmark  
2604 ..			.dmark: db "CBA"  
2607 f1			.pastdmark: pop af  
2608			endm  
# End of macro DMARK
2608						CALLMONITOR 
2608 cd e8 15			call break_point_state  
260b				endm  
# End of macro CALLMONITOR
260b					endif 
260b c3 d4 25				jp .storebyteat 
260e					NEXTW 
260e c3 33 20			jp macro_next 
2611				endm 
# End of macro NEXTW
2611			.SCALL: 
2611				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2611 23				db WORD_SYS_CORE+OPCODE_SCALL             
2612 45 26			dw .DEPTH            
2614 05				db 4 + 1 
2615 .. 00			db "CALL",0              
261a				endm 
# End of macro CWHEAD
261a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
261a					if DEBUG_FORTH_WORDS_KEY 
261a						DMARK "CLL" 
261a f5				push af  
261b 3a 2f 26			ld a, (.dmark)  
261e 32 71 ee			ld (debug_mark),a  
2621 3a 30 26			ld a, (.dmark+1)  
2624 32 72 ee			ld (debug_mark+1),a  
2627 3a 31 26			ld a, (.dmark+2)  
262a 32 73 ee			ld (debug_mark+2),a  
262d 18 03			jr .pastdmark  
262f ..			.dmark: db "CLL"  
2632 f1			.pastdmark: pop af  
2633			endm  
# End of macro DMARK
2633						CALLMONITOR 
2633 cd e8 15			call break_point_state  
2636				endm  
# End of macro CALLMONITOR
2636					endif 
2636			 
2636					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2636 cd 7d 1e			call macro_dsp_valuehl 
2639				endm 
# End of macro FORTH_DSP_VALUEHL
2639			 
2639			;		push hl 
2639			 
2639					; destroy value TOS 
2639			 
2639					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2639 cd 35 1f			call macro_forth_dsp_pop 
263c				endm 
# End of macro FORTH_DSP_POP
263c			 
263c						 
263c			;		pop hl 
263c			 
263c					; how to do a call with hl???? save SP? 
263c cd d7 1f				call forth_call_hl 
263f			 
263f			 
263f					; TODO push value back onto stack for another op etc 
263f			 
263f cd 86 1c				call forth_push_numhl 
2642					NEXTW 
2642 c3 33 20			jp macro_next 
2645				endm 
# End of macro NEXTW
2645			.DEPTH: 
2645				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2645 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2646 82 26			dw .OVER            
2648 06				db 5 + 1 
2649 .. 00			db "DEPTH",0              
264f				endm 
# End of macro CWHEAD
264f			; | DEPTH ( -- u ) Push count of stack | DONE 
264f					; take current TOS and remove from base value div by two to get count 
264f					if DEBUG_FORTH_WORDS_KEY 
264f						DMARK "DEP" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 71 ee			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 72 ee			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 73 ee			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "DEP"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668						CALLMONITOR 
2668 cd e8 15			call break_point_state  
266b				endm  
# End of macro CALLMONITOR
266b					endif 
266b			 
266b			 
266b 2a f4 e9			ld hl, (cli_data_sp) 
266e 11 2e e8			ld de, cli_data_stack 
2671 ed 52			sbc hl,de 
2673				 
2673				; div by size of stack item 
2673			 
2673 5d				ld e,l 
2674 0e 03			ld c, 3 
2676 cd 77 0d			call Div8 
2679			 
2679 6f				ld l,a 
267a 26 00			ld h,0 
267c			 
267c				;srl h 
267c				;rr l 
267c			 
267c cd 86 1c				call forth_push_numhl 
267f					NEXTW 
267f c3 33 20			jp macro_next 
2682				endm 
# End of macro NEXTW
2682			.OVER: 
2682				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2682 42				db WORD_SYS_CORE+46             
2683 c9 26			dw .PAUSE            
2685 05				db 4 + 1 
2686 .. 00			db "OVER",0              
268b				endm 
# End of macro CWHEAD
268b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
268b					if DEBUG_FORTH_WORDS_KEY 
268b						DMARK "OVR" 
268b f5				push af  
268c 3a a0 26			ld a, (.dmark)  
268f 32 71 ee			ld (debug_mark),a  
2692 3a a1 26			ld a, (.dmark+1)  
2695 32 72 ee			ld (debug_mark+1),a  
2698 3a a2 26			ld a, (.dmark+2)  
269b 32 73 ee			ld (debug_mark+2),a  
269e 18 03			jr .pastdmark  
26a0 ..			.dmark: db "OVR"  
26a3 f1			.pastdmark: pop af  
26a4			endm  
# End of macro DMARK
26a4						CALLMONITOR 
26a4 cd e8 15			call break_point_state  
26a7				endm  
# End of macro CALLMONITOR
26a7					endif 
26a7			 
26a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a7 cd 7d 1e			call macro_dsp_valuehl 
26aa				endm 
# End of macro FORTH_DSP_VALUEHL
26aa e5					push hl    ; n2 
26ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ab cd 35 1f			call macro_forth_dsp_pop 
26ae				endm 
# End of macro FORTH_DSP_POP
26ae			 
26ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ae cd 7d 1e			call macro_dsp_valuehl 
26b1				endm 
# End of macro FORTH_DSP_VALUEHL
26b1 e5					push hl    ; n1 
26b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b2 cd 35 1f			call macro_forth_dsp_pop 
26b5				endm 
# End of macro FORTH_DSP_POP
26b5			 
26b5 d1					pop de     ; n1 
26b6 e1					pop hl     ; n2 
26b7			 
26b7 d5					push de 
26b8 e5					push hl 
26b9 d5					push de 
26ba			 
26ba					; push back  
26ba			 
26ba e1					pop hl 
26bb cd 86 1c				call forth_push_numhl 
26be e1					pop hl 
26bf cd 86 1c				call forth_push_numhl 
26c2 e1					pop hl 
26c3 cd 86 1c				call forth_push_numhl 
26c6					NEXTW 
26c6 c3 33 20			jp macro_next 
26c9				endm 
# End of macro NEXTW
26c9			 
26c9			.PAUSE: 
26c9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26c9 43				db WORD_SYS_CORE+47             
26ca fe 26			dw .PAUSES            
26cc 08				db 7 + 1 
26cd .. 00			db "PAUSEMS",0              
26d5				endm 
# End of macro CWHEAD
26d5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26d5					if DEBUG_FORTH_WORDS_KEY 
26d5						DMARK "PMS" 
26d5 f5				push af  
26d6 3a ea 26			ld a, (.dmark)  
26d9 32 71 ee			ld (debug_mark),a  
26dc 3a eb 26			ld a, (.dmark+1)  
26df 32 72 ee			ld (debug_mark+1),a  
26e2 3a ec 26			ld a, (.dmark+2)  
26e5 32 73 ee			ld (debug_mark+2),a  
26e8 18 03			jr .pastdmark  
26ea ..			.dmark: db "PMS"  
26ed f1			.pastdmark: pop af  
26ee			endm  
# End of macro DMARK
26ee						CALLMONITOR 
26ee cd e8 15			call break_point_state  
26f1				endm  
# End of macro CALLMONITOR
26f1					endif 
26f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f1 cd 7d 1e			call macro_dsp_valuehl 
26f4				endm 
# End of macro FORTH_DSP_VALUEHL
26f4			;		push hl    ; n2 
26f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f4 cd 35 1f			call macro_forth_dsp_pop 
26f7				endm 
# End of macro FORTH_DSP_POP
26f7			;		pop hl 
26f7			 
26f7 7d					ld a, l 
26f8 cd d7 0a				call aDelayInMS 
26fb				       NEXTW 
26fb c3 33 20			jp macro_next 
26fe				endm 
# End of macro NEXTW
26fe			.PAUSES:  
26fe				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26fe 44				db WORD_SYS_CORE+48             
26ff 6d 27			dw .ROT            
2701 06				db 5 + 1 
2702 .. 00			db "PAUSE",0              
2708				endm 
# End of macro CWHEAD
2708			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2708					if DEBUG_FORTH_WORDS_KEY 
2708						DMARK "PAU" 
2708 f5				push af  
2709 3a 1d 27			ld a, (.dmark)  
270c 32 71 ee			ld (debug_mark),a  
270f 3a 1e 27			ld a, (.dmark+1)  
2712 32 72 ee			ld (debug_mark+1),a  
2715 3a 1f 27			ld a, (.dmark+2)  
2718 32 73 ee			ld (debug_mark+2),a  
271b 18 03			jr .pastdmark  
271d ..			.dmark: db "PAU"  
2720 f1			.pastdmark: pop af  
2721			endm  
# End of macro DMARK
2721						CALLMONITOR 
2721 cd e8 15			call break_point_state  
2724				endm  
# End of macro CALLMONITOR
2724					endif 
2724					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2724 cd 7d 1e			call macro_dsp_valuehl 
2727				endm 
# End of macro FORTH_DSP_VALUEHL
2727			;		push hl    ; n2 
2727					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2727 cd 35 1f			call macro_forth_dsp_pop 
272a				endm 
# End of macro FORTH_DSP_POP
272a			;		pop hl 
272a 45					ld b, l 
272b					if DEBUG_FORTH_WORDS 
272b						DMARK "PAU" 
272b f5				push af  
272c 3a 40 27			ld a, (.dmark)  
272f 32 71 ee			ld (debug_mark),a  
2732 3a 41 27			ld a, (.dmark+1)  
2735 32 72 ee			ld (debug_mark+1),a  
2738 3a 42 27			ld a, (.dmark+2)  
273b 32 73 ee			ld (debug_mark+2),a  
273e 18 03			jr .pastdmark  
2740 ..			.dmark: db "PAU"  
2743 f1			.pastdmark: pop af  
2744			endm  
# End of macro DMARK
2744						CALLMONITOR 
2744 cd e8 15			call break_point_state  
2747				endm  
# End of macro CALLMONITOR
2747					endif 
2747 c5			.pauses1:	push bc 
2748 cd f2 0a				call delay1s 
274b c1					pop bc 
274c					if DEBUG_FORTH_WORDS 
274c						DMARK "PA1" 
274c f5				push af  
274d 3a 61 27			ld a, (.dmark)  
2750 32 71 ee			ld (debug_mark),a  
2753 3a 62 27			ld a, (.dmark+1)  
2756 32 72 ee			ld (debug_mark+1),a  
2759 3a 63 27			ld a, (.dmark+2)  
275c 32 73 ee			ld (debug_mark+2),a  
275f 18 03			jr .pastdmark  
2761 ..			.dmark: db "PA1"  
2764 f1			.pastdmark: pop af  
2765			endm  
# End of macro DMARK
2765						CALLMONITOR 
2765 cd e8 15			call break_point_state  
2768				endm  
# End of macro CALLMONITOR
2768					endif 
2768 10 dd				djnz .pauses1 
276a			 
276a				       NEXTW 
276a c3 33 20			jp macro_next 
276d				endm 
# End of macro NEXTW
276d			.ROT: 
276d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
276d 45				db WORD_SYS_CORE+49             
276e bb 27			dw .UWORDS            
2770 04				db 3 + 1 
2771 .. 00			db "ROT",0              
2775				endm 
# End of macro CWHEAD
2775			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2775					if DEBUG_FORTH_WORDS_KEY 
2775						DMARK "ROT" 
2775 f5				push af  
2776 3a 8a 27			ld a, (.dmark)  
2779 32 71 ee			ld (debug_mark),a  
277c 3a 8b 27			ld a, (.dmark+1)  
277f 32 72 ee			ld (debug_mark+1),a  
2782 3a 8c 27			ld a, (.dmark+2)  
2785 32 73 ee			ld (debug_mark+2),a  
2788 18 03			jr .pastdmark  
278a ..			.dmark: db "ROT"  
278d f1			.pastdmark: pop af  
278e			endm  
# End of macro DMARK
278e						CALLMONITOR 
278e cd e8 15			call break_point_state  
2791				endm  
# End of macro CALLMONITOR
2791					endif 
2791			 
2791					FORTH_DSP_VALUEHL 
2791 cd 7d 1e			call macro_dsp_valuehl 
2794				endm 
# End of macro FORTH_DSP_VALUEHL
2794 e5					push hl    ; u3  
2795			 
2795					FORTH_DSP_POP 
2795 cd 35 1f			call macro_forth_dsp_pop 
2798				endm 
# End of macro FORTH_DSP_POP
2798			   
2798					FORTH_DSP_VALUEHL 
2798 cd 7d 1e			call macro_dsp_valuehl 
279b				endm 
# End of macro FORTH_DSP_VALUEHL
279b e5					push hl     ; u2 
279c			 
279c					FORTH_DSP_POP 
279c cd 35 1f			call macro_forth_dsp_pop 
279f				endm 
# End of macro FORTH_DSP_POP
279f			 
279f					FORTH_DSP_VALUEHL 
279f cd 7d 1e			call macro_dsp_valuehl 
27a2				endm 
# End of macro FORTH_DSP_VALUEHL
27a2 e5					push hl     ; u1 
27a3			 
27a3					FORTH_DSP_POP 
27a3 cd 35 1f			call macro_forth_dsp_pop 
27a6				endm 
# End of macro FORTH_DSP_POP
27a6			 
27a6 c1					pop bc      ; u1 
27a7 e1					pop hl      ; u2 
27a8 d1					pop de      ; u3 
27a9			 
27a9			 
27a9 c5					push bc 
27aa d5					push de 
27ab e5					push hl 
27ac			 
27ac			 
27ac e1					pop hl 
27ad cd 86 1c				call forth_push_numhl 
27b0			 
27b0 e1					pop hl 
27b1 cd 86 1c				call forth_push_numhl 
27b4			 
27b4 e1					pop hl 
27b5 cd 86 1c				call forth_push_numhl 
27b8					 
27b8			 
27b8			 
27b8			 
27b8			 
27b8			 
27b8				       NEXTW 
27b8 c3 33 20			jp macro_next 
27bb				endm 
# End of macro NEXTW
27bb			 
27bb			.UWORDS: 
27bb				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27bb 50				db WORD_SYS_CORE+60             
27bc 7d 28			dw .BP            
27be 07				db 6 + 1 
27bf .. 00			db "UWORDS",0              
27c6				endm 
# End of macro CWHEAD
27c6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27c6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27c6			; | | Following the count are the individual words. 
27c6			; | | 
27c6			; | | e.g. UWORDS 
27c6			; | | BOX DIRLIST 2 
27c6			; | |  
27c6			; | | Can be used to save the words to storage via: 
27c6			; | | UWORDS $01 DO $01 APPEND LOOP 
27c6				if DEBUG_FORTH_WORDS_KEY 
27c6					DMARK "UWR" 
27c6 f5				push af  
27c7 3a db 27			ld a, (.dmark)  
27ca 32 71 ee			ld (debug_mark),a  
27cd 3a dc 27			ld a, (.dmark+1)  
27d0 32 72 ee			ld (debug_mark+1),a  
27d3 3a dd 27			ld a, (.dmark+2)  
27d6 32 73 ee			ld (debug_mark+2),a  
27d9 18 03			jr .pastdmark  
27db ..			.dmark: db "UWR"  
27de f1			.pastdmark: pop af  
27df			endm  
# End of macro DMARK
27df					CALLMONITOR 
27df cd e8 15			call break_point_state  
27e2				endm  
# End of macro CALLMONITOR
27e2				endif 
27e2 21 e0 64				ld hl, baseram 
27e5					;ld hl, baseusermem 
27e5 01 00 00				ld bc, 0    ; start a counter 
27e8			 
27e8				; skip dict stub 
27e8			 
27e8 cd 84 21				call forth_tok_next 
27eb			 
27eb			 
27eb			; while we have words to look for 
27eb			 
27eb 7e			.douscan:	ld a, (hl)      
27ec				if DEBUG_FORTH_WORDS 
27ec					DMARK "UWs" 
27ec f5				push af  
27ed 3a 01 28			ld a, (.dmark)  
27f0 32 71 ee			ld (debug_mark),a  
27f3 3a 02 28			ld a, (.dmark+1)  
27f6 32 72 ee			ld (debug_mark+1),a  
27f9 3a 03 28			ld a, (.dmark+2)  
27fc 32 73 ee			ld (debug_mark+2),a  
27ff 18 03			jr .pastdmark  
2801 ..			.dmark: db "UWs"  
2804 f1			.pastdmark: pop af  
2805			endm  
# End of macro DMARK
2805					CALLMONITOR 
2805 cd e8 15			call break_point_state  
2808				endm  
# End of macro CALLMONITOR
2808				endif 
2808 fe 00				cp WORD_SYS_END 
280a 28 4d				jr z, .udone 
280c fe 01				cp WORD_SYS_UWORD 
280e 20 44				jr nz, .nuword 
2810			 
2810				if DEBUG_FORTH_WORDS 
2810					DMARK "UWu" 
2810 f5				push af  
2811 3a 25 28			ld a, (.dmark)  
2814 32 71 ee			ld (debug_mark),a  
2817 3a 26 28			ld a, (.dmark+1)  
281a 32 72 ee			ld (debug_mark+1),a  
281d 3a 27 28			ld a, (.dmark+2)  
2820 32 73 ee			ld (debug_mark+2),a  
2823 18 03			jr .pastdmark  
2825 ..			.dmark: db "UWu"  
2828 f1			.pastdmark: pop af  
2829			endm  
# End of macro DMARK
2829					CALLMONITOR 
2829 cd e8 15			call break_point_state  
282c				endm  
# End of macro CALLMONITOR
282c				endif 
282c					; we have a uword so push its name to the stack 
282c			 
282c e5				   	push hl  ; save so we can move to next dict block 
282d			 
282d					; skip opcode 
282d 23					inc hl  
282e					; skip next ptr 
282e 23					inc hl  
282f 23					inc hl 
2830					; skip len 
2830 23					inc hl 
2831				if DEBUG_FORTH_WORDS 
2831					DMARK "UWt" 
2831 f5				push af  
2832 3a 46 28			ld a, (.dmark)  
2835 32 71 ee			ld (debug_mark),a  
2838 3a 47 28			ld a, (.dmark+1)  
283b 32 72 ee			ld (debug_mark+1),a  
283e 3a 48 28			ld a, (.dmark+2)  
2841 32 73 ee			ld (debug_mark+2),a  
2844 18 03			jr .pastdmark  
2846 ..			.dmark: db "UWt"  
2849 f1			.pastdmark: pop af  
284a			endm  
# End of macro DMARK
284a					CALLMONITOR 
284a cd e8 15			call break_point_state  
284d				endm  
# End of macro CALLMONITOR
284d				endif 
284d 03					inc bc 
284e			 
284e c5					push bc 
284f cd f4 1c				call forth_push_str 
2852 c1					pop bc 
2853			 
2853 e1					pop hl 	 
2854			 
2854 cd 84 21		.nuword:	call forth_tok_next 
2857 18 92				jr .douscan  
2859			 
2859			.udone:		 ; push count of uwords found 
2859 c5					push bc 
285a e1					pop hl 
285b			 
285b				if DEBUG_FORTH_WORDS 
285b					DMARK "UWc" 
285b f5				push af  
285c 3a 70 28			ld a, (.dmark)  
285f 32 71 ee			ld (debug_mark),a  
2862 3a 71 28			ld a, (.dmark+1)  
2865 32 72 ee			ld (debug_mark+1),a  
2868 3a 72 28			ld a, (.dmark+2)  
286b 32 73 ee			ld (debug_mark+2),a  
286e 18 03			jr .pastdmark  
2870 ..			.dmark: db "UWc"  
2873 f1			.pastdmark: pop af  
2874			endm  
# End of macro DMARK
2874					CALLMONITOR 
2874 cd e8 15			call break_point_state  
2877				endm  
# End of macro CALLMONITOR
2877				endif 
2877 cd 86 1c				call forth_push_numhl 
287a			 
287a			 
287a				       NEXTW 
287a c3 33 20			jp macro_next 
287d				endm 
# End of macro NEXTW
287d			 
287d			.BP: 
287d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
287d 54				db WORD_SYS_CORE+64             
287e b3 28			dw .MONITOR            
2880 03				db 2 + 1 
2881 .. 00			db "BP",0              
2884				endm 
# End of macro CWHEAD
2884			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2884			; | | $00 Will enable the break points within specific code paths 
2884			; | | $01 Will disable break points 
2884			; | |  
2884			; | | By default break points are off. Either the above can be used to enable them 
2884			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2884			; | | and on release of the pressed key a message will be disaplayed to notify 
2884			; | | that break points are enabled. Pressing any key will then continue boot process. 
2884					; get byte count 
2884					if DEBUG_FORTH_WORDS_KEY 
2884						DMARK "BP." 
2884 f5				push af  
2885 3a 99 28			ld a, (.dmark)  
2888 32 71 ee			ld (debug_mark),a  
288b 3a 9a 28			ld a, (.dmark+1)  
288e 32 72 ee			ld (debug_mark+1),a  
2891 3a 9b 28			ld a, (.dmark+2)  
2894 32 73 ee			ld (debug_mark+2),a  
2897 18 03			jr .pastdmark  
2899 ..			.dmark: db "BP."  
289c f1			.pastdmark: pop af  
289d			endm  
# End of macro DMARK
289d						CALLMONITOR 
289d cd e8 15			call break_point_state  
28a0				endm  
# End of macro CALLMONITOR
28a0					endif 
28a0			 
28a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28a0 cd 7d 1e			call macro_dsp_valuehl 
28a3				endm 
# End of macro FORTH_DSP_VALUEHL
28a3			 
28a3			;		push hl 
28a3			 
28a3					; destroy value TOS 
28a3			 
28a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a3 cd 35 1f			call macro_forth_dsp_pop 
28a6				endm 
# End of macro FORTH_DSP_POP
28a6			 
28a6			;		pop hl 
28a6			 
28a6 3e 00				ld a,0 
28a8 bd					cp l 
28a9 28 02				jr z, .bpset 
28ab 3e 2a				ld a, '*' 
28ad			 
28ad 32 b8 e2		.bpset:		ld (os_view_disable), a 
28b0			 
28b0			 
28b0					NEXTW 
28b0 c3 33 20			jp macro_next 
28b3				endm 
# End of macro NEXTW
28b3			 
28b3			 
28b3			.MONITOR: 
28b3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28b3 55				db WORD_SYS_CORE+65             
28b4 e6 28			dw .MALLOC            
28b6 08				db 7 + 1 
28b7 .. 00			db "MONITOR",0              
28bf				endm 
# End of macro CWHEAD
28bf			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28bf			; | | At start the current various registers will be displayed with contents. 
28bf			; | | Top right corner will show the most recent debug marker seen. 
28bf			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28bf			; | | and the return stack pointer (RSP). 
28bf			; | | Pressing: 
28bf			; | |    1 - Initial screen 
28bf			; | |    2 - Display a data dump of HL 
28bf			; | |    3 - Display a data dump of DE 
28bf			; | |    4 - Display a data dump of BC 
28bf			; | |    5 - Display a data dump of HL 
28bf			; | |    6 - Display a data dump of DSP 
28bf			; | |    7 - Display a data dump of RSP 
28bf			; | |    8 - Display a data dump of what is at DSP 
28bf			; | |    9 - Display a data dump of what is at RSP 
28bf			; | |    0 - Exit monitor and continue running. This will also enable break points 
28bf			; | |    * - Disable break points 
28bf			; | |    # - Enter traditional monitor mode 
28bf			; | | 
28bf			; | | Monitor Mode 
28bf			; | | ------------ 
28bf			; | | A prompt of '>' will be shown for various commands: 
28bf			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28bf			; | |    C - Continue display a data dump from the last set address 
28bf			; | |    M xxxx - Set start of memory edit at address xx 
28bf			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28bf			; | |    Q - Return to previous 
28bf					if DEBUG_FORTH_WORDS_KEY 
28bf						DMARK "MON" 
28bf f5				push af  
28c0 3a d4 28			ld a, (.dmark)  
28c3 32 71 ee			ld (debug_mark),a  
28c6 3a d5 28			ld a, (.dmark+1)  
28c9 32 72 ee			ld (debug_mark+1),a  
28cc 3a d6 28			ld a, (.dmark+2)  
28cf 32 73 ee			ld (debug_mark+2),a  
28d2 18 03			jr .pastdmark  
28d4 ..			.dmark: db "MON"  
28d7 f1			.pastdmark: pop af  
28d8			endm  
# End of macro DMARK
28d8						CALLMONITOR 
28d8 cd e8 15			call break_point_state  
28db				endm  
# End of macro CALLMONITOR
28db					endif 
28db 3e 00				ld a, 0 
28dd 32 b8 e2				ld (os_view_disable), a 
28e0			 
28e0					CALLMONITOR 
28e0 cd e8 15			call break_point_state  
28e3				endm  
# End of macro CALLMONITOR
28e3			 
28e3			;	call monitor 
28e3			 
28e3					NEXTW 
28e3 c3 33 20			jp macro_next 
28e6				endm 
# End of macro NEXTW
28e6			 
28e6			 
28e6			.MALLOC: 
28e6				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28e6 56				db WORD_SYS_CORE+66             
28e7 0f 29			dw .MALLOC2            
28e9 06				db 5 + 1 
28ea .. 00			db "ALLOT",0              
28f0				endm 
# End of macro CWHEAD
28f0			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28f0					if DEBUG_FORTH_WORDS_KEY 
28f0						DMARK "ALL" 
28f0 f5				push af  
28f1 3a 05 29			ld a, (.dmark)  
28f4 32 71 ee			ld (debug_mark),a  
28f7 3a 06 29			ld a, (.dmark+1)  
28fa 32 72 ee			ld (debug_mark+1),a  
28fd 3a 07 29			ld a, (.dmark+2)  
2900 32 73 ee			ld (debug_mark+2),a  
2903 18 03			jr .pastdmark  
2905 ..			.dmark: db "ALL"  
2908 f1			.pastdmark: pop af  
2909			endm  
# End of macro DMARK
2909						CALLMONITOR 
2909 cd e8 15			call break_point_state  
290c				endm  
# End of macro CALLMONITOR
290c					endif 
290c c3 36 29				jp .mallocc 
290f			.MALLOC2: 
290f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
290f 56				db WORD_SYS_CORE+66             
2910 4d 29			dw .FREE            
2912 07				db 6 + 1 
2913 .. 00			db "MALLOC",0              
291a				endm 
# End of macro CWHEAD
291a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
291a					; get byte count 
291a					if DEBUG_FORTH_WORDS_KEY 
291a						DMARK "MAL" 
291a f5				push af  
291b 3a 2f 29			ld a, (.dmark)  
291e 32 71 ee			ld (debug_mark),a  
2921 3a 30 29			ld a, (.dmark+1)  
2924 32 72 ee			ld (debug_mark+1),a  
2927 3a 31 29			ld a, (.dmark+2)  
292a 32 73 ee			ld (debug_mark+2),a  
292d 18 03			jr .pastdmark  
292f ..			.dmark: db "MAL"  
2932 f1			.pastdmark: pop af  
2933			endm  
# End of macro DMARK
2933						CALLMONITOR 
2933 cd e8 15			call break_point_state  
2936				endm  
# End of macro CALLMONITOR
2936					endif 
2936			.mallocc: 
2936					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2936 cd 7d 1e			call macro_dsp_valuehl 
2939				endm 
# End of macro FORTH_DSP_VALUEHL
2939			 
2939			;		push hl 
2939			 
2939					; destroy value TOS 
2939			 
2939					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2939 cd 35 1f			call macro_forth_dsp_pop 
293c				endm 
# End of macro FORTH_DSP_POP
293c			 
293c			;		pop hl 
293c cd ae 12				call malloc 
293f				if DEBUG_FORTH_MALLOC_GUARD 
293f f5					push af 
2940 cd 10 0e				call ishlzero 
2943			;		ld a, l 
2943			;		add h 
2943			;		cp 0 
2943 f1					pop af 
2944					 
2944 cc 3e 4d				call z,malloc_error 
2947				endif 
2947			 
2947 cd 86 1c				call forth_push_numhl 
294a					NEXTW 
294a c3 33 20			jp macro_next 
294d				endm 
# End of macro NEXTW
294d			 
294d			.FREE: 
294d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
294d 57				db WORD_SYS_CORE+67             
294e 7e 29			dw .LIST            
2950 05				db 4 + 1 
2951 .. 00			db "FREE",0              
2956				endm 
# End of macro CWHEAD
2956			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2956					if DEBUG_FORTH_WORDS_KEY 
2956						DMARK "FRE" 
2956 f5				push af  
2957 3a 6b 29			ld a, (.dmark)  
295a 32 71 ee			ld (debug_mark),a  
295d 3a 6c 29			ld a, (.dmark+1)  
2960 32 72 ee			ld (debug_mark+1),a  
2963 3a 6d 29			ld a, (.dmark+2)  
2966 32 73 ee			ld (debug_mark+2),a  
2969 18 03			jr .pastdmark  
296b ..			.dmark: db "FRE"  
296e f1			.pastdmark: pop af  
296f			endm  
# End of macro DMARK
296f						CALLMONITOR 
296f cd e8 15			call break_point_state  
2972				endm  
# End of macro CALLMONITOR
2972					endif 
2972					; get address 
2972			 
2972					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2972 cd 7d 1e			call macro_dsp_valuehl 
2975				endm 
# End of macro FORTH_DSP_VALUEHL
2975			 
2975			;		push hl 
2975			 
2975					; destroy value TOS 
2975			 
2975					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2975 cd 35 1f			call macro_forth_dsp_pop 
2978				endm 
# End of macro FORTH_DSP_POP
2978			 
2978			;		pop hl 
2978			if FORTH_ENABLE_MALLOCFREE 
2978 cd 78 13				call free 
297b			endif 
297b					NEXTW 
297b c3 33 20			jp macro_next 
297e				endm 
# End of macro NEXTW
297e			.LIST: 
297e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
297e 5c				db WORD_SYS_CORE+72             
297f 6c 2b			dw .FORGET            
2981 05				db 4 + 1 
2982 .. 00			db "LIST",0              
2987				endm 
# End of macro CWHEAD
2987			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2987			; | | The quoted word must be in upper case. 
2987				if DEBUG_FORTH_WORDS_KEY 
2987					DMARK "LST" 
2987 f5				push af  
2988 3a 9c 29			ld a, (.dmark)  
298b 32 71 ee			ld (debug_mark),a  
298e 3a 9d 29			ld a, (.dmark+1)  
2991 32 72 ee			ld (debug_mark+1),a  
2994 3a 9e 29			ld a, (.dmark+2)  
2997 32 73 ee			ld (debug_mark+2),a  
299a 18 03			jr .pastdmark  
299c ..			.dmark: db "LST"  
299f f1			.pastdmark: pop af  
29a0			endm  
# End of macro DMARK
29a0					CALLMONITOR 
29a0 cd e8 15			call break_point_state  
29a3				endm  
# End of macro CALLMONITOR
29a3				endif 
29a3			 
29a3					FORTH_DSP_VALUEHL 
29a3 cd 7d 1e			call macro_dsp_valuehl 
29a6				endm 
# End of macro FORTH_DSP_VALUEHL
29a6			 
29a6 e5					push hl 
29a7					FORTH_DSP_POP 
29a7 cd 35 1f			call macro_forth_dsp_pop 
29aa				endm 
# End of macro FORTH_DSP_POP
29aa c1					pop bc 
29ab			 
29ab			; Start format of scratch string 
29ab			 
29ab 21 c7 e2				ld hl, scratch 
29ae			 
29ae 3e 3a				ld a, ':' 
29b0 77					ld (hl),a 
29b1 23					inc hl 
29b2 3e 20				ld a, ' ' 
29b4 77					ld (hl), a 
29b5			 
29b5					; Get ptr to the word we need to look up 
29b5			 
29b5			;		FORTH_DSP_VALUEHL 
29b5					;v5 FORTH_DSP_VALUE 
29b5				; TODO type check 
29b5			;		inc hl    ; Skip type check  
29b5			;		push hl 
29b5			;		ex de, hl    ; put into DE 
29b5			 
29b5			 
29b5 21 e0 64				ld hl, baseram 
29b8					;ld hl, baseusermem 
29b8			 
29b8 e5			push hl   ; sacreifical push 
29b9			 
29b9			.ldouscanm: 
29b9 e1				pop hl 
29ba			.ldouscan: 
29ba				if DEBUG_FORTH_WORDS 
29ba					DMARK "LSs" 
29ba f5				push af  
29bb 3a cf 29			ld a, (.dmark)  
29be 32 71 ee			ld (debug_mark),a  
29c1 3a d0 29			ld a, (.dmark+1)  
29c4 32 72 ee			ld (debug_mark+1),a  
29c7 3a d1 29			ld a, (.dmark+2)  
29ca 32 73 ee			ld (debug_mark+2),a  
29cd 18 03			jr .pastdmark  
29cf ..			.dmark: db "LSs"  
29d2 f1			.pastdmark: pop af  
29d3			endm  
# End of macro DMARK
29d3					CALLMONITOR 
29d3 cd e8 15			call break_point_state  
29d6				endm  
# End of macro CALLMONITOR
29d6				endif 
29d6				; skip dict stub 
29d6 cd 84 21				call forth_tok_next 
29d9			 
29d9			 
29d9			; while we have words to look for 
29d9			 
29d9 7e				ld a, (hl)      
29da				if DEBUG_FORTH_WORDS 
29da					DMARK "LSk" 
29da f5				push af  
29db 3a ef 29			ld a, (.dmark)  
29de 32 71 ee			ld (debug_mark),a  
29e1 3a f0 29			ld a, (.dmark+1)  
29e4 32 72 ee			ld (debug_mark+1),a  
29e7 3a f1 29			ld a, (.dmark+2)  
29ea 32 73 ee			ld (debug_mark+2),a  
29ed 18 03			jr .pastdmark  
29ef ..			.dmark: db "LSk"  
29f2 f1			.pastdmark: pop af  
29f3			endm  
# End of macro DMARK
29f3					CALLMONITOR 
29f3 cd e8 15			call break_point_state  
29f6				endm  
# End of macro CALLMONITOR
29f6				endif 
29f6					;cp WORD_SYS_END 
29f6					;jp z, .lunotfound 
29f6			 
29f6					; if we hit non uwords then gone too far 
29f6 fe 01				cp WORD_SYS_UWORD 
29f8 c2 28 2b				jp nz, .lunotfound 
29fb			 
29fb				if DEBUG_FORTH_WORDS 
29fb					DMARK "LSu" 
29fb f5				push af  
29fc 3a 10 2a			ld a, (.dmark)  
29ff 32 71 ee			ld (debug_mark),a  
2a02 3a 11 2a			ld a, (.dmark+1)  
2a05 32 72 ee			ld (debug_mark+1),a  
2a08 3a 12 2a			ld a, (.dmark+2)  
2a0b 32 73 ee			ld (debug_mark+2),a  
2a0e 18 03			jr .pastdmark  
2a10 ..			.dmark: db "LSu"  
2a13 f1			.pastdmark: pop af  
2a14			endm  
# End of macro DMARK
2a14					CALLMONITOR 
2a14 cd e8 15			call break_point_state  
2a17				endm  
# End of macro CALLMONITOR
2a17				endif 
2a17			 
2a17					; found a uword but is it the one we want... 
2a17			 
2a17 c5					push bc     ; uword to find is on bc 
2a18 d1					pop de 
2a19			 
2a19 e5					push hl  ; to save the ptr 
2a1a			 
2a1a					; skip opcode 
2a1a 23					inc hl  
2a1b					; skip next ptr 
2a1b 23					inc hl  
2a1c 23					inc hl 
2a1d					; skip len 
2a1d 23					inc hl 
2a1e			 
2a1e				if DEBUG_FORTH_WORDS 
2a1e					DMARK "LSc" 
2a1e f5				push af  
2a1f 3a 33 2a			ld a, (.dmark)  
2a22 32 71 ee			ld (debug_mark),a  
2a25 3a 34 2a			ld a, (.dmark+1)  
2a28 32 72 ee			ld (debug_mark+1),a  
2a2b 3a 35 2a			ld a, (.dmark+2)  
2a2e 32 73 ee			ld (debug_mark+2),a  
2a31 18 03			jr .pastdmark  
2a33 ..			.dmark: db "LSc"  
2a36 f1			.pastdmark: pop af  
2a37			endm  
# End of macro DMARK
2a37					CALLMONITOR 
2a37 cd e8 15			call break_point_state  
2a3a				endm  
# End of macro CALLMONITOR
2a3a				endif 
2a3a cd 7d 12				call strcmp 
2a3d c2 b9 29				jp nz, .ldouscanm 
2a40				 
2a40			 
2a40			 
2a40					; we have a uword so push its name to the stack 
2a40			 
2a40			;	   	push hl  ; save so we can move to next dict block 
2a40 e1			pop hl 
2a41			 
2a41				if DEBUG_FORTH_WORDS 
2a41					DMARK "LSm" 
2a41 f5				push af  
2a42 3a 56 2a			ld a, (.dmark)  
2a45 32 71 ee			ld (debug_mark),a  
2a48 3a 57 2a			ld a, (.dmark+1)  
2a4b 32 72 ee			ld (debug_mark+1),a  
2a4e 3a 58 2a			ld a, (.dmark+2)  
2a51 32 73 ee			ld (debug_mark+2),a  
2a54 18 03			jr .pastdmark  
2a56 ..			.dmark: db "LSm"  
2a59 f1			.pastdmark: pop af  
2a5a			endm  
# End of macro DMARK
2a5a					CALLMONITOR 
2a5a cd e8 15			call break_point_state  
2a5d				endm  
# End of macro CALLMONITOR
2a5d				endif 
2a5d			 
2a5d					; skip opcode 
2a5d 23					inc hl  
2a5e					; skip next ptr 
2a5e 23					inc hl  
2a5f 23					inc hl 
2a60					; skip len 
2a60 7e					ld a, (hl)   ; save length to add 
2a61				if DEBUG_FORTH_WORDS 
2a61					DMARK "LS2" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 71 ee			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 72 ee			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 73 ee			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db "LS2"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a					CALLMONITOR 
2a7a cd e8 15			call break_point_state  
2a7d				endm  
# End of macro CALLMONITOR
2a7d				endif 
2a7d			 
2a7d					; save this location 
2a7d				 
2a7d e5					push hl 
2a7e			 
2a7e 23					inc hl 
2a7f 11 c9 e2				ld de, scratch+2 
2a82 4f					ld c, a 
2a83 06 00				ld b, 0 
2a85			 
2a85				if DEBUG_FORTH_WORDS 
2a85					DMARK "LSn" 
2a85 f5				push af  
2a86 3a 9a 2a			ld a, (.dmark)  
2a89 32 71 ee			ld (debug_mark),a  
2a8c 3a 9b 2a			ld a, (.dmark+1)  
2a8f 32 72 ee			ld (debug_mark+1),a  
2a92 3a 9c 2a			ld a, (.dmark+2)  
2a95 32 73 ee			ld (debug_mark+2),a  
2a98 18 03			jr .pastdmark  
2a9a ..			.dmark: db "LSn"  
2a9d f1			.pastdmark: pop af  
2a9e			endm  
# End of macro DMARK
2a9e					CALLMONITOR 
2a9e cd e8 15			call break_point_state  
2aa1				endm  
# End of macro CALLMONITOR
2aa1				endif 
2aa1			 
2aa1					; copy uword name to scratch 
2aa1			 
2aa1 ed b0				ldir 
2aa3			 
2aa3 1b					dec de 
2aa4 3e 20				ld a, ' '    ; change null to space 
2aa6 12					ld (de), a 
2aa7			 
2aa7 13					inc de 
2aa8			 
2aa8 d5					push de 
2aa9 c1					pop bc     ; move scratch pointer to end of word name and save it 
2aaa			 
2aaa e1					pop hl 
2aab 7e					ld a, (hl) 
2aac					;inc hl 
2aac					; skip word string 
2aac cd e7 0d				call addatohl 
2aaf			 
2aaf 23					inc hl 
2ab0			 
2ab0				if DEBUG_FORTH_WORDS 
2ab0					DMARK "LS3" 
2ab0 f5				push af  
2ab1 3a c5 2a			ld a, (.dmark)  
2ab4 32 71 ee			ld (debug_mark),a  
2ab7 3a c6 2a			ld a, (.dmark+1)  
2aba 32 72 ee			ld (debug_mark+1),a  
2abd 3a c7 2a			ld a, (.dmark+2)  
2ac0 32 73 ee			ld (debug_mark+2),a  
2ac3 18 03			jr .pastdmark  
2ac5 ..			.dmark: db "LS3"  
2ac8 f1			.pastdmark: pop af  
2ac9			endm  
# End of macro DMARK
2ac9					CALLMONITOR 
2ac9 cd e8 15			call break_point_state  
2acc				endm  
# End of macro CALLMONITOR
2acc				endif 
2acc					; should now be at the start of the machine code to setup the eval of the uword 
2acc					; now locate the ptr to the string defintion 
2acc			 
2acc					; skip ld hl, 
2acc					; then load the ptr 
2acc			; TODO use get from hl ptr 
2acc 23					inc hl 
2acd 5e					ld e, (hl) 
2ace 23					inc hl 
2acf 56					ld d, (hl) 
2ad0 eb					ex de, hl 
2ad1			 
2ad1			 
2ad1				if DEBUG_FORTH_WORDS 
2ad1					DMARK "LSt" 
2ad1 f5				push af  
2ad2 3a e6 2a			ld a, (.dmark)  
2ad5 32 71 ee			ld (debug_mark),a  
2ad8 3a e7 2a			ld a, (.dmark+1)  
2adb 32 72 ee			ld (debug_mark+1),a  
2ade 3a e8 2a			ld a, (.dmark+2)  
2ae1 32 73 ee			ld (debug_mark+2),a  
2ae4 18 03			jr .pastdmark  
2ae6 ..			.dmark: db "LSt"  
2ae9 f1			.pastdmark: pop af  
2aea			endm  
# End of macro DMARK
2aea					CALLMONITOR 
2aea cd e8 15			call break_point_state  
2aed				endm  
# End of macro CALLMONITOR
2aed				endif 
2aed			 
2aed			; cant push right now due to tokenised strings  
2aed			 
2aed			; get the destination of where to copy this definition to. 
2aed			 
2aed c5					push bc 
2aee d1					pop de 
2aef			 
2aef 7e			.listl:         ld a,(hl) 
2af0 fe 00				cp 0 
2af2 28 09				jr z, .lreplsp     ; replace zero with space 
2af4					;cp FORTH_END_BUFFER 
2af4 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2af6 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2af8				 
2af8					; just copy this char as is then 
2af8			 
2af8 12					ld (de), a 
2af9			 
2af9 23			.listnxt:	inc hl 
2afa 13					inc de 
2afb 18 f2				jr .listl 
2afd			 
2afd 3e 20		.lreplsp:	ld a,' ' 
2aff 12					ld (de), a 
2b00 18 f7				jr .listnxt 
2b02			 
2b02			; close up uword def 
2b02			 
2b02			.listdone: 
2b02 12					ld (de), a 
2b03 13					inc de 
2b04 3e 00				ld a, 0 
2b06 12					ld (de), a 
2b07			 
2b07			; now have def so clean up and push to stack 
2b07			 
2b07 21 c7 e2				ld hl, scratch 
2b0a				if DEBUG_FORTH_WORDS 
2b0a					DMARK "Ltp" 
2b0a f5				push af  
2b0b 3a 1f 2b			ld a, (.dmark)  
2b0e 32 71 ee			ld (debug_mark),a  
2b11 3a 20 2b			ld a, (.dmark+1)  
2b14 32 72 ee			ld (debug_mark+1),a  
2b17 3a 21 2b			ld a, (.dmark+2)  
2b1a 32 73 ee			ld (debug_mark+2),a  
2b1d 18 03			jr .pastdmark  
2b1f ..			.dmark: db "Ltp"  
2b22 f1			.pastdmark: pop af  
2b23			endm  
# End of macro DMARK
2b23					CALLMONITOR 
2b23 cd e8 15			call break_point_state  
2b26				endm  
# End of macro CALLMONITOR
2b26				endif 
2b26			 
2b26 18 1f			jr .listpush 
2b28			 
2b28			;.lnuword:	pop hl 
2b28			;		call forth_tok_next 
2b28			;		jp .ldouscan  
2b28			 
2b28			.lunotfound:		  
2b28			 
2b28				if DEBUG_FORTH_WORDS 
2b28					DMARK "LSn" 
2b28 f5				push af  
2b29 3a 3d 2b			ld a, (.dmark)  
2b2c 32 71 ee			ld (debug_mark),a  
2b2f 3a 3e 2b			ld a, (.dmark+1)  
2b32 32 72 ee			ld (debug_mark+1),a  
2b35 3a 3f 2b			ld a, (.dmark+2)  
2b38 32 73 ee			ld (debug_mark+2),a  
2b3b 18 03			jr .pastdmark  
2b3d ..			.dmark: db "LSn"  
2b40 f1			.pastdmark: pop af  
2b41			endm  
# End of macro DMARK
2b41					CALLMONITOR 
2b41 cd e8 15			call break_point_state  
2b44				endm  
# End of macro CALLMONITOR
2b44				endif 
2b44			 
2b44					 
2b44			;		FORTH_DSP_POP 
2b44			;		ld hl, .luno 
2b44			 
2b44					NEXTW			 
2b44 c3 33 20			jp macro_next 
2b47				endm 
# End of macro NEXTW
2b47			 
2b47			.listpush: 
2b47				if DEBUG_FORTH_WORDS 
2b47					DMARK "LS>" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 71 ee			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 72 ee			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 73 ee			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "LS>"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60					CALLMONITOR 
2b60 cd e8 15			call break_point_state  
2b63				endm  
# End of macro CALLMONITOR
2b63				endif 
2b63 cd f4 1c				call forth_push_str 
2b66			 
2b66			 
2b66			 
2b66					NEXTW 
2b66 c3 33 20			jp macro_next 
2b69				endm 
# End of macro NEXTW
2b69			 
2b69			;.luno:    db "Word not found",0 
2b69			 
2b69			 
2b69			 
2b69			 
2b69			 
2b69			;		push hl   ; save pointer to start of uword def string 
2b69			; 
2b69			;; look for FORTH_EOL_LINE 
2b69			;		ld a, FORTH_END_BUFFER 
2b69			;		call strlent 
2b69			; 
2b69			;		inc hl		 ; space for coln def 
2b69			;		inc hl 
2b69			;		inc hl          ; space for terms 
2b69			;		inc hl 
2b69			; 
2b69			;		ld a, 20   ; TODO get actual length 
2b69			;		call addatohl    ; include a random amount of room for the uword name 
2b69			; 
2b69			;		 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "Lt1" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69			;		 
2b69			; 
2b69			;; malloc space for the string because we cant change it 
2b69			; 
2b69			;		call malloc 
2b69			;	if DEBUG_FORTH_MALLOC_GUARD 
2b69			;		push af 
2b69			;		call ishlzero 
2b69			;		pop af 
2b69			;		 
2b69			;		call z,malloc_error 
2b69			;	endif 
2b69			; 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "Lt2" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69			;		pop de 
2b69			;		push hl    ; push the malloc to release later 
2b69			;		push hl   ;  push back a copy for the later stack push 
2b69			;		 
2b69			;; copy the string swapping out the zero terms for spaces 
2b69			; 
2b69			;		; de has our source 
2b69			;		; hl has our dest 
2b69			; 
2b69			;; add the coln def 
2b69			; 
2b69			;		ld a, ':' 
2b69			;		ld (hl), a 
2b69			;		inc hl 
2b69			;		ld a, ' ' 
2b69			;		ld (hl), a 
2b69			;		inc hl 
2b69			; 
2b69			;; add the uname word 
2b69			;		push de   ; save our string for now 
2b69			;		ex de, hl 
2b69			; 
2b69			;		FORTH_DSP_VALUE 
2b69			;		;v5 FORTH_DSP_VALUE 
2b69			; 
2b69			;		inc hl   ; skip type but we know by now this is OK 
2b69			; 
2b69			;.luword:	ld a,(hl) 
2b69			;		cp 0 
2b69			;		jr z, .luword2 
2b69			;		ld (de), a 
2b69			;		inc de 
2b69			;		inc hl 
2b69			;		jr .luword 
2b69			; 
2b69			;.luword2:	ld a, ' ' 
2b69			;		ld (de), a 
2b69			;;		inc hl 
2b69			;;		inc de 
2b69			;;		ld (de), a 
2b69			;;		inc hl 
2b69			;		inc de 
2b69			; 
2b69			;		ex de, hl 
2b69			;		pop de 
2b69			;		 
2b69			;		 
2b69			; 
2b69			;; detoken that string and copy it 
2b69			; 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "Lt2" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69			;.ldetok:	ld a, (de) 
2b69			;		cp FORTH_END_BUFFER 
2b69			;		jr z, .ldetokend 
2b69			;		; swap out any zero term for space 
2b69			;		cp 0 
2b69			;		jr nz, .ldetoknext 
2b69			;		ld a, ' ' 
2b69			; 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "LtS" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69			;.ldetoknext:	ld (hl), a 
2b69			;		inc de 
2b69			;		inc hl 
2b69			;		jr .ldetok 
2b69			; 
2b69			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b69			;		ld (hl), a  
2b69			; 
2b69			;; free that temp malloc 
2b69			; 
2b69			;		pop hl    
2b69			; 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "Lt4" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69			;		call forth_apushstrhl 
2b69			; 
2b69			;		; get rid of temp malloc area 
2b69			; 
2b69			;		pop hl 
2b69			;		call free 
2b69			; 
2b69			;		jr .ludone 
2b69			; 
2b69			;.lnuword:	pop hl 
2b69			;		call forth_tok_next 
2b69			;		jp .ldouscan  
2b69			; 
2b69			;.ludone:		 pop hl 
2b69			; 
2b69					NEXTW 
2b69 c3 33 20			jp macro_next 
2b6c				endm 
# End of macro NEXTW
2b6c			 
2b6c			.FORGET: 
2b6c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b6c 5d				db WORD_SYS_CORE+73             
2b6d e5 2b			dw .NOP            
2b6f 07				db 6 + 1 
2b70 .. 00			db "FORGET",0              
2b77				endm 
# End of macro CWHEAD
2b77			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b77			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b77			; | |  
2b77			; | | e.g. "MORE" forget 
2b77					if DEBUG_FORTH_WORDS_KEY 
2b77						DMARK "FRG" 
2b77 f5				push af  
2b78 3a 8c 2b			ld a, (.dmark)  
2b7b 32 71 ee			ld (debug_mark),a  
2b7e 3a 8d 2b			ld a, (.dmark+1)  
2b81 32 72 ee			ld (debug_mark+1),a  
2b84 3a 8e 2b			ld a, (.dmark+2)  
2b87 32 73 ee			ld (debug_mark+2),a  
2b8a 18 03			jr .pastdmark  
2b8c ..			.dmark: db "FRG"  
2b8f f1			.pastdmark: pop af  
2b90			endm  
# End of macro DMARK
2b90						CALLMONITOR 
2b90 cd e8 15			call break_point_state  
2b93				endm  
# End of macro CALLMONITOR
2b93					endif 
2b93			 
2b93				; find uword 
2b93			        ; update start of word with "_" 
2b93				; replace uword with deleted flag 
2b93			 
2b93			 
2b93			;	if DEBUG_FORTH_WORDS 
2b93			;		DMARK "FOG" 
2b93			;		CALLMONITOR 
2b93			;	endif 
2b93			 
2b93			 
2b93					; Get ptr to the word we need to look up 
2b93			 
2b93					FORTH_DSP_VALUEHL 
2b93 cd 7d 1e			call macro_dsp_valuehl 
2b96				endm 
# End of macro FORTH_DSP_VALUEHL
2b96					;v5 FORTH_DSP_VALUE 
2b96				; TODO type check 
2b96			;		inc hl    ; Skip type check  
2b96 e5					push hl 
2b97 c1					pop bc 
2b98			;		ex de, hl    ; put into DE 
2b98			 
2b98			 
2b98 21 e0 64				ld hl, baseram 
2b9b					;ld hl, baseusermem 
2b9b			 
2b9b				; skip dict stub 
2b9b			;	call forth_tok_next 
2b9b e5			push hl   ; sacreifical push 
2b9c			 
2b9c			.fldouscanm: 
2b9c e1				pop hl 
2b9d			.fldouscan: 
2b9d			;	if DEBUG_FORTH_WORDS 
2b9d			;		DMARK "LSs" 
2b9d			;		CALLMONITOR 
2b9d			;	endif 
2b9d				; skip dict stub 
2b9d cd 84 21				call forth_tok_next 
2ba0			 
2ba0			 
2ba0			; while we have words to look for 
2ba0			 
2ba0 7e				ld a, (hl)      
2ba1			;	if DEBUG_FORTH_WORDS 
2ba1			;		DMARK "LSk" 
2ba1			;		CALLMONITOR 
2ba1			;	endif 
2ba1 fe 00				cp WORD_SYS_END 
2ba3 ca df 2b				jp z, .flunotfound 
2ba6 fe 01				cp WORD_SYS_UWORD 
2ba8 c2 9d 2b				jp nz, .fldouscan 
2bab			 
2bab			;	if DEBUG_FORTH_WORDS 
2bab			;		DMARK "LSu" 
2bab			;		CALLMONITOR 
2bab			;	endif 
2bab			 
2bab					; found a uword but is it the one we want... 
2bab			 
2bab c5					push bc     ; uword to find is on bc 
2bac d1					pop de 
2bad			 
2bad e5					push hl  ; to save the ptr 
2bae			 
2bae					; skip opcode 
2bae 23					inc hl  
2baf					; skip next ptr 
2baf 23					inc hl  
2bb0 23					inc hl 
2bb1					; skip len 
2bb1 23					inc hl 
2bb2			 
2bb2			;	if DEBUG_FORTH_WORDS 
2bb2			;		DMARK "LSc" 
2bb2			;		CALLMONITOR 
2bb2			;	endif 
2bb2 cd 7d 12				call strcmp 
2bb5 c2 9c 2b				jp nz, .fldouscanm 
2bb8			; 
2bb8			; 
2bb8			;; while we have words to look for 
2bb8			; 
2bb8			;.fdouscan:	ld a, (hl)      
2bb8			;	if DEBUG_FORTH_WORDS 
2bb8			;		DMARK "LSs" 
2bb8			;		CALLMONITOR 
2bb8			;	endif 
2bb8			;		cp WORD_SYS_END 
2bb8			;		jp z, .fudone 
2bb8			;		cp WORD_SYS_UWORD 
2bb8			;		jp nz, .fnuword 
2bb8			; 
2bb8			;	if DEBUG_FORTH_WORDS 
2bb8			;		DMARK "FGu" 
2bb8			;		CALLMONITOR 
2bb8			;	endif 
2bb8			; 
2bb8			;		; found a uword but is it the one we want... 
2bb8			; 
2bb8			; 
2bb8			;	        pop de   ; get back the dsp name 
2bb8			;		push de 
2bb8			; 
2bb8			;		push hl  ; to save the ptr 
2bb8			; 
2bb8			;		; skip opcode 
2bb8			;		inc hl  
2bb8			;		; skip next ptr 
2bb8			;		inc hl  
2bb8			;		inc hl 
2bb8			;		; skip len 
2bb8			;		inc hl 
2bb8			; 
2bb8			;	if DEBUG_FORTH_WORDS 
2bb8			;		DMARK "FGc" 
2bb8			;		CALLMONITOR 
2bb8			;	endif 
2bb8			;		call strcmp 
2bb8			;		jp nz, .fnuword 
2bb8			 
2bb8			 
2bb8 e1			pop hl 
2bb9			 
2bb9				 
2bb9				if DEBUG_FORTH_WORDS 
2bb9					DMARK "FGm" 
2bb9 f5				push af  
2bba 3a ce 2b			ld a, (.dmark)  
2bbd 32 71 ee			ld (debug_mark),a  
2bc0 3a cf 2b			ld a, (.dmark+1)  
2bc3 32 72 ee			ld (debug_mark+1),a  
2bc6 3a d0 2b			ld a, (.dmark+2)  
2bc9 32 73 ee			ld (debug_mark+2),a  
2bcc 18 03			jr .pastdmark  
2bce ..			.dmark: db "FGm"  
2bd1 f1			.pastdmark: pop af  
2bd2			endm  
# End of macro DMARK
2bd2					CALLMONITOR 
2bd2 cd e8 15			call break_point_state  
2bd5				endm  
# End of macro CALLMONITOR
2bd5				endif 
2bd5			 
2bd5			 
2bd5			 
2bd5					; we have a uword so push its name to the stack 
2bd5			 
2bd5			;	   	push hl  ; save so we can move to next dict block 
2bd5			;pop hl 
2bd5			 
2bd5					; update opcode to deleted 
2bd5 3e 03				ld a, WORD_SYS_DELETED 
2bd7 77					ld (hl), a 
2bd8			 
2bd8 23					inc hl  
2bd9					; skip next ptr 
2bd9 23					inc hl  
2bda 23					inc hl 
2bdb					; skip len 
2bdb 23					inc hl 
2bdc			 
2bdc					; TODO change parser to skip deleted words but for now mark it out 
2bdc 3e 5f				ld a, "_" 
2bde 77					ld  (hl),a 
2bdf			 
2bdf			;		jr .fudone 
2bdf			; 
2bdf			;.fnuword:	pop hl 
2bdf			;		call forth_tok_next 
2bdf			;		jp .fdouscan  
2bdf			 
2bdf			.flunotfound:		  
2bdf			 
2bdf			 
2bdf					 
2bdf					FORTH_DSP_POP 
2bdf cd 35 1f			call macro_forth_dsp_pop 
2be2				endm 
# End of macro FORTH_DSP_POP
2be2			;		ld hl, .luno 
2be2			;.fudone:		 pop hl 
2be2					NEXTW 
2be2 c3 33 20			jp macro_next 
2be5				endm 
# End of macro NEXTW
2be5			.NOP: 
2be5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2be5 61				db WORD_SYS_CORE+77             
2be6 0c 2c			dw .COMO            
2be8 04				db 3 + 1 
2be9 .. 00			db "NOP",0              
2bed				endm 
# End of macro CWHEAD
2bed			; | NOP (  --  ) Do nothing | DONE 
2bed					if DEBUG_FORTH_WORDS_KEY 
2bed						DMARK "NOP" 
2bed f5				push af  
2bee 3a 02 2c			ld a, (.dmark)  
2bf1 32 71 ee			ld (debug_mark),a  
2bf4 3a 03 2c			ld a, (.dmark+1)  
2bf7 32 72 ee			ld (debug_mark+1),a  
2bfa 3a 04 2c			ld a, (.dmark+2)  
2bfd 32 73 ee			ld (debug_mark+2),a  
2c00 18 03			jr .pastdmark  
2c02 ..			.dmark: db "NOP"  
2c05 f1			.pastdmark: pop af  
2c06			endm  
# End of macro DMARK
2c06						CALLMONITOR 
2c06 cd e8 15			call break_point_state  
2c09				endm  
# End of macro CALLMONITOR
2c09					endif 
2c09				       NEXTW 
2c09 c3 33 20			jp macro_next 
2c0c				endm 
# End of macro NEXTW
2c0c			.COMO: 
2c0c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c0c 6e				db WORD_SYS_CORE+90             
2c0d 5e 2c			dw .COMC            
2c0f 02				db 1 + 1 
2c10 .. 00			db "(",0              
2c12				endm 
# End of macro CWHEAD
2c12			; | ( ( -- )  Start of comment | DONE 
2c12			 
2c12			 
2c12 2a c8 e5				ld hl, ( os_tok_ptr) 
2c15 11 59 2c			ld de, .closepar 
2c18					 
2c18					if DEBUG_FORTH_WORDS 
2c18						DMARK ").." 
2c18 f5				push af  
2c19 3a 2d 2c			ld a, (.dmark)  
2c1c 32 71 ee			ld (debug_mark),a  
2c1f 3a 2e 2c			ld a, (.dmark+1)  
2c22 32 72 ee			ld (debug_mark+1),a  
2c25 3a 2f 2c			ld a, (.dmark+2)  
2c28 32 73 ee			ld (debug_mark+2),a  
2c2b 18 03			jr .pastdmark  
2c2d ..			.dmark: db ").."  
2c30 f1			.pastdmark: pop af  
2c31			endm  
# End of macro DMARK
2c31						CALLMONITOR 
2c31 cd e8 15			call break_point_state  
2c34				endm  
# End of macro CALLMONITOR
2c34					endif 
2c34 cd 4e 21			call findnexttok  
2c37			 
2c37					if DEBUG_FORTH_WORDS 
2c37						DMARK "IF5" 
2c37 f5				push af  
2c38 3a 4c 2c			ld a, (.dmark)  
2c3b 32 71 ee			ld (debug_mark),a  
2c3e 3a 4d 2c			ld a, (.dmark+1)  
2c41 32 72 ee			ld (debug_mark+1),a  
2c44 3a 4e 2c			ld a, (.dmark+2)  
2c47 32 73 ee			ld (debug_mark+2),a  
2c4a 18 03			jr .pastdmark  
2c4c ..			.dmark: db "IF5"  
2c4f f1			.pastdmark: pop af  
2c50			endm  
# End of macro DMARK
2c50						CALLMONITOR 
2c50 cd e8 15			call break_point_state  
2c53				endm  
# End of macro CALLMONITOR
2c53					endif 
2c53				; replace below with ) exec using tok_ptr 
2c53 22 c8 e5			ld (os_tok_ptr), hl 
2c56 c3 c4 20			jp exec1 
2c59			 
2c59 .. 00			.closepar:   db ")",0 
2c5b			 
2c5b				       NEXTW 
2c5b c3 33 20			jp macro_next 
2c5e				endm 
# End of macro NEXTW
2c5e			.COMC: 
2c5e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c5e 6f				db WORD_SYS_CORE+91             
2c5f 67 2c			dw .SCRATCH            
2c61 02				db 1 + 1 
2c62 .. 00			db ")",0              
2c64				endm 
# End of macro CWHEAD
2c64			; | ) ( -- )  End of comment |  DONE  
2c64				       NEXTW 
2c64 c3 33 20			jp macro_next 
2c67				endm 
# End of macro NEXTW
2c67			 
2c67			.SCRATCH: 
2c67				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c67 6f				db WORD_SYS_CORE+91             
2c68 a2 2c			dw .INC            
2c6a 08				db 7 + 1 
2c6b .. 00			db "SCRATCH",0              
2c73				endm 
# End of macro CWHEAD
2c73			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c73			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c73			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c73			; | |  
2c73			; | | e.g.    : score $00 scratch ; 
2c73			; | |  
2c73			; | | $00 score ! 
2c73			; | | $01 score +! 
2c73			; | |  
2c73			; | | e.g.   : varword $0a scratch ;  
2c73			; | | 
2c73			; | | $8000 varword ! 
2c73					if DEBUG_FORTH_WORDS_KEY 
2c73						DMARK "SCR" 
2c73 f5				push af  
2c74 3a 88 2c			ld a, (.dmark)  
2c77 32 71 ee			ld (debug_mark),a  
2c7a 3a 89 2c			ld a, (.dmark+1)  
2c7d 32 72 ee			ld (debug_mark+1),a  
2c80 3a 8a 2c			ld a, (.dmark+2)  
2c83 32 73 ee			ld (debug_mark+2),a  
2c86 18 03			jr .pastdmark  
2c88 ..			.dmark: db "SCR"  
2c8b f1			.pastdmark: pop af  
2c8c			endm  
# End of macro DMARK
2c8c						CALLMONITOR 
2c8c cd e8 15			call break_point_state  
2c8f				endm  
# End of macro CALLMONITOR
2c8f					endif 
2c8f			 
2c8f					FORTH_DSP_VALUEHL 
2c8f cd 7d 1e			call macro_dsp_valuehl 
2c92				endm 
# End of macro FORTH_DSP_VALUEHL
2c92				 
2c92					FORTH_DSP_POP 
2c92 cd 35 1f			call macro_forth_dsp_pop 
2c95				endm 
# End of macro FORTH_DSP_POP
2c95			 
2c95 7d					ld a, l 
2c96 21 ec e7				ld hl, os_var_array 
2c99 cd e7 0d				call addatohl 
2c9c			 
2c9c cd 86 1c				call forth_push_numhl 
2c9f			 
2c9f				       NEXTW 
2c9f c3 33 20			jp macro_next 
2ca2				endm 
# End of macro NEXTW
2ca2			 
2ca2			.INC: 
2ca2				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ca2 6f				db WORD_SYS_CORE+91             
2ca3 f6 2c			dw .DEC            
2ca5 03				db 2 + 1 
2ca6 .. 00			db "+!",0              
2ca9				endm 
# End of macro CWHEAD
2ca9			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ca9					if DEBUG_FORTH_WORDS_KEY 
2ca9						DMARK "+s_" 
2ca9 f5				push af  
2caa 3a be 2c			ld a, (.dmark)  
2cad 32 71 ee			ld (debug_mark),a  
2cb0 3a bf 2c			ld a, (.dmark+1)  
2cb3 32 72 ee			ld (debug_mark+1),a  
2cb6 3a c0 2c			ld a, (.dmark+2)  
2cb9 32 73 ee			ld (debug_mark+2),a  
2cbc 18 03			jr .pastdmark  
2cbe ..			.dmark: db "+s_"  
2cc1 f1			.pastdmark: pop af  
2cc2			endm  
# End of macro DMARK
2cc2						CALLMONITOR 
2cc2 cd e8 15			call break_point_state  
2cc5				endm  
# End of macro CALLMONITOR
2cc5					endif 
2cc5			 
2cc5					FORTH_DSP_VALUEHL 
2cc5 cd 7d 1e			call macro_dsp_valuehl 
2cc8				endm 
# End of macro FORTH_DSP_VALUEHL
2cc8			 
2cc8 e5					push hl   ; save address 
2cc9			 
2cc9					FORTH_DSP_POP 
2cc9 cd 35 1f			call macro_forth_dsp_pop 
2ccc				endm 
# End of macro FORTH_DSP_POP
2ccc			 
2ccc					FORTH_DSP_VALUEHL 
2ccc cd 7d 1e			call macro_dsp_valuehl 
2ccf				endm 
# End of macro FORTH_DSP_VALUEHL
2ccf			 
2ccf					FORTH_DSP_POP 
2ccf cd 35 1f			call macro_forth_dsp_pop 
2cd2				endm 
# End of macro FORTH_DSP_POP
2cd2			 
2cd2					; hl contains value to add to byte at a 
2cd2				 
2cd2 eb					ex de, hl 
2cd3			 
2cd3 e1					pop hl 
2cd4			 
2cd4					if DEBUG_FORTH_WORDS 
2cd4						DMARK "INC" 
2cd4 f5				push af  
2cd5 3a e9 2c			ld a, (.dmark)  
2cd8 32 71 ee			ld (debug_mark),a  
2cdb 3a ea 2c			ld a, (.dmark+1)  
2cde 32 72 ee			ld (debug_mark+1),a  
2ce1 3a eb 2c			ld a, (.dmark+2)  
2ce4 32 73 ee			ld (debug_mark+2),a  
2ce7 18 03			jr .pastdmark  
2ce9 ..			.dmark: db "INC"  
2cec f1			.pastdmark: pop af  
2ced			endm  
# End of macro DMARK
2ced						CALLMONITOR 
2ced cd e8 15			call break_point_state  
2cf0				endm  
# End of macro CALLMONITOR
2cf0					endif 
2cf0			 
2cf0 7e					ld a,(hl) 
2cf1 83					add e 
2cf2 77					ld (hl),a 
2cf3			 
2cf3			 
2cf3			 
2cf3				       NEXTW 
2cf3 c3 33 20			jp macro_next 
2cf6				endm 
# End of macro NEXTW
2cf6			 
2cf6			.DEC: 
2cf6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cf6 6f				db WORD_SYS_CORE+91             
2cf7 47 2d			dw .INC2            
2cf9 03				db 2 + 1 
2cfa .. 00			db "-!",0              
2cfd				endm 
# End of macro CWHEAD
2cfd			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cfd					if DEBUG_FORTH_WORDS_KEY 
2cfd						DMARK "-s_" 
2cfd f5				push af  
2cfe 3a 12 2d			ld a, (.dmark)  
2d01 32 71 ee			ld (debug_mark),a  
2d04 3a 13 2d			ld a, (.dmark+1)  
2d07 32 72 ee			ld (debug_mark+1),a  
2d0a 3a 14 2d			ld a, (.dmark+2)  
2d0d 32 73 ee			ld (debug_mark+2),a  
2d10 18 03			jr .pastdmark  
2d12 ..			.dmark: db "-s_"  
2d15 f1			.pastdmark: pop af  
2d16			endm  
# End of macro DMARK
2d16						CALLMONITOR 
2d16 cd e8 15			call break_point_state  
2d19				endm  
# End of macro CALLMONITOR
2d19					endif 
2d19			 
2d19					FORTH_DSP_VALUEHL 
2d19 cd 7d 1e			call macro_dsp_valuehl 
2d1c				endm 
# End of macro FORTH_DSP_VALUEHL
2d1c			 
2d1c e5					push hl   ; save address 
2d1d			 
2d1d					FORTH_DSP_POP 
2d1d cd 35 1f			call macro_forth_dsp_pop 
2d20				endm 
# End of macro FORTH_DSP_POP
2d20			 
2d20					FORTH_DSP_VALUEHL 
2d20 cd 7d 1e			call macro_dsp_valuehl 
2d23				endm 
# End of macro FORTH_DSP_VALUEHL
2d23			 
2d23					; hl contains value to add to byte at a 
2d23				 
2d23 eb					ex de, hl 
2d24			 
2d24 e1					pop hl 
2d25			 
2d25					if DEBUG_FORTH_WORDS 
2d25						DMARK "DEC" 
2d25 f5				push af  
2d26 3a 3a 2d			ld a, (.dmark)  
2d29 32 71 ee			ld (debug_mark),a  
2d2c 3a 3b 2d			ld a, (.dmark+1)  
2d2f 32 72 ee			ld (debug_mark+1),a  
2d32 3a 3c 2d			ld a, (.dmark+2)  
2d35 32 73 ee			ld (debug_mark+2),a  
2d38 18 03			jr .pastdmark  
2d3a ..			.dmark: db "DEC"  
2d3d f1			.pastdmark: pop af  
2d3e			endm  
# End of macro DMARK
2d3e						CALLMONITOR 
2d3e cd e8 15			call break_point_state  
2d41				endm  
# End of macro CALLMONITOR
2d41					endif 
2d41			 
2d41 7e					ld a,(hl) 
2d42 93					sub e 
2d43 77					ld (hl),a 
2d44			 
2d44			 
2d44			 
2d44				       NEXTW 
2d44 c3 33 20			jp macro_next 
2d47				endm 
# End of macro NEXTW
2d47			 
2d47			.INC2: 
2d47				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d47 6f				db WORD_SYS_CORE+91             
2d48 f1 2d			dw .DEC2            
2d4a 04				db 3 + 1 
2d4b .. 00			db "+2!",0              
2d4f				endm 
# End of macro CWHEAD
2d4f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d4f			 
2d4f					if DEBUG_FORTH_WORDS_KEY 
2d4f						DMARK "+2s" 
2d4f f5				push af  
2d50 3a 64 2d			ld a, (.dmark)  
2d53 32 71 ee			ld (debug_mark),a  
2d56 3a 65 2d			ld a, (.dmark+1)  
2d59 32 72 ee			ld (debug_mark+1),a  
2d5c 3a 66 2d			ld a, (.dmark+2)  
2d5f 32 73 ee			ld (debug_mark+2),a  
2d62 18 03			jr .pastdmark  
2d64 ..			.dmark: db "+2s"  
2d67 f1			.pastdmark: pop af  
2d68			endm  
# End of macro DMARK
2d68						CALLMONITOR 
2d68 cd e8 15			call break_point_state  
2d6b				endm  
# End of macro CALLMONITOR
2d6b					endif 
2d6b			 
2d6b					; Address 
2d6b			 
2d6b					FORTH_DSP_VALUEHL 
2d6b cd 7d 1e			call macro_dsp_valuehl 
2d6e				endm 
# End of macro FORTH_DSP_VALUEHL
2d6e			 
2d6e e5					push hl    ; save address 
2d6f			 
2d6f					; load content into de 
2d6f			 
2d6f 5e					ld e,(hl) 
2d70 23					inc hl 
2d71 56					ld d, (hl) 
2d72			 
2d72					if DEBUG_FORTH_WORDS 
2d72						DMARK "+2a" 
2d72 f5				push af  
2d73 3a 87 2d			ld a, (.dmark)  
2d76 32 71 ee			ld (debug_mark),a  
2d79 3a 88 2d			ld a, (.dmark+1)  
2d7c 32 72 ee			ld (debug_mark+1),a  
2d7f 3a 89 2d			ld a, (.dmark+2)  
2d82 32 73 ee			ld (debug_mark+2),a  
2d85 18 03			jr .pastdmark  
2d87 ..			.dmark: db "+2a"  
2d8a f1			.pastdmark: pop af  
2d8b			endm  
# End of macro DMARK
2d8b						CALLMONITOR 
2d8b cd e8 15			call break_point_state  
2d8e				endm  
# End of macro CALLMONITOR
2d8e					endif 
2d8e			 
2d8e					FORTH_DSP_POP 
2d8e cd 35 1f			call macro_forth_dsp_pop 
2d91				endm 
# End of macro FORTH_DSP_POP
2d91			 
2d91					; Get value to add 
2d91			 
2d91					FORTH_DSP_VALUE 
2d91 cd 66 1e			call macro_forth_dsp_value 
2d94				endm 
# End of macro FORTH_DSP_VALUE
2d94			 
2d94					if DEBUG_FORTH_WORDS 
2d94						DMARK "+2v" 
2d94 f5				push af  
2d95 3a a9 2d			ld a, (.dmark)  
2d98 32 71 ee			ld (debug_mark),a  
2d9b 3a aa 2d			ld a, (.dmark+1)  
2d9e 32 72 ee			ld (debug_mark+1),a  
2da1 3a ab 2d			ld a, (.dmark+2)  
2da4 32 73 ee			ld (debug_mark+2),a  
2da7 18 03			jr .pastdmark  
2da9 ..			.dmark: db "+2v"  
2dac f1			.pastdmark: pop af  
2dad			endm  
# End of macro DMARK
2dad						CALLMONITOR 
2dad cd e8 15			call break_point_state  
2db0				endm  
# End of macro CALLMONITOR
2db0					endif 
2db0			 
2db0 19					add hl, de 
2db1			 
2db1					if DEBUG_FORTH_WORDS 
2db1						DMARK "+2+" 
2db1 f5				push af  
2db2 3a c6 2d			ld a, (.dmark)  
2db5 32 71 ee			ld (debug_mark),a  
2db8 3a c7 2d			ld a, (.dmark+1)  
2dbb 32 72 ee			ld (debug_mark+1),a  
2dbe 3a c8 2d			ld a, (.dmark+2)  
2dc1 32 73 ee			ld (debug_mark+2),a  
2dc4 18 03			jr .pastdmark  
2dc6 ..			.dmark: db "+2+"  
2dc9 f1			.pastdmark: pop af  
2dca			endm  
# End of macro DMARK
2dca						CALLMONITOR 
2dca cd e8 15			call break_point_state  
2dcd				endm  
# End of macro CALLMONITOR
2dcd					endif 
2dcd			 
2dcd					; move result to de 
2dcd			 
2dcd eb					ex de, hl 
2dce			 
2dce					; Address 
2dce			 
2dce e1					pop hl 
2dcf			 
2dcf					; save it back 
2dcf			 
2dcf 73					ld (hl), e 
2dd0 23					inc hl 
2dd1 72					ld (hl), d 
2dd2			 
2dd2					if DEBUG_FORTH_WORDS 
2dd2						DMARK "+2e" 
2dd2 f5				push af  
2dd3 3a e7 2d			ld a, (.dmark)  
2dd6 32 71 ee			ld (debug_mark),a  
2dd9 3a e8 2d			ld a, (.dmark+1)  
2ddc 32 72 ee			ld (debug_mark+1),a  
2ddf 3a e9 2d			ld a, (.dmark+2)  
2de2 32 73 ee			ld (debug_mark+2),a  
2de5 18 03			jr .pastdmark  
2de7 ..			.dmark: db "+2e"  
2dea f1			.pastdmark: pop af  
2deb			endm  
# End of macro DMARK
2deb						CALLMONITOR 
2deb cd e8 15			call break_point_state  
2dee				endm  
# End of macro CALLMONITOR
2dee					endif 
2dee			 
2dee			 
2dee			 
2dee			 
2dee			 
2dee				       NEXTW 
2dee c3 33 20			jp macro_next 
2df1				endm 
# End of macro NEXTW
2df1			 
2df1			.DEC2: 
2df1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2df1 6f				db WORD_SYS_CORE+91             
2df2 9d 2e			dw .GET2            
2df4 04				db 3 + 1 
2df5 .. 00			db "-2!",0              
2df9				endm 
# End of macro CWHEAD
2df9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2df9			 
2df9			 
2df9					if DEBUG_FORTH_WORDS_KEY 
2df9						DMARK "-2s" 
2df9 f5				push af  
2dfa 3a 0e 2e			ld a, (.dmark)  
2dfd 32 71 ee			ld (debug_mark),a  
2e00 3a 0f 2e			ld a, (.dmark+1)  
2e03 32 72 ee			ld (debug_mark+1),a  
2e06 3a 10 2e			ld a, (.dmark+2)  
2e09 32 73 ee			ld (debug_mark+2),a  
2e0c 18 03			jr .pastdmark  
2e0e ..			.dmark: db "-2s"  
2e11 f1			.pastdmark: pop af  
2e12			endm  
# End of macro DMARK
2e12						CALLMONITOR 
2e12 cd e8 15			call break_point_state  
2e15				endm  
# End of macro CALLMONITOR
2e15					endif 
2e15			 
2e15					; Address 
2e15			 
2e15					FORTH_DSP_VALUEHL 
2e15 cd 7d 1e			call macro_dsp_valuehl 
2e18				endm 
# End of macro FORTH_DSP_VALUEHL
2e18			 
2e18 e5					push hl    ; save address 
2e19			 
2e19					; load content into de 
2e19			 
2e19 5e					ld e,(hl) 
2e1a 23					inc hl 
2e1b 56					ld d, (hl) 
2e1c			 
2e1c					if DEBUG_FORTH_WORDS 
2e1c						DMARK "-2a" 
2e1c f5				push af  
2e1d 3a 31 2e			ld a, (.dmark)  
2e20 32 71 ee			ld (debug_mark),a  
2e23 3a 32 2e			ld a, (.dmark+1)  
2e26 32 72 ee			ld (debug_mark+1),a  
2e29 3a 33 2e			ld a, (.dmark+2)  
2e2c 32 73 ee			ld (debug_mark+2),a  
2e2f 18 03			jr .pastdmark  
2e31 ..			.dmark: db "-2a"  
2e34 f1			.pastdmark: pop af  
2e35			endm  
# End of macro DMARK
2e35						CALLMONITOR 
2e35 cd e8 15			call break_point_state  
2e38				endm  
# End of macro CALLMONITOR
2e38					endif 
2e38			 
2e38					FORTH_DSP_POP 
2e38 cd 35 1f			call macro_forth_dsp_pop 
2e3b				endm 
# End of macro FORTH_DSP_POP
2e3b			 
2e3b					; Get value to remove 
2e3b			 
2e3b					FORTH_DSP_VALUE 
2e3b cd 66 1e			call macro_forth_dsp_value 
2e3e				endm 
# End of macro FORTH_DSP_VALUE
2e3e			 
2e3e					if DEBUG_FORTH_WORDS 
2e3e						DMARK "-2v" 
2e3e f5				push af  
2e3f 3a 53 2e			ld a, (.dmark)  
2e42 32 71 ee			ld (debug_mark),a  
2e45 3a 54 2e			ld a, (.dmark+1)  
2e48 32 72 ee			ld (debug_mark+1),a  
2e4b 3a 55 2e			ld a, (.dmark+2)  
2e4e 32 73 ee			ld (debug_mark+2),a  
2e51 18 03			jr .pastdmark  
2e53 ..			.dmark: db "-2v"  
2e56 f1			.pastdmark: pop af  
2e57			endm  
# End of macro DMARK
2e57						CALLMONITOR 
2e57 cd e8 15			call break_point_state  
2e5a				endm  
# End of macro CALLMONITOR
2e5a					endif 
2e5a			 
2e5a eb					ex de, hl 
2e5b ed 52				sbc hl, de 
2e5d			 
2e5d					if DEBUG_FORTH_WORDS 
2e5d						DMARK "-2d" 
2e5d f5				push af  
2e5e 3a 72 2e			ld a, (.dmark)  
2e61 32 71 ee			ld (debug_mark),a  
2e64 3a 73 2e			ld a, (.dmark+1)  
2e67 32 72 ee			ld (debug_mark+1),a  
2e6a 3a 74 2e			ld a, (.dmark+2)  
2e6d 32 73 ee			ld (debug_mark+2),a  
2e70 18 03			jr .pastdmark  
2e72 ..			.dmark: db "-2d"  
2e75 f1			.pastdmark: pop af  
2e76			endm  
# End of macro DMARK
2e76						CALLMONITOR 
2e76 cd e8 15			call break_point_state  
2e79				endm  
# End of macro CALLMONITOR
2e79					endif 
2e79			 
2e79					; move result to de 
2e79			 
2e79 eb					ex de, hl 
2e7a			 
2e7a					; Address 
2e7a			 
2e7a e1					pop hl 
2e7b			 
2e7b					; save it back 
2e7b			 
2e7b 73					ld (hl), e 
2e7c 23					inc hl 
2e7d 72					ld (hl), d 
2e7e			 
2e7e					if DEBUG_FORTH_WORDS 
2e7e						DMARK "-2e" 
2e7e f5				push af  
2e7f 3a 93 2e			ld a, (.dmark)  
2e82 32 71 ee			ld (debug_mark),a  
2e85 3a 94 2e			ld a, (.dmark+1)  
2e88 32 72 ee			ld (debug_mark+1),a  
2e8b 3a 95 2e			ld a, (.dmark+2)  
2e8e 32 73 ee			ld (debug_mark+2),a  
2e91 18 03			jr .pastdmark  
2e93 ..			.dmark: db "-2e"  
2e96 f1			.pastdmark: pop af  
2e97			endm  
# End of macro DMARK
2e97						CALLMONITOR 
2e97 cd e8 15			call break_point_state  
2e9a				endm  
# End of macro CALLMONITOR
2e9a					endif 
2e9a			 
2e9a			 
2e9a			 
2e9a			 
2e9a			 
2e9a				       NEXTW 
2e9a c3 33 20			jp macro_next 
2e9d				endm 
# End of macro NEXTW
2e9d			.GET2: 
2e9d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e9d 6f				db WORD_SYS_CORE+91             
2e9e cd 2e			dw .BANG2            
2ea0 03				db 2 + 1 
2ea1 .. 00			db "2@",0              
2ea4				endm 
# End of macro CWHEAD
2ea4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ea4					if DEBUG_FORTH_WORDS_KEY 
2ea4						DMARK "2A_" 
2ea4 f5				push af  
2ea5 3a b9 2e			ld a, (.dmark)  
2ea8 32 71 ee			ld (debug_mark),a  
2eab 3a ba 2e			ld a, (.dmark+1)  
2eae 32 72 ee			ld (debug_mark+1),a  
2eb1 3a bb 2e			ld a, (.dmark+2)  
2eb4 32 73 ee			ld (debug_mark+2),a  
2eb7 18 03			jr .pastdmark  
2eb9 ..			.dmark: db "2A_"  
2ebc f1			.pastdmark: pop af  
2ebd			endm  
# End of macro DMARK
2ebd						CALLMONITOR 
2ebd cd e8 15			call break_point_state  
2ec0				endm  
# End of macro CALLMONITOR
2ec0					endif 
2ec0			 
2ec0					FORTH_DSP_VALUEHL 
2ec0 cd 7d 1e			call macro_dsp_valuehl 
2ec3				endm 
# End of macro FORTH_DSP_VALUEHL
2ec3			 
2ec3 5e					ld e, (hl) 
2ec4 23					inc hl 
2ec5 56					ld d, (hl) 
2ec6			 
2ec6 eb					ex de, hl 
2ec7			 
2ec7 cd 86 1c				call forth_push_numhl 
2eca			 
2eca				       NEXTW 
2eca c3 33 20			jp macro_next 
2ecd				endm 
# End of macro NEXTW
2ecd			.BANG2: 
2ecd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ecd 6f				db WORD_SYS_CORE+91             
2ece 05 2f			dw .CONFIG            
2ed0 03				db 2 + 1 
2ed1 .. 00			db "2!",0              
2ed4				endm 
# End of macro CWHEAD
2ed4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ed4					if DEBUG_FORTH_WORDS_KEY 
2ed4						DMARK "2S_" 
2ed4 f5				push af  
2ed5 3a e9 2e			ld a, (.dmark)  
2ed8 32 71 ee			ld (debug_mark),a  
2edb 3a ea 2e			ld a, (.dmark+1)  
2ede 32 72 ee			ld (debug_mark+1),a  
2ee1 3a eb 2e			ld a, (.dmark+2)  
2ee4 32 73 ee			ld (debug_mark+2),a  
2ee7 18 03			jr .pastdmark  
2ee9 ..			.dmark: db "2S_"  
2eec f1			.pastdmark: pop af  
2eed			endm  
# End of macro DMARK
2eed						CALLMONITOR 
2eed cd e8 15			call break_point_state  
2ef0				endm  
# End of macro CALLMONITOR
2ef0					endif 
2ef0			 
2ef0					FORTH_DSP_VALUEHL 
2ef0 cd 7d 1e			call macro_dsp_valuehl 
2ef3				endm 
# End of macro FORTH_DSP_VALUEHL
2ef3			 
2ef3 e5					push hl   ; save address 
2ef4			 
2ef4			 
2ef4					FORTH_DSP_POP 
2ef4 cd 35 1f			call macro_forth_dsp_pop 
2ef7				endm 
# End of macro FORTH_DSP_POP
2ef7			 
2ef7					 
2ef7					FORTH_DSP_VALUEHL 
2ef7 cd 7d 1e			call macro_dsp_valuehl 
2efa				endm 
# End of macro FORTH_DSP_VALUEHL
2efa			 
2efa					FORTH_DSP_POP 
2efa cd 35 1f			call macro_forth_dsp_pop 
2efd				endm 
# End of macro FORTH_DSP_POP
2efd			 
2efd eb					ex de, hl    ; value now in de 
2efe			 
2efe e1					pop hl 
2eff			 
2eff 73					ld (hl), e 
2f00			 
2f00 23					inc hl 
2f01			 
2f01 72					ld (hl), d 
2f02			 
2f02			 
2f02				       NEXTW 
2f02 c3 33 20			jp macro_next 
2f05				endm 
# End of macro NEXTW
2f05			.CONFIG: 
2f05				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f05 6f				db WORD_SYS_CORE+91             
2f06 16 2f			dw .ENDCORE            
2f08 07				db 6 + 1 
2f09 .. 00			db "CONFIG",0              
2f10				endm 
# End of macro CWHEAD
2f10			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f10			 
2f10 cd 47 14				call config 
2f13					NEXTW 
2f13 c3 33 20			jp macro_next 
2f16				endm 
# End of macro NEXTW
2f16			.ENDCORE: 
2f16			 
2f16			; eof 
2f16			 
2f16			 
# End of file forth_words_core.asm
2f16			include "forth_words_flow.asm" 
2f16			 
2f16			; | ## Program Flow Words 
2f16			 
2f16			.IF: 
2f16				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f16 1e				db WORD_SYS_CORE+10             
2f17 0b 30			dw .THEN            
2f19 03				db 2 + 1 
2f1a .. 00			db "IF",0              
2f1d				endm 
# End of macro CWHEAD
2f1d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f1d			; 
2f1d					if DEBUG_FORTH_WORDS_KEY 
2f1d						DMARK "IF." 
2f1d f5				push af  
2f1e 3a 32 2f			ld a, (.dmark)  
2f21 32 71 ee			ld (debug_mark),a  
2f24 3a 33 2f			ld a, (.dmark+1)  
2f27 32 72 ee			ld (debug_mark+1),a  
2f2a 3a 34 2f			ld a, (.dmark+2)  
2f2d 32 73 ee			ld (debug_mark+2),a  
2f30 18 03			jr .pastdmark  
2f32 ..			.dmark: db "IF."  
2f35 f1			.pastdmark: pop af  
2f36			endm  
# End of macro DMARK
2f36						CALLMONITOR 
2f36 cd e8 15			call break_point_state  
2f39				endm  
# End of macro CALLMONITOR
2f39					endif 
2f39			; eval TOS 
2f39			 
2f39				FORTH_DSP_VALUEHL 
2f39 cd 7d 1e			call macro_dsp_valuehl 
2f3c				endm 
# End of macro FORTH_DSP_VALUEHL
2f3c			 
2f3c			;	push hl 
2f3c				FORTH_DSP_POP 
2f3c cd 35 1f			call macro_forth_dsp_pop 
2f3f				endm 
# End of macro FORTH_DSP_POP
2f3f			;	pop hl 
2f3f			 
2f3f					if DEBUG_FORTH_WORDS 
2f3f						DMARK "IF1" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 71 ee			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 72 ee			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 73 ee			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "IF1"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58						CALLMONITOR 
2f58 cd e8 15			call break_point_state  
2f5b				endm  
# End of macro CALLMONITOR
2f5b					endif 
2f5b b7				or a        ; clear carry flag 
2f5c 11 00 00			ld de, 0 
2f5f eb				ex de,hl 
2f60 ed 52			sbc hl, de 
2f62 c2 ec 2f			jp nz, .iftrue 
2f65			 
2f65					if DEBUG_FORTH_WORDS 
2f65						DMARK "IF2" 
2f65 f5				push af  
2f66 3a 7a 2f			ld a, (.dmark)  
2f69 32 71 ee			ld (debug_mark),a  
2f6c 3a 7b 2f			ld a, (.dmark+1)  
2f6f 32 72 ee			ld (debug_mark+1),a  
2f72 3a 7c 2f			ld a, (.dmark+2)  
2f75 32 73 ee			ld (debug_mark+2),a  
2f78 18 03			jr .pastdmark  
2f7a ..			.dmark: db "IF2"  
2f7d f1			.pastdmark: pop af  
2f7e			endm  
# End of macro DMARK
2f7e						CALLMONITOR 
2f7e cd e8 15			call break_point_state  
2f81				endm  
# End of macro CALLMONITOR
2f81					endif 
2f81			 
2f81			; if not true then skip to THEN 
2f81			 
2f81				; TODO get tok_ptr 
2f81				; TODO consume toks until we get to THEN 
2f81			 
2f81 2a c8 e5			ld hl, (os_tok_ptr) 
2f84					if DEBUG_FORTH_WORDS 
2f84						DMARK "IF3" 
2f84 f5				push af  
2f85 3a 99 2f			ld a, (.dmark)  
2f88 32 71 ee			ld (debug_mark),a  
2f8b 3a 9a 2f			ld a, (.dmark+1)  
2f8e 32 72 ee			ld (debug_mark+1),a  
2f91 3a 9b 2f			ld a, (.dmark+2)  
2f94 32 73 ee			ld (debug_mark+2),a  
2f97 18 03			jr .pastdmark  
2f99 ..			.dmark: db "IF3"  
2f9c f1			.pastdmark: pop af  
2f9d			endm  
# End of macro DMARK
2f9d						CALLMONITOR 
2f9d cd e8 15			call break_point_state  
2fa0				endm  
# End of macro CALLMONITOR
2fa0						 
2fa0					endif 
2fa0 11 e7 2f			ld de, .ifthen 
2fa3					if DEBUG_FORTH_WORDS 
2fa3						DMARK "IF4" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 71 ee			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 72 ee			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 73 ee			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "IF4"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd e8 15			call break_point_state  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf cd 4e 21			call findnexttok  
2fc2			 
2fc2					if DEBUG_FORTH_WORDS 
2fc2						DMARK "IF5" 
2fc2 f5				push af  
2fc3 3a d7 2f			ld a, (.dmark)  
2fc6 32 71 ee			ld (debug_mark),a  
2fc9 3a d8 2f			ld a, (.dmark+1)  
2fcc 32 72 ee			ld (debug_mark+1),a  
2fcf 3a d9 2f			ld a, (.dmark+2)  
2fd2 32 73 ee			ld (debug_mark+2),a  
2fd5 18 03			jr .pastdmark  
2fd7 ..			.dmark: db "IF5"  
2fda f1			.pastdmark: pop af  
2fdb			endm  
# End of macro DMARK
2fdb						CALLMONITOR 
2fdb cd e8 15			call break_point_state  
2fde				endm  
# End of macro CALLMONITOR
2fde					endif 
2fde				; TODO replace below with ; exec using tok_ptr 
2fde 22 c8 e5			ld (os_tok_ptr), hl 
2fe1 c3 c4 20			jp exec1 
2fe4				NEXTW 
2fe4 c3 33 20			jp macro_next 
2fe7				endm 
# End of macro NEXTW
2fe7			 
2fe7 .. 00		.ifthen:  db "THEN",0 
2fec			 
2fec			.iftrue:		 
2fec				; Exec next words normally 
2fec			 
2fec				; if true then exec following IF as normal 
2fec					if DEBUG_FORTH_WORDS 
2fec						DMARK "IFT" 
2fec f5				push af  
2fed 3a 01 30			ld a, (.dmark)  
2ff0 32 71 ee			ld (debug_mark),a  
2ff3 3a 02 30			ld a, (.dmark+1)  
2ff6 32 72 ee			ld (debug_mark+1),a  
2ff9 3a 03 30			ld a, (.dmark+2)  
2ffc 32 73 ee			ld (debug_mark+2),a  
2fff 18 03			jr .pastdmark  
3001 ..			.dmark: db "IFT"  
3004 f1			.pastdmark: pop af  
3005			endm  
# End of macro DMARK
3005						CALLMONITOR 
3005 cd e8 15			call break_point_state  
3008				endm  
# End of macro CALLMONITOR
3008					endif 
3008			 
3008					NEXTW 
3008 c3 33 20			jp macro_next 
300b				endm 
# End of macro NEXTW
300b			.THEN: 
300b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
300b 1f				db WORD_SYS_CORE+11             
300c 33 30			dw .ELSE            
300e 05				db 4 + 1 
300f .. 00			db "THEN",0              
3014				endm 
# End of macro CWHEAD
3014			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3014					if DEBUG_FORTH_WORDS_KEY 
3014						DMARK "THN" 
3014 f5				push af  
3015 3a 29 30			ld a, (.dmark)  
3018 32 71 ee			ld (debug_mark),a  
301b 3a 2a 30			ld a, (.dmark+1)  
301e 32 72 ee			ld (debug_mark+1),a  
3021 3a 2b 30			ld a, (.dmark+2)  
3024 32 73 ee			ld (debug_mark+2),a  
3027 18 03			jr .pastdmark  
3029 ..			.dmark: db "THN"  
302c f1			.pastdmark: pop af  
302d			endm  
# End of macro DMARK
302d						CALLMONITOR 
302d cd e8 15			call break_point_state  
3030				endm  
# End of macro CALLMONITOR
3030					endif 
3030					NEXTW 
3030 c3 33 20			jp macro_next 
3033				endm 
# End of macro NEXTW
3033			.ELSE: 
3033				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3033 20				db WORD_SYS_CORE+12             
3034 5b 30			dw .DO            
3036 03				db 2 + 1 
3037 .. 00			db "ELSE",0              
303c				endm 
# End of macro CWHEAD
303c			; | ELSE ( -- ) Not supported - does nothing | TODO 
303c			 
303c					if DEBUG_FORTH_WORDS_KEY 
303c						DMARK "ELS" 
303c f5				push af  
303d 3a 51 30			ld a, (.dmark)  
3040 32 71 ee			ld (debug_mark),a  
3043 3a 52 30			ld a, (.dmark+1)  
3046 32 72 ee			ld (debug_mark+1),a  
3049 3a 53 30			ld a, (.dmark+2)  
304c 32 73 ee			ld (debug_mark+2),a  
304f 18 03			jr .pastdmark  
3051 ..			.dmark: db "ELS"  
3054 f1			.pastdmark: pop af  
3055			endm  
# End of macro DMARK
3055						CALLMONITOR 
3055 cd e8 15			call break_point_state  
3058				endm  
# End of macro CALLMONITOR
3058					endif 
3058			 
3058			 
3058					NEXTW 
3058 c3 33 20			jp macro_next 
305b				endm 
# End of macro NEXTW
305b			.DO: 
305b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
305b 21				db WORD_SYS_CORE+13             
305c 82 31			dw .LOOP            
305e 03				db 2 + 1 
305f .. 00			db "DO",0              
3062				endm 
# End of macro CWHEAD
3062			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3062			 
3062					if DEBUG_FORTH_WORDS_KEY 
3062						DMARK "DO." 
3062 f5				push af  
3063 3a 77 30			ld a, (.dmark)  
3066 32 71 ee			ld (debug_mark),a  
3069 3a 78 30			ld a, (.dmark+1)  
306c 32 72 ee			ld (debug_mark+1),a  
306f 3a 79 30			ld a, (.dmark+2)  
3072 32 73 ee			ld (debug_mark+2),a  
3075 18 03			jr .pastdmark  
3077 ..			.dmark: db "DO."  
307a f1			.pastdmark: pop af  
307b			endm  
# End of macro DMARK
307b						CALLMONITOR 
307b cd e8 15			call break_point_state  
307e				endm  
# End of macro CALLMONITOR
307e					endif 
307e			;  push pc to rsp stack past the DO 
307e			 
307e 2a c8 e5				ld hl, (os_tok_ptr) 
3081 23					inc hl   ; D 
3082 23					inc hl  ; O 
3083 23					inc hl   ; null 
3084					if DEBUG_FORTH_WORDS 
3084						DMARK "DO2" 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 71 ee			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 72 ee			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 73 ee			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "DO2"  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd e8 15			call break_point_state  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0					FORTH_RSP_NEXT 
30a0 cd 2d 1c			call macro_forth_rsp_next 
30a3				endm 
# End of macro FORTH_RSP_NEXT
30a3					if DEBUG_FORTH_WORDS 
30a3						DMARK "DO3" 
30a3 f5				push af  
30a4 3a b8 30			ld a, (.dmark)  
30a7 32 71 ee			ld (debug_mark),a  
30aa 3a b9 30			ld a, (.dmark+1)  
30ad 32 72 ee			ld (debug_mark+1),a  
30b0 3a ba 30			ld a, (.dmark+2)  
30b3 32 73 ee			ld (debug_mark+2),a  
30b6 18 03			jr .pastdmark  
30b8 ..			.dmark: db "DO3"  
30bb f1			.pastdmark: pop af  
30bc			endm  
# End of macro DMARK
30bc						CALLMONITOR 
30bc cd e8 15			call break_point_state  
30bf				endm  
# End of macro CALLMONITOR
30bf					endif 
30bf			 
30bf					;if DEBUG_FORTH_WORDS 
30bf				;		push hl 
30bf			;		endif  
30bf			 
30bf			; get counters from data stack 
30bf			 
30bf			 
30bf					FORTH_DSP_VALUEHL 
30bf cd 7d 1e			call macro_dsp_valuehl 
30c2				endm 
# End of macro FORTH_DSP_VALUEHL
30c2 e5					push hl		 ; hl now has starting counter which needs to be tos 
30c3			 
30c3					if DEBUG_FORTH_WORDS 
30c3						DMARK "DO4" 
30c3 f5				push af  
30c4 3a d8 30			ld a, (.dmark)  
30c7 32 71 ee			ld (debug_mark),a  
30ca 3a d9 30			ld a, (.dmark+1)  
30cd 32 72 ee			ld (debug_mark+1),a  
30d0 3a da 30			ld a, (.dmark+2)  
30d3 32 73 ee			ld (debug_mark+2),a  
30d6 18 03			jr .pastdmark  
30d8 ..			.dmark: db "DO4"  
30db f1			.pastdmark: pop af  
30dc			endm  
# End of macro DMARK
30dc						CALLMONITOR 
30dc cd e8 15			call break_point_state  
30df				endm  
# End of macro CALLMONITOR
30df					endif 
30df					FORTH_DSP_POP 
30df cd 35 1f			call macro_forth_dsp_pop 
30e2				endm 
# End of macro FORTH_DSP_POP
30e2			 
30e2					if DEBUG_FORTH_WORDS 
30e2						DMARK "DO5" 
30e2 f5				push af  
30e3 3a f7 30			ld a, (.dmark)  
30e6 32 71 ee			ld (debug_mark),a  
30e9 3a f8 30			ld a, (.dmark+1)  
30ec 32 72 ee			ld (debug_mark+1),a  
30ef 3a f9 30			ld a, (.dmark+2)  
30f2 32 73 ee			ld (debug_mark+2),a  
30f5 18 03			jr .pastdmark  
30f7 ..			.dmark: db "DO5"  
30fa f1			.pastdmark: pop af  
30fb			endm  
# End of macro DMARK
30fb						CALLMONITOR 
30fb cd e8 15			call break_point_state  
30fe				endm  
# End of macro CALLMONITOR
30fe					endif 
30fe			 
30fe					FORTH_DSP_VALUEHL 
30fe cd 7d 1e			call macro_dsp_valuehl 
3101				endm 
# End of macro FORTH_DSP_VALUEHL
3101			;		push hl		 ; hl now has starting limit counter 
3101			 
3101					if DEBUG_FORTH_WORDS 
3101						DMARK "DO6" 
3101 f5				push af  
3102 3a 16 31			ld a, (.dmark)  
3105 32 71 ee			ld (debug_mark),a  
3108 3a 17 31			ld a, (.dmark+1)  
310b 32 72 ee			ld (debug_mark+1),a  
310e 3a 18 31			ld a, (.dmark+2)  
3111 32 73 ee			ld (debug_mark+2),a  
3114 18 03			jr .pastdmark  
3116 ..			.dmark: db "DO6"  
3119 f1			.pastdmark: pop af  
311a			endm  
# End of macro DMARK
311a						CALLMONITOR 
311a cd e8 15			call break_point_state  
311d				endm  
# End of macro CALLMONITOR
311d					endif 
311d					FORTH_DSP_POP 
311d cd 35 1f			call macro_forth_dsp_pop 
3120				endm 
# End of macro FORTH_DSP_POP
3120			 
3120			; put counters on the loop stack 
3120			 
3120			;		pop hl			 ; limit counter 
3120 d1					pop de			; start counter 
3121			 
3121					; push limit counter 
3121			 
3121					if DEBUG_FORTH_WORDS 
3121						DMARK "DO7" 
3121 f5				push af  
3122 3a 36 31			ld a, (.dmark)  
3125 32 71 ee			ld (debug_mark),a  
3128 3a 37 31			ld a, (.dmark+1)  
312b 32 72 ee			ld (debug_mark+1),a  
312e 3a 38 31			ld a, (.dmark+2)  
3131 32 73 ee			ld (debug_mark+2),a  
3134 18 03			jr .pastdmark  
3136 ..			.dmark: db "DO7"  
3139 f1			.pastdmark: pop af  
313a			endm  
# End of macro DMARK
313a						CALLMONITOR 
313a cd e8 15			call break_point_state  
313d				endm  
# End of macro CALLMONITOR
313d					endif 
313d					FORTH_LOOP_NEXT 
313d cd ae 1e			call macro_forth_loop_next 
3140				endm 
# End of macro FORTH_LOOP_NEXT
3140			 
3140					; push start counter 
3140			 
3140 eb					ex de, hl 
3141					if DEBUG_FORTH_WORDS 
3141						DMARK "DO7" 
3141 f5				push af  
3142 3a 56 31			ld a, (.dmark)  
3145 32 71 ee			ld (debug_mark),a  
3148 3a 57 31			ld a, (.dmark+1)  
314b 32 72 ee			ld (debug_mark+1),a  
314e 3a 58 31			ld a, (.dmark+2)  
3151 32 73 ee			ld (debug_mark+2),a  
3154 18 03			jr .pastdmark  
3156 ..			.dmark: db "DO7"  
3159 f1			.pastdmark: pop af  
315a			endm  
# End of macro DMARK
315a						CALLMONITOR 
315a cd e8 15			call break_point_state  
315d				endm  
# End of macro CALLMONITOR
315d					endif 
315d					FORTH_LOOP_NEXT 
315d cd ae 1e			call macro_forth_loop_next 
3160				endm 
# End of macro FORTH_LOOP_NEXT
3160			 
3160			 
3160					; init first round of I counter 
3160			 
3160 22 ec e5				ld (os_current_i), hl 
3163			 
3163					if DEBUG_FORTH_WORDS 
3163						DMARK "DO8" 
3163 f5				push af  
3164 3a 78 31			ld a, (.dmark)  
3167 32 71 ee			ld (debug_mark),a  
316a 3a 79 31			ld a, (.dmark+1)  
316d 32 72 ee			ld (debug_mark+1),a  
3170 3a 7a 31			ld a, (.dmark+2)  
3173 32 73 ee			ld (debug_mark+2),a  
3176 18 03			jr .pastdmark  
3178 ..			.dmark: db "DO8"  
317b f1			.pastdmark: pop af  
317c			endm  
# End of macro DMARK
317c						CALLMONITOR 
317c cd e8 15			call break_point_state  
317f				endm  
# End of macro CALLMONITOR
317f					endif 
317f			 
317f					NEXTW 
317f c3 33 20			jp macro_next 
3182				endm 
# End of macro NEXTW
3182			.LOOP: 
3182				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3182 22				db WORD_SYS_CORE+14             
3183 9a 32			dw .I            
3185 05				db 4 + 1 
3186 .. 00			db "LOOP",0              
318b				endm 
# End of macro CWHEAD
318b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
318b			 
318b				; pop tos as current loop count to hl 
318b			 
318b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
318b			 
318b				FORTH_LOOP_TOS 
318b cd e1 1e			call macro_forth_loop_tos 
318e				endm 
# End of macro FORTH_LOOP_TOS
318e e5				push hl 
318f			 
318f					if DEBUG_FORTH_WORDS_KEY 
318f						DMARK "LOP" 
318f f5				push af  
3190 3a a4 31			ld a, (.dmark)  
3193 32 71 ee			ld (debug_mark),a  
3196 3a a5 31			ld a, (.dmark+1)  
3199 32 72 ee			ld (debug_mark+1),a  
319c 3a a6 31			ld a, (.dmark+2)  
319f 32 73 ee			ld (debug_mark+2),a  
31a2 18 03			jr .pastdmark  
31a4 ..			.dmark: db "LOP"  
31a7 f1			.pastdmark: pop af  
31a8			endm  
# End of macro DMARK
31a8						CALLMONITOR 
31a8 cd e8 15			call break_point_state  
31ab				endm  
# End of macro CALLMONITOR
31ab					endif 
31ab				; next item on the stack is the limit. get it 
31ab			 
31ab			 
31ab				FORTH_LOOP_POP 
31ab cd eb 1e			call macro_forth_loop_pop 
31ae				endm 
# End of macro FORTH_LOOP_POP
31ae			 
31ae				FORTH_LOOP_TOS 
31ae cd e1 1e			call macro_forth_loop_tos 
31b1				endm 
# End of macro FORTH_LOOP_TOS
31b1			 
31b1 d1				pop de		 ; de = i, hl = limit 
31b2			 
31b2					if DEBUG_FORTH_WORDS 
31b2						DMARK "LP1" 
31b2 f5				push af  
31b3 3a c7 31			ld a, (.dmark)  
31b6 32 71 ee			ld (debug_mark),a  
31b9 3a c8 31			ld a, (.dmark+1)  
31bc 32 72 ee			ld (debug_mark+1),a  
31bf 3a c9 31			ld a, (.dmark+2)  
31c2 32 73 ee			ld (debug_mark+2),a  
31c5 18 03			jr .pastdmark  
31c7 ..			.dmark: db "LP1"  
31ca f1			.pastdmark: pop af  
31cb			endm  
# End of macro DMARK
31cb						CALLMONITOR 
31cb cd e8 15			call break_point_state  
31ce				endm  
# End of macro CALLMONITOR
31ce					endif 
31ce			 
31ce				; go back to previous word 
31ce			 
31ce d5				push de    ; save I for inc later 
31cf			 
31cf			 
31cf				; get limit 
31cf				;  is I at limit? 
31cf			 
31cf			 
31cf					if DEBUG_FORTH_WORDS 
31cf						DMARK "LP1" 
31cf f5				push af  
31d0 3a e4 31			ld a, (.dmark)  
31d3 32 71 ee			ld (debug_mark),a  
31d6 3a e5 31			ld a, (.dmark+1)  
31d9 32 72 ee			ld (debug_mark+1),a  
31dc 3a e6 31			ld a, (.dmark+2)  
31df 32 73 ee			ld (debug_mark+2),a  
31e2 18 03			jr .pastdmark  
31e4 ..			.dmark: db "LP1"  
31e7 f1			.pastdmark: pop af  
31e8			endm  
# End of macro DMARK
31e8						CALLMONITOR 
31e8 cd e8 15			call break_point_state  
31eb				endm  
# End of macro CALLMONITOR
31eb					endif 
31eb			 
31eb ed 52			sbc hl, de 
31ed			 
31ed			 
31ed				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31ed			 
31ed 20 26				jr nz, .loopnotdone 
31ef			 
31ef e1				pop hl   ; get rid of saved I 
31f0				FORTH_LOOP_POP     ; get rid of limit 
31f0 cd eb 1e			call macro_forth_loop_pop 
31f3				endm 
# End of macro FORTH_LOOP_POP
31f3			 
31f3				FORTH_RSP_POP     ; get rid of DO ptr 
31f3 cd 4e 1c			call macro_forth_rsp_pop 
31f6				endm 
# End of macro FORTH_RSP_POP
31f6			 
31f6			if DEBUG_FORTH_WORDS 
31f6						DMARK "LP>" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 71 ee			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 72 ee			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 73 ee			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "LP>"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f				CALLMONITOR 
320f cd e8 15			call break_point_state  
3212				endm  
# End of macro CALLMONITOR
3212			endif 
3212			 
3212					NEXTW 
3212 c3 33 20			jp macro_next 
3215				endm 
# End of macro NEXTW
3215				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3215			 
3215			.loopnotdone: 
3215			 
3215 e1				pop hl    ; get I 
3216 23				inc hl 
3217			 
3217			   	; save new I 
3217			 
3217			 
3217					; set I counter 
3217			 
3217 22 ec e5				ld (os_current_i), hl 
321a			 
321a					if DEBUG_FORTH_WORDS 
321a						DMARK "LPN" 
321a f5				push af  
321b 3a 2f 32			ld a, (.dmark)  
321e 32 71 ee			ld (debug_mark),a  
3221 3a 30 32			ld a, (.dmark+1)  
3224 32 72 ee			ld (debug_mark+1),a  
3227 3a 31 32			ld a, (.dmark+2)  
322a 32 73 ee			ld (debug_mark+2),a  
322d 18 03			jr .pastdmark  
322f ..			.dmark: db "LPN"  
3232 f1			.pastdmark: pop af  
3233			endm  
# End of macro DMARK
3233					CALLMONITOR 
3233 cd e8 15			call break_point_state  
3236				endm  
# End of macro CALLMONITOR
3236					endif 
3236					 
3236				FORTH_LOOP_NEXT 
3236 cd ae 1e			call macro_forth_loop_next 
3239				endm 
# End of macro FORTH_LOOP_NEXT
3239			 
3239			 
3239					if DEBUG_FORTH_WORDS 
3239 eb						ex de,hl 
323a					endif 
323a			 
323a			;	; get DO ptr 
323a			; 
323a					if DEBUG_FORTH_WORDS 
323a						DMARK "LP7" 
323a f5				push af  
323b 3a 4f 32			ld a, (.dmark)  
323e 32 71 ee			ld (debug_mark),a  
3241 3a 50 32			ld a, (.dmark+1)  
3244 32 72 ee			ld (debug_mark+1),a  
3247 3a 51 32			ld a, (.dmark+2)  
324a 32 73 ee			ld (debug_mark+2),a  
324d 18 03			jr .pastdmark  
324f ..			.dmark: db "LP7"  
3252 f1			.pastdmark: pop af  
3253			endm  
# End of macro DMARK
3253					CALLMONITOR 
3253 cd e8 15			call break_point_state  
3256				endm  
# End of macro CALLMONITOR
3256					endif 
3256				FORTH_RSP_TOS 
3256 cd 44 1c			call macro_forth_rsp_tos 
3259				endm 
# End of macro FORTH_RSP_TOS
3259			 
3259					if DEBUG_FORTH_WORDS 
3259						DMARK "LP8" 
3259 f5				push af  
325a 3a 6e 32			ld a, (.dmark)  
325d 32 71 ee			ld (debug_mark),a  
3260 3a 6f 32			ld a, (.dmark+1)  
3263 32 72 ee			ld (debug_mark+1),a  
3266 3a 70 32			ld a, (.dmark+2)  
3269 32 73 ee			ld (debug_mark+2),a  
326c 18 03			jr .pastdmark  
326e ..			.dmark: db "LP8"  
3271 f1			.pastdmark: pop af  
3272			endm  
# End of macro DMARK
3272					CALLMONITOR 
3272 cd e8 15			call break_point_state  
3275				endm  
# End of macro CALLMONITOR
3275					endif 
3275				;push hl 
3275			 
3275				; not going to DO any more 
3275				; get rid of the RSP pointer as DO will add it back in 
3275				;FORTH_RSP_POP 
3275				;pop hl 
3275			 
3275				;ld hl,(cli_ret_sp) 
3275				;ld e, (hl) 
3275				;inc hl 
3275				;ld d, (hl) 
3275				;ex de,hl 
3275 22 c8 e5			ld (os_tok_ptr), hl 
3278					if DEBUG_FORTH_WORDS 
3278						DMARK "LP<" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 71 ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 72 ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 73 ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "LP<"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291					CALLMONITOR 
3291 cd e8 15			call break_point_state  
3294				endm  
# End of macro CALLMONITOR
3294				endif 
3294 c3 c4 20			jp exec1 
3297			 
3297					 
3297			 
3297			 
3297					NEXTW 
3297 c3 33 20			jp macro_next 
329a				endm 
# End of macro NEXTW
329a			.I:  
329a			 
329a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
329a 5e				db WORD_SYS_CORE+74             
329b c5 32			dw .DLOOP            
329d 02				db 1 + 1 
329e .. 00			db "I",0              
32a0				endm 
# End of macro CWHEAD
32a0			; | I ( -- ) Current loop counter | DONE 
32a0					if DEBUG_FORTH_WORDS_KEY 
32a0						DMARK "I.." 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 71 ee			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 72 ee			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 73 ee			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "I.."  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9						CALLMONITOR 
32b9 cd e8 15			call break_point_state  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc			 
32bc 2a ec e5				ld hl,(os_current_i) 
32bf cd 86 1c				call forth_push_numhl 
32c2			 
32c2					NEXTW 
32c2 c3 33 20			jp macro_next 
32c5				endm 
# End of macro NEXTW
32c5			.DLOOP: 
32c5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32c5 5f				db WORD_SYS_CORE+75             
32c6 a6 33			dw .REPEAT            
32c8 06				db 5 + 1 
32c9 .. 00			db "-LOOP",0              
32cf				endm 
# End of macro CWHEAD
32cf			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32cf				; pop tos as current loop count to hl 
32cf					if DEBUG_FORTH_WORDS_KEY 
32cf						DMARK "-LP" 
32cf f5				push af  
32d0 3a e4 32			ld a, (.dmark)  
32d3 32 71 ee			ld (debug_mark),a  
32d6 3a e5 32			ld a, (.dmark+1)  
32d9 32 72 ee			ld (debug_mark+1),a  
32dc 3a e6 32			ld a, (.dmark+2)  
32df 32 73 ee			ld (debug_mark+2),a  
32e2 18 03			jr .pastdmark  
32e4 ..			.dmark: db "-LP"  
32e7 f1			.pastdmark: pop af  
32e8			endm  
# End of macro DMARK
32e8						CALLMONITOR 
32e8 cd e8 15			call break_point_state  
32eb				endm  
# End of macro CALLMONITOR
32eb					endif 
32eb			 
32eb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32eb			 
32eb				FORTH_LOOP_TOS 
32eb cd e1 1e			call macro_forth_loop_tos 
32ee				endm 
# End of macro FORTH_LOOP_TOS
32ee e5				push hl 
32ef			 
32ef					if DEBUG_FORTH_WORDS 
32ef						DMARK "-LP" 
32ef f5				push af  
32f0 3a 04 33			ld a, (.dmark)  
32f3 32 71 ee			ld (debug_mark),a  
32f6 3a 05 33			ld a, (.dmark+1)  
32f9 32 72 ee			ld (debug_mark+1),a  
32fc 3a 06 33			ld a, (.dmark+2)  
32ff 32 73 ee			ld (debug_mark+2),a  
3302 18 03			jr .pastdmark  
3304 ..			.dmark: db "-LP"  
3307 f1			.pastdmark: pop af  
3308			endm  
# End of macro DMARK
3308						CALLMONITOR 
3308 cd e8 15			call break_point_state  
330b				endm  
# End of macro CALLMONITOR
330b					endif 
330b				; next item on the stack is the limit. get it 
330b			 
330b			 
330b				FORTH_LOOP_POP 
330b cd eb 1e			call macro_forth_loop_pop 
330e				endm 
# End of macro FORTH_LOOP_POP
330e			 
330e				FORTH_LOOP_TOS 
330e cd e1 1e			call macro_forth_loop_tos 
3311				endm 
# End of macro FORTH_LOOP_TOS
3311			 
3311 d1				pop de		 ; de = i, hl = limit 
3312			 
3312					if DEBUG_FORTH_WORDS 
3312						DMARK "-L1" 
3312 f5				push af  
3313 3a 27 33			ld a, (.dmark)  
3316 32 71 ee			ld (debug_mark),a  
3319 3a 28 33			ld a, (.dmark+1)  
331c 32 72 ee			ld (debug_mark+1),a  
331f 3a 29 33			ld a, (.dmark+2)  
3322 32 73 ee			ld (debug_mark+2),a  
3325 18 03			jr .pastdmark  
3327 ..			.dmark: db "-L1"  
332a f1			.pastdmark: pop af  
332b			endm  
# End of macro DMARK
332b						CALLMONITOR 
332b cd e8 15			call break_point_state  
332e				endm  
# End of macro CALLMONITOR
332e					endif 
332e			 
332e				; go back to previous word 
332e			 
332e d5				push de    ; save I for inc later 
332f			 
332f			 
332f				; get limit 
332f				;  is I at limit? 
332f			 
332f			 
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "-L1" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 71 ee			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 72 ee			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 73 ee			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "-L1"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd e8 15			call break_point_state  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b			 
334b ed 52			sbc hl, de 
334d			 
334d			 
334d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
334d			 
334d 20 26				jr nz, .mloopnotdone 
334f			 
334f e1				pop hl   ; get rid of saved I 
3350				FORTH_LOOP_POP     ; get rid of limit 
3350 cd eb 1e			call macro_forth_loop_pop 
3353				endm 
# End of macro FORTH_LOOP_POP
3353			 
3353				FORTH_RSP_POP     ; get rid of DO ptr 
3353 cd 4e 1c			call macro_forth_rsp_pop 
3356				endm 
# End of macro FORTH_RSP_POP
3356			 
3356			if DEBUG_FORTH_WORDS 
3356						DMARK "-L>" 
3356 f5				push af  
3357 3a 6b 33			ld a, (.dmark)  
335a 32 71 ee			ld (debug_mark),a  
335d 3a 6c 33			ld a, (.dmark+1)  
3360 32 72 ee			ld (debug_mark+1),a  
3363 3a 6d 33			ld a, (.dmark+2)  
3366 32 73 ee			ld (debug_mark+2),a  
3369 18 03			jr .pastdmark  
336b ..			.dmark: db "-L>"  
336e f1			.pastdmark: pop af  
336f			endm  
# End of macro DMARK
336f				CALLMONITOR 
336f cd e8 15			call break_point_state  
3372				endm  
# End of macro CALLMONITOR
3372			endif 
3372			 
3372					NEXTW 
3372 c3 33 20			jp macro_next 
3375				endm 
# End of macro NEXTW
3375				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3375			 
3375			.mloopnotdone: 
3375			 
3375 e1				pop hl    ; get I 
3376 2b				dec hl 
3377			 
3377			   	; save new I 
3377			 
3377			 
3377					; set I counter 
3377			 
3377 22 ec e5				ld (os_current_i), hl 
337a			 
337a					 
337a				FORTH_LOOP_NEXT 
337a cd ae 1e			call macro_forth_loop_next 
337d				endm 
# End of macro FORTH_LOOP_NEXT
337d			 
337d			 
337d					if DEBUG_FORTH_WORDS 
337d eb						ex de,hl 
337e					endif 
337e			 
337e			;	; get DO ptr 
337e			; 
337e				FORTH_RSP_TOS 
337e cd 44 1c			call macro_forth_rsp_tos 
3381				endm 
# End of macro FORTH_RSP_TOS
3381			 
3381				;push hl 
3381			 
3381				; not going to DO any more 
3381				; get rid of the RSP pointer as DO will add it back in 
3381				;FORTH_RSP_POP 
3381				;pop hl 
3381			 
3381			 
3381 22 c8 e5			ld (os_tok_ptr), hl 
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "-L<" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 71 ee			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 72 ee			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 73 ee			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "-L<"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d					CALLMONITOR 
339d cd e8 15			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0				endif 
33a0 c3 c4 20			jp exec1 
33a3			 
33a3					 
33a3			 
33a3			 
33a3			 
33a3				NEXTW 
33a3 c3 33 20			jp macro_next 
33a6				endm 
# End of macro NEXTW
33a6			 
33a6			 
33a6			 
33a6			 
33a6			.REPEAT: 
33a6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33a6 71				db WORD_SYS_CORE+93             
33a7 f9 33			dw .UNTIL            
33a9 06				db 5 + 1 
33aa .. 00			db "REPEAT",0              
33b1				endm 
# End of macro CWHEAD
33b1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33b1			;  push pc to rsp stack past the REPEAT 
33b1					if DEBUG_FORTH_WORDS_KEY 
33b1						DMARK "REP" 
33b1 f5				push af  
33b2 3a c6 33			ld a, (.dmark)  
33b5 32 71 ee			ld (debug_mark),a  
33b8 3a c7 33			ld a, (.dmark+1)  
33bb 32 72 ee			ld (debug_mark+1),a  
33be 3a c8 33			ld a, (.dmark+2)  
33c1 32 73 ee			ld (debug_mark+2),a  
33c4 18 03			jr .pastdmark  
33c6 ..			.dmark: db "REP"  
33c9 f1			.pastdmark: pop af  
33ca			endm  
# End of macro DMARK
33ca						CALLMONITOR 
33ca cd e8 15			call break_point_state  
33cd				endm  
# End of macro CALLMONITOR
33cd					endif 
33cd			 
33cd 2a c8 e5				ld hl, (os_tok_ptr) 
33d0 23					inc hl   ; R 
33d1 23					inc hl  ; E 
33d2 23					inc hl   ; P 
33d3 23					inc hl   ; E 
33d4 23					inc hl   ; A 
33d5 23					inc hl   ; T 
33d6 23					inc hl   ; zero 
33d7					FORTH_RSP_NEXT 
33d7 cd 2d 1c			call macro_forth_rsp_next 
33da				endm 
# End of macro FORTH_RSP_NEXT
33da			 
33da			 
33da					if DEBUG_FORTH_WORDS 
33da						DMARK "REP" 
33da f5				push af  
33db 3a ef 33			ld a, (.dmark)  
33de 32 71 ee			ld (debug_mark),a  
33e1 3a f0 33			ld a, (.dmark+1)  
33e4 32 72 ee			ld (debug_mark+1),a  
33e7 3a f1 33			ld a, (.dmark+2)  
33ea 32 73 ee			ld (debug_mark+2),a  
33ed 18 03			jr .pastdmark  
33ef ..			.dmark: db "REP"  
33f2 f1			.pastdmark: pop af  
33f3			endm  
# End of macro DMARK
33f3						;pop bc    ; TODO BUG ?????? what is this for???? 
33f3						CALLMONITOR 
33f3 cd e8 15			call break_point_state  
33f6				endm  
# End of macro CALLMONITOR
33f6					endif 
33f6			 
33f6					NEXTW 
33f6 c3 33 20			jp macro_next 
33f9				endm 
# End of macro NEXTW
33f9			;	       NEXTW 
33f9			 
33f9			.UNTIL: 
33f9				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33f9 72				db WORD_SYS_CORE+94             
33fa 90 34			dw .ENDFLOW            
33fc 06				db 5 + 1 
33fd .. 00			db "UNTIL",0              
3403				endm 
# End of macro CWHEAD
3403			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3403			 
3403				; pop tos as check 
3403			 
3403				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3403			 
3403				FORTH_DSP_VALUEHL 
3403 cd 7d 1e			call macro_dsp_valuehl 
3406				endm 
# End of macro FORTH_DSP_VALUEHL
3406			 
3406					if DEBUG_FORTH_WORDS_KEY 
3406						DMARK "UNT" 
3406 f5				push af  
3407 3a 1b 34			ld a, (.dmark)  
340a 32 71 ee			ld (debug_mark),a  
340d 3a 1c 34			ld a, (.dmark+1)  
3410 32 72 ee			ld (debug_mark+1),a  
3413 3a 1d 34			ld a, (.dmark+2)  
3416 32 73 ee			ld (debug_mark+2),a  
3419 18 03			jr .pastdmark  
341b ..			.dmark: db "UNT"  
341e f1			.pastdmark: pop af  
341f			endm  
# End of macro DMARK
341f						CALLMONITOR 
341f cd e8 15			call break_point_state  
3422				endm  
# End of macro CALLMONITOR
3422					endif 
3422			 
3422			;	push hl 
3422				FORTH_DSP_POP 
3422 cd 35 1f			call macro_forth_dsp_pop 
3425				endm 
# End of macro FORTH_DSP_POP
3425			 
3425			;	pop hl 
3425			 
3425				; test if true 
3425			 
3425 cd 10 0e			call ishlzero 
3428			;	ld a,l 
3428			;	add h 
3428			; 
3428			;	cp 0 
3428			 
3428 20 3e			jr nz, .untilnotdone 
342a			 
342a					if DEBUG_FORTH_WORDS 
342a						DMARK "UNf" 
342a f5				push af  
342b 3a 3f 34			ld a, (.dmark)  
342e 32 71 ee			ld (debug_mark),a  
3431 3a 40 34			ld a, (.dmark+1)  
3434 32 72 ee			ld (debug_mark+1),a  
3437 3a 41 34			ld a, (.dmark+2)  
343a 32 73 ee			ld (debug_mark+2),a  
343d 18 03			jr .pastdmark  
343f ..			.dmark: db "UNf"  
3442 f1			.pastdmark: pop af  
3443			endm  
# End of macro DMARK
3443						CALLMONITOR 
3443 cd e8 15			call break_point_state  
3446				endm  
# End of macro CALLMONITOR
3446					endif 
3446			 
3446			 
3446			 
3446				FORTH_RSP_POP     ; get rid of DO ptr 
3446 cd 4e 1c			call macro_forth_rsp_pop 
3449				endm 
# End of macro FORTH_RSP_POP
3449			 
3449			if DEBUG_FORTH_WORDS 
3449						DMARK "UN>" 
3449 f5				push af  
344a 3a 5e 34			ld a, (.dmark)  
344d 32 71 ee			ld (debug_mark),a  
3450 3a 5f 34			ld a, (.dmark+1)  
3453 32 72 ee			ld (debug_mark+1),a  
3456 3a 60 34			ld a, (.dmark+2)  
3459 32 73 ee			ld (debug_mark+2),a  
345c 18 03			jr .pastdmark  
345e ..			.dmark: db "UN>"  
3461 f1			.pastdmark: pop af  
3462			endm  
# End of macro DMARK
3462				CALLMONITOR 
3462 cd e8 15			call break_point_state  
3465				endm  
# End of macro CALLMONITOR
3465			endif 
3465			 
3465					NEXTW 
3465 c3 33 20			jp macro_next 
3468				endm 
# End of macro NEXTW
3468				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3468			 
3468			.untilnotdone: 
3468			 
3468			 
3468			;	; get DO ptr 
3468			; 
3468				FORTH_RSP_TOS 
3468 cd 44 1c			call macro_forth_rsp_tos 
346b				endm 
# End of macro FORTH_RSP_TOS
346b			 
346b				;push hl 
346b			 
346b				; not going to DO any more 
346b				; get rid of the RSP pointer as DO will add it back in 
346b				;FORTH_RSP_POP 
346b				;pop hl 
346b			 
346b			 
346b 22 c8 e5			ld (os_tok_ptr), hl 
346e					if DEBUG_FORTH_WORDS 
346e						DMARK "UN<" 
346e f5				push af  
346f 3a 83 34			ld a, (.dmark)  
3472 32 71 ee			ld (debug_mark),a  
3475 3a 84 34			ld a, (.dmark+1)  
3478 32 72 ee			ld (debug_mark+1),a  
347b 3a 85 34			ld a, (.dmark+2)  
347e 32 73 ee			ld (debug_mark+2),a  
3481 18 03			jr .pastdmark  
3483 ..			.dmark: db "UN<"  
3486 f1			.pastdmark: pop af  
3487			endm  
# End of macro DMARK
3487					CALLMONITOR 
3487 cd e8 15			call break_point_state  
348a				endm  
# End of macro CALLMONITOR
348a				endif 
348a c3 c4 20			jp exec1 
348d			 
348d					 
348d			 
348d			 
348d					NEXTW 
348d c3 33 20			jp macro_next 
3490				endm 
# End of macro NEXTW
3490			 
3490			 
3490			.ENDFLOW: 
3490			 
3490			; eof 
3490			 
# End of file forth_words_flow.asm
3490			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3490			include "forth_words_logic.asm" 
3490			 
3490			; | ## Logic Words 
3490			 
3490			.NOT: 
3490				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3490 2d				db WORD_SYS_CORE+25             
3491 d8 34			dw .IS            
3493 04				db 3 + 1 
3494 .. 00			db "NOT",0              
3498				endm 
# End of macro CWHEAD
3498			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3498					if DEBUG_FORTH_WORDS_KEY 
3498						DMARK "NOT" 
3498 f5				push af  
3499 3a ad 34			ld a, (.dmark)  
349c 32 71 ee			ld (debug_mark),a  
349f 3a ae 34			ld a, (.dmark+1)  
34a2 32 72 ee			ld (debug_mark+1),a  
34a5 3a af 34			ld a, (.dmark+2)  
34a8 32 73 ee			ld (debug_mark+2),a  
34ab 18 03			jr .pastdmark  
34ad ..			.dmark: db "NOT"  
34b0 f1			.pastdmark: pop af  
34b1			endm  
# End of macro DMARK
34b1						CALLMONITOR 
34b1 cd e8 15			call break_point_state  
34b4				endm  
# End of macro CALLMONITOR
34b4					endif 
34b4					FORTH_DSP 
34b4 cd 43 1e			call macro_forth_dsp 
34b7				endm 
# End of macro FORTH_DSP
34b7 7e					ld a,(hl)	; get type of value on TOS 
34b8 fe 02				cp DS_TYPE_INUM  
34ba 28 03				jr z, .noti 
34bc					NEXTW 
34bc c3 33 20			jp macro_next 
34bf				endm 
# End of macro NEXTW
34bf			.noti:          FORTH_DSP_VALUEHL 
34bf cd 7d 1e			call macro_dsp_valuehl 
34c2				endm 
# End of macro FORTH_DSP_VALUEHL
34c2			;		push hl 
34c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c2 cd 35 1f			call macro_forth_dsp_pop 
34c5				endm 
# End of macro FORTH_DSP_POP
34c5			;		pop hl 
34c5 3e 00				ld a,0 
34c7 bd					cp l 
34c8 28 04				jr z, .not2t 
34ca 2e 00				ld l, 0 
34cc 18 02				jr .notip 
34ce			 
34ce 2e ff		.not2t:		ld l, 255 
34d0			 
34d0 26 00		.notip:		ld h, 0	 
34d2			 
34d2 cd 86 1c				call forth_push_numhl 
34d5					NEXTW 
34d5 c3 33 20			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8			 
34d8			.IS: 
34d8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34d8 2d				db WORD_SYS_CORE+25             
34d9 fe 34			dw .LZERO            
34db 03				db 2 + 1 
34dc .. 00			db "IS",0              
34df				endm 
# End of macro CWHEAD
34df			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34df					if DEBUG_FORTH_WORDS_KEY 
34df						DMARK "IS." 
34df f5				push af  
34e0 3a f4 34			ld a, (.dmark)  
34e3 32 71 ee			ld (debug_mark),a  
34e6 3a f5 34			ld a, (.dmark+1)  
34e9 32 72 ee			ld (debug_mark+1),a  
34ec 3a f6 34			ld a, (.dmark+2)  
34ef 32 73 ee			ld (debug_mark+2),a  
34f2 18 03			jr .pastdmark  
34f4 ..			.dmark: db "IS."  
34f7 f1			.pastdmark: pop af  
34f8			endm  
# End of macro DMARK
34f8						CALLMONITOR 
34f8 cd e8 15			call break_point_state  
34fb				endm  
# End of macro CALLMONITOR
34fb					endif 
34fb					NEXTW 
34fb c3 33 20			jp macro_next 
34fe				endm 
# End of macro NEXTW
34fe			.LZERO: 
34fe				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34fe 2d				db WORD_SYS_CORE+25             
34ff 08 35			dw .TZERO            
3501 03				db 2 + 1 
3502 .. 00			db "0<",0              
3505				endm 
# End of macro CWHEAD
3505			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3505					NEXTW 
3505 c3 33 20			jp macro_next 
3508				endm 
# End of macro NEXTW
3508			.TZERO: 
3508				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3508 2e				db WORD_SYS_CORE+26             
3509 4f 35			dw .LESS            
350b 03				db 2 + 1 
350c .. 00			db "0=",0              
350f				endm 
# End of macro CWHEAD
350f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
350f				; TODO add floating point number detection 
350f					;v5 FORTH_DSP_VALUE 
350f					if DEBUG_FORTH_WORDS_KEY 
350f						DMARK "0=." 
350f f5				push af  
3510 3a 24 35			ld a, (.dmark)  
3513 32 71 ee			ld (debug_mark),a  
3516 3a 25 35			ld a, (.dmark+1)  
3519 32 72 ee			ld (debug_mark+1),a  
351c 3a 26 35			ld a, (.dmark+2)  
351f 32 73 ee			ld (debug_mark+2),a  
3522 18 03			jr .pastdmark  
3524 ..			.dmark: db "0=."  
3527 f1			.pastdmark: pop af  
3528			endm  
# End of macro DMARK
3528						CALLMONITOR 
3528 cd e8 15			call break_point_state  
352b				endm  
# End of macro CALLMONITOR
352b					endif 
352b					FORTH_DSP 
352b cd 43 1e			call macro_forth_dsp 
352e				endm 
# End of macro FORTH_DSP
352e 7e					ld a,(hl)	; get type of value on TOS 
352f fe 02				cp DS_TYPE_INUM  
3531 28 00				jr z, .tz_inum 
3533			 
3533				if FORTH_ENABLE_FLOATMATH 
3533					jr .tz_done 
3533			 
3533				endif 
3533					 
3533			 
3533			.tz_inum: 
3533					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3533 cd 7d 1e			call macro_dsp_valuehl 
3536				endm 
# End of macro FORTH_DSP_VALUEHL
3536			 
3536			;		push hl 
3536			 
3536					; destroy value TOS 
3536			 
3536					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3536 cd 35 1f			call macro_forth_dsp_pop 
3539				endm 
# End of macro FORTH_DSP_POP
3539			 
3539			;		pop hl 
3539			 
3539 3e 00				ld a,0 
353b			 
353b bd					cp l 
353c 20 08				jr nz, .tz_notzero 
353e			 
353e bc					cp h 
353f			 
353f 20 05				jr nz, .tz_notzero 
3541			 
3541			 
3541 21 01 00				ld hl, FORTH_TRUE 
3544 18 03				jr .tz_done 
3546			 
3546 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3549			 
3549					; push value back onto stack for another op etc 
3549			 
3549			.tz_done: 
3549 cd 86 1c				call forth_push_numhl 
354c			 
354c					NEXTW 
354c c3 33 20			jp macro_next 
354f				endm 
# End of macro NEXTW
354f			.LESS: 
354f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
354f 2f				db WORD_SYS_CORE+27             
3550 b8 35			dw .GT            
3552 02				db 1 + 1 
3553 .. 00			db "<",0              
3555				endm 
# End of macro CWHEAD
3555			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3555				; TODO add floating point number detection 
3555					if DEBUG_FORTH_WORDS_KEY 
3555						DMARK "LES" 
3555 f5				push af  
3556 3a 6a 35			ld a, (.dmark)  
3559 32 71 ee			ld (debug_mark),a  
355c 3a 6b 35			ld a, (.dmark+1)  
355f 32 72 ee			ld (debug_mark+1),a  
3562 3a 6c 35			ld a, (.dmark+2)  
3565 32 73 ee			ld (debug_mark+2),a  
3568 18 03			jr .pastdmark  
356a ..			.dmark: db "LES"  
356d f1			.pastdmark: pop af  
356e			endm  
# End of macro DMARK
356e						CALLMONITOR 
356e cd e8 15			call break_point_state  
3571				endm  
# End of macro CALLMONITOR
3571					endif 
3571					FORTH_DSP 
3571 cd 43 1e			call macro_forth_dsp 
3574				endm 
# End of macro FORTH_DSP
3574					;v5 FORTH_DSP_VALUE 
3574 7e					ld a,(hl)	; get type of value on TOS 
3575 fe 02				cp DS_TYPE_INUM  
3577 28 00				jr z, .less_inum 
3579			 
3579				if FORTH_ENABLE_FLOATMATH 
3579					jr .less_done 
3579			 
3579				endif 
3579					 
3579			 
3579			.less_inum: 
3579					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3579 cd 7d 1e			call macro_dsp_valuehl 
357c				endm 
# End of macro FORTH_DSP_VALUEHL
357c			 
357c e5					push hl  ; u2 
357d			 
357d					; destroy value TOS 
357d			 
357d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
357d cd 35 1f			call macro_forth_dsp_pop 
3580				endm 
# End of macro FORTH_DSP_POP
3580			 
3580			 
3580					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3580 cd 7d 1e			call macro_dsp_valuehl 
3583				endm 
# End of macro FORTH_DSP_VALUEHL
3583			 
3583 e5					push hl    ; u1 
3584			 
3584					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3584 cd 35 1f			call macro_forth_dsp_pop 
3587				endm 
# End of macro FORTH_DSP_POP
3587			 
3587			 
3587 b7			 or a      ;clear carry flag 
3588 01 00 00		 ld bc, FORTH_FALSE 
358b e1			  pop hl    ; u1 
358c d1			  pop de    ; u2 
358d ed 52		  sbc hl,de 
358f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3591			 
3591 01 01 00		 ld bc, FORTH_TRUE 
3594			.lscont:  
3594 c5					push bc 
3595 e1					pop hl 
3596			 
3596					if DEBUG_FORTH_WORDS 
3596						DMARK "LT1" 
3596 f5				push af  
3597 3a ab 35			ld a, (.dmark)  
359a 32 71 ee			ld (debug_mark),a  
359d 3a ac 35			ld a, (.dmark+1)  
35a0 32 72 ee			ld (debug_mark+1),a  
35a3 3a ad 35			ld a, (.dmark+2)  
35a6 32 73 ee			ld (debug_mark+2),a  
35a9 18 03			jr .pastdmark  
35ab ..			.dmark: db "LT1"  
35ae f1			.pastdmark: pop af  
35af			endm  
# End of macro DMARK
35af						CALLMONITOR 
35af cd e8 15			call break_point_state  
35b2				endm  
# End of macro CALLMONITOR
35b2					endif 
35b2 cd 86 1c				call forth_push_numhl 
35b5			 
35b5					NEXTW 
35b5 c3 33 20			jp macro_next 
35b8				endm 
# End of macro NEXTW
35b8			.GT: 
35b8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35b8 30				db WORD_SYS_CORE+28             
35b9 21 36			dw .EQUAL            
35bb 02				db 1 + 1 
35bc .. 00			db ">",0              
35be				endm 
# End of macro CWHEAD
35be			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35be				; TODO add floating point number detection 
35be					if DEBUG_FORTH_WORDS_KEY 
35be						DMARK "GRT" 
35be f5				push af  
35bf 3a d3 35			ld a, (.dmark)  
35c2 32 71 ee			ld (debug_mark),a  
35c5 3a d4 35			ld a, (.dmark+1)  
35c8 32 72 ee			ld (debug_mark+1),a  
35cb 3a d5 35			ld a, (.dmark+2)  
35ce 32 73 ee			ld (debug_mark+2),a  
35d1 18 03			jr .pastdmark  
35d3 ..			.dmark: db "GRT"  
35d6 f1			.pastdmark: pop af  
35d7			endm  
# End of macro DMARK
35d7						CALLMONITOR 
35d7 cd e8 15			call break_point_state  
35da				endm  
# End of macro CALLMONITOR
35da					endif 
35da					FORTH_DSP 
35da cd 43 1e			call macro_forth_dsp 
35dd				endm 
# End of macro FORTH_DSP
35dd					;FORTH_DSP_VALUE 
35dd 7e					ld a,(hl)	; get type of value on TOS 
35de fe 02				cp DS_TYPE_INUM  
35e0 28 00				jr z, .gt_inum 
35e2			 
35e2				if FORTH_ENABLE_FLOATMATH 
35e2					jr .gt_done 
35e2			 
35e2				endif 
35e2					 
35e2			 
35e2			.gt_inum: 
35e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e2 cd 7d 1e			call macro_dsp_valuehl 
35e5				endm 
# End of macro FORTH_DSP_VALUEHL
35e5			 
35e5 e5					push hl  ; u2 
35e6			 
35e6					; destroy value TOS 
35e6			 
35e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e6 cd 35 1f			call macro_forth_dsp_pop 
35e9				endm 
# End of macro FORTH_DSP_POP
35e9			 
35e9			 
35e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e9 cd 7d 1e			call macro_dsp_valuehl 
35ec				endm 
# End of macro FORTH_DSP_VALUEHL
35ec			 
35ec e5					push hl    ; u1 
35ed			 
35ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ed cd 35 1f			call macro_forth_dsp_pop 
35f0				endm 
# End of macro FORTH_DSP_POP
35f0			 
35f0			 
35f0 b7			 or a      ;clear carry flag 
35f1 01 00 00		 ld bc, FORTH_FALSE 
35f4 e1			  pop hl    ; u1 
35f5 d1			  pop de    ; u2 
35f6 ed 52		  sbc hl,de 
35f8 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35fa			 
35fa 01 01 00		 ld bc, FORTH_TRUE 
35fd			.gtcont:  
35fd c5					push bc 
35fe e1					pop hl 
35ff			 
35ff					if DEBUG_FORTH_WORDS 
35ff						DMARK "GT1" 
35ff f5				push af  
3600 3a 14 36			ld a, (.dmark)  
3603 32 71 ee			ld (debug_mark),a  
3606 3a 15 36			ld a, (.dmark+1)  
3609 32 72 ee			ld (debug_mark+1),a  
360c 3a 16 36			ld a, (.dmark+2)  
360f 32 73 ee			ld (debug_mark+2),a  
3612 18 03			jr .pastdmark  
3614 ..			.dmark: db "GT1"  
3617 f1			.pastdmark: pop af  
3618			endm  
# End of macro DMARK
3618						CALLMONITOR 
3618 cd e8 15			call break_point_state  
361b				endm  
# End of macro CALLMONITOR
361b					endif 
361b cd 86 1c				call forth_push_numhl 
361e			 
361e					NEXTW 
361e c3 33 20			jp macro_next 
3621				endm 
# End of macro NEXTW
3621			.EQUAL: 
3621				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3621 31				db WORD_SYS_CORE+29             
3622 8c 36			dw .ENDLOGIC            
3624 02				db 1 + 1 
3625 .. 00			db "=",0              
3627				endm 
# End of macro CWHEAD
3627			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3627				; TODO add floating point number detection 
3627					if DEBUG_FORTH_WORDS_KEY 
3627						DMARK "EQ." 
3627 f5				push af  
3628 3a 3c 36			ld a, (.dmark)  
362b 32 71 ee			ld (debug_mark),a  
362e 3a 3d 36			ld a, (.dmark+1)  
3631 32 72 ee			ld (debug_mark+1),a  
3634 3a 3e 36			ld a, (.dmark+2)  
3637 32 73 ee			ld (debug_mark+2),a  
363a 18 03			jr .pastdmark  
363c ..			.dmark: db "EQ."  
363f f1			.pastdmark: pop af  
3640			endm  
# End of macro DMARK
3640						CALLMONITOR 
3640 cd e8 15			call break_point_state  
3643				endm  
# End of macro CALLMONITOR
3643					endif 
3643					FORTH_DSP 
3643 cd 43 1e			call macro_forth_dsp 
3646				endm 
# End of macro FORTH_DSP
3646					;v5 FORTH_DSP_VALUE 
3646 7e					ld a,(hl)	; get type of value on TOS 
3647 fe 02				cp DS_TYPE_INUM  
3649 28 00				jr z, .eq_inum 
364b			 
364b				if FORTH_ENABLE_FLOATMATH 
364b					jr .eq_done 
364b			 
364b				endif 
364b					 
364b			 
364b			.eq_inum: 
364b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364b cd 7d 1e			call macro_dsp_valuehl 
364e				endm 
# End of macro FORTH_DSP_VALUEHL
364e			 
364e e5					push hl 
364f			 
364f					; destroy value TOS 
364f			 
364f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
364f cd 35 1f			call macro_forth_dsp_pop 
3652				endm 
# End of macro FORTH_DSP_POP
3652			 
3652			 
3652					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3652 cd 7d 1e			call macro_dsp_valuehl 
3655				endm 
# End of macro FORTH_DSP_VALUEHL
3655			 
3655					; one value on hl get other one back 
3655			 
3655 e5					push hl 
3656			 
3656					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3656 cd 35 1f			call macro_forth_dsp_pop 
3659				endm 
# End of macro FORTH_DSP_POP
3659			 
3659 0e 00				ld c, FORTH_FALSE 
365b			 
365b e1					pop hl 
365c d1					pop de 
365d			 
365d 7b					ld a, e 
365e bd					cp l 
365f			 
365f 20 06				jr nz, .eq_done 
3661			 
3661 7a					ld a, d 
3662 bc					cp h 
3663			 
3663 20 02				jr nz, .eq_done 
3665			 
3665 0e 01				ld c, FORTH_TRUE 
3667					 
3667			 
3667			 
3667			.eq_done: 
3667			 
3667					; TODO push value back onto stack for another op etc 
3667			 
3667 26 00				ld h, 0 
3669 69					ld l, c 
366a					if DEBUG_FORTH_WORDS 
366a						DMARK "EQ1" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 71 ee			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 72 ee			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 73 ee			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "EQ1"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683						CALLMONITOR 
3683 cd e8 15			call break_point_state  
3686				endm  
# End of macro CALLMONITOR
3686					endif 
3686 cd 86 1c				call forth_push_numhl 
3689			 
3689					NEXTW 
3689 c3 33 20			jp macro_next 
368c				endm 
# End of macro NEXTW
368c			 
368c			 
368c			.ENDLOGIC: 
368c			; eof 
368c			 
368c			 
# End of file forth_words_logic.asm
368c			include "forth_words_maths.asm" 
368c			 
368c			; | ## Maths Words 
368c			 
368c			.PLUS:	 
368c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
368c 15				db WORD_SYS_CORE+1             
368d ea 36			dw .NEG            
368f 02				db 1 + 1 
3690 .. 00			db "+",0              
3692				endm 
# End of macro CWHEAD
3692			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3692					if DEBUG_FORTH_WORDS_KEY 
3692						DMARK "PLU" 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 71 ee			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 72 ee			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 73 ee			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "PLU"  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd e8 15			call break_point_state  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae					; add top two values and push back result 
36ae			 
36ae					;for v5 FORTH_DSP_VALUE 
36ae					FORTH_DSP 
36ae cd 43 1e			call macro_forth_dsp 
36b1				endm 
# End of macro FORTH_DSP
36b1 7e					ld a,(hl)	; get type of value on TOS 
36b2 fe 02				cp DS_TYPE_INUM  
36b4 28 03				jr z, .dot_inum 
36b6			 
36b6					NEXTW 
36b6 c3 33 20			jp macro_next 
36b9				endm 
# End of macro NEXTW
36b9			 
36b9			; float maths 
36b9			 
36b9				if FORTH_ENABLE_FLOATMATH 
36b9						inc hl      ; now at start of numeric as string 
36b9			 
36b9					if DEBUG_FORTH_MATHS 
36b9						DMARK "ADD" 
36b9				CALLMONITOR 
36b9					endif 
36b9			 
36b9					;ld ix, hl 
36b9					call CON 
36b9			 
36b9			 
36b9					push hl 
36b9					 
36b9					 
36b9			 
36b9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36b9			 
36b9					; get next number 
36b9			 
36b9						FORTH_DSP_VALUE 
36b9			 
36b9						inc hl      ; now at start of numeric as string 
36b9			 
36b9					;ld ix, hl 
36b9					call CON 
36b9			 
36b9					push hl 
36b9			 
36b9			 
36b9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b9			 
36b9						; TODO do add 
36b9			 
36b9						call IADD 
36b9			 
36b9						; TODO get result back as ascii 
36b9			 
36b9						; TODO push result  
36b9			 
36b9			 
36b9			 
36b9						jr .dot_done 
36b9				endif 
36b9			 
36b9			.dot_inum: 
36b9			 
36b9			 
36b9					if DEBUG_FORTH_DOT 
36b9						DMARK "+IT" 
36b9 f5				push af  
36ba 3a ce 36			ld a, (.dmark)  
36bd 32 71 ee			ld (debug_mark),a  
36c0 3a cf 36			ld a, (.dmark+1)  
36c3 32 72 ee			ld (debug_mark+1),a  
36c6 3a d0 36			ld a, (.dmark+2)  
36c9 32 73 ee			ld (debug_mark+2),a  
36cc 18 03			jr .pastdmark  
36ce ..			.dmark: db "+IT"  
36d1 f1			.pastdmark: pop af  
36d2			endm  
# End of macro DMARK
36d2				CALLMONITOR 
36d2 cd e8 15			call break_point_state  
36d5				endm  
# End of macro CALLMONITOR
36d5					endif 
36d5			 
36d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d5 cd 7d 1e			call macro_dsp_valuehl 
36d8				endm 
# End of macro FORTH_DSP_VALUEHL
36d8			 
36d8				; TODO add floating point number detection 
36d8			 
36d8 e5					push hl 
36d9			 
36d9					; destroy value TOS 
36d9			 
36d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d9 cd 35 1f			call macro_forth_dsp_pop 
36dc				endm 
# End of macro FORTH_DSP_POP
36dc			 
36dc			 
36dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36dc cd 7d 1e			call macro_dsp_valuehl 
36df				endm 
# End of macro FORTH_DSP_VALUEHL
36df			 
36df					; one value on hl get other one back 
36df			 
36df d1					pop de 
36e0			 
36e0					; do the add 
36e0			 
36e0 19					add hl,de 
36e1			 
36e1					; save it 
36e1			 
36e1			;		push hl	 
36e1			 
36e1					; 
36e1			 
36e1					; destroy value TOS 
36e1			 
36e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e1 cd 35 1f			call macro_forth_dsp_pop 
36e4				endm 
# End of macro FORTH_DSP_POP
36e4			 
36e4					; TODO push value back onto stack for another op etc 
36e4			 
36e4			;		pop hl 
36e4			 
36e4			.dot_done: 
36e4 cd 86 1c				call forth_push_numhl 
36e7			 
36e7					NEXTW 
36e7 c3 33 20			jp macro_next 
36ea				endm 
# End of macro NEXTW
36ea			.NEG: 
36ea			 
36ea				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36ea 17				db WORD_SYS_CORE+3             
36eb 2d 37			dw .DIV            
36ed 02				db 1 + 1 
36ee .. 00			db "-",0              
36f0				endm 
# End of macro CWHEAD
36f0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36f0					if DEBUG_FORTH_WORDS_KEY 
36f0						DMARK "SUB" 
36f0 f5				push af  
36f1 3a 05 37			ld a, (.dmark)  
36f4 32 71 ee			ld (debug_mark),a  
36f7 3a 06 37			ld a, (.dmark+1)  
36fa 32 72 ee			ld (debug_mark+1),a  
36fd 3a 07 37			ld a, (.dmark+2)  
3700 32 73 ee			ld (debug_mark+2),a  
3703 18 03			jr .pastdmark  
3705 ..			.dmark: db "SUB"  
3708 f1			.pastdmark: pop af  
3709			endm  
# End of macro DMARK
3709						CALLMONITOR 
3709 cd e8 15			call break_point_state  
370c				endm  
# End of macro CALLMONITOR
370c					endif 
370c			 
370c			 
370c				; TODO add floating point number detection 
370c					; v5 FORTH_DSP_VALUE 
370c					FORTH_DSP 
370c cd 43 1e			call macro_forth_dsp 
370f				endm 
# End of macro FORTH_DSP
370f 7e					ld a,(hl)	; get type of value on TOS 
3710 fe 02				cp DS_TYPE_INUM  
3712 28 03				jr z, .neg_inum 
3714			 
3714					NEXTW 
3714 c3 33 20			jp macro_next 
3717				endm 
# End of macro NEXTW
3717			 
3717			; float maths 
3717			 
3717				if FORTH_ENABLE_FLOATMATH 
3717					jr .neg_done 
3717			 
3717				endif 
3717					 
3717			 
3717			.neg_inum: 
3717					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3717 cd 7d 1e			call macro_dsp_valuehl 
371a				endm 
# End of macro FORTH_DSP_VALUEHL
371a			 
371a e5					push hl 
371b			 
371b					; destroy value TOS 
371b			 
371b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371b cd 35 1f			call macro_forth_dsp_pop 
371e				endm 
# End of macro FORTH_DSP_POP
371e			 
371e			 
371e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
371e cd 7d 1e			call macro_dsp_valuehl 
3721				endm 
# End of macro FORTH_DSP_VALUEHL
3721			 
3721					; one value on hl get other one back 
3721			 
3721 d1					pop de 
3722			 
3722					; do the sub 
3722			;		ex de, hl 
3722			 
3722 ed 52				sbc hl,de 
3724			 
3724					; save it 
3724			 
3724			;		push hl	 
3724			 
3724					; 
3724			 
3724					; destroy value TOS 
3724			 
3724					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3724 cd 35 1f			call macro_forth_dsp_pop 
3727				endm 
# End of macro FORTH_DSP_POP
3727			 
3727					; TODO push value back onto stack for another op etc 
3727			 
3727			;		pop hl 
3727			 
3727 cd 86 1c				call forth_push_numhl 
372a			.neg_done: 
372a			 
372a					NEXTW 
372a c3 33 20			jp macro_next 
372d				endm 
# End of macro NEXTW
372d			.DIV: 
372d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
372d 18				db WORD_SYS_CORE+4             
372e 7a 37			dw .MUL            
3730 02				db 1 + 1 
3731 .. 00			db "/",0              
3733				endm 
# End of macro CWHEAD
3733			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3733					if DEBUG_FORTH_WORDS_KEY 
3733						DMARK "DIV" 
3733 f5				push af  
3734 3a 48 37			ld a, (.dmark)  
3737 32 71 ee			ld (debug_mark),a  
373a 3a 49 37			ld a, (.dmark+1)  
373d 32 72 ee			ld (debug_mark+1),a  
3740 3a 4a 37			ld a, (.dmark+2)  
3743 32 73 ee			ld (debug_mark+2),a  
3746 18 03			jr .pastdmark  
3748 ..			.dmark: db "DIV"  
374b f1			.pastdmark: pop af  
374c			endm  
# End of macro DMARK
374c						CALLMONITOR 
374c cd e8 15			call break_point_state  
374f				endm  
# End of macro CALLMONITOR
374f					endif 
374f				; TODO add floating point number detection 
374f					; v5 FORTH_DSP_VALUE 
374f					FORTH_DSP 
374f cd 43 1e			call macro_forth_dsp 
3752				endm 
# End of macro FORTH_DSP
3752 7e					ld a,(hl)	; get type of value on TOS 
3753 fe 02				cp DS_TYPE_INUM  
3755 28 03				jr z, .div_inum 
3757			 
3757				if FORTH_ENABLE_FLOATMATH 
3757					jr .div_done 
3757			 
3757				endif 
3757					NEXTW 
3757 c3 33 20			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			.div_inum: 
375a			 
375a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375a cd 7d 1e			call macro_dsp_valuehl 
375d				endm 
# End of macro FORTH_DSP_VALUEHL
375d			 
375d e5					push hl    ; to go to bc 
375e			 
375e					; destroy value TOS 
375e			 
375e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375e cd 35 1f			call macro_forth_dsp_pop 
3761				endm 
# End of macro FORTH_DSP_POP
3761			 
3761			 
3761					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3761 cd 7d 1e			call macro_dsp_valuehl 
3764				endm 
# End of macro FORTH_DSP_VALUEHL
3764			 
3764					; hl to go to de 
3764			 
3764 e5					push hl 
3765			 
3765 c1					pop bc 
3766 d1					pop de		 
3767			 
3767			 
3767					if DEBUG_FORTH_MATHS 
3767						DMARK "DIV" 
3767				CALLMONITOR 
3767					endif 
3767					; one value on hl but move to a get other one back 
3767			 
3767			        
3767 cd 44 0d			call Div16 
376a			 
376a			;	push af	 
376a e5				push hl 
376b c5				push bc 
376c			 
376c					if DEBUG_FORTH_MATHS 
376c						DMARK "DI1" 
376c				CALLMONITOR 
376c					endif 
376c			 
376c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376c cd 35 1f			call macro_forth_dsp_pop 
376f				endm 
# End of macro FORTH_DSP_POP
376f			 
376f			 
376f			 
376f e1					pop hl    ; result 
3770			 
3770 cd 86 1c				call forth_push_numhl 
3773			 
3773 e1					pop hl    ; reminder 
3774			;		ld h,0 
3774			;		ld l,d 
3774			 
3774 cd 86 1c				call forth_push_numhl 
3777			.div_done: 
3777					NEXTW 
3777 c3 33 20			jp macro_next 
377a				endm 
# End of macro NEXTW
377a			.MUL: 
377a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
377a 19				db WORD_SYS_CORE+5             
377b bf 37			dw .MIN            
377d 02				db 1 + 1 
377e .. 00			db "*",0              
3780				endm 
# End of macro CWHEAD
3780			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3780				; TODO add floating point number detection 
3780					if DEBUG_FORTH_WORDS_KEY 
3780						DMARK "MUL" 
3780 f5				push af  
3781 3a 95 37			ld a, (.dmark)  
3784 32 71 ee			ld (debug_mark),a  
3787 3a 96 37			ld a, (.dmark+1)  
378a 32 72 ee			ld (debug_mark+1),a  
378d 3a 97 37			ld a, (.dmark+2)  
3790 32 73 ee			ld (debug_mark+2),a  
3793 18 03			jr .pastdmark  
3795 ..			.dmark: db "MUL"  
3798 f1			.pastdmark: pop af  
3799			endm  
# End of macro DMARK
3799						CALLMONITOR 
3799 cd e8 15			call break_point_state  
379c				endm  
# End of macro CALLMONITOR
379c					endif 
379c					FORTH_DSP 
379c cd 43 1e			call macro_forth_dsp 
379f				endm 
# End of macro FORTH_DSP
379f					; v5 FORTH_DSP_VALUE 
379f 7e					ld a,(hl)	; get type of value on TOS 
37a0 fe 02				cp DS_TYPE_INUM  
37a2 28 03				jr z, .mul_inum 
37a4			 
37a4				if FORTH_ENABLE_FLOATMATH 
37a4					jr .mul_done 
37a4			 
37a4				endif 
37a4			 
37a4					NEXTW 
37a4 c3 33 20			jp macro_next 
37a7				endm 
# End of macro NEXTW
37a7			.mul_inum:	 
37a7			 
37a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a7 cd 7d 1e			call macro_dsp_valuehl 
37aa				endm 
# End of macro FORTH_DSP_VALUEHL
37aa			 
37aa e5					push hl 
37ab			 
37ab					; destroy value TOS 
37ab			 
37ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ab cd 35 1f			call macro_forth_dsp_pop 
37ae				endm 
# End of macro FORTH_DSP_POP
37ae			 
37ae			 
37ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ae cd 7d 1e			call macro_dsp_valuehl 
37b1				endm 
# End of macro FORTH_DSP_VALUEHL
37b1			 
37b1					; one value on hl but move to a get other one back 
37b1			 
37b1 7d					ld a, l 
37b2			 
37b2 d1					pop de 
37b3			 
37b3					; do the mull 
37b3			;		ex de, hl 
37b3			 
37b3 cd 6a 0d				call Mult16 
37b6					; save it 
37b6			 
37b6			;		push hl	 
37b6			 
37b6					; 
37b6			 
37b6					; destroy value TOS 
37b6			 
37b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b6 cd 35 1f			call macro_forth_dsp_pop 
37b9				endm 
# End of macro FORTH_DSP_POP
37b9			 
37b9					; TODO push value back onto stack for another op etc 
37b9			 
37b9			;		pop hl 
37b9			 
37b9 cd 86 1c				call forth_push_numhl 
37bc			 
37bc			.mul_done: 
37bc					NEXTW 
37bc c3 33 20			jp macro_next 
37bf				endm 
# End of macro NEXTW
37bf			 
37bf			 
37bf			 
37bf			 
37bf			.MIN: 
37bf				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37bf 49				db WORD_SYS_CORE+53             
37c0 40 38			dw .MAX            
37c2 04				db 3 + 1 
37c3 .. 00			db "MIN",0              
37c7				endm 
# End of macro CWHEAD
37c7			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37c7					if DEBUG_FORTH_WORDS_KEY 
37c7						DMARK "MIN" 
37c7 f5				push af  
37c8 3a dc 37			ld a, (.dmark)  
37cb 32 71 ee			ld (debug_mark),a  
37ce 3a dd 37			ld a, (.dmark+1)  
37d1 32 72 ee			ld (debug_mark+1),a  
37d4 3a de 37			ld a, (.dmark+2)  
37d7 32 73 ee			ld (debug_mark+2),a  
37da 18 03			jr .pastdmark  
37dc ..			.dmark: db "MIN"  
37df f1			.pastdmark: pop af  
37e0			endm  
# End of macro DMARK
37e0						CALLMONITOR 
37e0 cd e8 15			call break_point_state  
37e3				endm  
# End of macro CALLMONITOR
37e3					endif 
37e3					; get u2 
37e3			 
37e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e3 cd 7d 1e			call macro_dsp_valuehl 
37e6				endm 
# End of macro FORTH_DSP_VALUEHL
37e6			 
37e6 e5					push hl   ; u2 
37e7			 
37e7					; destroy value TOS 
37e7			 
37e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e7 cd 35 1f			call macro_forth_dsp_pop 
37ea				endm 
# End of macro FORTH_DSP_POP
37ea			 
37ea					; get u1 
37ea			 
37ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ea cd 7d 1e			call macro_dsp_valuehl 
37ed				endm 
# End of macro FORTH_DSP_VALUEHL
37ed			 
37ed e5					push hl  ; u1 
37ee			 
37ee					; destroy value TOS 
37ee			 
37ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ee cd 35 1f			call macro_forth_dsp_pop 
37f1				endm 
# End of macro FORTH_DSP_POP
37f1			 
37f1 b7			 or a      ;clear carry flag 
37f2 e1			  pop hl    ; u1 
37f3 d1			  pop de    ; u2 
37f4 e5				push hl   ; saved in case hl is lowest 
37f5 ed 52		  sbc hl,de 
37f7 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37f9			 
37f9 e1				pop hl 
37fa					if DEBUG_FORTH_WORDS 
37fa						DMARK "MIN" 
37fa f5				push af  
37fb 3a 0f 38			ld a, (.dmark)  
37fe 32 71 ee			ld (debug_mark),a  
3801 3a 10 38			ld a, (.dmark+1)  
3804 32 72 ee			ld (debug_mark+1),a  
3807 3a 11 38			ld a, (.dmark+2)  
380a 32 73 ee			ld (debug_mark+2),a  
380d 18 03			jr .pastdmark  
380f ..			.dmark: db "MIN"  
3812 f1			.pastdmark: pop af  
3813			endm  
# End of macro DMARK
3813						CALLMONITOR 
3813 cd e8 15			call break_point_state  
3816				endm  
# End of macro CALLMONITOR
3816					endif 
3816 cd 86 1c				call forth_push_numhl 
3819			 
3819				       NEXTW 
3819 c3 33 20			jp macro_next 
381c				endm 
# End of macro NEXTW
381c			 
381c			.mincont:  
381c c1				pop bc   ; tidy up 
381d eb				ex de , hl  
381e					if DEBUG_FORTH_WORDS 
381e						DMARK "MI1" 
381e f5				push af  
381f 3a 33 38			ld a, (.dmark)  
3822 32 71 ee			ld (debug_mark),a  
3825 3a 34 38			ld a, (.dmark+1)  
3828 32 72 ee			ld (debug_mark+1),a  
382b 3a 35 38			ld a, (.dmark+2)  
382e 32 73 ee			ld (debug_mark+2),a  
3831 18 03			jr .pastdmark  
3833 ..			.dmark: db "MI1"  
3836 f1			.pastdmark: pop af  
3837			endm  
# End of macro DMARK
3837						CALLMONITOR 
3837 cd e8 15			call break_point_state  
383a				endm  
# End of macro CALLMONITOR
383a					endif 
383a cd 86 1c				call forth_push_numhl 
383d			 
383d				       NEXTW 
383d c3 33 20			jp macro_next 
3840				endm 
# End of macro NEXTW
3840			.MAX: 
3840				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3840 4a				db WORD_SYS_CORE+54             
3841 c1 38			dw .RND16            
3843 04				db 3 + 1 
3844 .. 00			db "MAX",0              
3848				endm 
# End of macro CWHEAD
3848			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3848					if DEBUG_FORTH_WORDS_KEY 
3848						DMARK "MAX" 
3848 f5				push af  
3849 3a 5d 38			ld a, (.dmark)  
384c 32 71 ee			ld (debug_mark),a  
384f 3a 5e 38			ld a, (.dmark+1)  
3852 32 72 ee			ld (debug_mark+1),a  
3855 3a 5f 38			ld a, (.dmark+2)  
3858 32 73 ee			ld (debug_mark+2),a  
385b 18 03			jr .pastdmark  
385d ..			.dmark: db "MAX"  
3860 f1			.pastdmark: pop af  
3861			endm  
# End of macro DMARK
3861						CALLMONITOR 
3861 cd e8 15			call break_point_state  
3864				endm  
# End of macro CALLMONITOR
3864					endif 
3864					; get u2 
3864			 
3864					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3864 cd 7d 1e			call macro_dsp_valuehl 
3867				endm 
# End of macro FORTH_DSP_VALUEHL
3867			 
3867 e5					push hl   ; u2 
3868			 
3868					; destroy value TOS 
3868			 
3868					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3868 cd 35 1f			call macro_forth_dsp_pop 
386b				endm 
# End of macro FORTH_DSP_POP
386b			 
386b					; get u1 
386b			 
386b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386b cd 7d 1e			call macro_dsp_valuehl 
386e				endm 
# End of macro FORTH_DSP_VALUEHL
386e			 
386e e5					push hl  ; u1 
386f			 
386f					; destroy value TOS 
386f			 
386f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
386f cd 35 1f			call macro_forth_dsp_pop 
3872				endm 
# End of macro FORTH_DSP_POP
3872			 
3872 b7			 or a      ;clear carry flag 
3873 e1			  pop hl    ; u1 
3874 d1			  pop de    ; u2 
3875 e5				push hl   ; saved in case hl is lowest 
3876 ed 52		  sbc hl,de 
3878 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
387a			 
387a e1				pop hl 
387b					if DEBUG_FORTH_WORDS 
387b						DMARK "MAX" 
387b f5				push af  
387c 3a 90 38			ld a, (.dmark)  
387f 32 71 ee			ld (debug_mark),a  
3882 3a 91 38			ld a, (.dmark+1)  
3885 32 72 ee			ld (debug_mark+1),a  
3888 3a 92 38			ld a, (.dmark+2)  
388b 32 73 ee			ld (debug_mark+2),a  
388e 18 03			jr .pastdmark  
3890 ..			.dmark: db "MAX"  
3893 f1			.pastdmark: pop af  
3894			endm  
# End of macro DMARK
3894						CALLMONITOR 
3894 cd e8 15			call break_point_state  
3897				endm  
# End of macro CALLMONITOR
3897					endif 
3897 cd 86 1c				call forth_push_numhl 
389a			 
389a				       NEXTW 
389a c3 33 20			jp macro_next 
389d				endm 
# End of macro NEXTW
389d			 
389d			.maxcont:  
389d c1				pop bc   ; tidy up 
389e eb				ex de , hl  
389f					if DEBUG_FORTH_WORDS 
389f						DMARK "MA1" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 71 ee			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 72 ee			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 73 ee			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "MA1"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8						CALLMONITOR 
38b8 cd e8 15			call break_point_state  
38bb				endm  
# End of macro CALLMONITOR
38bb					endif 
38bb cd 86 1c				call forth_push_numhl 
38be				       NEXTW 
38be c3 33 20			jp macro_next 
38c1				endm 
# End of macro NEXTW
38c1			 
38c1			.RND16: 
38c1				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38c1 4e				db WORD_SYS_CORE+58             
38c2 f0 38			dw .RND8            
38c4 06				db 5 + 1 
38c5 .. 00			db "RND16",0              
38cb				endm 
# End of macro CWHEAD
38cb			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38cb					if DEBUG_FORTH_WORDS_KEY 
38cb						DMARK "R16" 
38cb f5				push af  
38cc 3a e0 38			ld a, (.dmark)  
38cf 32 71 ee			ld (debug_mark),a  
38d2 3a e1 38			ld a, (.dmark+1)  
38d5 32 72 ee			ld (debug_mark+1),a  
38d8 3a e2 38			ld a, (.dmark+2)  
38db 32 73 ee			ld (debug_mark+2),a  
38de 18 03			jr .pastdmark  
38e0 ..			.dmark: db "R16"  
38e3 f1			.pastdmark: pop af  
38e4			endm  
# End of macro DMARK
38e4						CALLMONITOR 
38e4 cd e8 15			call break_point_state  
38e7				endm  
# End of macro CALLMONITOR
38e7					endif 
38e7 cd 0e 0d				call prng16  
38ea cd 86 1c				call forth_push_numhl 
38ed				       NEXTW 
38ed c3 33 20			jp macro_next 
38f0				endm 
# End of macro NEXTW
38f0			.RND8: 
38f0				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38f0 60				db WORD_SYS_CORE+76             
38f1 25 39			dw .RND            
38f3 05				db 4 + 1 
38f4 .. 00			db "RND8",0              
38f9				endm 
# End of macro CWHEAD
38f9			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38f9					if DEBUG_FORTH_WORDS_KEY 
38f9						DMARK "RN8" 
38f9 f5				push af  
38fa 3a 0e 39			ld a, (.dmark)  
38fd 32 71 ee			ld (debug_mark),a  
3900 3a 0f 39			ld a, (.dmark+1)  
3903 32 72 ee			ld (debug_mark+1),a  
3906 3a 10 39			ld a, (.dmark+2)  
3909 32 73 ee			ld (debug_mark+2),a  
390c 18 03			jr .pastdmark  
390e ..			.dmark: db "RN8"  
3911 f1			.pastdmark: pop af  
3912			endm  
# End of macro DMARK
3912						CALLMONITOR 
3912 cd e8 15			call break_point_state  
3915				endm  
# End of macro CALLMONITOR
3915					endif 
3915 2a af eb				ld hl,(xrandc) 
3918 23					inc hl 
3919 cd 28 0d				call xrnd 
391c 6f					ld l,a	 
391d 26 00				ld h,0 
391f cd 86 1c				call forth_push_numhl 
3922				       NEXTW 
3922 c3 33 20			jp macro_next 
3925				endm 
# End of macro NEXTW
3925			.RND: 
3925				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3925 60				db WORD_SYS_CORE+76             
3926 2b 3a			dw .ENDMATHS            
3928 04				db 3 + 1 
3929 .. 00			db "RND",0              
392d				endm 
# End of macro CWHEAD
392d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
392d			 
392d					if DEBUG_FORTH_WORDS_KEY 
392d						DMARK "RND" 
392d f5				push af  
392e 3a 42 39			ld a, (.dmark)  
3931 32 71 ee			ld (debug_mark),a  
3934 3a 43 39			ld a, (.dmark+1)  
3937 32 72 ee			ld (debug_mark+1),a  
393a 3a 44 39			ld a, (.dmark+2)  
393d 32 73 ee			ld (debug_mark+2),a  
3940 18 03			jr .pastdmark  
3942 ..			.dmark: db "RND"  
3945 f1			.pastdmark: pop af  
3946			endm  
# End of macro DMARK
3946						CALLMONITOR 
3946 cd e8 15			call break_point_state  
3949				endm  
# End of macro CALLMONITOR
3949					endif 
3949					 
3949					FORTH_DSP_VALUEHL    ; upper range 
3949 cd 7d 1e			call macro_dsp_valuehl 
394c				endm 
# End of macro FORTH_DSP_VALUEHL
394c			 
394c 22 b3 eb				ld (LFSRSeed), hl	 
394f			 
394f					if DEBUG_FORTH_WORDS 
394f						DMARK "RN1" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 71 ee			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 72 ee			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 73 ee			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "RN1"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968						CALLMONITOR 
3968 cd e8 15			call break_point_state  
396b				endm  
# End of macro CALLMONITOR
396b					endif 
396b					FORTH_DSP_POP 
396b cd 35 1f			call macro_forth_dsp_pop 
396e				endm 
# End of macro FORTH_DSP_POP
396e			 
396e					FORTH_DSP_VALUEHL    ; low range 
396e cd 7d 1e			call macro_dsp_valuehl 
3971				endm 
# End of macro FORTH_DSP_VALUEHL
3971			 
3971					if DEBUG_FORTH_WORDS 
3971						DMARK "RN2" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 71 ee			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 72 ee			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 73 ee			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "RN2"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a						CALLMONITOR 
398a cd e8 15			call break_point_state  
398d				endm  
# End of macro CALLMONITOR
398d					endif 
398d 22 b5 eb				ld (LFSRSeed+2), hl 
3990			 
3990					FORTH_DSP_POP 
3990 cd 35 1f			call macro_forth_dsp_pop 
3993				endm 
# End of macro FORTH_DSP_POP
3993			 
3993 e5					push hl 
3994			 
3994 e1			.inrange:	pop hl 
3995 cd 0e 0d				call prng16  
3998					if DEBUG_FORTH_WORDS 
3998						DMARK "RN3" 
3998 f5				push af  
3999 3a ad 39			ld a, (.dmark)  
399c 32 71 ee			ld (debug_mark),a  
399f 3a ae 39			ld a, (.dmark+1)  
39a2 32 72 ee			ld (debug_mark+1),a  
39a5 3a af 39			ld a, (.dmark+2)  
39a8 32 73 ee			ld (debug_mark+2),a  
39ab 18 03			jr .pastdmark  
39ad ..			.dmark: db "RN3"  
39b0 f1			.pastdmark: pop af  
39b1			endm  
# End of macro DMARK
39b1						CALLMONITOR 
39b1 cd e8 15			call break_point_state  
39b4				endm  
# End of macro CALLMONITOR
39b4					endif 
39b4					 
39b4					; if the range is 8bit knock out the high byte 
39b4			 
39b4 ed 5b b3 eb			ld de, (LFSRSeed)     ; check high level 
39b8			 
39b8 3e 00				ld a, 0 
39ba ba					cp d  
39bb 20 1e				jr nz, .hirange 
39bd 26 00				ld h, 0   ; knock it down to 8bit 
39bf			 
39bf					if DEBUG_FORTH_WORDS 
39bf						DMARK "RNk" 
39bf f5				push af  
39c0 3a d4 39			ld a, (.dmark)  
39c3 32 71 ee			ld (debug_mark),a  
39c6 3a d5 39			ld a, (.dmark+1)  
39c9 32 72 ee			ld (debug_mark+1),a  
39cc 3a d6 39			ld a, (.dmark+2)  
39cf 32 73 ee			ld (debug_mark+2),a  
39d2 18 03			jr .pastdmark  
39d4 ..			.dmark: db "RNk"  
39d7 f1			.pastdmark: pop af  
39d8			endm  
# End of macro DMARK
39d8						CALLMONITOR 
39d8 cd e8 15			call break_point_state  
39db				endm  
# End of macro CALLMONITOR
39db					endif 
39db			.hirange:   
39db e5					push hl  
39dc b7					or a  
39dd ed 52		                sbc hl, de 
39df			 
39df					;call cmp16 
39df			 
39df 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39e1 e1					pop hl 
39e2 e5					push hl 
39e3			 
39e3					if DEBUG_FORTH_WORDS 
39e3						DMARK "RN4" 
39e3 f5				push af  
39e4 3a f8 39			ld a, (.dmark)  
39e7 32 71 ee			ld (debug_mark),a  
39ea 3a f9 39			ld a, (.dmark+1)  
39ed 32 72 ee			ld (debug_mark+1),a  
39f0 3a fa 39			ld a, (.dmark+2)  
39f3 32 73 ee			ld (debug_mark+2),a  
39f6 18 03			jr .pastdmark  
39f8 ..			.dmark: db "RN4"  
39fb f1			.pastdmark: pop af  
39fc			endm  
# End of macro DMARK
39fc						CALLMONITOR 
39fc cd e8 15			call break_point_state  
39ff				endm  
# End of macro CALLMONITOR
39ff					endif 
39ff ed 5b b5 eb			ld de, (LFSRSeed+2)   ; check low range 
3a03					;call cmp16 
3a03				 
3a03 b7					or a  
3a04 ed 52		                sbc hl, de 
3a06 38 8c				jr c, .inrange 
3a08			 
3a08 e1					pop hl 
3a09					 
3a09					if DEBUG_FORTH_WORDS 
3a09						DMARK "RNd" 
3a09 f5				push af  
3a0a 3a 1e 3a			ld a, (.dmark)  
3a0d 32 71 ee			ld (debug_mark),a  
3a10 3a 1f 3a			ld a, (.dmark+1)  
3a13 32 72 ee			ld (debug_mark+1),a  
3a16 3a 20 3a			ld a, (.dmark+2)  
3a19 32 73 ee			ld (debug_mark+2),a  
3a1c 18 03			jr .pastdmark  
3a1e ..			.dmark: db "RNd"  
3a21 f1			.pastdmark: pop af  
3a22			endm  
# End of macro DMARK
3a22						CALLMONITOR 
3a22 cd e8 15			call break_point_state  
3a25				endm  
# End of macro CALLMONITOR
3a25					endif 
3a25			 
3a25			 
3a25 cd 86 1c				call forth_push_numhl 
3a28				       NEXTW 
3a28 c3 33 20			jp macro_next 
3a2b				endm 
# End of macro NEXTW
3a2b			 
3a2b			.ENDMATHS: 
3a2b			 
3a2b			; eof 
3a2b			 
# End of file forth_words_maths.asm
3a2b			include "forth_words_display.asm" 
3a2b			 
3a2b			; | ## Display Words 
3a2b			 
3a2b			.ACT: 
3a2b			 
3a2b				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a2b 62				db WORD_SYS_CORE+78             
3a2c 77 3a			dw .INFO            
3a2e 07				db 6 + 1 
3a2f .. 00			db "ACTIVE",0              
3a36				endm 
# End of macro CWHEAD
3a36			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a36			;  
3a36			; | | e.g. $ff $00 do active . $01 pause loop 
3a36			 
3a36					if DEBUG_FORTH_WORDS_KEY 
3a36						DMARK "ACT" 
3a36 f5				push af  
3a37 3a 4b 3a			ld a, (.dmark)  
3a3a 32 71 ee			ld (debug_mark),a  
3a3d 3a 4c 3a			ld a, (.dmark+1)  
3a40 32 72 ee			ld (debug_mark+1),a  
3a43 3a 4d 3a			ld a, (.dmark+2)  
3a46 32 73 ee			ld (debug_mark+2),a  
3a49 18 03			jr .pastdmark  
3a4b ..			.dmark: db "ACT"  
3a4e f1			.pastdmark: pop af  
3a4f			endm  
# End of macro DMARK
3a4f						CALLMONITOR 
3a4f cd e8 15			call break_point_state  
3a52				endm  
# End of macro CALLMONITOR
3a52					endif 
3a52 cd 11 0b				call active 
3a55					if DEBUG_FORTH_WORDS 
3a55						DMARK "ACp" 
3a55 f5				push af  
3a56 3a 6a 3a			ld a, (.dmark)  
3a59 32 71 ee			ld (debug_mark),a  
3a5c 3a 6b 3a			ld a, (.dmark+1)  
3a5f 32 72 ee			ld (debug_mark+1),a  
3a62 3a 6c 3a			ld a, (.dmark+2)  
3a65 32 73 ee			ld (debug_mark+2),a  
3a68 18 03			jr .pastdmark  
3a6a ..			.dmark: db "ACp"  
3a6d f1			.pastdmark: pop af  
3a6e			endm  
# End of macro DMARK
3a6e						CALLMONITOR 
3a6e cd e8 15			call break_point_state  
3a71				endm  
# End of macro CALLMONITOR
3a71					endif 
3a71 cd f4 1c				call forth_push_str 
3a74			 
3a74					NEXTW 
3a74 c3 33 20			jp macro_next 
3a77				endm 
# End of macro NEXTW
3a77			.INFO: 
3a77			 
3a77				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a77 62				db WORD_SYS_CORE+78             
3a78 94 3a			dw .ATP            
3a7a 05				db 4 + 1 
3a7b .. 00			db "INFO",0              
3a80				endm 
# End of macro CWHEAD
3a80			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a80					FORTH_DSP_VALUEHL 
3a80 cd 7d 1e			call macro_dsp_valuehl 
3a83				endm 
# End of macro FORTH_DSP_VALUEHL
3a83			 
3a83					FORTH_DSP_POP 
3a83 cd 35 1f			call macro_forth_dsp_pop 
3a86				endm 
# End of macro FORTH_DSP_POP
3a86			 
3a86 e5					push hl 
3a87			 
3a87					FORTH_DSP_VALUEHL 
3a87 cd 7d 1e			call macro_dsp_valuehl 
3a8a				endm 
# End of macro FORTH_DSP_VALUEHL
3a8a			 
3a8a					FORTH_DSP_POP 
3a8a cd 35 1f			call macro_forth_dsp_pop 
3a8d				endm 
# End of macro FORTH_DSP_POP
3a8d			 
3a8d d1					pop de 
3a8e			 
3a8e cd 4b 0b				call info_panel 
3a91			 
3a91			 
3a91					NEXTW 
3a91 c3 33 20			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			.ATP: 
3a94				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a94 62				db WORD_SYS_CORE+78             
3a95 0b 3b			dw .FB            
3a97 04				db 3 + 1 
3a98 .. 00			db "AT?",0              
3a9c				endm 
# End of macro CWHEAD
3a9c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a9c					if DEBUG_FORTH_WORDS_KEY 
3a9c						DMARK "AT?" 
3a9c f5				push af  
3a9d 3a b1 3a			ld a, (.dmark)  
3aa0 32 71 ee			ld (debug_mark),a  
3aa3 3a b2 3a			ld a, (.dmark+1)  
3aa6 32 72 ee			ld (debug_mark+1),a  
3aa9 3a b3 3a			ld a, (.dmark+2)  
3aac 32 73 ee			ld (debug_mark+2),a  
3aaf 18 03			jr .pastdmark  
3ab1 ..			.dmark: db "AT?"  
3ab4 f1			.pastdmark: pop af  
3ab5			endm  
# End of macro DMARK
3ab5						CALLMONITOR 
3ab5 cd e8 15			call break_point_state  
3ab8				endm  
# End of macro CALLMONITOR
3ab8					endif 
3ab8 3a 64 ea				ld a, (f_cursor_ptr) 
3abb			 
3abb			if DEBUG_FORTH_WORDS 
3abb				DMARK "AT?" 
3abb f5				push af  
3abc 3a d0 3a			ld a, (.dmark)  
3abf 32 71 ee			ld (debug_mark),a  
3ac2 3a d1 3a			ld a, (.dmark+1)  
3ac5 32 72 ee			ld (debug_mark+1),a  
3ac8 3a d2 3a			ld a, (.dmark+2)  
3acb 32 73 ee			ld (debug_mark+2),a  
3ace 18 03			jr .pastdmark  
3ad0 ..			.dmark: db "AT?"  
3ad3 f1			.pastdmark: pop af  
3ad4			endm  
# End of macro DMARK
3ad4				CALLMONITOR 
3ad4 cd e8 15			call break_point_state  
3ad7				endm  
# End of macro CALLMONITOR
3ad7			endif	 
3ad7					; count the number of rows 
3ad7			 
3ad7 06 00				ld b, 0 
3ad9 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ada d6 28				sub display_cols 
3adc f2 e2 3a				jp p, .atprunder 
3adf 04					inc b 
3ae0 18 f7				jr .atpr 
3ae2			.atprunder:	 
3ae2			if DEBUG_FORTH_WORDS 
3ae2				DMARK "A?2" 
3ae2 f5				push af  
3ae3 3a f7 3a			ld a, (.dmark)  
3ae6 32 71 ee			ld (debug_mark),a  
3ae9 3a f8 3a			ld a, (.dmark+1)  
3aec 32 72 ee			ld (debug_mark+1),a  
3aef 3a f9 3a			ld a, (.dmark+2)  
3af2 32 73 ee			ld (debug_mark+2),a  
3af5 18 03			jr .pastdmark  
3af7 ..			.dmark: db "A?2"  
3afa f1			.pastdmark: pop af  
3afb			endm  
# End of macro DMARK
3afb				CALLMONITOR 
3afb cd e8 15			call break_point_state  
3afe				endm  
# End of macro CALLMONITOR
3afe			endif	 
3afe 26 00				ld h, 0 
3b00 69					ld l, c 
3b01 cd 86 1c				call forth_push_numhl 
3b04 68					ld l, b  
3b05 cd 86 1c				call forth_push_numhl 
3b08			 
3b08			 
3b08				NEXTW 
3b08 c3 33 20			jp macro_next 
3b0b				endm 
# End of macro NEXTW
3b0b			 
3b0b			.FB: 
3b0b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b0b 1b				db WORD_SYS_CORE+7             
3b0c 59 3b			dw .EMIT            
3b0e 03				db 2 + 1 
3b0f .. 00			db "FB",0              
3b12				endm 
# End of macro CWHEAD
3b12			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b12			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b12			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b12			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b12					if DEBUG_FORTH_WORDS_KEY 
3b12						DMARK "FB." 
3b12 f5				push af  
3b13 3a 27 3b			ld a, (.dmark)  
3b16 32 71 ee			ld (debug_mark),a  
3b19 3a 28 3b			ld a, (.dmark+1)  
3b1c 32 72 ee			ld (debug_mark+1),a  
3b1f 3a 29 3b			ld a, (.dmark+2)  
3b22 32 73 ee			ld (debug_mark+2),a  
3b25 18 03			jr .pastdmark  
3b27 ..			.dmark: db "FB."  
3b2a f1			.pastdmark: pop af  
3b2b			endm  
# End of macro DMARK
3b2b						CALLMONITOR 
3b2b cd e8 15			call break_point_state  
3b2e				endm  
# End of macro CALLMONITOR
3b2e					endif 
3b2e			 
3b2e					FORTH_DSP_VALUEHL 
3b2e cd 7d 1e			call macro_dsp_valuehl 
3b31				endm 
# End of macro FORTH_DSP_VALUEHL
3b31			 
3b31 7d					ld a, l 
3b32 fe 01				cp 1 
3b34 20 05				jr nz, .fbn1 
3b36 21 16 ed				ld hl, display_fb1 
3b39 18 15				jr .fbset 
3b3b fe 02		.fbn1:		cp 2 
3b3d 20 05				jr nz, .fbn2 
3b3f 21 d4 eb				ld hl, display_fb2 
3b42 18 0c				jr .fbset 
3b44 fe 03		.fbn2:		cp 3 
3b46 20 05				jr nz, .fbn3 
3b48 21 75 ec				ld hl, display_fb3 
3b4b 18 03				jr .fbset 
3b4d			.fbn3:		 ; if invalid number select first 
3b4d 21 16 ed				ld hl, display_fb1 
3b50 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3b53			 
3b53					FORTH_DSP_POP 
3b53 cd 35 1f			call macro_forth_dsp_pop 
3b56				endm 
# End of macro FORTH_DSP_POP
3b56			 
3b56					NEXTW 
3b56 c3 33 20			jp macro_next 
3b59				endm 
# End of macro NEXTW
3b59			 
3b59			 
3b59			.EMIT: 
3b59				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b59 1b				db WORD_SYS_CORE+7             
3b5a aa 3b			dw .DOTH            
3b5c 05				db 4 + 1 
3b5d .. 00			db "EMIT",0              
3b62				endm 
# End of macro CWHEAD
3b62			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b62					; get value off TOS and display it 
3b62			 
3b62					if DEBUG_FORTH_WORDS_KEY 
3b62						DMARK "EMT" 
3b62 f5				push af  
3b63 3a 77 3b			ld a, (.dmark)  
3b66 32 71 ee			ld (debug_mark),a  
3b69 3a 78 3b			ld a, (.dmark+1)  
3b6c 32 72 ee			ld (debug_mark+1),a  
3b6f 3a 79 3b			ld a, (.dmark+2)  
3b72 32 73 ee			ld (debug_mark+2),a  
3b75 18 03			jr .pastdmark  
3b77 ..			.dmark: db "EMT"  
3b7a f1			.pastdmark: pop af  
3b7b			endm  
# End of macro DMARK
3b7b						CALLMONITOR 
3b7b cd e8 15			call break_point_state  
3b7e				endm  
# End of macro CALLMONITOR
3b7e					endif 
3b7e			 
3b7e					FORTH_DSP_VALUEHL 
3b7e cd 7d 1e			call macro_dsp_valuehl 
3b81				endm 
# End of macro FORTH_DSP_VALUEHL
3b81			 
3b81 7d					ld a,l 
3b82			 
3b82					; TODO write to display 
3b82			 
3b82 32 c5 e4				ld (os_input), a 
3b85 3e 00				ld a, 0 
3b87 32 c6 e4				ld (os_input+1), a 
3b8a					 
3b8a 3a 64 ea				ld a, (f_cursor_ptr) 
3b8d 11 c5 e4				ld de, os_input 
3b90 cd cd 0b				call str_at_display 
3b93			 
3b93			 
3b93 3a 42 ea				ld a,(cli_autodisplay) 
3b96 fe 00				cp 0 
3b98 28 03				jr z, .enoupdate 
3b9a cd dd 0b						call update_display 
3b9d					.enoupdate: 
3b9d			 
3b9d 3a 64 ea				ld a, (f_cursor_ptr) 
3ba0 3c					inc a 
3ba1 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
3ba4			 
3ba4			 
3ba4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba4 cd 35 1f			call macro_forth_dsp_pop 
3ba7				endm 
# End of macro FORTH_DSP_POP
3ba7			  
3ba7			 
3ba7					NEXTW 
3ba7 c3 33 20			jp macro_next 
3baa				endm 
# End of macro NEXTW
3baa			.DOTH: 
3baa				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3baa 1c				db WORD_SYS_CORE+8             
3bab da 3b			dw .DOTF            
3bad 03				db 2 + 1 
3bae .. 00			db ".-",0              
3bb1				endm 
# End of macro CWHEAD
3bb1			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bb1					; get value off TOS and display it 
3bb1					if DEBUG_FORTH_WORDS_KEY 
3bb1						DMARK "DTD" 
3bb1 f5				push af  
3bb2 3a c6 3b			ld a, (.dmark)  
3bb5 32 71 ee			ld (debug_mark),a  
3bb8 3a c7 3b			ld a, (.dmark+1)  
3bbb 32 72 ee			ld (debug_mark+1),a  
3bbe 3a c8 3b			ld a, (.dmark+2)  
3bc1 32 73 ee			ld (debug_mark+2),a  
3bc4 18 03			jr .pastdmark  
3bc6 ..			.dmark: db "DTD"  
3bc9 f1			.pastdmark: pop af  
3bca			endm  
# End of macro DMARK
3bca						CALLMONITOR 
3bca cd e8 15			call break_point_state  
3bcd				endm  
# End of macro CALLMONITOR
3bcd					endif 
3bcd 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bcf 3e 00			ld a, 0 
3bd1 32 43 ea			ld (cli_mvdot), a 
3bd4 c3 31 3c			jp .dotgo 
3bd7				NEXTW 
3bd7 c3 33 20			jp macro_next 
3bda				endm 
# End of macro NEXTW
3bda			.DOTF: 
3bda				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bda 1c				db WORD_SYS_CORE+8             
3bdb 08 3c			dw .DOT            
3bdd 03				db 2 + 1 
3bde .. 00			db ".>",0              
3be1				endm 
# End of macro CWHEAD
3be1			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3be1					; get value off TOS and display it 
3be1			        ; TODO BUG adds extra spaces 
3be1			        ; TODO BUG handle numerics? 
3be1					if DEBUG_FORTH_WORDS_KEY 
3be1						DMARK "DTC" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 71 ee			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 72 ee			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 73 ee			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "DTC"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd e8 15			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd 3e 01			ld a, 1 
3bff 32 43 ea			ld (cli_mvdot), a 
3c02 c3 31 3c			jp .dotgo 
3c05				NEXTW 
3c05 c3 33 20			jp macro_next 
3c08				endm 
# End of macro NEXTW
3c08			 
3c08			.DOT: 
3c08				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c08 1c				db WORD_SYS_CORE+8             
3c09 e4 3d			dw .CLS            
3c0b 02				db 1 + 1 
3c0c .. 00			db ".",0              
3c0e				endm 
# End of macro CWHEAD
3c0e			        ; | . ( u -- ) Display TOS | DONE 
3c0e					; get value off TOS and display it 
3c0e			 
3c0e					if DEBUG_FORTH_WORDS_KEY 
3c0e						DMARK "DOT" 
3c0e f5				push af  
3c0f 3a 23 3c			ld a, (.dmark)  
3c12 32 71 ee			ld (debug_mark),a  
3c15 3a 24 3c			ld a, (.dmark+1)  
3c18 32 72 ee			ld (debug_mark+1),a  
3c1b 3a 25 3c			ld a, (.dmark+2)  
3c1e 32 73 ee			ld (debug_mark+2),a  
3c21 18 03			jr .pastdmark  
3c23 ..			.dmark: db "DOT"  
3c26 f1			.pastdmark: pop af  
3c27			endm  
# End of macro DMARK
3c27						CALLMONITOR 
3c27 cd e8 15			call break_point_state  
3c2a				endm  
# End of macro CALLMONITOR
3c2a					endif 
3c2a 3e 00			ld a, 0 
3c2c 32 43 ea			ld (cli_mvdot), a 
3c2f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c31				 
3c31			 
3c31			.dotgo: 
3c31			 
3c31			; move up type to on stack for parserv5 
3c31					FORTH_DSP 
3c31 cd 43 1e			call macro_forth_dsp 
3c34				endm 
# End of macro FORTH_DSP
3c34				;FORTH_DSP_VALUE  
3c34			 
3c34			if DEBUG_FORTH_DOT 
3c34				DMARK "DOT" 
3c34 f5				push af  
3c35 3a 49 3c			ld a, (.dmark)  
3c38 32 71 ee			ld (debug_mark),a  
3c3b 3a 4a 3c			ld a, (.dmark+1)  
3c3e 32 72 ee			ld (debug_mark+1),a  
3c41 3a 4b 3c			ld a, (.dmark+2)  
3c44 32 73 ee			ld (debug_mark+2),a  
3c47 18 03			jr .pastdmark  
3c49 ..			.dmark: db "DOT"  
3c4c f1			.pastdmark: pop af  
3c4d			endm  
# End of macro DMARK
3c4d				CALLMONITOR 
3c4d cd e8 15			call break_point_state  
3c50				endm  
# End of macro CALLMONITOR
3c50			endif	 
3c50			;		.print: 
3c50			 
3c50 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c51 23				inc hl   ; position to the actual value 
3c52 fe 01			cp DS_TYPE_STR 
3c54 20 06			jr nz, .dotnum1  
3c56			 
3c56			; display string 
3c56				FORTH_DSP_VALUE  
3c56 cd 66 1e			call macro_forth_dsp_value 
3c59				endm 
# End of macro FORTH_DSP_VALUE
3c59 eb				ex de,hl 
3c5a 18 49			jr .dotwrite 
3c5c			 
3c5c			.dotnum1: 
3c5c fe 02			cp DS_TYPE_INUM 
3c5e 20 44			jr nz, .dotflot 
3c60			 
3c60			 
3c60			; display number 
3c60			 
3c60			;	push hl 
3c60			;	call clear_display 
3c60			;	pop hl 
3c60			 
3c60 5e				ld e, (hl) 
3c61 23				inc hl 
3c62 56				ld d, (hl) 
3c63 21 c7 e2			ld hl, scratch 
3c66			if DEBUG_FORTH_DOT 
3c66				DMARK "DT1" 
3c66 f5				push af  
3c67 3a 7b 3c			ld a, (.dmark)  
3c6a 32 71 ee			ld (debug_mark),a  
3c6d 3a 7c 3c			ld a, (.dmark+1)  
3c70 32 72 ee			ld (debug_mark+1),a  
3c73 3a 7d 3c			ld a, (.dmark+2)  
3c76 32 73 ee			ld (debug_mark+2),a  
3c79 18 03			jr .pastdmark  
3c7b ..			.dmark: db "DT1"  
3c7e f1			.pastdmark: pop af  
3c7f			endm  
# End of macro DMARK
3c7f				CALLMONITOR 
3c7f cd e8 15			call break_point_state  
3c82				endm  
# End of macro CALLMONITOR
3c82			endif	 
3c82			 
3c82 cd f4 11			call uitoa_16 
3c85 eb				ex de,hl 
3c86			 
3c86			if DEBUG_FORTH_DOT 
3c86				DMARK "DT2" 
3c86 f5				push af  
3c87 3a 9b 3c			ld a, (.dmark)  
3c8a 32 71 ee			ld (debug_mark),a  
3c8d 3a 9c 3c			ld a, (.dmark+1)  
3c90 32 72 ee			ld (debug_mark+1),a  
3c93 3a 9d 3c			ld a, (.dmark+2)  
3c96 32 73 ee			ld (debug_mark+2),a  
3c99 18 03			jr .pastdmark  
3c9b ..			.dmark: db "DT2"  
3c9e f1			.pastdmark: pop af  
3c9f			endm  
# End of macro DMARK
3c9f				CALLMONITOR 
3c9f cd e8 15			call break_point_state  
3ca2				endm  
# End of macro CALLMONITOR
3ca2			endif	 
3ca2			 
3ca2			;	ld de, os_word_scratch 
3ca2 18 01			jr .dotwrite 
3ca4			 
3ca4 00			.dotflot:   nop 
3ca5			; TODO print floating point number 
3ca5			 
3ca5			.dotwrite:		 
3ca5			 
3ca5					; if c is set then set all '-' to spaces 
3ca5					; need to also take into account .>  
3ca5			 
3ca5 3e 01				ld a, 1 
3ca7 b9					cp c 
3ca8 20 67				jr nz, .nodashswap 
3caa			 
3caa					; DE has the string to write, working with HL 
3caa			 
3caa 06 ff				ld b, 255 
3cac d5					push de 
3cad e1					pop hl 
3cae			 
3cae			if DEBUG_FORTH_DOT 
3cae				DMARK "DT-" 
3cae f5				push af  
3caf 3a c3 3c			ld a, (.dmark)  
3cb2 32 71 ee			ld (debug_mark),a  
3cb5 3a c4 3c			ld a, (.dmark+1)  
3cb8 32 72 ee			ld (debug_mark+1),a  
3cbb 3a c5 3c			ld a, (.dmark+2)  
3cbe 32 73 ee			ld (debug_mark+2),a  
3cc1 18 03			jr .pastdmark  
3cc3 ..			.dmark: db "DT-"  
3cc6 f1			.pastdmark: pop af  
3cc7			endm  
# End of macro DMARK
3cc7				CALLMONITOR 
3cc7 cd e8 15			call break_point_state  
3cca				endm  
# End of macro CALLMONITOR
3cca			endif	 
3cca 7e			.dashscan:	ld a, (hl) 
3ccb fe 00				cp 0 
3ccd 28 42				jr z, .nodashswap 
3ccf fe 2d				cp '-' 
3cd1 20 03				jr nz, .dashskip 
3cd3 3e 20				ld a, ' ' 
3cd5 77					ld (hl), a 
3cd6 23			.dashskip:	inc hl 
3cd7			if DEBUG_FORTH_DOT 
3cd7				DMARK "D-2" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 71 ee			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 72 ee			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 73 ee			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "D-2"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0				CALLMONITOR 
3cf0 cd e8 15			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3			endif	 
3cf3 10 d5				djnz .dashscan 
3cf5			 
3cf5			if DEBUG_FORTH_DOT 
3cf5				DMARK "D-1" 
3cf5 f5				push af  
3cf6 3a 0a 3d			ld a, (.dmark)  
3cf9 32 71 ee			ld (debug_mark),a  
3cfc 3a 0b 3d			ld a, (.dmark+1)  
3cff 32 72 ee			ld (debug_mark+1),a  
3d02 3a 0c 3d			ld a, (.dmark+2)  
3d05 32 73 ee			ld (debug_mark+2),a  
3d08 18 03			jr .pastdmark  
3d0a ..			.dmark: db "D-1"  
3d0d f1			.pastdmark: pop af  
3d0e			endm  
# End of macro DMARK
3d0e				CALLMONITOR 
3d0e cd e8 15			call break_point_state  
3d11				endm  
# End of macro CALLMONITOR
3d11			endif	 
3d11			 
3d11			.nodashswap: 
3d11			 
3d11			if DEBUG_FORTH_DOT 
3d11				DMARK "D-o" 
3d11 f5				push af  
3d12 3a 26 3d			ld a, (.dmark)  
3d15 32 71 ee			ld (debug_mark),a  
3d18 3a 27 3d			ld a, (.dmark+1)  
3d1b 32 72 ee			ld (debug_mark+1),a  
3d1e 3a 28 3d			ld a, (.dmark+2)  
3d21 32 73 ee			ld (debug_mark+2),a  
3d24 18 03			jr .pastdmark  
3d26 ..			.dmark: db "D-o"  
3d29 f1			.pastdmark: pop af  
3d2a			endm  
# End of macro DMARK
3d2a				CALLMONITOR 
3d2a cd e8 15			call break_point_state  
3d2d				endm  
# End of macro CALLMONITOR
3d2d			endif	 
3d2d			 
3d2d d5					push de   ; save string start in case we need to advance print 
3d2e			 
3d2e 3a 64 ea				ld a, (f_cursor_ptr) 
3d31 cd cd 0b				call str_at_display 
3d34 3a 42 ea				ld a,(cli_autodisplay) 
3d37 fe 00				cp 0 
3d39 28 03				jr z, .noupdate 
3d3b cd dd 0b						call update_display 
3d3e					.noupdate: 
3d3e			 
3d3e			 
3d3e					; see if we need to advance the print position 
3d3e			 
3d3e e1					pop hl   ; get back string 
3d3f			;		ex de,hl 
3d3f			 
3d3f 3a 43 ea				ld a, (cli_mvdot) 
3d42			if DEBUG_FORTH_DOT 
3d42			;		ld e,a 
3d42				DMARK "D>1" 
3d42 f5				push af  
3d43 3a 57 3d			ld a, (.dmark)  
3d46 32 71 ee			ld (debug_mark),a  
3d49 3a 58 3d			ld a, (.dmark+1)  
3d4c 32 72 ee			ld (debug_mark+1),a  
3d4f 3a 59 3d			ld a, (.dmark+2)  
3d52 32 73 ee			ld (debug_mark+2),a  
3d55 18 03			jr .pastdmark  
3d57 ..			.dmark: db "D>1"  
3d5a f1			.pastdmark: pop af  
3d5b			endm  
# End of macro DMARK
3d5b				CALLMONITOR 
3d5b cd e8 15			call break_point_state  
3d5e				endm  
# End of macro CALLMONITOR
3d5e			endif	 
3d5e fe 00				cp 0 
3d60 28 44				jr z, .noadv 
3d62					; yes, lets advance the print position 
3d62 3e 00				ld a, 0 
3d64 cd 50 12				call strlent 
3d67			if DEBUG_FORTH_DOT 
3d67				DMARK "D-?" 
3d67 f5				push af  
3d68 3a 7c 3d			ld a, (.dmark)  
3d6b 32 71 ee			ld (debug_mark),a  
3d6e 3a 7d 3d			ld a, (.dmark+1)  
3d71 32 72 ee			ld (debug_mark+1),a  
3d74 3a 7e 3d			ld a, (.dmark+2)  
3d77 32 73 ee			ld (debug_mark+2),a  
3d7a 18 03			jr .pastdmark  
3d7c ..			.dmark: db "D-?"  
3d7f f1			.pastdmark: pop af  
3d80			endm  
# End of macro DMARK
3d80				CALLMONITOR 
3d80 cd e8 15			call break_point_state  
3d83				endm  
# End of macro CALLMONITOR
3d83			endif	 
3d83 3a 64 ea				ld a, (f_cursor_ptr) 
3d86 85					add a,l 
3d87					;call addatohl 
3d87					;ld a, l 
3d87 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
3d8a			 
3d8a			if DEBUG_FORTH_DOT 
3d8a				DMARK "D->" 
3d8a f5				push af  
3d8b 3a 9f 3d			ld a, (.dmark)  
3d8e 32 71 ee			ld (debug_mark),a  
3d91 3a a0 3d			ld a, (.dmark+1)  
3d94 32 72 ee			ld (debug_mark+1),a  
3d97 3a a1 3d			ld a, (.dmark+2)  
3d9a 32 73 ee			ld (debug_mark+2),a  
3d9d 18 03			jr .pastdmark  
3d9f ..			.dmark: db "D->"  
3da2 f1			.pastdmark: pop af  
3da3			endm  
# End of macro DMARK
3da3				CALLMONITOR 
3da3 cd e8 15			call break_point_state  
3da6				endm  
# End of macro CALLMONITOR
3da6			endif	 
3da6			 
3da6			.noadv:	 
3da6			 
3da6					if DEBUG_FORTH_DOT_WAIT 
3da6							call next_page_prompt 
3da6					endif	 
3da6			; TODO this pop off the stack causes a crash. i dont know why 
3da6			 
3da6			 
3da6			if DEBUG_FORTH_DOT 
3da6				DMARK "DTh" 
3da6 f5				push af  
3da7 3a bb 3d			ld a, (.dmark)  
3daa 32 71 ee			ld (debug_mark),a  
3dad 3a bc 3d			ld a, (.dmark+1)  
3db0 32 72 ee			ld (debug_mark+1),a  
3db3 3a bd 3d			ld a, (.dmark+2)  
3db6 32 73 ee			ld (debug_mark+2),a  
3db9 18 03			jr .pastdmark  
3dbb ..			.dmark: db "DTh"  
3dbe f1			.pastdmark: pop af  
3dbf			endm  
# End of macro DMARK
3dbf				CALLMONITOR 
3dbf cd e8 15			call break_point_state  
3dc2				endm  
# End of macro CALLMONITOR
3dc2			endif	 
3dc2			 
3dc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc2 cd 35 1f			call macro_forth_dsp_pop 
3dc5				endm 
# End of macro FORTH_DSP_POP
3dc5			 
3dc5			if DEBUG_FORTH_DOT 
3dc5				DMARK "DTi" 
3dc5 f5				push af  
3dc6 3a da 3d			ld a, (.dmark)  
3dc9 32 71 ee			ld (debug_mark),a  
3dcc 3a db 3d			ld a, (.dmark+1)  
3dcf 32 72 ee			ld (debug_mark+1),a  
3dd2 3a dc 3d			ld a, (.dmark+2)  
3dd5 32 73 ee			ld (debug_mark+2),a  
3dd8 18 03			jr .pastdmark  
3dda ..			.dmark: db "DTi"  
3ddd f1			.pastdmark: pop af  
3dde			endm  
# End of macro DMARK
3dde				CALLMONITOR 
3dde cd e8 15			call break_point_state  
3de1				endm  
# End of macro CALLMONITOR
3de1			endif	 
3de1			 
3de1			 
3de1					NEXTW 
3de1 c3 33 20			jp macro_next 
3de4				endm 
# End of macro NEXTW
3de4			 
3de4			.CLS: 
3de4				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3de4 35				db WORD_SYS_CORE+33             
3de5 11 3e			dw .DRAW            
3de7 04				db 3 + 1 
3de8 .. 00			db "CLS",0              
3dec				endm 
# End of macro CWHEAD
3dec			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3dec					if DEBUG_FORTH_WORDS_KEY 
3dec						DMARK "CLS" 
3dec f5				push af  
3ded 3a 01 3e			ld a, (.dmark)  
3df0 32 71 ee			ld (debug_mark),a  
3df3 3a 02 3e			ld a, (.dmark+1)  
3df6 32 72 ee			ld (debug_mark+1),a  
3df9 3a 03 3e			ld a, (.dmark+2)  
3dfc 32 73 ee			ld (debug_mark+2),a  
3dff 18 03			jr .pastdmark  
3e01 ..			.dmark: db "CLS"  
3e04 f1			.pastdmark: pop af  
3e05			endm  
# End of macro DMARK
3e05						CALLMONITOR 
3e05 cd e8 15			call break_point_state  
3e08				endm  
# End of macro CALLMONITOR
3e08					endif 
3e08 cd ba 0b				call clear_display 
3e0b c3 1f 3f				jp .home		; and home cursor 
3e0e					NEXTW 
3e0e c3 33 20			jp macro_next 
3e11				endm 
# End of macro NEXTW
3e11			 
3e11			.DRAW: 
3e11				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e11 36				db WORD_SYS_CORE+34             
3e12 3c 3e			dw .DUMP            
3e14 05				db 4 + 1 
3e15 .. 00			db "DRAW",0              
3e1a				endm 
# End of macro CWHEAD
3e1a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e1a					if DEBUG_FORTH_WORDS_KEY 
3e1a						DMARK "DRW" 
3e1a f5				push af  
3e1b 3a 2f 3e			ld a, (.dmark)  
3e1e 32 71 ee			ld (debug_mark),a  
3e21 3a 30 3e			ld a, (.dmark+1)  
3e24 32 72 ee			ld (debug_mark+1),a  
3e27 3a 31 3e			ld a, (.dmark+2)  
3e2a 32 73 ee			ld (debug_mark+2),a  
3e2d 18 03			jr .pastdmark  
3e2f ..			.dmark: db "DRW"  
3e32 f1			.pastdmark: pop af  
3e33			endm  
# End of macro DMARK
3e33						CALLMONITOR 
3e33 cd e8 15			call break_point_state  
3e36				endm  
# End of macro CALLMONITOR
3e36					endif 
3e36 cd dd 0b				call update_display 
3e39					NEXTW 
3e39 c3 33 20			jp macro_next 
3e3c				endm 
# End of macro NEXTW
3e3c			 
3e3c			.DUMP: 
3e3c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e3c 37				db WORD_SYS_CORE+35             
3e3d 74 3e			dw .CDUMP            
3e3f 05				db 4 + 1 
3e40 .. 00			db "DUMP",0              
3e45				endm 
# End of macro CWHEAD
3e45			; | DUMP ( x -- ) With address x display dump   | DONE 
3e45			; TODO pop address to use off of the stack 
3e45					if DEBUG_FORTH_WORDS_KEY 
3e45						DMARK "DUM" 
3e45 f5				push af  
3e46 3a 5a 3e			ld a, (.dmark)  
3e49 32 71 ee			ld (debug_mark),a  
3e4c 3a 5b 3e			ld a, (.dmark+1)  
3e4f 32 72 ee			ld (debug_mark+1),a  
3e52 3a 5c 3e			ld a, (.dmark+2)  
3e55 32 73 ee			ld (debug_mark+2),a  
3e58 18 03			jr .pastdmark  
3e5a ..			.dmark: db "DUM"  
3e5d f1			.pastdmark: pop af  
3e5e			endm  
# End of macro DMARK
3e5e						CALLMONITOR 
3e5e cd e8 15			call break_point_state  
3e61				endm  
# End of macro CALLMONITOR
3e61					endif 
3e61 cd ba 0b				call clear_display 
3e64			 
3e64					; get address 
3e64			 
3e64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e64 cd 7d 1e			call macro_dsp_valuehl 
3e67				endm 
# End of macro FORTH_DSP_VALUEHL
3e67				 
3e67					; save it for cdump 
3e67			 
3e67 22 ea e5				ld (os_cur_ptr),hl 
3e6a			 
3e6a					; destroy value TOS 
3e6a			 
3e6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e6a cd 35 1f			call macro_forth_dsp_pop 
3e6d				endm 
# End of macro FORTH_DSP_POP
3e6d			 
3e6d cd 06 1b				call dumpcont	; skip old style of param parsing	 
3e70 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e71					NEXTW 
3e71 c3 33 20			jp macro_next 
3e74				endm 
# End of macro NEXTW
3e74			.CDUMP: 
3e74				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e74 38				db WORD_SYS_CORE+36             
3e75 a4 3e			dw .DAT            
3e77 06				db 5 + 1 
3e78 .. 00			db "CDUMP",0              
3e7e				endm 
# End of macro CWHEAD
3e7e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e7e					if DEBUG_FORTH_WORDS_KEY 
3e7e						DMARK "CDP" 
3e7e f5				push af  
3e7f 3a 93 3e			ld a, (.dmark)  
3e82 32 71 ee			ld (debug_mark),a  
3e85 3a 94 3e			ld a, (.dmark+1)  
3e88 32 72 ee			ld (debug_mark+1),a  
3e8b 3a 95 3e			ld a, (.dmark+2)  
3e8e 32 73 ee			ld (debug_mark+2),a  
3e91 18 03			jr .pastdmark  
3e93 ..			.dmark: db "CDP"  
3e96 f1			.pastdmark: pop af  
3e97			endm  
# End of macro DMARK
3e97						CALLMONITOR 
3e97 cd e8 15			call break_point_state  
3e9a				endm  
# End of macro CALLMONITOR
3e9a					endif 
3e9a cd ba 0b				call clear_display 
3e9d cd 06 1b				call dumpcont	 
3ea0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ea1					NEXTW 
3ea1 c3 33 20			jp macro_next 
3ea4				endm 
# End of macro NEXTW
3ea4			 
3ea4			 
3ea4			 
3ea4			 
3ea4			.DAT: 
3ea4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ea4 3d				db WORD_SYS_CORE+41             
3ea5 fa 3e			dw .HOME            
3ea7 03				db 2 + 1 
3ea8 .. 00			db "AT",0              
3eab				endm 
# End of macro CWHEAD
3eab			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3eab					if DEBUG_FORTH_WORDS_KEY 
3eab						DMARK "AT." 
3eab f5				push af  
3eac 3a c0 3e			ld a, (.dmark)  
3eaf 32 71 ee			ld (debug_mark),a  
3eb2 3a c1 3e			ld a, (.dmark+1)  
3eb5 32 72 ee			ld (debug_mark+1),a  
3eb8 3a c2 3e			ld a, (.dmark+2)  
3ebb 32 73 ee			ld (debug_mark+2),a  
3ebe 18 03			jr .pastdmark  
3ec0 ..			.dmark: db "AT."  
3ec3 f1			.pastdmark: pop af  
3ec4			endm  
# End of macro DMARK
3ec4						CALLMONITOR 
3ec4 cd e8 15			call break_point_state  
3ec7				endm  
# End of macro CALLMONITOR
3ec7					endif 
3ec7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec7 cd 7d 1e			call macro_dsp_valuehl 
3eca				endm 
# End of macro FORTH_DSP_VALUEHL
3eca			 
3eca			 
3eca					; TODO save cursor row 
3eca 7d					ld a,l 
3ecb fe 02				cp 2 
3ecd 20 04				jr nz, .crow3 
3ecf 3e 28				ld a, display_row_2 
3ed1 18 12				jr .ccol1 
3ed3 fe 03		.crow3:		cp 3 
3ed5 20 04				jr nz, .crow4 
3ed7 3e 50				ld a, display_row_3 
3ed9 18 0a				jr .ccol1 
3edb fe 04		.crow4:		cp 4 
3edd 20 04				jr nz, .crow1 
3edf 3e 78				ld a, display_row_4 
3ee1 18 02				jr .ccol1 
3ee3 3e 00		.crow1:		ld a,display_row_1 
3ee5 f5			.ccol1:		push af			; got row offset 
3ee6 6f					ld l,a 
3ee7 26 00				ld h,0 
3ee9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee9 cd 35 1f			call macro_forth_dsp_pop 
3eec				endm 
# End of macro FORTH_DSP_POP
3eec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eec cd 7d 1e			call macro_dsp_valuehl 
3eef				endm 
# End of macro FORTH_DSP_VALUEHL
3eef					; TODO save cursor col 
3eef f1					pop af 
3ef0 85					add l		; add col offset 
3ef1 32 64 ea				ld (f_cursor_ptr), a 
3ef4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef4 cd 35 1f			call macro_forth_dsp_pop 
3ef7				endm 
# End of macro FORTH_DSP_POP
3ef7			 
3ef7					; calculate  
3ef7			 
3ef7					NEXTW 
3ef7 c3 33 20			jp macro_next 
3efa				endm 
# End of macro NEXTW
3efa			 
3efa			 
3efa			.HOME: 
3efa				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3efa 41				db WORD_SYS_CORE+45             
3efb 27 3f			dw .SPACE            
3efd 05				db 4 + 1 
3efe .. 00			db "HOME",0              
3f03				endm 
# End of macro CWHEAD
3f03			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f03					if DEBUG_FORTH_WORDS_KEY 
3f03						DMARK "HOM" 
3f03 f5				push af  
3f04 3a 18 3f			ld a, (.dmark)  
3f07 32 71 ee			ld (debug_mark),a  
3f0a 3a 19 3f			ld a, (.dmark+1)  
3f0d 32 72 ee			ld (debug_mark+1),a  
3f10 3a 1a 3f			ld a, (.dmark+2)  
3f13 32 73 ee			ld (debug_mark+2),a  
3f16 18 03			jr .pastdmark  
3f18 ..			.dmark: db "HOM"  
3f1b f1			.pastdmark: pop af  
3f1c			endm  
# End of macro DMARK
3f1c						CALLMONITOR 
3f1c cd e8 15			call break_point_state  
3f1f				endm  
# End of macro CALLMONITOR
3f1f					endif 
3f1f 3e 00		.home:		ld a, 0		; and home cursor 
3f21 32 64 ea				ld (f_cursor_ptr), a 
3f24					NEXTW 
3f24 c3 33 20			jp macro_next 
3f27				endm 
# End of macro NEXTW
3f27			 
3f27			 
3f27			.SPACE: 
3f27				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f27 46				db WORD_SYS_CORE+50             
3f28 5d 3f			dw .SPACES            
3f2a 03				db 2 + 1 
3f2b .. 00			db "BL",0              
3f2e				endm 
# End of macro CWHEAD
3f2e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f2e					if DEBUG_FORTH_WORDS_KEY 
3f2e						DMARK "BL." 
3f2e f5				push af  
3f2f 3a 43 3f			ld a, (.dmark)  
3f32 32 71 ee			ld (debug_mark),a  
3f35 3a 44 3f			ld a, (.dmark+1)  
3f38 32 72 ee			ld (debug_mark+1),a  
3f3b 3a 45 3f			ld a, (.dmark+2)  
3f3e 32 73 ee			ld (debug_mark+2),a  
3f41 18 03			jr .pastdmark  
3f43 ..			.dmark: db "BL."  
3f46 f1			.pastdmark: pop af  
3f47			endm  
# End of macro DMARK
3f47						CALLMONITOR 
3f47 cd e8 15			call break_point_state  
3f4a				endm  
# End of macro CALLMONITOR
3f4a					endif 
3f4a 3e 20				ld a, " " 
3f4c 32 c7 e2				ld (scratch),a 
3f4f 3e 00				ld a, 0 
3f51 32 c8 e2				ld (scratch+1),a 
3f54 21 c7 e2				ld hl, scratch 
3f57 cd f4 1c				call forth_push_str 
3f5a					 
3f5a				       NEXTW 
3f5a c3 33 20			jp macro_next 
3f5d				endm 
# End of macro NEXTW
3f5d			 
3f5d			;.blstr: db " ", 0 
3f5d			 
3f5d			.SPACES: 
3f5d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f5d 47				db WORD_SYS_CORE+51             
3f5e f8 3f			dw .SCROLL            
3f60 07				db 6 + 1 
3f61 .. 00			db "SPACES",0              
3f68				endm 
# End of macro CWHEAD
3f68			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f68					if DEBUG_FORTH_WORDS_KEY 
3f68						DMARK "SPS" 
3f68 f5				push af  
3f69 3a 7d 3f			ld a, (.dmark)  
3f6c 32 71 ee			ld (debug_mark),a  
3f6f 3a 7e 3f			ld a, (.dmark+1)  
3f72 32 72 ee			ld (debug_mark+1),a  
3f75 3a 7f 3f			ld a, (.dmark+2)  
3f78 32 73 ee			ld (debug_mark+2),a  
3f7b 18 03			jr .pastdmark  
3f7d ..			.dmark: db "SPS"  
3f80 f1			.pastdmark: pop af  
3f81			endm  
# End of macro DMARK
3f81						CALLMONITOR 
3f81 cd e8 15			call break_point_state  
3f84				endm  
# End of macro CALLMONITOR
3f84					endif 
3f84			 
3f84			 
3f84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f84 cd 7d 1e			call macro_dsp_valuehl 
3f87				endm 
# End of macro FORTH_DSP_VALUEHL
3f87			 
3f87 e5					push hl    ; u 
3f88					if DEBUG_FORTH_WORDS 
3f88						DMARK "SPA" 
3f88 f5				push af  
3f89 3a 9d 3f			ld a, (.dmark)  
3f8c 32 71 ee			ld (debug_mark),a  
3f8f 3a 9e 3f			ld a, (.dmark+1)  
3f92 32 72 ee			ld (debug_mark+1),a  
3f95 3a 9f 3f			ld a, (.dmark+2)  
3f98 32 73 ee			ld (debug_mark+2),a  
3f9b 18 03			jr .pastdmark  
3f9d ..			.dmark: db "SPA"  
3fa0 f1			.pastdmark: pop af  
3fa1			endm  
# End of macro DMARK
3fa1						CALLMONITOR 
3fa1 cd e8 15			call break_point_state  
3fa4				endm  
# End of macro CALLMONITOR
3fa4					endif 
3fa4			 
3fa4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa4 cd 35 1f			call macro_forth_dsp_pop 
3fa7				endm 
# End of macro FORTH_DSP_POP
3fa7 e1					pop hl 
3fa8 0e 00				ld c, 0 
3faa 45					ld b, l 
3fab 21 c7 e2				ld hl, scratch  
3fae			 
3fae					if DEBUG_FORTH_WORDS 
3fae						DMARK "SP2" 
3fae f5				push af  
3faf 3a c3 3f			ld a, (.dmark)  
3fb2 32 71 ee			ld (debug_mark),a  
3fb5 3a c4 3f			ld a, (.dmark+1)  
3fb8 32 72 ee			ld (debug_mark+1),a  
3fbb 3a c5 3f			ld a, (.dmark+2)  
3fbe 32 73 ee			ld (debug_mark+2),a  
3fc1 18 03			jr .pastdmark  
3fc3 ..			.dmark: db "SP2"  
3fc6 f1			.pastdmark: pop af  
3fc7			endm  
# End of macro DMARK
3fc7						CALLMONITOR 
3fc7 cd e8 15			call break_point_state  
3fca				endm  
# End of macro CALLMONITOR
3fca					endif 
3fca 3e 20				ld a, ' ' 
3fcc			.spaces1:	 
3fcc 77					ld (hl),a 
3fcd 23					inc hl 
3fce					 
3fce 10 fc				djnz .spaces1 
3fd0 3e 00				ld a,0 
3fd2 77					ld (hl),a 
3fd3 21 c7 e2				ld hl, scratch 
3fd6					if DEBUG_FORTH_WORDS 
3fd6						DMARK "SP3" 
3fd6 f5				push af  
3fd7 3a eb 3f			ld a, (.dmark)  
3fda 32 71 ee			ld (debug_mark),a  
3fdd 3a ec 3f			ld a, (.dmark+1)  
3fe0 32 72 ee			ld (debug_mark+1),a  
3fe3 3a ed 3f			ld a, (.dmark+2)  
3fe6 32 73 ee			ld (debug_mark+2),a  
3fe9 18 03			jr .pastdmark  
3feb ..			.dmark: db "SP3"  
3fee f1			.pastdmark: pop af  
3fef			endm  
# End of macro DMARK
3fef						CALLMONITOR 
3fef cd e8 15			call break_point_state  
3ff2				endm  
# End of macro CALLMONITOR
3ff2					endif 
3ff2 cd f4 1c				call forth_push_str 
3ff5			 
3ff5				       NEXTW 
3ff5 c3 33 20			jp macro_next 
3ff8				endm 
# End of macro NEXTW
3ff8			 
3ff8			 
3ff8			 
3ff8			.SCROLL: 
3ff8				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3ff8 53				db WORD_SYS_CORE+63             
3ff9 25 40			dw .SCROLLD            
3ffb 07				db 6 + 1 
3ffc .. 00			db "SCROLL",0              
4003				endm 
# End of macro CWHEAD
4003			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4003					if DEBUG_FORTH_WORDS_KEY 
4003						DMARK "SCR" 
4003 f5				push af  
4004 3a 18 40			ld a, (.dmark)  
4007 32 71 ee			ld (debug_mark),a  
400a 3a 19 40			ld a, (.dmark+1)  
400d 32 72 ee			ld (debug_mark+1),a  
4010 3a 1a 40			ld a, (.dmark+2)  
4013 32 73 ee			ld (debug_mark+2),a  
4016 18 03			jr .pastdmark  
4018 ..			.dmark: db "SCR"  
401b f1			.pastdmark: pop af  
401c			endm  
# End of macro DMARK
401c						CALLMONITOR 
401c cd e8 15			call break_point_state  
401f				endm  
# End of macro CALLMONITOR
401f					endif 
401f			 
401f cd 7c 0b			call scroll_up 
4022			;	call update_display 
4022			 
4022					NEXTW 
4022 c3 33 20			jp macro_next 
4025				endm 
# End of macro NEXTW
4025			 
4025			 
4025			 
4025			;		; get dir 
4025			; 
4025			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4025			; 
4025			;		push hl 
4025			; 
4025			;		; destroy value TOS 
4025			; 
4025			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4025			; 
4025			;		; get count 
4025			; 
4025			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4025			; 
4025			;		push hl 
4025			; 
4025			;		; destroy value TOS 
4025			; 
4025			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4025			; 
4025			;		; one value on hl get other one back 
4025			; 
4025			;		pop bc    ; count 
4025			; 
4025			;		pop de   ; dir 
4025			; 
4025			; 
4025			;		ld b, c 
4025			; 
4025			;.scrolldir:     push bc 
4025			;		push de 
4025			; 
4025			;		ld a, 0 
4025			;		cp e 
4025			;		jr z, .scrollup  
4025			;		call scroll_down 
4025			;		jr .scrollnext 
4025			;.scrollup:	call scroll_up 
4025			; 
4025			;		 
4025			;.scrollnext: 
4025			;		pop de 
4025			;		pop bc 
4025			;		djnz .scrolldir 
4025			; 
4025			; 
4025			; 
4025			; 
4025			; 
4025			;		NEXTW 
4025			 
4025			.SCROLLD: 
4025				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4025 53				db WORD_SYS_CORE+63             
4026 53 40			dw .ATQ            
4028 08				db 7 + 1 
4029 .. 00			db "SCROLLD",0              
4031				endm 
# End of macro CWHEAD
4031			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4031					if DEBUG_FORTH_WORDS_KEY 
4031						DMARK "SCD" 
4031 f5				push af  
4032 3a 46 40			ld a, (.dmark)  
4035 32 71 ee			ld (debug_mark),a  
4038 3a 47 40			ld a, (.dmark+1)  
403b 32 72 ee			ld (debug_mark+1),a  
403e 3a 48 40			ld a, (.dmark+2)  
4041 32 73 ee			ld (debug_mark+2),a  
4044 18 03			jr .pastdmark  
4046 ..			.dmark: db "SCD"  
4049 f1			.pastdmark: pop af  
404a			endm  
# End of macro DMARK
404a						CALLMONITOR 
404a cd e8 15			call break_point_state  
404d				endm  
# End of macro CALLMONITOR
404d					endif 
404d			 
404d cd a0 0b			call scroll_down 
4050			;	call update_display 
4050			 
4050					NEXTW 
4050 c3 33 20			jp macro_next 
4053				endm 
# End of macro NEXTW
4053			 
4053			 
4053			.ATQ: 
4053				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4053 62				db WORD_SYS_CORE+78             
4054 b1 40			dw .AUTODSP            
4056 04				db 3 + 1 
4057 .. 00			db "AT@",0              
405b				endm 
# End of macro CWHEAD
405b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
405b					if DEBUG_FORTH_WORDS_KEY 
405b						DMARK "ATA" 
405b f5				push af  
405c 3a 70 40			ld a, (.dmark)  
405f 32 71 ee			ld (debug_mark),a  
4062 3a 71 40			ld a, (.dmark+1)  
4065 32 72 ee			ld (debug_mark+1),a  
4068 3a 72 40			ld a, (.dmark+2)  
406b 32 73 ee			ld (debug_mark+2),a  
406e 18 03			jr .pastdmark  
4070 ..			.dmark: db "ATA"  
4073 f1			.pastdmark: pop af  
4074			endm  
# End of macro DMARK
4074						CALLMONITOR 
4074 cd e8 15			call break_point_state  
4077				endm  
# End of macro CALLMONITOR
4077					endif 
4077			 
4077			 
4077					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4077 cd 7d 1e			call macro_dsp_valuehl 
407a				endm 
# End of macro FORTH_DSP_VALUEHL
407a			 
407a					; TODO save cursor row 
407a 7d					ld a,l 
407b fe 02				cp 2 
407d 20 04				jr nz, .crow3aq 
407f 3e 28				ld a, display_row_2 
4081 18 12				jr .ccol1aq 
4083 fe 03		.crow3aq:		cp 3 
4085 20 04				jr nz, .crow4aq 
4087 3e 50				ld a, display_row_3 
4089 18 0a				jr .ccol1aq 
408b fe 04		.crow4aq:		cp 4 
408d 20 04				jr nz, .crow1aq 
408f 3e 78				ld a, display_row_4 
4091 18 02				jr .ccol1aq 
4093 3e 00		.crow1aq:		ld a,display_row_1 
4095 f5			.ccol1aq:		push af			; got row offset 
4096 6f					ld l,a 
4097 26 00				ld h,0 
4099					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4099 cd 35 1f			call macro_forth_dsp_pop 
409c				endm 
# End of macro FORTH_DSP_POP
409c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
409c cd 7d 1e			call macro_dsp_valuehl 
409f				endm 
# End of macro FORTH_DSP_VALUEHL
409f					; TODO save cursor col 
409f f1					pop af 
40a0 85					add l		; add col offset 
40a1			 
40a1					; add current frame buffer address 
40a1 2a d2 eb				ld hl, (display_fb_active) 
40a4 cd e7 0d				call addatohl 
40a7			 
40a7			 
40a7			 
40a7			 
40a7					; get char frame buffer location offset in hl 
40a7			 
40a7 7e					ld a,(hl) 
40a8 26 00				ld h, 0 
40aa 6f					ld l, a 
40ab			 
40ab cd 86 1c				call forth_push_numhl 
40ae			 
40ae			 
40ae					NEXTW 
40ae c3 33 20			jp macro_next 
40b1				endm 
# End of macro NEXTW
40b1			 
40b1			.AUTODSP: 
40b1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40b1 63				db WORD_SYS_CORE+79             
40b2 c7 40			dw .MENU            
40b4 05				db 4 + 1 
40b5 .. 00			db "ADSP",0              
40ba				endm 
# End of macro CWHEAD
40ba			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40ba			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40ba			 
40ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ba cd 7d 1e			call macro_dsp_valuehl 
40bd				endm 
# End of macro FORTH_DSP_VALUEHL
40bd			 
40bd			;		push hl 
40bd			 
40bd					; destroy value TOS 
40bd			 
40bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bd cd 35 1f			call macro_forth_dsp_pop 
40c0				endm 
# End of macro FORTH_DSP_POP
40c0			 
40c0			;		pop hl 
40c0			 
40c0 7d					ld a,l 
40c1 32 42 ea				ld (cli_autodisplay), a 
40c4				       NEXTW 
40c4 c3 33 20			jp macro_next 
40c7				endm 
# End of macro NEXTW
40c7			 
40c7			.MENU: 
40c7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40c7 70				db WORD_SYS_CORE+92             
40c8 70 41			dw .ENDDISPLAY            
40ca 05				db 4 + 1 
40cb .. 00			db "MENU",0              
40d0				endm 
# End of macro CWHEAD
40d0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40d0			 
40d0			;		; get number of items on the stack 
40d0			; 
40d0				 
40d0					FORTH_DSP_VALUEHL 
40d0 cd 7d 1e			call macro_dsp_valuehl 
40d3				endm 
# End of macro FORTH_DSP_VALUEHL
40d3				 
40d3					if DEBUG_FORTH_WORDS_KEY 
40d3						DMARK "MNU" 
40d3 f5				push af  
40d4 3a e8 40			ld a, (.dmark)  
40d7 32 71 ee			ld (debug_mark),a  
40da 3a e9 40			ld a, (.dmark+1)  
40dd 32 72 ee			ld (debug_mark+1),a  
40e0 3a ea 40			ld a, (.dmark+2)  
40e3 32 73 ee			ld (debug_mark+2),a  
40e6 18 03			jr .pastdmark  
40e8 ..			.dmark: db "MNU"  
40eb f1			.pastdmark: pop af  
40ec			endm  
# End of macro DMARK
40ec						CALLMONITOR 
40ec cd e8 15			call break_point_state  
40ef				endm  
# End of macro CALLMONITOR
40ef					endif 
40ef			 
40ef 45					ld b, l	 
40f0 05					dec b 
40f1			 
40f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f1 cd 35 1f			call macro_forth_dsp_pop 
40f4				endm 
# End of macro FORTH_DSP_POP
40f4			 
40f4			 
40f4					; go directly through the stack to pluck out the string pointers and build an array 
40f4			 
40f4			;		FORTH_DSP 
40f4			 
40f4					; hl contains top most stack item 
40f4				 
40f4 11 c7 e2				ld de, scratch 
40f7			 
40f7			.mbuild: 
40f7			 
40f7					FORTH_DSP_VALUEHL 
40f7 cd 7d 1e			call macro_dsp_valuehl 
40fa				endm 
# End of macro FORTH_DSP_VALUEHL
40fa			 
40fa					if DEBUG_FORTH_WORDS 
40fa						DMARK "MN3" 
40fa f5				push af  
40fb 3a 0f 41			ld a, (.dmark)  
40fe 32 71 ee			ld (debug_mark),a  
4101 3a 10 41			ld a, (.dmark+1)  
4104 32 72 ee			ld (debug_mark+1),a  
4107 3a 11 41			ld a, (.dmark+2)  
410a 32 73 ee			ld (debug_mark+2),a  
410d 18 03			jr .pastdmark  
410f ..			.dmark: db "MN3"  
4112 f1			.pastdmark: pop af  
4113			endm  
# End of macro DMARK
4113						CALLMONITOR 
4113 cd e8 15			call break_point_state  
4116				endm  
# End of macro CALLMONITOR
4116					endif 
4116 eb					ex de, hl 
4117 73					ld (hl), e 
4118 23					inc hl 
4119 72					ld (hl), d 
411a 23					inc hl 
411b eb					ex de, hl 
411c			 
411c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
411c cd 35 1f			call macro_forth_dsp_pop 
411f				endm 
# End of macro FORTH_DSP_POP
411f			 
411f 10 d6				djnz .mbuild 
4121			 
4121					; done add term 
4121			 
4121 eb					ex de, hl 
4122 36 00				ld (hl), 0 
4124 23					inc hl 
4125 36 00				ld (hl), 0 
4127			 
4127				 
4127					 
4127 21 c7 e2				ld hl, scratch 
412a			 
412a					if DEBUG_FORTH_WORDS 
412a						DMARK "MNx" 
412a f5				push af  
412b 3a 3f 41			ld a, (.dmark)  
412e 32 71 ee			ld (debug_mark),a  
4131 3a 40 41			ld a, (.dmark+1)  
4134 32 72 ee			ld (debug_mark+1),a  
4137 3a 41 41			ld a, (.dmark+2)  
413a 32 73 ee			ld (debug_mark+2),a  
413d 18 03			jr .pastdmark  
413f ..			.dmark: db "MNx"  
4142 f1			.pastdmark: pop af  
4143			endm  
# End of macro DMARK
4143						CALLMONITOR 
4143 cd e8 15			call break_point_state  
4146				endm  
# End of macro CALLMONITOR
4146					endif 
4146			 
4146			 
4146			 
4146 3e 00				ld a, 0 
4148 cd eb 0b				call menu 
414b			 
414b			 
414b 6f					ld l, a 
414c 26 00				ld h, 0 
414e			 
414e					if DEBUG_FORTH_WORDS 
414e						DMARK "MNr" 
414e f5				push af  
414f 3a 63 41			ld a, (.dmark)  
4152 32 71 ee			ld (debug_mark),a  
4155 3a 64 41			ld a, (.dmark+1)  
4158 32 72 ee			ld (debug_mark+1),a  
415b 3a 65 41			ld a, (.dmark+2)  
415e 32 73 ee			ld (debug_mark+2),a  
4161 18 03			jr .pastdmark  
4163 ..			.dmark: db "MNr"  
4166 f1			.pastdmark: pop af  
4167			endm  
# End of macro DMARK
4167						CALLMONITOR 
4167 cd e8 15			call break_point_state  
416a				endm  
# End of macro CALLMONITOR
416a					endif 
416a			 
416a cd 86 1c				call forth_push_numhl 
416d			 
416d			 
416d			 
416d			 
416d				       NEXTW 
416d c3 33 20			jp macro_next 
4170				endm 
# End of macro NEXTW
4170			 
4170			 
4170			.ENDDISPLAY: 
4170			 
4170			; eof 
# End of file forth_words_display.asm
4170			include "forth_words_str.asm" 
4170			 
4170			; | ## String Words 
4170			 
4170			.PTR:   
4170			 
4170				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4170 48				db WORD_SYS_CORE+52             
4171 9d 41			dw .STYPE            
4173 04				db 3 + 1 
4174 .. 00			db "PTR",0              
4178				endm 
# End of macro CWHEAD
4178			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4178			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4178			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4178			 
4178					if DEBUG_FORTH_WORDS_KEY 
4178						DMARK "PTR" 
4178 f5				push af  
4179 3a 8d 41			ld a, (.dmark)  
417c 32 71 ee			ld (debug_mark),a  
417f 3a 8e 41			ld a, (.dmark+1)  
4182 32 72 ee			ld (debug_mark+1),a  
4185 3a 8f 41			ld a, (.dmark+2)  
4188 32 73 ee			ld (debug_mark+2),a  
418b 18 03			jr .pastdmark  
418d ..			.dmark: db "PTR"  
4190 f1			.pastdmark: pop af  
4191			endm  
# End of macro DMARK
4191						CALLMONITOR 
4191 cd e8 15			call break_point_state  
4194				endm  
# End of macro CALLMONITOR
4194					endif 
4194					FORTH_DSP_VALUEHL 
4194 cd 7d 1e			call macro_dsp_valuehl 
4197				endm 
# End of macro FORTH_DSP_VALUEHL
4197 cd 86 1c				call forth_push_numhl 
419a			 
419a			 
419a					NEXTW 
419a c3 33 20			jp macro_next 
419d				endm 
# End of macro NEXTW
419d			.STYPE: 
419d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
419d 48				db WORD_SYS_CORE+52             
419e ec 41			dw .UPPER            
41a0 06				db 5 + 1 
41a1 .. 00			db "STYPE",0              
41a7				endm 
# End of macro CWHEAD
41a7			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41a7					if DEBUG_FORTH_WORDS_KEY 
41a7						DMARK "STY" 
41a7 f5				push af  
41a8 3a bc 41			ld a, (.dmark)  
41ab 32 71 ee			ld (debug_mark),a  
41ae 3a bd 41			ld a, (.dmark+1)  
41b1 32 72 ee			ld (debug_mark+1),a  
41b4 3a be 41			ld a, (.dmark+2)  
41b7 32 73 ee			ld (debug_mark+2),a  
41ba 18 03			jr .pastdmark  
41bc ..			.dmark: db "STY"  
41bf f1			.pastdmark: pop af  
41c0			endm  
# End of macro DMARK
41c0						CALLMONITOR 
41c0 cd e8 15			call break_point_state  
41c3				endm  
# End of macro CALLMONITOR
41c3					endif 
41c3					FORTH_DSP 
41c3 cd 43 1e			call macro_forth_dsp 
41c6				endm 
# End of macro FORTH_DSP
41c6					;v5 FORTH_DSP_VALUE 
41c6			 
41c6 7e					ld a, (hl) 
41c7			 
41c7 f5					push af 
41c8			 
41c8			; Dont destroy TOS		FORTH_DSP_POP 
41c8			 
41c8 f1					pop af 
41c9			 
41c9 fe 01				cp DS_TYPE_STR 
41cb 28 09				jr z, .typestr 
41cd			 
41cd fe 02				cp DS_TYPE_INUM 
41cf 28 0a				jr z, .typeinum 
41d1			 
41d1 21 ea 41				ld hl, .tna 
41d4 18 0a				jr .tpush 
41d6			 
41d6 21 e6 41		.typestr:	ld hl, .tstr 
41d9 18 05				jr .tpush 
41db 21 e8 41		.typeinum:	ld hl, .tinum 
41de 18 00				jr .tpush 
41e0			 
41e0			.tpush: 
41e0			 
41e0 cd f4 1c				call forth_push_str 
41e3			 
41e3					NEXTW 
41e3 c3 33 20			jp macro_next 
41e6				endm 
# End of macro NEXTW
41e6 .. 00		.tstr:	db "s",0 
41e8 .. 00		.tinum:  db "i",0 
41ea .. 00		.tna:   db "?", 0 
41ec			 
41ec			 
41ec			.UPPER: 
41ec				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41ec 48				db WORD_SYS_CORE+52             
41ed 27 42			dw .LOWER            
41ef 06				db 5 + 1 
41f0 .. 00			db "UPPER",0              
41f6				endm 
# End of macro CWHEAD
41f6			; | UPPER ( s -- s ) Upper case string s  | DONE 
41f6					if DEBUG_FORTH_WORDS_KEY 
41f6						DMARK "UPR" 
41f6 f5				push af  
41f7 3a 0b 42			ld a, (.dmark)  
41fa 32 71 ee			ld (debug_mark),a  
41fd 3a 0c 42			ld a, (.dmark+1)  
4200 32 72 ee			ld (debug_mark+1),a  
4203 3a 0d 42			ld a, (.dmark+2)  
4206 32 73 ee			ld (debug_mark+2),a  
4209 18 03			jr .pastdmark  
420b ..			.dmark: db "UPR"  
420e f1			.pastdmark: pop af  
420f			endm  
# End of macro DMARK
420f						CALLMONITOR 
420f cd e8 15			call break_point_state  
4212				endm  
# End of macro CALLMONITOR
4212					endif 
4212			 
4212					FORTH_DSP 
4212 cd 43 1e			call macro_forth_dsp 
4215				endm 
# End of macro FORTH_DSP
4215					 
4215			; TODO check is string type 
4215			 
4215					FORTH_DSP_VALUEHL 
4215 cd 7d 1e			call macro_dsp_valuehl 
4218				endm 
# End of macro FORTH_DSP_VALUEHL
4218			; get pointer to string in hl 
4218			 
4218 7e			.toup:		ld a, (hl) 
4219 fe 00				cp 0 
421b 28 07				jr z, .toupdone 
421d			 
421d cd 54 11				call to_upper 
4220			 
4220 77					ld (hl), a 
4221 23					inc hl 
4222 18 f4				jr .toup 
4224			 
4224					 
4224			 
4224			 
4224			; for each char convert to upper 
4224					 
4224			.toupdone: 
4224			 
4224			 
4224					NEXTW 
4224 c3 33 20			jp macro_next 
4227				endm 
# End of macro NEXTW
4227			.LOWER: 
4227				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4227 48				db WORD_SYS_CORE+52             
4228 62 42			dw .TCASE            
422a 06				db 5 + 1 
422b .. 00			db "LOWER",0              
4231				endm 
# End of macro CWHEAD
4231			; | LOWER ( s -- s ) Lower case string s  | DONE 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "LWR" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 71 ee			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 72 ee			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 73 ee			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "LWR"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd e8 15			call break_point_state  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d			 
424d					FORTH_DSP 
424d cd 43 1e			call macro_forth_dsp 
4250				endm 
# End of macro FORTH_DSP
4250					 
4250			; TODO check is string type 
4250			 
4250					FORTH_DSP_VALUEHL 
4250 cd 7d 1e			call macro_dsp_valuehl 
4253				endm 
# End of macro FORTH_DSP_VALUEHL
4253			; get pointer to string in hl 
4253			 
4253 7e			.tolow:		ld a, (hl) 
4254 fe 00				cp 0 
4256 28 07				jr z, .tolowdone 
4258			 
4258 cd 5d 11				call to_lower 
425b			 
425b 77					ld (hl), a 
425c 23					inc hl 
425d 18 f4				jr .tolow 
425f			 
425f					 
425f			 
425f			 
425f			; for each char convert to low 
425f					 
425f			.tolowdone: 
425f					NEXTW 
425f c3 33 20			jp macro_next 
4262				endm 
# End of macro NEXTW
4262			.TCASE: 
4262				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4262 48				db WORD_SYS_CORE+52             
4263 98 43			dw .SUBSTR            
4265 06				db 5 + 1 
4266 .. 00			db "TCASE",0              
426c				endm 
# End of macro CWHEAD
426c			; | TCASE ( s -- s ) Title case string s  | DONE 
426c					if DEBUG_FORTH_WORDS_KEY 
426c						DMARK "TCS" 
426c f5				push af  
426d 3a 81 42			ld a, (.dmark)  
4270 32 71 ee			ld (debug_mark),a  
4273 3a 82 42			ld a, (.dmark+1)  
4276 32 72 ee			ld (debug_mark+1),a  
4279 3a 83 42			ld a, (.dmark+2)  
427c 32 73 ee			ld (debug_mark+2),a  
427f 18 03			jr .pastdmark  
4281 ..			.dmark: db "TCS"  
4284 f1			.pastdmark: pop af  
4285			endm  
# End of macro DMARK
4285						CALLMONITOR 
4285 cd e8 15			call break_point_state  
4288				endm  
# End of macro CALLMONITOR
4288					endif 
4288			 
4288					FORTH_DSP 
4288 cd 43 1e			call macro_forth_dsp 
428b				endm 
# End of macro FORTH_DSP
428b					 
428b			; TODO check is string type 
428b			 
428b					FORTH_DSP_VALUEHL 
428b cd 7d 1e			call macro_dsp_valuehl 
428e				endm 
# End of macro FORTH_DSP_VALUEHL
428e			; get pointer to string in hl 
428e			 
428e					if DEBUG_FORTH_WORDS 
428e						DMARK "TC1" 
428e f5				push af  
428f 3a a3 42			ld a, (.dmark)  
4292 32 71 ee			ld (debug_mark),a  
4295 3a a4 42			ld a, (.dmark+1)  
4298 32 72 ee			ld (debug_mark+1),a  
429b 3a a5 42			ld a, (.dmark+2)  
429e 32 73 ee			ld (debug_mark+2),a  
42a1 18 03			jr .pastdmark  
42a3 ..			.dmark: db "TC1"  
42a6 f1			.pastdmark: pop af  
42a7			endm  
# End of macro DMARK
42a7						CALLMONITOR 
42a7 cd e8 15			call break_point_state  
42aa				endm  
# End of macro CALLMONITOR
42aa					endif 
42aa			 
42aa					; first time in turn to upper case first char 
42aa			 
42aa 7e					ld a, (hl) 
42ab c3 35 43				jp .totsiptou 
42ae			 
42ae			 
42ae 7e			.tot:		ld a, (hl) 
42af fe 00				cp 0 
42b1 ca 79 43				jp z, .totdone 
42b4			 
42b4					if DEBUG_FORTH_WORDS 
42b4						DMARK "TC2" 
42b4 f5				push af  
42b5 3a c9 42			ld a, (.dmark)  
42b8 32 71 ee			ld (debug_mark),a  
42bb 3a ca 42			ld a, (.dmark+1)  
42be 32 72 ee			ld (debug_mark+1),a  
42c1 3a cb 42			ld a, (.dmark+2)  
42c4 32 73 ee			ld (debug_mark+2),a  
42c7 18 03			jr .pastdmark  
42c9 ..			.dmark: db "TC2"  
42cc f1			.pastdmark: pop af  
42cd			endm  
# End of macro DMARK
42cd						CALLMONITOR 
42cd cd e8 15			call break_point_state  
42d0				endm  
# End of macro CALLMONITOR
42d0					endif 
42d0					; check to see if current char is a space 
42d0			 
42d0 fe 20				cp ' ' 
42d2 28 21				jr z, .totsp 
42d4 cd 5d 11				call to_lower 
42d7					if DEBUG_FORTH_WORDS 
42d7						DMARK "TC3" 
42d7 f5				push af  
42d8 3a ec 42			ld a, (.dmark)  
42db 32 71 ee			ld (debug_mark),a  
42de 3a ed 42			ld a, (.dmark+1)  
42e1 32 72 ee			ld (debug_mark+1),a  
42e4 3a ee 42			ld a, (.dmark+2)  
42e7 32 73 ee			ld (debug_mark+2),a  
42ea 18 03			jr .pastdmark  
42ec ..			.dmark: db "TC3"  
42ef f1			.pastdmark: pop af  
42f0			endm  
# End of macro DMARK
42f0						CALLMONITOR 
42f0 cd e8 15			call break_point_state  
42f3				endm  
# End of macro CALLMONITOR
42f3					endif 
42f3 18 63				jr .totnxt 
42f5			 
42f5			.totsp:         ; on a space, find next char which should be upper 
42f5			 
42f5					if DEBUG_FORTH_WORDS 
42f5						DMARK "TC4" 
42f5 f5				push af  
42f6 3a 0a 43			ld a, (.dmark)  
42f9 32 71 ee			ld (debug_mark),a  
42fc 3a 0b 43			ld a, (.dmark+1)  
42ff 32 72 ee			ld (debug_mark+1),a  
4302 3a 0c 43			ld a, (.dmark+2)  
4305 32 73 ee			ld (debug_mark+2),a  
4308 18 03			jr .pastdmark  
430a ..			.dmark: db "TC4"  
430d f1			.pastdmark: pop af  
430e			endm  
# End of macro DMARK
430e						CALLMONITOR 
430e cd e8 15			call break_point_state  
4311				endm  
# End of macro CALLMONITOR
4311					endif 
4311					;; 
4311			 
4311 fe 20				cp ' ' 
4313 20 20				jr nz, .totsiptou 
4315 23					inc hl 
4316 7e					ld a, (hl) 
4317					if DEBUG_FORTH_WORDS 
4317						DMARK "TC5" 
4317 f5				push af  
4318 3a 2c 43			ld a, (.dmark)  
431b 32 71 ee			ld (debug_mark),a  
431e 3a 2d 43			ld a, (.dmark+1)  
4321 32 72 ee			ld (debug_mark+1),a  
4324 3a 2e 43			ld a, (.dmark+2)  
4327 32 73 ee			ld (debug_mark+2),a  
432a 18 03			jr .pastdmark  
432c ..			.dmark: db "TC5"  
432f f1			.pastdmark: pop af  
4330			endm  
# End of macro DMARK
4330						CALLMONITOR 
4330 cd e8 15			call break_point_state  
4333				endm  
# End of macro CALLMONITOR
4333					endif 
4333 18 c0				jr .totsp 
4335 fe 00		.totsiptou:    cp 0 
4337 28 40				jr z, .totdone 
4339					; not space and not zero term so upper case it 
4339 cd 54 11				call to_upper 
433c			 
433c					if DEBUG_FORTH_WORDS 
433c						DMARK "TC6" 
433c f5				push af  
433d 3a 51 43			ld a, (.dmark)  
4340 32 71 ee			ld (debug_mark),a  
4343 3a 52 43			ld a, (.dmark+1)  
4346 32 72 ee			ld (debug_mark+1),a  
4349 3a 53 43			ld a, (.dmark+2)  
434c 32 73 ee			ld (debug_mark+2),a  
434f 18 03			jr .pastdmark  
4351 ..			.dmark: db "TC6"  
4354 f1			.pastdmark: pop af  
4355			endm  
# End of macro DMARK
4355						CALLMONITOR 
4355 cd e8 15			call break_point_state  
4358				endm  
# End of macro CALLMONITOR
4358					endif 
4358			 
4358			 
4358			.totnxt: 
4358			 
4358 77					ld (hl), a 
4359 23					inc hl 
435a					if DEBUG_FORTH_WORDS 
435a						DMARK "TC7" 
435a f5				push af  
435b 3a 6f 43			ld a, (.dmark)  
435e 32 71 ee			ld (debug_mark),a  
4361 3a 70 43			ld a, (.dmark+1)  
4364 32 72 ee			ld (debug_mark+1),a  
4367 3a 71 43			ld a, (.dmark+2)  
436a 32 73 ee			ld (debug_mark+2),a  
436d 18 03			jr .pastdmark  
436f ..			.dmark: db "TC7"  
4372 f1			.pastdmark: pop af  
4373			endm  
# End of macro DMARK
4373						CALLMONITOR 
4373 cd e8 15			call break_point_state  
4376				endm  
# End of macro CALLMONITOR
4376					endif 
4376 c3 ae 42				jp .tot 
4379			 
4379					 
4379			 
4379			 
4379			; for each char convert to low 
4379					 
4379			.totdone: 
4379					if DEBUG_FORTH_WORDS 
4379						DMARK "TCd" 
4379 f5				push af  
437a 3a 8e 43			ld a, (.dmark)  
437d 32 71 ee			ld (debug_mark),a  
4380 3a 8f 43			ld a, (.dmark+1)  
4383 32 72 ee			ld (debug_mark+1),a  
4386 3a 90 43			ld a, (.dmark+2)  
4389 32 73 ee			ld (debug_mark+2),a  
438c 18 03			jr .pastdmark  
438e ..			.dmark: db "TCd"  
4391 f1			.pastdmark: pop af  
4392			endm  
# End of macro DMARK
4392						CALLMONITOR 
4392 cd e8 15			call break_point_state  
4395				endm  
# End of macro CALLMONITOR
4395					endif 
4395					NEXTW 
4395 c3 33 20			jp macro_next 
4398				endm 
# End of macro NEXTW
4398			 
4398			.SUBSTR: 
4398				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4398 48				db WORD_SYS_CORE+52             
4399 f6 43			dw .LEFT            
439b 07				db 6 + 1 
439c .. 00			db "SUBSTR",0              
43a3				endm 
# End of macro CWHEAD
43a3			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43a3			 
43a3					if DEBUG_FORTH_WORDS_KEY 
43a3						DMARK "SST" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 71 ee			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 72 ee			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 73 ee			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "SST"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd e8 15			call break_point_state  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf			; TODO check string type 
43bf					FORTH_DSP_VALUEHL 
43bf cd 7d 1e			call macro_dsp_valuehl 
43c2				endm 
# End of macro FORTH_DSP_VALUEHL
43c2			 
43c2 e5					push hl      ; string length 
43c3			 
43c3					FORTH_DSP_POP 
43c3 cd 35 1f			call macro_forth_dsp_pop 
43c6				endm 
# End of macro FORTH_DSP_POP
43c6			 
43c6					FORTH_DSP_VALUEHL 
43c6 cd 7d 1e			call macro_dsp_valuehl 
43c9				endm 
# End of macro FORTH_DSP_VALUEHL
43c9			 
43c9 e5					push hl     ; start char 
43ca			 
43ca					FORTH_DSP_POP 
43ca cd 35 1f			call macro_forth_dsp_pop 
43cd				endm 
# End of macro FORTH_DSP_POP
43cd			 
43cd			 
43cd					FORTH_DSP_VALUE 
43cd cd 66 1e			call macro_forth_dsp_value 
43d0				endm 
# End of macro FORTH_DSP_VALUE
43d0			 
43d0 d1					pop de    ; get start post offset 
43d1			 
43d1 19					add hl, de    ; starting offset 
43d2			 
43d2 c1					pop bc 
43d3 c5					push bc      ; grab size of string 
43d4			 
43d4 e5					push hl    ; save string start  
43d5			 
43d5 26 00				ld h, 0 
43d7 69					ld l, c 
43d8 23					inc hl 
43d9 23					inc hl 
43da			 
43da cd ae 12				call malloc 
43dd				if DEBUG_FORTH_MALLOC_GUARD 
43dd cc 3e 4d				call z,malloc_error 
43e0				endif 
43e0			 
43e0 eb					ex de, hl      ; save malloc area for string copy 
43e1 e1					pop hl    ; get back source 
43e2 c1					pop bc    ; get length of string back 
43e3			 
43e3 d5					push de    ; save malloc area for after we push 
43e4 ed b0				ldir     ; copy substr 
43e6			 
43e6			 
43e6 eb					ex de, hl 
43e7 3e 00				ld a, 0 
43e9 77					ld (hl), a   ; term substr 
43ea			 
43ea					 
43ea e1					pop hl    ; get malloc so we can push it 
43eb e5					push hl   ; save so we can free it afterwards 
43ec			 
43ec cd f4 1c				call forth_push_str 
43ef			 
43ef e1					pop hl 
43f0 cd 78 13				call free 
43f3			 
43f3					 
43f3					 
43f3			 
43f3			 
43f3					NEXTW 
43f3 c3 33 20			jp macro_next 
43f6				endm 
# End of macro NEXTW
43f6			 
43f6			.LEFT: 
43f6				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43f6 48				db WORD_SYS_CORE+52             
43f7 1e 44			dw .RIGHT            
43f9 05				db 4 + 1 
43fa .. 00			db "LEFT",0              
43ff				endm 
# End of macro CWHEAD
43ff			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43ff					if DEBUG_FORTH_WORDS_KEY 
43ff						DMARK "LEF" 
43ff f5				push af  
4400 3a 14 44			ld a, (.dmark)  
4403 32 71 ee			ld (debug_mark),a  
4406 3a 15 44			ld a, (.dmark+1)  
4409 32 72 ee			ld (debug_mark+1),a  
440c 3a 16 44			ld a, (.dmark+2)  
440f 32 73 ee			ld (debug_mark+2),a  
4412 18 03			jr .pastdmark  
4414 ..			.dmark: db "LEF"  
4417 f1			.pastdmark: pop af  
4418			endm  
# End of macro DMARK
4418						CALLMONITOR 
4418 cd e8 15			call break_point_state  
441b				endm  
# End of macro CALLMONITOR
441b					endif 
441b			 
441b					NEXTW 
441b c3 33 20			jp macro_next 
441e				endm 
# End of macro NEXTW
441e			.RIGHT: 
441e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
441e 48				db WORD_SYS_CORE+52             
441f 47 44			dw .STR2NUM            
4421 06				db 5 + 1 
4422 .. 00			db "RIGHT",0              
4428				endm 
# End of macro CWHEAD
4428			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4428					if DEBUG_FORTH_WORDS_KEY 
4428						DMARK "RIG" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 71 ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 72 ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 73 ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "RIG"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd e8 15			call break_point_state  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444			 
4444					NEXTW 
4444 c3 33 20			jp macro_next 
4447				endm 
# End of macro NEXTW
4447			 
4447			 
4447			.STR2NUM: 
4447				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4447 48				db WORD_SYS_CORE+52             
4448 d3 44			dw .NUM2STR            
444a 08				db 7 + 1 
444b .. 00			db "STR2NUM",0              
4453				endm 
# End of macro CWHEAD
4453			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4453			 
4453			 
4453			; TODO STR type check to do 
4453					if DEBUG_FORTH_WORDS_KEY 
4453						DMARK "S2N" 
4453 f5				push af  
4454 3a 68 44			ld a, (.dmark)  
4457 32 71 ee			ld (debug_mark),a  
445a 3a 69 44			ld a, (.dmark+1)  
445d 32 72 ee			ld (debug_mark+1),a  
4460 3a 6a 44			ld a, (.dmark+2)  
4463 32 73 ee			ld (debug_mark+2),a  
4466 18 03			jr .pastdmark  
4468 ..			.dmark: db "S2N"  
446b f1			.pastdmark: pop af  
446c			endm  
# End of macro DMARK
446c						CALLMONITOR 
446c cd e8 15			call break_point_state  
446f				endm  
# End of macro CALLMONITOR
446f					endif 
446f			 
446f					;FORTH_DSP 
446f					FORTH_DSP_VALUE 
446f cd 66 1e			call macro_forth_dsp_value 
4472				endm 
# End of macro FORTH_DSP_VALUE
4472					;inc hl 
4472			 
4472 eb					ex de, hl 
4473					if DEBUG_FORTH_WORDS 
4473						DMARK "S2a" 
4473 f5				push af  
4474 3a 88 44			ld a, (.dmark)  
4477 32 71 ee			ld (debug_mark),a  
447a 3a 89 44			ld a, (.dmark+1)  
447d 32 72 ee			ld (debug_mark+1),a  
4480 3a 8a 44			ld a, (.dmark+2)  
4483 32 73 ee			ld (debug_mark+2),a  
4486 18 03			jr .pastdmark  
4488 ..			.dmark: db "S2a"  
448b f1			.pastdmark: pop af  
448c			endm  
# End of macro DMARK
448c						CALLMONITOR 
448c cd e8 15			call break_point_state  
448f				endm  
# End of macro CALLMONITOR
448f					endif 
448f cd dc 11				call string_to_uint16 
4492			 
4492					if DEBUG_FORTH_WORDS 
4492						DMARK "S2b" 
4492 f5				push af  
4493 3a a7 44			ld a, (.dmark)  
4496 32 71 ee			ld (debug_mark),a  
4499 3a a8 44			ld a, (.dmark+1)  
449c 32 72 ee			ld (debug_mark+1),a  
449f 3a a9 44			ld a, (.dmark+2)  
44a2 32 73 ee			ld (debug_mark+2),a  
44a5 18 03			jr .pastdmark  
44a7 ..			.dmark: db "S2b"  
44aa f1			.pastdmark: pop af  
44ab			endm  
# End of macro DMARK
44ab						CALLMONITOR 
44ab cd e8 15			call break_point_state  
44ae				endm  
# End of macro CALLMONITOR
44ae					endif 
44ae			;		push hl 
44ae					FORTH_DSP_POP 
44ae cd 35 1f			call macro_forth_dsp_pop 
44b1				endm 
# End of macro FORTH_DSP_POP
44b1			;		pop hl 
44b1					 
44b1					if DEBUG_FORTH_WORDS 
44b1						DMARK "S2b" 
44b1 f5				push af  
44b2 3a c6 44			ld a, (.dmark)  
44b5 32 71 ee			ld (debug_mark),a  
44b8 3a c7 44			ld a, (.dmark+1)  
44bb 32 72 ee			ld (debug_mark+1),a  
44be 3a c8 44			ld a, (.dmark+2)  
44c1 32 73 ee			ld (debug_mark+2),a  
44c4 18 03			jr .pastdmark  
44c6 ..			.dmark: db "S2b"  
44c9 f1			.pastdmark: pop af  
44ca			endm  
# End of macro DMARK
44ca						CALLMONITOR 
44ca cd e8 15			call break_point_state  
44cd				endm  
# End of macro CALLMONITOR
44cd					endif 
44cd cd 86 1c				call forth_push_numhl	 
44d0			 
44d0				 
44d0				       NEXTW 
44d0 c3 33 20			jp macro_next 
44d3				endm 
# End of macro NEXTW
44d3			.NUM2STR: 
44d3				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44d3 48				db WORD_SYS_CORE+52             
44d4 e2 44			dw .CONCAT            
44d6 08				db 7 + 1 
44d7 .. 00			db "NUM2STR",0              
44df				endm 
# End of macro CWHEAD
44df			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
44df			 
44df			;		; malloc a string to target 
44df			;		ld hl, 10     ; TODO max string size should be fine 
44df			;		call malloc 
44df			;		push hl    ; save malloc location 
44df			; 
44df			; 
44df			;; TODO check int type 
44df			;		FORTH_DSP_VALUEHL 
44df			;		ld a, l 
44df			;		call DispAToASCII   
44df			;;TODO need to chage above call to dump into string 
44df			; 
44df			; 
44df			 
44df				       NEXTW 
44df c3 33 20			jp macro_next 
44e2				endm 
# End of macro NEXTW
44e2			 
44e2			.CONCAT: 
44e2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44e2 48				db WORD_SYS_CORE+52             
44e3 95 45			dw .FIND            
44e5 07				db 6 + 1 
44e6 .. 00			db "CONCAT",0              
44ed				endm 
# End of macro CWHEAD
44ed			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44ed			 
44ed			; TODO check string type 
44ed			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44ed			 
44ed					if DEBUG_FORTH_WORDS_KEY 
44ed						DMARK "CON" 
44ed f5				push af  
44ee 3a 02 45			ld a, (.dmark)  
44f1 32 71 ee			ld (debug_mark),a  
44f4 3a 03 45			ld a, (.dmark+1)  
44f7 32 72 ee			ld (debug_mark+1),a  
44fa 3a 04 45			ld a, (.dmark+2)  
44fd 32 73 ee			ld (debug_mark+2),a  
4500 18 03			jr .pastdmark  
4502 ..			.dmark: db "CON"  
4505 f1			.pastdmark: pop af  
4506			endm  
# End of macro DMARK
4506						CALLMONITOR 
4506 cd e8 15			call break_point_state  
4509				endm  
# End of macro CALLMONITOR
4509					endif 
4509			 
4509			 
4509					FORTH_DSP_VALUE 
4509 cd 66 1e			call macro_forth_dsp_value 
450c				endm 
# End of macro FORTH_DSP_VALUE
450c e5					push hl   ; s2 
450d			 
450d					FORTH_DSP_POP 
450d cd 35 1f			call macro_forth_dsp_pop 
4510				endm 
# End of macro FORTH_DSP_POP
4510			 
4510					FORTH_DSP_VALUE 
4510 cd 66 1e			call macro_forth_dsp_value 
4513				endm 
# End of macro FORTH_DSP_VALUE
4513			 
4513 e5					push hl   ; s1 
4514			 
4514					FORTH_DSP_POP 
4514 cd 35 1f			call macro_forth_dsp_pop 
4517				endm 
# End of macro FORTH_DSP_POP
4517					 
4517			 
4517					; copy s1 
4517			 
4517				 
4517					; save ptr 
4517 e1					pop hl  
4518 e5					push hl 
4519 3e 00				ld a, 0 
451b cd 50 12				call strlent 
451e					;inc hl    ; zer0 
451e 06 00				ld b, 0 
4520 4d					ld c, l 
4521 e1					pop hl		 
4522 11 c7 e2				ld de, scratch	 
4525					if DEBUG_FORTH_WORDS 
4525						DMARK "CO1" 
4525 f5				push af  
4526 3a 3a 45			ld a, (.dmark)  
4529 32 71 ee			ld (debug_mark),a  
452c 3a 3b 45			ld a, (.dmark+1)  
452f 32 72 ee			ld (debug_mark+1),a  
4532 3a 3c 45			ld a, (.dmark+2)  
4535 32 73 ee			ld (debug_mark+2),a  
4538 18 03			jr .pastdmark  
453a ..			.dmark: db "CO1"  
453d f1			.pastdmark: pop af  
453e			endm  
# End of macro DMARK
453e						CALLMONITOR 
453e cd e8 15			call break_point_state  
4541				endm  
# End of macro CALLMONITOR
4541					endif 
4541 ed b0				ldir 
4543			 
4543 e1					pop hl 
4544 e5					push hl 
4545 d5					push de 
4546			 
4546			 
4546 3e 00				ld a, 0 
4548 cd 50 12				call strlent 
454b 23					inc hl    ; zer0 
454c 23					inc hl 
454d 06 00				ld b, 0 
454f 4d					ld c, l 
4550 d1					pop de 
4551 e1					pop hl		 
4552					if DEBUG_FORTH_WORDS 
4552						DMARK "CO2" 
4552 f5				push af  
4553 3a 67 45			ld a, (.dmark)  
4556 32 71 ee			ld (debug_mark),a  
4559 3a 68 45			ld a, (.dmark+1)  
455c 32 72 ee			ld (debug_mark+1),a  
455f 3a 69 45			ld a, (.dmark+2)  
4562 32 73 ee			ld (debug_mark+2),a  
4565 18 03			jr .pastdmark  
4567 ..			.dmark: db "CO2"  
456a f1			.pastdmark: pop af  
456b			endm  
# End of macro DMARK
456b						CALLMONITOR 
456b cd e8 15			call break_point_state  
456e				endm  
# End of macro CALLMONITOR
456e					endif 
456e ed b0				ldir 
4570			 
4570			 
4570			 
4570 21 c7 e2				ld hl, scratch 
4573					if DEBUG_FORTH_WORDS 
4573						DMARK "CO5" 
4573 f5				push af  
4574 3a 88 45			ld a, (.dmark)  
4577 32 71 ee			ld (debug_mark),a  
457a 3a 89 45			ld a, (.dmark+1)  
457d 32 72 ee			ld (debug_mark+1),a  
4580 3a 8a 45			ld a, (.dmark+2)  
4583 32 73 ee			ld (debug_mark+2),a  
4586 18 03			jr .pastdmark  
4588 ..			.dmark: db "CO5"  
458b f1			.pastdmark: pop af  
458c			endm  
# End of macro DMARK
458c						CALLMONITOR 
458c cd e8 15			call break_point_state  
458f				endm  
# End of macro CALLMONITOR
458f					endif 
458f			 
458f cd f4 1c				call forth_push_str 
4592			 
4592			 
4592			 
4592			 
4592				       NEXTW 
4592 c3 33 20			jp macro_next 
4595				endm 
# End of macro NEXTW
4595			 
4595			 
4595			.FIND: 
4595				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4595 4b				db WORD_SYS_CORE+55             
4596 53 46			dw .LEN            
4598 05				db 4 + 1 
4599 .. 00			db "FIND",0              
459e				endm 
# End of macro CWHEAD
459e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
459e			 
459e					if DEBUG_FORTH_WORDS_KEY 
459e						DMARK "FND" 
459e f5				push af  
459f 3a b3 45			ld a, (.dmark)  
45a2 32 71 ee			ld (debug_mark),a  
45a5 3a b4 45			ld a, (.dmark+1)  
45a8 32 72 ee			ld (debug_mark+1),a  
45ab 3a b5 45			ld a, (.dmark+2)  
45ae 32 73 ee			ld (debug_mark+2),a  
45b1 18 03			jr .pastdmark  
45b3 ..			.dmark: db "FND"  
45b6 f1			.pastdmark: pop af  
45b7			endm  
# End of macro DMARK
45b7						CALLMONITOR 
45b7 cd e8 15			call break_point_state  
45ba				endm  
# End of macro CALLMONITOR
45ba					endif 
45ba			 
45ba			; TODO check string type 
45ba					FORTH_DSP_VALUE 
45ba cd 66 1e			call macro_forth_dsp_value 
45bd				endm 
# End of macro FORTH_DSP_VALUE
45bd			 
45bd e5					push hl    
45be 7e					ld a,(hl)    ; char to find   
45bf			; TODO change char to substr 
45bf			 
45bf f5					push af 
45c0					 
45c0			 
45c0			 
45c0					if DEBUG_FORTH_WORDS 
45c0						DMARK "FN1" 
45c0 f5				push af  
45c1 3a d5 45			ld a, (.dmark)  
45c4 32 71 ee			ld (debug_mark),a  
45c7 3a d6 45			ld a, (.dmark+1)  
45ca 32 72 ee			ld (debug_mark+1),a  
45cd 3a d7 45			ld a, (.dmark+2)  
45d0 32 73 ee			ld (debug_mark+2),a  
45d3 18 03			jr .pastdmark  
45d5 ..			.dmark: db "FN1"  
45d8 f1			.pastdmark: pop af  
45d9			endm  
# End of macro DMARK
45d9						CALLMONITOR 
45d9 cd e8 15			call break_point_state  
45dc				endm  
# End of macro CALLMONITOR
45dc					endif 
45dc			 
45dc					FORTH_DSP_POP 
45dc cd 35 1f			call macro_forth_dsp_pop 
45df				endm 
# End of macro FORTH_DSP_POP
45df			 
45df					; string to search 
45df			 
45df					FORTH_DSP_VALUE 
45df cd 66 1e			call macro_forth_dsp_value 
45e2				endm 
# End of macro FORTH_DSP_VALUE
45e2			 
45e2 d1					pop de  ; d is char to find  
45e3			 
45e3					if DEBUG_FORTH_WORDS 
45e3						DMARK "FN2" 
45e3 f5				push af  
45e4 3a f8 45			ld a, (.dmark)  
45e7 32 71 ee			ld (debug_mark),a  
45ea 3a f9 45			ld a, (.dmark+1)  
45ed 32 72 ee			ld (debug_mark+1),a  
45f0 3a fa 45			ld a, (.dmark+2)  
45f3 32 73 ee			ld (debug_mark+2),a  
45f6 18 03			jr .pastdmark  
45f8 ..			.dmark: db "FN2"  
45fb f1			.pastdmark: pop af  
45fc			endm  
# End of macro DMARK
45fc						CALLMONITOR 
45fc cd e8 15			call break_point_state  
45ff				endm  
# End of macro CALLMONITOR
45ff					endif 
45ff					 
45ff 01 00 00				ld bc, 0 
4602 7e			.findchar:      ld a,(hl) 
4603 fe 00				cp 0   		 
4605 28 27				jr z, .finddone     
4607 ba					cp d 
4608 28 20				jr z, .foundchar 
460a 03					inc bc 
460b 23					inc hl 
460c					if DEBUG_FORTH_WORDS 
460c						DMARK "FN3" 
460c f5				push af  
460d 3a 21 46			ld a, (.dmark)  
4610 32 71 ee			ld (debug_mark),a  
4613 3a 22 46			ld a, (.dmark+1)  
4616 32 72 ee			ld (debug_mark+1),a  
4619 3a 23 46			ld a, (.dmark+2)  
461c 32 73 ee			ld (debug_mark+2),a  
461f 18 03			jr .pastdmark  
4621 ..			.dmark: db "FN3"  
4624 f1			.pastdmark: pop af  
4625			endm  
# End of macro DMARK
4625						CALLMONITOR 
4625 cd e8 15			call break_point_state  
4628				endm  
# End of macro CALLMONITOR
4628					endif 
4628 18 d8				jr .findchar 
462a			 
462a			 
462a c5			.foundchar:	push bc 
462b e1					pop hl 
462c 18 03				jr .findexit 
462e			 
462e			 
462e							 
462e			 
462e			.finddone:     ; got to end of string with no find 
462e 21 00 00				ld hl, 0 
4631			.findexit: 
4631			 
4631					if DEBUG_FORTH_WORDS 
4631						DMARK "FNd" 
4631 f5				push af  
4632 3a 46 46			ld a, (.dmark)  
4635 32 71 ee			ld (debug_mark),a  
4638 3a 47 46			ld a, (.dmark+1)  
463b 32 72 ee			ld (debug_mark+1),a  
463e 3a 48 46			ld a, (.dmark+2)  
4641 32 73 ee			ld (debug_mark+2),a  
4644 18 03			jr .pastdmark  
4646 ..			.dmark: db "FNd"  
4649 f1			.pastdmark: pop af  
464a			endm  
# End of macro DMARK
464a						CALLMONITOR 
464a cd e8 15			call break_point_state  
464d				endm  
# End of macro CALLMONITOR
464d					endif 
464d cd 86 1c			call forth_push_numhl 
4650			 
4650				       NEXTW 
4650 c3 33 20			jp macro_next 
4653				endm 
# End of macro NEXTW
4653			 
4653			.LEN: 
4653				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4653 4c				db WORD_SYS_CORE+56             
4654 bd 46			dw .ASC            
4656 06				db 5 + 1 
4657 .. 00			db "COUNT",0              
465d				endm 
# End of macro CWHEAD
465d			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
465d			 
465d					if DEBUG_FORTH_WORDS_KEY 
465d						DMARK "CNT" 
465d f5				push af  
465e 3a 72 46			ld a, (.dmark)  
4661 32 71 ee			ld (debug_mark),a  
4664 3a 73 46			ld a, (.dmark+1)  
4667 32 72 ee			ld (debug_mark+1),a  
466a 3a 74 46			ld a, (.dmark+2)  
466d 32 73 ee			ld (debug_mark+2),a  
4670 18 03			jr .pastdmark  
4672 ..			.dmark: db "CNT"  
4675 f1			.pastdmark: pop af  
4676			endm  
# End of macro DMARK
4676						CALLMONITOR 
4676 cd e8 15			call break_point_state  
4679				endm  
# End of macro CALLMONITOR
4679					endif 
4679			; TODO check string type 
4679					FORTH_DSP_VALUE 
4679 cd 66 1e			call macro_forth_dsp_value 
467c				endm 
# End of macro FORTH_DSP_VALUE
467c			 
467c			 
467c					if DEBUG_FORTH_WORDS 
467c						DMARK "CN?" 
467c f5				push af  
467d 3a 91 46			ld a, (.dmark)  
4680 32 71 ee			ld (debug_mark),a  
4683 3a 92 46			ld a, (.dmark+1)  
4686 32 72 ee			ld (debug_mark+1),a  
4689 3a 93 46			ld a, (.dmark+2)  
468c 32 73 ee			ld (debug_mark+2),a  
468f 18 03			jr .pastdmark  
4691 ..			.dmark: db "CN?"  
4694 f1			.pastdmark: pop af  
4695			endm  
# End of macro DMARK
4695						CALLMONITOR 
4695 cd e8 15			call break_point_state  
4698				endm  
# End of macro CALLMONITOR
4698					endif 
4698 cd 45 12				call strlenz 
469b					if DEBUG_FORTH_WORDS 
469b						DMARK "CNl" 
469b f5				push af  
469c 3a b0 46			ld a, (.dmark)  
469f 32 71 ee			ld (debug_mark),a  
46a2 3a b1 46			ld a, (.dmark+1)  
46a5 32 72 ee			ld (debug_mark+1),a  
46a8 3a b2 46			ld a, (.dmark+2)  
46ab 32 73 ee			ld (debug_mark+2),a  
46ae 18 03			jr .pastdmark  
46b0 ..			.dmark: db "CNl"  
46b3 f1			.pastdmark: pop af  
46b4			endm  
# End of macro DMARK
46b4						CALLMONITOR 
46b4 cd e8 15			call break_point_state  
46b7				endm  
# End of macro CALLMONITOR
46b7					endif 
46b7			 
46b7 cd 86 1c				call forth_push_numhl 
46ba			 
46ba			 
46ba			 
46ba				       NEXTW 
46ba c3 33 20			jp macro_next 
46bd				endm 
# End of macro NEXTW
46bd			.ASC: 
46bd				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46bd 4d				db WORD_SYS_CORE+57             
46be 2b 47			dw .CHR            
46c0 04				db 3 + 1 
46c1 .. 00			db "ASC",0              
46c5				endm 
# End of macro CWHEAD
46c5			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46c5					if DEBUG_FORTH_WORDS_KEY 
46c5						DMARK "ASC" 
46c5 f5				push af  
46c6 3a da 46			ld a, (.dmark)  
46c9 32 71 ee			ld (debug_mark),a  
46cc 3a db 46			ld a, (.dmark+1)  
46cf 32 72 ee			ld (debug_mark+1),a  
46d2 3a dc 46			ld a, (.dmark+2)  
46d5 32 73 ee			ld (debug_mark+2),a  
46d8 18 03			jr .pastdmark  
46da ..			.dmark: db "ASC"  
46dd f1			.pastdmark: pop af  
46de			endm  
# End of macro DMARK
46de						CALLMONITOR 
46de cd e8 15			call break_point_state  
46e1				endm  
# End of macro CALLMONITOR
46e1					endif 
46e1					FORTH_DSP_VALUE 
46e1 cd 66 1e			call macro_forth_dsp_value 
46e4				endm 
# End of macro FORTH_DSP_VALUE
46e4					;v5 FORTH_DSP_VALUE 
46e4			;		inc hl      ; now at start of numeric as string 
46e4			 
46e4 e5					push hl 
46e5			 
46e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46e5 cd 35 1f			call macro_forth_dsp_pop 
46e8				endm 
# End of macro FORTH_DSP_POP
46e8			 
46e8 e1					pop hl 
46e9			 
46e9					if DEBUG_FORTH_WORDS 
46e9						DMARK "AS1" 
46e9 f5				push af  
46ea 3a fe 46			ld a, (.dmark)  
46ed 32 71 ee			ld (debug_mark),a  
46f0 3a ff 46			ld a, (.dmark+1)  
46f3 32 72 ee			ld (debug_mark+1),a  
46f6 3a 00 47			ld a, (.dmark+2)  
46f9 32 73 ee			ld (debug_mark+2),a  
46fc 18 03			jr .pastdmark  
46fe ..			.dmark: db "AS1"  
4701 f1			.pastdmark: pop af  
4702			endm  
# End of macro DMARK
4702						CALLMONITOR 
4702 cd e8 15			call break_point_state  
4705				endm  
# End of macro CALLMONITOR
4705					endif 
4705					; push the content of a onto the stack as a value 
4705			 
4705 7e					ld a,(hl)   ; get char 
4706 26 00				ld h,0 
4708 6f					ld l,a 
4709					if DEBUG_FORTH_WORDS 
4709						DMARK "AS2" 
4709 f5				push af  
470a 3a 1e 47			ld a, (.dmark)  
470d 32 71 ee			ld (debug_mark),a  
4710 3a 1f 47			ld a, (.dmark+1)  
4713 32 72 ee			ld (debug_mark+1),a  
4716 3a 20 47			ld a, (.dmark+2)  
4719 32 73 ee			ld (debug_mark+2),a  
471c 18 03			jr .pastdmark  
471e ..			.dmark: db "AS2"  
4721 f1			.pastdmark: pop af  
4722			endm  
# End of macro DMARK
4722						CALLMONITOR 
4722 cd e8 15			call break_point_state  
4725				endm  
# End of macro CALLMONITOR
4725					endif 
4725 cd 86 1c				call forth_push_numhl 
4728			 
4728				       NEXTW 
4728 c3 33 20			jp macro_next 
472b				endm 
# End of macro NEXTW
472b			 
472b			.CHR: 
472b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
472b 4d				db WORD_SYS_CORE+57             
472c 67 47			dw .ENDSTR            
472e 04				db 3 + 1 
472f .. 00			db "CHR",0              
4733				endm 
# End of macro CWHEAD
4733			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4733					if DEBUG_FORTH_WORDS_KEY 
4733						DMARK "CHR" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 71 ee			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 72 ee			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 73 ee			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "CHR"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd e8 15			call break_point_state  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f					FORTH_DSP_VALUEHL 
474f cd 7d 1e			call macro_dsp_valuehl 
4752				endm 
# End of macro FORTH_DSP_VALUEHL
4752			 
4752					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4752 cd 35 1f			call macro_forth_dsp_pop 
4755				endm 
# End of macro FORTH_DSP_POP
4755			 
4755					; save asci byte as a zero term string and push string 
4755			 
4755 7d					ld a,l 
4756 32 c7 e2				ld (scratch), a 
4759			 
4759 3e 00				ld a, 0 
475b 32 c8 e2				ld (scratch+1), a 
475e			 
475e 21 c7 e2				ld hl, scratch 
4761 cd f4 1c				call forth_push_str 
4764			 
4764			 
4764				       NEXTW 
4764 c3 33 20			jp macro_next 
4767				endm 
# End of macro NEXTW
4767			 
4767			 
4767			 
4767			 
4767			.ENDSTR: 
4767			; eof 
4767			 
# End of file forth_words_str.asm
4767			include "forth_words_key.asm" 
4767			 
4767			; | ## Keyboard Words 
4767			 
4767			.KEY: 
4767				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4767 3e				db WORD_SYS_CORE+42             
4768 97 47			dw .WAITK            
476a 04				db 3 + 1 
476b .. 00			db "KEY",0              
476f				endm 
# End of macro CWHEAD
476f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
476f			 
476f					if DEBUG_FORTH_WORDS_KEY 
476f						DMARK "KEY" 
476f f5				push af  
4770 3a 84 47			ld a, (.dmark)  
4773 32 71 ee			ld (debug_mark),a  
4776 3a 85 47			ld a, (.dmark+1)  
4779 32 72 ee			ld (debug_mark+1),a  
477c 3a 86 47			ld a, (.dmark+2)  
477f 32 73 ee			ld (debug_mark+2),a  
4782 18 03			jr .pastdmark  
4784 ..			.dmark: db "KEY"  
4787 f1			.pastdmark: pop af  
4788			endm  
# End of macro DMARK
4788						CALLMONITOR 
4788 cd e8 15			call break_point_state  
478b				endm  
# End of macro CALLMONITOR
478b					endif 
478b			; TODO currently waits 
478b cd c7 64				call cin 
478e					;call cin_wait 
478e 6f					ld l, a 
478f 26 00				ld h, 0 
4791 cd 86 1c				call forth_push_numhl 
4794					NEXTW 
4794 c3 33 20			jp macro_next 
4797				endm 
# End of macro NEXTW
4797			.WAITK: 
4797				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4797 3f				db WORD_SYS_CORE+43             
4798 c9 47			dw .ACCEPT            
479a 06				db 5 + 1 
479b .. 00			db "WAITK",0              
47a1				endm 
# End of macro CWHEAD
47a1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47a1					if DEBUG_FORTH_WORDS_KEY 
47a1						DMARK "WAI" 
47a1 f5				push af  
47a2 3a b6 47			ld a, (.dmark)  
47a5 32 71 ee			ld (debug_mark),a  
47a8 3a b7 47			ld a, (.dmark+1)  
47ab 32 72 ee			ld (debug_mark+1),a  
47ae 3a b8 47			ld a, (.dmark+2)  
47b1 32 73 ee			ld (debug_mark+2),a  
47b4 18 03			jr .pastdmark  
47b6 ..			.dmark: db "WAI"  
47b9 f1			.pastdmark: pop af  
47ba			endm  
# End of macro DMARK
47ba						CALLMONITOR 
47ba cd e8 15			call break_point_state  
47bd				endm  
# End of macro CALLMONITOR
47bd					endif 
47bd cd bf 64				call cin_wait 
47c0 6f					ld l, a 
47c1 26 00				ld h, 0 
47c3 cd 86 1c				call forth_push_numhl 
47c6					NEXTW 
47c6 c3 33 20			jp macro_next 
47c9				endm 
# End of macro NEXTW
47c9			.ACCEPT: 
47c9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47c9 40				db WORD_SYS_CORE+44             
47ca 27 48			dw .EDIT            
47cc 07				db 6 + 1 
47cd .. 00			db "ACCEPT",0              
47d4				endm 
# End of macro CWHEAD
47d4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47d4					; TODO crashes on push 
47d4					if DEBUG_FORTH_WORDS_KEY 
47d4						DMARK "ACC" 
47d4 f5				push af  
47d5 3a e9 47			ld a, (.dmark)  
47d8 32 71 ee			ld (debug_mark),a  
47db 3a ea 47			ld a, (.dmark+1)  
47de 32 72 ee			ld (debug_mark+1),a  
47e1 3a eb 47			ld a, (.dmark+2)  
47e4 32 73 ee			ld (debug_mark+2),a  
47e7 18 03			jr .pastdmark  
47e9 ..			.dmark: db "ACC"  
47ec f1			.pastdmark: pop af  
47ed			endm  
# End of macro DMARK
47ed						CALLMONITOR 
47ed cd e8 15			call break_point_state  
47f0				endm  
# End of macro CALLMONITOR
47f0					endif 
47f0 21 c5 e4				ld hl, os_input 
47f3 3e 00				ld a, 0 
47f5 77					ld (hl),a 
47f6 3a 64 ea				ld a,(f_cursor_ptr) 
47f9 16 64				ld d, 100 
47fb 0e 00				ld c, 0 
47fd 1e 28				ld e, 40 
47ff cd 14 0e				call input_str 
4802					; TODO perhaps do a type check and wrap in quotes if not a number 
4802 21 c5 e4				ld hl, os_input 
4805					if DEBUG_FORTH_WORDS 
4805						DMARK "AC1" 
4805 f5				push af  
4806 3a 1a 48			ld a, (.dmark)  
4809 32 71 ee			ld (debug_mark),a  
480c 3a 1b 48			ld a, (.dmark+1)  
480f 32 72 ee			ld (debug_mark+1),a  
4812 3a 1c 48			ld a, (.dmark+2)  
4815 32 73 ee			ld (debug_mark+2),a  
4818 18 03			jr .pastdmark  
481a ..			.dmark: db "AC1"  
481d f1			.pastdmark: pop af  
481e			endm  
# End of macro DMARK
481e						CALLMONITOR 
481e cd e8 15			call break_point_state  
4821				endm  
# End of macro CALLMONITOR
4821					endif 
4821 cd f4 1c				call forth_push_str 
4824					NEXTW 
4824 c3 33 20			jp macro_next 
4827				endm 
# End of macro NEXTW
4827			 
4827			.EDIT: 
4827				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4827 40				db WORD_SYS_CORE+44             
4828 c9 48			dw .DEDIT            
482a 05				db 4 + 1 
482b .. 00			db "EDIT",0              
4830				endm 
# End of macro CWHEAD
4830			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4830			 
4830					; TODO does not copy from stack 
4830					if DEBUG_FORTH_WORDS_KEY 
4830						DMARK "EDT" 
4830 f5				push af  
4831 3a 45 48			ld a, (.dmark)  
4834 32 71 ee			ld (debug_mark),a  
4837 3a 46 48			ld a, (.dmark+1)  
483a 32 72 ee			ld (debug_mark+1),a  
483d 3a 47 48			ld a, (.dmark+2)  
4840 32 73 ee			ld (debug_mark+2),a  
4843 18 03			jr .pastdmark  
4845 ..			.dmark: db "EDT"  
4848 f1			.pastdmark: pop af  
4849			endm  
# End of macro DMARK
4849						CALLMONITOR 
4849 cd e8 15			call break_point_state  
484c				endm  
# End of macro CALLMONITOR
484c					endif 
484c			 
484c					;FORTH_DSP 
484c					FORTH_DSP_VALUEHL 
484c cd 7d 1e			call macro_dsp_valuehl 
484f				endm 
# End of macro FORTH_DSP_VALUEHL
484f			;		inc hl    ; TODO do type check 
484f			 
484f			;		call get_word_hl 
484f e5					push hl 
4850					if DEBUG_FORTH_WORDS 
4850						DMARK "EDp" 
4850 f5				push af  
4851 3a 65 48			ld a, (.dmark)  
4854 32 71 ee			ld (debug_mark),a  
4857 3a 66 48			ld a, (.dmark+1)  
485a 32 72 ee			ld (debug_mark+1),a  
485d 3a 67 48			ld a, (.dmark+2)  
4860 32 73 ee			ld (debug_mark+2),a  
4863 18 03			jr .pastdmark  
4865 ..			.dmark: db "EDp"  
4868 f1			.pastdmark: pop af  
4869			endm  
# End of macro DMARK
4869						CALLMONITOR 
4869 cd e8 15			call break_point_state  
486c				endm  
# End of macro CALLMONITOR
486c					endif 
486c				;	ld a, 0 
486c cd 45 12				call strlenz 
486f 23					inc hl 
4870			 
4870 06 00				ld b, 0 
4872 4d					ld c, l 
4873			 
4873 e1					pop hl 
4874 11 c5 e4				ld de, os_input 
4877					if DEBUG_FORTH_WORDS_KEY 
4877						DMARK "EDc" 
4877 f5				push af  
4878 3a 8c 48			ld a, (.dmark)  
487b 32 71 ee			ld (debug_mark),a  
487e 3a 8d 48			ld a, (.dmark+1)  
4881 32 72 ee			ld (debug_mark+1),a  
4884 3a 8e 48			ld a, (.dmark+2)  
4887 32 73 ee			ld (debug_mark+2),a  
488a 18 03			jr .pastdmark  
488c ..			.dmark: db "EDc"  
488f f1			.pastdmark: pop af  
4890			endm  
# End of macro DMARK
4890						CALLMONITOR 
4890 cd e8 15			call break_point_state  
4893				endm  
# End of macro CALLMONITOR
4893					endif 
4893 ed b0				ldir 
4895			 
4895			 
4895 21 c5 e4				ld hl, os_input 
4898					;ld a, 0 
4898					;ld (hl),a 
4898 3a 64 ea				ld a,(f_cursor_ptr) 
489b 16 64				ld d, 100 
489d 0e 00				ld c, 0 
489f 1e 28				ld e, 40 
48a1 cd 14 0e				call input_str 
48a4					; TODO perhaps do a type check and wrap in quotes if not a number 
48a4 21 c5 e4				ld hl, os_input 
48a7					if DEBUG_FORTH_WORDS 
48a7						DMARK "ED1" 
48a7 f5				push af  
48a8 3a bc 48			ld a, (.dmark)  
48ab 32 71 ee			ld (debug_mark),a  
48ae 3a bd 48			ld a, (.dmark+1)  
48b1 32 72 ee			ld (debug_mark+1),a  
48b4 3a be 48			ld a, (.dmark+2)  
48b7 32 73 ee			ld (debug_mark+2),a  
48ba 18 03			jr .pastdmark  
48bc ..			.dmark: db "ED1"  
48bf f1			.pastdmark: pop af  
48c0			endm  
# End of macro DMARK
48c0						CALLMONITOR 
48c0 cd e8 15			call break_point_state  
48c3				endm  
# End of macro CALLMONITOR
48c3					endif 
48c3 cd f4 1c				call forth_push_str 
48c6					NEXTW 
48c6 c3 33 20			jp macro_next 
48c9				endm 
# End of macro NEXTW
48c9			 
48c9			.DEDIT: 
48c9				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48c9 40				db WORD_SYS_CORE+44             
48ca 2b 49			dw .ENDKEY            
48cc 06				db 5 + 1 
48cd .. 00			db "DEDIT",0              
48d3				endm 
# End of macro CWHEAD
48d3			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48d3			 
48d3					; TODO does not copy from stack 
48d3					if DEBUG_FORTH_WORDS_KEY 
48d3						DMARK "DED" 
48d3 f5				push af  
48d4 3a e8 48			ld a, (.dmark)  
48d7 32 71 ee			ld (debug_mark),a  
48da 3a e9 48			ld a, (.dmark+1)  
48dd 32 72 ee			ld (debug_mark+1),a  
48e0 3a ea 48			ld a, (.dmark+2)  
48e3 32 73 ee			ld (debug_mark+2),a  
48e6 18 03			jr .pastdmark  
48e8 ..			.dmark: db "DED"  
48eb f1			.pastdmark: pop af  
48ec			endm  
# End of macro DMARK
48ec						CALLMONITOR 
48ec cd e8 15			call break_point_state  
48ef				endm  
# End of macro CALLMONITOR
48ef					endif 
48ef			 
48ef					;FORTH_DSP 
48ef					FORTH_DSP_VALUEHL 
48ef cd 7d 1e			call macro_dsp_valuehl 
48f2				endm 
# End of macro FORTH_DSP_VALUEHL
48f2			;		inc hl    ; TODO do type check 
48f2			 
48f2			;		call get_word_hl 
48f2 e5					push hl 
48f3 e5					push hl 
48f4					FORTH_DSP_POP 
48f4 cd 35 1f			call macro_forth_dsp_pop 
48f7				endm 
# End of macro FORTH_DSP_POP
48f7 e1					pop hl 
48f8					if DEBUG_FORTH_WORDS 
48f8						DMARK "EDp" 
48f8 f5				push af  
48f9 3a 0d 49			ld a, (.dmark)  
48fc 32 71 ee			ld (debug_mark),a  
48ff 3a 0e 49			ld a, (.dmark+1)  
4902 32 72 ee			ld (debug_mark+1),a  
4905 3a 0f 49			ld a, (.dmark+2)  
4908 32 73 ee			ld (debug_mark+2),a  
490b 18 03			jr .pastdmark  
490d ..			.dmark: db "EDp"  
4910 f1			.pastdmark: pop af  
4911			endm  
# End of macro DMARK
4911						CALLMONITOR 
4911 cd e8 15			call break_point_state  
4914				endm  
# End of macro CALLMONITOR
4914					endif 
4914				;	ld a, 0 
4914 cd 45 12				call strlenz 
4917 23					inc hl 
4918			 
4918 06 00				ld b, 0 
491a 4d					ld c, l 
491b			 
491b e1					pop hl 
491c			 
491c					;ld a, 0 
491c					;ld (hl),a 
491c 3a 64 ea				ld a,(f_cursor_ptr) 
491f 16 64				ld d, 100 
4921 0e 00				ld c, 0 
4923 1e 28				ld e, 40 
4925 cd 14 0e				call input_str 
4928					; TODO perhaps do a type check and wrap in quotes if not a number 
4928					NEXTW 
4928 c3 33 20			jp macro_next 
492b				endm 
# End of macro NEXTW
492b			 
492b			 
492b			.ENDKEY: 
492b			; eof 
492b			 
# End of file forth_words_key.asm
492b			include "forth_words_const.asm" 
492b			 
492b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
492b			 
492b			 
492b			.SPITIME: 
492b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
492b 77				db WORD_SYS_CORE+99             
492c 40 49			dw .VA            
492e 08				db 7 + 1 
492f .. 00			db "SPITIME",0              
4937				endm 
# End of macro CWHEAD
4937			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4937			; 
4937			; | If using BANK devices then leave as is. 
4937			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4937			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4937			 
4937 21 6a ea				ld hl, spi_clktime  
493a cd 86 1c				call forth_push_numhl 
493d			 
493d					NEXTW 
493d c3 33 20			jp macro_next 
4940				endm 
# End of macro NEXTW
4940			 
4940			 
4940			.VA: 
4940				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4940 77				db WORD_SYS_CORE+99             
4941 50 49			dw .SYMBOL            
4943 03				db 2 + 1 
4944 .. 00			db "VA",0              
4947				endm 
# End of macro CWHEAD
4947			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4947 21 2e ea				ld hl, cli_var_array 
494a cd 86 1c				call forth_push_numhl 
494d			 
494d					NEXTW 
494d c3 33 20			jp macro_next 
4950				endm 
# End of macro NEXTW
4950			 
4950			.SYMBOL: 
4950				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4950 77				db WORD_SYS_CORE+99             
4951 88 4a			dw .ENDCONST            
4953 07				db 6 + 1 
4954 .. 00			db "SYMBOL",0              
495b				endm 
# End of macro CWHEAD
495b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
495b			; | 
495b			; | The value is the number reference and the final address is pushed to stack 
495b			 
495b					if DEBUG_FORTH_WORDS_KEY 
495b						DMARK "SYM" 
495b f5				push af  
495c 3a 70 49			ld a, (.dmark)  
495f 32 71 ee			ld (debug_mark),a  
4962 3a 71 49			ld a, (.dmark+1)  
4965 32 72 ee			ld (debug_mark+1),a  
4968 3a 72 49			ld a, (.dmark+2)  
496b 32 73 ee			ld (debug_mark+2),a  
496e 18 03			jr .pastdmark  
4970 ..			.dmark: db "SYM"  
4973 f1			.pastdmark: pop af  
4974			endm  
# End of macro DMARK
4974						CALLMONITOR 
4974 cd e8 15			call break_point_state  
4977				endm  
# End of macro CALLMONITOR
4977					endif 
4977			 
4977					FORTH_DSP_VALUEHL 
4977 cd 7d 1e			call macro_dsp_valuehl 
497a				endm 
# End of macro FORTH_DSP_VALUEHL
497a			 
497a 7d					ld a, l     
497b			 
497b			 
497b					if DEBUG_FORTH_WORDS 
497b						DMARK "SY1" 
497b f5				push af  
497c 3a 90 49			ld a, (.dmark)  
497f 32 71 ee			ld (debug_mark),a  
4982 3a 91 49			ld a, (.dmark+1)  
4985 32 72 ee			ld (debug_mark+1),a  
4988 3a 92 49			ld a, (.dmark+2)  
498b 32 73 ee			ld (debug_mark+2),a  
498e 18 03			jr .pastdmark  
4990 ..			.dmark: db "SY1"  
4993 f1			.pastdmark: pop af  
4994			endm  
# End of macro DMARK
4994						CALLMONITOR 
4994 cd e8 15			call break_point_state  
4997				endm  
# End of macro CALLMONITOR
4997					endif 
4997					 
4997 f5					push af	 
4998					FORTH_DSP_POP 
4998 cd 35 1f			call macro_forth_dsp_pop 
499b				endm 
# End of macro FORTH_DSP_POP
499b f1					pop af 
499c			 
499c cb 27				sla a  
499e				 
499e					 
499e					if DEBUG_FORTH_WORDS 
499e						DMARK "SY" 
499e f5				push af  
499f 3a b3 49			ld a, (.dmark)  
49a2 32 71 ee			ld (debug_mark),a  
49a5 3a b4 49			ld a, (.dmark+1)  
49a8 32 72 ee			ld (debug_mark+1),a  
49ab 3a b5 49			ld a, (.dmark+2)  
49ae 32 73 ee			ld (debug_mark+2),a  
49b1 18 02			jr .pastdmark  
49b3 ..			.dmark: db "SY"  
49b5 f1			.pastdmark: pop af  
49b6			endm  
# End of macro DMARK
49b6						CALLMONITOR 
49b6 cd e8 15			call break_point_state  
49b9				endm  
# End of macro CALLMONITOR
49b9					endif 
49b9			 
49b9 21 c8 49				ld hl, sym_table 
49bc cd e7 0d				call addatohl 
49bf cd b5 1f				call loadwordinhl 
49c2 cd 86 1c				call forth_push_numhl 
49c5			 
49c5			 
49c5				       NEXTW 
49c5 c3 33 20			jp macro_next 
49c8				endm 
# End of macro NEXTW
49c8			 
49c8			sym_table: 
49c8			 
49c8			; 0 
49c8 42 ea		dw cli_autodisplay 
49ca 50 ea		dw cli_buffer 
49cc f4 e9		dw cli_data_sp 
49ce 2e e8		dw cli_data_stack 
49d0 4a ea		dw cli_execword 
49d2 f6 e9		dw cli_loop_sp 
49d4 30 e9		dw cli_loop_stack 
49d6 43 ea		dw cli_mvdot 
49d8 48 ea		dw cli_nextword 
49da 44 ea		dw cli_origptr 
49dc 4e ea		dw cli_origtoken 
49de			; 11 
49de 46 ea		dw cli_ptr 
49e0 f8 e9		dw cli_ret_sp 
49e2 b2 e9		dw cli_ret_stack 
49e4 4c ea		dw cli_token 
49e6 2e ea		dw cli_var_array 
49e8 cb eb		dw cursor_col 
49ea c9 eb		dw cursor_ptr 
49ec ca eb		dw cursor_row 
49ee c7 eb		dw cursor_shape 
49f0 71 ee		dw debug_mark 
49f2			; 21 
49f2 b7 ed		dw display_fb0 
49f4 16 ed		dw display_fb1 
49f6 d4 eb		dw display_fb2 
49f8 75 ec		dw display_fb3 
49fa d2 eb		dw display_fb_active 
49fc c6 e3		dw execscratch 
49fe 64 ea		dw f_cursor_ptr 
4a00 75 ee		dw hardware_word 
4a02 68 ee		dw input_at_cursor 
4a04 6a ee		dw input_at_pos 
4a06			; 31 
4a06 66 ee		dw input_cur_flash 
4a08 65 ee		dw input_cur_onoff 
4a0a 5b ee		dw input_cursor 
4a0c 6b ee		dw input_display_size 
4a0e 60 ee		dw input_len 
4a10 6f ee		dw input_ptr 
4a12 6c ee		dw input_size 
4a14 6d ee		dw input_start 
4a16 14 0e		dw input_str 
4a18 69 ee		dw input_under_cursor 
4a1a			; 41 
4a1a 5a ee		dw key_actual_pressed 
4a1c 85 ee		dw key_fa 
4a1e 81 ee		dw key_face_held 
4a20 84 ee		dw key_fb 
4a22 83 ee		dw key_fc 
4a24 82 ee		dw key_fd 
4a26 8b ee		dw key_held 
4a28 8a ee		dw key_held_prev 
4a2a be 64		dw key_init 
4a2c 86 ee		dw key_repeat_ct 
4a2e			; 51 
4a2e 05 00		dw key_rows 
4a30 58 ee		dw key_shift 
4a32 59 ee		dw key_symbol 
4a34 8c ee		dw keyscan_scancol 
4a36 96 ee		dw keyscan_table 
4a38 f5 ee		dw keyscan_table_row1 
4a3a ea ee		dw keyscan_table_row2 
4a3c df ee		dw keyscan_table_row3 
4a3e d4 ee		dw keyscan_table_row4 
4a40 c9 ee		dw keyscan_table_row5 
4a42			; 61 
4a42 ee e5		dw os_cli_cmd 
4a44 ea e5		dw os_cur_ptr 
4a46 ec e5		dw os_current_i 
4a48 c5 e4		dw os_input 
4a4a ed e6		dw os_last_cmd 
4a4c c4 e5		dw os_last_new_uword 
4a4e b8 e2		dw os_view_disable 
4a50 b4 e2		dw os_view_hl 
4a52 cc e5		dw os_word_scratch 
4a54 c3 00		dw portbctl 
4a56			; 71 
4a56 c1 00		dw portbdata 
4a58 69 ea		dw spi_cartdev 
4a5a 68 ea		dw spi_cartdev2 
4a5c 6a ea		dw spi_clktime 
4a5e 66 ea		dw spi_device 
4a60 65 ea		dw spi_device_id 
4a62 67 ea		dw spi_portbyte 
4a64 ad eb		dw stackstore 
4a66			if STORAGE_SE 
4a66			dw storage_actl 
4a66			dw storage_adata 
4a66			else 
4a66 00 00		dw 0 
4a68 00 00		dw 0 
4a6a			endif 
4a6a			; 81 
4a6a 69 09		dw storage_append 
4a6c			if STORAGE_SE 
4a6c			dw storage_bctl 
4a6c			else 
4a6c 00 00		dw 0 
4a6e			endif 
4a6e 99 eb		dw store_bank_active 
4a70 6d ea		dw store_filecache 
4a72 7b ea		dw store_longread 
4a74 71 ea		dw store_openaddr 
4a76 70 ea		dw store_openext 
4a78 6f ea		dw store_openmaxext 
4a7a 80 ea		dw store_page 
4a7c 7c ea		dw store_readbuf 
4a7e			; 91 
4a7e 73 ea		dw store_readcont 
4a80 7e ea		dw store_readptr 
4a82 73 ea		dw store_tmpext 
4a84 74 ea		dw store_tmpid 
4a86 6b ea		dw store_tmppageid 
4a88			 
4a88			 
4a88			.ENDCONST: 
4a88			 
4a88			; eof 
4a88			 
4a88			 
# End of file forth_words_const.asm
4a88			 
4a88			if STORAGE_SE 
4a88			   	include "forth_words_storage.asm" 
4a88			endif 
4a88				include "forth_words_device.asm" 
4a88			; Device related words 
4a88			 
4a88			; | ## Device Words 
4a88			 
4a88			;if SOUND_ENABLE 
4a88			;.NOTE: 
4a88			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a88			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a88			;		if DEBUG_FORTH_WORDS_KEY 
4a88			;			DMARK "NTE" 
4a88			;			CALLMONITOR 
4a88			;		endif 
4a88			; 
4a88			;	 
4a88			; 
4a88			;		NEXTW 
4a88			;.AFTERSOUND: 
4a88			;endif 
4a88			 
4a88			 
4a88			USE_GPIO: equ 0 
4a88			 
4a88			if USE_GPIO 
4a88			.GP1: 
4a88				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a88			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a88					NEXTW 
4a88			.GP2: 
4a88				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a88			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a88			 
4a88					NEXTW 
4a88			 
4a88			.GP3: 
4a88				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a88			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a88			 
4a88					NEXTW 
4a88			 
4a88			.GP4: 
4a88				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a88			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a88			 
4a88					NEXTW 
4a88			.SIN: 
4a88			 
4a88			 
4a88			endif 
4a88			 
4a88			 
4a88				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a88 33				db WORD_SYS_CORE+31             
4a89 bd 4a			dw .SOUT            
4a8b 03				db 2 + 1 
4a8c .. 00			db "IN",0              
4a8f				endm 
# End of macro CWHEAD
4a8f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a8f					if DEBUG_FORTH_WORDS_KEY 
4a8f						DMARK "IN." 
4a8f f5				push af  
4a90 3a a4 4a			ld a, (.dmark)  
4a93 32 71 ee			ld (debug_mark),a  
4a96 3a a5 4a			ld a, (.dmark+1)  
4a99 32 72 ee			ld (debug_mark+1),a  
4a9c 3a a6 4a			ld a, (.dmark+2)  
4a9f 32 73 ee			ld (debug_mark+2),a  
4aa2 18 03			jr .pastdmark  
4aa4 ..			.dmark: db "IN."  
4aa7 f1			.pastdmark: pop af  
4aa8			endm  
# End of macro DMARK
4aa8						CALLMONITOR 
4aa8 cd e8 15			call break_point_state  
4aab				endm  
# End of macro CALLMONITOR
4aab					endif 
4aab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aab cd 7d 1e			call macro_dsp_valuehl 
4aae				endm 
# End of macro FORTH_DSP_VALUEHL
4aae			 
4aae e5					push hl 
4aaf			 
4aaf					; destroy value TOS 
4aaf			 
4aaf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aaf cd 35 1f			call macro_forth_dsp_pop 
4ab2				endm 
# End of macro FORTH_DSP_POP
4ab2			 
4ab2					; one value on hl get other one back 
4ab2			 
4ab2 c1					pop bc 
4ab3			 
4ab3					; do the sub 
4ab3			;		ex de, hl 
4ab3			 
4ab3 ed 68				in l,(c) 
4ab5			 
4ab5					; save it 
4ab5			 
4ab5 26 00				ld h,0 
4ab7			 
4ab7					; TODO push value back onto stack for another op etc 
4ab7			 
4ab7 cd 86 1c				call forth_push_numhl 
4aba					NEXTW 
4aba c3 33 20			jp macro_next 
4abd				endm 
# End of macro NEXTW
4abd			.SOUT: 
4abd				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4abd 34				db WORD_SYS_CORE+32             
4abe 10 4b			dw .SPIO            
4ac0 04				db 3 + 1 
4ac1 .. 00			db "OUT",0              
4ac5				endm 
# End of macro CWHEAD
4ac5			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ac5					if DEBUG_FORTH_WORDS_KEY 
4ac5						DMARK "OUT" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 71 ee			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 72 ee			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 73 ee			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "OUT"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd e8 15			call break_point_state  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1			 
4ae1					; get port 
4ae1			 
4ae1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae1 cd 7d 1e			call macro_dsp_valuehl 
4ae4				endm 
# End of macro FORTH_DSP_VALUEHL
4ae4			 
4ae4 e5					push hl 
4ae5			 
4ae5					; destroy value TOS 
4ae5			 
4ae5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae5 cd 35 1f			call macro_forth_dsp_pop 
4ae8				endm 
# End of macro FORTH_DSP_POP
4ae8			 
4ae8					; get byte to send 
4ae8			 
4ae8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae8 cd 7d 1e			call macro_dsp_valuehl 
4aeb				endm 
# End of macro FORTH_DSP_VALUEHL
4aeb			 
4aeb			;		push hl 
4aeb			 
4aeb					; destroy value TOS 
4aeb			 
4aeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aeb cd 35 1f			call macro_forth_dsp_pop 
4aee				endm 
# End of macro FORTH_DSP_POP
4aee			 
4aee					; one value on hl get other one back 
4aee			 
4aee			;		pop hl 
4aee			 
4aee c1					pop bc 
4aef			 
4aef					if DEBUG_FORTH_WORDS 
4aef						DMARK "OUT" 
4aef f5				push af  
4af0 3a 04 4b			ld a, (.dmark)  
4af3 32 71 ee			ld (debug_mark),a  
4af6 3a 05 4b			ld a, (.dmark+1)  
4af9 32 72 ee			ld (debug_mark+1),a  
4afc 3a 06 4b			ld a, (.dmark+2)  
4aff 32 73 ee			ld (debug_mark+2),a  
4b02 18 03			jr .pastdmark  
4b04 ..			.dmark: db "OUT"  
4b07 f1			.pastdmark: pop af  
4b08			endm  
# End of macro DMARK
4b08						CALLMONITOR 
4b08 cd e8 15			call break_point_state  
4b0b				endm  
# End of macro CALLMONITOR
4b0b					endif 
4b0b			 
4b0b ed 69				out (c), l 
4b0d			 
4b0d					NEXTW 
4b0d c3 33 20			jp macro_next 
4b10				endm 
# End of macro NEXTW
4b10			 
4b10			 
4b10			.SPIO: 
4b10			 
4b10			if STORAGE_SE 
4b10				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b10			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b10			 
4b10					call spi_ce_low 
4b10			    NEXTW 
4b10			 
4b10			.SPICEH: 
4b10				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b10			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b10			 
4b10					call spi_ce_high 
4b10			    NEXTW 
4b10			 
4b10			 
4b10			.SPIOb: 
4b10			 
4b10				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b10			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b10			 
4b10					if DEBUG_FORTH_WORDS_KEY 
4b10						DMARK "SPo" 
4b10						CALLMONITOR 
4b10					endif 
4b10					; get port 
4b10			 
4b10			 
4b10					; get byte to send 
4b10			 
4b10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b10			 
4b10			;		push hl    ; u1  
4b10			 
4b10					; destroy value TOS 
4b10			 
4b10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b10			 
4b10					; one value on hl get other one back 
4b10			 
4b10			;		pop hl   ; u2 - addr 
4b10			 
4b10					; TODO Send SPI byte 
4b10			 
4b10			;		push hl 
4b10			;		call spi_ce_low 
4b10			;		pop hl 
4b10					ld a, l 
4b10					call spi_send_byte 
4b10			;		call spi_ce_high 
4b10			 
4b10					NEXTW 
4b10			 
4b10			.SPII: 
4b10				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b10			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b10					if DEBUG_FORTH_WORDS_KEY 
4b10						DMARK "SPi" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					; TODO Get SPI byte 
4b10			 
4b10					call spi_read_byte 
4b10			 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "Si2" 
4b10						CALLMONITOR 
4b10					endif 
4b10					ld h, 0 
4b10					ld l, a 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "Si3" 
4b10						CALLMONITOR 
4b10					endif 
4b10					call forth_push_numhl 
4b10			 
4b10					NEXTW 
4b10			 
4b10			 
4b10			 
4b10			.SESEL: 
4b10				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b10			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b10					if DEBUG_FORTH_WORDS_KEY 
4b10						DMARK "BNK" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					ld a, 255 
4b10					ld (spi_cartdev), a 
4b10			 
4b10					; get bank 
4b10			 
4b10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b10			 
4b10			;		push hl 
4b10			 
4b10					; destroy value TOS 
4b10			 
4b10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b10			 
4b10					; one value on hl get other one back 
4b10			 
4b10			;		pop hl 
4b10			 
4b10			 
4b10					ld c, SPI_CE_HIGH 
4b10					ld b, '0'    ; human readable bank number 
4b10			 
4b10					ld a, l 
4b10			 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "BNK" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					; active low 
4b10			 
4b10					cp 0 
4b10					jr z, .bset 
4b10					cp 1 
4b10					jr nz, .b2 
4b10					res 0, c 
4b10					ld b, '1'    ; human readable bank number 
4b10			.b2:		cp 2 
4b10					jr nz, .b3 
4b10					res 1, c 
4b10					ld b, '2'    ; human readable bank number 
4b10			.b3:		cp 3 
4b10					jr nz, .b4 
4b10					res 2, c 
4b10					ld b, '3'    ; human readable bank number 
4b10			.b4:		cp 4 
4b10					jr nz, .b5 
4b10					res 3, c 
4b10					ld b, '4'    ; human readable bank number 
4b10			.b5:		cp 5 
4b10					jr nz, .bset 
4b10					res 4, c 
4b10					ld b, '5'    ; human readable bank number 
4b10			 
4b10			.bset: 
4b10					ld a, c 
4b10					ld (spi_device),a 
4b10					ld a, b 
4b10					ld (spi_device_id),a 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "BN2" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					; set default SPI clk pulse time as disabled for BANK use 
4b10			 
4b10					ld a, 0 
4b10					ld (spi_clktime), a 
4b10			 
4b10					NEXTW 
4b10			 
4b10			.CARTDEV: 
4b10				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b10			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b10					if DEBUG_FORTH_WORDS_KEY 
4b10						DMARK "CDV" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					; disable se storage bank selection 
4b10			 
4b10					ld a, SPI_CE_HIGH		; ce high 
4b10					ld (spi_device), a 
4b10			 
4b10					; get bank 
4b10			 
4b10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b10			 
4b10			;		push hl 
4b10			 
4b10					; destroy value TOS 
4b10			 
4b10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b10			 
4b10					; one value on hl get other one back 
4b10			 
4b10			;		pop hl 
4b10			 
4b10					; active low 
4b10			 
4b10					ld c, 255 
4b10			 
4b10					ld a, l 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "CDV" 
4b10						CALLMONITOR 
4b10					endif 
4b10					cp 0 
4b10					jr z, .cset 
4b10					cp 1 
4b10					jr nz, .c2 
4b10					res 0, c 
4b10			.c2:		cp 2 
4b10					jr nz, .c3 
4b10					res 1, c 
4b10			.c3:		cp 3 
4b10					jr nz, .c4 
4b10					res 2, c 
4b10			.c4:		cp 4 
4b10					jr nz, .c5 
4b10					res 3, c 
4b10			.c5:		cp 5 
4b10					jr nz, .c6 
4b10					res 4, c 
4b10			.c6:		cp 6 
4b10					jr nz, .c7 
4b10					res 5, c 
4b10			.c7:		cp 7 
4b10					jr nz, .c8 
4b10					res 6, c 
4b10			.c8:		cp 8 
4b10					jr nz, .cset 
4b10					res 7, c 
4b10			.cset:		ld a, c 
4b10					ld (spi_cartdev),a 
4b10			 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "CD2" 
4b10						CALLMONITOR 
4b10					endif 
4b10			 
4b10					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b10			 
4b10					ld a, $0a 
4b10					ld (spi_clktime), a 
4b10					NEXTW 
4b10			endif 
4b10			 
4b10			.ENDDEVICE: 
4b10			; eof 
4b10			 
# End of file forth_words_device.asm
4b10			 
4b10			; var handler 
4b10			 
4b10			 
4b10			.VARS: 
4b10				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b10 77				db WORD_SYS_CORE+99             
4b11 c1 4b			dw .V0            
4b13 04				db 3 + 1 
4b14 .. 00			db "VAR",0              
4b18				endm 
# End of macro CWHEAD
4b18			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b18			;| 
4b18			;| The variable name should consist of a single letter. e.g. "a" 
4b18			;! If a full string is passed then only the first char is looked at 
4b18			;| Any other char could exceed bounds checks!  
4b18			 
4b18					if DEBUG_FORTH_WORDS_KEY 
4b18						DMARK "VAR" 
4b18 f5				push af  
4b19 3a 2d 4b			ld a, (.dmark)  
4b1c 32 71 ee			ld (debug_mark),a  
4b1f 3a 2e 4b			ld a, (.dmark+1)  
4b22 32 72 ee			ld (debug_mark+1),a  
4b25 3a 2f 4b			ld a, (.dmark+2)  
4b28 32 73 ee			ld (debug_mark+2),a  
4b2b 18 03			jr .pastdmark  
4b2d ..			.dmark: db "VAR"  
4b30 f1			.pastdmark: pop af  
4b31			endm  
# End of macro DMARK
4b31						CALLMONITOR 
4b31 cd e8 15			call break_point_state  
4b34				endm  
# End of macro CALLMONITOR
4b34					endif 
4b34			 
4b34					FORTH_DSP_VALUEHL 
4b34 cd 7d 1e			call macro_dsp_valuehl 
4b37				endm 
# End of macro FORTH_DSP_VALUEHL
4b37			 
4b37 7e					ld a, (hl)    ; get first char on of the string 
4b38			 
4b38			 
4b38					if DEBUG_FORTH_WORDS 
4b38						DMARK "VR1" 
4b38 f5				push af  
4b39 3a 4d 4b			ld a, (.dmark)  
4b3c 32 71 ee			ld (debug_mark),a  
4b3f 3a 4e 4b			ld a, (.dmark+1)  
4b42 32 72 ee			ld (debug_mark+1),a  
4b45 3a 4f 4b			ld a, (.dmark+2)  
4b48 32 73 ee			ld (debug_mark+2),a  
4b4b 18 03			jr .pastdmark  
4b4d ..			.dmark: db "VR1"  
4b50 f1			.pastdmark: pop af  
4b51			endm  
# End of macro DMARK
4b51						CALLMONITOR 
4b51 cd e8 15			call break_point_state  
4b54				endm  
# End of macro CALLMONITOR
4b54					endif 
4b54					 
4b54 f5					push af	 
4b55					FORTH_DSP_POP 
4b55 cd 35 1f			call macro_forth_dsp_pop 
4b58				endm 
# End of macro FORTH_DSP_POP
4b58 f1					pop af 
4b59			 
4b59					; convert to upper 
4b59			 
4b59 cd 54 11				call to_upper 
4b5c					if DEBUG_FORTH_WORDS 
4b5c						DMARK "Vaa" 
4b5c f5				push af  
4b5d 3a 71 4b			ld a, (.dmark)  
4b60 32 71 ee			ld (debug_mark),a  
4b63 3a 72 4b			ld a, (.dmark+1)  
4b66 32 72 ee			ld (debug_mark+1),a  
4b69 3a 73 4b			ld a, (.dmark+2)  
4b6c 32 73 ee			ld (debug_mark+2),a  
4b6f 18 03			jr .pastdmark  
4b71 ..			.dmark: db "Vaa"  
4b74 f1			.pastdmark: pop af  
4b75			endm  
# End of macro DMARK
4b75						CALLMONITOR 
4b75 cd e8 15			call break_point_state  
4b78				endm  
# End of macro CALLMONITOR
4b78					endif 
4b78 06 41				ld b, 'A' 
4b7a 90					sub b			; set offset 
4b7b					if DEBUG_FORTH_WORDS 
4b7b						DMARK "Vbb" 
4b7b f5				push af  
4b7c 3a 90 4b			ld a, (.dmark)  
4b7f 32 71 ee			ld (debug_mark),a  
4b82 3a 91 4b			ld a, (.dmark+1)  
4b85 32 72 ee			ld (debug_mark+1),a  
4b88 3a 92 4b			ld a, (.dmark+2)  
4b8b 32 73 ee			ld (debug_mark+2),a  
4b8e 18 03			jr .pastdmark  
4b90 ..			.dmark: db "Vbb"  
4b93 f1			.pastdmark: pop af  
4b94			endm  
# End of macro DMARK
4b94						CALLMONITOR 
4b94 cd e8 15			call break_point_state  
4b97				endm  
# End of macro CALLMONITOR
4b97					endif 
4b97 cb 27				sla a  
4b99				 
4b99					 
4b99					if DEBUG_FORTH_WORDS 
4b99						DMARK "VR2" 
4b99 f5				push af  
4b9a 3a ae 4b			ld a, (.dmark)  
4b9d 32 71 ee			ld (debug_mark),a  
4ba0 3a af 4b			ld a, (.dmark+1)  
4ba3 32 72 ee			ld (debug_mark+1),a  
4ba6 3a b0 4b			ld a, (.dmark+2)  
4ba9 32 73 ee			ld (debug_mark+2),a  
4bac 18 03			jr .pastdmark  
4bae ..			.dmark: db "VR2"  
4bb1 f1			.pastdmark: pop af  
4bb2			endm  
# End of macro DMARK
4bb2						CALLMONITOR 
4bb2 cd e8 15			call break_point_state  
4bb5				endm  
# End of macro CALLMONITOR
4bb5					endif 
4bb5			 
4bb5 21 fa e9				ld hl, cli_var_array2 
4bb8 cd e7 0d				call addatohl 
4bbb cd 86 1c				call forth_push_numhl 
4bbe			 
4bbe			 
4bbe				       NEXTW 
4bbe c3 33 20			jp macro_next 
4bc1				endm 
# End of macro NEXTW
4bc1			.V0: 
4bc1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bc1 78				db WORD_SYS_CORE+100             
4bc2 d9 4b			dw .V0Q            
4bc4 04				db 3 + 1 
4bc5 .. 00			db "V0!",0              
4bc9				endm 
# End of macro CWHEAD
4bc9			;| V0! ( u1 -- )  Store value to v0  | DONE 
4bc9			 
4bc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc9 cd 7d 1e			call macro_dsp_valuehl 
4bcc				endm 
# End of macro FORTH_DSP_VALUEHL
4bcc			 
4bcc 11 2e ea				ld de, cli_var_array 
4bcf			 
4bcf eb					ex de, hl 
4bd0 73					ld (hl), e 
4bd1 23					inc hl 
4bd2 72					ld (hl), d 
4bd3			 
4bd3					; destroy value TOS 
4bd3			 
4bd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd3 cd 35 1f			call macro_forth_dsp_pop 
4bd6				endm 
# End of macro FORTH_DSP_POP
4bd6			 
4bd6				       NEXTW 
4bd6 c3 33 20			jp macro_next 
4bd9				endm 
# End of macro NEXTW
4bd9			.V0Q: 
4bd9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bd9 79				db WORD_SYS_CORE+101             
4bda ea 4b			dw .V1S            
4bdc 04				db 3 + 1 
4bdd .. 00			db "V0@",0              
4be1				endm 
# End of macro CWHEAD
4be1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4be1 2a 2e ea				ld hl, (cli_var_array) 
4be4 cd 86 1c				call forth_push_numhl 
4be7			 
4be7				       NEXTW 
4be7 c3 33 20			jp macro_next 
4bea				endm 
# End of macro NEXTW
4bea			.V1S: 
4bea				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bea 7a				db WORD_SYS_CORE+102             
4beb 02 4c			dw .V1Q            
4bed 04				db 3 + 1 
4bee .. 00			db "V1!",0              
4bf2				endm 
# End of macro CWHEAD
4bf2			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bf2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf2 cd 7d 1e			call macro_dsp_valuehl 
4bf5				endm 
# End of macro FORTH_DSP_VALUEHL
4bf5			 
4bf5 11 30 ea				ld de, cli_var_array+2 
4bf8				 
4bf8 eb					ex de, hl 
4bf9 73					ld (hl), e 
4bfa 23					inc hl 
4bfb 72					ld (hl), d 
4bfc			 
4bfc					; destroy value TOS 
4bfc			 
4bfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bfc cd 35 1f			call macro_forth_dsp_pop 
4bff				endm 
# End of macro FORTH_DSP_POP
4bff				       NEXTW 
4bff c3 33 20			jp macro_next 
4c02				endm 
# End of macro NEXTW
4c02			.V1Q: 
4c02				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c02 7b				db WORD_SYS_CORE+103             
4c03 13 4c			dw .V2S            
4c05 04				db 3 + 1 
4c06 .. 00			db "V1@",0              
4c0a				endm 
# End of macro CWHEAD
4c0a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c0a 2a 30 ea				ld hl, (cli_var_array+2) 
4c0d cd 86 1c				call forth_push_numhl 
4c10				       NEXTW 
4c10 c3 33 20			jp macro_next 
4c13				endm 
# End of macro NEXTW
4c13			.V2S: 
4c13				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c13 7c				db WORD_SYS_CORE+104             
4c14 2b 4c			dw .V2Q            
4c16 04				db 3 + 1 
4c17 .. 00			db "V2!",0              
4c1b				endm 
# End of macro CWHEAD
4c1b			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c1b cd 7d 1e			call macro_dsp_valuehl 
4c1e				endm 
# End of macro FORTH_DSP_VALUEHL
4c1e			 
4c1e 11 32 ea				ld de, cli_var_array+4 
4c21				 
4c21 eb					ex de, hl 
4c22 73					ld (hl), e 
4c23 23					inc hl 
4c24 72					ld (hl), d 
4c25			 
4c25					; destroy value TOS 
4c25			 
4c25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c25 cd 35 1f			call macro_forth_dsp_pop 
4c28				endm 
# End of macro FORTH_DSP_POP
4c28				       NEXTW 
4c28 c3 33 20			jp macro_next 
4c2b				endm 
# End of macro NEXTW
4c2b			.V2Q: 
4c2b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c2b 7d				db WORD_SYS_CORE+105             
4c2c 3c 4c			dw .V3S            
4c2e 04				db 3 + 1 
4c2f .. 00			db "V2@",0              
4c33				endm 
# End of macro CWHEAD
4c33			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c33 2a 32 ea				ld hl, (cli_var_array+4) 
4c36 cd 86 1c				call forth_push_numhl 
4c39				       NEXTW 
4c39 c3 33 20			jp macro_next 
4c3c				endm 
# End of macro NEXTW
4c3c			.V3S: 
4c3c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c3c 7c				db WORD_SYS_CORE+104             
4c3d 54 4c			dw .V3Q            
4c3f 04				db 3 + 1 
4c40 .. 00			db "V3!",0              
4c44				endm 
# End of macro CWHEAD
4c44			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c44 cd 7d 1e			call macro_dsp_valuehl 
4c47				endm 
# End of macro FORTH_DSP_VALUEHL
4c47			 
4c47 11 34 ea				ld de, cli_var_array+6 
4c4a				 
4c4a eb					ex de, hl 
4c4b 73					ld (hl), e 
4c4c 23					inc hl 
4c4d 72					ld (hl), d 
4c4e			 
4c4e					; destroy value TOS 
4c4e			 
4c4e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c4e cd 35 1f			call macro_forth_dsp_pop 
4c51				endm 
# End of macro FORTH_DSP_POP
4c51				       NEXTW 
4c51 c3 33 20			jp macro_next 
4c54				endm 
# End of macro NEXTW
4c54			.V3Q: 
4c54				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c54 7d				db WORD_SYS_CORE+105             
4c55 65 4c			dw .END            
4c57 04				db 3 + 1 
4c58 .. 00			db "V3@",0              
4c5c				endm 
# End of macro CWHEAD
4c5c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c5c 2a 34 ea				ld hl, (cli_var_array+6) 
4c5f cd 86 1c				call forth_push_numhl 
4c62				       NEXTW 
4c62 c3 33 20			jp macro_next 
4c65				endm 
# End of macro NEXTW
4c65			 
4c65			 
4c65			 
4c65			 
4c65			 
4c65			; end of dict marker 
4c65			 
4c65 00			.END:    db WORD_SYS_END 
4c66 00 00			dw 0 
4c68 00				db 0 
4c69			 
4c69			; use to jp here for user dict words to save on macro expansion  
4c69			 
4c69			user_dict_next: 
4c69				NEXTW 
4c69 c3 33 20			jp macro_next 
4c6c				endm 
# End of macro NEXTW
4c6c			 
4c6c			 
4c6c			user_exec: 
4c6c				;    ld hl, <word code> 
4c6c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c6c				;    call forthexec 
4c6c				;    jp user_dict_next   (NEXT) 
4c6c			        ;    <word code bytes> 
4c6c eb				ex de, hl 
4c6d 2a c8 e5			ld hl,(os_tok_ptr) 
4c70				 
4c70				FORTH_RSP_NEXT 
4c70 cd 2d 1c			call macro_forth_rsp_next 
4c73				endm 
# End of macro FORTH_RSP_NEXT
4c73			 
4c73			if DEBUG_FORTH_UWORD 
4c73						DMARK "UEX" 
4c73 f5				push af  
4c74 3a 88 4c			ld a, (.dmark)  
4c77 32 71 ee			ld (debug_mark),a  
4c7a 3a 89 4c			ld a, (.dmark+1)  
4c7d 32 72 ee			ld (debug_mark+1),a  
4c80 3a 8a 4c			ld a, (.dmark+2)  
4c83 32 73 ee			ld (debug_mark+2),a  
4c86 18 03			jr .pastdmark  
4c88 ..			.dmark: db "UEX"  
4c8b f1			.pastdmark: pop af  
4c8c			endm  
# End of macro DMARK
4c8c				CALLMONITOR 
4c8c cd e8 15			call break_point_state  
4c8f				endm  
# End of macro CALLMONITOR
4c8f			endif 
4c8f			 
4c8f			 
4c8f			 
4c8f eb				ex de, hl 
4c90 22 c8 e5			ld (os_tok_ptr), hl 
4c93				 
4c93				; Don't use next - Skips the first word in uword. 
4c93			 
4c93 c3 c4 20			jp exec1 
4c96			;	NEXT 
4c96			 
4c96			 
4c96			; eof 
# End of file forth_wordsv4.asm
4c96			endif 
4c96			;;;;;;;;;;;;;; Debug code 
4c96			 
4c96			 
4c96			;if DEBUG_FORTH_PARSE 
4c96 .. 00		.nowordfound: db "No match",0 
4c9f .. 00		.compword:	db "Comparing word ",0 
4caf .. 00		.nextwordat:	db "Next word at",0 
4cbc .. 00		.charmatch:	db "Char match",0 
4cc7			;endif 
4cc7			if DEBUG_FORTH_JP 
4cc7			.foundword:	db "Word match. Exec..",0 
4cc7			endif 
4cc7			;if DEBUG_FORTH_PUSH 
4cc7 .. 00		.enddict:	db "Dict end. Push.",0 
4cd7 .. 00		.push_str:	db "Pushing string",0 
4ce6 .. 00		.push_num:	db "Pushing number",0 
4cf5 .. 00		.data_sp:	db "SP:",0 
4cf9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d0b .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d1d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d2f			;endif 
4d2f			;if DEBUG_FORTH_MALLOC 
4d2f .. 00		.push_malloc:	db "Malloc address",0 
4d3e			;endif 
4d3e			 
4d3e			 
4d3e			 
4d3e			; display malloc address and current data stack pointer  
4d3e			 
4d3e			malloc_error: 
4d3e d5				push de 
4d3f f5				push af 
4d40 e5				push hl 
4d41 cd ba 0b			call clear_display 
4d44 11 66 4d			ld de, .mallocerr 
4d47 3e 00			ld a,0 
4d49			;	ld de,os_word_scratch 
4d49 cd cd 0b			call str_at_display 
4d4c 3e 11			ld a, display_row_1+17 
4d4e 11 71 ee			ld de, debug_mark 
4d51 cd cd 0b			call str_at_display 
4d54 cd dd 0b			call update_display 
4d57				;call break_point_state 
4d57 cd bf 64			call cin_wait 
4d5a			 
4d5a 3e 20			ld a, ' ' 
4d5c 32 b8 e2			ld (os_view_disable), a 
4d5f e1				pop hl 
4d60 f1				pop af 
4d61 d1				pop de	 
4d62				CALLMONITOR 
4d62 cd e8 15			call break_point_state  
4d65				endm  
# End of macro CALLMONITOR
4d65 c9				ret 
4d66			 
4d66 .. 00		.mallocerr: 	db "Malloc Error",0 
4d73			;if DEBUG_FORTH_PUSH 
4d73			display_data_sp: 
4d73 f5				push af 
4d74			 
4d74				; see if disabled 
4d74			 
4d74 3a b8 e2			ld a, (os_view_disable) 
4d77 fe 2a			cp '*' 
4d79 28 67			jr z, .skipdsp 
4d7b			 
4d7b e5				push hl 
4d7c e5				push hl 
4d7d e5			push hl 
4d7e cd ba 0b			call clear_display 
4d81 e1			pop hl 
4d82 7c				ld a,h 
4d83 21 cc e5			ld hl, os_word_scratch 
4d86 cd e8 10			call hexout 
4d89 e1				pop hl 
4d8a 7d				ld a,l 
4d8b 21 ce e5			ld hl, os_word_scratch+2 
4d8e cd e8 10			call hexout 
4d91 21 d0 e5			ld hl, os_word_scratch+4 
4d94 3e 00			ld a,0 
4d96 77				ld (hl),a 
4d97 11 cc e5			ld de,os_word_scratch 
4d9a 3e 28				ld a, display_row_2 
4d9c cd cd 0b				call str_at_display 
4d9f 11 f9 4c			ld de, .wordinhl 
4da2 3e 00			ld a, display_row_1 
4da4			 
4da4 cd cd 0b				call str_at_display 
4da7 11 71 ee			ld de, debug_mark 
4daa 3e 11			ld a, display_row_1+17 
4dac			 
4dac cd cd 0b				call str_at_display 
4daf			 
4daf				; display current data stack pointer 
4daf 11 f5 4c			ld de,.data_sp 
4db2 3e 30				ld a, display_row_2 + 8 
4db4 cd cd 0b				call str_at_display 
4db7			 
4db7 2a f4 e9			ld hl,(cli_data_sp) 
4dba e5				push hl 
4dbb 7c				ld a,h 
4dbc 21 cc e5			ld hl, os_word_scratch 
4dbf cd e8 10			call hexout 
4dc2 e1				pop hl 
4dc3 7d				ld a,l 
4dc4 21 ce e5			ld hl, os_word_scratch+2 
4dc7 cd e8 10			call hexout 
4dca 21 d0 e5			ld hl, os_word_scratch+4 
4dcd 3e 00			ld a,0 
4dcf 77				ld (hl),a 
4dd0 11 cc e5			ld de,os_word_scratch 
4dd3 3e 33				ld a, display_row_2 + 11 
4dd5 cd cd 0b				call str_at_display 
4dd8			 
4dd8			 
4dd8 cd dd 0b			call update_display 
4ddb cd f2 0a			call delay1s 
4dde cd f2 0a			call delay1s 
4de1 e1				pop hl 
4de2			.skipdsp: 
4de2 f1				pop af 
4de3 c9				ret 
4de4			 
4de4			display_data_malloc: 
4de4			 
4de4 f5				push af 
4de5 e5				push hl 
4de6 e5				push hl 
4de7 e5			push hl 
4de8 cd ba 0b			call clear_display 
4deb e1			pop hl 
4dec 7c				ld a,h 
4ded 21 cc e5			ld hl, os_word_scratch 
4df0 cd e8 10			call hexout 
4df3 e1				pop hl 
4df4 7d				ld a,l 
4df5 21 ce e5			ld hl, os_word_scratch+2 
4df8 cd e8 10			call hexout 
4dfb 21 d0 e5			ld hl, os_word_scratch+4 
4dfe 3e 00			ld a,0 
4e00 77				ld (hl),a 
4e01 11 cc e5			ld de,os_word_scratch 
4e04 3e 28				ld a, display_row_2 
4e06 cd cd 0b				call str_at_display 
4e09 11 2f 4d			ld de, .push_malloc 
4e0c 3e 00			ld a, display_row_1 
4e0e			 
4e0e cd cd 0b				call str_at_display 
4e11			 
4e11				; display current data stack pointer 
4e11 11 f5 4c			ld de,.data_sp 
4e14 3e 30				ld a, display_row_2 + 8 
4e16 cd cd 0b				call str_at_display 
4e19			 
4e19 2a f4 e9			ld hl,(cli_data_sp) 
4e1c e5				push hl 
4e1d 7c				ld a,h 
4e1e 21 cc e5			ld hl, os_word_scratch 
4e21 cd e8 10			call hexout 
4e24 e1				pop hl 
4e25 7d				ld a,l 
4e26 21 ce e5			ld hl, os_word_scratch+2 
4e29 cd e8 10			call hexout 
4e2c 21 d0 e5			ld hl, os_word_scratch+4 
4e2f 3e 00			ld a,0 
4e31 77				ld (hl),a 
4e32 11 cc e5			ld de,os_word_scratch 
4e35 3e 33				ld a, display_row_2 + 11 
4e37 cd cd 0b				call str_at_display 
4e3a			 
4e3a cd dd 0b			call update_display 
4e3d cd f2 0a			call delay1s 
4e40 cd f2 0a			call delay1s 
4e43 e1				pop hl 
4e44 f1				pop af 
4e45 c9				ret 
4e46			;endif 
4e46			 
4e46			include "forth_autostart.asm" 
4e46			; list of commands to perform at system start up 
4e46			 
4e46			startcmds: 
4e46			;	dw test11 
4e46			;	dw test12 
4e46			;	dw test13 
4e46			;	dw test14 
4e46			;	dw test15 
4e46			;	dw test16 
4e46			;	dw test17 
4e46			;	dw ifthtest1 
4e46			;	dw ifthtest2 
4e46			;	dw ifthtest3 
4e46			;	dw mmtest1 
4e46			;	dw mmtest2 
4e46			;	dw mmtest3 
4e46			;	dw mmtest4 
4e46			;	dw mmtest5 
4e46			;	dw mmtest6 
4e46			;	dw iftest1 
4e46			;	dw iftest2 
4e46			;	dw iftest3 
4e46			;	dw looptest1 
4e46			;	dw looptest2 
4e46			;	dw test1 
4e46			;	dw test2 
4e46			;	dw test3 
4e46			;	dw test4 
4e46			;	dw game2r 
4e46			;	dw game2b1 
4e46			;	dw game2b2 
4e46			 
4e46				; start up words that are actually useful 
4e46			 
4e46 4e 4f		    dw spi1 
4e48 a7 4f		    dw spi2 
4e4a 35 50		    dw spi3 
4e4c dd 4f		    dw spi4 
4e4e 08 50		    dw spi5 
4e50 9b 50		    dw spi6 
4e52 f0 50		    dw spi7 
4e54			 
4e54 48 51		    dw spi8 
4e56 67 51		    dw spi9 
4e58 bf 51		    dw spi10 
4e5a			 
4e5a			; file editor 
4e5a c0 4e			dw edit1 
4e5c e1 4e			dw edit2 
4e5e 16 4f			dw edit3 
4e60			 
4e60 32 52			dw longread 
4e62 79 52			dw clrstack 
4e64 ac 52			dw type 
4e66 97 54			dw stest 
4e68 d0 52			dw strncpy 
4e6a 2d 54			dw list 
4e6c 31 53			dw start1 
4e6e 41 53			dw start2 
4e70			;	dw start3 
4e70 52 53			dw start3b 
4e72 cd 53			dw start3c 
4e74			 
4e74				; (unit) testing words 
4e74			 
4e74 0e 55			dw mtesta 
4e76 c3 55			dw mtestb 
4e78 66 56			dw mtestc 
4e7a 1b 57			dw mtestd 
4e7c bf 57			dw mteste 
4e7e			 
4e7e				; demo/game words 
4e7e			 
4e7e cb 5e		        dw game3w 
4e80 f9 5e		        dw game3p 
4e82 17 5f		        dw game3sc 
4e84 48 5f		        dw game3vsi 
4e86 74 5f		        dw game3vs 
4e88				 
4e88 be 5c			dw game2b 
4e8a 2c 5d			dw game2bf 
4e8c 76 5d			dw game2mba 
4e8e 0c 5e			dw game2mbas 
4e90 4e 5e			dw game2mb 
4e92			 
4e92 7f 59			dw game1 
4e94 90 59			dw game1a 
4e96 f2 59			dw game1b 
4e98 27 5a			dw game1c 
4e9a 5d 5a			dw game1d 
4e9c 8e 5a			dw game1s 
4e9e a2 5a			dw game1t 
4ea0 b7 5a			dw game1f 
4ea2 eb 5a			dw game1z 
4ea4 2f 5b			dw game1zz 
4ea6			 
4ea6 75 58			dw test5 
4ea8 ad 58			dw test6 
4eaa e5 58			dw test7 
4eac f9 58			dw test8 
4eae 25 59			dw test9 
4eb0 3b 59			dw test10 
4eb2				 
4eb2 06 5c		        dw ssv5 
4eb4 ea 5b		        dw ssv4 
4eb6 ce 5b		        dw ssv3 
4eb8 98 5b		        dw ssv2 
4eba 1f 5c		        dw ssv1 
4ebc 67 5c		        dw ssv1cpm 
4ebe			;	dw keyup 
4ebe			;	dw keydown 
4ebe			;	dw keyleft 
4ebe			;	dw keyright 
4ebe			;	dw 	keyf1 
4ebe			;	dw keyf2 
4ebe			;	dw keyf3 
4ebe			;	dw keyf4 
4ebe			;	dw keyf5 
4ebe			;	dw keyf6 
4ebe			;	dw keyf7 
4ebe			;	dw keyf8 
4ebe			;	dw keyf9 
4ebe			;	dw keyf10 
4ebe			;	dw keyf11 
4ebe			;	dw keyf12 
4ebe			;	dw keytab 
4ebe			;	dw keycr 
4ebe			;	dw keyhome 
4ebe			;	dw keyend 
4ebe			;	dw keybs 
4ebe 00 00			db 0, 0	 
4ec0			 
4ec0			 
4ec0			; File Editor 
4ec0			 
4ec0			; ( id - ) use 'e' to edit the displayed line 
4ec0 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4ee1 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f16			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f16 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f4e			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f4e			 
4f4e			; SPI Net support words 
4f4e			 
4f4e			; v0! = node to send to 
4f4e			; ( str count - ) 
4f4e .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4fa7			 
4fa7			; spiputchr ( char node - ) 
4fa7 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fdd			 
4fdd			; spigetchr ( - n ) 
4fdd .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5008			 
5008			; getnode ( - n ) 
5008 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5035			 
5035			; ( str node - )  
5035 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
509b			; store string ( str i - ) 
509b			 
509b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
509b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50f0			 
50f0			; get string ( addr i -  )    TO FIX 
50f0			 
50f0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5148			 
5148			 
5148			; NETCHAT (TODO) 
5148			; Program to allow two nodes to chat with eachother 
5148			; 
5148			; v0 - target node 
5148			;  
5148			; accept input at 0,0 
5148			; if input is string send spitype to target node 
5148			; starting at row 2,0 , while spigetchr is not zero ->  
5148			; 
5148			; 
5148			; TODO add paging of get request 
5148			 
5148			; ( node - ) 
5148 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5167 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
51bf .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5232			 
5232			 
5232			; Long read of currently open file 
5232 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5279			 
5279			; clear stack  
5279			 
5279 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
52ac			 
52ac			; type ( addr count - ) 
52ac .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
52d0			 
52d0			; some direct memory words 
52d0			; strncpy ( len t f -- t ) 
52d0			 
52d0 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5331			 
5331 .. 00		start1:     	db ": bpon $00 bp ;",0 
5341 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5352 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
53cd .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
542d			 
542d			 
542d			; a handy word to list items on the stack 
542d			 
542d .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5497			 
5497			 
5497			; test stack  
5497			; rnd8 stest 
5497			 
5497 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
550e			 
550e			; random malloc and free cycles 
550e			 
550e .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55c3			 
55c3			; fixed malloc and free cycles 
55c3			 
55c3 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5666			 
5666			; fixed double string push and drop cycle  
5666			 
5666 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
571b			 
571b			; consistent fixed string push and drop cycle  
571b			 
571b .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57bf			 
57bf .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5875			 
5875			;test1:		db ": aa 1 2 3 ;", 0 
5875			;test2:     	db "111 aa 888 999",0 
5875			;test3:     	db ": bb 77 ;",0 
5875			;test4:     	db "$02 $01 do i . loop bb",0 
5875			 
5875 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
58ad .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58e5 .. 00		test7:     	db ": box hline vline ;",0 
58f9 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5925 .. 00		test9:     	db ": sw $01 adsp world ;",0 
593b .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5960 .. 00		test11:     	db "hello create .",0 
596f .. 00		test12:     	db "hello2 create .",0 
597f			 
597f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
597f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
597f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
597f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
597f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
597f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
597f			 
597f			;iftest1:     	db "$0001 IF cls .",0 
597f			;iftest2:     	db "$0000 IF cls .",0 
597f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
597f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
597f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
597f			 
597f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597f			 
597f			 
597f			 
597f			; a small guess the number game 
597f			 
597f .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5990 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
59f2			 
59f2 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a27 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a5d .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5a8e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5aa2 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5ab7 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5aeb .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b2f			 
5b2f			; Using 'ga' save a high score across multiple runs using external storage 
5b2f			 
5b2f .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5b98			 
5b98			 
5b98			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5b98			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b98			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b98			 
5b98			; simple screen saver to test code memory reuse to destruction 
5b98			 
5b98 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5bce .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5bea .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c06 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c1f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c67 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5cbe			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cbe			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5cbe			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5cbe			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5cbe			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5cbe			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5cbe			 
5cbe			 
5cbe			 
5cbe			; minesweeper/battleship finding game 
5cbe			; draws a game board of random ship/mine positions 
5cbe			; user enters coords to see if it hits on 
5cbe			; game ends when all are hit 
5cbe			; when hit or miss says how many may be in the area 
5cbe			 
5cbe			; setup the game board and then hide it 
5cbe .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d2c .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5d76			; prompt for where to target 
5d76 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e0c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e31			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e31 .. 00		game2mbht:      db ": mbckht nop ;",0 
5e40 .. 00		game2mbms:      db ": mbcms nop ;",0 
5e4e			; TODO how many might be near by 
5e4e .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ecb			 
5ecb			; Game 3 
5ecb			 
5ecb			; Vert scroller ski game - avoid the trees! 
5ecb			 
5ecb			; v0 score (ie turns) 
5ecb			; v1 player pos 
5ecb			; v2 left wall 
5ecb			; v3 right wall 
5ecb			 
5ecb			; Draw side walls randomly 
5ecb			 
5ecb .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5ef9			 
5ef9			; Draw player 
5ef9 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f17			 
5f17			; TODO Get Key 
5f17			 
5f17			; TODO Move left right 
5f17			 
5f17			; scroll and move walls a bit 
5f17			 
5f17 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f48			 
5f48			; main game loop 
5f48			 
5f48 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5f74 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5fb3			 
5fb3			; key board defs 
5fb3			 
5fb3 .. 00		keyup:       db ": keyup $05 ;",0 
5fc1 .. 00		keydown:       db ": keydown $0a ;",0 
5fd1 .. 00		keyleft:       db ": keyleft $0b ;",0 
5fe1 .. 00		keyright:       db ": keyright $0c ;",0 
5ff2 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6000 .. 00		keyf2:       db ": keyf2 $11 ;",0 
600e .. 00		keyf3:       db ": keyf3 $12 ;",0 
601c .. 00		keyf4:       db ": keyf4 $13 ;",0 
602a .. 00		keyf5:       db ": keyf5 $14 ;",0 
6038 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6046 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6054 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6062 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6070 .. 00		keyf10:       db ": keyf10 $19 ;",0 
607f .. 00		keyf11:       db ": keyf11 $1a ;",0 
608e .. 00		keyf12:       db ": keyf12 $1b ;",0 
609d			 
609d .. 00		keytab:       db ": keytab $09 ;",0 
60ac .. 00		keycr:       db ": keycr $0d ;",0 
60ba .. 00		keyhome:       db ": keyhome $0e ;",0 
60ca .. 00		keyend:       db ": keyend $0f ;",0 
60d9 .. 00		keybs:       db ": keybs $08 ;",0 
60e7			 
60e7			   
60e7			 
60e7			 
60e7			 
60e7			; eof 
# End of file forth_autostart.asm
60e7			 
60e7			 
60e7			 
60e7			; stack over and underflow checks 
60e7			 
60e7			; init the words to detect the under/overflow 
60e7			 
60e7			chk_stk_init: 
60e7				; a vague random number to check so we dont get any "lucky" hits 
60e7 3e 2d			ld a, 45 
60e9 6f				ld l, a 
60ea 00				nop 
60eb 3e 17			ld a, 23 
60ed 67				ld h, a 
60ee			 
60ee 22 ae e2			ld (chk_word), hl     ; the word we need to check against 
60f1			 
60f1			;	ld (chk_stund), hl	; stack points.... 
60f1 22 00 ef			ld (chk_stovr), hl 
60f4 22 f2 e9			ld (chk_ret_und), hl 
60f7 22 b0 e9			ld (chk_ret_ovr), hl 
60fa 22 2e e9			ld (chk_loop_ovr), hl 
60fd 22 2c e8			ld (chk_data_ovr), hl 
6100 c9				ret 
6101				 
6101			check_stacks: 
6101				; check all stack words 
6101			 
6101 e5				push hl 
6102 d5				push de 
6103			 
6103			;	ld de,(chk_word) 
6103			;	ld hl, (chk_stund)	; stack points.... 
6103			;	if DEBUG_STK_FAULT 
6103			;		DMARK "FAa" 
6103			;		CALLMONITOR 
6103			;	endif 
6103			;	call cmp16 
6103			;	jp z, .chk_faulta 
6103			; 
6103			;	ld de, sfaultsu 
6103			;	jp .chk_fault 
6103			 
6103 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
6106 ed 5b ae e2		ld de,(chk_word) 
610a				if DEBUG_STK_FAULT 
610a					DMARK "FAb" 
610a					CALLMONITOR 
610a				endif 
610a cd 05 0e			call cmp16 
610d 28 06			jr z, .chk_fault1 
610f 11 b0 61			ld de, sfaultso 
6112 c3 64 61			jp .chk_fault 
6115			.chk_fault1:  
6115 2a f2 e9			ld hl, (chk_ret_und) 
6118 ed 5b ae e2		ld de,(chk_word) 
611c				if DEBUG_STK_FAULT 
611c					DMARK "FAU" 
611c					CALLMONITOR 
611c				endif 
611c cd 05 0e			call cmp16 
611f ca 28 61			jp z, .chk_fault2 
6122 11 c0 61			ld de, sfaultru 
6125 c3 64 61			jp .chk_fault 
6128			.chk_fault2:  
6128 2a b0 e9			ld hl, (chk_ret_ovr) 
612b ed 5b ae e2		ld de,(chk_word) 
612f				if DEBUG_STK_FAULT 
612f					DMARK "FA1" 
612f					CALLMONITOR 
612f				endif 
612f cd 05 0e			call cmp16 
6132 ca 3b 61			jp z, .chk_fault3 
6135 11 ce 61			ld de, sfaultro 
6138 c3 64 61			jp .chk_fault 
613b			.chk_fault3:  
613b 2a 2e e9			ld hl, (chk_loop_ovr) 
613e ed 5b ae e2		ld de,(chk_word) 
6142				if DEBUG_STK_FAULT 
6142					DMARK "FA2" 
6142					CALLMONITOR 
6142				endif 
6142 cd 05 0e			call cmp16 
6145 ca 4e 61			jp z, .chk_fault4 
6148 11 e8 61			ld de, sfaultlo 
614b c3 64 61			jp .chk_fault 
614e			.chk_fault4:  
614e 2a 2c e8			ld hl, (chk_data_ovr) 
6151 ed 5b ae e2		ld de,(chk_word) 
6155				if DEBUG_STK_FAULT 
6155					DMARK "FA3" 
6155					CALLMONITOR 
6155				endif 
6155 cd 05 0e			call cmp16 
6158 ca 61 61			jp z, .chk_fault5 
615b 11 02 62			ld de, sfaultdo 
615e c3 64 61			jp .chk_fault 
6161			 
6161			 
6161			.chk_fault5:  
6161 d1				pop de 
6162 e1				pop hl 
6163			 
6163 c9				ret 
6164			 
6164 cd ba 0b		.chk_fault: 	call clear_display 
6167 3e 28				ld a, display_row_2 
6169 cd cd 0b				call str_at_display 
616c 11 92 61				   ld de, .stackfault 
616f 3e 00				ld a, display_row_1 
6171 cd cd 0b				call str_at_display 
6174 11 71 ee				    ld de, debug_mark 
6177 3e 11				ld a, display_row_1+17 
6179 cd cd 0b				call str_at_display 
617c cd dd 0b				call update_display 
617f			 
617f				; prompt before entering montior for investigating issue 
617f			 
617f 3e 78			ld a, display_row_4 
6181 11 78 19			ld de, endprog 
6184			 
6184 cd dd 0b			call update_display		 
6187			 
6187 cd fe 1b			call next_page_prompt 
618a			 
618a d1				pop de 
618b e1				pop hl 
618c cd cc 19				call monitor 
618f c3 c6 18				jp warmstart 
6192					;jp 0 
6192					;halt 
6192			 
6192			 
6192			 
6192 .. 00		.stackfault: 	db "Stack fault:",0 
619f			 
619f .. 00		sfaultsu: 	db	"Stack under flow",0 
61b0 .. 00		sfaultso: 	db	"Stack over flow",0 
61c0 .. 00		sfaultru:	db "RTS underflow",0 
61ce .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
61e8 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6202 .. 00		sfaultdo:	db "DTS overflow", 0 
620f			 
620f			 
620f			fault_dsp_under: 
620f 11 21 62			ld de, .dsp_under 
6212 c3 d1 62			jp .show_fault 
6215			 
6215			fault_rsp_under: 
6215 11 2f 62			ld de, .rsp_under 
6218 c3 d1 62			jp .show_fault 
621b			fault_loop_under: 
621b 11 3d 62			ld de, .loop_under 
621e c3 d1 62			jp .show_fault 
6221			 
6221 .. 00		.dsp_under: db "DSP Underflow",0 
622f .. 00		.rsp_under: db "RSP Underflow",0 
623d .. 00		.loop_under: db "LOOP Underflow",0 
624c			 
624c			 
624c d5			type_faultn: 	push de 
624d e5					push hl 
624e cd ba 0b				call clear_display 
6251 11 78 62				   ld de, .typefaultn 
6254 3e 00				ld a, display_row_1 
6256 cd cd 0b				call str_at_display 
6259 11 71 ee				    ld de, debug_mark 
625c 3e 11				ld a, display_row_1+17 
625e cd cd 0b				call str_at_display 
6261 cd dd 0b				call update_display 
6264			 
6264				; prompt before entering montior for investigating issue 
6264			 
6264 3e 78			ld a, display_row_4 
6266 11 78 19			ld de, endprog 
6269			 
6269 cd dd 0b			call update_display		 
626c			 
626c cd fe 1b			call next_page_prompt 
626f			 
626f e5					push hl 
6270 d5					push de 
6271 cd cc 19				call monitor 
6274 c3 c6 18				jp warmstart 
6277 76					halt 
6278			 
6278			 
6278 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
628f			 
628f d5			type_faults: 	push de 
6290 e5					push hl 
6291 cd ba 0b				call clear_display 
6294 11 ba 62				   ld de, .typefaults 
6297 3e 00				ld a, display_row_1 
6299 cd cd 0b				call str_at_display 
629c 11 71 ee				    ld de, debug_mark 
629f 3e 11				ld a, display_row_1+17 
62a1 cd cd 0b				call str_at_display 
62a4 cd dd 0b				call update_display 
62a7			 
62a7				; prompt before entering montior for investigating issue 
62a7			 
62a7 3e 78			ld a, display_row_4 
62a9 11 78 19			ld de, endprog 
62ac			 
62ac cd dd 0b			call update_display		 
62af			 
62af cd fe 1b			call next_page_prompt 
62b2			 
62b2 e1					pop hl 
62b3 d1					pop de 
62b4 cd cc 19				call monitor 
62b7 c3 c6 18				jp warmstart 
62ba			 
62ba			 
62ba .. 00		.typefaults: db "STR Type Expected TOS!",0 
62d1			 
62d1			.show_fault: 	 
62d1 d5					push de 
62d2 cd ba 0b				call clear_display 
62d5 d1					pop de 
62d6 3e 00				ld a, display_row_1 
62d8 cd cd 0b				call str_at_display 
62db 11 71 ee				    ld de, debug_mark 
62de 3e 11				ld a, display_row_1+17 
62e0 cd cd 0b				call str_at_display 
62e3 cd dd 0b				call update_display 
62e6			 
62e6				; prompt before entering montior for investigating issue 
62e6			 
62e6 3e 78			ld a, display_row_4 
62e8 11 78 19			ld de, endprog 
62eb			 
62eb cd dd 0b			call update_display		 
62ee			 
62ee cd fe 1b			call next_page_prompt 
62f1			 
62f1 e1					pop hl 
62f2 d1					pop de 
62f3 cd cc 19				call monitor 
62f6			; do a dump to cli and not warmstart so we preserve all of the uwords.  
62f6			; TODO Make optional fault restart to cli or warm boot? 
62f6					;jp warmstart 
62f6 c3 1e 19				jp cli 
62f9 76					halt 
62fa			 
62fa			; handle the auto run of code from files in storage 
62fa			 
62fa			 
62fa			include "forth_startup.asm" 
62fa			; Which startup method to use? 
62fa			; 
62fa			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
62fa			; followed by loading of a list of scripts in eeprom 
62fa			 
62fa			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
62fa			; from eeprom 
62fa			 
62fa			; Select with define in main stubs 
62fa			 
62fa			if STARTUP_V1 
62fa				include "forth_startupv1.asm" 
62fa			; Startup script loading version 1 
62fa			 
62fa			; If SE storage is available first stage is to use the selected file 
62fa			; then go through the eeprom list 
62fa			 
62fa .. 00		sprompt1: db "Startup load...",0 
630a .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6320			 
6320			 
6320			 
6320			 
6320			forth_startup: 
6320 21 46 4e			ld hl, startcmds 
6323 3e 00			ld a, 0 
6325 32 ed e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6328			 
6328 e5			.start1:	push hl 
6329 cd ba 0b			call clear_display 
632c 11 fa 62			ld de, sprompt1 
632f 3e 00		        ld a, display_row_1 
6331 cd cd 0b			call str_at_display 
6334 11 0a 63			ld de, sprompt2 
6337 3e 28		        ld a, display_row_2 
6339 cd cd 0b			call str_at_display 
633c e1				pop hl 
633d e5				push hl 
633e 5e				ld e,(hl) 
633f 23				inc hl 
6340 56				ld d,(hl) 
6341 3e 50		        ld a, display_row_3 
6343 cd cd 0b			call str_at_display 
6346 cd dd 0b			call update_display 
6349			 
6349			 
6349 3a ed e6			ld a, (os_last_cmd) 
634c fe 00			cp 0 
634e 28 05			jr z, .startprompt 
6350 cd e6 0a			call delay250ms 
6353 18 24			jr .startdo 
6355				 
6355				 
6355			 
6355			.startprompt: 
6355			 
6355 3e 9f			ld a,display_row_4 + display_cols - 1 
6357 11 fc 1b		        ld de, endprg 
635a cd cd 0b			call str_at_display 
635d cd dd 0b			call update_display 
6360 cd f2 0a			call delay1s 
6363 cd bf 64			call cin_wait 
6366						 
6366 fe 2a			cp '*' 
6368 28 5e			jr z, .startupend1 
636a fe 23			cp '#' 
636c 20 07			jr nz, .startno 
636e 3e 01			ld a, 1 
6370 32 ed e6			ld (os_last_cmd),a 
6373 18 04			jr .startdo 
6375 fe 31		.startno:	cp '1' 
6377 28 3a			jr z,.startnxt  
6379			 
6379				; exec startup line 
6379			.startdo:	 
6379 e1				pop hl 
637a e5				push hl 
637b				 
637b 5e				ld e,(hl) 
637c 23				inc hl 
637d 56				ld d,(hl) 
637e eb				ex de,hl 
637f			 
637f e5				push hl 
6380			 
6380 3e 00			ld a, 0 
6382				;ld a, FORTH_END_BUFFER 
6382 cd 50 12			call strlent 
6385 23				inc hl   ; include zero term to copy 
6386 06 00			ld b,0 
6388 4d				ld c,l 
6389 e1				pop hl 
638a 11 c7 e2			ld de, scratch 
638d ed b0			ldir 
638f			 
638f			 
638f 21 c7 e2			ld hl, scratch 
6392 cd 81 20			call forthparse 
6395 cd c1 20			call forthexec 
6398 cd d3 1f			call forthexec_cleanup 
639b			 
639b 3e 78			ld a, display_row_4 
639d 11 78 19			ld de, endprog 
63a0			 
63a0 cd dd 0b			call update_display		 
63a3			 
63a3 3a ed e6			ld a, (os_last_cmd) 
63a6 fe 00			cp 0 
63a8 20 09			jr nz, .startnxt 
63aa cd fe 1b			call next_page_prompt 
63ad cd ba 0b		        call clear_display 
63b0 cd dd 0b			call update_display		 
63b3			 
63b3				; move onto next startup line? 
63b3			.startnxt: 
63b3			 
63b3 cd e6 0a			call delay250ms 
63b6 e1				pop hl 
63b7			 
63b7 23				inc hl 
63b8 23				inc hl 
63b9			 
63b9 e5				push hl 
63ba 5e				ld e, (hl) 
63bb 23				inc hl 
63bc 56				ld d, (hl) 
63bd e1				pop hl 
63be				; TODO replace 0 test 
63be			 
63be eb				ex de, hl 
63bf cd 10 0e			call ishlzero 
63c2			;	ld a,e 
63c2			;	add d 
63c2			;	cp 0    ; any left to do? 
63c2 eb				ex de, hl 
63c3 c2 28 63			jp nz, .start1 
63c6 18 01			jr .startupend 
63c8			 
63c8 e1			.startupend1: pop hl 
63c9			.startupend: 
63c9			 
63c9 cd ba 0b			call clear_display 
63cc cd dd 0b			call update_display 
63cf c9				ret 
63d0			if STORAGE_SE 
63d0			 
63d0			sprompt3: db "Loading from start-up file?:",0 
63d0			sprompt4: db "(Y=Any key/N=No)",0 
63d0			 
63d0			 
63d0			forth_autoload: 
63d0			 
63d0				; load block 0 of store 1 
63d0				 
63d0				ld a, $fe      ; bit 0 clear 
63d0				ld (spi_device), a 
63d0			 
63d0				call storage_get_block_0 
63d0			 
63d0				ld a, (store_page+STORE_0_AUTOFILE) 
63d0			 
63d0				cp 0 
63d0				ret z     ; auto start not enabled 
63d0			 
63d0				call clear_display 
63d0			 
63d0				; set bank 
63d0			 
63d0					ld a, (store_page+STORE_0_BANKRUN) 
63d0					ld (spi_device), a 
63d0			 
63d0				; get file id to load from and get the file name to display 
63d0			 
63d0					ld a, (store_page+STORE_0_FILERUN) 
63d0			 
63d0					ld l, 0 
63d0					ld h, a 
63d0					ld de, store_page 
63d0			 
63d0					if DEBUG_FORTH_WORDS 
63d0						DMARK "ASp" 
63d0						CALLMONITOR 
63d0					endif 
63d0					call storage_read 
63d0			 
63d0					if DEBUG_FORTH_WORDS 
63d0						DMARK "ASr" 
63d0						CALLMONITOR 
63d0					endif 
63d0			 
63d0					call ishlzero 
63d0					ret z             ; file not found 
63d0			 
63d0					ld a, display_row_2 + 10 
63d0					ld de, store_page+3 
63d0					call str_at_display 
63d0				 
63d0			; 
63d0			 
63d0				ld a, display_row_1+5 
63d0				ld de, sprompt3 
63d0				call str_at_display 
63d0				ld a, display_row_3+15 
63d0				ld de, sprompt4 
63d0				call str_at_display 
63d0			 
63d0				call update_display 
63d0			 
63d0				call cin_wait 
63d0				cp 'n' 
63d0				ret z 
63d0				cp 'N' 
63d0				ret z 
63d0			 
63d0				call delay1s 
63d0			 
63d0				ld a, (store_page+2) 
63d0				ld (store_openmaxext), a    ; save count of ext 
63d0				ld a, 1  
63d0				ld (store_openext), a    ; save count of ext 
63d0			 
63d0			.autof:  
63d0				ld l , a 
63d0				 
63d0				ld a, (store_page) 
63d0				ld h, a	 
63d0				ld de, store_page 
63d0					if DEBUG_FORTH_WORDS 
63d0						DMARK "ASl" 
63d0						CALLMONITOR 
63d0					endif 
63d0					call storage_read 
63d0				call ishlzero 
63d0				ret z 
63d0			;	jr z, .autoend 
63d0			 
63d0					if DEBUG_FORTH_WORDS 
63d0						DMARK "ASc" 
63d0						CALLMONITOR 
63d0					endif 
63d0				ld de, store_page+2 
63d0				ld a, display_row_4 
63d0				call str_at_display 
63d0			 
63d0				call update_display 
63d0				call delay250ms 
63d0			 
63d0			 
63d0			 
63d0				ld hl, store_page+2 
63d0				call forthparse 
63d0				call forthexec 
63d0				call forthexec_cleanup 
63d0			 
63d0				 
63d0				ld a, (store_openext) 
63d0				inc a 
63d0				ld (store_openext), a    ; save count of ext 
63d0			 
63d0				jr .autof 
63d0			;.autofdone: 
63d0			; 
63d0			;		if DEBUG_FORTH_WORDS 
63d0			;			DMARK "ASx" 
63d0			;			CALLMONITOR 
63d0			;		endif 
63d0			;;	call clear_display 
63d0			;	ret 
63d0			 
63d0			 
63d0			 
63d0			endif 
# End of file forth_startupv1.asm
63d0			endif 
63d0			if STARTUP_V2 
63d0				include "forth_startupv2.asm" 
63d0			endif 
63d0			 
# End of file forth_startup.asm
63d0			 
63d0			; eof 
# End of file forth_kernel.asm
63d0			;include "nascombasic.asm" 
63d0			 
63d0			 
63d0			; find out where the code ends if loaded into RAM (for SC114) 
63d0			;endofcode:  
63d0			;	nop 
63d0			 
63d0			 
63d0			; eof 
63d0			 
# End of file main.asm
63d0			;include "firmware_lcd_4x40.asm" 
63d0			;;include "firmware_lcd_4x20.asm" 
63d0			include "firmware_cpm_display.asm" 
63d0			 
63d0			; Serial display interface for SC114 
63d0			 
63d0			 
63d0			display_row_1: equ 0 
63d0			display_row_2: equ display_row_1+display_cols 
63d0			display_row_3: equ display_row_2 + display_cols 
63d0			display_row_4: equ display_row_3 + display_cols 
63d0			 
63d0			kLCDWidth:  EQU display_cols             ;Width in characters 
63d0			kLCD_Line1: EQU 0x00  
63d0			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
63d0			; E1 
63d0			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
63d0			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
63d0			 
63d0			lcd_init: 
63d0				; no init as handled by the SCM bios 
63d0 c9				ret 
63d1			 
63d1			 
63d1			; low level functions for direct screen writes 
63d1			 
63d1			; output char at pos? 
63d1			fLCD_Str: 
63d1			        ;out (SC114_SIO_1_OUT),a 
63d1 c5				push bc 
63d2 d5				push de 
63d3 5f				ld e, a 
63d4			; TODO Replace with CP/M BIOS call 
63d4 0e 02			ld c, $02 
63d6 cd 05 00			call 5 
63d9 d1				pop de 
63da c1				pop bc 
63db c9				ret 
63dc			 
63dc			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
63dc			fLCD_Pos: 
63dc				; use ASCII escape to position 
63dc			        ;out (SC114_SIO_1_OUT),a 
63dc c5				push bc 
63dd d5				push de 
63de 5f				ld e, a 
63df 0e 02			ld c, $02 
63e1			; TODO Replace with CP/M BIOS call 
63e1 cd 05 00			call 5 
63e4 d1				pop de 
63e5 c1				pop bc 
63e6			 
63e6 c9				ret 
63e7			 
63e7			; output char at pos 
63e7			fLCD_Data: 
63e7			      ;  out (SC114_SIO_1_OUT),a 
63e7 c5				push bc 
63e8 d5				push de 
63e9 0e 02			ld c, $02 
63eb 5f				ld e, a 
63ec			; TODO Replace with CP/M BIOS call 
63ec cd 05 00			call 5 
63ef d1				pop de 
63f0 c1				pop bc 
63f1			 
63f1 c9				ret 
63f2			 
63f2			; ascii cls  
63f2			 
63f2 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
63f6			 
63f6 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
640d			;.clscpm: db 3, $3c,"$" 
640d			 
640d			; write the frame buffer given in hl to hardware  
640d			write_display: 
640d			 
640d			API: equ 0 
640d			 
640d			if API 
640d				push bc 
640d				ld b, 4 
640d			 
640d			        ld (display_write_tmp), hl 	  
640d			 
640d				; clear and home cursor 
640d			 
640d				ld c, 9 
640d				ld de, .cls 
640d			; TODO Replace with CP/M BIOS call 
640d				call 5 
640d			 
640d			 
640d			.writeln: 
640d			 
640d				ld de, (display_write_tmp) 
640d				ld c, 6 
640d			; TODO Replace with CP/M BIOS call 
640d				rst $30 
640d				ld c, 7 
640d				rst $30 
640d			 
640d				ld hl, (display_write_tmp) 
640d				ld de, display_cols 
640d				add hl,de 
640d				ld (display_write_tmp),hl 
640d			 
640d				djnz  .writeln 
640d			 
640d				pop bc 
640d			 
640d			 
640d				ret 
640d			endif 
640d e5				push hl 
640e c5				push bc 
640f d5				push de 
6410			 
6410			;	ld c, 2 
6410			;	;ld de, .cls 
6410			;	ld a, 27 
6410			;	rst $30 
6410			;	ld c, 2 
6410			;	;ld de, .cls 
6410			;	ld a, '[' 
6410			;	rst $30 
6410			; 
6410			;	ld c, 2 
6410			;	;ld de, .cls 
6410			;	ld a, 'H' 
6410			;	rst $30 
6410			; 
6410			 
6410			 
6410			; lots of CR/LF 
6410			;	ld c, 9 
6410			;	ld de, .clscpm 
6410			;	call 5 
6410			 
6410			; xterm cls 
6410 0e 02			ld c, 2 
6412 1e 1b			ld e, 27 
6414 cd 05 00			call 5 
6417			; cls causes too much flicker 
6417			;	ld c, 2 
6417			;	ld e, 'c' 
6417			;	call 5 
6417			 
6417			; use xterm home instead 
6417 0e 02			ld c, 2 
6419 1e 5b			ld e, '[' 
641b cd 05 00			call 5 
641e 0e 02			ld c, 2 
6420 1e 48			ld e, 'H' 
6422 cd 05 00			call 5 
6425			LLL: equ 0 
6425			 
6425			if LLL 
6425			 
6425				ld c, 2 
6425				;ld de, .cls 
6425				ld e, 27 
6425			; TODO Replace with CP/M BIOS call 
6425				call 5 
6425			 
6425			 
6425				ld c, 2 
6425				;ld de, .cls 
6425				ld e, '[' 
6425			; TODO Replace with CP/M BIOS call 
6425				call 5 
6425				ld c, 2 
6425				;ld de, .cls 
6425				ld e, '2' 
6425			; TODO Replace with CP/M BIOS call 
6425				call 5 
6425				ld c, 2 
6425				;ld de, .cls 
6425				ld e, 'J' 
6425			; TODO Replace with CP/M BIOS call 
6425				call 5 
6425			 
6425			endif 
6425			 
6425 d1				pop de 
6426 c1				pop bc 
6427 e1				pop hl 
6428			 
6428			 
6428 22 cf eb		        ld (display_write_tmp), hl 	  
642b 3e 00			ld a, kLCD_Line1 
642d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
642d 06 28			ld b, display_cols 
642f ed 5b cf eb		ld de, (display_write_tmp) 
6433 cd b6 64			call write_len_string 
6436				 
6436			 
6436 e5			push hl 
6437 d5			push de 
6438 c5			push bc 
6439 0e 02			ld c, 2 
643b 1e 0a			ld e, 10 
643d cd 05 00			call 5 
6440 0e 02			ld c, 2 
6442 1e 0d			ld e, 13 
6444 cd 05 00			call 5 
6447			; TODO Replace with CP/M BIOS call 
6447				;rst $30 
6447 c1			pop bc 
6448 d1			pop de 
6449 e1			pop hl 
644a			 
644a				 
644a 2a cf eb			ld hl, (display_write_tmp) 
644d 11 28 00			ld de, display_cols 
6450 19				add hl,de 
6451 22 cf eb			ld (display_write_tmp),hl 
6454			 
6454				 
6454 3e 28			ld a, kLCD_Line2 
6456			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6456 06 28			ld b, display_cols 
6458 ed 5b cf eb		ld de, (display_write_tmp) 
645c cd b6 64			call write_len_string 
645f				 
645f 2a cf eb			ld hl, (display_write_tmp) 
6462 11 28 00			ld de, display_cols 
6465 19				add hl,de 
6466 22 cf eb			ld (display_write_tmp),hl 
6469			 
6469 e5			push hl 
646a d5			push de 
646b c5			push bc 
646c 0e 07			ld c, 7 
646e			; TODO Replace with CP/M BIOS call 
646e				;rst $30 
646e 0e 02			ld c, 2 
6470 1e 0a			ld e, 10 
6472 cd 05 00			call 5 
6475 0e 02			ld c, 2 
6477 1e 0d			ld e, 13 
6479 cd 05 00			call 5 
647c c1			pop bc 
647d d1			pop de 
647e e1			pop hl 
647f			 
647f				 
647f 3e 50			ld a, kLCD_Line3 
6481			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6481 06 28			ld b, display_cols 
6483 ed 5b cf eb		ld de, (display_write_tmp) 
6487 cd b6 64			call write_len_string 
648a				 
648a 2a cf eb			ld hl, (display_write_tmp) 
648d 11 28 00			ld de, display_cols 
6490 19				add hl,de 
6491 22 cf eb			ld (display_write_tmp),hl 
6494			 
6494 e5			push hl 
6495 d5			push de 
6496 c5			push bc 
6497 0e 07			ld c, 7 
6499			; TODO Replace with CP/M BIOS call 
6499				;rst $30 
6499 0e 02			ld c, 2 
649b 1e 0a			ld e, 10 
649d cd 05 00			call 5 
64a0 0e 02			ld c, 2 
64a2 1e 0d			ld e, 13 
64a4 cd 05 00			call 5 
64a7 c1			pop bc 
64a8 d1			pop de 
64a9 e1			pop hl 
64aa			 
64aa				 
64aa 3e 78			ld a, kLCD_Line4 
64ac			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
64ac 06 28			ld b, display_cols 
64ae ed 5b cf eb		ld de, (display_write_tmp) 
64b2 cd b6 64			call write_len_string 
64b5 c9					ret 
64b6			 
64b6			 
64b6				; write out a fixed length string given in b from de 
64b6			 
64b6 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
64b7 cd e7 63		            CALL fLCD_Data      ;Write character to display 
64ba 13				inc de 
64bb 10 f9			djnz write_len_string 
64bd c9				ret 
64be			 
64be			 
64be			; eof 
# End of file firmware_cpm_display.asm
64be			;include "firmware_key_5x10.asm" 
64be			;;include "firmware_key_4x10.asm" 
64be			include "firmware_key_cpm.asm" 
64be			; Serial keyboard interface for SC114 
64be			 
64be			 
64be			key_init: 
64be				; no init as handled by the SCM bios 
64be c9				ret 
64bf			 
64bf			 
64bf			cin_wait: 
64bf			;	ld a, 0 
64bf			;	ret 
64bf			 
64bf				;in a,(SC114_SIO_1_IN) 
64bf			        ; Use SCM API to get from whatever console device we are using 
64bf			 
64bf			; TODO Replace with CP/M BIOS call 
64bf c5				push bc 
64c0 0e 01			ld c, $01 
64c2 cd 05 00			call 5 
64c5 c1				pop bc 
64c6 c9				ret 
64c7			 
64c7			cin: 
64c7			 
64c7			 
64c7 c5				push bc 
64c8			 
64c8				; any key waiting to process? 
64c8			; TODO Replace with CP/M BIOS call 
64c8 0e 06			ld c, $06 
64ca cd 05 00			call 5 
64cd 28 0d			jr z, .cin_skip 
64cf			 
64cf				; yep, get it 
64cf			 
64cf 0e 01			ld c, $01 
64d1			; TODO Replace with CP/M BIOS call 
64d1 cd 05 00			call 5 
64d4			 
64d4 fe 7f			cp $7f     ; back space 
64d6 20 02			jr nz, .skipbs 
64d8 3e 08			ld a, KEY_BS 
64da			.skipbs: 
64da			 
64da c1				pop bc 
64db c9				ret 
64dc			.cin_skip: 
64dc 3e 00			ld a, 0 
64de c1				pop bc 
64df c9				ret 
64e0			 
64e0			 
64e0			 
64e0			 
# End of file firmware_key_cpm.asm
64e0			endofcode:  
64e0			baseram:  
64e0 00				nop 
64e1			 
64e1			heap_start: equ baseram+15  ; Starting address of heap 
64e1			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
64e1			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
64e1			;VDU:  EQU     endofcode           ; BASIC Work space 
64e1			; eof 
64e1			 
# End of file os_mega_cpm.asm
64e1
