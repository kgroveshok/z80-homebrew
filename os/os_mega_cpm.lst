# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5a 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			if BASE_KEV = 1  
011c			 
011c				; need to be at $66 for nmi support 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255 
011c				jp nmi 
011c			endif 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 0       
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			os_stack_1: equ scratch - 3       ; stack holding area 1  
011c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ os_stack_4-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 10 ed				ld hl, display_fb1  
011f 22 cc eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 ce eb				ld hl, display_fb2  
0128 22 cc eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b1 ed				ld hl, display_fb0  
0131 22 cc eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 81 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 6f 65			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b8 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 cd 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6b ee		ld (debug_mark),a  
0191 32 6c ee		ld (debug_mark+1),a  
0194 32 6d ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 6e ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 73 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6b ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6c ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 6d ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 6f ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7a ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6b ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6c ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 6d ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 6f ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7a ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6b ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6c ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 6d ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 6f ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 73 ea				ld hl, (store_tmp1) 
0210 11 7d ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6b ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6c ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 6d ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 6f ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6b ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6c ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 6d ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 6f ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6b ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6c ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 6d ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 6f ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6b ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6c ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 6d ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 6f ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6b ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6c ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 6d ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 6f ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7a ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6b ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6c ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 6d ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 6f ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6b ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6c ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 6d ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 6f ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7a ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6b ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6c ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 6d ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7a ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 6f ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7b ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6b ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6c ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 6d ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 6f ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6b ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6c ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 6d ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 6f ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7a ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7b ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 7d ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 86 ea			ld hl, store_page+3+9 
03b5 3a 5f ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7a ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6b ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6c ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 6d ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 6f ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6b ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6c ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 6d ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 6f ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6b ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6c ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 6d ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 6f ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 7d ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6b ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6c ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 6d ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 6f ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7a ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6b ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6c ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 6d ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 6f ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6b ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6c ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 6d ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 6f ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7a ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6b ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6c ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 6d ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 6f ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7a ea			ld a, (store_page)	; get file id 
0510 32 6e ea			ld (store_tmpid), a 
0513			 
0513 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0516 32 6d ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7a ea			ld (store_page), a 
051f 32 7b ea			ld (store_page+1),a 
0522 11 7a ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6b ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6c ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 6d ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 6f ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 6d ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 6e ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6b ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6c ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 6d ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 6f ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7a ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7a ea			ld (store_page), a 
0582 32 7b ea			ld (store_page+1),a 
0585 11 7a ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6b ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6c ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 6d ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 6f ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6b ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6c ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 6d ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 6f ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6b ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6c ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 6d ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 6f ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6b ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6c ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 6d ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 6f ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6b ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6c ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 6d ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 6f ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7a ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7a ea			ld (store_page),a 
06a3				 
06a3 32 6e ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7a ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6b ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6c ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 6d ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 6f ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7a ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6b ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6c ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 6d ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 6f ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6b ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6c ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 6d ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 6f ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 65 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7a ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7b ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6b ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6c ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 6d ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 6f ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6b ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6c ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 6d ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 6f ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6b ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6c ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 6d ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 6f ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 65 ea			ld hl,(store_tmppageid) 
078b 11 7a ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6b ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6c ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 6d ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 6f ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 6e ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6b ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6c ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 6d ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 6f ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6b ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6c ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 6d ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 6f ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6b ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6c ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 6d ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 6f ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6b ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6b ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6c ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 6d ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 6f ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 6d ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6b ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6c ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 6d ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 6f ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 75 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6b ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6c ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 6d ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 6f ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6b ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6c ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 6d ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 6f ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6b ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6c ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 6d ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 6f ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6b ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6b ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6c ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 6d ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 6f ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6b ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6c ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 6d ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 6f ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6b ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6c ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 6d ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 6f ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6b ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6c ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 6d ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 6f ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 6e ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 6e ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 65 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6b ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6c ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 6d ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 6f ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7a ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6b ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6c ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 6d ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 6f ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7c ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7c ea			ld (store_page+2), a 
09e3 32 6d ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6b ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6c ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 6d ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 6f ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 65 ea			ld hl, (store_tmppageid) 
0a05 11 7a ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 65 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6b ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6c ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 6d ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 6f ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7a ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 6e ea				ld a, (store_tmpid) 
0a4b 32 7a ea				ld (store_page), a   ; file id 
0a4e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7b ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7c ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6b ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6c ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 6d ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 6f ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 65 ea			ld hl, (store_tmppageid) 
0a85 11 7a ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6b ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6c ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 6d ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 6e ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7a ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7b ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c6 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c6 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 76 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 c7 eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 c7 eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cc eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b1 ed				ld hl, display_fb0 
0b53 22 cc eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd bf 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 10 ed				ld hl, display_fb1 
0b74 22 cc eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cc eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cc eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cc eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cc eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cc eb			ld hl, (display_fb_active) 
0be1 cd be 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 73 ea				ld (store_tmp1), hl 
0bee 32 71 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b1 ed				ld hl, display_fb0 
0bf4 22 cc eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 6f ea				ld (store_tmp3), a   ; display row count 
0c02 3a 71 ea				ld a,( store_tmp2) 
0c05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 72 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 73 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 6f ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 72 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 6f ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 6f ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 70 65				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 71 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 71 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 71 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 71 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 71 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 10 ed				ld hl, display_fb1 
0cb1 22 cc eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ab eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ab eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b1 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b3 eb		        ld hl,LFSRSeed+6 
0d04 11 b4 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a5 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a5 eb		    ld (seed1),hl 
0d1a 2a a3 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a3 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 a9 eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 60 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 60 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 5f ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 5f ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 60 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 69 ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 67 ee			ld de, (input_start) 
0e69 3a 64 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 5f ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 62 ee				ld a,(input_at_cursor) 
0e79 11 c1 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 67 ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5a ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 78 65				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 67 ee				ld hl, (input_start) 
0e98 3a 55 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 69 ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 64 ee				ld a, (input_at_pos) 
0ea9 32 62 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 55 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 69 ee				ld (input_ptr), hl 
0ed1 3a 62 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 62 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 69 ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 69 ee				ld (input_ptr), hl 
0ef0 3a 62 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 62 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 55 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 55 ee				ld (input_cursor), a 
0f09			 
0f09 2a 69 ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 69 ee				ld (input_ptr), hl 
0f10					 
0f10 3a 62 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 62 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 5f ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 60 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 55 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 55 ee				ld (input_cursor), a 
0f37			 
0f37 3a 62 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 62 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 69 ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 69 ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 5f ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 60 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 67 ee				ld hl, (input_start) 
0f59 22 69 ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 64 ee				ld a, (input_at_pos) 
0f5f 32 62 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 55 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 e8 e5				ld hl, os_cli_cmd 
0f6a 11 e7 e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 55 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 55 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 69 ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 69 ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 62 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 62 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 5f ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 62 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 55 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 62 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 62 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 69 ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 69 ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 69 ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 69 ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 5f ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 60 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 67 ee				ld hl, (input_start) 
0ffa 3a 5a ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5a ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 55 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 55 ee				ld (input_cursor), a 
1022			 
1022 3a 62 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 62 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 67 ee				ld hl, (input_start) 
102f 3a 5a ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 67 ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 69 ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 66 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 55 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 69 ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c1 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 64 ee				ld a,(input_at_pos) 
1063 cd 8d 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 67 ee	            	LD   de, (input_start) 
106a cd 82 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 78 65				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 69 ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c1 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 69 ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 69 ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 69 ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 69 ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 69 ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c1 e2			ld hl, scratch 
10bd 11 e7 e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c1 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 69 ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 36 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f5 e2			ld (scratch+52),a 
11be				 
11be 21 f3 e2			ld hl,scratch+50 
11c1 22 e4 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 a0 65		      ld    HL, heap_start 
128e 22 9b 65		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 9d 65		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 98 e2		      ld    HL, heap_start+heap_size-4 
129a 22 a0 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 f8 7c		      ld    HL, heap_size-4 
12a0 22 a2 65		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 9a e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 98 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 9b 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 9b 65		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			; Now handled by SPI  
1447			;if SOUND_ENABLE  
1447			;	include "firmware_sound.asm"  
1447			;endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d dd 17			dw prom_c2 
146f f2 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 11 18			dw prom_m4 
1473 2c 18			dw prom_m4b 
1475 34 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 43 18			ld hl, prom_notav 
147c 11 59 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 43 18			ld hl, prom_notav 
1486 11 59 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 43 18			ld hl, prom_notav 
1490 11 59 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 43 18			ld hl, prom_notav 
149a 11 59 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				cp 7 
14a1				call z, .gensoundword 
14a1				jr create_startup 
14a1			 
14a1			.gensoundword: 
14a1				ld hl, crs_sound 
14a1				ld de, .soundworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.soundworddef: 
14a1				dw sound1 
14a1				dw sound2 
14a1				dw sound3 
14a1				dw sound4 
14a1				dw sound5 
14a1				dw sound6 
14a1				dw sound7 
14a1				dw sound8 
14a1				dw sound9 
14a1				dw 0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw crs_sound 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 6f ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c1 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c1 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c1 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c6 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 c8 e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 ca e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c6 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 60 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6b ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6a 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 40 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 72 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 3e ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a1 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f2 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd bf 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 6f ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 70 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 6f ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef			;	pop af 
15ef f5				push af 
15f0 22 a3 e2			ld (os_view_hl), hl 
15f3 ed 53 a1 e2		ld (os_view_de), de 
15f7 ed 43 9f e2		ld (os_view_bc), bc 
15fb e5				push hl 
15fc 6f				ld l, a 
15fd 26 00			ld h, 0 
15ff 22 a5 e2			ld (os_view_af),hl 
1602			 
1602 21 b1 ed				ld hl, display_fb0 
1605 22 cc eb				ld (display_fb_active), hl 
1608 e1				pop hl	 
1609			 
1609 3e 31			ld a, '1' 
160b fe 2a		.bps1:  cp '*' 
160d cc e9 15			call z, bp_off 
1610			;	jr nz, .bps1b 
1610			;	ld (os_view_disable),a 
1610 fe 31		.bps1b:  cp '1' 
1612 20 14			jr nz, .bps2 
1614			 
1614				; display reg 
1614			 
1614				 
1614			 
1614 3a a5 e2			ld a, (os_view_af) 
1617 2a a3 e2			ld hl, (os_view_hl) 
161a ed 5b a1 e2		ld de, (os_view_de) 
161e ed 4b 9f e2		ld bc, (os_view_bc) 
1622 cd bc 16			call display_reg_state 
1625 c3 a8 16			jp .bpschk 
1628			 
1628 fe 32		.bps2:  cp '2' 
162a 20 08			jr nz, .bps3 
162c				 
162c				; display hl 
162c 2a a3 e2			ld hl, (os_view_hl) 
162f cd a6 17			call display_dump_at_hl 
1632			 
1632 18 74			jr .bpschk 
1634			 
1634 fe 33		.bps3:  cp '3' 
1636 20 08			jr nz, .bps4 
1638			 
1638			        ; display de 
1638 2a a1 e2			ld hl, (os_view_de) 
163b cd a6 17			call display_dump_at_hl 
163e			 
163e 18 68			jr .bpschk 
1640 fe 34		.bps4:  cp '4' 
1642 20 08			jr nz, .bps5 
1644			 
1644			        ; display bc 
1644 2a 9f e2			ld hl, (os_view_bc) 
1647 cd a6 17			call display_dump_at_hl 
164a			 
164a 18 5c			jr .bpschk 
164c fe 35		.bps5:  cp '5' 
164e 20 08		        jr nz, .bps7 
1650			 
1650				; display cur ptr 
1650 2a 40 ea			ld hl, (cli_ptr) 
1653 cd a6 17			call display_dump_at_hl 
1656			 
1656 18 50			jr .bpschk 
1658 fe 36		.bps7:  cp '6' 
165a 20 08			jr nz, .bps8b 
165c				 
165c				; display cur orig ptr 
165c 2a 3e ea			ld hl, (cli_origptr) 
165f cd a6 17			call display_dump_at_hl 
1662 18 44			jr .bpschk 
1664 fe 37		.bps8b:  cp '7' 
1666 20 08			jr nz, .bps9 
1668				 
1668				; display dsp 
1668 2a ee e9			ld hl, (cli_data_sp) 
166b cd a6 17			call display_dump_at_hl 
166e			 
166e 18 38			jr .bpschk 
1670 fe 39		.bps9:  cp '9' 
1672 20 05			jr nz, .bps8c 
1674				 
1674				; display SP 
1674			;	ld hl, sp 
1674 cd a6 17			call display_dump_at_hl 
1677			 
1677 18 2f			jr .bpschk 
1679 fe 38		.bps8c:  cp '8' 
167b 20 08			jr nz, .bps8d 
167d				 
167d				; display rsp 
167d 2a f2 e9			ld hl, (cli_ret_sp) 
1680 cd a6 17			call display_dump_at_hl 
1683			 
1683 18 23			jr .bpschk 
1685 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1687 20 05			jr nz, .bps8 
1689 cd 8d 19			call monitor 
168c			 
168c 18 1a			jr .bpschk 
168e fe 30		.bps8:  cp '0' 
1690 20 16			jr nz, .bpschk 
1692			 
1692 21 10 ed				ld hl, display_fb1 
1695 22 cc eb				ld (display_fb_active), hl 
1698 cd dd 0b				call update_display 
169b			 
169b				;ld a, (os_view_af) 
169b 2a a3 e2			ld hl, (os_view_hl) 
169e ed 5b a1 e2		ld de, (os_view_de) 
16a2 ed 4b 9f e2		ld bc, (os_view_bc) 
16a6 f1				pop af 
16a7 c9				ret 
16a8			 
16a8			.bpschk:   
16a8 cd f2 0a			call delay1s 
16ab 3e 9f		ld a,display_row_4 + display_cols - 1 
16ad 11 bd 1b		        ld de, endprg 
16b0 cd cd 0b			call str_at_display 
16b3 cd dd 0b			call update_display 
16b6 cd 70 65			call cin_wait 
16b9			 
16b9 c3 0b 16			jp .bps1 
16bc			 
16bc			 
16bc			display_reg_state: 
16bc			 
16bc				; to restore afterwards 
16bc			 
16bc d5				push de 
16bd c5				push bc 
16be e5				push hl 
16bf f5				push af 
16c0			 
16c0				; for use in here 
16c0			 
16c0 c5				push bc 
16c1 d5				push de 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4 cd ba 0b			call clear_display 
16c7			 
16c7 11 7c 17			ld de, .regstate 
16ca 3e 00			ld a, display_row_1 
16cc cd cd 0b			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 6b ee			ld de, debug_mark 
16d2 3e 25			ld a, display_row_1+display_cols-3 
16d4 cd cd 0b			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 98 17			ld de, .regstatea 
16da 3e 28			ld a, display_row_2 
16dc cd cd 0b			call str_at_display 
16df			 
16df e1				pop hl 
16e0			;	ld h,0 
16e0			;	ld l, a 
16e0 3e 2b			ld a, display_row_2+3 
16e2 cd 62 15			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 8c 17			ld de, .regstatehl 
16e8 3e 32			ld a, display_row_2+10 
16ea cd cd 0b			call str_at_display 
16ed			 
16ed e1				pop hl 
16ee 3e 35			ld a, display_row_2+13 
16f0 cd 62 15			call display_word_at 
16f3			 
16f3				 
16f3				; display de 
16f3			 
16f3 11 90 17			ld de, .regstatede 
16f6 3e 50			ld a, display_row_3 
16f8 cd cd 0b			call str_at_display 
16fb			 
16fb e1				pop hl 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc 3e 53			ld a, display_row_3+3 
16fe cd 62 15			call display_word_at 
1701			 
1701			 
1701				; display bc 
1701			 
1701 11 94 17			ld de, .regstatebc 
1704 3e 5a			ld a, display_row_3+10 
1706 cd cd 0b			call str_at_display 
1709			 
1709 e1				pop hl 
170a			;	ld h,b 
170a			;	ld l, c 
170a 3e 5d			ld a, display_row_3+13 
170c cd 62 15			call display_word_at 
170f			 
170f			 
170f				; display dsp 
170f			 
170f 11 9c 17			ld de, .regstatedsp 
1712 3e 78			ld a, display_row_4 
1714 cd cd 0b			call str_at_display 
1717			 
1717				 
1717 2a ee e9			ld hl,(cli_data_sp) 
171a 3e 7c			ld a, display_row_4+4 
171c cd 62 15			call display_word_at 
171f			 
171f				; display rsp 
171f			 
171f 11 a1 17			ld de, .regstatersp 
1722 3e 82			ld a, display_row_4+10 
1724 cd cd 0b			call str_at_display 
1727			 
1727				 
1727 2a f2 e9			ld hl,(cli_ret_sp) 
172a 3e 86			ld a, display_row_4+14 
172c cd 62 15			call display_word_at 
172f			 
172f cd dd 0b			call update_display 
1732			 
1732			;	call delay1s 
1732			;	call delay1s 
1732			;	call delay1s 
1732			 
1732			 
1732			;	call next_page_prompt 
1732			 
1732				; restore  
1732			 
1732 f1				pop af 
1733 e1				pop hl 
1734 c1				pop bc 
1735 d1				pop de 
1736 c9				ret 
1737			 
1737 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1760 .. 00		.ptrstate:	db "Ptr State",0 
176a .. 00		.ptrcliptr:     db "cli_ptr",0 
1772 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177c .. 00		.regstate:	db "Reg State (1/0)",0 
178c .. 00		.regstatehl:	db "HL:",0 
1790 .. 00		.regstatede:	db "DE:",0 
1794 .. 00		.regstatebc:	db "BC:",0 
1798 .. 00		.regstatea:	db "A :",0 
179c .. 00		.regstatedsp:	db "DSP:",0 
17a1 .. 00		.regstatersp:	db "RSP:",0 
17a6			 
17a6			display_dump_at_hl: 
17a6 e5				push hl 
17a7 d5				push de 
17a8 c5				push bc 
17a9 f5				push af 
17aa			 
17aa 22 e4 e5			ld (os_cur_ptr),hl	 
17ad cd ba 0b			call clear_display 
17b0 cd c7 1a			call dumpcont 
17b3			;	call delay1s 
17b3			;	call next_page_prompt 
17b3			 
17b3			 
17b3 f1				pop af 
17b4 c1				pop bc 
17b5 d1				pop de 
17b6 e1				pop hl 
17b7 c9				ret 
17b8			 
17b8			;if ENABLE_BASIC 
17b8			;	include "nascombasic.asm" 
17b8			;	basic: 
17b8			;	include "forth/FORTH.ASM" 
17b8			;endif 
17b8			 
17b8			; eof 
17b8			 
17b8			 
# End of file firmware_diags.asm
17b8			  
17b8			include "firmware_prompts.asm"  
17b8			; Prompts  
17b8			 
17b8			; boot messages 
17b8			 
17b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dd			 
17dd			 
17dd			; config menus 
17dd			 
17dd			;prom_c3: db "Add Dictionary To File",0 
17dd			 
17dd			if STARTUP_V1 
17dd .. 00		prom_c2: db "Select Autoload File",0 
17f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1808			endif 
1808			 
1808			if STARTUP_V2 
1808			prom_c2: db "Enable Autoload Files",0 
1808			prom_c2a: db "Disable Autoload Files", 0 
1808			 
1808			crs_s1: db "*ls-word", 0 
1808			crs_s2: db "*ed-word", 0 
1808			crs_s3: db "*Demo-Programs", 0 
1808			crs_s4: db "*Utils", 0 
1808			crs_s5: db "*SPI-Addons", 0 
1808			crs_s6: db "*Key-constants", 0 
1808			crs_sound: db "*Sound-Util", 0 
1808			 
1808			 
1808			 
1808			endif 
1808			;prom_c2b: db "Select Storage Bank",0 
1808 .. 00		prom_c4: db "Settings",0 
1811 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182c .. 00		prom_m4b:   db "Monitor",0 
1834 .. 00		prom_c1: db "Hardware Diags",0 
1843			 
1843			 
1843			if STARTUP_V2 
1843			prom_c9: db "Create Startup Files",0 
1843			endif 
1843			 
1843 .. 00		prom_notav:    db "Feature not available",0 
1859 .. 00		prom_empty:    db "",0 
185a			 
185a			; eof 
185a			 
# End of file firmware_prompts.asm
185a			  
185a			  
185a			; eof  
185a			  
# End of file firmware.asm
185a			 
185a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185a			;if BASE_KEV  
185a			;baseram: equ 08000h 
185a			;endif 
185a			 
185a			;if BASE_SC114 
185a			;baseram:     equ    endofcode 
185a			;endif 
185a			 
185a			 
185a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185a			 
185a			; start system 
185a			 
185a			coldstart: 
185a				; set sp 
185a				; di/ei 
185a			 
185a f3				di 
185b 31 00 f0			ld sp, tos 
185e cd 6e 64			call init_nmi 
1861			;	ei 
1861			 
1861				; init spinner 
1861 3e 00			ld a,0 
1863 32 c6 eb			ld (display_active), a 
1866			 
1866				; disable breakpoint by default 
1866			 
1866				;ld a,'*' 
1866			;	ld a,' ' 
1866			;	ld (os_view_disable),a 
1866			 
1866				; set break point vector as new break point on or off 
1866 cd e9 15			call bp_off 
1869			 
1869				; init hardware 
1869			 
1869				; init keyboard and screen hardware 
1869			 
1869 cd 1c 01			call hardware_init 
186c			 
186c			 
186c cd f2 0a			call delay1s 
186f 3e 58			ld a, display_row_3+8 
1871 11 03 01			ld de, buildtime 
1874 cd cd 0b			call str_at_display 
1877 cd dd 0b			call update_display 
187a			 
187a cd f2 0a			call delay1s 
187d cd f2 0a			call delay1s 
1880 cd f2 0a			call delay1s 
1883			 
1883				; detect if any keys are held down to enable breakpoints at start up 
1883			 
1883 cd 78 65			call cin  
1886 fe 00			cp 0 
1888 28 03			jr z, .nokeys 
188a			 
188a				;call hardware_diags 
188a cd 47 14			call config 
188d			 
188d			;	ld de, .bpen 
188d			;	ld a, display_row_4 
188d			;	call str_at_display 
188d			;	call update_display 
188d			; 
188d			;	ld a,0 
188d			;	ld (os_view_disable),a 
188d			; 
188d			;.bpwait: 
188d			;	call cin 
188d			;	cp 0 
188d			;	jr z, .bpwait 
188d			;	jr .nokeys 
188d			; 
188d			; 
188d			;.bpen:  db "Break points enabled!",0 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			.nokeys: 
188d			 
188d			 
188d				 
188d			 
188d			;jp  testkey 
188d			 
188d			;call storage_get_block_0 
188d			; 
188d			;ld hl, 0 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d				 
188d			;ld hl, 10 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			;stop:	nop 
188d			;	jp stop 
188d			 
188d			 
188d			 
188d			main: 
188d cd ba 0b			call clear_display 
1890 cd dd 0b			call update_display 
1893			 
1893			 
1893			 
1893			;	call testlcd 
1893			 
1893			 
1893			 
1893 cd c4 1f			call forth_init 
1896			 
1896			 
1896			warmstart: 
1896 cd 9a 1f			call forth_warmstart 
1899			 
1899				; run startup word load 
1899			        ; TODO prevent this running at warmstart after crash  
1899			 
1899				if STARTUP_ENABLE 
1899			 
1899					if STARTUP_V1 
1899			 
1899						if STORAGE_SE 
1899							call forth_autoload 
1899						endif 
1899 cd be 63					call forth_startup 
189c					endif 
189c			 
189c					if STARTUP_V2 
189c			 
189c						if STORAGE_SE 
189c							call forth_autoload 
189c						else 
189c							call forth_startup 
189c						endif 
189c			 
189c			 
189c					endif 
189c			 
189c				endif 
189c			 
189c				; show free memory after boot 
189c 11 28 19			ld de, freeram 
189f 3e 00			ld a, display_row_1 
18a1 cd cd 0b			call str_at_display 
18a4			 
18a4				; get current heap start after loading any uwords 
18a4			 
18a4				;ld de, (os_last_new_uword) 
18a4				;ex de, hl 
18a4			 
18a4			; Or use heap_size word???? 
18a4				;ld hl, heap_end 
18a4				;ld hl, heap_size 
18a4				;ld de, topusermem 
18a4				;ld de, heap_start 
18a4 ed 5b 9b 65			ld de, (free_list )      
18a8 21 9c e2				ld hl, heap_end 
18ab ed 52			sbc hl, de 
18ad				;push hl 
18ad				;ld a,h	         	 
18ad				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18ad				;call hexout 
18ad			   	;pop hl 
18ad			; 
18ad			;	ld a,l 
18ad			;	ld hl, os_word_scratch+2 
18ad			;	call hexout 
18ad			;	ld hl, os_word_scratch+4 
18ad			;	ld a, 0 
18ad			;	ld (hl),a 
18ad eb				ex de, hl 
18ae 21 c6 e5			ld hl, os_word_scratch 
18b1 cd f4 11			call uitoa_16 
18b4			 
18b4			 
18b4 11 c6 e5			ld de, os_word_scratch 
18b7 3e 0d			ld a, display_row_1 + 13 
18b9 cd cd 0b			call str_at_display 
18bc cd dd 0b			call update_display 
18bf			 
18bf			 
18bf				;call demo 
18bf			 
18bf			 
18bf				; init scratch input area for cli commands 
18bf			 
18bf 21 e8 e5			ld hl, os_cli_cmd 
18c2 3e 00			ld a,0 
18c4 77				ld (hl),a 
18c5 23				inc hl 
18c6 77				ld (hl),a 
18c7			 
18c7 3e 00			ld a,0 
18c9 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cc			 
18cc 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18cf 32 e5 e5			ld (os_cur_ptr+1),a	 
18d2			 
18d2 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d5 32 c7 e5			ld (os_word_scratch+1),a	 
18d8				 
18d8			 
18d8				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d8 21 e8 e5			ld hl, os_cli_cmd 
18db			 
18db 3e 00			ld a, 0		 ; init cli input 
18dd 77				ld (hl), a 
18de 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e0			cli: 
18e0				; show cli prompt 
18e0				;push af 
18e0				;ld a, 0 
18e0				;ld de, prompt 
18e0				;call str_at_display 
18e0			 
18e0				;call update_display 
18e0				;pop af 
18e0				;inc a 
18e0				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18e0 0e 00			ld c, 0 
18e2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e4 1e 28			ld e, 40 
18e6			 
18e6 21 e8 e5			ld hl, os_cli_cmd 
18e9			 
18e9				STACKFRAME OFF $fefe $9f9f 
18e9				if DEBUG_STACK_IMB 
18e9					if OFF 
18e9						exx 
18e9						ld de, $fefe 
18e9						ld a, d 
18e9						ld hl, curframe 
18e9						call hexout 
18e9						ld a, e 
18e9						ld hl, curframe+2 
18e9						call hexout 
18e9						ld hl, $fefe 
18e9						push hl 
18e9						ld hl, $9f9f 
18e9						push hl 
18e9						exx 
18e9					endif 
18e9				endif 
18e9			endm 
# End of macro STACKFRAME
18e9			 
18e9 cd 14 0e			call input_str 
18ec			 
18ec				STACKFRAMECHK OFF $fefe $9f9f 
18ec				if DEBUG_STACK_IMB 
18ec					if OFF 
18ec						exx 
18ec						ld hl, $9f9f 
18ec						pop de   ; $9f9f 
18ec						call cmp16 
18ec						jr nz, .spnosame 
18ec						ld hl, $fefe 
18ec						pop de   ; $fefe 
18ec						call cmp16 
18ec						jr z, .spfrsame 
18ec						.spnosame: call showsperror 
18ec						.spfrsame: nop 
18ec						exx 
18ec					endif 
18ec				endif 
18ec			endm 
# End of macro STACKFRAMECHK
18ec			 
18ec				; copy input to last command 
18ec			 
18ec 21 e8 e5			ld hl, os_cli_cmd 
18ef 11 e7 e6			ld de, os_last_cmd 
18f2 01 ff 00			ld bc, 255 
18f5 ed b0			ldir 
18f7			 
18f7				; wipe current buffer 
18f7			 
18f7			;	ld a, 0 
18f7			;	ld hl, os_cli_cmd 
18f7			;	ld de, os_cli_cmd+1 
18f7			;	ld bc, 254 
18f7			;	ldir 
18f7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f7			;	call strcpy 
18f7			;	ld a, 0 
18f7			;	ld (hl), a 
18f7			;	inc hl 
18f7			;	ld (hl), a 
18f7			;	inc hl 
18f7			;	ld (hl), a 
18f7			 
18f7				; switch frame buffer to program  
18f7			 
18f7 21 10 ed				ld hl, display_fb1 
18fa 22 cc eb				ld (display_fb_active), hl 
18fd			 
18fd			;	nop 
18fd				STACKFRAME ON $fbfe $8f9f 
18fd				if DEBUG_STACK_IMB 
18fd					if ON 
18fd						exx 
18fd						ld de, $fbfe 
18fd						ld a, d 
18fd						ld hl, curframe 
18fd						call hexout 
18fd						ld a, e 
18fd						ld hl, curframe+2 
18fd						call hexout 
18fd						ld hl, $fbfe 
18fd						push hl 
18fd						ld hl, $8f9f 
18fd						push hl 
18fd						exx 
18fd					endif 
18fd				endif 
18fd			endm 
# End of macro STACKFRAME
18fd				; first time into the parser so pass over the current scratch pad 
18fd 21 e8 e5			ld hl,os_cli_cmd 
1900				; tokenise the entered statement(s) in HL 
1900 cd 42 20			call forthparse 
1903			        ; exec forth statements in top of return stack 
1903 cd 82 20			call forthexec 
1906				;call forthexec_cleanup 
1906			;	call parsenext 
1906			 
1906				STACKFRAMECHK ON $fbfe $8f9f 
1906				if DEBUG_STACK_IMB 
1906					if ON 
1906						exx 
1906						ld hl, $8f9f 
1906						pop de   ; $8f9f 
1906						call cmp16 
1906						jr nz, .spnosame 
1906						ld hl, $fbfe 
1906						pop de   ; $fbfe 
1906						call cmp16 
1906						jr z, .spfrsame 
1906						.spnosame: call showsperror 
1906						.spfrsame: nop 
1906						exx 
1906					endif 
1906				endif 
1906			endm 
# End of macro STACKFRAMECHK
1906				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1906			 
1906 3e 78			ld a, display_row_4 
1908 11 39 19			ld de, endprog 
190b			 
190b cd dd 0b			call update_display		 
190e			 
190e cd bf 1b			call next_page_prompt 
1911			 
1911				; switch frame buffer to cli 
1911			 
1911 21 b1 ed				ld hl, display_fb0 
1914 22 cc eb				ld (display_fb_active), hl 
1917			 
1917			 
1917 cd ba 0b		        call clear_display 
191a cd dd 0b			call update_display		 
191d			 
191d 21 e8 e5			ld hl, os_cli_cmd 
1920			 
1920 3e 00			ld a, 0		 ; init cli input 
1922 77				ld (hl), a 
1923			 
1923				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1923			 
1923				; now on last line 
1923			 
1923				; TODO scroll screen up 
1923			 
1923				; TODO instead just clear screen and place at top of screen 
1923			 
1923			;	ld a, 0 
1923			;	ld (f_cursor_ptr),a 
1923			 
1923				;call clear_display 
1923				;call update_display 
1923			 
1923				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1923 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1925 c3 e0 18			jp cli 
1928			 
1928 .. 00		freeram: db "Free bytes: ",0 
1935 ..			asc: db "1A2F" 
1939 .. 00		endprog: db "End prog...",0 
1945			 
1945			testenter2:   
1945 21 f3 e2			ld hl,scratch+50 
1948 22 e4 e5			ld (os_cur_ptr),hl 
194b c3 e0 18			jp cli 
194e			 
194e			testenter:  
194e			 
194e 21 35 19			ld hl,asc 
1951			;	ld a,(hl) 
1951			;	call nibble2val 
1951 cd 3e 11			call get_byte 
1954			 
1954			 
1954			;	ld a,(hl) 
1954			;	call atohex 
1954			 
1954			;	call fourehexhl 
1954 32 f3 e2			ld (scratch+50),a 
1957			 
1957			 
1957			 
1957 21 37 19			ld hl,asc+2 
195a			;	ld a, (hl) 
195a			;	call nibble2val 
195a cd 3e 11			call get_byte 
195d			 
195d			;	call fourehexhl 
195d 32 f5 e2			ld (scratch+52),a 
1960				 
1960 21 f3 e2			ld hl,scratch+50 
1963 22 e4 e5			ld (os_cur_ptr),hl 
1966 c3 e0 18			jp cli 
1969			 
1969			enter:	 
1969 3a c5 e2			ld a,(scratch+4) 
196c fe 00			cp 0 
196e 28 0c			jr z, .entercont 
1970				; no, not a null term line so has an address to work out.... 
1970			 
1970 21 c3 e2			ld hl,scratch+2 
1973 cd 9e 11			call get_word_hl 
1976			 
1976 22 e4 e5			ld (os_cur_ptr),hl	 
1979 c3 e0 18			jp cli 
197c			 
197c			 
197c			.entercont:  
197c			 
197c 21 c3 e2			ld hl, scratch+2 
197f cd 3e 11			call get_byte 
1982			 
1982 2a e4 e5		   	ld hl,(os_cur_ptr) 
1985 77					ld (hl),a 
1986 23					inc hl 
1987 22 e4 e5				ld (os_cur_ptr),hl 
198a				 
198a			; get byte  
198a			 
198a			 
198a c3 e0 18			jp cli 
198d			 
198d			 
198d			; basic monitor support 
198d			 
198d			monitor: 
198d				;  
198d cd ba 0b			call clear_display 
1990 3e 00			ld a, 0 
1992 11 e1 19			ld de, .monprompt 
1995 cd cd 0b			call str_at_display 
1998 cd dd 0b			call update_display 
199b			 
199b				; get a monitor command 
199b			 
199b 0e 00			ld c, 0     ; entry at top left 
199d 16 64			ld d, 100   ; max buffer size 
199f 1e 0f			ld e, 15    ; input scroll area 
19a1 3e 00			ld a, 0     ; init string 
19a3 21 bf e4			ld hl, os_input 
19a6 77				ld (hl), a 
19a7 23				inc hl 
19a8 77				ld (hl), a 
19a9 21 bf e4			ld hl, os_input 
19ac 3e 01			ld a, 1     ; init string 
19ae cd 14 0e			call input_str 
19b1			 
19b1 cd ba 0b		        call clear_display 
19b4 cd dd 0b			call update_display		 
19b7			 
19b7 3a bf e4			ld a, (os_input) 
19ba cd 3c 12			call toUpper 
19bd fe 48		        cp 'H' 
19bf ca 46 1a		        jp z, .monhelp 
19c2 fe 44			cp 'D'		; dump 
19c4 ca 79 1a			jp z, .mondump	 
19c7 fe 43			cp 'C'		; dump 
19c9 ca 93 1a			jp z, .moncdump	 
19cc fe 4d			cp 'M'		; dump 
19ce ca e3 19			jp z, .moneditstart 
19d1 fe 55			cp 'U'		; dump 
19d3 ca ef 19			jp z, .monedit	 
19d6 fe 47			cp 'G'		; dump 
19d8 ca 6f 1a			jp z, .monjump 
19db fe 51			cp 'Q'		; dump 
19dd c8				ret z	 
19de			 
19de			 
19de				; TODO "S" to access symbol by name and not need the address 
19de				; TODO "F" to find a string in memory 
19de			 
19de c3 8d 19			jp monitor 
19e1			 
19e1 .. 00		.monprompt: db ">", 0 
19e3			 
19e3			.moneditstart: 
19e3				; get starting address 
19e3			 
19e3 21 c1 e4			ld hl,os_input+2 
19e6 cd 9e 11			call get_word_hl 
19e9			 
19e9 22 e4 e5			ld (os_cur_ptr),hl	 
19ec			 
19ec c3 8d 19			jp monitor 
19ef			 
19ef			.monedit: 
19ef				; get byte to load 
19ef			 
19ef 21 c1 e4			ld hl,os_input+2 
19f2 cd 3e 11			call get_byte 
19f5			 
19f5				; get address to update 
19f5 2a e4 e5			ld hl, (os_cur_ptr) 
19f8			 
19f8				; update byte 
19f8			 
19f8 77				ld (hl), a 
19f9			 
19f9				; move to next address and save it 
19f9			 
19f9 23				inc hl 
19fa 22 e4 e5			ld (os_cur_ptr),hl	 
19fd			 
19fd c3 8d 19			jp monitor 
1a00			 
1a00			 
1a00 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a14 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a30 .. 00		.monhelptext3:  db "G-Call address",0 
1a3f .. 00		.monhelptext4:  db "Q-Quit",0 
1a46			        
1a46			.monhelp: 
1a46 3e 00			ld a, display_row_1 
1a48 11 00 1a		        ld de, .monhelptext1 
1a4b			 
1a4b cd cd 0b			call str_at_display 
1a4e 3e 28			ld a, display_row_2 
1a50 11 14 1a		        ld de, .monhelptext2 
1a53					 
1a53 cd cd 0b			call str_at_display 
1a56 3e 50			ld a, display_row_3 
1a58 11 30 1a		        ld de, .monhelptext3 
1a5b					 
1a5b cd cd 0b			call str_at_display 
1a5e 3e 78			ld a, display_row_4 
1a60 11 3f 1a		        ld de, .monhelptext4 
1a63 cd cd 0b			call str_at_display 
1a66			 
1a66 cd dd 0b			call update_display		 
1a69			 
1a69 cd bf 1b			call next_page_prompt 
1a6c c3 8d 19			jp monitor 
1a6f			 
1a6f			.monjump:    
1a6f 21 c1 e4			ld hl,os_input+2 
1a72 cd 9e 11			call get_word_hl 
1a75			 
1a75 e9				jp (hl) 
1a76 c3 8d 19			jp monitor 
1a79			 
1a79			.mondump:    
1a79 21 c1 e4			ld hl,os_input+2 
1a7c cd 9e 11			call get_word_hl 
1a7f			 
1a7f 22 e4 e5			ld (os_cur_ptr),hl	 
1a82 cd c7 1a			call dumpcont 
1a85 3e 78			ld a, display_row_4 
1a87 11 39 19			ld de, endprog 
1a8a			 
1a8a cd dd 0b			call update_display		 
1a8d			 
1a8d cd bf 1b			call next_page_prompt 
1a90 c3 8d 19			jp monitor 
1a93			.moncdump: 
1a93 cd c7 1a			call dumpcont 
1a96 3e 78			ld a, display_row_4 
1a98 11 39 19			ld de, endprog 
1a9b			 
1a9b cd dd 0b			call update_display		 
1a9e			 
1a9e cd bf 1b			call next_page_prompt 
1aa1 c3 8d 19			jp monitor 
1aa4			 
1aa4			 
1aa4			; TODO symbol access  
1aa4			 
1aa4			.symbols:     ;; A list of symbols that can be called up  
1aa4 b1 ed			dw display_fb0 
1aa6 .. 00			db "fb0",0  
1aaa 7a ea		     	dw store_page 
1aac .. 00			db "store_page",0 
1ab7			 
1ab7			 
1ab7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ab7			 
1ab7 3a c2 e2			ld a,(scratch+1) 
1aba fe 00			cp 0 
1abc 28 09			jr z, dumpcont 
1abe			 
1abe				; no, not a null term line so has an address to work out.... 
1abe			 
1abe 21 c3 e2			ld hl,scratch+2 
1ac1 cd 9e 11			call get_word_hl 
1ac4			 
1ac4 22 e4 e5			ld (os_cur_ptr),hl	 
1ac7			 
1ac7			 
1ac7			 
1ac7			dumpcont: 
1ac7			 
1ac7				; dump bytes at ptr 
1ac7			 
1ac7			 
1ac7 3e 00			ld a, display_row_1 
1ac9 2a cc eb			ld hl, (display_fb_active) 
1acc cd e7 0d			call addatohl 
1acf cd f7 1a			call .dumpbyterow 
1ad2			 
1ad2 3e 28			ld a, display_row_2 
1ad4 2a cc eb			ld hl, (display_fb_active) 
1ad7 cd e7 0d			call addatohl 
1ada cd f7 1a			call .dumpbyterow 
1add			 
1add			 
1add 3e 50			ld a, display_row_3 
1adf 2a cc eb			ld hl, (display_fb_active) 
1ae2 cd e7 0d			call addatohl 
1ae5 cd f7 1a			call .dumpbyterow 
1ae8			 
1ae8 3e 78			ld a, display_row_4 
1aea 2a cc eb			ld hl, (display_fb_active) 
1aed cd e7 0d			call addatohl 
1af0 cd f7 1a			call .dumpbyterow 
1af3			 
1af3 cd dd 0b			call update_display 
1af6			;		jp cli 
1af6 c9				ret 
1af7			 
1af7			.dumpbyterow: 
1af7			 
1af7				;push af 
1af7			 
1af7 e5				push hl 
1af8			 
1af8				; calc where to poke the ascii 
1af8			if display_cols == 20 
1af8				ld a, 16 
1af8			else 
1af8 3e 1f			ld a, 31 
1afa			endif 
1afa			 
1afa cd e7 0d			call addatohl 
1afd 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1b00			 
1b00			 
1b00			; display decoding address 
1b00 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b03			 
1b03 7c				ld a,h 
1b04 e1				pop hl 
1b05 e5				push hl 
1b06			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b06 cd e8 10			call hexout 
1b09 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b0c			 
1b0c 7d				ld a,l 
1b0d e1				pop hl 
1b0e 23				inc hl 
1b0f 23				inc hl 
1b10 e5				push hl 
1b11			;	ld hl, os_word_scratch+2 
1b11 cd e8 10			call hexout 
1b14 e1				pop hl 
1b15 23				inc hl 
1b16 23				inc hl 
1b17				;ld hl, os_word_scratch+4 
1b17 3e 3a			ld a, ':' 
1b19 77				ld (hl),a 
1b1a 23				inc hl 
1b1b				;ld a, 0 
1b1b				;ld (hl),a 
1b1b				;ld de, os_word_scratch 
1b1b				;pop af 
1b1b				;push af 
1b1b			;		ld a, display_row_2 
1b1b			;		call str_at_display 
1b1b			;		call update_display 
1b1b			 
1b1b			 
1b1b			;pop af 
1b1b			;	add 5 
1b1b			 
1b1b			if display_cols == 20 
1b1b				ld b, 4 
1b1b			else 
1b1b 06 08			ld b, 8 
1b1d			endif	 
1b1d			 
1b1d			.dumpbyte: 
1b1d c5				push bc 
1b1e e5				push hl 
1b1f			 
1b1f			 
1b1f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b22 7e					ld a,(hl) 
1b23			 
1b23					; poke the ascii to display 
1b23 2a c6 e5				ld hl,(os_word_scratch) 
1b26 77					ld (hl),a 
1b27 23					inc hl 
1b28 22 c6 e5				ld (os_word_scratch),hl 
1b2b			 
1b2b					 
1b2b			 
1b2b			 
1b2b e1					pop hl 
1b2c e5					push hl 
1b2d			 
1b2d cd e8 10				call hexout 
1b30			 
1b30					 
1b30 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b33 23				inc hl 
1b34 22 e4 e5		   	ld (os_cur_ptr),hl 
1b37			 
1b37 e1					pop hl 
1b38 23					inc hl 
1b39 23					inc hl 
1b3a 23					inc hl 
1b3b			 
1b3b			 
1b3b			 
1b3b					;ld a,0 
1b3b					;ld (os_word_scratch+2),a 
1b3b					;pop af 
1b3b					;push af 
1b3b			 
1b3b					;ld de, os_word_scratch 
1b3b					;call str_at_display 
1b3b			;		call update_display 
1b3b			;		pop af 
1b3b c1					pop bc 
1b3c c6 03				add 3 
1b3e 10 dd			djnz .dumpbyte 
1b40			 
1b40				 
1b40			 
1b40 c9				ret 
1b41			 
1b41			jump:	 
1b41			 
1b41 21 c3 e2			ld hl,scratch+2 
1b44 cd 9e 11			call get_word_hl 
1b47				;ld hl,(scratch+2) 
1b47				;call fourehexhl 
1b47			 
1b47 22 e4 e5			ld (os_cur_ptr),hl	 
1b4a			 
1b4a e9				jp (hl) 
1b4b			 
1b4b			 
1b4b			 
1b4b			; TODO implement a basic monitor mode to start with 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			 
1b4b			; testing and demo code during development 
1b4b			 
1b4b			 
1b4b .. 00		str1: db "Enter some text...",0 
1b5e .. 00		clear: db "                    ",0 
1b73			 
1b73			demo: 
1b73			 
1b73			 
1b73			 
1b73			;	call update_display 
1b73			 
1b73				; init scratch input area for testing 
1b73 21 c1 e2			ld hl, scratch	 
1b76 3e 00			ld a,0 
1b78 77				ld (hl),a 
1b79			 
1b79			 
1b79 3e 28		            LD   A, display_row_2 
1b7b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b7b 11 4b 1b		            LD   DE, str1 
1b7e cd cd 0b			call str_at_display 
1b81			 
1b81			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b81			cloop:	 
1b81 3e 50		            LD   A, display_row_3 
1b83			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b83 11 5e 1b		            LD   DE, clear 
1b86			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b86 cd cd 0b				call str_at_display 
1b89 3e 78			ld a, display_row_4 
1b8b 11 bb 1b			ld de, prompt 
1b8e			 
1b8e cd cd 0b				call str_at_display 
1b91 cd dd 0b			call update_display 
1b94			 
1b94 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b96 16 0a			ld d, 10 
1b98 21 c1 e2			ld hl, scratch	 
1b9b cd 14 0e			call input_str 
1b9e			 
1b9e			;	call clear_display 
1b9e			;'	call update_display 
1b9e			 
1b9e 3e 00		            LD   A, display_row_1 
1ba0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ba0 11 5e 1b		            LD   DE, clear 
1ba3 cd cd 0b				call str_at_display 
1ba6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ba6 3e 00		            LD   A, display_row_1 
1ba8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ba8 11 c1 e2		            LD   DE, scratch 
1bab			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bab cd cd 0b				call str_at_display 
1bae cd dd 0b			call update_display 
1bb1			 
1bb1 3e 00				ld a,0 
1bb3 21 c1 e2			ld hl, scratch 
1bb6 77				ld (hl),a 
1bb7			 
1bb7 00				nop 
1bb8 c3 81 1b			jp cloop 
1bbb			 
1bbb			 
1bbb			 
1bbb			; OS Prompt 
1bbb			 
1bbb .. 00		prompt: db ">",0 
1bbd .. 00		endprg: db "?",0 
1bbf			 
1bbf			 
1bbf			; handy next page prompt 
1bbf			next_page_prompt: 
1bbf e5				push hl 
1bc0 d5				push de 
1bc1 f5				push af 
1bc2 c5				push bc 
1bc3			 
1bc3 3e 9f			ld a,display_row_4 + display_cols - 1 
1bc5 11 bd 1b		        ld de, endprg 
1bc8 cd cd 0b			call str_at_display 
1bcb cd dd 0b			call update_display 
1bce cd 70 65			call cin_wait 
1bd1 c1				pop bc 
1bd2 f1				pop af 
1bd3 d1				pop de 
1bd4 e1				pop hl 
1bd5			 
1bd5			 
1bd5 c9				ret 
1bd6			 
1bd6			 
1bd6			; forth parser 
1bd6			 
1bd6			; My forth kernel 
1bd6			include "forth_kernel.asm" 
1bd6			; 
1bd6			; kernel to the forth OS 
1bd6			 
1bd6			DS_TYPE_STR: equ 1     ; string type 
1bd6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bd6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bd6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bd6			 
1bd6			FORTH_PARSEV1: equ 0 
1bd6			FORTH_PARSEV2: equ 0 
1bd6			FORTH_PARSEV3: equ 0 
1bd6			FORTH_PARSEV4: equ 0 
1bd6			FORTH_PARSEV5: equ 1 
1bd6			 
1bd6			;if FORTH_PARSEV5 
1bd6			;	FORTH_END_BUFFER: equ 0 
1bd6			;else 
1bd6			FORTH_END_BUFFER: equ 127 
1bd6			;endif 
1bd6			 
1bd6			FORTH_TRUE: equ 1 
1bd6			FORTH_FALSE: equ 0 
1bd6			 
1bd6			if FORTH_PARSEV4 
1bd6			include "forth_stackops.asm" 
1bd6			endif 
1bd6			 
1bd6			if FORTH_PARSEV5 
1bd6			include "forth_stackopsv5.asm" 
1bd6			 
1bd6			; Stack operations for v5 parser on wards 
1bd6			; * DATA stack 
1bd6			; * LOOP stack 
1bd6			; * RETURN stack 
1bd6			 
1bd6			 
1bd6			 
1bd6			FORTH_CHK_DSP_UNDER: macro 
1bd6				push hl 
1bd6				push de 
1bd6				ld hl,(cli_data_sp) 
1bd6				ld de, cli_data_stack 
1bd6				call cmp16 
1bd6				jp c, fault_dsp_under 
1bd6				pop de 
1bd6				pop hl 
1bd6				endm 
1bd6			 
1bd6			 
1bd6			FORTH_CHK_RSP_UNDER: macro 
1bd6				push hl 
1bd6				push de 
1bd6				ld hl,(cli_ret_sp) 
1bd6				ld de, cli_ret_stack 
1bd6				call cmp16 
1bd6				jp c, fault_rsp_under 
1bd6				pop de 
1bd6				pop hl 
1bd6				endm 
1bd6			 
1bd6			FORTH_CHK_LOOP_UNDER: macro 
1bd6				push hl 
1bd6				push de 
1bd6				ld hl,(cli_loop_sp) 
1bd6				ld de, cli_loop_stack 
1bd6				call cmp16 
1bd6				jp c, fault_loop_under 
1bd6				pop de 
1bd6				pop hl 
1bd6				endm 
1bd6			 
1bd6			FORTH_ERR_TOS_NOTSTR: macro 
1bd6				; TOSO might need more for checks when used 
1bd6				push af 
1bd6				ld a,(hl) 
1bd6				cp DS_TYPE_STR 
1bd6				jp nz, type_faultn   
1bd6				pop af 
1bd6				endm 
1bd6			 
1bd6			FORTH_ERR_TOS_NOTNUM: macro 
1bd6				push af 
1bd6				ld a,(hl) 
1bd6				cp DS_TYPE_INUM 
1bd6				jp nz, type_faultn   
1bd6				pop af 
1bd6				endm 
1bd6			 
1bd6			 
1bd6			; increase data stack pointer and save hl to it 
1bd6				 
1bd6			FORTH_DSP_NEXT: macro 
1bd6				call macro_forth_dsp_next 
1bd6				endm 
1bd6			 
1bd6			 
1bd6			macro_forth_dsp_next: 
1bd6				if DEBUG_FORTH_STACK_GUARD 
1bd6 cd 9f 61				call check_stacks 
1bd9				endif 
1bd9 e5				push hl 
1bda d5				push de 
1bdb eb				ex de,hl 
1bdc 2a ee e9			ld hl,(cli_data_sp) 
1bdf 23				inc hl 
1be0 23				inc hl 
1be1			 
1be1			; PARSEV5 
1be1 23				inc hl 
1be2 22 ee e9			ld (cli_data_sp),hl 
1be5 73				ld (hl), e 
1be6 23				inc hl 
1be7 72				ld (hl), d 
1be8 d1				pop de 
1be9 e1				pop hl 
1bea				if DEBUG_FORTH_STACK_GUARD 
1bea cd 9f 61				call check_stacks 
1bed				endif 
1bed c9				ret 
1bee			 
1bee			 
1bee			; increase ret stack pointer and save hl to it 
1bee				 
1bee			FORTH_RSP_NEXT: macro 
1bee				call macro_forth_rsp_next 
1bee				endm 
1bee			 
1bee			macro_forth_rsp_next: 
1bee				if DEBUG_FORTH_STACK_GUARD 
1bee cd 9f 61				call check_stacks 
1bf1				endif 
1bf1 e5				push hl 
1bf2 d5				push de 
1bf3 eb				ex de,hl 
1bf4 2a f2 e9			ld hl,(cli_ret_sp) 
1bf7 23				inc hl 
1bf8 23				inc hl 
1bf9 22 f2 e9			ld (cli_ret_sp),hl 
1bfc 73				ld (hl), e 
1bfd 23				inc hl 
1bfe 72				ld (hl), d 
1bff d1				pop de 
1c00 e1				pop hl 
1c01				if DEBUG_FORTH_STACK_GUARD 
1c01 cd 9f 61				call check_stacks 
1c04				endif 
1c04 c9				ret 
1c05			 
1c05			; get current ret stack pointer and save to hl  
1c05				 
1c05			FORTH_RSP_TOS: macro 
1c05				call macro_forth_rsp_tos 
1c05				endm 
1c05			 
1c05			macro_forth_rsp_tos: 
1c05				;push de 
1c05 2a f2 e9			ld hl,(cli_ret_sp) 
1c08 cd 40 1c			call loadhlptrtohl 
1c0b				;ld e, (hl) 
1c0b				;inc hl 
1c0b				;ld d, (hl) 
1c0b				;ex de, hl 
1c0b					if DEBUG_FORTH_WORDS 
1c0b			;			DMARK "RST" 
1c0b						CALLMONITOR 
1c0b cd 6f ee			call debug_vector  
1c0e				endm  
# End of macro CALLMONITOR
1c0e					endif 
1c0e				;pop de 
1c0e c9				ret 
1c0f			 
1c0f			; pop ret stack pointer 
1c0f				 
1c0f			FORTH_RSP_POP: macro 
1c0f				call macro_forth_rsp_pop 
1c0f				endm 
1c0f			 
1c0f			 
1c0f			macro_forth_rsp_pop: 
1c0f				if DEBUG_FORTH_STACK_GUARD 
1c0f			;		DMARK "RPP" 
1c0f cd 9f 61				call check_stacks 
1c12					FORTH_CHK_RSP_UNDER 
1c12 e5				push hl 
1c13 d5				push de 
1c14 2a f2 e9			ld hl,(cli_ret_sp) 
1c17 11 ac e9			ld de, cli_ret_stack 
1c1a cd 05 0e			call cmp16 
1c1d da b3 62			jp c, fault_rsp_under 
1c20 d1				pop de 
1c21 e1				pop hl 
1c22				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c22				endif 
1c22 e5				push hl 
1c23 2a f2 e9			ld hl,(cli_ret_sp) 
1c26			 
1c26			 
1c26				if FORTH_ENABLE_FREE 
1c26			 
1c26					; get pointer 
1c26			 
1c26					push de 
1c26					push hl 
1c26			 
1c26					ld e, (hl) 
1c26					inc hl 
1c26					ld d, (hl) 
1c26			 
1c26					ex de, hl 
1c26					call free 
1c26			 
1c26					pop hl 
1c26					pop de 
1c26			 
1c26			 
1c26				endif 
1c26			 
1c26			 
1c26 2b				dec hl 
1c27 2b				dec hl 
1c28 22 f2 e9			ld (cli_ret_sp), hl 
1c2b				; do stack underflow checks 
1c2b e1				pop hl 
1c2c				if DEBUG_FORTH_STACK_GUARD 
1c2c cd 9f 61				call check_stacks 
1c2f					FORTH_CHK_RSP_UNDER 
1c2f e5				push hl 
1c30 d5				push de 
1c31 2a f2 e9			ld hl,(cli_ret_sp) 
1c34 11 ac e9			ld de, cli_ret_stack 
1c37 cd 05 0e			call cmp16 
1c3a da b3 62			jp c, fault_rsp_under 
1c3d d1				pop de 
1c3e e1				pop hl 
1c3f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c3f				endif 
1c3f c9				ret 
1c40			 
1c40			 
1c40			 
1c40			; routine to load word pointed to by hl into hl 
1c40			 
1c40			loadhlptrtohl: 
1c40			 
1c40 d5				push de 
1c41 5e				ld e, (hl) 
1c42 23				inc hl 
1c43 56				ld d, (hl) 
1c44 eb				ex de, hl 
1c45 d1				pop de 
1c46			 
1c46 c9				ret 
1c47			 
1c47			 
1c47			 
1c47			 
1c47			 
1c47			; push a number held in HL onto the data stack 
1c47			; entry point for pushing a value when already in hl used in function above 
1c47			 
1c47			forth_push_numhl: 
1c47			 
1c47 e5				push hl    ; save value to push 
1c48			 
1c48			if DEBUG_FORTH_PUSH 
1c48				; see if disabled 
1c48			 
1c48			 
1c48 f5				push af 
1c49 3a 6f ee			ld a,(debug_vector) 
1c4c fe c9			cp $c9   ; ret 
1c4e			;	ld a, (os_view_disable) 
1c4e			;	cp '*' 
1c4e 28 34			jr z, .pskip2 
1c50 e5				push hl 
1c51 e5			push hl 
1c52 cd ba 0b			call clear_display 
1c55 e1			pop hl 
1c56 7c				ld a,h 
1c57 21 c6 e5			ld hl, os_word_scratch 
1c5a cd e8 10			call hexout 
1c5d e1				pop hl 
1c5e 7d				ld a,l 
1c5f 21 c8 e5			ld hl, os_word_scratch+2 
1c62 cd e8 10			call hexout 
1c65			 
1c65 21 ca e5			ld hl, os_word_scratch+4 
1c68 3e 00			ld a,0 
1c6a 77				ld (hl),a 
1c6b 11 c6 e5			ld de,os_word_scratch 
1c6e 3e 28				ld a, display_row_2 
1c70 cd cd 0b				call str_at_display 
1c73 11 db 4c			ld de, .push_num 
1c76 3e 00			ld a, display_row_1 
1c78			 
1c78 cd cd 0b				call str_at_display 
1c7b			 
1c7b			 
1c7b cd dd 0b			call update_display 
1c7e cd f2 0a			call delay1s 
1c81 cd f2 0a			call delay1s 
1c84			.pskip2:  
1c84			 
1c84 f1				pop af 
1c85			endif	 
1c85			 
1c85			 
1c85				FORTH_DSP_NEXT 
1c85 cd d6 1b			call macro_forth_dsp_next 
1c88				endm 
# End of macro FORTH_DSP_NEXT
1c88			 
1c88 2a ee e9			ld hl, (cli_data_sp) 
1c8b			 
1c8b				; save item type 
1c8b 3e 02			ld a,  DS_TYPE_INUM 
1c8d 77				ld (hl), a 
1c8e 23				inc hl 
1c8f			 
1c8f				; get word off stack 
1c8f d1				pop de 
1c90 7b				ld a,e 
1c91 77				ld (hl), a 
1c92 23				inc hl 
1c93 7a				ld a,d 
1c94 77				ld (hl), a 
1c95			 
1c95			if DEBUG_FORTH_PUSH 
1c95 2b				dec hl 
1c96 2b				dec hl 
1c97 2b				dec hl 
1c98						DMARK "PH5" 
1c98 f5				push af  
1c99 3a ad 1c			ld a, (.dmark)  
1c9c 32 6b ee			ld (debug_mark),a  
1c9f 3a ae 1c			ld a, (.dmark+1)  
1ca2 32 6c ee			ld (debug_mark+1),a  
1ca5 3a af 1c			ld a, (.dmark+2)  
1ca8 32 6d ee			ld (debug_mark+2),a  
1cab 18 03			jr .pastdmark  
1cad ..			.dmark: db "PH5"  
1cb0 f1			.pastdmark: pop af  
1cb1			endm  
# End of macro DMARK
1cb1				CALLMONITOR 
1cb1 cd 6f ee			call debug_vector  
1cb4				endm  
# End of macro CALLMONITOR
1cb4			endif	 
1cb4			 
1cb4 c9				ret 
1cb5			 
1cb5			 
1cb5			; Push a string to stack pointed to by hl 
1cb5			 
1cb5			forth_push_str: 
1cb5			 
1cb5			if DEBUG_FORTH_PUSH 
1cb5						DMARK "PSQ" 
1cb5 f5				push af  
1cb6 3a ca 1c			ld a, (.dmark)  
1cb9 32 6b ee			ld (debug_mark),a  
1cbc 3a cb 1c			ld a, (.dmark+1)  
1cbf 32 6c ee			ld (debug_mark+1),a  
1cc2 3a cc 1c			ld a, (.dmark+2)  
1cc5 32 6d ee			ld (debug_mark+2),a  
1cc8 18 03			jr .pastdmark  
1cca ..			.dmark: db "PSQ"  
1ccd f1			.pastdmark: pop af  
1cce			endm  
# End of macro DMARK
1cce				CALLMONITOR 
1cce cd 6f ee			call debug_vector  
1cd1				endm  
# End of macro CALLMONITOR
1cd1			endif	 
1cd1			    
1cd1 e5				push hl 
1cd2 e5				push hl 
1cd3			 
1cd3			;	ld a, 0   ; find end of string 
1cd3 cd 45 12			call strlenz 
1cd6			if DEBUG_FORTH_PUSH 
1cd6						DMARK "PQ2" 
1cd6 f5				push af  
1cd7 3a eb 1c			ld a, (.dmark)  
1cda 32 6b ee			ld (debug_mark),a  
1cdd 3a ec 1c			ld a, (.dmark+1)  
1ce0 32 6c ee			ld (debug_mark+1),a  
1ce3 3a ed 1c			ld a, (.dmark+2)  
1ce6 32 6d ee			ld (debug_mark+2),a  
1ce9 18 03			jr .pastdmark  
1ceb ..			.dmark: db "PQ2"  
1cee f1			.pastdmark: pop af  
1cef			endm  
# End of macro DMARK
1cef				CALLMONITOR 
1cef cd 6f ee			call debug_vector  
1cf2				endm  
# End of macro CALLMONITOR
1cf2			endif	 
1cf2 eb				ex de, hl 
1cf3 e1				pop hl   ; get ptr to start of string 
1cf4			if DEBUG_FORTH_PUSH 
1cf4						DMARK "PQ3" 
1cf4 f5				push af  
1cf5 3a 09 1d			ld a, (.dmark)  
1cf8 32 6b ee			ld (debug_mark),a  
1cfb 3a 0a 1d			ld a, (.dmark+1)  
1cfe 32 6c ee			ld (debug_mark+1),a  
1d01 3a 0b 1d			ld a, (.dmark+2)  
1d04 32 6d ee			ld (debug_mark+2),a  
1d07 18 03			jr .pastdmark  
1d09 ..			.dmark: db "PQ3"  
1d0c f1			.pastdmark: pop af  
1d0d			endm  
# End of macro DMARK
1d0d				CALLMONITOR 
1d0d cd 6f ee			call debug_vector  
1d10				endm  
# End of macro CALLMONITOR
1d10			endif	 
1d10 19				add hl,de 
1d11			if DEBUG_FORTH_PUSH 
1d11						DMARK "PQE" 
1d11 f5				push af  
1d12 3a 26 1d			ld a, (.dmark)  
1d15 32 6b ee			ld (debug_mark),a  
1d18 3a 27 1d			ld a, (.dmark+1)  
1d1b 32 6c ee			ld (debug_mark+1),a  
1d1e 3a 28 1d			ld a, (.dmark+2)  
1d21 32 6d ee			ld (debug_mark+2),a  
1d24 18 03			jr .pastdmark  
1d26 ..			.dmark: db "PQE"  
1d29 f1			.pastdmark: pop af  
1d2a			endm  
# End of macro DMARK
1d2a				CALLMONITOR 
1d2a cd 6f ee			call debug_vector  
1d2d				endm  
# End of macro CALLMONITOR
1d2d			endif	 
1d2d			 
1d2d 2b				dec hl    ; see if there is an optional trailing double quote 
1d2e 7e				ld a,(hl) 
1d2f fe 22			cp '"' 
1d31 20 03			jr nz, .strnoq 
1d33 3e 00			ld a, 0      ; get rid of double quote 
1d35 77				ld (hl), a 
1d36 23			.strnoq: inc hl 
1d37			 
1d37 3e 00			ld a, 0 
1d39 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d3a			 
1d3a 13				inc de ; add one for the type string 
1d3b 13				inc de ; add one for null term??? 
1d3c			 
1d3c				; tos is get string pointer again 
1d3c				; de contains space to allocate 
1d3c				 
1d3c d5				push de 
1d3d			 
1d3d eb				ex de, hl 
1d3e			 
1d3e				;push af 
1d3e			 
1d3e			if DEBUG_FORTH_PUSH 
1d3e						DMARK "PHm" 
1d3e f5				push af  
1d3f 3a 53 1d			ld a, (.dmark)  
1d42 32 6b ee			ld (debug_mark),a  
1d45 3a 54 1d			ld a, (.dmark+1)  
1d48 32 6c ee			ld (debug_mark+1),a  
1d4b 3a 55 1d			ld a, (.dmark+2)  
1d4e 32 6d ee			ld (debug_mark+2),a  
1d51 18 03			jr .pastdmark  
1d53 ..			.dmark: db "PHm"  
1d56 f1			.pastdmark: pop af  
1d57			endm  
# End of macro DMARK
1d57				CALLMONITOR 
1d57 cd 6f ee			call debug_vector  
1d5a				endm  
# End of macro CALLMONITOR
1d5a			endif	 
1d5a cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d5d				if DEBUG_FORTH_MALLOC_GUARD 
1d5d cc 33 4d				call z,malloc_error 
1d60				endif 
1d60			 
1d60				 
1d60 c1				pop bc    ; get length 
1d61 d1				pop de   ;  get string start    
1d62			 
1d62				; hl has destination from malloc 
1d62			 
1d62 eb				ex de, hl    ; prep for ldir 
1d63			 
1d63 d5				push de   ; save malloc area for DSP later 
1d64				;push hl   ; save malloc area for DSP later 
1d64			 
1d64			if DEBUG_FORTH_PUSH 
1d64						DMARK "PHc" 
1d64 f5				push af  
1d65 3a 79 1d			ld a, (.dmark)  
1d68 32 6b ee			ld (debug_mark),a  
1d6b 3a 7a 1d			ld a, (.dmark+1)  
1d6e 32 6c ee			ld (debug_mark+1),a  
1d71 3a 7b 1d			ld a, (.dmark+2)  
1d74 32 6d ee			ld (debug_mark+2),a  
1d77 18 03			jr .pastdmark  
1d79 ..			.dmark: db "PHc"  
1d7c f1			.pastdmark: pop af  
1d7d			endm  
# End of macro DMARK
1d7d				CALLMONITOR 
1d7d cd 6f ee			call debug_vector  
1d80				endm  
# End of macro CALLMONITOR
1d80			endif	 
1d80			 
1d80			 
1d80 ed b0			ldir 
1d82			 
1d82			 
1d82				; push malloc to data stack     macro?????  
1d82			 
1d82				FORTH_DSP_NEXT 
1d82 cd d6 1b			call macro_forth_dsp_next 
1d85				endm 
# End of macro FORTH_DSP_NEXT
1d85			 
1d85				; save value and type 
1d85			 
1d85 2a ee e9			ld hl, (cli_data_sp) 
1d88			 
1d88				; save item type 
1d88 3e 01			ld a,  DS_TYPE_STR 
1d8a 77				ld (hl), a 
1d8b 23				inc hl 
1d8c			 
1d8c				; get malloc word off stack 
1d8c d1				pop de 
1d8d 73				ld (hl), e 
1d8e 23				inc hl 
1d8f 72				ld (hl), d 
1d90			 
1d90			 
1d90			 
1d90			if DEBUG_FORTH_PUSH 
1d90 2a ee e9			ld hl, (cli_data_sp) 
1d93						DMARK "PHS" 
1d93 f5				push af  
1d94 3a a8 1d			ld a, (.dmark)  
1d97 32 6b ee			ld (debug_mark),a  
1d9a 3a a9 1d			ld a, (.dmark+1)  
1d9d 32 6c ee			ld (debug_mark+1),a  
1da0 3a aa 1d			ld a, (.dmark+2)  
1da3 32 6d ee			ld (debug_mark+2),a  
1da6 18 03			jr .pastdmark  
1da8 ..			.dmark: db "PHS"  
1dab f1			.pastdmark: pop af  
1dac			endm  
# End of macro DMARK
1dac				CALLMONITOR 
1dac cd 6f ee			call debug_vector  
1daf				endm  
# End of macro CALLMONITOR
1daf			;	ex de,hl 
1daf			endif	 
1daf				; in case of spaces, skip the ptr past the copied string 
1daf				;pop af 
1daf				;ld (cli_origptr),hl 
1daf			 
1daf c9				ret 
1db0			 
1db0			 
1db0			 
1db0			; TODO ascii push input onto stack given hl to start of input 
1db0			 
1db0			; identify type 
1db0			; if starts with a " then a string 
1db0			; otherwise it is a number 
1db0			;  
1db0			; if a string 
1db0			;     scan for ending " to get length of string to malloc for + 1 
1db0			;     malloc 
1db0			;     put pointer to string on stack first byte flags as string 
1db0			; 
1db0			; else a number 
1db0			;    look for number format identifier 
1db0			;    $xx hex 
1db0			;    %xxxxx bin 
1db0			;    xxxxx decimal 
1db0			;    convert number to 16bit word.  
1db0			;    malloc word + 1 with flag to identiy as num 
1db0			;    put pointer to number on stack 
1db0			;   
1db0			;  
1db0			  
1db0			forth_apush: 
1db0				; kernel push 
1db0			 
1db0			if DEBUG_FORTH_PUSH 
1db0						DMARK "PSH" 
1db0 f5				push af  
1db1 3a c5 1d			ld a, (.dmark)  
1db4 32 6b ee			ld (debug_mark),a  
1db7 3a c6 1d			ld a, (.dmark+1)  
1dba 32 6c ee			ld (debug_mark+1),a  
1dbd 3a c7 1d			ld a, (.dmark+2)  
1dc0 32 6d ee			ld (debug_mark+2),a  
1dc3 18 03			jr .pastdmark  
1dc5 ..			.dmark: db "PSH"  
1dc8 f1			.pastdmark: pop af  
1dc9			endm  
# End of macro DMARK
1dc9				CALLMONITOR 
1dc9 cd 6f ee			call debug_vector  
1dcc				endm  
# End of macro CALLMONITOR
1dcc			endif	 
1dcc				; identify input type 
1dcc			 
1dcc 7e				ld a,(hl) 
1dcd fe 22			cp '"' 
1dcf 28 0a			jr z, .fapstr 
1dd1 fe 24			cp '$' 
1dd3 ca fb 1d			jp z, .faphex 
1dd6 fe 25			cp '%' 
1dd8 ca e3 1d			jp z, .fapbin 
1ddb			;	cp 'b' 
1ddb			;	jp z, .fabin 
1ddb				; else decimal 
1ddb			 
1ddb				; TODO do decimal conversion 
1ddb				; decimal is stored as a 16bit word 
1ddb			 
1ddb				; by default everything is a string if type is not detected 
1ddb			.fapstr: ; 
1ddb fe 22			cp '"' 
1ddd 20 01			jr nz, .strnoqu 
1ddf 23				inc hl 
1de0			.strnoqu: 
1de0 c3 b5 1c			jp forth_push_str 
1de3			 
1de3			 
1de3			 
1de3			.fapbin:    ; push a binary string.  
1de3 11 00 00			ld de, 0   ; hold a 16bit value 
1de6			 
1de6 23			.fapbinshift:	inc hl  
1de7 7e				ld a,(hl) 
1de8 fe 00			cp 0     ; done scanning  
1dea 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dec			 
1dec				; left shift de 
1dec eb				ex de, hl	 
1ded 29				add hl, hl 
1dee			 
1dee				; is 1 
1dee fe 31			cp '1' 
1df0 20 02			jr nz, .binzero 
1df2 cb 4d			bit 1, l 
1df4			.binzero: 
1df4 eb				ex de, hl	 ; save current de 
1df5 18 ef			jr .fapbinshift 
1df7			 
1df7			.fapbdone: 
1df7 eb				ex de, hl 
1df8 c3 47 1c			jp forth_push_numhl 
1dfb			 
1dfb			 
1dfb			.faphex:   ; hex is always stored as a 16bit word 
1dfb				; skip number prefix 
1dfb 23				inc hl 
1dfc				; turn ascii into number 
1dfc cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1dff			 
1dff c3 47 1c			jp forth_push_numhl 
1e02			 
1e02 00				 nop 
1e03			 
1e03			.fabin:   ; TODO bin conversion 
1e03			 
1e03			 
1e03 c9				ret 
1e04			 
1e04			 
1e04			; get either a string ptr or a 16bit word from the data stack 
1e04			 
1e04			FORTH_DSP: macro 
1e04				call macro_forth_dsp 
1e04				endm 
1e04			 
1e04			macro_forth_dsp: 
1e04				; data stack pointer points to current word on tos 
1e04			 
1e04 2a ee e9			ld hl,(cli_data_sp) 
1e07			 
1e07				if DEBUG_FORTH_PUSH 
1e07						DMARK "DSP" 
1e07 f5				push af  
1e08 3a 1c 1e			ld a, (.dmark)  
1e0b 32 6b ee			ld (debug_mark),a  
1e0e 3a 1d 1e			ld a, (.dmark+1)  
1e11 32 6c ee			ld (debug_mark+1),a  
1e14 3a 1e 1e			ld a, (.dmark+2)  
1e17 32 6d ee			ld (debug_mark+2),a  
1e1a 18 03			jr .pastdmark  
1e1c ..			.dmark: db "DSP"  
1e1f f1			.pastdmark: pop af  
1e20			endm  
# End of macro DMARK
1e20			 
1e20 cd 66 4d				call display_data_sp 
1e23				;call break_point_state 
1e23				;rst 030h 
1e23				CALLMONITOR 
1e23 cd 6f ee			call debug_vector  
1e26				endm  
# End of macro CALLMONITOR
1e26				endif 
1e26			 
1e26 c9				ret 
1e27			 
1e27			; return hl to start of value on stack 
1e27			 
1e27			FORTH_DSP_VALUE: macro 
1e27				call macro_forth_dsp_value 
1e27				endm 
1e27			 
1e27			macro_forth_dsp_value: 
1e27			 
1e27				FORTH_DSP 
1e27 cd 04 1e			call macro_forth_dsp 
1e2a				endm 
# End of macro FORTH_DSP
1e2a			 
1e2a d5				push de 
1e2b			 
1e2b 23				inc hl ; skip type 
1e2c			 
1e2c 5e				ld e, (hl) 
1e2d 23				inc hl 
1e2e 56				ld d, (hl) 
1e2f eb				ex de,hl  
1e30			 
1e30 d1				pop de 
1e31			 
1e31 c9				ret 
1e32			 
1e32			; return hl to start of value to second item on stack 
1e32			 
1e32			FORTH_DSP_VALUEM1: macro 
1e32				call macro_forth_dsp_value_m1 
1e32				endm 
1e32			 
1e32			macro_forth_dsp_value_m1: 
1e32			 
1e32				FORTH_DSP 
1e32 cd 04 1e			call macro_forth_dsp 
1e35				endm 
# End of macro FORTH_DSP
1e35			 
1e35 2b				dec hl 
1e36 2b				dec hl 
1e37			;	dec hl 
1e37			 
1e37 d5				push de 
1e38			 
1e38 5e				ld e, (hl) 
1e39 23				inc hl 
1e3a 56				ld d, (hl) 
1e3b eb				ex de,hl  
1e3c			 
1e3c d1				pop de 
1e3d			 
1e3d c9				ret 
1e3e			 
1e3e				 
1e3e			 
1e3e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e3e			 
1e3e			FORTH_DSP_POP: macro 
1e3e				call macro_forth_dsp_pop 
1e3e				endm 
1e3e			 
1e3e			 
1e3e			; get the tos data type 
1e3e			 
1e3e			FORTH_DSP_TYPE:   macro 
1e3e			 
1e3e				;FORTH_DSP_VALUE 
1e3e				FORTH_DSP 
1e3e				 
1e3e				; hl points to value 
1e3e				; check type 
1e3e			 
1e3e				ld a,(hl) 
1e3e			 
1e3e				endm 
1e3e			 
1e3e			; load the tos value into hl 
1e3e			 
1e3e			 
1e3e			FORTH_DSP_VALUEHL:  macro 
1e3e				call macro_dsp_valuehl 
1e3e				endm 
1e3e			 
1e3e			 
1e3e			 
1e3e			macro_dsp_valuehl: 
1e3e				FORTH_DSP_VALUE 
1e3e cd 27 1e			call macro_forth_dsp_value 
1e41				endm 
# End of macro FORTH_DSP_VALUE
1e41			 
1e41				;FORTH_ERR_TOS_NOTNUM 
1e41			 
1e41				;inc hl   ; skip type id 
1e41			 
1e41			;	push de 
1e41			; 
1e41			;	ld e, (hl) 
1e41			;	inc hl 
1e41			;	ld d, (hl) 
1e41			;	ex de,hl  
1e41			 
1e41			;	pop de 
1e41			 
1e41				if DEBUG_FORTH_PUSH 
1e41						DMARK "DVL" 
1e41 f5				push af  
1e42 3a 56 1e			ld a, (.dmark)  
1e45 32 6b ee			ld (debug_mark),a  
1e48 3a 57 1e			ld a, (.dmark+1)  
1e4b 32 6c ee			ld (debug_mark+1),a  
1e4e 3a 58 1e			ld a, (.dmark+2)  
1e51 32 6d ee			ld (debug_mark+2),a  
1e54 18 03			jr .pastdmark  
1e56 ..			.dmark: db "DVL"  
1e59 f1			.pastdmark: pop af  
1e5a			endm  
# End of macro DMARK
1e5a				CALLMONITOR 
1e5a cd 6f ee			call debug_vector  
1e5d				endm  
# End of macro CALLMONITOR
1e5d				endif 
1e5d c9				ret 
1e5e			 
1e5e			forth_apushstrhl:      
1e5e				; push of string requires use of cli_origptr 
1e5e				; bodge use 
1e5e			 
1e5e				; get current cli_origptr, save, update with temp pointer  
1e5e ed 5b 3e ea		ld de, (cli_origptr) 
1e62 22 3e ea			ld (cli_origptr), hl 
1e65 d5				push de 
1e66 cd b0 1d			call forth_apush 
1e69 d1				pop de 
1e6a ed 53 3e ea		ld (cli_origptr), de 
1e6e c9			        ret	 
1e6f			 
1e6f			 
1e6f			; increase loop stack pointer and save hl to it 
1e6f				 
1e6f			FORTH_LOOP_NEXT: macro 
1e6f				call macro_forth_loop_next 
1e6f				;nop 
1e6f				endm 
1e6f			 
1e6f			macro_forth_loop_next: 
1e6f				if DEBUG_FORTH_STACK_GUARD 
1e6f cd 9f 61				call check_stacks 
1e72				endif 
1e72 e5				push hl 
1e73 d5				push de 
1e74 eb				ex de,hl 
1e75 2a f0 e9			ld hl,(cli_loop_sp) 
1e78 23				inc hl 
1e79 23				inc hl 
1e7a					if DEBUG_FORTH_WORDS 
1e7a						DMARK "LNX" 
1e7a f5				push af  
1e7b 3a 8f 1e			ld a, (.dmark)  
1e7e 32 6b ee			ld (debug_mark),a  
1e81 3a 90 1e			ld a, (.dmark+1)  
1e84 32 6c ee			ld (debug_mark+1),a  
1e87 3a 91 1e			ld a, (.dmark+2)  
1e8a 32 6d ee			ld (debug_mark+2),a  
1e8d 18 03			jr .pastdmark  
1e8f ..			.dmark: db "LNX"  
1e92 f1			.pastdmark: pop af  
1e93			endm  
# End of macro DMARK
1e93						CALLMONITOR 
1e93 cd 6f ee			call debug_vector  
1e96				endm  
# End of macro CALLMONITOR
1e96					endif 
1e96 22 f0 e9			ld (cli_loop_sp),hl 
1e99 73				ld (hl), e 
1e9a 23				inc hl 
1e9b 72				ld (hl), d 
1e9c d1				pop de    ; been reversed so save a swap on restore 
1e9d e1				pop hl 
1e9e				if DEBUG_FORTH_STACK_GUARD 
1e9e cd 9f 61				call check_stacks 
1ea1				endif 
1ea1 c9				ret 
1ea2			 
1ea2			; get current ret stack pointer and save to hl  
1ea2				 
1ea2			FORTH_LOOP_TOS: macro 
1ea2				call macro_forth_loop_tos 
1ea2				endm 
1ea2			 
1ea2			macro_forth_loop_tos: 
1ea2 d5				push de 
1ea3 2a f0 e9			ld hl,(cli_loop_sp) 
1ea6 5e				ld e, (hl) 
1ea7 23				inc hl 
1ea8 56				ld d, (hl) 
1ea9 eb				ex de, hl 
1eaa d1				pop de 
1eab c9				ret 
1eac			 
1eac			; pop loop stack pointer 
1eac				 
1eac			FORTH_LOOP_POP: macro 
1eac				call macro_forth_loop_pop 
1eac				endm 
1eac			 
1eac			 
1eac			macro_forth_loop_pop: 
1eac				if DEBUG_FORTH_STACK_GUARD 
1eac					DMARK "LPP" 
1eac f5				push af  
1ead 3a c1 1e			ld a, (.dmark)  
1eb0 32 6b ee			ld (debug_mark),a  
1eb3 3a c2 1e			ld a, (.dmark+1)  
1eb6 32 6c ee			ld (debug_mark+1),a  
1eb9 3a c3 1e			ld a, (.dmark+2)  
1ebc 32 6d ee			ld (debug_mark+2),a  
1ebf 18 03			jr .pastdmark  
1ec1 ..			.dmark: db "LPP"  
1ec4 f1			.pastdmark: pop af  
1ec5			endm  
# End of macro DMARK
1ec5 cd 9f 61				call check_stacks 
1ec8					FORTH_CHK_LOOP_UNDER 
1ec8 e5				push hl 
1ec9 d5				push de 
1eca 2a f0 e9			ld hl,(cli_loop_sp) 
1ecd 11 2a e9			ld de, cli_loop_stack 
1ed0 cd 05 0e			call cmp16 
1ed3 da b9 62			jp c, fault_loop_under 
1ed6 d1				pop de 
1ed7 e1				pop hl 
1ed8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ed8				endif 
1ed8 e5				push hl 
1ed9 2a f0 e9			ld hl,(cli_loop_sp) 
1edc 2b				dec hl 
1edd 2b				dec hl 
1ede 22 f0 e9			ld (cli_loop_sp), hl 
1ee1				; TODO do stack underflow checks 
1ee1 e1				pop hl 
1ee2				if DEBUG_FORTH_STACK_GUARD 
1ee2 cd 9f 61				call check_stacks 
1ee5					FORTH_CHK_LOOP_UNDER 
1ee5 e5				push hl 
1ee6 d5				push de 
1ee7 2a f0 e9			ld hl,(cli_loop_sp) 
1eea 11 2a e9			ld de, cli_loop_stack 
1eed cd 05 0e			call cmp16 
1ef0 da b9 62			jp c, fault_loop_under 
1ef3 d1				pop de 
1ef4 e1				pop hl 
1ef5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ef5				endif 
1ef5 c9				ret 
1ef6			 
1ef6			macro_forth_dsp_pop: 
1ef6			 
1ef6 e5				push hl 
1ef7			 
1ef7				; release malloc data 
1ef7			 
1ef7				if DEBUG_FORTH_STACK_GUARD 
1ef7 cd 9f 61				call check_stacks 
1efa					FORTH_CHK_DSP_UNDER 
1efa e5				push hl 
1efb d5				push de 
1efc 2a ee e9			ld hl,(cli_data_sp) 
1eff 11 28 e8			ld de, cli_data_stack 
1f02 cd 05 0e			call cmp16 
1f05 da ad 62			jp c, fault_dsp_under 
1f08 d1				pop de 
1f09 e1				pop hl 
1f0a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f0a				endif 
1f0a				;ld hl,(cli_data_sp) 
1f0a			if DEBUG_FORTH_DOT 
1f0a				DMARK "DPP" 
1f0a f5				push af  
1f0b 3a 1f 1f			ld a, (.dmark)  
1f0e 32 6b ee			ld (debug_mark),a  
1f11 3a 20 1f			ld a, (.dmark+1)  
1f14 32 6c ee			ld (debug_mark+1),a  
1f17 3a 21 1f			ld a, (.dmark+2)  
1f1a 32 6d ee			ld (debug_mark+2),a  
1f1d 18 03			jr .pastdmark  
1f1f ..			.dmark: db "DPP"  
1f22 f1			.pastdmark: pop af  
1f23			endm  
# End of macro DMARK
1f23				CALLMONITOR 
1f23 cd 6f ee			call debug_vector  
1f26				endm  
# End of macro CALLMONITOR
1f26			endif	 
1f26			 
1f26			 
1f26			if FORTH_ENABLE_DSPPOPFREE 
1f26			 
1f26				FORTH_DSP 
1f26 cd 04 1e			call macro_forth_dsp 
1f29				endm 
# End of macro FORTH_DSP
1f29			 
1f29 7e				ld a, (hl) 
1f2a fe 01			cp DS_TYPE_STR 
1f2c 20 23			jr nz, .skippopfree 
1f2e			 
1f2e				FORTH_DSP_VALUEHL 
1f2e cd 3e 1e			call macro_dsp_valuehl 
1f31				endm 
# End of macro FORTH_DSP_VALUEHL
1f31 00				nop 
1f32			if DEBUG_FORTH_DOT 
1f32				DMARK "DPf" 
1f32 f5				push af  
1f33 3a 47 1f			ld a, (.dmark)  
1f36 32 6b ee			ld (debug_mark),a  
1f39 3a 48 1f			ld a, (.dmark+1)  
1f3c 32 6c ee			ld (debug_mark+1),a  
1f3f 3a 49 1f			ld a, (.dmark+2)  
1f42 32 6d ee			ld (debug_mark+2),a  
1f45 18 03			jr .pastdmark  
1f47 ..			.dmark: db "DPf"  
1f4a f1			.pastdmark: pop af  
1f4b			endm  
# End of macro DMARK
1f4b				CALLMONITOR 
1f4b cd 6f ee			call debug_vector  
1f4e				endm  
# End of macro CALLMONITOR
1f4e			endif	 
1f4e cd 78 13			call free 
1f51			.skippopfree: 
1f51				 
1f51			 
1f51			endif 
1f51			 
1f51			if DEBUG_FORTH_DOT_KEY 
1f51				DMARK "DP2" 
1f51				CALLMONITOR 
1f51			endif	 
1f51			 
1f51				; move pointer down 
1f51			 
1f51 2a ee e9			ld hl,(cli_data_sp) 
1f54 2b				dec hl 
1f55 2b				dec hl 
1f56			; PARSEV5 
1f56 2b				dec hl 
1f57 22 ee e9			ld (cli_data_sp), hl 
1f5a			 
1f5a				if DEBUG_FORTH_STACK_GUARD 
1f5a cd 9f 61				call check_stacks 
1f5d					FORTH_CHK_DSP_UNDER 
1f5d e5				push hl 
1f5e d5				push de 
1f5f 2a ee e9			ld hl,(cli_data_sp) 
1f62 11 28 e8			ld de, cli_data_stack 
1f65 cd 05 0e			call cmp16 
1f68 da ad 62			jp c, fault_dsp_under 
1f6b d1				pop de 
1f6c e1				pop hl 
1f6d				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6d				endif 
1f6d			 
1f6d e1				pop hl 
1f6e			 
1f6e c9				ret 
1f6f			 
1f6f			getwordathl: 
1f6f				; hl points to an address 
1f6f				; load hl with the word at that address 
1f6f			 
1f6f d5				push de 
1f70			 
1f70 5e				ld e, (hl) 
1f71 23				inc hl 
1f72 56				ld d, (hl) 
1f73 eb				ex de, hl 
1f74			 
1f74 d1				pop de 
1f75 c9				ret 
1f76			 
1f76			 
1f76			 
1f76			 
1f76			 
1f76			; eof 
1f76			 
# End of file forth_stackopsv5.asm
1f76			endif 
1f76			 
1f76			loadwordinhl:	 
1f76			 
1f76 d5				push de 
1f77			 
1f77 5e				ld e, (hl) 
1f78 23				inc hl 
1f79 56				ld d, (hl) 
1f7a eb				ex de,hl  
1f7b			 
1f7b d1				pop de 
1f7c			 
1f7c c9				ret 
1f7d			 
1f7d			user_word_eol:  
1f7d				; hl contains the pointer to where to create a linked list item from the end 
1f7d				; of the user dict to continue on at the system word dict 
1f7d				 
1f7d				; poke the stub of the word list linked list to repoint to rom words 
1f7d			 
1f7d				; stub format 
1f7d				; db   word id 
1f7d				; dw    link to next word 
1f7d			        ; db char length of token 
1f7d				; db string + 0 term 
1f7d				; db exec code....  
1f7d			 
1f7d 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f7f 77				ld (hl), a		; word id 
1f80 23				inc hl 
1f81			 
1f81 11 4c 21			ld de, sysdict 
1f84 73				ld (hl), e		; next word link ie system dict 
1f85 23				inc hl 
1f86 72				ld (hl), d		; next word link ie system dict 
1f87 23				inc hl	 
1f88			 
1f88			;	ld (hl), sysdict		; next word link ie system dict 
1f88			;	inc hl 
1f88			;	inc hl 
1f88			 
1f88			;	inc hl 
1f88			;	inc hl 
1f88			 
1f88 3e 02			ld a, 2			; word length is 0 
1f8a 77				ld (hl), a	 
1f8b 23				inc hl 
1f8c			 
1f8c 3e 7e			ld a, '~'			; word length is 0 
1f8e 77				ld (hl), a	 
1f8f 23				inc hl 
1f90 3e 00			ld a, 0			; save empty word 
1f92 77				ld (hl), a 
1f93			 
1f93 c9				ret 
1f94			 
1f94				 
1f94			 
1f94			forthexec_cleanup: 
1f94				FORTH_RSP_POP 
1f94 cd 0f 1c			call macro_forth_rsp_pop 
1f97				endm 
# End of macro FORTH_RSP_POP
1f97 c9				ret 
1f98			 
1f98			forth_call_hl: 
1f98				; taking hl 
1f98 e5				push hl 
1f99 c9				ret 
1f9a			 
1f9a			; this is called to reset Forth system but keep existing uwords etc 
1f9a			 
1f9a			forth_warmstart: 
1f9a				; setup stack over/under flow checks 
1f9a				if DEBUG_FORTH_STACK_GUARD 
1f9a cd 85 61				call chk_stk_init 
1f9d				endif 
1f9d			 
1f9d				; init stack pointers  - * these stacks go upwards *  
1f9d 21 ac e9			ld hl, cli_ret_stack 
1fa0 22 f2 e9			ld (cli_ret_sp), hl	 
1fa3				; set bottom of stack 
1fa3 3e 00			ld a,0 
1fa5 77				ld (hl),a 
1fa6 23				inc hl 
1fa7 77				ld (hl),a 
1fa8			 
1fa8 21 28 e8			ld hl, cli_data_stack 
1fab 22 ee e9			ld (cli_data_sp), hl	 
1fae				; set bottom of stack 
1fae 3e 00			ld a,0 
1fb0 77				ld (hl),a 
1fb1 23				inc hl 
1fb2 77				ld (hl),a 
1fb3			 
1fb3 21 2a e9			ld hl, cli_loop_stack 
1fb6 22 f0 e9			ld (cli_loop_sp), hl	 
1fb9				; set bottom of stack 
1fb9 3e 00			ld a,0 
1fbb 77				ld (hl),a 
1fbc 23				inc hl 
1fbd 77				ld (hl),a 
1fbe			 
1fbe				; init extent of current open file 
1fbe			 
1fbe 3e 00			ld a, 0 
1fc0 32 6a ea			ld (store_openext), a 
1fc3			 
1fc3 c9				ret 
1fc4			 
1fc4			 
1fc4			 
1fc4			; Cold Start - this is called to setup the whole Forth system 
1fc4			 
1fc4			forth_init: 
1fc4			 
1fc4				; setup stack over/under flow checks 
1fc4			 
1fc4			;	if DEBUG_FORTH_STACK_GUARD 
1fc4			;		call chk_stk_init 
1fc4			;	endif 
1fc4			 
1fc4				; enable auto display updates (slow.....) 
1fc4			 
1fc4 3e 01			ld a, 1 
1fc6 32 3c ea			ld (cli_autodisplay), a 
1fc9			 
1fc9				; if storage is in use disable long reads for now 
1fc9 3e 00			ld a, 0 
1fcb 32 75 ea			ld (store_longread), a 
1fce			 
1fce			 
1fce				; show start up screen 
1fce			 
1fce cd ba 0b			call clear_display 
1fd1			 
1fd1 3e 00			ld a,0 
1fd3 32 5e ea			ld (f_cursor_ptr), a 
1fd6			 
1fd6				; set start of word list in start of ram - for use when creating user words 
1fd6			 
1fd6 21 91 65			ld hl, baseram 
1fd9 22 be e5			ld (os_last_new_uword), hl 
1fdc cd 7d 1f			call user_word_eol 
1fdf				 
1fdf			;		call display_data_sp 
1fdf			;		call next_page_prompt 
1fdf			 
1fdf			 
1fdf			 
1fdf			 
1fdf c9				ret 
1fe0			 
1fe0 .. 00		.bootforth: db " Forth Kernel Init ",0 
1ff4			 
1ff4			; TODO push to stack 
1ff4			 
1ff4			;  
1ff4			 
1ff4			if FORTH_PARSEV2 
1ff4			 
1ff4			 
1ff4				include "forth_parserv2.asm" 
1ff4			 
1ff4			endif 
1ff4			 
1ff4			 
1ff4			; parse cli version 1 
1ff4			 
1ff4			if FORTH_PARSEV1 
1ff4			 
1ff4			 
1ff4			 
1ff4			      include "forth_parserv1.asm" 
1ff4			endif 
1ff4				 
1ff4			if FORTH_PARSEV3 
1ff4			 
1ff4			 
1ff4			 
1ff4			      include "forth_parserv3.asm" 
1ff4				include "forth_wordsv3.asm" 
1ff4			endif 
1ff4			 
1ff4			if FORTH_PARSEV4 
1ff4			 
1ff4			 
1ff4			 
1ff4			      include "forth_parserv4.asm" 
1ff4				include "forth_wordsv4.asm" 
1ff4			endif 
1ff4			 
1ff4			if FORTH_PARSEV5 
1ff4			 
1ff4			 
1ff4			 
1ff4			      include "forth_parserv5.asm" 
1ff4			 
1ff4			 
1ff4			; A better parser without using malloc and string copies all over the place.  
1ff4			; Exec in situ should be faster 
1ff4			 
1ff4			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ff4			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ff4			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ff4			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ff4			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ff4			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ff4			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ff4			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ff4			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ff4			 
1ff4			; Core word preamble macro 
1ff4			 
1ff4			CWHEAD:   macro nxtword opcode lit len opflags 
1ff4				db WORD_SYS_CORE+opcode             
1ff4				; internal op code number 
1ff4				dw nxtword            
1ff4				; link to next dict word block 
1ff4				db len + 1 
1ff4				; literal length of dict word inc zero term 
1ff4				db lit,0              
1ff4				; literal dict word 
1ff4			        ; TODO db opflags        
1ff4				endm 
1ff4			 
1ff4			 
1ff4			NEXTW: macro  
1ff4				jp macro_next 
1ff4				endm 
1ff4			 
1ff4			macro_next: 
1ff4			if DEBUG_FORTH_PARSE_KEY 
1ff4				DMARK "NXT" 
1ff4				CALLMONITOR 
1ff4			endif	 
1ff4			;	inc hl  ; skip token null term  
1ff4 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ff8 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ffc 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1fff			if DEBUG_FORTH_PARSE_KEY 
1fff				DMARK "}AA" 
1fff				CALLMONITOR 
1fff			endif	 
1fff c3 02 21			jp execnext 
2002				;jp exec1 
2002			       
2002			 
2002			 
2002			; Another go at the parser to compile  
2002			 
2002			 
2002			; TODO rework parser to change all of the string words to byte tokens 
2002			; TODO do a search for  
2002			 
2002			; TODO first run normal parser to zero term sections 
2002			; TODO for each word do a token look up to get the op code 
2002			; TODO need some means to flag to the exec that this is a byte code form    
2002			 
2002			 
2002			forthcompile: 
2002			 
2002			; 
2002			; line parse: 
2002			;       parse raw input buffer 
2002			;       tokenise the words 
2002			;       malloc new copy (for looping etc) 
2002			;       copy to malloc + current pc in line to start of string and add line term 
2002			;       save on new rsp 
2002			; 
2002			 
2002			; hl to point to the line to tokenise 
2002			 
2002			;	push hl 
2002 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2005			 
2005			;	ld a,0		; string term on input 
2005			;	call strlent 
2005			 
2005			;	ld (os_tok_len), hl	 ; save string length 
2005			 
2005			;if DEBUG_FORTH_TOK 
2005			;	ex de,hl		 
2005			;endif 
2005			 
2005			;	pop hl 		; get back string pointer 
2005			 
2005			if DEBUG_FORTH_TOK 
2005						DMARK "TOc" 
2005				CALLMONITOR 
2005			endif 
2005 7e			.cptoken2:    ld a,(hl) 
2006 23				inc hl 
2007 fe 7f			cp FORTH_END_BUFFER 
2009 28 29			jr z, .cptokendone2 
200b fe 00			cp 0 
200d 28 25			jr z, .cptokendone2 
200f fe 22			cp '"' 
2011 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2013 fe 20			cp ' ' 
2015 20 ee			jr nz,  .cptoken2 
2017			 
2017			; TODO consume comments held between ( and ) 
2017			 
2017				; we have a space so change to zero term for dict match later 
2017 2b				dec hl 
2018 3e 00			ld a,0 
201a 77				ld (hl), a 
201b 23				inc hl 
201c 18 e7			jr .cptoken2 
201e				 
201e			 
201e			.cptokenstr2: 
201e				; skip all white space until either eol (because forgot to term) or end double quote 
201e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
201e				;inc hl ; skip current double quote 
201e 7e				ld a,(hl) 
201f 23				inc hl 
2020 fe 22			cp '"' 
2022 28 e1			jr z, .cptoken2 
2024 fe 7f			cp FORTH_END_BUFFER 
2026 28 0c			jr z, .cptokendone2 
2028 fe 00			cp 0 
202a 28 08			jr z, .cptokendone2 
202c fe 20			cp ' ' 
202e 28 02			jr z, .cptmp2 
2030 18 ec			jr .cptokenstr2 
2032			 
2032			.cptmp2:	; we have a space so change to zero term for dict match later 
2032				;dec hl 
2032				;ld a,"-"	; TODO remove this when working 
2032				;ld (hl), a 
2032				;inc hl 
2032 18 ea			jr .cptokenstr2 
2034			 
2034			.cptokendone2: 
2034				;inc hl 
2034 3e 7f			ld a, FORTH_END_BUFFER 
2036 77				ld (hl),a 
2037 23				inc hl 
2038 3e 21			ld a, '!' 
203a 77				ld (hl),a 
203b			 
203b 2a c2 e5			ld hl,(os_tok_ptr) 
203e			         
203e			if DEBUG_FORTH_TOK 
203e						DMARK "Tc1" 
203e				CALLMONITOR 
203e			endif 
203e			 
203e				; push exec string to top of return stack 
203e				FORTH_RSP_NEXT 
203e cd ee 1b			call macro_forth_rsp_next 
2041				endm 
# End of macro FORTH_RSP_NEXT
2041 c9				ret 
2042			 
2042			; Another go at the parser need to simplify the process 
2042			 
2042			forthparse: 
2042			 
2042			; 
2042			; line parse: 
2042			;       parse raw input buffer 
2042			;       tokenise the words 
2042			;       malloc new copy (for looping etc) 
2042			;       copy to malloc + current pc in line to start of string and add line term 
2042			;       save on new rsp 
2042			; 
2042			 
2042			; hl to point to the line to tokenise 
2042			 
2042			;	push hl 
2042 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2045			 
2045			;	ld a,0		; string term on input 
2045			;	call strlent 
2045			 
2045			;	ld (os_tok_len), hl	 ; save string length 
2045			 
2045			;if DEBUG_FORTH_TOK 
2045			;	ex de,hl		 
2045			;endif 
2045			 
2045			;	pop hl 		; get back string pointer 
2045			 
2045			if DEBUG_FORTH_TOK 
2045						DMARK "TOK" 
2045				CALLMONITOR 
2045			endif 
2045 7e			.ptoken2:    ld a,(hl) 
2046 23				inc hl 
2047 fe 7f			cp FORTH_END_BUFFER 
2049 28 29			jr z, .ptokendone2 
204b fe 00			cp 0 
204d 28 25			jr z, .ptokendone2 
204f fe 22			cp '"' 
2051 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2053 fe 20			cp ' ' 
2055 20 ee			jr nz,  .ptoken2 
2057			 
2057			; TODO consume comments held between ( and ) 
2057			 
2057				; we have a space so change to zero term for dict match later 
2057 2b				dec hl 
2058 3e 00			ld a,0 
205a 77				ld (hl), a 
205b 23				inc hl 
205c 18 e7			jr .ptoken2 
205e				 
205e			 
205e			.ptokenstr2: 
205e				; skip all white space until either eol (because forgot to term) or end double quote 
205e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
205e				;inc hl ; skip current double quote 
205e 7e				ld a,(hl) 
205f 23				inc hl 
2060 fe 22			cp '"' 
2062 28 e1			jr z, .ptoken2 
2064 fe 7f			cp FORTH_END_BUFFER 
2066 28 0c			jr z, .ptokendone2 
2068 fe 00			cp 0 
206a 28 08			jr z, .ptokendone2 
206c fe 20			cp ' ' 
206e 28 02			jr z, .ptmp2 
2070 18 ec			jr .ptokenstr2 
2072			 
2072			.ptmp2:	; we have a space so change to zero term for dict match later 
2072				;dec hl 
2072				;ld a,"-"	; TODO remove this when working 
2072				;ld (hl), a 
2072				;inc hl 
2072 18 ea			jr .ptokenstr2 
2074			 
2074			.ptokendone2: 
2074				;inc hl 
2074 3e 7f			ld a, FORTH_END_BUFFER 
2076 77				ld (hl),a 
2077 23				inc hl 
2078 3e 21			ld a, '!' 
207a 77				ld (hl),a 
207b			 
207b 2a c2 e5			ld hl,(os_tok_ptr) 
207e			         
207e			if DEBUG_FORTH_TOK 
207e						DMARK "TK1" 
207e				CALLMONITOR 
207e			endif 
207e			 
207e				; push exec string to top of return stack 
207e				FORTH_RSP_NEXT 
207e cd ee 1b			call macro_forth_rsp_next 
2081				endm 
# End of macro FORTH_RSP_NEXT
2081 c9				ret 
2082			 
2082			; 
2082			;	; malloc size + buffer pointer + if is loop flag 
2082			;	ld hl,(os_tok_len) 		 ; get string length 
2082			; 
2082			;	ld a,l 
2082			; 
2082			;	cp 0			; we dont want to use a null string 
2082			;	ret z 
2082			; 
2082			;;	add 3    ; prefix malloc with buffer for current word ptr 
2082			; 
2082			;	add 5     ; TODO when certain not over writing memory remove 
2082			; 
2082			;		 
2082			; 
2082			;if DEBUG_FORTH_TOK 
2082			;			DMARK "TKE" 
2082			;	CALLMONITOR 
2082			;endif 
2082			; 
2082			;	ld l,a 
2082			;	ld h,0 
2082			;;	push hl   ; save required space for the copy later 
2082			;	call malloc 
2082			;if DEBUG_FORTH_TOK 
2082			;			DMARK "TKM" 
2082			;	CALLMONITOR 
2082			;endif 
2082			;	if DEBUG_FORTH_MALLOC_GUARD 
2082			;		push af 
2082			;		call ishlzero 
2082			;;		ld a, l 
2082			;;		add h 
2082			;;		cp 0 
2082			;		pop af 
2082			;		 
2082			;		call z,malloc_error 
2082			;	endif 
2082			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2082			; 
2082			; 
2082			;if DEBUG_FORTH_TOK 
2082			;			DMARK "TKR" 
2082			;	CALLMONITOR 
2082			;endif 
2082			; 
2082			;	FORTH_RSP_NEXT 
2082			; 
2082			;	;inc hl	 ; go past current buffer pointer 
2082			;	;inc hl 
2082			;	;inc hl   ; and past if loop flag 
2082			;		; TODO Need to set flag  
2082			; 
2082			;	 
2082			;	 
2082			;	ex de,hl	; malloc is dest 
2082			;	ld hl, (os_tok_len) 
2082			;;	pop bc 
2082			;	ld c, l                
2082			;	ld b,0 
2082			;	ld hl, (os_tok_ptr) 
2082			; 
2082			;if DEBUG_FORTH_TOK 
2082			;			DMARK "TKT" 
2082			;	CALLMONITOR 
2082			;endif 
2082			; 
2082			;	; do str cpy 
2082			; 
2082			;	ldir      ; copy byte in hl to de 
2082			; 
2082			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2082			; 
2082			;if DEBUG_FORTH_TOK 
2082			; 
2082			;			DMARK "TKY" 
2082			;	CALLMONITOR 
2082			;endif 
2082			;	;ld a,0 
2082			;	;ld a,FORTH_END_BUFFER 
2082			;	ex de, hl 
2082			;	;dec hl			 ; go back over the space delim at the end of word 
2082			;	;ld (hl),a 
2082			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2082			;	ld a,FORTH_END_BUFFER 
2082			;	ld (hl),a 
2082			;	inc hl 
2082			;	ld a,FORTH_END_BUFFER 
2082			;	ld (hl),a 
2082			; 
2082			;	; init the malloc area data 
2082			;	; set pc for in current area 
2082			;	;ld hl, (os_tok_malloc) 
2082			;	;inc hl 
2082			;	;inc hl 
2082			;	;inc hl 
2082			;	;ex de,hl 
2082			;	;ld hl, (os_tok_malloc) 
2082			;	;ld (hl),e 
2082			;	;inc hl 
2082			;	;ld (hl),d 
2082			; 
2082			; 
2082			;	ld hl,(os_tok_malloc) 
2082			;if DEBUG_FORTH_PARSE_KEY 
2082			;			DMARK "TKU" 
2082			;	CALLMONITOR 
2082			;endif 
2082			; 
2082			;	ret 
2082			 
2082			forthexec: 
2082			 
2082			; line exec: 
2082			; forth parser 
2082			 
2082			; 
2082			;       get current exec line on rsp 
2082			 
2082				FORTH_RSP_TOS 
2082 cd 05 1c			call macro_forth_rsp_tos 
2085				endm 
# End of macro FORTH_RSP_TOS
2085			 
2085			;       restore current pc - hl points to malloc of data 
2085			 
2085				;ld e, (hl) 
2085				;inc hl 
2085				;ld d, (hl) 
2085				;ex de,hl 
2085			 
2085			 
2085			exec1: 
2085 22 c2 e5			ld (os_tok_ptr), hl 
2088			 
2088				; copy our PC to working vars  
2088 22 40 ea			ld (cli_ptr), hl 
208b 22 3e ea			ld (cli_origptr), hl 
208e			 
208e 7e				ld a,(hl) 
208f fe 7f			cp FORTH_END_BUFFER 
2091 c8				ret z 
2092			 
2092				; skip any nulls 
2092			 
2092 fe 00			cp 0 
2094 20 03			jr nz, .execword 
2096 23				inc hl 
2097 18 ec			jr exec1 
2099			 
2099			 
2099			.execword: 
2099			 
2099			 
2099			 
2099			if DEBUG_FORTH_PARSE_KEY 
2099						DMARK "KYQ" 
2099				CALLMONITOR 
2099			endif 
2099			;       while at start of word: 
2099			; get start of dict (in user area first) 
2099			 
2099 21 91 65		ld hl, baseram 
209c			;ld hl, sysdict 
209c 22 42 ea		ld (cli_nextword),hl 
209f			;           match word at pc 
209f			;           exec word 
209f			;           or push to dsp 
209f			;           forward to next token 
209f			;           if line term pop rsp and exit 
209f			;        
209f			 
209f			if DEBUG_FORTH_PARSE_KEY 
209f						DMARK "KYq" 
209f				CALLMONITOR 
209f			endif 
209f			 
209f			; 
209f			; word comp 
209f			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
209f			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
209f			;    move to start of word  
209f			;    compare word to cli_token 
209f			 
209f			.execpnword:	; HL at start of a word in the dictionary to check 
209f			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
209f			;	ld (cli_ptr), hl 
209f			 
209f 2a 42 ea			ld hl,(cli_nextword) 
20a2			 
20a2 cd 45 21			call forth_tok_next 
20a5			; tok next start here 
20a5			;	; TODO skip compiled symbol for now 
20a5			;	inc hl 
20a5			; 
20a5			;	; save pointer to next word 
20a5			; 
20a5			;	; hl now points to the address of the next word pointer  
20a5			;	ld e, (hl) 
20a5			;	inc hl 
20a5			;	ld d, (hl) 
20a5			;	inc l 
20a5			; 
20a5			;	ex de,hl 
20a5			;if DEBUG_FORTH_PARSE_NEXTWORD 
20a5			;	push bc 
20a5			;	ld bc, (cli_nextword) 
20a5			;			DMARK "NXW" 
20a5			;	CALLMONITOR 
20a5			;	pop bc 
20a5			;endif 
20a5			; tok next end here 
20a5 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20a8 eb				ex de, hl 
20a9			 
20a9			 
20a9				; save the pointer of the current token - 1 to check against 
20a9				 
20a9 22 46 ea			ld (cli_token), hl   
20ac				; TODO maybe remove below save if no debug 
20ac				; save token string ptr for any debug later 
20ac 23				inc hl  
20ad 22 48 ea			ld (cli_origtoken), hl 
20b0 2b				dec hl 
20b1				; save pointer to the start of the next dictionay word 
20b1 7e				ld a,(hl)   ; get string length 
20b2 47				ld b,a 
20b3			.execpnwordinc:  
20b3 23				inc hl 
20b4 10 fd			djnz .execpnwordinc 
20b6 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20b9			 
20b9				; now check the word token against the string being parsed 
20b9			 
20b9 2a 46 ea			ld hl,(cli_token) 
20bc 23				inc hl     ; skip string length (use zero term instead to end) 
20bd 22 46 ea			ld (cli_token), hl 
20c0			 
20c0			if DEBUG_FORTH_PARSE_KEY 
20c0						DMARK "KY2" 
20c0			endif 
20c0			if DEBUG_FORTH_PARSE_EXEC 
20c0				; see if disabled 
20c0			 
20c0			;	ld a, (os_view_disable) 
20c0			;	cp '*' 
20c0				ld a, (debug_vector) 
20c0				cp $c9   ; RET  
20c0				jr z, .skip 
20c0			 
20c0				push hl 
20c0				push hl 
20c0				call clear_display 
20c0				ld de, .compword 
20c0				ld a, display_row_1 
20c0				call str_at_display 
20c0				pop de 
20c0				ld a, display_row_2 
20c0				call str_at_display 
20c0				ld hl,(cli_ptr) 
20c0				ld a,(hl) 
20c0			        ld hl, os_word_scratch 
20c0				ld (hl),a 
20c0				ld a,0 
20c0				inc hl 
20c0				ld (hl),a 	 
20c0				ld de, os_word_scratch 
20c0				ld a, display_row_2+10 
20c0				call str_at_display 
20c0				call update_display 
20c0				ld a, 100 
20c0				call aDelayInMS 
20c0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20c0				call delay250ms 
20c0				endif 
20c0				pop hl 
20c0			.skip:  
20c0			endif	 
20c0			.execpnchar:    ; compare char between token and string to parse 
20c0			 
20c0			if DEBUG_FORTH_PARSE_KEY 
20c0						DMARK "Ky3" 
20c0			endif 
20c0			if DEBUG_FORTH_PARSE_EXEC 
20c0				; see if disabled 
20c0			 
20c0			;	ld a, (os_view_disable) 
20c0			;	cp '*' 
20c0				ld a, (debug_vector) 
20c0				cp $C9  ; RET 
20c0				jr z, .skip2 
20c0			 
20c0			;	call clear_display 
20c0			ld hl,(cli_token) 
20c0			ld a,(hl) 
20c0			ld (os_word_scratch),a 
20c0				ld hl,(cli_ptr) 
20c0			ld a,(hl) 
20c0				ld (os_word_scratch+1),a 
20c0				ld a,0 
20c0				ld (os_word_scratch+2),a 
20c0				ld de,os_word_scratch 
20c0				ld a,display_row_4 
20c0				call str_at_display 
20c0				call update_display 
20c0			.skip2:  
20c0			endif 
20c0 2a 46 ea			ld hl,(cli_token) 
20c3 7e				ld a, (hl)	 ; char in word token 
20c4 23				inc hl 		; move to next char 
20c5 22 46 ea			ld (cli_token), hl ; and save it 
20c8 47				ld b,a 
20c9			 
20c9 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20cc 7e				ld a,(hl) 
20cd 23				inc hl 
20ce 22 40 ea			ld (cli_ptr), hl		; move to next char 
20d1 cd 3c 12			call toUpper 		; make sure the input string matches case 
20d4			 
20d4			if DEBUG_FORTH_PARSE 
20d4			endif 
20d4			 
20d4				; input stream end of token is a space so get rid of it 
20d4			 
20d4			;	cp ' ' 
20d4			;	jr nz, .pnskipspace 
20d4			; 
20d4			;	ld a, 0		; make same term as word token term 
20d4			; 
20d4			;.pnskipspace: 
20d4			 
20d4			if DEBUG_FORTH_PARSE_KEY 
20d4						DMARK "KY7" 
20d4			endif 
20d4 b8				cp b 
20d5 c2 eb 20			jp nz, .execpnskipword	 ; no match so move to next word 
20d8				 
20d8			;    if same 
20d8			;       scan for string terms 0 for token and 32 for input 
20d8			 
20d8				 
20d8			if DEBUG_FORTH_PARSE_KEY 
20d8						DMARK "KY8" 
20d8			endif 
20d8			 
20d8 80				add b			 
20d9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20db							; TODO need to make sure last word in zero term string is accounted for 
20db 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20dd			 
20dd			 
20dd				; at end of both strings so both are exact match 
20dd			 
20dd			;       skip ptr for next word 
20dd			 
20dd 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20e0 23				inc hl			 ; at next char 
20e1 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20e4 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20e7				 
20e7				 
20e7			if DEBUG_FORTH_PARSE_KEY 
20e7						DMARK "KY3" 
20e7			endif 
20e7			 
20e7			 
20e7			 
20e7			;       exec code block 
20e7			if DEBUG_FORTH_JP 
20e7				call clear_display 
20e7				call update_display 
20e7				call delay1s 
20e7				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e7				ld a,h 
20e7				ld hl, os_word_scratch 
20e7				call hexout 
20e7				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e7				ld a,l 
20e7				ld hl, os_word_scratch+2 
20e7				call hexout 
20e7				ld hl, os_word_scratch+4 
20e7				ld a,0 
20e7				ld (hl),a 
20e7				ld de,os_word_scratch 
20e7				call str_at_display 
20e7					ld a, display_row_2 
20e7					call str_at_display 
20e7				ld de, (cli_origtoken) 
20e7				ld a, display_row_1+10 
20e7					call str_at_display 
20e7			 
20e7				ld a,display_row_1 
20e7				ld de, .foundword 
20e7				ld a, display_row_3 
20e7				call str_at_display 
20e7				call update_display 
20e7				call delay1s 
20e7				call delay1s 
20e7				call delay1s 
20e7			endif 
20e7			 
20e7			if DEBUG_FORTH_PARSE_KEY 
20e7						DMARK "KYj" 
20e7			endif 
20e7				; TODO save the word pointer in this exec 
20e7			 
20e7 2a 44 ea			ld hl,(cli_execword) 
20ea e9				jp (hl) 
20eb			 
20eb			 
20eb			;    if not same 
20eb			;	scan for zero term 
20eb			;	get ptr for next word 
20eb			;	goto word comp 
20eb			 
20eb			.execpnskipword:	; get pointer to next word 
20eb 2a 42 ea			ld hl,(cli_nextword) 
20ee			 
20ee 7e				ld a,(hl) 
20ef fe 00			cp WORD_SYS_END 
20f1			;	cp 0 
20f1 28 09			jr z, .execendofdict			 ; at end of words 
20f3			 
20f3			if DEBUG_FORTH_PARSE_KEY 
20f3						DMARK "KY4" 
20f3			endif 
20f3			if DEBUG_FORTH_PARSE_EXEC 
20f3			 
20f3				; see if disabled 
20f3			 
20f3			;	ld a, (os_view_disable) 
20f3			;	cp '*' 
20f3				ld a,(debug_vector) 
20f3				cp $c9   ; RET 
20f3				jr z, .noskip 
20f3			 
20f3			 
20f3				ld de, .nowordfound 
20f3				ld a, display_row_3 
20f3				call str_at_display 
20f3				call update_display 
20f3				ld a, 100 
20f3				call aDelayInMS 
20f3				 
20f3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20f3					call delay250ms 
20f3				endif 
20f3			.noskip:  
20f3			 
20f3			endif	 
20f3			 
20f3 2a 3e ea			ld hl,(cli_origptr) 
20f6 22 40 ea			ld (cli_ptr),hl 
20f9			 
20f9			if DEBUG_FORTH_PARSE_KEY 
20f9						DMARK "KY5" 
20f9			endif 
20f9 c3 9f 20			jp .execpnword			; else go to next word 
20fc			 
20fc			.execendofdict:  
20fc			 
20fc			if DEBUG_FORTH_PARSE_KEY 
20fc						DMARK "KYe" 
20fc			endif 
20fc			if DEBUG_FORTH_PARSE_EXEC 
20fc				; see if disabled 
20fc			 
20fc			;	ld a, (os_view_disable) 
20fc			;	cp '*' 
20fc				ld a,(debug_vector) 
20fc				cp $c9   ; ret 
20fc				jr z, .ispskip 
20fc			 
20fc				call clear_display 
20fc				call update_display 
20fc				call delay1s 
20fc				ld de, (cli_origptr) 
20fc				ld a, display_row_1 
20fc				call str_at_display 
20fc				 
20fc				ld de, .enddict 
20fc				ld a, display_row_3 
20fc				call str_at_display 
20fc				call update_display 
20fc				ld a, 100 
20fc				call aDelayInMS 
20fc				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20fc				call delay1s 
20fc				call delay1s 
20fc				call delay1s 
20fc				endif 
20fc			.ispskip:  
20fc				 
20fc			endif	 
20fc			 
20fc			 
20fc			 
20fc				; if the word is not a keyword then must be a literal so push it to stack 
20fc			 
20fc			; push token to stack to end of word 
20fc			 
20fc				STACKFRAME ON $1efe $2f9f 
20fc				if DEBUG_STACK_IMB 
20fc					if ON 
20fc						exx 
20fc						ld de, $1efe 
20fc						ld a, d 
20fc						ld hl, curframe 
20fc						call hexout 
20fc						ld a, e 
20fc						ld hl, curframe+2 
20fc						call hexout 
20fc						ld hl, $1efe 
20fc						push hl 
20fc						ld hl, $2f9f 
20fc						push hl 
20fc						exx 
20fc					endif 
20fc				endif 
20fc			endm 
# End of macro STACKFRAME
20fc			 
20fc 2a c2 e5		ld hl,(os_tok_ptr) 
20ff cd b0 1d		call forth_apush 
2102			 
2102				STACKFRAMECHK ON $1efe $2f9f 
2102				if DEBUG_STACK_IMB 
2102					if ON 
2102						exx 
2102						ld hl, $2f9f 
2102						pop de   ; $2f9f 
2102						call cmp16 
2102						jr nz, .spnosame 
2102						ld hl, $1efe 
2102						pop de   ; $1efe 
2102						call cmp16 
2102						jr z, .spfrsame 
2102						.spnosame: call showsperror 
2102						.spfrsame: nop 
2102						exx 
2102					endif 
2102				endif 
2102			endm 
# End of macro STACKFRAMECHK
2102			 
2102			execnext: 
2102			 
2102			if DEBUG_FORTH_PARSE_KEY 
2102						DMARK "KY>" 
2102			endif 
2102			; move past token to next word 
2102			 
2102 2a c2 e5		ld hl, (os_tok_ptr) 
2105 3e 00		ld a, 0 
2107 01 ff 00		ld bc, 255     ; input buffer size 
210a ed b1		cpir 
210c			 
210c			if DEBUG_FORTH_PARSE_KEY 
210c						DMARK "KY!" 
210c				CALLMONITOR 
210c			endif	 
210c			; TODO this might place hl on the null, so will need to forward on??? 
210c			;inc hl   ; see if this gets onto the next item 
210c			 
210c			 
210c			; TODO pass a pointer to the buffer to push 
210c			; TODO call function to push 
210c			 
210c			; look for end of input 
210c			 
210c			;inc hl 
210c			;ld a,(hl) 
210c			;cp FORTH_END_BUFFER 
210c			;ret z 
210c			 
210c			 
210c c3 85 20		jp exec1 
210f			 
210f			 
210f			 
210f			 
210f			 
210f			 
210f			 
210f			 
210f			 
210f			findnexttok: 
210f			 
210f				; hl is pointer to move 
210f				; de is the token to locate 
210f			 
210f					if DEBUG_FORTH 
210f						DMARK "NTK" 
210f						CALLMONITOR 
210f					endif 
210f d5				push de 
2110			 
2110			.fnt1:	 
2110				; find first char of token to locate 
2110			 
2110 1a				ld a, (de) 
2111 4f				ld c,a 
2112 7e				ld a,(hl) 
2113 cd 3c 12			call toUpper 
2116					if DEBUG_FORTH 
2116						DMARK "NT1" 
2116						CALLMONITOR 
2116					endif 
2116 b9				cp c 
2117			 
2117 28 03			jr z, .fnt2cmpmorefirst	 
2119			 
2119				; first char not found move to next char 
2119			 
2119 23				inc hl 
211a 18 f4			jr .fnt1 
211c			 
211c			.fnt2cmpmorefirst:	 
211c				; first char of token found.  
211c			 
211c e5				push hl     ; save start of token just in case it is the right one 
211d d9				exx 
211e e1				pop hl        ; save it to hl' 
211f d9				exx 
2120			 
2120			 
2120			.fnt2cmpmore:	 
2120				; compare the rest 
2120				 
2120 23				inc hl 
2121 13				inc de 
2122				 
2122 1a				ld a, (de) 
2123 4f				ld c,a 
2124 7e				ld a,(hl) 
2125 cd 3c 12			call toUpper 
2128			 
2128					if DEBUG_FORTH 
2128						DMARK "NT2" 
2128						CALLMONITOR 
2128					endif 
2128				; c has the token to find char 
2128				; a has the mem to scan char 
2128			 
2128 b9				cp c 
2129 28 04			jr z,.fntmatch1 
212b			 
212b				; they are not the same 
212b			 
212b					if DEBUG_FORTH 
212b						DMARK "NT3" 
212b						CALLMONITOR 
212b					endif 
212b d1				pop de	; reset de token to look for 
212c d5				push de 
212d 18 e1			jr .fnt1 
212f				 
212f			.fntmatch1: 
212f			 
212f				; is the same char a null which means we might have a full hit? 
212f					if DEBUG_FORTH 
212f						DMARK "NT4" 
212f						CALLMONITOR 
212f					endif 
212f			 
212f fe 00			cp 0 
2131 28 0b			jr z, .fntmatchyes 
2133			 
2133				; are we at the end of the token to find? 
2133			 
2133					if DEBUG_FORTH 
2133						DMARK "NT5" 
2133						CALLMONITOR 
2133					endif 
2133 3e 00			ld a, 0 
2135 b9				cp c 
2136			 
2136 c2 20 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2139			 
2139					if DEBUG_FORTH 
2139						DMARK "NT6" 
2139						CALLMONITOR 
2139					endif 
2139				; token to find is exhusted but no match to stream 
2139			 
2139				; restore tok pointer and continue on 
2139 d1				pop de 
213a d5				push de 
213b c3 10 21			jp .fnt1 
213e			 
213e			 
213e			.fntmatchyes: 
213e			 
213e				; hl now contains the end of the found token 
213e			 
213e				; get rid of saved token pointer to find 
213e			 
213e d1				pop de 
213f			 
213f					if DEBUG_FORTH 
213f						DMARK "NT9" 
213f						CALLMONITOR 
213f					endif 
213f			 
213f				; hl will be on the null term so forward on 
213f			 
213f				; get back the saved start of the token 
213f			 
213f d9				exx 
2140 e5				push hl     ; save start of token just in case it is the right one 
2141 d9				exx 
2142 e1				pop hl        ; save it to hl 
2143			 
2143 c9				ret 
2144			 
2144			 
2144			; LIST needs to find a specific token   
2144			; FORGET needs to find a spefici token 
2144			 
2144			; SAVE needs to find all tokens by flag 
2144			; WORDS just needs to scan through all  by flag 
2144			; UWORDS needs to scan through all by flag 
2144			 
2144			 
2144			; given hl as pointer to start of dict look up string 
2144			; return hl as pointer to start of word block 
2144			; or 0 if not found 
2144			 
2144			forth_find_tok: 
2144 c9				ret 
2145			 
2145			; given hl as pointer to dict structure 
2145			; move to the next dict block structure 
2145			 
2145			forth_tok_next: 
2145				; hl now points to the address of the next word pointer  
2145				; TODO skip compiled symbol for now 
2145			;	push de 
2145 23				inc hl 
2146 5e				ld e, (hl) 
2147 23				inc hl 
2148 56				ld d, (hl) 
2149 23				inc hl 
214a			 
214a eb				ex de,hl 
214b			if DEBUG_FORTH_PARSE_NEXTWORD 
214b				push bc 
214b				ld bc, (cli_nextword) 
214b						DMARK "NXW" 
214b				CALLMONITOR 
214b				pop bc 
214b			endif 
214b			;	pop de	 
214b c9				ret 
214c			 
214c			 
214c			 
214c			; eof 
# End of file forth_parserv5.asm
214c				include "forth_wordsv4.asm" 
214c			 
214c			; the core word dictionary v4 
214c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
214c			 
214c			; this is a linked list for each of the system words used 
214c			; user defined words will follow the same format but will be in ram 
214c			 
214c			 
214c			; 
214c			; 
214c			; define linked list: 
214c			; 
214c			; 1. compiled byte op code 
214c			; 2. len of text word 
214c			; 3. text word 
214c			; 4. ptr to next dictionary word 
214c			; 5. asm, calls etc for the word 
214c			; 
214c			;  if 1 == 0 then last word in dict  
214c			;   
214c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
214c			;  
214c			;  
214c			; create basic standard set of words 
214c			; 
214c			;  
214c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
214c			; 2DUP 2DROP 2SWAP  
214c			; @ C@ - get byte  
214c			; ! C! - store byte 
214c			; 0< true if less than zero 
214c			; 0= true if zero 
214c			; < >  
214c			; = true if same 
214c			; variables 
214c			 
214c			 
214c			; Hardware specific words I may need 
214c			; 
214c			; IN OUT  
214c			; calls to key util functions 
214c			; calls to hardward abstraction stuff 
214c			; easy control of frame buffers and lcd i/o 
214c			; keyboard  
214c			 
214c			 
214c			;DICT: macro 
214c			; op_code, len, word, next 
214c			;    word: 
214c			;    db op_code 
214c			;    ds word zero term 
214c			;    dw next 
214c			;    endm 
214c			 
214c			 
214c			 
214c			 
214c			; op code 1 is a flag for user define words which are to be handled differently 
214c			 
214c			 
214c			; 
214c			; 
214c			;    TODO on entry to a word this should be the expected environment 
214c			;    hl - tos value if number then held, if string this is the ptr 
214c			;    de -  
214c			 
214c			 
214c			; opcode ranges 
214c			; 0 - end of word dict 
214c			; 255 - user define words 
214c			 
214c			sysdict: 
214c			include "forth_opcodes.asm" 
214c			; op codes for forth keywords 
214c			; free to use code 0  
214c				OPCODE_HEAP: equ  1 
214c				OPCODE_EXEC: equ 2 
214c				OPCODE_DUP: equ 3 
214c				OPCODE_SWAP: equ 4 
214c				OPCODE_COLN: equ 5 
214c				OPCODE_SCOLN: equ 6 
214c				OPCODE_DROP: equ 7 
214c				OPCODE_DUP2: equ 8 
214c				OPCODE_DROP2: equ 9 
214c				OPCODE_SWAP2: equ 10 
214c				OPCODE_AT: equ 11 
214c				OPCODE_CAT: equ 12 
214c				OPCODE_BANG: equ 13 
214c				OPCODE_CBANG: equ 14 
214c				OPCODE_SCALL: equ 15 
214c				OPCODE_DEPTH: equ 16 
214c				OPCODE_OVER: equ 17 
214c				OPCODE_PAUSE: equ 18 
214c				OPCODE_PAUSES: equ 19 
214c				OPCODE_ROT: equ 20 
214c			;free to reuse	OPCODE_WORDS: equ 21 
214c			        OPCODE_NOT: equ 21 
214c				OPCODE_UWORDS: equ 22 
214c				OPCODE_BP: equ 23 
214c				OPCODE_MONITOR: equ 24  
214c				OPCODE_MALLOC: equ 25 
214c				OPCODE_FREE: equ 26 
214c				OPCODE_LIST: equ 27 
214c				OPCODE_FORGET: equ 28 
214c				OPCODE_NOP: equ 29 
214c				OPCODE_COMO: equ 30 
214c				OPCODE_COMC: equ 31 
214c			;free to reuse	OPCODE_ENDCORE: equ 32 
214c				OPCODE_AFTERSOUND: equ 33 
214c				OPCODE_GP2: equ 34 
214c				OPCODE_GP3: equ 35 
214c				OPCODE_GP4: equ 36 
214c				OPCODE_SIN: equ 37 
214c				OPCODE_SOUT: equ 38 
214c				OPCODE_SPIO: equ 39 
214c				OPCODE_SPICEH: equ 40 
214c				OPCODE_SPIOb: equ 41 
214c				OPCODE_SPII: equ 42 
214c				OPCODE_SESEL: equ 43 
214c				OPCODE_CARTDEV: equ 44 
214c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
214c				OPCODE_FB: equ 46 
214c				OPCODE_EMIT: equ 47 
214c				OPCODE_DOTH: equ 48 
214c				OPCODE_DOTF: equ 49 
214c				OPCODE_DOT: equ 50 
214c				OPCODE_CLS: equ 51 
214c				OPCODE_DRAW: equ 52 
214c				OPCODE_DUMP: equ 53 
214c				OPCODE_CDUMP: equ 54 
214c				OPCODE_DAT: equ 55 
214c				OPCODE_HOME: equ 56 
214c				OPCODE_SPACE: equ 57 
214c				OPCODE_SPACES: equ 58 
214c				OPCODE_SCROLL: equ 59 
214c				OPCODE_ATQ: equ 60 
214c				OPCODE_AUTODSP: equ 61 
214c				OPCODE_MENU: equ 62 
214c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
214c				OPCODE_THEN: equ 64 
214c				OPCODE_ELSE: equ 65 
214c				OPCODE_DO: equ 66 
214c				OPCODE_LOOP: equ 67 
214c				OPCODE_I: equ 68 
214c				OPCODE_DLOOP: equ 69  
214c				OPCODE_REPEAT: equ 70  
214c				OPCODE_UNTIL: equ 71 
214c				OPCODE_ENDFLOW: equ 72 
214c				OPCODE_WAITK: equ 73 
214c				OPCODE_ACCEPT: equ 74 
214c				OPCODE_EDIT: equ 75 
214c			;free to reuse	OPCODE_ENDKEY: equ 76 
214c				OPCODE_LZERO: equ 77 
214c				OPCODE_TZERO: equ 78 
214c				OPCODE_LESS: equ 79 
214c				OPCODE_GT: equ 80 
214c				OPCODE_EQUAL: equ 81  
214c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
214c				OPCODE_NEG: equ 83 
214c				OPCODE_DIV: equ 84 
214c				OPCODE_MUL: equ 85 
214c				OPCODE_MIN: equ 86 
214c				OPCODE_MAX: equ 87 
214c				OPCODE_RND16: equ 88 
214c				OPCODE_RND8: equ 89 
214c				OPCODE_RND: equ 90 
214c			;free to reuse	OPCODE_ENDMATHS: equ 91  
214c				OPCODE_BYNAME: equ 92 
214c				OPCODE_DIR: equ 93 
214c				OPCODE_SAVE: equ 94 
214c				OPCODE_LOAD: equ 95 
214c				OPCODE_BSAVE: equ 96 
214c				OPCODE_BLOAD: equ 97 
214c				OPCODE_SEO: equ 98  
214c				OPCODE_SEI: equ 99 
214c				OPCODE_SFREE: equ 100 
214c				OPCODE_SIZE: equ 101 
214c				OPCODE_CREATE: equ 102 
214c				OPCODE_APPEND: equ 103 
214c				OPCODE_SDEL: equ 104 
214c				OPCODE_OPEN: equ 105 
214c				OPCODE_READ: equ 106 
214c				OPCODE_EOF: equ 106 
214c				OPCODE_FORMAT: equ 107 
214c				OPCODE_LABEL: equ 108 
214c				OPCODE_LABELS: equ 109 
214c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
214c				OPCODE_UPPER: equ 111 
214c				OPCODE_LOWER: equ 112 
214c				OPCODE_SUBSTR: equ 113 
214c				OPCODE_LEFT: equ 114 
214c				OPCODE_RIGHT: equ 115 
214c				OPCODE_STR2NUM: equ 116 
214c				OPCODE_NUM2STR: equ 117 
214c				OPCODE_CONCAT: equ 118 
214c				OPCODE_FIND: equ 119 
214c				OPCODE_LEN: equ 120 
214c				OPCODE_CHAR: equ 121 
214c			; free to reuse	OPCODE_STRLEN: equ 122 
214c			; free to reuse	OPCODE_ENDSTR: equ 123 
214c				OPCODE_V0S: equ 124 
214c				OPCODE_V0Q: equ 125 
214c				OPCODE_V1S: equ 126 
214c				OPCODE_V1Q: equ 127 
214c				OPCODE_V2S: equ 128 
214c				OPCODE_V2Q: equ 129 
214c				OPCODE_V3S: equ 130 
214c				OPCODE_V3Q: equ 131 
214c			;free to reuse	OPCODE_END: equ 132 
214c				OPCODE_ZDUP: equ 133 
214c			 
214c			; eof 
# End of file forth_opcodes.asm
214c			 
214c			include "forth_words_core.asm" 
214c			 
214c			; | ## Core Words 
214c			 
214c			;if MALLOC_4 
214c			 
214c			.HEAP: 
214c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
214c 15				db WORD_SYS_CORE+OPCODE_HEAP             
214d 8b 21			dw .EXEC            
214f 05				db 4 + 1 
2150 .. 00			db "HEAP",0              
2155				endm 
# End of macro CWHEAD
2155			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2155			; | | u1 - Current number of bytes in the heap 
2155			; | | u2 - Remaining bytes left on the heap 
2155			; | |  
2155			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2155			 
2155			 
2155					if DEBUG_FORTH_WORDS_KEY 
2155						DMARK "HEP" 
2155 f5				push af  
2156 3a 6a 21			ld a, (.dmark)  
2159 32 6b ee			ld (debug_mark),a  
215c 3a 6b 21			ld a, (.dmark+1)  
215f 32 6c ee			ld (debug_mark+1),a  
2162 3a 6c 21			ld a, (.dmark+2)  
2165 32 6d ee			ld (debug_mark+2),a  
2168 18 03			jr .pastdmark  
216a ..			.dmark: db "HEP"  
216d f1			.pastdmark: pop af  
216e			endm  
# End of macro DMARK
216e						CALLMONITOR 
216e cd 6f ee			call debug_vector  
2171				endm  
# End of macro CALLMONITOR
2171					endif 
2171 2a 9b 65				ld hl, (free_list )      
2174 11 a0 65				ld de, heap_start 
2177			 
2177 ed 52				sbc hl, de  
2179			 
2179 cd 47 1c				call forth_push_numhl 
217c			 
217c			 
217c ed 5b 9b 65			ld de, (free_list )      
2180 21 9c e2				ld hl, heap_end 
2183			 
2183 ed 52				sbc hl, de 
2185			 
2185 cd 47 1c				call forth_push_numhl 
2188					 
2188			 
2188					 
2188			 
2188			 
2188			 
2188					NEXTW 
2188 c3 f4 1f			jp macro_next 
218b				endm 
# End of macro NEXTW
218b			;endif 
218b			 
218b			.EXEC: 
218b			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
218b			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
218b			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
218b			;; > > 
218b			;; > >   
218b			;	STACKFRAME OFF $5efe $5f9f 
218b			; 
218b			;		if DEBUG_FORTH_WORDS_KEY 
218b			;			DMARK "EXE" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			;	FORTH_DSP_VALUEHL 
218b			; 
218b			;	FORTH_DSP_POP 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX1" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;;	ld e,(hl) 
218b			;;	inc hl 
218b			;;	ld d,(hl) 
218b			;;	ex de,hl 
218b			; 
218b			;;		if DEBUG_FORTH_WORDS 
218b			;;			DMARK "EX2" 
218b			;;			CALLMONITOR 
218b			;;		endif 
218b			;	push hl 
218b			; 
218b			;	;ld a, 0 
218b			;	;ld a, FORTH_END_BUFFER 
218b			;	call strlenz 
218b			;	inc hl   ; include zero term to copy 
218b			;	inc hl   ; include term 
218b			;	inc hl   ; include term 
218b			;	ld b,0 
218b			;	ld c,l 
218b			;	pop hl 
218b			;	ld de, execscratch 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX3" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	ldir 
218b			; 
218b			; 
218b			;	ld hl, execscratch 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EXe" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			;	call forthparse 
218b			;	call forthexec 
218b			;;	call forthexec_cleanup 
218b			;;	call forthparse 
218b			;;	call forthexec 
218b			; 
218b			;	STACKFRAMECHK OFF $5efe $5f9f 
218b			; 
218b			;	; an immediate word so no need to process any more words 
218b			;	ret 
218b			;	NEXTW 
218b			 
218b			; dead code - old version  
218b			;	FORTH_RSP_NEXT 
218b			 
218b			;  
218b			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
218b			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
218b			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
218b			;	push hl 
218b			;	push de 
218b			;	push bc 
218b			; 
218b			; 
218b			;		if DEBUG_FORTH_WORDS_KEY 
218b			;			DMARK "EXR" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			; 
218b			; 
218b			;	;v5 FORTH_DSP_VALUE 
218b			;	FORTH_DSP_VALUEHL 
218b			; 
218b			;	; TODO do string type checks 
218b			; 
218b			;;v5	inc hl   ; skip type 
218b			; 
218b			;	push hl  ; source code  
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX1" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	ld a, 0 
218b			;	call strlent 
218b			; 
218b			;	inc hl 
218b			;	inc hl 
218b			;	inc hl 
218b			;	inc hl 
218b			; 
218b			;	push hl    ; size 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX2" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	call malloc 
218b			; 
218b			;	ex de, hl    ; de now contains malloc area 
218b			;	pop bc   	; get byte count 
218b			;	pop hl      ; get string to copy 
218b			; 
218b			;	push de     ; save malloc for free later 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX3" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	ldir       ; duplicate string 
218b			; 
218b			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
218b			;	 
218b			;	; TODO fix the parse would be better than this...  
218b			;	ex de, hl 
218b			;	dec hl 
218b			;	ld a, 0 
218b			;	ld (hl), a 
218b			;	dec hl 
218b			;	ld a, ' ' 
218b			;	ld (hl), a 
218b			;	dec hl 
218b			;	ld (hl), a 
218b			; 
218b			;	dec hl 
218b			;	ld (hl), a 
218b			; 
218b			; 
218b			;	FORTH_DSP_POP  
218b			; 
218b			;	pop hl     
218b			;	push hl    ; save malloc area 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX4" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			;	call forthparse 
218b			;	call forthexec 
218b			;	 
218b			;	pop hl 
218b			;	if DEBUG_FORTH_WORDS 
218b			;		DMARK "EX5" 
218b			;		CALLMONITOR 
218b			;	endif 
218b			; 
218b			;	if FORTH_ENABLE_FREE 
218b			;	call free 
218b			;	endif 
218b			; 
218b			;	if DEBUG_FORTH_WORDS 
218b			;		DMARK "EX6" 
218b			;		CALLMONITOR 
218b			;	endif 
218b			; 
218b			;	pop bc 
218b			;	pop de 
218b			;	pop hl 
218b			;;	FORTH_RSP_POP	  
218b			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
218b			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
218b			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
218b			; 
218b			;	if DEBUG_FORTH_WORDS 
218b			;		DMARK "EX7" 
218b			;		CALLMONITOR 
218b			;	endif 
218b			;	NEXTW 
218b			 
218b			;.STKEXEC: 
218b			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
218b			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
218b			; 
218b			; 
218b			;		if DEBUG_FORTH_WORDS_KEY 
218b			;			DMARK "STX" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			;	FORTH_DSP_VALUEHL 
218b			; 
218b			;	ld (store_tmp1), hl    ; count 
218b			; 
218b			;	FORTH_DSP_POP 
218b			;.stkexec1: 
218b			;	ld hl, (store_tmp1)   ; count 
218b			;	ld a, 0 
218b			;	cp l 
218b			;	ret z 
218b			; 
218b			;	dec hl 
218b			;	ld (store_tmp1), hl    ; count 
218b			;	 
218b			;	FORTH_DSP_VALUEHL 
218b			;	push hl 
218b			;	 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EXp" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	FORTH_DSP_POP 
218b			; 
218b			;	call strlenz 
218b			;	inc hl   ; include zero term to copy 
218b			;	inc hl   ; include zero term to copy 
218b			;	inc hl   ; include zero term to copy 
218b			;	ld b,0 
218b			;	ld c,l 
218b			;	pop hl 
218b			;	ld de, execscratch 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EX3" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	ldir 
218b			; 
218b			; 
218b			;	ld hl, execscratch 
218b			; 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EXP" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			; 
218b			;	call forthparse 
218b			;	ld hl, execscratch 
218b			;		if DEBUG_FORTH_WORDS 
218b			;			DMARK "EXx" 
218b			;			CALLMONITOR 
218b			;		endif 
218b			;	call forthexec 
218b			; 
218b			;	jp .stkexec1 
218b			; 
218b			;	ret 
218b			 
218b			 
218b			.DUP: 
218b				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
218b 17				db WORD_SYS_CORE+OPCODE_DUP             
218c 01 22			dw .ZDUP            
218e 04				db 3 + 1 
218f .. 00			db "DUP",0              
2193				endm 
# End of macro CWHEAD
2193			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2193			 
2193					if DEBUG_FORTH_WORDS_KEY 
2193						DMARK "DUP" 
2193 f5				push af  
2194 3a a8 21			ld a, (.dmark)  
2197 32 6b ee			ld (debug_mark),a  
219a 3a a9 21			ld a, (.dmark+1)  
219d 32 6c ee			ld (debug_mark+1),a  
21a0 3a aa 21			ld a, (.dmark+2)  
21a3 32 6d ee			ld (debug_mark+2),a  
21a6 18 03			jr .pastdmark  
21a8 ..			.dmark: db "DUP"  
21ab f1			.pastdmark: pop af  
21ac			endm  
# End of macro DMARK
21ac						CALLMONITOR 
21ac cd 6f ee			call debug_vector  
21af				endm  
# End of macro CALLMONITOR
21af					endif 
21af			 
21af					FORTH_DSP 
21af cd 04 1e			call macro_forth_dsp 
21b2				endm 
# End of macro FORTH_DSP
21b2			 
21b2 7e					ld a, (HL) 
21b3 fe 01				cp DS_TYPE_STR 
21b5 20 25				jr nz, .dupinum 
21b7			 
21b7					; push another string 
21b7			 
21b7					FORTH_DSP_VALUEHL     		 
21b7 cd 3e 1e			call macro_dsp_valuehl 
21ba				endm 
# End of macro FORTH_DSP_VALUEHL
21ba			 
21ba				if DEBUG_FORTH_WORDS 
21ba					DMARK "DUs" 
21ba f5				push af  
21bb 3a cf 21			ld a, (.dmark)  
21be 32 6b ee			ld (debug_mark),a  
21c1 3a d0 21			ld a, (.dmark+1)  
21c4 32 6c ee			ld (debug_mark+1),a  
21c7 3a d1 21			ld a, (.dmark+2)  
21ca 32 6d ee			ld (debug_mark+2),a  
21cd 18 03			jr .pastdmark  
21cf ..			.dmark: db "DUs"  
21d2 f1			.pastdmark: pop af  
21d3			endm  
# End of macro DMARK
21d3					CALLMONITOR 
21d3 cd 6f ee			call debug_vector  
21d6				endm  
# End of macro CALLMONITOR
21d6				endif 
21d6 cd b5 1c				call forth_push_str 
21d9			 
21d9					NEXTW 
21d9 c3 f4 1f			jp macro_next 
21dc				endm 
# End of macro NEXTW
21dc			 
21dc			 
21dc			.dupinum: 
21dc					 
21dc			 
21dc			 
21dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21dc cd 3e 1e			call macro_dsp_valuehl 
21df				endm 
# End of macro FORTH_DSP_VALUEHL
21df			 
21df				; TODO add floating point number detection 
21df			 
21df				if DEBUG_FORTH_WORDS 
21df					DMARK "DUi" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 6b ee			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 6c ee			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 6d ee			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "DUi"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8					CALLMONITOR 
21f8 cd 6f ee			call debug_vector  
21fb				endm  
# End of macro CALLMONITOR
21fb				endif 
21fb			 
21fb cd 47 1c				call forth_push_numhl 
21fe					NEXTW 
21fe c3 f4 1f			jp macro_next 
2201				endm 
# End of macro NEXTW
2201			.ZDUP: 
2201				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2201 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2202 39 22			dw .SWAP            
2204 05				db 4 + 1 
2205 .. 00			db "?DUP",0              
220a				endm 
# End of macro CWHEAD
220a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
220a			 
220a					if DEBUG_FORTH_WORDS_KEY 
220a						DMARK "qDU" 
220a f5				push af  
220b 3a 1f 22			ld a, (.dmark)  
220e 32 6b ee			ld (debug_mark),a  
2211 3a 20 22			ld a, (.dmark+1)  
2214 32 6c ee			ld (debug_mark+1),a  
2217 3a 21 22			ld a, (.dmark+2)  
221a 32 6d ee			ld (debug_mark+2),a  
221d 18 03			jr .pastdmark  
221f ..			.dmark: db "qDU"  
2222 f1			.pastdmark: pop af  
2223			endm  
# End of macro DMARK
2223						CALLMONITOR 
2223 cd 6f ee			call debug_vector  
2226				endm  
# End of macro CALLMONITOR
2226					endif 
2226					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2226 cd 3e 1e			call macro_dsp_valuehl 
2229				endm 
# End of macro FORTH_DSP_VALUEHL
2229			 
2229 e5					push hl 
222a			 
222a					; is it a zero? 
222a			 
222a 3e 00				ld a, 0 
222c 84					add h 
222d 85					add l 
222e			 
222e e1					pop hl 
222f			 
222f fe 00				cp 0 
2231 28 03				jr z, .dup2orig 
2233			 
2233			 
2233 cd 47 1c				call forth_push_numhl 
2236			 
2236			 
2236				; TODO add floating point number detection 
2236			 
2236			.dup2orig: 
2236			 
2236					NEXTW 
2236 c3 f4 1f			jp macro_next 
2239				endm 
# End of macro NEXTW
2239			.SWAP: 
2239				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2239 18				db WORD_SYS_CORE+OPCODE_SWAP             
223a 78 22			dw .COLN            
223c 05				db 4 + 1 
223d .. 00			db "SWAP",0              
2242				endm 
# End of macro CWHEAD
2242			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2242					if DEBUG_FORTH_WORDS_KEY 
2242						DMARK "SWP" 
2242 f5				push af  
2243 3a 57 22			ld a, (.dmark)  
2246 32 6b ee			ld (debug_mark),a  
2249 3a 58 22			ld a, (.dmark+1)  
224c 32 6c ee			ld (debug_mark+1),a  
224f 3a 59 22			ld a, (.dmark+2)  
2252 32 6d ee			ld (debug_mark+2),a  
2255 18 03			jr .pastdmark  
2257 ..			.dmark: db "SWP"  
225a f1			.pastdmark: pop af  
225b			endm  
# End of macro DMARK
225b						CALLMONITOR 
225b cd 6f ee			call debug_vector  
225e				endm  
# End of macro CALLMONITOR
225e					endif 
225e			 
225e			; TODO Use os stack swap memory 
225e					FORTH_DSP_VALUEHL 
225e cd 3e 1e			call macro_dsp_valuehl 
2261				endm 
# End of macro FORTH_DSP_VALUEHL
2261 e5					push hl     ; w2 
2262			 
2262					FORTH_DSP_POP 
2262 cd f6 1e			call macro_forth_dsp_pop 
2265				endm 
# End of macro FORTH_DSP_POP
2265			 
2265					FORTH_DSP_VALUEHL 
2265 cd 3e 1e			call macro_dsp_valuehl 
2268				endm 
# End of macro FORTH_DSP_VALUEHL
2268			 
2268					FORTH_DSP_POP 
2268 cd f6 1e			call macro_forth_dsp_pop 
226b				endm 
# End of macro FORTH_DSP_POP
226b			 
226b d1					pop de     ; w2	, hl = w1 
226c			 
226c eb					ex de, hl 
226d d5					push de 
226e			 
226e cd 47 1c				call forth_push_numhl 
2271			 
2271 e1					pop hl 
2272			 
2272 cd 47 1c				call forth_push_numhl 
2275					 
2275			 
2275					NEXTW 
2275 c3 f4 1f			jp macro_next 
2278				endm 
# End of macro NEXTW
2278			.COLN: 
2278				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2278 19				db WORD_SYS_CORE+OPCODE_COLN             
2279 04 24			dw .SCOLN            
227b 02				db 1 + 1 
227c .. 00			db ":",0              
227e				endm 
# End of macro CWHEAD
227e			; | : ( -- )         Create new word | DONE 
227e			 
227e					if DEBUG_FORTH_WORDS_KEY 
227e						DMARK "CLN" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 6b ee			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 6c ee			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 6d ee			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db "CLN"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297						CALLMONITOR 
2297 cd 6f ee			call debug_vector  
229a				endm  
# End of macro CALLMONITOR
229a					endif 
229a				STACKFRAME OFF $8efe $989f 
229a				if DEBUG_STACK_IMB 
229a					if OFF 
229a						exx 
229a						ld de, $8efe 
229a						ld a, d 
229a						ld hl, curframe 
229a						call hexout 
229a						ld a, e 
229a						ld hl, curframe+2 
229a						call hexout 
229a						ld hl, $8efe 
229a						push hl 
229a						ld hl, $989f 
229a						push hl 
229a						exx 
229a					endif 
229a				endif 
229a			endm 
# End of macro STACKFRAME
229a				; get parser buffer length  of new word 
229a			 
229a				 
229a			 
229a					; move tok past this to start of name defintition 
229a					; TODO get word to define 
229a					; TODO Move past word token 
229a					; TODO get length of string up to the ';' 
229a			 
229a 2a c2 e5			ld hl, (os_tok_ptr) 
229d 23				inc hl 
229e 23				inc hl 
229f			 
229f 3e 3b			ld a, ';' 
22a1 cd 50 12			call strlent 
22a4			 
22a4 7d				ld a,l 
22a5 32 b1 e2			ld (os_new_parse_len), a 
22a8			 
22a8			 
22a8			if DEBUG_FORTH_UWORD 
22a8 ed 5b c2 e5		ld de, (os_tok_ptr) 
22ac						DMARK ":01" 
22ac f5				push af  
22ad 3a c1 22			ld a, (.dmark)  
22b0 32 6b ee			ld (debug_mark),a  
22b3 3a c2 22			ld a, (.dmark+1)  
22b6 32 6c ee			ld (debug_mark+1),a  
22b9 3a c3 22			ld a, (.dmark+2)  
22bc 32 6d ee			ld (debug_mark+2),a  
22bf 18 03			jr .pastdmark  
22c1 ..			.dmark: db ":01"  
22c4 f1			.pastdmark: pop af  
22c5			endm  
# End of macro DMARK
22c5				CALLMONITOR 
22c5 cd 6f ee			call debug_vector  
22c8				endm  
# End of macro CALLMONITOR
22c8			endif 
22c8			 
22c8			; 
22c8			;  new word memory layout: 
22c8			;  
22c8			;    : adg 6666 ;  
22c8			; 
22c8			;    db   1     ; user defined word  
22c8 23				inc hl    
22c9			;    dw   sysdict 
22c9 23				inc hl 
22ca 23				inc hl 
22cb			;    db <word len>+1 (for null) 
22cb 23				inc hl 
22cc			;    db .... <word> 
22cc			; 
22cc			 
22cc 23				inc hl    ; some extras for the word preamble before the above 
22cd 23				inc hl 
22ce 23				inc hl 
22cf 23				inc hl 
22d0 23				inc hl 
22d1 23				inc hl 
22d2 23				inc hl  
22d3 23				inc hl 
22d4 23				inc hl 
22d5 23				inc hl 
22d6 23				inc hl 
22d7 23				inc hl 
22d8 23				inc hl 
22d9 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22da			;       exec word buffer 
22da			;	<ptr word>   
22da 23				inc hl 
22db 23				inc hl 
22dc			;       <word list><null term> 7F final term 
22dc			 
22dc			 
22dc			if DEBUG_FORTH_UWORD 
22dc						DMARK ":02" 
22dc f5				push af  
22dd 3a f1 22			ld a, (.dmark)  
22e0 32 6b ee			ld (debug_mark),a  
22e3 3a f2 22			ld a, (.dmark+1)  
22e6 32 6c ee			ld (debug_mark+1),a  
22e9 3a f3 22			ld a, (.dmark+2)  
22ec 32 6d ee			ld (debug_mark+2),a  
22ef 18 03			jr .pastdmark  
22f1 ..			.dmark: db ":02"  
22f4 f1			.pastdmark: pop af  
22f5			endm  
# End of macro DMARK
22f5				CALLMONITOR 
22f5 cd 6f ee			call debug_vector  
22f8				endm  
# End of macro CALLMONITOR
22f8			endif 
22f8			 
22f8				 
22f8					; malloc the size 
22f8			 
22f8 cd ae 12				call malloc 
22fb 22 b3 e2				ld (os_new_malloc), hl     ; save malloc start 
22fe			 
22fe			;    db   1     ; user defined word  
22fe 3e 01				ld a, WORD_SYS_UWORD  
2300 77					ld (hl), a 
2301				 
2301 23				inc hl    
2302			;    dw   sysdict 
2302 11 4c 21			ld de, sysdict       ; continue on with the scan to the system dict 
2305 73				ld (hl), e 
2306 23				inc hl 
2307 72				ld (hl), d 
2308 23				inc hl 
2309			 
2309			 
2309			;    Setup dict word 
2309			 
2309 23				inc hl 
230a 22 ad e2			ld (os_new_work_ptr), hl     ; save start of dict word  
230d			 
230d				; 1. get length of dict word 
230d			 
230d			 
230d 2a c2 e5			ld hl, (os_tok_ptr) 
2310 23				inc hl 
2311 23				inc hl    ; position to start of dict word 
2312 3e 00			ld a, 0 
2314 cd 50 12			call strlent 
2317			 
2317			 
2317 23				inc hl    ; to include null??? 
2318			 
2318				; write length of dict word 
2318			 
2318 ed 5b ad e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
231c 1b				dec de 
231d eb				ex de, hl 
231e 73				ld (hl), e 
231f eb				ex de, hl 
2320			 
2320				 
2320			 
2320				; copy  
2320 4d				ld c, l 
2321 06 00			ld b, 0 
2323 ed 5b ad e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2327 2a c2 e5			ld hl, (os_tok_ptr) 
232a 23				inc hl 
232b 23				inc hl    ; position to start of dict word 
232c				 
232c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
232c				 
232c				; TODO need to convert word to upper case 
232c			 
232c			ucasetok:	 
232c 7e				ld a,(hl) 
232d cd 3c 12			call toUpper 
2330 77				ld (hl),a 
2331 ed a0			ldi 
2333 f2 2c 23		 	jp p, ucasetok 
2336			 
2336			 
2336			 
2336				; de now points to start of where the word body code should be placed 
2336 ed 53 ad e2		ld (os_new_work_ptr), de 
233a				; hl now points to the words to throw at forthexec which needs to be copied 
233a 22 ab e2			ld (os_new_src_ptr), hl 
233d			 
233d				; TODO add 'call to forthexec' 
233d			 
233d			if DEBUG_FORTH_UWORD 
233d c5				push bc 
233e ed 4b b3 e2		ld bc, (os_new_malloc) 
2342						DMARK ":0x" 
2342 f5				push af  
2343 3a 57 23			ld a, (.dmark)  
2346 32 6b ee			ld (debug_mark),a  
2349 3a 58 23			ld a, (.dmark+1)  
234c 32 6c ee			ld (debug_mark+1),a  
234f 3a 59 23			ld a, (.dmark+2)  
2352 32 6d ee			ld (debug_mark+2),a  
2355 18 03			jr .pastdmark  
2357 ..			.dmark: db ":0x"  
235a f1			.pastdmark: pop af  
235b			endm  
# End of macro DMARK
235b				CALLMONITOR 
235b cd 6f ee			call debug_vector  
235e				endm  
# End of macro CALLMONITOR
235e c1				pop bc 
235f			endif 
235f			 
235f			 
235f				; create word preamble which should be: 
235f			 
235f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
235f			 
235f				;    ld hl, <word code> 
235f				;    jp user_exec 
235f			        ;    <word code bytes> 
235f			 
235f			 
235f			;	inc de     ; TODO ??? or are we already past the word's null 
235f eb				ex de, hl 
2360			 
2360 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2362			 
2362 23				inc hl 
2363 22 a7 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2366 23				inc hl 
2367			 
2367 23				inc hl 
2368 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
236a			 
236a 01 61 4c			ld bc, user_exec 
236d 23				inc hl 
236e 71				ld (hl), c     ; poke address of user_exec 
236f 23				inc hl 
2370 70				ld (hl), b     
2371			 ; 
2371			;	inc hl 
2371			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2371			; 
2371			; 
2371			;	ld bc, macro_forth_rsp_next 
2371			;	inc hl 
2371			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2371			;	inc hl 
2371			;	ld (hl), b     
2371			 ; 
2371			;	inc hl 
2371			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2371			; 
2371			; 
2371			;	inc hl 
2371			;	ld bc, forthexec 
2371			;	ld (hl), c     ; poke address of forthexec 
2371			;	inc hl 
2371			;	ld (hl), b      
2371			; 
2371			;	inc hl 
2371			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2371			; 
2371			;	ld bc, user_dict_next 
2371			;	inc hl 
2371			;	ld (hl), c     ; poke address of forthexec 
2371			;	inc hl 
2371			;	ld (hl), b      
2371			 
2371				; hl is now where we need to copy the word byte data to save this 
2371			 
2371 23				inc hl 
2372 22 a9 e2			ld (os_new_exec), hl 
2375				 
2375				; copy definition 
2375			 
2375 eb				ex de, hl 
2376			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2376			;	inc de    ; skip the PC for this parse 
2376 3a b1 e2			ld a, (os_new_parse_len) 
2379 4f				ld c, a 
237a 06 00			ld b, 0 
237c ed b0			ldir		 ; copy defintion 
237e			 
237e			 
237e				; poke the address of where the new word bytes live for forthexec 
237e			 
237e 2a a7 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2381			 
2381 ed 5b a9 e2		ld de, (os_new_exec)      
2385				 
2385 73				ld (hl), e 
2386 23				inc hl 
2387 72				ld (hl), d 
2388			 
2388					; TODO copy last user dict word next link to this word 
2388					; TODO update last user dict word to point to this word 
2388			; 
2388			; hl f923 de 812a ; bc 811a 
2388			 
2388			if DEBUG_FORTH_UWORD 
2388 c5				push bc 
2389 ed 4b b3 e2		ld bc, (os_new_malloc) 
238d						DMARK ":0A" 
238d f5				push af  
238e 3a a2 23			ld a, (.dmark)  
2391 32 6b ee			ld (debug_mark),a  
2394 3a a3 23			ld a, (.dmark+1)  
2397 32 6c ee			ld (debug_mark+1),a  
239a 3a a4 23			ld a, (.dmark+2)  
239d 32 6d ee			ld (debug_mark+2),a  
23a0 18 03			jr .pastdmark  
23a2 ..			.dmark: db ":0A"  
23a5 f1			.pastdmark: pop af  
23a6			endm  
# End of macro DMARK
23a6				CALLMONITOR 
23a6 cd 6f ee			call debug_vector  
23a9				endm  
# End of macro CALLMONITOR
23a9 c1				pop bc 
23aa			endif 
23aa			if DEBUG_FORTH_UWORD 
23aa c5				push bc 
23ab ed 4b b3 e2		ld bc, (os_new_malloc) 
23af 03				inc bc 
23b0 03				inc bc 
23b1 03				inc bc 
23b2 03				inc bc 
23b3 03				inc bc 
23b4 03				inc bc 
23b5 03				inc bc 
23b6 03				inc bc 
23b7			 
23b7						DMARK ":0B" 
23b7 f5				push af  
23b8 3a cc 23			ld a, (.dmark)  
23bb 32 6b ee			ld (debug_mark),a  
23be 3a cd 23			ld a, (.dmark+1)  
23c1 32 6c ee			ld (debug_mark+1),a  
23c4 3a ce 23			ld a, (.dmark+2)  
23c7 32 6d ee			ld (debug_mark+2),a  
23ca 18 03			jr .pastdmark  
23cc ..			.dmark: db ":0B"  
23cf f1			.pastdmark: pop af  
23d0			endm  
# End of macro DMARK
23d0				CALLMONITOR 
23d0 cd 6f ee			call debug_vector  
23d3				endm  
# End of macro CALLMONITOR
23d3 c1				pop bc 
23d4			endif 
23d4			 
23d4			; update word dict linked list for new word 
23d4			 
23d4			 
23d4 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23d7 23			inc hl     ; move to next work linked list ptr 
23d8			 
23d8 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
23dc 73			ld (hl), e 
23dd 23			inc hl 
23de 72			ld (hl), d 
23df			 
23df			if DEBUG_FORTH_UWORD 
23df ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23e3			endif 
23e3			 
23e3 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23e7			 
23e7			 
23e7			if DEBUG_FORTH_UWORD 
23e7						DMARK ":0+" 
23e7 f5				push af  
23e8 3a fc 23			ld a, (.dmark)  
23eb 32 6b ee			ld (debug_mark),a  
23ee 3a fd 23			ld a, (.dmark+1)  
23f1 32 6c ee			ld (debug_mark+1),a  
23f4 3a fe 23			ld a, (.dmark+2)  
23f7 32 6d ee			ld (debug_mark+2),a  
23fa 18 03			jr .pastdmark  
23fc ..			.dmark: db ":0+"  
23ff f1			.pastdmark: pop af  
2400			endm  
# End of macro DMARK
2400				CALLMONITOR 
2400 cd 6f ee			call debug_vector  
2403				endm  
# End of macro CALLMONITOR
2403			endif 
2403			 
2403				STACKFRAMECHK OFF $8efe $989f 
2403				if DEBUG_STACK_IMB 
2403					if OFF 
2403						exx 
2403						ld hl, $989f 
2403						pop de   ; $989f 
2403						call cmp16 
2403						jr nz, .spnosame 
2403						ld hl, $8efe 
2403						pop de   ; $8efe 
2403						call cmp16 
2403						jr z, .spfrsame 
2403						.spnosame: call showsperror 
2403						.spfrsame: nop 
2403						exx 
2403					endif 
2403				endif 
2403			endm 
# End of macro STACKFRAMECHK
2403			 
2403 c9			ret    ; dont process any remaining parser tokens as they form new word 
2404			 
2404			 
2404			 
2404			 
2404			;		NEXT 
2404			.SCOLN: 
2404			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2404 06				db OPCODE_SCOLN 
2405 50 24			dw .DROP 
2407 02				db 2 
2408 .. 00			db ";",0           
240a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
240a					if DEBUG_FORTH_WORDS_KEY 
240a						DMARK "SCN" 
240a f5				push af  
240b 3a 1f 24			ld a, (.dmark)  
240e 32 6b ee			ld (debug_mark),a  
2411 3a 20 24			ld a, (.dmark+1)  
2414 32 6c ee			ld (debug_mark+1),a  
2417 3a 21 24			ld a, (.dmark+2)  
241a 32 6d ee			ld (debug_mark+2),a  
241d 18 03			jr .pastdmark  
241f ..			.dmark: db "SCN"  
2422 f1			.pastdmark: pop af  
2423			endm  
# End of macro DMARK
2423						CALLMONITOR 
2423 cd 6f ee			call debug_vector  
2426				endm  
# End of macro CALLMONITOR
2426					endif 
2426					FORTH_RSP_TOS 
2426 cd 05 1c			call macro_forth_rsp_tos 
2429				endm 
# End of macro FORTH_RSP_TOS
2429 e5					push hl 
242a					FORTH_RSP_POP 
242a cd 0f 1c			call macro_forth_rsp_pop 
242d				endm 
# End of macro FORTH_RSP_POP
242d e1					pop hl 
242e			;		ex de,hl 
242e 22 c2 e5				ld (os_tok_ptr),hl 
2431			 
2431			if DEBUG_FORTH_UWORD 
2431						DMARK "SCL" 
2431 f5				push af  
2432 3a 46 24			ld a, (.dmark)  
2435 32 6b ee			ld (debug_mark),a  
2438 3a 47 24			ld a, (.dmark+1)  
243b 32 6c ee			ld (debug_mark+1),a  
243e 3a 48 24			ld a, (.dmark+2)  
2441 32 6d ee			ld (debug_mark+2),a  
2444 18 03			jr .pastdmark  
2446 ..			.dmark: db "SCL"  
2449 f1			.pastdmark: pop af  
244a			endm  
# End of macro DMARK
244a				CALLMONITOR 
244a cd 6f ee			call debug_vector  
244d				endm  
# End of macro CALLMONITOR
244d			endif 
244d					NEXTW 
244d c3 f4 1f			jp macro_next 
2450				endm 
# End of macro NEXTW
2450			 
2450			.DROP: 
2450				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2450 1b				db WORD_SYS_CORE+OPCODE_DROP             
2451 7b 24			dw .DUP2            
2453 05				db 4 + 1 
2454 .. 00			db "DROP",0              
2459				endm 
# End of macro CWHEAD
2459			; | DROP ( w -- )   drop the TOS item   | DONE 
2459					if DEBUG_FORTH_WORDS_KEY 
2459						DMARK "DRP" 
2459 f5				push af  
245a 3a 6e 24			ld a, (.dmark)  
245d 32 6b ee			ld (debug_mark),a  
2460 3a 6f 24			ld a, (.dmark+1)  
2463 32 6c ee			ld (debug_mark+1),a  
2466 3a 70 24			ld a, (.dmark+2)  
2469 32 6d ee			ld (debug_mark+2),a  
246c 18 03			jr .pastdmark  
246e ..			.dmark: db "DRP"  
2471 f1			.pastdmark: pop af  
2472			endm  
# End of macro DMARK
2472						CALLMONITOR 
2472 cd 6f ee			call debug_vector  
2475				endm  
# End of macro CALLMONITOR
2475					endif 
2475					FORTH_DSP_POP 
2475 cd f6 1e			call macro_forth_dsp_pop 
2478				endm 
# End of macro FORTH_DSP_POP
2478					NEXTW 
2478 c3 f4 1f			jp macro_next 
247b				endm 
# End of macro NEXTW
247b			.DUP2: 
247b				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
247b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
247c c0 24			dw .DROP2            
247e 05				db 4 + 1 
247f .. 00			db "2DUP",0              
2484				endm 
# End of macro CWHEAD
2484			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2484					if DEBUG_FORTH_WORDS_KEY 
2484						DMARK "2DU" 
2484 f5				push af  
2485 3a 99 24			ld a, (.dmark)  
2488 32 6b ee			ld (debug_mark),a  
248b 3a 9a 24			ld a, (.dmark+1)  
248e 32 6c ee			ld (debug_mark+1),a  
2491 3a 9b 24			ld a, (.dmark+2)  
2494 32 6d ee			ld (debug_mark+2),a  
2497 18 03			jr .pastdmark  
2499 ..			.dmark: db "2DU"  
249c f1			.pastdmark: pop af  
249d			endm  
# End of macro DMARK
249d						CALLMONITOR 
249d cd 6f ee			call debug_vector  
24a0				endm  
# End of macro CALLMONITOR
24a0					endif 
24a0					FORTH_DSP_VALUEHL 
24a0 cd 3e 1e			call macro_dsp_valuehl 
24a3				endm 
# End of macro FORTH_DSP_VALUEHL
24a3 e5					push hl      ; 2 
24a4			 
24a4					FORTH_DSP_POP 
24a4 cd f6 1e			call macro_forth_dsp_pop 
24a7				endm 
# End of macro FORTH_DSP_POP
24a7					 
24a7					FORTH_DSP_VALUEHL 
24a7 cd 3e 1e			call macro_dsp_valuehl 
24aa				endm 
# End of macro FORTH_DSP_VALUEHL
24aa			;		push hl      ; 1 
24aa			 
24aa					FORTH_DSP_POP 
24aa cd f6 1e			call macro_forth_dsp_pop 
24ad				endm 
# End of macro FORTH_DSP_POP
24ad			 
24ad			;		pop hl       ; 1 
24ad d1					pop de       ; 2 
24ae			 
24ae cd 47 1c				call forth_push_numhl 
24b1 eb					ex de, hl 
24b2 cd 47 1c				call forth_push_numhl 
24b5			 
24b5					 
24b5 eb					ex de, hl 
24b6			 
24b6 cd 47 1c				call forth_push_numhl 
24b9 eb					ex de, hl 
24ba cd 47 1c				call forth_push_numhl 
24bd			 
24bd			 
24bd					NEXTW 
24bd c3 f4 1f			jp macro_next 
24c0				endm 
# End of macro NEXTW
24c0			.DROP2: 
24c0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24c0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24c1 ef 24			dw .SWAP2            
24c3 06				db 5 + 1 
24c4 .. 00			db "2DROP",0              
24ca				endm 
# End of macro CWHEAD
24ca			; | 2DROP ( w w -- )    Double drop | DONE 
24ca					if DEBUG_FORTH_WORDS_KEY 
24ca						DMARK "2DR" 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 6b ee			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 6c ee			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 6d ee			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "2DR"  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3						CALLMONITOR 
24e3 cd 6f ee			call debug_vector  
24e6				endm  
# End of macro CALLMONITOR
24e6					endif 
24e6					FORTH_DSP_POP 
24e6 cd f6 1e			call macro_forth_dsp_pop 
24e9				endm 
# End of macro FORTH_DSP_POP
24e9					FORTH_DSP_POP 
24e9 cd f6 1e			call macro_forth_dsp_pop 
24ec				endm 
# End of macro FORTH_DSP_POP
24ec					NEXTW 
24ec c3 f4 1f			jp macro_next 
24ef				endm 
# End of macro NEXTW
24ef			.SWAP2: 
24ef				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24ef 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24f0 18 25			dw .AT            
24f2 06				db 5 + 1 
24f3 .. 00			db "2SWAP",0              
24f9				endm 
# End of macro CWHEAD
24f9			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24f9					if DEBUG_FORTH_WORDS_KEY 
24f9						DMARK "2SW" 
24f9 f5				push af  
24fa 3a 0e 25			ld a, (.dmark)  
24fd 32 6b ee			ld (debug_mark),a  
2500 3a 0f 25			ld a, (.dmark+1)  
2503 32 6c ee			ld (debug_mark+1),a  
2506 3a 10 25			ld a, (.dmark+2)  
2509 32 6d ee			ld (debug_mark+2),a  
250c 18 03			jr .pastdmark  
250e ..			.dmark: db "2SW"  
2511 f1			.pastdmark: pop af  
2512			endm  
# End of macro DMARK
2512						CALLMONITOR 
2512 cd 6f ee			call debug_vector  
2515				endm  
# End of macro CALLMONITOR
2515					endif 
2515			; TODO Use os stack swap memory 
2515					NEXTW 
2515 c3 f4 1f			jp macro_next 
2518				endm 
# End of macro NEXTW
2518			.AT: 
2518				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2518 1f				db WORD_SYS_CORE+OPCODE_AT             
2519 4a 25			dw .CAT            
251b 02				db 1 + 1 
251c .. 00			db "@",0              
251e				endm 
# End of macro CWHEAD
251e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
251e			 
251e					if DEBUG_FORTH_WORDS_KEY 
251e						DMARK "AT." 
251e f5				push af  
251f 3a 33 25			ld a, (.dmark)  
2522 32 6b ee			ld (debug_mark),a  
2525 3a 34 25			ld a, (.dmark+1)  
2528 32 6c ee			ld (debug_mark+1),a  
252b 3a 35 25			ld a, (.dmark+2)  
252e 32 6d ee			ld (debug_mark+2),a  
2531 18 03			jr .pastdmark  
2533 ..			.dmark: db "AT."  
2536 f1			.pastdmark: pop af  
2537			endm  
# End of macro DMARK
2537						CALLMONITOR 
2537 cd 6f ee			call debug_vector  
253a				endm  
# End of macro CALLMONITOR
253a					endif 
253a			.getbyteat:	 
253a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
253a cd 3e 1e			call macro_dsp_valuehl 
253d				endm 
# End of macro FORTH_DSP_VALUEHL
253d					 
253d			;		push hl 
253d				 
253d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253d cd f6 1e			call macro_forth_dsp_pop 
2540				endm 
# End of macro FORTH_DSP_POP
2540			 
2540			;		pop hl 
2540			 
2540 7e					ld a, (hl) 
2541			 
2541 6f					ld l, a 
2542 26 00				ld h, 0 
2544 cd 47 1c				call forth_push_numhl 
2547			 
2547					NEXTW 
2547 c3 f4 1f			jp macro_next 
254a				endm 
# End of macro NEXTW
254a			.CAT: 
254a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
254a 20				db WORD_SYS_CORE+OPCODE_CAT             
254b 73 25			dw .BANG            
254d 03				db 2 + 1 
254e .. 00			db "C@",0              
2551				endm 
# End of macro CWHEAD
2551			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2551					if DEBUG_FORTH_WORDS_KEY 
2551						DMARK "CAA" 
2551 f5				push af  
2552 3a 66 25			ld a, (.dmark)  
2555 32 6b ee			ld (debug_mark),a  
2558 3a 67 25			ld a, (.dmark+1)  
255b 32 6c ee			ld (debug_mark+1),a  
255e 3a 68 25			ld a, (.dmark+2)  
2561 32 6d ee			ld (debug_mark+2),a  
2564 18 03			jr .pastdmark  
2566 ..			.dmark: db "CAA"  
2569 f1			.pastdmark: pop af  
256a			endm  
# End of macro DMARK
256a						CALLMONITOR 
256a cd 6f ee			call debug_vector  
256d				endm  
# End of macro CALLMONITOR
256d					endif 
256d c3 3a 25				jp .getbyteat 
2570					NEXTW 
2570 c3 f4 1f			jp macro_next 
2573				endm 
# End of macro NEXTW
2573			.BANG: 
2573				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2573 21				db WORD_SYS_CORE+OPCODE_BANG             
2574 a9 25			dw .CBANG            
2576 02				db 1 + 1 
2577 .. 00			db "!",0              
2579				endm 
# End of macro CWHEAD
2579			; | ! ( x w -- ) Store x at address w      | DONE 
2579					if DEBUG_FORTH_WORDS_KEY 
2579						DMARK "BNG" 
2579 f5				push af  
257a 3a 8e 25			ld a, (.dmark)  
257d 32 6b ee			ld (debug_mark),a  
2580 3a 8f 25			ld a, (.dmark+1)  
2583 32 6c ee			ld (debug_mark+1),a  
2586 3a 90 25			ld a, (.dmark+2)  
2589 32 6d ee			ld (debug_mark+2),a  
258c 18 03			jr .pastdmark  
258e ..			.dmark: db "BNG"  
2591 f1			.pastdmark: pop af  
2592			endm  
# End of macro DMARK
2592						CALLMONITOR 
2592 cd 6f ee			call debug_vector  
2595				endm  
# End of macro CALLMONITOR
2595					endif 
2595			 
2595			.storebyteat:		 
2595					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2595 cd 3e 1e			call macro_dsp_valuehl 
2598				endm 
# End of macro FORTH_DSP_VALUEHL
2598					 
2598 e5					push hl 
2599				 
2599					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2599 cd f6 1e			call macro_forth_dsp_pop 
259c				endm 
# End of macro FORTH_DSP_POP
259c			 
259c					; get byte to poke 
259c			 
259c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259c cd 3e 1e			call macro_dsp_valuehl 
259f				endm 
# End of macro FORTH_DSP_VALUEHL
259f e5					push hl 
25a0			 
25a0			 
25a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a0 cd f6 1e			call macro_forth_dsp_pop 
25a3				endm 
# End of macro FORTH_DSP_POP
25a3			 
25a3			 
25a3 d1					pop de 
25a4 e1					pop hl 
25a5			 
25a5 73					ld (hl),e 
25a6			 
25a6			 
25a6					NEXTW 
25a6 c3 f4 1f			jp macro_next 
25a9				endm 
# End of macro NEXTW
25a9			.CBANG: 
25a9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25a9 22				db WORD_SYS_CORE+OPCODE_CBANG             
25aa d2 25			dw .SCALL            
25ac 03				db 2 + 1 
25ad .. 00			db "C!",0              
25b0				endm 
# End of macro CWHEAD
25b0			; | C!  ( x w -- ) Store x at address w  | DONE 
25b0					if DEBUG_FORTH_WORDS_KEY 
25b0						DMARK "CBA" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 6b ee			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 6c ee			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 6d ee			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db "CBA"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9						CALLMONITOR 
25c9 cd 6f ee			call debug_vector  
25cc				endm  
# End of macro CALLMONITOR
25cc					endif 
25cc c3 95 25				jp .storebyteat 
25cf					NEXTW 
25cf c3 f4 1f			jp macro_next 
25d2				endm 
# End of macro NEXTW
25d2			.SCALL: 
25d2				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25d2 23				db WORD_SYS_CORE+OPCODE_SCALL             
25d3 06 26			dw .DEPTH            
25d5 05				db 4 + 1 
25d6 .. 00			db "CALL",0              
25db				endm 
# End of macro CWHEAD
25db			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25db					if DEBUG_FORTH_WORDS_KEY 
25db						DMARK "CLL" 
25db f5				push af  
25dc 3a f0 25			ld a, (.dmark)  
25df 32 6b ee			ld (debug_mark),a  
25e2 3a f1 25			ld a, (.dmark+1)  
25e5 32 6c ee			ld (debug_mark+1),a  
25e8 3a f2 25			ld a, (.dmark+2)  
25eb 32 6d ee			ld (debug_mark+2),a  
25ee 18 03			jr .pastdmark  
25f0 ..			.dmark: db "CLL"  
25f3 f1			.pastdmark: pop af  
25f4			endm  
# End of macro DMARK
25f4						CALLMONITOR 
25f4 cd 6f ee			call debug_vector  
25f7				endm  
# End of macro CALLMONITOR
25f7					endif 
25f7			 
25f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f7 cd 3e 1e			call macro_dsp_valuehl 
25fa				endm 
# End of macro FORTH_DSP_VALUEHL
25fa			 
25fa			;		push hl 
25fa			 
25fa					; destroy value TOS 
25fa			 
25fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25fa cd f6 1e			call macro_forth_dsp_pop 
25fd				endm 
# End of macro FORTH_DSP_POP
25fd			 
25fd						 
25fd			;		pop hl 
25fd			 
25fd					; how to do a call with hl???? save SP? 
25fd cd 98 1f				call forth_call_hl 
2600			 
2600			 
2600					; TODO push value back onto stack for another op etc 
2600			 
2600 cd 47 1c				call forth_push_numhl 
2603					NEXTW 
2603 c3 f4 1f			jp macro_next 
2606				endm 
# End of macro NEXTW
2606			.DEPTH: 
2606				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2606 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2607 43 26			dw .OVER            
2609 06				db 5 + 1 
260a .. 00			db "DEPTH",0              
2610				endm 
# End of macro CWHEAD
2610			; | DEPTH ( -- u ) Push count of stack | DONE 
2610					; take current TOS and remove from base value div by two to get count 
2610					if DEBUG_FORTH_WORDS_KEY 
2610						DMARK "DEP" 
2610 f5				push af  
2611 3a 25 26			ld a, (.dmark)  
2614 32 6b ee			ld (debug_mark),a  
2617 3a 26 26			ld a, (.dmark+1)  
261a 32 6c ee			ld (debug_mark+1),a  
261d 3a 27 26			ld a, (.dmark+2)  
2620 32 6d ee			ld (debug_mark+2),a  
2623 18 03			jr .pastdmark  
2625 ..			.dmark: db "DEP"  
2628 f1			.pastdmark: pop af  
2629			endm  
# End of macro DMARK
2629						CALLMONITOR 
2629 cd 6f ee			call debug_vector  
262c				endm  
# End of macro CALLMONITOR
262c					endif 
262c			 
262c			 
262c 2a ee e9			ld hl, (cli_data_sp) 
262f 11 28 e8			ld de, cli_data_stack 
2632 ed 52			sbc hl,de 
2634				 
2634				; div by size of stack item 
2634			 
2634 5d				ld e,l 
2635 0e 03			ld c, 3 
2637 cd 77 0d			call Div8 
263a			 
263a 6f				ld l,a 
263b 26 00			ld h,0 
263d			 
263d				;srl h 
263d				;rr l 
263d			 
263d cd 47 1c				call forth_push_numhl 
2640					NEXTW 
2640 c3 f4 1f			jp macro_next 
2643				endm 
# End of macro NEXTW
2643			.OVER: 
2643				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2643 42				db WORD_SYS_CORE+46             
2644 8a 26			dw .PAUSE            
2646 05				db 4 + 1 
2647 .. 00			db "OVER",0              
264c				endm 
# End of macro CWHEAD
264c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
264c					if DEBUG_FORTH_WORDS_KEY 
264c						DMARK "OVR" 
264c f5				push af  
264d 3a 61 26			ld a, (.dmark)  
2650 32 6b ee			ld (debug_mark),a  
2653 3a 62 26			ld a, (.dmark+1)  
2656 32 6c ee			ld (debug_mark+1),a  
2659 3a 63 26			ld a, (.dmark+2)  
265c 32 6d ee			ld (debug_mark+2),a  
265f 18 03			jr .pastdmark  
2661 ..			.dmark: db "OVR"  
2664 f1			.pastdmark: pop af  
2665			endm  
# End of macro DMARK
2665						CALLMONITOR 
2665 cd 6f ee			call debug_vector  
2668				endm  
# End of macro CALLMONITOR
2668					endif 
2668			 
2668			; TODO Use os stack swap memory 
2668					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2668 cd 3e 1e			call macro_dsp_valuehl 
266b				endm 
# End of macro FORTH_DSP_VALUEHL
266b e5					push hl    ; n2 
266c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266c cd f6 1e			call macro_forth_dsp_pop 
266f				endm 
# End of macro FORTH_DSP_POP
266f			 
266f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266f cd 3e 1e			call macro_dsp_valuehl 
2672				endm 
# End of macro FORTH_DSP_VALUEHL
2672 e5					push hl    ; n1 
2673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2673 cd f6 1e			call macro_forth_dsp_pop 
2676				endm 
# End of macro FORTH_DSP_POP
2676			 
2676 d1					pop de     ; n1 
2677 e1					pop hl     ; n2 
2678			 
2678 d5					push de 
2679 e5					push hl 
267a d5					push de 
267b			 
267b					; push back  
267b			 
267b e1					pop hl 
267c cd 47 1c				call forth_push_numhl 
267f e1					pop hl 
2680 cd 47 1c				call forth_push_numhl 
2683 e1					pop hl 
2684 cd 47 1c				call forth_push_numhl 
2687					NEXTW 
2687 c3 f4 1f			jp macro_next 
268a				endm 
# End of macro NEXTW
268a			 
268a			.PAUSE: 
268a				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
268a 43				db WORD_SYS_CORE+47             
268b bf 26			dw .PAUSES            
268d 08				db 7 + 1 
268e .. 00			db "PAUSEMS",0              
2696				endm 
# End of macro CWHEAD
2696			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2696					if DEBUG_FORTH_WORDS_KEY 
2696						DMARK "PMS" 
2696 f5				push af  
2697 3a ab 26			ld a, (.dmark)  
269a 32 6b ee			ld (debug_mark),a  
269d 3a ac 26			ld a, (.dmark+1)  
26a0 32 6c ee			ld (debug_mark+1),a  
26a3 3a ad 26			ld a, (.dmark+2)  
26a6 32 6d ee			ld (debug_mark+2),a  
26a9 18 03			jr .pastdmark  
26ab ..			.dmark: db "PMS"  
26ae f1			.pastdmark: pop af  
26af			endm  
# End of macro DMARK
26af						CALLMONITOR 
26af cd 6f ee			call debug_vector  
26b2				endm  
# End of macro CALLMONITOR
26b2					endif 
26b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b2 cd 3e 1e			call macro_dsp_valuehl 
26b5				endm 
# End of macro FORTH_DSP_VALUEHL
26b5			;		push hl    ; n2 
26b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b5 cd f6 1e			call macro_forth_dsp_pop 
26b8				endm 
# End of macro FORTH_DSP_POP
26b8			;		pop hl 
26b8			 
26b8 7d					ld a, l 
26b9 cd d7 0a				call aDelayInMS 
26bc				       NEXTW 
26bc c3 f4 1f			jp macro_next 
26bf				endm 
# End of macro NEXTW
26bf			.PAUSES:  
26bf				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26bf 44				db WORD_SYS_CORE+48             
26c0 2e 27			dw .ROT            
26c2 06				db 5 + 1 
26c3 .. 00			db "PAUSE",0              
26c9				endm 
# End of macro CWHEAD
26c9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26c9					if DEBUG_FORTH_WORDS_KEY 
26c9						DMARK "PAU" 
26c9 f5				push af  
26ca 3a de 26			ld a, (.dmark)  
26cd 32 6b ee			ld (debug_mark),a  
26d0 3a df 26			ld a, (.dmark+1)  
26d3 32 6c ee			ld (debug_mark+1),a  
26d6 3a e0 26			ld a, (.dmark+2)  
26d9 32 6d ee			ld (debug_mark+2),a  
26dc 18 03			jr .pastdmark  
26de ..			.dmark: db "PAU"  
26e1 f1			.pastdmark: pop af  
26e2			endm  
# End of macro DMARK
26e2						CALLMONITOR 
26e2 cd 6f ee			call debug_vector  
26e5				endm  
# End of macro CALLMONITOR
26e5					endif 
26e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e5 cd 3e 1e			call macro_dsp_valuehl 
26e8				endm 
# End of macro FORTH_DSP_VALUEHL
26e8			;		push hl    ; n2 
26e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e8 cd f6 1e			call macro_forth_dsp_pop 
26eb				endm 
# End of macro FORTH_DSP_POP
26eb			;		pop hl 
26eb 45					ld b, l 
26ec					if DEBUG_FORTH_WORDS 
26ec						DMARK "PAU" 
26ec f5				push af  
26ed 3a 01 27			ld a, (.dmark)  
26f0 32 6b ee			ld (debug_mark),a  
26f3 3a 02 27			ld a, (.dmark+1)  
26f6 32 6c ee			ld (debug_mark+1),a  
26f9 3a 03 27			ld a, (.dmark+2)  
26fc 32 6d ee			ld (debug_mark+2),a  
26ff 18 03			jr .pastdmark  
2701 ..			.dmark: db "PAU"  
2704 f1			.pastdmark: pop af  
2705			endm  
# End of macro DMARK
2705						CALLMONITOR 
2705 cd 6f ee			call debug_vector  
2708				endm  
# End of macro CALLMONITOR
2708					endif 
2708 c5			.pauses1:	push bc 
2709 cd f2 0a				call delay1s 
270c c1					pop bc 
270d					if DEBUG_FORTH_WORDS 
270d						DMARK "PA1" 
270d f5				push af  
270e 3a 22 27			ld a, (.dmark)  
2711 32 6b ee			ld (debug_mark),a  
2714 3a 23 27			ld a, (.dmark+1)  
2717 32 6c ee			ld (debug_mark+1),a  
271a 3a 24 27			ld a, (.dmark+2)  
271d 32 6d ee			ld (debug_mark+2),a  
2720 18 03			jr .pastdmark  
2722 ..			.dmark: db "PA1"  
2725 f1			.pastdmark: pop af  
2726			endm  
# End of macro DMARK
2726						CALLMONITOR 
2726 cd 6f ee			call debug_vector  
2729				endm  
# End of macro CALLMONITOR
2729					endif 
2729 10 dd				djnz .pauses1 
272b			 
272b				       NEXTW 
272b c3 f4 1f			jp macro_next 
272e				endm 
# End of macro NEXTW
272e			.ROT: 
272e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
272e 45				db WORD_SYS_CORE+49             
272f 7c 27			dw .UWORDS            
2731 04				db 3 + 1 
2732 .. 00			db "ROT",0              
2736				endm 
# End of macro CWHEAD
2736			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2736					if DEBUG_FORTH_WORDS_KEY 
2736						DMARK "ROT" 
2736 f5				push af  
2737 3a 4b 27			ld a, (.dmark)  
273a 32 6b ee			ld (debug_mark),a  
273d 3a 4c 27			ld a, (.dmark+1)  
2740 32 6c ee			ld (debug_mark+1),a  
2743 3a 4d 27			ld a, (.dmark+2)  
2746 32 6d ee			ld (debug_mark+2),a  
2749 18 03			jr .pastdmark  
274b ..			.dmark: db "ROT"  
274e f1			.pastdmark: pop af  
274f			endm  
# End of macro DMARK
274f						CALLMONITOR 
274f cd 6f ee			call debug_vector  
2752				endm  
# End of macro CALLMONITOR
2752					endif 
2752			 
2752			; TODO Use os stack swap memory 
2752					FORTH_DSP_VALUEHL 
2752 cd 3e 1e			call macro_dsp_valuehl 
2755				endm 
# End of macro FORTH_DSP_VALUEHL
2755 e5					push hl    ; u3  
2756			 
2756					FORTH_DSP_POP 
2756 cd f6 1e			call macro_forth_dsp_pop 
2759				endm 
# End of macro FORTH_DSP_POP
2759			   
2759					FORTH_DSP_VALUEHL 
2759 cd 3e 1e			call macro_dsp_valuehl 
275c				endm 
# End of macro FORTH_DSP_VALUEHL
275c e5					push hl     ; u2 
275d			 
275d					FORTH_DSP_POP 
275d cd f6 1e			call macro_forth_dsp_pop 
2760				endm 
# End of macro FORTH_DSP_POP
2760			 
2760					FORTH_DSP_VALUEHL 
2760 cd 3e 1e			call macro_dsp_valuehl 
2763				endm 
# End of macro FORTH_DSP_VALUEHL
2763 e5					push hl     ; u1 
2764			 
2764					FORTH_DSP_POP 
2764 cd f6 1e			call macro_forth_dsp_pop 
2767				endm 
# End of macro FORTH_DSP_POP
2767			 
2767 c1					pop bc      ; u1 
2768 e1					pop hl      ; u2 
2769 d1					pop de      ; u3 
276a			 
276a			 
276a c5					push bc 
276b d5					push de 
276c e5					push hl 
276d			 
276d			 
276d e1					pop hl 
276e cd 47 1c				call forth_push_numhl 
2771			 
2771 e1					pop hl 
2772 cd 47 1c				call forth_push_numhl 
2775			 
2775 e1					pop hl 
2776 cd 47 1c				call forth_push_numhl 
2779					 
2779			 
2779			 
2779			 
2779			 
2779			 
2779				       NEXTW 
2779 c3 f4 1f			jp macro_next 
277c				endm 
# End of macro NEXTW
277c			 
277c			.UWORDS: 
277c				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
277c 50				db WORD_SYS_CORE+60             
277d 3e 28			dw .BP            
277f 07				db 6 + 1 
2780 .. 00			db "UWORDS",0              
2787				endm 
# End of macro CWHEAD
2787			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2787			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2787			; | | Following the count are the individual words. 
2787			; | | 
2787			; | | e.g. UWORDS 
2787			; | | BOX DIRLIST 2 
2787			; | |  
2787			; | | Can be used to save the words to storage via: 
2787			; | | UWORDS $01 DO $01 APPEND LOOP 
2787				if DEBUG_FORTH_WORDS_KEY 
2787					DMARK "UWR" 
2787 f5				push af  
2788 3a 9c 27			ld a, (.dmark)  
278b 32 6b ee			ld (debug_mark),a  
278e 3a 9d 27			ld a, (.dmark+1)  
2791 32 6c ee			ld (debug_mark+1),a  
2794 3a 9e 27			ld a, (.dmark+2)  
2797 32 6d ee			ld (debug_mark+2),a  
279a 18 03			jr .pastdmark  
279c ..			.dmark: db "UWR"  
279f f1			.pastdmark: pop af  
27a0			endm  
# End of macro DMARK
27a0					CALLMONITOR 
27a0 cd 6f ee			call debug_vector  
27a3				endm  
# End of macro CALLMONITOR
27a3				endif 
27a3 21 91 65				ld hl, baseram 
27a6					;ld hl, baseusermem 
27a6 01 00 00				ld bc, 0    ; start a counter 
27a9			 
27a9				; skip dict stub 
27a9			 
27a9 cd 45 21				call forth_tok_next 
27ac			 
27ac			 
27ac			; while we have words to look for 
27ac			 
27ac 7e			.douscan:	ld a, (hl)      
27ad				if DEBUG_FORTH_WORDS 
27ad					DMARK "UWs" 
27ad f5				push af  
27ae 3a c2 27			ld a, (.dmark)  
27b1 32 6b ee			ld (debug_mark),a  
27b4 3a c3 27			ld a, (.dmark+1)  
27b7 32 6c ee			ld (debug_mark+1),a  
27ba 3a c4 27			ld a, (.dmark+2)  
27bd 32 6d ee			ld (debug_mark+2),a  
27c0 18 03			jr .pastdmark  
27c2 ..			.dmark: db "UWs"  
27c5 f1			.pastdmark: pop af  
27c6			endm  
# End of macro DMARK
27c6					CALLMONITOR 
27c6 cd 6f ee			call debug_vector  
27c9				endm  
# End of macro CALLMONITOR
27c9				endif 
27c9 fe 00				cp WORD_SYS_END 
27cb 28 4d				jr z, .udone 
27cd fe 01				cp WORD_SYS_UWORD 
27cf 20 44				jr nz, .nuword 
27d1			 
27d1				if DEBUG_FORTH_WORDS 
27d1					DMARK "UWu" 
27d1 f5				push af  
27d2 3a e6 27			ld a, (.dmark)  
27d5 32 6b ee			ld (debug_mark),a  
27d8 3a e7 27			ld a, (.dmark+1)  
27db 32 6c ee			ld (debug_mark+1),a  
27de 3a e8 27			ld a, (.dmark+2)  
27e1 32 6d ee			ld (debug_mark+2),a  
27e4 18 03			jr .pastdmark  
27e6 ..			.dmark: db "UWu"  
27e9 f1			.pastdmark: pop af  
27ea			endm  
# End of macro DMARK
27ea					CALLMONITOR 
27ea cd 6f ee			call debug_vector  
27ed				endm  
# End of macro CALLMONITOR
27ed				endif 
27ed					; we have a uword so push its name to the stack 
27ed			 
27ed e5				   	push hl  ; save so we can move to next dict block 
27ee			 
27ee					; skip opcode 
27ee 23					inc hl  
27ef					; skip next ptr 
27ef 23					inc hl  
27f0 23					inc hl 
27f1					; skip len 
27f1 23					inc hl 
27f2				if DEBUG_FORTH_WORDS 
27f2					DMARK "UWt" 
27f2 f5				push af  
27f3 3a 07 28			ld a, (.dmark)  
27f6 32 6b ee			ld (debug_mark),a  
27f9 3a 08 28			ld a, (.dmark+1)  
27fc 32 6c ee			ld (debug_mark+1),a  
27ff 3a 09 28			ld a, (.dmark+2)  
2802 32 6d ee			ld (debug_mark+2),a  
2805 18 03			jr .pastdmark  
2807 ..			.dmark: db "UWt"  
280a f1			.pastdmark: pop af  
280b			endm  
# End of macro DMARK
280b					CALLMONITOR 
280b cd 6f ee			call debug_vector  
280e				endm  
# End of macro CALLMONITOR
280e				endif 
280e 03					inc bc 
280f			 
280f c5					push bc 
2810 cd b5 1c				call forth_push_str 
2813 c1					pop bc 
2814			 
2814 e1					pop hl 	 
2815			 
2815 cd 45 21		.nuword:	call forth_tok_next 
2818 18 92				jr .douscan  
281a			 
281a			.udone:		 ; push count of uwords found 
281a c5					push bc 
281b e1					pop hl 
281c			 
281c				if DEBUG_FORTH_WORDS 
281c					DMARK "UWc" 
281c f5				push af  
281d 3a 31 28			ld a, (.dmark)  
2820 32 6b ee			ld (debug_mark),a  
2823 3a 32 28			ld a, (.dmark+1)  
2826 32 6c ee			ld (debug_mark+1),a  
2829 3a 33 28			ld a, (.dmark+2)  
282c 32 6d ee			ld (debug_mark+2),a  
282f 18 03			jr .pastdmark  
2831 ..			.dmark: db "UWc"  
2834 f1			.pastdmark: pop af  
2835			endm  
# End of macro DMARK
2835					CALLMONITOR 
2835 cd 6f ee			call debug_vector  
2838				endm  
# End of macro CALLMONITOR
2838				endif 
2838 cd 47 1c				call forth_push_numhl 
283b			 
283b			 
283b				       NEXTW 
283b c3 f4 1f			jp macro_next 
283e				endm 
# End of macro NEXTW
283e			 
283e			.BP: 
283e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
283e 54				db WORD_SYS_CORE+64             
283f 78 28			dw .MONITOR            
2841 03				db 2 + 1 
2842 .. 00			db "BP",0              
2845				endm 
# End of macro CWHEAD
2845			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2845			; | | $00 Will enable the break points within specific code paths 
2845			; | | $01 Will disable break points 
2845			; | |  
2845			; | | By default break points are off. Either the above can be used to enable them 
2845			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2845			; | | and on release of the pressed key a message will be disaplayed to notify 
2845			; | | that break points are enabled. Pressing any key will then continue boot process. 
2845					; get byte count 
2845					if DEBUG_FORTH_WORDS_KEY 
2845						DMARK "BP." 
2845 f5				push af  
2846 3a 5a 28			ld a, (.dmark)  
2849 32 6b ee			ld (debug_mark),a  
284c 3a 5b 28			ld a, (.dmark+1)  
284f 32 6c ee			ld (debug_mark+1),a  
2852 3a 5c 28			ld a, (.dmark+2)  
2855 32 6d ee			ld (debug_mark+2),a  
2858 18 03			jr .pastdmark  
285a ..			.dmark: db "BP."  
285d f1			.pastdmark: pop af  
285e			endm  
# End of macro DMARK
285e						CALLMONITOR 
285e cd 6f ee			call debug_vector  
2861				endm  
# End of macro CALLMONITOR
2861					endif 
2861			 
2861					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2861 cd 3e 1e			call macro_dsp_valuehl 
2864				endm 
# End of macro FORTH_DSP_VALUEHL
2864			 
2864			;		push hl 
2864			 
2864					; destroy value TOS 
2864			 
2864					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2864 cd f6 1e			call macro_forth_dsp_pop 
2867				endm 
# End of macro FORTH_DSP_POP
2867			 
2867			;		pop hl 
2867			 
2867 3e 00				ld a,0 
2869 bd					cp l 
286a 28 06				jr z, .bpset 
286c			;		ld a, '*' 
286c cd e9 15				call bp_off 
286f					NEXTW 
286f c3 f4 1f			jp macro_next 
2872				endm 
# End of macro NEXTW
2872			 
2872			.bpset:	 
2872					;	ld (os_view_disable), a 
2872 cd dd 15				call bp_on 
2875			 
2875			 
2875					NEXTW 
2875 c3 f4 1f			jp macro_next 
2878				endm 
# End of macro NEXTW
2878			 
2878			 
2878			.MONITOR: 
2878				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2878 55				db WORD_SYS_CORE+65             
2879 a9 28			dw .MALLOC            
287b 08				db 7 + 1 
287c .. 00			db "MONITOR",0              
2884				endm 
# End of macro CWHEAD
2884			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2884			; | | At start the current various registers will be displayed with contents. 
2884			; | | Top right corner will show the most recent debug marker seen. 
2884			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2884			; | | and the return stack pointer (RSP). 
2884			; | | Pressing: 
2884			; | |    1 - Initial screen 
2884			; | |    2 - Display a data dump of HL 
2884			; | |    3 - Display a data dump of DE 
2884			; | |    4 - Display a data dump of BC 
2884			; | |    5 - Display a data dump of HL 
2884			; | |    6 - Display a data dump of DSP 
2884			; | |    7 - Display a data dump of RSP 
2884			; | |    8 - Display a data dump of what is at DSP 
2884			; | |    9 - Display a data dump of what is at RSP 
2884			; | |    0 - Exit monitor and continue running. This will also enable break points 
2884			; | |    * - Disable break points 
2884			; | |    # - Enter traditional monitor mode 
2884			; | | 
2884			; | | Monitor Mode 
2884			; | | ------------ 
2884			; | | A prompt of '>' will be shown for various commands: 
2884			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2884			; | |    C - Continue display a data dump from the last set address 
2884			; | |    M xxxx - Set start of memory edit at address xx 
2884			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2884			; | |    Q - Return to previous 
2884					if DEBUG_FORTH_WORDS_KEY 
2884						DMARK "MON" 
2884 f5				push af  
2885 3a 99 28			ld a, (.dmark)  
2888 32 6b ee			ld (debug_mark),a  
288b 3a 9a 28			ld a, (.dmark+1)  
288e 32 6c ee			ld (debug_mark+1),a  
2891 3a 9b 28			ld a, (.dmark+2)  
2894 32 6d ee			ld (debug_mark+2),a  
2897 18 03			jr .pastdmark  
2899 ..			.dmark: db "MON"  
289c f1			.pastdmark: pop af  
289d			endm  
# End of macro DMARK
289d						CALLMONITOR 
289d cd 6f ee			call debug_vector  
28a0				endm  
# End of macro CALLMONITOR
28a0					endif 
28a0			;		ld a, 0 
28a0			;		ld (os_view_disable), a 
28a0 cd dd 15				call bp_on 
28a3			 
28a3					CALLMONITOR 
28a3 cd 6f ee			call debug_vector  
28a6				endm  
# End of macro CALLMONITOR
28a6			 
28a6			;	call monitor 
28a6			 
28a6					NEXTW 
28a6 c3 f4 1f			jp macro_next 
28a9				endm 
# End of macro NEXTW
28a9			 
28a9			 
28a9			.MALLOC: 
28a9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28a9 56				db WORD_SYS_CORE+66             
28aa d2 28			dw .MALLOC2            
28ac 06				db 5 + 1 
28ad .. 00			db "ALLOT",0              
28b3				endm 
# End of macro CWHEAD
28b3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28b3					if DEBUG_FORTH_WORDS_KEY 
28b3						DMARK "ALL" 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 6b ee			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 6c ee			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 6d ee			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db "ALL"  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc						CALLMONITOR 
28cc cd 6f ee			call debug_vector  
28cf				endm  
# End of macro CALLMONITOR
28cf					endif 
28cf c3 f9 28				jp .mallocc 
28d2			.MALLOC2: 
28d2				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28d2 56				db WORD_SYS_CORE+66             
28d3 10 29			dw .FREE            
28d5 07				db 6 + 1 
28d6 .. 00			db "MALLOC",0              
28dd				endm 
# End of macro CWHEAD
28dd			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28dd					; get byte count 
28dd					if DEBUG_FORTH_WORDS_KEY 
28dd						DMARK "MAL" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6b ee			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6c ee			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 6d ee			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "MAL"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6						CALLMONITOR 
28f6 cd 6f ee			call debug_vector  
28f9				endm  
# End of macro CALLMONITOR
28f9					endif 
28f9			.mallocc: 
28f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f9 cd 3e 1e			call macro_dsp_valuehl 
28fc				endm 
# End of macro FORTH_DSP_VALUEHL
28fc			 
28fc			;		push hl 
28fc			 
28fc					; destroy value TOS 
28fc			 
28fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28fc cd f6 1e			call macro_forth_dsp_pop 
28ff				endm 
# End of macro FORTH_DSP_POP
28ff			 
28ff			;		pop hl 
28ff cd ae 12				call malloc 
2902				if DEBUG_FORTH_MALLOC_GUARD 
2902 f5					push af 
2903 cd 10 0e				call ishlzero 
2906			;		ld a, l 
2906			;		add h 
2906			;		cp 0 
2906 f1					pop af 
2907					 
2907 cc 33 4d				call z,malloc_error 
290a				endif 
290a			 
290a cd 47 1c				call forth_push_numhl 
290d					NEXTW 
290d c3 f4 1f			jp macro_next 
2910				endm 
# End of macro NEXTW
2910			 
2910			.FREE: 
2910				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2910 57				db WORD_SYS_CORE+67             
2911 41 29			dw .LIST            
2913 05				db 4 + 1 
2914 .. 00			db "FREE",0              
2919				endm 
# End of macro CWHEAD
2919			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2919					if DEBUG_FORTH_WORDS_KEY 
2919						DMARK "FRE" 
2919 f5				push af  
291a 3a 2e 29			ld a, (.dmark)  
291d 32 6b ee			ld (debug_mark),a  
2920 3a 2f 29			ld a, (.dmark+1)  
2923 32 6c ee			ld (debug_mark+1),a  
2926 3a 30 29			ld a, (.dmark+2)  
2929 32 6d ee			ld (debug_mark+2),a  
292c 18 03			jr .pastdmark  
292e ..			.dmark: db "FRE"  
2931 f1			.pastdmark: pop af  
2932			endm  
# End of macro DMARK
2932						CALLMONITOR 
2932 cd 6f ee			call debug_vector  
2935				endm  
# End of macro CALLMONITOR
2935					endif 
2935					; get address 
2935			 
2935					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2935 cd 3e 1e			call macro_dsp_valuehl 
2938				endm 
# End of macro FORTH_DSP_VALUEHL
2938			 
2938			;		push hl 
2938			 
2938					; destroy value TOS 
2938			 
2938					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2938 cd f6 1e			call macro_forth_dsp_pop 
293b				endm 
# End of macro FORTH_DSP_POP
293b			 
293b			;		pop hl 
293b			if FORTH_ENABLE_MALLOCFREE 
293b cd 78 13				call free 
293e			endif 
293e					NEXTW 
293e c3 f4 1f			jp macro_next 
2941				endm 
# End of macro NEXTW
2941			.LIST: 
2941				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2941 5c				db WORD_SYS_CORE+72             
2942 2f 2b			dw .FORGET            
2944 05				db 4 + 1 
2945 .. 00			db "LIST",0              
294a				endm 
# End of macro CWHEAD
294a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
294a			; | | The quoted word must be in upper case. 
294a				if DEBUG_FORTH_WORDS_KEY 
294a					DMARK "LST" 
294a f5				push af  
294b 3a 5f 29			ld a, (.dmark)  
294e 32 6b ee			ld (debug_mark),a  
2951 3a 60 29			ld a, (.dmark+1)  
2954 32 6c ee			ld (debug_mark+1),a  
2957 3a 61 29			ld a, (.dmark+2)  
295a 32 6d ee			ld (debug_mark+2),a  
295d 18 03			jr .pastdmark  
295f ..			.dmark: db "LST"  
2962 f1			.pastdmark: pop af  
2963			endm  
# End of macro DMARK
2963					CALLMONITOR 
2963 cd 6f ee			call debug_vector  
2966				endm  
# End of macro CALLMONITOR
2966				endif 
2966			 
2966					FORTH_DSP_VALUEHL 
2966 cd 3e 1e			call macro_dsp_valuehl 
2969				endm 
# End of macro FORTH_DSP_VALUEHL
2969			 
2969 e5					push hl 
296a					FORTH_DSP_POP 
296a cd f6 1e			call macro_forth_dsp_pop 
296d				endm 
# End of macro FORTH_DSP_POP
296d c1					pop bc 
296e			 
296e			; Start format of scratch string 
296e			 
296e 21 c1 e2				ld hl, scratch 
2971			 
2971 3e 3a				ld a, ':' 
2973 77					ld (hl),a 
2974 23					inc hl 
2975 3e 20				ld a, ' ' 
2977 77					ld (hl), a 
2978			 
2978					; Get ptr to the word we need to look up 
2978			 
2978			;		FORTH_DSP_VALUEHL 
2978					;v5 FORTH_DSP_VALUE 
2978				; TODO type check 
2978			;		inc hl    ; Skip type check  
2978			;		push hl 
2978			;		ex de, hl    ; put into DE 
2978			 
2978			 
2978 21 91 65				ld hl, baseram 
297b					;ld hl, baseusermem 
297b			 
297b e5			push hl   ; sacreifical push 
297c			 
297c			.ldouscanm: 
297c e1				pop hl 
297d			.ldouscan: 
297d				if DEBUG_FORTH_WORDS 
297d					DMARK "LSs" 
297d f5				push af  
297e 3a 92 29			ld a, (.dmark)  
2981 32 6b ee			ld (debug_mark),a  
2984 3a 93 29			ld a, (.dmark+1)  
2987 32 6c ee			ld (debug_mark+1),a  
298a 3a 94 29			ld a, (.dmark+2)  
298d 32 6d ee			ld (debug_mark+2),a  
2990 18 03			jr .pastdmark  
2992 ..			.dmark: db "LSs"  
2995 f1			.pastdmark: pop af  
2996			endm  
# End of macro DMARK
2996					CALLMONITOR 
2996 cd 6f ee			call debug_vector  
2999				endm  
# End of macro CALLMONITOR
2999				endif 
2999				; skip dict stub 
2999 cd 45 21				call forth_tok_next 
299c			 
299c			 
299c			; while we have words to look for 
299c			 
299c 7e				ld a, (hl)      
299d				if DEBUG_FORTH_WORDS 
299d					DMARK "LSk" 
299d f5				push af  
299e 3a b2 29			ld a, (.dmark)  
29a1 32 6b ee			ld (debug_mark),a  
29a4 3a b3 29			ld a, (.dmark+1)  
29a7 32 6c ee			ld (debug_mark+1),a  
29aa 3a b4 29			ld a, (.dmark+2)  
29ad 32 6d ee			ld (debug_mark+2),a  
29b0 18 03			jr .pastdmark  
29b2 ..			.dmark: db "LSk"  
29b5 f1			.pastdmark: pop af  
29b6			endm  
# End of macro DMARK
29b6					CALLMONITOR 
29b6 cd 6f ee			call debug_vector  
29b9				endm  
# End of macro CALLMONITOR
29b9				endif 
29b9					;cp WORD_SYS_END 
29b9					;jp z, .lunotfound 
29b9			 
29b9					; if we hit non uwords then gone too far 
29b9 fe 01				cp WORD_SYS_UWORD 
29bb c2 eb 2a				jp nz, .lunotfound 
29be			 
29be				if DEBUG_FORTH_WORDS 
29be					DMARK "LSu" 
29be f5				push af  
29bf 3a d3 29			ld a, (.dmark)  
29c2 32 6b ee			ld (debug_mark),a  
29c5 3a d4 29			ld a, (.dmark+1)  
29c8 32 6c ee			ld (debug_mark+1),a  
29cb 3a d5 29			ld a, (.dmark+2)  
29ce 32 6d ee			ld (debug_mark+2),a  
29d1 18 03			jr .pastdmark  
29d3 ..			.dmark: db "LSu"  
29d6 f1			.pastdmark: pop af  
29d7			endm  
# End of macro DMARK
29d7					CALLMONITOR 
29d7 cd 6f ee			call debug_vector  
29da				endm  
# End of macro CALLMONITOR
29da				endif 
29da			 
29da					; found a uword but is it the one we want... 
29da			 
29da c5					push bc     ; uword to find is on bc 
29db d1					pop de 
29dc			 
29dc e5					push hl  ; to save the ptr 
29dd			 
29dd					; skip opcode 
29dd 23					inc hl  
29de					; skip next ptr 
29de 23					inc hl  
29df 23					inc hl 
29e0					; skip len 
29e0 23					inc hl 
29e1			 
29e1				if DEBUG_FORTH_WORDS 
29e1					DMARK "LSc" 
29e1 f5				push af  
29e2 3a f6 29			ld a, (.dmark)  
29e5 32 6b ee			ld (debug_mark),a  
29e8 3a f7 29			ld a, (.dmark+1)  
29eb 32 6c ee			ld (debug_mark+1),a  
29ee 3a f8 29			ld a, (.dmark+2)  
29f1 32 6d ee			ld (debug_mark+2),a  
29f4 18 03			jr .pastdmark  
29f6 ..			.dmark: db "LSc"  
29f9 f1			.pastdmark: pop af  
29fa			endm  
# End of macro DMARK
29fa					CALLMONITOR 
29fa cd 6f ee			call debug_vector  
29fd				endm  
# End of macro CALLMONITOR
29fd				endif 
29fd cd 7d 12				call strcmp 
2a00 c2 7c 29				jp nz, .ldouscanm 
2a03				 
2a03			 
2a03			 
2a03					; we have a uword so push its name to the stack 
2a03			 
2a03			;	   	push hl  ; save so we can move to next dict block 
2a03 e1			pop hl 
2a04			 
2a04				if DEBUG_FORTH_WORDS 
2a04					DMARK "LSm" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 6b ee			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 6c ee			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 6d ee			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "LSm"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d					CALLMONITOR 
2a1d cd 6f ee			call debug_vector  
2a20				endm  
# End of macro CALLMONITOR
2a20				endif 
2a20			 
2a20					; skip opcode 
2a20 23					inc hl  
2a21					; skip next ptr 
2a21 23					inc hl  
2a22 23					inc hl 
2a23					; skip len 
2a23 7e					ld a, (hl)   ; save length to add 
2a24				if DEBUG_FORTH_WORDS 
2a24					DMARK "LS2" 
2a24 f5				push af  
2a25 3a 39 2a			ld a, (.dmark)  
2a28 32 6b ee			ld (debug_mark),a  
2a2b 3a 3a 2a			ld a, (.dmark+1)  
2a2e 32 6c ee			ld (debug_mark+1),a  
2a31 3a 3b 2a			ld a, (.dmark+2)  
2a34 32 6d ee			ld (debug_mark+2),a  
2a37 18 03			jr .pastdmark  
2a39 ..			.dmark: db "LS2"  
2a3c f1			.pastdmark: pop af  
2a3d			endm  
# End of macro DMARK
2a3d					CALLMONITOR 
2a3d cd 6f ee			call debug_vector  
2a40				endm  
# End of macro CALLMONITOR
2a40				endif 
2a40			 
2a40					; save this location 
2a40				 
2a40 e5					push hl 
2a41			 
2a41 23					inc hl 
2a42 11 c3 e2				ld de, scratch+2 
2a45 4f					ld c, a 
2a46 06 00				ld b, 0 
2a48			 
2a48				if DEBUG_FORTH_WORDS 
2a48					DMARK "LSn" 
2a48 f5				push af  
2a49 3a 5d 2a			ld a, (.dmark)  
2a4c 32 6b ee			ld (debug_mark),a  
2a4f 3a 5e 2a			ld a, (.dmark+1)  
2a52 32 6c ee			ld (debug_mark+1),a  
2a55 3a 5f 2a			ld a, (.dmark+2)  
2a58 32 6d ee			ld (debug_mark+2),a  
2a5b 18 03			jr .pastdmark  
2a5d ..			.dmark: db "LSn"  
2a60 f1			.pastdmark: pop af  
2a61			endm  
# End of macro DMARK
2a61					CALLMONITOR 
2a61 cd 6f ee			call debug_vector  
2a64				endm  
# End of macro CALLMONITOR
2a64				endif 
2a64			 
2a64					; copy uword name to scratch 
2a64			 
2a64 ed b0				ldir 
2a66			 
2a66 1b					dec de 
2a67 3e 20				ld a, ' '    ; change null to space 
2a69 12					ld (de), a 
2a6a			 
2a6a 13					inc de 
2a6b			 
2a6b d5					push de 
2a6c c1					pop bc     ; move scratch pointer to end of word name and save it 
2a6d			 
2a6d e1					pop hl 
2a6e 7e					ld a, (hl) 
2a6f					;inc hl 
2a6f					; skip word string 
2a6f cd e7 0d				call addatohl 
2a72			 
2a72 23					inc hl 
2a73			 
2a73				if DEBUG_FORTH_WORDS 
2a73					DMARK "LS3" 
2a73 f5				push af  
2a74 3a 88 2a			ld a, (.dmark)  
2a77 32 6b ee			ld (debug_mark),a  
2a7a 3a 89 2a			ld a, (.dmark+1)  
2a7d 32 6c ee			ld (debug_mark+1),a  
2a80 3a 8a 2a			ld a, (.dmark+2)  
2a83 32 6d ee			ld (debug_mark+2),a  
2a86 18 03			jr .pastdmark  
2a88 ..			.dmark: db "LS3"  
2a8b f1			.pastdmark: pop af  
2a8c			endm  
# End of macro DMARK
2a8c					CALLMONITOR 
2a8c cd 6f ee			call debug_vector  
2a8f				endm  
# End of macro CALLMONITOR
2a8f				endif 
2a8f					; should now be at the start of the machine code to setup the eval of the uword 
2a8f					; now locate the ptr to the string defintion 
2a8f			 
2a8f					; skip ld hl, 
2a8f					; then load the ptr 
2a8f			; TODO use get from hl ptr 
2a8f 23					inc hl 
2a90 5e					ld e, (hl) 
2a91 23					inc hl 
2a92 56					ld d, (hl) 
2a93 eb					ex de, hl 
2a94			 
2a94			 
2a94				if DEBUG_FORTH_WORDS 
2a94					DMARK "LSt" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 6b ee			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 6c ee			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 6d ee			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "LSt"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad					CALLMONITOR 
2aad cd 6f ee			call debug_vector  
2ab0				endm  
# End of macro CALLMONITOR
2ab0				endif 
2ab0			 
2ab0			; cant push right now due to tokenised strings  
2ab0			 
2ab0			; get the destination of where to copy this definition to. 
2ab0			 
2ab0 c5					push bc 
2ab1 d1					pop de 
2ab2			 
2ab2 7e			.listl:         ld a,(hl) 
2ab3 fe 00				cp 0 
2ab5 28 09				jr z, .lreplsp     ; replace zero with space 
2ab7					;cp FORTH_END_BUFFER 
2ab7 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ab9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2abb				 
2abb					; just copy this char as is then 
2abb			 
2abb 12					ld (de), a 
2abc			 
2abc 23			.listnxt:	inc hl 
2abd 13					inc de 
2abe 18 f2				jr .listl 
2ac0			 
2ac0 3e 20		.lreplsp:	ld a,' ' 
2ac2 12					ld (de), a 
2ac3 18 f7				jr .listnxt 
2ac5			 
2ac5			; close up uword def 
2ac5			 
2ac5			.listdone: 
2ac5 12					ld (de), a 
2ac6 13					inc de 
2ac7 3e 00				ld a, 0 
2ac9 12					ld (de), a 
2aca			 
2aca			; now have def so clean up and push to stack 
2aca			 
2aca 21 c1 e2				ld hl, scratch 
2acd				if DEBUG_FORTH_WORDS 
2acd					DMARK "Ltp" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 6b ee			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 6c ee			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 6d ee			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "Ltp"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6					CALLMONITOR 
2ae6 cd 6f ee			call debug_vector  
2ae9				endm  
# End of macro CALLMONITOR
2ae9				endif 
2ae9			 
2ae9 18 1f			jr .listpush 
2aeb			 
2aeb			;.lnuword:	pop hl 
2aeb			;		call forth_tok_next 
2aeb			;		jp .ldouscan  
2aeb			 
2aeb			.lunotfound:		  
2aeb			 
2aeb				if DEBUG_FORTH_WORDS 
2aeb					DMARK "LSn" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 6b ee			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 6c ee			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 6d ee			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "LSn"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04					CALLMONITOR 
2b04 cd 6f ee			call debug_vector  
2b07				endm  
# End of macro CALLMONITOR
2b07				endif 
2b07			 
2b07					 
2b07			;		FORTH_DSP_POP 
2b07			;		ld hl, .luno 
2b07			 
2b07					NEXTW			 
2b07 c3 f4 1f			jp macro_next 
2b0a				endm 
# End of macro NEXTW
2b0a			 
2b0a			.listpush: 
2b0a				if DEBUG_FORTH_WORDS 
2b0a					DMARK "LS>" 
2b0a f5				push af  
2b0b 3a 1f 2b			ld a, (.dmark)  
2b0e 32 6b ee			ld (debug_mark),a  
2b11 3a 20 2b			ld a, (.dmark+1)  
2b14 32 6c ee			ld (debug_mark+1),a  
2b17 3a 21 2b			ld a, (.dmark+2)  
2b1a 32 6d ee			ld (debug_mark+2),a  
2b1d 18 03			jr .pastdmark  
2b1f ..			.dmark: db "LS>"  
2b22 f1			.pastdmark: pop af  
2b23			endm  
# End of macro DMARK
2b23					CALLMONITOR 
2b23 cd 6f ee			call debug_vector  
2b26				endm  
# End of macro CALLMONITOR
2b26				endif 
2b26 cd b5 1c				call forth_push_str 
2b29			 
2b29			 
2b29			 
2b29					NEXTW 
2b29 c3 f4 1f			jp macro_next 
2b2c				endm 
# End of macro NEXTW
2b2c			 
2b2c			;.luno:    db "Word not found",0 
2b2c			 
2b2c			 
2b2c			 
2b2c			 
2b2c			 
2b2c			;		push hl   ; save pointer to start of uword def string 
2b2c			; 
2b2c			;; look for FORTH_EOL_LINE 
2b2c			;		ld a, FORTH_END_BUFFER 
2b2c			;		call strlent 
2b2c			; 
2b2c			;		inc hl		 ; space for coln def 
2b2c			;		inc hl 
2b2c			;		inc hl          ; space for terms 
2b2c			;		inc hl 
2b2c			; 
2b2c			;		ld a, 20   ; TODO get actual length 
2b2c			;		call addatohl    ; include a random amount of room for the uword name 
2b2c			; 
2b2c			;		 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "Lt1" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			;		 
2b2c			; 
2b2c			;; malloc space for the string because we cant change it 
2b2c			; 
2b2c			;		call malloc 
2b2c			;	if DEBUG_FORTH_MALLOC_GUARD 
2b2c			;		push af 
2b2c			;		call ishlzero 
2b2c			;		pop af 
2b2c			;		 
2b2c			;		call z,malloc_error 
2b2c			;	endif 
2b2c			; 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "Lt2" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			;		pop de 
2b2c			;		push hl    ; push the malloc to release later 
2b2c			;		push hl   ;  push back a copy for the later stack push 
2b2c			;		 
2b2c			;; copy the string swapping out the zero terms for spaces 
2b2c			; 
2b2c			;		; de has our source 
2b2c			;		; hl has our dest 
2b2c			; 
2b2c			;; add the coln def 
2b2c			; 
2b2c			;		ld a, ':' 
2b2c			;		ld (hl), a 
2b2c			;		inc hl 
2b2c			;		ld a, ' ' 
2b2c			;		ld (hl), a 
2b2c			;		inc hl 
2b2c			; 
2b2c			;; add the uname word 
2b2c			;		push de   ; save our string for now 
2b2c			;		ex de, hl 
2b2c			; 
2b2c			;		FORTH_DSP_VALUE 
2b2c			;		;v5 FORTH_DSP_VALUE 
2b2c			; 
2b2c			;		inc hl   ; skip type but we know by now this is OK 
2b2c			; 
2b2c			;.luword:	ld a,(hl) 
2b2c			;		cp 0 
2b2c			;		jr z, .luword2 
2b2c			;		ld (de), a 
2b2c			;		inc de 
2b2c			;		inc hl 
2b2c			;		jr .luword 
2b2c			; 
2b2c			;.luword2:	ld a, ' ' 
2b2c			;		ld (de), a 
2b2c			;;		inc hl 
2b2c			;;		inc de 
2b2c			;;		ld (de), a 
2b2c			;;		inc hl 
2b2c			;		inc de 
2b2c			; 
2b2c			;		ex de, hl 
2b2c			;		pop de 
2b2c			;		 
2b2c			;		 
2b2c			; 
2b2c			;; detoken that string and copy it 
2b2c			; 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "Lt2" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			;.ldetok:	ld a, (de) 
2b2c			;		cp FORTH_END_BUFFER 
2b2c			;		jr z, .ldetokend 
2b2c			;		; swap out any zero term for space 
2b2c			;		cp 0 
2b2c			;		jr nz, .ldetoknext 
2b2c			;		ld a, ' ' 
2b2c			; 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "LtS" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			;.ldetoknext:	ld (hl), a 
2b2c			;		inc de 
2b2c			;		inc hl 
2b2c			;		jr .ldetok 
2b2c			; 
2b2c			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b2c			;		ld (hl), a  
2b2c			; 
2b2c			;; free that temp malloc 
2b2c			; 
2b2c			;		pop hl    
2b2c			; 
2b2c			;	if DEBUG_FORTH_WORDS 
2b2c			;		DMARK "Lt4" 
2b2c			;		CALLMONITOR 
2b2c			;	endif 
2b2c			;		call forth_apushstrhl 
2b2c			; 
2b2c			;		; get rid of temp malloc area 
2b2c			; 
2b2c			;		pop hl 
2b2c			;		call free 
2b2c			; 
2b2c			;		jr .ludone 
2b2c			; 
2b2c			;.lnuword:	pop hl 
2b2c			;		call forth_tok_next 
2b2c			;		jp .ldouscan  
2b2c			; 
2b2c			;.ludone:		 pop hl 
2b2c			; 
2b2c					NEXTW 
2b2c c3 f4 1f			jp macro_next 
2b2f				endm 
# End of macro NEXTW
2b2f			 
2b2f			.FORGET: 
2b2f				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b2f 5d				db WORD_SYS_CORE+73             
2b30 a8 2b			dw .NOP            
2b32 07				db 6 + 1 
2b33 .. 00			db "FORGET",0              
2b3a				endm 
# End of macro CWHEAD
2b3a			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b3a			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b3a			; | |  
2b3a			; | | e.g. "MORE" forget 
2b3a					if DEBUG_FORTH_WORDS_KEY 
2b3a						DMARK "FRG" 
2b3a f5				push af  
2b3b 3a 4f 2b			ld a, (.dmark)  
2b3e 32 6b ee			ld (debug_mark),a  
2b41 3a 50 2b			ld a, (.dmark+1)  
2b44 32 6c ee			ld (debug_mark+1),a  
2b47 3a 51 2b			ld a, (.dmark+2)  
2b4a 32 6d ee			ld (debug_mark+2),a  
2b4d 18 03			jr .pastdmark  
2b4f ..			.dmark: db "FRG"  
2b52 f1			.pastdmark: pop af  
2b53			endm  
# End of macro DMARK
2b53						CALLMONITOR 
2b53 cd 6f ee			call debug_vector  
2b56				endm  
# End of macro CALLMONITOR
2b56					endif 
2b56			 
2b56				; find uword 
2b56			        ; update start of word with "_" 
2b56				; replace uword with deleted flag 
2b56			 
2b56			 
2b56			;	if DEBUG_FORTH_WORDS 
2b56			;		DMARK "FOG" 
2b56			;		CALLMONITOR 
2b56			;	endif 
2b56			 
2b56			 
2b56					; Get ptr to the word we need to look up 
2b56			 
2b56					FORTH_DSP_VALUEHL 
2b56 cd 3e 1e			call macro_dsp_valuehl 
2b59				endm 
# End of macro FORTH_DSP_VALUEHL
2b59					;v5 FORTH_DSP_VALUE 
2b59				; TODO type check 
2b59			;		inc hl    ; Skip type check  
2b59 e5					push hl 
2b5a c1					pop bc 
2b5b			;		ex de, hl    ; put into DE 
2b5b			 
2b5b			 
2b5b 21 91 65				ld hl, baseram 
2b5e					;ld hl, baseusermem 
2b5e			 
2b5e				; skip dict stub 
2b5e			;	call forth_tok_next 
2b5e e5			push hl   ; sacreifical push 
2b5f			 
2b5f			.fldouscanm: 
2b5f e1				pop hl 
2b60			.fldouscan: 
2b60			;	if DEBUG_FORTH_WORDS 
2b60			;		DMARK "LSs" 
2b60			;		CALLMONITOR 
2b60			;	endif 
2b60				; skip dict stub 
2b60 cd 45 21				call forth_tok_next 
2b63			 
2b63			 
2b63			; while we have words to look for 
2b63			 
2b63 7e				ld a, (hl)      
2b64			;	if DEBUG_FORTH_WORDS 
2b64			;		DMARK "LSk" 
2b64			;		CALLMONITOR 
2b64			;	endif 
2b64 fe 00				cp WORD_SYS_END 
2b66 ca a2 2b				jp z, .flunotfound 
2b69 fe 01				cp WORD_SYS_UWORD 
2b6b c2 60 2b				jp nz, .fldouscan 
2b6e			 
2b6e			;	if DEBUG_FORTH_WORDS 
2b6e			;		DMARK "LSu" 
2b6e			;		CALLMONITOR 
2b6e			;	endif 
2b6e			 
2b6e					; found a uword but is it the one we want... 
2b6e			 
2b6e c5					push bc     ; uword to find is on bc 
2b6f d1					pop de 
2b70			 
2b70 e5					push hl  ; to save the ptr 
2b71			 
2b71					; skip opcode 
2b71 23					inc hl  
2b72					; skip next ptr 
2b72 23					inc hl  
2b73 23					inc hl 
2b74					; skip len 
2b74 23					inc hl 
2b75			 
2b75			;	if DEBUG_FORTH_WORDS 
2b75			;		DMARK "LSc" 
2b75			;		CALLMONITOR 
2b75			;	endif 
2b75 cd 7d 12				call strcmp 
2b78 c2 5f 2b				jp nz, .fldouscanm 
2b7b			; 
2b7b			; 
2b7b			;; while we have words to look for 
2b7b			; 
2b7b			;.fdouscan:	ld a, (hl)      
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "LSs" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			;		cp WORD_SYS_END 
2b7b			;		jp z, .fudone 
2b7b			;		cp WORD_SYS_UWORD 
2b7b			;		jp nz, .fnuword 
2b7b			; 
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "FGu" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			; 
2b7b			;		; found a uword but is it the one we want... 
2b7b			; 
2b7b			; 
2b7b			;	        pop de   ; get back the dsp name 
2b7b			;		push de 
2b7b			; 
2b7b			;		push hl  ; to save the ptr 
2b7b			; 
2b7b			;		; skip opcode 
2b7b			;		inc hl  
2b7b			;		; skip next ptr 
2b7b			;		inc hl  
2b7b			;		inc hl 
2b7b			;		; skip len 
2b7b			;		inc hl 
2b7b			; 
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "FGc" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			;		call strcmp 
2b7b			;		jp nz, .fnuword 
2b7b			 
2b7b			 
2b7b e1			pop hl 
2b7c			 
2b7c				 
2b7c				if DEBUG_FORTH_WORDS 
2b7c					DMARK "FGm" 
2b7c f5				push af  
2b7d 3a 91 2b			ld a, (.dmark)  
2b80 32 6b ee			ld (debug_mark),a  
2b83 3a 92 2b			ld a, (.dmark+1)  
2b86 32 6c ee			ld (debug_mark+1),a  
2b89 3a 93 2b			ld a, (.dmark+2)  
2b8c 32 6d ee			ld (debug_mark+2),a  
2b8f 18 03			jr .pastdmark  
2b91 ..			.dmark: db "FGm"  
2b94 f1			.pastdmark: pop af  
2b95			endm  
# End of macro DMARK
2b95					CALLMONITOR 
2b95 cd 6f ee			call debug_vector  
2b98				endm  
# End of macro CALLMONITOR
2b98				endif 
2b98			 
2b98			 
2b98			 
2b98					; we have a uword so push its name to the stack 
2b98			 
2b98			;	   	push hl  ; save so we can move to next dict block 
2b98			;pop hl 
2b98			 
2b98					; update opcode to deleted 
2b98 3e 03				ld a, WORD_SYS_DELETED 
2b9a 77					ld (hl), a 
2b9b			 
2b9b 23					inc hl  
2b9c					; skip next ptr 
2b9c 23					inc hl  
2b9d 23					inc hl 
2b9e					; skip len 
2b9e 23					inc hl 
2b9f			 
2b9f					; TODO change parser to skip deleted words but for now mark it out 
2b9f 3e 5f				ld a, "_" 
2ba1 77					ld  (hl),a 
2ba2			 
2ba2			;		jr .fudone 
2ba2			; 
2ba2			;.fnuword:	pop hl 
2ba2			;		call forth_tok_next 
2ba2			;		jp .fdouscan  
2ba2			 
2ba2			.flunotfound:		  
2ba2			 
2ba2			 
2ba2					 
2ba2					FORTH_DSP_POP 
2ba2 cd f6 1e			call macro_forth_dsp_pop 
2ba5				endm 
# End of macro FORTH_DSP_POP
2ba5			;		ld hl, .luno 
2ba5			;.fudone:		 pop hl 
2ba5					NEXTW 
2ba5 c3 f4 1f			jp macro_next 
2ba8				endm 
# End of macro NEXTW
2ba8			.NOP: 
2ba8				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ba8 61				db WORD_SYS_CORE+77             
2ba9 cf 2b			dw .COMO            
2bab 04				db 3 + 1 
2bac .. 00			db "NOP",0              
2bb0				endm 
# End of macro CWHEAD
2bb0			; | NOP (  --  ) Do nothing | DONE 
2bb0					if DEBUG_FORTH_WORDS_KEY 
2bb0						DMARK "NOP" 
2bb0 f5				push af  
2bb1 3a c5 2b			ld a, (.dmark)  
2bb4 32 6b ee			ld (debug_mark),a  
2bb7 3a c6 2b			ld a, (.dmark+1)  
2bba 32 6c ee			ld (debug_mark+1),a  
2bbd 3a c7 2b			ld a, (.dmark+2)  
2bc0 32 6d ee			ld (debug_mark+2),a  
2bc3 18 03			jr .pastdmark  
2bc5 ..			.dmark: db "NOP"  
2bc8 f1			.pastdmark: pop af  
2bc9			endm  
# End of macro DMARK
2bc9						CALLMONITOR 
2bc9 cd 6f ee			call debug_vector  
2bcc				endm  
# End of macro CALLMONITOR
2bcc					endif 
2bcc				       NEXTW 
2bcc c3 f4 1f			jp macro_next 
2bcf				endm 
# End of macro NEXTW
2bcf			.COMO: 
2bcf				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bcf 6e				db WORD_SYS_CORE+90             
2bd0 21 2c			dw .COMC            
2bd2 02				db 1 + 1 
2bd3 .. 00			db "(",0              
2bd5				endm 
# End of macro CWHEAD
2bd5			; | ( ( -- )  Start of comment | DONE 
2bd5			 
2bd5			 
2bd5 2a c2 e5				ld hl, ( os_tok_ptr) 
2bd8 11 1c 2c			ld de, .closepar 
2bdb					 
2bdb					if DEBUG_FORTH_WORDS 
2bdb						DMARK ").." 
2bdb f5				push af  
2bdc 3a f0 2b			ld a, (.dmark)  
2bdf 32 6b ee			ld (debug_mark),a  
2be2 3a f1 2b			ld a, (.dmark+1)  
2be5 32 6c ee			ld (debug_mark+1),a  
2be8 3a f2 2b			ld a, (.dmark+2)  
2beb 32 6d ee			ld (debug_mark+2),a  
2bee 18 03			jr .pastdmark  
2bf0 ..			.dmark: db ").."  
2bf3 f1			.pastdmark: pop af  
2bf4			endm  
# End of macro DMARK
2bf4						CALLMONITOR 
2bf4 cd 6f ee			call debug_vector  
2bf7				endm  
# End of macro CALLMONITOR
2bf7					endif 
2bf7 cd 0f 21			call findnexttok  
2bfa			 
2bfa					if DEBUG_FORTH_WORDS 
2bfa						DMARK "IF5" 
2bfa f5				push af  
2bfb 3a 0f 2c			ld a, (.dmark)  
2bfe 32 6b ee			ld (debug_mark),a  
2c01 3a 10 2c			ld a, (.dmark+1)  
2c04 32 6c ee			ld (debug_mark+1),a  
2c07 3a 11 2c			ld a, (.dmark+2)  
2c0a 32 6d ee			ld (debug_mark+2),a  
2c0d 18 03			jr .pastdmark  
2c0f ..			.dmark: db "IF5"  
2c12 f1			.pastdmark: pop af  
2c13			endm  
# End of macro DMARK
2c13						CALLMONITOR 
2c13 cd 6f ee			call debug_vector  
2c16				endm  
# End of macro CALLMONITOR
2c16					endif 
2c16				; replace below with ) exec using tok_ptr 
2c16 22 c2 e5			ld (os_tok_ptr), hl 
2c19 c3 85 20			jp exec1 
2c1c			 
2c1c .. 00			.closepar:   db ")",0 
2c1e			 
2c1e				       NEXTW 
2c1e c3 f4 1f			jp macro_next 
2c21				endm 
# End of macro NEXTW
2c21			.COMC: 
2c21				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c21 6f				db WORD_SYS_CORE+91             
2c22 2a 2c			dw .SCRATCH            
2c24 02				db 1 + 1 
2c25 .. 00			db ")",0              
2c27				endm 
# End of macro CWHEAD
2c27			; | ) ( -- )  End of comment |  DONE  
2c27				       NEXTW 
2c27 c3 f4 1f			jp macro_next 
2c2a				endm 
# End of macro NEXTW
2c2a			 
2c2a			.SCRATCH: 
2c2a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c2a 6f				db WORD_SYS_CORE+91             
2c2b 65 2c			dw .INC            
2c2d 08				db 7 + 1 
2c2e .. 00			db "SCRATCH",0              
2c36				endm 
# End of macro CWHEAD
2c36			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c36			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c36			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c36			; | |  
2c36			; | | e.g.    : score $00 scratch ; 
2c36			; | |  
2c36			; | | $00 score ! 
2c36			; | | $01 score +! 
2c36			; | |  
2c36			; | | e.g.   : varword $0a scratch ;  
2c36			; | | 
2c36			; | | $8000 varword ! 
2c36					if DEBUG_FORTH_WORDS_KEY 
2c36						DMARK "SCR" 
2c36 f5				push af  
2c37 3a 4b 2c			ld a, (.dmark)  
2c3a 32 6b ee			ld (debug_mark),a  
2c3d 3a 4c 2c			ld a, (.dmark+1)  
2c40 32 6c ee			ld (debug_mark+1),a  
2c43 3a 4d 2c			ld a, (.dmark+2)  
2c46 32 6d ee			ld (debug_mark+2),a  
2c49 18 03			jr .pastdmark  
2c4b ..			.dmark: db "SCR"  
2c4e f1			.pastdmark: pop af  
2c4f			endm  
# End of macro DMARK
2c4f						CALLMONITOR 
2c4f cd 6f ee			call debug_vector  
2c52				endm  
# End of macro CALLMONITOR
2c52					endif 
2c52			 
2c52					FORTH_DSP_VALUEHL 
2c52 cd 3e 1e			call macro_dsp_valuehl 
2c55				endm 
# End of macro FORTH_DSP_VALUEHL
2c55				 
2c55					FORTH_DSP_POP 
2c55 cd f6 1e			call macro_forth_dsp_pop 
2c58				endm 
# End of macro FORTH_DSP_POP
2c58			 
2c58 7d					ld a, l 
2c59 21 e6 e7				ld hl, os_var_array 
2c5c cd e7 0d				call addatohl 
2c5f			 
2c5f cd 47 1c				call forth_push_numhl 
2c62			 
2c62				       NEXTW 
2c62 c3 f4 1f			jp macro_next 
2c65				endm 
# End of macro NEXTW
2c65			 
2c65			.INC: 
2c65				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c65 6f				db WORD_SYS_CORE+91             
2c66 b9 2c			dw .DEC            
2c68 03				db 2 + 1 
2c69 .. 00			db "+!",0              
2c6c				endm 
# End of macro CWHEAD
2c6c			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c6c					if DEBUG_FORTH_WORDS_KEY 
2c6c						DMARK "+s_" 
2c6c f5				push af  
2c6d 3a 81 2c			ld a, (.dmark)  
2c70 32 6b ee			ld (debug_mark),a  
2c73 3a 82 2c			ld a, (.dmark+1)  
2c76 32 6c ee			ld (debug_mark+1),a  
2c79 3a 83 2c			ld a, (.dmark+2)  
2c7c 32 6d ee			ld (debug_mark+2),a  
2c7f 18 03			jr .pastdmark  
2c81 ..			.dmark: db "+s_"  
2c84 f1			.pastdmark: pop af  
2c85			endm  
# End of macro DMARK
2c85						CALLMONITOR 
2c85 cd 6f ee			call debug_vector  
2c88				endm  
# End of macro CALLMONITOR
2c88					endif 
2c88			 
2c88					FORTH_DSP_VALUEHL 
2c88 cd 3e 1e			call macro_dsp_valuehl 
2c8b				endm 
# End of macro FORTH_DSP_VALUEHL
2c8b			 
2c8b e5					push hl   ; save address 
2c8c			 
2c8c					FORTH_DSP_POP 
2c8c cd f6 1e			call macro_forth_dsp_pop 
2c8f				endm 
# End of macro FORTH_DSP_POP
2c8f			 
2c8f					FORTH_DSP_VALUEHL 
2c8f cd 3e 1e			call macro_dsp_valuehl 
2c92				endm 
# End of macro FORTH_DSP_VALUEHL
2c92			 
2c92					FORTH_DSP_POP 
2c92 cd f6 1e			call macro_forth_dsp_pop 
2c95				endm 
# End of macro FORTH_DSP_POP
2c95			 
2c95					; hl contains value to add to byte at a 
2c95				 
2c95 eb					ex de, hl 
2c96			 
2c96 e1					pop hl 
2c97			 
2c97					if DEBUG_FORTH_WORDS 
2c97						DMARK "INC" 
2c97 f5				push af  
2c98 3a ac 2c			ld a, (.dmark)  
2c9b 32 6b ee			ld (debug_mark),a  
2c9e 3a ad 2c			ld a, (.dmark+1)  
2ca1 32 6c ee			ld (debug_mark+1),a  
2ca4 3a ae 2c			ld a, (.dmark+2)  
2ca7 32 6d ee			ld (debug_mark+2),a  
2caa 18 03			jr .pastdmark  
2cac ..			.dmark: db "INC"  
2caf f1			.pastdmark: pop af  
2cb0			endm  
# End of macro DMARK
2cb0						CALLMONITOR 
2cb0 cd 6f ee			call debug_vector  
2cb3				endm  
# End of macro CALLMONITOR
2cb3					endif 
2cb3			 
2cb3 7e					ld a,(hl) 
2cb4 83					add e 
2cb5 77					ld (hl),a 
2cb6			 
2cb6			 
2cb6			 
2cb6				       NEXTW 
2cb6 c3 f4 1f			jp macro_next 
2cb9				endm 
# End of macro NEXTW
2cb9			 
2cb9			.DEC: 
2cb9				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cb9 6f				db WORD_SYS_CORE+91             
2cba 0a 2d			dw .INC2            
2cbc 03				db 2 + 1 
2cbd .. 00			db "-!",0              
2cc0				endm 
# End of macro CWHEAD
2cc0			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cc0					if DEBUG_FORTH_WORDS_KEY 
2cc0						DMARK "-s_" 
2cc0 f5				push af  
2cc1 3a d5 2c			ld a, (.dmark)  
2cc4 32 6b ee			ld (debug_mark),a  
2cc7 3a d6 2c			ld a, (.dmark+1)  
2cca 32 6c ee			ld (debug_mark+1),a  
2ccd 3a d7 2c			ld a, (.dmark+2)  
2cd0 32 6d ee			ld (debug_mark+2),a  
2cd3 18 03			jr .pastdmark  
2cd5 ..			.dmark: db "-s_"  
2cd8 f1			.pastdmark: pop af  
2cd9			endm  
# End of macro DMARK
2cd9						CALLMONITOR 
2cd9 cd 6f ee			call debug_vector  
2cdc				endm  
# End of macro CALLMONITOR
2cdc					endif 
2cdc			 
2cdc					FORTH_DSP_VALUEHL 
2cdc cd 3e 1e			call macro_dsp_valuehl 
2cdf				endm 
# End of macro FORTH_DSP_VALUEHL
2cdf			 
2cdf e5					push hl   ; save address 
2ce0			 
2ce0					FORTH_DSP_POP 
2ce0 cd f6 1e			call macro_forth_dsp_pop 
2ce3				endm 
# End of macro FORTH_DSP_POP
2ce3			 
2ce3					FORTH_DSP_VALUEHL 
2ce3 cd 3e 1e			call macro_dsp_valuehl 
2ce6				endm 
# End of macro FORTH_DSP_VALUEHL
2ce6			 
2ce6					; hl contains value to add to byte at a 
2ce6				 
2ce6 eb					ex de, hl 
2ce7			 
2ce7 e1					pop hl 
2ce8			 
2ce8					if DEBUG_FORTH_WORDS 
2ce8						DMARK "DEC" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 6b ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 6c ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 6d ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "DEC"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd 6f ee			call debug_vector  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04 7e					ld a,(hl) 
2d05 93					sub e 
2d06 77					ld (hl),a 
2d07			 
2d07			 
2d07			 
2d07				       NEXTW 
2d07 c3 f4 1f			jp macro_next 
2d0a				endm 
# End of macro NEXTW
2d0a			 
2d0a			.INC2: 
2d0a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d0a 6f				db WORD_SYS_CORE+91             
2d0b b4 2d			dw .DEC2            
2d0d 04				db 3 + 1 
2d0e .. 00			db "+2!",0              
2d12				endm 
# End of macro CWHEAD
2d12			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d12			 
2d12					if DEBUG_FORTH_WORDS_KEY 
2d12						DMARK "+2s" 
2d12 f5				push af  
2d13 3a 27 2d			ld a, (.dmark)  
2d16 32 6b ee			ld (debug_mark),a  
2d19 3a 28 2d			ld a, (.dmark+1)  
2d1c 32 6c ee			ld (debug_mark+1),a  
2d1f 3a 29 2d			ld a, (.dmark+2)  
2d22 32 6d ee			ld (debug_mark+2),a  
2d25 18 03			jr .pastdmark  
2d27 ..			.dmark: db "+2s"  
2d2a f1			.pastdmark: pop af  
2d2b			endm  
# End of macro DMARK
2d2b						CALLMONITOR 
2d2b cd 6f ee			call debug_vector  
2d2e				endm  
# End of macro CALLMONITOR
2d2e					endif 
2d2e			 
2d2e					; Address 
2d2e			 
2d2e					FORTH_DSP_VALUEHL 
2d2e cd 3e 1e			call macro_dsp_valuehl 
2d31				endm 
# End of macro FORTH_DSP_VALUEHL
2d31			 
2d31 e5					push hl    ; save address 
2d32			 
2d32					; load content into de 
2d32			 
2d32 5e					ld e,(hl) 
2d33 23					inc hl 
2d34 56					ld d, (hl) 
2d35			 
2d35					if DEBUG_FORTH_WORDS 
2d35						DMARK "+2a" 
2d35 f5				push af  
2d36 3a 4a 2d			ld a, (.dmark)  
2d39 32 6b ee			ld (debug_mark),a  
2d3c 3a 4b 2d			ld a, (.dmark+1)  
2d3f 32 6c ee			ld (debug_mark+1),a  
2d42 3a 4c 2d			ld a, (.dmark+2)  
2d45 32 6d ee			ld (debug_mark+2),a  
2d48 18 03			jr .pastdmark  
2d4a ..			.dmark: db "+2a"  
2d4d f1			.pastdmark: pop af  
2d4e			endm  
# End of macro DMARK
2d4e						CALLMONITOR 
2d4e cd 6f ee			call debug_vector  
2d51				endm  
# End of macro CALLMONITOR
2d51					endif 
2d51			 
2d51					FORTH_DSP_POP 
2d51 cd f6 1e			call macro_forth_dsp_pop 
2d54				endm 
# End of macro FORTH_DSP_POP
2d54			 
2d54					; Get value to add 
2d54			 
2d54					FORTH_DSP_VALUE 
2d54 cd 27 1e			call macro_forth_dsp_value 
2d57				endm 
# End of macro FORTH_DSP_VALUE
2d57			 
2d57					if DEBUG_FORTH_WORDS 
2d57						DMARK "+2v" 
2d57 f5				push af  
2d58 3a 6c 2d			ld a, (.dmark)  
2d5b 32 6b ee			ld (debug_mark),a  
2d5e 3a 6d 2d			ld a, (.dmark+1)  
2d61 32 6c ee			ld (debug_mark+1),a  
2d64 3a 6e 2d			ld a, (.dmark+2)  
2d67 32 6d ee			ld (debug_mark+2),a  
2d6a 18 03			jr .pastdmark  
2d6c ..			.dmark: db "+2v"  
2d6f f1			.pastdmark: pop af  
2d70			endm  
# End of macro DMARK
2d70						CALLMONITOR 
2d70 cd 6f ee			call debug_vector  
2d73				endm  
# End of macro CALLMONITOR
2d73					endif 
2d73			 
2d73 19					add hl, de 
2d74			 
2d74					if DEBUG_FORTH_WORDS 
2d74						DMARK "+2+" 
2d74 f5				push af  
2d75 3a 89 2d			ld a, (.dmark)  
2d78 32 6b ee			ld (debug_mark),a  
2d7b 3a 8a 2d			ld a, (.dmark+1)  
2d7e 32 6c ee			ld (debug_mark+1),a  
2d81 3a 8b 2d			ld a, (.dmark+2)  
2d84 32 6d ee			ld (debug_mark+2),a  
2d87 18 03			jr .pastdmark  
2d89 ..			.dmark: db "+2+"  
2d8c f1			.pastdmark: pop af  
2d8d			endm  
# End of macro DMARK
2d8d						CALLMONITOR 
2d8d cd 6f ee			call debug_vector  
2d90				endm  
# End of macro CALLMONITOR
2d90					endif 
2d90			 
2d90					; move result to de 
2d90			 
2d90 eb					ex de, hl 
2d91			 
2d91					; Address 
2d91			 
2d91 e1					pop hl 
2d92			 
2d92					; save it back 
2d92			 
2d92 73					ld (hl), e 
2d93 23					inc hl 
2d94 72					ld (hl), d 
2d95			 
2d95					if DEBUG_FORTH_WORDS 
2d95						DMARK "+2e" 
2d95 f5				push af  
2d96 3a aa 2d			ld a, (.dmark)  
2d99 32 6b ee			ld (debug_mark),a  
2d9c 3a ab 2d			ld a, (.dmark+1)  
2d9f 32 6c ee			ld (debug_mark+1),a  
2da2 3a ac 2d			ld a, (.dmark+2)  
2da5 32 6d ee			ld (debug_mark+2),a  
2da8 18 03			jr .pastdmark  
2daa ..			.dmark: db "+2e"  
2dad f1			.pastdmark: pop af  
2dae			endm  
# End of macro DMARK
2dae						CALLMONITOR 
2dae cd 6f ee			call debug_vector  
2db1				endm  
# End of macro CALLMONITOR
2db1					endif 
2db1			 
2db1			 
2db1			 
2db1			 
2db1			 
2db1				       NEXTW 
2db1 c3 f4 1f			jp macro_next 
2db4				endm 
# End of macro NEXTW
2db4			 
2db4			.DEC2: 
2db4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2db4 6f				db WORD_SYS_CORE+91             
2db5 60 2e			dw .GET2            
2db7 04				db 3 + 1 
2db8 .. 00			db "-2!",0              
2dbc				endm 
# End of macro CWHEAD
2dbc			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dbc			 
2dbc			 
2dbc					if DEBUG_FORTH_WORDS_KEY 
2dbc						DMARK "-2s" 
2dbc f5				push af  
2dbd 3a d1 2d			ld a, (.dmark)  
2dc0 32 6b ee			ld (debug_mark),a  
2dc3 3a d2 2d			ld a, (.dmark+1)  
2dc6 32 6c ee			ld (debug_mark+1),a  
2dc9 3a d3 2d			ld a, (.dmark+2)  
2dcc 32 6d ee			ld (debug_mark+2),a  
2dcf 18 03			jr .pastdmark  
2dd1 ..			.dmark: db "-2s"  
2dd4 f1			.pastdmark: pop af  
2dd5			endm  
# End of macro DMARK
2dd5						CALLMONITOR 
2dd5 cd 6f ee			call debug_vector  
2dd8				endm  
# End of macro CALLMONITOR
2dd8					endif 
2dd8			 
2dd8					; Address 
2dd8			 
2dd8					FORTH_DSP_VALUEHL 
2dd8 cd 3e 1e			call macro_dsp_valuehl 
2ddb				endm 
# End of macro FORTH_DSP_VALUEHL
2ddb			 
2ddb e5					push hl    ; save address 
2ddc			 
2ddc					; load content into de 
2ddc			 
2ddc 5e					ld e,(hl) 
2ddd 23					inc hl 
2dde 56					ld d, (hl) 
2ddf			 
2ddf					if DEBUG_FORTH_WORDS 
2ddf						DMARK "-2a" 
2ddf f5				push af  
2de0 3a f4 2d			ld a, (.dmark)  
2de3 32 6b ee			ld (debug_mark),a  
2de6 3a f5 2d			ld a, (.dmark+1)  
2de9 32 6c ee			ld (debug_mark+1),a  
2dec 3a f6 2d			ld a, (.dmark+2)  
2def 32 6d ee			ld (debug_mark+2),a  
2df2 18 03			jr .pastdmark  
2df4 ..			.dmark: db "-2a"  
2df7 f1			.pastdmark: pop af  
2df8			endm  
# End of macro DMARK
2df8						CALLMONITOR 
2df8 cd 6f ee			call debug_vector  
2dfb				endm  
# End of macro CALLMONITOR
2dfb					endif 
2dfb			 
2dfb					FORTH_DSP_POP 
2dfb cd f6 1e			call macro_forth_dsp_pop 
2dfe				endm 
# End of macro FORTH_DSP_POP
2dfe			 
2dfe					; Get value to remove 
2dfe			 
2dfe					FORTH_DSP_VALUE 
2dfe cd 27 1e			call macro_forth_dsp_value 
2e01				endm 
# End of macro FORTH_DSP_VALUE
2e01			 
2e01					if DEBUG_FORTH_WORDS 
2e01						DMARK "-2v" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 6b ee			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 6c ee			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 6d ee			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "-2v"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a						CALLMONITOR 
2e1a cd 6f ee			call debug_vector  
2e1d				endm  
# End of macro CALLMONITOR
2e1d					endif 
2e1d			 
2e1d eb					ex de, hl 
2e1e ed 52				sbc hl, de 
2e20			 
2e20					if DEBUG_FORTH_WORDS 
2e20						DMARK "-2d" 
2e20 f5				push af  
2e21 3a 35 2e			ld a, (.dmark)  
2e24 32 6b ee			ld (debug_mark),a  
2e27 3a 36 2e			ld a, (.dmark+1)  
2e2a 32 6c ee			ld (debug_mark+1),a  
2e2d 3a 37 2e			ld a, (.dmark+2)  
2e30 32 6d ee			ld (debug_mark+2),a  
2e33 18 03			jr .pastdmark  
2e35 ..			.dmark: db "-2d"  
2e38 f1			.pastdmark: pop af  
2e39			endm  
# End of macro DMARK
2e39						CALLMONITOR 
2e39 cd 6f ee			call debug_vector  
2e3c				endm  
# End of macro CALLMONITOR
2e3c					endif 
2e3c			 
2e3c					; move result to de 
2e3c			 
2e3c eb					ex de, hl 
2e3d			 
2e3d					; Address 
2e3d			 
2e3d e1					pop hl 
2e3e			 
2e3e					; save it back 
2e3e			 
2e3e 73					ld (hl), e 
2e3f 23					inc hl 
2e40 72					ld (hl), d 
2e41			 
2e41					if DEBUG_FORTH_WORDS 
2e41						DMARK "-2e" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 6b ee			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 6c ee			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 6d ee			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "-2e"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a						CALLMONITOR 
2e5a cd 6f ee			call debug_vector  
2e5d				endm  
# End of macro CALLMONITOR
2e5d					endif 
2e5d			 
2e5d			 
2e5d			 
2e5d			 
2e5d			 
2e5d				       NEXTW 
2e5d c3 f4 1f			jp macro_next 
2e60				endm 
# End of macro NEXTW
2e60			.GET2: 
2e60				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e60 6f				db WORD_SYS_CORE+91             
2e61 90 2e			dw .BANG2            
2e63 03				db 2 + 1 
2e64 .. 00			db "2@",0              
2e67				endm 
# End of macro CWHEAD
2e67			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e67					if DEBUG_FORTH_WORDS_KEY 
2e67						DMARK "2A_" 
2e67 f5				push af  
2e68 3a 7c 2e			ld a, (.dmark)  
2e6b 32 6b ee			ld (debug_mark),a  
2e6e 3a 7d 2e			ld a, (.dmark+1)  
2e71 32 6c ee			ld (debug_mark+1),a  
2e74 3a 7e 2e			ld a, (.dmark+2)  
2e77 32 6d ee			ld (debug_mark+2),a  
2e7a 18 03			jr .pastdmark  
2e7c ..			.dmark: db "2A_"  
2e7f f1			.pastdmark: pop af  
2e80			endm  
# End of macro DMARK
2e80						CALLMONITOR 
2e80 cd 6f ee			call debug_vector  
2e83				endm  
# End of macro CALLMONITOR
2e83					endif 
2e83			 
2e83					FORTH_DSP_VALUEHL 
2e83 cd 3e 1e			call macro_dsp_valuehl 
2e86				endm 
# End of macro FORTH_DSP_VALUEHL
2e86			 
2e86 5e					ld e, (hl) 
2e87 23					inc hl 
2e88 56					ld d, (hl) 
2e89			 
2e89 eb					ex de, hl 
2e8a			 
2e8a cd 47 1c				call forth_push_numhl 
2e8d			 
2e8d				       NEXTW 
2e8d c3 f4 1f			jp macro_next 
2e90				endm 
# End of macro NEXTW
2e90			.BANG2: 
2e90				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e90 6f				db WORD_SYS_CORE+91             
2e91 c8 2e			dw .CONFIG            
2e93 03				db 2 + 1 
2e94 .. 00			db "2!",0              
2e97				endm 
# End of macro CWHEAD
2e97			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e97					if DEBUG_FORTH_WORDS_KEY 
2e97						DMARK "2S_" 
2e97 f5				push af  
2e98 3a ac 2e			ld a, (.dmark)  
2e9b 32 6b ee			ld (debug_mark),a  
2e9e 3a ad 2e			ld a, (.dmark+1)  
2ea1 32 6c ee			ld (debug_mark+1),a  
2ea4 3a ae 2e			ld a, (.dmark+2)  
2ea7 32 6d ee			ld (debug_mark+2),a  
2eaa 18 03			jr .pastdmark  
2eac ..			.dmark: db "2S_"  
2eaf f1			.pastdmark: pop af  
2eb0			endm  
# End of macro DMARK
2eb0						CALLMONITOR 
2eb0 cd 6f ee			call debug_vector  
2eb3				endm  
# End of macro CALLMONITOR
2eb3					endif 
2eb3			 
2eb3					FORTH_DSP_VALUEHL 
2eb3 cd 3e 1e			call macro_dsp_valuehl 
2eb6				endm 
# End of macro FORTH_DSP_VALUEHL
2eb6			 
2eb6 e5					push hl   ; save address 
2eb7			 
2eb7			 
2eb7					FORTH_DSP_POP 
2eb7 cd f6 1e			call macro_forth_dsp_pop 
2eba				endm 
# End of macro FORTH_DSP_POP
2eba			 
2eba					 
2eba					FORTH_DSP_VALUEHL 
2eba cd 3e 1e			call macro_dsp_valuehl 
2ebd				endm 
# End of macro FORTH_DSP_VALUEHL
2ebd			 
2ebd					FORTH_DSP_POP 
2ebd cd f6 1e			call macro_forth_dsp_pop 
2ec0				endm 
# End of macro FORTH_DSP_POP
2ec0			 
2ec0 eb					ex de, hl    ; value now in de 
2ec1			 
2ec1 e1					pop hl 
2ec2			 
2ec2 73					ld (hl), e 
2ec3			 
2ec3 23					inc hl 
2ec4			 
2ec4 72					ld (hl), d 
2ec5			 
2ec5			 
2ec5				       NEXTW 
2ec5 c3 f4 1f			jp macro_next 
2ec8				endm 
# End of macro NEXTW
2ec8			.CONFIG: 
2ec8				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ec8 6f				db WORD_SYS_CORE+91             
2ec9 d9 2e			dw .ADTOS            
2ecb 07				db 6 + 1 
2ecc .. 00			db "CONFIG",0              
2ed3				endm 
# End of macro CWHEAD
2ed3			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ed3			 
2ed3 cd 47 14				call config 
2ed6					NEXTW 
2ed6 c3 f4 1f			jp macro_next 
2ed9				endm 
# End of macro NEXTW
2ed9			 
2ed9			.ADTOS: 
2ed9				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ed9 6f				db WORD_SYS_CORE+91             
2eda ef 2e			dw .SBTOS            
2edc 03				db 2 + 1 
2edd .. 00			db "1+",0              
2ee0				endm 
# End of macro CWHEAD
2ee0			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2ee0			 
2ee0					FORTH_DSP_VALUEHL 
2ee0 cd 3e 1e			call macro_dsp_valuehl 
2ee3				endm 
# End of macro FORTH_DSP_VALUEHL
2ee3 e5					push hl 
2ee4			 
2ee4					FORTH_DSP_POP 
2ee4 cd f6 1e			call macro_forth_dsp_pop 
2ee7				endm 
# End of macro FORTH_DSP_POP
2ee7 e1					pop hl 
2ee8			 
2ee8 23					inc hl 
2ee9 cd 47 1c				call forth_push_numhl 
2eec					 
2eec					NEXTW 
2eec c3 f4 1f			jp macro_next 
2eef				endm 
# End of macro NEXTW
2eef			.SBTOS: 
2eef				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2eef 6f				db WORD_SYS_CORE+91             
2ef0 05 2f			dw .ADSTORE            
2ef2 03				db 2 + 1 
2ef3 .. 00			db "1-",0              
2ef6				endm 
# End of macro CWHEAD
2ef6			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2ef6			 
2ef6					FORTH_DSP_VALUEHL 
2ef6 cd 3e 1e			call macro_dsp_valuehl 
2ef9				endm 
# End of macro FORTH_DSP_VALUEHL
2ef9 e5					push hl 
2efa			 
2efa					FORTH_DSP_POP 
2efa cd f6 1e			call macro_forth_dsp_pop 
2efd				endm 
# End of macro FORTH_DSP_POP
2efd e1					pop hl 
2efe			 
2efe 2b					dec hl 
2eff cd 47 1c				call forth_push_numhl 
2f02					 
2f02					NEXTW 
2f02 c3 f4 1f			jp macro_next 
2f05				endm 
# End of macro NEXTW
2f05			.ADSTORE: 
2f05				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f05 6f				db WORD_SYS_CORE+91             
2f06 1b 2f			dw .ADWSTORE            
2f08 04				db 3 + 1 
2f09 .. 00			db "1+!",0              
2f0d				endm 
# End of macro CWHEAD
2f0d			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f0d			 
2f0d					FORTH_DSP_VALUEHL 
2f0d cd 3e 1e			call macro_dsp_valuehl 
2f10				endm 
# End of macro FORTH_DSP_VALUEHL
2f10 e5					push hl 
2f11			 
2f11					FORTH_DSP_POP 
2f11 cd f6 1e			call macro_forth_dsp_pop 
2f14				endm 
# End of macro FORTH_DSP_POP
2f14 e1					pop hl 
2f15			 
2f15 7e					ld a, (hl) 
2f16 3c					inc a 
2f17 77					ld (hl), a 
2f18					 
2f18					NEXTW 
2f18 c3 f4 1f			jp macro_next 
2f1b				endm 
# End of macro NEXTW
2f1b			.ADWSTORE: 
2f1b				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f1b 6f				db WORD_SYS_CORE+91             
2f1c 39 2f			dw .ENDCORE            
2f1e 05				db 4 + 1 
2f1f .. 00			db "1+2!",0              
2f24				endm 
# End of macro CWHEAD
2f24			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f24			 
2f24					FORTH_DSP_VALUEHL 
2f24 cd 3e 1e			call macro_dsp_valuehl 
2f27				endm 
# End of macro FORTH_DSP_VALUEHL
2f27 e5					push hl 
2f28			 
2f28					FORTH_DSP_POP 
2f28 cd f6 1e			call macro_forth_dsp_pop 
2f2b				endm 
# End of macro FORTH_DSP_POP
2f2b e1					pop hl 
2f2c			 
2f2c e5					push hl 
2f2d			 
2f2d cd 76 1f				call loadwordinhl 
2f30 23					inc hl 
2f31			 
2f31 d1					pop de 
2f32 eb					ex de, hl 
2f33 73					ld (hl), e 
2f34 23					inc hl 
2f35 72					ld (hl), d 
2f36					 
2f36					NEXTW 
2f36 c3 f4 1f			jp macro_next 
2f39				endm 
# End of macro NEXTW
2f39			.ENDCORE: 
2f39			 
2f39			; eof 
2f39			 
2f39			 
# End of file forth_words_core.asm
2f39			include "forth_words_flow.asm" 
2f39			 
2f39			; | ## Program Flow Words 
2f39			 
2f39			.IF: 
2f39				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f39 1e				db WORD_SYS_CORE+10             
2f3a 2e 30			dw .THEN            
2f3c 03				db 2 + 1 
2f3d .. 00			db "IF",0              
2f40				endm 
# End of macro CWHEAD
2f40			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f40			; 
2f40					if DEBUG_FORTH_WORDS_KEY 
2f40						DMARK "IF." 
2f40 f5				push af  
2f41 3a 55 2f			ld a, (.dmark)  
2f44 32 6b ee			ld (debug_mark),a  
2f47 3a 56 2f			ld a, (.dmark+1)  
2f4a 32 6c ee			ld (debug_mark+1),a  
2f4d 3a 57 2f			ld a, (.dmark+2)  
2f50 32 6d ee			ld (debug_mark+2),a  
2f53 18 03			jr .pastdmark  
2f55 ..			.dmark: db "IF."  
2f58 f1			.pastdmark: pop af  
2f59			endm  
# End of macro DMARK
2f59						CALLMONITOR 
2f59 cd 6f ee			call debug_vector  
2f5c				endm  
# End of macro CALLMONITOR
2f5c					endif 
2f5c			; eval TOS 
2f5c			 
2f5c				FORTH_DSP_VALUEHL 
2f5c cd 3e 1e			call macro_dsp_valuehl 
2f5f				endm 
# End of macro FORTH_DSP_VALUEHL
2f5f			 
2f5f			;	push hl 
2f5f				FORTH_DSP_POP 
2f5f cd f6 1e			call macro_forth_dsp_pop 
2f62				endm 
# End of macro FORTH_DSP_POP
2f62			;	pop hl 
2f62			 
2f62					if DEBUG_FORTH_WORDS 
2f62						DMARK "IF1" 
2f62 f5				push af  
2f63 3a 77 2f			ld a, (.dmark)  
2f66 32 6b ee			ld (debug_mark),a  
2f69 3a 78 2f			ld a, (.dmark+1)  
2f6c 32 6c ee			ld (debug_mark+1),a  
2f6f 3a 79 2f			ld a, (.dmark+2)  
2f72 32 6d ee			ld (debug_mark+2),a  
2f75 18 03			jr .pastdmark  
2f77 ..			.dmark: db "IF1"  
2f7a f1			.pastdmark: pop af  
2f7b			endm  
# End of macro DMARK
2f7b						CALLMONITOR 
2f7b cd 6f ee			call debug_vector  
2f7e				endm  
# End of macro CALLMONITOR
2f7e					endif 
2f7e b7				or a        ; clear carry flag 
2f7f 11 00 00			ld de, 0 
2f82 eb				ex de,hl 
2f83 ed 52			sbc hl, de 
2f85 c2 0f 30			jp nz, .iftrue 
2f88			 
2f88					if DEBUG_FORTH_WORDS 
2f88						DMARK "IF2" 
2f88 f5				push af  
2f89 3a 9d 2f			ld a, (.dmark)  
2f8c 32 6b ee			ld (debug_mark),a  
2f8f 3a 9e 2f			ld a, (.dmark+1)  
2f92 32 6c ee			ld (debug_mark+1),a  
2f95 3a 9f 2f			ld a, (.dmark+2)  
2f98 32 6d ee			ld (debug_mark+2),a  
2f9b 18 03			jr .pastdmark  
2f9d ..			.dmark: db "IF2"  
2fa0 f1			.pastdmark: pop af  
2fa1			endm  
# End of macro DMARK
2fa1						CALLMONITOR 
2fa1 cd 6f ee			call debug_vector  
2fa4				endm  
# End of macro CALLMONITOR
2fa4					endif 
2fa4			 
2fa4			; if not true then skip to THEN 
2fa4			 
2fa4				; TODO get tok_ptr 
2fa4				; TODO consume toks until we get to THEN 
2fa4			 
2fa4 2a c2 e5			ld hl, (os_tok_ptr) 
2fa7					if DEBUG_FORTH_WORDS 
2fa7						DMARK "IF3" 
2fa7 f5				push af  
2fa8 3a bc 2f			ld a, (.dmark)  
2fab 32 6b ee			ld (debug_mark),a  
2fae 3a bd 2f			ld a, (.dmark+1)  
2fb1 32 6c ee			ld (debug_mark+1),a  
2fb4 3a be 2f			ld a, (.dmark+2)  
2fb7 32 6d ee			ld (debug_mark+2),a  
2fba 18 03			jr .pastdmark  
2fbc ..			.dmark: db "IF3"  
2fbf f1			.pastdmark: pop af  
2fc0			endm  
# End of macro DMARK
2fc0						CALLMONITOR 
2fc0 cd 6f ee			call debug_vector  
2fc3				endm  
# End of macro CALLMONITOR
2fc3						 
2fc3					endif 
2fc3 11 0a 30			ld de, .ifthen 
2fc6					if DEBUG_FORTH_WORDS 
2fc6						DMARK "IF4" 
2fc6 f5				push af  
2fc7 3a db 2f			ld a, (.dmark)  
2fca 32 6b ee			ld (debug_mark),a  
2fcd 3a dc 2f			ld a, (.dmark+1)  
2fd0 32 6c ee			ld (debug_mark+1),a  
2fd3 3a dd 2f			ld a, (.dmark+2)  
2fd6 32 6d ee			ld (debug_mark+2),a  
2fd9 18 03			jr .pastdmark  
2fdb ..			.dmark: db "IF4"  
2fde f1			.pastdmark: pop af  
2fdf			endm  
# End of macro DMARK
2fdf						CALLMONITOR 
2fdf cd 6f ee			call debug_vector  
2fe2				endm  
# End of macro CALLMONITOR
2fe2					endif 
2fe2 cd 0f 21			call findnexttok  
2fe5			 
2fe5					if DEBUG_FORTH_WORDS 
2fe5						DMARK "IF5" 
2fe5 f5				push af  
2fe6 3a fa 2f			ld a, (.dmark)  
2fe9 32 6b ee			ld (debug_mark),a  
2fec 3a fb 2f			ld a, (.dmark+1)  
2fef 32 6c ee			ld (debug_mark+1),a  
2ff2 3a fc 2f			ld a, (.dmark+2)  
2ff5 32 6d ee			ld (debug_mark+2),a  
2ff8 18 03			jr .pastdmark  
2ffa ..			.dmark: db "IF5"  
2ffd f1			.pastdmark: pop af  
2ffe			endm  
# End of macro DMARK
2ffe						CALLMONITOR 
2ffe cd 6f ee			call debug_vector  
3001				endm  
# End of macro CALLMONITOR
3001					endif 
3001				; TODO replace below with ; exec using tok_ptr 
3001 22 c2 e5			ld (os_tok_ptr), hl 
3004 c3 85 20			jp exec1 
3007				NEXTW 
3007 c3 f4 1f			jp macro_next 
300a				endm 
# End of macro NEXTW
300a			 
300a .. 00		.ifthen:  db "THEN",0 
300f			 
300f			.iftrue:		 
300f				; Exec next words normally 
300f			 
300f				; if true then exec following IF as normal 
300f					if DEBUG_FORTH_WORDS 
300f						DMARK "IFT" 
300f f5				push af  
3010 3a 24 30			ld a, (.dmark)  
3013 32 6b ee			ld (debug_mark),a  
3016 3a 25 30			ld a, (.dmark+1)  
3019 32 6c ee			ld (debug_mark+1),a  
301c 3a 26 30			ld a, (.dmark+2)  
301f 32 6d ee			ld (debug_mark+2),a  
3022 18 03			jr .pastdmark  
3024 ..			.dmark: db "IFT"  
3027 f1			.pastdmark: pop af  
3028			endm  
# End of macro DMARK
3028						CALLMONITOR 
3028 cd 6f ee			call debug_vector  
302b				endm  
# End of macro CALLMONITOR
302b					endif 
302b			 
302b					NEXTW 
302b c3 f4 1f			jp macro_next 
302e				endm 
# End of macro NEXTW
302e			.THEN: 
302e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
302e 1f				db WORD_SYS_CORE+11             
302f 56 30			dw .ELSE            
3031 05				db 4 + 1 
3032 .. 00			db "THEN",0              
3037				endm 
# End of macro CWHEAD
3037			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3037					if DEBUG_FORTH_WORDS_KEY 
3037						DMARK "THN" 
3037 f5				push af  
3038 3a 4c 30			ld a, (.dmark)  
303b 32 6b ee			ld (debug_mark),a  
303e 3a 4d 30			ld a, (.dmark+1)  
3041 32 6c ee			ld (debug_mark+1),a  
3044 3a 4e 30			ld a, (.dmark+2)  
3047 32 6d ee			ld (debug_mark+2),a  
304a 18 03			jr .pastdmark  
304c ..			.dmark: db "THN"  
304f f1			.pastdmark: pop af  
3050			endm  
# End of macro DMARK
3050						CALLMONITOR 
3050 cd 6f ee			call debug_vector  
3053				endm  
# End of macro CALLMONITOR
3053					endif 
3053					NEXTW 
3053 c3 f4 1f			jp macro_next 
3056				endm 
# End of macro NEXTW
3056			.ELSE: 
3056				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3056 20				db WORD_SYS_CORE+12             
3057 7e 30			dw .DO            
3059 03				db 2 + 1 
305a .. 00			db "ELSE",0              
305f				endm 
# End of macro CWHEAD
305f			; | ELSE ( -- ) Not supported - does nothing | TODO 
305f			 
305f					if DEBUG_FORTH_WORDS_KEY 
305f						DMARK "ELS" 
305f f5				push af  
3060 3a 74 30			ld a, (.dmark)  
3063 32 6b ee			ld (debug_mark),a  
3066 3a 75 30			ld a, (.dmark+1)  
3069 32 6c ee			ld (debug_mark+1),a  
306c 3a 76 30			ld a, (.dmark+2)  
306f 32 6d ee			ld (debug_mark+2),a  
3072 18 03			jr .pastdmark  
3074 ..			.dmark: db "ELS"  
3077 f1			.pastdmark: pop af  
3078			endm  
# End of macro DMARK
3078						CALLMONITOR 
3078 cd 6f ee			call debug_vector  
307b				endm  
# End of macro CALLMONITOR
307b					endif 
307b			 
307b			 
307b					NEXTW 
307b c3 f4 1f			jp macro_next 
307e				endm 
# End of macro NEXTW
307e			.DO: 
307e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
307e 21				db WORD_SYS_CORE+13             
307f a5 31			dw .LOOP            
3081 03				db 2 + 1 
3082 .. 00			db "DO",0              
3085				endm 
# End of macro CWHEAD
3085			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3085			 
3085					if DEBUG_FORTH_WORDS_KEY 
3085						DMARK "DO." 
3085 f5				push af  
3086 3a 9a 30			ld a, (.dmark)  
3089 32 6b ee			ld (debug_mark),a  
308c 3a 9b 30			ld a, (.dmark+1)  
308f 32 6c ee			ld (debug_mark+1),a  
3092 3a 9c 30			ld a, (.dmark+2)  
3095 32 6d ee			ld (debug_mark+2),a  
3098 18 03			jr .pastdmark  
309a ..			.dmark: db "DO."  
309d f1			.pastdmark: pop af  
309e			endm  
# End of macro DMARK
309e						CALLMONITOR 
309e cd 6f ee			call debug_vector  
30a1				endm  
# End of macro CALLMONITOR
30a1					endif 
30a1			;  push pc to rsp stack past the DO 
30a1			 
30a1 2a c2 e5				ld hl, (os_tok_ptr) 
30a4 23					inc hl   ; D 
30a5 23					inc hl  ; O 
30a6 23					inc hl   ; null 
30a7					if DEBUG_FORTH_WORDS 
30a7						DMARK "DO2" 
30a7 f5				push af  
30a8 3a bc 30			ld a, (.dmark)  
30ab 32 6b ee			ld (debug_mark),a  
30ae 3a bd 30			ld a, (.dmark+1)  
30b1 32 6c ee			ld (debug_mark+1),a  
30b4 3a be 30			ld a, (.dmark+2)  
30b7 32 6d ee			ld (debug_mark+2),a  
30ba 18 03			jr .pastdmark  
30bc ..			.dmark: db "DO2"  
30bf f1			.pastdmark: pop af  
30c0			endm  
# End of macro DMARK
30c0						CALLMONITOR 
30c0 cd 6f ee			call debug_vector  
30c3				endm  
# End of macro CALLMONITOR
30c3					endif 
30c3					FORTH_RSP_NEXT 
30c3 cd ee 1b			call macro_forth_rsp_next 
30c6				endm 
# End of macro FORTH_RSP_NEXT
30c6					if DEBUG_FORTH_WORDS 
30c6						DMARK "DO3" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 6b ee			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 6c ee			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 6d ee			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "DO3"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 6f ee			call debug_vector  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2			 
30e2					;if DEBUG_FORTH_WORDS 
30e2				;		push hl 
30e2			;		endif  
30e2			 
30e2			; get counters from data stack 
30e2			 
30e2			 
30e2					FORTH_DSP_VALUEHL 
30e2 cd 3e 1e			call macro_dsp_valuehl 
30e5				endm 
# End of macro FORTH_DSP_VALUEHL
30e5 e5					push hl		 ; hl now has starting counter which needs to be tos 
30e6			 
30e6					if DEBUG_FORTH_WORDS 
30e6						DMARK "DO4" 
30e6 f5				push af  
30e7 3a fb 30			ld a, (.dmark)  
30ea 32 6b ee			ld (debug_mark),a  
30ed 3a fc 30			ld a, (.dmark+1)  
30f0 32 6c ee			ld (debug_mark+1),a  
30f3 3a fd 30			ld a, (.dmark+2)  
30f6 32 6d ee			ld (debug_mark+2),a  
30f9 18 03			jr .pastdmark  
30fb ..			.dmark: db "DO4"  
30fe f1			.pastdmark: pop af  
30ff			endm  
# End of macro DMARK
30ff						CALLMONITOR 
30ff cd 6f ee			call debug_vector  
3102				endm  
# End of macro CALLMONITOR
3102					endif 
3102					FORTH_DSP_POP 
3102 cd f6 1e			call macro_forth_dsp_pop 
3105				endm 
# End of macro FORTH_DSP_POP
3105			 
3105					if DEBUG_FORTH_WORDS 
3105						DMARK "DO5" 
3105 f5				push af  
3106 3a 1a 31			ld a, (.dmark)  
3109 32 6b ee			ld (debug_mark),a  
310c 3a 1b 31			ld a, (.dmark+1)  
310f 32 6c ee			ld (debug_mark+1),a  
3112 3a 1c 31			ld a, (.dmark+2)  
3115 32 6d ee			ld (debug_mark+2),a  
3118 18 03			jr .pastdmark  
311a ..			.dmark: db "DO5"  
311d f1			.pastdmark: pop af  
311e			endm  
# End of macro DMARK
311e						CALLMONITOR 
311e cd 6f ee			call debug_vector  
3121				endm  
# End of macro CALLMONITOR
3121					endif 
3121			 
3121					FORTH_DSP_VALUEHL 
3121 cd 3e 1e			call macro_dsp_valuehl 
3124				endm 
# End of macro FORTH_DSP_VALUEHL
3124			;		push hl		 ; hl now has starting limit counter 
3124			 
3124					if DEBUG_FORTH_WORDS 
3124						DMARK "DO6" 
3124 f5				push af  
3125 3a 39 31			ld a, (.dmark)  
3128 32 6b ee			ld (debug_mark),a  
312b 3a 3a 31			ld a, (.dmark+1)  
312e 32 6c ee			ld (debug_mark+1),a  
3131 3a 3b 31			ld a, (.dmark+2)  
3134 32 6d ee			ld (debug_mark+2),a  
3137 18 03			jr .pastdmark  
3139 ..			.dmark: db "DO6"  
313c f1			.pastdmark: pop af  
313d			endm  
# End of macro DMARK
313d						CALLMONITOR 
313d cd 6f ee			call debug_vector  
3140				endm  
# End of macro CALLMONITOR
3140					endif 
3140					FORTH_DSP_POP 
3140 cd f6 1e			call macro_forth_dsp_pop 
3143				endm 
# End of macro FORTH_DSP_POP
3143			 
3143			; put counters on the loop stack 
3143			 
3143			;		pop hl			 ; limit counter 
3143 d1					pop de			; start counter 
3144			 
3144					; push limit counter 
3144			 
3144					if DEBUG_FORTH_WORDS 
3144						DMARK "DO7" 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 6b ee			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 6c ee			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 6d ee			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "DO7"  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd 6f ee			call debug_vector  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160					FORTH_LOOP_NEXT 
3160 cd 6f 1e			call macro_forth_loop_next 
3163				endm 
# End of macro FORTH_LOOP_NEXT
3163			 
3163					; push start counter 
3163			 
3163 eb					ex de, hl 
3164					if DEBUG_FORTH_WORDS 
3164						DMARK "DO7" 
3164 f5				push af  
3165 3a 79 31			ld a, (.dmark)  
3168 32 6b ee			ld (debug_mark),a  
316b 3a 7a 31			ld a, (.dmark+1)  
316e 32 6c ee			ld (debug_mark+1),a  
3171 3a 7b 31			ld a, (.dmark+2)  
3174 32 6d ee			ld (debug_mark+2),a  
3177 18 03			jr .pastdmark  
3179 ..			.dmark: db "DO7"  
317c f1			.pastdmark: pop af  
317d			endm  
# End of macro DMARK
317d						CALLMONITOR 
317d cd 6f ee			call debug_vector  
3180				endm  
# End of macro CALLMONITOR
3180					endif 
3180					FORTH_LOOP_NEXT 
3180 cd 6f 1e			call macro_forth_loop_next 
3183				endm 
# End of macro FORTH_LOOP_NEXT
3183			 
3183			 
3183					; init first round of I counter 
3183			 
3183 22 e6 e5				ld (os_current_i), hl 
3186			 
3186					if DEBUG_FORTH_WORDS 
3186						DMARK "DO8" 
3186 f5				push af  
3187 3a 9b 31			ld a, (.dmark)  
318a 32 6b ee			ld (debug_mark),a  
318d 3a 9c 31			ld a, (.dmark+1)  
3190 32 6c ee			ld (debug_mark+1),a  
3193 3a 9d 31			ld a, (.dmark+2)  
3196 32 6d ee			ld (debug_mark+2),a  
3199 18 03			jr .pastdmark  
319b ..			.dmark: db "DO8"  
319e f1			.pastdmark: pop af  
319f			endm  
# End of macro DMARK
319f						CALLMONITOR 
319f cd 6f ee			call debug_vector  
31a2				endm  
# End of macro CALLMONITOR
31a2					endif 
31a2			 
31a2					NEXTW 
31a2 c3 f4 1f			jp macro_next 
31a5				endm 
# End of macro NEXTW
31a5			.LOOP: 
31a5				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31a5 22				db WORD_SYS_CORE+14             
31a6 bd 32			dw .I            
31a8 05				db 4 + 1 
31a9 .. 00			db "LOOP",0              
31ae				endm 
# End of macro CWHEAD
31ae			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31ae			 
31ae				; pop tos as current loop count to hl 
31ae			 
31ae				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31ae			 
31ae				FORTH_LOOP_TOS 
31ae cd a2 1e			call macro_forth_loop_tos 
31b1				endm 
# End of macro FORTH_LOOP_TOS
31b1 e5				push hl 
31b2			 
31b2					if DEBUG_FORTH_WORDS_KEY 
31b2						DMARK "LOP" 
31b2 f5				push af  
31b3 3a c7 31			ld a, (.dmark)  
31b6 32 6b ee			ld (debug_mark),a  
31b9 3a c8 31			ld a, (.dmark+1)  
31bc 32 6c ee			ld (debug_mark+1),a  
31bf 3a c9 31			ld a, (.dmark+2)  
31c2 32 6d ee			ld (debug_mark+2),a  
31c5 18 03			jr .pastdmark  
31c7 ..			.dmark: db "LOP"  
31ca f1			.pastdmark: pop af  
31cb			endm  
# End of macro DMARK
31cb						CALLMONITOR 
31cb cd 6f ee			call debug_vector  
31ce				endm  
# End of macro CALLMONITOR
31ce					endif 
31ce				; next item on the stack is the limit. get it 
31ce			 
31ce			 
31ce				FORTH_LOOP_POP 
31ce cd ac 1e			call macro_forth_loop_pop 
31d1				endm 
# End of macro FORTH_LOOP_POP
31d1			 
31d1				FORTH_LOOP_TOS 
31d1 cd a2 1e			call macro_forth_loop_tos 
31d4				endm 
# End of macro FORTH_LOOP_TOS
31d4			 
31d4 d1				pop de		 ; de = i, hl = limit 
31d5			 
31d5					if DEBUG_FORTH_WORDS 
31d5						DMARK "LP1" 
31d5 f5				push af  
31d6 3a ea 31			ld a, (.dmark)  
31d9 32 6b ee			ld (debug_mark),a  
31dc 3a eb 31			ld a, (.dmark+1)  
31df 32 6c ee			ld (debug_mark+1),a  
31e2 3a ec 31			ld a, (.dmark+2)  
31e5 32 6d ee			ld (debug_mark+2),a  
31e8 18 03			jr .pastdmark  
31ea ..			.dmark: db "LP1"  
31ed f1			.pastdmark: pop af  
31ee			endm  
# End of macro DMARK
31ee						CALLMONITOR 
31ee cd 6f ee			call debug_vector  
31f1				endm  
# End of macro CALLMONITOR
31f1					endif 
31f1			 
31f1				; go back to previous word 
31f1			 
31f1 d5				push de    ; save I for inc later 
31f2			 
31f2			 
31f2				; get limit 
31f2				;  is I at limit? 
31f2			 
31f2			 
31f2					if DEBUG_FORTH_WORDS 
31f2						DMARK "LP1" 
31f2 f5				push af  
31f3 3a 07 32			ld a, (.dmark)  
31f6 32 6b ee			ld (debug_mark),a  
31f9 3a 08 32			ld a, (.dmark+1)  
31fc 32 6c ee			ld (debug_mark+1),a  
31ff 3a 09 32			ld a, (.dmark+2)  
3202 32 6d ee			ld (debug_mark+2),a  
3205 18 03			jr .pastdmark  
3207 ..			.dmark: db "LP1"  
320a f1			.pastdmark: pop af  
320b			endm  
# End of macro DMARK
320b						CALLMONITOR 
320b cd 6f ee			call debug_vector  
320e				endm  
# End of macro CALLMONITOR
320e					endif 
320e			 
320e ed 52			sbc hl, de 
3210			 
3210			 
3210				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3210			 
3210 20 26				jr nz, .loopnotdone 
3212			 
3212 e1				pop hl   ; get rid of saved I 
3213				FORTH_LOOP_POP     ; get rid of limit 
3213 cd ac 1e			call macro_forth_loop_pop 
3216				endm 
# End of macro FORTH_LOOP_POP
3216			 
3216				FORTH_RSP_POP     ; get rid of DO ptr 
3216 cd 0f 1c			call macro_forth_rsp_pop 
3219				endm 
# End of macro FORTH_RSP_POP
3219			 
3219			if DEBUG_FORTH_WORDS 
3219						DMARK "LP>" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 6b ee			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 6c ee			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 6d ee			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "LP>"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232				CALLMONITOR 
3232 cd 6f ee			call debug_vector  
3235				endm  
# End of macro CALLMONITOR
3235			endif 
3235			 
3235					NEXTW 
3235 c3 f4 1f			jp macro_next 
3238				endm 
# End of macro NEXTW
3238				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3238			 
3238			.loopnotdone: 
3238			 
3238 e1				pop hl    ; get I 
3239 23				inc hl 
323a			 
323a			   	; save new I 
323a			 
323a			 
323a					; set I counter 
323a			 
323a 22 e6 e5				ld (os_current_i), hl 
323d			 
323d					if DEBUG_FORTH_WORDS 
323d						DMARK "LPN" 
323d f5				push af  
323e 3a 52 32			ld a, (.dmark)  
3241 32 6b ee			ld (debug_mark),a  
3244 3a 53 32			ld a, (.dmark+1)  
3247 32 6c ee			ld (debug_mark+1),a  
324a 3a 54 32			ld a, (.dmark+2)  
324d 32 6d ee			ld (debug_mark+2),a  
3250 18 03			jr .pastdmark  
3252 ..			.dmark: db "LPN"  
3255 f1			.pastdmark: pop af  
3256			endm  
# End of macro DMARK
3256					CALLMONITOR 
3256 cd 6f ee			call debug_vector  
3259				endm  
# End of macro CALLMONITOR
3259					endif 
3259					 
3259				FORTH_LOOP_NEXT 
3259 cd 6f 1e			call macro_forth_loop_next 
325c				endm 
# End of macro FORTH_LOOP_NEXT
325c			 
325c			 
325c					if DEBUG_FORTH_WORDS 
325c eb						ex de,hl 
325d					endif 
325d			 
325d			;	; get DO ptr 
325d			; 
325d					if DEBUG_FORTH_WORDS 
325d						DMARK "LP7" 
325d f5				push af  
325e 3a 72 32			ld a, (.dmark)  
3261 32 6b ee			ld (debug_mark),a  
3264 3a 73 32			ld a, (.dmark+1)  
3267 32 6c ee			ld (debug_mark+1),a  
326a 3a 74 32			ld a, (.dmark+2)  
326d 32 6d ee			ld (debug_mark+2),a  
3270 18 03			jr .pastdmark  
3272 ..			.dmark: db "LP7"  
3275 f1			.pastdmark: pop af  
3276			endm  
# End of macro DMARK
3276					CALLMONITOR 
3276 cd 6f ee			call debug_vector  
3279				endm  
# End of macro CALLMONITOR
3279					endif 
3279				FORTH_RSP_TOS 
3279 cd 05 1c			call macro_forth_rsp_tos 
327c				endm 
# End of macro FORTH_RSP_TOS
327c			 
327c					if DEBUG_FORTH_WORDS 
327c						DMARK "LP8" 
327c f5				push af  
327d 3a 91 32			ld a, (.dmark)  
3280 32 6b ee			ld (debug_mark),a  
3283 3a 92 32			ld a, (.dmark+1)  
3286 32 6c ee			ld (debug_mark+1),a  
3289 3a 93 32			ld a, (.dmark+2)  
328c 32 6d ee			ld (debug_mark+2),a  
328f 18 03			jr .pastdmark  
3291 ..			.dmark: db "LP8"  
3294 f1			.pastdmark: pop af  
3295			endm  
# End of macro DMARK
3295					CALLMONITOR 
3295 cd 6f ee			call debug_vector  
3298				endm  
# End of macro CALLMONITOR
3298					endif 
3298				;push hl 
3298			 
3298				; not going to DO any more 
3298				; get rid of the RSP pointer as DO will add it back in 
3298				;FORTH_RSP_POP 
3298				;pop hl 
3298			 
3298				;ld hl,(cli_ret_sp) 
3298				;ld e, (hl) 
3298				;inc hl 
3298				;ld d, (hl) 
3298				;ex de,hl 
3298 22 c2 e5			ld (os_tok_ptr), hl 
329b					if DEBUG_FORTH_WORDS 
329b						DMARK "LP<" 
329b f5				push af  
329c 3a b0 32			ld a, (.dmark)  
329f 32 6b ee			ld (debug_mark),a  
32a2 3a b1 32			ld a, (.dmark+1)  
32a5 32 6c ee			ld (debug_mark+1),a  
32a8 3a b2 32			ld a, (.dmark+2)  
32ab 32 6d ee			ld (debug_mark+2),a  
32ae 18 03			jr .pastdmark  
32b0 ..			.dmark: db "LP<"  
32b3 f1			.pastdmark: pop af  
32b4			endm  
# End of macro DMARK
32b4					CALLMONITOR 
32b4 cd 6f ee			call debug_vector  
32b7				endm  
# End of macro CALLMONITOR
32b7				endif 
32b7 c3 85 20			jp exec1 
32ba			 
32ba					 
32ba			 
32ba			 
32ba					NEXTW 
32ba c3 f4 1f			jp macro_next 
32bd				endm 
# End of macro NEXTW
32bd			.I:  
32bd			 
32bd				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32bd 5e				db WORD_SYS_CORE+74             
32be e8 32			dw .DLOOP            
32c0 02				db 1 + 1 
32c1 .. 00			db "I",0              
32c3				endm 
# End of macro CWHEAD
32c3			; | I ( -- ) Current loop counter | DONE 
32c3					if DEBUG_FORTH_WORDS_KEY 
32c3						DMARK "I.." 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 6b ee			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 6c ee			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 6d ee			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "I.."  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd 6f ee			call debug_vector  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df			 
32df 2a e6 e5				ld hl,(os_current_i) 
32e2 cd 47 1c				call forth_push_numhl 
32e5			 
32e5					NEXTW 
32e5 c3 f4 1f			jp macro_next 
32e8				endm 
# End of macro NEXTW
32e8			.DLOOP: 
32e8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32e8 5f				db WORD_SYS_CORE+75             
32e9 c9 33			dw .REPEAT            
32eb 06				db 5 + 1 
32ec .. 00			db "-LOOP",0              
32f2				endm 
# End of macro CWHEAD
32f2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32f2				; pop tos as current loop count to hl 
32f2					if DEBUG_FORTH_WORDS_KEY 
32f2						DMARK "-LP" 
32f2 f5				push af  
32f3 3a 07 33			ld a, (.dmark)  
32f6 32 6b ee			ld (debug_mark),a  
32f9 3a 08 33			ld a, (.dmark+1)  
32fc 32 6c ee			ld (debug_mark+1),a  
32ff 3a 09 33			ld a, (.dmark+2)  
3302 32 6d ee			ld (debug_mark+2),a  
3305 18 03			jr .pastdmark  
3307 ..			.dmark: db "-LP"  
330a f1			.pastdmark: pop af  
330b			endm  
# End of macro DMARK
330b						CALLMONITOR 
330b cd 6f ee			call debug_vector  
330e				endm  
# End of macro CALLMONITOR
330e					endif 
330e			 
330e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
330e			 
330e				FORTH_LOOP_TOS 
330e cd a2 1e			call macro_forth_loop_tos 
3311				endm 
# End of macro FORTH_LOOP_TOS
3311 e5				push hl 
3312			 
3312					if DEBUG_FORTH_WORDS 
3312						DMARK "-LP" 
3312 f5				push af  
3313 3a 27 33			ld a, (.dmark)  
3316 32 6b ee			ld (debug_mark),a  
3319 3a 28 33			ld a, (.dmark+1)  
331c 32 6c ee			ld (debug_mark+1),a  
331f 3a 29 33			ld a, (.dmark+2)  
3322 32 6d ee			ld (debug_mark+2),a  
3325 18 03			jr .pastdmark  
3327 ..			.dmark: db "-LP"  
332a f1			.pastdmark: pop af  
332b			endm  
# End of macro DMARK
332b						CALLMONITOR 
332b cd 6f ee			call debug_vector  
332e				endm  
# End of macro CALLMONITOR
332e					endif 
332e				; next item on the stack is the limit. get it 
332e			 
332e			 
332e				FORTH_LOOP_POP 
332e cd ac 1e			call macro_forth_loop_pop 
3331				endm 
# End of macro FORTH_LOOP_POP
3331			 
3331				FORTH_LOOP_TOS 
3331 cd a2 1e			call macro_forth_loop_tos 
3334				endm 
# End of macro FORTH_LOOP_TOS
3334			 
3334 d1				pop de		 ; de = i, hl = limit 
3335			 
3335					if DEBUG_FORTH_WORDS 
3335						DMARK "-L1" 
3335 f5				push af  
3336 3a 4a 33			ld a, (.dmark)  
3339 32 6b ee			ld (debug_mark),a  
333c 3a 4b 33			ld a, (.dmark+1)  
333f 32 6c ee			ld (debug_mark+1),a  
3342 3a 4c 33			ld a, (.dmark+2)  
3345 32 6d ee			ld (debug_mark+2),a  
3348 18 03			jr .pastdmark  
334a ..			.dmark: db "-L1"  
334d f1			.pastdmark: pop af  
334e			endm  
# End of macro DMARK
334e						CALLMONITOR 
334e cd 6f ee			call debug_vector  
3351				endm  
# End of macro CALLMONITOR
3351					endif 
3351			 
3351				; go back to previous word 
3351			 
3351 d5				push de    ; save I for inc later 
3352			 
3352			 
3352				; get limit 
3352				;  is I at limit? 
3352			 
3352			 
3352					if DEBUG_FORTH_WORDS 
3352						DMARK "-L1" 
3352 f5				push af  
3353 3a 67 33			ld a, (.dmark)  
3356 32 6b ee			ld (debug_mark),a  
3359 3a 68 33			ld a, (.dmark+1)  
335c 32 6c ee			ld (debug_mark+1),a  
335f 3a 69 33			ld a, (.dmark+2)  
3362 32 6d ee			ld (debug_mark+2),a  
3365 18 03			jr .pastdmark  
3367 ..			.dmark: db "-L1"  
336a f1			.pastdmark: pop af  
336b			endm  
# End of macro DMARK
336b						CALLMONITOR 
336b cd 6f ee			call debug_vector  
336e				endm  
# End of macro CALLMONITOR
336e					endif 
336e			 
336e ed 52			sbc hl, de 
3370			 
3370			 
3370				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3370			 
3370 20 26				jr nz, .mloopnotdone 
3372			 
3372 e1				pop hl   ; get rid of saved I 
3373				FORTH_LOOP_POP     ; get rid of limit 
3373 cd ac 1e			call macro_forth_loop_pop 
3376				endm 
# End of macro FORTH_LOOP_POP
3376			 
3376				FORTH_RSP_POP     ; get rid of DO ptr 
3376 cd 0f 1c			call macro_forth_rsp_pop 
3379				endm 
# End of macro FORTH_RSP_POP
3379			 
3379			if DEBUG_FORTH_WORDS 
3379						DMARK "-L>" 
3379 f5				push af  
337a 3a 8e 33			ld a, (.dmark)  
337d 32 6b ee			ld (debug_mark),a  
3380 3a 8f 33			ld a, (.dmark+1)  
3383 32 6c ee			ld (debug_mark+1),a  
3386 3a 90 33			ld a, (.dmark+2)  
3389 32 6d ee			ld (debug_mark+2),a  
338c 18 03			jr .pastdmark  
338e ..			.dmark: db "-L>"  
3391 f1			.pastdmark: pop af  
3392			endm  
# End of macro DMARK
3392				CALLMONITOR 
3392 cd 6f ee			call debug_vector  
3395				endm  
# End of macro CALLMONITOR
3395			endif 
3395			 
3395					NEXTW 
3395 c3 f4 1f			jp macro_next 
3398				endm 
# End of macro NEXTW
3398				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3398			 
3398			.mloopnotdone: 
3398			 
3398 e1				pop hl    ; get I 
3399 2b				dec hl 
339a			 
339a			   	; save new I 
339a			 
339a			 
339a					; set I counter 
339a			 
339a 22 e6 e5				ld (os_current_i), hl 
339d			 
339d					 
339d				FORTH_LOOP_NEXT 
339d cd 6f 1e			call macro_forth_loop_next 
33a0				endm 
# End of macro FORTH_LOOP_NEXT
33a0			 
33a0			 
33a0					if DEBUG_FORTH_WORDS 
33a0 eb						ex de,hl 
33a1					endif 
33a1			 
33a1			;	; get DO ptr 
33a1			; 
33a1				FORTH_RSP_TOS 
33a1 cd 05 1c			call macro_forth_rsp_tos 
33a4				endm 
# End of macro FORTH_RSP_TOS
33a4			 
33a4				;push hl 
33a4			 
33a4				; not going to DO any more 
33a4				; get rid of the RSP pointer as DO will add it back in 
33a4				;FORTH_RSP_POP 
33a4				;pop hl 
33a4			 
33a4			 
33a4 22 c2 e5			ld (os_tok_ptr), hl 
33a7					if DEBUG_FORTH_WORDS 
33a7						DMARK "-L<" 
33a7 f5				push af  
33a8 3a bc 33			ld a, (.dmark)  
33ab 32 6b ee			ld (debug_mark),a  
33ae 3a bd 33			ld a, (.dmark+1)  
33b1 32 6c ee			ld (debug_mark+1),a  
33b4 3a be 33			ld a, (.dmark+2)  
33b7 32 6d ee			ld (debug_mark+2),a  
33ba 18 03			jr .pastdmark  
33bc ..			.dmark: db "-L<"  
33bf f1			.pastdmark: pop af  
33c0			endm  
# End of macro DMARK
33c0					CALLMONITOR 
33c0 cd 6f ee			call debug_vector  
33c3				endm  
# End of macro CALLMONITOR
33c3				endif 
33c3 c3 85 20			jp exec1 
33c6			 
33c6					 
33c6			 
33c6			 
33c6			 
33c6				NEXTW 
33c6 c3 f4 1f			jp macro_next 
33c9				endm 
# End of macro NEXTW
33c9			 
33c9			 
33c9			 
33c9			 
33c9			.REPEAT: 
33c9				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33c9 71				db WORD_SYS_CORE+93             
33ca 1c 34			dw .UNTIL            
33cc 06				db 5 + 1 
33cd .. 00			db "REPEAT",0              
33d4				endm 
# End of macro CWHEAD
33d4			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33d4			;  push pc to rsp stack past the REPEAT 
33d4					if DEBUG_FORTH_WORDS_KEY 
33d4						DMARK "REP" 
33d4 f5				push af  
33d5 3a e9 33			ld a, (.dmark)  
33d8 32 6b ee			ld (debug_mark),a  
33db 3a ea 33			ld a, (.dmark+1)  
33de 32 6c ee			ld (debug_mark+1),a  
33e1 3a eb 33			ld a, (.dmark+2)  
33e4 32 6d ee			ld (debug_mark+2),a  
33e7 18 03			jr .pastdmark  
33e9 ..			.dmark: db "REP"  
33ec f1			.pastdmark: pop af  
33ed			endm  
# End of macro DMARK
33ed						CALLMONITOR 
33ed cd 6f ee			call debug_vector  
33f0				endm  
# End of macro CALLMONITOR
33f0					endif 
33f0			 
33f0 2a c2 e5				ld hl, (os_tok_ptr) 
33f3 23					inc hl   ; R 
33f4 23					inc hl  ; E 
33f5 23					inc hl   ; P 
33f6 23					inc hl   ; E 
33f7 23					inc hl   ; A 
33f8 23					inc hl   ; T 
33f9 23					inc hl   ; zero 
33fa					FORTH_RSP_NEXT 
33fa cd ee 1b			call macro_forth_rsp_next 
33fd				endm 
# End of macro FORTH_RSP_NEXT
33fd			 
33fd			 
33fd					if DEBUG_FORTH_WORDS 
33fd						DMARK "REP" 
33fd f5				push af  
33fe 3a 12 34			ld a, (.dmark)  
3401 32 6b ee			ld (debug_mark),a  
3404 3a 13 34			ld a, (.dmark+1)  
3407 32 6c ee			ld (debug_mark+1),a  
340a 3a 14 34			ld a, (.dmark+2)  
340d 32 6d ee			ld (debug_mark+2),a  
3410 18 03			jr .pastdmark  
3412 ..			.dmark: db "REP"  
3415 f1			.pastdmark: pop af  
3416			endm  
# End of macro DMARK
3416						;pop bc    ; TODO BUG ?????? what is this for???? 
3416						CALLMONITOR 
3416 cd 6f ee			call debug_vector  
3419				endm  
# End of macro CALLMONITOR
3419					endif 
3419			 
3419					NEXTW 
3419 c3 f4 1f			jp macro_next 
341c				endm 
# End of macro NEXTW
341c			;	       NEXTW 
341c			 
341c			.UNTIL: 
341c				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
341c 72				db WORD_SYS_CORE+94             
341d b3 34			dw .ENDFLOW            
341f 06				db 5 + 1 
3420 .. 00			db "UNTIL",0              
3426				endm 
# End of macro CWHEAD
3426			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3426			 
3426				; pop tos as check 
3426			 
3426				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3426			 
3426				FORTH_DSP_VALUEHL 
3426 cd 3e 1e			call macro_dsp_valuehl 
3429				endm 
# End of macro FORTH_DSP_VALUEHL
3429			 
3429					if DEBUG_FORTH_WORDS_KEY 
3429						DMARK "UNT" 
3429 f5				push af  
342a 3a 3e 34			ld a, (.dmark)  
342d 32 6b ee			ld (debug_mark),a  
3430 3a 3f 34			ld a, (.dmark+1)  
3433 32 6c ee			ld (debug_mark+1),a  
3436 3a 40 34			ld a, (.dmark+2)  
3439 32 6d ee			ld (debug_mark+2),a  
343c 18 03			jr .pastdmark  
343e ..			.dmark: db "UNT"  
3441 f1			.pastdmark: pop af  
3442			endm  
# End of macro DMARK
3442						CALLMONITOR 
3442 cd 6f ee			call debug_vector  
3445				endm  
# End of macro CALLMONITOR
3445					endif 
3445			 
3445			;	push hl 
3445				FORTH_DSP_POP 
3445 cd f6 1e			call macro_forth_dsp_pop 
3448				endm 
# End of macro FORTH_DSP_POP
3448			 
3448			;	pop hl 
3448			 
3448				; test if true 
3448			 
3448 cd 10 0e			call ishlzero 
344b			;	ld a,l 
344b			;	add h 
344b			; 
344b			;	cp 0 
344b			 
344b 20 3e			jr nz, .untilnotdone 
344d			 
344d					if DEBUG_FORTH_WORDS 
344d						DMARK "UNf" 
344d f5				push af  
344e 3a 62 34			ld a, (.dmark)  
3451 32 6b ee			ld (debug_mark),a  
3454 3a 63 34			ld a, (.dmark+1)  
3457 32 6c ee			ld (debug_mark+1),a  
345a 3a 64 34			ld a, (.dmark+2)  
345d 32 6d ee			ld (debug_mark+2),a  
3460 18 03			jr .pastdmark  
3462 ..			.dmark: db "UNf"  
3465 f1			.pastdmark: pop af  
3466			endm  
# End of macro DMARK
3466						CALLMONITOR 
3466 cd 6f ee			call debug_vector  
3469				endm  
# End of macro CALLMONITOR
3469					endif 
3469			 
3469			 
3469			 
3469				FORTH_RSP_POP     ; get rid of DO ptr 
3469 cd 0f 1c			call macro_forth_rsp_pop 
346c				endm 
# End of macro FORTH_RSP_POP
346c			 
346c			if DEBUG_FORTH_WORDS 
346c						DMARK "UN>" 
346c f5				push af  
346d 3a 81 34			ld a, (.dmark)  
3470 32 6b ee			ld (debug_mark),a  
3473 3a 82 34			ld a, (.dmark+1)  
3476 32 6c ee			ld (debug_mark+1),a  
3479 3a 83 34			ld a, (.dmark+2)  
347c 32 6d ee			ld (debug_mark+2),a  
347f 18 03			jr .pastdmark  
3481 ..			.dmark: db "UN>"  
3484 f1			.pastdmark: pop af  
3485			endm  
# End of macro DMARK
3485				CALLMONITOR 
3485 cd 6f ee			call debug_vector  
3488				endm  
# End of macro CALLMONITOR
3488			endif 
3488			 
3488					NEXTW 
3488 c3 f4 1f			jp macro_next 
348b				endm 
# End of macro NEXTW
348b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
348b			 
348b			.untilnotdone: 
348b			 
348b			 
348b			;	; get DO ptr 
348b			; 
348b				FORTH_RSP_TOS 
348b cd 05 1c			call macro_forth_rsp_tos 
348e				endm 
# End of macro FORTH_RSP_TOS
348e			 
348e				;push hl 
348e			 
348e				; not going to DO any more 
348e				; get rid of the RSP pointer as DO will add it back in 
348e				;FORTH_RSP_POP 
348e				;pop hl 
348e			 
348e			 
348e 22 c2 e5			ld (os_tok_ptr), hl 
3491					if DEBUG_FORTH_WORDS 
3491						DMARK "UN<" 
3491 f5				push af  
3492 3a a6 34			ld a, (.dmark)  
3495 32 6b ee			ld (debug_mark),a  
3498 3a a7 34			ld a, (.dmark+1)  
349b 32 6c ee			ld (debug_mark+1),a  
349e 3a a8 34			ld a, (.dmark+2)  
34a1 32 6d ee			ld (debug_mark+2),a  
34a4 18 03			jr .pastdmark  
34a6 ..			.dmark: db "UN<"  
34a9 f1			.pastdmark: pop af  
34aa			endm  
# End of macro DMARK
34aa					CALLMONITOR 
34aa cd 6f ee			call debug_vector  
34ad				endm  
# End of macro CALLMONITOR
34ad				endif 
34ad c3 85 20			jp exec1 
34b0			 
34b0					 
34b0			 
34b0			 
34b0					NEXTW 
34b0 c3 f4 1f			jp macro_next 
34b3				endm 
# End of macro NEXTW
34b3			 
34b3			 
34b3			.ENDFLOW: 
34b3			 
34b3			; eof 
34b3			 
# End of file forth_words_flow.asm
34b3			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34b3			include "forth_words_logic.asm" 
34b3			 
34b3			; | ## Logic Words 
34b3			 
34b3			.NOT: 
34b3				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34b3 2d				db WORD_SYS_CORE+25             
34b4 fb 34			dw .IS            
34b6 04				db 3 + 1 
34b7 .. 00			db "NOT",0              
34bb				endm 
# End of macro CWHEAD
34bb			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34bb					if DEBUG_FORTH_WORDS_KEY 
34bb						DMARK "NOT" 
34bb f5				push af  
34bc 3a d0 34			ld a, (.dmark)  
34bf 32 6b ee			ld (debug_mark),a  
34c2 3a d1 34			ld a, (.dmark+1)  
34c5 32 6c ee			ld (debug_mark+1),a  
34c8 3a d2 34			ld a, (.dmark+2)  
34cb 32 6d ee			ld (debug_mark+2),a  
34ce 18 03			jr .pastdmark  
34d0 ..			.dmark: db "NOT"  
34d3 f1			.pastdmark: pop af  
34d4			endm  
# End of macro DMARK
34d4						CALLMONITOR 
34d4 cd 6f ee			call debug_vector  
34d7				endm  
# End of macro CALLMONITOR
34d7					endif 
34d7					FORTH_DSP 
34d7 cd 04 1e			call macro_forth_dsp 
34da				endm 
# End of macro FORTH_DSP
34da 7e					ld a,(hl)	; get type of value on TOS 
34db fe 02				cp DS_TYPE_INUM  
34dd 28 03				jr z, .noti 
34df					NEXTW 
34df c3 f4 1f			jp macro_next 
34e2				endm 
# End of macro NEXTW
34e2			.noti:          FORTH_DSP_VALUEHL 
34e2 cd 3e 1e			call macro_dsp_valuehl 
34e5				endm 
# End of macro FORTH_DSP_VALUEHL
34e5			;		push hl 
34e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34e5 cd f6 1e			call macro_forth_dsp_pop 
34e8				endm 
# End of macro FORTH_DSP_POP
34e8			;		pop hl 
34e8 3e 00				ld a,0 
34ea bd					cp l 
34eb 28 04				jr z, .not2t 
34ed 2e 00				ld l, 0 
34ef 18 02				jr .notip 
34f1			 
34f1 2e ff		.not2t:		ld l, 255 
34f3			 
34f3 26 00		.notip:		ld h, 0	 
34f5			 
34f5 cd 47 1c				call forth_push_numhl 
34f8					NEXTW 
34f8 c3 f4 1f			jp macro_next 
34fb				endm 
# End of macro NEXTW
34fb			 
34fb			.IS: 
34fb				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34fb 2d				db WORD_SYS_CORE+25             
34fc 21 35			dw .LZERO            
34fe 03				db 2 + 1 
34ff .. 00			db "IS",0              
3502				endm 
# End of macro CWHEAD
3502			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3502					if DEBUG_FORTH_WORDS_KEY 
3502						DMARK "IS." 
3502 f5				push af  
3503 3a 17 35			ld a, (.dmark)  
3506 32 6b ee			ld (debug_mark),a  
3509 3a 18 35			ld a, (.dmark+1)  
350c 32 6c ee			ld (debug_mark+1),a  
350f 3a 19 35			ld a, (.dmark+2)  
3512 32 6d ee			ld (debug_mark+2),a  
3515 18 03			jr .pastdmark  
3517 ..			.dmark: db "IS."  
351a f1			.pastdmark: pop af  
351b			endm  
# End of macro DMARK
351b						CALLMONITOR 
351b cd 6f ee			call debug_vector  
351e				endm  
# End of macro CALLMONITOR
351e					endif 
351e					NEXTW 
351e c3 f4 1f			jp macro_next 
3521				endm 
# End of macro NEXTW
3521			.LZERO: 
3521				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3521 2d				db WORD_SYS_CORE+25             
3522 2b 35			dw .TZERO            
3524 03				db 2 + 1 
3525 .. 00			db "0<",0              
3528				endm 
# End of macro CWHEAD
3528			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3528					NEXTW 
3528 c3 f4 1f			jp macro_next 
352b				endm 
# End of macro NEXTW
352b			.TZERO: 
352b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
352b 2e				db WORD_SYS_CORE+26             
352c 72 35			dw .LESS            
352e 03				db 2 + 1 
352f .. 00			db "0=",0              
3532				endm 
# End of macro CWHEAD
3532			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3532				; TODO add floating point number detection 
3532					;v5 FORTH_DSP_VALUE 
3532					if DEBUG_FORTH_WORDS_KEY 
3532						DMARK "0=." 
3532 f5				push af  
3533 3a 47 35			ld a, (.dmark)  
3536 32 6b ee			ld (debug_mark),a  
3539 3a 48 35			ld a, (.dmark+1)  
353c 32 6c ee			ld (debug_mark+1),a  
353f 3a 49 35			ld a, (.dmark+2)  
3542 32 6d ee			ld (debug_mark+2),a  
3545 18 03			jr .pastdmark  
3547 ..			.dmark: db "0=."  
354a f1			.pastdmark: pop af  
354b			endm  
# End of macro DMARK
354b						CALLMONITOR 
354b cd 6f ee			call debug_vector  
354e				endm  
# End of macro CALLMONITOR
354e					endif 
354e					FORTH_DSP 
354e cd 04 1e			call macro_forth_dsp 
3551				endm 
# End of macro FORTH_DSP
3551 7e					ld a,(hl)	; get type of value on TOS 
3552 fe 02				cp DS_TYPE_INUM  
3554 28 00				jr z, .tz_inum 
3556			 
3556				if FORTH_ENABLE_FLOATMATH 
3556					jr .tz_done 
3556			 
3556				endif 
3556					 
3556			 
3556			.tz_inum: 
3556					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3556 cd 3e 1e			call macro_dsp_valuehl 
3559				endm 
# End of macro FORTH_DSP_VALUEHL
3559			 
3559			;		push hl 
3559			 
3559					; destroy value TOS 
3559			 
3559					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3559 cd f6 1e			call macro_forth_dsp_pop 
355c				endm 
# End of macro FORTH_DSP_POP
355c			 
355c			;		pop hl 
355c			 
355c 3e 00				ld a,0 
355e			 
355e bd					cp l 
355f 20 08				jr nz, .tz_notzero 
3561			 
3561 bc					cp h 
3562			 
3562 20 05				jr nz, .tz_notzero 
3564			 
3564			 
3564 21 01 00				ld hl, FORTH_TRUE 
3567 18 03				jr .tz_done 
3569			 
3569 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
356c			 
356c					; push value back onto stack for another op etc 
356c			 
356c			.tz_done: 
356c cd 47 1c				call forth_push_numhl 
356f			 
356f					NEXTW 
356f c3 f4 1f			jp macro_next 
3572				endm 
# End of macro NEXTW
3572			.LESS: 
3572				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3572 2f				db WORD_SYS_CORE+27             
3573 db 35			dw .GT            
3575 02				db 1 + 1 
3576 .. 00			db "<",0              
3578				endm 
# End of macro CWHEAD
3578			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3578				; TODO add floating point number detection 
3578					if DEBUG_FORTH_WORDS_KEY 
3578						DMARK "LES" 
3578 f5				push af  
3579 3a 8d 35			ld a, (.dmark)  
357c 32 6b ee			ld (debug_mark),a  
357f 3a 8e 35			ld a, (.dmark+1)  
3582 32 6c ee			ld (debug_mark+1),a  
3585 3a 8f 35			ld a, (.dmark+2)  
3588 32 6d ee			ld (debug_mark+2),a  
358b 18 03			jr .pastdmark  
358d ..			.dmark: db "LES"  
3590 f1			.pastdmark: pop af  
3591			endm  
# End of macro DMARK
3591						CALLMONITOR 
3591 cd 6f ee			call debug_vector  
3594				endm  
# End of macro CALLMONITOR
3594					endif 
3594					FORTH_DSP 
3594 cd 04 1e			call macro_forth_dsp 
3597				endm 
# End of macro FORTH_DSP
3597					;v5 FORTH_DSP_VALUE 
3597 7e					ld a,(hl)	; get type of value on TOS 
3598 fe 02				cp DS_TYPE_INUM  
359a 28 00				jr z, .less_inum 
359c			 
359c				if FORTH_ENABLE_FLOATMATH 
359c					jr .less_done 
359c			 
359c				endif 
359c					 
359c			 
359c			.less_inum: 
359c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359c cd 3e 1e			call macro_dsp_valuehl 
359f				endm 
# End of macro FORTH_DSP_VALUEHL
359f			 
359f e5					push hl  ; u2 
35a0			 
35a0					; destroy value TOS 
35a0			 
35a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a0 cd f6 1e			call macro_forth_dsp_pop 
35a3				endm 
# End of macro FORTH_DSP_POP
35a3			 
35a3			 
35a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a3 cd 3e 1e			call macro_dsp_valuehl 
35a6				endm 
# End of macro FORTH_DSP_VALUEHL
35a6			 
35a6 e5					push hl    ; u1 
35a7			 
35a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a7 cd f6 1e			call macro_forth_dsp_pop 
35aa				endm 
# End of macro FORTH_DSP_POP
35aa			 
35aa			 
35aa b7			 or a      ;clear carry flag 
35ab 01 00 00		 ld bc, FORTH_FALSE 
35ae e1			  pop hl    ; u1 
35af d1			  pop de    ; u2 
35b0 ed 52		  sbc hl,de 
35b2 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35b4			 
35b4 01 01 00		 ld bc, FORTH_TRUE 
35b7			.lscont:  
35b7 c5					push bc 
35b8 e1					pop hl 
35b9			 
35b9					if DEBUG_FORTH_WORDS 
35b9						DMARK "LT1" 
35b9 f5				push af  
35ba 3a ce 35			ld a, (.dmark)  
35bd 32 6b ee			ld (debug_mark),a  
35c0 3a cf 35			ld a, (.dmark+1)  
35c3 32 6c ee			ld (debug_mark+1),a  
35c6 3a d0 35			ld a, (.dmark+2)  
35c9 32 6d ee			ld (debug_mark+2),a  
35cc 18 03			jr .pastdmark  
35ce ..			.dmark: db "LT1"  
35d1 f1			.pastdmark: pop af  
35d2			endm  
# End of macro DMARK
35d2						CALLMONITOR 
35d2 cd 6f ee			call debug_vector  
35d5				endm  
# End of macro CALLMONITOR
35d5					endif 
35d5 cd 47 1c				call forth_push_numhl 
35d8			 
35d8					NEXTW 
35d8 c3 f4 1f			jp macro_next 
35db				endm 
# End of macro NEXTW
35db			.GT: 
35db				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35db 30				db WORD_SYS_CORE+28             
35dc 44 36			dw .EQUAL            
35de 02				db 1 + 1 
35df .. 00			db ">",0              
35e1				endm 
# End of macro CWHEAD
35e1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35e1				; TODO add floating point number detection 
35e1					if DEBUG_FORTH_WORDS_KEY 
35e1						DMARK "GRT" 
35e1 f5				push af  
35e2 3a f6 35			ld a, (.dmark)  
35e5 32 6b ee			ld (debug_mark),a  
35e8 3a f7 35			ld a, (.dmark+1)  
35eb 32 6c ee			ld (debug_mark+1),a  
35ee 3a f8 35			ld a, (.dmark+2)  
35f1 32 6d ee			ld (debug_mark+2),a  
35f4 18 03			jr .pastdmark  
35f6 ..			.dmark: db "GRT"  
35f9 f1			.pastdmark: pop af  
35fa			endm  
# End of macro DMARK
35fa						CALLMONITOR 
35fa cd 6f ee			call debug_vector  
35fd				endm  
# End of macro CALLMONITOR
35fd					endif 
35fd					FORTH_DSP 
35fd cd 04 1e			call macro_forth_dsp 
3600				endm 
# End of macro FORTH_DSP
3600					;FORTH_DSP_VALUE 
3600 7e					ld a,(hl)	; get type of value on TOS 
3601 fe 02				cp DS_TYPE_INUM  
3603 28 00				jr z, .gt_inum 
3605			 
3605				if FORTH_ENABLE_FLOATMATH 
3605					jr .gt_done 
3605			 
3605				endif 
3605					 
3605			 
3605			.gt_inum: 
3605					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3605 cd 3e 1e			call macro_dsp_valuehl 
3608				endm 
# End of macro FORTH_DSP_VALUEHL
3608			 
3608 e5					push hl  ; u2 
3609			 
3609					; destroy value TOS 
3609			 
3609					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3609 cd f6 1e			call macro_forth_dsp_pop 
360c				endm 
# End of macro FORTH_DSP_POP
360c			 
360c			 
360c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360c cd 3e 1e			call macro_dsp_valuehl 
360f				endm 
# End of macro FORTH_DSP_VALUEHL
360f			 
360f e5					push hl    ; u1 
3610			 
3610					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3610 cd f6 1e			call macro_forth_dsp_pop 
3613				endm 
# End of macro FORTH_DSP_POP
3613			 
3613			 
3613 b7			 or a      ;clear carry flag 
3614 01 00 00		 ld bc, FORTH_FALSE 
3617 e1			  pop hl    ; u1 
3618 d1			  pop de    ; u2 
3619 ed 52		  sbc hl,de 
361b 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
361d			 
361d 01 01 00		 ld bc, FORTH_TRUE 
3620			.gtcont:  
3620 c5					push bc 
3621 e1					pop hl 
3622			 
3622					if DEBUG_FORTH_WORDS 
3622						DMARK "GT1" 
3622 f5				push af  
3623 3a 37 36			ld a, (.dmark)  
3626 32 6b ee			ld (debug_mark),a  
3629 3a 38 36			ld a, (.dmark+1)  
362c 32 6c ee			ld (debug_mark+1),a  
362f 3a 39 36			ld a, (.dmark+2)  
3632 32 6d ee			ld (debug_mark+2),a  
3635 18 03			jr .pastdmark  
3637 ..			.dmark: db "GT1"  
363a f1			.pastdmark: pop af  
363b			endm  
# End of macro DMARK
363b						CALLMONITOR 
363b cd 6f ee			call debug_vector  
363e				endm  
# End of macro CALLMONITOR
363e					endif 
363e cd 47 1c				call forth_push_numhl 
3641			 
3641					NEXTW 
3641 c3 f4 1f			jp macro_next 
3644				endm 
# End of macro NEXTW
3644			.EQUAL: 
3644				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3644 31				db WORD_SYS_CORE+29             
3645 af 36			dw .ENDLOGIC            
3647 02				db 1 + 1 
3648 .. 00			db "=",0              
364a				endm 
# End of macro CWHEAD
364a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
364a				; TODO add floating point number detection 
364a					if DEBUG_FORTH_WORDS_KEY 
364a						DMARK "EQ." 
364a f5				push af  
364b 3a 5f 36			ld a, (.dmark)  
364e 32 6b ee			ld (debug_mark),a  
3651 3a 60 36			ld a, (.dmark+1)  
3654 32 6c ee			ld (debug_mark+1),a  
3657 3a 61 36			ld a, (.dmark+2)  
365a 32 6d ee			ld (debug_mark+2),a  
365d 18 03			jr .pastdmark  
365f ..			.dmark: db "EQ."  
3662 f1			.pastdmark: pop af  
3663			endm  
# End of macro DMARK
3663						CALLMONITOR 
3663 cd 6f ee			call debug_vector  
3666				endm  
# End of macro CALLMONITOR
3666					endif 
3666					FORTH_DSP 
3666 cd 04 1e			call macro_forth_dsp 
3669				endm 
# End of macro FORTH_DSP
3669					;v5 FORTH_DSP_VALUE 
3669 7e					ld a,(hl)	; get type of value on TOS 
366a fe 02				cp DS_TYPE_INUM  
366c 28 00				jr z, .eq_inum 
366e			 
366e				if FORTH_ENABLE_FLOATMATH 
366e					jr .eq_done 
366e			 
366e				endif 
366e					 
366e			 
366e			.eq_inum: 
366e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366e cd 3e 1e			call macro_dsp_valuehl 
3671				endm 
# End of macro FORTH_DSP_VALUEHL
3671			 
3671 e5					push hl 
3672			 
3672					; destroy value TOS 
3672			 
3672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3672 cd f6 1e			call macro_forth_dsp_pop 
3675				endm 
# End of macro FORTH_DSP_POP
3675			 
3675			 
3675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3675 cd 3e 1e			call macro_dsp_valuehl 
3678				endm 
# End of macro FORTH_DSP_VALUEHL
3678			 
3678					; one value on hl get other one back 
3678			 
3678 e5					push hl 
3679			 
3679					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3679 cd f6 1e			call macro_forth_dsp_pop 
367c				endm 
# End of macro FORTH_DSP_POP
367c			 
367c 0e 00				ld c, FORTH_FALSE 
367e			 
367e e1					pop hl 
367f d1					pop de 
3680			 
3680 7b					ld a, e 
3681 bd					cp l 
3682			 
3682 20 06				jr nz, .eq_done 
3684			 
3684 7a					ld a, d 
3685 bc					cp h 
3686			 
3686 20 02				jr nz, .eq_done 
3688			 
3688 0e 01				ld c, FORTH_TRUE 
368a					 
368a			 
368a			 
368a			.eq_done: 
368a			 
368a					; TODO push value back onto stack for another op etc 
368a			 
368a 26 00				ld h, 0 
368c 69					ld l, c 
368d					if DEBUG_FORTH_WORDS 
368d						DMARK "EQ1" 
368d f5				push af  
368e 3a a2 36			ld a, (.dmark)  
3691 32 6b ee			ld (debug_mark),a  
3694 3a a3 36			ld a, (.dmark+1)  
3697 32 6c ee			ld (debug_mark+1),a  
369a 3a a4 36			ld a, (.dmark+2)  
369d 32 6d ee			ld (debug_mark+2),a  
36a0 18 03			jr .pastdmark  
36a2 ..			.dmark: db "EQ1"  
36a5 f1			.pastdmark: pop af  
36a6			endm  
# End of macro DMARK
36a6						CALLMONITOR 
36a6 cd 6f ee			call debug_vector  
36a9				endm  
# End of macro CALLMONITOR
36a9					endif 
36a9 cd 47 1c				call forth_push_numhl 
36ac			 
36ac					NEXTW 
36ac c3 f4 1f			jp macro_next 
36af				endm 
# End of macro NEXTW
36af			 
36af			 
36af			.ENDLOGIC: 
36af			; eof 
36af			 
36af			 
# End of file forth_words_logic.asm
36af			include "forth_words_maths.asm" 
36af			 
36af			; | ## Maths Words 
36af			 
36af			.PLUS:	 
36af				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36af 15				db WORD_SYS_CORE+1             
36b0 0d 37			dw .NEG            
36b2 02				db 1 + 1 
36b3 .. 00			db "+",0              
36b5				endm 
# End of macro CWHEAD
36b5			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36b5					if DEBUG_FORTH_WORDS_KEY 
36b5						DMARK "PLU" 
36b5 f5				push af  
36b6 3a ca 36			ld a, (.dmark)  
36b9 32 6b ee			ld (debug_mark),a  
36bc 3a cb 36			ld a, (.dmark+1)  
36bf 32 6c ee			ld (debug_mark+1),a  
36c2 3a cc 36			ld a, (.dmark+2)  
36c5 32 6d ee			ld (debug_mark+2),a  
36c8 18 03			jr .pastdmark  
36ca ..			.dmark: db "PLU"  
36cd f1			.pastdmark: pop af  
36ce			endm  
# End of macro DMARK
36ce						CALLMONITOR 
36ce cd 6f ee			call debug_vector  
36d1				endm  
# End of macro CALLMONITOR
36d1					endif 
36d1					; add top two values and push back result 
36d1			 
36d1					;for v5 FORTH_DSP_VALUE 
36d1					FORTH_DSP 
36d1 cd 04 1e			call macro_forth_dsp 
36d4				endm 
# End of macro FORTH_DSP
36d4 7e					ld a,(hl)	; get type of value on TOS 
36d5 fe 02				cp DS_TYPE_INUM  
36d7 28 03				jr z, .dot_inum 
36d9			 
36d9					NEXTW 
36d9 c3 f4 1f			jp macro_next 
36dc				endm 
# End of macro NEXTW
36dc			 
36dc			; float maths 
36dc			 
36dc				if FORTH_ENABLE_FLOATMATH 
36dc						inc hl      ; now at start of numeric as string 
36dc			 
36dc					if DEBUG_FORTH_MATHS 
36dc						DMARK "ADD" 
36dc				CALLMONITOR 
36dc					endif 
36dc			 
36dc					;ld ix, hl 
36dc					call CON 
36dc			 
36dc			 
36dc					push hl 
36dc					 
36dc					 
36dc			 
36dc						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36dc			 
36dc					; get next number 
36dc			 
36dc						FORTH_DSP_VALUE 
36dc			 
36dc						inc hl      ; now at start of numeric as string 
36dc			 
36dc					;ld ix, hl 
36dc					call CON 
36dc			 
36dc					push hl 
36dc			 
36dc			 
36dc						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36dc			 
36dc						; TODO do add 
36dc			 
36dc						call IADD 
36dc			 
36dc						; TODO get result back as ascii 
36dc			 
36dc						; TODO push result  
36dc			 
36dc			 
36dc			 
36dc						jr .dot_done 
36dc				endif 
36dc			 
36dc			.dot_inum: 
36dc			 
36dc			 
36dc					if DEBUG_FORTH_DOT 
36dc						DMARK "+IT" 
36dc f5				push af  
36dd 3a f1 36			ld a, (.dmark)  
36e0 32 6b ee			ld (debug_mark),a  
36e3 3a f2 36			ld a, (.dmark+1)  
36e6 32 6c ee			ld (debug_mark+1),a  
36e9 3a f3 36			ld a, (.dmark+2)  
36ec 32 6d ee			ld (debug_mark+2),a  
36ef 18 03			jr .pastdmark  
36f1 ..			.dmark: db "+IT"  
36f4 f1			.pastdmark: pop af  
36f5			endm  
# End of macro DMARK
36f5				CALLMONITOR 
36f5 cd 6f ee			call debug_vector  
36f8				endm  
# End of macro CALLMONITOR
36f8					endif 
36f8			 
36f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f8 cd 3e 1e			call macro_dsp_valuehl 
36fb				endm 
# End of macro FORTH_DSP_VALUEHL
36fb			 
36fb				; TODO add floating point number detection 
36fb			 
36fb e5					push hl 
36fc			 
36fc					; destroy value TOS 
36fc			 
36fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fc cd f6 1e			call macro_forth_dsp_pop 
36ff				endm 
# End of macro FORTH_DSP_POP
36ff			 
36ff			 
36ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ff cd 3e 1e			call macro_dsp_valuehl 
3702				endm 
# End of macro FORTH_DSP_VALUEHL
3702			 
3702					; one value on hl get other one back 
3702			 
3702 d1					pop de 
3703			 
3703					; do the add 
3703			 
3703 19					add hl,de 
3704			 
3704					; save it 
3704			 
3704			;		push hl	 
3704			 
3704					; 
3704			 
3704					; destroy value TOS 
3704			 
3704					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3704 cd f6 1e			call macro_forth_dsp_pop 
3707				endm 
# End of macro FORTH_DSP_POP
3707			 
3707					; TODO push value back onto stack for another op etc 
3707			 
3707			;		pop hl 
3707			 
3707			.dot_done: 
3707 cd 47 1c				call forth_push_numhl 
370a			 
370a					NEXTW 
370a c3 f4 1f			jp macro_next 
370d				endm 
# End of macro NEXTW
370d			.NEG: 
370d			 
370d				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
370d 17				db WORD_SYS_CORE+3             
370e 50 37			dw .DIV            
3710 02				db 1 + 1 
3711 .. 00			db "-",0              
3713				endm 
# End of macro CWHEAD
3713			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3713					if DEBUG_FORTH_WORDS_KEY 
3713						DMARK "SUB" 
3713 f5				push af  
3714 3a 28 37			ld a, (.dmark)  
3717 32 6b ee			ld (debug_mark),a  
371a 3a 29 37			ld a, (.dmark+1)  
371d 32 6c ee			ld (debug_mark+1),a  
3720 3a 2a 37			ld a, (.dmark+2)  
3723 32 6d ee			ld (debug_mark+2),a  
3726 18 03			jr .pastdmark  
3728 ..			.dmark: db "SUB"  
372b f1			.pastdmark: pop af  
372c			endm  
# End of macro DMARK
372c						CALLMONITOR 
372c cd 6f ee			call debug_vector  
372f				endm  
# End of macro CALLMONITOR
372f					endif 
372f			 
372f			 
372f				; TODO add floating point number detection 
372f					; v5 FORTH_DSP_VALUE 
372f					FORTH_DSP 
372f cd 04 1e			call macro_forth_dsp 
3732				endm 
# End of macro FORTH_DSP
3732 7e					ld a,(hl)	; get type of value on TOS 
3733 fe 02				cp DS_TYPE_INUM  
3735 28 03				jr z, .neg_inum 
3737			 
3737					NEXTW 
3737 c3 f4 1f			jp macro_next 
373a				endm 
# End of macro NEXTW
373a			 
373a			; float maths 
373a			 
373a				if FORTH_ENABLE_FLOATMATH 
373a					jr .neg_done 
373a			 
373a				endif 
373a					 
373a			 
373a			.neg_inum: 
373a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373a cd 3e 1e			call macro_dsp_valuehl 
373d				endm 
# End of macro FORTH_DSP_VALUEHL
373d			 
373d e5					push hl 
373e			 
373e					; destroy value TOS 
373e			 
373e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373e cd f6 1e			call macro_forth_dsp_pop 
3741				endm 
# End of macro FORTH_DSP_POP
3741			 
3741			 
3741					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3741 cd 3e 1e			call macro_dsp_valuehl 
3744				endm 
# End of macro FORTH_DSP_VALUEHL
3744			 
3744					; one value on hl get other one back 
3744			 
3744 d1					pop de 
3745			 
3745					; do the sub 
3745			;		ex de, hl 
3745			 
3745 ed 52				sbc hl,de 
3747			 
3747					; save it 
3747			 
3747			;		push hl	 
3747			 
3747					; 
3747			 
3747					; destroy value TOS 
3747			 
3747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3747 cd f6 1e			call macro_forth_dsp_pop 
374a				endm 
# End of macro FORTH_DSP_POP
374a			 
374a					; TODO push value back onto stack for another op etc 
374a			 
374a			;		pop hl 
374a			 
374a cd 47 1c				call forth_push_numhl 
374d			.neg_done: 
374d			 
374d					NEXTW 
374d c3 f4 1f			jp macro_next 
3750				endm 
# End of macro NEXTW
3750			.DIV: 
3750				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3750 18				db WORD_SYS_CORE+4             
3751 9d 37			dw .MUL            
3753 02				db 1 + 1 
3754 .. 00			db "/",0              
3756				endm 
# End of macro CWHEAD
3756			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3756					if DEBUG_FORTH_WORDS_KEY 
3756						DMARK "DIV" 
3756 f5				push af  
3757 3a 6b 37			ld a, (.dmark)  
375a 32 6b ee			ld (debug_mark),a  
375d 3a 6c 37			ld a, (.dmark+1)  
3760 32 6c ee			ld (debug_mark+1),a  
3763 3a 6d 37			ld a, (.dmark+2)  
3766 32 6d ee			ld (debug_mark+2),a  
3769 18 03			jr .pastdmark  
376b ..			.dmark: db "DIV"  
376e f1			.pastdmark: pop af  
376f			endm  
# End of macro DMARK
376f						CALLMONITOR 
376f cd 6f ee			call debug_vector  
3772				endm  
# End of macro CALLMONITOR
3772					endif 
3772				; TODO add floating point number detection 
3772					; v5 FORTH_DSP_VALUE 
3772					FORTH_DSP 
3772 cd 04 1e			call macro_forth_dsp 
3775				endm 
# End of macro FORTH_DSP
3775 7e					ld a,(hl)	; get type of value on TOS 
3776 fe 02				cp DS_TYPE_INUM  
3778 28 03				jr z, .div_inum 
377a			 
377a				if FORTH_ENABLE_FLOATMATH 
377a					jr .div_done 
377a			 
377a				endif 
377a					NEXTW 
377a c3 f4 1f			jp macro_next 
377d				endm 
# End of macro NEXTW
377d			.div_inum: 
377d			 
377d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377d cd 3e 1e			call macro_dsp_valuehl 
3780				endm 
# End of macro FORTH_DSP_VALUEHL
3780			 
3780 e5					push hl    ; to go to bc 
3781			 
3781					; destroy value TOS 
3781			 
3781					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3781 cd f6 1e			call macro_forth_dsp_pop 
3784				endm 
# End of macro FORTH_DSP_POP
3784			 
3784			 
3784					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3784 cd 3e 1e			call macro_dsp_valuehl 
3787				endm 
# End of macro FORTH_DSP_VALUEHL
3787			 
3787					; hl to go to de 
3787			 
3787 e5					push hl 
3788			 
3788 c1					pop bc 
3789 d1					pop de		 
378a			 
378a			 
378a					if DEBUG_FORTH_MATHS 
378a						DMARK "DIV" 
378a				CALLMONITOR 
378a					endif 
378a					; one value on hl but move to a get other one back 
378a			 
378a			        
378a cd 44 0d			call Div16 
378d			 
378d			;	push af	 
378d e5				push hl 
378e c5				push bc 
378f			 
378f					if DEBUG_FORTH_MATHS 
378f						DMARK "DI1" 
378f				CALLMONITOR 
378f					endif 
378f			 
378f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378f cd f6 1e			call macro_forth_dsp_pop 
3792				endm 
# End of macro FORTH_DSP_POP
3792			 
3792			 
3792			 
3792 e1					pop hl    ; result 
3793			 
3793 cd 47 1c				call forth_push_numhl 
3796			 
3796 e1					pop hl    ; reminder 
3797			;		ld h,0 
3797			;		ld l,d 
3797			 
3797 cd 47 1c				call forth_push_numhl 
379a			.div_done: 
379a					NEXTW 
379a c3 f4 1f			jp macro_next 
379d				endm 
# End of macro NEXTW
379d			.MUL: 
379d				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
379d 19				db WORD_SYS_CORE+5             
379e e2 37			dw .MIN            
37a0 02				db 1 + 1 
37a1 .. 00			db "*",0              
37a3				endm 
# End of macro CWHEAD
37a3			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37a3				; TODO add floating point number detection 
37a3					if DEBUG_FORTH_WORDS_KEY 
37a3						DMARK "MUL" 
37a3 f5				push af  
37a4 3a b8 37			ld a, (.dmark)  
37a7 32 6b ee			ld (debug_mark),a  
37aa 3a b9 37			ld a, (.dmark+1)  
37ad 32 6c ee			ld (debug_mark+1),a  
37b0 3a ba 37			ld a, (.dmark+2)  
37b3 32 6d ee			ld (debug_mark+2),a  
37b6 18 03			jr .pastdmark  
37b8 ..			.dmark: db "MUL"  
37bb f1			.pastdmark: pop af  
37bc			endm  
# End of macro DMARK
37bc						CALLMONITOR 
37bc cd 6f ee			call debug_vector  
37bf				endm  
# End of macro CALLMONITOR
37bf					endif 
37bf					FORTH_DSP 
37bf cd 04 1e			call macro_forth_dsp 
37c2				endm 
# End of macro FORTH_DSP
37c2					; v5 FORTH_DSP_VALUE 
37c2 7e					ld a,(hl)	; get type of value on TOS 
37c3 fe 02				cp DS_TYPE_INUM  
37c5 28 03				jr z, .mul_inum 
37c7			 
37c7				if FORTH_ENABLE_FLOATMATH 
37c7					jr .mul_done 
37c7			 
37c7				endif 
37c7			 
37c7					NEXTW 
37c7 c3 f4 1f			jp macro_next 
37ca				endm 
# End of macro NEXTW
37ca			.mul_inum:	 
37ca			 
37ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ca cd 3e 1e			call macro_dsp_valuehl 
37cd				endm 
# End of macro FORTH_DSP_VALUEHL
37cd			 
37cd e5					push hl 
37ce			 
37ce					; destroy value TOS 
37ce			 
37ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ce cd f6 1e			call macro_forth_dsp_pop 
37d1				endm 
# End of macro FORTH_DSP_POP
37d1			 
37d1			 
37d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d1 cd 3e 1e			call macro_dsp_valuehl 
37d4				endm 
# End of macro FORTH_DSP_VALUEHL
37d4			 
37d4					; one value on hl but move to a get other one back 
37d4			 
37d4 7d					ld a, l 
37d5			 
37d5 d1					pop de 
37d6			 
37d6					; do the mull 
37d6			;		ex de, hl 
37d6			 
37d6 cd 6a 0d				call Mult16 
37d9					; save it 
37d9			 
37d9			;		push hl	 
37d9			 
37d9					; 
37d9			 
37d9					; destroy value TOS 
37d9			 
37d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d9 cd f6 1e			call macro_forth_dsp_pop 
37dc				endm 
# End of macro FORTH_DSP_POP
37dc			 
37dc					; TODO push value back onto stack for another op etc 
37dc			 
37dc			;		pop hl 
37dc			 
37dc cd 47 1c				call forth_push_numhl 
37df			 
37df			.mul_done: 
37df					NEXTW 
37df c3 f4 1f			jp macro_next 
37e2				endm 
# End of macro NEXTW
37e2			 
37e2			 
37e2			 
37e2			 
37e2			.MIN: 
37e2				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37e2 49				db WORD_SYS_CORE+53             
37e3 63 38			dw .MAX            
37e5 04				db 3 + 1 
37e6 .. 00			db "MIN",0              
37ea				endm 
# End of macro CWHEAD
37ea			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37ea					if DEBUG_FORTH_WORDS_KEY 
37ea						DMARK "MIN" 
37ea f5				push af  
37eb 3a ff 37			ld a, (.dmark)  
37ee 32 6b ee			ld (debug_mark),a  
37f1 3a 00 38			ld a, (.dmark+1)  
37f4 32 6c ee			ld (debug_mark+1),a  
37f7 3a 01 38			ld a, (.dmark+2)  
37fa 32 6d ee			ld (debug_mark+2),a  
37fd 18 03			jr .pastdmark  
37ff ..			.dmark: db "MIN"  
3802 f1			.pastdmark: pop af  
3803			endm  
# End of macro DMARK
3803						CALLMONITOR 
3803 cd 6f ee			call debug_vector  
3806				endm  
# End of macro CALLMONITOR
3806					endif 
3806					; get u2 
3806			 
3806					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3806 cd 3e 1e			call macro_dsp_valuehl 
3809				endm 
# End of macro FORTH_DSP_VALUEHL
3809			 
3809 e5					push hl   ; u2 
380a			 
380a					; destroy value TOS 
380a			 
380a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380a cd f6 1e			call macro_forth_dsp_pop 
380d				endm 
# End of macro FORTH_DSP_POP
380d			 
380d					; get u1 
380d			 
380d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380d cd 3e 1e			call macro_dsp_valuehl 
3810				endm 
# End of macro FORTH_DSP_VALUEHL
3810			 
3810 e5					push hl  ; u1 
3811			 
3811					; destroy value TOS 
3811			 
3811					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3811 cd f6 1e			call macro_forth_dsp_pop 
3814				endm 
# End of macro FORTH_DSP_POP
3814			 
3814 b7			 or a      ;clear carry flag 
3815 e1			  pop hl    ; u1 
3816 d1			  pop de    ; u2 
3817 e5				push hl   ; saved in case hl is lowest 
3818 ed 52		  sbc hl,de 
381a 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
381c			 
381c e1				pop hl 
381d					if DEBUG_FORTH_WORDS 
381d						DMARK "MIN" 
381d f5				push af  
381e 3a 32 38			ld a, (.dmark)  
3821 32 6b ee			ld (debug_mark),a  
3824 3a 33 38			ld a, (.dmark+1)  
3827 32 6c ee			ld (debug_mark+1),a  
382a 3a 34 38			ld a, (.dmark+2)  
382d 32 6d ee			ld (debug_mark+2),a  
3830 18 03			jr .pastdmark  
3832 ..			.dmark: db "MIN"  
3835 f1			.pastdmark: pop af  
3836			endm  
# End of macro DMARK
3836						CALLMONITOR 
3836 cd 6f ee			call debug_vector  
3839				endm  
# End of macro CALLMONITOR
3839					endif 
3839 cd 47 1c				call forth_push_numhl 
383c			 
383c				       NEXTW 
383c c3 f4 1f			jp macro_next 
383f				endm 
# End of macro NEXTW
383f			 
383f			.mincont:  
383f c1				pop bc   ; tidy up 
3840 eb				ex de , hl  
3841					if DEBUG_FORTH_WORDS 
3841						DMARK "MI1" 
3841 f5				push af  
3842 3a 56 38			ld a, (.dmark)  
3845 32 6b ee			ld (debug_mark),a  
3848 3a 57 38			ld a, (.dmark+1)  
384b 32 6c ee			ld (debug_mark+1),a  
384e 3a 58 38			ld a, (.dmark+2)  
3851 32 6d ee			ld (debug_mark+2),a  
3854 18 03			jr .pastdmark  
3856 ..			.dmark: db "MI1"  
3859 f1			.pastdmark: pop af  
385a			endm  
# End of macro DMARK
385a						CALLMONITOR 
385a cd 6f ee			call debug_vector  
385d				endm  
# End of macro CALLMONITOR
385d					endif 
385d cd 47 1c				call forth_push_numhl 
3860			 
3860				       NEXTW 
3860 c3 f4 1f			jp macro_next 
3863				endm 
# End of macro NEXTW
3863			.MAX: 
3863				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3863 4a				db WORD_SYS_CORE+54             
3864 e4 38			dw .RND16            
3866 04				db 3 + 1 
3867 .. 00			db "MAX",0              
386b				endm 
# End of macro CWHEAD
386b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
386b					if DEBUG_FORTH_WORDS_KEY 
386b						DMARK "MAX" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 6b ee			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 6c ee			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 6d ee			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "MAX"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd 6f ee			call debug_vector  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887					; get u2 
3887			 
3887					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3887 cd 3e 1e			call macro_dsp_valuehl 
388a				endm 
# End of macro FORTH_DSP_VALUEHL
388a			 
388a e5					push hl   ; u2 
388b			 
388b					; destroy value TOS 
388b			 
388b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388b cd f6 1e			call macro_forth_dsp_pop 
388e				endm 
# End of macro FORTH_DSP_POP
388e			 
388e					; get u1 
388e			 
388e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388e cd 3e 1e			call macro_dsp_valuehl 
3891				endm 
# End of macro FORTH_DSP_VALUEHL
3891			 
3891 e5					push hl  ; u1 
3892			 
3892					; destroy value TOS 
3892			 
3892					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3892 cd f6 1e			call macro_forth_dsp_pop 
3895				endm 
# End of macro FORTH_DSP_POP
3895			 
3895 b7			 or a      ;clear carry flag 
3896 e1			  pop hl    ; u1 
3897 d1			  pop de    ; u2 
3898 e5				push hl   ; saved in case hl is lowest 
3899 ed 52		  sbc hl,de 
389b 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
389d			 
389d e1				pop hl 
389e					if DEBUG_FORTH_WORDS 
389e						DMARK "MAX" 
389e f5				push af  
389f 3a b3 38			ld a, (.dmark)  
38a2 32 6b ee			ld (debug_mark),a  
38a5 3a b4 38			ld a, (.dmark+1)  
38a8 32 6c ee			ld (debug_mark+1),a  
38ab 3a b5 38			ld a, (.dmark+2)  
38ae 32 6d ee			ld (debug_mark+2),a  
38b1 18 03			jr .pastdmark  
38b3 ..			.dmark: db "MAX"  
38b6 f1			.pastdmark: pop af  
38b7			endm  
# End of macro DMARK
38b7						CALLMONITOR 
38b7 cd 6f ee			call debug_vector  
38ba				endm  
# End of macro CALLMONITOR
38ba					endif 
38ba cd 47 1c				call forth_push_numhl 
38bd			 
38bd				       NEXTW 
38bd c3 f4 1f			jp macro_next 
38c0				endm 
# End of macro NEXTW
38c0			 
38c0			.maxcont:  
38c0 c1				pop bc   ; tidy up 
38c1 eb				ex de , hl  
38c2					if DEBUG_FORTH_WORDS 
38c2						DMARK "MA1" 
38c2 f5				push af  
38c3 3a d7 38			ld a, (.dmark)  
38c6 32 6b ee			ld (debug_mark),a  
38c9 3a d8 38			ld a, (.dmark+1)  
38cc 32 6c ee			ld (debug_mark+1),a  
38cf 3a d9 38			ld a, (.dmark+2)  
38d2 32 6d ee			ld (debug_mark+2),a  
38d5 18 03			jr .pastdmark  
38d7 ..			.dmark: db "MA1"  
38da f1			.pastdmark: pop af  
38db			endm  
# End of macro DMARK
38db						CALLMONITOR 
38db cd 6f ee			call debug_vector  
38de				endm  
# End of macro CALLMONITOR
38de					endif 
38de cd 47 1c				call forth_push_numhl 
38e1				       NEXTW 
38e1 c3 f4 1f			jp macro_next 
38e4				endm 
# End of macro NEXTW
38e4			 
38e4			.RND16: 
38e4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38e4 4e				db WORD_SYS_CORE+58             
38e5 13 39			dw .RND8            
38e7 06				db 5 + 1 
38e8 .. 00			db "RND16",0              
38ee				endm 
# End of macro CWHEAD
38ee			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38ee					if DEBUG_FORTH_WORDS_KEY 
38ee						DMARK "R16" 
38ee f5				push af  
38ef 3a 03 39			ld a, (.dmark)  
38f2 32 6b ee			ld (debug_mark),a  
38f5 3a 04 39			ld a, (.dmark+1)  
38f8 32 6c ee			ld (debug_mark+1),a  
38fb 3a 05 39			ld a, (.dmark+2)  
38fe 32 6d ee			ld (debug_mark+2),a  
3901 18 03			jr .pastdmark  
3903 ..			.dmark: db "R16"  
3906 f1			.pastdmark: pop af  
3907			endm  
# End of macro DMARK
3907						CALLMONITOR 
3907 cd 6f ee			call debug_vector  
390a				endm  
# End of macro CALLMONITOR
390a					endif 
390a cd 0e 0d				call prng16  
390d cd 47 1c				call forth_push_numhl 
3910				       NEXTW 
3910 c3 f4 1f			jp macro_next 
3913				endm 
# End of macro NEXTW
3913			.RND8: 
3913				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3913 60				db WORD_SYS_CORE+76             
3914 48 39			dw .RND            
3916 05				db 4 + 1 
3917 .. 00			db "RND8",0              
391c				endm 
# End of macro CWHEAD
391c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
391c					if DEBUG_FORTH_WORDS_KEY 
391c						DMARK "RN8" 
391c f5				push af  
391d 3a 31 39			ld a, (.dmark)  
3920 32 6b ee			ld (debug_mark),a  
3923 3a 32 39			ld a, (.dmark+1)  
3926 32 6c ee			ld (debug_mark+1),a  
3929 3a 33 39			ld a, (.dmark+2)  
392c 32 6d ee			ld (debug_mark+2),a  
392f 18 03			jr .pastdmark  
3931 ..			.dmark: db "RN8"  
3934 f1			.pastdmark: pop af  
3935			endm  
# End of macro DMARK
3935						CALLMONITOR 
3935 cd 6f ee			call debug_vector  
3938				endm  
# End of macro CALLMONITOR
3938					endif 
3938 2a a9 eb				ld hl,(xrandc) 
393b 23					inc hl 
393c cd 28 0d				call xrnd 
393f 6f					ld l,a	 
3940 26 00				ld h,0 
3942 cd 47 1c				call forth_push_numhl 
3945				       NEXTW 
3945 c3 f4 1f			jp macro_next 
3948				endm 
# End of macro NEXTW
3948			.RND: 
3948				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3948 60				db WORD_SYS_CORE+76             
3949 4e 3a			dw .ENDMATHS            
394b 04				db 3 + 1 
394c .. 00			db "RND",0              
3950				endm 
# End of macro CWHEAD
3950			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3950			 
3950					if DEBUG_FORTH_WORDS_KEY 
3950						DMARK "RND" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 6b ee			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 6c ee			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 6d ee			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "RND"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969						CALLMONITOR 
3969 cd 6f ee			call debug_vector  
396c				endm  
# End of macro CALLMONITOR
396c					endif 
396c					 
396c					FORTH_DSP_VALUEHL    ; upper range 
396c cd 3e 1e			call macro_dsp_valuehl 
396f				endm 
# End of macro FORTH_DSP_VALUEHL
396f			 
396f 22 ad eb				ld (LFSRSeed), hl	 
3972			 
3972					if DEBUG_FORTH_WORDS 
3972						DMARK "RN1" 
3972 f5				push af  
3973 3a 87 39			ld a, (.dmark)  
3976 32 6b ee			ld (debug_mark),a  
3979 3a 88 39			ld a, (.dmark+1)  
397c 32 6c ee			ld (debug_mark+1),a  
397f 3a 89 39			ld a, (.dmark+2)  
3982 32 6d ee			ld (debug_mark+2),a  
3985 18 03			jr .pastdmark  
3987 ..			.dmark: db "RN1"  
398a f1			.pastdmark: pop af  
398b			endm  
# End of macro DMARK
398b						CALLMONITOR 
398b cd 6f ee			call debug_vector  
398e				endm  
# End of macro CALLMONITOR
398e					endif 
398e					FORTH_DSP_POP 
398e cd f6 1e			call macro_forth_dsp_pop 
3991				endm 
# End of macro FORTH_DSP_POP
3991			 
3991					FORTH_DSP_VALUEHL    ; low range 
3991 cd 3e 1e			call macro_dsp_valuehl 
3994				endm 
# End of macro FORTH_DSP_VALUEHL
3994			 
3994					if DEBUG_FORTH_WORDS 
3994						DMARK "RN2" 
3994 f5				push af  
3995 3a a9 39			ld a, (.dmark)  
3998 32 6b ee			ld (debug_mark),a  
399b 3a aa 39			ld a, (.dmark+1)  
399e 32 6c ee			ld (debug_mark+1),a  
39a1 3a ab 39			ld a, (.dmark+2)  
39a4 32 6d ee			ld (debug_mark+2),a  
39a7 18 03			jr .pastdmark  
39a9 ..			.dmark: db "RN2"  
39ac f1			.pastdmark: pop af  
39ad			endm  
# End of macro DMARK
39ad						CALLMONITOR 
39ad cd 6f ee			call debug_vector  
39b0				endm  
# End of macro CALLMONITOR
39b0					endif 
39b0 22 af eb				ld (LFSRSeed+2), hl 
39b3			 
39b3					FORTH_DSP_POP 
39b3 cd f6 1e			call macro_forth_dsp_pop 
39b6				endm 
# End of macro FORTH_DSP_POP
39b6			 
39b6 e5					push hl 
39b7			 
39b7 e1			.inrange:	pop hl 
39b8 cd 0e 0d				call prng16  
39bb					if DEBUG_FORTH_WORDS 
39bb						DMARK "RN3" 
39bb f5				push af  
39bc 3a d0 39			ld a, (.dmark)  
39bf 32 6b ee			ld (debug_mark),a  
39c2 3a d1 39			ld a, (.dmark+1)  
39c5 32 6c ee			ld (debug_mark+1),a  
39c8 3a d2 39			ld a, (.dmark+2)  
39cb 32 6d ee			ld (debug_mark+2),a  
39ce 18 03			jr .pastdmark  
39d0 ..			.dmark: db "RN3"  
39d3 f1			.pastdmark: pop af  
39d4			endm  
# End of macro DMARK
39d4						CALLMONITOR 
39d4 cd 6f ee			call debug_vector  
39d7				endm  
# End of macro CALLMONITOR
39d7					endif 
39d7					 
39d7					; if the range is 8bit knock out the high byte 
39d7			 
39d7 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
39db			 
39db 3e 00				ld a, 0 
39dd ba					cp d  
39de 20 1e				jr nz, .hirange 
39e0 26 00				ld h, 0   ; knock it down to 8bit 
39e2			 
39e2					if DEBUG_FORTH_WORDS 
39e2						DMARK "RNk" 
39e2 f5				push af  
39e3 3a f7 39			ld a, (.dmark)  
39e6 32 6b ee			ld (debug_mark),a  
39e9 3a f8 39			ld a, (.dmark+1)  
39ec 32 6c ee			ld (debug_mark+1),a  
39ef 3a f9 39			ld a, (.dmark+2)  
39f2 32 6d ee			ld (debug_mark+2),a  
39f5 18 03			jr .pastdmark  
39f7 ..			.dmark: db "RNk"  
39fa f1			.pastdmark: pop af  
39fb			endm  
# End of macro DMARK
39fb						CALLMONITOR 
39fb cd 6f ee			call debug_vector  
39fe				endm  
# End of macro CALLMONITOR
39fe					endif 
39fe			.hirange:   
39fe e5					push hl  
39ff b7					or a  
3a00 ed 52		                sbc hl, de 
3a02			 
3a02					;call cmp16 
3a02			 
3a02 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a04 e1					pop hl 
3a05 e5					push hl 
3a06			 
3a06					if DEBUG_FORTH_WORDS 
3a06						DMARK "RN4" 
3a06 f5				push af  
3a07 3a 1b 3a			ld a, (.dmark)  
3a0a 32 6b ee			ld (debug_mark),a  
3a0d 3a 1c 3a			ld a, (.dmark+1)  
3a10 32 6c ee			ld (debug_mark+1),a  
3a13 3a 1d 3a			ld a, (.dmark+2)  
3a16 32 6d ee			ld (debug_mark+2),a  
3a19 18 03			jr .pastdmark  
3a1b ..			.dmark: db "RN4"  
3a1e f1			.pastdmark: pop af  
3a1f			endm  
# End of macro DMARK
3a1f						CALLMONITOR 
3a1f cd 6f ee			call debug_vector  
3a22				endm  
# End of macro CALLMONITOR
3a22					endif 
3a22 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a26					;call cmp16 
3a26				 
3a26 b7					or a  
3a27 ed 52		                sbc hl, de 
3a29 38 8c				jr c, .inrange 
3a2b			 
3a2b e1					pop hl 
3a2c					 
3a2c					if DEBUG_FORTH_WORDS 
3a2c						DMARK "RNd" 
3a2c f5				push af  
3a2d 3a 41 3a			ld a, (.dmark)  
3a30 32 6b ee			ld (debug_mark),a  
3a33 3a 42 3a			ld a, (.dmark+1)  
3a36 32 6c ee			ld (debug_mark+1),a  
3a39 3a 43 3a			ld a, (.dmark+2)  
3a3c 32 6d ee			ld (debug_mark+2),a  
3a3f 18 03			jr .pastdmark  
3a41 ..			.dmark: db "RNd"  
3a44 f1			.pastdmark: pop af  
3a45			endm  
# End of macro DMARK
3a45						CALLMONITOR 
3a45 cd 6f ee			call debug_vector  
3a48				endm  
# End of macro CALLMONITOR
3a48					endif 
3a48			 
3a48			 
3a48 cd 47 1c				call forth_push_numhl 
3a4b				       NEXTW 
3a4b c3 f4 1f			jp macro_next 
3a4e				endm 
# End of macro NEXTW
3a4e			 
3a4e			.ENDMATHS: 
3a4e			 
3a4e			; eof 
3a4e			 
# End of file forth_words_maths.asm
3a4e			include "forth_words_display.asm" 
3a4e			 
3a4e			; | ## Display Words 
3a4e			 
3a4e			.ACT: 
3a4e			 
3a4e				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a4e 62				db WORD_SYS_CORE+78             
3a4f 9a 3a			dw .INFO            
3a51 07				db 6 + 1 
3a52 .. 00			db "ACTIVE",0              
3a59				endm 
# End of macro CWHEAD
3a59			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a59			;  
3a59			; | | e.g. $ff $00 do active . $01 pause loop 
3a59			 
3a59					if DEBUG_FORTH_WORDS_KEY 
3a59						DMARK "ACT" 
3a59 f5				push af  
3a5a 3a 6e 3a			ld a, (.dmark)  
3a5d 32 6b ee			ld (debug_mark),a  
3a60 3a 6f 3a			ld a, (.dmark+1)  
3a63 32 6c ee			ld (debug_mark+1),a  
3a66 3a 70 3a			ld a, (.dmark+2)  
3a69 32 6d ee			ld (debug_mark+2),a  
3a6c 18 03			jr .pastdmark  
3a6e ..			.dmark: db "ACT"  
3a71 f1			.pastdmark: pop af  
3a72			endm  
# End of macro DMARK
3a72						CALLMONITOR 
3a72 cd 6f ee			call debug_vector  
3a75				endm  
# End of macro CALLMONITOR
3a75					endif 
3a75 cd 11 0b				call active 
3a78					if DEBUG_FORTH_WORDS 
3a78						DMARK "ACp" 
3a78 f5				push af  
3a79 3a 8d 3a			ld a, (.dmark)  
3a7c 32 6b ee			ld (debug_mark),a  
3a7f 3a 8e 3a			ld a, (.dmark+1)  
3a82 32 6c ee			ld (debug_mark+1),a  
3a85 3a 8f 3a			ld a, (.dmark+2)  
3a88 32 6d ee			ld (debug_mark+2),a  
3a8b 18 03			jr .pastdmark  
3a8d ..			.dmark: db "ACp"  
3a90 f1			.pastdmark: pop af  
3a91			endm  
# End of macro DMARK
3a91						CALLMONITOR 
3a91 cd 6f ee			call debug_vector  
3a94				endm  
# End of macro CALLMONITOR
3a94					endif 
3a94 cd b5 1c				call forth_push_str 
3a97			 
3a97					NEXTW 
3a97 c3 f4 1f			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			.INFO: 
3a9a			 
3a9a				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a9a 62				db WORD_SYS_CORE+78             
3a9b b7 3a			dw .ATP            
3a9d 05				db 4 + 1 
3a9e .. 00			db "INFO",0              
3aa3				endm 
# End of macro CWHEAD
3aa3			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3aa3					FORTH_DSP_VALUEHL 
3aa3 cd 3e 1e			call macro_dsp_valuehl 
3aa6				endm 
# End of macro FORTH_DSP_VALUEHL
3aa6			 
3aa6					FORTH_DSP_POP 
3aa6 cd f6 1e			call macro_forth_dsp_pop 
3aa9				endm 
# End of macro FORTH_DSP_POP
3aa9			 
3aa9 e5					push hl 
3aaa			 
3aaa					FORTH_DSP_VALUEHL 
3aaa cd 3e 1e			call macro_dsp_valuehl 
3aad				endm 
# End of macro FORTH_DSP_VALUEHL
3aad			 
3aad					FORTH_DSP_POP 
3aad cd f6 1e			call macro_forth_dsp_pop 
3ab0				endm 
# End of macro FORTH_DSP_POP
3ab0			 
3ab0 d1					pop de 
3ab1			 
3ab1 cd 4b 0b				call info_panel 
3ab4			 
3ab4			 
3ab4					NEXTW 
3ab4 c3 f4 1f			jp macro_next 
3ab7				endm 
# End of macro NEXTW
3ab7			.ATP: 
3ab7				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ab7 62				db WORD_SYS_CORE+78             
3ab8 2e 3b			dw .FB            
3aba 04				db 3 + 1 
3abb .. 00			db "AT?",0              
3abf				endm 
# End of macro CWHEAD
3abf			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3abf					if DEBUG_FORTH_WORDS_KEY 
3abf						DMARK "AT?" 
3abf f5				push af  
3ac0 3a d4 3a			ld a, (.dmark)  
3ac3 32 6b ee			ld (debug_mark),a  
3ac6 3a d5 3a			ld a, (.dmark+1)  
3ac9 32 6c ee			ld (debug_mark+1),a  
3acc 3a d6 3a			ld a, (.dmark+2)  
3acf 32 6d ee			ld (debug_mark+2),a  
3ad2 18 03			jr .pastdmark  
3ad4 ..			.dmark: db "AT?"  
3ad7 f1			.pastdmark: pop af  
3ad8			endm  
# End of macro DMARK
3ad8						CALLMONITOR 
3ad8 cd 6f ee			call debug_vector  
3adb				endm  
# End of macro CALLMONITOR
3adb					endif 
3adb 3a 5e ea				ld a, (f_cursor_ptr) 
3ade			 
3ade			if DEBUG_FORTH_WORDS 
3ade				DMARK "AT?" 
3ade f5				push af  
3adf 3a f3 3a			ld a, (.dmark)  
3ae2 32 6b ee			ld (debug_mark),a  
3ae5 3a f4 3a			ld a, (.dmark+1)  
3ae8 32 6c ee			ld (debug_mark+1),a  
3aeb 3a f5 3a			ld a, (.dmark+2)  
3aee 32 6d ee			ld (debug_mark+2),a  
3af1 18 03			jr .pastdmark  
3af3 ..			.dmark: db "AT?"  
3af6 f1			.pastdmark: pop af  
3af7			endm  
# End of macro DMARK
3af7				CALLMONITOR 
3af7 cd 6f ee			call debug_vector  
3afa				endm  
# End of macro CALLMONITOR
3afa			endif	 
3afa					; count the number of rows 
3afa			 
3afa 06 00				ld b, 0 
3afc 4f			.atpr:		ld c, a    ; save in case we go below zero 
3afd d6 28				sub display_cols 
3aff f2 05 3b				jp p, .atprunder 
3b02 04					inc b 
3b03 18 f7				jr .atpr 
3b05			.atprunder:	 
3b05			if DEBUG_FORTH_WORDS 
3b05				DMARK "A?2" 
3b05 f5				push af  
3b06 3a 1a 3b			ld a, (.dmark)  
3b09 32 6b ee			ld (debug_mark),a  
3b0c 3a 1b 3b			ld a, (.dmark+1)  
3b0f 32 6c ee			ld (debug_mark+1),a  
3b12 3a 1c 3b			ld a, (.dmark+2)  
3b15 32 6d ee			ld (debug_mark+2),a  
3b18 18 03			jr .pastdmark  
3b1a ..			.dmark: db "A?2"  
3b1d f1			.pastdmark: pop af  
3b1e			endm  
# End of macro DMARK
3b1e				CALLMONITOR 
3b1e cd 6f ee			call debug_vector  
3b21				endm  
# End of macro CALLMONITOR
3b21			endif	 
3b21 26 00				ld h, 0 
3b23 69					ld l, c 
3b24 cd 47 1c				call forth_push_numhl 
3b27 68					ld l, b  
3b28 cd 47 1c				call forth_push_numhl 
3b2b			 
3b2b			 
3b2b				NEXTW 
3b2b c3 f4 1f			jp macro_next 
3b2e				endm 
# End of macro NEXTW
3b2e			 
3b2e			.FB: 
3b2e				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b2e 1b				db WORD_SYS_CORE+7             
3b2f 7c 3b			dw .EMIT            
3b31 03				db 2 + 1 
3b32 .. 00			db "FB",0              
3b35				endm 
# End of macro CWHEAD
3b35			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b35			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b35			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b35			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b35					if DEBUG_FORTH_WORDS_KEY 
3b35						DMARK "FB." 
3b35 f5				push af  
3b36 3a 4a 3b			ld a, (.dmark)  
3b39 32 6b ee			ld (debug_mark),a  
3b3c 3a 4b 3b			ld a, (.dmark+1)  
3b3f 32 6c ee			ld (debug_mark+1),a  
3b42 3a 4c 3b			ld a, (.dmark+2)  
3b45 32 6d ee			ld (debug_mark+2),a  
3b48 18 03			jr .pastdmark  
3b4a ..			.dmark: db "FB."  
3b4d f1			.pastdmark: pop af  
3b4e			endm  
# End of macro DMARK
3b4e						CALLMONITOR 
3b4e cd 6f ee			call debug_vector  
3b51				endm  
# End of macro CALLMONITOR
3b51					endif 
3b51			 
3b51					FORTH_DSP_VALUEHL 
3b51 cd 3e 1e			call macro_dsp_valuehl 
3b54				endm 
# End of macro FORTH_DSP_VALUEHL
3b54			 
3b54 7d					ld a, l 
3b55 fe 01				cp 1 
3b57 20 05				jr nz, .fbn1 
3b59 21 10 ed				ld hl, display_fb1 
3b5c 18 15				jr .fbset 
3b5e fe 02		.fbn1:		cp 2 
3b60 20 05				jr nz, .fbn2 
3b62 21 ce eb				ld hl, display_fb2 
3b65 18 0c				jr .fbset 
3b67 fe 03		.fbn2:		cp 3 
3b69 20 05				jr nz, .fbn3 
3b6b 21 6f ec				ld hl, display_fb3 
3b6e 18 03				jr .fbset 
3b70			.fbn3:		 ; if invalid number select first 
3b70 21 10 ed				ld hl, display_fb1 
3b73 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b76			 
3b76					FORTH_DSP_POP 
3b76 cd f6 1e			call macro_forth_dsp_pop 
3b79				endm 
# End of macro FORTH_DSP_POP
3b79			 
3b79					NEXTW 
3b79 c3 f4 1f			jp macro_next 
3b7c				endm 
# End of macro NEXTW
3b7c			 
3b7c			 
3b7c			.EMIT: 
3b7c				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b7c 1b				db WORD_SYS_CORE+7             
3b7d cd 3b			dw .DOTH            
3b7f 05				db 4 + 1 
3b80 .. 00			db "EMIT",0              
3b85				endm 
# End of macro CWHEAD
3b85			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b85					; get value off TOS and display it 
3b85			 
3b85					if DEBUG_FORTH_WORDS_KEY 
3b85						DMARK "EMT" 
3b85 f5				push af  
3b86 3a 9a 3b			ld a, (.dmark)  
3b89 32 6b ee			ld (debug_mark),a  
3b8c 3a 9b 3b			ld a, (.dmark+1)  
3b8f 32 6c ee			ld (debug_mark+1),a  
3b92 3a 9c 3b			ld a, (.dmark+2)  
3b95 32 6d ee			ld (debug_mark+2),a  
3b98 18 03			jr .pastdmark  
3b9a ..			.dmark: db "EMT"  
3b9d f1			.pastdmark: pop af  
3b9e			endm  
# End of macro DMARK
3b9e						CALLMONITOR 
3b9e cd 6f ee			call debug_vector  
3ba1				endm  
# End of macro CALLMONITOR
3ba1					endif 
3ba1			 
3ba1					FORTH_DSP_VALUEHL 
3ba1 cd 3e 1e			call macro_dsp_valuehl 
3ba4				endm 
# End of macro FORTH_DSP_VALUEHL
3ba4			 
3ba4 7d					ld a,l 
3ba5			 
3ba5					; TODO write to display 
3ba5			 
3ba5 32 bf e4				ld (os_input), a 
3ba8 3e 00				ld a, 0 
3baa 32 c0 e4				ld (os_input+1), a 
3bad					 
3bad 3a 5e ea				ld a, (f_cursor_ptr) 
3bb0 11 bf e4				ld de, os_input 
3bb3 cd cd 0b				call str_at_display 
3bb6			 
3bb6			 
3bb6 3a 3c ea				ld a,(cli_autodisplay) 
3bb9 fe 00				cp 0 
3bbb 28 03				jr z, .enoupdate 
3bbd cd dd 0b						call update_display 
3bc0					.enoupdate: 
3bc0			 
3bc0 3a 5e ea				ld a, (f_cursor_ptr) 
3bc3 3c					inc a 
3bc4 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3bc7			 
3bc7			 
3bc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc7 cd f6 1e			call macro_forth_dsp_pop 
3bca				endm 
# End of macro FORTH_DSP_POP
3bca			  
3bca			 
3bca					NEXTW 
3bca c3 f4 1f			jp macro_next 
3bcd				endm 
# End of macro NEXTW
3bcd			.DOTH: 
3bcd				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bcd 1c				db WORD_SYS_CORE+8             
3bce fd 3b			dw .DOTF            
3bd0 03				db 2 + 1 
3bd1 .. 00			db ".-",0              
3bd4				endm 
# End of macro CWHEAD
3bd4			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bd4					; get value off TOS and display it 
3bd4					if DEBUG_FORTH_WORDS_KEY 
3bd4						DMARK "DTD" 
3bd4 f5				push af  
3bd5 3a e9 3b			ld a, (.dmark)  
3bd8 32 6b ee			ld (debug_mark),a  
3bdb 3a ea 3b			ld a, (.dmark+1)  
3bde 32 6c ee			ld (debug_mark+1),a  
3be1 3a eb 3b			ld a, (.dmark+2)  
3be4 32 6d ee			ld (debug_mark+2),a  
3be7 18 03			jr .pastdmark  
3be9 ..			.dmark: db "DTD"  
3bec f1			.pastdmark: pop af  
3bed			endm  
# End of macro DMARK
3bed						CALLMONITOR 
3bed cd 6f ee			call debug_vector  
3bf0				endm  
# End of macro CALLMONITOR
3bf0					endif 
3bf0 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bf2 3e 00			ld a, 0 
3bf4 32 3d ea			ld (cli_mvdot), a 
3bf7 c3 54 3c			jp .dotgo 
3bfa				NEXTW 
3bfa c3 f4 1f			jp macro_next 
3bfd				endm 
# End of macro NEXTW
3bfd			.DOTF: 
3bfd				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bfd 1c				db WORD_SYS_CORE+8             
3bfe 2b 3c			dw .DOT            
3c00 03				db 2 + 1 
3c01 .. 00			db ".>",0              
3c04				endm 
# End of macro CWHEAD
3c04			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c04					; get value off TOS and display it 
3c04			        ; TODO BUG adds extra spaces 
3c04			        ; TODO BUG handle numerics? 
3c04					if DEBUG_FORTH_WORDS_KEY 
3c04						DMARK "DTC" 
3c04 f5				push af  
3c05 3a 19 3c			ld a, (.dmark)  
3c08 32 6b ee			ld (debug_mark),a  
3c0b 3a 1a 3c			ld a, (.dmark+1)  
3c0e 32 6c ee			ld (debug_mark+1),a  
3c11 3a 1b 3c			ld a, (.dmark+2)  
3c14 32 6d ee			ld (debug_mark+2),a  
3c17 18 03			jr .pastdmark  
3c19 ..			.dmark: db "DTC"  
3c1c f1			.pastdmark: pop af  
3c1d			endm  
# End of macro DMARK
3c1d						CALLMONITOR 
3c1d cd 6f ee			call debug_vector  
3c20				endm  
# End of macro CALLMONITOR
3c20					endif 
3c20 3e 01			ld a, 1 
3c22 32 3d ea			ld (cli_mvdot), a 
3c25 c3 54 3c			jp .dotgo 
3c28				NEXTW 
3c28 c3 f4 1f			jp macro_next 
3c2b				endm 
# End of macro NEXTW
3c2b			 
3c2b			.DOT: 
3c2b				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c2b 1c				db WORD_SYS_CORE+8             
3c2c 07 3e			dw .CLS            
3c2e 02				db 1 + 1 
3c2f .. 00			db ".",0              
3c31				endm 
# End of macro CWHEAD
3c31			        ; | . ( u -- ) Display TOS | DONE 
3c31					; get value off TOS and display it 
3c31			 
3c31					if DEBUG_FORTH_WORDS_KEY 
3c31						DMARK "DOT" 
3c31 f5				push af  
3c32 3a 46 3c			ld a, (.dmark)  
3c35 32 6b ee			ld (debug_mark),a  
3c38 3a 47 3c			ld a, (.dmark+1)  
3c3b 32 6c ee			ld (debug_mark+1),a  
3c3e 3a 48 3c			ld a, (.dmark+2)  
3c41 32 6d ee			ld (debug_mark+2),a  
3c44 18 03			jr .pastdmark  
3c46 ..			.dmark: db "DOT"  
3c49 f1			.pastdmark: pop af  
3c4a			endm  
# End of macro DMARK
3c4a						CALLMONITOR 
3c4a cd 6f ee			call debug_vector  
3c4d				endm  
# End of macro CALLMONITOR
3c4d					endif 
3c4d 3e 00			ld a, 0 
3c4f 32 3d ea			ld (cli_mvdot), a 
3c52 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c54				 
3c54			 
3c54			.dotgo: 
3c54			 
3c54			; move up type to on stack for parserv5 
3c54					FORTH_DSP 
3c54 cd 04 1e			call macro_forth_dsp 
3c57				endm 
# End of macro FORTH_DSP
3c57				;FORTH_DSP_VALUE  
3c57			 
3c57			if DEBUG_FORTH_DOT 
3c57				DMARK "DOT" 
3c57 f5				push af  
3c58 3a 6c 3c			ld a, (.dmark)  
3c5b 32 6b ee			ld (debug_mark),a  
3c5e 3a 6d 3c			ld a, (.dmark+1)  
3c61 32 6c ee			ld (debug_mark+1),a  
3c64 3a 6e 3c			ld a, (.dmark+2)  
3c67 32 6d ee			ld (debug_mark+2),a  
3c6a 18 03			jr .pastdmark  
3c6c ..			.dmark: db "DOT"  
3c6f f1			.pastdmark: pop af  
3c70			endm  
# End of macro DMARK
3c70				CALLMONITOR 
3c70 cd 6f ee			call debug_vector  
3c73				endm  
# End of macro CALLMONITOR
3c73			endif	 
3c73			;		.print: 
3c73			 
3c73 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c74 23				inc hl   ; position to the actual value 
3c75 fe 01			cp DS_TYPE_STR 
3c77 20 06			jr nz, .dotnum1  
3c79			 
3c79			; display string 
3c79				FORTH_DSP_VALUE  
3c79 cd 27 1e			call macro_forth_dsp_value 
3c7c				endm 
# End of macro FORTH_DSP_VALUE
3c7c eb				ex de,hl 
3c7d 18 49			jr .dotwrite 
3c7f			 
3c7f			.dotnum1: 
3c7f fe 02			cp DS_TYPE_INUM 
3c81 20 44			jr nz, .dotflot 
3c83			 
3c83			 
3c83			; display number 
3c83			 
3c83			;	push hl 
3c83			;	call clear_display 
3c83			;	pop hl 
3c83			 
3c83 5e				ld e, (hl) 
3c84 23				inc hl 
3c85 56				ld d, (hl) 
3c86 21 c1 e2			ld hl, scratch 
3c89			if DEBUG_FORTH_DOT 
3c89				DMARK "DT1" 
3c89 f5				push af  
3c8a 3a 9e 3c			ld a, (.dmark)  
3c8d 32 6b ee			ld (debug_mark),a  
3c90 3a 9f 3c			ld a, (.dmark+1)  
3c93 32 6c ee			ld (debug_mark+1),a  
3c96 3a a0 3c			ld a, (.dmark+2)  
3c99 32 6d ee			ld (debug_mark+2),a  
3c9c 18 03			jr .pastdmark  
3c9e ..			.dmark: db "DT1"  
3ca1 f1			.pastdmark: pop af  
3ca2			endm  
# End of macro DMARK
3ca2				CALLMONITOR 
3ca2 cd 6f ee			call debug_vector  
3ca5				endm  
# End of macro CALLMONITOR
3ca5			endif	 
3ca5			 
3ca5 cd f4 11			call uitoa_16 
3ca8 eb				ex de,hl 
3ca9			 
3ca9			if DEBUG_FORTH_DOT 
3ca9				DMARK "DT2" 
3ca9 f5				push af  
3caa 3a be 3c			ld a, (.dmark)  
3cad 32 6b ee			ld (debug_mark),a  
3cb0 3a bf 3c			ld a, (.dmark+1)  
3cb3 32 6c ee			ld (debug_mark+1),a  
3cb6 3a c0 3c			ld a, (.dmark+2)  
3cb9 32 6d ee			ld (debug_mark+2),a  
3cbc 18 03			jr .pastdmark  
3cbe ..			.dmark: db "DT2"  
3cc1 f1			.pastdmark: pop af  
3cc2			endm  
# End of macro DMARK
3cc2				CALLMONITOR 
3cc2 cd 6f ee			call debug_vector  
3cc5				endm  
# End of macro CALLMONITOR
3cc5			endif	 
3cc5			 
3cc5			;	ld de, os_word_scratch 
3cc5 18 01			jr .dotwrite 
3cc7			 
3cc7 00			.dotflot:   nop 
3cc8			; TODO print floating point number 
3cc8			 
3cc8			.dotwrite:		 
3cc8			 
3cc8					; if c is set then set all '-' to spaces 
3cc8					; need to also take into account .>  
3cc8			 
3cc8 3e 01				ld a, 1 
3cca b9					cp c 
3ccb 20 67				jr nz, .nodashswap 
3ccd			 
3ccd					; DE has the string to write, working with HL 
3ccd			 
3ccd 06 ff				ld b, 255 
3ccf d5					push de 
3cd0 e1					pop hl 
3cd1			 
3cd1			if DEBUG_FORTH_DOT 
3cd1				DMARK "DT-" 
3cd1 f5				push af  
3cd2 3a e6 3c			ld a, (.dmark)  
3cd5 32 6b ee			ld (debug_mark),a  
3cd8 3a e7 3c			ld a, (.dmark+1)  
3cdb 32 6c ee			ld (debug_mark+1),a  
3cde 3a e8 3c			ld a, (.dmark+2)  
3ce1 32 6d ee			ld (debug_mark+2),a  
3ce4 18 03			jr .pastdmark  
3ce6 ..			.dmark: db "DT-"  
3ce9 f1			.pastdmark: pop af  
3cea			endm  
# End of macro DMARK
3cea				CALLMONITOR 
3cea cd 6f ee			call debug_vector  
3ced				endm  
# End of macro CALLMONITOR
3ced			endif	 
3ced 7e			.dashscan:	ld a, (hl) 
3cee fe 00				cp 0 
3cf0 28 42				jr z, .nodashswap 
3cf2 fe 2d				cp '-' 
3cf4 20 03				jr nz, .dashskip 
3cf6 3e 20				ld a, ' ' 
3cf8 77					ld (hl), a 
3cf9 23			.dashskip:	inc hl 
3cfa			if DEBUG_FORTH_DOT 
3cfa				DMARK "D-2" 
3cfa f5				push af  
3cfb 3a 0f 3d			ld a, (.dmark)  
3cfe 32 6b ee			ld (debug_mark),a  
3d01 3a 10 3d			ld a, (.dmark+1)  
3d04 32 6c ee			ld (debug_mark+1),a  
3d07 3a 11 3d			ld a, (.dmark+2)  
3d0a 32 6d ee			ld (debug_mark+2),a  
3d0d 18 03			jr .pastdmark  
3d0f ..			.dmark: db "D-2"  
3d12 f1			.pastdmark: pop af  
3d13			endm  
# End of macro DMARK
3d13				CALLMONITOR 
3d13 cd 6f ee			call debug_vector  
3d16				endm  
# End of macro CALLMONITOR
3d16			endif	 
3d16 10 d5				djnz .dashscan 
3d18			 
3d18			if DEBUG_FORTH_DOT 
3d18				DMARK "D-1" 
3d18 f5				push af  
3d19 3a 2d 3d			ld a, (.dmark)  
3d1c 32 6b ee			ld (debug_mark),a  
3d1f 3a 2e 3d			ld a, (.dmark+1)  
3d22 32 6c ee			ld (debug_mark+1),a  
3d25 3a 2f 3d			ld a, (.dmark+2)  
3d28 32 6d ee			ld (debug_mark+2),a  
3d2b 18 03			jr .pastdmark  
3d2d ..			.dmark: db "D-1"  
3d30 f1			.pastdmark: pop af  
3d31			endm  
# End of macro DMARK
3d31				CALLMONITOR 
3d31 cd 6f ee			call debug_vector  
3d34				endm  
# End of macro CALLMONITOR
3d34			endif	 
3d34			 
3d34			.nodashswap: 
3d34			 
3d34			if DEBUG_FORTH_DOT 
3d34				DMARK "D-o" 
3d34 f5				push af  
3d35 3a 49 3d			ld a, (.dmark)  
3d38 32 6b ee			ld (debug_mark),a  
3d3b 3a 4a 3d			ld a, (.dmark+1)  
3d3e 32 6c ee			ld (debug_mark+1),a  
3d41 3a 4b 3d			ld a, (.dmark+2)  
3d44 32 6d ee			ld (debug_mark+2),a  
3d47 18 03			jr .pastdmark  
3d49 ..			.dmark: db "D-o"  
3d4c f1			.pastdmark: pop af  
3d4d			endm  
# End of macro DMARK
3d4d				CALLMONITOR 
3d4d cd 6f ee			call debug_vector  
3d50				endm  
# End of macro CALLMONITOR
3d50			endif	 
3d50			 
3d50 d5					push de   ; save string start in case we need to advance print 
3d51			 
3d51 3a 5e ea				ld a, (f_cursor_ptr) 
3d54 cd cd 0b				call str_at_display 
3d57 3a 3c ea				ld a,(cli_autodisplay) 
3d5a fe 00				cp 0 
3d5c 28 03				jr z, .noupdate 
3d5e cd dd 0b						call update_display 
3d61					.noupdate: 
3d61			 
3d61			 
3d61					; see if we need to advance the print position 
3d61			 
3d61 e1					pop hl   ; get back string 
3d62			;		ex de,hl 
3d62			 
3d62 3a 3d ea				ld a, (cli_mvdot) 
3d65			if DEBUG_FORTH_DOT 
3d65			;		ld e,a 
3d65				DMARK "D>1" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 6b ee			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 6c ee			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 6d ee			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "D>1"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e				CALLMONITOR 
3d7e cd 6f ee			call debug_vector  
3d81				endm  
# End of macro CALLMONITOR
3d81			endif	 
3d81 fe 00				cp 0 
3d83 28 44				jr z, .noadv 
3d85					; yes, lets advance the print position 
3d85 3e 00				ld a, 0 
3d87 cd 50 12				call strlent 
3d8a			if DEBUG_FORTH_DOT 
3d8a				DMARK "D-?" 
3d8a f5				push af  
3d8b 3a 9f 3d			ld a, (.dmark)  
3d8e 32 6b ee			ld (debug_mark),a  
3d91 3a a0 3d			ld a, (.dmark+1)  
3d94 32 6c ee			ld (debug_mark+1),a  
3d97 3a a1 3d			ld a, (.dmark+2)  
3d9a 32 6d ee			ld (debug_mark+2),a  
3d9d 18 03			jr .pastdmark  
3d9f ..			.dmark: db "D-?"  
3da2 f1			.pastdmark: pop af  
3da3			endm  
# End of macro DMARK
3da3				CALLMONITOR 
3da3 cd 6f ee			call debug_vector  
3da6				endm  
# End of macro CALLMONITOR
3da6			endif	 
3da6 3a 5e ea				ld a, (f_cursor_ptr) 
3da9 85					add a,l 
3daa					;call addatohl 
3daa					;ld a, l 
3daa 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3dad			 
3dad			if DEBUG_FORTH_DOT 
3dad				DMARK "D->" 
3dad f5				push af  
3dae 3a c2 3d			ld a, (.dmark)  
3db1 32 6b ee			ld (debug_mark),a  
3db4 3a c3 3d			ld a, (.dmark+1)  
3db7 32 6c ee			ld (debug_mark+1),a  
3dba 3a c4 3d			ld a, (.dmark+2)  
3dbd 32 6d ee			ld (debug_mark+2),a  
3dc0 18 03			jr .pastdmark  
3dc2 ..			.dmark: db "D->"  
3dc5 f1			.pastdmark: pop af  
3dc6			endm  
# End of macro DMARK
3dc6				CALLMONITOR 
3dc6 cd 6f ee			call debug_vector  
3dc9				endm  
# End of macro CALLMONITOR
3dc9			endif	 
3dc9			 
3dc9			.noadv:	 
3dc9			 
3dc9					if DEBUG_FORTH_DOT_WAIT 
3dc9							call next_page_prompt 
3dc9					endif	 
3dc9			; TODO this pop off the stack causes a crash. i dont know why 
3dc9			 
3dc9			 
3dc9			if DEBUG_FORTH_DOT 
3dc9				DMARK "DTh" 
3dc9 f5				push af  
3dca 3a de 3d			ld a, (.dmark)  
3dcd 32 6b ee			ld (debug_mark),a  
3dd0 3a df 3d			ld a, (.dmark+1)  
3dd3 32 6c ee			ld (debug_mark+1),a  
3dd6 3a e0 3d			ld a, (.dmark+2)  
3dd9 32 6d ee			ld (debug_mark+2),a  
3ddc 18 03			jr .pastdmark  
3dde ..			.dmark: db "DTh"  
3de1 f1			.pastdmark: pop af  
3de2			endm  
# End of macro DMARK
3de2				CALLMONITOR 
3de2 cd 6f ee			call debug_vector  
3de5				endm  
# End of macro CALLMONITOR
3de5			endif	 
3de5			 
3de5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de5 cd f6 1e			call macro_forth_dsp_pop 
3de8				endm 
# End of macro FORTH_DSP_POP
3de8			 
3de8			if DEBUG_FORTH_DOT 
3de8				DMARK "DTi" 
3de8 f5				push af  
3de9 3a fd 3d			ld a, (.dmark)  
3dec 32 6b ee			ld (debug_mark),a  
3def 3a fe 3d			ld a, (.dmark+1)  
3df2 32 6c ee			ld (debug_mark+1),a  
3df5 3a ff 3d			ld a, (.dmark+2)  
3df8 32 6d ee			ld (debug_mark+2),a  
3dfb 18 03			jr .pastdmark  
3dfd ..			.dmark: db "DTi"  
3e00 f1			.pastdmark: pop af  
3e01			endm  
# End of macro DMARK
3e01				CALLMONITOR 
3e01 cd 6f ee			call debug_vector  
3e04				endm  
# End of macro CALLMONITOR
3e04			endif	 
3e04			 
3e04			 
3e04					NEXTW 
3e04 c3 f4 1f			jp macro_next 
3e07				endm 
# End of macro NEXTW
3e07			 
3e07			.CLS: 
3e07				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e07 35				db WORD_SYS_CORE+33             
3e08 34 3e			dw .DRAW            
3e0a 04				db 3 + 1 
3e0b .. 00			db "CLS",0              
3e0f				endm 
# End of macro CWHEAD
3e0f			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e0f					if DEBUG_FORTH_WORDS_KEY 
3e0f						DMARK "CLS" 
3e0f f5				push af  
3e10 3a 24 3e			ld a, (.dmark)  
3e13 32 6b ee			ld (debug_mark),a  
3e16 3a 25 3e			ld a, (.dmark+1)  
3e19 32 6c ee			ld (debug_mark+1),a  
3e1c 3a 26 3e			ld a, (.dmark+2)  
3e1f 32 6d ee			ld (debug_mark+2),a  
3e22 18 03			jr .pastdmark  
3e24 ..			.dmark: db "CLS"  
3e27 f1			.pastdmark: pop af  
3e28			endm  
# End of macro DMARK
3e28						CALLMONITOR 
3e28 cd 6f ee			call debug_vector  
3e2b				endm  
# End of macro CALLMONITOR
3e2b					endif 
3e2b cd ba 0b				call clear_display 
3e2e c3 42 3f				jp .home		; and home cursor 
3e31					NEXTW 
3e31 c3 f4 1f			jp macro_next 
3e34				endm 
# End of macro NEXTW
3e34			 
3e34			.DRAW: 
3e34				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e34 36				db WORD_SYS_CORE+34             
3e35 5f 3e			dw .DUMP            
3e37 05				db 4 + 1 
3e38 .. 00			db "DRAW",0              
3e3d				endm 
# End of macro CWHEAD
3e3d			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e3d					if DEBUG_FORTH_WORDS_KEY 
3e3d						DMARK "DRW" 
3e3d f5				push af  
3e3e 3a 52 3e			ld a, (.dmark)  
3e41 32 6b ee			ld (debug_mark),a  
3e44 3a 53 3e			ld a, (.dmark+1)  
3e47 32 6c ee			ld (debug_mark+1),a  
3e4a 3a 54 3e			ld a, (.dmark+2)  
3e4d 32 6d ee			ld (debug_mark+2),a  
3e50 18 03			jr .pastdmark  
3e52 ..			.dmark: db "DRW"  
3e55 f1			.pastdmark: pop af  
3e56			endm  
# End of macro DMARK
3e56						CALLMONITOR 
3e56 cd 6f ee			call debug_vector  
3e59				endm  
# End of macro CALLMONITOR
3e59					endif 
3e59 cd dd 0b				call update_display 
3e5c					NEXTW 
3e5c c3 f4 1f			jp macro_next 
3e5f				endm 
# End of macro NEXTW
3e5f			 
3e5f			.DUMP: 
3e5f				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e5f 37				db WORD_SYS_CORE+35             
3e60 97 3e			dw .CDUMP            
3e62 05				db 4 + 1 
3e63 .. 00			db "DUMP",0              
3e68				endm 
# End of macro CWHEAD
3e68			; | DUMP ( x -- ) With address x display dump   | DONE 
3e68			; TODO pop address to use off of the stack 
3e68					if DEBUG_FORTH_WORDS_KEY 
3e68						DMARK "DUM" 
3e68 f5				push af  
3e69 3a 7d 3e			ld a, (.dmark)  
3e6c 32 6b ee			ld (debug_mark),a  
3e6f 3a 7e 3e			ld a, (.dmark+1)  
3e72 32 6c ee			ld (debug_mark+1),a  
3e75 3a 7f 3e			ld a, (.dmark+2)  
3e78 32 6d ee			ld (debug_mark+2),a  
3e7b 18 03			jr .pastdmark  
3e7d ..			.dmark: db "DUM"  
3e80 f1			.pastdmark: pop af  
3e81			endm  
# End of macro DMARK
3e81						CALLMONITOR 
3e81 cd 6f ee			call debug_vector  
3e84				endm  
# End of macro CALLMONITOR
3e84					endif 
3e84 cd ba 0b				call clear_display 
3e87			 
3e87					; get address 
3e87			 
3e87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e87 cd 3e 1e			call macro_dsp_valuehl 
3e8a				endm 
# End of macro FORTH_DSP_VALUEHL
3e8a				 
3e8a					; save it for cdump 
3e8a			 
3e8a 22 e4 e5				ld (os_cur_ptr),hl 
3e8d			 
3e8d					; destroy value TOS 
3e8d			 
3e8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e8d cd f6 1e			call macro_forth_dsp_pop 
3e90				endm 
# End of macro FORTH_DSP_POP
3e90			 
3e90 cd c7 1a				call dumpcont	; skip old style of param parsing	 
3e93 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e94					NEXTW 
3e94 c3 f4 1f			jp macro_next 
3e97				endm 
# End of macro NEXTW
3e97			.CDUMP: 
3e97				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e97 38				db WORD_SYS_CORE+36             
3e98 c7 3e			dw .DAT            
3e9a 06				db 5 + 1 
3e9b .. 00			db "CDUMP",0              
3ea1				endm 
# End of macro CWHEAD
3ea1			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ea1					if DEBUG_FORTH_WORDS_KEY 
3ea1						DMARK "CDP" 
3ea1 f5				push af  
3ea2 3a b6 3e			ld a, (.dmark)  
3ea5 32 6b ee			ld (debug_mark),a  
3ea8 3a b7 3e			ld a, (.dmark+1)  
3eab 32 6c ee			ld (debug_mark+1),a  
3eae 3a b8 3e			ld a, (.dmark+2)  
3eb1 32 6d ee			ld (debug_mark+2),a  
3eb4 18 03			jr .pastdmark  
3eb6 ..			.dmark: db "CDP"  
3eb9 f1			.pastdmark: pop af  
3eba			endm  
# End of macro DMARK
3eba						CALLMONITOR 
3eba cd 6f ee			call debug_vector  
3ebd				endm  
# End of macro CALLMONITOR
3ebd					endif 
3ebd cd ba 0b				call clear_display 
3ec0 cd c7 1a				call dumpcont	 
3ec3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ec4					NEXTW 
3ec4 c3 f4 1f			jp macro_next 
3ec7				endm 
# End of macro NEXTW
3ec7			 
3ec7			 
3ec7			 
3ec7			 
3ec7			.DAT: 
3ec7				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ec7 3d				db WORD_SYS_CORE+41             
3ec8 1d 3f			dw .HOME            
3eca 03				db 2 + 1 
3ecb .. 00			db "AT",0              
3ece				endm 
# End of macro CWHEAD
3ece			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3ece					if DEBUG_FORTH_WORDS_KEY 
3ece						DMARK "AT." 
3ece f5				push af  
3ecf 3a e3 3e			ld a, (.dmark)  
3ed2 32 6b ee			ld (debug_mark),a  
3ed5 3a e4 3e			ld a, (.dmark+1)  
3ed8 32 6c ee			ld (debug_mark+1),a  
3edb 3a e5 3e			ld a, (.dmark+2)  
3ede 32 6d ee			ld (debug_mark+2),a  
3ee1 18 03			jr .pastdmark  
3ee3 ..			.dmark: db "AT."  
3ee6 f1			.pastdmark: pop af  
3ee7			endm  
# End of macro DMARK
3ee7						CALLMONITOR 
3ee7 cd 6f ee			call debug_vector  
3eea				endm  
# End of macro CALLMONITOR
3eea					endif 
3eea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eea cd 3e 1e			call macro_dsp_valuehl 
3eed				endm 
# End of macro FORTH_DSP_VALUEHL
3eed			 
3eed			 
3eed					; TODO save cursor row 
3eed 7d					ld a,l 
3eee fe 02				cp 2 
3ef0 20 04				jr nz, .crow3 
3ef2 3e 28				ld a, display_row_2 
3ef4 18 12				jr .ccol1 
3ef6 fe 03		.crow3:		cp 3 
3ef8 20 04				jr nz, .crow4 
3efa 3e 50				ld a, display_row_3 
3efc 18 0a				jr .ccol1 
3efe fe 04		.crow4:		cp 4 
3f00 20 04				jr nz, .crow1 
3f02 3e 78				ld a, display_row_4 
3f04 18 02				jr .ccol1 
3f06 3e 00		.crow1:		ld a,display_row_1 
3f08 f5			.ccol1:		push af			; got row offset 
3f09 6f					ld l,a 
3f0a 26 00				ld h,0 
3f0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0c cd f6 1e			call macro_forth_dsp_pop 
3f0f				endm 
# End of macro FORTH_DSP_POP
3f0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0f cd 3e 1e			call macro_dsp_valuehl 
3f12				endm 
# End of macro FORTH_DSP_VALUEHL
3f12					; TODO save cursor col 
3f12 f1					pop af 
3f13 85					add l		; add col offset 
3f14 32 5e ea				ld (f_cursor_ptr), a 
3f17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f17 cd f6 1e			call macro_forth_dsp_pop 
3f1a				endm 
# End of macro FORTH_DSP_POP
3f1a			 
3f1a					; calculate  
3f1a			 
3f1a					NEXTW 
3f1a c3 f4 1f			jp macro_next 
3f1d				endm 
# End of macro NEXTW
3f1d			 
3f1d			 
3f1d			.HOME: 
3f1d				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f1d 41				db WORD_SYS_CORE+45             
3f1e 4a 3f			dw .SPACE            
3f20 05				db 4 + 1 
3f21 .. 00			db "HOME",0              
3f26				endm 
# End of macro CWHEAD
3f26			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f26					if DEBUG_FORTH_WORDS_KEY 
3f26						DMARK "HOM" 
3f26 f5				push af  
3f27 3a 3b 3f			ld a, (.dmark)  
3f2a 32 6b ee			ld (debug_mark),a  
3f2d 3a 3c 3f			ld a, (.dmark+1)  
3f30 32 6c ee			ld (debug_mark+1),a  
3f33 3a 3d 3f			ld a, (.dmark+2)  
3f36 32 6d ee			ld (debug_mark+2),a  
3f39 18 03			jr .pastdmark  
3f3b ..			.dmark: db "HOM"  
3f3e f1			.pastdmark: pop af  
3f3f			endm  
# End of macro DMARK
3f3f						CALLMONITOR 
3f3f cd 6f ee			call debug_vector  
3f42				endm  
# End of macro CALLMONITOR
3f42					endif 
3f42 3e 00		.home:		ld a, 0		; and home cursor 
3f44 32 5e ea				ld (f_cursor_ptr), a 
3f47					NEXTW 
3f47 c3 f4 1f			jp macro_next 
3f4a				endm 
# End of macro NEXTW
3f4a			 
3f4a			 
3f4a			.SPACE: 
3f4a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f4a 46				db WORD_SYS_CORE+50             
3f4b 80 3f			dw .SPACES            
3f4d 03				db 2 + 1 
3f4e .. 00			db "BL",0              
3f51				endm 
# End of macro CWHEAD
3f51			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f51					if DEBUG_FORTH_WORDS_KEY 
3f51						DMARK "BL." 
3f51 f5				push af  
3f52 3a 66 3f			ld a, (.dmark)  
3f55 32 6b ee			ld (debug_mark),a  
3f58 3a 67 3f			ld a, (.dmark+1)  
3f5b 32 6c ee			ld (debug_mark+1),a  
3f5e 3a 68 3f			ld a, (.dmark+2)  
3f61 32 6d ee			ld (debug_mark+2),a  
3f64 18 03			jr .pastdmark  
3f66 ..			.dmark: db "BL."  
3f69 f1			.pastdmark: pop af  
3f6a			endm  
# End of macro DMARK
3f6a						CALLMONITOR 
3f6a cd 6f ee			call debug_vector  
3f6d				endm  
# End of macro CALLMONITOR
3f6d					endif 
3f6d 3e 20				ld a, " " 
3f6f 32 c1 e2				ld (scratch),a 
3f72 3e 00				ld a, 0 
3f74 32 c2 e2				ld (scratch+1),a 
3f77 21 c1 e2				ld hl, scratch 
3f7a cd b5 1c				call forth_push_str 
3f7d					 
3f7d				       NEXTW 
3f7d c3 f4 1f			jp macro_next 
3f80				endm 
# End of macro NEXTW
3f80			 
3f80			;.blstr: db " ", 0 
3f80			 
3f80			.SPACES: 
3f80				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f80 47				db WORD_SYS_CORE+51             
3f81 1b 40			dw .SCROLL            
3f83 07				db 6 + 1 
3f84 .. 00			db "SPACES",0              
3f8b				endm 
# End of macro CWHEAD
3f8b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f8b					if DEBUG_FORTH_WORDS_KEY 
3f8b						DMARK "SPS" 
3f8b f5				push af  
3f8c 3a a0 3f			ld a, (.dmark)  
3f8f 32 6b ee			ld (debug_mark),a  
3f92 3a a1 3f			ld a, (.dmark+1)  
3f95 32 6c ee			ld (debug_mark+1),a  
3f98 3a a2 3f			ld a, (.dmark+2)  
3f9b 32 6d ee			ld (debug_mark+2),a  
3f9e 18 03			jr .pastdmark  
3fa0 ..			.dmark: db "SPS"  
3fa3 f1			.pastdmark: pop af  
3fa4			endm  
# End of macro DMARK
3fa4						CALLMONITOR 
3fa4 cd 6f ee			call debug_vector  
3fa7				endm  
# End of macro CALLMONITOR
3fa7					endif 
3fa7			 
3fa7			 
3fa7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa7 cd 3e 1e			call macro_dsp_valuehl 
3faa				endm 
# End of macro FORTH_DSP_VALUEHL
3faa			 
3faa e5					push hl    ; u 
3fab					if DEBUG_FORTH_WORDS 
3fab						DMARK "SPA" 
3fab f5				push af  
3fac 3a c0 3f			ld a, (.dmark)  
3faf 32 6b ee			ld (debug_mark),a  
3fb2 3a c1 3f			ld a, (.dmark+1)  
3fb5 32 6c ee			ld (debug_mark+1),a  
3fb8 3a c2 3f			ld a, (.dmark+2)  
3fbb 32 6d ee			ld (debug_mark+2),a  
3fbe 18 03			jr .pastdmark  
3fc0 ..			.dmark: db "SPA"  
3fc3 f1			.pastdmark: pop af  
3fc4			endm  
# End of macro DMARK
3fc4						CALLMONITOR 
3fc4 cd 6f ee			call debug_vector  
3fc7				endm  
# End of macro CALLMONITOR
3fc7					endif 
3fc7			 
3fc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fc7 cd f6 1e			call macro_forth_dsp_pop 
3fca				endm 
# End of macro FORTH_DSP_POP
3fca e1					pop hl 
3fcb 0e 00				ld c, 0 
3fcd 45					ld b, l 
3fce 21 c1 e2				ld hl, scratch  
3fd1			 
3fd1					if DEBUG_FORTH_WORDS 
3fd1						DMARK "SP2" 
3fd1 f5				push af  
3fd2 3a e6 3f			ld a, (.dmark)  
3fd5 32 6b ee			ld (debug_mark),a  
3fd8 3a e7 3f			ld a, (.dmark+1)  
3fdb 32 6c ee			ld (debug_mark+1),a  
3fde 3a e8 3f			ld a, (.dmark+2)  
3fe1 32 6d ee			ld (debug_mark+2),a  
3fe4 18 03			jr .pastdmark  
3fe6 ..			.dmark: db "SP2"  
3fe9 f1			.pastdmark: pop af  
3fea			endm  
# End of macro DMARK
3fea						CALLMONITOR 
3fea cd 6f ee			call debug_vector  
3fed				endm  
# End of macro CALLMONITOR
3fed					endif 
3fed 3e 20				ld a, ' ' 
3fef			.spaces1:	 
3fef 77					ld (hl),a 
3ff0 23					inc hl 
3ff1					 
3ff1 10 fc				djnz .spaces1 
3ff3 3e 00				ld a,0 
3ff5 77					ld (hl),a 
3ff6 21 c1 e2				ld hl, scratch 
3ff9					if DEBUG_FORTH_WORDS 
3ff9						DMARK "SP3" 
3ff9 f5				push af  
3ffa 3a 0e 40			ld a, (.dmark)  
3ffd 32 6b ee			ld (debug_mark),a  
4000 3a 0f 40			ld a, (.dmark+1)  
4003 32 6c ee			ld (debug_mark+1),a  
4006 3a 10 40			ld a, (.dmark+2)  
4009 32 6d ee			ld (debug_mark+2),a  
400c 18 03			jr .pastdmark  
400e ..			.dmark: db "SP3"  
4011 f1			.pastdmark: pop af  
4012			endm  
# End of macro DMARK
4012						CALLMONITOR 
4012 cd 6f ee			call debug_vector  
4015				endm  
# End of macro CALLMONITOR
4015					endif 
4015 cd b5 1c				call forth_push_str 
4018			 
4018				       NEXTW 
4018 c3 f4 1f			jp macro_next 
401b				endm 
# End of macro NEXTW
401b			 
401b			 
401b			 
401b			.SCROLL: 
401b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
401b 53				db WORD_SYS_CORE+63             
401c 48 40			dw .SCROLLD            
401e 07				db 6 + 1 
401f .. 00			db "SCROLL",0              
4026				endm 
# End of macro CWHEAD
4026			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4026					if DEBUG_FORTH_WORDS_KEY 
4026						DMARK "SCR" 
4026 f5				push af  
4027 3a 3b 40			ld a, (.dmark)  
402a 32 6b ee			ld (debug_mark),a  
402d 3a 3c 40			ld a, (.dmark+1)  
4030 32 6c ee			ld (debug_mark+1),a  
4033 3a 3d 40			ld a, (.dmark+2)  
4036 32 6d ee			ld (debug_mark+2),a  
4039 18 03			jr .pastdmark  
403b ..			.dmark: db "SCR"  
403e f1			.pastdmark: pop af  
403f			endm  
# End of macro DMARK
403f						CALLMONITOR 
403f cd 6f ee			call debug_vector  
4042				endm  
# End of macro CALLMONITOR
4042					endif 
4042			 
4042 cd 7c 0b			call scroll_up 
4045			;	call update_display 
4045			 
4045					NEXTW 
4045 c3 f4 1f			jp macro_next 
4048				endm 
# End of macro NEXTW
4048			 
4048			 
4048			 
4048			;		; get dir 
4048			; 
4048			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4048			; 
4048			;		push hl 
4048			; 
4048			;		; destroy value TOS 
4048			; 
4048			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4048			; 
4048			;		; get count 
4048			; 
4048			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4048			; 
4048			;		push hl 
4048			; 
4048			;		; destroy value TOS 
4048			; 
4048			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4048			; 
4048			;		; one value on hl get other one back 
4048			; 
4048			;		pop bc    ; count 
4048			; 
4048			;		pop de   ; dir 
4048			; 
4048			; 
4048			;		ld b, c 
4048			; 
4048			;.scrolldir:     push bc 
4048			;		push de 
4048			; 
4048			;		ld a, 0 
4048			;		cp e 
4048			;		jr z, .scrollup  
4048			;		call scroll_down 
4048			;		jr .scrollnext 
4048			;.scrollup:	call scroll_up 
4048			; 
4048			;		 
4048			;.scrollnext: 
4048			;		pop de 
4048			;		pop bc 
4048			;		djnz .scrolldir 
4048			; 
4048			; 
4048			; 
4048			; 
4048			; 
4048			;		NEXTW 
4048			 
4048			.SCROLLD: 
4048				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4048 53				db WORD_SYS_CORE+63             
4049 76 40			dw .ATQ            
404b 08				db 7 + 1 
404c .. 00			db "SCROLLD",0              
4054				endm 
# End of macro CWHEAD
4054			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4054					if DEBUG_FORTH_WORDS_KEY 
4054						DMARK "SCD" 
4054 f5				push af  
4055 3a 69 40			ld a, (.dmark)  
4058 32 6b ee			ld (debug_mark),a  
405b 3a 6a 40			ld a, (.dmark+1)  
405e 32 6c ee			ld (debug_mark+1),a  
4061 3a 6b 40			ld a, (.dmark+2)  
4064 32 6d ee			ld (debug_mark+2),a  
4067 18 03			jr .pastdmark  
4069 ..			.dmark: db "SCD"  
406c f1			.pastdmark: pop af  
406d			endm  
# End of macro DMARK
406d						CALLMONITOR 
406d cd 6f ee			call debug_vector  
4070				endm  
# End of macro CALLMONITOR
4070					endif 
4070			 
4070 cd a0 0b			call scroll_down 
4073			;	call update_display 
4073			 
4073					NEXTW 
4073 c3 f4 1f			jp macro_next 
4076				endm 
# End of macro NEXTW
4076			 
4076			 
4076			.ATQ: 
4076				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4076 62				db WORD_SYS_CORE+78             
4077 d4 40			dw .AUTODSP            
4079 04				db 3 + 1 
407a .. 00			db "AT@",0              
407e				endm 
# End of macro CWHEAD
407e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
407e					if DEBUG_FORTH_WORDS_KEY 
407e						DMARK "ATA" 
407e f5				push af  
407f 3a 93 40			ld a, (.dmark)  
4082 32 6b ee			ld (debug_mark),a  
4085 3a 94 40			ld a, (.dmark+1)  
4088 32 6c ee			ld (debug_mark+1),a  
408b 3a 95 40			ld a, (.dmark+2)  
408e 32 6d ee			ld (debug_mark+2),a  
4091 18 03			jr .pastdmark  
4093 ..			.dmark: db "ATA"  
4096 f1			.pastdmark: pop af  
4097			endm  
# End of macro DMARK
4097						CALLMONITOR 
4097 cd 6f ee			call debug_vector  
409a				endm  
# End of macro CALLMONITOR
409a					endif 
409a			 
409a			 
409a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
409a cd 3e 1e			call macro_dsp_valuehl 
409d				endm 
# End of macro FORTH_DSP_VALUEHL
409d			 
409d					; TODO save cursor row 
409d 7d					ld a,l 
409e fe 02				cp 2 
40a0 20 04				jr nz, .crow3aq 
40a2 3e 28				ld a, display_row_2 
40a4 18 12				jr .ccol1aq 
40a6 fe 03		.crow3aq:		cp 3 
40a8 20 04				jr nz, .crow4aq 
40aa 3e 50				ld a, display_row_3 
40ac 18 0a				jr .ccol1aq 
40ae fe 04		.crow4aq:		cp 4 
40b0 20 04				jr nz, .crow1aq 
40b2 3e 78				ld a, display_row_4 
40b4 18 02				jr .ccol1aq 
40b6 3e 00		.crow1aq:		ld a,display_row_1 
40b8 f5			.ccol1aq:		push af			; got row offset 
40b9 6f					ld l,a 
40ba 26 00				ld h,0 
40bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bc cd f6 1e			call macro_forth_dsp_pop 
40bf				endm 
# End of macro FORTH_DSP_POP
40bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bf cd 3e 1e			call macro_dsp_valuehl 
40c2				endm 
# End of macro FORTH_DSP_VALUEHL
40c2					; TODO save cursor col 
40c2 f1					pop af 
40c3 85					add l		; add col offset 
40c4			 
40c4					; add current frame buffer address 
40c4 2a cc eb				ld hl, (display_fb_active) 
40c7 cd e7 0d				call addatohl 
40ca			 
40ca			 
40ca			 
40ca			 
40ca					; get char frame buffer location offset in hl 
40ca			 
40ca 7e					ld a,(hl) 
40cb 26 00				ld h, 0 
40cd 6f					ld l, a 
40ce			 
40ce cd 47 1c				call forth_push_numhl 
40d1			 
40d1			 
40d1					NEXTW 
40d1 c3 f4 1f			jp macro_next 
40d4				endm 
# End of macro NEXTW
40d4			 
40d4			.AUTODSP: 
40d4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40d4 63				db WORD_SYS_CORE+79             
40d5 ea 40			dw .MENU            
40d7 05				db 4 + 1 
40d8 .. 00			db "ADSP",0              
40dd				endm 
# End of macro CWHEAD
40dd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40dd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40dd			 
40dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40dd cd 3e 1e			call macro_dsp_valuehl 
40e0				endm 
# End of macro FORTH_DSP_VALUEHL
40e0			 
40e0			;		push hl 
40e0			 
40e0					; destroy value TOS 
40e0			 
40e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40e0 cd f6 1e			call macro_forth_dsp_pop 
40e3				endm 
# End of macro FORTH_DSP_POP
40e3			 
40e3			;		pop hl 
40e3			 
40e3 7d					ld a,l 
40e4 32 3c ea				ld (cli_autodisplay), a 
40e7				       NEXTW 
40e7 c3 f4 1f			jp macro_next 
40ea				endm 
# End of macro NEXTW
40ea			 
40ea			.MENU: 
40ea				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40ea 70				db WORD_SYS_CORE+92             
40eb 93 41			dw .ENDDISPLAY            
40ed 05				db 4 + 1 
40ee .. 00			db "MENU",0              
40f3				endm 
# End of macro CWHEAD
40f3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40f3			 
40f3			;		; get number of items on the stack 
40f3			; 
40f3				 
40f3					FORTH_DSP_VALUEHL 
40f3 cd 3e 1e			call macro_dsp_valuehl 
40f6				endm 
# End of macro FORTH_DSP_VALUEHL
40f6				 
40f6					if DEBUG_FORTH_WORDS_KEY 
40f6						DMARK "MNU" 
40f6 f5				push af  
40f7 3a 0b 41			ld a, (.dmark)  
40fa 32 6b ee			ld (debug_mark),a  
40fd 3a 0c 41			ld a, (.dmark+1)  
4100 32 6c ee			ld (debug_mark+1),a  
4103 3a 0d 41			ld a, (.dmark+2)  
4106 32 6d ee			ld (debug_mark+2),a  
4109 18 03			jr .pastdmark  
410b ..			.dmark: db "MNU"  
410e f1			.pastdmark: pop af  
410f			endm  
# End of macro DMARK
410f						CALLMONITOR 
410f cd 6f ee			call debug_vector  
4112				endm  
# End of macro CALLMONITOR
4112					endif 
4112			 
4112 45					ld b, l	 
4113 05					dec b 
4114			 
4114					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4114 cd f6 1e			call macro_forth_dsp_pop 
4117				endm 
# End of macro FORTH_DSP_POP
4117			 
4117			 
4117					; go directly through the stack to pluck out the string pointers and build an array 
4117			 
4117			;		FORTH_DSP 
4117			 
4117					; hl contains top most stack item 
4117				 
4117 11 c1 e2				ld de, scratch 
411a			 
411a			.mbuild: 
411a			 
411a					FORTH_DSP_VALUEHL 
411a cd 3e 1e			call macro_dsp_valuehl 
411d				endm 
# End of macro FORTH_DSP_VALUEHL
411d			 
411d					if DEBUG_FORTH_WORDS 
411d						DMARK "MN3" 
411d f5				push af  
411e 3a 32 41			ld a, (.dmark)  
4121 32 6b ee			ld (debug_mark),a  
4124 3a 33 41			ld a, (.dmark+1)  
4127 32 6c ee			ld (debug_mark+1),a  
412a 3a 34 41			ld a, (.dmark+2)  
412d 32 6d ee			ld (debug_mark+2),a  
4130 18 03			jr .pastdmark  
4132 ..			.dmark: db "MN3"  
4135 f1			.pastdmark: pop af  
4136			endm  
# End of macro DMARK
4136						CALLMONITOR 
4136 cd 6f ee			call debug_vector  
4139				endm  
# End of macro CALLMONITOR
4139					endif 
4139 eb					ex de, hl 
413a 73					ld (hl), e 
413b 23					inc hl 
413c 72					ld (hl), d 
413d 23					inc hl 
413e eb					ex de, hl 
413f			 
413f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
413f cd f6 1e			call macro_forth_dsp_pop 
4142				endm 
# End of macro FORTH_DSP_POP
4142			 
4142 10 d6				djnz .mbuild 
4144			 
4144					; done add term 
4144			 
4144 eb					ex de, hl 
4145 36 00				ld (hl), 0 
4147 23					inc hl 
4148 36 00				ld (hl), 0 
414a			 
414a				 
414a					 
414a 21 c1 e2				ld hl, scratch 
414d			 
414d					if DEBUG_FORTH_WORDS 
414d						DMARK "MNx" 
414d f5				push af  
414e 3a 62 41			ld a, (.dmark)  
4151 32 6b ee			ld (debug_mark),a  
4154 3a 63 41			ld a, (.dmark+1)  
4157 32 6c ee			ld (debug_mark+1),a  
415a 3a 64 41			ld a, (.dmark+2)  
415d 32 6d ee			ld (debug_mark+2),a  
4160 18 03			jr .pastdmark  
4162 ..			.dmark: db "MNx"  
4165 f1			.pastdmark: pop af  
4166			endm  
# End of macro DMARK
4166						CALLMONITOR 
4166 cd 6f ee			call debug_vector  
4169				endm  
# End of macro CALLMONITOR
4169					endif 
4169			 
4169			 
4169			 
4169 3e 00				ld a, 0 
416b cd eb 0b				call menu 
416e			 
416e			 
416e 6f					ld l, a 
416f 26 00				ld h, 0 
4171			 
4171					if DEBUG_FORTH_WORDS 
4171						DMARK "MNr" 
4171 f5				push af  
4172 3a 86 41			ld a, (.dmark)  
4175 32 6b ee			ld (debug_mark),a  
4178 3a 87 41			ld a, (.dmark+1)  
417b 32 6c ee			ld (debug_mark+1),a  
417e 3a 88 41			ld a, (.dmark+2)  
4181 32 6d ee			ld (debug_mark+2),a  
4184 18 03			jr .pastdmark  
4186 ..			.dmark: db "MNr"  
4189 f1			.pastdmark: pop af  
418a			endm  
# End of macro DMARK
418a						CALLMONITOR 
418a cd 6f ee			call debug_vector  
418d				endm  
# End of macro CALLMONITOR
418d					endif 
418d			 
418d cd 47 1c				call forth_push_numhl 
4190			 
4190			 
4190			 
4190			 
4190				       NEXTW 
4190 c3 f4 1f			jp macro_next 
4193				endm 
# End of macro NEXTW
4193			 
4193			 
4193			.ENDDISPLAY: 
4193			 
4193			; eof 
# End of file forth_words_display.asm
4193			include "forth_words_str.asm" 
4193			 
4193			; | ## String Words 
4193			 
4193			.PTR:   
4193			 
4193				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4193 48				db WORD_SYS_CORE+52             
4194 c0 41			dw .STYPE            
4196 04				db 3 + 1 
4197 .. 00			db "PTR",0              
419b				endm 
# End of macro CWHEAD
419b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
419b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
419b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
419b			 
419b					if DEBUG_FORTH_WORDS_KEY 
419b						DMARK "PTR" 
419b f5				push af  
419c 3a b0 41			ld a, (.dmark)  
419f 32 6b ee			ld (debug_mark),a  
41a2 3a b1 41			ld a, (.dmark+1)  
41a5 32 6c ee			ld (debug_mark+1),a  
41a8 3a b2 41			ld a, (.dmark+2)  
41ab 32 6d ee			ld (debug_mark+2),a  
41ae 18 03			jr .pastdmark  
41b0 ..			.dmark: db "PTR"  
41b3 f1			.pastdmark: pop af  
41b4			endm  
# End of macro DMARK
41b4						CALLMONITOR 
41b4 cd 6f ee			call debug_vector  
41b7				endm  
# End of macro CALLMONITOR
41b7					endif 
41b7					FORTH_DSP_VALUEHL 
41b7 cd 3e 1e			call macro_dsp_valuehl 
41ba				endm 
# End of macro FORTH_DSP_VALUEHL
41ba cd 47 1c				call forth_push_numhl 
41bd			 
41bd			 
41bd					NEXTW 
41bd c3 f4 1f			jp macro_next 
41c0				endm 
# End of macro NEXTW
41c0			.STYPE: 
41c0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41c0 48				db WORD_SYS_CORE+52             
41c1 0f 42			dw .UPPER            
41c3 06				db 5 + 1 
41c4 .. 00			db "STYPE",0              
41ca				endm 
# End of macro CWHEAD
41ca			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41ca					if DEBUG_FORTH_WORDS_KEY 
41ca						DMARK "STY" 
41ca f5				push af  
41cb 3a df 41			ld a, (.dmark)  
41ce 32 6b ee			ld (debug_mark),a  
41d1 3a e0 41			ld a, (.dmark+1)  
41d4 32 6c ee			ld (debug_mark+1),a  
41d7 3a e1 41			ld a, (.dmark+2)  
41da 32 6d ee			ld (debug_mark+2),a  
41dd 18 03			jr .pastdmark  
41df ..			.dmark: db "STY"  
41e2 f1			.pastdmark: pop af  
41e3			endm  
# End of macro DMARK
41e3						CALLMONITOR 
41e3 cd 6f ee			call debug_vector  
41e6				endm  
# End of macro CALLMONITOR
41e6					endif 
41e6					FORTH_DSP 
41e6 cd 04 1e			call macro_forth_dsp 
41e9				endm 
# End of macro FORTH_DSP
41e9					;v5 FORTH_DSP_VALUE 
41e9			 
41e9 7e					ld a, (hl) 
41ea			 
41ea f5					push af 
41eb			 
41eb			; Dont destroy TOS		FORTH_DSP_POP 
41eb			 
41eb f1					pop af 
41ec			 
41ec fe 01				cp DS_TYPE_STR 
41ee 28 09				jr z, .typestr 
41f0			 
41f0 fe 02				cp DS_TYPE_INUM 
41f2 28 0a				jr z, .typeinum 
41f4			 
41f4 21 0d 42				ld hl, .tna 
41f7 18 0a				jr .tpush 
41f9			 
41f9 21 09 42		.typestr:	ld hl, .tstr 
41fc 18 05				jr .tpush 
41fe 21 0b 42		.typeinum:	ld hl, .tinum 
4201 18 00				jr .tpush 
4203			 
4203			.tpush: 
4203			 
4203 cd b5 1c				call forth_push_str 
4206			 
4206					NEXTW 
4206 c3 f4 1f			jp macro_next 
4209				endm 
# End of macro NEXTW
4209 .. 00		.tstr:	db "s",0 
420b .. 00		.tinum:  db "i",0 
420d .. 00		.tna:   db "?", 0 
420f			 
420f			 
420f			.UPPER: 
420f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
420f 48				db WORD_SYS_CORE+52             
4210 4a 42			dw .LOWER            
4212 06				db 5 + 1 
4213 .. 00			db "UPPER",0              
4219				endm 
# End of macro CWHEAD
4219			; | UPPER ( s -- s ) Upper case string s  | DONE 
4219					if DEBUG_FORTH_WORDS_KEY 
4219						DMARK "UPR" 
4219 f5				push af  
421a 3a 2e 42			ld a, (.dmark)  
421d 32 6b ee			ld (debug_mark),a  
4220 3a 2f 42			ld a, (.dmark+1)  
4223 32 6c ee			ld (debug_mark+1),a  
4226 3a 30 42			ld a, (.dmark+2)  
4229 32 6d ee			ld (debug_mark+2),a  
422c 18 03			jr .pastdmark  
422e ..			.dmark: db "UPR"  
4231 f1			.pastdmark: pop af  
4232			endm  
# End of macro DMARK
4232						CALLMONITOR 
4232 cd 6f ee			call debug_vector  
4235				endm  
# End of macro CALLMONITOR
4235					endif 
4235			 
4235					FORTH_DSP 
4235 cd 04 1e			call macro_forth_dsp 
4238				endm 
# End of macro FORTH_DSP
4238					 
4238			; TODO check is string type 
4238			 
4238					FORTH_DSP_VALUEHL 
4238 cd 3e 1e			call macro_dsp_valuehl 
423b				endm 
# End of macro FORTH_DSP_VALUEHL
423b			; get pointer to string in hl 
423b			 
423b 7e			.toup:		ld a, (hl) 
423c fe 00				cp 0 
423e 28 07				jr z, .toupdone 
4240			 
4240 cd 54 11				call to_upper 
4243			 
4243 77					ld (hl), a 
4244 23					inc hl 
4245 18 f4				jr .toup 
4247			 
4247					 
4247			 
4247			 
4247			; for each char convert to upper 
4247					 
4247			.toupdone: 
4247			 
4247			 
4247					NEXTW 
4247 c3 f4 1f			jp macro_next 
424a				endm 
# End of macro NEXTW
424a			.LOWER: 
424a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
424a 48				db WORD_SYS_CORE+52             
424b 85 42			dw .TCASE            
424d 06				db 5 + 1 
424e .. 00			db "LOWER",0              
4254				endm 
# End of macro CWHEAD
4254			; | LOWER ( s -- s ) Lower case string s  | DONE 
4254					if DEBUG_FORTH_WORDS_KEY 
4254						DMARK "LWR" 
4254 f5				push af  
4255 3a 69 42			ld a, (.dmark)  
4258 32 6b ee			ld (debug_mark),a  
425b 3a 6a 42			ld a, (.dmark+1)  
425e 32 6c ee			ld (debug_mark+1),a  
4261 3a 6b 42			ld a, (.dmark+2)  
4264 32 6d ee			ld (debug_mark+2),a  
4267 18 03			jr .pastdmark  
4269 ..			.dmark: db "LWR"  
426c f1			.pastdmark: pop af  
426d			endm  
# End of macro DMARK
426d						CALLMONITOR 
426d cd 6f ee			call debug_vector  
4270				endm  
# End of macro CALLMONITOR
4270					endif 
4270			 
4270					FORTH_DSP 
4270 cd 04 1e			call macro_forth_dsp 
4273				endm 
# End of macro FORTH_DSP
4273					 
4273			; TODO check is string type 
4273			 
4273					FORTH_DSP_VALUEHL 
4273 cd 3e 1e			call macro_dsp_valuehl 
4276				endm 
# End of macro FORTH_DSP_VALUEHL
4276			; get pointer to string in hl 
4276			 
4276 7e			.tolow:		ld a, (hl) 
4277 fe 00				cp 0 
4279 28 07				jr z, .tolowdone 
427b			 
427b cd 5d 11				call to_lower 
427e			 
427e 77					ld (hl), a 
427f 23					inc hl 
4280 18 f4				jr .tolow 
4282			 
4282					 
4282			 
4282			 
4282			; for each char convert to low 
4282					 
4282			.tolowdone: 
4282					NEXTW 
4282 c3 f4 1f			jp macro_next 
4285				endm 
# End of macro NEXTW
4285			.TCASE: 
4285				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4285 48				db WORD_SYS_CORE+52             
4286 bb 43			dw .SUBSTR            
4288 06				db 5 + 1 
4289 .. 00			db "TCASE",0              
428f				endm 
# End of macro CWHEAD
428f			; | TCASE ( s -- s ) Title case string s  | DONE 
428f					if DEBUG_FORTH_WORDS_KEY 
428f						DMARK "TCS" 
428f f5				push af  
4290 3a a4 42			ld a, (.dmark)  
4293 32 6b ee			ld (debug_mark),a  
4296 3a a5 42			ld a, (.dmark+1)  
4299 32 6c ee			ld (debug_mark+1),a  
429c 3a a6 42			ld a, (.dmark+2)  
429f 32 6d ee			ld (debug_mark+2),a  
42a2 18 03			jr .pastdmark  
42a4 ..			.dmark: db "TCS"  
42a7 f1			.pastdmark: pop af  
42a8			endm  
# End of macro DMARK
42a8						CALLMONITOR 
42a8 cd 6f ee			call debug_vector  
42ab				endm  
# End of macro CALLMONITOR
42ab					endif 
42ab			 
42ab					FORTH_DSP 
42ab cd 04 1e			call macro_forth_dsp 
42ae				endm 
# End of macro FORTH_DSP
42ae					 
42ae			; TODO check is string type 
42ae			 
42ae					FORTH_DSP_VALUEHL 
42ae cd 3e 1e			call macro_dsp_valuehl 
42b1				endm 
# End of macro FORTH_DSP_VALUEHL
42b1			; get pointer to string in hl 
42b1			 
42b1					if DEBUG_FORTH_WORDS 
42b1						DMARK "TC1" 
42b1 f5				push af  
42b2 3a c6 42			ld a, (.dmark)  
42b5 32 6b ee			ld (debug_mark),a  
42b8 3a c7 42			ld a, (.dmark+1)  
42bb 32 6c ee			ld (debug_mark+1),a  
42be 3a c8 42			ld a, (.dmark+2)  
42c1 32 6d ee			ld (debug_mark+2),a  
42c4 18 03			jr .pastdmark  
42c6 ..			.dmark: db "TC1"  
42c9 f1			.pastdmark: pop af  
42ca			endm  
# End of macro DMARK
42ca						CALLMONITOR 
42ca cd 6f ee			call debug_vector  
42cd				endm  
# End of macro CALLMONITOR
42cd					endif 
42cd			 
42cd					; first time in turn to upper case first char 
42cd			 
42cd 7e					ld a, (hl) 
42ce c3 58 43				jp .totsiptou 
42d1			 
42d1			 
42d1 7e			.tot:		ld a, (hl) 
42d2 fe 00				cp 0 
42d4 ca 9c 43				jp z, .totdone 
42d7			 
42d7					if DEBUG_FORTH_WORDS 
42d7						DMARK "TC2" 
42d7 f5				push af  
42d8 3a ec 42			ld a, (.dmark)  
42db 32 6b ee			ld (debug_mark),a  
42de 3a ed 42			ld a, (.dmark+1)  
42e1 32 6c ee			ld (debug_mark+1),a  
42e4 3a ee 42			ld a, (.dmark+2)  
42e7 32 6d ee			ld (debug_mark+2),a  
42ea 18 03			jr .pastdmark  
42ec ..			.dmark: db "TC2"  
42ef f1			.pastdmark: pop af  
42f0			endm  
# End of macro DMARK
42f0						CALLMONITOR 
42f0 cd 6f ee			call debug_vector  
42f3				endm  
# End of macro CALLMONITOR
42f3					endif 
42f3					; check to see if current char is a space 
42f3			 
42f3 fe 20				cp ' ' 
42f5 28 21				jr z, .totsp 
42f7 cd 5d 11				call to_lower 
42fa					if DEBUG_FORTH_WORDS 
42fa						DMARK "TC3" 
42fa f5				push af  
42fb 3a 0f 43			ld a, (.dmark)  
42fe 32 6b ee			ld (debug_mark),a  
4301 3a 10 43			ld a, (.dmark+1)  
4304 32 6c ee			ld (debug_mark+1),a  
4307 3a 11 43			ld a, (.dmark+2)  
430a 32 6d ee			ld (debug_mark+2),a  
430d 18 03			jr .pastdmark  
430f ..			.dmark: db "TC3"  
4312 f1			.pastdmark: pop af  
4313			endm  
# End of macro DMARK
4313						CALLMONITOR 
4313 cd 6f ee			call debug_vector  
4316				endm  
# End of macro CALLMONITOR
4316					endif 
4316 18 63				jr .totnxt 
4318			 
4318			.totsp:         ; on a space, find next char which should be upper 
4318			 
4318					if DEBUG_FORTH_WORDS 
4318						DMARK "TC4" 
4318 f5				push af  
4319 3a 2d 43			ld a, (.dmark)  
431c 32 6b ee			ld (debug_mark),a  
431f 3a 2e 43			ld a, (.dmark+1)  
4322 32 6c ee			ld (debug_mark+1),a  
4325 3a 2f 43			ld a, (.dmark+2)  
4328 32 6d ee			ld (debug_mark+2),a  
432b 18 03			jr .pastdmark  
432d ..			.dmark: db "TC4"  
4330 f1			.pastdmark: pop af  
4331			endm  
# End of macro DMARK
4331						CALLMONITOR 
4331 cd 6f ee			call debug_vector  
4334				endm  
# End of macro CALLMONITOR
4334					endif 
4334					;; 
4334			 
4334 fe 20				cp ' ' 
4336 20 20				jr nz, .totsiptou 
4338 23					inc hl 
4339 7e					ld a, (hl) 
433a					if DEBUG_FORTH_WORDS 
433a						DMARK "TC5" 
433a f5				push af  
433b 3a 4f 43			ld a, (.dmark)  
433e 32 6b ee			ld (debug_mark),a  
4341 3a 50 43			ld a, (.dmark+1)  
4344 32 6c ee			ld (debug_mark+1),a  
4347 3a 51 43			ld a, (.dmark+2)  
434a 32 6d ee			ld (debug_mark+2),a  
434d 18 03			jr .pastdmark  
434f ..			.dmark: db "TC5"  
4352 f1			.pastdmark: pop af  
4353			endm  
# End of macro DMARK
4353						CALLMONITOR 
4353 cd 6f ee			call debug_vector  
4356				endm  
# End of macro CALLMONITOR
4356					endif 
4356 18 c0				jr .totsp 
4358 fe 00		.totsiptou:    cp 0 
435a 28 40				jr z, .totdone 
435c					; not space and not zero term so upper case it 
435c cd 54 11				call to_upper 
435f			 
435f					if DEBUG_FORTH_WORDS 
435f						DMARK "TC6" 
435f f5				push af  
4360 3a 74 43			ld a, (.dmark)  
4363 32 6b ee			ld (debug_mark),a  
4366 3a 75 43			ld a, (.dmark+1)  
4369 32 6c ee			ld (debug_mark+1),a  
436c 3a 76 43			ld a, (.dmark+2)  
436f 32 6d ee			ld (debug_mark+2),a  
4372 18 03			jr .pastdmark  
4374 ..			.dmark: db "TC6"  
4377 f1			.pastdmark: pop af  
4378			endm  
# End of macro DMARK
4378						CALLMONITOR 
4378 cd 6f ee			call debug_vector  
437b				endm  
# End of macro CALLMONITOR
437b					endif 
437b			 
437b			 
437b			.totnxt: 
437b			 
437b 77					ld (hl), a 
437c 23					inc hl 
437d					if DEBUG_FORTH_WORDS 
437d						DMARK "TC7" 
437d f5				push af  
437e 3a 92 43			ld a, (.dmark)  
4381 32 6b ee			ld (debug_mark),a  
4384 3a 93 43			ld a, (.dmark+1)  
4387 32 6c ee			ld (debug_mark+1),a  
438a 3a 94 43			ld a, (.dmark+2)  
438d 32 6d ee			ld (debug_mark+2),a  
4390 18 03			jr .pastdmark  
4392 ..			.dmark: db "TC7"  
4395 f1			.pastdmark: pop af  
4396			endm  
# End of macro DMARK
4396						CALLMONITOR 
4396 cd 6f ee			call debug_vector  
4399				endm  
# End of macro CALLMONITOR
4399					endif 
4399 c3 d1 42				jp .tot 
439c			 
439c					 
439c			 
439c			 
439c			; for each char convert to low 
439c					 
439c			.totdone: 
439c					if DEBUG_FORTH_WORDS 
439c						DMARK "TCd" 
439c f5				push af  
439d 3a b1 43			ld a, (.dmark)  
43a0 32 6b ee			ld (debug_mark),a  
43a3 3a b2 43			ld a, (.dmark+1)  
43a6 32 6c ee			ld (debug_mark+1),a  
43a9 3a b3 43			ld a, (.dmark+2)  
43ac 32 6d ee			ld (debug_mark+2),a  
43af 18 03			jr .pastdmark  
43b1 ..			.dmark: db "TCd"  
43b4 f1			.pastdmark: pop af  
43b5			endm  
# End of macro DMARK
43b5						CALLMONITOR 
43b5 cd 6f ee			call debug_vector  
43b8				endm  
# End of macro CALLMONITOR
43b8					endif 
43b8					NEXTW 
43b8 c3 f4 1f			jp macro_next 
43bb				endm 
# End of macro NEXTW
43bb			 
43bb			.SUBSTR: 
43bb				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43bb 48				db WORD_SYS_CORE+52             
43bc 19 44			dw .LEFT            
43be 07				db 6 + 1 
43bf .. 00			db "SUBSTR",0              
43c6				endm 
# End of macro CWHEAD
43c6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43c6			 
43c6					if DEBUG_FORTH_WORDS_KEY 
43c6						DMARK "SST" 
43c6 f5				push af  
43c7 3a db 43			ld a, (.dmark)  
43ca 32 6b ee			ld (debug_mark),a  
43cd 3a dc 43			ld a, (.dmark+1)  
43d0 32 6c ee			ld (debug_mark+1),a  
43d3 3a dd 43			ld a, (.dmark+2)  
43d6 32 6d ee			ld (debug_mark+2),a  
43d9 18 03			jr .pastdmark  
43db ..			.dmark: db "SST"  
43de f1			.pastdmark: pop af  
43df			endm  
# End of macro DMARK
43df						CALLMONITOR 
43df cd 6f ee			call debug_vector  
43e2				endm  
# End of macro CALLMONITOR
43e2					endif 
43e2			; TODO check string type 
43e2					FORTH_DSP_VALUEHL 
43e2 cd 3e 1e			call macro_dsp_valuehl 
43e5				endm 
# End of macro FORTH_DSP_VALUEHL
43e5			 
43e5 e5					push hl      ; string length 
43e6			 
43e6					FORTH_DSP_POP 
43e6 cd f6 1e			call macro_forth_dsp_pop 
43e9				endm 
# End of macro FORTH_DSP_POP
43e9			 
43e9					FORTH_DSP_VALUEHL 
43e9 cd 3e 1e			call macro_dsp_valuehl 
43ec				endm 
# End of macro FORTH_DSP_VALUEHL
43ec			 
43ec e5					push hl     ; start char 
43ed			 
43ed					FORTH_DSP_POP 
43ed cd f6 1e			call macro_forth_dsp_pop 
43f0				endm 
# End of macro FORTH_DSP_POP
43f0			 
43f0			 
43f0					FORTH_DSP_VALUE 
43f0 cd 27 1e			call macro_forth_dsp_value 
43f3				endm 
# End of macro FORTH_DSP_VALUE
43f3			 
43f3 d1					pop de    ; get start post offset 
43f4			 
43f4 19					add hl, de    ; starting offset 
43f5			 
43f5 c1					pop bc 
43f6 c5					push bc      ; grab size of string 
43f7			 
43f7 e5					push hl    ; save string start  
43f8			 
43f8 26 00				ld h, 0 
43fa 69					ld l, c 
43fb 23					inc hl 
43fc 23					inc hl 
43fd			 
43fd cd ae 12				call malloc 
4400				if DEBUG_FORTH_MALLOC_GUARD 
4400 cc 33 4d				call z,malloc_error 
4403				endif 
4403			 
4403 eb					ex de, hl      ; save malloc area for string copy 
4404 e1					pop hl    ; get back source 
4405 c1					pop bc    ; get length of string back 
4406			 
4406 d5					push de    ; save malloc area for after we push 
4407 ed b0				ldir     ; copy substr 
4409			 
4409			 
4409 eb					ex de, hl 
440a 3e 00				ld a, 0 
440c 77					ld (hl), a   ; term substr 
440d			 
440d					 
440d e1					pop hl    ; get malloc so we can push it 
440e e5					push hl   ; save so we can free it afterwards 
440f			 
440f cd b5 1c				call forth_push_str 
4412			 
4412 e1					pop hl 
4413 cd 78 13				call free 
4416			 
4416					 
4416					 
4416			 
4416			 
4416					NEXTW 
4416 c3 f4 1f			jp macro_next 
4419				endm 
# End of macro NEXTW
4419			 
4419			.LEFT: 
4419				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4419 48				db WORD_SYS_CORE+52             
441a 41 44			dw .RIGHT            
441c 05				db 4 + 1 
441d .. 00			db "LEFT",0              
4422				endm 
# End of macro CWHEAD
4422			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4422					if DEBUG_FORTH_WORDS_KEY 
4422						DMARK "LEF" 
4422 f5				push af  
4423 3a 37 44			ld a, (.dmark)  
4426 32 6b ee			ld (debug_mark),a  
4429 3a 38 44			ld a, (.dmark+1)  
442c 32 6c ee			ld (debug_mark+1),a  
442f 3a 39 44			ld a, (.dmark+2)  
4432 32 6d ee			ld (debug_mark+2),a  
4435 18 03			jr .pastdmark  
4437 ..			.dmark: db "LEF"  
443a f1			.pastdmark: pop af  
443b			endm  
# End of macro DMARK
443b						CALLMONITOR 
443b cd 6f ee			call debug_vector  
443e				endm  
# End of macro CALLMONITOR
443e					endif 
443e			 
443e					NEXTW 
443e c3 f4 1f			jp macro_next 
4441				endm 
# End of macro NEXTW
4441			.RIGHT: 
4441				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4441 48				db WORD_SYS_CORE+52             
4442 6a 44			dw .STR2NUM            
4444 06				db 5 + 1 
4445 .. 00			db "RIGHT",0              
444b				endm 
# End of macro CWHEAD
444b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
444b					if DEBUG_FORTH_WORDS_KEY 
444b						DMARK "RIG" 
444b f5				push af  
444c 3a 60 44			ld a, (.dmark)  
444f 32 6b ee			ld (debug_mark),a  
4452 3a 61 44			ld a, (.dmark+1)  
4455 32 6c ee			ld (debug_mark+1),a  
4458 3a 62 44			ld a, (.dmark+2)  
445b 32 6d ee			ld (debug_mark+2),a  
445e 18 03			jr .pastdmark  
4460 ..			.dmark: db "RIG"  
4463 f1			.pastdmark: pop af  
4464			endm  
# End of macro DMARK
4464						CALLMONITOR 
4464 cd 6f ee			call debug_vector  
4467				endm  
# End of macro CALLMONITOR
4467					endif 
4467			 
4467					NEXTW 
4467 c3 f4 1f			jp macro_next 
446a				endm 
# End of macro NEXTW
446a			 
446a			 
446a			.STR2NUM: 
446a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
446a 48				db WORD_SYS_CORE+52             
446b f6 44			dw .NUM2STR            
446d 08				db 7 + 1 
446e .. 00			db "STR2NUM",0              
4476				endm 
# End of macro CWHEAD
4476			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4476			 
4476			 
4476			; TODO STR type check to do 
4476					if DEBUG_FORTH_WORDS_KEY 
4476						DMARK "S2N" 
4476 f5				push af  
4477 3a 8b 44			ld a, (.dmark)  
447a 32 6b ee			ld (debug_mark),a  
447d 3a 8c 44			ld a, (.dmark+1)  
4480 32 6c ee			ld (debug_mark+1),a  
4483 3a 8d 44			ld a, (.dmark+2)  
4486 32 6d ee			ld (debug_mark+2),a  
4489 18 03			jr .pastdmark  
448b ..			.dmark: db "S2N"  
448e f1			.pastdmark: pop af  
448f			endm  
# End of macro DMARK
448f						CALLMONITOR 
448f cd 6f ee			call debug_vector  
4492				endm  
# End of macro CALLMONITOR
4492					endif 
4492			 
4492					;FORTH_DSP 
4492					FORTH_DSP_VALUE 
4492 cd 27 1e			call macro_forth_dsp_value 
4495				endm 
# End of macro FORTH_DSP_VALUE
4495					;inc hl 
4495			 
4495 eb					ex de, hl 
4496					if DEBUG_FORTH_WORDS 
4496						DMARK "S2a" 
4496 f5				push af  
4497 3a ab 44			ld a, (.dmark)  
449a 32 6b ee			ld (debug_mark),a  
449d 3a ac 44			ld a, (.dmark+1)  
44a0 32 6c ee			ld (debug_mark+1),a  
44a3 3a ad 44			ld a, (.dmark+2)  
44a6 32 6d ee			ld (debug_mark+2),a  
44a9 18 03			jr .pastdmark  
44ab ..			.dmark: db "S2a"  
44ae f1			.pastdmark: pop af  
44af			endm  
# End of macro DMARK
44af						CALLMONITOR 
44af cd 6f ee			call debug_vector  
44b2				endm  
# End of macro CALLMONITOR
44b2					endif 
44b2 cd dc 11				call string_to_uint16 
44b5			 
44b5					if DEBUG_FORTH_WORDS 
44b5						DMARK "S2b" 
44b5 f5				push af  
44b6 3a ca 44			ld a, (.dmark)  
44b9 32 6b ee			ld (debug_mark),a  
44bc 3a cb 44			ld a, (.dmark+1)  
44bf 32 6c ee			ld (debug_mark+1),a  
44c2 3a cc 44			ld a, (.dmark+2)  
44c5 32 6d ee			ld (debug_mark+2),a  
44c8 18 03			jr .pastdmark  
44ca ..			.dmark: db "S2b"  
44cd f1			.pastdmark: pop af  
44ce			endm  
# End of macro DMARK
44ce						CALLMONITOR 
44ce cd 6f ee			call debug_vector  
44d1				endm  
# End of macro CALLMONITOR
44d1					endif 
44d1			;		push hl 
44d1					FORTH_DSP_POP 
44d1 cd f6 1e			call macro_forth_dsp_pop 
44d4				endm 
# End of macro FORTH_DSP_POP
44d4			;		pop hl 
44d4					 
44d4					if DEBUG_FORTH_WORDS 
44d4						DMARK "S2b" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 6b ee			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 6c ee			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 6d ee			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "S2b"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed						CALLMONITOR 
44ed cd 6f ee			call debug_vector  
44f0				endm  
# End of macro CALLMONITOR
44f0					endif 
44f0 cd 47 1c				call forth_push_numhl	 
44f3			 
44f3				 
44f3				       NEXTW 
44f3 c3 f4 1f			jp macro_next 
44f6				endm 
# End of macro NEXTW
44f6			.NUM2STR: 
44f6				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44f6 48				db WORD_SYS_CORE+52             
44f7 05 45			dw .CONCAT            
44f9 08				db 7 + 1 
44fa .. 00			db "NUM2STR",0              
4502				endm 
# End of macro CWHEAD
4502			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4502			 
4502			;		; malloc a string to target 
4502			;		ld hl, 10     ; TODO max string size should be fine 
4502			;		call malloc 
4502			;		push hl    ; save malloc location 
4502			; 
4502			; 
4502			;; TODO check int type 
4502			;		FORTH_DSP_VALUEHL 
4502			;		ld a, l 
4502			;		call DispAToASCII   
4502			;;TODO need to chage above call to dump into string 
4502			; 
4502			; 
4502			 
4502				       NEXTW 
4502 c3 f4 1f			jp macro_next 
4505				endm 
# End of macro NEXTW
4505			 
4505			.CONCAT: 
4505				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4505 48				db WORD_SYS_CORE+52             
4506 b8 45			dw .FIND            
4508 07				db 6 + 1 
4509 .. 00			db "CONCAT",0              
4510				endm 
# End of macro CWHEAD
4510			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4510			 
4510			; TODO check string type 
4510			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4510			 
4510					if DEBUG_FORTH_WORDS_KEY 
4510						DMARK "CON" 
4510 f5				push af  
4511 3a 25 45			ld a, (.dmark)  
4514 32 6b ee			ld (debug_mark),a  
4517 3a 26 45			ld a, (.dmark+1)  
451a 32 6c ee			ld (debug_mark+1),a  
451d 3a 27 45			ld a, (.dmark+2)  
4520 32 6d ee			ld (debug_mark+2),a  
4523 18 03			jr .pastdmark  
4525 ..			.dmark: db "CON"  
4528 f1			.pastdmark: pop af  
4529			endm  
# End of macro DMARK
4529						CALLMONITOR 
4529 cd 6f ee			call debug_vector  
452c				endm  
# End of macro CALLMONITOR
452c					endif 
452c			 
452c			 
452c					FORTH_DSP_VALUE 
452c cd 27 1e			call macro_forth_dsp_value 
452f				endm 
# End of macro FORTH_DSP_VALUE
452f e5					push hl   ; s2 
4530			 
4530					FORTH_DSP_POP 
4530 cd f6 1e			call macro_forth_dsp_pop 
4533				endm 
# End of macro FORTH_DSP_POP
4533			 
4533					FORTH_DSP_VALUE 
4533 cd 27 1e			call macro_forth_dsp_value 
4536				endm 
# End of macro FORTH_DSP_VALUE
4536			 
4536 e5					push hl   ; s1 
4537			 
4537					FORTH_DSP_POP 
4537 cd f6 1e			call macro_forth_dsp_pop 
453a				endm 
# End of macro FORTH_DSP_POP
453a					 
453a			 
453a					; copy s1 
453a			 
453a				 
453a					; save ptr 
453a e1					pop hl  
453b e5					push hl 
453c 3e 00				ld a, 0 
453e cd 50 12				call strlent 
4541					;inc hl    ; zer0 
4541 06 00				ld b, 0 
4543 4d					ld c, l 
4544 e1					pop hl		 
4545 11 c1 e2				ld de, scratch	 
4548					if DEBUG_FORTH_WORDS 
4548						DMARK "CO1" 
4548 f5				push af  
4549 3a 5d 45			ld a, (.dmark)  
454c 32 6b ee			ld (debug_mark),a  
454f 3a 5e 45			ld a, (.dmark+1)  
4552 32 6c ee			ld (debug_mark+1),a  
4555 3a 5f 45			ld a, (.dmark+2)  
4558 32 6d ee			ld (debug_mark+2),a  
455b 18 03			jr .pastdmark  
455d ..			.dmark: db "CO1"  
4560 f1			.pastdmark: pop af  
4561			endm  
# End of macro DMARK
4561						CALLMONITOR 
4561 cd 6f ee			call debug_vector  
4564				endm  
# End of macro CALLMONITOR
4564					endif 
4564 ed b0				ldir 
4566			 
4566 e1					pop hl 
4567 e5					push hl 
4568 d5					push de 
4569			 
4569			 
4569 3e 00				ld a, 0 
456b cd 50 12				call strlent 
456e 23					inc hl    ; zer0 
456f 23					inc hl 
4570 06 00				ld b, 0 
4572 4d					ld c, l 
4573 d1					pop de 
4574 e1					pop hl		 
4575					if DEBUG_FORTH_WORDS 
4575						DMARK "CO2" 
4575 f5				push af  
4576 3a 8a 45			ld a, (.dmark)  
4579 32 6b ee			ld (debug_mark),a  
457c 3a 8b 45			ld a, (.dmark+1)  
457f 32 6c ee			ld (debug_mark+1),a  
4582 3a 8c 45			ld a, (.dmark+2)  
4585 32 6d ee			ld (debug_mark+2),a  
4588 18 03			jr .pastdmark  
458a ..			.dmark: db "CO2"  
458d f1			.pastdmark: pop af  
458e			endm  
# End of macro DMARK
458e						CALLMONITOR 
458e cd 6f ee			call debug_vector  
4591				endm  
# End of macro CALLMONITOR
4591					endif 
4591 ed b0				ldir 
4593			 
4593			 
4593			 
4593 21 c1 e2				ld hl, scratch 
4596					if DEBUG_FORTH_WORDS 
4596						DMARK "CO5" 
4596 f5				push af  
4597 3a ab 45			ld a, (.dmark)  
459a 32 6b ee			ld (debug_mark),a  
459d 3a ac 45			ld a, (.dmark+1)  
45a0 32 6c ee			ld (debug_mark+1),a  
45a3 3a ad 45			ld a, (.dmark+2)  
45a6 32 6d ee			ld (debug_mark+2),a  
45a9 18 03			jr .pastdmark  
45ab ..			.dmark: db "CO5"  
45ae f1			.pastdmark: pop af  
45af			endm  
# End of macro DMARK
45af						CALLMONITOR 
45af cd 6f ee			call debug_vector  
45b2				endm  
# End of macro CALLMONITOR
45b2					endif 
45b2			 
45b2 cd b5 1c				call forth_push_str 
45b5			 
45b5			 
45b5			 
45b5			 
45b5				       NEXTW 
45b5 c3 f4 1f			jp macro_next 
45b8				endm 
# End of macro NEXTW
45b8			 
45b8			 
45b8			.FIND: 
45b8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45b8 4b				db WORD_SYS_CORE+55             
45b9 76 46			dw .LEN            
45bb 05				db 4 + 1 
45bc .. 00			db "FIND",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45c1			 
45c1					if DEBUG_FORTH_WORDS_KEY 
45c1						DMARK "FND" 
45c1 f5				push af  
45c2 3a d6 45			ld a, (.dmark)  
45c5 32 6b ee			ld (debug_mark),a  
45c8 3a d7 45			ld a, (.dmark+1)  
45cb 32 6c ee			ld (debug_mark+1),a  
45ce 3a d8 45			ld a, (.dmark+2)  
45d1 32 6d ee			ld (debug_mark+2),a  
45d4 18 03			jr .pastdmark  
45d6 ..			.dmark: db "FND"  
45d9 f1			.pastdmark: pop af  
45da			endm  
# End of macro DMARK
45da						CALLMONITOR 
45da cd 6f ee			call debug_vector  
45dd				endm  
# End of macro CALLMONITOR
45dd					endif 
45dd			 
45dd			; TODO check string type 
45dd					FORTH_DSP_VALUE 
45dd cd 27 1e			call macro_forth_dsp_value 
45e0				endm 
# End of macro FORTH_DSP_VALUE
45e0			 
45e0 e5					push hl    
45e1 7e					ld a,(hl)    ; char to find   
45e2			; TODO change char to substr 
45e2			 
45e2 f5					push af 
45e3					 
45e3			 
45e3			 
45e3					if DEBUG_FORTH_WORDS 
45e3						DMARK "FN1" 
45e3 f5				push af  
45e4 3a f8 45			ld a, (.dmark)  
45e7 32 6b ee			ld (debug_mark),a  
45ea 3a f9 45			ld a, (.dmark+1)  
45ed 32 6c ee			ld (debug_mark+1),a  
45f0 3a fa 45			ld a, (.dmark+2)  
45f3 32 6d ee			ld (debug_mark+2),a  
45f6 18 03			jr .pastdmark  
45f8 ..			.dmark: db "FN1"  
45fb f1			.pastdmark: pop af  
45fc			endm  
# End of macro DMARK
45fc						CALLMONITOR 
45fc cd 6f ee			call debug_vector  
45ff				endm  
# End of macro CALLMONITOR
45ff					endif 
45ff			 
45ff					FORTH_DSP_POP 
45ff cd f6 1e			call macro_forth_dsp_pop 
4602				endm 
# End of macro FORTH_DSP_POP
4602			 
4602					; string to search 
4602			 
4602					FORTH_DSP_VALUE 
4602 cd 27 1e			call macro_forth_dsp_value 
4605				endm 
# End of macro FORTH_DSP_VALUE
4605			 
4605 d1					pop de  ; d is char to find  
4606			 
4606					if DEBUG_FORTH_WORDS 
4606						DMARK "FN2" 
4606 f5				push af  
4607 3a 1b 46			ld a, (.dmark)  
460a 32 6b ee			ld (debug_mark),a  
460d 3a 1c 46			ld a, (.dmark+1)  
4610 32 6c ee			ld (debug_mark+1),a  
4613 3a 1d 46			ld a, (.dmark+2)  
4616 32 6d ee			ld (debug_mark+2),a  
4619 18 03			jr .pastdmark  
461b ..			.dmark: db "FN2"  
461e f1			.pastdmark: pop af  
461f			endm  
# End of macro DMARK
461f						CALLMONITOR 
461f cd 6f ee			call debug_vector  
4622				endm  
# End of macro CALLMONITOR
4622					endif 
4622					 
4622 01 00 00				ld bc, 0 
4625 7e			.findchar:      ld a,(hl) 
4626 fe 00				cp 0   		 
4628 28 27				jr z, .finddone     
462a ba					cp d 
462b 28 20				jr z, .foundchar 
462d 03					inc bc 
462e 23					inc hl 
462f					if DEBUG_FORTH_WORDS 
462f						DMARK "FN3" 
462f f5				push af  
4630 3a 44 46			ld a, (.dmark)  
4633 32 6b ee			ld (debug_mark),a  
4636 3a 45 46			ld a, (.dmark+1)  
4639 32 6c ee			ld (debug_mark+1),a  
463c 3a 46 46			ld a, (.dmark+2)  
463f 32 6d ee			ld (debug_mark+2),a  
4642 18 03			jr .pastdmark  
4644 ..			.dmark: db "FN3"  
4647 f1			.pastdmark: pop af  
4648			endm  
# End of macro DMARK
4648						CALLMONITOR 
4648 cd 6f ee			call debug_vector  
464b				endm  
# End of macro CALLMONITOR
464b					endif 
464b 18 d8				jr .findchar 
464d			 
464d			 
464d c5			.foundchar:	push bc 
464e e1					pop hl 
464f 18 03				jr .findexit 
4651			 
4651			 
4651							 
4651			 
4651			.finddone:     ; got to end of string with no find 
4651 21 00 00				ld hl, 0 
4654			.findexit: 
4654			 
4654					if DEBUG_FORTH_WORDS 
4654						DMARK "FNd" 
4654 f5				push af  
4655 3a 69 46			ld a, (.dmark)  
4658 32 6b ee			ld (debug_mark),a  
465b 3a 6a 46			ld a, (.dmark+1)  
465e 32 6c ee			ld (debug_mark+1),a  
4661 3a 6b 46			ld a, (.dmark+2)  
4664 32 6d ee			ld (debug_mark+2),a  
4667 18 03			jr .pastdmark  
4669 ..			.dmark: db "FNd"  
466c f1			.pastdmark: pop af  
466d			endm  
# End of macro DMARK
466d						CALLMONITOR 
466d cd 6f ee			call debug_vector  
4670				endm  
# End of macro CALLMONITOR
4670					endif 
4670 cd 47 1c			call forth_push_numhl 
4673			 
4673				       NEXTW 
4673 c3 f4 1f			jp macro_next 
4676				endm 
# End of macro NEXTW
4676			 
4676			.LEN: 
4676				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4676 4c				db WORD_SYS_CORE+56             
4677 e0 46			dw .ASC            
4679 06				db 5 + 1 
467a .. 00			db "COUNT",0              
4680				endm 
# End of macro CWHEAD
4680			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4680			 
4680					if DEBUG_FORTH_WORDS_KEY 
4680						DMARK "CNT" 
4680 f5				push af  
4681 3a 95 46			ld a, (.dmark)  
4684 32 6b ee			ld (debug_mark),a  
4687 3a 96 46			ld a, (.dmark+1)  
468a 32 6c ee			ld (debug_mark+1),a  
468d 3a 97 46			ld a, (.dmark+2)  
4690 32 6d ee			ld (debug_mark+2),a  
4693 18 03			jr .pastdmark  
4695 ..			.dmark: db "CNT"  
4698 f1			.pastdmark: pop af  
4699			endm  
# End of macro DMARK
4699						CALLMONITOR 
4699 cd 6f ee			call debug_vector  
469c				endm  
# End of macro CALLMONITOR
469c					endif 
469c			; TODO check string type 
469c					FORTH_DSP_VALUE 
469c cd 27 1e			call macro_forth_dsp_value 
469f				endm 
# End of macro FORTH_DSP_VALUE
469f			 
469f			 
469f					if DEBUG_FORTH_WORDS 
469f						DMARK "CN?" 
469f f5				push af  
46a0 3a b4 46			ld a, (.dmark)  
46a3 32 6b ee			ld (debug_mark),a  
46a6 3a b5 46			ld a, (.dmark+1)  
46a9 32 6c ee			ld (debug_mark+1),a  
46ac 3a b6 46			ld a, (.dmark+2)  
46af 32 6d ee			ld (debug_mark+2),a  
46b2 18 03			jr .pastdmark  
46b4 ..			.dmark: db "CN?"  
46b7 f1			.pastdmark: pop af  
46b8			endm  
# End of macro DMARK
46b8						CALLMONITOR 
46b8 cd 6f ee			call debug_vector  
46bb				endm  
# End of macro CALLMONITOR
46bb					endif 
46bb cd 45 12				call strlenz 
46be					if DEBUG_FORTH_WORDS 
46be						DMARK "CNl" 
46be f5				push af  
46bf 3a d3 46			ld a, (.dmark)  
46c2 32 6b ee			ld (debug_mark),a  
46c5 3a d4 46			ld a, (.dmark+1)  
46c8 32 6c ee			ld (debug_mark+1),a  
46cb 3a d5 46			ld a, (.dmark+2)  
46ce 32 6d ee			ld (debug_mark+2),a  
46d1 18 03			jr .pastdmark  
46d3 ..			.dmark: db "CNl"  
46d6 f1			.pastdmark: pop af  
46d7			endm  
# End of macro DMARK
46d7						CALLMONITOR 
46d7 cd 6f ee			call debug_vector  
46da				endm  
# End of macro CALLMONITOR
46da					endif 
46da			 
46da cd 47 1c				call forth_push_numhl 
46dd			 
46dd			 
46dd			 
46dd				       NEXTW 
46dd c3 f4 1f			jp macro_next 
46e0				endm 
# End of macro NEXTW
46e0			.ASC: 
46e0				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46e0 4d				db WORD_SYS_CORE+57             
46e1 4e 47			dw .CHR            
46e3 04				db 3 + 1 
46e4 .. 00			db "ASC",0              
46e8				endm 
# End of macro CWHEAD
46e8			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46e8					if DEBUG_FORTH_WORDS_KEY 
46e8						DMARK "ASC" 
46e8 f5				push af  
46e9 3a fd 46			ld a, (.dmark)  
46ec 32 6b ee			ld (debug_mark),a  
46ef 3a fe 46			ld a, (.dmark+1)  
46f2 32 6c ee			ld (debug_mark+1),a  
46f5 3a ff 46			ld a, (.dmark+2)  
46f8 32 6d ee			ld (debug_mark+2),a  
46fb 18 03			jr .pastdmark  
46fd ..			.dmark: db "ASC"  
4700 f1			.pastdmark: pop af  
4701			endm  
# End of macro DMARK
4701						CALLMONITOR 
4701 cd 6f ee			call debug_vector  
4704				endm  
# End of macro CALLMONITOR
4704					endif 
4704					FORTH_DSP_VALUE 
4704 cd 27 1e			call macro_forth_dsp_value 
4707				endm 
# End of macro FORTH_DSP_VALUE
4707					;v5 FORTH_DSP_VALUE 
4707			;		inc hl      ; now at start of numeric as string 
4707			 
4707 e5					push hl 
4708			 
4708					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4708 cd f6 1e			call macro_forth_dsp_pop 
470b				endm 
# End of macro FORTH_DSP_POP
470b			 
470b e1					pop hl 
470c			 
470c					if DEBUG_FORTH_WORDS 
470c						DMARK "AS1" 
470c f5				push af  
470d 3a 21 47			ld a, (.dmark)  
4710 32 6b ee			ld (debug_mark),a  
4713 3a 22 47			ld a, (.dmark+1)  
4716 32 6c ee			ld (debug_mark+1),a  
4719 3a 23 47			ld a, (.dmark+2)  
471c 32 6d ee			ld (debug_mark+2),a  
471f 18 03			jr .pastdmark  
4721 ..			.dmark: db "AS1"  
4724 f1			.pastdmark: pop af  
4725			endm  
# End of macro DMARK
4725						CALLMONITOR 
4725 cd 6f ee			call debug_vector  
4728				endm  
# End of macro CALLMONITOR
4728					endif 
4728					; push the content of a onto the stack as a value 
4728			 
4728 7e					ld a,(hl)   ; get char 
4729 26 00				ld h,0 
472b 6f					ld l,a 
472c					if DEBUG_FORTH_WORDS 
472c						DMARK "AS2" 
472c f5				push af  
472d 3a 41 47			ld a, (.dmark)  
4730 32 6b ee			ld (debug_mark),a  
4733 3a 42 47			ld a, (.dmark+1)  
4736 32 6c ee			ld (debug_mark+1),a  
4739 3a 43 47			ld a, (.dmark+2)  
473c 32 6d ee			ld (debug_mark+2),a  
473f 18 03			jr .pastdmark  
4741 ..			.dmark: db "AS2"  
4744 f1			.pastdmark: pop af  
4745			endm  
# End of macro DMARK
4745						CALLMONITOR 
4745 cd 6f ee			call debug_vector  
4748				endm  
# End of macro CALLMONITOR
4748					endif 
4748 cd 47 1c				call forth_push_numhl 
474b			 
474b				       NEXTW 
474b c3 f4 1f			jp macro_next 
474e				endm 
# End of macro NEXTW
474e			 
474e			.CHR: 
474e				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
474e 4d				db WORD_SYS_CORE+57             
474f 8a 47			dw .ENDSTR            
4751 04				db 3 + 1 
4752 .. 00			db "CHR",0              
4756				endm 
# End of macro CWHEAD
4756			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4756					if DEBUG_FORTH_WORDS_KEY 
4756						DMARK "CHR" 
4756 f5				push af  
4757 3a 6b 47			ld a, (.dmark)  
475a 32 6b ee			ld (debug_mark),a  
475d 3a 6c 47			ld a, (.dmark+1)  
4760 32 6c ee			ld (debug_mark+1),a  
4763 3a 6d 47			ld a, (.dmark+2)  
4766 32 6d ee			ld (debug_mark+2),a  
4769 18 03			jr .pastdmark  
476b ..			.dmark: db "CHR"  
476e f1			.pastdmark: pop af  
476f			endm  
# End of macro DMARK
476f						CALLMONITOR 
476f cd 6f ee			call debug_vector  
4772				endm  
# End of macro CALLMONITOR
4772					endif 
4772					FORTH_DSP_VALUEHL 
4772 cd 3e 1e			call macro_dsp_valuehl 
4775				endm 
# End of macro FORTH_DSP_VALUEHL
4775			 
4775					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4775 cd f6 1e			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			 
4778					; save asci byte as a zero term string and push string 
4778			 
4778 7d					ld a,l 
4779 32 c1 e2				ld (scratch), a 
477c			 
477c 3e 00				ld a, 0 
477e 32 c2 e2				ld (scratch+1), a 
4781			 
4781 21 c1 e2				ld hl, scratch 
4784 cd b5 1c				call forth_push_str 
4787			 
4787			 
4787				       NEXTW 
4787 c3 f4 1f			jp macro_next 
478a				endm 
# End of macro NEXTW
478a			 
478a			 
478a			 
478a			 
478a			.ENDSTR: 
478a			; eof 
478a			 
# End of file forth_words_str.asm
478a			include "forth_words_key.asm" 
478a			 
478a			; | ## Keyboard Words 
478a			 
478a			.KEY: 
478a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
478a 3e				db WORD_SYS_CORE+42             
478b ba 47			dw .WAITK            
478d 04				db 3 + 1 
478e .. 00			db "KEY",0              
4792				endm 
# End of macro CWHEAD
4792			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4792			 
4792					if DEBUG_FORTH_WORDS_KEY 
4792						DMARK "KEY" 
4792 f5				push af  
4793 3a a7 47			ld a, (.dmark)  
4796 32 6b ee			ld (debug_mark),a  
4799 3a a8 47			ld a, (.dmark+1)  
479c 32 6c ee			ld (debug_mark+1),a  
479f 3a a9 47			ld a, (.dmark+2)  
47a2 32 6d ee			ld (debug_mark+2),a  
47a5 18 03			jr .pastdmark  
47a7 ..			.dmark: db "KEY"  
47aa f1			.pastdmark: pop af  
47ab			endm  
# End of macro DMARK
47ab						CALLMONITOR 
47ab cd 6f ee			call debug_vector  
47ae				endm  
# End of macro CALLMONITOR
47ae					endif 
47ae			; TODO currently waits 
47ae cd 78 65				call cin 
47b1					;call cin_wait 
47b1 6f					ld l, a 
47b2 26 00				ld h, 0 
47b4 cd 47 1c				call forth_push_numhl 
47b7					NEXTW 
47b7 c3 f4 1f			jp macro_next 
47ba				endm 
# End of macro NEXTW
47ba			.WAITK: 
47ba				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47ba 3f				db WORD_SYS_CORE+43             
47bb ec 47			dw .ACCEPT            
47bd 06				db 5 + 1 
47be .. 00			db "WAITK",0              
47c4				endm 
# End of macro CWHEAD
47c4			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47c4					if DEBUG_FORTH_WORDS_KEY 
47c4						DMARK "WAI" 
47c4 f5				push af  
47c5 3a d9 47			ld a, (.dmark)  
47c8 32 6b ee			ld (debug_mark),a  
47cb 3a da 47			ld a, (.dmark+1)  
47ce 32 6c ee			ld (debug_mark+1),a  
47d1 3a db 47			ld a, (.dmark+2)  
47d4 32 6d ee			ld (debug_mark+2),a  
47d7 18 03			jr .pastdmark  
47d9 ..			.dmark: db "WAI"  
47dc f1			.pastdmark: pop af  
47dd			endm  
# End of macro DMARK
47dd						CALLMONITOR 
47dd cd 6f ee			call debug_vector  
47e0				endm  
# End of macro CALLMONITOR
47e0					endif 
47e0 cd 70 65				call cin_wait 
47e3 6f					ld l, a 
47e4 26 00				ld h, 0 
47e6 cd 47 1c				call forth_push_numhl 
47e9					NEXTW 
47e9 c3 f4 1f			jp macro_next 
47ec				endm 
# End of macro NEXTW
47ec			.ACCEPT: 
47ec				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47ec 40				db WORD_SYS_CORE+44             
47ed 4a 48			dw .EDIT            
47ef 07				db 6 + 1 
47f0 .. 00			db "ACCEPT",0              
47f7				endm 
# End of macro CWHEAD
47f7			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47f7					; TODO crashes on push 
47f7					if DEBUG_FORTH_WORDS_KEY 
47f7						DMARK "ACC" 
47f7 f5				push af  
47f8 3a 0c 48			ld a, (.dmark)  
47fb 32 6b ee			ld (debug_mark),a  
47fe 3a 0d 48			ld a, (.dmark+1)  
4801 32 6c ee			ld (debug_mark+1),a  
4804 3a 0e 48			ld a, (.dmark+2)  
4807 32 6d ee			ld (debug_mark+2),a  
480a 18 03			jr .pastdmark  
480c ..			.dmark: db "ACC"  
480f f1			.pastdmark: pop af  
4810			endm  
# End of macro DMARK
4810						CALLMONITOR 
4810 cd 6f ee			call debug_vector  
4813				endm  
# End of macro CALLMONITOR
4813					endif 
4813 21 bf e4				ld hl, os_input 
4816 3e 00				ld a, 0 
4818 77					ld (hl),a 
4819 3a 5e ea				ld a,(f_cursor_ptr) 
481c 16 64				ld d, 100 
481e 0e 00				ld c, 0 
4820 1e 28				ld e, 40 
4822 cd 14 0e				call input_str 
4825					; TODO perhaps do a type check and wrap in quotes if not a number 
4825 21 bf e4				ld hl, os_input 
4828					if DEBUG_FORTH_WORDS 
4828						DMARK "AC1" 
4828 f5				push af  
4829 3a 3d 48			ld a, (.dmark)  
482c 32 6b ee			ld (debug_mark),a  
482f 3a 3e 48			ld a, (.dmark+1)  
4832 32 6c ee			ld (debug_mark+1),a  
4835 3a 3f 48			ld a, (.dmark+2)  
4838 32 6d ee			ld (debug_mark+2),a  
483b 18 03			jr .pastdmark  
483d ..			.dmark: db "AC1"  
4840 f1			.pastdmark: pop af  
4841			endm  
# End of macro DMARK
4841						CALLMONITOR 
4841 cd 6f ee			call debug_vector  
4844				endm  
# End of macro CALLMONITOR
4844					endif 
4844 cd b5 1c				call forth_push_str 
4847					NEXTW 
4847 c3 f4 1f			jp macro_next 
484a				endm 
# End of macro NEXTW
484a			 
484a			.EDIT: 
484a				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
484a 40				db WORD_SYS_CORE+44             
484b ec 48			dw .DEDIT            
484d 05				db 4 + 1 
484e .. 00			db "EDIT",0              
4853				endm 
# End of macro CWHEAD
4853			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4853			 
4853					; TODO does not copy from stack 
4853					if DEBUG_FORTH_WORDS_KEY 
4853						DMARK "EDT" 
4853 f5				push af  
4854 3a 68 48			ld a, (.dmark)  
4857 32 6b ee			ld (debug_mark),a  
485a 3a 69 48			ld a, (.dmark+1)  
485d 32 6c ee			ld (debug_mark+1),a  
4860 3a 6a 48			ld a, (.dmark+2)  
4863 32 6d ee			ld (debug_mark+2),a  
4866 18 03			jr .pastdmark  
4868 ..			.dmark: db "EDT"  
486b f1			.pastdmark: pop af  
486c			endm  
# End of macro DMARK
486c						CALLMONITOR 
486c cd 6f ee			call debug_vector  
486f				endm  
# End of macro CALLMONITOR
486f					endif 
486f			 
486f					;FORTH_DSP 
486f					FORTH_DSP_VALUEHL 
486f cd 3e 1e			call macro_dsp_valuehl 
4872				endm 
# End of macro FORTH_DSP_VALUEHL
4872			;		inc hl    ; TODO do type check 
4872			 
4872			;		call get_word_hl 
4872 e5					push hl 
4873					if DEBUG_FORTH_WORDS 
4873						DMARK "EDp" 
4873 f5				push af  
4874 3a 88 48			ld a, (.dmark)  
4877 32 6b ee			ld (debug_mark),a  
487a 3a 89 48			ld a, (.dmark+1)  
487d 32 6c ee			ld (debug_mark+1),a  
4880 3a 8a 48			ld a, (.dmark+2)  
4883 32 6d ee			ld (debug_mark+2),a  
4886 18 03			jr .pastdmark  
4888 ..			.dmark: db "EDp"  
488b f1			.pastdmark: pop af  
488c			endm  
# End of macro DMARK
488c						CALLMONITOR 
488c cd 6f ee			call debug_vector  
488f				endm  
# End of macro CALLMONITOR
488f					endif 
488f				;	ld a, 0 
488f cd 45 12				call strlenz 
4892 23					inc hl 
4893			 
4893 06 00				ld b, 0 
4895 4d					ld c, l 
4896			 
4896 e1					pop hl 
4897 11 bf e4				ld de, os_input 
489a					if DEBUG_FORTH_WORDS_KEY 
489a						DMARK "EDc" 
489a f5				push af  
489b 3a af 48			ld a, (.dmark)  
489e 32 6b ee			ld (debug_mark),a  
48a1 3a b0 48			ld a, (.dmark+1)  
48a4 32 6c ee			ld (debug_mark+1),a  
48a7 3a b1 48			ld a, (.dmark+2)  
48aa 32 6d ee			ld (debug_mark+2),a  
48ad 18 03			jr .pastdmark  
48af ..			.dmark: db "EDc"  
48b2 f1			.pastdmark: pop af  
48b3			endm  
# End of macro DMARK
48b3						CALLMONITOR 
48b3 cd 6f ee			call debug_vector  
48b6				endm  
# End of macro CALLMONITOR
48b6					endif 
48b6 ed b0				ldir 
48b8			 
48b8			 
48b8 21 bf e4				ld hl, os_input 
48bb					;ld a, 0 
48bb					;ld (hl),a 
48bb 3a 5e ea				ld a,(f_cursor_ptr) 
48be 16 64				ld d, 100 
48c0 0e 00				ld c, 0 
48c2 1e 28				ld e, 40 
48c4 cd 14 0e				call input_str 
48c7					; TODO perhaps do a type check and wrap in quotes if not a number 
48c7 21 bf e4				ld hl, os_input 
48ca					if DEBUG_FORTH_WORDS 
48ca						DMARK "ED1" 
48ca f5				push af  
48cb 3a df 48			ld a, (.dmark)  
48ce 32 6b ee			ld (debug_mark),a  
48d1 3a e0 48			ld a, (.dmark+1)  
48d4 32 6c ee			ld (debug_mark+1),a  
48d7 3a e1 48			ld a, (.dmark+2)  
48da 32 6d ee			ld (debug_mark+2),a  
48dd 18 03			jr .pastdmark  
48df ..			.dmark: db "ED1"  
48e2 f1			.pastdmark: pop af  
48e3			endm  
# End of macro DMARK
48e3						CALLMONITOR 
48e3 cd 6f ee			call debug_vector  
48e6				endm  
# End of macro CALLMONITOR
48e6					endif 
48e6 cd b5 1c				call forth_push_str 
48e9					NEXTW 
48e9 c3 f4 1f			jp macro_next 
48ec				endm 
# End of macro NEXTW
48ec			 
48ec			.DEDIT: 
48ec				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48ec 40				db WORD_SYS_CORE+44             
48ed 4e 49			dw .ENDKEY            
48ef 06				db 5 + 1 
48f0 .. 00			db "DEDIT",0              
48f6				endm 
# End of macro CWHEAD
48f6			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48f6			 
48f6					; TODO does not copy from stack 
48f6					if DEBUG_FORTH_WORDS_KEY 
48f6						DMARK "DED" 
48f6 f5				push af  
48f7 3a 0b 49			ld a, (.dmark)  
48fa 32 6b ee			ld (debug_mark),a  
48fd 3a 0c 49			ld a, (.dmark+1)  
4900 32 6c ee			ld (debug_mark+1),a  
4903 3a 0d 49			ld a, (.dmark+2)  
4906 32 6d ee			ld (debug_mark+2),a  
4909 18 03			jr .pastdmark  
490b ..			.dmark: db "DED"  
490e f1			.pastdmark: pop af  
490f			endm  
# End of macro DMARK
490f						CALLMONITOR 
490f cd 6f ee			call debug_vector  
4912				endm  
# End of macro CALLMONITOR
4912					endif 
4912			 
4912					;FORTH_DSP 
4912					FORTH_DSP_VALUEHL 
4912 cd 3e 1e			call macro_dsp_valuehl 
4915				endm 
# End of macro FORTH_DSP_VALUEHL
4915			;		inc hl    ; TODO do type check 
4915			 
4915			;		call get_word_hl 
4915 e5					push hl 
4916 e5					push hl 
4917					FORTH_DSP_POP 
4917 cd f6 1e			call macro_forth_dsp_pop 
491a				endm 
# End of macro FORTH_DSP_POP
491a e1					pop hl 
491b					if DEBUG_FORTH_WORDS 
491b						DMARK "EDp" 
491b f5				push af  
491c 3a 30 49			ld a, (.dmark)  
491f 32 6b ee			ld (debug_mark),a  
4922 3a 31 49			ld a, (.dmark+1)  
4925 32 6c ee			ld (debug_mark+1),a  
4928 3a 32 49			ld a, (.dmark+2)  
492b 32 6d ee			ld (debug_mark+2),a  
492e 18 03			jr .pastdmark  
4930 ..			.dmark: db "EDp"  
4933 f1			.pastdmark: pop af  
4934			endm  
# End of macro DMARK
4934						CALLMONITOR 
4934 cd 6f ee			call debug_vector  
4937				endm  
# End of macro CALLMONITOR
4937					endif 
4937				;	ld a, 0 
4937 cd 45 12				call strlenz 
493a 23					inc hl 
493b			 
493b 06 00				ld b, 0 
493d 4d					ld c, l 
493e			 
493e e1					pop hl 
493f			 
493f					;ld a, 0 
493f					;ld (hl),a 
493f 3a 5e ea				ld a,(f_cursor_ptr) 
4942 16 64				ld d, 100 
4944 0e 00				ld c, 0 
4946 1e 28				ld e, 40 
4948 cd 14 0e				call input_str 
494b					; TODO perhaps do a type check and wrap in quotes if not a number 
494b					NEXTW 
494b c3 f4 1f			jp macro_next 
494e				endm 
# End of macro NEXTW
494e			 
494e			 
494e			.ENDKEY: 
494e			; eof 
494e			 
# End of file forth_words_key.asm
494e			include "forth_words_const.asm" 
494e			 
494e			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
494e			 
494e			 
494e			.SPITIME: 
494e				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
494e 77				db WORD_SYS_CORE+99             
494f 63 49			dw .VA            
4951 08				db 7 + 1 
4952 .. 00			db "SPITIME",0              
495a				endm 
# End of macro CWHEAD
495a			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
495a			; 
495a			; | If using BANK devices then leave as is. 
495a			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
495a			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
495a			 
495a 21 64 ea				ld hl, spi_clktime  
495d cd 47 1c				call forth_push_numhl 
4960			 
4960					NEXTW 
4960 c3 f4 1f			jp macro_next 
4963				endm 
# End of macro NEXTW
4963			 
4963			 
4963			.VA: 
4963				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4963 77				db WORD_SYS_CORE+99             
4964 73 49			dw .SYMBOL            
4966 03				db 2 + 1 
4967 .. 00			db "VA",0              
496a				endm 
# End of macro CWHEAD
496a			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
496a 21 28 ea				ld hl, cli_var_array 
496d cd 47 1c				call forth_push_numhl 
4970			 
4970					NEXTW 
4970 c3 f4 1f			jp macro_next 
4973				endm 
# End of macro NEXTW
4973			 
4973			.SYMBOL: 
4973				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4973 77				db WORD_SYS_CORE+99             
4974 7d 4a			dw .ENDCONST            
4976 07				db 6 + 1 
4977 .. 00			db "SYMBOL",0              
497e				endm 
# End of macro CWHEAD
497e			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
497e			; | 
497e			; | The value is the number reference and the final address is pushed to stack 
497e			 
497e			; | dw sym_table 
497e			; | dw nmi_vector 
497e			; | dw cli_autodisplay 
497e			; | dw cli_data_sp 
497e			; | dw cli_data_stack 
497e			; | dw cli_loop_sp 
497e			; | dw cli_loop_stack 
497e			; | dw cli_var_array 
497e			; | dw cursor_col 
497e			; | dw cursor_ptr 
497e			; | ; 10 
497e			; | dw cursor_row 
497e			; | dw debug_mark 
497e			; | dw display_fb0 
497e			; | dw display_fb1 
497e			; | dw display_fb2 
497e			; | dw display_fb3 
497e			; | dw display_fb_active 
497e			; | dw execscratch 
497e			; | dw f_cursor_ptr 
497e			; | dw hardware_word 
497e			; | ;20 
497e			; | dw input_at_cursor 
497e			; | dw input_at_pos 
497e			; | dw input_cur_flash 
497e			; | dw input_cur_onoff 
497e			; | dw input_cursor 
497e			; | dw input_display_size 
497e			; | dw input_len 
497e			; | dw input_ptr 
497e			; | dw input_size 
497e			; | dw input_start 
497e			; | ; 30 
497e			; | dw input_str 
497e			; | dw input_under_cursor 
497e			; | dw os_cli_cmd 
497e			; | dw os_cur_ptr 
497e			; | dw os_current_i 
497e			; | dw os_input 
497e			; | dw os_last_cmd 
497e			; | dw os_last_new_uword 
497e			; | dw debug_vector 
497e			; | dw os_view_hl 
497e			; | ;40 
497e			; | dw os_word_scratch 
497e			; | dw portbctl 
497e			; | dw portbdata 
497e			; | dw spi_cartdev 
497e			; | dw spi_cartdev2 
497e			; | dw spi_clktime 
497e			; | dw spi_device 
497e			; | dw spi_device_id 
497e			; | dw spi_portbyte 
497e			; | dw stackstore 
497e			; | ; 50 
497e			; | if STORAGE_SE 
497e			; | dw storage_actl 
497e			; | dw storage_adata 
497e			; | else 
497e			; | dw 0 
497e			; | dw 0 
497e			; | endif 
497e			; | dw storage_append 
497e			; | if STORAGE_SE 
497e			; | dw storage_bctl 
497e			; | else 
497e			; | dw 0 
497e			; | endif 
497e			; | dw store_bank_active 
497e			; | dw store_filecache 
497e			; | dw store_longread 
497e			; | dw store_openaddr 
497e			; | dw store_openext 
497e			; | dw store_openmaxext 
497e			; | ; 60 
497e			; | dw store_page 
497e			; | dw store_readbuf 
497e			; | dw store_readcont 
497e			; | dw store_readptr 
497e			; | dw store_tmpext 
497e			; | dw store_tmpid 
497e			; | dw store_tmppageid 
497e			; | dw malloc 
497e			; | dw free 
497e			; | dw cin 
497e			; | ; 70 
497e			; | dw cin_wait 
497e			; | dw forth_push_numhl 
497e			; | dw forth_push_str 
497e			 
497e					if DEBUG_FORTH_WORDS_KEY 
497e						DMARK "SYM" 
497e f5				push af  
497f 3a 93 49			ld a, (.dmark)  
4982 32 6b ee			ld (debug_mark),a  
4985 3a 94 49			ld a, (.dmark+1)  
4988 32 6c ee			ld (debug_mark+1),a  
498b 3a 95 49			ld a, (.dmark+2)  
498e 32 6d ee			ld (debug_mark+2),a  
4991 18 03			jr .pastdmark  
4993 ..			.dmark: db "SYM"  
4996 f1			.pastdmark: pop af  
4997			endm  
# End of macro DMARK
4997						CALLMONITOR 
4997 cd 6f ee			call debug_vector  
499a				endm  
# End of macro CALLMONITOR
499a					endif 
499a			 
499a					FORTH_DSP_VALUEHL 
499a cd 3e 1e			call macro_dsp_valuehl 
499d				endm 
# End of macro FORTH_DSP_VALUEHL
499d			 
499d 7d					ld a, l     
499e			 
499e			 
499e					if DEBUG_FORTH_WORDS 
499e						DMARK "SY1" 
499e f5				push af  
499f 3a b3 49			ld a, (.dmark)  
49a2 32 6b ee			ld (debug_mark),a  
49a5 3a b4 49			ld a, (.dmark+1)  
49a8 32 6c ee			ld (debug_mark+1),a  
49ab 3a b5 49			ld a, (.dmark+2)  
49ae 32 6d ee			ld (debug_mark+2),a  
49b1 18 03			jr .pastdmark  
49b3 ..			.dmark: db "SY1"  
49b6 f1			.pastdmark: pop af  
49b7			endm  
# End of macro DMARK
49b7						CALLMONITOR 
49b7 cd 6f ee			call debug_vector  
49ba				endm  
# End of macro CALLMONITOR
49ba					endif 
49ba					 
49ba f5					push af	 
49bb					FORTH_DSP_POP 
49bb cd f6 1e			call macro_forth_dsp_pop 
49be				endm 
# End of macro FORTH_DSP_POP
49be f1					pop af 
49bf			 
49bf cb 27				sla a  
49c1				 
49c1					 
49c1					if DEBUG_FORTH_WORDS 
49c1						DMARK "SY" 
49c1 f5				push af  
49c2 3a d6 49			ld a, (.dmark)  
49c5 32 6b ee			ld (debug_mark),a  
49c8 3a d7 49			ld a, (.dmark+1)  
49cb 32 6c ee			ld (debug_mark+1),a  
49ce 3a d8 49			ld a, (.dmark+2)  
49d1 32 6d ee			ld (debug_mark+2),a  
49d4 18 02			jr .pastdmark  
49d6 ..			.dmark: db "SY"  
49d8 f1			.pastdmark: pop af  
49d9			endm  
# End of macro DMARK
49d9						CALLMONITOR 
49d9 cd 6f ee			call debug_vector  
49dc				endm  
# End of macro CALLMONITOR
49dc					endif 
49dc			 
49dc 21 eb 49				ld hl, sym_table 
49df cd e7 0d				call addatohl 
49e2 cd 76 1f				call loadwordinhl 
49e5 cd 47 1c				call forth_push_numhl 
49e8			 
49e8			 
49e8				       NEXTW 
49e8 c3 f4 1f			jp macro_next 
49eb				endm 
# End of macro NEXTW
49eb			 
49eb			sym_table: 
49eb			 
49eb			; 0 
49eb eb 49		dw sym_table 
49ed 72 ee		dw nmi_vector 
49ef 3c ea		dw cli_autodisplay 
49f1 ee e9		dw cli_data_sp 
49f3 28 e8		dw cli_data_stack 
49f5 f0 e9		dw cli_loop_sp 
49f7 2a e9		dw cli_loop_stack 
49f9 28 ea		dw cli_var_array 
49fb c5 eb		dw cursor_col 
49fd c3 eb		dw cursor_ptr 
49ff			; 10 
49ff c4 eb		dw cursor_row 
4a01 6b ee		dw debug_mark 
4a03 b1 ed		dw display_fb0 
4a05 10 ed		dw display_fb1 
4a07 ce eb		dw display_fb2 
4a09 6f ec		dw display_fb3 
4a0b cc eb		dw display_fb_active 
4a0d c0 e3		dw execscratch 
4a0f 5e ea		dw f_cursor_ptr 
4a11 75 ee		dw hardware_word 
4a13			;20 
4a13 62 ee		dw input_at_cursor 
4a15 64 ee		dw input_at_pos 
4a17 60 ee		dw input_cur_flash 
4a19 5f ee		dw input_cur_onoff 
4a1b 55 ee		dw input_cursor 
4a1d 65 ee		dw input_display_size 
4a1f 5a ee		dw input_len 
4a21 69 ee		dw input_ptr 
4a23 66 ee		dw input_size 
4a25 67 ee		dw input_start 
4a27			; 30 
4a27 14 0e		dw input_str 
4a29 63 ee		dw input_under_cursor 
4a2b e8 e5		dw os_cli_cmd 
4a2d e4 e5		dw os_cur_ptr 
4a2f e6 e5		dw os_current_i 
4a31 bf e4		dw os_input 
4a33 e7 e6		dw os_last_cmd 
4a35 be e5		dw os_last_new_uword 
4a37 6f ee		dw debug_vector 
4a39 a3 e2		dw os_view_hl 
4a3b			;40 
4a3b c6 e5		dw os_word_scratch 
4a3d c3 00		dw portbctl 
4a3f c1 00		dw portbdata 
4a41 63 ea		dw spi_cartdev 
4a43 62 ea		dw spi_cartdev2 
4a45 64 ea		dw spi_clktime 
4a47 60 ea		dw spi_device 
4a49 5f ea		dw spi_device_id 
4a4b 61 ea		dw spi_portbyte 
4a4d a7 eb		dw stackstore 
4a4f			; 50 
4a4f			if STORAGE_SE 
4a4f			dw storage_actl 
4a4f			dw storage_adata 
4a4f			else 
4a4f 00 00		dw 0 
4a51 00 00		dw 0 
4a53			endif 
4a53 69 09		dw storage_append 
4a55			if STORAGE_SE 
4a55			dw storage_bctl 
4a55			else 
4a55 00 00		dw 0 
4a57			endif 
4a57 93 eb		dw store_bank_active 
4a59 67 ea		dw store_filecache 
4a5b 75 ea		dw store_longread 
4a5d 6b ea		dw store_openaddr 
4a5f 6a ea		dw store_openext 
4a61 69 ea		dw store_openmaxext 
4a63			; 60 
4a63 7a ea		dw store_page 
4a65 76 ea		dw store_readbuf 
4a67 6d ea		dw store_readcont 
4a69 78 ea		dw store_readptr 
4a6b 6d ea		dw store_tmpext 
4a6d 6e ea		dw store_tmpid 
4a6f 65 ea		dw store_tmppageid 
4a71 ae 12		dw malloc 
4a73 78 13		dw free 
4a75 78 65		dw cin 
4a77			; 70 
4a77 70 65		dw cin_wait 
4a79 47 1c		dw forth_push_numhl 
4a7b b5 1c		dw forth_push_str 
4a7d			 
4a7d			 
4a7d			.ENDCONST: 
4a7d			 
4a7d			; eof 
4a7d			 
4a7d			 
# End of file forth_words_const.asm
4a7d			 
4a7d			if STORAGE_SE 
4a7d			   	include "forth_words_storage.asm" 
4a7d			endif 
4a7d				include "forth_words_device.asm" 
4a7d			; Device related words 
4a7d			 
4a7d			; | ## Device Words 
4a7d			 
4a7d			;if SOUND_ENABLE 
4a7d			;.NOTE: 
4a7d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a7d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a7d			;		if DEBUG_FORTH_WORDS_KEY 
4a7d			;			DMARK "NTE" 
4a7d			;			CALLMONITOR 
4a7d			;		endif 
4a7d			; 
4a7d			;	 
4a7d			; 
4a7d			;		NEXTW 
4a7d			;.AFTERSOUND: 
4a7d			;endif 
4a7d			 
4a7d			 
4a7d			USE_GPIO: equ 0 
4a7d			 
4a7d			if USE_GPIO 
4a7d			.GP1: 
4a7d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a7d			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a7d					NEXTW 
4a7d			.GP2: 
4a7d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a7d			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a7d			 
4a7d					NEXTW 
4a7d			 
4a7d			.GP3: 
4a7d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a7d			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a7d			 
4a7d					NEXTW 
4a7d			 
4a7d			.GP4: 
4a7d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a7d			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a7d			 
4a7d					NEXTW 
4a7d			.SIN: 
4a7d			 
4a7d			 
4a7d			endif 
4a7d			 
4a7d			 
4a7d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a7d 33				db WORD_SYS_CORE+31             
4a7e b2 4a			dw .SOUT            
4a80 03				db 2 + 1 
4a81 .. 00			db "IN",0              
4a84				endm 
# End of macro CWHEAD
4a84			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a84					if DEBUG_FORTH_WORDS_KEY 
4a84						DMARK "IN." 
4a84 f5				push af  
4a85 3a 99 4a			ld a, (.dmark)  
4a88 32 6b ee			ld (debug_mark),a  
4a8b 3a 9a 4a			ld a, (.dmark+1)  
4a8e 32 6c ee			ld (debug_mark+1),a  
4a91 3a 9b 4a			ld a, (.dmark+2)  
4a94 32 6d ee			ld (debug_mark+2),a  
4a97 18 03			jr .pastdmark  
4a99 ..			.dmark: db "IN."  
4a9c f1			.pastdmark: pop af  
4a9d			endm  
# End of macro DMARK
4a9d						CALLMONITOR 
4a9d cd 6f ee			call debug_vector  
4aa0				endm  
# End of macro CALLMONITOR
4aa0					endif 
4aa0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa0 cd 3e 1e			call macro_dsp_valuehl 
4aa3				endm 
# End of macro FORTH_DSP_VALUEHL
4aa3			 
4aa3 e5					push hl 
4aa4			 
4aa4					; destroy value TOS 
4aa4			 
4aa4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa4 cd f6 1e			call macro_forth_dsp_pop 
4aa7				endm 
# End of macro FORTH_DSP_POP
4aa7			 
4aa7					; one value on hl get other one back 
4aa7			 
4aa7 c1					pop bc 
4aa8			 
4aa8					; do the sub 
4aa8			;		ex de, hl 
4aa8			 
4aa8 ed 68				in l,(c) 
4aaa			 
4aaa					; save it 
4aaa			 
4aaa 26 00				ld h,0 
4aac			 
4aac					; TODO push value back onto stack for another op etc 
4aac			 
4aac cd 47 1c				call forth_push_numhl 
4aaf					NEXTW 
4aaf c3 f4 1f			jp macro_next 
4ab2				endm 
# End of macro NEXTW
4ab2			.SOUT: 
4ab2				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ab2 34				db WORD_SYS_CORE+32             
4ab3 05 4b			dw .SPIO            
4ab5 04				db 3 + 1 
4ab6 .. 00			db "OUT",0              
4aba				endm 
# End of macro CWHEAD
4aba			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4aba					if DEBUG_FORTH_WORDS_KEY 
4aba						DMARK "OUT" 
4aba f5				push af  
4abb 3a cf 4a			ld a, (.dmark)  
4abe 32 6b ee			ld (debug_mark),a  
4ac1 3a d0 4a			ld a, (.dmark+1)  
4ac4 32 6c ee			ld (debug_mark+1),a  
4ac7 3a d1 4a			ld a, (.dmark+2)  
4aca 32 6d ee			ld (debug_mark+2),a  
4acd 18 03			jr .pastdmark  
4acf ..			.dmark: db "OUT"  
4ad2 f1			.pastdmark: pop af  
4ad3			endm  
# End of macro DMARK
4ad3						CALLMONITOR 
4ad3 cd 6f ee			call debug_vector  
4ad6				endm  
# End of macro CALLMONITOR
4ad6					endif 
4ad6			 
4ad6					; get port 
4ad6			 
4ad6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad6 cd 3e 1e			call macro_dsp_valuehl 
4ad9				endm 
# End of macro FORTH_DSP_VALUEHL
4ad9			 
4ad9 e5					push hl 
4ada			 
4ada					; destroy value TOS 
4ada			 
4ada					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ada cd f6 1e			call macro_forth_dsp_pop 
4add				endm 
# End of macro FORTH_DSP_POP
4add			 
4add					; get byte to send 
4add			 
4add					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4add cd 3e 1e			call macro_dsp_valuehl 
4ae0				endm 
# End of macro FORTH_DSP_VALUEHL
4ae0			 
4ae0			;		push hl 
4ae0			 
4ae0					; destroy value TOS 
4ae0			 
4ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae0 cd f6 1e			call macro_forth_dsp_pop 
4ae3				endm 
# End of macro FORTH_DSP_POP
4ae3			 
4ae3					; one value on hl get other one back 
4ae3			 
4ae3			;		pop hl 
4ae3			 
4ae3 c1					pop bc 
4ae4			 
4ae4					if DEBUG_FORTH_WORDS 
4ae4						DMARK "OUT" 
4ae4 f5				push af  
4ae5 3a f9 4a			ld a, (.dmark)  
4ae8 32 6b ee			ld (debug_mark),a  
4aeb 3a fa 4a			ld a, (.dmark+1)  
4aee 32 6c ee			ld (debug_mark+1),a  
4af1 3a fb 4a			ld a, (.dmark+2)  
4af4 32 6d ee			ld (debug_mark+2),a  
4af7 18 03			jr .pastdmark  
4af9 ..			.dmark: db "OUT"  
4afc f1			.pastdmark: pop af  
4afd			endm  
# End of macro DMARK
4afd						CALLMONITOR 
4afd cd 6f ee			call debug_vector  
4b00				endm  
# End of macro CALLMONITOR
4b00					endif 
4b00			 
4b00 ed 69				out (c), l 
4b02			 
4b02					NEXTW 
4b02 c3 f4 1f			jp macro_next 
4b05				endm 
# End of macro NEXTW
4b05			 
4b05			 
4b05			.SPIO: 
4b05			 
4b05			if STORAGE_SE 
4b05				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b05			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b05			 
4b05					call spi_ce_low 
4b05			    NEXTW 
4b05			 
4b05			.SPICEH: 
4b05				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b05			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b05			 
4b05					call spi_ce_high 
4b05			    NEXTW 
4b05			 
4b05			 
4b05			.SPIOb: 
4b05			 
4b05				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b05			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b05			 
4b05					if DEBUG_FORTH_WORDS_KEY 
4b05						DMARK "SPo" 
4b05						CALLMONITOR 
4b05					endif 
4b05					; get port 
4b05			 
4b05			 
4b05					; get byte to send 
4b05			 
4b05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b05			 
4b05			;		push hl    ; u1  
4b05			 
4b05					; destroy value TOS 
4b05			 
4b05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b05			 
4b05					; one value on hl get other one back 
4b05			 
4b05			;		pop hl   ; u2 - addr 
4b05			 
4b05					; TODO Send SPI byte 
4b05			 
4b05			;		push hl 
4b05			;		call spi_ce_low 
4b05			;		pop hl 
4b05					ld a, l 
4b05					call spi_send_byte 
4b05			;		call spi_ce_high 
4b05			 
4b05					NEXTW 
4b05			 
4b05			.SPII: 
4b05				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b05			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b05					if DEBUG_FORTH_WORDS_KEY 
4b05						DMARK "SPi" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					; TODO Get SPI byte 
4b05			 
4b05					call spi_read_byte 
4b05			 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "Si2" 
4b05						CALLMONITOR 
4b05					endif 
4b05					ld h, 0 
4b05					ld l, a 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "Si3" 
4b05						CALLMONITOR 
4b05					endif 
4b05					call forth_push_numhl 
4b05			 
4b05					NEXTW 
4b05			 
4b05			 
4b05			 
4b05			.SESEL: 
4b05				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b05			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b05					if DEBUG_FORTH_WORDS_KEY 
4b05						DMARK "BNK" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					ld a, 255 
4b05					ld (spi_cartdev), a 
4b05			 
4b05					; get bank 
4b05			 
4b05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b05			 
4b05			;		push hl 
4b05			 
4b05					; destroy value TOS 
4b05			 
4b05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b05			 
4b05					; one value on hl get other one back 
4b05			 
4b05			;		pop hl 
4b05			 
4b05			 
4b05					ld c, SPI_CE_HIGH 
4b05					ld b, '0'    ; human readable bank number 
4b05			 
4b05					ld a, l 
4b05			 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "BNK" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					; active low 
4b05			 
4b05					cp 0 
4b05					jr z, .bset 
4b05					cp 1 
4b05					jr nz, .b2 
4b05					res 0, c 
4b05					ld b, '1'    ; human readable bank number 
4b05			.b2:		cp 2 
4b05					jr nz, .b3 
4b05					res 1, c 
4b05					ld b, '2'    ; human readable bank number 
4b05			.b3:		cp 3 
4b05					jr nz, .b4 
4b05					res 2, c 
4b05					ld b, '3'    ; human readable bank number 
4b05			.b4:		cp 4 
4b05					jr nz, .b5 
4b05					res 3, c 
4b05					ld b, '4'    ; human readable bank number 
4b05			.b5:		cp 5 
4b05					jr nz, .bset 
4b05					res 4, c 
4b05					ld b, '5'    ; human readable bank number 
4b05			 
4b05			.bset: 
4b05					ld a, c 
4b05					ld (spi_device),a 
4b05					ld a, b 
4b05					ld (spi_device_id),a 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "BN2" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					; set default SPI clk pulse time as disabled for BANK use 
4b05			 
4b05					ld a, 0 
4b05					ld (spi_clktime), a 
4b05			 
4b05					NEXTW 
4b05			 
4b05			.CARTDEV: 
4b05				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b05			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b05					if DEBUG_FORTH_WORDS_KEY 
4b05						DMARK "CDV" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					; disable se storage bank selection 
4b05			 
4b05					ld a, SPI_CE_HIGH		; ce high 
4b05					ld (spi_device), a 
4b05			 
4b05					; get bank 
4b05			 
4b05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b05			 
4b05			;		push hl 
4b05			 
4b05					; destroy value TOS 
4b05			 
4b05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b05			 
4b05					; one value on hl get other one back 
4b05			 
4b05			;		pop hl 
4b05			 
4b05					; active low 
4b05			 
4b05					ld c, 255 
4b05			 
4b05					ld a, l 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "CDV" 
4b05						CALLMONITOR 
4b05					endif 
4b05					cp 0 
4b05					jr z, .cset 
4b05					cp 1 
4b05					jr nz, .c2 
4b05					res 0, c 
4b05			.c2:		cp 2 
4b05					jr nz, .c3 
4b05					res 1, c 
4b05			.c3:		cp 3 
4b05					jr nz, .c4 
4b05					res 2, c 
4b05			.c4:		cp 4 
4b05					jr nz, .c5 
4b05					res 3, c 
4b05			.c5:		cp 5 
4b05					jr nz, .c6 
4b05					res 4, c 
4b05			.c6:		cp 6 
4b05					jr nz, .c7 
4b05					res 5, c 
4b05			.c7:		cp 7 
4b05					jr nz, .c8 
4b05					res 6, c 
4b05			.c8:		cp 8 
4b05					jr nz, .cset 
4b05					res 7, c 
4b05			.cset:		ld a, c 
4b05					ld (spi_cartdev),a 
4b05			 
4b05					if DEBUG_FORTH_WORDS 
4b05						DMARK "CD2" 
4b05						CALLMONITOR 
4b05					endif 
4b05			 
4b05					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b05			 
4b05					ld a, $0a 
4b05					ld (spi_clktime), a 
4b05					NEXTW 
4b05			endif 
4b05			 
4b05			.ENDDEVICE: 
4b05			; eof 
4b05			 
# End of file forth_words_device.asm
4b05			 
4b05			; var handler 
4b05			 
4b05			 
4b05			.VARS: 
4b05				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b05 77				db WORD_SYS_CORE+99             
4b06 b6 4b			dw .V0            
4b08 04				db 3 + 1 
4b09 .. 00			db "VAR",0              
4b0d				endm 
# End of macro CWHEAD
4b0d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b0d			;| 
4b0d			;| The variable name should consist of a single letter. e.g. "a" 
4b0d			;! If a full string is passed then only the first char is looked at 
4b0d			;| Any other char could exceed bounds checks!  
4b0d			 
4b0d					if DEBUG_FORTH_WORDS_KEY 
4b0d						DMARK "VAR" 
4b0d f5				push af  
4b0e 3a 22 4b			ld a, (.dmark)  
4b11 32 6b ee			ld (debug_mark),a  
4b14 3a 23 4b			ld a, (.dmark+1)  
4b17 32 6c ee			ld (debug_mark+1),a  
4b1a 3a 24 4b			ld a, (.dmark+2)  
4b1d 32 6d ee			ld (debug_mark+2),a  
4b20 18 03			jr .pastdmark  
4b22 ..			.dmark: db "VAR"  
4b25 f1			.pastdmark: pop af  
4b26			endm  
# End of macro DMARK
4b26						CALLMONITOR 
4b26 cd 6f ee			call debug_vector  
4b29				endm  
# End of macro CALLMONITOR
4b29					endif 
4b29			 
4b29					FORTH_DSP_VALUEHL 
4b29 cd 3e 1e			call macro_dsp_valuehl 
4b2c				endm 
# End of macro FORTH_DSP_VALUEHL
4b2c			 
4b2c 7e					ld a, (hl)    ; get first char on of the string 
4b2d			 
4b2d			 
4b2d					if DEBUG_FORTH_WORDS 
4b2d						DMARK "VR1" 
4b2d f5				push af  
4b2e 3a 42 4b			ld a, (.dmark)  
4b31 32 6b ee			ld (debug_mark),a  
4b34 3a 43 4b			ld a, (.dmark+1)  
4b37 32 6c ee			ld (debug_mark+1),a  
4b3a 3a 44 4b			ld a, (.dmark+2)  
4b3d 32 6d ee			ld (debug_mark+2),a  
4b40 18 03			jr .pastdmark  
4b42 ..			.dmark: db "VR1"  
4b45 f1			.pastdmark: pop af  
4b46			endm  
# End of macro DMARK
4b46						CALLMONITOR 
4b46 cd 6f ee			call debug_vector  
4b49				endm  
# End of macro CALLMONITOR
4b49					endif 
4b49					 
4b49 f5					push af	 
4b4a					FORTH_DSP_POP 
4b4a cd f6 1e			call macro_forth_dsp_pop 
4b4d				endm 
# End of macro FORTH_DSP_POP
4b4d f1					pop af 
4b4e			 
4b4e					; convert to upper 
4b4e			 
4b4e cd 54 11				call to_upper 
4b51					if DEBUG_FORTH_WORDS 
4b51						DMARK "Vaa" 
4b51 f5				push af  
4b52 3a 66 4b			ld a, (.dmark)  
4b55 32 6b ee			ld (debug_mark),a  
4b58 3a 67 4b			ld a, (.dmark+1)  
4b5b 32 6c ee			ld (debug_mark+1),a  
4b5e 3a 68 4b			ld a, (.dmark+2)  
4b61 32 6d ee			ld (debug_mark+2),a  
4b64 18 03			jr .pastdmark  
4b66 ..			.dmark: db "Vaa"  
4b69 f1			.pastdmark: pop af  
4b6a			endm  
# End of macro DMARK
4b6a						CALLMONITOR 
4b6a cd 6f ee			call debug_vector  
4b6d				endm  
# End of macro CALLMONITOR
4b6d					endif 
4b6d 06 41				ld b, 'A' 
4b6f 90					sub b			; set offset 
4b70					if DEBUG_FORTH_WORDS 
4b70						DMARK "Vbb" 
4b70 f5				push af  
4b71 3a 85 4b			ld a, (.dmark)  
4b74 32 6b ee			ld (debug_mark),a  
4b77 3a 86 4b			ld a, (.dmark+1)  
4b7a 32 6c ee			ld (debug_mark+1),a  
4b7d 3a 87 4b			ld a, (.dmark+2)  
4b80 32 6d ee			ld (debug_mark+2),a  
4b83 18 03			jr .pastdmark  
4b85 ..			.dmark: db "Vbb"  
4b88 f1			.pastdmark: pop af  
4b89			endm  
# End of macro DMARK
4b89						CALLMONITOR 
4b89 cd 6f ee			call debug_vector  
4b8c				endm  
# End of macro CALLMONITOR
4b8c					endif 
4b8c cb 27				sla a  
4b8e				 
4b8e					 
4b8e					if DEBUG_FORTH_WORDS 
4b8e						DMARK "VR2" 
4b8e f5				push af  
4b8f 3a a3 4b			ld a, (.dmark)  
4b92 32 6b ee			ld (debug_mark),a  
4b95 3a a4 4b			ld a, (.dmark+1)  
4b98 32 6c ee			ld (debug_mark+1),a  
4b9b 3a a5 4b			ld a, (.dmark+2)  
4b9e 32 6d ee			ld (debug_mark+2),a  
4ba1 18 03			jr .pastdmark  
4ba3 ..			.dmark: db "VR2"  
4ba6 f1			.pastdmark: pop af  
4ba7			endm  
# End of macro DMARK
4ba7						CALLMONITOR 
4ba7 cd 6f ee			call debug_vector  
4baa				endm  
# End of macro CALLMONITOR
4baa					endif 
4baa			 
4baa 21 f4 e9				ld hl, cli_var_array2 
4bad cd e7 0d				call addatohl 
4bb0 cd 47 1c				call forth_push_numhl 
4bb3			 
4bb3			 
4bb3				       NEXTW 
4bb3 c3 f4 1f			jp macro_next 
4bb6				endm 
# End of macro NEXTW
4bb6			.V0: 
4bb6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bb6 78				db WORD_SYS_CORE+100             
4bb7 ce 4b			dw .V0Q            
4bb9 04				db 3 + 1 
4bba .. 00			db "V0!",0              
4bbe				endm 
# End of macro CWHEAD
4bbe			;| V0! ( u1 -- )  Store value to v0  | DONE 
4bbe			 
4bbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bbe cd 3e 1e			call macro_dsp_valuehl 
4bc1				endm 
# End of macro FORTH_DSP_VALUEHL
4bc1			 
4bc1 11 28 ea				ld de, cli_var_array 
4bc4			 
4bc4 eb					ex de, hl 
4bc5 73					ld (hl), e 
4bc6 23					inc hl 
4bc7 72					ld (hl), d 
4bc8			 
4bc8					; destroy value TOS 
4bc8			 
4bc8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc8 cd f6 1e			call macro_forth_dsp_pop 
4bcb				endm 
# End of macro FORTH_DSP_POP
4bcb			 
4bcb				       NEXTW 
4bcb c3 f4 1f			jp macro_next 
4bce				endm 
# End of macro NEXTW
4bce			.V0Q: 
4bce				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bce 79				db WORD_SYS_CORE+101             
4bcf df 4b			dw .V1S            
4bd1 04				db 3 + 1 
4bd2 .. 00			db "V0@",0              
4bd6				endm 
# End of macro CWHEAD
4bd6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bd6 2a 28 ea				ld hl, (cli_var_array) 
4bd9 cd 47 1c				call forth_push_numhl 
4bdc			 
4bdc				       NEXTW 
4bdc c3 f4 1f			jp macro_next 
4bdf				endm 
# End of macro NEXTW
4bdf			.V1S: 
4bdf				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bdf 7a				db WORD_SYS_CORE+102             
4be0 f7 4b			dw .V1Q            
4be2 04				db 3 + 1 
4be3 .. 00			db "V1!",0              
4be7				endm 
# End of macro CWHEAD
4be7			;| V1! ( u1 -- )  Store value to v1 | DONE 
4be7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be7 cd 3e 1e			call macro_dsp_valuehl 
4bea				endm 
# End of macro FORTH_DSP_VALUEHL
4bea			 
4bea 11 2a ea				ld de, cli_var_array+2 
4bed				 
4bed eb					ex de, hl 
4bee 73					ld (hl), e 
4bef 23					inc hl 
4bf0 72					ld (hl), d 
4bf1			 
4bf1					; destroy value TOS 
4bf1			 
4bf1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf1 cd f6 1e			call macro_forth_dsp_pop 
4bf4				endm 
# End of macro FORTH_DSP_POP
4bf4				       NEXTW 
4bf4 c3 f4 1f			jp macro_next 
4bf7				endm 
# End of macro NEXTW
4bf7			.V1Q: 
4bf7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bf7 7b				db WORD_SYS_CORE+103             
4bf8 08 4c			dw .V2S            
4bfa 04				db 3 + 1 
4bfb .. 00			db "V1@",0              
4bff				endm 
# End of macro CWHEAD
4bff			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bff 2a 2a ea				ld hl, (cli_var_array+2) 
4c02 cd 47 1c				call forth_push_numhl 
4c05				       NEXTW 
4c05 c3 f4 1f			jp macro_next 
4c08				endm 
# End of macro NEXTW
4c08			.V2S: 
4c08				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c08 7c				db WORD_SYS_CORE+104             
4c09 20 4c			dw .V2Q            
4c0b 04				db 3 + 1 
4c0c .. 00			db "V2!",0              
4c10				endm 
# End of macro CWHEAD
4c10			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c10 cd 3e 1e			call macro_dsp_valuehl 
4c13				endm 
# End of macro FORTH_DSP_VALUEHL
4c13			 
4c13 11 2c ea				ld de, cli_var_array+4 
4c16				 
4c16 eb					ex de, hl 
4c17 73					ld (hl), e 
4c18 23					inc hl 
4c19 72					ld (hl), d 
4c1a			 
4c1a					; destroy value TOS 
4c1a			 
4c1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c1a cd f6 1e			call macro_forth_dsp_pop 
4c1d				endm 
# End of macro FORTH_DSP_POP
4c1d				       NEXTW 
4c1d c3 f4 1f			jp macro_next 
4c20				endm 
# End of macro NEXTW
4c20			.V2Q: 
4c20				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c20 7d				db WORD_SYS_CORE+105             
4c21 31 4c			dw .V3S            
4c23 04				db 3 + 1 
4c24 .. 00			db "V2@",0              
4c28				endm 
# End of macro CWHEAD
4c28			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c28 2a 2c ea				ld hl, (cli_var_array+4) 
4c2b cd 47 1c				call forth_push_numhl 
4c2e				       NEXTW 
4c2e c3 f4 1f			jp macro_next 
4c31				endm 
# End of macro NEXTW
4c31			.V3S: 
4c31				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c31 7c				db WORD_SYS_CORE+104             
4c32 49 4c			dw .V3Q            
4c34 04				db 3 + 1 
4c35 .. 00			db "V3!",0              
4c39				endm 
# End of macro CWHEAD
4c39			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c39 cd 3e 1e			call macro_dsp_valuehl 
4c3c				endm 
# End of macro FORTH_DSP_VALUEHL
4c3c			 
4c3c 11 2e ea				ld de, cli_var_array+6 
4c3f				 
4c3f eb					ex de, hl 
4c40 73					ld (hl), e 
4c41 23					inc hl 
4c42 72					ld (hl), d 
4c43			 
4c43					; destroy value TOS 
4c43			 
4c43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c43 cd f6 1e			call macro_forth_dsp_pop 
4c46				endm 
# End of macro FORTH_DSP_POP
4c46				       NEXTW 
4c46 c3 f4 1f			jp macro_next 
4c49				endm 
# End of macro NEXTW
4c49			.V3Q: 
4c49				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c49 7d				db WORD_SYS_CORE+105             
4c4a 5a 4c			dw .END            
4c4c 04				db 3 + 1 
4c4d .. 00			db "V3@",0              
4c51				endm 
# End of macro CWHEAD
4c51			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c51 2a 2e ea				ld hl, (cli_var_array+6) 
4c54 cd 47 1c				call forth_push_numhl 
4c57				       NEXTW 
4c57 c3 f4 1f			jp macro_next 
4c5a				endm 
# End of macro NEXTW
4c5a			 
4c5a			 
4c5a			 
4c5a			 
4c5a			 
4c5a			; end of dict marker 
4c5a			 
4c5a 00			.END:    db WORD_SYS_END 
4c5b 00 00			dw 0 
4c5d 00				db 0 
4c5e			 
4c5e			; use to jp here for user dict words to save on macro expansion  
4c5e			 
4c5e			user_dict_next: 
4c5e				NEXTW 
4c5e c3 f4 1f			jp macro_next 
4c61				endm 
# End of macro NEXTW
4c61			 
4c61			 
4c61			user_exec: 
4c61				;    ld hl, <word code> 
4c61				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c61				;    call forthexec 
4c61				;    jp user_dict_next   (NEXT) 
4c61			        ;    <word code bytes> 
4c61 eb				ex de, hl 
4c62 2a c2 e5			ld hl,(os_tok_ptr) 
4c65				 
4c65				FORTH_RSP_NEXT 
4c65 cd ee 1b			call macro_forth_rsp_next 
4c68				endm 
# End of macro FORTH_RSP_NEXT
4c68			 
4c68			if DEBUG_FORTH_UWORD 
4c68						DMARK "UEX" 
4c68 f5				push af  
4c69 3a 7d 4c			ld a, (.dmark)  
4c6c 32 6b ee			ld (debug_mark),a  
4c6f 3a 7e 4c			ld a, (.dmark+1)  
4c72 32 6c ee			ld (debug_mark+1),a  
4c75 3a 7f 4c			ld a, (.dmark+2)  
4c78 32 6d ee			ld (debug_mark+2),a  
4c7b 18 03			jr .pastdmark  
4c7d ..			.dmark: db "UEX"  
4c80 f1			.pastdmark: pop af  
4c81			endm  
# End of macro DMARK
4c81				CALLMONITOR 
4c81 cd 6f ee			call debug_vector  
4c84				endm  
# End of macro CALLMONITOR
4c84			endif 
4c84			 
4c84			 
4c84			 
4c84 eb				ex de, hl 
4c85 22 c2 e5			ld (os_tok_ptr), hl 
4c88				 
4c88				; Don't use next - Skips the first word in uword. 
4c88			 
4c88 c3 85 20			jp exec1 
4c8b			;	NEXT 
4c8b			 
4c8b			 
4c8b			; eof 
# End of file forth_wordsv4.asm
4c8b			endif 
4c8b			;;;;;;;;;;;;;; Debug code 
4c8b			 
4c8b			 
4c8b			;if DEBUG_FORTH_PARSE 
4c8b .. 00		.nowordfound: db "No match",0 
4c94 .. 00		.compword:	db "Comparing word ",0 
4ca4 .. 00		.nextwordat:	db "Next word at",0 
4cb1 .. 00		.charmatch:	db "Char match",0 
4cbc			;endif 
4cbc			if DEBUG_FORTH_JP 
4cbc			.foundword:	db "Word match. Exec..",0 
4cbc			endif 
4cbc			;if DEBUG_FORTH_PUSH 
4cbc .. 00		.enddict:	db "Dict end. Push.",0 
4ccc .. 00		.push_str:	db "Pushing string",0 
4cdb .. 00		.push_num:	db "Pushing number",0 
4cea .. 00		.data_sp:	db "SP:",0 
4cee .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d00 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d12 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d24			;endif 
4d24			;if DEBUG_FORTH_MALLOC 
4d24 .. 00		.push_malloc:	db "Malloc address",0 
4d33			;endif 
4d33			 
4d33			 
4d33			 
4d33			; display malloc address and current data stack pointer  
4d33			 
4d33			malloc_error: 
4d33 d5				push de 
4d34 f5				push af 
4d35 e5				push hl 
4d36 cd ba 0b			call clear_display 
4d39 11 59 4d			ld de, .mallocerr 
4d3c 3e 00			ld a,0 
4d3e			;	ld de,os_word_scratch 
4d3e cd cd 0b			call str_at_display 
4d41 3e 11			ld a, display_row_1+17 
4d43 11 6b ee			ld de, debug_mark 
4d46 cd cd 0b			call str_at_display 
4d49 cd dd 0b			call update_display 
4d4c				;call break_point_state 
4d4c cd 70 65			call cin_wait 
4d4f			 
4d4f			;	ld a, ' ' 
4d4f			;	ld (os_view_disable), a 
4d4f cd dd 15			call bp_on 
4d52 e1				pop hl 
4d53 f1				pop af 
4d54 d1				pop de	 
4d55				CALLMONITOR 
4d55 cd 6f ee			call debug_vector  
4d58				endm  
# End of macro CALLMONITOR
4d58 c9				ret 
4d59			 
4d59 .. 00		.mallocerr: 	db "Malloc Error",0 
4d66			;if DEBUG_FORTH_PUSH 
4d66			display_data_sp: 
4d66 f5				push af 
4d67			 
4d67				; see if disabled 
4d67			 
4d67			 
4d67 3a 6f ee			ld a, (debug_vector) 
4d6a fe c9			cp $C9  ; RET 
4d6c				;ld a, (os_view_disable) 
4d6c				;cp '*' 
4d6c 28 67			jr z, .skipdsp 
4d6e			 
4d6e e5				push hl 
4d6f e5				push hl 
4d70 e5			push hl 
4d71 cd ba 0b			call clear_display 
4d74 e1			pop hl 
4d75 7c				ld a,h 
4d76 21 c6 e5			ld hl, os_word_scratch 
4d79 cd e8 10			call hexout 
4d7c e1				pop hl 
4d7d 7d				ld a,l 
4d7e 21 c8 e5			ld hl, os_word_scratch+2 
4d81 cd e8 10			call hexout 
4d84 21 ca e5			ld hl, os_word_scratch+4 
4d87 3e 00			ld a,0 
4d89 77				ld (hl),a 
4d8a 11 c6 e5			ld de,os_word_scratch 
4d8d 3e 28				ld a, display_row_2 
4d8f cd cd 0b				call str_at_display 
4d92 11 ee 4c			ld de, .wordinhl 
4d95 3e 00			ld a, display_row_1 
4d97			 
4d97 cd cd 0b				call str_at_display 
4d9a 11 6b ee			ld de, debug_mark 
4d9d 3e 11			ld a, display_row_1+17 
4d9f			 
4d9f cd cd 0b				call str_at_display 
4da2			 
4da2				; display current data stack pointer 
4da2 11 ea 4c			ld de,.data_sp 
4da5 3e 30				ld a, display_row_2 + 8 
4da7 cd cd 0b				call str_at_display 
4daa			 
4daa 2a ee e9			ld hl,(cli_data_sp) 
4dad e5				push hl 
4dae 7c				ld a,h 
4daf 21 c6 e5			ld hl, os_word_scratch 
4db2 cd e8 10			call hexout 
4db5 e1				pop hl 
4db6 7d				ld a,l 
4db7 21 c8 e5			ld hl, os_word_scratch+2 
4dba cd e8 10			call hexout 
4dbd 21 ca e5			ld hl, os_word_scratch+4 
4dc0 3e 00			ld a,0 
4dc2 77				ld (hl),a 
4dc3 11 c6 e5			ld de,os_word_scratch 
4dc6 3e 33				ld a, display_row_2 + 11 
4dc8 cd cd 0b				call str_at_display 
4dcb			 
4dcb			 
4dcb cd dd 0b			call update_display 
4dce cd f2 0a			call delay1s 
4dd1 cd f2 0a			call delay1s 
4dd4 e1				pop hl 
4dd5			.skipdsp: 
4dd5 f1				pop af 
4dd6 c9				ret 
4dd7			 
4dd7			display_data_malloc: 
4dd7			 
4dd7 f5				push af 
4dd8 e5				push hl 
4dd9 e5				push hl 
4dda e5			push hl 
4ddb cd ba 0b			call clear_display 
4dde e1			pop hl 
4ddf 7c				ld a,h 
4de0 21 c6 e5			ld hl, os_word_scratch 
4de3 cd e8 10			call hexout 
4de6 e1				pop hl 
4de7 7d				ld a,l 
4de8 21 c8 e5			ld hl, os_word_scratch+2 
4deb cd e8 10			call hexout 
4dee 21 ca e5			ld hl, os_word_scratch+4 
4df1 3e 00			ld a,0 
4df3 77				ld (hl),a 
4df4 11 c6 e5			ld de,os_word_scratch 
4df7 3e 28				ld a, display_row_2 
4df9 cd cd 0b				call str_at_display 
4dfc 11 24 4d			ld de, .push_malloc 
4dff 3e 00			ld a, display_row_1 
4e01			 
4e01 cd cd 0b				call str_at_display 
4e04			 
4e04				; display current data stack pointer 
4e04 11 ea 4c			ld de,.data_sp 
4e07 3e 30				ld a, display_row_2 + 8 
4e09 cd cd 0b				call str_at_display 
4e0c			 
4e0c 2a ee e9			ld hl,(cli_data_sp) 
4e0f e5				push hl 
4e10 7c				ld a,h 
4e11 21 c6 e5			ld hl, os_word_scratch 
4e14 cd e8 10			call hexout 
4e17 e1				pop hl 
4e18 7d				ld a,l 
4e19 21 c8 e5			ld hl, os_word_scratch+2 
4e1c cd e8 10			call hexout 
4e1f 21 ca e5			ld hl, os_word_scratch+4 
4e22 3e 00			ld a,0 
4e24 77				ld (hl),a 
4e25 11 c6 e5			ld de,os_word_scratch 
4e28 3e 33				ld a, display_row_2 + 11 
4e2a cd cd 0b				call str_at_display 
4e2d			 
4e2d cd dd 0b			call update_display 
4e30 cd f2 0a			call delay1s 
4e33 cd f2 0a			call delay1s 
4e36 e1				pop hl 
4e37 f1				pop af 
4e38 c9				ret 
4e39			;endif 
4e39			 
4e39			include "forth_autostart.asm" 
4e39			; list of commands to perform at system start up 
4e39			 
4e39			startcmds: 
4e39			;	dw test11 
4e39			;	dw test12 
4e39			;	dw test13 
4e39			;	dw test14 
4e39			;	dw test15 
4e39			;	dw test16 
4e39			;	dw test17 
4e39			;	dw ifthtest1 
4e39			;	dw ifthtest2 
4e39			;	dw ifthtest3 
4e39			;	dw mmtest1 
4e39			;	dw mmtest2 
4e39			;	dw mmtest3 
4e39			;	dw mmtest4 
4e39			;	dw mmtest5 
4e39			;	dw mmtest6 
4e39			;	dw iftest1 
4e39			;	dw iftest2 
4e39			;	dw iftest3 
4e39			;	dw looptest1 
4e39			;	dw looptest2 
4e39			;	dw test1 
4e39			;	dw test2 
4e39			;	dw test3 
4e39			;	dw test4 
4e39			;	dw game2r 
4e39			;	dw game2b1 
4e39			;	dw game2b2 
4e39			 
4e39				; start up words that are actually useful 
4e39			 
4e39			;    dw spi1 
4e39			;    dw spi2 
4e39			;    dw spi3 
4e39			;    dw spi4 
4e39			;    dw spi5 
4e39			;    dw spi6 
4e39			;    dw spi7 
4e39			; 
4e39			;    dw spi8 
4e39			;    dw spi9 
4e39			;    dw spi10 
4e39			 
4e39			; file editor 
4e39			;	dw edit1 
4e39			;	dw edit2 
4e39			;	dw edit3 
4e39			 
4e39			;	dw longread 
4e39 39 52			dw clrstack 
4e3b 6d 52			dw type 
4e3d			;	dw stest 
4e3d 92 52			dw strncpy 
4e3f			;	dw list 
4e3f f3 52			dw start1 
4e41 03 53			dw start2 
4e43			;	dw start3 
4e43			;	dw start3b 
4e43			;	dw start3c 
4e43			 
4e43				; (unit) testing words 
4e43			 
4e43			;	dw mtesta 
4e43			;	dw mtestb 
4e43			;	dw mtestc 
4e43			;	dw mtestd 
4e43			;	dw mteste 
4e43			 
4e43				; demo/game words 
4e43			 
4e43			;        dw game3w 
4e43			;        dw game3p 
4e43			;        dw game3sc 
4e43			;        dw game3vsi 
4e43			;        dw game3vs 
4e43				 
4e43 5c 5d			dw game2b 
4e45 ca 5d			dw game2bf 
4e47 14 5e			dw game2mba 
4e49 aa 5e			dw game2mbas 
4e4b ec 5e			dw game2mb 
4e4d			 
4e4d 1d 5a			dw game1 
4e4f 2e 5a			dw game1a 
4e51 90 5a			dw game1b 
4e53 c5 5a			dw game1c 
4e55 fb 5a			dw game1d 
4e57 2c 5b			dw game1s 
4e59 40 5b			dw game1t 
4e5b 55 5b			dw game1f 
4e5d 89 5b			dw game1z 
4e5f cd 5b			dw game1zz 
4e61			 
4e61 37 58			dw test5 
4e63 6f 58			dw test6 
4e65 a7 58			dw test7 
4e67 bb 58			dw test8 
4e69 e7 58			dw test9 
4e6b fd 58			dw test10 
4e6d				 
4e6d a4 5c		        dw ssv5 
4e6f 88 5c		        dw ssv4 
4e71 6c 5c		        dw ssv3 
4e73 36 5c		        dw ssv2 
4e75 bd 5c		        dw ssv1 
4e77 05 5d		        dw ssv1cpm 
4e79			;	dw keyup 
4e79			;	dw keydown 
4e79			;	dw keyleft 
4e79			;	dw keyright 
4e79			;	dw 	keyf1 
4e79			;	dw keyf2 
4e79			;	dw keyf3 
4e79			;	dw keyf4 
4e79			;	dw keyf5 
4e79			;	dw keyf6 
4e79			;	dw keyf7 
4e79			;	dw keyf8 
4e79			;	dw keyf9 
4e79			;	dw keyf10 
4e79			;	dw keyf11 
4e79			;	dw keyf12 
4e79			;	dw keytab 
4e79			;	dw keycr 
4e79			;	dw keyhome 
4e79			;	dw keyend 
4e79			;	dw keybs 
4e79 00 00			db 0, 0	 
4e7b			 
4e7b			 
4e7b			; File Editor 
4e7b			 
4e7b			; ( id - ) use 'e' to edit the displayed line 
4e7b .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e9c .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ed1			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ed1 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f09			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f09			 
4f09			; SPI Net support words 
4f09			 
4f09			; v0! = node to send to 
4f09			; ( str count - ) 
4f09 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f62			 
4f62			; spiputchr ( char node - ) 
4f62 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f98			 
4f98			; spigetchr ( - n ) 
4f98 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fc3			 
4fc3			; getnode ( - n ) 
4fc3 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4ff0			 
4ff0			; ( str node - )  
4ff0 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5056			; store string ( str i - ) 
5056			 
5056			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5056 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50ab			 
50ab			; get string ( addr i -  )    TO FIX 
50ab			 
50ab .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5103			 
5103			 
5103			; NETCHAT (TODO) 
5103			; Program to allow two nodes to chat with eachother 
5103			; 
5103			; v0 - target node 
5103			;  
5103			; accept input at 0,0 
5103			; if input is string send spitype to target node 
5103			; starting at row 2,0 , while spigetchr is not zero ->  
5103			; 
5103			; 
5103			; TODO add paging of get request 
5103			 
5103			; ( node - ) 
5103 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5122 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
517a .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51f2			 
51f2			 
51f2			; Long read of currently open file 
51f2 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5239			 
5239			; clear stack  
5239			 
5239 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
526d			 
526d			; type ( addr count - ) 
526d .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5292			 
5292			; some direct memory words 
5292			; strncpy ( len t f -- t ) 
5292			 
5292 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52f3			 
52f3 .. 00		start1:     	db ": bpon $00 bp ;",0 
5303 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5314 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
538f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53ef			 
53ef			 
53ef			; a handy word to list items on the stack 
53ef			 
53ef .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5459			 
5459			 
5459			; test stack  
5459			; rnd8 stest 
5459			 
5459 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54d0			 
54d0			; random malloc and free cycles 
54d0			 
54d0 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5585			 
5585			; fixed malloc and free cycles 
5585			 
5585 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5628			 
5628			; fixed double string push and drop cycle  
5628			 
5628 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56dd			 
56dd			; consistent fixed string push and drop cycle  
56dd			 
56dd .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5781			 
5781 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5837			 
5837			;test1:		db ": aa 1 2 3 ;", 0 
5837			;test2:     	db "111 aa 888 999",0 
5837			;test3:     	db ": bb 77 ;",0 
5837			;test4:     	db "$02 $01 do i . loop bb",0 
5837			 
5837 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
586f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58a7 .. 00		test7:     	db ": box hline vline ;",0 
58bb .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58e7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
58fd .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5922 .. 00		test11:     	db "hello create .",0 
5931 .. 00		test12:     	db "hello2 create .",0 
5941			 
5941			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5941			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5941			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5941			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5941			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5941			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5941			 
5941			;iftest1:     	db "$0001 IF cls .",0 
5941			;iftest2:     	db "$0000 IF cls .",0 
5941			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5941			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5941			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5941			 
5941			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5941			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5941			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5941			 
5941			 
5941 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5965 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5995 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59ba .. 00		sound4: db ": cha $00 ; ",0 
59c7 .. 00		sound5: db ": chb $20 ; ",0 
59d4 .. 00		sound6: db ": chc $40 ; ",0 
59e1 .. 00		sound7: db ": chd $60 ; ",0 
59ee .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a06 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a1d			 
5a1d			 
5a1d			 
5a1d			 
5a1d			; a small guess the number game 
5a1d			 
5a1d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a2e .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a90			 
5a90 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ac5 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5afb .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b2c .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b40 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b55 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b89 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bcd			 
5bcd			; Using 'ga' save a high score across multiple runs using external storage 
5bcd			 
5bcd .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c36			 
5c36			 
5c36			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c36			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c36			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c36			 
5c36			; simple screen saver to test code memory reuse to destruction 
5c36			 
5c36 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c6c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c88 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ca4 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cbd .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d05 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d5c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d5c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d5c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d5c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d5c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d5c			 
5d5c			 
5d5c			 
5d5c			; minesweeper/battleship finding game 
5d5c			; draws a game board of random ship/mine positions 
5d5c			; user enters coords to see if it hits on 
5d5c			; game ends when all are hit 
5d5c			; when hit or miss says how many may be in the area 
5d5c			 
5d5c			; setup the game board and then hide it 
5d5c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dca .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e14			; prompt for where to target 
5e14 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5eaa .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ecf			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ecf .. 00		game2mbht:      db ": mbckht nop ;",0 
5ede .. 00		game2mbms:      db ": mbcms nop ;",0 
5eec			; TODO how many might be near by 
5eec .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f69			 
5f69			; Game 3 
5f69			 
5f69			; Vert scroller ski game - avoid the trees! 
5f69			 
5f69			; v0 score (ie turns) 
5f69			; v1 player pos 
5f69			; v2 left wall 
5f69			; v3 right wall 
5f69			 
5f69			; Draw side walls randomly 
5f69			 
5f69 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f97			 
5f97			; Draw player 
5f97 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fb5			 
5fb5			; TODO Get Key 
5fb5			 
5fb5			; TODO Move left right 
5fb5			 
5fb5			; scroll and move walls a bit 
5fb5			 
5fb5 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fe6			 
5fe6			; main game loop 
5fe6			 
5fe6 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6012 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6051			 
6051			; key board defs 
6051			 
6051 .. 00		keyup:       db ": keyup $05 ;",0 
605f .. 00		keydown:       db ": keydown $0a ;",0 
606f .. 00		keyleft:       db ": keyleft $0b ;",0 
607f .. 00		keyright:       db ": keyright $0c ;",0 
6090 .. 00		keyf1:       db ": keyf1 $10 ;",0 
609e .. 00		keyf2:       db ": keyf2 $11 ;",0 
60ac .. 00		keyf3:       db ": keyf3 $12 ;",0 
60ba .. 00		keyf4:       db ": keyf4 $13 ;",0 
60c8 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60d6 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60e4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60f2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6100 .. 00		keyf9:       db ": keyf9 $18 ;",0 
610e .. 00		keyf10:       db ": keyf10 $19 ;",0 
611d .. 00		keyf11:       db ": keyf11 $1a ;",0 
612c .. 00		keyf12:       db ": keyf12 $1b ;",0 
613b			 
613b .. 00		keytab:       db ": keytab $09 ;",0 
614a .. 00		keycr:       db ": keycr $0d ;",0 
6158 .. 00		keyhome:       db ": keyhome $0e ;",0 
6168 .. 00		keyend:       db ": keyend $0f ;",0 
6177 .. 00		keybs:       db ": keybs $08 ;",0 
6185			 
6185			   
6185			 
6185			 
6185			 
6185			; eof 
# End of file forth_autostart.asm
6185			 
6185			 
6185			 
6185			; stack over and underflow checks 
6185			 
6185			; init the words to detect the under/overflow 
6185			 
6185			chk_stk_init: 
6185				; a vague random number to check so we dont get any "lucky" hits 
6185 3e 2d			ld a, 45 
6187 6f				ld l, a 
6188 00				nop 
6189 3e 17			ld a, 23 
618b 67				ld h, a 
618c			 
618c 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
618f			 
618f			;	ld (chk_stund), hl	; stack points.... 
618f 22 00 ef			ld (chk_stovr), hl 
6192 22 ec e9			ld (chk_ret_und), hl 
6195 22 aa e9			ld (chk_ret_ovr), hl 
6198 22 28 e9			ld (chk_loop_ovr), hl 
619b 22 26 e8			ld (chk_data_ovr), hl 
619e c9				ret 
619f				 
619f			check_stacks: 
619f				; check all stack words 
619f			 
619f e5				push hl 
61a0 d5				push de 
61a1			 
61a1			;	ld de,(chk_word) 
61a1			;	ld hl, (chk_stund)	; stack points.... 
61a1			;	if DEBUG_STK_FAULT 
61a1			;		DMARK "FAa" 
61a1			;		CALLMONITOR 
61a1			;	endif 
61a1			;	call cmp16 
61a1			;	jp z, .chk_faulta 
61a1			; 
61a1			;	ld de, sfaultsu 
61a1			;	jp .chk_fault 
61a1			 
61a1 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61a4 ed 5b 9d e2		ld de,(chk_word) 
61a8				if DEBUG_STK_FAULT 
61a8					DMARK "FAb" 
61a8					CALLMONITOR 
61a8				endif 
61a8 cd 05 0e			call cmp16 
61ab 28 06			jr z, .chk_fault1 
61ad 11 4e 62			ld de, sfaultso 
61b0 c3 02 62			jp .chk_fault 
61b3			.chk_fault1:  
61b3 2a ec e9			ld hl, (chk_ret_und) 
61b6 ed 5b 9d e2		ld de,(chk_word) 
61ba				if DEBUG_STK_FAULT 
61ba					DMARK "FAU" 
61ba					CALLMONITOR 
61ba				endif 
61ba cd 05 0e			call cmp16 
61bd ca c6 61			jp z, .chk_fault2 
61c0 11 5e 62			ld de, sfaultru 
61c3 c3 02 62			jp .chk_fault 
61c6			.chk_fault2:  
61c6 2a aa e9			ld hl, (chk_ret_ovr) 
61c9 ed 5b 9d e2		ld de,(chk_word) 
61cd				if DEBUG_STK_FAULT 
61cd					DMARK "FA1" 
61cd					CALLMONITOR 
61cd				endif 
61cd cd 05 0e			call cmp16 
61d0 ca d9 61			jp z, .chk_fault3 
61d3 11 6c 62			ld de, sfaultro 
61d6 c3 02 62			jp .chk_fault 
61d9			.chk_fault3:  
61d9 2a 28 e9			ld hl, (chk_loop_ovr) 
61dc ed 5b 9d e2		ld de,(chk_word) 
61e0				if DEBUG_STK_FAULT 
61e0					DMARK "FA2" 
61e0					CALLMONITOR 
61e0				endif 
61e0 cd 05 0e			call cmp16 
61e3 ca ec 61			jp z, .chk_fault4 
61e6 11 86 62			ld de, sfaultlo 
61e9 c3 02 62			jp .chk_fault 
61ec			.chk_fault4:  
61ec 2a 26 e8			ld hl, (chk_data_ovr) 
61ef ed 5b 9d e2		ld de,(chk_word) 
61f3				if DEBUG_STK_FAULT 
61f3					DMARK "FA3" 
61f3					CALLMONITOR 
61f3				endif 
61f3 cd 05 0e			call cmp16 
61f6 ca ff 61			jp z, .chk_fault5 
61f9 11 a0 62			ld de, sfaultdo 
61fc c3 02 62			jp .chk_fault 
61ff			 
61ff			 
61ff			.chk_fault5:  
61ff d1				pop de 
6200 e1				pop hl 
6201			 
6201 c9				ret 
6202			 
6202 cd ba 0b		.chk_fault: 	call clear_display 
6205 3e 28				ld a, display_row_2 
6207 cd cd 0b				call str_at_display 
620a 11 30 62				   ld de, .stackfault 
620d 3e 00				ld a, display_row_1 
620f cd cd 0b				call str_at_display 
6212 11 6b ee				    ld de, debug_mark 
6215 3e 11				ld a, display_row_1+17 
6217 cd cd 0b				call str_at_display 
621a cd dd 0b				call update_display 
621d			 
621d				; prompt before entering montior for investigating issue 
621d			 
621d 3e 78			ld a, display_row_4 
621f 11 39 19			ld de, endprog 
6222			 
6222 cd dd 0b			call update_display		 
6225			 
6225 cd bf 1b			call next_page_prompt 
6228			 
6228 d1				pop de 
6229 e1				pop hl 
622a cd 8d 19				call monitor 
622d c3 96 18				jp warmstart 
6230					;jp 0 
6230					;halt 
6230			 
6230			 
6230			 
6230 .. 00		.stackfault: 	db "Stack fault:",0 
623d			 
623d .. 00		sfaultsu: 	db	"Stack under flow",0 
624e .. 00		sfaultso: 	db	"Stack over flow",0 
625e .. 00		sfaultru:	db "RTS underflow",0 
626c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6286 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62a0 .. 00		sfaultdo:	db "DTS overflow", 0 
62ad			 
62ad			 
62ad			fault_dsp_under: 
62ad 11 bf 62			ld de, .dsp_under 
62b0 c3 6f 63			jp .show_fault 
62b3			 
62b3			fault_rsp_under: 
62b3 11 cd 62			ld de, .rsp_under 
62b6 c3 6f 63			jp .show_fault 
62b9			fault_loop_under: 
62b9 11 db 62			ld de, .loop_under 
62bc c3 6f 63			jp .show_fault 
62bf			 
62bf .. 00		.dsp_under: db "DSP Underflow",0 
62cd .. 00		.rsp_under: db "RSP Underflow",0 
62db .. 00		.loop_under: db "LOOP Underflow",0 
62ea			 
62ea			 
62ea d5			type_faultn: 	push de 
62eb e5					push hl 
62ec cd ba 0b				call clear_display 
62ef 11 16 63				   ld de, .typefaultn 
62f2 3e 00				ld a, display_row_1 
62f4 cd cd 0b				call str_at_display 
62f7 11 6b ee				    ld de, debug_mark 
62fa 3e 11				ld a, display_row_1+17 
62fc cd cd 0b				call str_at_display 
62ff cd dd 0b				call update_display 
6302			 
6302				; prompt before entering montior for investigating issue 
6302			 
6302 3e 78			ld a, display_row_4 
6304 11 39 19			ld de, endprog 
6307			 
6307 cd dd 0b			call update_display		 
630a			 
630a cd bf 1b			call next_page_prompt 
630d			 
630d e5					push hl 
630e d5					push de 
630f cd 8d 19				call monitor 
6312 c3 96 18				jp warmstart 
6315 76					halt 
6316			 
6316			 
6316 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
632d			 
632d d5			type_faults: 	push de 
632e e5					push hl 
632f cd ba 0b				call clear_display 
6332 11 58 63				   ld de, .typefaults 
6335 3e 00				ld a, display_row_1 
6337 cd cd 0b				call str_at_display 
633a 11 6b ee				    ld de, debug_mark 
633d 3e 11				ld a, display_row_1+17 
633f cd cd 0b				call str_at_display 
6342 cd dd 0b				call update_display 
6345			 
6345				; prompt before entering montior for investigating issue 
6345			 
6345 3e 78			ld a, display_row_4 
6347 11 39 19			ld de, endprog 
634a			 
634a cd dd 0b			call update_display		 
634d			 
634d cd bf 1b			call next_page_prompt 
6350			 
6350 e1					pop hl 
6351 d1					pop de 
6352 cd 8d 19				call monitor 
6355 c3 96 18				jp warmstart 
6358			 
6358			 
6358 .. 00		.typefaults: db "STR Type Expected TOS!",0 
636f			 
636f			.show_fault: 	 
636f d5					push de 
6370 cd ba 0b				call clear_display 
6373 d1					pop de 
6374 3e 00				ld a, display_row_1 
6376 cd cd 0b				call str_at_display 
6379 11 6b ee				    ld de, debug_mark 
637c 3e 11				ld a, display_row_1+17 
637e cd cd 0b				call str_at_display 
6381 cd dd 0b				call update_display 
6384			 
6384				; prompt before entering montior for investigating issue 
6384			 
6384 3e 78			ld a, display_row_4 
6386 11 39 19			ld de, endprog 
6389			 
6389 cd dd 0b			call update_display		 
638c			 
638c cd bf 1b			call next_page_prompt 
638f			 
638f e1					pop hl 
6390 d1					pop de 
6391 cd 8d 19				call monitor 
6394			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6394			; TODO Make optional fault restart to cli or warm boot? 
6394					;jp warmstart 
6394 c3 e0 18				jp cli 
6397 76					halt 
6398			 
6398			; handle the auto run of code from files in storage 
6398			 
6398			 
6398			include "forth_startup.asm" 
6398			; Which startup method to use? 
6398			; 
6398			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6398			; followed by loading of a list of scripts in eeprom 
6398			 
6398			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6398			; from eeprom 
6398			 
6398			; Select with define in main stubs 
6398			 
6398			if STARTUP_V1 
6398				include "forth_startupv1.asm" 
6398			; Startup script loading version 1 
6398			 
6398			; If SE storage is available first stage is to use the selected file 
6398			; then go through the eeprom list 
6398			 
6398 .. 00		sprompt1: db "Startup load...",0 
63a8 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63be			 
63be			 
63be			 
63be			 
63be			forth_startup: 
63be 21 39 4e			ld hl, startcmds 
63c1 3e 00			ld a, 0 
63c3 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63c6			 
63c6 e5			.start1:	push hl 
63c7 cd ba 0b			call clear_display 
63ca 11 98 63			ld de, sprompt1 
63cd 3e 00		        ld a, display_row_1 
63cf cd cd 0b			call str_at_display 
63d2 11 a8 63			ld de, sprompt2 
63d5 3e 28		        ld a, display_row_2 
63d7 cd cd 0b			call str_at_display 
63da e1				pop hl 
63db e5				push hl 
63dc 5e				ld e,(hl) 
63dd 23				inc hl 
63de 56				ld d,(hl) 
63df 3e 50		        ld a, display_row_3 
63e1 cd cd 0b			call str_at_display 
63e4 cd dd 0b			call update_display 
63e7			 
63e7			 
63e7 3a e7 e6			ld a, (os_last_cmd) 
63ea fe 00			cp 0 
63ec 28 05			jr z, .startprompt 
63ee cd e6 0a			call delay250ms 
63f1 18 24			jr .startdo 
63f3				 
63f3				 
63f3			 
63f3			.startprompt: 
63f3			 
63f3 3e 9f			ld a,display_row_4 + display_cols - 1 
63f5 11 bd 1b		        ld de, endprg 
63f8 cd cd 0b			call str_at_display 
63fb cd dd 0b			call update_display 
63fe cd f2 0a			call delay1s 
6401 cd 70 65			call cin_wait 
6404						 
6404 fe 2a			cp '*' 
6406 28 5e			jr z, .startupend1 
6408 fe 23			cp '#' 
640a 20 07			jr nz, .startno 
640c 3e 01			ld a, 1 
640e 32 e7 e6			ld (os_last_cmd),a 
6411 18 04			jr .startdo 
6413 fe 31		.startno:	cp '1' 
6415 28 3a			jr z,.startnxt  
6417			 
6417				; exec startup line 
6417			.startdo:	 
6417 e1				pop hl 
6418 e5				push hl 
6419				 
6419 5e				ld e,(hl) 
641a 23				inc hl 
641b 56				ld d,(hl) 
641c eb				ex de,hl 
641d			 
641d e5				push hl 
641e			 
641e 3e 00			ld a, 0 
6420				;ld a, FORTH_END_BUFFER 
6420 cd 50 12			call strlent 
6423 23				inc hl   ; include zero term to copy 
6424 06 00			ld b,0 
6426 4d				ld c,l 
6427 e1				pop hl 
6428 11 c1 e2			ld de, scratch 
642b ed b0			ldir 
642d			 
642d			 
642d 21 c1 e2			ld hl, scratch 
6430 cd 42 20			call forthparse 
6433 cd 82 20			call forthexec 
6436 cd 94 1f			call forthexec_cleanup 
6439			 
6439 3e 78			ld a, display_row_4 
643b 11 39 19			ld de, endprog 
643e			 
643e cd dd 0b			call update_display		 
6441			 
6441 3a e7 e6			ld a, (os_last_cmd) 
6444 fe 00			cp 0 
6446 20 09			jr nz, .startnxt 
6448 cd bf 1b			call next_page_prompt 
644b cd ba 0b		        call clear_display 
644e cd dd 0b			call update_display		 
6451			 
6451				; move onto next startup line? 
6451			.startnxt: 
6451			 
6451 cd e6 0a			call delay250ms 
6454 e1				pop hl 
6455			 
6455 23				inc hl 
6456 23				inc hl 
6457			 
6457 e5				push hl 
6458 5e				ld e, (hl) 
6459 23				inc hl 
645a 56				ld d, (hl) 
645b e1				pop hl 
645c				; TODO replace 0 test 
645c			 
645c eb				ex de, hl 
645d cd 10 0e			call ishlzero 
6460			;	ld a,e 
6460			;	add d 
6460			;	cp 0    ; any left to do? 
6460 eb				ex de, hl 
6461 c2 c6 63			jp nz, .start1 
6464 18 01			jr .startupend 
6466			 
6466 e1			.startupend1: pop hl 
6467			.startupend: 
6467			 
6467 cd ba 0b			call clear_display 
646a cd dd 0b			call update_display 
646d c9				ret 
646e			if STORAGE_SE 
646e			 
646e			sprompt3: db "Loading from start-up file?:",0 
646e			sprompt4: db "(Y=Any key/N=No)",0 
646e			 
646e			 
646e			forth_autoload: 
646e			 
646e				; load block 0 of store 1 
646e				 
646e				ld a, $fe      ; bit 0 clear 
646e				ld (spi_device), a 
646e			 
646e				call storage_get_block_0 
646e			 
646e				ld a, (store_page+STORE_0_AUTOFILE) 
646e			 
646e				cp 0 
646e				ret z     ; auto start not enabled 
646e			 
646e				call clear_display 
646e			 
646e				; set bank 
646e			 
646e					ld a, (store_page+STORE_0_BANKRUN) 
646e					ld (spi_device), a 
646e			 
646e				; get file id to load from and get the file name to display 
646e			 
646e					ld a, (store_page+STORE_0_FILERUN) 
646e			 
646e					ld l, 0 
646e					ld h, a 
646e					ld de, store_page 
646e			 
646e					if DEBUG_FORTH_WORDS 
646e						DMARK "ASp" 
646e						CALLMONITOR 
646e					endif 
646e					call storage_read 
646e			 
646e					if DEBUG_FORTH_WORDS 
646e						DMARK "ASr" 
646e						CALLMONITOR 
646e					endif 
646e			 
646e					call ishlzero 
646e					ret z             ; file not found 
646e			 
646e					ld a, display_row_2 + 10 
646e					ld de, store_page+3 
646e					call str_at_display 
646e				 
646e			; 
646e			 
646e				ld a, display_row_1+5 
646e				ld de, sprompt3 
646e				call str_at_display 
646e				ld a, display_row_3+15 
646e				ld de, sprompt4 
646e				call str_at_display 
646e			 
646e				call update_display 
646e			 
646e				call cin_wait 
646e				cp 'n' 
646e				ret z 
646e				cp 'N' 
646e				ret z 
646e			 
646e				call delay1s 
646e			 
646e				ld a, (store_page+2) 
646e				ld (store_openmaxext), a    ; save count of ext 
646e				ld a, 1  
646e				ld (store_openext), a    ; save count of ext 
646e			 
646e			.autof:  
646e				ld l , a 
646e				 
646e				ld a, (store_page) 
646e				ld h, a	 
646e				ld de, store_page 
646e					if DEBUG_FORTH_WORDS 
646e						DMARK "ASl" 
646e						CALLMONITOR 
646e					endif 
646e					call storage_read 
646e				call ishlzero 
646e				ret z 
646e			;	jr z, .autoend 
646e			 
646e					if DEBUG_FORTH_WORDS 
646e						DMARK "ASc" 
646e						CALLMONITOR 
646e					endif 
646e				ld de, store_page+2 
646e				ld a, display_row_4 
646e				call str_at_display 
646e			 
646e				call update_display 
646e				call delay250ms 
646e			 
646e			 
646e			 
646e				ld hl, store_page+2 
646e				call forthparse 
646e				call forthexec 
646e				call forthexec_cleanup 
646e			 
646e				 
646e				ld a, (store_openext) 
646e				inc a 
646e				ld (store_openext), a    ; save count of ext 
646e			 
646e				jr .autof 
646e			;.autofdone: 
646e			; 
646e			;		if DEBUG_FORTH_WORDS 
646e			;			DMARK "ASx" 
646e			;			CALLMONITOR 
646e			;		endif 
646e			;;	call clear_display 
646e			;	ret 
646e			 
646e			 
646e			 
646e			endif 
# End of file forth_startupv1.asm
646e			endif 
646e			if STARTUP_V2 
646e				include "forth_startupv2.asm" 
646e			endif 
646e			 
# End of file forth_startup.asm
646e			 
646e			; eof 
# End of file forth_kernel.asm
646e			;include "nascombasic.asm" 
646e			 
646e			 
646e			; find out where the code ends if loaded into RAM (for SC114) 
646e			;endofcode:  
646e			;	nop 
646e			 
646e			 
646e			; jump to nmi vector 
646e			 
646e			init_nmi: 
646e 3e c9			ld a, $c9   ; RET 
6470 32 72 ee			ld (nmi_vector), a 
6473 c9				ret 
6474			nmi: 
6474 e5				push hl 
6475 d5				push de 
6476 c5				push bc 
6477 f5				push af 
6478 cd 72 ee			call nmi_vector 
647b f5				push af 
647c c5				push bc 
647d d5				push de 
647e e5				push hl 
647f ed 4d			reti 
6481			 
6481			 
6481			; eof 
6481			 
# End of file main.asm
6481			;include "firmware_lcd_4x40.asm" 
6481			;;include "firmware_lcd_4x20.asm" 
6481			include "firmware_cpm_display.asm" 
6481			 
6481			; Serial display interface for SC114 
6481			 
6481			 
6481			display_row_1: equ 0 
6481			display_row_2: equ display_row_1+display_cols 
6481			display_row_3: equ display_row_2 + display_cols 
6481			display_row_4: equ display_row_3 + display_cols 
6481			 
6481			kLCDWidth:  EQU display_cols             ;Width in characters 
6481			kLCD_Line1: EQU 0x00  
6481			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6481			; E1 
6481			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6481			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6481			 
6481			lcd_init: 
6481				; no init as handled by the SCM bios 
6481 c9				ret 
6482			 
6482			 
6482			; low level functions for direct screen writes 
6482			 
6482			; output char at pos? 
6482			fLCD_Str: 
6482			        ;out (SC114_SIO_1_OUT),a 
6482 c5				push bc 
6483 d5				push de 
6484 5f				ld e, a 
6485			; TODO Replace with CP/M BIOS call 
6485 0e 02			ld c, $02 
6487 cd 05 00			call 5 
648a d1				pop de 
648b c1				pop bc 
648c c9				ret 
648d			 
648d			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
648d			fLCD_Pos: 
648d				; use ASCII escape to position 
648d			        ;out (SC114_SIO_1_OUT),a 
648d c5				push bc 
648e d5				push de 
648f 5f				ld e, a 
6490 0e 02			ld c, $02 
6492			; TODO Replace with CP/M BIOS call 
6492 cd 05 00			call 5 
6495 d1				pop de 
6496 c1				pop bc 
6497			 
6497 c9				ret 
6498			 
6498			; output char at pos 
6498			fLCD_Data: 
6498			      ;  out (SC114_SIO_1_OUT),a 
6498 c5				push bc 
6499 d5				push de 
649a 0e 02			ld c, $02 
649c 5f				ld e, a 
649d			; TODO Replace with CP/M BIOS call 
649d cd 05 00			call 5 
64a0 d1				pop de 
64a1 c1				pop bc 
64a2			 
64a2 c9				ret 
64a3			 
64a3			; ascii cls  
64a3			 
64a3 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64a7			 
64a7 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64be			;.clscpm: db 3, $3c,"$" 
64be			 
64be			; write the frame buffer given in hl to hardware  
64be			write_display: 
64be			 
64be			API: equ 0 
64be			 
64be			if API 
64be				push bc 
64be				ld b, 4 
64be			 
64be			        ld (display_write_tmp), hl 	  
64be			 
64be				; clear and home cursor 
64be			 
64be				ld c, 9 
64be				ld de, .cls 
64be			; TODO Replace with CP/M BIOS call 
64be				call 5 
64be			 
64be			 
64be			.writeln: 
64be			 
64be				ld de, (display_write_tmp) 
64be				ld c, 6 
64be			; TODO Replace with CP/M BIOS call 
64be				rst $30 
64be				ld c, 7 
64be				rst $30 
64be			 
64be				ld hl, (display_write_tmp) 
64be				ld de, display_cols 
64be				add hl,de 
64be				ld (display_write_tmp),hl 
64be			 
64be				djnz  .writeln 
64be			 
64be				pop bc 
64be			 
64be			 
64be				ret 
64be			endif 
64be e5				push hl 
64bf c5				push bc 
64c0 d5				push de 
64c1			 
64c1			;	ld c, 2 
64c1			;	;ld de, .cls 
64c1			;	ld a, 27 
64c1			;	rst $30 
64c1			;	ld c, 2 
64c1			;	;ld de, .cls 
64c1			;	ld a, '[' 
64c1			;	rst $30 
64c1			; 
64c1			;	ld c, 2 
64c1			;	;ld de, .cls 
64c1			;	ld a, 'H' 
64c1			;	rst $30 
64c1			; 
64c1			 
64c1			 
64c1			; lots of CR/LF 
64c1			;	ld c, 9 
64c1			;	ld de, .clscpm 
64c1			;	call 5 
64c1			 
64c1			; xterm cls 
64c1 0e 02			ld c, 2 
64c3 1e 1b			ld e, 27 
64c5 cd 05 00			call 5 
64c8			; cls causes too much flicker 
64c8			;	ld c, 2 
64c8			;	ld e, 'c' 
64c8			;	call 5 
64c8			 
64c8			; use xterm home instead 
64c8 0e 02			ld c, 2 
64ca 1e 5b			ld e, '[' 
64cc cd 05 00			call 5 
64cf 0e 02			ld c, 2 
64d1 1e 48			ld e, 'H' 
64d3 cd 05 00			call 5 
64d6			LLL: equ 0 
64d6			 
64d6			if LLL 
64d6			 
64d6				ld c, 2 
64d6				;ld de, .cls 
64d6				ld e, 27 
64d6			; TODO Replace with CP/M BIOS call 
64d6				call 5 
64d6			 
64d6			 
64d6				ld c, 2 
64d6				;ld de, .cls 
64d6				ld e, '[' 
64d6			; TODO Replace with CP/M BIOS call 
64d6				call 5 
64d6				ld c, 2 
64d6				;ld de, .cls 
64d6				ld e, '2' 
64d6			; TODO Replace with CP/M BIOS call 
64d6				call 5 
64d6				ld c, 2 
64d6				;ld de, .cls 
64d6				ld e, 'J' 
64d6			; TODO Replace with CP/M BIOS call 
64d6				call 5 
64d6			 
64d6			endif 
64d6			 
64d6 d1				pop de 
64d7 c1				pop bc 
64d8 e1				pop hl 
64d9			 
64d9			 
64d9 22 c9 eb		        ld (display_write_tmp), hl 	  
64dc 3e 00			ld a, kLCD_Line1 
64de			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64de 06 28			ld b, display_cols 
64e0 ed 5b c9 eb		ld de, (display_write_tmp) 
64e4 cd 67 65			call write_len_string 
64e7				 
64e7			 
64e7 e5			push hl 
64e8 d5			push de 
64e9 c5			push bc 
64ea 0e 02			ld c, 2 
64ec 1e 0a			ld e, 10 
64ee cd 05 00			call 5 
64f1 0e 02			ld c, 2 
64f3 1e 0d			ld e, 13 
64f5 cd 05 00			call 5 
64f8			; TODO Replace with CP/M BIOS call 
64f8				;rst $30 
64f8 c1			pop bc 
64f9 d1			pop de 
64fa e1			pop hl 
64fb			 
64fb				 
64fb 2a c9 eb			ld hl, (display_write_tmp) 
64fe 11 28 00			ld de, display_cols 
6501 19				add hl,de 
6502 22 c9 eb			ld (display_write_tmp),hl 
6505			 
6505				 
6505 3e 28			ld a, kLCD_Line2 
6507			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6507 06 28			ld b, display_cols 
6509 ed 5b c9 eb		ld de, (display_write_tmp) 
650d cd 67 65			call write_len_string 
6510				 
6510 2a c9 eb			ld hl, (display_write_tmp) 
6513 11 28 00			ld de, display_cols 
6516 19				add hl,de 
6517 22 c9 eb			ld (display_write_tmp),hl 
651a			 
651a e5			push hl 
651b d5			push de 
651c c5			push bc 
651d 0e 07			ld c, 7 
651f			; TODO Replace with CP/M BIOS call 
651f				;rst $30 
651f 0e 02			ld c, 2 
6521 1e 0a			ld e, 10 
6523 cd 05 00			call 5 
6526 0e 02			ld c, 2 
6528 1e 0d			ld e, 13 
652a cd 05 00			call 5 
652d c1			pop bc 
652e d1			pop de 
652f e1			pop hl 
6530			 
6530				 
6530 3e 50			ld a, kLCD_Line3 
6532			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6532 06 28			ld b, display_cols 
6534 ed 5b c9 eb		ld de, (display_write_tmp) 
6538 cd 67 65			call write_len_string 
653b				 
653b 2a c9 eb			ld hl, (display_write_tmp) 
653e 11 28 00			ld de, display_cols 
6541 19				add hl,de 
6542 22 c9 eb			ld (display_write_tmp),hl 
6545			 
6545 e5			push hl 
6546 d5			push de 
6547 c5			push bc 
6548 0e 07			ld c, 7 
654a			; TODO Replace with CP/M BIOS call 
654a				;rst $30 
654a 0e 02			ld c, 2 
654c 1e 0a			ld e, 10 
654e cd 05 00			call 5 
6551 0e 02			ld c, 2 
6553 1e 0d			ld e, 13 
6555 cd 05 00			call 5 
6558 c1			pop bc 
6559 d1			pop de 
655a e1			pop hl 
655b			 
655b				 
655b 3e 78			ld a, kLCD_Line4 
655d			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
655d 06 28			ld b, display_cols 
655f ed 5b c9 eb		ld de, (display_write_tmp) 
6563 cd 67 65			call write_len_string 
6566 c9					ret 
6567			 
6567			 
6567				; write out a fixed length string given in b from de 
6567			 
6567 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6568 cd 98 64		            CALL fLCD_Data      ;Write character to display 
656b 13				inc de 
656c 10 f9			djnz write_len_string 
656e c9				ret 
656f			 
656f			 
656f			; eof 
# End of file firmware_cpm_display.asm
656f			;include "firmware_key_5x10.asm" 
656f			;;include "firmware_key_4x10.asm" 
656f			include "firmware_key_cpm.asm" 
656f			; Serial keyboard interface for SC114 
656f			 
656f			 
656f			key_init: 
656f				; no init as handled by the SCM bios 
656f c9				ret 
6570			 
6570			 
6570			cin_wait: 
6570			;	ld a, 0 
6570			;	ret 
6570			 
6570				;in a,(SC114_SIO_1_IN) 
6570			        ; Use SCM API to get from whatever console device we are using 
6570			 
6570			; TODO Replace with CP/M BIOS call 
6570 c5				push bc 
6571 0e 01			ld c, $01 
6573 cd 05 00			call 5 
6576 c1				pop bc 
6577 c9				ret 
6578			 
6578			cin: 
6578			 
6578			 
6578 c5				push bc 
6579			 
6579				; any key waiting to process? 
6579			; TODO Replace with CP/M BIOS call 
6579 0e 06			ld c, $06 
657b cd 05 00			call 5 
657e 28 0d			jr z, .cin_skip 
6580			 
6580				; yep, get it 
6580			 
6580 0e 01			ld c, $01 
6582			; TODO Replace with CP/M BIOS call 
6582 cd 05 00			call 5 
6585			 
6585 fe 7f			cp $7f     ; back space 
6587 20 02			jr nz, .skipbs 
6589 3e 08			ld a, KEY_BS 
658b			.skipbs: 
658b			 
658b c1				pop bc 
658c c9				ret 
658d			.cin_skip: 
658d 3e 00			ld a, 0 
658f c1				pop bc 
6590 c9				ret 
6591			 
6591			 
6591			 
6591			 
# End of file firmware_key_cpm.asm
6591			endofcode:  
6591			baseram:  
6591 00				nop 
6592			 
6592			heap_start: equ baseram+15  ; Starting address of heap 
6592			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6592			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6592			;VDU:  EQU     endofcode           ; BASIC Work space 
6592			; eof 
6592			 
# End of file os_mega_cpm.asm
6592
