# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 38 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		.buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 0  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 67 89				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 67 89				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 67 89				call clear_display  
8037			  
8037			  
8037 cd 5d d8				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd ff d8			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 37 90				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 8a 89			call update_display  
8046 cd e4 88			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 6c 89			call fill_display  
804e cd 8a 89			call update_display  
8051 cd e4 88			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 6c 89			call fill_display  
8059 cd 8a 89			call update_display  
805c cd e4 88			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 6c 89			call fill_display  
8064 cd 8a 89			call update_display  
8067 cd e4 88			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 6b 95			ld de, prom_bootmsg  
806f cd 7a 89			call str_at_display  
8072 cd 8a 89			call update_display  
8075			  
8075			  
8075 cd e4 88			call delay1s  
8078 cd e4 88			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 80 95			ld de, prom_bootmsg1  
8080 cd 7a 89			call str_at_display  
8083 cd 8a 89			call update_display  
8086 cd e4 88			call delay1s  
8089 cd e4 88			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 5a eb			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 95 93			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 5c eb			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 95 93			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 5c eb				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 95 93			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd bd 8b				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 5a eb				ld hl, (store_tmp1) 
8110 11 5f eb				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 95 93			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 2a 90				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 95 93			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 95 93			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 95 93			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 95 93			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd bd 8b			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 5c eb			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 95 93			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 95 93			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 5c eb			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 5c eb				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 95 93			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 5d eb			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 95 93			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 95 93			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd a7 88			call storage_clear_page 
829b			 
829b 21 5c eb			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 5d eb		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 5f eb		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 68 eb			ld hl, store_page+3+9 
82b5 3a 41 eb			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 5c eb			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 95 93			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 95 93			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd c9 88			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd c9 88			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd 94 8b				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd c9 88			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd c9 88			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd 94 8b				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 95 93			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 5f eb		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 95 93			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 5c eb			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 95 93			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 95 93			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd bd 8b			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 5c eb			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd bd 8b			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 95 93			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 5c eb			ld a, (store_page)	; get file id 
8410 32 55 eb			ld (store_tmpid), a 
8413			 
8413 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
8416 32 54 eb			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 5c eb			ld (store_page), a 
841f 32 5d eb			ld (store_page+1),a 
8422 11 5c eb			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 95 93			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 54 eb			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 55 eb			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 95 93			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd bd 8b			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 5c eb			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 5c eb			ld (store_page), a 
8482 32 5d eb			ld (store_page+1),a 
8485 11 5c eb			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 95 93			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 95 93			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd b2 8b				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd 94 8b				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd b2 8b				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd 94 8b				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 95 93			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 95 93			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd 94 8b				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd 94 8b				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 95 93			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 5c eb			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 5c eb			ld (store_page),a 
85a3				 
85a3 32 55 eb			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 5c eb			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 95 93			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 5c eb				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 95 93			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 95 93			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 46 eb			ld (store_tmppageid), hl 
8615				 
8615 3a 55 eb			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 5c eb			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 5d eb			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 5e eb			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 95 93			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd fd 8f			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 95 93			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 95 93			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 46 eb			ld hl,(store_tmppageid) 
868b 11 5c eb			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 95 93			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 55 eb			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 95 93			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5 21 40 00			ld hl, STORE_BLOCK_PHY 
86d8				if DEBUG_STORESE 
86d8					DMARK "SRE" 
86d8 f5				push af  
86d9 3a ed 86			ld a, (.dmark)  
86dc 32 71 ee			ld (debug_mark),a  
86df 3a ee 86			ld a, (.dmark+1)  
86e2 32 72 ee			ld (debug_mark+1),a  
86e5 3a ef 86			ld a, (.dmark+2)  
86e8 32 73 ee			ld (debug_mark+2),a  
86eb 18 03			jr .pastdmark  
86ed ..			.dmark: db "SRE"  
86f0 f1			.pastdmark: pop af  
86f1			endm  
# End of macro DMARK
86f1					CALLMONITOR 
86f1 cd 95 93			call break_point_state  
86f4				endm  
# End of macro CALLMONITOR
86f4				endif 
86f4 cd ac 84			call storage_findnextid 
86f7			 
86f7				if DEBUG_STORESE 
86f7					DMARK "SRf" 
86f7 f5				push af  
86f8 3a 0c 87			ld a, (.dmark)  
86fb 32 71 ee			ld (debug_mark),a  
86fe 3a 0d 87			ld a, (.dmark+1)  
8701 32 72 ee			ld (debug_mark+1),a  
8704 3a 0e 87			ld a, (.dmark+2)  
8707 32 73 ee			ld (debug_mark+2),a  
870a 18 03			jr .pastdmark  
870c ..			.dmark: db "SRf"  
870f f1			.pastdmark: pop af  
8710			endm  
# End of macro DMARK
8710					CALLMONITOR 
8710 cd 95 93			call break_point_state  
8713				endm  
# End of macro CALLMONITOR
8713				endif 
8713 cd bd 8b			call ishlzero 
8716			;	ld a, l 
8716			;	add h 
8716			;	cp 0 
8716 28 b8			jr z,.sr_fail			; block not found so EOF 
8718			 
8718				; hl contains page number to load 
8718 d1				pop de   ; get storage 
8719 d5				push de 
871a				if DEBUG_STORESE 
871a					DMARK "SRg" 
871a f5				push af  
871b 3a 2f 87			ld a, (.dmark)  
871e 32 71 ee			ld (debug_mark),a  
8721 3a 30 87			ld a, (.dmark+1)  
8724 32 72 ee			ld (debug_mark+1),a  
8727 3a 31 87			ld a, (.dmark+2)  
872a 32 73 ee			ld (debug_mark+2),a  
872d 18 03			jr .pastdmark  
872f ..			.dmark: db "SRg"  
8732 f1			.pastdmark: pop af  
8733			endm  
# End of macro DMARK
8733					CALLMONITOR 
8733 cd 95 93			call break_point_state  
8736				endm  
# End of macro CALLMONITOR
8736				endif 
8736 cd 79 81			call storage_read_block 
8739			 
8739			 
8739			; TODO if block has no zeros then need to read next block  
8739			 
8739			 
8739					 
8739 e1				pop hl 		 ; return start of data to show as not EOF 
873a 23				inc hl   ; past file id 
873b 23				inc hl   ; past ext 
873c				if DEBUG_STORESE 
873c					DMARK "SRe" 
873c f5				push af  
873d 3a 51 87			ld a, (.dmark)  
8740 32 71 ee			ld (debug_mark),a  
8743 3a 52 87			ld a, (.dmark+1)  
8746 32 72 ee			ld (debug_mark+1),a  
8749 3a 53 87			ld a, (.dmark+2)  
874c 32 73 ee			ld (debug_mark+2),a  
874f 18 03			jr .pastdmark  
8751 ..			.dmark: db "SRe"  
8754 f1			.pastdmark: pop af  
8755			endm  
# End of macro DMARK
8755					CALLMONITOR 
8755 cd 95 93			call break_point_state  
8758				endm  
# End of macro CALLMONITOR
8758				endif 
8758 c9					ret 
8759			 
8759			 
8759			 
8759			; 
8759			; Append File 
8759			; 
8759			; hl - file id to locate 
8759			; de - pointer to (multi block) string to write 
8759			 
8759			.sa_notfound: 
8759 d1				pop de 
875a c9				ret 
875b			 
875b			 
875b			storage_append: 
875b				; hl -  file id to append to 
875b				; de - string to append 
875b			 
875b d5				push de 
875c				 
875c				if DEBUG_STORESE 
875c					DMARK "AP1" 
875c f5				push af  
875d 3a 71 87			ld a, (.dmark)  
8760 32 71 ee			ld (debug_mark),a  
8763 3a 72 87			ld a, (.dmark+1)  
8766 32 72 ee			ld (debug_mark+1),a  
8769 3a 73 87			ld a, (.dmark+2)  
876c 32 73 ee			ld (debug_mark+2),a  
876f 18 03			jr .pastdmark  
8771 ..			.dmark: db "AP1"  
8774 f1			.pastdmark: pop af  
8775			endm  
# End of macro DMARK
8775					CALLMONITOR 
8775 cd 95 93			call break_point_state  
8778				endm  
# End of macro CALLMONITOR
8778				endif 
8778			 
8778 7d				ld a, l 
8779 32 55 eb			ld (store_tmpid), a 
877c			 
877c				; get file header  
877c			 
877c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
877e 3a 55 eb			ld a, (store_tmpid) 
8781 5f				ld e, a 
8782			 
8782 21 40 00				ld hl, STORE_BLOCK_PHY 
8785 cd ac 84				call storage_findnextid 
8788			 
8788 cd bd 8b			call ishlzero 
878b 28 cc			jr z, .sa_notfound 
878d			 
878d 22 46 eb			ld (store_tmppageid), hl 
8790			 
8790				; TODO handle file id not found 
8790			 
8790				if DEBUG_STORESE 
8790					DMARK "AP2" 
8790 f5				push af  
8791 3a a5 87			ld a, (.dmark)  
8794 32 71 ee			ld (debug_mark),a  
8797 3a a6 87			ld a, (.dmark+1)  
879a 32 72 ee			ld (debug_mark+1),a  
879d 3a a7 87			ld a, (.dmark+2)  
87a0 32 73 ee			ld (debug_mark+2),a  
87a3 18 03			jr .pastdmark  
87a5 ..			.dmark: db "AP2"  
87a8 f1			.pastdmark: pop af  
87a9			endm  
# End of macro DMARK
87a9					CALLMONITOR 
87a9 cd 95 93			call break_point_state  
87ac				endm  
# End of macro CALLMONITOR
87ac				endif 
87ac			 
87ac				; update file extent count 
87ac			 
87ac 11 5c eb			ld de, store_page 
87af			 
87af cd 79 81			call storage_read_block 
87b2			 
87b2				if DEBUG_STORESE 
87b2					DMARK "AP3" 
87b2 f5				push af  
87b3 3a c7 87			ld a, (.dmark)  
87b6 32 71 ee			ld (debug_mark),a  
87b9 3a c8 87			ld a, (.dmark+1)  
87bc 32 72 ee			ld (debug_mark+1),a  
87bf 3a c9 87			ld a, (.dmark+2)  
87c2 32 73 ee			ld (debug_mark+2),a  
87c5 18 03			jr .pastdmark  
87c7 ..			.dmark: db "AP3"  
87ca f1			.pastdmark: pop af  
87cb			endm  
# End of macro DMARK
87cb					CALLMONITOR 
87cb cd 95 93			call break_point_state  
87ce				endm  
# End of macro CALLMONITOR
87ce				endif 
87ce			;	ld (store_tmppageid), hl 
87ce			 
87ce 3a 5e eb			ld a, (store_page+2) 
87d1 3c				inc a 
87d2 32 5e eb			ld (store_page+2), a 
87d5 32 54 eb			ld (store_tmpext), a 
87d8				 
87d8				if DEBUG_STORESE 
87d8					DMARK "AP3" 
87d8 f5				push af  
87d9 3a ed 87			ld a, (.dmark)  
87dc 32 71 ee			ld (debug_mark),a  
87df 3a ee 87			ld a, (.dmark+1)  
87e2 32 72 ee			ld (debug_mark+1),a  
87e5 3a ef 87			ld a, (.dmark+2)  
87e8 32 73 ee			ld (debug_mark+2),a  
87eb 18 03			jr .pastdmark  
87ed ..			.dmark: db "AP3"  
87f0 f1			.pastdmark: pop af  
87f1			endm  
# End of macro DMARK
87f1					CALLMONITOR 
87f1 cd 95 93			call break_point_state  
87f4				endm  
# End of macro CALLMONITOR
87f4				endif 
87f4 2a 46 eb			ld hl, (store_tmppageid) 
87f7 11 5c eb			ld de, store_page 
87fa cd de 81			call storage_write_block 
87fd			 
87fd				; find free block 
87fd			 
87fd 11 00 00			ld de, 0			 ; file extent to locate 
8800			 
8800 21 40 00				ld hl, STORE_BLOCK_PHY 
8803 cd ac 84				call storage_findnextid 
8806 cd bd 8b			call ishlzero 
8809 ca 59 87			jp z, .sa_notfound 
880c			 
880c					; TODO handle no space left 
880c					 
880c 22 46 eb				ld (store_tmppageid), hl 
880f			 
880f				if DEBUG_STORESE 
880f					DMARK "AP4" 
880f f5				push af  
8810 3a 24 88			ld a, (.dmark)  
8813 32 71 ee			ld (debug_mark),a  
8816 3a 25 88			ld a, (.dmark+1)  
8819 32 72 ee			ld (debug_mark+1),a  
881c 3a 26 88			ld a, (.dmark+2)  
881f 32 73 ee			ld (debug_mark+2),a  
8822 18 03			jr .pastdmark  
8824 ..			.dmark: db "AP4"  
8827 f1			.pastdmark: pop af  
8828			endm  
# End of macro DMARK
8828					CALLMONITOR 
8828 cd 95 93			call break_point_state  
882b				endm  
# End of macro CALLMONITOR
882b				endif 
882b					; init the buffer with zeros so we can id if the buffer is full or not 
882b			 
882b e5					push hl 
882c c5					push bc 
882d			 
882d 21 5c eb				ld hl, store_page 
8830 06 40				ld b, STORE_BLOCK_PHY 
8832 3e 00				ld a, 0 
8834 77			.zeroblock:	ld (hl), a 
8835 23					inc hl 
8836 10 fc				djnz .zeroblock 
8838			 
8838 c1					pop bc 
8839 e1					pop hl 
883a			 
883a					; construct block 
883a			 
883a 3a 55 eb				ld a, (store_tmpid) 
883d 32 5c eb				ld (store_page), a   ; file id 
8840 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
8843 32 5d eb				ld (store_page+1), a 
8846			 
8846 e1					pop hl    ; get string to write 
8847 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8849 11 5e eb				ld de, store_page+2 
884c			 
884c				if DEBUG_STORESE 
884c					DMARK "AP5" 
884c f5				push af  
884d 3a 61 88			ld a, (.dmark)  
8850 32 71 ee			ld (debug_mark),a  
8853 3a 62 88			ld a, (.dmark+1)  
8856 32 72 ee			ld (debug_mark+1),a  
8859 3a 63 88			ld a, (.dmark+2)  
885c 32 73 ee			ld (debug_mark+2),a  
885f 18 03			jr .pastdmark  
8861 ..			.dmark: db "AP5"  
8864 f1			.pastdmark: pop af  
8865			endm  
# End of macro DMARK
8865					CALLMONITOR 
8865 cd 95 93			call break_point_state  
8868				endm  
# End of macro CALLMONITOR
8868				endif 
8868			 
8868			 
8868			 
8868					; fill buffer with data until end of string or full block 
8868			 
8868 7e			.appd:		ld a, (hl) 
8869 12					ld (de), a 
886a fe 00				cp 0 
886c 28 04				jr z, .appdone 
886e 23					inc hl 
886f 13					inc de 
8870 10 f6				djnz .appd 
8872			 
8872 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8873 f5					push af   		; save last byte dumped 
8874			 
8874			 
8874 2a 46 eb			ld hl, (store_tmppageid) 
8877 11 5c eb			ld de, store_page 
887a				if DEBUG_STORESE 
887a					DMARK "AP6" 
887a f5				push af  
887b 3a 8f 88			ld a, (.dmark)  
887e 32 71 ee			ld (debug_mark),a  
8881 3a 90 88			ld a, (.dmark+1)  
8884 32 72 ee			ld (debug_mark+1),a  
8887 3a 91 88			ld a, (.dmark+2)  
888a 32 73 ee			ld (debug_mark+2),a  
888d 18 03			jr .pastdmark  
888f ..			.dmark: db "AP6"  
8892 f1			.pastdmark: pop af  
8893			endm  
# End of macro DMARK
8893					CALLMONITOR 
8893 cd 95 93			call break_point_state  
8896				endm  
# End of macro CALLMONITOR
8896				endif 
8896 cd de 81				call storage_write_block 
8899			 
8899			 
8899				; was that a full block of data written? 
8899				; any more to write out? 
8899			 
8899				; if yes then set vars and jump to start of function again 
8899			 
8899 f1					pop af 
889a d1					pop de 
889b			 
889b fe 00				cp 0		 ; no, string was fully written 
889d c8					ret z 
889e			 
889e					; setup vars for next cycle 
889e			 
889e 3a 55 eb				ld a, (store_tmpid) 
88a1 6f					ld l, a 
88a2 26 00				ld h, 0 
88a4			 
88a4 c3 5b 87			 	jp storage_append	 ; yes, need to write out some more 
88a7			 
88a7			 
88a7			 
88a7			 
88a7			 
88a7			 
88a7			 
88a7			if DEBUG_STORECF 
88a7			storageput:	 
88a7					ret 
88a7			storageread: 
88a7					ld hl, store_page 
88a7					ld b, 200 
88a7					ld a,0 
88a7			.src:		ld (hl),a 
88a7					inc hl 
88a7					djnz .src 
88a7					 
88a7			 
88a7					ld de, 0 
88a7					ld bc, 1 
88a7					ld hl, store_page 
88a7					call cfRead 
88a7			 
88a7				call cfGetError 
88a7				ld hl,scratch 
88a7				call hexout 
88a7				ld hl, scratch+2 
88a7				ld a, 0 
88a7				ld (hl),a 
88a7				ld de, scratch 
88a7				ld a,display_row_1 
88a7				call str_at_display 
88a7				call update_display 
88a7			 
88a7					ld hl, store_page 
88a7					ld (os_cur_ptr),hl 
88a7			 
88a7					ret 
88a7			endif 
88a7			 
88a7			 
88a7			; Clear out the main buffer store (used to remove junk before writing a new block) 
88a7			 
88a7			storage_clear_page: 
88a7 e5				push hl 
88a8 d5				push de 
88a9 c5				push bc 
88aa 21 5c eb			ld hl, store_page 
88ad 3e 00			ld a, 0 
88af 77				ld (hl), a 
88b0			 
88b0 11 5d eb			ld de, store_page+1 
88b3 01 40 00			ld bc, STORE_BLOCK_PHY 
88b6			 
88b6 ed b0			ldir 
88b8				 
88b8 c1				pop bc 
88b9 d1				pop de 
88ba e1				pop hl 
88bb c9				ret 
88bc			 
88bc			; eof 
# End of file firmware_storage.asm
88bc			  
88bc			; support routines for above hardware abstraction layer  
88bc			  
88bc			include "firmware_general.asm"        ; general support functions  
88bc			 
88bc			; word look up 
88bc			 
88bc			; in 
88bc			; a is the index 
88bc			; hl is pointer start of array 
88bc			; 
88bc			; returns 
88bc			; hl to the word 
88bc			; 
88bc			 
88bc			table_lookup:  
88bc d5					push de 
88bd eb					ex de, hl 
88be			 
88be 6f					ld l, a 
88bf 26 00				ld h, 0 
88c1 29					add hl, hl 
88c2 19					add hl, de 
88c3 7e					ld a, (hl) 
88c4 23					inc hl 
88c5 66					ld h,(hl) 
88c6 6f					ld l, a 
88c7			 
88c7 d1					pop de 
88c8 c9					ret 
88c9			 
88c9			; Delay loops 
88c9			 
88c9			 
88c9			 
88c9			aDelayInMS: 
88c9 c5				push bc 
88ca 47				ld b,a 
88cb			msdelay: 
88cb c5				push bc 
88cc				 
88cc			 
88cc 01 41 00			ld bc,041h 
88cf cd e7 88			call delayloop 
88d2 c1				pop bc 
88d3 05				dec b 
88d4 20 f5			jr nz,msdelay 
88d6			 
88d6			;if CPU_CLOCK_8MHZ 
88d6			;msdelay8: 
88d6			;	push bc 
88d6			;	 
88d6			; 
88d6			;	ld bc,041h 
88d6			;	call delayloop 
88d6			;	pop bc 
88d6			;	dec b 
88d6			;	jr nz,msdelay8 
88d6			;endif 
88d6			 
88d6			 
88d6 c1				pop bc 
88d7 c9				ret 
88d8			 
88d8			 
88d8			delay250ms: 
88d8				;push de 
88d8 01 00 40			ld bc, 04000h 
88db c3 e7 88			jp delayloop 
88de			delay500ms: 
88de				;push de 
88de 01 00 80			ld bc, 08000h 
88e1 c3 e7 88			jp delayloop 
88e4			delay1s: 
88e4				;push bc 
88e4			   ; Clobbers A, d and e 
88e4 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
88e7			delayloop: 
88e7 c5			    push bc 
88e8			 
88e8			if BASE_CPM 
88e8				ld bc, CPM_DELAY_TUNE 
88e8			.cpmloop: 
88e8				push bc 
88e8			 
88e8			endif 
88e8			 
88e8			 
88e8			 
88e8			delayloopi: 
88e8			;	push bc 
88e8			;.dl: 
88e8 cb 47		    bit     0,a    	; 8 
88ea cb 47		    bit     0,a    	; 8 
88ec cb 47		    bit     0,a    	; 8 
88ee e6 ff		    and     255  	; 7 
88f0 0b			    dec     bc      	; 6 
88f1 79			    ld      a,c     	; 4 
88f2 b0			    or      b     	; 4 
88f3 c2 e8 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
88f6			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
88f6				;pop de 
88f6			;pop bc 
88f6			 
88f6			if BASE_CPM 
88f6				pop bc 
88f6				 
88f6			    dec     bc      	; 6 
88f6			    ld      a,c     	; 4 
88f6			    or      b     	; 4 
88f6			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
88f6				 
88f6			 
88f6			endif 
88f6			;if CPU_CLOCK_8MHZ 
88f6			;    pop bc 
88f6			;    push bc 
88f6			;.dl8: 
88f6			;    bit     0,a    	; 8 
88f6			;    bit     0,a    	; 8 
88f6			;    bit     0,a    	; 8 
88f6			;    and     255  	; 7 
88f6			;    dec     bc      	; 6 
88f6			;    ld      a,c     	; 4 
88f6			;    or      b     	; 4 
88f6			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
88f6			;endif 
88f6			 
88f6			;if CPU_CLOCK_10MHZ 
88f6			;    pop bc 
88f6			;    push bc 
88f6			;.dl8: 
88f6			;    bit     0,a    	; 8 
88f6			;    bit     0,a    	; 8 
88f6			;    bit     0,a    	; 8 
88f6			;    and     255  	; 7 
88f6			;    dec     bc      	; 6 
88f6			;    ld      a,c     	; 4 
88f6			;    or      b     	; 4 
88f6			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
88f6			;endif 
88f6 c1			    pop bc 
88f7			 
88f7 c9				ret 
88f8			 
88f8			 
88f8			 
88f8			; eof 
# End of file firmware_general.asm
88f8			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
88f8			; display routines that use the physical hardware abstraction layer 
88f8			 
88f8			 
88f8			; information window 
88f8			 
88f8			; pass hl with 1st string to display 
88f8			; pass de with 2nd string to display 
88f8			 
88f8			info_panel: 
88f8 e5				push hl 
88f9			 
88f9 2a d2 eb			ld hl, (display_fb_active) 
88fc e5				push hl    ; future de destination 
88fd 21 b7 ed				ld hl, display_fb0 
8900 22 d2 eb				ld (display_fb_active), hl 
8903			 
8903			;	call clear_display 
8903			 
8903				if BASE_CPM 
8903				ld a, '.' 
8903				else 
8903 3e a5			ld a, 165 
8905				endif 
8905 cd 6c 89			call fill_display 
8908			 
8908			 
8908 3e 55			ld a, display_row_3 + 5 
890a cd 7a 89			call str_at_display 
890d			 
890d e1				pop hl 
890e d1				pop de 
890f			 
890f e5				push hl 
8910			 
8910			 
8910 3e 2d			ld a, display_row_2 + 5 
8912 cd 7a 89			call str_at_display 
8915			 
8915			 
8915 cd 8a 89			call update_display 
8918 cd 78 99			call next_page_prompt 
891b cd 67 89			call clear_display 
891e			 
891e				 
891e 21 16 ed				ld hl, display_fb1 
8921 22 d2 eb				ld (display_fb_active), hl 
8924 cd 8a 89			call update_display 
8927			 
8927 e1				pop hl 
8928			 
8928 c9				ret 
8929			 
8929			 
8929			 
8929			 
8929			; TODO windowing? 
8929			 
8929			; TODO scroll line up 
8929			 
8929			scroll_up: 
8929			 
8929 e5				push hl 
892a d5				push de 
892b c5				push bc 
892c			 
892c				; get frame buffer  
892c			 
892c 2a d2 eb			ld hl, (display_fb_active) 
892f e5				push hl    ; future de destination 
8930			 
8930 11 28 00			ld  de, display_cols 
8933 19				add hl, de 
8934			 
8934 d1				pop de 
8935			 
8935				;ex de, hl 
8935 01 9f 00			ld bc, display_fb_len -1  
8938			;if DEBUG_FORTH_WORDS 
8938			;	DMARK "SCL" 
8938			;	CALLMONITOR 
8938			;endif	 
8938 ed b0			ldir 
893a			 
893a				; wipe bottom row 
893a			 
893a			 
893a 2a d2 eb			ld hl, (display_fb_active) 
893d 11 a0 00			ld de, display_cols*display_rows 
8940 19				add hl, de 
8941 06 28			ld b, display_cols 
8943 3e 20			ld a, ' ' 
8945			.scwipe: 
8945 77				ld (hl), a 
8946 2b				dec hl 
8947 10 fc			djnz .scwipe 
8949			 
8949				;pop hl 
8949			 
8949 c1				pop bc 
894a d1				pop de 
894b e1				pop hl 
894c			 
894c c9				ret 
894d			 
894d			 
894d			;scroll_upo: 
894d			;	ld de, display_row_1 
894d			 ;	ld hl, display_row_2 
894d			;	ld bc, display_cols 
894d			;	ldir 
894d			;	ld de, display_row_2 
894d			 ;	ld hl, display_row_3 
894d			;	ld bc, display_cols 
894d			;	ldir 
894d			;	ld de, display_row_3 
894d			 ;	ld hl, display_row_4 
894d			;	ld bc, display_cols 
894d			;	ldir 
894d			 
894d			; TODO clear row 4 
894d			 
894d			;	ret 
894d			 
894d				 
894d			scroll_down: 
894d			 
894d e5				push hl 
894e d5				push de 
894f c5				push bc 
8950			 
8950				; get frame buffer  
8950			 
8950 2a d2 eb			ld hl, (display_fb_active) 
8953			 
8953 11 9f 00			ld de, display_fb_len - 1 
8956 19				add hl, de 
8957			 
8957 e5			push hl    ; future de destination 
8958			 
8958 11 28 00			ld  de, display_cols 
895b ed 52			sbc hl, de 
895d			 
895d			 
895d d1				pop de 
895e			 
895e			;	ex de, hl 
895e 01 9f 00			ld bc, display_fb_len -1  
8961			 
8961			 
8961				 
8961			 
8961 ed b0			ldir 
8963			 
8963				; wipe bottom row 
8963			 
8963			 
8963			;	ld hl, (display_fb_active) 
8963			;;	ld de, display_cols*display_rows 
8963			;;	add hl, de 
8963			;	ld b, display_cols 
8963			;	ld a, ' ' 
8963			;.scwiped: 
8963			;	ld (hl), a 
8963			;	dec hl 
8963			;	djnz .scwiped 
8963			 
8963				;pop hl 
8963			 
8963 c1				pop bc 
8964 d1				pop de 
8965 e1				pop hl 
8966			 
8966 c9				ret 
8967			;scroll_down: 
8967			;	ld de, display_row_4 
8967			;	ld hl, display_row_3 
8967			;	ld bc, display_cols 
8967			;	ldir 
8967			;	ld de, display_row_3 
8967			; 	ld hl, display_row_2 
8967			;	ld bc, display_cols 
8967			;	ldir 
8967			;	ld de, display_row_2 
8967			;	ld hl, display_row_1 
8967			;	ld bc, display_cols 
8967			;	ldir 
8967			;;; TODO clear row 1 
8967			;	ret 
8967			 
8967			 
8967			 
8967			 
8967			 
8967			; clear active frame buffer 
8967			 
8967			clear_display: 
8967 3e 20			ld a, ' ' 
8969 c3 6c 89			jp fill_display 
896c			 
896c			; fill active frame buffer with a char in A 
896c			 
896c			fill_display: 
896c 06 a0			ld b,display_fb_len 
896e 2a d2 eb			ld hl, (display_fb_active) 
8971 77			.fd1:	ld (hl),a 
8972 23				inc hl 
8973 10 fc			djnz .fd1 
8975 23				inc hl 
8976 3e 00			ld a,0 
8978 77				ld (hl),a 
8979			 
8979			 
8979 c9				ret 
897a			; Write string (DE) at pos (A) to active frame buffer 
897a			 
897a 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
897d 06 00					ld b,0 
897f 4f					ld c,a 
8980 09					add hl,bc 
8981 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8982 b7			            OR   A              ;Null terminator? 
8983 c8			            RET  Z              ;Yes, so finished 
8984 77					ld (hl),a 
8985 23				inc hl 
8986 13			            INC  DE             ;Point to next character 
8987 18 f8		            JR   .sad1     ;Repeat 
8989 c9					ret 
898a			 
898a			; using current frame buffer write to physical display 
898a			 
898a			update_display: 
898a e5				push hl 
898b 2a d2 eb			ld hl, (display_fb_active) 
898e cd 74 d8			call write_display 
8991 e1				pop hl 
8992 c9				ret 
8993			 
8993			; TODO scrolling 
8993			 
8993			 
8993			; move cursor right one char 
8993			cursor_right: 
8993			 
8993				; TODO shift right 
8993				; TODO if beyond max col 
8993				; TODO       cursor_next_line 
8993			 
8993 c9				ret 
8994			 
8994			 
8994			cursor_next_line: 
8994				; TODO first char 
8994				; TODO line down 
8994				; TODO if past last row 
8994				; TODO    scroll up 
8994			 
8994 c9				ret 
8995			 
8995			cursor_left: 
8995				; TODO shift left 
8995				; TODO if beyond left  
8995				; TODO     cursor prev line 
8995				 
8995 c9				ret 
8996			 
8996			cursor_prev_line: 
8996				; TODO last char 
8996				; TODO line up 
8996				; TODO if past first row 
8996				; TODO   scroll down 
8996			 
8996 c9				ret 
8997			 
8997			 
8997			cout: 
8997				; A - char 
8997 c9				ret 
8998			 
8998			 
8998			; Display a menu and allow item selection (optional toggle items) 
8998			; 
8998			; format: 
8998			; hl pointer to word array with zero term for items 
8998			; e.g.    db item1 
8998			;         db .... 
8998			;         db 0 
8998			; 
8998			; a = starting menu item  
8998			; 
8998			; de = pointer item toggle array   (todo) 
8998			; 
8998			; returns item selected in a 1-... 
8998			; returns 0 if back button pressed 
8998			; 
8998			; NOTE: Uses system frame buffer to display 
8998			; 
8998			; LEFT, Q = go back 
8998			; RIGHT, SPACE, CR = select 
8998			; UP, A - Up 
8998			; DOWN, Z - Down 
8998			 
8998			 
8998			 
8998			 
8998			 
8998			menu: 
8998			 
8998					; keep array pointer 
8998			 
8998 22 5a eb				ld (store_tmp1), hl 
899b 32 58 eb				ld (store_tmp2), a 
899e			 
899e					; check for key bounce 
899e			 
899e			if BASE_KEV 
899e			 
899e			.mbounce:	call cin 
899e					cp 0 
899e					jr nz, .mbounce 
899e			endif 
899e					; for ease use ex 
899e			 
899e					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
899e 21 b7 ed				ld hl, display_fb0 
89a1 22 d2 eb				ld (display_fb_active), hl 
89a4			 
89a4 cd 67 89		.mloop:		call clear_display 
89a7 cd 8a 89				call update_display 
89aa			 
89aa					; draw selection id '>' at 1 
89aa			 
89aa					; init start of list display 
89aa			 
89aa 3e 05				ld a, 5 
89ac 32 56 eb				ld (store_tmp3), a   ; display row count 
89af 3a 58 eb				ld a,( store_tmp2) 
89b2 32 59 eb				ld (store_tmp2+1), a   ; display item count 
89b5			 
89b5					 
89b5			.mitem:	 
89b5			 
89b5			 
89b5 3a 59 eb				ld a,(store_tmp2+1) 
89b8 6f					ld l, a 
89b9 26 00				ld h, 0 
89bb 29					add hl, hl 
89bc ed 5b 5a eb			ld de, (store_tmp1) 
89c0 19					add hl, de 
89c1 7e					ld a, (hl) 
89c2 23					inc hl 
89c3 66					ld h,(hl) 
89c4 6f					ld l, a 
89c5			 
89c5 cd bd 8b				call ishlzero 
89c8 28 1a				jr z, .mdone 
89ca			 
89ca eb					ex de, hl 
89cb 3a 56 eb				ld a, (store_tmp3) 
89ce cd 7a 89				call str_at_display 
89d1					 
89d1			 
89d1					; next item 
89d1 3a 59 eb				ld a, (store_tmp2+1) 
89d4 3c					inc a 
89d5 32 59 eb				ld (store_tmp2+1), a   ; display item count 
89d8			 
89d8			 		; next row 
89d8			 
89d8 3a 56 eb				ld a, (store_tmp3) 
89db c6 28				add display_cols 
89dd 32 56 eb				ld (store_tmp3), a 
89e0			 
89e0					; at end of screen? 
89e0			 
89e0 fe 10				cp display_rows*4 
89e2 20 d1				jr nz, .mitem 
89e4			 
89e4			 
89e4			.mdone: 
89e4 cd bd 8b				call ishlzero 
89e7 28 08				jr z, .nodn 
89e9			 
89e9 3e 78				ld a, display_row_4 
89eb 11 6a 8a				ld de, .mdown 
89ee cd 7a 89				call str_at_display 
89f1			 
89f1					; draw options to fill the screens with active item on line 1 
89f1					; if current option is 2 or more then display ^ in top 
89f1			 
89f1 3a 58 eb		.nodn:		ld a, (store_tmp2) 
89f4 fe 00				cp 0 
89f6 28 08				jr z, .noup 
89f8			 
89f8 3e 00				ld a, 0 
89fa 11 68 8a				ld de, .mup 
89fd cd 7a 89				call str_at_display 
8a00			 
8a00 3e 02		.noup:		ld a, 2 
8a02 11 66 8a				ld de, .msel 
8a05 cd 7a 89				call str_at_display 
8a08			 
8a08					; if current option + 1 is not null then display V in bottom 
8a08					; get key 
8a08 cd 8a 89				call update_display 
8a0b			 
8a0b			 
8a0b					; handle key 
8a0b			 
8a0b cd 00 d9				call cin_wait 
8a0e			 
8a0e fe 05				cp KEY_UP 
8a10 28 2b				jr z, .mgoup 
8a12 fe 61				cp 'a' 
8a14 28 27				jr z, .mgoup 
8a16 fe 0a				cp KEY_DOWN 
8a18 28 32				jr z, .mgod 
8a1a fe 7a				cp 'z' 
8a1c 28 2e				jr z, .mgod 
8a1e fe 20				cp ' ' 
8a20 28 34				jr z, .goend 
8a22 fe 0c				cp KEY_RIGHT 
8a24 28 30				jr z, .goend 
8a26 fe 0d				cp KEY_CR 
8a28 28 2c				jr z, .goend 
8a2a fe 71				cp 'q' 
8a2c 28 0b				jr z, .goback 
8a2e			 
8a2e fe 0b				cp KEY_LEFT 
8a30 28 07				jr z, .goback 
8a32 fe 08				cp KEY_BS 
8a34 28 03				jr z, .goback 
8a36 c3 a4 89				jp .mloop 
8a39			 
8a39			.goback: 
8a39 3e 00			ld a, 0 
8a3b 18 1d			jr .goend2 
8a3d			 
8a3d				; move up one 
8a3d			.mgoup: 
8a3d 3a 58 eb				ld a, (store_tmp2) 
8a40 fe 00				cp 0 
8a42 ca a4 89				jp z, .mloop 
8a45 3d					dec a 
8a46 32 58 eb				ld (store_tmp2), a 
8a49 c3 a4 89				jp .mloop 
8a4c			 
8a4c				; move down one 
8a4c			.mgod: 
8a4c 3a 58 eb				ld a, (store_tmp2) 
8a4f 3c					inc a 
8a50 32 58 eb				ld (store_tmp2), a 
8a53 c3 a4 89				jp .mloop 
8a56			 
8a56			 
8a56			.goend: 
8a56					; get selected item number 
8a56			 
8a56 3a 58 eb				ld a, (store_tmp2) 
8a59 3c					inc a 
8a5a			 
8a5a			.goend2: 
8a5a f5					push af 
8a5b			 
8a5b					; restore active fb 
8a5b					; TODO BUG assumes fb1 
8a5b			 
8a5b 21 16 ed				ld hl, display_fb1 
8a5e 22 d2 eb				ld (display_fb_active), hl 
8a61			 
8a61					; restore main regs 
8a61			 
8a61			 
8a61 cd 8a 89				call update_display 
8a64			 
8a64 f1					pop af 
8a65			 
8a65 c9				ret 
8a66			 
8a66 .. 00		.msel:   db ">",0 
8a68 .. 00		.mup:   db "^",0 
8a6a .. 00		.mdown:   db "v",0 
8a6c			 
8a6c			 
8a6c			; eof 
8a6c			 
# End of file firmware_display.asm
8a6c			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8a6c			; random number generators 
8a6c			 
8a6c			 
8a6c			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8a6c			 
8a6c			 
8a6c			;-----> Generate a random number 
8a6c			; output a=answer 0<=a<=255 
8a6c			; all registers are preserved except: af 
8a6c			random: 
8a6c e5			        push    hl 
8a6d d5			        push    de 
8a6e 2a b4 eb		        ld      hl,(randData) 
8a71 ed 5f		        ld      a,r 
8a73 57			        ld      d,a 
8a74 5e			        ld      e,(hl) 
8a75 19			        add     hl,de 
8a76 85			        add     a,l 
8a77 ac			        xor     h 
8a78 22 b4 eb		        ld      (randData),hl 
8a7b d1			        pop     de 
8a7c e1			        pop     hl 
8a7d c9			        ret 
8a7e			 
8a7e			 
8a7e			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8a7e			 
8a7e			 
8a7e			 
8a7e			;------LFSR------ 
8a7e			;James Montelongo 
8a7e			;optimized by Spencer Putt 
8a7e			;out: 
8a7e			; a = 8 bit random number 
8a7e			RandLFSR: 
8a7e 21 ba eb		        ld hl,LFSRSeed+4 
8a81 5e			        ld e,(hl) 
8a82 23			        inc hl 
8a83 56			        ld d,(hl) 
8a84 23			        inc hl 
8a85 4e			        ld c,(hl) 
8a86 23			        inc hl 
8a87 7e			        ld a,(hl) 
8a88 47			        ld b,a 
8a89 cb 13		        rl e  
8a8b cb 12			rl d 
8a8d cb 11		        rl c  
8a8f 17				rla 
8a90 cb 13		        rl e  
8a92 cb 12			rl d 
8a94 cb 11		        rl c  
8a96 17				rla 
8a97 cb 13		        rl e  
8a99 cb 12			rl d 
8a9b cb 11		        rl c  
8a9d 17				rla 
8a9e 67			        ld h,a 
8a9f cb 13		        rl e  
8aa1 cb 12			rl d 
8aa3 cb 11		        rl c  
8aa5 17				rla 
8aa6 a8			        xor b 
8aa7 cb 13		        rl e  
8aa9 cb 12			rl d 
8aab ac			        xor h 
8aac a9			        xor c 
8aad aa			        xor d 
8aae 21 bc eb		        ld hl,LFSRSeed+6 
8ab1 11 bd eb		        ld de,LFSRSeed+7 
8ab4 01 07 00		        ld bc,7 
8ab7 ed b8		        lddr 
8ab9 12			        ld (de),a 
8aba c9			        ret 
8abb			 
8abb			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8abb			 
8abb			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8abb			 
8abb			 
8abb			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8abb			 
8abb			prng16: 
8abb			;Inputs: 
8abb			;   (seed1) contains a 16-bit seed value 
8abb			;   (seed2) contains a NON-ZERO 16-bit seed value 
8abb			;Outputs: 
8abb			;   HL is the result 
8abb			;   BC is the result of the LCG, so not that great of quality 
8abb			;   DE is preserved 
8abb			;Destroys: 
8abb			;   AF 
8abb			;cycle: 4,294,901,760 (almost 4.3 billion) 
8abb			;160cc 
8abb			;26 bytes 
8abb 2a ae eb		    ld hl,(seed1) 
8abe 44			    ld b,h 
8abf 4d			    ld c,l 
8ac0 29			    add hl,hl 
8ac1 29			    add hl,hl 
8ac2 2c			    inc l 
8ac3 09			    add hl,bc 
8ac4 22 ae eb		    ld (seed1),hl 
8ac7 2a ac eb		    ld hl,(seed2) 
8aca 29			    add hl,hl 
8acb 9f			    sbc a,a 
8acc e6 2d		    and %00101101 
8ace ad			    xor l 
8acf 6f			    ld l,a 
8ad0 22 ac eb		    ld (seed2),hl 
8ad3 09			    add hl,bc 
8ad4 c9			    ret 
8ad5			 
8ad5			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8ad5			 
8ad5			rand32: 
8ad5			;Inputs: 
8ad5			;   (seed1_0) holds the lower 16 bits of the first seed 
8ad5			;   (seed1_1) holds the upper 16 bits of the first seed 
8ad5			;   (seed2_0) holds the lower 16 bits of the second seed 
8ad5			;   (seed2_1) holds the upper 16 bits of the second seed 
8ad5			;   **NOTE: seed2 must be non-zero 
8ad5			;Outputs: 
8ad5			;   HL is the result 
8ad5			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8ad5			;Destroys: 
8ad5			;   AF 
8ad5			;Tested and passes all CAcert tests 
8ad5			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8ad5			;it has a period of 18,446,744,069,414,584,320 
8ad5			;roughly 18.4 quintillion. 
8ad5			;LFSR taps: 0,2,6,7  = 11000101 
8ad5			;291cc 
8ad5			;seed1_0=$+1 
8ad5			;    ld hl,12345 
8ad5			;seed1_1=$+1 
8ad5			;    ld de,6789 
8ad5			;    ld b,h 
8ad5			;    ld c,l 
8ad5			;    add hl,hl \ rl e \ rl d 
8ad5			;    add hl,hl \ rl e \ rl d 
8ad5			;    inc l 
8ad5			;    add hl,bc 
8ad5			;    ld (seed1_0),hl 
8ad5			;    ld hl,(seed1_1) 
8ad5			;    adc hl,de 
8ad5			;    ld (seed1_1),hl 
8ad5			;    ex de,hl 
8ad5			;seed2_0=$+1 
8ad5			;    ld hl,9876 
8ad5			;seed2_1=$+1 
8ad5			;    ld bc,54321 
8ad5			;    add hl,hl \ rl c \ rl b 
8ad5			;    ld (seed2_1),bc 
8ad5			;    sbc a,a 
8ad5			;    and %11000101 
8ad5			;    xor l 
8ad5			;    ld l,a 
8ad5			;    ld (seed2_0),hl 
8ad5			;    ex de,hl 
8ad5			;    add hl,bc 
8ad5			;    ret 
8ad5			; 
8ad5			 
8ad5			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8ad5			; 20 bytes, 86 cycles (excluding ret) 
8ad5			 
8ad5			; returns   hl = pseudorandom number 
8ad5			; corrupts   a 
8ad5			 
8ad5			; generates 16-bit pseudorandom numbers with a period of 65535 
8ad5			; using the xorshift method: 
8ad5			 
8ad5			; hl ^= hl << 7 
8ad5			; hl ^= hl >> 9 
8ad5			; hl ^= hl << 8 
8ad5			 
8ad5			; some alternative shift triplets which also perform well are: 
8ad5			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8ad5			 
8ad5			;  org 32768 
8ad5			 
8ad5			xrnd: 
8ad5 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8ad8 3e 00		  ld a,0 
8ada bd			  cp l 
8adb 20 02		  jr nz, .xrnd1 
8add 2e 01		  ld l, 1 
8adf			.xrnd1: 
8adf			 
8adf 7c			  ld a,h 
8ae0 1f			  rra 
8ae1 7d			  ld a,l 
8ae2 1f			  rra 
8ae3 ac			  xor h 
8ae4 67			  ld h,a 
8ae5 7d			  ld a,l 
8ae6 1f			  rra 
8ae7 7c			  ld a,h 
8ae8 1f			  rra 
8ae9 ad			  xor l 
8aea 6f			  ld l,a 
8aeb ac			  xor h 
8aec 67			  ld h,a 
8aed			 
8aed 22 b2 eb		  ld (xrandc),hl 
8af0			 
8af0 c9			  ret 
8af1			;  
8af1			 
8af1			 
8af1			;;;; int maths 
8af1			 
8af1			; https://map.grauw.nl/articles/mult_div_shifts.php 
8af1			; Divide 16-bit values (with 16-bit result) 
8af1			; In: Divide BC by divider DE 
8af1			; Out: BC = result, HL = rest 
8af1			; 
8af1			Div16: 
8af1 21 00 00		    ld hl,0 
8af4 78			    ld a,b 
8af5 06 08		    ld b,8 
8af7			Div16_Loop1: 
8af7 17			    rla 
8af8 ed 6a		    adc hl,hl 
8afa ed 52		    sbc hl,de 
8afc 30 01		    jr nc,Div16_NoAdd1 
8afe 19			    add hl,de 
8aff			Div16_NoAdd1: 
8aff 10 f6		    djnz Div16_Loop1 
8b01 17			    rla 
8b02 2f			    cpl 
8b03 47			    ld b,a 
8b04 79			    ld a,c 
8b05 48			    ld c,b 
8b06 06 08		    ld b,8 
8b08			Div16_Loop2: 
8b08 17			    rla 
8b09 ed 6a		    adc hl,hl 
8b0b ed 52		    sbc hl,de 
8b0d 30 01		    jr nc,Div16_NoAdd2 
8b0f 19			    add hl,de 
8b10			Div16_NoAdd2: 
8b10 10 f6		    djnz Div16_Loop2 
8b12 17			    rla 
8b13 2f			    cpl 
8b14 41			    ld b,c 
8b15 4f			    ld c,a 
8b16 c9			ret 
8b17			 
8b17			 
8b17			;http://z80-heaven.wikidot.com/math 
8b17			; 
8b17			;Inputs: 
8b17			;     DE and A are factors 
8b17			;Outputs: 
8b17			;     A is not changed 
8b17			;     B is 0 
8b17			;     C is not changed 
8b17			;     DE is not changed 
8b17			;     HL is the product 
8b17			;Time: 
8b17			;     342+6x 
8b17			; 
8b17			Mult16: 
8b17			 
8b17 06 08		     ld b,8          ;7           7 
8b19 21 00 00		     ld hl,0         ;10         10 
8b1c 29			       add hl,hl     ;11*8       88 
8b1d 07			       rlca          ;4*8        32 
8b1e 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8b20 19			         add hl,de   ;--         -- 
8b21 10 f9		       djnz $-5      ;13*7+8     99 
8b23 c9			ret 
8b24			 
8b24			; 
8b24			; Square root of 16-bit value 
8b24			; In:  HL = value 
8b24			; Out:  D = result (rounded down) 
8b24			; 
8b24			;Sqr16: 
8b24			;    ld de,#0040 
8b24			;    ld a,l 
8b24			;    ld l,h 
8b24			;    ld h,d 
8b24			;    or a 
8b24			;    ld b,8 
8b24			;Sqr16_Loop: 
8b24			;    sbc hl,de 
8b24			;    jr nc,Sqr16_Skip 
8b24			;    add hl,de 
8b24			;Sqr16_Skip: 
8b24			;    ccf 
8b24			;    rl d 
8b24			;    add a,a 
8b24			;    adc hl,hl 
8b24			;    add a,a 
8b24			;    adc hl,hl 
8b24			;    djnz Sqr16_Loop 
8b24			;    ret 
8b24			; 
8b24			; 
8b24			; Divide 8-bit values 
8b24			; In: Divide E by divider C 
8b24			; Out: A = result, B = rest 
8b24			; 
8b24			Div8: 
8b24 af			    xor a 
8b25 06 08		    ld b,8 
8b27			Div8_Loop: 
8b27 cb 13		    rl e 
8b29 17			    rla 
8b2a 91			    sub c 
8b2b 30 01		    jr nc,Div8_NoAdd 
8b2d 81			    add a,c 
8b2e			Div8_NoAdd: 
8b2e 10 f7		    djnz Div8_Loop 
8b30 47			    ld b,a 
8b31 7b			    ld a,e 
8b32 17			    rla 
8b33 2f			    cpl 
8b34 c9			    ret 
8b35			 
8b35			; 
8b35			; Multiply 8-bit value with a 16-bit value (unrolled) 
8b35			; In: Multiply A with DE 
8b35			; Out: HL = result 
8b35			; 
8b35			Mult12U: 
8b35 2e 00		    ld l,0 
8b37 87			    add a,a 
8b38 30 01		    jr nc,Mult12U_NoAdd0 
8b3a 19			    add hl,de 
8b3b			Mult12U_NoAdd0: 
8b3b 29			    add hl,hl 
8b3c 87			    add a,a 
8b3d 30 01		    jr nc,Mult12U_NoAdd1 
8b3f 19			    add hl,de 
8b40			Mult12U_NoAdd1: 
8b40 29			    add hl,hl 
8b41 87			    add a,a 
8b42 30 01		    jr nc,Mult12U_NoAdd2 
8b44 19			    add hl,de 
8b45			Mult12U_NoAdd2: 
8b45 29			    add hl,hl 
8b46 87			    add a,a 
8b47 30 01		    jr nc,Mult12U_NoAdd3 
8b49 19			    add hl,de 
8b4a			Mult12U_NoAdd3: 
8b4a 29			    add hl,hl 
8b4b 87			    add a,a 
8b4c 30 01		    jr nc,Mult12U_NoAdd4 
8b4e 19			    add hl,de 
8b4f			Mult12U_NoAdd4: 
8b4f 29			    add hl,hl 
8b50 87			    add a,a 
8b51 30 01		    jr nc,Mult12U_NoAdd5 
8b53 19			    add hl,de 
8b54			Mult12U_NoAdd5: 
8b54 29			    add hl,hl 
8b55 87			    add a,a 
8b56 30 01		    jr nc,Mult12U_NoAdd6 
8b58 19			    add hl,de 
8b59			Mult12U_NoAdd6: 
8b59 29			    add hl,hl 
8b5a 87			    add a,a 
8b5b d0			    ret nc 
8b5c 19			    add hl,de 
8b5d c9			    ret 
8b5e			 
8b5e			; 
8b5e			; Multiply 8-bit value with a 16-bit value (right rotating) 
8b5e			; In: Multiply A with DE 
8b5e			;      Put lowest value in A for most efficient calculation 
8b5e			; Out: HL = result 
8b5e			; 
8b5e			Mult12R: 
8b5e 21 00 00		    ld hl,0 
8b61			Mult12R_Loop: 
8b61 cb 3f		    srl a 
8b63 30 01		    jr nc,Mult12R_NoAdd 
8b65 19			    add hl,de 
8b66			Mult12R_NoAdd: 
8b66 cb 23		    sla e 
8b68 cb 12		    rl d 
8b6a b7			    or a 
8b6b c2 61 8b		    jp nz,Mult12R_Loop 
8b6e c9			    ret 
8b6f			 
8b6f			; 
8b6f			; Multiply 16-bit values (with 32-bit result) 
8b6f			; In: Multiply BC with DE 
8b6f			; Out: BCHL = result 
8b6f			; 
8b6f			Mult32: 
8b6f 79			    ld a,c 
8b70 48			    ld c,b 
8b71 21 00 00		    ld hl,0 
8b74 06 10		    ld b,16 
8b76			Mult32_Loop: 
8b76 29			    add hl,hl 
8b77 17			    rla 
8b78 cb 11		    rl c 
8b7a 30 07		    jr nc,Mult32_NoAdd 
8b7c 19			    add hl,de 
8b7d ce 00		    adc a,0 
8b7f d2 83 8b		    jp nc,Mult32_NoAdd 
8b82 0c			    inc c 
8b83			Mult32_NoAdd: 
8b83 10 f1		    djnz Mult32_Loop 
8b85 41			    ld b,c 
8b86 4f			    ld c,a 
8b87 c9			    ret 
8b88			 
8b88			 
8b88			 
8b88			; 
8b88			; Multiply 8-bit values 
8b88			; In:  Multiply H with E 
8b88			; Out: HL = result 
8b88			; 
8b88			Mult8: 
8b88 16 00		    ld d,0 
8b8a 6a			    ld l,d 
8b8b 06 08		    ld b,8 
8b8d			Mult8_Loop: 
8b8d 29			    add hl,hl 
8b8e 30 01		    jr nc,Mult8_NoAdd 
8b90 19			    add hl,de 
8b91			Mult8_NoAdd: 
8b91 10 fa		    djnz Mult8_Loop 
8b93 c9			    ret 
8b94			 
8b94			 
8b94			 
8b94			 
8b94			 
8b94			 
8b94			 
8b94			 
8b94			;;http://z80-heaven.wikidot.com/math 
8b94			;;This divides DE by BC, storing the result in DE, remainder in HL 
8b94			; 
8b94			;DE_Div_BC:          ;1281-2x, x is at most 16 
8b94			;     ld a,16        ;7 
8b94			;     ld hl,0        ;10 
8b94			;     jp $+5         ;10 
8b94			;.DivLoop: 
8b94			;       add hl,bc    ;-- 
8b94			;       dec a        ;64 
8b94			;       jr z,.DivLoopEnd        ;86 
8b94			; 
8b94			;       sla e        ;128 
8b94			;       rl d         ;128 
8b94			;       adc hl,hl    ;240 
8b94			;       sbc hl,bc    ;240 
8b94			;       jr nc,.DivLoop ;23|21 
8b94			;       inc e        ;-- 
8b94			;       jp .DivLoop+1 
8b94			; 
8b94			;.DivLoopEnd: 
8b94			 
8b94			;HL_Div_C: 
8b94			;Inputs: 
8b94			;     HL is the numerator 
8b94			;     C is the denominator 
8b94			;Outputs: 
8b94			;     A is the remainder 
8b94			;     B is 0 
8b94			;     C is not changed 
8b94			;     DE is not changed 
8b94			;     HL is the quotient 
8b94			; 
8b94			;       ld b,16 
8b94			;       xor a 
8b94			;         add hl,hl 
8b94			;         rla 
8b94			;         cp c 
8b94			;         jr c,$+4 
8b94			;           inc l 
8b94			;           sub c 
8b94			;         djnz $-7 
8b94			 
8b94			; https://plutiedev.com/z80-add-8bit-to-16bit 
8b94			 
8b94			addatohl: 
8b94 85			    add   a, l    ; A = A+L 
8b95 6f			    ld    l, a    ; L = A+L 
8b96 8c			    adc   a, h    ; A = A+L+H+carry 
8b97 95			    sub   l       ; A = H+carry 
8b98 67			    ld    h, a    ; H = H+carry 
8b99 c9			ret 
8b9a			 
8b9a			addatode: 
8b9a 83			    add   a, e    ; A = A+L 
8b9b 5f			    ld    e, a    ; L = A+L 
8b9c 8a			    adc   a, d    ; A = A+L+H+carry 
8b9d 93			    sub   e       ; A = H+carry 
8b9e 57			    ld    d, a    ; H = H+carry 
8b9f c9			ret 
8ba0			 
8ba0			 
8ba0			addatobc: 
8ba0 81			    add   a, c    ; A = A+L 
8ba1 4f			    ld    c, a    ; L = A+L 
8ba2 88			    adc   a, b    ; A = A+L+H+carry 
8ba3 91			    sub   c       ; A = H+carry 
8ba4 47			    ld    b, a    ; H = H+carry 
8ba5 c9			ret 
8ba6			 
8ba6			subafromhl: 
8ba6			   ; If A=0 do nothing 
8ba6			    ; Otherwise flip A's sign. Since 
8ba6			    ; the upper byte becomes -1, also 
8ba6			    ; substract 1 from H. 
8ba6 ed 44		    neg 
8ba8 ca b1 8b		    jp    z, Skip 
8bab 25			    dec   h 
8bac			     
8bac			    ; Now add the low byte as usual 
8bac			    ; Two's complement takes care of 
8bac			    ; ensuring the result is correct 
8bac 85			    add   a, l 
8bad 6f			    ld    l, a 
8bae 8c			    adc   a, h 
8baf 95			    sub   l 
8bb0 67			    ld    h, a 
8bb1			Skip: 
8bb1 c9				ret 
8bb2			 
8bb2			 
8bb2			; compare hl and de 
8bb2			; returns:  
8bb2			; if hl = de, z=1, s=0, c0=0 
8bb2			; if hl > de, z=0, s=0, c=0 
8bb2			; if hl < de, z=0, s=1, c=1 
8bb2			cmp16:	 
8bb2 b7				or a 
8bb3 ed 52			sbc hl,de 
8bb5 e0				ret po 
8bb6 7c				ld a,h 
8bb7 1f				rra 
8bb8 ee 40			xor 01000000B 
8bba 37				scf 
8bbb 8f				adc a,a 
8bbc c9				ret 
8bbd			 
8bbd			 
8bbd			; test if hl contains zero   - A is destroyed 
8bbd			 
8bbd			ishlzero:    
8bbd b7				or a     ; reset flags 
8bbe 7c				ld a, h 
8bbf b5				or l        	 
8bc0			 
8bc0 c9				ret 
8bc1			 
8bc1			 
8bc1			 
8bc1			 
8bc1			if FORTH_ENABLE_FLOATMATH 
8bc1			;include "float/bbcmath.z80" 
8bc1			include "float/lpfpcalc.asm" 
8bc1			endif 
8bc1			 
8bc1			 
8bc1			; eof 
8bc1			 
# End of file firmware_maths.asm
8bc1			include "firmware_strings.asm"   ; string handling  
8bc1			 
8bc1			 
8bc1			; TODO string len 
8bc1			; input text string, end on cr with zero term 
8bc1			; a offset into frame buffer to start prompt 
8bc1			; d is max length 
8bc1			; e is display size TODO 
8bc1			; c is current cursor position 
8bc1			; hl is ptr to where string will be stored 
8bc1			 
8bc1			 
8bc1			; TODO check limit of buffer for new inserts 
8bc1			; TODO check insert does not push beyond buffer 
8bc1			; TODO scroll in a limited display area 
8bc1			; TODO scroll whole screen on page wrap 
8bc1			 
8bc1			 
8bc1			; TODO handle KEY_PREVWORD 
8bc1			; TODO handle KEY_NEXTWORD 
8bc1			; TODO handle KEY_HOME 
8bc1			; TODO handle KEY_END 
8bc1			; TODO use LCD cursor? 
8bc1			 
8bc1 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8bc4 81					add c 
8bc5 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8bc8 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8bcb 79					ld a, c 
8bcc cd 94 8b				call addatohl 
8bcf 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8bd2 7a					ld a,d 
8bd3 32 6c ee			        ld (input_size), a       ; save length of input area 
8bd6 79					ld a, c 
8bd7 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8bda 7b					ld a,e 
8bdb 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8bde					 
8bde					 
8bde			 
8bde			;		ld a,(input_ptr) 
8bde			;		ld (input_under_cursor),a 	; save what is under the cursor 
8bde			 
8bde			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8bde					; init cursor shape if not set by the cin routines 
8bde 21 ca eb				ld hl, cursor_shape 
8be1 3e ff				ld a, 255 
8be3 77					ld (hl), a 
8be4 23					inc hl 
8be5 3e 00				ld a, 0 
8be7 77					ld (hl), a 
8be8			 
8be8 3e 0f				ld a, CUR_BLINK_RATE 
8bea 32 66 ee				ld (input_cur_flash), a 
8bed 3e 01				ld a, 1 
8bef 32 65 ee				ld (input_cur_onoff),a 
8bf2			 
8bf2			;	if DEBUG_INPUT 
8bf2			;		push af 
8bf2			;		ld a, 'I' 
8bf2			;		ld (debug_mark),a 
8bf2			;		pop af 
8bf2			;		CALLMONITOR 
8bf2			;	endif 
8bf2			.is1:		; main entry loop 
8bf2			 
8bf2			 
8bf2			 
8bf2					; pause 1ms 
8bf2			 
8bf2 3e 01				ld a, 1 
8bf4 cd c9 88				call aDelayInMS 
8bf7			 
8bf7					; dec flash counter 
8bf7 3a 66 ee				ld a, (input_cur_flash) 
8bfa 3d					dec a 
8bfb 32 66 ee				ld (input_cur_flash), a 
8bfe fe 00				cp 0 
8c00 20 0d				jr nz, .nochgstate 
8c02			 
8c02			 
8c02					; change state 
8c02 3a 65 ee				ld a,(input_cur_onoff) 
8c05 ed 44				neg 
8c07 32 65 ee				ld (input_cur_onoff),a 
8c0a			 
8c0a			 
8c0a					; reset on change of state 
8c0a 3e 0f				ld a, CUR_BLINK_RATE 
8c0c 32 66 ee				ld (input_cur_flash), a 
8c0f			 
8c0f			.nochgstate: 
8c0f					 
8c0f					 
8c0f			 
8c0f					; display cursor  
8c0f			 
8c0f			;		ld hl, (input_start) 
8c0f			;		ld a, (input_cursor) 
8c0f			;		call addatohl 
8c0f			 
8c0f					; get char under cursor and replace with cursor 
8c0f 2a 6f ee		ld hl, (input_ptr) 
8c12			;		ld a, (hl) 
8c12			;		ld (input_under_cursor),a 
8c12			;		ld a, '_' 
8c12			;		ld (hl), a 
8c12			 
8c12					; display string 
8c12			 
8c12 ed 5b 6d ee			ld de, (input_start) 
8c16 3a 6a ee				ld a, (input_at_pos) 
8c19 cd 7a 89				call str_at_display 
8c1c			;	        call update_display 
8c1c			 
8c1c					; find place to put the cursor 
8c1c			;		add h 
8c1c			;		ld l, display_row_1 
8c1c			;		sub l 
8c1c			; (input_at_pos) 
8c1c					;ld c, a 
8c1c			;		ld a, (input_cursor) 
8c1c			;		ld l, (input_at_pos) 
8c1c			;		;ld b, h 
8c1c			;		add l 
8c1c			;		ld (input_at_cursor),a 
8c1c					;ld l,h 
8c1c			 
8c1c			;		ld h, 0 
8c1c			;		ld l,(input_at_pos) 
8c1c			;		ld a, (input_cursor) 
8c1c			;		call addatohl 
8c1c			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8c1c			;		call subafromhl 
8c1c			;		ld a,l 
8c1c			;		ld (input_at_cursor), a 
8c1c			 
8c1c				if DEBUG_INPUT 
8c1c					ld a, (hardware_diag) 
8c1c					cp 0 
8c1c					jr z, .skip_input_diag 
8c1c			 
8c1c					ld a,(input_at_pos) 
8c1c					ld hl, LFSRSeed 
8c1c					call hexout 
8c1c					ld a, (input_cursor) 
8c1c					ld hl, LFSRSeed+2 
8c1c					call hexout 
8c1c					ld a,(input_at_cursor) 
8c1c					ld hl, LFSRSeed+4 
8c1c					call hexout 
8c1c			 
8c1c					ld a,(input_cur_onoff) 
8c1c					ld hl, LFSRSeed+6 
8c1c					call hexout 
8c1c			 
8c1c					ld a,(input_cur_flash) 
8c1c					ld hl, LFSRSeed+8 
8c1c					call hexout 
8c1c			 
8c1c					ld a,(input_len) 
8c1c					ld hl, LFSRSeed+10 
8c1c					call hexout 
8c1c					ld hl, LFSRSeed+12 
8c1c					ld a, 0 
8c1c					ld (hl),a 
8c1c					ld a, display_row_4 
8c1c					ld de, LFSRSeed 
8c1c					call str_at_display 
8c1c					.skip_input_diag: 
8c1c				endif 
8c1c			 
8c1c					; decide on if we are showing the cursor this time round 
8c1c			 
8c1c 3a 65 ee				ld a, (input_cur_onoff) 
8c1f fe ff				cp 255 
8c21 28 13				jr z, .skipcur 
8c23			 
8c23			 
8c23 3a 68 ee				ld a,(input_at_cursor) 
8c26 11 ca eb				ld de, cursor_shape 
8c29 cd 7a 89				call str_at_display 
8c2c			 
8c2c					; save length of current input string 
8c2c 2a 6d ee				ld hl, (input_start) 
8c2f cd f2 8f				call strlenz 
8c32 7d					ld a,l 
8c33 32 60 ee				ld (input_len),a 
8c36			 
8c36			.skipcur: 
8c36			 
8c36 cd 8a 89			        call update_display 
8c39					 
8c39			 
8c39			 
8c39					; wait 
8c39				 
8c39					; TODO loop without wait to flash the cursor and char under cursor	 
8c39 cd 06 d9				call cin    ; _wait 
8c3c			 
8c3c fe 00				cp 0 
8c3e ca f2 8b				jp z, .is1 
8c41			 
8c41					; get ptr to char to input into 
8c41			 
8c41 4f					ld c,a 
8c42 2a 6d ee				ld hl, (input_start) 
8c45 3a 5b ee				ld a, (input_cursor) 
8c48 cd 94 8b				call addatohl 
8c4b 22 6f ee				ld (input_ptr), hl 
8c4e 79					ld a,c 
8c4f			 
8c4f					; replace char under cursor 
8c4f			 
8c4f			;		ld hl, (input_ptr) 
8c4f			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8c4f			;		ld (hl), a 
8c4f			 
8c4f			;	if DEBUG_INPUT 
8c4f			;		push af 
8c4f			;		ld a, 'i' 
8c4f			;		ld (debug_mark),a 
8c4f			;		pop af 
8c4f			;		CALLMONITOR 
8c4f			;	endif 
8c4f fe 0e				cp KEY_HOME 
8c51 20 0e				jr nz, .iske 
8c53			 
8c53 3a 6a ee				ld a, (input_at_pos) 
8c56 32 68 ee				ld (input_at_cursor),a 
8c59 3e 00				ld a, 0 
8c5b 32 5b ee				ld (input_cursor), a 
8c5e c3 f2 8b				jp .is1 
8c61					 
8c61 fe 0f		.iske:		cp KEY_END 
8c63 20 03				jr nz, .isknw 
8c65 c3 f2 8b				jp .is1 
8c68			 
8c68 fe 06		.isknw:		cp KEY_NEXTWORD 
8c6a 20 1b				jr nz, .iskpw 
8c6c			 
8c6c 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8c6f 7e					ld a,(hl)	 
8c70 fe 00				cp 0 
8c72 ca f2 8b				jp z, .is1    ; end of string 
8c75 fe 20				cp ' ' 
8c77 ca f2 8b				jp z, .is1    ; end of word 
8c7a 23					inc hl 
8c7b 22 6f ee				ld (input_ptr), hl 
8c7e 3a 68 ee				ld a, (input_at_cursor) 
8c81 3c					inc a 
8c82 32 68 ee				ld (input_at_cursor), a 
8c85 18 e5				jr .isknwm 
8c87			 
8c87 fe 07		.iskpw:		cp KEY_PREVWORD 
8c89 20 1b				jr nz, .iskl 
8c8b			.iskpwm:	 
8c8b 2a 6f ee				ld hl, (input_ptr) 
8c8e 7e					ld a,(hl)	 
8c8f fe 00				cp 0  
8c91 ca f2 8b				jp z, .is1    ; end of string 
8c94 fe 20				cp ' ' 
8c96 ca f2 8b				jp z, .is1    ; end of word 
8c99 2b					dec hl 
8c9a 22 6f ee				ld (input_ptr), hl 
8c9d 3a 68 ee				ld a, (input_at_cursor) 
8ca0 3d					dec a 
8ca1 32 68 ee				ld (input_at_cursor), a 
8ca4 18 e5				jr .iskpwm 
8ca6			 
8ca6			 
8ca6 fe 0b		.iskl:		cp KEY_LEFT 
8ca8 20 27				jr nz, .isk1 
8caa			 
8caa 3a 5b ee				ld a, (input_cursor) 
8cad			 
8cad fe 00				cp 0 
8caf ca f2 8b				jp z, .is1 		; at start of line to ignore  
8cb2			 
8cb2 3d					dec  a 		; TODO check underflow 
8cb3 32 5b ee				ld (input_cursor), a 
8cb6			 
8cb6 2a 6f ee				ld hl, (input_ptr) 
8cb9 2b					dec hl 
8cba 22 6f ee				ld (input_ptr), hl 
8cbd					 
8cbd 3a 68 ee				ld a, (input_at_cursor) 
8cc0 3d					dec a 
8cc1 32 68 ee				ld (input_at_cursor), a 
8cc4			 
8cc4 3e 01				ld a, 1		; show cursor moving 
8cc6 32 65 ee				ld (input_cur_onoff),a 
8cc9 3e 0f				ld a, CUR_BLINK_RATE 
8ccb 32 66 ee				ld (input_cur_flash), a 
8cce			 
8cce c3 f2 8b				jp .is1 
8cd1			 
8cd1 fe 0c		.isk1:		cp KEY_RIGHT 
8cd3 20 2a				jr nz, .isk2 
8cd5			 
8cd5 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8cd8 5f					ld e,a 
8cd9 3a 5b ee				ld a, (input_cursor) 
8cdc bb					cp e 
8cdd ca f2 8b				jp z, .is1		; at the end of string so dont go right 
8ce0			 
8ce0 3c					inc  a 		; TODO check overflow 
8ce1 32 5b ee				ld (input_cursor), a 
8ce4			 
8ce4 3a 68 ee				ld a, (input_at_cursor) 
8ce7 3c					inc a 
8ce8 32 68 ee				ld (input_at_cursor), a 
8ceb			 
8ceb 2a 6f ee				ld hl, (input_ptr) 
8cee 23					inc hl 
8cef 22 6f ee				ld (input_ptr), hl 
8cf2			 
8cf2 3e 01				ld a, 1		; show cursor moving 
8cf4 32 65 ee				ld (input_cur_onoff),a 
8cf7 3e 0f				ld a, CUR_BLINK_RATE 
8cf9 32 66 ee				ld (input_cur_flash), a 
8cfc			 
8cfc c3 f2 8b				jp .is1 
8cff			 
8cff fe 05		.isk2:		cp KEY_UP 
8d01			 
8d01 20 26				jr nz, .isk3 
8d03			 
8d03					; swap last command with the current on 
8d03			 
8d03					; move cursor to start of string 
8d03 2a 6d ee				ld hl, (input_start) 
8d06 22 6f ee				ld (input_ptr), hl 
8d09			 
8d09 3a 6a ee				ld a, (input_at_pos) 
8d0c 32 68 ee				ld (input_at_cursor), a 
8d0f			 
8d0f 3e 00				ld a, 0 
8d11 32 5b ee				ld (input_cursor), a 
8d14					 
8d14					; swap input and last command buffers 
8d14			 
8d14 21 fe e6				ld hl, os_cli_cmd 
8d17 11 fd e7				ld de, os_last_cmd 
8d1a 06 ff				ld b, 255 
8d1c 7e			.swap1:		ld a, (hl) 
8d1d 4f					ld c,a 
8d1e 1a					ld a, (de) 
8d1f 77					ld (hl), a 
8d20 79					ld a,c 
8d21 12					ld (de),a 
8d22 23					inc hl 
8d23 13					inc de 
8d24 10 f6				djnz .swap1 
8d26			 
8d26			 
8d26			 
8d26			 
8d26			 
8d26 c3 f2 8b				jp .is1 
8d29			 
8d29 fe 08		.isk3:		cp KEY_BS 
8d2b 20 3c				jr nz, .isk4 
8d2d			 
8d2d 3a 5b ee				ld a, (input_cursor) 
8d30			 
8d30 fe 00				cp 0 
8d32 ca f2 8b				jp z, .is1 		; at start of line to ignore  
8d35			 
8d35 3d					dec  a 		; TODO check underflow 
8d36 32 5b ee				ld (input_cursor), a 
8d39			 
8d39					; hl is source 
8d39					; de needs to be source - 1 
8d39			 
8d39			;		ld a, 0 
8d39			;		dec hl 
8d39			;		ld (hl), a 
8d39			 
8d39 2a 6f ee				ld hl, (input_ptr) 
8d3c 2b					dec hl 
8d3d 22 6f ee				ld (input_ptr), hl 
8d40			 
8d40					; shift all data 
8d40			 
8d40 e5					push hl 
8d41 23					inc hl 
8d42 d1					pop de 
8d43 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8d46 4f					ld c,a 
8d47 06 00				ld b,0 
8d49 ed b0				ldir  
8d4b			 
8d4b			 
8d4b			 
8d4b			 
8d4b 3a 68 ee				ld a, (input_at_cursor) 
8d4e 3d					dec a 
8d4f 32 68 ee				ld (input_at_cursor), a 
8d52			 
8d52			 
8d52 3e 01				ld a, 1		; show cursor moving 
8d54 32 65 ee				ld (input_cur_onoff),a 
8d57 3e 0f				ld a, CUR_BLINK_RATE 
8d59 32 66 ee				ld (input_cur_flash), a 
8d5c			 
8d5c					; remove char 
8d5c 3a 68 ee				ld a, (input_at_cursor) 
8d5f 3c					inc a 
8d60 11 ea 8d				ld de,.iblank 
8d63 cd 7a 89				call str_at_display 
8d66			 
8d66 c3 f2 8b				jp .is1 
8d69			 
8d69 fe 0d		.isk4:		cp KEY_CR 
8d6b 28 6c				jr z, .endinput 
8d6d			 
8d6d					; else add the key press to the end 
8d6d			 
8d6d 4f					ld c, a			; save key pressed 
8d6e			 
8d6e 7e					ld a,(hl)		; get what is currently under char 
8d6f			 
8d6f fe 00				cp 0			; we are at the end of the string 
8d71 20 2f				jr nz, .onchar 
8d73					 
8d73					; add a char to the end of the string 
8d73				 
8d73 71					ld (hl),c 
8d74 23					inc hl 
8d75			;		ld a,' ' 
8d75			;		ld (hl),a 
8d75			;		inc hl 
8d75 3e 00				ld a,0 
8d77 77					ld (hl),a 
8d78 2b					dec hl 
8d79			 
8d79 3a 5b ee				ld a, (input_cursor) 
8d7c 3c					inc a				; TODO check max string length and scroll  
8d7d 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8d80							 
8d80 3a 68 ee				ld a, (input_at_cursor) 
8d83 3c					inc a 
8d84 32 68 ee				ld (input_at_cursor), a 
8d87			 
8d87 2a 6f ee				ld hl, (input_ptr) 
8d8a 23					inc hl 
8d8b 22 6f ee				ld (input_ptr), hl 
8d8e			 
8d8e 2a 6f ee				ld hl, (input_ptr) 
8d91 23					inc hl 
8d92 22 6f ee				ld (input_ptr), hl 
8d95			;	if DEBUG_INPUT 
8d95			;		push af 
8d95			;		ld a, '+' 
8d95			;		ld (debug_mark),a 
8d95			;		pop af 
8d95			;		CALLMONITOR 
8d95			;	endif 
8d95 3e 01				ld a, 1		; show cursor moving 
8d97 32 65 ee				ld (input_cur_onoff),a 
8d9a 3e 0f				ld a, CUR_BLINK_RATE 
8d9c 32 66 ee				ld (input_cur_flash), a 
8d9f c3 f2 8b				jp .is1 
8da2					 
8da2			 
8da2			 
8da2					; if on a char then insert 
8da2			.onchar: 
8da2			 
8da2					; TODO over flow check: make sure insert does not blow out buffer 
8da2			 
8da2					; need to do some maths to use lddr 
8da2			 
8da2 e5					push hl   ; save char pos 
8da3 c5					push bc 
8da4			 
8da4 2a 6d ee				ld hl, (input_start) 
8da7 3a 60 ee				ld a, (input_len) 
8daa cd 94 8b				call addatohl  		; end of string 
8dad 23					inc hl 
8dae 23					inc hl		; past zero term 
8daf e5					push hl 
8db0 23					inc hl 
8db1 e5					push hl  
8db2			 
8db2								; start and end of lddr set, now how much to move? 
8db2			 
8db2							 
8db2 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8db5 47					ld b,a 
8db6 3a 60 ee				ld a,(input_len) 
8db9 5f					ld e,a 
8dba 90					sub b 
8dbb 3c					inc a		;?? 
8dbc 3c					inc a		;?? 
8dbd 3c					inc a		;?? 
8dbe			 
8dbe 06 00				ld b,0 
8dc0 4f					ld c,a 
8dc1			 
8dc1				if DEBUG_INPUT 
8dc1					push af 
8dc1					ld a, 'i' 
8dc1					ld (debug_mark),a 
8dc1					pop af 
8dc1			;		CALLMONITOR 
8dc1				endif 
8dc1 d1					pop de 
8dc2 e1					pop hl 
8dc3				if DEBUG_INPUT 
8dc3					push af 
8dc3					ld a, 'I' 
8dc3					ld (debug_mark),a 
8dc3					pop af 
8dc3			;		CALLMONITOR 
8dc3				endif 
8dc3 ed b8				lddr 
8dc5				 
8dc5			 
8dc5			 
8dc5					; TODO have a key for insert/overwrite mode???? 
8dc5 c1					pop bc 
8dc6 e1					pop hl 
8dc7 71					ld (hl), c		; otherwise overwrite current char 
8dc8					 
8dc8			 
8dc8			 
8dc8			 
8dc8 3a 5b ee				ld a, (input_cursor) 
8dcb 3c					inc  a 		; TODO check overflow 
8dcc 32 5b ee				ld (input_cursor), a 
8dcf			 
8dcf 3a 68 ee				ld a, (input_at_cursor) 
8dd2 3c					inc a 
8dd3 32 68 ee				ld (input_at_cursor), a 
8dd6			 
8dd6 c3 f2 8b				jp .is1 
8dd9			 
8dd9			.endinput:	; TODO look for end of string 
8dd9			 
8dd9					; add trailing space for end of token 
8dd9			 
8dd9 2a 6d ee				ld hl, (input_start) 
8ddc 3a 60 ee				ld a,(input_len) 
8ddf cd 94 8b				call addatohl 
8de2 3e 20				ld a, ' ' 
8de4 77					ld (hl),a 
8de5					; TODO eof of parse marker 
8de5			 
8de5 23					inc hl 
8de6 3e 00				ld a, 0 
8de8 77					ld (hl),a 
8de9			 
8de9			 
8de9 c9					ret 
8dea			 
8dea .. 00		.iblank: db " ",0 
8dec			 
8dec			 
8dec 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8def 22 6d ee				ld (input_start), hl 
8df2 3e 01				ld a,1			; add cursor 
8df4 77					ld (hl),a 
8df5 23					inc hl 
8df6 3e 00				ld a,0 
8df8 77					ld (hl),a 
8df9 22 6f ee				ld (input_ptr), hl 
8dfc 7a					ld a,d 
8dfd 32 6c ee				ld (input_size), a 
8e00 3e 00				ld a,0 
8e02 32 5b ee				ld (input_cursor),a 
8e05			.instr1:	 
8e05			 
8e05					; TODO do block cursor 
8e05					; TODO switch cursor depending on the modifer key 
8e05			 
8e05					; update cursor shape change on key hold 
8e05			 
8e05 2a 6f ee				ld hl, (input_ptr) 
8e08 2b					dec hl 
8e09 3a ca eb				ld a,(cursor_shape) 
8e0c 77					ld (hl), a 
8e0d			 
8e0d					; display entered text 
8e0d 3a 6a ee				ld a,(input_at_pos) 
8e10 cd 64 d8		            	CALL fLCD_Pos       ;Position cursor to location in A 
8e13 ed 5b 6d ee	            	LD   de, (input_start) 
8e17 cd 5e d8		            	CALL fLCD_Str       ;Display string pointed to by DE 
8e1a			 
8e1a cd 06 d9				call cin 
8e1d fe 00				cp 0 
8e1f 28 e4				jr z, .instr1 
8e21			 
8e21					; proecess keyboard controls first 
8e21			 
8e21 2a 6f ee				ld hl,(input_ptr) 
8e24			 
8e24 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8e26 28 5a				jr z, .instrcr 
8e28			 
8e28 fe 08				cp KEY_BS 	; back space 
8e2a 20 0f				jr nz, .instr2 
8e2c					; process back space 
8e2c			 
8e2c					; TODO stop back space if at start of string 
8e2c 2b					dec hl 
8e2d 2b					dec hl ; to over write cursor 
8e2e 3a ca eb				ld a,(cursor_shape) 
8e31					;ld a,0 
8e31 77					ld (hl),a 
8e32 23					inc hl 
8e33 3e 20				ld a," " 
8e35 77					ld (hl),a 
8e36 22 6f ee				ld (input_ptr),hl 
8e39					 
8e39			 
8e39 18 ca				jr .instr1 
8e3b			 
8e3b fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8e3d 20 06				jr nz, .instr3 
8e3f 2b					dec hl 
8e40 22 6f ee				ld (input_ptr),hl 
8e43 18 c0				jr .instr1 
8e45				 
8e45 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8e47 20 06				jr nz, .instr4 
8e49 23					inc hl 
8e4a 22 6f ee				ld (input_ptr),hl 
8e4d 18 b6				jr .instr1 
8e4f			 
8e4f fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8e51 20 06				jr nz, .instr5 
8e53 2b					dec hl 
8e54 22 6f ee				ld (input_ptr),hl 
8e57 18 ac				jr .instr1 
8e59			 
8e59 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8e5b 20 06				jr nz, .instr6 
8e5d 2b					dec hl 
8e5e 22 6f ee				ld (input_ptr),hl 
8e61 18 a2				jr .instr1 
8e63 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8e65 20 0b				jr nz, .instrnew 
8e67			 
8e67 21 d7 e3			ld hl, scratch 
8e6a 11 fd e7			ld de, os_last_cmd 
8e6d cd 8b 8e			call strcpy 
8e70 18 93				jr .instr1 
8e72			 
8e72			 
8e72			.instrnew:	; no special key pressed to see if we have room to store it 
8e72			 
8e72					; TODO do string size test 
8e72			 
8e72 2b					dec hl ; to over write cursor 
8e73 77					ld (hl),a 
8e74 23					inc hl 
8e75 3a ca eb				ld a,(cursor_shape) 
8e78 77					ld (hl),a 
8e79 23					inc hl 
8e7a 3e 00				ld a,0 
8e7c 77					ld (hl),a 
8e7d			 
8e7d 22 6f ee				ld (input_ptr),hl 
8e80					 
8e80 18 83				jr .instr1 
8e82 2b			.instrcr:	dec hl		; remove cursor 
8e83 3e 20				ld a,' '	; TODO add a trailing space for safety 
8e85 77					ld (hl),a 
8e86 23					inc hl 
8e87 3e 00				ld a,0 
8e89 77					ld (hl),a 
8e8a			 
8e8a			 
8e8a					; if at end of line scroll up    
8e8a					; TODO detecting only end of line 4 for scroll up  
8e8a			 
8e8a					;ld   
8e8a			 
8e8a c9					ret 
8e8b			 
8e8b			 
8e8b			; strcpy hl = dest, de source 
8e8b			 
8e8b 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8e8c b7			            OR   A              ;Null terminator? 
8e8d c8			            RET  Z              ;Yes, so finished 
8e8e 1a					ld a,(de) 
8e8f 77					ld (hl),a 
8e90 13			            INC  DE             ;Point to next character 
8e91 23					inc hl 
8e92 18 f7		            JR   strcpy       ;Repeat 
8e94 c9					ret 
8e95			 
8e95			 
8e95			; TODO string_at  
8e95			; pass string which starts with lcd offset address and then null term string 
8e95			 
8e95			; TODO string to dec 
8e95			; TODO string to hex 
8e95			; TODO byte to string hex 
8e95			; TODO byte to string dec 
8e95			 
8e95			 
8e95			 
8e95			; from z80uartmonitor 
8e95			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e95			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8e95			; pass hl for where to put the text 
8e95			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8e95 c5			hexout:	PUSH BC 
8e96 f5					PUSH AF 
8e97 47					LD B, A 
8e98					; Upper nybble 
8e98 cb 3f				SRL A 
8e9a cb 3f				SRL A 
8e9c cb 3f				SRL A 
8e9e cb 3f				SRL A 
8ea0 cd b0 8e				CALL tohex 
8ea3 77					ld (hl),a 
8ea4 23					inc hl	 
8ea5					 
8ea5					; Lower nybble 
8ea5 78					LD A, B 
8ea6 e6 0f				AND 0FH 
8ea8 cd b0 8e				CALL tohex 
8eab 77					ld (hl),a 
8eac 23					inc hl	 
8ead					 
8ead f1					POP AF 
8eae c1					POP BC 
8eaf c9					RET 
8eb0					 
8eb0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eb0			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8eb0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eb0			tohex: 
8eb0 e5					PUSH HL 
8eb1 d5					PUSH DE 
8eb2 16 00				LD D, 0 
8eb4 5f					LD E, A 
8eb5 21 bd 8e				LD HL, .DATA 
8eb8 19					ADD HL, DE 
8eb9 7e					LD A, (HL) 
8eba d1					POP DE 
8ebb e1					POP HL 
8ebc c9					RET 
8ebd			 
8ebd			.DATA: 
8ebd 30					DEFB	30h	; 0 
8ebe 31					DEFB	31h	; 1 
8ebf 32					DEFB	32h	; 2 
8ec0 33					DEFB	33h	; 3 
8ec1 34					DEFB	34h	; 4 
8ec2 35					DEFB	35h	; 5 
8ec3 36					DEFB	36h	; 6 
8ec4 37					DEFB	37h	; 7 
8ec5 38					DEFB	38h	; 8 
8ec6 39					DEFB	39h	; 9 
8ec7 41					DEFB	41h	; A 
8ec8 42					DEFB	42h	; B 
8ec9 43					DEFB	43h	; C 
8eca 44					DEFB	44h	; D 
8ecb 45					DEFB	45h	; E 
8ecc 46					DEFB	46h	; F 
8ecd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8ecd			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8ecd			;;    subtract $30, if result > 9 then subtract $7 more 
8ecd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8ecd			atohex: 
8ecd d6 30				SUB $30 
8ecf fe 0a				CP 10 
8ed1 f8					RET M		; If result negative it was 0-9 so we're done 
8ed2 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8ed4 c9					RET		 
8ed5			 
8ed5			 
8ed5			 
8ed5			 
8ed5			; Get 2 ASCII characters as hex byte from pointer in hl 
8ed5			 
8ed5			BYTERD: 
8ed5 16 00			LD	D,00h		;Set up 
8ed7 cd df 8e			CALL	HEXCON		;Get byte and convert to hex 
8eda 87				ADD	A,A		;First nibble so 
8edb 87				ADD	A,A		;multiply by 16 
8edc 87				ADD	A,A		; 
8edd 87				ADD	A,A		; 
8ede 57				LD	D,A		;Save hi nibble in D 
8edf			HEXCON: 
8edf 7e				ld a, (hl)		;Get next chr 
8ee0 23				inc hl 
8ee1 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8ee3 fe 0a			CP	00Ah		;Is it 0-9 ? 
8ee5 38 02			JR	C,NALPHA	;If so miss next bit 
8ee7 d6 07			SUB	007h		;Else convert alpha 
8ee9			NALPHA: 
8ee9 b2				OR	D		;Add hi nibble back 
8eea c9				RET			; 
8eeb			 
8eeb			 
8eeb			; 
8eeb			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8eeb			; Since the routines get_byte and therefore get_nibble are called, only valid 
8eeb			; characters (0-9a-f) are accepted. 
8eeb			; 
8eeb			;get_word        push    af 
8eeb			;                call    get_byte        ; Get the upper byte 
8eeb			;                ld      h, a 
8eeb			;                call    get_byte        ; Get the lower byte 
8eeb			;                ld      l, a 
8eeb			;                pop     af 
8eeb			;                ret 
8eeb			; 
8eeb			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8eeb			; the routine get_nibble is used only valid characters are accepted - the  
8eeb			; input routine only accepts characters 0-9a-f. 
8eeb			; 
8eeb c5			get_byte:        push    bc              ; Save contents of B (and C) 
8eec 7e					ld a,(hl) 
8eed 23					inc hl 
8eee cd 13 8f		                call    nibble2val      ; Get upper nibble 
8ef1 cb 07		                rlc     a 
8ef3 cb 07		                rlc     a 
8ef5 cb 07		                rlc     a 
8ef7 cb 07		                rlc     a 
8ef9 47			                ld      b, a            ; Save upper four bits 
8efa 7e					ld a,(hl) 
8efb cd 13 8f		                call    nibble2val      ; Get lower nibble 
8efe b0			                or      b               ; Combine both nibbles 
8eff c1			                pop     bc              ; Restore B (and C) 
8f00 c9			                ret 
8f01			; 
8f01			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f01			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f01			; to the serial line interface. The lower 4 bits of A contain the value of  
8f01			; that particular digit. 
8f01			; 
8f01			;get_nibble      ld a,(hl)           ; Read a character 
8f01			;                call    to_upper        ; Convert to upper case 
8f01			;                call    is_hex          ; Was it a hex digit? 
8f01			;                jr      nc, get_nibble  ; No, get another character 
8f01			 ;               call    nibble2val      ; Convert nibble to value 
8f01			 ;               call    print_nibble 
8f01			 ;               ret 
8f01			; 
8f01			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f01			; A valid hexadecimal digit is denoted by a set C flag. 
8f01			; 
8f01			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f01			;                ret     nc              ; Yes 
8f01			;                cp      '0'             ; Less than '0'? 
8f01			;                jr      nc, is_hex_1    ; No, continue 
8f01			;                ccf                     ; Complement carry (i.e. clear it) 
8f01			;                ret 
8f01			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f01			;                ret     c               ; Yes 
8f01			;                cp      'A'             ; Less than 'A'? 
8f01			;                jr      nc, is_hex_2    ; No, continue 
8f01			;                ccf                     ; Yes - clear carry and return 
8f01			;                ret 
8f01			;is_hex_2        scf                     ; Set carry 
8f01			;                ret 
8f01			; 
8f01			; Convert a single character contained in A to upper case: 
8f01			; 
8f01 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f03 d8			                ret     c 
8f04 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f06 d0			                ret     nc              ; Nothing to do, either 
8f07 e6 5f		                and     $5f             ; Convert to upper case 
8f09 c9			                ret 
8f0a			 
8f0a			 
8f0a			to_lower: 
8f0a			 
8f0a			   ; if char is in [A-Z] make it lower case 
8f0a			 
8f0a			   ; enter : a = char 
8f0a			   ; exit  : a = lower case char 
8f0a			   ; uses  : af 
8f0a			 
8f0a fe 41		   cp 'A' 
8f0c d8			   ret c 
8f0d			    
8f0d fe 5b		   cp 'Z'+1 
8f0f d0			   ret nc 
8f10			    
8f10 f6 20		   or $20 
8f12 c9			   ret 
8f13			 
8f13			; 
8f13			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f13			; corresponding value in A. 
8f13			; 
8f13 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f15 38 02		                jr      c, nibble2val_1 ; Yes 
8f17 d6 07		                sub     7               ; Adjust for A-F 
8f19 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f1b e6 0f		                and     $f              ; Only return lower 4 bits 
8f1d c9			                ret 
8f1e			; 
8f1e			; Print_nibble prints a single hex nibble which is contained in the lower  
8f1e			; four bits of A: 
8f1e			; 
8f1e			;print_nibble    push    af              ; We won't destroy the contents of A 
8f1e			;                and     $f              ; Just in case... 
8f1e			;                add     a, '0'             ; If we have a digit we are done here. 
8f1e			;                cp      '9' + 1         ; Is the result > 9? 
8f1e			;                jr      c, print_nibble_1 
8f1e			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f1e			;print_nibble_1  call    putc            ; Print the nibble and 
8f1e			;                pop     af              ; restore the original value of A 
8f1e			;                ret 
8f1e			;; 
8f1e			;; Send a CR/LF pair: 
8f1e			; 
8f1e			;crlf            push    af 
8f1e			;                ld      a, cr 
8f1e			;                call    putc 
8f1e			;                ld      a, lf 
8f1e			;                call    putc 
8f1e			;                pop     af 
8f1e			;                ret 
8f1e			; 
8f1e			; Print_word prints the four hex digits of a word to the serial line. The  
8f1e			; word is expected to be in HL. 
8f1e			; 
8f1e			;print_word      push    hl 
8f1e			;                push    af 
8f1e			;                ld      a, h 
8f1e			;                call    print_byte 
8f1e			;                ld      a, l 
8f1e			;                call    print_byte 
8f1e			;                pop     af 
8f1e			;                pop     hl 
8f1e			;                ret 
8f1e			; 
8f1e			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f1e			; The byte to be printed is expected to be in A. 
8f1e			; 
8f1e			;print_byte      push    af              ; Save the contents of the registers 
8f1e			;                push    bc 
8f1e			;                ld      b, a 
8f1e			;                rrca 
8f1e			;                rrca 
8f1e			;                rrca 
8f1e			;                rrca 
8f1e			;                call    print_nibble    ; Print high nibble 
8f1e			;                ld      a, b 
8f1e			;                call    print_nibble    ; Print low nibble 
8f1e			;                pop     bc              ; Restore original register contents 
8f1e			;                pop     af 
8f1e			;                ret 
8f1e			 
8f1e			 
8f1e			 
8f1e			 
8f1e			 
8f1e			fourehexhl:  
8f1e 7e				ld a,(hl) 
8f1f cd cd 8e			call atohex 
8f22 cb 3f				SRL A 
8f24 cb 3f				SRL A 
8f26 cb 3f				SRL A 
8f28 cb 3f				SRL A 
8f2a 47				ld b, a 
8f2b 23				inc hl 
8f2c 7e				ld a,(hl) 
8f2d 23				inc hl 
8f2e cd cd 8e			call atohex 
8f31 80				add b 
8f32 57				ld d,a 
8f33 7e				ld a,(hl) 
8f34 cd cd 8e			call atohex 
8f37 cb 3f				SRL A 
8f39 cb 3f				SRL A 
8f3b cb 3f				SRL A 
8f3d cb 3f				SRL A 
8f3f 47				ld b, a 
8f40 23				inc hl 
8f41 7e				ld a,(hl) 
8f42 23				inc hl 
8f43 cd cd 8e			call atohex 
8f46 80				add b 
8f47 5f				ld e, a 
8f48 d5				push de 
8f49 e1				pop hl 
8f4a c9				ret 
8f4b			 
8f4b			; pass hl. returns z set if the byte at hl is a digit 
8f4b			;isdigithl:  
8f4b			;	push bc 
8f4b			;	ld a,(hl) 
8f4b			;	cp ':' 
8f4b			;	jr nc, .isdf 		; > 
8f4b			;	cp '0' 
8f4b			;	jr c, .isdf		; < 
8f4b			; 
8f4b			;	; TODO find a better way to set z 
8f4b			; 
8f4b			;	ld b,a 
8f4b			;	cp b 
8f4b			;	pop bc 
8f4b			;	ret 
8f4b			; 
8f4b			;.isdf:	; not digit so clear z 
8f4b			; 
8f4b			;	; TODO find a better way to unset z 
8f4b			; 
8f4b			;	ld b,a 
8f4b			;	inc b 
8f4b			;	cp b 
8f4b			; 
8f4b			;	pop bc 
8f4b			;	ret 
8f4b				 
8f4b				 
8f4b			 
8f4b			 
8f4b			; pass hl as the four byte address to load 
8f4b			 
8f4b			get_word_hl:  
8f4b e5				push hl 
8f4c cd eb 8e			call get_byte 
8f4f				 
8f4f 47				ld b, a 
8f50			 
8f50 e1				pop hl 
8f51 23				inc hl 
8f52 23				inc hl 
8f53			 
8f53			; TODO not able to handle a-f  
8f53 7e				ld a,(hl) 
8f54			;	;cp ':' 
8f54			;	cp 'g' 
8f54			;	jr nc, .single_byte_hl 		; > 
8f54			;	cp 'G' 
8f54			;	jr nc, .single_byte_hl 		; > 
8f54			;	cp '0' 
8f54			;	jr c, .single_byte_hl		; < 
8f54			 
8f54				;call isdigithl 
8f54 fe 00			cp 0 
8f56 28 06			jr z, .single_byte_hl 
8f58			 
8f58			.getwhln:   ; hex word so get next byte 
8f58			 
8f58 cd eb 8e			call get_byte 
8f5b 6f				ld l, a 
8f5c 60				ld h,b 
8f5d c9				ret 
8f5e 68			.single_byte_hl:   ld l,b 
8f5f 26 00				ld h,0 
8f61 c9					ret 
8f62			 
8f62			 
8f62			 
8f62			 
8f62 21 17 97			ld hl,asc+1 
8f65			;	ld a, (hl) 
8f65			;	call nibble2val 
8f65 cd eb 8e			call get_byte 
8f68			 
8f68			;	call fourehexhl 
8f68 32 0b e4			ld (scratch+52),a 
8f6b				 
8f6b 21 09 e4			ld hl,scratch+50 
8f6e 22 fa e6			ld (os_cur_ptr),hl 
8f71			 
8f71 c9				ret 
8f72			 
8f72			 
8f72			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8f72			 
8f72			; Decimal Unsigned Version 
8f72			 
8f72			;Number in a to decimal ASCII 
8f72			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8f72			;Example: display a=56 as "056" 
8f72			;input: a = number 
8f72			;Output: a=0,value of a in the screen 
8f72			;destroys af,bc (don't know about hl and de) 
8f72			DispAToASCII: 
8f72 0e 9c			ld	c,-100 
8f74 cd 7e 8f			call	.Na1 
8f77 0e f6			ld	c,-10 
8f79 cd 7e 8f			call	.Na1 
8f7c 0e ff			ld	c,-1 
8f7e 06 2f		.Na1:	ld	b,'0'-1 
8f80 04			.Na2:	inc	b 
8f81 81				add	a,c 
8f82 38 fc			jr	c,.Na2 
8f84 91				sub	c		;works as add 100/10/1 
8f85 f5				push af		;safer than ld c,a 
8f86 78				ld	a,b		;char is in b 
8f87			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8f87 f1				pop af		;safer than ld a,c 
8f88 c9				ret 
8f89			 
8f89			; Decimal Signed Version 
8f89			 
8f89			; DispA 
8f89			; -------------------------------------------------------------- 
8f89			; Converts a signed integer value to a zero-terminated ASCII 
8f89			; string representative of that value (using radix 10). 
8f89			; -------------------------------------------------------------- 
8f89			; INPUTS: 
8f89			;     HL     Value to convert (two's complement integer). 
8f89			;     DE     Base address of string destination. (pointer). 
8f89			; -------------------------------------------------------------- 
8f89			; OUTPUTS: 
8f89			;     None 
8f89			; -------------------------------------------------------------- 
8f89			; REGISTERS/MEMORY DESTROYED 
8f89			; AF HL 
8f89			; -------------------------------------------------------------- 
8f89			 
8f89			;DispHLToASCII: 
8f89			;   push    de 
8f89			;   push    bc 
8f89			; 
8f89			;; Detect sign of HL. 
8f89			;    bit    7, h 
8f89			;    jr     z, ._DoConvert 
8f89			; 
8f89			;; HL is negative. Output '-' to string and negate HL. 
8f89			;    ld     a, '-' 
8f89			;    ld     (de), a 
8f89			;    inc    de 
8f89			; 
8f89			;; Negate HL (using two's complement) 
8f89			;    xor    a 
8f89			;    sub    l 
8f89			;    ld     l, a 
8f89			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8f89			;    sbc    a, h 
8f89			;    ld     h, a 
8f89			; 
8f89			;; Convert HL to digit characters 
8f89			;._DoConvert: 
8f89			;    ld     b, 0     ; B will count character length of number 
8f89			;-   ld     a, 10 
8f89			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8f89			;    push   af 
8f89			;    inc    b 
8f89			;    ld     a, h 
8f89			;    or     l 
8f89			;    jr     nz, - 
8f89			; 
8f89			;; Retrieve digits from stack 
8f89			;-   pop    af 
8f89			;    or     $30 
8f89			;    ld     (de), a 
8f89			;    inc    de 
8f89			;    djnz   - 
8f89			; 
8f89			;; Terminate string with NULL 
8f89			;    xor    a 
8f89			;    ld     (de), a 
8f89			; 
8f89			;    pop    bc 
8f89			;    pop    de 
8f89			;    ret 
8f89			 
8f89			;Comments 
8f89			; 
8f89			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8f89			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8f89			;    Note that the output string will not be fixed-width. 
8f89			; 
8f89			;Example Usage 
8f89			; 
8f89			;    ld    hl, -1004 
8f89			;    ld    de, OP1 
8f89			;    call  DispA 
8f89			;    ld    hl, OP1 
8f89			;    syscall  PutS 
8f89			 
8f89			 
8f89			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8f89			 
8f89			 
8f89			;Converts an ASCII string to an unsigned 16-bit integer 
8f89			;Quits when it reaches a non-decimal digit 
8f89			 
8f89			string_to_uint16: 
8f89			atoui_16: 
8f89			;Input: 
8f89			;     DE points to the string 
8f89			;Outputs: 
8f89			;     HL is the result 
8f89			;     A is the 8-bit value of the number 
8f89			;     DE points to the byte after the number 
8f89			;Destroys: 
8f89			;     BC 
8f89			;       if the string is non-empty, BC is HL/10 
8f89			;Size:  24 bytes 
8f89			;Speed: 42+d(104+{0,9}) 
8f89			;       d is the number of digits in the number 
8f89			;       max is 640 cycles for a 5 digit number 
8f89			;Assuming no leading zeros: 
8f89			;1 digit:  146cc 
8f89			;2 digit:  250cc 
8f89			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8f89			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8f89			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8f89			;avg: 544.81158447265625cc (544+13297/16384) 
8f89			;=============================================================== 
8f89 21 00 00		  ld hl,0 
8f8c			.u16a: 
8f8c 1a			  ld a,(de) 
8f8d d6 30		  sub 30h 
8f8f fe 0a		  cp 10 
8f91 d0			  ret nc 
8f92 13			  inc de 
8f93 44			  ld b,h 
8f94 4d			  ld c,l 
8f95 29			  add hl,hl 
8f96 29			  add hl,hl 
8f97 09			  add hl,bc 
8f98 29			  add hl,hl 
8f99 85			  add a,l 
8f9a 6f			  ld l,a 
8f9b 30 ef		  jr nc,.u16a 
8f9d 24			  inc h 
8f9e c3 8c 8f		  jp .u16a 
8fa1			 
8fa1			 
8fa1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fa1			 
8fa1			;written by Zeda 
8fa1			;Converts a 16-bit unsigned integer to an ASCII string. 
8fa1			 
8fa1			uitoa_16: 
8fa1			;Input: 
8fa1			;   DE is the number to convert 
8fa1			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fa1			;Output: 
8fa1			;   HL points to the null-terminated ASCII string 
8fa1			;      NOTE: This isn't necessarily the same as the input HL. 
8fa1 d5			  push de 
8fa2 c5			  push bc 
8fa3 f5			  push af 
8fa4 eb			  ex de,hl 
8fa5			 
8fa5 01 f0 d8		  ld bc,-10000 
8fa8 3e 2f		  ld a,'0'-1 
8faa 3c			  inc a 
8fab 09			  add hl,bc  
8fac 38 fc		   jr c,$-2 
8fae 12			  ld (de),a 
8faf 13			  inc de 
8fb0			 
8fb0 01 e8 03		  ld bc,1000 
8fb3 3e 3a		  ld a,'9'+1 
8fb5 3d			  dec a  
8fb6 09			  add hl,bc  
8fb7 30 fc		   jr nc,$-2 
8fb9 12			  ld (de),a 
8fba 13			  inc de 
8fbb			 
8fbb 01 9c ff		  ld bc,-100 
8fbe 3e 2f		  ld a,'0'-1 
8fc0 3c			  inc a  
8fc1 09			  add hl,bc  
8fc2 38 fc		   jr c,$-2 
8fc4 12			  ld (de),a 
8fc5 13			  inc de 
8fc6			 
8fc6 7d			  ld a,l 
8fc7 26 3a		  ld h,'9'+1 
8fc9 25			  dec h  
8fca c6 0a		  add a,10  
8fcc 30 fb		   jr nc,$-3 
8fce c6 30		  add a,'0' 
8fd0 eb			  ex de,hl 
8fd1 72			  ld (hl),d 
8fd2 23			  inc hl 
8fd3 77			  ld (hl),a 
8fd4 23			  inc hl 
8fd5 36 00		  ld (hl),0 
8fd7			 
8fd7			;Now strip the leading zeros 
8fd7 0e fa		  ld c,-6 
8fd9 09			  add hl,bc 
8fda 3e 30		  ld a,'0' 
8fdc 23			  inc hl  
8fdd be			  cp (hl)  
8fde 28 fc		  jr z,$-2 
8fe0			 
8fe0			;Make sure that the string is non-empty! 
8fe0 7e			  ld a,(hl) 
8fe1 b7			  or a 
8fe2 20 01		  jr nz,.atoub 
8fe4 2b			  dec hl 
8fe5			.atoub: 
8fe5			 
8fe5 f1			  pop af 
8fe6 c1			  pop bc 
8fe7 d1			  pop de 
8fe8 c9			  ret 
8fe9			 
8fe9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8fe9			 
8fe9			toUpper: 
8fe9			;A is the char. 
8fe9			;If A is a lowercase letter, this sets it to the matching uppercase 
8fe9			;18cc or 30cc or 41cc 
8fe9			;avg: 26.75cc 
8fe9 fe 61		  cp 'a' 
8feb d8			  ret c 
8fec fe 7b		  cp 'z'+1 
8fee d0			  ret nc 
8fef d6 20		  sub 'a'-'A' 
8ff1 c9			  ret 
8ff2			 
8ff2			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8ff2			 
8ff2			; String Length 
8ff2			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8ff2			 
8ff2			; Get the length of the null-terminated string starting at $8000 hl 
8ff2			;    LD     HL, $8000 
8ff2			 
8ff2			strlenz: 
8ff2			 
8ff2 af			    XOR    A               ; Zero is the value we are looking for. 
8ff3 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8ff4 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8ff5			                           ; 65, 536 bytes (the entire addressable memory space). 
8ff5 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8ff7			 
8ff7			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8ff7 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8ff8 6f			    LD     L, A             ; number of bytes 
8ff9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ffb 2b			    DEC    HL              ; Compensate for null. 
8ffc c9				ret 
8ffd			 
8ffd			; Get the length of the A terminated string starting at $8000 hl 
8ffd			;    LD     HL, $8000 
8ffd			 
8ffd			strlent: 
8ffd			 
8ffd			                  ; A is the value we are looking for. 
8ffd 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8fff 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9001			                           ; 65, 536 bytes (the entire addressable memory space). 
9001 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9003			 
9003			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9003 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9005 2e 00		    LD     L, 0             ; number of bytes 
9007 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9009 2b			    DEC    HL              ; Compensate for null. 
900a c9				ret 
900b			 
900b			 
900b			;Comparing Strings 
900b			 
900b			;IN    HL     Address of string1. 
900b			;      DE     Address of string2. 
900b			 
900b			; doc given but wrong??? 
900b			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
900b			;      carry  Set if string1 > string2, reset if string1 <= string2. 
900b			; tested 
900b			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
900b			 
900b			strcmp_old: 
900b e5			    PUSH   HL 
900c d5			    PUSH   DE 
900d			 
900d 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
900e be			    CP     (HL)            ; (want to minimize work). 
900f 38 01		    JR     C, Str1IsBigger 
9011 7e			    LD     A, (HL) 
9012			 
9012			Str1IsBigger: 
9012 4f			    LD     C, A             ; Put length in BC 
9013 06 00		    LD     B, 0 
9015 13			    INC    DE              ; Increment pointers to meat of string. 
9016 23			    INC    HL 
9017			 
9017			CmpLoop: 
9017 1a			    LD     A, (DE)          ; Compare bytes. 
9018 ed a1		    CPI 
901a 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
901c 13			    INC    DE              ; Update pointer. 
901d ea 17 90		    JP     PE, CmpLoop 
9020			 
9020 d1			    POP    DE 
9021 e1			    POP    HL 
9022 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9023 be			    CP     (HL) 
9024 c9			    RET 
9025			 
9025			NoMatch: 
9025 2b			    DEC    HL 
9026 be			    CP     (HL)            ; Compare again to affect carry. 
9027 d1			    POP    DE 
9028 e1			    POP    HL 
9029 c9			    RET 
902a			 
902a			;; test strmp 
902a			; 
902a			;ld de, .str1 
902a			;ld hl, .str2 
902a			;call strcmp 
902a			;jr z, .z1 
902a			;;this 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "NZ1" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			;.z1: 
902a			; 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "ZZ1" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			; 
902a			;ld de, .str1 
902a			;ld hl, .str1 
902a			;call strcmp 
902a			;jr z, .z2 
902a			;;this 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "NZ2" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			;.z2: 
902a			; 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "ZZ2" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			; 
902a			;ld de, .str1 
902a			;ld hl, .str2 
902a			;call strcmp 
902a			;jr c, .c1 
902a			; 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "Nc1" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			;.c1: 
902a			;;this 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "cc1" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			; 
902a			;ld de, .str1 
902a			;ld hl, .str1 
902a			;call strcmp 
902a			;jr c, .c2 
902a			;;this 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "Nc2" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			;.c2: 
902a			; 
902a			;	if DEBUG_FORTH_WORDS 
902a			;		DMARK "cc2" 
902a			;		CALLMONITOR 
902a			;	endif 
902a			;	NEXTW 
902a			;.str1:   db "string1",0 
902a			;.str2:   db "string2",0 
902a			 
902a			; only care about direct match or not 
902a			; hl and de strings 
902a			; zero set if the same 
902a			 
902a			strcmp: 
902a 1a				ld a, (de) 
902b be				cp (hl) 
902c 28 02			jr z, .ssame 
902e b7				or a 
902f c9				ret 
9030			 
9030			.ssame:  
9030 fe 00			cp 0 
9032 c8				ret z 
9033			 
9033 23				inc hl 
9034 13				inc de 
9035 18 f3			jr strcmp 
9037				 
9037				 
9037			 
9037			 
9037			 
9037			 
9037			; eof 
9037			 
9037			 
9037			 
9037			 
9037			 
9037			 
# End of file firmware_strings.asm
9037			include "firmware_memory.asm"   ; malloc and free  
9037			 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			.mallocsize: db "Wants malloc >256",0 
9037			.mallocasize: db "MALLOC gives >256",0 
9037			.malloczero: db "MALLOC gives zero",0 
9037			 
9037			malloc_guard_zerolen: 
9037				push hl 
9037				push de 
9037				push af 
9037			 
9037				ld de, 0 
9037			        call cmp16 
9037				jr nz, .lowalloz 
9037			 
9037				push hl 
9037				push de 
9037					ld hl, display_fb0 
9037					ld (display_fb_active), hl 
9037				call clear_display 
9037				ld a, 0 
9037				ld de, .malloczero 
9037				call str_at_display 
9037				call update_display 
9037				call delay1s 
9037				call delay1s 
9037				ld a, 0 
9037				ld (os_view_disable), a 
9037			 
9037				pop de 
9037				pop hl 
9037			 
9037				 
9037			 
9037				CALLMONITOR 
9037			.lowalloz: 
9037			 
9037			 
9037				pop af 
9037				pop de 
9037				pop hl 
9037			ret 
9037			 
9037			malloc_guard_entry: 
9037				push hl 
9037				push de 
9037				push af 
9037			 
9037			 	or a      ;clear carry flag 
9037				push hl 
9037				ld de, 255 
9037				sbc hl, de 
9037				jr c, .lowalloc 
9037			 
9037				push de 
9037					ld hl, display_fb0 
9037					ld (display_fb_active), hl 
9037				call clear_display 
9037				ld a, 0 
9037				ld de, .mallocsize 
9037				call str_at_display 
9037				call update_display 
9037				call delay1s 
9037				call delay1s 
9037				ld a, 0 
9037				ld (os_view_disable), a 
9037			 
9037				pop de 
9037				pop hl 
9037			 
9037				 
9037			 
9037				CALLMONITOR 
9037				jr .lowdone 
9037			.lowalloc: 
9037			 
9037			 
9037				pop hl 
9037			.lowdone:	pop af 
9037				pop de 
9037				pop hl 
9037			ret 
9037			 
9037			malloc_guard_exit: 
9037				push hl 
9037				push de 
9037				push af 
9037			 
9037			 	or a      ;clear carry flag 
9037				push hl 
9037				ld de, 255 
9037				sbc hl, de 
9037				jr c, .lowallocx 
9037			 
9037				push de 
9037					ld hl, display_fb0 
9037					ld (display_fb_active), hl 
9037				call clear_display 
9037				ld a, 0 
9037				ld de, .mallocasize 
9037				call str_at_display 
9037				call update_display 
9037				call delay1s 
9037				call delay1s 
9037				ld a, 0 
9037				ld (os_view_disable), a 
9037				pop de 
9037				pop hl 
9037			 
9037				CALLMONITOR 
9037				jr .lowdonex 
9037			.lowallocx: 
9037			 
9037				pop hl 
9037			.lowdonex:	pop af 
9037				pop de 
9037				pop hl 
9037			ret 
9037			endif 
9037			 
9037			if MALLOC_2 
9037			; Z80 Malloc and Free Functions 
9037			 
9037			; Malloc Function: 
9037			; Input: 
9037			;   HL: Size of block to allocate 
9037			; Output: 
9037			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9037			 
9037			malloc: 
9037				 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			call malloc_guard_entry 
9037			endif 
9037			 
9037			 
9037			 
9037			 
9037					if DEBUG_FORTH_MALLOC 
9037						DMARK "mal" 
9037						CALLMONITOR 
9037					endif 
9037			    push af            ; Save AF register 
9037			    ld a, l            ; Load low byte of size into A 
9037			    or h               ; Check if size is zero 
9037			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9037			 
9037			    ; Allocate memory 
9037			    ld hl, (heap_start) ; Load start of heap into HL 
9037					if DEBUG_FORTH_MALLOC 
9037						DMARK "ma1" 
9037						CALLMONITOR 
9037					endif 
9037			    call malloc_internal ; Call internal malloc function 
9037			    pop af             ; Restore AF register 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037			    ret                ; Return 
9037			 
9037			; Free Function: 
9037			; Input: 
9037			;   HL: Pointer to memory block to free 
9037			; Output: 
9037			;   None 
9037			 
9037			free: 
9037			    push af            ; Save AF register 
9037			    ld a, l            ; Load low byte of pointer into A 
9037			    or h               ; Check if pointer is NULL 
9037			    jp z, free_exit    ; If pointer is NULL, exit 
9037			 
9037			    ; Free memory 
9037			    ld hl, (heap_start) ; Load start of heap into HL 
9037			    call free_internal  ; Call internal free function 
9037			    pop af             ; Restore AF register 
9037			    ret                ; Return 
9037			 
9037			; Internal Malloc Function: 
9037			; Input: 
9037			;   HL: Size of block to allocate 
9037			; Output: 
9037			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9037			 
9037			malloc_internal: 
9037			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9037			    add hl, bc         ; Add management overhead to requested size 
9037			    ex de, hl          ; Save total size in DE, and keep it in HL 
9037					if DEBUG_FORTH_MALLOC 
9037						DMARK "ma2" 
9037						CALLMONITOR 
9037					endif 
9037			 
9037			    ; Search for free memory block 
9037			    ld de, (heap_end)  ; Load end of heap into DE 
9037			    ld bc, 0           ; Initialize counter 
9037			 
9037					if DEBUG_FORTH_MALLOC 
9037						DMARK "ma2" 
9037						CALLMONITOR 
9037					endif 
9037			malloc_search_loop: 
9037			    ; Check if current block is free 
9037			    ld a, (hl)         ; Load current block's status (free or used) 
9037			    cp 0               ; Compare with zero (free) 
9037			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9037			 
9037			    ; Check if current block is large enough 
9037			    ld a, (hl+1)       ; Load high byte of block size 
9037			    cp l               ; Compare with low byte of requested size 
9037			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9037			 
9037			    ld a, (hl+2)       ; Load low byte of block size 
9037			    cp h               ; Compare with high byte of requested size 
9037			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9037			 
9037			    ; Mark block as used 
9037			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9037			 
9037			    ; Calculate remaining space in block 
9037			    ld bc, 0           ; Clear BC 
9037			    add hl, bc         ; Increment HL to point to start of data block 
9037			    add hl, de         ; HL = HL + DE (total size) 
9037			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9037			    add hl, bc         ; Add management overhead to start of data block 
9037			 
9037			    ; Save pointer to allocated block in HL 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037						DMARK "ma5" 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037			    ret 
9037			 
9037			malloc_skip_block_check: 
9037			    ; Move to the next block 
9037			    ld bc, 3           ; Size of management overhead 
9037			    add hl, bc         ; Move to the next block 
9037			    inc de             ; Increment counter 
9037			 
9037			    ; Check if we have reached the end of heap 
9037			    ld a, e            ; Load low byte of heap end address 
9037			    cp (hl)            ; Compare with low byte of current address 
9037			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9037			    ld a, d            ; Load high byte of heap end address 
9037			    cp 0               ; Check if it's zero (end of memory) 
9037			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9037			 
9037			    ; If we reached here, allocation failed 
9037			    xor a              ; Set result to NULL 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037						DMARK "ma6" 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037			    ret 
9037			malloc_exit: 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037						DMARK "ma7" 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037			    ret 
9037			 
9037			; Internal Free Function: 
9037			; Input: 
9037			;   HL: Pointer to memory block to free 
9037			; Output: 
9037			;   None 
9037			 
9037			free_internal: 
9037			    ld de, (heap_start) ; Load start of heap into DE 
9037			    ld bc, 0            ; Initialize counter 
9037			 
9037			free_search_loop: 
9037			    ; Check if current block contains the pointer 
9037			    ld a, l             ; Load low byte of pointer 
9037			    cp (hl+1)           ; Compare with high byte of current block's address 
9037			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9037			    ld a, h             ; Load high byte of pointer 
9037			    cp (hl+2)           ; Compare with low byte of current block's address 
9037			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9037			 
9037			    ; Mark block as free 
9037			    ld (hl), 0          ; Set status byte to indicate free block 
9037			    ret                 ; Return 
9037			 
9037			free_skip_block_check: 
9037			    ; Move to the next block 
9037			    ld bc, 3            ; Size of management overhead 
9037			    add hl, bc          ; Move to the next block 
9037			    inc de              ; Increment counter 
9037			 
9037			    ; Check if we have reached the end of heap 
9037			    ld a, e             ; Load low byte of heap end address 
9037			    cp (hl)             ; Compare with low byte of current address 
9037			    jr nz, free_search_loop  ; If not equal, continue searching 
9037			    ld a, d             ; Load high byte of heap end address 
9037			    cp 0                ; Check if it's zero (end of memory) 
9037			    jr nz, free_search_loop  ; If not zero, continue searching 
9037			 
9037			    ; If we reached here, pointer is not found in heap 
9037			    ret 
9037			 
9037			free_exit: 
9037			    ret                 ; Return 
9037			 
9037			; Define heap start and end addresses 
9037			;heap_start:    .dw 0xC000   ; Start of heap 
9037			;heap_end:      .dw 0xE000   ; End of heap 
9037			 
9037			endif 
9037			 
9037			 
9037			if MALLOC_1 
9037			 
9037			 
9037			 
9037			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9037			 
9037			;moved to firmware.asm 
9037			;heap_start        .equ  0x9000      ; Starting address of heap 
9037			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9037			 
9037			;      .org 0 
9037			;      jp    main 
9037			 
9037			 
9037			;      .org  0x100 
9037			;main: 
9037			;      ld    HL, 0x8100 
9037			;      ld    SP, HL 
9037			; 
9037			;      call  heap_init 
9037			; 
9037			;      ; Make some allocations 
9037			;      ld    HL, 12 
9037			;      call  malloc            ; Allocates 0x9004 
9037			; 
9037			;      ld    HL, 12 
9037			;      call  malloc            ; Allocates 0x9014 
9037			; 
9037			;      ld    HL, 12 
9037			;      call  malloc            ; Allocates 0x9024 
9037			; 
9037			;      ; Free some allocations 
9037			;      ld    HL, 0x9014 
9037			;      call  free 
9037			; 
9037			;      ld    HL, 0x9004 
9037			;      call  free 
9037			; 
9037			;      ld    HL, 0x9024 
9037			;      call  free 
9037			; 
9037			; 
9037			;      halt 
9037			 
9037			 
9037			;------------------------------------------------------------------------------ 
9037			;     heap_init                                                               : 
9037			;                                                                             : 
9037			; Description                                                                 : 
9037			;     Initialise the heap and make it ready for malloc and free operations.   : 
9037			;                                                                             : 
9037			;     The heap is maintained as a linked list, starting with an initial       : 
9037			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9037			;     the first free block in the heap. Each block then points to the next    : 
9037			;     free block within the heap, and the free list ends at the first block   : 
9037			;     with a null pointer to the next free block.                             : 
9037			;                                                                             : 
9037			; Parameters                                                                  : 
9037			;     Inputs are compile-time only. Two defines which specify the starting    : 
9037			;     address of the heap and its size are required, along with a memory      : 
9037			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9037			;     principally stores a pointer to the first free block in the heap.       : 
9037			;                                                                             : 
9037			; Returns                                                                     : 
9037			;     Nothing                                                                 : 
9037			;------------------------------------------------------------------------------ 
9037			heap_init: 
9037 e5			      push  HL 
9038			 
9038			      ; Initialise free list struct 
9038 21 24 d9		      ld    HL, heap_start 
903b 22 1f d9		      ld    (free_list), HL 
903e 21 00 00		      ld    HL, 0 
9041 22 21 d9		      ld    (free_list+2), HL 
9044			 
9044			      ; Insert first free block at bottom of heap, consumes entire heap 
9044 21 b9 e3		      ld    HL, heap_start+heap_size-4 
9047 22 24 d9		      ld    (heap_start), HL        ; Next block (end of free list) 
904a 21 95 0a		      ld    HL, heap_size-4 
904d 22 26 d9		      ld    (heap_start+2), HL      ; Block size 
9050			 
9050			      ; Insert end of free list block at top of heap - two null words will 
9050			      ; terminate the free list 
9050 21 00 00		      ld    HL, 0 
9053 22 bb e3		      ld    (heap_start+heap_size-2), HL 
9056 22 b9 e3		      ld    (heap_start+heap_size-4), HL 
9059			 
9059 e1			      pop   HL 
905a			 
905a c9			      ret 
905b			 
905b			 
905b			;------------------------------------------------------------------------------ 
905b			;     malloc                                                                  : 
905b			;                                                                             : 
905b			; Description                                                                 : 
905b			;     Allocates the wanted space from the heap and returns the address of the : 
905b			;     first useable byte of the allocation.                                   : 
905b			;                                                                             : 
905b			;     Allocations can happen in one of two ways:                              : 
905b			;                                                                             : 
905b			;     1. A free block may be found which is the exact size wanted. In this    : 
905b			;        case the block is removed from the free list and retuedn to the      : 
905b			;        caller.                                                              : 
905b			;     2. A free block may be found which is larger than the size wanted. In   : 
905b			;        this case, the larger block is split into two. The first portion of  : 
905b			;        this block will become the requested space by the malloc call and    : 
905b			;        is returned to the caller. The second portion becomes a new free     : 
905b			;        block, and the free list is adjusted to maintain continuity via this : 
905b			;        newly created block.                                                 : 
905b			;                                                                             : 
905b			;     malloc does not set any initial value in the allocated space, the       : 
905b			;     caller is required to do this as required.                              : 
905b			;                                                                             : 
905b			;     This implementation of malloc uses the stack exclusively, and is        : 
905b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
905b			;     advisable to disable interrupts before calling malloc, and recommended  : 
905b			;     to avoid the use of malloc inside ISRs in general.                      : 
905b			;                                                                             : 
905b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
905b			;                                                                             : 
905b			; Parameters                                                                  : 
905b			;     HL  Number of bytes wanted                                              : 
905b			;                                                                             : 
905b			; Returns                                                                     : 
905b			;     HL  Address of the first useable byte of the allocation                 : 
905b			;                                                                             : 
905b			; Flags                                                                       : 
905b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
905b			;                                                                             : 
905b			; Stack frame                                                                 : 
905b			;       |             |                                                       : 
905b			;       +-------------+                                                       : 
905b			;       |     BC      |                                                       : 
905b			;       +-------------+                                                       : 
905b			;       |     DE      |                                                       : 
905b			;       +-------------+                                                       : 
905b			;       |     IX      |                                                       : 
905b			;       +-------------+                                                       : 
905b			;       |  prev_free  |                                                       : 
905b			;   +4  +-------------+                                                       : 
905b			;       |  this_free  |                                                       : 
905b			;   +2  +-------------+                                                       : 
905b			;       |  next_free  |                                                       : 
905b			;   +0  +-------------+                                                       : 
905b			;       |             |                                                       : 
905b			;                                                                             : 
905b			;------------------------------------------------------------------------------ 
905b			 
905b			 
905b			;malloc: 
905b			; 
905b			;	SAVESP ON 1 
905b			; 
905b			;	call malloc_code 
905b			; 
905b			;	CHECKSP ON 1 
905b			;	ret 
905b			 
905b			 
905b			malloc: 
905b c5			      push  BC 
905c d5			      push  DE 
905d dd e5		      push  IX 
905f			if DEBUG_FORTH_MALLOC_HIGH 
905f			call malloc_guard_entry 
905f			endif 
905f			 
905f					if DEBUG_FORTH_MALLOC 
905f						DMARK "mal" 
905f						CALLMONITOR 
905f					endif 
905f 7c			      ld    A, H                    ; Exit if no space requested 
9060 b5			      or    L 
9061 ca 20 91		      jp    Z, malloc_early_exit 
9064			 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			; 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			;inc hl 
9064			 
9064			 
9064			 
9064			 
9064					if DEBUG_FORTH_MALLOC 
9064						DMARK "maA" 
9064						CALLMONITOR 
9064					endif 
9064			      ; Set up stack frame 
9064 eb			      ex    DE, HL 
9065 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9068 39			      add   HL, SP 
9069 f9			      ld    SP, HL 
906a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
906e dd 39		      add   IX, SP 
9070			 
9070			      ; Setup initial state 
9070 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9073 19			      add   HL, DE 
9074			 
9074 44			      ld    B, H                    ; Move want to BC 
9075 4d			      ld    C, L 
9076			 
9076 21 1f d9		      ld    HL, free_list           ; Store prev_free ptr to stack 
9079 dd 75 04		      ld    (IX+4), L 
907c dd 74 05		      ld    (IX+5), H 
907f			 
907f 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
9080 23			      inc   HL 
9081 56			      ld    D, (HL) 
9082 dd 73 02		      ld    (IX+2), E 
9085 dd 72 03		      ld    (IX+3), D 
9088 eb			      ex    DE, HL                  ; this_free ptr into HL 
9089			 
9089					if DEBUG_FORTH_MALLOC 
9089						DMARK "maB" 
9089						CALLMONITOR 
9089					endif 
9089			      ; Loop through free block list to find some space 
9089			malloc_find_space: 
9089 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
908a 23			      inc   HL 
908b 56			      ld    D, (HL) 
908c			 
908c 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
908d b3			      or    E 
908e ca 1a 91		      jp    Z, malloc_no_space 
9091			 
9091 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
9094 dd 72 01		      ld    (IX+1), D 
9097			 
9097			      ; Does this block have enough space to make the allocation? 
9097 23			      inc   HL                      ; Load free block size into DE 
9098 5e			      ld    E, (HL) 
9099 23			      inc   HL 
909a 56			      ld    D, (HL) 
909b			 
909b eb			      ex    DE, HL                  ; Check size of block against want 
909c b7			      or    A                       ; Ensure carry flag clear 
909d ed 42		      sbc   HL, BC 
909f e5			      push  HL                      ; Store the result for later (new block size) 
90a0			 
90a0 ca ef 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90a3 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90a5			 
90a5			      ; this_free block is not big enough, setup ptrs to test next free block 
90a5 e1			      pop   HL                      ; Discard previous result 
90a6			 
90a6 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90a9 dd 66 03		      ld    H, (IX+3) 
90ac dd 75 04		      ld    (IX+4), L 
90af dd 74 05		      ld    (IX+5), H 
90b2			 
90b2 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
90b5 dd 66 01		      ld    H, (IX+1) 
90b8 dd 75 02		      ld    (IX+2), L 
90bb dd 74 03		      ld    (IX+3), H 
90be			 
90be					if DEBUG_FORTH_MALLOC 
90be						DMARK "MA>" 
90be						CALLMONITOR 
90be					endif 
90be 18 c9		      jr    malloc_find_space 
90c0			 
90c0			      ; split a bigger block into two - requested size and remaining size 
90c0			malloc_alloc_split: 
90c0					if DEBUG_FORTH_MALLOC 
90c0						DMARK "MAs" 
90c0						CALLMONITOR 
90c0					endif 
90c0 eb			      ex    DE, HL                  ; Calculate address of new free block 
90c1 2b			      dec   HL 
90c2 2b			      dec   HL 
90c3 2b			      dec   HL 
90c4 09			      add   HL, BC 
90c5			 
90c5			      ; Create a new block and point it at next_free 
90c5 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
90c8 dd 56 01		      ld    D, (IX+1) 
90cb			 
90cb 73			      ld    (HL), E                 ; Store next_free ptr into new block 
90cc 23			      inc   HL 
90cd 72			      ld    (HL), D 
90ce			 
90ce d1			      pop   DE                      ; Store size of new block into new block 
90cf 23			      inc   HL 
90d0 73			      ld    (HL), E 
90d1 23			      inc   HL 
90d2 72			      ld    (HL), D 
90d3			 
90d3			      ; Update this_free ptr to point to new block 
90d3 2b			      dec   HL 
90d4 2b			      dec   HL 
90d5 2b			      dec   HL 
90d6			 
90d6 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
90d9 dd 56 03		      ld    D, (IX+3) 
90dc			 
90dc dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
90df dd 74 03		      ld    (IX+3), H 
90e2			 
90e2			      ; Modify this_free block to be allocation 
90e2 eb			      ex    DE, HL 
90e3 af			      xor   A                       ; Null the next block ptr of allocated block 
90e4 77			      ld    (HL), A 
90e5 23			      inc   HL 
90e6 77			      ld    (HL), A 
90e7			 
90e7 23			      inc   HL                      ; Store want size into allocated block 
90e8 71			      ld    (HL), C 
90e9 23			      inc   HL 
90ea 70			      ld    (HL), B 
90eb 23			      inc   HL 
90ec e5			      push  HL                      ; Address of allocation to return 
90ed			 
90ed 18 19		      jr    malloc_update_links 
90ef			 
90ef			malloc_alloc_fit: 
90ef e1			      pop   HL                      ; Dont need new block size, want is exact fit 
90f0			 
90f0					if DEBUG_FORTH_MALLOC 
90f0						DMARK "MAf" 
90f0						CALLMONITOR 
90f0					endif 
90f0			      ; Modify this_free block to be allocation 
90f0 eb			      ex    DE, HL 
90f1 2b			      dec   HL 
90f2 2b			      dec   HL 
90f3 2b			      dec   HL 
90f4			 
90f4 af			      xor   A                       ; Null the next block ptr of allocated block 
90f5 77			      ld    (HL), A 
90f6 23			      inc   HL 
90f7 77			      ld    (HL), A 
90f8			 
90f8 23			      inc   HL                      ; Store address of allocation to return 
90f9 23			      inc   HL 
90fa 23			      inc   HL 
90fb e5			      push  HL 
90fc			 
90fc			      ; Copy next_free ptr to this_free, remove allocated block from free list 
90fc dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
90ff dd 66 01		      ld    H, (IX+1) 
9102			 
9102 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9105 dd 74 03		      ld    (IX+3), H 
9108			 
9108			 
9108			malloc_update_links: 
9108			      ; Update prev_free ptr to point to this_free 
9108 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
910b dd 66 05		      ld    H, (IX+5) 
910e			 
910e dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9111 dd 56 03		      ld    D, (IX+3) 
9114			 
9114 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9115 23			      inc   HL 
9116 72			      ld    (HL), D 
9117			 
9117					if DEBUG_FORTH_MALLOC 
9117						DMARK "Mul" 
9117						CALLMONITOR 
9117					endif 
9117			      ; Clear the Z flag to indicate successful allocation 
9117 7a			      ld    A, D 
9118 b3			      or    E 
9119			 
9119 d1			      pop   DE                      ; Address of allocation 
911a					if DEBUG_FORTH_MALLOC 
911a						DMARK "MAu" 
911a						CALLMONITOR 
911a					endif 
911a			 
911a			malloc_no_space: 
911a 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
911d 39			      add   HL, SP 
911e f9			      ld    SP, HL 
911f			 
911f eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9120					if DEBUG_FORTH_MALLOC 
9120						DMARK "MAN" 
9120						CALLMONITOR 
9120					endif 
9120			 
9120			malloc_early_exit: 
9120					if DEBUG_FORTH_MALLOC 
9120						DMARK "MAx" 
9120						CALLMONITOR 
9120					endif 
9120 dd e1		      pop   IX 
9122 d1			      pop   DE 
9123 c1			      pop   BC 
9124			 
9124			if DEBUG_FORTH_MALLOC_HIGH 
9124			call malloc_guard_exit 
9124			call malloc_guard_zerolen 
9124			endif 
9124 c9			      ret 
9125			 
9125			 
9125			;------------------------------------------------------------------------------ 
9125			;     free                                                                    : 
9125			;                                                                             : 
9125			; Description                                                                 : 
9125			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9125			;     returned by malloc, otherwise the behaviour is undefined.               : 
9125			;                                                                             : 
9125			;     Where possible, directly adjacent free blocks will be merged together   : 
9125			;     into larger blocks to help ensure that the heap does not become         : 
9125			;     excessively fragmented.                                                 : 
9125			;                                                                             : 
9125			;     free does not clear or set any other value into the freed space, and    : 
9125			;     therefore its contents may be visible through subsequent malloc's. The  : 
9125			;     caller should clear the freed space as required.                        : 
9125			;                                                                             : 
9125			;     This implementation of free uses the stack exclusively, and is          : 
9125			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9125			;     advisable to disable interrupts before calling free, and recommended    : 
9125			;     to avoid the use of free inside ISRs in general.                        : 
9125			;                                                                             : 
9125			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9125			;                                                                             : 
9125			; Parameters                                                                  : 
9125			;     HL  Pointer to address of first byte of allocation to be freed          : 
9125			;                                                                             : 
9125			; Returns                                                                     : 
9125			;     Nothing                                                                 : 
9125			;                                                                             : 
9125			; Stack frame                                                                 : 
9125			;       |             |                                                       : 
9125			;       +-------------+                                                       : 
9125			;       |     BC      |                                                       : 
9125			;       +-------------+                                                       : 
9125			;       |     DE      |                                                       : 
9125			;       +-------------+                                                       : 
9125			;       |     IX      |                                                       : 
9125			;       +-------------+                                                       : 
9125			;       |  prev_free  |                                                       : 
9125			;   +2  +-------------+                                                       : 
9125			;       |  next_free  |                                                       : 
9125			;   +0  +-------------+                                                       : 
9125			;       |             |                                                       : 
9125			;                                                                             : 
9125			;------------------------------------------------------------------------------ 
9125			free: 
9125 c5			      push  BC 
9126 d5			      push  DE 
9127 dd e5		      push  IX 
9129			 
9129 7c			      ld    A, H                    ; Exit if ptr is null 
912a b5			      or    L 
912b ca ef 91		      jp    Z, free_early_exit 
912e			 
912e			      ; Set up stack frame 
912e eb			      ex    DE, HL 
912f 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9132 39			      add   HL, SP 
9133 f9			      ld    SP, HL 
9134 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9138 dd 39		      add   IX, SP 
913a			 
913a			      ; The address in HL points to the start of the useable allocated space, 
913a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
913a			      ; address of the block itself. 
913a eb			      ex    DE, HL 
913b 11 fc ff		      ld    DE, -4 
913e 19			      add   HL, DE 
913f			 
913f			      ; An allocated block must have a null next block pointer in it 
913f 7e			      ld    A, (HL) 
9140 23			      inc   HL 
9141 b6			      or    (HL) 
9142 c2 ea 91		      jp    NZ, free_done 
9145			 
9145 2b			      dec   HL 
9146			 
9146 44			      ld    B, H                    ; Copy HL to BC 
9147 4d			      ld    C, L 
9148			 
9148			      ; Loop through the free list to find the first block with an address 
9148			      ; higher than the block being freed 
9148 21 1f d9		      ld    HL, free_list 
914b			 
914b			free_find_higher_block: 
914b 5e			      ld    E, (HL)                 ; Load next ptr from free block 
914c 23			      inc   HL 
914d 56			      ld    D, (HL) 
914e 2b			      dec   HL 
914f			 
914f dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9152 dd 72 01		      ld    (IX+1), D 
9155 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9158 dd 74 03		      ld    (IX+3), H 
915b			 
915b 78			      ld    A, B                    ; Check if DE is greater than BC 
915c ba			      cp    D                       ; Compare MSB first 
915d 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
915f 30 04		      jr    NC, free_find_higher_block_skip 
9161 79			      ld    A, C 
9162 bb			      cp    E                       ; Then compare LSB 
9163 38 08		      jr    C, free_found_higher_block 
9165			 
9165			free_find_higher_block_skip: 
9165 7a			      ld    A, D                    ; Reached the end of the free list? 
9166 b3			      or    E 
9167 ca ea 91		      jp    Z, free_done 
916a			 
916a eb			      ex    DE, HL 
916b			 
916b 18 de		      jr    free_find_higher_block 
916d			 
916d			free_found_higher_block: 
916d			      ; Insert freed block between prev and next free blocks 
916d 71			      ld    (HL), C                 ; Point prev free block to freed block 
916e 23			      inc   HL 
916f 70			      ld    (HL), B 
9170			 
9170 60			      ld    H, B                    ; Point freed block at next free block 
9171 69			      ld    L, C 
9172 73			      ld    (HL), E 
9173 23			      inc   HL 
9174 72			      ld    (HL), D 
9175			 
9175			      ; Check if the freed block is adjacent to the next free block 
9175 23			      inc   HL                      ; Load size of freed block into HL 
9176 5e			      ld    E, (HL) 
9177 23			      inc   HL 
9178 56			      ld    D, (HL) 
9179 eb			      ex    DE, HL 
917a			 
917a 09			      add   HL, BC                  ; Add addr of freed block and its size 
917b			 
917b dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
917e dd 56 01		      ld    D, (IX+1) 
9181			 
9181 b7			      or    A                       ; Clear the carry flag 
9182 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9184 20 22		      jr    NZ, free_check_adjacent_to_prev 
9186			 
9186			      ; Freed block is adjacent to next, merge into one bigger block 
9186 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9187 5e			      ld    E, (HL) 
9188 23			      inc   HL 
9189 56			      ld    D, (HL) 
918a e5			      push  HL                      ; Save ptr to next block for later 
918b			 
918b 60			      ld    H, B                    ; Store ptr from next block into freed block 
918c 69			      ld    L, C 
918d 73			      ld    (HL), E 
918e 23			      inc   HL 
918f 72			      ld    (HL), D 
9190			 
9190 e1			      pop   HL                      ; Restore ptr to next block 
9191 23			      inc   HL                      ; Load size of next block into DE 
9192 5e			      ld    E, (HL) 
9193 23			      inc   HL 
9194 56			      ld    D, (HL) 
9195 d5			      push  DE                      ; Save next block size for later 
9196			 
9196 60			      ld    H, B                    ; Load size of freed block into HL 
9197 69			      ld    L, C 
9198 23			      inc   HL 
9199 23			      inc   HL 
919a 5e			      ld    E, (HL) 
919b 23			      inc   HL 
919c 56			      ld    D, (HL) 
919d eb			      ex    DE, HL 
919e			 
919e d1			      pop   DE                      ; Restore size of next block 
919f 19			      add   HL, DE                  ; Add sizes of both blocks 
91a0 eb			      ex    DE, HL 
91a1			 
91a1 60			      ld    H, B                    ; Store new bigger size into freed block 
91a2 69			      ld    L, C 
91a3 23			      inc   HL 
91a4 23			      inc   HL 
91a5 73			      ld    (HL), E 
91a6 23			      inc   HL 
91a7 72			      ld    (HL), D 
91a8			 
91a8			free_check_adjacent_to_prev: 
91a8			      ; Check if the freed block is adjacent to the prev free block 
91a8 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
91ab dd 66 03		      ld    H, (IX+3) 
91ae			 
91ae 23			      inc   HL                      ; Size of prev free block into DE 
91af 23			      inc   HL 
91b0 5e			      ld    E, (HL) 
91b1 23			      inc   HL 
91b2 56			      ld    D, (HL) 
91b3 2b			      dec   HL 
91b4 2b			      dec   HL 
91b5 2b			      dec   HL 
91b6			 
91b6 19			      add   HL, DE                  ; Add prev block addr and size 
91b7			 
91b7 b7			      or    A                       ; Clear the carry flag 
91b8 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
91ba 20 2e		      jr    NZ, free_done 
91bc			 
91bc			      ; Freed block is adjacent to prev, merge into one bigger block 
91bc 60			      ld    H, B                    ; Load next ptr from freed block into DE 
91bd 69			      ld    L, C 
91be 5e			      ld    E, (HL) 
91bf 23			      inc   HL 
91c0 56			      ld    D, (HL) 
91c1 e5			      push  HL                      ; Save freed block ptr for later 
91c2			 
91c2 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
91c5 dd 66 03		      ld    H, (IX+3) 
91c8 73			      ld    (HL), E 
91c9 23			      inc   HL 
91ca 72			      ld    (HL), D 
91cb			 
91cb e1			      pop   HL                      ; Restore freed block ptr 
91cc 23			      inc   HL                      ; Load size of freed block into DE 
91cd 5e			      ld    E, (HL) 
91ce 23			      inc   HL 
91cf 56			      ld    D, (HL) 
91d0 d5			      push  DE                      ; Save freed block size for later 
91d1			 
91d1 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
91d4 dd 66 03		      ld    H, (IX+3) 
91d7 23			      inc   HL 
91d8 23			      inc   HL 
91d9 5e			      ld    E, (HL) 
91da 23			      inc   HL 
91db 56			      ld    D, (HL) 
91dc			 
91dc e1			      pop   HL                      ; Add sizes of both blocks 
91dd 19			      add   HL, DE 
91de eb			      ex    DE, HL 
91df			 
91df dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
91e2 dd 66 03		      ld    H, (IX+3) 
91e5 23			      inc   HL 
91e6 23			      inc   HL 
91e7 73			      ld    (HL), E 
91e8 23			      inc   HL 
91e9 72			      ld    (HL), D 
91ea			 
91ea			free_done: 
91ea 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
91ed 39			      add   HL, SP 
91ee f9			      ld    SP, HL 
91ef			 
91ef			free_early_exit: 
91ef dd e1		      pop   IX 
91f1 d1			      pop   DE 
91f2 c1			      pop   BC 
91f3			 
91f3 c9			      ret 
91f4			 
91f4			; moved to firmware.asm 
91f4			; 
91f4			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
91f4			;                  .dw   0 
91f4			 
91f4			 
91f4			endif 
91f4			 
91f4			 
91f4			if MALLOC_3 
91f4			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
91f4			;heap_start        .equ  0x9000      ; Starting address of heap 
91f4			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
91f4			; 
91f4			 ;     .org 0 
91f4			  ;    jp    main 
91f4			; 
91f4			; 
91f4			 ;     .org  0x100 
91f4			;main: 
91f4			 ;     ld    HL, 0x8100 
91f4			  ;    ld    SP, HL 
91f4			; 
91f4			;      call  heap_init 
91f4			 
91f4			      ; Make some allocations 
91f4			;      ld    HL, 12 
91f4			;      call  malloc            ; Allocates 0x9004 
91f4			; 
91f4			 ;     ld    HL, 12 
91f4			;      call  malloc            ; Allocates 0x9014 
91f4			 
91f4			;      ld    HL, 12 
91f4			;      call  malloc            ; Allocates 0x9024 
91f4			 
91f4			      ; Free some allocations 
91f4			;      ld    HL, 0x9014 
91f4			;      call  free 
91f4			 
91f4			;      ld    HL, 0x9004 
91f4			;      call  free 
91f4			; 
91f4			;      ld    HL, 0x9024 
91f4			;      call  free 
91f4			 
91f4			 
91f4			 ;     halt 
91f4			 
91f4			 
91f4			;------------------------------------------------------------------------------ 
91f4			;     heap_init                                                               : 
91f4			;                                                                             : 
91f4			; Description                                                                 : 
91f4			;     Initialise the heap and make it ready for malloc and free operations.   : 
91f4			;                                                                             : 
91f4			;     The heap is maintained as a linked list, starting with an initial       : 
91f4			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
91f4			;     the first free block in the heap. Each block then points to the next    : 
91f4			;     free block within the heap, and the free list ends at the first block   : 
91f4			;     with a null pointer to the next free block.                             : 
91f4			;                                                                             : 
91f4			; Parameters                                                                  : 
91f4			;     Inputs are compile-time only. Two defines which specify the starting    : 
91f4			;     address of the heap and its size are required, along with a memory      : 
91f4			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
91f4			;     principally stores a pointer to the first free block in the heap.       : 
91f4			;                                                                             : 
91f4			; Returns                                                                     : 
91f4			;     Nothing                                                                 : 
91f4			;------------------------------------------------------------------------------ 
91f4			heap_init: 
91f4			      push  HL 
91f4			 
91f4			      ; Initialise free list struct 
91f4			      ld    HL, heap_start 
91f4			      ld    (free_list), HL 
91f4			      ld    HL, 0 
91f4			      ld    (free_list+2), HL 
91f4			 
91f4			      ; Insert first free block at bottom of heap, consumes entire heap 
91f4			      ld    HL, heap_start+heap_size-4 
91f4			      ld    (heap_start), HL        ; Next block (end of free list) 
91f4			      ld    HL, heap_size-4 
91f4			      ld    (heap_start+2), HL      ; Block size 
91f4			 
91f4			      ; Insert end of free list block at top of heap - two null words will 
91f4			      ; terminate the free list 
91f4			      ld    HL, 0 
91f4			      ld    (heap_start+heap_size-2), HL 
91f4			      ld    (heap_start+heap_size-4), HL 
91f4			 
91f4			      pop   HL 
91f4			 
91f4			      ret 
91f4			 
91f4			 
91f4			;------------------------------------------------------------------------------ 
91f4			;     malloc                                                                  : 
91f4			;                                                                             : 
91f4			; Description                                                                 : 
91f4			;     Allocates the wanted space from the heap and returns the address of the : 
91f4			;     first useable byte of the allocation.                                   : 
91f4			;                                                                             : 
91f4			;     Allocations can happen in one of two ways:                              : 
91f4			;                                                                             : 
91f4			;     1. A free block may be found which is the exact size wanted. In this    : 
91f4			;        case the block is removed from the free list and retuedn to the      : 
91f4			;        caller.                                                              : 
91f4			;     2. A free block may be found which is larger than the size wanted. In   : 
91f4			;        this case, the larger block is split into two. The first portion of  : 
91f4			;        this block will become the requested space by the malloc call and    : 
91f4			;        is returned to the caller. The second portion becomes a new free     : 
91f4			;        block, and the free list is adjusted to maintain continuity via this : 
91f4			;        newly created block.                                                 : 
91f4			;                                                                             : 
91f4			;     malloc does not set any initial value in the allocated space, the       : 
91f4			;     caller is required to do this as required.                              : 
91f4			;                                                                             : 
91f4			;     This implementation of malloc uses the stack exclusively, and is        : 
91f4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91f4			;     advisable to disable interrupts before calling malloc, and recommended  : 
91f4			;     to avoid the use of malloc inside ISRs in general.                      : 
91f4			;                                                                             : 
91f4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91f4			;                                                                             : 
91f4			; Parameters                                                                  : 
91f4			;     HL  Number of bytes wanted                                              : 
91f4			;                                                                             : 
91f4			; Returns                                                                     : 
91f4			;     HL  Address of the first useable byte of the allocation                 : 
91f4			;                                                                             : 
91f4			; Flags                                                                       : 
91f4			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91f4			;                                                                             : 
91f4			; Stack frame                                                                 : 
91f4			;       |             |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     BC      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     DE      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     IX      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |  prev_free  |                                                       : 
91f4			;   +4  +-------------+                                                       : 
91f4			;       |  this_free  |                                                       : 
91f4			;   +2  +-------------+                                                       : 
91f4			;       |  next_free  |                                                       : 
91f4			;   +0  +-------------+                                                       : 
91f4			;       |             |                                                       : 
91f4			;                                                                             : 
91f4			;------------------------------------------------------------------------------ 
91f4			malloc: 
91f4			      push  BC 
91f4			      push  DE 
91f4			      push  IX 
91f4			 
91f4			      ld    A, H                    ; Exit if no space requested 
91f4			      or    L 
91f4			      jp    Z, malloc_early_exit 
91f4			 
91f4			      ; Set up stack frame 
91f4			      ex    DE, HL 
91f4			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91f4			      add   HL, SP 
91f4			      ld    SP, HL 
91f4			      ld    IX, 0                   ; Use IX as a frame pointer 
91f4			      add   IX, SP 
91f4			 
91f4			      ; Setup initial state 
91f4			      ld    HL, 4                   ; want must also include space used by block struct 
91f4			      add   HL, DE 
91f4			 
91f4			      ld    B, H                    ; Move want to BC 
91f4			      ld    C, L 
91f4			 
91f4			      ld    HL, free_list           ; Store prev_free ptr to stack 
91f4			      ld    (IX+4), L 
91f4			      ld    (IX+5), H 
91f4			 
91f4			      ld    E, (HL)                 ; Store this_free ptr to stack 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      ld    (IX+2), E 
91f4			      ld    (IX+3), D 
91f4			      ex    DE, HL                  ; this_free ptr into HL 
91f4			 
91f4			      ; Loop through free block list to find some space 
91f4			malloc_find_space: 
91f4			      ld    E, (HL)                 ; Load next_free ptr into DE 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			 
91f4			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91f4			      or    E 
91f4			      jp    Z, malloc_no_space 
91f4			 
91f4			      ld    (IX+0), E               ; Store next_free ptr to stack 
91f4			      ld    (IX+1), D 
91f4			 
91f4			      ; Does this block have enough space to make the allocation? 
91f4			      inc   HL                      ; Load free block size into DE 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			 
91f4			      ex    DE, HL                  ; Check size of block against want 
91f4			      or    A                       ; Ensure carry flag clear 
91f4			      sbc   HL, BC 
91f4			      push  HL                      ; Store the result for later (new block size) 
91f4			 
91f4			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91f4			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91f4			 
91f4			      ; this_free block is not big enough, setup ptrs to test next free block 
91f4			      pop   HL                      ; Discard previous result 
91f4			 
91f4			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f4			      ld    H, (IX+3) 
91f4			      ld    (IX+4), L 
91f4			      ld    (IX+5), H 
91f4			 
91f4			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91f4			      ld    H, (IX+1) 
91f4			      ld    (IX+2), L 
91f4			      ld    (IX+3), H 
91f4			 
91f4			      jr    malloc_find_space 
91f4			 
91f4			      ; split a bigger block into two - requested size and remaining size 
91f4			malloc_alloc_split: 
91f4			      ex    DE, HL                  ; Calculate address of new free block 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			      add   HL, BC 
91f4			 
91f4			      ; Create a new block and point it at next_free 
91f4			      ld    E, (IX+0)               ; Load next_free ptr into DE 
91f4			      ld    D, (IX+1) 
91f4			 
91f4			      ld    (HL), E                 ; Store next_free ptr into new block 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      pop   DE                      ; Store size of new block into new block 
91f4			      inc   HL 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      ; Update this_free ptr to point to new block 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			 
91f4			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91f4			      ld    D, (IX+3) 
91f4			 
91f4			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91f4			      ld    (IX+3), H 
91f4			 
91f4			      ; Modify this_free block to be allocation 
91f4			      ex    DE, HL 
91f4			      xor   A                       ; Null the next block ptr of allocated block 
91f4			      ld    (HL), A 
91f4			      inc   HL 
91f4			      ld    (HL), A 
91f4			 
91f4			      inc   HL                      ; Store want size into allocated block 
91f4			      ld    (HL), C 
91f4			      inc   HL 
91f4			      ld    (HL), B 
91f4			      inc   HL 
91f4			      push  HL                      ; Address of allocation to return 
91f4			 
91f4			      jr    malloc_update_links 
91f4			 
91f4			malloc_alloc_fit: 
91f4			      pop   HL                      ; Dont need new block size, want is exact fit 
91f4			 
91f4			      ; Modify this_free block to be allocation 
91f4			      ex    DE, HL 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			 
91f4			      xor   A                       ; Null the next block ptr of allocated block 
91f4			      ld    (HL), A 
91f4			      inc   HL 
91f4			      ld    (HL), A 
91f4			 
91f4			      inc   HL                      ; Store address of allocation to return 
91f4			      inc   HL 
91f4			      inc   HL 
91f4			      push  HL 
91f4			 
91f4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
91f4			      ld    L, (IX+0)               ; next_free to HL 
91f4			      ld    H, (IX+1) 
91f4			 
91f4			      ld    (IX+2), L               ; HL to this_free 
91f4			      ld    (IX+3), H 
91f4			 
91f4			 
91f4			malloc_update_links: 
91f4			      ; Update prev_free ptr to point to this_free 
91f4			      ld    L, (IX+4)               ; prev_free ptr to HL 
91f4			      ld    H, (IX+5) 
91f4			 
91f4			      ld    E, (IX+2)               ; this_free ptr to DE 
91f4			      ld    D, (IX+3) 
91f4			 
91f4			      ld    (HL), E                 ; this_free ptr into prev_free 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      ; Clear the Z flag to indicate successful allocation 
91f4			      ld    A, D 
91f4			      or    E 
91f4			 
91f4			      pop   DE                      ; Address of allocation 
91f4			 
91f4			malloc_no_space: 
91f4			      ld    HL, 6                   ; Clean up stack frame 
91f4			      add   HL, SP 
91f4			      ld    SP, HL 
91f4			 
91f4			      ex    DE, HL                  ; Alloc addr into HL for return 
91f4			 
91f4			malloc_early_exit: 
91f4			      pop   IX 
91f4			      pop   DE 
91f4			      pop   BC 
91f4			 
91f4			      ret 
91f4			 
91f4			 
91f4			;------------------------------------------------------------------------------ 
91f4			;     free                                                                    : 
91f4			;                                                                             : 
91f4			; Description                                                                 : 
91f4			;     Return the space pointed to by HL to the heap. HL must be an address as : 
91f4			;     returned by malloc, otherwise the behaviour is undefined.               : 
91f4			;                                                                             : 
91f4			;     Where possible, directly adjacent free blocks will be merged together   : 
91f4			;     into larger blocks to help ensure that the heap does not become         : 
91f4			;     excessively fragmented.                                                 : 
91f4			;                                                                             : 
91f4			;     free does not clear or set any other value into the freed space, and    : 
91f4			;     therefore its contents may be visible through subsequent malloc's. The  : 
91f4			;     caller should clear the freed space as required.                        : 
91f4			;                                                                             : 
91f4			;     This implementation of free uses the stack exclusively, and is          : 
91f4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91f4			;     advisable to disable interrupts before calling free, and recommended    : 
91f4			;     to avoid the use of free inside ISRs in general.                        : 
91f4			;                                                                             : 
91f4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91f4			;                                                                             : 
91f4			; Parameters                                                                  : 
91f4			;     HL  Pointer to address of first byte of allocation to be freed          : 
91f4			;                                                                             : 
91f4			; Returns                                                                     : 
91f4			;     Nothing                                                                 : 
91f4			;                                                                             : 
91f4			; Stack frame                                                                 : 
91f4			;       |             |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     BC      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     DE      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |     IX      |                                                       : 
91f4			;       +-------------+                                                       : 
91f4			;       |  prev_free  |                                                       : 
91f4			;   +2  +-------------+                                                       : 
91f4			;       |  next_free  |                                                       : 
91f4			;   +0  +-------------+                                                       : 
91f4			;       |             |                                                       : 
91f4			;                                                                             : 
91f4			;------------------------------------------------------------------------------ 
91f4			free: 
91f4			      push  BC 
91f4			      push  DE 
91f4			      push  IX 
91f4			 
91f4			      ld    A, H                    ; Exit if ptr is null 
91f4			      or    L 
91f4			      jp    Z, free_early_exit 
91f4			 
91f4			      ; Set up stack frame 
91f4			      ex    DE, HL 
91f4			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
91f4			      add   HL, SP 
91f4			      ld    SP, HL 
91f4			      ld    IX, 0                   ; Use IX as a frame pointer 
91f4			      add   IX, SP 
91f4			 
91f4			      ; The address in HL points to the start of the useable allocated space, 
91f4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91f4			      ; address of the block itself. 
91f4			      ex    DE, HL 
91f4			      ld    DE, -4 
91f4			      add   HL, DE 
91f4			 
91f4			      ; An allocated block must have a null next block pointer in it 
91f4			      ld    A, (HL) 
91f4			      inc   HL 
91f4			      or    (HL) 
91f4			      jp    NZ, free_done 
91f4			 
91f4			      dec   HL 
91f4			 
91f4			      ld    B, H                    ; Copy HL to BC 
91f4			      ld    C, L 
91f4			 
91f4			      ; Loop through the free list to find the first block with an address 
91f4			      ; higher than the block being freed 
91f4			      ld    HL, free_list 
91f4			 
91f4			free_find_higher_block: 
91f4			      ld    E, (HL)                 ; Load next ptr from free block 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      dec   HL 
91f4			 
91f4			      ld    (IX+0), E               ; Save ptr to next free block 
91f4			      ld    (IX+1), D 
91f4			      ld    (IX+2), L               ; Save ptr to prev free block 
91f4			      ld    (IX+3), H 
91f4			 
91f4			      ld    A, B                    ; Check if DE is greater than BC 
91f4			      cp    D                       ; Compare MSB first 
91f4			      jr    Z, $+4                  ; MSB the same, compare LSB 
91f4			      jr    NC, free_find_higher_block_skip 
91f4			      ld    A, C 
91f4			      cp    E                       ; Then compare LSB 
91f4			      jr    C, free_found_higher_block 
91f4			 
91f4			free_find_higher_block_skip: 
91f4			      ld    A, D                    ; Reached the end of the free list? 
91f4			      or    E 
91f4			      jp    Z, free_done 
91f4			 
91f4			      ex    DE, HL 
91f4			 
91f4			      jr    free_find_higher_block 
91f4			 
91f4			free_found_higher_block: 
91f4			      ; Insert freed block between prev and next free blocks 
91f4			      ld    (HL), C                 ; Point prev free block to freed block 
91f4			      inc   HL 
91f4			      ld    (HL), B 
91f4			 
91f4			      ld    H, B                    ; Point freed block at next free block 
91f4			      ld    L, C 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      ; Check if the freed block is adjacent to the next free block 
91f4			      inc   HL                      ; Load size of freed block into HL 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      ex    DE, HL 
91f4			 
91f4			      add   HL, BC                  ; Add addr of freed block and its size 
91f4			 
91f4			      ld    E, (IX+0)               ; Load addr of next free block into DE 
91f4			      ld    D, (IX+1) 
91f4			 
91f4			      or    A                       ; Clear the carry flag 
91f4			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91f4			      jr    NZ, free_check_adjacent_to_prev 
91f4			 
91f4			      ; Freed block is adjacent to next, merge into one bigger block 
91f4			      ex    DE, HL                  ; Load next ptr from next block into DE 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      push  HL                      ; Save ptr to next block for later 
91f4			 
91f4			      ld    H, B                    ; Store ptr from next block into freed block 
91f4			      ld    L, C 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      pop   HL                      ; Restore ptr to next block 
91f4			      inc   HL                      ; Load size of next block into DE 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      push  DE                      ; Save next block size for later 
91f4			 
91f4			      ld    H, B                    ; Load size of freed block into HL 
91f4			      ld    L, C 
91f4			      inc   HL 
91f4			      inc   HL 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      ex    DE, HL 
91f4			 
91f4			      pop   DE                      ; Restore size of next block 
91f4			      add   HL, DE                  ; Add sizes of both blocks 
91f4			      ex    DE, HL 
91f4			 
91f4			      ld    H, B                    ; Store new bigger size into freed block 
91f4			      ld    L, C 
91f4			      inc   HL 
91f4			      inc   HL 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			free_check_adjacent_to_prev: 
91f4			      ; Check if the freed block is adjacent to the prev free block 
91f4			      ld    L, (IX+2)               ; Prev free block ptr into HL 
91f4			      ld    H, (IX+3) 
91f4			 
91f4			      inc   HL                      ; Size of prev free block into DE 
91f4			      inc   HL 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			      dec   HL 
91f4			 
91f4			      add   HL, DE                  ; Add prev block addr and size 
91f4			 
91f4			      or    A                       ; Clear the carry flag 
91f4			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
91f4			      jr    NZ, free_done 
91f4			 
91f4			      ; Freed block is adjacent to prev, merge into one bigger block 
91f4			      ld    H, B                    ; Load next ptr from freed block into DE 
91f4			      ld    L, C 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      push  HL                      ; Save freed block ptr for later 
91f4			 
91f4			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
91f4			      ld    H, (IX+3) 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			      pop   HL                      ; Restore freed block ptr 
91f4			      inc   HL                      ; Load size of freed block into DE 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			      push  DE                      ; Save freed block size for later 
91f4			 
91f4			      ld    L, (IX+2)               ; Load size of prev block into DE 
91f4			      ld    H, (IX+3) 
91f4			      inc   HL 
91f4			      inc   HL 
91f4			      ld    E, (HL) 
91f4			      inc   HL 
91f4			      ld    D, (HL) 
91f4			 
91f4			      pop   HL                      ; Add sizes of both blocks 
91f4			      add   HL, DE 
91f4			      ex    DE, HL 
91f4			 
91f4			      ld    L, (IX+2)               ; Store new bigger size into prev block 
91f4			      ld    H, (IX+3) 
91f4			      inc   HL 
91f4			      inc   HL 
91f4			      ld    (HL), E 
91f4			      inc   HL 
91f4			      ld    (HL), D 
91f4			 
91f4			free_done: 
91f4			      ld    HL, 4                   ; Clean up stack frame 
91f4			      add   HL, SP 
91f4			      ld    SP, HL 
91f4			 
91f4			free_early_exit: 
91f4			      pop   IX 
91f4			      pop   DE 
91f4			      pop   BC 
91f4			 
91f4			      ret 
91f4			 
91f4			 
91f4			;      .org 0x8000 
91f4			; 
91f4			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
91f4			 ;                 .dw   0 
91f4			 
91f4			endif 
91f4			 
91f4			 
91f4			if MALLOC_4 
91f4			 
91f4			; My memory allocation code. Very very simple.... 
91f4			; allocate space under 250 chars 
91f4			 
91f4			heap_init: 
91f4				; init start of heap as zero 
91f4				;  
91f4			 
91f4				ld hl, heap_start 
91f4				ld a, 0 
91f4				ld (hl), a      ; empty block 
91f4				inc hl 
91f4				ld a, 0 
91f4				ld (hl), a      ; length of block 
91f4				; write end of list 
91f4				inc hl 
91f4				ld a,(hl) 
91f4				inc hl 
91f4				ld a,(hl) 
91f4				 
91f4			 
91f4				; init some malloc vars 
91f4			 
91f4				ld hl, 0 
91f4				ld (free_list), hl       ; store last malloc location 
91f4			 
91f4				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
91f4				ld a, 0 
91f4				ld (hl), a 
91f4			 
91f4			 
91f4				ld hl, heap_start 
91f4				;  
91f4				  
91f4				ret 
91f4			 
91f4			 
91f4			;    free block marker 
91f4			;    requested size  
91f4			;    pointer to next block 
91f4			;    .... 
91f4			;    next block marker 
91f4			 
91f4			 
91f4			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
91f4			; 
91f4			 
91f4			 
91f4			malloc:  
91f4				push de 
91f4				push bc 
91f4				push af 
91f4			 
91f4				; hl space required 
91f4				 
91f4				ld c, l    ; hold space   (TODO only a max of 255) 
91f4			 
91f4			;	inc c     ; TODO BUG need to fix memory leak on push str 
91f4			;	inc c 
91f4			;	inc c 
91f4			;	inc c 
91f4			;	inc c 
91f4			;	inc c 
91f4			;	inc c 
91f4			 
91f4			 
91f4			 
91f4				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
91f4			 
91f4				ld a, (free_list+3) 
91f4				cp 0 
91f4				jr z, .contheap 
91f4			 
91f4				ld hl, (free_list)     ; get last alloc 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "mrs" 
91f4						CALLMONITOR 
91f4					endif 
91f4				jr .startalloc 
91f4			 
91f4			.contheap: 
91f4				ld hl, heap_start 
91f4			 
91f4			.startalloc: 
91f4			 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "mym" 
91f4						CALLMONITOR 
91f4					endif 
91f4			.findblock: 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "mmf" 
91f4						CALLMONITOR 
91f4					endif 
91f4			 
91f4				ld a,(hl)  
91f4				; if byte is zero then clear to use 
91f4			 
91f4				cp 0 
91f4				jr z, .foundemptyblock 
91f4			 
91f4				; if byte is not clear 
91f4				;     then byte is offset to next block 
91f4			 
91f4				inc hl 
91f4				ld a, (hl) ; get size 
91f4			.nextblock:	inc hl 
91f4					ld e, (hl) 
91f4					inc hl 
91f4					ld d, (hl) 
91f4					ex de, hl 
91f4			;	inc hl  ; move past the store space 
91f4			;	inc hl  ; move past zero index  
91f4			 
91f4				; TODO detect no more space 
91f4			 
91f4				push hl 
91f4				ld de, heap_end 
91f4				call cmp16 
91f4				pop hl 
91f4				jr nc, .nospace 
91f4			 
91f4				jr .findblock 
91f4			 
91f4			.nospace: ld hl, 0 
91f4				jp .exit 
91f4			 
91f4			 
91f4			.foundemptyblock:	 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "mme" 
91f4						CALLMONITOR 
91f4					endif 
91f4			 
91f4			; TODO has block enough space if reusing??? 
91f4			 
91f4				;  
91f4			 
91f4			; see if this block has been previously used 
91f4				inc hl 
91f4				ld a, (hl) 
91f4				dec hl 
91f4				cp 0 
91f4				jr z, .newblock 
91f4			 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "meR" 
91f4						CALLMONITOR 
91f4					endif 
91f4			 
91f4			; no reusing previously allocated block 
91f4			 
91f4			; is it smaller than previously used? 
91f4				 
91f4				inc hl    ; move to size 
91f4				ld a, c 
91f4				sub (hl)        ; we want c < (hl) 
91f4				dec hl    ; move back to marker 
91f4			        jr z, .findblock 
91f4			 
91f4				; update with the new size which should be lower 
91f4			 
91f4			        ;inc  hl   ; negate next move. move back to size  
91f4			 
91f4			.newblock: 
91f4				; need to be at marker here 
91f4			 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "meN" 
91f4						CALLMONITOR 
91f4					endif 
91f4			 
91f4			 
91f4				ld a, c 
91f4			 
91f4				ld (free_list+3), a	 ; flag resume from last malloc  
91f4				ld (free_list), hl    ; save out last location 
91f4			 
91f4			 
91f4				;inc a     ; space for length byte 
91f4				ld (hl), a     ; save block in use marker 
91f4			 
91f4				inc hl   ; move to space marker 
91f4				ld (hl), a    ; save new space 
91f4			 
91f4				inc hl   ; move to start of allocated area 
91f4				 
91f4			;	push hl     ; save where we are - 1  
91f4			 
91f4			;	inc hl  ; move past zero index  
91f4				; skip space to set down new marker 
91f4			 
91f4				; provide some extra space for now 
91f4			 
91f4				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
91f4				inc a 
91f4				inc a 
91f4			 
91f4				push hl   ; save where we are in the node block 
91f4			 
91f4				call addatohl 
91f4			 
91f4				; write linked list point 
91f4			 
91f4				pop de     ; get our node position 
91f4				ex de, hl 
91f4			 
91f4				ld (hl), e 
91f4				inc hl 
91f4				ld (hl), d 
91f4			 
91f4				inc hl 
91f4			 
91f4				; now at start of allocated data so save pointer 
91f4			 
91f4				push hl 
91f4			 
91f4				; jump to position of next node and setup empty header in DE 
91f4			 
91f4				ex de, hl 
91f4			 
91f4			;	inc hl ; move past end of block 
91f4			 
91f4				ld a, 0 
91f4				ld (hl), a   ; empty marker 
91f4				inc hl 
91f4				ld (hl), a   ; size 
91f4				inc hl  
91f4				ld (hl), a   ; ptr 
91f4				inc hl 
91f4				ld (hl), a   ; ptr 
91f4			 
91f4			 
91f4				pop hl 
91f4			 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "mmr" 
91f4						CALLMONITOR 
91f4					endif 
91f4			 
91f4			.exit: 
91f4				pop af 
91f4				pop bc 
91f4				pop de  
91f4				ret 
91f4			 
91f4			 
91f4			 
91f4			 
91f4			free:  
91f4				push hl 
91f4				push af 
91f4				; get address in hl 
91f4			 
91f4					if DEBUG_FORTH_MALLOC_INT 
91f4						DMARK "fre" 
91f4						CALLMONITOR 
91f4					endif 
91f4				; data is at hl - move to block count 
91f4				dec hl 
91f4				dec hl    ; get past pointer 
91f4				dec hl 
91f4			 
91f4				ld a, (hl)    ; need this for a validation check 
91f4			 
91f4				dec hl    ; move to block marker 
91f4			 
91f4				; now check that the block count and block marker are the same  
91f4			        ; this checks that we are on a malloc node and not random memory 
91f4			        ; OK a faint chance this could be a problem but rare - famous last words! 
91f4			 
91f4				ld c, a 
91f4				ld a, (hl)    
91f4			 
91f4				cp c 
91f4				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
91f4			 
91f4				; yes good chance we are on a malloc node 
91f4			 
91f4				ld a, 0      
91f4				ld (hl), a   ; mark as free 
91f4			 
91f4				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
91f4			 
91f4			.freeignore:  
91f4			 
91f4				pop af 
91f4				pop hl 
91f4			 
91f4				ret 
91f4			 
91f4			 
91f4			 
91f4			endif 
91f4			 
91f4			; eof 
# End of file firmware_memory.asm
91f4			  
91f4			; device C  
91f4			if SOUND_ENABLE  
91f4				include "firmware_sound.asm"  
91f4			endif  
91f4			  
91f4			include "firmware_diags.asm"  
91f4			; Hardware diags menu 
91f4			 
91f4			 
91f4			config: 
91f4			 
91f4 3e 00			ld a, 0 
91f6 21 24 92			ld hl, .configmn 
91f9 cd 98 89			call menu 
91fc			 
91fc fe 00			cp 0 
91fe c8				ret z 
91ff			 
91ff fe 01			cp 1 
9201 cc 52 92			call z, .savetostore 
9204			 
9204 fe 02			cp 2 
9206 cc 3e 92			call z, .selautoload 
9209 fe 03			cp 3 
920b cc 34 92			call z, .disautoload 
920e fe 04			cp 4 
9210 cc 48 92			call z, .selbank 
9213 fe 05			cp 5 
9215 cc 5c 92			call z, .debug_tog 
9218 fe 06			cp 6 
921a cc 9f 93			call z, .bpsgo 
921d fe 07			cp 7 
921f cc 82 92			call z, hardware_diags 
9222			 
9222 18 d0			jr config 
9224			 
9224			.configmn: 
9224 90 95			dw prom_c3 
9226 a7 95			dw prom_c2 
9228 bc 95			dw prom_c2a 
922a d2 95			dw prom_c2b 
922c			;	dw prom_c4 
922c ef 95			dw prom_m4 
922e 0a 96			dw prom_m4b 
9230 12 96			dw prom_c1 
9232 00 00			dw 0 
9234				 
9234			 
9234			 
9234			 
9234			.disautoload: 
9234				if STORAGE_SE 
9234				ld a, $fe      ; bit 0 clear 
9234				ld (spi_device), a 
9234			 
9234				call storage_get_block_0 
9234			 
9234				ld a, 0 
9234				ld (store_page+STORE_0_AUTOFILE), a 
9234			 
9234					ld hl, 0 
9234					ld de, store_page 
9234				call storage_write_block	 ; save update 
9234				else 
9234			 
9234 21 21 96			ld hl, prom_notav 
9237 11 37 96			ld de, prom_empty 
923a cd f8 88			call info_panel 
923d				endif 
923d			 
923d			 
923d c9				ret 
923e			 
923e			 
923e			 
923e			; Select auto start 
923e			 
923e			.selautoload: 
923e			 
923e				 
923e				if STORAGE_SE 
923e			 
923e					call config_dir 
923e				        ld hl, scratch 
923e					ld a, 0 
923e					call menu 
923e			 
923e					cp 0 
923e					ret z 
923e			 
923e					dec a 
923e			 
923e			 
923e					; locate menu option 
923e			 
923e					ld hl, scratch 
923e					call table_lookup 
923e			 
923e					if DEBUG_FORTH_WORDS 
923e						DMARK "ALl" 
923e						CALLMONITOR 
923e					endif 
923e					; with the pointer to the menu it, the byte following the zero term is the file id 
923e			 
923e					ld a, 0 
923e					ld bc, 50   ; max of bytes to look at 
923e					cpir  
923e			 
923e					if DEBUG_FORTH_WORDS 
923e						DMARK "ALb" 
923e						CALLMONITOR 
923e					endif 
923e					;inc hl 
923e			 
923e					ld a, (hl)   ; file id 
923e					 
923e				        ; save bank and file ids 
923e			 
923e					push af 
923e			 
923e			; TODO need to save to block 0 on bank 1	 
923e			 
923e					call storage_get_block_0 
923e			 
923e					if DEBUG_FORTH_WORDS 
923e						DMARK "AL0" 
923e						CALLMONITOR 
923e					endif 
923e					pop af 
923e			 
923e					ld (store_page+STORE_0_FILERUN),a 
923e					 
923e					; save bank id 
923e			 
923e					ld a,(spi_device) 
923e					ld (store_page+STORE_0_BANKRUN),a 
923e			 
923e					; enable auto run of store file 
923e			 
923e					ld a, 1 
923e					ld (store_page+STORE_0_AUTOFILE),a 
923e			 
923e					; save buffer 
923e			 
923e					ld hl, 0 
923e					ld de, store_page 
923e					if DEBUG_FORTH_WORDS 
923e						DMARK "ALw" 
923e						CALLMONITOR 
923e					endif 
923e				call storage_write_block	 ; save update 
923e			  
923e			 
923e			 
923e			 
923e					ld hl, scratch 
923e					call config_fdir 
923e			 
923e				else 
923e			 
923e 21 21 96			ld hl, prom_notav 
9241 11 37 96			ld de, prom_empty 
9244 cd f8 88			call info_panel 
9247			 
9247				endif 
9247 c9				ret 
9248			 
9248			 
9248			 
9248			; Select storage bank 
9248			 
9248			.selbank: 
9248			 
9248				if STORAGE_SE 
9248				else 
9248			 
9248 21 21 96			ld hl, prom_notav 
924b 11 37 96			ld de, prom_empty 
924e cd f8 88			call info_panel 
9251				endif 
9251				 
9251 c9				ret 
9252			 
9252			if STORAGE_SE 
9252			 
9252			.config_ldir:   
9252				; Load storage bank labels into menu array 
9252			 
9252				 
9252			 
9252			 
9252				ret 
9252			 
9252			 
9252			endif 
9252			 
9252			 
9252			; Save user words to storage 
9252			 
9252			.savetostore: 
9252			 
9252				if STORAGE_SE 
9252			 
9252					call config_dir 
9252				        ld hl, scratch 
9252					ld a, 0 
9252					call menu 
9252					 
9252					ld hl, scratch 
9252					call config_fdir 
9252			 
9252				else 
9252			 
9252 21 21 96			ld hl, prom_notav 
9255 11 37 96			ld de, prom_empty 
9258 cd f8 88			call info_panel 
925b			 
925b				endif 
925b			 
925b c9				ret 
925c			 
925c			 
925c			 
925c			if STORAGE_SE 
925c			 
925c			config_fdir: 
925c				; using the scratch dir go through and release the memory allocated for each string 
925c				 
925c				ld hl, scratch 
925c			.cfdir:	ld e,(hl) 
925c				inc hl 
925c				ld d,(hl) 
925c				inc hl 
925c			 
925c				ex de, hl 
925c				call ishlzero 
925c				ret z     ; return on null pointer 
925c				call free 
925c				ex de, hl 
925c				jr .cfdir 
925c			 
925c			 
925c				ret 
925c			 
925c			 
925c			config_dir: 
925c			 
925c				; for the config menus that need to build a directory of storage call this routine 
925c				; it will construct a menu in scratch to pass to menu 
925c			 
925c				; open storage device 
925c			 
925c				; execute DIR to build a list of files and their ids into scratch in menu format 
925c				; once the menu has finished then will need to call config_fdir to release the strings 
925c				 
925c				; c = number items 
925c			 
925c				 
925c				call storage_get_block_0 
925c			 
925c				ld hl, store_page     ; get current id count 
925c				ld b, (hl) 
925c				ld c, 0    ; count of files   
925c			 
925c			 
925c				ld hl, scratch 
925c				ld (store_tmp2), hl    ; location to poke strings 
925c			 
925c				; check for empty drive 
925c			 
925c				ld a, 0 
925c				cp b 
925c				jp z, .dirdone 
925c			 
925c				 
925c					if DEBUG_FORTH_WORDS 
925c						DMARK "Cdc" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c			 
925c			.diritem:	 
925c				push bc 
925c				; for each of the current ids do a search for them and if found push to stack 
925c			 
925c					ld hl, STORE_BLOCK_PHY 
925c					ld d, 0		 ; look for extent 0 of block id as this contains file name 
925c					ld e,b 
925c			 
925c					call storage_findnextid 
925c			 
925c			 
925c					; if found hl will be non zero 
925c			 
925c					call ishlzero 
925c					jr z, .dirnotfound 
925c			 
925c					; increase count 
925c			 
925c					pop bc	 
925c					inc c 
925c					push bc 
925c					 
925c			 
925c					; get file header and push the file name 
925c			 
925c					ld de, store_page 
925c					call storage_read_block 
925c			 
925c					; push file id to stack 
925c				 
925c					ld a, (store_page) 
925c					ld h, 0 
925c					ld l, a 
925c			 
925c					;call forth_push_numhl 
925c					; TODO store id 
925c			 
925c					push hl 
925c			 
925c					; push extent count to stack  
925c				 
925c					ld hl, store_page+3 
925c			 
925c					; get file name length 
925c			 
925c					call strlenz   
925c			 
925c					inc hl   ; cover zero term 
925c					inc hl  ; stick the id at the end of the area 
925c			 
925c					push hl 
925c					pop bc    ; move length to bc 
925c			 
925c					call malloc 
925c			 
925c					; TODO save malloc area to scratch 
925c			 
925c					ex de, hl 
925c					ld hl, (store_tmp2) 
925c					ld (hl), e 
925c					inc hl 
925c					ld (hl), d 
925c					inc hl 
925c					ld (store_tmp2), hl 
925c			 
925c					 
925c			 
925c					;pop hl   ; get source 
925c			;		ex de, hl    ; swap aronund	 
925c			 
925c					ld hl, store_page+3 
925c					if DEBUG_FORTH_WORDS 
925c						DMARK "CFd" 
925c						CALLMONITOR 
925c					endif 
925c					ldir 
925c			 
925c					; de is past string, move back one and store id 
925c					 
925c					dec de 
925c			 
925c					; store file id 
925c			 
925c					pop hl 
925c					ex de,hl 
925c					ld (hl), e 
925c			 
925c					if DEBUG_FORTH_WORDS 
925c						DMARK "Cdi" 
925c						CALLMONITOR 
925c					endif 
925c					 
925c			.dirnotfound: 
925c					pop bc     
925c					djnz .diritem 
925c				 
925c			.dirdone:	 
925c			 
925c					ld a, 0 
925c					ld hl, (store_tmp2) 
925c					ld (hl), a 
925c					inc hl 
925c					ld (hl), a 
925c					inc hl 
925c					; push a count of the dir items found 
925c			 
925c			;		ld h, 0 
925c			;		ld l, c 
925c			 
925c				ret 
925c			 
925c			endif 
925c			 
925c			 
925c			; Settings 
925c			; Run  
925c			 
925c			 
925c			 
925c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
925c			;;hd_menu2:   db "        2: Editor",0   
925c			;hd_menu2:   db "        2: Editor       6: Menu",0   
925c			;hd_menu3:   db "        3: Storage",0 
925c			;hd_menu4:   db "0=quit  4: Debug",0 
925c			;hd_don:     db "ON",0 
925c			;hd_doff:     db "OFF",0 
925c			; 
925c			; 
925c			; 
925c			;hardware_diags_old:       
925c			; 
925c			;.diagmenu: 
925c			;	call clear_display 
925c			;	ld a, display_row_1 
925c			;	ld de, hd_menu1 
925c			;	call str_at_display 
925c			; 
925c			;	ld a, display_row_2 
925c			;	ld de, hd_menu2 
925c			;	call str_at_display 
925c			; 
925c			;	ld a, display_row_3 
925c			;	ld de, hd_menu3 
925c			;	call str_at_display 
925c			; 
925c			;	ld a,  display_row_4 
925c			;	ld de, hd_menu4 
925c			;	call str_at_display 
925c			; 
925c			;	; display debug state 
925c			; 
925c			;	ld de, hd_don 
925c			;	ld a, (os_view_disable) 
925c			;	cp 0 
925c			;	jr z, .distog 
925c			;	ld de, hd_doff 
925c			;.distog: ld a, display_row_4+17 
925c			;	call str_at_display 
925c			; 
925c			;	call update_display 
925c			; 
925c			;	call cin_wait 
925c			; 
925c			; 
925c			; 
925c			;	cp '4' 
925c			;	jr nz, .diagn1 
925c			; 
925c			;	; debug toggle 
925c			; 
925c			;	ld a, (os_view_disable) 
925c			;	ld b, '*' 
925c			;	cp 0 
925c			;	jr z, .debtog 
925c			;	ld b, 0 
925c			;.debtog:	 
925c			;	ld a,b 
925c			;	ld (os_view_disable),a 
925c			; 
925c			;.diagn1: cp '0' 
925c			;	 ret z 
925c			; 
925c			;;	cp '1' 
925c			;;       jp z, matrix	 
925c			;;   TODO keyboard matrix test 
925c			; 
925c			;	cp '2' 
925c			;	jp z, .diagedit 
925c			; 
925c			;;	cp '6' 
925c			;;	jp z, .menutest 
925c			;;if ENABLE_BASIC 
925c			;;	cp '6' 
925c			;;	jp z, basic 
925c			;;endif 
925c			 ; 
925c			;	jp .diagmenu 
925c			; 
925c			; 
925c			;	ret 
925c			 
925c			 
925c			.debug_tog: 
925c 21 a3 92			ld hl, .menudebug 
925f				 
925f 3a c8 e3			ld a, (os_view_disable) 
9262 fe 2a			cp '*' 
9264 20 04			jr nz,.tdon  
9266 3e 01			ld a, 1 
9268 18 02			jr .tog1 
926a 3e 00		.tdon: ld a, 0 
926c			 
926c			.tog1: 
926c cd 98 89			call menu 
926f fe 00			cp 0 
9271 c8				ret z 
9272 fe 01			cp 1    ; disable debug 
9274 28 04			jr z, .dtog0 
9276 3e 2a			ld a, '*' 
9278 18 02			jr .dtogset 
927a 3e 00		.dtog0: ld a, 0 
927c 32 c8 e3		.dtogset:  ld (os_view_disable), a 
927f c3 5c 92			jp .debug_tog 
9282			 
9282			 
9282			hardware_diags:       
9282			 
9282			.diagm: 
9282 21 95 92			ld hl, .menuitems 
9285 3e 00			ld a, 0 
9287 cd 98 89			call menu 
928a			 
928a fe 00		         cp 0 
928c c8				 ret z 
928d			 
928d fe 02			cp 2 
928f ca ee 92			jp z, .diagedit 
9292			 
9292			;	cp '6' 
9292			;	jp z, .menutest 
9292			;if ENABLE_BASIC 
9292			;	cp '6' 
9292			;	jp z, basic 
9292			;endif 
9292			  
9292 c3 82 92			jp .diagm 
9295			 
9295				 
9295 a9 92		.menuitems:   	dw .m1 
9297 b4 92				dw .m2 
9299 bb 92				dw .m3 
929b c3 92				dw .m5 
929d c9 92				dw .m5a 
929f d2 92				dw .m5b 
92a1 00 00				dw 0 
92a3			 
92a3			.menudebug: 
92a3 db 92				dw .m6 
92a5 e4 92				dw .m7 
92a7 00 00				dw 0 
92a9			 
92a9 .. 00		.m1:   db "Key Matrix",0 
92b4 .. 00		.m2:   db "Editor",0 
92bb .. 00		.m3:   db "Storage",0 
92c3 .. 00		.m5:   db "Sound",0 
92c9 .. 00		.m5a:  db "RAM Test",0 
92d2 .. 00		.m5b:  db "LCD Test",0 
92db			 
92db .. 00		.m6:   db "Debug ON",0 
92e4 .. 00		.m7:   db "Debug OFF",0 
92ee			 
92ee			; debug editor 
92ee			 
92ee			.diagedit: 
92ee			 
92ee 21 d7 e3			ld hl, scratch 
92f1			;	ld bc, 250 
92f1			;	ldir 
92f1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92f1 3e 00			ld a, 0 
92f3 77				ld (hl), a 
92f4 23				inc hl 
92f5 77				ld (hl), a 
92f6 23				inc hl 
92f7 77				ld (hl), a 
92f8			 
92f8 cd 67 89		        call clear_display 
92fb cd 8a 89			call update_display 
92fe				;ld a, 1 
92fe				;ld (hardware_diag), a 
92fe			.diloop: 
92fe 3e 00			ld a, display_row_1 
9300 0e 00			ld c, 0 
9302 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9304 1e 28			ld e, 40 
9306			 
9306 21 d7 e3			ld hl, scratch	 
9309 cd c1 8b			call input_str 
930c			 
930c 3e 28			ld a, display_row_2 
930e 11 d7 e3			ld de, scratch 
9311 cd 7a 89			call str_at_display 
9314 cd 8a 89			call update_display 
9317			 
9317 c3 fe 92			jp .diloop 
931a			 
931a			 
931a			; pass word in hl 
931a			; a has display location 
931a			display_word_at: 
931a f5				push af 
931b e5				push hl 
931c 7c				ld a,h 
931d 21 dc e6			ld hl, os_word_scratch 
9320 cd 95 8e			call hexout 
9323 e1				pop hl 
9324 7d				ld a,l 
9325 21 de e6			ld hl, os_word_scratch+2 
9328 cd 95 8e			call hexout 
932b 21 e0 e6			ld hl, os_word_scratch+4 
932e 3e 00			ld a,0 
9330 77				ld (hl),a 
9331 11 dc e6			ld de,os_word_scratch 
9334 f1				pop af 
9335 cd 7a 89				call str_at_display 
9338 c9				ret 
9339			 
9339			display_ptr_state: 
9339			 
9339				; to restore afterwards 
9339			 
9339 d5				push de 
933a c5				push bc 
933b e5				push hl 
933c f5				push af 
933d			 
933d				; for use in here 
933d			 
933d			;	push bc 
933d			;	push de 
933d			;	push hl 
933d			;	push af 
933d			 
933d cd 67 89			call clear_display 
9340			 
9340 11 13 95			ld de, .ptrstate 
9343 3e 00			ld a, display_row_1 
9345 cd 7a 89			call str_at_display 
9348			 
9348				; display debug step 
9348			 
9348			 
9348 11 71 ee			ld de, debug_mark 
934b 3e 26			ld a, display_row_1+display_cols-2 
934d cd 7a 89			call str_at_display 
9350			 
9350				; display a 
9350 11 1d 95			ld de, .ptrcliptr 
9353 3e 28			ld a, display_row_2 
9355 cd 7a 89			call str_at_display 
9358			 
9358 f1				pop af 
9359 2a 22 eb			ld hl,(cli_ptr) 
935c 3e 30			ld a, display_row_2+8 
935e cd 1a 93			call display_word_at 
9361			 
9361			 
9361				; display hl 
9361			 
9361			 
9361 11 25 95			ld de, .ptrclioptr 
9364 3e 32			ld a, display_row_2+10 
9366 cd 7a 89			call str_at_display 
9369			; 
9369			;	pop hl 
9369 3e 35			ld a, display_row_2+13 
936b 2a 20 eb			ld hl,(cli_origptr) 
936e cd 1a 93			call display_word_at 
9371			; 
9371			;	 
9371			;	; display de 
9371			 
9371			;	ld de, .regstatede 
9371			;	ld a, display_row_3 
9371			;	call str_at_display 
9371			 
9371			;	pop de 
9371			;	ld h,d 
9371			;	ld l, e 
9371			;	ld a, display_row_3+3 
9371			;	call display_word_at 
9371			 
9371			 
9371				; display bc 
9371			 
9371			;	ld de, .regstatebc 
9371			;	ld a, display_row_3+10 
9371			;	call str_at_display 
9371			 
9371			;	pop bc 
9371			;	ld h,b 
9371			;	ld l, c 
9371			;	ld a, display_row_3+13 
9371			;	call display_word_at 
9371			 
9371			 
9371				; display dsp 
9371			 
9371			;	ld de, .regstatedsp 
9371			;	ld a, display_row_4 
9371			;	call str_at_display 
9371			 
9371				 
9371			;	ld hl,(cli_data_sp) 
9371			;	ld a, display_row_4+4 
9371			;	call display_word_at 
9371			 
9371				; display rsp 
9371			 
9371 11 54 95			ld de, .regstatersp 
9374 3e 82			ld a, display_row_4+10 
9376 cd 7a 89			call str_at_display 
9379			 
9379				 
9379 2a 08 eb			ld hl,(cli_ret_sp) 
937c 3e 86			ld a, display_row_4+14 
937e cd 1a 93			call display_word_at 
9381			 
9381 cd 8a 89			call update_display 
9384			 
9384 cd e4 88			call delay1s 
9387 cd e4 88			call delay1s 
938a cd e4 88			call delay1s 
938d			 
938d			 
938d cd 78 99			call next_page_prompt 
9390			 
9390				; restore  
9390			 
9390 f1				pop af 
9391 e1				pop hl 
9392 c1				pop bc 
9393 d1				pop de 
9394 c9				ret 
9395			 
9395			break_point_state: 
9395 f5				push af 
9396			 
9396				; see if disabled 
9396			 
9396 3a c8 e3			ld a, (os_view_disable) 
9399 fe 2a			cp '*' 
939b 20 02			jr nz, .bpsgo 
939d f1				pop af 
939e c9				ret 
939f			 
939f			.bpsgo: 
939f f1				pop af 
93a0 f5				push af 
93a1 22 c4 e3			ld (os_view_hl), hl 
93a4 ed 53 c2 e3		ld (os_view_de), de 
93a8 ed 43 c0 e3		ld (os_view_bc), bc 
93ac e5				push hl 
93ad 6f				ld l, a 
93ae 26 00			ld h, 0 
93b0 22 c6 e3			ld (os_view_af),hl 
93b3			 
93b3 21 b7 ed				ld hl, display_fb0 
93b6 22 d2 eb				ld (display_fb_active), hl 
93b9 e1				pop hl	 
93ba			 
93ba 3e 31			ld a, '1' 
93bc fe 2a		.bps1:  cp '*' 
93be 20 03			jr nz, .bps1b 
93c0 32 c8 e3			ld (os_view_disable),a 
93c3 fe 31		.bps1b:  cp '1' 
93c5 20 14			jr nz, .bps2 
93c7			 
93c7				; display reg 
93c7			 
93c7				 
93c7			 
93c7 3a c6 e3			ld a, (os_view_af) 
93ca 2a c4 e3			ld hl, (os_view_hl) 
93cd ed 5b c2 e3		ld de, (os_view_de) 
93d1 ed 4b c0 e3		ld bc, (os_view_bc) 
93d5 cd 6f 94			call display_reg_state 
93d8 c3 5b 94			jp .bpschk 
93db			 
93db fe 32		.bps2:  cp '2' 
93dd 20 08			jr nz, .bps3 
93df				 
93df				; display hl 
93df 2a c4 e3			ld hl, (os_view_hl) 
93e2 cd 59 95			call display_dump_at_hl 
93e5			 
93e5 18 74			jr .bpschk 
93e7			 
93e7 fe 33		.bps3:  cp '3' 
93e9 20 08			jr nz, .bps4 
93eb			 
93eb			        ; display de 
93eb 2a c2 e3			ld hl, (os_view_de) 
93ee cd 59 95			call display_dump_at_hl 
93f1			 
93f1 18 68			jr .bpschk 
93f3 fe 34		.bps4:  cp '4' 
93f5 20 08			jr nz, .bps5 
93f7			 
93f7			        ; display bc 
93f7 2a c0 e3			ld hl, (os_view_bc) 
93fa cd 59 95			call display_dump_at_hl 
93fd			 
93fd 18 5c			jr .bpschk 
93ff fe 35		.bps5:  cp '5' 
9401 20 08		        jr nz, .bps7 
9403			 
9403				; display cur ptr 
9403 2a 22 eb			ld hl, (cli_ptr) 
9406 cd 59 95			call display_dump_at_hl 
9409			 
9409 18 50			jr .bpschk 
940b fe 36		.bps7:  cp '6' 
940d 20 08			jr nz, .bps8b 
940f				 
940f				; display cur orig ptr 
940f 2a 20 eb			ld hl, (cli_origptr) 
9412 cd 59 95			call display_dump_at_hl 
9415 18 44			jr .bpschk 
9417 fe 37		.bps8b:  cp '7' 
9419 20 08			jr nz, .bps9 
941b				 
941b				; display dsp 
941b 2a 04 eb			ld hl, (cli_data_sp) 
941e cd 59 95			call display_dump_at_hl 
9421			 
9421 18 38			jr .bpschk 
9423 fe 39		.bps9:  cp '9' 
9425 20 05			jr nz, .bps8c 
9427				 
9427				; display SP 
9427			;	ld hl, sp 
9427 cd 59 95			call display_dump_at_hl 
942a			 
942a 18 2f			jr .bpschk 
942c fe 38		.bps8c:  cp '8' 
942e 20 08			jr nz, .bps8d 
9430				 
9430				; display rsp 
9430 2a 08 eb			ld hl, (cli_ret_sp) 
9433 cd 59 95			call display_dump_at_hl 
9436			 
9436 18 23			jr .bpschk 
9438 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
943a 20 05			jr nz, .bps8 
943c cd 6e 97			call monitor 
943f			 
943f 18 1a			jr .bpschk 
9441 fe 30		.bps8:  cp '0' 
9443 20 16			jr nz, .bpschk 
9445			 
9445 21 16 ed				ld hl, display_fb1 
9448 22 d2 eb				ld (display_fb_active), hl 
944b cd 8a 89				call update_display 
944e			 
944e				;ld a, (os_view_af) 
944e 2a c4 e3			ld hl, (os_view_hl) 
9451 ed 5b c2 e3		ld de, (os_view_de) 
9455 ed 4b c0 e3		ld bc, (os_view_bc) 
9459 f1				pop af 
945a c9				ret 
945b			 
945b			.bpschk:   
945b cd e4 88			call delay1s 
945e 3e 9f		ld a,display_row_4 + display_cols - 1 
9460 11 76 99		        ld de, endprg 
9463 cd 7a 89			call str_at_display 
9466 cd 8a 89			call update_display 
9469 cd 00 d9			call cin_wait 
946c			 
946c c3 bc 93			jp .bps1 
946f			 
946f			 
946f			display_reg_state: 
946f			 
946f				; to restore afterwards 
946f			 
946f d5				push de 
9470 c5				push bc 
9471 e5				push hl 
9472 f5				push af 
9473			 
9473				; for use in here 
9473			 
9473 c5				push bc 
9474 d5				push de 
9475 e5				push hl 
9476 f5				push af 
9477			 
9477 cd 67 89			call clear_display 
947a			 
947a 11 2f 95			ld de, .regstate 
947d 3e 00			ld a, display_row_1 
947f cd 7a 89			call str_at_display 
9482			 
9482				; display debug step 
9482			 
9482			 
9482 11 71 ee			ld de, debug_mark 
9485 3e 25			ld a, display_row_1+display_cols-3 
9487 cd 7a 89			call str_at_display 
948a			 
948a				; display a 
948a 11 4b 95			ld de, .regstatea 
948d 3e 28			ld a, display_row_2 
948f cd 7a 89			call str_at_display 
9492			 
9492 e1				pop hl 
9493			;	ld h,0 
9493			;	ld l, a 
9493 3e 2b			ld a, display_row_2+3 
9495 cd 1a 93			call display_word_at 
9498			 
9498			 
9498				; display hl 
9498			 
9498			 
9498 11 3f 95			ld de, .regstatehl 
949b 3e 32			ld a, display_row_2+10 
949d cd 7a 89			call str_at_display 
94a0			 
94a0 e1				pop hl 
94a1 3e 35			ld a, display_row_2+13 
94a3 cd 1a 93			call display_word_at 
94a6			 
94a6				 
94a6				; display de 
94a6			 
94a6 11 43 95			ld de, .regstatede 
94a9 3e 50			ld a, display_row_3 
94ab cd 7a 89			call str_at_display 
94ae			 
94ae e1				pop hl 
94af			;	ld h,d 
94af			;	ld l, e 
94af 3e 53			ld a, display_row_3+3 
94b1 cd 1a 93			call display_word_at 
94b4			 
94b4			 
94b4				; display bc 
94b4			 
94b4 11 47 95			ld de, .regstatebc 
94b7 3e 5a			ld a, display_row_3+10 
94b9 cd 7a 89			call str_at_display 
94bc			 
94bc e1				pop hl 
94bd			;	ld h,b 
94bd			;	ld l, c 
94bd 3e 5d			ld a, display_row_3+13 
94bf cd 1a 93			call display_word_at 
94c2			 
94c2			 
94c2				; display dsp 
94c2			 
94c2 11 4f 95			ld de, .regstatedsp 
94c5 3e 78			ld a, display_row_4 
94c7 cd 7a 89			call str_at_display 
94ca			 
94ca				 
94ca 2a 04 eb			ld hl,(cli_data_sp) 
94cd 3e 7c			ld a, display_row_4+4 
94cf cd 1a 93			call display_word_at 
94d2			 
94d2				; display rsp 
94d2			 
94d2 11 54 95			ld de, .regstatersp 
94d5 3e 82			ld a, display_row_4+10 
94d7 cd 7a 89			call str_at_display 
94da			 
94da				 
94da 2a 08 eb			ld hl,(cli_ret_sp) 
94dd 3e 86			ld a, display_row_4+14 
94df cd 1a 93			call display_word_at 
94e2			 
94e2 cd 8a 89			call update_display 
94e5			 
94e5			;	call delay1s 
94e5			;	call delay1s 
94e5			;	call delay1s 
94e5			 
94e5			 
94e5			;	call next_page_prompt 
94e5			 
94e5				; restore  
94e5			 
94e5 f1				pop af 
94e6 e1				pop hl 
94e7 c1				pop bc 
94e8 d1				pop de 
94e9 c9				ret 
94ea			 
94ea .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94fe .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9513 .. 00		.ptrstate:	db "Ptr State",0 
951d .. 00		.ptrcliptr:     db "cli_ptr",0 
9525 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
952f .. 00		.regstate:	db "Reg State (1/0)",0 
953f .. 00		.regstatehl:	db "HL:",0 
9543 .. 00		.regstatede:	db "DE:",0 
9547 .. 00		.regstatebc:	db "BC:",0 
954b .. 00		.regstatea:	db "A :",0 
954f .. 00		.regstatedsp:	db "DSP:",0 
9554 .. 00		.regstatersp:	db "RSP:",0 
9559			 
9559			display_dump_at_hl: 
9559 e5				push hl 
955a d5				push de 
955b c5				push bc 
955c f5				push af 
955d			 
955d 22 fa e6			ld (os_cur_ptr),hl	 
9560 cd 67 89			call clear_display 
9563 cd 80 98			call dumpcont 
9566			;	call delay1s 
9566			;	call next_page_prompt 
9566			 
9566			 
9566 f1				pop af 
9567 c1				pop bc 
9568 d1				pop de 
9569 e1				pop hl 
956a c9				ret 
956b			 
956b			;if ENABLE_BASIC 
956b			;	include "nascombasic.asm" 
956b			;	basic: 
956b			;	include "forth/FORTH.ASM" 
956b			;endif 
956b			 
956b			; eof 
956b			 
956b			 
# End of file firmware_diags.asm
956b			  
956b			include "firmware_prompts.asm"  
956b			; Prompts  
956b			 
956b			; boot messages 
956b			 
956b .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
9580 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9590			 
9590			 
9590			; config menus 
9590			 
9590 .. 00		prom_c3: db "Add Dictionary To File",0 
95a7 .. 00		prom_c2: db "Select Autoload File",0 
95bc .. 00		prom_c2a: db "Disable Autoload File", 0 
95d2 .. 00		prom_c2b: db "Select Storage Bank",0 
95e6 .. 00		prom_c4: db "Settings",0 
95ef .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
960a .. 00		prom_m4b:   db "Monitor",0 
9612 .. 00		prom_c1: db "Hardware Diags",0 
9621			 
9621			 
9621 .. 00		prom_notav:    db "Feature not available",0 
9637 .. 00		prom_empty:    db "",0 
9638			 
9638			; eof 
9638			 
# End of file firmware_prompts.asm
9638			  
9638			  
9638			; eof  
9638			  
# End of file firmware.asm
9638			 
9638			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9638			;if BASE_KEV  
9638			;baseram: equ 08000h 
9638			;endif 
9638			 
9638			;if BASE_SC114 
9638			;baseram:     equ    endofcode 
9638			;endif 
9638			 
9638			 
9638			; start system 
9638			 
9638			coldstart: 
9638				; set sp 
9638				; di/ei 
9638			 
9638 f3				di 
9639 31 00 f0			ld sp, tos 
963c			;	ei 
963c			 
963c			 
963c				; disable breakpoint by default 
963c			 
963c 3e 2a			ld a,'*' 
963e 32 c8 e3			ld (os_view_disable),a 
9641			 
9641				; init hardware 
9641			 
9641				; init keyboard and screen hardware 
9641			 
9641 cd 1c 80			call hardware_init 
9644			 
9644			 
9644 cd e4 88			call delay1s 
9647 3e 58			ld a, display_row_3+8 
9649 11 03 80			ld de, .buildtime 
964c cd 7a 89			call str_at_display 
964f cd 8a 89			call update_display 
9652			 
9652 cd e4 88			call delay1s 
9655			 
9655				; detect if any keys are held down to enable breakpoints at start up 
9655			 
9655 cd 06 d9			call cin  
9658 fe 00			cp 0 
965a 28 03			jr z, .nokeys 
965c			 
965c				;call hardware_diags 
965c cd f4 91			call config 
965f			 
965f			;	ld de, .bpen 
965f			;	ld a, display_row_4 
965f			;	call str_at_display 
965f			;	call update_display 
965f			; 
965f			;	ld a,0 
965f			;	ld (os_view_disable),a 
965f			; 
965f			;.bpwait: 
965f			;	call cin 
965f			;	cp 0 
965f			;	jr z, .bpwait 
965f			;	jr .nokeys 
965f			; 
965f			; 
965f			;.bpen:  db "Break points enabled!",0 
965f			 
965f			 
965f			 
965f			 
965f			 
965f			 
965f			.nokeys: 
965f			 
965f			 
965f				 
965f			 
965f			;jp  testkey 
965f			 
965f			;call storage_get_block_0 
965f			; 
965f			;ld hl, 0 
965f			;ld de, store_page 
965f			;call storage_read_block 
965f			 
965f				 
965f			;ld hl, 10 
965f			;ld de, store_page 
965f			;call storage_read_block 
965f			 
965f			 
965f			 
965f			 
965f			 
965f			;stop:	nop 
965f			;	jp stop 
965f			 
965f			 
965f			 
965f			main: 
965f cd 67 89			call clear_display 
9662 cd 8a 89			call update_display 
9665			 
9665			 
9665			 
9665			;	call testlcd 
9665			 
9665			 
9665			 
9665 cd 3e 9d			call forth_init 
9668			 
9668			 
9668			warmstart: 
9668 cd 14 9d			call forth_warmstart 
966b			 
966b				; run startup word load 
966b			        ; TODO prevent this running at warmstart after crash  
966b			 
966b				if STARTUP_ENABLE 
966b					if STORAGE_SE 
966b						call forth_autoload 
966b					endif 
966b cd 9a d5				call forth_startup 
966e			 
966e			 
966e				endif 
966e			 
966e				; show free memory after boot 
966e 11 08 97			ld de, freeram 
9671 3e 00			ld a, display_row_1 
9673 cd 7a 89			call str_at_display 
9676			 
9676			; Or use heap_size word???? 
9676 21 bd e3			ld hl, heap_end 
9679 11 24 d9			ld de, heap_start 
967c ed 52			sbc hl, de 
967e e5				push hl 
967f 7c				ld a,h	         	 
9680 21 dc e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9683 cd 95 8e			call hexout 
9686 e1			   	pop hl 
9687			 
9687 7d				ld a,l 
9688 21 de e6			ld hl, os_word_scratch+2 
968b cd 95 8e			call hexout 
968e 21 e0 e6			ld hl, os_word_scratch+4 
9691 3e 00			ld a, 0 
9693 77				ld (hl),a 
9694 11 dc e6			ld de, os_word_scratch 
9697 3e 0d			ld a, display_row_1 + 13 
9699 cd 7a 89			call str_at_display 
969c cd 8a 89			call update_display 
969f			 
969f			 
969f				;call demo 
969f			 
969f			 
969f				; init scratch input area for cli commands 
969f			 
969f 21 fe e6			ld hl, os_cli_cmd 
96a2 3e 00			ld a,0 
96a4 77				ld (hl),a 
96a5 23				inc hl 
96a6 77				ld (hl),a 
96a7			 
96a7 3e 00			ld a,0 
96a9 32 fd e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96ac			 
96ac 32 fa e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96af 32 fb e6			ld (os_cur_ptr+1),a	 
96b2			 
96b2 32 dc e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96b5 32 dd e6			ld (os_word_scratch+1),a	 
96b8				 
96b8			 
96b8				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96b8 21 fe e6			ld hl, os_cli_cmd 
96bb			 
96bb 3e 00			ld a, 0		 ; init cli input 
96bd 77				ld (hl), a 
96be 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96c0			cli: 
96c0				; show cli prompt 
96c0				;push af 
96c0				;ld a, 0 
96c0				;ld de, prompt 
96c0				;call str_at_display 
96c0			 
96c0				;call update_display 
96c0				;pop af 
96c0				;inc a 
96c0				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96c0 0e 00			ld c, 0 
96c2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96c4 1e 28			ld e, 40 
96c6			 
96c6 21 fe e6			ld hl, os_cli_cmd 
96c9			 
96c9				STACKFRAME OFF $fefe $9f9f 
96c9				if DEBUG_STACK_IMB 
96c9					if OFF 
96c9						exx 
96c9						ld de, $fefe 
96c9						ld a, d 
96c9						ld hl, curframe 
96c9						call hexout 
96c9						ld a, e 
96c9						ld hl, curframe+2 
96c9						call hexout 
96c9						ld hl, $fefe 
96c9						push hl 
96c9						ld hl, $9f9f 
96c9						push hl 
96c9						exx 
96c9					endif 
96c9				endif 
96c9			endm 
# End of macro STACKFRAME
96c9			 
96c9 cd c1 8b			call input_str 
96cc			 
96cc				STACKFRAMECHK OFF $fefe $9f9f 
96cc				if DEBUG_STACK_IMB 
96cc					if OFF 
96cc						exx 
96cc						ld hl, $9f9f 
96cc						pop de   ; $9f9f 
96cc						call cmp16 
96cc						jr nz, .spnosame 
96cc						ld hl, $fefe 
96cc						pop de   ; $fefe 
96cc						call cmp16 
96cc						jr z, .spfrsame 
96cc						.spnosame: call showsperror 
96cc						.spfrsame: nop 
96cc						exx 
96cc					endif 
96cc				endif 
96cc			endm 
# End of macro STACKFRAMECHK
96cc			 
96cc				; copy input to last command 
96cc			 
96cc 21 fe e6			ld hl, os_cli_cmd 
96cf 11 fd e7			ld de, os_last_cmd 
96d2 01 ff 00			ld bc, 255 
96d5 ed b0			ldir 
96d7			 
96d7				; wipe current buffer 
96d7			 
96d7			;	ld a, 0 
96d7			;	ld hl, os_cli_cmd 
96d7			;	ld de, os_cli_cmd+1 
96d7			;	ld bc, 254 
96d7			;	ldir 
96d7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
96d7			;	call strcpy 
96d7			;	ld a, 0 
96d7			;	ld (hl), a 
96d7			;	inc hl 
96d7			;	ld (hl), a 
96d7			;	inc hl 
96d7			;	ld (hl), a 
96d7			 
96d7				; switch frame buffer to program  
96d7			 
96d7 21 16 ed				ld hl, display_fb1 
96da 22 d2 eb				ld (display_fb_active), hl 
96dd			 
96dd			;	nop 
96dd				STACKFRAME ON $fbfe $8f9f 
96dd				if DEBUG_STACK_IMB 
96dd					if ON 
96dd						exx 
96dd						ld de, $fbfe 
96dd						ld a, d 
96dd						ld hl, curframe 
96dd						call hexout 
96dd						ld a, e 
96dd						ld hl, curframe+2 
96dd						call hexout 
96dd						ld hl, $fbfe 
96dd						push hl 
96dd						ld hl, $8f9f 
96dd						push hl 
96dd						exx 
96dd					endif 
96dd				endif 
96dd			endm 
# End of macro STACKFRAME
96dd				; first time into the parser so pass over the current scratch pad 
96dd 21 fe e6			ld hl,os_cli_cmd 
96e0				; tokenise the entered statement(s) in HL 
96e0 cd b7 9d			call forthparse 
96e3			        ; exec forth statements in top of return stack 
96e3 cd f7 9d			call forthexec 
96e6				;call forthexec_cleanup 
96e6			;	call parsenext 
96e6			 
96e6				STACKFRAMECHK ON $fbfe $8f9f 
96e6				if DEBUG_STACK_IMB 
96e6					if ON 
96e6						exx 
96e6						ld hl, $8f9f 
96e6						pop de   ; $8f9f 
96e6						call cmp16 
96e6						jr nz, .spnosame 
96e6						ld hl, $fbfe 
96e6						pop de   ; $fbfe 
96e6						call cmp16 
96e6						jr z, .spfrsame 
96e6						.spnosame: call showsperror 
96e6						.spfrsame: nop 
96e6						exx 
96e6					endif 
96e6				endif 
96e6			endm 
# End of macro STACKFRAMECHK
96e6				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
96e6			 
96e6 3e 78			ld a, display_row_4 
96e8 11 1a 97			ld de, endprog 
96eb			 
96eb cd 8a 89			call update_display		 
96ee			 
96ee cd 78 99			call next_page_prompt 
96f1			 
96f1				; switch frame buffer to cli 
96f1			 
96f1 21 b7 ed				ld hl, display_fb0 
96f4 22 d2 eb				ld (display_fb_active), hl 
96f7			 
96f7			 
96f7 cd 67 89		        call clear_display 
96fa cd 8a 89			call update_display		 
96fd			 
96fd 21 fe e6			ld hl, os_cli_cmd 
9700			 
9700 3e 00			ld a, 0		 ; init cli input 
9702 77				ld (hl), a 
9703			 
9703				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9703			 
9703				; now on last line 
9703			 
9703				; TODO scroll screen up 
9703			 
9703				; TODO instead just clear screen and place at top of screen 
9703			 
9703			;	ld a, 0 
9703			;	ld (f_cursor_ptr),a 
9703			 
9703				;call clear_display 
9703				;call update_display 
9703			 
9703				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9703 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9705 c3 c0 96			jp cli 
9708			 
9708 .. 00		freeram: db "Free bytes: $",0 
9716 ..			asc: db "1A2F" 
971a .. 00		endprog: db "End prog...",0 
9726			 
9726			testenter2:   
9726 21 09 e4			ld hl,scratch+50 
9729 22 fa e6			ld (os_cur_ptr),hl 
972c c3 c0 96			jp cli 
972f			 
972f			testenter:  
972f			 
972f 21 16 97			ld hl,asc 
9732			;	ld a,(hl) 
9732			;	call nibble2val 
9732 cd eb 8e			call get_byte 
9735			 
9735			 
9735			;	ld a,(hl) 
9735			;	call atohex 
9735			 
9735			;	call fourehexhl 
9735 32 09 e4			ld (scratch+50),a 
9738			 
9738			 
9738			 
9738 21 18 97			ld hl,asc+2 
973b			;	ld a, (hl) 
973b			;	call nibble2val 
973b cd eb 8e			call get_byte 
973e			 
973e			;	call fourehexhl 
973e 32 0b e4			ld (scratch+52),a 
9741				 
9741 21 09 e4			ld hl,scratch+50 
9744 22 fa e6			ld (os_cur_ptr),hl 
9747 c3 c0 96			jp cli 
974a			 
974a			enter:	 
974a 3a db e3			ld a,(scratch+4) 
974d fe 00			cp 0 
974f 28 0c			jr z, .entercont 
9751				; no, not a null term line so has an address to work out.... 
9751			 
9751 21 d9 e3			ld hl,scratch+2 
9754 cd 4b 8f			call get_word_hl 
9757			 
9757 22 fa e6			ld (os_cur_ptr),hl	 
975a c3 c0 96			jp cli 
975d			 
975d			 
975d			.entercont:  
975d			 
975d 21 d9 e3			ld hl, scratch+2 
9760 cd eb 8e			call get_byte 
9763			 
9763 2a fa e6		   	ld hl,(os_cur_ptr) 
9766 77					ld (hl),a 
9767 23					inc hl 
9768 22 fa e6				ld (os_cur_ptr),hl 
976b				 
976b			; get byte  
976b			 
976b			 
976b c3 c0 96			jp cli 
976e			 
976e			 
976e			; basic monitor support 
976e			 
976e			monitor: 
976e				;  
976e cd 67 89			call clear_display 
9771 3e 00			ld a, 0 
9773 11 bb 97			ld de, .monprompt 
9776 cd 7a 89			call str_at_display 
9779 cd 8a 89			call update_display 
977c			 
977c				; get a monitor command 
977c			 
977c 0e 00			ld c, 0     ; entry at top left 
977e 16 64			ld d, 100   ; max buffer size 
9780 1e 0f			ld e, 15    ; input scroll area 
9782 3e 00			ld a, 0     ; init string 
9784 21 d5 e5			ld hl, os_input 
9787 77				ld (hl), a 
9788 23				inc hl 
9789 77				ld (hl), a 
978a 21 d5 e5			ld hl, os_input 
978d 3e 01			ld a, 1     ; init string 
978f cd c1 8b			call input_str 
9792			 
9792 cd 67 89		        call clear_display 
9795 cd 8a 89			call update_display		 
9798			 
9798 3a d5 e5			ld a, (os_input) 
979b cd e9 8f			call toUpper 
979e fe 48		        cp 'H' 
97a0 28 6f		        jr z, .monhelp 
97a2 fe 44			cp 'D'		; dump 
97a4 ca 32 98			jp z, .mondump	 
97a7 fe 43			cp 'C'		; dump 
97a9 ca 4c 98			jp z, .moncdump	 
97ac fe 4d			cp 'M'		; dump 
97ae ca bd 97			jp z, .moneditstart 
97b1 fe 55			cp 'U'		; dump 
97b3 28 14			jr z, .monedit	 
97b5 fe 51			cp 'Q'		; dump 
97b7 c8				ret z	 
97b8			 
97b8			 
97b8				; TODO "S" to access symbol by name and not need the address 
97b8				; TODO "F" to find a string in memory 
97b8			 
97b8 c3 6e 97			jp monitor 
97bb			 
97bb .. 00		.monprompt: db ">", 0 
97bd			 
97bd			.moneditstart: 
97bd				; get starting address 
97bd			 
97bd 21 d7 e5			ld hl,os_input+2 
97c0 cd 4b 8f			call get_word_hl 
97c3			 
97c3 22 fa e6			ld (os_cur_ptr),hl	 
97c6			 
97c6 c3 6e 97			jp monitor 
97c9			 
97c9			.monedit: 
97c9				; get byte to load 
97c9			 
97c9 21 d7 e5			ld hl,os_input+2 
97cc cd eb 8e			call get_byte 
97cf			 
97cf				; get address to update 
97cf 2a fa e6			ld hl, (os_cur_ptr) 
97d2			 
97d2				; update byte 
97d2			 
97d2 77				ld (hl), a 
97d3			 
97d3				; move to next address and save it 
97d3			 
97d3 23				inc hl 
97d4 22 fa e6			ld (os_cur_ptr),hl	 
97d7			 
97d7 c3 6e 97			jp monitor 
97da			 
97da			 
97da .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
97ee .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
980a .. 00		.monhelptext3:  db "Q-Quit",0 
9811			        
9811			.monhelp: 
9811 3e 00			ld a, display_row_1 
9813 11 da 97		        ld de, .monhelptext1 
9816			 
9816 cd 7a 89			call str_at_display 
9819 3e 28			ld a, display_row_2 
981b 11 ee 97		        ld de, .monhelptext2 
981e					 
981e cd 7a 89			call str_at_display 
9821 3e 50			ld a, display_row_3 
9823 11 0a 98		        ld de, .monhelptext3 
9826					 
9826 cd 7a 89			call str_at_display 
9829 cd 8a 89			call update_display		 
982c			 
982c cd 78 99			call next_page_prompt 
982f c3 6e 97			jp monitor 
9832			 
9832			.mondump:    
9832 21 d7 e5			ld hl,os_input+2 
9835 cd 4b 8f			call get_word_hl 
9838			 
9838 22 fa e6			ld (os_cur_ptr),hl	 
983b cd 80 98			call dumpcont 
983e 3e 78			ld a, display_row_4 
9840 11 1a 97			ld de, endprog 
9843			 
9843 cd 8a 89			call update_display		 
9846			 
9846 cd 78 99			call next_page_prompt 
9849 c3 6e 97			jp monitor 
984c			.moncdump: 
984c cd 80 98			call dumpcont 
984f 3e 78			ld a, display_row_4 
9851 11 1a 97			ld de, endprog 
9854			 
9854 cd 8a 89			call update_display		 
9857			 
9857 cd 78 99			call next_page_prompt 
985a c3 6e 97			jp monitor 
985d			 
985d			 
985d			; TODO symbol access  
985d			 
985d			.symbols:     ;; A list of symbols that can be called up  
985d b7 ed			dw display_fb0 
985f .. 00			db "fb0",0  
9863 5c eb		     	dw store_page 
9865 .. 00			db "store_page",0 
9870			 
9870			 
9870			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9870			 
9870 3a d8 e3			ld a,(scratch+1) 
9873 fe 00			cp 0 
9875 28 09			jr z, dumpcont 
9877			 
9877				; no, not a null term line so has an address to work out.... 
9877			 
9877 21 d9 e3			ld hl,scratch+2 
987a cd 4b 8f			call get_word_hl 
987d			 
987d 22 fa e6			ld (os_cur_ptr),hl	 
9880			 
9880			 
9880			 
9880			dumpcont: 
9880			 
9880				; dump bytes at ptr 
9880			 
9880			 
9880 3e 00			ld a, display_row_1 
9882 2a d2 eb			ld hl, (display_fb_active) 
9885 cd 94 8b			call addatohl 
9888 cd b0 98			call .dumpbyterow 
988b			 
988b 3e 28			ld a, display_row_2 
988d 2a d2 eb			ld hl, (display_fb_active) 
9890 cd 94 8b			call addatohl 
9893 cd b0 98			call .dumpbyterow 
9896			 
9896			 
9896 3e 50			ld a, display_row_3 
9898 2a d2 eb			ld hl, (display_fb_active) 
989b cd 94 8b			call addatohl 
989e cd b0 98			call .dumpbyterow 
98a1			 
98a1 3e 78			ld a, display_row_4 
98a3 2a d2 eb			ld hl, (display_fb_active) 
98a6 cd 94 8b			call addatohl 
98a9 cd b0 98			call .dumpbyterow 
98ac			 
98ac cd 8a 89			call update_display 
98af			;		jp cli 
98af c9				ret 
98b0			 
98b0			.dumpbyterow: 
98b0			 
98b0				;push af 
98b0			 
98b0 e5				push hl 
98b1			 
98b1				; calc where to poke the ascii 
98b1			if display_cols == 20 
98b1				ld a, 16 
98b1			else 
98b1 3e 1f			ld a, 31 
98b3			endif 
98b3			 
98b3 cd 94 8b			call addatohl 
98b6 22 dc e6			ld (os_word_scratch),hl  		; save pos for later 
98b9			 
98b9			 
98b9			; display decoding address 
98b9 2a fa e6		   	ld hl,(os_cur_ptr) 
98bc			 
98bc 7c				ld a,h 
98bd e1				pop hl 
98be e5				push hl 
98bf			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
98bf cd 95 8e			call hexout 
98c2 2a fa e6		   	ld hl,(os_cur_ptr) 
98c5			 
98c5 7d				ld a,l 
98c6 e1				pop hl 
98c7 23				inc hl 
98c8 23				inc hl 
98c9 e5				push hl 
98ca			;	ld hl, os_word_scratch+2 
98ca cd 95 8e			call hexout 
98cd e1				pop hl 
98ce 23				inc hl 
98cf 23				inc hl 
98d0				;ld hl, os_word_scratch+4 
98d0 3e 3a			ld a, ':' 
98d2 77				ld (hl),a 
98d3 23				inc hl 
98d4				;ld a, 0 
98d4				;ld (hl),a 
98d4				;ld de, os_word_scratch 
98d4				;pop af 
98d4				;push af 
98d4			;		ld a, display_row_2 
98d4			;		call str_at_display 
98d4			;		call update_display 
98d4			 
98d4			 
98d4			;pop af 
98d4			;	add 5 
98d4			 
98d4			if display_cols == 20 
98d4				ld b, 4 
98d4			else 
98d4 06 08			ld b, 8 
98d6			endif	 
98d6			 
98d6			.dumpbyte: 
98d6 c5				push bc 
98d7 e5				push hl 
98d8			 
98d8			 
98d8 2a fa e6		   	ld hl,(os_cur_ptr) 
98db 7e					ld a,(hl) 
98dc			 
98dc					; poke the ascii to display 
98dc 2a dc e6				ld hl,(os_word_scratch) 
98df 77					ld (hl),a 
98e0 23					inc hl 
98e1 22 dc e6				ld (os_word_scratch),hl 
98e4			 
98e4					 
98e4			 
98e4			 
98e4 e1					pop hl 
98e5 e5					push hl 
98e6			 
98e6 cd 95 8e				call hexout 
98e9			 
98e9					 
98e9 2a fa e6		   	ld hl,(os_cur_ptr) 
98ec 23				inc hl 
98ed 22 fa e6		   	ld (os_cur_ptr),hl 
98f0			 
98f0 e1					pop hl 
98f1 23					inc hl 
98f2 23					inc hl 
98f3 23					inc hl 
98f4			 
98f4			 
98f4			 
98f4					;ld a,0 
98f4					;ld (os_word_scratch+2),a 
98f4					;pop af 
98f4					;push af 
98f4			 
98f4					;ld de, os_word_scratch 
98f4					;call str_at_display 
98f4			;		call update_display 
98f4			;		pop af 
98f4 c1					pop bc 
98f5 c6 03				add 3 
98f7 10 dd			djnz .dumpbyte 
98f9			 
98f9				 
98f9			 
98f9 c9				ret 
98fa			 
98fa			jump:	 
98fa			 
98fa 21 d9 e3			ld hl,scratch+2 
98fd cd 4b 8f			call get_word_hl 
9900				;ld hl,(scratch+2) 
9900				;call fourehexhl 
9900			 
9900 22 fa e6			ld (os_cur_ptr),hl	 
9903			 
9903 e9				jp (hl) 
9904			 
9904			 
9904			 
9904			; TODO implement a basic monitor mode to start with 
9904			 
9904			 
9904			 
9904			 
9904			 
9904			 
9904			 
9904			 
9904			 
9904			; testing and demo code during development 
9904			 
9904			 
9904 .. 00		str1: db "Enter some text...",0 
9917 .. 00		clear: db "                    ",0 
992c			 
992c			demo: 
992c			 
992c			 
992c			 
992c			;	call update_display 
992c			 
992c				; init scratch input area for testing 
992c 21 d7 e3			ld hl, scratch	 
992f 3e 00			ld a,0 
9931 77				ld (hl),a 
9932			 
9932			 
9932 3e 28		            LD   A, display_row_2 
9934			;            CALL fLCD_Pos       ;Position cursor to location in A 
9934 11 04 99		            LD   DE, str1 
9937 cd 7a 89			call str_at_display 
993a			 
993a			;            CALL fLCD_Str       ;Display string pointed to by DE 
993a			cloop:	 
993a 3e 50		            LD   A, display_row_3 
993c			;            CALL fLCD_Pos       ;Position cursor to location in A 
993c 11 17 99		            LD   DE, clear 
993f			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
993f cd 7a 89				call str_at_display 
9942 3e 78			ld a, display_row_4 
9944 11 74 99			ld de, prompt 
9947			 
9947 cd 7a 89				call str_at_display 
994a cd 8a 89			call update_display 
994d			 
994d 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
994f 16 0a			ld d, 10 
9951 21 d7 e3			ld hl, scratch	 
9954 cd c1 8b			call input_str 
9957			 
9957			;	call clear_display 
9957			;'	call update_display 
9957			 
9957 3e 00		            LD   A, display_row_1 
9959			;            CALL fLCD_Pos       ;Position cursor to location in A 
9959 11 17 99		            LD   DE, clear 
995c cd 7a 89				call str_at_display 
995f			;            CALL fLCD_Str       ;Display string pointed to by DE 
995f 3e 00		            LD   A, display_row_1 
9961			;            CALL fLCD_Pos       ;Position cursor to location in A 
9961 11 d7 e3		            LD   DE, scratch 
9964			;            CALL fLCD_Str       ;Display string pointed to by DE 
9964 cd 7a 89				call str_at_display 
9967 cd 8a 89			call update_display 
996a			 
996a 3e 00				ld a,0 
996c 21 d7 e3			ld hl, scratch 
996f 77				ld (hl),a 
9970			 
9970 00				nop 
9971 c3 3a 99			jp cloop 
9974			 
9974			 
9974			 
9974			; OS Prompt 
9974			 
9974 .. 00		prompt: db ">",0 
9976 .. 00		endprg: db "?",0 
9978			 
9978			 
9978			; handy next page prompt 
9978			next_page_prompt: 
9978 e5				push hl 
9979 d5				push de 
997a f5				push af 
997b c5				push bc 
997c			 
997c 3e 9f			ld a,display_row_4 + display_cols - 1 
997e 11 76 99		        ld de, endprg 
9981 cd 7a 89			call str_at_display 
9984 cd 8a 89			call update_display 
9987 cd 00 d9			call cin_wait 
998a c1				pop bc 
998b f1				pop af 
998c d1				pop de 
998d e1				pop hl 
998e			 
998e			 
998e c9				ret 
998f			 
998f			 
998f			; forth parser 
998f			 
998f			; My forth kernel 
998f			include "forth_kernel.asm" 
998f			; 
998f			; kernel to the forth OS 
998f			 
998f			DS_TYPE_STR: equ 1     ; string type 
998f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
998f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
998f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
998f			 
998f			FORTH_PARSEV1: equ 0 
998f			FORTH_PARSEV2: equ 0 
998f			FORTH_PARSEV3: equ 0 
998f			FORTH_PARSEV4: equ 0 
998f			FORTH_PARSEV5: equ 1 
998f			 
998f			;if FORTH_PARSEV5 
998f			;	FORTH_END_BUFFER: equ 0 
998f			;else 
998f			FORTH_END_BUFFER: equ 127 
998f			;endif 
998f			 
998f			FORTH_TRUE: equ 1 
998f			FORTH_FALSE: equ 0 
998f			 
998f			if FORTH_PARSEV4 
998f			include "forth_stackops.asm" 
998f			endif 
998f			 
998f			if FORTH_PARSEV5 
998f			include "forth_stackopsv5.asm" 
998f			 
998f			; Stack operations for v5 parser on wards 
998f			; * DATA stack 
998f			; * LOOP stack 
998f			; * RETURN stack 
998f			 
998f			 
998f			 
998f			FORTH_CHK_DSP_UNDER: macro 
998f				push hl 
998f				push de 
998f				ld hl,(cli_data_sp) 
998f				ld de, cli_data_stack 
998f				call cmp16 
998f				jp c, fault_dsp_under 
998f				pop de 
998f				pop hl 
998f				endm 
998f			 
998f			 
998f			FORTH_CHK_RSP_UNDER: macro 
998f				push hl 
998f				push de 
998f				ld hl,(cli_ret_sp) 
998f				ld de, cli_ret_stack 
998f				call cmp16 
998f				jp c, fault_rsp_under 
998f				pop de 
998f				pop hl 
998f				endm 
998f			 
998f			FORTH_CHK_LOOP_UNDER: macro 
998f				push hl 
998f				push de 
998f				ld hl,(cli_loop_sp) 
998f				ld de, cli_loop_stack 
998f				call cmp16 
998f				jp c, fault_loop_under 
998f				pop de 
998f				pop hl 
998f				endm 
998f			 
998f			FORTH_ERR_TOS_NOTSTR: macro 
998f				; TOSO might need more for checks when used 
998f				push af 
998f				ld a,(hl) 
998f				cp DS_TYPE_STR 
998f				jp nz, type_faultn   
998f				pop af 
998f				endm 
998f			 
998f			FORTH_ERR_TOS_NOTNUM: macro 
998f				push af 
998f				ld a,(hl) 
998f				cp DS_TYPE_INUM 
998f				jp nz, type_faultn   
998f				pop af 
998f				endm 
998f			 
998f			 
998f			; increase data stack pointer and save hl to it 
998f				 
998f			FORTH_DSP_NEXT: macro 
998f				call macro_forth_dsp_next 
998f				endm 
998f			 
998f			 
998f			macro_forth_dsp_next: 
998f				if DEBUG_FORTH_STACK_GUARD 
998f cd 64 d6				call check_stacks 
9992				endif 
9992 e5				push hl 
9993 d5				push de 
9994 eb				ex de,hl 
9995 2a 04 eb			ld hl,(cli_data_sp) 
9998 23				inc hl 
9999 23				inc hl 
999a			 
999a			; PARSEV5 
999a 23				inc hl 
999b 22 04 eb			ld (cli_data_sp),hl 
999e 73				ld (hl), e 
999f 23				inc hl 
99a0 72				ld (hl), d 
99a1 d1				pop de 
99a2 e1				pop hl 
99a3				if DEBUG_FORTH_STACK_GUARD 
99a3 cd 64 d6				call check_stacks 
99a6				endif 
99a6 c9				ret 
99a7			 
99a7			 
99a7			; increase ret stack pointer and save hl to it 
99a7				 
99a7			FORTH_RSP_NEXT: macro 
99a7				call macro_forth_rsp_next 
99a7				endm 
99a7			 
99a7			macro_forth_rsp_next: 
99a7				if DEBUG_FORTH_STACK_GUARD 
99a7 cd 64 d6				call check_stacks 
99aa				endif 
99aa e5				push hl 
99ab d5				push de 
99ac eb				ex de,hl 
99ad 2a 08 eb			ld hl,(cli_ret_sp) 
99b0 23				inc hl 
99b1 23				inc hl 
99b2 22 08 eb			ld (cli_ret_sp),hl 
99b5 73				ld (hl), e 
99b6 23				inc hl 
99b7 72				ld (hl), d 
99b8 d1				pop de 
99b9 e1				pop hl 
99ba				if DEBUG_FORTH_STACK_GUARD 
99ba cd 64 d6				call check_stacks 
99bd				endif 
99bd c9				ret 
99be			 
99be			; get current ret stack pointer and save to hl  
99be				 
99be			FORTH_RSP_TOS: macro 
99be				call macro_forth_rsp_tos 
99be				endm 
99be			 
99be			macro_forth_rsp_tos: 
99be				;push de 
99be 2a 08 eb			ld hl,(cli_ret_sp) 
99c1 cd f9 99			call loadhlptrtohl 
99c4				;ld e, (hl) 
99c4				;inc hl 
99c4				;ld d, (hl) 
99c4				;ex de, hl 
99c4					if DEBUG_FORTH_WORDS 
99c4			;			DMARK "RST" 
99c4						CALLMONITOR 
99c4 cd 95 93			call break_point_state  
99c7				endm  
# End of macro CALLMONITOR
99c7					endif 
99c7				;pop de 
99c7 c9				ret 
99c8			 
99c8			; pop ret stack pointer 
99c8				 
99c8			FORTH_RSP_POP: macro 
99c8				call macro_forth_rsp_pop 
99c8				endm 
99c8			 
99c8			 
99c8			macro_forth_rsp_pop: 
99c8				if DEBUG_FORTH_STACK_GUARD 
99c8			;		DMARK "RPP" 
99c8 cd 64 d6				call check_stacks 
99cb					FORTH_CHK_RSP_UNDER 
99cb e5				push hl 
99cc d5				push de 
99cd 2a 08 eb			ld hl,(cli_ret_sp) 
99d0 11 c2 ea			ld de, cli_ret_stack 
99d3 cd b2 8b			call cmp16 
99d6 da 78 d7			jp c, fault_rsp_under 
99d9 d1				pop de 
99da e1				pop hl 
99db				endm 
# End of macro FORTH_CHK_RSP_UNDER
99db				endif 
99db e5				push hl 
99dc 2a 08 eb			ld hl,(cli_ret_sp) 
99df			 
99df			 
99df				if FORTH_ENABLE_FREE 
99df			 
99df					; get pointer 
99df			 
99df					push de 
99df					push hl 
99df			 
99df					ld e, (hl) 
99df					inc hl 
99df					ld d, (hl) 
99df			 
99df					ex de, hl 
99df					call free 
99df			 
99df					pop hl 
99df					pop de 
99df			 
99df			 
99df				endif 
99df			 
99df			 
99df 2b				dec hl 
99e0 2b				dec hl 
99e1 22 08 eb			ld (cli_ret_sp), hl 
99e4				; do stack underflow checks 
99e4 e1				pop hl 
99e5				if DEBUG_FORTH_STACK_GUARD 
99e5 cd 64 d6				call check_stacks 
99e8					FORTH_CHK_RSP_UNDER 
99e8 e5				push hl 
99e9 d5				push de 
99ea 2a 08 eb			ld hl,(cli_ret_sp) 
99ed 11 c2 ea			ld de, cli_ret_stack 
99f0 cd b2 8b			call cmp16 
99f3 da 78 d7			jp c, fault_rsp_under 
99f6 d1				pop de 
99f7 e1				pop hl 
99f8				endm 
# End of macro FORTH_CHK_RSP_UNDER
99f8				endif 
99f8 c9				ret 
99f9			 
99f9			 
99f9			 
99f9			; routine to load word pointed to by hl into hl 
99f9			 
99f9			loadhlptrtohl: 
99f9			 
99f9 d5				push de 
99fa 5e				ld e, (hl) 
99fb 23				inc hl 
99fc 56				ld d, (hl) 
99fd eb				ex de, hl 
99fe d1				pop de 
99ff			 
99ff c9				ret 
9a00			 
9a00			 
9a00			 
9a00			 
9a00			 
9a00			; push a number held in HL onto the data stack 
9a00			; entry point for pushing a value when already in hl used in function above 
9a00			 
9a00			forth_push_numhl: 
9a00			 
9a00 e5				push hl    ; save value to push 
9a01			 
9a01			if DEBUG_FORTH_PUSH 
9a01				; see if disabled 
9a01			 
9a01			 
9a01 f5				push af 
9a02 3a c8 e3			ld a, (os_view_disable) 
9a05 fe 2a			cp '*' 
9a07 28 34			jr z, .pskip2 
9a09 e5				push hl 
9a0a e5			push hl 
9a0b cd 67 89			call clear_display 
9a0e e1			pop hl 
9a0f 7c				ld a,h 
9a10 21 dc e6			ld hl, os_word_scratch 
9a13 cd 95 8e			call hexout 
9a16 e1				pop hl 
9a17 7d				ld a,l 
9a18 21 de e6			ld hl, os_word_scratch+2 
9a1b cd 95 8e			call hexout 
9a1e			 
9a1e 21 e0 e6			ld hl, os_word_scratch+4 
9a21 3e 00			ld a,0 
9a23 77				ld (hl),a 
9a24 11 dc e6			ld de,os_word_scratch 
9a27 3e 28				ld a, display_row_2 
9a29 cd 7a 89				call str_at_display 
9a2c 11 43 c5			ld de, .push_num 
9a2f 3e 00			ld a, display_row_1 
9a31			 
9a31 cd 7a 89				call str_at_display 
9a34			 
9a34			 
9a34 cd 8a 89			call update_display 
9a37 cd e4 88			call delay1s 
9a3a cd e4 88			call delay1s 
9a3d			.pskip2:  
9a3d			 
9a3d f1				pop af 
9a3e			endif	 
9a3e			 
9a3e			 
9a3e				FORTH_DSP_NEXT 
9a3e cd 8f 99			call macro_forth_dsp_next 
9a41				endm 
# End of macro FORTH_DSP_NEXT
9a41			 
9a41 2a 04 eb			ld hl, (cli_data_sp) 
9a44			 
9a44				; save item type 
9a44 3e 02			ld a,  DS_TYPE_INUM 
9a46 77				ld (hl), a 
9a47 23				inc hl 
9a48			 
9a48				; get word off stack 
9a48 d1				pop de 
9a49 7b				ld a,e 
9a4a 77				ld (hl), a 
9a4b 23				inc hl 
9a4c 7a				ld a,d 
9a4d 77				ld (hl), a 
9a4e			 
9a4e			if DEBUG_FORTH_PUSH 
9a4e 2b				dec hl 
9a4f 2b				dec hl 
9a50 2b				dec hl 
9a51						DMARK "PH5" 
9a51 f5				push af  
9a52 3a 66 9a			ld a, (.dmark)  
9a55 32 71 ee			ld (debug_mark),a  
9a58 3a 67 9a			ld a, (.dmark+1)  
9a5b 32 72 ee			ld (debug_mark+1),a  
9a5e 3a 68 9a			ld a, (.dmark+2)  
9a61 32 73 ee			ld (debug_mark+2),a  
9a64 18 03			jr .pastdmark  
9a66 ..			.dmark: db "PH5"  
9a69 f1			.pastdmark: pop af  
9a6a			endm  
# End of macro DMARK
9a6a				CALLMONITOR 
9a6a cd 95 93			call break_point_state  
9a6d				endm  
# End of macro CALLMONITOR
9a6d			endif	 
9a6d			 
9a6d c9				ret 
9a6e			 
9a6e			 
9a6e			; Push a string to stack pointed to by hl 
9a6e			 
9a6e			forth_push_str: 
9a6e			 
9a6e			if DEBUG_FORTH_PUSH 
9a6e						DMARK "PSQ" 
9a6e f5				push af  
9a6f 3a 83 9a			ld a, (.dmark)  
9a72 32 71 ee			ld (debug_mark),a  
9a75 3a 84 9a			ld a, (.dmark+1)  
9a78 32 72 ee			ld (debug_mark+1),a  
9a7b 3a 85 9a			ld a, (.dmark+2)  
9a7e 32 73 ee			ld (debug_mark+2),a  
9a81 18 03			jr .pastdmark  
9a83 ..			.dmark: db "PSQ"  
9a86 f1			.pastdmark: pop af  
9a87			endm  
# End of macro DMARK
9a87				CALLMONITOR 
9a87 cd 95 93			call break_point_state  
9a8a				endm  
# End of macro CALLMONITOR
9a8a			endif	 
9a8a			    
9a8a e5				push hl 
9a8b e5				push hl 
9a8c			 
9a8c			;	ld a, 0   ; find end of string 
9a8c cd f2 8f			call strlenz 
9a8f			if DEBUG_FORTH_PUSH 
9a8f						DMARK "PQ2" 
9a8f f5				push af  
9a90 3a a4 9a			ld a, (.dmark)  
9a93 32 71 ee			ld (debug_mark),a  
9a96 3a a5 9a			ld a, (.dmark+1)  
9a99 32 72 ee			ld (debug_mark+1),a  
9a9c 3a a6 9a			ld a, (.dmark+2)  
9a9f 32 73 ee			ld (debug_mark+2),a  
9aa2 18 03			jr .pastdmark  
9aa4 ..			.dmark: db "PQ2"  
9aa7 f1			.pastdmark: pop af  
9aa8			endm  
# End of macro DMARK
9aa8				CALLMONITOR 
9aa8 cd 95 93			call break_point_state  
9aab				endm  
# End of macro CALLMONITOR
9aab			endif	 
9aab eb				ex de, hl 
9aac e1				pop hl   ; get ptr to start of string 
9aad			if DEBUG_FORTH_PUSH 
9aad						DMARK "PQ3" 
9aad f5				push af  
9aae 3a c2 9a			ld a, (.dmark)  
9ab1 32 71 ee			ld (debug_mark),a  
9ab4 3a c3 9a			ld a, (.dmark+1)  
9ab7 32 72 ee			ld (debug_mark+1),a  
9aba 3a c4 9a			ld a, (.dmark+2)  
9abd 32 73 ee			ld (debug_mark+2),a  
9ac0 18 03			jr .pastdmark  
9ac2 ..			.dmark: db "PQ3"  
9ac5 f1			.pastdmark: pop af  
9ac6			endm  
# End of macro DMARK
9ac6				CALLMONITOR 
9ac6 cd 95 93			call break_point_state  
9ac9				endm  
# End of macro CALLMONITOR
9ac9			endif	 
9ac9 19				add hl,de 
9aca			if DEBUG_FORTH_PUSH 
9aca						DMARK "PQE" 
9aca f5				push af  
9acb 3a df 9a			ld a, (.dmark)  
9ace 32 71 ee			ld (debug_mark),a  
9ad1 3a e0 9a			ld a, (.dmark+1)  
9ad4 32 72 ee			ld (debug_mark+1),a  
9ad7 3a e1 9a			ld a, (.dmark+2)  
9ada 32 73 ee			ld (debug_mark+2),a  
9add 18 03			jr .pastdmark  
9adf ..			.dmark: db "PQE"  
9ae2 f1			.pastdmark: pop af  
9ae3			endm  
# End of macro DMARK
9ae3				CALLMONITOR 
9ae3 cd 95 93			call break_point_state  
9ae6				endm  
# End of macro CALLMONITOR
9ae6			endif	 
9ae6			 
9ae6 2b				dec hl    ; see if there is an optional trailing double quote 
9ae7 7e				ld a,(hl) 
9ae8 fe 22			cp '"' 
9aea 20 03			jr nz, .strnoq 
9aec 3e 00			ld a, 0      ; get rid of double quote 
9aee 77				ld (hl), a 
9aef 23			.strnoq: inc hl 
9af0			 
9af0 3e 00			ld a, 0 
9af2 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9af3			 
9af3 13				inc de ; add one for the type string 
9af4 13				inc de ; add one for null term??? 
9af5			 
9af5				; tos is get string pointer again 
9af5				; de contains space to allocate 
9af5				 
9af5 d5				push de 
9af6			 
9af6 eb				ex de, hl 
9af7			 
9af7				;push af 
9af7			 
9af7			if DEBUG_FORTH_PUSH 
9af7						DMARK "PHm" 
9af7 f5				push af  
9af8 3a 0c 9b			ld a, (.dmark)  
9afb 32 71 ee			ld (debug_mark),a  
9afe 3a 0d 9b			ld a, (.dmark+1)  
9b01 32 72 ee			ld (debug_mark+1),a  
9b04 3a 0e 9b			ld a, (.dmark+2)  
9b07 32 73 ee			ld (debug_mark+2),a  
9b0a 18 03			jr .pastdmark  
9b0c ..			.dmark: db "PHm"  
9b0f f1			.pastdmark: pop af  
9b10			endm  
# End of macro DMARK
9b10				CALLMONITOR 
9b10 cd 95 93			call break_point_state  
9b13				endm  
# End of macro CALLMONITOR
9b13			endif	 
9b13 cd 5b 90			call malloc	; on ret hl now contains allocated memory 
9b16				if DEBUG_FORTH_MALLOC_GUARD 
9b16 cc 9b c5				call z,malloc_error 
9b19				endif 
9b19			 
9b19				 
9b19 c1				pop bc    ; get length 
9b1a d1				pop de   ;  get string start    
9b1b			 
9b1b				; hl has destination from malloc 
9b1b			 
9b1b eb				ex de, hl    ; prep for ldir 
9b1c			 
9b1c d5				push de   ; save malloc area for DSP later 
9b1d				;push hl   ; save malloc area for DSP later 
9b1d			 
9b1d			if DEBUG_FORTH_PUSH 
9b1d						DMARK "PHc" 
9b1d f5				push af  
9b1e 3a 32 9b			ld a, (.dmark)  
9b21 32 71 ee			ld (debug_mark),a  
9b24 3a 33 9b			ld a, (.dmark+1)  
9b27 32 72 ee			ld (debug_mark+1),a  
9b2a 3a 34 9b			ld a, (.dmark+2)  
9b2d 32 73 ee			ld (debug_mark+2),a  
9b30 18 03			jr .pastdmark  
9b32 ..			.dmark: db "PHc"  
9b35 f1			.pastdmark: pop af  
9b36			endm  
# End of macro DMARK
9b36				CALLMONITOR 
9b36 cd 95 93			call break_point_state  
9b39				endm  
# End of macro CALLMONITOR
9b39			endif	 
9b39			 
9b39			 
9b39 ed b0			ldir 
9b3b			 
9b3b			 
9b3b				; push malloc to data stack     macro?????  
9b3b			 
9b3b				FORTH_DSP_NEXT 
9b3b cd 8f 99			call macro_forth_dsp_next 
9b3e				endm 
# End of macro FORTH_DSP_NEXT
9b3e			 
9b3e				; save value and type 
9b3e			 
9b3e 2a 04 eb			ld hl, (cli_data_sp) 
9b41			 
9b41				; save item type 
9b41 3e 01			ld a,  DS_TYPE_STR 
9b43 77				ld (hl), a 
9b44 23				inc hl 
9b45			 
9b45				; get malloc word off stack 
9b45 d1				pop de 
9b46 73				ld (hl), e 
9b47 23				inc hl 
9b48 72				ld (hl), d 
9b49			 
9b49			 
9b49			 
9b49			if DEBUG_FORTH_PUSH 
9b49 2a 04 eb			ld hl, (cli_data_sp) 
9b4c						DMARK "PHS" 
9b4c f5				push af  
9b4d 3a 61 9b			ld a, (.dmark)  
9b50 32 71 ee			ld (debug_mark),a  
9b53 3a 62 9b			ld a, (.dmark+1)  
9b56 32 72 ee			ld (debug_mark+1),a  
9b59 3a 63 9b			ld a, (.dmark+2)  
9b5c 32 73 ee			ld (debug_mark+2),a  
9b5f 18 03			jr .pastdmark  
9b61 ..			.dmark: db "PHS"  
9b64 f1			.pastdmark: pop af  
9b65			endm  
# End of macro DMARK
9b65				CALLMONITOR 
9b65 cd 95 93			call break_point_state  
9b68				endm  
# End of macro CALLMONITOR
9b68			;	ex de,hl 
9b68			endif	 
9b68				; in case of spaces, skip the ptr past the copied string 
9b68				;pop af 
9b68				;ld (cli_origptr),hl 
9b68			 
9b68 c9				ret 
9b69			 
9b69			 
9b69			 
9b69			; TODO ascii push input onto stack given hl to start of input 
9b69			 
9b69			; identify type 
9b69			; if starts with a " then a string 
9b69			; otherwise it is a number 
9b69			;  
9b69			; if a string 
9b69			;     scan for ending " to get length of string to malloc for + 1 
9b69			;     malloc 
9b69			;     put pointer to string on stack first byte flags as string 
9b69			; 
9b69			; else a number 
9b69			;    look for number format identifier 
9b69			;    $xx hex 
9b69			;    %xxxxx bin 
9b69			;    xxxxx decimal 
9b69			;    convert number to 16bit word.  
9b69			;    malloc word + 1 with flag to identiy as num 
9b69			;    put pointer to number on stack 
9b69			;   
9b69			;  
9b69			  
9b69			forth_apush: 
9b69				; kernel push 
9b69			 
9b69			if DEBUG_FORTH_PUSH 
9b69						DMARK "PSH" 
9b69 f5				push af  
9b6a 3a 7e 9b			ld a, (.dmark)  
9b6d 32 71 ee			ld (debug_mark),a  
9b70 3a 7f 9b			ld a, (.dmark+1)  
9b73 32 72 ee			ld (debug_mark+1),a  
9b76 3a 80 9b			ld a, (.dmark+2)  
9b79 32 73 ee			ld (debug_mark+2),a  
9b7c 18 03			jr .pastdmark  
9b7e ..			.dmark: db "PSH"  
9b81 f1			.pastdmark: pop af  
9b82			endm  
# End of macro DMARK
9b82				CALLMONITOR 
9b82 cd 95 93			call break_point_state  
9b85				endm  
# End of macro CALLMONITOR
9b85			endif	 
9b85				; identify input type 
9b85			 
9b85 7e				ld a,(hl) 
9b86 fe 22			cp '"' 
9b88 28 0a			jr z, .fapstr 
9b8a fe 24			cp '$' 
9b8c ca b4 9b			jp z, .faphex 
9b8f fe 25			cp '%' 
9b91 ca 9c 9b			jp z, .fapbin 
9b94			;	cp 'b' 
9b94			;	jp z, .fabin 
9b94				; else decimal 
9b94			 
9b94				; TODO do decimal conversion 
9b94				; decimal is stored as a 16bit word 
9b94			 
9b94				; by default everything is a string if type is not detected 
9b94			.fapstr: ; 
9b94 fe 22			cp '"' 
9b96 20 01			jr nz, .strnoqu 
9b98 23				inc hl 
9b99			.strnoqu: 
9b99 c3 6e 9a			jp forth_push_str 
9b9c			 
9b9c			 
9b9c			 
9b9c			.fapbin:    ; push a binary string.  
9b9c 11 00 00			ld de, 0   ; hold a 16bit value 
9b9f			 
9b9f 23			.fapbinshift:	inc hl  
9ba0 7e				ld a,(hl) 
9ba1 fe 00			cp 0     ; done scanning  
9ba3 28 0b			jr z, .fapbdone  	; got it in HL so push  
9ba5			 
9ba5				; left shift de 
9ba5 eb				ex de, hl	 
9ba6 29				add hl, hl 
9ba7			 
9ba7				; is 1 
9ba7 fe 31			cp '1' 
9ba9 20 02			jr nz, .binzero 
9bab cb 4d			bit 1, l 
9bad			.binzero: 
9bad eb				ex de, hl	 ; save current de 
9bae 18 ef			jr .fapbinshift 
9bb0			 
9bb0			.fapbdone: 
9bb0 eb				ex de, hl 
9bb1 c3 00 9a			jp forth_push_numhl 
9bb4			 
9bb4			 
9bb4			.faphex:   ; hex is always stored as a 16bit word 
9bb4				; skip number prefix 
9bb4 23				inc hl 
9bb5				; turn ascii into number 
9bb5 cd 4b 8f			call get_word_hl	; ret 16bit word in hl 
9bb8			 
9bb8 c3 00 9a			jp forth_push_numhl 
9bbb			 
9bbb 00				 nop 
9bbc			 
9bbc			.fabin:   ; TODO bin conversion 
9bbc			 
9bbc			 
9bbc c9				ret 
9bbd			 
9bbd			 
9bbd			; get either a string ptr or a 16bit word from the data stack 
9bbd			 
9bbd			FORTH_DSP: macro 
9bbd				call macro_forth_dsp 
9bbd				endm 
9bbd			 
9bbd			macro_forth_dsp: 
9bbd				; data stack pointer points to current word on tos 
9bbd			 
9bbd 2a 04 eb			ld hl,(cli_data_sp) 
9bc0			 
9bc0				if DEBUG_FORTH_PUSH 
9bc0						DMARK "DSP" 
9bc0 f5				push af  
9bc1 3a d5 9b			ld a, (.dmark)  
9bc4 32 71 ee			ld (debug_mark),a  
9bc7 3a d6 9b			ld a, (.dmark+1)  
9bca 32 72 ee			ld (debug_mark+1),a  
9bcd 3a d7 9b			ld a, (.dmark+2)  
9bd0 32 73 ee			ld (debug_mark+2),a  
9bd3 18 03			jr .pastdmark  
9bd5 ..			.dmark: db "DSP"  
9bd8 f1			.pastdmark: pop af  
9bd9			endm  
# End of macro DMARK
9bd9			 
9bd9 cd d0 c5				call display_data_sp 
9bdc				;call break_point_state 
9bdc				;rst 030h 
9bdc				CALLMONITOR 
9bdc cd 95 93			call break_point_state  
9bdf				endm  
# End of macro CALLMONITOR
9bdf				endif 
9bdf			 
9bdf c9				ret 
9be0			 
9be0			; return hl to start of value on stack 
9be0			 
9be0			FORTH_DSP_VALUE: macro 
9be0				call macro_forth_dsp_value 
9be0				endm 
9be0			 
9be0			macro_forth_dsp_value: 
9be0			 
9be0				FORTH_DSP 
9be0 cd bd 9b			call macro_forth_dsp 
9be3				endm 
# End of macro FORTH_DSP
9be3			 
9be3 d5				push de 
9be4			 
9be4 23				inc hl ; skip type 
9be5			 
9be5 5e				ld e, (hl) 
9be6 23				inc hl 
9be7 56				ld d, (hl) 
9be8 eb				ex de,hl  
9be9			 
9be9 d1				pop de 
9bea			 
9bea c9				ret 
9beb			 
9beb			; return hl to start of value to second item on stack 
9beb			 
9beb			FORTH_DSP_VALUEM1: macro 
9beb				call macro_forth_dsp_value_m1 
9beb				endm 
9beb			 
9beb			macro_forth_dsp_value_m1: 
9beb			 
9beb				FORTH_DSP 
9beb cd bd 9b			call macro_forth_dsp 
9bee				endm 
# End of macro FORTH_DSP
9bee			 
9bee 2b				dec hl 
9bef 2b				dec hl 
9bf0			;	dec hl 
9bf0			 
9bf0 d5				push de 
9bf1			 
9bf1 5e				ld e, (hl) 
9bf2 23				inc hl 
9bf3 56				ld d, (hl) 
9bf4 eb				ex de,hl  
9bf5			 
9bf5 d1				pop de 
9bf6			 
9bf6 c9				ret 
9bf7			 
9bf7				 
9bf7			 
9bf7			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bf7			 
9bf7			FORTH_DSP_POP: macro 
9bf7				call macro_forth_dsp_pop 
9bf7				endm 
9bf7			 
9bf7			 
9bf7			; get the tos data type 
9bf7			 
9bf7			FORTH_DSP_TYPE:   macro 
9bf7			 
9bf7				;FORTH_DSP_VALUE 
9bf7				FORTH_DSP 
9bf7				 
9bf7				; hl points to value 
9bf7				; check type 
9bf7			 
9bf7				ld a,(hl) 
9bf7			 
9bf7				endm 
9bf7			 
9bf7			; load the tos value into hl 
9bf7			 
9bf7			 
9bf7			FORTH_DSP_VALUEHL:  macro 
9bf7				call macro_dsp_valuehl 
9bf7				endm 
9bf7			 
9bf7			 
9bf7			 
9bf7			macro_dsp_valuehl: 
9bf7				FORTH_DSP_VALUE 
9bf7 cd e0 9b			call macro_forth_dsp_value 
9bfa				endm 
# End of macro FORTH_DSP_VALUE
9bfa			 
9bfa				;FORTH_ERR_TOS_NOTNUM 
9bfa			 
9bfa				;inc hl   ; skip type id 
9bfa			 
9bfa			;	push de 
9bfa			; 
9bfa			;	ld e, (hl) 
9bfa			;	inc hl 
9bfa			;	ld d, (hl) 
9bfa			;	ex de,hl  
9bfa			 
9bfa			;	pop de 
9bfa			 
9bfa				if DEBUG_FORTH_PUSH 
9bfa						DMARK "DVL" 
9bfa f5				push af  
9bfb 3a 0f 9c			ld a, (.dmark)  
9bfe 32 71 ee			ld (debug_mark),a  
9c01 3a 10 9c			ld a, (.dmark+1)  
9c04 32 72 ee			ld (debug_mark+1),a  
9c07 3a 11 9c			ld a, (.dmark+2)  
9c0a 32 73 ee			ld (debug_mark+2),a  
9c0d 18 03			jr .pastdmark  
9c0f ..			.dmark: db "DVL"  
9c12 f1			.pastdmark: pop af  
9c13			endm  
# End of macro DMARK
9c13				CALLMONITOR 
9c13 cd 95 93			call break_point_state  
9c16				endm  
# End of macro CALLMONITOR
9c16				endif 
9c16 c9				ret 
9c17			 
9c17			forth_apushstrhl:      
9c17				; push of string requires use of cli_origptr 
9c17				; bodge use 
9c17			 
9c17				; get current cli_origptr, save, update with temp pointer  
9c17 ed 5b 20 eb		ld de, (cli_origptr) 
9c1b 22 20 eb			ld (cli_origptr), hl 
9c1e d5				push de 
9c1f cd 69 9b			call forth_apush 
9c22 d1				pop de 
9c23 ed 53 20 eb		ld (cli_origptr), de 
9c27 c9			        ret	 
9c28			 
9c28			 
9c28			; increase loop stack pointer and save hl to it 
9c28				 
9c28			FORTH_LOOP_NEXT: macro 
9c28				call macro_forth_loop_next 
9c28				;nop 
9c28				endm 
9c28			 
9c28			macro_forth_loop_next: 
9c28				if DEBUG_FORTH_STACK_GUARD 
9c28 cd 64 d6				call check_stacks 
9c2b				endif 
9c2b e5				push hl 
9c2c d5				push de 
9c2d eb				ex de,hl 
9c2e 2a 06 eb			ld hl,(cli_loop_sp) 
9c31 23				inc hl 
9c32 23				inc hl 
9c33					if DEBUG_FORTH_WORDS 
9c33						DMARK "LNX" 
9c33 f5				push af  
9c34 3a 48 9c			ld a, (.dmark)  
9c37 32 71 ee			ld (debug_mark),a  
9c3a 3a 49 9c			ld a, (.dmark+1)  
9c3d 32 72 ee			ld (debug_mark+1),a  
9c40 3a 4a 9c			ld a, (.dmark+2)  
9c43 32 73 ee			ld (debug_mark+2),a  
9c46 18 03			jr .pastdmark  
9c48 ..			.dmark: db "LNX"  
9c4b f1			.pastdmark: pop af  
9c4c			endm  
# End of macro DMARK
9c4c						CALLMONITOR 
9c4c cd 95 93			call break_point_state  
9c4f				endm  
# End of macro CALLMONITOR
9c4f					endif 
9c4f 22 06 eb			ld (cli_loop_sp),hl 
9c52 73				ld (hl), e 
9c53 23				inc hl 
9c54 72				ld (hl), d 
9c55 d1				pop de    ; been reversed so save a swap on restore 
9c56 e1				pop hl 
9c57				if DEBUG_FORTH_STACK_GUARD 
9c57 cd 64 d6				call check_stacks 
9c5a				endif 
9c5a c9				ret 
9c5b			 
9c5b			; get current ret stack pointer and save to hl  
9c5b				 
9c5b			FORTH_LOOP_TOS: macro 
9c5b				call macro_forth_loop_tos 
9c5b				endm 
9c5b			 
9c5b			macro_forth_loop_tos: 
9c5b d5				push de 
9c5c 2a 06 eb			ld hl,(cli_loop_sp) 
9c5f 5e				ld e, (hl) 
9c60 23				inc hl 
9c61 56				ld d, (hl) 
9c62 eb				ex de, hl 
9c63 d1				pop de 
9c64 c9				ret 
9c65			 
9c65			; pop loop stack pointer 
9c65				 
9c65			FORTH_LOOP_POP: macro 
9c65				call macro_forth_loop_pop 
9c65				endm 
9c65			 
9c65			 
9c65			macro_forth_loop_pop: 
9c65				if DEBUG_FORTH_STACK_GUARD 
9c65					DMARK "LPP" 
9c65 f5				push af  
9c66 3a 7a 9c			ld a, (.dmark)  
9c69 32 71 ee			ld (debug_mark),a  
9c6c 3a 7b 9c			ld a, (.dmark+1)  
9c6f 32 72 ee			ld (debug_mark+1),a  
9c72 3a 7c 9c			ld a, (.dmark+2)  
9c75 32 73 ee			ld (debug_mark+2),a  
9c78 18 03			jr .pastdmark  
9c7a ..			.dmark: db "LPP"  
9c7d f1			.pastdmark: pop af  
9c7e			endm  
# End of macro DMARK
9c7e cd 64 d6				call check_stacks 
9c81					FORTH_CHK_LOOP_UNDER 
9c81 e5				push hl 
9c82 d5				push de 
9c83 2a 06 eb			ld hl,(cli_loop_sp) 
9c86 11 40 ea			ld de, cli_loop_stack 
9c89 cd b2 8b			call cmp16 
9c8c da 7e d7			jp c, fault_loop_under 
9c8f d1				pop de 
9c90 e1				pop hl 
9c91				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c91				endif 
9c91 e5				push hl 
9c92 2a 06 eb			ld hl,(cli_loop_sp) 
9c95 2b				dec hl 
9c96 2b				dec hl 
9c97 22 06 eb			ld (cli_loop_sp), hl 
9c9a				; TODO do stack underflow checks 
9c9a e1				pop hl 
9c9b				if DEBUG_FORTH_STACK_GUARD 
9c9b cd 64 d6				call check_stacks 
9c9e					FORTH_CHK_LOOP_UNDER 
9c9e e5				push hl 
9c9f d5				push de 
9ca0 2a 06 eb			ld hl,(cli_loop_sp) 
9ca3 11 40 ea			ld de, cli_loop_stack 
9ca6 cd b2 8b			call cmp16 
9ca9 da 7e d7			jp c, fault_loop_under 
9cac d1				pop de 
9cad e1				pop hl 
9cae				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9cae				endif 
9cae c9				ret 
9caf			 
9caf			macro_forth_dsp_pop: 
9caf			 
9caf e5				push hl 
9cb0			 
9cb0				; release malloc data 
9cb0			 
9cb0				if DEBUG_FORTH_STACK_GUARD 
9cb0 cd 64 d6				call check_stacks 
9cb3					FORTH_CHK_DSP_UNDER 
9cb3 e5				push hl 
9cb4 d5				push de 
9cb5 2a 04 eb			ld hl,(cli_data_sp) 
9cb8 11 3e e9			ld de, cli_data_stack 
9cbb cd b2 8b			call cmp16 
9cbe da 72 d7			jp c, fault_dsp_under 
9cc1 d1				pop de 
9cc2 e1				pop hl 
9cc3				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cc3				endif 
9cc3				;ld hl,(cli_data_sp) 
9cc3			if DEBUG_FORTH_DOT 
9cc3				DMARK "DPP" 
9cc3				CALLMONITOR 
9cc3			endif	 
9cc3			 
9cc3			 
9cc3			if FORTH_ENABLE_DSPPOPFREE 
9cc3			 
9cc3				FORTH_DSP 
9cc3 cd bd 9b			call macro_forth_dsp 
9cc6				endm 
# End of macro FORTH_DSP
9cc6			 
9cc6 7e				ld a, (hl) 
9cc7 fe 01			cp DS_TYPE_STR 
9cc9 20 07			jr nz, .skippopfree 
9ccb			 
9ccb				FORTH_DSP_VALUEHL 
9ccb cd f7 9b			call macro_dsp_valuehl 
9cce				endm 
# End of macro FORTH_DSP_VALUEHL
9cce 00				nop 
9ccf			if DEBUG_FORTH_DOT 
9ccf				DMARK "DPf" 
9ccf				CALLMONITOR 
9ccf			endif	 
9ccf cd 25 91			call free 
9cd2			.skippopfree: 
9cd2				 
9cd2			 
9cd2			endif 
9cd2			 
9cd2			if DEBUG_FORTH_DOT_KEY 
9cd2				DMARK "DP2" 
9cd2				CALLMONITOR 
9cd2			endif	 
9cd2			 
9cd2				; move pointer down 
9cd2			 
9cd2 2a 04 eb			ld hl,(cli_data_sp) 
9cd5 2b				dec hl 
9cd6 2b				dec hl 
9cd7			; PARSEV5 
9cd7 2b				dec hl 
9cd8 22 04 eb			ld (cli_data_sp), hl 
9cdb			 
9cdb				if DEBUG_FORTH_STACK_GUARD 
9cdb cd 64 d6				call check_stacks 
9cde					FORTH_CHK_DSP_UNDER 
9cde e5				push hl 
9cdf d5				push de 
9ce0 2a 04 eb			ld hl,(cli_data_sp) 
9ce3 11 3e e9			ld de, cli_data_stack 
9ce6 cd b2 8b			call cmp16 
9ce9 da 72 d7			jp c, fault_dsp_under 
9cec d1				pop de 
9ced e1				pop hl 
9cee				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cee				endif 
9cee			 
9cee e1				pop hl 
9cef			 
9cef c9				ret 
9cf0			 
9cf0			getwordathl: 
9cf0				; hl points to an address 
9cf0				; load hl with the word at that address 
9cf0			 
9cf0 d5				push de 
9cf1			 
9cf1 5e				ld e, (hl) 
9cf2 23				inc hl 
9cf3 56				ld d, (hl) 
9cf4 eb				ex de, hl 
9cf5			 
9cf5 d1				pop de 
9cf6 c9				ret 
9cf7			 
9cf7			 
9cf7			 
9cf7			 
9cf7			 
9cf7			; eof 
9cf7			 
# End of file forth_stackopsv5.asm
9cf7			endif 
9cf7			 
9cf7			user_word_eol:  
9cf7				; hl contains the pointer to where to create a linked list item from the end 
9cf7				; of the user dict to continue on at the system word dict 
9cf7				 
9cf7				; poke the stub of the word list linked list to repoint to rom words 
9cf7			 
9cf7				; stub format 
9cf7				; db   word id 
9cf7				; dw    link to next word 
9cf7			        ; db char length of token 
9cf7				; db string + 0 term 
9cf7				; db exec code....  
9cf7			 
9cf7 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9cf9 77				ld (hl), a		; word id 
9cfa 23				inc hl 
9cfb			 
9cfb 11 c1 9e			ld de, sysdict 
9cfe 73				ld (hl), e		; next word link ie system dict 
9cff 23				inc hl 
9d00 72				ld (hl), d		; next word link ie system dict 
9d01 23				inc hl	 
9d02			 
9d02			;	ld (hl), sysdict		; next word link ie system dict 
9d02			;	inc hl 
9d02			;	inc hl 
9d02			 
9d02			;	inc hl 
9d02			;	inc hl 
9d02			 
9d02 3e 02			ld a, 2			; word length is 0 
9d04 77				ld (hl), a	 
9d05 23				inc hl 
9d06			 
9d06 3e 7e			ld a, '~'			; word length is 0 
9d08 77				ld (hl), a	 
9d09 23				inc hl 
9d0a 3e 00			ld a, 0			; save empty word 
9d0c 77				ld (hl), a 
9d0d			 
9d0d c9				ret 
9d0e			 
9d0e				 
9d0e			 
9d0e			forthexec_cleanup: 
9d0e				FORTH_RSP_POP 
9d0e cd c8 99			call macro_forth_rsp_pop 
9d11				endm 
# End of macro FORTH_RSP_POP
9d11 c9				ret 
9d12			 
9d12			forth_call_hl: 
9d12				; taking hl 
9d12 e5				push hl 
9d13 c9				ret 
9d14			 
9d14			; this is called to reset Forth system but keep existing uwords etc 
9d14			 
9d14			forth_warmstart: 
9d14				; setup stack over/under flow checks 
9d14				if DEBUG_FORTH_STACK_GUARD 
9d14 cd 4a d6				call chk_stk_init 
9d17				endif 
9d17			 
9d17				; init stack pointers  - * these stacks go upwards *  
9d17 21 c2 ea			ld hl, cli_ret_stack 
9d1a 22 08 eb			ld (cli_ret_sp), hl	 
9d1d				; set bottom of stack 
9d1d 3e 00			ld a,0 
9d1f 77				ld (hl),a 
9d20 23				inc hl 
9d21 77				ld (hl),a 
9d22			 
9d22 21 3e e9			ld hl, cli_data_stack 
9d25 22 04 eb			ld (cli_data_sp), hl	 
9d28				; set bottom of stack 
9d28 3e 00			ld a,0 
9d2a 77				ld (hl),a 
9d2b 23				inc hl 
9d2c 77				ld (hl),a 
9d2d			 
9d2d 21 40 ea			ld hl, cli_loop_stack 
9d30 22 06 eb			ld (cli_loop_sp), hl	 
9d33				; set bottom of stack 
9d33 3e 00			ld a,0 
9d35 77				ld (hl),a 
9d36 23				inc hl 
9d37 77				ld (hl),a 
9d38			 
9d38				; init extent of current open file 
9d38			 
9d38 3e 00			ld a, 0 
9d3a 32 53 eb			ld (store_openext), a 
9d3d			 
9d3d c9				ret 
9d3e			 
9d3e			 
9d3e			; Cold Start - this is called to setup the whole Forth system 
9d3e			 
9d3e			forth_init: 
9d3e			 
9d3e				; setup stack over/under flow checks 
9d3e			 
9d3e			;	if DEBUG_FORTH_STACK_GUARD 
9d3e			;		call chk_stk_init 
9d3e			;	endif 
9d3e			 
9d3e				; enable auto display updates (slow.....) 
9d3e			 
9d3e 3e 01			ld a, 1 
9d40 32 1e eb			ld (cli_autodisplay), a 
9d43			 
9d43			 
9d43			 
9d43				; show start up screen 
9d43			 
9d43 cd 67 89			call clear_display 
9d46			 
9d46 3e 00			ld a,0 
9d48 32 40 eb			ld (f_cursor_ptr), a 
9d4b			 
9d4b				; set start of word list in start of ram - for use when creating user words 
9d4b			 
9d4b 21 15 d9			ld hl, baseram 
9d4e 22 d4 e6			ld (os_last_new_uword), hl 
9d51 cd f7 9c			call user_word_eol 
9d54				 
9d54			;		call display_data_sp 
9d54			;		call next_page_prompt 
9d54			 
9d54			 
9d54			 
9d54			 
9d54 c9				ret 
9d55			 
9d55 .. 00		.bootforth: db " Forth Kernel Init ",0 
9d69			 
9d69			; TODO push to stack 
9d69			 
9d69			;  
9d69			 
9d69			if FORTH_PARSEV2 
9d69			 
9d69			 
9d69				include "forth_parserv2.asm" 
9d69			 
9d69			endif 
9d69			 
9d69			 
9d69			; parse cli version 1 
9d69			 
9d69			if FORTH_PARSEV1 
9d69			 
9d69			 
9d69			 
9d69			      include "forth_parserv1.asm" 
9d69			endif 
9d69				 
9d69			if FORTH_PARSEV3 
9d69			 
9d69			 
9d69			 
9d69			      include "forth_parserv3.asm" 
9d69				include "forth_wordsv3.asm" 
9d69			endif 
9d69			 
9d69			if FORTH_PARSEV4 
9d69			 
9d69			 
9d69			 
9d69			      include "forth_parserv4.asm" 
9d69				include "forth_wordsv4.asm" 
9d69			endif 
9d69			 
9d69			if FORTH_PARSEV5 
9d69			 
9d69			 
9d69			 
9d69			      include "forth_parserv5.asm" 
9d69			 
9d69			 
9d69			; A better parser without using malloc and string copies all over the place.  
9d69			; Exec in situ should be faster 
9d69			 
9d69			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9d69			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9d69			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9d69			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9d69			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9d69			WORD_SYS_END: equ 0   ; Opcode for all user words 
9d69			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9d69			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9d69			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9d69			 
9d69			; Core word preamble macro 
9d69			 
9d69			CWHEAD:   macro nxtword opcode lit len opflags 
9d69				db WORD_SYS_CORE+opcode             
9d69				; internal op code number 
9d69				dw nxtword            
9d69				; link to next dict word block 
9d69				db len + 1 
9d69				; literal length of dict word inc zero term 
9d69				db lit,0              
9d69				; literal dict word 
9d69			        ; TODO db opflags        
9d69				endm 
9d69			 
9d69			 
9d69			NEXTW: macro  
9d69				jp macro_next 
9d69				endm 
9d69			 
9d69			macro_next: 
9d69			if DEBUG_FORTH_PARSE_KEY 
9d69				DMARK "NXT" 
9d69				CALLMONITOR 
9d69			endif	 
9d69			;	inc hl  ; skip token null term  
9d69 ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9d6d ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9d71 2a d8 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9d74			if DEBUG_FORTH_PARSE_KEY 
9d74				DMARK "}AA" 
9d74				CALLMONITOR 
9d74			endif	 
9d74 c3 77 9e			jp execnext 
9d77				;jp exec1 
9d77			       
9d77			 
9d77			 
9d77			; Another go at the parser to compile  
9d77			 
9d77			 
9d77			; TODO rework parser to change all of the string words to byte tokens 
9d77			; TODO do a search for  
9d77			 
9d77			; TODO first run normal parser to zero term sections 
9d77			; TODO for each word do a token look up to get the op code 
9d77			; TODO need some means to flag to the exec that this is a byte code form    
9d77			 
9d77			 
9d77			forthcompile: 
9d77			 
9d77			; 
9d77			; line parse: 
9d77			;       parse raw input buffer 
9d77			;       tokenise the words 
9d77			;       malloc new copy (for looping etc) 
9d77			;       copy to malloc + current pc in line to start of string and add line term 
9d77			;       save on new rsp 
9d77			; 
9d77			 
9d77			; hl to point to the line to tokenise 
9d77			 
9d77			;	push hl 
9d77 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9d7a			 
9d7a			;	ld a,0		; string term on input 
9d7a			;	call strlent 
9d7a			 
9d7a			;	ld (os_tok_len), hl	 ; save string length 
9d7a			 
9d7a			;if DEBUG_FORTH_TOK 
9d7a			;	ex de,hl		 
9d7a			;endif 
9d7a			 
9d7a			;	pop hl 		; get back string pointer 
9d7a			 
9d7a			if DEBUG_FORTH_TOK 
9d7a						DMARK "TOc" 
9d7a				CALLMONITOR 
9d7a			endif 
9d7a 7e			.cptoken2:    ld a,(hl) 
9d7b 23				inc hl 
9d7c fe 7f			cp FORTH_END_BUFFER 
9d7e 28 29			jr z, .cptokendone2 
9d80 fe 00			cp 0 
9d82 28 25			jr z, .cptokendone2 
9d84 fe 22			cp '"' 
9d86 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9d88 fe 20			cp ' ' 
9d8a 20 ee			jr nz,  .cptoken2 
9d8c			 
9d8c			; TODO consume comments held between ( and ) 
9d8c			 
9d8c				; we have a space so change to zero term for dict match later 
9d8c 2b				dec hl 
9d8d 3e 00			ld a,0 
9d8f 77				ld (hl), a 
9d90 23				inc hl 
9d91 18 e7			jr .cptoken2 
9d93				 
9d93			 
9d93			.cptokenstr2: 
9d93				; skip all white space until either eol (because forgot to term) or end double quote 
9d93			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9d93				;inc hl ; skip current double quote 
9d93 7e				ld a,(hl) 
9d94 23				inc hl 
9d95 fe 22			cp '"' 
9d97 28 e1			jr z, .cptoken2 
9d99 fe 7f			cp FORTH_END_BUFFER 
9d9b 28 0c			jr z, .cptokendone2 
9d9d fe 00			cp 0 
9d9f 28 08			jr z, .cptokendone2 
9da1 fe 20			cp ' ' 
9da3 28 02			jr z, .cptmp2 
9da5 18 ec			jr .cptokenstr2 
9da7			 
9da7			.cptmp2:	; we have a space so change to zero term for dict match later 
9da7				;dec hl 
9da7				;ld a,"-"	; TODO remove this when working 
9da7				;ld (hl), a 
9da7				;inc hl 
9da7 18 ea			jr .cptokenstr2 
9da9			 
9da9			.cptokendone2: 
9da9				;inc hl 
9da9 3e 7f			ld a, FORTH_END_BUFFER 
9dab 77				ld (hl),a 
9dac 23				inc hl 
9dad 3e 21			ld a, '!' 
9daf 77				ld (hl),a 
9db0			 
9db0 2a d8 e6			ld hl,(os_tok_ptr) 
9db3			         
9db3			if DEBUG_FORTH_TOK 
9db3						DMARK "Tc1" 
9db3				CALLMONITOR 
9db3			endif 
9db3			 
9db3				; push exec string to top of return stack 
9db3				FORTH_RSP_NEXT 
9db3 cd a7 99			call macro_forth_rsp_next 
9db6				endm 
# End of macro FORTH_RSP_NEXT
9db6 c9				ret 
9db7			 
9db7			; Another go at the parser need to simplify the process 
9db7			 
9db7			forthparse: 
9db7			 
9db7			; 
9db7			; line parse: 
9db7			;       parse raw input buffer 
9db7			;       tokenise the words 
9db7			;       malloc new copy (for looping etc) 
9db7			;       copy to malloc + current pc in line to start of string and add line term 
9db7			;       save on new rsp 
9db7			; 
9db7			 
9db7			; hl to point to the line to tokenise 
9db7			 
9db7			;	push hl 
9db7 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9dba			 
9dba			;	ld a,0		; string term on input 
9dba			;	call strlent 
9dba			 
9dba			;	ld (os_tok_len), hl	 ; save string length 
9dba			 
9dba			;if DEBUG_FORTH_TOK 
9dba			;	ex de,hl		 
9dba			;endif 
9dba			 
9dba			;	pop hl 		; get back string pointer 
9dba			 
9dba			if DEBUG_FORTH_TOK 
9dba						DMARK "TOK" 
9dba				CALLMONITOR 
9dba			endif 
9dba 7e			.ptoken2:    ld a,(hl) 
9dbb 23				inc hl 
9dbc fe 7f			cp FORTH_END_BUFFER 
9dbe 28 29			jr z, .ptokendone2 
9dc0 fe 00			cp 0 
9dc2 28 25			jr z, .ptokendone2 
9dc4 fe 22			cp '"' 
9dc6 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9dc8 fe 20			cp ' ' 
9dca 20 ee			jr nz,  .ptoken2 
9dcc			 
9dcc			; TODO consume comments held between ( and ) 
9dcc			 
9dcc				; we have a space so change to zero term for dict match later 
9dcc 2b				dec hl 
9dcd 3e 00			ld a,0 
9dcf 77				ld (hl), a 
9dd0 23				inc hl 
9dd1 18 e7			jr .ptoken2 
9dd3				 
9dd3			 
9dd3			.ptokenstr2: 
9dd3				; skip all white space until either eol (because forgot to term) or end double quote 
9dd3			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9dd3				;inc hl ; skip current double quote 
9dd3 7e				ld a,(hl) 
9dd4 23				inc hl 
9dd5 fe 22			cp '"' 
9dd7 28 e1			jr z, .ptoken2 
9dd9 fe 7f			cp FORTH_END_BUFFER 
9ddb 28 0c			jr z, .ptokendone2 
9ddd fe 00			cp 0 
9ddf 28 08			jr z, .ptokendone2 
9de1 fe 20			cp ' ' 
9de3 28 02			jr z, .ptmp2 
9de5 18 ec			jr .ptokenstr2 
9de7			 
9de7			.ptmp2:	; we have a space so change to zero term for dict match later 
9de7				;dec hl 
9de7				;ld a,"-"	; TODO remove this when working 
9de7				;ld (hl), a 
9de7				;inc hl 
9de7 18 ea			jr .ptokenstr2 
9de9			 
9de9			.ptokendone2: 
9de9				;inc hl 
9de9 3e 7f			ld a, FORTH_END_BUFFER 
9deb 77				ld (hl),a 
9dec 23				inc hl 
9ded 3e 21			ld a, '!' 
9def 77				ld (hl),a 
9df0			 
9df0 2a d8 e6			ld hl,(os_tok_ptr) 
9df3			         
9df3			if DEBUG_FORTH_TOK 
9df3						DMARK "TK1" 
9df3				CALLMONITOR 
9df3			endif 
9df3			 
9df3				; push exec string to top of return stack 
9df3				FORTH_RSP_NEXT 
9df3 cd a7 99			call macro_forth_rsp_next 
9df6				endm 
# End of macro FORTH_RSP_NEXT
9df6 c9				ret 
9df7			 
9df7			; 
9df7			;	; malloc size + buffer pointer + if is loop flag 
9df7			;	ld hl,(os_tok_len) 		 ; get string length 
9df7			; 
9df7			;	ld a,l 
9df7			; 
9df7			;	cp 0			; we dont want to use a null string 
9df7			;	ret z 
9df7			; 
9df7			;;	add 3    ; prefix malloc with buffer for current word ptr 
9df7			; 
9df7			;	add 5     ; TODO when certain not over writing memory remove 
9df7			; 
9df7			;		 
9df7			; 
9df7			;if DEBUG_FORTH_TOK 
9df7			;			DMARK "TKE" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			; 
9df7			;	ld l,a 
9df7			;	ld h,0 
9df7			;;	push hl   ; save required space for the copy later 
9df7			;	call malloc 
9df7			;if DEBUG_FORTH_TOK 
9df7			;			DMARK "TKM" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			;	if DEBUG_FORTH_MALLOC_GUARD 
9df7			;		push af 
9df7			;		call ishlzero 
9df7			;;		ld a, l 
9df7			;;		add h 
9df7			;;		cp 0 
9df7			;		pop af 
9df7			;		 
9df7			;		call z,malloc_error 
9df7			;	endif 
9df7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9df7			; 
9df7			; 
9df7			;if DEBUG_FORTH_TOK 
9df7			;			DMARK "TKR" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			; 
9df7			;	FORTH_RSP_NEXT 
9df7			; 
9df7			;	;inc hl	 ; go past current buffer pointer 
9df7			;	;inc hl 
9df7			;	;inc hl   ; and past if loop flag 
9df7			;		; TODO Need to set flag  
9df7			; 
9df7			;	 
9df7			;	 
9df7			;	ex de,hl	; malloc is dest 
9df7			;	ld hl, (os_tok_len) 
9df7			;;	pop bc 
9df7			;	ld c, l                
9df7			;	ld b,0 
9df7			;	ld hl, (os_tok_ptr) 
9df7			; 
9df7			;if DEBUG_FORTH_TOK 
9df7			;			DMARK "TKT" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			; 
9df7			;	; do str cpy 
9df7			; 
9df7			;	ldir      ; copy byte in hl to de 
9df7			; 
9df7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9df7			; 
9df7			;if DEBUG_FORTH_TOK 
9df7			; 
9df7			;			DMARK "TKY" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			;	;ld a,0 
9df7			;	;ld a,FORTH_END_BUFFER 
9df7			;	ex de, hl 
9df7			;	;dec hl			 ; go back over the space delim at the end of word 
9df7			;	;ld (hl),a 
9df7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9df7			;	ld a,FORTH_END_BUFFER 
9df7			;	ld (hl),a 
9df7			;	inc hl 
9df7			;	ld a,FORTH_END_BUFFER 
9df7			;	ld (hl),a 
9df7			; 
9df7			;	; init the malloc area data 
9df7			;	; set pc for in current area 
9df7			;	;ld hl, (os_tok_malloc) 
9df7			;	;inc hl 
9df7			;	;inc hl 
9df7			;	;inc hl 
9df7			;	;ex de,hl 
9df7			;	;ld hl, (os_tok_malloc) 
9df7			;	;ld (hl),e 
9df7			;	;inc hl 
9df7			;	;ld (hl),d 
9df7			; 
9df7			; 
9df7			;	ld hl,(os_tok_malloc) 
9df7			;if DEBUG_FORTH_PARSE_KEY 
9df7			;			DMARK "TKU" 
9df7			;	CALLMONITOR 
9df7			;endif 
9df7			; 
9df7			;	ret 
9df7			 
9df7			forthexec: 
9df7			 
9df7			; line exec: 
9df7			; forth parser 
9df7			 
9df7			; 
9df7			;       get current exec line on rsp 
9df7			 
9df7				FORTH_RSP_TOS 
9df7 cd be 99			call macro_forth_rsp_tos 
9dfa				endm 
# End of macro FORTH_RSP_TOS
9dfa			 
9dfa			;       restore current pc - hl points to malloc of data 
9dfa			 
9dfa				;ld e, (hl) 
9dfa				;inc hl 
9dfa				;ld d, (hl) 
9dfa				;ex de,hl 
9dfa			 
9dfa			 
9dfa			exec1: 
9dfa 22 d8 e6			ld (os_tok_ptr), hl 
9dfd			 
9dfd				; copy our PC to working vars  
9dfd 22 22 eb			ld (cli_ptr), hl 
9e00 22 20 eb			ld (cli_origptr), hl 
9e03			 
9e03 7e				ld a,(hl) 
9e04 fe 7f			cp FORTH_END_BUFFER 
9e06 c8				ret z 
9e07			 
9e07				; skip any nulls 
9e07			 
9e07 fe 00			cp 0 
9e09 20 03			jr nz, .execword 
9e0b 23				inc hl 
9e0c 18 ec			jr exec1 
9e0e			 
9e0e			 
9e0e			.execword: 
9e0e			 
9e0e			 
9e0e			 
9e0e			if DEBUG_FORTH_PARSE_KEY 
9e0e						DMARK "KYQ" 
9e0e				CALLMONITOR 
9e0e			endif 
9e0e			;       while at start of word: 
9e0e			; get start of dict (in user area first) 
9e0e			 
9e0e 21 15 d9		ld hl, baseram 
9e11			;ld hl, sysdict 
9e11 22 24 eb		ld (cli_nextword),hl 
9e14			;           match word at pc 
9e14			;           exec word 
9e14			;           or push to dsp 
9e14			;           forward to next token 
9e14			;           if line term pop rsp and exit 
9e14			;        
9e14			 
9e14			if DEBUG_FORTH_PARSE_KEY 
9e14						DMARK "KYq" 
9e14				CALLMONITOR 
9e14			endif 
9e14			 
9e14			; 
9e14			; word comp 
9e14			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9e14			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9e14			;    move to start of word  
9e14			;    compare word to cli_token 
9e14			 
9e14			.execpnword:	; HL at start of a word in the dictionary to check 
9e14			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9e14			;	ld (cli_ptr), hl 
9e14			 
9e14 2a 24 eb			ld hl,(cli_nextword) 
9e17			 
9e17 cd ba 9e			call forth_tok_next 
9e1a			; tok next start here 
9e1a			;	; TODO skip compiled symbol for now 
9e1a			;	inc hl 
9e1a			; 
9e1a			;	; save pointer to next word 
9e1a			; 
9e1a			;	; hl now points to the address of the next word pointer  
9e1a			;	ld e, (hl) 
9e1a			;	inc hl 
9e1a			;	ld d, (hl) 
9e1a			;	inc l 
9e1a			; 
9e1a			;	ex de,hl 
9e1a			;if DEBUG_FORTH_PARSE_NEXTWORD 
9e1a			;	push bc 
9e1a			;	ld bc, (cli_nextword) 
9e1a			;			DMARK "NXW" 
9e1a			;	CALLMONITOR 
9e1a			;	pop bc 
9e1a			;endif 
9e1a			; tok next end here 
9e1a 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9e1d eb				ex de, hl 
9e1e			 
9e1e			 
9e1e				; save the pointer of the current token - 1 to check against 
9e1e				 
9e1e 22 28 eb			ld (cli_token), hl   
9e21				; TODO maybe remove below save if no debug 
9e21				; save token string ptr for any debug later 
9e21 23				inc hl  
9e22 22 2a eb			ld (cli_origtoken), hl 
9e25 2b				dec hl 
9e26				; save pointer to the start of the next dictionay word 
9e26 7e				ld a,(hl)   ; get string length 
9e27 47				ld b,a 
9e28			.execpnwordinc:  
9e28 23				inc hl 
9e29 10 fd			djnz .execpnwordinc 
9e2b 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
9e2e			 
9e2e				; now check the word token against the string being parsed 
9e2e			 
9e2e 2a 28 eb			ld hl,(cli_token) 
9e31 23				inc hl     ; skip string length (use zero term instead to end) 
9e32 22 28 eb			ld (cli_token), hl 
9e35			 
9e35			if DEBUG_FORTH_PARSE_KEY 
9e35						DMARK "KY2" 
9e35			endif 
9e35			if DEBUG_FORTH_PARSE_EXEC 
9e35				; see if disabled 
9e35			 
9e35				ld a, (os_view_disable) 
9e35				cp '*' 
9e35				jr z, .skip 
9e35			 
9e35				push hl 
9e35				push hl 
9e35				call clear_display 
9e35				ld de, .compword 
9e35				ld a, display_row_1 
9e35				call str_at_display 
9e35				pop de 
9e35				ld a, display_row_2 
9e35				call str_at_display 
9e35				ld hl,(cli_ptr) 
9e35				ld a,(hl) 
9e35			        ld hl, os_word_scratch 
9e35				ld (hl),a 
9e35				ld a,0 
9e35				inc hl 
9e35				ld (hl),a 	 
9e35				ld de, os_word_scratch 
9e35				ld a, display_row_2+10 
9e35				call str_at_display 
9e35				call update_display 
9e35				ld a, 100 
9e35				call aDelayInMS 
9e35				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e35				call delay250ms 
9e35				endif 
9e35				pop hl 
9e35			.skip:  
9e35			endif	 
9e35			.execpnchar:    ; compare char between token and string to parse 
9e35			 
9e35			if DEBUG_FORTH_PARSE_KEY 
9e35						DMARK "Ky3" 
9e35			endif 
9e35			if DEBUG_FORTH_PARSE_EXEC 
9e35				; see if disabled 
9e35			 
9e35				ld a, (os_view_disable) 
9e35				cp '*' 
9e35				jr z, .skip2 
9e35			 
9e35			;	call clear_display 
9e35			ld hl,(cli_token) 
9e35			ld a,(hl) 
9e35			ld (os_word_scratch),a 
9e35				ld hl,(cli_ptr) 
9e35			ld a,(hl) 
9e35				ld (os_word_scratch+1),a 
9e35				ld a,0 
9e35				ld (os_word_scratch+2),a 
9e35				ld de,os_word_scratch 
9e35				ld a,display_row_4 
9e35				call str_at_display 
9e35				call update_display 
9e35			.skip2:  
9e35			endif 
9e35 2a 28 eb			ld hl,(cli_token) 
9e38 7e				ld a, (hl)	 ; char in word token 
9e39 23				inc hl 		; move to next char 
9e3a 22 28 eb			ld (cli_token), hl ; and save it 
9e3d 47				ld b,a 
9e3e			 
9e3e 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9e41 7e				ld a,(hl) 
9e42 23				inc hl 
9e43 22 22 eb			ld (cli_ptr), hl		; move to next char 
9e46 cd e9 8f			call toUpper 		; make sure the input string matches case 
9e49			 
9e49			if DEBUG_FORTH_PARSE 
9e49			endif 
9e49			 
9e49				; input stream end of token is a space so get rid of it 
9e49			 
9e49			;	cp ' ' 
9e49			;	jr nz, .pnskipspace 
9e49			; 
9e49			;	ld a, 0		; make same term as word token term 
9e49			; 
9e49			;.pnskipspace: 
9e49			 
9e49			if DEBUG_FORTH_PARSE_KEY 
9e49						DMARK "KY7" 
9e49			endif 
9e49 b8				cp b 
9e4a c2 60 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9e4d				 
9e4d			;    if same 
9e4d			;       scan for string terms 0 for token and 32 for input 
9e4d			 
9e4d				 
9e4d			if DEBUG_FORTH_PARSE_KEY 
9e4d						DMARK "KY8" 
9e4d			endif 
9e4d			 
9e4d 80				add b			 
9e4e fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9e50							; TODO need to make sure last word in zero term string is accounted for 
9e50 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9e52			 
9e52			 
9e52				; at end of both strings so both are exact match 
9e52			 
9e52			;       skip ptr for next word 
9e52			 
9e52 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
9e55 23				inc hl			 ; at next char 
9e56 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
9e59 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9e5c				 
9e5c				 
9e5c			if DEBUG_FORTH_PARSE_KEY 
9e5c						DMARK "KY3" 
9e5c			endif 
9e5c			 
9e5c			 
9e5c			 
9e5c			;       exec code block 
9e5c			if DEBUG_FORTH_JP 
9e5c				call clear_display 
9e5c				call update_display 
9e5c				call delay1s 
9e5c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e5c				ld a,h 
9e5c				ld hl, os_word_scratch 
9e5c				call hexout 
9e5c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e5c				ld a,l 
9e5c				ld hl, os_word_scratch+2 
9e5c				call hexout 
9e5c				ld hl, os_word_scratch+4 
9e5c				ld a,0 
9e5c				ld (hl),a 
9e5c				ld de,os_word_scratch 
9e5c				call str_at_display 
9e5c					ld a, display_row_2 
9e5c					call str_at_display 
9e5c				ld de, (cli_origtoken) 
9e5c				ld a, display_row_1+10 
9e5c					call str_at_display 
9e5c			 
9e5c				ld a,display_row_1 
9e5c				ld de, .foundword 
9e5c				ld a, display_row_3 
9e5c				call str_at_display 
9e5c				call update_display 
9e5c				call delay1s 
9e5c				call delay1s 
9e5c				call delay1s 
9e5c			endif 
9e5c			 
9e5c			if DEBUG_FORTH_PARSE_KEY 
9e5c						DMARK "KYj" 
9e5c			endif 
9e5c				; TODO save the word pointer in this exec 
9e5c			 
9e5c 2a 26 eb			ld hl,(cli_execword) 
9e5f e9				jp (hl) 
9e60			 
9e60			 
9e60			;    if not same 
9e60			;	scan for zero term 
9e60			;	get ptr for next word 
9e60			;	goto word comp 
9e60			 
9e60			.execpnskipword:	; get pointer to next word 
9e60 2a 24 eb			ld hl,(cli_nextword) 
9e63			 
9e63 7e				ld a,(hl) 
9e64 fe 00			cp WORD_SYS_END 
9e66			;	cp 0 
9e66 28 09			jr z, .execendofdict			 ; at end of words 
9e68			 
9e68			if DEBUG_FORTH_PARSE_KEY 
9e68						DMARK "KY4" 
9e68			endif 
9e68			if DEBUG_FORTH_PARSE_EXEC 
9e68			 
9e68				; see if disabled 
9e68			 
9e68				ld a, (os_view_disable) 
9e68				cp '*' 
9e68				jr z, .noskip 
9e68			 
9e68			 
9e68				ld de, .nowordfound 
9e68				ld a, display_row_3 
9e68				call str_at_display 
9e68				call update_display 
9e68				ld a, 100 
9e68				call aDelayInMS 
9e68				 
9e68				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e68					call delay250ms 
9e68				endif 
9e68			.noskip:  
9e68			 
9e68			endif	 
9e68			 
9e68 2a 20 eb			ld hl,(cli_origptr) 
9e6b 22 22 eb			ld (cli_ptr),hl 
9e6e			 
9e6e			if DEBUG_FORTH_PARSE_KEY 
9e6e						DMARK "KY5" 
9e6e			endif 
9e6e c3 14 9e			jp .execpnword			; else go to next word 
9e71			 
9e71			.execendofdict:  
9e71			 
9e71			if DEBUG_FORTH_PARSE_KEY 
9e71						DMARK "KYe" 
9e71			endif 
9e71			if DEBUG_FORTH_PARSE_EXEC 
9e71				; see if disabled 
9e71			 
9e71				ld a, (os_view_disable) 
9e71				cp '*' 
9e71				jr z, .ispskip 
9e71			 
9e71				call clear_display 
9e71				call update_display 
9e71				call delay1s 
9e71				ld de, (cli_origptr) 
9e71				ld a, display_row_1 
9e71				call str_at_display 
9e71				 
9e71				ld de, .enddict 
9e71				ld a, display_row_3 
9e71				call str_at_display 
9e71				call update_display 
9e71				ld a, 100 
9e71				call aDelayInMS 
9e71				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e71				call delay1s 
9e71				call delay1s 
9e71				call delay1s 
9e71				endif 
9e71			.ispskip:  
9e71				 
9e71			endif	 
9e71			 
9e71			 
9e71			 
9e71				; if the word is not a keyword then must be a literal so push it to stack 
9e71			 
9e71			; push token to stack to end of word 
9e71			 
9e71				STACKFRAME ON $1efe $2f9f 
9e71				if DEBUG_STACK_IMB 
9e71					if ON 
9e71						exx 
9e71						ld de, $1efe 
9e71						ld a, d 
9e71						ld hl, curframe 
9e71						call hexout 
9e71						ld a, e 
9e71						ld hl, curframe+2 
9e71						call hexout 
9e71						ld hl, $1efe 
9e71						push hl 
9e71						ld hl, $2f9f 
9e71						push hl 
9e71						exx 
9e71					endif 
9e71				endif 
9e71			endm 
# End of macro STACKFRAME
9e71			 
9e71 2a d8 e6		ld hl,(os_tok_ptr) 
9e74 cd 69 9b		call forth_apush 
9e77			 
9e77				STACKFRAMECHK ON $1efe $2f9f 
9e77				if DEBUG_STACK_IMB 
9e77					if ON 
9e77						exx 
9e77						ld hl, $2f9f 
9e77						pop de   ; $2f9f 
9e77						call cmp16 
9e77						jr nz, .spnosame 
9e77						ld hl, $1efe 
9e77						pop de   ; $1efe 
9e77						call cmp16 
9e77						jr z, .spfrsame 
9e77						.spnosame: call showsperror 
9e77						.spfrsame: nop 
9e77						exx 
9e77					endif 
9e77				endif 
9e77			endm 
# End of macro STACKFRAMECHK
9e77			 
9e77			execnext: 
9e77			 
9e77			if DEBUG_FORTH_PARSE_KEY 
9e77						DMARK "KY>" 
9e77			endif 
9e77			; move past token to next word 
9e77			 
9e77 2a d8 e6		ld hl, (os_tok_ptr) 
9e7a 3e 00		ld a, 0 
9e7c 01 ff 00		ld bc, 255     ; input buffer size 
9e7f ed b1		cpir 
9e81			 
9e81			if DEBUG_FORTH_PARSE_KEY 
9e81						DMARK "KY!" 
9e81				CALLMONITOR 
9e81			endif	 
9e81			; TODO this might place hl on the null, so will need to forward on??? 
9e81			;inc hl   ; see if this gets onto the next item 
9e81			 
9e81			 
9e81			; TODO pass a pointer to the buffer to push 
9e81			; TODO call function to push 
9e81			 
9e81			; look for end of input 
9e81			 
9e81			;inc hl 
9e81			;ld a,(hl) 
9e81			;cp FORTH_END_BUFFER 
9e81			;ret z 
9e81			 
9e81			 
9e81 c3 fa 9d		jp exec1 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			 
9e84			findnexttok: 
9e84			 
9e84				; hl is pointer to move 
9e84				; de is the token to locate 
9e84			 
9e84					if DEBUG_FORTH 
9e84						DMARK "NTK" 
9e84						CALLMONITOR 
9e84					endif 
9e84 d5				push de 
9e85			 
9e85			.fnt1:	 
9e85				; find first char of token to locate 
9e85			 
9e85 1a				ld a, (de) 
9e86 4f				ld c,a 
9e87 7e				ld a,(hl) 
9e88 cd e9 8f			call toUpper 
9e8b					if DEBUG_FORTH 
9e8b						DMARK "NT1" 
9e8b						CALLMONITOR 
9e8b					endif 
9e8b b9				cp c 
9e8c			 
9e8c 28 03			jr z, .fnt2cmpmorefirst	 
9e8e			 
9e8e				; first char not found move to next char 
9e8e			 
9e8e 23				inc hl 
9e8f 18 f4			jr .fnt1 
9e91			 
9e91			.fnt2cmpmorefirst:	 
9e91				; first char of token found.  
9e91			 
9e91 e5				push hl     ; save start of token just in case it is the right one 
9e92 d9				exx 
9e93 e1				pop hl        ; save it to hl' 
9e94 d9				exx 
9e95			 
9e95			 
9e95			.fnt2cmpmore:	 
9e95				; compare the rest 
9e95				 
9e95 23				inc hl 
9e96 13				inc de 
9e97				 
9e97 1a				ld a, (de) 
9e98 4f				ld c,a 
9e99 7e				ld a,(hl) 
9e9a cd e9 8f			call toUpper 
9e9d			 
9e9d					if DEBUG_FORTH 
9e9d						DMARK "NT2" 
9e9d						CALLMONITOR 
9e9d					endif 
9e9d				; c has the token to find char 
9e9d				; a has the mem to scan char 
9e9d			 
9e9d b9				cp c 
9e9e 28 04			jr z,.fntmatch1 
9ea0			 
9ea0				; they are not the same 
9ea0			 
9ea0					if DEBUG_FORTH 
9ea0						DMARK "NT3" 
9ea0						CALLMONITOR 
9ea0					endif 
9ea0 d1				pop de	; reset de token to look for 
9ea1 d5				push de 
9ea2 18 e1			jr .fnt1 
9ea4				 
9ea4			.fntmatch1: 
9ea4			 
9ea4				; is the same char a null which means we might have a full hit? 
9ea4					if DEBUG_FORTH 
9ea4						DMARK "NT4" 
9ea4						CALLMONITOR 
9ea4					endif 
9ea4			 
9ea4 fe 00			cp 0 
9ea6 28 0b			jr z, .fntmatchyes 
9ea8			 
9ea8				; are we at the end of the token to find? 
9ea8			 
9ea8					if DEBUG_FORTH 
9ea8						DMARK "NT5" 
9ea8						CALLMONITOR 
9ea8					endif 
9ea8 3e 00			ld a, 0 
9eaa b9				cp c 
9eab			 
9eab c2 95 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9eae			 
9eae					if DEBUG_FORTH 
9eae						DMARK "NT6" 
9eae						CALLMONITOR 
9eae					endif 
9eae				; token to find is exhusted but no match to stream 
9eae			 
9eae				; restore tok pointer and continue on 
9eae d1				pop de 
9eaf d5				push de 
9eb0 c3 85 9e			jp .fnt1 
9eb3			 
9eb3			 
9eb3			.fntmatchyes: 
9eb3			 
9eb3				; hl now contains the end of the found token 
9eb3			 
9eb3				; get rid of saved token pointer to find 
9eb3			 
9eb3 d1				pop de 
9eb4			 
9eb4					if DEBUG_FORTH 
9eb4						DMARK "NT9" 
9eb4						CALLMONITOR 
9eb4					endif 
9eb4			 
9eb4				; hl will be on the null term so forward on 
9eb4			 
9eb4				; get back the saved start of the token 
9eb4			 
9eb4 d9				exx 
9eb5 e5				push hl     ; save start of token just in case it is the right one 
9eb6 d9				exx 
9eb7 e1				pop hl        ; save it to hl 
9eb8			 
9eb8 c9				ret 
9eb9			 
9eb9			 
9eb9			; LIST needs to find a specific token   
9eb9			; FORGET needs to find a spefici token 
9eb9			 
9eb9			; SAVE needs to find all tokens by flag 
9eb9			; WORDS just needs to scan through all  by flag 
9eb9			; UWORDS needs to scan through all by flag 
9eb9			 
9eb9			 
9eb9			; given hl as pointer to start of dict look up string 
9eb9			; return hl as pointer to start of word block 
9eb9			; or 0 if not found 
9eb9			 
9eb9			forth_find_tok: 
9eb9 c9				ret 
9eba			 
9eba			; given hl as pointer to dict structure 
9eba			; move to the next dict block structure 
9eba			 
9eba			forth_tok_next: 
9eba				; hl now points to the address of the next word pointer  
9eba				; TODO skip compiled symbol for now 
9eba			;	push de 
9eba 23				inc hl 
9ebb 5e				ld e, (hl) 
9ebc 23				inc hl 
9ebd 56				ld d, (hl) 
9ebe 23				inc hl 
9ebf			 
9ebf eb				ex de,hl 
9ec0			if DEBUG_FORTH_PARSE_NEXTWORD 
9ec0				push bc 
9ec0				ld bc, (cli_nextword) 
9ec0						DMARK "NXW" 
9ec0				CALLMONITOR 
9ec0				pop bc 
9ec0			endif 
9ec0			;	pop de	 
9ec0 c9				ret 
9ec1			 
9ec1			 
9ec1			 
9ec1			; eof 
# End of file forth_parserv5.asm
9ec1				include "forth_wordsv4.asm" 
9ec1			 
9ec1			; the core word dictionary v4 
9ec1			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9ec1			 
9ec1			; this is a linked list for each of the system words used 
9ec1			; user defined words will follow the same format but will be in ram 
9ec1			 
9ec1			 
9ec1			; 
9ec1			; 
9ec1			; define linked list: 
9ec1			; 
9ec1			; 1. compiled byte op code 
9ec1			; 2. len of text word 
9ec1			; 3. text word 
9ec1			; 4. ptr to next dictionary word 
9ec1			; 5. asm, calls etc for the word 
9ec1			; 
9ec1			;  if 1 == 0 then last word in dict  
9ec1			;   
9ec1			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9ec1			;  
9ec1			;  
9ec1			; create basic standard set of words 
9ec1			; 
9ec1			;  
9ec1			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9ec1			; 2DUP 2DROP 2SWAP  
9ec1			; @ C@ - get byte  
9ec1			; ! C! - store byte 
9ec1			; 0< true if less than zero 
9ec1			; 0= true if zero 
9ec1			; < >  
9ec1			; = true if same 
9ec1			; variables 
9ec1			 
9ec1			 
9ec1			; Hardware specific words I may need 
9ec1			; 
9ec1			; IN OUT  
9ec1			; calls to key util functions 
9ec1			; calls to hardward abstraction stuff 
9ec1			; easy control of frame buffers and lcd i/o 
9ec1			; keyboard  
9ec1			 
9ec1			 
9ec1			;DICT: macro 
9ec1			; op_code, len, word, next 
9ec1			;    word: 
9ec1			;    db op_code 
9ec1			;    ds word zero term 
9ec1			;    dw next 
9ec1			;    endm 
9ec1			 
9ec1			 
9ec1			 
9ec1			 
9ec1			; op code 1 is a flag for user define words which are to be handled differently 
9ec1			 
9ec1			 
9ec1			; 
9ec1			; 
9ec1			;    TODO on entry to a word this should be the expected environment 
9ec1			;    hl - tos value if number then held, if string this is the ptr 
9ec1			;    de -  
9ec1			 
9ec1			 
9ec1			; opcode ranges 
9ec1			; 0 - end of word dict 
9ec1			; 255 - user define words 
9ec1			 
9ec1			sysdict: 
9ec1			include "forth_opcodes.asm" 
9ec1			; op codes for forth keywords 
9ec1			; free to use code 0  
9ec1				OPCODE_HEAP: equ  1 
9ec1				OPCODE_EXEC: equ 2 
9ec1				OPCODE_DUP: equ 3 
9ec1				OPCODE_SWAP: equ 4 
9ec1				OPCODE_COLN: equ 5 
9ec1				OPCODE_SCOLN: equ 6 
9ec1				OPCODE_DROP: equ 7 
9ec1				OPCODE_DUP2: equ 8 
9ec1				OPCODE_DROP2: equ 9 
9ec1				OPCODE_SWAP2: equ 10 
9ec1				OPCODE_AT: equ 11 
9ec1				OPCODE_CAT: equ 12 
9ec1				OPCODE_BANG: equ 13 
9ec1				OPCODE_CBANG: equ 14 
9ec1				OPCODE_SCALL: equ 15 
9ec1				OPCODE_DEPTH: equ 16 
9ec1				OPCODE_OVER: equ 17 
9ec1				OPCODE_PAUSE: equ 18 
9ec1				OPCODE_PAUSES: equ 19 
9ec1				OPCODE_ROT: equ 20 
9ec1			;free to reuse	OPCODE_WORDS: equ 21 
9ec1			        OPCODE_NOT: equ 21 
9ec1				OPCODE_UWORDS: equ 22 
9ec1				OPCODE_BP: equ 23 
9ec1				OPCODE_MONITOR: equ 24  
9ec1				OPCODE_MALLOC: equ 25 
9ec1				OPCODE_FREE: equ 26 
9ec1				OPCODE_LIST: equ 27 
9ec1				OPCODE_FORGET: equ 28 
9ec1				OPCODE_NOP: equ 29 
9ec1				OPCODE_COMO: equ 30 
9ec1				OPCODE_COMC: equ 31 
9ec1			;free to reuse	OPCODE_ENDCORE: equ 32 
9ec1				OPCODE_AFTERSOUND: equ 33 
9ec1				OPCODE_GP2: equ 34 
9ec1				OPCODE_GP3: equ 35 
9ec1				OPCODE_GP4: equ 36 
9ec1				OPCODE_SIN: equ 37 
9ec1				OPCODE_SOUT: equ 38 
9ec1				OPCODE_SPIO: equ 39 
9ec1				OPCODE_SPICEH: equ 40 
9ec1				OPCODE_SPIOb: equ 41 
9ec1				OPCODE_SPII: equ 42 
9ec1				OPCODE_SESEL: equ 43 
9ec1				OPCODE_CARTDEV: equ 44 
9ec1			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9ec1				OPCODE_FB: equ 46 
9ec1				OPCODE_EMIT: equ 47 
9ec1				OPCODE_DOTH: equ 48 
9ec1				OPCODE_DOTF: equ 49 
9ec1				OPCODE_DOT: equ 50 
9ec1				OPCODE_CLS: equ 51 
9ec1				OPCODE_DRAW: equ 52 
9ec1				OPCODE_DUMP: equ 53 
9ec1				OPCODE_CDUMP: equ 54 
9ec1				OPCODE_DAT: equ 55 
9ec1				OPCODE_HOME: equ 56 
9ec1				OPCODE_SPACE: equ 57 
9ec1				OPCODE_SPACES: equ 58 
9ec1				OPCODE_SCROLL: equ 59 
9ec1				OPCODE_ATQ: equ 60 
9ec1				OPCODE_AUTODSP: equ 61 
9ec1				OPCODE_MENU: equ 62 
9ec1			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9ec1				OPCODE_THEN: equ 64 
9ec1				OPCODE_ELSE: equ 65 
9ec1				OPCODE_DO: equ 66 
9ec1				OPCODE_LOOP: equ 67 
9ec1				OPCODE_I: equ 68 
9ec1				OPCODE_DLOOP: equ 69  
9ec1				OPCODE_REPEAT: equ 70  
9ec1				OPCODE_UNTIL: equ 71 
9ec1				OPCODE_ENDFLOW: equ 72 
9ec1				OPCODE_WAITK: equ 73 
9ec1				OPCODE_ACCEPT: equ 74 
9ec1				OPCODE_EDIT: equ 75 
9ec1			;free to reuse	OPCODE_ENDKEY: equ 76 
9ec1				OPCODE_LZERO: equ 77 
9ec1				OPCODE_TZERO: equ 78 
9ec1				OPCODE_LESS: equ 79 
9ec1				OPCODE_GT: equ 80 
9ec1				OPCODE_EQUAL: equ 81  
9ec1			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9ec1				OPCODE_NEG: equ 83 
9ec1				OPCODE_DIV: equ 84 
9ec1				OPCODE_MUL: equ 85 
9ec1				OPCODE_MIN: equ 86 
9ec1				OPCODE_MAX: equ 87 
9ec1				OPCODE_RND16: equ 88 
9ec1				OPCODE_RND8: equ 89 
9ec1				OPCODE_RND: equ 90 
9ec1			;free to reuse	OPCODE_ENDMATHS: equ 91  
9ec1				OPCODE_BYNAME: equ 92 
9ec1				OPCODE_DIR: equ 93 
9ec1				OPCODE_SAVE: equ 94 
9ec1				OPCODE_LOAD: equ 95 
9ec1				OPCODE_BSAVE: equ 96 
9ec1				OPCODE_BLOAD: equ 97 
9ec1				OPCODE_SEO: equ 98  
9ec1				OPCODE_SEI: equ 99 
9ec1				OPCODE_SFREE: equ 100 
9ec1				OPCODE_SIZE: equ 101 
9ec1				OPCODE_CREATE: equ 102 
9ec1				OPCODE_APPEND: equ 103 
9ec1				OPCODE_SDEL: equ 104 
9ec1				OPCODE_OPEN: equ 105 
9ec1				OPCODE_READ: equ 106 
9ec1				OPCODE_EOF: equ 106 
9ec1				OPCODE_FORMAT: equ 107 
9ec1				OPCODE_LABEL: equ 108 
9ec1				OPCODE_LABELS: equ 109 
9ec1			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9ec1				OPCODE_UPPER: equ 111 
9ec1				OPCODE_LOWER: equ 112 
9ec1				OPCODE_SUBSTR: equ 113 
9ec1				OPCODE_LEFT: equ 114 
9ec1				OPCODE_RIGHT: equ 115 
9ec1				OPCODE_STR2NUM: equ 116 
9ec1				OPCODE_NUM2STR: equ 117 
9ec1				OPCODE_CONCAT: equ 118 
9ec1				OPCODE_FIND: equ 119 
9ec1				OPCODE_LEN: equ 120 
9ec1				OPCODE_CHAR: equ 121 
9ec1			; free to reuse	OPCODE_STRLEN: equ 122 
9ec1			; free to reuse	OPCODE_ENDSTR: equ 123 
9ec1				OPCODE_V0S: equ 124 
9ec1				OPCODE_V0Q: equ 125 
9ec1				OPCODE_V1S: equ 126 
9ec1				OPCODE_V1Q: equ 127 
9ec1				OPCODE_V2S: equ 128 
9ec1				OPCODE_V2Q: equ 129 
9ec1				OPCODE_V3S: equ 130 
9ec1				OPCODE_V3Q: equ 131 
9ec1			;free to reuse	OPCODE_END: equ 132 
9ec1				OPCODE_ZDUP: equ 133 
9ec1			 
9ec1			; eof 
# End of file forth_opcodes.asm
9ec1			 
9ec1			include "forth_words_core.asm" 
9ec1			 
9ec1			; | ## Core Words 
9ec1			 
9ec1			;if MALLOC_4 
9ec1			 
9ec1			.HEAP: 
9ec1				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9ec1 15				db WORD_SYS_CORE+OPCODE_HEAP             
9ec2 00 9f			dw .EXEC            
9ec4 05				db 4 + 1 
9ec5 .. 00			db "HEAP",0              
9eca				endm 
# End of macro CWHEAD
9eca			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9eca			; | | u1 - Current number of bytes in the heap 
9eca			; | | u2 - Remaining bytes left on the heap 
9eca			; | |  
9eca			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9eca			 
9eca			 
9eca					if DEBUG_FORTH_WORDS_KEY 
9eca						DMARK "HEP" 
9eca f5				push af  
9ecb 3a df 9e			ld a, (.dmark)  
9ece 32 71 ee			ld (debug_mark),a  
9ed1 3a e0 9e			ld a, (.dmark+1)  
9ed4 32 72 ee			ld (debug_mark+1),a  
9ed7 3a e1 9e			ld a, (.dmark+2)  
9eda 32 73 ee			ld (debug_mark+2),a  
9edd 18 03			jr .pastdmark  
9edf ..			.dmark: db "HEP"  
9ee2 f1			.pastdmark: pop af  
9ee3			endm  
# End of macro DMARK
9ee3						CALLMONITOR 
9ee3 cd 95 93			call break_point_state  
9ee6				endm  
# End of macro CALLMONITOR
9ee6					endif 
9ee6 2a 1f d9				ld hl, (free_list )      
9ee9 11 24 d9				ld de, heap_start 
9eec			 
9eec ed 52				sbc hl, de  
9eee			 
9eee cd 00 9a				call forth_push_numhl 
9ef1			 
9ef1			 
9ef1 ed 5b 1f d9			ld de, (free_list )      
9ef5 21 bd e3				ld hl, heap_end 
9ef8			 
9ef8 ed 52				sbc hl, de 
9efa			 
9efa cd 00 9a				call forth_push_numhl 
9efd					 
9efd			 
9efd					 
9efd			 
9efd			 
9efd			 
9efd					NEXTW 
9efd c3 69 9d			jp macro_next 
9f00				endm 
# End of macro NEXTW
9f00			;endif 
9f00			 
9f00			.EXEC: 
9f00			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9f00			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9f00			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9f00			;; > > 
9f00			;; > >   
9f00			;	STACKFRAME OFF $5efe $5f9f 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS_KEY 
9f00			;			DMARK "EXE" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			;	FORTH_DSP_VALUEHL 
9f00			; 
9f00			;	FORTH_DSP_POP 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX1" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;;	ld e,(hl) 
9f00			;;	inc hl 
9f00			;;	ld d,(hl) 
9f00			;;	ex de,hl 
9f00			; 
9f00			;;		if DEBUG_FORTH_WORDS 
9f00			;;			DMARK "EX2" 
9f00			;;			CALLMONITOR 
9f00			;;		endif 
9f00			;	push hl 
9f00			; 
9f00			;	;ld a, 0 
9f00			;	;ld a, FORTH_END_BUFFER 
9f00			;	call strlenz 
9f00			;	inc hl   ; include zero term to copy 
9f00			;	inc hl   ; include term 
9f00			;	inc hl   ; include term 
9f00			;	ld b,0 
9f00			;	ld c,l 
9f00			;	pop hl 
9f00			;	ld de, execscratch 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX3" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	ldir 
9f00			; 
9f00			; 
9f00			;	ld hl, execscratch 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EXe" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			;	call forthparse 
9f00			;	call forthexec 
9f00			;;	call forthexec_cleanup 
9f00			;;	call forthparse 
9f00			;;	call forthexec 
9f00			; 
9f00			;	STACKFRAMECHK OFF $5efe $5f9f 
9f00			; 
9f00			;	; an immediate word so no need to process any more words 
9f00			;	ret 
9f00			;	NEXTW 
9f00			 
9f00			; dead code - old version  
9f00			;	FORTH_RSP_NEXT 
9f00			 
9f00			;  
9f00			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f00			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f00			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f00			;	push hl 
9f00			;	push de 
9f00			;	push bc 
9f00			; 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS_KEY 
9f00			;			DMARK "EXR" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			; 
9f00			; 
9f00			;	;v5 FORTH_DSP_VALUE 
9f00			;	FORTH_DSP_VALUEHL 
9f00			; 
9f00			;	; TODO do string type checks 
9f00			; 
9f00			;;v5	inc hl   ; skip type 
9f00			; 
9f00			;	push hl  ; source code  
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX1" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	ld a, 0 
9f00			;	call strlent 
9f00			; 
9f00			;	inc hl 
9f00			;	inc hl 
9f00			;	inc hl 
9f00			;	inc hl 
9f00			; 
9f00			;	push hl    ; size 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX2" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	call malloc 
9f00			; 
9f00			;	ex de, hl    ; de now contains malloc area 
9f00			;	pop bc   	; get byte count 
9f00			;	pop hl      ; get string to copy 
9f00			; 
9f00			;	push de     ; save malloc for free later 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX3" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	ldir       ; duplicate string 
9f00			; 
9f00			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9f00			;	 
9f00			;	; TODO fix the parse would be better than this...  
9f00			;	ex de, hl 
9f00			;	dec hl 
9f00			;	ld a, 0 
9f00			;	ld (hl), a 
9f00			;	dec hl 
9f00			;	ld a, ' ' 
9f00			;	ld (hl), a 
9f00			;	dec hl 
9f00			;	ld (hl), a 
9f00			; 
9f00			;	dec hl 
9f00			;	ld (hl), a 
9f00			; 
9f00			; 
9f00			;	FORTH_DSP_POP  
9f00			; 
9f00			;	pop hl     
9f00			;	push hl    ; save malloc area 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX4" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			;	call forthparse 
9f00			;	call forthexec 
9f00			;	 
9f00			;	pop hl 
9f00			;	if DEBUG_FORTH_WORDS 
9f00			;		DMARK "EX5" 
9f00			;		CALLMONITOR 
9f00			;	endif 
9f00			; 
9f00			;	if FORTH_ENABLE_FREE 
9f00			;	call free 
9f00			;	endif 
9f00			; 
9f00			;	if DEBUG_FORTH_WORDS 
9f00			;		DMARK "EX6" 
9f00			;		CALLMONITOR 
9f00			;	endif 
9f00			; 
9f00			;	pop bc 
9f00			;	pop de 
9f00			;	pop hl 
9f00			;;	FORTH_RSP_POP	  
9f00			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9f00			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9f00			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9f00			; 
9f00			;	if DEBUG_FORTH_WORDS 
9f00			;		DMARK "EX7" 
9f00			;		CALLMONITOR 
9f00			;	endif 
9f00			;	NEXTW 
9f00			 
9f00			;.STKEXEC: 
9f00			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9f00			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9f00			; 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS_KEY 
9f00			;			DMARK "STX" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			;	FORTH_DSP_VALUEHL 
9f00			; 
9f00			;	ld (store_tmp1), hl    ; count 
9f00			; 
9f00			;	FORTH_DSP_POP 
9f00			;.stkexec1: 
9f00			;	ld hl, (store_tmp1)   ; count 
9f00			;	ld a, 0 
9f00			;	cp l 
9f00			;	ret z 
9f00			; 
9f00			;	dec hl 
9f00			;	ld (store_tmp1), hl    ; count 
9f00			;	 
9f00			;	FORTH_DSP_VALUEHL 
9f00			;	push hl 
9f00			;	 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EXp" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	FORTH_DSP_POP 
9f00			; 
9f00			;	call strlenz 
9f00			;	inc hl   ; include zero term to copy 
9f00			;	inc hl   ; include zero term to copy 
9f00			;	inc hl   ; include zero term to copy 
9f00			;	ld b,0 
9f00			;	ld c,l 
9f00			;	pop hl 
9f00			;	ld de, execscratch 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EX3" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	ldir 
9f00			; 
9f00			; 
9f00			;	ld hl, execscratch 
9f00			; 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EXP" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			; 
9f00			;	call forthparse 
9f00			;	ld hl, execscratch 
9f00			;		if DEBUG_FORTH_WORDS 
9f00			;			DMARK "EXx" 
9f00			;			CALLMONITOR 
9f00			;		endif 
9f00			;	call forthexec 
9f00			; 
9f00			;	jp .stkexec1 
9f00			; 
9f00			;	ret 
9f00			 
9f00			 
9f00			.DUP: 
9f00				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9f00 17				db WORD_SYS_CORE+OPCODE_DUP             
9f01 76 9f			dw .ZDUP            
9f03 04				db 3 + 1 
9f04 .. 00			db "DUP",0              
9f08				endm 
# End of macro CWHEAD
9f08			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f08			 
9f08					if DEBUG_FORTH_WORDS_KEY 
9f08						DMARK "DUP" 
9f08 f5				push af  
9f09 3a 1d 9f			ld a, (.dmark)  
9f0c 32 71 ee			ld (debug_mark),a  
9f0f 3a 1e 9f			ld a, (.dmark+1)  
9f12 32 72 ee			ld (debug_mark+1),a  
9f15 3a 1f 9f			ld a, (.dmark+2)  
9f18 32 73 ee			ld (debug_mark+2),a  
9f1b 18 03			jr .pastdmark  
9f1d ..			.dmark: db "DUP"  
9f20 f1			.pastdmark: pop af  
9f21			endm  
# End of macro DMARK
9f21						CALLMONITOR 
9f21 cd 95 93			call break_point_state  
9f24				endm  
# End of macro CALLMONITOR
9f24					endif 
9f24			 
9f24					FORTH_DSP 
9f24 cd bd 9b			call macro_forth_dsp 
9f27				endm 
# End of macro FORTH_DSP
9f27			 
9f27 7e					ld a, (HL) 
9f28 fe 01				cp DS_TYPE_STR 
9f2a 20 25				jr nz, .dupinum 
9f2c			 
9f2c					; push another string 
9f2c			 
9f2c					FORTH_DSP_VALUEHL     		 
9f2c cd f7 9b			call macro_dsp_valuehl 
9f2f				endm 
# End of macro FORTH_DSP_VALUEHL
9f2f			 
9f2f				if DEBUG_FORTH_WORDS 
9f2f					DMARK "DUs" 
9f2f f5				push af  
9f30 3a 44 9f			ld a, (.dmark)  
9f33 32 71 ee			ld (debug_mark),a  
9f36 3a 45 9f			ld a, (.dmark+1)  
9f39 32 72 ee			ld (debug_mark+1),a  
9f3c 3a 46 9f			ld a, (.dmark+2)  
9f3f 32 73 ee			ld (debug_mark+2),a  
9f42 18 03			jr .pastdmark  
9f44 ..			.dmark: db "DUs"  
9f47 f1			.pastdmark: pop af  
9f48			endm  
# End of macro DMARK
9f48					CALLMONITOR 
9f48 cd 95 93			call break_point_state  
9f4b				endm  
# End of macro CALLMONITOR
9f4b				endif 
9f4b cd 6e 9a				call forth_push_str 
9f4e			 
9f4e					NEXTW 
9f4e c3 69 9d			jp macro_next 
9f51				endm 
# End of macro NEXTW
9f51			 
9f51			 
9f51			.dupinum: 
9f51					 
9f51			 
9f51			 
9f51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f51 cd f7 9b			call macro_dsp_valuehl 
9f54				endm 
# End of macro FORTH_DSP_VALUEHL
9f54			 
9f54				; TODO add floating point number detection 
9f54			 
9f54				if DEBUG_FORTH_WORDS 
9f54					DMARK "DUi" 
9f54 f5				push af  
9f55 3a 69 9f			ld a, (.dmark)  
9f58 32 71 ee			ld (debug_mark),a  
9f5b 3a 6a 9f			ld a, (.dmark+1)  
9f5e 32 72 ee			ld (debug_mark+1),a  
9f61 3a 6b 9f			ld a, (.dmark+2)  
9f64 32 73 ee			ld (debug_mark+2),a  
9f67 18 03			jr .pastdmark  
9f69 ..			.dmark: db "DUi"  
9f6c f1			.pastdmark: pop af  
9f6d			endm  
# End of macro DMARK
9f6d					CALLMONITOR 
9f6d cd 95 93			call break_point_state  
9f70				endm  
# End of macro CALLMONITOR
9f70				endif 
9f70			 
9f70 cd 00 9a				call forth_push_numhl 
9f73					NEXTW 
9f73 c3 69 9d			jp macro_next 
9f76				endm 
# End of macro NEXTW
9f76			.ZDUP: 
9f76				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9f76 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9f77 ae 9f			dw .SWAP            
9f79 05				db 4 + 1 
9f7a .. 00			db "?DUP",0              
9f7f				endm 
# End of macro CWHEAD
9f7f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9f7f			 
9f7f					if DEBUG_FORTH_WORDS_KEY 
9f7f						DMARK "qDU" 
9f7f f5				push af  
9f80 3a 94 9f			ld a, (.dmark)  
9f83 32 71 ee			ld (debug_mark),a  
9f86 3a 95 9f			ld a, (.dmark+1)  
9f89 32 72 ee			ld (debug_mark+1),a  
9f8c 3a 96 9f			ld a, (.dmark+2)  
9f8f 32 73 ee			ld (debug_mark+2),a  
9f92 18 03			jr .pastdmark  
9f94 ..			.dmark: db "qDU"  
9f97 f1			.pastdmark: pop af  
9f98			endm  
# End of macro DMARK
9f98						CALLMONITOR 
9f98 cd 95 93			call break_point_state  
9f9b				endm  
# End of macro CALLMONITOR
9f9b					endif 
9f9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f9b cd f7 9b			call macro_dsp_valuehl 
9f9e				endm 
# End of macro FORTH_DSP_VALUEHL
9f9e			 
9f9e e5					push hl 
9f9f			 
9f9f					; is it a zero? 
9f9f			 
9f9f 3e 00				ld a, 0 
9fa1 84					add h 
9fa2 85					add l 
9fa3			 
9fa3 e1					pop hl 
9fa4			 
9fa4 fe 00				cp 0 
9fa6 28 03				jr z, .dup2orig 
9fa8			 
9fa8			 
9fa8 cd 00 9a				call forth_push_numhl 
9fab			 
9fab			 
9fab				; TODO add floating point number detection 
9fab			 
9fab			.dup2orig: 
9fab			 
9fab					NEXTW 
9fab c3 69 9d			jp macro_next 
9fae				endm 
# End of macro NEXTW
9fae			.SWAP: 
9fae				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9fae 18				db WORD_SYS_CORE+OPCODE_SWAP             
9faf ed 9f			dw .COLN            
9fb1 05				db 4 + 1 
9fb2 .. 00			db "SWAP",0              
9fb7				endm 
# End of macro CWHEAD
9fb7			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9fb7					if DEBUG_FORTH_WORDS_KEY 
9fb7						DMARK "SWP" 
9fb7 f5				push af  
9fb8 3a cc 9f			ld a, (.dmark)  
9fbb 32 71 ee			ld (debug_mark),a  
9fbe 3a cd 9f			ld a, (.dmark+1)  
9fc1 32 72 ee			ld (debug_mark+1),a  
9fc4 3a ce 9f			ld a, (.dmark+2)  
9fc7 32 73 ee			ld (debug_mark+2),a  
9fca 18 03			jr .pastdmark  
9fcc ..			.dmark: db "SWP"  
9fcf f1			.pastdmark: pop af  
9fd0			endm  
# End of macro DMARK
9fd0						CALLMONITOR 
9fd0 cd 95 93			call break_point_state  
9fd3				endm  
# End of macro CALLMONITOR
9fd3					endif 
9fd3			 
9fd3					FORTH_DSP_VALUEHL 
9fd3 cd f7 9b			call macro_dsp_valuehl 
9fd6				endm 
# End of macro FORTH_DSP_VALUEHL
9fd6 e5					push hl     ; w2 
9fd7			 
9fd7					FORTH_DSP_POP 
9fd7 cd af 9c			call macro_forth_dsp_pop 
9fda				endm 
# End of macro FORTH_DSP_POP
9fda			 
9fda					FORTH_DSP_VALUEHL 
9fda cd f7 9b			call macro_dsp_valuehl 
9fdd				endm 
# End of macro FORTH_DSP_VALUEHL
9fdd			 
9fdd					FORTH_DSP_POP 
9fdd cd af 9c			call macro_forth_dsp_pop 
9fe0				endm 
# End of macro FORTH_DSP_POP
9fe0			 
9fe0 d1					pop de     ; w2	, hl = w1 
9fe1			 
9fe1 eb					ex de, hl 
9fe2 d5					push de 
9fe3			 
9fe3 cd 00 9a				call forth_push_numhl 
9fe6			 
9fe6 e1					pop hl 
9fe7			 
9fe7 cd 00 9a				call forth_push_numhl 
9fea					 
9fea			 
9fea					NEXTW 
9fea c3 69 9d			jp macro_next 
9fed				endm 
# End of macro NEXTW
9fed			.COLN: 
9fed				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9fed 19				db WORD_SYS_CORE+OPCODE_COLN             
9fee 79 a1			dw .SCOLN            
9ff0 02				db 1 + 1 
9ff1 .. 00			db ":",0              
9ff3				endm 
# End of macro CWHEAD
9ff3			; | : ( -- )         Create new word | DONE 
9ff3			 
9ff3					if DEBUG_FORTH_WORDS_KEY 
9ff3						DMARK "CLN" 
9ff3 f5				push af  
9ff4 3a 08 a0			ld a, (.dmark)  
9ff7 32 71 ee			ld (debug_mark),a  
9ffa 3a 09 a0			ld a, (.dmark+1)  
9ffd 32 72 ee			ld (debug_mark+1),a  
a000 3a 0a a0			ld a, (.dmark+2)  
a003 32 73 ee			ld (debug_mark+2),a  
a006 18 03			jr .pastdmark  
a008 ..			.dmark: db "CLN"  
a00b f1			.pastdmark: pop af  
a00c			endm  
# End of macro DMARK
a00c						CALLMONITOR 
a00c cd 95 93			call break_point_state  
a00f				endm  
# End of macro CALLMONITOR
a00f					endif 
a00f				STACKFRAME OFF $8efe $989f 
a00f				if DEBUG_STACK_IMB 
a00f					if OFF 
a00f						exx 
a00f						ld de, $8efe 
a00f						ld a, d 
a00f						ld hl, curframe 
a00f						call hexout 
a00f						ld a, e 
a00f						ld hl, curframe+2 
a00f						call hexout 
a00f						ld hl, $8efe 
a00f						push hl 
a00f						ld hl, $989f 
a00f						push hl 
a00f						exx 
a00f					endif 
a00f				endif 
a00f			endm 
# End of macro STACKFRAME
a00f				; get parser buffer length  of new word 
a00f			 
a00f				 
a00f			 
a00f					; move tok past this to start of name defintition 
a00f					; TODO get word to define 
a00f					; TODO Move past word token 
a00f					; TODO get length of string up to the ';' 
a00f			 
a00f 2a d8 e6			ld hl, (os_tok_ptr) 
a012 23				inc hl 
a013 23				inc hl 
a014			 
a014 3e 3b			ld a, ';' 
a016 cd fd 8f			call strlent 
a019			 
a019 7d				ld a,l 
a01a 32 d3 e3			ld (os_new_parse_len), a 
a01d			 
a01d			 
a01d			if DEBUG_FORTH_UWORD 
a01d ed 5b d8 e6		ld de, (os_tok_ptr) 
a021						DMARK ":01" 
a021 f5				push af  
a022 3a 36 a0			ld a, (.dmark)  
a025 32 71 ee			ld (debug_mark),a  
a028 3a 37 a0			ld a, (.dmark+1)  
a02b 32 72 ee			ld (debug_mark+1),a  
a02e 3a 38 a0			ld a, (.dmark+2)  
a031 32 73 ee			ld (debug_mark+2),a  
a034 18 03			jr .pastdmark  
a036 ..			.dmark: db ":01"  
a039 f1			.pastdmark: pop af  
a03a			endm  
# End of macro DMARK
a03a				CALLMONITOR 
a03a cd 95 93			call break_point_state  
a03d				endm  
# End of macro CALLMONITOR
a03d			endif 
a03d			 
a03d			; 
a03d			;  new word memory layout: 
a03d			;  
a03d			;    : adg 6666 ;  
a03d			; 
a03d			;    db   1     ; user defined word  
a03d 23				inc hl    
a03e			;    dw   sysdict 
a03e 23				inc hl 
a03f 23				inc hl 
a040			;    db <word len>+1 (for null) 
a040 23				inc hl 
a041			;    db .... <word> 
a041			; 
a041			 
a041 23				inc hl    ; some extras for the word preamble before the above 
a042 23				inc hl 
a043 23				inc hl 
a044 23				inc hl 
a045 23				inc hl 
a046 23				inc hl 
a047 23				inc hl  
a048 23				inc hl 
a049 23				inc hl 
a04a 23				inc hl 
a04b 23				inc hl 
a04c 23				inc hl 
a04d 23				inc hl 
a04e 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a04f			;       exec word buffer 
a04f			;	<ptr word>   
a04f 23				inc hl 
a050 23				inc hl 
a051			;       <word list><null term> 7F final term 
a051			 
a051			 
a051			if DEBUG_FORTH_UWORD 
a051						DMARK ":02" 
a051 f5				push af  
a052 3a 66 a0			ld a, (.dmark)  
a055 32 71 ee			ld (debug_mark),a  
a058 3a 67 a0			ld a, (.dmark+1)  
a05b 32 72 ee			ld (debug_mark+1),a  
a05e 3a 68 a0			ld a, (.dmark+2)  
a061 32 73 ee			ld (debug_mark+2),a  
a064 18 03			jr .pastdmark  
a066 ..			.dmark: db ":02"  
a069 f1			.pastdmark: pop af  
a06a			endm  
# End of macro DMARK
a06a				CALLMONITOR 
a06a cd 95 93			call break_point_state  
a06d				endm  
# End of macro CALLMONITOR
a06d			endif 
a06d			 
a06d				 
a06d					; malloc the size 
a06d			 
a06d cd 5b 90				call malloc 
a070 22 d5 e3				ld (os_new_malloc), hl     ; save malloc start 
a073			 
a073			;    db   1     ; user defined word  
a073 3e 01				ld a, WORD_SYS_UWORD  
a075 77					ld (hl), a 
a076				 
a076 23				inc hl    
a077			;    dw   sysdict 
a077 11 c1 9e			ld de, sysdict       ; continue on with the scan to the system dict 
a07a 73				ld (hl), e 
a07b 23				inc hl 
a07c 72				ld (hl), d 
a07d 23				inc hl 
a07e			 
a07e			 
a07e			;    Setup dict word 
a07e			 
a07e 23				inc hl 
a07f 22 cf e3			ld (os_new_work_ptr), hl     ; save start of dict word  
a082			 
a082				; 1. get length of dict word 
a082			 
a082			 
a082 2a d8 e6			ld hl, (os_tok_ptr) 
a085 23				inc hl 
a086 23				inc hl    ; position to start of dict word 
a087 3e 00			ld a, 0 
a089 cd fd 8f			call strlent 
a08c			 
a08c			 
a08c 23				inc hl    ; to include null??? 
a08d			 
a08d				; write length of dict word 
a08d			 
a08d ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a091 1b				dec de 
a092 eb				ex de, hl 
a093 73				ld (hl), e 
a094 eb				ex de, hl 
a095			 
a095				 
a095			 
a095				; copy  
a095 4d				ld c, l 
a096 06 00			ld b, 0 
a098 ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a09c 2a d8 e6			ld hl, (os_tok_ptr) 
a09f 23				inc hl 
a0a0 23				inc hl    ; position to start of dict word 
a0a1				 
a0a1			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a0a1				 
a0a1				; TODO need to convert word to upper case 
a0a1			 
a0a1			ucasetok:	 
a0a1 7e				ld a,(hl) 
a0a2 cd e9 8f			call toUpper 
a0a5 77				ld (hl),a 
a0a6 ed a0			ldi 
a0a8 f2 a1 a0		 	jp p, ucasetok 
a0ab			 
a0ab			 
a0ab			 
a0ab				; de now points to start of where the word body code should be placed 
a0ab ed 53 cf e3		ld (os_new_work_ptr), de 
a0af				; hl now points to the words to throw at forthexec which needs to be copied 
a0af 22 cd e3			ld (os_new_src_ptr), hl 
a0b2			 
a0b2				; TODO add 'call to forthexec' 
a0b2			 
a0b2			if DEBUG_FORTH_UWORD 
a0b2 c5				push bc 
a0b3 ed 4b d5 e3		ld bc, (os_new_malloc) 
a0b7						DMARK ":0x" 
a0b7 f5				push af  
a0b8 3a cc a0			ld a, (.dmark)  
a0bb 32 71 ee			ld (debug_mark),a  
a0be 3a cd a0			ld a, (.dmark+1)  
a0c1 32 72 ee			ld (debug_mark+1),a  
a0c4 3a ce a0			ld a, (.dmark+2)  
a0c7 32 73 ee			ld (debug_mark+2),a  
a0ca 18 03			jr .pastdmark  
a0cc ..			.dmark: db ":0x"  
a0cf f1			.pastdmark: pop af  
a0d0			endm  
# End of macro DMARK
a0d0				CALLMONITOR 
a0d0 cd 95 93			call break_point_state  
a0d3				endm  
# End of macro CALLMONITOR
a0d3 c1				pop bc 
a0d4			endif 
a0d4			 
a0d4			 
a0d4				; create word preamble which should be: 
a0d4			 
a0d4			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a0d4			 
a0d4				;    ld hl, <word code> 
a0d4				;    jp user_exec 
a0d4			        ;    <word code bytes> 
a0d4			 
a0d4			 
a0d4			;	inc de     ; TODO ??? or are we already past the word's null 
a0d4 eb				ex de, hl 
a0d5			 
a0d5 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a0d7			 
a0d7 23				inc hl 
a0d8 22 c9 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a0db 23				inc hl 
a0dc			 
a0dc 23				inc hl 
a0dd 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a0df			 
a0df 01 c9 c4			ld bc, user_exec 
a0e2 23				inc hl 
a0e3 71				ld (hl), c     ; poke address of user_exec 
a0e4 23				inc hl 
a0e5 70				ld (hl), b     
a0e6			 ; 
a0e6			;	inc hl 
a0e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0e6			; 
a0e6			; 
a0e6			;	ld bc, macro_forth_rsp_next 
a0e6			;	inc hl 
a0e6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a0e6			;	inc hl 
a0e6			;	ld (hl), b     
a0e6			 ; 
a0e6			;	inc hl 
a0e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0e6			; 
a0e6			; 
a0e6			;	inc hl 
a0e6			;	ld bc, forthexec 
a0e6			;	ld (hl), c     ; poke address of forthexec 
a0e6			;	inc hl 
a0e6			;	ld (hl), b      
a0e6			; 
a0e6			;	inc hl 
a0e6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a0e6			; 
a0e6			;	ld bc, user_dict_next 
a0e6			;	inc hl 
a0e6			;	ld (hl), c     ; poke address of forthexec 
a0e6			;	inc hl 
a0e6			;	ld (hl), b      
a0e6			 
a0e6				; hl is now where we need to copy the word byte data to save this 
a0e6			 
a0e6 23				inc hl 
a0e7 22 cb e3			ld (os_new_exec), hl 
a0ea				 
a0ea				; copy definition 
a0ea			 
a0ea eb				ex de, hl 
a0eb			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a0eb			;	inc de    ; skip the PC for this parse 
a0eb 3a d3 e3			ld a, (os_new_parse_len) 
a0ee 4f				ld c, a 
a0ef 06 00			ld b, 0 
a0f1 ed b0			ldir		 ; copy defintion 
a0f3			 
a0f3			 
a0f3				; poke the address of where the new word bytes live for forthexec 
a0f3			 
a0f3 2a c9 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a0f6			 
a0f6 ed 5b cb e3		ld de, (os_new_exec)      
a0fa				 
a0fa 73				ld (hl), e 
a0fb 23				inc hl 
a0fc 72				ld (hl), d 
a0fd			 
a0fd					; TODO copy last user dict word next link to this word 
a0fd					; TODO update last user dict word to point to this word 
a0fd			; 
a0fd			; hl f923 de 812a ; bc 811a 
a0fd			 
a0fd			if DEBUG_FORTH_UWORD 
a0fd c5				push bc 
a0fe ed 4b d5 e3		ld bc, (os_new_malloc) 
a102						DMARK ":0A" 
a102 f5				push af  
a103 3a 17 a1			ld a, (.dmark)  
a106 32 71 ee			ld (debug_mark),a  
a109 3a 18 a1			ld a, (.dmark+1)  
a10c 32 72 ee			ld (debug_mark+1),a  
a10f 3a 19 a1			ld a, (.dmark+2)  
a112 32 73 ee			ld (debug_mark+2),a  
a115 18 03			jr .pastdmark  
a117 ..			.dmark: db ":0A"  
a11a f1			.pastdmark: pop af  
a11b			endm  
# End of macro DMARK
a11b				CALLMONITOR 
a11b cd 95 93			call break_point_state  
a11e				endm  
# End of macro CALLMONITOR
a11e c1				pop bc 
a11f			endif 
a11f			if DEBUG_FORTH_UWORD 
a11f c5				push bc 
a120 ed 4b d5 e3		ld bc, (os_new_malloc) 
a124 03				inc bc 
a125 03				inc bc 
a126 03				inc bc 
a127 03				inc bc 
a128 03				inc bc 
a129 03				inc bc 
a12a 03				inc bc 
a12b 03				inc bc 
a12c			 
a12c						DMARK ":0B" 
a12c f5				push af  
a12d 3a 41 a1			ld a, (.dmark)  
a130 32 71 ee			ld (debug_mark),a  
a133 3a 42 a1			ld a, (.dmark+1)  
a136 32 72 ee			ld (debug_mark+1),a  
a139 3a 43 a1			ld a, (.dmark+2)  
a13c 32 73 ee			ld (debug_mark+2),a  
a13f 18 03			jr .pastdmark  
a141 ..			.dmark: db ":0B"  
a144 f1			.pastdmark: pop af  
a145			endm  
# End of macro DMARK
a145				CALLMONITOR 
a145 cd 95 93			call break_point_state  
a148				endm  
# End of macro CALLMONITOR
a148 c1				pop bc 
a149			endif 
a149			 
a149			; update word dict linked list for new word 
a149			 
a149			 
a149 2a d4 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a14c 23			inc hl     ; move to next work linked list ptr 
a14d			 
a14d ed 5b d5 e3	ld de, (os_new_malloc)		 ; new next word 
a151 73			ld (hl), e 
a152 23			inc hl 
a153 72			ld (hl), d 
a154			 
a154			if DEBUG_FORTH_UWORD 
a154 ed 4b d4 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a158			endif 
a158			 
a158 ed 53 d4 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
a15c			 
a15c			 
a15c			if DEBUG_FORTH_UWORD 
a15c						DMARK ":0+" 
a15c f5				push af  
a15d 3a 71 a1			ld a, (.dmark)  
a160 32 71 ee			ld (debug_mark),a  
a163 3a 72 a1			ld a, (.dmark+1)  
a166 32 72 ee			ld (debug_mark+1),a  
a169 3a 73 a1			ld a, (.dmark+2)  
a16c 32 73 ee			ld (debug_mark+2),a  
a16f 18 03			jr .pastdmark  
a171 ..			.dmark: db ":0+"  
a174 f1			.pastdmark: pop af  
a175			endm  
# End of macro DMARK
a175				CALLMONITOR 
a175 cd 95 93			call break_point_state  
a178				endm  
# End of macro CALLMONITOR
a178			endif 
a178			 
a178				STACKFRAMECHK OFF $8efe $989f 
a178				if DEBUG_STACK_IMB 
a178					if OFF 
a178						exx 
a178						ld hl, $989f 
a178						pop de   ; $989f 
a178						call cmp16 
a178						jr nz, .spnosame 
a178						ld hl, $8efe 
a178						pop de   ; $8efe 
a178						call cmp16 
a178						jr z, .spfrsame 
a178						.spnosame: call showsperror 
a178						.spfrsame: nop 
a178						exx 
a178					endif 
a178				endif 
a178			endm 
# End of macro STACKFRAMECHK
a178			 
a178 c9			ret    ; dont process any remaining parser tokens as they form new word 
a179			 
a179			 
a179			 
a179			 
a179			;		NEXT 
a179			.SCOLN: 
a179			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a179 06				db OPCODE_SCOLN 
a17a c5 a1			dw .DROP 
a17c 02				db 2 
a17d .. 00			db ";",0           
a17f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a17f					if DEBUG_FORTH_WORDS_KEY 
a17f						DMARK "SCN" 
a17f f5				push af  
a180 3a 94 a1			ld a, (.dmark)  
a183 32 71 ee			ld (debug_mark),a  
a186 3a 95 a1			ld a, (.dmark+1)  
a189 32 72 ee			ld (debug_mark+1),a  
a18c 3a 96 a1			ld a, (.dmark+2)  
a18f 32 73 ee			ld (debug_mark+2),a  
a192 18 03			jr .pastdmark  
a194 ..			.dmark: db "SCN"  
a197 f1			.pastdmark: pop af  
a198			endm  
# End of macro DMARK
a198						CALLMONITOR 
a198 cd 95 93			call break_point_state  
a19b				endm  
# End of macro CALLMONITOR
a19b					endif 
a19b					FORTH_RSP_TOS 
a19b cd be 99			call macro_forth_rsp_tos 
a19e				endm 
# End of macro FORTH_RSP_TOS
a19e e5					push hl 
a19f					FORTH_RSP_POP 
a19f cd c8 99			call macro_forth_rsp_pop 
a1a2				endm 
# End of macro FORTH_RSP_POP
a1a2 e1					pop hl 
a1a3			;		ex de,hl 
a1a3 22 d8 e6				ld (os_tok_ptr),hl 
a1a6			 
a1a6			if DEBUG_FORTH_UWORD 
a1a6						DMARK "SCL" 
a1a6 f5				push af  
a1a7 3a bb a1			ld a, (.dmark)  
a1aa 32 71 ee			ld (debug_mark),a  
a1ad 3a bc a1			ld a, (.dmark+1)  
a1b0 32 72 ee			ld (debug_mark+1),a  
a1b3 3a bd a1			ld a, (.dmark+2)  
a1b6 32 73 ee			ld (debug_mark+2),a  
a1b9 18 03			jr .pastdmark  
a1bb ..			.dmark: db "SCL"  
a1be f1			.pastdmark: pop af  
a1bf			endm  
# End of macro DMARK
a1bf				CALLMONITOR 
a1bf cd 95 93			call break_point_state  
a1c2				endm  
# End of macro CALLMONITOR
a1c2			endif 
a1c2					NEXTW 
a1c2 c3 69 9d			jp macro_next 
a1c5				endm 
# End of macro NEXTW
a1c5			 
a1c5			.DROP: 
a1c5				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a1c5 1b				db WORD_SYS_CORE+OPCODE_DROP             
a1c6 f0 a1			dw .DUP2            
a1c8 05				db 4 + 1 
a1c9 .. 00			db "DROP",0              
a1ce				endm 
# End of macro CWHEAD
a1ce			; | DROP ( w -- )   drop the TOS item   | DONE 
a1ce					if DEBUG_FORTH_WORDS_KEY 
a1ce						DMARK "DRP" 
a1ce f5				push af  
a1cf 3a e3 a1			ld a, (.dmark)  
a1d2 32 71 ee			ld (debug_mark),a  
a1d5 3a e4 a1			ld a, (.dmark+1)  
a1d8 32 72 ee			ld (debug_mark+1),a  
a1db 3a e5 a1			ld a, (.dmark+2)  
a1de 32 73 ee			ld (debug_mark+2),a  
a1e1 18 03			jr .pastdmark  
a1e3 ..			.dmark: db "DRP"  
a1e6 f1			.pastdmark: pop af  
a1e7			endm  
# End of macro DMARK
a1e7						CALLMONITOR 
a1e7 cd 95 93			call break_point_state  
a1ea				endm  
# End of macro CALLMONITOR
a1ea					endif 
a1ea					FORTH_DSP_POP 
a1ea cd af 9c			call macro_forth_dsp_pop 
a1ed				endm 
# End of macro FORTH_DSP_POP
a1ed					NEXTW 
a1ed c3 69 9d			jp macro_next 
a1f0				endm 
# End of macro NEXTW
a1f0			.DUP2: 
a1f0				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a1f0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a1f1 35 a2			dw .DROP2            
a1f3 05				db 4 + 1 
a1f4 .. 00			db "2DUP",0              
a1f9				endm 
# End of macro CWHEAD
a1f9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a1f9					if DEBUG_FORTH_WORDS_KEY 
a1f9						DMARK "2DU" 
a1f9 f5				push af  
a1fa 3a 0e a2			ld a, (.dmark)  
a1fd 32 71 ee			ld (debug_mark),a  
a200 3a 0f a2			ld a, (.dmark+1)  
a203 32 72 ee			ld (debug_mark+1),a  
a206 3a 10 a2			ld a, (.dmark+2)  
a209 32 73 ee			ld (debug_mark+2),a  
a20c 18 03			jr .pastdmark  
a20e ..			.dmark: db "2DU"  
a211 f1			.pastdmark: pop af  
a212			endm  
# End of macro DMARK
a212						CALLMONITOR 
a212 cd 95 93			call break_point_state  
a215				endm  
# End of macro CALLMONITOR
a215					endif 
a215					FORTH_DSP_VALUEHL 
a215 cd f7 9b			call macro_dsp_valuehl 
a218				endm 
# End of macro FORTH_DSP_VALUEHL
a218 e5					push hl      ; 2 
a219			 
a219					FORTH_DSP_POP 
a219 cd af 9c			call macro_forth_dsp_pop 
a21c				endm 
# End of macro FORTH_DSP_POP
a21c					 
a21c					FORTH_DSP_VALUEHL 
a21c cd f7 9b			call macro_dsp_valuehl 
a21f				endm 
# End of macro FORTH_DSP_VALUEHL
a21f			;		push hl      ; 1 
a21f			 
a21f					FORTH_DSP_POP 
a21f cd af 9c			call macro_forth_dsp_pop 
a222				endm 
# End of macro FORTH_DSP_POP
a222			 
a222			;		pop hl       ; 1 
a222 d1					pop de       ; 2 
a223			 
a223 cd 00 9a				call forth_push_numhl 
a226 eb					ex de, hl 
a227 cd 00 9a				call forth_push_numhl 
a22a			 
a22a					 
a22a eb					ex de, hl 
a22b			 
a22b cd 00 9a				call forth_push_numhl 
a22e eb					ex de, hl 
a22f cd 00 9a				call forth_push_numhl 
a232			 
a232			 
a232					NEXTW 
a232 c3 69 9d			jp macro_next 
a235				endm 
# End of macro NEXTW
a235			.DROP2: 
a235				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a235 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a236 64 a2			dw .SWAP2            
a238 06				db 5 + 1 
a239 .. 00			db "2DROP",0              
a23f				endm 
# End of macro CWHEAD
a23f			; | 2DROP ( w w -- )    Double drop | DONE 
a23f					if DEBUG_FORTH_WORDS_KEY 
a23f						DMARK "2DR" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 71 ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 72 ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 73 ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db "2DR"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258						CALLMONITOR 
a258 cd 95 93			call break_point_state  
a25b				endm  
# End of macro CALLMONITOR
a25b					endif 
a25b					FORTH_DSP_POP 
a25b cd af 9c			call macro_forth_dsp_pop 
a25e				endm 
# End of macro FORTH_DSP_POP
a25e					FORTH_DSP_POP 
a25e cd af 9c			call macro_forth_dsp_pop 
a261				endm 
# End of macro FORTH_DSP_POP
a261					NEXTW 
a261 c3 69 9d			jp macro_next 
a264				endm 
# End of macro NEXTW
a264			.SWAP2: 
a264				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a264 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a265 8d a2			dw .AT            
a267 06				db 5 + 1 
a268 .. 00			db "2SWAP",0              
a26e				endm 
# End of macro CWHEAD
a26e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a26e					if DEBUG_FORTH_WORDS_KEY 
a26e						DMARK "2SW" 
a26e f5				push af  
a26f 3a 83 a2			ld a, (.dmark)  
a272 32 71 ee			ld (debug_mark),a  
a275 3a 84 a2			ld a, (.dmark+1)  
a278 32 72 ee			ld (debug_mark+1),a  
a27b 3a 85 a2			ld a, (.dmark+2)  
a27e 32 73 ee			ld (debug_mark+2),a  
a281 18 03			jr .pastdmark  
a283 ..			.dmark: db "2SW"  
a286 f1			.pastdmark: pop af  
a287			endm  
# End of macro DMARK
a287						CALLMONITOR 
a287 cd 95 93			call break_point_state  
a28a				endm  
# End of macro CALLMONITOR
a28a					endif 
a28a					NEXTW 
a28a c3 69 9d			jp macro_next 
a28d				endm 
# End of macro NEXTW
a28d			.AT: 
a28d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a28d 1f				db WORD_SYS_CORE+OPCODE_AT             
a28e bf a2			dw .CAT            
a290 02				db 1 + 1 
a291 .. 00			db "@",0              
a293				endm 
# End of macro CWHEAD
a293			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a293			 
a293					if DEBUG_FORTH_WORDS_KEY 
a293						DMARK "AT." 
a293 f5				push af  
a294 3a a8 a2			ld a, (.dmark)  
a297 32 71 ee			ld (debug_mark),a  
a29a 3a a9 a2			ld a, (.dmark+1)  
a29d 32 72 ee			ld (debug_mark+1),a  
a2a0 3a aa a2			ld a, (.dmark+2)  
a2a3 32 73 ee			ld (debug_mark+2),a  
a2a6 18 03			jr .pastdmark  
a2a8 ..			.dmark: db "AT."  
a2ab f1			.pastdmark: pop af  
a2ac			endm  
# End of macro DMARK
a2ac						CALLMONITOR 
a2ac cd 95 93			call break_point_state  
a2af				endm  
# End of macro CALLMONITOR
a2af					endif 
a2af			.getbyteat:	 
a2af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2af cd f7 9b			call macro_dsp_valuehl 
a2b2				endm 
# End of macro FORTH_DSP_VALUEHL
a2b2					 
a2b2			;		push hl 
a2b2				 
a2b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2b2 cd af 9c			call macro_forth_dsp_pop 
a2b5				endm 
# End of macro FORTH_DSP_POP
a2b5			 
a2b5			;		pop hl 
a2b5			 
a2b5 7e					ld a, (hl) 
a2b6			 
a2b6 6f					ld l, a 
a2b7 26 00				ld h, 0 
a2b9 cd 00 9a				call forth_push_numhl 
a2bc			 
a2bc					NEXTW 
a2bc c3 69 9d			jp macro_next 
a2bf				endm 
# End of macro NEXTW
a2bf			.CAT: 
a2bf				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a2bf 20				db WORD_SYS_CORE+OPCODE_CAT             
a2c0 e8 a2			dw .BANG            
a2c2 03				db 2 + 1 
a2c3 .. 00			db "C@",0              
a2c6				endm 
# End of macro CWHEAD
a2c6			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a2c6					if DEBUG_FORTH_WORDS_KEY 
a2c6						DMARK "CAA" 
a2c6 f5				push af  
a2c7 3a db a2			ld a, (.dmark)  
a2ca 32 71 ee			ld (debug_mark),a  
a2cd 3a dc a2			ld a, (.dmark+1)  
a2d0 32 72 ee			ld (debug_mark+1),a  
a2d3 3a dd a2			ld a, (.dmark+2)  
a2d6 32 73 ee			ld (debug_mark+2),a  
a2d9 18 03			jr .pastdmark  
a2db ..			.dmark: db "CAA"  
a2de f1			.pastdmark: pop af  
a2df			endm  
# End of macro DMARK
a2df						CALLMONITOR 
a2df cd 95 93			call break_point_state  
a2e2				endm  
# End of macro CALLMONITOR
a2e2					endif 
a2e2 c3 af a2				jp .getbyteat 
a2e5					NEXTW 
a2e5 c3 69 9d			jp macro_next 
a2e8				endm 
# End of macro NEXTW
a2e8			.BANG: 
a2e8				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a2e8 21				db WORD_SYS_CORE+OPCODE_BANG             
a2e9 1e a3			dw .CBANG            
a2eb 02				db 1 + 1 
a2ec .. 00			db "!",0              
a2ee				endm 
# End of macro CWHEAD
a2ee			; | ! ( x w -- ) Store x at address w      | DONE 
a2ee					if DEBUG_FORTH_WORDS_KEY 
a2ee						DMARK "BNG" 
a2ee f5				push af  
a2ef 3a 03 a3			ld a, (.dmark)  
a2f2 32 71 ee			ld (debug_mark),a  
a2f5 3a 04 a3			ld a, (.dmark+1)  
a2f8 32 72 ee			ld (debug_mark+1),a  
a2fb 3a 05 a3			ld a, (.dmark+2)  
a2fe 32 73 ee			ld (debug_mark+2),a  
a301 18 03			jr .pastdmark  
a303 ..			.dmark: db "BNG"  
a306 f1			.pastdmark: pop af  
a307			endm  
# End of macro DMARK
a307						CALLMONITOR 
a307 cd 95 93			call break_point_state  
a30a				endm  
# End of macro CALLMONITOR
a30a					endif 
a30a			 
a30a			.storebyteat:		 
a30a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a30a cd f7 9b			call macro_dsp_valuehl 
a30d				endm 
# End of macro FORTH_DSP_VALUEHL
a30d					 
a30d e5					push hl 
a30e				 
a30e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a30e cd af 9c			call macro_forth_dsp_pop 
a311				endm 
# End of macro FORTH_DSP_POP
a311			 
a311					; get byte to poke 
a311			 
a311					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a311 cd f7 9b			call macro_dsp_valuehl 
a314				endm 
# End of macro FORTH_DSP_VALUEHL
a314 e5					push hl 
a315			 
a315			 
a315					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a315 cd af 9c			call macro_forth_dsp_pop 
a318				endm 
# End of macro FORTH_DSP_POP
a318			 
a318			 
a318 d1					pop de 
a319 e1					pop hl 
a31a			 
a31a 73					ld (hl),e 
a31b			 
a31b			 
a31b					NEXTW 
a31b c3 69 9d			jp macro_next 
a31e				endm 
# End of macro NEXTW
a31e			.CBANG: 
a31e				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a31e 22				db WORD_SYS_CORE+OPCODE_CBANG             
a31f 47 a3			dw .SCALL            
a321 03				db 2 + 1 
a322 .. 00			db "C!",0              
a325				endm 
# End of macro CWHEAD
a325			; | C!  ( x w -- ) Store x at address w  | DONE 
a325					if DEBUG_FORTH_WORDS_KEY 
a325						DMARK "CBA" 
a325 f5				push af  
a326 3a 3a a3			ld a, (.dmark)  
a329 32 71 ee			ld (debug_mark),a  
a32c 3a 3b a3			ld a, (.dmark+1)  
a32f 32 72 ee			ld (debug_mark+1),a  
a332 3a 3c a3			ld a, (.dmark+2)  
a335 32 73 ee			ld (debug_mark+2),a  
a338 18 03			jr .pastdmark  
a33a ..			.dmark: db "CBA"  
a33d f1			.pastdmark: pop af  
a33e			endm  
# End of macro DMARK
a33e						CALLMONITOR 
a33e cd 95 93			call break_point_state  
a341				endm  
# End of macro CALLMONITOR
a341					endif 
a341 c3 0a a3				jp .storebyteat 
a344					NEXTW 
a344 c3 69 9d			jp macro_next 
a347				endm 
# End of macro NEXTW
a347			.SCALL: 
a347				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a347 23				db WORD_SYS_CORE+OPCODE_SCALL             
a348 7b a3			dw .DEPTH            
a34a 05				db 4 + 1 
a34b .. 00			db "CALL",0              
a350				endm 
# End of macro CWHEAD
a350			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a350					if DEBUG_FORTH_WORDS_KEY 
a350						DMARK "CLL" 
a350 f5				push af  
a351 3a 65 a3			ld a, (.dmark)  
a354 32 71 ee			ld (debug_mark),a  
a357 3a 66 a3			ld a, (.dmark+1)  
a35a 32 72 ee			ld (debug_mark+1),a  
a35d 3a 67 a3			ld a, (.dmark+2)  
a360 32 73 ee			ld (debug_mark+2),a  
a363 18 03			jr .pastdmark  
a365 ..			.dmark: db "CLL"  
a368 f1			.pastdmark: pop af  
a369			endm  
# End of macro DMARK
a369						CALLMONITOR 
a369 cd 95 93			call break_point_state  
a36c				endm  
# End of macro CALLMONITOR
a36c					endif 
a36c			 
a36c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a36c cd f7 9b			call macro_dsp_valuehl 
a36f				endm 
# End of macro FORTH_DSP_VALUEHL
a36f			 
a36f			;		push hl 
a36f			 
a36f					; destroy value TOS 
a36f			 
a36f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a36f cd af 9c			call macro_forth_dsp_pop 
a372				endm 
# End of macro FORTH_DSP_POP
a372			 
a372						 
a372			;		pop hl 
a372			 
a372					; how to do a call with hl???? save SP? 
a372 cd 12 9d				call forth_call_hl 
a375			 
a375			 
a375					; TODO push value back onto stack for another op etc 
a375			 
a375 cd 00 9a				call forth_push_numhl 
a378					NEXTW 
a378 c3 69 9d			jp macro_next 
a37b				endm 
# End of macro NEXTW
a37b			.DEPTH: 
a37b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a37b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a37c b8 a3			dw .OVER            
a37e 06				db 5 + 1 
a37f .. 00			db "DEPTH",0              
a385				endm 
# End of macro CWHEAD
a385			; | DEPTH ( -- u ) Push count of stack | DONE 
a385					; take current TOS and remove from base value div by two to get count 
a385					if DEBUG_FORTH_WORDS_KEY 
a385						DMARK "DEP" 
a385 f5				push af  
a386 3a 9a a3			ld a, (.dmark)  
a389 32 71 ee			ld (debug_mark),a  
a38c 3a 9b a3			ld a, (.dmark+1)  
a38f 32 72 ee			ld (debug_mark+1),a  
a392 3a 9c a3			ld a, (.dmark+2)  
a395 32 73 ee			ld (debug_mark+2),a  
a398 18 03			jr .pastdmark  
a39a ..			.dmark: db "DEP"  
a39d f1			.pastdmark: pop af  
a39e			endm  
# End of macro DMARK
a39e						CALLMONITOR 
a39e cd 95 93			call break_point_state  
a3a1				endm  
# End of macro CALLMONITOR
a3a1					endif 
a3a1			 
a3a1			 
a3a1 2a 04 eb			ld hl, (cli_data_sp) 
a3a4 11 3e e9			ld de, cli_data_stack 
a3a7 ed 52			sbc hl,de 
a3a9				 
a3a9				; div by size of stack item 
a3a9			 
a3a9 5d				ld e,l 
a3aa 0e 03			ld c, 3 
a3ac cd 24 8b			call Div8 
a3af			 
a3af 6f				ld l,a 
a3b0 26 00			ld h,0 
a3b2			 
a3b2				;srl h 
a3b2				;rr l 
a3b2			 
a3b2 cd 00 9a				call forth_push_numhl 
a3b5					NEXTW 
a3b5 c3 69 9d			jp macro_next 
a3b8				endm 
# End of macro NEXTW
a3b8			.OVER: 
a3b8				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a3b8 42				db WORD_SYS_CORE+46             
a3b9 ff a3			dw .PAUSE            
a3bb 05				db 4 + 1 
a3bc .. 00			db "OVER",0              
a3c1				endm 
# End of macro CWHEAD
a3c1			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a3c1					if DEBUG_FORTH_WORDS_KEY 
a3c1						DMARK "OVR" 
a3c1 f5				push af  
a3c2 3a d6 a3			ld a, (.dmark)  
a3c5 32 71 ee			ld (debug_mark),a  
a3c8 3a d7 a3			ld a, (.dmark+1)  
a3cb 32 72 ee			ld (debug_mark+1),a  
a3ce 3a d8 a3			ld a, (.dmark+2)  
a3d1 32 73 ee			ld (debug_mark+2),a  
a3d4 18 03			jr .pastdmark  
a3d6 ..			.dmark: db "OVR"  
a3d9 f1			.pastdmark: pop af  
a3da			endm  
# End of macro DMARK
a3da						CALLMONITOR 
a3da cd 95 93			call break_point_state  
a3dd				endm  
# End of macro CALLMONITOR
a3dd					endif 
a3dd			 
a3dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3dd cd f7 9b			call macro_dsp_valuehl 
a3e0				endm 
# End of macro FORTH_DSP_VALUEHL
a3e0 e5					push hl    ; n2 
a3e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3e1 cd af 9c			call macro_forth_dsp_pop 
a3e4				endm 
# End of macro FORTH_DSP_POP
a3e4			 
a3e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3e4 cd f7 9b			call macro_dsp_valuehl 
a3e7				endm 
# End of macro FORTH_DSP_VALUEHL
a3e7 e5					push hl    ; n1 
a3e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3e8 cd af 9c			call macro_forth_dsp_pop 
a3eb				endm 
# End of macro FORTH_DSP_POP
a3eb			 
a3eb d1					pop de     ; n1 
a3ec e1					pop hl     ; n2 
a3ed			 
a3ed d5					push de 
a3ee e5					push hl 
a3ef d5					push de 
a3f0			 
a3f0					; push back  
a3f0			 
a3f0 e1					pop hl 
a3f1 cd 00 9a				call forth_push_numhl 
a3f4 e1					pop hl 
a3f5 cd 00 9a				call forth_push_numhl 
a3f8 e1					pop hl 
a3f9 cd 00 9a				call forth_push_numhl 
a3fc					NEXTW 
a3fc c3 69 9d			jp macro_next 
a3ff				endm 
# End of macro NEXTW
a3ff			 
a3ff			.PAUSE: 
a3ff				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a3ff 43				db WORD_SYS_CORE+47             
a400 34 a4			dw .PAUSES            
a402 08				db 7 + 1 
a403 .. 00			db "PAUSEMS",0              
a40b				endm 
# End of macro CWHEAD
a40b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a40b					if DEBUG_FORTH_WORDS_KEY 
a40b						DMARK "PMS" 
a40b f5				push af  
a40c 3a 20 a4			ld a, (.dmark)  
a40f 32 71 ee			ld (debug_mark),a  
a412 3a 21 a4			ld a, (.dmark+1)  
a415 32 72 ee			ld (debug_mark+1),a  
a418 3a 22 a4			ld a, (.dmark+2)  
a41b 32 73 ee			ld (debug_mark+2),a  
a41e 18 03			jr .pastdmark  
a420 ..			.dmark: db "PMS"  
a423 f1			.pastdmark: pop af  
a424			endm  
# End of macro DMARK
a424						CALLMONITOR 
a424 cd 95 93			call break_point_state  
a427				endm  
# End of macro CALLMONITOR
a427					endif 
a427					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a427 cd f7 9b			call macro_dsp_valuehl 
a42a				endm 
# End of macro FORTH_DSP_VALUEHL
a42a			;		push hl    ; n2 
a42a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a42a cd af 9c			call macro_forth_dsp_pop 
a42d				endm 
# End of macro FORTH_DSP_POP
a42d			;		pop hl 
a42d			 
a42d 7d					ld a, l 
a42e cd c9 88				call aDelayInMS 
a431				       NEXTW 
a431 c3 69 9d			jp macro_next 
a434				endm 
# End of macro NEXTW
a434			.PAUSES:  
a434				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a434 44				db WORD_SYS_CORE+48             
a435 a3 a4			dw .ROT            
a437 06				db 5 + 1 
a438 .. 00			db "PAUSE",0              
a43e				endm 
# End of macro CWHEAD
a43e			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a43e					if DEBUG_FORTH_WORDS_KEY 
a43e						DMARK "PAU" 
a43e f5				push af  
a43f 3a 53 a4			ld a, (.dmark)  
a442 32 71 ee			ld (debug_mark),a  
a445 3a 54 a4			ld a, (.dmark+1)  
a448 32 72 ee			ld (debug_mark+1),a  
a44b 3a 55 a4			ld a, (.dmark+2)  
a44e 32 73 ee			ld (debug_mark+2),a  
a451 18 03			jr .pastdmark  
a453 ..			.dmark: db "PAU"  
a456 f1			.pastdmark: pop af  
a457			endm  
# End of macro DMARK
a457						CALLMONITOR 
a457 cd 95 93			call break_point_state  
a45a				endm  
# End of macro CALLMONITOR
a45a					endif 
a45a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a45a cd f7 9b			call macro_dsp_valuehl 
a45d				endm 
# End of macro FORTH_DSP_VALUEHL
a45d			;		push hl    ; n2 
a45d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a45d cd af 9c			call macro_forth_dsp_pop 
a460				endm 
# End of macro FORTH_DSP_POP
a460			;		pop hl 
a460 45					ld b, l 
a461					if DEBUG_FORTH_WORDS 
a461						DMARK "PAU" 
a461 f5				push af  
a462 3a 76 a4			ld a, (.dmark)  
a465 32 71 ee			ld (debug_mark),a  
a468 3a 77 a4			ld a, (.dmark+1)  
a46b 32 72 ee			ld (debug_mark+1),a  
a46e 3a 78 a4			ld a, (.dmark+2)  
a471 32 73 ee			ld (debug_mark+2),a  
a474 18 03			jr .pastdmark  
a476 ..			.dmark: db "PAU"  
a479 f1			.pastdmark: pop af  
a47a			endm  
# End of macro DMARK
a47a						CALLMONITOR 
a47a cd 95 93			call break_point_state  
a47d				endm  
# End of macro CALLMONITOR
a47d					endif 
a47d c5			.pauses1:	push bc 
a47e cd e4 88				call delay1s 
a481 c1					pop bc 
a482					if DEBUG_FORTH_WORDS 
a482						DMARK "PA1" 
a482 f5				push af  
a483 3a 97 a4			ld a, (.dmark)  
a486 32 71 ee			ld (debug_mark),a  
a489 3a 98 a4			ld a, (.dmark+1)  
a48c 32 72 ee			ld (debug_mark+1),a  
a48f 3a 99 a4			ld a, (.dmark+2)  
a492 32 73 ee			ld (debug_mark+2),a  
a495 18 03			jr .pastdmark  
a497 ..			.dmark: db "PA1"  
a49a f1			.pastdmark: pop af  
a49b			endm  
# End of macro DMARK
a49b						CALLMONITOR 
a49b cd 95 93			call break_point_state  
a49e				endm  
# End of macro CALLMONITOR
a49e					endif 
a49e 10 dd				djnz .pauses1 
a4a0			 
a4a0				       NEXTW 
a4a0 c3 69 9d			jp macro_next 
a4a3				endm 
# End of macro NEXTW
a4a3			.ROT: 
a4a3				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a4a3 45				db WORD_SYS_CORE+49             
a4a4 f1 a4			dw .UWORDS            
a4a6 04				db 3 + 1 
a4a7 .. 00			db "ROT",0              
a4ab				endm 
# End of macro CWHEAD
a4ab			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a4ab					if DEBUG_FORTH_WORDS_KEY 
a4ab						DMARK "ROT" 
a4ab f5				push af  
a4ac 3a c0 a4			ld a, (.dmark)  
a4af 32 71 ee			ld (debug_mark),a  
a4b2 3a c1 a4			ld a, (.dmark+1)  
a4b5 32 72 ee			ld (debug_mark+1),a  
a4b8 3a c2 a4			ld a, (.dmark+2)  
a4bb 32 73 ee			ld (debug_mark+2),a  
a4be 18 03			jr .pastdmark  
a4c0 ..			.dmark: db "ROT"  
a4c3 f1			.pastdmark: pop af  
a4c4			endm  
# End of macro DMARK
a4c4						CALLMONITOR 
a4c4 cd 95 93			call break_point_state  
a4c7				endm  
# End of macro CALLMONITOR
a4c7					endif 
a4c7			 
a4c7					FORTH_DSP_VALUEHL 
a4c7 cd f7 9b			call macro_dsp_valuehl 
a4ca				endm 
# End of macro FORTH_DSP_VALUEHL
a4ca e5					push hl    ; u3  
a4cb			 
a4cb					FORTH_DSP_POP 
a4cb cd af 9c			call macro_forth_dsp_pop 
a4ce				endm 
# End of macro FORTH_DSP_POP
a4ce			   
a4ce					FORTH_DSP_VALUEHL 
a4ce cd f7 9b			call macro_dsp_valuehl 
a4d1				endm 
# End of macro FORTH_DSP_VALUEHL
a4d1 e5					push hl     ; u2 
a4d2			 
a4d2					FORTH_DSP_POP 
a4d2 cd af 9c			call macro_forth_dsp_pop 
a4d5				endm 
# End of macro FORTH_DSP_POP
a4d5			 
a4d5					FORTH_DSP_VALUEHL 
a4d5 cd f7 9b			call macro_dsp_valuehl 
a4d8				endm 
# End of macro FORTH_DSP_VALUEHL
a4d8 e5					push hl     ; u1 
a4d9			 
a4d9					FORTH_DSP_POP 
a4d9 cd af 9c			call macro_forth_dsp_pop 
a4dc				endm 
# End of macro FORTH_DSP_POP
a4dc			 
a4dc c1					pop bc      ; u1 
a4dd e1					pop hl      ; u2 
a4de d1					pop de      ; u3 
a4df			 
a4df			 
a4df c5					push bc 
a4e0 d5					push de 
a4e1 e5					push hl 
a4e2			 
a4e2			 
a4e2 e1					pop hl 
a4e3 cd 00 9a				call forth_push_numhl 
a4e6			 
a4e6 e1					pop hl 
a4e7 cd 00 9a				call forth_push_numhl 
a4ea			 
a4ea e1					pop hl 
a4eb cd 00 9a				call forth_push_numhl 
a4ee					 
a4ee			 
a4ee			 
a4ee			 
a4ee			 
a4ee			 
a4ee				       NEXTW 
a4ee c3 69 9d			jp macro_next 
a4f1				endm 
# End of macro NEXTW
a4f1			 
a4f1			.UWORDS: 
a4f1				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a4f1 50				db WORD_SYS_CORE+60             
a4f2 b3 a5			dw .BP            
a4f4 07				db 6 + 1 
a4f5 .. 00			db "UWORDS",0              
a4fc				endm 
# End of macro CWHEAD
a4fc			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a4fc			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a4fc			; | | Following the count are the individual words. 
a4fc			; | | 
a4fc			; | | e.g. UWORDS 
a4fc			; | | BOX DIRLIST 2 
a4fc			; | |  
a4fc			; | | Can be used to save the words to storage via: 
a4fc			; | | UWORDS $01 DO $01 APPEND LOOP 
a4fc				if DEBUG_FORTH_WORDS_KEY 
a4fc					DMARK "UWR" 
a4fc f5				push af  
a4fd 3a 11 a5			ld a, (.dmark)  
a500 32 71 ee			ld (debug_mark),a  
a503 3a 12 a5			ld a, (.dmark+1)  
a506 32 72 ee			ld (debug_mark+1),a  
a509 3a 13 a5			ld a, (.dmark+2)  
a50c 32 73 ee			ld (debug_mark+2),a  
a50f 18 03			jr .pastdmark  
a511 ..			.dmark: db "UWR"  
a514 f1			.pastdmark: pop af  
a515			endm  
# End of macro DMARK
a515					CALLMONITOR 
a515 cd 95 93			call break_point_state  
a518				endm  
# End of macro CALLMONITOR
a518				endif 
a518 21 15 d9				ld hl, baseram 
a51b					;ld hl, baseusermem 
a51b 01 00 00				ld bc, 0    ; start a counter 
a51e			 
a51e				; skip dict stub 
a51e			 
a51e cd ba 9e				call forth_tok_next 
a521			 
a521			 
a521			; while we have words to look for 
a521			 
a521 7e			.douscan:	ld a, (hl)      
a522				if DEBUG_FORTH_WORDS 
a522					DMARK "UWs" 
a522 f5				push af  
a523 3a 37 a5			ld a, (.dmark)  
a526 32 71 ee			ld (debug_mark),a  
a529 3a 38 a5			ld a, (.dmark+1)  
a52c 32 72 ee			ld (debug_mark+1),a  
a52f 3a 39 a5			ld a, (.dmark+2)  
a532 32 73 ee			ld (debug_mark+2),a  
a535 18 03			jr .pastdmark  
a537 ..			.dmark: db "UWs"  
a53a f1			.pastdmark: pop af  
a53b			endm  
# End of macro DMARK
a53b					CALLMONITOR 
a53b cd 95 93			call break_point_state  
a53e				endm  
# End of macro CALLMONITOR
a53e				endif 
a53e fe 00				cp WORD_SYS_END 
a540 28 4d				jr z, .udone 
a542 fe 01				cp WORD_SYS_UWORD 
a544 20 44				jr nz, .nuword 
a546			 
a546				if DEBUG_FORTH_WORDS 
a546					DMARK "UWu" 
a546 f5				push af  
a547 3a 5b a5			ld a, (.dmark)  
a54a 32 71 ee			ld (debug_mark),a  
a54d 3a 5c a5			ld a, (.dmark+1)  
a550 32 72 ee			ld (debug_mark+1),a  
a553 3a 5d a5			ld a, (.dmark+2)  
a556 32 73 ee			ld (debug_mark+2),a  
a559 18 03			jr .pastdmark  
a55b ..			.dmark: db "UWu"  
a55e f1			.pastdmark: pop af  
a55f			endm  
# End of macro DMARK
a55f					CALLMONITOR 
a55f cd 95 93			call break_point_state  
a562				endm  
# End of macro CALLMONITOR
a562				endif 
a562					; we have a uword so push its name to the stack 
a562			 
a562 e5				   	push hl  ; save so we can move to next dict block 
a563			 
a563					; skip opcode 
a563 23					inc hl  
a564					; skip next ptr 
a564 23					inc hl  
a565 23					inc hl 
a566					; skip len 
a566 23					inc hl 
a567				if DEBUG_FORTH_WORDS 
a567					DMARK "UWt" 
a567 f5				push af  
a568 3a 7c a5			ld a, (.dmark)  
a56b 32 71 ee			ld (debug_mark),a  
a56e 3a 7d a5			ld a, (.dmark+1)  
a571 32 72 ee			ld (debug_mark+1),a  
a574 3a 7e a5			ld a, (.dmark+2)  
a577 32 73 ee			ld (debug_mark+2),a  
a57a 18 03			jr .pastdmark  
a57c ..			.dmark: db "UWt"  
a57f f1			.pastdmark: pop af  
a580			endm  
# End of macro DMARK
a580					CALLMONITOR 
a580 cd 95 93			call break_point_state  
a583				endm  
# End of macro CALLMONITOR
a583				endif 
a583 03					inc bc 
a584			 
a584 c5					push bc 
a585 cd 6e 9a				call forth_push_str 
a588 c1					pop bc 
a589			 
a589 e1					pop hl 	 
a58a			 
a58a cd ba 9e		.nuword:	call forth_tok_next 
a58d 18 92				jr .douscan  
a58f			 
a58f			.udone:		 ; push count of uwords found 
a58f c5					push bc 
a590 e1					pop hl 
a591			 
a591				if DEBUG_FORTH_WORDS 
a591					DMARK "UWc" 
a591 f5				push af  
a592 3a a6 a5			ld a, (.dmark)  
a595 32 71 ee			ld (debug_mark),a  
a598 3a a7 a5			ld a, (.dmark+1)  
a59b 32 72 ee			ld (debug_mark+1),a  
a59e 3a a8 a5			ld a, (.dmark+2)  
a5a1 32 73 ee			ld (debug_mark+2),a  
a5a4 18 03			jr .pastdmark  
a5a6 ..			.dmark: db "UWc"  
a5a9 f1			.pastdmark: pop af  
a5aa			endm  
# End of macro DMARK
a5aa					CALLMONITOR 
a5aa cd 95 93			call break_point_state  
a5ad				endm  
# End of macro CALLMONITOR
a5ad				endif 
a5ad cd 00 9a				call forth_push_numhl 
a5b0			 
a5b0			 
a5b0				       NEXTW 
a5b0 c3 69 9d			jp macro_next 
a5b3				endm 
# End of macro NEXTW
a5b3			 
a5b3			.BP: 
a5b3				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a5b3 54				db WORD_SYS_CORE+64             
a5b4 e9 a5			dw .MONITOR            
a5b6 03				db 2 + 1 
a5b7 .. 00			db "BP",0              
a5ba				endm 
# End of macro CWHEAD
a5ba			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a5ba			; | | $00 Will enable the break points within specific code paths 
a5ba			; | | $01 Will disable break points 
a5ba			; | |  
a5ba			; | | By default break points are off. Either the above can be used to enable them 
a5ba			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a5ba			; | | and on release of the pressed key a message will be disaplayed to notify 
a5ba			; | | that break points are enabled. Pressing any key will then continue boot process. 
a5ba					; get byte count 
a5ba					if DEBUG_FORTH_WORDS_KEY 
a5ba						DMARK "BP." 
a5ba f5				push af  
a5bb 3a cf a5			ld a, (.dmark)  
a5be 32 71 ee			ld (debug_mark),a  
a5c1 3a d0 a5			ld a, (.dmark+1)  
a5c4 32 72 ee			ld (debug_mark+1),a  
a5c7 3a d1 a5			ld a, (.dmark+2)  
a5ca 32 73 ee			ld (debug_mark+2),a  
a5cd 18 03			jr .pastdmark  
a5cf ..			.dmark: db "BP."  
a5d2 f1			.pastdmark: pop af  
a5d3			endm  
# End of macro DMARK
a5d3						CALLMONITOR 
a5d3 cd 95 93			call break_point_state  
a5d6				endm  
# End of macro CALLMONITOR
a5d6					endif 
a5d6			 
a5d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5d6 cd f7 9b			call macro_dsp_valuehl 
a5d9				endm 
# End of macro FORTH_DSP_VALUEHL
a5d9			 
a5d9			;		push hl 
a5d9			 
a5d9					; destroy value TOS 
a5d9			 
a5d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5d9 cd af 9c			call macro_forth_dsp_pop 
a5dc				endm 
# End of macro FORTH_DSP_POP
a5dc			 
a5dc			;		pop hl 
a5dc			 
a5dc 3e 00				ld a,0 
a5de bd					cp l 
a5df 28 02				jr z, .bpset 
a5e1 3e 2a				ld a, '*' 
a5e3			 
a5e3 32 c8 e3		.bpset:		ld (os_view_disable), a 
a5e6			 
a5e6			 
a5e6					NEXTW 
a5e6 c3 69 9d			jp macro_next 
a5e9				endm 
# End of macro NEXTW
a5e9			 
a5e9			 
a5e9			.MONITOR: 
a5e9				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a5e9 55				db WORD_SYS_CORE+65             
a5ea 1c a6			dw .MALLOC            
a5ec 08				db 7 + 1 
a5ed .. 00			db "MONITOR",0              
a5f5				endm 
# End of macro CWHEAD
a5f5			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a5f5			; | | At start the current various registers will be displayed with contents. 
a5f5			; | | Top right corner will show the most recent debug marker seen. 
a5f5			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a5f5			; | | and the return stack pointer (RSP). 
a5f5			; | | Pressing: 
a5f5			; | |    1 - Initial screen 
a5f5			; | |    2 - Display a data dump of HL 
a5f5			; | |    3 - Display a data dump of DE 
a5f5			; | |    4 - Display a data dump of BC 
a5f5			; | |    5 - Display a data dump of HL 
a5f5			; | |    6 - Display a data dump of DSP 
a5f5			; | |    7 - Display a data dump of RSP 
a5f5			; | |    8 - Display a data dump of what is at DSP 
a5f5			; | |    9 - Display a data dump of what is at RSP 
a5f5			; | |    0 - Exit monitor and continue running. This will also enable break points 
a5f5			; | |    * - Disable break points 
a5f5			; | |    # - Enter traditional monitor mode 
a5f5			; | | 
a5f5			; | | Monitor Mode 
a5f5			; | | ------------ 
a5f5			; | | A prompt of '>' will be shown for various commands: 
a5f5			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a5f5			; | |    C - Continue display a data dump from the last set address 
a5f5			; | |    M xxxx - Set start of memory edit at address xx 
a5f5			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a5f5			; | |    Q - Return to previous 
a5f5					if DEBUG_FORTH_WORDS_KEY 
a5f5						DMARK "MON" 
a5f5 f5				push af  
a5f6 3a 0a a6			ld a, (.dmark)  
a5f9 32 71 ee			ld (debug_mark),a  
a5fc 3a 0b a6			ld a, (.dmark+1)  
a5ff 32 72 ee			ld (debug_mark+1),a  
a602 3a 0c a6			ld a, (.dmark+2)  
a605 32 73 ee			ld (debug_mark+2),a  
a608 18 03			jr .pastdmark  
a60a ..			.dmark: db "MON"  
a60d f1			.pastdmark: pop af  
a60e			endm  
# End of macro DMARK
a60e						CALLMONITOR 
a60e cd 95 93			call break_point_state  
a611				endm  
# End of macro CALLMONITOR
a611					endif 
a611 3e 00				ld a, 0 
a613 32 c8 e3				ld (os_view_disable), a 
a616			 
a616					CALLMONITOR 
a616 cd 95 93			call break_point_state  
a619				endm  
# End of macro CALLMONITOR
a619			 
a619			;	call monitor 
a619			 
a619					NEXTW 
a619 c3 69 9d			jp macro_next 
a61c				endm 
# End of macro NEXTW
a61c			 
a61c			 
a61c			.MALLOC: 
a61c				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a61c 56				db WORD_SYS_CORE+66             
a61d 45 a6			dw .MALLOC2            
a61f 06				db 5 + 1 
a620 .. 00			db "ALLOT",0              
a626				endm 
# End of macro CWHEAD
a626			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a626					if DEBUG_FORTH_WORDS_KEY 
a626						DMARK "ALL" 
a626 f5				push af  
a627 3a 3b a6			ld a, (.dmark)  
a62a 32 71 ee			ld (debug_mark),a  
a62d 3a 3c a6			ld a, (.dmark+1)  
a630 32 72 ee			ld (debug_mark+1),a  
a633 3a 3d a6			ld a, (.dmark+2)  
a636 32 73 ee			ld (debug_mark+2),a  
a639 18 03			jr .pastdmark  
a63b ..			.dmark: db "ALL"  
a63e f1			.pastdmark: pop af  
a63f			endm  
# End of macro DMARK
a63f						CALLMONITOR 
a63f cd 95 93			call break_point_state  
a642				endm  
# End of macro CALLMONITOR
a642					endif 
a642 c3 6c a6				jp .mallocc 
a645			.MALLOC2: 
a645				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a645 56				db WORD_SYS_CORE+66             
a646 83 a6			dw .FREE            
a648 07				db 6 + 1 
a649 .. 00			db "MALLOC",0              
a650				endm 
# End of macro CWHEAD
a650			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a650					; get byte count 
a650					if DEBUG_FORTH_WORDS_KEY 
a650						DMARK "MAL" 
a650 f5				push af  
a651 3a 65 a6			ld a, (.dmark)  
a654 32 71 ee			ld (debug_mark),a  
a657 3a 66 a6			ld a, (.dmark+1)  
a65a 32 72 ee			ld (debug_mark+1),a  
a65d 3a 67 a6			ld a, (.dmark+2)  
a660 32 73 ee			ld (debug_mark+2),a  
a663 18 03			jr .pastdmark  
a665 ..			.dmark: db "MAL"  
a668 f1			.pastdmark: pop af  
a669			endm  
# End of macro DMARK
a669						CALLMONITOR 
a669 cd 95 93			call break_point_state  
a66c				endm  
# End of macro CALLMONITOR
a66c					endif 
a66c			.mallocc: 
a66c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a66c cd f7 9b			call macro_dsp_valuehl 
a66f				endm 
# End of macro FORTH_DSP_VALUEHL
a66f			 
a66f			;		push hl 
a66f			 
a66f					; destroy value TOS 
a66f			 
a66f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a66f cd af 9c			call macro_forth_dsp_pop 
a672				endm 
# End of macro FORTH_DSP_POP
a672			 
a672			;		pop hl 
a672 cd 5b 90				call malloc 
a675				if DEBUG_FORTH_MALLOC_GUARD 
a675 f5					push af 
a676 cd bd 8b				call ishlzero 
a679			;		ld a, l 
a679			;		add h 
a679			;		cp 0 
a679 f1					pop af 
a67a					 
a67a cc 9b c5				call z,malloc_error 
a67d				endif 
a67d			 
a67d cd 00 9a				call forth_push_numhl 
a680					NEXTW 
a680 c3 69 9d			jp macro_next 
a683				endm 
# End of macro NEXTW
a683			 
a683			.FREE: 
a683				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a683 57				db WORD_SYS_CORE+67             
a684 b4 a6			dw .LIST            
a686 05				db 4 + 1 
a687 .. 00			db "FREE",0              
a68c				endm 
# End of macro CWHEAD
a68c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a68c					if DEBUG_FORTH_WORDS_KEY 
a68c						DMARK "FRE" 
a68c f5				push af  
a68d 3a a1 a6			ld a, (.dmark)  
a690 32 71 ee			ld (debug_mark),a  
a693 3a a2 a6			ld a, (.dmark+1)  
a696 32 72 ee			ld (debug_mark+1),a  
a699 3a a3 a6			ld a, (.dmark+2)  
a69c 32 73 ee			ld (debug_mark+2),a  
a69f 18 03			jr .pastdmark  
a6a1 ..			.dmark: db "FRE"  
a6a4 f1			.pastdmark: pop af  
a6a5			endm  
# End of macro DMARK
a6a5						CALLMONITOR 
a6a5 cd 95 93			call break_point_state  
a6a8				endm  
# End of macro CALLMONITOR
a6a8					endif 
a6a8					; get address 
a6a8			 
a6a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6a8 cd f7 9b			call macro_dsp_valuehl 
a6ab				endm 
# End of macro FORTH_DSP_VALUEHL
a6ab			 
a6ab			;		push hl 
a6ab			 
a6ab					; destroy value TOS 
a6ab			 
a6ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6ab cd af 9c			call macro_forth_dsp_pop 
a6ae				endm 
# End of macro FORTH_DSP_POP
a6ae			 
a6ae			;		pop hl 
a6ae			if FORTH_ENABLE_MALLOCFREE 
a6ae cd 25 91				call free 
a6b1			endif 
a6b1					NEXTW 
a6b1 c3 69 9d			jp macro_next 
a6b4				endm 
# End of macro NEXTW
a6b4			.LIST: 
a6b4				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a6b4 5c				db WORD_SYS_CORE+72             
a6b5 a2 a8			dw .FORGET            
a6b7 05				db 4 + 1 
a6b8 .. 00			db "LIST",0              
a6bd				endm 
# End of macro CWHEAD
a6bd			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a6bd			; | | The quoted word must be in upper case. 
a6bd				if DEBUG_FORTH_WORDS_KEY 
a6bd					DMARK "LST" 
a6bd f5				push af  
a6be 3a d2 a6			ld a, (.dmark)  
a6c1 32 71 ee			ld (debug_mark),a  
a6c4 3a d3 a6			ld a, (.dmark+1)  
a6c7 32 72 ee			ld (debug_mark+1),a  
a6ca 3a d4 a6			ld a, (.dmark+2)  
a6cd 32 73 ee			ld (debug_mark+2),a  
a6d0 18 03			jr .pastdmark  
a6d2 ..			.dmark: db "LST"  
a6d5 f1			.pastdmark: pop af  
a6d6			endm  
# End of macro DMARK
a6d6					CALLMONITOR 
a6d6 cd 95 93			call break_point_state  
a6d9				endm  
# End of macro CALLMONITOR
a6d9				endif 
a6d9			 
a6d9					FORTH_DSP_VALUEHL 
a6d9 cd f7 9b			call macro_dsp_valuehl 
a6dc				endm 
# End of macro FORTH_DSP_VALUEHL
a6dc			 
a6dc e5					push hl 
a6dd					FORTH_DSP_POP 
a6dd cd af 9c			call macro_forth_dsp_pop 
a6e0				endm 
# End of macro FORTH_DSP_POP
a6e0 c1					pop bc 
a6e1			 
a6e1			; Start format of scratch string 
a6e1			 
a6e1 21 d7 e3				ld hl, scratch 
a6e4			 
a6e4 3e 3a				ld a, ':' 
a6e6 77					ld (hl),a 
a6e7 23					inc hl 
a6e8 3e 20				ld a, ' ' 
a6ea 77					ld (hl), a 
a6eb			 
a6eb					; Get ptr to the word we need to look up 
a6eb			 
a6eb			;		FORTH_DSP_VALUEHL 
a6eb					;v5 FORTH_DSP_VALUE 
a6eb				; TODO type check 
a6eb			;		inc hl    ; Skip type check  
a6eb			;		push hl 
a6eb			;		ex de, hl    ; put into DE 
a6eb			 
a6eb			 
a6eb 21 15 d9				ld hl, baseram 
a6ee					;ld hl, baseusermem 
a6ee			 
a6ee e5			push hl   ; sacreifical push 
a6ef			 
a6ef			.ldouscanm: 
a6ef e1				pop hl 
a6f0			.ldouscan: 
a6f0				if DEBUG_FORTH_WORDS 
a6f0					DMARK "LSs" 
a6f0 f5				push af  
a6f1 3a 05 a7			ld a, (.dmark)  
a6f4 32 71 ee			ld (debug_mark),a  
a6f7 3a 06 a7			ld a, (.dmark+1)  
a6fa 32 72 ee			ld (debug_mark+1),a  
a6fd 3a 07 a7			ld a, (.dmark+2)  
a700 32 73 ee			ld (debug_mark+2),a  
a703 18 03			jr .pastdmark  
a705 ..			.dmark: db "LSs"  
a708 f1			.pastdmark: pop af  
a709			endm  
# End of macro DMARK
a709					CALLMONITOR 
a709 cd 95 93			call break_point_state  
a70c				endm  
# End of macro CALLMONITOR
a70c				endif 
a70c				; skip dict stub 
a70c cd ba 9e				call forth_tok_next 
a70f			 
a70f			 
a70f			; while we have words to look for 
a70f			 
a70f 7e				ld a, (hl)      
a710				if DEBUG_FORTH_WORDS 
a710					DMARK "LSk" 
a710 f5				push af  
a711 3a 25 a7			ld a, (.dmark)  
a714 32 71 ee			ld (debug_mark),a  
a717 3a 26 a7			ld a, (.dmark+1)  
a71a 32 72 ee			ld (debug_mark+1),a  
a71d 3a 27 a7			ld a, (.dmark+2)  
a720 32 73 ee			ld (debug_mark+2),a  
a723 18 03			jr .pastdmark  
a725 ..			.dmark: db "LSk"  
a728 f1			.pastdmark: pop af  
a729			endm  
# End of macro DMARK
a729					CALLMONITOR 
a729 cd 95 93			call break_point_state  
a72c				endm  
# End of macro CALLMONITOR
a72c				endif 
a72c					;cp WORD_SYS_END 
a72c					;jp z, .lunotfound 
a72c			 
a72c					; if we hit non uwords then gone too far 
a72c fe 01				cp WORD_SYS_UWORD 
a72e c2 5e a8				jp nz, .lunotfound 
a731			 
a731				if DEBUG_FORTH_WORDS 
a731					DMARK "LSu" 
a731 f5				push af  
a732 3a 46 a7			ld a, (.dmark)  
a735 32 71 ee			ld (debug_mark),a  
a738 3a 47 a7			ld a, (.dmark+1)  
a73b 32 72 ee			ld (debug_mark+1),a  
a73e 3a 48 a7			ld a, (.dmark+2)  
a741 32 73 ee			ld (debug_mark+2),a  
a744 18 03			jr .pastdmark  
a746 ..			.dmark: db "LSu"  
a749 f1			.pastdmark: pop af  
a74a			endm  
# End of macro DMARK
a74a					CALLMONITOR 
a74a cd 95 93			call break_point_state  
a74d				endm  
# End of macro CALLMONITOR
a74d				endif 
a74d			 
a74d					; found a uword but is it the one we want... 
a74d			 
a74d c5					push bc     ; uword to find is on bc 
a74e d1					pop de 
a74f			 
a74f e5					push hl  ; to save the ptr 
a750			 
a750					; skip opcode 
a750 23					inc hl  
a751					; skip next ptr 
a751 23					inc hl  
a752 23					inc hl 
a753					; skip len 
a753 23					inc hl 
a754			 
a754				if DEBUG_FORTH_WORDS 
a754					DMARK "LSc" 
a754 f5				push af  
a755 3a 69 a7			ld a, (.dmark)  
a758 32 71 ee			ld (debug_mark),a  
a75b 3a 6a a7			ld a, (.dmark+1)  
a75e 32 72 ee			ld (debug_mark+1),a  
a761 3a 6b a7			ld a, (.dmark+2)  
a764 32 73 ee			ld (debug_mark+2),a  
a767 18 03			jr .pastdmark  
a769 ..			.dmark: db "LSc"  
a76c f1			.pastdmark: pop af  
a76d			endm  
# End of macro DMARK
a76d					CALLMONITOR 
a76d cd 95 93			call break_point_state  
a770				endm  
# End of macro CALLMONITOR
a770				endif 
a770 cd 2a 90				call strcmp 
a773 c2 ef a6				jp nz, .ldouscanm 
a776				 
a776			 
a776			 
a776					; we have a uword so push its name to the stack 
a776			 
a776			;	   	push hl  ; save so we can move to next dict block 
a776 e1			pop hl 
a777			 
a777				if DEBUG_FORTH_WORDS 
a777					DMARK "LSm" 
a777 f5				push af  
a778 3a 8c a7			ld a, (.dmark)  
a77b 32 71 ee			ld (debug_mark),a  
a77e 3a 8d a7			ld a, (.dmark+1)  
a781 32 72 ee			ld (debug_mark+1),a  
a784 3a 8e a7			ld a, (.dmark+2)  
a787 32 73 ee			ld (debug_mark+2),a  
a78a 18 03			jr .pastdmark  
a78c ..			.dmark: db "LSm"  
a78f f1			.pastdmark: pop af  
a790			endm  
# End of macro DMARK
a790					CALLMONITOR 
a790 cd 95 93			call break_point_state  
a793				endm  
# End of macro CALLMONITOR
a793				endif 
a793			 
a793					; skip opcode 
a793 23					inc hl  
a794					; skip next ptr 
a794 23					inc hl  
a795 23					inc hl 
a796					; skip len 
a796 7e					ld a, (hl)   ; save length to add 
a797				if DEBUG_FORTH_WORDS 
a797					DMARK "LS2" 
a797 f5				push af  
a798 3a ac a7			ld a, (.dmark)  
a79b 32 71 ee			ld (debug_mark),a  
a79e 3a ad a7			ld a, (.dmark+1)  
a7a1 32 72 ee			ld (debug_mark+1),a  
a7a4 3a ae a7			ld a, (.dmark+2)  
a7a7 32 73 ee			ld (debug_mark+2),a  
a7aa 18 03			jr .pastdmark  
a7ac ..			.dmark: db "LS2"  
a7af f1			.pastdmark: pop af  
a7b0			endm  
# End of macro DMARK
a7b0					CALLMONITOR 
a7b0 cd 95 93			call break_point_state  
a7b3				endm  
# End of macro CALLMONITOR
a7b3				endif 
a7b3			 
a7b3					; save this location 
a7b3				 
a7b3 e5					push hl 
a7b4			 
a7b4 23					inc hl 
a7b5 11 d9 e3				ld de, scratch+2 
a7b8 4f					ld c, a 
a7b9 06 00				ld b, 0 
a7bb			 
a7bb				if DEBUG_FORTH_WORDS 
a7bb					DMARK "LSn" 
a7bb f5				push af  
a7bc 3a d0 a7			ld a, (.dmark)  
a7bf 32 71 ee			ld (debug_mark),a  
a7c2 3a d1 a7			ld a, (.dmark+1)  
a7c5 32 72 ee			ld (debug_mark+1),a  
a7c8 3a d2 a7			ld a, (.dmark+2)  
a7cb 32 73 ee			ld (debug_mark+2),a  
a7ce 18 03			jr .pastdmark  
a7d0 ..			.dmark: db "LSn"  
a7d3 f1			.pastdmark: pop af  
a7d4			endm  
# End of macro DMARK
a7d4					CALLMONITOR 
a7d4 cd 95 93			call break_point_state  
a7d7				endm  
# End of macro CALLMONITOR
a7d7				endif 
a7d7			 
a7d7					; copy uword name to scratch 
a7d7			 
a7d7 ed b0				ldir 
a7d9			 
a7d9 1b					dec de 
a7da 3e 20				ld a, ' '    ; change null to space 
a7dc 12					ld (de), a 
a7dd			 
a7dd 13					inc de 
a7de			 
a7de d5					push de 
a7df c1					pop bc     ; move scratch pointer to end of word name and save it 
a7e0			 
a7e0 e1					pop hl 
a7e1 7e					ld a, (hl) 
a7e2					;inc hl 
a7e2					; skip word string 
a7e2 cd 94 8b				call addatohl 
a7e5			 
a7e5 23					inc hl 
a7e6			 
a7e6				if DEBUG_FORTH_WORDS 
a7e6					DMARK "LS3" 
a7e6 f5				push af  
a7e7 3a fb a7			ld a, (.dmark)  
a7ea 32 71 ee			ld (debug_mark),a  
a7ed 3a fc a7			ld a, (.dmark+1)  
a7f0 32 72 ee			ld (debug_mark+1),a  
a7f3 3a fd a7			ld a, (.dmark+2)  
a7f6 32 73 ee			ld (debug_mark+2),a  
a7f9 18 03			jr .pastdmark  
a7fb ..			.dmark: db "LS3"  
a7fe f1			.pastdmark: pop af  
a7ff			endm  
# End of macro DMARK
a7ff					CALLMONITOR 
a7ff cd 95 93			call break_point_state  
a802				endm  
# End of macro CALLMONITOR
a802				endif 
a802					; should now be at the start of the machine code to setup the eval of the uword 
a802					; now locate the ptr to the string defintion 
a802			 
a802					; skip ld hl, 
a802					; then load the ptr 
a802			; TODO use get from hl ptr 
a802 23					inc hl 
a803 5e					ld e, (hl) 
a804 23					inc hl 
a805 56					ld d, (hl) 
a806 eb					ex de, hl 
a807			 
a807			 
a807				if DEBUG_FORTH_WORDS 
a807					DMARK "LSt" 
a807 f5				push af  
a808 3a 1c a8			ld a, (.dmark)  
a80b 32 71 ee			ld (debug_mark),a  
a80e 3a 1d a8			ld a, (.dmark+1)  
a811 32 72 ee			ld (debug_mark+1),a  
a814 3a 1e a8			ld a, (.dmark+2)  
a817 32 73 ee			ld (debug_mark+2),a  
a81a 18 03			jr .pastdmark  
a81c ..			.dmark: db "LSt"  
a81f f1			.pastdmark: pop af  
a820			endm  
# End of macro DMARK
a820					CALLMONITOR 
a820 cd 95 93			call break_point_state  
a823				endm  
# End of macro CALLMONITOR
a823				endif 
a823			 
a823			; cant push right now due to tokenised strings  
a823			 
a823			; get the destination of where to copy this definition to. 
a823			 
a823 c5					push bc 
a824 d1					pop de 
a825			 
a825 7e			.listl:         ld a,(hl) 
a826 fe 00				cp 0 
a828 28 09				jr z, .lreplsp     ; replace zero with space 
a82a					;cp FORTH_END_BUFFER 
a82a fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a82c 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a82e				 
a82e					; just copy this char as is then 
a82e			 
a82e 12					ld (de), a 
a82f			 
a82f 23			.listnxt:	inc hl 
a830 13					inc de 
a831 18 f2				jr .listl 
a833			 
a833 3e 20		.lreplsp:	ld a,' ' 
a835 12					ld (de), a 
a836 18 f7				jr .listnxt 
a838			 
a838			; close up uword def 
a838			 
a838			.listdone: 
a838 12					ld (de), a 
a839 13					inc de 
a83a 3e 00				ld a, 0 
a83c 12					ld (de), a 
a83d			 
a83d			; now have def so clean up and push to stack 
a83d			 
a83d 21 d7 e3				ld hl, scratch 
a840				if DEBUG_FORTH_WORDS 
a840					DMARK "Ltp" 
a840 f5				push af  
a841 3a 55 a8			ld a, (.dmark)  
a844 32 71 ee			ld (debug_mark),a  
a847 3a 56 a8			ld a, (.dmark+1)  
a84a 32 72 ee			ld (debug_mark+1),a  
a84d 3a 57 a8			ld a, (.dmark+2)  
a850 32 73 ee			ld (debug_mark+2),a  
a853 18 03			jr .pastdmark  
a855 ..			.dmark: db "Ltp"  
a858 f1			.pastdmark: pop af  
a859			endm  
# End of macro DMARK
a859					CALLMONITOR 
a859 cd 95 93			call break_point_state  
a85c				endm  
# End of macro CALLMONITOR
a85c				endif 
a85c			 
a85c 18 1f			jr .listpush 
a85e			 
a85e			;.lnuword:	pop hl 
a85e			;		call forth_tok_next 
a85e			;		jp .ldouscan  
a85e			 
a85e			.lunotfound:		  
a85e			 
a85e				if DEBUG_FORTH_WORDS 
a85e					DMARK "LSn" 
a85e f5				push af  
a85f 3a 73 a8			ld a, (.dmark)  
a862 32 71 ee			ld (debug_mark),a  
a865 3a 74 a8			ld a, (.dmark+1)  
a868 32 72 ee			ld (debug_mark+1),a  
a86b 3a 75 a8			ld a, (.dmark+2)  
a86e 32 73 ee			ld (debug_mark+2),a  
a871 18 03			jr .pastdmark  
a873 ..			.dmark: db "LSn"  
a876 f1			.pastdmark: pop af  
a877			endm  
# End of macro DMARK
a877					CALLMONITOR 
a877 cd 95 93			call break_point_state  
a87a				endm  
# End of macro CALLMONITOR
a87a				endif 
a87a			 
a87a					 
a87a			;		FORTH_DSP_POP 
a87a			;		ld hl, .luno 
a87a			 
a87a					NEXTW			 
a87a c3 69 9d			jp macro_next 
a87d				endm 
# End of macro NEXTW
a87d			 
a87d			.listpush: 
a87d				if DEBUG_FORTH_WORDS 
a87d					DMARK "LS>" 
a87d f5				push af  
a87e 3a 92 a8			ld a, (.dmark)  
a881 32 71 ee			ld (debug_mark),a  
a884 3a 93 a8			ld a, (.dmark+1)  
a887 32 72 ee			ld (debug_mark+1),a  
a88a 3a 94 a8			ld a, (.dmark+2)  
a88d 32 73 ee			ld (debug_mark+2),a  
a890 18 03			jr .pastdmark  
a892 ..			.dmark: db "LS>"  
a895 f1			.pastdmark: pop af  
a896			endm  
# End of macro DMARK
a896					CALLMONITOR 
a896 cd 95 93			call break_point_state  
a899				endm  
# End of macro CALLMONITOR
a899				endif 
a899 cd 6e 9a				call forth_push_str 
a89c			 
a89c			 
a89c			 
a89c					NEXTW 
a89c c3 69 9d			jp macro_next 
a89f				endm 
# End of macro NEXTW
a89f			 
a89f			;.luno:    db "Word not found",0 
a89f			 
a89f			 
a89f			 
a89f			 
a89f			 
a89f			;		push hl   ; save pointer to start of uword def string 
a89f			; 
a89f			;; look for FORTH_EOL_LINE 
a89f			;		ld a, FORTH_END_BUFFER 
a89f			;		call strlent 
a89f			; 
a89f			;		inc hl		 ; space for coln def 
a89f			;		inc hl 
a89f			;		inc hl          ; space for terms 
a89f			;		inc hl 
a89f			; 
a89f			;		ld a, 20   ; TODO get actual length 
a89f			;		call addatohl    ; include a random amount of room for the uword name 
a89f			; 
a89f			;		 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "Lt1" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			;		 
a89f			; 
a89f			;; malloc space for the string because we cant change it 
a89f			; 
a89f			;		call malloc 
a89f			;	if DEBUG_FORTH_MALLOC_GUARD 
a89f			;		push af 
a89f			;		call ishlzero 
a89f			;		pop af 
a89f			;		 
a89f			;		call z,malloc_error 
a89f			;	endif 
a89f			; 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "Lt2" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			;		pop de 
a89f			;		push hl    ; push the malloc to release later 
a89f			;		push hl   ;  push back a copy for the later stack push 
a89f			;		 
a89f			;; copy the string swapping out the zero terms for spaces 
a89f			; 
a89f			;		; de has our source 
a89f			;		; hl has our dest 
a89f			; 
a89f			;; add the coln def 
a89f			; 
a89f			;		ld a, ':' 
a89f			;		ld (hl), a 
a89f			;		inc hl 
a89f			;		ld a, ' ' 
a89f			;		ld (hl), a 
a89f			;		inc hl 
a89f			; 
a89f			;; add the uname word 
a89f			;		push de   ; save our string for now 
a89f			;		ex de, hl 
a89f			; 
a89f			;		FORTH_DSP_VALUE 
a89f			;		;v5 FORTH_DSP_VALUE 
a89f			; 
a89f			;		inc hl   ; skip type but we know by now this is OK 
a89f			; 
a89f			;.luword:	ld a,(hl) 
a89f			;		cp 0 
a89f			;		jr z, .luword2 
a89f			;		ld (de), a 
a89f			;		inc de 
a89f			;		inc hl 
a89f			;		jr .luword 
a89f			; 
a89f			;.luword2:	ld a, ' ' 
a89f			;		ld (de), a 
a89f			;;		inc hl 
a89f			;;		inc de 
a89f			;;		ld (de), a 
a89f			;;		inc hl 
a89f			;		inc de 
a89f			; 
a89f			;		ex de, hl 
a89f			;		pop de 
a89f			;		 
a89f			;		 
a89f			; 
a89f			;; detoken that string and copy it 
a89f			; 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "Lt2" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			;.ldetok:	ld a, (de) 
a89f			;		cp FORTH_END_BUFFER 
a89f			;		jr z, .ldetokend 
a89f			;		; swap out any zero term for space 
a89f			;		cp 0 
a89f			;		jr nz, .ldetoknext 
a89f			;		ld a, ' ' 
a89f			; 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "LtS" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			;.ldetoknext:	ld (hl), a 
a89f			;		inc de 
a89f			;		inc hl 
a89f			;		jr .ldetok 
a89f			; 
a89f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a89f			;		ld (hl), a  
a89f			; 
a89f			;; free that temp malloc 
a89f			; 
a89f			;		pop hl    
a89f			; 
a89f			;	if DEBUG_FORTH_WORDS 
a89f			;		DMARK "Lt4" 
a89f			;		CALLMONITOR 
a89f			;	endif 
a89f			;		call forth_apushstrhl 
a89f			; 
a89f			;		; get rid of temp malloc area 
a89f			; 
a89f			;		pop hl 
a89f			;		call free 
a89f			; 
a89f			;		jr .ludone 
a89f			; 
a89f			;.lnuword:	pop hl 
a89f			;		call forth_tok_next 
a89f			;		jp .ldouscan  
a89f			; 
a89f			;.ludone:		 pop hl 
a89f			; 
a89f					NEXTW 
a89f c3 69 9d			jp macro_next 
a8a2				endm 
# End of macro NEXTW
a8a2			 
a8a2			.FORGET: 
a8a2				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a8a2 5d				db WORD_SYS_CORE+73             
a8a3 1b a9			dw .NOP            
a8a5 07				db 6 + 1 
a8a6 .. 00			db "FORGET",0              
a8ad				endm 
# End of macro CWHEAD
a8ad			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a8ad			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a8ad			; | |  
a8ad			; | | e.g. "MORE" forget 
a8ad					if DEBUG_FORTH_WORDS_KEY 
a8ad						DMARK "FRG" 
a8ad f5				push af  
a8ae 3a c2 a8			ld a, (.dmark)  
a8b1 32 71 ee			ld (debug_mark),a  
a8b4 3a c3 a8			ld a, (.dmark+1)  
a8b7 32 72 ee			ld (debug_mark+1),a  
a8ba 3a c4 a8			ld a, (.dmark+2)  
a8bd 32 73 ee			ld (debug_mark+2),a  
a8c0 18 03			jr .pastdmark  
a8c2 ..			.dmark: db "FRG"  
a8c5 f1			.pastdmark: pop af  
a8c6			endm  
# End of macro DMARK
a8c6						CALLMONITOR 
a8c6 cd 95 93			call break_point_state  
a8c9				endm  
# End of macro CALLMONITOR
a8c9					endif 
a8c9			 
a8c9				; find uword 
a8c9			        ; update start of word with "_" 
a8c9				; replace uword with deleted flag 
a8c9			 
a8c9			 
a8c9			;	if DEBUG_FORTH_WORDS 
a8c9			;		DMARK "FOG" 
a8c9			;		CALLMONITOR 
a8c9			;	endif 
a8c9			 
a8c9			 
a8c9					; Get ptr to the word we need to look up 
a8c9			 
a8c9					FORTH_DSP_VALUEHL 
a8c9 cd f7 9b			call macro_dsp_valuehl 
a8cc				endm 
# End of macro FORTH_DSP_VALUEHL
a8cc					;v5 FORTH_DSP_VALUE 
a8cc				; TODO type check 
a8cc			;		inc hl    ; Skip type check  
a8cc e5					push hl 
a8cd c1					pop bc 
a8ce			;		ex de, hl    ; put into DE 
a8ce			 
a8ce			 
a8ce 21 15 d9				ld hl, baseram 
a8d1					;ld hl, baseusermem 
a8d1			 
a8d1				; skip dict stub 
a8d1			;	call forth_tok_next 
a8d1 e5			push hl   ; sacreifical push 
a8d2			 
a8d2			.fldouscanm: 
a8d2 e1				pop hl 
a8d3			.fldouscan: 
a8d3			;	if DEBUG_FORTH_WORDS 
a8d3			;		DMARK "LSs" 
a8d3			;		CALLMONITOR 
a8d3			;	endif 
a8d3				; skip dict stub 
a8d3 cd ba 9e				call forth_tok_next 
a8d6			 
a8d6			 
a8d6			; while we have words to look for 
a8d6			 
a8d6 7e				ld a, (hl)      
a8d7			;	if DEBUG_FORTH_WORDS 
a8d7			;		DMARK "LSk" 
a8d7			;		CALLMONITOR 
a8d7			;	endif 
a8d7 fe 00				cp WORD_SYS_END 
a8d9 ca 15 a9				jp z, .flunotfound 
a8dc fe 01				cp WORD_SYS_UWORD 
a8de c2 d3 a8				jp nz, .fldouscan 
a8e1			 
a8e1			;	if DEBUG_FORTH_WORDS 
a8e1			;		DMARK "LSu" 
a8e1			;		CALLMONITOR 
a8e1			;	endif 
a8e1			 
a8e1					; found a uword but is it the one we want... 
a8e1			 
a8e1 c5					push bc     ; uword to find is on bc 
a8e2 d1					pop de 
a8e3			 
a8e3 e5					push hl  ; to save the ptr 
a8e4			 
a8e4					; skip opcode 
a8e4 23					inc hl  
a8e5					; skip next ptr 
a8e5 23					inc hl  
a8e6 23					inc hl 
a8e7					; skip len 
a8e7 23					inc hl 
a8e8			 
a8e8			;	if DEBUG_FORTH_WORDS 
a8e8			;		DMARK "LSc" 
a8e8			;		CALLMONITOR 
a8e8			;	endif 
a8e8 cd 2a 90				call strcmp 
a8eb c2 d2 a8				jp nz, .fldouscanm 
a8ee			; 
a8ee			; 
a8ee			;; while we have words to look for 
a8ee			; 
a8ee			;.fdouscan:	ld a, (hl)      
a8ee			;	if DEBUG_FORTH_WORDS 
a8ee			;		DMARK "LSs" 
a8ee			;		CALLMONITOR 
a8ee			;	endif 
a8ee			;		cp WORD_SYS_END 
a8ee			;		jp z, .fudone 
a8ee			;		cp WORD_SYS_UWORD 
a8ee			;		jp nz, .fnuword 
a8ee			; 
a8ee			;	if DEBUG_FORTH_WORDS 
a8ee			;		DMARK "FGu" 
a8ee			;		CALLMONITOR 
a8ee			;	endif 
a8ee			; 
a8ee			;		; found a uword but is it the one we want... 
a8ee			; 
a8ee			; 
a8ee			;	        pop de   ; get back the dsp name 
a8ee			;		push de 
a8ee			; 
a8ee			;		push hl  ; to save the ptr 
a8ee			; 
a8ee			;		; skip opcode 
a8ee			;		inc hl  
a8ee			;		; skip next ptr 
a8ee			;		inc hl  
a8ee			;		inc hl 
a8ee			;		; skip len 
a8ee			;		inc hl 
a8ee			; 
a8ee			;	if DEBUG_FORTH_WORDS 
a8ee			;		DMARK "FGc" 
a8ee			;		CALLMONITOR 
a8ee			;	endif 
a8ee			;		call strcmp 
a8ee			;		jp nz, .fnuword 
a8ee			 
a8ee			 
a8ee e1			pop hl 
a8ef			 
a8ef				 
a8ef				if DEBUG_FORTH_WORDS 
a8ef					DMARK "FGm" 
a8ef f5				push af  
a8f0 3a 04 a9			ld a, (.dmark)  
a8f3 32 71 ee			ld (debug_mark),a  
a8f6 3a 05 a9			ld a, (.dmark+1)  
a8f9 32 72 ee			ld (debug_mark+1),a  
a8fc 3a 06 a9			ld a, (.dmark+2)  
a8ff 32 73 ee			ld (debug_mark+2),a  
a902 18 03			jr .pastdmark  
a904 ..			.dmark: db "FGm"  
a907 f1			.pastdmark: pop af  
a908			endm  
# End of macro DMARK
a908					CALLMONITOR 
a908 cd 95 93			call break_point_state  
a90b				endm  
# End of macro CALLMONITOR
a90b				endif 
a90b			 
a90b			 
a90b			 
a90b					; we have a uword so push its name to the stack 
a90b			 
a90b			;	   	push hl  ; save so we can move to next dict block 
a90b			;pop hl 
a90b			 
a90b					; update opcode to deleted 
a90b 3e 03				ld a, WORD_SYS_DELETED 
a90d 77					ld (hl), a 
a90e			 
a90e 23					inc hl  
a90f					; skip next ptr 
a90f 23					inc hl  
a910 23					inc hl 
a911					; skip len 
a911 23					inc hl 
a912			 
a912					; TODO change parser to skip deleted words but for now mark it out 
a912 3e 5f				ld a, "_" 
a914 77					ld  (hl),a 
a915			 
a915			;		jr .fudone 
a915			; 
a915			;.fnuword:	pop hl 
a915			;		call forth_tok_next 
a915			;		jp .fdouscan  
a915			 
a915			.flunotfound:		  
a915			 
a915			 
a915					 
a915					FORTH_DSP_POP 
a915 cd af 9c			call macro_forth_dsp_pop 
a918				endm 
# End of macro FORTH_DSP_POP
a918			;		ld hl, .luno 
a918			;.fudone:		 pop hl 
a918					NEXTW 
a918 c3 69 9d			jp macro_next 
a91b				endm 
# End of macro NEXTW
a91b			.NOP: 
a91b				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a91b 61				db WORD_SYS_CORE+77             
a91c 42 a9			dw .COMO            
a91e 04				db 3 + 1 
a91f .. 00			db "NOP",0              
a923				endm 
# End of macro CWHEAD
a923			; | NOP (  --  ) Do nothing | DONE 
a923					if DEBUG_FORTH_WORDS_KEY 
a923						DMARK "NOP" 
a923 f5				push af  
a924 3a 38 a9			ld a, (.dmark)  
a927 32 71 ee			ld (debug_mark),a  
a92a 3a 39 a9			ld a, (.dmark+1)  
a92d 32 72 ee			ld (debug_mark+1),a  
a930 3a 3a a9			ld a, (.dmark+2)  
a933 32 73 ee			ld (debug_mark+2),a  
a936 18 03			jr .pastdmark  
a938 ..			.dmark: db "NOP"  
a93b f1			.pastdmark: pop af  
a93c			endm  
# End of macro DMARK
a93c						CALLMONITOR 
a93c cd 95 93			call break_point_state  
a93f				endm  
# End of macro CALLMONITOR
a93f					endif 
a93f				       NEXTW 
a93f c3 69 9d			jp macro_next 
a942				endm 
# End of macro NEXTW
a942			.COMO: 
a942				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a942 6e				db WORD_SYS_CORE+90             
a943 94 a9			dw .COMC            
a945 02				db 1 + 1 
a946 .. 00			db "(",0              
a948				endm 
# End of macro CWHEAD
a948			; | ( ( -- )  Start of comment | DONE 
a948			 
a948			 
a948 2a d8 e6				ld hl, ( os_tok_ptr) 
a94b 11 8f a9			ld de, .closepar 
a94e					 
a94e					if DEBUG_FORTH_WORDS 
a94e						DMARK ").." 
a94e f5				push af  
a94f 3a 63 a9			ld a, (.dmark)  
a952 32 71 ee			ld (debug_mark),a  
a955 3a 64 a9			ld a, (.dmark+1)  
a958 32 72 ee			ld (debug_mark+1),a  
a95b 3a 65 a9			ld a, (.dmark+2)  
a95e 32 73 ee			ld (debug_mark+2),a  
a961 18 03			jr .pastdmark  
a963 ..			.dmark: db ").."  
a966 f1			.pastdmark: pop af  
a967			endm  
# End of macro DMARK
a967						CALLMONITOR 
a967 cd 95 93			call break_point_state  
a96a				endm  
# End of macro CALLMONITOR
a96a					endif 
a96a cd 84 9e			call findnexttok  
a96d			 
a96d					if DEBUG_FORTH_WORDS 
a96d						DMARK "IF5" 
a96d f5				push af  
a96e 3a 82 a9			ld a, (.dmark)  
a971 32 71 ee			ld (debug_mark),a  
a974 3a 83 a9			ld a, (.dmark+1)  
a977 32 72 ee			ld (debug_mark+1),a  
a97a 3a 84 a9			ld a, (.dmark+2)  
a97d 32 73 ee			ld (debug_mark+2),a  
a980 18 03			jr .pastdmark  
a982 ..			.dmark: db "IF5"  
a985 f1			.pastdmark: pop af  
a986			endm  
# End of macro DMARK
a986						CALLMONITOR 
a986 cd 95 93			call break_point_state  
a989				endm  
# End of macro CALLMONITOR
a989					endif 
a989				; replace below with ) exec using tok_ptr 
a989 22 d8 e6			ld (os_tok_ptr), hl 
a98c c3 fa 9d			jp exec1 
a98f			 
a98f .. 00			.closepar:   db ")",0 
a991			 
a991				       NEXTW 
a991 c3 69 9d			jp macro_next 
a994				endm 
# End of macro NEXTW
a994			.COMC: 
a994				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a994 6f				db WORD_SYS_CORE+91             
a995 9d a9			dw .SCRATCH            
a997 02				db 1 + 1 
a998 .. 00			db ")",0              
a99a				endm 
# End of macro CWHEAD
a99a			; | ) ( -- )  End of comment |  DONE  
a99a				       NEXTW 
a99a c3 69 9d			jp macro_next 
a99d				endm 
# End of macro NEXTW
a99d			 
a99d			.SCRATCH: 
a99d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a99d 6f				db WORD_SYS_CORE+91             
a99e d8 a9			dw .INC            
a9a0 08				db 7 + 1 
a9a1 .. 00			db "SCRATCH",0              
a9a9				endm 
# End of macro CWHEAD
a9a9			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a9a9			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a9a9			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a9a9			; | |  
a9a9			; | | e.g.    : score $00 scratch ; 
a9a9			; | |  
a9a9			; | | $00 score ! 
a9a9			; | | $01 score +! 
a9a9			; | |  
a9a9			; | | e.g.   : varword $0a scratch ;  
a9a9			; | | 
a9a9			; | | $8000 varword ! 
a9a9					if DEBUG_FORTH_WORDS_KEY 
a9a9						DMARK "SCR" 
a9a9 f5				push af  
a9aa 3a be a9			ld a, (.dmark)  
a9ad 32 71 ee			ld (debug_mark),a  
a9b0 3a bf a9			ld a, (.dmark+1)  
a9b3 32 72 ee			ld (debug_mark+1),a  
a9b6 3a c0 a9			ld a, (.dmark+2)  
a9b9 32 73 ee			ld (debug_mark+2),a  
a9bc 18 03			jr .pastdmark  
a9be ..			.dmark: db "SCR"  
a9c1 f1			.pastdmark: pop af  
a9c2			endm  
# End of macro DMARK
a9c2						CALLMONITOR 
a9c2 cd 95 93			call break_point_state  
a9c5				endm  
# End of macro CALLMONITOR
a9c5					endif 
a9c5			 
a9c5					FORTH_DSP_VALUEHL 
a9c5 cd f7 9b			call macro_dsp_valuehl 
a9c8				endm 
# End of macro FORTH_DSP_VALUEHL
a9c8				 
a9c8					FORTH_DSP_POP 
a9c8 cd af 9c			call macro_forth_dsp_pop 
a9cb				endm 
# End of macro FORTH_DSP_POP
a9cb			 
a9cb 7d					ld a, l 
a9cc 21 fc e8				ld hl, os_var_array 
a9cf cd 94 8b				call addatohl 
a9d2			 
a9d2 cd 00 9a				call forth_push_numhl 
a9d5			 
a9d5				       NEXTW 
a9d5 c3 69 9d			jp macro_next 
a9d8				endm 
# End of macro NEXTW
a9d8			 
a9d8			.INC: 
a9d8				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a9d8 6f				db WORD_SYS_CORE+91             
a9d9 2c aa			dw .DEC            
a9db 03				db 2 + 1 
a9dc .. 00			db "+!",0              
a9df				endm 
# End of macro CWHEAD
a9df			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a9df					if DEBUG_FORTH_WORDS_KEY 
a9df						DMARK "+s_" 
a9df f5				push af  
a9e0 3a f4 a9			ld a, (.dmark)  
a9e3 32 71 ee			ld (debug_mark),a  
a9e6 3a f5 a9			ld a, (.dmark+1)  
a9e9 32 72 ee			ld (debug_mark+1),a  
a9ec 3a f6 a9			ld a, (.dmark+2)  
a9ef 32 73 ee			ld (debug_mark+2),a  
a9f2 18 03			jr .pastdmark  
a9f4 ..			.dmark: db "+s_"  
a9f7 f1			.pastdmark: pop af  
a9f8			endm  
# End of macro DMARK
a9f8						CALLMONITOR 
a9f8 cd 95 93			call break_point_state  
a9fb				endm  
# End of macro CALLMONITOR
a9fb					endif 
a9fb			 
a9fb					FORTH_DSP_VALUEHL 
a9fb cd f7 9b			call macro_dsp_valuehl 
a9fe				endm 
# End of macro FORTH_DSP_VALUEHL
a9fe			 
a9fe e5					push hl   ; save address 
a9ff			 
a9ff					FORTH_DSP_POP 
a9ff cd af 9c			call macro_forth_dsp_pop 
aa02				endm 
# End of macro FORTH_DSP_POP
aa02			 
aa02					FORTH_DSP_VALUEHL 
aa02 cd f7 9b			call macro_dsp_valuehl 
aa05				endm 
# End of macro FORTH_DSP_VALUEHL
aa05			 
aa05					FORTH_DSP_POP 
aa05 cd af 9c			call macro_forth_dsp_pop 
aa08				endm 
# End of macro FORTH_DSP_POP
aa08			 
aa08					; hl contains value to add to byte at a 
aa08				 
aa08 eb					ex de, hl 
aa09			 
aa09 e1					pop hl 
aa0a			 
aa0a					if DEBUG_FORTH_WORDS 
aa0a						DMARK "INC" 
aa0a f5				push af  
aa0b 3a 1f aa			ld a, (.dmark)  
aa0e 32 71 ee			ld (debug_mark),a  
aa11 3a 20 aa			ld a, (.dmark+1)  
aa14 32 72 ee			ld (debug_mark+1),a  
aa17 3a 21 aa			ld a, (.dmark+2)  
aa1a 32 73 ee			ld (debug_mark+2),a  
aa1d 18 03			jr .pastdmark  
aa1f ..			.dmark: db "INC"  
aa22 f1			.pastdmark: pop af  
aa23			endm  
# End of macro DMARK
aa23						CALLMONITOR 
aa23 cd 95 93			call break_point_state  
aa26				endm  
# End of macro CALLMONITOR
aa26					endif 
aa26			 
aa26 7e					ld a,(hl) 
aa27 83					add e 
aa28 77					ld (hl),a 
aa29			 
aa29			 
aa29			 
aa29				       NEXTW 
aa29 c3 69 9d			jp macro_next 
aa2c				endm 
# End of macro NEXTW
aa2c			 
aa2c			.DEC: 
aa2c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aa2c 6f				db WORD_SYS_CORE+91             
aa2d 7d aa			dw .INC2            
aa2f 03				db 2 + 1 
aa30 .. 00			db "-!",0              
aa33				endm 
# End of macro CWHEAD
aa33			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aa33					if DEBUG_FORTH_WORDS_KEY 
aa33						DMARK "-s_" 
aa33 f5				push af  
aa34 3a 48 aa			ld a, (.dmark)  
aa37 32 71 ee			ld (debug_mark),a  
aa3a 3a 49 aa			ld a, (.dmark+1)  
aa3d 32 72 ee			ld (debug_mark+1),a  
aa40 3a 4a aa			ld a, (.dmark+2)  
aa43 32 73 ee			ld (debug_mark+2),a  
aa46 18 03			jr .pastdmark  
aa48 ..			.dmark: db "-s_"  
aa4b f1			.pastdmark: pop af  
aa4c			endm  
# End of macro DMARK
aa4c						CALLMONITOR 
aa4c cd 95 93			call break_point_state  
aa4f				endm  
# End of macro CALLMONITOR
aa4f					endif 
aa4f			 
aa4f					FORTH_DSP_VALUEHL 
aa4f cd f7 9b			call macro_dsp_valuehl 
aa52				endm 
# End of macro FORTH_DSP_VALUEHL
aa52			 
aa52 e5					push hl   ; save address 
aa53			 
aa53					FORTH_DSP_POP 
aa53 cd af 9c			call macro_forth_dsp_pop 
aa56				endm 
# End of macro FORTH_DSP_POP
aa56			 
aa56					FORTH_DSP_VALUEHL 
aa56 cd f7 9b			call macro_dsp_valuehl 
aa59				endm 
# End of macro FORTH_DSP_VALUEHL
aa59			 
aa59					; hl contains value to add to byte at a 
aa59				 
aa59 eb					ex de, hl 
aa5a			 
aa5a e1					pop hl 
aa5b			 
aa5b					if DEBUG_FORTH_WORDS 
aa5b						DMARK "DEC" 
aa5b f5				push af  
aa5c 3a 70 aa			ld a, (.dmark)  
aa5f 32 71 ee			ld (debug_mark),a  
aa62 3a 71 aa			ld a, (.dmark+1)  
aa65 32 72 ee			ld (debug_mark+1),a  
aa68 3a 72 aa			ld a, (.dmark+2)  
aa6b 32 73 ee			ld (debug_mark+2),a  
aa6e 18 03			jr .pastdmark  
aa70 ..			.dmark: db "DEC"  
aa73 f1			.pastdmark: pop af  
aa74			endm  
# End of macro DMARK
aa74						CALLMONITOR 
aa74 cd 95 93			call break_point_state  
aa77				endm  
# End of macro CALLMONITOR
aa77					endif 
aa77			 
aa77 7e					ld a,(hl) 
aa78 93					sub e 
aa79 77					ld (hl),a 
aa7a			 
aa7a			 
aa7a			 
aa7a				       NEXTW 
aa7a c3 69 9d			jp macro_next 
aa7d				endm 
# End of macro NEXTW
aa7d			 
aa7d			.INC2: 
aa7d				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
aa7d 6f				db WORD_SYS_CORE+91             
aa7e 27 ab			dw .DEC2            
aa80 04				db 3 + 1 
aa81 .. 00			db "+2!",0              
aa85				endm 
# End of macro CWHEAD
aa85			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
aa85			 
aa85					if DEBUG_FORTH_WORDS_KEY 
aa85						DMARK "+2s" 
aa85 f5				push af  
aa86 3a 9a aa			ld a, (.dmark)  
aa89 32 71 ee			ld (debug_mark),a  
aa8c 3a 9b aa			ld a, (.dmark+1)  
aa8f 32 72 ee			ld (debug_mark+1),a  
aa92 3a 9c aa			ld a, (.dmark+2)  
aa95 32 73 ee			ld (debug_mark+2),a  
aa98 18 03			jr .pastdmark  
aa9a ..			.dmark: db "+2s"  
aa9d f1			.pastdmark: pop af  
aa9e			endm  
# End of macro DMARK
aa9e						CALLMONITOR 
aa9e cd 95 93			call break_point_state  
aaa1				endm  
# End of macro CALLMONITOR
aaa1					endif 
aaa1			 
aaa1					; Address 
aaa1			 
aaa1					FORTH_DSP_VALUEHL 
aaa1 cd f7 9b			call macro_dsp_valuehl 
aaa4				endm 
# End of macro FORTH_DSP_VALUEHL
aaa4			 
aaa4 e5					push hl    ; save address 
aaa5			 
aaa5					; load content into de 
aaa5			 
aaa5 5e					ld e,(hl) 
aaa6 23					inc hl 
aaa7 56					ld d, (hl) 
aaa8			 
aaa8					if DEBUG_FORTH_WORDS 
aaa8						DMARK "+2a" 
aaa8 f5				push af  
aaa9 3a bd aa			ld a, (.dmark)  
aaac 32 71 ee			ld (debug_mark),a  
aaaf 3a be aa			ld a, (.dmark+1)  
aab2 32 72 ee			ld (debug_mark+1),a  
aab5 3a bf aa			ld a, (.dmark+2)  
aab8 32 73 ee			ld (debug_mark+2),a  
aabb 18 03			jr .pastdmark  
aabd ..			.dmark: db "+2a"  
aac0 f1			.pastdmark: pop af  
aac1			endm  
# End of macro DMARK
aac1						CALLMONITOR 
aac1 cd 95 93			call break_point_state  
aac4				endm  
# End of macro CALLMONITOR
aac4					endif 
aac4			 
aac4					FORTH_DSP_POP 
aac4 cd af 9c			call macro_forth_dsp_pop 
aac7				endm 
# End of macro FORTH_DSP_POP
aac7			 
aac7					; Get value to add 
aac7			 
aac7					FORTH_DSP_VALUE 
aac7 cd e0 9b			call macro_forth_dsp_value 
aaca				endm 
# End of macro FORTH_DSP_VALUE
aaca			 
aaca					if DEBUG_FORTH_WORDS 
aaca						DMARK "+2v" 
aaca f5				push af  
aacb 3a df aa			ld a, (.dmark)  
aace 32 71 ee			ld (debug_mark),a  
aad1 3a e0 aa			ld a, (.dmark+1)  
aad4 32 72 ee			ld (debug_mark+1),a  
aad7 3a e1 aa			ld a, (.dmark+2)  
aada 32 73 ee			ld (debug_mark+2),a  
aadd 18 03			jr .pastdmark  
aadf ..			.dmark: db "+2v"  
aae2 f1			.pastdmark: pop af  
aae3			endm  
# End of macro DMARK
aae3						CALLMONITOR 
aae3 cd 95 93			call break_point_state  
aae6				endm  
# End of macro CALLMONITOR
aae6					endif 
aae6			 
aae6 19					add hl, de 
aae7			 
aae7					if DEBUG_FORTH_WORDS 
aae7						DMARK "+2+" 
aae7 f5				push af  
aae8 3a fc aa			ld a, (.dmark)  
aaeb 32 71 ee			ld (debug_mark),a  
aaee 3a fd aa			ld a, (.dmark+1)  
aaf1 32 72 ee			ld (debug_mark+1),a  
aaf4 3a fe aa			ld a, (.dmark+2)  
aaf7 32 73 ee			ld (debug_mark+2),a  
aafa 18 03			jr .pastdmark  
aafc ..			.dmark: db "+2+"  
aaff f1			.pastdmark: pop af  
ab00			endm  
# End of macro DMARK
ab00						CALLMONITOR 
ab00 cd 95 93			call break_point_state  
ab03				endm  
# End of macro CALLMONITOR
ab03					endif 
ab03			 
ab03					; move result to de 
ab03			 
ab03 eb					ex de, hl 
ab04			 
ab04					; Address 
ab04			 
ab04 e1					pop hl 
ab05			 
ab05					; save it back 
ab05			 
ab05 73					ld (hl), e 
ab06 23					inc hl 
ab07 72					ld (hl), d 
ab08			 
ab08					if DEBUG_FORTH_WORDS 
ab08						DMARK "+2e" 
ab08 f5				push af  
ab09 3a 1d ab			ld a, (.dmark)  
ab0c 32 71 ee			ld (debug_mark),a  
ab0f 3a 1e ab			ld a, (.dmark+1)  
ab12 32 72 ee			ld (debug_mark+1),a  
ab15 3a 1f ab			ld a, (.dmark+2)  
ab18 32 73 ee			ld (debug_mark+2),a  
ab1b 18 03			jr .pastdmark  
ab1d ..			.dmark: db "+2e"  
ab20 f1			.pastdmark: pop af  
ab21			endm  
# End of macro DMARK
ab21						CALLMONITOR 
ab21 cd 95 93			call break_point_state  
ab24				endm  
# End of macro CALLMONITOR
ab24					endif 
ab24			 
ab24			 
ab24			 
ab24			 
ab24			 
ab24				       NEXTW 
ab24 c3 69 9d			jp macro_next 
ab27				endm 
# End of macro NEXTW
ab27			 
ab27			.DEC2: 
ab27				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ab27 6f				db WORD_SYS_CORE+91             
ab28 d3 ab			dw .GET2            
ab2a 04				db 3 + 1 
ab2b .. 00			db "-2!",0              
ab2f				endm 
# End of macro CWHEAD
ab2f			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ab2f			 
ab2f			 
ab2f					if DEBUG_FORTH_WORDS_KEY 
ab2f						DMARK "-2s" 
ab2f f5				push af  
ab30 3a 44 ab			ld a, (.dmark)  
ab33 32 71 ee			ld (debug_mark),a  
ab36 3a 45 ab			ld a, (.dmark+1)  
ab39 32 72 ee			ld (debug_mark+1),a  
ab3c 3a 46 ab			ld a, (.dmark+2)  
ab3f 32 73 ee			ld (debug_mark+2),a  
ab42 18 03			jr .pastdmark  
ab44 ..			.dmark: db "-2s"  
ab47 f1			.pastdmark: pop af  
ab48			endm  
# End of macro DMARK
ab48						CALLMONITOR 
ab48 cd 95 93			call break_point_state  
ab4b				endm  
# End of macro CALLMONITOR
ab4b					endif 
ab4b			 
ab4b					; Address 
ab4b			 
ab4b					FORTH_DSP_VALUEHL 
ab4b cd f7 9b			call macro_dsp_valuehl 
ab4e				endm 
# End of macro FORTH_DSP_VALUEHL
ab4e			 
ab4e e5					push hl    ; save address 
ab4f			 
ab4f					; load content into de 
ab4f			 
ab4f 5e					ld e,(hl) 
ab50 23					inc hl 
ab51 56					ld d, (hl) 
ab52			 
ab52					if DEBUG_FORTH_WORDS 
ab52						DMARK "-2a" 
ab52 f5				push af  
ab53 3a 67 ab			ld a, (.dmark)  
ab56 32 71 ee			ld (debug_mark),a  
ab59 3a 68 ab			ld a, (.dmark+1)  
ab5c 32 72 ee			ld (debug_mark+1),a  
ab5f 3a 69 ab			ld a, (.dmark+2)  
ab62 32 73 ee			ld (debug_mark+2),a  
ab65 18 03			jr .pastdmark  
ab67 ..			.dmark: db "-2a"  
ab6a f1			.pastdmark: pop af  
ab6b			endm  
# End of macro DMARK
ab6b						CALLMONITOR 
ab6b cd 95 93			call break_point_state  
ab6e				endm  
# End of macro CALLMONITOR
ab6e					endif 
ab6e			 
ab6e					FORTH_DSP_POP 
ab6e cd af 9c			call macro_forth_dsp_pop 
ab71				endm 
# End of macro FORTH_DSP_POP
ab71			 
ab71					; Get value to remove 
ab71			 
ab71					FORTH_DSP_VALUE 
ab71 cd e0 9b			call macro_forth_dsp_value 
ab74				endm 
# End of macro FORTH_DSP_VALUE
ab74			 
ab74					if DEBUG_FORTH_WORDS 
ab74						DMARK "-2v" 
ab74 f5				push af  
ab75 3a 89 ab			ld a, (.dmark)  
ab78 32 71 ee			ld (debug_mark),a  
ab7b 3a 8a ab			ld a, (.dmark+1)  
ab7e 32 72 ee			ld (debug_mark+1),a  
ab81 3a 8b ab			ld a, (.dmark+2)  
ab84 32 73 ee			ld (debug_mark+2),a  
ab87 18 03			jr .pastdmark  
ab89 ..			.dmark: db "-2v"  
ab8c f1			.pastdmark: pop af  
ab8d			endm  
# End of macro DMARK
ab8d						CALLMONITOR 
ab8d cd 95 93			call break_point_state  
ab90				endm  
# End of macro CALLMONITOR
ab90					endif 
ab90			 
ab90 eb					ex de, hl 
ab91 ed 52				sbc hl, de 
ab93			 
ab93					if DEBUG_FORTH_WORDS 
ab93						DMARK "-2d" 
ab93 f5				push af  
ab94 3a a8 ab			ld a, (.dmark)  
ab97 32 71 ee			ld (debug_mark),a  
ab9a 3a a9 ab			ld a, (.dmark+1)  
ab9d 32 72 ee			ld (debug_mark+1),a  
aba0 3a aa ab			ld a, (.dmark+2)  
aba3 32 73 ee			ld (debug_mark+2),a  
aba6 18 03			jr .pastdmark  
aba8 ..			.dmark: db "-2d"  
abab f1			.pastdmark: pop af  
abac			endm  
# End of macro DMARK
abac						CALLMONITOR 
abac cd 95 93			call break_point_state  
abaf				endm  
# End of macro CALLMONITOR
abaf					endif 
abaf			 
abaf					; move result to de 
abaf			 
abaf eb					ex de, hl 
abb0			 
abb0					; Address 
abb0			 
abb0 e1					pop hl 
abb1			 
abb1					; save it back 
abb1			 
abb1 73					ld (hl), e 
abb2 23					inc hl 
abb3 72					ld (hl), d 
abb4			 
abb4					if DEBUG_FORTH_WORDS 
abb4						DMARK "-2e" 
abb4 f5				push af  
abb5 3a c9 ab			ld a, (.dmark)  
abb8 32 71 ee			ld (debug_mark),a  
abbb 3a ca ab			ld a, (.dmark+1)  
abbe 32 72 ee			ld (debug_mark+1),a  
abc1 3a cb ab			ld a, (.dmark+2)  
abc4 32 73 ee			ld (debug_mark+2),a  
abc7 18 03			jr .pastdmark  
abc9 ..			.dmark: db "-2e"  
abcc f1			.pastdmark: pop af  
abcd			endm  
# End of macro DMARK
abcd						CALLMONITOR 
abcd cd 95 93			call break_point_state  
abd0				endm  
# End of macro CALLMONITOR
abd0					endif 
abd0			 
abd0			 
abd0			 
abd0			 
abd0			 
abd0				       NEXTW 
abd0 c3 69 9d			jp macro_next 
abd3				endm 
# End of macro NEXTW
abd3			.GET2: 
abd3				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
abd3 6f				db WORD_SYS_CORE+91             
abd4 03 ac			dw .BANG2            
abd6 03				db 2 + 1 
abd7 .. 00			db "2@",0              
abda				endm 
# End of macro CWHEAD
abda			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
abda					if DEBUG_FORTH_WORDS_KEY 
abda						DMARK "2A_" 
abda f5				push af  
abdb 3a ef ab			ld a, (.dmark)  
abde 32 71 ee			ld (debug_mark),a  
abe1 3a f0 ab			ld a, (.dmark+1)  
abe4 32 72 ee			ld (debug_mark+1),a  
abe7 3a f1 ab			ld a, (.dmark+2)  
abea 32 73 ee			ld (debug_mark+2),a  
abed 18 03			jr .pastdmark  
abef ..			.dmark: db "2A_"  
abf2 f1			.pastdmark: pop af  
abf3			endm  
# End of macro DMARK
abf3						CALLMONITOR 
abf3 cd 95 93			call break_point_state  
abf6				endm  
# End of macro CALLMONITOR
abf6					endif 
abf6			 
abf6					FORTH_DSP_VALUEHL 
abf6 cd f7 9b			call macro_dsp_valuehl 
abf9				endm 
# End of macro FORTH_DSP_VALUEHL
abf9			 
abf9 5e					ld e, (hl) 
abfa 23					inc hl 
abfb 56					ld d, (hl) 
abfc			 
abfc eb					ex de, hl 
abfd			 
abfd cd 00 9a				call forth_push_numhl 
ac00			 
ac00				       NEXTW 
ac00 c3 69 9d			jp macro_next 
ac03				endm 
# End of macro NEXTW
ac03			.BANG2: 
ac03				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ac03 6f				db WORD_SYS_CORE+91             
ac04 3b ac			dw .CONFIG            
ac06 03				db 2 + 1 
ac07 .. 00			db "2!",0              
ac0a				endm 
# End of macro CWHEAD
ac0a			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ac0a					if DEBUG_FORTH_WORDS_KEY 
ac0a						DMARK "2S_" 
ac0a f5				push af  
ac0b 3a 1f ac			ld a, (.dmark)  
ac0e 32 71 ee			ld (debug_mark),a  
ac11 3a 20 ac			ld a, (.dmark+1)  
ac14 32 72 ee			ld (debug_mark+1),a  
ac17 3a 21 ac			ld a, (.dmark+2)  
ac1a 32 73 ee			ld (debug_mark+2),a  
ac1d 18 03			jr .pastdmark  
ac1f ..			.dmark: db "2S_"  
ac22 f1			.pastdmark: pop af  
ac23			endm  
# End of macro DMARK
ac23						CALLMONITOR 
ac23 cd 95 93			call break_point_state  
ac26				endm  
# End of macro CALLMONITOR
ac26					endif 
ac26			 
ac26					FORTH_DSP_VALUEHL 
ac26 cd f7 9b			call macro_dsp_valuehl 
ac29				endm 
# End of macro FORTH_DSP_VALUEHL
ac29			 
ac29 e5					push hl   ; save address 
ac2a			 
ac2a			 
ac2a					FORTH_DSP_POP 
ac2a cd af 9c			call macro_forth_dsp_pop 
ac2d				endm 
# End of macro FORTH_DSP_POP
ac2d			 
ac2d					 
ac2d					FORTH_DSP_VALUEHL 
ac2d cd f7 9b			call macro_dsp_valuehl 
ac30				endm 
# End of macro FORTH_DSP_VALUEHL
ac30			 
ac30					FORTH_DSP_POP 
ac30 cd af 9c			call macro_forth_dsp_pop 
ac33				endm 
# End of macro FORTH_DSP_POP
ac33			 
ac33 eb					ex de, hl    ; value now in de 
ac34			 
ac34 e1					pop hl 
ac35			 
ac35 73					ld (hl), e 
ac36			 
ac36 23					inc hl 
ac37			 
ac37 72					ld (hl), d 
ac38			 
ac38			 
ac38				       NEXTW 
ac38 c3 69 9d			jp macro_next 
ac3b				endm 
# End of macro NEXTW
ac3b			.CONFIG: 
ac3b				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ac3b 6f				db WORD_SYS_CORE+91             
ac3c 4c ac			dw .ENDCORE            
ac3e 07				db 6 + 1 
ac3f .. 00			db "CONFIG",0              
ac46				endm 
# End of macro CWHEAD
ac46			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ac46			 
ac46 cd f4 91				call config 
ac49					NEXTW 
ac49 c3 69 9d			jp macro_next 
ac4c				endm 
# End of macro NEXTW
ac4c			.ENDCORE: 
ac4c			 
ac4c			; eof 
ac4c			 
ac4c			 
# End of file forth_words_core.asm
ac4c			include "forth_words_flow.asm" 
ac4c			 
ac4c			; | ## Program Flow Words 
ac4c			 
ac4c			.IF: 
ac4c				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ac4c 1e				db WORD_SYS_CORE+10             
ac4d 41 ad			dw .THEN            
ac4f 03				db 2 + 1 
ac50 .. 00			db "IF",0              
ac53				endm 
# End of macro CWHEAD
ac53			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ac53			; 
ac53					if DEBUG_FORTH_WORDS_KEY 
ac53						DMARK "IF." 
ac53 f5				push af  
ac54 3a 68 ac			ld a, (.dmark)  
ac57 32 71 ee			ld (debug_mark),a  
ac5a 3a 69 ac			ld a, (.dmark+1)  
ac5d 32 72 ee			ld (debug_mark+1),a  
ac60 3a 6a ac			ld a, (.dmark+2)  
ac63 32 73 ee			ld (debug_mark+2),a  
ac66 18 03			jr .pastdmark  
ac68 ..			.dmark: db "IF."  
ac6b f1			.pastdmark: pop af  
ac6c			endm  
# End of macro DMARK
ac6c						CALLMONITOR 
ac6c cd 95 93			call break_point_state  
ac6f				endm  
# End of macro CALLMONITOR
ac6f					endif 
ac6f			; eval TOS 
ac6f			 
ac6f				FORTH_DSP_VALUEHL 
ac6f cd f7 9b			call macro_dsp_valuehl 
ac72				endm 
# End of macro FORTH_DSP_VALUEHL
ac72			 
ac72			;	push hl 
ac72				FORTH_DSP_POP 
ac72 cd af 9c			call macro_forth_dsp_pop 
ac75				endm 
# End of macro FORTH_DSP_POP
ac75			;	pop hl 
ac75			 
ac75					if DEBUG_FORTH_WORDS 
ac75						DMARK "IF1" 
ac75 f5				push af  
ac76 3a 8a ac			ld a, (.dmark)  
ac79 32 71 ee			ld (debug_mark),a  
ac7c 3a 8b ac			ld a, (.dmark+1)  
ac7f 32 72 ee			ld (debug_mark+1),a  
ac82 3a 8c ac			ld a, (.dmark+2)  
ac85 32 73 ee			ld (debug_mark+2),a  
ac88 18 03			jr .pastdmark  
ac8a ..			.dmark: db "IF1"  
ac8d f1			.pastdmark: pop af  
ac8e			endm  
# End of macro DMARK
ac8e						CALLMONITOR 
ac8e cd 95 93			call break_point_state  
ac91				endm  
# End of macro CALLMONITOR
ac91					endif 
ac91 b7				or a        ; clear carry flag 
ac92 11 00 00			ld de, 0 
ac95 eb				ex de,hl 
ac96 ed 52			sbc hl, de 
ac98 c2 22 ad			jp nz, .iftrue 
ac9b			 
ac9b					if DEBUG_FORTH_WORDS 
ac9b						DMARK "IF2" 
ac9b f5				push af  
ac9c 3a b0 ac			ld a, (.dmark)  
ac9f 32 71 ee			ld (debug_mark),a  
aca2 3a b1 ac			ld a, (.dmark+1)  
aca5 32 72 ee			ld (debug_mark+1),a  
aca8 3a b2 ac			ld a, (.dmark+2)  
acab 32 73 ee			ld (debug_mark+2),a  
acae 18 03			jr .pastdmark  
acb0 ..			.dmark: db "IF2"  
acb3 f1			.pastdmark: pop af  
acb4			endm  
# End of macro DMARK
acb4						CALLMONITOR 
acb4 cd 95 93			call break_point_state  
acb7				endm  
# End of macro CALLMONITOR
acb7					endif 
acb7			 
acb7			; if not true then skip to THEN 
acb7			 
acb7				; TODO get tok_ptr 
acb7				; TODO consume toks until we get to THEN 
acb7			 
acb7 2a d8 e6			ld hl, (os_tok_ptr) 
acba					if DEBUG_FORTH_WORDS 
acba						DMARK "IF3" 
acba f5				push af  
acbb 3a cf ac			ld a, (.dmark)  
acbe 32 71 ee			ld (debug_mark),a  
acc1 3a d0 ac			ld a, (.dmark+1)  
acc4 32 72 ee			ld (debug_mark+1),a  
acc7 3a d1 ac			ld a, (.dmark+2)  
acca 32 73 ee			ld (debug_mark+2),a  
accd 18 03			jr .pastdmark  
accf ..			.dmark: db "IF3"  
acd2 f1			.pastdmark: pop af  
acd3			endm  
# End of macro DMARK
acd3						CALLMONITOR 
acd3 cd 95 93			call break_point_state  
acd6				endm  
# End of macro CALLMONITOR
acd6						 
acd6					endif 
acd6 11 1d ad			ld de, .ifthen 
acd9					if DEBUG_FORTH_WORDS 
acd9						DMARK "IF4" 
acd9 f5				push af  
acda 3a ee ac			ld a, (.dmark)  
acdd 32 71 ee			ld (debug_mark),a  
ace0 3a ef ac			ld a, (.dmark+1)  
ace3 32 72 ee			ld (debug_mark+1),a  
ace6 3a f0 ac			ld a, (.dmark+2)  
ace9 32 73 ee			ld (debug_mark+2),a  
acec 18 03			jr .pastdmark  
acee ..			.dmark: db "IF4"  
acf1 f1			.pastdmark: pop af  
acf2			endm  
# End of macro DMARK
acf2						CALLMONITOR 
acf2 cd 95 93			call break_point_state  
acf5				endm  
# End of macro CALLMONITOR
acf5					endif 
acf5 cd 84 9e			call findnexttok  
acf8			 
acf8					if DEBUG_FORTH_WORDS 
acf8						DMARK "IF5" 
acf8 f5				push af  
acf9 3a 0d ad			ld a, (.dmark)  
acfc 32 71 ee			ld (debug_mark),a  
acff 3a 0e ad			ld a, (.dmark+1)  
ad02 32 72 ee			ld (debug_mark+1),a  
ad05 3a 0f ad			ld a, (.dmark+2)  
ad08 32 73 ee			ld (debug_mark+2),a  
ad0b 18 03			jr .pastdmark  
ad0d ..			.dmark: db "IF5"  
ad10 f1			.pastdmark: pop af  
ad11			endm  
# End of macro DMARK
ad11						CALLMONITOR 
ad11 cd 95 93			call break_point_state  
ad14				endm  
# End of macro CALLMONITOR
ad14					endif 
ad14				; TODO replace below with ; exec using tok_ptr 
ad14 22 d8 e6			ld (os_tok_ptr), hl 
ad17 c3 fa 9d			jp exec1 
ad1a				NEXTW 
ad1a c3 69 9d			jp macro_next 
ad1d				endm 
# End of macro NEXTW
ad1d			 
ad1d .. 00		.ifthen:  db "THEN",0 
ad22			 
ad22			.iftrue:		 
ad22				; Exec next words normally 
ad22			 
ad22				; if true then exec following IF as normal 
ad22					if DEBUG_FORTH_WORDS 
ad22						DMARK "IFT" 
ad22 f5				push af  
ad23 3a 37 ad			ld a, (.dmark)  
ad26 32 71 ee			ld (debug_mark),a  
ad29 3a 38 ad			ld a, (.dmark+1)  
ad2c 32 72 ee			ld (debug_mark+1),a  
ad2f 3a 39 ad			ld a, (.dmark+2)  
ad32 32 73 ee			ld (debug_mark+2),a  
ad35 18 03			jr .pastdmark  
ad37 ..			.dmark: db "IFT"  
ad3a f1			.pastdmark: pop af  
ad3b			endm  
# End of macro DMARK
ad3b						CALLMONITOR 
ad3b cd 95 93			call break_point_state  
ad3e				endm  
# End of macro CALLMONITOR
ad3e					endif 
ad3e			 
ad3e					NEXTW 
ad3e c3 69 9d			jp macro_next 
ad41				endm 
# End of macro NEXTW
ad41			.THEN: 
ad41				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ad41 1f				db WORD_SYS_CORE+11             
ad42 69 ad			dw .ELSE            
ad44 05				db 4 + 1 
ad45 .. 00			db "THEN",0              
ad4a				endm 
# End of macro CWHEAD
ad4a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ad4a					if DEBUG_FORTH_WORDS_KEY 
ad4a						DMARK "THN" 
ad4a f5				push af  
ad4b 3a 5f ad			ld a, (.dmark)  
ad4e 32 71 ee			ld (debug_mark),a  
ad51 3a 60 ad			ld a, (.dmark+1)  
ad54 32 72 ee			ld (debug_mark+1),a  
ad57 3a 61 ad			ld a, (.dmark+2)  
ad5a 32 73 ee			ld (debug_mark+2),a  
ad5d 18 03			jr .pastdmark  
ad5f ..			.dmark: db "THN"  
ad62 f1			.pastdmark: pop af  
ad63			endm  
# End of macro DMARK
ad63						CALLMONITOR 
ad63 cd 95 93			call break_point_state  
ad66				endm  
# End of macro CALLMONITOR
ad66					endif 
ad66					NEXTW 
ad66 c3 69 9d			jp macro_next 
ad69				endm 
# End of macro NEXTW
ad69			.ELSE: 
ad69				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ad69 20				db WORD_SYS_CORE+12             
ad6a 91 ad			dw .DO            
ad6c 03				db 2 + 1 
ad6d .. 00			db "ELSE",0              
ad72				endm 
# End of macro CWHEAD
ad72			; | ELSE ( -- ) Not supported - does nothing | TODO 
ad72			 
ad72					if DEBUG_FORTH_WORDS_KEY 
ad72						DMARK "ELS" 
ad72 f5				push af  
ad73 3a 87 ad			ld a, (.dmark)  
ad76 32 71 ee			ld (debug_mark),a  
ad79 3a 88 ad			ld a, (.dmark+1)  
ad7c 32 72 ee			ld (debug_mark+1),a  
ad7f 3a 89 ad			ld a, (.dmark+2)  
ad82 32 73 ee			ld (debug_mark+2),a  
ad85 18 03			jr .pastdmark  
ad87 ..			.dmark: db "ELS"  
ad8a f1			.pastdmark: pop af  
ad8b			endm  
# End of macro DMARK
ad8b						CALLMONITOR 
ad8b cd 95 93			call break_point_state  
ad8e				endm  
# End of macro CALLMONITOR
ad8e					endif 
ad8e			 
ad8e			 
ad8e					NEXTW 
ad8e c3 69 9d			jp macro_next 
ad91				endm 
# End of macro NEXTW
ad91			.DO: 
ad91				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ad91 21				db WORD_SYS_CORE+13             
ad92 b8 ae			dw .LOOP            
ad94 03				db 2 + 1 
ad95 .. 00			db "DO",0              
ad98				endm 
# End of macro CWHEAD
ad98			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ad98			 
ad98					if DEBUG_FORTH_WORDS_KEY 
ad98						DMARK "DO." 
ad98 f5				push af  
ad99 3a ad ad			ld a, (.dmark)  
ad9c 32 71 ee			ld (debug_mark),a  
ad9f 3a ae ad			ld a, (.dmark+1)  
ada2 32 72 ee			ld (debug_mark+1),a  
ada5 3a af ad			ld a, (.dmark+2)  
ada8 32 73 ee			ld (debug_mark+2),a  
adab 18 03			jr .pastdmark  
adad ..			.dmark: db "DO."  
adb0 f1			.pastdmark: pop af  
adb1			endm  
# End of macro DMARK
adb1						CALLMONITOR 
adb1 cd 95 93			call break_point_state  
adb4				endm  
# End of macro CALLMONITOR
adb4					endif 
adb4			;  push pc to rsp stack past the DO 
adb4			 
adb4 2a d8 e6				ld hl, (os_tok_ptr) 
adb7 23					inc hl   ; D 
adb8 23					inc hl  ; O 
adb9 23					inc hl   ; null 
adba					if DEBUG_FORTH_WORDS 
adba						DMARK "DO2" 
adba f5				push af  
adbb 3a cf ad			ld a, (.dmark)  
adbe 32 71 ee			ld (debug_mark),a  
adc1 3a d0 ad			ld a, (.dmark+1)  
adc4 32 72 ee			ld (debug_mark+1),a  
adc7 3a d1 ad			ld a, (.dmark+2)  
adca 32 73 ee			ld (debug_mark+2),a  
adcd 18 03			jr .pastdmark  
adcf ..			.dmark: db "DO2"  
add2 f1			.pastdmark: pop af  
add3			endm  
# End of macro DMARK
add3						CALLMONITOR 
add3 cd 95 93			call break_point_state  
add6				endm  
# End of macro CALLMONITOR
add6					endif 
add6					FORTH_RSP_NEXT 
add6 cd a7 99			call macro_forth_rsp_next 
add9				endm 
# End of macro FORTH_RSP_NEXT
add9					if DEBUG_FORTH_WORDS 
add9						DMARK "DO3" 
add9 f5				push af  
adda 3a ee ad			ld a, (.dmark)  
addd 32 71 ee			ld (debug_mark),a  
ade0 3a ef ad			ld a, (.dmark+1)  
ade3 32 72 ee			ld (debug_mark+1),a  
ade6 3a f0 ad			ld a, (.dmark+2)  
ade9 32 73 ee			ld (debug_mark+2),a  
adec 18 03			jr .pastdmark  
adee ..			.dmark: db "DO3"  
adf1 f1			.pastdmark: pop af  
adf2			endm  
# End of macro DMARK
adf2						CALLMONITOR 
adf2 cd 95 93			call break_point_state  
adf5				endm  
# End of macro CALLMONITOR
adf5					endif 
adf5			 
adf5					;if DEBUG_FORTH_WORDS 
adf5				;		push hl 
adf5			;		endif  
adf5			 
adf5			; get counters from data stack 
adf5			 
adf5			 
adf5					FORTH_DSP_VALUEHL 
adf5 cd f7 9b			call macro_dsp_valuehl 
adf8				endm 
# End of macro FORTH_DSP_VALUEHL
adf8 e5					push hl		 ; hl now has starting counter which needs to be tos 
adf9			 
adf9					if DEBUG_FORTH_WORDS 
adf9						DMARK "DO4" 
adf9 f5				push af  
adfa 3a 0e ae			ld a, (.dmark)  
adfd 32 71 ee			ld (debug_mark),a  
ae00 3a 0f ae			ld a, (.dmark+1)  
ae03 32 72 ee			ld (debug_mark+1),a  
ae06 3a 10 ae			ld a, (.dmark+2)  
ae09 32 73 ee			ld (debug_mark+2),a  
ae0c 18 03			jr .pastdmark  
ae0e ..			.dmark: db "DO4"  
ae11 f1			.pastdmark: pop af  
ae12			endm  
# End of macro DMARK
ae12						CALLMONITOR 
ae12 cd 95 93			call break_point_state  
ae15				endm  
# End of macro CALLMONITOR
ae15					endif 
ae15					FORTH_DSP_POP 
ae15 cd af 9c			call macro_forth_dsp_pop 
ae18				endm 
# End of macro FORTH_DSP_POP
ae18			 
ae18					if DEBUG_FORTH_WORDS 
ae18						DMARK "DO5" 
ae18 f5				push af  
ae19 3a 2d ae			ld a, (.dmark)  
ae1c 32 71 ee			ld (debug_mark),a  
ae1f 3a 2e ae			ld a, (.dmark+1)  
ae22 32 72 ee			ld (debug_mark+1),a  
ae25 3a 2f ae			ld a, (.dmark+2)  
ae28 32 73 ee			ld (debug_mark+2),a  
ae2b 18 03			jr .pastdmark  
ae2d ..			.dmark: db "DO5"  
ae30 f1			.pastdmark: pop af  
ae31			endm  
# End of macro DMARK
ae31						CALLMONITOR 
ae31 cd 95 93			call break_point_state  
ae34				endm  
# End of macro CALLMONITOR
ae34					endif 
ae34			 
ae34					FORTH_DSP_VALUEHL 
ae34 cd f7 9b			call macro_dsp_valuehl 
ae37				endm 
# End of macro FORTH_DSP_VALUEHL
ae37			;		push hl		 ; hl now has starting limit counter 
ae37			 
ae37					if DEBUG_FORTH_WORDS 
ae37						DMARK "DO6" 
ae37 f5				push af  
ae38 3a 4c ae			ld a, (.dmark)  
ae3b 32 71 ee			ld (debug_mark),a  
ae3e 3a 4d ae			ld a, (.dmark+1)  
ae41 32 72 ee			ld (debug_mark+1),a  
ae44 3a 4e ae			ld a, (.dmark+2)  
ae47 32 73 ee			ld (debug_mark+2),a  
ae4a 18 03			jr .pastdmark  
ae4c ..			.dmark: db "DO6"  
ae4f f1			.pastdmark: pop af  
ae50			endm  
# End of macro DMARK
ae50						CALLMONITOR 
ae50 cd 95 93			call break_point_state  
ae53				endm  
# End of macro CALLMONITOR
ae53					endif 
ae53					FORTH_DSP_POP 
ae53 cd af 9c			call macro_forth_dsp_pop 
ae56				endm 
# End of macro FORTH_DSP_POP
ae56			 
ae56			; put counters on the loop stack 
ae56			 
ae56			;		pop hl			 ; limit counter 
ae56 d1					pop de			; start counter 
ae57			 
ae57					; push limit counter 
ae57			 
ae57					if DEBUG_FORTH_WORDS 
ae57						DMARK "DO7" 
ae57 f5				push af  
ae58 3a 6c ae			ld a, (.dmark)  
ae5b 32 71 ee			ld (debug_mark),a  
ae5e 3a 6d ae			ld a, (.dmark+1)  
ae61 32 72 ee			ld (debug_mark+1),a  
ae64 3a 6e ae			ld a, (.dmark+2)  
ae67 32 73 ee			ld (debug_mark+2),a  
ae6a 18 03			jr .pastdmark  
ae6c ..			.dmark: db "DO7"  
ae6f f1			.pastdmark: pop af  
ae70			endm  
# End of macro DMARK
ae70						CALLMONITOR 
ae70 cd 95 93			call break_point_state  
ae73				endm  
# End of macro CALLMONITOR
ae73					endif 
ae73					FORTH_LOOP_NEXT 
ae73 cd 28 9c			call macro_forth_loop_next 
ae76				endm 
# End of macro FORTH_LOOP_NEXT
ae76			 
ae76					; push start counter 
ae76			 
ae76 eb					ex de, hl 
ae77					if DEBUG_FORTH_WORDS 
ae77						DMARK "DO7" 
ae77 f5				push af  
ae78 3a 8c ae			ld a, (.dmark)  
ae7b 32 71 ee			ld (debug_mark),a  
ae7e 3a 8d ae			ld a, (.dmark+1)  
ae81 32 72 ee			ld (debug_mark+1),a  
ae84 3a 8e ae			ld a, (.dmark+2)  
ae87 32 73 ee			ld (debug_mark+2),a  
ae8a 18 03			jr .pastdmark  
ae8c ..			.dmark: db "DO7"  
ae8f f1			.pastdmark: pop af  
ae90			endm  
# End of macro DMARK
ae90						CALLMONITOR 
ae90 cd 95 93			call break_point_state  
ae93				endm  
# End of macro CALLMONITOR
ae93					endif 
ae93					FORTH_LOOP_NEXT 
ae93 cd 28 9c			call macro_forth_loop_next 
ae96				endm 
# End of macro FORTH_LOOP_NEXT
ae96			 
ae96			 
ae96					; init first round of I counter 
ae96			 
ae96 22 fc e6				ld (os_current_i), hl 
ae99			 
ae99					if DEBUG_FORTH_WORDS 
ae99						DMARK "DO8" 
ae99 f5				push af  
ae9a 3a ae ae			ld a, (.dmark)  
ae9d 32 71 ee			ld (debug_mark),a  
aea0 3a af ae			ld a, (.dmark+1)  
aea3 32 72 ee			ld (debug_mark+1),a  
aea6 3a b0 ae			ld a, (.dmark+2)  
aea9 32 73 ee			ld (debug_mark+2),a  
aeac 18 03			jr .pastdmark  
aeae ..			.dmark: db "DO8"  
aeb1 f1			.pastdmark: pop af  
aeb2			endm  
# End of macro DMARK
aeb2						CALLMONITOR 
aeb2 cd 95 93			call break_point_state  
aeb5				endm  
# End of macro CALLMONITOR
aeb5					endif 
aeb5			 
aeb5					NEXTW 
aeb5 c3 69 9d			jp macro_next 
aeb8				endm 
# End of macro NEXTW
aeb8			.LOOP: 
aeb8				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
aeb8 22				db WORD_SYS_CORE+14             
aeb9 d0 af			dw .I            
aebb 05				db 4 + 1 
aebc .. 00			db "LOOP",0              
aec1				endm 
# End of macro CWHEAD
aec1			; | LOOP ( -- ) Increment and test loop counter  | DONE 
aec1			 
aec1				; pop tos as current loop count to hl 
aec1			 
aec1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aec1			 
aec1				FORTH_LOOP_TOS 
aec1 cd 5b 9c			call macro_forth_loop_tos 
aec4				endm 
# End of macro FORTH_LOOP_TOS
aec4 e5				push hl 
aec5			 
aec5					if DEBUG_FORTH_WORDS_KEY 
aec5						DMARK "LOP" 
aec5 f5				push af  
aec6 3a da ae			ld a, (.dmark)  
aec9 32 71 ee			ld (debug_mark),a  
aecc 3a db ae			ld a, (.dmark+1)  
aecf 32 72 ee			ld (debug_mark+1),a  
aed2 3a dc ae			ld a, (.dmark+2)  
aed5 32 73 ee			ld (debug_mark+2),a  
aed8 18 03			jr .pastdmark  
aeda ..			.dmark: db "LOP"  
aedd f1			.pastdmark: pop af  
aede			endm  
# End of macro DMARK
aede						CALLMONITOR 
aede cd 95 93			call break_point_state  
aee1				endm  
# End of macro CALLMONITOR
aee1					endif 
aee1				; next item on the stack is the limit. get it 
aee1			 
aee1			 
aee1				FORTH_LOOP_POP 
aee1 cd 65 9c			call macro_forth_loop_pop 
aee4				endm 
# End of macro FORTH_LOOP_POP
aee4			 
aee4				FORTH_LOOP_TOS 
aee4 cd 5b 9c			call macro_forth_loop_tos 
aee7				endm 
# End of macro FORTH_LOOP_TOS
aee7			 
aee7 d1				pop de		 ; de = i, hl = limit 
aee8			 
aee8					if DEBUG_FORTH_WORDS 
aee8						DMARK "LP1" 
aee8 f5				push af  
aee9 3a fd ae			ld a, (.dmark)  
aeec 32 71 ee			ld (debug_mark),a  
aeef 3a fe ae			ld a, (.dmark+1)  
aef2 32 72 ee			ld (debug_mark+1),a  
aef5 3a ff ae			ld a, (.dmark+2)  
aef8 32 73 ee			ld (debug_mark+2),a  
aefb 18 03			jr .pastdmark  
aefd ..			.dmark: db "LP1"  
af00 f1			.pastdmark: pop af  
af01			endm  
# End of macro DMARK
af01						CALLMONITOR 
af01 cd 95 93			call break_point_state  
af04				endm  
# End of macro CALLMONITOR
af04					endif 
af04			 
af04				; go back to previous word 
af04			 
af04 d5				push de    ; save I for inc later 
af05			 
af05			 
af05				; get limit 
af05				;  is I at limit? 
af05			 
af05			 
af05					if DEBUG_FORTH_WORDS 
af05						DMARK "LP1" 
af05 f5				push af  
af06 3a 1a af			ld a, (.dmark)  
af09 32 71 ee			ld (debug_mark),a  
af0c 3a 1b af			ld a, (.dmark+1)  
af0f 32 72 ee			ld (debug_mark+1),a  
af12 3a 1c af			ld a, (.dmark+2)  
af15 32 73 ee			ld (debug_mark+2),a  
af18 18 03			jr .pastdmark  
af1a ..			.dmark: db "LP1"  
af1d f1			.pastdmark: pop af  
af1e			endm  
# End of macro DMARK
af1e						CALLMONITOR 
af1e cd 95 93			call break_point_state  
af21				endm  
# End of macro CALLMONITOR
af21					endif 
af21			 
af21 ed 52			sbc hl, de 
af23			 
af23			 
af23				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af23			 
af23 20 26				jr nz, .loopnotdone 
af25			 
af25 e1				pop hl   ; get rid of saved I 
af26				FORTH_LOOP_POP     ; get rid of limit 
af26 cd 65 9c			call macro_forth_loop_pop 
af29				endm 
# End of macro FORTH_LOOP_POP
af29			 
af29				FORTH_RSP_POP     ; get rid of DO ptr 
af29 cd c8 99			call macro_forth_rsp_pop 
af2c				endm 
# End of macro FORTH_RSP_POP
af2c			 
af2c			if DEBUG_FORTH_WORDS 
af2c						DMARK "LP>" 
af2c f5				push af  
af2d 3a 41 af			ld a, (.dmark)  
af30 32 71 ee			ld (debug_mark),a  
af33 3a 42 af			ld a, (.dmark+1)  
af36 32 72 ee			ld (debug_mark+1),a  
af39 3a 43 af			ld a, (.dmark+2)  
af3c 32 73 ee			ld (debug_mark+2),a  
af3f 18 03			jr .pastdmark  
af41 ..			.dmark: db "LP>"  
af44 f1			.pastdmark: pop af  
af45			endm  
# End of macro DMARK
af45				CALLMONITOR 
af45 cd 95 93			call break_point_state  
af48				endm  
# End of macro CALLMONITOR
af48			endif 
af48			 
af48					NEXTW 
af48 c3 69 9d			jp macro_next 
af4b				endm 
# End of macro NEXTW
af4b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af4b			 
af4b			.loopnotdone: 
af4b			 
af4b e1				pop hl    ; get I 
af4c 23				inc hl 
af4d			 
af4d			   	; save new I 
af4d			 
af4d			 
af4d					; set I counter 
af4d			 
af4d 22 fc e6				ld (os_current_i), hl 
af50			 
af50					if DEBUG_FORTH_WORDS 
af50						DMARK "LPN" 
af50 f5				push af  
af51 3a 65 af			ld a, (.dmark)  
af54 32 71 ee			ld (debug_mark),a  
af57 3a 66 af			ld a, (.dmark+1)  
af5a 32 72 ee			ld (debug_mark+1),a  
af5d 3a 67 af			ld a, (.dmark+2)  
af60 32 73 ee			ld (debug_mark+2),a  
af63 18 03			jr .pastdmark  
af65 ..			.dmark: db "LPN"  
af68 f1			.pastdmark: pop af  
af69			endm  
# End of macro DMARK
af69					CALLMONITOR 
af69 cd 95 93			call break_point_state  
af6c				endm  
# End of macro CALLMONITOR
af6c					endif 
af6c					 
af6c				FORTH_LOOP_NEXT 
af6c cd 28 9c			call macro_forth_loop_next 
af6f				endm 
# End of macro FORTH_LOOP_NEXT
af6f			 
af6f			 
af6f					if DEBUG_FORTH_WORDS 
af6f eb						ex de,hl 
af70					endif 
af70			 
af70			;	; get DO ptr 
af70			; 
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "LP7" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 71 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 72 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 73 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "LP7"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89					CALLMONITOR 
af89 cd 95 93			call break_point_state  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c				FORTH_RSP_TOS 
af8c cd be 99			call macro_forth_rsp_tos 
af8f				endm 
# End of macro FORTH_RSP_TOS
af8f			 
af8f					if DEBUG_FORTH_WORDS 
af8f						DMARK "LP8" 
af8f f5				push af  
af90 3a a4 af			ld a, (.dmark)  
af93 32 71 ee			ld (debug_mark),a  
af96 3a a5 af			ld a, (.dmark+1)  
af99 32 72 ee			ld (debug_mark+1),a  
af9c 3a a6 af			ld a, (.dmark+2)  
af9f 32 73 ee			ld (debug_mark+2),a  
afa2 18 03			jr .pastdmark  
afa4 ..			.dmark: db "LP8"  
afa7 f1			.pastdmark: pop af  
afa8			endm  
# End of macro DMARK
afa8					CALLMONITOR 
afa8 cd 95 93			call break_point_state  
afab				endm  
# End of macro CALLMONITOR
afab					endif 
afab				;push hl 
afab			 
afab				; not going to DO any more 
afab				; get rid of the RSP pointer as DO will add it back in 
afab				;FORTH_RSP_POP 
afab				;pop hl 
afab			 
afab				;ld hl,(cli_ret_sp) 
afab				;ld e, (hl) 
afab				;inc hl 
afab				;ld d, (hl) 
afab				;ex de,hl 
afab 22 d8 e6			ld (os_tok_ptr), hl 
afae					if DEBUG_FORTH_WORDS 
afae						DMARK "LP<" 
afae f5				push af  
afaf 3a c3 af			ld a, (.dmark)  
afb2 32 71 ee			ld (debug_mark),a  
afb5 3a c4 af			ld a, (.dmark+1)  
afb8 32 72 ee			ld (debug_mark+1),a  
afbb 3a c5 af			ld a, (.dmark+2)  
afbe 32 73 ee			ld (debug_mark+2),a  
afc1 18 03			jr .pastdmark  
afc3 ..			.dmark: db "LP<"  
afc6 f1			.pastdmark: pop af  
afc7			endm  
# End of macro DMARK
afc7					CALLMONITOR 
afc7 cd 95 93			call break_point_state  
afca				endm  
# End of macro CALLMONITOR
afca				endif 
afca c3 fa 9d			jp exec1 
afcd			 
afcd					 
afcd			 
afcd			 
afcd					NEXTW 
afcd c3 69 9d			jp macro_next 
afd0				endm 
# End of macro NEXTW
afd0			.I:  
afd0			 
afd0				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
afd0 5e				db WORD_SYS_CORE+74             
afd1 fb af			dw .DLOOP            
afd3 02				db 1 + 1 
afd4 .. 00			db "I",0              
afd6				endm 
# End of macro CWHEAD
afd6			; | I ( -- ) Current loop counter | DONE 
afd6					if DEBUG_FORTH_WORDS_KEY 
afd6						DMARK "I.." 
afd6 f5				push af  
afd7 3a eb af			ld a, (.dmark)  
afda 32 71 ee			ld (debug_mark),a  
afdd 3a ec af			ld a, (.dmark+1)  
afe0 32 72 ee			ld (debug_mark+1),a  
afe3 3a ed af			ld a, (.dmark+2)  
afe6 32 73 ee			ld (debug_mark+2),a  
afe9 18 03			jr .pastdmark  
afeb ..			.dmark: db "I.."  
afee f1			.pastdmark: pop af  
afef			endm  
# End of macro DMARK
afef						CALLMONITOR 
afef cd 95 93			call break_point_state  
aff2				endm  
# End of macro CALLMONITOR
aff2					endif 
aff2			 
aff2 2a fc e6				ld hl,(os_current_i) 
aff5 cd 00 9a				call forth_push_numhl 
aff8			 
aff8					NEXTW 
aff8 c3 69 9d			jp macro_next 
affb				endm 
# End of macro NEXTW
affb			.DLOOP: 
affb				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
affb 5f				db WORD_SYS_CORE+75             
affc dc b0			dw .REPEAT            
affe 06				db 5 + 1 
afff .. 00			db "-LOOP",0              
b005				endm 
# End of macro CWHEAD
b005			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b005				; pop tos as current loop count to hl 
b005					if DEBUG_FORTH_WORDS_KEY 
b005						DMARK "-LP" 
b005 f5				push af  
b006 3a 1a b0			ld a, (.dmark)  
b009 32 71 ee			ld (debug_mark),a  
b00c 3a 1b b0			ld a, (.dmark+1)  
b00f 32 72 ee			ld (debug_mark+1),a  
b012 3a 1c b0			ld a, (.dmark+2)  
b015 32 73 ee			ld (debug_mark+2),a  
b018 18 03			jr .pastdmark  
b01a ..			.dmark: db "-LP"  
b01d f1			.pastdmark: pop af  
b01e			endm  
# End of macro DMARK
b01e						CALLMONITOR 
b01e cd 95 93			call break_point_state  
b021				endm  
# End of macro CALLMONITOR
b021					endif 
b021			 
b021				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b021			 
b021				FORTH_LOOP_TOS 
b021 cd 5b 9c			call macro_forth_loop_tos 
b024				endm 
# End of macro FORTH_LOOP_TOS
b024 e5				push hl 
b025			 
b025					if DEBUG_FORTH_WORDS 
b025						DMARK "-LP" 
b025 f5				push af  
b026 3a 3a b0			ld a, (.dmark)  
b029 32 71 ee			ld (debug_mark),a  
b02c 3a 3b b0			ld a, (.dmark+1)  
b02f 32 72 ee			ld (debug_mark+1),a  
b032 3a 3c b0			ld a, (.dmark+2)  
b035 32 73 ee			ld (debug_mark+2),a  
b038 18 03			jr .pastdmark  
b03a ..			.dmark: db "-LP"  
b03d f1			.pastdmark: pop af  
b03e			endm  
# End of macro DMARK
b03e						CALLMONITOR 
b03e cd 95 93			call break_point_state  
b041				endm  
# End of macro CALLMONITOR
b041					endif 
b041				; next item on the stack is the limit. get it 
b041			 
b041			 
b041				FORTH_LOOP_POP 
b041 cd 65 9c			call macro_forth_loop_pop 
b044				endm 
# End of macro FORTH_LOOP_POP
b044			 
b044				FORTH_LOOP_TOS 
b044 cd 5b 9c			call macro_forth_loop_tos 
b047				endm 
# End of macro FORTH_LOOP_TOS
b047			 
b047 d1				pop de		 ; de = i, hl = limit 
b048			 
b048					if DEBUG_FORTH_WORDS 
b048						DMARK "-L1" 
b048 f5				push af  
b049 3a 5d b0			ld a, (.dmark)  
b04c 32 71 ee			ld (debug_mark),a  
b04f 3a 5e b0			ld a, (.dmark+1)  
b052 32 72 ee			ld (debug_mark+1),a  
b055 3a 5f b0			ld a, (.dmark+2)  
b058 32 73 ee			ld (debug_mark+2),a  
b05b 18 03			jr .pastdmark  
b05d ..			.dmark: db "-L1"  
b060 f1			.pastdmark: pop af  
b061			endm  
# End of macro DMARK
b061						CALLMONITOR 
b061 cd 95 93			call break_point_state  
b064				endm  
# End of macro CALLMONITOR
b064					endif 
b064			 
b064				; go back to previous word 
b064			 
b064 d5				push de    ; save I for inc later 
b065			 
b065			 
b065				; get limit 
b065				;  is I at limit? 
b065			 
b065			 
b065					if DEBUG_FORTH_WORDS 
b065						DMARK "-L1" 
b065 f5				push af  
b066 3a 7a b0			ld a, (.dmark)  
b069 32 71 ee			ld (debug_mark),a  
b06c 3a 7b b0			ld a, (.dmark+1)  
b06f 32 72 ee			ld (debug_mark+1),a  
b072 3a 7c b0			ld a, (.dmark+2)  
b075 32 73 ee			ld (debug_mark+2),a  
b078 18 03			jr .pastdmark  
b07a ..			.dmark: db "-L1"  
b07d f1			.pastdmark: pop af  
b07e			endm  
# End of macro DMARK
b07e						CALLMONITOR 
b07e cd 95 93			call break_point_state  
b081				endm  
# End of macro CALLMONITOR
b081					endif 
b081			 
b081 ed 52			sbc hl, de 
b083			 
b083			 
b083				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b083			 
b083 20 26				jr nz, .mloopnotdone 
b085			 
b085 e1				pop hl   ; get rid of saved I 
b086				FORTH_LOOP_POP     ; get rid of limit 
b086 cd 65 9c			call macro_forth_loop_pop 
b089				endm 
# End of macro FORTH_LOOP_POP
b089			 
b089				FORTH_RSP_POP     ; get rid of DO ptr 
b089 cd c8 99			call macro_forth_rsp_pop 
b08c				endm 
# End of macro FORTH_RSP_POP
b08c			 
b08c			if DEBUG_FORTH_WORDS 
b08c						DMARK "-L>" 
b08c f5				push af  
b08d 3a a1 b0			ld a, (.dmark)  
b090 32 71 ee			ld (debug_mark),a  
b093 3a a2 b0			ld a, (.dmark+1)  
b096 32 72 ee			ld (debug_mark+1),a  
b099 3a a3 b0			ld a, (.dmark+2)  
b09c 32 73 ee			ld (debug_mark+2),a  
b09f 18 03			jr .pastdmark  
b0a1 ..			.dmark: db "-L>"  
b0a4 f1			.pastdmark: pop af  
b0a5			endm  
# End of macro DMARK
b0a5				CALLMONITOR 
b0a5 cd 95 93			call break_point_state  
b0a8				endm  
# End of macro CALLMONITOR
b0a8			endif 
b0a8			 
b0a8					NEXTW 
b0a8 c3 69 9d			jp macro_next 
b0ab				endm 
# End of macro NEXTW
b0ab				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0ab			 
b0ab			.mloopnotdone: 
b0ab			 
b0ab e1				pop hl    ; get I 
b0ac 2b				dec hl 
b0ad			 
b0ad			   	; save new I 
b0ad			 
b0ad			 
b0ad					; set I counter 
b0ad			 
b0ad 22 fc e6				ld (os_current_i), hl 
b0b0			 
b0b0					 
b0b0				FORTH_LOOP_NEXT 
b0b0 cd 28 9c			call macro_forth_loop_next 
b0b3				endm 
# End of macro FORTH_LOOP_NEXT
b0b3			 
b0b3			 
b0b3					if DEBUG_FORTH_WORDS 
b0b3 eb						ex de,hl 
b0b4					endif 
b0b4			 
b0b4			;	; get DO ptr 
b0b4			; 
b0b4				FORTH_RSP_TOS 
b0b4 cd be 99			call macro_forth_rsp_tos 
b0b7				endm 
# End of macro FORTH_RSP_TOS
b0b7			 
b0b7				;push hl 
b0b7			 
b0b7				; not going to DO any more 
b0b7				; get rid of the RSP pointer as DO will add it back in 
b0b7				;FORTH_RSP_POP 
b0b7				;pop hl 
b0b7			 
b0b7			 
b0b7 22 d8 e6			ld (os_tok_ptr), hl 
b0ba					if DEBUG_FORTH_WORDS 
b0ba						DMARK "-L<" 
b0ba f5				push af  
b0bb 3a cf b0			ld a, (.dmark)  
b0be 32 71 ee			ld (debug_mark),a  
b0c1 3a d0 b0			ld a, (.dmark+1)  
b0c4 32 72 ee			ld (debug_mark+1),a  
b0c7 3a d1 b0			ld a, (.dmark+2)  
b0ca 32 73 ee			ld (debug_mark+2),a  
b0cd 18 03			jr .pastdmark  
b0cf ..			.dmark: db "-L<"  
b0d2 f1			.pastdmark: pop af  
b0d3			endm  
# End of macro DMARK
b0d3					CALLMONITOR 
b0d3 cd 95 93			call break_point_state  
b0d6				endm  
# End of macro CALLMONITOR
b0d6				endif 
b0d6 c3 fa 9d			jp exec1 
b0d9			 
b0d9					 
b0d9			 
b0d9			 
b0d9			 
b0d9				NEXTW 
b0d9 c3 69 9d			jp macro_next 
b0dc				endm 
# End of macro NEXTW
b0dc			 
b0dc			 
b0dc			 
b0dc			 
b0dc			.REPEAT: 
b0dc				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b0dc 71				db WORD_SYS_CORE+93             
b0dd 2f b1			dw .UNTIL            
b0df 06				db 5 + 1 
b0e0 .. 00			db "REPEAT",0              
b0e7				endm 
# End of macro CWHEAD
b0e7			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b0e7			;  push pc to rsp stack past the REPEAT 
b0e7					if DEBUG_FORTH_WORDS_KEY 
b0e7						DMARK "REP" 
b0e7 f5				push af  
b0e8 3a fc b0			ld a, (.dmark)  
b0eb 32 71 ee			ld (debug_mark),a  
b0ee 3a fd b0			ld a, (.dmark+1)  
b0f1 32 72 ee			ld (debug_mark+1),a  
b0f4 3a fe b0			ld a, (.dmark+2)  
b0f7 32 73 ee			ld (debug_mark+2),a  
b0fa 18 03			jr .pastdmark  
b0fc ..			.dmark: db "REP"  
b0ff f1			.pastdmark: pop af  
b100			endm  
# End of macro DMARK
b100						CALLMONITOR 
b100 cd 95 93			call break_point_state  
b103				endm  
# End of macro CALLMONITOR
b103					endif 
b103			 
b103 2a d8 e6				ld hl, (os_tok_ptr) 
b106 23					inc hl   ; R 
b107 23					inc hl  ; E 
b108 23					inc hl   ; P 
b109 23					inc hl   ; E 
b10a 23					inc hl   ; A 
b10b 23					inc hl   ; T 
b10c 23					inc hl   ; zero 
b10d					FORTH_RSP_NEXT 
b10d cd a7 99			call macro_forth_rsp_next 
b110				endm 
# End of macro FORTH_RSP_NEXT
b110			 
b110			 
b110					if DEBUG_FORTH_WORDS 
b110						DMARK "REP" 
b110 f5				push af  
b111 3a 25 b1			ld a, (.dmark)  
b114 32 71 ee			ld (debug_mark),a  
b117 3a 26 b1			ld a, (.dmark+1)  
b11a 32 72 ee			ld (debug_mark+1),a  
b11d 3a 27 b1			ld a, (.dmark+2)  
b120 32 73 ee			ld (debug_mark+2),a  
b123 18 03			jr .pastdmark  
b125 ..			.dmark: db "REP"  
b128 f1			.pastdmark: pop af  
b129			endm  
# End of macro DMARK
b129						;pop bc    ; TODO BUG ?????? what is this for???? 
b129						CALLMONITOR 
b129 cd 95 93			call break_point_state  
b12c				endm  
# End of macro CALLMONITOR
b12c					endif 
b12c			 
b12c					NEXTW 
b12c c3 69 9d			jp macro_next 
b12f				endm 
# End of macro NEXTW
b12f			;	       NEXTW 
b12f			 
b12f			.UNTIL: 
b12f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b12f 72				db WORD_SYS_CORE+94             
b130 c6 b1			dw .ENDFLOW            
b132 06				db 5 + 1 
b133 .. 00			db "UNTIL",0              
b139				endm 
# End of macro CWHEAD
b139			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b139			 
b139				; pop tos as check 
b139			 
b139				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b139			 
b139				FORTH_DSP_VALUEHL 
b139 cd f7 9b			call macro_dsp_valuehl 
b13c				endm 
# End of macro FORTH_DSP_VALUEHL
b13c			 
b13c					if DEBUG_FORTH_WORDS_KEY 
b13c						DMARK "UNT" 
b13c f5				push af  
b13d 3a 51 b1			ld a, (.dmark)  
b140 32 71 ee			ld (debug_mark),a  
b143 3a 52 b1			ld a, (.dmark+1)  
b146 32 72 ee			ld (debug_mark+1),a  
b149 3a 53 b1			ld a, (.dmark+2)  
b14c 32 73 ee			ld (debug_mark+2),a  
b14f 18 03			jr .pastdmark  
b151 ..			.dmark: db "UNT"  
b154 f1			.pastdmark: pop af  
b155			endm  
# End of macro DMARK
b155						CALLMONITOR 
b155 cd 95 93			call break_point_state  
b158				endm  
# End of macro CALLMONITOR
b158					endif 
b158			 
b158			;	push hl 
b158				FORTH_DSP_POP 
b158 cd af 9c			call macro_forth_dsp_pop 
b15b				endm 
# End of macro FORTH_DSP_POP
b15b			 
b15b			;	pop hl 
b15b			 
b15b				; test if true 
b15b			 
b15b cd bd 8b			call ishlzero 
b15e			;	ld a,l 
b15e			;	add h 
b15e			; 
b15e			;	cp 0 
b15e			 
b15e 20 3e			jr nz, .untilnotdone 
b160			 
b160					if DEBUG_FORTH_WORDS 
b160						DMARK "UNf" 
b160 f5				push af  
b161 3a 75 b1			ld a, (.dmark)  
b164 32 71 ee			ld (debug_mark),a  
b167 3a 76 b1			ld a, (.dmark+1)  
b16a 32 72 ee			ld (debug_mark+1),a  
b16d 3a 77 b1			ld a, (.dmark+2)  
b170 32 73 ee			ld (debug_mark+2),a  
b173 18 03			jr .pastdmark  
b175 ..			.dmark: db "UNf"  
b178 f1			.pastdmark: pop af  
b179			endm  
# End of macro DMARK
b179						CALLMONITOR 
b179 cd 95 93			call break_point_state  
b17c				endm  
# End of macro CALLMONITOR
b17c					endif 
b17c			 
b17c			 
b17c			 
b17c				FORTH_RSP_POP     ; get rid of DO ptr 
b17c cd c8 99			call macro_forth_rsp_pop 
b17f				endm 
# End of macro FORTH_RSP_POP
b17f			 
b17f			if DEBUG_FORTH_WORDS 
b17f						DMARK "UN>" 
b17f f5				push af  
b180 3a 94 b1			ld a, (.dmark)  
b183 32 71 ee			ld (debug_mark),a  
b186 3a 95 b1			ld a, (.dmark+1)  
b189 32 72 ee			ld (debug_mark+1),a  
b18c 3a 96 b1			ld a, (.dmark+2)  
b18f 32 73 ee			ld (debug_mark+2),a  
b192 18 03			jr .pastdmark  
b194 ..			.dmark: db "UN>"  
b197 f1			.pastdmark: pop af  
b198			endm  
# End of macro DMARK
b198				CALLMONITOR 
b198 cd 95 93			call break_point_state  
b19b				endm  
# End of macro CALLMONITOR
b19b			endif 
b19b			 
b19b					NEXTW 
b19b c3 69 9d			jp macro_next 
b19e				endm 
# End of macro NEXTW
b19e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b19e			 
b19e			.untilnotdone: 
b19e			 
b19e			 
b19e			;	; get DO ptr 
b19e			; 
b19e				FORTH_RSP_TOS 
b19e cd be 99			call macro_forth_rsp_tos 
b1a1				endm 
# End of macro FORTH_RSP_TOS
b1a1			 
b1a1				;push hl 
b1a1			 
b1a1				; not going to DO any more 
b1a1				; get rid of the RSP pointer as DO will add it back in 
b1a1				;FORTH_RSP_POP 
b1a1				;pop hl 
b1a1			 
b1a1			 
b1a1 22 d8 e6			ld (os_tok_ptr), hl 
b1a4					if DEBUG_FORTH_WORDS 
b1a4						DMARK "UN<" 
b1a4 f5				push af  
b1a5 3a b9 b1			ld a, (.dmark)  
b1a8 32 71 ee			ld (debug_mark),a  
b1ab 3a ba b1			ld a, (.dmark+1)  
b1ae 32 72 ee			ld (debug_mark+1),a  
b1b1 3a bb b1			ld a, (.dmark+2)  
b1b4 32 73 ee			ld (debug_mark+2),a  
b1b7 18 03			jr .pastdmark  
b1b9 ..			.dmark: db "UN<"  
b1bc f1			.pastdmark: pop af  
b1bd			endm  
# End of macro DMARK
b1bd					CALLMONITOR 
b1bd cd 95 93			call break_point_state  
b1c0				endm  
# End of macro CALLMONITOR
b1c0				endif 
b1c0 c3 fa 9d			jp exec1 
b1c3			 
b1c3					 
b1c3			 
b1c3			 
b1c3					NEXTW 
b1c3 c3 69 9d			jp macro_next 
b1c6				endm 
# End of macro NEXTW
b1c6			 
b1c6			 
b1c6			.ENDFLOW: 
b1c6			 
b1c6			; eof 
b1c6			 
# End of file forth_words_flow.asm
b1c6			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b1c6			include "forth_words_logic.asm" 
b1c6			 
b1c6			; | ## Logic Words 
b1c6			 
b1c6			.NOT: 
b1c6				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b1c6 2d				db WORD_SYS_CORE+25             
b1c7 0e b2			dw .IS            
b1c9 04				db 3 + 1 
b1ca .. 00			db "NOT",0              
b1ce				endm 
# End of macro CWHEAD
b1ce			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b1ce					if DEBUG_FORTH_WORDS_KEY 
b1ce						DMARK "NOT" 
b1ce f5				push af  
b1cf 3a e3 b1			ld a, (.dmark)  
b1d2 32 71 ee			ld (debug_mark),a  
b1d5 3a e4 b1			ld a, (.dmark+1)  
b1d8 32 72 ee			ld (debug_mark+1),a  
b1db 3a e5 b1			ld a, (.dmark+2)  
b1de 32 73 ee			ld (debug_mark+2),a  
b1e1 18 03			jr .pastdmark  
b1e3 ..			.dmark: db "NOT"  
b1e6 f1			.pastdmark: pop af  
b1e7			endm  
# End of macro DMARK
b1e7						CALLMONITOR 
b1e7 cd 95 93			call break_point_state  
b1ea				endm  
# End of macro CALLMONITOR
b1ea					endif 
b1ea					FORTH_DSP 
b1ea cd bd 9b			call macro_forth_dsp 
b1ed				endm 
# End of macro FORTH_DSP
b1ed 7e					ld a,(hl)	; get type of value on TOS 
b1ee fe 02				cp DS_TYPE_INUM  
b1f0 28 03				jr z, .noti 
b1f2					NEXTW 
b1f2 c3 69 9d			jp macro_next 
b1f5				endm 
# End of macro NEXTW
b1f5			.noti:          FORTH_DSP_VALUEHL 
b1f5 cd f7 9b			call macro_dsp_valuehl 
b1f8				endm 
# End of macro FORTH_DSP_VALUEHL
b1f8			;		push hl 
b1f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1f8 cd af 9c			call macro_forth_dsp_pop 
b1fb				endm 
# End of macro FORTH_DSP_POP
b1fb			;		pop hl 
b1fb 3e 00				ld a,0 
b1fd bd					cp l 
b1fe 28 04				jr z, .not2t 
b200 2e 00				ld l, 0 
b202 18 02				jr .notip 
b204			 
b204 2e ff		.not2t:		ld l, 255 
b206			 
b206 26 00		.notip:		ld h, 0	 
b208			 
b208 cd 00 9a				call forth_push_numhl 
b20b					NEXTW 
b20b c3 69 9d			jp macro_next 
b20e				endm 
# End of macro NEXTW
b20e			 
b20e			.IS: 
b20e				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b20e 2d				db WORD_SYS_CORE+25             
b20f 34 b2			dw .LZERO            
b211 03				db 2 + 1 
b212 .. 00			db "IS",0              
b215				endm 
# End of macro CWHEAD
b215			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b215					if DEBUG_FORTH_WORDS_KEY 
b215						DMARK "IS." 
b215 f5				push af  
b216 3a 2a b2			ld a, (.dmark)  
b219 32 71 ee			ld (debug_mark),a  
b21c 3a 2b b2			ld a, (.dmark+1)  
b21f 32 72 ee			ld (debug_mark+1),a  
b222 3a 2c b2			ld a, (.dmark+2)  
b225 32 73 ee			ld (debug_mark+2),a  
b228 18 03			jr .pastdmark  
b22a ..			.dmark: db "IS."  
b22d f1			.pastdmark: pop af  
b22e			endm  
# End of macro DMARK
b22e						CALLMONITOR 
b22e cd 95 93			call break_point_state  
b231				endm  
# End of macro CALLMONITOR
b231					endif 
b231					NEXTW 
b231 c3 69 9d			jp macro_next 
b234				endm 
# End of macro NEXTW
b234			.LZERO: 
b234				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b234 2d				db WORD_SYS_CORE+25             
b235 3e b2			dw .TZERO            
b237 03				db 2 + 1 
b238 .. 00			db "0<",0              
b23b				endm 
# End of macro CWHEAD
b23b			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b23b					NEXTW 
b23b c3 69 9d			jp macro_next 
b23e				endm 
# End of macro NEXTW
b23e			.TZERO: 
b23e				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b23e 2e				db WORD_SYS_CORE+26             
b23f 85 b2			dw .LESS            
b241 03				db 2 + 1 
b242 .. 00			db "0=",0              
b245				endm 
# End of macro CWHEAD
b245			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b245				; TODO add floating point number detection 
b245					;v5 FORTH_DSP_VALUE 
b245					if DEBUG_FORTH_WORDS_KEY 
b245						DMARK "0=." 
b245 f5				push af  
b246 3a 5a b2			ld a, (.dmark)  
b249 32 71 ee			ld (debug_mark),a  
b24c 3a 5b b2			ld a, (.dmark+1)  
b24f 32 72 ee			ld (debug_mark+1),a  
b252 3a 5c b2			ld a, (.dmark+2)  
b255 32 73 ee			ld (debug_mark+2),a  
b258 18 03			jr .pastdmark  
b25a ..			.dmark: db "0=."  
b25d f1			.pastdmark: pop af  
b25e			endm  
# End of macro DMARK
b25e						CALLMONITOR 
b25e cd 95 93			call break_point_state  
b261				endm  
# End of macro CALLMONITOR
b261					endif 
b261					FORTH_DSP 
b261 cd bd 9b			call macro_forth_dsp 
b264				endm 
# End of macro FORTH_DSP
b264 7e					ld a,(hl)	; get type of value on TOS 
b265 fe 02				cp DS_TYPE_INUM  
b267 28 00				jr z, .tz_inum 
b269			 
b269				if FORTH_ENABLE_FLOATMATH 
b269					jr .tz_done 
b269			 
b269				endif 
b269					 
b269			 
b269			.tz_inum: 
b269					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b269 cd f7 9b			call macro_dsp_valuehl 
b26c				endm 
# End of macro FORTH_DSP_VALUEHL
b26c			 
b26c			;		push hl 
b26c			 
b26c					; destroy value TOS 
b26c			 
b26c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b26c cd af 9c			call macro_forth_dsp_pop 
b26f				endm 
# End of macro FORTH_DSP_POP
b26f			 
b26f			;		pop hl 
b26f			 
b26f 3e 00				ld a,0 
b271			 
b271 bd					cp l 
b272 20 08				jr nz, .tz_notzero 
b274			 
b274 bc					cp h 
b275			 
b275 20 05				jr nz, .tz_notzero 
b277			 
b277			 
b277 21 01 00				ld hl, FORTH_TRUE 
b27a 18 03				jr .tz_done 
b27c			 
b27c 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b27f			 
b27f					; push value back onto stack for another op etc 
b27f			 
b27f			.tz_done: 
b27f cd 00 9a				call forth_push_numhl 
b282			 
b282					NEXTW 
b282 c3 69 9d			jp macro_next 
b285				endm 
# End of macro NEXTW
b285			.LESS: 
b285				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b285 2f				db WORD_SYS_CORE+27             
b286 ee b2			dw .GT            
b288 02				db 1 + 1 
b289 .. 00			db "<",0              
b28b				endm 
# End of macro CWHEAD
b28b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b28b				; TODO add floating point number detection 
b28b					if DEBUG_FORTH_WORDS_KEY 
b28b						DMARK "LES" 
b28b f5				push af  
b28c 3a a0 b2			ld a, (.dmark)  
b28f 32 71 ee			ld (debug_mark),a  
b292 3a a1 b2			ld a, (.dmark+1)  
b295 32 72 ee			ld (debug_mark+1),a  
b298 3a a2 b2			ld a, (.dmark+2)  
b29b 32 73 ee			ld (debug_mark+2),a  
b29e 18 03			jr .pastdmark  
b2a0 ..			.dmark: db "LES"  
b2a3 f1			.pastdmark: pop af  
b2a4			endm  
# End of macro DMARK
b2a4						CALLMONITOR 
b2a4 cd 95 93			call break_point_state  
b2a7				endm  
# End of macro CALLMONITOR
b2a7					endif 
b2a7					FORTH_DSP 
b2a7 cd bd 9b			call macro_forth_dsp 
b2aa				endm 
# End of macro FORTH_DSP
b2aa					;v5 FORTH_DSP_VALUE 
b2aa 7e					ld a,(hl)	; get type of value on TOS 
b2ab fe 02				cp DS_TYPE_INUM  
b2ad 28 00				jr z, .less_inum 
b2af			 
b2af				if FORTH_ENABLE_FLOATMATH 
b2af					jr .less_done 
b2af			 
b2af				endif 
b2af					 
b2af			 
b2af			.less_inum: 
b2af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2af cd f7 9b			call macro_dsp_valuehl 
b2b2				endm 
# End of macro FORTH_DSP_VALUEHL
b2b2			 
b2b2 e5					push hl  ; u2 
b2b3			 
b2b3					; destroy value TOS 
b2b3			 
b2b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2b3 cd af 9c			call macro_forth_dsp_pop 
b2b6				endm 
# End of macro FORTH_DSP_POP
b2b6			 
b2b6			 
b2b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2b6 cd f7 9b			call macro_dsp_valuehl 
b2b9				endm 
# End of macro FORTH_DSP_VALUEHL
b2b9			 
b2b9 e5					push hl    ; u1 
b2ba			 
b2ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ba cd af 9c			call macro_forth_dsp_pop 
b2bd				endm 
# End of macro FORTH_DSP_POP
b2bd			 
b2bd			 
b2bd b7			 or a      ;clear carry flag 
b2be 01 00 00		 ld bc, FORTH_FALSE 
b2c1 e1			  pop hl    ; u1 
b2c2 d1			  pop de    ; u2 
b2c3 ed 52		  sbc hl,de 
b2c5 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b2c7			 
b2c7 01 01 00		 ld bc, FORTH_TRUE 
b2ca			.lscont:  
b2ca c5					push bc 
b2cb e1					pop hl 
b2cc			 
b2cc					if DEBUG_FORTH_WORDS 
b2cc						DMARK "LT1" 
b2cc f5				push af  
b2cd 3a e1 b2			ld a, (.dmark)  
b2d0 32 71 ee			ld (debug_mark),a  
b2d3 3a e2 b2			ld a, (.dmark+1)  
b2d6 32 72 ee			ld (debug_mark+1),a  
b2d9 3a e3 b2			ld a, (.dmark+2)  
b2dc 32 73 ee			ld (debug_mark+2),a  
b2df 18 03			jr .pastdmark  
b2e1 ..			.dmark: db "LT1"  
b2e4 f1			.pastdmark: pop af  
b2e5			endm  
# End of macro DMARK
b2e5						CALLMONITOR 
b2e5 cd 95 93			call break_point_state  
b2e8				endm  
# End of macro CALLMONITOR
b2e8					endif 
b2e8 cd 00 9a				call forth_push_numhl 
b2eb			 
b2eb					NEXTW 
b2eb c3 69 9d			jp macro_next 
b2ee				endm 
# End of macro NEXTW
b2ee			.GT: 
b2ee				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b2ee 30				db WORD_SYS_CORE+28             
b2ef 57 b3			dw .EQUAL            
b2f1 02				db 1 + 1 
b2f2 .. 00			db ">",0              
b2f4				endm 
# End of macro CWHEAD
b2f4			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b2f4				; TODO add floating point number detection 
b2f4					if DEBUG_FORTH_WORDS_KEY 
b2f4						DMARK "GRT" 
b2f4 f5				push af  
b2f5 3a 09 b3			ld a, (.dmark)  
b2f8 32 71 ee			ld (debug_mark),a  
b2fb 3a 0a b3			ld a, (.dmark+1)  
b2fe 32 72 ee			ld (debug_mark+1),a  
b301 3a 0b b3			ld a, (.dmark+2)  
b304 32 73 ee			ld (debug_mark+2),a  
b307 18 03			jr .pastdmark  
b309 ..			.dmark: db "GRT"  
b30c f1			.pastdmark: pop af  
b30d			endm  
# End of macro DMARK
b30d						CALLMONITOR 
b30d cd 95 93			call break_point_state  
b310				endm  
# End of macro CALLMONITOR
b310					endif 
b310					FORTH_DSP 
b310 cd bd 9b			call macro_forth_dsp 
b313				endm 
# End of macro FORTH_DSP
b313					;FORTH_DSP_VALUE 
b313 7e					ld a,(hl)	; get type of value on TOS 
b314 fe 02				cp DS_TYPE_INUM  
b316 28 00				jr z, .gt_inum 
b318			 
b318				if FORTH_ENABLE_FLOATMATH 
b318					jr .gt_done 
b318			 
b318				endif 
b318					 
b318			 
b318			.gt_inum: 
b318					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b318 cd f7 9b			call macro_dsp_valuehl 
b31b				endm 
# End of macro FORTH_DSP_VALUEHL
b31b			 
b31b e5					push hl  ; u2 
b31c			 
b31c					; destroy value TOS 
b31c			 
b31c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b31c cd af 9c			call macro_forth_dsp_pop 
b31f				endm 
# End of macro FORTH_DSP_POP
b31f			 
b31f			 
b31f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b31f cd f7 9b			call macro_dsp_valuehl 
b322				endm 
# End of macro FORTH_DSP_VALUEHL
b322			 
b322 e5					push hl    ; u1 
b323			 
b323					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b323 cd af 9c			call macro_forth_dsp_pop 
b326				endm 
# End of macro FORTH_DSP_POP
b326			 
b326			 
b326 b7			 or a      ;clear carry flag 
b327 01 00 00		 ld bc, FORTH_FALSE 
b32a e1			  pop hl    ; u1 
b32b d1			  pop de    ; u2 
b32c ed 52		  sbc hl,de 
b32e 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b330			 
b330 01 01 00		 ld bc, FORTH_TRUE 
b333			.gtcont:  
b333 c5					push bc 
b334 e1					pop hl 
b335			 
b335					if DEBUG_FORTH_WORDS 
b335						DMARK "GT1" 
b335 f5				push af  
b336 3a 4a b3			ld a, (.dmark)  
b339 32 71 ee			ld (debug_mark),a  
b33c 3a 4b b3			ld a, (.dmark+1)  
b33f 32 72 ee			ld (debug_mark+1),a  
b342 3a 4c b3			ld a, (.dmark+2)  
b345 32 73 ee			ld (debug_mark+2),a  
b348 18 03			jr .pastdmark  
b34a ..			.dmark: db "GT1"  
b34d f1			.pastdmark: pop af  
b34e			endm  
# End of macro DMARK
b34e						CALLMONITOR 
b34e cd 95 93			call break_point_state  
b351				endm  
# End of macro CALLMONITOR
b351					endif 
b351 cd 00 9a				call forth_push_numhl 
b354			 
b354					NEXTW 
b354 c3 69 9d			jp macro_next 
b357				endm 
# End of macro NEXTW
b357			.EQUAL: 
b357				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b357 31				db WORD_SYS_CORE+29             
b358 c2 b3			dw .ENDLOGIC            
b35a 02				db 1 + 1 
b35b .. 00			db "=",0              
b35d				endm 
# End of macro CWHEAD
b35d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b35d				; TODO add floating point number detection 
b35d					if DEBUG_FORTH_WORDS_KEY 
b35d						DMARK "EQ." 
b35d f5				push af  
b35e 3a 72 b3			ld a, (.dmark)  
b361 32 71 ee			ld (debug_mark),a  
b364 3a 73 b3			ld a, (.dmark+1)  
b367 32 72 ee			ld (debug_mark+1),a  
b36a 3a 74 b3			ld a, (.dmark+2)  
b36d 32 73 ee			ld (debug_mark+2),a  
b370 18 03			jr .pastdmark  
b372 ..			.dmark: db "EQ."  
b375 f1			.pastdmark: pop af  
b376			endm  
# End of macro DMARK
b376						CALLMONITOR 
b376 cd 95 93			call break_point_state  
b379				endm  
# End of macro CALLMONITOR
b379					endif 
b379					FORTH_DSP 
b379 cd bd 9b			call macro_forth_dsp 
b37c				endm 
# End of macro FORTH_DSP
b37c					;v5 FORTH_DSP_VALUE 
b37c 7e					ld a,(hl)	; get type of value on TOS 
b37d fe 02				cp DS_TYPE_INUM  
b37f 28 00				jr z, .eq_inum 
b381			 
b381				if FORTH_ENABLE_FLOATMATH 
b381					jr .eq_done 
b381			 
b381				endif 
b381					 
b381			 
b381			.eq_inum: 
b381					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b381 cd f7 9b			call macro_dsp_valuehl 
b384				endm 
# End of macro FORTH_DSP_VALUEHL
b384			 
b384 e5					push hl 
b385			 
b385					; destroy value TOS 
b385			 
b385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b385 cd af 9c			call macro_forth_dsp_pop 
b388				endm 
# End of macro FORTH_DSP_POP
b388			 
b388			 
b388					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b388 cd f7 9b			call macro_dsp_valuehl 
b38b				endm 
# End of macro FORTH_DSP_VALUEHL
b38b			 
b38b					; one value on hl get other one back 
b38b			 
b38b e5					push hl 
b38c			 
b38c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b38c cd af 9c			call macro_forth_dsp_pop 
b38f				endm 
# End of macro FORTH_DSP_POP
b38f			 
b38f 0e 00				ld c, FORTH_FALSE 
b391			 
b391 e1					pop hl 
b392 d1					pop de 
b393			 
b393 7b					ld a, e 
b394 bd					cp l 
b395			 
b395 20 06				jr nz, .eq_done 
b397			 
b397 7a					ld a, d 
b398 bc					cp h 
b399			 
b399 20 02				jr nz, .eq_done 
b39b			 
b39b 0e 01				ld c, FORTH_TRUE 
b39d					 
b39d			 
b39d			 
b39d			.eq_done: 
b39d			 
b39d					; TODO push value back onto stack for another op etc 
b39d			 
b39d 26 00				ld h, 0 
b39f 69					ld l, c 
b3a0					if DEBUG_FORTH_WORDS 
b3a0						DMARK "EQ1" 
b3a0 f5				push af  
b3a1 3a b5 b3			ld a, (.dmark)  
b3a4 32 71 ee			ld (debug_mark),a  
b3a7 3a b6 b3			ld a, (.dmark+1)  
b3aa 32 72 ee			ld (debug_mark+1),a  
b3ad 3a b7 b3			ld a, (.dmark+2)  
b3b0 32 73 ee			ld (debug_mark+2),a  
b3b3 18 03			jr .pastdmark  
b3b5 ..			.dmark: db "EQ1"  
b3b8 f1			.pastdmark: pop af  
b3b9			endm  
# End of macro DMARK
b3b9						CALLMONITOR 
b3b9 cd 95 93			call break_point_state  
b3bc				endm  
# End of macro CALLMONITOR
b3bc					endif 
b3bc cd 00 9a				call forth_push_numhl 
b3bf			 
b3bf					NEXTW 
b3bf c3 69 9d			jp macro_next 
b3c2				endm 
# End of macro NEXTW
b3c2			 
b3c2			 
b3c2			.ENDLOGIC: 
b3c2			; eof 
b3c2			 
b3c2			 
# End of file forth_words_logic.asm
b3c2			include "forth_words_maths.asm" 
b3c2			 
b3c2			; | ## Maths Words 
b3c2			 
b3c2			.PLUS:	 
b3c2				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b3c2 15				db WORD_SYS_CORE+1             
b3c3 04 b4			dw .NEG            
b3c5 02				db 1 + 1 
b3c6 .. 00			db "+",0              
b3c8				endm 
# End of macro CWHEAD
b3c8			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b3c8					if DEBUG_FORTH_WORDS_KEY 
b3c8						DMARK "PLU" 
b3c8 f5				push af  
b3c9 3a dd b3			ld a, (.dmark)  
b3cc 32 71 ee			ld (debug_mark),a  
b3cf 3a de b3			ld a, (.dmark+1)  
b3d2 32 72 ee			ld (debug_mark+1),a  
b3d5 3a df b3			ld a, (.dmark+2)  
b3d8 32 73 ee			ld (debug_mark+2),a  
b3db 18 03			jr .pastdmark  
b3dd ..			.dmark: db "PLU"  
b3e0 f1			.pastdmark: pop af  
b3e1			endm  
# End of macro DMARK
b3e1						CALLMONITOR 
b3e1 cd 95 93			call break_point_state  
b3e4				endm  
# End of macro CALLMONITOR
b3e4					endif 
b3e4					; add top two values and push back result 
b3e4			 
b3e4					;for v5 FORTH_DSP_VALUE 
b3e4					FORTH_DSP 
b3e4 cd bd 9b			call macro_forth_dsp 
b3e7				endm 
# End of macro FORTH_DSP
b3e7 7e					ld a,(hl)	; get type of value on TOS 
b3e8 fe 02				cp DS_TYPE_INUM  
b3ea 28 03				jr z, .dot_inum 
b3ec			 
b3ec					NEXTW 
b3ec c3 69 9d			jp macro_next 
b3ef				endm 
# End of macro NEXTW
b3ef			 
b3ef			; float maths 
b3ef			 
b3ef				if FORTH_ENABLE_FLOATMATH 
b3ef						inc hl      ; now at start of numeric as string 
b3ef			 
b3ef					if DEBUG_FORTH_MATHS 
b3ef						DMARK "ADD" 
b3ef				CALLMONITOR 
b3ef					endif 
b3ef			 
b3ef					;ld ix, hl 
b3ef					call CON 
b3ef			 
b3ef			 
b3ef					push hl 
b3ef					 
b3ef					 
b3ef			 
b3ef						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b3ef			 
b3ef					; get next number 
b3ef			 
b3ef						FORTH_DSP_VALUE 
b3ef			 
b3ef						inc hl      ; now at start of numeric as string 
b3ef			 
b3ef					;ld ix, hl 
b3ef					call CON 
b3ef			 
b3ef					push hl 
b3ef			 
b3ef			 
b3ef						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3ef			 
b3ef						; TODO do add 
b3ef			 
b3ef						call IADD 
b3ef			 
b3ef						; TODO get result back as ascii 
b3ef			 
b3ef						; TODO push result  
b3ef			 
b3ef			 
b3ef			 
b3ef						jr .dot_done 
b3ef				endif 
b3ef			 
b3ef			.dot_inum: 
b3ef			 
b3ef			 
b3ef					if DEBUG_FORTH_DOT 
b3ef						DMARK "+IT" 
b3ef				CALLMONITOR 
b3ef					endif 
b3ef			 
b3ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3ef cd f7 9b			call macro_dsp_valuehl 
b3f2				endm 
# End of macro FORTH_DSP_VALUEHL
b3f2			 
b3f2				; TODO add floating point number detection 
b3f2			 
b3f2 e5					push hl 
b3f3			 
b3f3					; destroy value TOS 
b3f3			 
b3f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f3 cd af 9c			call macro_forth_dsp_pop 
b3f6				endm 
# End of macro FORTH_DSP_POP
b3f6			 
b3f6			 
b3f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f6 cd f7 9b			call macro_dsp_valuehl 
b3f9				endm 
# End of macro FORTH_DSP_VALUEHL
b3f9			 
b3f9					; one value on hl get other one back 
b3f9			 
b3f9 d1					pop de 
b3fa			 
b3fa					; do the add 
b3fa			 
b3fa 19					add hl,de 
b3fb			 
b3fb					; save it 
b3fb			 
b3fb			;		push hl	 
b3fb			 
b3fb					; 
b3fb			 
b3fb					; destroy value TOS 
b3fb			 
b3fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fb cd af 9c			call macro_forth_dsp_pop 
b3fe				endm 
# End of macro FORTH_DSP_POP
b3fe			 
b3fe					; TODO push value back onto stack for another op etc 
b3fe			 
b3fe			;		pop hl 
b3fe			 
b3fe			.dot_done: 
b3fe cd 00 9a				call forth_push_numhl 
b401			 
b401					NEXTW 
b401 c3 69 9d			jp macro_next 
b404				endm 
# End of macro NEXTW
b404			.NEG: 
b404			 
b404				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b404 17				db WORD_SYS_CORE+3             
b405 47 b4			dw .DIV            
b407 02				db 1 + 1 
b408 .. 00			db "-",0              
b40a				endm 
# End of macro CWHEAD
b40a			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b40a					if DEBUG_FORTH_WORDS_KEY 
b40a						DMARK "SUB" 
b40a f5				push af  
b40b 3a 1f b4			ld a, (.dmark)  
b40e 32 71 ee			ld (debug_mark),a  
b411 3a 20 b4			ld a, (.dmark+1)  
b414 32 72 ee			ld (debug_mark+1),a  
b417 3a 21 b4			ld a, (.dmark+2)  
b41a 32 73 ee			ld (debug_mark+2),a  
b41d 18 03			jr .pastdmark  
b41f ..			.dmark: db "SUB"  
b422 f1			.pastdmark: pop af  
b423			endm  
# End of macro DMARK
b423						CALLMONITOR 
b423 cd 95 93			call break_point_state  
b426				endm  
# End of macro CALLMONITOR
b426					endif 
b426			 
b426			 
b426				; TODO add floating point number detection 
b426					; v5 FORTH_DSP_VALUE 
b426					FORTH_DSP 
b426 cd bd 9b			call macro_forth_dsp 
b429				endm 
# End of macro FORTH_DSP
b429 7e					ld a,(hl)	; get type of value on TOS 
b42a fe 02				cp DS_TYPE_INUM  
b42c 28 03				jr z, .neg_inum 
b42e			 
b42e					NEXTW 
b42e c3 69 9d			jp macro_next 
b431				endm 
# End of macro NEXTW
b431			 
b431			; float maths 
b431			 
b431				if FORTH_ENABLE_FLOATMATH 
b431					jr .neg_done 
b431			 
b431				endif 
b431					 
b431			 
b431			.neg_inum: 
b431					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b431 cd f7 9b			call macro_dsp_valuehl 
b434				endm 
# End of macro FORTH_DSP_VALUEHL
b434			 
b434 e5					push hl 
b435			 
b435					; destroy value TOS 
b435			 
b435					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b435 cd af 9c			call macro_forth_dsp_pop 
b438				endm 
# End of macro FORTH_DSP_POP
b438			 
b438			 
b438					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b438 cd f7 9b			call macro_dsp_valuehl 
b43b				endm 
# End of macro FORTH_DSP_VALUEHL
b43b			 
b43b					; one value on hl get other one back 
b43b			 
b43b d1					pop de 
b43c			 
b43c					; do the sub 
b43c			;		ex de, hl 
b43c			 
b43c ed 52				sbc hl,de 
b43e			 
b43e					; save it 
b43e			 
b43e			;		push hl	 
b43e			 
b43e					; 
b43e			 
b43e					; destroy value TOS 
b43e			 
b43e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b43e cd af 9c			call macro_forth_dsp_pop 
b441				endm 
# End of macro FORTH_DSP_POP
b441			 
b441					; TODO push value back onto stack for another op etc 
b441			 
b441			;		pop hl 
b441			 
b441 cd 00 9a				call forth_push_numhl 
b444			.neg_done: 
b444			 
b444					NEXTW 
b444 c3 69 9d			jp macro_next 
b447				endm 
# End of macro NEXTW
b447			.DIV: 
b447				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b447 18				db WORD_SYS_CORE+4             
b448 94 b4			dw .MUL            
b44a 02				db 1 + 1 
b44b .. 00			db "/",0              
b44d				endm 
# End of macro CWHEAD
b44d			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b44d					if DEBUG_FORTH_WORDS_KEY 
b44d						DMARK "DIV" 
b44d f5				push af  
b44e 3a 62 b4			ld a, (.dmark)  
b451 32 71 ee			ld (debug_mark),a  
b454 3a 63 b4			ld a, (.dmark+1)  
b457 32 72 ee			ld (debug_mark+1),a  
b45a 3a 64 b4			ld a, (.dmark+2)  
b45d 32 73 ee			ld (debug_mark+2),a  
b460 18 03			jr .pastdmark  
b462 ..			.dmark: db "DIV"  
b465 f1			.pastdmark: pop af  
b466			endm  
# End of macro DMARK
b466						CALLMONITOR 
b466 cd 95 93			call break_point_state  
b469				endm  
# End of macro CALLMONITOR
b469					endif 
b469				; TODO add floating point number detection 
b469					; v5 FORTH_DSP_VALUE 
b469					FORTH_DSP 
b469 cd bd 9b			call macro_forth_dsp 
b46c				endm 
# End of macro FORTH_DSP
b46c 7e					ld a,(hl)	; get type of value on TOS 
b46d fe 02				cp DS_TYPE_INUM  
b46f 28 03				jr z, .div_inum 
b471			 
b471				if FORTH_ENABLE_FLOATMATH 
b471					jr .div_done 
b471			 
b471				endif 
b471					NEXTW 
b471 c3 69 9d			jp macro_next 
b474				endm 
# End of macro NEXTW
b474			.div_inum: 
b474			 
b474					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b474 cd f7 9b			call macro_dsp_valuehl 
b477				endm 
# End of macro FORTH_DSP_VALUEHL
b477			 
b477 e5					push hl    ; to go to bc 
b478			 
b478					; destroy value TOS 
b478			 
b478					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b478 cd af 9c			call macro_forth_dsp_pop 
b47b				endm 
# End of macro FORTH_DSP_POP
b47b			 
b47b			 
b47b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b47b cd f7 9b			call macro_dsp_valuehl 
b47e				endm 
# End of macro FORTH_DSP_VALUEHL
b47e			 
b47e					; hl to go to de 
b47e			 
b47e e5					push hl 
b47f			 
b47f c1					pop bc 
b480 d1					pop de		 
b481			 
b481			 
b481					if DEBUG_FORTH_MATHS 
b481						DMARK "DIV" 
b481				CALLMONITOR 
b481					endif 
b481					; one value on hl but move to a get other one back 
b481			 
b481			        
b481 cd f1 8a			call Div16 
b484			 
b484			;	push af	 
b484 e5				push hl 
b485 c5				push bc 
b486			 
b486					if DEBUG_FORTH_MATHS 
b486						DMARK "DI1" 
b486				CALLMONITOR 
b486					endif 
b486			 
b486					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b486 cd af 9c			call macro_forth_dsp_pop 
b489				endm 
# End of macro FORTH_DSP_POP
b489			 
b489			 
b489			 
b489 e1					pop hl    ; result 
b48a			 
b48a cd 00 9a				call forth_push_numhl 
b48d			 
b48d e1					pop hl    ; reminder 
b48e			;		ld h,0 
b48e			;		ld l,d 
b48e			 
b48e cd 00 9a				call forth_push_numhl 
b491			.div_done: 
b491					NEXTW 
b491 c3 69 9d			jp macro_next 
b494				endm 
# End of macro NEXTW
b494			.MUL: 
b494				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b494 19				db WORD_SYS_CORE+5             
b495 d9 b4			dw .MIN            
b497 02				db 1 + 1 
b498 .. 00			db "*",0              
b49a				endm 
# End of macro CWHEAD
b49a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b49a				; TODO add floating point number detection 
b49a					if DEBUG_FORTH_WORDS_KEY 
b49a						DMARK "MUL" 
b49a f5				push af  
b49b 3a af b4			ld a, (.dmark)  
b49e 32 71 ee			ld (debug_mark),a  
b4a1 3a b0 b4			ld a, (.dmark+1)  
b4a4 32 72 ee			ld (debug_mark+1),a  
b4a7 3a b1 b4			ld a, (.dmark+2)  
b4aa 32 73 ee			ld (debug_mark+2),a  
b4ad 18 03			jr .pastdmark  
b4af ..			.dmark: db "MUL"  
b4b2 f1			.pastdmark: pop af  
b4b3			endm  
# End of macro DMARK
b4b3						CALLMONITOR 
b4b3 cd 95 93			call break_point_state  
b4b6				endm  
# End of macro CALLMONITOR
b4b6					endif 
b4b6					FORTH_DSP 
b4b6 cd bd 9b			call macro_forth_dsp 
b4b9				endm 
# End of macro FORTH_DSP
b4b9					; v5 FORTH_DSP_VALUE 
b4b9 7e					ld a,(hl)	; get type of value on TOS 
b4ba fe 02				cp DS_TYPE_INUM  
b4bc 28 03				jr z, .mul_inum 
b4be			 
b4be				if FORTH_ENABLE_FLOATMATH 
b4be					jr .mul_done 
b4be			 
b4be				endif 
b4be			 
b4be					NEXTW 
b4be c3 69 9d			jp macro_next 
b4c1				endm 
# End of macro NEXTW
b4c1			.mul_inum:	 
b4c1			 
b4c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4c1 cd f7 9b			call macro_dsp_valuehl 
b4c4				endm 
# End of macro FORTH_DSP_VALUEHL
b4c4			 
b4c4 e5					push hl 
b4c5			 
b4c5					; destroy value TOS 
b4c5			 
b4c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4c5 cd af 9c			call macro_forth_dsp_pop 
b4c8				endm 
# End of macro FORTH_DSP_POP
b4c8			 
b4c8			 
b4c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4c8 cd f7 9b			call macro_dsp_valuehl 
b4cb				endm 
# End of macro FORTH_DSP_VALUEHL
b4cb			 
b4cb					; one value on hl but move to a get other one back 
b4cb			 
b4cb 7d					ld a, l 
b4cc			 
b4cc d1					pop de 
b4cd			 
b4cd					; do the mull 
b4cd			;		ex de, hl 
b4cd			 
b4cd cd 17 8b				call Mult16 
b4d0					; save it 
b4d0			 
b4d0			;		push hl	 
b4d0			 
b4d0					; 
b4d0			 
b4d0					; destroy value TOS 
b4d0			 
b4d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d0 cd af 9c			call macro_forth_dsp_pop 
b4d3				endm 
# End of macro FORTH_DSP_POP
b4d3			 
b4d3					; TODO push value back onto stack for another op etc 
b4d3			 
b4d3			;		pop hl 
b4d3			 
b4d3 cd 00 9a				call forth_push_numhl 
b4d6			 
b4d6			.mul_done: 
b4d6					NEXTW 
b4d6 c3 69 9d			jp macro_next 
b4d9				endm 
# End of macro NEXTW
b4d9			 
b4d9			 
b4d9			 
b4d9			 
b4d9			.MIN: 
b4d9				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b4d9 49				db WORD_SYS_CORE+53             
b4da 5a b5			dw .MAX            
b4dc 04				db 3 + 1 
b4dd .. 00			db "MIN",0              
b4e1				endm 
# End of macro CWHEAD
b4e1			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b4e1					if DEBUG_FORTH_WORDS_KEY 
b4e1						DMARK "MIN" 
b4e1 f5				push af  
b4e2 3a f6 b4			ld a, (.dmark)  
b4e5 32 71 ee			ld (debug_mark),a  
b4e8 3a f7 b4			ld a, (.dmark+1)  
b4eb 32 72 ee			ld (debug_mark+1),a  
b4ee 3a f8 b4			ld a, (.dmark+2)  
b4f1 32 73 ee			ld (debug_mark+2),a  
b4f4 18 03			jr .pastdmark  
b4f6 ..			.dmark: db "MIN"  
b4f9 f1			.pastdmark: pop af  
b4fa			endm  
# End of macro DMARK
b4fa						CALLMONITOR 
b4fa cd 95 93			call break_point_state  
b4fd				endm  
# End of macro CALLMONITOR
b4fd					endif 
b4fd					; get u2 
b4fd			 
b4fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4fd cd f7 9b			call macro_dsp_valuehl 
b500				endm 
# End of macro FORTH_DSP_VALUEHL
b500			 
b500 e5					push hl   ; u2 
b501			 
b501					; destroy value TOS 
b501			 
b501					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b501 cd af 9c			call macro_forth_dsp_pop 
b504				endm 
# End of macro FORTH_DSP_POP
b504			 
b504					; get u1 
b504			 
b504					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b504 cd f7 9b			call macro_dsp_valuehl 
b507				endm 
# End of macro FORTH_DSP_VALUEHL
b507			 
b507 e5					push hl  ; u1 
b508			 
b508					; destroy value TOS 
b508			 
b508					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b508 cd af 9c			call macro_forth_dsp_pop 
b50b				endm 
# End of macro FORTH_DSP_POP
b50b			 
b50b b7			 or a      ;clear carry flag 
b50c e1			  pop hl    ; u1 
b50d d1			  pop de    ; u2 
b50e e5				push hl   ; saved in case hl is lowest 
b50f ed 52		  sbc hl,de 
b511 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b513			 
b513 e1				pop hl 
b514					if DEBUG_FORTH_WORDS 
b514						DMARK "MIN" 
b514 f5				push af  
b515 3a 29 b5			ld a, (.dmark)  
b518 32 71 ee			ld (debug_mark),a  
b51b 3a 2a b5			ld a, (.dmark+1)  
b51e 32 72 ee			ld (debug_mark+1),a  
b521 3a 2b b5			ld a, (.dmark+2)  
b524 32 73 ee			ld (debug_mark+2),a  
b527 18 03			jr .pastdmark  
b529 ..			.dmark: db "MIN"  
b52c f1			.pastdmark: pop af  
b52d			endm  
# End of macro DMARK
b52d						CALLMONITOR 
b52d cd 95 93			call break_point_state  
b530				endm  
# End of macro CALLMONITOR
b530					endif 
b530 cd 00 9a				call forth_push_numhl 
b533			 
b533				       NEXTW 
b533 c3 69 9d			jp macro_next 
b536				endm 
# End of macro NEXTW
b536			 
b536			.mincont:  
b536 c1				pop bc   ; tidy up 
b537 eb				ex de , hl  
b538					if DEBUG_FORTH_WORDS 
b538						DMARK "MI1" 
b538 f5				push af  
b539 3a 4d b5			ld a, (.dmark)  
b53c 32 71 ee			ld (debug_mark),a  
b53f 3a 4e b5			ld a, (.dmark+1)  
b542 32 72 ee			ld (debug_mark+1),a  
b545 3a 4f b5			ld a, (.dmark+2)  
b548 32 73 ee			ld (debug_mark+2),a  
b54b 18 03			jr .pastdmark  
b54d ..			.dmark: db "MI1"  
b550 f1			.pastdmark: pop af  
b551			endm  
# End of macro DMARK
b551						CALLMONITOR 
b551 cd 95 93			call break_point_state  
b554				endm  
# End of macro CALLMONITOR
b554					endif 
b554 cd 00 9a				call forth_push_numhl 
b557			 
b557				       NEXTW 
b557 c3 69 9d			jp macro_next 
b55a				endm 
# End of macro NEXTW
b55a			.MAX: 
b55a				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b55a 4a				db WORD_SYS_CORE+54             
b55b db b5			dw .RND16            
b55d 04				db 3 + 1 
b55e .. 00			db "MAX",0              
b562				endm 
# End of macro CWHEAD
b562			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b562					if DEBUG_FORTH_WORDS_KEY 
b562						DMARK "MAX" 
b562 f5				push af  
b563 3a 77 b5			ld a, (.dmark)  
b566 32 71 ee			ld (debug_mark),a  
b569 3a 78 b5			ld a, (.dmark+1)  
b56c 32 72 ee			ld (debug_mark+1),a  
b56f 3a 79 b5			ld a, (.dmark+2)  
b572 32 73 ee			ld (debug_mark+2),a  
b575 18 03			jr .pastdmark  
b577 ..			.dmark: db "MAX"  
b57a f1			.pastdmark: pop af  
b57b			endm  
# End of macro DMARK
b57b						CALLMONITOR 
b57b cd 95 93			call break_point_state  
b57e				endm  
# End of macro CALLMONITOR
b57e					endif 
b57e					; get u2 
b57e			 
b57e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b57e cd f7 9b			call macro_dsp_valuehl 
b581				endm 
# End of macro FORTH_DSP_VALUEHL
b581			 
b581 e5					push hl   ; u2 
b582			 
b582					; destroy value TOS 
b582			 
b582					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b582 cd af 9c			call macro_forth_dsp_pop 
b585				endm 
# End of macro FORTH_DSP_POP
b585			 
b585					; get u1 
b585			 
b585					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b585 cd f7 9b			call macro_dsp_valuehl 
b588				endm 
# End of macro FORTH_DSP_VALUEHL
b588			 
b588 e5					push hl  ; u1 
b589			 
b589					; destroy value TOS 
b589			 
b589					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b589 cd af 9c			call macro_forth_dsp_pop 
b58c				endm 
# End of macro FORTH_DSP_POP
b58c			 
b58c b7			 or a      ;clear carry flag 
b58d e1			  pop hl    ; u1 
b58e d1			  pop de    ; u2 
b58f e5				push hl   ; saved in case hl is lowest 
b590 ed 52		  sbc hl,de 
b592 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b594			 
b594 e1				pop hl 
b595					if DEBUG_FORTH_WORDS 
b595						DMARK "MAX" 
b595 f5				push af  
b596 3a aa b5			ld a, (.dmark)  
b599 32 71 ee			ld (debug_mark),a  
b59c 3a ab b5			ld a, (.dmark+1)  
b59f 32 72 ee			ld (debug_mark+1),a  
b5a2 3a ac b5			ld a, (.dmark+2)  
b5a5 32 73 ee			ld (debug_mark+2),a  
b5a8 18 03			jr .pastdmark  
b5aa ..			.dmark: db "MAX"  
b5ad f1			.pastdmark: pop af  
b5ae			endm  
# End of macro DMARK
b5ae						CALLMONITOR 
b5ae cd 95 93			call break_point_state  
b5b1				endm  
# End of macro CALLMONITOR
b5b1					endif 
b5b1 cd 00 9a				call forth_push_numhl 
b5b4			 
b5b4				       NEXTW 
b5b4 c3 69 9d			jp macro_next 
b5b7				endm 
# End of macro NEXTW
b5b7			 
b5b7			.maxcont:  
b5b7 c1				pop bc   ; tidy up 
b5b8 eb				ex de , hl  
b5b9					if DEBUG_FORTH_WORDS 
b5b9						DMARK "MA1" 
b5b9 f5				push af  
b5ba 3a ce b5			ld a, (.dmark)  
b5bd 32 71 ee			ld (debug_mark),a  
b5c0 3a cf b5			ld a, (.dmark+1)  
b5c3 32 72 ee			ld (debug_mark+1),a  
b5c6 3a d0 b5			ld a, (.dmark+2)  
b5c9 32 73 ee			ld (debug_mark+2),a  
b5cc 18 03			jr .pastdmark  
b5ce ..			.dmark: db "MA1"  
b5d1 f1			.pastdmark: pop af  
b5d2			endm  
# End of macro DMARK
b5d2						CALLMONITOR 
b5d2 cd 95 93			call break_point_state  
b5d5				endm  
# End of macro CALLMONITOR
b5d5					endif 
b5d5 cd 00 9a				call forth_push_numhl 
b5d8				       NEXTW 
b5d8 c3 69 9d			jp macro_next 
b5db				endm 
# End of macro NEXTW
b5db			 
b5db			.RND16: 
b5db				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b5db 4e				db WORD_SYS_CORE+58             
b5dc 0a b6			dw .RND8            
b5de 06				db 5 + 1 
b5df .. 00			db "RND16",0              
b5e5				endm 
# End of macro CWHEAD
b5e5			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b5e5					if DEBUG_FORTH_WORDS_KEY 
b5e5						DMARK "R16" 
b5e5 f5				push af  
b5e6 3a fa b5			ld a, (.dmark)  
b5e9 32 71 ee			ld (debug_mark),a  
b5ec 3a fb b5			ld a, (.dmark+1)  
b5ef 32 72 ee			ld (debug_mark+1),a  
b5f2 3a fc b5			ld a, (.dmark+2)  
b5f5 32 73 ee			ld (debug_mark+2),a  
b5f8 18 03			jr .pastdmark  
b5fa ..			.dmark: db "R16"  
b5fd f1			.pastdmark: pop af  
b5fe			endm  
# End of macro DMARK
b5fe						CALLMONITOR 
b5fe cd 95 93			call break_point_state  
b601				endm  
# End of macro CALLMONITOR
b601					endif 
b601 cd bb 8a				call prng16  
b604 cd 00 9a				call forth_push_numhl 
b607				       NEXTW 
b607 c3 69 9d			jp macro_next 
b60a				endm 
# End of macro NEXTW
b60a			.RND8: 
b60a				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b60a 60				db WORD_SYS_CORE+76             
b60b 3f b6			dw .RND            
b60d 05				db 4 + 1 
b60e .. 00			db "RND8",0              
b613				endm 
# End of macro CWHEAD
b613			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b613					if DEBUG_FORTH_WORDS_KEY 
b613						DMARK "RN8" 
b613 f5				push af  
b614 3a 28 b6			ld a, (.dmark)  
b617 32 71 ee			ld (debug_mark),a  
b61a 3a 29 b6			ld a, (.dmark+1)  
b61d 32 72 ee			ld (debug_mark+1),a  
b620 3a 2a b6			ld a, (.dmark+2)  
b623 32 73 ee			ld (debug_mark+2),a  
b626 18 03			jr .pastdmark  
b628 ..			.dmark: db "RN8"  
b62b f1			.pastdmark: pop af  
b62c			endm  
# End of macro DMARK
b62c						CALLMONITOR 
b62c cd 95 93			call break_point_state  
b62f				endm  
# End of macro CALLMONITOR
b62f					endif 
b62f 2a b2 eb				ld hl,(xrandc) 
b632 23					inc hl 
b633 cd d5 8a				call xrnd 
b636 6f					ld l,a	 
b637 26 00				ld h,0 
b639 cd 00 9a				call forth_push_numhl 
b63c				       NEXTW 
b63c c3 69 9d			jp macro_next 
b63f				endm 
# End of macro NEXTW
b63f			.RND: 
b63f				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b63f 60				db WORD_SYS_CORE+76             
b640 45 b7			dw .ENDMATHS            
b642 04				db 3 + 1 
b643 .. 00			db "RND",0              
b647				endm 
# End of macro CWHEAD
b647			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b647			 
b647					if DEBUG_FORTH_WORDS_KEY 
b647						DMARK "RND" 
b647 f5				push af  
b648 3a 5c b6			ld a, (.dmark)  
b64b 32 71 ee			ld (debug_mark),a  
b64e 3a 5d b6			ld a, (.dmark+1)  
b651 32 72 ee			ld (debug_mark+1),a  
b654 3a 5e b6			ld a, (.dmark+2)  
b657 32 73 ee			ld (debug_mark+2),a  
b65a 18 03			jr .pastdmark  
b65c ..			.dmark: db "RND"  
b65f f1			.pastdmark: pop af  
b660			endm  
# End of macro DMARK
b660						CALLMONITOR 
b660 cd 95 93			call break_point_state  
b663				endm  
# End of macro CALLMONITOR
b663					endif 
b663					 
b663					FORTH_DSP_VALUEHL    ; upper range 
b663 cd f7 9b			call macro_dsp_valuehl 
b666				endm 
# End of macro FORTH_DSP_VALUEHL
b666			 
b666 22 b6 eb				ld (LFSRSeed), hl	 
b669			 
b669					if DEBUG_FORTH_WORDS 
b669						DMARK "RN1" 
b669 f5				push af  
b66a 3a 7e b6			ld a, (.dmark)  
b66d 32 71 ee			ld (debug_mark),a  
b670 3a 7f b6			ld a, (.dmark+1)  
b673 32 72 ee			ld (debug_mark+1),a  
b676 3a 80 b6			ld a, (.dmark+2)  
b679 32 73 ee			ld (debug_mark+2),a  
b67c 18 03			jr .pastdmark  
b67e ..			.dmark: db "RN1"  
b681 f1			.pastdmark: pop af  
b682			endm  
# End of macro DMARK
b682						CALLMONITOR 
b682 cd 95 93			call break_point_state  
b685				endm  
# End of macro CALLMONITOR
b685					endif 
b685					FORTH_DSP_POP 
b685 cd af 9c			call macro_forth_dsp_pop 
b688				endm 
# End of macro FORTH_DSP_POP
b688			 
b688					FORTH_DSP_VALUEHL    ; low range 
b688 cd f7 9b			call macro_dsp_valuehl 
b68b				endm 
# End of macro FORTH_DSP_VALUEHL
b68b			 
b68b					if DEBUG_FORTH_WORDS 
b68b						DMARK "RN2" 
b68b f5				push af  
b68c 3a a0 b6			ld a, (.dmark)  
b68f 32 71 ee			ld (debug_mark),a  
b692 3a a1 b6			ld a, (.dmark+1)  
b695 32 72 ee			ld (debug_mark+1),a  
b698 3a a2 b6			ld a, (.dmark+2)  
b69b 32 73 ee			ld (debug_mark+2),a  
b69e 18 03			jr .pastdmark  
b6a0 ..			.dmark: db "RN2"  
b6a3 f1			.pastdmark: pop af  
b6a4			endm  
# End of macro DMARK
b6a4						CALLMONITOR 
b6a4 cd 95 93			call break_point_state  
b6a7				endm  
# End of macro CALLMONITOR
b6a7					endif 
b6a7 22 b8 eb				ld (LFSRSeed+2), hl 
b6aa			 
b6aa					FORTH_DSP_POP 
b6aa cd af 9c			call macro_forth_dsp_pop 
b6ad				endm 
# End of macro FORTH_DSP_POP
b6ad			 
b6ad e5					push hl 
b6ae			 
b6ae e1			.inrange:	pop hl 
b6af cd bb 8a				call prng16  
b6b2					if DEBUG_FORTH_WORDS 
b6b2						DMARK "RN3" 
b6b2 f5				push af  
b6b3 3a c7 b6			ld a, (.dmark)  
b6b6 32 71 ee			ld (debug_mark),a  
b6b9 3a c8 b6			ld a, (.dmark+1)  
b6bc 32 72 ee			ld (debug_mark+1),a  
b6bf 3a c9 b6			ld a, (.dmark+2)  
b6c2 32 73 ee			ld (debug_mark+2),a  
b6c5 18 03			jr .pastdmark  
b6c7 ..			.dmark: db "RN3"  
b6ca f1			.pastdmark: pop af  
b6cb			endm  
# End of macro DMARK
b6cb						CALLMONITOR 
b6cb cd 95 93			call break_point_state  
b6ce				endm  
# End of macro CALLMONITOR
b6ce					endif 
b6ce					 
b6ce					; if the range is 8bit knock out the high byte 
b6ce			 
b6ce ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b6d2			 
b6d2 3e 00				ld a, 0 
b6d4 ba					cp d  
b6d5 20 1e				jr nz, .hirange 
b6d7 26 00				ld h, 0   ; knock it down to 8bit 
b6d9			 
b6d9					if DEBUG_FORTH_WORDS 
b6d9						DMARK "RNk" 
b6d9 f5				push af  
b6da 3a ee b6			ld a, (.dmark)  
b6dd 32 71 ee			ld (debug_mark),a  
b6e0 3a ef b6			ld a, (.dmark+1)  
b6e3 32 72 ee			ld (debug_mark+1),a  
b6e6 3a f0 b6			ld a, (.dmark+2)  
b6e9 32 73 ee			ld (debug_mark+2),a  
b6ec 18 03			jr .pastdmark  
b6ee ..			.dmark: db "RNk"  
b6f1 f1			.pastdmark: pop af  
b6f2			endm  
# End of macro DMARK
b6f2						CALLMONITOR 
b6f2 cd 95 93			call break_point_state  
b6f5				endm  
# End of macro CALLMONITOR
b6f5					endif 
b6f5			.hirange:   
b6f5 e5					push hl  
b6f6 b7					or a  
b6f7 ed 52		                sbc hl, de 
b6f9			 
b6f9					;call cmp16 
b6f9			 
b6f9 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b6fb e1					pop hl 
b6fc e5					push hl 
b6fd			 
b6fd					if DEBUG_FORTH_WORDS 
b6fd						DMARK "RN4" 
b6fd f5				push af  
b6fe 3a 12 b7			ld a, (.dmark)  
b701 32 71 ee			ld (debug_mark),a  
b704 3a 13 b7			ld a, (.dmark+1)  
b707 32 72 ee			ld (debug_mark+1),a  
b70a 3a 14 b7			ld a, (.dmark+2)  
b70d 32 73 ee			ld (debug_mark+2),a  
b710 18 03			jr .pastdmark  
b712 ..			.dmark: db "RN4"  
b715 f1			.pastdmark: pop af  
b716			endm  
# End of macro DMARK
b716						CALLMONITOR 
b716 cd 95 93			call break_point_state  
b719				endm  
# End of macro CALLMONITOR
b719					endif 
b719 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b71d					;call cmp16 
b71d				 
b71d b7					or a  
b71e ed 52		                sbc hl, de 
b720 38 8c				jr c, .inrange 
b722			 
b722 e1					pop hl 
b723					 
b723					if DEBUG_FORTH_WORDS 
b723						DMARK "RNd" 
b723 f5				push af  
b724 3a 38 b7			ld a, (.dmark)  
b727 32 71 ee			ld (debug_mark),a  
b72a 3a 39 b7			ld a, (.dmark+1)  
b72d 32 72 ee			ld (debug_mark+1),a  
b730 3a 3a b7			ld a, (.dmark+2)  
b733 32 73 ee			ld (debug_mark+2),a  
b736 18 03			jr .pastdmark  
b738 ..			.dmark: db "RNd"  
b73b f1			.pastdmark: pop af  
b73c			endm  
# End of macro DMARK
b73c						CALLMONITOR 
b73c cd 95 93			call break_point_state  
b73f				endm  
# End of macro CALLMONITOR
b73f					endif 
b73f			 
b73f			 
b73f cd 00 9a				call forth_push_numhl 
b742				       NEXTW 
b742 c3 69 9d			jp macro_next 
b745				endm 
# End of macro NEXTW
b745			 
b745			.ENDMATHS: 
b745			 
b745			; eof 
b745			 
# End of file forth_words_maths.asm
b745			include "forth_words_display.asm" 
b745			 
b745			; | ## Display Words 
b745			 
b745			.INFO: 
b745			 
b745				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b745 62				db WORD_SYS_CORE+78             
b746 62 b7			dw .ATP            
b748 05				db 4 + 1 
b749 .. 00			db "INFO",0              
b74e				endm 
# End of macro CWHEAD
b74e			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b74e					FORTH_DSP_VALUEHL 
b74e cd f7 9b			call macro_dsp_valuehl 
b751				endm 
# End of macro FORTH_DSP_VALUEHL
b751			 
b751					FORTH_DSP_POP 
b751 cd af 9c			call macro_forth_dsp_pop 
b754				endm 
# End of macro FORTH_DSP_POP
b754			 
b754 e5					push hl 
b755			 
b755					FORTH_DSP_VALUEHL 
b755 cd f7 9b			call macro_dsp_valuehl 
b758				endm 
# End of macro FORTH_DSP_VALUEHL
b758			 
b758					FORTH_DSP_POP 
b758 cd af 9c			call macro_forth_dsp_pop 
b75b				endm 
# End of macro FORTH_DSP_POP
b75b			 
b75b d1					pop de 
b75c			 
b75c cd f8 88				call info_panel 
b75f			 
b75f			 
b75f					NEXTW 
b75f c3 69 9d			jp macro_next 
b762				endm 
# End of macro NEXTW
b762			.ATP: 
b762				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b762 62				db WORD_SYS_CORE+78             
b763 d9 b7			dw .FB            
b765 04				db 3 + 1 
b766 .. 00			db "AT?",0              
b76a				endm 
# End of macro CWHEAD
b76a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b76a					if DEBUG_FORTH_WORDS_KEY 
b76a						DMARK "AT?" 
b76a f5				push af  
b76b 3a 7f b7			ld a, (.dmark)  
b76e 32 71 ee			ld (debug_mark),a  
b771 3a 80 b7			ld a, (.dmark+1)  
b774 32 72 ee			ld (debug_mark+1),a  
b777 3a 81 b7			ld a, (.dmark+2)  
b77a 32 73 ee			ld (debug_mark+2),a  
b77d 18 03			jr .pastdmark  
b77f ..			.dmark: db "AT?"  
b782 f1			.pastdmark: pop af  
b783			endm  
# End of macro DMARK
b783						CALLMONITOR 
b783 cd 95 93			call break_point_state  
b786				endm  
# End of macro CALLMONITOR
b786					endif 
b786 3a 40 eb				ld a, (f_cursor_ptr) 
b789			 
b789			if DEBUG_FORTH_WORDS 
b789				DMARK "AT?" 
b789 f5				push af  
b78a 3a 9e b7			ld a, (.dmark)  
b78d 32 71 ee			ld (debug_mark),a  
b790 3a 9f b7			ld a, (.dmark+1)  
b793 32 72 ee			ld (debug_mark+1),a  
b796 3a a0 b7			ld a, (.dmark+2)  
b799 32 73 ee			ld (debug_mark+2),a  
b79c 18 03			jr .pastdmark  
b79e ..			.dmark: db "AT?"  
b7a1 f1			.pastdmark: pop af  
b7a2			endm  
# End of macro DMARK
b7a2				CALLMONITOR 
b7a2 cd 95 93			call break_point_state  
b7a5				endm  
# End of macro CALLMONITOR
b7a5			endif	 
b7a5					; count the number of rows 
b7a5			 
b7a5 06 00				ld b, 0 
b7a7 4f			.atpr:		ld c, a    ; save in case we go below zero 
b7a8 d6 28				sub display_cols 
b7aa f2 b0 b7				jp p, .atprunder 
b7ad 04					inc b 
b7ae 18 f7				jr .atpr 
b7b0			.atprunder:	 
b7b0			if DEBUG_FORTH_WORDS 
b7b0				DMARK "A?2" 
b7b0 f5				push af  
b7b1 3a c5 b7			ld a, (.dmark)  
b7b4 32 71 ee			ld (debug_mark),a  
b7b7 3a c6 b7			ld a, (.dmark+1)  
b7ba 32 72 ee			ld (debug_mark+1),a  
b7bd 3a c7 b7			ld a, (.dmark+2)  
b7c0 32 73 ee			ld (debug_mark+2),a  
b7c3 18 03			jr .pastdmark  
b7c5 ..			.dmark: db "A?2"  
b7c8 f1			.pastdmark: pop af  
b7c9			endm  
# End of macro DMARK
b7c9				CALLMONITOR 
b7c9 cd 95 93			call break_point_state  
b7cc				endm  
# End of macro CALLMONITOR
b7cc			endif	 
b7cc 26 00				ld h, 0 
b7ce 69					ld l, c 
b7cf cd 00 9a				call forth_push_numhl 
b7d2 68					ld l, b  
b7d3 cd 00 9a				call forth_push_numhl 
b7d6			 
b7d6			 
b7d6				NEXTW 
b7d6 c3 69 9d			jp macro_next 
b7d9				endm 
# End of macro NEXTW
b7d9			 
b7d9			.FB: 
b7d9				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b7d9 1b				db WORD_SYS_CORE+7             
b7da 27 b8			dw .EMIT            
b7dc 03				db 2 + 1 
b7dd .. 00			db "FB",0              
b7e0				endm 
# End of macro CWHEAD
b7e0			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b7e0			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b7e0			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b7e0			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b7e0					if DEBUG_FORTH_WORDS_KEY 
b7e0						DMARK "FB." 
b7e0 f5				push af  
b7e1 3a f5 b7			ld a, (.dmark)  
b7e4 32 71 ee			ld (debug_mark),a  
b7e7 3a f6 b7			ld a, (.dmark+1)  
b7ea 32 72 ee			ld (debug_mark+1),a  
b7ed 3a f7 b7			ld a, (.dmark+2)  
b7f0 32 73 ee			ld (debug_mark+2),a  
b7f3 18 03			jr .pastdmark  
b7f5 ..			.dmark: db "FB."  
b7f8 f1			.pastdmark: pop af  
b7f9			endm  
# End of macro DMARK
b7f9						CALLMONITOR 
b7f9 cd 95 93			call break_point_state  
b7fc				endm  
# End of macro CALLMONITOR
b7fc					endif 
b7fc			 
b7fc					FORTH_DSP_VALUEHL 
b7fc cd f7 9b			call macro_dsp_valuehl 
b7ff				endm 
# End of macro FORTH_DSP_VALUEHL
b7ff			 
b7ff 7d					ld a, l 
b800 fe 01				cp 1 
b802 20 05				jr nz, .fbn1 
b804 21 16 ed				ld hl, display_fb1 
b807 18 15				jr .fbset 
b809 fe 02		.fbn1:		cp 2 
b80b 20 05				jr nz, .fbn2 
b80d 21 d4 eb				ld hl, display_fb2 
b810 18 0c				jr .fbset 
b812 fe 03		.fbn2:		cp 3 
b814 20 05				jr nz, .fbn3 
b816 21 75 ec				ld hl, display_fb3 
b819 18 03				jr .fbset 
b81b			.fbn3:		 ; if invalid number select first 
b81b 21 16 ed				ld hl, display_fb1 
b81e 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b821			 
b821					FORTH_DSP_POP 
b821 cd af 9c			call macro_forth_dsp_pop 
b824				endm 
# End of macro FORTH_DSP_POP
b824			 
b824					NEXTW 
b824 c3 69 9d			jp macro_next 
b827				endm 
# End of macro NEXTW
b827			 
b827			 
b827			.EMIT: 
b827				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b827 1b				db WORD_SYS_CORE+7             
b828 78 b8			dw .DOTH            
b82a 05				db 4 + 1 
b82b .. 00			db "EMIT",0              
b830				endm 
# End of macro CWHEAD
b830			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b830					; get value off TOS and display it 
b830			 
b830					if DEBUG_FORTH_WORDS_KEY 
b830						DMARK "EMT" 
b830 f5				push af  
b831 3a 45 b8			ld a, (.dmark)  
b834 32 71 ee			ld (debug_mark),a  
b837 3a 46 b8			ld a, (.dmark+1)  
b83a 32 72 ee			ld (debug_mark+1),a  
b83d 3a 47 b8			ld a, (.dmark+2)  
b840 32 73 ee			ld (debug_mark+2),a  
b843 18 03			jr .pastdmark  
b845 ..			.dmark: db "EMT"  
b848 f1			.pastdmark: pop af  
b849			endm  
# End of macro DMARK
b849						CALLMONITOR 
b849 cd 95 93			call break_point_state  
b84c				endm  
# End of macro CALLMONITOR
b84c					endif 
b84c			 
b84c					FORTH_DSP_VALUEHL 
b84c cd f7 9b			call macro_dsp_valuehl 
b84f				endm 
# End of macro FORTH_DSP_VALUEHL
b84f			 
b84f 7d					ld a,l 
b850			 
b850					; TODO write to display 
b850			 
b850 32 d5 e5				ld (os_input), a 
b853 3e 00				ld a, 0 
b855 32 d6 e5				ld (os_input+1), a 
b858					 
b858 3a 40 eb				ld a, (f_cursor_ptr) 
b85b 11 d5 e5				ld de, os_input 
b85e cd 7a 89				call str_at_display 
b861			 
b861			 
b861 3a 1e eb				ld a,(cli_autodisplay) 
b864 fe 00				cp 0 
b866 28 03				jr z, .enoupdate 
b868 cd 8a 89						call update_display 
b86b					.enoupdate: 
b86b			 
b86b 3a 40 eb				ld a, (f_cursor_ptr) 
b86e 3c					inc a 
b86f 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
b872			 
b872			 
b872					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b872 cd af 9c			call macro_forth_dsp_pop 
b875				endm 
# End of macro FORTH_DSP_POP
b875			  
b875			 
b875					NEXTW 
b875 c3 69 9d			jp macro_next 
b878				endm 
# End of macro NEXTW
b878			.DOTH: 
b878				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b878 1c				db WORD_SYS_CORE+8             
b879 a8 b8			dw .DOTF            
b87b 03				db 2 + 1 
b87c .. 00			db ".-",0              
b87f				endm 
# End of macro CWHEAD
b87f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b87f					; get value off TOS and display it 
b87f					if DEBUG_FORTH_WORDS_KEY 
b87f						DMARK "DTD" 
b87f f5				push af  
b880 3a 94 b8			ld a, (.dmark)  
b883 32 71 ee			ld (debug_mark),a  
b886 3a 95 b8			ld a, (.dmark+1)  
b889 32 72 ee			ld (debug_mark+1),a  
b88c 3a 96 b8			ld a, (.dmark+2)  
b88f 32 73 ee			ld (debug_mark+2),a  
b892 18 03			jr .pastdmark  
b894 ..			.dmark: db "DTD"  
b897 f1			.pastdmark: pop af  
b898			endm  
# End of macro DMARK
b898						CALLMONITOR 
b898 cd 95 93			call break_point_state  
b89b				endm  
# End of macro CALLMONITOR
b89b					endif 
b89b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b89d 3e 00			ld a, 0 
b89f 32 1f eb			ld (cli_mvdot), a 
b8a2 c3 ff b8			jp .dotgo 
b8a5				NEXTW 
b8a5 c3 69 9d			jp macro_next 
b8a8				endm 
# End of macro NEXTW
b8a8			.DOTF: 
b8a8				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b8a8 1c				db WORD_SYS_CORE+8             
b8a9 d6 b8			dw .DOT            
b8ab 03				db 2 + 1 
b8ac .. 00			db ".>",0              
b8af				endm 
# End of macro CWHEAD
b8af			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b8af					; get value off TOS and display it 
b8af			        ; TODO BUG adds extra spaces 
b8af			        ; TODO BUG handle numerics? 
b8af					if DEBUG_FORTH_WORDS_KEY 
b8af						DMARK "DTC" 
b8af f5				push af  
b8b0 3a c4 b8			ld a, (.dmark)  
b8b3 32 71 ee			ld (debug_mark),a  
b8b6 3a c5 b8			ld a, (.dmark+1)  
b8b9 32 72 ee			ld (debug_mark+1),a  
b8bc 3a c6 b8			ld a, (.dmark+2)  
b8bf 32 73 ee			ld (debug_mark+2),a  
b8c2 18 03			jr .pastdmark  
b8c4 ..			.dmark: db "DTC"  
b8c7 f1			.pastdmark: pop af  
b8c8			endm  
# End of macro DMARK
b8c8						CALLMONITOR 
b8c8 cd 95 93			call break_point_state  
b8cb				endm  
# End of macro CALLMONITOR
b8cb					endif 
b8cb 3e 01			ld a, 1 
b8cd 32 1f eb			ld (cli_mvdot), a 
b8d0 c3 ff b8			jp .dotgo 
b8d3				NEXTW 
b8d3 c3 69 9d			jp macro_next 
b8d6				endm 
# End of macro NEXTW
b8d6			 
b8d6			.DOT: 
b8d6				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b8d6 1c				db WORD_SYS_CORE+8             
b8d7 62 b9			dw .CLS            
b8d9 02				db 1 + 1 
b8da .. 00			db ".",0              
b8dc				endm 
# End of macro CWHEAD
b8dc			        ; | . ( u -- ) Display TOS | DONE 
b8dc					; get value off TOS and display it 
b8dc			 
b8dc					if DEBUG_FORTH_WORDS_KEY 
b8dc						DMARK "DOT" 
b8dc f5				push af  
b8dd 3a f1 b8			ld a, (.dmark)  
b8e0 32 71 ee			ld (debug_mark),a  
b8e3 3a f2 b8			ld a, (.dmark+1)  
b8e6 32 72 ee			ld (debug_mark+1),a  
b8e9 3a f3 b8			ld a, (.dmark+2)  
b8ec 32 73 ee			ld (debug_mark+2),a  
b8ef 18 03			jr .pastdmark  
b8f1 ..			.dmark: db "DOT"  
b8f4 f1			.pastdmark: pop af  
b8f5			endm  
# End of macro DMARK
b8f5						CALLMONITOR 
b8f5 cd 95 93			call break_point_state  
b8f8				endm  
# End of macro CALLMONITOR
b8f8					endif 
b8f8 3e 00			ld a, 0 
b8fa 32 1f eb			ld (cli_mvdot), a 
b8fd 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b8ff				 
b8ff			 
b8ff			.dotgo: 
b8ff			 
b8ff			; move up type to on stack for parserv5 
b8ff					FORTH_DSP 
b8ff cd bd 9b			call macro_forth_dsp 
b902				endm 
# End of macro FORTH_DSP
b902				;FORTH_DSP_VALUE  
b902			 
b902			if DEBUG_FORTH_DOT 
b902				DMARK "DOT" 
b902				CALLMONITOR 
b902			endif	 
b902			;		.print: 
b902			 
b902 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b903 23				inc hl   ; position to the actual value 
b904 fe 01			cp DS_TYPE_STR 
b906 20 06			jr nz, .dotnum1  
b908			 
b908			; display string 
b908				FORTH_DSP_VALUE  
b908 cd e0 9b			call macro_forth_dsp_value 
b90b				endm 
# End of macro FORTH_DSP_VALUE
b90b eb				ex de,hl 
b90c 18 11			jr .dotwrite 
b90e			 
b90e			.dotnum1: 
b90e fe 02			cp DS_TYPE_INUM 
b910 20 0c			jr nz, .dotflot 
b912			 
b912			 
b912			; display number 
b912			 
b912			;	push hl 
b912			;	call clear_display 
b912			;	pop hl 
b912			 
b912 5e				ld e, (hl) 
b913 23				inc hl 
b914 56				ld d, (hl) 
b915 21 d7 e3			ld hl, scratch 
b918			if DEBUG_FORTH_DOT 
b918				DMARK "DT1" 
b918				CALLMONITOR 
b918			endif	 
b918			 
b918 cd a1 8f			call uitoa_16 
b91b eb				ex de,hl 
b91c			 
b91c			if DEBUG_FORTH_DOT 
b91c				DMARK "DT2" 
b91c				CALLMONITOR 
b91c			endif	 
b91c			 
b91c			;	ld de, os_word_scratch 
b91c 18 01			jr .dotwrite 
b91e			 
b91e 00			.dotflot:   nop 
b91f			; TODO print floating point number 
b91f			 
b91f			.dotwrite:		 
b91f			 
b91f					; if c is set then set all '-' to spaces 
b91f					; need to also take into account .>  
b91f			 
b91f 3e 01				ld a, 1 
b921 b9					cp c 
b922 20 13				jr nz, .nodashswap 
b924			 
b924					; DE has the string to write, working with HL 
b924			 
b924 06 ff				ld b, 255 
b926 d5					push de 
b927 e1					pop hl 
b928			 
b928			if DEBUG_FORTH_DOT 
b928				DMARK "DT-" 
b928				CALLMONITOR 
b928			endif	 
b928 7e			.dashscan:	ld a, (hl) 
b929 fe 00				cp 0 
b92b 28 0a				jr z, .nodashswap 
b92d fe 2d				cp '-' 
b92f 20 03				jr nz, .dashskip 
b931 3e 20				ld a, ' ' 
b933 77					ld (hl), a 
b934 23			.dashskip:	inc hl 
b935			if DEBUG_FORTH_DOT 
b935				DMARK "D-2" 
b935				CALLMONITOR 
b935			endif	 
b935 10 f1				djnz .dashscan 
b937			 
b937			if DEBUG_FORTH_DOT 
b937				DMARK "D-1" 
b937				CALLMONITOR 
b937			endif	 
b937			 
b937			.nodashswap: 
b937			 
b937 e5					push hl   ; save string start in case we need to advance print 
b938			 
b938 3a 40 eb				ld a, (f_cursor_ptr) 
b93b cd 7a 89				call str_at_display 
b93e 3a 1e eb				ld a,(cli_autodisplay) 
b941 fe 00				cp 0 
b943 28 03				jr z, .noupdate 
b945 cd 8a 89						call update_display 
b948					.noupdate: 
b948			 
b948			 
b948					; see if we need to advance the print position 
b948			 
b948 e1					pop hl   ; get back string 
b949			 
b949 3a 1f eb				ld a, (cli_mvdot) 
b94c			if DEBUG_FORTH_DOT 
b94c					ld e,a 
b94c				DMARK "D>1" 
b94c				CALLMONITOR 
b94c			endif	 
b94c fe 00				cp 0 
b94e 28 0c				jr z, .noadv 
b950					; yes, lets advance the print position 
b950 3e 00				ld a, 0 
b952 cd fd 8f				call strlent 
b955 3a 40 eb				ld a, (f_cursor_ptr) 
b958 85					add a,l 
b959					;call addatohl 
b959					;ld a, l 
b959 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
b95c			 
b95c			if DEBUG_FORTH_DOT 
b95c				DMARK "D->" 
b95c				CALLMONITOR 
b95c			endif	 
b95c			 
b95c			.noadv:	 
b95c			 
b95c					if DEBUG_FORTH_DOT_WAIT 
b95c							call next_page_prompt 
b95c					endif	 
b95c			; TODO this pop off the stack causes a crash. i dont know why 
b95c			 
b95c			 
b95c			if DEBUG_FORTH_DOT 
b95c				DMARK "DTh" 
b95c				CALLMONITOR 
b95c			endif	 
b95c			 
b95c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b95c cd af 9c			call macro_forth_dsp_pop 
b95f				endm 
# End of macro FORTH_DSP_POP
b95f			 
b95f			if DEBUG_FORTH_DOT 
b95f				DMARK "DTi" 
b95f				CALLMONITOR 
b95f			endif	 
b95f			 
b95f			 
b95f					NEXTW 
b95f c3 69 9d			jp macro_next 
b962				endm 
# End of macro NEXTW
b962			 
b962			.CLS: 
b962				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b962 35				db WORD_SYS_CORE+33             
b963 8f b9			dw .DRAW            
b965 04				db 3 + 1 
b966 .. 00			db "CLS",0              
b96a				endm 
# End of macro CWHEAD
b96a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b96a					if DEBUG_FORTH_WORDS_KEY 
b96a						DMARK "CLS" 
b96a f5				push af  
b96b 3a 7f b9			ld a, (.dmark)  
b96e 32 71 ee			ld (debug_mark),a  
b971 3a 80 b9			ld a, (.dmark+1)  
b974 32 72 ee			ld (debug_mark+1),a  
b977 3a 81 b9			ld a, (.dmark+2)  
b97a 32 73 ee			ld (debug_mark+2),a  
b97d 18 03			jr .pastdmark  
b97f ..			.dmark: db "CLS"  
b982 f1			.pastdmark: pop af  
b983			endm  
# End of macro DMARK
b983						CALLMONITOR 
b983 cd 95 93			call break_point_state  
b986				endm  
# End of macro CALLMONITOR
b986					endif 
b986 cd 67 89				call clear_display 
b989 c3 9d ba				jp .home		; and home cursor 
b98c					NEXTW 
b98c c3 69 9d			jp macro_next 
b98f				endm 
# End of macro NEXTW
b98f			 
b98f			.DRAW: 
b98f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b98f 36				db WORD_SYS_CORE+34             
b990 ba b9			dw .DUMP            
b992 05				db 4 + 1 
b993 .. 00			db "DRAW",0              
b998				endm 
# End of macro CWHEAD
b998			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b998					if DEBUG_FORTH_WORDS_KEY 
b998						DMARK "DRW" 
b998 f5				push af  
b999 3a ad b9			ld a, (.dmark)  
b99c 32 71 ee			ld (debug_mark),a  
b99f 3a ae b9			ld a, (.dmark+1)  
b9a2 32 72 ee			ld (debug_mark+1),a  
b9a5 3a af b9			ld a, (.dmark+2)  
b9a8 32 73 ee			ld (debug_mark+2),a  
b9ab 18 03			jr .pastdmark  
b9ad ..			.dmark: db "DRW"  
b9b0 f1			.pastdmark: pop af  
b9b1			endm  
# End of macro DMARK
b9b1						CALLMONITOR 
b9b1 cd 95 93			call break_point_state  
b9b4				endm  
# End of macro CALLMONITOR
b9b4					endif 
b9b4 cd 8a 89				call update_display 
b9b7					NEXTW 
b9b7 c3 69 9d			jp macro_next 
b9ba				endm 
# End of macro NEXTW
b9ba			 
b9ba			.DUMP: 
b9ba				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b9ba 37				db WORD_SYS_CORE+35             
b9bb f2 b9			dw .CDUMP            
b9bd 05				db 4 + 1 
b9be .. 00			db "DUMP",0              
b9c3				endm 
# End of macro CWHEAD
b9c3			; | DUMP ( x -- ) With address x display dump   | DONE 
b9c3			; TODO pop address to use off of the stack 
b9c3					if DEBUG_FORTH_WORDS_KEY 
b9c3						DMARK "DUM" 
b9c3 f5				push af  
b9c4 3a d8 b9			ld a, (.dmark)  
b9c7 32 71 ee			ld (debug_mark),a  
b9ca 3a d9 b9			ld a, (.dmark+1)  
b9cd 32 72 ee			ld (debug_mark+1),a  
b9d0 3a da b9			ld a, (.dmark+2)  
b9d3 32 73 ee			ld (debug_mark+2),a  
b9d6 18 03			jr .pastdmark  
b9d8 ..			.dmark: db "DUM"  
b9db f1			.pastdmark: pop af  
b9dc			endm  
# End of macro DMARK
b9dc						CALLMONITOR 
b9dc cd 95 93			call break_point_state  
b9df				endm  
# End of macro CALLMONITOR
b9df					endif 
b9df cd 67 89				call clear_display 
b9e2			 
b9e2					; get address 
b9e2			 
b9e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9e2 cd f7 9b			call macro_dsp_valuehl 
b9e5				endm 
# End of macro FORTH_DSP_VALUEHL
b9e5				 
b9e5					; save it for cdump 
b9e5			 
b9e5 22 fa e6				ld (os_cur_ptr),hl 
b9e8			 
b9e8					; destroy value TOS 
b9e8			 
b9e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9e8 cd af 9c			call macro_forth_dsp_pop 
b9eb				endm 
# End of macro FORTH_DSP_POP
b9eb			 
b9eb cd 80 98				call dumpcont	; skip old style of param parsing	 
b9ee c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b9ef					NEXTW 
b9ef c3 69 9d			jp macro_next 
b9f2				endm 
# End of macro NEXTW
b9f2			.CDUMP: 
b9f2				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b9f2 38				db WORD_SYS_CORE+36             
b9f3 22 ba			dw .DAT            
b9f5 06				db 5 + 1 
b9f6 .. 00			db "CDUMP",0              
b9fc				endm 
# End of macro CWHEAD
b9fc			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b9fc					if DEBUG_FORTH_WORDS_KEY 
b9fc						DMARK "CDP" 
b9fc f5				push af  
b9fd 3a 11 ba			ld a, (.dmark)  
ba00 32 71 ee			ld (debug_mark),a  
ba03 3a 12 ba			ld a, (.dmark+1)  
ba06 32 72 ee			ld (debug_mark+1),a  
ba09 3a 13 ba			ld a, (.dmark+2)  
ba0c 32 73 ee			ld (debug_mark+2),a  
ba0f 18 03			jr .pastdmark  
ba11 ..			.dmark: db "CDP"  
ba14 f1			.pastdmark: pop af  
ba15			endm  
# End of macro DMARK
ba15						CALLMONITOR 
ba15 cd 95 93			call break_point_state  
ba18				endm  
# End of macro CALLMONITOR
ba18					endif 
ba18 cd 67 89				call clear_display 
ba1b cd 80 98				call dumpcont	 
ba1e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
ba1f					NEXTW 
ba1f c3 69 9d			jp macro_next 
ba22				endm 
# End of macro NEXTW
ba22			 
ba22			 
ba22			 
ba22			 
ba22			.DAT: 
ba22				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
ba22 3d				db WORD_SYS_CORE+41             
ba23 78 ba			dw .HOME            
ba25 03				db 2 + 1 
ba26 .. 00			db "AT",0              
ba29				endm 
# End of macro CWHEAD
ba29			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
ba29					if DEBUG_FORTH_WORDS_KEY 
ba29						DMARK "AT." 
ba29 f5				push af  
ba2a 3a 3e ba			ld a, (.dmark)  
ba2d 32 71 ee			ld (debug_mark),a  
ba30 3a 3f ba			ld a, (.dmark+1)  
ba33 32 72 ee			ld (debug_mark+1),a  
ba36 3a 40 ba			ld a, (.dmark+2)  
ba39 32 73 ee			ld (debug_mark+2),a  
ba3c 18 03			jr .pastdmark  
ba3e ..			.dmark: db "AT."  
ba41 f1			.pastdmark: pop af  
ba42			endm  
# End of macro DMARK
ba42						CALLMONITOR 
ba42 cd 95 93			call break_point_state  
ba45				endm  
# End of macro CALLMONITOR
ba45					endif 
ba45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba45 cd f7 9b			call macro_dsp_valuehl 
ba48				endm 
# End of macro FORTH_DSP_VALUEHL
ba48			 
ba48			 
ba48					; TODO save cursor row 
ba48 7d					ld a,l 
ba49 fe 02				cp 2 
ba4b 20 04				jr nz, .crow3 
ba4d 3e 28				ld a, display_row_2 
ba4f 18 12				jr .ccol1 
ba51 fe 03		.crow3:		cp 3 
ba53 20 04				jr nz, .crow4 
ba55 3e 50				ld a, display_row_3 
ba57 18 0a				jr .ccol1 
ba59 fe 04		.crow4:		cp 4 
ba5b 20 04				jr nz, .crow1 
ba5d 3e 78				ld a, display_row_4 
ba5f 18 02				jr .ccol1 
ba61 3e 00		.crow1:		ld a,display_row_1 
ba63 f5			.ccol1:		push af			; got row offset 
ba64 6f					ld l,a 
ba65 26 00				ld h,0 
ba67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba67 cd af 9c			call macro_forth_dsp_pop 
ba6a				endm 
# End of macro FORTH_DSP_POP
ba6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba6a cd f7 9b			call macro_dsp_valuehl 
ba6d				endm 
# End of macro FORTH_DSP_VALUEHL
ba6d					; TODO save cursor col 
ba6d f1					pop af 
ba6e 85					add l		; add col offset 
ba6f 32 40 eb				ld (f_cursor_ptr), a 
ba72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba72 cd af 9c			call macro_forth_dsp_pop 
ba75				endm 
# End of macro FORTH_DSP_POP
ba75			 
ba75					; calculate  
ba75			 
ba75					NEXTW 
ba75 c3 69 9d			jp macro_next 
ba78				endm 
# End of macro NEXTW
ba78			 
ba78			 
ba78			.HOME: 
ba78				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
ba78 41				db WORD_SYS_CORE+45             
ba79 a5 ba			dw .SPACE            
ba7b 05				db 4 + 1 
ba7c .. 00			db "HOME",0              
ba81				endm 
# End of macro CWHEAD
ba81			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
ba81					if DEBUG_FORTH_WORDS_KEY 
ba81						DMARK "HOM" 
ba81 f5				push af  
ba82 3a 96 ba			ld a, (.dmark)  
ba85 32 71 ee			ld (debug_mark),a  
ba88 3a 97 ba			ld a, (.dmark+1)  
ba8b 32 72 ee			ld (debug_mark+1),a  
ba8e 3a 98 ba			ld a, (.dmark+2)  
ba91 32 73 ee			ld (debug_mark+2),a  
ba94 18 03			jr .pastdmark  
ba96 ..			.dmark: db "HOM"  
ba99 f1			.pastdmark: pop af  
ba9a			endm  
# End of macro DMARK
ba9a						CALLMONITOR 
ba9a cd 95 93			call break_point_state  
ba9d				endm  
# End of macro CALLMONITOR
ba9d					endif 
ba9d 3e 00		.home:		ld a, 0		; and home cursor 
ba9f 32 40 eb				ld (f_cursor_ptr), a 
baa2					NEXTW 
baa2 c3 69 9d			jp macro_next 
baa5				endm 
# End of macro NEXTW
baa5			 
baa5			 
baa5			.SPACE: 
baa5				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
baa5 46				db WORD_SYS_CORE+50             
baa6 d3 ba			dw .SPACES            
baa8 03				db 2 + 1 
baa9 .. 00			db "BL",0              
baac				endm 
# End of macro CWHEAD
baac			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
baac					if DEBUG_FORTH_WORDS_KEY 
baac						DMARK "BL." 
baac f5				push af  
baad 3a c1 ba			ld a, (.dmark)  
bab0 32 71 ee			ld (debug_mark),a  
bab3 3a c2 ba			ld a, (.dmark+1)  
bab6 32 72 ee			ld (debug_mark+1),a  
bab9 3a c3 ba			ld a, (.dmark+2)  
babc 32 73 ee			ld (debug_mark+2),a  
babf 18 03			jr .pastdmark  
bac1 ..			.dmark: db "BL."  
bac4 f1			.pastdmark: pop af  
bac5			endm  
# End of macro DMARK
bac5						CALLMONITOR 
bac5 cd 95 93			call break_point_state  
bac8				endm  
# End of macro CALLMONITOR
bac8					endif 
bac8 21 d1 ba				ld hl, .blstr 
bacb cd 6e 9a				call forth_push_str 
bace					 
bace				       NEXTW 
bace c3 69 9d			jp macro_next 
bad1				endm 
# End of macro NEXTW
bad1			 
bad1 .. 00		.blstr: db " ", 0 
bad3			 
bad3			.SPACES: 
bad3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bad3 47				db WORD_SYS_CORE+51             
bad4 6e bb			dw .SCROLL            
bad6 07				db 6 + 1 
bad7 .. 00			db "SPACES",0              
bade				endm 
# End of macro CWHEAD
bade			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bade					if DEBUG_FORTH_WORDS_KEY 
bade						DMARK "SPS" 
bade f5				push af  
badf 3a f3 ba			ld a, (.dmark)  
bae2 32 71 ee			ld (debug_mark),a  
bae5 3a f4 ba			ld a, (.dmark+1)  
bae8 32 72 ee			ld (debug_mark+1),a  
baeb 3a f5 ba			ld a, (.dmark+2)  
baee 32 73 ee			ld (debug_mark+2),a  
baf1 18 03			jr .pastdmark  
baf3 ..			.dmark: db "SPS"  
baf6 f1			.pastdmark: pop af  
baf7			endm  
# End of macro DMARK
baf7						CALLMONITOR 
baf7 cd 95 93			call break_point_state  
bafa				endm  
# End of macro CALLMONITOR
bafa					endif 
bafa			 
bafa			 
bafa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bafa cd f7 9b			call macro_dsp_valuehl 
bafd				endm 
# End of macro FORTH_DSP_VALUEHL
bafd			 
bafd			;		push hl    ; u 
bafd					if DEBUG_FORTH_WORDS 
bafd						DMARK "SPA" 
bafd f5				push af  
bafe 3a 12 bb			ld a, (.dmark)  
bb01 32 71 ee			ld (debug_mark),a  
bb04 3a 13 bb			ld a, (.dmark+1)  
bb07 32 72 ee			ld (debug_mark+1),a  
bb0a 3a 14 bb			ld a, (.dmark+2)  
bb0d 32 73 ee			ld (debug_mark+2),a  
bb10 18 03			jr .pastdmark  
bb12 ..			.dmark: db "SPA"  
bb15 f1			.pastdmark: pop af  
bb16			endm  
# End of macro DMARK
bb16						CALLMONITOR 
bb16 cd 95 93			call break_point_state  
bb19				endm  
# End of macro CALLMONITOR
bb19					endif 
bb19			 
bb19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb19 cd af 9c			call macro_forth_dsp_pop 
bb1c				endm 
# End of macro FORTH_DSP_POP
bb1c			;		pop hl 
bb1c 4d					ld c, l 
bb1d 06 00				ld b, 0 
bb1f 21 d7 e3				ld hl, scratch  
bb22			 
bb22					if DEBUG_FORTH_WORDS 
bb22						DMARK "SP2" 
bb22 f5				push af  
bb23 3a 37 bb			ld a, (.dmark)  
bb26 32 71 ee			ld (debug_mark),a  
bb29 3a 38 bb			ld a, (.dmark+1)  
bb2c 32 72 ee			ld (debug_mark+1),a  
bb2f 3a 39 bb			ld a, (.dmark+2)  
bb32 32 73 ee			ld (debug_mark+2),a  
bb35 18 03			jr .pastdmark  
bb37 ..			.dmark: db "SP2"  
bb3a f1			.pastdmark: pop af  
bb3b			endm  
# End of macro DMARK
bb3b						CALLMONITOR 
bb3b cd 95 93			call break_point_state  
bb3e				endm  
# End of macro CALLMONITOR
bb3e					endif 
bb3e 3e 20				ld a, ' ' 
bb40 c5			.spaces1:	push bc 
bb41 77					ld (hl),a 
bb42 23					inc hl 
bb43 c1					pop bc 
bb44 10 fa				djnz .spaces1 
bb46 3e 00				ld a,0 
bb48 77					ld (hl),a 
bb49 21 d7 e3				ld hl, scratch 
bb4c					if DEBUG_FORTH_WORDS 
bb4c						DMARK "SP3" 
bb4c f5				push af  
bb4d 3a 61 bb			ld a, (.dmark)  
bb50 32 71 ee			ld (debug_mark),a  
bb53 3a 62 bb			ld a, (.dmark+1)  
bb56 32 72 ee			ld (debug_mark+1),a  
bb59 3a 63 bb			ld a, (.dmark+2)  
bb5c 32 73 ee			ld (debug_mark+2),a  
bb5f 18 03			jr .pastdmark  
bb61 ..			.dmark: db "SP3"  
bb64 f1			.pastdmark: pop af  
bb65			endm  
# End of macro DMARK
bb65						CALLMONITOR 
bb65 cd 95 93			call break_point_state  
bb68				endm  
# End of macro CALLMONITOR
bb68					endif 
bb68 cd 69 9b				call forth_apush 
bb6b			 
bb6b				       NEXTW 
bb6b c3 69 9d			jp macro_next 
bb6e				endm 
# End of macro NEXTW
bb6e			 
bb6e			 
bb6e			 
bb6e			.SCROLL: 
bb6e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bb6e 53				db WORD_SYS_CORE+63             
bb6f 9b bb			dw .SCROLLD            
bb71 07				db 6 + 1 
bb72 .. 00			db "SCROLL",0              
bb79				endm 
# End of macro CWHEAD
bb79			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bb79					if DEBUG_FORTH_WORDS_KEY 
bb79						DMARK "SCR" 
bb79 f5				push af  
bb7a 3a 8e bb			ld a, (.dmark)  
bb7d 32 71 ee			ld (debug_mark),a  
bb80 3a 8f bb			ld a, (.dmark+1)  
bb83 32 72 ee			ld (debug_mark+1),a  
bb86 3a 90 bb			ld a, (.dmark+2)  
bb89 32 73 ee			ld (debug_mark+2),a  
bb8c 18 03			jr .pastdmark  
bb8e ..			.dmark: db "SCR"  
bb91 f1			.pastdmark: pop af  
bb92			endm  
# End of macro DMARK
bb92						CALLMONITOR 
bb92 cd 95 93			call break_point_state  
bb95				endm  
# End of macro CALLMONITOR
bb95					endif 
bb95			 
bb95 cd 29 89			call scroll_up 
bb98			;	call update_display 
bb98			 
bb98					NEXTW 
bb98 c3 69 9d			jp macro_next 
bb9b				endm 
# End of macro NEXTW
bb9b			 
bb9b			 
bb9b			 
bb9b			;		; get dir 
bb9b			; 
bb9b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb9b			; 
bb9b			;		push hl 
bb9b			; 
bb9b			;		; destroy value TOS 
bb9b			; 
bb9b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb9b			; 
bb9b			;		; get count 
bb9b			; 
bb9b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb9b			; 
bb9b			;		push hl 
bb9b			; 
bb9b			;		; destroy value TOS 
bb9b			; 
bb9b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb9b			; 
bb9b			;		; one value on hl get other one back 
bb9b			; 
bb9b			;		pop bc    ; count 
bb9b			; 
bb9b			;		pop de   ; dir 
bb9b			; 
bb9b			; 
bb9b			;		ld b, c 
bb9b			; 
bb9b			;.scrolldir:     push bc 
bb9b			;		push de 
bb9b			; 
bb9b			;		ld a, 0 
bb9b			;		cp e 
bb9b			;		jr z, .scrollup  
bb9b			;		call scroll_down 
bb9b			;		jr .scrollnext 
bb9b			;.scrollup:	call scroll_up 
bb9b			; 
bb9b			;		 
bb9b			;.scrollnext: 
bb9b			;		pop de 
bb9b			;		pop bc 
bb9b			;		djnz .scrolldir 
bb9b			; 
bb9b			; 
bb9b			; 
bb9b			; 
bb9b			; 
bb9b			;		NEXTW 
bb9b			 
bb9b			.SCROLLD: 
bb9b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bb9b 53				db WORD_SYS_CORE+63             
bb9c c9 bb			dw .ATQ            
bb9e 08				db 7 + 1 
bb9f .. 00			db "SCROLLD",0              
bba7				endm 
# End of macro CWHEAD
bba7			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bba7					if DEBUG_FORTH_WORDS_KEY 
bba7						DMARK "SCD" 
bba7 f5				push af  
bba8 3a bc bb			ld a, (.dmark)  
bbab 32 71 ee			ld (debug_mark),a  
bbae 3a bd bb			ld a, (.dmark+1)  
bbb1 32 72 ee			ld (debug_mark+1),a  
bbb4 3a be bb			ld a, (.dmark+2)  
bbb7 32 73 ee			ld (debug_mark+2),a  
bbba 18 03			jr .pastdmark  
bbbc ..			.dmark: db "SCD"  
bbbf f1			.pastdmark: pop af  
bbc0			endm  
# End of macro DMARK
bbc0						CALLMONITOR 
bbc0 cd 95 93			call break_point_state  
bbc3				endm  
# End of macro CALLMONITOR
bbc3					endif 
bbc3			 
bbc3 cd 4d 89			call scroll_down 
bbc6			;	call update_display 
bbc6			 
bbc6					NEXTW 
bbc6 c3 69 9d			jp macro_next 
bbc9				endm 
# End of macro NEXTW
bbc9			 
bbc9			 
bbc9			.ATQ: 
bbc9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bbc9 62				db WORD_SYS_CORE+78             
bbca 27 bc			dw .AUTODSP            
bbcc 04				db 3 + 1 
bbcd .. 00			db "AT@",0              
bbd1				endm 
# End of macro CWHEAD
bbd1			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bbd1					if DEBUG_FORTH_WORDS_KEY 
bbd1						DMARK "ATA" 
bbd1 f5				push af  
bbd2 3a e6 bb			ld a, (.dmark)  
bbd5 32 71 ee			ld (debug_mark),a  
bbd8 3a e7 bb			ld a, (.dmark+1)  
bbdb 32 72 ee			ld (debug_mark+1),a  
bbde 3a e8 bb			ld a, (.dmark+2)  
bbe1 32 73 ee			ld (debug_mark+2),a  
bbe4 18 03			jr .pastdmark  
bbe6 ..			.dmark: db "ATA"  
bbe9 f1			.pastdmark: pop af  
bbea			endm  
# End of macro DMARK
bbea						CALLMONITOR 
bbea cd 95 93			call break_point_state  
bbed				endm  
# End of macro CALLMONITOR
bbed					endif 
bbed			 
bbed			 
bbed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbed cd f7 9b			call macro_dsp_valuehl 
bbf0				endm 
# End of macro FORTH_DSP_VALUEHL
bbf0			 
bbf0					; TODO save cursor row 
bbf0 7d					ld a,l 
bbf1 fe 02				cp 2 
bbf3 20 04				jr nz, .crow3aq 
bbf5 3e 28				ld a, display_row_2 
bbf7 18 12				jr .ccol1aq 
bbf9 fe 03		.crow3aq:		cp 3 
bbfb 20 04				jr nz, .crow4aq 
bbfd 3e 50				ld a, display_row_3 
bbff 18 0a				jr .ccol1aq 
bc01 fe 04		.crow4aq:		cp 4 
bc03 20 04				jr nz, .crow1aq 
bc05 3e 78				ld a, display_row_4 
bc07 18 02				jr .ccol1aq 
bc09 3e 00		.crow1aq:		ld a,display_row_1 
bc0b f5			.ccol1aq:		push af			; got row offset 
bc0c 6f					ld l,a 
bc0d 26 00				ld h,0 
bc0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc0f cd af 9c			call macro_forth_dsp_pop 
bc12				endm 
# End of macro FORTH_DSP_POP
bc12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc12 cd f7 9b			call macro_dsp_valuehl 
bc15				endm 
# End of macro FORTH_DSP_VALUEHL
bc15					; TODO save cursor col 
bc15 f1					pop af 
bc16 85					add l		; add col offset 
bc17			 
bc17					; add current frame buffer address 
bc17 2a d2 eb				ld hl, (display_fb_active) 
bc1a cd 94 8b				call addatohl 
bc1d			 
bc1d			 
bc1d			 
bc1d			 
bc1d					; get char frame buffer location offset in hl 
bc1d			 
bc1d 7e					ld a,(hl) 
bc1e 26 00				ld h, 0 
bc20 6f					ld l, a 
bc21			 
bc21 cd 00 9a				call forth_push_numhl 
bc24			 
bc24			 
bc24					NEXTW 
bc24 c3 69 9d			jp macro_next 
bc27				endm 
# End of macro NEXTW
bc27			 
bc27			.AUTODSP: 
bc27				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bc27 63				db WORD_SYS_CORE+79             
bc28 3d bc			dw .MENU            
bc2a 05				db 4 + 1 
bc2b .. 00			db "ADSP",0              
bc30				endm 
# End of macro CWHEAD
bc30			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bc30			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bc30			 
bc30					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc30 cd f7 9b			call macro_dsp_valuehl 
bc33				endm 
# End of macro FORTH_DSP_VALUEHL
bc33			 
bc33			;		push hl 
bc33			 
bc33					; destroy value TOS 
bc33			 
bc33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc33 cd af 9c			call macro_forth_dsp_pop 
bc36				endm 
# End of macro FORTH_DSP_POP
bc36			 
bc36			;		pop hl 
bc36			 
bc36 7d					ld a,l 
bc37 32 1e eb				ld (cli_autodisplay), a 
bc3a				       NEXTW 
bc3a c3 69 9d			jp macro_next 
bc3d				endm 
# End of macro NEXTW
bc3d			 
bc3d			.MENU: 
bc3d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bc3d 70				db WORD_SYS_CORE+92             
bc3e e6 bc			dw .ENDDISPLAY            
bc40 05				db 4 + 1 
bc41 .. 00			db "MENU",0              
bc46				endm 
# End of macro CWHEAD
bc46			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bc46			 
bc46			;		; get number of items on the stack 
bc46			; 
bc46				 
bc46					FORTH_DSP_VALUEHL 
bc46 cd f7 9b			call macro_dsp_valuehl 
bc49				endm 
# End of macro FORTH_DSP_VALUEHL
bc49				 
bc49					if DEBUG_FORTH_WORDS_KEY 
bc49						DMARK "MNU" 
bc49 f5				push af  
bc4a 3a 5e bc			ld a, (.dmark)  
bc4d 32 71 ee			ld (debug_mark),a  
bc50 3a 5f bc			ld a, (.dmark+1)  
bc53 32 72 ee			ld (debug_mark+1),a  
bc56 3a 60 bc			ld a, (.dmark+2)  
bc59 32 73 ee			ld (debug_mark+2),a  
bc5c 18 03			jr .pastdmark  
bc5e ..			.dmark: db "MNU"  
bc61 f1			.pastdmark: pop af  
bc62			endm  
# End of macro DMARK
bc62						CALLMONITOR 
bc62 cd 95 93			call break_point_state  
bc65				endm  
# End of macro CALLMONITOR
bc65					endif 
bc65			 
bc65 45					ld b, l	 
bc66 05					dec b 
bc67			 
bc67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc67 cd af 9c			call macro_forth_dsp_pop 
bc6a				endm 
# End of macro FORTH_DSP_POP
bc6a			 
bc6a			 
bc6a					; go directly through the stack to pluck out the string pointers and build an array 
bc6a			 
bc6a			;		FORTH_DSP 
bc6a			 
bc6a					; hl contains top most stack item 
bc6a				 
bc6a 11 d7 e3				ld de, scratch 
bc6d			 
bc6d			.mbuild: 
bc6d			 
bc6d					FORTH_DSP_VALUEHL 
bc6d cd f7 9b			call macro_dsp_valuehl 
bc70				endm 
# End of macro FORTH_DSP_VALUEHL
bc70			 
bc70					if DEBUG_FORTH_WORDS 
bc70						DMARK "MN3" 
bc70 f5				push af  
bc71 3a 85 bc			ld a, (.dmark)  
bc74 32 71 ee			ld (debug_mark),a  
bc77 3a 86 bc			ld a, (.dmark+1)  
bc7a 32 72 ee			ld (debug_mark+1),a  
bc7d 3a 87 bc			ld a, (.dmark+2)  
bc80 32 73 ee			ld (debug_mark+2),a  
bc83 18 03			jr .pastdmark  
bc85 ..			.dmark: db "MN3"  
bc88 f1			.pastdmark: pop af  
bc89			endm  
# End of macro DMARK
bc89						CALLMONITOR 
bc89 cd 95 93			call break_point_state  
bc8c				endm  
# End of macro CALLMONITOR
bc8c					endif 
bc8c eb					ex de, hl 
bc8d 73					ld (hl), e 
bc8e 23					inc hl 
bc8f 72					ld (hl), d 
bc90 23					inc hl 
bc91 eb					ex de, hl 
bc92			 
bc92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc92 cd af 9c			call macro_forth_dsp_pop 
bc95				endm 
# End of macro FORTH_DSP_POP
bc95			 
bc95 10 d6				djnz .mbuild 
bc97			 
bc97					; done add term 
bc97			 
bc97 eb					ex de, hl 
bc98 36 00				ld (hl), 0 
bc9a 23					inc hl 
bc9b 36 00				ld (hl), 0 
bc9d			 
bc9d				 
bc9d					 
bc9d 21 d7 e3				ld hl, scratch 
bca0			 
bca0					if DEBUG_FORTH_WORDS 
bca0						DMARK "MNx" 
bca0 f5				push af  
bca1 3a b5 bc			ld a, (.dmark)  
bca4 32 71 ee			ld (debug_mark),a  
bca7 3a b6 bc			ld a, (.dmark+1)  
bcaa 32 72 ee			ld (debug_mark+1),a  
bcad 3a b7 bc			ld a, (.dmark+2)  
bcb0 32 73 ee			ld (debug_mark+2),a  
bcb3 18 03			jr .pastdmark  
bcb5 ..			.dmark: db "MNx"  
bcb8 f1			.pastdmark: pop af  
bcb9			endm  
# End of macro DMARK
bcb9						CALLMONITOR 
bcb9 cd 95 93			call break_point_state  
bcbc				endm  
# End of macro CALLMONITOR
bcbc					endif 
bcbc			 
bcbc			 
bcbc			 
bcbc 3e 00				ld a, 0 
bcbe cd 98 89				call menu 
bcc1			 
bcc1			 
bcc1 6f					ld l, a 
bcc2 26 00				ld h, 0 
bcc4			 
bcc4					if DEBUG_FORTH_WORDS 
bcc4						DMARK "MNr" 
bcc4 f5				push af  
bcc5 3a d9 bc			ld a, (.dmark)  
bcc8 32 71 ee			ld (debug_mark),a  
bccb 3a da bc			ld a, (.dmark+1)  
bcce 32 72 ee			ld (debug_mark+1),a  
bcd1 3a db bc			ld a, (.dmark+2)  
bcd4 32 73 ee			ld (debug_mark+2),a  
bcd7 18 03			jr .pastdmark  
bcd9 ..			.dmark: db "MNr"  
bcdc f1			.pastdmark: pop af  
bcdd			endm  
# End of macro DMARK
bcdd						CALLMONITOR 
bcdd cd 95 93			call break_point_state  
bce0				endm  
# End of macro CALLMONITOR
bce0					endif 
bce0			 
bce0 cd 00 9a				call forth_push_numhl 
bce3			 
bce3			 
bce3			 
bce3			 
bce3				       NEXTW 
bce3 c3 69 9d			jp macro_next 
bce6				endm 
# End of macro NEXTW
bce6			 
bce6			 
bce6			.ENDDISPLAY: 
bce6			 
bce6			; eof 
# End of file forth_words_display.asm
bce6			include "forth_words_str.asm" 
bce6			 
bce6			; | ## String Words 
bce6			 
bce6			.PTR:   
bce6			 
bce6				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bce6 48				db WORD_SYS_CORE+52             
bce7 13 bd			dw .STYPE            
bce9 04				db 3 + 1 
bcea .. 00			db "PTR",0              
bcee				endm 
# End of macro CWHEAD
bcee			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bcee			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bcee			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bcee			 
bcee					if DEBUG_FORTH_WORDS_KEY 
bcee						DMARK "PTR" 
bcee f5				push af  
bcef 3a 03 bd			ld a, (.dmark)  
bcf2 32 71 ee			ld (debug_mark),a  
bcf5 3a 04 bd			ld a, (.dmark+1)  
bcf8 32 72 ee			ld (debug_mark+1),a  
bcfb 3a 05 bd			ld a, (.dmark+2)  
bcfe 32 73 ee			ld (debug_mark+2),a  
bd01 18 03			jr .pastdmark  
bd03 ..			.dmark: db "PTR"  
bd06 f1			.pastdmark: pop af  
bd07			endm  
# End of macro DMARK
bd07						CALLMONITOR 
bd07 cd 95 93			call break_point_state  
bd0a				endm  
# End of macro CALLMONITOR
bd0a					endif 
bd0a					FORTH_DSP_VALUEHL 
bd0a cd f7 9b			call macro_dsp_valuehl 
bd0d				endm 
# End of macro FORTH_DSP_VALUEHL
bd0d cd 00 9a				call forth_push_numhl 
bd10			 
bd10			 
bd10					NEXTW 
bd10 c3 69 9d			jp macro_next 
bd13				endm 
# End of macro NEXTW
bd13			.STYPE: 
bd13				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bd13 48				db WORD_SYS_CORE+52             
bd14 62 bd			dw .UPPER            
bd16 06				db 5 + 1 
bd17 .. 00			db "STYPE",0              
bd1d				endm 
# End of macro CWHEAD
bd1d			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bd1d					if DEBUG_FORTH_WORDS_KEY 
bd1d						DMARK "STY" 
bd1d f5				push af  
bd1e 3a 32 bd			ld a, (.dmark)  
bd21 32 71 ee			ld (debug_mark),a  
bd24 3a 33 bd			ld a, (.dmark+1)  
bd27 32 72 ee			ld (debug_mark+1),a  
bd2a 3a 34 bd			ld a, (.dmark+2)  
bd2d 32 73 ee			ld (debug_mark+2),a  
bd30 18 03			jr .pastdmark  
bd32 ..			.dmark: db "STY"  
bd35 f1			.pastdmark: pop af  
bd36			endm  
# End of macro DMARK
bd36						CALLMONITOR 
bd36 cd 95 93			call break_point_state  
bd39				endm  
# End of macro CALLMONITOR
bd39					endif 
bd39					FORTH_DSP 
bd39 cd bd 9b			call macro_forth_dsp 
bd3c				endm 
# End of macro FORTH_DSP
bd3c					;v5 FORTH_DSP_VALUE 
bd3c			 
bd3c 7e					ld a, (hl) 
bd3d			 
bd3d f5					push af 
bd3e			 
bd3e			; Dont destroy TOS		FORTH_DSP_POP 
bd3e			 
bd3e f1					pop af 
bd3f			 
bd3f fe 01				cp DS_TYPE_STR 
bd41 28 09				jr z, .typestr 
bd43			 
bd43 fe 02				cp DS_TYPE_INUM 
bd45 28 0a				jr z, .typeinum 
bd47			 
bd47 21 60 bd				ld hl, .tna 
bd4a 18 0a				jr .tpush 
bd4c			 
bd4c 21 5c bd		.typestr:	ld hl, .tstr 
bd4f 18 05				jr .tpush 
bd51 21 5e bd		.typeinum:	ld hl, .tinum 
bd54 18 00				jr .tpush 
bd56			 
bd56			.tpush: 
bd56			 
bd56 cd 6e 9a				call forth_push_str 
bd59			 
bd59					NEXTW 
bd59 c3 69 9d			jp macro_next 
bd5c				endm 
# End of macro NEXTW
bd5c .. 00		.tstr:	db "s",0 
bd5e .. 00		.tinum:  db "i",0 
bd60 .. 00		.tna:   db "?", 0 
bd62			 
bd62			 
bd62			.UPPER: 
bd62				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bd62 48				db WORD_SYS_CORE+52             
bd63 9d bd			dw .LOWER            
bd65 06				db 5 + 1 
bd66 .. 00			db "UPPER",0              
bd6c				endm 
# End of macro CWHEAD
bd6c			; | UPPER ( s -- s ) Upper case string s  | DONE 
bd6c					if DEBUG_FORTH_WORDS_KEY 
bd6c						DMARK "UPR" 
bd6c f5				push af  
bd6d 3a 81 bd			ld a, (.dmark)  
bd70 32 71 ee			ld (debug_mark),a  
bd73 3a 82 bd			ld a, (.dmark+1)  
bd76 32 72 ee			ld (debug_mark+1),a  
bd79 3a 83 bd			ld a, (.dmark+2)  
bd7c 32 73 ee			ld (debug_mark+2),a  
bd7f 18 03			jr .pastdmark  
bd81 ..			.dmark: db "UPR"  
bd84 f1			.pastdmark: pop af  
bd85			endm  
# End of macro DMARK
bd85						CALLMONITOR 
bd85 cd 95 93			call break_point_state  
bd88				endm  
# End of macro CALLMONITOR
bd88					endif 
bd88			 
bd88					FORTH_DSP 
bd88 cd bd 9b			call macro_forth_dsp 
bd8b				endm 
# End of macro FORTH_DSP
bd8b					 
bd8b			; TODO check is string type 
bd8b			 
bd8b					FORTH_DSP_VALUEHL 
bd8b cd f7 9b			call macro_dsp_valuehl 
bd8e				endm 
# End of macro FORTH_DSP_VALUEHL
bd8e			; get pointer to string in hl 
bd8e			 
bd8e 7e			.toup:		ld a, (hl) 
bd8f fe 00				cp 0 
bd91 28 07				jr z, .toupdone 
bd93			 
bd93 cd 01 8f				call to_upper 
bd96			 
bd96 77					ld (hl), a 
bd97 23					inc hl 
bd98 18 f4				jr .toup 
bd9a			 
bd9a					 
bd9a			 
bd9a			 
bd9a			; for each char convert to upper 
bd9a					 
bd9a			.toupdone: 
bd9a			 
bd9a			 
bd9a					NEXTW 
bd9a c3 69 9d			jp macro_next 
bd9d				endm 
# End of macro NEXTW
bd9d			.LOWER: 
bd9d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bd9d 48				db WORD_SYS_CORE+52             
bd9e d8 bd			dw .TCASE            
bda0 06				db 5 + 1 
bda1 .. 00			db "LOWER",0              
bda7				endm 
# End of macro CWHEAD
bda7			; | LOWER ( s -- s ) Lower case string s  | DONE 
bda7					if DEBUG_FORTH_WORDS_KEY 
bda7						DMARK "LWR" 
bda7 f5				push af  
bda8 3a bc bd			ld a, (.dmark)  
bdab 32 71 ee			ld (debug_mark),a  
bdae 3a bd bd			ld a, (.dmark+1)  
bdb1 32 72 ee			ld (debug_mark+1),a  
bdb4 3a be bd			ld a, (.dmark+2)  
bdb7 32 73 ee			ld (debug_mark+2),a  
bdba 18 03			jr .pastdmark  
bdbc ..			.dmark: db "LWR"  
bdbf f1			.pastdmark: pop af  
bdc0			endm  
# End of macro DMARK
bdc0						CALLMONITOR 
bdc0 cd 95 93			call break_point_state  
bdc3				endm  
# End of macro CALLMONITOR
bdc3					endif 
bdc3			 
bdc3					FORTH_DSP 
bdc3 cd bd 9b			call macro_forth_dsp 
bdc6				endm 
# End of macro FORTH_DSP
bdc6					 
bdc6			; TODO check is string type 
bdc6			 
bdc6					FORTH_DSP_VALUEHL 
bdc6 cd f7 9b			call macro_dsp_valuehl 
bdc9				endm 
# End of macro FORTH_DSP_VALUEHL
bdc9			; get pointer to string in hl 
bdc9			 
bdc9 7e			.tolow:		ld a, (hl) 
bdca fe 00				cp 0 
bdcc 28 07				jr z, .tolowdone 
bdce			 
bdce cd 0a 8f				call to_lower 
bdd1			 
bdd1 77					ld (hl), a 
bdd2 23					inc hl 
bdd3 18 f4				jr .tolow 
bdd5			 
bdd5					 
bdd5			 
bdd5			 
bdd5			; for each char convert to low 
bdd5					 
bdd5			.tolowdone: 
bdd5					NEXTW 
bdd5 c3 69 9d			jp macro_next 
bdd8				endm 
# End of macro NEXTW
bdd8			.TCASE: 
bdd8				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bdd8 48				db WORD_SYS_CORE+52             
bdd9 0e bf			dw .SUBSTR            
bddb 06				db 5 + 1 
bddc .. 00			db "TCASE",0              
bde2				endm 
# End of macro CWHEAD
bde2			; | TCASE ( s -- s ) Title case string s  | DONE 
bde2					if DEBUG_FORTH_WORDS_KEY 
bde2						DMARK "TCS" 
bde2 f5				push af  
bde3 3a f7 bd			ld a, (.dmark)  
bde6 32 71 ee			ld (debug_mark),a  
bde9 3a f8 bd			ld a, (.dmark+1)  
bdec 32 72 ee			ld (debug_mark+1),a  
bdef 3a f9 bd			ld a, (.dmark+2)  
bdf2 32 73 ee			ld (debug_mark+2),a  
bdf5 18 03			jr .pastdmark  
bdf7 ..			.dmark: db "TCS"  
bdfa f1			.pastdmark: pop af  
bdfb			endm  
# End of macro DMARK
bdfb						CALLMONITOR 
bdfb cd 95 93			call break_point_state  
bdfe				endm  
# End of macro CALLMONITOR
bdfe					endif 
bdfe			 
bdfe					FORTH_DSP 
bdfe cd bd 9b			call macro_forth_dsp 
be01				endm 
# End of macro FORTH_DSP
be01					 
be01			; TODO check is string type 
be01			 
be01					FORTH_DSP_VALUEHL 
be01 cd f7 9b			call macro_dsp_valuehl 
be04				endm 
# End of macro FORTH_DSP_VALUEHL
be04			; get pointer to string in hl 
be04			 
be04					if DEBUG_FORTH_WORDS 
be04						DMARK "TC1" 
be04 f5				push af  
be05 3a 19 be			ld a, (.dmark)  
be08 32 71 ee			ld (debug_mark),a  
be0b 3a 1a be			ld a, (.dmark+1)  
be0e 32 72 ee			ld (debug_mark+1),a  
be11 3a 1b be			ld a, (.dmark+2)  
be14 32 73 ee			ld (debug_mark+2),a  
be17 18 03			jr .pastdmark  
be19 ..			.dmark: db "TC1"  
be1c f1			.pastdmark: pop af  
be1d			endm  
# End of macro DMARK
be1d						CALLMONITOR 
be1d cd 95 93			call break_point_state  
be20				endm  
# End of macro CALLMONITOR
be20					endif 
be20			 
be20					; first time in turn to upper case first char 
be20			 
be20 7e					ld a, (hl) 
be21 c3 ab be				jp .totsiptou 
be24			 
be24			 
be24 7e			.tot:		ld a, (hl) 
be25 fe 00				cp 0 
be27 ca ef be				jp z, .totdone 
be2a			 
be2a					if DEBUG_FORTH_WORDS 
be2a						DMARK "TC2" 
be2a f5				push af  
be2b 3a 3f be			ld a, (.dmark)  
be2e 32 71 ee			ld (debug_mark),a  
be31 3a 40 be			ld a, (.dmark+1)  
be34 32 72 ee			ld (debug_mark+1),a  
be37 3a 41 be			ld a, (.dmark+2)  
be3a 32 73 ee			ld (debug_mark+2),a  
be3d 18 03			jr .pastdmark  
be3f ..			.dmark: db "TC2"  
be42 f1			.pastdmark: pop af  
be43			endm  
# End of macro DMARK
be43						CALLMONITOR 
be43 cd 95 93			call break_point_state  
be46				endm  
# End of macro CALLMONITOR
be46					endif 
be46					; check to see if current char is a space 
be46			 
be46 fe 20				cp ' ' 
be48 28 21				jr z, .totsp 
be4a cd 0a 8f				call to_lower 
be4d					if DEBUG_FORTH_WORDS 
be4d						DMARK "TC3" 
be4d f5				push af  
be4e 3a 62 be			ld a, (.dmark)  
be51 32 71 ee			ld (debug_mark),a  
be54 3a 63 be			ld a, (.dmark+1)  
be57 32 72 ee			ld (debug_mark+1),a  
be5a 3a 64 be			ld a, (.dmark+2)  
be5d 32 73 ee			ld (debug_mark+2),a  
be60 18 03			jr .pastdmark  
be62 ..			.dmark: db "TC3"  
be65 f1			.pastdmark: pop af  
be66			endm  
# End of macro DMARK
be66						CALLMONITOR 
be66 cd 95 93			call break_point_state  
be69				endm  
# End of macro CALLMONITOR
be69					endif 
be69 18 63				jr .totnxt 
be6b			 
be6b			.totsp:         ; on a space, find next char which should be upper 
be6b			 
be6b					if DEBUG_FORTH_WORDS 
be6b						DMARK "TC4" 
be6b f5				push af  
be6c 3a 80 be			ld a, (.dmark)  
be6f 32 71 ee			ld (debug_mark),a  
be72 3a 81 be			ld a, (.dmark+1)  
be75 32 72 ee			ld (debug_mark+1),a  
be78 3a 82 be			ld a, (.dmark+2)  
be7b 32 73 ee			ld (debug_mark+2),a  
be7e 18 03			jr .pastdmark  
be80 ..			.dmark: db "TC4"  
be83 f1			.pastdmark: pop af  
be84			endm  
# End of macro DMARK
be84						CALLMONITOR 
be84 cd 95 93			call break_point_state  
be87				endm  
# End of macro CALLMONITOR
be87					endif 
be87					;; 
be87			 
be87 fe 20				cp ' ' 
be89 20 20				jr nz, .totsiptou 
be8b 23					inc hl 
be8c 7e					ld a, (hl) 
be8d					if DEBUG_FORTH_WORDS 
be8d						DMARK "TC5" 
be8d f5				push af  
be8e 3a a2 be			ld a, (.dmark)  
be91 32 71 ee			ld (debug_mark),a  
be94 3a a3 be			ld a, (.dmark+1)  
be97 32 72 ee			ld (debug_mark+1),a  
be9a 3a a4 be			ld a, (.dmark+2)  
be9d 32 73 ee			ld (debug_mark+2),a  
bea0 18 03			jr .pastdmark  
bea2 ..			.dmark: db "TC5"  
bea5 f1			.pastdmark: pop af  
bea6			endm  
# End of macro DMARK
bea6						CALLMONITOR 
bea6 cd 95 93			call break_point_state  
bea9				endm  
# End of macro CALLMONITOR
bea9					endif 
bea9 18 c0				jr .totsp 
beab fe 00		.totsiptou:    cp 0 
bead 28 40				jr z, .totdone 
beaf					; not space and not zero term so upper case it 
beaf cd 01 8f				call to_upper 
beb2			 
beb2					if DEBUG_FORTH_WORDS 
beb2						DMARK "TC6" 
beb2 f5				push af  
beb3 3a c7 be			ld a, (.dmark)  
beb6 32 71 ee			ld (debug_mark),a  
beb9 3a c8 be			ld a, (.dmark+1)  
bebc 32 72 ee			ld (debug_mark+1),a  
bebf 3a c9 be			ld a, (.dmark+2)  
bec2 32 73 ee			ld (debug_mark+2),a  
bec5 18 03			jr .pastdmark  
bec7 ..			.dmark: db "TC6"  
beca f1			.pastdmark: pop af  
becb			endm  
# End of macro DMARK
becb						CALLMONITOR 
becb cd 95 93			call break_point_state  
bece				endm  
# End of macro CALLMONITOR
bece					endif 
bece			 
bece			 
bece			.totnxt: 
bece			 
bece 77					ld (hl), a 
becf 23					inc hl 
bed0					if DEBUG_FORTH_WORDS 
bed0						DMARK "TC7" 
bed0 f5				push af  
bed1 3a e5 be			ld a, (.dmark)  
bed4 32 71 ee			ld (debug_mark),a  
bed7 3a e6 be			ld a, (.dmark+1)  
beda 32 72 ee			ld (debug_mark+1),a  
bedd 3a e7 be			ld a, (.dmark+2)  
bee0 32 73 ee			ld (debug_mark+2),a  
bee3 18 03			jr .pastdmark  
bee5 ..			.dmark: db "TC7"  
bee8 f1			.pastdmark: pop af  
bee9			endm  
# End of macro DMARK
bee9						CALLMONITOR 
bee9 cd 95 93			call break_point_state  
beec				endm  
# End of macro CALLMONITOR
beec					endif 
beec c3 24 be				jp .tot 
beef			 
beef					 
beef			 
beef			 
beef			; for each char convert to low 
beef					 
beef			.totdone: 
beef					if DEBUG_FORTH_WORDS 
beef						DMARK "TCd" 
beef f5				push af  
bef0 3a 04 bf			ld a, (.dmark)  
bef3 32 71 ee			ld (debug_mark),a  
bef6 3a 05 bf			ld a, (.dmark+1)  
bef9 32 72 ee			ld (debug_mark+1),a  
befc 3a 06 bf			ld a, (.dmark+2)  
beff 32 73 ee			ld (debug_mark+2),a  
bf02 18 03			jr .pastdmark  
bf04 ..			.dmark: db "TCd"  
bf07 f1			.pastdmark: pop af  
bf08			endm  
# End of macro DMARK
bf08						CALLMONITOR 
bf08 cd 95 93			call break_point_state  
bf0b				endm  
# End of macro CALLMONITOR
bf0b					endif 
bf0b					NEXTW 
bf0b c3 69 9d			jp macro_next 
bf0e				endm 
# End of macro NEXTW
bf0e			 
bf0e			.SUBSTR: 
bf0e				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bf0e 48				db WORD_SYS_CORE+52             
bf0f 6c bf			dw .LEFT            
bf11 07				db 6 + 1 
bf12 .. 00			db "SUBSTR",0              
bf19				endm 
# End of macro CWHEAD
bf19			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bf19			 
bf19					if DEBUG_FORTH_WORDS_KEY 
bf19						DMARK "SST" 
bf19 f5				push af  
bf1a 3a 2e bf			ld a, (.dmark)  
bf1d 32 71 ee			ld (debug_mark),a  
bf20 3a 2f bf			ld a, (.dmark+1)  
bf23 32 72 ee			ld (debug_mark+1),a  
bf26 3a 30 bf			ld a, (.dmark+2)  
bf29 32 73 ee			ld (debug_mark+2),a  
bf2c 18 03			jr .pastdmark  
bf2e ..			.dmark: db "SST"  
bf31 f1			.pastdmark: pop af  
bf32			endm  
# End of macro DMARK
bf32						CALLMONITOR 
bf32 cd 95 93			call break_point_state  
bf35				endm  
# End of macro CALLMONITOR
bf35					endif 
bf35			; TODO check string type 
bf35					FORTH_DSP_VALUEHL 
bf35 cd f7 9b			call macro_dsp_valuehl 
bf38				endm 
# End of macro FORTH_DSP_VALUEHL
bf38			 
bf38 e5					push hl      ; string length 
bf39			 
bf39					FORTH_DSP_POP 
bf39 cd af 9c			call macro_forth_dsp_pop 
bf3c				endm 
# End of macro FORTH_DSP_POP
bf3c			 
bf3c					FORTH_DSP_VALUEHL 
bf3c cd f7 9b			call macro_dsp_valuehl 
bf3f				endm 
# End of macro FORTH_DSP_VALUEHL
bf3f			 
bf3f e5					push hl     ; start char 
bf40			 
bf40					FORTH_DSP_POP 
bf40 cd af 9c			call macro_forth_dsp_pop 
bf43				endm 
# End of macro FORTH_DSP_POP
bf43			 
bf43			 
bf43					FORTH_DSP_VALUE 
bf43 cd e0 9b			call macro_forth_dsp_value 
bf46				endm 
# End of macro FORTH_DSP_VALUE
bf46			 
bf46 d1					pop de    ; get start post offset 
bf47			 
bf47 19					add hl, de    ; starting offset 
bf48			 
bf48 c1					pop bc 
bf49 c5					push bc      ; grab size of string 
bf4a			 
bf4a e5					push hl    ; save string start  
bf4b			 
bf4b 26 00				ld h, 0 
bf4d 69					ld l, c 
bf4e 23					inc hl 
bf4f 23					inc hl 
bf50			 
bf50 cd 5b 90				call malloc 
bf53				if DEBUG_FORTH_MALLOC_GUARD 
bf53 cc 9b c5				call z,malloc_error 
bf56				endif 
bf56			 
bf56 eb					ex de, hl      ; save malloc area for string copy 
bf57 e1					pop hl    ; get back source 
bf58 c1					pop bc    ; get length of string back 
bf59			 
bf59 d5					push de    ; save malloc area for after we push 
bf5a ed b0				ldir     ; copy substr 
bf5c			 
bf5c			 
bf5c eb					ex de, hl 
bf5d 3e 00				ld a, 0 
bf5f 77					ld (hl), a   ; term substr 
bf60			 
bf60					 
bf60 e1					pop hl    ; get malloc so we can push it 
bf61 e5					push hl   ; save so we can free it afterwards 
bf62			 
bf62 cd 6e 9a				call forth_push_str 
bf65			 
bf65 e1					pop hl 
bf66 cd 25 91				call free 
bf69			 
bf69					 
bf69					 
bf69			 
bf69			 
bf69					NEXTW 
bf69 c3 69 9d			jp macro_next 
bf6c				endm 
# End of macro NEXTW
bf6c			 
bf6c			.LEFT: 
bf6c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bf6c 48				db WORD_SYS_CORE+52             
bf6d 94 bf			dw .RIGHT            
bf6f 05				db 4 + 1 
bf70 .. 00			db "LEFT",0              
bf75				endm 
# End of macro CWHEAD
bf75			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bf75					if DEBUG_FORTH_WORDS_KEY 
bf75						DMARK "LEF" 
bf75 f5				push af  
bf76 3a 8a bf			ld a, (.dmark)  
bf79 32 71 ee			ld (debug_mark),a  
bf7c 3a 8b bf			ld a, (.dmark+1)  
bf7f 32 72 ee			ld (debug_mark+1),a  
bf82 3a 8c bf			ld a, (.dmark+2)  
bf85 32 73 ee			ld (debug_mark+2),a  
bf88 18 03			jr .pastdmark  
bf8a ..			.dmark: db "LEF"  
bf8d f1			.pastdmark: pop af  
bf8e			endm  
# End of macro DMARK
bf8e						CALLMONITOR 
bf8e cd 95 93			call break_point_state  
bf91				endm  
# End of macro CALLMONITOR
bf91					endif 
bf91			 
bf91					NEXTW 
bf91 c3 69 9d			jp macro_next 
bf94				endm 
# End of macro NEXTW
bf94			.RIGHT: 
bf94				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bf94 48				db WORD_SYS_CORE+52             
bf95 bd bf			dw .STR2NUM            
bf97 06				db 5 + 1 
bf98 .. 00			db "RIGHT",0              
bf9e				endm 
# End of macro CWHEAD
bf9e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bf9e					if DEBUG_FORTH_WORDS_KEY 
bf9e						DMARK "RIG" 
bf9e f5				push af  
bf9f 3a b3 bf			ld a, (.dmark)  
bfa2 32 71 ee			ld (debug_mark),a  
bfa5 3a b4 bf			ld a, (.dmark+1)  
bfa8 32 72 ee			ld (debug_mark+1),a  
bfab 3a b5 bf			ld a, (.dmark+2)  
bfae 32 73 ee			ld (debug_mark+2),a  
bfb1 18 03			jr .pastdmark  
bfb3 ..			.dmark: db "RIG"  
bfb6 f1			.pastdmark: pop af  
bfb7			endm  
# End of macro DMARK
bfb7						CALLMONITOR 
bfb7 cd 95 93			call break_point_state  
bfba				endm  
# End of macro CALLMONITOR
bfba					endif 
bfba			 
bfba					NEXTW 
bfba c3 69 9d			jp macro_next 
bfbd				endm 
# End of macro NEXTW
bfbd			 
bfbd			 
bfbd			.STR2NUM: 
bfbd				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bfbd 48				db WORD_SYS_CORE+52             
bfbe 49 c0			dw .NUM2STR            
bfc0 08				db 7 + 1 
bfc1 .. 00			db "STR2NUM",0              
bfc9				endm 
# End of macro CWHEAD
bfc9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bfc9			 
bfc9			 
bfc9			; TODO STR type check to do 
bfc9					if DEBUG_FORTH_WORDS_KEY 
bfc9						DMARK "S2N" 
bfc9 f5				push af  
bfca 3a de bf			ld a, (.dmark)  
bfcd 32 71 ee			ld (debug_mark),a  
bfd0 3a df bf			ld a, (.dmark+1)  
bfd3 32 72 ee			ld (debug_mark+1),a  
bfd6 3a e0 bf			ld a, (.dmark+2)  
bfd9 32 73 ee			ld (debug_mark+2),a  
bfdc 18 03			jr .pastdmark  
bfde ..			.dmark: db "S2N"  
bfe1 f1			.pastdmark: pop af  
bfe2			endm  
# End of macro DMARK
bfe2						CALLMONITOR 
bfe2 cd 95 93			call break_point_state  
bfe5				endm  
# End of macro CALLMONITOR
bfe5					endif 
bfe5			 
bfe5					;FORTH_DSP 
bfe5					FORTH_DSP_VALUE 
bfe5 cd e0 9b			call macro_forth_dsp_value 
bfe8				endm 
# End of macro FORTH_DSP_VALUE
bfe8					;inc hl 
bfe8			 
bfe8 eb					ex de, hl 
bfe9					if DEBUG_FORTH_WORDS 
bfe9						DMARK "S2a" 
bfe9 f5				push af  
bfea 3a fe bf			ld a, (.dmark)  
bfed 32 71 ee			ld (debug_mark),a  
bff0 3a ff bf			ld a, (.dmark+1)  
bff3 32 72 ee			ld (debug_mark+1),a  
bff6 3a 00 c0			ld a, (.dmark+2)  
bff9 32 73 ee			ld (debug_mark+2),a  
bffc 18 03			jr .pastdmark  
bffe ..			.dmark: db "S2a"  
c001 f1			.pastdmark: pop af  
c002			endm  
# End of macro DMARK
c002						CALLMONITOR 
c002 cd 95 93			call break_point_state  
c005				endm  
# End of macro CALLMONITOR
c005					endif 
c005 cd 89 8f				call string_to_uint16 
c008			 
c008					if DEBUG_FORTH_WORDS 
c008						DMARK "S2b" 
c008 f5				push af  
c009 3a 1d c0			ld a, (.dmark)  
c00c 32 71 ee			ld (debug_mark),a  
c00f 3a 1e c0			ld a, (.dmark+1)  
c012 32 72 ee			ld (debug_mark+1),a  
c015 3a 1f c0			ld a, (.dmark+2)  
c018 32 73 ee			ld (debug_mark+2),a  
c01b 18 03			jr .pastdmark  
c01d ..			.dmark: db "S2b"  
c020 f1			.pastdmark: pop af  
c021			endm  
# End of macro DMARK
c021						CALLMONITOR 
c021 cd 95 93			call break_point_state  
c024				endm  
# End of macro CALLMONITOR
c024					endif 
c024			;		push hl 
c024					FORTH_DSP_POP 
c024 cd af 9c			call macro_forth_dsp_pop 
c027				endm 
# End of macro FORTH_DSP_POP
c027			;		pop hl 
c027					 
c027					if DEBUG_FORTH_WORDS 
c027						DMARK "S2b" 
c027 f5				push af  
c028 3a 3c c0			ld a, (.dmark)  
c02b 32 71 ee			ld (debug_mark),a  
c02e 3a 3d c0			ld a, (.dmark+1)  
c031 32 72 ee			ld (debug_mark+1),a  
c034 3a 3e c0			ld a, (.dmark+2)  
c037 32 73 ee			ld (debug_mark+2),a  
c03a 18 03			jr .pastdmark  
c03c ..			.dmark: db "S2b"  
c03f f1			.pastdmark: pop af  
c040			endm  
# End of macro DMARK
c040						CALLMONITOR 
c040 cd 95 93			call break_point_state  
c043				endm  
# End of macro CALLMONITOR
c043					endif 
c043 cd 00 9a				call forth_push_numhl	 
c046			 
c046				 
c046				       NEXTW 
c046 c3 69 9d			jp macro_next 
c049				endm 
# End of macro NEXTW
c049			.NUM2STR: 
c049				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c049 48				db WORD_SYS_CORE+52             
c04a 58 c0			dw .CONCAT            
c04c 08				db 7 + 1 
c04d .. 00			db "NUM2STR",0              
c055				endm 
# End of macro CWHEAD
c055			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c055			 
c055			;		; malloc a string to target 
c055			;		ld hl, 10     ; TODO max string size should be fine 
c055			;		call malloc 
c055			;		push hl    ; save malloc location 
c055			; 
c055			; 
c055			;; TODO check int type 
c055			;		FORTH_DSP_VALUEHL 
c055			;		ld a, l 
c055			;		call DispAToASCII   
c055			;;TODO need to chage above call to dump into string 
c055			; 
c055			; 
c055			 
c055				       NEXTW 
c055 c3 69 9d			jp macro_next 
c058				endm 
# End of macro NEXTW
c058			 
c058			.CONCAT: 
c058				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c058 48				db WORD_SYS_CORE+52             
c059 0b c1			dw .FIND            
c05b 07				db 6 + 1 
c05c .. 00			db "CONCAT",0              
c063				endm 
# End of macro CWHEAD
c063			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c063			 
c063			; TODO check string type 
c063			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c063			 
c063					if DEBUG_FORTH_WORDS_KEY 
c063						DMARK "CON" 
c063 f5				push af  
c064 3a 78 c0			ld a, (.dmark)  
c067 32 71 ee			ld (debug_mark),a  
c06a 3a 79 c0			ld a, (.dmark+1)  
c06d 32 72 ee			ld (debug_mark+1),a  
c070 3a 7a c0			ld a, (.dmark+2)  
c073 32 73 ee			ld (debug_mark+2),a  
c076 18 03			jr .pastdmark  
c078 ..			.dmark: db "CON"  
c07b f1			.pastdmark: pop af  
c07c			endm  
# End of macro DMARK
c07c						CALLMONITOR 
c07c cd 95 93			call break_point_state  
c07f				endm  
# End of macro CALLMONITOR
c07f					endif 
c07f			 
c07f			 
c07f					FORTH_DSP_VALUE 
c07f cd e0 9b			call macro_forth_dsp_value 
c082				endm 
# End of macro FORTH_DSP_VALUE
c082 e5					push hl   ; s2 
c083			 
c083					FORTH_DSP_POP 
c083 cd af 9c			call macro_forth_dsp_pop 
c086				endm 
# End of macro FORTH_DSP_POP
c086			 
c086					FORTH_DSP_VALUE 
c086 cd e0 9b			call macro_forth_dsp_value 
c089				endm 
# End of macro FORTH_DSP_VALUE
c089			 
c089 e5					push hl   ; s1 
c08a			 
c08a					FORTH_DSP_POP 
c08a cd af 9c			call macro_forth_dsp_pop 
c08d				endm 
# End of macro FORTH_DSP_POP
c08d					 
c08d			 
c08d					; copy s1 
c08d			 
c08d				 
c08d					; save ptr 
c08d e1					pop hl  
c08e e5					push hl 
c08f 3e 00				ld a, 0 
c091 cd fd 8f				call strlent 
c094					;inc hl    ; zer0 
c094 06 00				ld b, 0 
c096 4d					ld c, l 
c097 e1					pop hl		 
c098 11 d7 e3				ld de, scratch	 
c09b					if DEBUG_FORTH_WORDS 
c09b						DMARK "CO1" 
c09b f5				push af  
c09c 3a b0 c0			ld a, (.dmark)  
c09f 32 71 ee			ld (debug_mark),a  
c0a2 3a b1 c0			ld a, (.dmark+1)  
c0a5 32 72 ee			ld (debug_mark+1),a  
c0a8 3a b2 c0			ld a, (.dmark+2)  
c0ab 32 73 ee			ld (debug_mark+2),a  
c0ae 18 03			jr .pastdmark  
c0b0 ..			.dmark: db "CO1"  
c0b3 f1			.pastdmark: pop af  
c0b4			endm  
# End of macro DMARK
c0b4						CALLMONITOR 
c0b4 cd 95 93			call break_point_state  
c0b7				endm  
# End of macro CALLMONITOR
c0b7					endif 
c0b7 ed b0				ldir 
c0b9			 
c0b9 e1					pop hl 
c0ba e5					push hl 
c0bb d5					push de 
c0bc			 
c0bc			 
c0bc 3e 00				ld a, 0 
c0be cd fd 8f				call strlent 
c0c1 23					inc hl    ; zer0 
c0c2 23					inc hl 
c0c3 06 00				ld b, 0 
c0c5 4d					ld c, l 
c0c6 d1					pop de 
c0c7 e1					pop hl		 
c0c8					if DEBUG_FORTH_WORDS 
c0c8						DMARK "CO2" 
c0c8 f5				push af  
c0c9 3a dd c0			ld a, (.dmark)  
c0cc 32 71 ee			ld (debug_mark),a  
c0cf 3a de c0			ld a, (.dmark+1)  
c0d2 32 72 ee			ld (debug_mark+1),a  
c0d5 3a df c0			ld a, (.dmark+2)  
c0d8 32 73 ee			ld (debug_mark+2),a  
c0db 18 03			jr .pastdmark  
c0dd ..			.dmark: db "CO2"  
c0e0 f1			.pastdmark: pop af  
c0e1			endm  
# End of macro DMARK
c0e1						CALLMONITOR 
c0e1 cd 95 93			call break_point_state  
c0e4				endm  
# End of macro CALLMONITOR
c0e4					endif 
c0e4 ed b0				ldir 
c0e6			 
c0e6			 
c0e6			 
c0e6 21 d7 e3				ld hl, scratch 
c0e9					if DEBUG_FORTH_WORDS 
c0e9						DMARK "CO5" 
c0e9 f5				push af  
c0ea 3a fe c0			ld a, (.dmark)  
c0ed 32 71 ee			ld (debug_mark),a  
c0f0 3a ff c0			ld a, (.dmark+1)  
c0f3 32 72 ee			ld (debug_mark+1),a  
c0f6 3a 00 c1			ld a, (.dmark+2)  
c0f9 32 73 ee			ld (debug_mark+2),a  
c0fc 18 03			jr .pastdmark  
c0fe ..			.dmark: db "CO5"  
c101 f1			.pastdmark: pop af  
c102			endm  
# End of macro DMARK
c102						CALLMONITOR 
c102 cd 95 93			call break_point_state  
c105				endm  
# End of macro CALLMONITOR
c105					endif 
c105			 
c105 cd 6e 9a				call forth_push_str 
c108			 
c108			 
c108			 
c108			 
c108				       NEXTW 
c108 c3 69 9d			jp macro_next 
c10b				endm 
# End of macro NEXTW
c10b			 
c10b			 
c10b			.FIND: 
c10b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c10b 4b				db WORD_SYS_CORE+55             
c10c c9 c1			dw .LEN            
c10e 05				db 4 + 1 
c10f .. 00			db "FIND",0              
c114				endm 
# End of macro CWHEAD
c114			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c114			 
c114					if DEBUG_FORTH_WORDS_KEY 
c114						DMARK "FND" 
c114 f5				push af  
c115 3a 29 c1			ld a, (.dmark)  
c118 32 71 ee			ld (debug_mark),a  
c11b 3a 2a c1			ld a, (.dmark+1)  
c11e 32 72 ee			ld (debug_mark+1),a  
c121 3a 2b c1			ld a, (.dmark+2)  
c124 32 73 ee			ld (debug_mark+2),a  
c127 18 03			jr .pastdmark  
c129 ..			.dmark: db "FND"  
c12c f1			.pastdmark: pop af  
c12d			endm  
# End of macro DMARK
c12d						CALLMONITOR 
c12d cd 95 93			call break_point_state  
c130				endm  
# End of macro CALLMONITOR
c130					endif 
c130			 
c130			; TODO check string type 
c130					FORTH_DSP_VALUE 
c130 cd e0 9b			call macro_forth_dsp_value 
c133				endm 
# End of macro FORTH_DSP_VALUE
c133			 
c133 e5					push hl    
c134 7e					ld a,(hl)    ; char to find   
c135			; TODO change char to substr 
c135			 
c135 f5					push af 
c136					 
c136			 
c136			 
c136					if DEBUG_FORTH_WORDS 
c136						DMARK "FN1" 
c136 f5				push af  
c137 3a 4b c1			ld a, (.dmark)  
c13a 32 71 ee			ld (debug_mark),a  
c13d 3a 4c c1			ld a, (.dmark+1)  
c140 32 72 ee			ld (debug_mark+1),a  
c143 3a 4d c1			ld a, (.dmark+2)  
c146 32 73 ee			ld (debug_mark+2),a  
c149 18 03			jr .pastdmark  
c14b ..			.dmark: db "FN1"  
c14e f1			.pastdmark: pop af  
c14f			endm  
# End of macro DMARK
c14f						CALLMONITOR 
c14f cd 95 93			call break_point_state  
c152				endm  
# End of macro CALLMONITOR
c152					endif 
c152			 
c152					FORTH_DSP_POP 
c152 cd af 9c			call macro_forth_dsp_pop 
c155				endm 
# End of macro FORTH_DSP_POP
c155			 
c155					; string to search 
c155			 
c155					FORTH_DSP_VALUE 
c155 cd e0 9b			call macro_forth_dsp_value 
c158				endm 
# End of macro FORTH_DSP_VALUE
c158			 
c158 d1					pop de  ; d is char to find  
c159			 
c159					if DEBUG_FORTH_WORDS 
c159						DMARK "FN2" 
c159 f5				push af  
c15a 3a 6e c1			ld a, (.dmark)  
c15d 32 71 ee			ld (debug_mark),a  
c160 3a 6f c1			ld a, (.dmark+1)  
c163 32 72 ee			ld (debug_mark+1),a  
c166 3a 70 c1			ld a, (.dmark+2)  
c169 32 73 ee			ld (debug_mark+2),a  
c16c 18 03			jr .pastdmark  
c16e ..			.dmark: db "FN2"  
c171 f1			.pastdmark: pop af  
c172			endm  
# End of macro DMARK
c172						CALLMONITOR 
c172 cd 95 93			call break_point_state  
c175				endm  
# End of macro CALLMONITOR
c175					endif 
c175					 
c175 01 00 00				ld bc, 0 
c178 7e			.findchar:      ld a,(hl) 
c179 fe 00				cp 0   		 
c17b 28 27				jr z, .finddone     
c17d ba					cp d 
c17e 28 20				jr z, .foundchar 
c180 03					inc bc 
c181 23					inc hl 
c182					if DEBUG_FORTH_WORDS 
c182						DMARK "FN3" 
c182 f5				push af  
c183 3a 97 c1			ld a, (.dmark)  
c186 32 71 ee			ld (debug_mark),a  
c189 3a 98 c1			ld a, (.dmark+1)  
c18c 32 72 ee			ld (debug_mark+1),a  
c18f 3a 99 c1			ld a, (.dmark+2)  
c192 32 73 ee			ld (debug_mark+2),a  
c195 18 03			jr .pastdmark  
c197 ..			.dmark: db "FN3"  
c19a f1			.pastdmark: pop af  
c19b			endm  
# End of macro DMARK
c19b						CALLMONITOR 
c19b cd 95 93			call break_point_state  
c19e				endm  
# End of macro CALLMONITOR
c19e					endif 
c19e 18 d8				jr .findchar 
c1a0			 
c1a0			 
c1a0 c5			.foundchar:	push bc 
c1a1 e1					pop hl 
c1a2 18 03				jr .findexit 
c1a4			 
c1a4			 
c1a4							 
c1a4			 
c1a4			.finddone:     ; got to end of string with no find 
c1a4 21 00 00				ld hl, 0 
c1a7			.findexit: 
c1a7			 
c1a7					if DEBUG_FORTH_WORDS 
c1a7						DMARK "FNd" 
c1a7 f5				push af  
c1a8 3a bc c1			ld a, (.dmark)  
c1ab 32 71 ee			ld (debug_mark),a  
c1ae 3a bd c1			ld a, (.dmark+1)  
c1b1 32 72 ee			ld (debug_mark+1),a  
c1b4 3a be c1			ld a, (.dmark+2)  
c1b7 32 73 ee			ld (debug_mark+2),a  
c1ba 18 03			jr .pastdmark  
c1bc ..			.dmark: db "FNd"  
c1bf f1			.pastdmark: pop af  
c1c0			endm  
# End of macro DMARK
c1c0						CALLMONITOR 
c1c0 cd 95 93			call break_point_state  
c1c3				endm  
# End of macro CALLMONITOR
c1c3					endif 
c1c3 cd 00 9a			call forth_push_numhl 
c1c6			 
c1c6				       NEXTW 
c1c6 c3 69 9d			jp macro_next 
c1c9				endm 
# End of macro NEXTW
c1c9			 
c1c9			.LEN: 
c1c9				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c1c9 4c				db WORD_SYS_CORE+56             
c1ca fe c1			dw .CHAR            
c1cc 06				db 5 + 1 
c1cd .. 00			db "COUNT",0              
c1d3				endm 
# End of macro CWHEAD
c1d3			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c1d3			 
c1d3					if DEBUG_FORTH_WORDS_KEY 
c1d3						DMARK "CNT" 
c1d3 f5				push af  
c1d4 3a e8 c1			ld a, (.dmark)  
c1d7 32 71 ee			ld (debug_mark),a  
c1da 3a e9 c1			ld a, (.dmark+1)  
c1dd 32 72 ee			ld (debug_mark+1),a  
c1e0 3a ea c1			ld a, (.dmark+2)  
c1e3 32 73 ee			ld (debug_mark+2),a  
c1e6 18 03			jr .pastdmark  
c1e8 ..			.dmark: db "CNT"  
c1eb f1			.pastdmark: pop af  
c1ec			endm  
# End of macro DMARK
c1ec						CALLMONITOR 
c1ec cd 95 93			call break_point_state  
c1ef				endm  
# End of macro CALLMONITOR
c1ef					endif 
c1ef			; TODO check string type 
c1ef					FORTH_DSP 
c1ef cd bd 9b			call macro_forth_dsp 
c1f2				endm 
# End of macro FORTH_DSP
c1f2					;v5FORTH_DSP_VALUE 
c1f2			 
c1f2 23					inc hl 
c1f3			 
c1f3 3e 00				ld a, 0 
c1f5 cd fd 8f				call strlent 
c1f8			 
c1f8 cd 00 9a				call forth_push_numhl 
c1fb			 
c1fb			 
c1fb			 
c1fb				       NEXTW 
c1fb c3 69 9d			jp macro_next 
c1fe				endm 
# End of macro NEXTW
c1fe			.CHAR: 
c1fe				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c1fe 4d				db WORD_SYS_CORE+57             
c1ff 34 c2			dw .ENDSTR            
c201 05				db 4 + 1 
c202 .. 00			db "CHAR",0              
c207				endm 
# End of macro CWHEAD
c207			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c207					if DEBUG_FORTH_WORDS_KEY 
c207						DMARK "CHR" 
c207 f5				push af  
c208 3a 1c c2			ld a, (.dmark)  
c20b 32 71 ee			ld (debug_mark),a  
c20e 3a 1d c2			ld a, (.dmark+1)  
c211 32 72 ee			ld (debug_mark+1),a  
c214 3a 1e c2			ld a, (.dmark+2)  
c217 32 73 ee			ld (debug_mark+2),a  
c21a 18 03			jr .pastdmark  
c21c ..			.dmark: db "CHR"  
c21f f1			.pastdmark: pop af  
c220			endm  
# End of macro DMARK
c220						CALLMONITOR 
c220 cd 95 93			call break_point_state  
c223				endm  
# End of macro CALLMONITOR
c223					endif 
c223					FORTH_DSP 
c223 cd bd 9b			call macro_forth_dsp 
c226				endm 
# End of macro FORTH_DSP
c226					;v5 FORTH_DSP_VALUE 
c226 23					inc hl      ; now at start of numeric as string 
c227			 
c227			;		push hl 
c227			 
c227					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c227 cd af 9c			call macro_forth_dsp_pop 
c22a				endm 
# End of macro FORTH_DSP_POP
c22a			 
c22a			;		pop hl 
c22a			 
c22a					; push the content of a onto the stack as a value 
c22a			 
c22a 7e					ld a,(hl)   ; get char 
c22b 26 00				ld h,0 
c22d 6f					ld l,a 
c22e cd 00 9a				call forth_push_numhl 
c231			 
c231				       NEXTW 
c231 c3 69 9d			jp macro_next 
c234				endm 
# End of macro NEXTW
c234			 
c234			 
c234			 
c234			 
c234			.ENDSTR: 
c234			; eof 
c234			 
# End of file forth_words_str.asm
c234			include "forth_words_key.asm" 
c234			 
c234			; | ## Keyboard Words 
c234			 
c234			.KEY: 
c234				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c234 3e				db WORD_SYS_CORE+42             
c235 64 c2			dw .WAITK            
c237 04				db 3 + 1 
c238 .. 00			db "KEY",0              
c23c				endm 
# End of macro CWHEAD
c23c			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c23c			 
c23c					if DEBUG_FORTH_WORDS_KEY 
c23c						DMARK "KEY" 
c23c f5				push af  
c23d 3a 51 c2			ld a, (.dmark)  
c240 32 71 ee			ld (debug_mark),a  
c243 3a 52 c2			ld a, (.dmark+1)  
c246 32 72 ee			ld (debug_mark+1),a  
c249 3a 53 c2			ld a, (.dmark+2)  
c24c 32 73 ee			ld (debug_mark+2),a  
c24f 18 03			jr .pastdmark  
c251 ..			.dmark: db "KEY"  
c254 f1			.pastdmark: pop af  
c255			endm  
# End of macro DMARK
c255						CALLMONITOR 
c255 cd 95 93			call break_point_state  
c258				endm  
# End of macro CALLMONITOR
c258					endif 
c258			; TODO currently waits 
c258 cd 06 d9				call cin 
c25b					;call cin_wait 
c25b 6f					ld l, a 
c25c 26 00				ld h, 0 
c25e cd 00 9a				call forth_push_numhl 
c261					NEXTW 
c261 c3 69 9d			jp macro_next 
c264				endm 
# End of macro NEXTW
c264			.WAITK: 
c264				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c264 3f				db WORD_SYS_CORE+43             
c265 96 c2			dw .ACCEPT            
c267 06				db 5 + 1 
c268 .. 00			db "WAITK",0              
c26e				endm 
# End of macro CWHEAD
c26e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c26e					if DEBUG_FORTH_WORDS_KEY 
c26e						DMARK "WAI" 
c26e f5				push af  
c26f 3a 83 c2			ld a, (.dmark)  
c272 32 71 ee			ld (debug_mark),a  
c275 3a 84 c2			ld a, (.dmark+1)  
c278 32 72 ee			ld (debug_mark+1),a  
c27b 3a 85 c2			ld a, (.dmark+2)  
c27e 32 73 ee			ld (debug_mark+2),a  
c281 18 03			jr .pastdmark  
c283 ..			.dmark: db "WAI"  
c286 f1			.pastdmark: pop af  
c287			endm  
# End of macro DMARK
c287						CALLMONITOR 
c287 cd 95 93			call break_point_state  
c28a				endm  
# End of macro CALLMONITOR
c28a					endif 
c28a cd 00 d9				call cin_wait 
c28d 6f					ld l, a 
c28e 26 00				ld h, 0 
c290 cd 00 9a				call forth_push_numhl 
c293					NEXTW 
c293 c3 69 9d			jp macro_next 
c296				endm 
# End of macro NEXTW
c296			.ACCEPT: 
c296				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c296 40				db WORD_SYS_CORE+44             
c297 f4 c2			dw .EDIT            
c299 07				db 6 + 1 
c29a .. 00			db "ACCEPT",0              
c2a1				endm 
# End of macro CWHEAD
c2a1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c2a1					; TODO crashes on push 
c2a1					if DEBUG_FORTH_WORDS_KEY 
c2a1						DMARK "ACC" 
c2a1 f5				push af  
c2a2 3a b6 c2			ld a, (.dmark)  
c2a5 32 71 ee			ld (debug_mark),a  
c2a8 3a b7 c2			ld a, (.dmark+1)  
c2ab 32 72 ee			ld (debug_mark+1),a  
c2ae 3a b8 c2			ld a, (.dmark+2)  
c2b1 32 73 ee			ld (debug_mark+2),a  
c2b4 18 03			jr .pastdmark  
c2b6 ..			.dmark: db "ACC"  
c2b9 f1			.pastdmark: pop af  
c2ba			endm  
# End of macro DMARK
c2ba						CALLMONITOR 
c2ba cd 95 93			call break_point_state  
c2bd				endm  
# End of macro CALLMONITOR
c2bd					endif 
c2bd 21 d5 e5				ld hl, os_input 
c2c0 3e 00				ld a, 0 
c2c2 77					ld (hl),a 
c2c3 3a 40 eb				ld a,(f_cursor_ptr) 
c2c6 16 64				ld d, 100 
c2c8 0e 00				ld c, 0 
c2ca 1e 28				ld e, 40 
c2cc cd c1 8b				call input_str 
c2cf					; TODO perhaps do a type check and wrap in quotes if not a number 
c2cf 21 d5 e5				ld hl, os_input 
c2d2					if DEBUG_FORTH_WORDS 
c2d2						DMARK "AC1" 
c2d2 f5				push af  
c2d3 3a e7 c2			ld a, (.dmark)  
c2d6 32 71 ee			ld (debug_mark),a  
c2d9 3a e8 c2			ld a, (.dmark+1)  
c2dc 32 72 ee			ld (debug_mark+1),a  
c2df 3a e9 c2			ld a, (.dmark+2)  
c2e2 32 73 ee			ld (debug_mark+2),a  
c2e5 18 03			jr .pastdmark  
c2e7 ..			.dmark: db "AC1"  
c2ea f1			.pastdmark: pop af  
c2eb			endm  
# End of macro DMARK
c2eb						CALLMONITOR 
c2eb cd 95 93			call break_point_state  
c2ee				endm  
# End of macro CALLMONITOR
c2ee					endif 
c2ee cd 6e 9a				call forth_push_str 
c2f1					NEXTW 
c2f1 c3 69 9d			jp macro_next 
c2f4				endm 
# End of macro NEXTW
c2f4			 
c2f4			.EDIT: 
c2f4				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c2f4 40				db WORD_SYS_CORE+44             
c2f5 96 c3			dw .ENDKEY            
c2f7 05				db 4 + 1 
c2f8 .. 00			db "EDIT",0              
c2fd				endm 
# End of macro CWHEAD
c2fd			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c2fd			 
c2fd					; TODO does not copy from stack 
c2fd					if DEBUG_FORTH_WORDS_KEY 
c2fd						DMARK "EDT" 
c2fd f5				push af  
c2fe 3a 12 c3			ld a, (.dmark)  
c301 32 71 ee			ld (debug_mark),a  
c304 3a 13 c3			ld a, (.dmark+1)  
c307 32 72 ee			ld (debug_mark+1),a  
c30a 3a 14 c3			ld a, (.dmark+2)  
c30d 32 73 ee			ld (debug_mark+2),a  
c310 18 03			jr .pastdmark  
c312 ..			.dmark: db "EDT"  
c315 f1			.pastdmark: pop af  
c316			endm  
# End of macro DMARK
c316						CALLMONITOR 
c316 cd 95 93			call break_point_state  
c319				endm  
# End of macro CALLMONITOR
c319					endif 
c319			 
c319					;FORTH_DSP 
c319					FORTH_DSP_VALUEHL 
c319 cd f7 9b			call macro_dsp_valuehl 
c31c				endm 
# End of macro FORTH_DSP_VALUEHL
c31c			;		inc hl    ; TODO do type check 
c31c			 
c31c			;		call get_word_hl 
c31c e5					push hl 
c31d					if DEBUG_FORTH_WORDS 
c31d						DMARK "EDp" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 71 ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 72 ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 73 ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "EDp"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336						CALLMONITOR 
c336 cd 95 93			call break_point_state  
c339				endm  
# End of macro CALLMONITOR
c339					endif 
c339				;	ld a, 0 
c339 cd f2 8f				call strlenz 
c33c 23					inc hl 
c33d			 
c33d 06 00				ld b, 0 
c33f 4d					ld c, l 
c340			 
c340 e1					pop hl 
c341 11 d5 e5				ld de, os_input 
c344					if DEBUG_FORTH_WORDS_KEY 
c344						DMARK "EDc" 
c344 f5				push af  
c345 3a 59 c3			ld a, (.dmark)  
c348 32 71 ee			ld (debug_mark),a  
c34b 3a 5a c3			ld a, (.dmark+1)  
c34e 32 72 ee			ld (debug_mark+1),a  
c351 3a 5b c3			ld a, (.dmark+2)  
c354 32 73 ee			ld (debug_mark+2),a  
c357 18 03			jr .pastdmark  
c359 ..			.dmark: db "EDc"  
c35c f1			.pastdmark: pop af  
c35d			endm  
# End of macro DMARK
c35d						CALLMONITOR 
c35d cd 95 93			call break_point_state  
c360				endm  
# End of macro CALLMONITOR
c360					endif 
c360 ed b0				ldir 
c362			 
c362			 
c362 21 d5 e5				ld hl, os_input 
c365					;ld a, 0 
c365					;ld (hl),a 
c365 3a 40 eb				ld a,(f_cursor_ptr) 
c368 16 64				ld d, 100 
c36a 0e 00				ld c, 0 
c36c 1e 28				ld e, 40 
c36e cd c1 8b				call input_str 
c371					; TODO perhaps do a type check and wrap in quotes if not a number 
c371 21 d5 e5				ld hl, os_input 
c374					if DEBUG_FORTH_WORDS 
c374						DMARK "ED1" 
c374 f5				push af  
c375 3a 89 c3			ld a, (.dmark)  
c378 32 71 ee			ld (debug_mark),a  
c37b 3a 8a c3			ld a, (.dmark+1)  
c37e 32 72 ee			ld (debug_mark+1),a  
c381 3a 8b c3			ld a, (.dmark+2)  
c384 32 73 ee			ld (debug_mark+2),a  
c387 18 03			jr .pastdmark  
c389 ..			.dmark: db "ED1"  
c38c f1			.pastdmark: pop af  
c38d			endm  
# End of macro DMARK
c38d						CALLMONITOR 
c38d cd 95 93			call break_point_state  
c390				endm  
# End of macro CALLMONITOR
c390					endif 
c390 cd 6e 9a				call forth_push_str 
c393					NEXTW 
c393 c3 69 9d			jp macro_next 
c396				endm 
# End of macro NEXTW
c396			 
c396			 
c396			 
c396			.ENDKEY: 
c396			; eof 
c396			 
# End of file forth_words_key.asm
c396			 
c396			if STORAGE_SE 
c396			   	include "forth_words_storage.asm" 
c396			endif 
c396				include "forth_words_device.asm" 
c396			; Device related words 
c396			 
c396			; | ## Device Words 
c396			 
c396			if SOUND_ENABLE 
c396			.NOTE: 
c396				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c396			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c396					if DEBUG_FORTH_WORDS_KEY 
c396						DMARK "NTE" 
c396						CALLMONITOR 
c396					endif 
c396			 
c396				 
c396			 
c396					NEXTW 
c396			.AFTERSOUND: 
c396			endif 
c396			 
c396			 
c396			USE_GPIO: equ 0 
c396			 
c396			if USE_GPIO 
c396			.GP1: 
c396				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c396			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c396					NEXTW 
c396			.GP2: 
c396				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c396			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c396			 
c396					NEXTW 
c396			 
c396			.GP3: 
c396				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c396			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c396			 
c396					NEXTW 
c396			 
c396			.GP4: 
c396				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c396			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c396			 
c396					NEXTW 
c396			.SIN: 
c396			 
c396			 
c396			endif 
c396			 
c396			 
c396				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c396 33				db WORD_SYS_CORE+31             
c397 cb c3			dw .SOUT            
c399 03				db 2 + 1 
c39a .. 00			db "IN",0              
c39d				endm 
# End of macro CWHEAD
c39d			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c39d					if DEBUG_FORTH_WORDS_KEY 
c39d						DMARK "IN." 
c39d f5				push af  
c39e 3a b2 c3			ld a, (.dmark)  
c3a1 32 71 ee			ld (debug_mark),a  
c3a4 3a b3 c3			ld a, (.dmark+1)  
c3a7 32 72 ee			ld (debug_mark+1),a  
c3aa 3a b4 c3			ld a, (.dmark+2)  
c3ad 32 73 ee			ld (debug_mark+2),a  
c3b0 18 03			jr .pastdmark  
c3b2 ..			.dmark: db "IN."  
c3b5 f1			.pastdmark: pop af  
c3b6			endm  
# End of macro DMARK
c3b6						CALLMONITOR 
c3b6 cd 95 93			call break_point_state  
c3b9				endm  
# End of macro CALLMONITOR
c3b9					endif 
c3b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3b9 cd f7 9b			call macro_dsp_valuehl 
c3bc				endm 
# End of macro FORTH_DSP_VALUEHL
c3bc			 
c3bc e5					push hl 
c3bd			 
c3bd					; destroy value TOS 
c3bd			 
c3bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3bd cd af 9c			call macro_forth_dsp_pop 
c3c0				endm 
# End of macro FORTH_DSP_POP
c3c0			 
c3c0					; one value on hl get other one back 
c3c0			 
c3c0 c1					pop bc 
c3c1			 
c3c1					; do the sub 
c3c1			;		ex de, hl 
c3c1			 
c3c1 ed 68				in l,(c) 
c3c3			 
c3c3					; save it 
c3c3			 
c3c3 26 00				ld h,0 
c3c5			 
c3c5					; TODO push value back onto stack for another op etc 
c3c5			 
c3c5 cd 00 9a				call forth_push_numhl 
c3c8					NEXTW 
c3c8 c3 69 9d			jp macro_next 
c3cb				endm 
# End of macro NEXTW
c3cb			.SOUT: 
c3cb				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c3cb 34				db WORD_SYS_CORE+32             
c3cc 1e c4			dw .SPIO            
c3ce 04				db 3 + 1 
c3cf .. 00			db "OUT",0              
c3d3				endm 
# End of macro CWHEAD
c3d3			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c3d3					if DEBUG_FORTH_WORDS_KEY 
c3d3						DMARK "OUT" 
c3d3 f5				push af  
c3d4 3a e8 c3			ld a, (.dmark)  
c3d7 32 71 ee			ld (debug_mark),a  
c3da 3a e9 c3			ld a, (.dmark+1)  
c3dd 32 72 ee			ld (debug_mark+1),a  
c3e0 3a ea c3			ld a, (.dmark+2)  
c3e3 32 73 ee			ld (debug_mark+2),a  
c3e6 18 03			jr .pastdmark  
c3e8 ..			.dmark: db "OUT"  
c3eb f1			.pastdmark: pop af  
c3ec			endm  
# End of macro DMARK
c3ec						CALLMONITOR 
c3ec cd 95 93			call break_point_state  
c3ef				endm  
# End of macro CALLMONITOR
c3ef					endif 
c3ef			 
c3ef					; get port 
c3ef			 
c3ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3ef cd f7 9b			call macro_dsp_valuehl 
c3f2				endm 
# End of macro FORTH_DSP_VALUEHL
c3f2			 
c3f2 e5					push hl 
c3f3			 
c3f3					; destroy value TOS 
c3f3			 
c3f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f3 cd af 9c			call macro_forth_dsp_pop 
c3f6				endm 
# End of macro FORTH_DSP_POP
c3f6			 
c3f6					; get byte to send 
c3f6			 
c3f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3f6 cd f7 9b			call macro_dsp_valuehl 
c3f9				endm 
# End of macro FORTH_DSP_VALUEHL
c3f9			 
c3f9			;		push hl 
c3f9			 
c3f9					; destroy value TOS 
c3f9			 
c3f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f9 cd af 9c			call macro_forth_dsp_pop 
c3fc				endm 
# End of macro FORTH_DSP_POP
c3fc			 
c3fc					; one value on hl get other one back 
c3fc			 
c3fc			;		pop hl 
c3fc			 
c3fc c1					pop bc 
c3fd			 
c3fd					if DEBUG_FORTH_WORDS 
c3fd						DMARK "OUT" 
c3fd f5				push af  
c3fe 3a 12 c4			ld a, (.dmark)  
c401 32 71 ee			ld (debug_mark),a  
c404 3a 13 c4			ld a, (.dmark+1)  
c407 32 72 ee			ld (debug_mark+1),a  
c40a 3a 14 c4			ld a, (.dmark+2)  
c40d 32 73 ee			ld (debug_mark+2),a  
c410 18 03			jr .pastdmark  
c412 ..			.dmark: db "OUT"  
c415 f1			.pastdmark: pop af  
c416			endm  
# End of macro DMARK
c416						CALLMONITOR 
c416 cd 95 93			call break_point_state  
c419				endm  
# End of macro CALLMONITOR
c419					endif 
c419			 
c419 ed 69				out (c), l 
c41b			 
c41b					NEXTW 
c41b c3 69 9d			jp macro_next 
c41e				endm 
# End of macro NEXTW
c41e			 
c41e			 
c41e			.SPIO: 
c41e			 
c41e			if STORAGE_SE 
c41e				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c41e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c41e			 
c41e					call spi_ce_low 
c41e			    NEXTW 
c41e			 
c41e			.SPICEH: 
c41e				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c41e			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c41e			 
c41e					call spi_ce_high 
c41e			    NEXTW 
c41e			 
c41e			 
c41e			.SPIOb: 
c41e			 
c41e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c41e			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c41e			 
c41e					; get port 
c41e			 
c41e			 
c41e					; get byte to send 
c41e			 
c41e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c41e			 
c41e			;		push hl    ; u1  
c41e			 
c41e					; destroy value TOS 
c41e			 
c41e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c41e			 
c41e					; one value on hl get other one back 
c41e			 
c41e			;		pop hl   ; u2 - addr 
c41e			 
c41e					; TODO Send SPI byte 
c41e			 
c41e					ld a, l 
c41e					call spi_send_byte 
c41e			 
c41e					NEXTW 
c41e			 
c41e			.SPII: 
c41e				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c41e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c41e			 
c41e					; TODO Get SPI byte 
c41e			 
c41e					call spi_read_byte 
c41e			 
c41e					ld h, 0 
c41e					ld l, a 
c41e					call forth_push_numhl 
c41e			 
c41e					NEXTW 
c41e			 
c41e			 
c41e			 
c41e			.SESEL: 
c41e				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c41e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c41e					if DEBUG_FORTH_WORDS_KEY 
c41e						DMARK "BNK" 
c41e						CALLMONITOR 
c41e					endif 
c41e			 
c41e					ld a, 255 
c41e					ld (spi_cartdev), a 
c41e			 
c41e					; get bank 
c41e			 
c41e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c41e			 
c41e			;		push hl 
c41e			 
c41e					; destroy value TOS 
c41e			 
c41e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c41e			 
c41e					; one value on hl get other one back 
c41e			 
c41e			;		pop hl 
c41e			 
c41e			 
c41e					ld c, SPI_CE_HIGH 
c41e					ld b, '0'    ; human readable bank number 
c41e			 
c41e					ld a, l 
c41e			 
c41e					if DEBUG_FORTH_WORDS 
c41e						DMARK "BNK" 
c41e						CALLMONITOR 
c41e					endif 
c41e			 
c41e					; active low 
c41e			 
c41e					cp 0 
c41e					jr z, .bset 
c41e					cp 1 
c41e					jr nz, .b2 
c41e					res 0, c 
c41e					ld b, '1'    ; human readable bank number 
c41e			.b2:		cp 2 
c41e					jr nz, .b3 
c41e					res 1, c 
c41e					ld b, '2'    ; human readable bank number 
c41e			.b3:		cp 3 
c41e					jr nz, .b4 
c41e					res 2, c 
c41e					ld b, '3'    ; human readable bank number 
c41e			.b4:		cp 4 
c41e					jr nz, .b5 
c41e					res 3, c 
c41e					ld b, '4'    ; human readable bank number 
c41e			.b5:		cp 5 
c41e					jr nz, .bset 
c41e					res 4, c 
c41e					ld b, '5'    ; human readable bank number 
c41e			 
c41e			.bset: 
c41e					ld a, c 
c41e					ld (spi_device),a 
c41e					ld a, b 
c41e					ld (spi_device_id),a 
c41e					if DEBUG_FORTH_WORDS 
c41e						DMARK "BN2" 
c41e						CALLMONITOR 
c41e					endif 
c41e			 
c41e					NEXTW 
c41e			 
c41e			.CARTDEV: 
c41e				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c41e			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c41e					if DEBUG_FORTH_WORDS_KEY 
c41e						DMARK "CDV" 
c41e						CALLMONITOR 
c41e					endif 
c41e			 
c41e					; disable se storage bank selection 
c41e			 
c41e					ld a, SPI_CE_HIGH		; ce high 
c41e					ld (spi_device), a 
c41e			 
c41e					; get bank 
c41e			 
c41e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c41e			 
c41e			;		push hl 
c41e			 
c41e					; destroy value TOS 
c41e			 
c41e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c41e			 
c41e					; one value on hl get other one back 
c41e			 
c41e			;		pop hl 
c41e			 
c41e					; active low 
c41e			 
c41e					ld c, 255 
c41e			 
c41e					ld a, l 
c41e					if DEBUG_FORTH_WORDS 
c41e						DMARK "CDV" 
c41e						CALLMONITOR 
c41e					endif 
c41e					cp 0 
c41e					jr z, .cset 
c41e					cp 1 
c41e					jr nz, .c2 
c41e					res 0, c 
c41e			.c2:		cp 2 
c41e					jr nz, .c3 
c41e					res 1, c 
c41e			.c3:		cp 3 
c41e					jr nz, .c4 
c41e					res 2, c 
c41e			.c4:		cp 4 
c41e					jr nz, .c5 
c41e					res 3, c 
c41e			.c5:		cp 5 
c41e					jr nz, .c6 
c41e					res 4, c 
c41e			.c6:		cp 6 
c41e					jr nz, .c7 
c41e					res 5, c 
c41e			.c7:		cp 7 
c41e					jr nz, .c8 
c41e					res 6, c 
c41e			.c8:		cp 8 
c41e					jr nz, .cset 
c41e					res 7, c 
c41e			.cset:		ld a, c 
c41e					ld (spi_cartdev),a 
c41e			 
c41e					if DEBUG_FORTH_WORDS 
c41e						DMARK "CD2" 
c41e						CALLMONITOR 
c41e					endif 
c41e					NEXTW 
c41e			endif 
c41e			 
c41e			.ENDDEVICE: 
c41e			; eof 
c41e			 
# End of file forth_words_device.asm
c41e			 
c41e			; var handler 
c41e			 
c41e			 
c41e			.VARS: 
c41e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c41e 78				db WORD_SYS_CORE+100             
c41f 36 c4			dw .V0Q            
c421 04				db 3 + 1 
c422 .. 00			db "V0!",0              
c426				endm 
# End of macro CWHEAD
c426			;| V0! ( u1 -- )  Store value to v0  | DONE 
c426			 
c426					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c426 cd f7 9b			call macro_dsp_valuehl 
c429				endm 
# End of macro FORTH_DSP_VALUEHL
c429			 
c429 11 0a eb				ld de, cli_var_array 
c42c			 
c42c eb					ex de, hl 
c42d 73					ld (hl), e 
c42e 23					inc hl 
c42f 72					ld (hl), d 
c430			 
c430					; destroy value TOS 
c430			 
c430					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c430 cd af 9c			call macro_forth_dsp_pop 
c433				endm 
# End of macro FORTH_DSP_POP
c433			 
c433				       NEXTW 
c433 c3 69 9d			jp macro_next 
c436				endm 
# End of macro NEXTW
c436			.V0Q: 
c436				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c436 79				db WORD_SYS_CORE+101             
c437 47 c4			dw .V1S            
c439 04				db 3 + 1 
c43a .. 00			db "V0@",0              
c43e				endm 
# End of macro CWHEAD
c43e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c43e 2a 0a eb				ld hl, (cli_var_array) 
c441 cd 00 9a				call forth_push_numhl 
c444			 
c444				       NEXTW 
c444 c3 69 9d			jp macro_next 
c447				endm 
# End of macro NEXTW
c447			.V1S: 
c447				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c447 7a				db WORD_SYS_CORE+102             
c448 5f c4			dw .V1Q            
c44a 04				db 3 + 1 
c44b .. 00			db "V1!",0              
c44f				endm 
# End of macro CWHEAD
c44f			;| V1! ( u1 -- )  Store value to v1 | DONE 
c44f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c44f cd f7 9b			call macro_dsp_valuehl 
c452				endm 
# End of macro FORTH_DSP_VALUEHL
c452			 
c452 11 0c eb				ld de, cli_var_array+2 
c455				 
c455 eb					ex de, hl 
c456 73					ld (hl), e 
c457 23					inc hl 
c458 72					ld (hl), d 
c459			 
c459					; destroy value TOS 
c459			 
c459					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c459 cd af 9c			call macro_forth_dsp_pop 
c45c				endm 
# End of macro FORTH_DSP_POP
c45c				       NEXTW 
c45c c3 69 9d			jp macro_next 
c45f				endm 
# End of macro NEXTW
c45f			.V1Q: 
c45f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c45f 7b				db WORD_SYS_CORE+103             
c460 70 c4			dw .V2S            
c462 04				db 3 + 1 
c463 .. 00			db "V1@",0              
c467				endm 
# End of macro CWHEAD
c467			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c467 2a 0c eb				ld hl, (cli_var_array+2) 
c46a cd 00 9a				call forth_push_numhl 
c46d				       NEXTW 
c46d c3 69 9d			jp macro_next 
c470				endm 
# End of macro NEXTW
c470			.V2S: 
c470				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c470 7c				db WORD_SYS_CORE+104             
c471 88 c4			dw .V2Q            
c473 04				db 3 + 1 
c474 .. 00			db "V2!",0              
c478				endm 
# End of macro CWHEAD
c478			;| V2! ( u1 -- )  Store value to v2 | DONE 
c478					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c478 cd f7 9b			call macro_dsp_valuehl 
c47b				endm 
# End of macro FORTH_DSP_VALUEHL
c47b			 
c47b 11 0e eb				ld de, cli_var_array+4 
c47e				 
c47e eb					ex de, hl 
c47f 73					ld (hl), e 
c480 23					inc hl 
c481 72					ld (hl), d 
c482			 
c482					; destroy value TOS 
c482			 
c482					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c482 cd af 9c			call macro_forth_dsp_pop 
c485				endm 
# End of macro FORTH_DSP_POP
c485				       NEXTW 
c485 c3 69 9d			jp macro_next 
c488				endm 
# End of macro NEXTW
c488			.V2Q: 
c488				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c488 7d				db WORD_SYS_CORE+105             
c489 99 c4			dw .V3S            
c48b 04				db 3 + 1 
c48c .. 00			db "V2@",0              
c490				endm 
# End of macro CWHEAD
c490			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c490 2a 0e eb				ld hl, (cli_var_array+4) 
c493 cd 00 9a				call forth_push_numhl 
c496				       NEXTW 
c496 c3 69 9d			jp macro_next 
c499				endm 
# End of macro NEXTW
c499			.V3S: 
c499				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c499 7c				db WORD_SYS_CORE+104             
c49a b1 c4			dw .V3Q            
c49c 04				db 3 + 1 
c49d .. 00			db "V3!",0              
c4a1				endm 
# End of macro CWHEAD
c4a1			;| V3! ( u1 -- )  Store value to v3 | DONE 
c4a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c4a1 cd f7 9b			call macro_dsp_valuehl 
c4a4				endm 
# End of macro FORTH_DSP_VALUEHL
c4a4			 
c4a4 11 10 eb				ld de, cli_var_array+6 
c4a7				 
c4a7 eb					ex de, hl 
c4a8 73					ld (hl), e 
c4a9 23					inc hl 
c4aa 72					ld (hl), d 
c4ab			 
c4ab					; destroy value TOS 
c4ab			 
c4ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c4ab cd af 9c			call macro_forth_dsp_pop 
c4ae				endm 
# End of macro FORTH_DSP_POP
c4ae				       NEXTW 
c4ae c3 69 9d			jp macro_next 
c4b1				endm 
# End of macro NEXTW
c4b1			.V3Q: 
c4b1				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c4b1 7d				db WORD_SYS_CORE+105             
c4b2 c2 c4			dw .END            
c4b4 04				db 3 + 1 
c4b5 .. 00			db "V3@",0              
c4b9				endm 
# End of macro CWHEAD
c4b9			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c4b9 2a 10 eb				ld hl, (cli_var_array+6) 
c4bc cd 00 9a				call forth_push_numhl 
c4bf				       NEXTW 
c4bf c3 69 9d			jp macro_next 
c4c2				endm 
# End of macro NEXTW
c4c2			 
c4c2			 
c4c2			 
c4c2			 
c4c2			 
c4c2			; end of dict marker 
c4c2			 
c4c2 00			.END:    db WORD_SYS_END 
c4c3 00 00			dw 0 
c4c5 00				db 0 
c4c6			 
c4c6			; use to jp here for user dict words to save on macro expansion  
c4c6			 
c4c6			user_dict_next: 
c4c6				NEXTW 
c4c6 c3 69 9d			jp macro_next 
c4c9				endm 
# End of macro NEXTW
c4c9			 
c4c9			 
c4c9			user_exec: 
c4c9				;    ld hl, <word code> 
c4c9				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c4c9				;    call forthexec 
c4c9				;    jp user_dict_next   (NEXT) 
c4c9			        ;    <word code bytes> 
c4c9 eb				ex de, hl 
c4ca 2a d8 e6			ld hl,(os_tok_ptr) 
c4cd				 
c4cd				FORTH_RSP_NEXT 
c4cd cd a7 99			call macro_forth_rsp_next 
c4d0				endm 
# End of macro FORTH_RSP_NEXT
c4d0			 
c4d0			if DEBUG_FORTH_UWORD 
c4d0						DMARK "UEX" 
c4d0 f5				push af  
c4d1 3a e5 c4			ld a, (.dmark)  
c4d4 32 71 ee			ld (debug_mark),a  
c4d7 3a e6 c4			ld a, (.dmark+1)  
c4da 32 72 ee			ld (debug_mark+1),a  
c4dd 3a e7 c4			ld a, (.dmark+2)  
c4e0 32 73 ee			ld (debug_mark+2),a  
c4e3 18 03			jr .pastdmark  
c4e5 ..			.dmark: db "UEX"  
c4e8 f1			.pastdmark: pop af  
c4e9			endm  
# End of macro DMARK
c4e9				CALLMONITOR 
c4e9 cd 95 93			call break_point_state  
c4ec				endm  
# End of macro CALLMONITOR
c4ec			endif 
c4ec			 
c4ec			 
c4ec			 
c4ec eb				ex de, hl 
c4ed 22 d8 e6			ld (os_tok_ptr), hl 
c4f0				 
c4f0				; Don't use next - Skips the first word in uword. 
c4f0			 
c4f0 c3 fa 9d			jp exec1 
c4f3			;	NEXT 
c4f3			 
c4f3			 
c4f3			; eof 
# End of file forth_wordsv4.asm
c4f3			endif 
c4f3			;;;;;;;;;;;;;; Debug code 
c4f3			 
c4f3			 
c4f3			;if DEBUG_FORTH_PARSE 
c4f3 .. 00		.nowordfound: db "No match",0 
c4fc .. 00		.compword:	db "Comparing word ",0 
c50c .. 00		.nextwordat:	db "Next word at",0 
c519 .. 00		.charmatch:	db "Char match",0 
c524			;endif 
c524			if DEBUG_FORTH_JP 
c524			.foundword:	db "Word match. Exec..",0 
c524			endif 
c524			;if DEBUG_FORTH_PUSH 
c524 .. 00		.enddict:	db "Dict end. Push.",0 
c534 .. 00		.push_str:	db "Pushing string",0 
c543 .. 00		.push_num:	db "Pushing number",0 
c552 .. 00		.data_sp:	db "SP:",0 
c556 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c568 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c57a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c58c			;endif 
c58c			;if DEBUG_FORTH_MALLOC 
c58c .. 00		.push_malloc:	db "Malloc address",0 
c59b			;endif 
c59b			 
c59b			 
c59b			 
c59b			; display malloc address and current data stack pointer  
c59b			 
c59b			malloc_error: 
c59b d5				push de 
c59c f5				push af 
c59d e5				push hl 
c59e cd 67 89			call clear_display 
c5a1 11 c3 c5			ld de, .mallocerr 
c5a4 3e 00			ld a,0 
c5a6			;	ld de,os_word_scratch 
c5a6 cd 7a 89			call str_at_display 
c5a9 3e 11			ld a, display_row_1+17 
c5ab 11 71 ee			ld de, debug_mark 
c5ae cd 7a 89			call str_at_display 
c5b1 cd 8a 89			call update_display 
c5b4				;call break_point_state 
c5b4 cd 00 d9			call cin_wait 
c5b7			 
c5b7 3e 20			ld a, ' ' 
c5b9 32 c8 e3			ld (os_view_disable), a 
c5bc e1				pop hl 
c5bd f1				pop af 
c5be d1				pop de	 
c5bf				CALLMONITOR 
c5bf cd 95 93			call break_point_state  
c5c2				endm  
# End of macro CALLMONITOR
c5c2 c9				ret 
c5c3			 
c5c3 .. 00		.mallocerr: 	db "Malloc Error",0 
c5d0			;if DEBUG_FORTH_PUSH 
c5d0			display_data_sp: 
c5d0 f5				push af 
c5d1			 
c5d1				; see if disabled 
c5d1			 
c5d1 3a c8 e3			ld a, (os_view_disable) 
c5d4 fe 2a			cp '*' 
c5d6 28 67			jr z, .skipdsp 
c5d8			 
c5d8 e5				push hl 
c5d9 e5				push hl 
c5da e5			push hl 
c5db cd 67 89			call clear_display 
c5de e1			pop hl 
c5df 7c				ld a,h 
c5e0 21 dc e6			ld hl, os_word_scratch 
c5e3 cd 95 8e			call hexout 
c5e6 e1				pop hl 
c5e7 7d				ld a,l 
c5e8 21 de e6			ld hl, os_word_scratch+2 
c5eb cd 95 8e			call hexout 
c5ee 21 e0 e6			ld hl, os_word_scratch+4 
c5f1 3e 00			ld a,0 
c5f3 77				ld (hl),a 
c5f4 11 dc e6			ld de,os_word_scratch 
c5f7 3e 28				ld a, display_row_2 
c5f9 cd 7a 89				call str_at_display 
c5fc 11 56 c5			ld de, .wordinhl 
c5ff 3e 00			ld a, display_row_1 
c601			 
c601 cd 7a 89				call str_at_display 
c604 11 71 ee			ld de, debug_mark 
c607 3e 11			ld a, display_row_1+17 
c609			 
c609 cd 7a 89				call str_at_display 
c60c			 
c60c				; display current data stack pointer 
c60c 11 52 c5			ld de,.data_sp 
c60f 3e 30				ld a, display_row_2 + 8 
c611 cd 7a 89				call str_at_display 
c614			 
c614 2a 04 eb			ld hl,(cli_data_sp) 
c617 e5				push hl 
c618 7c				ld a,h 
c619 21 dc e6			ld hl, os_word_scratch 
c61c cd 95 8e			call hexout 
c61f e1				pop hl 
c620 7d				ld a,l 
c621 21 de e6			ld hl, os_word_scratch+2 
c624 cd 95 8e			call hexout 
c627 21 e0 e6			ld hl, os_word_scratch+4 
c62a 3e 00			ld a,0 
c62c 77				ld (hl),a 
c62d 11 dc e6			ld de,os_word_scratch 
c630 3e 33				ld a, display_row_2 + 11 
c632 cd 7a 89				call str_at_display 
c635			 
c635			 
c635 cd 8a 89			call update_display 
c638 cd e4 88			call delay1s 
c63b cd e4 88			call delay1s 
c63e e1				pop hl 
c63f			.skipdsp: 
c63f f1				pop af 
c640 c9				ret 
c641			 
c641			display_data_malloc: 
c641			 
c641 f5				push af 
c642 e5				push hl 
c643 e5				push hl 
c644 e5			push hl 
c645 cd 67 89			call clear_display 
c648 e1			pop hl 
c649 7c				ld a,h 
c64a 21 dc e6			ld hl, os_word_scratch 
c64d cd 95 8e			call hexout 
c650 e1				pop hl 
c651 7d				ld a,l 
c652 21 de e6			ld hl, os_word_scratch+2 
c655 cd 95 8e			call hexout 
c658 21 e0 e6			ld hl, os_word_scratch+4 
c65b 3e 00			ld a,0 
c65d 77				ld (hl),a 
c65e 11 dc e6			ld de,os_word_scratch 
c661 3e 28				ld a, display_row_2 
c663 cd 7a 89				call str_at_display 
c666 11 8c c5			ld de, .push_malloc 
c669 3e 00			ld a, display_row_1 
c66b			 
c66b cd 7a 89				call str_at_display 
c66e			 
c66e				; display current data stack pointer 
c66e 11 52 c5			ld de,.data_sp 
c671 3e 30				ld a, display_row_2 + 8 
c673 cd 7a 89				call str_at_display 
c676			 
c676 2a 04 eb			ld hl,(cli_data_sp) 
c679 e5				push hl 
c67a 7c				ld a,h 
c67b 21 dc e6			ld hl, os_word_scratch 
c67e cd 95 8e			call hexout 
c681 e1				pop hl 
c682 7d				ld a,l 
c683 21 de e6			ld hl, os_word_scratch+2 
c686 cd 95 8e			call hexout 
c689 21 e0 e6			ld hl, os_word_scratch+4 
c68c 3e 00			ld a,0 
c68e 77				ld (hl),a 
c68f 11 dc e6			ld de,os_word_scratch 
c692 3e 33				ld a, display_row_2 + 11 
c694 cd 7a 89				call str_at_display 
c697			 
c697 cd 8a 89			call update_display 
c69a cd e4 88			call delay1s 
c69d cd e4 88			call delay1s 
c6a0 e1				pop hl 
c6a1 f1				pop af 
c6a2 c9				ret 
c6a3			;endif 
c6a3			 
c6a3			include "forth_autostart.asm" 
c6a3			; list of commands to perform at system start up 
c6a3			 
c6a3			startcmds: 
c6a3			;	dw test11 
c6a3			;	dw test12 
c6a3			;	dw test13 
c6a3			;	dw test14 
c6a3			;	dw test15 
c6a3			;	dw test16 
c6a3			;	dw test17 
c6a3			;	dw ifthtest1 
c6a3			;	dw ifthtest2 
c6a3			;	dw ifthtest3 
c6a3			;	dw mmtest1 
c6a3			;	dw mmtest2 
c6a3			;	dw mmtest3 
c6a3			;	dw mmtest4 
c6a3			;	dw mmtest5 
c6a3			;	dw mmtest6 
c6a3			;	dw iftest1 
c6a3			;	dw iftest2 
c6a3			;	dw iftest3 
c6a3			;	dw looptest1 
c6a3			;	dw looptest2 
c6a3			;	dw test1 
c6a3			;	dw test2 
c6a3			;	dw test3 
c6a3			;	dw test4 
c6a3			;	dw game2r 
c6a3			;	dw game2b1 
c6a3			;	dw game2b2 
c6a3			 
c6a3				; start up words that are actually useful 
c6a3			 
c6a3 01 c7			dw clrstack 
c6a5 34 c7			dw type 
c6a7 24 c9			dw stest 
c6a9 58 c7			dw strncpy 
c6ab ba c8			dw list 
c6ad b9 c7			dw start1 
c6af cb c7			dw start2 
c6b1			;	dw start3 
c6b1 de c7			dw start3b 
c6b3 5a c8			dw start3c 
c6b5			 
c6b5				; (unit) testing words 
c6b5			 
c6b5 9b c9			dw mtesta 
c6b7 50 ca			dw mtestb 
c6b9 f3 ca			dw mtestc 
c6bb a8 cb			dw mtestd 
c6bd 4c cc			dw mteste 
c6bf			 
c6bf				; demo/game words 
c6bf			 
c6bf 58 d3		        dw game3w 
c6c1 86 d3		        dw game3p 
c6c3 a4 d3		        dw game3sc 
c6c5 d5 d3		        dw game3vsi 
c6c7 01 d4		        dw game3vs 
c6c9				 
c6c9 4b d1			dw game2b 
c6cb b9 d1			dw game2bf 
c6cd 03 d2			dw game2mba 
c6cf 99 d2			dw game2mbas 
c6d1 db d2			dw game2mb 
c6d3			 
c6d3 0c ce			dw game1 
c6d5 1d ce			dw game1a 
c6d7 7f ce			dw game1b 
c6d9 b4 ce			dw game1c 
c6db ea ce			dw game1d 
c6dd 1b cf			dw game1s 
c6df 2f cf			dw game1t 
c6e1 44 cf			dw game1f 
c6e3 78 cf			dw game1z 
c6e5 bc cf			dw game1zz 
c6e7			 
c6e7 02 cd			dw test5 
c6e9 3a cd			dw test6 
c6eb 72 cd			dw test7 
c6ed 86 cd			dw test8 
c6ef b2 cd			dw test9 
c6f1 c8 cd			dw test10 
c6f3				 
c6f3 93 d0		        dw ssv5 
c6f5 77 d0		        dw ssv4 
c6f7 5b d0		        dw ssv3 
c6f9 25 d0		        dw ssv2 
c6fb ac d0		        dw ssv1 
c6fd f4 d0		        dw ssv1cpm 
c6ff			;	dw keyup 
c6ff			;	dw keydown 
c6ff			;	dw keyleft 
c6ff			;	dw keyright 
c6ff			;	dw 	keyf1 
c6ff			;	dw keyf2 
c6ff			;	dw keyf3 
c6ff			;	dw keyf4 
c6ff			;	dw keyf5 
c6ff			;	dw keyf6 
c6ff			;	dw keyf7 
c6ff			;	dw keyf8 
c6ff			;	dw keyf9 
c6ff			;	dw keyf10 
c6ff			;	dw keyf11 
c6ff			;	dw keyf12 
c6ff			;	dw keytab 
c6ff			;	dw keycr 
c6ff			;	dw keyhome 
c6ff			;	dw keyend 
c6ff			;	dw keybs 
c6ff 00 00			db 0, 0	 
c701			 
c701			 
c701			; clear stack  
c701			 
c701 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c734			 
c734			; type ( addr count - ) 
c734 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c758			 
c758			; some direct memory words 
c758			; strncpy ( len t f -- t ) 
c758			 
c758 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c7b9			 
c7b9 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c7cb .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c7de .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
c85a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c8ba			 
c8ba			 
c8ba			; a handy word to list items on the stack 
c8ba			 
c8ba .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
c924			 
c924			 
c924			; test stack  
c924			; rnd8 stest 
c924			 
c924 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c99b			 
c99b			; random malloc and free cycles 
c99b			 
c99b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
ca50			 
ca50			; fixed malloc and free cycles 
ca50			 
ca50 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
caf3			 
caf3			; fixed double string push and drop cycle  
caf3			 
caf3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cba8			 
cba8			; consistent fixed string push and drop cycle  
cba8			 
cba8 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cc4c			 
cc4c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cd02			 
cd02			;test1:		db ": aa 1 2 3 ;", 0 
cd02			;test2:     	db "111 aa 888 999",0 
cd02			;test3:     	db ": bb 77 ;",0 
cd02			;test4:     	db "$02 $01 do i . loop bb",0 
cd02			 
cd02 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cd3a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cd72 .. 00		test7:     	db ": box hline vline ;",0 
cd86 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cdb2 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cdc8 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cded .. 00		test11:     	db "hello create .",0 
cdfc .. 00		test12:     	db "hello2 create .",0 
ce0c			 
ce0c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
ce0c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
ce0c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
ce0c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
ce0c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
ce0c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
ce0c			 
ce0c			;iftest1:     	db "$0001 IF cls .",0 
ce0c			;iftest2:     	db "$0000 IF cls .",0 
ce0c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
ce0c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
ce0c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
ce0c			 
ce0c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ce0c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ce0c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ce0c			 
ce0c			 
ce0c			 
ce0c			; a small guess the number game 
ce0c			 
ce0c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
ce1d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ce7f			 
ce7f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ceb4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ceea .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cf1b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cf2f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cf44 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cf78 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cfbc			 
cfbc			; Using 'ga' save a high score across multiple runs using external storage 
cfbc			 
cfbc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d025			 
d025			 
d025			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d025			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d025			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d025			 
d025			; simple screen saver to test code memory reuse to destruction 
d025			 
d025 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d05b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d077 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d093 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d0ac .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d0f4 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d14b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d14b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d14b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d14b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d14b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d14b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d14b			 
d14b			 
d14b			 
d14b			; minesweeper/battleship finding game 
d14b			; draws a game board of random ship/mine positions 
d14b			; user enters coords to see if it hits on 
d14b			; game ends when all are hit 
d14b			; when hit or miss says how many may be in the area 
d14b			 
d14b			; setup the game board and then hide it 
d14b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d1b9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d203			; prompt for where to target 
d203 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d299 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d2be			; TODO see if the entered coords hits or misses pushes char hit of miss 
d2be .. 00		game2mbht:      db ": mbckht nop ;",0 
d2cd .. 00		game2mbms:      db ": mbcms nop ;",0 
d2db			; TODO how many might be near by 
d2db .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d358			 
d358			; Game 3 
d358			 
d358			; Vert scroller ski game - avoid the trees! 
d358			 
d358			; v0 score (ie turns) 
d358			; v1 player pos 
d358			; v2 left wall 
d358			; v3 right wall 
d358			 
d358			; Draw side walls randomly 
d358			 
d358 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d386			 
d386			; Draw player 
d386 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d3a4			 
d3a4			; TODO Get Key 
d3a4			 
d3a4			; TODO Move left right 
d3a4			 
d3a4			; scroll and move walls a bit 
d3a4			 
d3a4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d3d5			 
d3d5			; main game loop 
d3d5			 
d3d5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d401 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d440			 
d440			; key board defs 
d440			 
d440 .. 00		keyup:       db ": keyup $05 ;",0 
d44e .. 00		keydown:       db ": keydown $0a ;",0 
d45e .. 00		keyleft:       db ": keyleft $0b ;",0 
d46e .. 00		keyright:       db ": keyright $0c ;",0 
d47f .. 00		keyf1:       db ": keyf1 $10 ;",0 
d48d .. 00		keyf2:       db ": keyf2 $11 ;",0 
d49b .. 00		keyf3:       db ": keyf3 $12 ;",0 
d4a9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d4b7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d4c5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d4d3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d4e1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d4ef .. 00		keyf9:       db ": keyf9 $18 ;",0 
d4fd .. 00		keyf10:       db ": keyf10 $19 ;",0 
d50c .. 00		keyf11:       db ": keyf11 $1a ;",0 
d51b .. 00		keyf12:       db ": keyf12 $1b ;",0 
d52a			 
d52a .. 00		keytab:       db ": keytab $09 ;",0 
d539 .. 00		keycr:       db ": keycr $0d ;",0 
d547 .. 00		keyhome:       db ": keyhome $0e ;",0 
d557 .. 00		keyend:       db ": keyend $0f ;",0 
d566 .. 00		keybs:       db ": keybs $08 ;",0 
d574			 
d574			   
d574			 
d574			 
d574			 
d574			; eof 
# End of file forth_autostart.asm
d574			 
d574 .. 00		sprompt1: db "Startup load...",0 
d584 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d59a			 
d59a			 
d59a			 
d59a			 
d59a			forth_startup: 
d59a 21 a3 c6			ld hl, startcmds 
d59d 3e 00			ld a, 0 
d59f 32 fd e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d5a2			 
d5a2 e5			.start1:	push hl 
d5a3 cd 67 89			call clear_display 
d5a6 11 74 d5			ld de, sprompt1 
d5a9 3e 00		        ld a, display_row_1 
d5ab cd 7a 89			call str_at_display 
d5ae 11 84 d5			ld de, sprompt2 
d5b1 3e 28		        ld a, display_row_2 
d5b3 cd 7a 89			call str_at_display 
d5b6 e1				pop hl 
d5b7 e5				push hl 
d5b8 5e				ld e,(hl) 
d5b9 23				inc hl 
d5ba 56				ld d,(hl) 
d5bb 3e 50		        ld a, display_row_3 
d5bd cd 7a 89			call str_at_display 
d5c0 cd 8a 89			call update_display 
d5c3			 
d5c3			 
d5c3 3a fd e7			ld a, (os_last_cmd) 
d5c6 fe 00			cp 0 
d5c8 28 05			jr z, .startprompt 
d5ca cd d8 88			call delay250ms 
d5cd 18 24			jr .startdo 
d5cf				 
d5cf				 
d5cf			 
d5cf			.startprompt: 
d5cf			 
d5cf 3e 9f			ld a,display_row_4 + display_cols - 1 
d5d1 11 76 99		        ld de, endprg 
d5d4 cd 7a 89			call str_at_display 
d5d7 cd 8a 89			call update_display 
d5da cd e4 88			call delay1s 
d5dd cd 00 d9			call cin_wait 
d5e0						 
d5e0 fe 2a			cp '*' 
d5e2 28 5e			jr z, .startupend1 
d5e4 fe 23			cp '#' 
d5e6 20 07			jr nz, .startno 
d5e8 3e 01			ld a, 1 
d5ea 32 fd e7			ld (os_last_cmd),a 
d5ed 18 04			jr .startdo 
d5ef fe 31		.startno:	cp '1' 
d5f1 28 3a			jr z,.startnxt  
d5f3			 
d5f3				; exec startup line 
d5f3			.startdo:	 
d5f3 e1				pop hl 
d5f4 e5				push hl 
d5f5				 
d5f5 5e				ld e,(hl) 
d5f6 23				inc hl 
d5f7 56				ld d,(hl) 
d5f8 eb				ex de,hl 
d5f9			 
d5f9 e5				push hl 
d5fa			 
d5fa 3e 00			ld a, 0 
d5fc				;ld a, FORTH_END_BUFFER 
d5fc cd fd 8f			call strlent 
d5ff 23				inc hl   ; include zero term to copy 
d600 06 00			ld b,0 
d602 4d				ld c,l 
d603 e1				pop hl 
d604 11 d7 e3			ld de, scratch 
d607 ed b0			ldir 
d609			 
d609			 
d609 21 d7 e3			ld hl, scratch 
d60c cd b7 9d			call forthparse 
d60f cd f7 9d			call forthexec 
d612 cd 0e 9d			call forthexec_cleanup 
d615			 
d615 3e 78			ld a, display_row_4 
d617 11 1a 97			ld de, endprog 
d61a			 
d61a cd 8a 89			call update_display		 
d61d			 
d61d 3a fd e7			ld a, (os_last_cmd) 
d620 fe 00			cp 0 
d622 20 09			jr nz, .startnxt 
d624 cd 78 99			call next_page_prompt 
d627 cd 67 89		        call clear_display 
d62a cd 8a 89			call update_display		 
d62d			 
d62d				; move onto next startup line? 
d62d			.startnxt: 
d62d			 
d62d cd d8 88			call delay250ms 
d630 e1				pop hl 
d631			 
d631 23				inc hl 
d632 23				inc hl 
d633			 
d633 e5				push hl 
d634 5e				ld e, (hl) 
d635 23				inc hl 
d636 56				ld d, (hl) 
d637 e1				pop hl 
d638				; TODO replace 0 test 
d638			 
d638 eb				ex de, hl 
d639 cd bd 8b			call ishlzero 
d63c			;	ld a,e 
d63c			;	add d 
d63c			;	cp 0    ; any left to do? 
d63c eb				ex de, hl 
d63d c2 a2 d5			jp nz, .start1 
d640 18 01			jr .startupend 
d642			 
d642 e1			.startupend1: pop hl 
d643			.startupend: 
d643			 
d643 cd 67 89			call clear_display 
d646 cd 8a 89			call update_display 
d649 c9				ret 
d64a			 
d64a			 
d64a			; stack over and underflow checks 
d64a			 
d64a			; init the words to detect the under/overflow 
d64a			 
d64a			chk_stk_init: 
d64a				; a vague random number to check so we dont get any "lucky" hits 
d64a 3e 2d			ld a, 45 
d64c 6f				ld l, a 
d64d 00				nop 
d64e 3e 17			ld a, 23 
d650 67				ld h, a 
d651			 
d651 22 be e3			ld (chk_word), hl     ; the word we need to check against 
d654			 
d654			;	ld (chk_stund), hl	; stack points.... 
d654 22 00 ef			ld (chk_stovr), hl 
d657 22 02 eb			ld (chk_ret_und), hl 
d65a 22 c0 ea			ld (chk_ret_ovr), hl 
d65d 22 3e ea			ld (chk_loop_ovr), hl 
d660 22 3c e9			ld (chk_data_ovr), hl 
d663 c9				ret 
d664				 
d664			check_stacks: 
d664				; check all stack words 
d664			 
d664 e5				push hl 
d665 d5				push de 
d666			 
d666			;	ld de,(chk_word) 
d666			;	ld hl, (chk_stund)	; stack points.... 
d666			;	if DEBUG_STK_FAULT 
d666			;		DMARK "FAa" 
d666			;		CALLMONITOR 
d666			;	endif 
d666			;	call cmp16 
d666			;	jp z, .chk_faulta 
d666			; 
d666			;	ld de, sfaultsu 
d666			;	jp .chk_fault 
d666			 
d666 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d669 ed 5b be e3		ld de,(chk_word) 
d66d				if DEBUG_STK_FAULT 
d66d					DMARK "FAb" 
d66d					CALLMONITOR 
d66d				endif 
d66d cd b2 8b			call cmp16 
d670 28 06			jr z, .chk_fault1 
d672 11 13 d7			ld de, sfaultso 
d675 c3 c7 d6			jp .chk_fault 
d678			.chk_fault1:  
d678 2a 02 eb			ld hl, (chk_ret_und) 
d67b ed 5b be e3		ld de,(chk_word) 
d67f				if DEBUG_STK_FAULT 
d67f					DMARK "FAU" 
d67f					CALLMONITOR 
d67f				endif 
d67f cd b2 8b			call cmp16 
d682 ca 8b d6			jp z, .chk_fault2 
d685 11 23 d7			ld de, sfaultru 
d688 c3 c7 d6			jp .chk_fault 
d68b			.chk_fault2:  
d68b 2a c0 ea			ld hl, (chk_ret_ovr) 
d68e ed 5b be e3		ld de,(chk_word) 
d692				if DEBUG_STK_FAULT 
d692					DMARK "FA1" 
d692					CALLMONITOR 
d692				endif 
d692 cd b2 8b			call cmp16 
d695 ca 9e d6			jp z, .chk_fault3 
d698 11 31 d7			ld de, sfaultro 
d69b c3 c7 d6			jp .chk_fault 
d69e			.chk_fault3:  
d69e 2a 3e ea			ld hl, (chk_loop_ovr) 
d6a1 ed 5b be e3		ld de,(chk_word) 
d6a5				if DEBUG_STK_FAULT 
d6a5					DMARK "FA2" 
d6a5					CALLMONITOR 
d6a5				endif 
d6a5 cd b2 8b			call cmp16 
d6a8 ca b1 d6			jp z, .chk_fault4 
d6ab 11 4b d7			ld de, sfaultlo 
d6ae c3 c7 d6			jp .chk_fault 
d6b1			.chk_fault4:  
d6b1 2a 3c e9			ld hl, (chk_data_ovr) 
d6b4 ed 5b be e3		ld de,(chk_word) 
d6b8				if DEBUG_STK_FAULT 
d6b8					DMARK "FA3" 
d6b8					CALLMONITOR 
d6b8				endif 
d6b8 cd b2 8b			call cmp16 
d6bb ca c4 d6			jp z, .chk_fault5 
d6be 11 65 d7			ld de, sfaultdo 
d6c1 c3 c7 d6			jp .chk_fault 
d6c4			 
d6c4			 
d6c4			.chk_fault5:  
d6c4 d1				pop de 
d6c5 e1				pop hl 
d6c6			 
d6c6 c9				ret 
d6c7			 
d6c7 cd 67 89		.chk_fault: 	call clear_display 
d6ca 3e 28				ld a, display_row_2 
d6cc cd 7a 89				call str_at_display 
d6cf 11 f5 d6				   ld de, .stackfault 
d6d2 3e 00				ld a, display_row_1 
d6d4 cd 7a 89				call str_at_display 
d6d7 11 71 ee				    ld de, debug_mark 
d6da 3e 11				ld a, display_row_1+17 
d6dc cd 7a 89				call str_at_display 
d6df cd 8a 89				call update_display 
d6e2			 
d6e2				; prompt before entering montior for investigating issue 
d6e2			 
d6e2 3e 78			ld a, display_row_4 
d6e4 11 1a 97			ld de, endprog 
d6e7			 
d6e7 cd 8a 89			call update_display		 
d6ea			 
d6ea cd 78 99			call next_page_prompt 
d6ed			 
d6ed d1				pop de 
d6ee e1				pop hl 
d6ef cd 6e 97				call monitor 
d6f2 c3 68 96				jp warmstart 
d6f5					;jp 0 
d6f5					;halt 
d6f5			 
d6f5			 
d6f5			 
d6f5 .. 00		.stackfault: 	db "Stack fault:",0 
d702			 
d702 .. 00		sfaultsu: 	db	"Stack under flow",0 
d713 .. 00		sfaultso: 	db	"Stack over flow",0 
d723 .. 00		sfaultru:	db "RTS underflow",0 
d731 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d74b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d765 .. 00		sfaultdo:	db "DTS overflow", 0 
d772			 
d772			 
d772			fault_dsp_under: 
d772 11 84 d7			ld de, .dsp_under 
d775 c3 34 d8			jp .show_fault 
d778			 
d778			fault_rsp_under: 
d778 11 92 d7			ld de, .rsp_under 
d77b c3 34 d8			jp .show_fault 
d77e			fault_loop_under: 
d77e 11 a0 d7			ld de, .loop_under 
d781 c3 34 d8			jp .show_fault 
d784			 
d784 .. 00		.dsp_under: db "DSP Underflow",0 
d792 .. 00		.rsp_under: db "RSP Underflow",0 
d7a0 .. 00		.loop_under: db "LOOP Underflow",0 
d7af			 
d7af			 
d7af d5			type_faultn: 	push de 
d7b0 e5					push hl 
d7b1 cd 67 89				call clear_display 
d7b4 11 db d7				   ld de, .typefaultn 
d7b7 3e 00				ld a, display_row_1 
d7b9 cd 7a 89				call str_at_display 
d7bc 11 71 ee				    ld de, debug_mark 
d7bf 3e 11				ld a, display_row_1+17 
d7c1 cd 7a 89				call str_at_display 
d7c4 cd 8a 89				call update_display 
d7c7			 
d7c7				; prompt before entering montior for investigating issue 
d7c7			 
d7c7 3e 78			ld a, display_row_4 
d7c9 11 1a 97			ld de, endprog 
d7cc			 
d7cc cd 8a 89			call update_display		 
d7cf			 
d7cf cd 78 99			call next_page_prompt 
d7d2			 
d7d2 e5					push hl 
d7d3 d5					push de 
d7d4 cd 6e 97				call monitor 
d7d7 c3 68 96				jp warmstart 
d7da 76					halt 
d7db			 
d7db			 
d7db .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d7f2			 
d7f2 d5			type_faults: 	push de 
d7f3 e5					push hl 
d7f4 cd 67 89				call clear_display 
d7f7 11 1d d8				   ld de, .typefaults 
d7fa 3e 00				ld a, display_row_1 
d7fc cd 7a 89				call str_at_display 
d7ff 11 71 ee				    ld de, debug_mark 
d802 3e 11				ld a, display_row_1+17 
d804 cd 7a 89				call str_at_display 
d807 cd 8a 89				call update_display 
d80a			 
d80a				; prompt before entering montior for investigating issue 
d80a			 
d80a 3e 78			ld a, display_row_4 
d80c 11 1a 97			ld de, endprog 
d80f			 
d80f cd 8a 89			call update_display		 
d812			 
d812 cd 78 99			call next_page_prompt 
d815			 
d815 e1					pop hl 
d816 d1					pop de 
d817 cd 6e 97				call monitor 
d81a c3 68 96				jp warmstart 
d81d			 
d81d			 
d81d .. 00		.typefaults: db "STR Type Expected TOS!",0 
d834			 
d834			.show_fault: 	 
d834 d5					push de 
d835 cd 67 89				call clear_display 
d838 d1					pop de 
d839 3e 00				ld a, display_row_1 
d83b cd 7a 89				call str_at_display 
d83e 11 71 ee				    ld de, debug_mark 
d841 3e 11				ld a, display_row_1+17 
d843 cd 7a 89				call str_at_display 
d846 cd 8a 89				call update_display 
d849			 
d849				; prompt before entering montior for investigating issue 
d849			 
d849 3e 78			ld a, display_row_4 
d84b 11 1a 97			ld de, endprog 
d84e			 
d84e cd 8a 89			call update_display		 
d851			 
d851 cd 78 99			call next_page_prompt 
d854			 
d854 e1					pop hl 
d855 d1					pop de 
d856 cd 6e 97				call monitor 
d859			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d859			; TODO Make optional fault restart to cli or warm boot? 
d859					;jp warmstart 
d859 c3 c0 96				jp cli 
d85c 76					halt 
d85d			 
d85d			; handle the auto run of code from files in storage 
d85d			 
d85d			 
d85d			if STORAGE_SE 
d85d			 
d85d			sprompt3: db "Loading from start-up file?:",0 
d85d			sprompt4: db "(Y=Any key/N=No)",0 
d85d			 
d85d			 
d85d			forth_autoload: 
d85d			 
d85d				; load block 0 of store 1 
d85d				 
d85d				ld a, $fe      ; bit 0 clear 
d85d				ld (spi_device), a 
d85d			 
d85d				call storage_get_block_0 
d85d			 
d85d				ld a, (store_page+STORE_0_AUTOFILE) 
d85d			 
d85d				cp 0 
d85d				ret z     ; auto start not enabled 
d85d			 
d85d				call clear_display 
d85d			 
d85d				; set bank 
d85d			 
d85d					ld a, (store_page+STORE_0_BANKRUN) 
d85d					ld (spi_device), a 
d85d			 
d85d				; get file id to load from and get the file name to display 
d85d			 
d85d					ld a, (store_page+STORE_0_FILERUN) 
d85d			 
d85d					ld l, 0 
d85d					ld h, a 
d85d					ld de, store_page 
d85d			 
d85d					if DEBUG_FORTH_WORDS 
d85d						DMARK "ASp" 
d85d						CALLMONITOR 
d85d					endif 
d85d					call storage_read 
d85d			 
d85d					if DEBUG_FORTH_WORDS 
d85d						DMARK "ASr" 
d85d						CALLMONITOR 
d85d					endif 
d85d			 
d85d					call ishlzero 
d85d					ret z             ; file not found 
d85d			 
d85d					ld a, display_row_2 + 10 
d85d					ld de, store_page+3 
d85d					call str_at_display 
d85d				 
d85d			; 
d85d			 
d85d				ld a, display_row_1+5 
d85d				ld de, sprompt3 
d85d				call str_at_display 
d85d				ld a, display_row_3+15 
d85d				ld de, sprompt4 
d85d				call str_at_display 
d85d			 
d85d				call update_display 
d85d			 
d85d				call cin_wait 
d85d				cp 'n' 
d85d				ret z 
d85d				cp 'N' 
d85d				ret z 
d85d			 
d85d				call delay1s 
d85d			 
d85d				ld a, (store_page+2) 
d85d				ld (store_openmaxext), a    ; save count of ext 
d85d				ld a, 1  
d85d				ld (store_openext), a    ; save count of ext 
d85d			 
d85d			.autof:  
d85d				ld l , a 
d85d				 
d85d				ld a, (store_page) 
d85d				ld h, a	 
d85d				ld de, store_page 
d85d					if DEBUG_FORTH_WORDS 
d85d						DMARK "ASl" 
d85d						CALLMONITOR 
d85d					endif 
d85d					call storage_read 
d85d				call ishlzero 
d85d				ret z 
d85d			;	jr z, .autoend 
d85d			 
d85d					if DEBUG_FORTH_WORDS 
d85d						DMARK "ASc" 
d85d						CALLMONITOR 
d85d					endif 
d85d				ld de, store_page+2 
d85d				ld a, display_row_4 
d85d				call str_at_display 
d85d			 
d85d				call update_display 
d85d				call delay250ms 
d85d			 
d85d			 
d85d			 
d85d				ld hl, store_page+2 
d85d				call forthparse 
d85d				call forthexec 
d85d				call forthexec_cleanup 
d85d			 
d85d				 
d85d				ld a, (store_openext) 
d85d				inc a 
d85d				ld (store_openext), a    ; save count of ext 
d85d			 
d85d				jr .autof 
d85d			;.autofdone: 
d85d			; 
d85d			;		if DEBUG_FORTH_WORDS 
d85d			;			DMARK "ASx" 
d85d			;			CALLMONITOR 
d85d			;		endif 
d85d			;;	call clear_display 
d85d			;	ret 
d85d			 
d85d			 
d85d			 
d85d			endif 
d85d			 
d85d			 
d85d			; eof 
# End of file forth_kernel.asm
d85d			;include "nascombasic.asm" 
d85d			 
d85d			 
d85d			; find out where the code ends if loaded into RAM (for SC114) 
d85d			;endofcode:  
d85d			;	nop 
d85d			 
d85d			 
d85d			; eof 
d85d			 
# End of file main.asm
d85d			;include "firmware_lcd_4x40.asm" 
d85d			;;include "firmware_lcd_4x20.asm" 
d85d			include "firmware_serial_display.asm" 
d85d			 
d85d			; Serial display interface for SC114 
d85d			 
d85d			 
d85d			display_row_1: equ 0 
d85d			display_row_2: equ display_row_1+display_cols 
d85d			display_row_3: equ display_row_2 + display_cols 
d85d			display_row_4: equ display_row_3 + display_cols 
d85d			 
d85d			kLCDWidth:  EQU display_cols             ;Width in characters 
d85d			kLCD_Line1: EQU 0x00  
d85d			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d85d			; E1 
d85d			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d85d			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d85d			 
d85d			lcd_init: 
d85d				; no init as handled by the SCM bios 
d85d c9				ret 
d85e			 
d85e			 
d85e			; low level functions for direct screen writes 
d85e			 
d85e			; output char at pos? 
d85e			fLCD_Str: 
d85e			        ;out (SC114_SIO_1_OUT),a 
d85e c5				push bc 
d85f 0e 02			ld c, $02 
d861 f7				rst $30 
d862 c1				pop bc 
d863 c9				ret 
d864			 
d864			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d864			fLCD_Pos: 
d864				; use ASCII escape to position 
d864			        ;out (SC114_SIO_1_OUT),a 
d864 c5				push bc 
d865 0e 02			ld c, $02 
d867 f7				rst $30 
d868 c1				pop bc 
d869			 
d869 c9				ret 
d86a			 
d86a			; output char at pos 
d86a			fLCD_Data: 
d86a			      ;  out (SC114_SIO_1_OUT),a 
d86a c5				push bc 
d86b 0e 02			ld c, $02 
d86d f7				rst $30 
d86e c1				pop bc 
d86f			 
d86f c9				ret 
d870			 
d870			; ascii cls  
d870			 
d870 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d874			 
d874			; write the frame buffer given in hl to hardware  
d874			write_display: 
d874			 
d874			API: equ 0 
d874			 
d874			if API 
d874				push bc 
d874				ld b, 4 
d874			 
d874			        ld (display_write_tmp), hl 	  
d874			 
d874				; clear and home cursor 
d874			 
d874				ld c, 6 
d874				ld de, .cls 
d874				rst $30 
d874			 
d874			 
d874			.writeln: 
d874			 
d874				ld de, (display_write_tmp) 
d874				ld c, 6 
d874				rst $30 
d874				ld c, 7 
d874				rst $30 
d874			 
d874				ld hl, (display_write_tmp) 
d874				ld de, display_cols 
d874				add hl,de 
d874				ld (display_write_tmp),hl 
d874			 
d874				djnz  .writeln 
d874			 
d874				pop bc 
d874			 
d874			 
d874				ret 
d874			endif 
d874 e5				push hl 
d875 c5				push bc 
d876 d5				push de 
d877			 
d877			;	ld c, 2 
d877			;	;ld de, .cls 
d877			;	ld a, 27 
d877			;	rst $30 
d877			;	ld c, 2 
d877			;	;ld de, .cls 
d877			;	ld a, '[' 
d877			;	rst $30 
d877			; 
d877			;	ld c, 2 
d877			;	;ld de, .cls 
d877			;	ld a, 'H' 
d877			;	rst $30 
d877			; 
d877			 
d877 0e 02			ld c, 2 
d879				;ld de, .cls 
d879 3e 1b			ld a, 27 
d87b f7				rst $30 
d87c			 
d87c			 
d87c 0e 02			ld c, 2 
d87e				;ld de, .cls 
d87e 3e 5b			ld a, '[' 
d880 f7				rst $30 
d881 0e 02			ld c, 2 
d883				;ld de, .cls 
d883 3e 32			ld a, '2' 
d885 f7				rst $30 
d886 0e 02			ld c, 2 
d888				;ld de, .cls 
d888 3e 4a			ld a, 'J' 
d88a f7				rst $30 
d88b d1				pop de 
d88c c1				pop bc 
d88d e1				pop hl 
d88e			 
d88e			 
d88e 22 cf eb		        ld (display_write_tmp), hl 	  
d891 3e 00			ld a, kLCD_Line1 
d893			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d893 06 28			ld b, display_cols 
d895 ed 5b cf eb		ld de, (display_write_tmp) 
d899 cd f7 d8			call write_len_string 
d89c				 
d89c			 
d89c e5			push hl 
d89d d5			push de 
d89e c5			push bc 
d89f 0e 07			ld c, 7 
d8a1 f7				rst $30 
d8a2 c1			pop bc 
d8a3 d1			pop de 
d8a4 e1			pop hl 
d8a5			 
d8a5				 
d8a5 2a cf eb			ld hl, (display_write_tmp) 
d8a8 11 28 00			ld de, display_cols 
d8ab 19				add hl,de 
d8ac 22 cf eb			ld (display_write_tmp),hl 
d8af			 
d8af				 
d8af 3e 28			ld a, kLCD_Line2 
d8b1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d8b1 06 28			ld b, display_cols 
d8b3 ed 5b cf eb		ld de, (display_write_tmp) 
d8b7 cd f7 d8			call write_len_string 
d8ba				 
d8ba 2a cf eb			ld hl, (display_write_tmp) 
d8bd 11 28 00			ld de, display_cols 
d8c0 19				add hl,de 
d8c1 22 cf eb			ld (display_write_tmp),hl 
d8c4			 
d8c4 e5			push hl 
d8c5 d5			push de 
d8c6 c5			push bc 
d8c7 0e 07			ld c, 7 
d8c9 f7				rst $30 
d8ca c1			pop bc 
d8cb d1			pop de 
d8cc e1			pop hl 
d8cd			 
d8cd				 
d8cd 3e 50			ld a, kLCD_Line3 
d8cf			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d8cf 06 28			ld b, display_cols 
d8d1 ed 5b cf eb		ld de, (display_write_tmp) 
d8d5 cd f7 d8			call write_len_string 
d8d8				 
d8d8 2a cf eb			ld hl, (display_write_tmp) 
d8db 11 28 00			ld de, display_cols 
d8de 19				add hl,de 
d8df 22 cf eb			ld (display_write_tmp),hl 
d8e2			 
d8e2 e5			push hl 
d8e3 d5			push de 
d8e4 c5			push bc 
d8e5 0e 07			ld c, 7 
d8e7 f7				rst $30 
d8e8 c1			pop bc 
d8e9 d1			pop de 
d8ea e1			pop hl 
d8eb			 
d8eb				 
d8eb 3e 78			ld a, kLCD_Line4 
d8ed			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d8ed 06 28			ld b, display_cols 
d8ef ed 5b cf eb		ld de, (display_write_tmp) 
d8f3 cd f7 d8			call write_len_string 
d8f6 c9					ret 
d8f7			 
d8f7			 
d8f7				; write out a fixed length string given in b from de 
d8f7			 
d8f7 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d8f8 cd 6a d8		            CALL fLCD_Data      ;Write character to display 
d8fb 13				inc de 
d8fc 10 f9			djnz write_len_string 
d8fe c9				ret 
d8ff			 
d8ff			 
d8ff			; eof 
# End of file firmware_serial_display.asm
d8ff			;include "firmware_key_5x10.asm" 
d8ff			;;include "firmware_key_4x10.asm" 
d8ff			include "firmware_key_serial.asm" 
d8ff			; Serial keyboard interface for SC114 
d8ff			 
d8ff			key_init: 
d8ff				; no init as handled by the SCM bios 
d8ff c9				ret 
d900			 
d900			 
d900			cin_wait: 
d900			;	ld a, 0 
d900			;	ret 
d900			 
d900				;in a,(SC114_SIO_1_IN) 
d900			        ; Use SCM API to get from whatever console device we are using 
d900 c5				push bc 
d901 0e 01			ld c, $01 
d903 f7				rst $30 
d904 c1				pop bc 
d905 c9				ret 
d906			 
d906			cin: 
d906			 
d906			 
d906 c5				push bc 
d907			 
d907				; any key waiting to process? 
d907 0e 03			ld c, $03 
d909 f7				rst $30 
d90a 28 05			jr z, .cin_skip 
d90c			 
d90c				; yep, get it 
d90c			 
d90c 0e 01			ld c, $01 
d90e f7				rst $30 
d90f c1				pop bc 
d910 c9				ret 
d911			.cin_skip: 
d911 3e 00			ld a, 0 
d913 c1				pop bc 
d914 c9				ret 
d915			 
d915			 
d915			 
d915			 
# End of file firmware_key_serial.asm
d915			endofcode:  
d915			baseram:  
d915 00				nop 
d916			 
d916			heap_start: equ baseram+15  ; Starting address of heap 
d916			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d916			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d916			;VDU:  EQU     endofcode           ; BASIC Work space 
d916			; eof 
d916			 
# End of file os_mega_sc114.asm
d916
