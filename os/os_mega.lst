# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 da 14			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 0   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 0   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd bd 09				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd bd 09				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd bd 09				call clear_display  
0023			  
0023			  
0023 cd b5 51				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 4c 54			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b9 0f				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 76 11				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd e0 09			call update_display  
0035 cd 41 09			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd c2 09			call fill_display  
003d cd e0 09			call update_display  
0040 cd 41 09			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd c2 09			call fill_display  
0048 cd e0 09			call update_display  
004b cd 41 09			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd c2 09			call fill_display  
0053 cd e0 09			call update_display  
0056 cd 41 09			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd d0 09			call str_at_display  
0061 cd e0 09			call update_display  
0064			  
0064			  
0064 cd 41 09			call delay1s  
0067 cd 41 09			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd d0 09			call str_at_display  
0072 cd e0 09			call update_display  
0075 cd 41 09			call delay1s  
0078 cd 41 09			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 26 09			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 26 09			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 34 ee			ld hl,scratch+2 
02be cd cd 0e			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 55 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 39 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 55 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 55 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 55 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 55 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 5a ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 5a ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 55 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 55 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 5a ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 55 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 04 13			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341						CALLMONITOR 
0341					endif 
0341 cd 7a 05			call storage_findnextid 
0344			 
0344 cd 3f 0b			call ishlzero 
0347			;	ld a, l 
0347			;	add h 
0347			;	cp 0 
0347 c8				ret z			; block not found so EOF 
0348			 
0348 11 62 f8			ld de, store_page 
034b cd 0c 03			call storage_read_block 
034e			 
034e 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
0351 6f				ld l, a 
0352 26 00			ld h, 0 
0354 c9			 	ret 
0355			 
0355			 
0355			; Write Block 
0355			; ----------- 
0355			; 
0355			; With current bank 
0355			;  
0355			; Get block number to write 
0355			; Write physical blocks starting at start block from buffer 
0355			  
0355			storage_write_block: 
0355				; TODO bank selection 
0355			 
0355				; for each of the physical blocks read it into the buffer 
0355 06 40			ld b, STORE_BLOCK_PHY 
0357			 
0357				if DEBUG_STORESE 
0357					DMARK "SWB" 
0357 f5				push af  
0358 3a 6c 03			ld a, (.dmark)  
035b 32 77 fb			ld (debug_mark),a  
035e 3a 6d 03			ld a, (.dmark+1)  
0361 32 78 fb			ld (debug_mark+1),a  
0364 3a 6e 03			ld a, (.dmark+2)  
0367 32 79 fb			ld (debug_mark+2),a  
036a 18 03			jr .pastdmark  
036c ..			.dmark: db "SWB"  
036f f1			.pastdmark: pop af  
0370			endm  
# End of macro DMARK
0370			 
0370					;push af 
0370					;ld a, 'W' 
0370					;ld (debug_mark),a 
0370					;pop af 
0370					CALLMONITOR 
0370 cd 04 13			call break_point_state  
0373				endm  
# End of macro CALLMONITOR
0373				endif 
0373			 
0373			; might not be working 
0373			;	call se_writepage 
0373			 
0373			;	ret 
0373			; 
0373			 
0373			 
0373			 
0373			.wl1:    
0373			 
0373				; read physical block at hl into de 
0373			        ; increment hl and de to next read position on exit 
0373			 
0373 e5				push hl 
0374 d5				push de	 
0375 c5				push bc 
0376 1a				ld a,(de) 
0377				;if DEBUG_STORESE 
0377			;		push af 
0377			;		ld a, 'W' 
0377			;		ld (debug_mark),a 
0377			;		pop af 
0377			;		CALLMONITOR 
0377			;	endif 
0377 cd ea 01			call se_writebyte 
037a			;	call delay250ms 
037a 00				nop 
037b 00				nop 
037c 00				nop 
037d			;	if DEBUG_STORESE 
037d			;		push af 
037d			;		ld a, 'w' 
037d			;		ld (debug_mark),a 
037d			;		pop af 
037d			;		CALLMONITOR 
037d			;	endif 
037d c1				pop bc 
037e d1				pop de 
037f e1				pop hl 
0380 23				inc hl 
0381 13				inc de 
0382			 
0382			 
0382 10 ef			djnz .wl1 
0384			 
0384				if DEBUG_STORESE 
0384					DMARK "SW2" 
0384 f5				push af  
0385 3a 99 03			ld a, (.dmark)  
0388 32 77 fb			ld (debug_mark),a  
038b 3a 9a 03			ld a, (.dmark+1)  
038e 32 78 fb			ld (debug_mark+1),a  
0391 3a 9b 03			ld a, (.dmark+2)  
0394 32 79 fb			ld (debug_mark+2),a  
0397 18 03			jr .pastdmark  
0399 ..			.dmark: db "SW2"  
039c f1			.pastdmark: pop af  
039d			endm  
# End of macro DMARK
039d			 
039d					;push af 
039d					;ld a, 'W' 
039d					;ld (debug_mark),a 
039d					;pop af 
039d					CALLMONITOR 
039d cd 04 13			call break_point_state  
03a0				endm  
# End of macro CALLMONITOR
03a0				endif 
03a0 c9				ret	 
03a1			 
03a1			; Init bank 
03a1			; --------- 
03a1			; 
03a1			; With current bank 
03a1			; 
03a1			; Setup block 0 config 
03a1			;     Set 0 file id counter 
03a1			;     Set formatted byte pattern 
03a1			;     Zero out bank label 
03a1			;      
03a1			; For every logical block write 0-1 byte as null 
03a1			 
03a1			storage_get_block_0: 
03a1			 
03a1				; TODO check presence 
03a1			 
03a1				; get block 0 config 
03a1			 
03a1 21 00 00			ld hl, 0 
03a4 11 62 f8			ld de, store_page 
03a7 cd 0c 03			call storage_read_block 
03aa			 
03aa				if DEBUG_STORESE 
03aa					DMARK "SB0" 
03aa f5				push af  
03ab 3a bf 03			ld a, (.dmark)  
03ae 32 77 fb			ld (debug_mark),a  
03b1 3a c0 03			ld a, (.dmark+1)  
03b4 32 78 fb			ld (debug_mark+1),a  
03b7 3a c1 03			ld a, (.dmark+2)  
03ba 32 79 fb			ld (debug_mark+2),a  
03bd 18 03			jr .pastdmark  
03bf ..			.dmark: db "SB0"  
03c2 f1			.pastdmark: pop af  
03c3			endm  
# End of macro DMARK
03c3 11 62 f8				ld de, store_page 
03c6			;		push af 
03c6			;		ld a, 'i' 
03c6			;		ld (debug_mark),a 
03c6			;		pop af 
03c6					CALLMONITOR 
03c6 cd 04 13			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9			 
03c9				; is this area formatted? 
03c9			 
03c9			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03c9 2a 63 f8			ld hl, (store_page+1) 
03cc 3e 80			ld a,0x80 
03ce bd				cp l 
03cf 20 22			jr nz, .ininotformatted 
03d1				; do a double check 
03d1 3e 27			ld a, 0x27 
03d3 bc				cp h 
03d4 20 1d			jr nz, .ininotformatted 
03d6			 
03d6				; formatted then 
03d6			 
03d6				if DEBUG_STORESE 
03d6					DMARK "SB1" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 77 fb			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 78 fb			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 79 fb			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SB1"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					;push af 
03ef					;ld a, 'I' 
03ef					;ld (debug_mark),a 
03ef					;pop af 
03ef					CALLMONITOR 
03ef cd 04 13			call break_point_state  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 c9				ret 
03f3			 
03f3			.ininotformatted: 
03f3				; bank not formatted so poke various bits to make sure 
03f3			 
03f3				if DEBUG_STORESE 
03f3					DMARK "SB2" 
03f3 f5				push af  
03f4 3a 08 04			ld a, (.dmark)  
03f7 32 77 fb			ld (debug_mark),a  
03fa 3a 09 04			ld a, (.dmark+1)  
03fd 32 78 fb			ld (debug_mark+1),a  
0400 3a 0a 04			ld a, (.dmark+2)  
0403 32 79 fb			ld (debug_mark+2),a  
0406 18 03			jr .pastdmark  
0408 ..			.dmark: db "SB2"  
040b f1			.pastdmark: pop af  
040c			endm  
# End of macro DMARK
040c					;push af 
040c					;ld a, 'f' 
040c					;ld (debug_mark),a 
040c					;pop af 
040c					CALLMONITOR 
040c cd 04 13			call break_point_state  
040f				endm  
# End of macro CALLMONITOR
040f				endif 
040f			 
040f 21 62 f8			ld hl, store_page 
0412 3e 00			ld a, 0 
0414				 
0414 77				ld (hl),a   ; reset file counter 
0415			 
0415 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0418 22 63 f8		 	ld (store_page+1), hl	 
041b			 
041b				; set default label 
041b			 
041b 21 b0 04			ld hl, .defaultbanklabl 
041e 11 65 f8		 	ld de, store_page+3 
0421 01 0f 00			ld bc, 15 
0424 ed b0			ldir 
0426			 
0426				; save default page 0 
0426			 
0426 21 00 00			ld hl, 0 
0429 11 62 f8			ld de, store_page 
042c				if DEBUG_STORESE 
042c					DMARK "SB3" 
042c f5				push af  
042d 3a 41 04			ld a, (.dmark)  
0430 32 77 fb			ld (debug_mark),a  
0433 3a 42 04			ld a, (.dmark+1)  
0436 32 78 fb			ld (debug_mark+1),a  
0439 3a 43 04			ld a, (.dmark+2)  
043c 32 79 fb			ld (debug_mark+2),a  
043f 18 03			jr .pastdmark  
0441 ..			.dmark: db "SB3"  
0444 f1			.pastdmark: pop af  
0445			endm  
# End of macro DMARK
0445			;		push af 
0445			;		ld a, 'F' 
0445			;		ld (debug_mark),a 
0445			;		pop af 
0445					CALLMONITOR 
0445 cd 04 13			call break_point_state  
0448				endm  
# End of macro CALLMONITOR
0448				endif 
0448 cd 55 03			call storage_write_block 
044b				if DEBUG_STORESE 
044b					DMARK "SB4" 
044b f5				push af  
044c 3a 60 04			ld a, (.dmark)  
044f 32 77 fb			ld (debug_mark),a  
0452 3a 61 04			ld a, (.dmark+1)  
0455 32 78 fb			ld (debug_mark+1),a  
0458 3a 62 04			ld a, (.dmark+2)  
045b 32 79 fb			ld (debug_mark+2),a  
045e 18 03			jr .pastdmark  
0460 ..			.dmark: db "SB4"  
0463 f1			.pastdmark: pop af  
0464			endm  
# End of macro DMARK
0464			;		push af 
0464			;		ld a, '>' 
0464			;		ld (debug_mark),a 
0464			;		pop af 
0464					CALLMONITOR 
0464 cd 04 13			call break_point_state  
0467				endm  
# End of macro CALLMONITOR
0467				endif 
0467			 
0467 00				nop 
0468 00				nop 
0469 00				nop 
046a			 
046a				; now set 0 in every page to mark as a free block 
046a			 
046a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
046c 21 40 00			ld hl, STORE_BLOCK_PHY 
046f			 
046f 3e 00		.setmark1:   	ld a,0 
0471 e5					push hl 
0472 c5					push bc 
0473 cd ea 01				call se_writebyte 
0476 3e 0a			ld a, 10 
0478 cd 26 09			call aDelayInMS 
047b 23				inc hl 
047c cd ea 01				call se_writebyte 
047f 3e 0a			ld a, 10 
0481 cd 26 09			call aDelayInMS 
0484 2b				dec hl 
0485 c1					pop bc 
0486 e1					pop hl 
0487 3e 40				ld a, STORE_BLOCK_PHY 
0489 cd 16 0b				call addatohl 
048c 10 e1				djnz .setmark1 
048e			 
048e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0490 3e 00		.setmark2:   	ld a,0 
0492 e5					push hl 
0493 c5					push bc 
0494 cd ea 01				call se_writebyte 
0497 3e 0a			ld a, 10 
0499 cd 26 09			call aDelayInMS 
049c 23				inc hl 
049d cd ea 01				call se_writebyte 
04a0 3e 0a			ld a, 10 
04a2 cd 26 09			call aDelayInMS 
04a5 2b				dec hl 
04a6 c1					pop bc 
04a7 e1					pop hl 
04a8 3e 40				ld a, STORE_BLOCK_PHY 
04aa cd 16 0b				call addatohl 
04ad 10 e1				djnz .setmark2 
04af			 
04af					 
04af			 
04af			 
04af c9				ret 
04b0			 
04b0			 
04b0			 
04b0			 
04b0 .. 00		.defaultbanklabl:   db "BankLabel",0 
04ba			 
04ba			 
04ba			 
04ba			; Label Bank 
04ba			; ---------- 
04ba			; 
04ba			; With current bank 
04ba			; Read block 0 
04ba			; Set label 
04ba			; Write block 0 
04ba			 
04ba			; label str pointer in hl 
04ba			 
04ba			storage_label:     
04ba			 
04ba				if DEBUG_STORESE 
04ba					DMARK "LBL" 
04ba f5				push af  
04bb 3a cf 04			ld a, (.dmark)  
04be 32 77 fb			ld (debug_mark),a  
04c1 3a d0 04			ld a, (.dmark+1)  
04c4 32 78 fb			ld (debug_mark+1),a  
04c7 3a d1 04			ld a, (.dmark+2)  
04ca 32 79 fb			ld (debug_mark+2),a  
04cd 18 03			jr .pastdmark  
04cf ..			.dmark: db "LBL"  
04d2 f1			.pastdmark: pop af  
04d3			endm  
# End of macro DMARK
04d3					CALLMONITOR 
04d3 cd 04 13			call break_point_state  
04d6				endm  
# End of macro CALLMONITOR
04d6				endif 
04d6			 
04d6 e5				push hl 
04d7			 
04d7 cd a1 03			call storage_get_block_0 
04da			 
04da				; set default label 
04da			 
04da e1				pop hl 
04db			 
04db 11 65 f8		 	ld de, store_page+3 
04de 01 0f 00			ld bc, 15 
04e1				if DEBUG_STORESE 
04e1					DMARK "LB3" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LB3"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 04 13			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd ed b0			ldir 
04ff				; save default page 0 
04ff			 
04ff 21 00 00			ld hl, 0 
0502 11 62 f8			ld de, store_page 
0505				if DEBUG_STORESE 
0505					DMARK "LBW" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 77 fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 78 fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 79 fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LBW"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 04 13			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 cd 55 03			call storage_write_block 
0524			 
0524 c9				ret 
0525			 
0525			 
0525			 
0525			; Read Block 0 - Config 
0525			; --------------------- 
0525			; 
0525			; With current bank 
0525			; Call presence test 
0525			;    If not present format/init bank  
0525			; Read block 0  
0525			;  
0525			 
0525			 
0525			; Dir 
0525			; --- 
0525			; 
0525			; With current bank 
0525			; Load Block 0 Config 
0525			; Get max file id number 
0525			; For each logical block 
0525			;    Read block read byte 2 
0525			;      if first block of file 
0525			;         Display file name 
0525			;         Display type flags for file 
0525			;        
0525			 
0525			; moving to words as this requires stack control 
0525			 
0525			 
0525			; Delete File 
0525			; ----------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Load Block 0 Config 
0525			; Get max file id number 
0525			; For each logical block 
0525			;    Read block file id 
0525			;      If first block of file and dont have file id 
0525			;         if file to delete 
0525			;         Save file id 
0525			;         Null file id 
0525			;         Write this block back 
0525			;      If file id is one saved 
0525			;         Null file id 
0525			;         Write this block back 
0525			 
0525			storage_erase: 
0525			 
0525				; hl contains the file id 
0525			 
0525 5d				ld e, l 
0526 16 00			ld d, 0 
0528 21 40 00			ld hl, STORE_BLOCK_PHY 
052b					if DEBUG_FORTH_WORDS 
052b						DMARK "ERA" 
052b						CALLMONITOR 
052b					endif 
052b cd 7a 05			call storage_findnextid 
052e			 
052e e5				push hl 
052f			 
052f				; TODO check file not found 
052f			 
052f 11 62 f8			ld de, store_page 
0532 cd 0c 03			call storage_read_block 
0535			 
0535					if DEBUG_FORTH_WORDS 
0535						DMARK "ER1" 
0535						CALLMONITOR 
0535					endif 
0535 3a 62 f8			ld a, (store_page)	; get file id 
0538 32 5b f8			ld (store_tmpid), a 
053b			 
053b 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
053e 32 5a f8			ld (store_tmpext), a 
0541			 
0541				; wipe file header 
0541			 
0541 e1				pop hl 
0542 3e 00			ld a, 0 
0544 32 62 f8			ld (store_page), a 
0547 32 63 f8			ld (store_page+1),a 
054a 11 62 f8			ld de, store_page 
054d					if DEBUG_FORTH_WORDS 
054d						DMARK "ER2" 
054d						CALLMONITOR 
054d					endif 
054d cd 55 03			call storage_write_block 
0550			 
0550			 
0550				; wipe file extents 
0550			 
0550 3a 5a f8			ld a, (store_tmpext) 
0553 47				ld b, a 
0554			 
0554			.eraext:	  
0554 c5				push bc 
0555			 
0555 21 40 00			ld hl, STORE_BLOCK_PHY 
0558 3a 5b f8			ld a,(store_tmpid) 
055b 5f				ld e, a 
055c 50				ld d, b	 
055d					if DEBUG_FORTH_WORDS 
055d						DMARK "ER3" 
055d						CALLMONITOR 
055d					endif 
055d cd 7a 05			call storage_findnextid 
0560			 
0560 e5				push hl 
0561 11 62 f8			ld de, store_page 
0564 cd 0c 03			call storage_read_block 
0567			 
0567				; free block	 
0567			 
0567 3e 00			ld a, 0 
0569 32 62 f8			ld (store_page), a 
056c 32 63 f8			ld (store_page+1),a 
056f 11 62 f8			ld de, store_page 
0572 e1				pop hl 
0573					if DEBUG_FORTH_WORDS 
0573						DMARK "ER4" 
0573						CALLMONITOR 
0573					endif 
0573 cd 55 03			call storage_write_block 
0576			 
0576 c1				pop bc 
0577 10 db			djnz .eraext 
0579			 
0579 c9				ret 
057a			 
057a			 
057a			; Find Free Block 
057a			; --------------- 
057a			; 
057a			; With current bank 
057a			;  
057a			; From given starting logical block 
057a			;    Read block  
057a			;    If no file id 
057a			;         Return block id 
057a			 
057a			 
057a			; hl starting page number 
057a			; hl contains free page number or zero if no pages free 
057a			; e contains the file id to locate 
057a			; d contains the block number 
057a			 
057a			; TODO change to find file id and use zero for free block 
057a			 
057a			storage_findnextid: 
057a			 
057a				; now locate first 0 page to mark as a free block 
057a			 
057a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057c			;	ld hl, STORE_BLOCK_PHY 
057c			 
057c					if DEBUG_FORTH_WORDS 
057c					DMARK "FNI" 
057c						CALLMONITOR 
057c					endif 
057c			.ff1:   	 
057c e5					push hl 
057d c5					push bc 
057e d5					push de 
057f cd 8c 02				call se_readbyte 
0582 5f					ld e,a 
0583 23					inc hl 
0584 cd 8c 02				call se_readbyte 
0587 57					ld d, a 
0588 e1					pop hl 
0589 e5					push hl 
058a cd 34 0b				call cmp16 
058d 28 2d				jr z, .fffound 
058f			 
058f d1					pop de 
0590 c1					pop bc 
0591 e1					pop hl 
0592			 
0592					; is found? 
0592					;cp e 
0592					;ret z 
0592			 
0592 3e 40				ld a, STORE_BLOCK_PHY 
0594 cd 16 0b				call addatohl 
0597 10 e3				djnz .ff1 
0599			 
0599 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
059b			.ff2:   	 
059b			 
059b e5					push hl 
059c c5					push bc 
059d d5					push de 
059e cd 8c 02				call se_readbyte 
05a1 5f					ld e,a 
05a2 23					inc hl 
05a3 cd 8c 02				call se_readbyte 
05a6 57					ld d, a 
05a7			 
05a7 e1					pop hl 
05a8 e5					push hl 
05a9 cd 34 0b				call cmp16 
05ac 28 0e				jr z, .fffound 
05ae			 
05ae d1					pop de 
05af c1					pop bc 
05b0 e1					pop hl 
05b1					; is found? 
05b1					;cp e 
05b1					;ret z 
05b1			 
05b1 3e 40				ld a, STORE_BLOCK_PHY 
05b3 cd 16 0b				call addatohl 
05b6 10 e3				djnz .ff2 
05b8			 
05b8			 
05b8					if DEBUG_FORTH_WORDS 
05b8					DMARK "FN-" 
05b8					;	push af 
05b8					;	ld a, 'n' 
05b8					;	ld (debug_mark),a 
05b8					;	pop af 
05b8						CALLMONITOR 
05b8					endif 
05b8				; no free marks! 
05b8 21 00 00				ld hl, 0 
05bb c9				ret 
05bc			.fffound: 
05bc				 
05bc			 
05bc d1					pop de 
05bd c1					pop bc 
05be e1					pop hl 
05bf					if DEBUG_FORTH_WORDS 
05bf					DMARK "FNF" 
05bf					;	push af 
05bf					;	ld a, 'n' 
05bf					;	ld (debug_mark),a 
05bf					;	pop af 
05bf						CALLMONITOR 
05bf					endif 
05bf c9				ret 
05c0			 
05c0			 
05c0			 
05c0			; Free Space 
05c0			; ---------- 
05c0			; 
05c0			; With current bank 
05c0			; 
05c0			; Set block count to zero 
05c0			; Starting with first logical block 
05c0			;      Find free block  
05c0			;      If block id given, increment block count 
05c0			; 
05c0			;  
05c0			 
05c0			 
05c0			; hl contains count of free blocks 
05c0			 
05c0			storage_freeblocks: 
05c0			 
05c0				; now locate first 0 page to mark as a free block 
05c0			 
05c0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c2 21 40 00			ld hl, STORE_BLOCK_PHY 
05c5 11 00 00			ld de, 0 
05c8			 
05c8			.fb1:   	 
05c8 e5					push hl 
05c9 c5					push bc 
05ca d5					push de 
05cb cd 8c 02				call se_readbyte 
05ce d1					pop de 
05cf c1					pop bc 
05d0 e1					pop hl 
05d1			 
05d1					; is free? 
05d1 fe 00				cp 0 
05d3 20 01				jr nz, .ff1cont 
05d5 13					inc de 
05d6			 
05d6			.ff1cont: 
05d6			 
05d6			 
05d6 3e 40				ld a, STORE_BLOCK_PHY 
05d8 cd 16 0b				call addatohl 
05db 10 eb				djnz .fb1 
05dd			 
05dd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05df			.fb2:   	 
05df e5					push hl 
05e0 c5					push bc 
05e1 d5					push de 
05e2 cd 8c 02				call se_readbyte 
05e5 d1					pop de 
05e6 c1					pop bc 
05e7 e1					pop hl 
05e8			 
05e8					; is free? 
05e8 fe 00				cp 0 
05ea 20 01				jr nz, .ff2cont 
05ec 13					inc de 
05ed			 
05ed			.ff2cont: 
05ed			 
05ed 3e 40				ld a, STORE_BLOCK_PHY 
05ef cd 16 0b				call addatohl 
05f2 10 eb				djnz .fb2 
05f4			 
05f4 eb				ex de, hl 
05f5 c9				ret 
05f6			 
05f6			; Get File ID 
05f6			; ----------- 
05f6			; 
05f6			; With current bank 
05f6			;  
05f6			; Load Block 0 Config 
05f6			; Get max file id number 
05f6			; For each logical block 
05f6			;    Read block file id 
05f6			;      If first block of file and dont have file id 
05f6			;         if file get id and exit 
05f6			 
05f6			 
05f6			 
05f6			 
05f6			; Create File 
05f6			; ----------- 
05f6			; 
05f6			; With current bank  
05f6			; Load Block 0 Config 
05f6			; Get max file id number 
05f6			; Increment file id number 
05f6			; Save Config 
05f6			; Find free block 
05f6			; Set buffer with file name and file id 
05f6			; Write buffer to free block  
05f6			 
05f6			 
05f6			; hl point to file name 
05f6			; hl returns file id 
05f6			 
05f6			; file format: 
05f6			; byte 0 - file id 
05f6			; byte 1 - extent number 
05f6			; byte 2-> data 
05f6			 
05f6			; format for extent number 0: 
05f6			; 
05f6			; byte 0 - file id 
05f6			; byte 1 - extent 0 
05f6			; byte 2 - extent count 
05f6			; byte 3 -> file name and meta data 
05f6			 
05f6			 
05f6			storage_create: 
05f6				if DEBUG_STORESE 
05f6					DMARK "SCR" 
05f6 f5				push af  
05f7 3a 0b 06			ld a, (.dmark)  
05fa 32 77 fb			ld (debug_mark),a  
05fd 3a 0c 06			ld a, (.dmark+1)  
0600 32 78 fb			ld (debug_mark+1),a  
0603 3a 0d 06			ld a, (.dmark+2)  
0606 32 79 fb			ld (debug_mark+2),a  
0609 18 03			jr .pastdmark  
060b ..			.dmark: db "SCR"  
060e f1			.pastdmark: pop af  
060f			endm  
# End of macro DMARK
060f					CALLMONITOR 
060f cd 04 13			call break_point_state  
0612				endm  
# End of macro CALLMONITOR
0612				endif 
0612			 
0612 e5				push hl		; save file name pointer 
0613			 
0613 cd a1 03			call storage_get_block_0 
0616			 
0616 3a 62 f8			ld a,(store_page)	; get current file id 
0619 3c				inc a 
061a 32 62 f8			ld (store_page),a 
061d				 
061d 32 5b f8			ld (store_tmpid),a			; save id 
0620			 
0620 21 00 00			ld hl, 0 
0623 11 62 f8			ld de, store_page 
0626				if DEBUG_STORESE 
0626					DMARK "SCw" 
0626 f5				push af  
0627 3a 3b 06			ld a, (.dmark)  
062a 32 77 fb			ld (debug_mark),a  
062d 3a 3c 06			ld a, (.dmark+1)  
0630 32 78 fb			ld (debug_mark+1),a  
0633 3a 3d 06			ld a, (.dmark+2)  
0636 32 79 fb			ld (debug_mark+2),a  
0639 18 03			jr .pastdmark  
063b ..			.dmark: db "SCw"  
063e f1			.pastdmark: pop af  
063f			endm  
# End of macro DMARK
063f					CALLMONITOR 
063f cd 04 13			call break_point_state  
0642				endm  
# End of macro CALLMONITOR
0642				endif 
0642 cd 55 03			call storage_write_block	 ; save update 
0645			 
0645				if DEBUG_STORESE 
0645 11 62 f8				ld de, store_page 
0648					DMARK "SCC" 
0648 f5				push af  
0649 3a 5d 06			ld a, (.dmark)  
064c 32 77 fb			ld (debug_mark),a  
064f 3a 5e 06			ld a, (.dmark+1)  
0652 32 78 fb			ld (debug_mark+1),a  
0655 3a 5f 06			ld a, (.dmark+2)  
0658 32 79 fb			ld (debug_mark+2),a  
065b 18 03			jr .pastdmark  
065d ..			.dmark: db "SCC"  
0660 f1			.pastdmark: pop af  
0661			endm  
# End of macro DMARK
0661					CALLMONITOR 
0661 cd 04 13			call break_point_state  
0664				endm  
# End of macro CALLMONITOR
0664				endif 
0664				;  
0664				 
0664 21 40 00			ld hl, STORE_BLOCK_PHY 
0667 11 00 00			ld de, 0 
066a cd 7a 05			call storage_findnextid 
066d			 
066d 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
0670			 
0670				; TODO detect 0 = no spare blocks 
0670			 
0670				; hl now contains the free page to use for the file header page 
0670			 
0670				if DEBUG_STORESE 
0670				DMARK "SCF" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 77 fb			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 78 fb			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 79 fb			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "SCF"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd 04 13			call break_point_state  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c			 
068c 22 60 f8			ld (store_tmppageid), hl 
068f				 
068f 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0692			;	ld a, (store_filecache)			; save to cache 
0692			 
0692 32 62 f8			ld (store_page),a    ; set page id 
0695 3e 00			ld a, 0			 ; extent 0 is file header 
0697 32 63 f8			ld (store_page+1), a   ; set file extent 
069a			 
069a 32 64 f8			ld (store_page+2), a   ; extent count for the file 
069d			 
069d			;	inc hl 		; init block 0 of file 
069d			;	inc hl   		; skip file and extent id 
069d			 ;       ld a, 0 
069d			;	ld (hl),a 
069d			;	ld a, (store_filecache+1)  	; save to cache 
069d			 
069d			;	inc hl    ; file name 
069d				 
069d				 
069d 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
06a0				if DEBUG_STORESE 
06a0					DMARK "SCc" 
06a0 f5				push af  
06a1 3a b5 06			ld a, (.dmark)  
06a4 32 77 fb			ld (debug_mark),a  
06a7 3a b6 06			ld a, (.dmark+1)  
06aa 32 78 fb			ld (debug_mark+1),a  
06ad 3a b7 06			ld a, (.dmark+2)  
06b0 32 79 fb			ld (debug_mark+2),a  
06b3 18 03			jr .pastdmark  
06b5 ..			.dmark: db "SCc"  
06b8 f1			.pastdmark: pop af  
06b9			endm  
# End of macro DMARK
06b9					CALLMONITOR 
06b9 cd 04 13			call break_point_state  
06bc				endm  
# End of macro CALLMONITOR
06bc				endif 
06bc e1				pop hl    ; get zero term string 
06bd e5				push hl 
06be 3e 00			ld a, 0 
06c0 cd 7f 0f			call strlent 
06c3 23				inc hl   ; cover zero term 
06c4 06 00			ld b,0 
06c6 4d				ld c,l 
06c7 e1				pop hl 
06c8				;ex de, hl 
06c8				if DEBUG_STORESE 
06c8					DMARK "SCa" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 77 fb			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 78 fb			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 79 fb			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "SCa"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1					;push af 
06e1					;ld a, 'a' 
06e1					;ld (debug_mark),a 
06e1					;pop af 
06e1					CALLMONITOR 
06e1 cd 04 13			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4				endif 
06e4 ed b0			ldir    ; copy zero term string 
06e6				if DEBUG_STORESE 
06e6					DMARK "SCA" 
06e6 f5				push af  
06e7 3a fb 06			ld a, (.dmark)  
06ea 32 77 fb			ld (debug_mark),a  
06ed 3a fc 06			ld a, (.dmark+1)  
06f0 32 78 fb			ld (debug_mark+1),a  
06f3 3a fd 06			ld a, (.dmark+2)  
06f6 32 79 fb			ld (debug_mark+2),a  
06f9 18 03			jr .pastdmark  
06fb ..			.dmark: db "SCA"  
06fe f1			.pastdmark: pop af  
06ff			endm  
# End of macro DMARK
06ff					CALLMONITOR 
06ff cd 04 13			call break_point_state  
0702				endm  
# End of macro CALLMONITOR
0702				endif 
0702			 
0702				; write file header page 
0702			 
0702 2a 60 f8			ld hl,(store_tmppageid) 
0705 11 62 f8			ld de, store_page 
0708				if DEBUG_STORESE 
0708					DMARK "SCb" 
0708 f5				push af  
0709 3a 1d 07			ld a, (.dmark)  
070c 32 77 fb			ld (debug_mark),a  
070f 3a 1e 07			ld a, (.dmark+1)  
0712 32 78 fb			ld (debug_mark+1),a  
0715 3a 1f 07			ld a, (.dmark+2)  
0718 32 79 fb			ld (debug_mark+2),a  
071b 18 03			jr .pastdmark  
071d ..			.dmark: db "SCb"  
0720 f1			.pastdmark: pop af  
0721			endm  
# End of macro DMARK
0721					;push af 
0721					;ld a, 'b' 
0721					;ld (debug_mark),a 
0721					;pop af 
0721					CALLMONITOR 
0721 cd 04 13			call break_point_state  
0724				endm  
# End of macro CALLMONITOR
0724				endif 
0724 cd 55 03			call storage_write_block 
0727			 
0727 3a 5b f8			ld a, (store_tmpid) 
072a 6f				ld l, a 
072b 26 00			ld h,0 
072d				if DEBUG_STORESE 
072d					DMARK "SCz" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCz"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 04 13			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 c9				ret 
074a				 
074a			 
074a			 
074a			; 
074a			; Read File 
074a			; 
074a			; h - file id to locate 
074a			; l - extent to locate 
074a			; de - pointer to string to read into 
074a			; 
074a			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
074a			storage_read: 
074a d5				push de 
074b			 
074b			; TODO BUG the above push is it popped before the RET Z? 
074b			 
074b			; TODO how to handle multiple part blocks 
074b			 
074b				; locate file extent to read 
074b			 
074b 5c				ld e, h 
074c 55				ld d, l 
074d 21 40 00			ld hl, STORE_BLOCK_PHY 
0750				if DEBUG_STORESE 
0750					DMARK "SRE" 
0750 f5				push af  
0751 3a 65 07			ld a, (.dmark)  
0754 32 77 fb			ld (debug_mark),a  
0757 3a 66 07			ld a, (.dmark+1)  
075a 32 78 fb			ld (debug_mark+1),a  
075d 3a 67 07			ld a, (.dmark+2)  
0760 32 79 fb			ld (debug_mark+2),a  
0763 18 03			jr .pastdmark  
0765 ..			.dmark: db "SRE"  
0768 f1			.pastdmark: pop af  
0769			endm  
# End of macro DMARK
0769					CALLMONITOR 
0769 cd 04 13			call break_point_state  
076c				endm  
# End of macro CALLMONITOR
076c				endif 
076c cd 7a 05			call storage_findnextid 
076f			 
076f				if DEBUG_STORESE 
076f					DMARK "SRf" 
076f f5				push af  
0770 3a 84 07			ld a, (.dmark)  
0773 32 77 fb			ld (debug_mark),a  
0776 3a 85 07			ld a, (.dmark+1)  
0779 32 78 fb			ld (debug_mark+1),a  
077c 3a 86 07			ld a, (.dmark+2)  
077f 32 79 fb			ld (debug_mark+2),a  
0782 18 03			jr .pastdmark  
0784 ..			.dmark: db "SRf"  
0787 f1			.pastdmark: pop af  
0788			endm  
# End of macro DMARK
0788					CALLMONITOR 
0788 cd 04 13			call break_point_state  
078b				endm  
# End of macro CALLMONITOR
078b				endif 
078b cd 3f 0b			call ishlzero 
078e			;	ld a, l 
078e			;	add h 
078e			;	cp 0 
078e c8				ret z			; block not found so EOF 
078f			 
078f				; hl contains page number to load 
078f d1				pop de   ; get storage 
0790 d5				push de 
0791				if DEBUG_STORESE 
0791					DMARK "SRg" 
0791 f5				push af  
0792 3a a6 07			ld a, (.dmark)  
0795 32 77 fb			ld (debug_mark),a  
0798 3a a7 07			ld a, (.dmark+1)  
079b 32 78 fb			ld (debug_mark+1),a  
079e 3a a8 07			ld a, (.dmark+2)  
07a1 32 79 fb			ld (debug_mark+2),a  
07a4 18 03			jr .pastdmark  
07a6 ..			.dmark: db "SRg"  
07a9 f1			.pastdmark: pop af  
07aa			endm  
# End of macro DMARK
07aa					CALLMONITOR 
07aa cd 04 13			call break_point_state  
07ad				endm  
# End of macro CALLMONITOR
07ad				endif 
07ad cd 0c 03			call storage_read_block 
07b0			 
07b0			 
07b0			; TODO if block has no zeros then need to read next block  
07b0			 
07b0			 
07b0					 
07b0 e1				pop hl 		 ; return start of data to show as not EOF 
07b1 23				inc hl   ; past file id 
07b2 23				inc hl   ; past ext 
07b3				if DEBUG_STORESE 
07b3					DMARK "SRe" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 77 fb			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 78 fb			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 79 fb			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SRe"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 04 13			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9					ret 
07d0			 
07d0			 
07d0			 
07d0			; 
07d0			; Append File 
07d0			; 
07d0			; hl - file id to locate 
07d0			; de - pointer to (multi block) string to write 
07d0			 
07d0			 
07d0			storage_append: 
07d0				; hl -  file id to append to 
07d0				; de - string to append 
07d0			 
07d0 d5				push de 
07d1				 
07d1				if DEBUG_STORESE 
07d1					DMARK "AP1" 
07d1 f5				push af  
07d2 3a e6 07			ld a, (.dmark)  
07d5 32 77 fb			ld (debug_mark),a  
07d8 3a e7 07			ld a, (.dmark+1)  
07db 32 78 fb			ld (debug_mark+1),a  
07de 3a e8 07			ld a, (.dmark+2)  
07e1 32 79 fb			ld (debug_mark+2),a  
07e4 18 03			jr .pastdmark  
07e6 ..			.dmark: db "AP1"  
07e9 f1			.pastdmark: pop af  
07ea			endm  
# End of macro DMARK
07ea					CALLMONITOR 
07ea cd 04 13			call break_point_state  
07ed				endm  
# End of macro CALLMONITOR
07ed				endif 
07ed			 
07ed 7d				ld a, l 
07ee 32 5b f8			ld (store_tmpid), a 
07f1			 
07f1				; get file header  
07f1			 
07f1 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07f3 3a 5b f8			ld a, (store_tmpid) 
07f6 5f				ld e, a 
07f7			 
07f7 21 40 00				ld hl, STORE_BLOCK_PHY 
07fa cd 7a 05				call storage_findnextid 
07fd			 
07fd 22 60 f8			ld (store_tmppageid), hl 
0800			 
0800				; TODO handle file id not found 
0800			 
0800				if DEBUG_STORESE 
0800					DMARK "AP2" 
0800 f5				push af  
0801 3a 15 08			ld a, (.dmark)  
0804 32 77 fb			ld (debug_mark),a  
0807 3a 16 08			ld a, (.dmark+1)  
080a 32 78 fb			ld (debug_mark+1),a  
080d 3a 17 08			ld a, (.dmark+2)  
0810 32 79 fb			ld (debug_mark+2),a  
0813 18 03			jr .pastdmark  
0815 ..			.dmark: db "AP2"  
0818 f1			.pastdmark: pop af  
0819			endm  
# End of macro DMARK
0819					CALLMONITOR 
0819 cd 04 13			call break_point_state  
081c				endm  
# End of macro CALLMONITOR
081c				endif 
081c			 
081c				; update file extent count 
081c			 
081c 11 62 f8			ld de, store_page 
081f			 
081f cd 0c 03			call storage_read_block 
0822			 
0822				if DEBUG_STORESE 
0822					DMARK "AP3" 
0822 f5				push af  
0823 3a 37 08			ld a, (.dmark)  
0826 32 77 fb			ld (debug_mark),a  
0829 3a 38 08			ld a, (.dmark+1)  
082c 32 78 fb			ld (debug_mark+1),a  
082f 3a 39 08			ld a, (.dmark+2)  
0832 32 79 fb			ld (debug_mark+2),a  
0835 18 03			jr .pastdmark  
0837 ..			.dmark: db "AP3"  
083a f1			.pastdmark: pop af  
083b			endm  
# End of macro DMARK
083b					CALLMONITOR 
083b cd 04 13			call break_point_state  
083e				endm  
# End of macro CALLMONITOR
083e				endif 
083e			;	ld (store_tmppageid), hl 
083e			 
083e 3a 64 f8			ld a, (store_page+2) 
0841 3c				inc a 
0842 32 64 f8			ld (store_page+2), a 
0845 32 5a f8			ld (store_tmpext), a 
0848				 
0848				if DEBUG_STORESE 
0848					DMARK "AP3" 
0848 f5				push af  
0849 3a 5d 08			ld a, (.dmark)  
084c 32 77 fb			ld (debug_mark),a  
084f 3a 5e 08			ld a, (.dmark+1)  
0852 32 78 fb			ld (debug_mark+1),a  
0855 3a 5f 08			ld a, (.dmark+2)  
0858 32 79 fb			ld (debug_mark+2),a  
085b 18 03			jr .pastdmark  
085d ..			.dmark: db "AP3"  
0860 f1			.pastdmark: pop af  
0861			endm  
# End of macro DMARK
0861					CALLMONITOR 
0861 cd 04 13			call break_point_state  
0864				endm  
# End of macro CALLMONITOR
0864				endif 
0864 2a 60 f8			ld hl, (store_tmppageid) 
0867 11 62 f8			ld de, store_page 
086a cd 55 03			call storage_write_block 
086d			 
086d				; find free block 
086d			 
086d 11 00 00			ld de, 0			 ; file extent to locate 
0870			 
0870 21 40 00				ld hl, STORE_BLOCK_PHY 
0873 cd 7a 05				call storage_findnextid 
0876			 
0876					; TODO handle no space left 
0876					 
0876 22 60 f8				ld (store_tmppageid), hl 
0879			 
0879				if DEBUG_STORESE 
0879					DMARK "AP4" 
0879 f5				push af  
087a 3a 8e 08			ld a, (.dmark)  
087d 32 77 fb			ld (debug_mark),a  
0880 3a 8f 08			ld a, (.dmark+1)  
0883 32 78 fb			ld (debug_mark+1),a  
0886 3a 90 08			ld a, (.dmark+2)  
0889 32 79 fb			ld (debug_mark+2),a  
088c 18 03			jr .pastdmark  
088e ..			.dmark: db "AP4"  
0891 f1			.pastdmark: pop af  
0892			endm  
# End of macro DMARK
0892					CALLMONITOR 
0892 cd 04 13			call break_point_state  
0895				endm  
# End of macro CALLMONITOR
0895				endif 
0895					; init the buffer with zeros so we can id if the buffer is full or not 
0895			 
0895 e5					push hl 
0896 c5					push bc 
0897			 
0897 21 62 f8				ld hl, store_page 
089a 06 40				ld b, STORE_BLOCK_PHY 
089c 3e 00				ld a, 0 
089e 77			.zeroblock:	ld (hl), a 
089f 23					inc hl 
08a0 10 fc				djnz .zeroblock 
08a2			 
08a2 c1					pop bc 
08a3 e1					pop hl 
08a4			 
08a4					; construct block 
08a4			 
08a4 3a 5b f8				ld a, (store_tmpid) 
08a7 32 62 f8				ld (store_page), a   ; file id 
08aa 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
08ad 32 63 f8				ld (store_page+1), a 
08b0			 
08b0 e1					pop hl    ; get string to write 
08b1 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
08b3 11 64 f8				ld de, store_page+2 
08b6			 
08b6				if DEBUG_STORESE 
08b6					DMARK "AP5" 
08b6 f5				push af  
08b7 3a cb 08			ld a, (.dmark)  
08ba 32 77 fb			ld (debug_mark),a  
08bd 3a cc 08			ld a, (.dmark+1)  
08c0 32 78 fb			ld (debug_mark+1),a  
08c3 3a cd 08			ld a, (.dmark+2)  
08c6 32 79 fb			ld (debug_mark+2),a  
08c9 18 03			jr .pastdmark  
08cb ..			.dmark: db "AP5"  
08ce f1			.pastdmark: pop af  
08cf			endm  
# End of macro DMARK
08cf					CALLMONITOR 
08cf cd 04 13			call break_point_state  
08d2				endm  
# End of macro CALLMONITOR
08d2				endif 
08d2			 
08d2			 
08d2			 
08d2					; fill buffer with data until end of string or full block 
08d2			 
08d2 7e			.appd:		ld a, (hl) 
08d3 12					ld (de), a 
08d4 fe 00				cp 0 
08d6 28 04				jr z, .appdone 
08d8 23					inc hl 
08d9 13					inc de 
08da 10 f6				djnz .appd 
08dc			 
08dc e5			.appdone:	push hl		 	; save current source in case we need to go around again 
08dd f5					push af   		; save last byte dumped 
08de			 
08de			 
08de 2a 60 f8			ld hl, (store_tmppageid) 
08e1 11 62 f8			ld de, store_page 
08e4				if DEBUG_STORESE 
08e4					DMARK "AP6" 
08e4 f5				push af  
08e5 3a f9 08			ld a, (.dmark)  
08e8 32 77 fb			ld (debug_mark),a  
08eb 3a fa 08			ld a, (.dmark+1)  
08ee 32 78 fb			ld (debug_mark+1),a  
08f1 3a fb 08			ld a, (.dmark+2)  
08f4 32 79 fb			ld (debug_mark+2),a  
08f7 18 03			jr .pastdmark  
08f9 ..			.dmark: db "AP6"  
08fc f1			.pastdmark: pop af  
08fd			endm  
# End of macro DMARK
08fd					CALLMONITOR 
08fd cd 04 13			call break_point_state  
0900				endm  
# End of macro CALLMONITOR
0900				endif 
0900 cd 55 03				call storage_write_block 
0903			 
0903			 
0903				; was that a full block of data written? 
0903				; any more to write out? 
0903			 
0903				; if yes then set vars and jump to start of function again 
0903			 
0903 f1					pop af 
0904 d1					pop de 
0905			 
0905 fe 00				cp 0		 ; no, string was fully written 
0907 c8					ret z 
0908			 
0908					; setup vars for next cycle 
0908			 
0908 3a 5b f8				ld a, (store_tmpid) 
090b 6f					ld l, a 
090c 26 00				ld h, 0 
090e			 
090e c3 d0 07			 	jp storage_append	 ; yes, need to write out some more 
0911			 
0911			 
0911			 
0911			 
0911			 
0911			 
0911			 
0911			if DEBUG_STORECF 
0911			storageput:	 
0911					ret 
0911			storageread: 
0911					ld hl, store_page 
0911					ld b, 200 
0911					ld a,0 
0911			.src:		ld (hl),a 
0911					inc hl 
0911					djnz .src 
0911					 
0911			 
0911					ld de, 0 
0911					ld bc, 1 
0911					ld hl, store_page 
0911					call cfRead 
0911			 
0911				call cfGetError 
0911				ld hl,scratch 
0911				call hexout 
0911				ld hl, scratch+2 
0911				ld a, 0 
0911				ld (hl),a 
0911				ld de, scratch 
0911				ld a,display_row_1 
0911				call str_at_display 
0911				call update_display 
0911			 
0911					ld hl, store_page 
0911					ld (os_cur_ptr),hl 
0911			 
0911					ret 
0911			endif 
0911			 
0911			 
0911			; Clear out the main buffer store (used to remove junk before writing a new block) 
0911			 
0911			storage_clear_page: 
0911 e5				push hl 
0912 d5				push de 
0913 c5				push bc 
0914 21 62 f8			ld hl, store_page 
0917 3e 00			ld a, 0 
0919 77				ld (hl), a 
091a			 
091a 11 63 f8			ld de, store_page+1 
091d 01 40 00			ld bc, STORE_BLOCK_PHY 
0920			 
0920 ed b0			ldir 
0922				 
0922 c1				pop bc 
0923 d1				pop de 
0924 e1				pop hl 
0925 c9				ret 
0926			 
0926			; eof 
# End of file firmware_storage.asm
0926			  
0926			; support routines for above hardware abstraction layer  
0926			  
0926			include "firmware_general.asm"        ; general support functions  
0926			 
0926			 
0926			 
0926			; Delay loops 
0926			 
0926			 
0926			 
0926			aDelayInMS: 
0926 c5				push bc 
0927 47				ld b,a 
0928			msdelay: 
0928 c5				push bc 
0929				 
0929			 
0929 01 41 00			ld bc,041h 
092c cd 44 09			call delayloop 
092f c1				pop bc 
0930 05				dec b 
0931 20 f5			jr nz,msdelay 
0933			 
0933			;if CPU_CLOCK_8MHZ 
0933			;msdelay8: 
0933			;	push bc 
0933			;	 
0933			; 
0933			;	ld bc,041h 
0933			;	call delayloop 
0933			;	pop bc 
0933			;	dec b 
0933			;	jr nz,msdelay8 
0933			;endif 
0933			 
0933			 
0933 c1				pop bc 
0934 c9				ret 
0935			 
0935			 
0935			delay250ms: 
0935				;push de 
0935 01 00 40			ld bc, 04000h 
0938 c3 44 09			jp delayloop 
093b			delay500ms: 
093b				;push de 
093b 01 00 80			ld bc, 08000h 
093e c3 44 09			jp delayloop 
0941			delay1s: 
0941				;push bc 
0941			   ; Clobbers A, d and e 
0941 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0944			delayloop: 
0944 c5			    push bc 
0945			 
0945			if BASE_CPM 
0945				ld bc, CPM_DELAY_TUNE 
0945			.cpmloop: 
0945				push bc 
0945			 
0945			endif 
0945			 
0945			 
0945			 
0945			delayloopi: 
0945			;	push bc 
0945			;.dl: 
0945 cb 47		    bit     0,a    	; 8 
0947 cb 47		    bit     0,a    	; 8 
0949 cb 47		    bit     0,a    	; 8 
094b e6 ff		    and     255  	; 7 
094d 0b			    dec     bc      	; 6 
094e 79			    ld      a,c     	; 4 
094f b0			    or      b     	; 4 
0950 c2 45 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0953			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0953				;pop de 
0953			;pop bc 
0953			 
0953			if BASE_CPM 
0953				pop bc 
0953				 
0953			    dec     bc      	; 6 
0953			    ld      a,c     	; 4 
0953			    or      b     	; 4 
0953			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0953				 
0953			 
0953			endif 
0953			;if CPU_CLOCK_8MHZ 
0953			;    pop bc 
0953			;    push bc 
0953			;.dl8: 
0953			;    bit     0,a    	; 8 
0953			;    bit     0,a    	; 8 
0953			;    bit     0,a    	; 8 
0953			;    and     255  	; 7 
0953			;    dec     bc      	; 6 
0953			;    ld      a,c     	; 4 
0953			;    or      b     	; 4 
0953			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0953			;endif 
0953			 
0953			;if CPU_CLOCK_10MHZ 
0953			;    pop bc 
0953			;    push bc 
0953			;.dl8: 
0953			;    bit     0,a    	; 8 
0953			;    bit     0,a    	; 8 
0953			;    bit     0,a    	; 8 
0953			;    and     255  	; 7 
0953			;    dec     bc      	; 6 
0953			;    ld      a,c     	; 4 
0953			;    or      b     	; 4 
0953			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0953			;endif 
0953 c1			    pop bc 
0954			 
0954 c9				ret 
0955			 
0955			 
0955			 
0955			; eof 
# End of file firmware_general.asm
0955			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0955			; display routines that use the physical hardware abstraction layer 
0955			 
0955			 
0955			; TODO windowing? 
0955			 
0955			; TODO scroll line up 
0955			 
0955			scroll_up: 
0955			 
0955 e5				push hl 
0956 d5				push de 
0957 c5				push bc 
0958			 
0958				; get frame buffer  
0958			 
0958 2a d8 f8			ld hl, (display_fb_active) 
095b e5				push hl    ; future de destination 
095c			 
095c 11 28 00			ld  de, display_cols 
095f 19				add hl, de 
0960			 
0960 d1				pop de 
0961			 
0961				;ex de, hl 
0961 01 9f 00			ld bc, display_fb_len -1  
0964			;if DEBUG_FORTH_WORDS 
0964			;	DMARK "SCL" 
0964			;	CALLMONITOR 
0964			;endif	 
0964 ed b0			ldir 
0966			 
0966				; wipe bottom row 
0966			 
0966			 
0966 2a d8 f8			ld hl, (display_fb_active) 
0969 11 a0 00			ld de, display_cols*display_rows 
096c 19				add hl, de 
096d 06 28			ld b, display_cols 
096f 3e 20			ld a, ' ' 
0971			.scwipe: 
0971 77				ld (hl), a 
0972 2b				dec hl 
0973 10 fc			djnz .scwipe 
0975			 
0975				;pop hl 
0975			 
0975 c1				pop bc 
0976 d1				pop de 
0977 e1				pop hl 
0978			 
0978 c9				ret 
0979			 
0979			 
0979			scroll_upo: 
0979 11 00 00			ld de, display_row_1 
097c 21 28 00		 	ld hl, display_row_2 
097f 01 28 00			ld bc, display_cols 
0982 ed b0			ldir 
0984 11 28 00			ld de, display_row_2 
0987 21 50 00		 	ld hl, display_row_3 
098a 01 28 00			ld bc, display_cols 
098d ed b0			ldir 
098f 11 50 00			ld de, display_row_3 
0992 21 78 00		 	ld hl, display_row_4 
0995 01 28 00			ld bc, display_cols 
0998 ed b0			ldir 
099a			 
099a			; TODO clear row 4 
099a			 
099a c9				ret 
099b				 
099b			scroll_down: 
099b 11 78 00			ld de, display_row_4 
099e 21 50 00		 	ld hl, display_row_3 
09a1 01 28 00			ld bc, display_cols 
09a4 ed b0			ldir 
09a6 11 50 00			ld de, display_row_3 
09a9 21 28 00		 	ld hl, display_row_2 
09ac 01 28 00			ld bc, display_cols 
09af ed b0			ldir 
09b1 11 28 00			ld de, display_row_2 
09b4 21 00 00		 	ld hl, display_row_1 
09b7 01 28 00			ld bc, display_cols 
09ba ed b0			ldir 
09bc			; TODO clear row 1 
09bc c9				ret 
09bd			 
09bd			 
09bd			 
09bd			 
09bd			 
09bd			; clear active frame buffer 
09bd			 
09bd			clear_display: 
09bd 3e 20			ld a, ' ' 
09bf c3 c2 09			jp fill_display 
09c2			 
09c2			; fill active frame buffer with a char in A 
09c2			 
09c2			fill_display: 
09c2 06 a0			ld b,display_fb_len 
09c4 2a d8 f8			ld hl, (display_fb_active) 
09c7 77			.fd1:	ld (hl),a 
09c8 23				inc hl 
09c9 10 fc			djnz .fd1 
09cb 23				inc hl 
09cc 3e 00			ld a,0 
09ce 77				ld (hl),a 
09cf			 
09cf			 
09cf c9				ret 
09d0			; Write string (DE) at pos (A) to active frame buffer 
09d0			 
09d0 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
09d3 06 00					ld b,0 
09d5 4f					ld c,a 
09d6 09					add hl,bc 
09d7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09d8 b7			            OR   A              ;Null terminator? 
09d9 c8			            RET  Z              ;Yes, so finished 
09da 77					ld (hl),a 
09db 23				inc hl 
09dc 13			            INC  DE             ;Point to next character 
09dd 18 f8		            JR   .sad1     ;Repeat 
09df c9					ret 
09e0			 
09e0			; using current frame buffer write to physical display 
09e0			 
09e0			update_display: 
09e0 e5				push hl 
09e1 2a d8 f8			ld hl, (display_fb_active) 
09e4 cd e1 51			call write_display 
09e7 e1				pop hl 
09e8 c9				ret 
09e9			 
09e9			; TODO scrolling 
09e9			 
09e9			 
09e9			; move cursor right one char 
09e9			cursor_right: 
09e9			 
09e9				; TODO shift right 
09e9				; TODO if beyond max col 
09e9				; TODO       cursor_next_line 
09e9			 
09e9 c9				ret 
09ea			 
09ea			 
09ea			cursor_next_line: 
09ea				; TODO first char 
09ea				; TODO line down 
09ea				; TODO if past last row 
09ea				; TODO    scroll up 
09ea			 
09ea c9				ret 
09eb			 
09eb			cursor_left: 
09eb				; TODO shift left 
09eb				; TODO if beyond left  
09eb				; TODO     cursor prev line 
09eb				 
09eb c9				ret 
09ec			 
09ec			cursor_prev_line: 
09ec				; TODO last char 
09ec				; TODO line up 
09ec				; TODO if past first row 
09ec				; TODO   scroll down 
09ec			 
09ec c9				ret 
09ed			 
09ed			 
09ed			cout: 
09ed				; A - char 
09ed c9				ret 
09ee			 
09ee			; eof 
09ee			 
# End of file firmware_display.asm
09ee			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
09ee			; random number generators 
09ee			 
09ee			 
09ee			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
09ee			 
09ee			 
09ee			;-----> Generate a random number 
09ee			; output a=answer 0<=a<=255 
09ee			; all registers are preserved except: af 
09ee			random: 
09ee e5			        push    hl 
09ef d5			        push    de 
09f0 2a ba f8		        ld      hl,(randData) 
09f3 ed 5f		        ld      a,r 
09f5 57			        ld      d,a 
09f6 5e			        ld      e,(hl) 
09f7 19			        add     hl,de 
09f8 85			        add     a,l 
09f9 ac			        xor     h 
09fa 22 ba f8		        ld      (randData),hl 
09fd d1			        pop     de 
09fe e1			        pop     hl 
09ff c9			        ret 
0a00			 
0a00			 
0a00			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a00			 
0a00			 
0a00			 
0a00			;------LFSR------ 
0a00			;James Montelongo 
0a00			;optimized by Spencer Putt 
0a00			;out: 
0a00			; a = 8 bit random number 
0a00			RandLFSR: 
0a00 21 c0 f8		        ld hl,LFSRSeed+4 
0a03 5e			        ld e,(hl) 
0a04 23			        inc hl 
0a05 56			        ld d,(hl) 
0a06 23			        inc hl 
0a07 4e			        ld c,(hl) 
0a08 23			        inc hl 
0a09 7e			        ld a,(hl) 
0a0a 47			        ld b,a 
0a0b cb 13		        rl e  
0a0d cb 12			rl d 
0a0f cb 11		        rl c  
0a11 17				rla 
0a12 cb 13		        rl e  
0a14 cb 12			rl d 
0a16 cb 11		        rl c  
0a18 17				rla 
0a19 cb 13		        rl e  
0a1b cb 12			rl d 
0a1d cb 11		        rl c  
0a1f 17				rla 
0a20 67			        ld h,a 
0a21 cb 13		        rl e  
0a23 cb 12			rl d 
0a25 cb 11		        rl c  
0a27 17				rla 
0a28 a8			        xor b 
0a29 cb 13		        rl e  
0a2b cb 12			rl d 
0a2d ac			        xor h 
0a2e a9			        xor c 
0a2f aa			        xor d 
0a30 21 c2 f8		        ld hl,LFSRSeed+6 
0a33 11 c3 f8		        ld de,LFSRSeed+7 
0a36 01 07 00		        ld bc,7 
0a39 ed b8		        lddr 
0a3b 12			        ld (de),a 
0a3c c9			        ret 
0a3d			 
0a3d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0a3d			 
0a3d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0a3d			 
0a3d			 
0a3d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0a3d			 
0a3d			prng16: 
0a3d			;Inputs: 
0a3d			;   (seed1) contains a 16-bit seed value 
0a3d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0a3d			;Outputs: 
0a3d			;   HL is the result 
0a3d			;   BC is the result of the LCG, so not that great of quality 
0a3d			;   DE is preserved 
0a3d			;Destroys: 
0a3d			;   AF 
0a3d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0a3d			;160cc 
0a3d			;26 bytes 
0a3d 2a b4 f8		    ld hl,(seed1) 
0a40 44			    ld b,h 
0a41 4d			    ld c,l 
0a42 29			    add hl,hl 
0a43 29			    add hl,hl 
0a44 2c			    inc l 
0a45 09			    add hl,bc 
0a46 22 b4 f8		    ld (seed1),hl 
0a49 2a b2 f8		    ld hl,(seed2) 
0a4c 29			    add hl,hl 
0a4d 9f			    sbc a,a 
0a4e e6 2d		    and %00101101 
0a50 ad			    xor l 
0a51 6f			    ld l,a 
0a52 22 b2 f8		    ld (seed2),hl 
0a55 09			    add hl,bc 
0a56 c9			    ret 
0a57			 
0a57			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0a57			 
0a57			rand32: 
0a57			;Inputs: 
0a57			;   (seed1_0) holds the lower 16 bits of the first seed 
0a57			;   (seed1_1) holds the upper 16 bits of the first seed 
0a57			;   (seed2_0) holds the lower 16 bits of the second seed 
0a57			;   (seed2_1) holds the upper 16 bits of the second seed 
0a57			;   **NOTE: seed2 must be non-zero 
0a57			;Outputs: 
0a57			;   HL is the result 
0a57			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0a57			;Destroys: 
0a57			;   AF 
0a57			;Tested and passes all CAcert tests 
0a57			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0a57			;it has a period of 18,446,744,069,414,584,320 
0a57			;roughly 18.4 quintillion. 
0a57			;LFSR taps: 0,2,6,7  = 11000101 
0a57			;291cc 
0a57			;seed1_0=$+1 
0a57			;    ld hl,12345 
0a57			;seed1_1=$+1 
0a57			;    ld de,6789 
0a57			;    ld b,h 
0a57			;    ld c,l 
0a57			;    add hl,hl \ rl e \ rl d 
0a57			;    add hl,hl \ rl e \ rl d 
0a57			;    inc l 
0a57			;    add hl,bc 
0a57			;    ld (seed1_0),hl 
0a57			;    ld hl,(seed1_1) 
0a57			;    adc hl,de 
0a57			;    ld (seed1_1),hl 
0a57			;    ex de,hl 
0a57			;seed2_0=$+1 
0a57			;    ld hl,9876 
0a57			;seed2_1=$+1 
0a57			;    ld bc,54321 
0a57			;    add hl,hl \ rl c \ rl b 
0a57			;    ld (seed2_1),bc 
0a57			;    sbc a,a 
0a57			;    and %11000101 
0a57			;    xor l 
0a57			;    ld l,a 
0a57			;    ld (seed2_0),hl 
0a57			;    ex de,hl 
0a57			;    add hl,bc 
0a57			;    ret 
0a57			; 
0a57			 
0a57			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0a57			; 20 bytes, 86 cycles (excluding ret) 
0a57			 
0a57			; returns   hl = pseudorandom number 
0a57			; corrupts   a 
0a57			 
0a57			; generates 16-bit pseudorandom numbers with a period of 65535 
0a57			; using the xorshift method: 
0a57			 
0a57			; hl ^= hl << 7 
0a57			; hl ^= hl >> 9 
0a57			; hl ^= hl << 8 
0a57			 
0a57			; some alternative shift triplets which also perform well are: 
0a57			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0a57			 
0a57			;  org 32768 
0a57			 
0a57			xrnd: 
0a57 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0a5a 3e 00		  ld a,0 
0a5c bd			  cp l 
0a5d 20 02		  jr nz, .xrnd1 
0a5f 2e 01		  ld l, 1 
0a61			.xrnd1: 
0a61			 
0a61 7c			  ld a,h 
0a62 1f			  rra 
0a63 7d			  ld a,l 
0a64 1f			  rra 
0a65 ac			  xor h 
0a66 67			  ld h,a 
0a67 7d			  ld a,l 
0a68 1f			  rra 
0a69 7c			  ld a,h 
0a6a 1f			  rra 
0a6b ad			  xor l 
0a6c 6f			  ld l,a 
0a6d ac			  xor h 
0a6e 67			  ld h,a 
0a6f			 
0a6f 22 b8 f8		  ld (xrandc),hl 
0a72			 
0a72 c9			  ret 
0a73			;  
0a73			 
0a73			 
0a73			;;;; int maths 
0a73			 
0a73			; https://map.grauw.nl/articles/mult_div_shifts.php 
0a73			; Divide 16-bit values (with 16-bit result) 
0a73			; In: Divide BC by divider DE 
0a73			; Out: BC = result, HL = rest 
0a73			; 
0a73			Div16: 
0a73 21 00 00		    ld hl,0 
0a76 78			    ld a,b 
0a77 06 08		    ld b,8 
0a79			Div16_Loop1: 
0a79 17			    rla 
0a7a ed 6a		    adc hl,hl 
0a7c ed 52		    sbc hl,de 
0a7e 30 01		    jr nc,Div16_NoAdd1 
0a80 19			    add hl,de 
0a81			Div16_NoAdd1: 
0a81 10 f6		    djnz Div16_Loop1 
0a83 17			    rla 
0a84 2f			    cpl 
0a85 47			    ld b,a 
0a86 79			    ld a,c 
0a87 48			    ld c,b 
0a88 06 08		    ld b,8 
0a8a			Div16_Loop2: 
0a8a 17			    rla 
0a8b ed 6a		    adc hl,hl 
0a8d ed 52		    sbc hl,de 
0a8f 30 01		    jr nc,Div16_NoAdd2 
0a91 19			    add hl,de 
0a92			Div16_NoAdd2: 
0a92 10 f6		    djnz Div16_Loop2 
0a94 17			    rla 
0a95 2f			    cpl 
0a96 41			    ld b,c 
0a97 4f			    ld c,a 
0a98 c9			ret 
0a99			 
0a99			 
0a99			;http://z80-heaven.wikidot.com/math 
0a99			; 
0a99			;Inputs: 
0a99			;     DE and A are factors 
0a99			;Outputs: 
0a99			;     A is not changed 
0a99			;     B is 0 
0a99			;     C is not changed 
0a99			;     DE is not changed 
0a99			;     HL is the product 
0a99			;Time: 
0a99			;     342+6x 
0a99			; 
0a99			Mult16: 
0a99			 
0a99 06 08		     ld b,8          ;7           7 
0a9b 21 00 00		     ld hl,0         ;10         10 
0a9e 29			       add hl,hl     ;11*8       88 
0a9f 07			       rlca          ;4*8        32 
0aa0 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0aa2 19			         add hl,de   ;--         -- 
0aa3 10 f9		       djnz $-5      ;13*7+8     99 
0aa5 c9			ret 
0aa6			 
0aa6			; 
0aa6			; Square root of 16-bit value 
0aa6			; In:  HL = value 
0aa6			; Out:  D = result (rounded down) 
0aa6			; 
0aa6			;Sqr16: 
0aa6			;    ld de,#0040 
0aa6			;    ld a,l 
0aa6			;    ld l,h 
0aa6			;    ld h,d 
0aa6			;    or a 
0aa6			;    ld b,8 
0aa6			;Sqr16_Loop: 
0aa6			;    sbc hl,de 
0aa6			;    jr nc,Sqr16_Skip 
0aa6			;    add hl,de 
0aa6			;Sqr16_Skip: 
0aa6			;    ccf 
0aa6			;    rl d 
0aa6			;    add a,a 
0aa6			;    adc hl,hl 
0aa6			;    add a,a 
0aa6			;    adc hl,hl 
0aa6			;    djnz Sqr16_Loop 
0aa6			;    ret 
0aa6			; 
0aa6			; 
0aa6			; Divide 8-bit values 
0aa6			; In: Divide E by divider C 
0aa6			; Out: A = result, B = rest 
0aa6			; 
0aa6			Div8: 
0aa6 af			    xor a 
0aa7 06 08		    ld b,8 
0aa9			Div8_Loop: 
0aa9 cb 13		    rl e 
0aab 17			    rla 
0aac 91			    sub c 
0aad 30 01		    jr nc,Div8_NoAdd 
0aaf 81			    add a,c 
0ab0			Div8_NoAdd: 
0ab0 10 f7		    djnz Div8_Loop 
0ab2 47			    ld b,a 
0ab3 7b			    ld a,e 
0ab4 17			    rla 
0ab5 2f			    cpl 
0ab6 c9			    ret 
0ab7			 
0ab7			; 
0ab7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ab7			; In: Multiply A with DE 
0ab7			; Out: HL = result 
0ab7			; 
0ab7			Mult12U: 
0ab7 2e 00		    ld l,0 
0ab9 87			    add a,a 
0aba 30 01		    jr nc,Mult12U_NoAdd0 
0abc 19			    add hl,de 
0abd			Mult12U_NoAdd0: 
0abd 29			    add hl,hl 
0abe 87			    add a,a 
0abf 30 01		    jr nc,Mult12U_NoAdd1 
0ac1 19			    add hl,de 
0ac2			Mult12U_NoAdd1: 
0ac2 29			    add hl,hl 
0ac3 87			    add a,a 
0ac4 30 01		    jr nc,Mult12U_NoAdd2 
0ac6 19			    add hl,de 
0ac7			Mult12U_NoAdd2: 
0ac7 29			    add hl,hl 
0ac8 87			    add a,a 
0ac9 30 01		    jr nc,Mult12U_NoAdd3 
0acb 19			    add hl,de 
0acc			Mult12U_NoAdd3: 
0acc 29			    add hl,hl 
0acd 87			    add a,a 
0ace 30 01		    jr nc,Mult12U_NoAdd4 
0ad0 19			    add hl,de 
0ad1			Mult12U_NoAdd4: 
0ad1 29			    add hl,hl 
0ad2 87			    add a,a 
0ad3 30 01		    jr nc,Mult12U_NoAdd5 
0ad5 19			    add hl,de 
0ad6			Mult12U_NoAdd5: 
0ad6 29			    add hl,hl 
0ad7 87			    add a,a 
0ad8 30 01		    jr nc,Mult12U_NoAdd6 
0ada 19			    add hl,de 
0adb			Mult12U_NoAdd6: 
0adb 29			    add hl,hl 
0adc 87			    add a,a 
0add d0			    ret nc 
0ade 19			    add hl,de 
0adf c9			    ret 
0ae0			 
0ae0			; 
0ae0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ae0			; In: Multiply A with DE 
0ae0			;      Put lowest value in A for most efficient calculation 
0ae0			; Out: HL = result 
0ae0			; 
0ae0			Mult12R: 
0ae0 21 00 00		    ld hl,0 
0ae3			Mult12R_Loop: 
0ae3 cb 3f		    srl a 
0ae5 30 01		    jr nc,Mult12R_NoAdd 
0ae7 19			    add hl,de 
0ae8			Mult12R_NoAdd: 
0ae8 cb 23		    sla e 
0aea cb 12		    rl d 
0aec b7			    or a 
0aed c2 e3 0a		    jp nz,Mult12R_Loop 
0af0 c9			    ret 
0af1			 
0af1			; 
0af1			; Multiply 16-bit values (with 32-bit result) 
0af1			; In: Multiply BC with DE 
0af1			; Out: BCHL = result 
0af1			; 
0af1			Mult32: 
0af1 79			    ld a,c 
0af2 48			    ld c,b 
0af3 21 00 00		    ld hl,0 
0af6 06 10		    ld b,16 
0af8			Mult32_Loop: 
0af8 29			    add hl,hl 
0af9 17			    rla 
0afa cb 11		    rl c 
0afc 30 07		    jr nc,Mult32_NoAdd 
0afe 19			    add hl,de 
0aff ce 00		    adc a,0 
0b01 d2 05 0b		    jp nc,Mult32_NoAdd 
0b04 0c			    inc c 
0b05			Mult32_NoAdd: 
0b05 10 f1		    djnz Mult32_Loop 
0b07 41			    ld b,c 
0b08 4f			    ld c,a 
0b09 c9			    ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Multiply 8-bit values 
0b0a			; In:  Multiply H with E 
0b0a			; Out: HL = result 
0b0a			; 
0b0a			Mult8: 
0b0a 16 00		    ld d,0 
0b0c 6a			    ld l,d 
0b0d 06 08		    ld b,8 
0b0f			Mult8_Loop: 
0b0f 29			    add hl,hl 
0b10 30 01		    jr nc,Mult8_NoAdd 
0b12 19			    add hl,de 
0b13			Mult8_NoAdd: 
0b13 10 fa		    djnz Mult8_Loop 
0b15 c9			    ret 
0b16			 
0b16			 
0b16			 
0b16			 
0b16			 
0b16			 
0b16			 
0b16			 
0b16			;;http://z80-heaven.wikidot.com/math 
0b16			;;This divides DE by BC, storing the result in DE, remainder in HL 
0b16			; 
0b16			;DE_Div_BC:          ;1281-2x, x is at most 16 
0b16			;     ld a,16        ;7 
0b16			;     ld hl,0        ;10 
0b16			;     jp $+5         ;10 
0b16			;.DivLoop: 
0b16			;       add hl,bc    ;-- 
0b16			;       dec a        ;64 
0b16			;       jr z,.DivLoopEnd        ;86 
0b16			; 
0b16			;       sla e        ;128 
0b16			;       rl d         ;128 
0b16			;       adc hl,hl    ;240 
0b16			;       sbc hl,bc    ;240 
0b16			;       jr nc,.DivLoop ;23|21 
0b16			;       inc e        ;-- 
0b16			;       jp .DivLoop+1 
0b16			; 
0b16			;.DivLoopEnd: 
0b16			 
0b16			;HL_Div_C: 
0b16			;Inputs: 
0b16			;     HL is the numerator 
0b16			;     C is the denominator 
0b16			;Outputs: 
0b16			;     A is the remainder 
0b16			;     B is 0 
0b16			;     C is not changed 
0b16			;     DE is not changed 
0b16			;     HL is the quotient 
0b16			; 
0b16			;       ld b,16 
0b16			;       xor a 
0b16			;         add hl,hl 
0b16			;         rla 
0b16			;         cp c 
0b16			;         jr c,$+4 
0b16			;           inc l 
0b16			;           sub c 
0b16			;         djnz $-7 
0b16			 
0b16			; https://plutiedev.com/z80-add-8bit-to-16bit 
0b16			 
0b16			addatohl: 
0b16 85			    add   a, l    ; A = A+L 
0b17 6f			    ld    l, a    ; L = A+L 
0b18 8c			    adc   a, h    ; A = A+L+H+carry 
0b19 95			    sub   l       ; A = H+carry 
0b1a 67			    ld    h, a    ; H = H+carry 
0b1b c9			ret 
0b1c			 
0b1c			addatode: 
0b1c 83			    add   a, e    ; A = A+L 
0b1d 5f			    ld    e, a    ; L = A+L 
0b1e 8a			    adc   a, d    ; A = A+L+H+carry 
0b1f 93			    sub   e       ; A = H+carry 
0b20 57			    ld    d, a    ; H = H+carry 
0b21 c9			ret 
0b22			 
0b22			 
0b22			addatobc: 
0b22 81			    add   a, c    ; A = A+L 
0b23 4f			    ld    c, a    ; L = A+L 
0b24 88			    adc   a, b    ; A = A+L+H+carry 
0b25 91			    sub   c       ; A = H+carry 
0b26 47			    ld    b, a    ; H = H+carry 
0b27 c9			ret 
0b28			 
0b28			subafromhl: 
0b28			   ; If A=0 do nothing 
0b28			    ; Otherwise flip A's sign. Since 
0b28			    ; the upper byte becomes -1, also 
0b28			    ; substract 1 from H. 
0b28 ed 44		    neg 
0b2a ca 33 0b		    jp    z, Skip 
0b2d 25			    dec   h 
0b2e			     
0b2e			    ; Now add the low byte as usual 
0b2e			    ; Two's complement takes care of 
0b2e			    ; ensuring the result is correct 
0b2e 85			    add   a, l 
0b2f 6f			    ld    l, a 
0b30 8c			    adc   a, h 
0b31 95			    sub   l 
0b32 67			    ld    h, a 
0b33			Skip: 
0b33 c9				ret 
0b34			 
0b34			 
0b34			; compare hl and de 
0b34			; returns:  
0b34			; if hl = de, z=1, s=0, c0=0 
0b34			; if hl > de, z=0, s=0, c=0 
0b34			; if hl < de, z=0, s=1, c=1 
0b34			cmp16:	 
0b34 b7				or a 
0b35 ed 52			sbc hl,de 
0b37 e0				ret po 
0b38 7c				ld a,h 
0b39 1f				rra 
0b3a ee 40			xor 01000000B 
0b3c 37				scf 
0b3d 8f				adc a,a 
0b3e c9				ret 
0b3f			 
0b3f			 
0b3f			; test if hl contains zero   - A is destroyed 
0b3f			 
0b3f			ishlzero:    
0b3f b7				or a     ; reset flags 
0b40 7c				ld a, h 
0b41 b5				or l        	 
0b42			 
0b42 c9				ret 
0b43			 
0b43			 
0b43			 
0b43			 
0b43			if FORTH_ENABLE_FLOATMATH 
0b43			include "float/bbcmath.z80" 
0b43			endif 
0b43			 
0b43			 
0b43			; eof 
0b43			 
# End of file firmware_maths.asm
0b43			include "firmware_strings.asm"   ; string handling  
0b43			 
0b43			 
0b43			; TODO string len 
0b43			; input text string, end on cr with zero term 
0b43			; a offset into frame buffer to start prompt 
0b43			; d is max length 
0b43			; e is display size TODO 
0b43			; c is current cursor position 
0b43			; hl is ptr to where string will be stored 
0b43			 
0b43			 
0b43			; TODO check limit of buffer for new inserts 
0b43			; TODO check insert does not push beyond buffer 
0b43			; TODO scroll in a limited display area 
0b43			; TODO scroll whole screen on page wrap 
0b43			 
0b43			 
0b43			; TODO handle KEY_PREVWORD 
0b43			; TODO handle KEY_NEXTWORD 
0b43			; TODO handle KEY_HOME 
0b43			; TODO handle KEY_END 
0b43			; TODO use LCD cursor? 
0b43			 
0b43 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0b46 81					add c 
0b47 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0b4a 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0b4d 79					ld a, c 
0b4e cd 16 0b				call addatohl 
0b51 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0b54 7a					ld a,d 
0b55 32 72 fb			        ld (input_size), a       ; save length of input area 
0b58 79					ld a, c 
0b59 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0b5c 7b					ld a,e 
0b5d 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0b60					 
0b60					 
0b60			 
0b60			;		ld a,(input_ptr) 
0b60			;		ld (input_under_cursor),a 	; save what is under the cursor 
0b60			 
0b60			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0b60					; init cursor shape if not set by the cin routines 
0b60 21 d0 f8				ld hl, cursor_shape 
0b63 3e ff				ld a, 255 
0b65 77					ld (hl), a 
0b66 23					inc hl 
0b67 3e 00				ld a, 0 
0b69 77					ld (hl), a 
0b6a			 
0b6a 3e 0f				ld a, CUR_BLINK_RATE 
0b6c 32 6c fb				ld (input_cur_flash), a 
0b6f 3e 01				ld a, 1 
0b71 32 6b fb				ld (input_cur_onoff),a 
0b74			 
0b74			;	if DEBUG_INPUT 
0b74			;		push af 
0b74			;		ld a, 'I' 
0b74			;		ld (debug_mark),a 
0b74			;		pop af 
0b74			;		CALLMONITOR 
0b74			;	endif 
0b74			.is1:		; main entry loop 
0b74			 
0b74			 
0b74			 
0b74					; pause 1ms 
0b74			 
0b74 3e 01				ld a, 1 
0b76 cd 26 09				call aDelayInMS 
0b79			 
0b79					; dec flash counter 
0b79 3a 6c fb				ld a, (input_cur_flash) 
0b7c 3d					dec a 
0b7d 32 6c fb				ld (input_cur_flash), a 
0b80 fe 00				cp 0 
0b82 20 0d				jr nz, .nochgstate 
0b84			 
0b84			 
0b84					; change state 
0b84 3a 6b fb				ld a,(input_cur_onoff) 
0b87 ed 44				neg 
0b89 32 6b fb				ld (input_cur_onoff),a 
0b8c			 
0b8c			 
0b8c					; reset on change of state 
0b8c 3e 0f				ld a, CUR_BLINK_RATE 
0b8e 32 6c fb				ld (input_cur_flash), a 
0b91			 
0b91			.nochgstate: 
0b91					 
0b91					 
0b91			 
0b91					; display cursor  
0b91			 
0b91			;		ld hl, (input_start) 
0b91			;		ld a, (input_cursor) 
0b91			;		call addatohl 
0b91			 
0b91					; get char under cursor and replace with cursor 
0b91 2a 75 fb		ld hl, (input_ptr) 
0b94			;		ld a, (hl) 
0b94			;		ld (input_under_cursor),a 
0b94			;		ld a, '_' 
0b94			;		ld (hl), a 
0b94			 
0b94					; display string 
0b94			 
0b94 ed 5b 73 fb			ld de, (input_start) 
0b98 3a 70 fb				ld a, (input_at_pos) 
0b9b cd d0 09				call str_at_display 
0b9e			;	        call update_display 
0b9e			 
0b9e					; find place to put the cursor 
0b9e			;		add h 
0b9e			;		ld l, display_row_1 
0b9e			;		sub l 
0b9e			; (input_at_pos) 
0b9e					;ld c, a 
0b9e			;		ld a, (input_cursor) 
0b9e			;		ld l, (input_at_pos) 
0b9e			;		;ld b, h 
0b9e			;		add l 
0b9e			;		ld (input_at_cursor),a 
0b9e					;ld l,h 
0b9e			 
0b9e			;		ld h, 0 
0b9e			;		ld l,(input_at_pos) 
0b9e			;		ld a, (input_cursor) 
0b9e			;		call addatohl 
0b9e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0b9e			;		call subafromhl 
0b9e			;		ld a,l 
0b9e			;		ld (input_at_cursor), a 
0b9e			 
0b9e				if DEBUG_INPUT 
0b9e					ld a, (hardware_diag) 
0b9e					cp 0 
0b9e					jr z, .skip_input_diag 
0b9e			 
0b9e					ld a,(input_at_pos) 
0b9e					ld hl, LFSRSeed 
0b9e					call hexout 
0b9e					ld a, (input_cursor) 
0b9e					ld hl, LFSRSeed+2 
0b9e					call hexout 
0b9e					ld a,(input_at_cursor) 
0b9e					ld hl, LFSRSeed+4 
0b9e					call hexout 
0b9e			 
0b9e					ld a,(input_cur_onoff) 
0b9e					ld hl, LFSRSeed+6 
0b9e					call hexout 
0b9e			 
0b9e					ld a,(input_cur_flash) 
0b9e					ld hl, LFSRSeed+8 
0b9e					call hexout 
0b9e			 
0b9e					ld a,(input_len) 
0b9e					ld hl, LFSRSeed+10 
0b9e					call hexout 
0b9e					ld hl, LFSRSeed+12 
0b9e					ld a, 0 
0b9e					ld (hl),a 
0b9e					ld a, display_row_4 
0b9e					ld de, LFSRSeed 
0b9e					call str_at_display 
0b9e					.skip_input_diag: 
0b9e				endif 
0b9e			 
0b9e					; decide on if we are showing the cursor this time round 
0b9e			 
0b9e 3a 6b fb				ld a, (input_cur_onoff) 
0ba1 fe ff				cp 255 
0ba3 28 13				jr z, .skipcur 
0ba5			 
0ba5			 
0ba5 3a 6e fb				ld a,(input_at_cursor) 
0ba8 11 d0 f8				ld de, cursor_shape 
0bab cd d0 09				call str_at_display 
0bae			 
0bae					; save length of current input string 
0bae 2a 73 fb				ld hl, (input_start) 
0bb1 cd 74 0f				call strlenz 
0bb4 7d					ld a,l 
0bb5 32 66 fb				ld (input_len),a 
0bb8			 
0bb8			.skipcur: 
0bb8			 
0bb8 cd e0 09			        call update_display 
0bbb					 
0bbb			 
0bbb			 
0bbb					; wait 
0bbb				 
0bbb					; TODO loop without wait to flash the cursor and char under cursor	 
0bbb cd 2c 55				call cin    ; _wait 
0bbe			 
0bbe fe 00				cp 0 
0bc0 ca 74 0b				jp z, .is1 
0bc3			 
0bc3					; get ptr to char to input into 
0bc3			 
0bc3 4f					ld c,a 
0bc4 2a 73 fb				ld hl, (input_start) 
0bc7 3a 61 fb				ld a, (input_cursor) 
0bca cd 16 0b				call addatohl 
0bcd 22 75 fb				ld (input_ptr), hl 
0bd0 79					ld a,c 
0bd1			 
0bd1					; replace char under cursor 
0bd1			 
0bd1			;		ld hl, (input_ptr) 
0bd1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0bd1			;		ld (hl), a 
0bd1			 
0bd1			;	if DEBUG_INPUT 
0bd1			;		push af 
0bd1			;		ld a, 'i' 
0bd1			;		ld (debug_mark),a 
0bd1			;		pop af 
0bd1			;		CALLMONITOR 
0bd1			;	endif 
0bd1 fe 0e				cp KEY_HOME 
0bd3 20 0e				jr nz, .iske 
0bd5			 
0bd5 3a 70 fb				ld a, (input_at_pos) 
0bd8 32 6e fb				ld (input_at_cursor),a 
0bdb 3e 00				ld a, 0 
0bdd 32 61 fb				ld (input_cursor), a 
0be0 c3 74 0b				jp .is1 
0be3					 
0be3 fe 0f		.iske:		cp KEY_END 
0be5 20 03				jr nz, .isknw 
0be7 c3 74 0b				jp .is1 
0bea			 
0bea fe 06		.isknw:		cp KEY_NEXTWORD 
0bec 20 1b				jr nz, .iskpw 
0bee			 
0bee 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0bf1 7e					ld a,(hl)	 
0bf2 fe 00				cp 0 
0bf4 ca 74 0b				jp z, .is1    ; end of string 
0bf7 fe 20				cp ' ' 
0bf9 ca 74 0b				jp z, .is1    ; end of word 
0bfc 23					inc hl 
0bfd 22 75 fb				ld (input_ptr), hl 
0c00 3a 6e fb				ld a, (input_at_cursor) 
0c03 3c					inc a 
0c04 32 6e fb				ld (input_at_cursor), a 
0c07 18 e5				jr .isknwm 
0c09			 
0c09 fe 07		.iskpw:		cp KEY_PREVWORD 
0c0b 20 1b				jr nz, .iskl 
0c0d			.iskpwm:	 
0c0d 2a 75 fb				ld hl, (input_ptr) 
0c10 7e					ld a,(hl)	 
0c11 fe 00				cp 0  
0c13 ca 74 0b				jp z, .is1    ; end of string 
0c16 fe 20				cp ' ' 
0c18 ca 74 0b				jp z, .is1    ; end of word 
0c1b 2b					dec hl 
0c1c 22 75 fb				ld (input_ptr), hl 
0c1f 3a 6e fb				ld a, (input_at_cursor) 
0c22 3d					dec a 
0c23 32 6e fb				ld (input_at_cursor), a 
0c26 18 e5				jr .iskpwm 
0c28			 
0c28			 
0c28 fe 0b		.iskl:		cp KEY_LEFT 
0c2a 20 27				jr nz, .isk1 
0c2c			 
0c2c 3a 61 fb				ld a, (input_cursor) 
0c2f			 
0c2f fe 00				cp 0 
0c31 ca 74 0b				jp z, .is1 		; at start of line to ignore  
0c34			 
0c34 3d					dec  a 		; TODO check underflow 
0c35 32 61 fb				ld (input_cursor), a 
0c38			 
0c38 2a 75 fb				ld hl, (input_ptr) 
0c3b 2b					dec hl 
0c3c 22 75 fb				ld (input_ptr), hl 
0c3f					 
0c3f 3a 6e fb				ld a, (input_at_cursor) 
0c42 3d					dec a 
0c43 32 6e fb				ld (input_at_cursor), a 
0c46			 
0c46 3e 01				ld a, 1		; show cursor moving 
0c48 32 6b fb				ld (input_cur_onoff),a 
0c4b 3e 0f				ld a, CUR_BLINK_RATE 
0c4d 32 6c fb				ld (input_cur_flash), a 
0c50			 
0c50 c3 74 0b				jp .is1 
0c53			 
0c53 fe 0c		.isk1:		cp KEY_RIGHT 
0c55 20 2a				jr nz, .isk2 
0c57			 
0c57 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0c5a 5f					ld e,a 
0c5b 3a 61 fb				ld a, (input_cursor) 
0c5e bb					cp e 
0c5f ca 74 0b				jp z, .is1		; at the end of string so dont go right 
0c62			 
0c62 3c					inc  a 		; TODO check overflow 
0c63 32 61 fb				ld (input_cursor), a 
0c66			 
0c66 3a 6e fb				ld a, (input_at_cursor) 
0c69 3c					inc a 
0c6a 32 6e fb				ld (input_at_cursor), a 
0c6d			 
0c6d 2a 75 fb				ld hl, (input_ptr) 
0c70 23					inc hl 
0c71 22 75 fb				ld (input_ptr), hl 
0c74			 
0c74 3e 01				ld a, 1		; show cursor moving 
0c76 32 6b fb				ld (input_cur_onoff),a 
0c79 3e 0f				ld a, CUR_BLINK_RATE 
0c7b 32 6c fb				ld (input_cur_flash), a 
0c7e			 
0c7e c3 74 0b				jp .is1 
0c81			 
0c81 fe 05		.isk2:		cp KEY_UP 
0c83			 
0c83 20 26				jr nz, .isk3 
0c85			 
0c85					; swap last command with the current on 
0c85			 
0c85					; move cursor to start of string 
0c85 2a 73 fb				ld hl, (input_start) 
0c88 22 75 fb				ld (input_ptr), hl 
0c8b			 
0c8b 3a 70 fb				ld a, (input_at_pos) 
0c8e 32 6e fb				ld (input_at_cursor), a 
0c91			 
0c91 3e 00				ld a, 0 
0c93 32 61 fb				ld (input_cursor), a 
0c96					 
0c96					; swap input and last command buffers 
0c96			 
0c96 21 59 f1				ld hl, os_cli_cmd 
0c99 11 58 f2				ld de, os_last_cmd 
0c9c 06 ff				ld b, 255 
0c9e 7e			.swap1:		ld a, (hl) 
0c9f 4f					ld c,a 
0ca0 1a					ld a, (de) 
0ca1 77					ld (hl), a 
0ca2 79					ld a,c 
0ca3 12					ld (de),a 
0ca4 23					inc hl 
0ca5 13					inc de 
0ca6 10 f6				djnz .swap1 
0ca8			 
0ca8			 
0ca8			 
0ca8			 
0ca8			 
0ca8 c3 74 0b				jp .is1 
0cab			 
0cab fe 08		.isk3:		cp KEY_BS 
0cad 20 3c				jr nz, .isk4 
0caf			 
0caf 3a 61 fb				ld a, (input_cursor) 
0cb2			 
0cb2 fe 00				cp 0 
0cb4 ca 74 0b				jp z, .is1 		; at start of line to ignore  
0cb7			 
0cb7 3d					dec  a 		; TODO check underflow 
0cb8 32 61 fb				ld (input_cursor), a 
0cbb			 
0cbb					; hl is source 
0cbb					; de needs to be source - 1 
0cbb			 
0cbb			;		ld a, 0 
0cbb			;		dec hl 
0cbb			;		ld (hl), a 
0cbb			 
0cbb 2a 75 fb				ld hl, (input_ptr) 
0cbe 2b					dec hl 
0cbf 22 75 fb				ld (input_ptr), hl 
0cc2			 
0cc2					; shift all data 
0cc2			 
0cc2 e5					push hl 
0cc3 23					inc hl 
0cc4 d1					pop de 
0cc5 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0cc8 4f					ld c,a 
0cc9 06 00				ld b,0 
0ccb ed b0				ldir  
0ccd			 
0ccd			 
0ccd			 
0ccd			 
0ccd 3a 6e fb				ld a, (input_at_cursor) 
0cd0 3d					dec a 
0cd1 32 6e fb				ld (input_at_cursor), a 
0cd4			 
0cd4			 
0cd4 3e 01				ld a, 1		; show cursor moving 
0cd6 32 6b fb				ld (input_cur_onoff),a 
0cd9 3e 0f				ld a, CUR_BLINK_RATE 
0cdb 32 6c fb				ld (input_cur_flash), a 
0cde			 
0cde					; remove char 
0cde 3a 6e fb				ld a, (input_at_cursor) 
0ce1 3c					inc a 
0ce2 11 6c 0d				ld de,.iblank 
0ce5 cd d0 09				call str_at_display 
0ce8			 
0ce8 c3 74 0b				jp .is1 
0ceb			 
0ceb fe 0d		.isk4:		cp KEY_CR 
0ced 28 6c				jr z, .endinput 
0cef			 
0cef					; else add the key press to the end 
0cef			 
0cef 4f					ld c, a			; save key pressed 
0cf0			 
0cf0 7e					ld a,(hl)		; get what is currently under char 
0cf1			 
0cf1 fe 00				cp 0			; we are at the end of the string 
0cf3 20 2f				jr nz, .onchar 
0cf5					 
0cf5					; add a char to the end of the string 
0cf5				 
0cf5 71					ld (hl),c 
0cf6 23					inc hl 
0cf7			;		ld a,' ' 
0cf7			;		ld (hl),a 
0cf7			;		inc hl 
0cf7 3e 00				ld a,0 
0cf9 77					ld (hl),a 
0cfa 2b					dec hl 
0cfb			 
0cfb 3a 61 fb				ld a, (input_cursor) 
0cfe 3c					inc a				; TODO check max string length and scroll  
0cff 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0d02							 
0d02 3a 6e fb				ld a, (input_at_cursor) 
0d05 3c					inc a 
0d06 32 6e fb				ld (input_at_cursor), a 
0d09			 
0d09 2a 75 fb				ld hl, (input_ptr) 
0d0c 23					inc hl 
0d0d 22 75 fb				ld (input_ptr), hl 
0d10			 
0d10 2a 75 fb				ld hl, (input_ptr) 
0d13 23					inc hl 
0d14 22 75 fb				ld (input_ptr), hl 
0d17			;	if DEBUG_INPUT 
0d17			;		push af 
0d17			;		ld a, '+' 
0d17			;		ld (debug_mark),a 
0d17			;		pop af 
0d17			;		CALLMONITOR 
0d17			;	endif 
0d17 3e 01				ld a, 1		; show cursor moving 
0d19 32 6b fb				ld (input_cur_onoff),a 
0d1c 3e 0f				ld a, CUR_BLINK_RATE 
0d1e 32 6c fb				ld (input_cur_flash), a 
0d21 c3 74 0b				jp .is1 
0d24					 
0d24			 
0d24			 
0d24					; if on a char then insert 
0d24			.onchar: 
0d24			 
0d24					; TODO over flow check: make sure insert does not blow out buffer 
0d24			 
0d24					; need to do some maths to use lddr 
0d24			 
0d24 e5					push hl   ; save char pos 
0d25 c5					push bc 
0d26			 
0d26 2a 73 fb				ld hl, (input_start) 
0d29 3a 66 fb				ld a, (input_len) 
0d2c cd 16 0b				call addatohl  		; end of string 
0d2f 23					inc hl 
0d30 23					inc hl		; past zero term 
0d31 e5					push hl 
0d32 23					inc hl 
0d33 e5					push hl  
0d34			 
0d34								; start and end of lddr set, now how much to move? 
0d34			 
0d34							 
0d34 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0d37 47					ld b,a 
0d38 3a 66 fb				ld a,(input_len) 
0d3b 5f					ld e,a 
0d3c 90					sub b 
0d3d 3c					inc a		;?? 
0d3e 3c					inc a		;?? 
0d3f 3c					inc a		;?? 
0d40			 
0d40 06 00				ld b,0 
0d42 4f					ld c,a 
0d43			 
0d43				if DEBUG_INPUT 
0d43					push af 
0d43					ld a, 'i' 
0d43					ld (debug_mark),a 
0d43					pop af 
0d43			;		CALLMONITOR 
0d43				endif 
0d43 d1					pop de 
0d44 e1					pop hl 
0d45				if DEBUG_INPUT 
0d45					push af 
0d45					ld a, 'I' 
0d45					ld (debug_mark),a 
0d45					pop af 
0d45			;		CALLMONITOR 
0d45				endif 
0d45 ed b8				lddr 
0d47				 
0d47			 
0d47			 
0d47					; TODO have a key for insert/overwrite mode???? 
0d47 c1					pop bc 
0d48 e1					pop hl 
0d49 71					ld (hl), c		; otherwise overwrite current char 
0d4a					 
0d4a			 
0d4a			 
0d4a			 
0d4a 3a 61 fb				ld a, (input_cursor) 
0d4d 3c					inc  a 		; TODO check overflow 
0d4e 32 61 fb				ld (input_cursor), a 
0d51			 
0d51 3a 6e fb				ld a, (input_at_cursor) 
0d54 3c					inc a 
0d55 32 6e fb				ld (input_at_cursor), a 
0d58			 
0d58 c3 74 0b				jp .is1 
0d5b			 
0d5b			.endinput:	; TODO look for end of string 
0d5b			 
0d5b					; add trailing space for end of token 
0d5b			 
0d5b 2a 73 fb				ld hl, (input_start) 
0d5e 3a 66 fb				ld a,(input_len) 
0d61 cd 16 0b				call addatohl 
0d64 3e 20				ld a, ' ' 
0d66 77					ld (hl),a 
0d67					; TODO eof of parse marker 
0d67			 
0d67 23					inc hl 
0d68 3e 00				ld a, 0 
0d6a 77					ld (hl),a 
0d6b			 
0d6b			 
0d6b c9					ret 
0d6c			 
0d6c .. 00		.iblank: db " ",0 
0d6e			 
0d6e			 
0d6e 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0d71 22 73 fb				ld (input_start), hl 
0d74 3e 01				ld a,1			; add cursor 
0d76 77					ld (hl),a 
0d77 23					inc hl 
0d78 3e 00				ld a,0 
0d7a 77					ld (hl),a 
0d7b 22 75 fb				ld (input_ptr), hl 
0d7e 7a					ld a,d 
0d7f 32 72 fb				ld (input_size), a 
0d82 3e 00				ld a,0 
0d84 32 61 fb				ld (input_cursor),a 
0d87			.instr1:	 
0d87			 
0d87					; TODO do block cursor 
0d87					; TODO switch cursor depending on the modifer key 
0d87			 
0d87					; update cursor shape change on key hold 
0d87			 
0d87 2a 75 fb				ld hl, (input_ptr) 
0d8a 2b					dec hl 
0d8b 3a d0 f8				ld a,(cursor_shape) 
0d8e 77					ld (hl), a 
0d8f			 
0d8f					; display entered text 
0d8f 3a 70 fb				ld a,(input_at_pos) 
0d92 cd f0 52		            	CALL fLCD_Pos       ;Position cursor to location in A 
0d95 ed 5b 73 fb	            	LD   de, (input_start) 
0d99 cd 12 53		            	CALL fLCD_Str       ;Display string pointed to by DE 
0d9c			 
0d9c cd 2c 55				call cin 
0d9f fe 00				cp 0 
0da1 28 e4				jr z, .instr1 
0da3			 
0da3					; proecess keyboard controls first 
0da3			 
0da3 2a 75 fb				ld hl,(input_ptr) 
0da6			 
0da6 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0da8 28 5a				jr z, .instrcr 
0daa			 
0daa fe 08				cp KEY_BS 	; back space 
0dac 20 0f				jr nz, .instr2 
0dae					; process back space 
0dae			 
0dae					; TODO stop back space if at start of string 
0dae 2b					dec hl 
0daf 2b					dec hl ; to over write cursor 
0db0 3a d0 f8				ld a,(cursor_shape) 
0db3					;ld a,0 
0db3 77					ld (hl),a 
0db4 23					inc hl 
0db5 3e 20				ld a," " 
0db7 77					ld (hl),a 
0db8 22 75 fb				ld (input_ptr),hl 
0dbb					 
0dbb			 
0dbb 18 ca				jr .instr1 
0dbd			 
0dbd fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0dbf 20 06				jr nz, .instr3 
0dc1 2b					dec hl 
0dc2 22 75 fb				ld (input_ptr),hl 
0dc5 18 c0				jr .instr1 
0dc7				 
0dc7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0dc9 20 06				jr nz, .instr4 
0dcb 23					inc hl 
0dcc 22 75 fb				ld (input_ptr),hl 
0dcf 18 b6				jr .instr1 
0dd1			 
0dd1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0dd3 20 06				jr nz, .instr5 
0dd5 2b					dec hl 
0dd6 22 75 fb				ld (input_ptr),hl 
0dd9 18 ac				jr .instr1 
0ddb			 
0ddb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ddd 20 06				jr nz, .instr6 
0ddf 2b					dec hl 
0de0 22 75 fb				ld (input_ptr),hl 
0de3 18 a2				jr .instr1 
0de5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0de7 20 0b				jr nz, .instrnew 
0de9			 
0de9 21 32 ee			ld hl, scratch 
0dec 11 58 f2			ld de, os_last_cmd 
0def cd 0d 0e			call strcpy 
0df2 18 93				jr .instr1 
0df4			 
0df4			 
0df4			.instrnew:	; no special key pressed to see if we have room to store it 
0df4			 
0df4					; TODO do string size test 
0df4			 
0df4 2b					dec hl ; to over write cursor 
0df5 77					ld (hl),a 
0df6 23					inc hl 
0df7 3a d0 f8				ld a,(cursor_shape) 
0dfa 77					ld (hl),a 
0dfb 23					inc hl 
0dfc 3e 00				ld a,0 
0dfe 77					ld (hl),a 
0dff			 
0dff 22 75 fb				ld (input_ptr),hl 
0e02					 
0e02 18 83				jr .instr1 
0e04 2b			.instrcr:	dec hl		; remove cursor 
0e05 3e 20				ld a,' '	; TODO add a trailing space for safety 
0e07 77					ld (hl),a 
0e08 23					inc hl 
0e09 3e 00				ld a,0 
0e0b 77					ld (hl),a 
0e0c			 
0e0c			 
0e0c					; if at end of line scroll up    
0e0c					; TODO detecting only end of line 4 for scroll up  
0e0c			 
0e0c					;ld   
0e0c			 
0e0c c9					ret 
0e0d			 
0e0d			 
0e0d			; strcpy hl = dest, de source 
0e0d			 
0e0d 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0e0e b7			            OR   A              ;Null terminator? 
0e0f c8			            RET  Z              ;Yes, so finished 
0e10 1a					ld a,(de) 
0e11 77					ld (hl),a 
0e12 13			            INC  DE             ;Point to next character 
0e13 23					inc hl 
0e14 18 f7		            JR   strcpy       ;Repeat 
0e16 c9					ret 
0e17			 
0e17			 
0e17			; TODO string_at  
0e17			; pass string which starts with lcd offset address and then null term string 
0e17			 
0e17			; TODO string to dec 
0e17			; TODO string to hex 
0e17			; TODO byte to string hex 
0e17			; TODO byte to string dec 
0e17			 
0e17			 
0e17			 
0e17			; from z80uartmonitor 
0e17			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e17			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0e17			; pass hl for where to put the text 
0e17			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e17 c5			hexout:	PUSH BC 
0e18 f5					PUSH AF 
0e19 47					LD B, A 
0e1a					; Upper nybble 
0e1a cb 3f				SRL A 
0e1c cb 3f				SRL A 
0e1e cb 3f				SRL A 
0e20 cb 3f				SRL A 
0e22 cd 32 0e				CALL tohex 
0e25 77					ld (hl),a 
0e26 23					inc hl	 
0e27					 
0e27					; Lower nybble 
0e27 78					LD A, B 
0e28 e6 0f				AND 0FH 
0e2a cd 32 0e				CALL tohex 
0e2d 77					ld (hl),a 
0e2e 23					inc hl	 
0e2f					 
0e2f f1					POP AF 
0e30 c1					POP BC 
0e31 c9					RET 
0e32					 
0e32			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e32			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0e32			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e32			tohex: 
0e32 e5					PUSH HL 
0e33 d5					PUSH DE 
0e34 16 00				LD D, 0 
0e36 5f					LD E, A 
0e37 21 3f 0e				LD HL, .DATA 
0e3a 19					ADD HL, DE 
0e3b 7e					LD A, (HL) 
0e3c d1					POP DE 
0e3d e1					POP HL 
0e3e c9					RET 
0e3f			 
0e3f			.DATA: 
0e3f 30					DEFB	30h	; 0 
0e40 31					DEFB	31h	; 1 
0e41 32					DEFB	32h	; 2 
0e42 33					DEFB	33h	; 3 
0e43 34					DEFB	34h	; 4 
0e44 35					DEFB	35h	; 5 
0e45 36					DEFB	36h	; 6 
0e46 37					DEFB	37h	; 7 
0e47 38					DEFB	38h	; 8 
0e48 39					DEFB	39h	; 9 
0e49 41					DEFB	41h	; A 
0e4a 42					DEFB	42h	; B 
0e4b 43					DEFB	43h	; C 
0e4c 44					DEFB	44h	; D 
0e4d 45					DEFB	45h	; E 
0e4e 46					DEFB	46h	; F 
0e4f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0e4f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0e4f			;;    subtract $30, if result > 9 then subtract $7 more 
0e4f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0e4f			atohex: 
0e4f d6 30				SUB $30 
0e51 fe 0a				CP 10 
0e53 f8					RET M		; If result negative it was 0-9 so we're done 
0e54 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0e56 c9					RET		 
0e57			 
0e57			 
0e57			 
0e57			 
0e57			; Get 2 ASCII characters as hex byte from pointer in hl 
0e57			 
0e57			BYTERD: 
0e57 16 00			LD	D,00h		;Set up 
0e59 cd 61 0e			CALL	HEXCON		;Get byte and convert to hex 
0e5c 87				ADD	A,A		;First nibble so 
0e5d 87				ADD	A,A		;multiply by 16 
0e5e 87				ADD	A,A		; 
0e5f 87				ADD	A,A		; 
0e60 57				LD	D,A		;Save hi nibble in D 
0e61			HEXCON: 
0e61 7e				ld a, (hl)		;Get next chr 
0e62 23				inc hl 
0e63 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0e65 fe 0a			CP	00Ah		;Is it 0-9 ? 
0e67 38 02			JR	C,NALPHA	;If so miss next bit 
0e69 d6 07			SUB	007h		;Else convert alpha 
0e6b			NALPHA: 
0e6b b2				OR	D		;Add hi nibble back 
0e6c c9				RET			; 
0e6d			 
0e6d			 
0e6d			; 
0e6d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0e6d			; Since the routines get_byte and therefore get_nibble are called, only valid 
0e6d			; characters (0-9a-f) are accepted. 
0e6d			; 
0e6d			;get_word        push    af 
0e6d			;                call    get_byte        ; Get the upper byte 
0e6d			;                ld      h, a 
0e6d			;                call    get_byte        ; Get the lower byte 
0e6d			;                ld      l, a 
0e6d			;                pop     af 
0e6d			;                ret 
0e6d			; 
0e6d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0e6d			; the routine get_nibble is used only valid characters are accepted - the  
0e6d			; input routine only accepts characters 0-9a-f. 
0e6d			; 
0e6d c5			get_byte:        push    bc              ; Save contents of B (and C) 
0e6e 7e					ld a,(hl) 
0e6f 23					inc hl 
0e70 cd 95 0e		                call    nibble2val      ; Get upper nibble 
0e73 cb 07		                rlc     a 
0e75 cb 07		                rlc     a 
0e77 cb 07		                rlc     a 
0e79 cb 07		                rlc     a 
0e7b 47			                ld      b, a            ; Save upper four bits 
0e7c 7e					ld a,(hl) 
0e7d cd 95 0e		                call    nibble2val      ; Get lower nibble 
0e80 b0			                or      b               ; Combine both nibbles 
0e81 c1			                pop     bc              ; Restore B (and C) 
0e82 c9			                ret 
0e83			; 
0e83			; Get a hexadecimal digit from the serial line. This routine blocks until 
0e83			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0e83			; to the serial line interface. The lower 4 bits of A contain the value of  
0e83			; that particular digit. 
0e83			; 
0e83			;get_nibble      ld a,(hl)           ; Read a character 
0e83			;                call    to_upper        ; Convert to upper case 
0e83			;                call    is_hex          ; Was it a hex digit? 
0e83			;                jr      nc, get_nibble  ; No, get another character 
0e83			 ;               call    nibble2val      ; Convert nibble to value 
0e83			 ;               call    print_nibble 
0e83			 ;               ret 
0e83			; 
0e83			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0e83			; A valid hexadecimal digit is denoted by a set C flag. 
0e83			; 
0e83			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0e83			;                ret     nc              ; Yes 
0e83			;                cp      '0'             ; Less than '0'? 
0e83			;                jr      nc, is_hex_1    ; No, continue 
0e83			;                ccf                     ; Complement carry (i.e. clear it) 
0e83			;                ret 
0e83			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0e83			;                ret     c               ; Yes 
0e83			;                cp      'A'             ; Less than 'A'? 
0e83			;                jr      nc, is_hex_2    ; No, continue 
0e83			;                ccf                     ; Yes - clear carry and return 
0e83			;                ret 
0e83			;is_hex_2        scf                     ; Set carry 
0e83			;                ret 
0e83			; 
0e83			; Convert a single character contained in A to upper case: 
0e83			; 
0e83 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0e85 d8			                ret     c 
0e86 fe 7b		                cp      'z' + 1         ; > 'z'? 
0e88 d0			                ret     nc              ; Nothing to do, either 
0e89 e6 5f		                and     $5f             ; Convert to upper case 
0e8b c9			                ret 
0e8c			 
0e8c			 
0e8c			to_lower: 
0e8c			 
0e8c			   ; if char is in [A-Z] make it lower case 
0e8c			 
0e8c			   ; enter : a = char 
0e8c			   ; exit  : a = lower case char 
0e8c			   ; uses  : af 
0e8c			 
0e8c fe 41		   cp 'A' 
0e8e d8			   ret c 
0e8f			    
0e8f fe 5b		   cp 'Z'+1 
0e91 d0			   ret nc 
0e92			    
0e92 f6 20		   or $20 
0e94 c9			   ret 
0e95			 
0e95			; 
0e95			; Expects a hexadecimal digit (upper case!) in A and returns the 
0e95			; corresponding value in A. 
0e95			; 
0e95 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0e97 38 02		                jr      c, nibble2val_1 ; Yes 
0e99 d6 07		                sub     7               ; Adjust for A-F 
0e9b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0e9d e6 0f		                and     $f              ; Only return lower 4 bits 
0e9f c9			                ret 
0ea0			; 
0ea0			; Print_nibble prints a single hex nibble which is contained in the lower  
0ea0			; four bits of A: 
0ea0			; 
0ea0			;print_nibble    push    af              ; We won't destroy the contents of A 
0ea0			;                and     $f              ; Just in case... 
0ea0			;                add     a, '0'             ; If we have a digit we are done here. 
0ea0			;                cp      '9' + 1         ; Is the result > 9? 
0ea0			;                jr      c, print_nibble_1 
0ea0			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0ea0			;print_nibble_1  call    putc            ; Print the nibble and 
0ea0			;                pop     af              ; restore the original value of A 
0ea0			;                ret 
0ea0			;; 
0ea0			;; Send a CR/LF pair: 
0ea0			; 
0ea0			;crlf            push    af 
0ea0			;                ld      a, cr 
0ea0			;                call    putc 
0ea0			;                ld      a, lf 
0ea0			;                call    putc 
0ea0			;                pop     af 
0ea0			;                ret 
0ea0			; 
0ea0			; Print_word prints the four hex digits of a word to the serial line. The  
0ea0			; word is expected to be in HL. 
0ea0			; 
0ea0			;print_word      push    hl 
0ea0			;                push    af 
0ea0			;                ld      a, h 
0ea0			;                call    print_byte 
0ea0			;                ld      a, l 
0ea0			;                call    print_byte 
0ea0			;                pop     af 
0ea0			;                pop     hl 
0ea0			;                ret 
0ea0			; 
0ea0			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0ea0			; The byte to be printed is expected to be in A. 
0ea0			; 
0ea0			;print_byte      push    af              ; Save the contents of the registers 
0ea0			;                push    bc 
0ea0			;                ld      b, a 
0ea0			;                rrca 
0ea0			;                rrca 
0ea0			;                rrca 
0ea0			;                rrca 
0ea0			;                call    print_nibble    ; Print high nibble 
0ea0			;                ld      a, b 
0ea0			;                call    print_nibble    ; Print low nibble 
0ea0			;                pop     bc              ; Restore original register contents 
0ea0			;                pop     af 
0ea0			;                ret 
0ea0			 
0ea0			 
0ea0			 
0ea0			 
0ea0			 
0ea0			fourehexhl:  
0ea0 7e				ld a,(hl) 
0ea1 cd 4f 0e			call atohex 
0ea4 cb 3f				SRL A 
0ea6 cb 3f				SRL A 
0ea8 cb 3f				SRL A 
0eaa cb 3f				SRL A 
0eac 47				ld b, a 
0ead 23				inc hl 
0eae 7e				ld a,(hl) 
0eaf 23				inc hl 
0eb0 cd 4f 0e			call atohex 
0eb3 80				add b 
0eb4 57				ld d,a 
0eb5 7e				ld a,(hl) 
0eb6 cd 4f 0e			call atohex 
0eb9 cb 3f				SRL A 
0ebb cb 3f				SRL A 
0ebd cb 3f				SRL A 
0ebf cb 3f				SRL A 
0ec1 47				ld b, a 
0ec2 23				inc hl 
0ec3 7e				ld a,(hl) 
0ec4 23				inc hl 
0ec5 cd 4f 0e			call atohex 
0ec8 80				add b 
0ec9 5f				ld e, a 
0eca d5				push de 
0ecb e1				pop hl 
0ecc c9				ret 
0ecd			 
0ecd			; pass hl. returns z set if the byte at hl is a digit 
0ecd			;isdigithl:  
0ecd			;	push bc 
0ecd			;	ld a,(hl) 
0ecd			;	cp ':' 
0ecd			;	jr nc, .isdf 		; > 
0ecd			;	cp '0' 
0ecd			;	jr c, .isdf		; < 
0ecd			; 
0ecd			;	; TODO find a better way to set z 
0ecd			; 
0ecd			;	ld b,a 
0ecd			;	cp b 
0ecd			;	pop bc 
0ecd			;	ret 
0ecd			; 
0ecd			;.isdf:	; not digit so clear z 
0ecd			; 
0ecd			;	; TODO find a better way to unset z 
0ecd			; 
0ecd			;	ld b,a 
0ecd			;	inc b 
0ecd			;	cp b 
0ecd			; 
0ecd			;	pop bc 
0ecd			;	ret 
0ecd				 
0ecd				 
0ecd			 
0ecd			 
0ecd			; pass hl as the four byte address to load 
0ecd			 
0ecd			get_word_hl:  
0ecd e5				push hl 
0ece cd 6d 0e			call get_byte 
0ed1				 
0ed1 47				ld b, a 
0ed2			 
0ed2 e1				pop hl 
0ed3 23				inc hl 
0ed4 23				inc hl 
0ed5			 
0ed5			; TODO not able to handle a-f  
0ed5 7e				ld a,(hl) 
0ed6			;	;cp ':' 
0ed6			;	cp 'g' 
0ed6			;	jr nc, .single_byte_hl 		; > 
0ed6			;	cp 'G' 
0ed6			;	jr nc, .single_byte_hl 		; > 
0ed6			;	cp '0' 
0ed6			;	jr c, .single_byte_hl		; < 
0ed6			 
0ed6				;call isdigithl 
0ed6 fe 00			cp 0 
0ed8 28 06			jr z, .single_byte_hl 
0eda			 
0eda			.getwhln:   ; hex word so get next byte 
0eda			 
0eda cd 6d 0e			call get_byte 
0edd 6f				ld l, a 
0ede 60				ld h,b 
0edf c9				ret 
0ee0 68			.single_byte_hl:   ld l,b 
0ee1 26 00				ld h,0 
0ee3 c9					ret 
0ee4			 
0ee4			 
0ee4			 
0ee4			 
0ee4 21 a8 15			ld hl,asc+1 
0ee7			;	ld a, (hl) 
0ee7			;	call nibble2val 
0ee7 cd 6d 0e			call get_byte 
0eea			 
0eea			;	call fourehexhl 
0eea 32 66 ee			ld (scratch+52),a 
0eed				 
0eed 21 64 ee			ld hl,scratch+50 
0ef0 22 55 f1			ld (os_cur_ptr),hl 
0ef3			 
0ef3 c9				ret 
0ef4			 
0ef4			 
0ef4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ef4			 
0ef4			; Decimal Unsigned Version 
0ef4			 
0ef4			;Number in a to decimal ASCII 
0ef4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ef4			;Example: display a=56 as "056" 
0ef4			;input: a = number 
0ef4			;Output: a=0,value of a in the screen 
0ef4			;destroys af,bc (don't know about hl and de) 
0ef4			DispAToASCII: 
0ef4 0e 9c			ld	c,-100 
0ef6 cd 00 0f			call	.Na1 
0ef9 0e f6			ld	c,-10 
0efb cd 00 0f			call	.Na1 
0efe 0e ff			ld	c,-1 
0f00 06 2f		.Na1:	ld	b,'0'-1 
0f02 04			.Na2:	inc	b 
0f03 81				add	a,c 
0f04 38 fc			jr	c,.Na2 
0f06 91				sub	c		;works as add 100/10/1 
0f07 f5				push af		;safer than ld c,a 
0f08 78				ld	a,b		;char is in b 
0f09			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0f09 f1				pop af		;safer than ld a,c 
0f0a c9				ret 
0f0b			 
0f0b			; Decimal Signed Version 
0f0b			 
0f0b			; DispA 
0f0b			; -------------------------------------------------------------- 
0f0b			; Converts a signed integer value to a zero-terminated ASCII 
0f0b			; string representative of that value (using radix 10). 
0f0b			; -------------------------------------------------------------- 
0f0b			; INPUTS: 
0f0b			;     HL     Value to convert (two's complement integer). 
0f0b			;     DE     Base address of string destination. (pointer). 
0f0b			; -------------------------------------------------------------- 
0f0b			; OUTPUTS: 
0f0b			;     None 
0f0b			; -------------------------------------------------------------- 
0f0b			; REGISTERS/MEMORY DESTROYED 
0f0b			; AF HL 
0f0b			; -------------------------------------------------------------- 
0f0b			 
0f0b			;DispHLToASCII: 
0f0b			;   push    de 
0f0b			;   push    bc 
0f0b			; 
0f0b			;; Detect sign of HL. 
0f0b			;    bit    7, h 
0f0b			;    jr     z, ._DoConvert 
0f0b			; 
0f0b			;; HL is negative. Output '-' to string and negate HL. 
0f0b			;    ld     a, '-' 
0f0b			;    ld     (de), a 
0f0b			;    inc    de 
0f0b			; 
0f0b			;; Negate HL (using two's complement) 
0f0b			;    xor    a 
0f0b			;    sub    l 
0f0b			;    ld     l, a 
0f0b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0f0b			;    sbc    a, h 
0f0b			;    ld     h, a 
0f0b			; 
0f0b			;; Convert HL to digit characters 
0f0b			;._DoConvert: 
0f0b			;    ld     b, 0     ; B will count character length of number 
0f0b			;-   ld     a, 10 
0f0b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0f0b			;    push   af 
0f0b			;    inc    b 
0f0b			;    ld     a, h 
0f0b			;    or     l 
0f0b			;    jr     nz, - 
0f0b			; 
0f0b			;; Retrieve digits from stack 
0f0b			;-   pop    af 
0f0b			;    or     $30 
0f0b			;    ld     (de), a 
0f0b			;    inc    de 
0f0b			;    djnz   - 
0f0b			; 
0f0b			;; Terminate string with NULL 
0f0b			;    xor    a 
0f0b			;    ld     (de), a 
0f0b			; 
0f0b			;    pop    bc 
0f0b			;    pop    de 
0f0b			;    ret 
0f0b			 
0f0b			;Comments 
0f0b			; 
0f0b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0f0b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0f0b			;    Note that the output string will not be fixed-width. 
0f0b			; 
0f0b			;Example Usage 
0f0b			; 
0f0b			;    ld    hl, -1004 
0f0b			;    ld    de, OP1 
0f0b			;    call  DispA 
0f0b			;    ld    hl, OP1 
0f0b			;    syscall  PutS 
0f0b			 
0f0b			 
0f0b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f0b			 
0f0b			 
0f0b			;Converts an ASCII string to an unsigned 16-bit integer 
0f0b			;Quits when it reaches a non-decimal digit 
0f0b			 
0f0b			string_to_uint16: 
0f0b			atoui_16: 
0f0b			;Input: 
0f0b			;     DE points to the string 
0f0b			;Outputs: 
0f0b			;     HL is the result 
0f0b			;     A is the 8-bit value of the number 
0f0b			;     DE points to the byte after the number 
0f0b			;Destroys: 
0f0b			;     BC 
0f0b			;       if the string is non-empty, BC is HL/10 
0f0b			;Size:  24 bytes 
0f0b			;Speed: 42+d(104+{0,9}) 
0f0b			;       d is the number of digits in the number 
0f0b			;       max is 640 cycles for a 5 digit number 
0f0b			;Assuming no leading zeros: 
0f0b			;1 digit:  146cc 
0f0b			;2 digit:  250cc 
0f0b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0f0b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0f0b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0f0b			;avg: 544.81158447265625cc (544+13297/16384) 
0f0b			;=============================================================== 
0f0b 21 00 00		  ld hl,0 
0f0e			.u16a: 
0f0e 1a			  ld a,(de) 
0f0f d6 30		  sub 30h 
0f11 fe 0a		  cp 10 
0f13 d0			  ret nc 
0f14 13			  inc de 
0f15 44			  ld b,h 
0f16 4d			  ld c,l 
0f17 29			  add hl,hl 
0f18 29			  add hl,hl 
0f19 09			  add hl,bc 
0f1a 29			  add hl,hl 
0f1b 85			  add a,l 
0f1c 6f			  ld l,a 
0f1d 30 ef		  jr nc,.u16a 
0f1f 24			  inc h 
0f20 c3 0e 0f		  jp .u16a 
0f23			 
0f23			 
0f23			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f23			 
0f23			;written by Zeda 
0f23			;Converts a 16-bit unsigned integer to an ASCII string. 
0f23			 
0f23			uitoa_16: 
0f23			;Input: 
0f23			;   DE is the number to convert 
0f23			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0f23			;Output: 
0f23			;   HL points to the null-terminated ASCII string 
0f23			;      NOTE: This isn't necessarily the same as the input HL. 
0f23 d5			  push de 
0f24 c5			  push bc 
0f25 f5			  push af 
0f26 eb			  ex de,hl 
0f27			 
0f27 01 f0 d8		  ld bc,-10000 
0f2a 3e 2f		  ld a,'0'-1 
0f2c 3c			  inc a 
0f2d 09			  add hl,bc  
0f2e 38 fc		   jr c,$-2 
0f30 12			  ld (de),a 
0f31 13			  inc de 
0f32			 
0f32 01 e8 03		  ld bc,1000 
0f35 3e 3a		  ld a,'9'+1 
0f37 3d			  dec a  
0f38 09			  add hl,bc  
0f39 30 fc		   jr nc,$-2 
0f3b 12			  ld (de),a 
0f3c 13			  inc de 
0f3d			 
0f3d 01 9c ff		  ld bc,-100 
0f40 3e 2f		  ld a,'0'-1 
0f42 3c			  inc a  
0f43 09			  add hl,bc  
0f44 38 fc		   jr c,$-2 
0f46 12			  ld (de),a 
0f47 13			  inc de 
0f48			 
0f48 7d			  ld a,l 
0f49 26 3a		  ld h,'9'+1 
0f4b 25			  dec h  
0f4c c6 0a		  add a,10  
0f4e 30 fb		   jr nc,$-3 
0f50 c6 30		  add a,'0' 
0f52 eb			  ex de,hl 
0f53 72			  ld (hl),d 
0f54 23			  inc hl 
0f55 77			  ld (hl),a 
0f56 23			  inc hl 
0f57 36 00		  ld (hl),0 
0f59			 
0f59			;Now strip the leading zeros 
0f59 0e fa		  ld c,-6 
0f5b 09			  add hl,bc 
0f5c 3e 30		  ld a,'0' 
0f5e 23			  inc hl  
0f5f be			  cp (hl)  
0f60 28 fc		  jr z,$-2 
0f62			 
0f62			;Make sure that the string is non-empty! 
0f62 7e			  ld a,(hl) 
0f63 b7			  or a 
0f64 20 01		  jr nz,.atoub 
0f66 2b			  dec hl 
0f67			.atoub: 
0f67			 
0f67 f1			  pop af 
0f68 c1			  pop bc 
0f69 d1			  pop de 
0f6a c9			  ret 
0f6b			 
0f6b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0f6b			 
0f6b			toUpper: 
0f6b			;A is the char. 
0f6b			;If A is a lowercase letter, this sets it to the matching uppercase 
0f6b			;18cc or 30cc or 41cc 
0f6b			;avg: 26.75cc 
0f6b fe 61		  cp 'a' 
0f6d d8			  ret c 
0f6e fe 7b		  cp 'z'+1 
0f70 d0			  ret nc 
0f71 d6 20		  sub 'a'-'A' 
0f73 c9			  ret 
0f74			 
0f74			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0f74			 
0f74			; String Length 
0f74			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0f74			 
0f74			; Get the length of the null-terminated string starting at $8000 hl 
0f74			;    LD     HL, $8000 
0f74			 
0f74			strlenz: 
0f74			 
0f74 af			    XOR    A               ; Zero is the value we are looking for. 
0f75 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0f76 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0f77			                           ; 65, 536 bytes (the entire addressable memory space). 
0f77 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f79			 
0f79			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f79 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0f7a 6f			    LD     L, A             ; number of bytes 
0f7b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f7d 2b			    DEC    HL              ; Compensate for null. 
0f7e c9				ret 
0f7f			 
0f7f			; Get the length of the A terminated string starting at $8000 hl 
0f7f			;    LD     HL, $8000 
0f7f			 
0f7f			strlent: 
0f7f			 
0f7f			                  ; A is the value we are looking for. 
0f7f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0f81 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0f83			                           ; 65, 536 bytes (the entire addressable memory space). 
0f83 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f85			 
0f85			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f85 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0f87 2e 00		    LD     L, 0             ; number of bytes 
0f89 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f8b 2b			    DEC    HL              ; Compensate for null. 
0f8c c9				ret 
0f8d			 
0f8d			 
0f8d			;Comparing Strings 
0f8d			 
0f8d			;IN    HL     Address of string1. 
0f8d			;      DE     Address of string2. 
0f8d			 
0f8d			; doc given but wrong??? 
0f8d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0f8d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0f8d			; tested 
0f8d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0f8d			 
0f8d			strcmp_old: 
0f8d e5			    PUSH   HL 
0f8e d5			    PUSH   DE 
0f8f			 
0f8f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0f90 be			    CP     (HL)            ; (want to minimize work). 
0f91 38 01		    JR     C, Str1IsBigger 
0f93 7e			    LD     A, (HL) 
0f94			 
0f94			Str1IsBigger: 
0f94 4f			    LD     C, A             ; Put length in BC 
0f95 06 00		    LD     B, 0 
0f97 13			    INC    DE              ; Increment pointers to meat of string. 
0f98 23			    INC    HL 
0f99			 
0f99			CmpLoop: 
0f99 1a			    LD     A, (DE)          ; Compare bytes. 
0f9a ed a1		    CPI 
0f9c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0f9e 13			    INC    DE              ; Update pointer. 
0f9f ea 99 0f		    JP     PE, CmpLoop 
0fa2			 
0fa2 d1			    POP    DE 
0fa3 e1			    POP    HL 
0fa4 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0fa5 be			    CP     (HL) 
0fa6 c9			    RET 
0fa7			 
0fa7			NoMatch: 
0fa7 2b			    DEC    HL 
0fa8 be			    CP     (HL)            ; Compare again to affect carry. 
0fa9 d1			    POP    DE 
0faa e1			    POP    HL 
0fab c9			    RET 
0fac			 
0fac			;; test strmp 
0fac			; 
0fac			;ld de, .str1 
0fac			;ld hl, .str2 
0fac			;call strcmp 
0fac			;jr z, .z1 
0fac			;;this 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "NZ1" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			;.z1: 
0fac			; 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "ZZ1" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			; 
0fac			;ld de, .str1 
0fac			;ld hl, .str1 
0fac			;call strcmp 
0fac			;jr z, .z2 
0fac			;;this 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "NZ2" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			;.z2: 
0fac			; 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "ZZ2" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			; 
0fac			;ld de, .str1 
0fac			;ld hl, .str2 
0fac			;call strcmp 
0fac			;jr c, .c1 
0fac			; 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "Nc1" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			;.c1: 
0fac			;;this 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "cc1" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			; 
0fac			;ld de, .str1 
0fac			;ld hl, .str1 
0fac			;call strcmp 
0fac			;jr c, .c2 
0fac			;;this 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "Nc2" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			;.c2: 
0fac			; 
0fac			;	if DEBUG_FORTH_WORDS 
0fac			;		DMARK "cc2" 
0fac			;		CALLMONITOR 
0fac			;	endif 
0fac			;	NEXTW 
0fac			;.str1:   db "string1",0 
0fac			;.str2:   db "string2",0 
0fac			 
0fac			; only care about direct match or not 
0fac			; hl and de strings 
0fac			; zero set if the same 
0fac			 
0fac			strcmp: 
0fac 1a				ld a, (de) 
0fad be				cp (hl) 
0fae 28 02			jr z, .ssame 
0fb0 b7				or a 
0fb1 c9				ret 
0fb2			 
0fb2			.ssame:  
0fb2 fe 00			cp 0 
0fb4 c8				ret z 
0fb5			 
0fb5 23				inc hl 
0fb6 13				inc de 
0fb7 18 f3			jr strcmp 
0fb9				 
0fb9				 
0fb9			 
0fb9			 
0fb9			 
0fb9			 
0fb9			; eof 
0fb9			 
0fb9			 
0fb9			 
0fb9			 
0fb9			 
0fb9			 
# End of file firmware_strings.asm
0fb9			include "firmware_memory.asm"   ; malloc and free  
0fb9			 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9			.mallocsize: db "Wants malloc >256",0 
0fb9			.mallocasize: db "MALLOC gives >256",0 
0fb9			.malloczero: db "MALLOC gives zero",0 
0fb9			 
0fb9			malloc_guard_zerolen: 
0fb9				push hl 
0fb9				push de 
0fb9				push af 
0fb9			 
0fb9				ld de, 0 
0fb9			        call cmp16 
0fb9				jr nz, .lowalloz 
0fb9			 
0fb9				push hl 
0fb9				push de 
0fb9					ld hl, display_fb0 
0fb9					ld (display_fb_active), hl 
0fb9				call clear_display 
0fb9				ld a, 0 
0fb9				ld de, .malloczero 
0fb9				call str_at_display 
0fb9				call update_display 
0fb9				call delay1s 
0fb9				call delay1s 
0fb9				ld a, 0 
0fb9				ld (os_view_disable), a 
0fb9			 
0fb9				pop de 
0fb9				pop hl 
0fb9			 
0fb9				 
0fb9			 
0fb9				CALLMONITOR 
0fb9			.lowalloz: 
0fb9			 
0fb9			 
0fb9				pop af 
0fb9				pop de 
0fb9				pop hl 
0fb9			ret 
0fb9			 
0fb9			malloc_guard_entry: 
0fb9				push hl 
0fb9				push de 
0fb9				push af 
0fb9			 
0fb9			 	or a      ;clear carry flag 
0fb9				push hl 
0fb9				ld de, 255 
0fb9				sbc hl, de 
0fb9				jr c, .lowalloc 
0fb9			 
0fb9				push de 
0fb9					ld hl, display_fb0 
0fb9					ld (display_fb_active), hl 
0fb9				call clear_display 
0fb9				ld a, 0 
0fb9				ld de, .mallocsize 
0fb9				call str_at_display 
0fb9				call update_display 
0fb9				call delay1s 
0fb9				call delay1s 
0fb9				ld a, 0 
0fb9				ld (os_view_disable), a 
0fb9			 
0fb9				pop de 
0fb9				pop hl 
0fb9			 
0fb9				 
0fb9			 
0fb9				CALLMONITOR 
0fb9				jr .lowdone 
0fb9			.lowalloc: 
0fb9			 
0fb9			 
0fb9				pop hl 
0fb9			.lowdone:	pop af 
0fb9				pop de 
0fb9				pop hl 
0fb9			ret 
0fb9			 
0fb9			malloc_guard_exit: 
0fb9				push hl 
0fb9				push de 
0fb9				push af 
0fb9			 
0fb9			 	or a      ;clear carry flag 
0fb9				push hl 
0fb9				ld de, 255 
0fb9				sbc hl, de 
0fb9				jr c, .lowallocx 
0fb9			 
0fb9				push de 
0fb9					ld hl, display_fb0 
0fb9					ld (display_fb_active), hl 
0fb9				call clear_display 
0fb9				ld a, 0 
0fb9				ld de, .mallocasize 
0fb9				call str_at_display 
0fb9				call update_display 
0fb9				call delay1s 
0fb9				call delay1s 
0fb9				ld a, 0 
0fb9				ld (os_view_disable), a 
0fb9				pop de 
0fb9				pop hl 
0fb9			 
0fb9				CALLMONITOR 
0fb9				jr .lowdonex 
0fb9			.lowallocx: 
0fb9			 
0fb9				pop hl 
0fb9			.lowdonex:	pop af 
0fb9				pop de 
0fb9				pop hl 
0fb9			ret 
0fb9			endif 
0fb9			 
0fb9			if MALLOC_2 
0fb9			; Z80 Malloc and Free Functions 
0fb9			 
0fb9			; Malloc Function: 
0fb9			; Input: 
0fb9			;   HL: Size of block to allocate 
0fb9			; Output: 
0fb9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0fb9			 
0fb9			malloc: 
0fb9				 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9			call malloc_guard_entry 
0fb9			endif 
0fb9			 
0fb9			 
0fb9			 
0fb9			 
0fb9					if DEBUG_FORTH_MALLOC 
0fb9						DMARK "mal" 
0fb9						CALLMONITOR 
0fb9					endif 
0fb9			    push af            ; Save AF register 
0fb9			    ld a, l            ; Load low byte of size into A 
0fb9			    or h               ; Check if size is zero 
0fb9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
0fb9			 
0fb9			    ; Allocate memory 
0fb9			    ld hl, (heap_start) ; Load start of heap into HL 
0fb9					if DEBUG_FORTH_MALLOC 
0fb9						DMARK "ma1" 
0fb9						CALLMONITOR 
0fb9					endif 
0fb9			    call malloc_internal ; Call internal malloc function 
0fb9			    pop af             ; Restore AF register 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9			call malloc_guard_exit 
0fb9			call malloc_guard_zerolen 
0fb9			endif 
0fb9			    ret                ; Return 
0fb9			 
0fb9			; Free Function: 
0fb9			; Input: 
0fb9			;   HL: Pointer to memory block to free 
0fb9			; Output: 
0fb9			;   None 
0fb9			 
0fb9			free: 
0fb9			    push af            ; Save AF register 
0fb9			    ld a, l            ; Load low byte of pointer into A 
0fb9			    or h               ; Check if pointer is NULL 
0fb9			    jp z, free_exit    ; If pointer is NULL, exit 
0fb9			 
0fb9			    ; Free memory 
0fb9			    ld hl, (heap_start) ; Load start of heap into HL 
0fb9			    call free_internal  ; Call internal free function 
0fb9			    pop af             ; Restore AF register 
0fb9			    ret                ; Return 
0fb9			 
0fb9			; Internal Malloc Function: 
0fb9			; Input: 
0fb9			;   HL: Size of block to allocate 
0fb9			; Output: 
0fb9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0fb9			 
0fb9			malloc_internal: 
0fb9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
0fb9			    add hl, bc         ; Add management overhead to requested size 
0fb9			    ex de, hl          ; Save total size in DE, and keep it in HL 
0fb9					if DEBUG_FORTH_MALLOC 
0fb9						DMARK "ma2" 
0fb9						CALLMONITOR 
0fb9					endif 
0fb9			 
0fb9			    ; Search for free memory block 
0fb9			    ld de, (heap_end)  ; Load end of heap into DE 
0fb9			    ld bc, 0           ; Initialize counter 
0fb9			 
0fb9					if DEBUG_FORTH_MALLOC 
0fb9						DMARK "ma2" 
0fb9						CALLMONITOR 
0fb9					endif 
0fb9			malloc_search_loop: 
0fb9			    ; Check if current block is free 
0fb9			    ld a, (hl)         ; Load current block's status (free or used) 
0fb9			    cp 0               ; Compare with zero (free) 
0fb9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
0fb9			 
0fb9			    ; Check if current block is large enough 
0fb9			    ld a, (hl+1)       ; Load high byte of block size 
0fb9			    cp l               ; Compare with low byte of requested size 
0fb9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
0fb9			 
0fb9			    ld a, (hl+2)       ; Load low byte of block size 
0fb9			    cp h               ; Compare with high byte of requested size 
0fb9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
0fb9			 
0fb9			    ; Mark block as used 
0fb9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
0fb9			 
0fb9			    ; Calculate remaining space in block 
0fb9			    ld bc, 0           ; Clear BC 
0fb9			    add hl, bc         ; Increment HL to point to start of data block 
0fb9			    add hl, de         ; HL = HL + DE (total size) 
0fb9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
0fb9			    add hl, bc         ; Add management overhead to start of data block 
0fb9			 
0fb9			    ; Save pointer to allocated block in HL 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9						DMARK "ma5" 
0fb9			call malloc_guard_exit 
0fb9			call malloc_guard_zerolen 
0fb9			endif 
0fb9			    ret 
0fb9			 
0fb9			malloc_skip_block_check: 
0fb9			    ; Move to the next block 
0fb9			    ld bc, 3           ; Size of management overhead 
0fb9			    add hl, bc         ; Move to the next block 
0fb9			    inc de             ; Increment counter 
0fb9			 
0fb9			    ; Check if we have reached the end of heap 
0fb9			    ld a, e            ; Load low byte of heap end address 
0fb9			    cp (hl)            ; Compare with low byte of current address 
0fb9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
0fb9			    ld a, d            ; Load high byte of heap end address 
0fb9			    cp 0               ; Check if it's zero (end of memory) 
0fb9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
0fb9			 
0fb9			    ; If we reached here, allocation failed 
0fb9			    xor a              ; Set result to NULL 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9						DMARK "ma6" 
0fb9			call malloc_guard_exit 
0fb9			call malloc_guard_zerolen 
0fb9			endif 
0fb9			    ret 
0fb9			malloc_exit: 
0fb9			if DEBUG_FORTH_MALLOC_HIGH 
0fb9						DMARK "ma7" 
0fb9			call malloc_guard_exit 
0fb9			call malloc_guard_zerolen 
0fb9			endif 
0fb9			    ret 
0fb9			 
0fb9			; Internal Free Function: 
0fb9			; Input: 
0fb9			;   HL: Pointer to memory block to free 
0fb9			; Output: 
0fb9			;   None 
0fb9			 
0fb9			free_internal: 
0fb9			    ld de, (heap_start) ; Load start of heap into DE 
0fb9			    ld bc, 0            ; Initialize counter 
0fb9			 
0fb9			free_search_loop: 
0fb9			    ; Check if current block contains the pointer 
0fb9			    ld a, l             ; Load low byte of pointer 
0fb9			    cp (hl+1)           ; Compare with high byte of current block's address 
0fb9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0fb9			    ld a, h             ; Load high byte of pointer 
0fb9			    cp (hl+2)           ; Compare with low byte of current block's address 
0fb9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0fb9			 
0fb9			    ; Mark block as free 
0fb9			    ld (hl), 0          ; Set status byte to indicate free block 
0fb9			    ret                 ; Return 
0fb9			 
0fb9			free_skip_block_check: 
0fb9			    ; Move to the next block 
0fb9			    ld bc, 3            ; Size of management overhead 
0fb9			    add hl, bc          ; Move to the next block 
0fb9			    inc de              ; Increment counter 
0fb9			 
0fb9			    ; Check if we have reached the end of heap 
0fb9			    ld a, e             ; Load low byte of heap end address 
0fb9			    cp (hl)             ; Compare with low byte of current address 
0fb9			    jr nz, free_search_loop  ; If not equal, continue searching 
0fb9			    ld a, d             ; Load high byte of heap end address 
0fb9			    cp 0                ; Check if it's zero (end of memory) 
0fb9			    jr nz, free_search_loop  ; If not zero, continue searching 
0fb9			 
0fb9			    ; If we reached here, pointer is not found in heap 
0fb9			    ret 
0fb9			 
0fb9			free_exit: 
0fb9			    ret                 ; Return 
0fb9			 
0fb9			; Define heap start and end addresses 
0fb9			;heap_start:    .dw 0xC000   ; Start of heap 
0fb9			;heap_end:      .dw 0xE000   ; End of heap 
0fb9			 
0fb9			endif 
0fb9			 
0fb9			 
0fb9			if MALLOC_1 
0fb9			 
0fb9			 
0fb9			 
0fb9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
0fb9			 
0fb9			;moved to firmware.asm 
0fb9			;heap_start        .equ  0x9000      ; Starting address of heap 
0fb9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
0fb9			 
0fb9			;      .org 0 
0fb9			;      jp    main 
0fb9			 
0fb9			 
0fb9			;      .org  0x100 
0fb9			;main: 
0fb9			;      ld    HL, 0x8100 
0fb9			;      ld    SP, HL 
0fb9			; 
0fb9			;      call  heap_init 
0fb9			; 
0fb9			;      ; Make some allocations 
0fb9			;      ld    HL, 12 
0fb9			;      call  malloc            ; Allocates 0x9004 
0fb9			; 
0fb9			;      ld    HL, 12 
0fb9			;      call  malloc            ; Allocates 0x9014 
0fb9			; 
0fb9			;      ld    HL, 12 
0fb9			;      call  malloc            ; Allocates 0x9024 
0fb9			; 
0fb9			;      ; Free some allocations 
0fb9			;      ld    HL, 0x9014 
0fb9			;      call  free 
0fb9			; 
0fb9			;      ld    HL, 0x9004 
0fb9			;      call  free 
0fb9			; 
0fb9			;      ld    HL, 0x9024 
0fb9			;      call  free 
0fb9			; 
0fb9			; 
0fb9			;      halt 
0fb9			 
0fb9			 
0fb9			;------------------------------------------------------------------------------ 
0fb9			;     heap_init                                                               : 
0fb9			;                                                                             : 
0fb9			; Description                                                                 : 
0fb9			;     Initialise the heap and make it ready for malloc and free operations.   : 
0fb9			;                                                                             : 
0fb9			;     The heap is maintained as a linked list, starting with an initial       : 
0fb9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
0fb9			;     the first free block in the heap. Each block then points to the next    : 
0fb9			;     free block within the heap, and the free list ends at the first block   : 
0fb9			;     with a null pointer to the next free block.                             : 
0fb9			;                                                                             : 
0fb9			; Parameters                                                                  : 
0fb9			;     Inputs are compile-time only. Two defines which specify the starting    : 
0fb9			;     address of the heap and its size are required, along with a memory      : 
0fb9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
0fb9			;     principally stores a pointer to the first free block in the heap.       : 
0fb9			;                                                                             : 
0fb9			; Returns                                                                     : 
0fb9			;     Nothing                                                                 : 
0fb9			;------------------------------------------------------------------------------ 
0fb9			heap_init: 
0fb9 e5			      push  HL 
0fba			 
0fba			      ; Initialise free list struct 
0fba 21 0e 80		      ld    HL, heap_start 
0fbd 22 0a 80		      ld    (free_list), HL 
0fc0 21 00 00		      ld    HL, 0 
0fc3 22 0c 80		      ld    (free_list+2), HL 
0fc6			 
0fc6			      ; Insert first free block at bottom of heap, consumes entire heap 
0fc6 21 22 ee		      ld    HL, heap_start+heap_size-4 
0fc9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
0fcc 21 14 6e		      ld    HL, heap_size-4 
0fcf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
0fd2			 
0fd2			      ; Insert end of free list block at top of heap - two null words will 
0fd2			      ; terminate the free list 
0fd2 21 00 00		      ld    HL, 0 
0fd5 22 24 ee		      ld    (heap_start+heap_size-2), HL 
0fd8 22 22 ee		      ld    (heap_start+heap_size-4), HL 
0fdb			 
0fdb e1			      pop   HL 
0fdc			 
0fdc c9			      ret 
0fdd			 
0fdd			 
0fdd			;------------------------------------------------------------------------------ 
0fdd			;     malloc                                                                  : 
0fdd			;                                                                             : 
0fdd			; Description                                                                 : 
0fdd			;     Allocates the wanted space from the heap and returns the address of the : 
0fdd			;     first useable byte of the allocation.                                   : 
0fdd			;                                                                             : 
0fdd			;     Allocations can happen in one of two ways:                              : 
0fdd			;                                                                             : 
0fdd			;     1. A free block may be found which is the exact size wanted. In this    : 
0fdd			;        case the block is removed from the free list and retuedn to the      : 
0fdd			;        caller.                                                              : 
0fdd			;     2. A free block may be found which is larger than the size wanted. In   : 
0fdd			;        this case, the larger block is split into two. The first portion of  : 
0fdd			;        this block will become the requested space by the malloc call and    : 
0fdd			;        is returned to the caller. The second portion becomes a new free     : 
0fdd			;        block, and the free list is adjusted to maintain continuity via this : 
0fdd			;        newly created block.                                                 : 
0fdd			;                                                                             : 
0fdd			;     malloc does not set any initial value in the allocated space, the       : 
0fdd			;     caller is required to do this as required.                              : 
0fdd			;                                                                             : 
0fdd			;     This implementation of malloc uses the stack exclusively, and is        : 
0fdd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0fdd			;     advisable to disable interrupts before calling malloc, and recommended  : 
0fdd			;     to avoid the use of malloc inside ISRs in general.                      : 
0fdd			;                                                                             : 
0fdd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0fdd			;                                                                             : 
0fdd			; Parameters                                                                  : 
0fdd			;     HL  Number of bytes wanted                                              : 
0fdd			;                                                                             : 
0fdd			; Returns                                                                     : 
0fdd			;     HL  Address of the first useable byte of the allocation                 : 
0fdd			;                                                                             : 
0fdd			; Flags                                                                       : 
0fdd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
0fdd			;                                                                             : 
0fdd			; Stack frame                                                                 : 
0fdd			;       |             |                                                       : 
0fdd			;       +-------------+                                                       : 
0fdd			;       |     BC      |                                                       : 
0fdd			;       +-------------+                                                       : 
0fdd			;       |     DE      |                                                       : 
0fdd			;       +-------------+                                                       : 
0fdd			;       |     IX      |                                                       : 
0fdd			;       +-------------+                                                       : 
0fdd			;       |  prev_free  |                                                       : 
0fdd			;   +4  +-------------+                                                       : 
0fdd			;       |  this_free  |                                                       : 
0fdd			;   +2  +-------------+                                                       : 
0fdd			;       |  next_free  |                                                       : 
0fdd			;   +0  +-------------+                                                       : 
0fdd			;       |             |                                                       : 
0fdd			;                                                                             : 
0fdd			;------------------------------------------------------------------------------ 
0fdd			 
0fdd			 
0fdd			;malloc: 
0fdd			; 
0fdd			;	SAVESP ON 1 
0fdd			; 
0fdd			;	call malloc_code 
0fdd			; 
0fdd			;	CHECKSP ON 1 
0fdd			;	ret 
0fdd			 
0fdd			 
0fdd			malloc: 
0fdd c5			      push  BC 
0fde d5			      push  DE 
0fdf dd e5		      push  IX 
0fe1			if DEBUG_FORTH_MALLOC_HIGH 
0fe1			call malloc_guard_entry 
0fe1			endif 
0fe1			 
0fe1					if DEBUG_FORTH_MALLOC 
0fe1						DMARK "mal" 
0fe1						CALLMONITOR 
0fe1					endif 
0fe1 7c			      ld    A, H                    ; Exit if no space requested 
0fe2 b5			      or    L 
0fe3 ca a2 10		      jp    Z, malloc_early_exit 
0fe6			 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			; 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			;inc hl 
0fe6			 
0fe6			 
0fe6			 
0fe6			 
0fe6					if DEBUG_FORTH_MALLOC 
0fe6						DMARK "maA" 
0fe6						CALLMONITOR 
0fe6					endif 
0fe6			      ; Set up stack frame 
0fe6 eb			      ex    DE, HL 
0fe7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
0fea 39			      add   HL, SP 
0feb f9			      ld    SP, HL 
0fec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0ff0 dd 39		      add   IX, SP 
0ff2			 
0ff2			      ; Setup initial state 
0ff2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
0ff5 19			      add   HL, DE 
0ff6			 
0ff6 44			      ld    B, H                    ; Move want to BC 
0ff7 4d			      ld    C, L 
0ff8			 
0ff8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
0ffb dd 75 04		      ld    (IX+4), L 
0ffe dd 74 05		      ld    (IX+5), H 
1001			 
1001 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1002 23			      inc   HL 
1003 56			      ld    D, (HL) 
1004 dd 73 02		      ld    (IX+2), E 
1007 dd 72 03		      ld    (IX+3), D 
100a eb			      ex    DE, HL                  ; this_free ptr into HL 
100b			 
100b					if DEBUG_FORTH_MALLOC 
100b						DMARK "maB" 
100b						CALLMONITOR 
100b					endif 
100b			      ; Loop through free block list to find some space 
100b			malloc_find_space: 
100b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
100c 23			      inc   HL 
100d 56			      ld    D, (HL) 
100e			 
100e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
100f b3			      or    E 
1010 ca 9c 10		      jp    Z, malloc_no_space 
1013			 
1013 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1016 dd 72 01		      ld    (IX+1), D 
1019			 
1019			      ; Does this block have enough space to make the allocation? 
1019 23			      inc   HL                      ; Load free block size into DE 
101a 5e			      ld    E, (HL) 
101b 23			      inc   HL 
101c 56			      ld    D, (HL) 
101d			 
101d eb			      ex    DE, HL                  ; Check size of block against want 
101e b7			      or    A                       ; Ensure carry flag clear 
101f ed 42		      sbc   HL, BC 
1021 e5			      push  HL                      ; Store the result for later (new block size) 
1022			 
1022 ca 71 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1025 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1027			 
1027			      ; this_free block is not big enough, setup ptrs to test next free block 
1027 e1			      pop   HL                      ; Discard previous result 
1028			 
1028 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
102b dd 66 03		      ld    H, (IX+3) 
102e dd 75 04		      ld    (IX+4), L 
1031 dd 74 05		      ld    (IX+5), H 
1034			 
1034 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1037 dd 66 01		      ld    H, (IX+1) 
103a dd 75 02		      ld    (IX+2), L 
103d dd 74 03		      ld    (IX+3), H 
1040			 
1040					if DEBUG_FORTH_MALLOC 
1040						DMARK "MA>" 
1040						CALLMONITOR 
1040					endif 
1040 18 c9		      jr    malloc_find_space 
1042			 
1042			      ; split a bigger block into two - requested size and remaining size 
1042			malloc_alloc_split: 
1042					if DEBUG_FORTH_MALLOC 
1042						DMARK "MAs" 
1042						CALLMONITOR 
1042					endif 
1042 eb			      ex    DE, HL                  ; Calculate address of new free block 
1043 2b			      dec   HL 
1044 2b			      dec   HL 
1045 2b			      dec   HL 
1046 09			      add   HL, BC 
1047			 
1047			      ; Create a new block and point it at next_free 
1047 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
104a dd 56 01		      ld    D, (IX+1) 
104d			 
104d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
104e 23			      inc   HL 
104f 72			      ld    (HL), D 
1050			 
1050 d1			      pop   DE                      ; Store size of new block into new block 
1051 23			      inc   HL 
1052 73			      ld    (HL), E 
1053 23			      inc   HL 
1054 72			      ld    (HL), D 
1055			 
1055			      ; Update this_free ptr to point to new block 
1055 2b			      dec   HL 
1056 2b			      dec   HL 
1057 2b			      dec   HL 
1058			 
1058 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
105b dd 56 03		      ld    D, (IX+3) 
105e			 
105e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1061 dd 74 03		      ld    (IX+3), H 
1064			 
1064			      ; Modify this_free block to be allocation 
1064 eb			      ex    DE, HL 
1065 af			      xor   A                       ; Null the next block ptr of allocated block 
1066 77			      ld    (HL), A 
1067 23			      inc   HL 
1068 77			      ld    (HL), A 
1069			 
1069 23			      inc   HL                      ; Store want size into allocated block 
106a 71			      ld    (HL), C 
106b 23			      inc   HL 
106c 70			      ld    (HL), B 
106d 23			      inc   HL 
106e e5			      push  HL                      ; Address of allocation to return 
106f			 
106f 18 19		      jr    malloc_update_links 
1071			 
1071			malloc_alloc_fit: 
1071 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1072			 
1072					if DEBUG_FORTH_MALLOC 
1072						DMARK "MAf" 
1072						CALLMONITOR 
1072					endif 
1072			      ; Modify this_free block to be allocation 
1072 eb			      ex    DE, HL 
1073 2b			      dec   HL 
1074 2b			      dec   HL 
1075 2b			      dec   HL 
1076			 
1076 af			      xor   A                       ; Null the next block ptr of allocated block 
1077 77			      ld    (HL), A 
1078 23			      inc   HL 
1079 77			      ld    (HL), A 
107a			 
107a 23			      inc   HL                      ; Store address of allocation to return 
107b 23			      inc   HL 
107c 23			      inc   HL 
107d e5			      push  HL 
107e			 
107e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
107e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1081 dd 66 01		      ld    H, (IX+1) 
1084			 
1084 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1087 dd 74 03		      ld    (IX+3), H 
108a			 
108a			 
108a			malloc_update_links: 
108a			      ; Update prev_free ptr to point to this_free 
108a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
108d dd 66 05		      ld    H, (IX+5) 
1090			 
1090 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1093 dd 56 03		      ld    D, (IX+3) 
1096			 
1096 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1097 23			      inc   HL 
1098 72			      ld    (HL), D 
1099			 
1099					if DEBUG_FORTH_MALLOC 
1099						DMARK "Mul" 
1099						CALLMONITOR 
1099					endif 
1099			      ; Clear the Z flag to indicate successful allocation 
1099 7a			      ld    A, D 
109a b3			      or    E 
109b			 
109b d1			      pop   DE                      ; Address of allocation 
109c					if DEBUG_FORTH_MALLOC 
109c						DMARK "MAu" 
109c						CALLMONITOR 
109c					endif 
109c			 
109c			malloc_no_space: 
109c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
109f 39			      add   HL, SP 
10a0 f9			      ld    SP, HL 
10a1			 
10a1 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
10a2					if DEBUG_FORTH_MALLOC 
10a2						DMARK "MAN" 
10a2						CALLMONITOR 
10a2					endif 
10a2			 
10a2			malloc_early_exit: 
10a2					if DEBUG_FORTH_MALLOC 
10a2						DMARK "MAx" 
10a2						CALLMONITOR 
10a2					endif 
10a2 dd e1		      pop   IX 
10a4 d1			      pop   DE 
10a5 c1			      pop   BC 
10a6			 
10a6			if DEBUG_FORTH_MALLOC_HIGH 
10a6			call malloc_guard_exit 
10a6			call malloc_guard_zerolen 
10a6			endif 
10a6 c9			      ret 
10a7			 
10a7			 
10a7			;------------------------------------------------------------------------------ 
10a7			;     free                                                                    : 
10a7			;                                                                             : 
10a7			; Description                                                                 : 
10a7			;     Return the space pointed to by HL to the heap. HL must be an address as : 
10a7			;     returned by malloc, otherwise the behaviour is undefined.               : 
10a7			;                                                                             : 
10a7			;     Where possible, directly adjacent free blocks will be merged together   : 
10a7			;     into larger blocks to help ensure that the heap does not become         : 
10a7			;     excessively fragmented.                                                 : 
10a7			;                                                                             : 
10a7			;     free does not clear or set any other value into the freed space, and    : 
10a7			;     therefore its contents may be visible through subsequent malloc's. The  : 
10a7			;     caller should clear the freed space as required.                        : 
10a7			;                                                                             : 
10a7			;     This implementation of free uses the stack exclusively, and is          : 
10a7			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10a7			;     advisable to disable interrupts before calling free, and recommended    : 
10a7			;     to avoid the use of free inside ISRs in general.                        : 
10a7			;                                                                             : 
10a7			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10a7			;                                                                             : 
10a7			; Parameters                                                                  : 
10a7			;     HL  Pointer to address of first byte of allocation to be freed          : 
10a7			;                                                                             : 
10a7			; Returns                                                                     : 
10a7			;     Nothing                                                                 : 
10a7			;                                                                             : 
10a7			; Stack frame                                                                 : 
10a7			;       |             |                                                       : 
10a7			;       +-------------+                                                       : 
10a7			;       |     BC      |                                                       : 
10a7			;       +-------------+                                                       : 
10a7			;       |     DE      |                                                       : 
10a7			;       +-------------+                                                       : 
10a7			;       |     IX      |                                                       : 
10a7			;       +-------------+                                                       : 
10a7			;       |  prev_free  |                                                       : 
10a7			;   +2  +-------------+                                                       : 
10a7			;       |  next_free  |                                                       : 
10a7			;   +0  +-------------+                                                       : 
10a7			;       |             |                                                       : 
10a7			;                                                                             : 
10a7			;------------------------------------------------------------------------------ 
10a7			free: 
10a7 c5			      push  BC 
10a8 d5			      push  DE 
10a9 dd e5		      push  IX 
10ab			 
10ab 7c			      ld    A, H                    ; Exit if ptr is null 
10ac b5			      or    L 
10ad ca 71 11		      jp    Z, free_early_exit 
10b0			 
10b0			      ; Set up stack frame 
10b0 eb			      ex    DE, HL 
10b1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
10b4 39			      add   HL, SP 
10b5 f9			      ld    SP, HL 
10b6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10ba dd 39		      add   IX, SP 
10bc			 
10bc			      ; The address in HL points to the start of the useable allocated space, 
10bc			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
10bc			      ; address of the block itself. 
10bc eb			      ex    DE, HL 
10bd 11 fc ff		      ld    DE, -4 
10c0 19			      add   HL, DE 
10c1			 
10c1			      ; An allocated block must have a null next block pointer in it 
10c1 7e			      ld    A, (HL) 
10c2 23			      inc   HL 
10c3 b6			      or    (HL) 
10c4 c2 6c 11		      jp    NZ, free_done 
10c7			 
10c7 2b			      dec   HL 
10c8			 
10c8 44			      ld    B, H                    ; Copy HL to BC 
10c9 4d			      ld    C, L 
10ca			 
10ca			      ; Loop through the free list to find the first block with an address 
10ca			      ; higher than the block being freed 
10ca 21 0a 80		      ld    HL, free_list 
10cd			 
10cd			free_find_higher_block: 
10cd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
10ce 23			      inc   HL 
10cf 56			      ld    D, (HL) 
10d0 2b			      dec   HL 
10d1			 
10d1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
10d4 dd 72 01		      ld    (IX+1), D 
10d7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
10da dd 74 03		      ld    (IX+3), H 
10dd			 
10dd 78			      ld    A, B                    ; Check if DE is greater than BC 
10de ba			      cp    D                       ; Compare MSB first 
10df 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
10e1 30 04		      jr    NC, free_find_higher_block_skip 
10e3 79			      ld    A, C 
10e4 bb			      cp    E                       ; Then compare LSB 
10e5 38 08		      jr    C, free_found_higher_block 
10e7			 
10e7			free_find_higher_block_skip: 
10e7 7a			      ld    A, D                    ; Reached the end of the free list? 
10e8 b3			      or    E 
10e9 ca 6c 11		      jp    Z, free_done 
10ec			 
10ec eb			      ex    DE, HL 
10ed			 
10ed 18 de		      jr    free_find_higher_block 
10ef			 
10ef			free_found_higher_block: 
10ef			      ; Insert freed block between prev and next free blocks 
10ef 71			      ld    (HL), C                 ; Point prev free block to freed block 
10f0 23			      inc   HL 
10f1 70			      ld    (HL), B 
10f2			 
10f2 60			      ld    H, B                    ; Point freed block at next free block 
10f3 69			      ld    L, C 
10f4 73			      ld    (HL), E 
10f5 23			      inc   HL 
10f6 72			      ld    (HL), D 
10f7			 
10f7			      ; Check if the freed block is adjacent to the next free block 
10f7 23			      inc   HL                      ; Load size of freed block into HL 
10f8 5e			      ld    E, (HL) 
10f9 23			      inc   HL 
10fa 56			      ld    D, (HL) 
10fb eb			      ex    DE, HL 
10fc			 
10fc 09			      add   HL, BC                  ; Add addr of freed block and its size 
10fd			 
10fd dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1100 dd 56 01		      ld    D, (IX+1) 
1103			 
1103 b7			      or    A                       ; Clear the carry flag 
1104 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1106 20 22		      jr    NZ, free_check_adjacent_to_prev 
1108			 
1108			      ; Freed block is adjacent to next, merge into one bigger block 
1108 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1109 5e			      ld    E, (HL) 
110a 23			      inc   HL 
110b 56			      ld    D, (HL) 
110c e5			      push  HL                      ; Save ptr to next block for later 
110d			 
110d 60			      ld    H, B                    ; Store ptr from next block into freed block 
110e 69			      ld    L, C 
110f 73			      ld    (HL), E 
1110 23			      inc   HL 
1111 72			      ld    (HL), D 
1112			 
1112 e1			      pop   HL                      ; Restore ptr to next block 
1113 23			      inc   HL                      ; Load size of next block into DE 
1114 5e			      ld    E, (HL) 
1115 23			      inc   HL 
1116 56			      ld    D, (HL) 
1117 d5			      push  DE                      ; Save next block size for later 
1118			 
1118 60			      ld    H, B                    ; Load size of freed block into HL 
1119 69			      ld    L, C 
111a 23			      inc   HL 
111b 23			      inc   HL 
111c 5e			      ld    E, (HL) 
111d 23			      inc   HL 
111e 56			      ld    D, (HL) 
111f eb			      ex    DE, HL 
1120			 
1120 d1			      pop   DE                      ; Restore size of next block 
1121 19			      add   HL, DE                  ; Add sizes of both blocks 
1122 eb			      ex    DE, HL 
1123			 
1123 60			      ld    H, B                    ; Store new bigger size into freed block 
1124 69			      ld    L, C 
1125 23			      inc   HL 
1126 23			      inc   HL 
1127 73			      ld    (HL), E 
1128 23			      inc   HL 
1129 72			      ld    (HL), D 
112a			 
112a			free_check_adjacent_to_prev: 
112a			      ; Check if the freed block is adjacent to the prev free block 
112a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
112d dd 66 03		      ld    H, (IX+3) 
1130			 
1130 23			      inc   HL                      ; Size of prev free block into DE 
1131 23			      inc   HL 
1132 5e			      ld    E, (HL) 
1133 23			      inc   HL 
1134 56			      ld    D, (HL) 
1135 2b			      dec   HL 
1136 2b			      dec   HL 
1137 2b			      dec   HL 
1138			 
1138 19			      add   HL, DE                  ; Add prev block addr and size 
1139			 
1139 b7			      or    A                       ; Clear the carry flag 
113a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
113c 20 2e		      jr    NZ, free_done 
113e			 
113e			      ; Freed block is adjacent to prev, merge into one bigger block 
113e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
113f 69			      ld    L, C 
1140 5e			      ld    E, (HL) 
1141 23			      inc   HL 
1142 56			      ld    D, (HL) 
1143 e5			      push  HL                      ; Save freed block ptr for later 
1144			 
1144 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1147 dd 66 03		      ld    H, (IX+3) 
114a 73			      ld    (HL), E 
114b 23			      inc   HL 
114c 72			      ld    (HL), D 
114d			 
114d e1			      pop   HL                      ; Restore freed block ptr 
114e 23			      inc   HL                      ; Load size of freed block into DE 
114f 5e			      ld    E, (HL) 
1150 23			      inc   HL 
1151 56			      ld    D, (HL) 
1152 d5			      push  DE                      ; Save freed block size for later 
1153			 
1153 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1156 dd 66 03		      ld    H, (IX+3) 
1159 23			      inc   HL 
115a 23			      inc   HL 
115b 5e			      ld    E, (HL) 
115c 23			      inc   HL 
115d 56			      ld    D, (HL) 
115e			 
115e e1			      pop   HL                      ; Add sizes of both blocks 
115f 19			      add   HL, DE 
1160 eb			      ex    DE, HL 
1161			 
1161 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1164 dd 66 03		      ld    H, (IX+3) 
1167 23			      inc   HL 
1168 23			      inc   HL 
1169 73			      ld    (HL), E 
116a 23			      inc   HL 
116b 72			      ld    (HL), D 
116c			 
116c			free_done: 
116c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
116f 39			      add   HL, SP 
1170 f9			      ld    SP, HL 
1171			 
1171			free_early_exit: 
1171 dd e1		      pop   IX 
1173 d1			      pop   DE 
1174 c1			      pop   BC 
1175			 
1175 c9			      ret 
1176			 
1176			; moved to firmware.asm 
1176			; 
1176			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1176			;                  .dw   0 
1176			 
1176			 
1176			endif 
1176			 
1176			 
1176			if MALLOC_3 
1176			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1176			;heap_start        .equ  0x9000      ; Starting address of heap 
1176			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1176			; 
1176			 ;     .org 0 
1176			  ;    jp    main 
1176			; 
1176			; 
1176			 ;     .org  0x100 
1176			;main: 
1176			 ;     ld    HL, 0x8100 
1176			  ;    ld    SP, HL 
1176			; 
1176			;      call  heap_init 
1176			 
1176			      ; Make some allocations 
1176			;      ld    HL, 12 
1176			;      call  malloc            ; Allocates 0x9004 
1176			; 
1176			 ;     ld    HL, 12 
1176			;      call  malloc            ; Allocates 0x9014 
1176			 
1176			;      ld    HL, 12 
1176			;      call  malloc            ; Allocates 0x9024 
1176			 
1176			      ; Free some allocations 
1176			;      ld    HL, 0x9014 
1176			;      call  free 
1176			 
1176			;      ld    HL, 0x9004 
1176			;      call  free 
1176			; 
1176			;      ld    HL, 0x9024 
1176			;      call  free 
1176			 
1176			 
1176			 ;     halt 
1176			 
1176			 
1176			;------------------------------------------------------------------------------ 
1176			;     heap_init                                                               : 
1176			;                                                                             : 
1176			; Description                                                                 : 
1176			;     Initialise the heap and make it ready for malloc and free operations.   : 
1176			;                                                                             : 
1176			;     The heap is maintained as a linked list, starting with an initial       : 
1176			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1176			;     the first free block in the heap. Each block then points to the next    : 
1176			;     free block within the heap, and the free list ends at the first block   : 
1176			;     with a null pointer to the next free block.                             : 
1176			;                                                                             : 
1176			; Parameters                                                                  : 
1176			;     Inputs are compile-time only. Two defines which specify the starting    : 
1176			;     address of the heap and its size are required, along with a memory      : 
1176			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1176			;     principally stores a pointer to the first free block in the heap.       : 
1176			;                                                                             : 
1176			; Returns                                                                     : 
1176			;     Nothing                                                                 : 
1176			;------------------------------------------------------------------------------ 
1176			heap_init: 
1176			      push  HL 
1176			 
1176			      ; Initialise free list struct 
1176			      ld    HL, heap_start 
1176			      ld    (free_list), HL 
1176			      ld    HL, 0 
1176			      ld    (free_list+2), HL 
1176			 
1176			      ; Insert first free block at bottom of heap, consumes entire heap 
1176			      ld    HL, heap_start+heap_size-4 
1176			      ld    (heap_start), HL        ; Next block (end of free list) 
1176			      ld    HL, heap_size-4 
1176			      ld    (heap_start+2), HL      ; Block size 
1176			 
1176			      ; Insert end of free list block at top of heap - two null words will 
1176			      ; terminate the free list 
1176			      ld    HL, 0 
1176			      ld    (heap_start+heap_size-2), HL 
1176			      ld    (heap_start+heap_size-4), HL 
1176			 
1176			      pop   HL 
1176			 
1176			      ret 
1176			 
1176			 
1176			;------------------------------------------------------------------------------ 
1176			;     malloc                                                                  : 
1176			;                                                                             : 
1176			; Description                                                                 : 
1176			;     Allocates the wanted space from the heap and returns the address of the : 
1176			;     first useable byte of the allocation.                                   : 
1176			;                                                                             : 
1176			;     Allocations can happen in one of two ways:                              : 
1176			;                                                                             : 
1176			;     1. A free block may be found which is the exact size wanted. In this    : 
1176			;        case the block is removed from the free list and retuedn to the      : 
1176			;        caller.                                                              : 
1176			;     2. A free block may be found which is larger than the size wanted. In   : 
1176			;        this case, the larger block is split into two. The first portion of  : 
1176			;        this block will become the requested space by the malloc call and    : 
1176			;        is returned to the caller. The second portion becomes a new free     : 
1176			;        block, and the free list is adjusted to maintain continuity via this : 
1176			;        newly created block.                                                 : 
1176			;                                                                             : 
1176			;     malloc does not set any initial value in the allocated space, the       : 
1176			;     caller is required to do this as required.                              : 
1176			;                                                                             : 
1176			;     This implementation of malloc uses the stack exclusively, and is        : 
1176			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1176			;     advisable to disable interrupts before calling malloc, and recommended  : 
1176			;     to avoid the use of malloc inside ISRs in general.                      : 
1176			;                                                                             : 
1176			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1176			;                                                                             : 
1176			; Parameters                                                                  : 
1176			;     HL  Number of bytes wanted                                              : 
1176			;                                                                             : 
1176			; Returns                                                                     : 
1176			;     HL  Address of the first useable byte of the allocation                 : 
1176			;                                                                             : 
1176			; Flags                                                                       : 
1176			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1176			;                                                                             : 
1176			; Stack frame                                                                 : 
1176			;       |             |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     BC      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     DE      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     IX      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |  prev_free  |                                                       : 
1176			;   +4  +-------------+                                                       : 
1176			;       |  this_free  |                                                       : 
1176			;   +2  +-------------+                                                       : 
1176			;       |  next_free  |                                                       : 
1176			;   +0  +-------------+                                                       : 
1176			;       |             |                                                       : 
1176			;                                                                             : 
1176			;------------------------------------------------------------------------------ 
1176			malloc: 
1176			      push  BC 
1176			      push  DE 
1176			      push  IX 
1176			 
1176			      ld    A, H                    ; Exit if no space requested 
1176			      or    L 
1176			      jp    Z, malloc_early_exit 
1176			 
1176			      ; Set up stack frame 
1176			      ex    DE, HL 
1176			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1176			      add   HL, SP 
1176			      ld    SP, HL 
1176			      ld    IX, 0                   ; Use IX as a frame pointer 
1176			      add   IX, SP 
1176			 
1176			      ; Setup initial state 
1176			      ld    HL, 4                   ; want must also include space used by block struct 
1176			      add   HL, DE 
1176			 
1176			      ld    B, H                    ; Move want to BC 
1176			      ld    C, L 
1176			 
1176			      ld    HL, free_list           ; Store prev_free ptr to stack 
1176			      ld    (IX+4), L 
1176			      ld    (IX+5), H 
1176			 
1176			      ld    E, (HL)                 ; Store this_free ptr to stack 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      ld    (IX+2), E 
1176			      ld    (IX+3), D 
1176			      ex    DE, HL                  ; this_free ptr into HL 
1176			 
1176			      ; Loop through free block list to find some space 
1176			malloc_find_space: 
1176			      ld    E, (HL)                 ; Load next_free ptr into DE 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			 
1176			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1176			      or    E 
1176			      jp    Z, malloc_no_space 
1176			 
1176			      ld    (IX+0), E               ; Store next_free ptr to stack 
1176			      ld    (IX+1), D 
1176			 
1176			      ; Does this block have enough space to make the allocation? 
1176			      inc   HL                      ; Load free block size into DE 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			 
1176			      ex    DE, HL                  ; Check size of block against want 
1176			      or    A                       ; Ensure carry flag clear 
1176			      sbc   HL, BC 
1176			      push  HL                      ; Store the result for later (new block size) 
1176			 
1176			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1176			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1176			 
1176			      ; this_free block is not big enough, setup ptrs to test next free block 
1176			      pop   HL                      ; Discard previous result 
1176			 
1176			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1176			      ld    H, (IX+3) 
1176			      ld    (IX+4), L 
1176			      ld    (IX+5), H 
1176			 
1176			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1176			      ld    H, (IX+1) 
1176			      ld    (IX+2), L 
1176			      ld    (IX+3), H 
1176			 
1176			      jr    malloc_find_space 
1176			 
1176			      ; split a bigger block into two - requested size and remaining size 
1176			malloc_alloc_split: 
1176			      ex    DE, HL                  ; Calculate address of new free block 
1176			      dec   HL 
1176			      dec   HL 
1176			      dec   HL 
1176			      add   HL, BC 
1176			 
1176			      ; Create a new block and point it at next_free 
1176			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1176			      ld    D, (IX+1) 
1176			 
1176			      ld    (HL), E                 ; Store next_free ptr into new block 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      pop   DE                      ; Store size of new block into new block 
1176			      inc   HL 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      ; Update this_free ptr to point to new block 
1176			      dec   HL 
1176			      dec   HL 
1176			      dec   HL 
1176			 
1176			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1176			      ld    D, (IX+3) 
1176			 
1176			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1176			      ld    (IX+3), H 
1176			 
1176			      ; Modify this_free block to be allocation 
1176			      ex    DE, HL 
1176			      xor   A                       ; Null the next block ptr of allocated block 
1176			      ld    (HL), A 
1176			      inc   HL 
1176			      ld    (HL), A 
1176			 
1176			      inc   HL                      ; Store want size into allocated block 
1176			      ld    (HL), C 
1176			      inc   HL 
1176			      ld    (HL), B 
1176			      inc   HL 
1176			      push  HL                      ; Address of allocation to return 
1176			 
1176			      jr    malloc_update_links 
1176			 
1176			malloc_alloc_fit: 
1176			      pop   HL                      ; Dont need new block size, want is exact fit 
1176			 
1176			      ; Modify this_free block to be allocation 
1176			      ex    DE, HL 
1176			      dec   HL 
1176			      dec   HL 
1176			      dec   HL 
1176			 
1176			      xor   A                       ; Null the next block ptr of allocated block 
1176			      ld    (HL), A 
1176			      inc   HL 
1176			      ld    (HL), A 
1176			 
1176			      inc   HL                      ; Store address of allocation to return 
1176			      inc   HL 
1176			      inc   HL 
1176			      push  HL 
1176			 
1176			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1176			      ld    L, (IX+0)               ; next_free to HL 
1176			      ld    H, (IX+1) 
1176			 
1176			      ld    (IX+2), L               ; HL to this_free 
1176			      ld    (IX+3), H 
1176			 
1176			 
1176			malloc_update_links: 
1176			      ; Update prev_free ptr to point to this_free 
1176			      ld    L, (IX+4)               ; prev_free ptr to HL 
1176			      ld    H, (IX+5) 
1176			 
1176			      ld    E, (IX+2)               ; this_free ptr to DE 
1176			      ld    D, (IX+3) 
1176			 
1176			      ld    (HL), E                 ; this_free ptr into prev_free 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      ; Clear the Z flag to indicate successful allocation 
1176			      ld    A, D 
1176			      or    E 
1176			 
1176			      pop   DE                      ; Address of allocation 
1176			 
1176			malloc_no_space: 
1176			      ld    HL, 6                   ; Clean up stack frame 
1176			      add   HL, SP 
1176			      ld    SP, HL 
1176			 
1176			      ex    DE, HL                  ; Alloc addr into HL for return 
1176			 
1176			malloc_early_exit: 
1176			      pop   IX 
1176			      pop   DE 
1176			      pop   BC 
1176			 
1176			      ret 
1176			 
1176			 
1176			;------------------------------------------------------------------------------ 
1176			;     free                                                                    : 
1176			;                                                                             : 
1176			; Description                                                                 : 
1176			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1176			;     returned by malloc, otherwise the behaviour is undefined.               : 
1176			;                                                                             : 
1176			;     Where possible, directly adjacent free blocks will be merged together   : 
1176			;     into larger blocks to help ensure that the heap does not become         : 
1176			;     excessively fragmented.                                                 : 
1176			;                                                                             : 
1176			;     free does not clear or set any other value into the freed space, and    : 
1176			;     therefore its contents may be visible through subsequent malloc's. The  : 
1176			;     caller should clear the freed space as required.                        : 
1176			;                                                                             : 
1176			;     This implementation of free uses the stack exclusively, and is          : 
1176			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1176			;     advisable to disable interrupts before calling free, and recommended    : 
1176			;     to avoid the use of free inside ISRs in general.                        : 
1176			;                                                                             : 
1176			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1176			;                                                                             : 
1176			; Parameters                                                                  : 
1176			;     HL  Pointer to address of first byte of allocation to be freed          : 
1176			;                                                                             : 
1176			; Returns                                                                     : 
1176			;     Nothing                                                                 : 
1176			;                                                                             : 
1176			; Stack frame                                                                 : 
1176			;       |             |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     BC      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     DE      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |     IX      |                                                       : 
1176			;       +-------------+                                                       : 
1176			;       |  prev_free  |                                                       : 
1176			;   +2  +-------------+                                                       : 
1176			;       |  next_free  |                                                       : 
1176			;   +0  +-------------+                                                       : 
1176			;       |             |                                                       : 
1176			;                                                                             : 
1176			;------------------------------------------------------------------------------ 
1176			free: 
1176			      push  BC 
1176			      push  DE 
1176			      push  IX 
1176			 
1176			      ld    A, H                    ; Exit if ptr is null 
1176			      or    L 
1176			      jp    Z, free_early_exit 
1176			 
1176			      ; Set up stack frame 
1176			      ex    DE, HL 
1176			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1176			      add   HL, SP 
1176			      ld    SP, HL 
1176			      ld    IX, 0                   ; Use IX as a frame pointer 
1176			      add   IX, SP 
1176			 
1176			      ; The address in HL points to the start of the useable allocated space, 
1176			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1176			      ; address of the block itself. 
1176			      ex    DE, HL 
1176			      ld    DE, -4 
1176			      add   HL, DE 
1176			 
1176			      ; An allocated block must have a null next block pointer in it 
1176			      ld    A, (HL) 
1176			      inc   HL 
1176			      or    (HL) 
1176			      jp    NZ, free_done 
1176			 
1176			      dec   HL 
1176			 
1176			      ld    B, H                    ; Copy HL to BC 
1176			      ld    C, L 
1176			 
1176			      ; Loop through the free list to find the first block with an address 
1176			      ; higher than the block being freed 
1176			      ld    HL, free_list 
1176			 
1176			free_find_higher_block: 
1176			      ld    E, (HL)                 ; Load next ptr from free block 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      dec   HL 
1176			 
1176			      ld    (IX+0), E               ; Save ptr to next free block 
1176			      ld    (IX+1), D 
1176			      ld    (IX+2), L               ; Save ptr to prev free block 
1176			      ld    (IX+3), H 
1176			 
1176			      ld    A, B                    ; Check if DE is greater than BC 
1176			      cp    D                       ; Compare MSB first 
1176			      jr    Z, $+4                  ; MSB the same, compare LSB 
1176			      jr    NC, free_find_higher_block_skip 
1176			      ld    A, C 
1176			      cp    E                       ; Then compare LSB 
1176			      jr    C, free_found_higher_block 
1176			 
1176			free_find_higher_block_skip: 
1176			      ld    A, D                    ; Reached the end of the free list? 
1176			      or    E 
1176			      jp    Z, free_done 
1176			 
1176			      ex    DE, HL 
1176			 
1176			      jr    free_find_higher_block 
1176			 
1176			free_found_higher_block: 
1176			      ; Insert freed block between prev and next free blocks 
1176			      ld    (HL), C                 ; Point prev free block to freed block 
1176			      inc   HL 
1176			      ld    (HL), B 
1176			 
1176			      ld    H, B                    ; Point freed block at next free block 
1176			      ld    L, C 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      ; Check if the freed block is adjacent to the next free block 
1176			      inc   HL                      ; Load size of freed block into HL 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      ex    DE, HL 
1176			 
1176			      add   HL, BC                  ; Add addr of freed block and its size 
1176			 
1176			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1176			      ld    D, (IX+1) 
1176			 
1176			      or    A                       ; Clear the carry flag 
1176			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1176			      jr    NZ, free_check_adjacent_to_prev 
1176			 
1176			      ; Freed block is adjacent to next, merge into one bigger block 
1176			      ex    DE, HL                  ; Load next ptr from next block into DE 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      push  HL                      ; Save ptr to next block for later 
1176			 
1176			      ld    H, B                    ; Store ptr from next block into freed block 
1176			      ld    L, C 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      pop   HL                      ; Restore ptr to next block 
1176			      inc   HL                      ; Load size of next block into DE 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      push  DE                      ; Save next block size for later 
1176			 
1176			      ld    H, B                    ; Load size of freed block into HL 
1176			      ld    L, C 
1176			      inc   HL 
1176			      inc   HL 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      ex    DE, HL 
1176			 
1176			      pop   DE                      ; Restore size of next block 
1176			      add   HL, DE                  ; Add sizes of both blocks 
1176			      ex    DE, HL 
1176			 
1176			      ld    H, B                    ; Store new bigger size into freed block 
1176			      ld    L, C 
1176			      inc   HL 
1176			      inc   HL 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			free_check_adjacent_to_prev: 
1176			      ; Check if the freed block is adjacent to the prev free block 
1176			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1176			      ld    H, (IX+3) 
1176			 
1176			      inc   HL                      ; Size of prev free block into DE 
1176			      inc   HL 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      dec   HL 
1176			      dec   HL 
1176			      dec   HL 
1176			 
1176			      add   HL, DE                  ; Add prev block addr and size 
1176			 
1176			      or    A                       ; Clear the carry flag 
1176			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1176			      jr    NZ, free_done 
1176			 
1176			      ; Freed block is adjacent to prev, merge into one bigger block 
1176			      ld    H, B                    ; Load next ptr from freed block into DE 
1176			      ld    L, C 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      push  HL                      ; Save freed block ptr for later 
1176			 
1176			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1176			      ld    H, (IX+3) 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			      pop   HL                      ; Restore freed block ptr 
1176			      inc   HL                      ; Load size of freed block into DE 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			      push  DE                      ; Save freed block size for later 
1176			 
1176			      ld    L, (IX+2)               ; Load size of prev block into DE 
1176			      ld    H, (IX+3) 
1176			      inc   HL 
1176			      inc   HL 
1176			      ld    E, (HL) 
1176			      inc   HL 
1176			      ld    D, (HL) 
1176			 
1176			      pop   HL                      ; Add sizes of both blocks 
1176			      add   HL, DE 
1176			      ex    DE, HL 
1176			 
1176			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1176			      ld    H, (IX+3) 
1176			      inc   HL 
1176			      inc   HL 
1176			      ld    (HL), E 
1176			      inc   HL 
1176			      ld    (HL), D 
1176			 
1176			free_done: 
1176			      ld    HL, 4                   ; Clean up stack frame 
1176			      add   HL, SP 
1176			      ld    SP, HL 
1176			 
1176			free_early_exit: 
1176			      pop   IX 
1176			      pop   DE 
1176			      pop   BC 
1176			 
1176			      ret 
1176			 
1176			 
1176			;      .org 0x8000 
1176			; 
1176			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1176			 ;                 .dw   0 
1176			 
1176			endif 
1176			 
1176			 
1176			if MALLOC_4 
1176			 
1176			; My memory allocation code. Very very simple.... 
1176			; allocate space under 250 chars 
1176			 
1176			heap_init: 
1176				; init start of heap as zero 
1176				;  
1176			 
1176				ld hl, heap_start 
1176				ld a, 0 
1176				ld (hl), a      ; empty block 
1176				inc hl 
1176				ld a, 0 
1176				ld (hl), a      ; length of block 
1176				; write end of list 
1176				inc hl 
1176				ld a,(hl) 
1176				inc hl 
1176				ld a,(hl) 
1176				 
1176			 
1176				; init some malloc vars 
1176			 
1176				ld hl, 0 
1176				ld (free_list), hl       ; store last malloc location 
1176			 
1176				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1176				ld a, 0 
1176				ld (hl), a 
1176			 
1176			 
1176				ld hl, heap_start 
1176				;  
1176				  
1176				ret 
1176			 
1176			 
1176			;    free block marker 
1176			;    requested size  
1176			;    pointer to next block 
1176			;    .... 
1176			;    next block marker 
1176			 
1176			 
1176			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1176			; 
1176			 
1176			 
1176			malloc:  
1176				push de 
1176				push bc 
1176				push af 
1176			 
1176				; hl space required 
1176				 
1176				ld c, l    ; hold space   (TODO only a max of 255) 
1176			 
1176			;	inc c     ; TODO BUG need to fix memory leak on push str 
1176			;	inc c 
1176			;	inc c 
1176			;	inc c 
1176			;	inc c 
1176			;	inc c 
1176			;	inc c 
1176			 
1176			 
1176			 
1176				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1176			 
1176				ld a, (free_list+3) 
1176				cp 0 
1176				jr z, .contheap 
1176			 
1176				ld hl, (free_list)     ; get last alloc 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "mrs" 
1176						CALLMONITOR 
1176					endif 
1176				jr .startalloc 
1176			 
1176			.contheap: 
1176				ld hl, heap_start 
1176			 
1176			.startalloc: 
1176			 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "mym" 
1176						CALLMONITOR 
1176					endif 
1176			.findblock: 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "mmf" 
1176						CALLMONITOR 
1176					endif 
1176			 
1176				ld a,(hl)  
1176				; if byte is zero then clear to use 
1176			 
1176				cp 0 
1176				jr z, .foundemptyblock 
1176			 
1176				; if byte is not clear 
1176				;     then byte is offset to next block 
1176			 
1176				inc hl 
1176				ld a, (hl) ; get size 
1176			.nextblock:	inc hl 
1176					ld e, (hl) 
1176					inc hl 
1176					ld d, (hl) 
1176					ex de, hl 
1176			;	inc hl  ; move past the store space 
1176			;	inc hl  ; move past zero index  
1176			 
1176				; TODO detect no more space 
1176			 
1176				push hl 
1176				ld de, heap_end 
1176				call cmp16 
1176				pop hl 
1176				jr nc, .nospace 
1176			 
1176				jr .findblock 
1176			 
1176			.nospace: ld hl, 0 
1176				jp .exit 
1176			 
1176			 
1176			.foundemptyblock:	 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "mme" 
1176						CALLMONITOR 
1176					endif 
1176			 
1176			; TODO has block enough space if reusing??? 
1176			 
1176				;  
1176			 
1176			; see if this block has been previously used 
1176				inc hl 
1176				ld a, (hl) 
1176				dec hl 
1176				cp 0 
1176				jr z, .newblock 
1176			 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "meR" 
1176						CALLMONITOR 
1176					endif 
1176			 
1176			; no reusing previously allocated block 
1176			 
1176			; is it smaller than previously used? 
1176				 
1176				inc hl    ; move to size 
1176				ld a, c 
1176				sub (hl)        ; we want c < (hl) 
1176				dec hl    ; move back to marker 
1176			        jr z, .findblock 
1176			 
1176				; update with the new size which should be lower 
1176			 
1176			        ;inc  hl   ; negate next move. move back to size  
1176			 
1176			.newblock: 
1176				; need to be at marker here 
1176			 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "meN" 
1176						CALLMONITOR 
1176					endif 
1176			 
1176			 
1176				ld a, c 
1176			 
1176				ld (free_list+3), a	 ; flag resume from last malloc  
1176				ld (free_list), hl    ; save out last location 
1176			 
1176			 
1176				;inc a     ; space for length byte 
1176				ld (hl), a     ; save block in use marker 
1176			 
1176				inc hl   ; move to space marker 
1176				ld (hl), a    ; save new space 
1176			 
1176				inc hl   ; move to start of allocated area 
1176				 
1176			;	push hl     ; save where we are - 1  
1176			 
1176			;	inc hl  ; move past zero index  
1176				; skip space to set down new marker 
1176			 
1176				; provide some extra space for now 
1176			 
1176				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1176				inc a 
1176				inc a 
1176			 
1176				push hl   ; save where we are in the node block 
1176			 
1176				call addatohl 
1176			 
1176				; write linked list point 
1176			 
1176				pop de     ; get our node position 
1176				ex de, hl 
1176			 
1176				ld (hl), e 
1176				inc hl 
1176				ld (hl), d 
1176			 
1176				inc hl 
1176			 
1176				; now at start of allocated data so save pointer 
1176			 
1176				push hl 
1176			 
1176				; jump to position of next node and setup empty header in DE 
1176			 
1176				ex de, hl 
1176			 
1176			;	inc hl ; move past end of block 
1176			 
1176				ld a, 0 
1176				ld (hl), a   ; empty marker 
1176				inc hl 
1176				ld (hl), a   ; size 
1176				inc hl  
1176				ld (hl), a   ; ptr 
1176				inc hl 
1176				ld (hl), a   ; ptr 
1176			 
1176			 
1176				pop hl 
1176			 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "mmr" 
1176						CALLMONITOR 
1176					endif 
1176			 
1176			.exit: 
1176				pop af 
1176				pop bc 
1176				pop de  
1176				ret 
1176			 
1176			 
1176			 
1176			 
1176			free:  
1176				push hl 
1176				push af 
1176				; get address in hl 
1176			 
1176					if DEBUG_FORTH_MALLOC_INT 
1176						DMARK "fre" 
1176						CALLMONITOR 
1176					endif 
1176				; data is at hl - move to block count 
1176				dec hl 
1176				dec hl    ; get past pointer 
1176				dec hl 
1176			 
1176				ld a, (hl)    ; need this for a validation check 
1176			 
1176				dec hl    ; move to block marker 
1176			 
1176				; now check that the block count and block marker are the same  
1176			        ; this checks that we are on a malloc node and not random memory 
1176			        ; OK a faint chance this could be a problem but rare - famous last words! 
1176			 
1176				ld c, a 
1176				ld a, (hl)    
1176			 
1176				cp c 
1176				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1176			 
1176				; yes good chance we are on a malloc node 
1176			 
1176				ld a, 0      
1176				ld (hl), a   ; mark as free 
1176			 
1176				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1176			 
1176			.freeignore:  
1176			 
1176				pop af 
1176				pop hl 
1176			 
1176				ret 
1176			 
1176			 
1176			 
1176			endif 
1176			 
1176			; eof 
# End of file firmware_memory.asm
1176			  
1176			; device C  
1176			if SOUND_ENABLE  
1176				include "firmware_sound.asm"  
1176			; Sound abstraction layer 
1176			 
1176			; support different sound chips through common interface 
1176			 
1176			SOUND_DEVICE_AY: equ 0 
1176			 
1176			SOUND_DEVICE: equ Device_A 
1176			 
1176			 
1176			 
1176			if SOUND_DEVICE_AY 
1176				include "firmware_sound_ay38910.asm" 
1176			else 
1176				include "firmware_sound_sn76489an.asm" 
1176			 
1176			; Device support for SN76489AN sound chip 
1176			 
1176			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1176			; http://danceswithferrets.org/geekblog/?p=93 
1176			; https://www.smspower.org/Development/SN76489 
1176			 
1176			; D0 [ 3] 
1176			; D1 [ 2] 
1176			; D2 [ 1] 
1176			; D3 [15] 
1176			; D4 [13] 
1176			; D5 [12] 
1176			; D6 [11] 
1176			; D7 [10] 
1176			; /WE [ 5] 
1176			; CLK [14] 
1176			; /OE [ 6] 
1176			; AUDIO [ 7] 
1176			; GND 8 
1176			; +5 16 
1176			; 
1176			 
1176			; Write sequence: 
1176			; CE low 
1176			; Data bus 
1176			; WE low then high 
1176			; 32 clock cycles / 8ns write time at 4mhz 
1176			; 
1176			; https://github.com/jblang/SN76489 
1176			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1176			; Tried: 
1176			; 
1176			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1176			; 
1176			; Connected WE to OR too 
1176			;  
1176			; That enabled the clock when required 
1176			; However still random bus corruption. Need further investigation 
1176			 
1176			 
1176			SOUND_LATCH: equ 10000000B 
1176			SOUND_DATA: equ 0B 
1176			SOUND_CH0:  equ 0B    ; Tone 
1176			SOUND_CH1: equ 0100000B        ; Tone 
1176			SOUND_CH2: equ 1000000B   ; Tone 
1176			SOUND_CH3: equ 1100000B    ; Noise 
1176			SOUND_VOL: equ 10000B 
1176			SOUND_TONE: equ 0B 
1176			 
1176			 
1176			sound_init: 
1176 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1178 cd 8d 11			call note_send_byte 
117b 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
117d cd 8d 11			call note_send_byte 
1180 cd 35 09			call delay250ms 
1183 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1185 cd 8d 11			call note_send_byte 
1188 cd 35 09			call delay250ms 
118b c9				ret 
118c			 
118c			; Play a note 
118c			; h = note 
118c			; l = duration 
118c			; a = channel 
118c			 
118c			 
118c			;  frequ = clock / ( 2 x reg valu x 32 )  
118c			 
118c			note:  
118c				 
118c			 
118c c9				ret 
118d			 
118d			note_send_byte: 
118d				; byte in a 
118d			 
118d				; we high 
118d d3 40			out (Device_B), a 
118f			;	ld a, 1 
118f			;	call aDelayInMS 
118f 00				nop  
1190 00				nop  
1191 00				nop  
1192 00				nop  
1193				; we low 
1193 d3 40			out (Device_B), a 
1195			;	ld a, 1 
1195			;	call aDelayInMS 
1195 00				nop  
1196 00				nop  
1197 00				nop  
1198 00				nop  
1199				; we high 
1199 d3 40			out (Device_B), a 
119b			;	ld a, 1 
119b			;	call aDelayInMS 
119b 00				nop  
119c 00				nop  
119d 00				nop  
119e 00				nop  
119f			 
119f			 
119f c9				ret 
11a0			 
11a0			;void SilenceAllChannels() 
11a0			;{ 
11a0			;  SendByte(0x9f); 
11a0			;  SendByte(0xbf); 
11a0			;  SendByte(0xdf); 
11a0			;  SendByte(0xff); 
11a0			;} 
11a0			 
11a0			 
11a0			; eof 
11a0			 
# End of file firmware_sound_sn76489an.asm
11a0			endif 
11a0			 
11a0			 
11a0			; Abstraction entry points 
11a0			 
11a0			; init  
11a0			 
11a0			; sound_init in specific hardware files 
11a0			 
11a0			; Play a note 
11a0			; h = note 
11a0			; l = duration 
11a0			; a = channel 
11a0			 
11a0			;note:     
11a0			;	ret 
11a0			 
11a0			 
11a0			 
11a0			 
11a0			; eof 
11a0			 
# End of file firmware_sound.asm
11a0			endif  
11a0			  
11a0			include "firmware_diags.asm"  
11a0			; Hardware diags menu 
11a0			 
11a0			 
11a0 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
11c1 .. 00		hd_menu2:   db "        2: Editor",0   
11d3			;hd_menu2:   db "        2: Editor       6: BASIC",0   
11d3 .. 00		hd_menu3:   db "        3: Storage",0 
11e6 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
11f7 .. 00		hd_don:     db "ON",0 
11fa .. 00		hd_doff:     db "OFF",0 
11fe			 
11fe			 
11fe			 
11fe			hardware_diags:       
11fe			 
11fe			.diagmenu: 
11fe cd bd 09			call clear_display 
1201 3e 00			ld a, display_row_1 
1203 11 a0 11			ld de, hd_menu1 
1206 cd d0 09			call str_at_display 
1209			 
1209 3e 28			ld a, display_row_2 
120b 11 c1 11			ld de, hd_menu2 
120e cd d0 09			call str_at_display 
1211			 
1211 3e 50			ld a, display_row_3 
1213 11 d3 11			ld de, hd_menu3 
1216 cd d0 09			call str_at_display 
1219			 
1219 3e 78			ld a,  display_row_4 
121b 11 e6 11			ld de, hd_menu4 
121e cd d0 09			call str_at_display 
1221			 
1221				; display debug state 
1221			 
1221 11 f7 11			ld de, hd_don 
1224 3a 31 ee			ld a, (os_view_disable) 
1227 fe 00			cp 0 
1229 28 03			jr z, .distog 
122b 11 fa 11			ld de, hd_doff 
122e 3e 89		.distog: ld a, display_row_4+17 
1230 cd d0 09			call str_at_display 
1233			 
1233 cd e0 09			call update_display 
1236			 
1236 cd 1b 55			call cin_wait 
1239			 
1239			 
1239			 
1239 fe 34			cp '4' 
123b 20 0f			jr nz, .diagn1 
123d			 
123d				; debug toggle 
123d			 
123d 3a 31 ee			ld a, (os_view_disable) 
1240 06 2a			ld b, '*' 
1242 fe 00			cp 0 
1244 28 02			jr z, .debtog 
1246 06 00			ld b, 0 
1248			.debtog:	 
1248 78				ld a,b 
1249 32 31 ee			ld (os_view_disable),a 
124c			 
124c fe 30		.diagn1: cp '0' 
124e c8				 ret z 
124f			 
124f			;	cp '1' 
124f			;       jp z, matrix	 
124f			;   TODO keyboard matrix test 
124f			 
124f fe 32			cp '2' 
1251 ca 58 12			jp z, .diagedit 
1254			 
1254			;if ENABLE_BASIC 
1254			;	cp '6' 
1254			;	jp z, basic 
1254			;endif 
1254			  
1254 c3 fe 11			jp .diagmenu 
1257			 
1257			 
1257 c9				ret 
1258			 
1258			; debug editor 
1258			 
1258			.diagedit: 
1258			 
1258 21 32 ee			ld hl, scratch 
125b			;	ld bc, 250 
125b			;	ldir 
125b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
125b 3e 00			ld a, 0 
125d 77				ld (hl), a 
125e 23				inc hl 
125f 77				ld (hl), a 
1260 23				inc hl 
1261 77				ld (hl), a 
1262			 
1262 cd bd 09		        call clear_display 
1265 cd e0 09			call update_display 
1268 3e 01			ld a, 1 
126a 32 7d fb			ld (hardware_diag), a 
126d			.diloop: 
126d 3e 00			ld a, display_row_1 
126f 0e 00			ld c, 0 
1271 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1273 1e 28			ld e, 40 
1275			 
1275 21 32 ee			ld hl, scratch	 
1278 cd 43 0b			call input_str 
127b			 
127b 3e 28			ld a, display_row_2 
127d 11 32 ee			ld de, scratch 
1280 cd d0 09			call str_at_display 
1283 cd e0 09			call update_display 
1286			 
1286 c3 6d 12			jp .diloop 
1289			 
1289			 
1289			; pass word in hl 
1289			; a has display location 
1289			display_word_at: 
1289 f5				push af 
128a e5				push hl 
128b 7c				ld a,h 
128c 21 37 f1			ld hl, os_word_scratch 
128f cd 17 0e			call hexout 
1292 e1				pop hl 
1293 7d				ld a,l 
1294 21 39 f1			ld hl, os_word_scratch+2 
1297 cd 17 0e			call hexout 
129a 21 3b f1			ld hl, os_word_scratch+4 
129d 3e 00			ld a,0 
129f 77				ld (hl),a 
12a0 11 37 f1			ld de,os_word_scratch 
12a3 f1				pop af 
12a4 cd d0 09				call str_at_display 
12a7 c9				ret 
12a8			 
12a8			display_ptr_state: 
12a8			 
12a8				; to restore afterwards 
12a8			 
12a8 d5				push de 
12a9 c5				push bc 
12aa e5				push hl 
12ab f5				push af 
12ac			 
12ac				; for use in here 
12ac			 
12ac			;	push bc 
12ac			;	push de 
12ac			;	push hl 
12ac			;	push af 
12ac			 
12ac cd bd 09			call clear_display 
12af			 
12af 11 82 14			ld de, .ptrstate 
12b2 3e 00			ld a, display_row_1 
12b4 cd d0 09			call str_at_display 
12b7			 
12b7				; display debug step 
12b7			 
12b7			 
12b7 11 77 fb			ld de, debug_mark 
12ba 3e 26			ld a, display_row_1+display_cols-2 
12bc cd d0 09			call str_at_display 
12bf			 
12bf				; display a 
12bf 11 8c 14			ld de, .ptrcliptr 
12c2 3e 28			ld a, display_row_2 
12c4 cd d0 09			call str_at_display 
12c7			 
12c7 f1				pop af 
12c8 2a 3d f8			ld hl,(cli_ptr) 
12cb 3e 30			ld a, display_row_2+8 
12cd cd 89 12			call display_word_at 
12d0			 
12d0			 
12d0				; display hl 
12d0			 
12d0			 
12d0 11 94 14			ld de, .ptrclioptr 
12d3 3e 32			ld a, display_row_2+10 
12d5 cd d0 09			call str_at_display 
12d8			; 
12d8			;	pop hl 
12d8 3e 35			ld a, display_row_2+13 
12da 2a 3b f8			ld hl,(cli_origptr) 
12dd cd 89 12			call display_word_at 
12e0			; 
12e0			;	 
12e0			;	; display de 
12e0			 
12e0			;	ld de, .regstatede 
12e0			;	ld a, display_row_3 
12e0			;	call str_at_display 
12e0			 
12e0			;	pop de 
12e0			;	ld h,d 
12e0			;	ld l, e 
12e0			;	ld a, display_row_3+3 
12e0			;	call display_word_at 
12e0			 
12e0			 
12e0				; display bc 
12e0			 
12e0			;	ld de, .regstatebc 
12e0			;	ld a, display_row_3+10 
12e0			;	call str_at_display 
12e0			 
12e0			;	pop bc 
12e0			;	ld h,b 
12e0			;	ld l, c 
12e0			;	ld a, display_row_3+13 
12e0			;	call display_word_at 
12e0			 
12e0			 
12e0				; display dsp 
12e0			 
12e0			;	ld de, .regstatedsp 
12e0			;	ld a, display_row_4 
12e0			;	call str_at_display 
12e0			 
12e0				 
12e0			;	ld hl,(cli_data_sp) 
12e0			;	ld a, display_row_4+4 
12e0			;	call display_word_at 
12e0			 
12e0				; display rsp 
12e0			 
12e0 11 c3 14			ld de, .regstatersp 
12e3 3e 82			ld a, display_row_4+10 
12e5 cd d0 09			call str_at_display 
12e8			 
12e8				 
12e8 2a 23 f8			ld hl,(cli_ret_sp) 
12eb 3e 86			ld a, display_row_4+14 
12ed cd 89 12			call display_word_at 
12f0			 
12f0 cd e0 09			call update_display 
12f3			 
12f3 cd 41 09			call delay1s 
12f6 cd 41 09			call delay1s 
12f9 cd 41 09			call delay1s 
12fc			 
12fc			 
12fc cd 09 18			call next_page_prompt 
12ff			 
12ff				; restore  
12ff			 
12ff f1				pop af 
1300 e1				pop hl 
1301 c1				pop bc 
1302 d1				pop de 
1303 c9				ret 
1304			 
1304			break_point_state: 
1304 f5				push af 
1305			 
1305				; see if disabled 
1305			 
1305 3a 31 ee			ld a, (os_view_disable) 
1308 fe 2a			cp '*' 
130a 20 02			jr nz, .bpsgo 
130c f1				pop af 
130d c9				ret 
130e			 
130e			.bpsgo: 
130e f1				pop af 
130f f5				push af 
1310 22 2d ee			ld (os_view_hl), hl 
1313 ed 53 2b ee		ld (os_view_de), de 
1317 ed 43 29 ee		ld (os_view_bc), bc 
131b e5				push hl 
131c 6f				ld l, a 
131d 26 00			ld h, 0 
131f 22 2f ee			ld (os_view_af),hl 
1322			 
1322 21 bd fa				ld hl, display_fb0 
1325 22 d8 f8				ld (display_fb_active), hl 
1328 e1				pop hl	 
1329			 
1329 3e 31			ld a, '1' 
132b fe 2a		.bps1:  cp '*' 
132d 20 03			jr nz, .bps1b 
132f 32 31 ee			ld (os_view_disable),a 
1332 fe 31		.bps1b:  cp '1' 
1334 20 14			jr nz, .bps2 
1336			 
1336				; display reg 
1336			 
1336				 
1336			 
1336 3a 2f ee			ld a, (os_view_af) 
1339 2a 2d ee			ld hl, (os_view_hl) 
133c ed 5b 2b ee		ld de, (os_view_de) 
1340 ed 4b 29 ee		ld bc, (os_view_bc) 
1344 cd de 13			call display_reg_state 
1347 c3 ca 13			jp .bpschk 
134a			 
134a fe 32		.bps2:  cp '2' 
134c 20 08			jr nz, .bps3 
134e				 
134e				; display hl 
134e 2a 2d ee			ld hl, (os_view_hl) 
1351 cd c8 14			call display_dump_at_hl 
1354			 
1354 18 74			jr .bpschk 
1356			 
1356 fe 33		.bps3:  cp '3' 
1358 20 08			jr nz, .bps4 
135a			 
135a			        ; display de 
135a 2a 2b ee			ld hl, (os_view_de) 
135d cd c8 14			call display_dump_at_hl 
1360			 
1360 18 68			jr .bpschk 
1362 fe 34		.bps4:  cp '4' 
1364 20 08			jr nz, .bps5 
1366			 
1366			        ; display bc 
1366 2a 29 ee			ld hl, (os_view_bc) 
1369 cd c8 14			call display_dump_at_hl 
136c			 
136c 18 5c			jr .bpschk 
136e fe 35		.bps5:  cp '5' 
1370 20 08		        jr nz, .bps7 
1372			 
1372				; display cur ptr 
1372 2a 3d f8			ld hl, (cli_ptr) 
1375 cd c8 14			call display_dump_at_hl 
1378			 
1378 18 50			jr .bpschk 
137a fe 36		.bps7:  cp '6' 
137c 20 08			jr nz, .bps8b 
137e				 
137e				; display cur orig ptr 
137e 2a 3b f8			ld hl, (cli_origptr) 
1381 cd c8 14			call display_dump_at_hl 
1384 18 44			jr .bpschk 
1386 fe 37		.bps8b:  cp '7' 
1388 20 08			jr nz, .bps9 
138a				 
138a				; display dsp 
138a 2a 1f f8			ld hl, (cli_data_sp) 
138d cd c8 14			call display_dump_at_hl 
1390			 
1390 18 38			jr .bpschk 
1392 fe 39		.bps9:  cp '9' 
1394 20 05			jr nz, .bps8c 
1396				 
1396				; display SP 
1396			;	ld hl, sp 
1396 cd c8 14			call display_dump_at_hl 
1399			 
1399 18 2f			jr .bpschk 
139b fe 38		.bps8c:  cp '8' 
139d 20 08			jr nz, .bps8d 
139f				 
139f				; display rsp 
139f 2a 23 f8			ld hl, (cli_ret_sp) 
13a2 cd c8 14			call display_dump_at_hl 
13a5			 
13a5 18 23			jr .bpschk 
13a7 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
13a9 20 05			jr nz, .bps8 
13ab cd ff 15			call monitor 
13ae			 
13ae 18 1a			jr .bpschk 
13b0 fe 30		.bps8:  cp '0' 
13b2 20 16			jr nz, .bpschk 
13b4			 
13b4 21 1c fa				ld hl, display_fb1 
13b7 22 d8 f8				ld (display_fb_active), hl 
13ba cd e0 09				call update_display 
13bd			 
13bd				;ld a, (os_view_af) 
13bd 2a 2d ee			ld hl, (os_view_hl) 
13c0 ed 5b 2b ee		ld de, (os_view_de) 
13c4 ed 4b 29 ee		ld bc, (os_view_bc) 
13c8 f1				pop af 
13c9 c9				ret 
13ca			 
13ca			.bpschk:   
13ca cd 41 09			call delay1s 
13cd 3e 9f		ld a,display_row_4 + display_cols - 1 
13cf 11 07 18		        ld de, endprg 
13d2 cd d0 09			call str_at_display 
13d5 cd e0 09			call update_display 
13d8 cd 1b 55			call cin_wait 
13db			 
13db c3 2b 13			jp .bps1 
13de			 
13de			 
13de			display_reg_state: 
13de			 
13de				; to restore afterwards 
13de			 
13de d5				push de 
13df c5				push bc 
13e0 e5				push hl 
13e1 f5				push af 
13e2			 
13e2				; for use in here 
13e2			 
13e2 c5				push bc 
13e3 d5				push de 
13e4 e5				push hl 
13e5 f5				push af 
13e6			 
13e6 cd bd 09			call clear_display 
13e9			 
13e9 11 9e 14			ld de, .regstate 
13ec 3e 00			ld a, display_row_1 
13ee cd d0 09			call str_at_display 
13f1			 
13f1				; display debug step 
13f1			 
13f1			 
13f1 11 77 fb			ld de, debug_mark 
13f4 3e 25			ld a, display_row_1+display_cols-3 
13f6 cd d0 09			call str_at_display 
13f9			 
13f9				; display a 
13f9 11 ba 14			ld de, .regstatea 
13fc 3e 28			ld a, display_row_2 
13fe cd d0 09			call str_at_display 
1401			 
1401 e1				pop hl 
1402			;	ld h,0 
1402			;	ld l, a 
1402 3e 2b			ld a, display_row_2+3 
1404 cd 89 12			call display_word_at 
1407			 
1407			 
1407				; display hl 
1407			 
1407			 
1407 11 ae 14			ld de, .regstatehl 
140a 3e 32			ld a, display_row_2+10 
140c cd d0 09			call str_at_display 
140f			 
140f e1				pop hl 
1410 3e 35			ld a, display_row_2+13 
1412 cd 89 12			call display_word_at 
1415			 
1415				 
1415				; display de 
1415			 
1415 11 b2 14			ld de, .regstatede 
1418 3e 50			ld a, display_row_3 
141a cd d0 09			call str_at_display 
141d			 
141d e1				pop hl 
141e			;	ld h,d 
141e			;	ld l, e 
141e 3e 53			ld a, display_row_3+3 
1420 cd 89 12			call display_word_at 
1423			 
1423			 
1423				; display bc 
1423			 
1423 11 b6 14			ld de, .regstatebc 
1426 3e 5a			ld a, display_row_3+10 
1428 cd d0 09			call str_at_display 
142b			 
142b e1				pop hl 
142c			;	ld h,b 
142c			;	ld l, c 
142c 3e 5d			ld a, display_row_3+13 
142e cd 89 12			call display_word_at 
1431			 
1431			 
1431				; display dsp 
1431			 
1431 11 be 14			ld de, .regstatedsp 
1434 3e 78			ld a, display_row_4 
1436 cd d0 09			call str_at_display 
1439			 
1439				 
1439 2a 1f f8			ld hl,(cli_data_sp) 
143c 3e 7c			ld a, display_row_4+4 
143e cd 89 12			call display_word_at 
1441			 
1441				; display rsp 
1441			 
1441 11 c3 14			ld de, .regstatersp 
1444 3e 82			ld a, display_row_4+10 
1446 cd d0 09			call str_at_display 
1449			 
1449				 
1449 2a 23 f8			ld hl,(cli_ret_sp) 
144c 3e 86			ld a, display_row_4+14 
144e cd 89 12			call display_word_at 
1451			 
1451 cd e0 09			call update_display 
1454			 
1454			;	call delay1s 
1454			;	call delay1s 
1454			;	call delay1s 
1454			 
1454			 
1454			;	call next_page_prompt 
1454			 
1454				; restore  
1454			 
1454 f1				pop af 
1455 e1				pop hl 
1456 c1				pop bc 
1457 d1				pop de 
1458 c9				ret 
1459			 
1459 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
146d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1482 .. 00		.ptrstate:	db "Ptr State",0 
148c .. 00		.ptrcliptr:     db "cli_ptr",0 
1494 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
149e .. 00		.regstate:	db "Reg State (1/0)",0 
14ae .. 00		.regstatehl:	db "HL:",0 
14b2 .. 00		.regstatede:	db "DE:",0 
14b6 .. 00		.regstatebc:	db "BC:",0 
14ba .. 00		.regstatea:	db "A :",0 
14be .. 00		.regstatedsp:	db "DSP:",0 
14c3 .. 00		.regstatersp:	db "RSP:",0 
14c8			 
14c8			display_dump_at_hl: 
14c8 e5				push hl 
14c9 d5				push de 
14ca c5				push bc 
14cb f5				push af 
14cc			 
14cc 22 55 f1			ld (os_cur_ptr),hl	 
14cf cd bd 09			call clear_display 
14d2 cd 11 17			call dumpcont 
14d5			;	call delay1s 
14d5			;	call next_page_prompt 
14d5			 
14d5			 
14d5 f1				pop af 
14d6 c1				pop bc 
14d7 d1				pop de 
14d8 e1				pop hl 
14d9 c9				ret 
14da			 
14da			;if ENABLE_BASIC 
14da			;	include "nascombasic.asm" 
14da			;	basic: 
14da			;	include "forth/FORTH.ASM" 
14da			;endif 
14da			 
14da			; eof 
14da			 
14da			 
# End of file firmware_diags.asm
14da			  
14da			  
14da			  
14da			  
14da			; eof  
14da			  
# End of file firmware.asm
14da			 
14da			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
14da			;if BASE_KEV  
14da			;baseram: equ 08000h 
14da			;endif 
14da			 
14da			;if BASE_SC114 
14da			;baseram:     equ    endofcode 
14da			;endif 
14da			 
14da			 
14da			; start system 
14da			 
14da			coldstart: 
14da				; set sp 
14da				; di/ei 
14da			 
14da f3				di 
14db 31 fd ff			ld sp, tos 
14de			;	ei 
14de			 
14de			 
14de				; disable breakpoint by default 
14de			 
14de 3e 2a			ld a,'*' 
14e0 32 31 ee			ld (os_view_disable),a 
14e3			 
14e3				; init hardware 
14e3			 
14e3				; init keyboard and screen hardware 
14e3			 
14e3 cd 03 00			call hardware_init 
14e6			 
14e6			 
14e6				; detect if any keys are held down to enable breakpoints at start up 
14e6			 
14e6 cd 2c 55			call cin  
14e9 fe 00			cp 0 
14eb 28 03			jr z, .nokeys 
14ed			 
14ed cd fe 11			call hardware_diags 
14f0			 
14f0			;	ld de, .bpen 
14f0			;	ld a, display_row_4 
14f0			;	call str_at_display 
14f0			;	call update_display 
14f0			; 
14f0			;	ld a,0 
14f0			;	ld (os_view_disable),a 
14f0			; 
14f0			;.bpwait: 
14f0			;	call cin 
14f0			;	cp 0 
14f0			;	jr z, .bpwait 
14f0			;	jr .nokeys 
14f0			; 
14f0			; 
14f0			;.bpen:  db "Break points enabled!",0 
14f0			 
14f0			 
14f0			 
14f0			 
14f0			 
14f0			 
14f0			.nokeys: 
14f0			 
14f0			 
14f0				 
14f0			 
14f0			;jp  testkey 
14f0			 
14f0			;call storage_get_block_0 
14f0			; 
14f0			;ld hl, 0 
14f0			;ld de, store_page 
14f0			;call storage_read_block 
14f0			 
14f0				 
14f0			;ld hl, 10 
14f0			;ld de, store_page 
14f0			;call storage_read_block 
14f0			 
14f0			 
14f0			 
14f0			 
14f0			 
14f0			;stop:	nop 
14f0			;	jp stop 
14f0			 
14f0			 
14f0			 
14f0			main: 
14f0 cd bd 09			call clear_display 
14f3 cd e0 09			call update_display 
14f6			 
14f6			 
14f6			 
14f6			;	call testlcd 
14f6			 
14f6			 
14f6			 
14f6 cd 38 1a			call forth_init 
14f9			 
14f9			 
14f9			warmstart: 
14f9 cd 0e 1a			call forth_warmstart 
14fc			 
14fc				; run startup word load 
14fc			        ; TODO prevent this running at warmstart after crash  
14fc			 
14fc				if STARTUP_ENABLE 
14fc cd f2 4e				call forth_startup 
14ff				endif 
14ff			 
14ff				; show free memory after boot 
14ff 11 99 15			ld de, freeram 
1502 3e 00			ld a, display_row_1 
1504 cd d0 09			call str_at_display 
1507			 
1507			; Or use heap_size word???? 
1507 21 26 ee			ld hl, heap_end 
150a 11 0e 80			ld de, heap_start 
150d ed 52			sbc hl, de 
150f e5				push hl 
1510 7c				ld a,h	         	 
1511 21 37 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1514 cd 17 0e			call hexout 
1517 e1			   	pop hl 
1518			 
1518 7d				ld a,l 
1519 21 39 f1			ld hl, os_word_scratch+2 
151c cd 17 0e			call hexout 
151f 21 3b f1			ld hl, os_word_scratch+4 
1522 3e 00			ld a, 0 
1524 77				ld (hl),a 
1525 11 37 f1			ld de, os_word_scratch 
1528 3e 0d			ld a, display_row_1 + 13 
152a cd d0 09			call str_at_display 
152d cd e0 09			call update_display 
1530			 
1530			 
1530				;call demo 
1530			 
1530			 
1530				; init scratch input area for cli commands 
1530			 
1530 21 59 f1			ld hl, os_cli_cmd 
1533 3e 00			ld a,0 
1535 77				ld (hl),a 
1536 23				inc hl 
1537 77				ld (hl),a 
1538			 
1538 3e 00			ld a,0 
153a 32 58 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
153d			 
153d 32 55 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1540 32 56 f1			ld (os_cur_ptr+1),a	 
1543			 
1543 32 37 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1546 32 38 f1			ld (os_word_scratch+1),a	 
1549				 
1549			 
1549				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1549 21 59 f1			ld hl, os_cli_cmd 
154c			 
154c 3e 00			ld a, 0		 ; init cli input 
154e 77				ld (hl), a 
154f 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1551			cli: 
1551				; show cli prompt 
1551				;push af 
1551				;ld a, 0 
1551				;ld de, prompt 
1551				;call str_at_display 
1551			 
1551				;call update_display 
1551				;pop af 
1551				;inc a 
1551				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1551 0e 00			ld c, 0 
1553 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1555 1e 28			ld e, 40 
1557			 
1557 21 59 f1			ld hl, os_cli_cmd 
155a			 
155a				STACKFRAME OFF $fefe $9f9f 
155a				if DEBUG_STACK_IMB 
155a					if OFF 
155a						exx 
155a						ld de, $fefe 
155a						ld a, d 
155a						ld hl, curframe 
155a						call hexout 
155a						ld a, e 
155a						ld hl, curframe+2 
155a						call hexout 
155a						ld hl, $fefe 
155a						push hl 
155a						ld hl, $9f9f 
155a						push hl 
155a						exx 
155a					endif 
155a				endif 
155a			endm 
# End of macro STACKFRAME
155a			 
155a cd 43 0b			call input_str 
155d			 
155d				STACKFRAMECHK OFF $fefe $9f9f 
155d				if DEBUG_STACK_IMB 
155d					if OFF 
155d						exx 
155d						ld hl, $9f9f 
155d						pop de   ; $9f9f 
155d						call cmp16 
155d						jr nz, .spnosame 
155d						ld hl, $fefe 
155d						pop de   ; $fefe 
155d						call cmp16 
155d						jr z, .spfrsame 
155d						.spnosame: call showsperror 
155d						.spfrsame: nop 
155d						exx 
155d					endif 
155d				endif 
155d			endm 
# End of macro STACKFRAMECHK
155d			 
155d				; copy input to last command 
155d			 
155d 21 59 f1			ld hl, os_cli_cmd 
1560 11 58 f2			ld de, os_last_cmd 
1563 01 ff 00			ld bc, 255 
1566 ed b0			ldir 
1568				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1568			;	call strcpy 
1568			;	ld a, 0 
1568			;	ld (hl), a 
1568			;	inc hl 
1568			;	ld (hl), a 
1568			;	inc hl 
1568			;	ld (hl), a 
1568			 
1568				; switch frame buffer to program  
1568			 
1568 21 1c fa				ld hl, display_fb1 
156b 22 d8 f8				ld (display_fb_active), hl 
156e			 
156e			;	nop 
156e				STACKFRAME ON $fbfe $8f9f 
156e				if DEBUG_STACK_IMB 
156e					if ON 
156e						exx 
156e						ld de, $fbfe 
156e						ld a, d 
156e						ld hl, curframe 
156e						call hexout 
156e						ld a, e 
156e						ld hl, curframe+2 
156e						call hexout 
156e						ld hl, $fbfe 
156e						push hl 
156e						ld hl, $8f9f 
156e						push hl 
156e						exx 
156e					endif 
156e				endif 
156e			endm 
# End of macro STACKFRAME
156e				; first time into the parser so pass over the current scratch pad 
156e 21 59 f1			ld hl,os_cli_cmd 
1571				; tokenise the entered statement(s) in HL 
1571 cd b1 1a			call forthparse 
1574			        ; exec forth statements in top of return stack 
1574 cd f1 1a			call forthexec 
1577				;call forthexec_cleanup 
1577			;	call parsenext 
1577			 
1577				STACKFRAMECHK ON $fbfe $8f9f 
1577				if DEBUG_STACK_IMB 
1577					if ON 
1577						exx 
1577						ld hl, $8f9f 
1577						pop de   ; $8f9f 
1577						call cmp16 
1577						jr nz, .spnosame 
1577						ld hl, $fbfe 
1577						pop de   ; $fbfe 
1577						call cmp16 
1577						jr z, .spfrsame 
1577						.spnosame: call showsperror 
1577						.spfrsame: nop 
1577						exx 
1577					endif 
1577				endif 
1577			endm 
# End of macro STACKFRAMECHK
1577				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1577			 
1577 3e 78			ld a, display_row_4 
1579 11 ab 15			ld de, endprog 
157c			 
157c cd e0 09			call update_display		 
157f			 
157f cd 09 18			call next_page_prompt 
1582			 
1582				; switch frame buffer to cli 
1582			 
1582 21 bd fa				ld hl, display_fb0 
1585 22 d8 f8				ld (display_fb_active), hl 
1588			 
1588			 
1588 cd bd 09		        call clear_display 
158b cd e0 09			call update_display		 
158e			 
158e 21 59 f1			ld hl, os_cli_cmd 
1591			 
1591 3e 00			ld a, 0		 ; init cli input 
1593 77				ld (hl), a 
1594			 
1594				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1594			 
1594				; now on last line 
1594			 
1594				; TODO scroll screen up 
1594			 
1594				; TODO instead just clear screen and place at top of screen 
1594			 
1594			;	ld a, 0 
1594			;	ld (f_cursor_ptr),a 
1594			 
1594				;call clear_display 
1594				;call update_display 
1594			 
1594				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1594 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1596 c3 51 15			jp cli 
1599			 
1599 .. 00		freeram: db "Free bytes: $",0 
15a7 ..			asc: db "1A2F" 
15ab .. 00		endprog: db "End prog...",0 
15b7			 
15b7			testenter2:   
15b7 21 64 ee			ld hl,scratch+50 
15ba 22 55 f1			ld (os_cur_ptr),hl 
15bd c3 51 15			jp cli 
15c0			 
15c0			testenter:  
15c0			 
15c0 21 a7 15			ld hl,asc 
15c3			;	ld a,(hl) 
15c3			;	call nibble2val 
15c3 cd 6d 0e			call get_byte 
15c6			 
15c6			 
15c6			;	ld a,(hl) 
15c6			;	call atohex 
15c6			 
15c6			;	call fourehexhl 
15c6 32 64 ee			ld (scratch+50),a 
15c9			 
15c9			 
15c9			 
15c9 21 a9 15			ld hl,asc+2 
15cc			;	ld a, (hl) 
15cc			;	call nibble2val 
15cc cd 6d 0e			call get_byte 
15cf			 
15cf			;	call fourehexhl 
15cf 32 66 ee			ld (scratch+52),a 
15d2				 
15d2 21 64 ee			ld hl,scratch+50 
15d5 22 55 f1			ld (os_cur_ptr),hl 
15d8 c3 51 15			jp cli 
15db			 
15db			enter:	 
15db 3a 36 ee			ld a,(scratch+4) 
15de fe 00			cp 0 
15e0 28 0c			jr z, .entercont 
15e2				; no, not a null term line so has an address to work out.... 
15e2			 
15e2 21 34 ee			ld hl,scratch+2 
15e5 cd cd 0e			call get_word_hl 
15e8			 
15e8 22 55 f1			ld (os_cur_ptr),hl	 
15eb c3 51 15			jp cli 
15ee			 
15ee			 
15ee			.entercont:  
15ee			 
15ee 21 34 ee			ld hl, scratch+2 
15f1 cd 6d 0e			call get_byte 
15f4			 
15f4 2a 55 f1		   	ld hl,(os_cur_ptr) 
15f7 77					ld (hl),a 
15f8 23					inc hl 
15f9 22 55 f1				ld (os_cur_ptr),hl 
15fc				 
15fc			; get byte  
15fc			 
15fc			 
15fc c3 51 15			jp cli 
15ff			 
15ff			 
15ff			; basic monitor support 
15ff			 
15ff			monitor: 
15ff				;  
15ff cd bd 09			call clear_display 
1602 3e 00			ld a, 0 
1604 11 4c 16			ld de, .monprompt 
1607 cd d0 09			call str_at_display 
160a cd e0 09			call update_display 
160d			 
160d				; get a monitor command 
160d			 
160d 0e 00			ld c, 0     ; entry at top left 
160f 16 64			ld d, 100   ; max buffer size 
1611 1e 0f			ld e, 15    ; input scroll area 
1613 3e 00			ld a, 0     ; init string 
1615 21 30 f0			ld hl, os_input 
1618 77				ld (hl), a 
1619 23				inc hl 
161a 77				ld (hl), a 
161b 21 30 f0			ld hl, os_input 
161e 3e 01			ld a, 1     ; init string 
1620 cd 43 0b			call input_str 
1623			 
1623 cd bd 09		        call clear_display 
1626 cd e0 09			call update_display		 
1629			 
1629 3a 30 f0			ld a, (os_input) 
162c cd 6b 0f			call toUpper 
162f fe 48		        cp 'H' 
1631 28 6f		        jr z, .monhelp 
1633 fe 44			cp 'D'		; dump 
1635 ca c3 16			jp z, .mondump	 
1638 fe 43			cp 'C'		; dump 
163a ca dd 16			jp z, .moncdump	 
163d fe 4d			cp 'M'		; dump 
163f ca 4e 16			jp z, .moneditstart 
1642 fe 55			cp 'U'		; dump 
1644 28 14			jr z, .monedit	 
1646 fe 51			cp 'Q'		; dump 
1648 c8				ret z	 
1649			 
1649			 
1649				; TODO "S" to access symbol by name and not need the address 
1649				; TODO "F" to find a string in memory 
1649			 
1649 c3 ff 15			jp monitor 
164c			 
164c .. 00		.monprompt: db ">", 0 
164e			 
164e			.moneditstart: 
164e				; get starting address 
164e			 
164e 21 32 f0			ld hl,os_input+2 
1651 cd cd 0e			call get_word_hl 
1654			 
1654 22 55 f1			ld (os_cur_ptr),hl	 
1657			 
1657 c3 ff 15			jp monitor 
165a			 
165a			.monedit: 
165a				; get byte to load 
165a			 
165a 21 32 f0			ld hl,os_input+2 
165d cd 6d 0e			call get_byte 
1660			 
1660				; get address to update 
1660 2a 55 f1			ld hl, (os_cur_ptr) 
1663			 
1663				; update byte 
1663			 
1663 77				ld (hl), a 
1664			 
1664				; move to next address and save it 
1664			 
1664 23				inc hl 
1665 22 55 f1			ld (os_cur_ptr),hl	 
1668			 
1668 c3 ff 15			jp monitor 
166b			 
166b			 
166b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
167f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
169b .. 00		.monhelptext3:  db "Q-Quit",0 
16a2			        
16a2			.monhelp: 
16a2 3e 00			ld a, display_row_1 
16a4 11 6b 16		        ld de, .monhelptext1 
16a7			 
16a7 cd d0 09			call str_at_display 
16aa 3e 28			ld a, display_row_2 
16ac 11 7f 16		        ld de, .monhelptext2 
16af					 
16af cd d0 09			call str_at_display 
16b2 3e 50			ld a, display_row_3 
16b4 11 9b 16		        ld de, .monhelptext3 
16b7					 
16b7 cd d0 09			call str_at_display 
16ba cd e0 09			call update_display		 
16bd			 
16bd cd 09 18			call next_page_prompt 
16c0 c3 ff 15			jp monitor 
16c3			 
16c3			.mondump:    
16c3 21 32 f0			ld hl,os_input+2 
16c6 cd cd 0e			call get_word_hl 
16c9			 
16c9 22 55 f1			ld (os_cur_ptr),hl	 
16cc cd 11 17			call dumpcont 
16cf 3e 78			ld a, display_row_4 
16d1 11 ab 15			ld de, endprog 
16d4			 
16d4 cd e0 09			call update_display		 
16d7			 
16d7 cd 09 18			call next_page_prompt 
16da c3 ff 15			jp monitor 
16dd			.moncdump: 
16dd cd 11 17			call dumpcont 
16e0 3e 78			ld a, display_row_4 
16e2 11 ab 15			ld de, endprog 
16e5			 
16e5 cd e0 09			call update_display		 
16e8			 
16e8 cd 09 18			call next_page_prompt 
16eb c3 ff 15			jp monitor 
16ee			 
16ee			 
16ee			; TODO symbol access  
16ee			 
16ee			.symbols:     ;; A list of symbols that can be called up  
16ee bd fa			dw display_fb0 
16f0 .. 00			db "fb0",0  
16f4 62 f8		     	dw store_page 
16f6 .. 00			db "store_page",0 
1701			 
1701			 
1701			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1701			 
1701 3a 33 ee			ld a,(scratch+1) 
1704 fe 00			cp 0 
1706 28 09			jr z, dumpcont 
1708			 
1708				; no, not a null term line so has an address to work out.... 
1708			 
1708 21 34 ee			ld hl,scratch+2 
170b cd cd 0e			call get_word_hl 
170e			 
170e 22 55 f1			ld (os_cur_ptr),hl	 
1711			 
1711			 
1711			 
1711			dumpcont: 
1711			 
1711				; dump bytes at ptr 
1711			 
1711			 
1711 3e 00			ld a, display_row_1 
1713 2a d8 f8			ld hl, (display_fb_active) 
1716 cd 16 0b			call addatohl 
1719 cd 41 17			call .dumpbyterow 
171c			 
171c 3e 28			ld a, display_row_2 
171e 2a d8 f8			ld hl, (display_fb_active) 
1721 cd 16 0b			call addatohl 
1724 cd 41 17			call .dumpbyterow 
1727			 
1727			 
1727 3e 50			ld a, display_row_3 
1729 2a d8 f8			ld hl, (display_fb_active) 
172c cd 16 0b			call addatohl 
172f cd 41 17			call .dumpbyterow 
1732			 
1732 3e 78			ld a, display_row_4 
1734 2a d8 f8			ld hl, (display_fb_active) 
1737 cd 16 0b			call addatohl 
173a cd 41 17			call .dumpbyterow 
173d			 
173d cd e0 09			call update_display 
1740			;		jp cli 
1740 c9				ret 
1741			 
1741			.dumpbyterow: 
1741			 
1741				;push af 
1741			 
1741 e5				push hl 
1742			 
1742				; calc where to poke the ascii 
1742			if display_cols == 20 
1742				ld a, 16 
1742			else 
1742 3e 1f			ld a, 31 
1744			endif 
1744			 
1744 cd 16 0b			call addatohl 
1747 22 37 f1			ld (os_word_scratch),hl  		; save pos for later 
174a			 
174a			 
174a			; display decoding address 
174a 2a 55 f1		   	ld hl,(os_cur_ptr) 
174d			 
174d 7c				ld a,h 
174e e1				pop hl 
174f e5				push hl 
1750			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1750 cd 17 0e			call hexout 
1753 2a 55 f1		   	ld hl,(os_cur_ptr) 
1756			 
1756 7d				ld a,l 
1757 e1				pop hl 
1758 23				inc hl 
1759 23				inc hl 
175a e5				push hl 
175b			;	ld hl, os_word_scratch+2 
175b cd 17 0e			call hexout 
175e e1				pop hl 
175f 23				inc hl 
1760 23				inc hl 
1761				;ld hl, os_word_scratch+4 
1761 3e 3a			ld a, ':' 
1763 77				ld (hl),a 
1764 23				inc hl 
1765				;ld a, 0 
1765				;ld (hl),a 
1765				;ld de, os_word_scratch 
1765				;pop af 
1765				;push af 
1765			;		ld a, display_row_2 
1765			;		call str_at_display 
1765			;		call update_display 
1765			 
1765			 
1765			;pop af 
1765			;	add 5 
1765			 
1765			if display_cols == 20 
1765				ld b, 4 
1765			else 
1765 06 08			ld b, 8 
1767			endif	 
1767			 
1767			.dumpbyte: 
1767 c5				push bc 
1768 e5				push hl 
1769			 
1769			 
1769 2a 55 f1		   	ld hl,(os_cur_ptr) 
176c 7e					ld a,(hl) 
176d			 
176d					; poke the ascii to display 
176d 2a 37 f1				ld hl,(os_word_scratch) 
1770 77					ld (hl),a 
1771 23					inc hl 
1772 22 37 f1				ld (os_word_scratch),hl 
1775			 
1775					 
1775			 
1775			 
1775 e1					pop hl 
1776 e5					push hl 
1777			 
1777 cd 17 0e				call hexout 
177a			 
177a					 
177a 2a 55 f1		   	ld hl,(os_cur_ptr) 
177d 23				inc hl 
177e 22 55 f1		   	ld (os_cur_ptr),hl 
1781			 
1781 e1					pop hl 
1782 23					inc hl 
1783 23					inc hl 
1784 23					inc hl 
1785			 
1785			 
1785			 
1785					;ld a,0 
1785					;ld (os_word_scratch+2),a 
1785					;pop af 
1785					;push af 
1785			 
1785					;ld de, os_word_scratch 
1785					;call str_at_display 
1785			;		call update_display 
1785			;		pop af 
1785 c1					pop bc 
1786 c6 03				add 3 
1788 10 dd			djnz .dumpbyte 
178a			 
178a				 
178a			 
178a c9				ret 
178b			 
178b			jump:	 
178b			 
178b 21 34 ee			ld hl,scratch+2 
178e cd cd 0e			call get_word_hl 
1791				;ld hl,(scratch+2) 
1791				;call fourehexhl 
1791			 
1791 22 55 f1			ld (os_cur_ptr),hl	 
1794			 
1794 e9				jp (hl) 
1795			 
1795			 
1795			 
1795			; TODO implement a basic monitor mode to start with 
1795			 
1795			 
1795			 
1795			 
1795			 
1795			 
1795			 
1795			 
1795			 
1795			; testing and demo code during development 
1795			 
1795			 
1795 .. 00		str1: db "Enter some text...",0 
17a8 .. 00		clear: db "                    ",0 
17bd			 
17bd			demo: 
17bd			 
17bd			 
17bd			 
17bd			;	call update_display 
17bd			 
17bd				; init scratch input area for testing 
17bd 21 32 ee			ld hl, scratch	 
17c0 3e 00			ld a,0 
17c2 77				ld (hl),a 
17c3			 
17c3			 
17c3 3e 28		            LD   A, display_row_2 
17c5			;            CALL fLCD_Pos       ;Position cursor to location in A 
17c5 11 95 17		            LD   DE, str1 
17c8 cd d0 09			call str_at_display 
17cb			 
17cb			;            CALL fLCD_Str       ;Display string pointed to by DE 
17cb			cloop:	 
17cb 3e 50		            LD   A, display_row_3 
17cd			;            CALL fLCD_Pos       ;Position cursor to location in A 
17cd 11 a8 17		            LD   DE, clear 
17d0			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
17d0 cd d0 09				call str_at_display 
17d3 3e 78			ld a, display_row_4 
17d5 11 05 18			ld de, prompt 
17d8			 
17d8 cd d0 09				call str_at_display 
17db cd e0 09			call update_display 
17de			 
17de 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17e0 16 0a			ld d, 10 
17e2 21 32 ee			ld hl, scratch	 
17e5 cd 43 0b			call input_str 
17e8			 
17e8			;	call clear_display 
17e8			;'	call update_display 
17e8			 
17e8 3e 00		            LD   A, display_row_1 
17ea			;            CALL fLCD_Pos       ;Position cursor to location in A 
17ea 11 a8 17		            LD   DE, clear 
17ed cd d0 09				call str_at_display 
17f0			;            CALL fLCD_Str       ;Display string pointed to by DE 
17f0 3e 00		            LD   A, display_row_1 
17f2			;            CALL fLCD_Pos       ;Position cursor to location in A 
17f2 11 32 ee		            LD   DE, scratch 
17f5			;            CALL fLCD_Str       ;Display string pointed to by DE 
17f5 cd d0 09				call str_at_display 
17f8 cd e0 09			call update_display 
17fb			 
17fb 3e 00				ld a,0 
17fd 21 32 ee			ld hl, scratch 
1800 77				ld (hl),a 
1801			 
1801 00				nop 
1802 c3 cb 17			jp cloop 
1805			 
1805			 
1805			 
1805			; OS Prompt 
1805			 
1805 .. 00		prompt: db ">",0 
1807 .. 00		endprg: db "?",0 
1809			 
1809			 
1809			; handy next page prompt 
1809			next_page_prompt: 
1809 e5				push hl 
180a d5				push de 
180b f5				push af 
180c c5				push bc 
180d			 
180d 3e 9f			ld a,display_row_4 + display_cols - 1 
180f 11 07 18		        ld de, endprg 
1812 cd d0 09			call str_at_display 
1815 cd e0 09			call update_display 
1818 cd 1b 55			call cin_wait 
181b c1				pop bc 
181c f1				pop af 
181d d1				pop de 
181e e1				pop hl 
181f			 
181f			 
181f c9				ret 
1820			 
1820			 
1820			; forth parser 
1820			 
1820			; My forth kernel 
1820			include "forth_kernel.asm" 
1820			; 
1820			; kernel to the forth OS 
1820			 
1820			DS_TYPE_STR: equ 1     ; string type 
1820			DS_TYPE_INUM: equ 2     ; $ 16 bit int usually a hex address 
1820			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1820			 
1820			FORTH_PARSEV1: equ 0 
1820			FORTH_PARSEV2: equ 0 
1820			FORTH_PARSEV3: equ 0 
1820			FORTH_PARSEV4: equ 0 
1820			FORTH_PARSEV5: equ 1 
1820			 
1820			;if FORTH_PARSEV5 
1820			;	FORTH_END_BUFFER: equ 0 
1820			;else 
1820			FORTH_END_BUFFER: equ 127 
1820			;endif 
1820			 
1820			FORTH_TRUE: equ 1 
1820			FORTH_FALSE: equ 0 
1820			 
1820			if FORTH_PARSEV4 
1820			include "forth_stackops.asm" 
1820			endif 
1820			 
1820			if FORTH_PARSEV5 
1820			include "forth_stackopsv5.asm" 
1820			 
1820			; Stack operations for v5 parser on wards 
1820			; * DATA stack 
1820			; * LOOP stack 
1820			; * RETURN stack 
1820			 
1820			 
1820			 
1820			FORTH_CHK_DSP_UNDER: macro 
1820				push hl 
1820				push de 
1820				ld hl,(cli_data_sp) 
1820				ld de, cli_data_stack 
1820				call cmp16 
1820				jp c, fault_dsp_under 
1820				pop de 
1820				pop hl 
1820				endm 
1820			 
1820			 
1820			FORTH_CHK_RSP_UNDER: macro 
1820				push hl 
1820				push de 
1820				ld hl,(cli_ret_sp) 
1820				ld de, cli_ret_stack 
1820				call cmp16 
1820				jp c, fault_rsp_under 
1820				pop de 
1820				pop hl 
1820				endm 
1820			 
1820			FORTH_CHK_LOOP_UNDER: macro 
1820				push hl 
1820				push de 
1820				ld hl,(cli_loop_sp) 
1820				ld de, cli_loop_stack 
1820				call cmp16 
1820				jp c, fault_loop_under 
1820				pop de 
1820				pop hl 
1820				endm 
1820			 
1820			FORTH_ERR_TOS_NOTSTR: macro 
1820				; TOSO might need more for checks when used 
1820				push af 
1820				ld a,(hl) 
1820				cp DS_TYPE_STR 
1820				jp nz, type_faultn   
1820				pop af 
1820				endm 
1820			 
1820			FORTH_ERR_TOS_NOTNUM: macro 
1820				push af 
1820				ld a,(hl) 
1820				cp DS_TYPE_INUM 
1820				jp nz, type_faultn   
1820				pop af 
1820				endm 
1820			 
1820			 
1820			; increase data stack pointer and save hl to it 
1820				 
1820			FORTH_DSP_NEXT: macro 
1820				call macro_forth_dsp_next 
1820				endm 
1820			 
1820			 
1820			macro_forth_dsp_next: 
1820				if DEBUG_FORTH_STACK_GUARD 
1820 cd bc 4f				call check_stacks 
1823				endif 
1823 e5				push hl 
1824 d5				push de 
1825 eb				ex de,hl 
1826 2a 1f f8			ld hl,(cli_data_sp) 
1829 23				inc hl 
182a 23				inc hl 
182b			 
182b			; PARSEV5 
182b 23				inc hl 
182c 22 1f f8			ld (cli_data_sp),hl 
182f 73				ld (hl), e 
1830 23				inc hl 
1831 72				ld (hl), d 
1832 d1				pop de 
1833 e1				pop hl 
1834				if DEBUG_FORTH_STACK_GUARD 
1834 cd bc 4f				call check_stacks 
1837				endif 
1837 c9				ret 
1838			 
1838			 
1838			; increase ret stack pointer and save hl to it 
1838				 
1838			FORTH_RSP_NEXT: macro 
1838				call macro_forth_rsp_next 
1838				endm 
1838			 
1838			macro_forth_rsp_next: 
1838				if DEBUG_FORTH_STACK_GUARD 
1838 cd bc 4f				call check_stacks 
183b				endif 
183b e5				push hl 
183c d5				push de 
183d eb				ex de,hl 
183e 2a 23 f8			ld hl,(cli_ret_sp) 
1841 23				inc hl 
1842 23				inc hl 
1843 22 23 f8			ld (cli_ret_sp),hl 
1846 73				ld (hl), e 
1847 23				inc hl 
1848 72				ld (hl), d 
1849 d1				pop de 
184a e1				pop hl 
184b				if DEBUG_FORTH_STACK_GUARD 
184b cd bc 4f				call check_stacks 
184e				endif 
184e c9				ret 
184f			 
184f			; get current ret stack pointer and save to hl  
184f				 
184f			FORTH_RSP_TOS: macro 
184f				call macro_forth_rsp_tos 
184f				endm 
184f			 
184f			macro_forth_rsp_tos: 
184f				;push de 
184f 2a 23 f8			ld hl,(cli_ret_sp) 
1852 cd 87 18			call loadhlptrtohl 
1855				;ld e, (hl) 
1855				;inc hl 
1855				;ld d, (hl) 
1855				;ex de, hl 
1855					if DEBUG_FORTH_WORDS 
1855			;			DMARK "RST" 
1855						CALLMONITOR 
1855					endif 
1855				;pop de 
1855 c9				ret 
1856			 
1856			; pop ret stack pointer 
1856				 
1856			FORTH_RSP_POP: macro 
1856				call macro_forth_rsp_pop 
1856				endm 
1856			 
1856			 
1856			macro_forth_rsp_pop: 
1856				if DEBUG_FORTH_STACK_GUARD 
1856			;		DMARK "RPP" 
1856 cd bc 4f				call check_stacks 
1859					FORTH_CHK_RSP_UNDER 
1859 e5				push hl 
185a d5				push de 
185b 2a 23 f8			ld hl,(cli_ret_sp) 
185e 11 9d f7			ld de, cli_ret_stack 
1861 cd 34 0b			call cmp16 
1864 da d0 50			jp c, fault_rsp_under 
1867 d1				pop de 
1868 e1				pop hl 
1869				endm 
# End of macro FORTH_CHK_RSP_UNDER
1869				endif 
1869 e5				push hl 
186a 2a 23 f8			ld hl,(cli_ret_sp) 
186d			 
186d			 
186d				if FORTH_ENABLE_FREE 
186d			 
186d					; get pointer 
186d			 
186d					push de 
186d					push hl 
186d			 
186d					ld e, (hl) 
186d					inc hl 
186d					ld d, (hl) 
186d			 
186d					ex de, hl 
186d					call free 
186d			 
186d					pop hl 
186d					pop de 
186d			 
186d			 
186d				endif 
186d			 
186d			 
186d 2b				dec hl 
186e 2b				dec hl 
186f 22 23 f8			ld (cli_ret_sp), hl 
1872				; do stack underflow checks 
1872 e1				pop hl 
1873				if DEBUG_FORTH_STACK_GUARD 
1873 cd bc 4f				call check_stacks 
1876					FORTH_CHK_RSP_UNDER 
1876 e5				push hl 
1877 d5				push de 
1878 2a 23 f8			ld hl,(cli_ret_sp) 
187b 11 9d f7			ld de, cli_ret_stack 
187e cd 34 0b			call cmp16 
1881 da d0 50			jp c, fault_rsp_under 
1884 d1				pop de 
1885 e1				pop hl 
1886				endm 
# End of macro FORTH_CHK_RSP_UNDER
1886				endif 
1886 c9				ret 
1887			 
1887			 
1887			 
1887			; routine to load word pointed to by hl into hl 
1887			 
1887			loadhlptrtohl: 
1887			 
1887 d5				push de 
1888 5e				ld e, (hl) 
1889 23				inc hl 
188a 56				ld d, (hl) 
188b eb				ex de, hl 
188c d1				pop de 
188d			 
188d c9				ret 
188e			 
188e			 
188e			 
188e			 
188e			 
188e			; push a number held in HL onto the data stack 
188e			; entry point for pushing a value when already in hl used in function above 
188e			 
188e			forth_push_numhl: 
188e			 
188e e5				push hl    ; save value to push 
188f			 
188f			if DEBUG_FORTH_PUSH 
188f				; see if disabled 
188f			 
188f			 
188f				push af 
188f				ld a, (os_view_disable) 
188f				cp '*' 
188f				jr z, .pskip2 
188f				push hl 
188f			push hl 
188f				call clear_display 
188f			pop hl 
188f				ld a,h 
188f				ld hl, os_word_scratch 
188f				call hexout 
188f				pop hl 
188f				ld a,l 
188f				ld hl, os_word_scratch+2 
188f				call hexout 
188f			 
188f				ld hl, os_word_scratch+4 
188f				ld a,0 
188f				ld (hl),a 
188f				ld de,os_word_scratch 
188f					ld a, display_row_2 
188f					call str_at_display 
188f				ld de, .push_num 
188f				ld a, display_row_1 
188f			 
188f					call str_at_display 
188f			 
188f			 
188f				call update_display 
188f				call delay1s 
188f				call delay1s 
188f			.pskip2:  
188f			 
188f				pop af 
188f			endif	 
188f			 
188f			 
188f				FORTH_DSP_NEXT 
188f cd 20 18			call macro_forth_dsp_next 
1892				endm 
# End of macro FORTH_DSP_NEXT
1892			 
1892 2a 1f f8			ld hl, (cli_data_sp) 
1895			 
1895				; save item type 
1895 3e 02			ld a,  DS_TYPE_INUM 
1897 77				ld (hl), a 
1898 23				inc hl 
1899			 
1899				; get word off stack 
1899 d1				pop de 
189a 7b				ld a,e 
189b 77				ld (hl), a 
189c 23				inc hl 
189d 7a				ld a,d 
189e 77				ld (hl), a 
189f			 
189f			if DEBUG_FORTH_PUSH 
189f				dec hl 
189f				dec hl 
189f				dec hl 
189f						DMARK "PH5" 
189f				CALLMONITOR 
189f			endif	 
189f			 
189f c9				ret 
18a0			 
18a0			 
18a0			; Push a string to stack pointed to by hl 
18a0			 
18a0			forth_push_str: 
18a0			 
18a0			if DEBUG_FORTH_PUSH 
18a0						DMARK "PSQ" 
18a0				CALLMONITOR 
18a0			endif	 
18a0			    
18a0 e5				push hl 
18a1 e5				push hl 
18a2			 
18a2 3e 00			ld a, 0   ; find end of string 
18a4 cd 7f 0f			call strlent       
18a7			if DEBUG_FORTH_PUSH 
18a7						DMARK "PQ2" 
18a7				CALLMONITOR 
18a7			endif	 
18a7 eb				ex de, hl 
18a8 e1				pop hl   ; get ptr to start of string 
18a9			if DEBUG_FORTH_PUSH 
18a9						DMARK "PQ3" 
18a9				CALLMONITOR 
18a9			endif	 
18a9 19				add hl,de 
18aa			if DEBUG_FORTH_PUSH 
18aa						DMARK "PQE" 
18aa				CALLMONITOR 
18aa			endif	 
18aa			 
18aa 2b				dec hl    ; see if there is an optional trailing double quote 
18ab 7e				ld a,(hl) 
18ac fe 22			cp '"' 
18ae 20 03			jr nz, .strnoq 
18b0 3e 00			ld a, 0      ; get rid of double quote 
18b2 77				ld (hl), a 
18b3 23			.strnoq: inc hl 
18b4			 
18b4 3e 00			ld a, 0 
18b6 77				ld (hl), a     ; add null term and get rid of trailing double quote 
18b7			 
18b7 13				inc de ; add one for the type string 
18b8 13				inc de ; add one for null term??? 
18b9			 
18b9				; tos is get string pointer again 
18b9				; de contains space to allocate 
18b9				 
18b9 d5				push de 
18ba			 
18ba eb				ex de, hl 
18bb			 
18bb				;push af 
18bb			 
18bb			if DEBUG_FORTH_PUSH 
18bb						DMARK "PHm" 
18bb				CALLMONITOR 
18bb			endif	 
18bb cd dd 0f			call malloc	; on ret hl now contains allocated memory 
18be				if DEBUG_FORTH_MALLOC_GUARD 
18be cc 8d 3f				call z,malloc_error 
18c1				endif 
18c1			 
18c1				 
18c1 c1				pop bc    ; get length 
18c2 d1				pop de   ;  get string start    
18c3			 
18c3				; hl has destination from malloc 
18c3			 
18c3 eb				ex de, hl    ; prep for ldir 
18c4			 
18c4 e5				push hl   ; save malloc area for DSP later 
18c5			 
18c5			if DEBUG_FORTH_PUSH 
18c5						DMARK "PHc" 
18c5				CALLMONITOR 
18c5			endif	 
18c5			 
18c5			 
18c5 ed b0			ldir 
18c7			 
18c7			 
18c7				; push malloc to data stack     macro?????  
18c7			 
18c7				FORTH_DSP_NEXT 
18c7 cd 20 18			call macro_forth_dsp_next 
18ca				endm 
# End of macro FORTH_DSP_NEXT
18ca			 
18ca				; save value and type 
18ca			 
18ca 2a 1f f8			ld hl, (cli_data_sp) 
18cd			 
18cd				; save item type 
18cd 3e 01			ld a,  DS_TYPE_STR 
18cf 77				ld (hl), a 
18d0 23				inc hl 
18d1			 
18d1				; get malloc word off stack 
18d1 d1				pop de 
18d2 73				ld (hl), e 
18d3 23				inc hl 
18d4 72				ld (hl), d 
18d5			 
18d5			 
18d5			 
18d5			if DEBUG_FORTH_PUSH 
18d5				ld hl, (cli_data_sp) 
18d5						DMARK "PHS" 
18d5				CALLMONITOR 
18d5			;	ex de,hl 
18d5			endif	 
18d5				; in case of spaces, skip the ptr past the copied string 
18d5				;pop af 
18d5				;ld (cli_origptr),hl 
18d5			 
18d5 c9				ret 
18d6			 
18d6			 
18d6			 
18d6			; TODO ascii push input onto stack given hl to start of input 
18d6			 
18d6			; identify type 
18d6			; if starts with a " then a string 
18d6			; otherwise it is a number 
18d6			;  
18d6			; if a string 
18d6			;     scan for ending " to get length of string to malloc for + 1 
18d6			;     malloc 
18d6			;     put pointer to string on stack first byte flags as string 
18d6			; 
18d6			; else a number 
18d6			;    look for number format identifier 
18d6			;    $xx hex 
18d6			;    %xxxxx bin 
18d6			;    xxxxx decimal 
18d6			;    convert number to 16bit word.  
18d6			;    malloc word + 1 with flag to identiy as num 
18d6			;    put pointer to number on stack 
18d6			;   
18d6			;  
18d6			  
18d6			forth_apush: 
18d6				; kernel push 
18d6			 
18d6			if DEBUG_FORTH_PUSH 
18d6						DMARK "PSH" 
18d6				CALLMONITOR 
18d6			endif	 
18d6				; identify input type 
18d6			 
18d6 7e				ld a,(hl) 
18d7 fe 22			cp '"' 
18d9 28 0a			jr z, .fapstr 
18db fe 24			cp '$' 
18dd ca 05 19			jp z, .faphex 
18e0 fe 25			cp '%' 
18e2 ca ed 18			jp z, .fapbin 
18e5			;	cp 'b' 
18e5			;	jp z, .fabin 
18e5				; else decimal 
18e5			 
18e5				; TODO do decimal conversion 
18e5				; decimal is stored as a 16bit word 
18e5			 
18e5				; by default everything is a string if type is not detected 
18e5			.fapstr: ; 
18e5 fe 22			cp '"' 
18e7 20 01			jr nz, .strnoqu 
18e9 23				inc hl 
18ea			.strnoqu: 
18ea c3 a0 18			jp forth_push_str 
18ed			 
18ed			 
18ed			 
18ed			.fapbin:    ; push a binary string.  
18ed 11 00 00			ld de, 0   ; hold a 16bit value 
18f0			 
18f0 23			.fapbinshift:	inc hl  
18f1 7e				ld a,(hl) 
18f2 fe 00			cp 0     ; done scanning  
18f4 28 0b			jr z, .fapbdone  	; got it in HL so push  
18f6			 
18f6				; left shift de 
18f6 eb				ex de, hl	 
18f7 29				add hl, hl 
18f8			 
18f8				; is 1 
18f8 fe 31			cp '1' 
18fa 20 02			jr nz, .binzero 
18fc cb 4d			bit 1, l 
18fe			.binzero: 
18fe eb				ex de, hl	 ; save current de 
18ff 18 ef			jr .fapbinshift 
1901			 
1901			.fapbdone: 
1901 eb				ex de, hl 
1902 c3 8e 18			jp forth_push_numhl 
1905			 
1905			 
1905			.faphex:   ; hex is always stored as a 16bit word 
1905				; skip number prefix 
1905 23				inc hl 
1906				; turn ascii into number 
1906 cd cd 0e			call get_word_hl	; ret 16bit word in hl 
1909			 
1909 c3 8e 18			jp forth_push_numhl 
190c			 
190c 00				 nop 
190d			 
190d			.fabin:   ; TODO bin conversion 
190d			 
190d			 
190d c9				ret 
190e			 
190e			 
190e			; get either a string ptr or a 16bit word from the data stack 
190e			 
190e			FORTH_DSP: macro 
190e				call macro_forth_dsp 
190e				endm 
190e			 
190e			macro_forth_dsp: 
190e				; data stack pointer points to current word on tos 
190e			 
190e 2a 1f f8			ld hl,(cli_data_sp) 
1911			 
1911				if DEBUG_FORTH_PUSH 
1911						DMARK "DSP" 
1911			 
1911					call display_data_sp 
1911				;call break_point_state 
1911				;rst 030h 
1911				CALLMONITOR 
1911				endif 
1911			 
1911 c9				ret 
1912			 
1912			; return hl to start of value on stack 
1912			 
1912			FORTH_DSP_VALUE: macro 
1912				call macro_forth_dsp_value 
1912				endm 
1912			 
1912			macro_forth_dsp_value: 
1912			 
1912				FORTH_DSP 
1912 cd 0e 19			call macro_forth_dsp 
1915				endm 
# End of macro FORTH_DSP
1915			 
1915 d5				push de 
1916			 
1916 23				inc hl ; skip type 
1917			 
1917 5e				ld e, (hl) 
1918 23				inc hl 
1919 56				ld d, (hl) 
191a eb				ex de,hl  
191b			 
191b d1				pop de 
191c			 
191c c9				ret 
191d			 
191d			; return hl to start of value to second item on stack 
191d			 
191d			FORTH_DSP_VALUEM1: macro 
191d				call macro_forth_dsp_value_m1 
191d				endm 
191d			 
191d			macro_forth_dsp_value_m1: 
191d			 
191d				FORTH_DSP 
191d cd 0e 19			call macro_forth_dsp 
1920				endm 
# End of macro FORTH_DSP
1920			 
1920 2b				dec hl 
1921 2b				dec hl 
1922			;	dec hl 
1922			 
1922 d5				push de 
1923			 
1923 5e				ld e, (hl) 
1924 23				inc hl 
1925 56				ld d, (hl) 
1926 eb				ex de,hl  
1927			 
1927 d1				pop de 
1928			 
1928 c9				ret 
1929			 
1929				 
1929			 
1929			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1929			 
1929			FORTH_DSP_POP: macro 
1929				call macro_forth_dsp_pop 
1929				endm 
1929			 
1929			 
1929			; get the tos data type 
1929			 
1929			FORTH_DSP_TYPE:   macro 
1929			 
1929				;FORTH_DSP_VALUE 
1929				FORTH_DSP 
1929				 
1929				; hl points to value 
1929				; check type 
1929			 
1929				ld a,(hl) 
1929			 
1929				endm 
1929			 
1929			; load the tos value into hl 
1929			 
1929			 
1929			FORTH_DSP_VALUEHL:  macro 
1929				call macro_dsp_valuehl 
1929				endm 
1929			 
1929			 
1929			 
1929			macro_dsp_valuehl: 
1929				FORTH_DSP_VALUE 
1929 cd 12 19			call macro_forth_dsp_value 
192c				endm 
# End of macro FORTH_DSP_VALUE
192c			 
192c				;FORTH_ERR_TOS_NOTNUM 
192c			 
192c				;inc hl   ; skip type id 
192c			 
192c			;	push de 
192c			; 
192c			;	ld e, (hl) 
192c			;	inc hl 
192c			;	ld d, (hl) 
192c			;	ex de,hl  
192c			 
192c			;	pop de 
192c			 
192c				if DEBUG_FORTH_PUSH 
192c						DMARK "DVL" 
192c				CALLMONITOR 
192c				endif 
192c c9				ret 
192d			 
192d			forth_apushstrhl:      
192d				; push of string requires use of cli_origptr 
192d				; bodge use 
192d			 
192d				; get current cli_origptr, save, update with temp pointer  
192d ed 5b 3b f8		ld de, (cli_origptr) 
1931 22 3b f8			ld (cli_origptr), hl 
1934 d5				push de 
1935 cd d6 18			call forth_apush 
1938 d1				pop de 
1939 ed 53 3b f8		ld (cli_origptr), de 
193d c9			        ret	 
193e			 
193e			 
193e			; increase loop stack pointer and save hl to it 
193e				 
193e			FORTH_LOOP_NEXT: macro 
193e				call macro_forth_loop_next 
193e				;nop 
193e				endm 
193e			 
193e			macro_forth_loop_next: 
193e				if DEBUG_FORTH_STACK_GUARD 
193e cd bc 4f				call check_stacks 
1941				endif 
1941 e5				push hl 
1942 d5				push de 
1943 eb				ex de,hl 
1944 2a 21 f8			ld hl,(cli_loop_sp) 
1947 23				inc hl 
1948 23				inc hl 
1949					if DEBUG_FORTH_WORDS 
1949						DMARK "LNX" 
1949						CALLMONITOR 
1949					endif 
1949 22 21 f8			ld (cli_loop_sp),hl 
194c 73				ld (hl), e 
194d 23				inc hl 
194e 72				ld (hl), d 
194f d1				pop de    ; been reversed so save a swap on restore 
1950 e1				pop hl 
1951				if DEBUG_FORTH_STACK_GUARD 
1951 cd bc 4f				call check_stacks 
1954				endif 
1954 c9				ret 
1955			 
1955			; get current ret stack pointer and save to hl  
1955				 
1955			FORTH_LOOP_TOS: macro 
1955				call macro_forth_loop_tos 
1955				endm 
1955			 
1955			macro_forth_loop_tos: 
1955 d5				push de 
1956 2a 21 f8			ld hl,(cli_loop_sp) 
1959 5e				ld e, (hl) 
195a 23				inc hl 
195b 56				ld d, (hl) 
195c eb				ex de, hl 
195d d1				pop de 
195e c9				ret 
195f			 
195f			; pop loop stack pointer 
195f				 
195f			FORTH_LOOP_POP: macro 
195f				call macro_forth_loop_pop 
195f				endm 
195f			 
195f			 
195f			macro_forth_loop_pop: 
195f				if DEBUG_FORTH_STACK_GUARD 
195f					DMARK "LPP" 
195f f5				push af  
1960 3a 74 19			ld a, (.dmark)  
1963 32 77 fb			ld (debug_mark),a  
1966 3a 75 19			ld a, (.dmark+1)  
1969 32 78 fb			ld (debug_mark+1),a  
196c 3a 76 19			ld a, (.dmark+2)  
196f 32 79 fb			ld (debug_mark+2),a  
1972 18 03			jr .pastdmark  
1974 ..			.dmark: db "LPP"  
1977 f1			.pastdmark: pop af  
1978			endm  
# End of macro DMARK
1978 cd bc 4f				call check_stacks 
197b					FORTH_CHK_LOOP_UNDER 
197b e5				push hl 
197c d5				push de 
197d 2a 21 f8			ld hl,(cli_loop_sp) 
1980 11 9b f5			ld de, cli_loop_stack 
1983 cd 34 0b			call cmp16 
1986 da d6 50			jp c, fault_loop_under 
1989 d1				pop de 
198a e1				pop hl 
198b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
198b				endif 
198b e5				push hl 
198c 2a 21 f8			ld hl,(cli_loop_sp) 
198f 2b				dec hl 
1990 2b				dec hl 
1991 22 21 f8			ld (cli_loop_sp), hl 
1994				; TODO do stack underflow checks 
1994 e1				pop hl 
1995				if DEBUG_FORTH_STACK_GUARD 
1995 cd bc 4f				call check_stacks 
1998					FORTH_CHK_LOOP_UNDER 
1998 e5				push hl 
1999 d5				push de 
199a 2a 21 f8			ld hl,(cli_loop_sp) 
199d 11 9b f5			ld de, cli_loop_stack 
19a0 cd 34 0b			call cmp16 
19a3 da d6 50			jp c, fault_loop_under 
19a6 d1				pop de 
19a7 e1				pop hl 
19a8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
19a8				endif 
19a8 c9				ret 
19a9			 
19a9			macro_forth_dsp_pop: 
19a9			 
19a9 e5				push hl 
19aa			 
19aa				; release malloc data 
19aa			 
19aa				if DEBUG_FORTH_STACK_GUARD 
19aa cd bc 4f				call check_stacks 
19ad					FORTH_CHK_DSP_UNDER 
19ad e5				push hl 
19ae d5				push de 
19af 2a 1f f8			ld hl,(cli_data_sp) 
19b2 11 99 f3			ld de, cli_data_stack 
19b5 cd 34 0b			call cmp16 
19b8 da ca 50			jp c, fault_dsp_under 
19bb d1				pop de 
19bc e1				pop hl 
19bd				endm 
# End of macro FORTH_CHK_DSP_UNDER
19bd				endif 
19bd				;ld hl,(cli_data_sp) 
19bd			if DEBUG_FORTH_DOT 
19bd				DMARK "DPP" 
19bd				CALLMONITOR 
19bd			endif	 
19bd			 
19bd			 
19bd			if FORTH_ENABLE_DSPPOPFREE 
19bd			 
19bd				FORTH_DSP 
19bd cd 0e 19			call macro_forth_dsp 
19c0				endm 
# End of macro FORTH_DSP
19c0			 
19c0 7e				ld a, (hl) 
19c1 fe 01			cp DS_TYPE_STR 
19c3 20 07			jr nz, .skippopfree 
19c5			 
19c5				FORTH_DSP_VALUEHL 
19c5 cd 29 19			call macro_dsp_valuehl 
19c8				endm 
# End of macro FORTH_DSP_VALUEHL
19c8 00				nop 
19c9			if DEBUG_FORTH_DOT 
19c9				DMARK "DPf" 
19c9				CALLMONITOR 
19c9			endif	 
19c9 cd a7 10			call free 
19cc			.skippopfree: 
19cc				 
19cc			 
19cc			endif 
19cc			 
19cc			if DEBUG_FORTH_DOT_KEY 
19cc				DMARK "DP2" 
19cc				CALLMONITOR 
19cc			endif	 
19cc			 
19cc				; move pointer down 
19cc			 
19cc 2a 1f f8			ld hl,(cli_data_sp) 
19cf 2b				dec hl 
19d0 2b				dec hl 
19d1			; PARSEV5 
19d1 2b				dec hl 
19d2 22 1f f8			ld (cli_data_sp), hl 
19d5			 
19d5				if DEBUG_FORTH_STACK_GUARD 
19d5 cd bc 4f				call check_stacks 
19d8					FORTH_CHK_DSP_UNDER 
19d8 e5				push hl 
19d9 d5				push de 
19da 2a 1f f8			ld hl,(cli_data_sp) 
19dd 11 99 f3			ld de, cli_data_stack 
19e0 cd 34 0b			call cmp16 
19e3 da ca 50			jp c, fault_dsp_under 
19e6 d1				pop de 
19e7 e1				pop hl 
19e8				endm 
# End of macro FORTH_CHK_DSP_UNDER
19e8				endif 
19e8			 
19e8 e1				pop hl 
19e9			 
19e9 c9				ret 
19ea			 
19ea			getwordathl: 
19ea				; hl points to an address 
19ea				; load hl with the word at that address 
19ea			 
19ea d5				push de 
19eb			 
19eb 5e				ld e, (hl) 
19ec 23				inc hl 
19ed 56				ld d, (hl) 
19ee eb				ex de, hl 
19ef			 
19ef d1				pop de 
19f0 c9				ret 
19f1			 
19f1			 
19f1			 
19f1			 
19f1			 
19f1			; eof 
19f1			 
# End of file forth_stackopsv5.asm
19f1			endif 
19f1			 
19f1			user_word_eol:  
19f1				; hl contains the pointer to where to create a linked list item from the end 
19f1				; of the user dict to continue on at the system word dict 
19f1				 
19f1				; poke the stub of the word list linked list to repoint to rom words 
19f1			 
19f1				; stub format 
19f1				; db   word id 
19f1				; dw    link to next word 
19f1			        ; db char length of token 
19f1				; db string + 0 term 
19f1				; db exec code....  
19f1			 
19f1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
19f3 77				ld (hl), a		; word id 
19f4 23				inc hl 
19f5			 
19f5 11 bb 1b			ld de, sysdict 
19f8 73				ld (hl), e		; next word link ie system dict 
19f9 23				inc hl 
19fa 72				ld (hl), d		; next word link ie system dict 
19fb 23				inc hl	 
19fc			 
19fc			;	ld (hl), sysdict		; next word link ie system dict 
19fc			;	inc hl 
19fc			;	inc hl 
19fc			 
19fc			;	inc hl 
19fc			;	inc hl 
19fc			 
19fc 3e 02			ld a, 2			; word length is 0 
19fe 77				ld (hl), a	 
19ff 23				inc hl 
1a00			 
1a00 3e 7e			ld a, '~'			; word length is 0 
1a02 77				ld (hl), a	 
1a03 23				inc hl 
1a04 3e 00			ld a, 0			; save empty word 
1a06 77				ld (hl), a 
1a07			 
1a07 c9				ret 
1a08			 
1a08				 
1a08			 
1a08			forthexec_cleanup: 
1a08				FORTH_RSP_POP 
1a08 cd 56 18			call macro_forth_rsp_pop 
1a0b				endm 
# End of macro FORTH_RSP_POP
1a0b c9				ret 
1a0c			 
1a0c			forth_call_hl: 
1a0c				; taking hl 
1a0c e5				push hl 
1a0d c9				ret 
1a0e			 
1a0e			; this is called to reset Forth system but keep existing uwords etc 
1a0e			 
1a0e			forth_warmstart: 
1a0e				; setup stack over/under flow checks 
1a0e				if DEBUG_FORTH_STACK_GUARD 
1a0e cd a2 4f				call chk_stk_init 
1a11				endif 
1a11			 
1a11				; init stack pointers  - * these stacks go upwards *  
1a11 21 9d f7			ld hl, cli_ret_stack 
1a14 22 23 f8			ld (cli_ret_sp), hl	 
1a17				; set bottom of stack 
1a17 3e 00			ld a,0 
1a19 77				ld (hl),a 
1a1a 23				inc hl 
1a1b 77				ld (hl),a 
1a1c			 
1a1c 21 99 f3			ld hl, cli_data_stack 
1a1f 22 1f f8			ld (cli_data_sp), hl	 
1a22				; set bottom of stack 
1a22 3e 00			ld a,0 
1a24 77				ld (hl),a 
1a25 23				inc hl 
1a26 77				ld (hl),a 
1a27			 
1a27 21 9b f5			ld hl, cli_loop_stack 
1a2a 22 21 f8			ld (cli_loop_sp), hl	 
1a2d				; set bottom of stack 
1a2d 3e 00			ld a,0 
1a2f 77				ld (hl),a 
1a30 23				inc hl 
1a31 77				ld (hl),a 
1a32			 
1a32				; init extent of current open file 
1a32			 
1a32 3e 00			ld a, 0 
1a34 32 59 f8			ld (store_openext), a 
1a37			 
1a37 c9				ret 
1a38			 
1a38			 
1a38			; Cold Start - this is called to setup the whole Forth system 
1a38			 
1a38			forth_init: 
1a38			 
1a38				; setup stack over/under flow checks 
1a38			 
1a38			;	if DEBUG_FORTH_STACK_GUARD 
1a38			;		call chk_stk_init 
1a38			;	endif 
1a38			 
1a38				; enable auto display updates (slow.....) 
1a38			 
1a38 3e 01			ld a, 1 
1a3a 32 39 f8			ld (cli_autodisplay), a 
1a3d			 
1a3d			 
1a3d			 
1a3d				; show start up screen 
1a3d			 
1a3d cd bd 09			call clear_display 
1a40			 
1a40 3e 00			ld a,0 
1a42 32 5b f8			ld (f_cursor_ptr), a 
1a45			 
1a45				; set start of word list in start of ram - for use when creating user words 
1a45			 
1a45 21 00 80			ld hl, baseram 
1a48 22 2f f1			ld (os_last_new_uword), hl 
1a4b cd f1 19			call user_word_eol 
1a4e				 
1a4e			;		call display_data_sp 
1a4e			;		call next_page_prompt 
1a4e			 
1a4e			 
1a4e			 
1a4e			 
1a4e c9				ret 
1a4f			 
1a4f .. 00		.bootforth: db " Forth Kernel Init ",0 
1a63			 
1a63			; TODO push to stack 
1a63			 
1a63			;  
1a63			 
1a63			if FORTH_PARSEV2 
1a63			 
1a63			 
1a63				include "forth_parserv2.asm" 
1a63			 
1a63			endif 
1a63			 
1a63			 
1a63			; parse cli version 1 
1a63			 
1a63			if FORTH_PARSEV1 
1a63			 
1a63			 
1a63			 
1a63			      include "forth_parserv1.asm" 
1a63			endif 
1a63				 
1a63			if FORTH_PARSEV3 
1a63			 
1a63			 
1a63			 
1a63			      include "forth_parserv3.asm" 
1a63				include "forth_wordsv3.asm" 
1a63			endif 
1a63			 
1a63			if FORTH_PARSEV4 
1a63			 
1a63			 
1a63			 
1a63			      include "forth_parserv4.asm" 
1a63				include "forth_wordsv4.asm" 
1a63			endif 
1a63			 
1a63			if FORTH_PARSEV5 
1a63			 
1a63			 
1a63			 
1a63			      include "forth_parserv5.asm" 
1a63			 
1a63			 
1a63			; A better parser without using malloc and string copies all over the place.  
1a63			; Exec in situ should be faster 
1a63			 
1a63			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1a63			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1a63			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1a63			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1a63			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1a63			WORD_SYS_END: equ 0   ; Opcode for all user words 
1a63			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1a63			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1a63			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1a63			 
1a63			; Core word preamble macro 
1a63			 
1a63			CWHEAD:   macro nxtword opcode lit len opflags 
1a63				db WORD_SYS_CORE+opcode             
1a63				; internal op code number 
1a63				dw nxtword            
1a63				; link to next dict word block 
1a63				db len + 1 
1a63				; literal length of dict word inc zero term 
1a63				db lit,0              
1a63				; literal dict word 
1a63			        ; TODO db opflags        
1a63				endm 
1a63			 
1a63			 
1a63			NEXTW: macro  
1a63				jp macro_next 
1a63				endm 
1a63			 
1a63			macro_next: 
1a63			if DEBUG_FORTH_PARSE_KEY 
1a63				DMARK "NXT" 
1a63				CALLMONITOR 
1a63			endif	 
1a63			;	inc hl  ; skip token null term  
1a63 ed 4b 3d f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1a67 ed 5b 3b f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1a6b 2a 33 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1a6e			if DEBUG_FORTH_PARSE_KEY 
1a6e				DMARK "}AA" 
1a6e				CALLMONITOR 
1a6e			endif	 
1a6e c3 71 1b			jp execnext 
1a71				;jp exec1 
1a71			       
1a71			 
1a71			 
1a71			; Another go at the parser to compile  
1a71			 
1a71			 
1a71			; TODO rework parser to change all of the string words to byte tokens 
1a71			; TODO do a search for  
1a71			 
1a71			; TODO first run normal parser to zero term sections 
1a71			; TODO for each word do a token look up to get the op code 
1a71			; TODO need some means to flag to the exec that this is a byte code form    
1a71			 
1a71			 
1a71			forthcompile: 
1a71			 
1a71			; 
1a71			; line parse: 
1a71			;       parse raw input buffer 
1a71			;       tokenise the words 
1a71			;       malloc new copy (for looping etc) 
1a71			;       copy to malloc + current pc in line to start of string and add line term 
1a71			;       save on new rsp 
1a71			; 
1a71			 
1a71			; hl to point to the line to tokenise 
1a71			 
1a71			;	push hl 
1a71 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1a74			 
1a74			;	ld a,0		; string term on input 
1a74			;	call strlent 
1a74			 
1a74			;	ld (os_tok_len), hl	 ; save string length 
1a74			 
1a74			;if DEBUG_FORTH_TOK 
1a74			;	ex de,hl		 
1a74			;endif 
1a74			 
1a74			;	pop hl 		; get back string pointer 
1a74			 
1a74			if DEBUG_FORTH_TOK 
1a74						DMARK "TOc" 
1a74				CALLMONITOR 
1a74			endif 
1a74 7e			.cptoken2:    ld a,(hl) 
1a75 23				inc hl 
1a76 fe 7f			cp FORTH_END_BUFFER 
1a78 28 29			jr z, .cptokendone2 
1a7a fe 00			cp 0 
1a7c 28 25			jr z, .cptokendone2 
1a7e fe 22			cp '"' 
1a80 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1a82 fe 20			cp ' ' 
1a84 20 ee			jr nz,  .cptoken2 
1a86			 
1a86			; TODO consume comments held between ( and ) 
1a86			 
1a86				; we have a space so change to zero term for dict match later 
1a86 2b				dec hl 
1a87 3e 00			ld a,0 
1a89 77				ld (hl), a 
1a8a 23				inc hl 
1a8b 18 e7			jr .cptoken2 
1a8d				 
1a8d			 
1a8d			.cptokenstr2: 
1a8d				; skip all white space until either eol (because forgot to term) or end double quote 
1a8d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a8d				;inc hl ; skip current double quote 
1a8d 7e				ld a,(hl) 
1a8e 23				inc hl 
1a8f fe 22			cp '"' 
1a91 28 e1			jr z, .cptoken2 
1a93 fe 7f			cp FORTH_END_BUFFER 
1a95 28 0c			jr z, .cptokendone2 
1a97 fe 00			cp 0 
1a99 28 08			jr z, .cptokendone2 
1a9b fe 20			cp ' ' 
1a9d 28 02			jr z, .cptmp2 
1a9f 18 ec			jr .cptokenstr2 
1aa1			 
1aa1			.cptmp2:	; we have a space so change to zero term for dict match later 
1aa1				;dec hl 
1aa1				;ld a,"-"	; TODO remove this when working 
1aa1				;ld (hl), a 
1aa1				;inc hl 
1aa1 18 ea			jr .cptokenstr2 
1aa3			 
1aa3			.cptokendone2: 
1aa3				;inc hl 
1aa3 3e 7f			ld a, FORTH_END_BUFFER 
1aa5 77				ld (hl),a 
1aa6 23				inc hl 
1aa7 3e 21			ld a, '!' 
1aa9 77				ld (hl),a 
1aaa			 
1aaa 2a 33 f1			ld hl,(os_tok_ptr) 
1aad			         
1aad			if DEBUG_FORTH_TOK 
1aad						DMARK "Tc1" 
1aad				CALLMONITOR 
1aad			endif 
1aad			 
1aad				; push exec string to top of return stack 
1aad				FORTH_RSP_NEXT 
1aad cd 38 18			call macro_forth_rsp_next 
1ab0				endm 
# End of macro FORTH_RSP_NEXT
1ab0 c9				ret 
1ab1			 
1ab1			; Another go at the parser need to simplify the process 
1ab1			 
1ab1			forthparse: 
1ab1			 
1ab1			; 
1ab1			; line parse: 
1ab1			;       parse raw input buffer 
1ab1			;       tokenise the words 
1ab1			;       malloc new copy (for looping etc) 
1ab1			;       copy to malloc + current pc in line to start of string and add line term 
1ab1			;       save on new rsp 
1ab1			; 
1ab1			 
1ab1			; hl to point to the line to tokenise 
1ab1			 
1ab1			;	push hl 
1ab1 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1ab4			 
1ab4			;	ld a,0		; string term on input 
1ab4			;	call strlent 
1ab4			 
1ab4			;	ld (os_tok_len), hl	 ; save string length 
1ab4			 
1ab4			;if DEBUG_FORTH_TOK 
1ab4			;	ex de,hl		 
1ab4			;endif 
1ab4			 
1ab4			;	pop hl 		; get back string pointer 
1ab4			 
1ab4			if DEBUG_FORTH_TOK 
1ab4						DMARK "TOK" 
1ab4				CALLMONITOR 
1ab4			endif 
1ab4 7e			.ptoken2:    ld a,(hl) 
1ab5 23				inc hl 
1ab6 fe 7f			cp FORTH_END_BUFFER 
1ab8 28 29			jr z, .ptokendone2 
1aba fe 00			cp 0 
1abc 28 25			jr z, .ptokendone2 
1abe fe 22			cp '"' 
1ac0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1ac2 fe 20			cp ' ' 
1ac4 20 ee			jr nz,  .ptoken2 
1ac6			 
1ac6			; TODO consume comments held between ( and ) 
1ac6			 
1ac6				; we have a space so change to zero term for dict match later 
1ac6 2b				dec hl 
1ac7 3e 00			ld a,0 
1ac9 77				ld (hl), a 
1aca 23				inc hl 
1acb 18 e7			jr .ptoken2 
1acd				 
1acd			 
1acd			.ptokenstr2: 
1acd				; skip all white space until either eol (because forgot to term) or end double quote 
1acd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1acd				;inc hl ; skip current double quote 
1acd 7e				ld a,(hl) 
1ace 23				inc hl 
1acf fe 22			cp '"' 
1ad1 28 e1			jr z, .ptoken2 
1ad3 fe 7f			cp FORTH_END_BUFFER 
1ad5 28 0c			jr z, .ptokendone2 
1ad7 fe 00			cp 0 
1ad9 28 08			jr z, .ptokendone2 
1adb fe 20			cp ' ' 
1add 28 02			jr z, .ptmp2 
1adf 18 ec			jr .ptokenstr2 
1ae1			 
1ae1			.ptmp2:	; we have a space so change to zero term for dict match later 
1ae1				;dec hl 
1ae1				;ld a,"-"	; TODO remove this when working 
1ae1				;ld (hl), a 
1ae1				;inc hl 
1ae1 18 ea			jr .ptokenstr2 
1ae3			 
1ae3			.ptokendone2: 
1ae3				;inc hl 
1ae3 3e 7f			ld a, FORTH_END_BUFFER 
1ae5 77				ld (hl),a 
1ae6 23				inc hl 
1ae7 3e 21			ld a, '!' 
1ae9 77				ld (hl),a 
1aea			 
1aea 2a 33 f1			ld hl,(os_tok_ptr) 
1aed			         
1aed			if DEBUG_FORTH_TOK 
1aed						DMARK "TK1" 
1aed				CALLMONITOR 
1aed			endif 
1aed			 
1aed				; push exec string to top of return stack 
1aed				FORTH_RSP_NEXT 
1aed cd 38 18			call macro_forth_rsp_next 
1af0				endm 
# End of macro FORTH_RSP_NEXT
1af0 c9				ret 
1af1			 
1af1			; 
1af1			;	; malloc size + buffer pointer + if is loop flag 
1af1			;	ld hl,(os_tok_len) 		 ; get string length 
1af1			; 
1af1			;	ld a,l 
1af1			; 
1af1			;	cp 0			; we dont want to use a null string 
1af1			;	ret z 
1af1			; 
1af1			;;	add 3    ; prefix malloc with buffer for current word ptr 
1af1			; 
1af1			;	add 5     ; TODO when certain not over writing memory remove 
1af1			; 
1af1			;		 
1af1			; 
1af1			;if DEBUG_FORTH_TOK 
1af1			;			DMARK "TKE" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			; 
1af1			;	ld l,a 
1af1			;	ld h,0 
1af1			;;	push hl   ; save required space for the copy later 
1af1			;	call malloc 
1af1			;if DEBUG_FORTH_TOK 
1af1			;			DMARK "TKM" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			;	if DEBUG_FORTH_MALLOC_GUARD 
1af1			;		push af 
1af1			;		call ishlzero 
1af1			;;		ld a, l 
1af1			;;		add h 
1af1			;;		cp 0 
1af1			;		pop af 
1af1			;		 
1af1			;		call z,malloc_error 
1af1			;	endif 
1af1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1af1			; 
1af1			; 
1af1			;if DEBUG_FORTH_TOK 
1af1			;			DMARK "TKR" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			; 
1af1			;	FORTH_RSP_NEXT 
1af1			; 
1af1			;	;inc hl	 ; go past current buffer pointer 
1af1			;	;inc hl 
1af1			;	;inc hl   ; and past if loop flag 
1af1			;		; TODO Need to set flag  
1af1			; 
1af1			;	 
1af1			;	 
1af1			;	ex de,hl	; malloc is dest 
1af1			;	ld hl, (os_tok_len) 
1af1			;;	pop bc 
1af1			;	ld c, l                
1af1			;	ld b,0 
1af1			;	ld hl, (os_tok_ptr) 
1af1			; 
1af1			;if DEBUG_FORTH_TOK 
1af1			;			DMARK "TKT" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			; 
1af1			;	; do str cpy 
1af1			; 
1af1			;	ldir      ; copy byte in hl to de 
1af1			; 
1af1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1af1			; 
1af1			;if DEBUG_FORTH_TOK 
1af1			; 
1af1			;			DMARK "TKY" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			;	;ld a,0 
1af1			;	;ld a,FORTH_END_BUFFER 
1af1			;	ex de, hl 
1af1			;	;dec hl			 ; go back over the space delim at the end of word 
1af1			;	;ld (hl),a 
1af1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1af1			;	ld a,FORTH_END_BUFFER 
1af1			;	ld (hl),a 
1af1			;	inc hl 
1af1			;	ld a,FORTH_END_BUFFER 
1af1			;	ld (hl),a 
1af1			; 
1af1			;	; init the malloc area data 
1af1			;	; set pc for in current area 
1af1			;	;ld hl, (os_tok_malloc) 
1af1			;	;inc hl 
1af1			;	;inc hl 
1af1			;	;inc hl 
1af1			;	;ex de,hl 
1af1			;	;ld hl, (os_tok_malloc) 
1af1			;	;ld (hl),e 
1af1			;	;inc hl 
1af1			;	;ld (hl),d 
1af1			; 
1af1			; 
1af1			;	ld hl,(os_tok_malloc) 
1af1			;if DEBUG_FORTH_PARSE_KEY 
1af1			;			DMARK "TKU" 
1af1			;	CALLMONITOR 
1af1			;endif 
1af1			; 
1af1			;	ret 
1af1			 
1af1			forthexec: 
1af1			 
1af1			; line exec: 
1af1			; forth parser 
1af1			 
1af1			; 
1af1			;       get current exec line on rsp 
1af1			 
1af1				FORTH_RSP_TOS 
1af1 cd 4f 18			call macro_forth_rsp_tos 
1af4				endm 
# End of macro FORTH_RSP_TOS
1af4			 
1af4			;       restore current pc - hl points to malloc of data 
1af4			 
1af4				;ld e, (hl) 
1af4				;inc hl 
1af4				;ld d, (hl) 
1af4				;ex de,hl 
1af4			 
1af4			 
1af4			exec1: 
1af4 22 33 f1			ld (os_tok_ptr), hl 
1af7			 
1af7				; copy our PC to working vars  
1af7 22 3d f8			ld (cli_ptr), hl 
1afa 22 3b f8			ld (cli_origptr), hl 
1afd			 
1afd 7e				ld a,(hl) 
1afe fe 7f			cp FORTH_END_BUFFER 
1b00 c8				ret z 
1b01			 
1b01				; skip any nulls 
1b01			 
1b01 fe 00			cp 0 
1b03 20 03			jr nz, .execword 
1b05 23				inc hl 
1b06 18 ec			jr exec1 
1b08			 
1b08			 
1b08			.execword: 
1b08			 
1b08			 
1b08			 
1b08			if DEBUG_FORTH_PARSE_KEY 
1b08						DMARK "KYQ" 
1b08				CALLMONITOR 
1b08			endif 
1b08			;       while at start of word: 
1b08			; get start of dict (in user area first) 
1b08			 
1b08 21 00 80		ld hl, baseram 
1b0b			;ld hl, sysdict 
1b0b 22 3f f8		ld (cli_nextword),hl 
1b0e			;           match word at pc 
1b0e			;           exec word 
1b0e			;           or push to dsp 
1b0e			;           forward to next token 
1b0e			;           if line term pop rsp and exit 
1b0e			;        
1b0e			 
1b0e			if DEBUG_FORTH_PARSE_KEY 
1b0e						DMARK "KYq" 
1b0e				CALLMONITOR 
1b0e			endif 
1b0e			 
1b0e			; 
1b0e			; word comp 
1b0e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1b0e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1b0e			;    move to start of word  
1b0e			;    compare word to cli_token 
1b0e			 
1b0e			.execpnword:	; HL at start of a word in the dictionary to check 
1b0e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1b0e			;	ld (cli_ptr), hl 
1b0e			 
1b0e 2a 3f f8			ld hl,(cli_nextword) 
1b11			 
1b11 cd b4 1b			call forth_tok_next 
1b14			; tok next start here 
1b14			;	; TODO skip compiled symbol for now 
1b14			;	inc hl 
1b14			; 
1b14			;	; save pointer to next word 
1b14			; 
1b14			;	; hl now points to the address of the next word pointer  
1b14			;	ld e, (hl) 
1b14			;	inc hl 
1b14			;	ld d, (hl) 
1b14			;	inc l 
1b14			; 
1b14			;	ex de,hl 
1b14			;if DEBUG_FORTH_PARSE_NEXTWORD 
1b14			;	push bc 
1b14			;	ld bc, (cli_nextword) 
1b14			;			DMARK "NXW" 
1b14			;	CALLMONITOR 
1b14			;	pop bc 
1b14			;endif 
1b14			; tok next end here 
1b14 22 3f f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1b17 eb				ex de, hl 
1b18			 
1b18			 
1b18				; save the pointer of the current token - 1 to check against 
1b18				 
1b18 22 43 f8			ld (cli_token), hl   
1b1b				; TODO maybe remove below save if no debug 
1b1b				; save token string ptr for any debug later 
1b1b 23				inc hl  
1b1c 22 45 f8			ld (cli_origtoken), hl 
1b1f 2b				dec hl 
1b20				; save pointer to the start of the next dictionay word 
1b20 7e				ld a,(hl)   ; get string length 
1b21 47				ld b,a 
1b22			.execpnwordinc:  
1b22 23				inc hl 
1b23 10 fd			djnz .execpnwordinc 
1b25 22 41 f8			ld (cli_execword), hl      ; save start of this words code 
1b28			 
1b28				; now check the word token against the string being parsed 
1b28			 
1b28 2a 43 f8			ld hl,(cli_token) 
1b2b 23				inc hl     ; skip string length (use zero term instead to end) 
1b2c 22 43 f8			ld (cli_token), hl 
1b2f			 
1b2f			if DEBUG_FORTH_PARSE_KEY 
1b2f						DMARK "KY2" 
1b2f			endif 
1b2f			if DEBUG_FORTH_PARSE_EXEC 
1b2f				; see if disabled 
1b2f			 
1b2f				ld a, (os_view_disable) 
1b2f				cp '*' 
1b2f				jr z, .skip 
1b2f			 
1b2f				push hl 
1b2f				push hl 
1b2f				call clear_display 
1b2f				ld de, .compword 
1b2f				ld a, display_row_1 
1b2f				call str_at_display 
1b2f				pop de 
1b2f				ld a, display_row_2 
1b2f				call str_at_display 
1b2f				ld hl,(cli_ptr) 
1b2f				ld a,(hl) 
1b2f			        ld hl, os_word_scratch 
1b2f				ld (hl),a 
1b2f				ld a,0 
1b2f				inc hl 
1b2f				ld (hl),a 	 
1b2f				ld de, os_word_scratch 
1b2f				ld a, display_row_2+10 
1b2f				call str_at_display 
1b2f				call update_display 
1b2f				ld a, 100 
1b2f				call aDelayInMS 
1b2f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b2f				call delay250ms 
1b2f				endif 
1b2f				pop hl 
1b2f			.skip:  
1b2f			endif	 
1b2f			.execpnchar:    ; compare char between token and string to parse 
1b2f			 
1b2f			if DEBUG_FORTH_PARSE_KEY 
1b2f						DMARK "Ky3" 
1b2f			endif 
1b2f			if DEBUG_FORTH_PARSE_EXEC 
1b2f				; see if disabled 
1b2f			 
1b2f				ld a, (os_view_disable) 
1b2f				cp '*' 
1b2f				jr z, .skip2 
1b2f			 
1b2f			;	call clear_display 
1b2f			ld hl,(cli_token) 
1b2f			ld a,(hl) 
1b2f			ld (os_word_scratch),a 
1b2f				ld hl,(cli_ptr) 
1b2f			ld a,(hl) 
1b2f				ld (os_word_scratch+1),a 
1b2f				ld a,0 
1b2f				ld (os_word_scratch+2),a 
1b2f				ld de,os_word_scratch 
1b2f				ld a,display_row_4 
1b2f				call str_at_display 
1b2f				call update_display 
1b2f			.skip2:  
1b2f			endif 
1b2f 2a 43 f8			ld hl,(cli_token) 
1b32 7e				ld a, (hl)	 ; char in word token 
1b33 23				inc hl 		; move to next char 
1b34 22 43 f8			ld (cli_token), hl ; and save it 
1b37 47				ld b,a 
1b38			 
1b38 2a 3d f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1b3b 7e				ld a,(hl) 
1b3c 23				inc hl 
1b3d 22 3d f8			ld (cli_ptr), hl		; move to next char 
1b40 cd 6b 0f			call toUpper 		; make sure the input string matches case 
1b43			 
1b43			if DEBUG_FORTH_PARSE 
1b43			endif 
1b43			 
1b43				; input stream end of token is a space so get rid of it 
1b43			 
1b43			;	cp ' ' 
1b43			;	jr nz, .pnskipspace 
1b43			; 
1b43			;	ld a, 0		; make same term as word token term 
1b43			; 
1b43			;.pnskipspace: 
1b43			 
1b43			if DEBUG_FORTH_PARSE_KEY 
1b43						DMARK "KY7" 
1b43			endif 
1b43 b8				cp b 
1b44 c2 5a 1b			jp nz, .execpnskipword	 ; no match so move to next word 
1b47				 
1b47			;    if same 
1b47			;       scan for string terms 0 for token and 32 for input 
1b47			 
1b47				 
1b47			if DEBUG_FORTH_PARSE_KEY 
1b47						DMARK "KY8" 
1b47			endif 
1b47			 
1b47 80				add b			 
1b48 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1b4a							; TODO need to make sure last word in zero term string is accounted for 
1b4a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1b4c			 
1b4c			 
1b4c				; at end of both strings so both are exact match 
1b4c			 
1b4c			;       skip ptr for next word 
1b4c			 
1b4c 2a 3d f8			ld hl,(cli_ptr) 	; at input string term 
1b4f 23				inc hl			 ; at next char 
1b50 22 3d f8			ld (cli_ptr), hl     ; save for next round of the parser 
1b53 22 3b f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1b56				 
1b56				 
1b56			if DEBUG_FORTH_PARSE_KEY 
1b56						DMARK "KY3" 
1b56			endif 
1b56			 
1b56			 
1b56			 
1b56			;       exec code block 
1b56			if DEBUG_FORTH_JP 
1b56				call clear_display 
1b56				call update_display 
1b56				call delay1s 
1b56				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b56				ld a,h 
1b56				ld hl, os_word_scratch 
1b56				call hexout 
1b56				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b56				ld a,l 
1b56				ld hl, os_word_scratch+2 
1b56				call hexout 
1b56				ld hl, os_word_scratch+4 
1b56				ld a,0 
1b56				ld (hl),a 
1b56				ld de,os_word_scratch 
1b56				call str_at_display 
1b56					ld a, display_row_2 
1b56					call str_at_display 
1b56				ld de, (cli_origtoken) 
1b56				ld a, display_row_1+10 
1b56					call str_at_display 
1b56			 
1b56				ld a,display_row_1 
1b56				ld de, .foundword 
1b56				ld a, display_row_3 
1b56				call str_at_display 
1b56				call update_display 
1b56				call delay1s 
1b56				call delay1s 
1b56				call delay1s 
1b56			endif 
1b56			 
1b56			if DEBUG_FORTH_PARSE_KEY 
1b56						DMARK "KYj" 
1b56			endif 
1b56				; TODO save the word pointer in this exec 
1b56			 
1b56 2a 41 f8			ld hl,(cli_execword) 
1b59 e9				jp (hl) 
1b5a			 
1b5a			 
1b5a			;    if not same 
1b5a			;	scan for zero term 
1b5a			;	get ptr for next word 
1b5a			;	goto word comp 
1b5a			 
1b5a			.execpnskipword:	; get pointer to next word 
1b5a 2a 3f f8			ld hl,(cli_nextword) 
1b5d			 
1b5d 7e				ld a,(hl) 
1b5e fe 00			cp WORD_SYS_END 
1b60			;	cp 0 
1b60 28 09			jr z, .execendofdict			 ; at end of words 
1b62			 
1b62			if DEBUG_FORTH_PARSE_KEY 
1b62						DMARK "KY4" 
1b62			endif 
1b62			if DEBUG_FORTH_PARSE_EXEC 
1b62			 
1b62				; see if disabled 
1b62			 
1b62				ld a, (os_view_disable) 
1b62				cp '*' 
1b62				jr z, .noskip 
1b62			 
1b62			 
1b62				ld de, .nowordfound 
1b62				ld a, display_row_3 
1b62				call str_at_display 
1b62				call update_display 
1b62				ld a, 100 
1b62				call aDelayInMS 
1b62				 
1b62				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b62					call delay250ms 
1b62				endif 
1b62			.noskip:  
1b62			 
1b62			endif	 
1b62			 
1b62 2a 3b f8			ld hl,(cli_origptr) 
1b65 22 3d f8			ld (cli_ptr),hl 
1b68			 
1b68			if DEBUG_FORTH_PARSE_KEY 
1b68						DMARK "KY5" 
1b68			endif 
1b68 c3 0e 1b			jp .execpnword			; else go to next word 
1b6b			 
1b6b			.execendofdict:  
1b6b			 
1b6b			if DEBUG_FORTH_PARSE_KEY 
1b6b						DMARK "KYe" 
1b6b			endif 
1b6b			if DEBUG_FORTH_PARSE_EXEC 
1b6b				; see if disabled 
1b6b			 
1b6b				ld a, (os_view_disable) 
1b6b				cp '*' 
1b6b				jr z, .ispskip 
1b6b			 
1b6b				call clear_display 
1b6b				call update_display 
1b6b				call delay1s 
1b6b				ld de, (cli_origptr) 
1b6b				ld a, display_row_1 
1b6b				call str_at_display 
1b6b				 
1b6b				ld de, .enddict 
1b6b				ld a, display_row_3 
1b6b				call str_at_display 
1b6b				call update_display 
1b6b				ld a, 100 
1b6b				call aDelayInMS 
1b6b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b6b				call delay1s 
1b6b				call delay1s 
1b6b				call delay1s 
1b6b				endif 
1b6b			.ispskip:  
1b6b				 
1b6b			endif	 
1b6b			 
1b6b			 
1b6b			 
1b6b				; if the word is not a keyword then must be a literal so push it to stack 
1b6b			 
1b6b			; push token to stack to end of word 
1b6b			 
1b6b				STACKFRAME ON $1efe $2f9f 
1b6b				if DEBUG_STACK_IMB 
1b6b					if ON 
1b6b						exx 
1b6b						ld de, $1efe 
1b6b						ld a, d 
1b6b						ld hl, curframe 
1b6b						call hexout 
1b6b						ld a, e 
1b6b						ld hl, curframe+2 
1b6b						call hexout 
1b6b						ld hl, $1efe 
1b6b						push hl 
1b6b						ld hl, $2f9f 
1b6b						push hl 
1b6b						exx 
1b6b					endif 
1b6b				endif 
1b6b			endm 
# End of macro STACKFRAME
1b6b			 
1b6b 2a 33 f1		ld hl,(os_tok_ptr) 
1b6e cd d6 18		call forth_apush 
1b71			 
1b71				STACKFRAMECHK ON $1efe $2f9f 
1b71				if DEBUG_STACK_IMB 
1b71					if ON 
1b71						exx 
1b71						ld hl, $2f9f 
1b71						pop de   ; $2f9f 
1b71						call cmp16 
1b71						jr nz, .spnosame 
1b71						ld hl, $1efe 
1b71						pop de   ; $1efe 
1b71						call cmp16 
1b71						jr z, .spfrsame 
1b71						.spnosame: call showsperror 
1b71						.spfrsame: nop 
1b71						exx 
1b71					endif 
1b71				endif 
1b71			endm 
# End of macro STACKFRAMECHK
1b71			 
1b71			execnext: 
1b71			 
1b71			if DEBUG_FORTH_PARSE_KEY 
1b71						DMARK "KY>" 
1b71			endif 
1b71			; move past token to next word 
1b71			 
1b71 2a 33 f1		ld hl, (os_tok_ptr) 
1b74 3e 00		ld a, 0 
1b76 01 ff 00		ld bc, 255     ; input buffer size 
1b79 ed b1		cpir 
1b7b			 
1b7b			if DEBUG_FORTH_PARSE_KEY 
1b7b						DMARK "KY!" 
1b7b				CALLMONITOR 
1b7b			endif	 
1b7b			; TODO this might place hl on the null, so will need to forward on??? 
1b7b			;inc hl   ; see if this gets onto the next item 
1b7b			 
1b7b			 
1b7b			; TODO pass a pointer to the buffer to push 
1b7b			; TODO call function to push 
1b7b			 
1b7b			; look for end of input 
1b7b			 
1b7b			;inc hl 
1b7b			;ld a,(hl) 
1b7b			;cp FORTH_END_BUFFER 
1b7b			;ret z 
1b7b			 
1b7b			 
1b7b c3 f4 1a		jp exec1 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			 
1b7e			findnexttok: 
1b7e			 
1b7e				; hl is pointer to move 
1b7e				; de is the token to locate 
1b7e			 
1b7e					if DEBUG_FORTH 
1b7e						DMARK "NTK" 
1b7e						CALLMONITOR 
1b7e					endif 
1b7e d5				push de 
1b7f			 
1b7f			.fnt1:	 
1b7f				; find first char of token to locate 
1b7f			 
1b7f 1a				ld a, (de) 
1b80 4f				ld c,a 
1b81 7e				ld a,(hl) 
1b82 cd 6b 0f			call toUpper 
1b85					if DEBUG_FORTH 
1b85						DMARK "NT1" 
1b85						CALLMONITOR 
1b85					endif 
1b85 b9				cp c 
1b86			 
1b86 28 03			jr z, .fnt2cmpmorefirst	 
1b88			 
1b88				; first char not found move to next char 
1b88			 
1b88 23				inc hl 
1b89 18 f4			jr .fnt1 
1b8b			 
1b8b			.fnt2cmpmorefirst:	 
1b8b				; first char of token found.  
1b8b			 
1b8b e5				push hl     ; save start of token just in case it is the right one 
1b8c d9				exx 
1b8d e1				pop hl        ; save it to hl' 
1b8e d9				exx 
1b8f			 
1b8f			 
1b8f			.fnt2cmpmore:	 
1b8f				; compare the rest 
1b8f				 
1b8f 23				inc hl 
1b90 13				inc de 
1b91				 
1b91 1a				ld a, (de) 
1b92 4f				ld c,a 
1b93 7e				ld a,(hl) 
1b94 cd 6b 0f			call toUpper 
1b97			 
1b97					if DEBUG_FORTH 
1b97						DMARK "NT2" 
1b97						CALLMONITOR 
1b97					endif 
1b97				; c has the token to find char 
1b97				; a has the mem to scan char 
1b97			 
1b97 b9				cp c 
1b98 28 04			jr z,.fntmatch1 
1b9a			 
1b9a				; they are not the same 
1b9a			 
1b9a					if DEBUG_FORTH 
1b9a						DMARK "NT3" 
1b9a						CALLMONITOR 
1b9a					endif 
1b9a d1				pop de	; reset de token to look for 
1b9b d5				push de 
1b9c 18 e1			jr .fnt1 
1b9e				 
1b9e			.fntmatch1: 
1b9e			 
1b9e				; is the same char a null which means we might have a full hit? 
1b9e					if DEBUG_FORTH 
1b9e						DMARK "NT4" 
1b9e						CALLMONITOR 
1b9e					endif 
1b9e			 
1b9e fe 00			cp 0 
1ba0 28 0b			jr z, .fntmatchyes 
1ba2			 
1ba2				; are we at the end of the token to find? 
1ba2			 
1ba2					if DEBUG_FORTH 
1ba2						DMARK "NT5" 
1ba2						CALLMONITOR 
1ba2					endif 
1ba2 3e 00			ld a, 0 
1ba4 b9				cp c 
1ba5			 
1ba5 c2 8f 1b			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1ba8			 
1ba8					if DEBUG_FORTH 
1ba8						DMARK "NT6" 
1ba8						CALLMONITOR 
1ba8					endif 
1ba8				; token to find is exhusted but no match to stream 
1ba8			 
1ba8				; restore tok pointer and continue on 
1ba8 d1				pop de 
1ba9 d5				push de 
1baa c3 7f 1b			jp .fnt1 
1bad			 
1bad			 
1bad			.fntmatchyes: 
1bad			 
1bad				; hl now contains the end of the found token 
1bad			 
1bad				; get rid of saved token pointer to find 
1bad			 
1bad d1				pop de 
1bae			 
1bae					if DEBUG_FORTH 
1bae						DMARK "NT9" 
1bae						CALLMONITOR 
1bae					endif 
1bae			 
1bae				; hl will be on the null term so forward on 
1bae			 
1bae				; get back the saved start of the token 
1bae			 
1bae d9				exx 
1baf e5				push hl     ; save start of token just in case it is the right one 
1bb0 d9				exx 
1bb1 e1				pop hl        ; save it to hl 
1bb2			 
1bb2 c9				ret 
1bb3			 
1bb3			 
1bb3			; LIST needs to find a specific token   
1bb3			; FORGET needs to find a spefici token 
1bb3			 
1bb3			; SAVE needs to find all tokens by flag 
1bb3			; WORDS just needs to scan through all  by flag 
1bb3			; UWORDS needs to scan through all by flag 
1bb3			 
1bb3			 
1bb3			; given hl as pointer to start of dict look up string 
1bb3			; return hl as pointer to start of word block 
1bb3			; or 0 if not found 
1bb3			 
1bb3			forth_find_tok: 
1bb3 c9				ret 
1bb4			 
1bb4			; given hl as pointer to dict structure 
1bb4			; move to the next dict block structure 
1bb4			 
1bb4			forth_tok_next: 
1bb4				; hl now points to the address of the next word pointer  
1bb4				; TODO skip compiled symbol for now 
1bb4			;	push de 
1bb4 23				inc hl 
1bb5 5e				ld e, (hl) 
1bb6 23				inc hl 
1bb7 56				ld d, (hl) 
1bb8 23				inc hl 
1bb9			 
1bb9 eb				ex de,hl 
1bba			if DEBUG_FORTH_PARSE_NEXTWORD 
1bba				push bc 
1bba				ld bc, (cli_nextword) 
1bba						DMARK "NXW" 
1bba				CALLMONITOR 
1bba				pop bc 
1bba			endif 
1bba			;	pop de	 
1bba c9				ret 
1bbb			 
1bbb			 
1bbb			 
1bbb			; eof 
# End of file forth_parserv5.asm
1bbb				include "forth_wordsv4.asm" 
1bbb			 
1bbb			; the core word dictionary v4 
1bbb			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1bbb			 
1bbb			; this is a linked list for each of the system words used 
1bbb			; user defined words will follow the same format but will be in ram 
1bbb			 
1bbb			 
1bbb			; 
1bbb			; 
1bbb			; define linked list: 
1bbb			; 
1bbb			; 1. compiled byte op code 
1bbb			; 2. len of text word 
1bbb			; 3. text word 
1bbb			; 4. ptr to next dictionary word 
1bbb			; 5. asm, calls etc for the word 
1bbb			; 
1bbb			;  if 1 == 0 then last word in dict  
1bbb			;   
1bbb			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1bbb			;  
1bbb			;  
1bbb			; create basic standard set of words 
1bbb			; 
1bbb			;  
1bbb			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1bbb			; 2DUP 2DROP 2SWAP  
1bbb			; @ C@ - get byte  
1bbb			; ! C! - store byte 
1bbb			; 0< true if less than zero 
1bbb			; 0= true if zero 
1bbb			; < >  
1bbb			; = true if same 
1bbb			; variables 
1bbb			 
1bbb			 
1bbb			; Hardware specific words I may need 
1bbb			; 
1bbb			; IN OUT  
1bbb			; calls to key util functions 
1bbb			; calls to hardward abstraction stuff 
1bbb			; easy control of frame buffers and lcd i/o 
1bbb			; keyboard  
1bbb			 
1bbb			 
1bbb			;DICT: macro 
1bbb			; op_code, len, word, next 
1bbb			;    word: 
1bbb			;    db op_code 
1bbb			;    ds word zero term 
1bbb			;    dw next 
1bbb			;    endm 
1bbb			 
1bbb			 
1bbb			 
1bbb			 
1bbb			; op code 1 is a flag for user define words which are to be handled differently 
1bbb			 
1bbb			 
1bbb			; 
1bbb			; 
1bbb			;    TODO on entry to a word this should be the expected environment 
1bbb			;    hl - tos value if number then held, if string this is the ptr 
1bbb			;    de -  
1bbb			 
1bbb			 
1bbb			; opcode ranges 
1bbb			; 0 - end of word dict 
1bbb			; 255 - user define words 
1bbb			 
1bbb			sysdict: 
1bbb			include "forth_opcodes.asm" 
1bbb			; op codes for forth keywords 
1bbb			; free to use code 0  
1bbb				OPCODE_HEAP: equ  1 
1bbb				OPCODE_EXEC: equ 2 
1bbb				OPCODE_DUP: equ 3 
1bbb				OPCODE_SWAP: equ 4 
1bbb				OPCODE_COLN: equ 5 
1bbb				OPCODE_SCOLN: equ 6 
1bbb				OPCODE_DROP: equ 7 
1bbb				OPCODE_DUP2: equ 8 
1bbb				OPCODE_DROP2: equ 9 
1bbb				OPCODE_SWAP2: equ 10 
1bbb				OPCODE_AT: equ 11 
1bbb				OPCODE_CAT: equ 12 
1bbb				OPCODE_BANG: equ 13 
1bbb				OPCODE_CBANG: equ 14 
1bbb				OPCODE_SCALL: equ 15 
1bbb				OPCODE_DEPTH: equ 16 
1bbb				OPCODE_OVER: equ 17 
1bbb				OPCODE_PAUSE: equ 18 
1bbb				OPCODE_PAUSES: equ 19 
1bbb				OPCODE_ROT: equ 20 
1bbb			;free to reuse	OPCODE_WORDS: equ 21 
1bbb			        OPCODE_NOT: equ 21 
1bbb				OPCODE_UWORDS: equ 22 
1bbb				OPCODE_BP: equ 23 
1bbb				OPCODE_MONITOR: equ 24  
1bbb				OPCODE_MALLOC: equ 25 
1bbb				OPCODE_FREE: equ 26 
1bbb				OPCODE_LIST: equ 27 
1bbb				OPCODE_FORGET: equ 28 
1bbb				OPCODE_NOP: equ 29 
1bbb				OPCODE_COMO: equ 30 
1bbb				OPCODE_COMC: equ 31 
1bbb			;free to reuse	OPCODE_ENDCORE: equ 32 
1bbb				OPCODE_AFTERSOUND: equ 33 
1bbb				OPCODE_GP2: equ 34 
1bbb				OPCODE_GP3: equ 35 
1bbb				OPCODE_GP4: equ 36 
1bbb				OPCODE_SIN: equ 37 
1bbb				OPCODE_SOUT: equ 38 
1bbb				OPCODE_SPIO: equ 39 
1bbb				OPCODE_SPICEH: equ 40 
1bbb				OPCODE_SPIOb: equ 41 
1bbb				OPCODE_SPII: equ 42 
1bbb				OPCODE_SESEL: equ 43 
1bbb				OPCODE_CARTDEV: equ 44 
1bbb			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1bbb				OPCODE_FB: equ 46 
1bbb				OPCODE_EMIT: equ 47 
1bbb				OPCODE_DOTH: equ 48 
1bbb				OPCODE_DOTF: equ 49 
1bbb				OPCODE_DOT: equ 50 
1bbb				OPCODE_CLS: equ 51 
1bbb				OPCODE_DRAW: equ 52 
1bbb				OPCODE_DUMP: equ 53 
1bbb				OPCODE_CDUMP: equ 54 
1bbb				OPCODE_DAT: equ 55 
1bbb				OPCODE_HOME: equ 56 
1bbb				OPCODE_SPACE: equ 57 
1bbb				OPCODE_SPACES: equ 58 
1bbb				OPCODE_SCROLL: equ 59 
1bbb				OPCODE_ATQ: equ 60 
1bbb				OPCODE_AUTODSP: equ 61 
1bbb				OPCODE_MENU: equ 62 
1bbb			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1bbb				OPCODE_THEN: equ 64 
1bbb				OPCODE_ELSE: equ 65 
1bbb				OPCODE_DO: equ 66 
1bbb				OPCODE_LOOP: equ 67 
1bbb				OPCODE_I: equ 68 
1bbb				OPCODE_DLOOP: equ 69  
1bbb				OPCODE_REPEAT: equ 70  
1bbb				OPCODE_UNTIL: equ 71 
1bbb				OPCODE_ENDFLOW: equ 72 
1bbb				OPCODE_WAITK: equ 73 
1bbb				OPCODE_ACCEPT: equ 74 
1bbb				OPCODE_EDIT: equ 75 
1bbb			;free to reuse	OPCODE_ENDKEY: equ 76 
1bbb				OPCODE_LZERO: equ 77 
1bbb				OPCODE_TZERO: equ 78 
1bbb				OPCODE_LESS: equ 79 
1bbb				OPCODE_GT: equ 80 
1bbb				OPCODE_EQUAL: equ 81  
1bbb			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1bbb				OPCODE_NEG: equ 83 
1bbb				OPCODE_DIV: equ 84 
1bbb				OPCODE_MUL: equ 85 
1bbb				OPCODE_MIN: equ 86 
1bbb				OPCODE_MAX: equ 87 
1bbb				OPCODE_RND16: equ 88 
1bbb				OPCODE_RND8: equ 89 
1bbb				OPCODE_RND: equ 90 
1bbb			;free to reuse	OPCODE_ENDMATHS: equ 91  
1bbb				OPCODE_BYNAME: equ 92 
1bbb				OPCODE_DIR: equ 93 
1bbb				OPCODE_SAVE: equ 94 
1bbb				OPCODE_LOAD: equ 95 
1bbb				OPCODE_BSAVE: equ 96 
1bbb				OPCODE_BLOAD: equ 97 
1bbb				OPCODE_SEO: equ 98  
1bbb				OPCODE_SEI: equ 99 
1bbb				OPCODE_SFREE: equ 100 
1bbb				OPCODE_SIZE: equ 101 
1bbb				OPCODE_CREATE: equ 102 
1bbb				OPCODE_APPEND: equ 103 
1bbb				OPCODE_SDEL: equ 104 
1bbb				OPCODE_OPEN: equ 105 
1bbb				OPCODE_READ: equ 106 
1bbb				OPCODE_EOF: equ 106 
1bbb				OPCODE_FORMAT: equ 107 
1bbb				OPCODE_LABEL: equ 108 
1bbb				OPCODE_LABELS: equ 109 
1bbb			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1bbb				OPCODE_UPPER: equ 111 
1bbb				OPCODE_LOWER: equ 112 
1bbb				OPCODE_SUBSTR: equ 113 
1bbb				OPCODE_LEFT: equ 114 
1bbb				OPCODE_RIGHT: equ 115 
1bbb				OPCODE_STR2NUM: equ 116 
1bbb				OPCODE_NUM2STR: equ 117 
1bbb				OPCODE_CONCAT: equ 118 
1bbb				OPCODE_FIND: equ 119 
1bbb				OPCODE_LEN: equ 120 
1bbb				OPCODE_CHAR: equ 121 
1bbb			; free to reuse	OPCODE_STRLEN: equ 122 
1bbb			; free to reuse	OPCODE_ENDSTR: equ 123 
1bbb				OPCODE_V0S: equ 124 
1bbb				OPCODE_V0Q: equ 125 
1bbb				OPCODE_V1S: equ 126 
1bbb				OPCODE_V1Q: equ 127 
1bbb				OPCODE_V2S: equ 128 
1bbb				OPCODE_V2Q: equ 129 
1bbb				OPCODE_V3S: equ 130 
1bbb				OPCODE_V3Q: equ 131 
1bbb			;free to reuse	OPCODE_END: equ 132 
1bbb				OPCODE_ZDUP: equ 133 
1bbb			 
1bbb			; eof 
# End of file forth_opcodes.asm
1bbb			 
1bbb			include "forth_words_core.asm" 
1bbb			 
1bbb			; | ## Core Words 
1bbb			 
1bbb			;if MALLOC_4 
1bbb			 
1bbb			.HEAP: 
1bbb				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1bbb 15				db WORD_SYS_CORE+OPCODE_HEAP             
1bbc fa 1b			dw .EXEC            
1bbe 05				db 4 + 1 
1bbf .. 00			db "HEAP",0              
1bc4				endm 
# End of macro CWHEAD
1bc4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1bc4			; | | u1 - Current number of bytes in the heap 
1bc4			; | | u2 - Remaining bytes left on the heap 
1bc4			; | |  
1bc4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1bc4			 
1bc4			 
1bc4					if DEBUG_FORTH_WORDS_KEY 
1bc4						DMARK "HEP" 
1bc4 f5				push af  
1bc5 3a d9 1b			ld a, (.dmark)  
1bc8 32 77 fb			ld (debug_mark),a  
1bcb 3a da 1b			ld a, (.dmark+1)  
1bce 32 78 fb			ld (debug_mark+1),a  
1bd1 3a db 1b			ld a, (.dmark+2)  
1bd4 32 79 fb			ld (debug_mark+2),a  
1bd7 18 03			jr .pastdmark  
1bd9 ..			.dmark: db "HEP"  
1bdc f1			.pastdmark: pop af  
1bdd			endm  
# End of macro DMARK
1bdd						CALLMONITOR 
1bdd cd 04 13			call break_point_state  
1be0				endm  
# End of macro CALLMONITOR
1be0					endif 
1be0 2a 0a 80				ld hl, (free_list )      
1be3 11 0e 80				ld de, heap_start 
1be6			 
1be6 ed 52				sbc hl, de  
1be8			 
1be8 cd 8e 18				call forth_push_numhl 
1beb			 
1beb			 
1beb ed 5b 0a 80			ld de, (free_list )      
1bef 21 26 ee				ld hl, heap_end 
1bf2			 
1bf2 ed 52				sbc hl, de 
1bf4			 
1bf4 cd 8e 18				call forth_push_numhl 
1bf7					 
1bf7			 
1bf7					 
1bf7			 
1bf7			 
1bf7			 
1bf7					NEXTW 
1bf7 c3 63 1a			jp macro_next 
1bfa				endm 
# End of macro NEXTW
1bfa			;endif 
1bfa			 
1bfa			.EXEC: 
1bfa				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1bfa 16				db WORD_SYS_CORE+OPCODE_EXEC             
1bfb 40 1c			dw .STKEXEC            
1bfd 05				db 4 + 1 
1bfe .. 00			db "EXEC",0              
1c03				endm 
# End of macro CWHEAD
1c03			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1c03			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1c03			; | | 
1c03			; | |   
1c03				STACKFRAME OFF $5efe $5f9f 
1c03				if DEBUG_STACK_IMB 
1c03					if OFF 
1c03						exx 
1c03						ld de, $5efe 
1c03						ld a, d 
1c03						ld hl, curframe 
1c03						call hexout 
1c03						ld a, e 
1c03						ld hl, curframe+2 
1c03						call hexout 
1c03						ld hl, $5efe 
1c03						push hl 
1c03						ld hl, $5f9f 
1c03						push hl 
1c03						exx 
1c03					endif 
1c03				endif 
1c03			endm 
# End of macro STACKFRAME
1c03			 
1c03					if DEBUG_FORTH_WORDS_KEY 
1c03						DMARK "EXE" 
1c03 f5				push af  
1c04 3a 18 1c			ld a, (.dmark)  
1c07 32 77 fb			ld (debug_mark),a  
1c0a 3a 19 1c			ld a, (.dmark+1)  
1c0d 32 78 fb			ld (debug_mark+1),a  
1c10 3a 1a 1c			ld a, (.dmark+2)  
1c13 32 79 fb			ld (debug_mark+2),a  
1c16 18 03			jr .pastdmark  
1c18 ..			.dmark: db "EXE"  
1c1b f1			.pastdmark: pop af  
1c1c			endm  
# End of macro DMARK
1c1c						CALLMONITOR 
1c1c cd 04 13			call break_point_state  
1c1f				endm  
# End of macro CALLMONITOR
1c1f					endif 
1c1f			 
1c1f				FORTH_DSP_VALUEHL 
1c1f cd 29 19			call macro_dsp_valuehl 
1c22				endm 
# End of macro FORTH_DSP_VALUEHL
1c22			 
1c22				FORTH_DSP_POP 
1c22 cd a9 19			call macro_forth_dsp_pop 
1c25				endm 
# End of macro FORTH_DSP_POP
1c25			 
1c25					if DEBUG_FORTH_WORDS 
1c25						DMARK "EX1" 
1c25						CALLMONITOR 
1c25					endif 
1c25			;	ld e,(hl) 
1c25			;	inc hl 
1c25			;	ld d,(hl) 
1c25			;	ex de,hl 
1c25			 
1c25					if DEBUG_FORTH_WORDS 
1c25						DMARK "EX2" 
1c25						CALLMONITOR 
1c25					endif 
1c25 e5				push hl 
1c26			 
1c26				;ld a, 0 
1c26				;ld a, FORTH_END_BUFFER 
1c26 cd 74 0f			call strlenz 
1c29 23				inc hl   ; include zero term to copy 
1c2a 06 00			ld b,0 
1c2c 4d				ld c,l 
1c2d e1				pop hl 
1c2e 11 31 ef			ld de, execscratch 
1c31					if DEBUG_FORTH_WORDS 
1c31						DMARK "EX3" 
1c31						CALLMONITOR 
1c31					endif 
1c31 ed b0			ldir 
1c33			 
1c33			 
1c33 21 31 ef			ld hl, execscratch 
1c36			 
1c36					if DEBUG_FORTH_WORDS 
1c36						DMARK "EXe" 
1c36						CALLMONITOR 
1c36					endif 
1c36			 
1c36 cd b1 1a			call forthparse 
1c39 cd f1 1a			call forthexec 
1c3c			;	call forthexec_cleanup 
1c3c			;	call forthparse 
1c3c			;	call forthexec 
1c3c			 
1c3c				STACKFRAMECHK OFF $5efe $5f9f 
1c3c				if DEBUG_STACK_IMB 
1c3c					if OFF 
1c3c						exx 
1c3c						ld hl, $5f9f 
1c3c						pop de   ; $5f9f 
1c3c						call cmp16 
1c3c						jr nz, .spnosame 
1c3c						ld hl, $5efe 
1c3c						pop de   ; $5efe 
1c3c						call cmp16 
1c3c						jr z, .spfrsame 
1c3c						.spnosame: call showsperror 
1c3c						.spfrsame: nop 
1c3c						exx 
1c3c					endif 
1c3c				endif 
1c3c			endm 
# End of macro STACKFRAMECHK
1c3c			 
1c3c				; an immediate word so no need to process any more words 
1c3c c9				ret 
1c3d				NEXTW 
1c3d c3 63 1a			jp macro_next 
1c40				endm 
# End of macro NEXTW
1c40			 
1c40			; dead code - old version  
1c40			;	FORTH_RSP_NEXT 
1c40			 
1c40			;  
1c40			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c40			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c40			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c40			;	push hl 
1c40			;	push de 
1c40			;	push bc 
1c40			; 
1c40			; 
1c40			;		if DEBUG_FORTH_WORDS_KEY 
1c40			;			DMARK "EXR" 
1c40			;			CALLMONITOR 
1c40			;		endif 
1c40			; 
1c40			; 
1c40			; 
1c40			;	;v5 FORTH_DSP_VALUE 
1c40			;	FORTH_DSP_VALUEHL 
1c40			; 
1c40			;	; TODO do string type checks 
1c40			; 
1c40			;;v5	inc hl   ; skip type 
1c40			; 
1c40			;	push hl  ; source code  
1c40			;		if DEBUG_FORTH_WORDS 
1c40			;			DMARK "EX1" 
1c40			;			CALLMONITOR 
1c40			;		endif 
1c40			;	ld a, 0 
1c40			;	call strlent 
1c40			; 
1c40			;	inc hl 
1c40			;	inc hl 
1c40			;	inc hl 
1c40			;	inc hl 
1c40			; 
1c40			;	push hl    ; size 
1c40			; 
1c40			;		if DEBUG_FORTH_WORDS 
1c40			;			DMARK "EX2" 
1c40			;			CALLMONITOR 
1c40			;		endif 
1c40			;	call malloc 
1c40			; 
1c40			;	ex de, hl    ; de now contains malloc area 
1c40			;	pop bc   	; get byte count 
1c40			;	pop hl      ; get string to copy 
1c40			; 
1c40			;	push de     ; save malloc for free later 
1c40			; 
1c40			;		if DEBUG_FORTH_WORDS 
1c40			;			DMARK "EX3" 
1c40			;			CALLMONITOR 
1c40			;		endif 
1c40			;	ldir       ; duplicate string 
1c40			; 
1c40			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1c40			;	 
1c40			;	; TODO fix the parse would be better than this...  
1c40			;	ex de, hl 
1c40			;	dec hl 
1c40			;	ld a, 0 
1c40			;	ld (hl), a 
1c40			;	dec hl 
1c40			;	ld a, ' ' 
1c40			;	ld (hl), a 
1c40			;	dec hl 
1c40			;	ld (hl), a 
1c40			; 
1c40			;	dec hl 
1c40			;	ld (hl), a 
1c40			; 
1c40			; 
1c40			;	FORTH_DSP_POP  
1c40			; 
1c40			;	pop hl     
1c40			;	push hl    ; save malloc area 
1c40			; 
1c40			;		if DEBUG_FORTH_WORDS 
1c40			;			DMARK "EX4" 
1c40			;			CALLMONITOR 
1c40			;		endif 
1c40			; 
1c40			;	call forthparse 
1c40			;	call forthexec 
1c40			;	 
1c40			;	pop hl 
1c40			;	if DEBUG_FORTH_WORDS 
1c40			;		DMARK "EX5" 
1c40			;		CALLMONITOR 
1c40			;	endif 
1c40			; 
1c40			;	if FORTH_ENABLE_FREE 
1c40			;	call free 
1c40			;	endif 
1c40			; 
1c40			;	if DEBUG_FORTH_WORDS 
1c40			;		DMARK "EX6" 
1c40			;		CALLMONITOR 
1c40			;	endif 
1c40			; 
1c40			;	pop bc 
1c40			;	pop de 
1c40			;	pop hl 
1c40			;;	FORTH_RSP_POP	  
1c40			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1c40			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1c40			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1c40			; 
1c40			;	if DEBUG_FORTH_WORDS 
1c40			;		DMARK "EX7" 
1c40			;		CALLMONITOR 
1c40			;	endif 
1c40			;	NEXTW 
1c40			 
1c40			.STKEXEC: 
1c40				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1c40 3f				db WORD_SYS_CORE+43             
1c41 db 1c			dw .ZDUP            
1c43 08				db 7 + 1 
1c44 .. 00			db "STKEXEC",0              
1c4c				endm 
# End of macro CWHEAD
1c4c			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1c4c			 
1c4c			 
1c4c					if DEBUG_FORTH_WORDS_KEY 
1c4c						DMARK "STX" 
1c4c f5				push af  
1c4d 3a 61 1c			ld a, (.dmark)  
1c50 32 77 fb			ld (debug_mark),a  
1c53 3a 62 1c			ld a, (.dmark+1)  
1c56 32 78 fb			ld (debug_mark+1),a  
1c59 3a 63 1c			ld a, (.dmark+2)  
1c5c 32 79 fb			ld (debug_mark+2),a  
1c5f 18 03			jr .pastdmark  
1c61 ..			.dmark: db "STX"  
1c64 f1			.pastdmark: pop af  
1c65			endm  
# End of macro DMARK
1c65						CALLMONITOR 
1c65 cd 04 13			call break_point_state  
1c68				endm  
# End of macro CALLMONITOR
1c68					endif 
1c68			 
1c68				FORTH_DSP_VALUEHL 
1c68 cd 29 19			call macro_dsp_valuehl 
1c6b				endm 
# End of macro FORTH_DSP_VALUEHL
1c6b			 
1c6b 22 60 f8			ld (store_tmp1), hl    ; count 
1c6e			 
1c6e				FORTH_DSP_POP 
1c6e cd a9 19			call macro_forth_dsp_pop 
1c71				endm 
# End of macro FORTH_DSP_POP
1c71			.stkexec1: 
1c71 2a 60 f8			ld hl, (store_tmp1)   ; count 
1c74 3e 00			ld a, 0 
1c76 bd				cp l 
1c77 c8				ret z 
1c78			 
1c78 2b				dec hl 
1c79 22 60 f8			ld (store_tmp1), hl    ; count 
1c7c				 
1c7c				FORTH_DSP_VALUEHL 
1c7c cd 29 19			call macro_dsp_valuehl 
1c7f				endm 
# End of macro FORTH_DSP_VALUEHL
1c7f e5				push hl 
1c80				 
1c80				FORTH_DSP_POP 
1c80 cd a9 19			call macro_forth_dsp_pop 
1c83				endm 
# End of macro FORTH_DSP_POP
1c83			 
1c83 cd 74 0f			call strlenz 
1c86 23				inc hl   ; include zero term to copy 
1c87 06 00			ld b,0 
1c89 4d				ld c,l 
1c8a e1				pop hl 
1c8b 11 31 ef			ld de, execscratch 
1c8e					if DEBUG_FORTH_WORDS 
1c8e						DMARK "EX3" 
1c8e						CALLMONITOR 
1c8e					endif 
1c8e ed b0			ldir 
1c90			 
1c90			 
1c90 21 31 ef			ld hl, execscratch 
1c93			 
1c93					if DEBUG_FORTH_WORDS 
1c93						DMARK "EXe" 
1c93						CALLMONITOR 
1c93					endif 
1c93			 
1c93 cd b1 1a			call forthparse 
1c96 cd f1 1a			call forthexec 
1c99			 
1c99 c3 71 1c			jp .stkexec1 
1c9c			 
1c9c c9				ret 
1c9d			 
1c9d			 
1c9d			.DUP: 
1c9d				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1c9d 17				db WORD_SYS_CORE+OPCODE_DUP             
1c9e db 1c			dw .ZDUP            
1ca0 04				db 3 + 1 
1ca1 .. 00			db "DUP",0              
1ca5				endm 
# End of macro CWHEAD
1ca5			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1ca5			 
1ca5					if DEBUG_FORTH_WORDS_KEY 
1ca5						DMARK "DUP" 
1ca5 f5				push af  
1ca6 3a ba 1c			ld a, (.dmark)  
1ca9 32 77 fb			ld (debug_mark),a  
1cac 3a bb 1c			ld a, (.dmark+1)  
1caf 32 78 fb			ld (debug_mark+1),a  
1cb2 3a bc 1c			ld a, (.dmark+2)  
1cb5 32 79 fb			ld (debug_mark+2),a  
1cb8 18 03			jr .pastdmark  
1cba ..			.dmark: db "DUP"  
1cbd f1			.pastdmark: pop af  
1cbe			endm  
# End of macro DMARK
1cbe						CALLMONITOR 
1cbe cd 04 13			call break_point_state  
1cc1				endm  
# End of macro CALLMONITOR
1cc1					endif 
1cc1			 
1cc1					FORTH_DSP 
1cc1 cd 0e 19			call macro_forth_dsp 
1cc4				endm 
# End of macro FORTH_DSP
1cc4			 
1cc4 7e					ld a, (HL) 
1cc5 fe 01				cp DS_TYPE_STR 
1cc7 20 09				jr nz, .dupinum 
1cc9			 
1cc9					; push another string 
1cc9			 
1cc9					FORTH_DSP_VALUEHL     		 
1cc9 cd 29 19			call macro_dsp_valuehl 
1ccc				endm 
# End of macro FORTH_DSP_VALUEHL
1ccc			 
1ccc				if DEBUG_FORTH_WORDS 
1ccc					DMARK "DUs" 
1ccc					CALLMONITOR 
1ccc				endif 
1ccc cd a0 18				call forth_push_str 
1ccf			 
1ccf					NEXTW 
1ccf c3 63 1a			jp macro_next 
1cd2				endm 
# End of macro NEXTW
1cd2			 
1cd2			 
1cd2			.dupinum: 
1cd2					 
1cd2			 
1cd2			 
1cd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1cd2 cd 29 19			call macro_dsp_valuehl 
1cd5				endm 
# End of macro FORTH_DSP_VALUEHL
1cd5			 
1cd5				; TODO add floating point number detection 
1cd5			 
1cd5				if DEBUG_FORTH_WORDS 
1cd5					DMARK "DUi" 
1cd5					CALLMONITOR 
1cd5				endif 
1cd5			 
1cd5 cd 8e 18				call forth_push_numhl 
1cd8					NEXTW 
1cd8 c3 63 1a			jp macro_next 
1cdb				endm 
# End of macro NEXTW
1cdb			.ZDUP: 
1cdb				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1cdb 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1cdc 13 1d			dw .SWAP            
1cde 05				db 4 + 1 
1cdf .. 00			db "?DUP",0              
1ce4				endm 
# End of macro CWHEAD
1ce4			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1ce4			 
1ce4					if DEBUG_FORTH_WORDS_KEY 
1ce4						DMARK "qDU" 
1ce4 f5				push af  
1ce5 3a f9 1c			ld a, (.dmark)  
1ce8 32 77 fb			ld (debug_mark),a  
1ceb 3a fa 1c			ld a, (.dmark+1)  
1cee 32 78 fb			ld (debug_mark+1),a  
1cf1 3a fb 1c			ld a, (.dmark+2)  
1cf4 32 79 fb			ld (debug_mark+2),a  
1cf7 18 03			jr .pastdmark  
1cf9 ..			.dmark: db "qDU"  
1cfc f1			.pastdmark: pop af  
1cfd			endm  
# End of macro DMARK
1cfd						CALLMONITOR 
1cfd cd 04 13			call break_point_state  
1d00				endm  
# End of macro CALLMONITOR
1d00					endif 
1d00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1d00 cd 29 19			call macro_dsp_valuehl 
1d03				endm 
# End of macro FORTH_DSP_VALUEHL
1d03			 
1d03 e5					push hl 
1d04			 
1d04					; is it a zero? 
1d04			 
1d04 3e 00				ld a, 0 
1d06 84					add h 
1d07 85					add l 
1d08			 
1d08 e1					pop hl 
1d09			 
1d09 fe 00				cp 0 
1d0b 28 03				jr z, .dup2orig 
1d0d			 
1d0d			 
1d0d cd 8e 18				call forth_push_numhl 
1d10			 
1d10			 
1d10				; TODO add floating point number detection 
1d10			 
1d10			.dup2orig: 
1d10			 
1d10					NEXTW 
1d10 c3 63 1a			jp macro_next 
1d13				endm 
# End of macro NEXTW
1d13			.SWAP: 
1d13				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1d13 18				db WORD_SYS_CORE+OPCODE_SWAP             
1d14 52 1d			dw .COLN            
1d16 05				db 4 + 1 
1d17 .. 00			db "SWAP",0              
1d1c				endm 
# End of macro CWHEAD
1d1c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1d1c					if DEBUG_FORTH_WORDS_KEY 
1d1c						DMARK "SWP" 
1d1c f5				push af  
1d1d 3a 31 1d			ld a, (.dmark)  
1d20 32 77 fb			ld (debug_mark),a  
1d23 3a 32 1d			ld a, (.dmark+1)  
1d26 32 78 fb			ld (debug_mark+1),a  
1d29 3a 33 1d			ld a, (.dmark+2)  
1d2c 32 79 fb			ld (debug_mark+2),a  
1d2f 18 03			jr .pastdmark  
1d31 ..			.dmark: db "SWP"  
1d34 f1			.pastdmark: pop af  
1d35			endm  
# End of macro DMARK
1d35						CALLMONITOR 
1d35 cd 04 13			call break_point_state  
1d38				endm  
# End of macro CALLMONITOR
1d38					endif 
1d38			 
1d38					FORTH_DSP_VALUEHL 
1d38 cd 29 19			call macro_dsp_valuehl 
1d3b				endm 
# End of macro FORTH_DSP_VALUEHL
1d3b e5					push hl     ; w2 
1d3c			 
1d3c					FORTH_DSP_POP 
1d3c cd a9 19			call macro_forth_dsp_pop 
1d3f				endm 
# End of macro FORTH_DSP_POP
1d3f			 
1d3f					FORTH_DSP_VALUEHL 
1d3f cd 29 19			call macro_dsp_valuehl 
1d42				endm 
# End of macro FORTH_DSP_VALUEHL
1d42			 
1d42					FORTH_DSP_POP 
1d42 cd a9 19			call macro_forth_dsp_pop 
1d45				endm 
# End of macro FORTH_DSP_POP
1d45			 
1d45 d1					pop de     ; w2	, hl = w1 
1d46			 
1d46 eb					ex de, hl 
1d47 d5					push de 
1d48			 
1d48 cd 8e 18				call forth_push_numhl 
1d4b			 
1d4b e1					pop hl 
1d4c			 
1d4c cd 8e 18				call forth_push_numhl 
1d4f					 
1d4f			 
1d4f					NEXTW 
1d4f c3 63 1a			jp macro_next 
1d52				endm 
# End of macro NEXTW
1d52			.COLN: 
1d52				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1d52 19				db WORD_SYS_CORE+OPCODE_COLN             
1d53 14 1e			dw .SCOLN            
1d55 02				db 1 + 1 
1d56 .. 00			db ":",0              
1d58				endm 
# End of macro CWHEAD
1d58			; | : ( -- )         Create new word | DONE 
1d58			 
1d58					if DEBUG_FORTH_WORDS_KEY 
1d58						DMARK "CLN" 
1d58 f5				push af  
1d59 3a 6d 1d			ld a, (.dmark)  
1d5c 32 77 fb			ld (debug_mark),a  
1d5f 3a 6e 1d			ld a, (.dmark+1)  
1d62 32 78 fb			ld (debug_mark+1),a  
1d65 3a 6f 1d			ld a, (.dmark+2)  
1d68 32 79 fb			ld (debug_mark+2),a  
1d6b 18 03			jr .pastdmark  
1d6d ..			.dmark: db "CLN"  
1d70 f1			.pastdmark: pop af  
1d71			endm  
# End of macro DMARK
1d71						CALLMONITOR 
1d71 cd 04 13			call break_point_state  
1d74				endm  
# End of macro CALLMONITOR
1d74					endif 
1d74				STACKFRAME OFF $8efe $989f 
1d74				if DEBUG_STACK_IMB 
1d74					if OFF 
1d74						exx 
1d74						ld de, $8efe 
1d74						ld a, d 
1d74						ld hl, curframe 
1d74						call hexout 
1d74						ld a, e 
1d74						ld hl, curframe+2 
1d74						call hexout 
1d74						ld hl, $8efe 
1d74						push hl 
1d74						ld hl, $989f 
1d74						push hl 
1d74						exx 
1d74					endif 
1d74				endif 
1d74			endm 
# End of macro STACKFRAME
1d74				; get parser buffer length  of new word 
1d74			 
1d74				 
1d74			 
1d74					; move tok past this to start of name defintition 
1d74					; TODO get word to define 
1d74					; TODO Move past word token 
1d74					; TODO get length of string up to the ';' 
1d74			 
1d74 2a 33 f1			ld hl, (os_tok_ptr) 
1d77 23				inc hl 
1d78 23				inc hl 
1d79			 
1d79 3e 3b			ld a, ';' 
1d7b cd 7f 0f			call strlent 
1d7e			 
1d7e 7d				ld a,l 
1d7f 32 32 f0			ld (os_new_parse_len), a 
1d82			 
1d82			 
1d82			if DEBUG_FORTH_UWORD 
1d82				ld de, (os_tok_ptr) 
1d82						DMARK ":01" 
1d82				CALLMONITOR 
1d82			endif 
1d82			 
1d82			; 
1d82			;  new word memory layout: 
1d82			;  
1d82			;    : adg 6666 ;  
1d82			; 
1d82			;    db   1     ; user defined word  
1d82 23				inc hl    
1d83			;    dw   sysdict 
1d83 23				inc hl 
1d84 23				inc hl 
1d85			;    db <word len>+1 (for null) 
1d85 23				inc hl 
1d86			;    db .... <word> 
1d86			; 
1d86			 
1d86 23				inc hl    ; some extras for the word preamble before the above 
1d87 23				inc hl 
1d88 23				inc hl 
1d89 23				inc hl 
1d8a 23				inc hl 
1d8b 23				inc hl 
1d8c 23				inc hl  
1d8d 23				inc hl 
1d8e 23				inc hl 
1d8f 23				inc hl 
1d90 23				inc hl 
1d91 23				inc hl 
1d92 23				inc hl 
1d93 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1d94			;       exec word buffer 
1d94			;	<ptr word>   
1d94 23				inc hl 
1d95 23				inc hl 
1d96			;       <word list><null term> 7F final term 
1d96			 
1d96			 
1d96			if DEBUG_FORTH_UWORD 
1d96						DMARK ":02" 
1d96				CALLMONITOR 
1d96			endif 
1d96			 
1d96				 
1d96					; malloc the size 
1d96			 
1d96 cd dd 0f				call malloc 
1d99 22 30 f0				ld (os_new_malloc), hl     ; save malloc start 
1d9c			 
1d9c			;    db   1     ; user defined word  
1d9c 3e 01				ld a, WORD_SYS_UWORD  
1d9e 77					ld (hl), a 
1d9f				 
1d9f 23				inc hl    
1da0			;    dw   sysdict 
1da0 11 bb 1b			ld de, sysdict       ; continue on with the scan to the system dict 
1da3 73				ld (hl), e 
1da4 23				inc hl 
1da5 72				ld (hl), d 
1da6 23				inc hl 
1da7			 
1da7			 
1da7			;    Setup dict word 
1da7			 
1da7 23				inc hl 
1da8 22 36 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
1dab			 
1dab				; 1. get length of dict word 
1dab			 
1dab			 
1dab 2a 33 f1			ld hl, (os_tok_ptr) 
1dae 23				inc hl 
1daf 23				inc hl    ; position to start of dict word 
1db0 3e 00			ld a, 0 
1db2 cd 7f 0f			call strlent 
1db5			 
1db5			 
1db5 23				inc hl    ; to include null??? 
1db6			 
1db6				; write length of dict word 
1db6			 
1db6 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1dba 1b				dec de 
1dbb eb				ex de, hl 
1dbc 73				ld (hl), e 
1dbd eb				ex de, hl 
1dbe			 
1dbe				 
1dbe			 
1dbe				; copy  
1dbe 4d				ld c, l 
1dbf 06 00			ld b, 0 
1dc1 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1dc5 2a 33 f1			ld hl, (os_tok_ptr) 
1dc8 23				inc hl 
1dc9 23				inc hl    ; position to start of dict word 
1dca				 
1dca			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1dca				 
1dca				; TODO need to convert word to upper case 
1dca			 
1dca			ucasetok:	 
1dca 7e				ld a,(hl) 
1dcb cd 6b 0f			call toUpper 
1dce 77				ld (hl),a 
1dcf ed a0			ldi 
1dd1 f2 ca 1d		 	jp p, ucasetok 
1dd4			 
1dd4			 
1dd4			 
1dd4				; de now points to start of where the word body code should be placed 
1dd4 ed 53 36 f0		ld (os_new_work_ptr), de 
1dd8				; hl now points to the words to throw at forthexec which needs to be copied 
1dd8 22 38 f0			ld (os_new_src_ptr), hl 
1ddb			 
1ddb				; TODO add 'call to forthexec' 
1ddb			 
1ddb			if DEBUG_FORTH_UWORD 
1ddb				push bc 
1ddb				ld bc, (os_new_malloc) 
1ddb						DMARK ":0x" 
1ddb				CALLMONITOR 
1ddb				pop bc 
1ddb			endif 
1ddb			 
1ddb			 
1ddb				; create word preamble which should be: 
1ddb			 
1ddb			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1ddb			 
1ddb				;    ld hl, <word code> 
1ddb				;    jp user_exec 
1ddb			        ;    <word code bytes> 
1ddb			 
1ddb			 
1ddb			;	inc de     ; TODO ??? or are we already past the word's null 
1ddb eb				ex de, hl 
1ddc			 
1ddc 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1dde			 
1dde 23				inc hl 
1ddf 22 3c f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1de2 23				inc hl 
1de3			 
1de3 23				inc hl 
1de4 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1de6			 
1de6 01 d7 3e			ld bc, user_exec 
1de9 23				inc hl 
1dea 71				ld (hl), c     ; poke address of user_exec 
1deb 23				inc hl 
1dec 70				ld (hl), b     
1ded			 ; 
1ded			;	inc hl 
1ded			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1ded			; 
1ded			; 
1ded			;	ld bc, macro_forth_rsp_next 
1ded			;	inc hl 
1ded			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1ded			;	inc hl 
1ded			;	ld (hl), b     
1ded			 ; 
1ded			;	inc hl 
1ded			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1ded			; 
1ded			; 
1ded			;	inc hl 
1ded			;	ld bc, forthexec 
1ded			;	ld (hl), c     ; poke address of forthexec 
1ded			;	inc hl 
1ded			;	ld (hl), b      
1ded			; 
1ded			;	inc hl 
1ded			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1ded			; 
1ded			;	ld bc, user_dict_next 
1ded			;	inc hl 
1ded			;	ld (hl), c     ; poke address of forthexec 
1ded			;	inc hl 
1ded			;	ld (hl), b      
1ded			 
1ded				; hl is now where we need to copy the word byte data to save this 
1ded			 
1ded 23				inc hl 
1dee 22 3a f0			ld (os_new_exec), hl 
1df1				 
1df1				; copy definition 
1df1			 
1df1 eb				ex de, hl 
1df2			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1df2			;	inc de    ; skip the PC for this parse 
1df2 3a 32 f0			ld a, (os_new_parse_len) 
1df5 4f				ld c, a 
1df6 06 00			ld b, 0 
1df8 ed b0			ldir		 ; copy defintion 
1dfa			 
1dfa			 
1dfa				; poke the address of where the new word bytes live for forthexec 
1dfa			 
1dfa 2a 3c f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
1dfd			 
1dfd ed 5b 3a f0		ld de, (os_new_exec)      
1e01				 
1e01 73				ld (hl), e 
1e02 23				inc hl 
1e03 72				ld (hl), d 
1e04			 
1e04					; TODO copy last user dict word next link to this word 
1e04					; TODO update last user dict word to point to this word 
1e04			; 
1e04			; hl f923 de 812a ; bc 811a 
1e04			 
1e04			if DEBUG_FORTH_UWORD 
1e04				push bc 
1e04				ld bc, (os_new_malloc) 
1e04						DMARK ":0A" 
1e04				CALLMONITOR 
1e04				pop bc 
1e04			endif 
1e04			if DEBUG_FORTH_UWORD 
1e04				push bc 
1e04				ld bc, (os_new_malloc) 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04				inc bc 
1e04			 
1e04						DMARK ":0B" 
1e04				CALLMONITOR 
1e04				pop bc 
1e04			endif 
1e04			 
1e04			; update word dict linked list for new word 
1e04			 
1e04			 
1e04 2a 2f f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
1e07 23			inc hl     ; move to next work linked list ptr 
1e08			 
1e08 ed 5b 30 f0	ld de, (os_new_malloc)		 ; new next word 
1e0c 73			ld (hl), e 
1e0d 23			inc hl 
1e0e 72			ld (hl), d 
1e0f			 
1e0f			if DEBUG_FORTH_UWORD 
1e0f				ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
1e0f			endif 
1e0f			 
1e0f ed 53 2f f1	ld (os_last_new_uword), de      ; update last new uword ptr 
1e13			 
1e13			 
1e13			if DEBUG_FORTH_UWORD 
1e13						DMARK ":0+" 
1e13				CALLMONITOR 
1e13			endif 
1e13			 
1e13				STACKFRAMECHK OFF $8efe $989f 
1e13				if DEBUG_STACK_IMB 
1e13					if OFF 
1e13						exx 
1e13						ld hl, $989f 
1e13						pop de   ; $989f 
1e13						call cmp16 
1e13						jr nz, .spnosame 
1e13						ld hl, $8efe 
1e13						pop de   ; $8efe 
1e13						call cmp16 
1e13						jr z, .spfrsame 
1e13						.spnosame: call showsperror 
1e13						.spfrsame: nop 
1e13						exx 
1e13					endif 
1e13				endif 
1e13			endm 
# End of macro STACKFRAMECHK
1e13			 
1e13 c9			ret    ; dont process any remaining parser tokens as they form new word 
1e14			 
1e14			 
1e14			 
1e14			 
1e14			;		NEXT 
1e14			.SCOLN: 
1e14			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
1e14 06				db OPCODE_SCOLN 
1e15 44 1e			dw .DROP 
1e17 02				db 2 
1e18 .. 00			db ";",0           
1e1a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
1e1a					if DEBUG_FORTH_WORDS_KEY 
1e1a						DMARK "SCN" 
1e1a f5				push af  
1e1b 3a 2f 1e			ld a, (.dmark)  
1e1e 32 77 fb			ld (debug_mark),a  
1e21 3a 30 1e			ld a, (.dmark+1)  
1e24 32 78 fb			ld (debug_mark+1),a  
1e27 3a 31 1e			ld a, (.dmark+2)  
1e2a 32 79 fb			ld (debug_mark+2),a  
1e2d 18 03			jr .pastdmark  
1e2f ..			.dmark: db "SCN"  
1e32 f1			.pastdmark: pop af  
1e33			endm  
# End of macro DMARK
1e33						CALLMONITOR 
1e33 cd 04 13			call break_point_state  
1e36				endm  
# End of macro CALLMONITOR
1e36					endif 
1e36					FORTH_RSP_TOS 
1e36 cd 4f 18			call macro_forth_rsp_tos 
1e39				endm 
# End of macro FORTH_RSP_TOS
1e39 e5					push hl 
1e3a					FORTH_RSP_POP 
1e3a cd 56 18			call macro_forth_rsp_pop 
1e3d				endm 
# End of macro FORTH_RSP_POP
1e3d e1					pop hl 
1e3e			;		ex de,hl 
1e3e 22 33 f1				ld (os_tok_ptr),hl 
1e41			 
1e41			if DEBUG_FORTH_UWORD 
1e41						DMARK "SCL" 
1e41				CALLMONITOR 
1e41			endif 
1e41					NEXTW 
1e41 c3 63 1a			jp macro_next 
1e44				endm 
# End of macro NEXTW
1e44			 
1e44			.DROP: 
1e44				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
1e44 1b				db WORD_SYS_CORE+OPCODE_DROP             
1e45 6f 1e			dw .DUP2            
1e47 05				db 4 + 1 
1e48 .. 00			db "DROP",0              
1e4d				endm 
# End of macro CWHEAD
1e4d			; | DROP ( w -- )   drop the TOS item   | DONE 
1e4d					if DEBUG_FORTH_WORDS_KEY 
1e4d						DMARK "DRP" 
1e4d f5				push af  
1e4e 3a 62 1e			ld a, (.dmark)  
1e51 32 77 fb			ld (debug_mark),a  
1e54 3a 63 1e			ld a, (.dmark+1)  
1e57 32 78 fb			ld (debug_mark+1),a  
1e5a 3a 64 1e			ld a, (.dmark+2)  
1e5d 32 79 fb			ld (debug_mark+2),a  
1e60 18 03			jr .pastdmark  
1e62 ..			.dmark: db "DRP"  
1e65 f1			.pastdmark: pop af  
1e66			endm  
# End of macro DMARK
1e66						CALLMONITOR 
1e66 cd 04 13			call break_point_state  
1e69				endm  
# End of macro CALLMONITOR
1e69					endif 
1e69					FORTH_DSP_POP 
1e69 cd a9 19			call macro_forth_dsp_pop 
1e6c				endm 
# End of macro FORTH_DSP_POP
1e6c					NEXTW 
1e6c c3 63 1a			jp macro_next 
1e6f				endm 
# End of macro NEXTW
1e6f			.DUP2: 
1e6f				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
1e6f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
1e70 b4 1e			dw .DROP2            
1e72 05				db 4 + 1 
1e73 .. 00			db "2DUP",0              
1e78				endm 
# End of macro CWHEAD
1e78			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
1e78					if DEBUG_FORTH_WORDS_KEY 
1e78						DMARK "2DU" 
1e78 f5				push af  
1e79 3a 8d 1e			ld a, (.dmark)  
1e7c 32 77 fb			ld (debug_mark),a  
1e7f 3a 8e 1e			ld a, (.dmark+1)  
1e82 32 78 fb			ld (debug_mark+1),a  
1e85 3a 8f 1e			ld a, (.dmark+2)  
1e88 32 79 fb			ld (debug_mark+2),a  
1e8b 18 03			jr .pastdmark  
1e8d ..			.dmark: db "2DU"  
1e90 f1			.pastdmark: pop af  
1e91			endm  
# End of macro DMARK
1e91						CALLMONITOR 
1e91 cd 04 13			call break_point_state  
1e94				endm  
# End of macro CALLMONITOR
1e94					endif 
1e94					FORTH_DSP_VALUEHL 
1e94 cd 29 19			call macro_dsp_valuehl 
1e97				endm 
# End of macro FORTH_DSP_VALUEHL
1e97 e5					push hl      ; 2 
1e98			 
1e98					FORTH_DSP_POP 
1e98 cd a9 19			call macro_forth_dsp_pop 
1e9b				endm 
# End of macro FORTH_DSP_POP
1e9b					 
1e9b					FORTH_DSP_VALUEHL 
1e9b cd 29 19			call macro_dsp_valuehl 
1e9e				endm 
# End of macro FORTH_DSP_VALUEHL
1e9e			;		push hl      ; 1 
1e9e			 
1e9e					FORTH_DSP_POP 
1e9e cd a9 19			call macro_forth_dsp_pop 
1ea1				endm 
# End of macro FORTH_DSP_POP
1ea1			 
1ea1			;		pop hl       ; 1 
1ea1 d1					pop de       ; 2 
1ea2			 
1ea2 cd 8e 18				call forth_push_numhl 
1ea5 eb					ex de, hl 
1ea6 cd 8e 18				call forth_push_numhl 
1ea9			 
1ea9					 
1ea9 eb					ex de, hl 
1eaa			 
1eaa cd 8e 18				call forth_push_numhl 
1ead eb					ex de, hl 
1eae cd 8e 18				call forth_push_numhl 
1eb1			 
1eb1			 
1eb1					NEXTW 
1eb1 c3 63 1a			jp macro_next 
1eb4				endm 
# End of macro NEXTW
1eb4			.DROP2: 
1eb4				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
1eb4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
1eb5 e3 1e			dw .SWAP2            
1eb7 06				db 5 + 1 
1eb8 .. 00			db "2DROP",0              
1ebe				endm 
# End of macro CWHEAD
1ebe			; | 2DROP ( w w -- )    Double drop | DONE 
1ebe					if DEBUG_FORTH_WORDS_KEY 
1ebe						DMARK "2DR" 
1ebe f5				push af  
1ebf 3a d3 1e			ld a, (.dmark)  
1ec2 32 77 fb			ld (debug_mark),a  
1ec5 3a d4 1e			ld a, (.dmark+1)  
1ec8 32 78 fb			ld (debug_mark+1),a  
1ecb 3a d5 1e			ld a, (.dmark+2)  
1ece 32 79 fb			ld (debug_mark+2),a  
1ed1 18 03			jr .pastdmark  
1ed3 ..			.dmark: db "2DR"  
1ed6 f1			.pastdmark: pop af  
1ed7			endm  
# End of macro DMARK
1ed7						CALLMONITOR 
1ed7 cd 04 13			call break_point_state  
1eda				endm  
# End of macro CALLMONITOR
1eda					endif 
1eda					FORTH_DSP_POP 
1eda cd a9 19			call macro_forth_dsp_pop 
1edd				endm 
# End of macro FORTH_DSP_POP
1edd					FORTH_DSP_POP 
1edd cd a9 19			call macro_forth_dsp_pop 
1ee0				endm 
# End of macro FORTH_DSP_POP
1ee0					NEXTW 
1ee0 c3 63 1a			jp macro_next 
1ee3				endm 
# End of macro NEXTW
1ee3			.SWAP2: 
1ee3				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
1ee3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
1ee4 0c 1f			dw .AT            
1ee6 06				db 5 + 1 
1ee7 .. 00			db "2SWAP",0              
1eed				endm 
# End of macro CWHEAD
1eed			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
1eed					if DEBUG_FORTH_WORDS_KEY 
1eed						DMARK "2SW" 
1eed f5				push af  
1eee 3a 02 1f			ld a, (.dmark)  
1ef1 32 77 fb			ld (debug_mark),a  
1ef4 3a 03 1f			ld a, (.dmark+1)  
1ef7 32 78 fb			ld (debug_mark+1),a  
1efa 3a 04 1f			ld a, (.dmark+2)  
1efd 32 79 fb			ld (debug_mark+2),a  
1f00 18 03			jr .pastdmark  
1f02 ..			.dmark: db "2SW"  
1f05 f1			.pastdmark: pop af  
1f06			endm  
# End of macro DMARK
1f06						CALLMONITOR 
1f06 cd 04 13			call break_point_state  
1f09				endm  
# End of macro CALLMONITOR
1f09					endif 
1f09					NEXTW 
1f09 c3 63 1a			jp macro_next 
1f0c				endm 
# End of macro NEXTW
1f0c			.AT: 
1f0c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
1f0c 1f				db WORD_SYS_CORE+OPCODE_AT             
1f0d 3e 1f			dw .CAT            
1f0f 02				db 1 + 1 
1f10 .. 00			db "@",0              
1f12				endm 
# End of macro CWHEAD
1f12			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
1f12			 
1f12					if DEBUG_FORTH_WORDS_KEY 
1f12						DMARK "AT." 
1f12 f5				push af  
1f13 3a 27 1f			ld a, (.dmark)  
1f16 32 77 fb			ld (debug_mark),a  
1f19 3a 28 1f			ld a, (.dmark+1)  
1f1c 32 78 fb			ld (debug_mark+1),a  
1f1f 3a 29 1f			ld a, (.dmark+2)  
1f22 32 79 fb			ld (debug_mark+2),a  
1f25 18 03			jr .pastdmark  
1f27 ..			.dmark: db "AT."  
1f2a f1			.pastdmark: pop af  
1f2b			endm  
# End of macro DMARK
1f2b						CALLMONITOR 
1f2b cd 04 13			call break_point_state  
1f2e				endm  
# End of macro CALLMONITOR
1f2e					endif 
1f2e			.getbyteat:	 
1f2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f2e cd 29 19			call macro_dsp_valuehl 
1f31				endm 
# End of macro FORTH_DSP_VALUEHL
1f31					 
1f31			;		push hl 
1f31				 
1f31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f31 cd a9 19			call macro_forth_dsp_pop 
1f34				endm 
# End of macro FORTH_DSP_POP
1f34			 
1f34			;		pop hl 
1f34			 
1f34 7e					ld a, (hl) 
1f35			 
1f35 6f					ld l, a 
1f36 26 00				ld h, 0 
1f38 cd 8e 18				call forth_push_numhl 
1f3b			 
1f3b					NEXTW 
1f3b c3 63 1a			jp macro_next 
1f3e				endm 
# End of macro NEXTW
1f3e			.CAT: 
1f3e				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
1f3e 20				db WORD_SYS_CORE+OPCODE_CAT             
1f3f 67 1f			dw .BANG            
1f41 03				db 2 + 1 
1f42 .. 00			db "C@",0              
1f45				endm 
# End of macro CWHEAD
1f45			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
1f45					if DEBUG_FORTH_WORDS_KEY 
1f45						DMARK "CAA" 
1f45 f5				push af  
1f46 3a 5a 1f			ld a, (.dmark)  
1f49 32 77 fb			ld (debug_mark),a  
1f4c 3a 5b 1f			ld a, (.dmark+1)  
1f4f 32 78 fb			ld (debug_mark+1),a  
1f52 3a 5c 1f			ld a, (.dmark+2)  
1f55 32 79 fb			ld (debug_mark+2),a  
1f58 18 03			jr .pastdmark  
1f5a ..			.dmark: db "CAA"  
1f5d f1			.pastdmark: pop af  
1f5e			endm  
# End of macro DMARK
1f5e						CALLMONITOR 
1f5e cd 04 13			call break_point_state  
1f61				endm  
# End of macro CALLMONITOR
1f61					endif 
1f61 c3 2e 1f				jp .getbyteat 
1f64					NEXTW 
1f64 c3 63 1a			jp macro_next 
1f67				endm 
# End of macro NEXTW
1f67			.BANG: 
1f67				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
1f67 21				db WORD_SYS_CORE+OPCODE_BANG             
1f68 9d 1f			dw .CBANG            
1f6a 02				db 1 + 1 
1f6b .. 00			db "!",0              
1f6d				endm 
# End of macro CWHEAD
1f6d			; | ! ( x w -- ) Store x at address w      | DONE 
1f6d					if DEBUG_FORTH_WORDS_KEY 
1f6d						DMARK "BNG" 
1f6d f5				push af  
1f6e 3a 82 1f			ld a, (.dmark)  
1f71 32 77 fb			ld (debug_mark),a  
1f74 3a 83 1f			ld a, (.dmark+1)  
1f77 32 78 fb			ld (debug_mark+1),a  
1f7a 3a 84 1f			ld a, (.dmark+2)  
1f7d 32 79 fb			ld (debug_mark+2),a  
1f80 18 03			jr .pastdmark  
1f82 ..			.dmark: db "BNG"  
1f85 f1			.pastdmark: pop af  
1f86			endm  
# End of macro DMARK
1f86						CALLMONITOR 
1f86 cd 04 13			call break_point_state  
1f89				endm  
# End of macro CALLMONITOR
1f89					endif 
1f89			 
1f89			.storebyteat:		 
1f89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f89 cd 29 19			call macro_dsp_valuehl 
1f8c				endm 
# End of macro FORTH_DSP_VALUEHL
1f8c					 
1f8c e5					push hl 
1f8d				 
1f8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f8d cd a9 19			call macro_forth_dsp_pop 
1f90				endm 
# End of macro FORTH_DSP_POP
1f90			 
1f90					; get byte to poke 
1f90			 
1f90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f90 cd 29 19			call macro_dsp_valuehl 
1f93				endm 
# End of macro FORTH_DSP_VALUEHL
1f93 e5					push hl 
1f94			 
1f94			 
1f94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f94 cd a9 19			call macro_forth_dsp_pop 
1f97				endm 
# End of macro FORTH_DSP_POP
1f97			 
1f97			 
1f97 d1					pop de 
1f98 e1					pop hl 
1f99			 
1f99 73					ld (hl),e 
1f9a			 
1f9a			 
1f9a					NEXTW 
1f9a c3 63 1a			jp macro_next 
1f9d				endm 
# End of macro NEXTW
1f9d			.CBANG: 
1f9d				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
1f9d 22				db WORD_SYS_CORE+OPCODE_CBANG             
1f9e c6 1f			dw .SCALL            
1fa0 03				db 2 + 1 
1fa1 .. 00			db "C!",0              
1fa4				endm 
# End of macro CWHEAD
1fa4			; | C!  ( x w -- ) Store x at address w  | DONE 
1fa4					if DEBUG_FORTH_WORDS_KEY 
1fa4						DMARK "CBA" 
1fa4 f5				push af  
1fa5 3a b9 1f			ld a, (.dmark)  
1fa8 32 77 fb			ld (debug_mark),a  
1fab 3a ba 1f			ld a, (.dmark+1)  
1fae 32 78 fb			ld (debug_mark+1),a  
1fb1 3a bb 1f			ld a, (.dmark+2)  
1fb4 32 79 fb			ld (debug_mark+2),a  
1fb7 18 03			jr .pastdmark  
1fb9 ..			.dmark: db "CBA"  
1fbc f1			.pastdmark: pop af  
1fbd			endm  
# End of macro DMARK
1fbd						CALLMONITOR 
1fbd cd 04 13			call break_point_state  
1fc0				endm  
# End of macro CALLMONITOR
1fc0					endif 
1fc0 c3 89 1f				jp .storebyteat 
1fc3					NEXTW 
1fc3 c3 63 1a			jp macro_next 
1fc6				endm 
# End of macro NEXTW
1fc6			.SCALL: 
1fc6				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
1fc6 23				db WORD_SYS_CORE+OPCODE_SCALL             
1fc7 fa 1f			dw .DEPTH            
1fc9 05				db 4 + 1 
1fca .. 00			db "CALL",0              
1fcf				endm 
# End of macro CWHEAD
1fcf			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
1fcf					if DEBUG_FORTH_WORDS_KEY 
1fcf						DMARK "CLL" 
1fcf f5				push af  
1fd0 3a e4 1f			ld a, (.dmark)  
1fd3 32 77 fb			ld (debug_mark),a  
1fd6 3a e5 1f			ld a, (.dmark+1)  
1fd9 32 78 fb			ld (debug_mark+1),a  
1fdc 3a e6 1f			ld a, (.dmark+2)  
1fdf 32 79 fb			ld (debug_mark+2),a  
1fe2 18 03			jr .pastdmark  
1fe4 ..			.dmark: db "CLL"  
1fe7 f1			.pastdmark: pop af  
1fe8			endm  
# End of macro DMARK
1fe8						CALLMONITOR 
1fe8 cd 04 13			call break_point_state  
1feb				endm  
# End of macro CALLMONITOR
1feb					endif 
1feb			 
1feb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1feb cd 29 19			call macro_dsp_valuehl 
1fee				endm 
# End of macro FORTH_DSP_VALUEHL
1fee			 
1fee			;		push hl 
1fee			 
1fee					; destroy value TOS 
1fee			 
1fee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1fee cd a9 19			call macro_forth_dsp_pop 
1ff1				endm 
# End of macro FORTH_DSP_POP
1ff1			 
1ff1						 
1ff1			;		pop hl 
1ff1			 
1ff1					; how to do a call with hl???? save SP? 
1ff1 cd 0c 1a				call forth_call_hl 
1ff4			 
1ff4			 
1ff4					; TODO push value back onto stack for another op etc 
1ff4			 
1ff4 cd 8e 18				call forth_push_numhl 
1ff7					NEXTW 
1ff7 c3 63 1a			jp macro_next 
1ffa				endm 
# End of macro NEXTW
1ffa			.DEPTH: 
1ffa				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
1ffa 24				db WORD_SYS_CORE+OPCODE_DEPTH             
1ffb 37 20			dw .OVER            
1ffd 06				db 5 + 1 
1ffe .. 00			db "DEPTH",0              
2004				endm 
# End of macro CWHEAD
2004			; | DEPTH ( -- u ) Push count of stack | DONE 
2004					; take current TOS and remove from base value div by two to get count 
2004					if DEBUG_FORTH_WORDS_KEY 
2004						DMARK "DEP" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 77 fb			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 78 fb			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 79 fb			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "DEP"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d						CALLMONITOR 
201d cd 04 13			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020					endif 
2020			 
2020			 
2020 2a 1f f8			ld hl, (cli_data_sp) 
2023 11 99 f3			ld de, cli_data_stack 
2026 ed 52			sbc hl,de 
2028				 
2028				; div by size of stack item 
2028			 
2028 5d				ld e,l 
2029 0e 03			ld c, 3 
202b cd a6 0a			call Div8 
202e			 
202e 6f				ld l,a 
202f 26 00			ld h,0 
2031			 
2031				;srl h 
2031				;rr l 
2031			 
2031 cd 8e 18				call forth_push_numhl 
2034					NEXTW 
2034 c3 63 1a			jp macro_next 
2037				endm 
# End of macro NEXTW
2037			.OVER: 
2037				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2037 42				db WORD_SYS_CORE+46             
2038 7e 20			dw .PAUSE            
203a 05				db 4 + 1 
203b .. 00			db "OVER",0              
2040				endm 
# End of macro CWHEAD
2040			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2040					if DEBUG_FORTH_WORDS_KEY 
2040						DMARK "OVR" 
2040 f5				push af  
2041 3a 55 20			ld a, (.dmark)  
2044 32 77 fb			ld (debug_mark),a  
2047 3a 56 20			ld a, (.dmark+1)  
204a 32 78 fb			ld (debug_mark+1),a  
204d 3a 57 20			ld a, (.dmark+2)  
2050 32 79 fb			ld (debug_mark+2),a  
2053 18 03			jr .pastdmark  
2055 ..			.dmark: db "OVR"  
2058 f1			.pastdmark: pop af  
2059			endm  
# End of macro DMARK
2059						CALLMONITOR 
2059 cd 04 13			call break_point_state  
205c				endm  
# End of macro CALLMONITOR
205c					endif 
205c			 
205c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
205c cd 29 19			call macro_dsp_valuehl 
205f				endm 
# End of macro FORTH_DSP_VALUEHL
205f e5					push hl    ; n2 
2060					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2060 cd a9 19			call macro_forth_dsp_pop 
2063				endm 
# End of macro FORTH_DSP_POP
2063			 
2063					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2063 cd 29 19			call macro_dsp_valuehl 
2066				endm 
# End of macro FORTH_DSP_VALUEHL
2066 e5					push hl    ; n1 
2067					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2067 cd a9 19			call macro_forth_dsp_pop 
206a				endm 
# End of macro FORTH_DSP_POP
206a			 
206a d1					pop de     ; n1 
206b e1					pop hl     ; n2 
206c			 
206c d5					push de 
206d e5					push hl 
206e d5					push de 
206f			 
206f					; push back  
206f			 
206f e1					pop hl 
2070 cd 8e 18				call forth_push_numhl 
2073 e1					pop hl 
2074 cd 8e 18				call forth_push_numhl 
2077 e1					pop hl 
2078 cd 8e 18				call forth_push_numhl 
207b					NEXTW 
207b c3 63 1a			jp macro_next 
207e				endm 
# End of macro NEXTW
207e			 
207e			.PAUSE: 
207e				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
207e 43				db WORD_SYS_CORE+47             
207f b3 20			dw .PAUSES            
2081 08				db 7 + 1 
2082 .. 00			db "PAUSEMS",0              
208a				endm 
# End of macro CWHEAD
208a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
208a					if DEBUG_FORTH_WORDS_KEY 
208a						DMARK "PMS" 
208a f5				push af  
208b 3a 9f 20			ld a, (.dmark)  
208e 32 77 fb			ld (debug_mark),a  
2091 3a a0 20			ld a, (.dmark+1)  
2094 32 78 fb			ld (debug_mark+1),a  
2097 3a a1 20			ld a, (.dmark+2)  
209a 32 79 fb			ld (debug_mark+2),a  
209d 18 03			jr .pastdmark  
209f ..			.dmark: db "PMS"  
20a2 f1			.pastdmark: pop af  
20a3			endm  
# End of macro DMARK
20a3						CALLMONITOR 
20a3 cd 04 13			call break_point_state  
20a6				endm  
# End of macro CALLMONITOR
20a6					endif 
20a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20a6 cd 29 19			call macro_dsp_valuehl 
20a9				endm 
# End of macro FORTH_DSP_VALUEHL
20a9			;		push hl    ; n2 
20a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20a9 cd a9 19			call macro_forth_dsp_pop 
20ac				endm 
# End of macro FORTH_DSP_POP
20ac			;		pop hl 
20ac			 
20ac 7d					ld a, l 
20ad cd 26 09				call aDelayInMS 
20b0				       NEXTW 
20b0 c3 63 1a			jp macro_next 
20b3				endm 
# End of macro NEXTW
20b3			.PAUSES:  
20b3				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
20b3 44				db WORD_SYS_CORE+48             
20b4 ea 20			dw .ROT            
20b6 06				db 5 + 1 
20b7 .. 00			db "PAUSE",0              
20bd				endm 
# End of macro CWHEAD
20bd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
20bd					if DEBUG_FORTH_WORDS_KEY 
20bd						DMARK "PAU" 
20bd f5				push af  
20be 3a d2 20			ld a, (.dmark)  
20c1 32 77 fb			ld (debug_mark),a  
20c4 3a d3 20			ld a, (.dmark+1)  
20c7 32 78 fb			ld (debug_mark+1),a  
20ca 3a d4 20			ld a, (.dmark+2)  
20cd 32 79 fb			ld (debug_mark+2),a  
20d0 18 03			jr .pastdmark  
20d2 ..			.dmark: db "PAU"  
20d5 f1			.pastdmark: pop af  
20d6			endm  
# End of macro DMARK
20d6						CALLMONITOR 
20d6 cd 04 13			call break_point_state  
20d9				endm  
# End of macro CALLMONITOR
20d9					endif 
20d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20d9 cd 29 19			call macro_dsp_valuehl 
20dc				endm 
# End of macro FORTH_DSP_VALUEHL
20dc			;		push hl    ; n2 
20dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20dc cd a9 19			call macro_forth_dsp_pop 
20df				endm 
# End of macro FORTH_DSP_POP
20df			;		pop hl 
20df 45					ld b, l 
20e0					if DEBUG_FORTH_WORDS 
20e0						DMARK "PAU" 
20e0						CALLMONITOR 
20e0					endif 
20e0 c5			.pauses1:	push bc 
20e1 cd 41 09				call delay1s 
20e4 c1					pop bc 
20e5					if DEBUG_FORTH_WORDS 
20e5						DMARK "PA1" 
20e5						CALLMONITOR 
20e5					endif 
20e5 10 f9				djnz .pauses1 
20e7			 
20e7				       NEXTW 
20e7 c3 63 1a			jp macro_next 
20ea				endm 
# End of macro NEXTW
20ea			.ROT: 
20ea				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
20ea 45				db WORD_SYS_CORE+49             
20eb 38 21			dw .UWORDS            
20ed 04				db 3 + 1 
20ee .. 00			db "ROT",0              
20f2				endm 
# End of macro CWHEAD
20f2			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
20f2					if DEBUG_FORTH_WORDS_KEY 
20f2						DMARK "ROT" 
20f2 f5				push af  
20f3 3a 07 21			ld a, (.dmark)  
20f6 32 77 fb			ld (debug_mark),a  
20f9 3a 08 21			ld a, (.dmark+1)  
20fc 32 78 fb			ld (debug_mark+1),a  
20ff 3a 09 21			ld a, (.dmark+2)  
2102 32 79 fb			ld (debug_mark+2),a  
2105 18 03			jr .pastdmark  
2107 ..			.dmark: db "ROT"  
210a f1			.pastdmark: pop af  
210b			endm  
# End of macro DMARK
210b						CALLMONITOR 
210b cd 04 13			call break_point_state  
210e				endm  
# End of macro CALLMONITOR
210e					endif 
210e			 
210e					FORTH_DSP_VALUEHL 
210e cd 29 19			call macro_dsp_valuehl 
2111				endm 
# End of macro FORTH_DSP_VALUEHL
2111 e5					push hl    ; u3  
2112			 
2112					FORTH_DSP_POP 
2112 cd a9 19			call macro_forth_dsp_pop 
2115				endm 
# End of macro FORTH_DSP_POP
2115			   
2115					FORTH_DSP_VALUEHL 
2115 cd 29 19			call macro_dsp_valuehl 
2118				endm 
# End of macro FORTH_DSP_VALUEHL
2118 e5					push hl     ; u2 
2119			 
2119					FORTH_DSP_POP 
2119 cd a9 19			call macro_forth_dsp_pop 
211c				endm 
# End of macro FORTH_DSP_POP
211c			 
211c					FORTH_DSP_VALUEHL 
211c cd 29 19			call macro_dsp_valuehl 
211f				endm 
# End of macro FORTH_DSP_VALUEHL
211f e5					push hl     ; u1 
2120			 
2120					FORTH_DSP_POP 
2120 cd a9 19			call macro_forth_dsp_pop 
2123				endm 
# End of macro FORTH_DSP_POP
2123			 
2123 c1					pop bc      ; u1 
2124 e1					pop hl      ; u2 
2125 d1					pop de      ; u3 
2126			 
2126			 
2126 c5					push bc 
2127 d5					push de 
2128 e5					push hl 
2129			 
2129			 
2129 e1					pop hl 
212a cd 8e 18				call forth_push_numhl 
212d			 
212d e1					pop hl 
212e cd 8e 18				call forth_push_numhl 
2131			 
2131 e1					pop hl 
2132 cd 8e 18				call forth_push_numhl 
2135					 
2135			 
2135			 
2135			 
2135			 
2135			 
2135				       NEXTW 
2135 c3 63 1a			jp macro_next 
2138				endm 
# End of macro NEXTW
2138			 
2138			.UWORDS: 
2138				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2138 50				db WORD_SYS_CORE+60             
2139 8a 21			dw .BP            
213b 07				db 6 + 1 
213c .. 00			db "UWORDS",0              
2143				endm 
# End of macro CWHEAD
2143			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2143			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2143			; | | Following the count are the individual words. 
2143			; | | 
2143			; | | e.g. UWORDS 
2143			; | | BOX DIRLIST 2 
2143			; | |  
2143			; | | Can be used to save the words to storage via: 
2143			; | | UWORDS $01 DO $01 APPEND LOOP 
2143				if DEBUG_FORTH_WORDS_KEY 
2143					DMARK "UWR" 
2143 f5				push af  
2144 3a 58 21			ld a, (.dmark)  
2147 32 77 fb			ld (debug_mark),a  
214a 3a 59 21			ld a, (.dmark+1)  
214d 32 78 fb			ld (debug_mark+1),a  
2150 3a 5a 21			ld a, (.dmark+2)  
2153 32 79 fb			ld (debug_mark+2),a  
2156 18 03			jr .pastdmark  
2158 ..			.dmark: db "UWR"  
215b f1			.pastdmark: pop af  
215c			endm  
# End of macro DMARK
215c					CALLMONITOR 
215c cd 04 13			call break_point_state  
215f				endm  
# End of macro CALLMONITOR
215f				endif 
215f 21 00 80				ld hl, baseram 
2162					;ld hl, baseusermem 
2162 01 00 00				ld bc, 0    ; start a counter 
2165			 
2165				; skip dict stub 
2165			 
2165 cd b4 1b				call forth_tok_next 
2168			 
2168			 
2168			; while we have words to look for 
2168			 
2168 7e			.douscan:	ld a, (hl)      
2169				if DEBUG_FORTH_WORDS 
2169					DMARK "UWs" 
2169					CALLMONITOR 
2169				endif 
2169 fe 00				cp WORD_SYS_END 
216b 28 15				jr z, .udone 
216d fe 01				cp WORD_SYS_UWORD 
216f 20 0c				jr nz, .nuword 
2171			 
2171				if DEBUG_FORTH_WORDS 
2171					DMARK "UWu" 
2171					CALLMONITOR 
2171				endif 
2171					; we have a uword so push its name to the stack 
2171			 
2171 e5				   	push hl  ; save so we can move to next dict block 
2172			 
2172					; skip opcode 
2172 23					inc hl  
2173					; skip next ptr 
2173 23					inc hl  
2174 23					inc hl 
2175					; skip len 
2175 23					inc hl 
2176				if DEBUG_FORTH_WORDS 
2176					DMARK "UWt" 
2176					CALLMONITOR 
2176				endif 
2176 03					inc bc 
2177			 
2177 c5					push bc 
2178 cd a0 18				call forth_push_str 
217b c1					pop bc 
217c			 
217c e1					pop hl 	 
217d			 
217d cd b4 1b		.nuword:	call forth_tok_next 
2180 18 e6				jr .douscan  
2182			 
2182			.udone:		 ; push count of uwords found 
2182 c5					push bc 
2183 e1					pop hl 
2184			 
2184				if DEBUG_FORTH_WORDS 
2184					DMARK "UWc" 
2184					CALLMONITOR 
2184				endif 
2184 cd 8e 18				call forth_push_numhl 
2187			 
2187			 
2187				       NEXTW 
2187 c3 63 1a			jp macro_next 
218a				endm 
# End of macro NEXTW
218a			 
218a			.BP: 
218a				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
218a 54				db WORD_SYS_CORE+64             
218b c0 21			dw .MONITOR            
218d 03				db 2 + 1 
218e .. 00			db "BP",0              
2191				endm 
# End of macro CWHEAD
2191			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2191			; | | $00 Will enable the break points within specific code paths 
2191			; | | $01 Will disable break points 
2191			; | |  
2191			; | | By default break points are off. Either the above can be used to enable them 
2191			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2191			; | | and on release of the pressed key a message will be disaplayed to notify 
2191			; | | that break points are enabled. Pressing any key will then continue boot process. 
2191					; get byte count 
2191					if DEBUG_FORTH_WORDS_KEY 
2191						DMARK "BP." 
2191 f5				push af  
2192 3a a6 21			ld a, (.dmark)  
2195 32 77 fb			ld (debug_mark),a  
2198 3a a7 21			ld a, (.dmark+1)  
219b 32 78 fb			ld (debug_mark+1),a  
219e 3a a8 21			ld a, (.dmark+2)  
21a1 32 79 fb			ld (debug_mark+2),a  
21a4 18 03			jr .pastdmark  
21a6 ..			.dmark: db "BP."  
21a9 f1			.pastdmark: pop af  
21aa			endm  
# End of macro DMARK
21aa						CALLMONITOR 
21aa cd 04 13			call break_point_state  
21ad				endm  
# End of macro CALLMONITOR
21ad					endif 
21ad			 
21ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21ad cd 29 19			call macro_dsp_valuehl 
21b0				endm 
# End of macro FORTH_DSP_VALUEHL
21b0			 
21b0			;		push hl 
21b0			 
21b0					; destroy value TOS 
21b0			 
21b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21b0 cd a9 19			call macro_forth_dsp_pop 
21b3				endm 
# End of macro FORTH_DSP_POP
21b3			 
21b3			;		pop hl 
21b3			 
21b3 3e 00				ld a,0 
21b5 bd					cp l 
21b6 28 02				jr z, .bpset 
21b8 3e 2a				ld a, '*' 
21ba			 
21ba 32 31 ee		.bpset:		ld (os_view_disable), a 
21bd			 
21bd			 
21bd					NEXTW 
21bd c3 63 1a			jp macro_next 
21c0				endm 
# End of macro NEXTW
21c0			 
21c0			 
21c0			.MONITOR: 
21c0				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
21c0 55				db WORD_SYS_CORE+65             
21c1 f3 21			dw .MALLOC            
21c3 08				db 7 + 1 
21c4 .. 00			db "MONITOR",0              
21cc				endm 
# End of macro CWHEAD
21cc			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
21cc			; | | At start the current various registers will be displayed with contents. 
21cc			; | | Top right corner will show the most recent debug marker seen. 
21cc			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
21cc			; | | and the return stack pointer (RSP). 
21cc			; | | Pressing: 
21cc			; | |    1 - Initial screen 
21cc			; | |    2 - Display a data dump of HL 
21cc			; | |    3 - Display a data dump of DE 
21cc			; | |    4 - Display a data dump of BC 
21cc			; | |    5 - Display a data dump of HL 
21cc			; | |    6 - Display a data dump of DSP 
21cc			; | |    7 - Display a data dump of RSP 
21cc			; | |    8 - Display a data dump of what is at DSP 
21cc			; | |    9 - Display a data dump of what is at RSP 
21cc			; | |    0 - Exit monitor and continue running. This will also enable break points 
21cc			; | |    * - Disable break points 
21cc			; | |    # - Enter traditional monitor mode 
21cc			; | | 
21cc			; | | Monitor Mode 
21cc			; | | ------------ 
21cc			; | | A prompt of '>' will be shown for various commands: 
21cc			; | |    D xxxx - Display a data dump starting from hex address xxxx 
21cc			; | |    C - Continue display a data dump from the last set address 
21cc			; | |    M xxxx - Set start of memory edit at address xx 
21cc			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
21cc			; | |    Q - Return to previous 
21cc					if DEBUG_FORTH_WORDS_KEY 
21cc						DMARK "MON" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 77 fb			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 78 fb			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 79 fb			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db "MON"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5						CALLMONITOR 
21e5 cd 04 13			call break_point_state  
21e8				endm  
# End of macro CALLMONITOR
21e8					endif 
21e8 3e 00				ld a, 0 
21ea 32 31 ee				ld (os_view_disable), a 
21ed			 
21ed					CALLMONITOR 
21ed cd 04 13			call break_point_state  
21f0				endm  
# End of macro CALLMONITOR
21f0			 
21f0			;	call monitor 
21f0			 
21f0					NEXTW 
21f0 c3 63 1a			jp macro_next 
21f3				endm 
# End of macro NEXTW
21f3			 
21f3			 
21f3			.MALLOC: 
21f3				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
21f3 56				db WORD_SYS_CORE+66             
21f4 1c 22			dw .MALLOC2            
21f6 06				db 5 + 1 
21f7 .. 00			db "ALLOT",0              
21fd				endm 
# End of macro CWHEAD
21fd			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
21fd					if DEBUG_FORTH_WORDS_KEY 
21fd						DMARK "ALL" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 77 fb			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 78 fb			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 79 fb			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "ALL"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216						CALLMONITOR 
2216 cd 04 13			call break_point_state  
2219				endm  
# End of macro CALLMONITOR
2219					endif 
2219 c3 43 22				jp .mallocc 
221c			.MALLOC2: 
221c				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
221c 56				db WORD_SYS_CORE+66             
221d 5a 22			dw .FREE            
221f 07				db 6 + 1 
2220 .. 00			db "MALLOC",0              
2227				endm 
# End of macro CWHEAD
2227			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2227					; get byte count 
2227					if DEBUG_FORTH_WORDS_KEY 
2227						DMARK "MAL" 
2227 f5				push af  
2228 3a 3c 22			ld a, (.dmark)  
222b 32 77 fb			ld (debug_mark),a  
222e 3a 3d 22			ld a, (.dmark+1)  
2231 32 78 fb			ld (debug_mark+1),a  
2234 3a 3e 22			ld a, (.dmark+2)  
2237 32 79 fb			ld (debug_mark+2),a  
223a 18 03			jr .pastdmark  
223c ..			.dmark: db "MAL"  
223f f1			.pastdmark: pop af  
2240			endm  
# End of macro DMARK
2240						CALLMONITOR 
2240 cd 04 13			call break_point_state  
2243				endm  
# End of macro CALLMONITOR
2243					endif 
2243			.mallocc: 
2243					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2243 cd 29 19			call macro_dsp_valuehl 
2246				endm 
# End of macro FORTH_DSP_VALUEHL
2246			 
2246			;		push hl 
2246			 
2246					; destroy value TOS 
2246			 
2246					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2246 cd a9 19			call macro_forth_dsp_pop 
2249				endm 
# End of macro FORTH_DSP_POP
2249			 
2249			;		pop hl 
2249 cd dd 0f				call malloc 
224c				if DEBUG_FORTH_MALLOC_GUARD 
224c f5					push af 
224d cd 3f 0b				call ishlzero 
2250			;		ld a, l 
2250			;		add h 
2250			;		cp 0 
2250 f1					pop af 
2251					 
2251 cc 8d 3f				call z,malloc_error 
2254				endif 
2254			 
2254 cd 8e 18				call forth_push_numhl 
2257					NEXTW 
2257 c3 63 1a			jp macro_next 
225a				endm 
# End of macro NEXTW
225a			 
225a			.FREE: 
225a				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
225a 57				db WORD_SYS_CORE+67             
225b 8b 22			dw .LIST            
225d 05				db 4 + 1 
225e .. 00			db "FREE",0              
2263				endm 
# End of macro CWHEAD
2263			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2263					if DEBUG_FORTH_WORDS_KEY 
2263						DMARK "FRE" 
2263 f5				push af  
2264 3a 78 22			ld a, (.dmark)  
2267 32 77 fb			ld (debug_mark),a  
226a 3a 79 22			ld a, (.dmark+1)  
226d 32 78 fb			ld (debug_mark+1),a  
2270 3a 7a 22			ld a, (.dmark+2)  
2273 32 79 fb			ld (debug_mark+2),a  
2276 18 03			jr .pastdmark  
2278 ..			.dmark: db "FRE"  
227b f1			.pastdmark: pop af  
227c			endm  
# End of macro DMARK
227c						CALLMONITOR 
227c cd 04 13			call break_point_state  
227f				endm  
# End of macro CALLMONITOR
227f					endif 
227f					; get address 
227f			 
227f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
227f cd 29 19			call macro_dsp_valuehl 
2282				endm 
# End of macro FORTH_DSP_VALUEHL
2282			 
2282			;		push hl 
2282			 
2282					; destroy value TOS 
2282			 
2282					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2282 cd a9 19			call macro_forth_dsp_pop 
2285				endm 
# End of macro FORTH_DSP_POP
2285			 
2285			;		pop hl 
2285			if FORTH_ENABLE_MALLOCFREE 
2285 cd a7 10				call free 
2288			endif 
2288					NEXTW 
2288 c3 63 1a			jp macro_next 
228b				endm 
# End of macro NEXTW
228b			.LIST: 
228b				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
228b 5c				db WORD_SYS_CORE+72             
228c 36 23			dw .FORGET            
228e 05				db 4 + 1 
228f .. 00			db "LIST",0              
2294				endm 
# End of macro CWHEAD
2294			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2294			; | | The quoted word must be in upper case. 
2294				if DEBUG_FORTH_WORDS_KEY 
2294					DMARK "LST" 
2294 f5				push af  
2295 3a a9 22			ld a, (.dmark)  
2298 32 77 fb			ld (debug_mark),a  
229b 3a aa 22			ld a, (.dmark+1)  
229e 32 78 fb			ld (debug_mark+1),a  
22a1 3a ab 22			ld a, (.dmark+2)  
22a4 32 79 fb			ld (debug_mark+2),a  
22a7 18 03			jr .pastdmark  
22a9 ..			.dmark: db "LST"  
22ac f1			.pastdmark: pop af  
22ad			endm  
# End of macro DMARK
22ad					CALLMONITOR 
22ad cd 04 13			call break_point_state  
22b0				endm  
# End of macro CALLMONITOR
22b0				endif 
22b0			 
22b0					FORTH_DSP_VALUEHL 
22b0 cd 29 19			call macro_dsp_valuehl 
22b3				endm 
# End of macro FORTH_DSP_VALUEHL
22b3			 
22b3 e5					push hl 
22b4 c1					pop bc 
22b5			 
22b5			; Start format of scratch string 
22b5			 
22b5 21 32 ee				ld hl, scratch 
22b8			 
22b8 3e 3a				ld a, ':' 
22ba 77					ld (hl),a 
22bb 23					inc hl 
22bc 3e 20				ld a, ' ' 
22be 77					ld (hl), a 
22bf			 
22bf					; Get ptr to the word we need to look up 
22bf			 
22bf			;		FORTH_DSP_VALUEHL 
22bf					;v5 FORTH_DSP_VALUE 
22bf				; TODO type check 
22bf			;		inc hl    ; Skip type check  
22bf			;		push hl 
22bf			;		ex de, hl    ; put into DE 
22bf			 
22bf			 
22bf 21 00 80				ld hl, baseram 
22c2					;ld hl, baseusermem 
22c2			 
22c2 e5			push hl   ; sacreifical push 
22c3			 
22c3			.ldouscanm: 
22c3 e1				pop hl 
22c4			.ldouscan: 
22c4				if DEBUG_FORTH_WORDS 
22c4					DMARK "LSs" 
22c4					CALLMONITOR 
22c4				endif 
22c4				; skip dict stub 
22c4 cd b4 1b				call forth_tok_next 
22c7			 
22c7			 
22c7			; while we have words to look for 
22c7			 
22c7 7e				ld a, (hl)      
22c8				if DEBUG_FORTH_WORDS 
22c8					DMARK "LSk" 
22c8					CALLMONITOR 
22c8				endif 
22c8 fe 00				cp WORD_SYS_END 
22ca ca 1d 23				jp z, .lunotfound 
22cd fe 01				cp WORD_SYS_UWORD 
22cf c2 c4 22				jp nz, .ldouscan 
22d2			 
22d2				if DEBUG_FORTH_WORDS 
22d2					DMARK "LSu" 
22d2					CALLMONITOR 
22d2				endif 
22d2			 
22d2					; found a uword but is it the one we want... 
22d2			 
22d2 c5					push bc     ; uword to find is on bc 
22d3 d1					pop de 
22d4			 
22d4 e5					push hl  ; to save the ptr 
22d5			 
22d5					; skip opcode 
22d5 23					inc hl  
22d6					; skip next ptr 
22d6 23					inc hl  
22d7 23					inc hl 
22d8					; skip len 
22d8 23					inc hl 
22d9			 
22d9				if DEBUG_FORTH_WORDS 
22d9					DMARK "LSc" 
22d9					CALLMONITOR 
22d9				endif 
22d9 cd ac 0f				call strcmp 
22dc c2 c3 22				jp nz, .ldouscanm 
22df				 
22df			 
22df			 
22df					; we have a uword so push its name to the stack 
22df			 
22df			;	   	push hl  ; save so we can move to next dict block 
22df e1			pop hl 
22e0			 
22e0				if DEBUG_FORTH_WORDS 
22e0					DMARK "LSm" 
22e0					CALLMONITOR 
22e0				endif 
22e0			 
22e0					; skip opcode 
22e0 23					inc hl  
22e1					; skip next ptr 
22e1 23					inc hl  
22e2 23					inc hl 
22e3					; skip len 
22e3 7e					ld a, (hl)   ; save length to add 
22e4				if DEBUG_FORTH_WORDS 
22e4					DMARK "LS2" 
22e4					CALLMONITOR 
22e4				endif 
22e4			 
22e4					; save this location 
22e4				 
22e4 e5					push hl 
22e5			 
22e5 23					inc hl 
22e6 11 34 ee				ld de, scratch+2 
22e9 4f					ld c, a 
22ea 06 00				ld b, 0 
22ec			 
22ec				if DEBUG_FORTH_WORDS 
22ec					DMARK "LSn" 
22ec					CALLMONITOR 
22ec				endif 
22ec			 
22ec					; copy uword name to scratch 
22ec			 
22ec ed b0				ldir 
22ee			 
22ee 1b					dec de 
22ef 3e 20				ld a, ' '    ; change null to space 
22f1 12					ld (de), a 
22f2			 
22f2 13					inc de 
22f3			 
22f3 d5					push de 
22f4 c1					pop bc     ; move scratch pointer to end of word name and save it 
22f5			 
22f5 e1					pop hl 
22f6 7e					ld a, (hl) 
22f7					;inc hl 
22f7					; skip word string 
22f7 cd 16 0b				call addatohl 
22fa			 
22fa 23					inc hl 
22fb			 
22fb				if DEBUG_FORTH_WORDS 
22fb					DMARK "LS3" 
22fb					CALLMONITOR 
22fb				endif 
22fb					; should now be at the start of the machine code to setup the eval of the uword 
22fb					; now locate the ptr to the string defintion 
22fb			 
22fb					; skip ld hl, 
22fb					; then load the ptr 
22fb			 
22fb 23					inc hl 
22fc 5e					ld e, (hl) 
22fd 23					inc hl 
22fe 56					ld d, (hl) 
22ff eb					ex de, hl 
2300			 
2300			 
2300				if DEBUG_FORTH_WORDS 
2300					DMARK "LSt" 
2300					CALLMONITOR 
2300				endif 
2300			 
2300			; cant push right now due to tokenised strings  
2300			 
2300			; get the destination of where to copy this definition to. 
2300			 
2300 c5					push bc 
2301 d1					pop de 
2302			 
2302 7e			.listl:         ld a,(hl) 
2303 fe 00				cp 0 
2305 28 09				jr z, .lreplsp     ; replace zero with space 
2307 fe 7f				cp FORTH_END_BUFFER 
2309 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
230b				 
230b					; just copy this char as is then 
230b			 
230b 12					ld (de), a 
230c			 
230c 23			.listnxt:	inc hl 
230d 13					inc de 
230e 18 f2				jr .listl 
2310			 
2310 3e 20		.lreplsp:	ld a,' ' 
2312 12					ld (de), a 
2313 18 f7				jr .listnxt 
2315			 
2315			; close up uword def 
2315			 
2315			.listdone: 
2315 3e 00				ld a, 0 
2317 12					ld (de), a 
2318			 
2318			; now have def so clean up and push to stack 
2318			 
2318 21 32 ee				ld hl, scratch 
231b				if DEBUG_FORTH_WORDS 
231b					DMARK "Ltp" 
231b					CALLMONITOR 
231b				endif 
231b			 
231b 18 06			jr .listpush 
231d			 
231d			;.lnuword:	pop hl 
231d			;		call forth_tok_next 
231d			;		jp .ldouscan  
231d			 
231d			.lunotfound:		  
231d			 
231d			 
231d					 
231d					FORTH_DSP_POP 
231d cd a9 19			call macro_forth_dsp_pop 
2320				endm 
# End of macro FORTH_DSP_POP
2320 21 29 23				ld hl, .luno 
2323						 
2323			 
2323			.listpush: 
2323 cd a0 18				call forth_push_str 
2326			 
2326			 
2326			 
2326					NEXTW 
2326 c3 63 1a			jp macro_next 
2329				endm 
# End of macro NEXTW
2329			 
2329 .. 00		.luno:    db "Not found",0 
2333			 
2333			 
2333			 
2333			 
2333			 
2333			;		push hl   ; save pointer to start of uword def string 
2333			; 
2333			;; look for FORTH_EOL_LINE 
2333			;		ld a, FORTH_END_BUFFER 
2333			;		call strlent 
2333			; 
2333			;		inc hl		 ; space for coln def 
2333			;		inc hl 
2333			;		inc hl          ; space for terms 
2333			;		inc hl 
2333			; 
2333			;		ld a, 20   ; TODO get actual length 
2333			;		call addatohl    ; include a random amount of room for the uword name 
2333			; 
2333			;		 
2333			;	if DEBUG_FORTH_WORDS 
2333			;		DMARK "Lt1" 
2333			;		CALLMONITOR 
2333			;	endif 
2333			;		 
2333			; 
2333			;; malloc space for the string because we cant change it 
2333			; 
2333			;		call malloc 
2333			;	if DEBUG_FORTH_MALLOC_GUARD 
2333			;		push af 
2333			;		call ishlzero 
2333			;		pop af 
2333			;		 
2333			;		call z,malloc_error 
2333			;	endif 
2333			; 
2333			;	if DEBUG_FORTH_WORDS 
2333			;		DMARK "Lt2" 
2333			;		CALLMONITOR 
2333			;	endif 
2333			;		pop de 
2333			;		push hl    ; push the malloc to release later 
2333			;		push hl   ;  push back a copy for the later stack push 
2333			;		 
2333			;; copy the string swapping out the zero terms for spaces 
2333			; 
2333			;		; de has our source 
2333			;		; hl has our dest 
2333			; 
2333			;; add the coln def 
2333			; 
2333			;		ld a, ':' 
2333			;		ld (hl), a 
2333			;		inc hl 
2333			;		ld a, ' ' 
2333			;		ld (hl), a 
2333			;		inc hl 
2333			; 
2333			;; add the uname word 
2333			;		push de   ; save our string for now 
2333			;		ex de, hl 
2333			; 
2333			;		FORTH_DSP_VALUE 
2333			;		;v5 FORTH_DSP_VALUE 
2333			; 
2333			;		inc hl   ; skip type but we know by now this is OK 
2333			; 
2333			;.luword:	ld a,(hl) 
2333			;		cp 0 
2333			;		jr z, .luword2 
2333			;		ld (de), a 
2333			;		inc de 
2333			;		inc hl 
2333			;		jr .luword 
2333			; 
2333			;.luword2:	ld a, ' ' 
2333			;		ld (de), a 
2333			;;		inc hl 
2333			;;		inc de 
2333			;;		ld (de), a 
2333			;;		inc hl 
2333			;		inc de 
2333			; 
2333			;		ex de, hl 
2333			;		pop de 
2333			;		 
2333			;		 
2333			; 
2333			;; detoken that string and copy it 
2333			; 
2333			;	if DEBUG_FORTH_WORDS 
2333			;		DMARK "Lt2" 
2333			;		CALLMONITOR 
2333			;	endif 
2333			;.ldetok:	ld a, (de) 
2333			;		cp FORTH_END_BUFFER 
2333			;		jr z, .ldetokend 
2333			;		; swap out any zero term for space 
2333			;		cp 0 
2333			;		jr nz, .ldetoknext 
2333			;		ld a, ' ' 
2333			; 
2333			;	if DEBUG_FORTH_WORDS 
2333			;		DMARK "LtS" 
2333			;		CALLMONITOR 
2333			;	endif 
2333			;.ldetoknext:	ld (hl), a 
2333			;		inc de 
2333			;		inc hl 
2333			;		jr .ldetok 
2333			; 
2333			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2333			;		ld (hl), a  
2333			; 
2333			;; free that temp malloc 
2333			; 
2333			;		pop hl    
2333			; 
2333			;	if DEBUG_FORTH_WORDS 
2333			;		DMARK "Lt4" 
2333			;		CALLMONITOR 
2333			;	endif 
2333			;		call forth_apushstrhl 
2333			; 
2333			;		; get rid of temp malloc area 
2333			; 
2333			;		pop hl 
2333			;		call free 
2333			; 
2333			;		jr .ludone 
2333			; 
2333			;.lnuword:	pop hl 
2333			;		call forth_tok_next 
2333			;		jp .ldouscan  
2333			; 
2333			;.ludone:		 pop hl 
2333			; 
2333					NEXTW 
2333 c3 63 1a			jp macro_next 
2336				endm 
# End of macro NEXTW
2336			 
2336			.FORGET: 
2336				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2336 5d				db WORD_SYS_CORE+73             
2337 93 23			dw .NOP            
2339 07				db 6 + 1 
233a .. 00			db "FORGET",0              
2341				endm 
# End of macro CWHEAD
2341			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2341			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2341			; | |  
2341			; | | e.g. "MORE" forget 
2341					if DEBUG_FORTH_WORDS_KEY 
2341						DMARK "FRG" 
2341 f5				push af  
2342 3a 56 23			ld a, (.dmark)  
2345 32 77 fb			ld (debug_mark),a  
2348 3a 57 23			ld a, (.dmark+1)  
234b 32 78 fb			ld (debug_mark+1),a  
234e 3a 58 23			ld a, (.dmark+2)  
2351 32 79 fb			ld (debug_mark+2),a  
2354 18 03			jr .pastdmark  
2356 ..			.dmark: db "FRG"  
2359 f1			.pastdmark: pop af  
235a			endm  
# End of macro DMARK
235a						CALLMONITOR 
235a cd 04 13			call break_point_state  
235d				endm  
# End of macro CALLMONITOR
235d					endif 
235d			 
235d				; find uword 
235d			        ; update start of word with "_" 
235d				; replace uword with deleted flag 
235d			 
235d			 
235d			;	if DEBUG_FORTH_WORDS 
235d			;		DMARK "FOG" 
235d			;		CALLMONITOR 
235d			;	endif 
235d			 
235d			 
235d					; Get ptr to the word we need to look up 
235d			 
235d					FORTH_DSP_VALUEHL 
235d cd 29 19			call macro_dsp_valuehl 
2360				endm 
# End of macro FORTH_DSP_VALUEHL
2360					;v5 FORTH_DSP_VALUE 
2360				; TODO type check 
2360			;		inc hl    ; Skip type check  
2360 e5					push hl 
2361 c1					pop bc 
2362			;		ex de, hl    ; put into DE 
2362			 
2362			 
2362 21 00 80				ld hl, baseram 
2365					;ld hl, baseusermem 
2365			 
2365				; skip dict stub 
2365			;	call forth_tok_next 
2365 e5			push hl   ; sacreifical push 
2366			 
2366			.fldouscanm: 
2366 e1				pop hl 
2367			.fldouscan: 
2367			;	if DEBUG_FORTH_WORDS 
2367			;		DMARK "LSs" 
2367			;		CALLMONITOR 
2367			;	endif 
2367				; skip dict stub 
2367 cd b4 1b				call forth_tok_next 
236a			 
236a			 
236a			; while we have words to look for 
236a			 
236a 7e				ld a, (hl)      
236b			;	if DEBUG_FORTH_WORDS 
236b			;		DMARK "LSk" 
236b			;		CALLMONITOR 
236b			;	endif 
236b fe 00				cp WORD_SYS_END 
236d ca 8d 23				jp z, .flunotfound 
2370 fe 01				cp WORD_SYS_UWORD 
2372 c2 67 23				jp nz, .fldouscan 
2375			 
2375			;	if DEBUG_FORTH_WORDS 
2375			;		DMARK "LSu" 
2375			;		CALLMONITOR 
2375			;	endif 
2375			 
2375					; found a uword but is it the one we want... 
2375			 
2375 c5					push bc     ; uword to find is on bc 
2376 d1					pop de 
2377			 
2377 e5					push hl  ; to save the ptr 
2378			 
2378					; skip opcode 
2378 23					inc hl  
2379					; skip next ptr 
2379 23					inc hl  
237a 23					inc hl 
237b					; skip len 
237b 23					inc hl 
237c			 
237c			;	if DEBUG_FORTH_WORDS 
237c			;		DMARK "LSc" 
237c			;		CALLMONITOR 
237c			;	endif 
237c cd ac 0f				call strcmp 
237f c2 66 23				jp nz, .fldouscanm 
2382			; 
2382			; 
2382			;; while we have words to look for 
2382			; 
2382			;.fdouscan:	ld a, (hl)      
2382			;	if DEBUG_FORTH_WORDS 
2382			;		DMARK "LSs" 
2382			;		CALLMONITOR 
2382			;	endif 
2382			;		cp WORD_SYS_END 
2382			;		jp z, .fudone 
2382			;		cp WORD_SYS_UWORD 
2382			;		jp nz, .fnuword 
2382			; 
2382			;	if DEBUG_FORTH_WORDS 
2382			;		DMARK "FGu" 
2382			;		CALLMONITOR 
2382			;	endif 
2382			; 
2382			;		; found a uword but is it the one we want... 
2382			; 
2382			; 
2382			;	        pop de   ; get back the dsp name 
2382			;		push de 
2382			; 
2382			;		push hl  ; to save the ptr 
2382			; 
2382			;		; skip opcode 
2382			;		inc hl  
2382			;		; skip next ptr 
2382			;		inc hl  
2382			;		inc hl 
2382			;		; skip len 
2382			;		inc hl 
2382			; 
2382			;	if DEBUG_FORTH_WORDS 
2382			;		DMARK "FGc" 
2382			;		CALLMONITOR 
2382			;	endif 
2382			;		call strcmp 
2382			;		jp nz, .fnuword 
2382			 
2382			 
2382 e1			pop hl 
2383			 
2383				 
2383				if DEBUG_FORTH_WORDS 
2383					DMARK "FGm" 
2383					CALLMONITOR 
2383				endif 
2383			 
2383			 
2383			 
2383					; we have a uword so push its name to the stack 
2383			 
2383			;	   	push hl  ; save so we can move to next dict block 
2383			;pop hl 
2383			 
2383					; update opcode to deleted 
2383 3e 03				ld a, WORD_SYS_DELETED 
2385 77					ld (hl), a 
2386			 
2386 23					inc hl  
2387					; skip next ptr 
2387 23					inc hl  
2388 23					inc hl 
2389					; skip len 
2389 23					inc hl 
238a			 
238a					; TODO change parser to skip deleted words but for now mark it out 
238a 3e 5f				ld a, "_" 
238c 77					ld  (hl),a 
238d			 
238d			;		jr .fudone 
238d			; 
238d			;.fnuword:	pop hl 
238d			;		call forth_tok_next 
238d			;		jp .fdouscan  
238d			 
238d			.flunotfound:		  
238d			 
238d			 
238d					 
238d					FORTH_DSP_POP 
238d cd a9 19			call macro_forth_dsp_pop 
2390				endm 
# End of macro FORTH_DSP_POP
2390			;		ld hl, .luno 
2390			;.fudone:		 pop hl 
2390					NEXTW 
2390 c3 63 1a			jp macro_next 
2393				endm 
# End of macro NEXTW
2393			.NOP: 
2393				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2393 61				db WORD_SYS_CORE+77             
2394 ba 23			dw .COMO            
2396 04				db 3 + 1 
2397 .. 00			db "NOP",0              
239b				endm 
# End of macro CWHEAD
239b			; | NOP (  --  ) Do nothing | DONE 
239b					if DEBUG_FORTH_WORDS_KEY 
239b						DMARK "NOP" 
239b f5				push af  
239c 3a b0 23			ld a, (.dmark)  
239f 32 77 fb			ld (debug_mark),a  
23a2 3a b1 23			ld a, (.dmark+1)  
23a5 32 78 fb			ld (debug_mark+1),a  
23a8 3a b2 23			ld a, (.dmark+2)  
23ab 32 79 fb			ld (debug_mark+2),a  
23ae 18 03			jr .pastdmark  
23b0 ..			.dmark: db "NOP"  
23b3 f1			.pastdmark: pop af  
23b4			endm  
# End of macro DMARK
23b4						CALLMONITOR 
23b4 cd 04 13			call break_point_state  
23b7				endm  
# End of macro CALLMONITOR
23b7					endif 
23b7				       NEXTW 
23b7 c3 63 1a			jp macro_next 
23ba				endm 
# End of macro NEXTW
23ba			.COMO: 
23ba				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
23ba 6e				db WORD_SYS_CORE+90             
23bb d4 23			dw .COMC            
23bd 02				db 1 + 1 
23be .. 00			db "(",0              
23c0				endm 
# End of macro CWHEAD
23c0			; | ( ( -- )  Start of comment | DONE 
23c0			 
23c0			 
23c0 2a 33 f1				ld hl, ( os_tok_ptr) 
23c3 11 cf 23			ld de, .closepar 
23c6					 
23c6					if DEBUG_FORTH_WORDS 
23c6						DMARK ").." 
23c6						CALLMONITOR 
23c6					endif 
23c6 cd 7e 1b			call findnexttok  
23c9			 
23c9					if DEBUG_FORTH_WORDS 
23c9						DMARK "IF5" 
23c9						CALLMONITOR 
23c9					endif 
23c9				; replace below with ) exec using tok_ptr 
23c9 22 33 f1			ld (os_tok_ptr), hl 
23cc c3 f4 1a			jp exec1 
23cf			 
23cf .. 00			.closepar:   db ")",0 
23d1			 
23d1				       NEXTW 
23d1 c3 63 1a			jp macro_next 
23d4				endm 
# End of macro NEXTW
23d4			.COMC: 
23d4				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
23d4 6f				db WORD_SYS_CORE+91             
23d5 dd 23			dw .SCRATCH            
23d7 02				db 1 + 1 
23d8 .. 00			db ")",0              
23da				endm 
# End of macro CWHEAD
23da			; | ) ( -- )  End of comment |  DONE  
23da				       NEXTW 
23da c3 63 1a			jp macro_next 
23dd				endm 
# End of macro NEXTW
23dd			 
23dd			.SCRATCH: 
23dd				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
23dd 6f				db WORD_SYS_CORE+91             
23de 18 24			dw .INC            
23e0 08				db 7 + 1 
23e1 .. 00			db "SCRATCH",0              
23e9				endm 
# End of macro CWHEAD
23e9			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
23e9			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
23e9			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
23e9			; | |  
23e9			; | | e.g.    : score $00 scratch ; 
23e9			; | |  
23e9			; | | $00 score ! 
23e9			; | | $01 score +! 
23e9			; | |  
23e9			; | | e.g.   : varword $0a scratch ;  
23e9			; | | 
23e9			; | | $8000 varword ! 
23e9					if DEBUG_FORTH_WORDS_KEY 
23e9						DMARK "SCR" 
23e9 f5				push af  
23ea 3a fe 23			ld a, (.dmark)  
23ed 32 77 fb			ld (debug_mark),a  
23f0 3a ff 23			ld a, (.dmark+1)  
23f3 32 78 fb			ld (debug_mark+1),a  
23f6 3a 00 24			ld a, (.dmark+2)  
23f9 32 79 fb			ld (debug_mark+2),a  
23fc 18 03			jr .pastdmark  
23fe ..			.dmark: db "SCR"  
2401 f1			.pastdmark: pop af  
2402			endm  
# End of macro DMARK
2402						CALLMONITOR 
2402 cd 04 13			call break_point_state  
2405				endm  
# End of macro CALLMONITOR
2405					endif 
2405			 
2405					FORTH_DSP_VALUEHL 
2405 cd 29 19			call macro_dsp_valuehl 
2408				endm 
# End of macro FORTH_DSP_VALUEHL
2408				 
2408					FORTH_DSP_POP 
2408 cd a9 19			call macro_forth_dsp_pop 
240b				endm 
# End of macro FORTH_DSP_POP
240b			 
240b 7d					ld a, l 
240c 21 57 f3				ld hl, os_var_array 
240f cd 16 0b				call addatohl 
2412			 
2412 cd 8e 18				call forth_push_numhl 
2415			 
2415				       NEXTW 
2415 c3 63 1a			jp macro_next 
2418				endm 
# End of macro NEXTW
2418			 
2418			.INC: 
2418				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2418 6f				db WORD_SYS_CORE+91             
2419 50 24			dw .DEC            
241b 03				db 2 + 1 
241c .. 00			db "+!",0              
241f				endm 
# End of macro CWHEAD
241f			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
241f					if DEBUG_FORTH_WORDS_KEY 
241f						DMARK "+s_" 
241f f5				push af  
2420 3a 34 24			ld a, (.dmark)  
2423 32 77 fb			ld (debug_mark),a  
2426 3a 35 24			ld a, (.dmark+1)  
2429 32 78 fb			ld (debug_mark+1),a  
242c 3a 36 24			ld a, (.dmark+2)  
242f 32 79 fb			ld (debug_mark+2),a  
2432 18 03			jr .pastdmark  
2434 ..			.dmark: db "+s_"  
2437 f1			.pastdmark: pop af  
2438			endm  
# End of macro DMARK
2438						CALLMONITOR 
2438 cd 04 13			call break_point_state  
243b				endm  
# End of macro CALLMONITOR
243b					endif 
243b			 
243b					FORTH_DSP_VALUEHL 
243b cd 29 19			call macro_dsp_valuehl 
243e				endm 
# End of macro FORTH_DSP_VALUEHL
243e			 
243e e5					push hl   ; save address 
243f			 
243f					FORTH_DSP_POP 
243f cd a9 19			call macro_forth_dsp_pop 
2442				endm 
# End of macro FORTH_DSP_POP
2442			 
2442					FORTH_DSP_VALUEHL 
2442 cd 29 19			call macro_dsp_valuehl 
2445				endm 
# End of macro FORTH_DSP_VALUEHL
2445			 
2445					FORTH_DSP_POP 
2445 cd a9 19			call macro_forth_dsp_pop 
2448				endm 
# End of macro FORTH_DSP_POP
2448			 
2448					; hl contains value to add to byte at a 
2448				 
2448 eb					ex de, hl 
2449			 
2449 e1					pop hl 
244a			 
244a					if DEBUG_FORTH_WORDS 
244a						DMARK "INC" 
244a						CALLMONITOR 
244a					endif 
244a			 
244a 7e					ld a,(hl) 
244b 83					add e 
244c 77					ld (hl),a 
244d			 
244d			 
244d			 
244d				       NEXTW 
244d c3 63 1a			jp macro_next 
2450				endm 
# End of macro NEXTW
2450			 
2450			.DEC: 
2450				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2450 6f				db WORD_SYS_CORE+91             
2451 85 24			dw .INC2            
2453 03				db 2 + 1 
2454 .. 00			db "-!",0              
2457				endm 
# End of macro CWHEAD
2457			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2457					if DEBUG_FORTH_WORDS_KEY 
2457						DMARK "-s_" 
2457 f5				push af  
2458 3a 6c 24			ld a, (.dmark)  
245b 32 77 fb			ld (debug_mark),a  
245e 3a 6d 24			ld a, (.dmark+1)  
2461 32 78 fb			ld (debug_mark+1),a  
2464 3a 6e 24			ld a, (.dmark+2)  
2467 32 79 fb			ld (debug_mark+2),a  
246a 18 03			jr .pastdmark  
246c ..			.dmark: db "-s_"  
246f f1			.pastdmark: pop af  
2470			endm  
# End of macro DMARK
2470						CALLMONITOR 
2470 cd 04 13			call break_point_state  
2473				endm  
# End of macro CALLMONITOR
2473					endif 
2473			 
2473					FORTH_DSP_VALUEHL 
2473 cd 29 19			call macro_dsp_valuehl 
2476				endm 
# End of macro FORTH_DSP_VALUEHL
2476			 
2476 e5					push hl   ; save address 
2477			 
2477					FORTH_DSP_POP 
2477 cd a9 19			call macro_forth_dsp_pop 
247a				endm 
# End of macro FORTH_DSP_POP
247a			 
247a					FORTH_DSP_VALUEHL 
247a cd 29 19			call macro_dsp_valuehl 
247d				endm 
# End of macro FORTH_DSP_VALUEHL
247d			 
247d					; hl contains value to add to byte at a 
247d				 
247d eb					ex de, hl 
247e			 
247e e1					pop hl 
247f			 
247f					if DEBUG_FORTH_WORDS 
247f						DMARK "DEC" 
247f						CALLMONITOR 
247f					endif 
247f			 
247f 7e					ld a,(hl) 
2480 93					sub e 
2481 77					ld (hl),a 
2482			 
2482			 
2482			 
2482				       NEXTW 
2482 c3 63 1a			jp macro_next 
2485				endm 
# End of macro NEXTW
2485			 
2485			.INC2: 
2485				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2485 6f				db WORD_SYS_CORE+91             
2486 bf 24			dw .DEC2            
2488 04				db 3 + 1 
2489 .. 00			db "+2!",0              
248d				endm 
# End of macro CWHEAD
248d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
248d			 
248d					if DEBUG_FORTH_WORDS_KEY 
248d						DMARK "+2s" 
248d f5				push af  
248e 3a a2 24			ld a, (.dmark)  
2491 32 77 fb			ld (debug_mark),a  
2494 3a a3 24			ld a, (.dmark+1)  
2497 32 78 fb			ld (debug_mark+1),a  
249a 3a a4 24			ld a, (.dmark+2)  
249d 32 79 fb			ld (debug_mark+2),a  
24a0 18 03			jr .pastdmark  
24a2 ..			.dmark: db "+2s"  
24a5 f1			.pastdmark: pop af  
24a6			endm  
# End of macro DMARK
24a6						CALLMONITOR 
24a6 cd 04 13			call break_point_state  
24a9				endm  
# End of macro CALLMONITOR
24a9					endif 
24a9			 
24a9					; Address 
24a9			 
24a9					FORTH_DSP_VALUEHL 
24a9 cd 29 19			call macro_dsp_valuehl 
24ac				endm 
# End of macro FORTH_DSP_VALUEHL
24ac			 
24ac e5					push hl    ; save address 
24ad			 
24ad					; load content into de 
24ad			 
24ad 5e					ld e,(hl) 
24ae 23					inc hl 
24af 56					ld d, (hl) 
24b0			 
24b0					if DEBUG_FORTH_WORDS 
24b0						DMARK "+2a" 
24b0						CALLMONITOR 
24b0					endif 
24b0			 
24b0					FORTH_DSP_POP 
24b0 cd a9 19			call macro_forth_dsp_pop 
24b3				endm 
# End of macro FORTH_DSP_POP
24b3			 
24b3					; Get value to add 
24b3			 
24b3					FORTH_DSP_VALUE 
24b3 cd 12 19			call macro_forth_dsp_value 
24b6				endm 
# End of macro FORTH_DSP_VALUE
24b6			 
24b6					if DEBUG_FORTH_WORDS 
24b6						DMARK "+2v" 
24b6						CALLMONITOR 
24b6					endif 
24b6			 
24b6 19					add hl, de 
24b7			 
24b7					if DEBUG_FORTH_WORDS 
24b7						DMARK "+2+" 
24b7						CALLMONITOR 
24b7					endif 
24b7			 
24b7					; move result to de 
24b7			 
24b7 eb					ex de, hl 
24b8			 
24b8					; Address 
24b8			 
24b8 e1					pop hl 
24b9			 
24b9					; save it back 
24b9			 
24b9 73					ld (hl), e 
24ba 23					inc hl 
24bb 72					ld (hl), d 
24bc			 
24bc					if DEBUG_FORTH_WORDS 
24bc						DMARK "+2e" 
24bc						CALLMONITOR 
24bc					endif 
24bc			 
24bc			 
24bc			 
24bc			 
24bc			 
24bc				       NEXTW 
24bc c3 63 1a			jp macro_next 
24bf				endm 
# End of macro NEXTW
24bf			 
24bf			.DEC2: 
24bf				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
24bf 6f				db WORD_SYS_CORE+91             
24c0 fb 24			dw .GET2            
24c2 04				db 3 + 1 
24c3 .. 00			db "-2!",0              
24c7				endm 
# End of macro CWHEAD
24c7			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
24c7			 
24c7			 
24c7					if DEBUG_FORTH_WORDS_KEY 
24c7						DMARK "-2s" 
24c7 f5				push af  
24c8 3a dc 24			ld a, (.dmark)  
24cb 32 77 fb			ld (debug_mark),a  
24ce 3a dd 24			ld a, (.dmark+1)  
24d1 32 78 fb			ld (debug_mark+1),a  
24d4 3a de 24			ld a, (.dmark+2)  
24d7 32 79 fb			ld (debug_mark+2),a  
24da 18 03			jr .pastdmark  
24dc ..			.dmark: db "-2s"  
24df f1			.pastdmark: pop af  
24e0			endm  
# End of macro DMARK
24e0						CALLMONITOR 
24e0 cd 04 13			call break_point_state  
24e3				endm  
# End of macro CALLMONITOR
24e3					endif 
24e3			 
24e3					; Address 
24e3			 
24e3					FORTH_DSP_VALUEHL 
24e3 cd 29 19			call macro_dsp_valuehl 
24e6				endm 
# End of macro FORTH_DSP_VALUEHL
24e6			 
24e6 e5					push hl    ; save address 
24e7			 
24e7					; load content into de 
24e7			 
24e7 5e					ld e,(hl) 
24e8 23					inc hl 
24e9 56					ld d, (hl) 
24ea			 
24ea					if DEBUG_FORTH_WORDS 
24ea						DMARK "-2a" 
24ea						CALLMONITOR 
24ea					endif 
24ea			 
24ea					FORTH_DSP_POP 
24ea cd a9 19			call macro_forth_dsp_pop 
24ed				endm 
# End of macro FORTH_DSP_POP
24ed			 
24ed					; Get value to remove 
24ed			 
24ed					FORTH_DSP_VALUE 
24ed cd 12 19			call macro_forth_dsp_value 
24f0				endm 
# End of macro FORTH_DSP_VALUE
24f0			 
24f0					if DEBUG_FORTH_WORDS 
24f0						DMARK "-2v" 
24f0						CALLMONITOR 
24f0					endif 
24f0			 
24f0 eb					ex de, hl 
24f1 ed 52				sbc hl, de 
24f3			 
24f3					if DEBUG_FORTH_WORDS 
24f3						DMARK "-2d" 
24f3						CALLMONITOR 
24f3					endif 
24f3			 
24f3					; move result to de 
24f3			 
24f3 eb					ex de, hl 
24f4			 
24f4					; Address 
24f4			 
24f4 e1					pop hl 
24f5			 
24f5					; save it back 
24f5			 
24f5 73					ld (hl), e 
24f6 23					inc hl 
24f7 72					ld (hl), d 
24f8			 
24f8					if DEBUG_FORTH_WORDS 
24f8						DMARK "-2e" 
24f8						CALLMONITOR 
24f8					endif 
24f8			 
24f8			 
24f8			 
24f8			 
24f8			 
24f8				       NEXTW 
24f8 c3 63 1a			jp macro_next 
24fb				endm 
# End of macro NEXTW
24fb			.GET2: 
24fb				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
24fb 6f				db WORD_SYS_CORE+91             
24fc 2b 25			dw .BANG2            
24fe 03				db 2 + 1 
24ff .. 00			db "2@",0              
2502				endm 
# End of macro CWHEAD
2502			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2502					if DEBUG_FORTH_WORDS_KEY 
2502						DMARK "2A_" 
2502 f5				push af  
2503 3a 17 25			ld a, (.dmark)  
2506 32 77 fb			ld (debug_mark),a  
2509 3a 18 25			ld a, (.dmark+1)  
250c 32 78 fb			ld (debug_mark+1),a  
250f 3a 19 25			ld a, (.dmark+2)  
2512 32 79 fb			ld (debug_mark+2),a  
2515 18 03			jr .pastdmark  
2517 ..			.dmark: db "2A_"  
251a f1			.pastdmark: pop af  
251b			endm  
# End of macro DMARK
251b						CALLMONITOR 
251b cd 04 13			call break_point_state  
251e				endm  
# End of macro CALLMONITOR
251e					endif 
251e			 
251e					FORTH_DSP_VALUEHL 
251e cd 29 19			call macro_dsp_valuehl 
2521				endm 
# End of macro FORTH_DSP_VALUEHL
2521			 
2521 5e					ld e, (hl) 
2522 23					inc hl 
2523 56					ld d, (hl) 
2524			 
2524 eb					ex de, hl 
2525			 
2525 cd 8e 18				call forth_push_numhl 
2528			 
2528				       NEXTW 
2528 c3 63 1a			jp macro_next 
252b				endm 
# End of macro NEXTW
252b			.BANG2: 
252b				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
252b 6f				db WORD_SYS_CORE+91             
252c 63 25			dw .ENDCORE            
252e 03				db 2 + 1 
252f .. 00			db "2!",0              
2532				endm 
# End of macro CWHEAD
2532			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2532					if DEBUG_FORTH_WORDS_KEY 
2532						DMARK "2S_" 
2532 f5				push af  
2533 3a 47 25			ld a, (.dmark)  
2536 32 77 fb			ld (debug_mark),a  
2539 3a 48 25			ld a, (.dmark+1)  
253c 32 78 fb			ld (debug_mark+1),a  
253f 3a 49 25			ld a, (.dmark+2)  
2542 32 79 fb			ld (debug_mark+2),a  
2545 18 03			jr .pastdmark  
2547 ..			.dmark: db "2S_"  
254a f1			.pastdmark: pop af  
254b			endm  
# End of macro DMARK
254b						CALLMONITOR 
254b cd 04 13			call break_point_state  
254e				endm  
# End of macro CALLMONITOR
254e					endif 
254e			 
254e					FORTH_DSP_VALUEHL 
254e cd 29 19			call macro_dsp_valuehl 
2551				endm 
# End of macro FORTH_DSP_VALUEHL
2551			 
2551 e5					push hl   ; save address 
2552			 
2552			 
2552					FORTH_DSP_POP 
2552 cd a9 19			call macro_forth_dsp_pop 
2555				endm 
# End of macro FORTH_DSP_POP
2555			 
2555					 
2555					FORTH_DSP_VALUEHL 
2555 cd 29 19			call macro_dsp_valuehl 
2558				endm 
# End of macro FORTH_DSP_VALUEHL
2558			 
2558					FORTH_DSP_POP 
2558 cd a9 19			call macro_forth_dsp_pop 
255b				endm 
# End of macro FORTH_DSP_POP
255b			 
255b eb					ex de, hl    ; value now in de 
255c			 
255c e1					pop hl 
255d			 
255d 73					ld (hl), e 
255e			 
255e 23					inc hl 
255f			 
255f 72					ld (hl), d 
2560			 
2560			 
2560				       NEXTW 
2560 c3 63 1a			jp macro_next 
2563				endm 
# End of macro NEXTW
2563			.ENDCORE: 
2563			 
2563			; eof 
2563			 
2563			 
# End of file forth_words_core.asm
2563			include "forth_words_flow.asm" 
2563			 
2563			; | ## Program Flow Words 
2563			 
2563			.IF: 
2563				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2563 1e				db WORD_SYS_CORE+10             
2564 b0 25			dw .THEN            
2566 03				db 2 + 1 
2567 .. 00			db "IF",0              
256a				endm 
# End of macro CWHEAD
256a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
256a			; 
256a					if DEBUG_FORTH_WORDS_KEY 
256a						DMARK "IF." 
256a f5				push af  
256b 3a 7f 25			ld a, (.dmark)  
256e 32 77 fb			ld (debug_mark),a  
2571 3a 80 25			ld a, (.dmark+1)  
2574 32 78 fb			ld (debug_mark+1),a  
2577 3a 81 25			ld a, (.dmark+2)  
257a 32 79 fb			ld (debug_mark+2),a  
257d 18 03			jr .pastdmark  
257f ..			.dmark: db "IF."  
2582 f1			.pastdmark: pop af  
2583			endm  
# End of macro DMARK
2583						CALLMONITOR 
2583 cd 04 13			call break_point_state  
2586				endm  
# End of macro CALLMONITOR
2586					endif 
2586			; eval TOS 
2586			 
2586				FORTH_DSP_VALUEHL 
2586 cd 29 19			call macro_dsp_valuehl 
2589				endm 
# End of macro FORTH_DSP_VALUEHL
2589			 
2589			;	push hl 
2589				FORTH_DSP_POP 
2589 cd a9 19			call macro_forth_dsp_pop 
258c				endm 
# End of macro FORTH_DSP_POP
258c			;	pop hl 
258c			 
258c					if DEBUG_FORTH_WORDS 
258c						DMARK "IF1" 
258c						CALLMONITOR 
258c					endif 
258c b7				or a        ; clear carry flag 
258d 11 00 00			ld de, 0 
2590 eb				ex de,hl 
2591 ed 52			sbc hl, de 
2593 c2 ad 25			jp nz, .iftrue 
2596			 
2596					if DEBUG_FORTH_WORDS 
2596						DMARK "IF2" 
2596						CALLMONITOR 
2596					endif 
2596			 
2596			; if not true then skip to THEN 
2596			 
2596				; TODO get tok_ptr 
2596				; TODO consume toks until we get to THEN 
2596			 
2596 2a 33 f1			ld hl, (os_tok_ptr) 
2599					if DEBUG_FORTH_WORDS 
2599						DMARK "IF3" 
2599						CALLMONITOR 
2599						 
2599					endif 
2599 11 a8 25			ld de, .ifthen 
259c					if DEBUG_FORTH_WORDS 
259c						DMARK "IF4" 
259c						CALLMONITOR 
259c					endif 
259c cd 7e 1b			call findnexttok  
259f			 
259f					if DEBUG_FORTH_WORDS 
259f						DMARK "IF5" 
259f						CALLMONITOR 
259f					endif 
259f				; TODO replace below with ; exec using tok_ptr 
259f 22 33 f1			ld (os_tok_ptr), hl 
25a2 c3 f4 1a			jp exec1 
25a5				NEXTW 
25a5 c3 63 1a			jp macro_next 
25a8				endm 
# End of macro NEXTW
25a8			 
25a8 .. 00		.ifthen:  db "THEN",0 
25ad			 
25ad			.iftrue:		 
25ad				; Exec next words normally 
25ad			 
25ad				; if true then exec following IF as normal 
25ad					if DEBUG_FORTH_WORDS 
25ad						DMARK "IFT" 
25ad						CALLMONITOR 
25ad					endif 
25ad			 
25ad					NEXTW 
25ad c3 63 1a			jp macro_next 
25b0				endm 
# End of macro NEXTW
25b0			.THEN: 
25b0				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
25b0 1f				db WORD_SYS_CORE+11             
25b1 d8 25			dw .ELSE            
25b3 05				db 4 + 1 
25b4 .. 00			db "THEN",0              
25b9				endm 
# End of macro CWHEAD
25b9			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
25b9					if DEBUG_FORTH_WORDS_KEY 
25b9						DMARK "THN" 
25b9 f5				push af  
25ba 3a ce 25			ld a, (.dmark)  
25bd 32 77 fb			ld (debug_mark),a  
25c0 3a cf 25			ld a, (.dmark+1)  
25c3 32 78 fb			ld (debug_mark+1),a  
25c6 3a d0 25			ld a, (.dmark+2)  
25c9 32 79 fb			ld (debug_mark+2),a  
25cc 18 03			jr .pastdmark  
25ce ..			.dmark: db "THN"  
25d1 f1			.pastdmark: pop af  
25d2			endm  
# End of macro DMARK
25d2						CALLMONITOR 
25d2 cd 04 13			call break_point_state  
25d5				endm  
# End of macro CALLMONITOR
25d5					endif 
25d5					NEXTW 
25d5 c3 63 1a			jp macro_next 
25d8				endm 
# End of macro NEXTW
25d8			.ELSE: 
25d8				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
25d8 20				db WORD_SYS_CORE+12             
25d9 00 26			dw .DO            
25db 03				db 2 + 1 
25dc .. 00			db "ELSE",0              
25e1				endm 
# End of macro CWHEAD
25e1			; | ELSE ( -- ) Not supported - does nothing | TODO 
25e1			 
25e1					if DEBUG_FORTH_WORDS_KEY 
25e1						DMARK "ELS" 
25e1 f5				push af  
25e2 3a f6 25			ld a, (.dmark)  
25e5 32 77 fb			ld (debug_mark),a  
25e8 3a f7 25			ld a, (.dmark+1)  
25eb 32 78 fb			ld (debug_mark+1),a  
25ee 3a f8 25			ld a, (.dmark+2)  
25f1 32 79 fb			ld (debug_mark+2),a  
25f4 18 03			jr .pastdmark  
25f6 ..			.dmark: db "ELS"  
25f9 f1			.pastdmark: pop af  
25fa			endm  
# End of macro DMARK
25fa						CALLMONITOR 
25fa cd 04 13			call break_point_state  
25fd				endm  
# End of macro CALLMONITOR
25fd					endif 
25fd			 
25fd			 
25fd					NEXTW 
25fd c3 63 1a			jp macro_next 
2600				endm 
# End of macro NEXTW
2600			.DO: 
2600				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2600 21				db WORD_SYS_CORE+13             
2601 47 26			dw .LOOP            
2603 03				db 2 + 1 
2604 .. 00			db "DO",0              
2607				endm 
# End of macro CWHEAD
2607			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2607			 
2607					if DEBUG_FORTH_WORDS_KEY 
2607						DMARK "DO." 
2607 f5				push af  
2608 3a 1c 26			ld a, (.dmark)  
260b 32 77 fb			ld (debug_mark),a  
260e 3a 1d 26			ld a, (.dmark+1)  
2611 32 78 fb			ld (debug_mark+1),a  
2614 3a 1e 26			ld a, (.dmark+2)  
2617 32 79 fb			ld (debug_mark+2),a  
261a 18 03			jr .pastdmark  
261c ..			.dmark: db "DO."  
261f f1			.pastdmark: pop af  
2620			endm  
# End of macro DMARK
2620						CALLMONITOR 
2620 cd 04 13			call break_point_state  
2623				endm  
# End of macro CALLMONITOR
2623					endif 
2623			;  push pc to rsp stack past the DO 
2623			 
2623 2a 33 f1				ld hl, (os_tok_ptr) 
2626 23					inc hl   ; D 
2627 23					inc hl  ; O 
2628 23					inc hl   ; null 
2629					if DEBUG_FORTH_WORDS 
2629						DMARK "DO2" 
2629						CALLMONITOR 
2629					endif 
2629					FORTH_RSP_NEXT 
2629 cd 38 18			call macro_forth_rsp_next 
262c				endm 
# End of macro FORTH_RSP_NEXT
262c					if DEBUG_FORTH_WORDS 
262c						DMARK "DO3" 
262c						CALLMONITOR 
262c					endif 
262c			 
262c					;if DEBUG_FORTH_WORDS 
262c				;		push hl 
262c			;		endif  
262c			 
262c			; get counters from data stack 
262c			 
262c			 
262c					FORTH_DSP_VALUEHL 
262c cd 29 19			call macro_dsp_valuehl 
262f				endm 
# End of macro FORTH_DSP_VALUEHL
262f e5					push hl		 ; hl now has starting counter which needs to be tos 
2630			 
2630					if DEBUG_FORTH_WORDS 
2630						DMARK "DO4" 
2630						CALLMONITOR 
2630					endif 
2630					FORTH_DSP_POP 
2630 cd a9 19			call macro_forth_dsp_pop 
2633				endm 
# End of macro FORTH_DSP_POP
2633			 
2633					if DEBUG_FORTH_WORDS 
2633						DMARK "DO5" 
2633						CALLMONITOR 
2633					endif 
2633			 
2633					FORTH_DSP_VALUEHL 
2633 cd 29 19			call macro_dsp_valuehl 
2636				endm 
# End of macro FORTH_DSP_VALUEHL
2636			;		push hl		 ; hl now has starting limit counter 
2636			 
2636					if DEBUG_FORTH_WORDS 
2636						DMARK "DO6" 
2636						CALLMONITOR 
2636					endif 
2636					FORTH_DSP_POP 
2636 cd a9 19			call macro_forth_dsp_pop 
2639				endm 
# End of macro FORTH_DSP_POP
2639			 
2639			; put counters on the loop stack 
2639			 
2639			;		pop hl			 ; limit counter 
2639 d1					pop de			; start counter 
263a			 
263a					; push limit counter 
263a			 
263a					if DEBUG_FORTH_WORDS 
263a						DMARK "DO7" 
263a						CALLMONITOR 
263a					endif 
263a					FORTH_LOOP_NEXT 
263a cd 3e 19			call macro_forth_loop_next 
263d				endm 
# End of macro FORTH_LOOP_NEXT
263d			 
263d					; push start counter 
263d			 
263d eb					ex de, hl 
263e					if DEBUG_FORTH_WORDS 
263e						DMARK "DO7" 
263e						CALLMONITOR 
263e					endif 
263e					FORTH_LOOP_NEXT 
263e cd 3e 19			call macro_forth_loop_next 
2641				endm 
# End of macro FORTH_LOOP_NEXT
2641			 
2641			 
2641					; init first round of I counter 
2641			 
2641 22 57 f1				ld (os_current_i), hl 
2644			 
2644					if DEBUG_FORTH_WORDS 
2644						DMARK "DO8" 
2644						CALLMONITOR 
2644					endif 
2644			 
2644					NEXTW 
2644 c3 63 1a			jp macro_next 
2647				endm 
# End of macro NEXTW
2647			.LOOP: 
2647				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2647 22				db WORD_SYS_CORE+14             
2648 9a 26			dw .I            
264a 05				db 4 + 1 
264b .. 00			db "LOOP",0              
2650				endm 
# End of macro CWHEAD
2650			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2650			 
2650				; pop tos as current loop count to hl 
2650			 
2650				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2650			 
2650				FORTH_LOOP_TOS 
2650 cd 55 19			call macro_forth_loop_tos 
2653				endm 
# End of macro FORTH_LOOP_TOS
2653 e5				push hl 
2654			 
2654					if DEBUG_FORTH_WORDS_KEY 
2654						DMARK "LOP" 
2654 f5				push af  
2655 3a 69 26			ld a, (.dmark)  
2658 32 77 fb			ld (debug_mark),a  
265b 3a 6a 26			ld a, (.dmark+1)  
265e 32 78 fb			ld (debug_mark+1),a  
2661 3a 6b 26			ld a, (.dmark+2)  
2664 32 79 fb			ld (debug_mark+2),a  
2667 18 03			jr .pastdmark  
2669 ..			.dmark: db "LOP"  
266c f1			.pastdmark: pop af  
266d			endm  
# End of macro DMARK
266d						CALLMONITOR 
266d cd 04 13			call break_point_state  
2670				endm  
# End of macro CALLMONITOR
2670					endif 
2670				; next item on the stack is the limit. get it 
2670			 
2670			 
2670				FORTH_LOOP_POP 
2670 cd 5f 19			call macro_forth_loop_pop 
2673				endm 
# End of macro FORTH_LOOP_POP
2673			 
2673				FORTH_LOOP_TOS 
2673 cd 55 19			call macro_forth_loop_tos 
2676				endm 
# End of macro FORTH_LOOP_TOS
2676			 
2676 d1				pop de		 ; de = i, hl = limit 
2677			 
2677					if DEBUG_FORTH_WORDS 
2677						DMARK "LP1" 
2677						CALLMONITOR 
2677					endif 
2677			 
2677				; go back to previous word 
2677			 
2677 d5				push de    ; save I for inc later 
2678			 
2678			 
2678				; get limit 
2678				;  is I at limit? 
2678			 
2678			 
2678					if DEBUG_FORTH_WORDS 
2678						DMARK "LP1" 
2678						CALLMONITOR 
2678					endif 
2678			 
2678 ed 52			sbc hl, de 
267a			 
267a			 
267a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
267a			 
267a 20 0a				jr nz, .loopnotdone 
267c			 
267c e1				pop hl   ; get rid of saved I 
267d				FORTH_LOOP_POP     ; get rid of limit 
267d cd 5f 19			call macro_forth_loop_pop 
2680				endm 
# End of macro FORTH_LOOP_POP
2680			 
2680				FORTH_RSP_POP     ; get rid of DO ptr 
2680 cd 56 18			call macro_forth_rsp_pop 
2683				endm 
# End of macro FORTH_RSP_POP
2683			 
2683			if DEBUG_FORTH_WORDS 
2683						DMARK "LP>" 
2683				CALLMONITOR 
2683			endif 
2683			 
2683					NEXTW 
2683 c3 63 1a			jp macro_next 
2686				endm 
# End of macro NEXTW
2686				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2686			 
2686			.loopnotdone: 
2686			 
2686 e1				pop hl    ; get I 
2687 23				inc hl 
2688			 
2688			   	; save new I 
2688			 
2688			 
2688					; set I counter 
2688			 
2688 22 57 f1				ld (os_current_i), hl 
268b			 
268b					if DEBUG_FORTH_WORDS 
268b						DMARK "LPN" 
268b					CALLMONITOR 
268b					endif 
268b					 
268b				FORTH_LOOP_NEXT 
268b cd 3e 19			call macro_forth_loop_next 
268e				endm 
# End of macro FORTH_LOOP_NEXT
268e			 
268e			 
268e					if DEBUG_FORTH_WORDS 
268e						ex de,hl 
268e					endif 
268e			 
268e			;	; get DO ptr 
268e			; 
268e					if DEBUG_FORTH_WORDS 
268e						DMARK "LP7" 
268e					CALLMONITOR 
268e					endif 
268e				FORTH_RSP_TOS 
268e cd 4f 18			call macro_forth_rsp_tos 
2691				endm 
# End of macro FORTH_RSP_TOS
2691			 
2691					if DEBUG_FORTH_WORDS 
2691						DMARK "LP8" 
2691					CALLMONITOR 
2691					endif 
2691				;push hl 
2691			 
2691				; not going to DO any more 
2691				; get rid of the RSP pointer as DO will add it back in 
2691				;FORTH_RSP_POP 
2691				;pop hl 
2691			 
2691				;ld hl,(cli_ret_sp) 
2691				;ld e, (hl) 
2691				;inc hl 
2691				;ld d, (hl) 
2691				;ex de,hl 
2691 22 33 f1			ld (os_tok_ptr), hl 
2694					if DEBUG_FORTH_WORDS 
2694						DMARK "LP<" 
2694					CALLMONITOR 
2694				endif 
2694 c3 f4 1a			jp exec1 
2697			 
2697					 
2697			 
2697			 
2697					NEXTW 
2697 c3 63 1a			jp macro_next 
269a				endm 
# End of macro NEXTW
269a			.I:  
269a			 
269a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
269a 5e				db WORD_SYS_CORE+74             
269b c5 26			dw .DLOOP            
269d 02				db 1 + 1 
269e .. 00			db "I",0              
26a0				endm 
# End of macro CWHEAD
26a0			; | I ( -- ) Current loop counter | DONE 
26a0					if DEBUG_FORTH_WORDS_KEY 
26a0						DMARK "I.." 
26a0 f5				push af  
26a1 3a b5 26			ld a, (.dmark)  
26a4 32 77 fb			ld (debug_mark),a  
26a7 3a b6 26			ld a, (.dmark+1)  
26aa 32 78 fb			ld (debug_mark+1),a  
26ad 3a b7 26			ld a, (.dmark+2)  
26b0 32 79 fb			ld (debug_mark+2),a  
26b3 18 03			jr .pastdmark  
26b5 ..			.dmark: db "I.."  
26b8 f1			.pastdmark: pop af  
26b9			endm  
# End of macro DMARK
26b9						CALLMONITOR 
26b9 cd 04 13			call break_point_state  
26bc				endm  
# End of macro CALLMONITOR
26bc					endif 
26bc			 
26bc 2a 57 f1				ld hl,(os_current_i) 
26bf cd 8e 18				call forth_push_numhl 
26c2			 
26c2					NEXTW 
26c2 c3 63 1a			jp macro_next 
26c5				endm 
# End of macro NEXTW
26c5			.DLOOP: 
26c5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
26c5 5f				db WORD_SYS_CORE+75             
26c6 19 27			dw .REPEAT            
26c8 06				db 5 + 1 
26c9 .. 00			db "-LOOP",0              
26cf				endm 
# End of macro CWHEAD
26cf			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
26cf				; pop tos as current loop count to hl 
26cf					if DEBUG_FORTH_WORDS_KEY 
26cf						DMARK "-LP" 
26cf f5				push af  
26d0 3a e4 26			ld a, (.dmark)  
26d3 32 77 fb			ld (debug_mark),a  
26d6 3a e5 26			ld a, (.dmark+1)  
26d9 32 78 fb			ld (debug_mark+1),a  
26dc 3a e6 26			ld a, (.dmark+2)  
26df 32 79 fb			ld (debug_mark+2),a  
26e2 18 03			jr .pastdmark  
26e4 ..			.dmark: db "-LP"  
26e7 f1			.pastdmark: pop af  
26e8			endm  
# End of macro DMARK
26e8						CALLMONITOR 
26e8 cd 04 13			call break_point_state  
26eb				endm  
# End of macro CALLMONITOR
26eb					endif 
26eb			 
26eb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
26eb			 
26eb				FORTH_LOOP_TOS 
26eb cd 55 19			call macro_forth_loop_tos 
26ee				endm 
# End of macro FORTH_LOOP_TOS
26ee e5				push hl 
26ef			 
26ef					if DEBUG_FORTH_WORDS 
26ef						DMARK "-LP" 
26ef						CALLMONITOR 
26ef					endif 
26ef				; next item on the stack is the limit. get it 
26ef			 
26ef			 
26ef				FORTH_LOOP_POP 
26ef cd 5f 19			call macro_forth_loop_pop 
26f2				endm 
# End of macro FORTH_LOOP_POP
26f2			 
26f2				FORTH_LOOP_TOS 
26f2 cd 55 19			call macro_forth_loop_tos 
26f5				endm 
# End of macro FORTH_LOOP_TOS
26f5			 
26f5 d1				pop de		 ; de = i, hl = limit 
26f6			 
26f6					if DEBUG_FORTH_WORDS 
26f6						DMARK "-L1" 
26f6						CALLMONITOR 
26f6					endif 
26f6			 
26f6				; go back to previous word 
26f6			 
26f6 d5				push de    ; save I for inc later 
26f7			 
26f7			 
26f7				; get limit 
26f7				;  is I at limit? 
26f7			 
26f7			 
26f7					if DEBUG_FORTH_WORDS 
26f7						DMARK "-L1" 
26f7						CALLMONITOR 
26f7					endif 
26f7			 
26f7 ed 52			sbc hl, de 
26f9			 
26f9			 
26f9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
26f9			 
26f9 20 0a				jr nz, .mloopnotdone 
26fb			 
26fb e1				pop hl   ; get rid of saved I 
26fc				FORTH_LOOP_POP     ; get rid of limit 
26fc cd 5f 19			call macro_forth_loop_pop 
26ff				endm 
# End of macro FORTH_LOOP_POP
26ff			 
26ff				FORTH_RSP_POP     ; get rid of DO ptr 
26ff cd 56 18			call macro_forth_rsp_pop 
2702				endm 
# End of macro FORTH_RSP_POP
2702			 
2702			if DEBUG_FORTH_WORDS 
2702						DMARK "-L>" 
2702				CALLMONITOR 
2702			endif 
2702			 
2702					NEXTW 
2702 c3 63 1a			jp macro_next 
2705				endm 
# End of macro NEXTW
2705				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2705			 
2705			.mloopnotdone: 
2705			 
2705 e1				pop hl    ; get I 
2706 2b				dec hl 
2707			 
2707			   	; save new I 
2707			 
2707			 
2707					; set I counter 
2707			 
2707 22 57 f1				ld (os_current_i), hl 
270a			 
270a					 
270a				FORTH_LOOP_NEXT 
270a cd 3e 19			call macro_forth_loop_next 
270d				endm 
# End of macro FORTH_LOOP_NEXT
270d			 
270d			 
270d					if DEBUG_FORTH_WORDS 
270d						ex de,hl 
270d					endif 
270d			 
270d			;	; get DO ptr 
270d			; 
270d				FORTH_RSP_TOS 
270d cd 4f 18			call macro_forth_rsp_tos 
2710				endm 
# End of macro FORTH_RSP_TOS
2710			 
2710				;push hl 
2710			 
2710				; not going to DO any more 
2710				; get rid of the RSP pointer as DO will add it back in 
2710				;FORTH_RSP_POP 
2710				;pop hl 
2710			 
2710			 
2710 22 33 f1			ld (os_tok_ptr), hl 
2713					if DEBUG_FORTH_WORDS 
2713						DMARK "-L<" 
2713					CALLMONITOR 
2713				endif 
2713 c3 f4 1a			jp exec1 
2716			 
2716					 
2716			 
2716			 
2716			 
2716				NEXTW 
2716 c3 63 1a			jp macro_next 
2719				endm 
# End of macro NEXTW
2719			 
2719			 
2719			 
2719			 
2719			.REPEAT: 
2719				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
2719 71				db WORD_SYS_CORE+93             
271a 50 27			dw .UNTIL            
271c 06				db 5 + 1 
271d .. 00			db "REPEAT",0              
2724				endm 
# End of macro CWHEAD
2724			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
2724			;  push pc to rsp stack past the REPEAT 
2724					if DEBUG_FORTH_WORDS_KEY 
2724						DMARK "REP" 
2724 f5				push af  
2725 3a 39 27			ld a, (.dmark)  
2728 32 77 fb			ld (debug_mark),a  
272b 3a 3a 27			ld a, (.dmark+1)  
272e 32 78 fb			ld (debug_mark+1),a  
2731 3a 3b 27			ld a, (.dmark+2)  
2734 32 79 fb			ld (debug_mark+2),a  
2737 18 03			jr .pastdmark  
2739 ..			.dmark: db "REP"  
273c f1			.pastdmark: pop af  
273d			endm  
# End of macro DMARK
273d						CALLMONITOR 
273d cd 04 13			call break_point_state  
2740				endm  
# End of macro CALLMONITOR
2740					endif 
2740			 
2740 2a 33 f1				ld hl, (os_tok_ptr) 
2743 23					inc hl   ; R 
2744 23					inc hl  ; E 
2745 23					inc hl   ; P 
2746 23					inc hl   ; E 
2747 23					inc hl   ; A 
2748 23					inc hl   ; T 
2749 23					inc hl   ; zero 
274a					FORTH_RSP_NEXT 
274a cd 38 18			call macro_forth_rsp_next 
274d				endm 
# End of macro FORTH_RSP_NEXT
274d			 
274d			 
274d					if DEBUG_FORTH_WORDS 
274d						DMARK "REP" 
274d						;pop bc    ; TODO BUG ?????? what is this for???? 
274d						CALLMONITOR 
274d					endif 
274d			 
274d					NEXTW 
274d c3 63 1a			jp macro_next 
2750				endm 
# End of macro NEXTW
2750			;	       NEXTW 
2750			 
2750			.UNTIL: 
2750				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
2750 72				db WORD_SYS_CORE+94             
2751 93 27			dw .ENDFLOW            
2753 06				db 5 + 1 
2754 .. 00			db "UNTIL",0              
275a				endm 
# End of macro CWHEAD
275a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
275a			 
275a				; pop tos as check 
275a			 
275a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
275a			 
275a				FORTH_DSP_VALUEHL 
275a cd 29 19			call macro_dsp_valuehl 
275d				endm 
# End of macro FORTH_DSP_VALUEHL
275d			 
275d					if DEBUG_FORTH_WORDS_KEY 
275d						DMARK "UNT" 
275d f5				push af  
275e 3a 72 27			ld a, (.dmark)  
2761 32 77 fb			ld (debug_mark),a  
2764 3a 73 27			ld a, (.dmark+1)  
2767 32 78 fb			ld (debug_mark+1),a  
276a 3a 74 27			ld a, (.dmark+2)  
276d 32 79 fb			ld (debug_mark+2),a  
2770 18 03			jr .pastdmark  
2772 ..			.dmark: db "UNT"  
2775 f1			.pastdmark: pop af  
2776			endm  
# End of macro DMARK
2776						CALLMONITOR 
2776 cd 04 13			call break_point_state  
2779				endm  
# End of macro CALLMONITOR
2779					endif 
2779			 
2779			;	push hl 
2779				FORTH_DSP_POP 
2779 cd a9 19			call macro_forth_dsp_pop 
277c				endm 
# End of macro FORTH_DSP_POP
277c			 
277c			;	pop hl 
277c			 
277c				; test if true 
277c			 
277c cd 3f 0b			call ishlzero 
277f			;	ld a,l 
277f			;	add h 
277f			; 
277f			;	cp 0 
277f			 
277f 20 06			jr nz, .untilnotdone 
2781			 
2781					if DEBUG_FORTH_WORDS 
2781						DMARK "UNf" 
2781						CALLMONITOR 
2781					endif 
2781			 
2781			 
2781			 
2781				FORTH_RSP_POP     ; get rid of DO ptr 
2781 cd 56 18			call macro_forth_rsp_pop 
2784				endm 
# End of macro FORTH_RSP_POP
2784			 
2784			if DEBUG_FORTH_WORDS 
2784						DMARK "UN>" 
2784				CALLMONITOR 
2784			endif 
2784			 
2784					NEXTW 
2784 c3 63 1a			jp macro_next 
2787				endm 
# End of macro NEXTW
2787				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2787			 
2787			.untilnotdone: 
2787			 
2787			 
2787			;	; get DO ptr 
2787			; 
2787				FORTH_RSP_TOS 
2787 cd 4f 18			call macro_forth_rsp_tos 
278a				endm 
# End of macro FORTH_RSP_TOS
278a			 
278a				;push hl 
278a			 
278a				; not going to DO any more 
278a				; get rid of the RSP pointer as DO will add it back in 
278a				;FORTH_RSP_POP 
278a				;pop hl 
278a			 
278a			 
278a 22 33 f1			ld (os_tok_ptr), hl 
278d					if DEBUG_FORTH_WORDS 
278d						DMARK "UN<" 
278d					CALLMONITOR 
278d				endif 
278d c3 f4 1a			jp exec1 
2790			 
2790					 
2790			 
2790			 
2790					NEXTW 
2790 c3 63 1a			jp macro_next 
2793				endm 
# End of macro NEXTW
2793			 
2793			 
2793			.ENDFLOW: 
2793			 
2793			; eof 
2793			 
# End of file forth_words_flow.asm
2793			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
2793			include "forth_words_logic.asm" 
2793			 
2793			; | ## Logic Words 
2793			 
2793			.NOT: 
2793				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
2793 2d				db WORD_SYS_CORE+25             
2794 db 27			dw .IS            
2796 04				db 3 + 1 
2797 .. 00			db "NOT",0              
279b				endm 
# End of macro CWHEAD
279b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
279b					if DEBUG_FORTH_WORDS_KEY 
279b						DMARK "NOT" 
279b f5				push af  
279c 3a b0 27			ld a, (.dmark)  
279f 32 77 fb			ld (debug_mark),a  
27a2 3a b1 27			ld a, (.dmark+1)  
27a5 32 78 fb			ld (debug_mark+1),a  
27a8 3a b2 27			ld a, (.dmark+2)  
27ab 32 79 fb			ld (debug_mark+2),a  
27ae 18 03			jr .pastdmark  
27b0 ..			.dmark: db "NOT"  
27b3 f1			.pastdmark: pop af  
27b4			endm  
# End of macro DMARK
27b4						CALLMONITOR 
27b4 cd 04 13			call break_point_state  
27b7				endm  
# End of macro CALLMONITOR
27b7					endif 
27b7					FORTH_DSP 
27b7 cd 0e 19			call macro_forth_dsp 
27ba				endm 
# End of macro FORTH_DSP
27ba 7e					ld a,(hl)	; get type of value on TOS 
27bb fe 02				cp DS_TYPE_INUM  
27bd 28 03				jr z, .noti 
27bf					NEXTW 
27bf c3 63 1a			jp macro_next 
27c2				endm 
# End of macro NEXTW
27c2			.noti:          FORTH_DSP_VALUEHL 
27c2 cd 29 19			call macro_dsp_valuehl 
27c5				endm 
# End of macro FORTH_DSP_VALUEHL
27c5			;		push hl 
27c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c5 cd a9 19			call macro_forth_dsp_pop 
27c8				endm 
# End of macro FORTH_DSP_POP
27c8			;		pop hl 
27c8 3e 00				ld a,0 
27ca bd					cp l 
27cb 28 04				jr z, .not2t 
27cd 2e 00				ld l, 0 
27cf 18 02				jr .notip 
27d1			 
27d1 2e ff		.not2t:		ld l, 255 
27d3			 
27d3 26 00		.notip:		ld h, 0	 
27d5			 
27d5 cd 8e 18				call forth_push_numhl 
27d8					NEXTW 
27d8 c3 63 1a			jp macro_next 
27db				endm 
# End of macro NEXTW
27db			 
27db			.IS: 
27db				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
27db 2d				db WORD_SYS_CORE+25             
27dc 01 28			dw .LZERO            
27de 03				db 2 + 1 
27df .. 00			db "IS",0              
27e2				endm 
# End of macro CWHEAD
27e2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
27e2					if DEBUG_FORTH_WORDS_KEY 
27e2						DMARK "IS." 
27e2 f5				push af  
27e3 3a f7 27			ld a, (.dmark)  
27e6 32 77 fb			ld (debug_mark),a  
27e9 3a f8 27			ld a, (.dmark+1)  
27ec 32 78 fb			ld (debug_mark+1),a  
27ef 3a f9 27			ld a, (.dmark+2)  
27f2 32 79 fb			ld (debug_mark+2),a  
27f5 18 03			jr .pastdmark  
27f7 ..			.dmark: db "IS."  
27fa f1			.pastdmark: pop af  
27fb			endm  
# End of macro DMARK
27fb						CALLMONITOR 
27fb cd 04 13			call break_point_state  
27fe				endm  
# End of macro CALLMONITOR
27fe					endif 
27fe					NEXTW 
27fe c3 63 1a			jp macro_next 
2801				endm 
# End of macro NEXTW
2801			.LZERO: 
2801				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
2801 2d				db WORD_SYS_CORE+25             
2802 0b 28			dw .TZERO            
2804 03				db 2 + 1 
2805 .. 00			db "0<",0              
2808				endm 
# End of macro CWHEAD
2808			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
2808					NEXTW 
2808 c3 63 1a			jp macro_next 
280b				endm 
# End of macro NEXTW
280b			.TZERO: 
280b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
280b 2e				db WORD_SYS_CORE+26             
280c 52 28			dw .LESS            
280e 03				db 2 + 1 
280f .. 00			db "0=",0              
2812				endm 
# End of macro CWHEAD
2812			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
2812				; TODO add floating point number detection 
2812					;v5 FORTH_DSP_VALUE 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "0=." 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 77 fb			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 78 fb			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 79 fb			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "0=."  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd 04 13			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e					FORTH_DSP 
282e cd 0e 19			call macro_forth_dsp 
2831				endm 
# End of macro FORTH_DSP
2831 7e					ld a,(hl)	; get type of value on TOS 
2832 fe 02				cp DS_TYPE_INUM  
2834 28 00				jr z, .tz_inum 
2836			 
2836				if FORTH_ENABLE_FLOATMATH 
2836					jr .tz_done 
2836			 
2836				endif 
2836					 
2836			 
2836			.tz_inum: 
2836					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2836 cd 29 19			call macro_dsp_valuehl 
2839				endm 
# End of macro FORTH_DSP_VALUEHL
2839			 
2839			;		push hl 
2839			 
2839					; destroy value TOS 
2839			 
2839					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2839 cd a9 19			call macro_forth_dsp_pop 
283c				endm 
# End of macro FORTH_DSP_POP
283c			 
283c			;		pop hl 
283c			 
283c 3e 00				ld a,0 
283e			 
283e bd					cp l 
283f 20 08				jr nz, .tz_notzero 
2841			 
2841 bc					cp h 
2842			 
2842 20 05				jr nz, .tz_notzero 
2844			 
2844			 
2844 21 01 00				ld hl, FORTH_TRUE 
2847 18 03				jr .tz_done 
2849			 
2849 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
284c			 
284c					; push value back onto stack for another op etc 
284c			 
284c			.tz_done: 
284c cd 8e 18				call forth_push_numhl 
284f			 
284f					NEXTW 
284f c3 63 1a			jp macro_next 
2852				endm 
# End of macro NEXTW
2852			.LESS: 
2852				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
2852 2f				db WORD_SYS_CORE+27             
2853 9f 28			dw .GT            
2855 02				db 1 + 1 
2856 .. 00			db "<",0              
2858				endm 
# End of macro CWHEAD
2858			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
2858				; TODO add floating point number detection 
2858					if DEBUG_FORTH_WORDS_KEY 
2858						DMARK "LES" 
2858 f5				push af  
2859 3a 6d 28			ld a, (.dmark)  
285c 32 77 fb			ld (debug_mark),a  
285f 3a 6e 28			ld a, (.dmark+1)  
2862 32 78 fb			ld (debug_mark+1),a  
2865 3a 6f 28			ld a, (.dmark+2)  
2868 32 79 fb			ld (debug_mark+2),a  
286b 18 03			jr .pastdmark  
286d ..			.dmark: db "LES"  
2870 f1			.pastdmark: pop af  
2871			endm  
# End of macro DMARK
2871						CALLMONITOR 
2871 cd 04 13			call break_point_state  
2874				endm  
# End of macro CALLMONITOR
2874					endif 
2874					FORTH_DSP 
2874 cd 0e 19			call macro_forth_dsp 
2877				endm 
# End of macro FORTH_DSP
2877					;v5 FORTH_DSP_VALUE 
2877 7e					ld a,(hl)	; get type of value on TOS 
2878 fe 02				cp DS_TYPE_INUM  
287a 28 00				jr z, .less_inum 
287c			 
287c				if FORTH_ENABLE_FLOATMATH 
287c					jr .less_done 
287c			 
287c				endif 
287c					 
287c			 
287c			.less_inum: 
287c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
287c cd 29 19			call macro_dsp_valuehl 
287f				endm 
# End of macro FORTH_DSP_VALUEHL
287f			 
287f e5					push hl  ; u2 
2880			 
2880					; destroy value TOS 
2880			 
2880					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2880 cd a9 19			call macro_forth_dsp_pop 
2883				endm 
# End of macro FORTH_DSP_POP
2883			 
2883			 
2883					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2883 cd 29 19			call macro_dsp_valuehl 
2886				endm 
# End of macro FORTH_DSP_VALUEHL
2886			 
2886 e5					push hl    ; u1 
2887			 
2887					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2887 cd a9 19			call macro_forth_dsp_pop 
288a				endm 
# End of macro FORTH_DSP_POP
288a			 
288a			 
288a b7			 or a      ;clear carry flag 
288b 01 00 00		 ld bc, FORTH_FALSE 
288e e1			  pop hl    ; u1 
288f d1			  pop de    ; u2 
2890 ed 52		  sbc hl,de 
2892 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
2894			 
2894 01 01 00		 ld bc, FORTH_TRUE 
2897			.lscont:  
2897 c5					push bc 
2898 e1					pop hl 
2899			 
2899					if DEBUG_FORTH_WORDS 
2899						DMARK "LT1" 
2899						CALLMONITOR 
2899					endif 
2899 cd 8e 18				call forth_push_numhl 
289c			 
289c					NEXTW 
289c c3 63 1a			jp macro_next 
289f				endm 
# End of macro NEXTW
289f			.GT: 
289f				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
289f 30				db WORD_SYS_CORE+28             
28a0 ec 28			dw .EQUAL            
28a2 02				db 1 + 1 
28a3 .. 00			db ">",0              
28a5				endm 
# End of macro CWHEAD
28a5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
28a5				; TODO add floating point number detection 
28a5					if DEBUG_FORTH_WORDS_KEY 
28a5						DMARK "GRT" 
28a5 f5				push af  
28a6 3a ba 28			ld a, (.dmark)  
28a9 32 77 fb			ld (debug_mark),a  
28ac 3a bb 28			ld a, (.dmark+1)  
28af 32 78 fb			ld (debug_mark+1),a  
28b2 3a bc 28			ld a, (.dmark+2)  
28b5 32 79 fb			ld (debug_mark+2),a  
28b8 18 03			jr .pastdmark  
28ba ..			.dmark: db "GRT"  
28bd f1			.pastdmark: pop af  
28be			endm  
# End of macro DMARK
28be						CALLMONITOR 
28be cd 04 13			call break_point_state  
28c1				endm  
# End of macro CALLMONITOR
28c1					endif 
28c1					FORTH_DSP 
28c1 cd 0e 19			call macro_forth_dsp 
28c4				endm 
# End of macro FORTH_DSP
28c4					;FORTH_DSP_VALUE 
28c4 7e					ld a,(hl)	; get type of value on TOS 
28c5 fe 02				cp DS_TYPE_INUM  
28c7 28 00				jr z, .gt_inum 
28c9			 
28c9				if FORTH_ENABLE_FLOATMATH 
28c9					jr .gt_done 
28c9			 
28c9				endif 
28c9					 
28c9			 
28c9			.gt_inum: 
28c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c9 cd 29 19			call macro_dsp_valuehl 
28cc				endm 
# End of macro FORTH_DSP_VALUEHL
28cc			 
28cc e5					push hl  ; u2 
28cd			 
28cd					; destroy value TOS 
28cd			 
28cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28cd cd a9 19			call macro_forth_dsp_pop 
28d0				endm 
# End of macro FORTH_DSP_POP
28d0			 
28d0			 
28d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d0 cd 29 19			call macro_dsp_valuehl 
28d3				endm 
# End of macro FORTH_DSP_VALUEHL
28d3			 
28d3 e5					push hl    ; u1 
28d4			 
28d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d4 cd a9 19			call macro_forth_dsp_pop 
28d7				endm 
# End of macro FORTH_DSP_POP
28d7			 
28d7			 
28d7 b7			 or a      ;clear carry flag 
28d8 01 00 00		 ld bc, FORTH_FALSE 
28db e1			  pop hl    ; u1 
28dc d1			  pop de    ; u2 
28dd ed 52		  sbc hl,de 
28df 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
28e1			 
28e1 01 01 00		 ld bc, FORTH_TRUE 
28e4			.gtcont:  
28e4 c5					push bc 
28e5 e1					pop hl 
28e6			 
28e6					if DEBUG_FORTH_WORDS 
28e6						DMARK "GT1" 
28e6						CALLMONITOR 
28e6					endif 
28e6 cd 8e 18				call forth_push_numhl 
28e9			 
28e9					NEXTW 
28e9 c3 63 1a			jp macro_next 
28ec				endm 
# End of macro NEXTW
28ec			.EQUAL: 
28ec				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
28ec 31				db WORD_SYS_CORE+29             
28ed 3b 29			dw .ENDLOGIC            
28ef 02				db 1 + 1 
28f0 .. 00			db "=",0              
28f2				endm 
# End of macro CWHEAD
28f2			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
28f2				; TODO add floating point number detection 
28f2					if DEBUG_FORTH_WORDS_KEY 
28f2						DMARK "EQ." 
28f2 f5				push af  
28f3 3a 07 29			ld a, (.dmark)  
28f6 32 77 fb			ld (debug_mark),a  
28f9 3a 08 29			ld a, (.dmark+1)  
28fc 32 78 fb			ld (debug_mark+1),a  
28ff 3a 09 29			ld a, (.dmark+2)  
2902 32 79 fb			ld (debug_mark+2),a  
2905 18 03			jr .pastdmark  
2907 ..			.dmark: db "EQ."  
290a f1			.pastdmark: pop af  
290b			endm  
# End of macro DMARK
290b						CALLMONITOR 
290b cd 04 13			call break_point_state  
290e				endm  
# End of macro CALLMONITOR
290e					endif 
290e					FORTH_DSP 
290e cd 0e 19			call macro_forth_dsp 
2911				endm 
# End of macro FORTH_DSP
2911					;v5 FORTH_DSP_VALUE 
2911 7e					ld a,(hl)	; get type of value on TOS 
2912 fe 02				cp DS_TYPE_INUM  
2914 28 00				jr z, .eq_inum 
2916			 
2916				if FORTH_ENABLE_FLOATMATH 
2916					jr .eq_done 
2916			 
2916				endif 
2916					 
2916			 
2916			.eq_inum: 
2916					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2916 cd 29 19			call macro_dsp_valuehl 
2919				endm 
# End of macro FORTH_DSP_VALUEHL
2919			 
2919 e5					push hl 
291a			 
291a					; destroy value TOS 
291a			 
291a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291a cd a9 19			call macro_forth_dsp_pop 
291d				endm 
# End of macro FORTH_DSP_POP
291d			 
291d			 
291d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
291d cd 29 19			call macro_dsp_valuehl 
2920				endm 
# End of macro FORTH_DSP_VALUEHL
2920			 
2920					; one value on hl get other one back 
2920			 
2920 e5					push hl 
2921			 
2921					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2921 cd a9 19			call macro_forth_dsp_pop 
2924				endm 
# End of macro FORTH_DSP_POP
2924			 
2924 0e 00				ld c, FORTH_FALSE 
2926			 
2926 e1					pop hl 
2927 d1					pop de 
2928			 
2928 7b					ld a, e 
2929 bd					cp l 
292a			 
292a 20 06				jr nz, .eq_done 
292c			 
292c 7a					ld a, d 
292d bc					cp h 
292e			 
292e 20 02				jr nz, .eq_done 
2930			 
2930 0e 01				ld c, FORTH_TRUE 
2932					 
2932			 
2932			 
2932			.eq_done: 
2932			 
2932					; TODO push value back onto stack for another op etc 
2932			 
2932 26 00				ld h, 0 
2934 69					ld l, c 
2935					if DEBUG_FORTH_WORDS 
2935						DMARK "EQ1" 
2935						CALLMONITOR 
2935					endif 
2935 cd 8e 18				call forth_push_numhl 
2938			 
2938					NEXTW 
2938 c3 63 1a			jp macro_next 
293b				endm 
# End of macro NEXTW
293b			 
293b			 
293b			.ENDLOGIC: 
293b			; eof 
293b			 
293b			 
# End of file forth_words_logic.asm
293b			include "forth_words_maths.asm" 
293b			 
293b			; | ## Maths Words 
293b			 
293b			.PLUS:	 
293b				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
293b 15				db WORD_SYS_CORE+1             
293c 7d 29			dw .NEG            
293e 02				db 1 + 1 
293f .. 00			db "+",0              
2941				endm 
# End of macro CWHEAD
2941			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
2941					if DEBUG_FORTH_WORDS_KEY 
2941						DMARK "PLU" 
2941 f5				push af  
2942 3a 56 29			ld a, (.dmark)  
2945 32 77 fb			ld (debug_mark),a  
2948 3a 57 29			ld a, (.dmark+1)  
294b 32 78 fb			ld (debug_mark+1),a  
294e 3a 58 29			ld a, (.dmark+2)  
2951 32 79 fb			ld (debug_mark+2),a  
2954 18 03			jr .pastdmark  
2956 ..			.dmark: db "PLU"  
2959 f1			.pastdmark: pop af  
295a			endm  
# End of macro DMARK
295a						CALLMONITOR 
295a cd 04 13			call break_point_state  
295d				endm  
# End of macro CALLMONITOR
295d					endif 
295d					; add top two values and push back result 
295d			 
295d					;for v5 FORTH_DSP_VALUE 
295d					FORTH_DSP 
295d cd 0e 19			call macro_forth_dsp 
2960				endm 
# End of macro FORTH_DSP
2960 7e					ld a,(hl)	; get type of value on TOS 
2961 fe 02				cp DS_TYPE_INUM  
2963 28 03				jr z, .dot_inum 
2965			 
2965					NEXTW 
2965 c3 63 1a			jp macro_next 
2968				endm 
# End of macro NEXTW
2968			 
2968			; float maths 
2968			 
2968				if FORTH_ENABLE_FLOATMATH 
2968						inc hl      ; now at start of numeric as string 
2968			 
2968					if DEBUG_FORTH_MATHS 
2968						DMARK "ADD" 
2968				CALLMONITOR 
2968					endif 
2968			 
2968					;ld ix, hl 
2968					call CON 
2968			 
2968			 
2968					push hl 
2968					 
2968					 
2968			 
2968						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
2968			 
2968					; get next number 
2968			 
2968						FORTH_DSP_VALUE 
2968			 
2968						inc hl      ; now at start of numeric as string 
2968			 
2968					;ld ix, hl 
2968					call CON 
2968			 
2968					push hl 
2968			 
2968			 
2968						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2968			 
2968						; TODO do add 
2968			 
2968						call IADD 
2968			 
2968						; TODO get result back as ascii 
2968			 
2968						; TODO push result  
2968			 
2968			 
2968			 
2968						jr .dot_done 
2968				endif 
2968			 
2968			.dot_inum: 
2968			 
2968			 
2968					if DEBUG_FORTH_DOT 
2968						DMARK "+IT" 
2968				CALLMONITOR 
2968					endif 
2968			 
2968					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2968 cd 29 19			call macro_dsp_valuehl 
296b				endm 
# End of macro FORTH_DSP_VALUEHL
296b			 
296b				; TODO add floating point number detection 
296b			 
296b e5					push hl 
296c			 
296c					; destroy value TOS 
296c			 
296c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
296c cd a9 19			call macro_forth_dsp_pop 
296f				endm 
# End of macro FORTH_DSP_POP
296f			 
296f			 
296f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
296f cd 29 19			call macro_dsp_valuehl 
2972				endm 
# End of macro FORTH_DSP_VALUEHL
2972			 
2972					; one value on hl get other one back 
2972			 
2972 d1					pop de 
2973			 
2973					; do the add 
2973			 
2973 19					add hl,de 
2974			 
2974					; save it 
2974			 
2974			;		push hl	 
2974			 
2974					; 
2974			 
2974					; destroy value TOS 
2974			 
2974					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2974 cd a9 19			call macro_forth_dsp_pop 
2977				endm 
# End of macro FORTH_DSP_POP
2977			 
2977					; TODO push value back onto stack for another op etc 
2977			 
2977			;		pop hl 
2977			 
2977			.dot_done: 
2977 cd 8e 18				call forth_push_numhl 
297a			 
297a					NEXTW 
297a c3 63 1a			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			.NEG: 
297d			 
297d				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
297d 17				db WORD_SYS_CORE+3             
297e c0 29			dw .DIV            
2980 02				db 1 + 1 
2981 .. 00			db "-",0              
2983				endm 
# End of macro CWHEAD
2983			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
2983					if DEBUG_FORTH_WORDS_KEY 
2983						DMARK "SUB" 
2983 f5				push af  
2984 3a 98 29			ld a, (.dmark)  
2987 32 77 fb			ld (debug_mark),a  
298a 3a 99 29			ld a, (.dmark+1)  
298d 32 78 fb			ld (debug_mark+1),a  
2990 3a 9a 29			ld a, (.dmark+2)  
2993 32 79 fb			ld (debug_mark+2),a  
2996 18 03			jr .pastdmark  
2998 ..			.dmark: db "SUB"  
299b f1			.pastdmark: pop af  
299c			endm  
# End of macro DMARK
299c						CALLMONITOR 
299c cd 04 13			call break_point_state  
299f				endm  
# End of macro CALLMONITOR
299f					endif 
299f			 
299f			 
299f				; TODO add floating point number detection 
299f					; v5 FORTH_DSP_VALUE 
299f					FORTH_DSP 
299f cd 0e 19			call macro_forth_dsp 
29a2				endm 
# End of macro FORTH_DSP
29a2 7e					ld a,(hl)	; get type of value on TOS 
29a3 fe 02				cp DS_TYPE_INUM  
29a5 28 03				jr z, .neg_inum 
29a7			 
29a7					NEXTW 
29a7 c3 63 1a			jp macro_next 
29aa				endm 
# End of macro NEXTW
29aa			 
29aa			; float maths 
29aa			 
29aa				if FORTH_ENABLE_FLOATMATH 
29aa					jr .neg_done 
29aa			 
29aa				endif 
29aa					 
29aa			 
29aa			.neg_inum: 
29aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29aa cd 29 19			call macro_dsp_valuehl 
29ad				endm 
# End of macro FORTH_DSP_VALUEHL
29ad			 
29ad e5					push hl 
29ae			 
29ae					; destroy value TOS 
29ae			 
29ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ae cd a9 19			call macro_forth_dsp_pop 
29b1				endm 
# End of macro FORTH_DSP_POP
29b1			 
29b1			 
29b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b1 cd 29 19			call macro_dsp_valuehl 
29b4				endm 
# End of macro FORTH_DSP_VALUEHL
29b4			 
29b4					; one value on hl get other one back 
29b4			 
29b4 d1					pop de 
29b5			 
29b5					; do the sub 
29b5			;		ex de, hl 
29b5			 
29b5 ed 52				sbc hl,de 
29b7			 
29b7					; save it 
29b7			 
29b7			;		push hl	 
29b7			 
29b7					; 
29b7			 
29b7					; destroy value TOS 
29b7			 
29b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29b7 cd a9 19			call macro_forth_dsp_pop 
29ba				endm 
# End of macro FORTH_DSP_POP
29ba			 
29ba					; TODO push value back onto stack for another op etc 
29ba			 
29ba			;		pop hl 
29ba			 
29ba cd 8e 18				call forth_push_numhl 
29bd			.neg_done: 
29bd			 
29bd					NEXTW 
29bd c3 63 1a			jp macro_next 
29c0				endm 
# End of macro NEXTW
29c0			.DIV: 
29c0				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
29c0 18				db WORD_SYS_CORE+4             
29c1 0d 2a			dw .MUL            
29c3 02				db 1 + 1 
29c4 .. 00			db "/",0              
29c6				endm 
# End of macro CWHEAD
29c6			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
29c6					if DEBUG_FORTH_WORDS_KEY 
29c6						DMARK "DIV" 
29c6 f5				push af  
29c7 3a db 29			ld a, (.dmark)  
29ca 32 77 fb			ld (debug_mark),a  
29cd 3a dc 29			ld a, (.dmark+1)  
29d0 32 78 fb			ld (debug_mark+1),a  
29d3 3a dd 29			ld a, (.dmark+2)  
29d6 32 79 fb			ld (debug_mark+2),a  
29d9 18 03			jr .pastdmark  
29db ..			.dmark: db "DIV"  
29de f1			.pastdmark: pop af  
29df			endm  
# End of macro DMARK
29df						CALLMONITOR 
29df cd 04 13			call break_point_state  
29e2				endm  
# End of macro CALLMONITOR
29e2					endif 
29e2				; TODO add floating point number detection 
29e2					; v5 FORTH_DSP_VALUE 
29e2					FORTH_DSP 
29e2 cd 0e 19			call macro_forth_dsp 
29e5				endm 
# End of macro FORTH_DSP
29e5 7e					ld a,(hl)	; get type of value on TOS 
29e6 fe 02				cp DS_TYPE_INUM  
29e8 28 03				jr z, .div_inum 
29ea			 
29ea				if FORTH_ENABLE_FLOATMATH 
29ea					jr .div_done 
29ea			 
29ea				endif 
29ea					NEXTW 
29ea c3 63 1a			jp macro_next 
29ed				endm 
# End of macro NEXTW
29ed			.div_inum: 
29ed			 
29ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ed cd 29 19			call macro_dsp_valuehl 
29f0				endm 
# End of macro FORTH_DSP_VALUEHL
29f0			 
29f0 e5					push hl    ; to go to bc 
29f1			 
29f1					; destroy value TOS 
29f1			 
29f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29f1 cd a9 19			call macro_forth_dsp_pop 
29f4				endm 
# End of macro FORTH_DSP_POP
29f4			 
29f4			 
29f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f4 cd 29 19			call macro_dsp_valuehl 
29f7				endm 
# End of macro FORTH_DSP_VALUEHL
29f7			 
29f7					; hl to go to de 
29f7			 
29f7 e5					push hl 
29f8			 
29f8 c1					pop bc 
29f9 d1					pop de		 
29fa			 
29fa			 
29fa					if DEBUG_FORTH_MATHS 
29fa						DMARK "DIV" 
29fa				CALLMONITOR 
29fa					endif 
29fa					; one value on hl but move to a get other one back 
29fa			 
29fa			        
29fa cd 73 0a			call Div16 
29fd			 
29fd			;	push af	 
29fd e5				push hl 
29fe c5				push bc 
29ff			 
29ff					if DEBUG_FORTH_MATHS 
29ff						DMARK "DI1" 
29ff				CALLMONITOR 
29ff					endif 
29ff			 
29ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ff cd a9 19			call macro_forth_dsp_pop 
2a02				endm 
# End of macro FORTH_DSP_POP
2a02			 
2a02			 
2a02			 
2a02 e1					pop hl    ; result 
2a03			 
2a03 cd 8e 18				call forth_push_numhl 
2a06			 
2a06 e1					pop hl    ; reminder 
2a07			;		ld h,0 
2a07			;		ld l,d 
2a07			 
2a07 cd 8e 18				call forth_push_numhl 
2a0a			.div_done: 
2a0a					NEXTW 
2a0a c3 63 1a			jp macro_next 
2a0d				endm 
# End of macro NEXTW
2a0d			.MUL: 
2a0d				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
2a0d 19				db WORD_SYS_CORE+5             
2a0e 52 2a			dw .MIN            
2a10 02				db 1 + 1 
2a11 .. 00			db "*",0              
2a13				endm 
# End of macro CWHEAD
2a13			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
2a13				; TODO add floating point number detection 
2a13					if DEBUG_FORTH_WORDS_KEY 
2a13						DMARK "MUL" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 77 fb			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 78 fb			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 79 fb			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "MUL"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c						CALLMONITOR 
2a2c cd 04 13			call break_point_state  
2a2f				endm  
# End of macro CALLMONITOR
2a2f					endif 
2a2f					FORTH_DSP 
2a2f cd 0e 19			call macro_forth_dsp 
2a32				endm 
# End of macro FORTH_DSP
2a32					; v5 FORTH_DSP_VALUE 
2a32 7e					ld a,(hl)	; get type of value on TOS 
2a33 fe 02				cp DS_TYPE_INUM  
2a35 28 03				jr z, .mul_inum 
2a37			 
2a37				if FORTH_ENABLE_FLOATMATH 
2a37					jr .mul_done 
2a37			 
2a37				endif 
2a37			 
2a37					NEXTW 
2a37 c3 63 1a			jp macro_next 
2a3a				endm 
# End of macro NEXTW
2a3a			.mul_inum:	 
2a3a			 
2a3a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a3a cd 29 19			call macro_dsp_valuehl 
2a3d				endm 
# End of macro FORTH_DSP_VALUEHL
2a3d			 
2a3d e5					push hl 
2a3e			 
2a3e					; destroy value TOS 
2a3e			 
2a3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a3e cd a9 19			call macro_forth_dsp_pop 
2a41				endm 
# End of macro FORTH_DSP_POP
2a41			 
2a41			 
2a41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a41 cd 29 19			call macro_dsp_valuehl 
2a44				endm 
# End of macro FORTH_DSP_VALUEHL
2a44			 
2a44					; one value on hl but move to a get other one back 
2a44			 
2a44 7d					ld a, l 
2a45			 
2a45 d1					pop de 
2a46			 
2a46					; do the mull 
2a46			;		ex de, hl 
2a46			 
2a46 cd 99 0a				call Mult16 
2a49					; save it 
2a49			 
2a49			;		push hl	 
2a49			 
2a49					; 
2a49			 
2a49					; destroy value TOS 
2a49			 
2a49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a49 cd a9 19			call macro_forth_dsp_pop 
2a4c				endm 
# End of macro FORTH_DSP_POP
2a4c			 
2a4c					; TODO push value back onto stack for another op etc 
2a4c			 
2a4c			;		pop hl 
2a4c			 
2a4c cd 8e 18				call forth_push_numhl 
2a4f			 
2a4f			.mul_done: 
2a4f					NEXTW 
2a4f c3 63 1a			jp macro_next 
2a52				endm 
# End of macro NEXTW
2a52			 
2a52			 
2a52			 
2a52			 
2a52			.MIN: 
2a52				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
2a52 49				db WORD_SYS_CORE+53             
2a53 9b 2a			dw .MAX            
2a55 04				db 3 + 1 
2a56 .. 00			db "MIN",0              
2a5a				endm 
# End of macro CWHEAD
2a5a			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
2a5a					if DEBUG_FORTH_WORDS_KEY 
2a5a						DMARK "MIN" 
2a5a f5				push af  
2a5b 3a 6f 2a			ld a, (.dmark)  
2a5e 32 77 fb			ld (debug_mark),a  
2a61 3a 70 2a			ld a, (.dmark+1)  
2a64 32 78 fb			ld (debug_mark+1),a  
2a67 3a 71 2a			ld a, (.dmark+2)  
2a6a 32 79 fb			ld (debug_mark+2),a  
2a6d 18 03			jr .pastdmark  
2a6f ..			.dmark: db "MIN"  
2a72 f1			.pastdmark: pop af  
2a73			endm  
# End of macro DMARK
2a73						CALLMONITOR 
2a73 cd 04 13			call break_point_state  
2a76				endm  
# End of macro CALLMONITOR
2a76					endif 
2a76					; get u2 
2a76			 
2a76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a76 cd 29 19			call macro_dsp_valuehl 
2a79				endm 
# End of macro FORTH_DSP_VALUEHL
2a79			 
2a79 e5					push hl   ; u2 
2a7a			 
2a7a					; destroy value TOS 
2a7a			 
2a7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a7a cd a9 19			call macro_forth_dsp_pop 
2a7d				endm 
# End of macro FORTH_DSP_POP
2a7d			 
2a7d					; get u1 
2a7d			 
2a7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a7d cd 29 19			call macro_dsp_valuehl 
2a80				endm 
# End of macro FORTH_DSP_VALUEHL
2a80			 
2a80 e5					push hl  ; u1 
2a81			 
2a81					; destroy value TOS 
2a81			 
2a81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a81 cd a9 19			call macro_forth_dsp_pop 
2a84				endm 
# End of macro FORTH_DSP_POP
2a84			 
2a84 b7			 or a      ;clear carry flag 
2a85 e1			  pop hl    ; u1 
2a86 d1			  pop de    ; u2 
2a87 e5				push hl   ; saved in case hl is lowest 
2a88 ed 52		  sbc hl,de 
2a8a 30 07		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
2a8c			 
2a8c e1				pop hl 
2a8d					if DEBUG_FORTH_WORDS 
2a8d						DMARK "MIN" 
2a8d						CALLMONITOR 
2a8d					endif 
2a8d cd 8e 18				call forth_push_numhl 
2a90			 
2a90				       NEXTW 
2a90 c3 63 1a			jp macro_next 
2a93				endm 
# End of macro NEXTW
2a93			 
2a93			.mincont:  
2a93 c1				pop bc   ; tidy up 
2a94 eb				ex de , hl  
2a95					if DEBUG_FORTH_WORDS 
2a95						DMARK "MI1" 
2a95						CALLMONITOR 
2a95					endif 
2a95 cd 8e 18				call forth_push_numhl 
2a98			 
2a98				       NEXTW 
2a98 c3 63 1a			jp macro_next 
2a9b				endm 
# End of macro NEXTW
2a9b			.MAX: 
2a9b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
2a9b 4a				db WORD_SYS_CORE+54             
2a9c e4 2a			dw .RND16            
2a9e 04				db 3 + 1 
2a9f .. 00			db "MAX",0              
2aa3				endm 
# End of macro CWHEAD
2aa3			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
2aa3					if DEBUG_FORTH_WORDS_KEY 
2aa3						DMARK "MAX" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 77 fb			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 78 fb			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 79 fb			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "MAX"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc						CALLMONITOR 
2abc cd 04 13			call break_point_state  
2abf				endm  
# End of macro CALLMONITOR
2abf					endif 
2abf					; get u2 
2abf			 
2abf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2abf cd 29 19			call macro_dsp_valuehl 
2ac2				endm 
# End of macro FORTH_DSP_VALUEHL
2ac2			 
2ac2 e5					push hl   ; u2 
2ac3			 
2ac3					; destroy value TOS 
2ac3			 
2ac3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac3 cd a9 19			call macro_forth_dsp_pop 
2ac6				endm 
# End of macro FORTH_DSP_POP
2ac6			 
2ac6					; get u1 
2ac6			 
2ac6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac6 cd 29 19			call macro_dsp_valuehl 
2ac9				endm 
# End of macro FORTH_DSP_VALUEHL
2ac9			 
2ac9 e5					push hl  ; u1 
2aca			 
2aca					; destroy value TOS 
2aca			 
2aca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aca cd a9 19			call macro_forth_dsp_pop 
2acd				endm 
# End of macro FORTH_DSP_POP
2acd			 
2acd b7			 or a      ;clear carry flag 
2ace e1			  pop hl    ; u1 
2acf d1			  pop de    ; u2 
2ad0 e5				push hl   ; saved in case hl is lowest 
2ad1 ed 52		  sbc hl,de 
2ad3 38 07		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
2ad5			 
2ad5 e1				pop hl 
2ad6					if DEBUG_FORTH_WORDS 
2ad6						DMARK "MAX" 
2ad6						CALLMONITOR 
2ad6					endif 
2ad6 cd 8e 18				call forth_push_numhl 
2ad9			 
2ad9				       NEXTW 
2ad9 c3 63 1a			jp macro_next 
2adc				endm 
# End of macro NEXTW
2adc			 
2adc			.maxcont:  
2adc c1				pop bc   ; tidy up 
2add eb				ex de , hl  
2ade					if DEBUG_FORTH_WORDS 
2ade						DMARK "MA1" 
2ade						CALLMONITOR 
2ade					endif 
2ade cd 8e 18				call forth_push_numhl 
2ae1				       NEXTW 
2ae1 c3 63 1a			jp macro_next 
2ae4				endm 
# End of macro NEXTW
2ae4			 
2ae4			.RND16: 
2ae4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
2ae4 4e				db WORD_SYS_CORE+58             
2ae5 13 2b			dw .RND8            
2ae7 06				db 5 + 1 
2ae8 .. 00			db "RND16",0              
2aee				endm 
# End of macro CWHEAD
2aee			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
2aee					if DEBUG_FORTH_WORDS_KEY 
2aee						DMARK "R16" 
2aee f5				push af  
2aef 3a 03 2b			ld a, (.dmark)  
2af2 32 77 fb			ld (debug_mark),a  
2af5 3a 04 2b			ld a, (.dmark+1)  
2af8 32 78 fb			ld (debug_mark+1),a  
2afb 3a 05 2b			ld a, (.dmark+2)  
2afe 32 79 fb			ld (debug_mark+2),a  
2b01 18 03			jr .pastdmark  
2b03 ..			.dmark: db "R16"  
2b06 f1			.pastdmark: pop af  
2b07			endm  
# End of macro DMARK
2b07						CALLMONITOR 
2b07 cd 04 13			call break_point_state  
2b0a				endm  
# End of macro CALLMONITOR
2b0a					endif 
2b0a cd 3d 0a				call prng16  
2b0d cd 8e 18				call forth_push_numhl 
2b10				       NEXTW 
2b10 c3 63 1a			jp macro_next 
2b13				endm 
# End of macro NEXTW
2b13			.RND8: 
2b13				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
2b13 60				db WORD_SYS_CORE+76             
2b14 48 2b			dw .RND            
2b16 05				db 4 + 1 
2b17 .. 00			db "RND8",0              
2b1c				endm 
# End of macro CWHEAD
2b1c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
2b1c					if DEBUG_FORTH_WORDS_KEY 
2b1c						DMARK "RN8" 
2b1c f5				push af  
2b1d 3a 31 2b			ld a, (.dmark)  
2b20 32 77 fb			ld (debug_mark),a  
2b23 3a 32 2b			ld a, (.dmark+1)  
2b26 32 78 fb			ld (debug_mark+1),a  
2b29 3a 33 2b			ld a, (.dmark+2)  
2b2c 32 79 fb			ld (debug_mark+2),a  
2b2f 18 03			jr .pastdmark  
2b31 ..			.dmark: db "RN8"  
2b34 f1			.pastdmark: pop af  
2b35			endm  
# End of macro DMARK
2b35						CALLMONITOR 
2b35 cd 04 13			call break_point_state  
2b38				endm  
# End of macro CALLMONITOR
2b38					endif 
2b38 2a b8 f8				ld hl,(xrandc) 
2b3b 23					inc hl 
2b3c cd 57 0a				call xrnd 
2b3f 6f					ld l,a	 
2b40 26 00				ld h,0 
2b42 cd 8e 18				call forth_push_numhl 
2b45				       NEXTW 
2b45 c3 63 1a			jp macro_next 
2b48				endm 
# End of macro NEXTW
2b48			.RND: 
2b48				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
2b48 60				db WORD_SYS_CORE+76             
2b49 a6 2b			dw .ENDMATHS            
2b4b 04				db 3 + 1 
2b4c .. 00			db "RND",0              
2b50				endm 
# End of macro CWHEAD
2b50			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
2b50			 
2b50					if DEBUG_FORTH_WORDS_KEY 
2b50						DMARK "RND" 
2b50 f5				push af  
2b51 3a 65 2b			ld a, (.dmark)  
2b54 32 77 fb			ld (debug_mark),a  
2b57 3a 66 2b			ld a, (.dmark+1)  
2b5a 32 78 fb			ld (debug_mark+1),a  
2b5d 3a 67 2b			ld a, (.dmark+2)  
2b60 32 79 fb			ld (debug_mark+2),a  
2b63 18 03			jr .pastdmark  
2b65 ..			.dmark: db "RND"  
2b68 f1			.pastdmark: pop af  
2b69			endm  
# End of macro DMARK
2b69						CALLMONITOR 
2b69 cd 04 13			call break_point_state  
2b6c				endm  
# End of macro CALLMONITOR
2b6c					endif 
2b6c					 
2b6c					FORTH_DSP_VALUEHL    ; upper range 
2b6c cd 29 19			call macro_dsp_valuehl 
2b6f				endm 
# End of macro FORTH_DSP_VALUEHL
2b6f			 
2b6f 22 bc f8				ld (LFSRSeed), hl	 
2b72			 
2b72					if DEBUG_FORTH_WORDS 
2b72						DMARK "RN1" 
2b72						CALLMONITOR 
2b72					endif 
2b72					FORTH_DSP_POP 
2b72 cd a9 19			call macro_forth_dsp_pop 
2b75				endm 
# End of macro FORTH_DSP_POP
2b75			 
2b75					FORTH_DSP_VALUEHL    ; low range 
2b75 cd 29 19			call macro_dsp_valuehl 
2b78				endm 
# End of macro FORTH_DSP_VALUEHL
2b78			 
2b78					if DEBUG_FORTH_WORDS 
2b78						DMARK "RN2" 
2b78						CALLMONITOR 
2b78					endif 
2b78 22 be f8				ld (LFSRSeed+2), hl 
2b7b			 
2b7b					FORTH_DSP_POP 
2b7b cd a9 19			call macro_forth_dsp_pop 
2b7e				endm 
# End of macro FORTH_DSP_POP
2b7e			 
2b7e e5					push hl 
2b7f			 
2b7f e1			.inrange:	pop hl 
2b80 cd 3d 0a				call prng16  
2b83					if DEBUG_FORTH_WORDS 
2b83						DMARK "RN3" 
2b83						CALLMONITOR 
2b83					endif 
2b83					 
2b83					; if the range is 8bit knock out the high byte 
2b83			 
2b83 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
2b87			 
2b87 3e 00				ld a, 0 
2b89 ba					cp d  
2b8a 20 02				jr nz, .hirange 
2b8c 26 00				ld h, 0   ; knock it down to 8bit 
2b8e			 
2b8e					if DEBUG_FORTH_WORDS 
2b8e						DMARK "RNk" 
2b8e						CALLMONITOR 
2b8e					endif 
2b8e			.hirange:   
2b8e e5					push hl  
2b8f b7					or a  
2b90 ed 52		                sbc hl, de 
2b92			 
2b92					;call cmp16 
2b92			 
2b92 30 eb				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
2b94 e1					pop hl 
2b95 e5					push hl 
2b96			 
2b96					if DEBUG_FORTH_WORDS 
2b96						DMARK "RN4" 
2b96						CALLMONITOR 
2b96					endif 
2b96 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
2b9a					;call cmp16 
2b9a				 
2b9a b7					or a  
2b9b ed 52		                sbc hl, de 
2b9d 38 e0				jr c, .inrange 
2b9f			 
2b9f e1					pop hl 
2ba0					 
2ba0					if DEBUG_FORTH_WORDS 
2ba0						DMARK "RNd" 
2ba0						CALLMONITOR 
2ba0					endif 
2ba0			 
2ba0			 
2ba0 cd 8e 18				call forth_push_numhl 
2ba3				       NEXTW 
2ba3 c3 63 1a			jp macro_next 
2ba6				endm 
# End of macro NEXTW
2ba6			 
2ba6			.ENDMATHS: 
2ba6			 
2ba6			; eof 
2ba6			 
# End of file forth_words_maths.asm
2ba6			include "forth_words_display.asm" 
2ba6			 
2ba6			; | ## Display Words 
2ba6			 
2ba6			.ATP: 
2ba6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
2ba6 62				db WORD_SYS_CORE+78             
2ba7 e5 2b			dw .FB            
2ba9 04				db 3 + 1 
2baa .. 00			db "AT?",0              
2bae				endm 
# End of macro CWHEAD
2bae			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
2bae					if DEBUG_FORTH_WORDS_KEY 
2bae						DMARK "AT?" 
2bae f5				push af  
2baf 3a c3 2b			ld a, (.dmark)  
2bb2 32 77 fb			ld (debug_mark),a  
2bb5 3a c4 2b			ld a, (.dmark+1)  
2bb8 32 78 fb			ld (debug_mark+1),a  
2bbb 3a c5 2b			ld a, (.dmark+2)  
2bbe 32 79 fb			ld (debug_mark+2),a  
2bc1 18 03			jr .pastdmark  
2bc3 ..			.dmark: db "AT?"  
2bc6 f1			.pastdmark: pop af  
2bc7			endm  
# End of macro DMARK
2bc7						CALLMONITOR 
2bc7 cd 04 13			call break_point_state  
2bca				endm  
# End of macro CALLMONITOR
2bca					endif 
2bca 3a 5b f8				ld a, (f_cursor_ptr) 
2bcd			 
2bcd			if DEBUG_FORTH_WORDS 
2bcd				DMARK "AT?" 
2bcd				CALLMONITOR 
2bcd			endif	 
2bcd					; count the number of rows 
2bcd			 
2bcd 06 00				ld b, 0 
2bcf 4f			.atpr:		ld c, a    ; save in case we go below zero 
2bd0 d6 28				sub display_cols 
2bd2 f2 d8 2b				jp p, .atprunder 
2bd5 04					inc b 
2bd6 18 f7				jr .atpr 
2bd8			.atprunder:	 
2bd8			if DEBUG_FORTH_WORDS 
2bd8				DMARK "A?2" 
2bd8				CALLMONITOR 
2bd8			endif	 
2bd8 26 00				ld h, 0 
2bda 69					ld l, c 
2bdb cd 8e 18				call forth_push_numhl 
2bde 68					ld l, b  
2bdf cd 8e 18				call forth_push_numhl 
2be2			 
2be2			 
2be2				NEXTW 
2be2 c3 63 1a			jp macro_next 
2be5				endm 
# End of macro NEXTW
2be5			 
2be5			.FB: 
2be5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
2be5 1b				db WORD_SYS_CORE+7             
2be6 33 2c			dw .EMIT            
2be8 03				db 2 + 1 
2be9 .. 00			db "FB",0              
2bec				endm 
# End of macro CWHEAD
2bec			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
2bec			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
2bec			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
2bec			; | | If automatic display is off then updates will not be shown until DRAW is used. 
2bec					if DEBUG_FORTH_WORDS_KEY 
2bec						DMARK "FB." 
2bec f5				push af  
2bed 3a 01 2c			ld a, (.dmark)  
2bf0 32 77 fb			ld (debug_mark),a  
2bf3 3a 02 2c			ld a, (.dmark+1)  
2bf6 32 78 fb			ld (debug_mark+1),a  
2bf9 3a 03 2c			ld a, (.dmark+2)  
2bfc 32 79 fb			ld (debug_mark+2),a  
2bff 18 03			jr .pastdmark  
2c01 ..			.dmark: db "FB."  
2c04 f1			.pastdmark: pop af  
2c05			endm  
# End of macro DMARK
2c05						CALLMONITOR 
2c05 cd 04 13			call break_point_state  
2c08				endm  
# End of macro CALLMONITOR
2c08					endif 
2c08			 
2c08					FORTH_DSP_VALUEHL 
2c08 cd 29 19			call macro_dsp_valuehl 
2c0b				endm 
# End of macro FORTH_DSP_VALUEHL
2c0b			 
2c0b 7d					ld a, l 
2c0c fe 01				cp 1 
2c0e 20 05				jr nz, .fbn1 
2c10 21 1c fa				ld hl, display_fb1 
2c13 18 15				jr .fbset 
2c15 fe 02		.fbn1:		cp 2 
2c17 20 05				jr nz, .fbn2 
2c19 21 da f8				ld hl, display_fb2 
2c1c 18 0c				jr .fbset 
2c1e fe 03		.fbn2:		cp 3 
2c20 20 05				jr nz, .fbn3 
2c22 21 7b f9				ld hl, display_fb3 
2c25 18 03				jr .fbset 
2c27			.fbn3:		 ; if invalid number select first 
2c27 21 1c fa				ld hl, display_fb1 
2c2a 22 d8 f8		.fbset:		ld (display_fb_active), hl 
2c2d			 
2c2d					FORTH_DSP_POP 
2c2d cd a9 19			call macro_forth_dsp_pop 
2c30				endm 
# End of macro FORTH_DSP_POP
2c30			 
2c30					NEXTW 
2c30 c3 63 1a			jp macro_next 
2c33				endm 
# End of macro NEXTW
2c33			 
2c33			 
2c33			.EMIT: 
2c33				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
2c33 1b				db WORD_SYS_CORE+7             
2c34 84 2c			dw .DOTH            
2c36 05				db 4 + 1 
2c37 .. 00			db "EMIT",0              
2c3c				endm 
# End of macro CWHEAD
2c3c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
2c3c					; get value off TOS and display it 
2c3c			 
2c3c					if DEBUG_FORTH_WORDS_KEY 
2c3c						DMARK "EMT" 
2c3c f5				push af  
2c3d 3a 51 2c			ld a, (.dmark)  
2c40 32 77 fb			ld (debug_mark),a  
2c43 3a 52 2c			ld a, (.dmark+1)  
2c46 32 78 fb			ld (debug_mark+1),a  
2c49 3a 53 2c			ld a, (.dmark+2)  
2c4c 32 79 fb			ld (debug_mark+2),a  
2c4f 18 03			jr .pastdmark  
2c51 ..			.dmark: db "EMT"  
2c54 f1			.pastdmark: pop af  
2c55			endm  
# End of macro DMARK
2c55						CALLMONITOR 
2c55 cd 04 13			call break_point_state  
2c58				endm  
# End of macro CALLMONITOR
2c58					endif 
2c58			 
2c58					FORTH_DSP_VALUEHL 
2c58 cd 29 19			call macro_dsp_valuehl 
2c5b				endm 
# End of macro FORTH_DSP_VALUEHL
2c5b			 
2c5b 7d					ld a,l 
2c5c			 
2c5c					; TODO write to display 
2c5c			 
2c5c 32 30 f0				ld (os_input), a 
2c5f 3e 00				ld a, 0 
2c61 32 31 f0				ld (os_input+1), a 
2c64					 
2c64 3a 5b f8				ld a, (f_cursor_ptr) 
2c67 11 30 f0				ld de, os_input 
2c6a cd d0 09				call str_at_display 
2c6d			 
2c6d			 
2c6d 3a 39 f8				ld a,(cli_autodisplay) 
2c70 fe 00				cp 0 
2c72 28 03				jr z, .enoupdate 
2c74 cd e0 09						call update_display 
2c77					.enoupdate: 
2c77			 
2c77 3a 5b f8				ld a, (f_cursor_ptr) 
2c7a 3c					inc a 
2c7b 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
2c7e			 
2c7e			 
2c7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c7e cd a9 19			call macro_forth_dsp_pop 
2c81				endm 
# End of macro FORTH_DSP_POP
2c81			  
2c81			 
2c81					NEXTW 
2c81 c3 63 1a			jp macro_next 
2c84				endm 
# End of macro NEXTW
2c84			.DOTH: 
2c84				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
2c84 1c				db WORD_SYS_CORE+8             
2c85 b4 2c			dw .DOTF            
2c87 03				db 2 + 1 
2c88 .. 00			db ".-",0              
2c8b				endm 
# End of macro CWHEAD
2c8b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
2c8b					; get value off TOS and display it 
2c8b					if DEBUG_FORTH_WORDS_KEY 
2c8b						DMARK "DTD" 
2c8b f5				push af  
2c8c 3a a0 2c			ld a, (.dmark)  
2c8f 32 77 fb			ld (debug_mark),a  
2c92 3a a1 2c			ld a, (.dmark+1)  
2c95 32 78 fb			ld (debug_mark+1),a  
2c98 3a a2 2c			ld a, (.dmark+2)  
2c9b 32 79 fb			ld (debug_mark+2),a  
2c9e 18 03			jr .pastdmark  
2ca0 ..			.dmark: db "DTD"  
2ca3 f1			.pastdmark: pop af  
2ca4			endm  
# End of macro DMARK
2ca4						CALLMONITOR 
2ca4 cd 04 13			call break_point_state  
2ca7				endm  
# End of macro CALLMONITOR
2ca7					endif 
2ca7 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
2ca9 3e 00			ld a, 0 
2cab 32 3a f8			ld (cli_mvdot), a 
2cae c3 0b 2d			jp .dotgo 
2cb1				NEXTW 
2cb1 c3 63 1a			jp macro_next 
2cb4				endm 
# End of macro NEXTW
2cb4			.DOTF: 
2cb4				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
2cb4 1c				db WORD_SYS_CORE+8             
2cb5 e2 2c			dw .DOT            
2cb7 03				db 2 + 1 
2cb8 .. 00			db ".>",0              
2cbb				endm 
# End of macro CWHEAD
2cbb			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
2cbb					; get value off TOS and display it 
2cbb			        ; TODO BUG adds extra spaces 
2cbb			        ; TODO BUG handle numerics? 
2cbb					if DEBUG_FORTH_WORDS_KEY 
2cbb						DMARK "DTC" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 77 fb			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 78 fb			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 79 fb			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "DTC"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4						CALLMONITOR 
2cd4 cd 04 13			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7					endif 
2cd7 3e 01			ld a, 1 
2cd9 32 3a f8			ld (cli_mvdot), a 
2cdc c3 0b 2d			jp .dotgo 
2cdf				NEXTW 
2cdf c3 63 1a			jp macro_next 
2ce2				endm 
# End of macro NEXTW
2ce2			 
2ce2			.DOT: 
2ce2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
2ce2 1c				db WORD_SYS_CORE+8             
2ce3 6e 2d			dw .CLS            
2ce5 02				db 1 + 1 
2ce6 .. 00			db ".",0              
2ce8				endm 
# End of macro CWHEAD
2ce8			        ; | . ( u -- ) Display TOS | DONE 
2ce8					; get value off TOS and display it 
2ce8			 
2ce8					if DEBUG_FORTH_WORDS_KEY 
2ce8						DMARK "DOT" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 77 fb			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 78 fb			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 79 fb			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "DOT"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd 04 13			call break_point_state  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04 3e 00			ld a, 0 
2d06 32 3a f8			ld (cli_mvdot), a 
2d09 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
2d0b				 
2d0b			 
2d0b			.dotgo: 
2d0b			 
2d0b			; move up type to on stack for parserv5 
2d0b					FORTH_DSP 
2d0b cd 0e 19			call macro_forth_dsp 
2d0e				endm 
# End of macro FORTH_DSP
2d0e				;FORTH_DSP_VALUE  
2d0e			 
2d0e			if DEBUG_FORTH_DOT 
2d0e				DMARK "DOT" 
2d0e				CALLMONITOR 
2d0e			endif	 
2d0e			;		.print: 
2d0e			 
2d0e 7e				ld a,(hl)  ; work out what type of value is on the TOS 
2d0f 23				inc hl   ; position to the actual value 
2d10 fe 01			cp DS_TYPE_STR 
2d12 20 06			jr nz, .dotnum1  
2d14			 
2d14			; display string 
2d14				FORTH_DSP_VALUE  
2d14 cd 12 19			call macro_forth_dsp_value 
2d17				endm 
# End of macro FORTH_DSP_VALUE
2d17 eb				ex de,hl 
2d18 18 11			jr .dotwrite 
2d1a			 
2d1a			.dotnum1: 
2d1a fe 02			cp DS_TYPE_INUM 
2d1c 20 0c			jr nz, .dotflot 
2d1e			 
2d1e			 
2d1e			; display number 
2d1e			 
2d1e			;	push hl 
2d1e			;	call clear_display 
2d1e			;	pop hl 
2d1e			 
2d1e 5e				ld e, (hl) 
2d1f 23				inc hl 
2d20 56				ld d, (hl) 
2d21 21 32 ee			ld hl, scratch 
2d24			if DEBUG_FORTH_DOT 
2d24				DMARK "DT1" 
2d24				CALLMONITOR 
2d24			endif	 
2d24			 
2d24 cd 23 0f			call uitoa_16 
2d27 eb				ex de,hl 
2d28			 
2d28			if DEBUG_FORTH_DOT 
2d28				DMARK "DT2" 
2d28				CALLMONITOR 
2d28			endif	 
2d28			 
2d28			;	ld de, os_word_scratch 
2d28 18 01			jr .dotwrite 
2d2a			 
2d2a 00			.dotflot:   nop 
2d2b			; TODO print floating point number 
2d2b			 
2d2b			.dotwrite:		 
2d2b			 
2d2b					; if c is set then set all '-' to spaces 
2d2b					; need to also take into account .>  
2d2b			 
2d2b 3e 01				ld a, 1 
2d2d b9					cp c 
2d2e 20 13				jr nz, .nodashswap 
2d30			 
2d30					; DE has the string to write, working with HL 
2d30			 
2d30 06 ff				ld b, 255 
2d32 d5					push de 
2d33 e1					pop hl 
2d34			 
2d34			if DEBUG_FORTH_DOT 
2d34				DMARK "DT-" 
2d34				CALLMONITOR 
2d34			endif	 
2d34 7e			.dashscan:	ld a, (hl) 
2d35 fe 00				cp 0 
2d37 28 0a				jr z, .nodashswap 
2d39 fe 2d				cp '-' 
2d3b 20 03				jr nz, .dashskip 
2d3d 3e 20				ld a, ' ' 
2d3f 77					ld (hl), a 
2d40 23			.dashskip:	inc hl 
2d41			if DEBUG_FORTH_DOT 
2d41				DMARK "D-2" 
2d41				CALLMONITOR 
2d41			endif	 
2d41 10 f1				djnz .dashscan 
2d43			 
2d43			if DEBUG_FORTH_DOT 
2d43				DMARK "D-1" 
2d43				CALLMONITOR 
2d43			endif	 
2d43			 
2d43			.nodashswap: 
2d43			 
2d43 e5					push hl   ; save string start in case we need to advance print 
2d44			 
2d44 3a 5b f8				ld a, (f_cursor_ptr) 
2d47 cd d0 09				call str_at_display 
2d4a 3a 39 f8				ld a,(cli_autodisplay) 
2d4d fe 00				cp 0 
2d4f 28 03				jr z, .noupdate 
2d51 cd e0 09						call update_display 
2d54					.noupdate: 
2d54			 
2d54			 
2d54					; see if we need to advance the print position 
2d54			 
2d54 e1					pop hl   ; get back string 
2d55			 
2d55 3a 3a f8				ld a, (cli_mvdot) 
2d58			if DEBUG_FORTH_DOT 
2d58					ld e,a 
2d58				DMARK "D>1" 
2d58				CALLMONITOR 
2d58			endif	 
2d58 fe 00				cp 0 
2d5a 28 0c				jr z, .noadv 
2d5c					; yes, lets advance the print position 
2d5c 3e 00				ld a, 0 
2d5e cd 7f 0f				call strlent 
2d61 3a 5b f8				ld a, (f_cursor_ptr) 
2d64 85					add a,l 
2d65					;call addatohl 
2d65					;ld a, l 
2d65 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
2d68			 
2d68			if DEBUG_FORTH_DOT 
2d68				DMARK "D->" 
2d68				CALLMONITOR 
2d68			endif	 
2d68			 
2d68			.noadv:	 
2d68			 
2d68					if DEBUG_FORTH_DOT_WAIT 
2d68							call next_page_prompt 
2d68					endif	 
2d68			; TODO this pop off the stack causes a crash. i dont know why 
2d68			 
2d68			 
2d68			if DEBUG_FORTH_DOT 
2d68				DMARK "DTh" 
2d68				CALLMONITOR 
2d68			endif	 
2d68			 
2d68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d68 cd a9 19			call macro_forth_dsp_pop 
2d6b				endm 
# End of macro FORTH_DSP_POP
2d6b			 
2d6b			if DEBUG_FORTH_DOT 
2d6b				DMARK "DTi" 
2d6b				CALLMONITOR 
2d6b			endif	 
2d6b			 
2d6b			 
2d6b					NEXTW 
2d6b c3 63 1a			jp macro_next 
2d6e				endm 
# End of macro NEXTW
2d6e			 
2d6e			.CLS: 
2d6e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
2d6e 35				db WORD_SYS_CORE+33             
2d6f 9b 2d			dw .DRAW            
2d71 04				db 3 + 1 
2d72 .. 00			db "CLS",0              
2d76				endm 
# End of macro CWHEAD
2d76			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
2d76					if DEBUG_FORTH_WORDS_KEY 
2d76						DMARK "CLS" 
2d76 f5				push af  
2d77 3a 8b 2d			ld a, (.dmark)  
2d7a 32 77 fb			ld (debug_mark),a  
2d7d 3a 8c 2d			ld a, (.dmark+1)  
2d80 32 78 fb			ld (debug_mark+1),a  
2d83 3a 8d 2d			ld a, (.dmark+2)  
2d86 32 79 fb			ld (debug_mark+2),a  
2d89 18 03			jr .pastdmark  
2d8b ..			.dmark: db "CLS"  
2d8e f1			.pastdmark: pop af  
2d8f			endm  
# End of macro DMARK
2d8f						CALLMONITOR 
2d8f cd 04 13			call break_point_state  
2d92				endm  
# End of macro CALLMONITOR
2d92					endif 
2d92 cd bd 09				call clear_display 
2d95 c3 a9 2e				jp .home		; and home cursor 
2d98					NEXTW 
2d98 c3 63 1a			jp macro_next 
2d9b				endm 
# End of macro NEXTW
2d9b			 
2d9b			.DRAW: 
2d9b				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
2d9b 36				db WORD_SYS_CORE+34             
2d9c c6 2d			dw .DUMP            
2d9e 05				db 4 + 1 
2d9f .. 00			db "DRAW",0              
2da4				endm 
# End of macro CWHEAD
2da4			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
2da4					if DEBUG_FORTH_WORDS_KEY 
2da4						DMARK "DRW" 
2da4 f5				push af  
2da5 3a b9 2d			ld a, (.dmark)  
2da8 32 77 fb			ld (debug_mark),a  
2dab 3a ba 2d			ld a, (.dmark+1)  
2dae 32 78 fb			ld (debug_mark+1),a  
2db1 3a bb 2d			ld a, (.dmark+2)  
2db4 32 79 fb			ld (debug_mark+2),a  
2db7 18 03			jr .pastdmark  
2db9 ..			.dmark: db "DRW"  
2dbc f1			.pastdmark: pop af  
2dbd			endm  
# End of macro DMARK
2dbd						CALLMONITOR 
2dbd cd 04 13			call break_point_state  
2dc0				endm  
# End of macro CALLMONITOR
2dc0					endif 
2dc0 cd e0 09				call update_display 
2dc3					NEXTW 
2dc3 c3 63 1a			jp macro_next 
2dc6				endm 
# End of macro NEXTW
2dc6			 
2dc6			.DUMP: 
2dc6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
2dc6 37				db WORD_SYS_CORE+35             
2dc7 fe 2d			dw .CDUMP            
2dc9 05				db 4 + 1 
2dca .. 00			db "DUMP",0              
2dcf				endm 
# End of macro CWHEAD
2dcf			; | DUMP ( x -- ) With address x display dump   | DONE 
2dcf			; TODO pop address to use off of the stack 
2dcf					if DEBUG_FORTH_WORDS_KEY 
2dcf						DMARK "DUM" 
2dcf f5				push af  
2dd0 3a e4 2d			ld a, (.dmark)  
2dd3 32 77 fb			ld (debug_mark),a  
2dd6 3a e5 2d			ld a, (.dmark+1)  
2dd9 32 78 fb			ld (debug_mark+1),a  
2ddc 3a e6 2d			ld a, (.dmark+2)  
2ddf 32 79 fb			ld (debug_mark+2),a  
2de2 18 03			jr .pastdmark  
2de4 ..			.dmark: db "DUM"  
2de7 f1			.pastdmark: pop af  
2de8			endm  
# End of macro DMARK
2de8						CALLMONITOR 
2de8 cd 04 13			call break_point_state  
2deb				endm  
# End of macro CALLMONITOR
2deb					endif 
2deb cd bd 09				call clear_display 
2dee			 
2dee					; get address 
2dee			 
2dee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dee cd 29 19			call macro_dsp_valuehl 
2df1				endm 
# End of macro FORTH_DSP_VALUEHL
2df1				 
2df1					; save it for cdump 
2df1			 
2df1 22 55 f1				ld (os_cur_ptr),hl 
2df4			 
2df4					; destroy value TOS 
2df4			 
2df4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2df4 cd a9 19			call macro_forth_dsp_pop 
2df7				endm 
# End of macro FORTH_DSP_POP
2df7			 
2df7 cd 11 17				call dumpcont	; skip old style of param parsing	 
2dfa c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
2dfb					NEXTW 
2dfb c3 63 1a			jp macro_next 
2dfe				endm 
# End of macro NEXTW
2dfe			.CDUMP: 
2dfe				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
2dfe 38				db WORD_SYS_CORE+36             
2dff 2e 2e			dw .DAT            
2e01 06				db 5 + 1 
2e02 .. 00			db "CDUMP",0              
2e08				endm 
# End of macro CWHEAD
2e08			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
2e08					if DEBUG_FORTH_WORDS_KEY 
2e08						DMARK "CDP" 
2e08 f5				push af  
2e09 3a 1d 2e			ld a, (.dmark)  
2e0c 32 77 fb			ld (debug_mark),a  
2e0f 3a 1e 2e			ld a, (.dmark+1)  
2e12 32 78 fb			ld (debug_mark+1),a  
2e15 3a 1f 2e			ld a, (.dmark+2)  
2e18 32 79 fb			ld (debug_mark+2),a  
2e1b 18 03			jr .pastdmark  
2e1d ..			.dmark: db "CDP"  
2e20 f1			.pastdmark: pop af  
2e21			endm  
# End of macro DMARK
2e21						CALLMONITOR 
2e21 cd 04 13			call break_point_state  
2e24				endm  
# End of macro CALLMONITOR
2e24					endif 
2e24 cd bd 09				call clear_display 
2e27 cd 11 17				call dumpcont	 
2e2a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
2e2b					NEXTW 
2e2b c3 63 1a			jp macro_next 
2e2e				endm 
# End of macro NEXTW
2e2e			 
2e2e			 
2e2e			 
2e2e			 
2e2e			.DAT: 
2e2e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
2e2e 3d				db WORD_SYS_CORE+41             
2e2f 84 2e			dw .HOME            
2e31 03				db 2 + 1 
2e32 .. 00			db "AT",0              
2e35				endm 
# End of macro CWHEAD
2e35			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
2e35					if DEBUG_FORTH_WORDS_KEY 
2e35						DMARK "AT." 
2e35 f5				push af  
2e36 3a 4a 2e			ld a, (.dmark)  
2e39 32 77 fb			ld (debug_mark),a  
2e3c 3a 4b 2e			ld a, (.dmark+1)  
2e3f 32 78 fb			ld (debug_mark+1),a  
2e42 3a 4c 2e			ld a, (.dmark+2)  
2e45 32 79 fb			ld (debug_mark+2),a  
2e48 18 03			jr .pastdmark  
2e4a ..			.dmark: db "AT."  
2e4d f1			.pastdmark: pop af  
2e4e			endm  
# End of macro DMARK
2e4e						CALLMONITOR 
2e4e cd 04 13			call break_point_state  
2e51				endm  
# End of macro CALLMONITOR
2e51					endif 
2e51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e51 cd 29 19			call macro_dsp_valuehl 
2e54				endm 
# End of macro FORTH_DSP_VALUEHL
2e54			 
2e54			 
2e54					; TODO save cursor row 
2e54 7d					ld a,l 
2e55 fe 02				cp 2 
2e57 20 04				jr nz, .crow3 
2e59 3e 28				ld a, display_row_2 
2e5b 18 12				jr .ccol1 
2e5d fe 03		.crow3:		cp 3 
2e5f 20 04				jr nz, .crow4 
2e61 3e 50				ld a, display_row_3 
2e63 18 0a				jr .ccol1 
2e65 fe 04		.crow4:		cp 4 
2e67 20 04				jr nz, .crow1 
2e69 3e 78				ld a, display_row_4 
2e6b 18 02				jr .ccol1 
2e6d 3e 00		.crow1:		ld a,display_row_1 
2e6f f5			.ccol1:		push af			; got row offset 
2e70 6f					ld l,a 
2e71 26 00				ld h,0 
2e73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e73 cd a9 19			call macro_forth_dsp_pop 
2e76				endm 
# End of macro FORTH_DSP_POP
2e76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e76 cd 29 19			call macro_dsp_valuehl 
2e79				endm 
# End of macro FORTH_DSP_VALUEHL
2e79					; TODO save cursor col 
2e79 f1					pop af 
2e7a 85					add l		; add col offset 
2e7b 32 5b f8				ld (f_cursor_ptr), a 
2e7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e7e cd a9 19			call macro_forth_dsp_pop 
2e81				endm 
# End of macro FORTH_DSP_POP
2e81			 
2e81					; calculate  
2e81			 
2e81					NEXTW 
2e81 c3 63 1a			jp macro_next 
2e84				endm 
# End of macro NEXTW
2e84			 
2e84			 
2e84			.HOME: 
2e84				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
2e84 41				db WORD_SYS_CORE+45             
2e85 b1 2e			dw .SPACE            
2e87 05				db 4 + 1 
2e88 .. 00			db "HOME",0              
2e8d				endm 
# End of macro CWHEAD
2e8d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
2e8d					if DEBUG_FORTH_WORDS_KEY 
2e8d						DMARK "HOM" 
2e8d f5				push af  
2e8e 3a a2 2e			ld a, (.dmark)  
2e91 32 77 fb			ld (debug_mark),a  
2e94 3a a3 2e			ld a, (.dmark+1)  
2e97 32 78 fb			ld (debug_mark+1),a  
2e9a 3a a4 2e			ld a, (.dmark+2)  
2e9d 32 79 fb			ld (debug_mark+2),a  
2ea0 18 03			jr .pastdmark  
2ea2 ..			.dmark: db "HOM"  
2ea5 f1			.pastdmark: pop af  
2ea6			endm  
# End of macro DMARK
2ea6						CALLMONITOR 
2ea6 cd 04 13			call break_point_state  
2ea9				endm  
# End of macro CALLMONITOR
2ea9					endif 
2ea9 3e 00		.home:		ld a, 0		; and home cursor 
2eab 32 5b f8				ld (f_cursor_ptr), a 
2eae					NEXTW 
2eae c3 63 1a			jp macro_next 
2eb1				endm 
# End of macro NEXTW
2eb1			 
2eb1			 
2eb1			.SPACE: 
2eb1				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
2eb1 46				db WORD_SYS_CORE+50             
2eb2 df 2e			dw .SPACES            
2eb4 03				db 2 + 1 
2eb5 .. 00			db "BL",0              
2eb8				endm 
# End of macro CWHEAD
2eb8			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
2eb8					if DEBUG_FORTH_WORDS_KEY 
2eb8						DMARK "BL." 
2eb8 f5				push af  
2eb9 3a cd 2e			ld a, (.dmark)  
2ebc 32 77 fb			ld (debug_mark),a  
2ebf 3a ce 2e			ld a, (.dmark+1)  
2ec2 32 78 fb			ld (debug_mark+1),a  
2ec5 3a cf 2e			ld a, (.dmark+2)  
2ec8 32 79 fb			ld (debug_mark+2),a  
2ecb 18 03			jr .pastdmark  
2ecd ..			.dmark: db "BL."  
2ed0 f1			.pastdmark: pop af  
2ed1			endm  
# End of macro DMARK
2ed1						CALLMONITOR 
2ed1 cd 04 13			call break_point_state  
2ed4				endm  
# End of macro CALLMONITOR
2ed4					endif 
2ed4 21 dd 2e				ld hl, .blstr 
2ed7 cd a0 18				call forth_push_str 
2eda					 
2eda				       NEXTW 
2eda c3 63 1a			jp macro_next 
2edd				endm 
# End of macro NEXTW
2edd			 
2edd .. 00		.blstr: db " ", 0 
2edf			 
2edf			.SPACES: 
2edf				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
2edf 47				db WORD_SYS_CORE+51             
2ee0 26 2f			dw .SCROLL            
2ee2 07				db 6 + 1 
2ee3 .. 00			db "SPACES",0              
2eea				endm 
# End of macro CWHEAD
2eea			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
2eea					if DEBUG_FORTH_WORDS_KEY 
2eea						DMARK "SPS" 
2eea f5				push af  
2eeb 3a ff 2e			ld a, (.dmark)  
2eee 32 77 fb			ld (debug_mark),a  
2ef1 3a 00 2f			ld a, (.dmark+1)  
2ef4 32 78 fb			ld (debug_mark+1),a  
2ef7 3a 01 2f			ld a, (.dmark+2)  
2efa 32 79 fb			ld (debug_mark+2),a  
2efd 18 03			jr .pastdmark  
2eff ..			.dmark: db "SPS"  
2f02 f1			.pastdmark: pop af  
2f03			endm  
# End of macro DMARK
2f03						CALLMONITOR 
2f03 cd 04 13			call break_point_state  
2f06				endm  
# End of macro CALLMONITOR
2f06					endif 
2f06			 
2f06			 
2f06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f06 cd 29 19			call macro_dsp_valuehl 
2f09				endm 
# End of macro FORTH_DSP_VALUEHL
2f09			 
2f09			;		push hl    ; u 
2f09					if DEBUG_FORTH_WORDS 
2f09						DMARK "SPA" 
2f09						CALLMONITOR 
2f09					endif 
2f09			 
2f09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f09 cd a9 19			call macro_forth_dsp_pop 
2f0c				endm 
# End of macro FORTH_DSP_POP
2f0c			;		pop hl 
2f0c 4d					ld c, l 
2f0d 06 00				ld b, 0 
2f0f 21 32 ee				ld hl, scratch  
2f12			 
2f12					if DEBUG_FORTH_WORDS 
2f12						DMARK "SP2" 
2f12						CALLMONITOR 
2f12					endif 
2f12 3e 20				ld a, ' ' 
2f14 c5			.spaces1:	push bc 
2f15 77					ld (hl),a 
2f16 23					inc hl 
2f17 c1					pop bc 
2f18 10 fa				djnz .spaces1 
2f1a 3e 00				ld a,0 
2f1c 77					ld (hl),a 
2f1d 21 32 ee				ld hl, scratch 
2f20					if DEBUG_FORTH_WORDS 
2f20						DMARK "SP3" 
2f20						CALLMONITOR 
2f20					endif 
2f20 cd d6 18				call forth_apush 
2f23			 
2f23				       NEXTW 
2f23 c3 63 1a			jp macro_next 
2f26				endm 
# End of macro NEXTW
2f26			 
2f26			 
2f26			 
2f26			.SCROLL: 
2f26				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
2f26 53				db WORD_SYS_CORE+63             
2f27 53 2f			dw .ATQ            
2f29 07				db 6 + 1 
2f2a .. 00			db "SCROLL",0              
2f31				endm 
# End of macro CWHEAD
2f31			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
2f31					if DEBUG_FORTH_WORDS_KEY 
2f31						DMARK "SCR" 
2f31 f5				push af  
2f32 3a 46 2f			ld a, (.dmark)  
2f35 32 77 fb			ld (debug_mark),a  
2f38 3a 47 2f			ld a, (.dmark+1)  
2f3b 32 78 fb			ld (debug_mark+1),a  
2f3e 3a 48 2f			ld a, (.dmark+2)  
2f41 32 79 fb			ld (debug_mark+2),a  
2f44 18 03			jr .pastdmark  
2f46 ..			.dmark: db "SCR"  
2f49 f1			.pastdmark: pop af  
2f4a			endm  
# End of macro DMARK
2f4a						CALLMONITOR 
2f4a cd 04 13			call break_point_state  
2f4d				endm  
# End of macro CALLMONITOR
2f4d					endif 
2f4d			 
2f4d cd 55 09			call scroll_up 
2f50			;	call update_display 
2f50			 
2f50					NEXTW 
2f50 c3 63 1a			jp macro_next 
2f53				endm 
# End of macro NEXTW
2f53			 
2f53			 
2f53			 
2f53			;		; get dir 
2f53			; 
2f53			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f53			; 
2f53			;		push hl 
2f53			; 
2f53			;		; destroy value TOS 
2f53			; 
2f53			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f53			; 
2f53			;		; get count 
2f53			; 
2f53			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f53			; 
2f53			;		push hl 
2f53			; 
2f53			;		; destroy value TOS 
2f53			; 
2f53			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f53			; 
2f53			;		; one value on hl get other one back 
2f53			; 
2f53			;		pop bc    ; count 
2f53			; 
2f53			;		pop de   ; dir 
2f53			; 
2f53			; 
2f53			;		ld b, c 
2f53			; 
2f53			;.scrolldir:     push bc 
2f53			;		push de 
2f53			; 
2f53			;		ld a, 0 
2f53			;		cp e 
2f53			;		jr z, .scrollup  
2f53			;		call scroll_down 
2f53			;		jr .scrollnext 
2f53			;.scrollup:	call scroll_up 
2f53			; 
2f53			;		 
2f53			;.scrollnext: 
2f53			;		pop de 
2f53			;		pop bc 
2f53			;		djnz .scrolldir 
2f53			; 
2f53			; 
2f53			; 
2f53			; 
2f53			; 
2f53			;		NEXTW 
2f53			 
2f53			 
2f53			 
2f53			 
2f53			.ATQ: 
2f53				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
2f53 62				db WORD_SYS_CORE+78             
2f54 b1 2f			dw .AUTODSP            
2f56 04				db 3 + 1 
2f57 .. 00			db "AT@",0              
2f5b				endm 
# End of macro CWHEAD
2f5b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
2f5b					if DEBUG_FORTH_WORDS_KEY 
2f5b						DMARK "ATA" 
2f5b f5				push af  
2f5c 3a 70 2f			ld a, (.dmark)  
2f5f 32 77 fb			ld (debug_mark),a  
2f62 3a 71 2f			ld a, (.dmark+1)  
2f65 32 78 fb			ld (debug_mark+1),a  
2f68 3a 72 2f			ld a, (.dmark+2)  
2f6b 32 79 fb			ld (debug_mark+2),a  
2f6e 18 03			jr .pastdmark  
2f70 ..			.dmark: db "ATA"  
2f73 f1			.pastdmark: pop af  
2f74			endm  
# End of macro DMARK
2f74						CALLMONITOR 
2f74 cd 04 13			call break_point_state  
2f77				endm  
# End of macro CALLMONITOR
2f77					endif 
2f77			 
2f77			 
2f77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f77 cd 29 19			call macro_dsp_valuehl 
2f7a				endm 
# End of macro FORTH_DSP_VALUEHL
2f7a			 
2f7a					; TODO save cursor row 
2f7a 7d					ld a,l 
2f7b fe 02				cp 2 
2f7d 20 04				jr nz, .crow3aq 
2f7f 3e 28				ld a, display_row_2 
2f81 18 12				jr .ccol1aq 
2f83 fe 03		.crow3aq:		cp 3 
2f85 20 04				jr nz, .crow4aq 
2f87 3e 50				ld a, display_row_3 
2f89 18 0a				jr .ccol1aq 
2f8b fe 04		.crow4aq:		cp 4 
2f8d 20 04				jr nz, .crow1aq 
2f8f 3e 78				ld a, display_row_4 
2f91 18 02				jr .ccol1aq 
2f93 3e 00		.crow1aq:		ld a,display_row_1 
2f95 f5			.ccol1aq:		push af			; got row offset 
2f96 6f					ld l,a 
2f97 26 00				ld h,0 
2f99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f99 cd a9 19			call macro_forth_dsp_pop 
2f9c				endm 
# End of macro FORTH_DSP_POP
2f9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f9c cd 29 19			call macro_dsp_valuehl 
2f9f				endm 
# End of macro FORTH_DSP_VALUEHL
2f9f					; TODO save cursor col 
2f9f f1					pop af 
2fa0 85					add l		; add col offset 
2fa1			 
2fa1					; add current frame buffer address 
2fa1 2a d8 f8				ld hl, (display_fb_active) 
2fa4 cd 16 0b				call addatohl 
2fa7			 
2fa7			 
2fa7			 
2fa7			 
2fa7					; get char frame buffer location offset in hl 
2fa7			 
2fa7 7e					ld a,(hl) 
2fa8 26 00				ld h, 0 
2faa 6f					ld l, a 
2fab			 
2fab cd 8e 18				call forth_push_numhl 
2fae			 
2fae			 
2fae					NEXTW 
2fae c3 63 1a			jp macro_next 
2fb1				endm 
# End of macro NEXTW
2fb1			 
2fb1			.AUTODSP: 
2fb1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
2fb1 63				db WORD_SYS_CORE+79             
2fb2 c7 2f			dw .MENU            
2fb4 05				db 4 + 1 
2fb5 .. 00			db "ADSP",0              
2fba				endm 
# End of macro CWHEAD
2fba			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
2fba			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
2fba			 
2fba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2fba cd 29 19			call macro_dsp_valuehl 
2fbd				endm 
# End of macro FORTH_DSP_VALUEHL
2fbd			 
2fbd			;		push hl 
2fbd			 
2fbd					; destroy value TOS 
2fbd			 
2fbd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fbd cd a9 19			call macro_forth_dsp_pop 
2fc0				endm 
# End of macro FORTH_DSP_POP
2fc0			 
2fc0			;		pop hl 
2fc0			 
2fc0 7d					ld a,l 
2fc1 32 39 f8				ld (cli_autodisplay), a 
2fc4				       NEXTW 
2fc4 c3 63 1a			jp macro_next 
2fc7				endm 
# End of macro NEXTW
2fc7			 
2fc7			.MENU: 
2fc7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
2fc7 70				db WORD_SYS_CORE+92             
2fc8 d3 2f			dw .ENDDISPLAY            
2fca 05				db 4 + 1 
2fcb .. 00			db "MENU",0              
2fd0				endm 
# End of macro CWHEAD
2fd0			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
2fd0			 
2fd0					; get the title address and save it 
2fd0			 
2fd0			;		FORTH_DSP_VALUEHL 
2fd0			;		push hl 
2fd0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fd0			; 
2fd0			;		; get number of items on the stack 
2fd0			; 
2fd0			;	 
2fd0			;		FORTH_DSP_VALUEHL 
2fd0			;		push hl 
2fd0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fd0			 
2fd0			 
2fd0			 
2fd0			 
2fd0				       NEXTW 
2fd0 c3 63 1a			jp macro_next 
2fd3				endm 
# End of macro NEXTW
2fd3			 
2fd3			 
2fd3			.ENDDISPLAY: 
2fd3			 
2fd3			; eof 
# End of file forth_words_display.asm
2fd3			include "forth_words_str.asm" 
2fd3			 
2fd3			; | ## String Words 
2fd3			 
2fd3			.PTR:   
2fd3			 
2fd3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
2fd3 48				db WORD_SYS_CORE+52             
2fd4 00 30			dw .STYPE            
2fd6 04				db 3 + 1 
2fd7 .. 00			db "PTR",0              
2fdb				endm 
# End of macro CWHEAD
2fdb			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
2fdb			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
2fdb			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
2fdb			 
2fdb					if DEBUG_FORTH_WORDS_KEY 
2fdb						DMARK "PTR" 
2fdb f5				push af  
2fdc 3a f0 2f			ld a, (.dmark)  
2fdf 32 77 fb			ld (debug_mark),a  
2fe2 3a f1 2f			ld a, (.dmark+1)  
2fe5 32 78 fb			ld (debug_mark+1),a  
2fe8 3a f2 2f			ld a, (.dmark+2)  
2feb 32 79 fb			ld (debug_mark+2),a  
2fee 18 03			jr .pastdmark  
2ff0 ..			.dmark: db "PTR"  
2ff3 f1			.pastdmark: pop af  
2ff4			endm  
# End of macro DMARK
2ff4						CALLMONITOR 
2ff4 cd 04 13			call break_point_state  
2ff7				endm  
# End of macro CALLMONITOR
2ff7					endif 
2ff7					FORTH_DSP_VALUEHL 
2ff7 cd 29 19			call macro_dsp_valuehl 
2ffa				endm 
# End of macro FORTH_DSP_VALUEHL
2ffa cd 8e 18				call forth_push_numhl 
2ffd			 
2ffd			 
2ffd					NEXTW 
2ffd c3 63 1a			jp macro_next 
3000				endm 
# End of macro NEXTW
3000			.STYPE: 
3000				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3000 48				db WORD_SYS_CORE+52             
3001 4f 30			dw .UPPER            
3003 06				db 5 + 1 
3004 .. 00			db "STYPE",0              
300a				endm 
# End of macro CWHEAD
300a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
300a					if DEBUG_FORTH_WORDS_KEY 
300a						DMARK "STY" 
300a f5				push af  
300b 3a 1f 30			ld a, (.dmark)  
300e 32 77 fb			ld (debug_mark),a  
3011 3a 20 30			ld a, (.dmark+1)  
3014 32 78 fb			ld (debug_mark+1),a  
3017 3a 21 30			ld a, (.dmark+2)  
301a 32 79 fb			ld (debug_mark+2),a  
301d 18 03			jr .pastdmark  
301f ..			.dmark: db "STY"  
3022 f1			.pastdmark: pop af  
3023			endm  
# End of macro DMARK
3023						CALLMONITOR 
3023 cd 04 13			call break_point_state  
3026				endm  
# End of macro CALLMONITOR
3026					endif 
3026					FORTH_DSP 
3026 cd 0e 19			call macro_forth_dsp 
3029				endm 
# End of macro FORTH_DSP
3029					;v5 FORTH_DSP_VALUE 
3029			 
3029 7e					ld a, (hl) 
302a			 
302a f5					push af 
302b			 
302b			; Dont destroy TOS		FORTH_DSP_POP 
302b			 
302b f1					pop af 
302c			 
302c fe 01				cp DS_TYPE_STR 
302e 28 09				jr z, .typestr 
3030			 
3030 fe 02				cp DS_TYPE_INUM 
3032 28 0a				jr z, .typeinum 
3034			 
3034 21 4d 30				ld hl, .tna 
3037 18 0a				jr .tpush 
3039			 
3039 21 49 30		.typestr:	ld hl, .tstr 
303c 18 05				jr .tpush 
303e 21 4b 30		.typeinum:	ld hl, .tinum 
3041 18 00				jr .tpush 
3043			 
3043			.tpush: 
3043			 
3043 cd a0 18				call forth_push_str 
3046			 
3046					NEXTW 
3046 c3 63 1a			jp macro_next 
3049				endm 
# End of macro NEXTW
3049 .. 00		.tstr:	db "s",0 
304b .. 00		.tinum:  db "i",0 
304d .. 00		.tna:   db "?", 0 
304f			 
304f			 
304f			.UPPER: 
304f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
304f 48				db WORD_SYS_CORE+52             
3050 8a 30			dw .LOWER            
3052 06				db 5 + 1 
3053 .. 00			db "UPPER",0              
3059				endm 
# End of macro CWHEAD
3059			; | UPPER ( s -- s ) Upper case string s  | DONE 
3059					if DEBUG_FORTH_WORDS_KEY 
3059						DMARK "UPR" 
3059 f5				push af  
305a 3a 6e 30			ld a, (.dmark)  
305d 32 77 fb			ld (debug_mark),a  
3060 3a 6f 30			ld a, (.dmark+1)  
3063 32 78 fb			ld (debug_mark+1),a  
3066 3a 70 30			ld a, (.dmark+2)  
3069 32 79 fb			ld (debug_mark+2),a  
306c 18 03			jr .pastdmark  
306e ..			.dmark: db "UPR"  
3071 f1			.pastdmark: pop af  
3072			endm  
# End of macro DMARK
3072						CALLMONITOR 
3072 cd 04 13			call break_point_state  
3075				endm  
# End of macro CALLMONITOR
3075					endif 
3075			 
3075					FORTH_DSP 
3075 cd 0e 19			call macro_forth_dsp 
3078				endm 
# End of macro FORTH_DSP
3078					 
3078			; TODO check is string type 
3078			 
3078					FORTH_DSP_VALUEHL 
3078 cd 29 19			call macro_dsp_valuehl 
307b				endm 
# End of macro FORTH_DSP_VALUEHL
307b			; get pointer to string in hl 
307b			 
307b 7e			.toup:		ld a, (hl) 
307c fe 00				cp 0 
307e 28 07				jr z, .toupdone 
3080			 
3080 cd 83 0e				call to_upper 
3083			 
3083 77					ld (hl), a 
3084 23					inc hl 
3085 18 f4				jr .toup 
3087			 
3087					 
3087			 
3087			 
3087			; for each char convert to upper 
3087					 
3087			.toupdone: 
3087			 
3087			 
3087					NEXTW 
3087 c3 63 1a			jp macro_next 
308a				endm 
# End of macro NEXTW
308a			.LOWER: 
308a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
308a 48				db WORD_SYS_CORE+52             
308b c5 30			dw .TCASE            
308d 06				db 5 + 1 
308e .. 00			db "LOWER",0              
3094				endm 
# End of macro CWHEAD
3094			; | LOWER ( s -- s ) Lower case string s  | DONE 
3094					if DEBUG_FORTH_WORDS_KEY 
3094						DMARK "LWR" 
3094 f5				push af  
3095 3a a9 30			ld a, (.dmark)  
3098 32 77 fb			ld (debug_mark),a  
309b 3a aa 30			ld a, (.dmark+1)  
309e 32 78 fb			ld (debug_mark+1),a  
30a1 3a ab 30			ld a, (.dmark+2)  
30a4 32 79 fb			ld (debug_mark+2),a  
30a7 18 03			jr .pastdmark  
30a9 ..			.dmark: db "LWR"  
30ac f1			.pastdmark: pop af  
30ad			endm  
# End of macro DMARK
30ad						CALLMONITOR 
30ad cd 04 13			call break_point_state  
30b0				endm  
# End of macro CALLMONITOR
30b0					endif 
30b0			 
30b0					FORTH_DSP 
30b0 cd 0e 19			call macro_forth_dsp 
30b3				endm 
# End of macro FORTH_DSP
30b3					 
30b3			; TODO check is string type 
30b3			 
30b3					FORTH_DSP_VALUEHL 
30b3 cd 29 19			call macro_dsp_valuehl 
30b6				endm 
# End of macro FORTH_DSP_VALUEHL
30b6			; get pointer to string in hl 
30b6			 
30b6 7e			.tolow:		ld a, (hl) 
30b7 fe 00				cp 0 
30b9 28 07				jr z, .tolowdone 
30bb			 
30bb cd 8c 0e				call to_lower 
30be			 
30be 77					ld (hl), a 
30bf 23					inc hl 
30c0 18 f4				jr .tolow 
30c2			 
30c2					 
30c2			 
30c2			 
30c2			; for each char convert to low 
30c2					 
30c2			.tolowdone: 
30c2					NEXTW 
30c2 c3 63 1a			jp macro_next 
30c5				endm 
# End of macro NEXTW
30c5			.TCASE: 
30c5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
30c5 48				db WORD_SYS_CORE+52             
30c6 1b 31			dw .SUBSTR            
30c8 06				db 5 + 1 
30c9 .. 00			db "TCASE",0              
30cf				endm 
# End of macro CWHEAD
30cf			; | TCASE ( s -- s ) Title case string s  | DONE 
30cf					if DEBUG_FORTH_WORDS_KEY 
30cf						DMARK "TCS" 
30cf f5				push af  
30d0 3a e4 30			ld a, (.dmark)  
30d3 32 77 fb			ld (debug_mark),a  
30d6 3a e5 30			ld a, (.dmark+1)  
30d9 32 78 fb			ld (debug_mark+1),a  
30dc 3a e6 30			ld a, (.dmark+2)  
30df 32 79 fb			ld (debug_mark+2),a  
30e2 18 03			jr .pastdmark  
30e4 ..			.dmark: db "TCS"  
30e7 f1			.pastdmark: pop af  
30e8			endm  
# End of macro DMARK
30e8						CALLMONITOR 
30e8 cd 04 13			call break_point_state  
30eb				endm  
# End of macro CALLMONITOR
30eb					endif 
30eb			 
30eb					FORTH_DSP 
30eb cd 0e 19			call macro_forth_dsp 
30ee				endm 
# End of macro FORTH_DSP
30ee					 
30ee			; TODO check is string type 
30ee			 
30ee					FORTH_DSP_VALUEHL 
30ee cd 29 19			call macro_dsp_valuehl 
30f1				endm 
# End of macro FORTH_DSP_VALUEHL
30f1			; get pointer to string in hl 
30f1			 
30f1					if DEBUG_FORTH_WORDS 
30f1						DMARK "TC1" 
30f1						CALLMONITOR 
30f1					endif 
30f1			 
30f1					; first time in turn to upper case first char 
30f1			 
30f1 7e					ld a, (hl) 
30f2 c3 0c 31				jp .totsiptou 
30f5			 
30f5			 
30f5 7e			.tot:		ld a, (hl) 
30f6 fe 00				cp 0 
30f8 ca 18 31				jp z, .totdone 
30fb			 
30fb					if DEBUG_FORTH_WORDS 
30fb						DMARK "TC2" 
30fb						CALLMONITOR 
30fb					endif 
30fb					; check to see if current char is a space 
30fb			 
30fb fe 20				cp ' ' 
30fd 28 05				jr z, .totsp 
30ff cd 8c 0e				call to_lower 
3102					if DEBUG_FORTH_WORDS 
3102						DMARK "TC3" 
3102						CALLMONITOR 
3102					endif 
3102 18 0f				jr .totnxt 
3104			 
3104			.totsp:         ; on a space, find next char which should be upper 
3104			 
3104					if DEBUG_FORTH_WORDS 
3104						DMARK "TC4" 
3104						CALLMONITOR 
3104					endif 
3104					;; 
3104			 
3104 fe 20				cp ' ' 
3106 20 04				jr nz, .totsiptou 
3108 23					inc hl 
3109 7e					ld a, (hl) 
310a					if DEBUG_FORTH_WORDS 
310a						DMARK "TC5" 
310a						CALLMONITOR 
310a					endif 
310a 18 f8				jr .totsp 
310c fe 00		.totsiptou:    cp 0 
310e 28 08				jr z, .totdone 
3110					; not space and not zero term so upper case it 
3110 cd 83 0e				call to_upper 
3113			 
3113					if DEBUG_FORTH_WORDS 
3113						DMARK "TC6" 
3113						CALLMONITOR 
3113					endif 
3113			 
3113			 
3113			.totnxt: 
3113			 
3113 77					ld (hl), a 
3114 23					inc hl 
3115					if DEBUG_FORTH_WORDS 
3115						DMARK "TC7" 
3115						CALLMONITOR 
3115					endif 
3115 c3 f5 30				jp .tot 
3118			 
3118					 
3118			 
3118			 
3118			; for each char convert to low 
3118					 
3118			.totdone: 
3118					if DEBUG_FORTH_WORDS 
3118						DMARK "TCd" 
3118						CALLMONITOR 
3118					endif 
3118					NEXTW 
3118 c3 63 1a			jp macro_next 
311b				endm 
# End of macro NEXTW
311b			 
311b			.SUBSTR: 
311b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
311b 48				db WORD_SYS_CORE+52             
311c 79 31			dw .LEFT            
311e 07				db 6 + 1 
311f .. 00			db "SUBSTR",0              
3126				endm 
# End of macro CWHEAD
3126			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3126			 
3126					if DEBUG_FORTH_WORDS_KEY 
3126						DMARK "SST" 
3126 f5				push af  
3127 3a 3b 31			ld a, (.dmark)  
312a 32 77 fb			ld (debug_mark),a  
312d 3a 3c 31			ld a, (.dmark+1)  
3130 32 78 fb			ld (debug_mark+1),a  
3133 3a 3d 31			ld a, (.dmark+2)  
3136 32 79 fb			ld (debug_mark+2),a  
3139 18 03			jr .pastdmark  
313b ..			.dmark: db "SST"  
313e f1			.pastdmark: pop af  
313f			endm  
# End of macro DMARK
313f						CALLMONITOR 
313f cd 04 13			call break_point_state  
3142				endm  
# End of macro CALLMONITOR
3142					endif 
3142			; TODO check string type 
3142					FORTH_DSP_VALUEHL 
3142 cd 29 19			call macro_dsp_valuehl 
3145				endm 
# End of macro FORTH_DSP_VALUEHL
3145			 
3145 e5					push hl      ; string length 
3146			 
3146					FORTH_DSP_POP 
3146 cd a9 19			call macro_forth_dsp_pop 
3149				endm 
# End of macro FORTH_DSP_POP
3149			 
3149					FORTH_DSP_VALUEHL 
3149 cd 29 19			call macro_dsp_valuehl 
314c				endm 
# End of macro FORTH_DSP_VALUEHL
314c			 
314c e5					push hl     ; start char 
314d			 
314d					FORTH_DSP_POP 
314d cd a9 19			call macro_forth_dsp_pop 
3150				endm 
# End of macro FORTH_DSP_POP
3150			 
3150			 
3150					FORTH_DSP_VALUE 
3150 cd 12 19			call macro_forth_dsp_value 
3153				endm 
# End of macro FORTH_DSP_VALUE
3153			 
3153 d1					pop de    ; get start post offset 
3154			 
3154 19					add hl, de    ; starting offset 
3155			 
3155 c1					pop bc 
3156 c5					push bc      ; grab size of string 
3157			 
3157 e5					push hl    ; save string start  
3158			 
3158 26 00				ld h, 0 
315a 69					ld l, c 
315b 23					inc hl 
315c 23					inc hl 
315d			 
315d cd dd 0f				call malloc 
3160				if DEBUG_FORTH_MALLOC_GUARD 
3160 cc 8d 3f				call z,malloc_error 
3163				endif 
3163			 
3163 eb					ex de, hl      ; save malloc area for string copy 
3164 e1					pop hl    ; get back source 
3165 c1					pop bc    ; get length of string back 
3166			 
3166 d5					push de    ; save malloc area for after we push 
3167 ed b0				ldir     ; copy substr 
3169			 
3169			 
3169 eb					ex de, hl 
316a 3e 00				ld a, 0 
316c 77					ld (hl), a   ; term substr 
316d			 
316d					 
316d e1					pop hl    ; get malloc so we can push it 
316e e5					push hl   ; save so we can free it afterwards 
316f			 
316f cd a0 18				call forth_push_str 
3172			 
3172 e1					pop hl 
3173 cd a7 10				call free 
3176			 
3176					 
3176					 
3176			 
3176			 
3176					NEXTW 
3176 c3 63 1a			jp macro_next 
3179				endm 
# End of macro NEXTW
3179			 
3179			.LEFT: 
3179				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3179 48				db WORD_SYS_CORE+52             
317a a1 31			dw .RIGHT            
317c 05				db 4 + 1 
317d .. 00			db "LEFT",0              
3182				endm 
# End of macro CWHEAD
3182			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3182					if DEBUG_FORTH_WORDS_KEY 
3182						DMARK "LEF" 
3182 f5				push af  
3183 3a 97 31			ld a, (.dmark)  
3186 32 77 fb			ld (debug_mark),a  
3189 3a 98 31			ld a, (.dmark+1)  
318c 32 78 fb			ld (debug_mark+1),a  
318f 3a 99 31			ld a, (.dmark+2)  
3192 32 79 fb			ld (debug_mark+2),a  
3195 18 03			jr .pastdmark  
3197 ..			.dmark: db "LEF"  
319a f1			.pastdmark: pop af  
319b			endm  
# End of macro DMARK
319b						CALLMONITOR 
319b cd 04 13			call break_point_state  
319e				endm  
# End of macro CALLMONITOR
319e					endif 
319e			 
319e					NEXTW 
319e c3 63 1a			jp macro_next 
31a1				endm 
# End of macro NEXTW
31a1			.RIGHT: 
31a1				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
31a1 48				db WORD_SYS_CORE+52             
31a2 ca 31			dw .STR2NUM            
31a4 06				db 5 + 1 
31a5 .. 00			db "RIGHT",0              
31ab				endm 
# End of macro CWHEAD
31ab			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
31ab					if DEBUG_FORTH_WORDS_KEY 
31ab						DMARK "RIG" 
31ab f5				push af  
31ac 3a c0 31			ld a, (.dmark)  
31af 32 77 fb			ld (debug_mark),a  
31b2 3a c1 31			ld a, (.dmark+1)  
31b5 32 78 fb			ld (debug_mark+1),a  
31b8 3a c2 31			ld a, (.dmark+2)  
31bb 32 79 fb			ld (debug_mark+2),a  
31be 18 03			jr .pastdmark  
31c0 ..			.dmark: db "RIG"  
31c3 f1			.pastdmark: pop af  
31c4			endm  
# End of macro DMARK
31c4						CALLMONITOR 
31c4 cd 04 13			call break_point_state  
31c7				endm  
# End of macro CALLMONITOR
31c7					endif 
31c7			 
31c7					NEXTW 
31c7 c3 63 1a			jp macro_next 
31ca				endm 
# End of macro NEXTW
31ca			 
31ca			 
31ca			.STR2NUM: 
31ca				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
31ca 48				db WORD_SYS_CORE+52             
31cb 02 32			dw .NUM2STR            
31cd 08				db 7 + 1 
31ce .. 00			db "STR2NUM",0              
31d6				endm 
# End of macro CWHEAD
31d6			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
31d6			 
31d6			 
31d6			; TODO STR type check to do 
31d6					if DEBUG_FORTH_WORDS_KEY 
31d6						DMARK "S2N" 
31d6 f5				push af  
31d7 3a eb 31			ld a, (.dmark)  
31da 32 77 fb			ld (debug_mark),a  
31dd 3a ec 31			ld a, (.dmark+1)  
31e0 32 78 fb			ld (debug_mark+1),a  
31e3 3a ed 31			ld a, (.dmark+2)  
31e6 32 79 fb			ld (debug_mark+2),a  
31e9 18 03			jr .pastdmark  
31eb ..			.dmark: db "S2N"  
31ee f1			.pastdmark: pop af  
31ef			endm  
# End of macro DMARK
31ef						CALLMONITOR 
31ef cd 04 13			call break_point_state  
31f2				endm  
# End of macro CALLMONITOR
31f2					endif 
31f2			 
31f2					;FORTH_DSP 
31f2					FORTH_DSP_VALUE 
31f2 cd 12 19			call macro_forth_dsp_value 
31f5				endm 
# End of macro FORTH_DSP_VALUE
31f5					;inc hl 
31f5			 
31f5 eb					ex de, hl 
31f6					if DEBUG_FORTH_WORDS 
31f6						DMARK "S2a" 
31f6						CALLMONITOR 
31f6					endif 
31f6 cd 0b 0f				call string_to_uint16 
31f9			 
31f9					if DEBUG_FORTH_WORDS 
31f9						DMARK "S2b" 
31f9						CALLMONITOR 
31f9					endif 
31f9			;		push hl 
31f9					FORTH_DSP_POP 
31f9 cd a9 19			call macro_forth_dsp_pop 
31fc				endm 
# End of macro FORTH_DSP_POP
31fc			;		pop hl 
31fc					 
31fc					if DEBUG_FORTH_WORDS 
31fc						DMARK "S2b" 
31fc						CALLMONITOR 
31fc					endif 
31fc cd 8e 18				call forth_push_numhl	 
31ff			 
31ff				 
31ff				       NEXTW 
31ff c3 63 1a			jp macro_next 
3202				endm 
# End of macro NEXTW
3202			.NUM2STR: 
3202				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3202 48				db WORD_SYS_CORE+52             
3203 11 32			dw .CONCAT            
3205 08				db 7 + 1 
3206 .. 00			db "NUM2STR",0              
320e				endm 
# End of macro CWHEAD
320e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
320e			 
320e			;		; malloc a string to target 
320e			;		ld hl, 10     ; TODO max string size should be fine 
320e			;		call malloc 
320e			;		push hl    ; save malloc location 
320e			; 
320e			; 
320e			;; TODO check int type 
320e			;		FORTH_DSP_VALUEHL 
320e			;		ld a, l 
320e			;		call DispAToASCII   
320e			;;TODO need to chage above call to dump into string 
320e			; 
320e			; 
320e			 
320e				       NEXTW 
320e c3 63 1a			jp macro_next 
3211				endm 
# End of macro NEXTW
3211			 
3211			.CONCAT: 
3211				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3211 48				db WORD_SYS_CORE+52             
3212 70 32			dw .FIND            
3214 07				db 6 + 1 
3215 .. 00			db "CONCAT",0              
321c				endm 
# End of macro CWHEAD
321c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
321c			 
321c			; TODO check string type 
321c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
321c			 
321c					if DEBUG_FORTH_WORDS_KEY 
321c						DMARK "CON" 
321c f5				push af  
321d 3a 31 32			ld a, (.dmark)  
3220 32 77 fb			ld (debug_mark),a  
3223 3a 32 32			ld a, (.dmark+1)  
3226 32 78 fb			ld (debug_mark+1),a  
3229 3a 33 32			ld a, (.dmark+2)  
322c 32 79 fb			ld (debug_mark+2),a  
322f 18 03			jr .pastdmark  
3231 ..			.dmark: db "CON"  
3234 f1			.pastdmark: pop af  
3235			endm  
# End of macro DMARK
3235						CALLMONITOR 
3235 cd 04 13			call break_point_state  
3238				endm  
# End of macro CALLMONITOR
3238					endif 
3238			 
3238			 
3238					FORTH_DSP_VALUE 
3238 cd 12 19			call macro_forth_dsp_value 
323b				endm 
# End of macro FORTH_DSP_VALUE
323b e5					push hl   ; s2 
323c			 
323c					FORTH_DSP_POP 
323c cd a9 19			call macro_forth_dsp_pop 
323f				endm 
# End of macro FORTH_DSP_POP
323f			 
323f					FORTH_DSP_VALUE 
323f cd 12 19			call macro_forth_dsp_value 
3242				endm 
# End of macro FORTH_DSP_VALUE
3242			 
3242 e5					push hl   ; s1 
3243			 
3243					FORTH_DSP_POP 
3243 cd a9 19			call macro_forth_dsp_pop 
3246				endm 
# End of macro FORTH_DSP_POP
3246					 
3246			 
3246					; copy s1 
3246			 
3246				 
3246					; save ptr 
3246 e1					pop hl  
3247 e5					push hl 
3248 3e 00				ld a, 0 
324a cd 7f 0f				call strlent 
324d					;inc hl    ; zer0 
324d 06 00				ld b, 0 
324f 4d					ld c, l 
3250 e1					pop hl		 
3251 11 32 ee				ld de, scratch	 
3254					if DEBUG_FORTH_WORDS 
3254						DMARK "CO1" 
3254						CALLMONITOR 
3254					endif 
3254 ed b0				ldir 
3256			 
3256 e1					pop hl 
3257 e5					push hl 
3258 d5					push de 
3259			 
3259			 
3259 3e 00				ld a, 0 
325b cd 7f 0f				call strlent 
325e 23					inc hl    ; zer0 
325f 23					inc hl 
3260 06 00				ld b, 0 
3262 4d					ld c, l 
3263 d1					pop de 
3264 e1					pop hl		 
3265					if DEBUG_FORTH_WORDS 
3265						DMARK "CO2" 
3265						CALLMONITOR 
3265					endif 
3265 ed b0				ldir 
3267			 
3267			 
3267			 
3267 21 32 ee				ld hl, scratch 
326a					if DEBUG_FORTH_WORDS 
326a						DMARK "CO5" 
326a						CALLMONITOR 
326a					endif 
326a			 
326a cd a0 18				call forth_push_str 
326d			 
326d			 
326d			 
326d			 
326d				       NEXTW 
326d c3 63 1a			jp macro_next 
3270				endm 
# End of macro NEXTW
3270			 
3270			 
3270			.FIND: 
3270				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3270 4b				db WORD_SYS_CORE+55             
3271 be 32			dw .LEN            
3273 05				db 4 + 1 
3274 .. 00			db "FIND",0              
3279				endm 
# End of macro CWHEAD
3279			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3279			 
3279					if DEBUG_FORTH_WORDS_KEY 
3279						DMARK "FND" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 77 fb			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 78 fb			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 79 fb			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "FND"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292						CALLMONITOR 
3292 cd 04 13			call break_point_state  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295			 
3295			; TODO check string type 
3295					FORTH_DSP_VALUE 
3295 cd 12 19			call macro_forth_dsp_value 
3298				endm 
# End of macro FORTH_DSP_VALUE
3298			 
3298 e5					push hl    
3299 7e					ld a,(hl)    ; char to find   
329a			; TODO change char to substr 
329a			 
329a f5					push af 
329b					 
329b			 
329b			 
329b					if DEBUG_FORTH_WORDS 
329b						DMARK "FN1" 
329b						CALLMONITOR 
329b					endif 
329b			 
329b					FORTH_DSP_POP 
329b cd a9 19			call macro_forth_dsp_pop 
329e				endm 
# End of macro FORTH_DSP_POP
329e			 
329e					; string to search 
329e			 
329e					FORTH_DSP_VALUE 
329e cd 12 19			call macro_forth_dsp_value 
32a1				endm 
# End of macro FORTH_DSP_VALUE
32a1			 
32a1 d1					pop de  ; d is char to find  
32a2			 
32a2					if DEBUG_FORTH_WORDS 
32a2						DMARK "FN2" 
32a2						CALLMONITOR 
32a2					endif 
32a2					 
32a2 01 00 00				ld bc, 0 
32a5 7e			.findchar:      ld a,(hl) 
32a6 fe 00				cp 0   		 
32a8 28 0b				jr z, .finddone     
32aa ba					cp d 
32ab 28 04				jr z, .foundchar 
32ad 03					inc bc 
32ae 23					inc hl 
32af					if DEBUG_FORTH_WORDS 
32af						DMARK "FN3" 
32af						CALLMONITOR 
32af					endif 
32af 18 f4				jr .findchar 
32b1			 
32b1			 
32b1 c5			.foundchar:	push bc 
32b2 e1					pop hl 
32b3 18 03				jr .findexit 
32b5			 
32b5			 
32b5							 
32b5			 
32b5			.finddone:     ; got to end of string with no find 
32b5 21 00 00				ld hl, 0 
32b8			.findexit: 
32b8			 
32b8					if DEBUG_FORTH_WORDS 
32b8						DMARK "FNd" 
32b8						CALLMONITOR 
32b8					endif 
32b8 cd 8e 18			call forth_push_numhl 
32bb			 
32bb				       NEXTW 
32bb c3 63 1a			jp macro_next 
32be				endm 
# End of macro NEXTW
32be			 
32be			.LEN: 
32be				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
32be 4c				db WORD_SYS_CORE+56             
32bf f3 32			dw .CHAR            
32c1 06				db 5 + 1 
32c2 .. 00			db "COUNT",0              
32c8				endm 
# End of macro CWHEAD
32c8			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
32c8			 
32c8					if DEBUG_FORTH_WORDS_KEY 
32c8						DMARK "CNT" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 77 fb			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 78 fb			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 79 fb			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "CNT"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd 04 13			call break_point_state  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4			; TODO check string type 
32e4					FORTH_DSP 
32e4 cd 0e 19			call macro_forth_dsp 
32e7				endm 
# End of macro FORTH_DSP
32e7					;v5FORTH_DSP_VALUE 
32e7			 
32e7 23					inc hl 
32e8			 
32e8 3e 00				ld a, 0 
32ea cd 7f 0f				call strlent 
32ed			 
32ed cd 8e 18				call forth_push_numhl 
32f0			 
32f0			 
32f0			 
32f0				       NEXTW 
32f0 c3 63 1a			jp macro_next 
32f3				endm 
# End of macro NEXTW
32f3			.CHAR: 
32f3				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
32f3 4d				db WORD_SYS_CORE+57             
32f4 29 33			dw .ENDSTR            
32f6 05				db 4 + 1 
32f7 .. 00			db "CHAR",0              
32fc				endm 
# End of macro CWHEAD
32fc			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
32fc					if DEBUG_FORTH_WORDS_KEY 
32fc						DMARK "CHR" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 77 fb			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 78 fb			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 79 fb			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "CHR"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						CALLMONITOR 
3315 cd 04 13			call break_point_state  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318					FORTH_DSP 
3318 cd 0e 19			call macro_forth_dsp 
331b				endm 
# End of macro FORTH_DSP
331b					;v5 FORTH_DSP_VALUE 
331b 23					inc hl      ; now at start of numeric as string 
331c			 
331c			;		push hl 
331c			 
331c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331c cd a9 19			call macro_forth_dsp_pop 
331f				endm 
# End of macro FORTH_DSP_POP
331f			 
331f			;		pop hl 
331f			 
331f					; push the content of a onto the stack as a value 
331f			 
331f 7e					ld a,(hl)   ; get char 
3320 26 00				ld h,0 
3322 6f					ld l,a 
3323 cd 8e 18				call forth_push_numhl 
3326			 
3326				       NEXTW 
3326 c3 63 1a			jp macro_next 
3329				endm 
# End of macro NEXTW
3329			 
3329			 
3329			 
3329			 
3329			.ENDSTR: 
3329			; eof 
3329			 
# End of file forth_words_str.asm
3329			include "forth_words_key.asm" 
3329			 
3329			; | ## Keyboard Words 
3329			 
3329			.KEY: 
3329				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
3329 3e				db WORD_SYS_CORE+42             
332a 59 33			dw .WAITK            
332c 04				db 3 + 1 
332d .. 00			db "KEY",0              
3331				endm 
# End of macro CWHEAD
3331			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
3331			 
3331					if DEBUG_FORTH_WORDS_KEY 
3331						DMARK "KEY" 
3331 f5				push af  
3332 3a 46 33			ld a, (.dmark)  
3335 32 77 fb			ld (debug_mark),a  
3338 3a 47 33			ld a, (.dmark+1)  
333b 32 78 fb			ld (debug_mark+1),a  
333e 3a 48 33			ld a, (.dmark+2)  
3341 32 79 fb			ld (debug_mark+2),a  
3344 18 03			jr .pastdmark  
3346 ..			.dmark: db "KEY"  
3349 f1			.pastdmark: pop af  
334a			endm  
# End of macro DMARK
334a						CALLMONITOR 
334a cd 04 13			call break_point_state  
334d				endm  
# End of macro CALLMONITOR
334d					endif 
334d			; TODO currently waits 
334d cd 1b 55				call cin_wait 
3350 6f					ld l, a 
3351 26 00				ld h, 0 
3353 cd 8e 18				call forth_push_numhl 
3356					NEXTW 
3356 c3 63 1a			jp macro_next 
3359				endm 
# End of macro NEXTW
3359			.WAITK: 
3359				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
3359 3f				db WORD_SYS_CORE+43             
335a 8b 33			dw .ACCEPT            
335c 06				db 5 + 1 
335d .. 00			db "WAITK",0              
3363				endm 
# End of macro CWHEAD
3363			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
3363					if DEBUG_FORTH_WORDS_KEY 
3363						DMARK "WAI" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 77 fb			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 78 fb			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 79 fb			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "WAI"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c						CALLMONITOR 
337c cd 04 13			call break_point_state  
337f				endm  
# End of macro CALLMONITOR
337f					endif 
337f cd 1b 55				call cin_wait 
3382 6f					ld l, a 
3383 26 00				ld h, 0 
3385 cd 8e 18				call forth_push_numhl 
3388					NEXTW 
3388 c3 63 1a			jp macro_next 
338b				endm 
# End of macro NEXTW
338b			.ACCEPT: 
338b				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
338b 40				db WORD_SYS_CORE+44             
338c cd 33			dw .EDIT            
338e 07				db 6 + 1 
338f .. 00			db "ACCEPT",0              
3396				endm 
# End of macro CWHEAD
3396			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
3396					; TODO crashes on push 
3396					if DEBUG_FORTH_WORDS_KEY 
3396						DMARK "ACC" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 77 fb			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 78 fb			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 79 fb			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "ACC"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd 04 13			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2 21 30 f0				ld hl, os_input 
33b5 3e 00				ld a, 0 
33b7 77					ld (hl),a 
33b8 3a 5b f8				ld a,(f_cursor_ptr) 
33bb 16 64				ld d, 100 
33bd 0e 00				ld c, 0 
33bf 1e 28				ld e, 40 
33c1 cd 43 0b				call input_str 
33c4					; TODO perhaps do a type check and wrap in quotes if not a number 
33c4 21 30 f0				ld hl, os_input 
33c7					if DEBUG_FORTH_WORDS 
33c7						DMARK "AC1" 
33c7						CALLMONITOR 
33c7					endif 
33c7 cd a0 18				call forth_push_str 
33ca					NEXTW 
33ca c3 63 1a			jp macro_next 
33cd				endm 
# End of macro NEXTW
33cd			 
33cd			.EDIT: 
33cd				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
33cd 40				db WORD_SYS_CORE+44             
33ce 3a 34			dw .ENDKEY            
33d0 05				db 4 + 1 
33d1 .. 00			db "EDIT",0              
33d6				endm 
# End of macro CWHEAD
33d6			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
33d6			 
33d6					; TODO does not copy from stack 
33d6					if DEBUG_FORTH_WORDS_KEY 
33d6						DMARK "EDT" 
33d6 f5				push af  
33d7 3a eb 33			ld a, (.dmark)  
33da 32 77 fb			ld (debug_mark),a  
33dd 3a ec 33			ld a, (.dmark+1)  
33e0 32 78 fb			ld (debug_mark+1),a  
33e3 3a ed 33			ld a, (.dmark+2)  
33e6 32 79 fb			ld (debug_mark+2),a  
33e9 18 03			jr .pastdmark  
33eb ..			.dmark: db "EDT"  
33ee f1			.pastdmark: pop af  
33ef			endm  
# End of macro DMARK
33ef						CALLMONITOR 
33ef cd 04 13			call break_point_state  
33f2				endm  
# End of macro CALLMONITOR
33f2					endif 
33f2			 
33f2					FORTH_DSP 
33f2 cd 0e 19			call macro_forth_dsp 
33f5				endm 
# End of macro FORTH_DSP
33f5					;v5 FORTH_DSP_VALUE 
33f5 23					inc hl    ; TODO do type check 
33f6			 
33f6 e5					push hl 
33f7 3e 00				ld a, 0 
33f9 cd 7f 0f				call strlent 
33fc 23					inc hl 
33fd			 
33fd 06 00				ld b, 0 
33ff 4d					ld c, l 
3400			 
3400 e1					pop hl 
3401 11 30 f0				ld de, os_input 
3404					if DEBUG_FORTH_WORDS_KEY 
3404						DMARK "EDc" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 77 fb			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 78 fb			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 79 fb			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "EDc"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd 04 13			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420 ed b0				ldir 
3422			 
3422			 
3422 21 30 f0				ld hl, os_input 
3425					;ld a, 0 
3425					;ld (hl),a 
3425 3a 5b f8				ld a,(f_cursor_ptr) 
3428 16 64				ld d, 100 
342a 0e 00				ld c, 0 
342c 1e 28				ld e, 40 
342e cd 43 0b				call input_str 
3431					; TODO perhaps do a type check and wrap in quotes if not a number 
3431 21 30 f0				ld hl, os_input 
3434					if DEBUG_FORTH_WORDS 
3434						DMARK "ED1" 
3434						CALLMONITOR 
3434					endif 
3434 cd a0 18				call forth_push_str 
3437					NEXTW 
3437 c3 63 1a			jp macro_next 
343a				endm 
# End of macro NEXTW
343a			 
343a			 
343a			 
343a			.ENDKEY: 
343a			; eof 
343a			 
# End of file forth_words_key.asm
343a			 
343a			if STORAGE_SE 
343a			   	include "forth_words_storage.asm" 
343a			 
343a			; | ## Fixed Storage Words 
343a			 
343a			 
343a			.BREAD: 
343a			  
343a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
343a 3a				db WORD_SYS_CORE+38             
343b 7b 34			dw .BWRITE            
343d 06				db 5 + 1 
343e .. 00			db "BREAD",0              
3444				endm 
# End of macro CWHEAD
3444			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
3444				 
3444					if DEBUG_FORTH_WORDS_KEY 
3444						DMARK "BRD" 
3444 f5				push af  
3445 3a 59 34			ld a, (.dmark)  
3448 32 77 fb			ld (debug_mark),a  
344b 3a 5a 34			ld a, (.dmark+1)  
344e 32 78 fb			ld (debug_mark+1),a  
3451 3a 5b 34			ld a, (.dmark+2)  
3454 32 79 fb			ld (debug_mark+2),a  
3457 18 03			jr .pastdmark  
3459 ..			.dmark: db "BRD"  
345c f1			.pastdmark: pop af  
345d			endm  
# End of macro DMARK
345d						CALLMONITOR 
345d cd 04 13			call break_point_state  
3460				endm  
# End of macro CALLMONITOR
3460					endif 
3460			 
3460				FORTH_DSP_VALUEHL 
3460 cd 29 19			call macro_dsp_valuehl 
3463				endm 
# End of macro FORTH_DSP_VALUEHL
3463			 
3463				FORTH_DSP_POP 
3463 cd a9 19			call macro_forth_dsp_pop 
3466				endm 
# End of macro FORTH_DSP_POP
3466			 
3466				; calc block address 
3466			 
3466 eb				ex de, hl 
3467 3e 40			ld a, STORE_BLOCK_PHY 
3469 cd 99 0a			call Mult16 
346c			 
346c			 
346c 11 62 f8			ld de, store_page 
346f			 
346f					if DEBUG_FORTH_WORDS 
346f						DMARK "BR1" 
346f						CALLMONITOR 
346f					endif 
346f			 
346f cd 0c 03			call storage_read_block 
3472			 
3472 21 64 f8		        ld hl, store_page+2 
3475					if DEBUG_FORTH_WORDS 
3475						DMARK "BR2" 
3475						CALLMONITOR 
3475					endif 
3475 cd a0 18			call forth_push_str 
3478			 
3478			 
3478					NEXTW 
3478 c3 63 1a			jp macro_next 
347b				endm 
# End of macro NEXTW
347b			.BWRITE: 
347b				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
347b 3a				db WORD_SYS_CORE+38             
347c d8 34			dw .BUPD            
347e 07				db 6 + 1 
347f .. 00			db "BWRITE",0              
3486				endm 
# End of macro CWHEAD
3486			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
3486			 
3486					if DEBUG_FORTH_WORDS_KEY 
3486						DMARK "BWR" 
3486 f5				push af  
3487 3a 9b 34			ld a, (.dmark)  
348a 32 77 fb			ld (debug_mark),a  
348d 3a 9c 34			ld a, (.dmark+1)  
3490 32 78 fb			ld (debug_mark+1),a  
3493 3a 9d 34			ld a, (.dmark+2)  
3496 32 79 fb			ld (debug_mark+2),a  
3499 18 03			jr .pastdmark  
349b ..			.dmark: db "BWR"  
349e f1			.pastdmark: pop af  
349f			endm  
# End of macro DMARK
349f						CALLMONITOR 
349f cd 04 13			call break_point_state  
34a2				endm  
# End of macro CALLMONITOR
34a2					endif 
34a2			 
34a2				FORTH_DSP_VALUEHL 
34a2 cd 29 19			call macro_dsp_valuehl 
34a5				endm 
# End of macro FORTH_DSP_VALUEHL
34a5			 
34a5				; calc block address 
34a5			 
34a5 eb				ex de, hl 
34a6 3e 40			ld a, STORE_BLOCK_PHY 
34a8 cd 99 0a			call Mult16 
34ab			 
34ab e5				push hl         ; address 
34ac			 
34ac				FORTH_DSP_POP 
34ac cd a9 19			call macro_forth_dsp_pop 
34af				endm 
# End of macro FORTH_DSP_POP
34af			 
34af				FORTH_DSP_VALUEHL 
34af cd 29 19			call macro_dsp_valuehl 
34b2				endm 
# End of macro FORTH_DSP_VALUEHL
34b2			 
34b2				FORTH_DSP_POP 
34b2 cd a9 19			call macro_forth_dsp_pop 
34b5				endm 
# End of macro FORTH_DSP_POP
34b5			 
34b5 cd 11 09			call storage_clear_page 
34b8			 
34b8				; copy string to store page 
34b8			 
34b8 e5				push hl     ; save string address 
34b9			 
34b9 3e 00			ld a, 0 
34bb cd 7f 0f			call strlent 
34be			 
34be 23				inc hl 
34bf			 
34bf 4d				ld c, l 
34c0 06 00			ld b, 0 
34c2			 
34c2 e1				pop hl 
34c3 11 64 f8			ld de, store_page + 2 
34c6					if DEBUG_FORTH_WORDS 
34c6						DMARK "BW1" 
34c6						CALLMONITOR 
34c6					endif 
34c6 ed b0			ldir 
34c8			 
34c8			 
34c8				; poke the start of the block with flags to prevent high level file ops hitting the block 
34c8			 
34c8 21 ff ff			ld hl, $ffff 
34cb			 
34cb 22 62 f8			ld (store_page), hl	 
34ce				 
34ce e1				pop hl    ; get address 
34cf 11 62 f8			ld de, store_page 
34d2			 
34d2					if DEBUG_FORTH_WORDS 
34d2						DMARK "BW2" 
34d2						CALLMONITOR 
34d2					endif 
34d2			 
34d2 cd 55 03			call storage_write_block 
34d5			 
34d5					NEXTW 
34d5 c3 63 1a			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8			 
34d8			.BUPD: 
34d8				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
34d8 3a				db WORD_SYS_CORE+38             
34d9 12 35			dw .BYID            
34db 05				db 4 + 1 
34dc .. 00			db "BUPD",0              
34e1				endm 
# End of macro CWHEAD
34e1			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
34e1			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
34e1			; | | or completely different file system structure. 
34e1			 
34e1					if DEBUG_FORTH_WORDS_KEY 
34e1						DMARK "BUD" 
34e1 f5				push af  
34e2 3a f6 34			ld a, (.dmark)  
34e5 32 77 fb			ld (debug_mark),a  
34e8 3a f7 34			ld a, (.dmark+1)  
34eb 32 78 fb			ld (debug_mark+1),a  
34ee 3a f8 34			ld a, (.dmark+2)  
34f1 32 79 fb			ld (debug_mark+2),a  
34f4 18 03			jr .pastdmark  
34f6 ..			.dmark: db "BUD"  
34f9 f1			.pastdmark: pop af  
34fa			endm  
# End of macro DMARK
34fa						CALLMONITOR 
34fa cd 04 13			call break_point_state  
34fd				endm  
# End of macro CALLMONITOR
34fd					endif 
34fd			 
34fd				FORTH_DSP_VALUEHL 
34fd cd 29 19			call macro_dsp_valuehl 
3500				endm 
# End of macro FORTH_DSP_VALUEHL
3500			 
3500				; calc block address 
3500			 
3500 eb				ex de, hl 
3501 3e 40			ld a, STORE_BLOCK_PHY 
3503 cd 99 0a			call Mult16 
3506			 
3506				FORTH_DSP_POP 
3506 cd a9 19			call macro_forth_dsp_pop 
3509				endm 
# End of macro FORTH_DSP_POP
3509			 
3509			 
3509 11 62 f8			ld de, store_page 
350c			 
350c					if DEBUG_FORTH_WORDS 
350c						DMARK "BUe" 
350c						CALLMONITOR 
350c					endif 
350c			 
350c cd 55 03			call storage_write_block 
350f			 
350f					NEXTW 
350f c3 63 1a			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			 
3512			.BYID: 
3512				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
3512 3a				db WORD_SYS_CORE+38             
3513 1e 35			dw .BYNAME            
3515 05				db 4 + 1 
3516 .. 00			db "BYID",0              
351b				endm 
# End of macro CWHEAD
351b			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
351b					NEXTW 
351b c3 63 1a			jp macro_next 
351e				endm 
# End of macro NEXTW
351e			.BYNAME: 
351e				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
351e 3a				db WORD_SYS_CORE+38             
351f 2c 35			dw .DIR            
3521 07				db 6 + 1 
3522 .. 00			db "BYNAME",0              
3529				endm 
# End of macro CWHEAD
3529			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
3529					NEXTW 
3529 c3 63 1a			jp macro_next 
352c				endm 
# End of macro NEXTW
352c			 
352c			.DIR: 
352c				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
352c 3a				db WORD_SYS_CORE+38             
352d a4 35			dw .SAVE            
352f 04				db 3 + 1 
3530 .. 00			db "DIR",0              
3534				endm 
# End of macro CWHEAD
3534			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
3534			 
3534					if DEBUG_FORTH_WORDS_KEY 
3534						DMARK "DIR" 
3534 f5				push af  
3535 3a 49 35			ld a, (.dmark)  
3538 32 77 fb			ld (debug_mark),a  
353b 3a 4a 35			ld a, (.dmark+1)  
353e 32 78 fb			ld (debug_mark+1),a  
3541 3a 4b 35			ld a, (.dmark+2)  
3544 32 79 fb			ld (debug_mark+2),a  
3547 18 03			jr .pastdmark  
3549 ..			.dmark: db "DIR"  
354c f1			.pastdmark: pop af  
354d			endm  
# End of macro DMARK
354d						CALLMONITOR 
354d cd 04 13			call break_point_state  
3550				endm  
# End of macro CALLMONITOR
3550					endif 
3550 cd a1 03			call storage_get_block_0 
3553			 
3553 21 62 f8			ld hl, store_page     ; get current id count 
3556 46				ld b, (hl) 
3557 0e 00			ld c, 0    ; count of files   
3559					if DEBUG_FORTH_WORDS 
3559						DMARK "DI1" 
3559						CALLMONITOR 
3559					endif 
3559			 
3559				; check for empty drive 
3559			 
3559 3e 00			ld a, 0 
355b b8				cp b 
355c ca 92 35			jp z, .dirdone 
355f			 
355f				; for each of the current ids do a search for them and if found push to stack 
355f			 
355f c5			.diritem:	push bc 
3560 21 40 00				ld hl, STORE_BLOCK_PHY 
3563 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
3565 58					ld e,b 
3566			 
3566			;		if DEBUG_FORTH_WORDS 
3566			;			DMARK "DI2" 
3566			;			CALLMONITOR 
3566			;		endif 
3566			 
3566 cd 7a 05				call storage_findnextid 
3569			 
3569			;		if DEBUG_FORTH_WORDS 
3569			;			DMARK "DI3" 
3569			;			CALLMONITOR 
3569			;		endif 
3569			 
3569					; if found hl will be non zero 
3569			 
3569 cd 3f 0b				call ishlzero 
356c			;		ld a, l 
356c			;		add h 
356c			; 
356c			;		cp 0 
356c 28 21				jr z, .dirnotfound 
356e			 
356e					; increase count 
356e			 
356e c1					pop bc	 
356f 0c					inc c 
3570 c5					push bc 
3571					 
3571			 
3571					; get file header and push the file name 
3571			 
3571 11 62 f8				ld de, store_page 
3574 cd 0c 03				call storage_read_block 
3577			 
3577					; push file id to stack 
3577				 
3577 3a 62 f8				ld a, (store_page) 
357a 26 00				ld h, 0 
357c 6f					ld l, a 
357d cd 8e 18				call forth_push_numhl 
3580			 
3580					; push extent count to stack  
3580				 
3580 3a 64 f8				ld a, (store_page+2) 
3583 26 00				ld h, 0 
3585 6f					ld l, a 
3586 cd 8e 18				call forth_push_numhl 
3589			 
3589					; push file name 
3589			 
3589 21 65 f8				ld hl, store_page+3 
358c					if DEBUG_FORTH_WORDS 
358c						DMARK "DI5" 
358c						CALLMONITOR 
358c					endif 
358c cd a0 18				call forth_push_str 
358f					if DEBUG_FORTH_WORDS 
358f						DMARK "DI6" 
358f						CALLMONITOR 
358f					endif 
358f			.dirnotfound: 
358f c1					pop bc     
3590 10 cd				djnz .diritem 
3592				 
3592			.dirdone:	 
3592					if DEBUG_FORTH_WORDS 
3592						DMARK "DI7" 
3592						CALLMONITOR 
3592					endif 
3592			 
3592					; push a count of the dir items found 
3592			 
3592 26 00				ld h, 0 
3594 69					ld l, c 
3595 cd 8e 18				call forth_push_numhl 
3598			 
3598					; push the bank label 
3598			 
3598 cd a1 03				call storage_get_block_0 
359b			 
359b				 
359b 21 65 f8		 		ld hl, store_page+3 
359e			 
359e					if DEBUG_FORTH_WORDS 
359e						DMARK "DI8" 
359e						CALLMONITOR 
359e					endif 
359e cd a0 18				call forth_push_str 
35a1			 
35a1			 
35a1				 
35a1					NEXTW 
35a1 c3 63 1a			jp macro_next 
35a4				endm 
# End of macro NEXTW
35a4			.SAVE: 
35a4				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
35a4 3b				db WORD_SYS_CORE+39             
35a5 b0 35			dw .LOAD            
35a7 05				db 4 + 1 
35a8 .. 00			db "SAVE",0              
35ad				endm 
# End of macro CWHEAD
35ad			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
35ad					NEXTW 
35ad c3 63 1a			jp macro_next 
35b0				endm 
# End of macro NEXTW
35b0			.LOAD: 
35b0				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
35b0 3c				db WORD_SYS_CORE+40             
35b1 12 37			dw .BSAVE            
35b3 05				db 4 + 1 
35b4 .. 00			db "LOAD",0              
35b9				endm 
# End of macro CWHEAD
35b9			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
35b9			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
35b9			; | | The LOAD command can not be used in any user words or compound lines. 
35b9			 
35b9					; store_openext use it. If zero it is EOF 
35b9			 
35b9					; read block from current stream id 
35b9					; if the block does not contain zero term keep reading blocks until zero found 
35b9					; push the block to stack 
35b9					; save the block id to stream 
35b9			 
35b9			 
35b9					FORTH_DSP_VALUEHL 
35b9 cd 29 19			call macro_dsp_valuehl 
35bc				endm 
# End of macro FORTH_DSP_VALUEHL
35bc			 
35bc			;		push hl 
35bc			 
35bc				if DEBUG_STORESE 
35bc					DMARK "LOA" 
35bc f5				push af  
35bd 3a d1 35			ld a, (.dmark)  
35c0 32 77 fb			ld (debug_mark),a  
35c3 3a d2 35			ld a, (.dmark+1)  
35c6 32 78 fb			ld (debug_mark+1),a  
35c9 3a d3 35			ld a, (.dmark+2)  
35cc 32 79 fb			ld (debug_mark+2),a  
35cf 18 03			jr .pastdmark  
35d1 ..			.dmark: db "LOA"  
35d4 f1			.pastdmark: pop af  
35d5			endm  
# End of macro DMARK
35d5					CALLMONITOR 
35d5 cd 04 13			call break_point_state  
35d8				endm  
# End of macro CALLMONITOR
35d8				endif 
35d8					FORTH_DSP_POP 
35d8 cd a9 19			call macro_forth_dsp_pop 
35db				endm 
# End of macro FORTH_DSP_POP
35db			 
35db			;		pop hl 
35db			 
35db 65					ld h, l 
35dc 2e 00				ld l, 0 
35de			 
35de e5					push hl     ; stack holds current file id and extent to work with 
35df			 
35df			 
35df 11 62 f8				ld de, store_page      ; get block zero of file 
35e2				if DEBUG_STORESE 
35e2					DMARK "LO0" 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 77 fb			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 78 fb			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 79 fb			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "LO0"  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb					CALLMONITOR 
35fb cd 04 13			call break_point_state  
35fe				endm  
# End of macro CALLMONITOR
35fe				endif 
35fe cd 4a 07				call storage_read 
3601			 
3601 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
3604 32 58 f8				ld  (store_openmaxext),a   ; get our limit 
3607			 
3607				if DEBUG_STORESE 
3607					DMARK "LOE" 
3607 f5				push af  
3608 3a 1c 36			ld a, (.dmark)  
360b 32 77 fb			ld (debug_mark),a  
360e 3a 1d 36			ld a, (.dmark+1)  
3611 32 78 fb			ld (debug_mark+1),a  
3614 3a 1e 36			ld a, (.dmark+2)  
3617 32 79 fb			ld (debug_mark+2),a  
361a 18 03			jr .pastdmark  
361c ..			.dmark: db "LOE"  
361f f1			.pastdmark: pop af  
3620			endm  
# End of macro DMARK
3620					CALLMONITOR 
3620 cd 04 13			call break_point_state  
3623				endm  
# End of macro CALLMONITOR
3623				endif 
3623			 
3623			; TODO dont know why max extents are not present 
3623			;		cp 0 
3623			;		jp z, .loadeof     ; dont read past eof 
3623			 
3623			;		ld a, 1   ; start from the head of the file 
3623			 
3623 e1			.loadline:	pop hl 
3624 23					inc hl 
3625 3a 58 f8				ld  a, (store_openmaxext)   ; get our limit 
3628				if DEBUG_STORESE 
3628					DMARK "LOx" 
3628 f5				push af  
3629 3a 3d 36			ld a, (.dmark)  
362c 32 77 fb			ld (debug_mark),a  
362f 3a 3e 36			ld a, (.dmark+1)  
3632 32 78 fb			ld (debug_mark+1),a  
3635 3a 3f 36			ld a, (.dmark+2)  
3638 32 79 fb			ld (debug_mark+2),a  
363b 18 03			jr .pastdmark  
363d ..			.dmark: db "LOx"  
3640 f1			.pastdmark: pop af  
3641			endm  
# End of macro DMARK
3641					CALLMONITOR 
3641 cd 04 13			call break_point_state  
3644				endm  
# End of macro CALLMONITOR
3644				endif 
3644 3c					inc a 
3645 bd					cp l 
3646 ca f0 36				jp z, .loadeof 
3649 e5					push hl    ; save current extent 
364a			 
364a 11 62 f8				ld de, store_page 
364d			 
364d				if DEBUG_STORESE 
364d					DMARK "LO1" 
364d f5				push af  
364e 3a 62 36			ld a, (.dmark)  
3651 32 77 fb			ld (debug_mark),a  
3654 3a 63 36			ld a, (.dmark+1)  
3657 32 78 fb			ld (debug_mark+1),a  
365a 3a 64 36			ld a, (.dmark+2)  
365d 32 79 fb			ld (debug_mark+2),a  
3660 18 03			jr .pastdmark  
3662 ..			.dmark: db "LO1"  
3665 f1			.pastdmark: pop af  
3666			endm  
# End of macro DMARK
3666					CALLMONITOR 
3666 cd 04 13			call break_point_state  
3669				endm  
# End of macro CALLMONITOR
3669				endif 
3669 cd 4a 07				call storage_read 
366c			 
366c				if DEBUG_STORESE 
366c					DMARK "LO2" 
366c f5				push af  
366d 3a 81 36			ld a, (.dmark)  
3670 32 77 fb			ld (debug_mark),a  
3673 3a 82 36			ld a, (.dmark+1)  
3676 32 78 fb			ld (debug_mark+1),a  
3679 3a 83 36			ld a, (.dmark+2)  
367c 32 79 fb			ld (debug_mark+2),a  
367f 18 03			jr .pastdmark  
3681 ..			.dmark: db "LO2"  
3684 f1			.pastdmark: pop af  
3685			endm  
# End of macro DMARK
3685					CALLMONITOR 
3685 cd 04 13			call break_point_state  
3688				endm  
# End of macro CALLMONITOR
3688				endif 
3688 cd 3f 0b			call ishlzero 
368b			;	ld a, l 
368b			;	add h 
368b			;	cp 0 
368b 28 63			jr z, .loadeof 
368d			 
368d				; not eof so hl should point to data to exec 
368d			 
368d				; will need to add the FORTH_END_BUFFER flag 
368d			  
368d 21 64 f8			ld hl, store_page+2 
3690 01 ff 00			ld bc, 255 
3693 3e 00			ld a, 0 
3695 ed b1			cpir 
3697				if DEBUG_STORESE 
3697					DMARK "LOt" 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 77 fb			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 78 fb			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 79 fb			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "LOt"  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0					CALLMONITOR 
36b0 cd 04 13			call break_point_state  
36b3				endm  
# End of macro CALLMONITOR
36b3				endif 
36b3 2b				dec hl 
36b4 3e 20			ld a, ' ' 
36b6 77				ld (hl), a 
36b7 23				inc hl 
36b8 77				ld (hl), a 
36b9 23				inc hl 
36ba 77				ld (hl), a 
36bb 23				inc hl 
36bc 3e 7f			ld a, FORTH_END_BUFFER 
36be 77				ld (hl), a 
36bf			 
36bf				; TODO handle more than a single block read 
36bf			 
36bf			 
36bf 21 64 f8			ld hl, store_page+2 
36c2			 
36c2 22 33 f1			ld (os_tok_ptr), hl 
36c5			 
36c5				if DEBUG_STORESE 
36c5					DMARK "LO3" 
36c5 f5				push af  
36c6 3a da 36			ld a, (.dmark)  
36c9 32 77 fb			ld (debug_mark),a  
36cc 3a db 36			ld a, (.dmark+1)  
36cf 32 78 fb			ld (debug_mark+1),a  
36d2 3a dc 36			ld a, (.dmark+2)  
36d5 32 79 fb			ld (debug_mark+2),a  
36d8 18 03			jr .pastdmark  
36da ..			.dmark: db "LO3"  
36dd f1			.pastdmark: pop af  
36de			endm  
# End of macro DMARK
36de					CALLMONITOR 
36de cd 04 13			call break_point_state  
36e1				endm  
# End of macro CALLMONITOR
36e1				endif 
36e1			 
36e1 cd b1 1a			call forthparse 
36e4 cd f1 1a			call forthexec 
36e7 cd 08 1a			call forthexec_cleanup 
36ea			 
36ea				; go to next extent 
36ea			 
36ea				; get next block  or mark as eof 
36ea c3 23 36			jp .loadline 
36ed			 
36ed			 
36ed			 
36ed				       NEXTW 
36ed c3 63 1a			jp macro_next 
36f0				endm 
# End of macro NEXTW
36f0 3e 00		.loadeof:	ld a, 0 
36f2 32 59 f8				ld (store_openext), a 
36f5			 
36f5				if DEBUG_STORESE 
36f5					DMARK "LOF" 
36f5 f5				push af  
36f6 3a 0a 37			ld a, (.dmark)  
36f9 32 77 fb			ld (debug_mark),a  
36fc 3a 0b 37			ld a, (.dmark+1)  
36ff 32 78 fb			ld (debug_mark+1),a  
3702 3a 0c 37			ld a, (.dmark+2)  
3705 32 79 fb			ld (debug_mark+2),a  
3708 18 03			jr .pastdmark  
370a ..			.dmark: db "LOF"  
370d f1			.pastdmark: pop af  
370e			endm  
# End of macro DMARK
370e					CALLMONITOR 
370e cd 04 13			call break_point_state  
3711				endm  
# End of macro CALLMONITOR
3711				endif 
3711 c9					ret 
3712					;NEXTW 
3712			.BSAVE:   
3712			 
3712				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
3712 5a				db WORD_SYS_CORE+70             
3713 1f 37			dw .BLOAD            
3715 06				db 5 + 1 
3716 .. 00			db "BSAVE",0              
371c				endm 
# End of macro CWHEAD
371c			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
371c					NEXTW 
371c c3 63 1a			jp macro_next 
371f				endm 
# End of macro NEXTW
371f			.BLOAD: 
371f				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
371f 5b				db WORD_SYS_CORE+71             
3720 2c 37			dw .SEO            
3722 06				db 5 + 1 
3723 .. 00			db "BLOAD",0              
3729				endm 
# End of macro CWHEAD
3729			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
3729					NEXTW 
3729 c3 63 1a			jp macro_next 
372c				endm 
# End of macro NEXTW
372c			;;;; counter gap 
372c			 
372c			 
372c			.SEO: 
372c				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
372c 64				db WORD_SYS_CORE+80             
372d 4b 37			dw .SEI            
372f 04				db 3 + 1 
3730 .. 00			db "SEO",0              
3734				endm 
# End of macro CWHEAD
3734			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
3734			 
3734					; get port 
3734			 
3734					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3734 cd 29 19			call macro_dsp_valuehl 
3737				endm 
# End of macro FORTH_DSP_VALUEHL
3737			 
3737 e5					push hl    ; u2 - byte 
3738			 
3738					; destroy value TOS 
3738			 
3738					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3738 cd a9 19			call macro_forth_dsp_pop 
373b				endm 
# End of macro FORTH_DSP_POP
373b			 
373b					; get byte to send 
373b			 
373b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373b cd 29 19			call macro_dsp_valuehl 
373e				endm 
# End of macro FORTH_DSP_VALUEHL
373e			 
373e e5					push hl    ; u1 - addr 
373f			 
373f					; destroy value TOS 
373f			 
373f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373f cd a9 19			call macro_forth_dsp_pop 
3742				endm 
# End of macro FORTH_DSP_POP
3742			 
3742					; one value on hl get other one back 
3742			 
3742 d1					pop de   ; u1 - byte 
3743			 
3743 e1					pop hl   ; u2 - addr 
3744			 
3744					; TODO Send SPI byte 
3744			 
3744			 
3744 7b					ld a, e 
3745 cd ea 01				call se_writebyte 
3748			 
3748					 
3748			 
3748					NEXTW 
3748 c3 63 1a			jp macro_next 
374b				endm 
# End of macro NEXTW
374b			 
374b			.SEI: 
374b				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
374b 65				db WORD_SYS_CORE+81             
374c 65 37			dw .SFREE            
374e 04				db 3 + 1 
374f .. 00			db "SEI",0              
3753				endm 
# End of macro CWHEAD
3753			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
3753			 
3753					; get port 
3753			 
3753					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3753 cd 29 19			call macro_dsp_valuehl 
3756				endm 
# End of macro FORTH_DSP_VALUEHL
3756			 
3756			;		push hl 
3756			 
3756					; destroy value TOS 
3756			 
3756					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3756 cd a9 19			call macro_forth_dsp_pop 
3759				endm 
# End of macro FORTH_DSP_POP
3759			 
3759					; one value on hl get other one back 
3759			 
3759			;		pop hl 
3759			 
3759			 
3759					; TODO Get SPI byte 
3759			 
3759 cd 8c 02				call se_readbyte 
375c			 
375c 26 00				ld h, 0 
375e 6f					ld l, a 
375f cd 8e 18				call forth_push_numhl 
3762			 
3762					NEXTW 
3762 c3 63 1a			jp macro_next 
3765				endm 
# End of macro NEXTW
3765			 
3765			.SFREE: 
3765				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
3765 67				db WORD_SYS_CORE+83             
3766 94 37			dw .SIZE            
3768 06				db 5 + 1 
3769 .. 00			db "FFREE",0              
376f				endm 
# End of macro CWHEAD
376f			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
376f					if DEBUG_FORTH_WORDS_KEY 
376f						DMARK "FFR" 
376f f5				push af  
3770 3a 84 37			ld a, (.dmark)  
3773 32 77 fb			ld (debug_mark),a  
3776 3a 85 37			ld a, (.dmark+1)  
3779 32 78 fb			ld (debug_mark+1),a  
377c 3a 86 37			ld a, (.dmark+2)  
377f 32 79 fb			ld (debug_mark+2),a  
3782 18 03			jr .pastdmark  
3784 ..			.dmark: db "FFR"  
3787 f1			.pastdmark: pop af  
3788			endm  
# End of macro DMARK
3788						CALLMONITOR 
3788 cd 04 13			call break_point_state  
378b				endm  
# End of macro CALLMONITOR
378b					endif 
378b			 
378b cd c0 05				call storage_freeblocks 
378e			 
378e cd 8e 18				call forth_push_numhl 
3791			 
3791				       NEXTW 
3791 c3 63 1a			jp macro_next 
3794				endm 
# End of macro NEXTW
3794			.SIZE: 
3794				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
3794 67				db WORD_SYS_CORE+83             
3795 c8 37			dw .CREATE            
3797 05				db 4 + 1 
3798 .. 00			db "SIZE",0              
379d				endm 
# End of macro CWHEAD
379d			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
379d					if DEBUG_FORTH_WORDS_KEY 
379d						DMARK "SIZ" 
379d f5				push af  
379e 3a b2 37			ld a, (.dmark)  
37a1 32 77 fb			ld (debug_mark),a  
37a4 3a b3 37			ld a, (.dmark+1)  
37a7 32 78 fb			ld (debug_mark+1),a  
37aa 3a b4 37			ld a, (.dmark+2)  
37ad 32 79 fb			ld (debug_mark+2),a  
37b0 18 03			jr .pastdmark  
37b2 ..			.dmark: db "SIZ"  
37b5 f1			.pastdmark: pop af  
37b6			endm  
# End of macro DMARK
37b6						CALLMONITOR 
37b6 cd 04 13			call break_point_state  
37b9				endm  
# End of macro CALLMONITOR
37b9					endif 
37b9			 
37b9					FORTH_DSP_VALUEHL 
37b9 cd 29 19			call macro_dsp_valuehl 
37bc				endm 
# End of macro FORTH_DSP_VALUEHL
37bc			;		push hl 
37bc					FORTH_DSP_POP 
37bc cd a9 19			call macro_forth_dsp_pop 
37bf				endm 
# End of macro FORTH_DSP_POP
37bf			;		pop hl 
37bf cd 3b 03				call storage_file_size 
37c2			 
37c2 cd 8e 18				call forth_push_numhl 
37c5			  
37c5			 
37c5				       NEXTW 
37c5 c3 63 1a			jp macro_next 
37c8				endm 
# End of macro NEXTW
37c8			 
37c8			.CREATE: 
37c8				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
37c8 68				db WORD_SYS_CORE+84             
37c9 36 38			dw .APPEND            
37cb 07				db 6 + 1 
37cc .. 00			db "CREATE",0              
37d3				endm 
# End of macro CWHEAD
37d3			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
37d3			; | | e.g.  
37d3			; | | TestProgram CREATE 
37d3			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
37d3			; | |  
37d3			; | | Max file IDs are 255. 
37d3			; | |  
37d3					 
37d3					if DEBUG_FORTH_WORDS_KEY 
37d3						DMARK "CRT" 
37d3 f5				push af  
37d4 3a e8 37			ld a, (.dmark)  
37d7 32 77 fb			ld (debug_mark),a  
37da 3a e9 37			ld a, (.dmark+1)  
37dd 32 78 fb			ld (debug_mark+1),a  
37e0 3a ea 37			ld a, (.dmark+2)  
37e3 32 79 fb			ld (debug_mark+2),a  
37e6 18 03			jr .pastdmark  
37e8 ..			.dmark: db "CRT"  
37eb f1			.pastdmark: pop af  
37ec			endm  
# End of macro DMARK
37ec						CALLMONITOR 
37ec cd 04 13			call break_point_state  
37ef				endm  
# End of macro CALLMONITOR
37ef					endif 
37ef			;		call storage_get_block_0 
37ef			 
37ef					; TODO pop hl 
37ef			 
37ef					;v5 FORTH_DSP_VALUE 
37ef					FORTH_DSP_VALUE 
37ef cd 12 19			call macro_forth_dsp_value 
37f2				endm 
# End of macro FORTH_DSP_VALUE
37f2			 
37f2				if DEBUG_STORESE 
37f2					DMARK "CR1" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 77 fb			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 78 fb			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 79 fb			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "CR1"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b					CALLMONITOR 
380b cd 04 13			call break_point_state  
380e				endm  
# End of macro CALLMONITOR
380e				endif 
380e			;		push hl 
380e			;		FORTH_DSP_POP 
380e			;		pop hl 
380e			 
380e			;		inc hl   ; move past the type marker 
380e			 
380e cd f6 05				call storage_create 
3811			 
3811				if DEBUG_STORESE 
3811					DMARK "CT1" 
3811 f5				push af  
3812 3a 26 38			ld a, (.dmark)  
3815 32 77 fb			ld (debug_mark),a  
3818 3a 27 38			ld a, (.dmark+1)  
381b 32 78 fb			ld (debug_mark+1),a  
381e 3a 28 38			ld a, (.dmark+2)  
3821 32 79 fb			ld (debug_mark+2),a  
3824 18 03			jr .pastdmark  
3826 ..			.dmark: db "CT1"  
3829 f1			.pastdmark: pop af  
382a			endm  
# End of macro DMARK
382a					CALLMONITOR 
382a cd 04 13			call break_point_state  
382d				endm  
# End of macro CALLMONITOR
382d				endif 
382d			;		push hl 
382d					FORTH_DSP_POP 
382d cd a9 19			call macro_forth_dsp_pop 
3830				endm 
# End of macro FORTH_DSP_POP
3830			;		pop hl 
3830					; push file id to stack 
3830 cd 8e 18				call forth_push_numhl 
3833			 
3833			 
3833			 
3833				       NEXTW 
3833 c3 63 1a			jp macro_next 
3836				endm 
# End of macro NEXTW
3836			 
3836			.APPEND: 
3836				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
3836 69				db WORD_SYS_CORE+85             
3837 c7 38			dw .SDEL            
3839 07				db 6 + 1 
383a .. 00			db "APPEND",0              
3841				endm 
# End of macro CWHEAD
3841			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
3841			; | | e.g. 
3841			; | | Test CREATE      -> $01 
3841			; | | "A string to add to file" $01 APPEND 
3841			; | |  
3841			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
3841					if DEBUG_FORTH_WORDS_KEY 
3841						DMARK "APP" 
3841 f5				push af  
3842 3a 56 38			ld a, (.dmark)  
3845 32 77 fb			ld (debug_mark),a  
3848 3a 57 38			ld a, (.dmark+1)  
384b 32 78 fb			ld (debug_mark+1),a  
384e 3a 58 38			ld a, (.dmark+2)  
3851 32 79 fb			ld (debug_mark+2),a  
3854 18 03			jr .pastdmark  
3856 ..			.dmark: db "APP"  
3859 f1			.pastdmark: pop af  
385a			endm  
# End of macro DMARK
385a						CALLMONITOR 
385a cd 04 13			call break_point_state  
385d				endm  
# End of macro CALLMONITOR
385d					endif 
385d			 
385d					FORTH_DSP_VALUEHL 
385d cd 29 19			call macro_dsp_valuehl 
3860				endm 
# End of macro FORTH_DSP_VALUEHL
3860 e5					push hl 	; save file id 
3861			 
3861				if DEBUG_STORESE 
3861					DMARK "AP1" 
3861 f5				push af  
3862 3a 76 38			ld a, (.dmark)  
3865 32 77 fb			ld (debug_mark),a  
3868 3a 77 38			ld a, (.dmark+1)  
386b 32 78 fb			ld (debug_mark+1),a  
386e 3a 78 38			ld a, (.dmark+2)  
3871 32 79 fb			ld (debug_mark+2),a  
3874 18 03			jr .pastdmark  
3876 ..			.dmark: db "AP1"  
3879 f1			.pastdmark: pop af  
387a			endm  
# End of macro DMARK
387a					CALLMONITOR 
387a cd 04 13			call break_point_state  
387d				endm  
# End of macro CALLMONITOR
387d				endif 
387d					FORTH_DSP_POP 
387d cd a9 19			call macro_forth_dsp_pop 
3880				endm 
# End of macro FORTH_DSP_POP
3880			 
3880					FORTH_DSP_VALUEHL 
3880 cd 29 19			call macro_dsp_valuehl 
3883				endm 
# End of macro FORTH_DSP_VALUEHL
3883					;v5 FORTH_DSP_VALUE 
3883 e5					push hl 	; save ptr to string to save 
3884			 
3884				if DEBUG_STORESE 
3884					DMARK "AP1" 
3884 f5				push af  
3885 3a 99 38			ld a, (.dmark)  
3888 32 77 fb			ld (debug_mark),a  
388b 3a 9a 38			ld a, (.dmark+1)  
388e 32 78 fb			ld (debug_mark+1),a  
3891 3a 9b 38			ld a, (.dmark+2)  
3894 32 79 fb			ld (debug_mark+2),a  
3897 18 03			jr .pastdmark  
3899 ..			.dmark: db "AP1"  
389c f1			.pastdmark: pop af  
389d			endm  
# End of macro DMARK
389d					CALLMONITOR 
389d cd 04 13			call break_point_state  
38a0				endm  
# End of macro CALLMONITOR
38a0				endif 
38a0					FORTH_DSP_POP 
38a0 cd a9 19			call macro_forth_dsp_pop 
38a3				endm 
# End of macro FORTH_DSP_POP
38a3			 
38a3 d1					pop de 
38a4 e1					pop hl 
38a5				if DEBUG_STORESE 
38a5					DMARK "AP2" 
38a5 f5				push af  
38a6 3a ba 38			ld a, (.dmark)  
38a9 32 77 fb			ld (debug_mark),a  
38ac 3a bb 38			ld a, (.dmark+1)  
38af 32 78 fb			ld (debug_mark+1),a  
38b2 3a bc 38			ld a, (.dmark+2)  
38b5 32 79 fb			ld (debug_mark+2),a  
38b8 18 03			jr .pastdmark  
38ba ..			.dmark: db "AP2"  
38bd f1			.pastdmark: pop af  
38be			endm  
# End of macro DMARK
38be					CALLMONITOR 
38be cd 04 13			call break_point_state  
38c1				endm  
# End of macro CALLMONITOR
38c1				endif 
38c1					;inc de ; skip var type indicator 
38c1			 
38c1					; TODO how to append numerics???? 
38c1			 
38c1 cd d0 07				call storage_append		 
38c4			 
38c4				       NEXTW 
38c4 c3 63 1a			jp macro_next 
38c7				endm 
# End of macro NEXTW
38c7			.SDEL: 
38c7				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
38c7 6a				db WORD_SYS_CORE+86             
38c8 13 39			dw .OPEN            
38ca 05				db 4 + 1 
38cb .. 00			db "ERA",0              
38cf				endm 
# End of macro CWHEAD
38cf			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
38cf					FORTH_DSP_VALUEHL 
38cf cd 29 19			call macro_dsp_valuehl 
38d2				endm 
# End of macro FORTH_DSP_VALUEHL
38d2			;		push hl 	; save file id 
38d2			 
38d2					if DEBUG_FORTH_WORDS_KEY 
38d2						DMARK "ERA" 
38d2 f5				push af  
38d3 3a e7 38			ld a, (.dmark)  
38d6 32 77 fb			ld (debug_mark),a  
38d9 3a e8 38			ld a, (.dmark+1)  
38dc 32 78 fb			ld (debug_mark+1),a  
38df 3a e9 38			ld a, (.dmark+2)  
38e2 32 79 fb			ld (debug_mark+2),a  
38e5 18 03			jr .pastdmark  
38e7 ..			.dmark: db "ERA"  
38ea f1			.pastdmark: pop af  
38eb			endm  
# End of macro DMARK
38eb						CALLMONITOR 
38eb cd 04 13			call break_point_state  
38ee				endm  
# End of macro CALLMONITOR
38ee					endif 
38ee				if DEBUG_STORESE 
38ee					DMARK "ER1" 
38ee f5				push af  
38ef 3a 03 39			ld a, (.dmark)  
38f2 32 77 fb			ld (debug_mark),a  
38f5 3a 04 39			ld a, (.dmark+1)  
38f8 32 78 fb			ld (debug_mark+1),a  
38fb 3a 05 39			ld a, (.dmark+2)  
38fe 32 79 fb			ld (debug_mark+2),a  
3901 18 03			jr .pastdmark  
3903 ..			.dmark: db "ER1"  
3906 f1			.pastdmark: pop af  
3907			endm  
# End of macro DMARK
3907					CALLMONITOR 
3907 cd 04 13			call break_point_state  
390a				endm  
# End of macro CALLMONITOR
390a				endif 
390a					FORTH_DSP_POP 
390a cd a9 19			call macro_forth_dsp_pop 
390d				endm 
# End of macro FORTH_DSP_POP
390d			 
390d			;		pop hl 
390d			 
390d cd 25 05				call storage_erase 
3910				       NEXTW 
3910 c3 63 1a			jp macro_next 
3913				endm 
# End of macro NEXTW
3913			 
3913			.OPEN: 
3913				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
3913 6b				db WORD_SYS_CORE+87             
3914 9a 39			dw .READ            
3916 05				db 4 + 1 
3917 .. 00			db "OPEN",0              
391c				endm 
# End of macro CWHEAD
391c			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
391c			; | | e.g. 
391c			; | | $01 OPEN $01 DO $01 READ . LOOP 
391c			 
391c					if DEBUG_FORTH_WORDS_KEY 
391c						DMARK "OPN" 
391c f5				push af  
391d 3a 31 39			ld a, (.dmark)  
3920 32 77 fb			ld (debug_mark),a  
3923 3a 32 39			ld a, (.dmark+1)  
3926 32 78 fb			ld (debug_mark+1),a  
3929 3a 33 39			ld a, (.dmark+2)  
392c 32 79 fb			ld (debug_mark+2),a  
392f 18 03			jr .pastdmark  
3931 ..			.dmark: db "OPN"  
3934 f1			.pastdmark: pop af  
3935			endm  
# End of macro DMARK
3935						CALLMONITOR 
3935 cd 04 13			call break_point_state  
3938				endm  
# End of macro CALLMONITOR
3938					endif 
3938					; TODO handle multiple file opens 
3938			 
3938 3e 01			       	ld a, 1 
393a 32 59 f8				ld (store_openext), a 
393d			 
393d					; get max extents for this file 
393d				 
393d								 
393d					FORTH_DSP_VALUEHL 
393d cd 29 19			call macro_dsp_valuehl 
3940				endm 
# End of macro FORTH_DSP_VALUEHL
3940			 
3940 65					ld h, l 
3941 2e 00				ld l, 0 
3943			 
3943				if DEBUG_STORESE 
3943					DMARK "OPN" 
3943 f5				push af  
3944 3a 58 39			ld a, (.dmark)  
3947 32 77 fb			ld (debug_mark),a  
394a 3a 59 39			ld a, (.dmark+1)  
394d 32 78 fb			ld (debug_mark+1),a  
3950 3a 5a 39			ld a, (.dmark+2)  
3953 32 79 fb			ld (debug_mark+2),a  
3956 18 03			jr .pastdmark  
3958 ..			.dmark: db "OPN"  
395b f1			.pastdmark: pop af  
395c			endm  
# End of macro DMARK
395c					CALLMONITOR 
395c cd 04 13			call break_point_state  
395f				endm  
# End of macro CALLMONITOR
395f				endif 
395f			;		push hl 
395f					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
395f cd a9 19			call macro_forth_dsp_pop 
3962				endm 
# End of macro FORTH_DSP_POP
3962			;		pop hl 
3962						 
3962 11 62 f8				ld de, store_page      ; get block zero of file 
3965 cd 4a 07				call storage_read 
3968			 
3968			 
3968 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
396b 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
396e					 
396e				if DEBUG_STORESE 
396e					DMARK "OPx" 
396e f5				push af  
396f 3a 83 39			ld a, (.dmark)  
3972 32 77 fb			ld (debug_mark),a  
3975 3a 84 39			ld a, (.dmark+1)  
3978 32 78 fb			ld (debug_mark+1),a  
397b 3a 85 39			ld a, (.dmark+2)  
397e 32 79 fb			ld (debug_mark+2),a  
3981 18 03			jr .pastdmark  
3983 ..			.dmark: db "OPx"  
3986 f1			.pastdmark: pop af  
3987			endm  
# End of macro DMARK
3987					CALLMONITOR 
3987 cd 04 13			call break_point_state  
398a				endm  
# End of macro CALLMONITOR
398a				endif 
398a fe 00				cp 0 
398c 20 03				jr nz, .skipopeneof 
398e					; have opened an empty file 
398e					 
398e 32 59 f8				ld (store_openext), a 
3991			 
3991			.skipopeneof: 
3991			 
3991 6f					ld l, a 
3992 26 00				ld h, 0 
3994 cd 8e 18				call forth_push_numhl 
3997			 
3997			 
3997				       NEXTW 
3997 c3 63 1a			jp macro_next 
399a				endm 
# End of macro NEXTW
399a			.READ: 
399a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
399a 6c				db WORD_SYS_CORE+88             
399b e1 3a			dw .EOF            
399d 05				db 4 + 1 
399e .. 00			db "READ",0              
39a3				endm 
# End of macro CWHEAD
39a3			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
39a3			; | | e.g. 
39a3			; | | $01 OPEN $01 DO $01 READ . LOOP 
39a3			 
39a3					if DEBUG_FORTH_WORDS_KEY 
39a3						DMARK "REA" 
39a3 f5				push af  
39a4 3a b8 39			ld a, (.dmark)  
39a7 32 77 fb			ld (debug_mark),a  
39aa 3a b9 39			ld a, (.dmark+1)  
39ad 32 78 fb			ld (debug_mark+1),a  
39b0 3a ba 39			ld a, (.dmark+2)  
39b3 32 79 fb			ld (debug_mark+2),a  
39b6 18 03			jr .pastdmark  
39b8 ..			.dmark: db "REA"  
39bb f1			.pastdmark: pop af  
39bc			endm  
# End of macro DMARK
39bc						CALLMONITOR 
39bc cd 04 13			call break_point_state  
39bf				endm  
# End of macro CALLMONITOR
39bf					endif 
39bf					; store_openext use it. If zero it is EOF 
39bf			 
39bf					; read block from current stream id 
39bf					; if the block does not contain zero term keep reading blocks until zero found 
39bf					; push the block to stack 
39bf					; save the block id to stream 
39bf			 
39bf			 
39bf					FORTH_DSP_VALUEHL 
39bf cd 29 19			call macro_dsp_valuehl 
39c2				endm 
# End of macro FORTH_DSP_VALUEHL
39c2			 
39c2			;		push hl 
39c2			 
39c2				if DEBUG_STORESE 
39c2					DMARK "REA" 
39c2 f5				push af  
39c3 3a d7 39			ld a, (.dmark)  
39c6 32 77 fb			ld (debug_mark),a  
39c9 3a d8 39			ld a, (.dmark+1)  
39cc 32 78 fb			ld (debug_mark+1),a  
39cf 3a d9 39			ld a, (.dmark+2)  
39d2 32 79 fb			ld (debug_mark+2),a  
39d5 18 03			jr .pastdmark  
39d7 ..			.dmark: db "REA"  
39da f1			.pastdmark: pop af  
39db			endm  
# End of macro DMARK
39db					CALLMONITOR 
39db cd 04 13			call break_point_state  
39de				endm  
# End of macro CALLMONITOR
39de				endif 
39de					FORTH_DSP_POP 
39de cd a9 19			call macro_forth_dsp_pop 
39e1				endm 
# End of macro FORTH_DSP_POP
39e1			 
39e1			;		pop hl 
39e1				 
39e1 65					ld h,l 
39e2			 
39e2 3a 59 f8				ld a, (store_openext) 
39e5 6f					ld l, a 
39e6					 
39e6 fe 00				cp 0 
39e8 ca b3 3a				jp z, .ateof     ; dont read past eof 
39eb			 
39eb			 
39eb 11 62 f8				ld de, store_page 
39ee				if DEBUG_STORESE 
39ee					DMARK "RE1" 
39ee f5				push af  
39ef 3a 03 3a			ld a, (.dmark)  
39f2 32 77 fb			ld (debug_mark),a  
39f5 3a 04 3a			ld a, (.dmark+1)  
39f8 32 78 fb			ld (debug_mark+1),a  
39fb 3a 05 3a			ld a, (.dmark+2)  
39fe 32 79 fb			ld (debug_mark+2),a  
3a01 18 03			jr .pastdmark  
3a03 ..			.dmark: db "RE1"  
3a06 f1			.pastdmark: pop af  
3a07			endm  
# End of macro DMARK
3a07					CALLMONITOR 
3a07 cd 04 13			call break_point_state  
3a0a				endm  
# End of macro CALLMONITOR
3a0a				endif 
3a0a cd 4a 07				call storage_read 
3a0d			 
3a0d				if DEBUG_STORESE 
3a0d					DMARK "RE2" 
3a0d f5				push af  
3a0e 3a 22 3a			ld a, (.dmark)  
3a11 32 77 fb			ld (debug_mark),a  
3a14 3a 23 3a			ld a, (.dmark+1)  
3a17 32 78 fb			ld (debug_mark+1),a  
3a1a 3a 24 3a			ld a, (.dmark+2)  
3a1d 32 79 fb			ld (debug_mark+2),a  
3a20 18 03			jr .pastdmark  
3a22 ..			.dmark: db "RE2"  
3a25 f1			.pastdmark: pop af  
3a26			endm  
# End of macro DMARK
3a26					CALLMONITOR 
3a26 cd 04 13			call break_point_state  
3a29				endm  
# End of macro CALLMONITOR
3a29				endif 
3a29 cd 3f 0b			call ishlzero 
3a2c			;	ld a, l 
3a2c			;	add h 
3a2c			;	cp 0 
3a2c ca b9 3a			jp z, .readeof 
3a2f			 
3a2f				; not eof so hl should point to data to push to stack 
3a2f			 
3a2f				if DEBUG_STORESE 
3a2f					DMARK "RE3" 
3a2f f5				push af  
3a30 3a 44 3a			ld a, (.dmark)  
3a33 32 77 fb			ld (debug_mark),a  
3a36 3a 45 3a			ld a, (.dmark+1)  
3a39 32 78 fb			ld (debug_mark+1),a  
3a3c 3a 46 3a			ld a, (.dmark+2)  
3a3f 32 79 fb			ld (debug_mark+2),a  
3a42 18 03			jr .pastdmark  
3a44 ..			.dmark: db "RE3"  
3a47 f1			.pastdmark: pop af  
3a48			endm  
# End of macro DMARK
3a48					CALLMONITOR 
3a48 cd 04 13			call break_point_state  
3a4b				endm  
# End of macro CALLMONITOR
3a4b				endif 
3a4b cd a0 18			call forth_push_str 
3a4e			 
3a4e				if DEBUG_STORESE 
3a4e					DMARK "RE4" 
3a4e f5				push af  
3a4f 3a 63 3a			ld a, (.dmark)  
3a52 32 77 fb			ld (debug_mark),a  
3a55 3a 64 3a			ld a, (.dmark+1)  
3a58 32 78 fb			ld (debug_mark+1),a  
3a5b 3a 65 3a			ld a, (.dmark+2)  
3a5e 32 79 fb			ld (debug_mark+2),a  
3a61 18 03			jr .pastdmark  
3a63 ..			.dmark: db "RE4"  
3a66 f1			.pastdmark: pop af  
3a67			endm  
# End of macro DMARK
3a67					CALLMONITOR 
3a67 cd 04 13			call break_point_state  
3a6a				endm  
# End of macro CALLMONITOR
3a6a				endif 
3a6a				; get next block  or mark as eof 
3a6a			 
3a6a 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
3a6d 4f				ld c, a	 
3a6e 3a 59 f8			ld a, (store_openext) 
3a71			 
3a71				if DEBUG_STORESE 
3a71					DMARK "RE5" 
3a71 f5				push af  
3a72 3a 86 3a			ld a, (.dmark)  
3a75 32 77 fb			ld (debug_mark),a  
3a78 3a 87 3a			ld a, (.dmark+1)  
3a7b 32 78 fb			ld (debug_mark+1),a  
3a7e 3a 88 3a			ld a, (.dmark+2)  
3a81 32 79 fb			ld (debug_mark+2),a  
3a84 18 03			jr .pastdmark  
3a86 ..			.dmark: db "RE5"  
3a89 f1			.pastdmark: pop af  
3a8a			endm  
# End of macro DMARK
3a8a					CALLMONITOR 
3a8a cd 04 13			call break_point_state  
3a8d				endm  
# End of macro CALLMONITOR
3a8d				endif 
3a8d b9				cp c 
3a8e 28 29			jr z, .readeof     ; at last extent 
3a90			 
3a90 3c					inc a 
3a91 32 59 f8				ld (store_openext), a 
3a94			 
3a94				if DEBUG_STORESE 
3a94					DMARK "RE6" 
3a94 f5				push af  
3a95 3a a9 3a			ld a, (.dmark)  
3a98 32 77 fb			ld (debug_mark),a  
3a9b 3a aa 3a			ld a, (.dmark+1)  
3a9e 32 78 fb			ld (debug_mark+1),a  
3aa1 3a ab 3a			ld a, (.dmark+2)  
3aa4 32 79 fb			ld (debug_mark+2),a  
3aa7 18 03			jr .pastdmark  
3aa9 ..			.dmark: db "RE6"  
3aac f1			.pastdmark: pop af  
3aad			endm  
# End of macro DMARK
3aad					CALLMONITOR 
3aad cd 04 13			call break_point_state  
3ab0				endm  
# End of macro CALLMONITOR
3ab0				endif 
3ab0			 
3ab0			 
3ab0				       NEXTW 
3ab0 c3 63 1a			jp macro_next 
3ab3				endm 
# End of macro NEXTW
3ab3			.ateof: 
3ab3 21 dd 3a				ld hl, .showeof 
3ab6 cd a0 18				call forth_push_str 
3ab9 3e 00		.readeof:	ld a, 0 
3abb 32 59 f8				ld (store_openext), a 
3abe			 
3abe					 
3abe				if DEBUG_STORESE 
3abe					DMARK "REF" 
3abe f5				push af  
3abf 3a d3 3a			ld a, (.dmark)  
3ac2 32 77 fb			ld (debug_mark),a  
3ac5 3a d4 3a			ld a, (.dmark+1)  
3ac8 32 78 fb			ld (debug_mark+1),a  
3acb 3a d5 3a			ld a, (.dmark+2)  
3ace 32 79 fb			ld (debug_mark+2),a  
3ad1 18 03			jr .pastdmark  
3ad3 ..			.dmark: db "REF"  
3ad6 f1			.pastdmark: pop af  
3ad7			endm  
# End of macro DMARK
3ad7					CALLMONITOR 
3ad7 cd 04 13			call break_point_state  
3ada				endm  
# End of macro CALLMONITOR
3ada				endif 
3ada				       NEXTW 
3ada c3 63 1a			jp macro_next 
3add				endm 
# End of macro NEXTW
3add			 
3add .. 00		.showeof:   db "eof", 0 
3ae1			 
3ae1			 
3ae1			.EOF: 
3ae1				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
3ae1 6d				db WORD_SYS_CORE+89             
3ae2 22 3b			dw .FORMAT            
3ae4 04				db 3 + 1 
3ae5 .. 00			db "EOF",0              
3ae9				endm 
# End of macro CWHEAD
3ae9			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
3ae9			; | | e.g. 
3ae9			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
3ae9					; TODO if current block id for stream is zero then push true else false 
3ae9			 
3ae9					if DEBUG_FORTH_WORDS_KEY 
3ae9						DMARK "EOF" 
3ae9 f5				push af  
3aea 3a fe 3a			ld a, (.dmark)  
3aed 32 77 fb			ld (debug_mark),a  
3af0 3a ff 3a			ld a, (.dmark+1)  
3af3 32 78 fb			ld (debug_mark+1),a  
3af6 3a 00 3b			ld a, (.dmark+2)  
3af9 32 79 fb			ld (debug_mark+2),a  
3afc 18 03			jr .pastdmark  
3afe ..			.dmark: db "EOF"  
3b01 f1			.pastdmark: pop af  
3b02			endm  
# End of macro DMARK
3b02						CALLMONITOR 
3b02 cd 04 13			call break_point_state  
3b05				endm  
# End of macro CALLMONITOR
3b05					endif 
3b05			 
3b05					; TODO handlue multiple file streams 
3b05			 
3b05					FORTH_DSP_POP     ; for now just get rid of stream id 
3b05 cd a9 19			call macro_forth_dsp_pop 
3b08				endm 
# End of macro FORTH_DSP_POP
3b08			 
3b08 2e 01				ld l, 1 
3b0a 3a 58 f8				ld a, (store_openmaxext) 
3b0d fe 00				cp 0 
3b0f 28 09				jr  z, .eofdone   ; empty file 
3b11 3a 59 f8				ld a, (store_openext) 
3b14 fe 00				cp 0 
3b16 28 02				jr  z, .eofdone 
3b18 2e 00				ld l, 0 
3b1a 26 00		.eofdone:	ld h, 0 
3b1c cd 8e 18				call forth_push_numhl 
3b1f			 
3b1f			 
3b1f				       NEXTW 
3b1f c3 63 1a			jp macro_next 
3b22				endm 
# End of macro NEXTW
3b22			 
3b22			.FORMAT: 
3b22				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
3b22 6d				db WORD_SYS_CORE+89             
3b23 73 3b			dw .LABEL            
3b25 07				db 6 + 1 
3b26 .. 00			db "FORMAT",0              
3b2d				endm 
# End of macro CWHEAD
3b2d			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
3b2d					; TODO if current block id for stream is zero then push true else false 
3b2d				 
3b2d				if DEBUG_STORESE 
3b2d					DMARK "FOR" 
3b2d f5				push af  
3b2e 3a 42 3b			ld a, (.dmark)  
3b31 32 77 fb			ld (debug_mark),a  
3b34 3a 43 3b			ld a, (.dmark+1)  
3b37 32 78 fb			ld (debug_mark+1),a  
3b3a 3a 44 3b			ld a, (.dmark+2)  
3b3d 32 79 fb			ld (debug_mark+2),a  
3b40 18 03			jr .pastdmark  
3b42 ..			.dmark: db "FOR"  
3b45 f1			.pastdmark: pop af  
3b46			endm  
# End of macro DMARK
3b46					CALLMONITOR 
3b46 cd 04 13			call break_point_state  
3b49				endm  
# End of macro CALLMONITOR
3b49				endif 
3b49					; Wipes the bank check flags to cause a reformat on next block 0 read 
3b49			 
3b49 21 01 00				ld hl, 1 
3b4c 3e 00				ld a, 0 
3b4e cd ea 01				call se_writebyte 
3b51			 
3b51				if DEBUG_STORESE 
3b51					DMARK "FO0" 
3b51 f5				push af  
3b52 3a 66 3b			ld a, (.dmark)  
3b55 32 77 fb			ld (debug_mark),a  
3b58 3a 67 3b			ld a, (.dmark+1)  
3b5b 32 78 fb			ld (debug_mark+1),a  
3b5e 3a 68 3b			ld a, (.dmark+2)  
3b61 32 79 fb			ld (debug_mark+2),a  
3b64 18 03			jr .pastdmark  
3b66 ..			.dmark: db "FO0"  
3b69 f1			.pastdmark: pop af  
3b6a			endm  
# End of macro DMARK
3b6a					CALLMONITOR 
3b6a cd 04 13			call break_point_state  
3b6d				endm  
# End of macro CALLMONITOR
3b6d				endif 
3b6d					; force bank init 
3b6d			 
3b6d cd a1 03				call storage_get_block_0 
3b70					 
3b70				       NEXTW 
3b70 c3 63 1a			jp macro_next 
3b73				endm 
# End of macro NEXTW
3b73			.LABEL: 
3b73				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
3b73 6d				db WORD_SYS_CORE+89             
3b74 c1 3b			dw .STOREPAGE            
3b76 06				db 5 + 1 
3b77 .. 00			db "LABEL",0              
3b7d				endm 
# End of macro CWHEAD
3b7d			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
3b7d					; TODO test to see if bank is selected 
3b7d				 
3b7d					if DEBUG_FORTH_WORDS_KEY 
3b7d						DMARK "LBL" 
3b7d f5				push af  
3b7e 3a 92 3b			ld a, (.dmark)  
3b81 32 77 fb			ld (debug_mark),a  
3b84 3a 93 3b			ld a, (.dmark+1)  
3b87 32 78 fb			ld (debug_mark+1),a  
3b8a 3a 94 3b			ld a, (.dmark+2)  
3b8d 32 79 fb			ld (debug_mark+2),a  
3b90 18 03			jr .pastdmark  
3b92 ..			.dmark: db "LBL"  
3b95 f1			.pastdmark: pop af  
3b96			endm  
# End of macro DMARK
3b96						CALLMONITOR 
3b96 cd 04 13			call break_point_state  
3b99				endm  
# End of macro CALLMONITOR
3b99					endif 
3b99			;	if DEBUG_STORESE 
3b99			;		DMARK "LBL" 
3b99			;		CALLMONITOR 
3b99			;	endif 
3b99					FORTH_DSP_VALUEHL 
3b99 cd 29 19			call macro_dsp_valuehl 
3b9c				endm 
# End of macro FORTH_DSP_VALUEHL
3b9c					;v5FORTH_DSP_VALUE 
3b9c					 
3b9c			;		push hl 
3b9c					FORTH_DSP_POP 
3b9c cd a9 19			call macro_forth_dsp_pop 
3b9f				endm 
# End of macro FORTH_DSP_POP
3b9f			;		pop hl 
3b9f			 
3b9f			;v5		inc hl   ; move past the type marker 
3b9f			 
3b9f				if DEBUG_STORESE 
3b9f					DMARK "LBl" 
3b9f f5				push af  
3ba0 3a b4 3b			ld a, (.dmark)  
3ba3 32 77 fb			ld (debug_mark),a  
3ba6 3a b5 3b			ld a, (.dmark+1)  
3ba9 32 78 fb			ld (debug_mark+1),a  
3bac 3a b6 3b			ld a, (.dmark+2)  
3baf 32 79 fb			ld (debug_mark+2),a  
3bb2 18 03			jr .pastdmark  
3bb4 ..			.dmark: db "LBl"  
3bb7 f1			.pastdmark: pop af  
3bb8			endm  
# End of macro DMARK
3bb8					CALLMONITOR 
3bb8 cd 04 13			call break_point_state  
3bbb				endm  
# End of macro CALLMONITOR
3bbb				endif 
3bbb cd ba 04				call storage_label 
3bbe			 
3bbe				       NEXTW 
3bbe c3 63 1a			jp macro_next 
3bc1				endm 
# End of macro NEXTW
3bc1			.STOREPAGE: 
3bc1				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
3bc1 6d				db WORD_SYS_CORE+89             
3bc2 f4 3b			dw .LABELS            
3bc4 0a				db 9 + 1 
3bc5 .. 00			db "STOREPAGE",0              
3bcf				endm 
# End of macro CWHEAD
3bcf			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
3bcf					; TODO test to see if bank is selected 
3bcf				 
3bcf					if DEBUG_FORTH_WORDS_KEY 
3bcf						DMARK "STP" 
3bcf f5				push af  
3bd0 3a e4 3b			ld a, (.dmark)  
3bd3 32 77 fb			ld (debug_mark),a  
3bd6 3a e5 3b			ld a, (.dmark+1)  
3bd9 32 78 fb			ld (debug_mark+1),a  
3bdc 3a e6 3b			ld a, (.dmark+2)  
3bdf 32 79 fb			ld (debug_mark+2),a  
3be2 18 03			jr .pastdmark  
3be4 ..			.dmark: db "STP"  
3be7 f1			.pastdmark: pop af  
3be8			endm  
# End of macro DMARK
3be8						CALLMONITOR 
3be8 cd 04 13			call break_point_state  
3beb				endm  
# End of macro CALLMONITOR
3beb					endif 
3beb			;	if DEBUG_STORESE 
3beb			;		DMARK "STP" 
3beb			;		CALLMONITOR 
3beb			;	endif 
3beb			 
3beb 21 62 f8			ld hl, store_page 
3bee cd 8e 18			call forth_push_numhl 
3bf1			 
3bf1			 
3bf1				       NEXTW 
3bf1 c3 63 1a			jp macro_next 
3bf4				endm 
# End of macro NEXTW
3bf4			.LABELS: 
3bf4				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
3bf4 6d				db WORD_SYS_CORE+89             
3bf5 7e 3c			dw .ENDSTORAGE            
3bf7 07				db 6 + 1 
3bf8 .. 00			db "LABELS",0              
3bff				endm 
# End of macro CWHEAD
3bff			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
3bff					;  
3bff			 
3bff					; save the current device selected to restore afterwards 
3bff				 
3bff 3a 5c f8				ld a, (spi_device) 
3c02 f5					push af 
3c03			 
3c03			 
3c03					; run through each of the banks 
3c03			 
3c03 21 01 00				ld hl, 1 
3c06 cd 8e 18				call forth_push_numhl 
3c09 3e ff				ld a, SPI_CE_HIGH 
3c0b cb 87				res SPI_CE0, a 
3c0d 32 5c f8				ld (spi_device), a 
3c10 cd a1 03				call storage_get_block_0 
3c13 21 65 f8				ld hl, store_page+3 
3c16 cd a0 18				call forth_push_str 
3c19			 
3c19					 
3c19 21 02 00				ld hl, 2 
3c1c cd 8e 18				call forth_push_numhl 
3c1f 3e ff				ld a, SPI_CE_HIGH 
3c21 cb 8f				res SPI_CE1, a 
3c23 32 5c f8				ld (spi_device), a 
3c26 cd a1 03				call storage_get_block_0 
3c29 21 65 f8				ld hl, store_page+3 
3c2c cd a0 18				call forth_push_str 
3c2f			 
3c2f					 
3c2f 21 03 00				ld hl, 3 
3c32 cd 8e 18				call forth_push_numhl 
3c35 3e ff				ld a, SPI_CE_HIGH 
3c37 cb 97				res SPI_CE2, a 
3c39 32 5c f8				ld (spi_device), a 
3c3c cd a1 03				call storage_get_block_0 
3c3f 21 65 f8				ld hl, store_page+3 
3c42 cd a0 18				call forth_push_str 
3c45			 
3c45			 
3c45 21 04 00				ld hl, 4 
3c48 cd 8e 18				call forth_push_numhl 
3c4b 3e ff				ld a, SPI_CE_HIGH 
3c4d cb 9f				res SPI_CE3, a 
3c4f 32 5c f8				ld (spi_device), a 
3c52 cd a1 03				call storage_get_block_0 
3c55 21 65 f8				ld hl, store_page+3 
3c58 cd a0 18				call forth_push_str 
3c5b			 
3c5b					 
3c5b			 
3c5b 21 05 00				ld hl, 5 
3c5e cd 8e 18				call forth_push_numhl 
3c61 3e ff				ld a, SPI_CE_HIGH 
3c63 cb a7				res SPI_CE4, a 
3c65 32 5c f8				ld (spi_device), a 
3c68 cd a1 03				call storage_get_block_0 
3c6b 21 65 f8				ld hl, store_page+3 
3c6e cd a0 18				call forth_push_str 
3c71			 
3c71					 
3c71					; push fixed count of storage devices (on board) for now 
3c71			 
3c71 21 05 00				ld hl, 5 
3c74 cd 8e 18				call forth_push_numhl 
3c77			 
3c77					; restore selected device  
3c77				 
3c77 f1					pop af 
3c78 32 5c f8				ld (spi_device), a 
3c7b			 
3c7b				       NEXTW 
3c7b c3 63 1a			jp macro_next 
3c7e				endm 
# End of macro NEXTW
3c7e			 
3c7e			.ENDSTORAGE: 
3c7e			; eof 
# End of file forth_words_storage.asm
3c7e			endif 
3c7e				include "forth_words_device.asm" 
3c7e			; Device related words 
3c7e			 
3c7e			; | ## Device Words 
3c7e			 
3c7e			if SOUND_ENABLE 
3c7e			.NOTE: 
3c7e				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
3c7e 33				db WORD_SYS_CORE+31             
3c7f a6 3c			dw .AFTERSOUND            
3c81 05				db 4 + 1 
3c82 .. 00			db "NOTE",0              
3c87				endm 
# End of macro CWHEAD
3c87			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
3c87					if DEBUG_FORTH_WORDS_KEY 
3c87						DMARK "NTE" 
3c87 f5				push af  
3c88 3a 9c 3c			ld a, (.dmark)  
3c8b 32 77 fb			ld (debug_mark),a  
3c8e 3a 9d 3c			ld a, (.dmark+1)  
3c91 32 78 fb			ld (debug_mark+1),a  
3c94 3a 9e 3c			ld a, (.dmark+2)  
3c97 32 79 fb			ld (debug_mark+2),a  
3c9a 18 03			jr .pastdmark  
3c9c ..			.dmark: db "NTE"  
3c9f f1			.pastdmark: pop af  
3ca0			endm  
# End of macro DMARK
3ca0						CALLMONITOR 
3ca0 cd 04 13			call break_point_state  
3ca3				endm  
# End of macro CALLMONITOR
3ca3					endif 
3ca3			 
3ca3				 
3ca3			 
3ca3					NEXTW 
3ca3 c3 63 1a			jp macro_next 
3ca6				endm 
# End of macro NEXTW
3ca6			.AFTERSOUND: 
3ca6			endif 
3ca6			 
3ca6			 
3ca6			USE_GPIO: equ 0 
3ca6			 
3ca6			if USE_GPIO 
3ca6			.GP1: 
3ca6				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
3ca6			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
3ca6					NEXTW 
3ca6			.GP2: 
3ca6				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
3ca6			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
3ca6			 
3ca6					NEXTW 
3ca6			 
3ca6			.GP3: 
3ca6				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
3ca6			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
3ca6			 
3ca6					NEXTW 
3ca6			 
3ca6			.GP4: 
3ca6				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
3ca6			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
3ca6			 
3ca6					NEXTW 
3ca6			.SIN: 
3ca6			 
3ca6			 
3ca6			endif 
3ca6			 
3ca6			 
3ca6				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
3ca6 33				db WORD_SYS_CORE+31             
3ca7 db 3c			dw .SOUT            
3ca9 03				db 2 + 1 
3caa .. 00			db "IN",0              
3cad				endm 
# End of macro CWHEAD
3cad			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
3cad					if DEBUG_FORTH_WORDS_KEY 
3cad						DMARK "IN." 
3cad f5				push af  
3cae 3a c2 3c			ld a, (.dmark)  
3cb1 32 77 fb			ld (debug_mark),a  
3cb4 3a c3 3c			ld a, (.dmark+1)  
3cb7 32 78 fb			ld (debug_mark+1),a  
3cba 3a c4 3c			ld a, (.dmark+2)  
3cbd 32 79 fb			ld (debug_mark+2),a  
3cc0 18 03			jr .pastdmark  
3cc2 ..			.dmark: db "IN."  
3cc5 f1			.pastdmark: pop af  
3cc6			endm  
# End of macro DMARK
3cc6						CALLMONITOR 
3cc6 cd 04 13			call break_point_state  
3cc9				endm  
# End of macro CALLMONITOR
3cc9					endif 
3cc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc9 cd 29 19			call macro_dsp_valuehl 
3ccc				endm 
# End of macro FORTH_DSP_VALUEHL
3ccc			 
3ccc e5					push hl 
3ccd			 
3ccd					; destroy value TOS 
3ccd			 
3ccd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ccd cd a9 19			call macro_forth_dsp_pop 
3cd0				endm 
# End of macro FORTH_DSP_POP
3cd0			 
3cd0					; one value on hl get other one back 
3cd0			 
3cd0 c1					pop bc 
3cd1			 
3cd1					; do the sub 
3cd1			;		ex de, hl 
3cd1			 
3cd1 ed 68				in l,(c) 
3cd3			 
3cd3					; save it 
3cd3			 
3cd3 26 00				ld h,0 
3cd5			 
3cd5					; TODO push value back onto stack for another op etc 
3cd5			 
3cd5 cd 8e 18				call forth_push_numhl 
3cd8					NEXTW 
3cd8 c3 63 1a			jp macro_next 
3cdb				endm 
# End of macro NEXTW
3cdb			.SOUT: 
3cdb				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
3cdb 34				db WORD_SYS_CORE+32             
3cdc 12 3d			dw .SPIO            
3cde 04				db 3 + 1 
3cdf .. 00			db "OUT",0              
3ce3				endm 
# End of macro CWHEAD
3ce3			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
3ce3					if DEBUG_FORTH_WORDS_KEY 
3ce3						DMARK "OUT" 
3ce3 f5				push af  
3ce4 3a f8 3c			ld a, (.dmark)  
3ce7 32 77 fb			ld (debug_mark),a  
3cea 3a f9 3c			ld a, (.dmark+1)  
3ced 32 78 fb			ld (debug_mark+1),a  
3cf0 3a fa 3c			ld a, (.dmark+2)  
3cf3 32 79 fb			ld (debug_mark+2),a  
3cf6 18 03			jr .pastdmark  
3cf8 ..			.dmark: db "OUT"  
3cfb f1			.pastdmark: pop af  
3cfc			endm  
# End of macro DMARK
3cfc						CALLMONITOR 
3cfc cd 04 13			call break_point_state  
3cff				endm  
# End of macro CALLMONITOR
3cff					endif 
3cff			 
3cff					; get port 
3cff			 
3cff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cff cd 29 19			call macro_dsp_valuehl 
3d02				endm 
# End of macro FORTH_DSP_VALUEHL
3d02			 
3d02 e5					push hl 
3d03			 
3d03					; destroy value TOS 
3d03			 
3d03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d03 cd a9 19			call macro_forth_dsp_pop 
3d06				endm 
# End of macro FORTH_DSP_POP
3d06			 
3d06					; get byte to send 
3d06			 
3d06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d06 cd 29 19			call macro_dsp_valuehl 
3d09				endm 
# End of macro FORTH_DSP_VALUEHL
3d09			 
3d09			;		push hl 
3d09			 
3d09					; destroy value TOS 
3d09			 
3d09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d09 cd a9 19			call macro_forth_dsp_pop 
3d0c				endm 
# End of macro FORTH_DSP_POP
3d0c			 
3d0c					; one value on hl get other one back 
3d0c			 
3d0c			;		pop hl 
3d0c			 
3d0c c1					pop bc 
3d0d			 
3d0d					if DEBUG_FORTH_WORDS 
3d0d						DMARK "OUT" 
3d0d						CALLMONITOR 
3d0d					endif 
3d0d			 
3d0d ed 69				out (c), l 
3d0f			 
3d0f					NEXTW 
3d0f c3 63 1a			jp macro_next 
3d12				endm 
# End of macro NEXTW
3d12			 
3d12			 
3d12			.SPIO: 
3d12			 
3d12			if STORAGE_SE 
3d12				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
3d12 51				db WORD_SYS_CORE+61             
3d13 23 3d			dw .SPICEH            
3d15 07				db 6 + 1 
3d16 .. 00			db "SPICEL",0              
3d1d				endm 
# End of macro CWHEAD
3d1d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
3d1d			 
3d1d cd 98 01				call spi_ce_low 
3d20			    NEXTW 
3d20 c3 63 1a			jp macro_next 
3d23				endm 
# End of macro NEXTW
3d23			 
3d23			.SPICEH: 
3d23				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
3d23 51				db WORD_SYS_CORE+61             
3d24 34 3d			dw .SPIOb            
3d26 07				db 6 + 1 
3d27 .. 00			db "SPICEH",0              
3d2e				endm 
# End of macro CWHEAD
3d2e			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
3d2e			 
3d2e cd 87 01				call spi_ce_high 
3d31			    NEXTW 
3d31 c3 63 1a			jp macro_next 
3d34				endm 
# End of macro NEXTW
3d34			 
3d34			 
3d34			.SPIOb: 
3d34			 
3d34				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
3d34 51				db WORD_SYS_CORE+61             
3d35 4a 3d			dw .SPII            
3d37 05				db 4 + 1 
3d38 .. 00			db "SPIO",0              
3d3d				endm 
# End of macro CWHEAD
3d3d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
3d3d			 
3d3d					; get port 
3d3d			 
3d3d			 
3d3d					; get byte to send 
3d3d			 
3d3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d3d cd 29 19			call macro_dsp_valuehl 
3d40				endm 
# End of macro FORTH_DSP_VALUEHL
3d40			 
3d40			;		push hl    ; u1  
3d40			 
3d40					; destroy value TOS 
3d40			 
3d40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d40 cd a9 19			call macro_forth_dsp_pop 
3d43				endm 
# End of macro FORTH_DSP_POP
3d43			 
3d43					; one value on hl get other one back 
3d43			 
3d43			;		pop hl   ; u2 - addr 
3d43			 
3d43					; TODO Send SPI byte 
3d43			 
3d43 7d					ld a, l 
3d44 cd bc 00				call spi_send_byte 
3d47			 
3d47					NEXTW 
3d47 c3 63 1a			jp macro_next 
3d4a				endm 
# End of macro NEXTW
3d4a			 
3d4a			.SPII: 
3d4a				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
3d4a 52				db WORD_SYS_CORE+62             
3d4b 5f 3d			dw .SESEL            
3d4d 06				db 5 + 1 
3d4e .. 00			db "SPII",0              
3d53				endm 
# End of macro CWHEAD
3d53			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
3d53			 
3d53					; TODO Get SPI byte 
3d53			 
3d53 cd dd 00				call spi_read_byte 
3d56			 
3d56 26 00				ld h, 0 
3d58 6f					ld l, a 
3d59 cd 8e 18				call forth_push_numhl 
3d5c			 
3d5c					NEXTW 
3d5c c3 63 1a			jp macro_next 
3d5f				endm 
# End of macro NEXTW
3d5f			 
3d5f			 
3d5f			 
3d5f			.SESEL: 
3d5f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
3d5f 66				db WORD_SYS_CORE+82             
3d60 bb 3d			dw .CARTDEV            
3d62 05				db 4 + 1 
3d63 .. 00			db "BANK",0              
3d68				endm 
# End of macro CWHEAD
3d68			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
3d68					if DEBUG_FORTH_WORDS_KEY 
3d68						DMARK "BNK" 
3d68 f5				push af  
3d69 3a 7d 3d			ld a, (.dmark)  
3d6c 32 77 fb			ld (debug_mark),a  
3d6f 3a 7e 3d			ld a, (.dmark+1)  
3d72 32 78 fb			ld (debug_mark+1),a  
3d75 3a 7f 3d			ld a, (.dmark+2)  
3d78 32 79 fb			ld (debug_mark+2),a  
3d7b 18 03			jr .pastdmark  
3d7d ..			.dmark: db "BNK"  
3d80 f1			.pastdmark: pop af  
3d81			endm  
# End of macro DMARK
3d81						CALLMONITOR 
3d81 cd 04 13			call break_point_state  
3d84				endm  
# End of macro CALLMONITOR
3d84					endif 
3d84			 
3d84 3e ff				ld a, 255 
3d86 32 5f f8				ld (spi_cartdev), a 
3d89			 
3d89					; get bank 
3d89			 
3d89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d89 cd 29 19			call macro_dsp_valuehl 
3d8c				endm 
# End of macro FORTH_DSP_VALUEHL
3d8c			 
3d8c			;		push hl 
3d8c			 
3d8c					; destroy value TOS 
3d8c			 
3d8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8c cd a9 19			call macro_forth_dsp_pop 
3d8f				endm 
# End of macro FORTH_DSP_POP
3d8f			 
3d8f					; one value on hl get other one back 
3d8f			 
3d8f			;		pop hl 
3d8f			 
3d8f			 
3d8f 0e ff				ld c, SPI_CE_HIGH 
3d91			 
3d91 7d					ld a, l 
3d92			 
3d92					if DEBUG_FORTH_WORDS 
3d92						DMARK "BNK" 
3d92						CALLMONITOR 
3d92					endif 
3d92			 
3d92					; active low 
3d92			 
3d92 fe 00				cp 0 
3d94 28 1e				jr z, .bset 
3d96 fe 01				cp 1 
3d98 20 02				jr nz, .b2 
3d9a cb 81				res 0, c 
3d9c fe 02		.b2:		cp 2 
3d9e 20 02				jr nz, .b3 
3da0 cb 89				res 1, c 
3da2 fe 03		.b3:		cp 3 
3da4 20 02				jr nz, .b4 
3da6 cb 91				res 2, c 
3da8 fe 04		.b4:		cp 4 
3daa 20 02				jr nz, .b5 
3dac cb 99				res 3, c 
3dae fe 05		.b5:		cp 5 
3db0 20 02				jr nz, .bset 
3db2 cb a1				res 4, c 
3db4			 
3db4			.bset: 
3db4 79					ld a, c 
3db5 32 5c f8				ld (spi_device),a 
3db8					if DEBUG_FORTH_WORDS 
3db8						DMARK "BN2" 
3db8						CALLMONITOR 
3db8					endif 
3db8			 
3db8					NEXTW 
3db8 c3 63 1a			jp macro_next 
3dbb				endm 
# End of macro NEXTW
3dbb			 
3dbb			.CARTDEV: 
3dbb				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
3dbb 66				db WORD_SYS_CORE+82             
3dbc 2c 3e			dw .ENDDEVICE            
3dbe 08				db 7 + 1 
3dbf .. 00			db "CARTDEV",0              
3dc7				endm 
# End of macro CWHEAD
3dc7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
3dc7					if DEBUG_FORTH_WORDS_KEY 
3dc7						DMARK "CDV" 
3dc7 f5				push af  
3dc8 3a dc 3d			ld a, (.dmark)  
3dcb 32 77 fb			ld (debug_mark),a  
3dce 3a dd 3d			ld a, (.dmark+1)  
3dd1 32 78 fb			ld (debug_mark+1),a  
3dd4 3a de 3d			ld a, (.dmark+2)  
3dd7 32 79 fb			ld (debug_mark+2),a  
3dda 18 03			jr .pastdmark  
3ddc ..			.dmark: db "CDV"  
3ddf f1			.pastdmark: pop af  
3de0			endm  
# End of macro DMARK
3de0						CALLMONITOR 
3de0 cd 04 13			call break_point_state  
3de3				endm  
# End of macro CALLMONITOR
3de3					endif 
3de3			 
3de3					; disable se storage bank selection 
3de3			 
3de3 3e ff				ld a, SPI_CE_HIGH		; ce high 
3de5 32 5c f8				ld (spi_device), a 
3de8			 
3de8					; get bank 
3de8			 
3de8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3de8 cd 29 19			call macro_dsp_valuehl 
3deb				endm 
# End of macro FORTH_DSP_VALUEHL
3deb			 
3deb			;		push hl 
3deb			 
3deb					; destroy value TOS 
3deb			 
3deb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3deb cd a9 19			call macro_forth_dsp_pop 
3dee				endm 
# End of macro FORTH_DSP_POP
3dee			 
3dee					; one value on hl get other one back 
3dee			 
3dee			;		pop hl 
3dee			 
3dee					; active low 
3dee			 
3dee 0e ff				ld c, 255 
3df0			 
3df0 7d					ld a, l 
3df1					if DEBUG_FORTH_WORDS 
3df1						DMARK "CDV" 
3df1						CALLMONITOR 
3df1					endif 
3df1 fe 00				cp 0 
3df3 28 30				jr z, .cset 
3df5 fe 01				cp 1 
3df7 20 02				jr nz, .c2 
3df9 cb 81				res 0, c 
3dfb fe 02		.c2:		cp 2 
3dfd 20 02				jr nz, .c3 
3dff cb 89				res 1, c 
3e01 fe 03		.c3:		cp 3 
3e03 20 02				jr nz, .c4 
3e05 cb 91				res 2, c 
3e07 fe 04		.c4:		cp 4 
3e09 20 02				jr nz, .c5 
3e0b cb 99				res 3, c 
3e0d fe 05		.c5:		cp 5 
3e0f 20 02				jr nz, .c6 
3e11 cb a1				res 4, c 
3e13 fe 06		.c6:		cp 6 
3e15 20 02				jr nz, .c7 
3e17 cb a9				res 5, c 
3e19 fe 07		.c7:		cp 7 
3e1b 20 02				jr nz, .c8 
3e1d cb b1				res 6, c 
3e1f fe 08		.c8:		cp 8 
3e21 20 02				jr nz, .cset 
3e23 cb b9				res 7, c 
3e25 79			.cset:		ld a, c 
3e26 32 5f f8				ld (spi_cartdev),a 
3e29			 
3e29					if DEBUG_FORTH_WORDS 
3e29						DMARK "CD2" 
3e29						CALLMONITOR 
3e29					endif 
3e29					NEXTW 
3e29 c3 63 1a			jp macro_next 
3e2c				endm 
# End of macro NEXTW
3e2c			endif 
3e2c			 
3e2c			.ENDDEVICE: 
3e2c			; eof 
3e2c			 
# End of file forth_words_device.asm
3e2c			 
3e2c			; var handler 
3e2c			 
3e2c			 
3e2c			.VARS: 
3e2c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
3e2c 78				db WORD_SYS_CORE+100             
3e2d 44 3e			dw .V0Q            
3e2f 04				db 3 + 1 
3e30 .. 00			db "V0!",0              
3e34				endm 
# End of macro CWHEAD
3e34			;| V0! ( u1 -- )  Store value to v0  | DONE 
3e34			 
3e34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e34 cd 29 19			call macro_dsp_valuehl 
3e37				endm 
# End of macro FORTH_DSP_VALUEHL
3e37			 
3e37 11 25 f8				ld de, cli_var_array 
3e3a			 
3e3a eb					ex de, hl 
3e3b 73					ld (hl), e 
3e3c 23					inc hl 
3e3d 72					ld (hl), d 
3e3e			 
3e3e					; destroy value TOS 
3e3e			 
3e3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3e cd a9 19			call macro_forth_dsp_pop 
3e41				endm 
# End of macro FORTH_DSP_POP
3e41			 
3e41				       NEXTW 
3e41 c3 63 1a			jp macro_next 
3e44				endm 
# End of macro NEXTW
3e44			.V0Q: 
3e44				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
3e44 79				db WORD_SYS_CORE+101             
3e45 55 3e			dw .V1S            
3e47 04				db 3 + 1 
3e48 .. 00			db "V0@",0              
3e4c				endm 
# End of macro CWHEAD
3e4c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
3e4c 2a 25 f8				ld hl, (cli_var_array) 
3e4f cd 8e 18				call forth_push_numhl 
3e52			 
3e52				       NEXTW 
3e52 c3 63 1a			jp macro_next 
3e55				endm 
# End of macro NEXTW
3e55			.V1S: 
3e55				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
3e55 7a				db WORD_SYS_CORE+102             
3e56 6d 3e			dw .V1Q            
3e58 04				db 3 + 1 
3e59 .. 00			db "V1!",0              
3e5d				endm 
# End of macro CWHEAD
3e5d			;| V1! ( u1 -- )  Store value to v1 | DONE 
3e5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e5d cd 29 19			call macro_dsp_valuehl 
3e60				endm 
# End of macro FORTH_DSP_VALUEHL
3e60			 
3e60 11 27 f8				ld de, cli_var_array+2 
3e63				 
3e63 eb					ex de, hl 
3e64 73					ld (hl), e 
3e65 23					inc hl 
3e66 72					ld (hl), d 
3e67			 
3e67					; destroy value TOS 
3e67			 
3e67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e67 cd a9 19			call macro_forth_dsp_pop 
3e6a				endm 
# End of macro FORTH_DSP_POP
3e6a				       NEXTW 
3e6a c3 63 1a			jp macro_next 
3e6d				endm 
# End of macro NEXTW
3e6d			.V1Q: 
3e6d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
3e6d 7b				db WORD_SYS_CORE+103             
3e6e 7e 3e			dw .V2S            
3e70 04				db 3 + 1 
3e71 .. 00			db "V1@",0              
3e75				endm 
# End of macro CWHEAD
3e75			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
3e75 2a 27 f8				ld hl, (cli_var_array+2) 
3e78 cd 8e 18				call forth_push_numhl 
3e7b				       NEXTW 
3e7b c3 63 1a			jp macro_next 
3e7e				endm 
# End of macro NEXTW
3e7e			.V2S: 
3e7e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
3e7e 7c				db WORD_SYS_CORE+104             
3e7f 96 3e			dw .V2Q            
3e81 04				db 3 + 1 
3e82 .. 00			db "V2!",0              
3e86				endm 
# End of macro CWHEAD
3e86			;| V2! ( u1 -- )  Store value to v2 | DONE 
3e86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e86 cd 29 19			call macro_dsp_valuehl 
3e89				endm 
# End of macro FORTH_DSP_VALUEHL
3e89			 
3e89 11 29 f8				ld de, cli_var_array+4 
3e8c				 
3e8c eb					ex de, hl 
3e8d 73					ld (hl), e 
3e8e 23					inc hl 
3e8f 72					ld (hl), d 
3e90			 
3e90					; destroy value TOS 
3e90			 
3e90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e90 cd a9 19			call macro_forth_dsp_pop 
3e93				endm 
# End of macro FORTH_DSP_POP
3e93				       NEXTW 
3e93 c3 63 1a			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			.V2Q: 
3e96				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
3e96 7d				db WORD_SYS_CORE+105             
3e97 a7 3e			dw .V3S            
3e99 04				db 3 + 1 
3e9a .. 00			db "V2@",0              
3e9e				endm 
# End of macro CWHEAD
3e9e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
3e9e 2a 29 f8				ld hl, (cli_var_array+4) 
3ea1 cd 8e 18				call forth_push_numhl 
3ea4				       NEXTW 
3ea4 c3 63 1a			jp macro_next 
3ea7				endm 
# End of macro NEXTW
3ea7			.V3S: 
3ea7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
3ea7 7c				db WORD_SYS_CORE+104             
3ea8 bf 3e			dw .V3Q            
3eaa 04				db 3 + 1 
3eab .. 00			db "V3!",0              
3eaf				endm 
# End of macro CWHEAD
3eaf			;| V3! ( u1 -- )  Store value to v3 | DONE 
3eaf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eaf cd 29 19			call macro_dsp_valuehl 
3eb2				endm 
# End of macro FORTH_DSP_VALUEHL
3eb2			 
3eb2 11 2b f8				ld de, cli_var_array+6 
3eb5				 
3eb5 eb					ex de, hl 
3eb6 73					ld (hl), e 
3eb7 23					inc hl 
3eb8 72					ld (hl), d 
3eb9			 
3eb9					; destroy value TOS 
3eb9			 
3eb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb9 cd a9 19			call macro_forth_dsp_pop 
3ebc				endm 
# End of macro FORTH_DSP_POP
3ebc				       NEXTW 
3ebc c3 63 1a			jp macro_next 
3ebf				endm 
# End of macro NEXTW
3ebf			.V3Q: 
3ebf				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
3ebf 7d				db WORD_SYS_CORE+105             
3ec0 d0 3e			dw .END            
3ec2 04				db 3 + 1 
3ec3 .. 00			db "V3@",0              
3ec7				endm 
# End of macro CWHEAD
3ec7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
3ec7 2a 2b f8				ld hl, (cli_var_array+6) 
3eca cd 8e 18				call forth_push_numhl 
3ecd				       NEXTW 
3ecd c3 63 1a			jp macro_next 
3ed0				endm 
# End of macro NEXTW
3ed0			 
3ed0			 
3ed0			 
3ed0			 
3ed0			 
3ed0			; end of dict marker 
3ed0			 
3ed0 00			.END:    db WORD_SYS_END 
3ed1 00 00			dw 0 
3ed3 00				db 0 
3ed4			 
3ed4			; use to jp here for user dict words to save on macro expansion  
3ed4			 
3ed4			user_dict_next: 
3ed4				NEXTW 
3ed4 c3 63 1a			jp macro_next 
3ed7				endm 
# End of macro NEXTW
3ed7			 
3ed7			 
3ed7			user_exec: 
3ed7				;    ld hl, <word code> 
3ed7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
3ed7				;    call forthexec 
3ed7				;    jp user_dict_next   (NEXT) 
3ed7			        ;    <word code bytes> 
3ed7 eb				ex de, hl 
3ed8 2a 33 f1			ld hl,(os_tok_ptr) 
3edb				 
3edb				FORTH_RSP_NEXT 
3edb cd 38 18			call macro_forth_rsp_next 
3ede				endm 
# End of macro FORTH_RSP_NEXT
3ede			 
3ede			if DEBUG_FORTH_UWORD 
3ede						DMARK "UEX" 
3ede				CALLMONITOR 
3ede			endif 
3ede			 
3ede			 
3ede			 
3ede eb				ex de, hl 
3edf 22 33 f1			ld (os_tok_ptr), hl 
3ee2				 
3ee2				; Don't use next - Skips the first word in uword. 
3ee2			 
3ee2 c3 f4 1a			jp exec1 
3ee5			;	NEXT 
3ee5			 
3ee5			 
3ee5			; eof 
# End of file forth_wordsv4.asm
3ee5			endif 
3ee5			;;;;;;;;;;;;;; Debug code 
3ee5			 
3ee5			 
3ee5			;if DEBUG_FORTH_PARSE 
3ee5 .. 00		.nowordfound: db "No match",0 
3eee .. 00		.compword:	db "Comparing word ",0 
3efe .. 00		.nextwordat:	db "Next word at",0 
3f0b .. 00		.charmatch:	db "Char match",0 
3f16			;endif 
3f16			if DEBUG_FORTH_JP 
3f16			.foundword:	db "Word match. Exec..",0 
3f16			endif 
3f16			;if DEBUG_FORTH_PUSH 
3f16 .. 00		.enddict:	db "Dict end. Push.",0 
3f26 .. 00		.push_str:	db "Pushing string",0 
3f35 .. 00		.push_num:	db "Pushing number",0 
3f44 .. 00		.data_sp:	db "SP:",0 
3f48 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
3f5a .. 00		.wordinde:	db "Word in DE (3/0):",0 
3f6c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
3f7e			;endif 
3f7e			;if DEBUG_FORTH_MALLOC 
3f7e .. 00		.push_malloc:	db "Malloc address",0 
3f8d			;endif 
3f8d			 
3f8d			 
3f8d			 
3f8d			; display malloc address and current data stack pointer  
3f8d			 
3f8d			malloc_error: 
3f8d d5				push de 
3f8e f5				push af 
3f8f e5				push hl 
3f90 cd bd 09			call clear_display 
3f93 11 b5 3f			ld de, .mallocerr 
3f96 3e 00			ld a,0 
3f98			;	ld de,os_word_scratch 
3f98 cd d0 09			call str_at_display 
3f9b 3e 11			ld a, display_row_1+17 
3f9d 11 77 fb			ld de, debug_mark 
3fa0 cd d0 09			call str_at_display 
3fa3 cd e0 09			call update_display 
3fa6				;call break_point_state 
3fa6 cd 1b 55			call cin_wait 
3fa9			 
3fa9 3e 20			ld a, ' ' 
3fab 32 31 ee			ld (os_view_disable), a 
3fae e1				pop hl 
3faf f1				pop af 
3fb0 d1				pop de	 
3fb1				CALLMONITOR 
3fb1 cd 04 13			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4 c9				ret 
3fb5			 
3fb5 .. 00		.mallocerr: 	db "Malloc Error",0 
3fc2			;if DEBUG_FORTH_PUSH 
3fc2			display_data_sp: 
3fc2 f5				push af 
3fc3			 
3fc3				; see if disabled 
3fc3			 
3fc3 3a 31 ee			ld a, (os_view_disable) 
3fc6 fe 2a			cp '*' 
3fc8 28 67			jr z, .skipdsp 
3fca			 
3fca e5				push hl 
3fcb e5				push hl 
3fcc e5			push hl 
3fcd cd bd 09			call clear_display 
3fd0 e1			pop hl 
3fd1 7c				ld a,h 
3fd2 21 37 f1			ld hl, os_word_scratch 
3fd5 cd 17 0e			call hexout 
3fd8 e1				pop hl 
3fd9 7d				ld a,l 
3fda 21 39 f1			ld hl, os_word_scratch+2 
3fdd cd 17 0e			call hexout 
3fe0 21 3b f1			ld hl, os_word_scratch+4 
3fe3 3e 00			ld a,0 
3fe5 77				ld (hl),a 
3fe6 11 37 f1			ld de,os_word_scratch 
3fe9 3e 28				ld a, display_row_2 
3feb cd d0 09				call str_at_display 
3fee 11 48 3f			ld de, .wordinhl 
3ff1 3e 00			ld a, display_row_1 
3ff3			 
3ff3 cd d0 09				call str_at_display 
3ff6 11 77 fb			ld de, debug_mark 
3ff9 3e 11			ld a, display_row_1+17 
3ffb			 
3ffb cd d0 09				call str_at_display 
3ffe			 
3ffe				; display current data stack pointer 
3ffe 11 44 3f			ld de,.data_sp 
4001 3e 30				ld a, display_row_2 + 8 
4003 cd d0 09				call str_at_display 
4006			 
4006 2a 1f f8			ld hl,(cli_data_sp) 
4009 e5				push hl 
400a 7c				ld a,h 
400b 21 37 f1			ld hl, os_word_scratch 
400e cd 17 0e			call hexout 
4011 e1				pop hl 
4012 7d				ld a,l 
4013 21 39 f1			ld hl, os_word_scratch+2 
4016 cd 17 0e			call hexout 
4019 21 3b f1			ld hl, os_word_scratch+4 
401c 3e 00			ld a,0 
401e 77				ld (hl),a 
401f 11 37 f1			ld de,os_word_scratch 
4022 3e 33				ld a, display_row_2 + 11 
4024 cd d0 09				call str_at_display 
4027			 
4027			 
4027 cd e0 09			call update_display 
402a cd 41 09			call delay1s 
402d cd 41 09			call delay1s 
4030 e1				pop hl 
4031			.skipdsp: 
4031 f1				pop af 
4032 c9				ret 
4033			 
4033			display_data_malloc: 
4033			 
4033 f5				push af 
4034 e5				push hl 
4035 e5				push hl 
4036 e5			push hl 
4037 cd bd 09			call clear_display 
403a e1			pop hl 
403b 7c				ld a,h 
403c 21 37 f1			ld hl, os_word_scratch 
403f cd 17 0e			call hexout 
4042 e1				pop hl 
4043 7d				ld a,l 
4044 21 39 f1			ld hl, os_word_scratch+2 
4047 cd 17 0e			call hexout 
404a 21 3b f1			ld hl, os_word_scratch+4 
404d 3e 00			ld a,0 
404f 77				ld (hl),a 
4050 11 37 f1			ld de,os_word_scratch 
4053 3e 28				ld a, display_row_2 
4055 cd d0 09				call str_at_display 
4058 11 7e 3f			ld de, .push_malloc 
405b 3e 00			ld a, display_row_1 
405d			 
405d cd d0 09				call str_at_display 
4060			 
4060				; display current data stack pointer 
4060 11 44 3f			ld de,.data_sp 
4063 3e 30				ld a, display_row_2 + 8 
4065 cd d0 09				call str_at_display 
4068			 
4068 2a 1f f8			ld hl,(cli_data_sp) 
406b e5				push hl 
406c 7c				ld a,h 
406d 21 37 f1			ld hl, os_word_scratch 
4070 cd 17 0e			call hexout 
4073 e1				pop hl 
4074 7d				ld a,l 
4075 21 39 f1			ld hl, os_word_scratch+2 
4078 cd 17 0e			call hexout 
407b 21 3b f1			ld hl, os_word_scratch+4 
407e 3e 00			ld a,0 
4080 77				ld (hl),a 
4081 11 37 f1			ld de,os_word_scratch 
4084 3e 33				ld a, display_row_2 + 11 
4086 cd d0 09				call str_at_display 
4089			 
4089 cd e0 09			call update_display 
408c cd 41 09			call delay1s 
408f cd 41 09			call delay1s 
4092 e1				pop hl 
4093 f1				pop af 
4094 c9				ret 
4095			;endif 
4095			 
4095			include "forth_autostart.asm" 
4095			; list of commands to perform at system start up 
4095			 
4095			startcmds: 
4095			;	dw test11 
4095			;	dw test12 
4095			;	dw test13 
4095			;	dw test14 
4095			;	dw test15 
4095			;	dw test16 
4095			;	dw test17 
4095			;	dw ifthtest1 
4095			;	dw ifthtest2 
4095			;	dw ifthtest3 
4095			;	dw mmtest1 
4095			;	dw mmtest2 
4095			;	dw mmtest3 
4095			;	dw mmtest4 
4095			;	dw mmtest5 
4095			;	dw mmtest6 
4095			;	dw iftest1 
4095			;	dw iftest2 
4095			;	dw iftest3 
4095			;	dw looptest1 
4095			;	dw looptest2 
4095			;	dw test1 
4095			;	dw test2 
4095			;	dw test3 
4095			;	dw test4 
4095			;	dw game2r 
4095			;	dw game2b1 
4095			;	dw game2b2 
4095			 
4095				; start up words that are actually useful 
4095			 
4095 f1 40			dw clrstack 
4097 24 41			dw type 
4099 e5 42			dw stest 
409b 48 41			dw strncpy 
409d 86 42			dw list 
409f a9 41			dw start1 
40a1 bb 41			dw start2 
40a3			;	dw start3 
40a3 ce 41			dw start3b 
40a5 26 42			dw start3c 
40a7			 
40a7				; (unit) testing words 
40a7			 
40a7 5c 43			dw mtesta 
40a9 11 44			dw mtestb 
40ab b4 44			dw mtestc 
40ad 69 45			dw mtestd 
40af 0d 46			dw mteste 
40b1			 
40b1				; demo/game words 
40b1			 
40b1 b0 4c		        dw game3w 
40b3 de 4c		        dw game3p 
40b5 fc 4c		        dw game3sc 
40b7 2d 4d		        dw game3vsi 
40b9 59 4d		        dw game3vs 
40bb				 
40bb a3 4a			dw game2b 
40bd 11 4b			dw game2bf 
40bf 5b 4b			dw game2mba 
40c1 f1 4b			dw game2mbas 
40c3 33 4c			dw game2mb 
40c5			 
40c5 cd 47			dw game1 
40c7 de 47			dw game1a 
40c9 40 48			dw game1b 
40cb 75 48			dw game1c 
40cd ab 48			dw game1d 
40cf dc 48			dw game1s 
40d1 f0 48			dw game1t 
40d3 05 49			dw game1f 
40d5 39 49			dw game1z 
40d7			 
40d7 c3 46			dw test5 
40d9 fb 46			dw test6 
40db 33 47			dw test7 
40dd 47 47			dw test8 
40df 73 47			dw test9 
40e1 89 47			dw test10 
40e3				 
40e3 eb 49		        dw ssv5 
40e5 cf 49		        dw ssv4 
40e7 b3 49		        dw ssv3 
40e9 7d 49		        dw ssv2 
40eb 04 4a		        dw ssv1 
40ed 4c 4a		        dw ssv1cpm 
40ef			;	dw keyup 
40ef			;	dw keydown 
40ef			;	dw keyleft 
40ef			;	dw keyright 
40ef			;	dw 	keyf1 
40ef			;	dw keyf2 
40ef			;	dw keyf3 
40ef			;	dw keyf4 
40ef			;	dw keyf5 
40ef			;	dw keyf6 
40ef			;	dw keyf7 
40ef			;	dw keyf8 
40ef			;	dw keyf9 
40ef			;	dw keyf10 
40ef			;	dw keyf11 
40ef			;	dw keyf12 
40ef			;	dw keytab 
40ef			;	dw keycr 
40ef			;	dw keyhome 
40ef			;	dw keyend 
40ef			;	dw keybs 
40ef 00 00			db 0, 0	 
40f1			 
40f1			 
40f1			; clear stack  
40f1			 
40f1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4124			 
4124			; type ( addr count - ) 
4124 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4148			 
4148			; some direct memory words 
4148			; strncpy ( len t f -- t ) 
4148			 
4148 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
41a9			 
41a9 .. 00		start1:     	db ": bpon $0000 bp ;",0 
41bb .. 00		start2:     	db ": bpoff $0001 bp ;",0 
41ce			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
41ce .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
4226 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4286			 
4286			 
4286			; a handy word to list items on the stack 
4286			 
4286 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
42e5			 
42e5			 
42e5			; test stack  
42e5			; rnd8 stest 
42e5			 
42e5 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
435c			 
435c			; random malloc and free cycles 
435c			 
435c .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4411			 
4411			; fixed malloc and free cycles 
4411			 
4411 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
44b4			 
44b4			; fixed double string push and drop cycle  
44b4			 
44b4 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4569			 
4569			; consistent fixed string push and drop cycle  
4569			 
4569 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
460d			 
460d .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
46c3			 
46c3			;test1:		db ": aa 1 2 3 ;", 0 
46c3			;test2:     	db "111 aa 888 999",0 
46c3			;test3:     	db ": bb 77 ;",0 
46c3			;test4:     	db "$02 $01 do i . loop bb",0 
46c3			 
46c3 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
46fb .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4733 .. 00		test7:     	db ": box hline vline ;",0 
4747 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4773 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4789 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
47ae .. 00		test11:     	db "hello create .",0 
47bd .. 00		test12:     	db "hello2 create .",0 
47cd			 
47cd			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
47cd			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
47cd			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
47cd			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
47cd			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
47cd			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
47cd			 
47cd			;iftest1:     	db "$0001 IF cls .",0 
47cd			;iftest2:     	db "$0000 IF cls .",0 
47cd			;iftest3:     	db "$0002 $0003 - IF cls .",0 
47cd			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
47cd			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
47cd			 
47cd			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
47cd			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
47cd			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
47cd			 
47cd			 
47cd			 
47cd			; a small guess the number game 
47cd			 
47cd .. 00		game1:          db ": gsn rnd8 v1! ;",0 
47de .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4840			 
4840 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4875 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
48ab .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
48dc .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
48f0 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4905 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4939 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
497d			 
497d			 
497d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
497d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
497d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
497d			 
497d			; simple screen saver to test code memory reuse to destruction 
497d			 
497d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
49b3 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
49cf .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
49eb .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4a04 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
4a4c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
4aa3			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
4aa3			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
4aa3			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
4aa3			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
4aa3			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
4aa3			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
4aa3			 
4aa3			 
4aa3			 
4aa3			; minesweeper/battleship finding game 
4aa3			; draws a game board of random ship/mine positions 
4aa3			; user enters coords to see if it hits on 
4aa3			; game ends when all are hit 
4aa3			; when hit or miss says how many may be in the area 
4aa3			 
4aa3			; setup the game board and then hide it 
4aa3 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
4b11 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
4b5b			; prompt for where to target 
4b5b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
4bf1 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
4c16			; TODO see if the entered coords hits or misses pushes char hit of miss 
4c16 .. 00		game2mbht:      db ": mbckht nop ;",0 
4c25 .. 00		game2mbms:      db ": mbcms nop ;",0 
4c33			; TODO how many might be near by 
4c33 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
4cb0			 
4cb0			; Game 3 
4cb0			 
4cb0			; Vert scroller ski game - avoid the trees! 
4cb0			 
4cb0			; v0 score (ie turns) 
4cb0			; v1 player pos 
4cb0			; v2 left wall 
4cb0			; v3 right wall 
4cb0			 
4cb0			; Draw side walls randomly 
4cb0			 
4cb0 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
4cde			 
4cde			; Draw player 
4cde .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
4cfc			 
4cfc			; TODO Get Key 
4cfc			 
4cfc			; TODO Move left right 
4cfc			 
4cfc			; scroll and move walls a bit 
4cfc			 
4cfc .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
4d2d			 
4d2d			; main game loop 
4d2d			 
4d2d .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
4d59 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
4d98			 
4d98			; key board defs 
4d98			 
4d98 .. 00		keyup:       db ": keyup $05 ;",0 
4da6 .. 00		keydown:       db ": keydown $0a ;",0 
4db6 .. 00		keyleft:       db ": keyleft $0b ;",0 
4dc6 .. 00		keyright:       db ": keyright $0c ;",0 
4dd7 .. 00		keyf1:       db ": keyf1 $10 ;",0 
4de5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
4df3 .. 00		keyf3:       db ": keyf3 $12 ;",0 
4e01 .. 00		keyf4:       db ": keyf4 $13 ;",0 
4e0f .. 00		keyf5:       db ": keyf5 $14 ;",0 
4e1d .. 00		keyf6:       db ": keyf6 $15 ;",0 
4e2b .. 00		keyf7:       db ": keyf7 $16 ;",0 
4e39 .. 00		keyf8:       db ": keyf8 $17 ;",0 
4e47 .. 00		keyf9:       db ": keyf9 $18 ;",0 
4e55 .. 00		keyf10:       db ": keyf10 $19 ;",0 
4e64 .. 00		keyf11:       db ": keyf11 $1a ;",0 
4e73 .. 00		keyf12:       db ": keyf12 $1b ;",0 
4e82			 
4e82 .. 00		keytab:       db ": keytab $09 ;",0 
4e91 .. 00		keycr:       db ": keycr $0d ;",0 
4e9f .. 00		keyhome:       db ": keyhome $0e ;",0 
4eaf .. 00		keyend:       db ": keyend $0f ;",0 
4ebe .. 00		keybs:       db ": keybs $08 ;",0 
4ecc			 
4ecc			   
4ecc			 
4ecc			 
4ecc			 
4ecc			; eof 
# End of file forth_autostart.asm
4ecc			 
4ecc .. 00		sprompt1: db "Startup load...",0 
4edc .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
4ef2			 
4ef2			forth_startup: 
4ef2 21 95 40			ld hl, startcmds 
4ef5 3e 00			ld a, 0 
4ef7 32 58 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
4efa			 
4efa e5			.start1:	push hl 
4efb cd bd 09			call clear_display 
4efe 11 cc 4e			ld de, sprompt1 
4f01 3e 00		        ld a, display_row_1 
4f03 cd d0 09			call str_at_display 
4f06 11 dc 4e			ld de, sprompt2 
4f09 3e 28		        ld a, display_row_2 
4f0b cd d0 09			call str_at_display 
4f0e e1				pop hl 
4f0f e5				push hl 
4f10 5e				ld e,(hl) 
4f11 23				inc hl 
4f12 56				ld d,(hl) 
4f13 3e 50		        ld a, display_row_3 
4f15 cd d0 09			call str_at_display 
4f18 cd e0 09			call update_display 
4f1b			 
4f1b			 
4f1b 3a 58 f2			ld a, (os_last_cmd) 
4f1e fe 00			cp 0 
4f20 28 05			jr z, .startprompt 
4f22 cd 35 09			call delay250ms 
4f25 18 24			jr .startdo 
4f27				 
4f27				 
4f27			 
4f27			.startprompt: 
4f27			 
4f27 3e 9f			ld a,display_row_4 + display_cols - 1 
4f29 11 07 18		        ld de, endprg 
4f2c cd d0 09			call str_at_display 
4f2f cd e0 09			call update_display 
4f32 cd 41 09			call delay1s 
4f35 cd 1b 55			call cin_wait 
4f38						 
4f38 fe 2a			cp '*' 
4f3a 28 5e			jr z, .startupend1 
4f3c fe 23			cp '#' 
4f3e 20 07			jr nz, .startno 
4f40 3e 01			ld a, 1 
4f42 32 58 f2			ld (os_last_cmd),a 
4f45 18 04			jr .startdo 
4f47 fe 31		.startno:	cp '1' 
4f49 28 3a			jr z,.startnxt  
4f4b			 
4f4b				; exec startup line 
4f4b			.startdo:	 
4f4b e1				pop hl 
4f4c e5				push hl 
4f4d				 
4f4d 5e				ld e,(hl) 
4f4e 23				inc hl 
4f4f 56				ld d,(hl) 
4f50 eb				ex de,hl 
4f51			 
4f51 e5				push hl 
4f52			 
4f52 3e 00			ld a, 0 
4f54				;ld a, FORTH_END_BUFFER 
4f54 cd 7f 0f			call strlent 
4f57 23				inc hl   ; include zero term to copy 
4f58 06 00			ld b,0 
4f5a 4d				ld c,l 
4f5b e1				pop hl 
4f5c 11 32 ee			ld de, scratch 
4f5f ed b0			ldir 
4f61			 
4f61			 
4f61 21 32 ee			ld hl, scratch 
4f64 cd b1 1a			call forthparse 
4f67 cd f1 1a			call forthexec 
4f6a cd 08 1a			call forthexec_cleanup 
4f6d			 
4f6d 3e 78			ld a, display_row_4 
4f6f 11 ab 15			ld de, endprog 
4f72			 
4f72 cd e0 09			call update_display		 
4f75			 
4f75 3a 58 f2			ld a, (os_last_cmd) 
4f78 fe 00			cp 0 
4f7a 20 09			jr nz, .startnxt 
4f7c cd 09 18			call next_page_prompt 
4f7f cd bd 09		        call clear_display 
4f82 cd e0 09			call update_display		 
4f85			 
4f85				; move onto next startup line? 
4f85			.startnxt: 
4f85			 
4f85 cd 35 09			call delay250ms 
4f88 e1				pop hl 
4f89			 
4f89 23				inc hl 
4f8a 23				inc hl 
4f8b			 
4f8b e5				push hl 
4f8c 5e				ld e, (hl) 
4f8d 23				inc hl 
4f8e 56				ld d, (hl) 
4f8f e1				pop hl 
4f90				; TODO replace 0 test 
4f90			 
4f90 eb				ex de, hl 
4f91 cd 3f 0b			call ishlzero 
4f94			;	ld a,e 
4f94			;	add d 
4f94			;	cp 0    ; any left to do? 
4f94 eb				ex de, hl 
4f95 c2 fa 4e			jp nz, .start1 
4f98 18 01			jr .startupend 
4f9a			 
4f9a e1			.startupend1: pop hl 
4f9b			.startupend: 
4f9b			 
4f9b cd bd 09			call clear_display 
4f9e cd e0 09			call update_display 
4fa1 c9				ret 
4fa2			 
4fa2			 
4fa2			; stack over and underflow checks 
4fa2			 
4fa2			; init the words to detect the under/overflow 
4fa2			 
4fa2			chk_stk_init: 
4fa2				; a vague random number to check so we dont get any "lucky" hits 
4fa2 3e 2d			ld a, 45 
4fa4 6f				ld l, a 
4fa5 00				nop 
4fa6 3e 17			ld a, 23 
4fa8 67				ld h, a 
4fa9			 
4fa9 22 27 ee			ld (chk_word), hl     ; the word we need to check against 
4fac			 
4fac			;	ld (chk_stund), hl	; stack points.... 
4fac 22 fd fb			ld (chk_stovr), hl 
4faf 22 1d f8			ld (chk_ret_und), hl 
4fb2 22 9b f7			ld (chk_ret_ovr), hl 
4fb5 22 99 f5			ld (chk_loop_ovr), hl 
4fb8 22 97 f3			ld (chk_data_ovr), hl 
4fbb c9				ret 
4fbc				 
4fbc			check_stacks: 
4fbc				; check all stack words 
4fbc			 
4fbc e5				push hl 
4fbd d5				push de 
4fbe			 
4fbe			;	ld de,(chk_word) 
4fbe			;	ld hl, (chk_stund)	; stack points.... 
4fbe			;	if DEBUG_STK_FAULT 
4fbe			;		DMARK "FAa" 
4fbe			;		CALLMONITOR 
4fbe			;	endif 
4fbe			;	call cmp16 
4fbe			;	jp z, .chk_faulta 
4fbe			; 
4fbe			;	ld de, sfaultsu 
4fbe			;	jp .chk_fault 
4fbe			 
4fbe 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
4fc1 ed 5b 27 ee		ld de,(chk_word) 
4fc5				if DEBUG_STK_FAULT 
4fc5					DMARK "FAb" 
4fc5					CALLMONITOR 
4fc5				endif 
4fc5 cd 34 0b			call cmp16 
4fc8 28 06			jr z, .chk_fault1 
4fca 11 6b 50			ld de, sfaultso 
4fcd c3 1f 50			jp .chk_fault 
4fd0			.chk_fault1:  
4fd0 2a 1d f8			ld hl, (chk_ret_und) 
4fd3 ed 5b 27 ee		ld de,(chk_word) 
4fd7				if DEBUG_STK_FAULT 
4fd7					DMARK "FAU" 
4fd7					CALLMONITOR 
4fd7				endif 
4fd7 cd 34 0b			call cmp16 
4fda ca e3 4f			jp z, .chk_fault2 
4fdd 11 7b 50			ld de, sfaultru 
4fe0 c3 1f 50			jp .chk_fault 
4fe3			.chk_fault2:  
4fe3 2a 9b f7			ld hl, (chk_ret_ovr) 
4fe6 ed 5b 27 ee		ld de,(chk_word) 
4fea				if DEBUG_STK_FAULT 
4fea					DMARK "FA1" 
4fea					CALLMONITOR 
4fea				endif 
4fea cd 34 0b			call cmp16 
4fed ca f6 4f			jp z, .chk_fault3 
4ff0 11 89 50			ld de, sfaultro 
4ff3 c3 1f 50			jp .chk_fault 
4ff6			.chk_fault3:  
4ff6 2a 99 f5			ld hl, (chk_loop_ovr) 
4ff9 ed 5b 27 ee		ld de,(chk_word) 
4ffd				if DEBUG_STK_FAULT 
4ffd					DMARK "FA2" 
4ffd					CALLMONITOR 
4ffd				endif 
4ffd cd 34 0b			call cmp16 
5000 ca 09 50			jp z, .chk_fault4 
5003 11 a3 50			ld de, sfaultlo 
5006 c3 1f 50			jp .chk_fault 
5009			.chk_fault4:  
5009 2a 97 f3			ld hl, (chk_data_ovr) 
500c ed 5b 27 ee		ld de,(chk_word) 
5010				if DEBUG_STK_FAULT 
5010					DMARK "FA3" 
5010					CALLMONITOR 
5010				endif 
5010 cd 34 0b			call cmp16 
5013 ca 1c 50			jp z, .chk_fault5 
5016 11 bd 50			ld de, sfaultdo 
5019 c3 1f 50			jp .chk_fault 
501c			 
501c			 
501c			.chk_fault5:  
501c d1				pop de 
501d e1				pop hl 
501e			 
501e c9				ret 
501f			 
501f cd bd 09		.chk_fault: 	call clear_display 
5022 3e 28				ld a, display_row_2 
5024 cd d0 09				call str_at_display 
5027 11 4d 50				   ld de, .stackfault 
502a 3e 00				ld a, display_row_1 
502c cd d0 09				call str_at_display 
502f 11 77 fb				    ld de, debug_mark 
5032 3e 11				ld a, display_row_1+17 
5034 cd d0 09				call str_at_display 
5037 cd e0 09				call update_display 
503a			 
503a				; prompt before entering montior for investigating issue 
503a			 
503a 3e 78			ld a, display_row_4 
503c 11 ab 15			ld de, endprog 
503f			 
503f cd e0 09			call update_display		 
5042			 
5042 cd 09 18			call next_page_prompt 
5045			 
5045 d1				pop de 
5046 e1				pop hl 
5047 cd ff 15				call monitor 
504a c3 f9 14				jp warmstart 
504d					;jp 0 
504d					;halt 
504d			 
504d			 
504d			 
504d .. 00		.stackfault: 	db "Stack fault:",0 
505a			 
505a .. 00		sfaultsu: 	db	"Stack under flow",0 
506b .. 00		sfaultso: 	db	"Stack over flow",0 
507b .. 00		sfaultru:	db "RTS underflow",0 
5089 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
50a3 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
50bd .. 00		sfaultdo:	db "DTS overflow", 0 
50ca			 
50ca			 
50ca			fault_dsp_under: 
50ca 11 dc 50			ld de, .dsp_under 
50cd c3 8c 51			jp .show_fault 
50d0			 
50d0			fault_rsp_under: 
50d0 11 ea 50			ld de, .rsp_under 
50d3 c3 8c 51			jp .show_fault 
50d6			fault_loop_under: 
50d6 11 f8 50			ld de, .loop_under 
50d9 c3 8c 51			jp .show_fault 
50dc			 
50dc .. 00		.dsp_under: db "DSP Underflow",0 
50ea .. 00		.rsp_under: db "RSP Underflow",0 
50f8 .. 00		.loop_under: db "LOOP Underflow",0 
5107			 
5107			 
5107 d5			type_faultn: 	push de 
5108 e5					push hl 
5109 cd bd 09				call clear_display 
510c 11 33 51				   ld de, .typefaultn 
510f 3e 00				ld a, display_row_1 
5111 cd d0 09				call str_at_display 
5114 11 77 fb				    ld de, debug_mark 
5117 3e 11				ld a, display_row_1+17 
5119 cd d0 09				call str_at_display 
511c cd e0 09				call update_display 
511f			 
511f				; prompt before entering montior for investigating issue 
511f			 
511f 3e 78			ld a, display_row_4 
5121 11 ab 15			ld de, endprog 
5124			 
5124 cd e0 09			call update_display		 
5127			 
5127 cd 09 18			call next_page_prompt 
512a			 
512a e5					push hl 
512b d5					push de 
512c cd ff 15				call monitor 
512f c3 f9 14				jp warmstart 
5132 76					halt 
5133			 
5133			 
5133 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
514a			 
514a d5			type_faults: 	push de 
514b e5					push hl 
514c cd bd 09				call clear_display 
514f 11 75 51				   ld de, .typefaults 
5152 3e 00				ld a, display_row_1 
5154 cd d0 09				call str_at_display 
5157 11 77 fb				    ld de, debug_mark 
515a 3e 11				ld a, display_row_1+17 
515c cd d0 09				call str_at_display 
515f cd e0 09				call update_display 
5162			 
5162				; prompt before entering montior for investigating issue 
5162			 
5162 3e 78			ld a, display_row_4 
5164 11 ab 15			ld de, endprog 
5167			 
5167 cd e0 09			call update_display		 
516a			 
516a cd 09 18			call next_page_prompt 
516d			 
516d e1					pop hl 
516e d1					pop de 
516f cd ff 15				call monitor 
5172 c3 f9 14				jp warmstart 
5175			 
5175			 
5175 .. 00		.typefaults: db "STR Type Expected TOS!",0 
518c			 
518c			.show_fault: 	 
518c d5					push de 
518d cd bd 09				call clear_display 
5190 d1					pop de 
5191 3e 00				ld a, display_row_1 
5193 cd d0 09				call str_at_display 
5196 11 77 fb				    ld de, debug_mark 
5199 3e 11				ld a, display_row_1+17 
519b cd d0 09				call str_at_display 
519e cd e0 09				call update_display 
51a1			 
51a1				; prompt before entering montior for investigating issue 
51a1			 
51a1 3e 78			ld a, display_row_4 
51a3 11 ab 15			ld de, endprog 
51a6			 
51a6 cd e0 09			call update_display		 
51a9			 
51a9 cd 09 18			call next_page_prompt 
51ac			 
51ac e1					pop hl 
51ad d1					pop de 
51ae cd ff 15				call monitor 
51b1			; do a dump to cli and not warmstart so we preserve all of the uwords.  
51b1			; TODO Make optional fault restart to cli or warm boot? 
51b1					;jp warmstart 
51b1 c3 51 15				jp cli 
51b4 76					halt 
51b5			; eof 
# End of file forth_kernel.asm
51b5			;include "nascombasic.asm" 
51b5			 
51b5			 
51b5			; find out where the code ends if loaded into RAM (for SC114) 
51b5			;endofcode:  
51b5			;	nop 
51b5			 
51b5			 
51b5			; eof 
51b5			 
# End of file main.asm
51b5			include "firmware_lcd_4x40.asm" 
51b5			; **********************************************************************  
51b5			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
51b5			; **********************************************************************  
51b5			;  
51b5			; **  Written as a Small Computer Monitor App  
51b5			; **  www.scc.me.uk  
51b5			;  
51b5			; History  
51b5			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
51b5			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
51b5			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
51b5			;  
51b5			; **********************************************************************  
51b5			;  
51b5			; This program is an example of one of the methods of interfacing an   
51b5			; alphanumeric LCD module.   
51b5			;  
51b5			; In this example the display is connected to either a Z80 PIO or a   
51b5			; simple 8-bit output port.   
51b5			;  
51b5			; This interfacing method uses 4-bit data mode and uses time delays  
51b5			; rather than polling the display's ready status. As a result the   
51b5			; interface only requires 6 simple output lines:  
51b5			;   Output bit 0 = not used  
51b5			;   Output bit 1 = not used  
51b5			;   Output bit 2 = RS         High = data, Low = instruction  
51b5			;   Output bit 3 = E          Active high  
51b5			;   Output bit 4 = DB4  
51b5			;   Output bit 5 = DB5  
51b5			;   Output bit 6 = DB6  
51b5			;   Output bit 7 = DB7  
51b5			; Display's R/W is connected to 0v so it is always in write mode  
51b5			;  
51b5			; This set up should work with any system supporting the RC2014 bus  
51b5			  
51b5			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
51b5			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
51b5			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
51b5			;  
51b5			; **********************************************************************  
51b5			  
51b5			; Additonal for 4x40. E1 and E2 instead of just E   
51b5			; TODO swipe vidout signal on port a to activate E2  
51b5			  
51b5			; **********************************************************************  
51b5			; **  Constants  
51b5			; **********************************************************************  
51b5			; LCD constants required by LCD support module  
51b5			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
51b5			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
51b5			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
51b5			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
51b5			; TODO Decide which E is being set  
51b5			kLCDWidth:  EQU display_cols             ;Width in characters  
51b5			  
51b5			; **********************************************************************  
51b5			; **  Code library usage  
51b5			; **********************************************************************  
51b5			  
51b5			; send character to current cursor position  
51b5			; wraps and/or scrolls screen automatically  
51b5			  
51b5			  
51b5			  
51b5			lcd_init:  
51b5			  
51b5			; SCMonAPI functions used  
51b5			  
51b5			; Alphanumeric LCD functions used  
51b5			; no need to specify specific functions for this module  
51b5			  
51b5 3e cf		            LD   A, 11001111b  
51b7 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
51b9 3e 00		            LD   A, 00000000b  
51bb d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
51bd			  
51bd			; Initialise alphanumeric LCD module  
51bd 3e 00				ld a, 0  
51bf 32 d7 f8				ld (display_lcde1e2), a  
51c2 cd 43 52		            CALL fLCD_Init      ;Initialise LCD module  
51c5 3e 01				ld a, 1  
51c7 32 d7 f8				ld (display_lcde1e2), a  
51ca cd 43 52		            CALL fLCD_Init      ;Initialise LCD module  
51cd			  
51cd c9				ret  
51ce			  
51ce			;  
51ce			;;  
51ce			; lcd functions  
51ce			;  
51ce			;  
51ce			  
51ce			; what is at cursor position   
51ce			  
51ce			;get_cursor:	ld de, (cursor_row)   ;  row + col  
51ce			;		call curptr  
51ce			;		ret  
51ce			  
51ce			  
51ce			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
51ce			  
51ce			curptr:  
51ce c5				push bc  
51cf 21 bd fa			ld hl, display_fb0  
51d2			cpr:	  
51d2				; loop for cursor whole row  
51d2 0e 28			ld c, display_cols  
51d4 23			cpr1:	inc hl  
51d5 0d				dec c  
51d6 20 fc			jr nz, cpr1  
51d8 05				dec b  
51d9 20 f7			jr nz, cpr  
51db			  
51db				; add col	  
51db			  
51db 23			cpr2:	inc hl  
51dc 1d				dec e  
51dd 20 fc			jr nz, cpr2  
51df			  
51df c1				pop bc  
51e0 c9				ret  
51e1				  
51e1			  
51e1			  
51e1			  
51e1			  
51e1			; write the frame buffer given in hl to hardware   
51e1 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
51e4 3e 00			ld a, kLCD_Line1  
51e6 cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
51e9 06 28			ld b, display_cols  
51eb ed 5b d5 f8		ld de, (display_write_tmp)  
51ef cd 3b 52			call write_len_string  
51f2				  
51f2				  
51f2 2a d5 f8			ld hl, (display_write_tmp)  
51f5 11 28 00			ld de, display_cols  
51f8 19				add hl,de  
51f9 22 d5 f8			ld (display_write_tmp),hl  
51fc			  
51fc				  
51fc 3e 28			ld a, kLCD_Line2  
51fe cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5201 06 28			ld b, display_cols  
5203 ed 5b d5 f8		ld de, (display_write_tmp)  
5207 cd 3b 52			call write_len_string  
520a				  
520a 2a d5 f8			ld hl, (display_write_tmp)  
520d 11 28 00			ld de, display_cols  
5210 19				add hl,de  
5211 22 d5 f8			ld (display_write_tmp),hl  
5214			  
5214				  
5214 3e 50			ld a, kLCD_Line3  
5216 cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5219 06 28			ld b, display_cols  
521b ed 5b d5 f8		ld de, (display_write_tmp)  
521f cd 3b 52			call write_len_string  
5222				  
5222 2a d5 f8			ld hl, (display_write_tmp)  
5225 11 28 00			ld de, display_cols  
5228 19				add hl,de  
5229 22 d5 f8			ld (display_write_tmp),hl  
522c			  
522c				  
522c 3e 78			ld a, kLCD_Line4  
522e cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5231 06 28			ld b, display_cols  
5233 ed 5b d5 f8		ld de, (display_write_tmp)  
5237 cd 3b 52			call write_len_string  
523a c9					ret  
523b				  
523b				; write out a fixed length string given in b from de  
523b			  
523b 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
523c cd a8 52		            CALL fLCD_Data      ;Write character to display  
523f 13				inc de  
5240 10 f9			djnz write_len_string  
5242 c9				ret  
5243			  
5243			; Some other things to do  
5243			;            LD   A, kLCD_Clear ;Display clear  
5243			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
5243			;            LD   A, kLCD_Under ;Display on with underscore cursor  
5243			;            LD   A, kLCD_On     ;Display on with no cursor  
5243			;            ;LD   A, kLCD_Off   ;Display off  
5243			;            CALL fLCD_Inst      ;Send instruction to display  
5243			;  
5243			;  
5243			;            halt  
5243			;  
5243			;  
5243			;MsgHello:   DB  "Hello World!",0  
5243			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
5243			  
5243			; Custom characters 5 pixels wide by 8 pixels high  
5243			; Up to 8 custom characters can be defined  
5243			;BitMaps:      
5243			;; Character 0x00 = Battery icon  
5243			;            DB  01110b  
5243			;            DB  11011b  
5243			;            DB  10001b  
5243			;            DB  10001b  
5243			;            DB  11111b  
5243			;            DB  11111b  
5243			;            DB  11111b  
5243			;            DB  11111b  
5243			;; Character 0x01 = Bluetooth icon  
5243			;            DB  01100b  
5243			;            DB  01010b  
5243			;            DB  11100b  
5243			;            DB  01000b  
5243			;            DB  11100b  
5243			;            DB  01010b  
5243			;            DB  01100b  
5243			;            DB  00000b  
5243			;  
5243			  
5243			  
5243			; **********************************************************************  
5243			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
5243			; **********************************************************************  
5243			;  
5243			; **  Written as a Small Computer Monitor App   
5243			; **  Version 0.1 SCC 2018-05-16  
5243			; **  www.scc.me.uk  
5243			;  
5243			; **********************************************************************  
5243			;  
5243			; This module provides support for alphanumeric LCD modules using with  
5243			; *  HD44780 (or compatible) controller  
5243			; *  5 x 7 pixel fonts  
5243			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
5243			; *  Interface via six digital outputs to the display (see below)  
5243			;  
5243			; LCD module pinout:  
5243			;   1  Vss   0v supply  
5243			;   2  Vdd   5v supply  
5243			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
5243			;   4  RS    High = data, Low = instruction  
5243			;   5  R/W   High = Read, Low = Write  
5243			;   6  E     Enable signal (active high)  
5243			;   7  DB0   Data bit 0  
5243			;   8  DB1   Data bit 1  
5243			;   9  DB2   Data bit 2  
5243			;  10  DB3   Data bit 3  
5243			;  11  DB4   Data bit 4  
5243			;  12  DB5   Data bit 5  
5243			;  13  DB6   Data bit 6  
5243			;  14  DB7   Data bit 7  
5243			;  15  A     Backlight anode (+)  
5243			;  16  K     Backlight cathode (-)  
5243			;  
5243			; This interfacing method uses 4-bit data mode and uses time delays  
5243			; rather than polling the display's ready status. As a result the   
5243			; interface only requires 6 simple output lines:  
5243			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
5243			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
5243			;   LCD DB4 = Microcomputer output port bit 4  
5243			;   LCD DB5 = Microcomputer output port bit 5  
5243			;   LCD DB6 = Microcomputer output port bit 6  
5243			;   LCD DB7 = Microcomputer output port bit 7  
5243			; Display's R/W is connected to 0v so it is always in write mode  
5243			; All 6 connections must be on the same port address <kLCDPrt>  
5243			; This method also allows a decent length of cable from micro to LCD  
5243			;  
5243			; **********************************************************************  
5243			;  
5243			; To include the code for any given function provided by this module,   
5243			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
5243			; the parent source file.  
5243			; For example:  #REQUIRES   uHexPrefix  
5243			;  
5243			; Also #INCLUDE this file at some point after the #REQUIRES statements  
5243			; in the parent source file.  
5243			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
5243			;  
5243			; These are the function names provided by this module:  
5243			; fLCD_Init                     ;Initialise LCD  
5243			; fLCD_Inst                     ;Send instruction to LCD  
5243			; fLCD_Data                     ;Send data byte to LCD  
5243			; fLCD_Pos                      ;Position cursor  
5243			; fLCD_Str                      ;Display string  
5243			; fLCD_Def                      ;Define custom character  
5243			;  
5243			; **********************************************************************  
5243			;  
5243			; Requires SCMonAPI.asm to also be included in the project  
5243			;  
5243			  
5243			  
5243			; **********************************************************************  
5243			; **  Constants  
5243			; **********************************************************************  
5243			  
5243			; Constants that must be defined externally  
5243			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
5243			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
5243			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
5243			;kLCDWidth: EQU 20             ;Width in characters  
5243			  
5243			; general line offsets in any frame buffer  
5243			  
5243			  
5243			display_row_1: equ 0  
5243			display_row_2: equ display_row_1+display_cols  
5243			display_row_3: equ display_row_2 + display_cols  
5243			display_row_4: equ display_row_3 + display_cols  
5243			;display_row_4_eol:   
5243			  
5243			  
5243			; Cursor position values for the start of each line  
5243			  
5243			; E  
5243			kLCD_Line1: EQU 0x00   
5243			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
5243			; E1  
5243			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
5243			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
5243			  
5243			; Instructions to send as A register to fLCD_Inst  
5243			kLCD_Clear: EQU 00000001b     ;LCD clear  
5243			kLCD_Off:   EQU 00001000b     ;LCD off  
5243			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
5243			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
5243			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
5243			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
5243			  
5243			; Constants used by this code module  
5243			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
5243			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
5243			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
5243			  
5243			  
5243			  
5243			; **********************************************************************  
5243			; **  LCD support functions  
5243			; **********************************************************************  
5243			  
5243			; Initialise alphanumeric LCD module  
5243			; LCD control register codes:  
5243			;   DL   0 = 4-bit mode        1 = 8-bit mode  
5243			;   N    0 = 1-line mode       1 = 2-line mode  
5243			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
5243			;   D    0 = Display off       1 = Display on  
5243			;   C    0 = Cursor off        1 = Cursor on  
5243			;   B    0 = Blinking off      1 = Blinking on  
5243			;   ID   0 = Decrement mode    1 = Increment mode  
5243			;   SH   0 = Entire shift off  1 = Entire shift on  
5243 3e 28		fLCD_Init:  LD   A, 40  
5245 cd 6a 53		            CALL LCDDelay       ;Delay 40ms after power up  
5248			; For reliable reset set 8-bit mode - 3 times  
5248 cd 3a 53		            CALL WrFn8bit       ;Function = 8-bit mode  
524b cd 3a 53		            CALL WrFn8bit       ;Function = 8-bit mode  
524e cd 3a 53		            CALL WrFn8bit       ;Function = 8-bit mode  
5251			; Set 4-bit mode  
5251 cd 36 53		            CALL WrFn4bit       ;Function = 4-bit mode  
5254 cd 68 53		            CALL LCDDelay1      ;Delay 37 us or more  
5257			; Function set  
5257 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
5259 cd 6c 52		            CALL fLCD_Inst      ;2 line, display on  
525c			; Display On/Off control  
525c 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
525e cd 6c 52		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
5261			; Display Clear  
5261 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
5263 cd 6c 52		            CALL fLCD_Inst      ;Clear display  
5266			; Entry mode  
5266 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
5268 cd 6c 52		            CALL fLCD_Inst      ;Increment mode, shift off  
526b			; Display module now initialised  
526b c9			            RET  
526c			; ok to here  
526c			  
526c			; Write instruction to LCD  
526c			;   On entry: A = Instruction byte to be written  
526c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
526c f5			fLCD_Inst:  PUSH AF  
526d f5			            PUSH AF  
526e cd 80 52		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
5271 f1			            POP  AF  
5272 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
5273 17			            RLA  
5274 17			            RLA  
5275 17			            RLA  
5276 cd 80 52		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
5279 3e 02		            LD   A, 2  
527b cd 6a 53		            CALL LCDDelay       ;Delay 2 ms to complete   
527e f1			            POP  AF  
527f c9			            RET  
5280			Wr4bits:   
5280 f5					push af  
5281 3a d7 f8				ld a, (display_lcde1e2)  
5284 fe 00				cp 0     ; e  
5286 20 10				jr nz, .wea2	  
5288 f1					pop af  
5289 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
528b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
528d cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
528f cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
5291 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
5293 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
5295 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5297 c9			            RET  
5298 f1			.wea2:		pop af  
5299 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
529b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
529d cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
529f cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
52a1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
52a3 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
52a5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
52a7 c9			            RET  
52a8			  
52a8			  
52a8			; Write data to LCD  
52a8			;   On entry: A = Data byte to be written  
52a8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
52a8 f5			fLCD_Data:  PUSH AF  
52a9 f5			            PUSH AF  
52aa cd bc 52		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
52ad f1			            POP  AF  
52ae 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
52af 17			            RLA  
52b0 17			            RLA  
52b1 17			            RLA  
52b2 cd bc 52		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
52b5 3e 96		            LD   A, 150  
52b7 3d			Wait:      DEC  A              ;Wait a while to allow data   
52b8 20 fd		            JR   NZ, Wait      ;  write to complete  
52ba f1			            POP  AF  
52bb c9			            RET  
52bc			Wr4bitsa:     
52bc f5					push af  
52bd 3a d7 f8				ld a, (display_lcde1e2)  
52c0 fe 00				cp 0     ; e1  
52c2 20 16				jr nz, .we2	  
52c4 f1					pop af  
52c5 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
52c7 cb d7		            SET  kLCDBitRS, A  
52c9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
52cb cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
52cd cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
52cf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
52d1 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
52d3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
52d5 cb 97		            RES  kLCDBitRS, A  
52d7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
52d9 c9			            RET  
52da f1			.we2:		pop af  
52db e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
52dd cb d7		            SET  kLCDBitRS, A  
52df d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
52e1 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
52e3 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
52e5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
52e7 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
52e9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
52eb cb 97		            RES  kLCDBitRS, A  
52ed d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
52ef c9			            RET  
52f0			  
52f0			  
52f0			; Position cursor to specified location  
52f0			;   On entry: A = Cursor position  
52f0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
52f0 f5			fLCD_Pos:   PUSH AF  
52f1					; at this point set the E1 or E2 flag depending on position  
52f1			  
52f1 c5					push bc  
52f2			;		push af  
52f2 06 00				ld b, 0  
52f4 4f					ld c, a  
52f5 3e 4f				ld a, kLCD_Line3-1  
52f7 b7			 		or a      ;clear carry flag  
52f8 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
52f9 38 04				jr c, .pe1  
52fb			  
52fb					; E selection  
52fb cb 80				res 0, b         ; bit 0 unset e  
52fd			;		pop af    ; before line 3 so recover orig pos  
52fd			;		ld c, a    ; save for poking back  
52fd 18 06				jr .peset	          
52ff			.pe1:          	; E2 selection  
52ff cb c0				set 0, b         ; bit 0 set e1  
5301 79					ld a, c  
5302 de 4f				sbc a, kLCD_Line3-1  
5304 4f					ld c, a	         ; save caculated offset  
5305			;		pop af     ; bin this original value now we have calculated form  
5305			  
5305			.peset:		; set bit  
5305 78					ld a, b  
5306 32 d7 f8				ld (display_lcde1e2), a 	  
5309 79					ld a, c  
530a c1					pop bc  
530b			  
530b f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
530d cd 6c 52		            CALL fLCD_Inst      ;Write instruction to LCD  
5310 f1			            POP  AF  
5311 c9			            RET  
5312			  
5312			  
5312			; Output text string to LCD  
5312			;   On entry: DE = Pointer to null terminated text string  
5312			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
5312 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
5313 b7			            OR   A              ;Null terminator?  
5314 c8			            RET  Z              ;Yes, so finished  
5315 cd a8 52		            CALL fLCD_Data      ;Write character to display  
5318 13			            INC  DE             ;Point to next character  
5319 18 f7		            JR   fLCD_Str       ;Repeat  
531b c9					ret  
531c			  
531c			; Define custom character  
531c			;   On entry: A = Character number (0 to 7)  
531c			;             DE = Pointer to character bitmap data  
531c			;   On exit:  A = Next character number  
531c			;             DE = Next location following bitmap  
531c			;             BC HL IX IY I AF' BC' DE' HL' preserved  
531c			; Character is   
531c c5			fLCD_Def:   PUSH BC  
531d f5			            PUSH AF  
531e 07			            RLCA                ;Calculate location  
531f 07			            RLCA                ;  for bitmap data  
5320 07			            RLCA                ;  = 8 x CharacterNumber  
5321 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
5323 cd 6c 52		            CALL fLCD_Inst      ;Write instruction to LCD  
5326 06 00		            LD   B, 0  
5328 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
5329 cd a8 52		            CALL fLCD_Data      ;Write byte to display  
532c 13			            INC  DE             ;Point to next byte  
532d 04			            INC  B              ;Count bytes  
532e cb 58		            BIT  3, B           ;Finish all 8 bytes?  
5330 28 f6		            JR   Z, Loop       ;No, so repeat  
5332 f1			            POP  AF  
5333 3c			            INC  A              ;Increment character number  
5334 c1			            POP  BC  
5335 c9			            RET  
5336			  
5336			  
5336			; **********************************************************************  
5336			; **  Private functions  
5336			; **********************************************************************  
5336			  
5336			; Write function to LCD  
5336			;   On entry: A = Function byte to be written  
5336			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
5336 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
5338 18 02		            JR   WrFunc  
533a 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
533c f5			WrFunc:     PUSH AF  
533d f5					push af  
533e 3a d7 f8				ld a, (display_lcde1e2)  
5341 fe 00				cp 0     ; e1  
5343 20 0f				jr nz, .wfea2	  
5345 f1					pop af  
5346 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5348 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
534a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
534c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
534e cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
5350 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5352 18 0d			jr .wfskip  
5354 f1			.wfea2:		pop af  
5355 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5357 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
5359 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
535b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
535d cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
535f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5361 3e 05		.wfskip:            LD  A, 5  
5363 cd 6a 53		            CALL LCDDelay       ;Delay 5 ms to complete  
5366 f1			            POP  AF  
5367 c9			            RET  
5368			  
5368			  
5368			; Delay in milliseconds  
5368			;   On entry: A = Number of milliseconds delay  
5368			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
5368 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
536a d5			LCDDelay:   PUSH DE  
536b 5f			            LD   E, A           ;Delay by 'A' ms  
536c 16 00		            LD   D, 0  
536e cd 26 09		            CALL aDelayInMS  
5371 d1			            POP  DE  
5372 c9			            RET  
5373			  
5373			  
5373			testlcd:  
5373 3e 00			ld a, kLCD_Line1  
5375 cd f0 52			call fLCD_Pos  
5378 06 28			ld b, 40  
537a 11 a8 53			ld de, .ttext1  
537d cd 3b 52			call write_len_string  
5380			  
5380 3e 28			ld a, kLCD_Line2  
5382 cd f0 52			call fLCD_Pos  
5385 06 28			ld b, 40  
5387 11 d1 53			ld de, .ttext2  
538a cd 3b 52			call write_len_string  
538d 3e 50			ld a, kLCD_Line3  
538f cd f0 52			call fLCD_Pos  
5392 06 28			ld b, 40  
5394 11 fa 53			ld de, .ttext3  
5397 cd 3b 52			call write_len_string  
539a 3e 78			ld a, kLCD_Line4  
539c cd f0 52			call fLCD_Pos  
539f 06 28			ld b, 40  
53a1 11 23 54			ld de, .ttext4  
53a4 cd 3b 52			call write_len_string  
53a7			  
53a7 76				halt  
53a8			  
53a8			  
53a8 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
53d1 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
53fa .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
5423 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
544c			   
544c			  
544c			  
544c			; eof  
544c			  
# End of file firmware_lcd_4x40.asm
544c			;include "firmware_lcd_4x20.asm" 
544c			include "firmware_key_5x10.asm" 
544c			; 5 x 10 decade counter scanner  
544c			  
544c			  
544c			; TODO do cursor shape change for shift keys  
544c			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
544c			  
544c			  
544c			; bit mask for each scan column and row for teing the matrix  
544c			  
544c			  
544c			key_init:  
544c			  
544c			; SCMonAPI functions used  
544c			  
544c			; Alphanumeric LCD functions used  
544c			; no need to specify specific functions for this module  
544c			  
544c			  
544c 3e cf		            LD   A, 11001111b  
544e d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
5450			;            LD   A, 00000000b  
5450 3e 1f		            LD   A, 00011111b  
5452 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
5454			  
5454			  
5454				; TODO Configure cursor shapes  
5454			  
5454				; Load cursor shapes   
5454 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
5456 11 66 54		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
5459 06 02		            LD   B, 2           ;Number of characters to define  
545b cd 1c 53		.DefLoop:   CALL fLCD_Def       ;Define custom character  
545e 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
5460			  
5460 3e 01				ld a, 1  
5462 32 d0 f8			ld (cursor_shape),a  
5465 c9				ret  
5466			  
5466			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
5466			; Up to 8 custom characters can be defined  
5466			.cursor_shapes:      
5466			;; Character 0x00 = Normal  
5466 1f			            DB  11111b  
5467 1f			            DB  11111b  
5468 1f			            DB  11111b  
5469 1f			            DB  11111b  
546a 1f			            DB  11111b  
546b 1f			            DB  11111b  
546c 1f			            DB  11111b  
546d 1f			            DB  11111b  
546e			;; Character 0x01 = Modifier  
546e 1f			            DB  11111b  
546f 1b			            DB  11011b  
5470 1b			            DB  11011b  
5471 1b			            DB  11011b  
5472 1b			            DB  11011b  
5473 1f			            DB  11111b  
5474 1b			            DB  11011b  
5475 1f			            DB  11111b  
5476			  
5476			  
5476			  
5476			  
5476			; Display custom character 0  
5476			;            LD   A, kLCD_Line1+14  
5476			;            CALL fLCD_Pos       ;Position cursor to location in A  
5476			;            LD   A, 0  
5476			;            CALL fLCD_Data      ;Write character in A at cursor  
5476			  
5476			; Display custom character 1  
5476			;            LD   A, kLCD_Line2+14  
5476			;            CALL fLCD_Pos      ;Position cursor to location in A  
5476			;            LD   A, 1  
5476			;            CALL fLCD_Data     ;Write character in A at cursor  
5476			  
5476			; keyboard scanning   
5476			  
5476			; character in from keyboard  
5476			  
5476			; mapping for the pcb layout  
5476			  
5476			.matrix_to_char:  
5476 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
5481 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
548c 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
5497 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
54a2 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
54ad			.matrix_to_shift:  
54ad			  
54ad .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
54b8 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
54c3 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
54ce 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
54d9 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
54e4			  
54e4			.matrix_to_symbolshift:  
54e4			  
54e4 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
54ef .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
54fa 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
5505 7e .. 7e 00			db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
5510 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
551b			  
551b			  
551b			  
551b			; mapping for a simple straight through breadboard layout  
551b			  
551b			;.matrix_to_char:  
551b			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
551b			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
551b			;		db "asdfghjkl",KEY_CR,0  
551b			;		db "qwertyuiop",0  
551b			;		 db "1234567890",0  
551b			;.matrix_to_shift:  
551b			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
551b			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
551b			;		db "ASDFGHJKL",KEY_CR,0  
551b			;		db "QWERTYUIOP",0  
551b			;		 db "!",'"',"#$%^&*()",0  
551b			;.matrix_to_symbolshift:  
551b			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
551b			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
551b			;		db "_?*fghjk=",KEY_CR,0  
551b			;		db "-/+*[]{}@#",0  
551b			;		 db "1234567890",0  
551b			  
551b			;.matrix_to_char: db "D#0*C987B654A321"  
551b			  
551b			  
551b				  
551b			  
551b			; add cin and cin_wait  
551b			  
551b cd 2c 55		cin_wait: 	call cin  
551e						if DEBUG_KEYCINWAIT  
551e							push af  
551e							  
551e							ld hl,key_repeat_ct  
551e							ld (hl),a  
551e							inc hl  
551e							call hexout  
551e							ld hl,key_repeat_ct+3  
551e							ld a,0  
551e							ld (hl),a  
551e			  
551e							    LD   A, kLCD_Line1+11  
551e							    CALL fLCD_Pos       ;Position cursor to location in A  
551e							    LD   DE, key_repeat_ct  
551e							    ;LD   DE, MsgHello  
551e							    CALL fLCD_Str       ;Display string pointed to by DE  
551e			  
551e			  
551e			  
551e							pop af  
551e						endif  
551e fe 00			cp 0  
5520 28 f9			jr z, cin_wait   ; block until key press  
5522			  
5522							if DEBUG_KEYCINWAIT  
5522								push af  
5522			  
5522								ld a, 'A'	  
5522								ld hl,key_repeat_ct  
5522								ld (hl),a  
5522								inc hl  
5522								ld a,0  
5522								ld (hl),a  
5522			  
5522								    LD   A, kLCD_Line2+11  
5522								    CALL fLCD_Pos       ;Position cursor to location in A  
5522								    LD   DE, key_repeat_ct  
5522								    ;LD   DE, MsgHello  
5522								    CALL fLCD_Str       ;Display string pointed to by DE  
5522			  
5522							call delay500ms  
5522			  
5522								pop af  
5522							endif  
5522 f5				push af   ; save key pressed  
5523			  
5523			.cin_wait1:	  
5523							if DEBUG_KEYCINWAIT  
5523								push af  
5523			  
5523								ld a, 'b'	  
5523								ld hl,key_repeat_ct  
5523								ld (hl),a  
5523								inc hl  
5523								ld a,0  
5523								ld (hl),a  
5523			  
5523								    LD   A, kLCD_Line2+11  
5523								    CALL fLCD_Pos       ;Position cursor to location in A  
5523								    LD   DE, key_repeat_ct  
5523								    ;LD   DE, MsgHello  
5523								    CALL fLCD_Str       ;Display string pointed to by DE  
5523			  
5523			  
5523							call delay500ms  
5523			  
5523								pop af  
5523							endif  
5523			  
5523 cd 2c 55		call cin  
5526 fe 00			cp 0  
5528 20 f9			jr nz, .cin_wait1  	; wait for key release  
552a			if DEBUG_KEYCINWAIT  
552a				push af  
552a			  
552a				ld a, '3'	  
552a				ld hl,key_repeat_ct  
552a				ld (hl),a  
552a				inc hl  
552a				ld a,0  
552a				ld (hl),a  
552a			  
552a			            LD   A, kLCD_Line2+11  
552a			            CALL fLCD_Pos       ;Position cursor to location in A  
552a			            LD   DE, key_repeat_ct  
552a			            ;LD   DE, MsgHello  
552a			            CALL fLCD_Str       ;Display string pointed to by DE  
552a			  
552a			  
552a			call delay500ms  
552a			  
552a				pop af  
552a			endif  
552a			  
552a f1				pop af   ; get key  
552b c9				ret  
552c			  
552c			  
552c cd 40 55		cin: 	call .mtoc  
552f			  
552f			if DEBUG_KEYCIN  
552f				push af  
552f				  
552f				ld hl,key_repeat_ct  
552f				ld (hl),a  
552f				inc hl  
552f				call hexout  
552f				ld hl,key_repeat_ct+3  
552f				ld a,0  
552f				ld (hl),a  
552f			  
552f			            LD   A, kLCD_Line3+15  
552f			            CALL fLCD_Pos       ;Position cursor to location in A  
552f			            LD   DE, key_repeat_ct  
552f			            ;LD   DE, MsgHello  
552f			            CALL fLCD_Str       ;Display string pointed to by DE  
552f			  
552f			  
552f			call delay500ms  
552f			  
552f				pop af  
552f			endif  
552f			  
552f			  
552f				; no key held  
552f fe 00			cp 0  
5531 c8				ret z  
5532			  
5532			if DEBUG_KEYCIN  
5532				push af  
5532			  
5532				ld a, '1'	  
5532				ld hl,key_repeat_ct  
5532				ld (hl),a  
5532				inc hl  
5532				ld a,0  
5532				ld (hl),a  
5532			  
5532			            LD   A, kLCD_Line4+15  
5532			            CALL fLCD_Pos       ;Position cursor to location in A  
5532			            LD   DE, key_repeat_ct  
5532			            ;LD   DE, MsgHello  
5532			            CALL fLCD_Str       ;Display string pointed to by DE  
5532			  
5532			  
5532			call delay500ms  
5532			  
5532				pop af  
5532			endif  
5532			  
5532				; stop key bounce  
5532			  
5532 32 88 fb			ld (key_held),a		 ; save it  
5535 47				ld b, a  
5536			  
5536 c5			.cina1:	push bc  
5537			if DEBUG_KEYCIN  
5537				push af  
5537			  
5537				ld hl,key_repeat_ct  
5537				inc hl  
5537				call hexout  
5537				ld hl,key_repeat_ct+3  
5537				ld a,0  
5537				ld (hl),a  
5537				ld hl,key_repeat_ct  
5537				ld a, '2'	  
5537				ld (hl),a  
5537			  
5537			            LD   A, kLCD_Line4+15  
5537			            CALL fLCD_Pos       ;Position cursor to location in A  
5537			            LD   DE, key_repeat_ct  
5537			            ;LD   DE, MsgHello  
5537			            CALL fLCD_Str       ;Display string pointed to by DE  
5537			  
5537				pop af  
5537			endif  
5537 cd 40 55			call .mtoc  
553a c1				pop bc  
553b b8				cp b  
553c 28 f8			jr z, .cina1  
553e 78				ld a,b		  
553f			if DEBUG_KEYCIN  
553f				push af  
553f			  
553f				ld hl,key_repeat_ct  
553f				inc hl  
553f				call hexout  
553f				ld hl,key_repeat_ct+3  
553f				ld a,0  
553f				ld (hl),a  
553f				ld hl,key_repeat_ct  
553f				ld a, '3'	  
553f				ld (hl),a  
553f			  
553f			            LD   A, kLCD_Line4+15  
553f			            CALL fLCD_Pos       ;Position cursor to location in A  
553f			            LD   DE, key_repeat_ct  
553f			            ;LD   DE, MsgHello  
553f			            CALL fLCD_Str       ;Display string pointed to by DE  
553f			  
553f				pop af  
553f			endif  
553f c9				ret  
5540			  
5540			; detect keyboard modifier key press and apply new overlay to the face key held  
5540			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
5540			  
5540			;.cin_map_modifier:   
5540			;	ld a, (hl)  
5540			;	and 255  
5540			;	ret NZ		; modifier key not flagged  
5540			;  
5540			;	; get key face  
5540			;  
5540			;	ld b,(key_face_held)  
5540			;  
5540			;	ld b, key_cols * key_rows  
5540			;  
5540			;	push de  
5540			;	pop hl  
5540			;  
5540			;.mmod1: ld a,(hl)   ; get map test  
5540			;	cp b  
5540			;	jr z, .mmod2  
5540			;  
5540			;  
5540			;  
5540			;.mmod2: inc hl    ;   
5540			;  
5540			;	  
5540			;  
5540			;	  
5540			;  
5540			;	ld hl,key_actual_pressed  
5540			;	ld (hl),a,  
5540			;	ret  
5540			  
5540			; map matrix key held to char on face of key  
5540			  
5540			.mtoc:  
5540			  
5540			; test decade counter strobes  
5540			  
5540			;.decadetest1:  
5540			  
5540			; reset counter  
5540			;ld a, 128  
5540			;out (portbdata),a  
5540			  
5540			  
5540			;ld b, 5  
5540			;.dec1:  
5540			;ld a, 0  
5540			;out (portbdata),a  
5540			;call delay1s  
5540			  
5540			;ld a, 32  
5540			;out (portbdata),a  
5540			;call delay1s  
5540			;call delay1s  
5540			;call delay1s  
5540			;  
5540			;ld a, 64+32  
5540			;out (portbdata),a  
5540			;call delay1s  
5540			;;djnz .dec1  
5540			;  
5540			;jp .decadetest1  
5540			  
5540			  
5540			  
5540			  
5540			  
5540			  
5540			  
5540			  
5540			  
5540			  
5540				; scan keyboard matrix and generate raw scan map  
5540 cd d3 55			call matrix  
5543			  
5543				; reuse c bit 0 left modifer button - ie shift  
5543			        ; reuse c bit 1 for right modifer button - ie symbol shift  
5543				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
5543			  
5543 0e 00			ld c, 0  
5545			  
5545				; TODO set flags for modifer key presses   
5545				; TODO do a search for modifer key...  
5545			  
5545				;ld hl,keyscan_table_row4  
5545 21 e7 fb			ld hl,keyscan_table_row2  
5548			  
5548 7e				ld a, (hl)  
5549 fe 23			cp '#'  
554b 20 07			jr nz, .nextmodcheck  
554d cb c1			set 0, c  
554f 21 ad 54			ld hl, .matrix_to_shift  
5552 18 21			jr .dokeymap  
5554				; TODO for now igonre  
5554			.nextmodcheck:  
5554 21 dc fb			ld hl,keyscan_table_row3  
5557			  
5557 7e				ld a, (hl)  
5558 fe 23			cp '#'  
555a 20 07			jr nz, .nextmodcheck2  
555c cb c9			set 1, c   
555e 21 e4 54			ld hl, .matrix_to_symbolshift  
5561 18 12			jr .dokeymap  
5563			.nextmodcheck2:  
5563 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
5566			  
5566 7e				ld a, (hl)  
5567 fe 23			cp '#'  
5569 20 07			jr nz, .donemodcheck  
556b cb c9			set 1, c   
556d 21 ad 54			ld hl, .matrix_to_shift  
5570 18 03			jr .dokeymap  
5572			  
5572				; no modifer found so just map to normal keys  
5572				; get mtoc map matrix to respective keys  
5572			;	ld hl, .matrix_to_char  
5572			;	ld hl, .matrix_to_char  
5572			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
5572			;	ld a, KEY_SHIFT  
5572			;	call findchar  
5572			;  
5572			;	; got offset to key modifer in b  
5572			;  
5572			;	ld hl,keyscan_table_row5  
5572			;  
5572			;	ld a,b  
5572			;	call addatohl  
5572			;	ld a,(hl)  
5572			;  
5572			;	cp '#'  
5572			;	jr nz, .nextmodcheck  
5572			;	set 0, c  
5572			;	ld hl, .matrix_to_char  
5572			;	jr .dokeymap  
5572			;	; TODO for now igonre  
5572			;.nextmodcheck:  
5572			;	ld hl, .matrix_to_symbolshift  
5572			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
5572			;	ld a, KEY_SYMBOLSHIFT  
5572			;	call findchar  
5572			;  
5572			;  
5572			;	; got offset to key modifer in b  
5572			;  
5572			;	ld hl,keyscan_table_row5  
5572			;  
5572			;	ld a,b  
5572			;	call addatohl  
5572			;	ld a,(hl)  
5572			;  
5572			;	cp '#'  
5572			;	jr nz, .donemodcheck  
5572			;	set 1, c   
5572			;	ld hl, .matrix_to_symbolshift  
5572			;	jr .dokeymap  
5572			  
5572			  
5572			  
5572			.donemodcheck:  
5572				; no modifer found so just map to normal keys  
5572				; get mtoc map matrix to respective keys  
5572 21 76 54			ld hl, .matrix_to_char  
5575			  
5575			.dokeymap:  
5575				;ld (key_fa), c   
5575 cd 8e 55			call .mapkeys  
5578			  
5578			  
5578			if DEBUG_KEY  
5578			  
5578			; Display text on first line  
5578			            LD   A, kLCD_Line1  
5578			            CALL fLCD_Pos       ;Position cursor to location in A  
5578			            LD   DE, keyscan_table_row1  
5578			            ;LD   DE, MsgHello  
5578			            CALL fLCD_Str       ;Display string pointed to by DE  
5578			  
5578			; Display text on second line  
5578			            LD   A, kLCD_Line2  
5578			            CALL fLCD_Pos       ;Position cursor to location in A  
5578			            LD   DE, keyscan_table_row2  
5578			            CALL fLCD_Str       ;Display string pointed to by DE  
5578			            LD   A, kLCD_Line3  
5578			            CALL fLCD_Pos       ;Position cursor to location in A  
5578			            LD   DE, keyscan_table_row3  
5578			            CALL fLCD_Str       ;Display string pointed to by DE  
5578			            LD   A, kLCD_Line4  
5578			            CALL fLCD_Pos       ;Position cursor to location in A  
5578			            LD   DE, keyscan_table_row4  
5578			            CALL fLCD_Str       ;Display string pointed to by DE  
5578			            LD   A, kLCD_Line1+10  
5578			            CALL fLCD_Pos       ;Position cursor to location in A  
5578			            LD   DE, keyscan_table_row5  
5578			            CALL fLCD_Str       ;Display string pointed to by DE  
5578			  
5578				;call delay250ms  
5578			endif  
5578			;	jp testkey  
5578			  
5578			; get first char reported  
5578			  
5578 21 c6 fb			ld hl,keyscan_table_row5  
557b			  
557b				;ld b, 46   ; 30 keys to remap + 8 nulls   
557b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
557d			.findkey:  
557d 7e				ld a,(hl)  
557e fe 00			cp 0  
5580 28 04			jr z, .nextkey  
5582 fe 7e			cp KEY_MATRIX_NO_PRESS  
5584 20 06			jr nz, .foundkey  
5586			.nextkey:  
5586 23				inc hl  
5587 10 f4			djnz .findkey  
5589 3e 00			ld a,0  
558b c9				ret  
558c			.foundkey:  
558c 7e				ld a,(hl)  
558d c9				ret  
558e				  
558e			  
558e			; convert the raw key map given hl for destination key  
558e			.mapkeys:  
558e 11 c6 fb			ld de,keyscan_table_row5  
5591			  
5591 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
5593			.remap:  
5593 1a				ld a,(de)  
5594 fe 23			cp '#'  
5596 20 02			jr nz, .remapnext  
5598				;CALLMONITOR  
5598 7e				ld a,(hl)  
5599 12				ld (de),a  
559a			  
559a			  
559a			  
559a			.remapnext:  
559a 23				inc hl  
559b 13				inc de  
559c 10 f5			djnz .remap  
559e				  
559e c9				ret  
559f			  
559f			  
559f			  
559f			.mtocold2:  
559f			  
559f			;	; flag if key D is held down and remove from reporting  
559f			;	ld bc, .key_map_fd    
559f			;	ld hl, keyscan_table  
559f			;	ld de, key_fd  
559f			;	call .key_shift_hold  
559f			;	cp 255  
559f			;	jr z, .cinmap  
559f			;	; flag if key C is held down and remove from reporting  
559f			;	ld bc, .key_map_fc    
559f			;	ld hl, keyscan_table+key_cols  
559f			;	ld de, key_fc  
559f			;	call .key_shift_hold  
559f			;	cp 255  
559f			;	jr z, .cinmap  
559f			;	; flag if key B is held down and remove from reporting  
559f			;	ld bc, .key_map_fb    
559f			;	ld hl, keyscan_table+(key_cols*2)  
559f			;	ld de, key_fb  
559f			;	call .key_shift_hold  
559f			;	cp 255  
559f			;	jr z, .cinmap  
559f			;	; flag if key A is held down and remove from reporting  
559f			;	ld bc, .key_map_fa    
559f			;	ld hl, keyscan_table+(key_cols*3)  
559f			;	ld de, key_fa  
559f			;	call .key_shift_hold  
559f			;	cp 255  
559f			;	jr z, .cinmap  
559f			  
559f 11 76 54			ld de, .matrix_to_char  
55a2			  
55a2			  
55a2			.cinmap1:   
55a2				if DEBUG_KEY  
55a2			            LD   A, kLCD_Line4  
55a2			            CALL fLCD_Pos       ;Position cursor to location in A  
55a2					push de  
55a2			            LD   DE, keyscan_table  
55a2			            CALL fLCD_Str       ;Display string pointed to by DE  
55a2					pop de  
55a2				endif  
55a2			  
55a2				; scan key matrix table for any held key  
55a2			  
55a2				; de holds either the default matrix or one selected above  
55a2			  
55a2 21 93 fb			ld hl, keyscan_table  
55a5 06 32			ld b,key_cols*key_rows  
55a7			  
55a7 7e			.cin11:	ld a,(hl)  
55a8 fe 23			cp '#'  
55aa 28 08			jr z, .cinhit1  
55ac 23				inc hl  
55ad 13				inc de  
55ae 05				dec b  
55af 20 f6			jr nz, .cin11  
55b1				; no key found held  
55b1 3e 00			ld a,0  
55b3 c9				ret  
55b4 d5			.cinhit1: push de  
55b5 e1				pop hl  
55b6 7e				ld a,(hl)  
55b7 c9				ret  
55b8			  
55b8			; flag a control key is held   
55b8			; hl is key pin, de is flag indicator  
55b8			  
55b8			.key_shift_hold1:  
55b8 c5				push bc  
55b9 3e 01			ld a, 1  
55bb 32 d0 f8			ld (cursor_shape),a  
55be 06 00			ld b, 0  
55c0 7e				ld a, (hl)  
55c1 fe 2e			cp '.'  
55c3 28 0a			jr z, .key_shift11  
55c5 06 ff			ld b, 255  
55c7 3e 2b			ld a, '+'    ; hide key from later scans  
55c9 77				ld (hl),a  
55ca 3e 02			ld a, 2  
55cc 32 d0 f8			ld (cursor_shape),a  
55cf			.key_shift11:  
55cf				; write flag indicator  
55cf 78				ld a,b  
55d0 12				ld (de),a  
55d1			  
55d1 d1				pop de    ; de now holds the key map ptr  
55d2 c9				ret  
55d3			  
55d3				  
55d3			  
55d3			; scans keyboard matrix and flags key press in memory array	  
55d3				  
55d3			matrix:  
55d3				;call matrix  
55d3				; TODO optimise the code....  
55d3			  
55d3			  
55d3			;ld hl, keyscan_table_row1  
55d3			;ld de, keyscan_table_row1+1  
55d3			;ld bc,46  
55d3			;ld a,KEY_MATRIX_NO_PRESS  
55d3			;ldir  
55d3			  
55d3			  
55d3			  
55d3			; reset counter  
55d3 3e 80		ld a, 128  
55d5 d3 c1		out (portbdata),a  
55d7			  
55d7 06 0a		ld b, 10  
55d9 0e 00		ld c, 0       ; current clock toggle  
55db			  
55db			.colscan:  
55db			  
55db			; set current column  
55db			; disable clock enable and set clock low  
55db			  
55db			;ld a, 0  
55db			;out (portbdata),a  
55db			  
55db			; For each column scan for switches  
55db			  
55db c5			push bc  
55dc 21 89 fb		ld hl, keyscan_scancol  
55df cd e8 56		call .rowscan  
55e2 c1			pop bc  
55e3			  
55e3			  
55e3			; get back current column  
55e3			  
55e3			; translate the row scan  
55e3			  
55e3			;   
55e3			; row 1  
55e3			  
55e3 78			ld a,b  
55e4			  
55e4 21 fc fb		LD   hl, keyscan_table_row1+10  
55e7			  
55e7 cd 28 0b		call subafromhl  
55ea			;call addatohl  
55ea			  
55ea 11 89 fb		ld de, keyscan_scancol  
55ed			  
55ed 1a			ld a,(de)  
55ee 77			ld (hl),a  
55ef			  
55ef			  
55ef			  
55ef			  
55ef			; row 2  
55ef			  
55ef 78			ld a,b  
55f0			  
55f0 21 f1 fb		LD   hl, keyscan_table_row2+10  
55f3			  
55f3			;call addatohl  
55f3 cd 28 0b		call subafromhl  
55f6			  
55f6			  
55f6 11 8a fb		ld de, keyscan_scancol+1  
55f9			  
55f9 1a			ld a,(de)  
55fa 77			ld (hl),a  
55fb			  
55fb			  
55fb			; row 3  
55fb			  
55fb 78			ld a,b  
55fc			  
55fc 21 e6 fb		LD   hl, keyscan_table_row3+10  
55ff			  
55ff			;call addatohl  
55ff cd 28 0b		call subafromhl  
5602			  
5602 11 8b fb		ld de, keyscan_scancol+2  
5605			  
5605 1a			ld a,(de)  
5606 77			ld (hl),a  
5607			  
5607			  
5607			  
5607			; row 4  
5607			  
5607 78			ld a,b  
5608			  
5608 21 db fb		LD   hl, keyscan_table_row4+10  
560b			  
560b			;call addatohl  
560b cd 28 0b		call subafromhl  
560e			  
560e 11 8c fb		ld de, keyscan_scancol+3  
5611			  
5611 1a			ld a,(de)  
5612 77			ld (hl),a  
5613			  
5613			; row 5  
5613			  
5613 78			ld a,b  
5614			  
5614 21 d0 fb		LD   hl, keyscan_table_row5+10  
5617			  
5617			;call addatohl  
5617 cd 28 0b		call subafromhl  
561a			  
561a 11 8d fb		ld de, keyscan_scancol+4  
561d			  
561d 1a			ld a,(de)  
561e 77			ld (hl),a  
561f			  
561f			; handshake next column  
561f			  
561f			  
561f 3e 40		ld a, 64  
5621 d3 c1		out (portbdata),a  
5623			  
5623 3e 00		ld a, 0  
5625 d3 c1		out (portbdata),a  
5627			  
5627			; toggle clk and move to next column  
5627			;ld a, 64  
5627			;cp c  
5627			;  
5627			;jr z, .coltoglow  
5627			;ld c, a  
5627			;jr .coltog  
5627			;.coltoglow:  
5627			;ld c, 0  
5627			;.coltog:  
5627			;ld a, c  
5627			;out (portbdata),a  
5627			  
5627 10 b2		djnz .colscan  
5629			  
5629 3e 0a		ld a,10  
562b 21 f2 fb		LD   hl, keyscan_table_row1  
562e cd 16 0b		call addatohl  
5631 3e 00		ld a, 0  
5633 77			ld (hl), a  
5634			  
5634			  
5634 3e 0a		ld a,10  
5636 21 e7 fb		LD   hl, keyscan_table_row2  
5639 cd 16 0b		call addatohl  
563c 3e 00		ld a, 0  
563e 77			ld (hl), a  
563f			  
563f 3e 0a		ld a,10  
5641 21 dc fb		LD   hl, keyscan_table_row3  
5644 cd 16 0b		call addatohl  
5647 3e 00		ld a, 0  
5649 77			ld (hl), a  
564a			  
564a 3e 0a		ld a,10  
564c 21 d1 fb		LD   hl, keyscan_table_row4  
564f cd 16 0b		call addatohl  
5652 3e 00		ld a, 0  
5654 77			ld (hl), a  
5655			  
5655 3e 0a		ld a,10  
5657 21 c6 fb		LD   hl, keyscan_table_row5  
565a cd 16 0b		call addatohl  
565d 3e 00		ld a, 0  
565f 77			ld (hl), a  
5660			  
5660			if DEBUG_KEY_MATRIX  
5660			  
5660			; Display text on first line  
5660			            LD   A, kLCD_Line1  
5660			            CALL fLCD_Pos       ;Position cursor to location in A  
5660			            LD   DE, keyscan_table_row1  
5660			            ;LD   DE, MsgHello  
5660			            CALL fLCD_Str       ;Display string pointed to by DE  
5660			  
5660			; Display text on second line  
5660			            LD   A, kLCD_Line2  
5660			            CALL fLCD_Pos       ;Position cursor to location in A  
5660			            LD   DE, keyscan_table_row2  
5660			            CALL fLCD_Str       ;Display string pointed to by DE  
5660			            LD   A, kLCD_Line3  
5660			            CALL fLCD_Pos       ;Position cursor to location in A  
5660			            LD   DE, keyscan_table_row3  
5660			            CALL fLCD_Str       ;Display string pointed to by DE  
5660			            LD   A, kLCD_Line4  
5660			            CALL fLCD_Pos       ;Position cursor to location in A  
5660			            LD   DE, keyscan_table_row4  
5660			            CALL fLCD_Str       ;Display string pointed to by DE  
5660			            LD   A, kLCD_Line4+10  
5660			            CALL fLCD_Pos       ;Position cursor to location in A  
5660			            LD   DE, keyscan_table_row5  
5660			            CALL fLCD_Str       ;Display string pointed to by DE  
5660			  
5660			;call delay250ms  
5660				jp matrix  
5660			endif  
5660 c9			ret  
5661			  
5661			; using decade counter....  
5661			  
5661			  
5661			; TODO reset decade counter to start of scan  
5661			  
5661			; reset 15  
5661			; clock 14  
5661			; ce 13  
5661			  
5661			; 1 - q5  
5661			; 2 - q1  
5661			; 3 - q0  
5661			; 4 - q2  
5661			; 5 - q6  
5661			; 6 - q7  
5661			; 7 - q3  
5661			; 8 - vss  
5661			; 9 - q8  
5661			; 10 - q4  
5661			; 11 - q9  
5661			; 12 - cout  
5661			; 16 - vdd  
5661			  
5661			; clock      ce       reset     output  
5661			; 0          x        0         n  
5661			; x          1        0         n  
5661			; x          x        1         q0  
5661			; rising     0        0         n+1  
5661			; falling    x        0         n  
5661			; x          rising   0         n  
5661			; 1          falling  0         x+1  
5661			;  
5661			; x = dont care, if n < 5 carry = 1 otherwise 0  
5661			  
5661			;   
5661			; reset   
5661			; 13=0, 14=0, 15=1 .. 15=0  
5661			;  
5661			; handshake line  
5661			; 14=1.... read line 14=0  
5661			  
5661			  
5661			  
5661			  
5661			  
5661			; TODO hand shake clock for next column scan  
5661			; TODO detect each row  
5661			  
5661			  
5661			  
5661			  
5661			; reset 128  
5661			; clock 64  
5661			; ce 32  
5661			  
5661			  
5661			.cyclestart:  
5661			  
5661			; reset counter  
5661 3e 80		ld a, 128  
5663 d3 c1		out (portbdata),a  
5665			  
5665			; loop leds  
5665 06 0a		ld b,10  
5667			  
5667			.cycle1:  
5667 c5			push bc  
5668 3e 00		ld a, 0  
566a d3 c1		out (portbdata),a  
566c cd 35 09		call delay250ms  
566f			  
566f 3e 40		ld a, 64  
5671 d3 c1		out (portbdata),a  
5673 cd 35 09		call delay250ms  
5676			  
5676 3e 00		ld a, 0  
5678 d3 c1		out (portbdata),a  
567a cd 35 09		call delay250ms  
567d			  
567d c1			pop bc  
567e 10 e7		djnz .cycle1  
5680			  
5680			  
5680 18 df		jr .cyclestart  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			; map matrix key held to char on face of key  
5682			  
5682			;.mtocold:  
5682			;  
5682			;  
5682			;; reset counter  
5682			;ld a, 128  
5682			;out (portbdata),a  
5682			;  
5682			;  
5682			;; scan keyboard row 1  
5682			;ld a, 0  
5682			;out (portbdata),a  
5682			;;ld a, 64  
5682			;;out (portbdata),a  
5682			;  
5682			;  
5682			;	ld a, 128  
5682			;	ld hl, keyscan_table  
5682			;	call .rowscan  
5682			;  
5682			;;ld a, 0  
5682			;;out (portbdata),a  
5682			;ld a, 64  
5682			;out (portbdata),a  
5682			;  
5682			;	ld a, 64  
5682			;	ld hl, keyscan_table+key_cols  
5682			;	call .rowscan  
5682			;  
5682			;ld a, 0  
5682			;out (portbdata),a  
5682			;;ld a, 64  
5682			;;out (portbdata),a  
5682			;	ld a, 32  
5682			;	ld hl, keyscan_table+(key_cols*2)  
5682			;	call .rowscan  
5682			;  
5682			;  
5682			;;ld a, 0  
5682			;;out (portbdata),a  
5682			;ld a, 64  
5682			;out (portbdata),a  
5682			;  
5682			;	ld a, 16  
5682			;	ld hl, keyscan_table+(key_cols*3)  
5682			;	call .rowscan  
5682			;  
5682			;  
5682			;	; flag if key D is held down and remove from reporting  
5682			;	ld bc, .key_map_fd    
5682			;	ld hl, keyscan_table  
5682			;	ld de, key_fd  
5682			;	call .key_shift_hold  
5682			;	cp 255  
5682			;	jr z, .cinmap  
5682			;	; flag if key C is held down and remove from reporting  
5682			;	ld bc, .key_map_fc    
5682			;	ld hl, keyscan_table+key_cols  
5682			;	ld de, key_fc  
5682			;	call .key_shift_hold  
5682			;	cp 255  
5682			;	jr z, .cinmap  
5682			;	; flag if key B is held down and remove from reporting  
5682			;	ld bc, .key_map_fb    
5682			;	ld hl, keyscan_table+(key_cols*2)  
5682			;	ld de, key_fb  
5682			;	call .key_shift_hold  
5682			;	cp 255  
5682			;	jr z, .cinmap  
5682			;	; flag if key A is held down and remove from reporting  
5682			;	ld bc, .key_map_fa    
5682			;	ld hl, keyscan_table+(key_cols*3)  
5682			;	ld de, key_fa  
5682			;	call .key_shift_hold  
5682			;	cp 255  
5682			;	jr z, .cinmap  
5682			;  
5682			;	ld de, .matrix_to_char  
5682			;  
5682			;  
5682			;.cinmap:   
5682			;	if DEBUG_KEY  
5682			;            LD   A, kLCD_Line4  
5682			;            CALL fLCD_Pos       ;Position cursor to location in A  
5682			;		push de  
5682			;            LD   DE, keyscan_table  
5682			;            CALL fLCD_Str       ;Display string pointed to by DE  
5682			;		pop de  
5682			;	endif  
5682			  
5682				; scan key matrix table for any held key  
5682			  
5682				; de holds either the default matrix or one selected above  
5682			  
5682			;	ld hl, keyscan_table  
5682			;	ld b,key_cols*key_rows  
5682			;  
5682			;.cin1:	ld a,(hl)  
5682			;	cp '#'  
5682			;	jr z, .cinhit  
5682			;	inc hl  
5682			;	inc de  
5682			;	dec b  
5682			;	jr nz, .cin1  
5682			;	; no key found held  
5682			;	ld a,0  
5682			;	ret  
5682			;.cinhit: push de  
5682			;	pop hl  
5682			;	ld a,(hl)  
5682			;	ret  
5682			  
5682			; flag a control key is held   
5682			; hl is key pin, de is flag indicator  
5682			  
5682			;.key_shift_hold:  
5682			;	push bc  
5682			;	ld a, 1  
5682			;	ld (cursor_shape),a  
5682			;	ld b, 0  
5682			;	ld a, (hl)  
5682			;	cp '.'  
5682			;	jr z, .key_shift1  
5682			;	ld b, 255  
5682			;	ld a, '+'    ; hide key from later scans  
5682			;	ld (hl),a  
5682			;	ld a, 2  
5682			;	ld (cursor_shape),a  
5682			;.key_shift1:  
5682			;	; write flag indicator  
5682			;	ld a,b  
5682			;	ld (de),a  
5682			;  
5682			;	pop de    ; de now holds the key map ptr  
5682			;	ret  
5682			  
5682				  
5682				  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			  
5682			;	push hl  
5682			;	push de  
5682			;	push bc  
5682			;	call keyscan  
5682			;	; map key matrix to ascii value of key face  
5682			;  
5682			;	ld hl, key_face_map  
5682			;	ld de, keyscan_table  
5682			;  
5682			;	; get how many keys to look at  
5682			;	ld b, keyscan_table_len  
5682			;	  
5682			;  
5682			;	; at this stage fall out on first key hit  
5682			;	; TODO handle multiple key press  
5682			;  
5682			;map1:	ld a,(hl)  
5682			;	cp '#'  
5682			;	jr z, keyhit  
5682			;	inc hl  
5682			;	inc de  
5682			;	dec b  
5682			;	jr nz, map1  
5682			;nohit:	ld a, 0  
5682			;	jr keydone  
5682			;keyhit: push de  
5682			;	pop hl  
5682			;	ld a,(hl)  
5682			;keydone:  
5682			;	push bc  
5682			;	push de  
5682			; 	push hl  
5682			;	ret   
5682			;  
5682			  
5682			  
5682			  
5682			  
5682			; scan physical key matrix  
5682			  
5682			  
5682			;keyscan:  
5682			;  
5682			;; for each key_row use keyscanr bit mask for out  
5682			;; then read in for keyscanc bitmask  
5682			;; save result of row scan to keyscantable  
5682			;  
5682			;; scan keyboard row 1  
5682			;  
5682			;	ld b, key_rows  
5682			;	ld hl, key_scanr  
5682			;	ld de, keyscan_table  
5682			;  
5682			;rowloop:  
5682			;  
5682			;	ld a,(hl)		; out bit mask to energise keyboard row  
5682			;	call rowscan  
5682			;	inc hl  
5682			;	dec b  
5682			;	jr nz, rowloop  
5682			;  
5682			;	ret  
5682			;  
5682			;  
5682			;; pass a out bitmask, b row number  
5682			;arowscan:   
5682			;	push bc  
5682			;  
5682			;	ld d, b  
5682			;  
5682			;	; calculate buffer location for this row  
5682			;  
5682			;	ld hl, keyscan_table	  
5682			;kbufr:  ld e, key_cols  
5682			;kbufc:	inc hl  
5682			;	dec e  
5682			;	jr nz, kbufc  
5682			;	dec d  
5682			;	jr nz, kbufr  
5682			;  
5682			;	; energise row and read columns  
5682			;  
5682			;	out (portbdata),a  
5682			;	in a,(portbdata)  
5682			;	ld c,a  
5682			;  
5682			;  
5682			;	; save buffer loc  
5682			;  
5682			;	ld (keybufptr), hl  
5682			;  
5682			;	ld hl, key_scanc  
5682			;	ld d, key_cols  
5682			;  
5682			;	; for each column check each bit mask  
5682			;  
5682			;colloop:  
5682			;	  
5682			;  
5682			;	; reset flags for the row   
5682			;  
5682			;	ld b,'.'  
5682			;	and (hl)  
5682			;	jr z, maskskip  
5682			;	ld b,'#'  
5682			;maskskip:  
5682			;	; save  key state  
5682			;	push hl  
5682			;	ld hl, (keybufptr)  
5682			;	ld (hl), b  
5682			;	inc hl  
5682			;	ld (keybufptr), hl  
5682			;  
5682			;	; move to next bit mask  
5682			;	pop hl  
5682			;	inc hl  
5682			;  
5682			;	dec d  
5682			;	jr nz, colloop  
5682			;  
5682			;	ret  
5682			;  
5682			;  
5682			;;  
5682			; lcd functions  
5682			;  
5682			;  
5682			  
5682			;if DEBUG_KEY_MATRIX  
5682			  
5682			; test function to display hardware view of matrix state  
5682			  
5682			matrixold:  
5682			  
5682			  
5682			  
5682			; reset counter  
5682 3e 80		ld a, 128  
5684 d3 c1		out (portbdata),a  
5686			; scan keyboard row 1  
5686 3e 00		ld a, 0  
5688 d3 c1		out (portbdata),a  
568a			;ld a, 64  
568a			;out (portbdata),a  
568a 3e 80			ld a, 128  
568c 21 f2 fb			ld hl, keyscan_table_row1  
568f cd e8 56			call .rowscan  
5692			  
5692			;ld a, 0  
5692			;out (portbdata),a  
5692 3e 40		ld a, 64  
5694 d3 c1		out (portbdata),a  
5696 3e 40			ld a, 64  
5698 21 e7 fb			ld hl, keyscan_table_row2  
569b cd e8 56			call .rowscan  
569e			  
569e 3e 00		ld a, 0  
56a0 d3 c1		out (portbdata),a  
56a2			;ld a, 64  
56a2			;out (portbdata),a  
56a2 3e 20			ld a, 32  
56a4 21 dc fb			ld hl, keyscan_table_row3  
56a7 cd e8 56			call .rowscan  
56aa			  
56aa			;ld a, 0  
56aa			;out (portbdata),a  
56aa 3e 40		ld a, 64  
56ac d3 c1		out (portbdata),a  
56ae 3e 10			ld a, 16  
56b0 21 d1 fb			ld hl, keyscan_table_row4  
56b3 cd e8 56			call .rowscan  
56b6			  
56b6			; Display text on first line  
56b6 3e 00		            LD   A, kLCD_Line1  
56b8 cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
56bb 11 f2 fb		            LD   DE, keyscan_table_row1  
56be			            ;LD   DE, MsgHello  
56be cd 12 53		            CALL fLCD_Str       ;Display string pointed to by DE  
56c1			  
56c1			; Display text on second line  
56c1 3e 28		            LD   A, kLCD_Line2  
56c3 cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
56c6 11 e7 fb		            LD   DE, keyscan_table_row2  
56c9 cd 12 53		            CALL fLCD_Str       ;Display string pointed to by DE  
56cc 3e 50		            LD   A, kLCD_Line3  
56ce cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
56d1 11 dc fb		            LD   DE, keyscan_table_row3  
56d4 cd 12 53		            CALL fLCD_Str       ;Display string pointed to by DE  
56d7 3e 78		            LD   A, kLCD_Line4  
56d9 cd f0 52		            CALL fLCD_Pos       ;Position cursor to location in A  
56dc 11 d1 fb		            LD   DE, keyscan_table_row4  
56df cd 12 53		            CALL fLCD_Str       ;Display string pointed to by DE  
56e2			  
56e2 cd 35 09			call delay250ms  
56e5 c3 d3 55			jp matrix  
56e8			  
56e8			; pass de as row display flags  
56e8			.rowscan:   
56e8			;	out (portbdata),a  
56e8 db c1			in a,(portbdata)  
56ea 4f				ld c,a  
56eb				; reset flags for the row   
56eb 06 7e			ld b,KEY_MATRIX_NO_PRESS  
56ed e6 01			and 1  
56ef 28 02			jr z, .p1on  
56f1 06 23			ld b,'#'  
56f3			.p1on:  
56f3 70				ld (hl), b  
56f4 23				inc hl  
56f5			  
56f5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
56f7 79				ld a,c  
56f8 e6 02			and 2  
56fa			;	bit 0,a  
56fa 28 02			jr z, .p2on  
56fc 06 23			ld b,'#'  
56fe			.p2on:  
56fe 70				ld (hl), b  
56ff 23				inc hl  
5700			;  
5700 06 7e			ld b,KEY_MATRIX_NO_PRESS  
5702 79				ld a,c  
5703 e6 04			and 4  
5705			;;	bit 0,a  
5705 28 02			jr z, .p3on  
5707 06 23			ld b,'#'  
5709			.p3on:  
5709 70				ld (hl), b  
570a 23				inc hl  
570b			;;  
570b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
570d			;;	bit 0,a  
570d 79				ld a,c  
570e e6 08			and 8  
5710 28 02			jr z, .p4on  
5712 06 23			ld b,'#'  
5714			.p4on:  
5714 70				ld (hl), b  
5715 23				inc hl  
5716			  
5716 06 7e			ld b,KEY_MATRIX_NO_PRESS  
5718			;;	bit 0,a  
5718 79				ld a,c  
5719 e6 10			and 16  
571b 28 02			jr z, .p5on  
571d 06 23			ld b,'#'  
571f			.p5on:  
571f 70				ld (hl), b  
5720 23				inc hl  
5721			; zero term  
5721 06 00			ld b,0  
5723 70				ld (hl), b  
5724			  
5724 c9			.rscandone: ret  
5725			  
5725			;addatohl:  
5725			;  
5725			 ;add   a, l    ; A = A+L  
5725			  ;  ld    l, a    ; L = A+L  
5725			   ; adc   a, h    ; A = A+L+H+carry  
5725			   ; sub   l       ; A = H+carry  
5725			   ; ld    h, a    ; H = H+carry  
5725			  
5725			;ret  
5725			; eof  
# End of file firmware_key_5x10.asm
5725			;include "firmware_key_4x10.asm" 
5725			 
5725			heap_size:    equ heap_end - heap_start 
5725			;eof 
# End of file os_mega.asm
5725
