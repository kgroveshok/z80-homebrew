# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 51 93			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 0   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ os_input  
8003			os_new_parse_len: equ os_new_malloc + 2  
8003			os_new_word_len: equ os_new_parse_len + 2  
8003			os_new_work_ptr: equ os_new_word_len + 2  
8003			os_new_src_ptr: equ os_new_work_ptr + 2  
8003			os_new_exec: equ os_new_src_ptr + 2  
8003			os_new_exec_ptr: equ os_new_exec + 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ scratch - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 5e 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 5e 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 5e 88				call clear_display  
8023			  
8023			  
8023 cd ef d3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 91 d4			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 5a 8e				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 81 88			call update_display  
8032 cd e2 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 63 88			call fill_display  
803a cd 81 88			call update_display  
803d cd e2 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 63 88			call fill_display  
8045 cd 81 88			call update_display  
8048 cd e2 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 63 88			call fill_display  
8050 cd 81 88			call update_display  
8053 cd e2 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 71 88			call str_at_display  
805e cd 81 88			call update_display  
8061			  
8061			  
8061 cd e2 87			call delay1s  
8064 cd e2 87			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 71 88			call str_at_display  
806f cd 81 88			call update_display  
8072 cd e2 87			call delay1s  
8075 cd e2 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 7b 91			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 7b 91			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd c7 83			call storage_findnextid 
8105			 
8105 cd e0 89			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 7b 91			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 7b 91			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 7b 91			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 7b 91			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 7b 91			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 21 65 eb			ld hl, store_page 
81d3 3e 00			ld a, 0 
81d5				 
81d5 77				ld (hl),a   ; reset file counter 
81d6			 
81d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81d9 22 66 eb		 	ld (store_page+1), hl	 
81dc			 
81dc				; set default label 
81dc			 
81dc 21 71 82			ld hl, .defaultbanklabl 
81df 11 68 eb		 	ld de, store_page+3 
81e2 01 0f 00			ld bc, 15 
81e5 ed b0			ldir 
81e7			 
81e7				; save default page 0 
81e7			 
81e7 21 00 00			ld hl, 0 
81ea 11 65 eb			ld de, store_page 
81ed				if DEBUG_STORESE 
81ed					DMARK "SB3" 
81ed f5				push af  
81ee 3a 02 82			ld a, (.dmark)  
81f1 32 7a ee			ld (debug_mark),a  
81f4 3a 03 82			ld a, (.dmark+1)  
81f7 32 7b ee			ld (debug_mark+1),a  
81fa 3a 04 82			ld a, (.dmark+2)  
81fd 32 7c ee			ld (debug_mark+2),a  
8200 18 03			jr .pastdmark  
8202 ..			.dmark: db "SB3"  
8205 f1			.pastdmark: pop af  
8206			endm  
# End of macro DMARK
8206			;		push af 
8206			;		ld a, 'F' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206					CALLMONITOR 
8206 cd 7b 91			call break_point_state  
8209				endm  
# End of macro CALLMONITOR
8209				endif 
8209 cd 16 81			call storage_write_block 
820c				if DEBUG_STORESE 
820c					DMARK "SB4" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 7a ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 7b ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 7c ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SB4"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			;		push af 
8225			;		ld a, '>' 
8225			;		ld (debug_mark),a 
8225			;		pop af 
8225					CALLMONITOR 
8225 cd 7b 91			call break_point_state  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228			 
8228 00				nop 
8229 00				nop 
822a 00				nop 
822b			 
822b				; now set 0 in every page to mark as a free block 
822b			 
822b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
822d 21 40 00			ld hl, STORE_BLOCK_PHY 
8230			 
8230 3e 00		.setmark1:   	ld a,0 
8232 e5					push hl 
8233 c5					push bc 
8234 cd af 80				call se_writebyte 
8237 3e 0a			ld a, 10 
8239 cd c7 87			call aDelayInMS 
823c 23				inc hl 
823d cd af 80				call se_writebyte 
8240 3e 0a			ld a, 10 
8242 cd c7 87			call aDelayInMS 
8245 2b				dec hl 
8246 c1					pop bc 
8247 e1					pop hl 
8248 3e 40				ld a, STORE_BLOCK_PHY 
824a cd b7 89				call addatohl 
824d 10 e1				djnz .setmark1 
824f			 
824f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8251 3e 00		.setmark2:   	ld a,0 
8253 e5					push hl 
8254 c5					push bc 
8255 cd af 80				call se_writebyte 
8258 3e 0a			ld a, 10 
825a cd c7 87			call aDelayInMS 
825d 23				inc hl 
825e cd af 80				call se_writebyte 
8261 3e 0a			ld a, 10 
8263 cd c7 87			call aDelayInMS 
8266 2b				dec hl 
8267 c1					pop bc 
8268 e1					pop hl 
8269 3e 40				ld a, STORE_BLOCK_PHY 
826b cd b7 89				call addatohl 
826e 10 e1				djnz .setmark2 
8270			 
8270					 
8270			 
8270			 
8270 c9				ret 
8271			 
8271			 
8271			 
8271			 
8271 .. 00		.defaultbanklabl:   db "BankLabel",0 
827b			 
827b			 
827b			 
827b			; Label Bank 
827b			; ---------- 
827b			; 
827b			; With current bank 
827b			; Read block 0 
827b			; Set label 
827b			; Write block 0 
827b			 
827b			; label str pointer in hl 
827b			 
827b			storage_label:     
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "LBL" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 7a ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 7b ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 7c ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "LBL"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					CALLMONITOR 
8294 cd 7b 91			call break_point_state  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 e5				push hl 
8298			 
8298 cd 62 81			call storage_get_block_0 
829b			 
829b				; set default label 
829b			 
829b e1				pop hl 
829c			 
829c 11 68 eb		 	ld de, store_page+3 
829f 01 0f 00			ld bc, 15 
82a2				if DEBUG_STORESE 
82a2					DMARK "LB3" 
82a2 f5				push af  
82a3 3a b7 82			ld a, (.dmark)  
82a6 32 7a ee			ld (debug_mark),a  
82a9 3a b8 82			ld a, (.dmark+1)  
82ac 32 7b ee			ld (debug_mark+1),a  
82af 3a b9 82			ld a, (.dmark+2)  
82b2 32 7c ee			ld (debug_mark+2),a  
82b5 18 03			jr .pastdmark  
82b7 ..			.dmark: db "LB3"  
82ba f1			.pastdmark: pop af  
82bb			endm  
# End of macro DMARK
82bb					CALLMONITOR 
82bb cd 7b 91			call break_point_state  
82be				endm  
# End of macro CALLMONITOR
82be				endif 
82be ed b0			ldir 
82c0				; save default page 0 
82c0			 
82c0 21 00 00			ld hl, 0 
82c3 11 65 eb			ld de, store_page 
82c6				if DEBUG_STORESE 
82c6					DMARK "LBW" 
82c6 f5				push af  
82c7 3a db 82			ld a, (.dmark)  
82ca 32 7a ee			ld (debug_mark),a  
82cd 3a dc 82			ld a, (.dmark+1)  
82d0 32 7b ee			ld (debug_mark+1),a  
82d3 3a dd 82			ld a, (.dmark+2)  
82d6 32 7c ee			ld (debug_mark+2),a  
82d9 18 03			jr .pastdmark  
82db ..			.dmark: db "LBW"  
82de f1			.pastdmark: pop af  
82df			endm  
# End of macro DMARK
82df					CALLMONITOR 
82df cd 7b 91			call break_point_state  
82e2				endm  
# End of macro CALLMONITOR
82e2				endif 
82e2 cd 16 81			call storage_write_block 
82e5			 
82e5 c9				ret 
82e6			 
82e6			 
82e6			 
82e6			; Read Block 0 - Config 
82e6			; --------------------- 
82e6			; 
82e6			; With current bank 
82e6			; Call presence test 
82e6			;    If not present format/init bank  
82e6			; Read block 0  
82e6			;  
82e6			 
82e6			 
82e6			; Dir 
82e6			; --- 
82e6			; 
82e6			; With current bank 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block read byte 2 
82e6			;      if first block of file 
82e6			;         Display file name 
82e6			;         Display type flags for file 
82e6			;        
82e6			 
82e6			; moving to words as this requires stack control 
82e6			 
82e6			 
82e6			; Delete File 
82e6			; ----------- 
82e6			; 
82e6			; With current bank 
82e6			; 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block file id 
82e6			;      If first block of file and dont have file id 
82e6			;         if file to delete 
82e6			;         Save file id 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			;      If file id is one saved 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			 
82e6			storage_erase: 
82e6			 
82e6				; hl contains the file id 
82e6			 
82e6 5d				ld e, l 
82e7 16 00			ld d, 0 
82e9 21 40 00			ld hl, STORE_BLOCK_PHY 
82ec					if DEBUG_FORTH_WORDS 
82ec						DMARK "ERA" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 7a ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 7b ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 7c ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "ERA"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305						CALLMONITOR 
8305 cd 7b 91			call break_point_state  
8308				endm  
# End of macro CALLMONITOR
8308					endif 
8308 cd c7 83			call storage_findnextid 
830b			 
830b e5				push hl 
830c			 
830c				; TODO check file not found 
830c			 
830c 11 65 eb			ld de, store_page 
830f cd b1 80			call storage_read_block 
8312			 
8312					if DEBUG_FORTH_WORDS 
8312						DMARK "ER1" 
8312 f5				push af  
8313 3a 27 83			ld a, (.dmark)  
8316 32 7a ee			ld (debug_mark),a  
8319 3a 28 83			ld a, (.dmark+1)  
831c 32 7b ee			ld (debug_mark+1),a  
831f 3a 29 83			ld a, (.dmark+2)  
8322 32 7c ee			ld (debug_mark+2),a  
8325 18 03			jr .pastdmark  
8327 ..			.dmark: db "ER1"  
832a f1			.pastdmark: pop af  
832b			endm  
# End of macro DMARK
832b						CALLMONITOR 
832b cd 7b 91			call break_point_state  
832e				endm  
# End of macro CALLMONITOR
832e					endif 
832e 3a 65 eb			ld a, (store_page)	; get file id 
8331 32 5e eb			ld (store_tmpid), a 
8334			 
8334 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8337 32 5d eb			ld (store_tmpext), a 
833a			 
833a				; wipe file header 
833a			 
833a e1				pop hl 
833b 3e 00			ld a, 0 
833d 32 65 eb			ld (store_page), a 
8340 32 66 eb			ld (store_page+1),a 
8343 11 65 eb			ld de, store_page 
8346					if DEBUG_FORTH_WORDS 
8346						DMARK "ER2" 
8346 f5				push af  
8347 3a 5b 83			ld a, (.dmark)  
834a 32 7a ee			ld (debug_mark),a  
834d 3a 5c 83			ld a, (.dmark+1)  
8350 32 7b ee			ld (debug_mark+1),a  
8353 3a 5d 83			ld a, (.dmark+2)  
8356 32 7c ee			ld (debug_mark+2),a  
8359 18 03			jr .pastdmark  
835b ..			.dmark: db "ER2"  
835e f1			.pastdmark: pop af  
835f			endm  
# End of macro DMARK
835f						CALLMONITOR 
835f cd 7b 91			call break_point_state  
8362				endm  
# End of macro CALLMONITOR
8362					endif 
8362 cd 16 81			call storage_write_block 
8365			 
8365			 
8365				; wipe file extents 
8365			 
8365 3a 5d eb			ld a, (store_tmpext) 
8368 47				ld b, a 
8369			 
8369			.eraext:	  
8369 c5				push bc 
836a			 
836a 21 40 00			ld hl, STORE_BLOCK_PHY 
836d 3a 5e eb			ld a,(store_tmpid) 
8370 5f				ld e, a 
8371 50				ld d, b	 
8372					if DEBUG_FORTH_WORDS 
8372						DMARK "ER3" 
8372 f5				push af  
8373 3a 87 83			ld a, (.dmark)  
8376 32 7a ee			ld (debug_mark),a  
8379 3a 88 83			ld a, (.dmark+1)  
837c 32 7b ee			ld (debug_mark+1),a  
837f 3a 89 83			ld a, (.dmark+2)  
8382 32 7c ee			ld (debug_mark+2),a  
8385 18 03			jr .pastdmark  
8387 ..			.dmark: db "ER3"  
838a f1			.pastdmark: pop af  
838b			endm  
# End of macro DMARK
838b						CALLMONITOR 
838b cd 7b 91			call break_point_state  
838e				endm  
# End of macro CALLMONITOR
838e					endif 
838e cd c7 83			call storage_findnextid 
8391			 
8391 e5				push hl 
8392 11 65 eb			ld de, store_page 
8395 cd b1 80			call storage_read_block 
8398			 
8398				; free block	 
8398			 
8398 3e 00			ld a, 0 
839a 32 65 eb			ld (store_page), a 
839d 32 66 eb			ld (store_page+1),a 
83a0 11 65 eb			ld de, store_page 
83a3 e1				pop hl 
83a4					if DEBUG_FORTH_WORDS 
83a4						DMARK "ER4" 
83a4 f5				push af  
83a5 3a b9 83			ld a, (.dmark)  
83a8 32 7a ee			ld (debug_mark),a  
83ab 3a ba 83			ld a, (.dmark+1)  
83ae 32 7b ee			ld (debug_mark+1),a  
83b1 3a bb 83			ld a, (.dmark+2)  
83b4 32 7c ee			ld (debug_mark+2),a  
83b7 18 03			jr .pastdmark  
83b9 ..			.dmark: db "ER4"  
83bc f1			.pastdmark: pop af  
83bd			endm  
# End of macro DMARK
83bd						CALLMONITOR 
83bd cd 7b 91			call break_point_state  
83c0				endm  
# End of macro CALLMONITOR
83c0					endif 
83c0 cd 16 81			call storage_write_block 
83c3			 
83c3 c1				pop bc 
83c4 10 a3			djnz .eraext 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			; Find Free Block 
83c7			; --------------- 
83c7			; 
83c7			; With current bank 
83c7			;  
83c7			; From given starting logical block 
83c7			;    Read block  
83c7			;    If no file id 
83c7			;         Return block id 
83c7			 
83c7			 
83c7			; hl starting page number 
83c7			; hl contains free page number or zero if no pages free 
83c7			; e contains the file id to locate 
83c7			; d contains the block number 
83c7			 
83c7			; TODO change to find file id and use zero for free block 
83c7			 
83c7			storage_findnextid: 
83c7			 
83c7				; now locate first 0 page to mark as a free block 
83c7			 
83c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83c9			;	ld hl, STORE_BLOCK_PHY 
83c9			 
83c9					if DEBUG_FORTH_WORDS 
83c9					DMARK "FNI" 
83c9 f5				push af  
83ca 3a de 83			ld a, (.dmark)  
83cd 32 7a ee			ld (debug_mark),a  
83d0 3a df 83			ld a, (.dmark+1)  
83d3 32 7b ee			ld (debug_mark+1),a  
83d6 3a e0 83			ld a, (.dmark+2)  
83d9 32 7c ee			ld (debug_mark+2),a  
83dc 18 03			jr .pastdmark  
83de ..			.dmark: db "FNI"  
83e1 f1			.pastdmark: pop af  
83e2			endm  
# End of macro DMARK
83e2						CALLMONITOR 
83e2 cd 7b 91			call break_point_state  
83e5				endm  
# End of macro CALLMONITOR
83e5					endif 
83e5			.ff1:   	 
83e5 e5					push hl 
83e6 c5					push bc 
83e7 d5					push de 
83e8 cd ae 80				call se_readbyte 
83eb 5f					ld e,a 
83ec 23					inc hl 
83ed cd ae 80				call se_readbyte 
83f0 57					ld d, a 
83f1 e1					pop hl 
83f2 e5					push hl 
83f3 cd d5 89				call cmp16 
83f6 28 49				jr z, .fffound 
83f8			 
83f8 d1					pop de 
83f9 c1					pop bc 
83fa e1					pop hl 
83fb			 
83fb					; is found? 
83fb					;cp e 
83fb					;ret z 
83fb			 
83fb 3e 40				ld a, STORE_BLOCK_PHY 
83fd cd b7 89				call addatohl 
8400 10 e3				djnz .ff1 
8402			 
8402 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8404			.ff2:   	 
8404			 
8404 e5					push hl 
8405 c5					push bc 
8406 d5					push de 
8407 cd ae 80				call se_readbyte 
840a 5f					ld e,a 
840b 23					inc hl 
840c cd ae 80				call se_readbyte 
840f 57					ld d, a 
8410			 
8410 e1					pop hl 
8411 e5					push hl 
8412 cd d5 89				call cmp16 
8415 28 2a				jr z, .fffound 
8417			 
8417 d1					pop de 
8418 c1					pop bc 
8419 e1					pop hl 
841a					; is found? 
841a					;cp e 
841a					;ret z 
841a			 
841a 3e 40				ld a, STORE_BLOCK_PHY 
841c cd b7 89				call addatohl 
841f 10 e3				djnz .ff2 
8421			 
8421			 
8421					if DEBUG_FORTH_WORDS 
8421					DMARK "FN-" 
8421 f5				push af  
8422 3a 36 84			ld a, (.dmark)  
8425 32 7a ee			ld (debug_mark),a  
8428 3a 37 84			ld a, (.dmark+1)  
842b 32 7b ee			ld (debug_mark+1),a  
842e 3a 38 84			ld a, (.dmark+2)  
8431 32 7c ee			ld (debug_mark+2),a  
8434 18 03			jr .pastdmark  
8436 ..			.dmark: db "FN-"  
8439 f1			.pastdmark: pop af  
843a			endm  
# End of macro DMARK
843a					;	push af 
843a					;	ld a, 'n' 
843a					;	ld (debug_mark),a 
843a					;	pop af 
843a						CALLMONITOR 
843a cd 7b 91			call break_point_state  
843d				endm  
# End of macro CALLMONITOR
843d					endif 
843d				; no free marks! 
843d 21 00 00				ld hl, 0 
8440 c9				ret 
8441			.fffound: 
8441				 
8441			 
8441 d1					pop de 
8442 c1					pop bc 
8443 e1					pop hl 
8444					if DEBUG_FORTH_WORDS 
8444					DMARK "FNF" 
8444 f5				push af  
8445 3a 59 84			ld a, (.dmark)  
8448 32 7a ee			ld (debug_mark),a  
844b 3a 5a 84			ld a, (.dmark+1)  
844e 32 7b ee			ld (debug_mark+1),a  
8451 3a 5b 84			ld a, (.dmark+2)  
8454 32 7c ee			ld (debug_mark+2),a  
8457 18 03			jr .pastdmark  
8459 ..			.dmark: db "FNF"  
845c f1			.pastdmark: pop af  
845d			endm  
# End of macro DMARK
845d					;	push af 
845d					;	ld a, 'n' 
845d					;	ld (debug_mark),a 
845d					;	pop af 
845d						CALLMONITOR 
845d cd 7b 91			call break_point_state  
8460				endm  
# End of macro CALLMONITOR
8460					endif 
8460 c9				ret 
8461			 
8461			 
8461			 
8461			; Free Space 
8461			; ---------- 
8461			; 
8461			; With current bank 
8461			; 
8461			; Set block count to zero 
8461			; Starting with first logical block 
8461			;      Find free block  
8461			;      If block id given, increment block count 
8461			; 
8461			;  
8461			 
8461			 
8461			; hl contains count of free blocks 
8461			 
8461			storage_freeblocks: 
8461			 
8461				; now locate first 0 page to mark as a free block 
8461			 
8461 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8463 21 40 00			ld hl, STORE_BLOCK_PHY 
8466 11 00 00			ld de, 0 
8469			 
8469			.fb1:   	 
8469 e5					push hl 
846a c5					push bc 
846b d5					push de 
846c cd ae 80				call se_readbyte 
846f d1					pop de 
8470 c1					pop bc 
8471 e1					pop hl 
8472			 
8472					; is free? 
8472 fe 00				cp 0 
8474 20 01				jr nz, .ff1cont 
8476 13					inc de 
8477			 
8477			.ff1cont: 
8477			 
8477			 
8477 3e 40				ld a, STORE_BLOCK_PHY 
8479 cd b7 89				call addatohl 
847c 10 eb				djnz .fb1 
847e			 
847e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8480			.fb2:   	 
8480 e5					push hl 
8481 c5					push bc 
8482 d5					push de 
8483 cd ae 80				call se_readbyte 
8486 d1					pop de 
8487 c1					pop bc 
8488 e1					pop hl 
8489			 
8489					; is free? 
8489 fe 00				cp 0 
848b 20 01				jr nz, .ff2cont 
848d 13					inc de 
848e			 
848e			.ff2cont: 
848e			 
848e 3e 40				ld a, STORE_BLOCK_PHY 
8490 cd b7 89				call addatohl 
8493 10 eb				djnz .fb2 
8495			 
8495 eb				ex de, hl 
8496 c9				ret 
8497			 
8497			; Get File ID 
8497			; ----------- 
8497			; 
8497			; With current bank 
8497			;  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; For each logical block 
8497			;    Read block file id 
8497			;      If first block of file and dont have file id 
8497			;         if file get id and exit 
8497			 
8497			 
8497			 
8497			 
8497			; Create File 
8497			; ----------- 
8497			; 
8497			; With current bank  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; Increment file id number 
8497			; Save Config 
8497			; Find free block 
8497			; Set buffer with file name and file id 
8497			; Write buffer to free block  
8497			 
8497			 
8497			; hl point to file name 
8497			; hl returns file id 
8497			 
8497			; file format: 
8497			; byte 0 - file id 
8497			; byte 1 - extent number 
8497			; byte 2-> data 
8497			 
8497			; format for extent number 0: 
8497			; 
8497			; byte 0 - file id 
8497			; byte 1 - extent 0 
8497			; byte 2 - extent count 
8497			; byte 3 -> file name and meta data 
8497			 
8497			 
8497			storage_create: 
8497				if DEBUG_STORESE 
8497					DMARK "SCR" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 7a ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 7b ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 7c ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "SCR"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0					CALLMONITOR 
84b0 cd 7b 91			call break_point_state  
84b3				endm  
# End of macro CALLMONITOR
84b3				endif 
84b3			 
84b3 e5				push hl		; save file name pointer 
84b4			 
84b4 cd 62 81			call storage_get_block_0 
84b7			 
84b7 3a 65 eb			ld a,(store_page)	; get current file id 
84ba 3c				inc a 
84bb 32 65 eb			ld (store_page),a 
84be				 
84be 32 5e eb			ld (store_tmpid),a			; save id 
84c1			 
84c1 21 00 00			ld hl, 0 
84c4 11 65 eb			ld de, store_page 
84c7				if DEBUG_STORESE 
84c7					DMARK "SCw" 
84c7 f5				push af  
84c8 3a dc 84			ld a, (.dmark)  
84cb 32 7a ee			ld (debug_mark),a  
84ce 3a dd 84			ld a, (.dmark+1)  
84d1 32 7b ee			ld (debug_mark+1),a  
84d4 3a de 84			ld a, (.dmark+2)  
84d7 32 7c ee			ld (debug_mark+2),a  
84da 18 03			jr .pastdmark  
84dc ..			.dmark: db "SCw"  
84df f1			.pastdmark: pop af  
84e0			endm  
# End of macro DMARK
84e0					CALLMONITOR 
84e0 cd 7b 91			call break_point_state  
84e3				endm  
# End of macro CALLMONITOR
84e3				endif 
84e3 cd 16 81			call storage_write_block	 ; save update 
84e6			 
84e6				if DEBUG_STORESE 
84e6 11 65 eb				ld de, store_page 
84e9					DMARK "SCC" 
84e9 f5				push af  
84ea 3a fe 84			ld a, (.dmark)  
84ed 32 7a ee			ld (debug_mark),a  
84f0 3a ff 84			ld a, (.dmark+1)  
84f3 32 7b ee			ld (debug_mark+1),a  
84f6 3a 00 85			ld a, (.dmark+2)  
84f9 32 7c ee			ld (debug_mark+2),a  
84fc 18 03			jr .pastdmark  
84fe ..			.dmark: db "SCC"  
8501 f1			.pastdmark: pop af  
8502			endm  
# End of macro DMARK
8502					CALLMONITOR 
8502 cd 7b 91			call break_point_state  
8505				endm  
# End of macro CALLMONITOR
8505				endif 
8505				;  
8505				 
8505 21 40 00			ld hl, STORE_BLOCK_PHY 
8508 11 00 00			ld de, 0 
850b cd c7 83			call storage_findnextid 
850e			 
850e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
8511			 
8511				; TODO detect 0 = no spare blocks 
8511			 
8511				; hl now contains the free page to use for the file header page 
8511			 
8511				if DEBUG_STORESE 
8511				DMARK "SCF" 
8511 f5				push af  
8512 3a 26 85			ld a, (.dmark)  
8515 32 7a ee			ld (debug_mark),a  
8518 3a 27 85			ld a, (.dmark+1)  
851b 32 7b ee			ld (debug_mark+1),a  
851e 3a 28 85			ld a, (.dmark+2)  
8521 32 7c ee			ld (debug_mark+2),a  
8524 18 03			jr .pastdmark  
8526 ..			.dmark: db "SCF"  
8529 f1			.pastdmark: pop af  
852a			endm  
# End of macro DMARK
852a					CALLMONITOR 
852a cd 7b 91			call break_point_state  
852d				endm  
# End of macro CALLMONITOR
852d				endif 
852d			 
852d 22 63 eb			ld (store_tmppageid), hl 
8530				 
8530 3a 5e eb			ld a,(store_tmpid)    ; get file id 
8533			;	ld a, (store_filecache)			; save to cache 
8533			 
8533 32 65 eb			ld (store_page),a    ; set page id 
8536 3e 00			ld a, 0			 ; extent 0 is file header 
8538 32 66 eb			ld (store_page+1), a   ; set file extent 
853b			 
853b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
853e			 
853e			;	inc hl 		; init block 0 of file 
853e			;	inc hl   		; skip file and extent id 
853e			 ;       ld a, 0 
853e			;	ld (hl),a 
853e			;	ld a, (store_filecache+1)  	; save to cache 
853e			 
853e			;	inc hl    ; file name 
853e				 
853e				 
853e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8541				if DEBUG_STORESE 
8541					DMARK "SCc" 
8541 f5				push af  
8542 3a 56 85			ld a, (.dmark)  
8545 32 7a ee			ld (debug_mark),a  
8548 3a 57 85			ld a, (.dmark+1)  
854b 32 7b ee			ld (debug_mark+1),a  
854e 3a 58 85			ld a, (.dmark+2)  
8551 32 7c ee			ld (debug_mark+2),a  
8554 18 03			jr .pastdmark  
8556 ..			.dmark: db "SCc"  
8559 f1			.pastdmark: pop af  
855a			endm  
# End of macro DMARK
855a					CALLMONITOR 
855a cd 7b 91			call break_point_state  
855d				endm  
# End of macro CALLMONITOR
855d				endif 
855d e1				pop hl    ; get zero term string 
855e e5				push hl 
855f 3e 00			ld a, 0 
8561 cd 20 8e			call strlent 
8564 23				inc hl   ; cover zero term 
8565 06 00			ld b,0 
8567 4d				ld c,l 
8568 e1				pop hl 
8569				;ex de, hl 
8569				if DEBUG_STORESE 
8569					DMARK "SCa" 
8569 f5				push af  
856a 3a 7e 85			ld a, (.dmark)  
856d 32 7a ee			ld (debug_mark),a  
8570 3a 7f 85			ld a, (.dmark+1)  
8573 32 7b ee			ld (debug_mark+1),a  
8576 3a 80 85			ld a, (.dmark+2)  
8579 32 7c ee			ld (debug_mark+2),a  
857c 18 03			jr .pastdmark  
857e ..			.dmark: db "SCa"  
8581 f1			.pastdmark: pop af  
8582			endm  
# End of macro DMARK
8582					;push af 
8582					;ld a, 'a' 
8582					;ld (debug_mark),a 
8582					;pop af 
8582					CALLMONITOR 
8582 cd 7b 91			call break_point_state  
8585				endm  
# End of macro CALLMONITOR
8585				endif 
8585 ed b0			ldir    ; copy zero term string 
8587				if DEBUG_STORESE 
8587					DMARK "SCA" 
8587 f5				push af  
8588 3a 9c 85			ld a, (.dmark)  
858b 32 7a ee			ld (debug_mark),a  
858e 3a 9d 85			ld a, (.dmark+1)  
8591 32 7b ee			ld (debug_mark+1),a  
8594 3a 9e 85			ld a, (.dmark+2)  
8597 32 7c ee			ld (debug_mark+2),a  
859a 18 03			jr .pastdmark  
859c ..			.dmark: db "SCA"  
859f f1			.pastdmark: pop af  
85a0			endm  
# End of macro DMARK
85a0					CALLMONITOR 
85a0 cd 7b 91			call break_point_state  
85a3				endm  
# End of macro CALLMONITOR
85a3				endif 
85a3			 
85a3				; write file header page 
85a3			 
85a3 2a 63 eb			ld hl,(store_tmppageid) 
85a6 11 65 eb			ld de, store_page 
85a9				if DEBUG_STORESE 
85a9					DMARK "SCb" 
85a9 f5				push af  
85aa 3a be 85			ld a, (.dmark)  
85ad 32 7a ee			ld (debug_mark),a  
85b0 3a bf 85			ld a, (.dmark+1)  
85b3 32 7b ee			ld (debug_mark+1),a  
85b6 3a c0 85			ld a, (.dmark+2)  
85b9 32 7c ee			ld (debug_mark+2),a  
85bc 18 03			jr .pastdmark  
85be ..			.dmark: db "SCb"  
85c1 f1			.pastdmark: pop af  
85c2			endm  
# End of macro DMARK
85c2					;push af 
85c2					;ld a, 'b' 
85c2					;ld (debug_mark),a 
85c2					;pop af 
85c2					CALLMONITOR 
85c2 cd 7b 91			call break_point_state  
85c5				endm  
# End of macro CALLMONITOR
85c5				endif 
85c5 cd 16 81			call storage_write_block 
85c8			 
85c8 3a 5e eb			ld a, (store_tmpid) 
85cb 6f				ld l, a 
85cc 26 00			ld h,0 
85ce				if DEBUG_STORESE 
85ce					DMARK "SCz" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 7a ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 7b ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 7c ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCz"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 7b 91			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea c9				ret 
85eb				 
85eb			 
85eb			 
85eb			; 
85eb			; Read File 
85eb			; 
85eb			; h - file id to locate 
85eb			; l - extent to locate 
85eb			; de - pointer to string to read into 
85eb			; 
85eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85eb			storage_read: 
85eb d5				push de 
85ec			 
85ec			; TODO BUG the above push is it popped before the RET Z? 
85ec			 
85ec			; TODO how to handle multiple part blocks 
85ec			 
85ec				; locate file extent to read 
85ec			 
85ec 5c				ld e, h 
85ed 55				ld d, l 
85ee 21 40 00			ld hl, STORE_BLOCK_PHY 
85f1				if DEBUG_STORESE 
85f1					DMARK "SRE" 
85f1 f5				push af  
85f2 3a 06 86			ld a, (.dmark)  
85f5 32 7a ee			ld (debug_mark),a  
85f8 3a 07 86			ld a, (.dmark+1)  
85fb 32 7b ee			ld (debug_mark+1),a  
85fe 3a 08 86			ld a, (.dmark+2)  
8601 32 7c ee			ld (debug_mark+2),a  
8604 18 03			jr .pastdmark  
8606 ..			.dmark: db "SRE"  
8609 f1			.pastdmark: pop af  
860a			endm  
# End of macro DMARK
860a					CALLMONITOR 
860a cd 7b 91			call break_point_state  
860d				endm  
# End of macro CALLMONITOR
860d				endif 
860d cd c7 83			call storage_findnextid 
8610			 
8610				if DEBUG_STORESE 
8610					DMARK "SRf" 
8610 f5				push af  
8611 3a 25 86			ld a, (.dmark)  
8614 32 7a ee			ld (debug_mark),a  
8617 3a 26 86			ld a, (.dmark+1)  
861a 32 7b ee			ld (debug_mark+1),a  
861d 3a 27 86			ld a, (.dmark+2)  
8620 32 7c ee			ld (debug_mark+2),a  
8623 18 03			jr .pastdmark  
8625 ..			.dmark: db "SRf"  
8628 f1			.pastdmark: pop af  
8629			endm  
# End of macro DMARK
8629					CALLMONITOR 
8629 cd 7b 91			call break_point_state  
862c				endm  
# End of macro CALLMONITOR
862c				endif 
862c cd e0 89			call ishlzero 
862f			;	ld a, l 
862f			;	add h 
862f			;	cp 0 
862f c8				ret z			; block not found so EOF 
8630			 
8630				; hl contains page number to load 
8630 d1				pop de   ; get storage 
8631 d5				push de 
8632				if DEBUG_STORESE 
8632					DMARK "SRg" 
8632 f5				push af  
8633 3a 47 86			ld a, (.dmark)  
8636 32 7a ee			ld (debug_mark),a  
8639 3a 48 86			ld a, (.dmark+1)  
863c 32 7b ee			ld (debug_mark+1),a  
863f 3a 49 86			ld a, (.dmark+2)  
8642 32 7c ee			ld (debug_mark+2),a  
8645 18 03			jr .pastdmark  
8647 ..			.dmark: db "SRg"  
864a f1			.pastdmark: pop af  
864b			endm  
# End of macro DMARK
864b					CALLMONITOR 
864b cd 7b 91			call break_point_state  
864e				endm  
# End of macro CALLMONITOR
864e				endif 
864e cd b1 80			call storage_read_block 
8651			 
8651			 
8651			; TODO if block has no zeros then need to read next block  
8651			 
8651			 
8651					 
8651 e1				pop hl 		 ; return start of data to show as not EOF 
8652 23				inc hl   ; past file id 
8653 23				inc hl   ; past ext 
8654				if DEBUG_STORESE 
8654					DMARK "SRe" 
8654 f5				push af  
8655 3a 69 86			ld a, (.dmark)  
8658 32 7a ee			ld (debug_mark),a  
865b 3a 6a 86			ld a, (.dmark+1)  
865e 32 7b ee			ld (debug_mark+1),a  
8661 3a 6b 86			ld a, (.dmark+2)  
8664 32 7c ee			ld (debug_mark+2),a  
8667 18 03			jr .pastdmark  
8669 ..			.dmark: db "SRe"  
866c f1			.pastdmark: pop af  
866d			endm  
# End of macro DMARK
866d					CALLMONITOR 
866d cd 7b 91			call break_point_state  
8670				endm  
# End of macro CALLMONITOR
8670				endif 
8670 c9					ret 
8671			 
8671			 
8671			 
8671			; 
8671			; Append File 
8671			; 
8671			; hl - file id to locate 
8671			; de - pointer to (multi block) string to write 
8671			 
8671			 
8671			storage_append: 
8671				; hl -  file id to append to 
8671				; de - string to append 
8671			 
8671 d5				push de 
8672				 
8672				if DEBUG_STORESE 
8672					DMARK "AP1" 
8672 f5				push af  
8673 3a 87 86			ld a, (.dmark)  
8676 32 7a ee			ld (debug_mark),a  
8679 3a 88 86			ld a, (.dmark+1)  
867c 32 7b ee			ld (debug_mark+1),a  
867f 3a 89 86			ld a, (.dmark+2)  
8682 32 7c ee			ld (debug_mark+2),a  
8685 18 03			jr .pastdmark  
8687 ..			.dmark: db "AP1"  
868a f1			.pastdmark: pop af  
868b			endm  
# End of macro DMARK
868b					CALLMONITOR 
868b cd 7b 91			call break_point_state  
868e				endm  
# End of macro CALLMONITOR
868e				endif 
868e			 
868e 7d				ld a, l 
868f 32 5e eb			ld (store_tmpid), a 
8692			 
8692				; get file header  
8692			 
8692 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8694 3a 5e eb			ld a, (store_tmpid) 
8697 5f				ld e, a 
8698			 
8698 21 40 00				ld hl, STORE_BLOCK_PHY 
869b cd c7 83				call storage_findnextid 
869e			 
869e 22 63 eb			ld (store_tmppageid), hl 
86a1			 
86a1				; TODO handle file id not found 
86a1			 
86a1				if DEBUG_STORESE 
86a1					DMARK "AP2" 
86a1 f5				push af  
86a2 3a b6 86			ld a, (.dmark)  
86a5 32 7a ee			ld (debug_mark),a  
86a8 3a b7 86			ld a, (.dmark+1)  
86ab 32 7b ee			ld (debug_mark+1),a  
86ae 3a b8 86			ld a, (.dmark+2)  
86b1 32 7c ee			ld (debug_mark+2),a  
86b4 18 03			jr .pastdmark  
86b6 ..			.dmark: db "AP2"  
86b9 f1			.pastdmark: pop af  
86ba			endm  
# End of macro DMARK
86ba					CALLMONITOR 
86ba cd 7b 91			call break_point_state  
86bd				endm  
# End of macro CALLMONITOR
86bd				endif 
86bd			 
86bd				; update file extent count 
86bd			 
86bd 11 65 eb			ld de, store_page 
86c0			 
86c0 cd b1 80			call storage_read_block 
86c3			 
86c3				if DEBUG_STORESE 
86c3					DMARK "AP3" 
86c3 f5				push af  
86c4 3a d8 86			ld a, (.dmark)  
86c7 32 7a ee			ld (debug_mark),a  
86ca 3a d9 86			ld a, (.dmark+1)  
86cd 32 7b ee			ld (debug_mark+1),a  
86d0 3a da 86			ld a, (.dmark+2)  
86d3 32 7c ee			ld (debug_mark+2),a  
86d6 18 03			jr .pastdmark  
86d8 ..			.dmark: db "AP3"  
86db f1			.pastdmark: pop af  
86dc			endm  
# End of macro DMARK
86dc					CALLMONITOR 
86dc cd 7b 91			call break_point_state  
86df				endm  
# End of macro CALLMONITOR
86df				endif 
86df			;	ld (store_tmppageid), hl 
86df			 
86df 3a 67 eb			ld a, (store_page+2) 
86e2 3c				inc a 
86e3 32 67 eb			ld (store_page+2), a 
86e6 32 5d eb			ld (store_tmpext), a 
86e9				 
86e9				if DEBUG_STORESE 
86e9					DMARK "AP3" 
86e9 f5				push af  
86ea 3a fe 86			ld a, (.dmark)  
86ed 32 7a ee			ld (debug_mark),a  
86f0 3a ff 86			ld a, (.dmark+1)  
86f3 32 7b ee			ld (debug_mark+1),a  
86f6 3a 00 87			ld a, (.dmark+2)  
86f9 32 7c ee			ld (debug_mark+2),a  
86fc 18 03			jr .pastdmark  
86fe ..			.dmark: db "AP3"  
8701 f1			.pastdmark: pop af  
8702			endm  
# End of macro DMARK
8702					CALLMONITOR 
8702 cd 7b 91			call break_point_state  
8705				endm  
# End of macro CALLMONITOR
8705				endif 
8705 2a 63 eb			ld hl, (store_tmppageid) 
8708 11 65 eb			ld de, store_page 
870b cd 16 81			call storage_write_block 
870e			 
870e				; find free block 
870e			 
870e 11 00 00			ld de, 0			 ; file extent to locate 
8711			 
8711 21 40 00				ld hl, STORE_BLOCK_PHY 
8714 cd c7 83				call storage_findnextid 
8717			 
8717					; TODO handle no space left 
8717					 
8717 22 63 eb				ld (store_tmppageid), hl 
871a			 
871a				if DEBUG_STORESE 
871a					DMARK "AP4" 
871a f5				push af  
871b 3a 2f 87			ld a, (.dmark)  
871e 32 7a ee			ld (debug_mark),a  
8721 3a 30 87			ld a, (.dmark+1)  
8724 32 7b ee			ld (debug_mark+1),a  
8727 3a 31 87			ld a, (.dmark+2)  
872a 32 7c ee			ld (debug_mark+2),a  
872d 18 03			jr .pastdmark  
872f ..			.dmark: db "AP4"  
8732 f1			.pastdmark: pop af  
8733			endm  
# End of macro DMARK
8733					CALLMONITOR 
8733 cd 7b 91			call break_point_state  
8736				endm  
# End of macro CALLMONITOR
8736				endif 
8736					; init the buffer with zeros so we can id if the buffer is full or not 
8736			 
8736 e5					push hl 
8737 c5					push bc 
8738			 
8738 21 65 eb				ld hl, store_page 
873b 06 40				ld b, STORE_BLOCK_PHY 
873d 3e 00				ld a, 0 
873f 77			.zeroblock:	ld (hl), a 
8740 23					inc hl 
8741 10 fc				djnz .zeroblock 
8743			 
8743 c1					pop bc 
8744 e1					pop hl 
8745			 
8745					; construct block 
8745			 
8745 3a 5e eb				ld a, (store_tmpid) 
8748 32 65 eb				ld (store_page), a   ; file id 
874b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
874e 32 66 eb				ld (store_page+1), a 
8751			 
8751 e1					pop hl    ; get string to write 
8752 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8754 11 67 eb				ld de, store_page+2 
8757			 
8757				if DEBUG_STORESE 
8757					DMARK "AP5" 
8757 f5				push af  
8758 3a 6c 87			ld a, (.dmark)  
875b 32 7a ee			ld (debug_mark),a  
875e 3a 6d 87			ld a, (.dmark+1)  
8761 32 7b ee			ld (debug_mark+1),a  
8764 3a 6e 87			ld a, (.dmark+2)  
8767 32 7c ee			ld (debug_mark+2),a  
876a 18 03			jr .pastdmark  
876c ..			.dmark: db "AP5"  
876f f1			.pastdmark: pop af  
8770			endm  
# End of macro DMARK
8770					CALLMONITOR 
8770 cd 7b 91			call break_point_state  
8773				endm  
# End of macro CALLMONITOR
8773				endif 
8773			 
8773			 
8773			 
8773					; fill buffer with data until end of string or full block 
8773			 
8773 7e			.appd:		ld a, (hl) 
8774 12					ld (de), a 
8775 fe 00				cp 0 
8777 28 04				jr z, .appdone 
8779 23					inc hl 
877a 13					inc de 
877b 10 f6				djnz .appd 
877d			 
877d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
877e f5					push af   		; save last byte dumped 
877f			 
877f			 
877f 2a 63 eb			ld hl, (store_tmppageid) 
8782 11 65 eb			ld de, store_page 
8785				if DEBUG_STORESE 
8785					DMARK "AP6" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 7a ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 7b ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 7c ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "AP6"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 7b 91			call break_point_state  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 cd 16 81				call storage_write_block 
87a4			 
87a4			 
87a4				; was that a full block of data written? 
87a4				; any more to write out? 
87a4			 
87a4				; if yes then set vars and jump to start of function again 
87a4			 
87a4 f1					pop af 
87a5 d1					pop de 
87a6			 
87a6 fe 00				cp 0		 ; no, string was fully written 
87a8 c8					ret z 
87a9			 
87a9					; setup vars for next cycle 
87a9			 
87a9 3a 5e eb				ld a, (store_tmpid) 
87ac 6f					ld l, a 
87ad 26 00				ld h, 0 
87af			 
87af c3 71 86			 	jp storage_append	 ; yes, need to write out some more 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			if DEBUG_STORECF 
87b2			storageput:	 
87b2					ret 
87b2			storageread: 
87b2					ld hl, store_page 
87b2					ld b, 200 
87b2					ld a,0 
87b2			.src:		ld (hl),a 
87b2					inc hl 
87b2					djnz .src 
87b2					 
87b2			 
87b2					ld de, 0 
87b2					ld bc, 1 
87b2					ld hl, store_page 
87b2					call cfRead 
87b2			 
87b2				call cfGetError 
87b2				ld hl,scratch 
87b2				call hexout 
87b2				ld hl, scratch+2 
87b2				ld a, 0 
87b2				ld (hl),a 
87b2				ld de, scratch 
87b2				ld a,display_row_1 
87b2				call str_at_display 
87b2				call update_display 
87b2			 
87b2					ld hl, store_page 
87b2					ld (os_cur_ptr),hl 
87b2			 
87b2					ret 
87b2			endif 
87b2			 
87b2			 
87b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
87b2			 
87b2			storage_clear_page: 
87b2 e5				push hl 
87b3 d5				push de 
87b4 c5				push bc 
87b5 21 65 eb			ld hl, store_page 
87b8 3e 00			ld a, 0 
87ba 77				ld (hl), a 
87bb			 
87bb 11 66 eb			ld de, store_page+1 
87be 01 40 00			ld bc, STORE_BLOCK_PHY 
87c1			 
87c1 ed b0			ldir 
87c3				 
87c3 c1				pop bc 
87c4 d1				pop de 
87c5 e1				pop hl 
87c6 c9				ret 
87c7			 
87c7			; eof 
# End of file firmware_storage.asm
87c7			  
87c7			; support routines for above hardware abstraction layer  
87c7			  
87c7			include "firmware_general.asm"        ; general support functions  
87c7			 
87c7			 
87c7			 
87c7			; Delay loops 
87c7			 
87c7			 
87c7			 
87c7			aDelayInMS: 
87c7 c5				push bc 
87c8 47				ld b,a 
87c9			msdelay: 
87c9 c5				push bc 
87ca				 
87ca			 
87ca 01 41 00			ld bc,041h 
87cd cd e5 87			call delayloop 
87d0 c1				pop bc 
87d1 05				dec b 
87d2 20 f5			jr nz,msdelay 
87d4			 
87d4			;if CPU_CLOCK_8MHZ 
87d4			;msdelay8: 
87d4			;	push bc 
87d4			;	 
87d4			; 
87d4			;	ld bc,041h 
87d4			;	call delayloop 
87d4			;	pop bc 
87d4			;	dec b 
87d4			;	jr nz,msdelay8 
87d4			;endif 
87d4			 
87d4			 
87d4 c1				pop bc 
87d5 c9				ret 
87d6			 
87d6			 
87d6			delay250ms: 
87d6				;push de 
87d6 01 00 40			ld bc, 04000h 
87d9 c3 e5 87			jp delayloop 
87dc			delay500ms: 
87dc				;push de 
87dc 01 00 80			ld bc, 08000h 
87df c3 e5 87			jp delayloop 
87e2			delay1s: 
87e2				;push bc 
87e2			   ; Clobbers A, d and e 
87e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87e5			delayloop: 
87e5 c5			    push bc 
87e6			 
87e6			if BASE_CPM 
87e6				ld bc, CPM_DELAY_TUNE 
87e6			.cpmloop: 
87e6				push bc 
87e6			 
87e6			endif 
87e6			 
87e6			 
87e6			 
87e6			delayloopi: 
87e6			;	push bc 
87e6			;.dl: 
87e6 cb 47		    bit     0,a    	; 8 
87e8 cb 47		    bit     0,a    	; 8 
87ea cb 47		    bit     0,a    	; 8 
87ec e6 ff		    and     255  	; 7 
87ee 0b			    dec     bc      	; 6 
87ef 79			    ld      a,c     	; 4 
87f0 b0			    or      b     	; 4 
87f1 c2 e6 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
87f4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
87f4				;pop de 
87f4			;pop bc 
87f4			 
87f4			if BASE_CPM 
87f4				pop bc 
87f4				 
87f4			    dec     bc      	; 6 
87f4			    ld      a,c     	; 4 
87f4			    or      b     	; 4 
87f4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
87f4				 
87f4			 
87f4			endif 
87f4			;if CPU_CLOCK_8MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4			 
87f4			;if CPU_CLOCK_10MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4 c1			    pop bc 
87f5			 
87f5 c9				ret 
87f6			 
87f6			 
87f6			 
87f6			; eof 
# End of file firmware_general.asm
87f6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
87f6			; display routines that use the physical hardware abstraction layer 
87f6			 
87f6			 
87f6			; TODO windowing? 
87f6			 
87f6			; TODO scroll line up 
87f6			 
87f6			scroll_up: 
87f6			 
87f6 e5				push hl 
87f7 d5				push de 
87f8 c5				push bc 
87f9			 
87f9				; get frame buffer  
87f9			 
87f9 2a db eb			ld hl, (display_fb_active) 
87fc e5				push hl    ; future de destination 
87fd			 
87fd 11 28 00			ld  de, display_cols 
8800 19				add hl, de 
8801			 
8801 d1				pop de 
8802			 
8802				;ex de, hl 
8802 01 9f 00			ld bc, display_fb_len -1  
8805			;if DEBUG_FORTH_WORDS 
8805			;	DMARK "SCL" 
8805			;	CALLMONITOR 
8805			;endif	 
8805 ed b0			ldir 
8807			 
8807				; wipe bottom row 
8807			 
8807			 
8807 2a db eb			ld hl, (display_fb_active) 
880a 11 a0 00			ld de, display_cols*display_rows 
880d 19				add hl, de 
880e 06 28			ld b, display_cols 
8810 3e 20			ld a, ' ' 
8812			.scwipe: 
8812 77				ld (hl), a 
8813 2b				dec hl 
8814 10 fc			djnz .scwipe 
8816			 
8816				;pop hl 
8816			 
8816 c1				pop bc 
8817 d1				pop de 
8818 e1				pop hl 
8819			 
8819 c9				ret 
881a			 
881a			 
881a			scroll_upo: 
881a 11 00 00			ld de, display_row_1 
881d 21 28 00		 	ld hl, display_row_2 
8820 01 28 00			ld bc, display_cols 
8823 ed b0			ldir 
8825 11 28 00			ld de, display_row_2 
8828 21 50 00		 	ld hl, display_row_3 
882b 01 28 00			ld bc, display_cols 
882e ed b0			ldir 
8830 11 50 00			ld de, display_row_3 
8833 21 78 00		 	ld hl, display_row_4 
8836 01 28 00			ld bc, display_cols 
8839 ed b0			ldir 
883b			 
883b			; TODO clear row 4 
883b			 
883b c9				ret 
883c				 
883c			scroll_down: 
883c 11 78 00			ld de, display_row_4 
883f 21 50 00		 	ld hl, display_row_3 
8842 01 28 00			ld bc, display_cols 
8845 ed b0			ldir 
8847 11 50 00			ld de, display_row_3 
884a 21 28 00		 	ld hl, display_row_2 
884d 01 28 00			ld bc, display_cols 
8850 ed b0			ldir 
8852 11 28 00			ld de, display_row_2 
8855 21 00 00		 	ld hl, display_row_1 
8858 01 28 00			ld bc, display_cols 
885b ed b0			ldir 
885d			; TODO clear row 1 
885d c9				ret 
885e			 
885e			 
885e			 
885e			 
885e			 
885e			; clear active frame buffer 
885e			 
885e			clear_display: 
885e 3e 20			ld a, ' ' 
8860 c3 63 88			jp fill_display 
8863			 
8863			; fill active frame buffer with a char in A 
8863			 
8863			fill_display: 
8863 06 a0			ld b,display_fb_len 
8865 2a db eb			ld hl, (display_fb_active) 
8868 77			.fd1:	ld (hl),a 
8869 23				inc hl 
886a 10 fc			djnz .fd1 
886c 23				inc hl 
886d 3e 00			ld a,0 
886f 77				ld (hl),a 
8870			 
8870			 
8870 c9				ret 
8871			; Write string (DE) at pos (A) to active frame buffer 
8871			 
8871 2a db eb		str_at_display:    ld hl,(display_fb_active) 
8874 06 00					ld b,0 
8876 4f					ld c,a 
8877 09					add hl,bc 
8878 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8879 b7			            OR   A              ;Null terminator? 
887a c8			            RET  Z              ;Yes, so finished 
887b 77					ld (hl),a 
887c 23				inc hl 
887d 13			            INC  DE             ;Point to next character 
887e 18 f8		            JR   .sad1     ;Repeat 
8880 c9					ret 
8881			 
8881			; using current frame buffer write to physical display 
8881			 
8881			update_display: 
8881 e5				push hl 
8882 2a db eb			ld hl, (display_fb_active) 
8885 cd 06 d4			call write_display 
8888 e1				pop hl 
8889 c9				ret 
888a			 
888a			; TODO scrolling 
888a			 
888a			 
888a			; move cursor right one char 
888a			cursor_right: 
888a			 
888a				; TODO shift right 
888a				; TODO if beyond max col 
888a				; TODO       cursor_next_line 
888a			 
888a c9				ret 
888b			 
888b			 
888b			cursor_next_line: 
888b				; TODO first char 
888b				; TODO line down 
888b				; TODO if past last row 
888b				; TODO    scroll up 
888b			 
888b c9				ret 
888c			 
888c			cursor_left: 
888c				; TODO shift left 
888c				; TODO if beyond left  
888c				; TODO     cursor prev line 
888c				 
888c c9				ret 
888d			 
888d			cursor_prev_line: 
888d				; TODO last char 
888d				; TODO line up 
888d				; TODO if past first row 
888d				; TODO   scroll down 
888d			 
888d c9				ret 
888e			 
888e			 
888e			cout: 
888e				; A - char 
888e c9				ret 
888f			 
888f			; eof 
888f			 
# End of file firmware_display.asm
888f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
888f			; random number generators 
888f			 
888f			 
888f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
888f			 
888f			 
888f			;-----> Generate a random number 
888f			; output a=answer 0<=a<=255 
888f			; all registers are preserved except: af 
888f			random: 
888f e5			        push    hl 
8890 d5			        push    de 
8891 2a bd eb		        ld      hl,(randData) 
8894 ed 5f		        ld      a,r 
8896 57			        ld      d,a 
8897 5e			        ld      e,(hl) 
8898 19			        add     hl,de 
8899 85			        add     a,l 
889a ac			        xor     h 
889b 22 bd eb		        ld      (randData),hl 
889e d1			        pop     de 
889f e1			        pop     hl 
88a0 c9			        ret 
88a1			 
88a1			 
88a1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
88a1			 
88a1			 
88a1			 
88a1			;------LFSR------ 
88a1			;James Montelongo 
88a1			;optimized by Spencer Putt 
88a1			;out: 
88a1			; a = 8 bit random number 
88a1			RandLFSR: 
88a1 21 c3 eb		        ld hl,LFSRSeed+4 
88a4 5e			        ld e,(hl) 
88a5 23			        inc hl 
88a6 56			        ld d,(hl) 
88a7 23			        inc hl 
88a8 4e			        ld c,(hl) 
88a9 23			        inc hl 
88aa 7e			        ld a,(hl) 
88ab 47			        ld b,a 
88ac cb 13		        rl e  
88ae cb 12			rl d 
88b0 cb 11		        rl c  
88b2 17				rla 
88b3 cb 13		        rl e  
88b5 cb 12			rl d 
88b7 cb 11		        rl c  
88b9 17				rla 
88ba cb 13		        rl e  
88bc cb 12			rl d 
88be cb 11		        rl c  
88c0 17				rla 
88c1 67			        ld h,a 
88c2 cb 13		        rl e  
88c4 cb 12			rl d 
88c6 cb 11		        rl c  
88c8 17				rla 
88c9 a8			        xor b 
88ca cb 13		        rl e  
88cc cb 12			rl d 
88ce ac			        xor h 
88cf a9			        xor c 
88d0 aa			        xor d 
88d1 21 c5 eb		        ld hl,LFSRSeed+6 
88d4 11 c6 eb		        ld de,LFSRSeed+7 
88d7 01 07 00		        ld bc,7 
88da ed b8		        lddr 
88dc 12			        ld (de),a 
88dd c9			        ret 
88de			 
88de			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
88de			 
88de			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
88de			 
88de			 
88de			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
88de			 
88de			prng16: 
88de			;Inputs: 
88de			;   (seed1) contains a 16-bit seed value 
88de			;   (seed2) contains a NON-ZERO 16-bit seed value 
88de			;Outputs: 
88de			;   HL is the result 
88de			;   BC is the result of the LCG, so not that great of quality 
88de			;   DE is preserved 
88de			;Destroys: 
88de			;   AF 
88de			;cycle: 4,294,901,760 (almost 4.3 billion) 
88de			;160cc 
88de			;26 bytes 
88de 2a b7 eb		    ld hl,(seed1) 
88e1 44			    ld b,h 
88e2 4d			    ld c,l 
88e3 29			    add hl,hl 
88e4 29			    add hl,hl 
88e5 2c			    inc l 
88e6 09			    add hl,bc 
88e7 22 b7 eb		    ld (seed1),hl 
88ea 2a b5 eb		    ld hl,(seed2) 
88ed 29			    add hl,hl 
88ee 9f			    sbc a,a 
88ef e6 2d		    and %00101101 
88f1 ad			    xor l 
88f2 6f			    ld l,a 
88f3 22 b5 eb		    ld (seed2),hl 
88f6 09			    add hl,bc 
88f7 c9			    ret 
88f8			 
88f8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
88f8			 
88f8			rand32: 
88f8			;Inputs: 
88f8			;   (seed1_0) holds the lower 16 bits of the first seed 
88f8			;   (seed1_1) holds the upper 16 bits of the first seed 
88f8			;   (seed2_0) holds the lower 16 bits of the second seed 
88f8			;   (seed2_1) holds the upper 16 bits of the second seed 
88f8			;   **NOTE: seed2 must be non-zero 
88f8			;Outputs: 
88f8			;   HL is the result 
88f8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
88f8			;Destroys: 
88f8			;   AF 
88f8			;Tested and passes all CAcert tests 
88f8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
88f8			;it has a period of 18,446,744,069,414,584,320 
88f8			;roughly 18.4 quintillion. 
88f8			;LFSR taps: 0,2,6,7  = 11000101 
88f8			;291cc 
88f8			;seed1_0=$+1 
88f8			;    ld hl,12345 
88f8			;seed1_1=$+1 
88f8			;    ld de,6789 
88f8			;    ld b,h 
88f8			;    ld c,l 
88f8			;    add hl,hl \ rl e \ rl d 
88f8			;    add hl,hl \ rl e \ rl d 
88f8			;    inc l 
88f8			;    add hl,bc 
88f8			;    ld (seed1_0),hl 
88f8			;    ld hl,(seed1_1) 
88f8			;    adc hl,de 
88f8			;    ld (seed1_1),hl 
88f8			;    ex de,hl 
88f8			;seed2_0=$+1 
88f8			;    ld hl,9876 
88f8			;seed2_1=$+1 
88f8			;    ld bc,54321 
88f8			;    add hl,hl \ rl c \ rl b 
88f8			;    ld (seed2_1),bc 
88f8			;    sbc a,a 
88f8			;    and %11000101 
88f8			;    xor l 
88f8			;    ld l,a 
88f8			;    ld (seed2_0),hl 
88f8			;    ex de,hl 
88f8			;    add hl,bc 
88f8			;    ret 
88f8			; 
88f8			 
88f8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
88f8			; 20 bytes, 86 cycles (excluding ret) 
88f8			 
88f8			; returns   hl = pseudorandom number 
88f8			; corrupts   a 
88f8			 
88f8			; generates 16-bit pseudorandom numbers with a period of 65535 
88f8			; using the xorshift method: 
88f8			 
88f8			; hl ^= hl << 7 
88f8			; hl ^= hl >> 9 
88f8			; hl ^= hl << 8 
88f8			 
88f8			; some alternative shift triplets which also perform well are: 
88f8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
88f8			 
88f8			;  org 32768 
88f8			 
88f8			xrnd: 
88f8 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
88fb 3e 00		  ld a,0 
88fd bd			  cp l 
88fe 20 02		  jr nz, .xrnd1 
8900 2e 01		  ld l, 1 
8902			.xrnd1: 
8902			 
8902 7c			  ld a,h 
8903 1f			  rra 
8904 7d			  ld a,l 
8905 1f			  rra 
8906 ac			  xor h 
8907 67			  ld h,a 
8908 7d			  ld a,l 
8909 1f			  rra 
890a 7c			  ld a,h 
890b 1f			  rra 
890c ad			  xor l 
890d 6f			  ld l,a 
890e ac			  xor h 
890f 67			  ld h,a 
8910			 
8910 22 bb eb		  ld (xrandc),hl 
8913			 
8913 c9			  ret 
8914			;  
8914			 
8914			 
8914			;;;; int maths 
8914			 
8914			; https://map.grauw.nl/articles/mult_div_shifts.php 
8914			; Divide 16-bit values (with 16-bit result) 
8914			; In: Divide BC by divider DE 
8914			; Out: BC = result, HL = rest 
8914			; 
8914			Div16: 
8914 21 00 00		    ld hl,0 
8917 78			    ld a,b 
8918 06 08		    ld b,8 
891a			Div16_Loop1: 
891a 17			    rla 
891b ed 6a		    adc hl,hl 
891d ed 52		    sbc hl,de 
891f 30 01		    jr nc,Div16_NoAdd1 
8921 19			    add hl,de 
8922			Div16_NoAdd1: 
8922 10 f6		    djnz Div16_Loop1 
8924 17			    rla 
8925 2f			    cpl 
8926 47			    ld b,a 
8927 79			    ld a,c 
8928 48			    ld c,b 
8929 06 08		    ld b,8 
892b			Div16_Loop2: 
892b 17			    rla 
892c ed 6a		    adc hl,hl 
892e ed 52		    sbc hl,de 
8930 30 01		    jr nc,Div16_NoAdd2 
8932 19			    add hl,de 
8933			Div16_NoAdd2: 
8933 10 f6		    djnz Div16_Loop2 
8935 17			    rla 
8936 2f			    cpl 
8937 41			    ld b,c 
8938 4f			    ld c,a 
8939 c9			ret 
893a			 
893a			 
893a			;http://z80-heaven.wikidot.com/math 
893a			; 
893a			;Inputs: 
893a			;     DE and A are factors 
893a			;Outputs: 
893a			;     A is not changed 
893a			;     B is 0 
893a			;     C is not changed 
893a			;     DE is not changed 
893a			;     HL is the product 
893a			;Time: 
893a			;     342+6x 
893a			; 
893a			Mult16: 
893a			 
893a 06 08		     ld b,8          ;7           7 
893c 21 00 00		     ld hl,0         ;10         10 
893f 29			       add hl,hl     ;11*8       88 
8940 07			       rlca          ;4*8        32 
8941 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8943 19			         add hl,de   ;--         -- 
8944 10 f9		       djnz $-5      ;13*7+8     99 
8946 c9			ret 
8947			 
8947			; 
8947			; Square root of 16-bit value 
8947			; In:  HL = value 
8947			; Out:  D = result (rounded down) 
8947			; 
8947			;Sqr16: 
8947			;    ld de,#0040 
8947			;    ld a,l 
8947			;    ld l,h 
8947			;    ld h,d 
8947			;    or a 
8947			;    ld b,8 
8947			;Sqr16_Loop: 
8947			;    sbc hl,de 
8947			;    jr nc,Sqr16_Skip 
8947			;    add hl,de 
8947			;Sqr16_Skip: 
8947			;    ccf 
8947			;    rl d 
8947			;    add a,a 
8947			;    adc hl,hl 
8947			;    add a,a 
8947			;    adc hl,hl 
8947			;    djnz Sqr16_Loop 
8947			;    ret 
8947			; 
8947			; 
8947			; Divide 8-bit values 
8947			; In: Divide E by divider C 
8947			; Out: A = result, B = rest 
8947			; 
8947			Div8: 
8947 af			    xor a 
8948 06 08		    ld b,8 
894a			Div8_Loop: 
894a cb 13		    rl e 
894c 17			    rla 
894d 91			    sub c 
894e 30 01		    jr nc,Div8_NoAdd 
8950 81			    add a,c 
8951			Div8_NoAdd: 
8951 10 f7		    djnz Div8_Loop 
8953 47			    ld b,a 
8954 7b			    ld a,e 
8955 17			    rla 
8956 2f			    cpl 
8957 c9			    ret 
8958			 
8958			; 
8958			; Multiply 8-bit value with a 16-bit value (unrolled) 
8958			; In: Multiply A with DE 
8958			; Out: HL = result 
8958			; 
8958			Mult12U: 
8958 2e 00		    ld l,0 
895a 87			    add a,a 
895b 30 01		    jr nc,Mult12U_NoAdd0 
895d 19			    add hl,de 
895e			Mult12U_NoAdd0: 
895e 29			    add hl,hl 
895f 87			    add a,a 
8960 30 01		    jr nc,Mult12U_NoAdd1 
8962 19			    add hl,de 
8963			Mult12U_NoAdd1: 
8963 29			    add hl,hl 
8964 87			    add a,a 
8965 30 01		    jr nc,Mult12U_NoAdd2 
8967 19			    add hl,de 
8968			Mult12U_NoAdd2: 
8968 29			    add hl,hl 
8969 87			    add a,a 
896a 30 01		    jr nc,Mult12U_NoAdd3 
896c 19			    add hl,de 
896d			Mult12U_NoAdd3: 
896d 29			    add hl,hl 
896e 87			    add a,a 
896f 30 01		    jr nc,Mult12U_NoAdd4 
8971 19			    add hl,de 
8972			Mult12U_NoAdd4: 
8972 29			    add hl,hl 
8973 87			    add a,a 
8974 30 01		    jr nc,Mult12U_NoAdd5 
8976 19			    add hl,de 
8977			Mult12U_NoAdd5: 
8977 29			    add hl,hl 
8978 87			    add a,a 
8979 30 01		    jr nc,Mult12U_NoAdd6 
897b 19			    add hl,de 
897c			Mult12U_NoAdd6: 
897c 29			    add hl,hl 
897d 87			    add a,a 
897e d0			    ret nc 
897f 19			    add hl,de 
8980 c9			    ret 
8981			 
8981			; 
8981			; Multiply 8-bit value with a 16-bit value (right rotating) 
8981			; In: Multiply A with DE 
8981			;      Put lowest value in A for most efficient calculation 
8981			; Out: HL = result 
8981			; 
8981			Mult12R: 
8981 21 00 00		    ld hl,0 
8984			Mult12R_Loop: 
8984 cb 3f		    srl a 
8986 30 01		    jr nc,Mult12R_NoAdd 
8988 19			    add hl,de 
8989			Mult12R_NoAdd: 
8989 cb 23		    sla e 
898b cb 12		    rl d 
898d b7			    or a 
898e c2 84 89		    jp nz,Mult12R_Loop 
8991 c9			    ret 
8992			 
8992			; 
8992			; Multiply 16-bit values (with 32-bit result) 
8992			; In: Multiply BC with DE 
8992			; Out: BCHL = result 
8992			; 
8992			Mult32: 
8992 79			    ld a,c 
8993 48			    ld c,b 
8994 21 00 00		    ld hl,0 
8997 06 10		    ld b,16 
8999			Mult32_Loop: 
8999 29			    add hl,hl 
899a 17			    rla 
899b cb 11		    rl c 
899d 30 07		    jr nc,Mult32_NoAdd 
899f 19			    add hl,de 
89a0 ce 00		    adc a,0 
89a2 d2 a6 89		    jp nc,Mult32_NoAdd 
89a5 0c			    inc c 
89a6			Mult32_NoAdd: 
89a6 10 f1		    djnz Mult32_Loop 
89a8 41			    ld b,c 
89a9 4f			    ld c,a 
89aa c9			    ret 
89ab			 
89ab			 
89ab			 
89ab			; 
89ab			; Multiply 8-bit values 
89ab			; In:  Multiply H with E 
89ab			; Out: HL = result 
89ab			; 
89ab			Mult8: 
89ab 16 00		    ld d,0 
89ad 6a			    ld l,d 
89ae 06 08		    ld b,8 
89b0			Mult8_Loop: 
89b0 29			    add hl,hl 
89b1 30 01		    jr nc,Mult8_NoAdd 
89b3 19			    add hl,de 
89b4			Mult8_NoAdd: 
89b4 10 fa		    djnz Mult8_Loop 
89b6 c9			    ret 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			 
89b7			;;http://z80-heaven.wikidot.com/math 
89b7			;;This divides DE by BC, storing the result in DE, remainder in HL 
89b7			; 
89b7			;DE_Div_BC:          ;1281-2x, x is at most 16 
89b7			;     ld a,16        ;7 
89b7			;     ld hl,0        ;10 
89b7			;     jp $+5         ;10 
89b7			;.DivLoop: 
89b7			;       add hl,bc    ;-- 
89b7			;       dec a        ;64 
89b7			;       jr z,.DivLoopEnd        ;86 
89b7			; 
89b7			;       sla e        ;128 
89b7			;       rl d         ;128 
89b7			;       adc hl,hl    ;240 
89b7			;       sbc hl,bc    ;240 
89b7			;       jr nc,.DivLoop ;23|21 
89b7			;       inc e        ;-- 
89b7			;       jp .DivLoop+1 
89b7			; 
89b7			;.DivLoopEnd: 
89b7			 
89b7			;HL_Div_C: 
89b7			;Inputs: 
89b7			;     HL is the numerator 
89b7			;     C is the denominator 
89b7			;Outputs: 
89b7			;     A is the remainder 
89b7			;     B is 0 
89b7			;     C is not changed 
89b7			;     DE is not changed 
89b7			;     HL is the quotient 
89b7			; 
89b7			;       ld b,16 
89b7			;       xor a 
89b7			;         add hl,hl 
89b7			;         rla 
89b7			;         cp c 
89b7			;         jr c,$+4 
89b7			;           inc l 
89b7			;           sub c 
89b7			;         djnz $-7 
89b7			 
89b7			; https://plutiedev.com/z80-add-8bit-to-16bit 
89b7			 
89b7			addatohl: 
89b7 85			    add   a, l    ; A = A+L 
89b8 6f			    ld    l, a    ; L = A+L 
89b9 8c			    adc   a, h    ; A = A+L+H+carry 
89ba 95			    sub   l       ; A = H+carry 
89bb 67			    ld    h, a    ; H = H+carry 
89bc c9			ret 
89bd			 
89bd			addatode: 
89bd 83			    add   a, e    ; A = A+L 
89be 5f			    ld    e, a    ; L = A+L 
89bf 8a			    adc   a, d    ; A = A+L+H+carry 
89c0 93			    sub   e       ; A = H+carry 
89c1 57			    ld    d, a    ; H = H+carry 
89c2 c9			ret 
89c3			 
89c3			 
89c3			addatobc: 
89c3 81			    add   a, c    ; A = A+L 
89c4 4f			    ld    c, a    ; L = A+L 
89c5 88			    adc   a, b    ; A = A+L+H+carry 
89c6 91			    sub   c       ; A = H+carry 
89c7 47			    ld    b, a    ; H = H+carry 
89c8 c9			ret 
89c9			 
89c9			subafromhl: 
89c9			   ; If A=0 do nothing 
89c9			    ; Otherwise flip A's sign. Since 
89c9			    ; the upper byte becomes -1, also 
89c9			    ; substract 1 from H. 
89c9 ed 44		    neg 
89cb ca d4 89		    jp    z, Skip 
89ce 25			    dec   h 
89cf			     
89cf			    ; Now add the low byte as usual 
89cf			    ; Two's complement takes care of 
89cf			    ; ensuring the result is correct 
89cf 85			    add   a, l 
89d0 6f			    ld    l, a 
89d1 8c			    adc   a, h 
89d2 95			    sub   l 
89d3 67			    ld    h, a 
89d4			Skip: 
89d4 c9				ret 
89d5			 
89d5			 
89d5			; compare hl and de 
89d5			; returns:  
89d5			; if hl = de, z=1, s=0, c0=0 
89d5			; if hl > de, z=0, s=0, c=0 
89d5			; if hl < de, z=0, s=1, c=1 
89d5			cmp16:	 
89d5 b7				or a 
89d6 ed 52			sbc hl,de 
89d8 e0				ret po 
89d9 7c				ld a,h 
89da 1f				rra 
89db ee 40			xor 01000000B 
89dd 37				scf 
89de 8f				adc a,a 
89df c9				ret 
89e0			 
89e0			 
89e0			; test if hl contains zero   - A is destroyed 
89e0			 
89e0			ishlzero:    
89e0 b7				or a     ; reset flags 
89e1 7c				ld a, h 
89e2 b5				or l        	 
89e3			 
89e3 c9				ret 
89e4			 
89e4			 
89e4			 
89e4			 
89e4			if FORTH_ENABLE_FLOATMATH 
89e4			;include "float/bbcmath.z80" 
89e4			include "float/lpfpcalc.asm" 
89e4			endif 
89e4			 
89e4			 
89e4			; eof 
89e4			 
# End of file firmware_maths.asm
89e4			include "firmware_strings.asm"   ; string handling  
89e4			 
89e4			 
89e4			; TODO string len 
89e4			; input text string, end on cr with zero term 
89e4			; a offset into frame buffer to start prompt 
89e4			; d is max length 
89e4			; e is display size TODO 
89e4			; c is current cursor position 
89e4			; hl is ptr to where string will be stored 
89e4			 
89e4			 
89e4			; TODO check limit of buffer for new inserts 
89e4			; TODO check insert does not push beyond buffer 
89e4			; TODO scroll in a limited display area 
89e4			; TODO scroll whole screen on page wrap 
89e4			 
89e4			 
89e4			; TODO handle KEY_PREVWORD 
89e4			; TODO handle KEY_NEXTWORD 
89e4			; TODO handle KEY_HOME 
89e4			; TODO handle KEY_END 
89e4			; TODO use LCD cursor? 
89e4			 
89e4 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
89e7 81					add c 
89e8 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
89eb 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
89ee 79					ld a, c 
89ef cd b7 89				call addatohl 
89f2 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
89f5 7a					ld a,d 
89f6 32 75 ee			        ld (input_size), a       ; save length of input area 
89f9 79					ld a, c 
89fa 32 64 ee				ld (input_cursor),a      ; init cursor start position  
89fd 7b					ld a,e 
89fe 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8a01					 
8a01					 
8a01			 
8a01			;		ld a,(input_ptr) 
8a01			;		ld (input_under_cursor),a 	; save what is under the cursor 
8a01			 
8a01			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8a01					; init cursor shape if not set by the cin routines 
8a01 21 d3 eb				ld hl, cursor_shape 
8a04 3e ff				ld a, 255 
8a06 77					ld (hl), a 
8a07 23					inc hl 
8a08 3e 00				ld a, 0 
8a0a 77					ld (hl), a 
8a0b			 
8a0b 3e 0f				ld a, CUR_BLINK_RATE 
8a0d 32 6f ee				ld (input_cur_flash), a 
8a10 3e 01				ld a, 1 
8a12 32 6e ee				ld (input_cur_onoff),a 
8a15			 
8a15			;	if DEBUG_INPUT 
8a15			;		push af 
8a15			;		ld a, 'I' 
8a15			;		ld (debug_mark),a 
8a15			;		pop af 
8a15			;		CALLMONITOR 
8a15			;	endif 
8a15			.is1:		; main entry loop 
8a15			 
8a15			 
8a15			 
8a15					; pause 1ms 
8a15			 
8a15 3e 01				ld a, 1 
8a17 cd c7 87				call aDelayInMS 
8a1a			 
8a1a					; dec flash counter 
8a1a 3a 6f ee				ld a, (input_cur_flash) 
8a1d 3d					dec a 
8a1e 32 6f ee				ld (input_cur_flash), a 
8a21 fe 00				cp 0 
8a23 20 0d				jr nz, .nochgstate 
8a25			 
8a25			 
8a25					; change state 
8a25 3a 6e ee				ld a,(input_cur_onoff) 
8a28 ed 44				neg 
8a2a 32 6e ee				ld (input_cur_onoff),a 
8a2d			 
8a2d			 
8a2d					; reset on change of state 
8a2d 3e 0f				ld a, CUR_BLINK_RATE 
8a2f 32 6f ee				ld (input_cur_flash), a 
8a32			 
8a32			.nochgstate: 
8a32					 
8a32					 
8a32			 
8a32					; display cursor  
8a32			 
8a32			;		ld hl, (input_start) 
8a32			;		ld a, (input_cursor) 
8a32			;		call addatohl 
8a32			 
8a32					; get char under cursor and replace with cursor 
8a32 2a 78 ee		ld hl, (input_ptr) 
8a35			;		ld a, (hl) 
8a35			;		ld (input_under_cursor),a 
8a35			;		ld a, '_' 
8a35			;		ld (hl), a 
8a35			 
8a35					; display string 
8a35			 
8a35 ed 5b 76 ee			ld de, (input_start) 
8a39 3a 73 ee				ld a, (input_at_pos) 
8a3c cd 71 88				call str_at_display 
8a3f			;	        call update_display 
8a3f			 
8a3f					; find place to put the cursor 
8a3f			;		add h 
8a3f			;		ld l, display_row_1 
8a3f			;		sub l 
8a3f			; (input_at_pos) 
8a3f					;ld c, a 
8a3f			;		ld a, (input_cursor) 
8a3f			;		ld l, (input_at_pos) 
8a3f			;		;ld b, h 
8a3f			;		add l 
8a3f			;		ld (input_at_cursor),a 
8a3f					;ld l,h 
8a3f			 
8a3f			;		ld h, 0 
8a3f			;		ld l,(input_at_pos) 
8a3f			;		ld a, (input_cursor) 
8a3f			;		call addatohl 
8a3f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8a3f			;		call subafromhl 
8a3f			;		ld a,l 
8a3f			;		ld (input_at_cursor), a 
8a3f			 
8a3f				if DEBUG_INPUT 
8a3f					ld a, (hardware_diag) 
8a3f					cp 0 
8a3f					jr z, .skip_input_diag 
8a3f			 
8a3f					ld a,(input_at_pos) 
8a3f					ld hl, LFSRSeed 
8a3f					call hexout 
8a3f					ld a, (input_cursor) 
8a3f					ld hl, LFSRSeed+2 
8a3f					call hexout 
8a3f					ld a,(input_at_cursor) 
8a3f					ld hl, LFSRSeed+4 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_cur_onoff) 
8a3f					ld hl, LFSRSeed+6 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_cur_flash) 
8a3f					ld hl, LFSRSeed+8 
8a3f					call hexout 
8a3f			 
8a3f					ld a,(input_len) 
8a3f					ld hl, LFSRSeed+10 
8a3f					call hexout 
8a3f					ld hl, LFSRSeed+12 
8a3f					ld a, 0 
8a3f					ld (hl),a 
8a3f					ld a, display_row_4 
8a3f					ld de, LFSRSeed 
8a3f					call str_at_display 
8a3f					.skip_input_diag: 
8a3f				endif 
8a3f			 
8a3f					; decide on if we are showing the cursor this time round 
8a3f			 
8a3f 3a 6e ee				ld a, (input_cur_onoff) 
8a42 fe ff				cp 255 
8a44 28 13				jr z, .skipcur 
8a46			 
8a46			 
8a46 3a 71 ee				ld a,(input_at_cursor) 
8a49 11 d3 eb				ld de, cursor_shape 
8a4c cd 71 88				call str_at_display 
8a4f			 
8a4f					; save length of current input string 
8a4f 2a 76 ee				ld hl, (input_start) 
8a52 cd 15 8e				call strlenz 
8a55 7d					ld a,l 
8a56 32 69 ee				ld (input_len),a 
8a59			 
8a59			.skipcur: 
8a59			 
8a59 cd 81 88			        call update_display 
8a5c					 
8a5c			 
8a5c			 
8a5c					; wait 
8a5c				 
8a5c					; TODO loop without wait to flash the cursor and char under cursor	 
8a5c cd 98 d4				call cin    ; _wait 
8a5f			 
8a5f fe 00				cp 0 
8a61 ca 15 8a				jp z, .is1 
8a64			 
8a64					; get ptr to char to input into 
8a64			 
8a64 4f					ld c,a 
8a65 2a 76 ee				ld hl, (input_start) 
8a68 3a 64 ee				ld a, (input_cursor) 
8a6b cd b7 89				call addatohl 
8a6e 22 78 ee				ld (input_ptr), hl 
8a71 79					ld a,c 
8a72			 
8a72					; replace char under cursor 
8a72			 
8a72			;		ld hl, (input_ptr) 
8a72			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8a72			;		ld (hl), a 
8a72			 
8a72			;	if DEBUG_INPUT 
8a72			;		push af 
8a72			;		ld a, 'i' 
8a72			;		ld (debug_mark),a 
8a72			;		pop af 
8a72			;		CALLMONITOR 
8a72			;	endif 
8a72 fe 0e				cp KEY_HOME 
8a74 20 0e				jr nz, .iske 
8a76			 
8a76 3a 73 ee				ld a, (input_at_pos) 
8a79 32 71 ee				ld (input_at_cursor),a 
8a7c 3e 00				ld a, 0 
8a7e 32 64 ee				ld (input_cursor), a 
8a81 c3 15 8a				jp .is1 
8a84					 
8a84 fe 0f		.iske:		cp KEY_END 
8a86 20 03				jr nz, .isknw 
8a88 c3 15 8a				jp .is1 
8a8b			 
8a8b fe 06		.isknw:		cp KEY_NEXTWORD 
8a8d 20 1b				jr nz, .iskpw 
8a8f			 
8a8f 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8a92 7e					ld a,(hl)	 
8a93 fe 00				cp 0 
8a95 ca 15 8a				jp z, .is1    ; end of string 
8a98 fe 20				cp ' ' 
8a9a ca 15 8a				jp z, .is1    ; end of word 
8a9d 23					inc hl 
8a9e 22 78 ee				ld (input_ptr), hl 
8aa1 3a 71 ee				ld a, (input_at_cursor) 
8aa4 3c					inc a 
8aa5 32 71 ee				ld (input_at_cursor), a 
8aa8 18 e5				jr .isknwm 
8aaa			 
8aaa fe 07		.iskpw:		cp KEY_PREVWORD 
8aac 20 1b				jr nz, .iskl 
8aae			.iskpwm:	 
8aae 2a 78 ee				ld hl, (input_ptr) 
8ab1 7e					ld a,(hl)	 
8ab2 fe 00				cp 0  
8ab4 ca 15 8a				jp z, .is1    ; end of string 
8ab7 fe 20				cp ' ' 
8ab9 ca 15 8a				jp z, .is1    ; end of word 
8abc 2b					dec hl 
8abd 22 78 ee				ld (input_ptr), hl 
8ac0 3a 71 ee				ld a, (input_at_cursor) 
8ac3 3d					dec a 
8ac4 32 71 ee				ld (input_at_cursor), a 
8ac7 18 e5				jr .iskpwm 
8ac9			 
8ac9			 
8ac9 fe 0b		.iskl:		cp KEY_LEFT 
8acb 20 27				jr nz, .isk1 
8acd			 
8acd 3a 64 ee				ld a, (input_cursor) 
8ad0			 
8ad0 fe 00				cp 0 
8ad2 ca 15 8a				jp z, .is1 		; at start of line to ignore  
8ad5			 
8ad5 3d					dec  a 		; TODO check underflow 
8ad6 32 64 ee				ld (input_cursor), a 
8ad9			 
8ad9 2a 78 ee				ld hl, (input_ptr) 
8adc 2b					dec hl 
8add 22 78 ee				ld (input_ptr), hl 
8ae0					 
8ae0 3a 71 ee				ld a, (input_at_cursor) 
8ae3 3d					dec a 
8ae4 32 71 ee				ld (input_at_cursor), a 
8ae7			 
8ae7 3e 01				ld a, 1		; show cursor moving 
8ae9 32 6e ee				ld (input_cur_onoff),a 
8aec 3e 0f				ld a, CUR_BLINK_RATE 
8aee 32 6f ee				ld (input_cur_flash), a 
8af1			 
8af1 c3 15 8a				jp .is1 
8af4			 
8af4 fe 0c		.isk1:		cp KEY_RIGHT 
8af6 20 2a				jr nz, .isk2 
8af8			 
8af8 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8afb 5f					ld e,a 
8afc 3a 64 ee				ld a, (input_cursor) 
8aff bb					cp e 
8b00 ca 15 8a				jp z, .is1		; at the end of string so dont go right 
8b03			 
8b03 3c					inc  a 		; TODO check overflow 
8b04 32 64 ee				ld (input_cursor), a 
8b07			 
8b07 3a 71 ee				ld a, (input_at_cursor) 
8b0a 3c					inc a 
8b0b 32 71 ee				ld (input_at_cursor), a 
8b0e			 
8b0e 2a 78 ee				ld hl, (input_ptr) 
8b11 23					inc hl 
8b12 22 78 ee				ld (input_ptr), hl 
8b15			 
8b15 3e 01				ld a, 1		; show cursor moving 
8b17 32 6e ee				ld (input_cur_onoff),a 
8b1a 3e 0f				ld a, CUR_BLINK_RATE 
8b1c 32 6f ee				ld (input_cur_flash), a 
8b1f			 
8b1f c3 15 8a				jp .is1 
8b22			 
8b22 fe 05		.isk2:		cp KEY_UP 
8b24			 
8b24 20 26				jr nz, .isk3 
8b26			 
8b26					; swap last command with the current on 
8b26			 
8b26					; move cursor to start of string 
8b26 2a 76 ee				ld hl, (input_start) 
8b29 22 78 ee				ld (input_ptr), hl 
8b2c			 
8b2c 3a 73 ee				ld a, (input_at_pos) 
8b2f 32 71 ee				ld (input_at_cursor), a 
8b32			 
8b32 3e 00				ld a, 0 
8b34 32 64 ee				ld (input_cursor), a 
8b37					 
8b37					; swap input and last command buffers 
8b37			 
8b37 21 9c e6				ld hl, os_cli_cmd 
8b3a 11 9b e7				ld de, os_last_cmd 
8b3d 06 ff				ld b, 255 
8b3f 7e			.swap1:		ld a, (hl) 
8b40 4f					ld c,a 
8b41 1a					ld a, (de) 
8b42 77					ld (hl), a 
8b43 79					ld a,c 
8b44 12					ld (de),a 
8b45 23					inc hl 
8b46 13					inc de 
8b47 10 f6				djnz .swap1 
8b49			 
8b49			 
8b49			 
8b49			 
8b49			 
8b49 c3 15 8a				jp .is1 
8b4c			 
8b4c fe 08		.isk3:		cp KEY_BS 
8b4e 20 3c				jr nz, .isk4 
8b50			 
8b50 3a 64 ee				ld a, (input_cursor) 
8b53			 
8b53 fe 00				cp 0 
8b55 ca 15 8a				jp z, .is1 		; at start of line to ignore  
8b58			 
8b58 3d					dec  a 		; TODO check underflow 
8b59 32 64 ee				ld (input_cursor), a 
8b5c			 
8b5c					; hl is source 
8b5c					; de needs to be source - 1 
8b5c			 
8b5c			;		ld a, 0 
8b5c			;		dec hl 
8b5c			;		ld (hl), a 
8b5c			 
8b5c 2a 78 ee				ld hl, (input_ptr) 
8b5f 2b					dec hl 
8b60 22 78 ee				ld (input_ptr), hl 
8b63			 
8b63					; shift all data 
8b63			 
8b63 e5					push hl 
8b64 23					inc hl 
8b65 d1					pop de 
8b66 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8b69 4f					ld c,a 
8b6a 06 00				ld b,0 
8b6c ed b0				ldir  
8b6e			 
8b6e			 
8b6e			 
8b6e			 
8b6e 3a 71 ee				ld a, (input_at_cursor) 
8b71 3d					dec a 
8b72 32 71 ee				ld (input_at_cursor), a 
8b75			 
8b75			 
8b75 3e 01				ld a, 1		; show cursor moving 
8b77 32 6e ee				ld (input_cur_onoff),a 
8b7a 3e 0f				ld a, CUR_BLINK_RATE 
8b7c 32 6f ee				ld (input_cur_flash), a 
8b7f			 
8b7f					; remove char 
8b7f 3a 71 ee				ld a, (input_at_cursor) 
8b82 3c					inc a 
8b83 11 0d 8c				ld de,.iblank 
8b86 cd 71 88				call str_at_display 
8b89			 
8b89 c3 15 8a				jp .is1 
8b8c			 
8b8c fe 0d		.isk4:		cp KEY_CR 
8b8e 28 6c				jr z, .endinput 
8b90			 
8b90					; else add the key press to the end 
8b90			 
8b90 4f					ld c, a			; save key pressed 
8b91			 
8b91 7e					ld a,(hl)		; get what is currently under char 
8b92			 
8b92 fe 00				cp 0			; we are at the end of the string 
8b94 20 2f				jr nz, .onchar 
8b96					 
8b96					; add a char to the end of the string 
8b96				 
8b96 71					ld (hl),c 
8b97 23					inc hl 
8b98			;		ld a,' ' 
8b98			;		ld (hl),a 
8b98			;		inc hl 
8b98 3e 00				ld a,0 
8b9a 77					ld (hl),a 
8b9b 2b					dec hl 
8b9c			 
8b9c 3a 64 ee				ld a, (input_cursor) 
8b9f 3c					inc a				; TODO check max string length and scroll  
8ba0 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8ba3							 
8ba3 3a 71 ee				ld a, (input_at_cursor) 
8ba6 3c					inc a 
8ba7 32 71 ee				ld (input_at_cursor), a 
8baa			 
8baa 2a 78 ee				ld hl, (input_ptr) 
8bad 23					inc hl 
8bae 22 78 ee				ld (input_ptr), hl 
8bb1			 
8bb1 2a 78 ee				ld hl, (input_ptr) 
8bb4 23					inc hl 
8bb5 22 78 ee				ld (input_ptr), hl 
8bb8			;	if DEBUG_INPUT 
8bb8			;		push af 
8bb8			;		ld a, '+' 
8bb8			;		ld (debug_mark),a 
8bb8			;		pop af 
8bb8			;		CALLMONITOR 
8bb8			;	endif 
8bb8 3e 01				ld a, 1		; show cursor moving 
8bba 32 6e ee				ld (input_cur_onoff),a 
8bbd 3e 0f				ld a, CUR_BLINK_RATE 
8bbf 32 6f ee				ld (input_cur_flash), a 
8bc2 c3 15 8a				jp .is1 
8bc5					 
8bc5			 
8bc5			 
8bc5					; if on a char then insert 
8bc5			.onchar: 
8bc5			 
8bc5					; TODO over flow check: make sure insert does not blow out buffer 
8bc5			 
8bc5					; need to do some maths to use lddr 
8bc5			 
8bc5 e5					push hl   ; save char pos 
8bc6 c5					push bc 
8bc7			 
8bc7 2a 76 ee				ld hl, (input_start) 
8bca 3a 69 ee				ld a, (input_len) 
8bcd cd b7 89				call addatohl  		; end of string 
8bd0 23					inc hl 
8bd1 23					inc hl		; past zero term 
8bd2 e5					push hl 
8bd3 23					inc hl 
8bd4 e5					push hl  
8bd5			 
8bd5								; start and end of lddr set, now how much to move? 
8bd5			 
8bd5							 
8bd5 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8bd8 47					ld b,a 
8bd9 3a 69 ee				ld a,(input_len) 
8bdc 5f					ld e,a 
8bdd 90					sub b 
8bde 3c					inc a		;?? 
8bdf 3c					inc a		;?? 
8be0 3c					inc a		;?? 
8be1			 
8be1 06 00				ld b,0 
8be3 4f					ld c,a 
8be4			 
8be4				if DEBUG_INPUT 
8be4					push af 
8be4					ld a, 'i' 
8be4					ld (debug_mark),a 
8be4					pop af 
8be4			;		CALLMONITOR 
8be4				endif 
8be4 d1					pop de 
8be5 e1					pop hl 
8be6				if DEBUG_INPUT 
8be6					push af 
8be6					ld a, 'I' 
8be6					ld (debug_mark),a 
8be6					pop af 
8be6			;		CALLMONITOR 
8be6				endif 
8be6 ed b8				lddr 
8be8				 
8be8			 
8be8			 
8be8					; TODO have a key for insert/overwrite mode???? 
8be8 c1					pop bc 
8be9 e1					pop hl 
8bea 71					ld (hl), c		; otherwise overwrite current char 
8beb					 
8beb			 
8beb			 
8beb			 
8beb 3a 64 ee				ld a, (input_cursor) 
8bee 3c					inc  a 		; TODO check overflow 
8bef 32 64 ee				ld (input_cursor), a 
8bf2			 
8bf2 3a 71 ee				ld a, (input_at_cursor) 
8bf5 3c					inc a 
8bf6 32 71 ee				ld (input_at_cursor), a 
8bf9			 
8bf9 c3 15 8a				jp .is1 
8bfc			 
8bfc			.endinput:	; TODO look for end of string 
8bfc			 
8bfc					; add trailing space for end of token 
8bfc			 
8bfc 2a 76 ee				ld hl, (input_start) 
8bff 3a 69 ee				ld a,(input_len) 
8c02 cd b7 89				call addatohl 
8c05 3e 20				ld a, ' ' 
8c07 77					ld (hl),a 
8c08					; TODO eof of parse marker 
8c08			 
8c08 23					inc hl 
8c09 3e 00				ld a, 0 
8c0b 77					ld (hl),a 
8c0c			 
8c0c			 
8c0c c9					ret 
8c0d			 
8c0d .. 00		.iblank: db " ",0 
8c0f			 
8c0f			 
8c0f 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8c12 22 76 ee				ld (input_start), hl 
8c15 3e 01				ld a,1			; add cursor 
8c17 77					ld (hl),a 
8c18 23					inc hl 
8c19 3e 00				ld a,0 
8c1b 77					ld (hl),a 
8c1c 22 78 ee				ld (input_ptr), hl 
8c1f 7a					ld a,d 
8c20 32 75 ee				ld (input_size), a 
8c23 3e 00				ld a,0 
8c25 32 64 ee				ld (input_cursor),a 
8c28			.instr1:	 
8c28			 
8c28					; TODO do block cursor 
8c28					; TODO switch cursor depending on the modifer key 
8c28			 
8c28					; update cursor shape change on key hold 
8c28			 
8c28 2a 78 ee				ld hl, (input_ptr) 
8c2b 2b					dec hl 
8c2c 3a d3 eb				ld a,(cursor_shape) 
8c2f 77					ld (hl), a 
8c30			 
8c30					; display entered text 
8c30 3a 73 ee				ld a,(input_at_pos) 
8c33 cd f6 d3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8c36 ed 5b 76 ee	            	LD   de, (input_start) 
8c3a cd f0 d3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8c3d			 
8c3d cd 98 d4				call cin 
8c40 fe 00				cp 0 
8c42 28 e4				jr z, .instr1 
8c44			 
8c44					; proecess keyboard controls first 
8c44			 
8c44 2a 78 ee				ld hl,(input_ptr) 
8c47			 
8c47 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8c49 28 5a				jr z, .instrcr 
8c4b			 
8c4b fe 08				cp KEY_BS 	; back space 
8c4d 20 0f				jr nz, .instr2 
8c4f					; process back space 
8c4f			 
8c4f					; TODO stop back space if at start of string 
8c4f 2b					dec hl 
8c50 2b					dec hl ; to over write cursor 
8c51 3a d3 eb				ld a,(cursor_shape) 
8c54					;ld a,0 
8c54 77					ld (hl),a 
8c55 23					inc hl 
8c56 3e 20				ld a," " 
8c58 77					ld (hl),a 
8c59 22 78 ee				ld (input_ptr),hl 
8c5c					 
8c5c			 
8c5c 18 ca				jr .instr1 
8c5e			 
8c5e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8c60 20 06				jr nz, .instr3 
8c62 2b					dec hl 
8c63 22 78 ee				ld (input_ptr),hl 
8c66 18 c0				jr .instr1 
8c68				 
8c68 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8c6a 20 06				jr nz, .instr4 
8c6c 23					inc hl 
8c6d 22 78 ee				ld (input_ptr),hl 
8c70 18 b6				jr .instr1 
8c72			 
8c72 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8c74 20 06				jr nz, .instr5 
8c76 2b					dec hl 
8c77 22 78 ee				ld (input_ptr),hl 
8c7a 18 ac				jr .instr1 
8c7c			 
8c7c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8c7e 20 06				jr nz, .instr6 
8c80 2b					dec hl 
8c81 22 78 ee				ld (input_ptr),hl 
8c84 18 a2				jr .instr1 
8c86 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8c88 20 0b				jr nz, .instrnew 
8c8a			 
8c8a 21 75 e3			ld hl, scratch 
8c8d 11 9b e7			ld de, os_last_cmd 
8c90 cd ae 8c			call strcpy 
8c93 18 93				jr .instr1 
8c95			 
8c95			 
8c95			.instrnew:	; no special key pressed to see if we have room to store it 
8c95			 
8c95					; TODO do string size test 
8c95			 
8c95 2b					dec hl ; to over write cursor 
8c96 77					ld (hl),a 
8c97 23					inc hl 
8c98 3a d3 eb				ld a,(cursor_shape) 
8c9b 77					ld (hl),a 
8c9c 23					inc hl 
8c9d 3e 00				ld a,0 
8c9f 77					ld (hl),a 
8ca0			 
8ca0 22 78 ee				ld (input_ptr),hl 
8ca3					 
8ca3 18 83				jr .instr1 
8ca5 2b			.instrcr:	dec hl		; remove cursor 
8ca6 3e 20				ld a,' '	; TODO add a trailing space for safety 
8ca8 77					ld (hl),a 
8ca9 23					inc hl 
8caa 3e 00				ld a,0 
8cac 77					ld (hl),a 
8cad			 
8cad			 
8cad					; if at end of line scroll up    
8cad					; TODO detecting only end of line 4 for scroll up  
8cad			 
8cad					;ld   
8cad			 
8cad c9					ret 
8cae			 
8cae			 
8cae			; strcpy hl = dest, de source 
8cae			 
8cae 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8caf b7			            OR   A              ;Null terminator? 
8cb0 c8			            RET  Z              ;Yes, so finished 
8cb1 1a					ld a,(de) 
8cb2 77					ld (hl),a 
8cb3 13			            INC  DE             ;Point to next character 
8cb4 23					inc hl 
8cb5 18 f7		            JR   strcpy       ;Repeat 
8cb7 c9					ret 
8cb8			 
8cb8			 
8cb8			; TODO string_at  
8cb8			; pass string which starts with lcd offset address and then null term string 
8cb8			 
8cb8			; TODO string to dec 
8cb8			; TODO string to hex 
8cb8			; TODO byte to string hex 
8cb8			; TODO byte to string dec 
8cb8			 
8cb8			 
8cb8			 
8cb8			; from z80uartmonitor 
8cb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cb8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8cb8			; pass hl for where to put the text 
8cb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cb8 c5			hexout:	PUSH BC 
8cb9 f5					PUSH AF 
8cba 47					LD B, A 
8cbb					; Upper nybble 
8cbb cb 3f				SRL A 
8cbd cb 3f				SRL A 
8cbf cb 3f				SRL A 
8cc1 cb 3f				SRL A 
8cc3 cd d3 8c				CALL tohex 
8cc6 77					ld (hl),a 
8cc7 23					inc hl	 
8cc8					 
8cc8					; Lower nybble 
8cc8 78					LD A, B 
8cc9 e6 0f				AND 0FH 
8ccb cd d3 8c				CALL tohex 
8cce 77					ld (hl),a 
8ccf 23					inc hl	 
8cd0					 
8cd0 f1					POP AF 
8cd1 c1					POP BC 
8cd2 c9					RET 
8cd3					 
8cd3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cd3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8cd3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8cd3			tohex: 
8cd3 e5					PUSH HL 
8cd4 d5					PUSH DE 
8cd5 16 00				LD D, 0 
8cd7 5f					LD E, A 
8cd8 21 e0 8c				LD HL, .DATA 
8cdb 19					ADD HL, DE 
8cdc 7e					LD A, (HL) 
8cdd d1					POP DE 
8cde e1					POP HL 
8cdf c9					RET 
8ce0			 
8ce0			.DATA: 
8ce0 30					DEFB	30h	; 0 
8ce1 31					DEFB	31h	; 1 
8ce2 32					DEFB	32h	; 2 
8ce3 33					DEFB	33h	; 3 
8ce4 34					DEFB	34h	; 4 
8ce5 35					DEFB	35h	; 5 
8ce6 36					DEFB	36h	; 6 
8ce7 37					DEFB	37h	; 7 
8ce8 38					DEFB	38h	; 8 
8ce9 39					DEFB	39h	; 9 
8cea 41					DEFB	41h	; A 
8ceb 42					DEFB	42h	; B 
8cec 43					DEFB	43h	; C 
8ced 44					DEFB	44h	; D 
8cee 45					DEFB	45h	; E 
8cef 46					DEFB	46h	; F 
8cf0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8cf0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8cf0			;;    subtract $30, if result > 9 then subtract $7 more 
8cf0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8cf0			atohex: 
8cf0 d6 30				SUB $30 
8cf2 fe 0a				CP 10 
8cf4 f8					RET M		; If result negative it was 0-9 so we're done 
8cf5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8cf7 c9					RET		 
8cf8			 
8cf8			 
8cf8			 
8cf8			 
8cf8			; Get 2 ASCII characters as hex byte from pointer in hl 
8cf8			 
8cf8			BYTERD: 
8cf8 16 00			LD	D,00h		;Set up 
8cfa cd 02 8d			CALL	HEXCON		;Get byte and convert to hex 
8cfd 87				ADD	A,A		;First nibble so 
8cfe 87				ADD	A,A		;multiply by 16 
8cff 87				ADD	A,A		; 
8d00 87				ADD	A,A		; 
8d01 57				LD	D,A		;Save hi nibble in D 
8d02			HEXCON: 
8d02 7e				ld a, (hl)		;Get next chr 
8d03 23				inc hl 
8d04 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8d06 fe 0a			CP	00Ah		;Is it 0-9 ? 
8d08 38 02			JR	C,NALPHA	;If so miss next bit 
8d0a d6 07			SUB	007h		;Else convert alpha 
8d0c			NALPHA: 
8d0c b2				OR	D		;Add hi nibble back 
8d0d c9				RET			; 
8d0e			 
8d0e			 
8d0e			; 
8d0e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8d0e			; Since the routines get_byte and therefore get_nibble are called, only valid 
8d0e			; characters (0-9a-f) are accepted. 
8d0e			; 
8d0e			;get_word        push    af 
8d0e			;                call    get_byte        ; Get the upper byte 
8d0e			;                ld      h, a 
8d0e			;                call    get_byte        ; Get the lower byte 
8d0e			;                ld      l, a 
8d0e			;                pop     af 
8d0e			;                ret 
8d0e			; 
8d0e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8d0e			; the routine get_nibble is used only valid characters are accepted - the  
8d0e			; input routine only accepts characters 0-9a-f. 
8d0e			; 
8d0e c5			get_byte:        push    bc              ; Save contents of B (and C) 
8d0f 7e					ld a,(hl) 
8d10 23					inc hl 
8d11 cd 36 8d		                call    nibble2val      ; Get upper nibble 
8d14 cb 07		                rlc     a 
8d16 cb 07		                rlc     a 
8d18 cb 07		                rlc     a 
8d1a cb 07		                rlc     a 
8d1c 47			                ld      b, a            ; Save upper four bits 
8d1d 7e					ld a,(hl) 
8d1e cd 36 8d		                call    nibble2val      ; Get lower nibble 
8d21 b0			                or      b               ; Combine both nibbles 
8d22 c1			                pop     bc              ; Restore B (and C) 
8d23 c9			                ret 
8d24			; 
8d24			; Get a hexadecimal digit from the serial line. This routine blocks until 
8d24			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8d24			; to the serial line interface. The lower 4 bits of A contain the value of  
8d24			; that particular digit. 
8d24			; 
8d24			;get_nibble      ld a,(hl)           ; Read a character 
8d24			;                call    to_upper        ; Convert to upper case 
8d24			;                call    is_hex          ; Was it a hex digit? 
8d24			;                jr      nc, get_nibble  ; No, get another character 
8d24			 ;               call    nibble2val      ; Convert nibble to value 
8d24			 ;               call    print_nibble 
8d24			 ;               ret 
8d24			; 
8d24			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8d24			; A valid hexadecimal digit is denoted by a set C flag. 
8d24			; 
8d24			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8d24			;                ret     nc              ; Yes 
8d24			;                cp      '0'             ; Less than '0'? 
8d24			;                jr      nc, is_hex_1    ; No, continue 
8d24			;                ccf                     ; Complement carry (i.e. clear it) 
8d24			;                ret 
8d24			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8d24			;                ret     c               ; Yes 
8d24			;                cp      'A'             ; Less than 'A'? 
8d24			;                jr      nc, is_hex_2    ; No, continue 
8d24			;                ccf                     ; Yes - clear carry and return 
8d24			;                ret 
8d24			;is_hex_2        scf                     ; Set carry 
8d24			;                ret 
8d24			; 
8d24			; Convert a single character contained in A to upper case: 
8d24			; 
8d24 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8d26 d8			                ret     c 
8d27 fe 7b		                cp      'z' + 1         ; > 'z'? 
8d29 d0			                ret     nc              ; Nothing to do, either 
8d2a e6 5f		                and     $5f             ; Convert to upper case 
8d2c c9			                ret 
8d2d			 
8d2d			 
8d2d			to_lower: 
8d2d			 
8d2d			   ; if char is in [A-Z] make it lower case 
8d2d			 
8d2d			   ; enter : a = char 
8d2d			   ; exit  : a = lower case char 
8d2d			   ; uses  : af 
8d2d			 
8d2d fe 41		   cp 'A' 
8d2f d8			   ret c 
8d30			    
8d30 fe 5b		   cp 'Z'+1 
8d32 d0			   ret nc 
8d33			    
8d33 f6 20		   or $20 
8d35 c9			   ret 
8d36			 
8d36			; 
8d36			; Expects a hexadecimal digit (upper case!) in A and returns the 
8d36			; corresponding value in A. 
8d36			; 
8d36 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8d38 38 02		                jr      c, nibble2val_1 ; Yes 
8d3a d6 07		                sub     7               ; Adjust for A-F 
8d3c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8d3e e6 0f		                and     $f              ; Only return lower 4 bits 
8d40 c9			                ret 
8d41			; 
8d41			; Print_nibble prints a single hex nibble which is contained in the lower  
8d41			; four bits of A: 
8d41			; 
8d41			;print_nibble    push    af              ; We won't destroy the contents of A 
8d41			;                and     $f              ; Just in case... 
8d41			;                add     a, '0'             ; If we have a digit we are done here. 
8d41			;                cp      '9' + 1         ; Is the result > 9? 
8d41			;                jr      c, print_nibble_1 
8d41			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8d41			;print_nibble_1  call    putc            ; Print the nibble and 
8d41			;                pop     af              ; restore the original value of A 
8d41			;                ret 
8d41			;; 
8d41			;; Send a CR/LF pair: 
8d41			; 
8d41			;crlf            push    af 
8d41			;                ld      a, cr 
8d41			;                call    putc 
8d41			;                ld      a, lf 
8d41			;                call    putc 
8d41			;                pop     af 
8d41			;                ret 
8d41			; 
8d41			; Print_word prints the four hex digits of a word to the serial line. The  
8d41			; word is expected to be in HL. 
8d41			; 
8d41			;print_word      push    hl 
8d41			;                push    af 
8d41			;                ld      a, h 
8d41			;                call    print_byte 
8d41			;                ld      a, l 
8d41			;                call    print_byte 
8d41			;                pop     af 
8d41			;                pop     hl 
8d41			;                ret 
8d41			; 
8d41			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8d41			; The byte to be printed is expected to be in A. 
8d41			; 
8d41			;print_byte      push    af              ; Save the contents of the registers 
8d41			;                push    bc 
8d41			;                ld      b, a 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                rrca 
8d41			;                call    print_nibble    ; Print high nibble 
8d41			;                ld      a, b 
8d41			;                call    print_nibble    ; Print low nibble 
8d41			;                pop     bc              ; Restore original register contents 
8d41			;                pop     af 
8d41			;                ret 
8d41			 
8d41			 
8d41			 
8d41			 
8d41			 
8d41			fourehexhl:  
8d41 7e				ld a,(hl) 
8d42 cd f0 8c			call atohex 
8d45 cb 3f				SRL A 
8d47 cb 3f				SRL A 
8d49 cb 3f				SRL A 
8d4b cb 3f				SRL A 
8d4d 47				ld b, a 
8d4e 23				inc hl 
8d4f 7e				ld a,(hl) 
8d50 23				inc hl 
8d51 cd f0 8c			call atohex 
8d54 80				add b 
8d55 57				ld d,a 
8d56 7e				ld a,(hl) 
8d57 cd f0 8c			call atohex 
8d5a cb 3f				SRL A 
8d5c cb 3f				SRL A 
8d5e cb 3f				SRL A 
8d60 cb 3f				SRL A 
8d62 47				ld b, a 
8d63 23				inc hl 
8d64 7e				ld a,(hl) 
8d65 23				inc hl 
8d66 cd f0 8c			call atohex 
8d69 80				add b 
8d6a 5f				ld e, a 
8d6b d5				push de 
8d6c e1				pop hl 
8d6d c9				ret 
8d6e			 
8d6e			; pass hl. returns z set if the byte at hl is a digit 
8d6e			;isdigithl:  
8d6e			;	push bc 
8d6e			;	ld a,(hl) 
8d6e			;	cp ':' 
8d6e			;	jr nc, .isdf 		; > 
8d6e			;	cp '0' 
8d6e			;	jr c, .isdf		; < 
8d6e			; 
8d6e			;	; TODO find a better way to set z 
8d6e			; 
8d6e			;	ld b,a 
8d6e			;	cp b 
8d6e			;	pop bc 
8d6e			;	ret 
8d6e			; 
8d6e			;.isdf:	; not digit so clear z 
8d6e			; 
8d6e			;	; TODO find a better way to unset z 
8d6e			; 
8d6e			;	ld b,a 
8d6e			;	inc b 
8d6e			;	cp b 
8d6e			; 
8d6e			;	pop bc 
8d6e			;	ret 
8d6e				 
8d6e				 
8d6e			 
8d6e			 
8d6e			; pass hl as the four byte address to load 
8d6e			 
8d6e			get_word_hl:  
8d6e e5				push hl 
8d6f cd 0e 8d			call get_byte 
8d72				 
8d72 47				ld b, a 
8d73			 
8d73 e1				pop hl 
8d74 23				inc hl 
8d75 23				inc hl 
8d76			 
8d76			; TODO not able to handle a-f  
8d76 7e				ld a,(hl) 
8d77			;	;cp ':' 
8d77			;	cp 'g' 
8d77			;	jr nc, .single_byte_hl 		; > 
8d77			;	cp 'G' 
8d77			;	jr nc, .single_byte_hl 		; > 
8d77			;	cp '0' 
8d77			;	jr c, .single_byte_hl		; < 
8d77			 
8d77				;call isdigithl 
8d77 fe 00			cp 0 
8d79 28 06			jr z, .single_byte_hl 
8d7b			 
8d7b			.getwhln:   ; hex word so get next byte 
8d7b			 
8d7b cd 0e 8d			call get_byte 
8d7e 6f				ld l, a 
8d7f 60				ld h,b 
8d80 c9				ret 
8d81 68			.single_byte_hl:   ld l,b 
8d82 26 00				ld h,0 
8d84 c9					ret 
8d85			 
8d85			 
8d85			 
8d85			 
8d85 21 1f 94			ld hl,asc+1 
8d88			;	ld a, (hl) 
8d88			;	call nibble2val 
8d88 cd 0e 8d			call get_byte 
8d8b			 
8d8b			;	call fourehexhl 
8d8b 32 a9 e3			ld (scratch+52),a 
8d8e				 
8d8e 21 a7 e3			ld hl,scratch+50 
8d91 22 98 e6			ld (os_cur_ptr),hl 
8d94			 
8d94 c9				ret 
8d95			 
8d95			 
8d95			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8d95			 
8d95			; Decimal Unsigned Version 
8d95			 
8d95			;Number in a to decimal ASCII 
8d95			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8d95			;Example: display a=56 as "056" 
8d95			;input: a = number 
8d95			;Output: a=0,value of a in the screen 
8d95			;destroys af,bc (don't know about hl and de) 
8d95			DispAToASCII: 
8d95 0e 9c			ld	c,-100 
8d97 cd a1 8d			call	.Na1 
8d9a 0e f6			ld	c,-10 
8d9c cd a1 8d			call	.Na1 
8d9f 0e ff			ld	c,-1 
8da1 06 2f		.Na1:	ld	b,'0'-1 
8da3 04			.Na2:	inc	b 
8da4 81				add	a,c 
8da5 38 fc			jr	c,.Na2 
8da7 91				sub	c		;works as add 100/10/1 
8da8 f5				push af		;safer than ld c,a 
8da9 78				ld	a,b		;char is in b 
8daa			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8daa f1				pop af		;safer than ld a,c 
8dab c9				ret 
8dac			 
8dac			; Decimal Signed Version 
8dac			 
8dac			; DispA 
8dac			; -------------------------------------------------------------- 
8dac			; Converts a signed integer value to a zero-terminated ASCII 
8dac			; string representative of that value (using radix 10). 
8dac			; -------------------------------------------------------------- 
8dac			; INPUTS: 
8dac			;     HL     Value to convert (two's complement integer). 
8dac			;     DE     Base address of string destination. (pointer). 
8dac			; -------------------------------------------------------------- 
8dac			; OUTPUTS: 
8dac			;     None 
8dac			; -------------------------------------------------------------- 
8dac			; REGISTERS/MEMORY DESTROYED 
8dac			; AF HL 
8dac			; -------------------------------------------------------------- 
8dac			 
8dac			;DispHLToASCII: 
8dac			;   push    de 
8dac			;   push    bc 
8dac			; 
8dac			;; Detect sign of HL. 
8dac			;    bit    7, h 
8dac			;    jr     z, ._DoConvert 
8dac			; 
8dac			;; HL is negative. Output '-' to string and negate HL. 
8dac			;    ld     a, '-' 
8dac			;    ld     (de), a 
8dac			;    inc    de 
8dac			; 
8dac			;; Negate HL (using two's complement) 
8dac			;    xor    a 
8dac			;    sub    l 
8dac			;    ld     l, a 
8dac			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8dac			;    sbc    a, h 
8dac			;    ld     h, a 
8dac			; 
8dac			;; Convert HL to digit characters 
8dac			;._DoConvert: 
8dac			;    ld     b, 0     ; B will count character length of number 
8dac			;-   ld     a, 10 
8dac			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8dac			;    push   af 
8dac			;    inc    b 
8dac			;    ld     a, h 
8dac			;    or     l 
8dac			;    jr     nz, - 
8dac			; 
8dac			;; Retrieve digits from stack 
8dac			;-   pop    af 
8dac			;    or     $30 
8dac			;    ld     (de), a 
8dac			;    inc    de 
8dac			;    djnz   - 
8dac			; 
8dac			;; Terminate string with NULL 
8dac			;    xor    a 
8dac			;    ld     (de), a 
8dac			; 
8dac			;    pop    bc 
8dac			;    pop    de 
8dac			;    ret 
8dac			 
8dac			;Comments 
8dac			; 
8dac			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8dac			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8dac			;    Note that the output string will not be fixed-width. 
8dac			; 
8dac			;Example Usage 
8dac			; 
8dac			;    ld    hl, -1004 
8dac			;    ld    de, OP1 
8dac			;    call  DispA 
8dac			;    ld    hl, OP1 
8dac			;    syscall  PutS 
8dac			 
8dac			 
8dac			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8dac			 
8dac			 
8dac			;Converts an ASCII string to an unsigned 16-bit integer 
8dac			;Quits when it reaches a non-decimal digit 
8dac			 
8dac			string_to_uint16: 
8dac			atoui_16: 
8dac			;Input: 
8dac			;     DE points to the string 
8dac			;Outputs: 
8dac			;     HL is the result 
8dac			;     A is the 8-bit value of the number 
8dac			;     DE points to the byte after the number 
8dac			;Destroys: 
8dac			;     BC 
8dac			;       if the string is non-empty, BC is HL/10 
8dac			;Size:  24 bytes 
8dac			;Speed: 42+d(104+{0,9}) 
8dac			;       d is the number of digits in the number 
8dac			;       max is 640 cycles for a 5 digit number 
8dac			;Assuming no leading zeros: 
8dac			;1 digit:  146cc 
8dac			;2 digit:  250cc 
8dac			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8dac			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8dac			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8dac			;avg: 544.81158447265625cc (544+13297/16384) 
8dac			;=============================================================== 
8dac 21 00 00		  ld hl,0 
8daf			.u16a: 
8daf 1a			  ld a,(de) 
8db0 d6 30		  sub 30h 
8db2 fe 0a		  cp 10 
8db4 d0			  ret nc 
8db5 13			  inc de 
8db6 44			  ld b,h 
8db7 4d			  ld c,l 
8db8 29			  add hl,hl 
8db9 29			  add hl,hl 
8dba 09			  add hl,bc 
8dbb 29			  add hl,hl 
8dbc 85			  add a,l 
8dbd 6f			  ld l,a 
8dbe 30 ef		  jr nc,.u16a 
8dc0 24			  inc h 
8dc1 c3 af 8d		  jp .u16a 
8dc4			 
8dc4			 
8dc4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8dc4			 
8dc4			;written by Zeda 
8dc4			;Converts a 16-bit unsigned integer to an ASCII string. 
8dc4			 
8dc4			uitoa_16: 
8dc4			;Input: 
8dc4			;   DE is the number to convert 
8dc4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8dc4			;Output: 
8dc4			;   HL points to the null-terminated ASCII string 
8dc4			;      NOTE: This isn't necessarily the same as the input HL. 
8dc4 d5			  push de 
8dc5 c5			  push bc 
8dc6 f5			  push af 
8dc7 eb			  ex de,hl 
8dc8			 
8dc8 01 f0 d8		  ld bc,-10000 
8dcb 3e 2f		  ld a,'0'-1 
8dcd 3c			  inc a 
8dce 09			  add hl,bc  
8dcf 38 fc		   jr c,$-2 
8dd1 12			  ld (de),a 
8dd2 13			  inc de 
8dd3			 
8dd3 01 e8 03		  ld bc,1000 
8dd6 3e 3a		  ld a,'9'+1 
8dd8 3d			  dec a  
8dd9 09			  add hl,bc  
8dda 30 fc		   jr nc,$-2 
8ddc 12			  ld (de),a 
8ddd 13			  inc de 
8dde			 
8dde 01 9c ff		  ld bc,-100 
8de1 3e 2f		  ld a,'0'-1 
8de3 3c			  inc a  
8de4 09			  add hl,bc  
8de5 38 fc		   jr c,$-2 
8de7 12			  ld (de),a 
8de8 13			  inc de 
8de9			 
8de9 7d			  ld a,l 
8dea 26 3a		  ld h,'9'+1 
8dec 25			  dec h  
8ded c6 0a		  add a,10  
8def 30 fb		   jr nc,$-3 
8df1 c6 30		  add a,'0' 
8df3 eb			  ex de,hl 
8df4 72			  ld (hl),d 
8df5 23			  inc hl 
8df6 77			  ld (hl),a 
8df7 23			  inc hl 
8df8 36 00		  ld (hl),0 
8dfa			 
8dfa			;Now strip the leading zeros 
8dfa 0e fa		  ld c,-6 
8dfc 09			  add hl,bc 
8dfd 3e 30		  ld a,'0' 
8dff 23			  inc hl  
8e00 be			  cp (hl)  
8e01 28 fc		  jr z,$-2 
8e03			 
8e03			;Make sure that the string is non-empty! 
8e03 7e			  ld a,(hl) 
8e04 b7			  or a 
8e05 20 01		  jr nz,.atoub 
8e07 2b			  dec hl 
8e08			.atoub: 
8e08			 
8e08 f1			  pop af 
8e09 c1			  pop bc 
8e0a d1			  pop de 
8e0b c9			  ret 
8e0c			 
8e0c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8e0c			 
8e0c			toUpper: 
8e0c			;A is the char. 
8e0c			;If A is a lowercase letter, this sets it to the matching uppercase 
8e0c			;18cc or 30cc or 41cc 
8e0c			;avg: 26.75cc 
8e0c fe 61		  cp 'a' 
8e0e d8			  ret c 
8e0f fe 7b		  cp 'z'+1 
8e11 d0			  ret nc 
8e12 d6 20		  sub 'a'-'A' 
8e14 c9			  ret 
8e15			 
8e15			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8e15			 
8e15			; String Length 
8e15			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8e15			 
8e15			; Get the length of the null-terminated string starting at $8000 hl 
8e15			;    LD     HL, $8000 
8e15			 
8e15			strlenz: 
8e15			 
8e15 af			    XOR    A               ; Zero is the value we are looking for. 
8e16 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8e17 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8e18			                           ; 65, 536 bytes (the entire addressable memory space). 
8e18 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8e1a			 
8e1a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8e1a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8e1b 6f			    LD     L, A             ; number of bytes 
8e1c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8e1e 2b			    DEC    HL              ; Compensate for null. 
8e1f c9				ret 
8e20			 
8e20			; Get the length of the A terminated string starting at $8000 hl 
8e20			;    LD     HL, $8000 
8e20			 
8e20			strlent: 
8e20			 
8e20			                  ; A is the value we are looking for. 
8e20 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8e22 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8e24			                           ; 65, 536 bytes (the entire addressable memory space). 
8e24 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8e26			 
8e26			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8e26 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8e28 2e 00		    LD     L, 0             ; number of bytes 
8e2a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8e2c 2b			    DEC    HL              ; Compensate for null. 
8e2d c9				ret 
8e2e			 
8e2e			 
8e2e			;Comparing Strings 
8e2e			 
8e2e			;IN    HL     Address of string1. 
8e2e			;      DE     Address of string2. 
8e2e			 
8e2e			; doc given but wrong??? 
8e2e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8e2e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8e2e			; tested 
8e2e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8e2e			 
8e2e			strcmp_old: 
8e2e e5			    PUSH   HL 
8e2f d5			    PUSH   DE 
8e30			 
8e30 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8e31 be			    CP     (HL)            ; (want to minimize work). 
8e32 38 01		    JR     C, Str1IsBigger 
8e34 7e			    LD     A, (HL) 
8e35			 
8e35			Str1IsBigger: 
8e35 4f			    LD     C, A             ; Put length in BC 
8e36 06 00		    LD     B, 0 
8e38 13			    INC    DE              ; Increment pointers to meat of string. 
8e39 23			    INC    HL 
8e3a			 
8e3a			CmpLoop: 
8e3a 1a			    LD     A, (DE)          ; Compare bytes. 
8e3b ed a1		    CPI 
8e3d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8e3f 13			    INC    DE              ; Update pointer. 
8e40 ea 3a 8e		    JP     PE, CmpLoop 
8e43			 
8e43 d1			    POP    DE 
8e44 e1			    POP    HL 
8e45 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8e46 be			    CP     (HL) 
8e47 c9			    RET 
8e48			 
8e48			NoMatch: 
8e48 2b			    DEC    HL 
8e49 be			    CP     (HL)            ; Compare again to affect carry. 
8e4a d1			    POP    DE 
8e4b e1			    POP    HL 
8e4c c9			    RET 
8e4d			 
8e4d			;; test strmp 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str2 
8e4d			;call strcmp 
8e4d			;jr z, .z1 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "NZ1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.z1: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "ZZ1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str1 
8e4d			;call strcmp 
8e4d			;jr z, .z2 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "NZ2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.z2: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "ZZ2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str2 
8e4d			;call strcmp 
8e4d			;jr c, .c1 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "Nc1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.c1: 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "cc1" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			; 
8e4d			;ld de, .str1 
8e4d			;ld hl, .str1 
8e4d			;call strcmp 
8e4d			;jr c, .c2 
8e4d			;;this 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "Nc2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;.c2: 
8e4d			; 
8e4d			;	if DEBUG_FORTH_WORDS 
8e4d			;		DMARK "cc2" 
8e4d			;		CALLMONITOR 
8e4d			;	endif 
8e4d			;	NEXTW 
8e4d			;.str1:   db "string1",0 
8e4d			;.str2:   db "string2",0 
8e4d			 
8e4d			; only care about direct match or not 
8e4d			; hl and de strings 
8e4d			; zero set if the same 
8e4d			 
8e4d			strcmp: 
8e4d 1a				ld a, (de) 
8e4e be				cp (hl) 
8e4f 28 02			jr z, .ssame 
8e51 b7				or a 
8e52 c9				ret 
8e53			 
8e53			.ssame:  
8e53 fe 00			cp 0 
8e55 c8				ret z 
8e56			 
8e56 23				inc hl 
8e57 13				inc de 
8e58 18 f3			jr strcmp 
8e5a				 
8e5a				 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			; eof 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
# End of file firmware_strings.asm
8e5a			include "firmware_memory.asm"   ; malloc and free  
8e5a			 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			.mallocsize: db "Wants malloc >256",0 
8e5a			.mallocasize: db "MALLOC gives >256",0 
8e5a			.malloczero: db "MALLOC gives zero",0 
8e5a			 
8e5a			malloc_guard_zerolen: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a				ld de, 0 
8e5a			        call cmp16 
8e5a				jr nz, .lowalloz 
8e5a			 
8e5a				push hl 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .malloczero 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a			 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				 
8e5a			 
8e5a				CALLMONITOR 
8e5a			.lowalloz: 
8e5a			 
8e5a			 
8e5a				pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			 
8e5a			malloc_guard_entry: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a			 	or a      ;clear carry flag 
8e5a				push hl 
8e5a				ld de, 255 
8e5a				sbc hl, de 
8e5a				jr c, .lowalloc 
8e5a			 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .mallocsize 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a			 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				 
8e5a			 
8e5a				CALLMONITOR 
8e5a				jr .lowdone 
8e5a			.lowalloc: 
8e5a			 
8e5a			 
8e5a				pop hl 
8e5a			.lowdone:	pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			 
8e5a			malloc_guard_exit: 
8e5a				push hl 
8e5a				push de 
8e5a				push af 
8e5a			 
8e5a			 	or a      ;clear carry flag 
8e5a				push hl 
8e5a				ld de, 255 
8e5a				sbc hl, de 
8e5a				jr c, .lowallocx 
8e5a			 
8e5a				push de 
8e5a					ld hl, display_fb0 
8e5a					ld (display_fb_active), hl 
8e5a				call clear_display 
8e5a				ld a, 0 
8e5a				ld de, .mallocasize 
8e5a				call str_at_display 
8e5a				call update_display 
8e5a				call delay1s 
8e5a				call delay1s 
8e5a				ld a, 0 
8e5a				ld (os_view_disable), a 
8e5a				pop de 
8e5a				pop hl 
8e5a			 
8e5a				CALLMONITOR 
8e5a				jr .lowdonex 
8e5a			.lowallocx: 
8e5a			 
8e5a				pop hl 
8e5a			.lowdonex:	pop af 
8e5a				pop de 
8e5a				pop hl 
8e5a			ret 
8e5a			endif 
8e5a			 
8e5a			if MALLOC_2 
8e5a			; Z80 Malloc and Free Functions 
8e5a			 
8e5a			; Malloc Function: 
8e5a			; Input: 
8e5a			;   HL: Size of block to allocate 
8e5a			; Output: 
8e5a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8e5a			 
8e5a			malloc: 
8e5a				 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			call malloc_guard_entry 
8e5a			endif 
8e5a			 
8e5a			 
8e5a			 
8e5a			 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "mal" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			    push af            ; Save AF register 
8e5a			    ld a, l            ; Load low byte of size into A 
8e5a			    or h               ; Check if size is zero 
8e5a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8e5a			 
8e5a			    ; Allocate memory 
8e5a			    ld hl, (heap_start) ; Load start of heap into HL 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma1" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			    call malloc_internal ; Call internal malloc function 
8e5a			    pop af             ; Restore AF register 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret                ; Return 
8e5a			 
8e5a			; Free Function: 
8e5a			; Input: 
8e5a			;   HL: Pointer to memory block to free 
8e5a			; Output: 
8e5a			;   None 
8e5a			 
8e5a			free: 
8e5a			    push af            ; Save AF register 
8e5a			    ld a, l            ; Load low byte of pointer into A 
8e5a			    or h               ; Check if pointer is NULL 
8e5a			    jp z, free_exit    ; If pointer is NULL, exit 
8e5a			 
8e5a			    ; Free memory 
8e5a			    ld hl, (heap_start) ; Load start of heap into HL 
8e5a			    call free_internal  ; Call internal free function 
8e5a			    pop af             ; Restore AF register 
8e5a			    ret                ; Return 
8e5a			 
8e5a			; Internal Malloc Function: 
8e5a			; Input: 
8e5a			;   HL: Size of block to allocate 
8e5a			; Output: 
8e5a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8e5a			 
8e5a			malloc_internal: 
8e5a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8e5a			    add hl, bc         ; Add management overhead to requested size 
8e5a			    ex de, hl          ; Save total size in DE, and keep it in HL 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma2" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			 
8e5a			    ; Search for free memory block 
8e5a			    ld de, (heap_end)  ; Load end of heap into DE 
8e5a			    ld bc, 0           ; Initialize counter 
8e5a			 
8e5a					if DEBUG_FORTH_MALLOC 
8e5a						DMARK "ma2" 
8e5a						CALLMONITOR 
8e5a					endif 
8e5a			malloc_search_loop: 
8e5a			    ; Check if current block is free 
8e5a			    ld a, (hl)         ; Load current block's status (free or used) 
8e5a			    cp 0               ; Compare with zero (free) 
8e5a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8e5a			 
8e5a			    ; Check if current block is large enough 
8e5a			    ld a, (hl+1)       ; Load high byte of block size 
8e5a			    cp l               ; Compare with low byte of requested size 
8e5a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8e5a			 
8e5a			    ld a, (hl+2)       ; Load low byte of block size 
8e5a			    cp h               ; Compare with high byte of requested size 
8e5a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8e5a			 
8e5a			    ; Mark block as used 
8e5a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8e5a			 
8e5a			    ; Calculate remaining space in block 
8e5a			    ld bc, 0           ; Clear BC 
8e5a			    add hl, bc         ; Increment HL to point to start of data block 
8e5a			    add hl, de         ; HL = HL + DE (total size) 
8e5a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8e5a			    add hl, bc         ; Add management overhead to start of data block 
8e5a			 
8e5a			    ; Save pointer to allocated block in HL 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma5" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			 
8e5a			malloc_skip_block_check: 
8e5a			    ; Move to the next block 
8e5a			    ld bc, 3           ; Size of management overhead 
8e5a			    add hl, bc         ; Move to the next block 
8e5a			    inc de             ; Increment counter 
8e5a			 
8e5a			    ; Check if we have reached the end of heap 
8e5a			    ld a, e            ; Load low byte of heap end address 
8e5a			    cp (hl)            ; Compare with low byte of current address 
8e5a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8e5a			    ld a, d            ; Load high byte of heap end address 
8e5a			    cp 0               ; Check if it's zero (end of memory) 
8e5a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8e5a			 
8e5a			    ; If we reached here, allocation failed 
8e5a			    xor a              ; Set result to NULL 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma6" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			malloc_exit: 
8e5a			if DEBUG_FORTH_MALLOC_HIGH 
8e5a						DMARK "ma7" 
8e5a			call malloc_guard_exit 
8e5a			call malloc_guard_zerolen 
8e5a			endif 
8e5a			    ret 
8e5a			 
8e5a			; Internal Free Function: 
8e5a			; Input: 
8e5a			;   HL: Pointer to memory block to free 
8e5a			; Output: 
8e5a			;   None 
8e5a			 
8e5a			free_internal: 
8e5a			    ld de, (heap_start) ; Load start of heap into DE 
8e5a			    ld bc, 0            ; Initialize counter 
8e5a			 
8e5a			free_search_loop: 
8e5a			    ; Check if current block contains the pointer 
8e5a			    ld a, l             ; Load low byte of pointer 
8e5a			    cp (hl+1)           ; Compare with high byte of current block's address 
8e5a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8e5a			    ld a, h             ; Load high byte of pointer 
8e5a			    cp (hl+2)           ; Compare with low byte of current block's address 
8e5a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8e5a			 
8e5a			    ; Mark block as free 
8e5a			    ld (hl), 0          ; Set status byte to indicate free block 
8e5a			    ret                 ; Return 
8e5a			 
8e5a			free_skip_block_check: 
8e5a			    ; Move to the next block 
8e5a			    ld bc, 3            ; Size of management overhead 
8e5a			    add hl, bc          ; Move to the next block 
8e5a			    inc de              ; Increment counter 
8e5a			 
8e5a			    ; Check if we have reached the end of heap 
8e5a			    ld a, e             ; Load low byte of heap end address 
8e5a			    cp (hl)             ; Compare with low byte of current address 
8e5a			    jr nz, free_search_loop  ; If not equal, continue searching 
8e5a			    ld a, d             ; Load high byte of heap end address 
8e5a			    cp 0                ; Check if it's zero (end of memory) 
8e5a			    jr nz, free_search_loop  ; If not zero, continue searching 
8e5a			 
8e5a			    ; If we reached here, pointer is not found in heap 
8e5a			    ret 
8e5a			 
8e5a			free_exit: 
8e5a			    ret                 ; Return 
8e5a			 
8e5a			; Define heap start and end addresses 
8e5a			;heap_start:    .dw 0xC000   ; Start of heap 
8e5a			;heap_end:      .dw 0xE000   ; End of heap 
8e5a			 
8e5a			endif 
8e5a			 
8e5a			 
8e5a			if MALLOC_1 
8e5a			 
8e5a			 
8e5a			 
8e5a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8e5a			 
8e5a			;moved to firmware.asm 
8e5a			;heap_start        .equ  0x9000      ; Starting address of heap 
8e5a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8e5a			 
8e5a			;      .org 0 
8e5a			;      jp    main 
8e5a			 
8e5a			 
8e5a			;      .org  0x100 
8e5a			;main: 
8e5a			;      ld    HL, 0x8100 
8e5a			;      ld    SP, HL 
8e5a			; 
8e5a			;      call  heap_init 
8e5a			; 
8e5a			;      ; Make some allocations 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9004 
8e5a			; 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9014 
8e5a			; 
8e5a			;      ld    HL, 12 
8e5a			;      call  malloc            ; Allocates 0x9024 
8e5a			; 
8e5a			;      ; Free some allocations 
8e5a			;      ld    HL, 0x9014 
8e5a			;      call  free 
8e5a			; 
8e5a			;      ld    HL, 0x9004 
8e5a			;      call  free 
8e5a			; 
8e5a			;      ld    HL, 0x9024 
8e5a			;      call  free 
8e5a			; 
8e5a			; 
8e5a			;      halt 
8e5a			 
8e5a			 
8e5a			;------------------------------------------------------------------------------ 
8e5a			;     heap_init                                                               : 
8e5a			;                                                                             : 
8e5a			; Description                                                                 : 
8e5a			;     Initialise the heap and make it ready for malloc and free operations.   : 
8e5a			;                                                                             : 
8e5a			;     The heap is maintained as a linked list, starting with an initial       : 
8e5a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8e5a			;     the first free block in the heap. Each block then points to the next    : 
8e5a			;     free block within the heap, and the free list ends at the first block   : 
8e5a			;     with a null pointer to the next free block.                             : 
8e5a			;                                                                             : 
8e5a			; Parameters                                                                  : 
8e5a			;     Inputs are compile-time only. Two defines which specify the starting    : 
8e5a			;     address of the heap and its size are required, along with a memory      : 
8e5a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8e5a			;     principally stores a pointer to the first free block in the heap.       : 
8e5a			;                                                                             : 
8e5a			; Returns                                                                     : 
8e5a			;     Nothing                                                                 : 
8e5a			;------------------------------------------------------------------------------ 
8e5a			heap_init: 
8e5a e5			      push  HL 
8e5b			 
8e5b			      ; Initialise free list struct 
8e5b 21 b6 d4		      ld    HL, heap_start 
8e5e 22 b1 d4		      ld    (free_list), HL 
8e61 21 00 00		      ld    HL, 0 
8e64 22 b3 d4		      ld    (free_list+2), HL 
8e67			 
8e67			      ; Insert first free block at bottom of heap, consumes entire heap 
8e67 21 65 e3		      ld    HL, heap_start+heap_size-4 
8e6a 22 b6 d4		      ld    (heap_start), HL        ; Next block (end of free list) 
8e6d 21 af 0e		      ld    HL, heap_size-4 
8e70 22 b8 d4		      ld    (heap_start+2), HL      ; Block size 
8e73			 
8e73			      ; Insert end of free list block at top of heap - two null words will 
8e73			      ; terminate the free list 
8e73 21 00 00		      ld    HL, 0 
8e76 22 67 e3		      ld    (heap_start+heap_size-2), HL 
8e79 22 65 e3		      ld    (heap_start+heap_size-4), HL 
8e7c			 
8e7c e1			      pop   HL 
8e7d			 
8e7d c9			      ret 
8e7e			 
8e7e			 
8e7e			;------------------------------------------------------------------------------ 
8e7e			;     malloc                                                                  : 
8e7e			;                                                                             : 
8e7e			; Description                                                                 : 
8e7e			;     Allocates the wanted space from the heap and returns the address of the : 
8e7e			;     first useable byte of the allocation.                                   : 
8e7e			;                                                                             : 
8e7e			;     Allocations can happen in one of two ways:                              : 
8e7e			;                                                                             : 
8e7e			;     1. A free block may be found which is the exact size wanted. In this    : 
8e7e			;        case the block is removed from the free list and retuedn to the      : 
8e7e			;        caller.                                                              : 
8e7e			;     2. A free block may be found which is larger than the size wanted. In   : 
8e7e			;        this case, the larger block is split into two. The first portion of  : 
8e7e			;        this block will become the requested space by the malloc call and    : 
8e7e			;        is returned to the caller. The second portion becomes a new free     : 
8e7e			;        block, and the free list is adjusted to maintain continuity via this : 
8e7e			;        newly created block.                                                 : 
8e7e			;                                                                             : 
8e7e			;     malloc does not set any initial value in the allocated space, the       : 
8e7e			;     caller is required to do this as required.                              : 
8e7e			;                                                                             : 
8e7e			;     This implementation of malloc uses the stack exclusively, and is        : 
8e7e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8e7e			;     advisable to disable interrupts before calling malloc, and recommended  : 
8e7e			;     to avoid the use of malloc inside ISRs in general.                      : 
8e7e			;                                                                             : 
8e7e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8e7e			;                                                                             : 
8e7e			; Parameters                                                                  : 
8e7e			;     HL  Number of bytes wanted                                              : 
8e7e			;                                                                             : 
8e7e			; Returns                                                                     : 
8e7e			;     HL  Address of the first useable byte of the allocation                 : 
8e7e			;                                                                             : 
8e7e			; Flags                                                                       : 
8e7e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8e7e			;                                                                             : 
8e7e			; Stack frame                                                                 : 
8e7e			;       |             |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     BC      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     DE      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |     IX      |                                                       : 
8e7e			;       +-------------+                                                       : 
8e7e			;       |  prev_free  |                                                       : 
8e7e			;   +4  +-------------+                                                       : 
8e7e			;       |  this_free  |                                                       : 
8e7e			;   +2  +-------------+                                                       : 
8e7e			;       |  next_free  |                                                       : 
8e7e			;   +0  +-------------+                                                       : 
8e7e			;       |             |                                                       : 
8e7e			;                                                                             : 
8e7e			;------------------------------------------------------------------------------ 
8e7e			 
8e7e			 
8e7e			;malloc: 
8e7e			; 
8e7e			;	SAVESP ON 1 
8e7e			; 
8e7e			;	call malloc_code 
8e7e			; 
8e7e			;	CHECKSP ON 1 
8e7e			;	ret 
8e7e			 
8e7e			 
8e7e			malloc: 
8e7e c5			      push  BC 
8e7f d5			      push  DE 
8e80 dd e5		      push  IX 
8e82			if DEBUG_FORTH_MALLOC_HIGH 
8e82			call malloc_guard_entry 
8e82			endif 
8e82			 
8e82					if DEBUG_FORTH_MALLOC 
8e82						DMARK "mal" 
8e82						CALLMONITOR 
8e82					endif 
8e82 7c			      ld    A, H                    ; Exit if no space requested 
8e83 b5			      or    L 
8e84 ca 43 8f		      jp    Z, malloc_early_exit 
8e87			 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			; 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			;inc hl 
8e87			 
8e87			 
8e87			 
8e87			 
8e87					if DEBUG_FORTH_MALLOC 
8e87						DMARK "maA" 
8e87						CALLMONITOR 
8e87					endif 
8e87			      ; Set up stack frame 
8e87 eb			      ex    DE, HL 
8e88 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8e8b 39			      add   HL, SP 
8e8c f9			      ld    SP, HL 
8e8d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8e91 dd 39		      add   IX, SP 
8e93			 
8e93			      ; Setup initial state 
8e93 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8e96 19			      add   HL, DE 
8e97			 
8e97 44			      ld    B, H                    ; Move want to BC 
8e98 4d			      ld    C, L 
8e99			 
8e99 21 b1 d4		      ld    HL, free_list           ; Store prev_free ptr to stack 
8e9c dd 75 04		      ld    (IX+4), L 
8e9f dd 74 05		      ld    (IX+5), H 
8ea2			 
8ea2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8ea3 23			      inc   HL 
8ea4 56			      ld    D, (HL) 
8ea5 dd 73 02		      ld    (IX+2), E 
8ea8 dd 72 03		      ld    (IX+3), D 
8eab eb			      ex    DE, HL                  ; this_free ptr into HL 
8eac			 
8eac					if DEBUG_FORTH_MALLOC 
8eac						DMARK "maB" 
8eac						CALLMONITOR 
8eac					endif 
8eac			      ; Loop through free block list to find some space 
8eac			malloc_find_space: 
8eac 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8ead 23			      inc   HL 
8eae 56			      ld    D, (HL) 
8eaf			 
8eaf 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8eb0 b3			      or    E 
8eb1 ca 3d 8f		      jp    Z, malloc_no_space 
8eb4			 
8eb4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8eb7 dd 72 01		      ld    (IX+1), D 
8eba			 
8eba			      ; Does this block have enough space to make the allocation? 
8eba 23			      inc   HL                      ; Load free block size into DE 
8ebb 5e			      ld    E, (HL) 
8ebc 23			      inc   HL 
8ebd 56			      ld    D, (HL) 
8ebe			 
8ebe eb			      ex    DE, HL                  ; Check size of block against want 
8ebf b7			      or    A                       ; Ensure carry flag clear 
8ec0 ed 42		      sbc   HL, BC 
8ec2 e5			      push  HL                      ; Store the result for later (new block size) 
8ec3			 
8ec3 ca 12 8f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8ec6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8ec8			 
8ec8			      ; this_free block is not big enough, setup ptrs to test next free block 
8ec8 e1			      pop   HL                      ; Discard previous result 
8ec9			 
8ec9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8ecc dd 66 03		      ld    H, (IX+3) 
8ecf dd 75 04		      ld    (IX+4), L 
8ed2 dd 74 05		      ld    (IX+5), H 
8ed5			 
8ed5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8ed8 dd 66 01		      ld    H, (IX+1) 
8edb dd 75 02		      ld    (IX+2), L 
8ede dd 74 03		      ld    (IX+3), H 
8ee1			 
8ee1					if DEBUG_FORTH_MALLOC 
8ee1						DMARK "MA>" 
8ee1						CALLMONITOR 
8ee1					endif 
8ee1 18 c9		      jr    malloc_find_space 
8ee3			 
8ee3			      ; split a bigger block into two - requested size and remaining size 
8ee3			malloc_alloc_split: 
8ee3					if DEBUG_FORTH_MALLOC 
8ee3						DMARK "MAs" 
8ee3						CALLMONITOR 
8ee3					endif 
8ee3 eb			      ex    DE, HL                  ; Calculate address of new free block 
8ee4 2b			      dec   HL 
8ee5 2b			      dec   HL 
8ee6 2b			      dec   HL 
8ee7 09			      add   HL, BC 
8ee8			 
8ee8			      ; Create a new block and point it at next_free 
8ee8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8eeb dd 56 01		      ld    D, (IX+1) 
8eee			 
8eee 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8eef 23			      inc   HL 
8ef0 72			      ld    (HL), D 
8ef1			 
8ef1 d1			      pop   DE                      ; Store size of new block into new block 
8ef2 23			      inc   HL 
8ef3 73			      ld    (HL), E 
8ef4 23			      inc   HL 
8ef5 72			      ld    (HL), D 
8ef6			 
8ef6			      ; Update this_free ptr to point to new block 
8ef6 2b			      dec   HL 
8ef7 2b			      dec   HL 
8ef8 2b			      dec   HL 
8ef9			 
8ef9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8efc dd 56 03		      ld    D, (IX+3) 
8eff			 
8eff dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8f02 dd 74 03		      ld    (IX+3), H 
8f05			 
8f05			      ; Modify this_free block to be allocation 
8f05 eb			      ex    DE, HL 
8f06 af			      xor   A                       ; Null the next block ptr of allocated block 
8f07 77			      ld    (HL), A 
8f08 23			      inc   HL 
8f09 77			      ld    (HL), A 
8f0a			 
8f0a 23			      inc   HL                      ; Store want size into allocated block 
8f0b 71			      ld    (HL), C 
8f0c 23			      inc   HL 
8f0d 70			      ld    (HL), B 
8f0e 23			      inc   HL 
8f0f e5			      push  HL                      ; Address of allocation to return 
8f10			 
8f10 18 19		      jr    malloc_update_links 
8f12			 
8f12			malloc_alloc_fit: 
8f12 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8f13			 
8f13					if DEBUG_FORTH_MALLOC 
8f13						DMARK "MAf" 
8f13						CALLMONITOR 
8f13					endif 
8f13			      ; Modify this_free block to be allocation 
8f13 eb			      ex    DE, HL 
8f14 2b			      dec   HL 
8f15 2b			      dec   HL 
8f16 2b			      dec   HL 
8f17			 
8f17 af			      xor   A                       ; Null the next block ptr of allocated block 
8f18 77			      ld    (HL), A 
8f19 23			      inc   HL 
8f1a 77			      ld    (HL), A 
8f1b			 
8f1b 23			      inc   HL                      ; Store address of allocation to return 
8f1c 23			      inc   HL 
8f1d 23			      inc   HL 
8f1e e5			      push  HL 
8f1f			 
8f1f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8f1f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
8f22 dd 66 01		      ld    H, (IX+1) 
8f25			 
8f25 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
8f28 dd 74 03		      ld    (IX+3), H 
8f2b			 
8f2b			 
8f2b			malloc_update_links: 
8f2b			      ; Update prev_free ptr to point to this_free 
8f2b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
8f2e dd 66 05		      ld    H, (IX+5) 
8f31			 
8f31 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
8f34 dd 56 03		      ld    D, (IX+3) 
8f37			 
8f37 73			      ld    (HL), E                 ; this_free ptr into prev_free 
8f38 23			      inc   HL 
8f39 72			      ld    (HL), D 
8f3a			 
8f3a					if DEBUG_FORTH_MALLOC 
8f3a						DMARK "Mul" 
8f3a						CALLMONITOR 
8f3a					endif 
8f3a			      ; Clear the Z flag to indicate successful allocation 
8f3a 7a			      ld    A, D 
8f3b b3			      or    E 
8f3c			 
8f3c d1			      pop   DE                      ; Address of allocation 
8f3d					if DEBUG_FORTH_MALLOC 
8f3d						DMARK "MAu" 
8f3d						CALLMONITOR 
8f3d					endif 
8f3d			 
8f3d			malloc_no_space: 
8f3d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
8f40 39			      add   HL, SP 
8f41 f9			      ld    SP, HL 
8f42			 
8f42 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
8f43					if DEBUG_FORTH_MALLOC 
8f43						DMARK "MAN" 
8f43						CALLMONITOR 
8f43					endif 
8f43			 
8f43			malloc_early_exit: 
8f43					if DEBUG_FORTH_MALLOC 
8f43						DMARK "MAx" 
8f43						CALLMONITOR 
8f43					endif 
8f43 dd e1		      pop   IX 
8f45 d1			      pop   DE 
8f46 c1			      pop   BC 
8f47			 
8f47			if DEBUG_FORTH_MALLOC_HIGH 
8f47			call malloc_guard_exit 
8f47			call malloc_guard_zerolen 
8f47			endif 
8f47 c9			      ret 
8f48			 
8f48			 
8f48			;------------------------------------------------------------------------------ 
8f48			;     free                                                                    : 
8f48			;                                                                             : 
8f48			; Description                                                                 : 
8f48			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8f48			;     returned by malloc, otherwise the behaviour is undefined.               : 
8f48			;                                                                             : 
8f48			;     Where possible, directly adjacent free blocks will be merged together   : 
8f48			;     into larger blocks to help ensure that the heap does not become         : 
8f48			;     excessively fragmented.                                                 : 
8f48			;                                                                             : 
8f48			;     free does not clear or set any other value into the freed space, and    : 
8f48			;     therefore its contents may be visible through subsequent malloc's. The  : 
8f48			;     caller should clear the freed space as required.                        : 
8f48			;                                                                             : 
8f48			;     This implementation of free uses the stack exclusively, and is          : 
8f48			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f48			;     advisable to disable interrupts before calling free, and recommended    : 
8f48			;     to avoid the use of free inside ISRs in general.                        : 
8f48			;                                                                             : 
8f48			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f48			;                                                                             : 
8f48			; Parameters                                                                  : 
8f48			;     HL  Pointer to address of first byte of allocation to be freed          : 
8f48			;                                                                             : 
8f48			; Returns                                                                     : 
8f48			;     Nothing                                                                 : 
8f48			;                                                                             : 
8f48			; Stack frame                                                                 : 
8f48			;       |             |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     BC      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     DE      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |     IX      |                                                       : 
8f48			;       +-------------+                                                       : 
8f48			;       |  prev_free  |                                                       : 
8f48			;   +2  +-------------+                                                       : 
8f48			;       |  next_free  |                                                       : 
8f48			;   +0  +-------------+                                                       : 
8f48			;       |             |                                                       : 
8f48			;                                                                             : 
8f48			;------------------------------------------------------------------------------ 
8f48			free: 
8f48 c5			      push  BC 
8f49 d5			      push  DE 
8f4a dd e5		      push  IX 
8f4c			 
8f4c 7c			      ld    A, H                    ; Exit if ptr is null 
8f4d b5			      or    L 
8f4e ca 12 90		      jp    Z, free_early_exit 
8f51			 
8f51			      ; Set up stack frame 
8f51 eb			      ex    DE, HL 
8f52 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
8f55 39			      add   HL, SP 
8f56 f9			      ld    SP, HL 
8f57 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f5b dd 39		      add   IX, SP 
8f5d			 
8f5d			      ; The address in HL points to the start of the useable allocated space, 
8f5d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
8f5d			      ; address of the block itself. 
8f5d eb			      ex    DE, HL 
8f5e 11 fc ff		      ld    DE, -4 
8f61 19			      add   HL, DE 
8f62			 
8f62			      ; An allocated block must have a null next block pointer in it 
8f62 7e			      ld    A, (HL) 
8f63 23			      inc   HL 
8f64 b6			      or    (HL) 
8f65 c2 0d 90		      jp    NZ, free_done 
8f68			 
8f68 2b			      dec   HL 
8f69			 
8f69 44			      ld    B, H                    ; Copy HL to BC 
8f6a 4d			      ld    C, L 
8f6b			 
8f6b			      ; Loop through the free list to find the first block with an address 
8f6b			      ; higher than the block being freed 
8f6b 21 b1 d4		      ld    HL, free_list 
8f6e			 
8f6e			free_find_higher_block: 
8f6e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
8f6f 23			      inc   HL 
8f70 56			      ld    D, (HL) 
8f71 2b			      dec   HL 
8f72			 
8f72 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
8f75 dd 72 01		      ld    (IX+1), D 
8f78 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
8f7b dd 74 03		      ld    (IX+3), H 
8f7e			 
8f7e 78			      ld    A, B                    ; Check if DE is greater than BC 
8f7f ba			      cp    D                       ; Compare MSB first 
8f80 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
8f82 30 04		      jr    NC, free_find_higher_block_skip 
8f84 79			      ld    A, C 
8f85 bb			      cp    E                       ; Then compare LSB 
8f86 38 08		      jr    C, free_found_higher_block 
8f88			 
8f88			free_find_higher_block_skip: 
8f88 7a			      ld    A, D                    ; Reached the end of the free list? 
8f89 b3			      or    E 
8f8a ca 0d 90		      jp    Z, free_done 
8f8d			 
8f8d eb			      ex    DE, HL 
8f8e			 
8f8e 18 de		      jr    free_find_higher_block 
8f90			 
8f90			free_found_higher_block: 
8f90			      ; Insert freed block between prev and next free blocks 
8f90 71			      ld    (HL), C                 ; Point prev free block to freed block 
8f91 23			      inc   HL 
8f92 70			      ld    (HL), B 
8f93			 
8f93 60			      ld    H, B                    ; Point freed block at next free block 
8f94 69			      ld    L, C 
8f95 73			      ld    (HL), E 
8f96 23			      inc   HL 
8f97 72			      ld    (HL), D 
8f98			 
8f98			      ; Check if the freed block is adjacent to the next free block 
8f98 23			      inc   HL                      ; Load size of freed block into HL 
8f99 5e			      ld    E, (HL) 
8f9a 23			      inc   HL 
8f9b 56			      ld    D, (HL) 
8f9c eb			      ex    DE, HL 
8f9d			 
8f9d 09			      add   HL, BC                  ; Add addr of freed block and its size 
8f9e			 
8f9e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
8fa1 dd 56 01		      ld    D, (IX+1) 
8fa4			 
8fa4 b7			      or    A                       ; Clear the carry flag 
8fa5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
8fa7 20 22		      jr    NZ, free_check_adjacent_to_prev 
8fa9			 
8fa9			      ; Freed block is adjacent to next, merge into one bigger block 
8fa9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
8faa 5e			      ld    E, (HL) 
8fab 23			      inc   HL 
8fac 56			      ld    D, (HL) 
8fad e5			      push  HL                      ; Save ptr to next block for later 
8fae			 
8fae 60			      ld    H, B                    ; Store ptr from next block into freed block 
8faf 69			      ld    L, C 
8fb0 73			      ld    (HL), E 
8fb1 23			      inc   HL 
8fb2 72			      ld    (HL), D 
8fb3			 
8fb3 e1			      pop   HL                      ; Restore ptr to next block 
8fb4 23			      inc   HL                      ; Load size of next block into DE 
8fb5 5e			      ld    E, (HL) 
8fb6 23			      inc   HL 
8fb7 56			      ld    D, (HL) 
8fb8 d5			      push  DE                      ; Save next block size for later 
8fb9			 
8fb9 60			      ld    H, B                    ; Load size of freed block into HL 
8fba 69			      ld    L, C 
8fbb 23			      inc   HL 
8fbc 23			      inc   HL 
8fbd 5e			      ld    E, (HL) 
8fbe 23			      inc   HL 
8fbf 56			      ld    D, (HL) 
8fc0 eb			      ex    DE, HL 
8fc1			 
8fc1 d1			      pop   DE                      ; Restore size of next block 
8fc2 19			      add   HL, DE                  ; Add sizes of both blocks 
8fc3 eb			      ex    DE, HL 
8fc4			 
8fc4 60			      ld    H, B                    ; Store new bigger size into freed block 
8fc5 69			      ld    L, C 
8fc6 23			      inc   HL 
8fc7 23			      inc   HL 
8fc8 73			      ld    (HL), E 
8fc9 23			      inc   HL 
8fca 72			      ld    (HL), D 
8fcb			 
8fcb			free_check_adjacent_to_prev: 
8fcb			      ; Check if the freed block is adjacent to the prev free block 
8fcb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
8fce dd 66 03		      ld    H, (IX+3) 
8fd1			 
8fd1 23			      inc   HL                      ; Size of prev free block into DE 
8fd2 23			      inc   HL 
8fd3 5e			      ld    E, (HL) 
8fd4 23			      inc   HL 
8fd5 56			      ld    D, (HL) 
8fd6 2b			      dec   HL 
8fd7 2b			      dec   HL 
8fd8 2b			      dec   HL 
8fd9			 
8fd9 19			      add   HL, DE                  ; Add prev block addr and size 
8fda			 
8fda b7			      or    A                       ; Clear the carry flag 
8fdb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
8fdd 20 2e		      jr    NZ, free_done 
8fdf			 
8fdf			      ; Freed block is adjacent to prev, merge into one bigger block 
8fdf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
8fe0 69			      ld    L, C 
8fe1 5e			      ld    E, (HL) 
8fe2 23			      inc   HL 
8fe3 56			      ld    D, (HL) 
8fe4 e5			      push  HL                      ; Save freed block ptr for later 
8fe5			 
8fe5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
8fe8 dd 66 03		      ld    H, (IX+3) 
8feb 73			      ld    (HL), E 
8fec 23			      inc   HL 
8fed 72			      ld    (HL), D 
8fee			 
8fee e1			      pop   HL                      ; Restore freed block ptr 
8fef 23			      inc   HL                      ; Load size of freed block into DE 
8ff0 5e			      ld    E, (HL) 
8ff1 23			      inc   HL 
8ff2 56			      ld    D, (HL) 
8ff3 d5			      push  DE                      ; Save freed block size for later 
8ff4			 
8ff4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
8ff7 dd 66 03		      ld    H, (IX+3) 
8ffa 23			      inc   HL 
8ffb 23			      inc   HL 
8ffc 5e			      ld    E, (HL) 
8ffd 23			      inc   HL 
8ffe 56			      ld    D, (HL) 
8fff			 
8fff e1			      pop   HL                      ; Add sizes of both blocks 
9000 19			      add   HL, DE 
9001 eb			      ex    DE, HL 
9002			 
9002 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9005 dd 66 03		      ld    H, (IX+3) 
9008 23			      inc   HL 
9009 23			      inc   HL 
900a 73			      ld    (HL), E 
900b 23			      inc   HL 
900c 72			      ld    (HL), D 
900d			 
900d			free_done: 
900d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9010 39			      add   HL, SP 
9011 f9			      ld    SP, HL 
9012			 
9012			free_early_exit: 
9012 dd e1		      pop   IX 
9014 d1			      pop   DE 
9015 c1			      pop   BC 
9016			 
9016 c9			      ret 
9017			 
9017			; moved to firmware.asm 
9017			; 
9017			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9017			;                  .dw   0 
9017			 
9017			 
9017			endif 
9017			 
9017			 
9017			if MALLOC_3 
9017			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9017			;heap_start        .equ  0x9000      ; Starting address of heap 
9017			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9017			; 
9017			 ;     .org 0 
9017			  ;    jp    main 
9017			; 
9017			; 
9017			 ;     .org  0x100 
9017			;main: 
9017			 ;     ld    HL, 0x8100 
9017			  ;    ld    SP, HL 
9017			; 
9017			;      call  heap_init 
9017			 
9017			      ; Make some allocations 
9017			;      ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9004 
9017			; 
9017			 ;     ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9014 
9017			 
9017			;      ld    HL, 12 
9017			;      call  malloc            ; Allocates 0x9024 
9017			 
9017			      ; Free some allocations 
9017			;      ld    HL, 0x9014 
9017			;      call  free 
9017			 
9017			;      ld    HL, 0x9004 
9017			;      call  free 
9017			; 
9017			;      ld    HL, 0x9024 
9017			;      call  free 
9017			 
9017			 
9017			 ;     halt 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     heap_init                                                               : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Initialise the heap and make it ready for malloc and free operations.   : 
9017			;                                                                             : 
9017			;     The heap is maintained as a linked list, starting with an initial       : 
9017			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9017			;     the first free block in the heap. Each block then points to the next    : 
9017			;     free block within the heap, and the free list ends at the first block   : 
9017			;     with a null pointer to the next free block.                             : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     Inputs are compile-time only. Two defines which specify the starting    : 
9017			;     address of the heap and its size are required, along with a memory      : 
9017			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9017			;     principally stores a pointer to the first free block in the heap.       : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     Nothing                                                                 : 
9017			;------------------------------------------------------------------------------ 
9017			heap_init: 
9017			      push  HL 
9017			 
9017			      ; Initialise free list struct 
9017			      ld    HL, heap_start 
9017			      ld    (free_list), HL 
9017			      ld    HL, 0 
9017			      ld    (free_list+2), HL 
9017			 
9017			      ; Insert first free block at bottom of heap, consumes entire heap 
9017			      ld    HL, heap_start+heap_size-4 
9017			      ld    (heap_start), HL        ; Next block (end of free list) 
9017			      ld    HL, heap_size-4 
9017			      ld    (heap_start+2), HL      ; Block size 
9017			 
9017			      ; Insert end of free list block at top of heap - two null words will 
9017			      ; terminate the free list 
9017			      ld    HL, 0 
9017			      ld    (heap_start+heap_size-2), HL 
9017			      ld    (heap_start+heap_size-4), HL 
9017			 
9017			      pop   HL 
9017			 
9017			      ret 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     malloc                                                                  : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Allocates the wanted space from the heap and returns the address of the : 
9017			;     first useable byte of the allocation.                                   : 
9017			;                                                                             : 
9017			;     Allocations can happen in one of two ways:                              : 
9017			;                                                                             : 
9017			;     1. A free block may be found which is the exact size wanted. In this    : 
9017			;        case the block is removed from the free list and retuedn to the      : 
9017			;        caller.                                                              : 
9017			;     2. A free block may be found which is larger than the size wanted. In   : 
9017			;        this case, the larger block is split into two. The first portion of  : 
9017			;        this block will become the requested space by the malloc call and    : 
9017			;        is returned to the caller. The second portion becomes a new free     : 
9017			;        block, and the free list is adjusted to maintain continuity via this : 
9017			;        newly created block.                                                 : 
9017			;                                                                             : 
9017			;     malloc does not set any initial value in the allocated space, the       : 
9017			;     caller is required to do this as required.                              : 
9017			;                                                                             : 
9017			;     This implementation of malloc uses the stack exclusively, and is        : 
9017			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9017			;     advisable to disable interrupts before calling malloc, and recommended  : 
9017			;     to avoid the use of malloc inside ISRs in general.                      : 
9017			;                                                                             : 
9017			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     HL  Number of bytes wanted                                              : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     HL  Address of the first useable byte of the allocation                 : 
9017			;                                                                             : 
9017			; Flags                                                                       : 
9017			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9017			;                                                                             : 
9017			; Stack frame                                                                 : 
9017			;       |             |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     BC      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     DE      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     IX      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |  prev_free  |                                                       : 
9017			;   +4  +-------------+                                                       : 
9017			;       |  this_free  |                                                       : 
9017			;   +2  +-------------+                                                       : 
9017			;       |  next_free  |                                                       : 
9017			;   +0  +-------------+                                                       : 
9017			;       |             |                                                       : 
9017			;                                                                             : 
9017			;------------------------------------------------------------------------------ 
9017			malloc: 
9017			      push  BC 
9017			      push  DE 
9017			      push  IX 
9017			 
9017			      ld    A, H                    ; Exit if no space requested 
9017			      or    L 
9017			      jp    Z, malloc_early_exit 
9017			 
9017			      ; Set up stack frame 
9017			      ex    DE, HL 
9017			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			      ld    IX, 0                   ; Use IX as a frame pointer 
9017			      add   IX, SP 
9017			 
9017			      ; Setup initial state 
9017			      ld    HL, 4                   ; want must also include space used by block struct 
9017			      add   HL, DE 
9017			 
9017			      ld    B, H                    ; Move want to BC 
9017			      ld    C, L 
9017			 
9017			      ld    HL, free_list           ; Store prev_free ptr to stack 
9017			      ld    (IX+4), L 
9017			      ld    (IX+5), H 
9017			 
9017			      ld    E, (HL)                 ; Store this_free ptr to stack 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ld    (IX+2), E 
9017			      ld    (IX+3), D 
9017			      ex    DE, HL                  ; this_free ptr into HL 
9017			 
9017			      ; Loop through free block list to find some space 
9017			malloc_find_space: 
9017			      ld    E, (HL)                 ; Load next_free ptr into DE 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9017			      or    E 
9017			      jp    Z, malloc_no_space 
9017			 
9017			      ld    (IX+0), E               ; Store next_free ptr to stack 
9017			      ld    (IX+1), D 
9017			 
9017			      ; Does this block have enough space to make the allocation? 
9017			      inc   HL                      ; Load free block size into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      ex    DE, HL                  ; Check size of block against want 
9017			      or    A                       ; Ensure carry flag clear 
9017			      sbc   HL, BC 
9017			      push  HL                      ; Store the result for later (new block size) 
9017			 
9017			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9017			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9017			 
9017			      ; this_free block is not big enough, setup ptrs to test next free block 
9017			      pop   HL                      ; Discard previous result 
9017			 
9017			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9017			      ld    H, (IX+3) 
9017			      ld    (IX+4), L 
9017			      ld    (IX+5), H 
9017			 
9017			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9017			      ld    H, (IX+1) 
9017			      ld    (IX+2), L 
9017			      ld    (IX+3), H 
9017			 
9017			      jr    malloc_find_space 
9017			 
9017			      ; split a bigger block into two - requested size and remaining size 
9017			malloc_alloc_split: 
9017			      ex    DE, HL                  ; Calculate address of new free block 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			      add   HL, BC 
9017			 
9017			      ; Create a new block and point it at next_free 
9017			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9017			      ld    D, (IX+1) 
9017			 
9017			      ld    (HL), E                 ; Store next_free ptr into new block 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   DE                      ; Store size of new block into new block 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Update this_free ptr to point to new block 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9017			      ld    D, (IX+3) 
9017			 
9017			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9017			      ld    (IX+3), H 
9017			 
9017			      ; Modify this_free block to be allocation 
9017			      ex    DE, HL 
9017			      xor   A                       ; Null the next block ptr of allocated block 
9017			      ld    (HL), A 
9017			      inc   HL 
9017			      ld    (HL), A 
9017			 
9017			      inc   HL                      ; Store want size into allocated block 
9017			      ld    (HL), C 
9017			      inc   HL 
9017			      ld    (HL), B 
9017			      inc   HL 
9017			      push  HL                      ; Address of allocation to return 
9017			 
9017			      jr    malloc_update_links 
9017			 
9017			malloc_alloc_fit: 
9017			      pop   HL                      ; Dont need new block size, want is exact fit 
9017			 
9017			      ; Modify this_free block to be allocation 
9017			      ex    DE, HL 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      xor   A                       ; Null the next block ptr of allocated block 
9017			      ld    (HL), A 
9017			      inc   HL 
9017			      ld    (HL), A 
9017			 
9017			      inc   HL                      ; Store address of allocation to return 
9017			      inc   HL 
9017			      inc   HL 
9017			      push  HL 
9017			 
9017			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9017			      ld    L, (IX+0)               ; next_free to HL 
9017			      ld    H, (IX+1) 
9017			 
9017			      ld    (IX+2), L               ; HL to this_free 
9017			      ld    (IX+3), H 
9017			 
9017			 
9017			malloc_update_links: 
9017			      ; Update prev_free ptr to point to this_free 
9017			      ld    L, (IX+4)               ; prev_free ptr to HL 
9017			      ld    H, (IX+5) 
9017			 
9017			      ld    E, (IX+2)               ; this_free ptr to DE 
9017			      ld    D, (IX+3) 
9017			 
9017			      ld    (HL), E                 ; this_free ptr into prev_free 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Clear the Z flag to indicate successful allocation 
9017			      ld    A, D 
9017			      or    E 
9017			 
9017			      pop   DE                      ; Address of allocation 
9017			 
9017			malloc_no_space: 
9017			      ld    HL, 6                   ; Clean up stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			 
9017			      ex    DE, HL                  ; Alloc addr into HL for return 
9017			 
9017			malloc_early_exit: 
9017			      pop   IX 
9017			      pop   DE 
9017			      pop   BC 
9017			 
9017			      ret 
9017			 
9017			 
9017			;------------------------------------------------------------------------------ 
9017			;     free                                                                    : 
9017			;                                                                             : 
9017			; Description                                                                 : 
9017			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9017			;     returned by malloc, otherwise the behaviour is undefined.               : 
9017			;                                                                             : 
9017			;     Where possible, directly adjacent free blocks will be merged together   : 
9017			;     into larger blocks to help ensure that the heap does not become         : 
9017			;     excessively fragmented.                                                 : 
9017			;                                                                             : 
9017			;     free does not clear or set any other value into the freed space, and    : 
9017			;     therefore its contents may be visible through subsequent malloc's. The  : 
9017			;     caller should clear the freed space as required.                        : 
9017			;                                                                             : 
9017			;     This implementation of free uses the stack exclusively, and is          : 
9017			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9017			;     advisable to disable interrupts before calling free, and recommended    : 
9017			;     to avoid the use of free inside ISRs in general.                        : 
9017			;                                                                             : 
9017			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9017			;                                                                             : 
9017			; Parameters                                                                  : 
9017			;     HL  Pointer to address of first byte of allocation to be freed          : 
9017			;                                                                             : 
9017			; Returns                                                                     : 
9017			;     Nothing                                                                 : 
9017			;                                                                             : 
9017			; Stack frame                                                                 : 
9017			;       |             |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     BC      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     DE      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |     IX      |                                                       : 
9017			;       +-------------+                                                       : 
9017			;       |  prev_free  |                                                       : 
9017			;   +2  +-------------+                                                       : 
9017			;       |  next_free  |                                                       : 
9017			;   +0  +-------------+                                                       : 
9017			;       |             |                                                       : 
9017			;                                                                             : 
9017			;------------------------------------------------------------------------------ 
9017			free: 
9017			      push  BC 
9017			      push  DE 
9017			      push  IX 
9017			 
9017			      ld    A, H                    ; Exit if ptr is null 
9017			      or    L 
9017			      jp    Z, free_early_exit 
9017			 
9017			      ; Set up stack frame 
9017			      ex    DE, HL 
9017			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			      ld    IX, 0                   ; Use IX as a frame pointer 
9017			      add   IX, SP 
9017			 
9017			      ; The address in HL points to the start of the useable allocated space, 
9017			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9017			      ; address of the block itself. 
9017			      ex    DE, HL 
9017			      ld    DE, -4 
9017			      add   HL, DE 
9017			 
9017			      ; An allocated block must have a null next block pointer in it 
9017			      ld    A, (HL) 
9017			      inc   HL 
9017			      or    (HL) 
9017			      jp    NZ, free_done 
9017			 
9017			      dec   HL 
9017			 
9017			      ld    B, H                    ; Copy HL to BC 
9017			      ld    C, L 
9017			 
9017			      ; Loop through the free list to find the first block with an address 
9017			      ; higher than the block being freed 
9017			      ld    HL, free_list 
9017			 
9017			free_find_higher_block: 
9017			      ld    E, (HL)                 ; Load next ptr from free block 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      dec   HL 
9017			 
9017			      ld    (IX+0), E               ; Save ptr to next free block 
9017			      ld    (IX+1), D 
9017			      ld    (IX+2), L               ; Save ptr to prev free block 
9017			      ld    (IX+3), H 
9017			 
9017			      ld    A, B                    ; Check if DE is greater than BC 
9017			      cp    D                       ; Compare MSB first 
9017			      jr    Z, $+4                  ; MSB the same, compare LSB 
9017			      jr    NC, free_find_higher_block_skip 
9017			      ld    A, C 
9017			      cp    E                       ; Then compare LSB 
9017			      jr    C, free_found_higher_block 
9017			 
9017			free_find_higher_block_skip: 
9017			      ld    A, D                    ; Reached the end of the free list? 
9017			      or    E 
9017			      jp    Z, free_done 
9017			 
9017			      ex    DE, HL 
9017			 
9017			      jr    free_find_higher_block 
9017			 
9017			free_found_higher_block: 
9017			      ; Insert freed block between prev and next free blocks 
9017			      ld    (HL), C                 ; Point prev free block to freed block 
9017			      inc   HL 
9017			      ld    (HL), B 
9017			 
9017			      ld    H, B                    ; Point freed block at next free block 
9017			      ld    L, C 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      ; Check if the freed block is adjacent to the next free block 
9017			      inc   HL                      ; Load size of freed block into HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ex    DE, HL 
9017			 
9017			      add   HL, BC                  ; Add addr of freed block and its size 
9017			 
9017			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9017			      ld    D, (IX+1) 
9017			 
9017			      or    A                       ; Clear the carry flag 
9017			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9017			      jr    NZ, free_check_adjacent_to_prev 
9017			 
9017			      ; Freed block is adjacent to next, merge into one bigger block 
9017			      ex    DE, HL                  ; Load next ptr from next block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  HL                      ; Save ptr to next block for later 
9017			 
9017			      ld    H, B                    ; Store ptr from next block into freed block 
9017			      ld    L, C 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   HL                      ; Restore ptr to next block 
9017			      inc   HL                      ; Load size of next block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  DE                      ; Save next block size for later 
9017			 
9017			      ld    H, B                    ; Load size of freed block into HL 
9017			      ld    L, C 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      ex    DE, HL 
9017			 
9017			      pop   DE                      ; Restore size of next block 
9017			      add   HL, DE                  ; Add sizes of both blocks 
9017			      ex    DE, HL 
9017			 
9017			      ld    H, B                    ; Store new bigger size into freed block 
9017			      ld    L, C 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			free_check_adjacent_to_prev: 
9017			      ; Check if the freed block is adjacent to the prev free block 
9017			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9017			      ld    H, (IX+3) 
9017			 
9017			      inc   HL                      ; Size of prev free block into DE 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      dec   HL 
9017			      dec   HL 
9017			      dec   HL 
9017			 
9017			      add   HL, DE                  ; Add prev block addr and size 
9017			 
9017			      or    A                       ; Clear the carry flag 
9017			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9017			      jr    NZ, free_done 
9017			 
9017			      ; Freed block is adjacent to prev, merge into one bigger block 
9017			      ld    H, B                    ; Load next ptr from freed block into DE 
9017			      ld    L, C 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  HL                      ; Save freed block ptr for later 
9017			 
9017			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9017			      ld    H, (IX+3) 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			      pop   HL                      ; Restore freed block ptr 
9017			      inc   HL                      ; Load size of freed block into DE 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			      push  DE                      ; Save freed block size for later 
9017			 
9017			      ld    L, (IX+2)               ; Load size of prev block into DE 
9017			      ld    H, (IX+3) 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    E, (HL) 
9017			      inc   HL 
9017			      ld    D, (HL) 
9017			 
9017			      pop   HL                      ; Add sizes of both blocks 
9017			      add   HL, DE 
9017			      ex    DE, HL 
9017			 
9017			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9017			      ld    H, (IX+3) 
9017			      inc   HL 
9017			      inc   HL 
9017			      ld    (HL), E 
9017			      inc   HL 
9017			      ld    (HL), D 
9017			 
9017			free_done: 
9017			      ld    HL, 4                   ; Clean up stack frame 
9017			      add   HL, SP 
9017			      ld    SP, HL 
9017			 
9017			free_early_exit: 
9017			      pop   IX 
9017			      pop   DE 
9017			      pop   BC 
9017			 
9017			      ret 
9017			 
9017			 
9017			;      .org 0x8000 
9017			; 
9017			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9017			 ;                 .dw   0 
9017			 
9017			endif 
9017			 
9017			 
9017			if MALLOC_4 
9017			 
9017			; My memory allocation code. Very very simple.... 
9017			; allocate space under 250 chars 
9017			 
9017			heap_init: 
9017				; init start of heap as zero 
9017				;  
9017			 
9017				ld hl, heap_start 
9017				ld a, 0 
9017				ld (hl), a      ; empty block 
9017				inc hl 
9017				ld a, 0 
9017				ld (hl), a      ; length of block 
9017				; write end of list 
9017				inc hl 
9017				ld a,(hl) 
9017				inc hl 
9017				ld a,(hl) 
9017				 
9017			 
9017				; init some malloc vars 
9017			 
9017				ld hl, 0 
9017				ld (free_list), hl       ; store last malloc location 
9017			 
9017				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9017				ld a, 0 
9017				ld (hl), a 
9017			 
9017			 
9017				ld hl, heap_start 
9017				;  
9017				  
9017				ret 
9017			 
9017			 
9017			;    free block marker 
9017			;    requested size  
9017			;    pointer to next block 
9017			;    .... 
9017			;    next block marker 
9017			 
9017			 
9017			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9017			; 
9017			 
9017			 
9017			malloc:  
9017				push de 
9017				push bc 
9017				push af 
9017			 
9017				; hl space required 
9017				 
9017				ld c, l    ; hold space   (TODO only a max of 255) 
9017			 
9017			;	inc c     ; TODO BUG need to fix memory leak on push str 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			;	inc c 
9017			 
9017			 
9017			 
9017				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9017			 
9017				ld a, (free_list+3) 
9017				cp 0 
9017				jr z, .contheap 
9017			 
9017				ld hl, (free_list)     ; get last alloc 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mrs" 
9017						CALLMONITOR 
9017					endif 
9017				jr .startalloc 
9017			 
9017			.contheap: 
9017				ld hl, heap_start 
9017			 
9017			.startalloc: 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mym" 
9017						CALLMONITOR 
9017					endif 
9017			.findblock: 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mmf" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017				ld a,(hl)  
9017				; if byte is zero then clear to use 
9017			 
9017				cp 0 
9017				jr z, .foundemptyblock 
9017			 
9017				; if byte is not clear 
9017				;     then byte is offset to next block 
9017			 
9017				inc hl 
9017				ld a, (hl) ; get size 
9017			.nextblock:	inc hl 
9017					ld e, (hl) 
9017					inc hl 
9017					ld d, (hl) 
9017					ex de, hl 
9017			;	inc hl  ; move past the store space 
9017			;	inc hl  ; move past zero index  
9017			 
9017				; TODO detect no more space 
9017			 
9017				push hl 
9017				ld de, heap_end 
9017				call cmp16 
9017				pop hl 
9017				jr nc, .nospace 
9017			 
9017				jr .findblock 
9017			 
9017			.nospace: ld hl, 0 
9017				jp .exit 
9017			 
9017			 
9017			.foundemptyblock:	 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mme" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			; TODO has block enough space if reusing??? 
9017			 
9017				;  
9017			 
9017			; see if this block has been previously used 
9017				inc hl 
9017				ld a, (hl) 
9017				dec hl 
9017				cp 0 
9017				jr z, .newblock 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "meR" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			; no reusing previously allocated block 
9017			 
9017			; is it smaller than previously used? 
9017				 
9017				inc hl    ; move to size 
9017				ld a, c 
9017				sub (hl)        ; we want c < (hl) 
9017				dec hl    ; move back to marker 
9017			        jr z, .findblock 
9017			 
9017				; update with the new size which should be lower 
9017			 
9017			        ;inc  hl   ; negate next move. move back to size  
9017			 
9017			.newblock: 
9017				; need to be at marker here 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "meN" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			 
9017				ld a, c 
9017			 
9017				ld (free_list+3), a	 ; flag resume from last malloc  
9017				ld (free_list), hl    ; save out last location 
9017			 
9017			 
9017				;inc a     ; space for length byte 
9017				ld (hl), a     ; save block in use marker 
9017			 
9017				inc hl   ; move to space marker 
9017				ld (hl), a    ; save new space 
9017			 
9017				inc hl   ; move to start of allocated area 
9017				 
9017			;	push hl     ; save where we are - 1  
9017			 
9017			;	inc hl  ; move past zero index  
9017				; skip space to set down new marker 
9017			 
9017				; provide some extra space for now 
9017			 
9017				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9017				inc a 
9017				inc a 
9017			 
9017				push hl   ; save where we are in the node block 
9017			 
9017				call addatohl 
9017			 
9017				; write linked list point 
9017			 
9017				pop de     ; get our node position 
9017				ex de, hl 
9017			 
9017				ld (hl), e 
9017				inc hl 
9017				ld (hl), d 
9017			 
9017				inc hl 
9017			 
9017				; now at start of allocated data so save pointer 
9017			 
9017				push hl 
9017			 
9017				; jump to position of next node and setup empty header in DE 
9017			 
9017				ex de, hl 
9017			 
9017			;	inc hl ; move past end of block 
9017			 
9017				ld a, 0 
9017				ld (hl), a   ; empty marker 
9017				inc hl 
9017				ld (hl), a   ; size 
9017				inc hl  
9017				ld (hl), a   ; ptr 
9017				inc hl 
9017				ld (hl), a   ; ptr 
9017			 
9017			 
9017				pop hl 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "mmr" 
9017						CALLMONITOR 
9017					endif 
9017			 
9017			.exit: 
9017				pop af 
9017				pop bc 
9017				pop de  
9017				ret 
9017			 
9017			 
9017			 
9017			 
9017			free:  
9017				push hl 
9017				push af 
9017				; get address in hl 
9017			 
9017					if DEBUG_FORTH_MALLOC_INT 
9017						DMARK "fre" 
9017						CALLMONITOR 
9017					endif 
9017				; data is at hl - move to block count 
9017				dec hl 
9017				dec hl    ; get past pointer 
9017				dec hl 
9017			 
9017				ld a, (hl)    ; need this for a validation check 
9017			 
9017				dec hl    ; move to block marker 
9017			 
9017				; now check that the block count and block marker are the same  
9017			        ; this checks that we are on a malloc node and not random memory 
9017			        ; OK a faint chance this could be a problem but rare - famous last words! 
9017			 
9017				ld c, a 
9017				ld a, (hl)    
9017			 
9017				cp c 
9017				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9017			 
9017				; yes good chance we are on a malloc node 
9017			 
9017				ld a, 0      
9017				ld (hl), a   ; mark as free 
9017			 
9017				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9017			 
9017			.freeignore:  
9017			 
9017				pop af 
9017				pop hl 
9017			 
9017				ret 
9017			 
9017			 
9017			 
9017			endif 
9017			 
9017			; eof 
# End of file firmware_memory.asm
9017			  
9017			; device C  
9017			if SOUND_ENABLE  
9017				include "firmware_sound.asm"  
9017			endif  
9017			  
9017			include "firmware_diags.asm"  
9017			; Hardware diags menu 
9017			 
9017			 
9017 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9038 .. 00		hd_menu2:   db "        2: Editor",0   
904a			;hd_menu2:   db "        2: Editor       6: BASIC",0   
904a .. 00		hd_menu3:   db "        3: Storage",0 
905d .. 00		hd_menu4:   db "0=quit  4: Debug",0 
906e .. 00		hd_don:     db "ON",0 
9071 .. 00		hd_doff:     db "OFF",0 
9075			 
9075			 
9075			 
9075			hardware_diags:       
9075			 
9075			.diagmenu: 
9075 cd 5e 88			call clear_display 
9078 3e 00			ld a, display_row_1 
907a 11 17 90			ld de, hd_menu1 
907d cd 71 88			call str_at_display 
9080			 
9080 3e 28			ld a, display_row_2 
9082 11 38 90			ld de, hd_menu2 
9085 cd 71 88			call str_at_display 
9088			 
9088 3e 50			ld a, display_row_3 
908a 11 4a 90			ld de, hd_menu3 
908d cd 71 88			call str_at_display 
9090			 
9090 3e 78			ld a,  display_row_4 
9092 11 5d 90			ld de, hd_menu4 
9095 cd 71 88			call str_at_display 
9098			 
9098				; display debug state 
9098			 
9098 11 6e 90			ld de, hd_don 
909b 3a 74 e3			ld a, (os_view_disable) 
909e fe 00			cp 0 
90a0 28 03			jr z, .distog 
90a2 11 71 90			ld de, hd_doff 
90a5 3e 89		.distog: ld a, display_row_4+17 
90a7 cd 71 88			call str_at_display 
90aa			 
90aa cd 81 88			call update_display 
90ad			 
90ad cd 92 d4			call cin_wait 
90b0			 
90b0			 
90b0			 
90b0 fe 34			cp '4' 
90b2 20 0f			jr nz, .diagn1 
90b4			 
90b4				; debug toggle 
90b4			 
90b4 3a 74 e3			ld a, (os_view_disable) 
90b7 06 2a			ld b, '*' 
90b9 fe 00			cp 0 
90bb 28 02			jr z, .debtog 
90bd 06 00			ld b, 0 
90bf			.debtog:	 
90bf 78				ld a,b 
90c0 32 74 e3			ld (os_view_disable),a 
90c3			 
90c3 fe 30		.diagn1: cp '0' 
90c5 c8				 ret z 
90c6			 
90c6			;	cp '1' 
90c6			;       jp z, matrix	 
90c6			;   TODO keyboard matrix test 
90c6			 
90c6 fe 32			cp '2' 
90c8 ca cf 90			jp z, .diagedit 
90cb			 
90cb			;if ENABLE_BASIC 
90cb			;	cp '6' 
90cb			;	jp z, basic 
90cb			;endif 
90cb			  
90cb c3 75 90			jp .diagmenu 
90ce			 
90ce			 
90ce c9				ret 
90cf			 
90cf			; debug editor 
90cf			 
90cf			.diagedit: 
90cf			 
90cf 21 75 e3			ld hl, scratch 
90d2			;	ld bc, 250 
90d2			;	ldir 
90d2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
90d2 3e 00			ld a, 0 
90d4 77				ld (hl), a 
90d5 23				inc hl 
90d6 77				ld (hl), a 
90d7 23				inc hl 
90d8 77				ld (hl), a 
90d9			 
90d9 cd 5e 88		        call clear_display 
90dc cd 81 88			call update_display 
90df 3e 01			ld a, 1 
90e1 32 80 ee			ld (hardware_diag), a 
90e4			.diloop: 
90e4 3e 00			ld a, display_row_1 
90e6 0e 00			ld c, 0 
90e8 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
90ea 1e 28			ld e, 40 
90ec			 
90ec 21 75 e3			ld hl, scratch	 
90ef cd e4 89			call input_str 
90f2			 
90f2 3e 28			ld a, display_row_2 
90f4 11 75 e3			ld de, scratch 
90f7 cd 71 88			call str_at_display 
90fa cd 81 88			call update_display 
90fd			 
90fd c3 e4 90			jp .diloop 
9100			 
9100			 
9100			; pass word in hl 
9100			; a has display location 
9100			display_word_at: 
9100 f5				push af 
9101 e5				push hl 
9102 7c				ld a,h 
9103 21 7a e6			ld hl, os_word_scratch 
9106 cd b8 8c			call hexout 
9109 e1				pop hl 
910a 7d				ld a,l 
910b 21 7c e6			ld hl, os_word_scratch+2 
910e cd b8 8c			call hexout 
9111 21 7e e6			ld hl, os_word_scratch+4 
9114 3e 00			ld a,0 
9116 77				ld (hl),a 
9117 11 7a e6			ld de,os_word_scratch 
911a f1				pop af 
911b cd 71 88				call str_at_display 
911e c9				ret 
911f			 
911f			display_ptr_state: 
911f			 
911f				; to restore afterwards 
911f			 
911f d5				push de 
9120 c5				push bc 
9121 e5				push hl 
9122 f5				push af 
9123			 
9123				; for use in here 
9123			 
9123			;	push bc 
9123			;	push de 
9123			;	push hl 
9123			;	push af 
9123			 
9123 cd 5e 88			call clear_display 
9126			 
9126 11 f9 92			ld de, .ptrstate 
9129 3e 00			ld a, display_row_1 
912b cd 71 88			call str_at_display 
912e			 
912e				; display debug step 
912e			 
912e			 
912e 11 7a ee			ld de, debug_mark 
9131 3e 26			ld a, display_row_1+display_cols-2 
9133 cd 71 88			call str_at_display 
9136			 
9136				; display a 
9136 11 03 93			ld de, .ptrcliptr 
9139 3e 28			ld a, display_row_2 
913b cd 71 88			call str_at_display 
913e			 
913e f1				pop af 
913f 2a 40 eb			ld hl,(cli_ptr) 
9142 3e 30			ld a, display_row_2+8 
9144 cd 00 91			call display_word_at 
9147			 
9147			 
9147				; display hl 
9147			 
9147			 
9147 11 0b 93			ld de, .ptrclioptr 
914a 3e 32			ld a, display_row_2+10 
914c cd 71 88			call str_at_display 
914f			; 
914f			;	pop hl 
914f 3e 35			ld a, display_row_2+13 
9151 2a 3e eb			ld hl,(cli_origptr) 
9154 cd 00 91			call display_word_at 
9157			; 
9157			;	 
9157			;	; display de 
9157			 
9157			;	ld de, .regstatede 
9157			;	ld a, display_row_3 
9157			;	call str_at_display 
9157			 
9157			;	pop de 
9157			;	ld h,d 
9157			;	ld l, e 
9157			;	ld a, display_row_3+3 
9157			;	call display_word_at 
9157			 
9157			 
9157				; display bc 
9157			 
9157			;	ld de, .regstatebc 
9157			;	ld a, display_row_3+10 
9157			;	call str_at_display 
9157			 
9157			;	pop bc 
9157			;	ld h,b 
9157			;	ld l, c 
9157			;	ld a, display_row_3+13 
9157			;	call display_word_at 
9157			 
9157			 
9157				; display dsp 
9157			 
9157			;	ld de, .regstatedsp 
9157			;	ld a, display_row_4 
9157			;	call str_at_display 
9157			 
9157				 
9157			;	ld hl,(cli_data_sp) 
9157			;	ld a, display_row_4+4 
9157			;	call display_word_at 
9157			 
9157				; display rsp 
9157			 
9157 11 3a 93			ld de, .regstatersp 
915a 3e 82			ld a, display_row_4+10 
915c cd 71 88			call str_at_display 
915f			 
915f				 
915f 2a 26 eb			ld hl,(cli_ret_sp) 
9162 3e 86			ld a, display_row_4+14 
9164 cd 00 91			call display_word_at 
9167			 
9167 cd 81 88			call update_display 
916a			 
916a cd e2 87			call delay1s 
916d cd e2 87			call delay1s 
9170 cd e2 87			call delay1s 
9173			 
9173			 
9173 cd 80 96			call next_page_prompt 
9176			 
9176				; restore  
9176			 
9176 f1				pop af 
9177 e1				pop hl 
9178 c1				pop bc 
9179 d1				pop de 
917a c9				ret 
917b			 
917b			break_point_state: 
917b f5				push af 
917c			 
917c				; see if disabled 
917c			 
917c 3a 74 e3			ld a, (os_view_disable) 
917f fe 2a			cp '*' 
9181 20 02			jr nz, .bpsgo 
9183 f1				pop af 
9184 c9				ret 
9185			 
9185			.bpsgo: 
9185 f1				pop af 
9186 f5				push af 
9187 22 70 e3			ld (os_view_hl), hl 
918a ed 53 6e e3		ld (os_view_de), de 
918e ed 43 6c e3		ld (os_view_bc), bc 
9192 e5				push hl 
9193 6f				ld l, a 
9194 26 00			ld h, 0 
9196 22 72 e3			ld (os_view_af),hl 
9199			 
9199 21 c0 ed				ld hl, display_fb0 
919c 22 db eb				ld (display_fb_active), hl 
919f e1				pop hl	 
91a0			 
91a0 3e 31			ld a, '1' 
91a2 fe 2a		.bps1:  cp '*' 
91a4 20 03			jr nz, .bps1b 
91a6 32 74 e3			ld (os_view_disable),a 
91a9 fe 31		.bps1b:  cp '1' 
91ab 20 14			jr nz, .bps2 
91ad			 
91ad				; display reg 
91ad			 
91ad				 
91ad			 
91ad 3a 72 e3			ld a, (os_view_af) 
91b0 2a 70 e3			ld hl, (os_view_hl) 
91b3 ed 5b 6e e3		ld de, (os_view_de) 
91b7 ed 4b 6c e3		ld bc, (os_view_bc) 
91bb cd 55 92			call display_reg_state 
91be c3 41 92			jp .bpschk 
91c1			 
91c1 fe 32		.bps2:  cp '2' 
91c3 20 08			jr nz, .bps3 
91c5				 
91c5				; display hl 
91c5 2a 70 e3			ld hl, (os_view_hl) 
91c8 cd 3f 93			call display_dump_at_hl 
91cb			 
91cb 18 74			jr .bpschk 
91cd			 
91cd fe 33		.bps3:  cp '3' 
91cf 20 08			jr nz, .bps4 
91d1			 
91d1			        ; display de 
91d1 2a 6e e3			ld hl, (os_view_de) 
91d4 cd 3f 93			call display_dump_at_hl 
91d7			 
91d7 18 68			jr .bpschk 
91d9 fe 34		.bps4:  cp '4' 
91db 20 08			jr nz, .bps5 
91dd			 
91dd			        ; display bc 
91dd 2a 6c e3			ld hl, (os_view_bc) 
91e0 cd 3f 93			call display_dump_at_hl 
91e3			 
91e3 18 5c			jr .bpschk 
91e5 fe 35		.bps5:  cp '5' 
91e7 20 08		        jr nz, .bps7 
91e9			 
91e9				; display cur ptr 
91e9 2a 40 eb			ld hl, (cli_ptr) 
91ec cd 3f 93			call display_dump_at_hl 
91ef			 
91ef 18 50			jr .bpschk 
91f1 fe 36		.bps7:  cp '6' 
91f3 20 08			jr nz, .bps8b 
91f5				 
91f5				; display cur orig ptr 
91f5 2a 3e eb			ld hl, (cli_origptr) 
91f8 cd 3f 93			call display_dump_at_hl 
91fb 18 44			jr .bpschk 
91fd fe 37		.bps8b:  cp '7' 
91ff 20 08			jr nz, .bps9 
9201				 
9201				; display dsp 
9201 2a 22 eb			ld hl, (cli_data_sp) 
9204 cd 3f 93			call display_dump_at_hl 
9207			 
9207 18 38			jr .bpschk 
9209 fe 39		.bps9:  cp '9' 
920b 20 05			jr nz, .bps8c 
920d				 
920d				; display SP 
920d			;	ld hl, sp 
920d cd 3f 93			call display_dump_at_hl 
9210			 
9210 18 2f			jr .bpschk 
9212 fe 38		.bps8c:  cp '8' 
9214 20 08			jr nz, .bps8d 
9216				 
9216				; display rsp 
9216 2a 26 eb			ld hl, (cli_ret_sp) 
9219 cd 3f 93			call display_dump_at_hl 
921c			 
921c 18 23			jr .bpschk 
921e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9220 20 05			jr nz, .bps8 
9222 cd 76 94			call monitor 
9225			 
9225 18 1a			jr .bpschk 
9227 fe 30		.bps8:  cp '0' 
9229 20 16			jr nz, .bpschk 
922b			 
922b 21 1f ed				ld hl, display_fb1 
922e 22 db eb				ld (display_fb_active), hl 
9231 cd 81 88				call update_display 
9234			 
9234				;ld a, (os_view_af) 
9234 2a 70 e3			ld hl, (os_view_hl) 
9237 ed 5b 6e e3		ld de, (os_view_de) 
923b ed 4b 6c e3		ld bc, (os_view_bc) 
923f f1				pop af 
9240 c9				ret 
9241			 
9241			.bpschk:   
9241 cd e2 87			call delay1s 
9244 3e 9f		ld a,display_row_4 + display_cols - 1 
9246 11 7e 96		        ld de, endprg 
9249 cd 71 88			call str_at_display 
924c cd 81 88			call update_display 
924f cd 92 d4			call cin_wait 
9252			 
9252 c3 a2 91			jp .bps1 
9255			 
9255			 
9255			display_reg_state: 
9255			 
9255				; to restore afterwards 
9255			 
9255 d5				push de 
9256 c5				push bc 
9257 e5				push hl 
9258 f5				push af 
9259			 
9259				; for use in here 
9259			 
9259 c5				push bc 
925a d5				push de 
925b e5				push hl 
925c f5				push af 
925d			 
925d cd 5e 88			call clear_display 
9260			 
9260 11 15 93			ld de, .regstate 
9263 3e 00			ld a, display_row_1 
9265 cd 71 88			call str_at_display 
9268			 
9268				; display debug step 
9268			 
9268			 
9268 11 7a ee			ld de, debug_mark 
926b 3e 25			ld a, display_row_1+display_cols-3 
926d cd 71 88			call str_at_display 
9270			 
9270				; display a 
9270 11 31 93			ld de, .regstatea 
9273 3e 28			ld a, display_row_2 
9275 cd 71 88			call str_at_display 
9278			 
9278 e1				pop hl 
9279			;	ld h,0 
9279			;	ld l, a 
9279 3e 2b			ld a, display_row_2+3 
927b cd 00 91			call display_word_at 
927e			 
927e			 
927e				; display hl 
927e			 
927e			 
927e 11 25 93			ld de, .regstatehl 
9281 3e 32			ld a, display_row_2+10 
9283 cd 71 88			call str_at_display 
9286			 
9286 e1				pop hl 
9287 3e 35			ld a, display_row_2+13 
9289 cd 00 91			call display_word_at 
928c			 
928c				 
928c				; display de 
928c			 
928c 11 29 93			ld de, .regstatede 
928f 3e 50			ld a, display_row_3 
9291 cd 71 88			call str_at_display 
9294			 
9294 e1				pop hl 
9295			;	ld h,d 
9295			;	ld l, e 
9295 3e 53			ld a, display_row_3+3 
9297 cd 00 91			call display_word_at 
929a			 
929a			 
929a				; display bc 
929a			 
929a 11 2d 93			ld de, .regstatebc 
929d 3e 5a			ld a, display_row_3+10 
929f cd 71 88			call str_at_display 
92a2			 
92a2 e1				pop hl 
92a3			;	ld h,b 
92a3			;	ld l, c 
92a3 3e 5d			ld a, display_row_3+13 
92a5 cd 00 91			call display_word_at 
92a8			 
92a8			 
92a8				; display dsp 
92a8			 
92a8 11 35 93			ld de, .regstatedsp 
92ab 3e 78			ld a, display_row_4 
92ad cd 71 88			call str_at_display 
92b0			 
92b0				 
92b0 2a 22 eb			ld hl,(cli_data_sp) 
92b3 3e 7c			ld a, display_row_4+4 
92b5 cd 00 91			call display_word_at 
92b8			 
92b8				; display rsp 
92b8			 
92b8 11 3a 93			ld de, .regstatersp 
92bb 3e 82			ld a, display_row_4+10 
92bd cd 71 88			call str_at_display 
92c0			 
92c0				 
92c0 2a 26 eb			ld hl,(cli_ret_sp) 
92c3 3e 86			ld a, display_row_4+14 
92c5 cd 00 91			call display_word_at 
92c8			 
92c8 cd 81 88			call update_display 
92cb			 
92cb			;	call delay1s 
92cb			;	call delay1s 
92cb			;	call delay1s 
92cb			 
92cb			 
92cb			;	call next_page_prompt 
92cb			 
92cb				; restore  
92cb			 
92cb f1				pop af 
92cc e1				pop hl 
92cd c1				pop bc 
92ce d1				pop de 
92cf c9				ret 
92d0			 
92d0 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
92e4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
92f9 .. 00		.ptrstate:	db "Ptr State",0 
9303 .. 00		.ptrcliptr:     db "cli_ptr",0 
930b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9315 .. 00		.regstate:	db "Reg State (1/0)",0 
9325 .. 00		.regstatehl:	db "HL:",0 
9329 .. 00		.regstatede:	db "DE:",0 
932d .. 00		.regstatebc:	db "BC:",0 
9331 .. 00		.regstatea:	db "A :",0 
9335 .. 00		.regstatedsp:	db "DSP:",0 
933a .. 00		.regstatersp:	db "RSP:",0 
933f			 
933f			display_dump_at_hl: 
933f e5				push hl 
9340 d5				push de 
9341 c5				push bc 
9342 f5				push af 
9343			 
9343 22 98 e6			ld (os_cur_ptr),hl	 
9346 cd 5e 88			call clear_display 
9349 cd 88 95			call dumpcont 
934c			;	call delay1s 
934c			;	call next_page_prompt 
934c			 
934c			 
934c f1				pop af 
934d c1				pop bc 
934e d1				pop de 
934f e1				pop hl 
9350 c9				ret 
9351			 
9351			;if ENABLE_BASIC 
9351			;	include "nascombasic.asm" 
9351			;	basic: 
9351			;	include "forth/FORTH.ASM" 
9351			;endif 
9351			 
9351			; eof 
9351			 
9351			 
# End of file firmware_diags.asm
9351			  
9351			  
9351			  
9351			  
9351			; eof  
9351			  
# End of file firmware.asm
9351			 
9351			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9351			;if BASE_KEV  
9351			;baseram: equ 08000h 
9351			;endif 
9351			 
9351			;if BASE_SC114 
9351			;baseram:     equ    endofcode 
9351			;endif 
9351			 
9351			 
9351			; start system 
9351			 
9351			coldstart: 
9351				; set sp 
9351				; di/ei 
9351			 
9351 f3				di 
9352 31 00 f0			ld sp, tos 
9355			;	ei 
9355			 
9355			 
9355				; disable breakpoint by default 
9355			 
9355 3e 2a			ld a,'*' 
9357 32 74 e3			ld (os_view_disable),a 
935a			 
935a				; init hardware 
935a			 
935a				; init keyboard and screen hardware 
935a			 
935a cd 03 80			call hardware_init 
935d			 
935d			 
935d				; detect if any keys are held down to enable breakpoints at start up 
935d			 
935d cd 98 d4			call cin  
9360 fe 00			cp 0 
9362 28 03			jr z, .nokeys 
9364			 
9364 cd 75 90			call hardware_diags 
9367			 
9367			;	ld de, .bpen 
9367			;	ld a, display_row_4 
9367			;	call str_at_display 
9367			;	call update_display 
9367			; 
9367			;	ld a,0 
9367			;	ld (os_view_disable),a 
9367			; 
9367			;.bpwait: 
9367			;	call cin 
9367			;	cp 0 
9367			;	jr z, .bpwait 
9367			;	jr .nokeys 
9367			; 
9367			; 
9367			;.bpen:  db "Break points enabled!",0 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			.nokeys: 
9367			 
9367			 
9367				 
9367			 
9367			;jp  testkey 
9367			 
9367			;call storage_get_block_0 
9367			; 
9367			;ld hl, 0 
9367			;ld de, store_page 
9367			;call storage_read_block 
9367			 
9367				 
9367			;ld hl, 10 
9367			;ld de, store_page 
9367			;call storage_read_block 
9367			 
9367			 
9367			 
9367			 
9367			 
9367			;stop:	nop 
9367			;	jp stop 
9367			 
9367			 
9367			 
9367			main: 
9367 cd 5e 88			call clear_display 
936a cd 81 88			call update_display 
936d			 
936d			 
936d			 
936d			;	call testlcd 
936d			 
936d			 
936d			 
936d cd ce 98			call forth_init 
9370			 
9370			 
9370			warmstart: 
9370 cd a4 98			call forth_warmstart 
9373			 
9373				; run startup word load 
9373			        ; TODO prevent this running at warmstart after crash  
9373			 
9373				if STARTUP_ENABLE 
9373 cd 2c d1				call forth_startup 
9376				endif 
9376			 
9376				; show free memory after boot 
9376 11 10 94			ld de, freeram 
9379 3e 00			ld a, display_row_1 
937b cd 71 88			call str_at_display 
937e			 
937e			; Or use heap_size word???? 
937e 21 69 e3			ld hl, heap_end 
9381 11 b6 d4			ld de, heap_start 
9384 ed 52			sbc hl, de 
9386 e5				push hl 
9387 7c				ld a,h	         	 
9388 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
938b cd b8 8c			call hexout 
938e e1			   	pop hl 
938f			 
938f 7d				ld a,l 
9390 21 7c e6			ld hl, os_word_scratch+2 
9393 cd b8 8c			call hexout 
9396 21 7e e6			ld hl, os_word_scratch+4 
9399 3e 00			ld a, 0 
939b 77				ld (hl),a 
939c 11 7a e6			ld de, os_word_scratch 
939f 3e 0d			ld a, display_row_1 + 13 
93a1 cd 71 88			call str_at_display 
93a4 cd 81 88			call update_display 
93a7			 
93a7			 
93a7				;call demo 
93a7			 
93a7			 
93a7				; init scratch input area for cli commands 
93a7			 
93a7 21 9c e6			ld hl, os_cli_cmd 
93aa 3e 00			ld a,0 
93ac 77				ld (hl),a 
93ad 23				inc hl 
93ae 77				ld (hl),a 
93af			 
93af 3e 00			ld a,0 
93b1 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
93b4			 
93b4 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
93b7 32 99 e6			ld (os_cur_ptr+1),a	 
93ba			 
93ba 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
93bd 32 7b e6			ld (os_word_scratch+1),a	 
93c0				 
93c0			 
93c0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
93c0 21 9c e6			ld hl, os_cli_cmd 
93c3			 
93c3 3e 00			ld a, 0		 ; init cli input 
93c5 77				ld (hl), a 
93c6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
93c8			cli: 
93c8				; show cli prompt 
93c8				;push af 
93c8				;ld a, 0 
93c8				;ld de, prompt 
93c8				;call str_at_display 
93c8			 
93c8				;call update_display 
93c8				;pop af 
93c8				;inc a 
93c8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
93c8 0e 00			ld c, 0 
93ca 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
93cc 1e 28			ld e, 40 
93ce			 
93ce 21 9c e6			ld hl, os_cli_cmd 
93d1			 
93d1				STACKFRAME OFF $fefe $9f9f 
93d1				if DEBUG_STACK_IMB 
93d1					if OFF 
93d1						exx 
93d1						ld de, $fefe 
93d1						ld a, d 
93d1						ld hl, curframe 
93d1						call hexout 
93d1						ld a, e 
93d1						ld hl, curframe+2 
93d1						call hexout 
93d1						ld hl, $fefe 
93d1						push hl 
93d1						ld hl, $9f9f 
93d1						push hl 
93d1						exx 
93d1					endif 
93d1				endif 
93d1			endm 
# End of macro STACKFRAME
93d1			 
93d1 cd e4 89			call input_str 
93d4			 
93d4				STACKFRAMECHK OFF $fefe $9f9f 
93d4				if DEBUG_STACK_IMB 
93d4					if OFF 
93d4						exx 
93d4						ld hl, $9f9f 
93d4						pop de   ; $9f9f 
93d4						call cmp16 
93d4						jr nz, .spnosame 
93d4						ld hl, $fefe 
93d4						pop de   ; $fefe 
93d4						call cmp16 
93d4						jr z, .spfrsame 
93d4						.spnosame: call showsperror 
93d4						.spfrsame: nop 
93d4						exx 
93d4					endif 
93d4				endif 
93d4			endm 
# End of macro STACKFRAMECHK
93d4			 
93d4				; copy input to last command 
93d4			 
93d4 21 9c e6			ld hl, os_cli_cmd 
93d7 11 9b e7			ld de, os_last_cmd 
93da 01 ff 00			ld bc, 255 
93dd ed b0			ldir 
93df				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93df			;	call strcpy 
93df			;	ld a, 0 
93df			;	ld (hl), a 
93df			;	inc hl 
93df			;	ld (hl), a 
93df			;	inc hl 
93df			;	ld (hl), a 
93df			 
93df				; switch frame buffer to program  
93df			 
93df 21 1f ed				ld hl, display_fb1 
93e2 22 db eb				ld (display_fb_active), hl 
93e5			 
93e5			;	nop 
93e5				STACKFRAME ON $fbfe $8f9f 
93e5				if DEBUG_STACK_IMB 
93e5					if ON 
93e5						exx 
93e5						ld de, $fbfe 
93e5						ld a, d 
93e5						ld hl, curframe 
93e5						call hexout 
93e5						ld a, e 
93e5						ld hl, curframe+2 
93e5						call hexout 
93e5						ld hl, $fbfe 
93e5						push hl 
93e5						ld hl, $8f9f 
93e5						push hl 
93e5						exx 
93e5					endif 
93e5				endif 
93e5			endm 
# End of macro STACKFRAME
93e5				; first time into the parser so pass over the current scratch pad 
93e5 21 9c e6			ld hl,os_cli_cmd 
93e8				; tokenise the entered statement(s) in HL 
93e8 cd 47 99			call forthparse 
93eb			        ; exec forth statements in top of return stack 
93eb cd 87 99			call forthexec 
93ee				;call forthexec_cleanup 
93ee			;	call parsenext 
93ee			 
93ee				STACKFRAMECHK ON $fbfe $8f9f 
93ee				if DEBUG_STACK_IMB 
93ee					if ON 
93ee						exx 
93ee						ld hl, $8f9f 
93ee						pop de   ; $8f9f 
93ee						call cmp16 
93ee						jr nz, .spnosame 
93ee						ld hl, $fbfe 
93ee						pop de   ; $fbfe 
93ee						call cmp16 
93ee						jr z, .spfrsame 
93ee						.spnosame: call showsperror 
93ee						.spfrsame: nop 
93ee						exx 
93ee					endif 
93ee				endif 
93ee			endm 
# End of macro STACKFRAMECHK
93ee				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
93ee			 
93ee 3e 78			ld a, display_row_4 
93f0 11 22 94			ld de, endprog 
93f3			 
93f3 cd 81 88			call update_display		 
93f6			 
93f6 cd 80 96			call next_page_prompt 
93f9			 
93f9				; switch frame buffer to cli 
93f9			 
93f9 21 c0 ed				ld hl, display_fb0 
93fc 22 db eb				ld (display_fb_active), hl 
93ff			 
93ff			 
93ff cd 5e 88		        call clear_display 
9402 cd 81 88			call update_display		 
9405			 
9405 21 9c e6			ld hl, os_cli_cmd 
9408			 
9408 3e 00			ld a, 0		 ; init cli input 
940a 77				ld (hl), a 
940b			 
940b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
940b			 
940b				; now on last line 
940b			 
940b				; TODO scroll screen up 
940b			 
940b				; TODO instead just clear screen and place at top of screen 
940b			 
940b			;	ld a, 0 
940b			;	ld (f_cursor_ptr),a 
940b			 
940b				;call clear_display 
940b				;call update_display 
940b			 
940b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
940b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
940d c3 c8 93			jp cli 
9410			 
9410 .. 00		freeram: db "Free bytes: $",0 
941e ..			asc: db "1A2F" 
9422 .. 00		endprog: db "End prog...",0 
942e			 
942e			testenter2:   
942e 21 a7 e3			ld hl,scratch+50 
9431 22 98 e6			ld (os_cur_ptr),hl 
9434 c3 c8 93			jp cli 
9437			 
9437			testenter:  
9437			 
9437 21 1e 94			ld hl,asc 
943a			;	ld a,(hl) 
943a			;	call nibble2val 
943a cd 0e 8d			call get_byte 
943d			 
943d			 
943d			;	ld a,(hl) 
943d			;	call atohex 
943d			 
943d			;	call fourehexhl 
943d 32 a7 e3			ld (scratch+50),a 
9440			 
9440			 
9440			 
9440 21 20 94			ld hl,asc+2 
9443			;	ld a, (hl) 
9443			;	call nibble2val 
9443 cd 0e 8d			call get_byte 
9446			 
9446			;	call fourehexhl 
9446 32 a9 e3			ld (scratch+52),a 
9449				 
9449 21 a7 e3			ld hl,scratch+50 
944c 22 98 e6			ld (os_cur_ptr),hl 
944f c3 c8 93			jp cli 
9452			 
9452			enter:	 
9452 3a 79 e3			ld a,(scratch+4) 
9455 fe 00			cp 0 
9457 28 0c			jr z, .entercont 
9459				; no, not a null term line so has an address to work out.... 
9459			 
9459 21 77 e3			ld hl,scratch+2 
945c cd 6e 8d			call get_word_hl 
945f			 
945f 22 98 e6			ld (os_cur_ptr),hl	 
9462 c3 c8 93			jp cli 
9465			 
9465			 
9465			.entercont:  
9465			 
9465 21 77 e3			ld hl, scratch+2 
9468 cd 0e 8d			call get_byte 
946b			 
946b 2a 98 e6		   	ld hl,(os_cur_ptr) 
946e 77					ld (hl),a 
946f 23					inc hl 
9470 22 98 e6				ld (os_cur_ptr),hl 
9473				 
9473			; get byte  
9473			 
9473			 
9473 c3 c8 93			jp cli 
9476			 
9476			 
9476			; basic monitor support 
9476			 
9476			monitor: 
9476				;  
9476 cd 5e 88			call clear_display 
9479 3e 00			ld a, 0 
947b 11 c3 94			ld de, .monprompt 
947e cd 71 88			call str_at_display 
9481 cd 81 88			call update_display 
9484			 
9484				; get a monitor command 
9484			 
9484 0e 00			ld c, 0     ; entry at top left 
9486 16 64			ld d, 100   ; max buffer size 
9488 1e 0f			ld e, 15    ; input scroll area 
948a 3e 00			ld a, 0     ; init string 
948c 21 73 e5			ld hl, os_input 
948f 77				ld (hl), a 
9490 23				inc hl 
9491 77				ld (hl), a 
9492 21 73 e5			ld hl, os_input 
9495 3e 01			ld a, 1     ; init string 
9497 cd e4 89			call input_str 
949a			 
949a cd 5e 88		        call clear_display 
949d cd 81 88			call update_display		 
94a0			 
94a0 3a 73 e5			ld a, (os_input) 
94a3 cd 0c 8e			call toUpper 
94a6 fe 48		        cp 'H' 
94a8 28 6f		        jr z, .monhelp 
94aa fe 44			cp 'D'		; dump 
94ac ca 3a 95			jp z, .mondump	 
94af fe 43			cp 'C'		; dump 
94b1 ca 54 95			jp z, .moncdump	 
94b4 fe 4d			cp 'M'		; dump 
94b6 ca c5 94			jp z, .moneditstart 
94b9 fe 55			cp 'U'		; dump 
94bb 28 14			jr z, .monedit	 
94bd fe 51			cp 'Q'		; dump 
94bf c8				ret z	 
94c0			 
94c0			 
94c0				; TODO "S" to access symbol by name and not need the address 
94c0				; TODO "F" to find a string in memory 
94c0			 
94c0 c3 76 94			jp monitor 
94c3			 
94c3 .. 00		.monprompt: db ">", 0 
94c5			 
94c5			.moneditstart: 
94c5				; get starting address 
94c5			 
94c5 21 75 e5			ld hl,os_input+2 
94c8 cd 6e 8d			call get_word_hl 
94cb			 
94cb 22 98 e6			ld (os_cur_ptr),hl	 
94ce			 
94ce c3 76 94			jp monitor 
94d1			 
94d1			.monedit: 
94d1				; get byte to load 
94d1			 
94d1 21 75 e5			ld hl,os_input+2 
94d4 cd 0e 8d			call get_byte 
94d7			 
94d7				; get address to update 
94d7 2a 98 e6			ld hl, (os_cur_ptr) 
94da			 
94da				; update byte 
94da			 
94da 77				ld (hl), a 
94db			 
94db				; move to next address and save it 
94db			 
94db 23				inc hl 
94dc 22 98 e6			ld (os_cur_ptr),hl	 
94df			 
94df c3 76 94			jp monitor 
94e2			 
94e2			 
94e2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
94f6 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9512 .. 00		.monhelptext3:  db "Q-Quit",0 
9519			        
9519			.monhelp: 
9519 3e 00			ld a, display_row_1 
951b 11 e2 94		        ld de, .monhelptext1 
951e			 
951e cd 71 88			call str_at_display 
9521 3e 28			ld a, display_row_2 
9523 11 f6 94		        ld de, .monhelptext2 
9526					 
9526 cd 71 88			call str_at_display 
9529 3e 50			ld a, display_row_3 
952b 11 12 95		        ld de, .monhelptext3 
952e					 
952e cd 71 88			call str_at_display 
9531 cd 81 88			call update_display		 
9534			 
9534 cd 80 96			call next_page_prompt 
9537 c3 76 94			jp monitor 
953a			 
953a			.mondump:    
953a 21 75 e5			ld hl,os_input+2 
953d cd 6e 8d			call get_word_hl 
9540			 
9540 22 98 e6			ld (os_cur_ptr),hl	 
9543 cd 88 95			call dumpcont 
9546 3e 78			ld a, display_row_4 
9548 11 22 94			ld de, endprog 
954b			 
954b cd 81 88			call update_display		 
954e			 
954e cd 80 96			call next_page_prompt 
9551 c3 76 94			jp monitor 
9554			.moncdump: 
9554 cd 88 95			call dumpcont 
9557 3e 78			ld a, display_row_4 
9559 11 22 94			ld de, endprog 
955c			 
955c cd 81 88			call update_display		 
955f			 
955f cd 80 96			call next_page_prompt 
9562 c3 76 94			jp monitor 
9565			 
9565			 
9565			; TODO symbol access  
9565			 
9565			.symbols:     ;; A list of symbols that can be called up  
9565 c0 ed			dw display_fb0 
9567 .. 00			db "fb0",0  
956b 65 eb		     	dw store_page 
956d .. 00			db "store_page",0 
9578			 
9578			 
9578			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9578			 
9578 3a 76 e3			ld a,(scratch+1) 
957b fe 00			cp 0 
957d 28 09			jr z, dumpcont 
957f			 
957f				; no, not a null term line so has an address to work out.... 
957f			 
957f 21 77 e3			ld hl,scratch+2 
9582 cd 6e 8d			call get_word_hl 
9585			 
9585 22 98 e6			ld (os_cur_ptr),hl	 
9588			 
9588			 
9588			 
9588			dumpcont: 
9588			 
9588				; dump bytes at ptr 
9588			 
9588			 
9588 3e 00			ld a, display_row_1 
958a 2a db eb			ld hl, (display_fb_active) 
958d cd b7 89			call addatohl 
9590 cd b8 95			call .dumpbyterow 
9593			 
9593 3e 28			ld a, display_row_2 
9595 2a db eb			ld hl, (display_fb_active) 
9598 cd b7 89			call addatohl 
959b cd b8 95			call .dumpbyterow 
959e			 
959e			 
959e 3e 50			ld a, display_row_3 
95a0 2a db eb			ld hl, (display_fb_active) 
95a3 cd b7 89			call addatohl 
95a6 cd b8 95			call .dumpbyterow 
95a9			 
95a9 3e 78			ld a, display_row_4 
95ab 2a db eb			ld hl, (display_fb_active) 
95ae cd b7 89			call addatohl 
95b1 cd b8 95			call .dumpbyterow 
95b4			 
95b4 cd 81 88			call update_display 
95b7			;		jp cli 
95b7 c9				ret 
95b8			 
95b8			.dumpbyterow: 
95b8			 
95b8				;push af 
95b8			 
95b8 e5				push hl 
95b9			 
95b9				; calc where to poke the ascii 
95b9			if display_cols == 20 
95b9				ld a, 16 
95b9			else 
95b9 3e 1f			ld a, 31 
95bb			endif 
95bb			 
95bb cd b7 89			call addatohl 
95be 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
95c1			 
95c1			 
95c1			; display decoding address 
95c1 2a 98 e6		   	ld hl,(os_cur_ptr) 
95c4			 
95c4 7c				ld a,h 
95c5 e1				pop hl 
95c6 e5				push hl 
95c7			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
95c7 cd b8 8c			call hexout 
95ca 2a 98 e6		   	ld hl,(os_cur_ptr) 
95cd			 
95cd 7d				ld a,l 
95ce e1				pop hl 
95cf 23				inc hl 
95d0 23				inc hl 
95d1 e5				push hl 
95d2			;	ld hl, os_word_scratch+2 
95d2 cd b8 8c			call hexout 
95d5 e1				pop hl 
95d6 23				inc hl 
95d7 23				inc hl 
95d8				;ld hl, os_word_scratch+4 
95d8 3e 3a			ld a, ':' 
95da 77				ld (hl),a 
95db 23				inc hl 
95dc				;ld a, 0 
95dc				;ld (hl),a 
95dc				;ld de, os_word_scratch 
95dc				;pop af 
95dc				;push af 
95dc			;		ld a, display_row_2 
95dc			;		call str_at_display 
95dc			;		call update_display 
95dc			 
95dc			 
95dc			;pop af 
95dc			;	add 5 
95dc			 
95dc			if display_cols == 20 
95dc				ld b, 4 
95dc			else 
95dc 06 08			ld b, 8 
95de			endif	 
95de			 
95de			.dumpbyte: 
95de c5				push bc 
95df e5				push hl 
95e0			 
95e0			 
95e0 2a 98 e6		   	ld hl,(os_cur_ptr) 
95e3 7e					ld a,(hl) 
95e4			 
95e4					; poke the ascii to display 
95e4 2a 7a e6				ld hl,(os_word_scratch) 
95e7 77					ld (hl),a 
95e8 23					inc hl 
95e9 22 7a e6				ld (os_word_scratch),hl 
95ec			 
95ec					 
95ec			 
95ec			 
95ec e1					pop hl 
95ed e5					push hl 
95ee			 
95ee cd b8 8c				call hexout 
95f1			 
95f1					 
95f1 2a 98 e6		   	ld hl,(os_cur_ptr) 
95f4 23				inc hl 
95f5 22 98 e6		   	ld (os_cur_ptr),hl 
95f8			 
95f8 e1					pop hl 
95f9 23					inc hl 
95fa 23					inc hl 
95fb 23					inc hl 
95fc			 
95fc			 
95fc			 
95fc					;ld a,0 
95fc					;ld (os_word_scratch+2),a 
95fc					;pop af 
95fc					;push af 
95fc			 
95fc					;ld de, os_word_scratch 
95fc					;call str_at_display 
95fc			;		call update_display 
95fc			;		pop af 
95fc c1					pop bc 
95fd c6 03				add 3 
95ff 10 dd			djnz .dumpbyte 
9601			 
9601				 
9601			 
9601 c9				ret 
9602			 
9602			jump:	 
9602			 
9602 21 77 e3			ld hl,scratch+2 
9605 cd 6e 8d			call get_word_hl 
9608				;ld hl,(scratch+2) 
9608				;call fourehexhl 
9608			 
9608 22 98 e6			ld (os_cur_ptr),hl	 
960b			 
960b e9				jp (hl) 
960c			 
960c			 
960c			 
960c			; TODO implement a basic monitor mode to start with 
960c			 
960c			 
960c			 
960c			 
960c			 
960c			 
960c			 
960c			 
960c			 
960c			; testing and demo code during development 
960c			 
960c			 
960c .. 00		str1: db "Enter some text...",0 
961f .. 00		clear: db "                    ",0 
9634			 
9634			demo: 
9634			 
9634			 
9634			 
9634			;	call update_display 
9634			 
9634				; init scratch input area for testing 
9634 21 75 e3			ld hl, scratch	 
9637 3e 00			ld a,0 
9639 77				ld (hl),a 
963a			 
963a			 
963a 3e 28		            LD   A, display_row_2 
963c			;            CALL fLCD_Pos       ;Position cursor to location in A 
963c 11 0c 96		            LD   DE, str1 
963f cd 71 88			call str_at_display 
9642			 
9642			;            CALL fLCD_Str       ;Display string pointed to by DE 
9642			cloop:	 
9642 3e 50		            LD   A, display_row_3 
9644			;            CALL fLCD_Pos       ;Position cursor to location in A 
9644 11 1f 96		            LD   DE, clear 
9647			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9647 cd 71 88				call str_at_display 
964a 3e 78			ld a, display_row_4 
964c 11 7c 96			ld de, prompt 
964f			 
964f cd 71 88				call str_at_display 
9652 cd 81 88			call update_display 
9655			 
9655 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9657 16 0a			ld d, 10 
9659 21 75 e3			ld hl, scratch	 
965c cd e4 89			call input_str 
965f			 
965f			;	call clear_display 
965f			;'	call update_display 
965f			 
965f 3e 00		            LD   A, display_row_1 
9661			;            CALL fLCD_Pos       ;Position cursor to location in A 
9661 11 1f 96		            LD   DE, clear 
9664 cd 71 88				call str_at_display 
9667			;            CALL fLCD_Str       ;Display string pointed to by DE 
9667 3e 00		            LD   A, display_row_1 
9669			;            CALL fLCD_Pos       ;Position cursor to location in A 
9669 11 75 e3		            LD   DE, scratch 
966c			;            CALL fLCD_Str       ;Display string pointed to by DE 
966c cd 71 88				call str_at_display 
966f cd 81 88			call update_display 
9672			 
9672 3e 00				ld a,0 
9674 21 75 e3			ld hl, scratch 
9677 77				ld (hl),a 
9678			 
9678 00				nop 
9679 c3 42 96			jp cloop 
967c			 
967c			 
967c			 
967c			; OS Prompt 
967c			 
967c .. 00		prompt: db ">",0 
967e .. 00		endprg: db "?",0 
9680			 
9680			 
9680			; handy next page prompt 
9680			next_page_prompt: 
9680 e5				push hl 
9681 d5				push de 
9682 f5				push af 
9683 c5				push bc 
9684			 
9684 3e 9f			ld a,display_row_4 + display_cols - 1 
9686 11 7e 96		        ld de, endprg 
9689 cd 71 88			call str_at_display 
968c cd 81 88			call update_display 
968f cd 92 d4			call cin_wait 
9692 c1				pop bc 
9693 f1				pop af 
9694 d1				pop de 
9695 e1				pop hl 
9696			 
9696			 
9696 c9				ret 
9697			 
9697			 
9697			; forth parser 
9697			 
9697			; My forth kernel 
9697			include "forth_kernel.asm" 
9697			; 
9697			; kernel to the forth OS 
9697			 
9697			DS_TYPE_STR: equ 1     ; string type 
9697			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9697			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9697			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9697			 
9697			FORTH_PARSEV1: equ 0 
9697			FORTH_PARSEV2: equ 0 
9697			FORTH_PARSEV3: equ 0 
9697			FORTH_PARSEV4: equ 0 
9697			FORTH_PARSEV5: equ 1 
9697			 
9697			;if FORTH_PARSEV5 
9697			;	FORTH_END_BUFFER: equ 0 
9697			;else 
9697			FORTH_END_BUFFER: equ 127 
9697			;endif 
9697			 
9697			FORTH_TRUE: equ 1 
9697			FORTH_FALSE: equ 0 
9697			 
9697			if FORTH_PARSEV4 
9697			include "forth_stackops.asm" 
9697			endif 
9697			 
9697			if FORTH_PARSEV5 
9697			include "forth_stackopsv5.asm" 
9697			 
9697			; Stack operations for v5 parser on wards 
9697			; * DATA stack 
9697			; * LOOP stack 
9697			; * RETURN stack 
9697			 
9697			 
9697			 
9697			FORTH_CHK_DSP_UNDER: macro 
9697				push hl 
9697				push de 
9697				ld hl,(cli_data_sp) 
9697				ld de, cli_data_stack 
9697				call cmp16 
9697				jp c, fault_dsp_under 
9697				pop de 
9697				pop hl 
9697				endm 
9697			 
9697			 
9697			FORTH_CHK_RSP_UNDER: macro 
9697				push hl 
9697				push de 
9697				ld hl,(cli_ret_sp) 
9697				ld de, cli_ret_stack 
9697				call cmp16 
9697				jp c, fault_rsp_under 
9697				pop de 
9697				pop hl 
9697				endm 
9697			 
9697			FORTH_CHK_LOOP_UNDER: macro 
9697				push hl 
9697				push de 
9697				ld hl,(cli_loop_sp) 
9697				ld de, cli_loop_stack 
9697				call cmp16 
9697				jp c, fault_loop_under 
9697				pop de 
9697				pop hl 
9697				endm 
9697			 
9697			FORTH_ERR_TOS_NOTSTR: macro 
9697				; TOSO might need more for checks when used 
9697				push af 
9697				ld a,(hl) 
9697				cp DS_TYPE_STR 
9697				jp nz, type_faultn   
9697				pop af 
9697				endm 
9697			 
9697			FORTH_ERR_TOS_NOTNUM: macro 
9697				push af 
9697				ld a,(hl) 
9697				cp DS_TYPE_INUM 
9697				jp nz, type_faultn   
9697				pop af 
9697				endm 
9697			 
9697			 
9697			; increase data stack pointer and save hl to it 
9697				 
9697			FORTH_DSP_NEXT: macro 
9697				call macro_forth_dsp_next 
9697				endm 
9697			 
9697			 
9697			macro_forth_dsp_next: 
9697				if DEBUG_FORTH_STACK_GUARD 
9697 cd f6 d1				call check_stacks 
969a				endif 
969a e5				push hl 
969b d5				push de 
969c eb				ex de,hl 
969d 2a 22 eb			ld hl,(cli_data_sp) 
96a0 23				inc hl 
96a1 23				inc hl 
96a2			 
96a2			; PARSEV5 
96a2 23				inc hl 
96a3 22 22 eb			ld (cli_data_sp),hl 
96a6 73				ld (hl), e 
96a7 23				inc hl 
96a8 72				ld (hl), d 
96a9 d1				pop de 
96aa e1				pop hl 
96ab				if DEBUG_FORTH_STACK_GUARD 
96ab cd f6 d1				call check_stacks 
96ae				endif 
96ae c9				ret 
96af			 
96af			 
96af			; increase ret stack pointer and save hl to it 
96af				 
96af			FORTH_RSP_NEXT: macro 
96af				call macro_forth_rsp_next 
96af				endm 
96af			 
96af			macro_forth_rsp_next: 
96af				if DEBUG_FORTH_STACK_GUARD 
96af cd f6 d1				call check_stacks 
96b2				endif 
96b2 e5				push hl 
96b3 d5				push de 
96b4 eb				ex de,hl 
96b5 2a 26 eb			ld hl,(cli_ret_sp) 
96b8 23				inc hl 
96b9 23				inc hl 
96ba 22 26 eb			ld (cli_ret_sp),hl 
96bd 73				ld (hl), e 
96be 23				inc hl 
96bf 72				ld (hl), d 
96c0 d1				pop de 
96c1 e1				pop hl 
96c2				if DEBUG_FORTH_STACK_GUARD 
96c2 cd f6 d1				call check_stacks 
96c5				endif 
96c5 c9				ret 
96c6			 
96c6			; get current ret stack pointer and save to hl  
96c6				 
96c6			FORTH_RSP_TOS: macro 
96c6				call macro_forth_rsp_tos 
96c6				endm 
96c6			 
96c6			macro_forth_rsp_tos: 
96c6				;push de 
96c6 2a 26 eb			ld hl,(cli_ret_sp) 
96c9 cd 01 97			call loadhlptrtohl 
96cc				;ld e, (hl) 
96cc				;inc hl 
96cc				;ld d, (hl) 
96cc				;ex de, hl 
96cc					if DEBUG_FORTH_WORDS 
96cc			;			DMARK "RST" 
96cc						CALLMONITOR 
96cc cd 7b 91			call break_point_state  
96cf				endm  
# End of macro CALLMONITOR
96cf					endif 
96cf				;pop de 
96cf c9				ret 
96d0			 
96d0			; pop ret stack pointer 
96d0				 
96d0			FORTH_RSP_POP: macro 
96d0				call macro_forth_rsp_pop 
96d0				endm 
96d0			 
96d0			 
96d0			macro_forth_rsp_pop: 
96d0				if DEBUG_FORTH_STACK_GUARD 
96d0			;		DMARK "RPP" 
96d0 cd f6 d1				call check_stacks 
96d3					FORTH_CHK_RSP_UNDER 
96d3 e5				push hl 
96d4 d5				push de 
96d5 2a 26 eb			ld hl,(cli_ret_sp) 
96d8 11 e0 ea			ld de, cli_ret_stack 
96db cd d5 89			call cmp16 
96de da 0a d3			jp c, fault_rsp_under 
96e1 d1				pop de 
96e2 e1				pop hl 
96e3				endm 
# End of macro FORTH_CHK_RSP_UNDER
96e3				endif 
96e3 e5				push hl 
96e4 2a 26 eb			ld hl,(cli_ret_sp) 
96e7			 
96e7			 
96e7				if FORTH_ENABLE_FREE 
96e7			 
96e7					; get pointer 
96e7			 
96e7					push de 
96e7					push hl 
96e7			 
96e7					ld e, (hl) 
96e7					inc hl 
96e7					ld d, (hl) 
96e7			 
96e7					ex de, hl 
96e7					call free 
96e7			 
96e7					pop hl 
96e7					pop de 
96e7			 
96e7			 
96e7				endif 
96e7			 
96e7			 
96e7 2b				dec hl 
96e8 2b				dec hl 
96e9 22 26 eb			ld (cli_ret_sp), hl 
96ec				; do stack underflow checks 
96ec e1				pop hl 
96ed				if DEBUG_FORTH_STACK_GUARD 
96ed cd f6 d1				call check_stacks 
96f0					FORTH_CHK_RSP_UNDER 
96f0 e5				push hl 
96f1 d5				push de 
96f2 2a 26 eb			ld hl,(cli_ret_sp) 
96f5 11 e0 ea			ld de, cli_ret_stack 
96f8 cd d5 89			call cmp16 
96fb da 0a d3			jp c, fault_rsp_under 
96fe d1				pop de 
96ff e1				pop hl 
9700				endm 
# End of macro FORTH_CHK_RSP_UNDER
9700				endif 
9700 c9				ret 
9701			 
9701			 
9701			 
9701			; routine to load word pointed to by hl into hl 
9701			 
9701			loadhlptrtohl: 
9701			 
9701 d5				push de 
9702 5e				ld e, (hl) 
9703 23				inc hl 
9704 56				ld d, (hl) 
9705 eb				ex de, hl 
9706 d1				pop de 
9707			 
9707 c9				ret 
9708			 
9708			 
9708			 
9708			 
9708			 
9708			; push a number held in HL onto the data stack 
9708			; entry point for pushing a value when already in hl used in function above 
9708			 
9708			forth_push_numhl: 
9708			 
9708 e5				push hl    ; save value to push 
9709			 
9709			if DEBUG_FORTH_PUSH 
9709				; see if disabled 
9709			 
9709			 
9709				push af 
9709				ld a, (os_view_disable) 
9709				cp '*' 
9709				jr z, .pskip2 
9709				push hl 
9709			push hl 
9709				call clear_display 
9709			pop hl 
9709				ld a,h 
9709				ld hl, os_word_scratch 
9709				call hexout 
9709				pop hl 
9709				ld a,l 
9709				ld hl, os_word_scratch+2 
9709				call hexout 
9709			 
9709				ld hl, os_word_scratch+4 
9709				ld a,0 
9709				ld (hl),a 
9709				ld de,os_word_scratch 
9709					ld a, display_row_2 
9709					call str_at_display 
9709				ld de, .push_num 
9709				ld a, display_row_1 
9709			 
9709					call str_at_display 
9709			 
9709			 
9709				call update_display 
9709				call delay1s 
9709				call delay1s 
9709			.pskip2:  
9709			 
9709				pop af 
9709			endif	 
9709			 
9709			 
9709				FORTH_DSP_NEXT 
9709 cd 97 96			call macro_forth_dsp_next 
970c				endm 
# End of macro FORTH_DSP_NEXT
970c			 
970c 2a 22 eb			ld hl, (cli_data_sp) 
970f			 
970f				; save item type 
970f 3e 02			ld a,  DS_TYPE_INUM 
9711 77				ld (hl), a 
9712 23				inc hl 
9713			 
9713				; get word off stack 
9713 d1				pop de 
9714 7b				ld a,e 
9715 77				ld (hl), a 
9716 23				inc hl 
9717 7a				ld a,d 
9718 77				ld (hl), a 
9719			 
9719			if DEBUG_FORTH_PUSH 
9719				dec hl 
9719				dec hl 
9719				dec hl 
9719						DMARK "PH5" 
9719				CALLMONITOR 
9719			endif	 
9719			 
9719 c9				ret 
971a			 
971a			 
971a			; Push a string to stack pointed to by hl 
971a			 
971a			forth_push_str: 
971a			 
971a			if DEBUG_FORTH_PUSH 
971a						DMARK "PSQ" 
971a				CALLMONITOR 
971a			endif	 
971a			    
971a e5				push hl 
971b e5				push hl 
971c			 
971c 3e 00			ld a, 0   ; find end of string 
971e cd 20 8e			call strlent       
9721			if DEBUG_FORTH_PUSH 
9721						DMARK "PQ2" 
9721				CALLMONITOR 
9721			endif	 
9721 eb				ex de, hl 
9722 e1				pop hl   ; get ptr to start of string 
9723			if DEBUG_FORTH_PUSH 
9723						DMARK "PQ3" 
9723				CALLMONITOR 
9723			endif	 
9723 19				add hl,de 
9724			if DEBUG_FORTH_PUSH 
9724						DMARK "PQE" 
9724				CALLMONITOR 
9724			endif	 
9724			 
9724 2b				dec hl    ; see if there is an optional trailing double quote 
9725 7e				ld a,(hl) 
9726 fe 22			cp '"' 
9728 20 03			jr nz, .strnoq 
972a 3e 00			ld a, 0      ; get rid of double quote 
972c 77				ld (hl), a 
972d 23			.strnoq: inc hl 
972e			 
972e 3e 00			ld a, 0 
9730 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9731			 
9731 13				inc de ; add one for the type string 
9732 13				inc de ; add one for null term??? 
9733			 
9733				; tos is get string pointer again 
9733				; de contains space to allocate 
9733				 
9733 d5				push de 
9734			 
9734 eb				ex de, hl 
9735			 
9735				;push af 
9735			 
9735			if DEBUG_FORTH_PUSH 
9735						DMARK "PHm" 
9735				CALLMONITOR 
9735			endif	 
9735 cd 7e 8e			call malloc	; on ret hl now contains allocated memory 
9738				if DEBUG_FORTH_MALLOC_GUARD 
9738 cc 5c c1				call z,malloc_error 
973b				endif 
973b			 
973b				 
973b c1				pop bc    ; get length 
973c d1				pop de   ;  get string start    
973d			 
973d				; hl has destination from malloc 
973d			 
973d eb				ex de, hl    ; prep for ldir 
973e			 
973e e5				push hl   ; save malloc area for DSP later 
973f			 
973f			if DEBUG_FORTH_PUSH 
973f						DMARK "PHc" 
973f				CALLMONITOR 
973f			endif	 
973f			 
973f			 
973f ed b0			ldir 
9741			 
9741			 
9741				; push malloc to data stack     macro?????  
9741			 
9741				FORTH_DSP_NEXT 
9741 cd 97 96			call macro_forth_dsp_next 
9744				endm 
# End of macro FORTH_DSP_NEXT
9744			 
9744				; save value and type 
9744			 
9744 2a 22 eb			ld hl, (cli_data_sp) 
9747			 
9747				; save item type 
9747 3e 01			ld a,  DS_TYPE_STR 
9749 77				ld (hl), a 
974a 23				inc hl 
974b			 
974b				; get malloc word off stack 
974b d1				pop de 
974c 73				ld (hl), e 
974d 23				inc hl 
974e 72				ld (hl), d 
974f			 
974f			 
974f			 
974f			if DEBUG_FORTH_PUSH 
974f				ld hl, (cli_data_sp) 
974f						DMARK "PHS" 
974f				CALLMONITOR 
974f			;	ex de,hl 
974f			endif	 
974f				; in case of spaces, skip the ptr past the copied string 
974f				;pop af 
974f				;ld (cli_origptr),hl 
974f			 
974f c9				ret 
9750			 
9750			 
9750			 
9750			; TODO ascii push input onto stack given hl to start of input 
9750			 
9750			; identify type 
9750			; if starts with a " then a string 
9750			; otherwise it is a number 
9750			;  
9750			; if a string 
9750			;     scan for ending " to get length of string to malloc for + 1 
9750			;     malloc 
9750			;     put pointer to string on stack first byte flags as string 
9750			; 
9750			; else a number 
9750			;    look for number format identifier 
9750			;    $xx hex 
9750			;    %xxxxx bin 
9750			;    xxxxx decimal 
9750			;    convert number to 16bit word.  
9750			;    malloc word + 1 with flag to identiy as num 
9750			;    put pointer to number on stack 
9750			;   
9750			;  
9750			  
9750			forth_apush: 
9750				; kernel push 
9750			 
9750			if DEBUG_FORTH_PUSH 
9750						DMARK "PSH" 
9750				CALLMONITOR 
9750			endif	 
9750				; identify input type 
9750			 
9750 7e				ld a,(hl) 
9751 fe 22			cp '"' 
9753 28 0a			jr z, .fapstr 
9755 fe 24			cp '$' 
9757 ca 7f 97			jp z, .faphex 
975a fe 25			cp '%' 
975c ca 67 97			jp z, .fapbin 
975f			;	cp 'b' 
975f			;	jp z, .fabin 
975f				; else decimal 
975f			 
975f				; TODO do decimal conversion 
975f				; decimal is stored as a 16bit word 
975f			 
975f				; by default everything is a string if type is not detected 
975f			.fapstr: ; 
975f fe 22			cp '"' 
9761 20 01			jr nz, .strnoqu 
9763 23				inc hl 
9764			.strnoqu: 
9764 c3 1a 97			jp forth_push_str 
9767			 
9767			 
9767			 
9767			.fapbin:    ; push a binary string.  
9767 11 00 00			ld de, 0   ; hold a 16bit value 
976a			 
976a 23			.fapbinshift:	inc hl  
976b 7e				ld a,(hl) 
976c fe 00			cp 0     ; done scanning  
976e 28 0b			jr z, .fapbdone  	; got it in HL so push  
9770			 
9770				; left shift de 
9770 eb				ex de, hl	 
9771 29				add hl, hl 
9772			 
9772				; is 1 
9772 fe 31			cp '1' 
9774 20 02			jr nz, .binzero 
9776 cb 4d			bit 1, l 
9778			.binzero: 
9778 eb				ex de, hl	 ; save current de 
9779 18 ef			jr .fapbinshift 
977b			 
977b			.fapbdone: 
977b eb				ex de, hl 
977c c3 08 97			jp forth_push_numhl 
977f			 
977f			 
977f			.faphex:   ; hex is always stored as a 16bit word 
977f				; skip number prefix 
977f 23				inc hl 
9780				; turn ascii into number 
9780 cd 6e 8d			call get_word_hl	; ret 16bit word in hl 
9783			 
9783 c3 08 97			jp forth_push_numhl 
9786			 
9786 00				 nop 
9787			 
9787			.fabin:   ; TODO bin conversion 
9787			 
9787			 
9787 c9				ret 
9788			 
9788			 
9788			; get either a string ptr or a 16bit word from the data stack 
9788			 
9788			FORTH_DSP: macro 
9788				call macro_forth_dsp 
9788				endm 
9788			 
9788			macro_forth_dsp: 
9788				; data stack pointer points to current word on tos 
9788			 
9788 2a 22 eb			ld hl,(cli_data_sp) 
978b			 
978b				if DEBUG_FORTH_PUSH 
978b						DMARK "DSP" 
978b			 
978b					call display_data_sp 
978b				;call break_point_state 
978b				;rst 030h 
978b				CALLMONITOR 
978b				endif 
978b			 
978b c9				ret 
978c			 
978c			; return hl to start of value on stack 
978c			 
978c			FORTH_DSP_VALUE: macro 
978c				call macro_forth_dsp_value 
978c				endm 
978c			 
978c			macro_forth_dsp_value: 
978c			 
978c				FORTH_DSP 
978c cd 88 97			call macro_forth_dsp 
978f				endm 
# End of macro FORTH_DSP
978f			 
978f d5				push de 
9790			 
9790 23				inc hl ; skip type 
9791			 
9791 5e				ld e, (hl) 
9792 23				inc hl 
9793 56				ld d, (hl) 
9794 eb				ex de,hl  
9795			 
9795 d1				pop de 
9796			 
9796 c9				ret 
9797			 
9797			; return hl to start of value to second item on stack 
9797			 
9797			FORTH_DSP_VALUEM1: macro 
9797				call macro_forth_dsp_value_m1 
9797				endm 
9797			 
9797			macro_forth_dsp_value_m1: 
9797			 
9797				FORTH_DSP 
9797 cd 88 97			call macro_forth_dsp 
979a				endm 
# End of macro FORTH_DSP
979a			 
979a 2b				dec hl 
979b 2b				dec hl 
979c			;	dec hl 
979c			 
979c d5				push de 
979d			 
979d 5e				ld e, (hl) 
979e 23				inc hl 
979f 56				ld d, (hl) 
97a0 eb				ex de,hl  
97a1			 
97a1 d1				pop de 
97a2			 
97a2 c9				ret 
97a3			 
97a3				 
97a3			 
97a3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
97a3			 
97a3			FORTH_DSP_POP: macro 
97a3				call macro_forth_dsp_pop 
97a3				endm 
97a3			 
97a3			 
97a3			; get the tos data type 
97a3			 
97a3			FORTH_DSP_TYPE:   macro 
97a3			 
97a3				;FORTH_DSP_VALUE 
97a3				FORTH_DSP 
97a3				 
97a3				; hl points to value 
97a3				; check type 
97a3			 
97a3				ld a,(hl) 
97a3			 
97a3				endm 
97a3			 
97a3			; load the tos value into hl 
97a3			 
97a3			 
97a3			FORTH_DSP_VALUEHL:  macro 
97a3				call macro_dsp_valuehl 
97a3				endm 
97a3			 
97a3			 
97a3			 
97a3			macro_dsp_valuehl: 
97a3				FORTH_DSP_VALUE 
97a3 cd 8c 97			call macro_forth_dsp_value 
97a6				endm 
# End of macro FORTH_DSP_VALUE
97a6			 
97a6				;FORTH_ERR_TOS_NOTNUM 
97a6			 
97a6				;inc hl   ; skip type id 
97a6			 
97a6			;	push de 
97a6			; 
97a6			;	ld e, (hl) 
97a6			;	inc hl 
97a6			;	ld d, (hl) 
97a6			;	ex de,hl  
97a6			 
97a6			;	pop de 
97a6			 
97a6				if DEBUG_FORTH_PUSH 
97a6						DMARK "DVL" 
97a6				CALLMONITOR 
97a6				endif 
97a6 c9				ret 
97a7			 
97a7			forth_apushstrhl:      
97a7				; push of string requires use of cli_origptr 
97a7				; bodge use 
97a7			 
97a7				; get current cli_origptr, save, update with temp pointer  
97a7 ed 5b 3e eb		ld de, (cli_origptr) 
97ab 22 3e eb			ld (cli_origptr), hl 
97ae d5				push de 
97af cd 50 97			call forth_apush 
97b2 d1				pop de 
97b3 ed 53 3e eb		ld (cli_origptr), de 
97b7 c9			        ret	 
97b8			 
97b8			 
97b8			; increase loop stack pointer and save hl to it 
97b8				 
97b8			FORTH_LOOP_NEXT: macro 
97b8				call macro_forth_loop_next 
97b8				;nop 
97b8				endm 
97b8			 
97b8			macro_forth_loop_next: 
97b8				if DEBUG_FORTH_STACK_GUARD 
97b8 cd f6 d1				call check_stacks 
97bb				endif 
97bb e5				push hl 
97bc d5				push de 
97bd eb				ex de,hl 
97be 2a 24 eb			ld hl,(cli_loop_sp) 
97c1 23				inc hl 
97c2 23				inc hl 
97c3					if DEBUG_FORTH_WORDS 
97c3						DMARK "LNX" 
97c3 f5				push af  
97c4 3a d8 97			ld a, (.dmark)  
97c7 32 7a ee			ld (debug_mark),a  
97ca 3a d9 97			ld a, (.dmark+1)  
97cd 32 7b ee			ld (debug_mark+1),a  
97d0 3a da 97			ld a, (.dmark+2)  
97d3 32 7c ee			ld (debug_mark+2),a  
97d6 18 03			jr .pastdmark  
97d8 ..			.dmark: db "LNX"  
97db f1			.pastdmark: pop af  
97dc			endm  
# End of macro DMARK
97dc						CALLMONITOR 
97dc cd 7b 91			call break_point_state  
97df				endm  
# End of macro CALLMONITOR
97df					endif 
97df 22 24 eb			ld (cli_loop_sp),hl 
97e2 73				ld (hl), e 
97e3 23				inc hl 
97e4 72				ld (hl), d 
97e5 d1				pop de    ; been reversed so save a swap on restore 
97e6 e1				pop hl 
97e7				if DEBUG_FORTH_STACK_GUARD 
97e7 cd f6 d1				call check_stacks 
97ea				endif 
97ea c9				ret 
97eb			 
97eb			; get current ret stack pointer and save to hl  
97eb				 
97eb			FORTH_LOOP_TOS: macro 
97eb				call macro_forth_loop_tos 
97eb				endm 
97eb			 
97eb			macro_forth_loop_tos: 
97eb d5				push de 
97ec 2a 24 eb			ld hl,(cli_loop_sp) 
97ef 5e				ld e, (hl) 
97f0 23				inc hl 
97f1 56				ld d, (hl) 
97f2 eb				ex de, hl 
97f3 d1				pop de 
97f4 c9				ret 
97f5			 
97f5			; pop loop stack pointer 
97f5				 
97f5			FORTH_LOOP_POP: macro 
97f5				call macro_forth_loop_pop 
97f5				endm 
97f5			 
97f5			 
97f5			macro_forth_loop_pop: 
97f5				if DEBUG_FORTH_STACK_GUARD 
97f5					DMARK "LPP" 
97f5 f5				push af  
97f6 3a 0a 98			ld a, (.dmark)  
97f9 32 7a ee			ld (debug_mark),a  
97fc 3a 0b 98			ld a, (.dmark+1)  
97ff 32 7b ee			ld (debug_mark+1),a  
9802 3a 0c 98			ld a, (.dmark+2)  
9805 32 7c ee			ld (debug_mark+2),a  
9808 18 03			jr .pastdmark  
980a ..			.dmark: db "LPP"  
980d f1			.pastdmark: pop af  
980e			endm  
# End of macro DMARK
980e cd f6 d1				call check_stacks 
9811					FORTH_CHK_LOOP_UNDER 
9811 e5				push hl 
9812 d5				push de 
9813 2a 24 eb			ld hl,(cli_loop_sp) 
9816 11 de e9			ld de, cli_loop_stack 
9819 cd d5 89			call cmp16 
981c da 10 d3			jp c, fault_loop_under 
981f d1				pop de 
9820 e1				pop hl 
9821				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9821				endif 
9821 e5				push hl 
9822 2a 24 eb			ld hl,(cli_loop_sp) 
9825 2b				dec hl 
9826 2b				dec hl 
9827 22 24 eb			ld (cli_loop_sp), hl 
982a				; TODO do stack underflow checks 
982a e1				pop hl 
982b				if DEBUG_FORTH_STACK_GUARD 
982b cd f6 d1				call check_stacks 
982e					FORTH_CHK_LOOP_UNDER 
982e e5				push hl 
982f d5				push de 
9830 2a 24 eb			ld hl,(cli_loop_sp) 
9833 11 de e9			ld de, cli_loop_stack 
9836 cd d5 89			call cmp16 
9839 da 10 d3			jp c, fault_loop_under 
983c d1				pop de 
983d e1				pop hl 
983e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
983e				endif 
983e c9				ret 
983f			 
983f			macro_forth_dsp_pop: 
983f			 
983f e5				push hl 
9840			 
9840				; release malloc data 
9840			 
9840				if DEBUG_FORTH_STACK_GUARD 
9840 cd f6 d1				call check_stacks 
9843					FORTH_CHK_DSP_UNDER 
9843 e5				push hl 
9844 d5				push de 
9845 2a 22 eb			ld hl,(cli_data_sp) 
9848 11 dc e8			ld de, cli_data_stack 
984b cd d5 89			call cmp16 
984e da 04 d3			jp c, fault_dsp_under 
9851 d1				pop de 
9852 e1				pop hl 
9853				endm 
# End of macro FORTH_CHK_DSP_UNDER
9853				endif 
9853				;ld hl,(cli_data_sp) 
9853			if DEBUG_FORTH_DOT 
9853				DMARK "DPP" 
9853				CALLMONITOR 
9853			endif	 
9853			 
9853			 
9853			if FORTH_ENABLE_DSPPOPFREE 
9853			 
9853				FORTH_DSP 
9853 cd 88 97			call macro_forth_dsp 
9856				endm 
# End of macro FORTH_DSP
9856			 
9856 7e				ld a, (hl) 
9857 fe 01			cp DS_TYPE_STR 
9859 20 07			jr nz, .skippopfree 
985b			 
985b				FORTH_DSP_VALUEHL 
985b cd a3 97			call macro_dsp_valuehl 
985e				endm 
# End of macro FORTH_DSP_VALUEHL
985e 00				nop 
985f			if DEBUG_FORTH_DOT 
985f				DMARK "DPf" 
985f				CALLMONITOR 
985f			endif	 
985f cd 48 8f			call free 
9862			.skippopfree: 
9862				 
9862			 
9862			endif 
9862			 
9862			if DEBUG_FORTH_DOT_KEY 
9862				DMARK "DP2" 
9862				CALLMONITOR 
9862			endif	 
9862			 
9862				; move pointer down 
9862			 
9862 2a 22 eb			ld hl,(cli_data_sp) 
9865 2b				dec hl 
9866 2b				dec hl 
9867			; PARSEV5 
9867 2b				dec hl 
9868 22 22 eb			ld (cli_data_sp), hl 
986b			 
986b				if DEBUG_FORTH_STACK_GUARD 
986b cd f6 d1				call check_stacks 
986e					FORTH_CHK_DSP_UNDER 
986e e5				push hl 
986f d5				push de 
9870 2a 22 eb			ld hl,(cli_data_sp) 
9873 11 dc e8			ld de, cli_data_stack 
9876 cd d5 89			call cmp16 
9879 da 04 d3			jp c, fault_dsp_under 
987c d1				pop de 
987d e1				pop hl 
987e				endm 
# End of macro FORTH_CHK_DSP_UNDER
987e				endif 
987e			 
987e e1				pop hl 
987f			 
987f c9				ret 
9880			 
9880			getwordathl: 
9880				; hl points to an address 
9880				; load hl with the word at that address 
9880			 
9880 d5				push de 
9881			 
9881 5e				ld e, (hl) 
9882 23				inc hl 
9883 56				ld d, (hl) 
9884 eb				ex de, hl 
9885			 
9885 d1				pop de 
9886 c9				ret 
9887			 
9887			 
9887			 
9887			 
9887			 
9887			; eof 
9887			 
# End of file forth_stackopsv5.asm
9887			endif 
9887			 
9887			user_word_eol:  
9887				; hl contains the pointer to where to create a linked list item from the end 
9887				; of the user dict to continue on at the system word dict 
9887				 
9887				; poke the stub of the word list linked list to repoint to rom words 
9887			 
9887				; stub format 
9887				; db   word id 
9887				; dw    link to next word 
9887			        ; db char length of token 
9887				; db string + 0 term 
9887				; db exec code....  
9887			 
9887 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9889 77				ld (hl), a		; word id 
988a 23				inc hl 
988b			 
988b 11 51 9a			ld de, sysdict 
988e 73				ld (hl), e		; next word link ie system dict 
988f 23				inc hl 
9890 72				ld (hl), d		; next word link ie system dict 
9891 23				inc hl	 
9892			 
9892			;	ld (hl), sysdict		; next word link ie system dict 
9892			;	inc hl 
9892			;	inc hl 
9892			 
9892			;	inc hl 
9892			;	inc hl 
9892			 
9892 3e 02			ld a, 2			; word length is 0 
9894 77				ld (hl), a	 
9895 23				inc hl 
9896			 
9896 3e 7e			ld a, '~'			; word length is 0 
9898 77				ld (hl), a	 
9899 23				inc hl 
989a 3e 00			ld a, 0			; save empty word 
989c 77				ld (hl), a 
989d			 
989d c9				ret 
989e			 
989e				 
989e			 
989e			forthexec_cleanup: 
989e				FORTH_RSP_POP 
989e cd d0 96			call macro_forth_rsp_pop 
98a1				endm 
# End of macro FORTH_RSP_POP
98a1 c9				ret 
98a2			 
98a2			forth_call_hl: 
98a2				; taking hl 
98a2 e5				push hl 
98a3 c9				ret 
98a4			 
98a4			; this is called to reset Forth system but keep existing uwords etc 
98a4			 
98a4			forth_warmstart: 
98a4				; setup stack over/under flow checks 
98a4				if DEBUG_FORTH_STACK_GUARD 
98a4 cd dc d1				call chk_stk_init 
98a7				endif 
98a7			 
98a7				; init stack pointers  - * these stacks go upwards *  
98a7 21 e0 ea			ld hl, cli_ret_stack 
98aa 22 26 eb			ld (cli_ret_sp), hl	 
98ad				; set bottom of stack 
98ad 3e 00			ld a,0 
98af 77				ld (hl),a 
98b0 23				inc hl 
98b1 77				ld (hl),a 
98b2			 
98b2 21 dc e8			ld hl, cli_data_stack 
98b5 22 22 eb			ld (cli_data_sp), hl	 
98b8				; set bottom of stack 
98b8 3e 00			ld a,0 
98ba 77				ld (hl),a 
98bb 23				inc hl 
98bc 77				ld (hl),a 
98bd			 
98bd 21 de e9			ld hl, cli_loop_stack 
98c0 22 24 eb			ld (cli_loop_sp), hl	 
98c3				; set bottom of stack 
98c3 3e 00			ld a,0 
98c5 77				ld (hl),a 
98c6 23				inc hl 
98c7 77				ld (hl),a 
98c8			 
98c8				; init extent of current open file 
98c8			 
98c8 3e 00			ld a, 0 
98ca 32 5c eb			ld (store_openext), a 
98cd			 
98cd c9				ret 
98ce			 
98ce			 
98ce			; Cold Start - this is called to setup the whole Forth system 
98ce			 
98ce			forth_init: 
98ce			 
98ce				; setup stack over/under flow checks 
98ce			 
98ce			;	if DEBUG_FORTH_STACK_GUARD 
98ce			;		call chk_stk_init 
98ce			;	endif 
98ce			 
98ce				; enable auto display updates (slow.....) 
98ce			 
98ce 3e 01			ld a, 1 
98d0 32 3c eb			ld (cli_autodisplay), a 
98d3			 
98d3			 
98d3			 
98d3				; show start up screen 
98d3			 
98d3 cd 5e 88			call clear_display 
98d6			 
98d6 3e 00			ld a,0 
98d8 32 5e eb			ld (f_cursor_ptr), a 
98db			 
98db				; set start of word list in start of ram - for use when creating user words 
98db			 
98db 21 a7 d4			ld hl, baseram 
98de 22 72 e6			ld (os_last_new_uword), hl 
98e1 cd 87 98			call user_word_eol 
98e4				 
98e4			;		call display_data_sp 
98e4			;		call next_page_prompt 
98e4			 
98e4			 
98e4			 
98e4			 
98e4 c9				ret 
98e5			 
98e5 .. 00		.bootforth: db " Forth Kernel Init ",0 
98f9			 
98f9			; TODO push to stack 
98f9			 
98f9			;  
98f9			 
98f9			if FORTH_PARSEV2 
98f9			 
98f9			 
98f9				include "forth_parserv2.asm" 
98f9			 
98f9			endif 
98f9			 
98f9			 
98f9			; parse cli version 1 
98f9			 
98f9			if FORTH_PARSEV1 
98f9			 
98f9			 
98f9			 
98f9			      include "forth_parserv1.asm" 
98f9			endif 
98f9				 
98f9			if FORTH_PARSEV3 
98f9			 
98f9			 
98f9			 
98f9			      include "forth_parserv3.asm" 
98f9				include "forth_wordsv3.asm" 
98f9			endif 
98f9			 
98f9			if FORTH_PARSEV4 
98f9			 
98f9			 
98f9			 
98f9			      include "forth_parserv4.asm" 
98f9				include "forth_wordsv4.asm" 
98f9			endif 
98f9			 
98f9			if FORTH_PARSEV5 
98f9			 
98f9			 
98f9			 
98f9			      include "forth_parserv5.asm" 
98f9			 
98f9			 
98f9			; A better parser without using malloc and string copies all over the place.  
98f9			; Exec in situ should be faster 
98f9			 
98f9			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
98f9			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
98f9			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
98f9			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
98f9			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
98f9			WORD_SYS_END: equ 0   ; Opcode for all user words 
98f9			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
98f9			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
98f9			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
98f9			 
98f9			; Core word preamble macro 
98f9			 
98f9			CWHEAD:   macro nxtword opcode lit len opflags 
98f9				db WORD_SYS_CORE+opcode             
98f9				; internal op code number 
98f9				dw nxtword            
98f9				; link to next dict word block 
98f9				db len + 1 
98f9				; literal length of dict word inc zero term 
98f9				db lit,0              
98f9				; literal dict word 
98f9			        ; TODO db opflags        
98f9				endm 
98f9			 
98f9			 
98f9			NEXTW: macro  
98f9				jp macro_next 
98f9				endm 
98f9			 
98f9			macro_next: 
98f9			if DEBUG_FORTH_PARSE_KEY 
98f9				DMARK "NXT" 
98f9				CALLMONITOR 
98f9			endif	 
98f9			;	inc hl  ; skip token null term  
98f9 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
98fd ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9901 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9904			if DEBUG_FORTH_PARSE_KEY 
9904				DMARK "}AA" 
9904				CALLMONITOR 
9904			endif	 
9904 c3 07 9a			jp execnext 
9907				;jp exec1 
9907			       
9907			 
9907			 
9907			; Another go at the parser to compile  
9907			 
9907			 
9907			; TODO rework parser to change all of the string words to byte tokens 
9907			; TODO do a search for  
9907			 
9907			; TODO first run normal parser to zero term sections 
9907			; TODO for each word do a token look up to get the op code 
9907			; TODO need some means to flag to the exec that this is a byte code form    
9907			 
9907			 
9907			forthcompile: 
9907			 
9907			; 
9907			; line parse: 
9907			;       parse raw input buffer 
9907			;       tokenise the words 
9907			;       malloc new copy (for looping etc) 
9907			;       copy to malloc + current pc in line to start of string and add line term 
9907			;       save on new rsp 
9907			; 
9907			 
9907			; hl to point to the line to tokenise 
9907			 
9907			;	push hl 
9907 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
990a			 
990a			;	ld a,0		; string term on input 
990a			;	call strlent 
990a			 
990a			;	ld (os_tok_len), hl	 ; save string length 
990a			 
990a			;if DEBUG_FORTH_TOK 
990a			;	ex de,hl		 
990a			;endif 
990a			 
990a			;	pop hl 		; get back string pointer 
990a			 
990a			if DEBUG_FORTH_TOK 
990a						DMARK "TOc" 
990a				CALLMONITOR 
990a			endif 
990a 7e			.cptoken2:    ld a,(hl) 
990b 23				inc hl 
990c fe 7f			cp FORTH_END_BUFFER 
990e 28 29			jr z, .cptokendone2 
9910 fe 00			cp 0 
9912 28 25			jr z, .cptokendone2 
9914 fe 22			cp '"' 
9916 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9918 fe 20			cp ' ' 
991a 20 ee			jr nz,  .cptoken2 
991c			 
991c			; TODO consume comments held between ( and ) 
991c			 
991c				; we have a space so change to zero term for dict match later 
991c 2b				dec hl 
991d 3e 00			ld a,0 
991f 77				ld (hl), a 
9920 23				inc hl 
9921 18 e7			jr .cptoken2 
9923				 
9923			 
9923			.cptokenstr2: 
9923				; skip all white space until either eol (because forgot to term) or end double quote 
9923			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9923				;inc hl ; skip current double quote 
9923 7e				ld a,(hl) 
9924 23				inc hl 
9925 fe 22			cp '"' 
9927 28 e1			jr z, .cptoken2 
9929 fe 7f			cp FORTH_END_BUFFER 
992b 28 0c			jr z, .cptokendone2 
992d fe 00			cp 0 
992f 28 08			jr z, .cptokendone2 
9931 fe 20			cp ' ' 
9933 28 02			jr z, .cptmp2 
9935 18 ec			jr .cptokenstr2 
9937			 
9937			.cptmp2:	; we have a space so change to zero term for dict match later 
9937				;dec hl 
9937				;ld a,"-"	; TODO remove this when working 
9937				;ld (hl), a 
9937				;inc hl 
9937 18 ea			jr .cptokenstr2 
9939			 
9939			.cptokendone2: 
9939				;inc hl 
9939 3e 7f			ld a, FORTH_END_BUFFER 
993b 77				ld (hl),a 
993c 23				inc hl 
993d 3e 21			ld a, '!' 
993f 77				ld (hl),a 
9940			 
9940 2a 76 e6			ld hl,(os_tok_ptr) 
9943			         
9943			if DEBUG_FORTH_TOK 
9943						DMARK "Tc1" 
9943				CALLMONITOR 
9943			endif 
9943			 
9943				; push exec string to top of return stack 
9943				FORTH_RSP_NEXT 
9943 cd af 96			call macro_forth_rsp_next 
9946				endm 
# End of macro FORTH_RSP_NEXT
9946 c9				ret 
9947			 
9947			; Another go at the parser need to simplify the process 
9947			 
9947			forthparse: 
9947			 
9947			; 
9947			; line parse: 
9947			;       parse raw input buffer 
9947			;       tokenise the words 
9947			;       malloc new copy (for looping etc) 
9947			;       copy to malloc + current pc in line to start of string and add line term 
9947			;       save on new rsp 
9947			; 
9947			 
9947			; hl to point to the line to tokenise 
9947			 
9947			;	push hl 
9947 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
994a			 
994a			;	ld a,0		; string term on input 
994a			;	call strlent 
994a			 
994a			;	ld (os_tok_len), hl	 ; save string length 
994a			 
994a			;if DEBUG_FORTH_TOK 
994a			;	ex de,hl		 
994a			;endif 
994a			 
994a			;	pop hl 		; get back string pointer 
994a			 
994a			if DEBUG_FORTH_TOK 
994a						DMARK "TOK" 
994a				CALLMONITOR 
994a			endif 
994a 7e			.ptoken2:    ld a,(hl) 
994b 23				inc hl 
994c fe 7f			cp FORTH_END_BUFFER 
994e 28 29			jr z, .ptokendone2 
9950 fe 00			cp 0 
9952 28 25			jr z, .ptokendone2 
9954 fe 22			cp '"' 
9956 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9958 fe 20			cp ' ' 
995a 20 ee			jr nz,  .ptoken2 
995c			 
995c			; TODO consume comments held between ( and ) 
995c			 
995c				; we have a space so change to zero term for dict match later 
995c 2b				dec hl 
995d 3e 00			ld a,0 
995f 77				ld (hl), a 
9960 23				inc hl 
9961 18 e7			jr .ptoken2 
9963				 
9963			 
9963			.ptokenstr2: 
9963				; skip all white space until either eol (because forgot to term) or end double quote 
9963			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9963				;inc hl ; skip current double quote 
9963 7e				ld a,(hl) 
9964 23				inc hl 
9965 fe 22			cp '"' 
9967 28 e1			jr z, .ptoken2 
9969 fe 7f			cp FORTH_END_BUFFER 
996b 28 0c			jr z, .ptokendone2 
996d fe 00			cp 0 
996f 28 08			jr z, .ptokendone2 
9971 fe 20			cp ' ' 
9973 28 02			jr z, .ptmp2 
9975 18 ec			jr .ptokenstr2 
9977			 
9977			.ptmp2:	; we have a space so change to zero term for dict match later 
9977				;dec hl 
9977				;ld a,"-"	; TODO remove this when working 
9977				;ld (hl), a 
9977				;inc hl 
9977 18 ea			jr .ptokenstr2 
9979			 
9979			.ptokendone2: 
9979				;inc hl 
9979 3e 7f			ld a, FORTH_END_BUFFER 
997b 77				ld (hl),a 
997c 23				inc hl 
997d 3e 21			ld a, '!' 
997f 77				ld (hl),a 
9980			 
9980 2a 76 e6			ld hl,(os_tok_ptr) 
9983			         
9983			if DEBUG_FORTH_TOK 
9983						DMARK "TK1" 
9983				CALLMONITOR 
9983			endif 
9983			 
9983				; push exec string to top of return stack 
9983				FORTH_RSP_NEXT 
9983 cd af 96			call macro_forth_rsp_next 
9986				endm 
# End of macro FORTH_RSP_NEXT
9986 c9				ret 
9987			 
9987			; 
9987			;	; malloc size + buffer pointer + if is loop flag 
9987			;	ld hl,(os_tok_len) 		 ; get string length 
9987			; 
9987			;	ld a,l 
9987			; 
9987			;	cp 0			; we dont want to use a null string 
9987			;	ret z 
9987			; 
9987			;;	add 3    ; prefix malloc with buffer for current word ptr 
9987			; 
9987			;	add 5     ; TODO when certain not over writing memory remove 
9987			; 
9987			;		 
9987			; 
9987			;if DEBUG_FORTH_TOK 
9987			;			DMARK "TKE" 
9987			;	CALLMONITOR 
9987			;endif 
9987			; 
9987			;	ld l,a 
9987			;	ld h,0 
9987			;;	push hl   ; save required space for the copy later 
9987			;	call malloc 
9987			;if DEBUG_FORTH_TOK 
9987			;			DMARK "TKM" 
9987			;	CALLMONITOR 
9987			;endif 
9987			;	if DEBUG_FORTH_MALLOC_GUARD 
9987			;		push af 
9987			;		call ishlzero 
9987			;;		ld a, l 
9987			;;		add h 
9987			;;		cp 0 
9987			;		pop af 
9987			;		 
9987			;		call z,malloc_error 
9987			;	endif 
9987			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9987			; 
9987			; 
9987			;if DEBUG_FORTH_TOK 
9987			;			DMARK "TKR" 
9987			;	CALLMONITOR 
9987			;endif 
9987			; 
9987			;	FORTH_RSP_NEXT 
9987			; 
9987			;	;inc hl	 ; go past current buffer pointer 
9987			;	;inc hl 
9987			;	;inc hl   ; and past if loop flag 
9987			;		; TODO Need to set flag  
9987			; 
9987			;	 
9987			;	 
9987			;	ex de,hl	; malloc is dest 
9987			;	ld hl, (os_tok_len) 
9987			;;	pop bc 
9987			;	ld c, l                
9987			;	ld b,0 
9987			;	ld hl, (os_tok_ptr) 
9987			; 
9987			;if DEBUG_FORTH_TOK 
9987			;			DMARK "TKT" 
9987			;	CALLMONITOR 
9987			;endif 
9987			; 
9987			;	; do str cpy 
9987			; 
9987			;	ldir      ; copy byte in hl to de 
9987			; 
9987			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9987			; 
9987			;if DEBUG_FORTH_TOK 
9987			; 
9987			;			DMARK "TKY" 
9987			;	CALLMONITOR 
9987			;endif 
9987			;	;ld a,0 
9987			;	;ld a,FORTH_END_BUFFER 
9987			;	ex de, hl 
9987			;	;dec hl			 ; go back over the space delim at the end of word 
9987			;	;ld (hl),a 
9987			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9987			;	ld a,FORTH_END_BUFFER 
9987			;	ld (hl),a 
9987			;	inc hl 
9987			;	ld a,FORTH_END_BUFFER 
9987			;	ld (hl),a 
9987			; 
9987			;	; init the malloc area data 
9987			;	; set pc for in current area 
9987			;	;ld hl, (os_tok_malloc) 
9987			;	;inc hl 
9987			;	;inc hl 
9987			;	;inc hl 
9987			;	;ex de,hl 
9987			;	;ld hl, (os_tok_malloc) 
9987			;	;ld (hl),e 
9987			;	;inc hl 
9987			;	;ld (hl),d 
9987			; 
9987			; 
9987			;	ld hl,(os_tok_malloc) 
9987			;if DEBUG_FORTH_PARSE_KEY 
9987			;			DMARK "TKU" 
9987			;	CALLMONITOR 
9987			;endif 
9987			; 
9987			;	ret 
9987			 
9987			forthexec: 
9987			 
9987			; line exec: 
9987			; forth parser 
9987			 
9987			; 
9987			;       get current exec line on rsp 
9987			 
9987				FORTH_RSP_TOS 
9987 cd c6 96			call macro_forth_rsp_tos 
998a				endm 
# End of macro FORTH_RSP_TOS
998a			 
998a			;       restore current pc - hl points to malloc of data 
998a			 
998a				;ld e, (hl) 
998a				;inc hl 
998a				;ld d, (hl) 
998a				;ex de,hl 
998a			 
998a			 
998a			exec1: 
998a 22 76 e6			ld (os_tok_ptr), hl 
998d			 
998d				; copy our PC to working vars  
998d 22 40 eb			ld (cli_ptr), hl 
9990 22 3e eb			ld (cli_origptr), hl 
9993			 
9993 7e				ld a,(hl) 
9994 fe 7f			cp FORTH_END_BUFFER 
9996 c8				ret z 
9997			 
9997				; skip any nulls 
9997			 
9997 fe 00			cp 0 
9999 20 03			jr nz, .execword 
999b 23				inc hl 
999c 18 ec			jr exec1 
999e			 
999e			 
999e			.execword: 
999e			 
999e			 
999e			 
999e			if DEBUG_FORTH_PARSE_KEY 
999e						DMARK "KYQ" 
999e				CALLMONITOR 
999e			endif 
999e			;       while at start of word: 
999e			; get start of dict (in user area first) 
999e			 
999e 21 a7 d4		ld hl, baseram 
99a1			;ld hl, sysdict 
99a1 22 42 eb		ld (cli_nextword),hl 
99a4			;           match word at pc 
99a4			;           exec word 
99a4			;           or push to dsp 
99a4			;           forward to next token 
99a4			;           if line term pop rsp and exit 
99a4			;        
99a4			 
99a4			if DEBUG_FORTH_PARSE_KEY 
99a4						DMARK "KYq" 
99a4				CALLMONITOR 
99a4			endif 
99a4			 
99a4			; 
99a4			; word comp 
99a4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
99a4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
99a4			;    move to start of word  
99a4			;    compare word to cli_token 
99a4			 
99a4			.execpnword:	; HL at start of a word in the dictionary to check 
99a4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
99a4			;	ld (cli_ptr), hl 
99a4			 
99a4 2a 42 eb			ld hl,(cli_nextword) 
99a7			 
99a7 cd 4a 9a			call forth_tok_next 
99aa			; tok next start here 
99aa			;	; TODO skip compiled symbol for now 
99aa			;	inc hl 
99aa			; 
99aa			;	; save pointer to next word 
99aa			; 
99aa			;	; hl now points to the address of the next word pointer  
99aa			;	ld e, (hl) 
99aa			;	inc hl 
99aa			;	ld d, (hl) 
99aa			;	inc l 
99aa			; 
99aa			;	ex de,hl 
99aa			;if DEBUG_FORTH_PARSE_NEXTWORD 
99aa			;	push bc 
99aa			;	ld bc, (cli_nextword) 
99aa			;			DMARK "NXW" 
99aa			;	CALLMONITOR 
99aa			;	pop bc 
99aa			;endif 
99aa			; tok next end here 
99aa 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
99ad eb				ex de, hl 
99ae			 
99ae			 
99ae				; save the pointer of the current token - 1 to check against 
99ae				 
99ae 22 46 eb			ld (cli_token), hl   
99b1				; TODO maybe remove below save if no debug 
99b1				; save token string ptr for any debug later 
99b1 23				inc hl  
99b2 22 48 eb			ld (cli_origtoken), hl 
99b5 2b				dec hl 
99b6				; save pointer to the start of the next dictionay word 
99b6 7e				ld a,(hl)   ; get string length 
99b7 47				ld b,a 
99b8			.execpnwordinc:  
99b8 23				inc hl 
99b9 10 fd			djnz .execpnwordinc 
99bb 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
99be			 
99be				; now check the word token against the string being parsed 
99be			 
99be 2a 46 eb			ld hl,(cli_token) 
99c1 23				inc hl     ; skip string length (use zero term instead to end) 
99c2 22 46 eb			ld (cli_token), hl 
99c5			 
99c5			if DEBUG_FORTH_PARSE_KEY 
99c5						DMARK "KY2" 
99c5			endif 
99c5			if DEBUG_FORTH_PARSE_EXEC 
99c5				; see if disabled 
99c5			 
99c5				ld a, (os_view_disable) 
99c5				cp '*' 
99c5				jr z, .skip 
99c5			 
99c5				push hl 
99c5				push hl 
99c5				call clear_display 
99c5				ld de, .compword 
99c5				ld a, display_row_1 
99c5				call str_at_display 
99c5				pop de 
99c5				ld a, display_row_2 
99c5				call str_at_display 
99c5				ld hl,(cli_ptr) 
99c5				ld a,(hl) 
99c5			        ld hl, os_word_scratch 
99c5				ld (hl),a 
99c5				ld a,0 
99c5				inc hl 
99c5				ld (hl),a 	 
99c5				ld de, os_word_scratch 
99c5				ld a, display_row_2+10 
99c5				call str_at_display 
99c5				call update_display 
99c5				ld a, 100 
99c5				call aDelayInMS 
99c5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
99c5				call delay250ms 
99c5				endif 
99c5				pop hl 
99c5			.skip:  
99c5			endif	 
99c5			.execpnchar:    ; compare char between token and string to parse 
99c5			 
99c5			if DEBUG_FORTH_PARSE_KEY 
99c5						DMARK "Ky3" 
99c5			endif 
99c5			if DEBUG_FORTH_PARSE_EXEC 
99c5				; see if disabled 
99c5			 
99c5				ld a, (os_view_disable) 
99c5				cp '*' 
99c5				jr z, .skip2 
99c5			 
99c5			;	call clear_display 
99c5			ld hl,(cli_token) 
99c5			ld a,(hl) 
99c5			ld (os_word_scratch),a 
99c5				ld hl,(cli_ptr) 
99c5			ld a,(hl) 
99c5				ld (os_word_scratch+1),a 
99c5				ld a,0 
99c5				ld (os_word_scratch+2),a 
99c5				ld de,os_word_scratch 
99c5				ld a,display_row_4 
99c5				call str_at_display 
99c5				call update_display 
99c5			.skip2:  
99c5			endif 
99c5 2a 46 eb			ld hl,(cli_token) 
99c8 7e				ld a, (hl)	 ; char in word token 
99c9 23				inc hl 		; move to next char 
99ca 22 46 eb			ld (cli_token), hl ; and save it 
99cd 47				ld b,a 
99ce			 
99ce 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
99d1 7e				ld a,(hl) 
99d2 23				inc hl 
99d3 22 40 eb			ld (cli_ptr), hl		; move to next char 
99d6 cd 0c 8e			call toUpper 		; make sure the input string matches case 
99d9			 
99d9			if DEBUG_FORTH_PARSE 
99d9			endif 
99d9			 
99d9				; input stream end of token is a space so get rid of it 
99d9			 
99d9			;	cp ' ' 
99d9			;	jr nz, .pnskipspace 
99d9			; 
99d9			;	ld a, 0		; make same term as word token term 
99d9			; 
99d9			;.pnskipspace: 
99d9			 
99d9			if DEBUG_FORTH_PARSE_KEY 
99d9						DMARK "KY7" 
99d9			endif 
99d9 b8				cp b 
99da c2 f0 99			jp nz, .execpnskipword	 ; no match so move to next word 
99dd				 
99dd			;    if same 
99dd			;       scan for string terms 0 for token and 32 for input 
99dd			 
99dd				 
99dd			if DEBUG_FORTH_PARSE_KEY 
99dd						DMARK "KY8" 
99dd			endif 
99dd			 
99dd 80				add b			 
99de fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
99e0							; TODO need to make sure last word in zero term string is accounted for 
99e0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
99e2			 
99e2			 
99e2				; at end of both strings so both are exact match 
99e2			 
99e2			;       skip ptr for next word 
99e2			 
99e2 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
99e5 23				inc hl			 ; at next char 
99e6 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
99e9 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
99ec				 
99ec				 
99ec			if DEBUG_FORTH_PARSE_KEY 
99ec						DMARK "KY3" 
99ec			endif 
99ec			 
99ec			 
99ec			 
99ec			;       exec code block 
99ec			if DEBUG_FORTH_JP 
99ec				call clear_display 
99ec				call update_display 
99ec				call delay1s 
99ec				ld hl, (cli_execword)     ; save for next check if no match on this word 
99ec				ld a,h 
99ec				ld hl, os_word_scratch 
99ec				call hexout 
99ec				ld hl, (cli_execword)     ; save for next check if no match on this word 
99ec				ld a,l 
99ec				ld hl, os_word_scratch+2 
99ec				call hexout 
99ec				ld hl, os_word_scratch+4 
99ec				ld a,0 
99ec				ld (hl),a 
99ec				ld de,os_word_scratch 
99ec				call str_at_display 
99ec					ld a, display_row_2 
99ec					call str_at_display 
99ec				ld de, (cli_origtoken) 
99ec				ld a, display_row_1+10 
99ec					call str_at_display 
99ec			 
99ec				ld a,display_row_1 
99ec				ld de, .foundword 
99ec				ld a, display_row_3 
99ec				call str_at_display 
99ec				call update_display 
99ec				call delay1s 
99ec				call delay1s 
99ec				call delay1s 
99ec			endif 
99ec			 
99ec			if DEBUG_FORTH_PARSE_KEY 
99ec						DMARK "KYj" 
99ec			endif 
99ec				; TODO save the word pointer in this exec 
99ec			 
99ec 2a 44 eb			ld hl,(cli_execword) 
99ef e9				jp (hl) 
99f0			 
99f0			 
99f0			;    if not same 
99f0			;	scan for zero term 
99f0			;	get ptr for next word 
99f0			;	goto word comp 
99f0			 
99f0			.execpnskipword:	; get pointer to next word 
99f0 2a 42 eb			ld hl,(cli_nextword) 
99f3			 
99f3 7e				ld a,(hl) 
99f4 fe 00			cp WORD_SYS_END 
99f6			;	cp 0 
99f6 28 09			jr z, .execendofdict			 ; at end of words 
99f8			 
99f8			if DEBUG_FORTH_PARSE_KEY 
99f8						DMARK "KY4" 
99f8			endif 
99f8			if DEBUG_FORTH_PARSE_EXEC 
99f8			 
99f8				; see if disabled 
99f8			 
99f8				ld a, (os_view_disable) 
99f8				cp '*' 
99f8				jr z, .noskip 
99f8			 
99f8			 
99f8				ld de, .nowordfound 
99f8				ld a, display_row_3 
99f8				call str_at_display 
99f8				call update_display 
99f8				ld a, 100 
99f8				call aDelayInMS 
99f8				 
99f8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
99f8					call delay250ms 
99f8				endif 
99f8			.noskip:  
99f8			 
99f8			endif	 
99f8			 
99f8 2a 3e eb			ld hl,(cli_origptr) 
99fb 22 40 eb			ld (cli_ptr),hl 
99fe			 
99fe			if DEBUG_FORTH_PARSE_KEY 
99fe						DMARK "KY5" 
99fe			endif 
99fe c3 a4 99			jp .execpnword			; else go to next word 
9a01			 
9a01			.execendofdict:  
9a01			 
9a01			if DEBUG_FORTH_PARSE_KEY 
9a01						DMARK "KYe" 
9a01			endif 
9a01			if DEBUG_FORTH_PARSE_EXEC 
9a01				; see if disabled 
9a01			 
9a01				ld a, (os_view_disable) 
9a01				cp '*' 
9a01				jr z, .ispskip 
9a01			 
9a01				call clear_display 
9a01				call update_display 
9a01				call delay1s 
9a01				ld de, (cli_origptr) 
9a01				ld a, display_row_1 
9a01				call str_at_display 
9a01				 
9a01				ld de, .enddict 
9a01				ld a, display_row_3 
9a01				call str_at_display 
9a01				call update_display 
9a01				ld a, 100 
9a01				call aDelayInMS 
9a01				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9a01				call delay1s 
9a01				call delay1s 
9a01				call delay1s 
9a01				endif 
9a01			.ispskip:  
9a01				 
9a01			endif	 
9a01			 
9a01			 
9a01			 
9a01				; if the word is not a keyword then must be a literal so push it to stack 
9a01			 
9a01			; push token to stack to end of word 
9a01			 
9a01				STACKFRAME ON $1efe $2f9f 
9a01				if DEBUG_STACK_IMB 
9a01					if ON 
9a01						exx 
9a01						ld de, $1efe 
9a01						ld a, d 
9a01						ld hl, curframe 
9a01						call hexout 
9a01						ld a, e 
9a01						ld hl, curframe+2 
9a01						call hexout 
9a01						ld hl, $1efe 
9a01						push hl 
9a01						ld hl, $2f9f 
9a01						push hl 
9a01						exx 
9a01					endif 
9a01				endif 
9a01			endm 
# End of macro STACKFRAME
9a01			 
9a01 2a 76 e6		ld hl,(os_tok_ptr) 
9a04 cd 50 97		call forth_apush 
9a07			 
9a07				STACKFRAMECHK ON $1efe $2f9f 
9a07				if DEBUG_STACK_IMB 
9a07					if ON 
9a07						exx 
9a07						ld hl, $2f9f 
9a07						pop de   ; $2f9f 
9a07						call cmp16 
9a07						jr nz, .spnosame 
9a07						ld hl, $1efe 
9a07						pop de   ; $1efe 
9a07						call cmp16 
9a07						jr z, .spfrsame 
9a07						.spnosame: call showsperror 
9a07						.spfrsame: nop 
9a07						exx 
9a07					endif 
9a07				endif 
9a07			endm 
# End of macro STACKFRAMECHK
9a07			 
9a07			execnext: 
9a07			 
9a07			if DEBUG_FORTH_PARSE_KEY 
9a07						DMARK "KY>" 
9a07			endif 
9a07			; move past token to next word 
9a07			 
9a07 2a 76 e6		ld hl, (os_tok_ptr) 
9a0a 3e 00		ld a, 0 
9a0c 01 ff 00		ld bc, 255     ; input buffer size 
9a0f ed b1		cpir 
9a11			 
9a11			if DEBUG_FORTH_PARSE_KEY 
9a11						DMARK "KY!" 
9a11				CALLMONITOR 
9a11			endif	 
9a11			; TODO this might place hl on the null, so will need to forward on??? 
9a11			;inc hl   ; see if this gets onto the next item 
9a11			 
9a11			 
9a11			; TODO pass a pointer to the buffer to push 
9a11			; TODO call function to push 
9a11			 
9a11			; look for end of input 
9a11			 
9a11			;inc hl 
9a11			;ld a,(hl) 
9a11			;cp FORTH_END_BUFFER 
9a11			;ret z 
9a11			 
9a11			 
9a11 c3 8a 99		jp exec1 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			 
9a14			findnexttok: 
9a14			 
9a14				; hl is pointer to move 
9a14				; de is the token to locate 
9a14			 
9a14					if DEBUG_FORTH 
9a14						DMARK "NTK" 
9a14						CALLMONITOR 
9a14					endif 
9a14 d5				push de 
9a15			 
9a15			.fnt1:	 
9a15				; find first char of token to locate 
9a15			 
9a15 1a				ld a, (de) 
9a16 4f				ld c,a 
9a17 7e				ld a,(hl) 
9a18 cd 0c 8e			call toUpper 
9a1b					if DEBUG_FORTH 
9a1b						DMARK "NT1" 
9a1b						CALLMONITOR 
9a1b					endif 
9a1b b9				cp c 
9a1c			 
9a1c 28 03			jr z, .fnt2cmpmorefirst	 
9a1e			 
9a1e				; first char not found move to next char 
9a1e			 
9a1e 23				inc hl 
9a1f 18 f4			jr .fnt1 
9a21			 
9a21			.fnt2cmpmorefirst:	 
9a21				; first char of token found.  
9a21			 
9a21 e5				push hl     ; save start of token just in case it is the right one 
9a22 d9				exx 
9a23 e1				pop hl        ; save it to hl' 
9a24 d9				exx 
9a25			 
9a25			 
9a25			.fnt2cmpmore:	 
9a25				; compare the rest 
9a25				 
9a25 23				inc hl 
9a26 13				inc de 
9a27				 
9a27 1a				ld a, (de) 
9a28 4f				ld c,a 
9a29 7e				ld a,(hl) 
9a2a cd 0c 8e			call toUpper 
9a2d			 
9a2d					if DEBUG_FORTH 
9a2d						DMARK "NT2" 
9a2d						CALLMONITOR 
9a2d					endif 
9a2d				; c has the token to find char 
9a2d				; a has the mem to scan char 
9a2d			 
9a2d b9				cp c 
9a2e 28 04			jr z,.fntmatch1 
9a30			 
9a30				; they are not the same 
9a30			 
9a30					if DEBUG_FORTH 
9a30						DMARK "NT3" 
9a30						CALLMONITOR 
9a30					endif 
9a30 d1				pop de	; reset de token to look for 
9a31 d5				push de 
9a32 18 e1			jr .fnt1 
9a34				 
9a34			.fntmatch1: 
9a34			 
9a34				; is the same char a null which means we might have a full hit? 
9a34					if DEBUG_FORTH 
9a34						DMARK "NT4" 
9a34						CALLMONITOR 
9a34					endif 
9a34			 
9a34 fe 00			cp 0 
9a36 28 0b			jr z, .fntmatchyes 
9a38			 
9a38				; are we at the end of the token to find? 
9a38			 
9a38					if DEBUG_FORTH 
9a38						DMARK "NT5" 
9a38						CALLMONITOR 
9a38					endif 
9a38 3e 00			ld a, 0 
9a3a b9				cp c 
9a3b			 
9a3b c2 25 9a			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9a3e			 
9a3e					if DEBUG_FORTH 
9a3e						DMARK "NT6" 
9a3e						CALLMONITOR 
9a3e					endif 
9a3e				; token to find is exhusted but no match to stream 
9a3e			 
9a3e				; restore tok pointer and continue on 
9a3e d1				pop de 
9a3f d5				push de 
9a40 c3 15 9a			jp .fnt1 
9a43			 
9a43			 
9a43			.fntmatchyes: 
9a43			 
9a43				; hl now contains the end of the found token 
9a43			 
9a43				; get rid of saved token pointer to find 
9a43			 
9a43 d1				pop de 
9a44			 
9a44					if DEBUG_FORTH 
9a44						DMARK "NT9" 
9a44						CALLMONITOR 
9a44					endif 
9a44			 
9a44				; hl will be on the null term so forward on 
9a44			 
9a44				; get back the saved start of the token 
9a44			 
9a44 d9				exx 
9a45 e5				push hl     ; save start of token just in case it is the right one 
9a46 d9				exx 
9a47 e1				pop hl        ; save it to hl 
9a48			 
9a48 c9				ret 
9a49			 
9a49			 
9a49			; LIST needs to find a specific token   
9a49			; FORGET needs to find a spefici token 
9a49			 
9a49			; SAVE needs to find all tokens by flag 
9a49			; WORDS just needs to scan through all  by flag 
9a49			; UWORDS needs to scan through all by flag 
9a49			 
9a49			 
9a49			; given hl as pointer to start of dict look up string 
9a49			; return hl as pointer to start of word block 
9a49			; or 0 if not found 
9a49			 
9a49			forth_find_tok: 
9a49 c9				ret 
9a4a			 
9a4a			; given hl as pointer to dict structure 
9a4a			; move to the next dict block structure 
9a4a			 
9a4a			forth_tok_next: 
9a4a				; hl now points to the address of the next word pointer  
9a4a				; TODO skip compiled symbol for now 
9a4a			;	push de 
9a4a 23				inc hl 
9a4b 5e				ld e, (hl) 
9a4c 23				inc hl 
9a4d 56				ld d, (hl) 
9a4e 23				inc hl 
9a4f			 
9a4f eb				ex de,hl 
9a50			if DEBUG_FORTH_PARSE_NEXTWORD 
9a50				push bc 
9a50				ld bc, (cli_nextword) 
9a50						DMARK "NXW" 
9a50				CALLMONITOR 
9a50				pop bc 
9a50			endif 
9a50			;	pop de	 
9a50 c9				ret 
9a51			 
9a51			 
9a51			 
9a51			; eof 
# End of file forth_parserv5.asm
9a51				include "forth_wordsv4.asm" 
9a51			 
9a51			; the core word dictionary v4 
9a51			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9a51			 
9a51			; this is a linked list for each of the system words used 
9a51			; user defined words will follow the same format but will be in ram 
9a51			 
9a51			 
9a51			; 
9a51			; 
9a51			; define linked list: 
9a51			; 
9a51			; 1. compiled byte op code 
9a51			; 2. len of text word 
9a51			; 3. text word 
9a51			; 4. ptr to next dictionary word 
9a51			; 5. asm, calls etc for the word 
9a51			; 
9a51			;  if 1 == 0 then last word in dict  
9a51			;   
9a51			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9a51			;  
9a51			;  
9a51			; create basic standard set of words 
9a51			; 
9a51			;  
9a51			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9a51			; 2DUP 2DROP 2SWAP  
9a51			; @ C@ - get byte  
9a51			; ! C! - store byte 
9a51			; 0< true if less than zero 
9a51			; 0= true if zero 
9a51			; < >  
9a51			; = true if same 
9a51			; variables 
9a51			 
9a51			 
9a51			; Hardware specific words I may need 
9a51			; 
9a51			; IN OUT  
9a51			; calls to key util functions 
9a51			; calls to hardward abstraction stuff 
9a51			; easy control of frame buffers and lcd i/o 
9a51			; keyboard  
9a51			 
9a51			 
9a51			;DICT: macro 
9a51			; op_code, len, word, next 
9a51			;    word: 
9a51			;    db op_code 
9a51			;    ds word zero term 
9a51			;    dw next 
9a51			;    endm 
9a51			 
9a51			 
9a51			 
9a51			 
9a51			; op code 1 is a flag for user define words which are to be handled differently 
9a51			 
9a51			 
9a51			; 
9a51			; 
9a51			;    TODO on entry to a word this should be the expected environment 
9a51			;    hl - tos value if number then held, if string this is the ptr 
9a51			;    de -  
9a51			 
9a51			 
9a51			; opcode ranges 
9a51			; 0 - end of word dict 
9a51			; 255 - user define words 
9a51			 
9a51			sysdict: 
9a51			include "forth_opcodes.asm" 
9a51			; op codes for forth keywords 
9a51			; free to use code 0  
9a51				OPCODE_HEAP: equ  1 
9a51				OPCODE_EXEC: equ 2 
9a51				OPCODE_DUP: equ 3 
9a51				OPCODE_SWAP: equ 4 
9a51				OPCODE_COLN: equ 5 
9a51				OPCODE_SCOLN: equ 6 
9a51				OPCODE_DROP: equ 7 
9a51				OPCODE_DUP2: equ 8 
9a51				OPCODE_DROP2: equ 9 
9a51				OPCODE_SWAP2: equ 10 
9a51				OPCODE_AT: equ 11 
9a51				OPCODE_CAT: equ 12 
9a51				OPCODE_BANG: equ 13 
9a51				OPCODE_CBANG: equ 14 
9a51				OPCODE_SCALL: equ 15 
9a51				OPCODE_DEPTH: equ 16 
9a51				OPCODE_OVER: equ 17 
9a51				OPCODE_PAUSE: equ 18 
9a51				OPCODE_PAUSES: equ 19 
9a51				OPCODE_ROT: equ 20 
9a51			;free to reuse	OPCODE_WORDS: equ 21 
9a51			        OPCODE_NOT: equ 21 
9a51				OPCODE_UWORDS: equ 22 
9a51				OPCODE_BP: equ 23 
9a51				OPCODE_MONITOR: equ 24  
9a51				OPCODE_MALLOC: equ 25 
9a51				OPCODE_FREE: equ 26 
9a51				OPCODE_LIST: equ 27 
9a51				OPCODE_FORGET: equ 28 
9a51				OPCODE_NOP: equ 29 
9a51				OPCODE_COMO: equ 30 
9a51				OPCODE_COMC: equ 31 
9a51			;free to reuse	OPCODE_ENDCORE: equ 32 
9a51				OPCODE_AFTERSOUND: equ 33 
9a51				OPCODE_GP2: equ 34 
9a51				OPCODE_GP3: equ 35 
9a51				OPCODE_GP4: equ 36 
9a51				OPCODE_SIN: equ 37 
9a51				OPCODE_SOUT: equ 38 
9a51				OPCODE_SPIO: equ 39 
9a51				OPCODE_SPICEH: equ 40 
9a51				OPCODE_SPIOb: equ 41 
9a51				OPCODE_SPII: equ 42 
9a51				OPCODE_SESEL: equ 43 
9a51				OPCODE_CARTDEV: equ 44 
9a51			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9a51				OPCODE_FB: equ 46 
9a51				OPCODE_EMIT: equ 47 
9a51				OPCODE_DOTH: equ 48 
9a51				OPCODE_DOTF: equ 49 
9a51				OPCODE_DOT: equ 50 
9a51				OPCODE_CLS: equ 51 
9a51				OPCODE_DRAW: equ 52 
9a51				OPCODE_DUMP: equ 53 
9a51				OPCODE_CDUMP: equ 54 
9a51				OPCODE_DAT: equ 55 
9a51				OPCODE_HOME: equ 56 
9a51				OPCODE_SPACE: equ 57 
9a51				OPCODE_SPACES: equ 58 
9a51				OPCODE_SCROLL: equ 59 
9a51				OPCODE_ATQ: equ 60 
9a51				OPCODE_AUTODSP: equ 61 
9a51				OPCODE_MENU: equ 62 
9a51			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9a51				OPCODE_THEN: equ 64 
9a51				OPCODE_ELSE: equ 65 
9a51				OPCODE_DO: equ 66 
9a51				OPCODE_LOOP: equ 67 
9a51				OPCODE_I: equ 68 
9a51				OPCODE_DLOOP: equ 69  
9a51				OPCODE_REPEAT: equ 70  
9a51				OPCODE_UNTIL: equ 71 
9a51				OPCODE_ENDFLOW: equ 72 
9a51				OPCODE_WAITK: equ 73 
9a51				OPCODE_ACCEPT: equ 74 
9a51				OPCODE_EDIT: equ 75 
9a51			;free to reuse	OPCODE_ENDKEY: equ 76 
9a51				OPCODE_LZERO: equ 77 
9a51				OPCODE_TZERO: equ 78 
9a51				OPCODE_LESS: equ 79 
9a51				OPCODE_GT: equ 80 
9a51				OPCODE_EQUAL: equ 81  
9a51			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9a51				OPCODE_NEG: equ 83 
9a51				OPCODE_DIV: equ 84 
9a51				OPCODE_MUL: equ 85 
9a51				OPCODE_MIN: equ 86 
9a51				OPCODE_MAX: equ 87 
9a51				OPCODE_RND16: equ 88 
9a51				OPCODE_RND8: equ 89 
9a51				OPCODE_RND: equ 90 
9a51			;free to reuse	OPCODE_ENDMATHS: equ 91  
9a51				OPCODE_BYNAME: equ 92 
9a51				OPCODE_DIR: equ 93 
9a51				OPCODE_SAVE: equ 94 
9a51				OPCODE_LOAD: equ 95 
9a51				OPCODE_BSAVE: equ 96 
9a51				OPCODE_BLOAD: equ 97 
9a51				OPCODE_SEO: equ 98  
9a51				OPCODE_SEI: equ 99 
9a51				OPCODE_SFREE: equ 100 
9a51				OPCODE_SIZE: equ 101 
9a51				OPCODE_CREATE: equ 102 
9a51				OPCODE_APPEND: equ 103 
9a51				OPCODE_SDEL: equ 104 
9a51				OPCODE_OPEN: equ 105 
9a51				OPCODE_READ: equ 106 
9a51				OPCODE_EOF: equ 106 
9a51				OPCODE_FORMAT: equ 107 
9a51				OPCODE_LABEL: equ 108 
9a51				OPCODE_LABELS: equ 109 
9a51			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9a51				OPCODE_UPPER: equ 111 
9a51				OPCODE_LOWER: equ 112 
9a51				OPCODE_SUBSTR: equ 113 
9a51				OPCODE_LEFT: equ 114 
9a51				OPCODE_RIGHT: equ 115 
9a51				OPCODE_STR2NUM: equ 116 
9a51				OPCODE_NUM2STR: equ 117 
9a51				OPCODE_CONCAT: equ 118 
9a51				OPCODE_FIND: equ 119 
9a51				OPCODE_LEN: equ 120 
9a51				OPCODE_CHAR: equ 121 
9a51			; free to reuse	OPCODE_STRLEN: equ 122 
9a51			; free to reuse	OPCODE_ENDSTR: equ 123 
9a51				OPCODE_V0S: equ 124 
9a51				OPCODE_V0Q: equ 125 
9a51				OPCODE_V1S: equ 126 
9a51				OPCODE_V1Q: equ 127 
9a51				OPCODE_V2S: equ 128 
9a51				OPCODE_V2Q: equ 129 
9a51				OPCODE_V3S: equ 130 
9a51				OPCODE_V3Q: equ 131 
9a51			;free to reuse	OPCODE_END: equ 132 
9a51				OPCODE_ZDUP: equ 133 
9a51			 
9a51			; eof 
# End of file forth_opcodes.asm
9a51			 
9a51			include "forth_words_core.asm" 
9a51			 
9a51			; | ## Core Words 
9a51			 
9a51			;if MALLOC_4 
9a51			 
9a51			.HEAP: 
9a51				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9a51 15				db WORD_SYS_CORE+OPCODE_HEAP             
9a52 90 9a			dw .EXEC            
9a54 05				db 4 + 1 
9a55 .. 00			db "HEAP",0              
9a5a				endm 
# End of macro CWHEAD
9a5a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9a5a			; | | u1 - Current number of bytes in the heap 
9a5a			; | | u2 - Remaining bytes left on the heap 
9a5a			; | |  
9a5a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9a5a			 
9a5a			 
9a5a					if DEBUG_FORTH_WORDS_KEY 
9a5a						DMARK "HEP" 
9a5a f5				push af  
9a5b 3a 6f 9a			ld a, (.dmark)  
9a5e 32 7a ee			ld (debug_mark),a  
9a61 3a 70 9a			ld a, (.dmark+1)  
9a64 32 7b ee			ld (debug_mark+1),a  
9a67 3a 71 9a			ld a, (.dmark+2)  
9a6a 32 7c ee			ld (debug_mark+2),a  
9a6d 18 03			jr .pastdmark  
9a6f ..			.dmark: db "HEP"  
9a72 f1			.pastdmark: pop af  
9a73			endm  
# End of macro DMARK
9a73						CALLMONITOR 
9a73 cd 7b 91			call break_point_state  
9a76				endm  
# End of macro CALLMONITOR
9a76					endif 
9a76 2a b1 d4				ld hl, (free_list )      
9a79 11 b6 d4				ld de, heap_start 
9a7c			 
9a7c ed 52				sbc hl, de  
9a7e			 
9a7e cd 08 97				call forth_push_numhl 
9a81			 
9a81			 
9a81 ed 5b b1 d4			ld de, (free_list )      
9a85 21 69 e3				ld hl, heap_end 
9a88			 
9a88 ed 52				sbc hl, de 
9a8a			 
9a8a cd 08 97				call forth_push_numhl 
9a8d					 
9a8d			 
9a8d					 
9a8d			 
9a8d			 
9a8d			 
9a8d					NEXTW 
9a8d c3 f9 98			jp macro_next 
9a90				endm 
# End of macro NEXTW
9a90			;endif 
9a90			 
9a90			.EXEC: 
9a90				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9a90 16				db WORD_SYS_CORE+OPCODE_EXEC             
9a91 2c 9b			dw .STKEXEC            
9a93 05				db 4 + 1 
9a94 .. 00			db "EXEC",0              
9a99				endm 
# End of macro CWHEAD
9a99			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9a99			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9a99			; | | 
9a99			; | |   
9a99				STACKFRAME OFF $5efe $5f9f 
9a99				if DEBUG_STACK_IMB 
9a99					if OFF 
9a99						exx 
9a99						ld de, $5efe 
9a99						ld a, d 
9a99						ld hl, curframe 
9a99						call hexout 
9a99						ld a, e 
9a99						ld hl, curframe+2 
9a99						call hexout 
9a99						ld hl, $5efe 
9a99						push hl 
9a99						ld hl, $5f9f 
9a99						push hl 
9a99						exx 
9a99					endif 
9a99				endif 
9a99			endm 
# End of macro STACKFRAME
9a99			 
9a99					if DEBUG_FORTH_WORDS_KEY 
9a99						DMARK "EXE" 
9a99 f5				push af  
9a9a 3a ae 9a			ld a, (.dmark)  
9a9d 32 7a ee			ld (debug_mark),a  
9aa0 3a af 9a			ld a, (.dmark+1)  
9aa3 32 7b ee			ld (debug_mark+1),a  
9aa6 3a b0 9a			ld a, (.dmark+2)  
9aa9 32 7c ee			ld (debug_mark+2),a  
9aac 18 03			jr .pastdmark  
9aae ..			.dmark: db "EXE"  
9ab1 f1			.pastdmark: pop af  
9ab2			endm  
# End of macro DMARK
9ab2						CALLMONITOR 
9ab2 cd 7b 91			call break_point_state  
9ab5				endm  
# End of macro CALLMONITOR
9ab5					endif 
9ab5			 
9ab5				FORTH_DSP_VALUEHL 
9ab5 cd a3 97			call macro_dsp_valuehl 
9ab8				endm 
# End of macro FORTH_DSP_VALUEHL
9ab8			 
9ab8				FORTH_DSP_POP 
9ab8 cd 3f 98			call macro_forth_dsp_pop 
9abb				endm 
# End of macro FORTH_DSP_POP
9abb			 
9abb					if DEBUG_FORTH_WORDS 
9abb						DMARK "EX1" 
9abb f5				push af  
9abc 3a d0 9a			ld a, (.dmark)  
9abf 32 7a ee			ld (debug_mark),a  
9ac2 3a d1 9a			ld a, (.dmark+1)  
9ac5 32 7b ee			ld (debug_mark+1),a  
9ac8 3a d2 9a			ld a, (.dmark+2)  
9acb 32 7c ee			ld (debug_mark+2),a  
9ace 18 03			jr .pastdmark  
9ad0 ..			.dmark: db "EX1"  
9ad3 f1			.pastdmark: pop af  
9ad4			endm  
# End of macro DMARK
9ad4						CALLMONITOR 
9ad4 cd 7b 91			call break_point_state  
9ad7				endm  
# End of macro CALLMONITOR
9ad7					endif 
9ad7			;	ld e,(hl) 
9ad7			;	inc hl 
9ad7			;	ld d,(hl) 
9ad7			;	ex de,hl 
9ad7			 
9ad7			;		if DEBUG_FORTH_WORDS 
9ad7			;			DMARK "EX2" 
9ad7			;			CALLMONITOR 
9ad7			;		endif 
9ad7 e5				push hl 
9ad8			 
9ad8				;ld a, 0 
9ad8				;ld a, FORTH_END_BUFFER 
9ad8 cd 15 8e			call strlenz 
9adb 23				inc hl   ; include zero term to copy 
9adc 23				inc hl   ; include term 
9add 23				inc hl   ; include term 
9ade 06 00			ld b,0 
9ae0 4d				ld c,l 
9ae1 e1				pop hl 
9ae2 11 74 e4			ld de, execscratch 
9ae5					if DEBUG_FORTH_WORDS 
9ae5						DMARK "EX3" 
9ae5 f5				push af  
9ae6 3a fa 9a			ld a, (.dmark)  
9ae9 32 7a ee			ld (debug_mark),a  
9aec 3a fb 9a			ld a, (.dmark+1)  
9aef 32 7b ee			ld (debug_mark+1),a  
9af2 3a fc 9a			ld a, (.dmark+2)  
9af5 32 7c ee			ld (debug_mark+2),a  
9af8 18 03			jr .pastdmark  
9afa ..			.dmark: db "EX3"  
9afd f1			.pastdmark: pop af  
9afe			endm  
# End of macro DMARK
9afe						CALLMONITOR 
9afe cd 7b 91			call break_point_state  
9b01				endm  
# End of macro CALLMONITOR
9b01					endif 
9b01 ed b0			ldir 
9b03			 
9b03			 
9b03 21 74 e4			ld hl, execscratch 
9b06			 
9b06					if DEBUG_FORTH_WORDS 
9b06						DMARK "EXe" 
9b06 f5				push af  
9b07 3a 1b 9b			ld a, (.dmark)  
9b0a 32 7a ee			ld (debug_mark),a  
9b0d 3a 1c 9b			ld a, (.dmark+1)  
9b10 32 7b ee			ld (debug_mark+1),a  
9b13 3a 1d 9b			ld a, (.dmark+2)  
9b16 32 7c ee			ld (debug_mark+2),a  
9b19 18 03			jr .pastdmark  
9b1b ..			.dmark: db "EXe"  
9b1e f1			.pastdmark: pop af  
9b1f			endm  
# End of macro DMARK
9b1f						CALLMONITOR 
9b1f cd 7b 91			call break_point_state  
9b22				endm  
# End of macro CALLMONITOR
9b22					endif 
9b22			 
9b22 cd 47 99			call forthparse 
9b25 cd 87 99			call forthexec 
9b28			;	call forthexec_cleanup 
9b28			;	call forthparse 
9b28			;	call forthexec 
9b28			 
9b28				STACKFRAMECHK OFF $5efe $5f9f 
9b28				if DEBUG_STACK_IMB 
9b28					if OFF 
9b28						exx 
9b28						ld hl, $5f9f 
9b28						pop de   ; $5f9f 
9b28						call cmp16 
9b28						jr nz, .spnosame 
9b28						ld hl, $5efe 
9b28						pop de   ; $5efe 
9b28						call cmp16 
9b28						jr z, .spfrsame 
9b28						.spnosame: call showsperror 
9b28						.spfrsame: nop 
9b28						exx 
9b28					endif 
9b28				endif 
9b28			endm 
# End of macro STACKFRAMECHK
9b28			 
9b28				; an immediate word so no need to process any more words 
9b28 c9				ret 
9b29				NEXTW 
9b29 c3 f9 98			jp macro_next 
9b2c				endm 
# End of macro NEXTW
9b2c			 
9b2c			; dead code - old version  
9b2c			;	FORTH_RSP_NEXT 
9b2c			 
9b2c			;  
9b2c			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9b2c			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9b2c			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9b2c			;	push hl 
9b2c			;	push de 
9b2c			;	push bc 
9b2c			; 
9b2c			; 
9b2c			;		if DEBUG_FORTH_WORDS_KEY 
9b2c			;			DMARK "EXR" 
9b2c			;			CALLMONITOR 
9b2c			;		endif 
9b2c			; 
9b2c			; 
9b2c			; 
9b2c			;	;v5 FORTH_DSP_VALUE 
9b2c			;	FORTH_DSP_VALUEHL 
9b2c			; 
9b2c			;	; TODO do string type checks 
9b2c			; 
9b2c			;;v5	inc hl   ; skip type 
9b2c			; 
9b2c			;	push hl  ; source code  
9b2c			;		if DEBUG_FORTH_WORDS 
9b2c			;			DMARK "EX1" 
9b2c			;			CALLMONITOR 
9b2c			;		endif 
9b2c			;	ld a, 0 
9b2c			;	call strlent 
9b2c			; 
9b2c			;	inc hl 
9b2c			;	inc hl 
9b2c			;	inc hl 
9b2c			;	inc hl 
9b2c			; 
9b2c			;	push hl    ; size 
9b2c			; 
9b2c			;		if DEBUG_FORTH_WORDS 
9b2c			;			DMARK "EX2" 
9b2c			;			CALLMONITOR 
9b2c			;		endif 
9b2c			;	call malloc 
9b2c			; 
9b2c			;	ex de, hl    ; de now contains malloc area 
9b2c			;	pop bc   	; get byte count 
9b2c			;	pop hl      ; get string to copy 
9b2c			; 
9b2c			;	push de     ; save malloc for free later 
9b2c			; 
9b2c			;		if DEBUG_FORTH_WORDS 
9b2c			;			DMARK "EX3" 
9b2c			;			CALLMONITOR 
9b2c			;		endif 
9b2c			;	ldir       ; duplicate string 
9b2c			; 
9b2c			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9b2c			;	 
9b2c			;	; TODO fix the parse would be better than this...  
9b2c			;	ex de, hl 
9b2c			;	dec hl 
9b2c			;	ld a, 0 
9b2c			;	ld (hl), a 
9b2c			;	dec hl 
9b2c			;	ld a, ' ' 
9b2c			;	ld (hl), a 
9b2c			;	dec hl 
9b2c			;	ld (hl), a 
9b2c			; 
9b2c			;	dec hl 
9b2c			;	ld (hl), a 
9b2c			; 
9b2c			; 
9b2c			;	FORTH_DSP_POP  
9b2c			; 
9b2c			;	pop hl     
9b2c			;	push hl    ; save malloc area 
9b2c			; 
9b2c			;		if DEBUG_FORTH_WORDS 
9b2c			;			DMARK "EX4" 
9b2c			;			CALLMONITOR 
9b2c			;		endif 
9b2c			; 
9b2c			;	call forthparse 
9b2c			;	call forthexec 
9b2c			;	 
9b2c			;	pop hl 
9b2c			;	if DEBUG_FORTH_WORDS 
9b2c			;		DMARK "EX5" 
9b2c			;		CALLMONITOR 
9b2c			;	endif 
9b2c			; 
9b2c			;	if FORTH_ENABLE_FREE 
9b2c			;	call free 
9b2c			;	endif 
9b2c			; 
9b2c			;	if DEBUG_FORTH_WORDS 
9b2c			;		DMARK "EX6" 
9b2c			;		CALLMONITOR 
9b2c			;	endif 
9b2c			; 
9b2c			;	pop bc 
9b2c			;	pop de 
9b2c			;	pop hl 
9b2c			;;	FORTH_RSP_POP	  
9b2c			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9b2c			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9b2c			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9b2c			; 
9b2c			;	if DEBUG_FORTH_WORDS 
9b2c			;		DMARK "EX7" 
9b2c			;		CALLMONITOR 
9b2c			;	endif 
9b2c			;	NEXTW 
9b2c			 
9b2c			.STKEXEC: 
9b2c				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9b2c 3f				db WORD_SYS_CORE+43             
9b2d 74 9c			dw .ZDUP            
9b2f 08				db 7 + 1 
9b30 .. 00			db "STKEXEC",0              
9b38				endm 
# End of macro CWHEAD
9b38			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9b38			 
9b38			 
9b38					if DEBUG_FORTH_WORDS_KEY 
9b38						DMARK "STX" 
9b38 f5				push af  
9b39 3a 4d 9b			ld a, (.dmark)  
9b3c 32 7a ee			ld (debug_mark),a  
9b3f 3a 4e 9b			ld a, (.dmark+1)  
9b42 32 7b ee			ld (debug_mark+1),a  
9b45 3a 4f 9b			ld a, (.dmark+2)  
9b48 32 7c ee			ld (debug_mark+2),a  
9b4b 18 03			jr .pastdmark  
9b4d ..			.dmark: db "STX"  
9b50 f1			.pastdmark: pop af  
9b51			endm  
# End of macro DMARK
9b51						CALLMONITOR 
9b51 cd 7b 91			call break_point_state  
9b54				endm  
# End of macro CALLMONITOR
9b54					endif 
9b54			 
9b54				FORTH_DSP_VALUEHL 
9b54 cd a3 97			call macro_dsp_valuehl 
9b57				endm 
# End of macro FORTH_DSP_VALUEHL
9b57			 
9b57 22 63 eb			ld (store_tmp1), hl    ; count 
9b5a			 
9b5a				FORTH_DSP_POP 
9b5a cd 3f 98			call macro_forth_dsp_pop 
9b5d				endm 
# End of macro FORTH_DSP_POP
9b5d			.stkexec1: 
9b5d 2a 63 eb			ld hl, (store_tmp1)   ; count 
9b60 3e 00			ld a, 0 
9b62 bd				cp l 
9b63 c8				ret z 
9b64			 
9b64 2b				dec hl 
9b65 22 63 eb			ld (store_tmp1), hl    ; count 
9b68				 
9b68				FORTH_DSP_VALUEHL 
9b68 cd a3 97			call macro_dsp_valuehl 
9b6b				endm 
# End of macro FORTH_DSP_VALUEHL
9b6b e5				push hl 
9b6c				 
9b6c					if DEBUG_FORTH_WORDS 
9b6c						DMARK "EXp" 
9b6c f5				push af  
9b6d 3a 81 9b			ld a, (.dmark)  
9b70 32 7a ee			ld (debug_mark),a  
9b73 3a 82 9b			ld a, (.dmark+1)  
9b76 32 7b ee			ld (debug_mark+1),a  
9b79 3a 83 9b			ld a, (.dmark+2)  
9b7c 32 7c ee			ld (debug_mark+2),a  
9b7f 18 03			jr .pastdmark  
9b81 ..			.dmark: db "EXp"  
9b84 f1			.pastdmark: pop af  
9b85			endm  
# End of macro DMARK
9b85						CALLMONITOR 
9b85 cd 7b 91			call break_point_state  
9b88				endm  
# End of macro CALLMONITOR
9b88					endif 
9b88				FORTH_DSP_POP 
9b88 cd 3f 98			call macro_forth_dsp_pop 
9b8b				endm 
# End of macro FORTH_DSP_POP
9b8b			 
9b8b cd 15 8e			call strlenz 
9b8e 23				inc hl   ; include zero term to copy 
9b8f 23				inc hl   ; include zero term to copy 
9b90 23				inc hl   ; include zero term to copy 
9b91 06 00			ld b,0 
9b93 4d				ld c,l 
9b94 e1				pop hl 
9b95 11 74 e4			ld de, execscratch 
9b98					if DEBUG_FORTH_WORDS 
9b98						DMARK "EX3" 
9b98 f5				push af  
9b99 3a ad 9b			ld a, (.dmark)  
9b9c 32 7a ee			ld (debug_mark),a  
9b9f 3a ae 9b			ld a, (.dmark+1)  
9ba2 32 7b ee			ld (debug_mark+1),a  
9ba5 3a af 9b			ld a, (.dmark+2)  
9ba8 32 7c ee			ld (debug_mark+2),a  
9bab 18 03			jr .pastdmark  
9bad ..			.dmark: db "EX3"  
9bb0 f1			.pastdmark: pop af  
9bb1			endm  
# End of macro DMARK
9bb1						CALLMONITOR 
9bb1 cd 7b 91			call break_point_state  
9bb4				endm  
# End of macro CALLMONITOR
9bb4					endif 
9bb4 ed b0			ldir 
9bb6			 
9bb6			 
9bb6 21 74 e4			ld hl, execscratch 
9bb9			 
9bb9					if DEBUG_FORTH_WORDS 
9bb9						DMARK "EXP" 
9bb9 f5				push af  
9bba 3a ce 9b			ld a, (.dmark)  
9bbd 32 7a ee			ld (debug_mark),a  
9bc0 3a cf 9b			ld a, (.dmark+1)  
9bc3 32 7b ee			ld (debug_mark+1),a  
9bc6 3a d0 9b			ld a, (.dmark+2)  
9bc9 32 7c ee			ld (debug_mark+2),a  
9bcc 18 03			jr .pastdmark  
9bce ..			.dmark: db "EXP"  
9bd1 f1			.pastdmark: pop af  
9bd2			endm  
# End of macro DMARK
9bd2						CALLMONITOR 
9bd2 cd 7b 91			call break_point_state  
9bd5				endm  
# End of macro CALLMONITOR
9bd5					endif 
9bd5			 
9bd5 cd 47 99			call forthparse 
9bd8 21 74 e4			ld hl, execscratch 
9bdb					if DEBUG_FORTH_WORDS 
9bdb						DMARK "EXx" 
9bdb f5				push af  
9bdc 3a f0 9b			ld a, (.dmark)  
9bdf 32 7a ee			ld (debug_mark),a  
9be2 3a f1 9b			ld a, (.dmark+1)  
9be5 32 7b ee			ld (debug_mark+1),a  
9be8 3a f2 9b			ld a, (.dmark+2)  
9beb 32 7c ee			ld (debug_mark+2),a  
9bee 18 03			jr .pastdmark  
9bf0 ..			.dmark: db "EXx"  
9bf3 f1			.pastdmark: pop af  
9bf4			endm  
# End of macro DMARK
9bf4						CALLMONITOR 
9bf4 cd 7b 91			call break_point_state  
9bf7				endm  
# End of macro CALLMONITOR
9bf7					endif 
9bf7 cd 87 99			call forthexec 
9bfa			 
9bfa c3 5d 9b			jp .stkexec1 
9bfd			 
9bfd c9				ret 
9bfe			 
9bfe			 
9bfe			.DUP: 
9bfe				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9bfe 17				db WORD_SYS_CORE+OPCODE_DUP             
9bff 74 9c			dw .ZDUP            
9c01 04				db 3 + 1 
9c02 .. 00			db "DUP",0              
9c06				endm 
# End of macro CWHEAD
9c06			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9c06			 
9c06					if DEBUG_FORTH_WORDS_KEY 
9c06						DMARK "DUP" 
9c06 f5				push af  
9c07 3a 1b 9c			ld a, (.dmark)  
9c0a 32 7a ee			ld (debug_mark),a  
9c0d 3a 1c 9c			ld a, (.dmark+1)  
9c10 32 7b ee			ld (debug_mark+1),a  
9c13 3a 1d 9c			ld a, (.dmark+2)  
9c16 32 7c ee			ld (debug_mark+2),a  
9c19 18 03			jr .pastdmark  
9c1b ..			.dmark: db "DUP"  
9c1e f1			.pastdmark: pop af  
9c1f			endm  
# End of macro DMARK
9c1f						CALLMONITOR 
9c1f cd 7b 91			call break_point_state  
9c22				endm  
# End of macro CALLMONITOR
9c22					endif 
9c22			 
9c22					FORTH_DSP 
9c22 cd 88 97			call macro_forth_dsp 
9c25				endm 
# End of macro FORTH_DSP
9c25			 
9c25 7e					ld a, (HL) 
9c26 fe 01				cp DS_TYPE_STR 
9c28 20 25				jr nz, .dupinum 
9c2a			 
9c2a					; push another string 
9c2a			 
9c2a					FORTH_DSP_VALUEHL     		 
9c2a cd a3 97			call macro_dsp_valuehl 
9c2d				endm 
# End of macro FORTH_DSP_VALUEHL
9c2d			 
9c2d				if DEBUG_FORTH_WORDS 
9c2d					DMARK "DUs" 
9c2d f5				push af  
9c2e 3a 42 9c			ld a, (.dmark)  
9c31 32 7a ee			ld (debug_mark),a  
9c34 3a 43 9c			ld a, (.dmark+1)  
9c37 32 7b ee			ld (debug_mark+1),a  
9c3a 3a 44 9c			ld a, (.dmark+2)  
9c3d 32 7c ee			ld (debug_mark+2),a  
9c40 18 03			jr .pastdmark  
9c42 ..			.dmark: db "DUs"  
9c45 f1			.pastdmark: pop af  
9c46			endm  
# End of macro DMARK
9c46					CALLMONITOR 
9c46 cd 7b 91			call break_point_state  
9c49				endm  
# End of macro CALLMONITOR
9c49				endif 
9c49 cd 1a 97				call forth_push_str 
9c4c			 
9c4c					NEXTW 
9c4c c3 f9 98			jp macro_next 
9c4f				endm 
# End of macro NEXTW
9c4f			 
9c4f			 
9c4f			.dupinum: 
9c4f					 
9c4f			 
9c4f			 
9c4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9c4f cd a3 97			call macro_dsp_valuehl 
9c52				endm 
# End of macro FORTH_DSP_VALUEHL
9c52			 
9c52				; TODO add floating point number detection 
9c52			 
9c52				if DEBUG_FORTH_WORDS 
9c52					DMARK "DUi" 
9c52 f5				push af  
9c53 3a 67 9c			ld a, (.dmark)  
9c56 32 7a ee			ld (debug_mark),a  
9c59 3a 68 9c			ld a, (.dmark+1)  
9c5c 32 7b ee			ld (debug_mark+1),a  
9c5f 3a 69 9c			ld a, (.dmark+2)  
9c62 32 7c ee			ld (debug_mark+2),a  
9c65 18 03			jr .pastdmark  
9c67 ..			.dmark: db "DUi"  
9c6a f1			.pastdmark: pop af  
9c6b			endm  
# End of macro DMARK
9c6b					CALLMONITOR 
9c6b cd 7b 91			call break_point_state  
9c6e				endm  
# End of macro CALLMONITOR
9c6e				endif 
9c6e			 
9c6e cd 08 97				call forth_push_numhl 
9c71					NEXTW 
9c71 c3 f9 98			jp macro_next 
9c74				endm 
# End of macro NEXTW
9c74			.ZDUP: 
9c74				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9c74 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9c75 ac 9c			dw .SWAP            
9c77 05				db 4 + 1 
9c78 .. 00			db "?DUP",0              
9c7d				endm 
# End of macro CWHEAD
9c7d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9c7d			 
9c7d					if DEBUG_FORTH_WORDS_KEY 
9c7d						DMARK "qDU" 
9c7d f5				push af  
9c7e 3a 92 9c			ld a, (.dmark)  
9c81 32 7a ee			ld (debug_mark),a  
9c84 3a 93 9c			ld a, (.dmark+1)  
9c87 32 7b ee			ld (debug_mark+1),a  
9c8a 3a 94 9c			ld a, (.dmark+2)  
9c8d 32 7c ee			ld (debug_mark+2),a  
9c90 18 03			jr .pastdmark  
9c92 ..			.dmark: db "qDU"  
9c95 f1			.pastdmark: pop af  
9c96			endm  
# End of macro DMARK
9c96						CALLMONITOR 
9c96 cd 7b 91			call break_point_state  
9c99				endm  
# End of macro CALLMONITOR
9c99					endif 
9c99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9c99 cd a3 97			call macro_dsp_valuehl 
9c9c				endm 
# End of macro FORTH_DSP_VALUEHL
9c9c			 
9c9c e5					push hl 
9c9d			 
9c9d					; is it a zero? 
9c9d			 
9c9d 3e 00				ld a, 0 
9c9f 84					add h 
9ca0 85					add l 
9ca1			 
9ca1 e1					pop hl 
9ca2			 
9ca2 fe 00				cp 0 
9ca4 28 03				jr z, .dup2orig 
9ca6			 
9ca6			 
9ca6 cd 08 97				call forth_push_numhl 
9ca9			 
9ca9			 
9ca9				; TODO add floating point number detection 
9ca9			 
9ca9			.dup2orig: 
9ca9			 
9ca9					NEXTW 
9ca9 c3 f9 98			jp macro_next 
9cac				endm 
# End of macro NEXTW
9cac			.SWAP: 
9cac				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9cac 18				db WORD_SYS_CORE+OPCODE_SWAP             
9cad eb 9c			dw .COLN            
9caf 05				db 4 + 1 
9cb0 .. 00			db "SWAP",0              
9cb5				endm 
# End of macro CWHEAD
9cb5			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9cb5					if DEBUG_FORTH_WORDS_KEY 
9cb5						DMARK "SWP" 
9cb5 f5				push af  
9cb6 3a ca 9c			ld a, (.dmark)  
9cb9 32 7a ee			ld (debug_mark),a  
9cbc 3a cb 9c			ld a, (.dmark+1)  
9cbf 32 7b ee			ld (debug_mark+1),a  
9cc2 3a cc 9c			ld a, (.dmark+2)  
9cc5 32 7c ee			ld (debug_mark+2),a  
9cc8 18 03			jr .pastdmark  
9cca ..			.dmark: db "SWP"  
9ccd f1			.pastdmark: pop af  
9cce			endm  
# End of macro DMARK
9cce						CALLMONITOR 
9cce cd 7b 91			call break_point_state  
9cd1				endm  
# End of macro CALLMONITOR
9cd1					endif 
9cd1			 
9cd1					FORTH_DSP_VALUEHL 
9cd1 cd a3 97			call macro_dsp_valuehl 
9cd4				endm 
# End of macro FORTH_DSP_VALUEHL
9cd4 e5					push hl     ; w2 
9cd5			 
9cd5					FORTH_DSP_POP 
9cd5 cd 3f 98			call macro_forth_dsp_pop 
9cd8				endm 
# End of macro FORTH_DSP_POP
9cd8			 
9cd8					FORTH_DSP_VALUEHL 
9cd8 cd a3 97			call macro_dsp_valuehl 
9cdb				endm 
# End of macro FORTH_DSP_VALUEHL
9cdb			 
9cdb					FORTH_DSP_POP 
9cdb cd 3f 98			call macro_forth_dsp_pop 
9cde				endm 
# End of macro FORTH_DSP_POP
9cde			 
9cde d1					pop de     ; w2	, hl = w1 
9cdf			 
9cdf eb					ex de, hl 
9ce0 d5					push de 
9ce1			 
9ce1 cd 08 97				call forth_push_numhl 
9ce4			 
9ce4 e1					pop hl 
9ce5			 
9ce5 cd 08 97				call forth_push_numhl 
9ce8					 
9ce8			 
9ce8					NEXTW 
9ce8 c3 f9 98			jp macro_next 
9ceb				endm 
# End of macro NEXTW
9ceb			.COLN: 
9ceb				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9ceb 19				db WORD_SYS_CORE+OPCODE_COLN             
9cec 77 9e			dw .SCOLN            
9cee 02				db 1 + 1 
9cef .. 00			db ":",0              
9cf1				endm 
# End of macro CWHEAD
9cf1			; | : ( -- )         Create new word | DONE 
9cf1			 
9cf1					if DEBUG_FORTH_WORDS_KEY 
9cf1						DMARK "CLN" 
9cf1 f5				push af  
9cf2 3a 06 9d			ld a, (.dmark)  
9cf5 32 7a ee			ld (debug_mark),a  
9cf8 3a 07 9d			ld a, (.dmark+1)  
9cfb 32 7b ee			ld (debug_mark+1),a  
9cfe 3a 08 9d			ld a, (.dmark+2)  
9d01 32 7c ee			ld (debug_mark+2),a  
9d04 18 03			jr .pastdmark  
9d06 ..			.dmark: db "CLN"  
9d09 f1			.pastdmark: pop af  
9d0a			endm  
# End of macro DMARK
9d0a						CALLMONITOR 
9d0a cd 7b 91			call break_point_state  
9d0d				endm  
# End of macro CALLMONITOR
9d0d					endif 
9d0d				STACKFRAME OFF $8efe $989f 
9d0d				if DEBUG_STACK_IMB 
9d0d					if OFF 
9d0d						exx 
9d0d						ld de, $8efe 
9d0d						ld a, d 
9d0d						ld hl, curframe 
9d0d						call hexout 
9d0d						ld a, e 
9d0d						ld hl, curframe+2 
9d0d						call hexout 
9d0d						ld hl, $8efe 
9d0d						push hl 
9d0d						ld hl, $989f 
9d0d						push hl 
9d0d						exx 
9d0d					endif 
9d0d				endif 
9d0d			endm 
# End of macro STACKFRAME
9d0d				; get parser buffer length  of new word 
9d0d			 
9d0d				 
9d0d			 
9d0d					; move tok past this to start of name defintition 
9d0d					; TODO get word to define 
9d0d					; TODO Move past word token 
9d0d					; TODO get length of string up to the ';' 
9d0d			 
9d0d 2a 76 e6			ld hl, (os_tok_ptr) 
9d10 23				inc hl 
9d11 23				inc hl 
9d12			 
9d12 3e 3b			ld a, ';' 
9d14 cd 20 8e			call strlent 
9d17			 
9d17 7d				ld a,l 
9d18 32 75 e5			ld (os_new_parse_len), a 
9d1b			 
9d1b			 
9d1b			if DEBUG_FORTH_UWORD 
9d1b ed 5b 76 e6		ld de, (os_tok_ptr) 
9d1f						DMARK ":01" 
9d1f f5				push af  
9d20 3a 34 9d			ld a, (.dmark)  
9d23 32 7a ee			ld (debug_mark),a  
9d26 3a 35 9d			ld a, (.dmark+1)  
9d29 32 7b ee			ld (debug_mark+1),a  
9d2c 3a 36 9d			ld a, (.dmark+2)  
9d2f 32 7c ee			ld (debug_mark+2),a  
9d32 18 03			jr .pastdmark  
9d34 ..			.dmark: db ":01"  
9d37 f1			.pastdmark: pop af  
9d38			endm  
# End of macro DMARK
9d38				CALLMONITOR 
9d38 cd 7b 91			call break_point_state  
9d3b				endm  
# End of macro CALLMONITOR
9d3b			endif 
9d3b			 
9d3b			; 
9d3b			;  new word memory layout: 
9d3b			;  
9d3b			;    : adg 6666 ;  
9d3b			; 
9d3b			;    db   1     ; user defined word  
9d3b 23				inc hl    
9d3c			;    dw   sysdict 
9d3c 23				inc hl 
9d3d 23				inc hl 
9d3e			;    db <word len>+1 (for null) 
9d3e 23				inc hl 
9d3f			;    db .... <word> 
9d3f			; 
9d3f			 
9d3f 23				inc hl    ; some extras for the word preamble before the above 
9d40 23				inc hl 
9d41 23				inc hl 
9d42 23				inc hl 
9d43 23				inc hl 
9d44 23				inc hl 
9d45 23				inc hl  
9d46 23				inc hl 
9d47 23				inc hl 
9d48 23				inc hl 
9d49 23				inc hl 
9d4a 23				inc hl 
9d4b 23				inc hl 
9d4c 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9d4d			;       exec word buffer 
9d4d			;	<ptr word>   
9d4d 23				inc hl 
9d4e 23				inc hl 
9d4f			;       <word list><null term> 7F final term 
9d4f			 
9d4f			 
9d4f			if DEBUG_FORTH_UWORD 
9d4f						DMARK ":02" 
9d4f f5				push af  
9d50 3a 64 9d			ld a, (.dmark)  
9d53 32 7a ee			ld (debug_mark),a  
9d56 3a 65 9d			ld a, (.dmark+1)  
9d59 32 7b ee			ld (debug_mark+1),a  
9d5c 3a 66 9d			ld a, (.dmark+2)  
9d5f 32 7c ee			ld (debug_mark+2),a  
9d62 18 03			jr .pastdmark  
9d64 ..			.dmark: db ":02"  
9d67 f1			.pastdmark: pop af  
9d68			endm  
# End of macro DMARK
9d68				CALLMONITOR 
9d68 cd 7b 91			call break_point_state  
9d6b				endm  
# End of macro CALLMONITOR
9d6b			endif 
9d6b			 
9d6b				 
9d6b					; malloc the size 
9d6b			 
9d6b cd 7e 8e				call malloc 
9d6e 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
9d71			 
9d71			;    db   1     ; user defined word  
9d71 3e 01				ld a, WORD_SYS_UWORD  
9d73 77					ld (hl), a 
9d74				 
9d74 23				inc hl    
9d75			;    dw   sysdict 
9d75 11 51 9a			ld de, sysdict       ; continue on with the scan to the system dict 
9d78 73				ld (hl), e 
9d79 23				inc hl 
9d7a 72				ld (hl), d 
9d7b 23				inc hl 
9d7c			 
9d7c			 
9d7c			;    Setup dict word 
9d7c			 
9d7c 23				inc hl 
9d7d 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
9d80			 
9d80				; 1. get length of dict word 
9d80			 
9d80			 
9d80 2a 76 e6			ld hl, (os_tok_ptr) 
9d83 23				inc hl 
9d84 23				inc hl    ; position to start of dict word 
9d85 3e 00			ld a, 0 
9d87 cd 20 8e			call strlent 
9d8a			 
9d8a			 
9d8a 23				inc hl    ; to include null??? 
9d8b			 
9d8b				; write length of dict word 
9d8b			 
9d8b ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9d8f 1b				dec de 
9d90 eb				ex de, hl 
9d91 73				ld (hl), e 
9d92 eb				ex de, hl 
9d93			 
9d93				 
9d93			 
9d93				; copy  
9d93 4d				ld c, l 
9d94 06 00			ld b, 0 
9d96 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9d9a 2a 76 e6			ld hl, (os_tok_ptr) 
9d9d 23				inc hl 
9d9e 23				inc hl    ; position to start of dict word 
9d9f				 
9d9f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9d9f				 
9d9f				; TODO need to convert word to upper case 
9d9f			 
9d9f			ucasetok:	 
9d9f 7e				ld a,(hl) 
9da0 cd 0c 8e			call toUpper 
9da3 77				ld (hl),a 
9da4 ed a0			ldi 
9da6 f2 9f 9d		 	jp p, ucasetok 
9da9			 
9da9			 
9da9			 
9da9				; de now points to start of where the word body code should be placed 
9da9 ed 53 79 e5		ld (os_new_work_ptr), de 
9dad				; hl now points to the words to throw at forthexec which needs to be copied 
9dad 22 7b e5			ld (os_new_src_ptr), hl 
9db0			 
9db0				; TODO add 'call to forthexec' 
9db0			 
9db0			if DEBUG_FORTH_UWORD 
9db0 c5				push bc 
9db1 ed 4b 73 e5		ld bc, (os_new_malloc) 
9db5						DMARK ":0x" 
9db5 f5				push af  
9db6 3a ca 9d			ld a, (.dmark)  
9db9 32 7a ee			ld (debug_mark),a  
9dbc 3a cb 9d			ld a, (.dmark+1)  
9dbf 32 7b ee			ld (debug_mark+1),a  
9dc2 3a cc 9d			ld a, (.dmark+2)  
9dc5 32 7c ee			ld (debug_mark+2),a  
9dc8 18 03			jr .pastdmark  
9dca ..			.dmark: db ":0x"  
9dcd f1			.pastdmark: pop af  
9dce			endm  
# End of macro DMARK
9dce				CALLMONITOR 
9dce cd 7b 91			call break_point_state  
9dd1				endm  
# End of macro CALLMONITOR
9dd1 c1				pop bc 
9dd2			endif 
9dd2			 
9dd2			 
9dd2				; create word preamble which should be: 
9dd2			 
9dd2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9dd2			 
9dd2				;    ld hl, <word code> 
9dd2				;    jp user_exec 
9dd2			        ;    <word code bytes> 
9dd2			 
9dd2			 
9dd2			;	inc de     ; TODO ??? or are we already past the word's null 
9dd2 eb				ex de, hl 
9dd3			 
9dd3 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9dd5			 
9dd5 23				inc hl 
9dd6 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9dd9 23				inc hl 
9dda			 
9dda 23				inc hl 
9ddb 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9ddd			 
9ddd 01 8a c0			ld bc, user_exec 
9de0 23				inc hl 
9de1 71				ld (hl), c     ; poke address of user_exec 
9de2 23				inc hl 
9de3 70				ld (hl), b     
9de4			 ; 
9de4			;	inc hl 
9de4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9de4			; 
9de4			; 
9de4			;	ld bc, macro_forth_rsp_next 
9de4			;	inc hl 
9de4			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9de4			;	inc hl 
9de4			;	ld (hl), b     
9de4			 ; 
9de4			;	inc hl 
9de4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9de4			; 
9de4			; 
9de4			;	inc hl 
9de4			;	ld bc, forthexec 
9de4			;	ld (hl), c     ; poke address of forthexec 
9de4			;	inc hl 
9de4			;	ld (hl), b      
9de4			; 
9de4			;	inc hl 
9de4			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9de4			; 
9de4			;	ld bc, user_dict_next 
9de4			;	inc hl 
9de4			;	ld (hl), c     ; poke address of forthexec 
9de4			;	inc hl 
9de4			;	ld (hl), b      
9de4			 
9de4				; hl is now where we need to copy the word byte data to save this 
9de4			 
9de4 23				inc hl 
9de5 22 7d e5			ld (os_new_exec), hl 
9de8				 
9de8				; copy definition 
9de8			 
9de8 eb				ex de, hl 
9de9			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9de9			;	inc de    ; skip the PC for this parse 
9de9 3a 75 e5			ld a, (os_new_parse_len) 
9dec 4f				ld c, a 
9ded 06 00			ld b, 0 
9def ed b0			ldir		 ; copy defintion 
9df1			 
9df1			 
9df1				; poke the address of where the new word bytes live for forthexec 
9df1			 
9df1 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9df4			 
9df4 ed 5b 7d e5		ld de, (os_new_exec)      
9df8				 
9df8 73				ld (hl), e 
9df9 23				inc hl 
9dfa 72				ld (hl), d 
9dfb			 
9dfb					; TODO copy last user dict word next link to this word 
9dfb					; TODO update last user dict word to point to this word 
9dfb			; 
9dfb			; hl f923 de 812a ; bc 811a 
9dfb			 
9dfb			if DEBUG_FORTH_UWORD 
9dfb c5				push bc 
9dfc ed 4b 73 e5		ld bc, (os_new_malloc) 
9e00						DMARK ":0A" 
9e00 f5				push af  
9e01 3a 15 9e			ld a, (.dmark)  
9e04 32 7a ee			ld (debug_mark),a  
9e07 3a 16 9e			ld a, (.dmark+1)  
9e0a 32 7b ee			ld (debug_mark+1),a  
9e0d 3a 17 9e			ld a, (.dmark+2)  
9e10 32 7c ee			ld (debug_mark+2),a  
9e13 18 03			jr .pastdmark  
9e15 ..			.dmark: db ":0A"  
9e18 f1			.pastdmark: pop af  
9e19			endm  
# End of macro DMARK
9e19				CALLMONITOR 
9e19 cd 7b 91			call break_point_state  
9e1c				endm  
# End of macro CALLMONITOR
9e1c c1				pop bc 
9e1d			endif 
9e1d			if DEBUG_FORTH_UWORD 
9e1d c5				push bc 
9e1e ed 4b 73 e5		ld bc, (os_new_malloc) 
9e22 03				inc bc 
9e23 03				inc bc 
9e24 03				inc bc 
9e25 03				inc bc 
9e26 03				inc bc 
9e27 03				inc bc 
9e28 03				inc bc 
9e29 03				inc bc 
9e2a			 
9e2a						DMARK ":0B" 
9e2a f5				push af  
9e2b 3a 3f 9e			ld a, (.dmark)  
9e2e 32 7a ee			ld (debug_mark),a  
9e31 3a 40 9e			ld a, (.dmark+1)  
9e34 32 7b ee			ld (debug_mark+1),a  
9e37 3a 41 9e			ld a, (.dmark+2)  
9e3a 32 7c ee			ld (debug_mark+2),a  
9e3d 18 03			jr .pastdmark  
9e3f ..			.dmark: db ":0B"  
9e42 f1			.pastdmark: pop af  
9e43			endm  
# End of macro DMARK
9e43				CALLMONITOR 
9e43 cd 7b 91			call break_point_state  
9e46				endm  
# End of macro CALLMONITOR
9e46 c1				pop bc 
9e47			endif 
9e47			 
9e47			; update word dict linked list for new word 
9e47			 
9e47			 
9e47 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9e4a 23			inc hl     ; move to next work linked list ptr 
9e4b			 
9e4b ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
9e4f 73			ld (hl), e 
9e50 23			inc hl 
9e51 72			ld (hl), d 
9e52			 
9e52			if DEBUG_FORTH_UWORD 
9e52 ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
9e56			endif 
9e56			 
9e56 ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
9e5a			 
9e5a			 
9e5a			if DEBUG_FORTH_UWORD 
9e5a						DMARK ":0+" 
9e5a f5				push af  
9e5b 3a 6f 9e			ld a, (.dmark)  
9e5e 32 7a ee			ld (debug_mark),a  
9e61 3a 70 9e			ld a, (.dmark+1)  
9e64 32 7b ee			ld (debug_mark+1),a  
9e67 3a 71 9e			ld a, (.dmark+2)  
9e6a 32 7c ee			ld (debug_mark+2),a  
9e6d 18 03			jr .pastdmark  
9e6f ..			.dmark: db ":0+"  
9e72 f1			.pastdmark: pop af  
9e73			endm  
# End of macro DMARK
9e73				CALLMONITOR 
9e73 cd 7b 91			call break_point_state  
9e76				endm  
# End of macro CALLMONITOR
9e76			endif 
9e76			 
9e76				STACKFRAMECHK OFF $8efe $989f 
9e76				if DEBUG_STACK_IMB 
9e76					if OFF 
9e76						exx 
9e76						ld hl, $989f 
9e76						pop de   ; $989f 
9e76						call cmp16 
9e76						jr nz, .spnosame 
9e76						ld hl, $8efe 
9e76						pop de   ; $8efe 
9e76						call cmp16 
9e76						jr z, .spfrsame 
9e76						.spnosame: call showsperror 
9e76						.spfrsame: nop 
9e76						exx 
9e76					endif 
9e76				endif 
9e76			endm 
# End of macro STACKFRAMECHK
9e76			 
9e76 c9			ret    ; dont process any remaining parser tokens as they form new word 
9e77			 
9e77			 
9e77			 
9e77			 
9e77			;		NEXT 
9e77			.SCOLN: 
9e77			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
9e77 06				db OPCODE_SCOLN 
9e78 c3 9e			dw .DROP 
9e7a 02				db 2 
9e7b .. 00			db ";",0           
9e7d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
9e7d					if DEBUG_FORTH_WORDS_KEY 
9e7d						DMARK "SCN" 
9e7d f5				push af  
9e7e 3a 92 9e			ld a, (.dmark)  
9e81 32 7a ee			ld (debug_mark),a  
9e84 3a 93 9e			ld a, (.dmark+1)  
9e87 32 7b ee			ld (debug_mark+1),a  
9e8a 3a 94 9e			ld a, (.dmark+2)  
9e8d 32 7c ee			ld (debug_mark+2),a  
9e90 18 03			jr .pastdmark  
9e92 ..			.dmark: db "SCN"  
9e95 f1			.pastdmark: pop af  
9e96			endm  
# End of macro DMARK
9e96						CALLMONITOR 
9e96 cd 7b 91			call break_point_state  
9e99				endm  
# End of macro CALLMONITOR
9e99					endif 
9e99					FORTH_RSP_TOS 
9e99 cd c6 96			call macro_forth_rsp_tos 
9e9c				endm 
# End of macro FORTH_RSP_TOS
9e9c e5					push hl 
9e9d					FORTH_RSP_POP 
9e9d cd d0 96			call macro_forth_rsp_pop 
9ea0				endm 
# End of macro FORTH_RSP_POP
9ea0 e1					pop hl 
9ea1			;		ex de,hl 
9ea1 22 76 e6				ld (os_tok_ptr),hl 
9ea4			 
9ea4			if DEBUG_FORTH_UWORD 
9ea4						DMARK "SCL" 
9ea4 f5				push af  
9ea5 3a b9 9e			ld a, (.dmark)  
9ea8 32 7a ee			ld (debug_mark),a  
9eab 3a ba 9e			ld a, (.dmark+1)  
9eae 32 7b ee			ld (debug_mark+1),a  
9eb1 3a bb 9e			ld a, (.dmark+2)  
9eb4 32 7c ee			ld (debug_mark+2),a  
9eb7 18 03			jr .pastdmark  
9eb9 ..			.dmark: db "SCL"  
9ebc f1			.pastdmark: pop af  
9ebd			endm  
# End of macro DMARK
9ebd				CALLMONITOR 
9ebd cd 7b 91			call break_point_state  
9ec0				endm  
# End of macro CALLMONITOR
9ec0			endif 
9ec0					NEXTW 
9ec0 c3 f9 98			jp macro_next 
9ec3				endm 
# End of macro NEXTW
9ec3			 
9ec3			.DROP: 
9ec3				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
9ec3 1b				db WORD_SYS_CORE+OPCODE_DROP             
9ec4 ee 9e			dw .DUP2            
9ec6 05				db 4 + 1 
9ec7 .. 00			db "DROP",0              
9ecc				endm 
# End of macro CWHEAD
9ecc			; | DROP ( w -- )   drop the TOS item   | DONE 
9ecc					if DEBUG_FORTH_WORDS_KEY 
9ecc						DMARK "DRP" 
9ecc f5				push af  
9ecd 3a e1 9e			ld a, (.dmark)  
9ed0 32 7a ee			ld (debug_mark),a  
9ed3 3a e2 9e			ld a, (.dmark+1)  
9ed6 32 7b ee			ld (debug_mark+1),a  
9ed9 3a e3 9e			ld a, (.dmark+2)  
9edc 32 7c ee			ld (debug_mark+2),a  
9edf 18 03			jr .pastdmark  
9ee1 ..			.dmark: db "DRP"  
9ee4 f1			.pastdmark: pop af  
9ee5			endm  
# End of macro DMARK
9ee5						CALLMONITOR 
9ee5 cd 7b 91			call break_point_state  
9ee8				endm  
# End of macro CALLMONITOR
9ee8					endif 
9ee8					FORTH_DSP_POP 
9ee8 cd 3f 98			call macro_forth_dsp_pop 
9eeb				endm 
# End of macro FORTH_DSP_POP
9eeb					NEXTW 
9eeb c3 f9 98			jp macro_next 
9eee				endm 
# End of macro NEXTW
9eee			.DUP2: 
9eee				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
9eee 1c				db WORD_SYS_CORE+OPCODE_DUP2             
9eef 33 9f			dw .DROP2            
9ef1 05				db 4 + 1 
9ef2 .. 00			db "2DUP",0              
9ef7				endm 
# End of macro CWHEAD
9ef7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
9ef7					if DEBUG_FORTH_WORDS_KEY 
9ef7						DMARK "2DU" 
9ef7 f5				push af  
9ef8 3a 0c 9f			ld a, (.dmark)  
9efb 32 7a ee			ld (debug_mark),a  
9efe 3a 0d 9f			ld a, (.dmark+1)  
9f01 32 7b ee			ld (debug_mark+1),a  
9f04 3a 0e 9f			ld a, (.dmark+2)  
9f07 32 7c ee			ld (debug_mark+2),a  
9f0a 18 03			jr .pastdmark  
9f0c ..			.dmark: db "2DU"  
9f0f f1			.pastdmark: pop af  
9f10			endm  
# End of macro DMARK
9f10						CALLMONITOR 
9f10 cd 7b 91			call break_point_state  
9f13				endm  
# End of macro CALLMONITOR
9f13					endif 
9f13					FORTH_DSP_VALUEHL 
9f13 cd a3 97			call macro_dsp_valuehl 
9f16				endm 
# End of macro FORTH_DSP_VALUEHL
9f16 e5					push hl      ; 2 
9f17			 
9f17					FORTH_DSP_POP 
9f17 cd 3f 98			call macro_forth_dsp_pop 
9f1a				endm 
# End of macro FORTH_DSP_POP
9f1a					 
9f1a					FORTH_DSP_VALUEHL 
9f1a cd a3 97			call macro_dsp_valuehl 
9f1d				endm 
# End of macro FORTH_DSP_VALUEHL
9f1d			;		push hl      ; 1 
9f1d			 
9f1d					FORTH_DSP_POP 
9f1d cd 3f 98			call macro_forth_dsp_pop 
9f20				endm 
# End of macro FORTH_DSP_POP
9f20			 
9f20			;		pop hl       ; 1 
9f20 d1					pop de       ; 2 
9f21			 
9f21 cd 08 97				call forth_push_numhl 
9f24 eb					ex de, hl 
9f25 cd 08 97				call forth_push_numhl 
9f28			 
9f28					 
9f28 eb					ex de, hl 
9f29			 
9f29 cd 08 97				call forth_push_numhl 
9f2c eb					ex de, hl 
9f2d cd 08 97				call forth_push_numhl 
9f30			 
9f30			 
9f30					NEXTW 
9f30 c3 f9 98			jp macro_next 
9f33				endm 
# End of macro NEXTW
9f33			.DROP2: 
9f33				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
9f33 1d				db WORD_SYS_CORE+OPCODE_DROP2             
9f34 62 9f			dw .SWAP2            
9f36 06				db 5 + 1 
9f37 .. 00			db "2DROP",0              
9f3d				endm 
# End of macro CWHEAD
9f3d			; | 2DROP ( w w -- )    Double drop | DONE 
9f3d					if DEBUG_FORTH_WORDS_KEY 
9f3d						DMARK "2DR" 
9f3d f5				push af  
9f3e 3a 52 9f			ld a, (.dmark)  
9f41 32 7a ee			ld (debug_mark),a  
9f44 3a 53 9f			ld a, (.dmark+1)  
9f47 32 7b ee			ld (debug_mark+1),a  
9f4a 3a 54 9f			ld a, (.dmark+2)  
9f4d 32 7c ee			ld (debug_mark+2),a  
9f50 18 03			jr .pastdmark  
9f52 ..			.dmark: db "2DR"  
9f55 f1			.pastdmark: pop af  
9f56			endm  
# End of macro DMARK
9f56						CALLMONITOR 
9f56 cd 7b 91			call break_point_state  
9f59				endm  
# End of macro CALLMONITOR
9f59					endif 
9f59					FORTH_DSP_POP 
9f59 cd 3f 98			call macro_forth_dsp_pop 
9f5c				endm 
# End of macro FORTH_DSP_POP
9f5c					FORTH_DSP_POP 
9f5c cd 3f 98			call macro_forth_dsp_pop 
9f5f				endm 
# End of macro FORTH_DSP_POP
9f5f					NEXTW 
9f5f c3 f9 98			jp macro_next 
9f62				endm 
# End of macro NEXTW
9f62			.SWAP2: 
9f62				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
9f62 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
9f63 8b 9f			dw .AT            
9f65 06				db 5 + 1 
9f66 .. 00			db "2SWAP",0              
9f6c				endm 
# End of macro CWHEAD
9f6c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
9f6c					if DEBUG_FORTH_WORDS_KEY 
9f6c						DMARK "2SW" 
9f6c f5				push af  
9f6d 3a 81 9f			ld a, (.dmark)  
9f70 32 7a ee			ld (debug_mark),a  
9f73 3a 82 9f			ld a, (.dmark+1)  
9f76 32 7b ee			ld (debug_mark+1),a  
9f79 3a 83 9f			ld a, (.dmark+2)  
9f7c 32 7c ee			ld (debug_mark+2),a  
9f7f 18 03			jr .pastdmark  
9f81 ..			.dmark: db "2SW"  
9f84 f1			.pastdmark: pop af  
9f85			endm  
# End of macro DMARK
9f85						CALLMONITOR 
9f85 cd 7b 91			call break_point_state  
9f88				endm  
# End of macro CALLMONITOR
9f88					endif 
9f88					NEXTW 
9f88 c3 f9 98			jp macro_next 
9f8b				endm 
# End of macro NEXTW
9f8b			.AT: 
9f8b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
9f8b 1f				db WORD_SYS_CORE+OPCODE_AT             
9f8c bd 9f			dw .CAT            
9f8e 02				db 1 + 1 
9f8f .. 00			db "@",0              
9f91				endm 
# End of macro CWHEAD
9f91			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
9f91			 
9f91					if DEBUG_FORTH_WORDS_KEY 
9f91						DMARK "AT." 
9f91 f5				push af  
9f92 3a a6 9f			ld a, (.dmark)  
9f95 32 7a ee			ld (debug_mark),a  
9f98 3a a7 9f			ld a, (.dmark+1)  
9f9b 32 7b ee			ld (debug_mark+1),a  
9f9e 3a a8 9f			ld a, (.dmark+2)  
9fa1 32 7c ee			ld (debug_mark+2),a  
9fa4 18 03			jr .pastdmark  
9fa6 ..			.dmark: db "AT."  
9fa9 f1			.pastdmark: pop af  
9faa			endm  
# End of macro DMARK
9faa						CALLMONITOR 
9faa cd 7b 91			call break_point_state  
9fad				endm  
# End of macro CALLMONITOR
9fad					endif 
9fad			.getbyteat:	 
9fad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fad cd a3 97			call macro_dsp_valuehl 
9fb0				endm 
# End of macro FORTH_DSP_VALUEHL
9fb0					 
9fb0			;		push hl 
9fb0				 
9fb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9fb0 cd 3f 98			call macro_forth_dsp_pop 
9fb3				endm 
# End of macro FORTH_DSP_POP
9fb3			 
9fb3			;		pop hl 
9fb3			 
9fb3 7e					ld a, (hl) 
9fb4			 
9fb4 6f					ld l, a 
9fb5 26 00				ld h, 0 
9fb7 cd 08 97				call forth_push_numhl 
9fba			 
9fba					NEXTW 
9fba c3 f9 98			jp macro_next 
9fbd				endm 
# End of macro NEXTW
9fbd			.CAT: 
9fbd				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
9fbd 20				db WORD_SYS_CORE+OPCODE_CAT             
9fbe e6 9f			dw .BANG            
9fc0 03				db 2 + 1 
9fc1 .. 00			db "C@",0              
9fc4				endm 
# End of macro CWHEAD
9fc4			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
9fc4					if DEBUG_FORTH_WORDS_KEY 
9fc4						DMARK "CAA" 
9fc4 f5				push af  
9fc5 3a d9 9f			ld a, (.dmark)  
9fc8 32 7a ee			ld (debug_mark),a  
9fcb 3a da 9f			ld a, (.dmark+1)  
9fce 32 7b ee			ld (debug_mark+1),a  
9fd1 3a db 9f			ld a, (.dmark+2)  
9fd4 32 7c ee			ld (debug_mark+2),a  
9fd7 18 03			jr .pastdmark  
9fd9 ..			.dmark: db "CAA"  
9fdc f1			.pastdmark: pop af  
9fdd			endm  
# End of macro DMARK
9fdd						CALLMONITOR 
9fdd cd 7b 91			call break_point_state  
9fe0				endm  
# End of macro CALLMONITOR
9fe0					endif 
9fe0 c3 ad 9f				jp .getbyteat 
9fe3					NEXTW 
9fe3 c3 f9 98			jp macro_next 
9fe6				endm 
# End of macro NEXTW
9fe6			.BANG: 
9fe6				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
9fe6 21				db WORD_SYS_CORE+OPCODE_BANG             
9fe7 1c a0			dw .CBANG            
9fe9 02				db 1 + 1 
9fea .. 00			db "!",0              
9fec				endm 
# End of macro CWHEAD
9fec			; | ! ( x w -- ) Store x at address w      | DONE 
9fec					if DEBUG_FORTH_WORDS_KEY 
9fec						DMARK "BNG" 
9fec f5				push af  
9fed 3a 01 a0			ld a, (.dmark)  
9ff0 32 7a ee			ld (debug_mark),a  
9ff3 3a 02 a0			ld a, (.dmark+1)  
9ff6 32 7b ee			ld (debug_mark+1),a  
9ff9 3a 03 a0			ld a, (.dmark+2)  
9ffc 32 7c ee			ld (debug_mark+2),a  
9fff 18 03			jr .pastdmark  
a001 ..			.dmark: db "BNG"  
a004 f1			.pastdmark: pop af  
a005			endm  
# End of macro DMARK
a005						CALLMONITOR 
a005 cd 7b 91			call break_point_state  
a008				endm  
# End of macro CALLMONITOR
a008					endif 
a008			 
a008			.storebyteat:		 
a008					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a008 cd a3 97			call macro_dsp_valuehl 
a00b				endm 
# End of macro FORTH_DSP_VALUEHL
a00b					 
a00b e5					push hl 
a00c				 
a00c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a00c cd 3f 98			call macro_forth_dsp_pop 
a00f				endm 
# End of macro FORTH_DSP_POP
a00f			 
a00f					; get byte to poke 
a00f			 
a00f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a00f cd a3 97			call macro_dsp_valuehl 
a012				endm 
# End of macro FORTH_DSP_VALUEHL
a012 e5					push hl 
a013			 
a013			 
a013					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a013 cd 3f 98			call macro_forth_dsp_pop 
a016				endm 
# End of macro FORTH_DSP_POP
a016			 
a016			 
a016 d1					pop de 
a017 e1					pop hl 
a018			 
a018 73					ld (hl),e 
a019			 
a019			 
a019					NEXTW 
a019 c3 f9 98			jp macro_next 
a01c				endm 
# End of macro NEXTW
a01c			.CBANG: 
a01c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a01c 22				db WORD_SYS_CORE+OPCODE_CBANG             
a01d 45 a0			dw .SCALL            
a01f 03				db 2 + 1 
a020 .. 00			db "C!",0              
a023				endm 
# End of macro CWHEAD
a023			; | C!  ( x w -- ) Store x at address w  | DONE 
a023					if DEBUG_FORTH_WORDS_KEY 
a023						DMARK "CBA" 
a023 f5				push af  
a024 3a 38 a0			ld a, (.dmark)  
a027 32 7a ee			ld (debug_mark),a  
a02a 3a 39 a0			ld a, (.dmark+1)  
a02d 32 7b ee			ld (debug_mark+1),a  
a030 3a 3a a0			ld a, (.dmark+2)  
a033 32 7c ee			ld (debug_mark+2),a  
a036 18 03			jr .pastdmark  
a038 ..			.dmark: db "CBA"  
a03b f1			.pastdmark: pop af  
a03c			endm  
# End of macro DMARK
a03c						CALLMONITOR 
a03c cd 7b 91			call break_point_state  
a03f				endm  
# End of macro CALLMONITOR
a03f					endif 
a03f c3 08 a0				jp .storebyteat 
a042					NEXTW 
a042 c3 f9 98			jp macro_next 
a045				endm 
# End of macro NEXTW
a045			.SCALL: 
a045				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a045 23				db WORD_SYS_CORE+OPCODE_SCALL             
a046 79 a0			dw .DEPTH            
a048 05				db 4 + 1 
a049 .. 00			db "CALL",0              
a04e				endm 
# End of macro CWHEAD
a04e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a04e					if DEBUG_FORTH_WORDS_KEY 
a04e						DMARK "CLL" 
a04e f5				push af  
a04f 3a 63 a0			ld a, (.dmark)  
a052 32 7a ee			ld (debug_mark),a  
a055 3a 64 a0			ld a, (.dmark+1)  
a058 32 7b ee			ld (debug_mark+1),a  
a05b 3a 65 a0			ld a, (.dmark+2)  
a05e 32 7c ee			ld (debug_mark+2),a  
a061 18 03			jr .pastdmark  
a063 ..			.dmark: db "CLL"  
a066 f1			.pastdmark: pop af  
a067			endm  
# End of macro DMARK
a067						CALLMONITOR 
a067 cd 7b 91			call break_point_state  
a06a				endm  
# End of macro CALLMONITOR
a06a					endif 
a06a			 
a06a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a06a cd a3 97			call macro_dsp_valuehl 
a06d				endm 
# End of macro FORTH_DSP_VALUEHL
a06d			 
a06d			;		push hl 
a06d			 
a06d					; destroy value TOS 
a06d			 
a06d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a06d cd 3f 98			call macro_forth_dsp_pop 
a070				endm 
# End of macro FORTH_DSP_POP
a070			 
a070						 
a070			;		pop hl 
a070			 
a070					; how to do a call with hl???? save SP? 
a070 cd a2 98				call forth_call_hl 
a073			 
a073			 
a073					; TODO push value back onto stack for another op etc 
a073			 
a073 cd 08 97				call forth_push_numhl 
a076					NEXTW 
a076 c3 f9 98			jp macro_next 
a079				endm 
# End of macro NEXTW
a079			.DEPTH: 
a079				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a079 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a07a b6 a0			dw .OVER            
a07c 06				db 5 + 1 
a07d .. 00			db "DEPTH",0              
a083				endm 
# End of macro CWHEAD
a083			; | DEPTH ( -- u ) Push count of stack | DONE 
a083					; take current TOS and remove from base value div by two to get count 
a083					if DEBUG_FORTH_WORDS_KEY 
a083						DMARK "DEP" 
a083 f5				push af  
a084 3a 98 a0			ld a, (.dmark)  
a087 32 7a ee			ld (debug_mark),a  
a08a 3a 99 a0			ld a, (.dmark+1)  
a08d 32 7b ee			ld (debug_mark+1),a  
a090 3a 9a a0			ld a, (.dmark+2)  
a093 32 7c ee			ld (debug_mark+2),a  
a096 18 03			jr .pastdmark  
a098 ..			.dmark: db "DEP"  
a09b f1			.pastdmark: pop af  
a09c			endm  
# End of macro DMARK
a09c						CALLMONITOR 
a09c cd 7b 91			call break_point_state  
a09f				endm  
# End of macro CALLMONITOR
a09f					endif 
a09f			 
a09f			 
a09f 2a 22 eb			ld hl, (cli_data_sp) 
a0a2 11 dc e8			ld de, cli_data_stack 
a0a5 ed 52			sbc hl,de 
a0a7				 
a0a7				; div by size of stack item 
a0a7			 
a0a7 5d				ld e,l 
a0a8 0e 03			ld c, 3 
a0aa cd 47 89			call Div8 
a0ad			 
a0ad 6f				ld l,a 
a0ae 26 00			ld h,0 
a0b0			 
a0b0				;srl h 
a0b0				;rr l 
a0b0			 
a0b0 cd 08 97				call forth_push_numhl 
a0b3					NEXTW 
a0b3 c3 f9 98			jp macro_next 
a0b6				endm 
# End of macro NEXTW
a0b6			.OVER: 
a0b6				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a0b6 42				db WORD_SYS_CORE+46             
a0b7 fd a0			dw .PAUSE            
a0b9 05				db 4 + 1 
a0ba .. 00			db "OVER",0              
a0bf				endm 
# End of macro CWHEAD
a0bf			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a0bf					if DEBUG_FORTH_WORDS_KEY 
a0bf						DMARK "OVR" 
a0bf f5				push af  
a0c0 3a d4 a0			ld a, (.dmark)  
a0c3 32 7a ee			ld (debug_mark),a  
a0c6 3a d5 a0			ld a, (.dmark+1)  
a0c9 32 7b ee			ld (debug_mark+1),a  
a0cc 3a d6 a0			ld a, (.dmark+2)  
a0cf 32 7c ee			ld (debug_mark+2),a  
a0d2 18 03			jr .pastdmark  
a0d4 ..			.dmark: db "OVR"  
a0d7 f1			.pastdmark: pop af  
a0d8			endm  
# End of macro DMARK
a0d8						CALLMONITOR 
a0d8 cd 7b 91			call break_point_state  
a0db				endm  
# End of macro CALLMONITOR
a0db					endif 
a0db			 
a0db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0db cd a3 97			call macro_dsp_valuehl 
a0de				endm 
# End of macro FORTH_DSP_VALUEHL
a0de e5					push hl    ; n2 
a0df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a0df cd 3f 98			call macro_forth_dsp_pop 
a0e2				endm 
# End of macro FORTH_DSP_POP
a0e2			 
a0e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0e2 cd a3 97			call macro_dsp_valuehl 
a0e5				endm 
# End of macro FORTH_DSP_VALUEHL
a0e5 e5					push hl    ; n1 
a0e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a0e6 cd 3f 98			call macro_forth_dsp_pop 
a0e9				endm 
# End of macro FORTH_DSP_POP
a0e9			 
a0e9 d1					pop de     ; n1 
a0ea e1					pop hl     ; n2 
a0eb			 
a0eb d5					push de 
a0ec e5					push hl 
a0ed d5					push de 
a0ee			 
a0ee					; push back  
a0ee			 
a0ee e1					pop hl 
a0ef cd 08 97				call forth_push_numhl 
a0f2 e1					pop hl 
a0f3 cd 08 97				call forth_push_numhl 
a0f6 e1					pop hl 
a0f7 cd 08 97				call forth_push_numhl 
a0fa					NEXTW 
a0fa c3 f9 98			jp macro_next 
a0fd				endm 
# End of macro NEXTW
a0fd			 
a0fd			.PAUSE: 
a0fd				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a0fd 43				db WORD_SYS_CORE+47             
a0fe 32 a1			dw .PAUSES            
a100 08				db 7 + 1 
a101 .. 00			db "PAUSEMS",0              
a109				endm 
# End of macro CWHEAD
a109			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a109					if DEBUG_FORTH_WORDS_KEY 
a109						DMARK "PMS" 
a109 f5				push af  
a10a 3a 1e a1			ld a, (.dmark)  
a10d 32 7a ee			ld (debug_mark),a  
a110 3a 1f a1			ld a, (.dmark+1)  
a113 32 7b ee			ld (debug_mark+1),a  
a116 3a 20 a1			ld a, (.dmark+2)  
a119 32 7c ee			ld (debug_mark+2),a  
a11c 18 03			jr .pastdmark  
a11e ..			.dmark: db "PMS"  
a121 f1			.pastdmark: pop af  
a122			endm  
# End of macro DMARK
a122						CALLMONITOR 
a122 cd 7b 91			call break_point_state  
a125				endm  
# End of macro CALLMONITOR
a125					endif 
a125					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a125 cd a3 97			call macro_dsp_valuehl 
a128				endm 
# End of macro FORTH_DSP_VALUEHL
a128			;		push hl    ; n2 
a128					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a128 cd 3f 98			call macro_forth_dsp_pop 
a12b				endm 
# End of macro FORTH_DSP_POP
a12b			;		pop hl 
a12b			 
a12b 7d					ld a, l 
a12c cd c7 87				call aDelayInMS 
a12f				       NEXTW 
a12f c3 f9 98			jp macro_next 
a132				endm 
# End of macro NEXTW
a132			.PAUSES:  
a132				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a132 44				db WORD_SYS_CORE+48             
a133 a1 a1			dw .ROT            
a135 06				db 5 + 1 
a136 .. 00			db "PAUSE",0              
a13c				endm 
# End of macro CWHEAD
a13c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a13c					if DEBUG_FORTH_WORDS_KEY 
a13c						DMARK "PAU" 
a13c f5				push af  
a13d 3a 51 a1			ld a, (.dmark)  
a140 32 7a ee			ld (debug_mark),a  
a143 3a 52 a1			ld a, (.dmark+1)  
a146 32 7b ee			ld (debug_mark+1),a  
a149 3a 53 a1			ld a, (.dmark+2)  
a14c 32 7c ee			ld (debug_mark+2),a  
a14f 18 03			jr .pastdmark  
a151 ..			.dmark: db "PAU"  
a154 f1			.pastdmark: pop af  
a155			endm  
# End of macro DMARK
a155						CALLMONITOR 
a155 cd 7b 91			call break_point_state  
a158				endm  
# End of macro CALLMONITOR
a158					endif 
a158					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a158 cd a3 97			call macro_dsp_valuehl 
a15b				endm 
# End of macro FORTH_DSP_VALUEHL
a15b			;		push hl    ; n2 
a15b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a15b cd 3f 98			call macro_forth_dsp_pop 
a15e				endm 
# End of macro FORTH_DSP_POP
a15e			;		pop hl 
a15e 45					ld b, l 
a15f					if DEBUG_FORTH_WORDS 
a15f						DMARK "PAU" 
a15f f5				push af  
a160 3a 74 a1			ld a, (.dmark)  
a163 32 7a ee			ld (debug_mark),a  
a166 3a 75 a1			ld a, (.dmark+1)  
a169 32 7b ee			ld (debug_mark+1),a  
a16c 3a 76 a1			ld a, (.dmark+2)  
a16f 32 7c ee			ld (debug_mark+2),a  
a172 18 03			jr .pastdmark  
a174 ..			.dmark: db "PAU"  
a177 f1			.pastdmark: pop af  
a178			endm  
# End of macro DMARK
a178						CALLMONITOR 
a178 cd 7b 91			call break_point_state  
a17b				endm  
# End of macro CALLMONITOR
a17b					endif 
a17b c5			.pauses1:	push bc 
a17c cd e2 87				call delay1s 
a17f c1					pop bc 
a180					if DEBUG_FORTH_WORDS 
a180						DMARK "PA1" 
a180 f5				push af  
a181 3a 95 a1			ld a, (.dmark)  
a184 32 7a ee			ld (debug_mark),a  
a187 3a 96 a1			ld a, (.dmark+1)  
a18a 32 7b ee			ld (debug_mark+1),a  
a18d 3a 97 a1			ld a, (.dmark+2)  
a190 32 7c ee			ld (debug_mark+2),a  
a193 18 03			jr .pastdmark  
a195 ..			.dmark: db "PA1"  
a198 f1			.pastdmark: pop af  
a199			endm  
# End of macro DMARK
a199						CALLMONITOR 
a199 cd 7b 91			call break_point_state  
a19c				endm  
# End of macro CALLMONITOR
a19c					endif 
a19c 10 dd				djnz .pauses1 
a19e			 
a19e				       NEXTW 
a19e c3 f9 98			jp macro_next 
a1a1				endm 
# End of macro NEXTW
a1a1			.ROT: 
a1a1				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a1a1 45				db WORD_SYS_CORE+49             
a1a2 ef a1			dw .UWORDS            
a1a4 04				db 3 + 1 
a1a5 .. 00			db "ROT",0              
a1a9				endm 
# End of macro CWHEAD
a1a9			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a1a9					if DEBUG_FORTH_WORDS_KEY 
a1a9						DMARK "ROT" 
a1a9 f5				push af  
a1aa 3a be a1			ld a, (.dmark)  
a1ad 32 7a ee			ld (debug_mark),a  
a1b0 3a bf a1			ld a, (.dmark+1)  
a1b3 32 7b ee			ld (debug_mark+1),a  
a1b6 3a c0 a1			ld a, (.dmark+2)  
a1b9 32 7c ee			ld (debug_mark+2),a  
a1bc 18 03			jr .pastdmark  
a1be ..			.dmark: db "ROT"  
a1c1 f1			.pastdmark: pop af  
a1c2			endm  
# End of macro DMARK
a1c2						CALLMONITOR 
a1c2 cd 7b 91			call break_point_state  
a1c5				endm  
# End of macro CALLMONITOR
a1c5					endif 
a1c5			 
a1c5					FORTH_DSP_VALUEHL 
a1c5 cd a3 97			call macro_dsp_valuehl 
a1c8				endm 
# End of macro FORTH_DSP_VALUEHL
a1c8 e5					push hl    ; u3  
a1c9			 
a1c9					FORTH_DSP_POP 
a1c9 cd 3f 98			call macro_forth_dsp_pop 
a1cc				endm 
# End of macro FORTH_DSP_POP
a1cc			   
a1cc					FORTH_DSP_VALUEHL 
a1cc cd a3 97			call macro_dsp_valuehl 
a1cf				endm 
# End of macro FORTH_DSP_VALUEHL
a1cf e5					push hl     ; u2 
a1d0			 
a1d0					FORTH_DSP_POP 
a1d0 cd 3f 98			call macro_forth_dsp_pop 
a1d3				endm 
# End of macro FORTH_DSP_POP
a1d3			 
a1d3					FORTH_DSP_VALUEHL 
a1d3 cd a3 97			call macro_dsp_valuehl 
a1d6				endm 
# End of macro FORTH_DSP_VALUEHL
a1d6 e5					push hl     ; u1 
a1d7			 
a1d7					FORTH_DSP_POP 
a1d7 cd 3f 98			call macro_forth_dsp_pop 
a1da				endm 
# End of macro FORTH_DSP_POP
a1da			 
a1da c1					pop bc      ; u1 
a1db e1					pop hl      ; u2 
a1dc d1					pop de      ; u3 
a1dd			 
a1dd			 
a1dd c5					push bc 
a1de d5					push de 
a1df e5					push hl 
a1e0			 
a1e0			 
a1e0 e1					pop hl 
a1e1 cd 08 97				call forth_push_numhl 
a1e4			 
a1e4 e1					pop hl 
a1e5 cd 08 97				call forth_push_numhl 
a1e8			 
a1e8 e1					pop hl 
a1e9 cd 08 97				call forth_push_numhl 
a1ec					 
a1ec			 
a1ec			 
a1ec			 
a1ec			 
a1ec			 
a1ec				       NEXTW 
a1ec c3 f9 98			jp macro_next 
a1ef				endm 
# End of macro NEXTW
a1ef			 
a1ef			.UWORDS: 
a1ef				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a1ef 50				db WORD_SYS_CORE+60             
a1f0 b1 a2			dw .BP            
a1f2 07				db 6 + 1 
a1f3 .. 00			db "UWORDS",0              
a1fa				endm 
# End of macro CWHEAD
a1fa			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a1fa			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a1fa			; | | Following the count are the individual words. 
a1fa			; | | 
a1fa			; | | e.g. UWORDS 
a1fa			; | | BOX DIRLIST 2 
a1fa			; | |  
a1fa			; | | Can be used to save the words to storage via: 
a1fa			; | | UWORDS $01 DO $01 APPEND LOOP 
a1fa				if DEBUG_FORTH_WORDS_KEY 
a1fa					DMARK "UWR" 
a1fa f5				push af  
a1fb 3a 0f a2			ld a, (.dmark)  
a1fe 32 7a ee			ld (debug_mark),a  
a201 3a 10 a2			ld a, (.dmark+1)  
a204 32 7b ee			ld (debug_mark+1),a  
a207 3a 11 a2			ld a, (.dmark+2)  
a20a 32 7c ee			ld (debug_mark+2),a  
a20d 18 03			jr .pastdmark  
a20f ..			.dmark: db "UWR"  
a212 f1			.pastdmark: pop af  
a213			endm  
# End of macro DMARK
a213					CALLMONITOR 
a213 cd 7b 91			call break_point_state  
a216				endm  
# End of macro CALLMONITOR
a216				endif 
a216 21 a7 d4				ld hl, baseram 
a219					;ld hl, baseusermem 
a219 01 00 00				ld bc, 0    ; start a counter 
a21c			 
a21c				; skip dict stub 
a21c			 
a21c cd 4a 9a				call forth_tok_next 
a21f			 
a21f			 
a21f			; while we have words to look for 
a21f			 
a21f 7e			.douscan:	ld a, (hl)      
a220				if DEBUG_FORTH_WORDS 
a220					DMARK "UWs" 
a220 f5				push af  
a221 3a 35 a2			ld a, (.dmark)  
a224 32 7a ee			ld (debug_mark),a  
a227 3a 36 a2			ld a, (.dmark+1)  
a22a 32 7b ee			ld (debug_mark+1),a  
a22d 3a 37 a2			ld a, (.dmark+2)  
a230 32 7c ee			ld (debug_mark+2),a  
a233 18 03			jr .pastdmark  
a235 ..			.dmark: db "UWs"  
a238 f1			.pastdmark: pop af  
a239			endm  
# End of macro DMARK
a239					CALLMONITOR 
a239 cd 7b 91			call break_point_state  
a23c				endm  
# End of macro CALLMONITOR
a23c				endif 
a23c fe 00				cp WORD_SYS_END 
a23e 28 4d				jr z, .udone 
a240 fe 01				cp WORD_SYS_UWORD 
a242 20 44				jr nz, .nuword 
a244			 
a244				if DEBUG_FORTH_WORDS 
a244					DMARK "UWu" 
a244 f5				push af  
a245 3a 59 a2			ld a, (.dmark)  
a248 32 7a ee			ld (debug_mark),a  
a24b 3a 5a a2			ld a, (.dmark+1)  
a24e 32 7b ee			ld (debug_mark+1),a  
a251 3a 5b a2			ld a, (.dmark+2)  
a254 32 7c ee			ld (debug_mark+2),a  
a257 18 03			jr .pastdmark  
a259 ..			.dmark: db "UWu"  
a25c f1			.pastdmark: pop af  
a25d			endm  
# End of macro DMARK
a25d					CALLMONITOR 
a25d cd 7b 91			call break_point_state  
a260				endm  
# End of macro CALLMONITOR
a260				endif 
a260					; we have a uword so push its name to the stack 
a260			 
a260 e5				   	push hl  ; save so we can move to next dict block 
a261			 
a261					; skip opcode 
a261 23					inc hl  
a262					; skip next ptr 
a262 23					inc hl  
a263 23					inc hl 
a264					; skip len 
a264 23					inc hl 
a265				if DEBUG_FORTH_WORDS 
a265					DMARK "UWt" 
a265 f5				push af  
a266 3a 7a a2			ld a, (.dmark)  
a269 32 7a ee			ld (debug_mark),a  
a26c 3a 7b a2			ld a, (.dmark+1)  
a26f 32 7b ee			ld (debug_mark+1),a  
a272 3a 7c a2			ld a, (.dmark+2)  
a275 32 7c ee			ld (debug_mark+2),a  
a278 18 03			jr .pastdmark  
a27a ..			.dmark: db "UWt"  
a27d f1			.pastdmark: pop af  
a27e			endm  
# End of macro DMARK
a27e					CALLMONITOR 
a27e cd 7b 91			call break_point_state  
a281				endm  
# End of macro CALLMONITOR
a281				endif 
a281 03					inc bc 
a282			 
a282 c5					push bc 
a283 cd 1a 97				call forth_push_str 
a286 c1					pop bc 
a287			 
a287 e1					pop hl 	 
a288			 
a288 cd 4a 9a		.nuword:	call forth_tok_next 
a28b 18 92				jr .douscan  
a28d			 
a28d			.udone:		 ; push count of uwords found 
a28d c5					push bc 
a28e e1					pop hl 
a28f			 
a28f				if DEBUG_FORTH_WORDS 
a28f					DMARK "UWc" 
a28f f5				push af  
a290 3a a4 a2			ld a, (.dmark)  
a293 32 7a ee			ld (debug_mark),a  
a296 3a a5 a2			ld a, (.dmark+1)  
a299 32 7b ee			ld (debug_mark+1),a  
a29c 3a a6 a2			ld a, (.dmark+2)  
a29f 32 7c ee			ld (debug_mark+2),a  
a2a2 18 03			jr .pastdmark  
a2a4 ..			.dmark: db "UWc"  
a2a7 f1			.pastdmark: pop af  
a2a8			endm  
# End of macro DMARK
a2a8					CALLMONITOR 
a2a8 cd 7b 91			call break_point_state  
a2ab				endm  
# End of macro CALLMONITOR
a2ab				endif 
a2ab cd 08 97				call forth_push_numhl 
a2ae			 
a2ae			 
a2ae				       NEXTW 
a2ae c3 f9 98			jp macro_next 
a2b1				endm 
# End of macro NEXTW
a2b1			 
a2b1			.BP: 
a2b1				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a2b1 54				db WORD_SYS_CORE+64             
a2b2 e7 a2			dw .MONITOR            
a2b4 03				db 2 + 1 
a2b5 .. 00			db "BP",0              
a2b8				endm 
# End of macro CWHEAD
a2b8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a2b8			; | | $00 Will enable the break points within specific code paths 
a2b8			; | | $01 Will disable break points 
a2b8			; | |  
a2b8			; | | By default break points are off. Either the above can be used to enable them 
a2b8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a2b8			; | | and on release of the pressed key a message will be disaplayed to notify 
a2b8			; | | that break points are enabled. Pressing any key will then continue boot process. 
a2b8					; get byte count 
a2b8					if DEBUG_FORTH_WORDS_KEY 
a2b8						DMARK "BP." 
a2b8 f5				push af  
a2b9 3a cd a2			ld a, (.dmark)  
a2bc 32 7a ee			ld (debug_mark),a  
a2bf 3a ce a2			ld a, (.dmark+1)  
a2c2 32 7b ee			ld (debug_mark+1),a  
a2c5 3a cf a2			ld a, (.dmark+2)  
a2c8 32 7c ee			ld (debug_mark+2),a  
a2cb 18 03			jr .pastdmark  
a2cd ..			.dmark: db "BP."  
a2d0 f1			.pastdmark: pop af  
a2d1			endm  
# End of macro DMARK
a2d1						CALLMONITOR 
a2d1 cd 7b 91			call break_point_state  
a2d4				endm  
# End of macro CALLMONITOR
a2d4					endif 
a2d4			 
a2d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2d4 cd a3 97			call macro_dsp_valuehl 
a2d7				endm 
# End of macro FORTH_DSP_VALUEHL
a2d7			 
a2d7			;		push hl 
a2d7			 
a2d7					; destroy value TOS 
a2d7			 
a2d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2d7 cd 3f 98			call macro_forth_dsp_pop 
a2da				endm 
# End of macro FORTH_DSP_POP
a2da			 
a2da			;		pop hl 
a2da			 
a2da 3e 00				ld a,0 
a2dc bd					cp l 
a2dd 28 02				jr z, .bpset 
a2df 3e 2a				ld a, '*' 
a2e1			 
a2e1 32 74 e3		.bpset:		ld (os_view_disable), a 
a2e4			 
a2e4			 
a2e4					NEXTW 
a2e4 c3 f9 98			jp macro_next 
a2e7				endm 
# End of macro NEXTW
a2e7			 
a2e7			 
a2e7			.MONITOR: 
a2e7				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a2e7 55				db WORD_SYS_CORE+65             
a2e8 1a a3			dw .MALLOC            
a2ea 08				db 7 + 1 
a2eb .. 00			db "MONITOR",0              
a2f3				endm 
# End of macro CWHEAD
a2f3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a2f3			; | | At start the current various registers will be displayed with contents. 
a2f3			; | | Top right corner will show the most recent debug marker seen. 
a2f3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a2f3			; | | and the return stack pointer (RSP). 
a2f3			; | | Pressing: 
a2f3			; | |    1 - Initial screen 
a2f3			; | |    2 - Display a data dump of HL 
a2f3			; | |    3 - Display a data dump of DE 
a2f3			; | |    4 - Display a data dump of BC 
a2f3			; | |    5 - Display a data dump of HL 
a2f3			; | |    6 - Display a data dump of DSP 
a2f3			; | |    7 - Display a data dump of RSP 
a2f3			; | |    8 - Display a data dump of what is at DSP 
a2f3			; | |    9 - Display a data dump of what is at RSP 
a2f3			; | |    0 - Exit monitor and continue running. This will also enable break points 
a2f3			; | |    * - Disable break points 
a2f3			; | |    # - Enter traditional monitor mode 
a2f3			; | | 
a2f3			; | | Monitor Mode 
a2f3			; | | ------------ 
a2f3			; | | A prompt of '>' will be shown for various commands: 
a2f3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a2f3			; | |    C - Continue display a data dump from the last set address 
a2f3			; | |    M xxxx - Set start of memory edit at address xx 
a2f3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a2f3			; | |    Q - Return to previous 
a2f3					if DEBUG_FORTH_WORDS_KEY 
a2f3						DMARK "MON" 
a2f3 f5				push af  
a2f4 3a 08 a3			ld a, (.dmark)  
a2f7 32 7a ee			ld (debug_mark),a  
a2fa 3a 09 a3			ld a, (.dmark+1)  
a2fd 32 7b ee			ld (debug_mark+1),a  
a300 3a 0a a3			ld a, (.dmark+2)  
a303 32 7c ee			ld (debug_mark+2),a  
a306 18 03			jr .pastdmark  
a308 ..			.dmark: db "MON"  
a30b f1			.pastdmark: pop af  
a30c			endm  
# End of macro DMARK
a30c						CALLMONITOR 
a30c cd 7b 91			call break_point_state  
a30f				endm  
# End of macro CALLMONITOR
a30f					endif 
a30f 3e 00				ld a, 0 
a311 32 74 e3				ld (os_view_disable), a 
a314			 
a314					CALLMONITOR 
a314 cd 7b 91			call break_point_state  
a317				endm  
# End of macro CALLMONITOR
a317			 
a317			;	call monitor 
a317			 
a317					NEXTW 
a317 c3 f9 98			jp macro_next 
a31a				endm 
# End of macro NEXTW
a31a			 
a31a			 
a31a			.MALLOC: 
a31a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a31a 56				db WORD_SYS_CORE+66             
a31b 43 a3			dw .MALLOC2            
a31d 06				db 5 + 1 
a31e .. 00			db "ALLOT",0              
a324				endm 
# End of macro CWHEAD
a324			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a324					if DEBUG_FORTH_WORDS_KEY 
a324						DMARK "ALL" 
a324 f5				push af  
a325 3a 39 a3			ld a, (.dmark)  
a328 32 7a ee			ld (debug_mark),a  
a32b 3a 3a a3			ld a, (.dmark+1)  
a32e 32 7b ee			ld (debug_mark+1),a  
a331 3a 3b a3			ld a, (.dmark+2)  
a334 32 7c ee			ld (debug_mark+2),a  
a337 18 03			jr .pastdmark  
a339 ..			.dmark: db "ALL"  
a33c f1			.pastdmark: pop af  
a33d			endm  
# End of macro DMARK
a33d						CALLMONITOR 
a33d cd 7b 91			call break_point_state  
a340				endm  
# End of macro CALLMONITOR
a340					endif 
a340 c3 6a a3				jp .mallocc 
a343			.MALLOC2: 
a343				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a343 56				db WORD_SYS_CORE+66             
a344 81 a3			dw .FREE            
a346 07				db 6 + 1 
a347 .. 00			db "MALLOC",0              
a34e				endm 
# End of macro CWHEAD
a34e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a34e					; get byte count 
a34e					if DEBUG_FORTH_WORDS_KEY 
a34e						DMARK "MAL" 
a34e f5				push af  
a34f 3a 63 a3			ld a, (.dmark)  
a352 32 7a ee			ld (debug_mark),a  
a355 3a 64 a3			ld a, (.dmark+1)  
a358 32 7b ee			ld (debug_mark+1),a  
a35b 3a 65 a3			ld a, (.dmark+2)  
a35e 32 7c ee			ld (debug_mark+2),a  
a361 18 03			jr .pastdmark  
a363 ..			.dmark: db "MAL"  
a366 f1			.pastdmark: pop af  
a367			endm  
# End of macro DMARK
a367						CALLMONITOR 
a367 cd 7b 91			call break_point_state  
a36a				endm  
# End of macro CALLMONITOR
a36a					endif 
a36a			.mallocc: 
a36a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a36a cd a3 97			call macro_dsp_valuehl 
a36d				endm 
# End of macro FORTH_DSP_VALUEHL
a36d			 
a36d			;		push hl 
a36d			 
a36d					; destroy value TOS 
a36d			 
a36d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a36d cd 3f 98			call macro_forth_dsp_pop 
a370				endm 
# End of macro FORTH_DSP_POP
a370			 
a370			;		pop hl 
a370 cd 7e 8e				call malloc 
a373				if DEBUG_FORTH_MALLOC_GUARD 
a373 f5					push af 
a374 cd e0 89				call ishlzero 
a377			;		ld a, l 
a377			;		add h 
a377			;		cp 0 
a377 f1					pop af 
a378					 
a378 cc 5c c1				call z,malloc_error 
a37b				endif 
a37b			 
a37b cd 08 97				call forth_push_numhl 
a37e					NEXTW 
a37e c3 f9 98			jp macro_next 
a381				endm 
# End of macro NEXTW
a381			 
a381			.FREE: 
a381				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a381 57				db WORD_SYS_CORE+67             
a382 b2 a3			dw .LIST            
a384 05				db 4 + 1 
a385 .. 00			db "FREE",0              
a38a				endm 
# End of macro CWHEAD
a38a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a38a					if DEBUG_FORTH_WORDS_KEY 
a38a						DMARK "FRE" 
a38a f5				push af  
a38b 3a 9f a3			ld a, (.dmark)  
a38e 32 7a ee			ld (debug_mark),a  
a391 3a a0 a3			ld a, (.dmark+1)  
a394 32 7b ee			ld (debug_mark+1),a  
a397 3a a1 a3			ld a, (.dmark+2)  
a39a 32 7c ee			ld (debug_mark+2),a  
a39d 18 03			jr .pastdmark  
a39f ..			.dmark: db "FRE"  
a3a2 f1			.pastdmark: pop af  
a3a3			endm  
# End of macro DMARK
a3a3						CALLMONITOR 
a3a3 cd 7b 91			call break_point_state  
a3a6				endm  
# End of macro CALLMONITOR
a3a6					endif 
a3a6					; get address 
a3a6			 
a3a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3a6 cd a3 97			call macro_dsp_valuehl 
a3a9				endm 
# End of macro FORTH_DSP_VALUEHL
a3a9			 
a3a9			;		push hl 
a3a9			 
a3a9					; destroy value TOS 
a3a9			 
a3a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3a9 cd 3f 98			call macro_forth_dsp_pop 
a3ac				endm 
# End of macro FORTH_DSP_POP
a3ac			 
a3ac			;		pop hl 
a3ac			if FORTH_ENABLE_MALLOCFREE 
a3ac cd 48 8f				call free 
a3af			endif 
a3af					NEXTW 
a3af c3 f9 98			jp macro_next 
a3b2				endm 
# End of macro NEXTW
a3b2			.LIST: 
a3b2				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a3b2 5c				db WORD_SYS_CORE+72             
a3b3 75 a5			dw .FORGET            
a3b5 05				db 4 + 1 
a3b6 .. 00			db "LIST",0              
a3bb				endm 
# End of macro CWHEAD
a3bb			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a3bb			; | | The quoted word must be in upper case. 
a3bb				if DEBUG_FORTH_WORDS_KEY 
a3bb					DMARK "LST" 
a3bb f5				push af  
a3bc 3a d0 a3			ld a, (.dmark)  
a3bf 32 7a ee			ld (debug_mark),a  
a3c2 3a d1 a3			ld a, (.dmark+1)  
a3c5 32 7b ee			ld (debug_mark+1),a  
a3c8 3a d2 a3			ld a, (.dmark+2)  
a3cb 32 7c ee			ld (debug_mark+2),a  
a3ce 18 03			jr .pastdmark  
a3d0 ..			.dmark: db "LST"  
a3d3 f1			.pastdmark: pop af  
a3d4			endm  
# End of macro DMARK
a3d4					CALLMONITOR 
a3d4 cd 7b 91			call break_point_state  
a3d7				endm  
# End of macro CALLMONITOR
a3d7				endif 
a3d7			 
a3d7					FORTH_DSP_VALUEHL 
a3d7 cd a3 97			call macro_dsp_valuehl 
a3da				endm 
# End of macro FORTH_DSP_VALUEHL
a3da			 
a3da e5					push hl 
a3db c1					pop bc 
a3dc			 
a3dc			; Start format of scratch string 
a3dc			 
a3dc 21 75 e3				ld hl, scratch 
a3df			 
a3df 3e 3a				ld a, ':' 
a3e1 77					ld (hl),a 
a3e2 23					inc hl 
a3e3 3e 20				ld a, ' ' 
a3e5 77					ld (hl), a 
a3e6			 
a3e6					; Get ptr to the word we need to look up 
a3e6			 
a3e6			;		FORTH_DSP_VALUEHL 
a3e6					;v5 FORTH_DSP_VALUE 
a3e6				; TODO type check 
a3e6			;		inc hl    ; Skip type check  
a3e6			;		push hl 
a3e6			;		ex de, hl    ; put into DE 
a3e6			 
a3e6			 
a3e6 21 a7 d4				ld hl, baseram 
a3e9					;ld hl, baseusermem 
a3e9			 
a3e9 e5			push hl   ; sacreifical push 
a3ea			 
a3ea			.ldouscanm: 
a3ea e1				pop hl 
a3eb			.ldouscan: 
a3eb				if DEBUG_FORTH_WORDS 
a3eb					DMARK "LSs" 
a3eb f5				push af  
a3ec 3a 00 a4			ld a, (.dmark)  
a3ef 32 7a ee			ld (debug_mark),a  
a3f2 3a 01 a4			ld a, (.dmark+1)  
a3f5 32 7b ee			ld (debug_mark+1),a  
a3f8 3a 02 a4			ld a, (.dmark+2)  
a3fb 32 7c ee			ld (debug_mark+2),a  
a3fe 18 03			jr .pastdmark  
a400 ..			.dmark: db "LSs"  
a403 f1			.pastdmark: pop af  
a404			endm  
# End of macro DMARK
a404					CALLMONITOR 
a404 cd 7b 91			call break_point_state  
a407				endm  
# End of macro CALLMONITOR
a407				endif 
a407				; skip dict stub 
a407 cd 4a 9a				call forth_tok_next 
a40a			 
a40a			 
a40a			; while we have words to look for 
a40a			 
a40a 7e				ld a, (hl)      
a40b				if DEBUG_FORTH_WORDS 
a40b					DMARK "LSk" 
a40b f5				push af  
a40c 3a 20 a4			ld a, (.dmark)  
a40f 32 7a ee			ld (debug_mark),a  
a412 3a 21 a4			ld a, (.dmark+1)  
a415 32 7b ee			ld (debug_mark+1),a  
a418 3a 22 a4			ld a, (.dmark+2)  
a41b 32 7c ee			ld (debug_mark+2),a  
a41e 18 03			jr .pastdmark  
a420 ..			.dmark: db "LSk"  
a423 f1			.pastdmark: pop af  
a424			endm  
# End of macro DMARK
a424					CALLMONITOR 
a424 cd 7b 91			call break_point_state  
a427				endm  
# End of macro CALLMONITOR
a427				endif 
a427 fe 00				cp WORD_SYS_END 
a429 ca 5c a5				jp z, .lunotfound 
a42c fe 01				cp WORD_SYS_UWORD 
a42e c2 eb a3				jp nz, .ldouscan 
a431			 
a431				if DEBUG_FORTH_WORDS 
a431					DMARK "LSu" 
a431 f5				push af  
a432 3a 46 a4			ld a, (.dmark)  
a435 32 7a ee			ld (debug_mark),a  
a438 3a 47 a4			ld a, (.dmark+1)  
a43b 32 7b ee			ld (debug_mark+1),a  
a43e 3a 48 a4			ld a, (.dmark+2)  
a441 32 7c ee			ld (debug_mark+2),a  
a444 18 03			jr .pastdmark  
a446 ..			.dmark: db "LSu"  
a449 f1			.pastdmark: pop af  
a44a			endm  
# End of macro DMARK
a44a					CALLMONITOR 
a44a cd 7b 91			call break_point_state  
a44d				endm  
# End of macro CALLMONITOR
a44d				endif 
a44d			 
a44d					; found a uword but is it the one we want... 
a44d			 
a44d c5					push bc     ; uword to find is on bc 
a44e d1					pop de 
a44f			 
a44f e5					push hl  ; to save the ptr 
a450			 
a450					; skip opcode 
a450 23					inc hl  
a451					; skip next ptr 
a451 23					inc hl  
a452 23					inc hl 
a453					; skip len 
a453 23					inc hl 
a454			 
a454				if DEBUG_FORTH_WORDS 
a454					DMARK "LSc" 
a454 f5				push af  
a455 3a 69 a4			ld a, (.dmark)  
a458 32 7a ee			ld (debug_mark),a  
a45b 3a 6a a4			ld a, (.dmark+1)  
a45e 32 7b ee			ld (debug_mark+1),a  
a461 3a 6b a4			ld a, (.dmark+2)  
a464 32 7c ee			ld (debug_mark+2),a  
a467 18 03			jr .pastdmark  
a469 ..			.dmark: db "LSc"  
a46c f1			.pastdmark: pop af  
a46d			endm  
# End of macro DMARK
a46d					CALLMONITOR 
a46d cd 7b 91			call break_point_state  
a470				endm  
# End of macro CALLMONITOR
a470				endif 
a470 cd 4d 8e				call strcmp 
a473 c2 ea a3				jp nz, .ldouscanm 
a476				 
a476			 
a476			 
a476					; we have a uword so push its name to the stack 
a476			 
a476			;	   	push hl  ; save so we can move to next dict block 
a476 e1			pop hl 
a477			 
a477				if DEBUG_FORTH_WORDS 
a477					DMARK "LSm" 
a477 f5				push af  
a478 3a 8c a4			ld a, (.dmark)  
a47b 32 7a ee			ld (debug_mark),a  
a47e 3a 8d a4			ld a, (.dmark+1)  
a481 32 7b ee			ld (debug_mark+1),a  
a484 3a 8e a4			ld a, (.dmark+2)  
a487 32 7c ee			ld (debug_mark+2),a  
a48a 18 03			jr .pastdmark  
a48c ..			.dmark: db "LSm"  
a48f f1			.pastdmark: pop af  
a490			endm  
# End of macro DMARK
a490					CALLMONITOR 
a490 cd 7b 91			call break_point_state  
a493				endm  
# End of macro CALLMONITOR
a493				endif 
a493			 
a493					; skip opcode 
a493 23					inc hl  
a494					; skip next ptr 
a494 23					inc hl  
a495 23					inc hl 
a496					; skip len 
a496 7e					ld a, (hl)   ; save length to add 
a497				if DEBUG_FORTH_WORDS 
a497					DMARK "LS2" 
a497 f5				push af  
a498 3a ac a4			ld a, (.dmark)  
a49b 32 7a ee			ld (debug_mark),a  
a49e 3a ad a4			ld a, (.dmark+1)  
a4a1 32 7b ee			ld (debug_mark+1),a  
a4a4 3a ae a4			ld a, (.dmark+2)  
a4a7 32 7c ee			ld (debug_mark+2),a  
a4aa 18 03			jr .pastdmark  
a4ac ..			.dmark: db "LS2"  
a4af f1			.pastdmark: pop af  
a4b0			endm  
# End of macro DMARK
a4b0					CALLMONITOR 
a4b0 cd 7b 91			call break_point_state  
a4b3				endm  
# End of macro CALLMONITOR
a4b3				endif 
a4b3			 
a4b3					; save this location 
a4b3				 
a4b3 e5					push hl 
a4b4			 
a4b4 23					inc hl 
a4b5 11 77 e3				ld de, scratch+2 
a4b8 4f					ld c, a 
a4b9 06 00				ld b, 0 
a4bb			 
a4bb				if DEBUG_FORTH_WORDS 
a4bb					DMARK "LSn" 
a4bb f5				push af  
a4bc 3a d0 a4			ld a, (.dmark)  
a4bf 32 7a ee			ld (debug_mark),a  
a4c2 3a d1 a4			ld a, (.dmark+1)  
a4c5 32 7b ee			ld (debug_mark+1),a  
a4c8 3a d2 a4			ld a, (.dmark+2)  
a4cb 32 7c ee			ld (debug_mark+2),a  
a4ce 18 03			jr .pastdmark  
a4d0 ..			.dmark: db "LSn"  
a4d3 f1			.pastdmark: pop af  
a4d4			endm  
# End of macro DMARK
a4d4					CALLMONITOR 
a4d4 cd 7b 91			call break_point_state  
a4d7				endm  
# End of macro CALLMONITOR
a4d7				endif 
a4d7			 
a4d7					; copy uword name to scratch 
a4d7			 
a4d7 ed b0				ldir 
a4d9			 
a4d9 1b					dec de 
a4da 3e 20				ld a, ' '    ; change null to space 
a4dc 12					ld (de), a 
a4dd			 
a4dd 13					inc de 
a4de			 
a4de d5					push de 
a4df c1					pop bc     ; move scratch pointer to end of word name and save it 
a4e0			 
a4e0 e1					pop hl 
a4e1 7e					ld a, (hl) 
a4e2					;inc hl 
a4e2					; skip word string 
a4e2 cd b7 89				call addatohl 
a4e5			 
a4e5 23					inc hl 
a4e6			 
a4e6				if DEBUG_FORTH_WORDS 
a4e6					DMARK "LS3" 
a4e6 f5				push af  
a4e7 3a fb a4			ld a, (.dmark)  
a4ea 32 7a ee			ld (debug_mark),a  
a4ed 3a fc a4			ld a, (.dmark+1)  
a4f0 32 7b ee			ld (debug_mark+1),a  
a4f3 3a fd a4			ld a, (.dmark+2)  
a4f6 32 7c ee			ld (debug_mark+2),a  
a4f9 18 03			jr .pastdmark  
a4fb ..			.dmark: db "LS3"  
a4fe f1			.pastdmark: pop af  
a4ff			endm  
# End of macro DMARK
a4ff					CALLMONITOR 
a4ff cd 7b 91			call break_point_state  
a502				endm  
# End of macro CALLMONITOR
a502				endif 
a502					; should now be at the start of the machine code to setup the eval of the uword 
a502					; now locate the ptr to the string defintion 
a502			 
a502					; skip ld hl, 
a502					; then load the ptr 
a502			 
a502 23					inc hl 
a503 5e					ld e, (hl) 
a504 23					inc hl 
a505 56					ld d, (hl) 
a506 eb					ex de, hl 
a507			 
a507			 
a507				if DEBUG_FORTH_WORDS 
a507					DMARK "LSt" 
a507 f5				push af  
a508 3a 1c a5			ld a, (.dmark)  
a50b 32 7a ee			ld (debug_mark),a  
a50e 3a 1d a5			ld a, (.dmark+1)  
a511 32 7b ee			ld (debug_mark+1),a  
a514 3a 1e a5			ld a, (.dmark+2)  
a517 32 7c ee			ld (debug_mark+2),a  
a51a 18 03			jr .pastdmark  
a51c ..			.dmark: db "LSt"  
a51f f1			.pastdmark: pop af  
a520			endm  
# End of macro DMARK
a520					CALLMONITOR 
a520 cd 7b 91			call break_point_state  
a523				endm  
# End of macro CALLMONITOR
a523				endif 
a523			 
a523			; cant push right now due to tokenised strings  
a523			 
a523			; get the destination of where to copy this definition to. 
a523			 
a523 c5					push bc 
a524 d1					pop de 
a525			 
a525 7e			.listl:         ld a,(hl) 
a526 fe 00				cp 0 
a528 28 09				jr z, .lreplsp     ; replace zero with space 
a52a fe 7f				cp FORTH_END_BUFFER 
a52c 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a52e				 
a52e					; just copy this char as is then 
a52e			 
a52e 12					ld (de), a 
a52f			 
a52f 23			.listnxt:	inc hl 
a530 13					inc de 
a531 18 f2				jr .listl 
a533			 
a533 3e 20		.lreplsp:	ld a,' ' 
a535 12					ld (de), a 
a536 18 f7				jr .listnxt 
a538			 
a538			; close up uword def 
a538			 
a538			.listdone: 
a538 3e 00				ld a, 0 
a53a 12					ld (de), a 
a53b			 
a53b			; now have def so clean up and push to stack 
a53b			 
a53b 21 75 e3				ld hl, scratch 
a53e				if DEBUG_FORTH_WORDS 
a53e					DMARK "Ltp" 
a53e f5				push af  
a53f 3a 53 a5			ld a, (.dmark)  
a542 32 7a ee			ld (debug_mark),a  
a545 3a 54 a5			ld a, (.dmark+1)  
a548 32 7b ee			ld (debug_mark+1),a  
a54b 3a 55 a5			ld a, (.dmark+2)  
a54e 32 7c ee			ld (debug_mark+2),a  
a551 18 03			jr .pastdmark  
a553 ..			.dmark: db "Ltp"  
a556 f1			.pastdmark: pop af  
a557			endm  
# End of macro DMARK
a557					CALLMONITOR 
a557 cd 7b 91			call break_point_state  
a55a				endm  
# End of macro CALLMONITOR
a55a				endif 
a55a			 
a55a 18 06			jr .listpush 
a55c			 
a55c			;.lnuword:	pop hl 
a55c			;		call forth_tok_next 
a55c			;		jp .ldouscan  
a55c			 
a55c			.lunotfound:		  
a55c			 
a55c			 
a55c					 
a55c					FORTH_DSP_POP 
a55c cd 3f 98			call macro_forth_dsp_pop 
a55f				endm 
# End of macro FORTH_DSP_POP
a55f 21 68 a5				ld hl, .luno 
a562						 
a562			 
a562			.listpush: 
a562 cd 1a 97				call forth_push_str 
a565			 
a565			 
a565			 
a565					NEXTW 
a565 c3 f9 98			jp macro_next 
a568				endm 
# End of macro NEXTW
a568			 
a568 .. 00		.luno:    db "Not found",0 
a572			 
a572			 
a572			 
a572			 
a572			 
a572			;		push hl   ; save pointer to start of uword def string 
a572			; 
a572			;; look for FORTH_EOL_LINE 
a572			;		ld a, FORTH_END_BUFFER 
a572			;		call strlent 
a572			; 
a572			;		inc hl		 ; space for coln def 
a572			;		inc hl 
a572			;		inc hl          ; space for terms 
a572			;		inc hl 
a572			; 
a572			;		ld a, 20   ; TODO get actual length 
a572			;		call addatohl    ; include a random amount of room for the uword name 
a572			; 
a572			;		 
a572			;	if DEBUG_FORTH_WORDS 
a572			;		DMARK "Lt1" 
a572			;		CALLMONITOR 
a572			;	endif 
a572			;		 
a572			; 
a572			;; malloc space for the string because we cant change it 
a572			; 
a572			;		call malloc 
a572			;	if DEBUG_FORTH_MALLOC_GUARD 
a572			;		push af 
a572			;		call ishlzero 
a572			;		pop af 
a572			;		 
a572			;		call z,malloc_error 
a572			;	endif 
a572			; 
a572			;	if DEBUG_FORTH_WORDS 
a572			;		DMARK "Lt2" 
a572			;		CALLMONITOR 
a572			;	endif 
a572			;		pop de 
a572			;		push hl    ; push the malloc to release later 
a572			;		push hl   ;  push back a copy for the later stack push 
a572			;		 
a572			;; copy the string swapping out the zero terms for spaces 
a572			; 
a572			;		; de has our source 
a572			;		; hl has our dest 
a572			; 
a572			;; add the coln def 
a572			; 
a572			;		ld a, ':' 
a572			;		ld (hl), a 
a572			;		inc hl 
a572			;		ld a, ' ' 
a572			;		ld (hl), a 
a572			;		inc hl 
a572			; 
a572			;; add the uname word 
a572			;		push de   ; save our string for now 
a572			;		ex de, hl 
a572			; 
a572			;		FORTH_DSP_VALUE 
a572			;		;v5 FORTH_DSP_VALUE 
a572			; 
a572			;		inc hl   ; skip type but we know by now this is OK 
a572			; 
a572			;.luword:	ld a,(hl) 
a572			;		cp 0 
a572			;		jr z, .luword2 
a572			;		ld (de), a 
a572			;		inc de 
a572			;		inc hl 
a572			;		jr .luword 
a572			; 
a572			;.luword2:	ld a, ' ' 
a572			;		ld (de), a 
a572			;;		inc hl 
a572			;;		inc de 
a572			;;		ld (de), a 
a572			;;		inc hl 
a572			;		inc de 
a572			; 
a572			;		ex de, hl 
a572			;		pop de 
a572			;		 
a572			;		 
a572			; 
a572			;; detoken that string and copy it 
a572			; 
a572			;	if DEBUG_FORTH_WORDS 
a572			;		DMARK "Lt2" 
a572			;		CALLMONITOR 
a572			;	endif 
a572			;.ldetok:	ld a, (de) 
a572			;		cp FORTH_END_BUFFER 
a572			;		jr z, .ldetokend 
a572			;		; swap out any zero term for space 
a572			;		cp 0 
a572			;		jr nz, .ldetoknext 
a572			;		ld a, ' ' 
a572			; 
a572			;	if DEBUG_FORTH_WORDS 
a572			;		DMARK "LtS" 
a572			;		CALLMONITOR 
a572			;	endif 
a572			;.ldetoknext:	ld (hl), a 
a572			;		inc de 
a572			;		inc hl 
a572			;		jr .ldetok 
a572			; 
a572			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a572			;		ld (hl), a  
a572			; 
a572			;; free that temp malloc 
a572			; 
a572			;		pop hl    
a572			; 
a572			;	if DEBUG_FORTH_WORDS 
a572			;		DMARK "Lt4" 
a572			;		CALLMONITOR 
a572			;	endif 
a572			;		call forth_apushstrhl 
a572			; 
a572			;		; get rid of temp malloc area 
a572			; 
a572			;		pop hl 
a572			;		call free 
a572			; 
a572			;		jr .ludone 
a572			; 
a572			;.lnuword:	pop hl 
a572			;		call forth_tok_next 
a572			;		jp .ldouscan  
a572			; 
a572			;.ludone:		 pop hl 
a572			; 
a572					NEXTW 
a572 c3 f9 98			jp macro_next 
a575				endm 
# End of macro NEXTW
a575			 
a575			.FORGET: 
a575				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a575 5d				db WORD_SYS_CORE+73             
a576 ee a5			dw .NOP            
a578 07				db 6 + 1 
a579 .. 00			db "FORGET",0              
a580				endm 
# End of macro CWHEAD
a580			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a580			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a580			; | |  
a580			; | | e.g. "MORE" forget 
a580					if DEBUG_FORTH_WORDS_KEY 
a580						DMARK "FRG" 
a580 f5				push af  
a581 3a 95 a5			ld a, (.dmark)  
a584 32 7a ee			ld (debug_mark),a  
a587 3a 96 a5			ld a, (.dmark+1)  
a58a 32 7b ee			ld (debug_mark+1),a  
a58d 3a 97 a5			ld a, (.dmark+2)  
a590 32 7c ee			ld (debug_mark+2),a  
a593 18 03			jr .pastdmark  
a595 ..			.dmark: db "FRG"  
a598 f1			.pastdmark: pop af  
a599			endm  
# End of macro DMARK
a599						CALLMONITOR 
a599 cd 7b 91			call break_point_state  
a59c				endm  
# End of macro CALLMONITOR
a59c					endif 
a59c			 
a59c				; find uword 
a59c			        ; update start of word with "_" 
a59c				; replace uword with deleted flag 
a59c			 
a59c			 
a59c			;	if DEBUG_FORTH_WORDS 
a59c			;		DMARK "FOG" 
a59c			;		CALLMONITOR 
a59c			;	endif 
a59c			 
a59c			 
a59c					; Get ptr to the word we need to look up 
a59c			 
a59c					FORTH_DSP_VALUEHL 
a59c cd a3 97			call macro_dsp_valuehl 
a59f				endm 
# End of macro FORTH_DSP_VALUEHL
a59f					;v5 FORTH_DSP_VALUE 
a59f				; TODO type check 
a59f			;		inc hl    ; Skip type check  
a59f e5					push hl 
a5a0 c1					pop bc 
a5a1			;		ex de, hl    ; put into DE 
a5a1			 
a5a1			 
a5a1 21 a7 d4				ld hl, baseram 
a5a4					;ld hl, baseusermem 
a5a4			 
a5a4				; skip dict stub 
a5a4			;	call forth_tok_next 
a5a4 e5			push hl   ; sacreifical push 
a5a5			 
a5a5			.fldouscanm: 
a5a5 e1				pop hl 
a5a6			.fldouscan: 
a5a6			;	if DEBUG_FORTH_WORDS 
a5a6			;		DMARK "LSs" 
a5a6			;		CALLMONITOR 
a5a6			;	endif 
a5a6				; skip dict stub 
a5a6 cd 4a 9a				call forth_tok_next 
a5a9			 
a5a9			 
a5a9			; while we have words to look for 
a5a9			 
a5a9 7e				ld a, (hl)      
a5aa			;	if DEBUG_FORTH_WORDS 
a5aa			;		DMARK "LSk" 
a5aa			;		CALLMONITOR 
a5aa			;	endif 
a5aa fe 00				cp WORD_SYS_END 
a5ac ca e8 a5				jp z, .flunotfound 
a5af fe 01				cp WORD_SYS_UWORD 
a5b1 c2 a6 a5				jp nz, .fldouscan 
a5b4			 
a5b4			;	if DEBUG_FORTH_WORDS 
a5b4			;		DMARK "LSu" 
a5b4			;		CALLMONITOR 
a5b4			;	endif 
a5b4			 
a5b4					; found a uword but is it the one we want... 
a5b4			 
a5b4 c5					push bc     ; uword to find is on bc 
a5b5 d1					pop de 
a5b6			 
a5b6 e5					push hl  ; to save the ptr 
a5b7			 
a5b7					; skip opcode 
a5b7 23					inc hl  
a5b8					; skip next ptr 
a5b8 23					inc hl  
a5b9 23					inc hl 
a5ba					; skip len 
a5ba 23					inc hl 
a5bb			 
a5bb			;	if DEBUG_FORTH_WORDS 
a5bb			;		DMARK "LSc" 
a5bb			;		CALLMONITOR 
a5bb			;	endif 
a5bb cd 4d 8e				call strcmp 
a5be c2 a5 a5				jp nz, .fldouscanm 
a5c1			; 
a5c1			; 
a5c1			;; while we have words to look for 
a5c1			; 
a5c1			;.fdouscan:	ld a, (hl)      
a5c1			;	if DEBUG_FORTH_WORDS 
a5c1			;		DMARK "LSs" 
a5c1			;		CALLMONITOR 
a5c1			;	endif 
a5c1			;		cp WORD_SYS_END 
a5c1			;		jp z, .fudone 
a5c1			;		cp WORD_SYS_UWORD 
a5c1			;		jp nz, .fnuword 
a5c1			; 
a5c1			;	if DEBUG_FORTH_WORDS 
a5c1			;		DMARK "FGu" 
a5c1			;		CALLMONITOR 
a5c1			;	endif 
a5c1			; 
a5c1			;		; found a uword but is it the one we want... 
a5c1			; 
a5c1			; 
a5c1			;	        pop de   ; get back the dsp name 
a5c1			;		push de 
a5c1			; 
a5c1			;		push hl  ; to save the ptr 
a5c1			; 
a5c1			;		; skip opcode 
a5c1			;		inc hl  
a5c1			;		; skip next ptr 
a5c1			;		inc hl  
a5c1			;		inc hl 
a5c1			;		; skip len 
a5c1			;		inc hl 
a5c1			; 
a5c1			;	if DEBUG_FORTH_WORDS 
a5c1			;		DMARK "FGc" 
a5c1			;		CALLMONITOR 
a5c1			;	endif 
a5c1			;		call strcmp 
a5c1			;		jp nz, .fnuword 
a5c1			 
a5c1			 
a5c1 e1			pop hl 
a5c2			 
a5c2				 
a5c2				if DEBUG_FORTH_WORDS 
a5c2					DMARK "FGm" 
a5c2 f5				push af  
a5c3 3a d7 a5			ld a, (.dmark)  
a5c6 32 7a ee			ld (debug_mark),a  
a5c9 3a d8 a5			ld a, (.dmark+1)  
a5cc 32 7b ee			ld (debug_mark+1),a  
a5cf 3a d9 a5			ld a, (.dmark+2)  
a5d2 32 7c ee			ld (debug_mark+2),a  
a5d5 18 03			jr .pastdmark  
a5d7 ..			.dmark: db "FGm"  
a5da f1			.pastdmark: pop af  
a5db			endm  
# End of macro DMARK
a5db					CALLMONITOR 
a5db cd 7b 91			call break_point_state  
a5de				endm  
# End of macro CALLMONITOR
a5de				endif 
a5de			 
a5de			 
a5de			 
a5de					; we have a uword so push its name to the stack 
a5de			 
a5de			;	   	push hl  ; save so we can move to next dict block 
a5de			;pop hl 
a5de			 
a5de					; update opcode to deleted 
a5de 3e 03				ld a, WORD_SYS_DELETED 
a5e0 77					ld (hl), a 
a5e1			 
a5e1 23					inc hl  
a5e2					; skip next ptr 
a5e2 23					inc hl  
a5e3 23					inc hl 
a5e4					; skip len 
a5e4 23					inc hl 
a5e5			 
a5e5					; TODO change parser to skip deleted words but for now mark it out 
a5e5 3e 5f				ld a, "_" 
a5e7 77					ld  (hl),a 
a5e8			 
a5e8			;		jr .fudone 
a5e8			; 
a5e8			;.fnuword:	pop hl 
a5e8			;		call forth_tok_next 
a5e8			;		jp .fdouscan  
a5e8			 
a5e8			.flunotfound:		  
a5e8			 
a5e8			 
a5e8					 
a5e8					FORTH_DSP_POP 
a5e8 cd 3f 98			call macro_forth_dsp_pop 
a5eb				endm 
# End of macro FORTH_DSP_POP
a5eb			;		ld hl, .luno 
a5eb			;.fudone:		 pop hl 
a5eb					NEXTW 
a5eb c3 f9 98			jp macro_next 
a5ee				endm 
# End of macro NEXTW
a5ee			.NOP: 
a5ee				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a5ee 61				db WORD_SYS_CORE+77             
a5ef 15 a6			dw .COMO            
a5f1 04				db 3 + 1 
a5f2 .. 00			db "NOP",0              
a5f6				endm 
# End of macro CWHEAD
a5f6			; | NOP (  --  ) Do nothing | DONE 
a5f6					if DEBUG_FORTH_WORDS_KEY 
a5f6						DMARK "NOP" 
a5f6 f5				push af  
a5f7 3a 0b a6			ld a, (.dmark)  
a5fa 32 7a ee			ld (debug_mark),a  
a5fd 3a 0c a6			ld a, (.dmark+1)  
a600 32 7b ee			ld (debug_mark+1),a  
a603 3a 0d a6			ld a, (.dmark+2)  
a606 32 7c ee			ld (debug_mark+2),a  
a609 18 03			jr .pastdmark  
a60b ..			.dmark: db "NOP"  
a60e f1			.pastdmark: pop af  
a60f			endm  
# End of macro DMARK
a60f						CALLMONITOR 
a60f cd 7b 91			call break_point_state  
a612				endm  
# End of macro CALLMONITOR
a612					endif 
a612				       NEXTW 
a612 c3 f9 98			jp macro_next 
a615				endm 
# End of macro NEXTW
a615			.COMO: 
a615				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a615 6e				db WORD_SYS_CORE+90             
a616 67 a6			dw .COMC            
a618 02				db 1 + 1 
a619 .. 00			db "(",0              
a61b				endm 
# End of macro CWHEAD
a61b			; | ( ( -- )  Start of comment | DONE 
a61b			 
a61b			 
a61b 2a 76 e6				ld hl, ( os_tok_ptr) 
a61e 11 62 a6			ld de, .closepar 
a621					 
a621					if DEBUG_FORTH_WORDS 
a621						DMARK ").." 
a621 f5				push af  
a622 3a 36 a6			ld a, (.dmark)  
a625 32 7a ee			ld (debug_mark),a  
a628 3a 37 a6			ld a, (.dmark+1)  
a62b 32 7b ee			ld (debug_mark+1),a  
a62e 3a 38 a6			ld a, (.dmark+2)  
a631 32 7c ee			ld (debug_mark+2),a  
a634 18 03			jr .pastdmark  
a636 ..			.dmark: db ").."  
a639 f1			.pastdmark: pop af  
a63a			endm  
# End of macro DMARK
a63a						CALLMONITOR 
a63a cd 7b 91			call break_point_state  
a63d				endm  
# End of macro CALLMONITOR
a63d					endif 
a63d cd 14 9a			call findnexttok  
a640			 
a640					if DEBUG_FORTH_WORDS 
a640						DMARK "IF5" 
a640 f5				push af  
a641 3a 55 a6			ld a, (.dmark)  
a644 32 7a ee			ld (debug_mark),a  
a647 3a 56 a6			ld a, (.dmark+1)  
a64a 32 7b ee			ld (debug_mark+1),a  
a64d 3a 57 a6			ld a, (.dmark+2)  
a650 32 7c ee			ld (debug_mark+2),a  
a653 18 03			jr .pastdmark  
a655 ..			.dmark: db "IF5"  
a658 f1			.pastdmark: pop af  
a659			endm  
# End of macro DMARK
a659						CALLMONITOR 
a659 cd 7b 91			call break_point_state  
a65c				endm  
# End of macro CALLMONITOR
a65c					endif 
a65c				; replace below with ) exec using tok_ptr 
a65c 22 76 e6			ld (os_tok_ptr), hl 
a65f c3 8a 99			jp exec1 
a662			 
a662 .. 00			.closepar:   db ")",0 
a664			 
a664				       NEXTW 
a664 c3 f9 98			jp macro_next 
a667				endm 
# End of macro NEXTW
a667			.COMC: 
a667				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a667 6f				db WORD_SYS_CORE+91             
a668 70 a6			dw .SCRATCH            
a66a 02				db 1 + 1 
a66b .. 00			db ")",0              
a66d				endm 
# End of macro CWHEAD
a66d			; | ) ( -- )  End of comment |  DONE  
a66d				       NEXTW 
a66d c3 f9 98			jp macro_next 
a670				endm 
# End of macro NEXTW
a670			 
a670			.SCRATCH: 
a670				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a670 6f				db WORD_SYS_CORE+91             
a671 ab a6			dw .INC            
a673 08				db 7 + 1 
a674 .. 00			db "SCRATCH",0              
a67c				endm 
# End of macro CWHEAD
a67c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a67c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a67c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a67c			; | |  
a67c			; | | e.g.    : score $00 scratch ; 
a67c			; | |  
a67c			; | | $00 score ! 
a67c			; | | $01 score +! 
a67c			; | |  
a67c			; | | e.g.   : varword $0a scratch ;  
a67c			; | | 
a67c			; | | $8000 varword ! 
a67c					if DEBUG_FORTH_WORDS_KEY 
a67c						DMARK "SCR" 
a67c f5				push af  
a67d 3a 91 a6			ld a, (.dmark)  
a680 32 7a ee			ld (debug_mark),a  
a683 3a 92 a6			ld a, (.dmark+1)  
a686 32 7b ee			ld (debug_mark+1),a  
a689 3a 93 a6			ld a, (.dmark+2)  
a68c 32 7c ee			ld (debug_mark+2),a  
a68f 18 03			jr .pastdmark  
a691 ..			.dmark: db "SCR"  
a694 f1			.pastdmark: pop af  
a695			endm  
# End of macro DMARK
a695						CALLMONITOR 
a695 cd 7b 91			call break_point_state  
a698				endm  
# End of macro CALLMONITOR
a698					endif 
a698			 
a698					FORTH_DSP_VALUEHL 
a698 cd a3 97			call macro_dsp_valuehl 
a69b				endm 
# End of macro FORTH_DSP_VALUEHL
a69b				 
a69b					FORTH_DSP_POP 
a69b cd 3f 98			call macro_forth_dsp_pop 
a69e				endm 
# End of macro FORTH_DSP_POP
a69e			 
a69e 7d					ld a, l 
a69f 21 9a e8				ld hl, os_var_array 
a6a2 cd b7 89				call addatohl 
a6a5			 
a6a5 cd 08 97				call forth_push_numhl 
a6a8			 
a6a8				       NEXTW 
a6a8 c3 f9 98			jp macro_next 
a6ab				endm 
# End of macro NEXTW
a6ab			 
a6ab			.INC: 
a6ab				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a6ab 6f				db WORD_SYS_CORE+91             
a6ac ff a6			dw .DEC            
a6ae 03				db 2 + 1 
a6af .. 00			db "+!",0              
a6b2				endm 
# End of macro CWHEAD
a6b2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a6b2					if DEBUG_FORTH_WORDS_KEY 
a6b2						DMARK "+s_" 
a6b2 f5				push af  
a6b3 3a c7 a6			ld a, (.dmark)  
a6b6 32 7a ee			ld (debug_mark),a  
a6b9 3a c8 a6			ld a, (.dmark+1)  
a6bc 32 7b ee			ld (debug_mark+1),a  
a6bf 3a c9 a6			ld a, (.dmark+2)  
a6c2 32 7c ee			ld (debug_mark+2),a  
a6c5 18 03			jr .pastdmark  
a6c7 ..			.dmark: db "+s_"  
a6ca f1			.pastdmark: pop af  
a6cb			endm  
# End of macro DMARK
a6cb						CALLMONITOR 
a6cb cd 7b 91			call break_point_state  
a6ce				endm  
# End of macro CALLMONITOR
a6ce					endif 
a6ce			 
a6ce					FORTH_DSP_VALUEHL 
a6ce cd a3 97			call macro_dsp_valuehl 
a6d1				endm 
# End of macro FORTH_DSP_VALUEHL
a6d1			 
a6d1 e5					push hl   ; save address 
a6d2			 
a6d2					FORTH_DSP_POP 
a6d2 cd 3f 98			call macro_forth_dsp_pop 
a6d5				endm 
# End of macro FORTH_DSP_POP
a6d5			 
a6d5					FORTH_DSP_VALUEHL 
a6d5 cd a3 97			call macro_dsp_valuehl 
a6d8				endm 
# End of macro FORTH_DSP_VALUEHL
a6d8			 
a6d8					FORTH_DSP_POP 
a6d8 cd 3f 98			call macro_forth_dsp_pop 
a6db				endm 
# End of macro FORTH_DSP_POP
a6db			 
a6db					; hl contains value to add to byte at a 
a6db				 
a6db eb					ex de, hl 
a6dc			 
a6dc e1					pop hl 
a6dd			 
a6dd					if DEBUG_FORTH_WORDS 
a6dd						DMARK "INC" 
a6dd f5				push af  
a6de 3a f2 a6			ld a, (.dmark)  
a6e1 32 7a ee			ld (debug_mark),a  
a6e4 3a f3 a6			ld a, (.dmark+1)  
a6e7 32 7b ee			ld (debug_mark+1),a  
a6ea 3a f4 a6			ld a, (.dmark+2)  
a6ed 32 7c ee			ld (debug_mark+2),a  
a6f0 18 03			jr .pastdmark  
a6f2 ..			.dmark: db "INC"  
a6f5 f1			.pastdmark: pop af  
a6f6			endm  
# End of macro DMARK
a6f6						CALLMONITOR 
a6f6 cd 7b 91			call break_point_state  
a6f9				endm  
# End of macro CALLMONITOR
a6f9					endif 
a6f9			 
a6f9 7e					ld a,(hl) 
a6fa 83					add e 
a6fb 77					ld (hl),a 
a6fc			 
a6fc			 
a6fc			 
a6fc				       NEXTW 
a6fc c3 f9 98			jp macro_next 
a6ff				endm 
# End of macro NEXTW
a6ff			 
a6ff			.DEC: 
a6ff				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a6ff 6f				db WORD_SYS_CORE+91             
a700 50 a7			dw .INC2            
a702 03				db 2 + 1 
a703 .. 00			db "-!",0              
a706				endm 
# End of macro CWHEAD
a706			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a706					if DEBUG_FORTH_WORDS_KEY 
a706						DMARK "-s_" 
a706 f5				push af  
a707 3a 1b a7			ld a, (.dmark)  
a70a 32 7a ee			ld (debug_mark),a  
a70d 3a 1c a7			ld a, (.dmark+1)  
a710 32 7b ee			ld (debug_mark+1),a  
a713 3a 1d a7			ld a, (.dmark+2)  
a716 32 7c ee			ld (debug_mark+2),a  
a719 18 03			jr .pastdmark  
a71b ..			.dmark: db "-s_"  
a71e f1			.pastdmark: pop af  
a71f			endm  
# End of macro DMARK
a71f						CALLMONITOR 
a71f cd 7b 91			call break_point_state  
a722				endm  
# End of macro CALLMONITOR
a722					endif 
a722			 
a722					FORTH_DSP_VALUEHL 
a722 cd a3 97			call macro_dsp_valuehl 
a725				endm 
# End of macro FORTH_DSP_VALUEHL
a725			 
a725 e5					push hl   ; save address 
a726			 
a726					FORTH_DSP_POP 
a726 cd 3f 98			call macro_forth_dsp_pop 
a729				endm 
# End of macro FORTH_DSP_POP
a729			 
a729					FORTH_DSP_VALUEHL 
a729 cd a3 97			call macro_dsp_valuehl 
a72c				endm 
# End of macro FORTH_DSP_VALUEHL
a72c			 
a72c					; hl contains value to add to byte at a 
a72c				 
a72c eb					ex de, hl 
a72d			 
a72d e1					pop hl 
a72e			 
a72e					if DEBUG_FORTH_WORDS 
a72e						DMARK "DEC" 
a72e f5				push af  
a72f 3a 43 a7			ld a, (.dmark)  
a732 32 7a ee			ld (debug_mark),a  
a735 3a 44 a7			ld a, (.dmark+1)  
a738 32 7b ee			ld (debug_mark+1),a  
a73b 3a 45 a7			ld a, (.dmark+2)  
a73e 32 7c ee			ld (debug_mark+2),a  
a741 18 03			jr .pastdmark  
a743 ..			.dmark: db "DEC"  
a746 f1			.pastdmark: pop af  
a747			endm  
# End of macro DMARK
a747						CALLMONITOR 
a747 cd 7b 91			call break_point_state  
a74a				endm  
# End of macro CALLMONITOR
a74a					endif 
a74a			 
a74a 7e					ld a,(hl) 
a74b 93					sub e 
a74c 77					ld (hl),a 
a74d			 
a74d			 
a74d			 
a74d				       NEXTW 
a74d c3 f9 98			jp macro_next 
a750				endm 
# End of macro NEXTW
a750			 
a750			.INC2: 
a750				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a750 6f				db WORD_SYS_CORE+91             
a751 fa a7			dw .DEC2            
a753 04				db 3 + 1 
a754 .. 00			db "+2!",0              
a758				endm 
# End of macro CWHEAD
a758			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a758			 
a758					if DEBUG_FORTH_WORDS_KEY 
a758						DMARK "+2s" 
a758 f5				push af  
a759 3a 6d a7			ld a, (.dmark)  
a75c 32 7a ee			ld (debug_mark),a  
a75f 3a 6e a7			ld a, (.dmark+1)  
a762 32 7b ee			ld (debug_mark+1),a  
a765 3a 6f a7			ld a, (.dmark+2)  
a768 32 7c ee			ld (debug_mark+2),a  
a76b 18 03			jr .pastdmark  
a76d ..			.dmark: db "+2s"  
a770 f1			.pastdmark: pop af  
a771			endm  
# End of macro DMARK
a771						CALLMONITOR 
a771 cd 7b 91			call break_point_state  
a774				endm  
# End of macro CALLMONITOR
a774					endif 
a774			 
a774					; Address 
a774			 
a774					FORTH_DSP_VALUEHL 
a774 cd a3 97			call macro_dsp_valuehl 
a777				endm 
# End of macro FORTH_DSP_VALUEHL
a777			 
a777 e5					push hl    ; save address 
a778			 
a778					; load content into de 
a778			 
a778 5e					ld e,(hl) 
a779 23					inc hl 
a77a 56					ld d, (hl) 
a77b			 
a77b					if DEBUG_FORTH_WORDS 
a77b						DMARK "+2a" 
a77b f5				push af  
a77c 3a 90 a7			ld a, (.dmark)  
a77f 32 7a ee			ld (debug_mark),a  
a782 3a 91 a7			ld a, (.dmark+1)  
a785 32 7b ee			ld (debug_mark+1),a  
a788 3a 92 a7			ld a, (.dmark+2)  
a78b 32 7c ee			ld (debug_mark+2),a  
a78e 18 03			jr .pastdmark  
a790 ..			.dmark: db "+2a"  
a793 f1			.pastdmark: pop af  
a794			endm  
# End of macro DMARK
a794						CALLMONITOR 
a794 cd 7b 91			call break_point_state  
a797				endm  
# End of macro CALLMONITOR
a797					endif 
a797			 
a797					FORTH_DSP_POP 
a797 cd 3f 98			call macro_forth_dsp_pop 
a79a				endm 
# End of macro FORTH_DSP_POP
a79a			 
a79a					; Get value to add 
a79a			 
a79a					FORTH_DSP_VALUE 
a79a cd 8c 97			call macro_forth_dsp_value 
a79d				endm 
# End of macro FORTH_DSP_VALUE
a79d			 
a79d					if DEBUG_FORTH_WORDS 
a79d						DMARK "+2v" 
a79d f5				push af  
a79e 3a b2 a7			ld a, (.dmark)  
a7a1 32 7a ee			ld (debug_mark),a  
a7a4 3a b3 a7			ld a, (.dmark+1)  
a7a7 32 7b ee			ld (debug_mark+1),a  
a7aa 3a b4 a7			ld a, (.dmark+2)  
a7ad 32 7c ee			ld (debug_mark+2),a  
a7b0 18 03			jr .pastdmark  
a7b2 ..			.dmark: db "+2v"  
a7b5 f1			.pastdmark: pop af  
a7b6			endm  
# End of macro DMARK
a7b6						CALLMONITOR 
a7b6 cd 7b 91			call break_point_state  
a7b9				endm  
# End of macro CALLMONITOR
a7b9					endif 
a7b9			 
a7b9 19					add hl, de 
a7ba			 
a7ba					if DEBUG_FORTH_WORDS 
a7ba						DMARK "+2+" 
a7ba f5				push af  
a7bb 3a cf a7			ld a, (.dmark)  
a7be 32 7a ee			ld (debug_mark),a  
a7c1 3a d0 a7			ld a, (.dmark+1)  
a7c4 32 7b ee			ld (debug_mark+1),a  
a7c7 3a d1 a7			ld a, (.dmark+2)  
a7ca 32 7c ee			ld (debug_mark+2),a  
a7cd 18 03			jr .pastdmark  
a7cf ..			.dmark: db "+2+"  
a7d2 f1			.pastdmark: pop af  
a7d3			endm  
# End of macro DMARK
a7d3						CALLMONITOR 
a7d3 cd 7b 91			call break_point_state  
a7d6				endm  
# End of macro CALLMONITOR
a7d6					endif 
a7d6			 
a7d6					; move result to de 
a7d6			 
a7d6 eb					ex de, hl 
a7d7			 
a7d7					; Address 
a7d7			 
a7d7 e1					pop hl 
a7d8			 
a7d8					; save it back 
a7d8			 
a7d8 73					ld (hl), e 
a7d9 23					inc hl 
a7da 72					ld (hl), d 
a7db			 
a7db					if DEBUG_FORTH_WORDS 
a7db						DMARK "+2e" 
a7db f5				push af  
a7dc 3a f0 a7			ld a, (.dmark)  
a7df 32 7a ee			ld (debug_mark),a  
a7e2 3a f1 a7			ld a, (.dmark+1)  
a7e5 32 7b ee			ld (debug_mark+1),a  
a7e8 3a f2 a7			ld a, (.dmark+2)  
a7eb 32 7c ee			ld (debug_mark+2),a  
a7ee 18 03			jr .pastdmark  
a7f0 ..			.dmark: db "+2e"  
a7f3 f1			.pastdmark: pop af  
a7f4			endm  
# End of macro DMARK
a7f4						CALLMONITOR 
a7f4 cd 7b 91			call break_point_state  
a7f7				endm  
# End of macro CALLMONITOR
a7f7					endif 
a7f7			 
a7f7			 
a7f7			 
a7f7			 
a7f7			 
a7f7				       NEXTW 
a7f7 c3 f9 98			jp macro_next 
a7fa				endm 
# End of macro NEXTW
a7fa			 
a7fa			.DEC2: 
a7fa				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a7fa 6f				db WORD_SYS_CORE+91             
a7fb a6 a8			dw .GET2            
a7fd 04				db 3 + 1 
a7fe .. 00			db "-2!",0              
a802				endm 
# End of macro CWHEAD
a802			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a802			 
a802			 
a802					if DEBUG_FORTH_WORDS_KEY 
a802						DMARK "-2s" 
a802 f5				push af  
a803 3a 17 a8			ld a, (.dmark)  
a806 32 7a ee			ld (debug_mark),a  
a809 3a 18 a8			ld a, (.dmark+1)  
a80c 32 7b ee			ld (debug_mark+1),a  
a80f 3a 19 a8			ld a, (.dmark+2)  
a812 32 7c ee			ld (debug_mark+2),a  
a815 18 03			jr .pastdmark  
a817 ..			.dmark: db "-2s"  
a81a f1			.pastdmark: pop af  
a81b			endm  
# End of macro DMARK
a81b						CALLMONITOR 
a81b cd 7b 91			call break_point_state  
a81e				endm  
# End of macro CALLMONITOR
a81e					endif 
a81e			 
a81e					; Address 
a81e			 
a81e					FORTH_DSP_VALUEHL 
a81e cd a3 97			call macro_dsp_valuehl 
a821				endm 
# End of macro FORTH_DSP_VALUEHL
a821			 
a821 e5					push hl    ; save address 
a822			 
a822					; load content into de 
a822			 
a822 5e					ld e,(hl) 
a823 23					inc hl 
a824 56					ld d, (hl) 
a825			 
a825					if DEBUG_FORTH_WORDS 
a825						DMARK "-2a" 
a825 f5				push af  
a826 3a 3a a8			ld a, (.dmark)  
a829 32 7a ee			ld (debug_mark),a  
a82c 3a 3b a8			ld a, (.dmark+1)  
a82f 32 7b ee			ld (debug_mark+1),a  
a832 3a 3c a8			ld a, (.dmark+2)  
a835 32 7c ee			ld (debug_mark+2),a  
a838 18 03			jr .pastdmark  
a83a ..			.dmark: db "-2a"  
a83d f1			.pastdmark: pop af  
a83e			endm  
# End of macro DMARK
a83e						CALLMONITOR 
a83e cd 7b 91			call break_point_state  
a841				endm  
# End of macro CALLMONITOR
a841					endif 
a841			 
a841					FORTH_DSP_POP 
a841 cd 3f 98			call macro_forth_dsp_pop 
a844				endm 
# End of macro FORTH_DSP_POP
a844			 
a844					; Get value to remove 
a844			 
a844					FORTH_DSP_VALUE 
a844 cd 8c 97			call macro_forth_dsp_value 
a847				endm 
# End of macro FORTH_DSP_VALUE
a847			 
a847					if DEBUG_FORTH_WORDS 
a847						DMARK "-2v" 
a847 f5				push af  
a848 3a 5c a8			ld a, (.dmark)  
a84b 32 7a ee			ld (debug_mark),a  
a84e 3a 5d a8			ld a, (.dmark+1)  
a851 32 7b ee			ld (debug_mark+1),a  
a854 3a 5e a8			ld a, (.dmark+2)  
a857 32 7c ee			ld (debug_mark+2),a  
a85a 18 03			jr .pastdmark  
a85c ..			.dmark: db "-2v"  
a85f f1			.pastdmark: pop af  
a860			endm  
# End of macro DMARK
a860						CALLMONITOR 
a860 cd 7b 91			call break_point_state  
a863				endm  
# End of macro CALLMONITOR
a863					endif 
a863			 
a863 eb					ex de, hl 
a864 ed 52				sbc hl, de 
a866			 
a866					if DEBUG_FORTH_WORDS 
a866						DMARK "-2d" 
a866 f5				push af  
a867 3a 7b a8			ld a, (.dmark)  
a86a 32 7a ee			ld (debug_mark),a  
a86d 3a 7c a8			ld a, (.dmark+1)  
a870 32 7b ee			ld (debug_mark+1),a  
a873 3a 7d a8			ld a, (.dmark+2)  
a876 32 7c ee			ld (debug_mark+2),a  
a879 18 03			jr .pastdmark  
a87b ..			.dmark: db "-2d"  
a87e f1			.pastdmark: pop af  
a87f			endm  
# End of macro DMARK
a87f						CALLMONITOR 
a87f cd 7b 91			call break_point_state  
a882				endm  
# End of macro CALLMONITOR
a882					endif 
a882			 
a882					; move result to de 
a882			 
a882 eb					ex de, hl 
a883			 
a883					; Address 
a883			 
a883 e1					pop hl 
a884			 
a884					; save it back 
a884			 
a884 73					ld (hl), e 
a885 23					inc hl 
a886 72					ld (hl), d 
a887			 
a887					if DEBUG_FORTH_WORDS 
a887						DMARK "-2e" 
a887 f5				push af  
a888 3a 9c a8			ld a, (.dmark)  
a88b 32 7a ee			ld (debug_mark),a  
a88e 3a 9d a8			ld a, (.dmark+1)  
a891 32 7b ee			ld (debug_mark+1),a  
a894 3a 9e a8			ld a, (.dmark+2)  
a897 32 7c ee			ld (debug_mark+2),a  
a89a 18 03			jr .pastdmark  
a89c ..			.dmark: db "-2e"  
a89f f1			.pastdmark: pop af  
a8a0			endm  
# End of macro DMARK
a8a0						CALLMONITOR 
a8a0 cd 7b 91			call break_point_state  
a8a3				endm  
# End of macro CALLMONITOR
a8a3					endif 
a8a3			 
a8a3			 
a8a3			 
a8a3			 
a8a3			 
a8a3				       NEXTW 
a8a3 c3 f9 98			jp macro_next 
a8a6				endm 
# End of macro NEXTW
a8a6			.GET2: 
a8a6				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
a8a6 6f				db WORD_SYS_CORE+91             
a8a7 d6 a8			dw .BANG2            
a8a9 03				db 2 + 1 
a8aa .. 00			db "2@",0              
a8ad				endm 
# End of macro CWHEAD
a8ad			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
a8ad					if DEBUG_FORTH_WORDS_KEY 
a8ad						DMARK "2A_" 
a8ad f5				push af  
a8ae 3a c2 a8			ld a, (.dmark)  
a8b1 32 7a ee			ld (debug_mark),a  
a8b4 3a c3 a8			ld a, (.dmark+1)  
a8b7 32 7b ee			ld (debug_mark+1),a  
a8ba 3a c4 a8			ld a, (.dmark+2)  
a8bd 32 7c ee			ld (debug_mark+2),a  
a8c0 18 03			jr .pastdmark  
a8c2 ..			.dmark: db "2A_"  
a8c5 f1			.pastdmark: pop af  
a8c6			endm  
# End of macro DMARK
a8c6						CALLMONITOR 
a8c6 cd 7b 91			call break_point_state  
a8c9				endm  
# End of macro CALLMONITOR
a8c9					endif 
a8c9			 
a8c9					FORTH_DSP_VALUEHL 
a8c9 cd a3 97			call macro_dsp_valuehl 
a8cc				endm 
# End of macro FORTH_DSP_VALUEHL
a8cc			 
a8cc 5e					ld e, (hl) 
a8cd 23					inc hl 
a8ce 56					ld d, (hl) 
a8cf			 
a8cf eb					ex de, hl 
a8d0			 
a8d0 cd 08 97				call forth_push_numhl 
a8d3			 
a8d3				       NEXTW 
a8d3 c3 f9 98			jp macro_next 
a8d6				endm 
# End of macro NEXTW
a8d6			.BANG2: 
a8d6				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
a8d6 6f				db WORD_SYS_CORE+91             
a8d7 0e a9			dw .ENDCORE            
a8d9 03				db 2 + 1 
a8da .. 00			db "2!",0              
a8dd				endm 
# End of macro CWHEAD
a8dd			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
a8dd					if DEBUG_FORTH_WORDS_KEY 
a8dd						DMARK "2S_" 
a8dd f5				push af  
a8de 3a f2 a8			ld a, (.dmark)  
a8e1 32 7a ee			ld (debug_mark),a  
a8e4 3a f3 a8			ld a, (.dmark+1)  
a8e7 32 7b ee			ld (debug_mark+1),a  
a8ea 3a f4 a8			ld a, (.dmark+2)  
a8ed 32 7c ee			ld (debug_mark+2),a  
a8f0 18 03			jr .pastdmark  
a8f2 ..			.dmark: db "2S_"  
a8f5 f1			.pastdmark: pop af  
a8f6			endm  
# End of macro DMARK
a8f6						CALLMONITOR 
a8f6 cd 7b 91			call break_point_state  
a8f9				endm  
# End of macro CALLMONITOR
a8f9					endif 
a8f9			 
a8f9					FORTH_DSP_VALUEHL 
a8f9 cd a3 97			call macro_dsp_valuehl 
a8fc				endm 
# End of macro FORTH_DSP_VALUEHL
a8fc			 
a8fc e5					push hl   ; save address 
a8fd			 
a8fd			 
a8fd					FORTH_DSP_POP 
a8fd cd 3f 98			call macro_forth_dsp_pop 
a900				endm 
# End of macro FORTH_DSP_POP
a900			 
a900					 
a900					FORTH_DSP_VALUEHL 
a900 cd a3 97			call macro_dsp_valuehl 
a903				endm 
# End of macro FORTH_DSP_VALUEHL
a903			 
a903					FORTH_DSP_POP 
a903 cd 3f 98			call macro_forth_dsp_pop 
a906				endm 
# End of macro FORTH_DSP_POP
a906			 
a906 eb					ex de, hl    ; value now in de 
a907			 
a907 e1					pop hl 
a908			 
a908 73					ld (hl), e 
a909			 
a909 23					inc hl 
a90a			 
a90a 72					ld (hl), d 
a90b			 
a90b			 
a90b				       NEXTW 
a90b c3 f9 98			jp macro_next 
a90e				endm 
# End of macro NEXTW
a90e			.ENDCORE: 
a90e			 
a90e			; eof 
a90e			 
a90e			 
# End of file forth_words_core.asm
a90e			include "forth_words_flow.asm" 
a90e			 
a90e			; | ## Program Flow Words 
a90e			 
a90e			.IF: 
a90e				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
a90e 1e				db WORD_SYS_CORE+10             
a90f 03 aa			dw .THEN            
a911 03				db 2 + 1 
a912 .. 00			db "IF",0              
a915				endm 
# End of macro CWHEAD
a915			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
a915			; 
a915					if DEBUG_FORTH_WORDS_KEY 
a915						DMARK "IF." 
a915 f5				push af  
a916 3a 2a a9			ld a, (.dmark)  
a919 32 7a ee			ld (debug_mark),a  
a91c 3a 2b a9			ld a, (.dmark+1)  
a91f 32 7b ee			ld (debug_mark+1),a  
a922 3a 2c a9			ld a, (.dmark+2)  
a925 32 7c ee			ld (debug_mark+2),a  
a928 18 03			jr .pastdmark  
a92a ..			.dmark: db "IF."  
a92d f1			.pastdmark: pop af  
a92e			endm  
# End of macro DMARK
a92e						CALLMONITOR 
a92e cd 7b 91			call break_point_state  
a931				endm  
# End of macro CALLMONITOR
a931					endif 
a931			; eval TOS 
a931			 
a931				FORTH_DSP_VALUEHL 
a931 cd a3 97			call macro_dsp_valuehl 
a934				endm 
# End of macro FORTH_DSP_VALUEHL
a934			 
a934			;	push hl 
a934				FORTH_DSP_POP 
a934 cd 3f 98			call macro_forth_dsp_pop 
a937				endm 
# End of macro FORTH_DSP_POP
a937			;	pop hl 
a937			 
a937					if DEBUG_FORTH_WORDS 
a937						DMARK "IF1" 
a937 f5				push af  
a938 3a 4c a9			ld a, (.dmark)  
a93b 32 7a ee			ld (debug_mark),a  
a93e 3a 4d a9			ld a, (.dmark+1)  
a941 32 7b ee			ld (debug_mark+1),a  
a944 3a 4e a9			ld a, (.dmark+2)  
a947 32 7c ee			ld (debug_mark+2),a  
a94a 18 03			jr .pastdmark  
a94c ..			.dmark: db "IF1"  
a94f f1			.pastdmark: pop af  
a950			endm  
# End of macro DMARK
a950						CALLMONITOR 
a950 cd 7b 91			call break_point_state  
a953				endm  
# End of macro CALLMONITOR
a953					endif 
a953 b7				or a        ; clear carry flag 
a954 11 00 00			ld de, 0 
a957 eb				ex de,hl 
a958 ed 52			sbc hl, de 
a95a c2 e4 a9			jp nz, .iftrue 
a95d			 
a95d					if DEBUG_FORTH_WORDS 
a95d						DMARK "IF2" 
a95d f5				push af  
a95e 3a 72 a9			ld a, (.dmark)  
a961 32 7a ee			ld (debug_mark),a  
a964 3a 73 a9			ld a, (.dmark+1)  
a967 32 7b ee			ld (debug_mark+1),a  
a96a 3a 74 a9			ld a, (.dmark+2)  
a96d 32 7c ee			ld (debug_mark+2),a  
a970 18 03			jr .pastdmark  
a972 ..			.dmark: db "IF2"  
a975 f1			.pastdmark: pop af  
a976			endm  
# End of macro DMARK
a976						CALLMONITOR 
a976 cd 7b 91			call break_point_state  
a979				endm  
# End of macro CALLMONITOR
a979					endif 
a979			 
a979			; if not true then skip to THEN 
a979			 
a979				; TODO get tok_ptr 
a979				; TODO consume toks until we get to THEN 
a979			 
a979 2a 76 e6			ld hl, (os_tok_ptr) 
a97c					if DEBUG_FORTH_WORDS 
a97c						DMARK "IF3" 
a97c f5				push af  
a97d 3a 91 a9			ld a, (.dmark)  
a980 32 7a ee			ld (debug_mark),a  
a983 3a 92 a9			ld a, (.dmark+1)  
a986 32 7b ee			ld (debug_mark+1),a  
a989 3a 93 a9			ld a, (.dmark+2)  
a98c 32 7c ee			ld (debug_mark+2),a  
a98f 18 03			jr .pastdmark  
a991 ..			.dmark: db "IF3"  
a994 f1			.pastdmark: pop af  
a995			endm  
# End of macro DMARK
a995						CALLMONITOR 
a995 cd 7b 91			call break_point_state  
a998				endm  
# End of macro CALLMONITOR
a998						 
a998					endif 
a998 11 df a9			ld de, .ifthen 
a99b					if DEBUG_FORTH_WORDS 
a99b						DMARK "IF4" 
a99b f5				push af  
a99c 3a b0 a9			ld a, (.dmark)  
a99f 32 7a ee			ld (debug_mark),a  
a9a2 3a b1 a9			ld a, (.dmark+1)  
a9a5 32 7b ee			ld (debug_mark+1),a  
a9a8 3a b2 a9			ld a, (.dmark+2)  
a9ab 32 7c ee			ld (debug_mark+2),a  
a9ae 18 03			jr .pastdmark  
a9b0 ..			.dmark: db "IF4"  
a9b3 f1			.pastdmark: pop af  
a9b4			endm  
# End of macro DMARK
a9b4						CALLMONITOR 
a9b4 cd 7b 91			call break_point_state  
a9b7				endm  
# End of macro CALLMONITOR
a9b7					endif 
a9b7 cd 14 9a			call findnexttok  
a9ba			 
a9ba					if DEBUG_FORTH_WORDS 
a9ba						DMARK "IF5" 
a9ba f5				push af  
a9bb 3a cf a9			ld a, (.dmark)  
a9be 32 7a ee			ld (debug_mark),a  
a9c1 3a d0 a9			ld a, (.dmark+1)  
a9c4 32 7b ee			ld (debug_mark+1),a  
a9c7 3a d1 a9			ld a, (.dmark+2)  
a9ca 32 7c ee			ld (debug_mark+2),a  
a9cd 18 03			jr .pastdmark  
a9cf ..			.dmark: db "IF5"  
a9d2 f1			.pastdmark: pop af  
a9d3			endm  
# End of macro DMARK
a9d3						CALLMONITOR 
a9d3 cd 7b 91			call break_point_state  
a9d6				endm  
# End of macro CALLMONITOR
a9d6					endif 
a9d6				; TODO replace below with ; exec using tok_ptr 
a9d6 22 76 e6			ld (os_tok_ptr), hl 
a9d9 c3 8a 99			jp exec1 
a9dc				NEXTW 
a9dc c3 f9 98			jp macro_next 
a9df				endm 
# End of macro NEXTW
a9df			 
a9df .. 00		.ifthen:  db "THEN",0 
a9e4			 
a9e4			.iftrue:		 
a9e4				; Exec next words normally 
a9e4			 
a9e4				; if true then exec following IF as normal 
a9e4					if DEBUG_FORTH_WORDS 
a9e4						DMARK "IFT" 
a9e4 f5				push af  
a9e5 3a f9 a9			ld a, (.dmark)  
a9e8 32 7a ee			ld (debug_mark),a  
a9eb 3a fa a9			ld a, (.dmark+1)  
a9ee 32 7b ee			ld (debug_mark+1),a  
a9f1 3a fb a9			ld a, (.dmark+2)  
a9f4 32 7c ee			ld (debug_mark+2),a  
a9f7 18 03			jr .pastdmark  
a9f9 ..			.dmark: db "IFT"  
a9fc f1			.pastdmark: pop af  
a9fd			endm  
# End of macro DMARK
a9fd						CALLMONITOR 
a9fd cd 7b 91			call break_point_state  
aa00				endm  
# End of macro CALLMONITOR
aa00					endif 
aa00			 
aa00					NEXTW 
aa00 c3 f9 98			jp macro_next 
aa03				endm 
# End of macro NEXTW
aa03			.THEN: 
aa03				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aa03 1f				db WORD_SYS_CORE+11             
aa04 2b aa			dw .ELSE            
aa06 05				db 4 + 1 
aa07 .. 00			db "THEN",0              
aa0c				endm 
# End of macro CWHEAD
aa0c			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aa0c					if DEBUG_FORTH_WORDS_KEY 
aa0c						DMARK "THN" 
aa0c f5				push af  
aa0d 3a 21 aa			ld a, (.dmark)  
aa10 32 7a ee			ld (debug_mark),a  
aa13 3a 22 aa			ld a, (.dmark+1)  
aa16 32 7b ee			ld (debug_mark+1),a  
aa19 3a 23 aa			ld a, (.dmark+2)  
aa1c 32 7c ee			ld (debug_mark+2),a  
aa1f 18 03			jr .pastdmark  
aa21 ..			.dmark: db "THN"  
aa24 f1			.pastdmark: pop af  
aa25			endm  
# End of macro DMARK
aa25						CALLMONITOR 
aa25 cd 7b 91			call break_point_state  
aa28				endm  
# End of macro CALLMONITOR
aa28					endif 
aa28					NEXTW 
aa28 c3 f9 98			jp macro_next 
aa2b				endm 
# End of macro NEXTW
aa2b			.ELSE: 
aa2b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aa2b 20				db WORD_SYS_CORE+12             
aa2c 53 aa			dw .DO            
aa2e 03				db 2 + 1 
aa2f .. 00			db "ELSE",0              
aa34				endm 
# End of macro CWHEAD
aa34			; | ELSE ( -- ) Not supported - does nothing | TODO 
aa34			 
aa34					if DEBUG_FORTH_WORDS_KEY 
aa34						DMARK "ELS" 
aa34 f5				push af  
aa35 3a 49 aa			ld a, (.dmark)  
aa38 32 7a ee			ld (debug_mark),a  
aa3b 3a 4a aa			ld a, (.dmark+1)  
aa3e 32 7b ee			ld (debug_mark+1),a  
aa41 3a 4b aa			ld a, (.dmark+2)  
aa44 32 7c ee			ld (debug_mark+2),a  
aa47 18 03			jr .pastdmark  
aa49 ..			.dmark: db "ELS"  
aa4c f1			.pastdmark: pop af  
aa4d			endm  
# End of macro DMARK
aa4d						CALLMONITOR 
aa4d cd 7b 91			call break_point_state  
aa50				endm  
# End of macro CALLMONITOR
aa50					endif 
aa50			 
aa50			 
aa50					NEXTW 
aa50 c3 f9 98			jp macro_next 
aa53				endm 
# End of macro NEXTW
aa53			.DO: 
aa53				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aa53 21				db WORD_SYS_CORE+13             
aa54 7a ab			dw .LOOP            
aa56 03				db 2 + 1 
aa57 .. 00			db "DO",0              
aa5a				endm 
# End of macro CWHEAD
aa5a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aa5a			 
aa5a					if DEBUG_FORTH_WORDS_KEY 
aa5a						DMARK "DO." 
aa5a f5				push af  
aa5b 3a 6f aa			ld a, (.dmark)  
aa5e 32 7a ee			ld (debug_mark),a  
aa61 3a 70 aa			ld a, (.dmark+1)  
aa64 32 7b ee			ld (debug_mark+1),a  
aa67 3a 71 aa			ld a, (.dmark+2)  
aa6a 32 7c ee			ld (debug_mark+2),a  
aa6d 18 03			jr .pastdmark  
aa6f ..			.dmark: db "DO."  
aa72 f1			.pastdmark: pop af  
aa73			endm  
# End of macro DMARK
aa73						CALLMONITOR 
aa73 cd 7b 91			call break_point_state  
aa76				endm  
# End of macro CALLMONITOR
aa76					endif 
aa76			;  push pc to rsp stack past the DO 
aa76			 
aa76 2a 76 e6				ld hl, (os_tok_ptr) 
aa79 23					inc hl   ; D 
aa7a 23					inc hl  ; O 
aa7b 23					inc hl   ; null 
aa7c					if DEBUG_FORTH_WORDS 
aa7c						DMARK "DO2" 
aa7c f5				push af  
aa7d 3a 91 aa			ld a, (.dmark)  
aa80 32 7a ee			ld (debug_mark),a  
aa83 3a 92 aa			ld a, (.dmark+1)  
aa86 32 7b ee			ld (debug_mark+1),a  
aa89 3a 93 aa			ld a, (.dmark+2)  
aa8c 32 7c ee			ld (debug_mark+2),a  
aa8f 18 03			jr .pastdmark  
aa91 ..			.dmark: db "DO2"  
aa94 f1			.pastdmark: pop af  
aa95			endm  
# End of macro DMARK
aa95						CALLMONITOR 
aa95 cd 7b 91			call break_point_state  
aa98				endm  
# End of macro CALLMONITOR
aa98					endif 
aa98					FORTH_RSP_NEXT 
aa98 cd af 96			call macro_forth_rsp_next 
aa9b				endm 
# End of macro FORTH_RSP_NEXT
aa9b					if DEBUG_FORTH_WORDS 
aa9b						DMARK "DO3" 
aa9b f5				push af  
aa9c 3a b0 aa			ld a, (.dmark)  
aa9f 32 7a ee			ld (debug_mark),a  
aaa2 3a b1 aa			ld a, (.dmark+1)  
aaa5 32 7b ee			ld (debug_mark+1),a  
aaa8 3a b2 aa			ld a, (.dmark+2)  
aaab 32 7c ee			ld (debug_mark+2),a  
aaae 18 03			jr .pastdmark  
aab0 ..			.dmark: db "DO3"  
aab3 f1			.pastdmark: pop af  
aab4			endm  
# End of macro DMARK
aab4						CALLMONITOR 
aab4 cd 7b 91			call break_point_state  
aab7				endm  
# End of macro CALLMONITOR
aab7					endif 
aab7			 
aab7					;if DEBUG_FORTH_WORDS 
aab7				;		push hl 
aab7			;		endif  
aab7			 
aab7			; get counters from data stack 
aab7			 
aab7			 
aab7					FORTH_DSP_VALUEHL 
aab7 cd a3 97			call macro_dsp_valuehl 
aaba				endm 
# End of macro FORTH_DSP_VALUEHL
aaba e5					push hl		 ; hl now has starting counter which needs to be tos 
aabb			 
aabb					if DEBUG_FORTH_WORDS 
aabb						DMARK "DO4" 
aabb f5				push af  
aabc 3a d0 aa			ld a, (.dmark)  
aabf 32 7a ee			ld (debug_mark),a  
aac2 3a d1 aa			ld a, (.dmark+1)  
aac5 32 7b ee			ld (debug_mark+1),a  
aac8 3a d2 aa			ld a, (.dmark+2)  
aacb 32 7c ee			ld (debug_mark+2),a  
aace 18 03			jr .pastdmark  
aad0 ..			.dmark: db "DO4"  
aad3 f1			.pastdmark: pop af  
aad4			endm  
# End of macro DMARK
aad4						CALLMONITOR 
aad4 cd 7b 91			call break_point_state  
aad7				endm  
# End of macro CALLMONITOR
aad7					endif 
aad7					FORTH_DSP_POP 
aad7 cd 3f 98			call macro_forth_dsp_pop 
aada				endm 
# End of macro FORTH_DSP_POP
aada			 
aada					if DEBUG_FORTH_WORDS 
aada						DMARK "DO5" 
aada f5				push af  
aadb 3a ef aa			ld a, (.dmark)  
aade 32 7a ee			ld (debug_mark),a  
aae1 3a f0 aa			ld a, (.dmark+1)  
aae4 32 7b ee			ld (debug_mark+1),a  
aae7 3a f1 aa			ld a, (.dmark+2)  
aaea 32 7c ee			ld (debug_mark+2),a  
aaed 18 03			jr .pastdmark  
aaef ..			.dmark: db "DO5"  
aaf2 f1			.pastdmark: pop af  
aaf3			endm  
# End of macro DMARK
aaf3						CALLMONITOR 
aaf3 cd 7b 91			call break_point_state  
aaf6				endm  
# End of macro CALLMONITOR
aaf6					endif 
aaf6			 
aaf6					FORTH_DSP_VALUEHL 
aaf6 cd a3 97			call macro_dsp_valuehl 
aaf9				endm 
# End of macro FORTH_DSP_VALUEHL
aaf9			;		push hl		 ; hl now has starting limit counter 
aaf9			 
aaf9					if DEBUG_FORTH_WORDS 
aaf9						DMARK "DO6" 
aaf9 f5				push af  
aafa 3a 0e ab			ld a, (.dmark)  
aafd 32 7a ee			ld (debug_mark),a  
ab00 3a 0f ab			ld a, (.dmark+1)  
ab03 32 7b ee			ld (debug_mark+1),a  
ab06 3a 10 ab			ld a, (.dmark+2)  
ab09 32 7c ee			ld (debug_mark+2),a  
ab0c 18 03			jr .pastdmark  
ab0e ..			.dmark: db "DO6"  
ab11 f1			.pastdmark: pop af  
ab12			endm  
# End of macro DMARK
ab12						CALLMONITOR 
ab12 cd 7b 91			call break_point_state  
ab15				endm  
# End of macro CALLMONITOR
ab15					endif 
ab15					FORTH_DSP_POP 
ab15 cd 3f 98			call macro_forth_dsp_pop 
ab18				endm 
# End of macro FORTH_DSP_POP
ab18			 
ab18			; put counters on the loop stack 
ab18			 
ab18			;		pop hl			 ; limit counter 
ab18 d1					pop de			; start counter 
ab19			 
ab19					; push limit counter 
ab19			 
ab19					if DEBUG_FORTH_WORDS 
ab19						DMARK "DO7" 
ab19 f5				push af  
ab1a 3a 2e ab			ld a, (.dmark)  
ab1d 32 7a ee			ld (debug_mark),a  
ab20 3a 2f ab			ld a, (.dmark+1)  
ab23 32 7b ee			ld (debug_mark+1),a  
ab26 3a 30 ab			ld a, (.dmark+2)  
ab29 32 7c ee			ld (debug_mark+2),a  
ab2c 18 03			jr .pastdmark  
ab2e ..			.dmark: db "DO7"  
ab31 f1			.pastdmark: pop af  
ab32			endm  
# End of macro DMARK
ab32						CALLMONITOR 
ab32 cd 7b 91			call break_point_state  
ab35				endm  
# End of macro CALLMONITOR
ab35					endif 
ab35					FORTH_LOOP_NEXT 
ab35 cd b8 97			call macro_forth_loop_next 
ab38				endm 
# End of macro FORTH_LOOP_NEXT
ab38			 
ab38					; push start counter 
ab38			 
ab38 eb					ex de, hl 
ab39					if DEBUG_FORTH_WORDS 
ab39						DMARK "DO7" 
ab39 f5				push af  
ab3a 3a 4e ab			ld a, (.dmark)  
ab3d 32 7a ee			ld (debug_mark),a  
ab40 3a 4f ab			ld a, (.dmark+1)  
ab43 32 7b ee			ld (debug_mark+1),a  
ab46 3a 50 ab			ld a, (.dmark+2)  
ab49 32 7c ee			ld (debug_mark+2),a  
ab4c 18 03			jr .pastdmark  
ab4e ..			.dmark: db "DO7"  
ab51 f1			.pastdmark: pop af  
ab52			endm  
# End of macro DMARK
ab52						CALLMONITOR 
ab52 cd 7b 91			call break_point_state  
ab55				endm  
# End of macro CALLMONITOR
ab55					endif 
ab55					FORTH_LOOP_NEXT 
ab55 cd b8 97			call macro_forth_loop_next 
ab58				endm 
# End of macro FORTH_LOOP_NEXT
ab58			 
ab58			 
ab58					; init first round of I counter 
ab58			 
ab58 22 9a e6				ld (os_current_i), hl 
ab5b			 
ab5b					if DEBUG_FORTH_WORDS 
ab5b						DMARK "DO8" 
ab5b f5				push af  
ab5c 3a 70 ab			ld a, (.dmark)  
ab5f 32 7a ee			ld (debug_mark),a  
ab62 3a 71 ab			ld a, (.dmark+1)  
ab65 32 7b ee			ld (debug_mark+1),a  
ab68 3a 72 ab			ld a, (.dmark+2)  
ab6b 32 7c ee			ld (debug_mark+2),a  
ab6e 18 03			jr .pastdmark  
ab70 ..			.dmark: db "DO8"  
ab73 f1			.pastdmark: pop af  
ab74			endm  
# End of macro DMARK
ab74						CALLMONITOR 
ab74 cd 7b 91			call break_point_state  
ab77				endm  
# End of macro CALLMONITOR
ab77					endif 
ab77			 
ab77					NEXTW 
ab77 c3 f9 98			jp macro_next 
ab7a				endm 
# End of macro NEXTW
ab7a			.LOOP: 
ab7a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ab7a 22				db WORD_SYS_CORE+14             
ab7b 92 ac			dw .I            
ab7d 05				db 4 + 1 
ab7e .. 00			db "LOOP",0              
ab83				endm 
# End of macro CWHEAD
ab83			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ab83			 
ab83				; pop tos as current loop count to hl 
ab83			 
ab83				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ab83			 
ab83				FORTH_LOOP_TOS 
ab83 cd eb 97			call macro_forth_loop_tos 
ab86				endm 
# End of macro FORTH_LOOP_TOS
ab86 e5				push hl 
ab87			 
ab87					if DEBUG_FORTH_WORDS_KEY 
ab87						DMARK "LOP" 
ab87 f5				push af  
ab88 3a 9c ab			ld a, (.dmark)  
ab8b 32 7a ee			ld (debug_mark),a  
ab8e 3a 9d ab			ld a, (.dmark+1)  
ab91 32 7b ee			ld (debug_mark+1),a  
ab94 3a 9e ab			ld a, (.dmark+2)  
ab97 32 7c ee			ld (debug_mark+2),a  
ab9a 18 03			jr .pastdmark  
ab9c ..			.dmark: db "LOP"  
ab9f f1			.pastdmark: pop af  
aba0			endm  
# End of macro DMARK
aba0						CALLMONITOR 
aba0 cd 7b 91			call break_point_state  
aba3				endm  
# End of macro CALLMONITOR
aba3					endif 
aba3				; next item on the stack is the limit. get it 
aba3			 
aba3			 
aba3				FORTH_LOOP_POP 
aba3 cd f5 97			call macro_forth_loop_pop 
aba6				endm 
# End of macro FORTH_LOOP_POP
aba6			 
aba6				FORTH_LOOP_TOS 
aba6 cd eb 97			call macro_forth_loop_tos 
aba9				endm 
# End of macro FORTH_LOOP_TOS
aba9			 
aba9 d1				pop de		 ; de = i, hl = limit 
abaa			 
abaa					if DEBUG_FORTH_WORDS 
abaa						DMARK "LP1" 
abaa f5				push af  
abab 3a bf ab			ld a, (.dmark)  
abae 32 7a ee			ld (debug_mark),a  
abb1 3a c0 ab			ld a, (.dmark+1)  
abb4 32 7b ee			ld (debug_mark+1),a  
abb7 3a c1 ab			ld a, (.dmark+2)  
abba 32 7c ee			ld (debug_mark+2),a  
abbd 18 03			jr .pastdmark  
abbf ..			.dmark: db "LP1"  
abc2 f1			.pastdmark: pop af  
abc3			endm  
# End of macro DMARK
abc3						CALLMONITOR 
abc3 cd 7b 91			call break_point_state  
abc6				endm  
# End of macro CALLMONITOR
abc6					endif 
abc6			 
abc6				; go back to previous word 
abc6			 
abc6 d5				push de    ; save I for inc later 
abc7			 
abc7			 
abc7				; get limit 
abc7				;  is I at limit? 
abc7			 
abc7			 
abc7					if DEBUG_FORTH_WORDS 
abc7						DMARK "LP1" 
abc7 f5				push af  
abc8 3a dc ab			ld a, (.dmark)  
abcb 32 7a ee			ld (debug_mark),a  
abce 3a dd ab			ld a, (.dmark+1)  
abd1 32 7b ee			ld (debug_mark+1),a  
abd4 3a de ab			ld a, (.dmark+2)  
abd7 32 7c ee			ld (debug_mark+2),a  
abda 18 03			jr .pastdmark  
abdc ..			.dmark: db "LP1"  
abdf f1			.pastdmark: pop af  
abe0			endm  
# End of macro DMARK
abe0						CALLMONITOR 
abe0 cd 7b 91			call break_point_state  
abe3				endm  
# End of macro CALLMONITOR
abe3					endif 
abe3			 
abe3 ed 52			sbc hl, de 
abe5			 
abe5			 
abe5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
abe5			 
abe5 20 26				jr nz, .loopnotdone 
abe7			 
abe7 e1				pop hl   ; get rid of saved I 
abe8				FORTH_LOOP_POP     ; get rid of limit 
abe8 cd f5 97			call macro_forth_loop_pop 
abeb				endm 
# End of macro FORTH_LOOP_POP
abeb			 
abeb				FORTH_RSP_POP     ; get rid of DO ptr 
abeb cd d0 96			call macro_forth_rsp_pop 
abee				endm 
# End of macro FORTH_RSP_POP
abee			 
abee			if DEBUG_FORTH_WORDS 
abee						DMARK "LP>" 
abee f5				push af  
abef 3a 03 ac			ld a, (.dmark)  
abf2 32 7a ee			ld (debug_mark),a  
abf5 3a 04 ac			ld a, (.dmark+1)  
abf8 32 7b ee			ld (debug_mark+1),a  
abfb 3a 05 ac			ld a, (.dmark+2)  
abfe 32 7c ee			ld (debug_mark+2),a  
ac01 18 03			jr .pastdmark  
ac03 ..			.dmark: db "LP>"  
ac06 f1			.pastdmark: pop af  
ac07			endm  
# End of macro DMARK
ac07				CALLMONITOR 
ac07 cd 7b 91			call break_point_state  
ac0a				endm  
# End of macro CALLMONITOR
ac0a			endif 
ac0a			 
ac0a					NEXTW 
ac0a c3 f9 98			jp macro_next 
ac0d				endm 
# End of macro NEXTW
ac0d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ac0d			 
ac0d			.loopnotdone: 
ac0d			 
ac0d e1				pop hl    ; get I 
ac0e 23				inc hl 
ac0f			 
ac0f			   	; save new I 
ac0f			 
ac0f			 
ac0f					; set I counter 
ac0f			 
ac0f 22 9a e6				ld (os_current_i), hl 
ac12			 
ac12					if DEBUG_FORTH_WORDS 
ac12						DMARK "LPN" 
ac12 f5				push af  
ac13 3a 27 ac			ld a, (.dmark)  
ac16 32 7a ee			ld (debug_mark),a  
ac19 3a 28 ac			ld a, (.dmark+1)  
ac1c 32 7b ee			ld (debug_mark+1),a  
ac1f 3a 29 ac			ld a, (.dmark+2)  
ac22 32 7c ee			ld (debug_mark+2),a  
ac25 18 03			jr .pastdmark  
ac27 ..			.dmark: db "LPN"  
ac2a f1			.pastdmark: pop af  
ac2b			endm  
# End of macro DMARK
ac2b					CALLMONITOR 
ac2b cd 7b 91			call break_point_state  
ac2e				endm  
# End of macro CALLMONITOR
ac2e					endif 
ac2e					 
ac2e				FORTH_LOOP_NEXT 
ac2e cd b8 97			call macro_forth_loop_next 
ac31				endm 
# End of macro FORTH_LOOP_NEXT
ac31			 
ac31			 
ac31					if DEBUG_FORTH_WORDS 
ac31 eb						ex de,hl 
ac32					endif 
ac32			 
ac32			;	; get DO ptr 
ac32			; 
ac32					if DEBUG_FORTH_WORDS 
ac32						DMARK "LP7" 
ac32 f5				push af  
ac33 3a 47 ac			ld a, (.dmark)  
ac36 32 7a ee			ld (debug_mark),a  
ac39 3a 48 ac			ld a, (.dmark+1)  
ac3c 32 7b ee			ld (debug_mark+1),a  
ac3f 3a 49 ac			ld a, (.dmark+2)  
ac42 32 7c ee			ld (debug_mark+2),a  
ac45 18 03			jr .pastdmark  
ac47 ..			.dmark: db "LP7"  
ac4a f1			.pastdmark: pop af  
ac4b			endm  
# End of macro DMARK
ac4b					CALLMONITOR 
ac4b cd 7b 91			call break_point_state  
ac4e				endm  
# End of macro CALLMONITOR
ac4e					endif 
ac4e				FORTH_RSP_TOS 
ac4e cd c6 96			call macro_forth_rsp_tos 
ac51				endm 
# End of macro FORTH_RSP_TOS
ac51			 
ac51					if DEBUG_FORTH_WORDS 
ac51						DMARK "LP8" 
ac51 f5				push af  
ac52 3a 66 ac			ld a, (.dmark)  
ac55 32 7a ee			ld (debug_mark),a  
ac58 3a 67 ac			ld a, (.dmark+1)  
ac5b 32 7b ee			ld (debug_mark+1),a  
ac5e 3a 68 ac			ld a, (.dmark+2)  
ac61 32 7c ee			ld (debug_mark+2),a  
ac64 18 03			jr .pastdmark  
ac66 ..			.dmark: db "LP8"  
ac69 f1			.pastdmark: pop af  
ac6a			endm  
# End of macro DMARK
ac6a					CALLMONITOR 
ac6a cd 7b 91			call break_point_state  
ac6d				endm  
# End of macro CALLMONITOR
ac6d					endif 
ac6d				;push hl 
ac6d			 
ac6d				; not going to DO any more 
ac6d				; get rid of the RSP pointer as DO will add it back in 
ac6d				;FORTH_RSP_POP 
ac6d				;pop hl 
ac6d			 
ac6d				;ld hl,(cli_ret_sp) 
ac6d				;ld e, (hl) 
ac6d				;inc hl 
ac6d				;ld d, (hl) 
ac6d				;ex de,hl 
ac6d 22 76 e6			ld (os_tok_ptr), hl 
ac70					if DEBUG_FORTH_WORDS 
ac70						DMARK "LP<" 
ac70 f5				push af  
ac71 3a 85 ac			ld a, (.dmark)  
ac74 32 7a ee			ld (debug_mark),a  
ac77 3a 86 ac			ld a, (.dmark+1)  
ac7a 32 7b ee			ld (debug_mark+1),a  
ac7d 3a 87 ac			ld a, (.dmark+2)  
ac80 32 7c ee			ld (debug_mark+2),a  
ac83 18 03			jr .pastdmark  
ac85 ..			.dmark: db "LP<"  
ac88 f1			.pastdmark: pop af  
ac89			endm  
# End of macro DMARK
ac89					CALLMONITOR 
ac89 cd 7b 91			call break_point_state  
ac8c				endm  
# End of macro CALLMONITOR
ac8c				endif 
ac8c c3 8a 99			jp exec1 
ac8f			 
ac8f					 
ac8f			 
ac8f			 
ac8f					NEXTW 
ac8f c3 f9 98			jp macro_next 
ac92				endm 
# End of macro NEXTW
ac92			.I:  
ac92			 
ac92				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ac92 5e				db WORD_SYS_CORE+74             
ac93 bd ac			dw .DLOOP            
ac95 02				db 1 + 1 
ac96 .. 00			db "I",0              
ac98				endm 
# End of macro CWHEAD
ac98			; | I ( -- ) Current loop counter | DONE 
ac98					if DEBUG_FORTH_WORDS_KEY 
ac98						DMARK "I.." 
ac98 f5				push af  
ac99 3a ad ac			ld a, (.dmark)  
ac9c 32 7a ee			ld (debug_mark),a  
ac9f 3a ae ac			ld a, (.dmark+1)  
aca2 32 7b ee			ld (debug_mark+1),a  
aca5 3a af ac			ld a, (.dmark+2)  
aca8 32 7c ee			ld (debug_mark+2),a  
acab 18 03			jr .pastdmark  
acad ..			.dmark: db "I.."  
acb0 f1			.pastdmark: pop af  
acb1			endm  
# End of macro DMARK
acb1						CALLMONITOR 
acb1 cd 7b 91			call break_point_state  
acb4				endm  
# End of macro CALLMONITOR
acb4					endif 
acb4			 
acb4 2a 9a e6				ld hl,(os_current_i) 
acb7 cd 08 97				call forth_push_numhl 
acba			 
acba					NEXTW 
acba c3 f9 98			jp macro_next 
acbd				endm 
# End of macro NEXTW
acbd			.DLOOP: 
acbd				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
acbd 5f				db WORD_SYS_CORE+75             
acbe 9e ad			dw .REPEAT            
acc0 06				db 5 + 1 
acc1 .. 00			db "-LOOP",0              
acc7				endm 
# End of macro CWHEAD
acc7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
acc7				; pop tos as current loop count to hl 
acc7					if DEBUG_FORTH_WORDS_KEY 
acc7						DMARK "-LP" 
acc7 f5				push af  
acc8 3a dc ac			ld a, (.dmark)  
accb 32 7a ee			ld (debug_mark),a  
acce 3a dd ac			ld a, (.dmark+1)  
acd1 32 7b ee			ld (debug_mark+1),a  
acd4 3a de ac			ld a, (.dmark+2)  
acd7 32 7c ee			ld (debug_mark+2),a  
acda 18 03			jr .pastdmark  
acdc ..			.dmark: db "-LP"  
acdf f1			.pastdmark: pop af  
ace0			endm  
# End of macro DMARK
ace0						CALLMONITOR 
ace0 cd 7b 91			call break_point_state  
ace3				endm  
# End of macro CALLMONITOR
ace3					endif 
ace3			 
ace3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ace3			 
ace3				FORTH_LOOP_TOS 
ace3 cd eb 97			call macro_forth_loop_tos 
ace6				endm 
# End of macro FORTH_LOOP_TOS
ace6 e5				push hl 
ace7			 
ace7					if DEBUG_FORTH_WORDS 
ace7						DMARK "-LP" 
ace7 f5				push af  
ace8 3a fc ac			ld a, (.dmark)  
aceb 32 7a ee			ld (debug_mark),a  
acee 3a fd ac			ld a, (.dmark+1)  
acf1 32 7b ee			ld (debug_mark+1),a  
acf4 3a fe ac			ld a, (.dmark+2)  
acf7 32 7c ee			ld (debug_mark+2),a  
acfa 18 03			jr .pastdmark  
acfc ..			.dmark: db "-LP"  
acff f1			.pastdmark: pop af  
ad00			endm  
# End of macro DMARK
ad00						CALLMONITOR 
ad00 cd 7b 91			call break_point_state  
ad03				endm  
# End of macro CALLMONITOR
ad03					endif 
ad03				; next item on the stack is the limit. get it 
ad03			 
ad03			 
ad03				FORTH_LOOP_POP 
ad03 cd f5 97			call macro_forth_loop_pop 
ad06				endm 
# End of macro FORTH_LOOP_POP
ad06			 
ad06				FORTH_LOOP_TOS 
ad06 cd eb 97			call macro_forth_loop_tos 
ad09				endm 
# End of macro FORTH_LOOP_TOS
ad09			 
ad09 d1				pop de		 ; de = i, hl = limit 
ad0a			 
ad0a					if DEBUG_FORTH_WORDS 
ad0a						DMARK "-L1" 
ad0a f5				push af  
ad0b 3a 1f ad			ld a, (.dmark)  
ad0e 32 7a ee			ld (debug_mark),a  
ad11 3a 20 ad			ld a, (.dmark+1)  
ad14 32 7b ee			ld (debug_mark+1),a  
ad17 3a 21 ad			ld a, (.dmark+2)  
ad1a 32 7c ee			ld (debug_mark+2),a  
ad1d 18 03			jr .pastdmark  
ad1f ..			.dmark: db "-L1"  
ad22 f1			.pastdmark: pop af  
ad23			endm  
# End of macro DMARK
ad23						CALLMONITOR 
ad23 cd 7b 91			call break_point_state  
ad26				endm  
# End of macro CALLMONITOR
ad26					endif 
ad26			 
ad26				; go back to previous word 
ad26			 
ad26 d5				push de    ; save I for inc later 
ad27			 
ad27			 
ad27				; get limit 
ad27				;  is I at limit? 
ad27			 
ad27			 
ad27					if DEBUG_FORTH_WORDS 
ad27						DMARK "-L1" 
ad27 f5				push af  
ad28 3a 3c ad			ld a, (.dmark)  
ad2b 32 7a ee			ld (debug_mark),a  
ad2e 3a 3d ad			ld a, (.dmark+1)  
ad31 32 7b ee			ld (debug_mark+1),a  
ad34 3a 3e ad			ld a, (.dmark+2)  
ad37 32 7c ee			ld (debug_mark+2),a  
ad3a 18 03			jr .pastdmark  
ad3c ..			.dmark: db "-L1"  
ad3f f1			.pastdmark: pop af  
ad40			endm  
# End of macro DMARK
ad40						CALLMONITOR 
ad40 cd 7b 91			call break_point_state  
ad43				endm  
# End of macro CALLMONITOR
ad43					endif 
ad43			 
ad43 ed 52			sbc hl, de 
ad45			 
ad45			 
ad45				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ad45			 
ad45 20 26				jr nz, .mloopnotdone 
ad47			 
ad47 e1				pop hl   ; get rid of saved I 
ad48				FORTH_LOOP_POP     ; get rid of limit 
ad48 cd f5 97			call macro_forth_loop_pop 
ad4b				endm 
# End of macro FORTH_LOOP_POP
ad4b			 
ad4b				FORTH_RSP_POP     ; get rid of DO ptr 
ad4b cd d0 96			call macro_forth_rsp_pop 
ad4e				endm 
# End of macro FORTH_RSP_POP
ad4e			 
ad4e			if DEBUG_FORTH_WORDS 
ad4e						DMARK "-L>" 
ad4e f5				push af  
ad4f 3a 63 ad			ld a, (.dmark)  
ad52 32 7a ee			ld (debug_mark),a  
ad55 3a 64 ad			ld a, (.dmark+1)  
ad58 32 7b ee			ld (debug_mark+1),a  
ad5b 3a 65 ad			ld a, (.dmark+2)  
ad5e 32 7c ee			ld (debug_mark+2),a  
ad61 18 03			jr .pastdmark  
ad63 ..			.dmark: db "-L>"  
ad66 f1			.pastdmark: pop af  
ad67			endm  
# End of macro DMARK
ad67				CALLMONITOR 
ad67 cd 7b 91			call break_point_state  
ad6a				endm  
# End of macro CALLMONITOR
ad6a			endif 
ad6a			 
ad6a					NEXTW 
ad6a c3 f9 98			jp macro_next 
ad6d				endm 
# End of macro NEXTW
ad6d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ad6d			 
ad6d			.mloopnotdone: 
ad6d			 
ad6d e1				pop hl    ; get I 
ad6e 2b				dec hl 
ad6f			 
ad6f			   	; save new I 
ad6f			 
ad6f			 
ad6f					; set I counter 
ad6f			 
ad6f 22 9a e6				ld (os_current_i), hl 
ad72			 
ad72					 
ad72				FORTH_LOOP_NEXT 
ad72 cd b8 97			call macro_forth_loop_next 
ad75				endm 
# End of macro FORTH_LOOP_NEXT
ad75			 
ad75			 
ad75					if DEBUG_FORTH_WORDS 
ad75 eb						ex de,hl 
ad76					endif 
ad76			 
ad76			;	; get DO ptr 
ad76			; 
ad76				FORTH_RSP_TOS 
ad76 cd c6 96			call macro_forth_rsp_tos 
ad79				endm 
# End of macro FORTH_RSP_TOS
ad79			 
ad79				;push hl 
ad79			 
ad79				; not going to DO any more 
ad79				; get rid of the RSP pointer as DO will add it back in 
ad79				;FORTH_RSP_POP 
ad79				;pop hl 
ad79			 
ad79			 
ad79 22 76 e6			ld (os_tok_ptr), hl 
ad7c					if DEBUG_FORTH_WORDS 
ad7c						DMARK "-L<" 
ad7c f5				push af  
ad7d 3a 91 ad			ld a, (.dmark)  
ad80 32 7a ee			ld (debug_mark),a  
ad83 3a 92 ad			ld a, (.dmark+1)  
ad86 32 7b ee			ld (debug_mark+1),a  
ad89 3a 93 ad			ld a, (.dmark+2)  
ad8c 32 7c ee			ld (debug_mark+2),a  
ad8f 18 03			jr .pastdmark  
ad91 ..			.dmark: db "-L<"  
ad94 f1			.pastdmark: pop af  
ad95			endm  
# End of macro DMARK
ad95					CALLMONITOR 
ad95 cd 7b 91			call break_point_state  
ad98				endm  
# End of macro CALLMONITOR
ad98				endif 
ad98 c3 8a 99			jp exec1 
ad9b			 
ad9b					 
ad9b			 
ad9b			 
ad9b			 
ad9b				NEXTW 
ad9b c3 f9 98			jp macro_next 
ad9e				endm 
# End of macro NEXTW
ad9e			 
ad9e			 
ad9e			 
ad9e			 
ad9e			.REPEAT: 
ad9e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
ad9e 71				db WORD_SYS_CORE+93             
ad9f f1 ad			dw .UNTIL            
ada1 06				db 5 + 1 
ada2 .. 00			db "REPEAT",0              
ada9				endm 
# End of macro CWHEAD
ada9			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
ada9			;  push pc to rsp stack past the REPEAT 
ada9					if DEBUG_FORTH_WORDS_KEY 
ada9						DMARK "REP" 
ada9 f5				push af  
adaa 3a be ad			ld a, (.dmark)  
adad 32 7a ee			ld (debug_mark),a  
adb0 3a bf ad			ld a, (.dmark+1)  
adb3 32 7b ee			ld (debug_mark+1),a  
adb6 3a c0 ad			ld a, (.dmark+2)  
adb9 32 7c ee			ld (debug_mark+2),a  
adbc 18 03			jr .pastdmark  
adbe ..			.dmark: db "REP"  
adc1 f1			.pastdmark: pop af  
adc2			endm  
# End of macro DMARK
adc2						CALLMONITOR 
adc2 cd 7b 91			call break_point_state  
adc5				endm  
# End of macro CALLMONITOR
adc5					endif 
adc5			 
adc5 2a 76 e6				ld hl, (os_tok_ptr) 
adc8 23					inc hl   ; R 
adc9 23					inc hl  ; E 
adca 23					inc hl   ; P 
adcb 23					inc hl   ; E 
adcc 23					inc hl   ; A 
adcd 23					inc hl   ; T 
adce 23					inc hl   ; zero 
adcf					FORTH_RSP_NEXT 
adcf cd af 96			call macro_forth_rsp_next 
add2				endm 
# End of macro FORTH_RSP_NEXT
add2			 
add2			 
add2					if DEBUG_FORTH_WORDS 
add2						DMARK "REP" 
add2 f5				push af  
add3 3a e7 ad			ld a, (.dmark)  
add6 32 7a ee			ld (debug_mark),a  
add9 3a e8 ad			ld a, (.dmark+1)  
addc 32 7b ee			ld (debug_mark+1),a  
addf 3a e9 ad			ld a, (.dmark+2)  
ade2 32 7c ee			ld (debug_mark+2),a  
ade5 18 03			jr .pastdmark  
ade7 ..			.dmark: db "REP"  
adea f1			.pastdmark: pop af  
adeb			endm  
# End of macro DMARK
adeb						;pop bc    ; TODO BUG ?????? what is this for???? 
adeb						CALLMONITOR 
adeb cd 7b 91			call break_point_state  
adee				endm  
# End of macro CALLMONITOR
adee					endif 
adee			 
adee					NEXTW 
adee c3 f9 98			jp macro_next 
adf1				endm 
# End of macro NEXTW
adf1			;	       NEXTW 
adf1			 
adf1			.UNTIL: 
adf1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
adf1 72				db WORD_SYS_CORE+94             
adf2 88 ae			dw .ENDFLOW            
adf4 06				db 5 + 1 
adf5 .. 00			db "UNTIL",0              
adfb				endm 
# End of macro CWHEAD
adfb			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
adfb			 
adfb				; pop tos as check 
adfb			 
adfb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
adfb			 
adfb				FORTH_DSP_VALUEHL 
adfb cd a3 97			call macro_dsp_valuehl 
adfe				endm 
# End of macro FORTH_DSP_VALUEHL
adfe			 
adfe					if DEBUG_FORTH_WORDS_KEY 
adfe						DMARK "UNT" 
adfe f5				push af  
adff 3a 13 ae			ld a, (.dmark)  
ae02 32 7a ee			ld (debug_mark),a  
ae05 3a 14 ae			ld a, (.dmark+1)  
ae08 32 7b ee			ld (debug_mark+1),a  
ae0b 3a 15 ae			ld a, (.dmark+2)  
ae0e 32 7c ee			ld (debug_mark+2),a  
ae11 18 03			jr .pastdmark  
ae13 ..			.dmark: db "UNT"  
ae16 f1			.pastdmark: pop af  
ae17			endm  
# End of macro DMARK
ae17						CALLMONITOR 
ae17 cd 7b 91			call break_point_state  
ae1a				endm  
# End of macro CALLMONITOR
ae1a					endif 
ae1a			 
ae1a			;	push hl 
ae1a				FORTH_DSP_POP 
ae1a cd 3f 98			call macro_forth_dsp_pop 
ae1d				endm 
# End of macro FORTH_DSP_POP
ae1d			 
ae1d			;	pop hl 
ae1d			 
ae1d				; test if true 
ae1d			 
ae1d cd e0 89			call ishlzero 
ae20			;	ld a,l 
ae20			;	add h 
ae20			; 
ae20			;	cp 0 
ae20			 
ae20 20 3e			jr nz, .untilnotdone 
ae22			 
ae22					if DEBUG_FORTH_WORDS 
ae22						DMARK "UNf" 
ae22 f5				push af  
ae23 3a 37 ae			ld a, (.dmark)  
ae26 32 7a ee			ld (debug_mark),a  
ae29 3a 38 ae			ld a, (.dmark+1)  
ae2c 32 7b ee			ld (debug_mark+1),a  
ae2f 3a 39 ae			ld a, (.dmark+2)  
ae32 32 7c ee			ld (debug_mark+2),a  
ae35 18 03			jr .pastdmark  
ae37 ..			.dmark: db "UNf"  
ae3a f1			.pastdmark: pop af  
ae3b			endm  
# End of macro DMARK
ae3b						CALLMONITOR 
ae3b cd 7b 91			call break_point_state  
ae3e				endm  
# End of macro CALLMONITOR
ae3e					endif 
ae3e			 
ae3e			 
ae3e			 
ae3e				FORTH_RSP_POP     ; get rid of DO ptr 
ae3e cd d0 96			call macro_forth_rsp_pop 
ae41				endm 
# End of macro FORTH_RSP_POP
ae41			 
ae41			if DEBUG_FORTH_WORDS 
ae41						DMARK "UN>" 
ae41 f5				push af  
ae42 3a 56 ae			ld a, (.dmark)  
ae45 32 7a ee			ld (debug_mark),a  
ae48 3a 57 ae			ld a, (.dmark+1)  
ae4b 32 7b ee			ld (debug_mark+1),a  
ae4e 3a 58 ae			ld a, (.dmark+2)  
ae51 32 7c ee			ld (debug_mark+2),a  
ae54 18 03			jr .pastdmark  
ae56 ..			.dmark: db "UN>"  
ae59 f1			.pastdmark: pop af  
ae5a			endm  
# End of macro DMARK
ae5a				CALLMONITOR 
ae5a cd 7b 91			call break_point_state  
ae5d				endm  
# End of macro CALLMONITOR
ae5d			endif 
ae5d			 
ae5d					NEXTW 
ae5d c3 f9 98			jp macro_next 
ae60				endm 
# End of macro NEXTW
ae60				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae60			 
ae60			.untilnotdone: 
ae60			 
ae60			 
ae60			;	; get DO ptr 
ae60			; 
ae60				FORTH_RSP_TOS 
ae60 cd c6 96			call macro_forth_rsp_tos 
ae63				endm 
# End of macro FORTH_RSP_TOS
ae63			 
ae63				;push hl 
ae63			 
ae63				; not going to DO any more 
ae63				; get rid of the RSP pointer as DO will add it back in 
ae63				;FORTH_RSP_POP 
ae63				;pop hl 
ae63			 
ae63			 
ae63 22 76 e6			ld (os_tok_ptr), hl 
ae66					if DEBUG_FORTH_WORDS 
ae66						DMARK "UN<" 
ae66 f5				push af  
ae67 3a 7b ae			ld a, (.dmark)  
ae6a 32 7a ee			ld (debug_mark),a  
ae6d 3a 7c ae			ld a, (.dmark+1)  
ae70 32 7b ee			ld (debug_mark+1),a  
ae73 3a 7d ae			ld a, (.dmark+2)  
ae76 32 7c ee			ld (debug_mark+2),a  
ae79 18 03			jr .pastdmark  
ae7b ..			.dmark: db "UN<"  
ae7e f1			.pastdmark: pop af  
ae7f			endm  
# End of macro DMARK
ae7f					CALLMONITOR 
ae7f cd 7b 91			call break_point_state  
ae82				endm  
# End of macro CALLMONITOR
ae82				endif 
ae82 c3 8a 99			jp exec1 
ae85			 
ae85					 
ae85			 
ae85			 
ae85					NEXTW 
ae85 c3 f9 98			jp macro_next 
ae88				endm 
# End of macro NEXTW
ae88			 
ae88			 
ae88			.ENDFLOW: 
ae88			 
ae88			; eof 
ae88			 
# End of file forth_words_flow.asm
ae88			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
ae88			include "forth_words_logic.asm" 
ae88			 
ae88			; | ## Logic Words 
ae88			 
ae88			.NOT: 
ae88				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
ae88 2d				db WORD_SYS_CORE+25             
ae89 d0 ae			dw .IS            
ae8b 04				db 3 + 1 
ae8c .. 00			db "NOT",0              
ae90				endm 
# End of macro CWHEAD
ae90			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
ae90					if DEBUG_FORTH_WORDS_KEY 
ae90						DMARK "NOT" 
ae90 f5				push af  
ae91 3a a5 ae			ld a, (.dmark)  
ae94 32 7a ee			ld (debug_mark),a  
ae97 3a a6 ae			ld a, (.dmark+1)  
ae9a 32 7b ee			ld (debug_mark+1),a  
ae9d 3a a7 ae			ld a, (.dmark+2)  
aea0 32 7c ee			ld (debug_mark+2),a  
aea3 18 03			jr .pastdmark  
aea5 ..			.dmark: db "NOT"  
aea8 f1			.pastdmark: pop af  
aea9			endm  
# End of macro DMARK
aea9						CALLMONITOR 
aea9 cd 7b 91			call break_point_state  
aeac				endm  
# End of macro CALLMONITOR
aeac					endif 
aeac					FORTH_DSP 
aeac cd 88 97			call macro_forth_dsp 
aeaf				endm 
# End of macro FORTH_DSP
aeaf 7e					ld a,(hl)	; get type of value on TOS 
aeb0 fe 02				cp DS_TYPE_INUM  
aeb2 28 03				jr z, .noti 
aeb4					NEXTW 
aeb4 c3 f9 98			jp macro_next 
aeb7				endm 
# End of macro NEXTW
aeb7			.noti:          FORTH_DSP_VALUEHL 
aeb7 cd a3 97			call macro_dsp_valuehl 
aeba				endm 
# End of macro FORTH_DSP_VALUEHL
aeba			;		push hl 
aeba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aeba cd 3f 98			call macro_forth_dsp_pop 
aebd				endm 
# End of macro FORTH_DSP_POP
aebd			;		pop hl 
aebd 3e 00				ld a,0 
aebf bd					cp l 
aec0 28 04				jr z, .not2t 
aec2 2e 00				ld l, 0 
aec4 18 02				jr .notip 
aec6			 
aec6 2e ff		.not2t:		ld l, 255 
aec8			 
aec8 26 00		.notip:		ld h, 0	 
aeca			 
aeca cd 08 97				call forth_push_numhl 
aecd					NEXTW 
aecd c3 f9 98			jp macro_next 
aed0				endm 
# End of macro NEXTW
aed0			 
aed0			.IS: 
aed0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
aed0 2d				db WORD_SYS_CORE+25             
aed1 f6 ae			dw .LZERO            
aed3 03				db 2 + 1 
aed4 .. 00			db "IS",0              
aed7				endm 
# End of macro CWHEAD
aed7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
aed7					if DEBUG_FORTH_WORDS_KEY 
aed7						DMARK "IS." 
aed7 f5				push af  
aed8 3a ec ae			ld a, (.dmark)  
aedb 32 7a ee			ld (debug_mark),a  
aede 3a ed ae			ld a, (.dmark+1)  
aee1 32 7b ee			ld (debug_mark+1),a  
aee4 3a ee ae			ld a, (.dmark+2)  
aee7 32 7c ee			ld (debug_mark+2),a  
aeea 18 03			jr .pastdmark  
aeec ..			.dmark: db "IS."  
aeef f1			.pastdmark: pop af  
aef0			endm  
# End of macro DMARK
aef0						CALLMONITOR 
aef0 cd 7b 91			call break_point_state  
aef3				endm  
# End of macro CALLMONITOR
aef3					endif 
aef3					NEXTW 
aef3 c3 f9 98			jp macro_next 
aef6				endm 
# End of macro NEXTW
aef6			.LZERO: 
aef6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
aef6 2d				db WORD_SYS_CORE+25             
aef7 00 af			dw .TZERO            
aef9 03				db 2 + 1 
aefa .. 00			db "0<",0              
aefd				endm 
# End of macro CWHEAD
aefd			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
aefd					NEXTW 
aefd c3 f9 98			jp macro_next 
af00				endm 
# End of macro NEXTW
af00			.TZERO: 
af00				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
af00 2e				db WORD_SYS_CORE+26             
af01 47 af			dw .LESS            
af03 03				db 2 + 1 
af04 .. 00			db "0=",0              
af07				endm 
# End of macro CWHEAD
af07			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
af07				; TODO add floating point number detection 
af07					;v5 FORTH_DSP_VALUE 
af07					if DEBUG_FORTH_WORDS_KEY 
af07						DMARK "0=." 
af07 f5				push af  
af08 3a 1c af			ld a, (.dmark)  
af0b 32 7a ee			ld (debug_mark),a  
af0e 3a 1d af			ld a, (.dmark+1)  
af11 32 7b ee			ld (debug_mark+1),a  
af14 3a 1e af			ld a, (.dmark+2)  
af17 32 7c ee			ld (debug_mark+2),a  
af1a 18 03			jr .pastdmark  
af1c ..			.dmark: db "0=."  
af1f f1			.pastdmark: pop af  
af20			endm  
# End of macro DMARK
af20						CALLMONITOR 
af20 cd 7b 91			call break_point_state  
af23				endm  
# End of macro CALLMONITOR
af23					endif 
af23					FORTH_DSP 
af23 cd 88 97			call macro_forth_dsp 
af26				endm 
# End of macro FORTH_DSP
af26 7e					ld a,(hl)	; get type of value on TOS 
af27 fe 02				cp DS_TYPE_INUM  
af29 28 00				jr z, .tz_inum 
af2b			 
af2b				if FORTH_ENABLE_FLOATMATH 
af2b					jr .tz_done 
af2b			 
af2b				endif 
af2b					 
af2b			 
af2b			.tz_inum: 
af2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af2b cd a3 97			call macro_dsp_valuehl 
af2e				endm 
# End of macro FORTH_DSP_VALUEHL
af2e			 
af2e			;		push hl 
af2e			 
af2e					; destroy value TOS 
af2e			 
af2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af2e cd 3f 98			call macro_forth_dsp_pop 
af31				endm 
# End of macro FORTH_DSP_POP
af31			 
af31			;		pop hl 
af31			 
af31 3e 00				ld a,0 
af33			 
af33 bd					cp l 
af34 20 08				jr nz, .tz_notzero 
af36			 
af36 bc					cp h 
af37			 
af37 20 05				jr nz, .tz_notzero 
af39			 
af39			 
af39 21 01 00				ld hl, FORTH_TRUE 
af3c 18 03				jr .tz_done 
af3e			 
af3e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
af41			 
af41					; push value back onto stack for another op etc 
af41			 
af41			.tz_done: 
af41 cd 08 97				call forth_push_numhl 
af44			 
af44					NEXTW 
af44 c3 f9 98			jp macro_next 
af47				endm 
# End of macro NEXTW
af47			.LESS: 
af47				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
af47 2f				db WORD_SYS_CORE+27             
af48 b0 af			dw .GT            
af4a 02				db 1 + 1 
af4b .. 00			db "<",0              
af4d				endm 
# End of macro CWHEAD
af4d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
af4d				; TODO add floating point number detection 
af4d					if DEBUG_FORTH_WORDS_KEY 
af4d						DMARK "LES" 
af4d f5				push af  
af4e 3a 62 af			ld a, (.dmark)  
af51 32 7a ee			ld (debug_mark),a  
af54 3a 63 af			ld a, (.dmark+1)  
af57 32 7b ee			ld (debug_mark+1),a  
af5a 3a 64 af			ld a, (.dmark+2)  
af5d 32 7c ee			ld (debug_mark+2),a  
af60 18 03			jr .pastdmark  
af62 ..			.dmark: db "LES"  
af65 f1			.pastdmark: pop af  
af66			endm  
# End of macro DMARK
af66						CALLMONITOR 
af66 cd 7b 91			call break_point_state  
af69				endm  
# End of macro CALLMONITOR
af69					endif 
af69					FORTH_DSP 
af69 cd 88 97			call macro_forth_dsp 
af6c				endm 
# End of macro FORTH_DSP
af6c					;v5 FORTH_DSP_VALUE 
af6c 7e					ld a,(hl)	; get type of value on TOS 
af6d fe 02				cp DS_TYPE_INUM  
af6f 28 00				jr z, .less_inum 
af71			 
af71				if FORTH_ENABLE_FLOATMATH 
af71					jr .less_done 
af71			 
af71				endif 
af71					 
af71			 
af71			.less_inum: 
af71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af71 cd a3 97			call macro_dsp_valuehl 
af74				endm 
# End of macro FORTH_DSP_VALUEHL
af74			 
af74 e5					push hl  ; u2 
af75			 
af75					; destroy value TOS 
af75			 
af75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af75 cd 3f 98			call macro_forth_dsp_pop 
af78				endm 
# End of macro FORTH_DSP_POP
af78			 
af78			 
af78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
af78 cd a3 97			call macro_dsp_valuehl 
af7b				endm 
# End of macro FORTH_DSP_VALUEHL
af7b			 
af7b e5					push hl    ; u1 
af7c			 
af7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
af7c cd 3f 98			call macro_forth_dsp_pop 
af7f				endm 
# End of macro FORTH_DSP_POP
af7f			 
af7f			 
af7f b7			 or a      ;clear carry flag 
af80 01 00 00		 ld bc, FORTH_FALSE 
af83 e1			  pop hl    ; u1 
af84 d1			  pop de    ; u2 
af85 ed 52		  sbc hl,de 
af87 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
af89			 
af89 01 01 00		 ld bc, FORTH_TRUE 
af8c			.lscont:  
af8c c5					push bc 
af8d e1					pop hl 
af8e			 
af8e					if DEBUG_FORTH_WORDS 
af8e						DMARK "LT1" 
af8e f5				push af  
af8f 3a a3 af			ld a, (.dmark)  
af92 32 7a ee			ld (debug_mark),a  
af95 3a a4 af			ld a, (.dmark+1)  
af98 32 7b ee			ld (debug_mark+1),a  
af9b 3a a5 af			ld a, (.dmark+2)  
af9e 32 7c ee			ld (debug_mark+2),a  
afa1 18 03			jr .pastdmark  
afa3 ..			.dmark: db "LT1"  
afa6 f1			.pastdmark: pop af  
afa7			endm  
# End of macro DMARK
afa7						CALLMONITOR 
afa7 cd 7b 91			call break_point_state  
afaa				endm  
# End of macro CALLMONITOR
afaa					endif 
afaa cd 08 97				call forth_push_numhl 
afad			 
afad					NEXTW 
afad c3 f9 98			jp macro_next 
afb0				endm 
# End of macro NEXTW
afb0			.GT: 
afb0				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
afb0 30				db WORD_SYS_CORE+28             
afb1 19 b0			dw .EQUAL            
afb3 02				db 1 + 1 
afb4 .. 00			db ">",0              
afb6				endm 
# End of macro CWHEAD
afb6			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
afb6				; TODO add floating point number detection 
afb6					if DEBUG_FORTH_WORDS_KEY 
afb6						DMARK "GRT" 
afb6 f5				push af  
afb7 3a cb af			ld a, (.dmark)  
afba 32 7a ee			ld (debug_mark),a  
afbd 3a cc af			ld a, (.dmark+1)  
afc0 32 7b ee			ld (debug_mark+1),a  
afc3 3a cd af			ld a, (.dmark+2)  
afc6 32 7c ee			ld (debug_mark+2),a  
afc9 18 03			jr .pastdmark  
afcb ..			.dmark: db "GRT"  
afce f1			.pastdmark: pop af  
afcf			endm  
# End of macro DMARK
afcf						CALLMONITOR 
afcf cd 7b 91			call break_point_state  
afd2				endm  
# End of macro CALLMONITOR
afd2					endif 
afd2					FORTH_DSP 
afd2 cd 88 97			call macro_forth_dsp 
afd5				endm 
# End of macro FORTH_DSP
afd5					;FORTH_DSP_VALUE 
afd5 7e					ld a,(hl)	; get type of value on TOS 
afd6 fe 02				cp DS_TYPE_INUM  
afd8 28 00				jr z, .gt_inum 
afda			 
afda				if FORTH_ENABLE_FLOATMATH 
afda					jr .gt_done 
afda			 
afda				endif 
afda					 
afda			 
afda			.gt_inum: 
afda					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
afda cd a3 97			call macro_dsp_valuehl 
afdd				endm 
# End of macro FORTH_DSP_VALUEHL
afdd			 
afdd e5					push hl  ; u2 
afde			 
afde					; destroy value TOS 
afde			 
afde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
afde cd 3f 98			call macro_forth_dsp_pop 
afe1				endm 
# End of macro FORTH_DSP_POP
afe1			 
afe1			 
afe1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
afe1 cd a3 97			call macro_dsp_valuehl 
afe4				endm 
# End of macro FORTH_DSP_VALUEHL
afe4			 
afe4 e5					push hl    ; u1 
afe5			 
afe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
afe5 cd 3f 98			call macro_forth_dsp_pop 
afe8				endm 
# End of macro FORTH_DSP_POP
afe8			 
afe8			 
afe8 b7			 or a      ;clear carry flag 
afe9 01 00 00		 ld bc, FORTH_FALSE 
afec e1			  pop hl    ; u1 
afed d1			  pop de    ; u2 
afee ed 52		  sbc hl,de 
aff0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
aff2			 
aff2 01 01 00		 ld bc, FORTH_TRUE 
aff5			.gtcont:  
aff5 c5					push bc 
aff6 e1					pop hl 
aff7			 
aff7					if DEBUG_FORTH_WORDS 
aff7						DMARK "GT1" 
aff7 f5				push af  
aff8 3a 0c b0			ld a, (.dmark)  
affb 32 7a ee			ld (debug_mark),a  
affe 3a 0d b0			ld a, (.dmark+1)  
b001 32 7b ee			ld (debug_mark+1),a  
b004 3a 0e b0			ld a, (.dmark+2)  
b007 32 7c ee			ld (debug_mark+2),a  
b00a 18 03			jr .pastdmark  
b00c ..			.dmark: db "GT1"  
b00f f1			.pastdmark: pop af  
b010			endm  
# End of macro DMARK
b010						CALLMONITOR 
b010 cd 7b 91			call break_point_state  
b013				endm  
# End of macro CALLMONITOR
b013					endif 
b013 cd 08 97				call forth_push_numhl 
b016			 
b016					NEXTW 
b016 c3 f9 98			jp macro_next 
b019				endm 
# End of macro NEXTW
b019			.EQUAL: 
b019				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b019 31				db WORD_SYS_CORE+29             
b01a 84 b0			dw .ENDLOGIC            
b01c 02				db 1 + 1 
b01d .. 00			db "=",0              
b01f				endm 
# End of macro CWHEAD
b01f			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b01f				; TODO add floating point number detection 
b01f					if DEBUG_FORTH_WORDS_KEY 
b01f						DMARK "EQ." 
b01f f5				push af  
b020 3a 34 b0			ld a, (.dmark)  
b023 32 7a ee			ld (debug_mark),a  
b026 3a 35 b0			ld a, (.dmark+1)  
b029 32 7b ee			ld (debug_mark+1),a  
b02c 3a 36 b0			ld a, (.dmark+2)  
b02f 32 7c ee			ld (debug_mark+2),a  
b032 18 03			jr .pastdmark  
b034 ..			.dmark: db "EQ."  
b037 f1			.pastdmark: pop af  
b038			endm  
# End of macro DMARK
b038						CALLMONITOR 
b038 cd 7b 91			call break_point_state  
b03b				endm  
# End of macro CALLMONITOR
b03b					endif 
b03b					FORTH_DSP 
b03b cd 88 97			call macro_forth_dsp 
b03e				endm 
# End of macro FORTH_DSP
b03e					;v5 FORTH_DSP_VALUE 
b03e 7e					ld a,(hl)	; get type of value on TOS 
b03f fe 02				cp DS_TYPE_INUM  
b041 28 00				jr z, .eq_inum 
b043			 
b043				if FORTH_ENABLE_FLOATMATH 
b043					jr .eq_done 
b043			 
b043				endif 
b043					 
b043			 
b043			.eq_inum: 
b043					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b043 cd a3 97			call macro_dsp_valuehl 
b046				endm 
# End of macro FORTH_DSP_VALUEHL
b046			 
b046 e5					push hl 
b047			 
b047					; destroy value TOS 
b047			 
b047					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b047 cd 3f 98			call macro_forth_dsp_pop 
b04a				endm 
# End of macro FORTH_DSP_POP
b04a			 
b04a			 
b04a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b04a cd a3 97			call macro_dsp_valuehl 
b04d				endm 
# End of macro FORTH_DSP_VALUEHL
b04d			 
b04d					; one value on hl get other one back 
b04d			 
b04d e5					push hl 
b04e			 
b04e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b04e cd 3f 98			call macro_forth_dsp_pop 
b051				endm 
# End of macro FORTH_DSP_POP
b051			 
b051 0e 00				ld c, FORTH_FALSE 
b053			 
b053 e1					pop hl 
b054 d1					pop de 
b055			 
b055 7b					ld a, e 
b056 bd					cp l 
b057			 
b057 20 06				jr nz, .eq_done 
b059			 
b059 7a					ld a, d 
b05a bc					cp h 
b05b			 
b05b 20 02				jr nz, .eq_done 
b05d			 
b05d 0e 01				ld c, FORTH_TRUE 
b05f					 
b05f			 
b05f			 
b05f			.eq_done: 
b05f			 
b05f					; TODO push value back onto stack for another op etc 
b05f			 
b05f 26 00				ld h, 0 
b061 69					ld l, c 
b062					if DEBUG_FORTH_WORDS 
b062						DMARK "EQ1" 
b062 f5				push af  
b063 3a 77 b0			ld a, (.dmark)  
b066 32 7a ee			ld (debug_mark),a  
b069 3a 78 b0			ld a, (.dmark+1)  
b06c 32 7b ee			ld (debug_mark+1),a  
b06f 3a 79 b0			ld a, (.dmark+2)  
b072 32 7c ee			ld (debug_mark+2),a  
b075 18 03			jr .pastdmark  
b077 ..			.dmark: db "EQ1"  
b07a f1			.pastdmark: pop af  
b07b			endm  
# End of macro DMARK
b07b						CALLMONITOR 
b07b cd 7b 91			call break_point_state  
b07e				endm  
# End of macro CALLMONITOR
b07e					endif 
b07e cd 08 97				call forth_push_numhl 
b081			 
b081					NEXTW 
b081 c3 f9 98			jp macro_next 
b084				endm 
# End of macro NEXTW
b084			 
b084			 
b084			.ENDLOGIC: 
b084			; eof 
b084			 
b084			 
# End of file forth_words_logic.asm
b084			include "forth_words_maths.asm" 
b084			 
b084			; | ## Maths Words 
b084			 
b084			.PLUS:	 
b084				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b084 15				db WORD_SYS_CORE+1             
b085 c6 b0			dw .NEG            
b087 02				db 1 + 1 
b088 .. 00			db "+",0              
b08a				endm 
# End of macro CWHEAD
b08a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b08a					if DEBUG_FORTH_WORDS_KEY 
b08a						DMARK "PLU" 
b08a f5				push af  
b08b 3a 9f b0			ld a, (.dmark)  
b08e 32 7a ee			ld (debug_mark),a  
b091 3a a0 b0			ld a, (.dmark+1)  
b094 32 7b ee			ld (debug_mark+1),a  
b097 3a a1 b0			ld a, (.dmark+2)  
b09a 32 7c ee			ld (debug_mark+2),a  
b09d 18 03			jr .pastdmark  
b09f ..			.dmark: db "PLU"  
b0a2 f1			.pastdmark: pop af  
b0a3			endm  
# End of macro DMARK
b0a3						CALLMONITOR 
b0a3 cd 7b 91			call break_point_state  
b0a6				endm  
# End of macro CALLMONITOR
b0a6					endif 
b0a6					; add top two values and push back result 
b0a6			 
b0a6					;for v5 FORTH_DSP_VALUE 
b0a6					FORTH_DSP 
b0a6 cd 88 97			call macro_forth_dsp 
b0a9				endm 
# End of macro FORTH_DSP
b0a9 7e					ld a,(hl)	; get type of value on TOS 
b0aa fe 02				cp DS_TYPE_INUM  
b0ac 28 03				jr z, .dot_inum 
b0ae			 
b0ae					NEXTW 
b0ae c3 f9 98			jp macro_next 
b0b1				endm 
# End of macro NEXTW
b0b1			 
b0b1			; float maths 
b0b1			 
b0b1				if FORTH_ENABLE_FLOATMATH 
b0b1						inc hl      ; now at start of numeric as string 
b0b1			 
b0b1					if DEBUG_FORTH_MATHS 
b0b1						DMARK "ADD" 
b0b1				CALLMONITOR 
b0b1					endif 
b0b1			 
b0b1					;ld ix, hl 
b0b1					call CON 
b0b1			 
b0b1			 
b0b1					push hl 
b0b1					 
b0b1					 
b0b1			 
b0b1						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b0b1			 
b0b1					; get next number 
b0b1			 
b0b1						FORTH_DSP_VALUE 
b0b1			 
b0b1						inc hl      ; now at start of numeric as string 
b0b1			 
b0b1					;ld ix, hl 
b0b1					call CON 
b0b1			 
b0b1					push hl 
b0b1			 
b0b1			 
b0b1						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0b1			 
b0b1						; TODO do add 
b0b1			 
b0b1						call IADD 
b0b1			 
b0b1						; TODO get result back as ascii 
b0b1			 
b0b1						; TODO push result  
b0b1			 
b0b1			 
b0b1			 
b0b1						jr .dot_done 
b0b1				endif 
b0b1			 
b0b1			.dot_inum: 
b0b1			 
b0b1			 
b0b1					if DEBUG_FORTH_DOT 
b0b1						DMARK "+IT" 
b0b1				CALLMONITOR 
b0b1					endif 
b0b1			 
b0b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0b1 cd a3 97			call macro_dsp_valuehl 
b0b4				endm 
# End of macro FORTH_DSP_VALUEHL
b0b4			 
b0b4				; TODO add floating point number detection 
b0b4			 
b0b4 e5					push hl 
b0b5			 
b0b5					; destroy value TOS 
b0b5			 
b0b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0b5 cd 3f 98			call macro_forth_dsp_pop 
b0b8				endm 
# End of macro FORTH_DSP_POP
b0b8			 
b0b8			 
b0b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0b8 cd a3 97			call macro_dsp_valuehl 
b0bb				endm 
# End of macro FORTH_DSP_VALUEHL
b0bb			 
b0bb					; one value on hl get other one back 
b0bb			 
b0bb d1					pop de 
b0bc			 
b0bc					; do the add 
b0bc			 
b0bc 19					add hl,de 
b0bd			 
b0bd					; save it 
b0bd			 
b0bd			;		push hl	 
b0bd			 
b0bd					; 
b0bd			 
b0bd					; destroy value TOS 
b0bd			 
b0bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0bd cd 3f 98			call macro_forth_dsp_pop 
b0c0				endm 
# End of macro FORTH_DSP_POP
b0c0			 
b0c0					; TODO push value back onto stack for another op etc 
b0c0			 
b0c0			;		pop hl 
b0c0			 
b0c0			.dot_done: 
b0c0 cd 08 97				call forth_push_numhl 
b0c3			 
b0c3					NEXTW 
b0c3 c3 f9 98			jp macro_next 
b0c6				endm 
# End of macro NEXTW
b0c6			.NEG: 
b0c6			 
b0c6				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b0c6 17				db WORD_SYS_CORE+3             
b0c7 09 b1			dw .DIV            
b0c9 02				db 1 + 1 
b0ca .. 00			db "-",0              
b0cc				endm 
# End of macro CWHEAD
b0cc			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b0cc					if DEBUG_FORTH_WORDS_KEY 
b0cc						DMARK "SUB" 
b0cc f5				push af  
b0cd 3a e1 b0			ld a, (.dmark)  
b0d0 32 7a ee			ld (debug_mark),a  
b0d3 3a e2 b0			ld a, (.dmark+1)  
b0d6 32 7b ee			ld (debug_mark+1),a  
b0d9 3a e3 b0			ld a, (.dmark+2)  
b0dc 32 7c ee			ld (debug_mark+2),a  
b0df 18 03			jr .pastdmark  
b0e1 ..			.dmark: db "SUB"  
b0e4 f1			.pastdmark: pop af  
b0e5			endm  
# End of macro DMARK
b0e5						CALLMONITOR 
b0e5 cd 7b 91			call break_point_state  
b0e8				endm  
# End of macro CALLMONITOR
b0e8					endif 
b0e8			 
b0e8			 
b0e8				; TODO add floating point number detection 
b0e8					; v5 FORTH_DSP_VALUE 
b0e8					FORTH_DSP 
b0e8 cd 88 97			call macro_forth_dsp 
b0eb				endm 
# End of macro FORTH_DSP
b0eb 7e					ld a,(hl)	; get type of value on TOS 
b0ec fe 02				cp DS_TYPE_INUM  
b0ee 28 03				jr z, .neg_inum 
b0f0			 
b0f0					NEXTW 
b0f0 c3 f9 98			jp macro_next 
b0f3				endm 
# End of macro NEXTW
b0f3			 
b0f3			; float maths 
b0f3			 
b0f3				if FORTH_ENABLE_FLOATMATH 
b0f3					jr .neg_done 
b0f3			 
b0f3				endif 
b0f3					 
b0f3			 
b0f3			.neg_inum: 
b0f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0f3 cd a3 97			call macro_dsp_valuehl 
b0f6				endm 
# End of macro FORTH_DSP_VALUEHL
b0f6			 
b0f6 e5					push hl 
b0f7			 
b0f7					; destroy value TOS 
b0f7			 
b0f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0f7 cd 3f 98			call macro_forth_dsp_pop 
b0fa				endm 
# End of macro FORTH_DSP_POP
b0fa			 
b0fa			 
b0fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0fa cd a3 97			call macro_dsp_valuehl 
b0fd				endm 
# End of macro FORTH_DSP_VALUEHL
b0fd			 
b0fd					; one value on hl get other one back 
b0fd			 
b0fd d1					pop de 
b0fe			 
b0fe					; do the sub 
b0fe			;		ex de, hl 
b0fe			 
b0fe ed 52				sbc hl,de 
b100			 
b100					; save it 
b100			 
b100			;		push hl	 
b100			 
b100					; 
b100			 
b100					; destroy value TOS 
b100			 
b100					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b100 cd 3f 98			call macro_forth_dsp_pop 
b103				endm 
# End of macro FORTH_DSP_POP
b103			 
b103					; TODO push value back onto stack for another op etc 
b103			 
b103			;		pop hl 
b103			 
b103 cd 08 97				call forth_push_numhl 
b106			.neg_done: 
b106			 
b106					NEXTW 
b106 c3 f9 98			jp macro_next 
b109				endm 
# End of macro NEXTW
b109			.DIV: 
b109				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b109 18				db WORD_SYS_CORE+4             
b10a 56 b1			dw .MUL            
b10c 02				db 1 + 1 
b10d .. 00			db "/",0              
b10f				endm 
# End of macro CWHEAD
b10f			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b10f					if DEBUG_FORTH_WORDS_KEY 
b10f						DMARK "DIV" 
b10f f5				push af  
b110 3a 24 b1			ld a, (.dmark)  
b113 32 7a ee			ld (debug_mark),a  
b116 3a 25 b1			ld a, (.dmark+1)  
b119 32 7b ee			ld (debug_mark+1),a  
b11c 3a 26 b1			ld a, (.dmark+2)  
b11f 32 7c ee			ld (debug_mark+2),a  
b122 18 03			jr .pastdmark  
b124 ..			.dmark: db "DIV"  
b127 f1			.pastdmark: pop af  
b128			endm  
# End of macro DMARK
b128						CALLMONITOR 
b128 cd 7b 91			call break_point_state  
b12b				endm  
# End of macro CALLMONITOR
b12b					endif 
b12b				; TODO add floating point number detection 
b12b					; v5 FORTH_DSP_VALUE 
b12b					FORTH_DSP 
b12b cd 88 97			call macro_forth_dsp 
b12e				endm 
# End of macro FORTH_DSP
b12e 7e					ld a,(hl)	; get type of value on TOS 
b12f fe 02				cp DS_TYPE_INUM  
b131 28 03				jr z, .div_inum 
b133			 
b133				if FORTH_ENABLE_FLOATMATH 
b133					jr .div_done 
b133			 
b133				endif 
b133					NEXTW 
b133 c3 f9 98			jp macro_next 
b136				endm 
# End of macro NEXTW
b136			.div_inum: 
b136			 
b136					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b136 cd a3 97			call macro_dsp_valuehl 
b139				endm 
# End of macro FORTH_DSP_VALUEHL
b139			 
b139 e5					push hl    ; to go to bc 
b13a			 
b13a					; destroy value TOS 
b13a			 
b13a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b13a cd 3f 98			call macro_forth_dsp_pop 
b13d				endm 
# End of macro FORTH_DSP_POP
b13d			 
b13d			 
b13d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b13d cd a3 97			call macro_dsp_valuehl 
b140				endm 
# End of macro FORTH_DSP_VALUEHL
b140			 
b140					; hl to go to de 
b140			 
b140 e5					push hl 
b141			 
b141 c1					pop bc 
b142 d1					pop de		 
b143			 
b143			 
b143					if DEBUG_FORTH_MATHS 
b143						DMARK "DIV" 
b143				CALLMONITOR 
b143					endif 
b143					; one value on hl but move to a get other one back 
b143			 
b143			        
b143 cd 14 89			call Div16 
b146			 
b146			;	push af	 
b146 e5				push hl 
b147 c5				push bc 
b148			 
b148					if DEBUG_FORTH_MATHS 
b148						DMARK "DI1" 
b148				CALLMONITOR 
b148					endif 
b148			 
b148					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b148 cd 3f 98			call macro_forth_dsp_pop 
b14b				endm 
# End of macro FORTH_DSP_POP
b14b			 
b14b			 
b14b			 
b14b e1					pop hl    ; result 
b14c			 
b14c cd 08 97				call forth_push_numhl 
b14f			 
b14f e1					pop hl    ; reminder 
b150			;		ld h,0 
b150			;		ld l,d 
b150			 
b150 cd 08 97				call forth_push_numhl 
b153			.div_done: 
b153					NEXTW 
b153 c3 f9 98			jp macro_next 
b156				endm 
# End of macro NEXTW
b156			.MUL: 
b156				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b156 19				db WORD_SYS_CORE+5             
b157 9b b1			dw .MIN            
b159 02				db 1 + 1 
b15a .. 00			db "*",0              
b15c				endm 
# End of macro CWHEAD
b15c			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b15c				; TODO add floating point number detection 
b15c					if DEBUG_FORTH_WORDS_KEY 
b15c						DMARK "MUL" 
b15c f5				push af  
b15d 3a 71 b1			ld a, (.dmark)  
b160 32 7a ee			ld (debug_mark),a  
b163 3a 72 b1			ld a, (.dmark+1)  
b166 32 7b ee			ld (debug_mark+1),a  
b169 3a 73 b1			ld a, (.dmark+2)  
b16c 32 7c ee			ld (debug_mark+2),a  
b16f 18 03			jr .pastdmark  
b171 ..			.dmark: db "MUL"  
b174 f1			.pastdmark: pop af  
b175			endm  
# End of macro DMARK
b175						CALLMONITOR 
b175 cd 7b 91			call break_point_state  
b178				endm  
# End of macro CALLMONITOR
b178					endif 
b178					FORTH_DSP 
b178 cd 88 97			call macro_forth_dsp 
b17b				endm 
# End of macro FORTH_DSP
b17b					; v5 FORTH_DSP_VALUE 
b17b 7e					ld a,(hl)	; get type of value on TOS 
b17c fe 02				cp DS_TYPE_INUM  
b17e 28 03				jr z, .mul_inum 
b180			 
b180				if FORTH_ENABLE_FLOATMATH 
b180					jr .mul_done 
b180			 
b180				endif 
b180			 
b180					NEXTW 
b180 c3 f9 98			jp macro_next 
b183				endm 
# End of macro NEXTW
b183			.mul_inum:	 
b183			 
b183					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b183 cd a3 97			call macro_dsp_valuehl 
b186				endm 
# End of macro FORTH_DSP_VALUEHL
b186			 
b186 e5					push hl 
b187			 
b187					; destroy value TOS 
b187			 
b187					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b187 cd 3f 98			call macro_forth_dsp_pop 
b18a				endm 
# End of macro FORTH_DSP_POP
b18a			 
b18a			 
b18a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b18a cd a3 97			call macro_dsp_valuehl 
b18d				endm 
# End of macro FORTH_DSP_VALUEHL
b18d			 
b18d					; one value on hl but move to a get other one back 
b18d			 
b18d 7d					ld a, l 
b18e			 
b18e d1					pop de 
b18f			 
b18f					; do the mull 
b18f			;		ex de, hl 
b18f			 
b18f cd 3a 89				call Mult16 
b192					; save it 
b192			 
b192			;		push hl	 
b192			 
b192					; 
b192			 
b192					; destroy value TOS 
b192			 
b192					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b192 cd 3f 98			call macro_forth_dsp_pop 
b195				endm 
# End of macro FORTH_DSP_POP
b195			 
b195					; TODO push value back onto stack for another op etc 
b195			 
b195			;		pop hl 
b195			 
b195 cd 08 97				call forth_push_numhl 
b198			 
b198			.mul_done: 
b198					NEXTW 
b198 c3 f9 98			jp macro_next 
b19b				endm 
# End of macro NEXTW
b19b			 
b19b			 
b19b			 
b19b			 
b19b			.MIN: 
b19b				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b19b 49				db WORD_SYS_CORE+53             
b19c 1c b2			dw .MAX            
b19e 04				db 3 + 1 
b19f .. 00			db "MIN",0              
b1a3				endm 
# End of macro CWHEAD
b1a3			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b1a3					if DEBUG_FORTH_WORDS_KEY 
b1a3						DMARK "MIN" 
b1a3 f5				push af  
b1a4 3a b8 b1			ld a, (.dmark)  
b1a7 32 7a ee			ld (debug_mark),a  
b1aa 3a b9 b1			ld a, (.dmark+1)  
b1ad 32 7b ee			ld (debug_mark+1),a  
b1b0 3a ba b1			ld a, (.dmark+2)  
b1b3 32 7c ee			ld (debug_mark+2),a  
b1b6 18 03			jr .pastdmark  
b1b8 ..			.dmark: db "MIN"  
b1bb f1			.pastdmark: pop af  
b1bc			endm  
# End of macro DMARK
b1bc						CALLMONITOR 
b1bc cd 7b 91			call break_point_state  
b1bf				endm  
# End of macro CALLMONITOR
b1bf					endif 
b1bf					; get u2 
b1bf			 
b1bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1bf cd a3 97			call macro_dsp_valuehl 
b1c2				endm 
# End of macro FORTH_DSP_VALUEHL
b1c2			 
b1c2 e5					push hl   ; u2 
b1c3			 
b1c3					; destroy value TOS 
b1c3			 
b1c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1c3 cd 3f 98			call macro_forth_dsp_pop 
b1c6				endm 
# End of macro FORTH_DSP_POP
b1c6			 
b1c6					; get u1 
b1c6			 
b1c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1c6 cd a3 97			call macro_dsp_valuehl 
b1c9				endm 
# End of macro FORTH_DSP_VALUEHL
b1c9			 
b1c9 e5					push hl  ; u1 
b1ca			 
b1ca					; destroy value TOS 
b1ca			 
b1ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1ca cd 3f 98			call macro_forth_dsp_pop 
b1cd				endm 
# End of macro FORTH_DSP_POP
b1cd			 
b1cd b7			 or a      ;clear carry flag 
b1ce e1			  pop hl    ; u1 
b1cf d1			  pop de    ; u2 
b1d0 e5				push hl   ; saved in case hl is lowest 
b1d1 ed 52		  sbc hl,de 
b1d3 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b1d5			 
b1d5 e1				pop hl 
b1d6					if DEBUG_FORTH_WORDS 
b1d6						DMARK "MIN" 
b1d6 f5				push af  
b1d7 3a eb b1			ld a, (.dmark)  
b1da 32 7a ee			ld (debug_mark),a  
b1dd 3a ec b1			ld a, (.dmark+1)  
b1e0 32 7b ee			ld (debug_mark+1),a  
b1e3 3a ed b1			ld a, (.dmark+2)  
b1e6 32 7c ee			ld (debug_mark+2),a  
b1e9 18 03			jr .pastdmark  
b1eb ..			.dmark: db "MIN"  
b1ee f1			.pastdmark: pop af  
b1ef			endm  
# End of macro DMARK
b1ef						CALLMONITOR 
b1ef cd 7b 91			call break_point_state  
b1f2				endm  
# End of macro CALLMONITOR
b1f2					endif 
b1f2 cd 08 97				call forth_push_numhl 
b1f5			 
b1f5				       NEXTW 
b1f5 c3 f9 98			jp macro_next 
b1f8				endm 
# End of macro NEXTW
b1f8			 
b1f8			.mincont:  
b1f8 c1				pop bc   ; tidy up 
b1f9 eb				ex de , hl  
b1fa					if DEBUG_FORTH_WORDS 
b1fa						DMARK "MI1" 
b1fa f5				push af  
b1fb 3a 0f b2			ld a, (.dmark)  
b1fe 32 7a ee			ld (debug_mark),a  
b201 3a 10 b2			ld a, (.dmark+1)  
b204 32 7b ee			ld (debug_mark+1),a  
b207 3a 11 b2			ld a, (.dmark+2)  
b20a 32 7c ee			ld (debug_mark+2),a  
b20d 18 03			jr .pastdmark  
b20f ..			.dmark: db "MI1"  
b212 f1			.pastdmark: pop af  
b213			endm  
# End of macro DMARK
b213						CALLMONITOR 
b213 cd 7b 91			call break_point_state  
b216				endm  
# End of macro CALLMONITOR
b216					endif 
b216 cd 08 97				call forth_push_numhl 
b219			 
b219				       NEXTW 
b219 c3 f9 98			jp macro_next 
b21c				endm 
# End of macro NEXTW
b21c			.MAX: 
b21c				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b21c 4a				db WORD_SYS_CORE+54             
b21d 9d b2			dw .RND16            
b21f 04				db 3 + 1 
b220 .. 00			db "MAX",0              
b224				endm 
# End of macro CWHEAD
b224			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b224					if DEBUG_FORTH_WORDS_KEY 
b224						DMARK "MAX" 
b224 f5				push af  
b225 3a 39 b2			ld a, (.dmark)  
b228 32 7a ee			ld (debug_mark),a  
b22b 3a 3a b2			ld a, (.dmark+1)  
b22e 32 7b ee			ld (debug_mark+1),a  
b231 3a 3b b2			ld a, (.dmark+2)  
b234 32 7c ee			ld (debug_mark+2),a  
b237 18 03			jr .pastdmark  
b239 ..			.dmark: db "MAX"  
b23c f1			.pastdmark: pop af  
b23d			endm  
# End of macro DMARK
b23d						CALLMONITOR 
b23d cd 7b 91			call break_point_state  
b240				endm  
# End of macro CALLMONITOR
b240					endif 
b240					; get u2 
b240			 
b240					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b240 cd a3 97			call macro_dsp_valuehl 
b243				endm 
# End of macro FORTH_DSP_VALUEHL
b243			 
b243 e5					push hl   ; u2 
b244			 
b244					; destroy value TOS 
b244			 
b244					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b244 cd 3f 98			call macro_forth_dsp_pop 
b247				endm 
# End of macro FORTH_DSP_POP
b247			 
b247					; get u1 
b247			 
b247					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b247 cd a3 97			call macro_dsp_valuehl 
b24a				endm 
# End of macro FORTH_DSP_VALUEHL
b24a			 
b24a e5					push hl  ; u1 
b24b			 
b24b					; destroy value TOS 
b24b			 
b24b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b24b cd 3f 98			call macro_forth_dsp_pop 
b24e				endm 
# End of macro FORTH_DSP_POP
b24e			 
b24e b7			 or a      ;clear carry flag 
b24f e1			  pop hl    ; u1 
b250 d1			  pop de    ; u2 
b251 e5				push hl   ; saved in case hl is lowest 
b252 ed 52		  sbc hl,de 
b254 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b256			 
b256 e1				pop hl 
b257					if DEBUG_FORTH_WORDS 
b257						DMARK "MAX" 
b257 f5				push af  
b258 3a 6c b2			ld a, (.dmark)  
b25b 32 7a ee			ld (debug_mark),a  
b25e 3a 6d b2			ld a, (.dmark+1)  
b261 32 7b ee			ld (debug_mark+1),a  
b264 3a 6e b2			ld a, (.dmark+2)  
b267 32 7c ee			ld (debug_mark+2),a  
b26a 18 03			jr .pastdmark  
b26c ..			.dmark: db "MAX"  
b26f f1			.pastdmark: pop af  
b270			endm  
# End of macro DMARK
b270						CALLMONITOR 
b270 cd 7b 91			call break_point_state  
b273				endm  
# End of macro CALLMONITOR
b273					endif 
b273 cd 08 97				call forth_push_numhl 
b276			 
b276				       NEXTW 
b276 c3 f9 98			jp macro_next 
b279				endm 
# End of macro NEXTW
b279			 
b279			.maxcont:  
b279 c1				pop bc   ; tidy up 
b27a eb				ex de , hl  
b27b					if DEBUG_FORTH_WORDS 
b27b						DMARK "MA1" 
b27b f5				push af  
b27c 3a 90 b2			ld a, (.dmark)  
b27f 32 7a ee			ld (debug_mark),a  
b282 3a 91 b2			ld a, (.dmark+1)  
b285 32 7b ee			ld (debug_mark+1),a  
b288 3a 92 b2			ld a, (.dmark+2)  
b28b 32 7c ee			ld (debug_mark+2),a  
b28e 18 03			jr .pastdmark  
b290 ..			.dmark: db "MA1"  
b293 f1			.pastdmark: pop af  
b294			endm  
# End of macro DMARK
b294						CALLMONITOR 
b294 cd 7b 91			call break_point_state  
b297				endm  
# End of macro CALLMONITOR
b297					endif 
b297 cd 08 97				call forth_push_numhl 
b29a				       NEXTW 
b29a c3 f9 98			jp macro_next 
b29d				endm 
# End of macro NEXTW
b29d			 
b29d			.RND16: 
b29d				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b29d 4e				db WORD_SYS_CORE+58             
b29e cc b2			dw .RND8            
b2a0 06				db 5 + 1 
b2a1 .. 00			db "RND16",0              
b2a7				endm 
# End of macro CWHEAD
b2a7			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b2a7					if DEBUG_FORTH_WORDS_KEY 
b2a7						DMARK "R16" 
b2a7 f5				push af  
b2a8 3a bc b2			ld a, (.dmark)  
b2ab 32 7a ee			ld (debug_mark),a  
b2ae 3a bd b2			ld a, (.dmark+1)  
b2b1 32 7b ee			ld (debug_mark+1),a  
b2b4 3a be b2			ld a, (.dmark+2)  
b2b7 32 7c ee			ld (debug_mark+2),a  
b2ba 18 03			jr .pastdmark  
b2bc ..			.dmark: db "R16"  
b2bf f1			.pastdmark: pop af  
b2c0			endm  
# End of macro DMARK
b2c0						CALLMONITOR 
b2c0 cd 7b 91			call break_point_state  
b2c3				endm  
# End of macro CALLMONITOR
b2c3					endif 
b2c3 cd de 88				call prng16  
b2c6 cd 08 97				call forth_push_numhl 
b2c9				       NEXTW 
b2c9 c3 f9 98			jp macro_next 
b2cc				endm 
# End of macro NEXTW
b2cc			.RND8: 
b2cc				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b2cc 60				db WORD_SYS_CORE+76             
b2cd 01 b3			dw .RND            
b2cf 05				db 4 + 1 
b2d0 .. 00			db "RND8",0              
b2d5				endm 
# End of macro CWHEAD
b2d5			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b2d5					if DEBUG_FORTH_WORDS_KEY 
b2d5						DMARK "RN8" 
b2d5 f5				push af  
b2d6 3a ea b2			ld a, (.dmark)  
b2d9 32 7a ee			ld (debug_mark),a  
b2dc 3a eb b2			ld a, (.dmark+1)  
b2df 32 7b ee			ld (debug_mark+1),a  
b2e2 3a ec b2			ld a, (.dmark+2)  
b2e5 32 7c ee			ld (debug_mark+2),a  
b2e8 18 03			jr .pastdmark  
b2ea ..			.dmark: db "RN8"  
b2ed f1			.pastdmark: pop af  
b2ee			endm  
# End of macro DMARK
b2ee						CALLMONITOR 
b2ee cd 7b 91			call break_point_state  
b2f1				endm  
# End of macro CALLMONITOR
b2f1					endif 
b2f1 2a bb eb				ld hl,(xrandc) 
b2f4 23					inc hl 
b2f5 cd f8 88				call xrnd 
b2f8 6f					ld l,a	 
b2f9 26 00				ld h,0 
b2fb cd 08 97				call forth_push_numhl 
b2fe				       NEXTW 
b2fe c3 f9 98			jp macro_next 
b301				endm 
# End of macro NEXTW
b301			.RND: 
b301				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b301 60				db WORD_SYS_CORE+76             
b302 07 b4			dw .ENDMATHS            
b304 04				db 3 + 1 
b305 .. 00			db "RND",0              
b309				endm 
# End of macro CWHEAD
b309			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b309			 
b309					if DEBUG_FORTH_WORDS_KEY 
b309						DMARK "RND" 
b309 f5				push af  
b30a 3a 1e b3			ld a, (.dmark)  
b30d 32 7a ee			ld (debug_mark),a  
b310 3a 1f b3			ld a, (.dmark+1)  
b313 32 7b ee			ld (debug_mark+1),a  
b316 3a 20 b3			ld a, (.dmark+2)  
b319 32 7c ee			ld (debug_mark+2),a  
b31c 18 03			jr .pastdmark  
b31e ..			.dmark: db "RND"  
b321 f1			.pastdmark: pop af  
b322			endm  
# End of macro DMARK
b322						CALLMONITOR 
b322 cd 7b 91			call break_point_state  
b325				endm  
# End of macro CALLMONITOR
b325					endif 
b325					 
b325					FORTH_DSP_VALUEHL    ; upper range 
b325 cd a3 97			call macro_dsp_valuehl 
b328				endm 
# End of macro FORTH_DSP_VALUEHL
b328			 
b328 22 bf eb				ld (LFSRSeed), hl	 
b32b			 
b32b					if DEBUG_FORTH_WORDS 
b32b						DMARK "RN1" 
b32b f5				push af  
b32c 3a 40 b3			ld a, (.dmark)  
b32f 32 7a ee			ld (debug_mark),a  
b332 3a 41 b3			ld a, (.dmark+1)  
b335 32 7b ee			ld (debug_mark+1),a  
b338 3a 42 b3			ld a, (.dmark+2)  
b33b 32 7c ee			ld (debug_mark+2),a  
b33e 18 03			jr .pastdmark  
b340 ..			.dmark: db "RN1"  
b343 f1			.pastdmark: pop af  
b344			endm  
# End of macro DMARK
b344						CALLMONITOR 
b344 cd 7b 91			call break_point_state  
b347				endm  
# End of macro CALLMONITOR
b347					endif 
b347					FORTH_DSP_POP 
b347 cd 3f 98			call macro_forth_dsp_pop 
b34a				endm 
# End of macro FORTH_DSP_POP
b34a			 
b34a					FORTH_DSP_VALUEHL    ; low range 
b34a cd a3 97			call macro_dsp_valuehl 
b34d				endm 
# End of macro FORTH_DSP_VALUEHL
b34d			 
b34d					if DEBUG_FORTH_WORDS 
b34d						DMARK "RN2" 
b34d f5				push af  
b34e 3a 62 b3			ld a, (.dmark)  
b351 32 7a ee			ld (debug_mark),a  
b354 3a 63 b3			ld a, (.dmark+1)  
b357 32 7b ee			ld (debug_mark+1),a  
b35a 3a 64 b3			ld a, (.dmark+2)  
b35d 32 7c ee			ld (debug_mark+2),a  
b360 18 03			jr .pastdmark  
b362 ..			.dmark: db "RN2"  
b365 f1			.pastdmark: pop af  
b366			endm  
# End of macro DMARK
b366						CALLMONITOR 
b366 cd 7b 91			call break_point_state  
b369				endm  
# End of macro CALLMONITOR
b369					endif 
b369 22 c1 eb				ld (LFSRSeed+2), hl 
b36c			 
b36c					FORTH_DSP_POP 
b36c cd 3f 98			call macro_forth_dsp_pop 
b36f				endm 
# End of macro FORTH_DSP_POP
b36f			 
b36f e5					push hl 
b370			 
b370 e1			.inrange:	pop hl 
b371 cd de 88				call prng16  
b374					if DEBUG_FORTH_WORDS 
b374						DMARK "RN3" 
b374 f5				push af  
b375 3a 89 b3			ld a, (.dmark)  
b378 32 7a ee			ld (debug_mark),a  
b37b 3a 8a b3			ld a, (.dmark+1)  
b37e 32 7b ee			ld (debug_mark+1),a  
b381 3a 8b b3			ld a, (.dmark+2)  
b384 32 7c ee			ld (debug_mark+2),a  
b387 18 03			jr .pastdmark  
b389 ..			.dmark: db "RN3"  
b38c f1			.pastdmark: pop af  
b38d			endm  
# End of macro DMARK
b38d						CALLMONITOR 
b38d cd 7b 91			call break_point_state  
b390				endm  
# End of macro CALLMONITOR
b390					endif 
b390					 
b390					; if the range is 8bit knock out the high byte 
b390			 
b390 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b394			 
b394 3e 00				ld a, 0 
b396 ba					cp d  
b397 20 1e				jr nz, .hirange 
b399 26 00				ld h, 0   ; knock it down to 8bit 
b39b			 
b39b					if DEBUG_FORTH_WORDS 
b39b						DMARK "RNk" 
b39b f5				push af  
b39c 3a b0 b3			ld a, (.dmark)  
b39f 32 7a ee			ld (debug_mark),a  
b3a2 3a b1 b3			ld a, (.dmark+1)  
b3a5 32 7b ee			ld (debug_mark+1),a  
b3a8 3a b2 b3			ld a, (.dmark+2)  
b3ab 32 7c ee			ld (debug_mark+2),a  
b3ae 18 03			jr .pastdmark  
b3b0 ..			.dmark: db "RNk"  
b3b3 f1			.pastdmark: pop af  
b3b4			endm  
# End of macro DMARK
b3b4						CALLMONITOR 
b3b4 cd 7b 91			call break_point_state  
b3b7				endm  
# End of macro CALLMONITOR
b3b7					endif 
b3b7			.hirange:   
b3b7 e5					push hl  
b3b8 b7					or a  
b3b9 ed 52		                sbc hl, de 
b3bb			 
b3bb					;call cmp16 
b3bb			 
b3bb 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b3bd e1					pop hl 
b3be e5					push hl 
b3bf			 
b3bf					if DEBUG_FORTH_WORDS 
b3bf						DMARK "RN4" 
b3bf f5				push af  
b3c0 3a d4 b3			ld a, (.dmark)  
b3c3 32 7a ee			ld (debug_mark),a  
b3c6 3a d5 b3			ld a, (.dmark+1)  
b3c9 32 7b ee			ld (debug_mark+1),a  
b3cc 3a d6 b3			ld a, (.dmark+2)  
b3cf 32 7c ee			ld (debug_mark+2),a  
b3d2 18 03			jr .pastdmark  
b3d4 ..			.dmark: db "RN4"  
b3d7 f1			.pastdmark: pop af  
b3d8			endm  
# End of macro DMARK
b3d8						CALLMONITOR 
b3d8 cd 7b 91			call break_point_state  
b3db				endm  
# End of macro CALLMONITOR
b3db					endif 
b3db ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b3df					;call cmp16 
b3df				 
b3df b7					or a  
b3e0 ed 52		                sbc hl, de 
b3e2 38 8c				jr c, .inrange 
b3e4			 
b3e4 e1					pop hl 
b3e5					 
b3e5					if DEBUG_FORTH_WORDS 
b3e5						DMARK "RNd" 
b3e5 f5				push af  
b3e6 3a fa b3			ld a, (.dmark)  
b3e9 32 7a ee			ld (debug_mark),a  
b3ec 3a fb b3			ld a, (.dmark+1)  
b3ef 32 7b ee			ld (debug_mark+1),a  
b3f2 3a fc b3			ld a, (.dmark+2)  
b3f5 32 7c ee			ld (debug_mark+2),a  
b3f8 18 03			jr .pastdmark  
b3fa ..			.dmark: db "RNd"  
b3fd f1			.pastdmark: pop af  
b3fe			endm  
# End of macro DMARK
b3fe						CALLMONITOR 
b3fe cd 7b 91			call break_point_state  
b401				endm  
# End of macro CALLMONITOR
b401					endif 
b401			 
b401			 
b401 cd 08 97				call forth_push_numhl 
b404				       NEXTW 
b404 c3 f9 98			jp macro_next 
b407				endm 
# End of macro NEXTW
b407			 
b407			.ENDMATHS: 
b407			 
b407			; eof 
b407			 
# End of file forth_words_maths.asm
b407			include "forth_words_display.asm" 
b407			 
b407			; | ## Display Words 
b407			 
b407			.ATP: 
b407				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b407 62				db WORD_SYS_CORE+78             
b408 7e b4			dw .FB            
b40a 04				db 3 + 1 
b40b .. 00			db "AT?",0              
b40f				endm 
# End of macro CWHEAD
b40f			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b40f					if DEBUG_FORTH_WORDS_KEY 
b40f						DMARK "AT?" 
b40f f5				push af  
b410 3a 24 b4			ld a, (.dmark)  
b413 32 7a ee			ld (debug_mark),a  
b416 3a 25 b4			ld a, (.dmark+1)  
b419 32 7b ee			ld (debug_mark+1),a  
b41c 3a 26 b4			ld a, (.dmark+2)  
b41f 32 7c ee			ld (debug_mark+2),a  
b422 18 03			jr .pastdmark  
b424 ..			.dmark: db "AT?"  
b427 f1			.pastdmark: pop af  
b428			endm  
# End of macro DMARK
b428						CALLMONITOR 
b428 cd 7b 91			call break_point_state  
b42b				endm  
# End of macro CALLMONITOR
b42b					endif 
b42b 3a 5e eb				ld a, (f_cursor_ptr) 
b42e			 
b42e			if DEBUG_FORTH_WORDS 
b42e				DMARK "AT?" 
b42e f5				push af  
b42f 3a 43 b4			ld a, (.dmark)  
b432 32 7a ee			ld (debug_mark),a  
b435 3a 44 b4			ld a, (.dmark+1)  
b438 32 7b ee			ld (debug_mark+1),a  
b43b 3a 45 b4			ld a, (.dmark+2)  
b43e 32 7c ee			ld (debug_mark+2),a  
b441 18 03			jr .pastdmark  
b443 ..			.dmark: db "AT?"  
b446 f1			.pastdmark: pop af  
b447			endm  
# End of macro DMARK
b447				CALLMONITOR 
b447 cd 7b 91			call break_point_state  
b44a				endm  
# End of macro CALLMONITOR
b44a			endif	 
b44a					; count the number of rows 
b44a			 
b44a 06 00				ld b, 0 
b44c 4f			.atpr:		ld c, a    ; save in case we go below zero 
b44d d6 28				sub display_cols 
b44f f2 55 b4				jp p, .atprunder 
b452 04					inc b 
b453 18 f7				jr .atpr 
b455			.atprunder:	 
b455			if DEBUG_FORTH_WORDS 
b455				DMARK "A?2" 
b455 f5				push af  
b456 3a 6a b4			ld a, (.dmark)  
b459 32 7a ee			ld (debug_mark),a  
b45c 3a 6b b4			ld a, (.dmark+1)  
b45f 32 7b ee			ld (debug_mark+1),a  
b462 3a 6c b4			ld a, (.dmark+2)  
b465 32 7c ee			ld (debug_mark+2),a  
b468 18 03			jr .pastdmark  
b46a ..			.dmark: db "A?2"  
b46d f1			.pastdmark: pop af  
b46e			endm  
# End of macro DMARK
b46e				CALLMONITOR 
b46e cd 7b 91			call break_point_state  
b471				endm  
# End of macro CALLMONITOR
b471			endif	 
b471 26 00				ld h, 0 
b473 69					ld l, c 
b474 cd 08 97				call forth_push_numhl 
b477 68					ld l, b  
b478 cd 08 97				call forth_push_numhl 
b47b			 
b47b			 
b47b				NEXTW 
b47b c3 f9 98			jp macro_next 
b47e				endm 
# End of macro NEXTW
b47e			 
b47e			.FB: 
b47e				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b47e 1b				db WORD_SYS_CORE+7             
b47f cc b4			dw .EMIT            
b481 03				db 2 + 1 
b482 .. 00			db "FB",0              
b485				endm 
# End of macro CWHEAD
b485			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b485			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b485			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b485			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b485					if DEBUG_FORTH_WORDS_KEY 
b485						DMARK "FB." 
b485 f5				push af  
b486 3a 9a b4			ld a, (.dmark)  
b489 32 7a ee			ld (debug_mark),a  
b48c 3a 9b b4			ld a, (.dmark+1)  
b48f 32 7b ee			ld (debug_mark+1),a  
b492 3a 9c b4			ld a, (.dmark+2)  
b495 32 7c ee			ld (debug_mark+2),a  
b498 18 03			jr .pastdmark  
b49a ..			.dmark: db "FB."  
b49d f1			.pastdmark: pop af  
b49e			endm  
# End of macro DMARK
b49e						CALLMONITOR 
b49e cd 7b 91			call break_point_state  
b4a1				endm  
# End of macro CALLMONITOR
b4a1					endif 
b4a1			 
b4a1					FORTH_DSP_VALUEHL 
b4a1 cd a3 97			call macro_dsp_valuehl 
b4a4				endm 
# End of macro FORTH_DSP_VALUEHL
b4a4			 
b4a4 7d					ld a, l 
b4a5 fe 01				cp 1 
b4a7 20 05				jr nz, .fbn1 
b4a9 21 1f ed				ld hl, display_fb1 
b4ac 18 15				jr .fbset 
b4ae fe 02		.fbn1:		cp 2 
b4b0 20 05				jr nz, .fbn2 
b4b2 21 dd eb				ld hl, display_fb2 
b4b5 18 0c				jr .fbset 
b4b7 fe 03		.fbn2:		cp 3 
b4b9 20 05				jr nz, .fbn3 
b4bb 21 7e ec				ld hl, display_fb3 
b4be 18 03				jr .fbset 
b4c0			.fbn3:		 ; if invalid number select first 
b4c0 21 1f ed				ld hl, display_fb1 
b4c3 22 db eb		.fbset:		ld (display_fb_active), hl 
b4c6			 
b4c6					FORTH_DSP_POP 
b4c6 cd 3f 98			call macro_forth_dsp_pop 
b4c9				endm 
# End of macro FORTH_DSP_POP
b4c9			 
b4c9					NEXTW 
b4c9 c3 f9 98			jp macro_next 
b4cc				endm 
# End of macro NEXTW
b4cc			 
b4cc			 
b4cc			.EMIT: 
b4cc				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b4cc 1b				db WORD_SYS_CORE+7             
b4cd 1d b5			dw .DOTH            
b4cf 05				db 4 + 1 
b4d0 .. 00			db "EMIT",0              
b4d5				endm 
# End of macro CWHEAD
b4d5			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b4d5					; get value off TOS and display it 
b4d5			 
b4d5					if DEBUG_FORTH_WORDS_KEY 
b4d5						DMARK "EMT" 
b4d5 f5				push af  
b4d6 3a ea b4			ld a, (.dmark)  
b4d9 32 7a ee			ld (debug_mark),a  
b4dc 3a eb b4			ld a, (.dmark+1)  
b4df 32 7b ee			ld (debug_mark+1),a  
b4e2 3a ec b4			ld a, (.dmark+2)  
b4e5 32 7c ee			ld (debug_mark+2),a  
b4e8 18 03			jr .pastdmark  
b4ea ..			.dmark: db "EMT"  
b4ed f1			.pastdmark: pop af  
b4ee			endm  
# End of macro DMARK
b4ee						CALLMONITOR 
b4ee cd 7b 91			call break_point_state  
b4f1				endm  
# End of macro CALLMONITOR
b4f1					endif 
b4f1			 
b4f1					FORTH_DSP_VALUEHL 
b4f1 cd a3 97			call macro_dsp_valuehl 
b4f4				endm 
# End of macro FORTH_DSP_VALUEHL
b4f4			 
b4f4 7d					ld a,l 
b4f5			 
b4f5					; TODO write to display 
b4f5			 
b4f5 32 73 e5				ld (os_input), a 
b4f8 3e 00				ld a, 0 
b4fa 32 74 e5				ld (os_input+1), a 
b4fd					 
b4fd 3a 5e eb				ld a, (f_cursor_ptr) 
b500 11 73 e5				ld de, os_input 
b503 cd 71 88				call str_at_display 
b506			 
b506			 
b506 3a 3c eb				ld a,(cli_autodisplay) 
b509 fe 00				cp 0 
b50b 28 03				jr z, .enoupdate 
b50d cd 81 88						call update_display 
b510					.enoupdate: 
b510			 
b510 3a 5e eb				ld a, (f_cursor_ptr) 
b513 3c					inc a 
b514 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b517			 
b517			 
b517					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b517 cd 3f 98			call macro_forth_dsp_pop 
b51a				endm 
# End of macro FORTH_DSP_POP
b51a			  
b51a			 
b51a					NEXTW 
b51a c3 f9 98			jp macro_next 
b51d				endm 
# End of macro NEXTW
b51d			.DOTH: 
b51d				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b51d 1c				db WORD_SYS_CORE+8             
b51e 4d b5			dw .DOTF            
b520 03				db 2 + 1 
b521 .. 00			db ".-",0              
b524				endm 
# End of macro CWHEAD
b524			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b524					; get value off TOS and display it 
b524					if DEBUG_FORTH_WORDS_KEY 
b524						DMARK "DTD" 
b524 f5				push af  
b525 3a 39 b5			ld a, (.dmark)  
b528 32 7a ee			ld (debug_mark),a  
b52b 3a 3a b5			ld a, (.dmark+1)  
b52e 32 7b ee			ld (debug_mark+1),a  
b531 3a 3b b5			ld a, (.dmark+2)  
b534 32 7c ee			ld (debug_mark+2),a  
b537 18 03			jr .pastdmark  
b539 ..			.dmark: db "DTD"  
b53c f1			.pastdmark: pop af  
b53d			endm  
# End of macro DMARK
b53d						CALLMONITOR 
b53d cd 7b 91			call break_point_state  
b540				endm  
# End of macro CALLMONITOR
b540					endif 
b540 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b542 3e 00			ld a, 0 
b544 32 3d eb			ld (cli_mvdot), a 
b547 c3 a4 b5			jp .dotgo 
b54a				NEXTW 
b54a c3 f9 98			jp macro_next 
b54d				endm 
# End of macro NEXTW
b54d			.DOTF: 
b54d				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b54d 1c				db WORD_SYS_CORE+8             
b54e 7b b5			dw .DOT            
b550 03				db 2 + 1 
b551 .. 00			db ".>",0              
b554				endm 
# End of macro CWHEAD
b554			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b554					; get value off TOS and display it 
b554			        ; TODO BUG adds extra spaces 
b554			        ; TODO BUG handle numerics? 
b554					if DEBUG_FORTH_WORDS_KEY 
b554						DMARK "DTC" 
b554 f5				push af  
b555 3a 69 b5			ld a, (.dmark)  
b558 32 7a ee			ld (debug_mark),a  
b55b 3a 6a b5			ld a, (.dmark+1)  
b55e 32 7b ee			ld (debug_mark+1),a  
b561 3a 6b b5			ld a, (.dmark+2)  
b564 32 7c ee			ld (debug_mark+2),a  
b567 18 03			jr .pastdmark  
b569 ..			.dmark: db "DTC"  
b56c f1			.pastdmark: pop af  
b56d			endm  
# End of macro DMARK
b56d						CALLMONITOR 
b56d cd 7b 91			call break_point_state  
b570				endm  
# End of macro CALLMONITOR
b570					endif 
b570 3e 01			ld a, 1 
b572 32 3d eb			ld (cli_mvdot), a 
b575 c3 a4 b5			jp .dotgo 
b578				NEXTW 
b578 c3 f9 98			jp macro_next 
b57b				endm 
# End of macro NEXTW
b57b			 
b57b			.DOT: 
b57b				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b57b 1c				db WORD_SYS_CORE+8             
b57c 07 b6			dw .CLS            
b57e 02				db 1 + 1 
b57f .. 00			db ".",0              
b581				endm 
# End of macro CWHEAD
b581			        ; | . ( u -- ) Display TOS | DONE 
b581					; get value off TOS and display it 
b581			 
b581					if DEBUG_FORTH_WORDS_KEY 
b581						DMARK "DOT" 
b581 f5				push af  
b582 3a 96 b5			ld a, (.dmark)  
b585 32 7a ee			ld (debug_mark),a  
b588 3a 97 b5			ld a, (.dmark+1)  
b58b 32 7b ee			ld (debug_mark+1),a  
b58e 3a 98 b5			ld a, (.dmark+2)  
b591 32 7c ee			ld (debug_mark+2),a  
b594 18 03			jr .pastdmark  
b596 ..			.dmark: db "DOT"  
b599 f1			.pastdmark: pop af  
b59a			endm  
# End of macro DMARK
b59a						CALLMONITOR 
b59a cd 7b 91			call break_point_state  
b59d				endm  
# End of macro CALLMONITOR
b59d					endif 
b59d 3e 00			ld a, 0 
b59f 32 3d eb			ld (cli_mvdot), a 
b5a2 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b5a4				 
b5a4			 
b5a4			.dotgo: 
b5a4			 
b5a4			; move up type to on stack for parserv5 
b5a4					FORTH_DSP 
b5a4 cd 88 97			call macro_forth_dsp 
b5a7				endm 
# End of macro FORTH_DSP
b5a7				;FORTH_DSP_VALUE  
b5a7			 
b5a7			if DEBUG_FORTH_DOT 
b5a7				DMARK "DOT" 
b5a7				CALLMONITOR 
b5a7			endif	 
b5a7			;		.print: 
b5a7			 
b5a7 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b5a8 23				inc hl   ; position to the actual value 
b5a9 fe 01			cp DS_TYPE_STR 
b5ab 20 06			jr nz, .dotnum1  
b5ad			 
b5ad			; display string 
b5ad				FORTH_DSP_VALUE  
b5ad cd 8c 97			call macro_forth_dsp_value 
b5b0				endm 
# End of macro FORTH_DSP_VALUE
b5b0 eb				ex de,hl 
b5b1 18 11			jr .dotwrite 
b5b3			 
b5b3			.dotnum1: 
b5b3 fe 02			cp DS_TYPE_INUM 
b5b5 20 0c			jr nz, .dotflot 
b5b7			 
b5b7			 
b5b7			; display number 
b5b7			 
b5b7			;	push hl 
b5b7			;	call clear_display 
b5b7			;	pop hl 
b5b7			 
b5b7 5e				ld e, (hl) 
b5b8 23				inc hl 
b5b9 56				ld d, (hl) 
b5ba 21 75 e3			ld hl, scratch 
b5bd			if DEBUG_FORTH_DOT 
b5bd				DMARK "DT1" 
b5bd				CALLMONITOR 
b5bd			endif	 
b5bd			 
b5bd cd c4 8d			call uitoa_16 
b5c0 eb				ex de,hl 
b5c1			 
b5c1			if DEBUG_FORTH_DOT 
b5c1				DMARK "DT2" 
b5c1				CALLMONITOR 
b5c1			endif	 
b5c1			 
b5c1			;	ld de, os_word_scratch 
b5c1 18 01			jr .dotwrite 
b5c3			 
b5c3 00			.dotflot:   nop 
b5c4			; TODO print floating point number 
b5c4			 
b5c4			.dotwrite:		 
b5c4			 
b5c4					; if c is set then set all '-' to spaces 
b5c4					; need to also take into account .>  
b5c4			 
b5c4 3e 01				ld a, 1 
b5c6 b9					cp c 
b5c7 20 13				jr nz, .nodashswap 
b5c9			 
b5c9					; DE has the string to write, working with HL 
b5c9			 
b5c9 06 ff				ld b, 255 
b5cb d5					push de 
b5cc e1					pop hl 
b5cd			 
b5cd			if DEBUG_FORTH_DOT 
b5cd				DMARK "DT-" 
b5cd				CALLMONITOR 
b5cd			endif	 
b5cd 7e			.dashscan:	ld a, (hl) 
b5ce fe 00				cp 0 
b5d0 28 0a				jr z, .nodashswap 
b5d2 fe 2d				cp '-' 
b5d4 20 03				jr nz, .dashskip 
b5d6 3e 20				ld a, ' ' 
b5d8 77					ld (hl), a 
b5d9 23			.dashskip:	inc hl 
b5da			if DEBUG_FORTH_DOT 
b5da				DMARK "D-2" 
b5da				CALLMONITOR 
b5da			endif	 
b5da 10 f1				djnz .dashscan 
b5dc			 
b5dc			if DEBUG_FORTH_DOT 
b5dc				DMARK "D-1" 
b5dc				CALLMONITOR 
b5dc			endif	 
b5dc			 
b5dc			.nodashswap: 
b5dc			 
b5dc e5					push hl   ; save string start in case we need to advance print 
b5dd			 
b5dd 3a 5e eb				ld a, (f_cursor_ptr) 
b5e0 cd 71 88				call str_at_display 
b5e3 3a 3c eb				ld a,(cli_autodisplay) 
b5e6 fe 00				cp 0 
b5e8 28 03				jr z, .noupdate 
b5ea cd 81 88						call update_display 
b5ed					.noupdate: 
b5ed			 
b5ed			 
b5ed					; see if we need to advance the print position 
b5ed			 
b5ed e1					pop hl   ; get back string 
b5ee			 
b5ee 3a 3d eb				ld a, (cli_mvdot) 
b5f1			if DEBUG_FORTH_DOT 
b5f1					ld e,a 
b5f1				DMARK "D>1" 
b5f1				CALLMONITOR 
b5f1			endif	 
b5f1 fe 00				cp 0 
b5f3 28 0c				jr z, .noadv 
b5f5					; yes, lets advance the print position 
b5f5 3e 00				ld a, 0 
b5f7 cd 20 8e				call strlent 
b5fa 3a 5e eb				ld a, (f_cursor_ptr) 
b5fd 85					add a,l 
b5fe					;call addatohl 
b5fe					;ld a, l 
b5fe 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b601			 
b601			if DEBUG_FORTH_DOT 
b601				DMARK "D->" 
b601				CALLMONITOR 
b601			endif	 
b601			 
b601			.noadv:	 
b601			 
b601					if DEBUG_FORTH_DOT_WAIT 
b601							call next_page_prompt 
b601					endif	 
b601			; TODO this pop off the stack causes a crash. i dont know why 
b601			 
b601			 
b601			if DEBUG_FORTH_DOT 
b601				DMARK "DTh" 
b601				CALLMONITOR 
b601			endif	 
b601			 
b601					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b601 cd 3f 98			call macro_forth_dsp_pop 
b604				endm 
# End of macro FORTH_DSP_POP
b604			 
b604			if DEBUG_FORTH_DOT 
b604				DMARK "DTi" 
b604				CALLMONITOR 
b604			endif	 
b604			 
b604			 
b604					NEXTW 
b604 c3 f9 98			jp macro_next 
b607				endm 
# End of macro NEXTW
b607			 
b607			.CLS: 
b607				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b607 35				db WORD_SYS_CORE+33             
b608 34 b6			dw .DRAW            
b60a 04				db 3 + 1 
b60b .. 00			db "CLS",0              
b60f				endm 
# End of macro CWHEAD
b60f			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b60f					if DEBUG_FORTH_WORDS_KEY 
b60f						DMARK "CLS" 
b60f f5				push af  
b610 3a 24 b6			ld a, (.dmark)  
b613 32 7a ee			ld (debug_mark),a  
b616 3a 25 b6			ld a, (.dmark+1)  
b619 32 7b ee			ld (debug_mark+1),a  
b61c 3a 26 b6			ld a, (.dmark+2)  
b61f 32 7c ee			ld (debug_mark+2),a  
b622 18 03			jr .pastdmark  
b624 ..			.dmark: db "CLS"  
b627 f1			.pastdmark: pop af  
b628			endm  
# End of macro DMARK
b628						CALLMONITOR 
b628 cd 7b 91			call break_point_state  
b62b				endm  
# End of macro CALLMONITOR
b62b					endif 
b62b cd 5e 88				call clear_display 
b62e c3 42 b7				jp .home		; and home cursor 
b631					NEXTW 
b631 c3 f9 98			jp macro_next 
b634				endm 
# End of macro NEXTW
b634			 
b634			.DRAW: 
b634				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b634 36				db WORD_SYS_CORE+34             
b635 5f b6			dw .DUMP            
b637 05				db 4 + 1 
b638 .. 00			db "DRAW",0              
b63d				endm 
# End of macro CWHEAD
b63d			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b63d					if DEBUG_FORTH_WORDS_KEY 
b63d						DMARK "DRW" 
b63d f5				push af  
b63e 3a 52 b6			ld a, (.dmark)  
b641 32 7a ee			ld (debug_mark),a  
b644 3a 53 b6			ld a, (.dmark+1)  
b647 32 7b ee			ld (debug_mark+1),a  
b64a 3a 54 b6			ld a, (.dmark+2)  
b64d 32 7c ee			ld (debug_mark+2),a  
b650 18 03			jr .pastdmark  
b652 ..			.dmark: db "DRW"  
b655 f1			.pastdmark: pop af  
b656			endm  
# End of macro DMARK
b656						CALLMONITOR 
b656 cd 7b 91			call break_point_state  
b659				endm  
# End of macro CALLMONITOR
b659					endif 
b659 cd 81 88				call update_display 
b65c					NEXTW 
b65c c3 f9 98			jp macro_next 
b65f				endm 
# End of macro NEXTW
b65f			 
b65f			.DUMP: 
b65f				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b65f 37				db WORD_SYS_CORE+35             
b660 97 b6			dw .CDUMP            
b662 05				db 4 + 1 
b663 .. 00			db "DUMP",0              
b668				endm 
# End of macro CWHEAD
b668			; | DUMP ( x -- ) With address x display dump   | DONE 
b668			; TODO pop address to use off of the stack 
b668					if DEBUG_FORTH_WORDS_KEY 
b668						DMARK "DUM" 
b668 f5				push af  
b669 3a 7d b6			ld a, (.dmark)  
b66c 32 7a ee			ld (debug_mark),a  
b66f 3a 7e b6			ld a, (.dmark+1)  
b672 32 7b ee			ld (debug_mark+1),a  
b675 3a 7f b6			ld a, (.dmark+2)  
b678 32 7c ee			ld (debug_mark+2),a  
b67b 18 03			jr .pastdmark  
b67d ..			.dmark: db "DUM"  
b680 f1			.pastdmark: pop af  
b681			endm  
# End of macro DMARK
b681						CALLMONITOR 
b681 cd 7b 91			call break_point_state  
b684				endm  
# End of macro CALLMONITOR
b684					endif 
b684 cd 5e 88				call clear_display 
b687			 
b687					; get address 
b687			 
b687					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b687 cd a3 97			call macro_dsp_valuehl 
b68a				endm 
# End of macro FORTH_DSP_VALUEHL
b68a				 
b68a					; save it for cdump 
b68a			 
b68a 22 98 e6				ld (os_cur_ptr),hl 
b68d			 
b68d					; destroy value TOS 
b68d			 
b68d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b68d cd 3f 98			call macro_forth_dsp_pop 
b690				endm 
# End of macro FORTH_DSP_POP
b690			 
b690 cd 88 95				call dumpcont	; skip old style of param parsing	 
b693 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b694					NEXTW 
b694 c3 f9 98			jp macro_next 
b697				endm 
# End of macro NEXTW
b697			.CDUMP: 
b697				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b697 38				db WORD_SYS_CORE+36             
b698 c7 b6			dw .DAT            
b69a 06				db 5 + 1 
b69b .. 00			db "CDUMP",0              
b6a1				endm 
# End of macro CWHEAD
b6a1			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b6a1					if DEBUG_FORTH_WORDS_KEY 
b6a1						DMARK "CDP" 
b6a1 f5				push af  
b6a2 3a b6 b6			ld a, (.dmark)  
b6a5 32 7a ee			ld (debug_mark),a  
b6a8 3a b7 b6			ld a, (.dmark+1)  
b6ab 32 7b ee			ld (debug_mark+1),a  
b6ae 3a b8 b6			ld a, (.dmark+2)  
b6b1 32 7c ee			ld (debug_mark+2),a  
b6b4 18 03			jr .pastdmark  
b6b6 ..			.dmark: db "CDP"  
b6b9 f1			.pastdmark: pop af  
b6ba			endm  
# End of macro DMARK
b6ba						CALLMONITOR 
b6ba cd 7b 91			call break_point_state  
b6bd				endm  
# End of macro CALLMONITOR
b6bd					endif 
b6bd cd 5e 88				call clear_display 
b6c0 cd 88 95				call dumpcont	 
b6c3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b6c4					NEXTW 
b6c4 c3 f9 98			jp macro_next 
b6c7				endm 
# End of macro NEXTW
b6c7			 
b6c7			 
b6c7			 
b6c7			 
b6c7			.DAT: 
b6c7				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b6c7 3d				db WORD_SYS_CORE+41             
b6c8 1d b7			dw .HOME            
b6ca 03				db 2 + 1 
b6cb .. 00			db "AT",0              
b6ce				endm 
# End of macro CWHEAD
b6ce			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b6ce					if DEBUG_FORTH_WORDS_KEY 
b6ce						DMARK "AT." 
b6ce f5				push af  
b6cf 3a e3 b6			ld a, (.dmark)  
b6d2 32 7a ee			ld (debug_mark),a  
b6d5 3a e4 b6			ld a, (.dmark+1)  
b6d8 32 7b ee			ld (debug_mark+1),a  
b6db 3a e5 b6			ld a, (.dmark+2)  
b6de 32 7c ee			ld (debug_mark+2),a  
b6e1 18 03			jr .pastdmark  
b6e3 ..			.dmark: db "AT."  
b6e6 f1			.pastdmark: pop af  
b6e7			endm  
# End of macro DMARK
b6e7						CALLMONITOR 
b6e7 cd 7b 91			call break_point_state  
b6ea				endm  
# End of macro CALLMONITOR
b6ea					endif 
b6ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6ea cd a3 97			call macro_dsp_valuehl 
b6ed				endm 
# End of macro FORTH_DSP_VALUEHL
b6ed			 
b6ed			 
b6ed					; TODO save cursor row 
b6ed 7d					ld a,l 
b6ee fe 02				cp 2 
b6f0 20 04				jr nz, .crow3 
b6f2 3e 28				ld a, display_row_2 
b6f4 18 12				jr .ccol1 
b6f6 fe 03		.crow3:		cp 3 
b6f8 20 04				jr nz, .crow4 
b6fa 3e 50				ld a, display_row_3 
b6fc 18 0a				jr .ccol1 
b6fe fe 04		.crow4:		cp 4 
b700 20 04				jr nz, .crow1 
b702 3e 78				ld a, display_row_4 
b704 18 02				jr .ccol1 
b706 3e 00		.crow1:		ld a,display_row_1 
b708 f5			.ccol1:		push af			; got row offset 
b709 6f					ld l,a 
b70a 26 00				ld h,0 
b70c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b70c cd 3f 98			call macro_forth_dsp_pop 
b70f				endm 
# End of macro FORTH_DSP_POP
b70f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b70f cd a3 97			call macro_dsp_valuehl 
b712				endm 
# End of macro FORTH_DSP_VALUEHL
b712					; TODO save cursor col 
b712 f1					pop af 
b713 85					add l		; add col offset 
b714 32 5e eb				ld (f_cursor_ptr), a 
b717					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b717 cd 3f 98			call macro_forth_dsp_pop 
b71a				endm 
# End of macro FORTH_DSP_POP
b71a			 
b71a					; calculate  
b71a			 
b71a					NEXTW 
b71a c3 f9 98			jp macro_next 
b71d				endm 
# End of macro NEXTW
b71d			 
b71d			 
b71d			.HOME: 
b71d				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b71d 41				db WORD_SYS_CORE+45             
b71e 4a b7			dw .SPACE            
b720 05				db 4 + 1 
b721 .. 00			db "HOME",0              
b726				endm 
# End of macro CWHEAD
b726			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b726					if DEBUG_FORTH_WORDS_KEY 
b726						DMARK "HOM" 
b726 f5				push af  
b727 3a 3b b7			ld a, (.dmark)  
b72a 32 7a ee			ld (debug_mark),a  
b72d 3a 3c b7			ld a, (.dmark+1)  
b730 32 7b ee			ld (debug_mark+1),a  
b733 3a 3d b7			ld a, (.dmark+2)  
b736 32 7c ee			ld (debug_mark+2),a  
b739 18 03			jr .pastdmark  
b73b ..			.dmark: db "HOM"  
b73e f1			.pastdmark: pop af  
b73f			endm  
# End of macro DMARK
b73f						CALLMONITOR 
b73f cd 7b 91			call break_point_state  
b742				endm  
# End of macro CALLMONITOR
b742					endif 
b742 3e 00		.home:		ld a, 0		; and home cursor 
b744 32 5e eb				ld (f_cursor_ptr), a 
b747					NEXTW 
b747 c3 f9 98			jp macro_next 
b74a				endm 
# End of macro NEXTW
b74a			 
b74a			 
b74a			.SPACE: 
b74a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b74a 46				db WORD_SYS_CORE+50             
b74b 78 b7			dw .SPACES            
b74d 03				db 2 + 1 
b74e .. 00			db "BL",0              
b751				endm 
# End of macro CWHEAD
b751			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b751					if DEBUG_FORTH_WORDS_KEY 
b751						DMARK "BL." 
b751 f5				push af  
b752 3a 66 b7			ld a, (.dmark)  
b755 32 7a ee			ld (debug_mark),a  
b758 3a 67 b7			ld a, (.dmark+1)  
b75b 32 7b ee			ld (debug_mark+1),a  
b75e 3a 68 b7			ld a, (.dmark+2)  
b761 32 7c ee			ld (debug_mark+2),a  
b764 18 03			jr .pastdmark  
b766 ..			.dmark: db "BL."  
b769 f1			.pastdmark: pop af  
b76a			endm  
# End of macro DMARK
b76a						CALLMONITOR 
b76a cd 7b 91			call break_point_state  
b76d				endm  
# End of macro CALLMONITOR
b76d					endif 
b76d 21 76 b7				ld hl, .blstr 
b770 cd 1a 97				call forth_push_str 
b773					 
b773				       NEXTW 
b773 c3 f9 98			jp macro_next 
b776				endm 
# End of macro NEXTW
b776			 
b776 .. 00		.blstr: db " ", 0 
b778			 
b778			.SPACES: 
b778				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b778 47				db WORD_SYS_CORE+51             
b779 13 b8			dw .SCROLL            
b77b 07				db 6 + 1 
b77c .. 00			db "SPACES",0              
b783				endm 
# End of macro CWHEAD
b783			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b783					if DEBUG_FORTH_WORDS_KEY 
b783						DMARK "SPS" 
b783 f5				push af  
b784 3a 98 b7			ld a, (.dmark)  
b787 32 7a ee			ld (debug_mark),a  
b78a 3a 99 b7			ld a, (.dmark+1)  
b78d 32 7b ee			ld (debug_mark+1),a  
b790 3a 9a b7			ld a, (.dmark+2)  
b793 32 7c ee			ld (debug_mark+2),a  
b796 18 03			jr .pastdmark  
b798 ..			.dmark: db "SPS"  
b79b f1			.pastdmark: pop af  
b79c			endm  
# End of macro DMARK
b79c						CALLMONITOR 
b79c cd 7b 91			call break_point_state  
b79f				endm  
# End of macro CALLMONITOR
b79f					endif 
b79f			 
b79f			 
b79f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b79f cd a3 97			call macro_dsp_valuehl 
b7a2				endm 
# End of macro FORTH_DSP_VALUEHL
b7a2			 
b7a2			;		push hl    ; u 
b7a2					if DEBUG_FORTH_WORDS 
b7a2						DMARK "SPA" 
b7a2 f5				push af  
b7a3 3a b7 b7			ld a, (.dmark)  
b7a6 32 7a ee			ld (debug_mark),a  
b7a9 3a b8 b7			ld a, (.dmark+1)  
b7ac 32 7b ee			ld (debug_mark+1),a  
b7af 3a b9 b7			ld a, (.dmark+2)  
b7b2 32 7c ee			ld (debug_mark+2),a  
b7b5 18 03			jr .pastdmark  
b7b7 ..			.dmark: db "SPA"  
b7ba f1			.pastdmark: pop af  
b7bb			endm  
# End of macro DMARK
b7bb						CALLMONITOR 
b7bb cd 7b 91			call break_point_state  
b7be				endm  
# End of macro CALLMONITOR
b7be					endif 
b7be			 
b7be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7be cd 3f 98			call macro_forth_dsp_pop 
b7c1				endm 
# End of macro FORTH_DSP_POP
b7c1			;		pop hl 
b7c1 4d					ld c, l 
b7c2 06 00				ld b, 0 
b7c4 21 75 e3				ld hl, scratch  
b7c7			 
b7c7					if DEBUG_FORTH_WORDS 
b7c7						DMARK "SP2" 
b7c7 f5				push af  
b7c8 3a dc b7			ld a, (.dmark)  
b7cb 32 7a ee			ld (debug_mark),a  
b7ce 3a dd b7			ld a, (.dmark+1)  
b7d1 32 7b ee			ld (debug_mark+1),a  
b7d4 3a de b7			ld a, (.dmark+2)  
b7d7 32 7c ee			ld (debug_mark+2),a  
b7da 18 03			jr .pastdmark  
b7dc ..			.dmark: db "SP2"  
b7df f1			.pastdmark: pop af  
b7e0			endm  
# End of macro DMARK
b7e0						CALLMONITOR 
b7e0 cd 7b 91			call break_point_state  
b7e3				endm  
# End of macro CALLMONITOR
b7e3					endif 
b7e3 3e 20				ld a, ' ' 
b7e5 c5			.spaces1:	push bc 
b7e6 77					ld (hl),a 
b7e7 23					inc hl 
b7e8 c1					pop bc 
b7e9 10 fa				djnz .spaces1 
b7eb 3e 00				ld a,0 
b7ed 77					ld (hl),a 
b7ee 21 75 e3				ld hl, scratch 
b7f1					if DEBUG_FORTH_WORDS 
b7f1						DMARK "SP3" 
b7f1 f5				push af  
b7f2 3a 06 b8			ld a, (.dmark)  
b7f5 32 7a ee			ld (debug_mark),a  
b7f8 3a 07 b8			ld a, (.dmark+1)  
b7fb 32 7b ee			ld (debug_mark+1),a  
b7fe 3a 08 b8			ld a, (.dmark+2)  
b801 32 7c ee			ld (debug_mark+2),a  
b804 18 03			jr .pastdmark  
b806 ..			.dmark: db "SP3"  
b809 f1			.pastdmark: pop af  
b80a			endm  
# End of macro DMARK
b80a						CALLMONITOR 
b80a cd 7b 91			call break_point_state  
b80d				endm  
# End of macro CALLMONITOR
b80d					endif 
b80d cd 50 97				call forth_apush 
b810			 
b810				       NEXTW 
b810 c3 f9 98			jp macro_next 
b813				endm 
# End of macro NEXTW
b813			 
b813			 
b813			 
b813			.SCROLL: 
b813				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
b813 53				db WORD_SYS_CORE+63             
b814 40 b8			dw .ATQ            
b816 07				db 6 + 1 
b817 .. 00			db "SCROLL",0              
b81e				endm 
# End of macro CWHEAD
b81e			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
b81e					if DEBUG_FORTH_WORDS_KEY 
b81e						DMARK "SCR" 
b81e f5				push af  
b81f 3a 33 b8			ld a, (.dmark)  
b822 32 7a ee			ld (debug_mark),a  
b825 3a 34 b8			ld a, (.dmark+1)  
b828 32 7b ee			ld (debug_mark+1),a  
b82b 3a 35 b8			ld a, (.dmark+2)  
b82e 32 7c ee			ld (debug_mark+2),a  
b831 18 03			jr .pastdmark  
b833 ..			.dmark: db "SCR"  
b836 f1			.pastdmark: pop af  
b837			endm  
# End of macro DMARK
b837						CALLMONITOR 
b837 cd 7b 91			call break_point_state  
b83a				endm  
# End of macro CALLMONITOR
b83a					endif 
b83a			 
b83a cd f6 87			call scroll_up 
b83d			;	call update_display 
b83d			 
b83d					NEXTW 
b83d c3 f9 98			jp macro_next 
b840				endm 
# End of macro NEXTW
b840			 
b840			 
b840			 
b840			;		; get dir 
b840			; 
b840			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b840			; 
b840			;		push hl 
b840			; 
b840			;		; destroy value TOS 
b840			; 
b840			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b840			; 
b840			;		; get count 
b840			; 
b840			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b840			; 
b840			;		push hl 
b840			; 
b840			;		; destroy value TOS 
b840			; 
b840			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b840			; 
b840			;		; one value on hl get other one back 
b840			; 
b840			;		pop bc    ; count 
b840			; 
b840			;		pop de   ; dir 
b840			; 
b840			; 
b840			;		ld b, c 
b840			; 
b840			;.scrolldir:     push bc 
b840			;		push de 
b840			; 
b840			;		ld a, 0 
b840			;		cp e 
b840			;		jr z, .scrollup  
b840			;		call scroll_down 
b840			;		jr .scrollnext 
b840			;.scrollup:	call scroll_up 
b840			; 
b840			;		 
b840			;.scrollnext: 
b840			;		pop de 
b840			;		pop bc 
b840			;		djnz .scrolldir 
b840			; 
b840			; 
b840			; 
b840			; 
b840			; 
b840			;		NEXTW 
b840			 
b840			 
b840			 
b840			 
b840			.ATQ: 
b840				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
b840 62				db WORD_SYS_CORE+78             
b841 9e b8			dw .AUTODSP            
b843 04				db 3 + 1 
b844 .. 00			db "AT@",0              
b848				endm 
# End of macro CWHEAD
b848			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
b848					if DEBUG_FORTH_WORDS_KEY 
b848						DMARK "ATA" 
b848 f5				push af  
b849 3a 5d b8			ld a, (.dmark)  
b84c 32 7a ee			ld (debug_mark),a  
b84f 3a 5e b8			ld a, (.dmark+1)  
b852 32 7b ee			ld (debug_mark+1),a  
b855 3a 5f b8			ld a, (.dmark+2)  
b858 32 7c ee			ld (debug_mark+2),a  
b85b 18 03			jr .pastdmark  
b85d ..			.dmark: db "ATA"  
b860 f1			.pastdmark: pop af  
b861			endm  
# End of macro DMARK
b861						CALLMONITOR 
b861 cd 7b 91			call break_point_state  
b864				endm  
# End of macro CALLMONITOR
b864					endif 
b864			 
b864			 
b864					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b864 cd a3 97			call macro_dsp_valuehl 
b867				endm 
# End of macro FORTH_DSP_VALUEHL
b867			 
b867					; TODO save cursor row 
b867 7d					ld a,l 
b868 fe 02				cp 2 
b86a 20 04				jr nz, .crow3aq 
b86c 3e 28				ld a, display_row_2 
b86e 18 12				jr .ccol1aq 
b870 fe 03		.crow3aq:		cp 3 
b872 20 04				jr nz, .crow4aq 
b874 3e 50				ld a, display_row_3 
b876 18 0a				jr .ccol1aq 
b878 fe 04		.crow4aq:		cp 4 
b87a 20 04				jr nz, .crow1aq 
b87c 3e 78				ld a, display_row_4 
b87e 18 02				jr .ccol1aq 
b880 3e 00		.crow1aq:		ld a,display_row_1 
b882 f5			.ccol1aq:		push af			; got row offset 
b883 6f					ld l,a 
b884 26 00				ld h,0 
b886					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b886 cd 3f 98			call macro_forth_dsp_pop 
b889				endm 
# End of macro FORTH_DSP_POP
b889					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b889 cd a3 97			call macro_dsp_valuehl 
b88c				endm 
# End of macro FORTH_DSP_VALUEHL
b88c					; TODO save cursor col 
b88c f1					pop af 
b88d 85					add l		; add col offset 
b88e			 
b88e					; add current frame buffer address 
b88e 2a db eb				ld hl, (display_fb_active) 
b891 cd b7 89				call addatohl 
b894			 
b894			 
b894			 
b894			 
b894					; get char frame buffer location offset in hl 
b894			 
b894 7e					ld a,(hl) 
b895 26 00				ld h, 0 
b897 6f					ld l, a 
b898			 
b898 cd 08 97				call forth_push_numhl 
b89b			 
b89b			 
b89b					NEXTW 
b89b c3 f9 98			jp macro_next 
b89e				endm 
# End of macro NEXTW
b89e			 
b89e			.AUTODSP: 
b89e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
b89e 63				db WORD_SYS_CORE+79             
b89f b4 b8			dw .MENU            
b8a1 05				db 4 + 1 
b8a2 .. 00			db "ADSP",0              
b8a7				endm 
# End of macro CWHEAD
b8a7			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
b8a7			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
b8a7			 
b8a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8a7 cd a3 97			call macro_dsp_valuehl 
b8aa				endm 
# End of macro FORTH_DSP_VALUEHL
b8aa			 
b8aa			;		push hl 
b8aa			 
b8aa					; destroy value TOS 
b8aa			 
b8aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8aa cd 3f 98			call macro_forth_dsp_pop 
b8ad				endm 
# End of macro FORTH_DSP_POP
b8ad			 
b8ad			;		pop hl 
b8ad			 
b8ad 7d					ld a,l 
b8ae 32 3c eb				ld (cli_autodisplay), a 
b8b1				       NEXTW 
b8b1 c3 f9 98			jp macro_next 
b8b4				endm 
# End of macro NEXTW
b8b4			 
b8b4			.MENU: 
b8b4				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
b8b4 70				db WORD_SYS_CORE+92             
b8b5 c0 b8			dw .ENDDISPLAY            
b8b7 05				db 4 + 1 
b8b8 .. 00			db "MENU",0              
b8bd				endm 
# End of macro CWHEAD
b8bd			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
b8bd			 
b8bd					; get the title address and save it 
b8bd			 
b8bd			;		FORTH_DSP_VALUEHL 
b8bd			;		push hl 
b8bd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8bd			; 
b8bd			;		; get number of items on the stack 
b8bd			; 
b8bd			;	 
b8bd			;		FORTH_DSP_VALUEHL 
b8bd			;		push hl 
b8bd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8bd			 
b8bd			 
b8bd			 
b8bd			 
b8bd				       NEXTW 
b8bd c3 f9 98			jp macro_next 
b8c0				endm 
# End of macro NEXTW
b8c0			 
b8c0			 
b8c0			.ENDDISPLAY: 
b8c0			 
b8c0			; eof 
# End of file forth_words_display.asm
b8c0			include "forth_words_str.asm" 
b8c0			 
b8c0			; | ## String Words 
b8c0			 
b8c0			.PTR:   
b8c0			 
b8c0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
b8c0 48				db WORD_SYS_CORE+52             
b8c1 ed b8			dw .STYPE            
b8c3 04				db 3 + 1 
b8c4 .. 00			db "PTR",0              
b8c8				endm 
# End of macro CWHEAD
b8c8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
b8c8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
b8c8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
b8c8			 
b8c8					if DEBUG_FORTH_WORDS_KEY 
b8c8						DMARK "PTR" 
b8c8 f5				push af  
b8c9 3a dd b8			ld a, (.dmark)  
b8cc 32 7a ee			ld (debug_mark),a  
b8cf 3a de b8			ld a, (.dmark+1)  
b8d2 32 7b ee			ld (debug_mark+1),a  
b8d5 3a df b8			ld a, (.dmark+2)  
b8d8 32 7c ee			ld (debug_mark+2),a  
b8db 18 03			jr .pastdmark  
b8dd ..			.dmark: db "PTR"  
b8e0 f1			.pastdmark: pop af  
b8e1			endm  
# End of macro DMARK
b8e1						CALLMONITOR 
b8e1 cd 7b 91			call break_point_state  
b8e4				endm  
# End of macro CALLMONITOR
b8e4					endif 
b8e4					FORTH_DSP_VALUEHL 
b8e4 cd a3 97			call macro_dsp_valuehl 
b8e7				endm 
# End of macro FORTH_DSP_VALUEHL
b8e7 cd 08 97				call forth_push_numhl 
b8ea			 
b8ea			 
b8ea					NEXTW 
b8ea c3 f9 98			jp macro_next 
b8ed				endm 
# End of macro NEXTW
b8ed			.STYPE: 
b8ed				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
b8ed 48				db WORD_SYS_CORE+52             
b8ee 3c b9			dw .UPPER            
b8f0 06				db 5 + 1 
b8f1 .. 00			db "STYPE",0              
b8f7				endm 
# End of macro CWHEAD
b8f7			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
b8f7					if DEBUG_FORTH_WORDS_KEY 
b8f7						DMARK "STY" 
b8f7 f5				push af  
b8f8 3a 0c b9			ld a, (.dmark)  
b8fb 32 7a ee			ld (debug_mark),a  
b8fe 3a 0d b9			ld a, (.dmark+1)  
b901 32 7b ee			ld (debug_mark+1),a  
b904 3a 0e b9			ld a, (.dmark+2)  
b907 32 7c ee			ld (debug_mark+2),a  
b90a 18 03			jr .pastdmark  
b90c ..			.dmark: db "STY"  
b90f f1			.pastdmark: pop af  
b910			endm  
# End of macro DMARK
b910						CALLMONITOR 
b910 cd 7b 91			call break_point_state  
b913				endm  
# End of macro CALLMONITOR
b913					endif 
b913					FORTH_DSP 
b913 cd 88 97			call macro_forth_dsp 
b916				endm 
# End of macro FORTH_DSP
b916					;v5 FORTH_DSP_VALUE 
b916			 
b916 7e					ld a, (hl) 
b917			 
b917 f5					push af 
b918			 
b918			; Dont destroy TOS		FORTH_DSP_POP 
b918			 
b918 f1					pop af 
b919			 
b919 fe 01				cp DS_TYPE_STR 
b91b 28 09				jr z, .typestr 
b91d			 
b91d fe 02				cp DS_TYPE_INUM 
b91f 28 0a				jr z, .typeinum 
b921			 
b921 21 3a b9				ld hl, .tna 
b924 18 0a				jr .tpush 
b926			 
b926 21 36 b9		.typestr:	ld hl, .tstr 
b929 18 05				jr .tpush 
b92b 21 38 b9		.typeinum:	ld hl, .tinum 
b92e 18 00				jr .tpush 
b930			 
b930			.tpush: 
b930			 
b930 cd 1a 97				call forth_push_str 
b933			 
b933					NEXTW 
b933 c3 f9 98			jp macro_next 
b936				endm 
# End of macro NEXTW
b936 .. 00		.tstr:	db "s",0 
b938 .. 00		.tinum:  db "i",0 
b93a .. 00		.tna:   db "?", 0 
b93c			 
b93c			 
b93c			.UPPER: 
b93c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
b93c 48				db WORD_SYS_CORE+52             
b93d 77 b9			dw .LOWER            
b93f 06				db 5 + 1 
b940 .. 00			db "UPPER",0              
b946				endm 
# End of macro CWHEAD
b946			; | UPPER ( s -- s ) Upper case string s  | DONE 
b946					if DEBUG_FORTH_WORDS_KEY 
b946						DMARK "UPR" 
b946 f5				push af  
b947 3a 5b b9			ld a, (.dmark)  
b94a 32 7a ee			ld (debug_mark),a  
b94d 3a 5c b9			ld a, (.dmark+1)  
b950 32 7b ee			ld (debug_mark+1),a  
b953 3a 5d b9			ld a, (.dmark+2)  
b956 32 7c ee			ld (debug_mark+2),a  
b959 18 03			jr .pastdmark  
b95b ..			.dmark: db "UPR"  
b95e f1			.pastdmark: pop af  
b95f			endm  
# End of macro DMARK
b95f						CALLMONITOR 
b95f cd 7b 91			call break_point_state  
b962				endm  
# End of macro CALLMONITOR
b962					endif 
b962			 
b962					FORTH_DSP 
b962 cd 88 97			call macro_forth_dsp 
b965				endm 
# End of macro FORTH_DSP
b965					 
b965			; TODO check is string type 
b965			 
b965					FORTH_DSP_VALUEHL 
b965 cd a3 97			call macro_dsp_valuehl 
b968				endm 
# End of macro FORTH_DSP_VALUEHL
b968			; get pointer to string in hl 
b968			 
b968 7e			.toup:		ld a, (hl) 
b969 fe 00				cp 0 
b96b 28 07				jr z, .toupdone 
b96d			 
b96d cd 24 8d				call to_upper 
b970			 
b970 77					ld (hl), a 
b971 23					inc hl 
b972 18 f4				jr .toup 
b974			 
b974					 
b974			 
b974			 
b974			; for each char convert to upper 
b974					 
b974			.toupdone: 
b974			 
b974			 
b974					NEXTW 
b974 c3 f9 98			jp macro_next 
b977				endm 
# End of macro NEXTW
b977			.LOWER: 
b977				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
b977 48				db WORD_SYS_CORE+52             
b978 b2 b9			dw .TCASE            
b97a 06				db 5 + 1 
b97b .. 00			db "LOWER",0              
b981				endm 
# End of macro CWHEAD
b981			; | LOWER ( s -- s ) Lower case string s  | DONE 
b981					if DEBUG_FORTH_WORDS_KEY 
b981						DMARK "LWR" 
b981 f5				push af  
b982 3a 96 b9			ld a, (.dmark)  
b985 32 7a ee			ld (debug_mark),a  
b988 3a 97 b9			ld a, (.dmark+1)  
b98b 32 7b ee			ld (debug_mark+1),a  
b98e 3a 98 b9			ld a, (.dmark+2)  
b991 32 7c ee			ld (debug_mark+2),a  
b994 18 03			jr .pastdmark  
b996 ..			.dmark: db "LWR"  
b999 f1			.pastdmark: pop af  
b99a			endm  
# End of macro DMARK
b99a						CALLMONITOR 
b99a cd 7b 91			call break_point_state  
b99d				endm  
# End of macro CALLMONITOR
b99d					endif 
b99d			 
b99d					FORTH_DSP 
b99d cd 88 97			call macro_forth_dsp 
b9a0				endm 
# End of macro FORTH_DSP
b9a0					 
b9a0			; TODO check is string type 
b9a0			 
b9a0					FORTH_DSP_VALUEHL 
b9a0 cd a3 97			call macro_dsp_valuehl 
b9a3				endm 
# End of macro FORTH_DSP_VALUEHL
b9a3			; get pointer to string in hl 
b9a3			 
b9a3 7e			.tolow:		ld a, (hl) 
b9a4 fe 00				cp 0 
b9a6 28 07				jr z, .tolowdone 
b9a8			 
b9a8 cd 2d 8d				call to_lower 
b9ab			 
b9ab 77					ld (hl), a 
b9ac 23					inc hl 
b9ad 18 f4				jr .tolow 
b9af			 
b9af					 
b9af			 
b9af			 
b9af			; for each char convert to low 
b9af					 
b9af			.tolowdone: 
b9af					NEXTW 
b9af c3 f9 98			jp macro_next 
b9b2				endm 
# End of macro NEXTW
b9b2			.TCASE: 
b9b2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
b9b2 48				db WORD_SYS_CORE+52             
b9b3 e8 ba			dw .SUBSTR            
b9b5 06				db 5 + 1 
b9b6 .. 00			db "TCASE",0              
b9bc				endm 
# End of macro CWHEAD
b9bc			; | TCASE ( s -- s ) Title case string s  | DONE 
b9bc					if DEBUG_FORTH_WORDS_KEY 
b9bc						DMARK "TCS" 
b9bc f5				push af  
b9bd 3a d1 b9			ld a, (.dmark)  
b9c0 32 7a ee			ld (debug_mark),a  
b9c3 3a d2 b9			ld a, (.dmark+1)  
b9c6 32 7b ee			ld (debug_mark+1),a  
b9c9 3a d3 b9			ld a, (.dmark+2)  
b9cc 32 7c ee			ld (debug_mark+2),a  
b9cf 18 03			jr .pastdmark  
b9d1 ..			.dmark: db "TCS"  
b9d4 f1			.pastdmark: pop af  
b9d5			endm  
# End of macro DMARK
b9d5						CALLMONITOR 
b9d5 cd 7b 91			call break_point_state  
b9d8				endm  
# End of macro CALLMONITOR
b9d8					endif 
b9d8			 
b9d8					FORTH_DSP 
b9d8 cd 88 97			call macro_forth_dsp 
b9db				endm 
# End of macro FORTH_DSP
b9db					 
b9db			; TODO check is string type 
b9db			 
b9db					FORTH_DSP_VALUEHL 
b9db cd a3 97			call macro_dsp_valuehl 
b9de				endm 
# End of macro FORTH_DSP_VALUEHL
b9de			; get pointer to string in hl 
b9de			 
b9de					if DEBUG_FORTH_WORDS 
b9de						DMARK "TC1" 
b9de f5				push af  
b9df 3a f3 b9			ld a, (.dmark)  
b9e2 32 7a ee			ld (debug_mark),a  
b9e5 3a f4 b9			ld a, (.dmark+1)  
b9e8 32 7b ee			ld (debug_mark+1),a  
b9eb 3a f5 b9			ld a, (.dmark+2)  
b9ee 32 7c ee			ld (debug_mark+2),a  
b9f1 18 03			jr .pastdmark  
b9f3 ..			.dmark: db "TC1"  
b9f6 f1			.pastdmark: pop af  
b9f7			endm  
# End of macro DMARK
b9f7						CALLMONITOR 
b9f7 cd 7b 91			call break_point_state  
b9fa				endm  
# End of macro CALLMONITOR
b9fa					endif 
b9fa			 
b9fa					; first time in turn to upper case first char 
b9fa			 
b9fa 7e					ld a, (hl) 
b9fb c3 85 ba				jp .totsiptou 
b9fe			 
b9fe			 
b9fe 7e			.tot:		ld a, (hl) 
b9ff fe 00				cp 0 
ba01 ca c9 ba				jp z, .totdone 
ba04			 
ba04					if DEBUG_FORTH_WORDS 
ba04						DMARK "TC2" 
ba04 f5				push af  
ba05 3a 19 ba			ld a, (.dmark)  
ba08 32 7a ee			ld (debug_mark),a  
ba0b 3a 1a ba			ld a, (.dmark+1)  
ba0e 32 7b ee			ld (debug_mark+1),a  
ba11 3a 1b ba			ld a, (.dmark+2)  
ba14 32 7c ee			ld (debug_mark+2),a  
ba17 18 03			jr .pastdmark  
ba19 ..			.dmark: db "TC2"  
ba1c f1			.pastdmark: pop af  
ba1d			endm  
# End of macro DMARK
ba1d						CALLMONITOR 
ba1d cd 7b 91			call break_point_state  
ba20				endm  
# End of macro CALLMONITOR
ba20					endif 
ba20					; check to see if current char is a space 
ba20			 
ba20 fe 20				cp ' ' 
ba22 28 21				jr z, .totsp 
ba24 cd 2d 8d				call to_lower 
ba27					if DEBUG_FORTH_WORDS 
ba27						DMARK "TC3" 
ba27 f5				push af  
ba28 3a 3c ba			ld a, (.dmark)  
ba2b 32 7a ee			ld (debug_mark),a  
ba2e 3a 3d ba			ld a, (.dmark+1)  
ba31 32 7b ee			ld (debug_mark+1),a  
ba34 3a 3e ba			ld a, (.dmark+2)  
ba37 32 7c ee			ld (debug_mark+2),a  
ba3a 18 03			jr .pastdmark  
ba3c ..			.dmark: db "TC3"  
ba3f f1			.pastdmark: pop af  
ba40			endm  
# End of macro DMARK
ba40						CALLMONITOR 
ba40 cd 7b 91			call break_point_state  
ba43				endm  
# End of macro CALLMONITOR
ba43					endif 
ba43 18 63				jr .totnxt 
ba45			 
ba45			.totsp:         ; on a space, find next char which should be upper 
ba45			 
ba45					if DEBUG_FORTH_WORDS 
ba45						DMARK "TC4" 
ba45 f5				push af  
ba46 3a 5a ba			ld a, (.dmark)  
ba49 32 7a ee			ld (debug_mark),a  
ba4c 3a 5b ba			ld a, (.dmark+1)  
ba4f 32 7b ee			ld (debug_mark+1),a  
ba52 3a 5c ba			ld a, (.dmark+2)  
ba55 32 7c ee			ld (debug_mark+2),a  
ba58 18 03			jr .pastdmark  
ba5a ..			.dmark: db "TC4"  
ba5d f1			.pastdmark: pop af  
ba5e			endm  
# End of macro DMARK
ba5e						CALLMONITOR 
ba5e cd 7b 91			call break_point_state  
ba61				endm  
# End of macro CALLMONITOR
ba61					endif 
ba61					;; 
ba61			 
ba61 fe 20				cp ' ' 
ba63 20 20				jr nz, .totsiptou 
ba65 23					inc hl 
ba66 7e					ld a, (hl) 
ba67					if DEBUG_FORTH_WORDS 
ba67						DMARK "TC5" 
ba67 f5				push af  
ba68 3a 7c ba			ld a, (.dmark)  
ba6b 32 7a ee			ld (debug_mark),a  
ba6e 3a 7d ba			ld a, (.dmark+1)  
ba71 32 7b ee			ld (debug_mark+1),a  
ba74 3a 7e ba			ld a, (.dmark+2)  
ba77 32 7c ee			ld (debug_mark+2),a  
ba7a 18 03			jr .pastdmark  
ba7c ..			.dmark: db "TC5"  
ba7f f1			.pastdmark: pop af  
ba80			endm  
# End of macro DMARK
ba80						CALLMONITOR 
ba80 cd 7b 91			call break_point_state  
ba83				endm  
# End of macro CALLMONITOR
ba83					endif 
ba83 18 c0				jr .totsp 
ba85 fe 00		.totsiptou:    cp 0 
ba87 28 40				jr z, .totdone 
ba89					; not space and not zero term so upper case it 
ba89 cd 24 8d				call to_upper 
ba8c			 
ba8c					if DEBUG_FORTH_WORDS 
ba8c						DMARK "TC6" 
ba8c f5				push af  
ba8d 3a a1 ba			ld a, (.dmark)  
ba90 32 7a ee			ld (debug_mark),a  
ba93 3a a2 ba			ld a, (.dmark+1)  
ba96 32 7b ee			ld (debug_mark+1),a  
ba99 3a a3 ba			ld a, (.dmark+2)  
ba9c 32 7c ee			ld (debug_mark+2),a  
ba9f 18 03			jr .pastdmark  
baa1 ..			.dmark: db "TC6"  
baa4 f1			.pastdmark: pop af  
baa5			endm  
# End of macro DMARK
baa5						CALLMONITOR 
baa5 cd 7b 91			call break_point_state  
baa8				endm  
# End of macro CALLMONITOR
baa8					endif 
baa8			 
baa8			 
baa8			.totnxt: 
baa8			 
baa8 77					ld (hl), a 
baa9 23					inc hl 
baaa					if DEBUG_FORTH_WORDS 
baaa						DMARK "TC7" 
baaa f5				push af  
baab 3a bf ba			ld a, (.dmark)  
baae 32 7a ee			ld (debug_mark),a  
bab1 3a c0 ba			ld a, (.dmark+1)  
bab4 32 7b ee			ld (debug_mark+1),a  
bab7 3a c1 ba			ld a, (.dmark+2)  
baba 32 7c ee			ld (debug_mark+2),a  
babd 18 03			jr .pastdmark  
babf ..			.dmark: db "TC7"  
bac2 f1			.pastdmark: pop af  
bac3			endm  
# End of macro DMARK
bac3						CALLMONITOR 
bac3 cd 7b 91			call break_point_state  
bac6				endm  
# End of macro CALLMONITOR
bac6					endif 
bac6 c3 fe b9				jp .tot 
bac9			 
bac9					 
bac9			 
bac9			 
bac9			; for each char convert to low 
bac9					 
bac9			.totdone: 
bac9					if DEBUG_FORTH_WORDS 
bac9						DMARK "TCd" 
bac9 f5				push af  
baca 3a de ba			ld a, (.dmark)  
bacd 32 7a ee			ld (debug_mark),a  
bad0 3a df ba			ld a, (.dmark+1)  
bad3 32 7b ee			ld (debug_mark+1),a  
bad6 3a e0 ba			ld a, (.dmark+2)  
bad9 32 7c ee			ld (debug_mark+2),a  
badc 18 03			jr .pastdmark  
bade ..			.dmark: db "TCd"  
bae1 f1			.pastdmark: pop af  
bae2			endm  
# End of macro DMARK
bae2						CALLMONITOR 
bae2 cd 7b 91			call break_point_state  
bae5				endm  
# End of macro CALLMONITOR
bae5					endif 
bae5					NEXTW 
bae5 c3 f9 98			jp macro_next 
bae8				endm 
# End of macro NEXTW
bae8			 
bae8			.SUBSTR: 
bae8				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bae8 48				db WORD_SYS_CORE+52             
bae9 46 bb			dw .LEFT            
baeb 07				db 6 + 1 
baec .. 00			db "SUBSTR",0              
baf3				endm 
# End of macro CWHEAD
baf3			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
baf3			 
baf3					if DEBUG_FORTH_WORDS_KEY 
baf3						DMARK "SST" 
baf3 f5				push af  
baf4 3a 08 bb			ld a, (.dmark)  
baf7 32 7a ee			ld (debug_mark),a  
bafa 3a 09 bb			ld a, (.dmark+1)  
bafd 32 7b ee			ld (debug_mark+1),a  
bb00 3a 0a bb			ld a, (.dmark+2)  
bb03 32 7c ee			ld (debug_mark+2),a  
bb06 18 03			jr .pastdmark  
bb08 ..			.dmark: db "SST"  
bb0b f1			.pastdmark: pop af  
bb0c			endm  
# End of macro DMARK
bb0c						CALLMONITOR 
bb0c cd 7b 91			call break_point_state  
bb0f				endm  
# End of macro CALLMONITOR
bb0f					endif 
bb0f			; TODO check string type 
bb0f					FORTH_DSP_VALUEHL 
bb0f cd a3 97			call macro_dsp_valuehl 
bb12				endm 
# End of macro FORTH_DSP_VALUEHL
bb12			 
bb12 e5					push hl      ; string length 
bb13			 
bb13					FORTH_DSP_POP 
bb13 cd 3f 98			call macro_forth_dsp_pop 
bb16				endm 
# End of macro FORTH_DSP_POP
bb16			 
bb16					FORTH_DSP_VALUEHL 
bb16 cd a3 97			call macro_dsp_valuehl 
bb19				endm 
# End of macro FORTH_DSP_VALUEHL
bb19			 
bb19 e5					push hl     ; start char 
bb1a			 
bb1a					FORTH_DSP_POP 
bb1a cd 3f 98			call macro_forth_dsp_pop 
bb1d				endm 
# End of macro FORTH_DSP_POP
bb1d			 
bb1d			 
bb1d					FORTH_DSP_VALUE 
bb1d cd 8c 97			call macro_forth_dsp_value 
bb20				endm 
# End of macro FORTH_DSP_VALUE
bb20			 
bb20 d1					pop de    ; get start post offset 
bb21			 
bb21 19					add hl, de    ; starting offset 
bb22			 
bb22 c1					pop bc 
bb23 c5					push bc      ; grab size of string 
bb24			 
bb24 e5					push hl    ; save string start  
bb25			 
bb25 26 00				ld h, 0 
bb27 69					ld l, c 
bb28 23					inc hl 
bb29 23					inc hl 
bb2a			 
bb2a cd 7e 8e				call malloc 
bb2d				if DEBUG_FORTH_MALLOC_GUARD 
bb2d cc 5c c1				call z,malloc_error 
bb30				endif 
bb30			 
bb30 eb					ex de, hl      ; save malloc area for string copy 
bb31 e1					pop hl    ; get back source 
bb32 c1					pop bc    ; get length of string back 
bb33			 
bb33 d5					push de    ; save malloc area for after we push 
bb34 ed b0				ldir     ; copy substr 
bb36			 
bb36			 
bb36 eb					ex de, hl 
bb37 3e 00				ld a, 0 
bb39 77					ld (hl), a   ; term substr 
bb3a			 
bb3a					 
bb3a e1					pop hl    ; get malloc so we can push it 
bb3b e5					push hl   ; save so we can free it afterwards 
bb3c			 
bb3c cd 1a 97				call forth_push_str 
bb3f			 
bb3f e1					pop hl 
bb40 cd 48 8f				call free 
bb43			 
bb43					 
bb43					 
bb43			 
bb43			 
bb43					NEXTW 
bb43 c3 f9 98			jp macro_next 
bb46				endm 
# End of macro NEXTW
bb46			 
bb46			.LEFT: 
bb46				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bb46 48				db WORD_SYS_CORE+52             
bb47 6e bb			dw .RIGHT            
bb49 05				db 4 + 1 
bb4a .. 00			db "LEFT",0              
bb4f				endm 
# End of macro CWHEAD
bb4f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bb4f					if DEBUG_FORTH_WORDS_KEY 
bb4f						DMARK "LEF" 
bb4f f5				push af  
bb50 3a 64 bb			ld a, (.dmark)  
bb53 32 7a ee			ld (debug_mark),a  
bb56 3a 65 bb			ld a, (.dmark+1)  
bb59 32 7b ee			ld (debug_mark+1),a  
bb5c 3a 66 bb			ld a, (.dmark+2)  
bb5f 32 7c ee			ld (debug_mark+2),a  
bb62 18 03			jr .pastdmark  
bb64 ..			.dmark: db "LEF"  
bb67 f1			.pastdmark: pop af  
bb68			endm  
# End of macro DMARK
bb68						CALLMONITOR 
bb68 cd 7b 91			call break_point_state  
bb6b				endm  
# End of macro CALLMONITOR
bb6b					endif 
bb6b			 
bb6b					NEXTW 
bb6b c3 f9 98			jp macro_next 
bb6e				endm 
# End of macro NEXTW
bb6e			.RIGHT: 
bb6e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bb6e 48				db WORD_SYS_CORE+52             
bb6f 97 bb			dw .STR2NUM            
bb71 06				db 5 + 1 
bb72 .. 00			db "RIGHT",0              
bb78				endm 
# End of macro CWHEAD
bb78			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bb78					if DEBUG_FORTH_WORDS_KEY 
bb78						DMARK "RIG" 
bb78 f5				push af  
bb79 3a 8d bb			ld a, (.dmark)  
bb7c 32 7a ee			ld (debug_mark),a  
bb7f 3a 8e bb			ld a, (.dmark+1)  
bb82 32 7b ee			ld (debug_mark+1),a  
bb85 3a 8f bb			ld a, (.dmark+2)  
bb88 32 7c ee			ld (debug_mark+2),a  
bb8b 18 03			jr .pastdmark  
bb8d ..			.dmark: db "RIG"  
bb90 f1			.pastdmark: pop af  
bb91			endm  
# End of macro DMARK
bb91						CALLMONITOR 
bb91 cd 7b 91			call break_point_state  
bb94				endm  
# End of macro CALLMONITOR
bb94					endif 
bb94			 
bb94					NEXTW 
bb94 c3 f9 98			jp macro_next 
bb97				endm 
# End of macro NEXTW
bb97			 
bb97			 
bb97			.STR2NUM: 
bb97				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bb97 48				db WORD_SYS_CORE+52             
bb98 23 bc			dw .NUM2STR            
bb9a 08				db 7 + 1 
bb9b .. 00			db "STR2NUM",0              
bba3				endm 
# End of macro CWHEAD
bba3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bba3			 
bba3			 
bba3			; TODO STR type check to do 
bba3					if DEBUG_FORTH_WORDS_KEY 
bba3						DMARK "S2N" 
bba3 f5				push af  
bba4 3a b8 bb			ld a, (.dmark)  
bba7 32 7a ee			ld (debug_mark),a  
bbaa 3a b9 bb			ld a, (.dmark+1)  
bbad 32 7b ee			ld (debug_mark+1),a  
bbb0 3a ba bb			ld a, (.dmark+2)  
bbb3 32 7c ee			ld (debug_mark+2),a  
bbb6 18 03			jr .pastdmark  
bbb8 ..			.dmark: db "S2N"  
bbbb f1			.pastdmark: pop af  
bbbc			endm  
# End of macro DMARK
bbbc						CALLMONITOR 
bbbc cd 7b 91			call break_point_state  
bbbf				endm  
# End of macro CALLMONITOR
bbbf					endif 
bbbf			 
bbbf					;FORTH_DSP 
bbbf					FORTH_DSP_VALUE 
bbbf cd 8c 97			call macro_forth_dsp_value 
bbc2				endm 
# End of macro FORTH_DSP_VALUE
bbc2					;inc hl 
bbc2			 
bbc2 eb					ex de, hl 
bbc3					if DEBUG_FORTH_WORDS 
bbc3						DMARK "S2a" 
bbc3 f5				push af  
bbc4 3a d8 bb			ld a, (.dmark)  
bbc7 32 7a ee			ld (debug_mark),a  
bbca 3a d9 bb			ld a, (.dmark+1)  
bbcd 32 7b ee			ld (debug_mark+1),a  
bbd0 3a da bb			ld a, (.dmark+2)  
bbd3 32 7c ee			ld (debug_mark+2),a  
bbd6 18 03			jr .pastdmark  
bbd8 ..			.dmark: db "S2a"  
bbdb f1			.pastdmark: pop af  
bbdc			endm  
# End of macro DMARK
bbdc						CALLMONITOR 
bbdc cd 7b 91			call break_point_state  
bbdf				endm  
# End of macro CALLMONITOR
bbdf					endif 
bbdf cd ac 8d				call string_to_uint16 
bbe2			 
bbe2					if DEBUG_FORTH_WORDS 
bbe2						DMARK "S2b" 
bbe2 f5				push af  
bbe3 3a f7 bb			ld a, (.dmark)  
bbe6 32 7a ee			ld (debug_mark),a  
bbe9 3a f8 bb			ld a, (.dmark+1)  
bbec 32 7b ee			ld (debug_mark+1),a  
bbef 3a f9 bb			ld a, (.dmark+2)  
bbf2 32 7c ee			ld (debug_mark+2),a  
bbf5 18 03			jr .pastdmark  
bbf7 ..			.dmark: db "S2b"  
bbfa f1			.pastdmark: pop af  
bbfb			endm  
# End of macro DMARK
bbfb						CALLMONITOR 
bbfb cd 7b 91			call break_point_state  
bbfe				endm  
# End of macro CALLMONITOR
bbfe					endif 
bbfe			;		push hl 
bbfe					FORTH_DSP_POP 
bbfe cd 3f 98			call macro_forth_dsp_pop 
bc01				endm 
# End of macro FORTH_DSP_POP
bc01			;		pop hl 
bc01					 
bc01					if DEBUG_FORTH_WORDS 
bc01						DMARK "S2b" 
bc01 f5				push af  
bc02 3a 16 bc			ld a, (.dmark)  
bc05 32 7a ee			ld (debug_mark),a  
bc08 3a 17 bc			ld a, (.dmark+1)  
bc0b 32 7b ee			ld (debug_mark+1),a  
bc0e 3a 18 bc			ld a, (.dmark+2)  
bc11 32 7c ee			ld (debug_mark+2),a  
bc14 18 03			jr .pastdmark  
bc16 ..			.dmark: db "S2b"  
bc19 f1			.pastdmark: pop af  
bc1a			endm  
# End of macro DMARK
bc1a						CALLMONITOR 
bc1a cd 7b 91			call break_point_state  
bc1d				endm  
# End of macro CALLMONITOR
bc1d					endif 
bc1d cd 08 97				call forth_push_numhl	 
bc20			 
bc20				 
bc20				       NEXTW 
bc20 c3 f9 98			jp macro_next 
bc23				endm 
# End of macro NEXTW
bc23			.NUM2STR: 
bc23				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bc23 48				db WORD_SYS_CORE+52             
bc24 32 bc			dw .CONCAT            
bc26 08				db 7 + 1 
bc27 .. 00			db "NUM2STR",0              
bc2f				endm 
# End of macro CWHEAD
bc2f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bc2f			 
bc2f			;		; malloc a string to target 
bc2f			;		ld hl, 10     ; TODO max string size should be fine 
bc2f			;		call malloc 
bc2f			;		push hl    ; save malloc location 
bc2f			; 
bc2f			; 
bc2f			;; TODO check int type 
bc2f			;		FORTH_DSP_VALUEHL 
bc2f			;		ld a, l 
bc2f			;		call DispAToASCII   
bc2f			;;TODO need to chage above call to dump into string 
bc2f			; 
bc2f			; 
bc2f			 
bc2f				       NEXTW 
bc2f c3 f9 98			jp macro_next 
bc32				endm 
# End of macro NEXTW
bc32			 
bc32			.CONCAT: 
bc32				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bc32 48				db WORD_SYS_CORE+52             
bc33 e5 bc			dw .FIND            
bc35 07				db 6 + 1 
bc36 .. 00			db "CONCAT",0              
bc3d				endm 
# End of macro CWHEAD
bc3d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bc3d			 
bc3d			; TODO check string type 
bc3d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bc3d			 
bc3d					if DEBUG_FORTH_WORDS_KEY 
bc3d						DMARK "CON" 
bc3d f5				push af  
bc3e 3a 52 bc			ld a, (.dmark)  
bc41 32 7a ee			ld (debug_mark),a  
bc44 3a 53 bc			ld a, (.dmark+1)  
bc47 32 7b ee			ld (debug_mark+1),a  
bc4a 3a 54 bc			ld a, (.dmark+2)  
bc4d 32 7c ee			ld (debug_mark+2),a  
bc50 18 03			jr .pastdmark  
bc52 ..			.dmark: db "CON"  
bc55 f1			.pastdmark: pop af  
bc56			endm  
# End of macro DMARK
bc56						CALLMONITOR 
bc56 cd 7b 91			call break_point_state  
bc59				endm  
# End of macro CALLMONITOR
bc59					endif 
bc59			 
bc59			 
bc59					FORTH_DSP_VALUE 
bc59 cd 8c 97			call macro_forth_dsp_value 
bc5c				endm 
# End of macro FORTH_DSP_VALUE
bc5c e5					push hl   ; s2 
bc5d			 
bc5d					FORTH_DSP_POP 
bc5d cd 3f 98			call macro_forth_dsp_pop 
bc60				endm 
# End of macro FORTH_DSP_POP
bc60			 
bc60					FORTH_DSP_VALUE 
bc60 cd 8c 97			call macro_forth_dsp_value 
bc63				endm 
# End of macro FORTH_DSP_VALUE
bc63			 
bc63 e5					push hl   ; s1 
bc64			 
bc64					FORTH_DSP_POP 
bc64 cd 3f 98			call macro_forth_dsp_pop 
bc67				endm 
# End of macro FORTH_DSP_POP
bc67					 
bc67			 
bc67					; copy s1 
bc67			 
bc67				 
bc67					; save ptr 
bc67 e1					pop hl  
bc68 e5					push hl 
bc69 3e 00				ld a, 0 
bc6b cd 20 8e				call strlent 
bc6e					;inc hl    ; zer0 
bc6e 06 00				ld b, 0 
bc70 4d					ld c, l 
bc71 e1					pop hl		 
bc72 11 75 e3				ld de, scratch	 
bc75					if DEBUG_FORTH_WORDS 
bc75						DMARK "CO1" 
bc75 f5				push af  
bc76 3a 8a bc			ld a, (.dmark)  
bc79 32 7a ee			ld (debug_mark),a  
bc7c 3a 8b bc			ld a, (.dmark+1)  
bc7f 32 7b ee			ld (debug_mark+1),a  
bc82 3a 8c bc			ld a, (.dmark+2)  
bc85 32 7c ee			ld (debug_mark+2),a  
bc88 18 03			jr .pastdmark  
bc8a ..			.dmark: db "CO1"  
bc8d f1			.pastdmark: pop af  
bc8e			endm  
# End of macro DMARK
bc8e						CALLMONITOR 
bc8e cd 7b 91			call break_point_state  
bc91				endm  
# End of macro CALLMONITOR
bc91					endif 
bc91 ed b0				ldir 
bc93			 
bc93 e1					pop hl 
bc94 e5					push hl 
bc95 d5					push de 
bc96			 
bc96			 
bc96 3e 00				ld a, 0 
bc98 cd 20 8e				call strlent 
bc9b 23					inc hl    ; zer0 
bc9c 23					inc hl 
bc9d 06 00				ld b, 0 
bc9f 4d					ld c, l 
bca0 d1					pop de 
bca1 e1					pop hl		 
bca2					if DEBUG_FORTH_WORDS 
bca2						DMARK "CO2" 
bca2 f5				push af  
bca3 3a b7 bc			ld a, (.dmark)  
bca6 32 7a ee			ld (debug_mark),a  
bca9 3a b8 bc			ld a, (.dmark+1)  
bcac 32 7b ee			ld (debug_mark+1),a  
bcaf 3a b9 bc			ld a, (.dmark+2)  
bcb2 32 7c ee			ld (debug_mark+2),a  
bcb5 18 03			jr .pastdmark  
bcb7 ..			.dmark: db "CO2"  
bcba f1			.pastdmark: pop af  
bcbb			endm  
# End of macro DMARK
bcbb						CALLMONITOR 
bcbb cd 7b 91			call break_point_state  
bcbe				endm  
# End of macro CALLMONITOR
bcbe					endif 
bcbe ed b0				ldir 
bcc0			 
bcc0			 
bcc0			 
bcc0 21 75 e3				ld hl, scratch 
bcc3					if DEBUG_FORTH_WORDS 
bcc3						DMARK "CO5" 
bcc3 f5				push af  
bcc4 3a d8 bc			ld a, (.dmark)  
bcc7 32 7a ee			ld (debug_mark),a  
bcca 3a d9 bc			ld a, (.dmark+1)  
bccd 32 7b ee			ld (debug_mark+1),a  
bcd0 3a da bc			ld a, (.dmark+2)  
bcd3 32 7c ee			ld (debug_mark+2),a  
bcd6 18 03			jr .pastdmark  
bcd8 ..			.dmark: db "CO5"  
bcdb f1			.pastdmark: pop af  
bcdc			endm  
# End of macro DMARK
bcdc						CALLMONITOR 
bcdc cd 7b 91			call break_point_state  
bcdf				endm  
# End of macro CALLMONITOR
bcdf					endif 
bcdf			 
bcdf cd 1a 97				call forth_push_str 
bce2			 
bce2			 
bce2			 
bce2			 
bce2				       NEXTW 
bce2 c3 f9 98			jp macro_next 
bce5				endm 
# End of macro NEXTW
bce5			 
bce5			 
bce5			.FIND: 
bce5				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bce5 4b				db WORD_SYS_CORE+55             
bce6 a3 bd			dw .LEN            
bce8 05				db 4 + 1 
bce9 .. 00			db "FIND",0              
bcee				endm 
# End of macro CWHEAD
bcee			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bcee			 
bcee					if DEBUG_FORTH_WORDS_KEY 
bcee						DMARK "FND" 
bcee f5				push af  
bcef 3a 03 bd			ld a, (.dmark)  
bcf2 32 7a ee			ld (debug_mark),a  
bcf5 3a 04 bd			ld a, (.dmark+1)  
bcf8 32 7b ee			ld (debug_mark+1),a  
bcfb 3a 05 bd			ld a, (.dmark+2)  
bcfe 32 7c ee			ld (debug_mark+2),a  
bd01 18 03			jr .pastdmark  
bd03 ..			.dmark: db "FND"  
bd06 f1			.pastdmark: pop af  
bd07			endm  
# End of macro DMARK
bd07						CALLMONITOR 
bd07 cd 7b 91			call break_point_state  
bd0a				endm  
# End of macro CALLMONITOR
bd0a					endif 
bd0a			 
bd0a			; TODO check string type 
bd0a					FORTH_DSP_VALUE 
bd0a cd 8c 97			call macro_forth_dsp_value 
bd0d				endm 
# End of macro FORTH_DSP_VALUE
bd0d			 
bd0d e5					push hl    
bd0e 7e					ld a,(hl)    ; char to find   
bd0f			; TODO change char to substr 
bd0f			 
bd0f f5					push af 
bd10					 
bd10			 
bd10			 
bd10					if DEBUG_FORTH_WORDS 
bd10						DMARK "FN1" 
bd10 f5				push af  
bd11 3a 25 bd			ld a, (.dmark)  
bd14 32 7a ee			ld (debug_mark),a  
bd17 3a 26 bd			ld a, (.dmark+1)  
bd1a 32 7b ee			ld (debug_mark+1),a  
bd1d 3a 27 bd			ld a, (.dmark+2)  
bd20 32 7c ee			ld (debug_mark+2),a  
bd23 18 03			jr .pastdmark  
bd25 ..			.dmark: db "FN1"  
bd28 f1			.pastdmark: pop af  
bd29			endm  
# End of macro DMARK
bd29						CALLMONITOR 
bd29 cd 7b 91			call break_point_state  
bd2c				endm  
# End of macro CALLMONITOR
bd2c					endif 
bd2c			 
bd2c					FORTH_DSP_POP 
bd2c cd 3f 98			call macro_forth_dsp_pop 
bd2f				endm 
# End of macro FORTH_DSP_POP
bd2f			 
bd2f					; string to search 
bd2f			 
bd2f					FORTH_DSP_VALUE 
bd2f cd 8c 97			call macro_forth_dsp_value 
bd32				endm 
# End of macro FORTH_DSP_VALUE
bd32			 
bd32 d1					pop de  ; d is char to find  
bd33			 
bd33					if DEBUG_FORTH_WORDS 
bd33						DMARK "FN2" 
bd33 f5				push af  
bd34 3a 48 bd			ld a, (.dmark)  
bd37 32 7a ee			ld (debug_mark),a  
bd3a 3a 49 bd			ld a, (.dmark+1)  
bd3d 32 7b ee			ld (debug_mark+1),a  
bd40 3a 4a bd			ld a, (.dmark+2)  
bd43 32 7c ee			ld (debug_mark+2),a  
bd46 18 03			jr .pastdmark  
bd48 ..			.dmark: db "FN2"  
bd4b f1			.pastdmark: pop af  
bd4c			endm  
# End of macro DMARK
bd4c						CALLMONITOR 
bd4c cd 7b 91			call break_point_state  
bd4f				endm  
# End of macro CALLMONITOR
bd4f					endif 
bd4f					 
bd4f 01 00 00				ld bc, 0 
bd52 7e			.findchar:      ld a,(hl) 
bd53 fe 00				cp 0   		 
bd55 28 27				jr z, .finddone     
bd57 ba					cp d 
bd58 28 20				jr z, .foundchar 
bd5a 03					inc bc 
bd5b 23					inc hl 
bd5c					if DEBUG_FORTH_WORDS 
bd5c						DMARK "FN3" 
bd5c f5				push af  
bd5d 3a 71 bd			ld a, (.dmark)  
bd60 32 7a ee			ld (debug_mark),a  
bd63 3a 72 bd			ld a, (.dmark+1)  
bd66 32 7b ee			ld (debug_mark+1),a  
bd69 3a 73 bd			ld a, (.dmark+2)  
bd6c 32 7c ee			ld (debug_mark+2),a  
bd6f 18 03			jr .pastdmark  
bd71 ..			.dmark: db "FN3"  
bd74 f1			.pastdmark: pop af  
bd75			endm  
# End of macro DMARK
bd75						CALLMONITOR 
bd75 cd 7b 91			call break_point_state  
bd78				endm  
# End of macro CALLMONITOR
bd78					endif 
bd78 18 d8				jr .findchar 
bd7a			 
bd7a			 
bd7a c5			.foundchar:	push bc 
bd7b e1					pop hl 
bd7c 18 03				jr .findexit 
bd7e			 
bd7e			 
bd7e							 
bd7e			 
bd7e			.finddone:     ; got to end of string with no find 
bd7e 21 00 00				ld hl, 0 
bd81			.findexit: 
bd81			 
bd81					if DEBUG_FORTH_WORDS 
bd81						DMARK "FNd" 
bd81 f5				push af  
bd82 3a 96 bd			ld a, (.dmark)  
bd85 32 7a ee			ld (debug_mark),a  
bd88 3a 97 bd			ld a, (.dmark+1)  
bd8b 32 7b ee			ld (debug_mark+1),a  
bd8e 3a 98 bd			ld a, (.dmark+2)  
bd91 32 7c ee			ld (debug_mark+2),a  
bd94 18 03			jr .pastdmark  
bd96 ..			.dmark: db "FNd"  
bd99 f1			.pastdmark: pop af  
bd9a			endm  
# End of macro DMARK
bd9a						CALLMONITOR 
bd9a cd 7b 91			call break_point_state  
bd9d				endm  
# End of macro CALLMONITOR
bd9d					endif 
bd9d cd 08 97			call forth_push_numhl 
bda0			 
bda0				       NEXTW 
bda0 c3 f9 98			jp macro_next 
bda3				endm 
# End of macro NEXTW
bda3			 
bda3			.LEN: 
bda3				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
bda3 4c				db WORD_SYS_CORE+56             
bda4 d8 bd			dw .CHAR            
bda6 06				db 5 + 1 
bda7 .. 00			db "COUNT",0              
bdad				endm 
# End of macro CWHEAD
bdad			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
bdad			 
bdad					if DEBUG_FORTH_WORDS_KEY 
bdad						DMARK "CNT" 
bdad f5				push af  
bdae 3a c2 bd			ld a, (.dmark)  
bdb1 32 7a ee			ld (debug_mark),a  
bdb4 3a c3 bd			ld a, (.dmark+1)  
bdb7 32 7b ee			ld (debug_mark+1),a  
bdba 3a c4 bd			ld a, (.dmark+2)  
bdbd 32 7c ee			ld (debug_mark+2),a  
bdc0 18 03			jr .pastdmark  
bdc2 ..			.dmark: db "CNT"  
bdc5 f1			.pastdmark: pop af  
bdc6			endm  
# End of macro DMARK
bdc6						CALLMONITOR 
bdc6 cd 7b 91			call break_point_state  
bdc9				endm  
# End of macro CALLMONITOR
bdc9					endif 
bdc9			; TODO check string type 
bdc9					FORTH_DSP 
bdc9 cd 88 97			call macro_forth_dsp 
bdcc				endm 
# End of macro FORTH_DSP
bdcc					;v5FORTH_DSP_VALUE 
bdcc			 
bdcc 23					inc hl 
bdcd			 
bdcd 3e 00				ld a, 0 
bdcf cd 20 8e				call strlent 
bdd2			 
bdd2 cd 08 97				call forth_push_numhl 
bdd5			 
bdd5			 
bdd5			 
bdd5				       NEXTW 
bdd5 c3 f9 98			jp macro_next 
bdd8				endm 
# End of macro NEXTW
bdd8			.CHAR: 
bdd8				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
bdd8 4d				db WORD_SYS_CORE+57             
bdd9 0e be			dw .ENDSTR            
bddb 05				db 4 + 1 
bddc .. 00			db "CHAR",0              
bde1				endm 
# End of macro CWHEAD
bde1			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
bde1					if DEBUG_FORTH_WORDS_KEY 
bde1						DMARK "CHR" 
bde1 f5				push af  
bde2 3a f6 bd			ld a, (.dmark)  
bde5 32 7a ee			ld (debug_mark),a  
bde8 3a f7 bd			ld a, (.dmark+1)  
bdeb 32 7b ee			ld (debug_mark+1),a  
bdee 3a f8 bd			ld a, (.dmark+2)  
bdf1 32 7c ee			ld (debug_mark+2),a  
bdf4 18 03			jr .pastdmark  
bdf6 ..			.dmark: db "CHR"  
bdf9 f1			.pastdmark: pop af  
bdfa			endm  
# End of macro DMARK
bdfa						CALLMONITOR 
bdfa cd 7b 91			call break_point_state  
bdfd				endm  
# End of macro CALLMONITOR
bdfd					endif 
bdfd					FORTH_DSP 
bdfd cd 88 97			call macro_forth_dsp 
be00				endm 
# End of macro FORTH_DSP
be00					;v5 FORTH_DSP_VALUE 
be00 23					inc hl      ; now at start of numeric as string 
be01			 
be01			;		push hl 
be01			 
be01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be01 cd 3f 98			call macro_forth_dsp_pop 
be04				endm 
# End of macro FORTH_DSP_POP
be04			 
be04			;		pop hl 
be04			 
be04					; push the content of a onto the stack as a value 
be04			 
be04 7e					ld a,(hl)   ; get char 
be05 26 00				ld h,0 
be07 6f					ld l,a 
be08 cd 08 97				call forth_push_numhl 
be0b			 
be0b				       NEXTW 
be0b c3 f9 98			jp macro_next 
be0e				endm 
# End of macro NEXTW
be0e			 
be0e			 
be0e			 
be0e			 
be0e			.ENDSTR: 
be0e			; eof 
be0e			 
# End of file forth_words_str.asm
be0e			include "forth_words_key.asm" 
be0e			 
be0e			; | ## Keyboard Words 
be0e			 
be0e			.KEY: 
be0e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
be0e 3e				db WORD_SYS_CORE+42             
be0f 3e be			dw .WAITK            
be11 04				db 3 + 1 
be12 .. 00			db "KEY",0              
be16				endm 
# End of macro CWHEAD
be16			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
be16			 
be16					if DEBUG_FORTH_WORDS_KEY 
be16						DMARK "KEY" 
be16 f5				push af  
be17 3a 2b be			ld a, (.dmark)  
be1a 32 7a ee			ld (debug_mark),a  
be1d 3a 2c be			ld a, (.dmark+1)  
be20 32 7b ee			ld (debug_mark+1),a  
be23 3a 2d be			ld a, (.dmark+2)  
be26 32 7c ee			ld (debug_mark+2),a  
be29 18 03			jr .pastdmark  
be2b ..			.dmark: db "KEY"  
be2e f1			.pastdmark: pop af  
be2f			endm  
# End of macro DMARK
be2f						CALLMONITOR 
be2f cd 7b 91			call break_point_state  
be32				endm  
# End of macro CALLMONITOR
be32					endif 
be32			; TODO currently waits 
be32 cd 98 d4				call cin 
be35					;call cin_wait 
be35 6f					ld l, a 
be36 26 00				ld h, 0 
be38 cd 08 97				call forth_push_numhl 
be3b					NEXTW 
be3b c3 f9 98			jp macro_next 
be3e				endm 
# End of macro NEXTW
be3e			.WAITK: 
be3e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
be3e 3f				db WORD_SYS_CORE+43             
be3f 70 be			dw .ACCEPT            
be41 06				db 5 + 1 
be42 .. 00			db "WAITK",0              
be48				endm 
# End of macro CWHEAD
be48			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
be48					if DEBUG_FORTH_WORDS_KEY 
be48						DMARK "WAI" 
be48 f5				push af  
be49 3a 5d be			ld a, (.dmark)  
be4c 32 7a ee			ld (debug_mark),a  
be4f 3a 5e be			ld a, (.dmark+1)  
be52 32 7b ee			ld (debug_mark+1),a  
be55 3a 5f be			ld a, (.dmark+2)  
be58 32 7c ee			ld (debug_mark+2),a  
be5b 18 03			jr .pastdmark  
be5d ..			.dmark: db "WAI"  
be60 f1			.pastdmark: pop af  
be61			endm  
# End of macro DMARK
be61						CALLMONITOR 
be61 cd 7b 91			call break_point_state  
be64				endm  
# End of macro CALLMONITOR
be64					endif 
be64 cd 92 d4				call cin_wait 
be67 6f					ld l, a 
be68 26 00				ld h, 0 
be6a cd 08 97				call forth_push_numhl 
be6d					NEXTW 
be6d c3 f9 98			jp macro_next 
be70				endm 
# End of macro NEXTW
be70			.ACCEPT: 
be70				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
be70 40				db WORD_SYS_CORE+44             
be71 ce be			dw .EDIT            
be73 07				db 6 + 1 
be74 .. 00			db "ACCEPT",0              
be7b				endm 
# End of macro CWHEAD
be7b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
be7b					; TODO crashes on push 
be7b					if DEBUG_FORTH_WORDS_KEY 
be7b						DMARK "ACC" 
be7b f5				push af  
be7c 3a 90 be			ld a, (.dmark)  
be7f 32 7a ee			ld (debug_mark),a  
be82 3a 91 be			ld a, (.dmark+1)  
be85 32 7b ee			ld (debug_mark+1),a  
be88 3a 92 be			ld a, (.dmark+2)  
be8b 32 7c ee			ld (debug_mark+2),a  
be8e 18 03			jr .pastdmark  
be90 ..			.dmark: db "ACC"  
be93 f1			.pastdmark: pop af  
be94			endm  
# End of macro DMARK
be94						CALLMONITOR 
be94 cd 7b 91			call break_point_state  
be97				endm  
# End of macro CALLMONITOR
be97					endif 
be97 21 73 e5				ld hl, os_input 
be9a 3e 00				ld a, 0 
be9c 77					ld (hl),a 
be9d 3a 5e eb				ld a,(f_cursor_ptr) 
bea0 16 64				ld d, 100 
bea2 0e 00				ld c, 0 
bea4 1e 28				ld e, 40 
bea6 cd e4 89				call input_str 
bea9					; TODO perhaps do a type check and wrap in quotes if not a number 
bea9 21 73 e5				ld hl, os_input 
beac					if DEBUG_FORTH_WORDS 
beac						DMARK "AC1" 
beac f5				push af  
bead 3a c1 be			ld a, (.dmark)  
beb0 32 7a ee			ld (debug_mark),a  
beb3 3a c2 be			ld a, (.dmark+1)  
beb6 32 7b ee			ld (debug_mark+1),a  
beb9 3a c3 be			ld a, (.dmark+2)  
bebc 32 7c ee			ld (debug_mark+2),a  
bebf 18 03			jr .pastdmark  
bec1 ..			.dmark: db "AC1"  
bec4 f1			.pastdmark: pop af  
bec5			endm  
# End of macro DMARK
bec5						CALLMONITOR 
bec5 cd 7b 91			call break_point_state  
bec8				endm  
# End of macro CALLMONITOR
bec8					endif 
bec8 cd 1a 97				call forth_push_str 
becb					NEXTW 
becb c3 f9 98			jp macro_next 
bece				endm 
# End of macro NEXTW
bece			 
bece			.EDIT: 
bece				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
bece 40				db WORD_SYS_CORE+44             
becf 57 bf			dw .ENDKEY            
bed1 05				db 4 + 1 
bed2 .. 00			db "EDIT",0              
bed7				endm 
# End of macro CWHEAD
bed7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
bed7			 
bed7					; TODO does not copy from stack 
bed7					if DEBUG_FORTH_WORDS_KEY 
bed7						DMARK "EDT" 
bed7 f5				push af  
bed8 3a ec be			ld a, (.dmark)  
bedb 32 7a ee			ld (debug_mark),a  
bede 3a ed be			ld a, (.dmark+1)  
bee1 32 7b ee			ld (debug_mark+1),a  
bee4 3a ee be			ld a, (.dmark+2)  
bee7 32 7c ee			ld (debug_mark+2),a  
beea 18 03			jr .pastdmark  
beec ..			.dmark: db "EDT"  
beef f1			.pastdmark: pop af  
bef0			endm  
# End of macro DMARK
bef0						CALLMONITOR 
bef0 cd 7b 91			call break_point_state  
bef3				endm  
# End of macro CALLMONITOR
bef3					endif 
bef3			 
bef3					FORTH_DSP 
bef3 cd 88 97			call macro_forth_dsp 
bef6				endm 
# End of macro FORTH_DSP
bef6					;v5 FORTH_DSP_VALUE 
bef6 23					inc hl    ; TODO do type check 
bef7			 
bef7 e5					push hl 
bef8 3e 00				ld a, 0 
befa cd 20 8e				call strlent 
befd 23					inc hl 
befe			 
befe 06 00				ld b, 0 
bf00 4d					ld c, l 
bf01			 
bf01 e1					pop hl 
bf02 11 73 e5				ld de, os_input 
bf05					if DEBUG_FORTH_WORDS_KEY 
bf05						DMARK "EDc" 
bf05 f5				push af  
bf06 3a 1a bf			ld a, (.dmark)  
bf09 32 7a ee			ld (debug_mark),a  
bf0c 3a 1b bf			ld a, (.dmark+1)  
bf0f 32 7b ee			ld (debug_mark+1),a  
bf12 3a 1c bf			ld a, (.dmark+2)  
bf15 32 7c ee			ld (debug_mark+2),a  
bf18 18 03			jr .pastdmark  
bf1a ..			.dmark: db "EDc"  
bf1d f1			.pastdmark: pop af  
bf1e			endm  
# End of macro DMARK
bf1e						CALLMONITOR 
bf1e cd 7b 91			call break_point_state  
bf21				endm  
# End of macro CALLMONITOR
bf21					endif 
bf21 ed b0				ldir 
bf23			 
bf23			 
bf23 21 73 e5				ld hl, os_input 
bf26					;ld a, 0 
bf26					;ld (hl),a 
bf26 3a 5e eb				ld a,(f_cursor_ptr) 
bf29 16 64				ld d, 100 
bf2b 0e 00				ld c, 0 
bf2d 1e 28				ld e, 40 
bf2f cd e4 89				call input_str 
bf32					; TODO perhaps do a type check and wrap in quotes if not a number 
bf32 21 73 e5				ld hl, os_input 
bf35					if DEBUG_FORTH_WORDS 
bf35						DMARK "ED1" 
bf35 f5				push af  
bf36 3a 4a bf			ld a, (.dmark)  
bf39 32 7a ee			ld (debug_mark),a  
bf3c 3a 4b bf			ld a, (.dmark+1)  
bf3f 32 7b ee			ld (debug_mark+1),a  
bf42 3a 4c bf			ld a, (.dmark+2)  
bf45 32 7c ee			ld (debug_mark+2),a  
bf48 18 03			jr .pastdmark  
bf4a ..			.dmark: db "ED1"  
bf4d f1			.pastdmark: pop af  
bf4e			endm  
# End of macro DMARK
bf4e						CALLMONITOR 
bf4e cd 7b 91			call break_point_state  
bf51				endm  
# End of macro CALLMONITOR
bf51					endif 
bf51 cd 1a 97				call forth_push_str 
bf54					NEXTW 
bf54 c3 f9 98			jp macro_next 
bf57				endm 
# End of macro NEXTW
bf57			 
bf57			 
bf57			 
bf57			.ENDKEY: 
bf57			; eof 
bf57			 
# End of file forth_words_key.asm
bf57			 
bf57			if STORAGE_SE 
bf57			   	include "forth_words_storage.asm" 
bf57			endif 
bf57				include "forth_words_device.asm" 
bf57			; Device related words 
bf57			 
bf57			; | ## Device Words 
bf57			 
bf57			if SOUND_ENABLE 
bf57			.NOTE: 
bf57				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
bf57			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
bf57					if DEBUG_FORTH_WORDS_KEY 
bf57						DMARK "NTE" 
bf57						CALLMONITOR 
bf57					endif 
bf57			 
bf57				 
bf57			 
bf57					NEXTW 
bf57			.AFTERSOUND: 
bf57			endif 
bf57			 
bf57			 
bf57			USE_GPIO: equ 0 
bf57			 
bf57			if USE_GPIO 
bf57			.GP1: 
bf57				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
bf57			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
bf57					NEXTW 
bf57			.GP2: 
bf57				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
bf57			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
bf57			 
bf57					NEXTW 
bf57			 
bf57			.GP3: 
bf57				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
bf57			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
bf57			 
bf57					NEXTW 
bf57			 
bf57			.GP4: 
bf57				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
bf57			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
bf57			 
bf57					NEXTW 
bf57			.SIN: 
bf57			 
bf57			 
bf57			endif 
bf57			 
bf57			 
bf57				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
bf57 33				db WORD_SYS_CORE+31             
bf58 8c bf			dw .SOUT            
bf5a 03				db 2 + 1 
bf5b .. 00			db "IN",0              
bf5e				endm 
# End of macro CWHEAD
bf5e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
bf5e					if DEBUG_FORTH_WORDS_KEY 
bf5e						DMARK "IN." 
bf5e f5				push af  
bf5f 3a 73 bf			ld a, (.dmark)  
bf62 32 7a ee			ld (debug_mark),a  
bf65 3a 74 bf			ld a, (.dmark+1)  
bf68 32 7b ee			ld (debug_mark+1),a  
bf6b 3a 75 bf			ld a, (.dmark+2)  
bf6e 32 7c ee			ld (debug_mark+2),a  
bf71 18 03			jr .pastdmark  
bf73 ..			.dmark: db "IN."  
bf76 f1			.pastdmark: pop af  
bf77			endm  
# End of macro DMARK
bf77						CALLMONITOR 
bf77 cd 7b 91			call break_point_state  
bf7a				endm  
# End of macro CALLMONITOR
bf7a					endif 
bf7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf7a cd a3 97			call macro_dsp_valuehl 
bf7d				endm 
# End of macro FORTH_DSP_VALUEHL
bf7d			 
bf7d e5					push hl 
bf7e			 
bf7e					; destroy value TOS 
bf7e			 
bf7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf7e cd 3f 98			call macro_forth_dsp_pop 
bf81				endm 
# End of macro FORTH_DSP_POP
bf81			 
bf81					; one value on hl get other one back 
bf81			 
bf81 c1					pop bc 
bf82			 
bf82					; do the sub 
bf82			;		ex de, hl 
bf82			 
bf82 ed 68				in l,(c) 
bf84			 
bf84					; save it 
bf84			 
bf84 26 00				ld h,0 
bf86			 
bf86					; TODO push value back onto stack for another op etc 
bf86			 
bf86 cd 08 97				call forth_push_numhl 
bf89					NEXTW 
bf89 c3 f9 98			jp macro_next 
bf8c				endm 
# End of macro NEXTW
bf8c			.SOUT: 
bf8c				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
bf8c 34				db WORD_SYS_CORE+32             
bf8d df bf			dw .SPIO            
bf8f 04				db 3 + 1 
bf90 .. 00			db "OUT",0              
bf94				endm 
# End of macro CWHEAD
bf94			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
bf94					if DEBUG_FORTH_WORDS_KEY 
bf94						DMARK "OUT" 
bf94 f5				push af  
bf95 3a a9 bf			ld a, (.dmark)  
bf98 32 7a ee			ld (debug_mark),a  
bf9b 3a aa bf			ld a, (.dmark+1)  
bf9e 32 7b ee			ld (debug_mark+1),a  
bfa1 3a ab bf			ld a, (.dmark+2)  
bfa4 32 7c ee			ld (debug_mark+2),a  
bfa7 18 03			jr .pastdmark  
bfa9 ..			.dmark: db "OUT"  
bfac f1			.pastdmark: pop af  
bfad			endm  
# End of macro DMARK
bfad						CALLMONITOR 
bfad cd 7b 91			call break_point_state  
bfb0				endm  
# End of macro CALLMONITOR
bfb0					endif 
bfb0			 
bfb0					; get port 
bfb0			 
bfb0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb0 cd a3 97			call macro_dsp_valuehl 
bfb3				endm 
# End of macro FORTH_DSP_VALUEHL
bfb3			 
bfb3 e5					push hl 
bfb4			 
bfb4					; destroy value TOS 
bfb4			 
bfb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb4 cd 3f 98			call macro_forth_dsp_pop 
bfb7				endm 
# End of macro FORTH_DSP_POP
bfb7			 
bfb7					; get byte to send 
bfb7			 
bfb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb7 cd a3 97			call macro_dsp_valuehl 
bfba				endm 
# End of macro FORTH_DSP_VALUEHL
bfba			 
bfba			;		push hl 
bfba			 
bfba					; destroy value TOS 
bfba			 
bfba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfba cd 3f 98			call macro_forth_dsp_pop 
bfbd				endm 
# End of macro FORTH_DSP_POP
bfbd			 
bfbd					; one value on hl get other one back 
bfbd			 
bfbd			;		pop hl 
bfbd			 
bfbd c1					pop bc 
bfbe			 
bfbe					if DEBUG_FORTH_WORDS 
bfbe						DMARK "OUT" 
bfbe f5				push af  
bfbf 3a d3 bf			ld a, (.dmark)  
bfc2 32 7a ee			ld (debug_mark),a  
bfc5 3a d4 bf			ld a, (.dmark+1)  
bfc8 32 7b ee			ld (debug_mark+1),a  
bfcb 3a d5 bf			ld a, (.dmark+2)  
bfce 32 7c ee			ld (debug_mark+2),a  
bfd1 18 03			jr .pastdmark  
bfd3 ..			.dmark: db "OUT"  
bfd6 f1			.pastdmark: pop af  
bfd7			endm  
# End of macro DMARK
bfd7						CALLMONITOR 
bfd7 cd 7b 91			call break_point_state  
bfda				endm  
# End of macro CALLMONITOR
bfda					endif 
bfda			 
bfda ed 69				out (c), l 
bfdc			 
bfdc					NEXTW 
bfdc c3 f9 98			jp macro_next 
bfdf				endm 
# End of macro NEXTW
bfdf			 
bfdf			 
bfdf			.SPIO: 
bfdf			 
bfdf			if STORAGE_SE 
bfdf				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
bfdf			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
bfdf			 
bfdf					call spi_ce_low 
bfdf			    NEXTW 
bfdf			 
bfdf			.SPICEH: 
bfdf				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
bfdf			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
bfdf			 
bfdf					call spi_ce_high 
bfdf			    NEXTW 
bfdf			 
bfdf			 
bfdf			.SPIOb: 
bfdf			 
bfdf				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
bfdf			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
bfdf			 
bfdf					; get port 
bfdf			 
bfdf			 
bfdf					; get byte to send 
bfdf			 
bfdf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfdf			 
bfdf			;		push hl    ; u1  
bfdf			 
bfdf					; destroy value TOS 
bfdf			 
bfdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfdf			 
bfdf					; one value on hl get other one back 
bfdf			 
bfdf			;		pop hl   ; u2 - addr 
bfdf			 
bfdf					; TODO Send SPI byte 
bfdf			 
bfdf					ld a, l 
bfdf					call spi_send_byte 
bfdf			 
bfdf					NEXTW 
bfdf			 
bfdf			.SPII: 
bfdf				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
bfdf			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
bfdf			 
bfdf					; TODO Get SPI byte 
bfdf			 
bfdf					call spi_read_byte 
bfdf			 
bfdf					ld h, 0 
bfdf					ld l, a 
bfdf					call forth_push_numhl 
bfdf			 
bfdf					NEXTW 
bfdf			 
bfdf			 
bfdf			 
bfdf			.SESEL: 
bfdf				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
bfdf			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
bfdf					if DEBUG_FORTH_WORDS_KEY 
bfdf						DMARK "BNK" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf			 
bfdf					ld a, 255 
bfdf					ld (spi_cartdev), a 
bfdf			 
bfdf					; get bank 
bfdf			 
bfdf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfdf			 
bfdf			;		push hl 
bfdf			 
bfdf					; destroy value TOS 
bfdf			 
bfdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfdf			 
bfdf					; one value on hl get other one back 
bfdf			 
bfdf			;		pop hl 
bfdf			 
bfdf			 
bfdf					ld c, SPI_CE_HIGH 
bfdf			 
bfdf					ld a, l 
bfdf			 
bfdf					if DEBUG_FORTH_WORDS 
bfdf						DMARK "BNK" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf			 
bfdf					; active low 
bfdf			 
bfdf					cp 0 
bfdf					jr z, .bset 
bfdf					cp 1 
bfdf					jr nz, .b2 
bfdf					res 0, c 
bfdf			.b2:		cp 2 
bfdf					jr nz, .b3 
bfdf					res 1, c 
bfdf			.b3:		cp 3 
bfdf					jr nz, .b4 
bfdf					res 2, c 
bfdf			.b4:		cp 4 
bfdf					jr nz, .b5 
bfdf					res 3, c 
bfdf			.b5:		cp 5 
bfdf					jr nz, .bset 
bfdf					res 4, c 
bfdf			 
bfdf			.bset: 
bfdf					ld a, c 
bfdf					ld (spi_device),a 
bfdf					if DEBUG_FORTH_WORDS 
bfdf						DMARK "BN2" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf			 
bfdf					NEXTW 
bfdf			 
bfdf			.CARTDEV: 
bfdf				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
bfdf			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
bfdf					if DEBUG_FORTH_WORDS_KEY 
bfdf						DMARK "CDV" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf			 
bfdf					; disable se storage bank selection 
bfdf			 
bfdf					ld a, SPI_CE_HIGH		; ce high 
bfdf					ld (spi_device), a 
bfdf			 
bfdf					; get bank 
bfdf			 
bfdf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfdf			 
bfdf			;		push hl 
bfdf			 
bfdf					; destroy value TOS 
bfdf			 
bfdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfdf			 
bfdf					; one value on hl get other one back 
bfdf			 
bfdf			;		pop hl 
bfdf			 
bfdf					; active low 
bfdf			 
bfdf					ld c, 255 
bfdf			 
bfdf					ld a, l 
bfdf					if DEBUG_FORTH_WORDS 
bfdf						DMARK "CDV" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf					cp 0 
bfdf					jr z, .cset 
bfdf					cp 1 
bfdf					jr nz, .c2 
bfdf					res 0, c 
bfdf			.c2:		cp 2 
bfdf					jr nz, .c3 
bfdf					res 1, c 
bfdf			.c3:		cp 3 
bfdf					jr nz, .c4 
bfdf					res 2, c 
bfdf			.c4:		cp 4 
bfdf					jr nz, .c5 
bfdf					res 3, c 
bfdf			.c5:		cp 5 
bfdf					jr nz, .c6 
bfdf					res 4, c 
bfdf			.c6:		cp 6 
bfdf					jr nz, .c7 
bfdf					res 5, c 
bfdf			.c7:		cp 7 
bfdf					jr nz, .c8 
bfdf					res 6, c 
bfdf			.c8:		cp 8 
bfdf					jr nz, .cset 
bfdf					res 7, c 
bfdf			.cset:		ld a, c 
bfdf					ld (spi_cartdev),a 
bfdf			 
bfdf					if DEBUG_FORTH_WORDS 
bfdf						DMARK "CD2" 
bfdf						CALLMONITOR 
bfdf					endif 
bfdf					NEXTW 
bfdf			endif 
bfdf			 
bfdf			.ENDDEVICE: 
bfdf			; eof 
bfdf			 
# End of file forth_words_device.asm
bfdf			 
bfdf			; var handler 
bfdf			 
bfdf			 
bfdf			.VARS: 
bfdf				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
bfdf 78				db WORD_SYS_CORE+100             
bfe0 f7 bf			dw .V0Q            
bfe2 04				db 3 + 1 
bfe3 .. 00			db "V0!",0              
bfe7				endm 
# End of macro CWHEAD
bfe7			;| V0! ( u1 -- )  Store value to v0  | DONE 
bfe7			 
bfe7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfe7 cd a3 97			call macro_dsp_valuehl 
bfea				endm 
# End of macro FORTH_DSP_VALUEHL
bfea			 
bfea 11 28 eb				ld de, cli_var_array 
bfed			 
bfed eb					ex de, hl 
bfee 73					ld (hl), e 
bfef 23					inc hl 
bff0 72					ld (hl), d 
bff1			 
bff1					; destroy value TOS 
bff1			 
bff1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bff1 cd 3f 98			call macro_forth_dsp_pop 
bff4				endm 
# End of macro FORTH_DSP_POP
bff4			 
bff4				       NEXTW 
bff4 c3 f9 98			jp macro_next 
bff7				endm 
# End of macro NEXTW
bff7			.V0Q: 
bff7				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
bff7 79				db WORD_SYS_CORE+101             
bff8 08 c0			dw .V1S            
bffa 04				db 3 + 1 
bffb .. 00			db "V0@",0              
bfff				endm 
# End of macro CWHEAD
bfff			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
bfff 2a 28 eb				ld hl, (cli_var_array) 
c002 cd 08 97				call forth_push_numhl 
c005			 
c005				       NEXTW 
c005 c3 f9 98			jp macro_next 
c008				endm 
# End of macro NEXTW
c008			.V1S: 
c008				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c008 7a				db WORD_SYS_CORE+102             
c009 20 c0			dw .V1Q            
c00b 04				db 3 + 1 
c00c .. 00			db "V1!",0              
c010				endm 
# End of macro CWHEAD
c010			;| V1! ( u1 -- )  Store value to v1 | DONE 
c010					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c010 cd a3 97			call macro_dsp_valuehl 
c013				endm 
# End of macro FORTH_DSP_VALUEHL
c013			 
c013 11 2a eb				ld de, cli_var_array+2 
c016				 
c016 eb					ex de, hl 
c017 73					ld (hl), e 
c018 23					inc hl 
c019 72					ld (hl), d 
c01a			 
c01a					; destroy value TOS 
c01a			 
c01a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c01a cd 3f 98			call macro_forth_dsp_pop 
c01d				endm 
# End of macro FORTH_DSP_POP
c01d				       NEXTW 
c01d c3 f9 98			jp macro_next 
c020				endm 
# End of macro NEXTW
c020			.V1Q: 
c020				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c020 7b				db WORD_SYS_CORE+103             
c021 31 c0			dw .V2S            
c023 04				db 3 + 1 
c024 .. 00			db "V1@",0              
c028				endm 
# End of macro CWHEAD
c028			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c028 2a 2a eb				ld hl, (cli_var_array+2) 
c02b cd 08 97				call forth_push_numhl 
c02e				       NEXTW 
c02e c3 f9 98			jp macro_next 
c031				endm 
# End of macro NEXTW
c031			.V2S: 
c031				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c031 7c				db WORD_SYS_CORE+104             
c032 49 c0			dw .V2Q            
c034 04				db 3 + 1 
c035 .. 00			db "V2!",0              
c039				endm 
# End of macro CWHEAD
c039			;| V2! ( u1 -- )  Store value to v2 | DONE 
c039					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c039 cd a3 97			call macro_dsp_valuehl 
c03c				endm 
# End of macro FORTH_DSP_VALUEHL
c03c			 
c03c 11 2c eb				ld de, cli_var_array+4 
c03f				 
c03f eb					ex de, hl 
c040 73					ld (hl), e 
c041 23					inc hl 
c042 72					ld (hl), d 
c043			 
c043					; destroy value TOS 
c043			 
c043					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c043 cd 3f 98			call macro_forth_dsp_pop 
c046				endm 
# End of macro FORTH_DSP_POP
c046				       NEXTW 
c046 c3 f9 98			jp macro_next 
c049				endm 
# End of macro NEXTW
c049			.V2Q: 
c049				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c049 7d				db WORD_SYS_CORE+105             
c04a 5a c0			dw .V3S            
c04c 04				db 3 + 1 
c04d .. 00			db "V2@",0              
c051				endm 
# End of macro CWHEAD
c051			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c051 2a 2c eb				ld hl, (cli_var_array+4) 
c054 cd 08 97				call forth_push_numhl 
c057				       NEXTW 
c057 c3 f9 98			jp macro_next 
c05a				endm 
# End of macro NEXTW
c05a			.V3S: 
c05a				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c05a 7c				db WORD_SYS_CORE+104             
c05b 72 c0			dw .V3Q            
c05d 04				db 3 + 1 
c05e .. 00			db "V3!",0              
c062				endm 
# End of macro CWHEAD
c062			;| V3! ( u1 -- )  Store value to v3 | DONE 
c062					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c062 cd a3 97			call macro_dsp_valuehl 
c065				endm 
# End of macro FORTH_DSP_VALUEHL
c065			 
c065 11 2e eb				ld de, cli_var_array+6 
c068				 
c068 eb					ex de, hl 
c069 73					ld (hl), e 
c06a 23					inc hl 
c06b 72					ld (hl), d 
c06c			 
c06c					; destroy value TOS 
c06c			 
c06c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c06c cd 3f 98			call macro_forth_dsp_pop 
c06f				endm 
# End of macro FORTH_DSP_POP
c06f				       NEXTW 
c06f c3 f9 98			jp macro_next 
c072				endm 
# End of macro NEXTW
c072			.V3Q: 
c072				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c072 7d				db WORD_SYS_CORE+105             
c073 83 c0			dw .END            
c075 04				db 3 + 1 
c076 .. 00			db "V3@",0              
c07a				endm 
# End of macro CWHEAD
c07a			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c07a 2a 2e eb				ld hl, (cli_var_array+6) 
c07d cd 08 97				call forth_push_numhl 
c080				       NEXTW 
c080 c3 f9 98			jp macro_next 
c083				endm 
# End of macro NEXTW
c083			 
c083			 
c083			 
c083			 
c083			 
c083			; end of dict marker 
c083			 
c083 00			.END:    db WORD_SYS_END 
c084 00 00			dw 0 
c086 00				db 0 
c087			 
c087			; use to jp here for user dict words to save on macro expansion  
c087			 
c087			user_dict_next: 
c087				NEXTW 
c087 c3 f9 98			jp macro_next 
c08a				endm 
# End of macro NEXTW
c08a			 
c08a			 
c08a			user_exec: 
c08a				;    ld hl, <word code> 
c08a				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c08a				;    call forthexec 
c08a				;    jp user_dict_next   (NEXT) 
c08a			        ;    <word code bytes> 
c08a eb				ex de, hl 
c08b 2a 76 e6			ld hl,(os_tok_ptr) 
c08e				 
c08e				FORTH_RSP_NEXT 
c08e cd af 96			call macro_forth_rsp_next 
c091				endm 
# End of macro FORTH_RSP_NEXT
c091			 
c091			if DEBUG_FORTH_UWORD 
c091						DMARK "UEX" 
c091 f5				push af  
c092 3a a6 c0			ld a, (.dmark)  
c095 32 7a ee			ld (debug_mark),a  
c098 3a a7 c0			ld a, (.dmark+1)  
c09b 32 7b ee			ld (debug_mark+1),a  
c09e 3a a8 c0			ld a, (.dmark+2)  
c0a1 32 7c ee			ld (debug_mark+2),a  
c0a4 18 03			jr .pastdmark  
c0a6 ..			.dmark: db "UEX"  
c0a9 f1			.pastdmark: pop af  
c0aa			endm  
# End of macro DMARK
c0aa				CALLMONITOR 
c0aa cd 7b 91			call break_point_state  
c0ad				endm  
# End of macro CALLMONITOR
c0ad			endif 
c0ad			 
c0ad			 
c0ad			 
c0ad eb				ex de, hl 
c0ae 22 76 e6			ld (os_tok_ptr), hl 
c0b1				 
c0b1				; Don't use next - Skips the first word in uword. 
c0b1			 
c0b1 c3 8a 99			jp exec1 
c0b4			;	NEXT 
c0b4			 
c0b4			 
c0b4			; eof 
# End of file forth_wordsv4.asm
c0b4			endif 
c0b4			;;;;;;;;;;;;;; Debug code 
c0b4			 
c0b4			 
c0b4			;if DEBUG_FORTH_PARSE 
c0b4 .. 00		.nowordfound: db "No match",0 
c0bd .. 00		.compword:	db "Comparing word ",0 
c0cd .. 00		.nextwordat:	db "Next word at",0 
c0da .. 00		.charmatch:	db "Char match",0 
c0e5			;endif 
c0e5			if DEBUG_FORTH_JP 
c0e5			.foundword:	db "Word match. Exec..",0 
c0e5			endif 
c0e5			;if DEBUG_FORTH_PUSH 
c0e5 .. 00		.enddict:	db "Dict end. Push.",0 
c0f5 .. 00		.push_str:	db "Pushing string",0 
c104 .. 00		.push_num:	db "Pushing number",0 
c113 .. 00		.data_sp:	db "SP:",0 
c117 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c129 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c13b .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c14d			;endif 
c14d			;if DEBUG_FORTH_MALLOC 
c14d .. 00		.push_malloc:	db "Malloc address",0 
c15c			;endif 
c15c			 
c15c			 
c15c			 
c15c			; display malloc address and current data stack pointer  
c15c			 
c15c			malloc_error: 
c15c d5				push de 
c15d f5				push af 
c15e e5				push hl 
c15f cd 5e 88			call clear_display 
c162 11 84 c1			ld de, .mallocerr 
c165 3e 00			ld a,0 
c167			;	ld de,os_word_scratch 
c167 cd 71 88			call str_at_display 
c16a 3e 11			ld a, display_row_1+17 
c16c 11 7a ee			ld de, debug_mark 
c16f cd 71 88			call str_at_display 
c172 cd 81 88			call update_display 
c175				;call break_point_state 
c175 cd 92 d4			call cin_wait 
c178			 
c178 3e 20			ld a, ' ' 
c17a 32 74 e3			ld (os_view_disable), a 
c17d e1				pop hl 
c17e f1				pop af 
c17f d1				pop de	 
c180				CALLMONITOR 
c180 cd 7b 91			call break_point_state  
c183				endm  
# End of macro CALLMONITOR
c183 c9				ret 
c184			 
c184 .. 00		.mallocerr: 	db "Malloc Error",0 
c191			;if DEBUG_FORTH_PUSH 
c191			display_data_sp: 
c191 f5				push af 
c192			 
c192				; see if disabled 
c192			 
c192 3a 74 e3			ld a, (os_view_disable) 
c195 fe 2a			cp '*' 
c197 28 67			jr z, .skipdsp 
c199			 
c199 e5				push hl 
c19a e5				push hl 
c19b e5			push hl 
c19c cd 5e 88			call clear_display 
c19f e1			pop hl 
c1a0 7c				ld a,h 
c1a1 21 7a e6			ld hl, os_word_scratch 
c1a4 cd b8 8c			call hexout 
c1a7 e1				pop hl 
c1a8 7d				ld a,l 
c1a9 21 7c e6			ld hl, os_word_scratch+2 
c1ac cd b8 8c			call hexout 
c1af 21 7e e6			ld hl, os_word_scratch+4 
c1b2 3e 00			ld a,0 
c1b4 77				ld (hl),a 
c1b5 11 7a e6			ld de,os_word_scratch 
c1b8 3e 28				ld a, display_row_2 
c1ba cd 71 88				call str_at_display 
c1bd 11 17 c1			ld de, .wordinhl 
c1c0 3e 00			ld a, display_row_1 
c1c2			 
c1c2 cd 71 88				call str_at_display 
c1c5 11 7a ee			ld de, debug_mark 
c1c8 3e 11			ld a, display_row_1+17 
c1ca			 
c1ca cd 71 88				call str_at_display 
c1cd			 
c1cd				; display current data stack pointer 
c1cd 11 13 c1			ld de,.data_sp 
c1d0 3e 30				ld a, display_row_2 + 8 
c1d2 cd 71 88				call str_at_display 
c1d5			 
c1d5 2a 22 eb			ld hl,(cli_data_sp) 
c1d8 e5				push hl 
c1d9 7c				ld a,h 
c1da 21 7a e6			ld hl, os_word_scratch 
c1dd cd b8 8c			call hexout 
c1e0 e1				pop hl 
c1e1 7d				ld a,l 
c1e2 21 7c e6			ld hl, os_word_scratch+2 
c1e5 cd b8 8c			call hexout 
c1e8 21 7e e6			ld hl, os_word_scratch+4 
c1eb 3e 00			ld a,0 
c1ed 77				ld (hl),a 
c1ee 11 7a e6			ld de,os_word_scratch 
c1f1 3e 33				ld a, display_row_2 + 11 
c1f3 cd 71 88				call str_at_display 
c1f6			 
c1f6			 
c1f6 cd 81 88			call update_display 
c1f9 cd e2 87			call delay1s 
c1fc cd e2 87			call delay1s 
c1ff e1				pop hl 
c200			.skipdsp: 
c200 f1				pop af 
c201 c9				ret 
c202			 
c202			display_data_malloc: 
c202			 
c202 f5				push af 
c203 e5				push hl 
c204 e5				push hl 
c205 e5			push hl 
c206 cd 5e 88			call clear_display 
c209 e1			pop hl 
c20a 7c				ld a,h 
c20b 21 7a e6			ld hl, os_word_scratch 
c20e cd b8 8c			call hexout 
c211 e1				pop hl 
c212 7d				ld a,l 
c213 21 7c e6			ld hl, os_word_scratch+2 
c216 cd b8 8c			call hexout 
c219 21 7e e6			ld hl, os_word_scratch+4 
c21c 3e 00			ld a,0 
c21e 77				ld (hl),a 
c21f 11 7a e6			ld de,os_word_scratch 
c222 3e 28				ld a, display_row_2 
c224 cd 71 88				call str_at_display 
c227 11 4d c1			ld de, .push_malloc 
c22a 3e 00			ld a, display_row_1 
c22c			 
c22c cd 71 88				call str_at_display 
c22f			 
c22f				; display current data stack pointer 
c22f 11 13 c1			ld de,.data_sp 
c232 3e 30				ld a, display_row_2 + 8 
c234 cd 71 88				call str_at_display 
c237			 
c237 2a 22 eb			ld hl,(cli_data_sp) 
c23a e5				push hl 
c23b 7c				ld a,h 
c23c 21 7a e6			ld hl, os_word_scratch 
c23f cd b8 8c			call hexout 
c242 e1				pop hl 
c243 7d				ld a,l 
c244 21 7c e6			ld hl, os_word_scratch+2 
c247 cd b8 8c			call hexout 
c24a 21 7e e6			ld hl, os_word_scratch+4 
c24d 3e 00			ld a,0 
c24f 77				ld (hl),a 
c250 11 7a e6			ld de,os_word_scratch 
c253 3e 33				ld a, display_row_2 + 11 
c255 cd 71 88				call str_at_display 
c258			 
c258 cd 81 88			call update_display 
c25b cd e2 87			call delay1s 
c25e cd e2 87			call delay1s 
c261 e1				pop hl 
c262 f1				pop af 
c263 c9				ret 
c264			;endif 
c264			 
c264			include "forth_autostart.asm" 
c264			; list of commands to perform at system start up 
c264			 
c264			startcmds: 
c264			;	dw test11 
c264			;	dw test12 
c264			;	dw test13 
c264			;	dw test14 
c264			;	dw test15 
c264			;	dw test16 
c264			;	dw test17 
c264			;	dw ifthtest1 
c264			;	dw ifthtest2 
c264			;	dw ifthtest3 
c264			;	dw mmtest1 
c264			;	dw mmtest2 
c264			;	dw mmtest3 
c264			;	dw mmtest4 
c264			;	dw mmtest5 
c264			;	dw mmtest6 
c264			;	dw iftest1 
c264			;	dw iftest2 
c264			;	dw iftest3 
c264			;	dw looptest1 
c264			;	dw looptest2 
c264			;	dw test1 
c264			;	dw test2 
c264			;	dw test3 
c264			;	dw test4 
c264			;	dw game2r 
c264			;	dw game2b1 
c264			;	dw game2b2 
c264			 
c264				; start up words that are actually useful 
c264			 
c264 c2 c2			dw clrstack 
c266 f5 c2			dw type 
c268 b6 c4			dw stest 
c26a 19 c3			dw strncpy 
c26c 57 c4			dw list 
c26e 7a c3			dw start1 
c270 8c c3			dw start2 
c272			;	dw start3 
c272 9f c3			dw start3b 
c274 f7 c3			dw start3c 
c276			 
c276				; (unit) testing words 
c276			 
c276 2d c5			dw mtesta 
c278 e2 c5			dw mtestb 
c27a 85 c6			dw mtestc 
c27c 3a c7			dw mtestd 
c27e de c7			dw mteste 
c280			 
c280				; demo/game words 
c280			 
c280 ea ce		        dw game3w 
c282 18 cf		        dw game3p 
c284 36 cf		        dw game3sc 
c286 67 cf		        dw game3vsi 
c288 93 cf		        dw game3vs 
c28a				 
c28a dd cc			dw game2b 
c28c 4b cd			dw game2bf 
c28e 95 cd			dw game2mba 
c290 2b ce			dw game2mbas 
c292 6d ce			dw game2mb 
c294			 
c294 9e c9			dw game1 
c296 af c9			dw game1a 
c298 11 ca			dw game1b 
c29a 46 ca			dw game1c 
c29c 7c ca			dw game1d 
c29e ad ca			dw game1s 
c2a0 c1 ca			dw game1t 
c2a2 d6 ca			dw game1f 
c2a4 0a cb			dw game1z 
c2a6 4e cb			dw game1zz 
c2a8			 
c2a8 94 c8			dw test5 
c2aa cc c8			dw test6 
c2ac 04 c9			dw test7 
c2ae 18 c9			dw test8 
c2b0 44 c9			dw test9 
c2b2 5a c9			dw test10 
c2b4				 
c2b4 25 cc		        dw ssv5 
c2b6 09 cc		        dw ssv4 
c2b8 ed cb		        dw ssv3 
c2ba b7 cb		        dw ssv2 
c2bc 3e cc		        dw ssv1 
c2be 86 cc		        dw ssv1cpm 
c2c0			;	dw keyup 
c2c0			;	dw keydown 
c2c0			;	dw keyleft 
c2c0			;	dw keyright 
c2c0			;	dw 	keyf1 
c2c0			;	dw keyf2 
c2c0			;	dw keyf3 
c2c0			;	dw keyf4 
c2c0			;	dw keyf5 
c2c0			;	dw keyf6 
c2c0			;	dw keyf7 
c2c0			;	dw keyf8 
c2c0			;	dw keyf9 
c2c0			;	dw keyf10 
c2c0			;	dw keyf11 
c2c0			;	dw keyf12 
c2c0			;	dw keytab 
c2c0			;	dw keycr 
c2c0			;	dw keyhome 
c2c0			;	dw keyend 
c2c0			;	dw keybs 
c2c0 00 00			db 0, 0	 
c2c2			 
c2c2			 
c2c2			; clear stack  
c2c2			 
c2c2 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c2f5			 
c2f5			; type ( addr count - ) 
c2f5 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c319			 
c319			; some direct memory words 
c319			; strncpy ( len t f -- t ) 
c319			 
c319 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c37a			 
c37a .. 00		start1:     	db ": bpon $0000 bp ;",0 
c38c .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c39f			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c39f .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c3f7 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c457			 
c457			 
c457			; a handy word to list items on the stack 
c457			 
c457 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c4b6			 
c4b6			 
c4b6			; test stack  
c4b6			; rnd8 stest 
c4b6			 
c4b6 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c52d			 
c52d			; random malloc and free cycles 
c52d			 
c52d .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c5e2			 
c5e2			; fixed malloc and free cycles 
c5e2			 
c5e2 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c685			 
c685			; fixed double string push and drop cycle  
c685			 
c685 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
c73a			 
c73a			; consistent fixed string push and drop cycle  
c73a			 
c73a .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
c7de			 
c7de .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
c894			 
c894			;test1:		db ": aa 1 2 3 ;", 0 
c894			;test2:     	db "111 aa 888 999",0 
c894			;test3:     	db ": bb 77 ;",0 
c894			;test4:     	db "$02 $01 do i . loop bb",0 
c894			 
c894 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
c8cc .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
c904 .. 00		test7:     	db ": box hline vline ;",0 
c918 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
c944 .. 00		test9:     	db ": sw $01 adsp world ;",0 
c95a .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
c97f .. 00		test11:     	db "hello create .",0 
c98e .. 00		test12:     	db "hello2 create .",0 
c99e			 
c99e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
c99e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
c99e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
c99e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
c99e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
c99e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
c99e			 
c99e			;iftest1:     	db "$0001 IF cls .",0 
c99e			;iftest2:     	db "$0000 IF cls .",0 
c99e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
c99e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
c99e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
c99e			 
c99e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c99e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c99e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
c99e			 
c99e			 
c99e			 
c99e			; a small guess the number game 
c99e			 
c99e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
c9af .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ca11			 
ca11 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ca46 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ca7c .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
caad .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cac1 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cad6 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cb0a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cb4e			 
cb4e			; Using 'ga' save a high score across multiple runs using external storage 
cb4e			 
cb4e .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cbb7			 
cbb7			 
cbb7			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cbb7			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cbb7			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cbb7			 
cbb7			; simple screen saver to test code memory reuse to destruction 
cbb7			 
cbb7 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cbed .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cc09 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cc25 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cc3e .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cc86 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
ccdd			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
ccdd			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
ccdd			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
ccdd			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
ccdd			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
ccdd			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
ccdd			 
ccdd			 
ccdd			 
ccdd			; minesweeper/battleship finding game 
ccdd			; draws a game board of random ship/mine positions 
ccdd			; user enters coords to see if it hits on 
ccdd			; game ends when all are hit 
ccdd			; when hit or miss says how many may be in the area 
ccdd			 
ccdd			; setup the game board and then hide it 
ccdd .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
cd4b .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
cd95			; prompt for where to target 
cd95 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
ce2b .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ce50			; TODO see if the entered coords hits or misses pushes char hit of miss 
ce50 .. 00		game2mbht:      db ": mbckht nop ;",0 
ce5f .. 00		game2mbms:      db ": mbcms nop ;",0 
ce6d			; TODO how many might be near by 
ce6d .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
ceea			 
ceea			; Game 3 
ceea			 
ceea			; Vert scroller ski game - avoid the trees! 
ceea			 
ceea			; v0 score (ie turns) 
ceea			; v1 player pos 
ceea			; v2 left wall 
ceea			; v3 right wall 
ceea			 
ceea			; Draw side walls randomly 
ceea			 
ceea .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
cf18			 
cf18			; Draw player 
cf18 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
cf36			 
cf36			; TODO Get Key 
cf36			 
cf36			; TODO Move left right 
cf36			 
cf36			; scroll and move walls a bit 
cf36			 
cf36 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
cf67			 
cf67			; main game loop 
cf67			 
cf67 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
cf93 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
cfd2			 
cfd2			; key board defs 
cfd2			 
cfd2 .. 00		keyup:       db ": keyup $05 ;",0 
cfe0 .. 00		keydown:       db ": keydown $0a ;",0 
cff0 .. 00		keyleft:       db ": keyleft $0b ;",0 
d000 .. 00		keyright:       db ": keyright $0c ;",0 
d011 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d01f .. 00		keyf2:       db ": keyf2 $11 ;",0 
d02d .. 00		keyf3:       db ": keyf3 $12 ;",0 
d03b .. 00		keyf4:       db ": keyf4 $13 ;",0 
d049 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d057 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d065 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d073 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d081 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d08f .. 00		keyf10:       db ": keyf10 $19 ;",0 
d09e .. 00		keyf11:       db ": keyf11 $1a ;",0 
d0ad .. 00		keyf12:       db ": keyf12 $1b ;",0 
d0bc			 
d0bc .. 00		keytab:       db ": keytab $09 ;",0 
d0cb .. 00		keycr:       db ": keycr $0d ;",0 
d0d9 .. 00		keyhome:       db ": keyhome $0e ;",0 
d0e9 .. 00		keyend:       db ": keyend $0f ;",0 
d0f8 .. 00		keybs:       db ": keybs $08 ;",0 
d106			 
d106			   
d106			 
d106			 
d106			 
d106			; eof 
# End of file forth_autostart.asm
d106			 
d106 .. 00		sprompt1: db "Startup load...",0 
d116 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d12c			 
d12c			forth_startup: 
d12c 21 64 c2			ld hl, startcmds 
d12f 3e 00			ld a, 0 
d131 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d134			 
d134 e5			.start1:	push hl 
d135 cd 5e 88			call clear_display 
d138 11 06 d1			ld de, sprompt1 
d13b 3e 00		        ld a, display_row_1 
d13d cd 71 88			call str_at_display 
d140 11 16 d1			ld de, sprompt2 
d143 3e 28		        ld a, display_row_2 
d145 cd 71 88			call str_at_display 
d148 e1				pop hl 
d149 e5				push hl 
d14a 5e				ld e,(hl) 
d14b 23				inc hl 
d14c 56				ld d,(hl) 
d14d 3e 50		        ld a, display_row_3 
d14f cd 71 88			call str_at_display 
d152 cd 81 88			call update_display 
d155			 
d155			 
d155 3a 9b e7			ld a, (os_last_cmd) 
d158 fe 00			cp 0 
d15a 28 05			jr z, .startprompt 
d15c cd d6 87			call delay250ms 
d15f 18 24			jr .startdo 
d161				 
d161				 
d161			 
d161			.startprompt: 
d161			 
d161 3e 9f			ld a,display_row_4 + display_cols - 1 
d163 11 7e 96		        ld de, endprg 
d166 cd 71 88			call str_at_display 
d169 cd 81 88			call update_display 
d16c cd e2 87			call delay1s 
d16f cd 92 d4			call cin_wait 
d172						 
d172 fe 2a			cp '*' 
d174 28 5e			jr z, .startupend1 
d176 fe 23			cp '#' 
d178 20 07			jr nz, .startno 
d17a 3e 01			ld a, 1 
d17c 32 9b e7			ld (os_last_cmd),a 
d17f 18 04			jr .startdo 
d181 fe 31		.startno:	cp '1' 
d183 28 3a			jr z,.startnxt  
d185			 
d185				; exec startup line 
d185			.startdo:	 
d185 e1				pop hl 
d186 e5				push hl 
d187				 
d187 5e				ld e,(hl) 
d188 23				inc hl 
d189 56				ld d,(hl) 
d18a eb				ex de,hl 
d18b			 
d18b e5				push hl 
d18c			 
d18c 3e 00			ld a, 0 
d18e				;ld a, FORTH_END_BUFFER 
d18e cd 20 8e			call strlent 
d191 23				inc hl   ; include zero term to copy 
d192 06 00			ld b,0 
d194 4d				ld c,l 
d195 e1				pop hl 
d196 11 75 e3			ld de, scratch 
d199 ed b0			ldir 
d19b			 
d19b			 
d19b 21 75 e3			ld hl, scratch 
d19e cd 47 99			call forthparse 
d1a1 cd 87 99			call forthexec 
d1a4 cd 9e 98			call forthexec_cleanup 
d1a7			 
d1a7 3e 78			ld a, display_row_4 
d1a9 11 22 94			ld de, endprog 
d1ac			 
d1ac cd 81 88			call update_display		 
d1af			 
d1af 3a 9b e7			ld a, (os_last_cmd) 
d1b2 fe 00			cp 0 
d1b4 20 09			jr nz, .startnxt 
d1b6 cd 80 96			call next_page_prompt 
d1b9 cd 5e 88		        call clear_display 
d1bc cd 81 88			call update_display		 
d1bf			 
d1bf				; move onto next startup line? 
d1bf			.startnxt: 
d1bf			 
d1bf cd d6 87			call delay250ms 
d1c2 e1				pop hl 
d1c3			 
d1c3 23				inc hl 
d1c4 23				inc hl 
d1c5			 
d1c5 e5				push hl 
d1c6 5e				ld e, (hl) 
d1c7 23				inc hl 
d1c8 56				ld d, (hl) 
d1c9 e1				pop hl 
d1ca				; TODO replace 0 test 
d1ca			 
d1ca eb				ex de, hl 
d1cb cd e0 89			call ishlzero 
d1ce			;	ld a,e 
d1ce			;	add d 
d1ce			;	cp 0    ; any left to do? 
d1ce eb				ex de, hl 
d1cf c2 34 d1			jp nz, .start1 
d1d2 18 01			jr .startupend 
d1d4			 
d1d4 e1			.startupend1: pop hl 
d1d5			.startupend: 
d1d5			 
d1d5 cd 5e 88			call clear_display 
d1d8 cd 81 88			call update_display 
d1db c9				ret 
d1dc			 
d1dc			 
d1dc			; stack over and underflow checks 
d1dc			 
d1dc			; init the words to detect the under/overflow 
d1dc			 
d1dc			chk_stk_init: 
d1dc				; a vague random number to check so we dont get any "lucky" hits 
d1dc 3e 2d			ld a, 45 
d1de 6f				ld l, a 
d1df 00				nop 
d1e0 3e 17			ld a, 23 
d1e2 67				ld h, a 
d1e3			 
d1e3 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
d1e6			 
d1e6			;	ld (chk_stund), hl	; stack points.... 
d1e6 22 00 ef			ld (chk_stovr), hl 
d1e9 22 20 eb			ld (chk_ret_und), hl 
d1ec 22 de ea			ld (chk_ret_ovr), hl 
d1ef 22 dc e9			ld (chk_loop_ovr), hl 
d1f2 22 da e8			ld (chk_data_ovr), hl 
d1f5 c9				ret 
d1f6				 
d1f6			check_stacks: 
d1f6				; check all stack words 
d1f6			 
d1f6 e5				push hl 
d1f7 d5				push de 
d1f8			 
d1f8			;	ld de,(chk_word) 
d1f8			;	ld hl, (chk_stund)	; stack points.... 
d1f8			;	if DEBUG_STK_FAULT 
d1f8			;		DMARK "FAa" 
d1f8			;		CALLMONITOR 
d1f8			;	endif 
d1f8			;	call cmp16 
d1f8			;	jp z, .chk_faulta 
d1f8			; 
d1f8			;	ld de, sfaultsu 
d1f8			;	jp .chk_fault 
d1f8			 
d1f8 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d1fb ed 5b 6a e3		ld de,(chk_word) 
d1ff				if DEBUG_STK_FAULT 
d1ff					DMARK "FAb" 
d1ff					CALLMONITOR 
d1ff				endif 
d1ff cd d5 89			call cmp16 
d202 28 06			jr z, .chk_fault1 
d204 11 a5 d2			ld de, sfaultso 
d207 c3 59 d2			jp .chk_fault 
d20a			.chk_fault1:  
d20a 2a 20 eb			ld hl, (chk_ret_und) 
d20d ed 5b 6a e3		ld de,(chk_word) 
d211				if DEBUG_STK_FAULT 
d211					DMARK "FAU" 
d211					CALLMONITOR 
d211				endif 
d211 cd d5 89			call cmp16 
d214 ca 1d d2			jp z, .chk_fault2 
d217 11 b5 d2			ld de, sfaultru 
d21a c3 59 d2			jp .chk_fault 
d21d			.chk_fault2:  
d21d 2a de ea			ld hl, (chk_ret_ovr) 
d220 ed 5b 6a e3		ld de,(chk_word) 
d224				if DEBUG_STK_FAULT 
d224					DMARK "FA1" 
d224					CALLMONITOR 
d224				endif 
d224 cd d5 89			call cmp16 
d227 ca 30 d2			jp z, .chk_fault3 
d22a 11 c3 d2			ld de, sfaultro 
d22d c3 59 d2			jp .chk_fault 
d230			.chk_fault3:  
d230 2a dc e9			ld hl, (chk_loop_ovr) 
d233 ed 5b 6a e3		ld de,(chk_word) 
d237				if DEBUG_STK_FAULT 
d237					DMARK "FA2" 
d237					CALLMONITOR 
d237				endif 
d237 cd d5 89			call cmp16 
d23a ca 43 d2			jp z, .chk_fault4 
d23d 11 dd d2			ld de, sfaultlo 
d240 c3 59 d2			jp .chk_fault 
d243			.chk_fault4:  
d243 2a da e8			ld hl, (chk_data_ovr) 
d246 ed 5b 6a e3		ld de,(chk_word) 
d24a				if DEBUG_STK_FAULT 
d24a					DMARK "FA3" 
d24a					CALLMONITOR 
d24a				endif 
d24a cd d5 89			call cmp16 
d24d ca 56 d2			jp z, .chk_fault5 
d250 11 f7 d2			ld de, sfaultdo 
d253 c3 59 d2			jp .chk_fault 
d256			 
d256			 
d256			.chk_fault5:  
d256 d1				pop de 
d257 e1				pop hl 
d258			 
d258 c9				ret 
d259			 
d259 cd 5e 88		.chk_fault: 	call clear_display 
d25c 3e 28				ld a, display_row_2 
d25e cd 71 88				call str_at_display 
d261 11 87 d2				   ld de, .stackfault 
d264 3e 00				ld a, display_row_1 
d266 cd 71 88				call str_at_display 
d269 11 7a ee				    ld de, debug_mark 
d26c 3e 11				ld a, display_row_1+17 
d26e cd 71 88				call str_at_display 
d271 cd 81 88				call update_display 
d274			 
d274				; prompt before entering montior for investigating issue 
d274			 
d274 3e 78			ld a, display_row_4 
d276 11 22 94			ld de, endprog 
d279			 
d279 cd 81 88			call update_display		 
d27c			 
d27c cd 80 96			call next_page_prompt 
d27f			 
d27f d1				pop de 
d280 e1				pop hl 
d281 cd 76 94				call monitor 
d284 c3 70 93				jp warmstart 
d287					;jp 0 
d287					;halt 
d287			 
d287			 
d287			 
d287 .. 00		.stackfault: 	db "Stack fault:",0 
d294			 
d294 .. 00		sfaultsu: 	db	"Stack under flow",0 
d2a5 .. 00		sfaultso: 	db	"Stack over flow",0 
d2b5 .. 00		sfaultru:	db "RTS underflow",0 
d2c3 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d2dd .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d2f7 .. 00		sfaultdo:	db "DTS overflow", 0 
d304			 
d304			 
d304			fault_dsp_under: 
d304 11 16 d3			ld de, .dsp_under 
d307 c3 c6 d3			jp .show_fault 
d30a			 
d30a			fault_rsp_under: 
d30a 11 24 d3			ld de, .rsp_under 
d30d c3 c6 d3			jp .show_fault 
d310			fault_loop_under: 
d310 11 32 d3			ld de, .loop_under 
d313 c3 c6 d3			jp .show_fault 
d316			 
d316 .. 00		.dsp_under: db "DSP Underflow",0 
d324 .. 00		.rsp_under: db "RSP Underflow",0 
d332 .. 00		.loop_under: db "LOOP Underflow",0 
d341			 
d341			 
d341 d5			type_faultn: 	push de 
d342 e5					push hl 
d343 cd 5e 88				call clear_display 
d346 11 6d d3				   ld de, .typefaultn 
d349 3e 00				ld a, display_row_1 
d34b cd 71 88				call str_at_display 
d34e 11 7a ee				    ld de, debug_mark 
d351 3e 11				ld a, display_row_1+17 
d353 cd 71 88				call str_at_display 
d356 cd 81 88				call update_display 
d359			 
d359				; prompt before entering montior for investigating issue 
d359			 
d359 3e 78			ld a, display_row_4 
d35b 11 22 94			ld de, endprog 
d35e			 
d35e cd 81 88			call update_display		 
d361			 
d361 cd 80 96			call next_page_prompt 
d364			 
d364 e5					push hl 
d365 d5					push de 
d366 cd 76 94				call monitor 
d369 c3 70 93				jp warmstart 
d36c 76					halt 
d36d			 
d36d			 
d36d .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d384			 
d384 d5			type_faults: 	push de 
d385 e5					push hl 
d386 cd 5e 88				call clear_display 
d389 11 af d3				   ld de, .typefaults 
d38c 3e 00				ld a, display_row_1 
d38e cd 71 88				call str_at_display 
d391 11 7a ee				    ld de, debug_mark 
d394 3e 11				ld a, display_row_1+17 
d396 cd 71 88				call str_at_display 
d399 cd 81 88				call update_display 
d39c			 
d39c				; prompt before entering montior for investigating issue 
d39c			 
d39c 3e 78			ld a, display_row_4 
d39e 11 22 94			ld de, endprog 
d3a1			 
d3a1 cd 81 88			call update_display		 
d3a4			 
d3a4 cd 80 96			call next_page_prompt 
d3a7			 
d3a7 e1					pop hl 
d3a8 d1					pop de 
d3a9 cd 76 94				call monitor 
d3ac c3 70 93				jp warmstart 
d3af			 
d3af			 
d3af .. 00		.typefaults: db "STR Type Expected TOS!",0 
d3c6			 
d3c6			.show_fault: 	 
d3c6 d5					push de 
d3c7 cd 5e 88				call clear_display 
d3ca d1					pop de 
d3cb 3e 00				ld a, display_row_1 
d3cd cd 71 88				call str_at_display 
d3d0 11 7a ee				    ld de, debug_mark 
d3d3 3e 11				ld a, display_row_1+17 
d3d5 cd 71 88				call str_at_display 
d3d8 cd 81 88				call update_display 
d3db			 
d3db				; prompt before entering montior for investigating issue 
d3db			 
d3db 3e 78			ld a, display_row_4 
d3dd 11 22 94			ld de, endprog 
d3e0			 
d3e0 cd 81 88			call update_display		 
d3e3			 
d3e3 cd 80 96			call next_page_prompt 
d3e6			 
d3e6 e1					pop hl 
d3e7 d1					pop de 
d3e8 cd 76 94				call monitor 
d3eb			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d3eb			; TODO Make optional fault restart to cli or warm boot? 
d3eb					;jp warmstart 
d3eb c3 c8 93				jp cli 
d3ee 76					halt 
d3ef			; eof 
# End of file forth_kernel.asm
d3ef			;include "nascombasic.asm" 
d3ef			 
d3ef			 
d3ef			; find out where the code ends if loaded into RAM (for SC114) 
d3ef			;endofcode:  
d3ef			;	nop 
d3ef			 
d3ef			 
d3ef			; eof 
d3ef			 
# End of file main.asm
d3ef			;include "firmware_lcd_4x40.asm" 
d3ef			;;include "firmware_lcd_4x20.asm" 
d3ef			include "firmware_serial_display.asm" 
d3ef			 
d3ef			; Serial display interface for SC114 
d3ef			 
d3ef			 
d3ef			display_row_1: equ 0 
d3ef			display_row_2: equ display_row_1+display_cols 
d3ef			display_row_3: equ display_row_2 + display_cols 
d3ef			display_row_4: equ display_row_3 + display_cols 
d3ef			 
d3ef			kLCDWidth:  EQU display_cols             ;Width in characters 
d3ef			kLCD_Line1: EQU 0x00  
d3ef			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d3ef			; E1 
d3ef			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d3ef			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d3ef			 
d3ef			lcd_init: 
d3ef				; no init as handled by the SCM bios 
d3ef c9				ret 
d3f0			 
d3f0			 
d3f0			; low level functions for direct screen writes 
d3f0			 
d3f0			; output char at pos? 
d3f0			fLCD_Str: 
d3f0			        ;out (SC114_SIO_1_OUT),a 
d3f0 c5				push bc 
d3f1 0e 02			ld c, $02 
d3f3 f7				rst $30 
d3f4 c1				pop bc 
d3f5 c9				ret 
d3f6			 
d3f6			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d3f6			fLCD_Pos: 
d3f6				; use ASCII escape to position 
d3f6			        ;out (SC114_SIO_1_OUT),a 
d3f6 c5				push bc 
d3f7 0e 02			ld c, $02 
d3f9 f7				rst $30 
d3fa c1				pop bc 
d3fb			 
d3fb c9				ret 
d3fc			 
d3fc			; output char at pos 
d3fc			fLCD_Data: 
d3fc			      ;  out (SC114_SIO_1_OUT),a 
d3fc c5				push bc 
d3fd 0e 02			ld c, $02 
d3ff f7				rst $30 
d400 c1				pop bc 
d401			 
d401 c9				ret 
d402			 
d402			; ascii cls  
d402			 
d402 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d406			 
d406			; write the frame buffer given in hl to hardware  
d406			write_display: 
d406			 
d406			API: equ 0 
d406			 
d406			if API 
d406				push bc 
d406				ld b, 4 
d406			 
d406			        ld (display_write_tmp), hl 	  
d406			 
d406				; clear and home cursor 
d406			 
d406				ld c, 6 
d406				ld de, .cls 
d406				rst $30 
d406			 
d406			 
d406			.writeln: 
d406			 
d406				ld de, (display_write_tmp) 
d406				ld c, 6 
d406				rst $30 
d406				ld c, 7 
d406				rst $30 
d406			 
d406				ld hl, (display_write_tmp) 
d406				ld de, display_cols 
d406				add hl,de 
d406				ld (display_write_tmp),hl 
d406			 
d406				djnz  .writeln 
d406			 
d406				pop bc 
d406			 
d406			 
d406				ret 
d406			endif 
d406 e5				push hl 
d407 c5				push bc 
d408 d5				push de 
d409			 
d409			;	ld c, 2 
d409			;	;ld de, .cls 
d409			;	ld a, 27 
d409			;	rst $30 
d409			;	ld c, 2 
d409			;	;ld de, .cls 
d409			;	ld a, '[' 
d409			;	rst $30 
d409			; 
d409			;	ld c, 2 
d409			;	;ld de, .cls 
d409			;	ld a, 'H' 
d409			;	rst $30 
d409			; 
d409			 
d409 0e 02			ld c, 2 
d40b				;ld de, .cls 
d40b 3e 1b			ld a, 27 
d40d f7				rst $30 
d40e			 
d40e			 
d40e 0e 02			ld c, 2 
d410				;ld de, .cls 
d410 3e 5b			ld a, '[' 
d412 f7				rst $30 
d413 0e 02			ld c, 2 
d415				;ld de, .cls 
d415 3e 32			ld a, '2' 
d417 f7				rst $30 
d418 0e 02			ld c, 2 
d41a				;ld de, .cls 
d41a 3e 4a			ld a, 'J' 
d41c f7				rst $30 
d41d d1				pop de 
d41e c1				pop bc 
d41f e1				pop hl 
d420			 
d420			 
d420 22 d8 eb		        ld (display_write_tmp), hl 	  
d423 3e 00			ld a, kLCD_Line1 
d425			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d425 06 28			ld b, display_cols 
d427 ed 5b d8 eb		ld de, (display_write_tmp) 
d42b cd 89 d4			call write_len_string 
d42e				 
d42e			 
d42e e5			push hl 
d42f d5			push de 
d430 c5			push bc 
d431 0e 07			ld c, 7 
d433 f7				rst $30 
d434 c1			pop bc 
d435 d1			pop de 
d436 e1			pop hl 
d437			 
d437				 
d437 2a d8 eb			ld hl, (display_write_tmp) 
d43a 11 28 00			ld de, display_cols 
d43d 19				add hl,de 
d43e 22 d8 eb			ld (display_write_tmp),hl 
d441			 
d441				 
d441 3e 28			ld a, kLCD_Line2 
d443			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d443 06 28			ld b, display_cols 
d445 ed 5b d8 eb		ld de, (display_write_tmp) 
d449 cd 89 d4			call write_len_string 
d44c				 
d44c 2a d8 eb			ld hl, (display_write_tmp) 
d44f 11 28 00			ld de, display_cols 
d452 19				add hl,de 
d453 22 d8 eb			ld (display_write_tmp),hl 
d456			 
d456 e5			push hl 
d457 d5			push de 
d458 c5			push bc 
d459 0e 07			ld c, 7 
d45b f7				rst $30 
d45c c1			pop bc 
d45d d1			pop de 
d45e e1			pop hl 
d45f			 
d45f				 
d45f 3e 50			ld a, kLCD_Line3 
d461			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d461 06 28			ld b, display_cols 
d463 ed 5b d8 eb		ld de, (display_write_tmp) 
d467 cd 89 d4			call write_len_string 
d46a				 
d46a 2a d8 eb			ld hl, (display_write_tmp) 
d46d 11 28 00			ld de, display_cols 
d470 19				add hl,de 
d471 22 d8 eb			ld (display_write_tmp),hl 
d474			 
d474 e5			push hl 
d475 d5			push de 
d476 c5			push bc 
d477 0e 07			ld c, 7 
d479 f7				rst $30 
d47a c1			pop bc 
d47b d1			pop de 
d47c e1			pop hl 
d47d			 
d47d				 
d47d 3e 78			ld a, kLCD_Line4 
d47f			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d47f 06 28			ld b, display_cols 
d481 ed 5b d8 eb		ld de, (display_write_tmp) 
d485 cd 89 d4			call write_len_string 
d488 c9					ret 
d489			 
d489			 
d489				; write out a fixed length string given in b from de 
d489			 
d489 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d48a cd fc d3		            CALL fLCD_Data      ;Write character to display 
d48d 13				inc de 
d48e 10 f9			djnz write_len_string 
d490 c9				ret 
d491			 
d491			 
d491			; eof 
# End of file firmware_serial_display.asm
d491			;include "firmware_key_5x10.asm" 
d491			;;include "firmware_key_4x10.asm" 
d491			include "firmware_key_serial.asm" 
d491			; Serial keyboard interface for SC114 
d491			 
d491			key_init: 
d491				; no init as handled by the SCM bios 
d491 c9				ret 
d492			 
d492			 
d492			cin_wait: 
d492			;	ld a, 0 
d492			;	ret 
d492			 
d492				;in a,(SC114_SIO_1_IN) 
d492			        ; Use SCM API to get from whatever console device we are using 
d492 c5				push bc 
d493 0e 01			ld c, $01 
d495 f7				rst $30 
d496 c1				pop bc 
d497 c9				ret 
d498			 
d498			cin: 
d498			 
d498			 
d498 c5				push bc 
d499			 
d499				; any key waiting to process? 
d499 0e 03			ld c, $03 
d49b f7				rst $30 
d49c 28 05			jr z, .cin_skip 
d49e			 
d49e				; yep, get it 
d49e			 
d49e 0e 01			ld c, $01 
d4a0 f7				rst $30 
d4a1 c1				pop bc 
d4a2 c9				ret 
d4a3			.cin_skip: 
d4a3 3e 00			ld a, 0 
d4a5 c1				pop bc 
d4a6 c9				ret 
d4a7			 
d4a7			 
d4a7			 
d4a7			 
# End of file firmware_key_serial.asm
d4a7			endofcode:  
d4a7			baseram:  
d4a7 00				nop 
d4a8			 
d4a8			heap_start: equ baseram+15  ; Starting address of heap 
d4a8			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d4a8			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d4a8			;VDU:  EQU     endofcode           ; BASIC Work space 
d4a8			; eof 
d4a8			 
# End of file os_mega_sc114.asm
d4a8
