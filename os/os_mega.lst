# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 96 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd 93 71				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 2a 74			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 c9 1a			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 de 1a			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 ca f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 eb f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cf f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a eb f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a eb f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 eb f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 eb f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 f0 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a f0 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a eb f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 eb f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 f0 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 eb f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd f3 18			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd f3 18			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd f3 18			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd f3 18			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd f3 18			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd f3 18			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd f3 18			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd f3 18			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd f3 18			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd f3 18			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd f3 18			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd f3 18			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd f3 18			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd f3 18			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd f3 18			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd f3 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd f3 18			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd f3 18			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd f3 18			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd f3 18			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd f3 18			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd f3 18			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd f3 18			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd f3 18			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd f3 18			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd f3 18			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd f3 18			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd f3 18			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd f3 18			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd f3 18			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd f3 18			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd f3 18			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd f3 18			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd f3 18			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd f3 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd f3 18			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd f3 18			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd f3 18			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd f3 18			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd f3 18			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd f3 18			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd f3 18			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd f3 18			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd f3 18			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd f3 18			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd f3 18			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd f3 18			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd f3 18			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd f3 18			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd f3 18			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd f3 18			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd f3 18			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd df 1e			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd bf 71			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd 0a 75		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd f9 74				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd 0a 75				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 ef f4				ld hl, os_cli_cmd 
10cf 11 ee f5				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd ce 72		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd f0 72		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd 0a 75				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 c8 f1			ld hl, scratch 
1222 11 ee f5			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 7e 1c			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 fc f1			ld (scratch+52),a 
1323				 
1323 21 fa f1			ld hl,scratch+50 
1326 22 eb f4			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 aa f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 9c 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 ac f1		      ld    (heap_start+heap_size-2), HL 
140e 22 aa f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 06 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc df 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8 cc 2d 16			call z, .selautoload 
15eb fe 03			cp 3 
15ed cc 16 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc dd 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc ba 17			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc fd 18			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc e0 17			call z, hardware_diags 
1604			 
1604 18 d0			jr config 
1606			 
1606			.configmn: 
1606 ee 1a			dw prom_c3 
1608 05 1b			dw prom_c2 
160a 1a 1b			dw prom_c2a 
160c 30 1b			dw prom_c2b 
160e			;	dw prom_c4 
160e 4d 1b			dw prom_m4 
1610 68 1b			dw prom_m4b 
1612 70 1b			dw prom_c1 
1614 00 00			dw 0 
1616				 
1616			 
1616			 
1616			 
1616			.disautoload: 
1616				if STORAGE_SE 
1616 3e fe			ld a, $fe      ; bit 0 clear 
1618 32 67 fa			ld (spi_device), a 
161b			 
161b cd cd 04			call storage_get_block_0 
161e			 
161e 3e 00			ld a, 0 
1620 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1623			 
1623 21 00 00				ld hl, 0 
1626 11 81 fa				ld de, store_page 
1629 cd 81 04			call storage_write_block	 ; save update 
162c				else 
162c			 
162c				ld hl, prom_notav 
162c				ld de, prom_empty 
162c				call info_panel 
162c				endif 
162c			 
162c			 
162c c9				ret 
162d			 
162d			 
162d			 
162d			; Select auto start 
162d			 
162d			.selautoload: 
162d			 
162d				 
162d				if STORAGE_SE 
162d			 
162d cd 04 17				call config_dir 
1630 21 c8 f1			        ld hl, scratch 
1633 3e 00				ld a, 0 
1635 cd 49 0d				call menu 
1638			 
1638 fe 00				cp 0 
163a c8					ret z 
163b			 
163b 3d					dec a 
163c			 
163c			 
163c					; locate menu option 
163c			 
163c 21 c8 f1				ld hl, scratch 
163f cd 6d 0c				call table_lookup 
1642			 
1642					if DEBUG_FORTH_WORDS 
1642						DMARK "ALl" 
1642 f5				push af  
1643 3a 57 16			ld a, (.dmark)  
1646 32 6e fe			ld (debug_mark),a  
1649 3a 58 16			ld a, (.dmark+1)  
164c 32 6f fe			ld (debug_mark+1),a  
164f 3a 59 16			ld a, (.dmark+2)  
1652 32 70 fe			ld (debug_mark+2),a  
1655 18 03			jr .pastdmark  
1657 ..			.dmark: db "ALl"  
165a f1			.pastdmark: pop af  
165b			endm  
# End of macro DMARK
165b						CALLMONITOR 
165b cd f3 18			call break_point_state  
165e				endm  
# End of macro CALLMONITOR
165e					endif 
165e					; with the pointer to the menu it, the byte following the zero term is the file id 
165e			 
165e 3e 00				ld a, 0 
1660 01 32 00				ld bc, 50   ; max of bytes to look at 
1663 ed b1				cpir  
1665			 
1665					if DEBUG_FORTH_WORDS 
1665						DMARK "ALb" 
1665 f5				push af  
1666 3a 7a 16			ld a, (.dmark)  
1669 32 6e fe			ld (debug_mark),a  
166c 3a 7b 16			ld a, (.dmark+1)  
166f 32 6f fe			ld (debug_mark+1),a  
1672 3a 7c 16			ld a, (.dmark+2)  
1675 32 70 fe			ld (debug_mark+2),a  
1678 18 03			jr .pastdmark  
167a ..			.dmark: db "ALb"  
167d f1			.pastdmark: pop af  
167e			endm  
# End of macro DMARK
167e						CALLMONITOR 
167e cd f3 18			call break_point_state  
1681				endm  
# End of macro CALLMONITOR
1681					endif 
1681					;inc hl 
1681			 
1681 7e					ld a, (hl)   ; file id 
1682					 
1682				        ; save bank and file ids 
1682			 
1682 f5					push af 
1683			 
1683			; TODO need to save to block 0 on bank 1	 
1683			 
1683 cd cd 04				call storage_get_block_0 
1686			 
1686					if DEBUG_FORTH_WORDS 
1686						DMARK "AL0" 
1686 f5				push af  
1687 3a 9b 16			ld a, (.dmark)  
168a 32 6e fe			ld (debug_mark),a  
168d 3a 9c 16			ld a, (.dmark+1)  
1690 32 6f fe			ld (debug_mark+1),a  
1693 3a 9d 16			ld a, (.dmark+2)  
1696 32 70 fe			ld (debug_mark+2),a  
1699 18 03			jr .pastdmark  
169b ..			.dmark: db "AL0"  
169e f1			.pastdmark: pop af  
169f			endm  
# End of macro DMARK
169f						CALLMONITOR 
169f cd f3 18			call break_point_state  
16a2				endm  
# End of macro CALLMONITOR
16a2					endif 
16a2 f1					pop af 
16a3			 
16a3 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
16a6					 
16a6					; save bank id 
16a6			 
16a6 3a 67 fa				ld a,(spi_device) 
16a9 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
16ac			 
16ac					; enable auto run of store file 
16ac			 
16ac 3e 01				ld a, 1 
16ae 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
16b1			 
16b1					; save buffer 
16b1			 
16b1 21 00 00				ld hl, 0 
16b4 11 81 fa				ld de, store_page 
16b7					if DEBUG_FORTH_WORDS 
16b7						DMARK "ALw" 
16b7 f5				push af  
16b8 3a cc 16			ld a, (.dmark)  
16bb 32 6e fe			ld (debug_mark),a  
16be 3a cd 16			ld a, (.dmark+1)  
16c1 32 6f fe			ld (debug_mark+1),a  
16c4 3a ce 16			ld a, (.dmark+2)  
16c7 32 70 fe			ld (debug_mark+2),a  
16ca 18 03			jr .pastdmark  
16cc ..			.dmark: db "ALw"  
16cf f1			.pastdmark: pop af  
16d0			endm  
# End of macro DMARK
16d0						CALLMONITOR 
16d0 cd f3 18			call break_point_state  
16d3				endm  
# End of macro CALLMONITOR
16d3					endif 
16d3 cd 81 04			call storage_write_block	 ; save update 
16d6			  
16d6			 
16d6			 
16d6			 
16d6 21 c8 f1				ld hl, scratch 
16d9 cd f1 16				call config_fdir 
16dc			 
16dc				else 
16dc			 
16dc				ld hl, prom_notav 
16dc				ld de, prom_empty 
16dc				call info_panel 
16dc			 
16dc				endif 
16dc c9				ret 
16dd			 
16dd			 
16dd			 
16dd			; Select storage bank 
16dd			 
16dd			.selbank: 
16dd			 
16dd				if STORAGE_SE 
16dd				else 
16dd			 
16dd				ld hl, prom_notav 
16dd				ld de, prom_empty 
16dd				call info_panel 
16dd				endif 
16dd				 
16dd c9				ret 
16de			 
16de			if STORAGE_SE 
16de			 
16de			.config_ldir:   
16de				; Load storage bank labels into menu array 
16de			 
16de				 
16de			 
16de			 
16de c9				ret 
16df			 
16df			 
16df			endif 
16df			 
16df			 
16df			; Save user words to storage 
16df			 
16df			.savetostore: 
16df			 
16df				if STORAGE_SE 
16df			 
16df cd 04 17				call config_dir 
16e2 21 c8 f1			        ld hl, scratch 
16e5 3e 00				ld a, 0 
16e7 cd 49 0d				call menu 
16ea					 
16ea 21 c8 f1				ld hl, scratch 
16ed cd f1 16				call config_fdir 
16f0			 
16f0				else 
16f0			 
16f0				ld hl, prom_notav 
16f0				ld de, prom_empty 
16f0				call info_panel 
16f0			 
16f0				endif 
16f0			 
16f0 c9				ret 
16f1			 
16f1			 
16f1			 
16f1			if STORAGE_SE 
16f1			 
16f1			config_fdir: 
16f1				; using the scratch dir go through and release the memory allocated for each string 
16f1				 
16f1 21 c8 f1			ld hl, scratch 
16f4 5e			.cfdir:	ld e,(hl) 
16f5 23				inc hl 
16f6 56				ld d,(hl) 
16f7 23				inc hl 
16f8			 
16f8 eb				ex de, hl 
16f9 cd 75 0f			call ishlzero 
16fc c8				ret z     ; return on null pointer 
16fd cd dd 14			call free 
1700 eb				ex de, hl 
1701 18 f1			jr .cfdir 
1703			 
1703			 
1703 c9				ret 
1704			 
1704			 
1704			config_dir: 
1704			 
1704				; for the config menus that need to build a directory of storage call this routine 
1704				; it will construct a menu in scratch to pass to menu 
1704			 
1704				; open storage device 
1704			 
1704				; execute DIR to build a list of files and their ids into scratch in menu format 
1704				; once the menu has finished then will need to call config_fdir to release the strings 
1704				 
1704				; c = number items 
1704			 
1704				 
1704 cd cd 04			call storage_get_block_0 
1707			 
1707 21 81 fa			ld hl, store_page     ; get current id count 
170a 46				ld b, (hl) 
170b 0e 00			ld c, 0    ; count of files   
170d			 
170d			 
170d 21 c8 f1			ld hl, scratch 
1710 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
1713			 
1713				; check for empty drive 
1713			 
1713 3e 00			ld a, 0 
1715 b8				cp b 
1716 ca b0 17			jp z, .dirdone 
1719			 
1719				 
1719					if DEBUG_FORTH_WORDS 
1719						DMARK "Cdc" 
1719 f5				push af  
171a 3a 2e 17			ld a, (.dmark)  
171d 32 6e fe			ld (debug_mark),a  
1720 3a 2f 17			ld a, (.dmark+1)  
1723 32 6f fe			ld (debug_mark+1),a  
1726 3a 30 17			ld a, (.dmark+2)  
1729 32 70 fe			ld (debug_mark+2),a  
172c 18 03			jr .pastdmark  
172e ..			.dmark: db "Cdc"  
1731 f1			.pastdmark: pop af  
1732			endm  
# End of macro DMARK
1732						CALLMONITOR 
1732 cd f3 18			call break_point_state  
1735				endm  
# End of macro CALLMONITOR
1735					endif 
1735			 
1735			 
1735			.diritem:	 
1735 c5				push bc 
1736				; for each of the current ids do a search for them and if found push to stack 
1736			 
1736 21 40 00				ld hl, STORE_BLOCK_PHY 
1739 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
173b 58					ld e,b 
173c			 
173c cd 4f 07				call storage_findnextid 
173f			 
173f			 
173f					; if found hl will be non zero 
173f			 
173f cd 75 0f				call ishlzero 
1742 28 69				jr z, .dirnotfound 
1744			 
1744					; increase count 
1744			 
1744 c1					pop bc	 
1745 0c					inc c 
1746 c5					push bc 
1747					 
1747			 
1747					; get file header and push the file name 
1747			 
1747 11 81 fa				ld de, store_page 
174a cd 1c 04				call storage_read_block 
174d			 
174d					; push file id to stack 
174d				 
174d 3a 81 fa				ld a, (store_page) 
1750 26 00				ld h, 0 
1752 6f					ld l, a 
1753			 
1753					;call forth_push_numhl 
1753					; TODO store id 
1753			 
1753 e5					push hl 
1754			 
1754					; push extent count to stack  
1754				 
1754 21 84 fa				ld hl, store_page+3 
1757			 
1757					; get file name length 
1757			 
1757 cd aa 13				call strlenz   
175a			 
175a 23					inc hl   ; cover zero term 
175b 23					inc hl  ; stick the id at the end of the area 
175c			 
175c e5					push hl 
175d c1					pop bc    ; move length to bc 
175e			 
175e cd 13 14				call malloc 
1761			 
1761					; TODO save malloc area to scratch 
1761			 
1761 eb					ex de, hl 
1762 2a 78 fa				ld hl, (store_tmp2) 
1765 73					ld (hl), e 
1766 23					inc hl 
1767 72					ld (hl), d 
1768 23					inc hl 
1769 22 78 fa				ld (store_tmp2), hl 
176c			 
176c					 
176c			 
176c					;pop hl   ; get source 
176c			;		ex de, hl    ; swap aronund	 
176c			 
176c 21 84 fa				ld hl, store_page+3 
176f					if DEBUG_FORTH_WORDS 
176f						DMARK "CFd" 
176f f5				push af  
1770 3a 84 17			ld a, (.dmark)  
1773 32 6e fe			ld (debug_mark),a  
1776 3a 85 17			ld a, (.dmark+1)  
1779 32 6f fe			ld (debug_mark+1),a  
177c 3a 86 17			ld a, (.dmark+2)  
177f 32 70 fe			ld (debug_mark+2),a  
1782 18 03			jr .pastdmark  
1784 ..			.dmark: db "CFd"  
1787 f1			.pastdmark: pop af  
1788			endm  
# End of macro DMARK
1788						CALLMONITOR 
1788 cd f3 18			call break_point_state  
178b				endm  
# End of macro CALLMONITOR
178b					endif 
178b ed b0				ldir 
178d			 
178d					; de is past string, move back one and store id 
178d					 
178d 1b					dec de 
178e			 
178e					; store file id 
178e			 
178e e1					pop hl 
178f eb					ex de,hl 
1790 73					ld (hl), e 
1791			 
1791					if DEBUG_FORTH_WORDS 
1791						DMARK "Cdi" 
1791 f5				push af  
1792 3a a6 17			ld a, (.dmark)  
1795 32 6e fe			ld (debug_mark),a  
1798 3a a7 17			ld a, (.dmark+1)  
179b 32 6f fe			ld (debug_mark+1),a  
179e 3a a8 17			ld a, (.dmark+2)  
17a1 32 70 fe			ld (debug_mark+2),a  
17a4 18 03			jr .pastdmark  
17a6 ..			.dmark: db "Cdi"  
17a9 f1			.pastdmark: pop af  
17aa			endm  
# End of macro DMARK
17aa						CALLMONITOR 
17aa cd f3 18			call break_point_state  
17ad				endm  
# End of macro CALLMONITOR
17ad					endif 
17ad					 
17ad			.dirnotfound: 
17ad c1					pop bc     
17ae 10 85				djnz .diritem 
17b0				 
17b0			.dirdone:	 
17b0			 
17b0 3e 00				ld a, 0 
17b2 2a 78 fa				ld hl, (store_tmp2) 
17b5 77					ld (hl), a 
17b6 23					inc hl 
17b7 77					ld (hl), a 
17b8 23					inc hl 
17b9					; push a count of the dir items found 
17b9			 
17b9			;		ld h, 0 
17b9			;		ld l, c 
17b9			 
17b9 c9				ret 
17ba			 
17ba			endif 
17ba			 
17ba			 
17ba			; Settings 
17ba			; Run  
17ba			 
17ba			 
17ba			 
17ba			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17ba			;;hd_menu2:   db "        2: Editor",0   
17ba			;hd_menu2:   db "        2: Editor       6: Menu",0   
17ba			;hd_menu3:   db "        3: Storage",0 
17ba			;hd_menu4:   db "0=quit  4: Debug",0 
17ba			;hd_don:     db "ON",0 
17ba			;hd_doff:     db "OFF",0 
17ba			; 
17ba			; 
17ba			; 
17ba			;hardware_diags_old:       
17ba			; 
17ba			;.diagmenu: 
17ba			;	call clear_display 
17ba			;	ld a, display_row_1 
17ba			;	ld de, hd_menu1 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_2 
17ba			;	ld de, hd_menu2 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_3 
17ba			;	ld de, hd_menu3 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a,  display_row_4 
17ba			;	ld de, hd_menu4 
17ba			;	call str_at_display 
17ba			; 
17ba			;	; display debug state 
17ba			; 
17ba			;	ld de, hd_don 
17ba			;	ld a, (os_view_disable) 
17ba			;	cp 0 
17ba			;	jr z, .distog 
17ba			;	ld de, hd_doff 
17ba			;.distog: ld a, display_row_4+17 
17ba			;	call str_at_display 
17ba			; 
17ba			;	call update_display 
17ba			; 
17ba			;	call cin_wait 
17ba			; 
17ba			; 
17ba			; 
17ba			;	cp '4' 
17ba			;	jr nz, .diagn1 
17ba			; 
17ba			;	; debug toggle 
17ba			; 
17ba			;	ld a, (os_view_disable) 
17ba			;	ld b, '*' 
17ba			;	cp 0 
17ba			;	jr z, .debtog 
17ba			;	ld b, 0 
17ba			;.debtog:	 
17ba			;	ld a,b 
17ba			;	ld (os_view_disable),a 
17ba			; 
17ba			;.diagn1: cp '0' 
17ba			;	 ret z 
17ba			; 
17ba			;;	cp '1' 
17ba			;;       jp z, matrix	 
17ba			;;   TODO keyboard matrix test 
17ba			; 
17ba			;	cp '2' 
17ba			;	jp z, .diagedit 
17ba			; 
17ba			;;	cp '6' 
17ba			;;	jp z, .menutest 
17ba			;;if ENABLE_BASIC 
17ba			;;	cp '6' 
17ba			;;	jp z, basic 
17ba			;;endif 
17ba			 ; 
17ba			;	jp .diagmenu 
17ba			; 
17ba			; 
17ba			;	ret 
17ba			 
17ba			 
17ba			.debug_tog: 
17ba 21 01 18			ld hl, .menudebug 
17bd				 
17bd 3a b9 f1			ld a, (os_view_disable) 
17c0 fe 2a			cp '*' 
17c2 20 04			jr nz,.tdon  
17c4 3e 01			ld a, 1 
17c6 18 02			jr .tog1 
17c8 3e 00		.tdon: ld a, 0 
17ca			 
17ca			.tog1: 
17ca cd 49 0d			call menu 
17cd fe 00			cp 0 
17cf c8				ret z 
17d0 fe 01			cp 1    ; disable debug 
17d2 28 04			jr z, .dtog0 
17d4 3e 2a			ld a, '*' 
17d6 18 02			jr .dtogset 
17d8 3e 00		.dtog0: ld a, 0 
17da 32 b9 f1		.dtogset:  ld (os_view_disable), a 
17dd c3 ba 17			jp .debug_tog 
17e0			 
17e0			 
17e0			hardware_diags:       
17e0			 
17e0			.diagm: 
17e0 21 f3 17			ld hl, .menuitems 
17e3 3e 00			ld a, 0 
17e5 cd 49 0d			call menu 
17e8			 
17e8 fe 00		         cp 0 
17ea c8				 ret z 
17eb			 
17eb fe 02			cp 2 
17ed ca 4c 18			jp z, .diagedit 
17f0			 
17f0			;	cp '6' 
17f0			;	jp z, .menutest 
17f0			;if ENABLE_BASIC 
17f0			;	cp '6' 
17f0			;	jp z, basic 
17f0			;endif 
17f0			  
17f0 c3 e0 17			jp .diagm 
17f3			 
17f3				 
17f3 07 18		.menuitems:   	dw .m1 
17f5 12 18				dw .m2 
17f7 19 18				dw .m3 
17f9 21 18				dw .m5 
17fb 27 18				dw .m5a 
17fd 30 18				dw .m5b 
17ff 00 00				dw 0 
1801			 
1801			.menudebug: 
1801 39 18				dw .m6 
1803 42 18				dw .m7 
1805 00 00				dw 0 
1807			 
1807 .. 00		.m1:   db "Key Matrix",0 
1812 .. 00		.m2:   db "Editor",0 
1819 .. 00		.m3:   db "Storage",0 
1821 .. 00		.m5:   db "Sound",0 
1827 .. 00		.m5a:  db "RAM Test",0 
1830 .. 00		.m5b:  db "LCD Test",0 
1839			 
1839 .. 00		.m6:   db "Debug ON",0 
1842 .. 00		.m7:   db "Debug OFF",0 
184c			 
184c			; debug editor 
184c			 
184c			.diagedit: 
184c			 
184c 21 c8 f1			ld hl, scratch 
184f			;	ld bc, 250 
184f			;	ldir 
184f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
184f 3e 00			ld a, 0 
1851 77				ld (hl), a 
1852 23				inc hl 
1853 77				ld (hl), a 
1854 23				inc hl 
1855 77				ld (hl), a 
1856			 
1856 cd 18 0d		        call clear_display 
1859 cd 3b 0d			call update_display 
185c				;ld a, 1 
185c				;ld (hardware_diag), a 
185c			.diloop: 
185c 3e 00			ld a, display_row_1 
185e 0e 00			ld c, 0 
1860 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1862 1e 28			ld e, 40 
1864			 
1864 21 c8 f1			ld hl, scratch	 
1867 cd 79 0f			call input_str 
186a			 
186a 3e 28			ld a, display_row_2 
186c 11 c8 f1			ld de, scratch 
186f cd 2b 0d			call str_at_display 
1872 cd 3b 0d			call update_display 
1875			 
1875 c3 5c 18			jp .diloop 
1878			 
1878			 
1878			; pass word in hl 
1878			; a has display location 
1878			display_word_at: 
1878 f5				push af 
1879 e5				push hl 
187a 7c				ld a,h 
187b 21 cd f4			ld hl, os_word_scratch 
187e cd 4d 12			call hexout 
1881 e1				pop hl 
1882 7d				ld a,l 
1883 21 cf f4			ld hl, os_word_scratch+2 
1886 cd 4d 12			call hexout 
1889 21 d1 f4			ld hl, os_word_scratch+4 
188c 3e 00			ld a,0 
188e 77				ld (hl),a 
188f 11 cd f4			ld de,os_word_scratch 
1892 f1				pop af 
1893 cd 2b 0d				call str_at_display 
1896 c9				ret 
1897			 
1897			display_ptr_state: 
1897			 
1897				; to restore afterwards 
1897			 
1897 d5				push de 
1898 c5				push bc 
1899 e5				push hl 
189a f5				push af 
189b			 
189b				; for use in here 
189b			 
189b			;	push bc 
189b			;	push de 
189b			;	push hl 
189b			;	push af 
189b			 
189b cd 18 0d			call clear_display 
189e			 
189e 11 71 1a			ld de, .ptrstate 
18a1 3e 00			ld a, display_row_1 
18a3 cd 2b 0d			call str_at_display 
18a6			 
18a6				; display debug step 
18a6			 
18a6			 
18a6 11 6e fe			ld de, debug_mark 
18a9 3e 26			ld a, display_row_1+display_cols-2 
18ab cd 2b 0d			call str_at_display 
18ae			 
18ae				; display a 
18ae 11 7b 1a			ld de, .ptrcliptr 
18b1 3e 28			ld a, display_row_2 
18b3 cd 2b 0d			call str_at_display 
18b6			 
18b6 f1				pop af 
18b7 2a 47 fa			ld hl,(cli_ptr) 
18ba 3e 30			ld a, display_row_2+8 
18bc cd 78 18			call display_word_at 
18bf			 
18bf			 
18bf				; display hl 
18bf			 
18bf			 
18bf 11 83 1a			ld de, .ptrclioptr 
18c2 3e 32			ld a, display_row_2+10 
18c4 cd 2b 0d			call str_at_display 
18c7			; 
18c7			;	pop hl 
18c7 3e 35			ld a, display_row_2+13 
18c9 2a 45 fa			ld hl,(cli_origptr) 
18cc cd 78 18			call display_word_at 
18cf			; 
18cf			;	 
18cf			;	; display de 
18cf			 
18cf			;	ld de, .regstatede 
18cf			;	ld a, display_row_3 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop de 
18cf			;	ld h,d 
18cf			;	ld l, e 
18cf			;	ld a, display_row_3+3 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display bc 
18cf			 
18cf			;	ld de, .regstatebc 
18cf			;	ld a, display_row_3+10 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop bc 
18cf			;	ld h,b 
18cf			;	ld l, c 
18cf			;	ld a, display_row_3+13 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display dsp 
18cf			 
18cf			;	ld de, .regstatedsp 
18cf			;	ld a, display_row_4 
18cf			;	call str_at_display 
18cf			 
18cf				 
18cf			;	ld hl,(cli_data_sp) 
18cf			;	ld a, display_row_4+4 
18cf			;	call display_word_at 
18cf			 
18cf				; display rsp 
18cf			 
18cf 11 b2 1a			ld de, .regstatersp 
18d2 3e 82			ld a, display_row_4+10 
18d4 cd 2b 0d			call str_at_display 
18d7			 
18d7				 
18d7 2a f9 f9			ld hl,(cli_ret_sp) 
18da 3e 86			ld a, display_row_4+14 
18dc cd 78 18			call display_word_at 
18df			 
18df cd 3b 0d			call update_display 
18e2			 
18e2 cd 95 0c			call delay1s 
18e5 cd 95 0c			call delay1s 
18e8 cd 95 0c			call delay1s 
18eb			 
18eb			 
18eb cd df 1e			call next_page_prompt 
18ee			 
18ee				; restore  
18ee			 
18ee f1				pop af 
18ef e1				pop hl 
18f0 c1				pop bc 
18f1 d1				pop de 
18f2 c9				ret 
18f3			 
18f3			break_point_state: 
18f3 f5				push af 
18f4			 
18f4				; see if disabled 
18f4			 
18f4 3a b9 f1			ld a, (os_view_disable) 
18f7 fe 2a			cp '*' 
18f9 20 02			jr nz, .bpsgo 
18fb f1				pop af 
18fc c9				ret 
18fd			 
18fd			.bpsgo: 
18fd f1				pop af 
18fe f5				push af 
18ff 22 b5 f1			ld (os_view_hl), hl 
1902 ed 53 b3 f1		ld (os_view_de), de 
1906 ed 43 b1 f1		ld (os_view_bc), bc 
190a e5				push hl 
190b 6f				ld l, a 
190c 26 00			ld h, 0 
190e 22 b7 f1			ld (os_view_af),hl 
1911			 
1911 21 b4 fd				ld hl, display_fb0 
1914 22 cf fb				ld (display_fb_active), hl 
1917 e1				pop hl	 
1918			 
1918 3e 31			ld a, '1' 
191a fe 2a		.bps1:  cp '*' 
191c 20 03			jr nz, .bps1b 
191e 32 b9 f1			ld (os_view_disable),a 
1921 fe 31		.bps1b:  cp '1' 
1923 20 14			jr nz, .bps2 
1925			 
1925				; display reg 
1925			 
1925				 
1925			 
1925 3a b7 f1			ld a, (os_view_af) 
1928 2a b5 f1			ld hl, (os_view_hl) 
192b ed 5b b3 f1		ld de, (os_view_de) 
192f ed 4b b1 f1		ld bc, (os_view_bc) 
1933 cd cd 19			call display_reg_state 
1936 c3 b9 19			jp .bpschk 
1939			 
1939 fe 32		.bps2:  cp '2' 
193b 20 08			jr nz, .bps3 
193d				 
193d				; display hl 
193d 2a b5 f1			ld hl, (os_view_hl) 
1940 cd b7 1a			call display_dump_at_hl 
1943			 
1943 18 74			jr .bpschk 
1945			 
1945 fe 33		.bps3:  cp '3' 
1947 20 08			jr nz, .bps4 
1949			 
1949			        ; display de 
1949 2a b3 f1			ld hl, (os_view_de) 
194c cd b7 1a			call display_dump_at_hl 
194f			 
194f 18 68			jr .bpschk 
1951 fe 34		.bps4:  cp '4' 
1953 20 08			jr nz, .bps5 
1955			 
1955			        ; display bc 
1955 2a b1 f1			ld hl, (os_view_bc) 
1958 cd b7 1a			call display_dump_at_hl 
195b			 
195b 18 5c			jr .bpschk 
195d fe 35		.bps5:  cp '5' 
195f 20 08		        jr nz, .bps7 
1961			 
1961				; display cur ptr 
1961 2a 47 fa			ld hl, (cli_ptr) 
1964 cd b7 1a			call display_dump_at_hl 
1967			 
1967 18 50			jr .bpschk 
1969 fe 36		.bps7:  cp '6' 
196b 20 08			jr nz, .bps8b 
196d				 
196d				; display cur orig ptr 
196d 2a 45 fa			ld hl, (cli_origptr) 
1970 cd b7 1a			call display_dump_at_hl 
1973 18 44			jr .bpschk 
1975 fe 37		.bps8b:  cp '7' 
1977 20 08			jr nz, .bps9 
1979				 
1979				; display dsp 
1979 2a f5 f9			ld hl, (cli_data_sp) 
197c cd b7 1a			call display_dump_at_hl 
197f			 
197f 18 38			jr .bpschk 
1981 fe 39		.bps9:  cp '9' 
1983 20 05			jr nz, .bps8c 
1985				 
1985				; display SP 
1985			;	ld hl, sp 
1985 cd b7 1a			call display_dump_at_hl 
1988			 
1988 18 2f			jr .bpschk 
198a fe 38		.bps8c:  cp '8' 
198c 20 08			jr nz, .bps8d 
198e				 
198e				; display rsp 
198e 2a f9 f9			ld hl, (cli_ret_sp) 
1991 cd b7 1a			call display_dump_at_hl 
1994			 
1994 18 23			jr .bpschk 
1996 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1998 20 05			jr nz, .bps8 
199a cd d5 1c			call monitor 
199d			 
199d 18 1a			jr .bpschk 
199f fe 30		.bps8:  cp '0' 
19a1 20 16			jr nz, .bpschk 
19a3			 
19a3 21 13 fd				ld hl, display_fb1 
19a6 22 cf fb				ld (display_fb_active), hl 
19a9 cd 3b 0d				call update_display 
19ac			 
19ac				;ld a, (os_view_af) 
19ac 2a b5 f1			ld hl, (os_view_hl) 
19af ed 5b b3 f1		ld de, (os_view_de) 
19b3 ed 4b b1 f1		ld bc, (os_view_bc) 
19b7 f1				pop af 
19b8 c9				ret 
19b9			 
19b9			.bpschk:   
19b9 cd 95 0c			call delay1s 
19bc 3e 9f		ld a,display_row_4 + display_cols - 1 
19be 11 dd 1e		        ld de, endprg 
19c1 cd 2b 0d			call str_at_display 
19c4 cd 3b 0d			call update_display 
19c7 cd f9 74			call cin_wait 
19ca			 
19ca c3 1a 19			jp .bps1 
19cd			 
19cd			 
19cd			display_reg_state: 
19cd			 
19cd				; to restore afterwards 
19cd			 
19cd d5				push de 
19ce c5				push bc 
19cf e5				push hl 
19d0 f5				push af 
19d1			 
19d1				; for use in here 
19d1			 
19d1 c5				push bc 
19d2 d5				push de 
19d3 e5				push hl 
19d4 f5				push af 
19d5			 
19d5 cd 18 0d			call clear_display 
19d8			 
19d8 11 8d 1a			ld de, .regstate 
19db 3e 00			ld a, display_row_1 
19dd cd 2b 0d			call str_at_display 
19e0			 
19e0				; display debug step 
19e0			 
19e0			 
19e0 11 6e fe			ld de, debug_mark 
19e3 3e 25			ld a, display_row_1+display_cols-3 
19e5 cd 2b 0d			call str_at_display 
19e8			 
19e8				; display a 
19e8 11 a9 1a			ld de, .regstatea 
19eb 3e 28			ld a, display_row_2 
19ed cd 2b 0d			call str_at_display 
19f0			 
19f0 e1				pop hl 
19f1			;	ld h,0 
19f1			;	ld l, a 
19f1 3e 2b			ld a, display_row_2+3 
19f3 cd 78 18			call display_word_at 
19f6			 
19f6			 
19f6				; display hl 
19f6			 
19f6			 
19f6 11 9d 1a			ld de, .regstatehl 
19f9 3e 32			ld a, display_row_2+10 
19fb cd 2b 0d			call str_at_display 
19fe			 
19fe e1				pop hl 
19ff 3e 35			ld a, display_row_2+13 
1a01 cd 78 18			call display_word_at 
1a04			 
1a04				 
1a04				; display de 
1a04			 
1a04 11 a1 1a			ld de, .regstatede 
1a07 3e 50			ld a, display_row_3 
1a09 cd 2b 0d			call str_at_display 
1a0c			 
1a0c e1				pop hl 
1a0d			;	ld h,d 
1a0d			;	ld l, e 
1a0d 3e 53			ld a, display_row_3+3 
1a0f cd 78 18			call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12 11 a5 1a			ld de, .regstatebc 
1a15 3e 5a			ld a, display_row_3+10 
1a17 cd 2b 0d			call str_at_display 
1a1a			 
1a1a e1				pop hl 
1a1b			;	ld h,b 
1a1b			;	ld l, c 
1a1b 3e 5d			ld a, display_row_3+13 
1a1d cd 78 18			call display_word_at 
1a20			 
1a20			 
1a20				; display dsp 
1a20			 
1a20 11 ad 1a			ld de, .regstatedsp 
1a23 3e 78			ld a, display_row_4 
1a25 cd 2b 0d			call str_at_display 
1a28			 
1a28				 
1a28 2a f5 f9			ld hl,(cli_data_sp) 
1a2b 3e 7c			ld a, display_row_4+4 
1a2d cd 78 18			call display_word_at 
1a30			 
1a30				; display rsp 
1a30			 
1a30 11 b2 1a			ld de, .regstatersp 
1a33 3e 82			ld a, display_row_4+10 
1a35 cd 2b 0d			call str_at_display 
1a38			 
1a38				 
1a38 2a f9 f9			ld hl,(cli_ret_sp) 
1a3b 3e 86			ld a, display_row_4+14 
1a3d cd 78 18			call display_word_at 
1a40			 
1a40 cd 3b 0d			call update_display 
1a43			 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			 
1a43			 
1a43			;	call next_page_prompt 
1a43			 
1a43				; restore  
1a43			 
1a43 f1				pop af 
1a44 e1				pop hl 
1a45 c1				pop bc 
1a46 d1				pop de 
1a47 c9				ret 
1a48			 
1a48 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a5c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a71 .. 00		.ptrstate:	db "Ptr State",0 
1a7b .. 00		.ptrcliptr:     db "cli_ptr",0 
1a83 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a8d .. 00		.regstate:	db "Reg State (1/0)",0 
1a9d .. 00		.regstatehl:	db "HL:",0 
1aa1 .. 00		.regstatede:	db "DE:",0 
1aa5 .. 00		.regstatebc:	db "BC:",0 
1aa9 .. 00		.regstatea:	db "A :",0 
1aad .. 00		.regstatedsp:	db "DSP:",0 
1ab2 .. 00		.regstatersp:	db "RSP:",0 
1ab7			 
1ab7			display_dump_at_hl: 
1ab7 e5				push hl 
1ab8 d5				push de 
1ab9 c5				push bc 
1aba f5				push af 
1abb			 
1abb 22 eb f4			ld (os_cur_ptr),hl	 
1abe cd 18 0d			call clear_display 
1ac1 cd e7 1d			call dumpcont 
1ac4			;	call delay1s 
1ac4			;	call next_page_prompt 
1ac4			 
1ac4			 
1ac4 f1				pop af 
1ac5 c1				pop bc 
1ac6 d1				pop de 
1ac7 e1				pop hl 
1ac8 c9				ret 
1ac9			 
1ac9			;if ENABLE_BASIC 
1ac9			;	include "nascombasic.asm" 
1ac9			;	basic: 
1ac9			;	include "forth/FORTH.ASM" 
1ac9			;endif 
1ac9			 
1ac9			; eof 
1ac9			 
1ac9			 
# End of file firmware_diags.asm
1ac9			  
1ac9			include "firmware_prompts.asm"  
1ac9			; Prompts  
1ac9			 
1ac9			; boot messages 
1ac9			 
1ac9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ade .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aee			 
1aee			 
1aee			; config menus 
1aee			 
1aee .. 00		prom_c3: db "Add Dictionary To File",0 
1b05 .. 00		prom_c2: db "Select Autoload File",0 
1b1a .. 00		prom_c2a: db "Disable Autoload File", 0 
1b30 .. 00		prom_c2b: db "Select Storage Bank",0 
1b44 .. 00		prom_c4: db "Settings",0 
1b4d .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b68 .. 00		prom_m4b:   db "Monitor",0 
1b70 .. 00		prom_c1: db "Hardware Diags",0 
1b7f			 
1b7f			 
1b7f .. 00		prom_notav:    db "Feature not available",0 
1b95 .. 00		prom_empty:    db "",0 
1b96			 
1b96			; eof 
1b96			 
# End of file firmware_prompts.asm
1b96			  
1b96			  
1b96			; eof  
1b96			  
# End of file firmware.asm
1b96			 
1b96			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b96			;if BASE_KEV  
1b96			;baseram: equ 08000h 
1b96			;endif 
1b96			 
1b96			;if BASE_SC114 
1b96			;baseram:     equ    endofcode 
1b96			;endif 
1b96			 
1b96			 
1b96			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b96			 
1b96			; start system 
1b96			 
1b96			coldstart: 
1b96				; set sp 
1b96				; di/ei 
1b96			 
1b96 f3				di 
1b97 31 fd ff			ld sp, tos 
1b9a			;	ei 
1b9a			 
1b9a			 
1b9a				; disable breakpoint by default 
1b9a			 
1b9a 3e 2a			ld a,'*' 
1b9c 32 b9 f1			ld (os_view_disable),a 
1b9f			 
1b9f				; init hardware 
1b9f			 
1b9f				; init keyboard and screen hardware 
1b9f			 
1b9f cd 1c 00			call hardware_init 
1ba2			 
1ba2			 
1ba2 cd 95 0c			call delay1s 
1ba5 3e 58			ld a, display_row_3+8 
1ba7 11 03 00			ld de, buildtime 
1baa cd 2b 0d			call str_at_display 
1bad cd 3b 0d			call update_display 
1bb0			 
1bb0 cd 95 0c			call delay1s 
1bb3 cd 95 0c			call delay1s 
1bb6 cd 95 0c			call delay1s 
1bb9			 
1bb9				; detect if any keys are held down to enable breakpoints at start up 
1bb9			 
1bb9 cd 0a 75			call cin  
1bbc fe 00			cp 0 
1bbe 28 03			jr z, .nokeys 
1bc0			 
1bc0				;call hardware_diags 
1bc0 cd d6 15			call config 
1bc3			 
1bc3			;	ld de, .bpen 
1bc3			;	ld a, display_row_4 
1bc3			;	call str_at_display 
1bc3			;	call update_display 
1bc3			; 
1bc3			;	ld a,0 
1bc3			;	ld (os_view_disable),a 
1bc3			; 
1bc3			;.bpwait: 
1bc3			;	call cin 
1bc3			;	cp 0 
1bc3			;	jr z, .bpwait 
1bc3			;	jr .nokeys 
1bc3			; 
1bc3			; 
1bc3			;.bpen:  db "Break points enabled!",0 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			.nokeys: 
1bc3			 
1bc3			 
1bc3				 
1bc3			 
1bc3			;jp  testkey 
1bc3			 
1bc3			;call storage_get_block_0 
1bc3			; 
1bc3			;ld hl, 0 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3				 
1bc3			;ld hl, 10 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			;stop:	nop 
1bc3			;	jp stop 
1bc3			 
1bc3			 
1bc3			 
1bc3			main: 
1bc3 cd 18 0d			call clear_display 
1bc6 cd 3b 0d			call update_display 
1bc9			 
1bc9			 
1bc9			 
1bc9			;	call testlcd 
1bc9			 
1bc9			 
1bc9			 
1bc9 cd e4 22			call forth_init 
1bcc			 
1bcc			 
1bcc			warmstart: 
1bcc cd ba 22			call forth_warmstart 
1bcf			 
1bcf				; run startup word load 
1bcf			        ; TODO prevent this running at warmstart after crash  
1bcf			 
1bcf				if STARTUP_ENABLE 
1bcf					if STORAGE_SE 
1bcf cd 98 70					call forth_autoload 
1bd2					endif 
1bd2 cd a7 6d				call forth_startup 
1bd5			 
1bd5			 
1bd5				endif 
1bd5			 
1bd5				; show free memory after boot 
1bd5 11 6f 1c			ld de, freeram 
1bd8 3e 00			ld a, display_row_1 
1bda cd 2b 0d			call str_at_display 
1bdd			 
1bdd			; Or use heap_size word???? 
1bdd 21 ae f1			ld hl, heap_end 
1be0 11 0e 80			ld de, heap_start 
1be3 ed 52			sbc hl, de 
1be5 e5				push hl 
1be6 7c				ld a,h	         	 
1be7 21 cd f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bea cd 4d 12			call hexout 
1bed e1			   	pop hl 
1bee			 
1bee 7d				ld a,l 
1bef 21 cf f4			ld hl, os_word_scratch+2 
1bf2 cd 4d 12			call hexout 
1bf5 21 d1 f4			ld hl, os_word_scratch+4 
1bf8 3e 00			ld a, 0 
1bfa 77				ld (hl),a 
1bfb 11 cd f4			ld de, os_word_scratch 
1bfe 3e 0d			ld a, display_row_1 + 13 
1c00 cd 2b 0d			call str_at_display 
1c03 cd 3b 0d			call update_display 
1c06			 
1c06			 
1c06				;call demo 
1c06			 
1c06			 
1c06				; init scratch input area for cli commands 
1c06			 
1c06 21 ef f4			ld hl, os_cli_cmd 
1c09 3e 00			ld a,0 
1c0b 77				ld (hl),a 
1c0c 23				inc hl 
1c0d 77				ld (hl),a 
1c0e			 
1c0e 3e 00			ld a,0 
1c10 32 ee f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c13			 
1c13 32 eb f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c16 32 ec f4			ld (os_cur_ptr+1),a	 
1c19			 
1c19 32 cd f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c1c 32 ce f4			ld (os_word_scratch+1),a	 
1c1f				 
1c1f			 
1c1f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1f 21 ef f4			ld hl, os_cli_cmd 
1c22			 
1c22 3e 00			ld a, 0		 ; init cli input 
1c24 77				ld (hl), a 
1c25 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c27			cli: 
1c27				; show cli prompt 
1c27				;push af 
1c27				;ld a, 0 
1c27				;ld de, prompt 
1c27				;call str_at_display 
1c27			 
1c27				;call update_display 
1c27				;pop af 
1c27				;inc a 
1c27				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c27 0e 00			ld c, 0 
1c29 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c2b 1e 28			ld e, 40 
1c2d			 
1c2d 21 ef f4			ld hl, os_cli_cmd 
1c30			 
1c30				STACKFRAME OFF $fefe $9f9f 
1c30				if DEBUG_STACK_IMB 
1c30					if OFF 
1c30						exx 
1c30						ld de, $fefe 
1c30						ld a, d 
1c30						ld hl, curframe 
1c30						call hexout 
1c30						ld a, e 
1c30						ld hl, curframe+2 
1c30						call hexout 
1c30						ld hl, $fefe 
1c30						push hl 
1c30						ld hl, $9f9f 
1c30						push hl 
1c30						exx 
1c30					endif 
1c30				endif 
1c30			endm 
# End of macro STACKFRAME
1c30			 
1c30 cd 79 0f			call input_str 
1c33			 
1c33				STACKFRAMECHK OFF $fefe $9f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld hl, $9f9f 
1c33						pop de   ; $9f9f 
1c33						call cmp16 
1c33						jr nz, .spnosame 
1c33						ld hl, $fefe 
1c33						pop de   ; $fefe 
1c33						call cmp16 
1c33						jr z, .spfrsame 
1c33						.spnosame: call showsperror 
1c33						.spfrsame: nop 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAMECHK
1c33			 
1c33				; copy input to last command 
1c33			 
1c33 21 ef f4			ld hl, os_cli_cmd 
1c36 11 ee f5			ld de, os_last_cmd 
1c39 01 ff 00			ld bc, 255 
1c3c ed b0			ldir 
1c3e			 
1c3e				; wipe current buffer 
1c3e			 
1c3e			;	ld a, 0 
1c3e			;	ld hl, os_cli_cmd 
1c3e			;	ld de, os_cli_cmd+1 
1c3e			;	ld bc, 254 
1c3e			;	ldir 
1c3e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c3e			;	call strcpy 
1c3e			;	ld a, 0 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			 
1c3e				; switch frame buffer to program  
1c3e			 
1c3e 21 13 fd				ld hl, display_fb1 
1c41 22 cf fb				ld (display_fb_active), hl 
1c44			 
1c44			;	nop 
1c44				STACKFRAME ON $fbfe $8f9f 
1c44				if DEBUG_STACK_IMB 
1c44					if ON 
1c44						exx 
1c44						ld de, $fbfe 
1c44						ld a, d 
1c44						ld hl, curframe 
1c44						call hexout 
1c44						ld a, e 
1c44						ld hl, curframe+2 
1c44						call hexout 
1c44						ld hl, $fbfe 
1c44						push hl 
1c44						ld hl, $8f9f 
1c44						push hl 
1c44						exx 
1c44					endif 
1c44				endif 
1c44			endm 
# End of macro STACKFRAME
1c44				; first time into the parser so pass over the current scratch pad 
1c44 21 ef f4			ld hl,os_cli_cmd 
1c47				; tokenise the entered statement(s) in HL 
1c47 cd 62 23			call forthparse 
1c4a			        ; exec forth statements in top of return stack 
1c4a cd a2 23			call forthexec 
1c4d				;call forthexec_cleanup 
1c4d			;	call parsenext 
1c4d			 
1c4d				STACKFRAMECHK ON $fbfe $8f9f 
1c4d				if DEBUG_STACK_IMB 
1c4d					if ON 
1c4d						exx 
1c4d						ld hl, $8f9f 
1c4d						pop de   ; $8f9f 
1c4d						call cmp16 
1c4d						jr nz, .spnosame 
1c4d						ld hl, $fbfe 
1c4d						pop de   ; $fbfe 
1c4d						call cmp16 
1c4d						jr z, .spfrsame 
1c4d						.spnosame: call showsperror 
1c4d						.spfrsame: nop 
1c4d						exx 
1c4d					endif 
1c4d				endif 
1c4d			endm 
# End of macro STACKFRAMECHK
1c4d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c4d			 
1c4d 3e 78			ld a, display_row_4 
1c4f 11 81 1c			ld de, endprog 
1c52			 
1c52 cd 3b 0d			call update_display		 
1c55			 
1c55 cd df 1e			call next_page_prompt 
1c58			 
1c58				; switch frame buffer to cli 
1c58			 
1c58 21 b4 fd				ld hl, display_fb0 
1c5b 22 cf fb				ld (display_fb_active), hl 
1c5e			 
1c5e			 
1c5e cd 18 0d		        call clear_display 
1c61 cd 3b 0d			call update_display		 
1c64			 
1c64 21 ef f4			ld hl, os_cli_cmd 
1c67			 
1c67 3e 00			ld a, 0		 ; init cli input 
1c69 77				ld (hl), a 
1c6a			 
1c6a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c6a			 
1c6a				; now on last line 
1c6a			 
1c6a				; TODO scroll screen up 
1c6a			 
1c6a				; TODO instead just clear screen and place at top of screen 
1c6a			 
1c6a			;	ld a, 0 
1c6a			;	ld (f_cursor_ptr),a 
1c6a			 
1c6a				;call clear_display 
1c6a				;call update_display 
1c6a			 
1c6a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6c c3 27 1c			jp cli 
1c6f			 
1c6f .. 00		freeram: db "Free bytes: $",0 
1c7d ..			asc: db "1A2F" 
1c81 .. 00		endprog: db "End prog...",0 
1c8d			 
1c8d			testenter2:   
1c8d 21 fa f1			ld hl,scratch+50 
1c90 22 eb f4			ld (os_cur_ptr),hl 
1c93 c3 27 1c			jp cli 
1c96			 
1c96			testenter:  
1c96			 
1c96 21 7d 1c			ld hl,asc 
1c99			;	ld a,(hl) 
1c99			;	call nibble2val 
1c99 cd a3 12			call get_byte 
1c9c			 
1c9c			 
1c9c			;	ld a,(hl) 
1c9c			;	call atohex 
1c9c			 
1c9c			;	call fourehexhl 
1c9c 32 fa f1			ld (scratch+50),a 
1c9f			 
1c9f			 
1c9f			 
1c9f 21 7f 1c			ld hl,asc+2 
1ca2			;	ld a, (hl) 
1ca2			;	call nibble2val 
1ca2 cd a3 12			call get_byte 
1ca5			 
1ca5			;	call fourehexhl 
1ca5 32 fc f1			ld (scratch+52),a 
1ca8				 
1ca8 21 fa f1			ld hl,scratch+50 
1cab 22 eb f4			ld (os_cur_ptr),hl 
1cae c3 27 1c			jp cli 
1cb1			 
1cb1			enter:	 
1cb1 3a cc f1			ld a,(scratch+4) 
1cb4 fe 00			cp 0 
1cb6 28 0c			jr z, .entercont 
1cb8				; no, not a null term line so has an address to work out.... 
1cb8			 
1cb8 21 ca f1			ld hl,scratch+2 
1cbb cd 03 13			call get_word_hl 
1cbe			 
1cbe 22 eb f4			ld (os_cur_ptr),hl	 
1cc1 c3 27 1c			jp cli 
1cc4			 
1cc4			 
1cc4			.entercont:  
1cc4			 
1cc4 21 ca f1			ld hl, scratch+2 
1cc7 cd a3 12			call get_byte 
1cca			 
1cca 2a eb f4		   	ld hl,(os_cur_ptr) 
1ccd 77					ld (hl),a 
1cce 23					inc hl 
1ccf 22 eb f4				ld (os_cur_ptr),hl 
1cd2				 
1cd2			; get byte  
1cd2			 
1cd2			 
1cd2 c3 27 1c			jp cli 
1cd5			 
1cd5			 
1cd5			; basic monitor support 
1cd5			 
1cd5			monitor: 
1cd5				;  
1cd5 cd 18 0d			call clear_display 
1cd8 3e 00			ld a, 0 
1cda 11 22 1d			ld de, .monprompt 
1cdd cd 2b 0d			call str_at_display 
1ce0 cd 3b 0d			call update_display 
1ce3			 
1ce3				; get a monitor command 
1ce3			 
1ce3 0e 00			ld c, 0     ; entry at top left 
1ce5 16 64			ld d, 100   ; max buffer size 
1ce7 1e 0f			ld e, 15    ; input scroll area 
1ce9 3e 00			ld a, 0     ; init string 
1ceb 21 c6 f3			ld hl, os_input 
1cee 77				ld (hl), a 
1cef 23				inc hl 
1cf0 77				ld (hl), a 
1cf1 21 c6 f3			ld hl, os_input 
1cf4 3e 01			ld a, 1     ; init string 
1cf6 cd 79 0f			call input_str 
1cf9			 
1cf9 cd 18 0d		        call clear_display 
1cfc cd 3b 0d			call update_display		 
1cff			 
1cff 3a c6 f3			ld a, (os_input) 
1d02 cd a1 13			call toUpper 
1d05 fe 48		        cp 'H' 
1d07 28 6f		        jr z, .monhelp 
1d09 fe 44			cp 'D'		; dump 
1d0b ca 99 1d			jp z, .mondump	 
1d0e fe 43			cp 'C'		; dump 
1d10 ca b3 1d			jp z, .moncdump	 
1d13 fe 4d			cp 'M'		; dump 
1d15 ca 24 1d			jp z, .moneditstart 
1d18 fe 55			cp 'U'		; dump 
1d1a 28 14			jr z, .monedit	 
1d1c fe 51			cp 'Q'		; dump 
1d1e c8				ret z	 
1d1f			 
1d1f			 
1d1f				; TODO "S" to access symbol by name and not need the address 
1d1f				; TODO "F" to find a string in memory 
1d1f			 
1d1f c3 d5 1c			jp monitor 
1d22			 
1d22 .. 00		.monprompt: db ">", 0 
1d24			 
1d24			.moneditstart: 
1d24				; get starting address 
1d24			 
1d24 21 c8 f3			ld hl,os_input+2 
1d27 cd 03 13			call get_word_hl 
1d2a			 
1d2a 22 eb f4			ld (os_cur_ptr),hl	 
1d2d			 
1d2d c3 d5 1c			jp monitor 
1d30			 
1d30			.monedit: 
1d30				; get byte to load 
1d30			 
1d30 21 c8 f3			ld hl,os_input+2 
1d33 cd a3 12			call get_byte 
1d36			 
1d36				; get address to update 
1d36 2a eb f4			ld hl, (os_cur_ptr) 
1d39			 
1d39				; update byte 
1d39			 
1d39 77				ld (hl), a 
1d3a			 
1d3a				; move to next address and save it 
1d3a			 
1d3a 23				inc hl 
1d3b 22 eb f4			ld (os_cur_ptr),hl	 
1d3e			 
1d3e c3 d5 1c			jp monitor 
1d41			 
1d41			 
1d41 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d55 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d71 .. 00		.monhelptext3:  db "Q-Quit",0 
1d78			        
1d78			.monhelp: 
1d78 3e 00			ld a, display_row_1 
1d7a 11 41 1d		        ld de, .monhelptext1 
1d7d			 
1d7d cd 2b 0d			call str_at_display 
1d80 3e 28			ld a, display_row_2 
1d82 11 55 1d		        ld de, .monhelptext2 
1d85					 
1d85 cd 2b 0d			call str_at_display 
1d88 3e 50			ld a, display_row_3 
1d8a 11 71 1d		        ld de, .monhelptext3 
1d8d					 
1d8d cd 2b 0d			call str_at_display 
1d90 cd 3b 0d			call update_display		 
1d93			 
1d93 cd df 1e			call next_page_prompt 
1d96 c3 d5 1c			jp monitor 
1d99			 
1d99			.mondump:    
1d99 21 c8 f3			ld hl,os_input+2 
1d9c cd 03 13			call get_word_hl 
1d9f			 
1d9f 22 eb f4			ld (os_cur_ptr),hl	 
1da2 cd e7 1d			call dumpcont 
1da5 3e 78			ld a, display_row_4 
1da7 11 81 1c			ld de, endprog 
1daa			 
1daa cd 3b 0d			call update_display		 
1dad			 
1dad cd df 1e			call next_page_prompt 
1db0 c3 d5 1c			jp monitor 
1db3			.moncdump: 
1db3 cd e7 1d			call dumpcont 
1db6 3e 78			ld a, display_row_4 
1db8 11 81 1c			ld de, endprog 
1dbb			 
1dbb cd 3b 0d			call update_display		 
1dbe			 
1dbe cd df 1e			call next_page_prompt 
1dc1 c3 d5 1c			jp monitor 
1dc4			 
1dc4			 
1dc4			; TODO symbol access  
1dc4			 
1dc4			.symbols:     ;; A list of symbols that can be called up  
1dc4 b4 fd			dw display_fb0 
1dc6 .. 00			db "fb0",0  
1dca 81 fa		     	dw store_page 
1dcc .. 00			db "store_page",0 
1dd7			 
1dd7			 
1dd7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1dd7			 
1dd7 3a c9 f1			ld a,(scratch+1) 
1dda fe 00			cp 0 
1ddc 28 09			jr z, dumpcont 
1dde			 
1dde				; no, not a null term line so has an address to work out.... 
1dde			 
1dde 21 ca f1			ld hl,scratch+2 
1de1 cd 03 13			call get_word_hl 
1de4			 
1de4 22 eb f4			ld (os_cur_ptr),hl	 
1de7			 
1de7			 
1de7			 
1de7			dumpcont: 
1de7			 
1de7				; dump bytes at ptr 
1de7			 
1de7			 
1de7 3e 00			ld a, display_row_1 
1de9 2a cf fb			ld hl, (display_fb_active) 
1dec cd 4c 0f			call addatohl 
1def cd 17 1e			call .dumpbyterow 
1df2			 
1df2 3e 28			ld a, display_row_2 
1df4 2a cf fb			ld hl, (display_fb_active) 
1df7 cd 4c 0f			call addatohl 
1dfa cd 17 1e			call .dumpbyterow 
1dfd			 
1dfd			 
1dfd 3e 50			ld a, display_row_3 
1dff 2a cf fb			ld hl, (display_fb_active) 
1e02 cd 4c 0f			call addatohl 
1e05 cd 17 1e			call .dumpbyterow 
1e08			 
1e08 3e 78			ld a, display_row_4 
1e0a 2a cf fb			ld hl, (display_fb_active) 
1e0d cd 4c 0f			call addatohl 
1e10 cd 17 1e			call .dumpbyterow 
1e13			 
1e13 cd 3b 0d			call update_display 
1e16			;		jp cli 
1e16 c9				ret 
1e17			 
1e17			.dumpbyterow: 
1e17			 
1e17				;push af 
1e17			 
1e17 e5				push hl 
1e18			 
1e18				; calc where to poke the ascii 
1e18			if display_cols == 20 
1e18				ld a, 16 
1e18			else 
1e18 3e 1f			ld a, 31 
1e1a			endif 
1e1a			 
1e1a cd 4c 0f			call addatohl 
1e1d 22 cd f4			ld (os_word_scratch),hl  		; save pos for later 
1e20			 
1e20			 
1e20			; display decoding address 
1e20 2a eb f4		   	ld hl,(os_cur_ptr) 
1e23			 
1e23 7c				ld a,h 
1e24 e1				pop hl 
1e25 e5				push hl 
1e26			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e26 cd 4d 12			call hexout 
1e29 2a eb f4		   	ld hl,(os_cur_ptr) 
1e2c			 
1e2c 7d				ld a,l 
1e2d e1				pop hl 
1e2e 23				inc hl 
1e2f 23				inc hl 
1e30 e5				push hl 
1e31			;	ld hl, os_word_scratch+2 
1e31 cd 4d 12			call hexout 
1e34 e1				pop hl 
1e35 23				inc hl 
1e36 23				inc hl 
1e37				;ld hl, os_word_scratch+4 
1e37 3e 3a			ld a, ':' 
1e39 77				ld (hl),a 
1e3a 23				inc hl 
1e3b				;ld a, 0 
1e3b				;ld (hl),a 
1e3b				;ld de, os_word_scratch 
1e3b				;pop af 
1e3b				;push af 
1e3b			;		ld a, display_row_2 
1e3b			;		call str_at_display 
1e3b			;		call update_display 
1e3b			 
1e3b			 
1e3b			;pop af 
1e3b			;	add 5 
1e3b			 
1e3b			if display_cols == 20 
1e3b				ld b, 4 
1e3b			else 
1e3b 06 08			ld b, 8 
1e3d			endif	 
1e3d			 
1e3d			.dumpbyte: 
1e3d c5				push bc 
1e3e e5				push hl 
1e3f			 
1e3f			 
1e3f 2a eb f4		   	ld hl,(os_cur_ptr) 
1e42 7e					ld a,(hl) 
1e43			 
1e43					; poke the ascii to display 
1e43 2a cd f4				ld hl,(os_word_scratch) 
1e46 77					ld (hl),a 
1e47 23					inc hl 
1e48 22 cd f4				ld (os_word_scratch),hl 
1e4b			 
1e4b					 
1e4b			 
1e4b			 
1e4b e1					pop hl 
1e4c e5					push hl 
1e4d			 
1e4d cd 4d 12				call hexout 
1e50			 
1e50					 
1e50 2a eb f4		   	ld hl,(os_cur_ptr) 
1e53 23				inc hl 
1e54 22 eb f4		   	ld (os_cur_ptr),hl 
1e57			 
1e57 e1					pop hl 
1e58 23					inc hl 
1e59 23					inc hl 
1e5a 23					inc hl 
1e5b			 
1e5b			 
1e5b			 
1e5b					;ld a,0 
1e5b					;ld (os_word_scratch+2),a 
1e5b					;pop af 
1e5b					;push af 
1e5b			 
1e5b					;ld de, os_word_scratch 
1e5b					;call str_at_display 
1e5b			;		call update_display 
1e5b			;		pop af 
1e5b c1					pop bc 
1e5c c6 03				add 3 
1e5e 10 dd			djnz .dumpbyte 
1e60			 
1e60				 
1e60			 
1e60 c9				ret 
1e61			 
1e61			jump:	 
1e61			 
1e61 21 ca f1			ld hl,scratch+2 
1e64 cd 03 13			call get_word_hl 
1e67				;ld hl,(scratch+2) 
1e67				;call fourehexhl 
1e67			 
1e67 22 eb f4			ld (os_cur_ptr),hl	 
1e6a			 
1e6a e9				jp (hl) 
1e6b			 
1e6b			 
1e6b			 
1e6b			; TODO implement a basic monitor mode to start with 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			; testing and demo code during development 
1e6b			 
1e6b			 
1e6b .. 00		str1: db "Enter some text...",0 
1e7e .. 00		clear: db "                    ",0 
1e93			 
1e93			demo: 
1e93			 
1e93			 
1e93			 
1e93			;	call update_display 
1e93			 
1e93				; init scratch input area for testing 
1e93 21 c8 f1			ld hl, scratch	 
1e96 3e 00			ld a,0 
1e98 77				ld (hl),a 
1e99			 
1e99			 
1e99 3e 28		            LD   A, display_row_2 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 6b 1e		            LD   DE, str1 
1e9e cd 2b 0d			call str_at_display 
1ea1			 
1ea1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ea1			cloop:	 
1ea1 3e 50		            LD   A, display_row_3 
1ea3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ea3 11 7e 1e		            LD   DE, clear 
1ea6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ea6 cd 2b 0d				call str_at_display 
1ea9 3e 78			ld a, display_row_4 
1eab 11 db 1e			ld de, prompt 
1eae			 
1eae cd 2b 0d				call str_at_display 
1eb1 cd 3b 0d			call update_display 
1eb4			 
1eb4 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1eb6 16 0a			ld d, 10 
1eb8 21 c8 f1			ld hl, scratch	 
1ebb cd 79 0f			call input_str 
1ebe			 
1ebe			;	call clear_display 
1ebe			;'	call update_display 
1ebe			 
1ebe 3e 00		            LD   A, display_row_1 
1ec0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec0 11 7e 1e		            LD   DE, clear 
1ec3 cd 2b 0d				call str_at_display 
1ec6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ec6 3e 00		            LD   A, display_row_1 
1ec8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec8 11 c8 f1		            LD   DE, scratch 
1ecb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ecb cd 2b 0d				call str_at_display 
1ece cd 3b 0d			call update_display 
1ed1			 
1ed1 3e 00				ld a,0 
1ed3 21 c8 f1			ld hl, scratch 
1ed6 77				ld (hl),a 
1ed7			 
1ed7 00				nop 
1ed8 c3 a1 1e			jp cloop 
1edb			 
1edb			 
1edb			 
1edb			; OS Prompt 
1edb			 
1edb .. 00		prompt: db ">",0 
1edd .. 00		endprg: db "?",0 
1edf			 
1edf			 
1edf			; handy next page prompt 
1edf			next_page_prompt: 
1edf e5				push hl 
1ee0 d5				push de 
1ee1 f5				push af 
1ee2 c5				push bc 
1ee3			 
1ee3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ee5 11 dd 1e		        ld de, endprg 
1ee8 cd 2b 0d			call str_at_display 
1eeb cd 3b 0d			call update_display 
1eee cd f9 74			call cin_wait 
1ef1 c1				pop bc 
1ef2 f1				pop af 
1ef3 d1				pop de 
1ef4 e1				pop hl 
1ef5			 
1ef5			 
1ef5 c9				ret 
1ef6			 
1ef6			 
1ef6			; forth parser 
1ef6			 
1ef6			; My forth kernel 
1ef6			include "forth_kernel.asm" 
1ef6			; 
1ef6			; kernel to the forth OS 
1ef6			 
1ef6			DS_TYPE_STR: equ 1     ; string type 
1ef6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ef6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ef6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ef6			 
1ef6			FORTH_PARSEV1: equ 0 
1ef6			FORTH_PARSEV2: equ 0 
1ef6			FORTH_PARSEV3: equ 0 
1ef6			FORTH_PARSEV4: equ 0 
1ef6			FORTH_PARSEV5: equ 1 
1ef6			 
1ef6			;if FORTH_PARSEV5 
1ef6			;	FORTH_END_BUFFER: equ 0 
1ef6			;else 
1ef6			FORTH_END_BUFFER: equ 127 
1ef6			;endif 
1ef6			 
1ef6			FORTH_TRUE: equ 1 
1ef6			FORTH_FALSE: equ 0 
1ef6			 
1ef6			if FORTH_PARSEV4 
1ef6			include "forth_stackops.asm" 
1ef6			endif 
1ef6			 
1ef6			if FORTH_PARSEV5 
1ef6			include "forth_stackopsv5.asm" 
1ef6			 
1ef6			; Stack operations for v5 parser on wards 
1ef6			; * DATA stack 
1ef6			; * LOOP stack 
1ef6			; * RETURN stack 
1ef6			 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_DSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_data_sp) 
1ef6				ld de, cli_data_stack 
1ef6				call cmp16 
1ef6				jp c, fault_dsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_RSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_ret_sp) 
1ef6				ld de, cli_ret_stack 
1ef6				call cmp16 
1ef6				jp c, fault_rsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_CHK_LOOP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_loop_sp) 
1ef6				ld de, cli_loop_stack 
1ef6				call cmp16 
1ef6				jp c, fault_loop_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTSTR: macro 
1ef6				; TOSO might need more for checks when used 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_STR 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTNUM: macro 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_INUM 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			; increase data stack pointer and save hl to it 
1ef6				 
1ef6			FORTH_DSP_NEXT: macro 
1ef6				call macro_forth_dsp_next 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			macro_forth_dsp_next: 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd 71 6e				call check_stacks 
1ef9				endif 
1ef9 e5				push hl 
1efa d5				push de 
1efb eb				ex de,hl 
1efc 2a f5 f9			ld hl,(cli_data_sp) 
1eff 23				inc hl 
1f00 23				inc hl 
1f01			 
1f01			; PARSEV5 
1f01 23				inc hl 
1f02 22 f5 f9			ld (cli_data_sp),hl 
1f05 73				ld (hl), e 
1f06 23				inc hl 
1f07 72				ld (hl), d 
1f08 d1				pop de 
1f09 e1				pop hl 
1f0a				if DEBUG_FORTH_STACK_GUARD 
1f0a cd 71 6e				call check_stacks 
1f0d				endif 
1f0d c9				ret 
1f0e			 
1f0e			 
1f0e			; increase ret stack pointer and save hl to it 
1f0e				 
1f0e			FORTH_RSP_NEXT: macro 
1f0e				call macro_forth_rsp_next 
1f0e				endm 
1f0e			 
1f0e			macro_forth_rsp_next: 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd 71 6e				call check_stacks 
1f11				endif 
1f11 e5				push hl 
1f12 d5				push de 
1f13 eb				ex de,hl 
1f14 2a f9 f9			ld hl,(cli_ret_sp) 
1f17 23				inc hl 
1f18 23				inc hl 
1f19 22 f9 f9			ld (cli_ret_sp),hl 
1f1c 73				ld (hl), e 
1f1d 23				inc hl 
1f1e 72				ld (hl), d 
1f1f d1				pop de 
1f20 e1				pop hl 
1f21				if DEBUG_FORTH_STACK_GUARD 
1f21 cd 71 6e				call check_stacks 
1f24				endif 
1f24 c9				ret 
1f25			 
1f25			; get current ret stack pointer and save to hl  
1f25				 
1f25			FORTH_RSP_TOS: macro 
1f25				call macro_forth_rsp_tos 
1f25				endm 
1f25			 
1f25			macro_forth_rsp_tos: 
1f25				;push de 
1f25 2a f9 f9			ld hl,(cli_ret_sp) 
1f28 cd 60 1f			call loadhlptrtohl 
1f2b				;ld e, (hl) 
1f2b				;inc hl 
1f2b				;ld d, (hl) 
1f2b				;ex de, hl 
1f2b					if DEBUG_FORTH_WORDS 
1f2b			;			DMARK "RST" 
1f2b						CALLMONITOR 
1f2b cd f3 18			call break_point_state  
1f2e				endm  
# End of macro CALLMONITOR
1f2e					endif 
1f2e				;pop de 
1f2e c9				ret 
1f2f			 
1f2f			; pop ret stack pointer 
1f2f				 
1f2f			FORTH_RSP_POP: macro 
1f2f				call macro_forth_rsp_pop 
1f2f				endm 
1f2f			 
1f2f			 
1f2f			macro_forth_rsp_pop: 
1f2f				if DEBUG_FORTH_STACK_GUARD 
1f2f			;		DMARK "RPP" 
1f2f cd 71 6e				call check_stacks 
1f32					FORTH_CHK_RSP_UNDER 
1f32 e5				push hl 
1f33 d5				push de 
1f34 2a f9 f9			ld hl,(cli_ret_sp) 
1f37 11 b3 f9			ld de, cli_ret_stack 
1f3a cd 6a 0f			call cmp16 
1f3d da 85 6f			jp c, fault_rsp_under 
1f40 d1				pop de 
1f41 e1				pop hl 
1f42				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f42				endif 
1f42 e5				push hl 
1f43 2a f9 f9			ld hl,(cli_ret_sp) 
1f46			 
1f46			 
1f46				if FORTH_ENABLE_FREE 
1f46			 
1f46					; get pointer 
1f46			 
1f46					push de 
1f46					push hl 
1f46			 
1f46					ld e, (hl) 
1f46					inc hl 
1f46					ld d, (hl) 
1f46			 
1f46					ex de, hl 
1f46					call free 
1f46			 
1f46					pop hl 
1f46					pop de 
1f46			 
1f46			 
1f46				endif 
1f46			 
1f46			 
1f46 2b				dec hl 
1f47 2b				dec hl 
1f48 22 f9 f9			ld (cli_ret_sp), hl 
1f4b				; do stack underflow checks 
1f4b e1				pop hl 
1f4c				if DEBUG_FORTH_STACK_GUARD 
1f4c cd 71 6e				call check_stacks 
1f4f					FORTH_CHK_RSP_UNDER 
1f4f e5				push hl 
1f50 d5				push de 
1f51 2a f9 f9			ld hl,(cli_ret_sp) 
1f54 11 b3 f9			ld de, cli_ret_stack 
1f57 cd 6a 0f			call cmp16 
1f5a da 85 6f			jp c, fault_rsp_under 
1f5d d1				pop de 
1f5e e1				pop hl 
1f5f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f5f				endif 
1f5f c9				ret 
1f60			 
1f60			 
1f60			 
1f60			; routine to load word pointed to by hl into hl 
1f60			 
1f60			loadhlptrtohl: 
1f60			 
1f60 d5				push de 
1f61 5e				ld e, (hl) 
1f62 23				inc hl 
1f63 56				ld d, (hl) 
1f64 eb				ex de, hl 
1f65 d1				pop de 
1f66			 
1f66 c9				ret 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			; push a number held in HL onto the data stack 
1f67			; entry point for pushing a value when already in hl used in function above 
1f67			 
1f67			forth_push_numhl: 
1f67			 
1f67 e5				push hl    ; save value to push 
1f68			 
1f68			if DEBUG_FORTH_PUSH 
1f68				; see if disabled 
1f68			 
1f68			 
1f68 f5				push af 
1f69 3a b9 f1			ld a, (os_view_disable) 
1f6c fe 2a			cp '*' 
1f6e 28 34			jr z, .pskip2 
1f70 e5				push hl 
1f71 e5			push hl 
1f72 cd 18 0d			call clear_display 
1f75 e1			pop hl 
1f76 7c				ld a,h 
1f77 21 cd f4			ld hl, os_word_scratch 
1f7a cd 4d 12			call hexout 
1f7d e1				pop hl 
1f7e 7d				ld a,l 
1f7f 21 cf f4			ld hl, os_word_scratch+2 
1f82 cd 4d 12			call hexout 
1f85			 
1f85 21 d1 f4			ld hl, os_word_scratch+4 
1f88 3e 00			ld a,0 
1f8a 77				ld (hl),a 
1f8b 11 cd f4			ld de,os_word_scratch 
1f8e 3e 28				ld a, display_row_2 
1f90 cd 2b 0d				call str_at_display 
1f93 11 0d 5a			ld de, .push_num 
1f96 3e 00			ld a, display_row_1 
1f98			 
1f98 cd 2b 0d				call str_at_display 
1f9b			 
1f9b			 
1f9b cd 3b 0d			call update_display 
1f9e cd 95 0c			call delay1s 
1fa1 cd 95 0c			call delay1s 
1fa4			.pskip2:  
1fa4			 
1fa4 f1				pop af 
1fa5			endif	 
1fa5			 
1fa5			 
1fa5				FORTH_DSP_NEXT 
1fa5 cd f6 1e			call macro_forth_dsp_next 
1fa8				endm 
# End of macro FORTH_DSP_NEXT
1fa8			 
1fa8 2a f5 f9			ld hl, (cli_data_sp) 
1fab			 
1fab				; save item type 
1fab 3e 02			ld a,  DS_TYPE_INUM 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf			 
1faf				; get word off stack 
1faf d1				pop de 
1fb0 7b				ld a,e 
1fb1 77				ld (hl), a 
1fb2 23				inc hl 
1fb3 7a				ld a,d 
1fb4 77				ld (hl), a 
1fb5			 
1fb5			if DEBUG_FORTH_PUSH 
1fb5 2b				dec hl 
1fb6 2b				dec hl 
1fb7 2b				dec hl 
1fb8						DMARK "PH5" 
1fb8 f5				push af  
1fb9 3a cd 1f			ld a, (.dmark)  
1fbc 32 6e fe			ld (debug_mark),a  
1fbf 3a ce 1f			ld a, (.dmark+1)  
1fc2 32 6f fe			ld (debug_mark+1),a  
1fc5 3a cf 1f			ld a, (.dmark+2)  
1fc8 32 70 fe			ld (debug_mark+2),a  
1fcb 18 03			jr .pastdmark  
1fcd ..			.dmark: db "PH5"  
1fd0 f1			.pastdmark: pop af  
1fd1			endm  
# End of macro DMARK
1fd1				CALLMONITOR 
1fd1 cd f3 18			call break_point_state  
1fd4				endm  
# End of macro CALLMONITOR
1fd4			endif	 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; Push a string to stack pointed to by hl 
1fd5			 
1fd5			forth_push_str: 
1fd5			 
1fd5			if DEBUG_FORTH_PUSH 
1fd5						DMARK "PSQ" 
1fd5 f5				push af  
1fd6 3a ea 1f			ld a, (.dmark)  
1fd9 32 6e fe			ld (debug_mark),a  
1fdc 3a eb 1f			ld a, (.dmark+1)  
1fdf 32 6f fe			ld (debug_mark+1),a  
1fe2 3a ec 1f			ld a, (.dmark+2)  
1fe5 32 70 fe			ld (debug_mark+2),a  
1fe8 18 03			jr .pastdmark  
1fea ..			.dmark: db "PSQ"  
1fed f1			.pastdmark: pop af  
1fee			endm  
# End of macro DMARK
1fee				CALLMONITOR 
1fee cd f3 18			call break_point_state  
1ff1				endm  
# End of macro CALLMONITOR
1ff1			endif	 
1ff1			    
1ff1 e5				push hl 
1ff2 e5				push hl 
1ff3			 
1ff3			;	ld a, 0   ; find end of string 
1ff3 cd aa 13			call strlenz 
1ff6			if DEBUG_FORTH_PUSH 
1ff6						DMARK "PQ2" 
1ff6 f5				push af  
1ff7 3a 0b 20			ld a, (.dmark)  
1ffa 32 6e fe			ld (debug_mark),a  
1ffd 3a 0c 20			ld a, (.dmark+1)  
2000 32 6f fe			ld (debug_mark+1),a  
2003 3a 0d 20			ld a, (.dmark+2)  
2006 32 70 fe			ld (debug_mark+2),a  
2009 18 03			jr .pastdmark  
200b ..			.dmark: db "PQ2"  
200e f1			.pastdmark: pop af  
200f			endm  
# End of macro DMARK
200f				CALLMONITOR 
200f cd f3 18			call break_point_state  
2012				endm  
# End of macro CALLMONITOR
2012			endif	 
2012 eb				ex de, hl 
2013 e1				pop hl   ; get ptr to start of string 
2014			if DEBUG_FORTH_PUSH 
2014						DMARK "PQ3" 
2014 f5				push af  
2015 3a 29 20			ld a, (.dmark)  
2018 32 6e fe			ld (debug_mark),a  
201b 3a 2a 20			ld a, (.dmark+1)  
201e 32 6f fe			ld (debug_mark+1),a  
2021 3a 2b 20			ld a, (.dmark+2)  
2024 32 70 fe			ld (debug_mark+2),a  
2027 18 03			jr .pastdmark  
2029 ..			.dmark: db "PQ3"  
202c f1			.pastdmark: pop af  
202d			endm  
# End of macro DMARK
202d				CALLMONITOR 
202d cd f3 18			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030			endif	 
2030 19				add hl,de 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PQE" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 6e fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 6f fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 70 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PQE"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd f3 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d			 
204d 2b				dec hl    ; see if there is an optional trailing double quote 
204e 7e				ld a,(hl) 
204f fe 22			cp '"' 
2051 20 03			jr nz, .strnoq 
2053 3e 00			ld a, 0      ; get rid of double quote 
2055 77				ld (hl), a 
2056 23			.strnoq: inc hl 
2057			 
2057 3e 00			ld a, 0 
2059 77				ld (hl), a     ; add null term and get rid of trailing double quote 
205a			 
205a 13				inc de ; add one for the type string 
205b 13				inc de ; add one for null term??? 
205c			 
205c				; tos is get string pointer again 
205c				; de contains space to allocate 
205c				 
205c d5				push de 
205d			 
205d eb				ex de, hl 
205e			 
205e				;push af 
205e			 
205e			if DEBUG_FORTH_PUSH 
205e						DMARK "PHm" 
205e f5				push af  
205f 3a 73 20			ld a, (.dmark)  
2062 32 6e fe			ld (debug_mark),a  
2065 3a 74 20			ld a, (.dmark+1)  
2068 32 6f fe			ld (debug_mark+1),a  
206b 3a 75 20			ld a, (.dmark+2)  
206e 32 70 fe			ld (debug_mark+2),a  
2071 18 03			jr .pastdmark  
2073 ..			.dmark: db "PHm"  
2076 f1			.pastdmark: pop af  
2077			endm  
# End of macro DMARK
2077				CALLMONITOR 
2077 cd f3 18			call break_point_state  
207a				endm  
# End of macro CALLMONITOR
207a			endif	 
207a cd 13 14			call malloc	; on ret hl now contains allocated memory 
207d				if DEBUG_FORTH_MALLOC_GUARD 
207d cc 65 5a				call z,malloc_error 
2080				endif 
2080			 
2080				 
2080 c1				pop bc    ; get length 
2081 d1				pop de   ;  get string start    
2082			 
2082				; hl has destination from malloc 
2082			 
2082 eb				ex de, hl    ; prep for ldir 
2083			 
2083 d5				push de   ; save malloc area for DSP later 
2084				;push hl   ; save malloc area for DSP later 
2084			 
2084			if DEBUG_FORTH_PUSH 
2084						DMARK "PHc" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 6e fe			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 6f fe			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 70 fe			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "PHc"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d				CALLMONITOR 
209d cd f3 18			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0			endif	 
20a0			 
20a0			 
20a0 ed b0			ldir 
20a2			 
20a2			 
20a2				; push malloc to data stack     macro?????  
20a2			 
20a2				FORTH_DSP_NEXT 
20a2 cd f6 1e			call macro_forth_dsp_next 
20a5				endm 
# End of macro FORTH_DSP_NEXT
20a5			 
20a5				; save value and type 
20a5			 
20a5 2a f5 f9			ld hl, (cli_data_sp) 
20a8			 
20a8				; save item type 
20a8 3e 01			ld a,  DS_TYPE_STR 
20aa 77				ld (hl), a 
20ab 23				inc hl 
20ac			 
20ac				; get malloc word off stack 
20ac d1				pop de 
20ad 73				ld (hl), e 
20ae 23				inc hl 
20af 72				ld (hl), d 
20b0			 
20b0			 
20b0			 
20b0			if DEBUG_FORTH_PUSH 
20b0 2a f5 f9			ld hl, (cli_data_sp) 
20b3						DMARK "PHS" 
20b3 f5				push af  
20b4 3a c8 20			ld a, (.dmark)  
20b7 32 6e fe			ld (debug_mark),a  
20ba 3a c9 20			ld a, (.dmark+1)  
20bd 32 6f fe			ld (debug_mark+1),a  
20c0 3a ca 20			ld a, (.dmark+2)  
20c3 32 70 fe			ld (debug_mark+2),a  
20c6 18 03			jr .pastdmark  
20c8 ..			.dmark: db "PHS"  
20cb f1			.pastdmark: pop af  
20cc			endm  
# End of macro DMARK
20cc				CALLMONITOR 
20cc cd f3 18			call break_point_state  
20cf				endm  
# End of macro CALLMONITOR
20cf			;	ex de,hl 
20cf			endif	 
20cf				; in case of spaces, skip the ptr past the copied string 
20cf				;pop af 
20cf				;ld (cli_origptr),hl 
20cf			 
20cf c9				ret 
20d0			 
20d0			 
20d0			 
20d0			; TODO ascii push input onto stack given hl to start of input 
20d0			 
20d0			; identify type 
20d0			; if starts with a " then a string 
20d0			; otherwise it is a number 
20d0			;  
20d0			; if a string 
20d0			;     scan for ending " to get length of string to malloc for + 1 
20d0			;     malloc 
20d0			;     put pointer to string on stack first byte flags as string 
20d0			; 
20d0			; else a number 
20d0			;    look for number format identifier 
20d0			;    $xx hex 
20d0			;    %xxxxx bin 
20d0			;    xxxxx decimal 
20d0			;    convert number to 16bit word.  
20d0			;    malloc word + 1 with flag to identiy as num 
20d0			;    put pointer to number on stack 
20d0			;   
20d0			;  
20d0			  
20d0			forth_apush: 
20d0				; kernel push 
20d0			 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PSH" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 6e fe			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 6f fe			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 70 fe			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PSH"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd f3 18			call break_point_state  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec				; identify input type 
20ec			 
20ec 7e				ld a,(hl) 
20ed fe 22			cp '"' 
20ef 28 0a			jr z, .fapstr 
20f1 fe 24			cp '$' 
20f3 ca 1b 21			jp z, .faphex 
20f6 fe 25			cp '%' 
20f8 ca 03 21			jp z, .fapbin 
20fb			;	cp 'b' 
20fb			;	jp z, .fabin 
20fb				; else decimal 
20fb			 
20fb				; TODO do decimal conversion 
20fb				; decimal is stored as a 16bit word 
20fb			 
20fb				; by default everything is a string if type is not detected 
20fb			.fapstr: ; 
20fb fe 22			cp '"' 
20fd 20 01			jr nz, .strnoqu 
20ff 23				inc hl 
2100			.strnoqu: 
2100 c3 d5 1f			jp forth_push_str 
2103			 
2103			 
2103			 
2103			.fapbin:    ; push a binary string.  
2103 11 00 00			ld de, 0   ; hold a 16bit value 
2106			 
2106 23			.fapbinshift:	inc hl  
2107 7e				ld a,(hl) 
2108 fe 00			cp 0     ; done scanning  
210a 28 0b			jr z, .fapbdone  	; got it in HL so push  
210c			 
210c				; left shift de 
210c eb				ex de, hl	 
210d 29				add hl, hl 
210e			 
210e				; is 1 
210e fe 31			cp '1' 
2110 20 02			jr nz, .binzero 
2112 cb 4d			bit 1, l 
2114			.binzero: 
2114 eb				ex de, hl	 ; save current de 
2115 18 ef			jr .fapbinshift 
2117			 
2117			.fapbdone: 
2117 eb				ex de, hl 
2118 c3 67 1f			jp forth_push_numhl 
211b			 
211b			 
211b			.faphex:   ; hex is always stored as a 16bit word 
211b				; skip number prefix 
211b 23				inc hl 
211c				; turn ascii into number 
211c cd 03 13			call get_word_hl	; ret 16bit word in hl 
211f			 
211f c3 67 1f			jp forth_push_numhl 
2122			 
2122 00				 nop 
2123			 
2123			.fabin:   ; TODO bin conversion 
2123			 
2123			 
2123 c9				ret 
2124			 
2124			 
2124			; get either a string ptr or a 16bit word from the data stack 
2124			 
2124			FORTH_DSP: macro 
2124				call macro_forth_dsp 
2124				endm 
2124			 
2124			macro_forth_dsp: 
2124				; data stack pointer points to current word on tos 
2124			 
2124 2a f5 f9			ld hl,(cli_data_sp) 
2127			 
2127				if DEBUG_FORTH_PUSH 
2127						DMARK "DSP" 
2127 f5				push af  
2128 3a 3c 21			ld a, (.dmark)  
212b 32 6e fe			ld (debug_mark),a  
212e 3a 3d 21			ld a, (.dmark+1)  
2131 32 6f fe			ld (debug_mark+1),a  
2134 3a 3e 21			ld a, (.dmark+2)  
2137 32 70 fe			ld (debug_mark+2),a  
213a 18 03			jr .pastdmark  
213c ..			.dmark: db "DSP"  
213f f1			.pastdmark: pop af  
2140			endm  
# End of macro DMARK
2140			 
2140 cd 9a 5a				call display_data_sp 
2143				;call break_point_state 
2143				;rst 030h 
2143				CALLMONITOR 
2143 cd f3 18			call break_point_state  
2146				endm  
# End of macro CALLMONITOR
2146				endif 
2146			 
2146 c9				ret 
2147			 
2147			; return hl to start of value on stack 
2147			 
2147			FORTH_DSP_VALUE: macro 
2147				call macro_forth_dsp_value 
2147				endm 
2147			 
2147			macro_forth_dsp_value: 
2147			 
2147				FORTH_DSP 
2147 cd 24 21			call macro_forth_dsp 
214a				endm 
# End of macro FORTH_DSP
214a			 
214a d5				push de 
214b			 
214b 23				inc hl ; skip type 
214c			 
214c 5e				ld e, (hl) 
214d 23				inc hl 
214e 56				ld d, (hl) 
214f eb				ex de,hl  
2150			 
2150 d1				pop de 
2151			 
2151 c9				ret 
2152			 
2152			; return hl to start of value to second item on stack 
2152			 
2152			FORTH_DSP_VALUEM1: macro 
2152				call macro_forth_dsp_value_m1 
2152				endm 
2152			 
2152			macro_forth_dsp_value_m1: 
2152			 
2152				FORTH_DSP 
2152 cd 24 21			call macro_forth_dsp 
2155				endm 
# End of macro FORTH_DSP
2155			 
2155 2b				dec hl 
2156 2b				dec hl 
2157			;	dec hl 
2157			 
2157 d5				push de 
2158			 
2158 5e				ld e, (hl) 
2159 23				inc hl 
215a 56				ld d, (hl) 
215b eb				ex de,hl  
215c			 
215c d1				pop de 
215d			 
215d c9				ret 
215e			 
215e				 
215e			 
215e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
215e			 
215e			FORTH_DSP_POP: macro 
215e				call macro_forth_dsp_pop 
215e				endm 
215e			 
215e			 
215e			; get the tos data type 
215e			 
215e			FORTH_DSP_TYPE:   macro 
215e			 
215e				;FORTH_DSP_VALUE 
215e				FORTH_DSP 
215e				 
215e				; hl points to value 
215e				; check type 
215e			 
215e				ld a,(hl) 
215e			 
215e				endm 
215e			 
215e			; load the tos value into hl 
215e			 
215e			 
215e			FORTH_DSP_VALUEHL:  macro 
215e				call macro_dsp_valuehl 
215e				endm 
215e			 
215e			 
215e			 
215e			macro_dsp_valuehl: 
215e				FORTH_DSP_VALUE 
215e cd 47 21			call macro_forth_dsp_value 
2161				endm 
# End of macro FORTH_DSP_VALUE
2161			 
2161				;FORTH_ERR_TOS_NOTNUM 
2161			 
2161				;inc hl   ; skip type id 
2161			 
2161			;	push de 
2161			; 
2161			;	ld e, (hl) 
2161			;	inc hl 
2161			;	ld d, (hl) 
2161			;	ex de,hl  
2161			 
2161			;	pop de 
2161			 
2161				if DEBUG_FORTH_PUSH 
2161						DMARK "DVL" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 6e fe			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 6f fe			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 70 fe			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "DVL"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd f3 18			call break_point_state  
217d				endm  
# End of macro CALLMONITOR
217d				endif 
217d c9				ret 
217e			 
217e			forth_apushstrhl:      
217e				; push of string requires use of cli_origptr 
217e				; bodge use 
217e			 
217e				; get current cli_origptr, save, update with temp pointer  
217e ed 5b 45 fa		ld de, (cli_origptr) 
2182 22 45 fa			ld (cli_origptr), hl 
2185 d5				push de 
2186 cd d0 20			call forth_apush 
2189 d1				pop de 
218a ed 53 45 fa		ld (cli_origptr), de 
218e c9			        ret	 
218f			 
218f			 
218f			; increase loop stack pointer and save hl to it 
218f				 
218f			FORTH_LOOP_NEXT: macro 
218f				call macro_forth_loop_next 
218f				;nop 
218f				endm 
218f			 
218f			macro_forth_loop_next: 
218f				if DEBUG_FORTH_STACK_GUARD 
218f cd 71 6e				call check_stacks 
2192				endif 
2192 e5				push hl 
2193 d5				push de 
2194 eb				ex de,hl 
2195 2a f7 f9			ld hl,(cli_loop_sp) 
2198 23				inc hl 
2199 23				inc hl 
219a					if DEBUG_FORTH_WORDS 
219a						DMARK "LNX" 
219a f5				push af  
219b 3a af 21			ld a, (.dmark)  
219e 32 6e fe			ld (debug_mark),a  
21a1 3a b0 21			ld a, (.dmark+1)  
21a4 32 6f fe			ld (debug_mark+1),a  
21a7 3a b1 21			ld a, (.dmark+2)  
21aa 32 70 fe			ld (debug_mark+2),a  
21ad 18 03			jr .pastdmark  
21af ..			.dmark: db "LNX"  
21b2 f1			.pastdmark: pop af  
21b3			endm  
# End of macro DMARK
21b3						CALLMONITOR 
21b3 cd f3 18			call break_point_state  
21b6				endm  
# End of macro CALLMONITOR
21b6					endif 
21b6 22 f7 f9			ld (cli_loop_sp),hl 
21b9 73				ld (hl), e 
21ba 23				inc hl 
21bb 72				ld (hl), d 
21bc d1				pop de    ; been reversed so save a swap on restore 
21bd e1				pop hl 
21be				if DEBUG_FORTH_STACK_GUARD 
21be cd 71 6e				call check_stacks 
21c1				endif 
21c1 c9				ret 
21c2			 
21c2			; get current ret stack pointer and save to hl  
21c2				 
21c2			FORTH_LOOP_TOS: macro 
21c2				call macro_forth_loop_tos 
21c2				endm 
21c2			 
21c2			macro_forth_loop_tos: 
21c2 d5				push de 
21c3 2a f7 f9			ld hl,(cli_loop_sp) 
21c6 5e				ld e, (hl) 
21c7 23				inc hl 
21c8 56				ld d, (hl) 
21c9 eb				ex de, hl 
21ca d1				pop de 
21cb c9				ret 
21cc			 
21cc			; pop loop stack pointer 
21cc				 
21cc			FORTH_LOOP_POP: macro 
21cc				call macro_forth_loop_pop 
21cc				endm 
21cc			 
21cc			 
21cc			macro_forth_loop_pop: 
21cc				if DEBUG_FORTH_STACK_GUARD 
21cc					DMARK "LPP" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 6e fe			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 6f fe			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 70 fe			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db "LPP"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5 cd 71 6e				call check_stacks 
21e8					FORTH_CHK_LOOP_UNDER 
21e8 e5				push hl 
21e9 d5				push de 
21ea 2a f7 f9			ld hl,(cli_loop_sp) 
21ed 11 31 f9			ld de, cli_loop_stack 
21f0 cd 6a 0f			call cmp16 
21f3 da 8b 6f			jp c, fault_loop_under 
21f6 d1				pop de 
21f7 e1				pop hl 
21f8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21f8				endif 
21f8 e5				push hl 
21f9 2a f7 f9			ld hl,(cli_loop_sp) 
21fc 2b				dec hl 
21fd 2b				dec hl 
21fe 22 f7 f9			ld (cli_loop_sp), hl 
2201				; TODO do stack underflow checks 
2201 e1				pop hl 
2202				if DEBUG_FORTH_STACK_GUARD 
2202 cd 71 6e				call check_stacks 
2205					FORTH_CHK_LOOP_UNDER 
2205 e5				push hl 
2206 d5				push de 
2207 2a f7 f9			ld hl,(cli_loop_sp) 
220a 11 31 f9			ld de, cli_loop_stack 
220d cd 6a 0f			call cmp16 
2210 da 8b 6f			jp c, fault_loop_under 
2213 d1				pop de 
2214 e1				pop hl 
2215				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2215				endif 
2215 c9				ret 
2216			 
2216			macro_forth_dsp_pop: 
2216			 
2216 e5				push hl 
2217			 
2217				; release malloc data 
2217			 
2217				if DEBUG_FORTH_STACK_GUARD 
2217 cd 71 6e				call check_stacks 
221a					FORTH_CHK_DSP_UNDER 
221a e5				push hl 
221b d5				push de 
221c 2a f5 f9			ld hl,(cli_data_sp) 
221f 11 2f f7			ld de, cli_data_stack 
2222 cd 6a 0f			call cmp16 
2225 da 7f 6f			jp c, fault_dsp_under 
2228 d1				pop de 
2229 e1				pop hl 
222a				endm 
# End of macro FORTH_CHK_DSP_UNDER
222a				endif 
222a				;ld hl,(cli_data_sp) 
222a			if DEBUG_FORTH_DOT 
222a				DMARK "DPP" 
222a f5				push af  
222b 3a 3f 22			ld a, (.dmark)  
222e 32 6e fe			ld (debug_mark),a  
2231 3a 40 22			ld a, (.dmark+1)  
2234 32 6f fe			ld (debug_mark+1),a  
2237 3a 41 22			ld a, (.dmark+2)  
223a 32 70 fe			ld (debug_mark+2),a  
223d 18 03			jr .pastdmark  
223f ..			.dmark: db "DPP"  
2242 f1			.pastdmark: pop af  
2243			endm  
# End of macro DMARK
2243				CALLMONITOR 
2243 cd f3 18			call break_point_state  
2246				endm  
# End of macro CALLMONITOR
2246			endif	 
2246			 
2246			 
2246			if FORTH_ENABLE_DSPPOPFREE 
2246			 
2246				FORTH_DSP 
2246 cd 24 21			call macro_forth_dsp 
2249				endm 
# End of macro FORTH_DSP
2249			 
2249 7e				ld a, (hl) 
224a fe 01			cp DS_TYPE_STR 
224c 20 23			jr nz, .skippopfree 
224e			 
224e				FORTH_DSP_VALUEHL 
224e cd 5e 21			call macro_dsp_valuehl 
2251				endm 
# End of macro FORTH_DSP_VALUEHL
2251 00				nop 
2252			if DEBUG_FORTH_DOT 
2252				DMARK "DPf" 
2252 f5				push af  
2253 3a 67 22			ld a, (.dmark)  
2256 32 6e fe			ld (debug_mark),a  
2259 3a 68 22			ld a, (.dmark+1)  
225c 32 6f fe			ld (debug_mark+1),a  
225f 3a 69 22			ld a, (.dmark+2)  
2262 32 70 fe			ld (debug_mark+2),a  
2265 18 03			jr .pastdmark  
2267 ..			.dmark: db "DPf"  
226a f1			.pastdmark: pop af  
226b			endm  
# End of macro DMARK
226b				CALLMONITOR 
226b cd f3 18			call break_point_state  
226e				endm  
# End of macro CALLMONITOR
226e			endif	 
226e cd dd 14			call free 
2271			.skippopfree: 
2271				 
2271			 
2271			endif 
2271			 
2271			if DEBUG_FORTH_DOT_KEY 
2271				DMARK "DP2" 
2271				CALLMONITOR 
2271			endif	 
2271			 
2271				; move pointer down 
2271			 
2271 2a f5 f9			ld hl,(cli_data_sp) 
2274 2b				dec hl 
2275 2b				dec hl 
2276			; PARSEV5 
2276 2b				dec hl 
2277 22 f5 f9			ld (cli_data_sp), hl 
227a			 
227a				if DEBUG_FORTH_STACK_GUARD 
227a cd 71 6e				call check_stacks 
227d					FORTH_CHK_DSP_UNDER 
227d e5				push hl 
227e d5				push de 
227f 2a f5 f9			ld hl,(cli_data_sp) 
2282 11 2f f7			ld de, cli_data_stack 
2285 cd 6a 0f			call cmp16 
2288 da 7f 6f			jp c, fault_dsp_under 
228b d1				pop de 
228c e1				pop hl 
228d				endm 
# End of macro FORTH_CHK_DSP_UNDER
228d				endif 
228d			 
228d e1				pop hl 
228e			 
228e c9				ret 
228f			 
228f			getwordathl: 
228f				; hl points to an address 
228f				; load hl with the word at that address 
228f			 
228f d5				push de 
2290			 
2290 5e				ld e, (hl) 
2291 23				inc hl 
2292 56				ld d, (hl) 
2293 eb				ex de, hl 
2294			 
2294 d1				pop de 
2295 c9				ret 
2296			 
2296			 
2296			 
2296			 
2296			 
2296			; eof 
2296			 
# End of file forth_stackopsv5.asm
2296			endif 
2296			 
2296			loadwordinhl:	 
2296			 
2296 d5				push de 
2297			 
2297 5e				ld e, (hl) 
2298 23				inc hl 
2299 56				ld d, (hl) 
229a eb				ex de,hl  
229b			 
229b d1				pop de 
229c			 
229c c9				ret 
229d			 
229d			user_word_eol:  
229d				; hl contains the pointer to where to create a linked list item from the end 
229d				; of the user dict to continue on at the system word dict 
229d				 
229d				; poke the stub of the word list linked list to repoint to rom words 
229d			 
229d				; stub format 
229d				; db   word id 
229d				; dw    link to next word 
229d			        ; db char length of token 
229d				; db string + 0 term 
229d				; db exec code....  
229d			 
229d 3e 00			ld a, WORD_SYS_ROOT     ; root word 
229f 77				ld (hl), a		; word id 
22a0 23				inc hl 
22a1			 
22a1 11 6c 24			ld de, sysdict 
22a4 73				ld (hl), e		; next word link ie system dict 
22a5 23				inc hl 
22a6 72				ld (hl), d		; next word link ie system dict 
22a7 23				inc hl	 
22a8			 
22a8			;	ld (hl), sysdict		; next word link ie system dict 
22a8			;	inc hl 
22a8			;	inc hl 
22a8			 
22a8			;	inc hl 
22a8			;	inc hl 
22a8			 
22a8 3e 02			ld a, 2			; word length is 0 
22aa 77				ld (hl), a	 
22ab 23				inc hl 
22ac			 
22ac 3e 7e			ld a, '~'			; word length is 0 
22ae 77				ld (hl), a	 
22af 23				inc hl 
22b0 3e 00			ld a, 0			; save empty word 
22b2 77				ld (hl), a 
22b3			 
22b3 c9				ret 
22b4			 
22b4				 
22b4			 
22b4			forthexec_cleanup: 
22b4				FORTH_RSP_POP 
22b4 cd 2f 1f			call macro_forth_rsp_pop 
22b7				endm 
# End of macro FORTH_RSP_POP
22b7 c9				ret 
22b8			 
22b8			forth_call_hl: 
22b8				; taking hl 
22b8 e5				push hl 
22b9 c9				ret 
22ba			 
22ba			; this is called to reset Forth system but keep existing uwords etc 
22ba			 
22ba			forth_warmstart: 
22ba				; setup stack over/under flow checks 
22ba				if DEBUG_FORTH_STACK_GUARD 
22ba cd 57 6e				call chk_stk_init 
22bd				endif 
22bd			 
22bd				; init stack pointers  - * these stacks go upwards *  
22bd 21 b3 f9			ld hl, cli_ret_stack 
22c0 22 f9 f9			ld (cli_ret_sp), hl	 
22c3				; set bottom of stack 
22c3 3e 00			ld a,0 
22c5 77				ld (hl),a 
22c6 23				inc hl 
22c7 77				ld (hl),a 
22c8			 
22c8 21 2f f7			ld hl, cli_data_stack 
22cb 22 f5 f9			ld (cli_data_sp), hl	 
22ce				; set bottom of stack 
22ce 3e 00			ld a,0 
22d0 77				ld (hl),a 
22d1 23				inc hl 
22d2 77				ld (hl),a 
22d3			 
22d3 21 31 f9			ld hl, cli_loop_stack 
22d6 22 f7 f9			ld (cli_loop_sp), hl	 
22d9				; set bottom of stack 
22d9 3e 00			ld a,0 
22db 77				ld (hl),a 
22dc 23				inc hl 
22dd 77				ld (hl),a 
22de			 
22de				; init extent of current open file 
22de			 
22de 3e 00			ld a, 0 
22e0 32 71 fa			ld (store_openext), a 
22e3			 
22e3 c9				ret 
22e4			 
22e4			 
22e4			; Cold Start - this is called to setup the whole Forth system 
22e4			 
22e4			forth_init: 
22e4			 
22e4				; setup stack over/under flow checks 
22e4			 
22e4			;	if DEBUG_FORTH_STACK_GUARD 
22e4			;		call chk_stk_init 
22e4			;	endif 
22e4			 
22e4				; enable auto display updates (slow.....) 
22e4			 
22e4 3e 01			ld a, 1 
22e6 32 43 fa			ld (cli_autodisplay), a 
22e9			 
22e9				; if storage is in use disable long reads for now 
22e9 3e 00			ld a, 0 
22eb 32 7c fa			ld (store_longread), a 
22ee			 
22ee			 
22ee				; show start up screen 
22ee			 
22ee cd 18 0d			call clear_display 
22f1			 
22f1 3e 00			ld a,0 
22f3 32 65 fa			ld (f_cursor_ptr), a 
22f6			 
22f6				; set start of word list in start of ram - for use when creating user words 
22f6			 
22f6 21 00 80			ld hl, baseram 
22f9 22 c5 f4			ld (os_last_new_uword), hl 
22fc cd 9d 22			call user_word_eol 
22ff				 
22ff			;		call display_data_sp 
22ff			;		call next_page_prompt 
22ff			 
22ff			 
22ff			 
22ff			 
22ff c9				ret 
2300			 
2300 .. 00		.bootforth: db " Forth Kernel Init ",0 
2314			 
2314			; TODO push to stack 
2314			 
2314			;  
2314			 
2314			if FORTH_PARSEV2 
2314			 
2314			 
2314				include "forth_parserv2.asm" 
2314			 
2314			endif 
2314			 
2314			 
2314			; parse cli version 1 
2314			 
2314			if FORTH_PARSEV1 
2314			 
2314			 
2314			 
2314			      include "forth_parserv1.asm" 
2314			endif 
2314				 
2314			if FORTH_PARSEV3 
2314			 
2314			 
2314			 
2314			      include "forth_parserv3.asm" 
2314				include "forth_wordsv3.asm" 
2314			endif 
2314			 
2314			if FORTH_PARSEV4 
2314			 
2314			 
2314			 
2314			      include "forth_parserv4.asm" 
2314				include "forth_wordsv4.asm" 
2314			endif 
2314			 
2314			if FORTH_PARSEV5 
2314			 
2314			 
2314			 
2314			      include "forth_parserv5.asm" 
2314			 
2314			 
2314			; A better parser without using malloc and string copies all over the place.  
2314			; Exec in situ should be faster 
2314			 
2314			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2314			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2314			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2314			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2314			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2314			WORD_SYS_END: equ 0   ; Opcode for all user words 
2314			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2314			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2314			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2314			 
2314			; Core word preamble macro 
2314			 
2314			CWHEAD:   macro nxtword opcode lit len opflags 
2314				db WORD_SYS_CORE+opcode             
2314				; internal op code number 
2314				dw nxtword            
2314				; link to next dict word block 
2314				db len + 1 
2314				; literal length of dict word inc zero term 
2314				db lit,0              
2314				; literal dict word 
2314			        ; TODO db opflags        
2314				endm 
2314			 
2314			 
2314			NEXTW: macro  
2314				jp macro_next 
2314				endm 
2314			 
2314			macro_next: 
2314			if DEBUG_FORTH_PARSE_KEY 
2314				DMARK "NXT" 
2314				CALLMONITOR 
2314			endif	 
2314			;	inc hl  ; skip token null term  
2314 ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2318 ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
231c 2a c9 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
231f			if DEBUG_FORTH_PARSE_KEY 
231f				DMARK "}AA" 
231f				CALLMONITOR 
231f			endif	 
231f c3 22 24			jp execnext 
2322				;jp exec1 
2322			       
2322			 
2322			 
2322			; Another go at the parser to compile  
2322			 
2322			 
2322			; TODO rework parser to change all of the string words to byte tokens 
2322			; TODO do a search for  
2322			 
2322			; TODO first run normal parser to zero term sections 
2322			; TODO for each word do a token look up to get the op code 
2322			; TODO need some means to flag to the exec that this is a byte code form    
2322			 
2322			 
2322			forthcompile: 
2322			 
2322			; 
2322			; line parse: 
2322			;       parse raw input buffer 
2322			;       tokenise the words 
2322			;       malloc new copy (for looping etc) 
2322			;       copy to malloc + current pc in line to start of string and add line term 
2322			;       save on new rsp 
2322			; 
2322			 
2322			; hl to point to the line to tokenise 
2322			 
2322			;	push hl 
2322 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2325			 
2325			;	ld a,0		; string term on input 
2325			;	call strlent 
2325			 
2325			;	ld (os_tok_len), hl	 ; save string length 
2325			 
2325			;if DEBUG_FORTH_TOK 
2325			;	ex de,hl		 
2325			;endif 
2325			 
2325			;	pop hl 		; get back string pointer 
2325			 
2325			if DEBUG_FORTH_TOK 
2325						DMARK "TOc" 
2325				CALLMONITOR 
2325			endif 
2325 7e			.cptoken2:    ld a,(hl) 
2326 23				inc hl 
2327 fe 7f			cp FORTH_END_BUFFER 
2329 28 29			jr z, .cptokendone2 
232b fe 00			cp 0 
232d 28 25			jr z, .cptokendone2 
232f fe 22			cp '"' 
2331 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2333 fe 20			cp ' ' 
2335 20 ee			jr nz,  .cptoken2 
2337			 
2337			; TODO consume comments held between ( and ) 
2337			 
2337				; we have a space so change to zero term for dict match later 
2337 2b				dec hl 
2338 3e 00			ld a,0 
233a 77				ld (hl), a 
233b 23				inc hl 
233c 18 e7			jr .cptoken2 
233e				 
233e			 
233e			.cptokenstr2: 
233e				; skip all white space until either eol (because forgot to term) or end double quote 
233e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
233e				;inc hl ; skip current double quote 
233e 7e				ld a,(hl) 
233f 23				inc hl 
2340 fe 22			cp '"' 
2342 28 e1			jr z, .cptoken2 
2344 fe 7f			cp FORTH_END_BUFFER 
2346 28 0c			jr z, .cptokendone2 
2348 fe 00			cp 0 
234a 28 08			jr z, .cptokendone2 
234c fe 20			cp ' ' 
234e 28 02			jr z, .cptmp2 
2350 18 ec			jr .cptokenstr2 
2352			 
2352			.cptmp2:	; we have a space so change to zero term for dict match later 
2352				;dec hl 
2352				;ld a,"-"	; TODO remove this when working 
2352				;ld (hl), a 
2352				;inc hl 
2352 18 ea			jr .cptokenstr2 
2354			 
2354			.cptokendone2: 
2354				;inc hl 
2354 3e 7f			ld a, FORTH_END_BUFFER 
2356 77				ld (hl),a 
2357 23				inc hl 
2358 3e 21			ld a, '!' 
235a 77				ld (hl),a 
235b			 
235b 2a c9 f4			ld hl,(os_tok_ptr) 
235e			         
235e			if DEBUG_FORTH_TOK 
235e						DMARK "Tc1" 
235e				CALLMONITOR 
235e			endif 
235e			 
235e				; push exec string to top of return stack 
235e				FORTH_RSP_NEXT 
235e cd 0e 1f			call macro_forth_rsp_next 
2361				endm 
# End of macro FORTH_RSP_NEXT
2361 c9				ret 
2362			 
2362			; Another go at the parser need to simplify the process 
2362			 
2362			forthparse: 
2362			 
2362			; 
2362			; line parse: 
2362			;       parse raw input buffer 
2362			;       tokenise the words 
2362			;       malloc new copy (for looping etc) 
2362			;       copy to malloc + current pc in line to start of string and add line term 
2362			;       save on new rsp 
2362			; 
2362			 
2362			; hl to point to the line to tokenise 
2362			 
2362			;	push hl 
2362 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2365			 
2365			;	ld a,0		; string term on input 
2365			;	call strlent 
2365			 
2365			;	ld (os_tok_len), hl	 ; save string length 
2365			 
2365			;if DEBUG_FORTH_TOK 
2365			;	ex de,hl		 
2365			;endif 
2365			 
2365			;	pop hl 		; get back string pointer 
2365			 
2365			if DEBUG_FORTH_TOK 
2365						DMARK "TOK" 
2365				CALLMONITOR 
2365			endif 
2365 7e			.ptoken2:    ld a,(hl) 
2366 23				inc hl 
2367 fe 7f			cp FORTH_END_BUFFER 
2369 28 29			jr z, .ptokendone2 
236b fe 00			cp 0 
236d 28 25			jr z, .ptokendone2 
236f fe 22			cp '"' 
2371 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2373 fe 20			cp ' ' 
2375 20 ee			jr nz,  .ptoken2 
2377			 
2377			; TODO consume comments held between ( and ) 
2377			 
2377				; we have a space so change to zero term for dict match later 
2377 2b				dec hl 
2378 3e 00			ld a,0 
237a 77				ld (hl), a 
237b 23				inc hl 
237c 18 e7			jr .ptoken2 
237e				 
237e			 
237e			.ptokenstr2: 
237e				; skip all white space until either eol (because forgot to term) or end double quote 
237e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
237e				;inc hl ; skip current double quote 
237e 7e				ld a,(hl) 
237f 23				inc hl 
2380 fe 22			cp '"' 
2382 28 e1			jr z, .ptoken2 
2384 fe 7f			cp FORTH_END_BUFFER 
2386 28 0c			jr z, .ptokendone2 
2388 fe 00			cp 0 
238a 28 08			jr z, .ptokendone2 
238c fe 20			cp ' ' 
238e 28 02			jr z, .ptmp2 
2390 18 ec			jr .ptokenstr2 
2392			 
2392			.ptmp2:	; we have a space so change to zero term for dict match later 
2392				;dec hl 
2392				;ld a,"-"	; TODO remove this when working 
2392				;ld (hl), a 
2392				;inc hl 
2392 18 ea			jr .ptokenstr2 
2394			 
2394			.ptokendone2: 
2394				;inc hl 
2394 3e 7f			ld a, FORTH_END_BUFFER 
2396 77				ld (hl),a 
2397 23				inc hl 
2398 3e 21			ld a, '!' 
239a 77				ld (hl),a 
239b			 
239b 2a c9 f4			ld hl,(os_tok_ptr) 
239e			         
239e			if DEBUG_FORTH_TOK 
239e						DMARK "TK1" 
239e				CALLMONITOR 
239e			endif 
239e			 
239e				; push exec string to top of return stack 
239e				FORTH_RSP_NEXT 
239e cd 0e 1f			call macro_forth_rsp_next 
23a1				endm 
# End of macro FORTH_RSP_NEXT
23a1 c9				ret 
23a2			 
23a2			; 
23a2			;	; malloc size + buffer pointer + if is loop flag 
23a2			;	ld hl,(os_tok_len) 		 ; get string length 
23a2			; 
23a2			;	ld a,l 
23a2			; 
23a2			;	cp 0			; we dont want to use a null string 
23a2			;	ret z 
23a2			; 
23a2			;;	add 3    ; prefix malloc with buffer for current word ptr 
23a2			; 
23a2			;	add 5     ; TODO when certain not over writing memory remove 
23a2			; 
23a2			;		 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKE" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	ld l,a 
23a2			;	ld h,0 
23a2			;;	push hl   ; save required space for the copy later 
23a2			;	call malloc 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKM" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			;	if DEBUG_FORTH_MALLOC_GUARD 
23a2			;		push af 
23a2			;		call ishlzero 
23a2			;;		ld a, l 
23a2			;;		add h 
23a2			;;		cp 0 
23a2			;		pop af 
23a2			;		 
23a2			;		call z,malloc_error 
23a2			;	endif 
23a2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
23a2			; 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKR" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	FORTH_RSP_NEXT 
23a2			; 
23a2			;	;inc hl	 ; go past current buffer pointer 
23a2			;	;inc hl 
23a2			;	;inc hl   ; and past if loop flag 
23a2			;		; TODO Need to set flag  
23a2			; 
23a2			;	 
23a2			;	 
23a2			;	ex de,hl	; malloc is dest 
23a2			;	ld hl, (os_tok_len) 
23a2			;;	pop bc 
23a2			;	ld c, l                
23a2			;	ld b,0 
23a2			;	ld hl, (os_tok_ptr) 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKT" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	; do str cpy 
23a2			; 
23a2			;	ldir      ; copy byte in hl to de 
23a2			; 
23a2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			; 
23a2			;			DMARK "TKY" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			;	;ld a,0 
23a2			;	;ld a,FORTH_END_BUFFER 
23a2			;	ex de, hl 
23a2			;	;dec hl			 ; go back over the space delim at the end of word 
23a2			;	;ld (hl),a 
23a2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
23a2			;	ld a,FORTH_END_BUFFER 
23a2			;	ld (hl),a 
23a2			;	inc hl 
23a2			;	ld a,FORTH_END_BUFFER 
23a2			;	ld (hl),a 
23a2			; 
23a2			;	; init the malloc area data 
23a2			;	; set pc for in current area 
23a2			;	;ld hl, (os_tok_malloc) 
23a2			;	;inc hl 
23a2			;	;inc hl 
23a2			;	;inc hl 
23a2			;	;ex de,hl 
23a2			;	;ld hl, (os_tok_malloc) 
23a2			;	;ld (hl),e 
23a2			;	;inc hl 
23a2			;	;ld (hl),d 
23a2			; 
23a2			; 
23a2			;	ld hl,(os_tok_malloc) 
23a2			;if DEBUG_FORTH_PARSE_KEY 
23a2			;			DMARK "TKU" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	ret 
23a2			 
23a2			forthexec: 
23a2			 
23a2			; line exec: 
23a2			; forth parser 
23a2			 
23a2			; 
23a2			;       get current exec line on rsp 
23a2			 
23a2				FORTH_RSP_TOS 
23a2 cd 25 1f			call macro_forth_rsp_tos 
23a5				endm 
# End of macro FORTH_RSP_TOS
23a5			 
23a5			;       restore current pc - hl points to malloc of data 
23a5			 
23a5				;ld e, (hl) 
23a5				;inc hl 
23a5				;ld d, (hl) 
23a5				;ex de,hl 
23a5			 
23a5			 
23a5			exec1: 
23a5 22 c9 f4			ld (os_tok_ptr), hl 
23a8			 
23a8				; copy our PC to working vars  
23a8 22 47 fa			ld (cli_ptr), hl 
23ab 22 45 fa			ld (cli_origptr), hl 
23ae			 
23ae 7e				ld a,(hl) 
23af fe 7f			cp FORTH_END_BUFFER 
23b1 c8				ret z 
23b2			 
23b2				; skip any nulls 
23b2			 
23b2 fe 00			cp 0 
23b4 20 03			jr nz, .execword 
23b6 23				inc hl 
23b7 18 ec			jr exec1 
23b9			 
23b9			 
23b9			.execword: 
23b9			 
23b9			 
23b9			 
23b9			if DEBUG_FORTH_PARSE_KEY 
23b9						DMARK "KYQ" 
23b9				CALLMONITOR 
23b9			endif 
23b9			;       while at start of word: 
23b9			; get start of dict (in user area first) 
23b9			 
23b9 21 00 80		ld hl, baseram 
23bc			;ld hl, sysdict 
23bc 22 49 fa		ld (cli_nextword),hl 
23bf			;           match word at pc 
23bf			;           exec word 
23bf			;           or push to dsp 
23bf			;           forward to next token 
23bf			;           if line term pop rsp and exit 
23bf			;        
23bf			 
23bf			if DEBUG_FORTH_PARSE_KEY 
23bf						DMARK "KYq" 
23bf				CALLMONITOR 
23bf			endif 
23bf			 
23bf			; 
23bf			; word comp 
23bf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
23bf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
23bf			;    move to start of word  
23bf			;    compare word to cli_token 
23bf			 
23bf			.execpnword:	; HL at start of a word in the dictionary to check 
23bf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
23bf			;	ld (cli_ptr), hl 
23bf			 
23bf 2a 49 fa			ld hl,(cli_nextword) 
23c2			 
23c2 cd 65 24			call forth_tok_next 
23c5			; tok next start here 
23c5			;	; TODO skip compiled symbol for now 
23c5			;	inc hl 
23c5			; 
23c5			;	; save pointer to next word 
23c5			; 
23c5			;	; hl now points to the address of the next word pointer  
23c5			;	ld e, (hl) 
23c5			;	inc hl 
23c5			;	ld d, (hl) 
23c5			;	inc l 
23c5			; 
23c5			;	ex de,hl 
23c5			;if DEBUG_FORTH_PARSE_NEXTWORD 
23c5			;	push bc 
23c5			;	ld bc, (cli_nextword) 
23c5			;			DMARK "NXW" 
23c5			;	CALLMONITOR 
23c5			;	pop bc 
23c5			;endif 
23c5			; tok next end here 
23c5 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
23c8 eb				ex de, hl 
23c9			 
23c9			 
23c9				; save the pointer of the current token - 1 to check against 
23c9				 
23c9 22 4d fa			ld (cli_token), hl   
23cc				; TODO maybe remove below save if no debug 
23cc				; save token string ptr for any debug later 
23cc 23				inc hl  
23cd 22 4f fa			ld (cli_origtoken), hl 
23d0 2b				dec hl 
23d1				; save pointer to the start of the next dictionay word 
23d1 7e				ld a,(hl)   ; get string length 
23d2 47				ld b,a 
23d3			.execpnwordinc:  
23d3 23				inc hl 
23d4 10 fd			djnz .execpnwordinc 
23d6 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
23d9			 
23d9				; now check the word token against the string being parsed 
23d9			 
23d9 2a 4d fa			ld hl,(cli_token) 
23dc 23				inc hl     ; skip string length (use zero term instead to end) 
23dd 22 4d fa			ld (cli_token), hl 
23e0			 
23e0			if DEBUG_FORTH_PARSE_KEY 
23e0						DMARK "KY2" 
23e0			endif 
23e0			if DEBUG_FORTH_PARSE_EXEC 
23e0				; see if disabled 
23e0			 
23e0				ld a, (os_view_disable) 
23e0				cp '*' 
23e0				jr z, .skip 
23e0			 
23e0				push hl 
23e0				push hl 
23e0				call clear_display 
23e0				ld de, .compword 
23e0				ld a, display_row_1 
23e0				call str_at_display 
23e0				pop de 
23e0				ld a, display_row_2 
23e0				call str_at_display 
23e0				ld hl,(cli_ptr) 
23e0				ld a,(hl) 
23e0			        ld hl, os_word_scratch 
23e0				ld (hl),a 
23e0				ld a,0 
23e0				inc hl 
23e0				ld (hl),a 	 
23e0				ld de, os_word_scratch 
23e0				ld a, display_row_2+10 
23e0				call str_at_display 
23e0				call update_display 
23e0				ld a, 100 
23e0				call aDelayInMS 
23e0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23e0				call delay250ms 
23e0				endif 
23e0				pop hl 
23e0			.skip:  
23e0			endif	 
23e0			.execpnchar:    ; compare char between token and string to parse 
23e0			 
23e0			if DEBUG_FORTH_PARSE_KEY 
23e0						DMARK "Ky3" 
23e0			endif 
23e0			if DEBUG_FORTH_PARSE_EXEC 
23e0				; see if disabled 
23e0			 
23e0				ld a, (os_view_disable) 
23e0				cp '*' 
23e0				jr z, .skip2 
23e0			 
23e0			;	call clear_display 
23e0			ld hl,(cli_token) 
23e0			ld a,(hl) 
23e0			ld (os_word_scratch),a 
23e0				ld hl,(cli_ptr) 
23e0			ld a,(hl) 
23e0				ld (os_word_scratch+1),a 
23e0				ld a,0 
23e0				ld (os_word_scratch+2),a 
23e0				ld de,os_word_scratch 
23e0				ld a,display_row_4 
23e0				call str_at_display 
23e0				call update_display 
23e0			.skip2:  
23e0			endif 
23e0 2a 4d fa			ld hl,(cli_token) 
23e3 7e				ld a, (hl)	 ; char in word token 
23e4 23				inc hl 		; move to next char 
23e5 22 4d fa			ld (cli_token), hl ; and save it 
23e8 47				ld b,a 
23e9			 
23e9 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
23ec 7e				ld a,(hl) 
23ed 23				inc hl 
23ee 22 47 fa			ld (cli_ptr), hl		; move to next char 
23f1 cd a1 13			call toUpper 		; make sure the input string matches case 
23f4			 
23f4			if DEBUG_FORTH_PARSE 
23f4			endif 
23f4			 
23f4				; input stream end of token is a space so get rid of it 
23f4			 
23f4			;	cp ' ' 
23f4			;	jr nz, .pnskipspace 
23f4			; 
23f4			;	ld a, 0		; make same term as word token term 
23f4			; 
23f4			;.pnskipspace: 
23f4			 
23f4			if DEBUG_FORTH_PARSE_KEY 
23f4						DMARK "KY7" 
23f4			endif 
23f4 b8				cp b 
23f5 c2 0b 24			jp nz, .execpnskipword	 ; no match so move to next word 
23f8				 
23f8			;    if same 
23f8			;       scan for string terms 0 for token and 32 for input 
23f8			 
23f8				 
23f8			if DEBUG_FORTH_PARSE_KEY 
23f8						DMARK "KY8" 
23f8			endif 
23f8			 
23f8 80				add b			 
23f9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23fb							; TODO need to make sure last word in zero term string is accounted for 
23fb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23fd			 
23fd			 
23fd				; at end of both strings so both are exact match 
23fd			 
23fd			;       skip ptr for next word 
23fd			 
23fd 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
2400 23				inc hl			 ; at next char 
2401 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2404 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2407				 
2407				 
2407			if DEBUG_FORTH_PARSE_KEY 
2407						DMARK "KY3" 
2407			endif 
2407			 
2407			 
2407			 
2407			;       exec code block 
2407			if DEBUG_FORTH_JP 
2407				call clear_display 
2407				call update_display 
2407				call delay1s 
2407				ld hl, (cli_execword)     ; save for next check if no match on this word 
2407				ld a,h 
2407				ld hl, os_word_scratch 
2407				call hexout 
2407				ld hl, (cli_execword)     ; save for next check if no match on this word 
2407				ld a,l 
2407				ld hl, os_word_scratch+2 
2407				call hexout 
2407				ld hl, os_word_scratch+4 
2407				ld a,0 
2407				ld (hl),a 
2407				ld de,os_word_scratch 
2407				call str_at_display 
2407					ld a, display_row_2 
2407					call str_at_display 
2407				ld de, (cli_origtoken) 
2407				ld a, display_row_1+10 
2407					call str_at_display 
2407			 
2407				ld a,display_row_1 
2407				ld de, .foundword 
2407				ld a, display_row_3 
2407				call str_at_display 
2407				call update_display 
2407				call delay1s 
2407				call delay1s 
2407				call delay1s 
2407			endif 
2407			 
2407			if DEBUG_FORTH_PARSE_KEY 
2407						DMARK "KYj" 
2407			endif 
2407				; TODO save the word pointer in this exec 
2407			 
2407 2a 4b fa			ld hl,(cli_execword) 
240a e9				jp (hl) 
240b			 
240b			 
240b			;    if not same 
240b			;	scan for zero term 
240b			;	get ptr for next word 
240b			;	goto word comp 
240b			 
240b			.execpnskipword:	; get pointer to next word 
240b 2a 49 fa			ld hl,(cli_nextword) 
240e			 
240e 7e				ld a,(hl) 
240f fe 00			cp WORD_SYS_END 
2411			;	cp 0 
2411 28 09			jr z, .execendofdict			 ; at end of words 
2413			 
2413			if DEBUG_FORTH_PARSE_KEY 
2413						DMARK "KY4" 
2413			endif 
2413			if DEBUG_FORTH_PARSE_EXEC 
2413			 
2413				; see if disabled 
2413			 
2413				ld a, (os_view_disable) 
2413				cp '*' 
2413				jr z, .noskip 
2413			 
2413			 
2413				ld de, .nowordfound 
2413				ld a, display_row_3 
2413				call str_at_display 
2413				call update_display 
2413				ld a, 100 
2413				call aDelayInMS 
2413				 
2413				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2413					call delay250ms 
2413				endif 
2413			.noskip:  
2413			 
2413			endif	 
2413			 
2413 2a 45 fa			ld hl,(cli_origptr) 
2416 22 47 fa			ld (cli_ptr),hl 
2419			 
2419			if DEBUG_FORTH_PARSE_KEY 
2419						DMARK "KY5" 
2419			endif 
2419 c3 bf 23			jp .execpnword			; else go to next word 
241c			 
241c			.execendofdict:  
241c			 
241c			if DEBUG_FORTH_PARSE_KEY 
241c						DMARK "KYe" 
241c			endif 
241c			if DEBUG_FORTH_PARSE_EXEC 
241c				; see if disabled 
241c			 
241c				ld a, (os_view_disable) 
241c				cp '*' 
241c				jr z, .ispskip 
241c			 
241c				call clear_display 
241c				call update_display 
241c				call delay1s 
241c				ld de, (cli_origptr) 
241c				ld a, display_row_1 
241c				call str_at_display 
241c				 
241c				ld de, .enddict 
241c				ld a, display_row_3 
241c				call str_at_display 
241c				call update_display 
241c				ld a, 100 
241c				call aDelayInMS 
241c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
241c				call delay1s 
241c				call delay1s 
241c				call delay1s 
241c				endif 
241c			.ispskip:  
241c				 
241c			endif	 
241c			 
241c			 
241c			 
241c				; if the word is not a keyword then must be a literal so push it to stack 
241c			 
241c			; push token to stack to end of word 
241c			 
241c				STACKFRAME ON $1efe $2f9f 
241c				if DEBUG_STACK_IMB 
241c					if ON 
241c						exx 
241c						ld de, $1efe 
241c						ld a, d 
241c						ld hl, curframe 
241c						call hexout 
241c						ld a, e 
241c						ld hl, curframe+2 
241c						call hexout 
241c						ld hl, $1efe 
241c						push hl 
241c						ld hl, $2f9f 
241c						push hl 
241c						exx 
241c					endif 
241c				endif 
241c			endm 
# End of macro STACKFRAME
241c			 
241c 2a c9 f4		ld hl,(os_tok_ptr) 
241f cd d0 20		call forth_apush 
2422			 
2422				STACKFRAMECHK ON $1efe $2f9f 
2422				if DEBUG_STACK_IMB 
2422					if ON 
2422						exx 
2422						ld hl, $2f9f 
2422						pop de   ; $2f9f 
2422						call cmp16 
2422						jr nz, .spnosame 
2422						ld hl, $1efe 
2422						pop de   ; $1efe 
2422						call cmp16 
2422						jr z, .spfrsame 
2422						.spnosame: call showsperror 
2422						.spfrsame: nop 
2422						exx 
2422					endif 
2422				endif 
2422			endm 
# End of macro STACKFRAMECHK
2422			 
2422			execnext: 
2422			 
2422			if DEBUG_FORTH_PARSE_KEY 
2422						DMARK "KY>" 
2422			endif 
2422			; move past token to next word 
2422			 
2422 2a c9 f4		ld hl, (os_tok_ptr) 
2425 3e 00		ld a, 0 
2427 01 ff 00		ld bc, 255     ; input buffer size 
242a ed b1		cpir 
242c			 
242c			if DEBUG_FORTH_PARSE_KEY 
242c						DMARK "KY!" 
242c				CALLMONITOR 
242c			endif	 
242c			; TODO this might place hl on the null, so will need to forward on??? 
242c			;inc hl   ; see if this gets onto the next item 
242c			 
242c			 
242c			; TODO pass a pointer to the buffer to push 
242c			; TODO call function to push 
242c			 
242c			; look for end of input 
242c			 
242c			;inc hl 
242c			;ld a,(hl) 
242c			;cp FORTH_END_BUFFER 
242c			;ret z 
242c			 
242c			 
242c c3 a5 23		jp exec1 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			findnexttok: 
242f			 
242f				; hl is pointer to move 
242f				; de is the token to locate 
242f			 
242f					if DEBUG_FORTH 
242f						DMARK "NTK" 
242f						CALLMONITOR 
242f					endif 
242f d5				push de 
2430			 
2430			.fnt1:	 
2430				; find first char of token to locate 
2430			 
2430 1a				ld a, (de) 
2431 4f				ld c,a 
2432 7e				ld a,(hl) 
2433 cd a1 13			call toUpper 
2436					if DEBUG_FORTH 
2436						DMARK "NT1" 
2436						CALLMONITOR 
2436					endif 
2436 b9				cp c 
2437			 
2437 28 03			jr z, .fnt2cmpmorefirst	 
2439			 
2439				; first char not found move to next char 
2439			 
2439 23				inc hl 
243a 18 f4			jr .fnt1 
243c			 
243c			.fnt2cmpmorefirst:	 
243c				; first char of token found.  
243c			 
243c e5				push hl     ; save start of token just in case it is the right one 
243d d9				exx 
243e e1				pop hl        ; save it to hl' 
243f d9				exx 
2440			 
2440			 
2440			.fnt2cmpmore:	 
2440				; compare the rest 
2440				 
2440 23				inc hl 
2441 13				inc de 
2442				 
2442 1a				ld a, (de) 
2443 4f				ld c,a 
2444 7e				ld a,(hl) 
2445 cd a1 13			call toUpper 
2448			 
2448					if DEBUG_FORTH 
2448						DMARK "NT2" 
2448						CALLMONITOR 
2448					endif 
2448				; c has the token to find char 
2448				; a has the mem to scan char 
2448			 
2448 b9				cp c 
2449 28 04			jr z,.fntmatch1 
244b			 
244b				; they are not the same 
244b			 
244b					if DEBUG_FORTH 
244b						DMARK "NT3" 
244b						CALLMONITOR 
244b					endif 
244b d1				pop de	; reset de token to look for 
244c d5				push de 
244d 18 e1			jr .fnt1 
244f				 
244f			.fntmatch1: 
244f			 
244f				; is the same char a null which means we might have a full hit? 
244f					if DEBUG_FORTH 
244f						DMARK "NT4" 
244f						CALLMONITOR 
244f					endif 
244f			 
244f fe 00			cp 0 
2451 28 0b			jr z, .fntmatchyes 
2453			 
2453				; are we at the end of the token to find? 
2453			 
2453					if DEBUG_FORTH 
2453						DMARK "NT5" 
2453						CALLMONITOR 
2453					endif 
2453 3e 00			ld a, 0 
2455 b9				cp c 
2456			 
2456 c2 40 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2459			 
2459					if DEBUG_FORTH 
2459						DMARK "NT6" 
2459						CALLMONITOR 
2459					endif 
2459				; token to find is exhusted but no match to stream 
2459			 
2459				; restore tok pointer and continue on 
2459 d1				pop de 
245a d5				push de 
245b c3 30 24			jp .fnt1 
245e			 
245e			 
245e			.fntmatchyes: 
245e			 
245e				; hl now contains the end of the found token 
245e			 
245e				; get rid of saved token pointer to find 
245e			 
245e d1				pop de 
245f			 
245f					if DEBUG_FORTH 
245f						DMARK "NT9" 
245f						CALLMONITOR 
245f					endif 
245f			 
245f				; hl will be on the null term so forward on 
245f			 
245f				; get back the saved start of the token 
245f			 
245f d9				exx 
2460 e5				push hl     ; save start of token just in case it is the right one 
2461 d9				exx 
2462 e1				pop hl        ; save it to hl 
2463			 
2463 c9				ret 
2464			 
2464			 
2464			; LIST needs to find a specific token   
2464			; FORGET needs to find a spefici token 
2464			 
2464			; SAVE needs to find all tokens by flag 
2464			; WORDS just needs to scan through all  by flag 
2464			; UWORDS needs to scan through all by flag 
2464			 
2464			 
2464			; given hl as pointer to start of dict look up string 
2464			; return hl as pointer to start of word block 
2464			; or 0 if not found 
2464			 
2464			forth_find_tok: 
2464 c9				ret 
2465			 
2465			; given hl as pointer to dict structure 
2465			; move to the next dict block structure 
2465			 
2465			forth_tok_next: 
2465				; hl now points to the address of the next word pointer  
2465				; TODO skip compiled symbol for now 
2465			;	push de 
2465 23				inc hl 
2466 5e				ld e, (hl) 
2467 23				inc hl 
2468 56				ld d, (hl) 
2469 23				inc hl 
246a			 
246a eb				ex de,hl 
246b			if DEBUG_FORTH_PARSE_NEXTWORD 
246b				push bc 
246b				ld bc, (cli_nextword) 
246b						DMARK "NXW" 
246b				CALLMONITOR 
246b				pop bc 
246b			endif 
246b			;	pop de	 
246b c9				ret 
246c			 
246c			 
246c			 
246c			; eof 
# End of file forth_parserv5.asm
246c				include "forth_wordsv4.asm" 
246c			 
246c			; the core word dictionary v4 
246c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
246c			 
246c			; this is a linked list for each of the system words used 
246c			; user defined words will follow the same format but will be in ram 
246c			 
246c			 
246c			; 
246c			; 
246c			; define linked list: 
246c			; 
246c			; 1. compiled byte op code 
246c			; 2. len of text word 
246c			; 3. text word 
246c			; 4. ptr to next dictionary word 
246c			; 5. asm, calls etc for the word 
246c			; 
246c			;  if 1 == 0 then last word in dict  
246c			;   
246c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
246c			;  
246c			;  
246c			; create basic standard set of words 
246c			; 
246c			;  
246c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
246c			; 2DUP 2DROP 2SWAP  
246c			; @ C@ - get byte  
246c			; ! C! - store byte 
246c			; 0< true if less than zero 
246c			; 0= true if zero 
246c			; < >  
246c			; = true if same 
246c			; variables 
246c			 
246c			 
246c			; Hardware specific words I may need 
246c			; 
246c			; IN OUT  
246c			; calls to key util functions 
246c			; calls to hardward abstraction stuff 
246c			; easy control of frame buffers and lcd i/o 
246c			; keyboard  
246c			 
246c			 
246c			;DICT: macro 
246c			; op_code, len, word, next 
246c			;    word: 
246c			;    db op_code 
246c			;    ds word zero term 
246c			;    dw next 
246c			;    endm 
246c			 
246c			 
246c			 
246c			 
246c			; op code 1 is a flag for user define words which are to be handled differently 
246c			 
246c			 
246c			; 
246c			; 
246c			;    TODO on entry to a word this should be the expected environment 
246c			;    hl - tos value if number then held, if string this is the ptr 
246c			;    de -  
246c			 
246c			 
246c			; opcode ranges 
246c			; 0 - end of word dict 
246c			; 255 - user define words 
246c			 
246c			sysdict: 
246c			include "forth_opcodes.asm" 
246c			; op codes for forth keywords 
246c			; free to use code 0  
246c				OPCODE_HEAP: equ  1 
246c				OPCODE_EXEC: equ 2 
246c				OPCODE_DUP: equ 3 
246c				OPCODE_SWAP: equ 4 
246c				OPCODE_COLN: equ 5 
246c				OPCODE_SCOLN: equ 6 
246c				OPCODE_DROP: equ 7 
246c				OPCODE_DUP2: equ 8 
246c				OPCODE_DROP2: equ 9 
246c				OPCODE_SWAP2: equ 10 
246c				OPCODE_AT: equ 11 
246c				OPCODE_CAT: equ 12 
246c				OPCODE_BANG: equ 13 
246c				OPCODE_CBANG: equ 14 
246c				OPCODE_SCALL: equ 15 
246c				OPCODE_DEPTH: equ 16 
246c				OPCODE_OVER: equ 17 
246c				OPCODE_PAUSE: equ 18 
246c				OPCODE_PAUSES: equ 19 
246c				OPCODE_ROT: equ 20 
246c			;free to reuse	OPCODE_WORDS: equ 21 
246c			        OPCODE_NOT: equ 21 
246c				OPCODE_UWORDS: equ 22 
246c				OPCODE_BP: equ 23 
246c				OPCODE_MONITOR: equ 24  
246c				OPCODE_MALLOC: equ 25 
246c				OPCODE_FREE: equ 26 
246c				OPCODE_LIST: equ 27 
246c				OPCODE_FORGET: equ 28 
246c				OPCODE_NOP: equ 29 
246c				OPCODE_COMO: equ 30 
246c				OPCODE_COMC: equ 31 
246c			;free to reuse	OPCODE_ENDCORE: equ 32 
246c				OPCODE_AFTERSOUND: equ 33 
246c				OPCODE_GP2: equ 34 
246c				OPCODE_GP3: equ 35 
246c				OPCODE_GP4: equ 36 
246c				OPCODE_SIN: equ 37 
246c				OPCODE_SOUT: equ 38 
246c				OPCODE_SPIO: equ 39 
246c				OPCODE_SPICEH: equ 40 
246c				OPCODE_SPIOb: equ 41 
246c				OPCODE_SPII: equ 42 
246c				OPCODE_SESEL: equ 43 
246c				OPCODE_CARTDEV: equ 44 
246c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
246c				OPCODE_FB: equ 46 
246c				OPCODE_EMIT: equ 47 
246c				OPCODE_DOTH: equ 48 
246c				OPCODE_DOTF: equ 49 
246c				OPCODE_DOT: equ 50 
246c				OPCODE_CLS: equ 51 
246c				OPCODE_DRAW: equ 52 
246c				OPCODE_DUMP: equ 53 
246c				OPCODE_CDUMP: equ 54 
246c				OPCODE_DAT: equ 55 
246c				OPCODE_HOME: equ 56 
246c				OPCODE_SPACE: equ 57 
246c				OPCODE_SPACES: equ 58 
246c				OPCODE_SCROLL: equ 59 
246c				OPCODE_ATQ: equ 60 
246c				OPCODE_AUTODSP: equ 61 
246c				OPCODE_MENU: equ 62 
246c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
246c				OPCODE_THEN: equ 64 
246c				OPCODE_ELSE: equ 65 
246c				OPCODE_DO: equ 66 
246c				OPCODE_LOOP: equ 67 
246c				OPCODE_I: equ 68 
246c				OPCODE_DLOOP: equ 69  
246c				OPCODE_REPEAT: equ 70  
246c				OPCODE_UNTIL: equ 71 
246c				OPCODE_ENDFLOW: equ 72 
246c				OPCODE_WAITK: equ 73 
246c				OPCODE_ACCEPT: equ 74 
246c				OPCODE_EDIT: equ 75 
246c			;free to reuse	OPCODE_ENDKEY: equ 76 
246c				OPCODE_LZERO: equ 77 
246c				OPCODE_TZERO: equ 78 
246c				OPCODE_LESS: equ 79 
246c				OPCODE_GT: equ 80 
246c				OPCODE_EQUAL: equ 81  
246c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
246c				OPCODE_NEG: equ 83 
246c				OPCODE_DIV: equ 84 
246c				OPCODE_MUL: equ 85 
246c				OPCODE_MIN: equ 86 
246c				OPCODE_MAX: equ 87 
246c				OPCODE_RND16: equ 88 
246c				OPCODE_RND8: equ 89 
246c				OPCODE_RND: equ 90 
246c			;free to reuse	OPCODE_ENDMATHS: equ 91  
246c				OPCODE_BYNAME: equ 92 
246c				OPCODE_DIR: equ 93 
246c				OPCODE_SAVE: equ 94 
246c				OPCODE_LOAD: equ 95 
246c				OPCODE_BSAVE: equ 96 
246c				OPCODE_BLOAD: equ 97 
246c				OPCODE_SEO: equ 98  
246c				OPCODE_SEI: equ 99 
246c				OPCODE_SFREE: equ 100 
246c				OPCODE_SIZE: equ 101 
246c				OPCODE_CREATE: equ 102 
246c				OPCODE_APPEND: equ 103 
246c				OPCODE_SDEL: equ 104 
246c				OPCODE_OPEN: equ 105 
246c				OPCODE_READ: equ 106 
246c				OPCODE_EOF: equ 106 
246c				OPCODE_FORMAT: equ 107 
246c				OPCODE_LABEL: equ 108 
246c				OPCODE_LABELS: equ 109 
246c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
246c				OPCODE_UPPER: equ 111 
246c				OPCODE_LOWER: equ 112 
246c				OPCODE_SUBSTR: equ 113 
246c				OPCODE_LEFT: equ 114 
246c				OPCODE_RIGHT: equ 115 
246c				OPCODE_STR2NUM: equ 116 
246c				OPCODE_NUM2STR: equ 117 
246c				OPCODE_CONCAT: equ 118 
246c				OPCODE_FIND: equ 119 
246c				OPCODE_LEN: equ 120 
246c				OPCODE_CHAR: equ 121 
246c			; free to reuse	OPCODE_STRLEN: equ 122 
246c			; free to reuse	OPCODE_ENDSTR: equ 123 
246c				OPCODE_V0S: equ 124 
246c				OPCODE_V0Q: equ 125 
246c				OPCODE_V1S: equ 126 
246c				OPCODE_V1Q: equ 127 
246c				OPCODE_V2S: equ 128 
246c				OPCODE_V2Q: equ 129 
246c				OPCODE_V3S: equ 130 
246c				OPCODE_V3Q: equ 131 
246c			;free to reuse	OPCODE_END: equ 132 
246c				OPCODE_ZDUP: equ 133 
246c			 
246c			; eof 
# End of file forth_opcodes.asm
246c			 
246c			include "forth_words_core.asm" 
246c			 
246c			; | ## Core Words 
246c			 
246c			;if MALLOC_4 
246c			 
246c			.HEAP: 
246c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
246c 15				db WORD_SYS_CORE+OPCODE_HEAP             
246d ab 24			dw .EXEC            
246f 05				db 4 + 1 
2470 .. 00			db "HEAP",0              
2475				endm 
# End of macro CWHEAD
2475			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2475			; | | u1 - Current number of bytes in the heap 
2475			; | | u2 - Remaining bytes left on the heap 
2475			; | |  
2475			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2475			 
2475			 
2475					if DEBUG_FORTH_WORDS_KEY 
2475						DMARK "HEP" 
2475 f5				push af  
2476 3a 8a 24			ld a, (.dmark)  
2479 32 6e fe			ld (debug_mark),a  
247c 3a 8b 24			ld a, (.dmark+1)  
247f 32 6f fe			ld (debug_mark+1),a  
2482 3a 8c 24			ld a, (.dmark+2)  
2485 32 70 fe			ld (debug_mark+2),a  
2488 18 03			jr .pastdmark  
248a ..			.dmark: db "HEP"  
248d f1			.pastdmark: pop af  
248e			endm  
# End of macro DMARK
248e						CALLMONITOR 
248e cd f3 18			call break_point_state  
2491				endm  
# End of macro CALLMONITOR
2491					endif 
2491 2a 0a 80				ld hl, (free_list )      
2494 11 0e 80				ld de, heap_start 
2497			 
2497 ed 52				sbc hl, de  
2499			 
2499 cd 67 1f				call forth_push_numhl 
249c			 
249c			 
249c ed 5b 0a 80			ld de, (free_list )      
24a0 21 ae f1				ld hl, heap_end 
24a3			 
24a3 ed 52				sbc hl, de 
24a5			 
24a5 cd 67 1f				call forth_push_numhl 
24a8					 
24a8			 
24a8					 
24a8			 
24a8			 
24a8			 
24a8					NEXTW 
24a8 c3 14 23			jp macro_next 
24ab				endm 
# End of macro NEXTW
24ab			;endif 
24ab			 
24ab			.EXEC: 
24ab			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
24ab			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
24ab			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
24ab			;; > > 
24ab			;; > >   
24ab			;	STACKFRAME OFF $5efe $5f9f 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "EXE" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	FORTH_DSP_POP 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX1" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;;	ld e,(hl) 
24ab			;;	inc hl 
24ab			;;	ld d,(hl) 
24ab			;;	ex de,hl 
24ab			; 
24ab			;;		if DEBUG_FORTH_WORDS 
24ab			;;			DMARK "EX2" 
24ab			;;			CALLMONITOR 
24ab			;;		endif 
24ab			;	push hl 
24ab			; 
24ab			;	;ld a, 0 
24ab			;	;ld a, FORTH_END_BUFFER 
24ab			;	call strlenz 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include term 
24ab			;	inc hl   ; include term 
24ab			;	ld b,0 
24ab			;	ld c,l 
24ab			;	pop hl 
24ab			;	ld de, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir 
24ab			; 
24ab			; 
24ab			;	ld hl, execscratch 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXe" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	call forthexec 
24ab			;;	call forthexec_cleanup 
24ab			;;	call forthparse 
24ab			;;	call forthexec 
24ab			; 
24ab			;	STACKFRAMECHK OFF $5efe $5f9f 
24ab			; 
24ab			;	; an immediate word so no need to process any more words 
24ab			;	ret 
24ab			;	NEXTW 
24ab			 
24ab			; dead code - old version  
24ab			;	FORTH_RSP_NEXT 
24ab			 
24ab			;  
24ab			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24ab			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24ab			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24ab			;	push hl 
24ab			;	push de 
24ab			;	push bc 
24ab			; 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "EXR" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			; 
24ab			; 
24ab			;	;v5 FORTH_DSP_VALUE 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	; TODO do string type checks 
24ab			; 
24ab			;;v5	inc hl   ; skip type 
24ab			; 
24ab			;	push hl  ; source code  
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX1" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ld a, 0 
24ab			;	call strlent 
24ab			; 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			; 
24ab			;	push hl    ; size 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX2" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	call malloc 
24ab			; 
24ab			;	ex de, hl    ; de now contains malloc area 
24ab			;	pop bc   	; get byte count 
24ab			;	pop hl      ; get string to copy 
24ab			; 
24ab			;	push de     ; save malloc for free later 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir       ; duplicate string 
24ab			; 
24ab			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
24ab			;	 
24ab			;	; TODO fix the parse would be better than this...  
24ab			;	ex de, hl 
24ab			;	dec hl 
24ab			;	ld a, 0 
24ab			;	ld (hl), a 
24ab			;	dec hl 
24ab			;	ld a, ' ' 
24ab			;	ld (hl), a 
24ab			;	dec hl 
24ab			;	ld (hl), a 
24ab			; 
24ab			;	dec hl 
24ab			;	ld (hl), a 
24ab			; 
24ab			; 
24ab			;	FORTH_DSP_POP  
24ab			; 
24ab			;	pop hl     
24ab			;	push hl    ; save malloc area 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX4" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	call forthexec 
24ab			;	 
24ab			;	pop hl 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX5" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			; 
24ab			;	if FORTH_ENABLE_FREE 
24ab			;	call free 
24ab			;	endif 
24ab			; 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX6" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			; 
24ab			;	pop bc 
24ab			;	pop de 
24ab			;	pop hl 
24ab			;;	FORTH_RSP_POP	  
24ab			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
24ab			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
24ab			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
24ab			; 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX7" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			;	NEXTW 
24ab			 
24ab			;.STKEXEC: 
24ab			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
24ab			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
24ab			; 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "STX" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	ld (store_tmp1), hl    ; count 
24ab			; 
24ab			;	FORTH_DSP_POP 
24ab			;.stkexec1: 
24ab			;	ld hl, (store_tmp1)   ; count 
24ab			;	ld a, 0 
24ab			;	cp l 
24ab			;	ret z 
24ab			; 
24ab			;	dec hl 
24ab			;	ld (store_tmp1), hl    ; count 
24ab			;	 
24ab			;	FORTH_DSP_VALUEHL 
24ab			;	push hl 
24ab			;	 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXp" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	FORTH_DSP_POP 
24ab			; 
24ab			;	call strlenz 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	ld b,0 
24ab			;	ld c,l 
24ab			;	pop hl 
24ab			;	ld de, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir 
24ab			; 
24ab			; 
24ab			;	ld hl, execscratch 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXP" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	ld hl, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXx" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	call forthexec 
24ab			; 
24ab			;	jp .stkexec1 
24ab			; 
24ab			;	ret 
24ab			 
24ab			 
24ab			.DUP: 
24ab				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
24ab 17				db WORD_SYS_CORE+OPCODE_DUP             
24ac 21 25			dw .ZDUP            
24ae 04				db 3 + 1 
24af .. 00			db "DUP",0              
24b3				endm 
# End of macro CWHEAD
24b3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
24b3			 
24b3					if DEBUG_FORTH_WORDS_KEY 
24b3						DMARK "DUP" 
24b3 f5				push af  
24b4 3a c8 24			ld a, (.dmark)  
24b7 32 6e fe			ld (debug_mark),a  
24ba 3a c9 24			ld a, (.dmark+1)  
24bd 32 6f fe			ld (debug_mark+1),a  
24c0 3a ca 24			ld a, (.dmark+2)  
24c3 32 70 fe			ld (debug_mark+2),a  
24c6 18 03			jr .pastdmark  
24c8 ..			.dmark: db "DUP"  
24cb f1			.pastdmark: pop af  
24cc			endm  
# End of macro DMARK
24cc						CALLMONITOR 
24cc cd f3 18			call break_point_state  
24cf				endm  
# End of macro CALLMONITOR
24cf					endif 
24cf			 
24cf					FORTH_DSP 
24cf cd 24 21			call macro_forth_dsp 
24d2				endm 
# End of macro FORTH_DSP
24d2			 
24d2 7e					ld a, (HL) 
24d3 fe 01				cp DS_TYPE_STR 
24d5 20 25				jr nz, .dupinum 
24d7			 
24d7					; push another string 
24d7			 
24d7					FORTH_DSP_VALUEHL     		 
24d7 cd 5e 21			call macro_dsp_valuehl 
24da				endm 
# End of macro FORTH_DSP_VALUEHL
24da			 
24da				if DEBUG_FORTH_WORDS 
24da					DMARK "DUs" 
24da f5				push af  
24db 3a ef 24			ld a, (.dmark)  
24de 32 6e fe			ld (debug_mark),a  
24e1 3a f0 24			ld a, (.dmark+1)  
24e4 32 6f fe			ld (debug_mark+1),a  
24e7 3a f1 24			ld a, (.dmark+2)  
24ea 32 70 fe			ld (debug_mark+2),a  
24ed 18 03			jr .pastdmark  
24ef ..			.dmark: db "DUs"  
24f2 f1			.pastdmark: pop af  
24f3			endm  
# End of macro DMARK
24f3					CALLMONITOR 
24f3 cd f3 18			call break_point_state  
24f6				endm  
# End of macro CALLMONITOR
24f6				endif 
24f6 cd d5 1f				call forth_push_str 
24f9			 
24f9					NEXTW 
24f9 c3 14 23			jp macro_next 
24fc				endm 
# End of macro NEXTW
24fc			 
24fc			 
24fc			.dupinum: 
24fc					 
24fc			 
24fc			 
24fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24fc cd 5e 21			call macro_dsp_valuehl 
24ff				endm 
# End of macro FORTH_DSP_VALUEHL
24ff			 
24ff				; TODO add floating point number detection 
24ff			 
24ff				if DEBUG_FORTH_WORDS 
24ff					DMARK "DUi" 
24ff f5				push af  
2500 3a 14 25			ld a, (.dmark)  
2503 32 6e fe			ld (debug_mark),a  
2506 3a 15 25			ld a, (.dmark+1)  
2509 32 6f fe			ld (debug_mark+1),a  
250c 3a 16 25			ld a, (.dmark+2)  
250f 32 70 fe			ld (debug_mark+2),a  
2512 18 03			jr .pastdmark  
2514 ..			.dmark: db "DUi"  
2517 f1			.pastdmark: pop af  
2518			endm  
# End of macro DMARK
2518					CALLMONITOR 
2518 cd f3 18			call break_point_state  
251b				endm  
# End of macro CALLMONITOR
251b				endif 
251b			 
251b cd 67 1f				call forth_push_numhl 
251e					NEXTW 
251e c3 14 23			jp macro_next 
2521				endm 
# End of macro NEXTW
2521			.ZDUP: 
2521				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2521 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2522 59 25			dw .SWAP            
2524 05				db 4 + 1 
2525 .. 00			db "?DUP",0              
252a				endm 
# End of macro CWHEAD
252a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
252a			 
252a					if DEBUG_FORTH_WORDS_KEY 
252a						DMARK "qDU" 
252a f5				push af  
252b 3a 3f 25			ld a, (.dmark)  
252e 32 6e fe			ld (debug_mark),a  
2531 3a 40 25			ld a, (.dmark+1)  
2534 32 6f fe			ld (debug_mark+1),a  
2537 3a 41 25			ld a, (.dmark+2)  
253a 32 70 fe			ld (debug_mark+2),a  
253d 18 03			jr .pastdmark  
253f ..			.dmark: db "qDU"  
2542 f1			.pastdmark: pop af  
2543			endm  
# End of macro DMARK
2543						CALLMONITOR 
2543 cd f3 18			call break_point_state  
2546				endm  
# End of macro CALLMONITOR
2546					endif 
2546					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2546 cd 5e 21			call macro_dsp_valuehl 
2549				endm 
# End of macro FORTH_DSP_VALUEHL
2549			 
2549 e5					push hl 
254a			 
254a					; is it a zero? 
254a			 
254a 3e 00				ld a, 0 
254c 84					add h 
254d 85					add l 
254e			 
254e e1					pop hl 
254f			 
254f fe 00				cp 0 
2551 28 03				jr z, .dup2orig 
2553			 
2553			 
2553 cd 67 1f				call forth_push_numhl 
2556			 
2556			 
2556				; TODO add floating point number detection 
2556			 
2556			.dup2orig: 
2556			 
2556					NEXTW 
2556 c3 14 23			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.SWAP: 
2559				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2559 18				db WORD_SYS_CORE+OPCODE_SWAP             
255a 98 25			dw .COLN            
255c 05				db 4 + 1 
255d .. 00			db "SWAP",0              
2562				endm 
# End of macro CWHEAD
2562			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2562					if DEBUG_FORTH_WORDS_KEY 
2562						DMARK "SWP" 
2562 f5				push af  
2563 3a 77 25			ld a, (.dmark)  
2566 32 6e fe			ld (debug_mark),a  
2569 3a 78 25			ld a, (.dmark+1)  
256c 32 6f fe			ld (debug_mark+1),a  
256f 3a 79 25			ld a, (.dmark+2)  
2572 32 70 fe			ld (debug_mark+2),a  
2575 18 03			jr .pastdmark  
2577 ..			.dmark: db "SWP"  
257a f1			.pastdmark: pop af  
257b			endm  
# End of macro DMARK
257b						CALLMONITOR 
257b cd f3 18			call break_point_state  
257e				endm  
# End of macro CALLMONITOR
257e					endif 
257e			 
257e					FORTH_DSP_VALUEHL 
257e cd 5e 21			call macro_dsp_valuehl 
2581				endm 
# End of macro FORTH_DSP_VALUEHL
2581 e5					push hl     ; w2 
2582			 
2582					FORTH_DSP_POP 
2582 cd 16 22			call macro_forth_dsp_pop 
2585				endm 
# End of macro FORTH_DSP_POP
2585			 
2585					FORTH_DSP_VALUEHL 
2585 cd 5e 21			call macro_dsp_valuehl 
2588				endm 
# End of macro FORTH_DSP_VALUEHL
2588			 
2588					FORTH_DSP_POP 
2588 cd 16 22			call macro_forth_dsp_pop 
258b				endm 
# End of macro FORTH_DSP_POP
258b			 
258b d1					pop de     ; w2	, hl = w1 
258c			 
258c eb					ex de, hl 
258d d5					push de 
258e			 
258e cd 67 1f				call forth_push_numhl 
2591			 
2591 e1					pop hl 
2592			 
2592 cd 67 1f				call forth_push_numhl 
2595					 
2595			 
2595					NEXTW 
2595 c3 14 23			jp macro_next 
2598				endm 
# End of macro NEXTW
2598			.COLN: 
2598				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2598 19				db WORD_SYS_CORE+OPCODE_COLN             
2599 24 27			dw .SCOLN            
259b 02				db 1 + 1 
259c .. 00			db ":",0              
259e				endm 
# End of macro CWHEAD
259e			; | : ( -- )         Create new word | DONE 
259e			 
259e					if DEBUG_FORTH_WORDS_KEY 
259e						DMARK "CLN" 
259e f5				push af  
259f 3a b3 25			ld a, (.dmark)  
25a2 32 6e fe			ld (debug_mark),a  
25a5 3a b4 25			ld a, (.dmark+1)  
25a8 32 6f fe			ld (debug_mark+1),a  
25ab 3a b5 25			ld a, (.dmark+2)  
25ae 32 70 fe			ld (debug_mark+2),a  
25b1 18 03			jr .pastdmark  
25b3 ..			.dmark: db "CLN"  
25b6 f1			.pastdmark: pop af  
25b7			endm  
# End of macro DMARK
25b7						CALLMONITOR 
25b7 cd f3 18			call break_point_state  
25ba				endm  
# End of macro CALLMONITOR
25ba					endif 
25ba				STACKFRAME OFF $8efe $989f 
25ba				if DEBUG_STACK_IMB 
25ba					if OFF 
25ba						exx 
25ba						ld de, $8efe 
25ba						ld a, d 
25ba						ld hl, curframe 
25ba						call hexout 
25ba						ld a, e 
25ba						ld hl, curframe+2 
25ba						call hexout 
25ba						ld hl, $8efe 
25ba						push hl 
25ba						ld hl, $989f 
25ba						push hl 
25ba						exx 
25ba					endif 
25ba				endif 
25ba			endm 
# End of macro STACKFRAME
25ba				; get parser buffer length  of new word 
25ba			 
25ba				 
25ba			 
25ba					; move tok past this to start of name defintition 
25ba					; TODO get word to define 
25ba					; TODO Move past word token 
25ba					; TODO get length of string up to the ';' 
25ba			 
25ba 2a c9 f4			ld hl, (os_tok_ptr) 
25bd 23				inc hl 
25be 23				inc hl 
25bf			 
25bf 3e 3b			ld a, ';' 
25c1 cd b5 13			call strlent 
25c4			 
25c4 7d				ld a,l 
25c5 32 c4 f1			ld (os_new_parse_len), a 
25c8			 
25c8			 
25c8			if DEBUG_FORTH_UWORD 
25c8 ed 5b c9 f4		ld de, (os_tok_ptr) 
25cc						DMARK ":01" 
25cc f5				push af  
25cd 3a e1 25			ld a, (.dmark)  
25d0 32 6e fe			ld (debug_mark),a  
25d3 3a e2 25			ld a, (.dmark+1)  
25d6 32 6f fe			ld (debug_mark+1),a  
25d9 3a e3 25			ld a, (.dmark+2)  
25dc 32 70 fe			ld (debug_mark+2),a  
25df 18 03			jr .pastdmark  
25e1 ..			.dmark: db ":01"  
25e4 f1			.pastdmark: pop af  
25e5			endm  
# End of macro DMARK
25e5				CALLMONITOR 
25e5 cd f3 18			call break_point_state  
25e8				endm  
# End of macro CALLMONITOR
25e8			endif 
25e8			 
25e8			; 
25e8			;  new word memory layout: 
25e8			;  
25e8			;    : adg 6666 ;  
25e8			; 
25e8			;    db   1     ; user defined word  
25e8 23				inc hl    
25e9			;    dw   sysdict 
25e9 23				inc hl 
25ea 23				inc hl 
25eb			;    db <word len>+1 (for null) 
25eb 23				inc hl 
25ec			;    db .... <word> 
25ec			; 
25ec			 
25ec 23				inc hl    ; some extras for the word preamble before the above 
25ed 23				inc hl 
25ee 23				inc hl 
25ef 23				inc hl 
25f0 23				inc hl 
25f1 23				inc hl 
25f2 23				inc hl  
25f3 23				inc hl 
25f4 23				inc hl 
25f5 23				inc hl 
25f6 23				inc hl 
25f7 23				inc hl 
25f8 23				inc hl 
25f9 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25fa			;       exec word buffer 
25fa			;	<ptr word>   
25fa 23				inc hl 
25fb 23				inc hl 
25fc			;       <word list><null term> 7F final term 
25fc			 
25fc			 
25fc			if DEBUG_FORTH_UWORD 
25fc						DMARK ":02" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 6e fe			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 6f fe			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 70 fe			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db ":02"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615				CALLMONITOR 
2615 cd f3 18			call break_point_state  
2618				endm  
# End of macro CALLMONITOR
2618			endif 
2618			 
2618				 
2618					; malloc the size 
2618			 
2618 cd 13 14				call malloc 
261b 22 c6 f1				ld (os_new_malloc), hl     ; save malloc start 
261e			 
261e			;    db   1     ; user defined word  
261e 3e 01				ld a, WORD_SYS_UWORD  
2620 77					ld (hl), a 
2621				 
2621 23				inc hl    
2622			;    dw   sysdict 
2622 11 6c 24			ld de, sysdict       ; continue on with the scan to the system dict 
2625 73				ld (hl), e 
2626 23				inc hl 
2627 72				ld (hl), d 
2628 23				inc hl 
2629			 
2629			 
2629			;    Setup dict word 
2629			 
2629 23				inc hl 
262a 22 c0 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
262d			 
262d				; 1. get length of dict word 
262d			 
262d			 
262d 2a c9 f4			ld hl, (os_tok_ptr) 
2630 23				inc hl 
2631 23				inc hl    ; position to start of dict word 
2632 3e 00			ld a, 0 
2634 cd b5 13			call strlent 
2637			 
2637			 
2637 23				inc hl    ; to include null??? 
2638			 
2638				; write length of dict word 
2638			 
2638 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
263c 1b				dec de 
263d eb				ex de, hl 
263e 73				ld (hl), e 
263f eb				ex de, hl 
2640			 
2640				 
2640			 
2640				; copy  
2640 4d				ld c, l 
2641 06 00			ld b, 0 
2643 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2647 2a c9 f4			ld hl, (os_tok_ptr) 
264a 23				inc hl 
264b 23				inc hl    ; position to start of dict word 
264c				 
264c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
264c				 
264c				; TODO need to convert word to upper case 
264c			 
264c			ucasetok:	 
264c 7e				ld a,(hl) 
264d cd a1 13			call toUpper 
2650 77				ld (hl),a 
2651 ed a0			ldi 
2653 f2 4c 26		 	jp p, ucasetok 
2656			 
2656			 
2656			 
2656				; de now points to start of where the word body code should be placed 
2656 ed 53 c0 f1		ld (os_new_work_ptr), de 
265a				; hl now points to the words to throw at forthexec which needs to be copied 
265a 22 be f1			ld (os_new_src_ptr), hl 
265d			 
265d				; TODO add 'call to forthexec' 
265d			 
265d			if DEBUG_FORTH_UWORD 
265d c5				push bc 
265e ed 4b c6 f1		ld bc, (os_new_malloc) 
2662						DMARK ":0x" 
2662 f5				push af  
2663 3a 77 26			ld a, (.dmark)  
2666 32 6e fe			ld (debug_mark),a  
2669 3a 78 26			ld a, (.dmark+1)  
266c 32 6f fe			ld (debug_mark+1),a  
266f 3a 79 26			ld a, (.dmark+2)  
2672 32 70 fe			ld (debug_mark+2),a  
2675 18 03			jr .pastdmark  
2677 ..			.dmark: db ":0x"  
267a f1			.pastdmark: pop af  
267b			endm  
# End of macro DMARK
267b				CALLMONITOR 
267b cd f3 18			call break_point_state  
267e				endm  
# End of macro CALLMONITOR
267e c1				pop bc 
267f			endif 
267f			 
267f			 
267f				; create word preamble which should be: 
267f			 
267f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
267f			 
267f				;    ld hl, <word code> 
267f				;    jp user_exec 
267f			        ;    <word code bytes> 
267f			 
267f			 
267f			;	inc de     ; TODO ??? or are we already past the word's null 
267f eb				ex de, hl 
2680			 
2680 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2682			 
2682 23				inc hl 
2683 22 ba f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2686 23				inc hl 
2687			 
2687 23				inc hl 
2688 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
268a			 
268a 01 93 59			ld bc, user_exec 
268d 23				inc hl 
268e 71				ld (hl), c     ; poke address of user_exec 
268f 23				inc hl 
2690 70				ld (hl), b     
2691			 ; 
2691			;	inc hl 
2691			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2691			; 
2691			; 
2691			;	ld bc, macro_forth_rsp_next 
2691			;	inc hl 
2691			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2691			;	inc hl 
2691			;	ld (hl), b     
2691			 ; 
2691			;	inc hl 
2691			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2691			; 
2691			; 
2691			;	inc hl 
2691			;	ld bc, forthexec 
2691			;	ld (hl), c     ; poke address of forthexec 
2691			;	inc hl 
2691			;	ld (hl), b      
2691			; 
2691			;	inc hl 
2691			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2691			; 
2691			;	ld bc, user_dict_next 
2691			;	inc hl 
2691			;	ld (hl), c     ; poke address of forthexec 
2691			;	inc hl 
2691			;	ld (hl), b      
2691			 
2691				; hl is now where we need to copy the word byte data to save this 
2691			 
2691 23				inc hl 
2692 22 bc f1			ld (os_new_exec), hl 
2695				 
2695				; copy definition 
2695			 
2695 eb				ex de, hl 
2696			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2696			;	inc de    ; skip the PC for this parse 
2696 3a c4 f1			ld a, (os_new_parse_len) 
2699 4f				ld c, a 
269a 06 00			ld b, 0 
269c ed b0			ldir		 ; copy defintion 
269e			 
269e			 
269e				; poke the address of where the new word bytes live for forthexec 
269e			 
269e 2a ba f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
26a1			 
26a1 ed 5b bc f1		ld de, (os_new_exec)      
26a5				 
26a5 73				ld (hl), e 
26a6 23				inc hl 
26a7 72				ld (hl), d 
26a8			 
26a8					; TODO copy last user dict word next link to this word 
26a8					; TODO update last user dict word to point to this word 
26a8			; 
26a8			; hl f923 de 812a ; bc 811a 
26a8			 
26a8			if DEBUG_FORTH_UWORD 
26a8 c5				push bc 
26a9 ed 4b c6 f1		ld bc, (os_new_malloc) 
26ad						DMARK ":0A" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 6e fe			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 6f fe			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 70 fe			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db ":0A"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6				CALLMONITOR 
26c6 cd f3 18			call break_point_state  
26c9				endm  
# End of macro CALLMONITOR
26c9 c1				pop bc 
26ca			endif 
26ca			if DEBUG_FORTH_UWORD 
26ca c5				push bc 
26cb ed 4b c6 f1		ld bc, (os_new_malloc) 
26cf 03				inc bc 
26d0 03				inc bc 
26d1 03				inc bc 
26d2 03				inc bc 
26d3 03				inc bc 
26d4 03				inc bc 
26d5 03				inc bc 
26d6 03				inc bc 
26d7			 
26d7						DMARK ":0B" 
26d7 f5				push af  
26d8 3a ec 26			ld a, (.dmark)  
26db 32 6e fe			ld (debug_mark),a  
26de 3a ed 26			ld a, (.dmark+1)  
26e1 32 6f fe			ld (debug_mark+1),a  
26e4 3a ee 26			ld a, (.dmark+2)  
26e7 32 70 fe			ld (debug_mark+2),a  
26ea 18 03			jr .pastdmark  
26ec ..			.dmark: db ":0B"  
26ef f1			.pastdmark: pop af  
26f0			endm  
# End of macro DMARK
26f0				CALLMONITOR 
26f0 cd f3 18			call break_point_state  
26f3				endm  
# End of macro CALLMONITOR
26f3 c1				pop bc 
26f4			endif 
26f4			 
26f4			; update word dict linked list for new word 
26f4			 
26f4			 
26f4 2a c5 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26f7 23			inc hl     ; move to next work linked list ptr 
26f8			 
26f8 ed 5b c6 f1	ld de, (os_new_malloc)		 ; new next word 
26fc 73			ld (hl), e 
26fd 23			inc hl 
26fe 72			ld (hl), d 
26ff			 
26ff			if DEBUG_FORTH_UWORD 
26ff ed 4b c5 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2703			endif 
2703			 
2703 ed 53 c5 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2707			 
2707			 
2707			if DEBUG_FORTH_UWORD 
2707						DMARK ":0+" 
2707 f5				push af  
2708 3a 1c 27			ld a, (.dmark)  
270b 32 6e fe			ld (debug_mark),a  
270e 3a 1d 27			ld a, (.dmark+1)  
2711 32 6f fe			ld (debug_mark+1),a  
2714 3a 1e 27			ld a, (.dmark+2)  
2717 32 70 fe			ld (debug_mark+2),a  
271a 18 03			jr .pastdmark  
271c ..			.dmark: db ":0+"  
271f f1			.pastdmark: pop af  
2720			endm  
# End of macro DMARK
2720				CALLMONITOR 
2720 cd f3 18			call break_point_state  
2723				endm  
# End of macro CALLMONITOR
2723			endif 
2723			 
2723				STACKFRAMECHK OFF $8efe $989f 
2723				if DEBUG_STACK_IMB 
2723					if OFF 
2723						exx 
2723						ld hl, $989f 
2723						pop de   ; $989f 
2723						call cmp16 
2723						jr nz, .spnosame 
2723						ld hl, $8efe 
2723						pop de   ; $8efe 
2723						call cmp16 
2723						jr z, .spfrsame 
2723						.spnosame: call showsperror 
2723						.spfrsame: nop 
2723						exx 
2723					endif 
2723				endif 
2723			endm 
# End of macro STACKFRAMECHK
2723			 
2723 c9			ret    ; dont process any remaining parser tokens as they form new word 
2724			 
2724			 
2724			 
2724			 
2724			;		NEXT 
2724			.SCOLN: 
2724			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2724 06				db OPCODE_SCOLN 
2725 70 27			dw .DROP 
2727 02				db 2 
2728 .. 00			db ";",0           
272a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
272a					if DEBUG_FORTH_WORDS_KEY 
272a						DMARK "SCN" 
272a f5				push af  
272b 3a 3f 27			ld a, (.dmark)  
272e 32 6e fe			ld (debug_mark),a  
2731 3a 40 27			ld a, (.dmark+1)  
2734 32 6f fe			ld (debug_mark+1),a  
2737 3a 41 27			ld a, (.dmark+2)  
273a 32 70 fe			ld (debug_mark+2),a  
273d 18 03			jr .pastdmark  
273f ..			.dmark: db "SCN"  
2742 f1			.pastdmark: pop af  
2743			endm  
# End of macro DMARK
2743						CALLMONITOR 
2743 cd f3 18			call break_point_state  
2746				endm  
# End of macro CALLMONITOR
2746					endif 
2746					FORTH_RSP_TOS 
2746 cd 25 1f			call macro_forth_rsp_tos 
2749				endm 
# End of macro FORTH_RSP_TOS
2749 e5					push hl 
274a					FORTH_RSP_POP 
274a cd 2f 1f			call macro_forth_rsp_pop 
274d				endm 
# End of macro FORTH_RSP_POP
274d e1					pop hl 
274e			;		ex de,hl 
274e 22 c9 f4				ld (os_tok_ptr),hl 
2751			 
2751			if DEBUG_FORTH_UWORD 
2751						DMARK "SCL" 
2751 f5				push af  
2752 3a 66 27			ld a, (.dmark)  
2755 32 6e fe			ld (debug_mark),a  
2758 3a 67 27			ld a, (.dmark+1)  
275b 32 6f fe			ld (debug_mark+1),a  
275e 3a 68 27			ld a, (.dmark+2)  
2761 32 70 fe			ld (debug_mark+2),a  
2764 18 03			jr .pastdmark  
2766 ..			.dmark: db "SCL"  
2769 f1			.pastdmark: pop af  
276a			endm  
# End of macro DMARK
276a				CALLMONITOR 
276a cd f3 18			call break_point_state  
276d				endm  
# End of macro CALLMONITOR
276d			endif 
276d					NEXTW 
276d c3 14 23			jp macro_next 
2770				endm 
# End of macro NEXTW
2770			 
2770			.DROP: 
2770				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2770 1b				db WORD_SYS_CORE+OPCODE_DROP             
2771 9b 27			dw .DUP2            
2773 05				db 4 + 1 
2774 .. 00			db "DROP",0              
2779				endm 
# End of macro CWHEAD
2779			; | DROP ( w -- )   drop the TOS item   | DONE 
2779					if DEBUG_FORTH_WORDS_KEY 
2779						DMARK "DRP" 
2779 f5				push af  
277a 3a 8e 27			ld a, (.dmark)  
277d 32 6e fe			ld (debug_mark),a  
2780 3a 8f 27			ld a, (.dmark+1)  
2783 32 6f fe			ld (debug_mark+1),a  
2786 3a 90 27			ld a, (.dmark+2)  
2789 32 70 fe			ld (debug_mark+2),a  
278c 18 03			jr .pastdmark  
278e ..			.dmark: db "DRP"  
2791 f1			.pastdmark: pop af  
2792			endm  
# End of macro DMARK
2792						CALLMONITOR 
2792 cd f3 18			call break_point_state  
2795				endm  
# End of macro CALLMONITOR
2795					endif 
2795					FORTH_DSP_POP 
2795 cd 16 22			call macro_forth_dsp_pop 
2798				endm 
# End of macro FORTH_DSP_POP
2798					NEXTW 
2798 c3 14 23			jp macro_next 
279b				endm 
# End of macro NEXTW
279b			.DUP2: 
279b				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
279b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
279c e0 27			dw .DROP2            
279e 05				db 4 + 1 
279f .. 00			db "2DUP",0              
27a4				endm 
# End of macro CWHEAD
27a4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
27a4					if DEBUG_FORTH_WORDS_KEY 
27a4						DMARK "2DU" 
27a4 f5				push af  
27a5 3a b9 27			ld a, (.dmark)  
27a8 32 6e fe			ld (debug_mark),a  
27ab 3a ba 27			ld a, (.dmark+1)  
27ae 32 6f fe			ld (debug_mark+1),a  
27b1 3a bb 27			ld a, (.dmark+2)  
27b4 32 70 fe			ld (debug_mark+2),a  
27b7 18 03			jr .pastdmark  
27b9 ..			.dmark: db "2DU"  
27bc f1			.pastdmark: pop af  
27bd			endm  
# End of macro DMARK
27bd						CALLMONITOR 
27bd cd f3 18			call break_point_state  
27c0				endm  
# End of macro CALLMONITOR
27c0					endif 
27c0					FORTH_DSP_VALUEHL 
27c0 cd 5e 21			call macro_dsp_valuehl 
27c3				endm 
# End of macro FORTH_DSP_VALUEHL
27c3 e5					push hl      ; 2 
27c4			 
27c4					FORTH_DSP_POP 
27c4 cd 16 22			call macro_forth_dsp_pop 
27c7				endm 
# End of macro FORTH_DSP_POP
27c7					 
27c7					FORTH_DSP_VALUEHL 
27c7 cd 5e 21			call macro_dsp_valuehl 
27ca				endm 
# End of macro FORTH_DSP_VALUEHL
27ca			;		push hl      ; 1 
27ca			 
27ca					FORTH_DSP_POP 
27ca cd 16 22			call macro_forth_dsp_pop 
27cd				endm 
# End of macro FORTH_DSP_POP
27cd			 
27cd			;		pop hl       ; 1 
27cd d1					pop de       ; 2 
27ce			 
27ce cd 67 1f				call forth_push_numhl 
27d1 eb					ex de, hl 
27d2 cd 67 1f				call forth_push_numhl 
27d5			 
27d5					 
27d5 eb					ex de, hl 
27d6			 
27d6 cd 67 1f				call forth_push_numhl 
27d9 eb					ex de, hl 
27da cd 67 1f				call forth_push_numhl 
27dd			 
27dd			 
27dd					NEXTW 
27dd c3 14 23			jp macro_next 
27e0				endm 
# End of macro NEXTW
27e0			.DROP2: 
27e0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27e0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27e1 0f 28			dw .SWAP2            
27e3 06				db 5 + 1 
27e4 .. 00			db "2DROP",0              
27ea				endm 
# End of macro CWHEAD
27ea			; | 2DROP ( w w -- )    Double drop | DONE 
27ea					if DEBUG_FORTH_WORDS_KEY 
27ea						DMARK "2DR" 
27ea f5				push af  
27eb 3a ff 27			ld a, (.dmark)  
27ee 32 6e fe			ld (debug_mark),a  
27f1 3a 00 28			ld a, (.dmark+1)  
27f4 32 6f fe			ld (debug_mark+1),a  
27f7 3a 01 28			ld a, (.dmark+2)  
27fa 32 70 fe			ld (debug_mark+2),a  
27fd 18 03			jr .pastdmark  
27ff ..			.dmark: db "2DR"  
2802 f1			.pastdmark: pop af  
2803			endm  
# End of macro DMARK
2803						CALLMONITOR 
2803 cd f3 18			call break_point_state  
2806				endm  
# End of macro CALLMONITOR
2806					endif 
2806					FORTH_DSP_POP 
2806 cd 16 22			call macro_forth_dsp_pop 
2809				endm 
# End of macro FORTH_DSP_POP
2809					FORTH_DSP_POP 
2809 cd 16 22			call macro_forth_dsp_pop 
280c				endm 
# End of macro FORTH_DSP_POP
280c					NEXTW 
280c c3 14 23			jp macro_next 
280f				endm 
# End of macro NEXTW
280f			.SWAP2: 
280f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
280f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2810 38 28			dw .AT            
2812 06				db 5 + 1 
2813 .. 00			db "2SWAP",0              
2819				endm 
# End of macro CWHEAD
2819			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2819					if DEBUG_FORTH_WORDS_KEY 
2819						DMARK "2SW" 
2819 f5				push af  
281a 3a 2e 28			ld a, (.dmark)  
281d 32 6e fe			ld (debug_mark),a  
2820 3a 2f 28			ld a, (.dmark+1)  
2823 32 6f fe			ld (debug_mark+1),a  
2826 3a 30 28			ld a, (.dmark+2)  
2829 32 70 fe			ld (debug_mark+2),a  
282c 18 03			jr .pastdmark  
282e ..			.dmark: db "2SW"  
2831 f1			.pastdmark: pop af  
2832			endm  
# End of macro DMARK
2832						CALLMONITOR 
2832 cd f3 18			call break_point_state  
2835				endm  
# End of macro CALLMONITOR
2835					endif 
2835					NEXTW 
2835 c3 14 23			jp macro_next 
2838				endm 
# End of macro NEXTW
2838			.AT: 
2838				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2838 1f				db WORD_SYS_CORE+OPCODE_AT             
2839 6a 28			dw .CAT            
283b 02				db 1 + 1 
283c .. 00			db "@",0              
283e				endm 
# End of macro CWHEAD
283e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
283e			 
283e					if DEBUG_FORTH_WORDS_KEY 
283e						DMARK "AT." 
283e f5				push af  
283f 3a 53 28			ld a, (.dmark)  
2842 32 6e fe			ld (debug_mark),a  
2845 3a 54 28			ld a, (.dmark+1)  
2848 32 6f fe			ld (debug_mark+1),a  
284b 3a 55 28			ld a, (.dmark+2)  
284e 32 70 fe			ld (debug_mark+2),a  
2851 18 03			jr .pastdmark  
2853 ..			.dmark: db "AT."  
2856 f1			.pastdmark: pop af  
2857			endm  
# End of macro DMARK
2857						CALLMONITOR 
2857 cd f3 18			call break_point_state  
285a				endm  
# End of macro CALLMONITOR
285a					endif 
285a			.getbyteat:	 
285a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285a cd 5e 21			call macro_dsp_valuehl 
285d				endm 
# End of macro FORTH_DSP_VALUEHL
285d					 
285d			;		push hl 
285d				 
285d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285d cd 16 22			call macro_forth_dsp_pop 
2860				endm 
# End of macro FORTH_DSP_POP
2860			 
2860			;		pop hl 
2860			 
2860 7e					ld a, (hl) 
2861			 
2861 6f					ld l, a 
2862 26 00				ld h, 0 
2864 cd 67 1f				call forth_push_numhl 
2867			 
2867					NEXTW 
2867 c3 14 23			jp macro_next 
286a				endm 
# End of macro NEXTW
286a			.CAT: 
286a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
286a 20				db WORD_SYS_CORE+OPCODE_CAT             
286b 93 28			dw .BANG            
286d 03				db 2 + 1 
286e .. 00			db "C@",0              
2871				endm 
# End of macro CWHEAD
2871			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2871					if DEBUG_FORTH_WORDS_KEY 
2871						DMARK "CAA" 
2871 f5				push af  
2872 3a 86 28			ld a, (.dmark)  
2875 32 6e fe			ld (debug_mark),a  
2878 3a 87 28			ld a, (.dmark+1)  
287b 32 6f fe			ld (debug_mark+1),a  
287e 3a 88 28			ld a, (.dmark+2)  
2881 32 70 fe			ld (debug_mark+2),a  
2884 18 03			jr .pastdmark  
2886 ..			.dmark: db "CAA"  
2889 f1			.pastdmark: pop af  
288a			endm  
# End of macro DMARK
288a						CALLMONITOR 
288a cd f3 18			call break_point_state  
288d				endm  
# End of macro CALLMONITOR
288d					endif 
288d c3 5a 28				jp .getbyteat 
2890					NEXTW 
2890 c3 14 23			jp macro_next 
2893				endm 
# End of macro NEXTW
2893			.BANG: 
2893				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2893 21				db WORD_SYS_CORE+OPCODE_BANG             
2894 c9 28			dw .CBANG            
2896 02				db 1 + 1 
2897 .. 00			db "!",0              
2899				endm 
# End of macro CWHEAD
2899			; | ! ( x w -- ) Store x at address w      | DONE 
2899					if DEBUG_FORTH_WORDS_KEY 
2899						DMARK "BNG" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 6e fe			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 6f fe			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 70 fe			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "BNG"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2						CALLMONITOR 
28b2 cd f3 18			call break_point_state  
28b5				endm  
# End of macro CALLMONITOR
28b5					endif 
28b5			 
28b5			.storebyteat:		 
28b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b5 cd 5e 21			call macro_dsp_valuehl 
28b8				endm 
# End of macro FORTH_DSP_VALUEHL
28b8					 
28b8 e5					push hl 
28b9				 
28b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b9 cd 16 22			call macro_forth_dsp_pop 
28bc				endm 
# End of macro FORTH_DSP_POP
28bc			 
28bc					; get byte to poke 
28bc			 
28bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28bc cd 5e 21			call macro_dsp_valuehl 
28bf				endm 
# End of macro FORTH_DSP_VALUEHL
28bf e5					push hl 
28c0			 
28c0			 
28c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28c0 cd 16 22			call macro_forth_dsp_pop 
28c3				endm 
# End of macro FORTH_DSP_POP
28c3			 
28c3			 
28c3 d1					pop de 
28c4 e1					pop hl 
28c5			 
28c5 73					ld (hl),e 
28c6			 
28c6			 
28c6					NEXTW 
28c6 c3 14 23			jp macro_next 
28c9				endm 
# End of macro NEXTW
28c9			.CBANG: 
28c9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
28c9 22				db WORD_SYS_CORE+OPCODE_CBANG             
28ca f2 28			dw .SCALL            
28cc 03				db 2 + 1 
28cd .. 00			db "C!",0              
28d0				endm 
# End of macro CWHEAD
28d0			; | C!  ( x w -- ) Store x at address w  | DONE 
28d0					if DEBUG_FORTH_WORDS_KEY 
28d0						DMARK "CBA" 
28d0 f5				push af  
28d1 3a e5 28			ld a, (.dmark)  
28d4 32 6e fe			ld (debug_mark),a  
28d7 3a e6 28			ld a, (.dmark+1)  
28da 32 6f fe			ld (debug_mark+1),a  
28dd 3a e7 28			ld a, (.dmark+2)  
28e0 32 70 fe			ld (debug_mark+2),a  
28e3 18 03			jr .pastdmark  
28e5 ..			.dmark: db "CBA"  
28e8 f1			.pastdmark: pop af  
28e9			endm  
# End of macro DMARK
28e9						CALLMONITOR 
28e9 cd f3 18			call break_point_state  
28ec				endm  
# End of macro CALLMONITOR
28ec					endif 
28ec c3 b5 28				jp .storebyteat 
28ef					NEXTW 
28ef c3 14 23			jp macro_next 
28f2				endm 
# End of macro NEXTW
28f2			.SCALL: 
28f2				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28f2 23				db WORD_SYS_CORE+OPCODE_SCALL             
28f3 26 29			dw .DEPTH            
28f5 05				db 4 + 1 
28f6 .. 00			db "CALL",0              
28fb				endm 
# End of macro CWHEAD
28fb			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28fb					if DEBUG_FORTH_WORDS_KEY 
28fb						DMARK "CLL" 
28fb f5				push af  
28fc 3a 10 29			ld a, (.dmark)  
28ff 32 6e fe			ld (debug_mark),a  
2902 3a 11 29			ld a, (.dmark+1)  
2905 32 6f fe			ld (debug_mark+1),a  
2908 3a 12 29			ld a, (.dmark+2)  
290b 32 70 fe			ld (debug_mark+2),a  
290e 18 03			jr .pastdmark  
2910 ..			.dmark: db "CLL"  
2913 f1			.pastdmark: pop af  
2914			endm  
# End of macro DMARK
2914						CALLMONITOR 
2914 cd f3 18			call break_point_state  
2917				endm  
# End of macro CALLMONITOR
2917					endif 
2917			 
2917					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2917 cd 5e 21			call macro_dsp_valuehl 
291a				endm 
# End of macro FORTH_DSP_VALUEHL
291a			 
291a			;		push hl 
291a			 
291a					; destroy value TOS 
291a			 
291a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291a cd 16 22			call macro_forth_dsp_pop 
291d				endm 
# End of macro FORTH_DSP_POP
291d			 
291d						 
291d			;		pop hl 
291d			 
291d					; how to do a call with hl???? save SP? 
291d cd b8 22				call forth_call_hl 
2920			 
2920			 
2920					; TODO push value back onto stack for another op etc 
2920			 
2920 cd 67 1f				call forth_push_numhl 
2923					NEXTW 
2923 c3 14 23			jp macro_next 
2926				endm 
# End of macro NEXTW
2926			.DEPTH: 
2926				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2926 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2927 63 29			dw .OVER            
2929 06				db 5 + 1 
292a .. 00			db "DEPTH",0              
2930				endm 
# End of macro CWHEAD
2930			; | DEPTH ( -- u ) Push count of stack | DONE 
2930					; take current TOS and remove from base value div by two to get count 
2930					if DEBUG_FORTH_WORDS_KEY 
2930						DMARK "DEP" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 6e fe			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 6f fe			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 70 fe			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "DEP"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949						CALLMONITOR 
2949 cd f3 18			call break_point_state  
294c				endm  
# End of macro CALLMONITOR
294c					endif 
294c			 
294c			 
294c 2a f5 f9			ld hl, (cli_data_sp) 
294f 11 2f f7			ld de, cli_data_stack 
2952 ed 52			sbc hl,de 
2954				 
2954				; div by size of stack item 
2954			 
2954 5d				ld e,l 
2955 0e 03			ld c, 3 
2957 cd dc 0e			call Div8 
295a			 
295a 6f				ld l,a 
295b 26 00			ld h,0 
295d			 
295d				;srl h 
295d				;rr l 
295d			 
295d cd 67 1f				call forth_push_numhl 
2960					NEXTW 
2960 c3 14 23			jp macro_next 
2963				endm 
# End of macro NEXTW
2963			.OVER: 
2963				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2963 42				db WORD_SYS_CORE+46             
2964 aa 29			dw .PAUSE            
2966 05				db 4 + 1 
2967 .. 00			db "OVER",0              
296c				endm 
# End of macro CWHEAD
296c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
296c					if DEBUG_FORTH_WORDS_KEY 
296c						DMARK "OVR" 
296c f5				push af  
296d 3a 81 29			ld a, (.dmark)  
2970 32 6e fe			ld (debug_mark),a  
2973 3a 82 29			ld a, (.dmark+1)  
2976 32 6f fe			ld (debug_mark+1),a  
2979 3a 83 29			ld a, (.dmark+2)  
297c 32 70 fe			ld (debug_mark+2),a  
297f 18 03			jr .pastdmark  
2981 ..			.dmark: db "OVR"  
2984 f1			.pastdmark: pop af  
2985			endm  
# End of macro DMARK
2985						CALLMONITOR 
2985 cd f3 18			call break_point_state  
2988				endm  
# End of macro CALLMONITOR
2988					endif 
2988			 
2988					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2988 cd 5e 21			call macro_dsp_valuehl 
298b				endm 
# End of macro FORTH_DSP_VALUEHL
298b e5					push hl    ; n2 
298c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298c cd 16 22			call macro_forth_dsp_pop 
298f				endm 
# End of macro FORTH_DSP_POP
298f			 
298f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
298f cd 5e 21			call macro_dsp_valuehl 
2992				endm 
# End of macro FORTH_DSP_VALUEHL
2992 e5					push hl    ; n1 
2993					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2993 cd 16 22			call macro_forth_dsp_pop 
2996				endm 
# End of macro FORTH_DSP_POP
2996			 
2996 d1					pop de     ; n1 
2997 e1					pop hl     ; n2 
2998			 
2998 d5					push de 
2999 e5					push hl 
299a d5					push de 
299b			 
299b					; push back  
299b			 
299b e1					pop hl 
299c cd 67 1f				call forth_push_numhl 
299f e1					pop hl 
29a0 cd 67 1f				call forth_push_numhl 
29a3 e1					pop hl 
29a4 cd 67 1f				call forth_push_numhl 
29a7					NEXTW 
29a7 c3 14 23			jp macro_next 
29aa				endm 
# End of macro NEXTW
29aa			 
29aa			.PAUSE: 
29aa				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
29aa 43				db WORD_SYS_CORE+47             
29ab df 29			dw .PAUSES            
29ad 08				db 7 + 1 
29ae .. 00			db "PAUSEMS",0              
29b6				endm 
# End of macro CWHEAD
29b6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
29b6					if DEBUG_FORTH_WORDS_KEY 
29b6						DMARK "PMS" 
29b6 f5				push af  
29b7 3a cb 29			ld a, (.dmark)  
29ba 32 6e fe			ld (debug_mark),a  
29bd 3a cc 29			ld a, (.dmark+1)  
29c0 32 6f fe			ld (debug_mark+1),a  
29c3 3a cd 29			ld a, (.dmark+2)  
29c6 32 70 fe			ld (debug_mark+2),a  
29c9 18 03			jr .pastdmark  
29cb ..			.dmark: db "PMS"  
29ce f1			.pastdmark: pop af  
29cf			endm  
# End of macro DMARK
29cf						CALLMONITOR 
29cf cd f3 18			call break_point_state  
29d2				endm  
# End of macro CALLMONITOR
29d2					endif 
29d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d2 cd 5e 21			call macro_dsp_valuehl 
29d5				endm 
# End of macro FORTH_DSP_VALUEHL
29d5			;		push hl    ; n2 
29d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d5 cd 16 22			call macro_forth_dsp_pop 
29d8				endm 
# End of macro FORTH_DSP_POP
29d8			;		pop hl 
29d8			 
29d8 7d					ld a, l 
29d9 cd 7a 0c				call aDelayInMS 
29dc				       NEXTW 
29dc c3 14 23			jp macro_next 
29df				endm 
# End of macro NEXTW
29df			.PAUSES:  
29df				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29df 44				db WORD_SYS_CORE+48             
29e0 4e 2a			dw .ROT            
29e2 06				db 5 + 1 
29e3 .. 00			db "PAUSE",0              
29e9				endm 
# End of macro CWHEAD
29e9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29e9					if DEBUG_FORTH_WORDS_KEY 
29e9						DMARK "PAU" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 6e fe			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 6f fe			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 70 fe			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "PAU"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02						CALLMONITOR 
2a02 cd f3 18			call break_point_state  
2a05				endm  
# End of macro CALLMONITOR
2a05					endif 
2a05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a05 cd 5e 21			call macro_dsp_valuehl 
2a08				endm 
# End of macro FORTH_DSP_VALUEHL
2a08			;		push hl    ; n2 
2a08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a08 cd 16 22			call macro_forth_dsp_pop 
2a0b				endm 
# End of macro FORTH_DSP_POP
2a0b			;		pop hl 
2a0b 45					ld b, l 
2a0c					if DEBUG_FORTH_WORDS 
2a0c						DMARK "PAU" 
2a0c f5				push af  
2a0d 3a 21 2a			ld a, (.dmark)  
2a10 32 6e fe			ld (debug_mark),a  
2a13 3a 22 2a			ld a, (.dmark+1)  
2a16 32 6f fe			ld (debug_mark+1),a  
2a19 3a 23 2a			ld a, (.dmark+2)  
2a1c 32 70 fe			ld (debug_mark+2),a  
2a1f 18 03			jr .pastdmark  
2a21 ..			.dmark: db "PAU"  
2a24 f1			.pastdmark: pop af  
2a25			endm  
# End of macro DMARK
2a25						CALLMONITOR 
2a25 cd f3 18			call break_point_state  
2a28				endm  
# End of macro CALLMONITOR
2a28					endif 
2a28 c5			.pauses1:	push bc 
2a29 cd 95 0c				call delay1s 
2a2c c1					pop bc 
2a2d					if DEBUG_FORTH_WORDS 
2a2d						DMARK "PA1" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 6e fe			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 6f fe			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 70 fe			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "PA1"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46						CALLMONITOR 
2a46 cd f3 18			call break_point_state  
2a49				endm  
# End of macro CALLMONITOR
2a49					endif 
2a49 10 dd				djnz .pauses1 
2a4b			 
2a4b				       NEXTW 
2a4b c3 14 23			jp macro_next 
2a4e				endm 
# End of macro NEXTW
2a4e			.ROT: 
2a4e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a4e 45				db WORD_SYS_CORE+49             
2a4f 9c 2a			dw .UWORDS            
2a51 04				db 3 + 1 
2a52 .. 00			db "ROT",0              
2a56				endm 
# End of macro CWHEAD
2a56			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a56					if DEBUG_FORTH_WORDS_KEY 
2a56						DMARK "ROT" 
2a56 f5				push af  
2a57 3a 6b 2a			ld a, (.dmark)  
2a5a 32 6e fe			ld (debug_mark),a  
2a5d 3a 6c 2a			ld a, (.dmark+1)  
2a60 32 6f fe			ld (debug_mark+1),a  
2a63 3a 6d 2a			ld a, (.dmark+2)  
2a66 32 70 fe			ld (debug_mark+2),a  
2a69 18 03			jr .pastdmark  
2a6b ..			.dmark: db "ROT"  
2a6e f1			.pastdmark: pop af  
2a6f			endm  
# End of macro DMARK
2a6f						CALLMONITOR 
2a6f cd f3 18			call break_point_state  
2a72				endm  
# End of macro CALLMONITOR
2a72					endif 
2a72			 
2a72					FORTH_DSP_VALUEHL 
2a72 cd 5e 21			call macro_dsp_valuehl 
2a75				endm 
# End of macro FORTH_DSP_VALUEHL
2a75 e5					push hl    ; u3  
2a76			 
2a76					FORTH_DSP_POP 
2a76 cd 16 22			call macro_forth_dsp_pop 
2a79				endm 
# End of macro FORTH_DSP_POP
2a79			   
2a79					FORTH_DSP_VALUEHL 
2a79 cd 5e 21			call macro_dsp_valuehl 
2a7c				endm 
# End of macro FORTH_DSP_VALUEHL
2a7c e5					push hl     ; u2 
2a7d			 
2a7d					FORTH_DSP_POP 
2a7d cd 16 22			call macro_forth_dsp_pop 
2a80				endm 
# End of macro FORTH_DSP_POP
2a80			 
2a80					FORTH_DSP_VALUEHL 
2a80 cd 5e 21			call macro_dsp_valuehl 
2a83				endm 
# End of macro FORTH_DSP_VALUEHL
2a83 e5					push hl     ; u1 
2a84			 
2a84					FORTH_DSP_POP 
2a84 cd 16 22			call macro_forth_dsp_pop 
2a87				endm 
# End of macro FORTH_DSP_POP
2a87			 
2a87 c1					pop bc      ; u1 
2a88 e1					pop hl      ; u2 
2a89 d1					pop de      ; u3 
2a8a			 
2a8a			 
2a8a c5					push bc 
2a8b d5					push de 
2a8c e5					push hl 
2a8d			 
2a8d			 
2a8d e1					pop hl 
2a8e cd 67 1f				call forth_push_numhl 
2a91			 
2a91 e1					pop hl 
2a92 cd 67 1f				call forth_push_numhl 
2a95			 
2a95 e1					pop hl 
2a96 cd 67 1f				call forth_push_numhl 
2a99					 
2a99			 
2a99			 
2a99			 
2a99			 
2a99			 
2a99				       NEXTW 
2a99 c3 14 23			jp macro_next 
2a9c				endm 
# End of macro NEXTW
2a9c			 
2a9c			.UWORDS: 
2a9c				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a9c 50				db WORD_SYS_CORE+60             
2a9d 5e 2b			dw .BP            
2a9f 07				db 6 + 1 
2aa0 .. 00			db "UWORDS",0              
2aa7				endm 
# End of macro CWHEAD
2aa7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2aa7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2aa7			; | | Following the count are the individual words. 
2aa7			; | | 
2aa7			; | | e.g. UWORDS 
2aa7			; | | BOX DIRLIST 2 
2aa7			; | |  
2aa7			; | | Can be used to save the words to storage via: 
2aa7			; | | UWORDS $01 DO $01 APPEND LOOP 
2aa7				if DEBUG_FORTH_WORDS_KEY 
2aa7					DMARK "UWR" 
2aa7 f5				push af  
2aa8 3a bc 2a			ld a, (.dmark)  
2aab 32 6e fe			ld (debug_mark),a  
2aae 3a bd 2a			ld a, (.dmark+1)  
2ab1 32 6f fe			ld (debug_mark+1),a  
2ab4 3a be 2a			ld a, (.dmark+2)  
2ab7 32 70 fe			ld (debug_mark+2),a  
2aba 18 03			jr .pastdmark  
2abc ..			.dmark: db "UWR"  
2abf f1			.pastdmark: pop af  
2ac0			endm  
# End of macro DMARK
2ac0					CALLMONITOR 
2ac0 cd f3 18			call break_point_state  
2ac3				endm  
# End of macro CALLMONITOR
2ac3				endif 
2ac3 21 00 80				ld hl, baseram 
2ac6					;ld hl, baseusermem 
2ac6 01 00 00				ld bc, 0    ; start a counter 
2ac9			 
2ac9				; skip dict stub 
2ac9			 
2ac9 cd 65 24				call forth_tok_next 
2acc			 
2acc			 
2acc			; while we have words to look for 
2acc			 
2acc 7e			.douscan:	ld a, (hl)      
2acd				if DEBUG_FORTH_WORDS 
2acd					DMARK "UWs" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 6e fe			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 6f fe			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 70 fe			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "UWs"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6					CALLMONITOR 
2ae6 cd f3 18			call break_point_state  
2ae9				endm  
# End of macro CALLMONITOR
2ae9				endif 
2ae9 fe 00				cp WORD_SYS_END 
2aeb 28 4d				jr z, .udone 
2aed fe 01				cp WORD_SYS_UWORD 
2aef 20 44				jr nz, .nuword 
2af1			 
2af1				if DEBUG_FORTH_WORDS 
2af1					DMARK "UWu" 
2af1 f5				push af  
2af2 3a 06 2b			ld a, (.dmark)  
2af5 32 6e fe			ld (debug_mark),a  
2af8 3a 07 2b			ld a, (.dmark+1)  
2afb 32 6f fe			ld (debug_mark+1),a  
2afe 3a 08 2b			ld a, (.dmark+2)  
2b01 32 70 fe			ld (debug_mark+2),a  
2b04 18 03			jr .pastdmark  
2b06 ..			.dmark: db "UWu"  
2b09 f1			.pastdmark: pop af  
2b0a			endm  
# End of macro DMARK
2b0a					CALLMONITOR 
2b0a cd f3 18			call break_point_state  
2b0d				endm  
# End of macro CALLMONITOR
2b0d				endif 
2b0d					; we have a uword so push its name to the stack 
2b0d			 
2b0d e5				   	push hl  ; save so we can move to next dict block 
2b0e			 
2b0e					; skip opcode 
2b0e 23					inc hl  
2b0f					; skip next ptr 
2b0f 23					inc hl  
2b10 23					inc hl 
2b11					; skip len 
2b11 23					inc hl 
2b12				if DEBUG_FORTH_WORDS 
2b12					DMARK "UWt" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 6e fe			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 6f fe			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 70 fe			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "UWt"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b					CALLMONITOR 
2b2b cd f3 18			call break_point_state  
2b2e				endm  
# End of macro CALLMONITOR
2b2e				endif 
2b2e 03					inc bc 
2b2f			 
2b2f c5					push bc 
2b30 cd d5 1f				call forth_push_str 
2b33 c1					pop bc 
2b34			 
2b34 e1					pop hl 	 
2b35			 
2b35 cd 65 24		.nuword:	call forth_tok_next 
2b38 18 92				jr .douscan  
2b3a			 
2b3a			.udone:		 ; push count of uwords found 
2b3a c5					push bc 
2b3b e1					pop hl 
2b3c			 
2b3c				if DEBUG_FORTH_WORDS 
2b3c					DMARK "UWc" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6e fe			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6f fe			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 70 fe			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "UWc"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55					CALLMONITOR 
2b55 cd f3 18			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58				endif 
2b58 cd 67 1f				call forth_push_numhl 
2b5b			 
2b5b			 
2b5b				       NEXTW 
2b5b c3 14 23			jp macro_next 
2b5e				endm 
# End of macro NEXTW
2b5e			 
2b5e			.BP: 
2b5e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b5e 54				db WORD_SYS_CORE+64             
2b5f 94 2b			dw .MONITOR            
2b61 03				db 2 + 1 
2b62 .. 00			db "BP",0              
2b65				endm 
# End of macro CWHEAD
2b65			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b65			; | | $00 Will enable the break points within specific code paths 
2b65			; | | $01 Will disable break points 
2b65			; | |  
2b65			; | | By default break points are off. Either the above can be used to enable them 
2b65			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b65			; | | and on release of the pressed key a message will be disaplayed to notify 
2b65			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b65					; get byte count 
2b65					if DEBUG_FORTH_WORDS_KEY 
2b65						DMARK "BP." 
2b65 f5				push af  
2b66 3a 7a 2b			ld a, (.dmark)  
2b69 32 6e fe			ld (debug_mark),a  
2b6c 3a 7b 2b			ld a, (.dmark+1)  
2b6f 32 6f fe			ld (debug_mark+1),a  
2b72 3a 7c 2b			ld a, (.dmark+2)  
2b75 32 70 fe			ld (debug_mark+2),a  
2b78 18 03			jr .pastdmark  
2b7a ..			.dmark: db "BP."  
2b7d f1			.pastdmark: pop af  
2b7e			endm  
# End of macro DMARK
2b7e						CALLMONITOR 
2b7e cd f3 18			call break_point_state  
2b81				endm  
# End of macro CALLMONITOR
2b81					endif 
2b81			 
2b81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b81 cd 5e 21			call macro_dsp_valuehl 
2b84				endm 
# End of macro FORTH_DSP_VALUEHL
2b84			 
2b84			;		push hl 
2b84			 
2b84					; destroy value TOS 
2b84			 
2b84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b84 cd 16 22			call macro_forth_dsp_pop 
2b87				endm 
# End of macro FORTH_DSP_POP
2b87			 
2b87			;		pop hl 
2b87			 
2b87 3e 00				ld a,0 
2b89 bd					cp l 
2b8a 28 02				jr z, .bpset 
2b8c 3e 2a				ld a, '*' 
2b8e			 
2b8e 32 b9 f1		.bpset:		ld (os_view_disable), a 
2b91			 
2b91			 
2b91					NEXTW 
2b91 c3 14 23			jp macro_next 
2b94				endm 
# End of macro NEXTW
2b94			 
2b94			 
2b94			.MONITOR: 
2b94				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b94 55				db WORD_SYS_CORE+65             
2b95 c7 2b			dw .MALLOC            
2b97 08				db 7 + 1 
2b98 .. 00			db "MONITOR",0              
2ba0				endm 
# End of macro CWHEAD
2ba0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ba0			; | | At start the current various registers will be displayed with contents. 
2ba0			; | | Top right corner will show the most recent debug marker seen. 
2ba0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ba0			; | | and the return stack pointer (RSP). 
2ba0			; | | Pressing: 
2ba0			; | |    1 - Initial screen 
2ba0			; | |    2 - Display a data dump of HL 
2ba0			; | |    3 - Display a data dump of DE 
2ba0			; | |    4 - Display a data dump of BC 
2ba0			; | |    5 - Display a data dump of HL 
2ba0			; | |    6 - Display a data dump of DSP 
2ba0			; | |    7 - Display a data dump of RSP 
2ba0			; | |    8 - Display a data dump of what is at DSP 
2ba0			; | |    9 - Display a data dump of what is at RSP 
2ba0			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ba0			; | |    * - Disable break points 
2ba0			; | |    # - Enter traditional monitor mode 
2ba0			; | | 
2ba0			; | | Monitor Mode 
2ba0			; | | ------------ 
2ba0			; | | A prompt of '>' will be shown for various commands: 
2ba0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ba0			; | |    C - Continue display a data dump from the last set address 
2ba0			; | |    M xxxx - Set start of memory edit at address xx 
2ba0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ba0			; | |    Q - Return to previous 
2ba0					if DEBUG_FORTH_WORDS_KEY 
2ba0						DMARK "MON" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 6e fe			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 6f fe			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 70 fe			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "MON"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9						CALLMONITOR 
2bb9 cd f3 18			call break_point_state  
2bbc				endm  
# End of macro CALLMONITOR
2bbc					endif 
2bbc 3e 00				ld a, 0 
2bbe 32 b9 f1				ld (os_view_disable), a 
2bc1			 
2bc1					CALLMONITOR 
2bc1 cd f3 18			call break_point_state  
2bc4				endm  
# End of macro CALLMONITOR
2bc4			 
2bc4			;	call monitor 
2bc4			 
2bc4					NEXTW 
2bc4 c3 14 23			jp macro_next 
2bc7				endm 
# End of macro NEXTW
2bc7			 
2bc7			 
2bc7			.MALLOC: 
2bc7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2bc7 56				db WORD_SYS_CORE+66             
2bc8 f0 2b			dw .MALLOC2            
2bca 06				db 5 + 1 
2bcb .. 00			db "ALLOT",0              
2bd1				endm 
# End of macro CWHEAD
2bd1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bd1					if DEBUG_FORTH_WORDS_KEY 
2bd1						DMARK "ALL" 
2bd1 f5				push af  
2bd2 3a e6 2b			ld a, (.dmark)  
2bd5 32 6e fe			ld (debug_mark),a  
2bd8 3a e7 2b			ld a, (.dmark+1)  
2bdb 32 6f fe			ld (debug_mark+1),a  
2bde 3a e8 2b			ld a, (.dmark+2)  
2be1 32 70 fe			ld (debug_mark+2),a  
2be4 18 03			jr .pastdmark  
2be6 ..			.dmark: db "ALL"  
2be9 f1			.pastdmark: pop af  
2bea			endm  
# End of macro DMARK
2bea						CALLMONITOR 
2bea cd f3 18			call break_point_state  
2bed				endm  
# End of macro CALLMONITOR
2bed					endif 
2bed c3 17 2c				jp .mallocc 
2bf0			.MALLOC2: 
2bf0				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bf0 56				db WORD_SYS_CORE+66             
2bf1 2e 2c			dw .FREE            
2bf3 07				db 6 + 1 
2bf4 .. 00			db "MALLOC",0              
2bfb				endm 
# End of macro CWHEAD
2bfb			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bfb					; get byte count 
2bfb					if DEBUG_FORTH_WORDS_KEY 
2bfb						DMARK "MAL" 
2bfb f5				push af  
2bfc 3a 10 2c			ld a, (.dmark)  
2bff 32 6e fe			ld (debug_mark),a  
2c02 3a 11 2c			ld a, (.dmark+1)  
2c05 32 6f fe			ld (debug_mark+1),a  
2c08 3a 12 2c			ld a, (.dmark+2)  
2c0b 32 70 fe			ld (debug_mark+2),a  
2c0e 18 03			jr .pastdmark  
2c10 ..			.dmark: db "MAL"  
2c13 f1			.pastdmark: pop af  
2c14			endm  
# End of macro DMARK
2c14						CALLMONITOR 
2c14 cd f3 18			call break_point_state  
2c17				endm  
# End of macro CALLMONITOR
2c17					endif 
2c17			.mallocc: 
2c17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c17 cd 5e 21			call macro_dsp_valuehl 
2c1a				endm 
# End of macro FORTH_DSP_VALUEHL
2c1a			 
2c1a			;		push hl 
2c1a			 
2c1a					; destroy value TOS 
2c1a			 
2c1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c1a cd 16 22			call macro_forth_dsp_pop 
2c1d				endm 
# End of macro FORTH_DSP_POP
2c1d			 
2c1d			;		pop hl 
2c1d cd 13 14				call malloc 
2c20				if DEBUG_FORTH_MALLOC_GUARD 
2c20 f5					push af 
2c21 cd 75 0f				call ishlzero 
2c24			;		ld a, l 
2c24			;		add h 
2c24			;		cp 0 
2c24 f1					pop af 
2c25					 
2c25 cc 65 5a				call z,malloc_error 
2c28				endif 
2c28			 
2c28 cd 67 1f				call forth_push_numhl 
2c2b					NEXTW 
2c2b c3 14 23			jp macro_next 
2c2e				endm 
# End of macro NEXTW
2c2e			 
2c2e			.FREE: 
2c2e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2c2e 57				db WORD_SYS_CORE+67             
2c2f 5f 2c			dw .LIST            
2c31 05				db 4 + 1 
2c32 .. 00			db "FREE",0              
2c37				endm 
# End of macro CWHEAD
2c37			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c37					if DEBUG_FORTH_WORDS_KEY 
2c37						DMARK "FRE" 
2c37 f5				push af  
2c38 3a 4c 2c			ld a, (.dmark)  
2c3b 32 6e fe			ld (debug_mark),a  
2c3e 3a 4d 2c			ld a, (.dmark+1)  
2c41 32 6f fe			ld (debug_mark+1),a  
2c44 3a 4e 2c			ld a, (.dmark+2)  
2c47 32 70 fe			ld (debug_mark+2),a  
2c4a 18 03			jr .pastdmark  
2c4c ..			.dmark: db "FRE"  
2c4f f1			.pastdmark: pop af  
2c50			endm  
# End of macro DMARK
2c50						CALLMONITOR 
2c50 cd f3 18			call break_point_state  
2c53				endm  
# End of macro CALLMONITOR
2c53					endif 
2c53					; get address 
2c53			 
2c53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c53 cd 5e 21			call macro_dsp_valuehl 
2c56				endm 
# End of macro FORTH_DSP_VALUEHL
2c56			 
2c56			;		push hl 
2c56			 
2c56					; destroy value TOS 
2c56			 
2c56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c56 cd 16 22			call macro_forth_dsp_pop 
2c59				endm 
# End of macro FORTH_DSP_POP
2c59			 
2c59			;		pop hl 
2c59			if FORTH_ENABLE_MALLOCFREE 
2c59 cd dd 14				call free 
2c5c			endif 
2c5c					NEXTW 
2c5c c3 14 23			jp macro_next 
2c5f				endm 
# End of macro NEXTW
2c5f			.LIST: 
2c5f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c5f 5c				db WORD_SYS_CORE+72             
2c60 4d 2e			dw .FORGET            
2c62 05				db 4 + 1 
2c63 .. 00			db "LIST",0              
2c68				endm 
# End of macro CWHEAD
2c68			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c68			; | | The quoted word must be in upper case. 
2c68				if DEBUG_FORTH_WORDS_KEY 
2c68					DMARK "LST" 
2c68 f5				push af  
2c69 3a 7d 2c			ld a, (.dmark)  
2c6c 32 6e fe			ld (debug_mark),a  
2c6f 3a 7e 2c			ld a, (.dmark+1)  
2c72 32 6f fe			ld (debug_mark+1),a  
2c75 3a 7f 2c			ld a, (.dmark+2)  
2c78 32 70 fe			ld (debug_mark+2),a  
2c7b 18 03			jr .pastdmark  
2c7d ..			.dmark: db "LST"  
2c80 f1			.pastdmark: pop af  
2c81			endm  
# End of macro DMARK
2c81					CALLMONITOR 
2c81 cd f3 18			call break_point_state  
2c84				endm  
# End of macro CALLMONITOR
2c84				endif 
2c84			 
2c84					FORTH_DSP_VALUEHL 
2c84 cd 5e 21			call macro_dsp_valuehl 
2c87				endm 
# End of macro FORTH_DSP_VALUEHL
2c87			 
2c87 e5					push hl 
2c88					FORTH_DSP_POP 
2c88 cd 16 22			call macro_forth_dsp_pop 
2c8b				endm 
# End of macro FORTH_DSP_POP
2c8b c1					pop bc 
2c8c			 
2c8c			; Start format of scratch string 
2c8c			 
2c8c 21 c8 f1				ld hl, scratch 
2c8f			 
2c8f 3e 3a				ld a, ':' 
2c91 77					ld (hl),a 
2c92 23					inc hl 
2c93 3e 20				ld a, ' ' 
2c95 77					ld (hl), a 
2c96			 
2c96					; Get ptr to the word we need to look up 
2c96			 
2c96			;		FORTH_DSP_VALUEHL 
2c96					;v5 FORTH_DSP_VALUE 
2c96				; TODO type check 
2c96			;		inc hl    ; Skip type check  
2c96			;		push hl 
2c96			;		ex de, hl    ; put into DE 
2c96			 
2c96			 
2c96 21 00 80				ld hl, baseram 
2c99					;ld hl, baseusermem 
2c99			 
2c99 e5			push hl   ; sacreifical push 
2c9a			 
2c9a			.ldouscanm: 
2c9a e1				pop hl 
2c9b			.ldouscan: 
2c9b				if DEBUG_FORTH_WORDS 
2c9b					DMARK "LSs" 
2c9b f5				push af  
2c9c 3a b0 2c			ld a, (.dmark)  
2c9f 32 6e fe			ld (debug_mark),a  
2ca2 3a b1 2c			ld a, (.dmark+1)  
2ca5 32 6f fe			ld (debug_mark+1),a  
2ca8 3a b2 2c			ld a, (.dmark+2)  
2cab 32 70 fe			ld (debug_mark+2),a  
2cae 18 03			jr .pastdmark  
2cb0 ..			.dmark: db "LSs"  
2cb3 f1			.pastdmark: pop af  
2cb4			endm  
# End of macro DMARK
2cb4					CALLMONITOR 
2cb4 cd f3 18			call break_point_state  
2cb7				endm  
# End of macro CALLMONITOR
2cb7				endif 
2cb7				; skip dict stub 
2cb7 cd 65 24				call forth_tok_next 
2cba			 
2cba			 
2cba			; while we have words to look for 
2cba			 
2cba 7e				ld a, (hl)      
2cbb				if DEBUG_FORTH_WORDS 
2cbb					DMARK "LSk" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 6e fe			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 6f fe			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 70 fe			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "LSk"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4					CALLMONITOR 
2cd4 cd f3 18			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7				endif 
2cd7					;cp WORD_SYS_END 
2cd7					;jp z, .lunotfound 
2cd7			 
2cd7					; if we hit non uwords then gone too far 
2cd7 fe 01				cp WORD_SYS_UWORD 
2cd9 c2 09 2e				jp nz, .lunotfound 
2cdc			 
2cdc				if DEBUG_FORTH_WORDS 
2cdc					DMARK "LSu" 
2cdc f5				push af  
2cdd 3a f1 2c			ld a, (.dmark)  
2ce0 32 6e fe			ld (debug_mark),a  
2ce3 3a f2 2c			ld a, (.dmark+1)  
2ce6 32 6f fe			ld (debug_mark+1),a  
2ce9 3a f3 2c			ld a, (.dmark+2)  
2cec 32 70 fe			ld (debug_mark+2),a  
2cef 18 03			jr .pastdmark  
2cf1 ..			.dmark: db "LSu"  
2cf4 f1			.pastdmark: pop af  
2cf5			endm  
# End of macro DMARK
2cf5					CALLMONITOR 
2cf5 cd f3 18			call break_point_state  
2cf8				endm  
# End of macro CALLMONITOR
2cf8				endif 
2cf8			 
2cf8					; found a uword but is it the one we want... 
2cf8			 
2cf8 c5					push bc     ; uword to find is on bc 
2cf9 d1					pop de 
2cfa			 
2cfa e5					push hl  ; to save the ptr 
2cfb			 
2cfb					; skip opcode 
2cfb 23					inc hl  
2cfc					; skip next ptr 
2cfc 23					inc hl  
2cfd 23					inc hl 
2cfe					; skip len 
2cfe 23					inc hl 
2cff			 
2cff				if DEBUG_FORTH_WORDS 
2cff					DMARK "LSc" 
2cff f5				push af  
2d00 3a 14 2d			ld a, (.dmark)  
2d03 32 6e fe			ld (debug_mark),a  
2d06 3a 15 2d			ld a, (.dmark+1)  
2d09 32 6f fe			ld (debug_mark+1),a  
2d0c 3a 16 2d			ld a, (.dmark+2)  
2d0f 32 70 fe			ld (debug_mark+2),a  
2d12 18 03			jr .pastdmark  
2d14 ..			.dmark: db "LSc"  
2d17 f1			.pastdmark: pop af  
2d18			endm  
# End of macro DMARK
2d18					CALLMONITOR 
2d18 cd f3 18			call break_point_state  
2d1b				endm  
# End of macro CALLMONITOR
2d1b				endif 
2d1b cd e2 13				call strcmp 
2d1e c2 9a 2c				jp nz, .ldouscanm 
2d21				 
2d21			 
2d21			 
2d21					; we have a uword so push its name to the stack 
2d21			 
2d21			;	   	push hl  ; save so we can move to next dict block 
2d21 e1			pop hl 
2d22			 
2d22				if DEBUG_FORTH_WORDS 
2d22					DMARK "LSm" 
2d22 f5				push af  
2d23 3a 37 2d			ld a, (.dmark)  
2d26 32 6e fe			ld (debug_mark),a  
2d29 3a 38 2d			ld a, (.dmark+1)  
2d2c 32 6f fe			ld (debug_mark+1),a  
2d2f 3a 39 2d			ld a, (.dmark+2)  
2d32 32 70 fe			ld (debug_mark+2),a  
2d35 18 03			jr .pastdmark  
2d37 ..			.dmark: db "LSm"  
2d3a f1			.pastdmark: pop af  
2d3b			endm  
# End of macro DMARK
2d3b					CALLMONITOR 
2d3b cd f3 18			call break_point_state  
2d3e				endm  
# End of macro CALLMONITOR
2d3e				endif 
2d3e			 
2d3e					; skip opcode 
2d3e 23					inc hl  
2d3f					; skip next ptr 
2d3f 23					inc hl  
2d40 23					inc hl 
2d41					; skip len 
2d41 7e					ld a, (hl)   ; save length to add 
2d42				if DEBUG_FORTH_WORDS 
2d42					DMARK "LS2" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 6e fe			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 6f fe			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 70 fe			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "LS2"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b					CALLMONITOR 
2d5b cd f3 18			call break_point_state  
2d5e				endm  
# End of macro CALLMONITOR
2d5e				endif 
2d5e			 
2d5e					; save this location 
2d5e				 
2d5e e5					push hl 
2d5f			 
2d5f 23					inc hl 
2d60 11 ca f1				ld de, scratch+2 
2d63 4f					ld c, a 
2d64 06 00				ld b, 0 
2d66			 
2d66				if DEBUG_FORTH_WORDS 
2d66					DMARK "LSn" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 6e fe			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 6f fe			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 70 fe			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "LSn"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f					CALLMONITOR 
2d7f cd f3 18			call break_point_state  
2d82				endm  
# End of macro CALLMONITOR
2d82				endif 
2d82			 
2d82					; copy uword name to scratch 
2d82			 
2d82 ed b0				ldir 
2d84			 
2d84 1b					dec de 
2d85 3e 20				ld a, ' '    ; change null to space 
2d87 12					ld (de), a 
2d88			 
2d88 13					inc de 
2d89			 
2d89 d5					push de 
2d8a c1					pop bc     ; move scratch pointer to end of word name and save it 
2d8b			 
2d8b e1					pop hl 
2d8c 7e					ld a, (hl) 
2d8d					;inc hl 
2d8d					; skip word string 
2d8d cd 4c 0f				call addatohl 
2d90			 
2d90 23					inc hl 
2d91			 
2d91				if DEBUG_FORTH_WORDS 
2d91					DMARK "LS3" 
2d91 f5				push af  
2d92 3a a6 2d			ld a, (.dmark)  
2d95 32 6e fe			ld (debug_mark),a  
2d98 3a a7 2d			ld a, (.dmark+1)  
2d9b 32 6f fe			ld (debug_mark+1),a  
2d9e 3a a8 2d			ld a, (.dmark+2)  
2da1 32 70 fe			ld (debug_mark+2),a  
2da4 18 03			jr .pastdmark  
2da6 ..			.dmark: db "LS3"  
2da9 f1			.pastdmark: pop af  
2daa			endm  
# End of macro DMARK
2daa					CALLMONITOR 
2daa cd f3 18			call break_point_state  
2dad				endm  
# End of macro CALLMONITOR
2dad				endif 
2dad					; should now be at the start of the machine code to setup the eval of the uword 
2dad					; now locate the ptr to the string defintion 
2dad			 
2dad					; skip ld hl, 
2dad					; then load the ptr 
2dad			; TODO use get from hl ptr 
2dad 23					inc hl 
2dae 5e					ld e, (hl) 
2daf 23					inc hl 
2db0 56					ld d, (hl) 
2db1 eb					ex de, hl 
2db2			 
2db2			 
2db2				if DEBUG_FORTH_WORDS 
2db2					DMARK "LSt" 
2db2 f5				push af  
2db3 3a c7 2d			ld a, (.dmark)  
2db6 32 6e fe			ld (debug_mark),a  
2db9 3a c8 2d			ld a, (.dmark+1)  
2dbc 32 6f fe			ld (debug_mark+1),a  
2dbf 3a c9 2d			ld a, (.dmark+2)  
2dc2 32 70 fe			ld (debug_mark+2),a  
2dc5 18 03			jr .pastdmark  
2dc7 ..			.dmark: db "LSt"  
2dca f1			.pastdmark: pop af  
2dcb			endm  
# End of macro DMARK
2dcb					CALLMONITOR 
2dcb cd f3 18			call break_point_state  
2dce				endm  
# End of macro CALLMONITOR
2dce				endif 
2dce			 
2dce			; cant push right now due to tokenised strings  
2dce			 
2dce			; get the destination of where to copy this definition to. 
2dce			 
2dce c5					push bc 
2dcf d1					pop de 
2dd0			 
2dd0 7e			.listl:         ld a,(hl) 
2dd1 fe 00				cp 0 
2dd3 28 09				jr z, .lreplsp     ; replace zero with space 
2dd5					;cp FORTH_END_BUFFER 
2dd5 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2dd7 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2dd9				 
2dd9					; just copy this char as is then 
2dd9			 
2dd9 12					ld (de), a 
2dda			 
2dda 23			.listnxt:	inc hl 
2ddb 13					inc de 
2ddc 18 f2				jr .listl 
2dde			 
2dde 3e 20		.lreplsp:	ld a,' ' 
2de0 12					ld (de), a 
2de1 18 f7				jr .listnxt 
2de3			 
2de3			; close up uword def 
2de3			 
2de3			.listdone: 
2de3 12					ld (de), a 
2de4 13					inc de 
2de5 3e 00				ld a, 0 
2de7 12					ld (de), a 
2de8			 
2de8			; now have def so clean up and push to stack 
2de8			 
2de8 21 c8 f1				ld hl, scratch 
2deb				if DEBUG_FORTH_WORDS 
2deb					DMARK "Ltp" 
2deb f5				push af  
2dec 3a 00 2e			ld a, (.dmark)  
2def 32 6e fe			ld (debug_mark),a  
2df2 3a 01 2e			ld a, (.dmark+1)  
2df5 32 6f fe			ld (debug_mark+1),a  
2df8 3a 02 2e			ld a, (.dmark+2)  
2dfb 32 70 fe			ld (debug_mark+2),a  
2dfe 18 03			jr .pastdmark  
2e00 ..			.dmark: db "Ltp"  
2e03 f1			.pastdmark: pop af  
2e04			endm  
# End of macro DMARK
2e04					CALLMONITOR 
2e04 cd f3 18			call break_point_state  
2e07				endm  
# End of macro CALLMONITOR
2e07				endif 
2e07			 
2e07 18 1f			jr .listpush 
2e09			 
2e09			;.lnuword:	pop hl 
2e09			;		call forth_tok_next 
2e09			;		jp .ldouscan  
2e09			 
2e09			.lunotfound:		  
2e09			 
2e09				if DEBUG_FORTH_WORDS 
2e09					DMARK "LSn" 
2e09 f5				push af  
2e0a 3a 1e 2e			ld a, (.dmark)  
2e0d 32 6e fe			ld (debug_mark),a  
2e10 3a 1f 2e			ld a, (.dmark+1)  
2e13 32 6f fe			ld (debug_mark+1),a  
2e16 3a 20 2e			ld a, (.dmark+2)  
2e19 32 70 fe			ld (debug_mark+2),a  
2e1c 18 03			jr .pastdmark  
2e1e ..			.dmark: db "LSn"  
2e21 f1			.pastdmark: pop af  
2e22			endm  
# End of macro DMARK
2e22					CALLMONITOR 
2e22 cd f3 18			call break_point_state  
2e25				endm  
# End of macro CALLMONITOR
2e25				endif 
2e25			 
2e25					 
2e25			;		FORTH_DSP_POP 
2e25			;		ld hl, .luno 
2e25			 
2e25					NEXTW			 
2e25 c3 14 23			jp macro_next 
2e28				endm 
# End of macro NEXTW
2e28			 
2e28			.listpush: 
2e28				if DEBUG_FORTH_WORDS 
2e28					DMARK "LS>" 
2e28 f5				push af  
2e29 3a 3d 2e			ld a, (.dmark)  
2e2c 32 6e fe			ld (debug_mark),a  
2e2f 3a 3e 2e			ld a, (.dmark+1)  
2e32 32 6f fe			ld (debug_mark+1),a  
2e35 3a 3f 2e			ld a, (.dmark+2)  
2e38 32 70 fe			ld (debug_mark+2),a  
2e3b 18 03			jr .pastdmark  
2e3d ..			.dmark: db "LS>"  
2e40 f1			.pastdmark: pop af  
2e41			endm  
# End of macro DMARK
2e41					CALLMONITOR 
2e41 cd f3 18			call break_point_state  
2e44				endm  
# End of macro CALLMONITOR
2e44				endif 
2e44 cd d5 1f				call forth_push_str 
2e47			 
2e47			 
2e47			 
2e47					NEXTW 
2e47 c3 14 23			jp macro_next 
2e4a				endm 
# End of macro NEXTW
2e4a			 
2e4a			;.luno:    db "Word not found",0 
2e4a			 
2e4a			 
2e4a			 
2e4a			 
2e4a			 
2e4a			;		push hl   ; save pointer to start of uword def string 
2e4a			; 
2e4a			;; look for FORTH_EOL_LINE 
2e4a			;		ld a, FORTH_END_BUFFER 
2e4a			;		call strlent 
2e4a			; 
2e4a			;		inc hl		 ; space for coln def 
2e4a			;		inc hl 
2e4a			;		inc hl          ; space for terms 
2e4a			;		inc hl 
2e4a			; 
2e4a			;		ld a, 20   ; TODO get actual length 
2e4a			;		call addatohl    ; include a random amount of room for the uword name 
2e4a			; 
2e4a			;		 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt1" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		 
2e4a			; 
2e4a			;; malloc space for the string because we cant change it 
2e4a			; 
2e4a			;		call malloc 
2e4a			;	if DEBUG_FORTH_MALLOC_GUARD 
2e4a			;		push af 
2e4a			;		call ishlzero 
2e4a			;		pop af 
2e4a			;		 
2e4a			;		call z,malloc_error 
2e4a			;	endif 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt2" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		pop de 
2e4a			;		push hl    ; push the malloc to release later 
2e4a			;		push hl   ;  push back a copy for the later stack push 
2e4a			;		 
2e4a			;; copy the string swapping out the zero terms for spaces 
2e4a			; 
2e4a			;		; de has our source 
2e4a			;		; hl has our dest 
2e4a			; 
2e4a			;; add the coln def 
2e4a			; 
2e4a			;		ld a, ':' 
2e4a			;		ld (hl), a 
2e4a			;		inc hl 
2e4a			;		ld a, ' ' 
2e4a			;		ld (hl), a 
2e4a			;		inc hl 
2e4a			; 
2e4a			;; add the uname word 
2e4a			;		push de   ; save our string for now 
2e4a			;		ex de, hl 
2e4a			; 
2e4a			;		FORTH_DSP_VALUE 
2e4a			;		;v5 FORTH_DSP_VALUE 
2e4a			; 
2e4a			;		inc hl   ; skip type but we know by now this is OK 
2e4a			; 
2e4a			;.luword:	ld a,(hl) 
2e4a			;		cp 0 
2e4a			;		jr z, .luword2 
2e4a			;		ld (de), a 
2e4a			;		inc de 
2e4a			;		inc hl 
2e4a			;		jr .luword 
2e4a			; 
2e4a			;.luword2:	ld a, ' ' 
2e4a			;		ld (de), a 
2e4a			;;		inc hl 
2e4a			;;		inc de 
2e4a			;;		ld (de), a 
2e4a			;;		inc hl 
2e4a			;		inc de 
2e4a			; 
2e4a			;		ex de, hl 
2e4a			;		pop de 
2e4a			;		 
2e4a			;		 
2e4a			; 
2e4a			;; detoken that string and copy it 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt2" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;.ldetok:	ld a, (de) 
2e4a			;		cp FORTH_END_BUFFER 
2e4a			;		jr z, .ldetokend 
2e4a			;		; swap out any zero term for space 
2e4a			;		cp 0 
2e4a			;		jr nz, .ldetoknext 
2e4a			;		ld a, ' ' 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "LtS" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;.ldetoknext:	ld (hl), a 
2e4a			;		inc de 
2e4a			;		inc hl 
2e4a			;		jr .ldetok 
2e4a			; 
2e4a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e4a			;		ld (hl), a  
2e4a			; 
2e4a			;; free that temp malloc 
2e4a			; 
2e4a			;		pop hl    
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt4" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		call forth_apushstrhl 
2e4a			; 
2e4a			;		; get rid of temp malloc area 
2e4a			; 
2e4a			;		pop hl 
2e4a			;		call free 
2e4a			; 
2e4a			;		jr .ludone 
2e4a			; 
2e4a			;.lnuword:	pop hl 
2e4a			;		call forth_tok_next 
2e4a			;		jp .ldouscan  
2e4a			; 
2e4a			;.ludone:		 pop hl 
2e4a			; 
2e4a					NEXTW 
2e4a c3 14 23			jp macro_next 
2e4d				endm 
# End of macro NEXTW
2e4d			 
2e4d			.FORGET: 
2e4d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e4d 5d				db WORD_SYS_CORE+73             
2e4e c6 2e			dw .NOP            
2e50 07				db 6 + 1 
2e51 .. 00			db "FORGET",0              
2e58				endm 
# End of macro CWHEAD
2e58			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e58			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e58			; | |  
2e58			; | | e.g. "MORE" forget 
2e58					if DEBUG_FORTH_WORDS_KEY 
2e58						DMARK "FRG" 
2e58 f5				push af  
2e59 3a 6d 2e			ld a, (.dmark)  
2e5c 32 6e fe			ld (debug_mark),a  
2e5f 3a 6e 2e			ld a, (.dmark+1)  
2e62 32 6f fe			ld (debug_mark+1),a  
2e65 3a 6f 2e			ld a, (.dmark+2)  
2e68 32 70 fe			ld (debug_mark+2),a  
2e6b 18 03			jr .pastdmark  
2e6d ..			.dmark: db "FRG"  
2e70 f1			.pastdmark: pop af  
2e71			endm  
# End of macro DMARK
2e71						CALLMONITOR 
2e71 cd f3 18			call break_point_state  
2e74				endm  
# End of macro CALLMONITOR
2e74					endif 
2e74			 
2e74				; find uword 
2e74			        ; update start of word with "_" 
2e74				; replace uword with deleted flag 
2e74			 
2e74			 
2e74			;	if DEBUG_FORTH_WORDS 
2e74			;		DMARK "FOG" 
2e74			;		CALLMONITOR 
2e74			;	endif 
2e74			 
2e74			 
2e74					; Get ptr to the word we need to look up 
2e74			 
2e74					FORTH_DSP_VALUEHL 
2e74 cd 5e 21			call macro_dsp_valuehl 
2e77				endm 
# End of macro FORTH_DSP_VALUEHL
2e77					;v5 FORTH_DSP_VALUE 
2e77				; TODO type check 
2e77			;		inc hl    ; Skip type check  
2e77 e5					push hl 
2e78 c1					pop bc 
2e79			;		ex de, hl    ; put into DE 
2e79			 
2e79			 
2e79 21 00 80				ld hl, baseram 
2e7c					;ld hl, baseusermem 
2e7c			 
2e7c				; skip dict stub 
2e7c			;	call forth_tok_next 
2e7c e5			push hl   ; sacreifical push 
2e7d			 
2e7d			.fldouscanm: 
2e7d e1				pop hl 
2e7e			.fldouscan: 
2e7e			;	if DEBUG_FORTH_WORDS 
2e7e			;		DMARK "LSs" 
2e7e			;		CALLMONITOR 
2e7e			;	endif 
2e7e				; skip dict stub 
2e7e cd 65 24				call forth_tok_next 
2e81			 
2e81			 
2e81			; while we have words to look for 
2e81			 
2e81 7e				ld a, (hl)      
2e82			;	if DEBUG_FORTH_WORDS 
2e82			;		DMARK "LSk" 
2e82			;		CALLMONITOR 
2e82			;	endif 
2e82 fe 00				cp WORD_SYS_END 
2e84 ca c0 2e				jp z, .flunotfound 
2e87 fe 01				cp WORD_SYS_UWORD 
2e89 c2 7e 2e				jp nz, .fldouscan 
2e8c			 
2e8c			;	if DEBUG_FORTH_WORDS 
2e8c			;		DMARK "LSu" 
2e8c			;		CALLMONITOR 
2e8c			;	endif 
2e8c			 
2e8c					; found a uword but is it the one we want... 
2e8c			 
2e8c c5					push bc     ; uword to find is on bc 
2e8d d1					pop de 
2e8e			 
2e8e e5					push hl  ; to save the ptr 
2e8f			 
2e8f					; skip opcode 
2e8f 23					inc hl  
2e90					; skip next ptr 
2e90 23					inc hl  
2e91 23					inc hl 
2e92					; skip len 
2e92 23					inc hl 
2e93			 
2e93			;	if DEBUG_FORTH_WORDS 
2e93			;		DMARK "LSc" 
2e93			;		CALLMONITOR 
2e93			;	endif 
2e93 cd e2 13				call strcmp 
2e96 c2 7d 2e				jp nz, .fldouscanm 
2e99			; 
2e99			; 
2e99			;; while we have words to look for 
2e99			; 
2e99			;.fdouscan:	ld a, (hl)      
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "LSs" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			;		cp WORD_SYS_END 
2e99			;		jp z, .fudone 
2e99			;		cp WORD_SYS_UWORD 
2e99			;		jp nz, .fnuword 
2e99			; 
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "FGu" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			; 
2e99			;		; found a uword but is it the one we want... 
2e99			; 
2e99			; 
2e99			;	        pop de   ; get back the dsp name 
2e99			;		push de 
2e99			; 
2e99			;		push hl  ; to save the ptr 
2e99			; 
2e99			;		; skip opcode 
2e99			;		inc hl  
2e99			;		; skip next ptr 
2e99			;		inc hl  
2e99			;		inc hl 
2e99			;		; skip len 
2e99			;		inc hl 
2e99			; 
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "FGc" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			;		call strcmp 
2e99			;		jp nz, .fnuword 
2e99			 
2e99			 
2e99 e1			pop hl 
2e9a			 
2e9a				 
2e9a				if DEBUG_FORTH_WORDS 
2e9a					DMARK "FGm" 
2e9a f5				push af  
2e9b 3a af 2e			ld a, (.dmark)  
2e9e 32 6e fe			ld (debug_mark),a  
2ea1 3a b0 2e			ld a, (.dmark+1)  
2ea4 32 6f fe			ld (debug_mark+1),a  
2ea7 3a b1 2e			ld a, (.dmark+2)  
2eaa 32 70 fe			ld (debug_mark+2),a  
2ead 18 03			jr .pastdmark  
2eaf ..			.dmark: db "FGm"  
2eb2 f1			.pastdmark: pop af  
2eb3			endm  
# End of macro DMARK
2eb3					CALLMONITOR 
2eb3 cd f3 18			call break_point_state  
2eb6				endm  
# End of macro CALLMONITOR
2eb6				endif 
2eb6			 
2eb6			 
2eb6			 
2eb6					; we have a uword so push its name to the stack 
2eb6			 
2eb6			;	   	push hl  ; save so we can move to next dict block 
2eb6			;pop hl 
2eb6			 
2eb6					; update opcode to deleted 
2eb6 3e 03				ld a, WORD_SYS_DELETED 
2eb8 77					ld (hl), a 
2eb9			 
2eb9 23					inc hl  
2eba					; skip next ptr 
2eba 23					inc hl  
2ebb 23					inc hl 
2ebc					; skip len 
2ebc 23					inc hl 
2ebd			 
2ebd					; TODO change parser to skip deleted words but for now mark it out 
2ebd 3e 5f				ld a, "_" 
2ebf 77					ld  (hl),a 
2ec0			 
2ec0			;		jr .fudone 
2ec0			; 
2ec0			;.fnuword:	pop hl 
2ec0			;		call forth_tok_next 
2ec0			;		jp .fdouscan  
2ec0			 
2ec0			.flunotfound:		  
2ec0			 
2ec0			 
2ec0					 
2ec0					FORTH_DSP_POP 
2ec0 cd 16 22			call macro_forth_dsp_pop 
2ec3				endm 
# End of macro FORTH_DSP_POP
2ec3			;		ld hl, .luno 
2ec3			;.fudone:		 pop hl 
2ec3					NEXTW 
2ec3 c3 14 23			jp macro_next 
2ec6				endm 
# End of macro NEXTW
2ec6			.NOP: 
2ec6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ec6 61				db WORD_SYS_CORE+77             
2ec7 ed 2e			dw .COMO            
2ec9 04				db 3 + 1 
2eca .. 00			db "NOP",0              
2ece				endm 
# End of macro CWHEAD
2ece			; | NOP (  --  ) Do nothing | DONE 
2ece					if DEBUG_FORTH_WORDS_KEY 
2ece						DMARK "NOP" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 6e fe			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 6f fe			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 70 fe			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "NOP"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7						CALLMONITOR 
2ee7 cd f3 18			call break_point_state  
2eea				endm  
# End of macro CALLMONITOR
2eea					endif 
2eea				       NEXTW 
2eea c3 14 23			jp macro_next 
2eed				endm 
# End of macro NEXTW
2eed			.COMO: 
2eed				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2eed 6e				db WORD_SYS_CORE+90             
2eee 3f 2f			dw .COMC            
2ef0 02				db 1 + 1 
2ef1 .. 00			db "(",0              
2ef3				endm 
# End of macro CWHEAD
2ef3			; | ( ( -- )  Start of comment | DONE 
2ef3			 
2ef3			 
2ef3 2a c9 f4				ld hl, ( os_tok_ptr) 
2ef6 11 3a 2f			ld de, .closepar 
2ef9					 
2ef9					if DEBUG_FORTH_WORDS 
2ef9						DMARK ").." 
2ef9 f5				push af  
2efa 3a 0e 2f			ld a, (.dmark)  
2efd 32 6e fe			ld (debug_mark),a  
2f00 3a 0f 2f			ld a, (.dmark+1)  
2f03 32 6f fe			ld (debug_mark+1),a  
2f06 3a 10 2f			ld a, (.dmark+2)  
2f09 32 70 fe			ld (debug_mark+2),a  
2f0c 18 03			jr .pastdmark  
2f0e ..			.dmark: db ").."  
2f11 f1			.pastdmark: pop af  
2f12			endm  
# End of macro DMARK
2f12						CALLMONITOR 
2f12 cd f3 18			call break_point_state  
2f15				endm  
# End of macro CALLMONITOR
2f15					endif 
2f15 cd 2f 24			call findnexttok  
2f18			 
2f18					if DEBUG_FORTH_WORDS 
2f18						DMARK "IF5" 
2f18 f5				push af  
2f19 3a 2d 2f			ld a, (.dmark)  
2f1c 32 6e fe			ld (debug_mark),a  
2f1f 3a 2e 2f			ld a, (.dmark+1)  
2f22 32 6f fe			ld (debug_mark+1),a  
2f25 3a 2f 2f			ld a, (.dmark+2)  
2f28 32 70 fe			ld (debug_mark+2),a  
2f2b 18 03			jr .pastdmark  
2f2d ..			.dmark: db "IF5"  
2f30 f1			.pastdmark: pop af  
2f31			endm  
# End of macro DMARK
2f31						CALLMONITOR 
2f31 cd f3 18			call break_point_state  
2f34				endm  
# End of macro CALLMONITOR
2f34					endif 
2f34				; replace below with ) exec using tok_ptr 
2f34 22 c9 f4			ld (os_tok_ptr), hl 
2f37 c3 a5 23			jp exec1 
2f3a			 
2f3a .. 00			.closepar:   db ")",0 
2f3c			 
2f3c				       NEXTW 
2f3c c3 14 23			jp macro_next 
2f3f				endm 
# End of macro NEXTW
2f3f			.COMC: 
2f3f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f3f 6f				db WORD_SYS_CORE+91             
2f40 48 2f			dw .SCRATCH            
2f42 02				db 1 + 1 
2f43 .. 00			db ")",0              
2f45				endm 
# End of macro CWHEAD
2f45			; | ) ( -- )  End of comment |  DONE  
2f45				       NEXTW 
2f45 c3 14 23			jp macro_next 
2f48				endm 
# End of macro NEXTW
2f48			 
2f48			.SCRATCH: 
2f48				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f48 6f				db WORD_SYS_CORE+91             
2f49 83 2f			dw .INC            
2f4b 08				db 7 + 1 
2f4c .. 00			db "SCRATCH",0              
2f54				endm 
# End of macro CWHEAD
2f54			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f54			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f54			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f54			; | |  
2f54			; | | e.g.    : score $00 scratch ; 
2f54			; | |  
2f54			; | | $00 score ! 
2f54			; | | $01 score +! 
2f54			; | |  
2f54			; | | e.g.   : varword $0a scratch ;  
2f54			; | | 
2f54			; | | $8000 varword ! 
2f54					if DEBUG_FORTH_WORDS_KEY 
2f54						DMARK "SCR" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 6e fe			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 6f fe			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 70 fe			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "SCR"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d						CALLMONITOR 
2f6d cd f3 18			call break_point_state  
2f70				endm  
# End of macro CALLMONITOR
2f70					endif 
2f70			 
2f70					FORTH_DSP_VALUEHL 
2f70 cd 5e 21			call macro_dsp_valuehl 
2f73				endm 
# End of macro FORTH_DSP_VALUEHL
2f73				 
2f73					FORTH_DSP_POP 
2f73 cd 16 22			call macro_forth_dsp_pop 
2f76				endm 
# End of macro FORTH_DSP_POP
2f76			 
2f76 7d					ld a, l 
2f77 21 ed f6				ld hl, os_var_array 
2f7a cd 4c 0f				call addatohl 
2f7d			 
2f7d cd 67 1f				call forth_push_numhl 
2f80			 
2f80				       NEXTW 
2f80 c3 14 23			jp macro_next 
2f83				endm 
# End of macro NEXTW
2f83			 
2f83			.INC: 
2f83				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f83 6f				db WORD_SYS_CORE+91             
2f84 d7 2f			dw .DEC            
2f86 03				db 2 + 1 
2f87 .. 00			db "+!",0              
2f8a				endm 
# End of macro CWHEAD
2f8a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f8a					if DEBUG_FORTH_WORDS_KEY 
2f8a						DMARK "+s_" 
2f8a f5				push af  
2f8b 3a 9f 2f			ld a, (.dmark)  
2f8e 32 6e fe			ld (debug_mark),a  
2f91 3a a0 2f			ld a, (.dmark+1)  
2f94 32 6f fe			ld (debug_mark+1),a  
2f97 3a a1 2f			ld a, (.dmark+2)  
2f9a 32 70 fe			ld (debug_mark+2),a  
2f9d 18 03			jr .pastdmark  
2f9f ..			.dmark: db "+s_"  
2fa2 f1			.pastdmark: pop af  
2fa3			endm  
# End of macro DMARK
2fa3						CALLMONITOR 
2fa3 cd f3 18			call break_point_state  
2fa6				endm  
# End of macro CALLMONITOR
2fa6					endif 
2fa6			 
2fa6					FORTH_DSP_VALUEHL 
2fa6 cd 5e 21			call macro_dsp_valuehl 
2fa9				endm 
# End of macro FORTH_DSP_VALUEHL
2fa9			 
2fa9 e5					push hl   ; save address 
2faa			 
2faa					FORTH_DSP_POP 
2faa cd 16 22			call macro_forth_dsp_pop 
2fad				endm 
# End of macro FORTH_DSP_POP
2fad			 
2fad					FORTH_DSP_VALUEHL 
2fad cd 5e 21			call macro_dsp_valuehl 
2fb0				endm 
# End of macro FORTH_DSP_VALUEHL
2fb0			 
2fb0					FORTH_DSP_POP 
2fb0 cd 16 22			call macro_forth_dsp_pop 
2fb3				endm 
# End of macro FORTH_DSP_POP
2fb3			 
2fb3					; hl contains value to add to byte at a 
2fb3				 
2fb3 eb					ex de, hl 
2fb4			 
2fb4 e1					pop hl 
2fb5			 
2fb5					if DEBUG_FORTH_WORDS 
2fb5						DMARK "INC" 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 6e fe			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 6f fe			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 70 fe			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "INC"  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd f3 18			call break_point_state  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1			 
2fd1 7e					ld a,(hl) 
2fd2 83					add e 
2fd3 77					ld (hl),a 
2fd4			 
2fd4			 
2fd4			 
2fd4				       NEXTW 
2fd4 c3 14 23			jp macro_next 
2fd7				endm 
# End of macro NEXTW
2fd7			 
2fd7			.DEC: 
2fd7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2fd7 6f				db WORD_SYS_CORE+91             
2fd8 28 30			dw .INC2            
2fda 03				db 2 + 1 
2fdb .. 00			db "-!",0              
2fde				endm 
# End of macro CWHEAD
2fde			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2fde					if DEBUG_FORTH_WORDS_KEY 
2fde						DMARK "-s_" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 6e fe			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 6f fe			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 70 fe			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "-s_"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd f3 18			call break_point_state  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa					FORTH_DSP_VALUEHL 
2ffa cd 5e 21			call macro_dsp_valuehl 
2ffd				endm 
# End of macro FORTH_DSP_VALUEHL
2ffd			 
2ffd e5					push hl   ; save address 
2ffe			 
2ffe					FORTH_DSP_POP 
2ffe cd 16 22			call macro_forth_dsp_pop 
3001				endm 
# End of macro FORTH_DSP_POP
3001			 
3001					FORTH_DSP_VALUEHL 
3001 cd 5e 21			call macro_dsp_valuehl 
3004				endm 
# End of macro FORTH_DSP_VALUEHL
3004			 
3004					; hl contains value to add to byte at a 
3004				 
3004 eb					ex de, hl 
3005			 
3005 e1					pop hl 
3006			 
3006					if DEBUG_FORTH_WORDS 
3006						DMARK "DEC" 
3006 f5				push af  
3007 3a 1b 30			ld a, (.dmark)  
300a 32 6e fe			ld (debug_mark),a  
300d 3a 1c 30			ld a, (.dmark+1)  
3010 32 6f fe			ld (debug_mark+1),a  
3013 3a 1d 30			ld a, (.dmark+2)  
3016 32 70 fe			ld (debug_mark+2),a  
3019 18 03			jr .pastdmark  
301b ..			.dmark: db "DEC"  
301e f1			.pastdmark: pop af  
301f			endm  
# End of macro DMARK
301f						CALLMONITOR 
301f cd f3 18			call break_point_state  
3022				endm  
# End of macro CALLMONITOR
3022					endif 
3022			 
3022 7e					ld a,(hl) 
3023 93					sub e 
3024 77					ld (hl),a 
3025			 
3025			 
3025			 
3025				       NEXTW 
3025 c3 14 23			jp macro_next 
3028				endm 
# End of macro NEXTW
3028			 
3028			.INC2: 
3028				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3028 6f				db WORD_SYS_CORE+91             
3029 d2 30			dw .DEC2            
302b 04				db 3 + 1 
302c .. 00			db "+2!",0              
3030				endm 
# End of macro CWHEAD
3030			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3030			 
3030					if DEBUG_FORTH_WORDS_KEY 
3030						DMARK "+2s" 
3030 f5				push af  
3031 3a 45 30			ld a, (.dmark)  
3034 32 6e fe			ld (debug_mark),a  
3037 3a 46 30			ld a, (.dmark+1)  
303a 32 6f fe			ld (debug_mark+1),a  
303d 3a 47 30			ld a, (.dmark+2)  
3040 32 70 fe			ld (debug_mark+2),a  
3043 18 03			jr .pastdmark  
3045 ..			.dmark: db "+2s"  
3048 f1			.pastdmark: pop af  
3049			endm  
# End of macro DMARK
3049						CALLMONITOR 
3049 cd f3 18			call break_point_state  
304c				endm  
# End of macro CALLMONITOR
304c					endif 
304c			 
304c					; Address 
304c			 
304c					FORTH_DSP_VALUEHL 
304c cd 5e 21			call macro_dsp_valuehl 
304f				endm 
# End of macro FORTH_DSP_VALUEHL
304f			 
304f e5					push hl    ; save address 
3050			 
3050					; load content into de 
3050			 
3050 5e					ld e,(hl) 
3051 23					inc hl 
3052 56					ld d, (hl) 
3053			 
3053					if DEBUG_FORTH_WORDS 
3053						DMARK "+2a" 
3053 f5				push af  
3054 3a 68 30			ld a, (.dmark)  
3057 32 6e fe			ld (debug_mark),a  
305a 3a 69 30			ld a, (.dmark+1)  
305d 32 6f fe			ld (debug_mark+1),a  
3060 3a 6a 30			ld a, (.dmark+2)  
3063 32 70 fe			ld (debug_mark+2),a  
3066 18 03			jr .pastdmark  
3068 ..			.dmark: db "+2a"  
306b f1			.pastdmark: pop af  
306c			endm  
# End of macro DMARK
306c						CALLMONITOR 
306c cd f3 18			call break_point_state  
306f				endm  
# End of macro CALLMONITOR
306f					endif 
306f			 
306f					FORTH_DSP_POP 
306f cd 16 22			call macro_forth_dsp_pop 
3072				endm 
# End of macro FORTH_DSP_POP
3072			 
3072					; Get value to add 
3072			 
3072					FORTH_DSP_VALUE 
3072 cd 47 21			call macro_forth_dsp_value 
3075				endm 
# End of macro FORTH_DSP_VALUE
3075			 
3075					if DEBUG_FORTH_WORDS 
3075						DMARK "+2v" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 6e fe			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 6f fe			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 70 fe			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "+2v"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd f3 18			call break_point_state  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091			 
3091 19					add hl, de 
3092			 
3092					if DEBUG_FORTH_WORDS 
3092						DMARK "+2+" 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 6e fe			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 6f fe			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 70 fe			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "+2+"  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab						CALLMONITOR 
30ab cd f3 18			call break_point_state  
30ae				endm  
# End of macro CALLMONITOR
30ae					endif 
30ae			 
30ae					; move result to de 
30ae			 
30ae eb					ex de, hl 
30af			 
30af					; Address 
30af			 
30af e1					pop hl 
30b0			 
30b0					; save it back 
30b0			 
30b0 73					ld (hl), e 
30b1 23					inc hl 
30b2 72					ld (hl), d 
30b3			 
30b3					if DEBUG_FORTH_WORDS 
30b3						DMARK "+2e" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 6e fe			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 6f fe			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 70 fe			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "+2e"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd f3 18			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf			 
30cf			 
30cf			 
30cf			 
30cf			 
30cf				       NEXTW 
30cf c3 14 23			jp macro_next 
30d2				endm 
# End of macro NEXTW
30d2			 
30d2			.DEC2: 
30d2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
30d2 6f				db WORD_SYS_CORE+91             
30d3 7e 31			dw .GET2            
30d5 04				db 3 + 1 
30d6 .. 00			db "-2!",0              
30da				endm 
# End of macro CWHEAD
30da			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30da			 
30da			 
30da					if DEBUG_FORTH_WORDS_KEY 
30da						DMARK "-2s" 
30da f5				push af  
30db 3a ef 30			ld a, (.dmark)  
30de 32 6e fe			ld (debug_mark),a  
30e1 3a f0 30			ld a, (.dmark+1)  
30e4 32 6f fe			ld (debug_mark+1),a  
30e7 3a f1 30			ld a, (.dmark+2)  
30ea 32 70 fe			ld (debug_mark+2),a  
30ed 18 03			jr .pastdmark  
30ef ..			.dmark: db "-2s"  
30f2 f1			.pastdmark: pop af  
30f3			endm  
# End of macro DMARK
30f3						CALLMONITOR 
30f3 cd f3 18			call break_point_state  
30f6				endm  
# End of macro CALLMONITOR
30f6					endif 
30f6			 
30f6					; Address 
30f6			 
30f6					FORTH_DSP_VALUEHL 
30f6 cd 5e 21			call macro_dsp_valuehl 
30f9				endm 
# End of macro FORTH_DSP_VALUEHL
30f9			 
30f9 e5					push hl    ; save address 
30fa			 
30fa					; load content into de 
30fa			 
30fa 5e					ld e,(hl) 
30fb 23					inc hl 
30fc 56					ld d, (hl) 
30fd			 
30fd					if DEBUG_FORTH_WORDS 
30fd						DMARK "-2a" 
30fd f5				push af  
30fe 3a 12 31			ld a, (.dmark)  
3101 32 6e fe			ld (debug_mark),a  
3104 3a 13 31			ld a, (.dmark+1)  
3107 32 6f fe			ld (debug_mark+1),a  
310a 3a 14 31			ld a, (.dmark+2)  
310d 32 70 fe			ld (debug_mark+2),a  
3110 18 03			jr .pastdmark  
3112 ..			.dmark: db "-2a"  
3115 f1			.pastdmark: pop af  
3116			endm  
# End of macro DMARK
3116						CALLMONITOR 
3116 cd f3 18			call break_point_state  
3119				endm  
# End of macro CALLMONITOR
3119					endif 
3119			 
3119					FORTH_DSP_POP 
3119 cd 16 22			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c			 
311c					; Get value to remove 
311c			 
311c					FORTH_DSP_VALUE 
311c cd 47 21			call macro_forth_dsp_value 
311f				endm 
# End of macro FORTH_DSP_VALUE
311f			 
311f					if DEBUG_FORTH_WORDS 
311f						DMARK "-2v" 
311f f5				push af  
3120 3a 34 31			ld a, (.dmark)  
3123 32 6e fe			ld (debug_mark),a  
3126 3a 35 31			ld a, (.dmark+1)  
3129 32 6f fe			ld (debug_mark+1),a  
312c 3a 36 31			ld a, (.dmark+2)  
312f 32 70 fe			ld (debug_mark+2),a  
3132 18 03			jr .pastdmark  
3134 ..			.dmark: db "-2v"  
3137 f1			.pastdmark: pop af  
3138			endm  
# End of macro DMARK
3138						CALLMONITOR 
3138 cd f3 18			call break_point_state  
313b				endm  
# End of macro CALLMONITOR
313b					endif 
313b			 
313b eb					ex de, hl 
313c ed 52				sbc hl, de 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e						DMARK "-2d" 
313e f5				push af  
313f 3a 53 31			ld a, (.dmark)  
3142 32 6e fe			ld (debug_mark),a  
3145 3a 54 31			ld a, (.dmark+1)  
3148 32 6f fe			ld (debug_mark+1),a  
314b 3a 55 31			ld a, (.dmark+2)  
314e 32 70 fe			ld (debug_mark+2),a  
3151 18 03			jr .pastdmark  
3153 ..			.dmark: db "-2d"  
3156 f1			.pastdmark: pop af  
3157			endm  
# End of macro DMARK
3157						CALLMONITOR 
3157 cd f3 18			call break_point_state  
315a				endm  
# End of macro CALLMONITOR
315a					endif 
315a			 
315a					; move result to de 
315a			 
315a eb					ex de, hl 
315b			 
315b					; Address 
315b			 
315b e1					pop hl 
315c			 
315c					; save it back 
315c			 
315c 73					ld (hl), e 
315d 23					inc hl 
315e 72					ld (hl), d 
315f			 
315f					if DEBUG_FORTH_WORDS 
315f						DMARK "-2e" 
315f f5				push af  
3160 3a 74 31			ld a, (.dmark)  
3163 32 6e fe			ld (debug_mark),a  
3166 3a 75 31			ld a, (.dmark+1)  
3169 32 6f fe			ld (debug_mark+1),a  
316c 3a 76 31			ld a, (.dmark+2)  
316f 32 70 fe			ld (debug_mark+2),a  
3172 18 03			jr .pastdmark  
3174 ..			.dmark: db "-2e"  
3177 f1			.pastdmark: pop af  
3178			endm  
# End of macro DMARK
3178						CALLMONITOR 
3178 cd f3 18			call break_point_state  
317b				endm  
# End of macro CALLMONITOR
317b					endif 
317b			 
317b			 
317b			 
317b			 
317b			 
317b				       NEXTW 
317b c3 14 23			jp macro_next 
317e				endm 
# End of macro NEXTW
317e			.GET2: 
317e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
317e 6f				db WORD_SYS_CORE+91             
317f ae 31			dw .BANG2            
3181 03				db 2 + 1 
3182 .. 00			db "2@",0              
3185				endm 
# End of macro CWHEAD
3185			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3185					if DEBUG_FORTH_WORDS_KEY 
3185						DMARK "2A_" 
3185 f5				push af  
3186 3a 9a 31			ld a, (.dmark)  
3189 32 6e fe			ld (debug_mark),a  
318c 3a 9b 31			ld a, (.dmark+1)  
318f 32 6f fe			ld (debug_mark+1),a  
3192 3a 9c 31			ld a, (.dmark+2)  
3195 32 70 fe			ld (debug_mark+2),a  
3198 18 03			jr .pastdmark  
319a ..			.dmark: db "2A_"  
319d f1			.pastdmark: pop af  
319e			endm  
# End of macro DMARK
319e						CALLMONITOR 
319e cd f3 18			call break_point_state  
31a1				endm  
# End of macro CALLMONITOR
31a1					endif 
31a1			 
31a1					FORTH_DSP_VALUEHL 
31a1 cd 5e 21			call macro_dsp_valuehl 
31a4				endm 
# End of macro FORTH_DSP_VALUEHL
31a4			 
31a4 5e					ld e, (hl) 
31a5 23					inc hl 
31a6 56					ld d, (hl) 
31a7			 
31a7 eb					ex de, hl 
31a8			 
31a8 cd 67 1f				call forth_push_numhl 
31ab			 
31ab				       NEXTW 
31ab c3 14 23			jp macro_next 
31ae				endm 
# End of macro NEXTW
31ae			.BANG2: 
31ae				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
31ae 6f				db WORD_SYS_CORE+91             
31af e6 31			dw .CONFIG            
31b1 03				db 2 + 1 
31b2 .. 00			db "2!",0              
31b5				endm 
# End of macro CWHEAD
31b5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
31b5					if DEBUG_FORTH_WORDS_KEY 
31b5						DMARK "2S_" 
31b5 f5				push af  
31b6 3a ca 31			ld a, (.dmark)  
31b9 32 6e fe			ld (debug_mark),a  
31bc 3a cb 31			ld a, (.dmark+1)  
31bf 32 6f fe			ld (debug_mark+1),a  
31c2 3a cc 31			ld a, (.dmark+2)  
31c5 32 70 fe			ld (debug_mark+2),a  
31c8 18 03			jr .pastdmark  
31ca ..			.dmark: db "2S_"  
31cd f1			.pastdmark: pop af  
31ce			endm  
# End of macro DMARK
31ce						CALLMONITOR 
31ce cd f3 18			call break_point_state  
31d1				endm  
# End of macro CALLMONITOR
31d1					endif 
31d1			 
31d1					FORTH_DSP_VALUEHL 
31d1 cd 5e 21			call macro_dsp_valuehl 
31d4				endm 
# End of macro FORTH_DSP_VALUEHL
31d4			 
31d4 e5					push hl   ; save address 
31d5			 
31d5			 
31d5					FORTH_DSP_POP 
31d5 cd 16 22			call macro_forth_dsp_pop 
31d8				endm 
# End of macro FORTH_DSP_POP
31d8			 
31d8					 
31d8					FORTH_DSP_VALUEHL 
31d8 cd 5e 21			call macro_dsp_valuehl 
31db				endm 
# End of macro FORTH_DSP_VALUEHL
31db			 
31db					FORTH_DSP_POP 
31db cd 16 22			call macro_forth_dsp_pop 
31de				endm 
# End of macro FORTH_DSP_POP
31de			 
31de eb					ex de, hl    ; value now in de 
31df			 
31df e1					pop hl 
31e0			 
31e0 73					ld (hl), e 
31e1			 
31e1 23					inc hl 
31e2			 
31e2 72					ld (hl), d 
31e3			 
31e3			 
31e3				       NEXTW 
31e3 c3 14 23			jp macro_next 
31e6				endm 
# End of macro NEXTW
31e6			.CONFIG: 
31e6				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31e6 6f				db WORD_SYS_CORE+91             
31e7 f7 31			dw .ENDCORE            
31e9 07				db 6 + 1 
31ea .. 00			db "CONFIG",0              
31f1				endm 
# End of macro CWHEAD
31f1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31f1			 
31f1 cd d6 15				call config 
31f4					NEXTW 
31f4 c3 14 23			jp macro_next 
31f7				endm 
# End of macro NEXTW
31f7			.ENDCORE: 
31f7			 
31f7			; eof 
31f7			 
31f7			 
# End of file forth_words_core.asm
31f7			include "forth_words_flow.asm" 
31f7			 
31f7			; | ## Program Flow Words 
31f7			 
31f7			.IF: 
31f7				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31f7 1e				db WORD_SYS_CORE+10             
31f8 ec 32			dw .THEN            
31fa 03				db 2 + 1 
31fb .. 00			db "IF",0              
31fe				endm 
# End of macro CWHEAD
31fe			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31fe			; 
31fe					if DEBUG_FORTH_WORDS_KEY 
31fe						DMARK "IF." 
31fe f5				push af  
31ff 3a 13 32			ld a, (.dmark)  
3202 32 6e fe			ld (debug_mark),a  
3205 3a 14 32			ld a, (.dmark+1)  
3208 32 6f fe			ld (debug_mark+1),a  
320b 3a 15 32			ld a, (.dmark+2)  
320e 32 70 fe			ld (debug_mark+2),a  
3211 18 03			jr .pastdmark  
3213 ..			.dmark: db "IF."  
3216 f1			.pastdmark: pop af  
3217			endm  
# End of macro DMARK
3217						CALLMONITOR 
3217 cd f3 18			call break_point_state  
321a				endm  
# End of macro CALLMONITOR
321a					endif 
321a			; eval TOS 
321a			 
321a				FORTH_DSP_VALUEHL 
321a cd 5e 21			call macro_dsp_valuehl 
321d				endm 
# End of macro FORTH_DSP_VALUEHL
321d			 
321d			;	push hl 
321d				FORTH_DSP_POP 
321d cd 16 22			call macro_forth_dsp_pop 
3220				endm 
# End of macro FORTH_DSP_POP
3220			;	pop hl 
3220			 
3220					if DEBUG_FORTH_WORDS 
3220						DMARK "IF1" 
3220 f5				push af  
3221 3a 35 32			ld a, (.dmark)  
3224 32 6e fe			ld (debug_mark),a  
3227 3a 36 32			ld a, (.dmark+1)  
322a 32 6f fe			ld (debug_mark+1),a  
322d 3a 37 32			ld a, (.dmark+2)  
3230 32 70 fe			ld (debug_mark+2),a  
3233 18 03			jr .pastdmark  
3235 ..			.dmark: db "IF1"  
3238 f1			.pastdmark: pop af  
3239			endm  
# End of macro DMARK
3239						CALLMONITOR 
3239 cd f3 18			call break_point_state  
323c				endm  
# End of macro CALLMONITOR
323c					endif 
323c b7				or a        ; clear carry flag 
323d 11 00 00			ld de, 0 
3240 eb				ex de,hl 
3241 ed 52			sbc hl, de 
3243 c2 cd 32			jp nz, .iftrue 
3246			 
3246					if DEBUG_FORTH_WORDS 
3246						DMARK "IF2" 
3246 f5				push af  
3247 3a 5b 32			ld a, (.dmark)  
324a 32 6e fe			ld (debug_mark),a  
324d 3a 5c 32			ld a, (.dmark+1)  
3250 32 6f fe			ld (debug_mark+1),a  
3253 3a 5d 32			ld a, (.dmark+2)  
3256 32 70 fe			ld (debug_mark+2),a  
3259 18 03			jr .pastdmark  
325b ..			.dmark: db "IF2"  
325e f1			.pastdmark: pop af  
325f			endm  
# End of macro DMARK
325f						CALLMONITOR 
325f cd f3 18			call break_point_state  
3262				endm  
# End of macro CALLMONITOR
3262					endif 
3262			 
3262			; if not true then skip to THEN 
3262			 
3262				; TODO get tok_ptr 
3262				; TODO consume toks until we get to THEN 
3262			 
3262 2a c9 f4			ld hl, (os_tok_ptr) 
3265					if DEBUG_FORTH_WORDS 
3265						DMARK "IF3" 
3265 f5				push af  
3266 3a 7a 32			ld a, (.dmark)  
3269 32 6e fe			ld (debug_mark),a  
326c 3a 7b 32			ld a, (.dmark+1)  
326f 32 6f fe			ld (debug_mark+1),a  
3272 3a 7c 32			ld a, (.dmark+2)  
3275 32 70 fe			ld (debug_mark+2),a  
3278 18 03			jr .pastdmark  
327a ..			.dmark: db "IF3"  
327d f1			.pastdmark: pop af  
327e			endm  
# End of macro DMARK
327e						CALLMONITOR 
327e cd f3 18			call break_point_state  
3281				endm  
# End of macro CALLMONITOR
3281						 
3281					endif 
3281 11 c8 32			ld de, .ifthen 
3284					if DEBUG_FORTH_WORDS 
3284						DMARK "IF4" 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 6e fe			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 6f fe			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 70 fe			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "IF4"  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd f3 18			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0 cd 2f 24			call findnexttok  
32a3			 
32a3					if DEBUG_FORTH_WORDS 
32a3						DMARK "IF5" 
32a3 f5				push af  
32a4 3a b8 32			ld a, (.dmark)  
32a7 32 6e fe			ld (debug_mark),a  
32aa 3a b9 32			ld a, (.dmark+1)  
32ad 32 6f fe			ld (debug_mark+1),a  
32b0 3a ba 32			ld a, (.dmark+2)  
32b3 32 70 fe			ld (debug_mark+2),a  
32b6 18 03			jr .pastdmark  
32b8 ..			.dmark: db "IF5"  
32bb f1			.pastdmark: pop af  
32bc			endm  
# End of macro DMARK
32bc						CALLMONITOR 
32bc cd f3 18			call break_point_state  
32bf				endm  
# End of macro CALLMONITOR
32bf					endif 
32bf				; TODO replace below with ; exec using tok_ptr 
32bf 22 c9 f4			ld (os_tok_ptr), hl 
32c2 c3 a5 23			jp exec1 
32c5				NEXTW 
32c5 c3 14 23			jp macro_next 
32c8				endm 
# End of macro NEXTW
32c8			 
32c8 .. 00		.ifthen:  db "THEN",0 
32cd			 
32cd			.iftrue:		 
32cd				; Exec next words normally 
32cd			 
32cd				; if true then exec following IF as normal 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "IFT" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 6e fe			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 6f fe			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 70 fe			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "IFT"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6						CALLMONITOR 
32e6 cd f3 18			call break_point_state  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9			 
32e9					NEXTW 
32e9 c3 14 23			jp macro_next 
32ec				endm 
# End of macro NEXTW
32ec			.THEN: 
32ec				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32ec 1f				db WORD_SYS_CORE+11             
32ed 14 33			dw .ELSE            
32ef 05				db 4 + 1 
32f0 .. 00			db "THEN",0              
32f5				endm 
# End of macro CWHEAD
32f5			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32f5					if DEBUG_FORTH_WORDS_KEY 
32f5						DMARK "THN" 
32f5 f5				push af  
32f6 3a 0a 33			ld a, (.dmark)  
32f9 32 6e fe			ld (debug_mark),a  
32fc 3a 0b 33			ld a, (.dmark+1)  
32ff 32 6f fe			ld (debug_mark+1),a  
3302 3a 0c 33			ld a, (.dmark+2)  
3305 32 70 fe			ld (debug_mark+2),a  
3308 18 03			jr .pastdmark  
330a ..			.dmark: db "THN"  
330d f1			.pastdmark: pop af  
330e			endm  
# End of macro DMARK
330e						CALLMONITOR 
330e cd f3 18			call break_point_state  
3311				endm  
# End of macro CALLMONITOR
3311					endif 
3311					NEXTW 
3311 c3 14 23			jp macro_next 
3314				endm 
# End of macro NEXTW
3314			.ELSE: 
3314				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3314 20				db WORD_SYS_CORE+12             
3315 3c 33			dw .DO            
3317 03				db 2 + 1 
3318 .. 00			db "ELSE",0              
331d				endm 
# End of macro CWHEAD
331d			; | ELSE ( -- ) Not supported - does nothing | TODO 
331d			 
331d					if DEBUG_FORTH_WORDS_KEY 
331d						DMARK "ELS" 
331d f5				push af  
331e 3a 32 33			ld a, (.dmark)  
3321 32 6e fe			ld (debug_mark),a  
3324 3a 33 33			ld a, (.dmark+1)  
3327 32 6f fe			ld (debug_mark+1),a  
332a 3a 34 33			ld a, (.dmark+2)  
332d 32 70 fe			ld (debug_mark+2),a  
3330 18 03			jr .pastdmark  
3332 ..			.dmark: db "ELS"  
3335 f1			.pastdmark: pop af  
3336			endm  
# End of macro DMARK
3336						CALLMONITOR 
3336 cd f3 18			call break_point_state  
3339				endm  
# End of macro CALLMONITOR
3339					endif 
3339			 
3339			 
3339					NEXTW 
3339 c3 14 23			jp macro_next 
333c				endm 
# End of macro NEXTW
333c			.DO: 
333c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
333c 21				db WORD_SYS_CORE+13             
333d 63 34			dw .LOOP            
333f 03				db 2 + 1 
3340 .. 00			db "DO",0              
3343				endm 
# End of macro CWHEAD
3343			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3343			 
3343					if DEBUG_FORTH_WORDS_KEY 
3343						DMARK "DO." 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 6e fe			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 6f fe			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 70 fe			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "DO."  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c						CALLMONITOR 
335c cd f3 18			call break_point_state  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f			;  push pc to rsp stack past the DO 
335f			 
335f 2a c9 f4				ld hl, (os_tok_ptr) 
3362 23					inc hl   ; D 
3363 23					inc hl  ; O 
3364 23					inc hl   ; null 
3365					if DEBUG_FORTH_WORDS 
3365						DMARK "DO2" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 6e fe			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 6f fe			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 70 fe			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "DO2"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd f3 18			call break_point_state  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381					FORTH_RSP_NEXT 
3381 cd 0e 1f			call macro_forth_rsp_next 
3384				endm 
# End of macro FORTH_RSP_NEXT
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "DO3" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 6e fe			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 6f fe			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 70 fe			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "DO3"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd f3 18			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0			 
33a0					;if DEBUG_FORTH_WORDS 
33a0				;		push hl 
33a0			;		endif  
33a0			 
33a0			; get counters from data stack 
33a0			 
33a0			 
33a0					FORTH_DSP_VALUEHL 
33a0 cd 5e 21			call macro_dsp_valuehl 
33a3				endm 
# End of macro FORTH_DSP_VALUEHL
33a3 e5					push hl		 ; hl now has starting counter which needs to be tos 
33a4			 
33a4					if DEBUG_FORTH_WORDS 
33a4						DMARK "DO4" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 6e fe			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 6f fe			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 70 fe			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "DO4"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd						CALLMONITOR 
33bd cd f3 18			call break_point_state  
33c0				endm  
# End of macro CALLMONITOR
33c0					endif 
33c0					FORTH_DSP_POP 
33c0 cd 16 22			call macro_forth_dsp_pop 
33c3				endm 
# End of macro FORTH_DSP_POP
33c3			 
33c3					if DEBUG_FORTH_WORDS 
33c3						DMARK "DO5" 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 6e fe			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 6f fe			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 70 fe			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "DO5"  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd f3 18			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df			 
33df					FORTH_DSP_VALUEHL 
33df cd 5e 21			call macro_dsp_valuehl 
33e2				endm 
# End of macro FORTH_DSP_VALUEHL
33e2			;		push hl		 ; hl now has starting limit counter 
33e2			 
33e2					if DEBUG_FORTH_WORDS 
33e2						DMARK "DO6" 
33e2 f5				push af  
33e3 3a f7 33			ld a, (.dmark)  
33e6 32 6e fe			ld (debug_mark),a  
33e9 3a f8 33			ld a, (.dmark+1)  
33ec 32 6f fe			ld (debug_mark+1),a  
33ef 3a f9 33			ld a, (.dmark+2)  
33f2 32 70 fe			ld (debug_mark+2),a  
33f5 18 03			jr .pastdmark  
33f7 ..			.dmark: db "DO6"  
33fa f1			.pastdmark: pop af  
33fb			endm  
# End of macro DMARK
33fb						CALLMONITOR 
33fb cd f3 18			call break_point_state  
33fe				endm  
# End of macro CALLMONITOR
33fe					endif 
33fe					FORTH_DSP_POP 
33fe cd 16 22			call macro_forth_dsp_pop 
3401				endm 
# End of macro FORTH_DSP_POP
3401			 
3401			; put counters on the loop stack 
3401			 
3401			;		pop hl			 ; limit counter 
3401 d1					pop de			; start counter 
3402			 
3402					; push limit counter 
3402			 
3402					if DEBUG_FORTH_WORDS 
3402						DMARK "DO7" 
3402 f5				push af  
3403 3a 17 34			ld a, (.dmark)  
3406 32 6e fe			ld (debug_mark),a  
3409 3a 18 34			ld a, (.dmark+1)  
340c 32 6f fe			ld (debug_mark+1),a  
340f 3a 19 34			ld a, (.dmark+2)  
3412 32 70 fe			ld (debug_mark+2),a  
3415 18 03			jr .pastdmark  
3417 ..			.dmark: db "DO7"  
341a f1			.pastdmark: pop af  
341b			endm  
# End of macro DMARK
341b						CALLMONITOR 
341b cd f3 18			call break_point_state  
341e				endm  
# End of macro CALLMONITOR
341e					endif 
341e					FORTH_LOOP_NEXT 
341e cd 8f 21			call macro_forth_loop_next 
3421				endm 
# End of macro FORTH_LOOP_NEXT
3421			 
3421					; push start counter 
3421			 
3421 eb					ex de, hl 
3422					if DEBUG_FORTH_WORDS 
3422						DMARK "DO7" 
3422 f5				push af  
3423 3a 37 34			ld a, (.dmark)  
3426 32 6e fe			ld (debug_mark),a  
3429 3a 38 34			ld a, (.dmark+1)  
342c 32 6f fe			ld (debug_mark+1),a  
342f 3a 39 34			ld a, (.dmark+2)  
3432 32 70 fe			ld (debug_mark+2),a  
3435 18 03			jr .pastdmark  
3437 ..			.dmark: db "DO7"  
343a f1			.pastdmark: pop af  
343b			endm  
# End of macro DMARK
343b						CALLMONITOR 
343b cd f3 18			call break_point_state  
343e				endm  
# End of macro CALLMONITOR
343e					endif 
343e					FORTH_LOOP_NEXT 
343e cd 8f 21			call macro_forth_loop_next 
3441				endm 
# End of macro FORTH_LOOP_NEXT
3441			 
3441			 
3441					; init first round of I counter 
3441			 
3441 22 ed f4				ld (os_current_i), hl 
3444			 
3444					if DEBUG_FORTH_WORDS 
3444						DMARK "DO8" 
3444 f5				push af  
3445 3a 59 34			ld a, (.dmark)  
3448 32 6e fe			ld (debug_mark),a  
344b 3a 5a 34			ld a, (.dmark+1)  
344e 32 6f fe			ld (debug_mark+1),a  
3451 3a 5b 34			ld a, (.dmark+2)  
3454 32 70 fe			ld (debug_mark+2),a  
3457 18 03			jr .pastdmark  
3459 ..			.dmark: db "DO8"  
345c f1			.pastdmark: pop af  
345d			endm  
# End of macro DMARK
345d						CALLMONITOR 
345d cd f3 18			call break_point_state  
3460				endm  
# End of macro CALLMONITOR
3460					endif 
3460			 
3460					NEXTW 
3460 c3 14 23			jp macro_next 
3463				endm 
# End of macro NEXTW
3463			.LOOP: 
3463				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3463 22				db WORD_SYS_CORE+14             
3464 7b 35			dw .I            
3466 05				db 4 + 1 
3467 .. 00			db "LOOP",0              
346c				endm 
# End of macro CWHEAD
346c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
346c			 
346c				; pop tos as current loop count to hl 
346c			 
346c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
346c			 
346c				FORTH_LOOP_TOS 
346c cd c2 21			call macro_forth_loop_tos 
346f				endm 
# End of macro FORTH_LOOP_TOS
346f e5				push hl 
3470			 
3470					if DEBUG_FORTH_WORDS_KEY 
3470						DMARK "LOP" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 6e fe			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 6f fe			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 70 fe			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "LOP"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd f3 18			call break_point_state  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c				; next item on the stack is the limit. get it 
348c			 
348c			 
348c				FORTH_LOOP_POP 
348c cd cc 21			call macro_forth_loop_pop 
348f				endm 
# End of macro FORTH_LOOP_POP
348f			 
348f				FORTH_LOOP_TOS 
348f cd c2 21			call macro_forth_loop_tos 
3492				endm 
# End of macro FORTH_LOOP_TOS
3492			 
3492 d1				pop de		 ; de = i, hl = limit 
3493			 
3493					if DEBUG_FORTH_WORDS 
3493						DMARK "LP1" 
3493 f5				push af  
3494 3a a8 34			ld a, (.dmark)  
3497 32 6e fe			ld (debug_mark),a  
349a 3a a9 34			ld a, (.dmark+1)  
349d 32 6f fe			ld (debug_mark+1),a  
34a0 3a aa 34			ld a, (.dmark+2)  
34a3 32 70 fe			ld (debug_mark+2),a  
34a6 18 03			jr .pastdmark  
34a8 ..			.dmark: db "LP1"  
34ab f1			.pastdmark: pop af  
34ac			endm  
# End of macro DMARK
34ac						CALLMONITOR 
34ac cd f3 18			call break_point_state  
34af				endm  
# End of macro CALLMONITOR
34af					endif 
34af			 
34af				; go back to previous word 
34af			 
34af d5				push de    ; save I for inc later 
34b0			 
34b0			 
34b0				; get limit 
34b0				;  is I at limit? 
34b0			 
34b0			 
34b0					if DEBUG_FORTH_WORDS 
34b0						DMARK "LP1" 
34b0 f5				push af  
34b1 3a c5 34			ld a, (.dmark)  
34b4 32 6e fe			ld (debug_mark),a  
34b7 3a c6 34			ld a, (.dmark+1)  
34ba 32 6f fe			ld (debug_mark+1),a  
34bd 3a c7 34			ld a, (.dmark+2)  
34c0 32 70 fe			ld (debug_mark+2),a  
34c3 18 03			jr .pastdmark  
34c5 ..			.dmark: db "LP1"  
34c8 f1			.pastdmark: pop af  
34c9			endm  
# End of macro DMARK
34c9						CALLMONITOR 
34c9 cd f3 18			call break_point_state  
34cc				endm  
# End of macro CALLMONITOR
34cc					endif 
34cc			 
34cc ed 52			sbc hl, de 
34ce			 
34ce			 
34ce				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34ce			 
34ce 20 26				jr nz, .loopnotdone 
34d0			 
34d0 e1				pop hl   ; get rid of saved I 
34d1				FORTH_LOOP_POP     ; get rid of limit 
34d1 cd cc 21			call macro_forth_loop_pop 
34d4				endm 
# End of macro FORTH_LOOP_POP
34d4			 
34d4				FORTH_RSP_POP     ; get rid of DO ptr 
34d4 cd 2f 1f			call macro_forth_rsp_pop 
34d7				endm 
# End of macro FORTH_RSP_POP
34d7			 
34d7			if DEBUG_FORTH_WORDS 
34d7						DMARK "LP>" 
34d7 f5				push af  
34d8 3a ec 34			ld a, (.dmark)  
34db 32 6e fe			ld (debug_mark),a  
34de 3a ed 34			ld a, (.dmark+1)  
34e1 32 6f fe			ld (debug_mark+1),a  
34e4 3a ee 34			ld a, (.dmark+2)  
34e7 32 70 fe			ld (debug_mark+2),a  
34ea 18 03			jr .pastdmark  
34ec ..			.dmark: db "LP>"  
34ef f1			.pastdmark: pop af  
34f0			endm  
# End of macro DMARK
34f0				CALLMONITOR 
34f0 cd f3 18			call break_point_state  
34f3				endm  
# End of macro CALLMONITOR
34f3			endif 
34f3			 
34f3					NEXTW 
34f3 c3 14 23			jp macro_next 
34f6				endm 
# End of macro NEXTW
34f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34f6			 
34f6			.loopnotdone: 
34f6			 
34f6 e1				pop hl    ; get I 
34f7 23				inc hl 
34f8			 
34f8			   	; save new I 
34f8			 
34f8			 
34f8					; set I counter 
34f8			 
34f8 22 ed f4				ld (os_current_i), hl 
34fb			 
34fb					if DEBUG_FORTH_WORDS 
34fb						DMARK "LPN" 
34fb f5				push af  
34fc 3a 10 35			ld a, (.dmark)  
34ff 32 6e fe			ld (debug_mark),a  
3502 3a 11 35			ld a, (.dmark+1)  
3505 32 6f fe			ld (debug_mark+1),a  
3508 3a 12 35			ld a, (.dmark+2)  
350b 32 70 fe			ld (debug_mark+2),a  
350e 18 03			jr .pastdmark  
3510 ..			.dmark: db "LPN"  
3513 f1			.pastdmark: pop af  
3514			endm  
# End of macro DMARK
3514					CALLMONITOR 
3514 cd f3 18			call break_point_state  
3517				endm  
# End of macro CALLMONITOR
3517					endif 
3517					 
3517				FORTH_LOOP_NEXT 
3517 cd 8f 21			call macro_forth_loop_next 
351a				endm 
# End of macro FORTH_LOOP_NEXT
351a			 
351a			 
351a					if DEBUG_FORTH_WORDS 
351a eb						ex de,hl 
351b					endif 
351b			 
351b			;	; get DO ptr 
351b			; 
351b					if DEBUG_FORTH_WORDS 
351b						DMARK "LP7" 
351b f5				push af  
351c 3a 30 35			ld a, (.dmark)  
351f 32 6e fe			ld (debug_mark),a  
3522 3a 31 35			ld a, (.dmark+1)  
3525 32 6f fe			ld (debug_mark+1),a  
3528 3a 32 35			ld a, (.dmark+2)  
352b 32 70 fe			ld (debug_mark+2),a  
352e 18 03			jr .pastdmark  
3530 ..			.dmark: db "LP7"  
3533 f1			.pastdmark: pop af  
3534			endm  
# End of macro DMARK
3534					CALLMONITOR 
3534 cd f3 18			call break_point_state  
3537				endm  
# End of macro CALLMONITOR
3537					endif 
3537				FORTH_RSP_TOS 
3537 cd 25 1f			call macro_forth_rsp_tos 
353a				endm 
# End of macro FORTH_RSP_TOS
353a			 
353a					if DEBUG_FORTH_WORDS 
353a						DMARK "LP8" 
353a f5				push af  
353b 3a 4f 35			ld a, (.dmark)  
353e 32 6e fe			ld (debug_mark),a  
3541 3a 50 35			ld a, (.dmark+1)  
3544 32 6f fe			ld (debug_mark+1),a  
3547 3a 51 35			ld a, (.dmark+2)  
354a 32 70 fe			ld (debug_mark+2),a  
354d 18 03			jr .pastdmark  
354f ..			.dmark: db "LP8"  
3552 f1			.pastdmark: pop af  
3553			endm  
# End of macro DMARK
3553					CALLMONITOR 
3553 cd f3 18			call break_point_state  
3556				endm  
# End of macro CALLMONITOR
3556					endif 
3556				;push hl 
3556			 
3556				; not going to DO any more 
3556				; get rid of the RSP pointer as DO will add it back in 
3556				;FORTH_RSP_POP 
3556				;pop hl 
3556			 
3556				;ld hl,(cli_ret_sp) 
3556				;ld e, (hl) 
3556				;inc hl 
3556				;ld d, (hl) 
3556				;ex de,hl 
3556 22 c9 f4			ld (os_tok_ptr), hl 
3559					if DEBUG_FORTH_WORDS 
3559						DMARK "LP<" 
3559 f5				push af  
355a 3a 6e 35			ld a, (.dmark)  
355d 32 6e fe			ld (debug_mark),a  
3560 3a 6f 35			ld a, (.dmark+1)  
3563 32 6f fe			ld (debug_mark+1),a  
3566 3a 70 35			ld a, (.dmark+2)  
3569 32 70 fe			ld (debug_mark+2),a  
356c 18 03			jr .pastdmark  
356e ..			.dmark: db "LP<"  
3571 f1			.pastdmark: pop af  
3572			endm  
# End of macro DMARK
3572					CALLMONITOR 
3572 cd f3 18			call break_point_state  
3575				endm  
# End of macro CALLMONITOR
3575				endif 
3575 c3 a5 23			jp exec1 
3578			 
3578					 
3578			 
3578			 
3578					NEXTW 
3578 c3 14 23			jp macro_next 
357b				endm 
# End of macro NEXTW
357b			.I:  
357b			 
357b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
357b 5e				db WORD_SYS_CORE+74             
357c a6 35			dw .DLOOP            
357e 02				db 1 + 1 
357f .. 00			db "I",0              
3581				endm 
# End of macro CWHEAD
3581			; | I ( -- ) Current loop counter | DONE 
3581					if DEBUG_FORTH_WORDS_KEY 
3581						DMARK "I.." 
3581 f5				push af  
3582 3a 96 35			ld a, (.dmark)  
3585 32 6e fe			ld (debug_mark),a  
3588 3a 97 35			ld a, (.dmark+1)  
358b 32 6f fe			ld (debug_mark+1),a  
358e 3a 98 35			ld a, (.dmark+2)  
3591 32 70 fe			ld (debug_mark+2),a  
3594 18 03			jr .pastdmark  
3596 ..			.dmark: db "I.."  
3599 f1			.pastdmark: pop af  
359a			endm  
# End of macro DMARK
359a						CALLMONITOR 
359a cd f3 18			call break_point_state  
359d				endm  
# End of macro CALLMONITOR
359d					endif 
359d			 
359d 2a ed f4				ld hl,(os_current_i) 
35a0 cd 67 1f				call forth_push_numhl 
35a3			 
35a3					NEXTW 
35a3 c3 14 23			jp macro_next 
35a6				endm 
# End of macro NEXTW
35a6			.DLOOP: 
35a6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
35a6 5f				db WORD_SYS_CORE+75             
35a7 87 36			dw .REPEAT            
35a9 06				db 5 + 1 
35aa .. 00			db "-LOOP",0              
35b0				endm 
# End of macro CWHEAD
35b0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
35b0				; pop tos as current loop count to hl 
35b0					if DEBUG_FORTH_WORDS_KEY 
35b0						DMARK "-LP" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 6e fe			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 6f fe			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 70 fe			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "-LP"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd f3 18			call break_point_state  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc			 
35cc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35cc			 
35cc				FORTH_LOOP_TOS 
35cc cd c2 21			call macro_forth_loop_tos 
35cf				endm 
# End of macro FORTH_LOOP_TOS
35cf e5				push hl 
35d0			 
35d0					if DEBUG_FORTH_WORDS 
35d0						DMARK "-LP" 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 6e fe			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 6f fe			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 70 fe			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "-LP"  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd f3 18			call break_point_state  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec				; next item on the stack is the limit. get it 
35ec			 
35ec			 
35ec				FORTH_LOOP_POP 
35ec cd cc 21			call macro_forth_loop_pop 
35ef				endm 
# End of macro FORTH_LOOP_POP
35ef			 
35ef				FORTH_LOOP_TOS 
35ef cd c2 21			call macro_forth_loop_tos 
35f2				endm 
# End of macro FORTH_LOOP_TOS
35f2			 
35f2 d1				pop de		 ; de = i, hl = limit 
35f3			 
35f3					if DEBUG_FORTH_WORDS 
35f3						DMARK "-L1" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 6e fe			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 6f fe			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 70 fe			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "-L1"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd f3 18			call break_point_state  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f			 
360f				; go back to previous word 
360f			 
360f d5				push de    ; save I for inc later 
3610			 
3610			 
3610				; get limit 
3610				;  is I at limit? 
3610			 
3610			 
3610					if DEBUG_FORTH_WORDS 
3610						DMARK "-L1" 
3610 f5				push af  
3611 3a 25 36			ld a, (.dmark)  
3614 32 6e fe			ld (debug_mark),a  
3617 3a 26 36			ld a, (.dmark+1)  
361a 32 6f fe			ld (debug_mark+1),a  
361d 3a 27 36			ld a, (.dmark+2)  
3620 32 70 fe			ld (debug_mark+2),a  
3623 18 03			jr .pastdmark  
3625 ..			.dmark: db "-L1"  
3628 f1			.pastdmark: pop af  
3629			endm  
# End of macro DMARK
3629						CALLMONITOR 
3629 cd f3 18			call break_point_state  
362c				endm  
# End of macro CALLMONITOR
362c					endif 
362c			 
362c ed 52			sbc hl, de 
362e			 
362e			 
362e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
362e			 
362e 20 26				jr nz, .mloopnotdone 
3630			 
3630 e1				pop hl   ; get rid of saved I 
3631				FORTH_LOOP_POP     ; get rid of limit 
3631 cd cc 21			call macro_forth_loop_pop 
3634				endm 
# End of macro FORTH_LOOP_POP
3634			 
3634				FORTH_RSP_POP     ; get rid of DO ptr 
3634 cd 2f 1f			call macro_forth_rsp_pop 
3637				endm 
# End of macro FORTH_RSP_POP
3637			 
3637			if DEBUG_FORTH_WORDS 
3637						DMARK "-L>" 
3637 f5				push af  
3638 3a 4c 36			ld a, (.dmark)  
363b 32 6e fe			ld (debug_mark),a  
363e 3a 4d 36			ld a, (.dmark+1)  
3641 32 6f fe			ld (debug_mark+1),a  
3644 3a 4e 36			ld a, (.dmark+2)  
3647 32 70 fe			ld (debug_mark+2),a  
364a 18 03			jr .pastdmark  
364c ..			.dmark: db "-L>"  
364f f1			.pastdmark: pop af  
3650			endm  
# End of macro DMARK
3650				CALLMONITOR 
3650 cd f3 18			call break_point_state  
3653				endm  
# End of macro CALLMONITOR
3653			endif 
3653			 
3653					NEXTW 
3653 c3 14 23			jp macro_next 
3656				endm 
# End of macro NEXTW
3656				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3656			 
3656			.mloopnotdone: 
3656			 
3656 e1				pop hl    ; get I 
3657 2b				dec hl 
3658			 
3658			   	; save new I 
3658			 
3658			 
3658					; set I counter 
3658			 
3658 22 ed f4				ld (os_current_i), hl 
365b			 
365b					 
365b				FORTH_LOOP_NEXT 
365b cd 8f 21			call macro_forth_loop_next 
365e				endm 
# End of macro FORTH_LOOP_NEXT
365e			 
365e			 
365e					if DEBUG_FORTH_WORDS 
365e eb						ex de,hl 
365f					endif 
365f			 
365f			;	; get DO ptr 
365f			; 
365f				FORTH_RSP_TOS 
365f cd 25 1f			call macro_forth_rsp_tos 
3662				endm 
# End of macro FORTH_RSP_TOS
3662			 
3662				;push hl 
3662			 
3662				; not going to DO any more 
3662				; get rid of the RSP pointer as DO will add it back in 
3662				;FORTH_RSP_POP 
3662				;pop hl 
3662			 
3662			 
3662 22 c9 f4			ld (os_tok_ptr), hl 
3665					if DEBUG_FORTH_WORDS 
3665						DMARK "-L<" 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 6e fe			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 6f fe			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 70 fe			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "-L<"  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e					CALLMONITOR 
367e cd f3 18			call break_point_state  
3681				endm  
# End of macro CALLMONITOR
3681				endif 
3681 c3 a5 23			jp exec1 
3684			 
3684					 
3684			 
3684			 
3684			 
3684				NEXTW 
3684 c3 14 23			jp macro_next 
3687				endm 
# End of macro NEXTW
3687			 
3687			 
3687			 
3687			 
3687			.REPEAT: 
3687				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3687 71				db WORD_SYS_CORE+93             
3688 da 36			dw .UNTIL            
368a 06				db 5 + 1 
368b .. 00			db "REPEAT",0              
3692				endm 
# End of macro CWHEAD
3692			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3692			;  push pc to rsp stack past the REPEAT 
3692					if DEBUG_FORTH_WORDS_KEY 
3692						DMARK "REP" 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 6e fe			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 6f fe			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 70 fe			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "REP"  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd f3 18			call break_point_state  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae			 
36ae 2a c9 f4				ld hl, (os_tok_ptr) 
36b1 23					inc hl   ; R 
36b2 23					inc hl  ; E 
36b3 23					inc hl   ; P 
36b4 23					inc hl   ; E 
36b5 23					inc hl   ; A 
36b6 23					inc hl   ; T 
36b7 23					inc hl   ; zero 
36b8					FORTH_RSP_NEXT 
36b8 cd 0e 1f			call macro_forth_rsp_next 
36bb				endm 
# End of macro FORTH_RSP_NEXT
36bb			 
36bb			 
36bb					if DEBUG_FORTH_WORDS 
36bb						DMARK "REP" 
36bb f5				push af  
36bc 3a d0 36			ld a, (.dmark)  
36bf 32 6e fe			ld (debug_mark),a  
36c2 3a d1 36			ld a, (.dmark+1)  
36c5 32 6f fe			ld (debug_mark+1),a  
36c8 3a d2 36			ld a, (.dmark+2)  
36cb 32 70 fe			ld (debug_mark+2),a  
36ce 18 03			jr .pastdmark  
36d0 ..			.dmark: db "REP"  
36d3 f1			.pastdmark: pop af  
36d4			endm  
# End of macro DMARK
36d4						;pop bc    ; TODO BUG ?????? what is this for???? 
36d4						CALLMONITOR 
36d4 cd f3 18			call break_point_state  
36d7				endm  
# End of macro CALLMONITOR
36d7					endif 
36d7			 
36d7					NEXTW 
36d7 c3 14 23			jp macro_next 
36da				endm 
# End of macro NEXTW
36da			;	       NEXTW 
36da			 
36da			.UNTIL: 
36da				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36da 72				db WORD_SYS_CORE+94             
36db 71 37			dw .ENDFLOW            
36dd 06				db 5 + 1 
36de .. 00			db "UNTIL",0              
36e4				endm 
# End of macro CWHEAD
36e4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36e4			 
36e4				; pop tos as check 
36e4			 
36e4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36e4			 
36e4				FORTH_DSP_VALUEHL 
36e4 cd 5e 21			call macro_dsp_valuehl 
36e7				endm 
# End of macro FORTH_DSP_VALUEHL
36e7			 
36e7					if DEBUG_FORTH_WORDS_KEY 
36e7						DMARK "UNT" 
36e7 f5				push af  
36e8 3a fc 36			ld a, (.dmark)  
36eb 32 6e fe			ld (debug_mark),a  
36ee 3a fd 36			ld a, (.dmark+1)  
36f1 32 6f fe			ld (debug_mark+1),a  
36f4 3a fe 36			ld a, (.dmark+2)  
36f7 32 70 fe			ld (debug_mark+2),a  
36fa 18 03			jr .pastdmark  
36fc ..			.dmark: db "UNT"  
36ff f1			.pastdmark: pop af  
3700			endm  
# End of macro DMARK
3700						CALLMONITOR 
3700 cd f3 18			call break_point_state  
3703				endm  
# End of macro CALLMONITOR
3703					endif 
3703			 
3703			;	push hl 
3703				FORTH_DSP_POP 
3703 cd 16 22			call macro_forth_dsp_pop 
3706				endm 
# End of macro FORTH_DSP_POP
3706			 
3706			;	pop hl 
3706			 
3706				; test if true 
3706			 
3706 cd 75 0f			call ishlzero 
3709			;	ld a,l 
3709			;	add h 
3709			; 
3709			;	cp 0 
3709			 
3709 20 3e			jr nz, .untilnotdone 
370b			 
370b					if DEBUG_FORTH_WORDS 
370b						DMARK "UNf" 
370b f5				push af  
370c 3a 20 37			ld a, (.dmark)  
370f 32 6e fe			ld (debug_mark),a  
3712 3a 21 37			ld a, (.dmark+1)  
3715 32 6f fe			ld (debug_mark+1),a  
3718 3a 22 37			ld a, (.dmark+2)  
371b 32 70 fe			ld (debug_mark+2),a  
371e 18 03			jr .pastdmark  
3720 ..			.dmark: db "UNf"  
3723 f1			.pastdmark: pop af  
3724			endm  
# End of macro DMARK
3724						CALLMONITOR 
3724 cd f3 18			call break_point_state  
3727				endm  
# End of macro CALLMONITOR
3727					endif 
3727			 
3727			 
3727			 
3727				FORTH_RSP_POP     ; get rid of DO ptr 
3727 cd 2f 1f			call macro_forth_rsp_pop 
372a				endm 
# End of macro FORTH_RSP_POP
372a			 
372a			if DEBUG_FORTH_WORDS 
372a						DMARK "UN>" 
372a f5				push af  
372b 3a 3f 37			ld a, (.dmark)  
372e 32 6e fe			ld (debug_mark),a  
3731 3a 40 37			ld a, (.dmark+1)  
3734 32 6f fe			ld (debug_mark+1),a  
3737 3a 41 37			ld a, (.dmark+2)  
373a 32 70 fe			ld (debug_mark+2),a  
373d 18 03			jr .pastdmark  
373f ..			.dmark: db "UN>"  
3742 f1			.pastdmark: pop af  
3743			endm  
# End of macro DMARK
3743				CALLMONITOR 
3743 cd f3 18			call break_point_state  
3746				endm  
# End of macro CALLMONITOR
3746			endif 
3746			 
3746					NEXTW 
3746 c3 14 23			jp macro_next 
3749				endm 
# End of macro NEXTW
3749				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3749			 
3749			.untilnotdone: 
3749			 
3749			 
3749			;	; get DO ptr 
3749			; 
3749				FORTH_RSP_TOS 
3749 cd 25 1f			call macro_forth_rsp_tos 
374c				endm 
# End of macro FORTH_RSP_TOS
374c			 
374c				;push hl 
374c			 
374c				; not going to DO any more 
374c				; get rid of the RSP pointer as DO will add it back in 
374c				;FORTH_RSP_POP 
374c				;pop hl 
374c			 
374c			 
374c 22 c9 f4			ld (os_tok_ptr), hl 
374f					if DEBUG_FORTH_WORDS 
374f						DMARK "UN<" 
374f f5				push af  
3750 3a 64 37			ld a, (.dmark)  
3753 32 6e fe			ld (debug_mark),a  
3756 3a 65 37			ld a, (.dmark+1)  
3759 32 6f fe			ld (debug_mark+1),a  
375c 3a 66 37			ld a, (.dmark+2)  
375f 32 70 fe			ld (debug_mark+2),a  
3762 18 03			jr .pastdmark  
3764 ..			.dmark: db "UN<"  
3767 f1			.pastdmark: pop af  
3768			endm  
# End of macro DMARK
3768					CALLMONITOR 
3768 cd f3 18			call break_point_state  
376b				endm  
# End of macro CALLMONITOR
376b				endif 
376b c3 a5 23			jp exec1 
376e			 
376e					 
376e			 
376e			 
376e					NEXTW 
376e c3 14 23			jp macro_next 
3771				endm 
# End of macro NEXTW
3771			 
3771			 
3771			.ENDFLOW: 
3771			 
3771			; eof 
3771			 
# End of file forth_words_flow.asm
3771			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3771			include "forth_words_logic.asm" 
3771			 
3771			; | ## Logic Words 
3771			 
3771			.NOT: 
3771				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3771 2d				db WORD_SYS_CORE+25             
3772 b9 37			dw .IS            
3774 04				db 3 + 1 
3775 .. 00			db "NOT",0              
3779				endm 
# End of macro CWHEAD
3779			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3779					if DEBUG_FORTH_WORDS_KEY 
3779						DMARK "NOT" 
3779 f5				push af  
377a 3a 8e 37			ld a, (.dmark)  
377d 32 6e fe			ld (debug_mark),a  
3780 3a 8f 37			ld a, (.dmark+1)  
3783 32 6f fe			ld (debug_mark+1),a  
3786 3a 90 37			ld a, (.dmark+2)  
3789 32 70 fe			ld (debug_mark+2),a  
378c 18 03			jr .pastdmark  
378e ..			.dmark: db "NOT"  
3791 f1			.pastdmark: pop af  
3792			endm  
# End of macro DMARK
3792						CALLMONITOR 
3792 cd f3 18			call break_point_state  
3795				endm  
# End of macro CALLMONITOR
3795					endif 
3795					FORTH_DSP 
3795 cd 24 21			call macro_forth_dsp 
3798				endm 
# End of macro FORTH_DSP
3798 7e					ld a,(hl)	; get type of value on TOS 
3799 fe 02				cp DS_TYPE_INUM  
379b 28 03				jr z, .noti 
379d					NEXTW 
379d c3 14 23			jp macro_next 
37a0				endm 
# End of macro NEXTW
37a0			.noti:          FORTH_DSP_VALUEHL 
37a0 cd 5e 21			call macro_dsp_valuehl 
37a3				endm 
# End of macro FORTH_DSP_VALUEHL
37a3			;		push hl 
37a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a3 cd 16 22			call macro_forth_dsp_pop 
37a6				endm 
# End of macro FORTH_DSP_POP
37a6			;		pop hl 
37a6 3e 00				ld a,0 
37a8 bd					cp l 
37a9 28 04				jr z, .not2t 
37ab 2e 00				ld l, 0 
37ad 18 02				jr .notip 
37af			 
37af 2e ff		.not2t:		ld l, 255 
37b1			 
37b1 26 00		.notip:		ld h, 0	 
37b3			 
37b3 cd 67 1f				call forth_push_numhl 
37b6					NEXTW 
37b6 c3 14 23			jp macro_next 
37b9				endm 
# End of macro NEXTW
37b9			 
37b9			.IS: 
37b9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
37b9 2d				db WORD_SYS_CORE+25             
37ba df 37			dw .LZERO            
37bc 03				db 2 + 1 
37bd .. 00			db "IS",0              
37c0				endm 
# End of macro CWHEAD
37c0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
37c0					if DEBUG_FORTH_WORDS_KEY 
37c0						DMARK "IS." 
37c0 f5				push af  
37c1 3a d5 37			ld a, (.dmark)  
37c4 32 6e fe			ld (debug_mark),a  
37c7 3a d6 37			ld a, (.dmark+1)  
37ca 32 6f fe			ld (debug_mark+1),a  
37cd 3a d7 37			ld a, (.dmark+2)  
37d0 32 70 fe			ld (debug_mark+2),a  
37d3 18 03			jr .pastdmark  
37d5 ..			.dmark: db "IS."  
37d8 f1			.pastdmark: pop af  
37d9			endm  
# End of macro DMARK
37d9						CALLMONITOR 
37d9 cd f3 18			call break_point_state  
37dc				endm  
# End of macro CALLMONITOR
37dc					endif 
37dc					NEXTW 
37dc c3 14 23			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.LZERO: 
37df				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37df 2d				db WORD_SYS_CORE+25             
37e0 e9 37			dw .TZERO            
37e2 03				db 2 + 1 
37e3 .. 00			db "0<",0              
37e6				endm 
# End of macro CWHEAD
37e6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37e6					NEXTW 
37e6 c3 14 23			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			.TZERO: 
37e9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37e9 2e				db WORD_SYS_CORE+26             
37ea 30 38			dw .LESS            
37ec 03				db 2 + 1 
37ed .. 00			db "0=",0              
37f0				endm 
# End of macro CWHEAD
37f0			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37f0				; TODO add floating point number detection 
37f0					;v5 FORTH_DSP_VALUE 
37f0					if DEBUG_FORTH_WORDS_KEY 
37f0						DMARK "0=." 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 6e fe			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 6f fe			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 70 fe			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "0=."  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd f3 18			call break_point_state  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c					FORTH_DSP 
380c cd 24 21			call macro_forth_dsp 
380f				endm 
# End of macro FORTH_DSP
380f 7e					ld a,(hl)	; get type of value on TOS 
3810 fe 02				cp DS_TYPE_INUM  
3812 28 00				jr z, .tz_inum 
3814			 
3814				if FORTH_ENABLE_FLOATMATH 
3814					jr .tz_done 
3814			 
3814				endif 
3814					 
3814			 
3814			.tz_inum: 
3814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3814 cd 5e 21			call macro_dsp_valuehl 
3817				endm 
# End of macro FORTH_DSP_VALUEHL
3817			 
3817			;		push hl 
3817			 
3817					; destroy value TOS 
3817			 
3817					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3817 cd 16 22			call macro_forth_dsp_pop 
381a				endm 
# End of macro FORTH_DSP_POP
381a			 
381a			;		pop hl 
381a			 
381a 3e 00				ld a,0 
381c			 
381c bd					cp l 
381d 20 08				jr nz, .tz_notzero 
381f			 
381f bc					cp h 
3820			 
3820 20 05				jr nz, .tz_notzero 
3822			 
3822			 
3822 21 01 00				ld hl, FORTH_TRUE 
3825 18 03				jr .tz_done 
3827			 
3827 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
382a			 
382a					; push value back onto stack for another op etc 
382a			 
382a			.tz_done: 
382a cd 67 1f				call forth_push_numhl 
382d			 
382d					NEXTW 
382d c3 14 23			jp macro_next 
3830				endm 
# End of macro NEXTW
3830			.LESS: 
3830				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3830 2f				db WORD_SYS_CORE+27             
3831 99 38			dw .GT            
3833 02				db 1 + 1 
3834 .. 00			db "<",0              
3836				endm 
# End of macro CWHEAD
3836			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3836				; TODO add floating point number detection 
3836					if DEBUG_FORTH_WORDS_KEY 
3836						DMARK "LES" 
3836 f5				push af  
3837 3a 4b 38			ld a, (.dmark)  
383a 32 6e fe			ld (debug_mark),a  
383d 3a 4c 38			ld a, (.dmark+1)  
3840 32 6f fe			ld (debug_mark+1),a  
3843 3a 4d 38			ld a, (.dmark+2)  
3846 32 70 fe			ld (debug_mark+2),a  
3849 18 03			jr .pastdmark  
384b ..			.dmark: db "LES"  
384e f1			.pastdmark: pop af  
384f			endm  
# End of macro DMARK
384f						CALLMONITOR 
384f cd f3 18			call break_point_state  
3852				endm  
# End of macro CALLMONITOR
3852					endif 
3852					FORTH_DSP 
3852 cd 24 21			call macro_forth_dsp 
3855				endm 
# End of macro FORTH_DSP
3855					;v5 FORTH_DSP_VALUE 
3855 7e					ld a,(hl)	; get type of value on TOS 
3856 fe 02				cp DS_TYPE_INUM  
3858 28 00				jr z, .less_inum 
385a			 
385a				if FORTH_ENABLE_FLOATMATH 
385a					jr .less_done 
385a			 
385a				endif 
385a					 
385a			 
385a			.less_inum: 
385a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385a cd 5e 21			call macro_dsp_valuehl 
385d				endm 
# End of macro FORTH_DSP_VALUEHL
385d			 
385d e5					push hl  ; u2 
385e			 
385e					; destroy value TOS 
385e			 
385e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385e cd 16 22			call macro_forth_dsp_pop 
3861				endm 
# End of macro FORTH_DSP_POP
3861			 
3861			 
3861					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3861 cd 5e 21			call macro_dsp_valuehl 
3864				endm 
# End of macro FORTH_DSP_VALUEHL
3864			 
3864 e5					push hl    ; u1 
3865			 
3865					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3865 cd 16 22			call macro_forth_dsp_pop 
3868				endm 
# End of macro FORTH_DSP_POP
3868			 
3868			 
3868 b7			 or a      ;clear carry flag 
3869 01 00 00		 ld bc, FORTH_FALSE 
386c e1			  pop hl    ; u1 
386d d1			  pop de    ; u2 
386e ed 52		  sbc hl,de 
3870 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3872			 
3872 01 01 00		 ld bc, FORTH_TRUE 
3875			.lscont:  
3875 c5					push bc 
3876 e1					pop hl 
3877			 
3877					if DEBUG_FORTH_WORDS 
3877						DMARK "LT1" 
3877 f5				push af  
3878 3a 8c 38			ld a, (.dmark)  
387b 32 6e fe			ld (debug_mark),a  
387e 3a 8d 38			ld a, (.dmark+1)  
3881 32 6f fe			ld (debug_mark+1),a  
3884 3a 8e 38			ld a, (.dmark+2)  
3887 32 70 fe			ld (debug_mark+2),a  
388a 18 03			jr .pastdmark  
388c ..			.dmark: db "LT1"  
388f f1			.pastdmark: pop af  
3890			endm  
# End of macro DMARK
3890						CALLMONITOR 
3890 cd f3 18			call break_point_state  
3893				endm  
# End of macro CALLMONITOR
3893					endif 
3893 cd 67 1f				call forth_push_numhl 
3896			 
3896					NEXTW 
3896 c3 14 23			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			.GT: 
3899				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3899 30				db WORD_SYS_CORE+28             
389a 02 39			dw .EQUAL            
389c 02				db 1 + 1 
389d .. 00			db ">",0              
389f				endm 
# End of macro CWHEAD
389f			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
389f				; TODO add floating point number detection 
389f					if DEBUG_FORTH_WORDS_KEY 
389f						DMARK "GRT" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 6e fe			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 6f fe			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 70 fe			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "GRT"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8						CALLMONITOR 
38b8 cd f3 18			call break_point_state  
38bb				endm  
# End of macro CALLMONITOR
38bb					endif 
38bb					FORTH_DSP 
38bb cd 24 21			call macro_forth_dsp 
38be				endm 
# End of macro FORTH_DSP
38be					;FORTH_DSP_VALUE 
38be 7e					ld a,(hl)	; get type of value on TOS 
38bf fe 02				cp DS_TYPE_INUM  
38c1 28 00				jr z, .gt_inum 
38c3			 
38c3				if FORTH_ENABLE_FLOATMATH 
38c3					jr .gt_done 
38c3			 
38c3				endif 
38c3					 
38c3			 
38c3			.gt_inum: 
38c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c3 cd 5e 21			call macro_dsp_valuehl 
38c6				endm 
# End of macro FORTH_DSP_VALUEHL
38c6			 
38c6 e5					push hl  ; u2 
38c7			 
38c7					; destroy value TOS 
38c7			 
38c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c7 cd 16 22			call macro_forth_dsp_pop 
38ca				endm 
# End of macro FORTH_DSP_POP
38ca			 
38ca			 
38ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ca cd 5e 21			call macro_dsp_valuehl 
38cd				endm 
# End of macro FORTH_DSP_VALUEHL
38cd			 
38cd e5					push hl    ; u1 
38ce			 
38ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ce cd 16 22			call macro_forth_dsp_pop 
38d1				endm 
# End of macro FORTH_DSP_POP
38d1			 
38d1			 
38d1 b7			 or a      ;clear carry flag 
38d2 01 00 00		 ld bc, FORTH_FALSE 
38d5 e1			  pop hl    ; u1 
38d6 d1			  pop de    ; u2 
38d7 ed 52		  sbc hl,de 
38d9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38db			 
38db 01 01 00		 ld bc, FORTH_TRUE 
38de			.gtcont:  
38de c5					push bc 
38df e1					pop hl 
38e0			 
38e0					if DEBUG_FORTH_WORDS 
38e0						DMARK "GT1" 
38e0 f5				push af  
38e1 3a f5 38			ld a, (.dmark)  
38e4 32 6e fe			ld (debug_mark),a  
38e7 3a f6 38			ld a, (.dmark+1)  
38ea 32 6f fe			ld (debug_mark+1),a  
38ed 3a f7 38			ld a, (.dmark+2)  
38f0 32 70 fe			ld (debug_mark+2),a  
38f3 18 03			jr .pastdmark  
38f5 ..			.dmark: db "GT1"  
38f8 f1			.pastdmark: pop af  
38f9			endm  
# End of macro DMARK
38f9						CALLMONITOR 
38f9 cd f3 18			call break_point_state  
38fc				endm  
# End of macro CALLMONITOR
38fc					endif 
38fc cd 67 1f				call forth_push_numhl 
38ff			 
38ff					NEXTW 
38ff c3 14 23			jp macro_next 
3902				endm 
# End of macro NEXTW
3902			.EQUAL: 
3902				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3902 31				db WORD_SYS_CORE+29             
3903 6d 39			dw .ENDLOGIC            
3905 02				db 1 + 1 
3906 .. 00			db "=",0              
3908				endm 
# End of macro CWHEAD
3908			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3908				; TODO add floating point number detection 
3908					if DEBUG_FORTH_WORDS_KEY 
3908						DMARK "EQ." 
3908 f5				push af  
3909 3a 1d 39			ld a, (.dmark)  
390c 32 6e fe			ld (debug_mark),a  
390f 3a 1e 39			ld a, (.dmark+1)  
3912 32 6f fe			ld (debug_mark+1),a  
3915 3a 1f 39			ld a, (.dmark+2)  
3918 32 70 fe			ld (debug_mark+2),a  
391b 18 03			jr .pastdmark  
391d ..			.dmark: db "EQ."  
3920 f1			.pastdmark: pop af  
3921			endm  
# End of macro DMARK
3921						CALLMONITOR 
3921 cd f3 18			call break_point_state  
3924				endm  
# End of macro CALLMONITOR
3924					endif 
3924					FORTH_DSP 
3924 cd 24 21			call macro_forth_dsp 
3927				endm 
# End of macro FORTH_DSP
3927					;v5 FORTH_DSP_VALUE 
3927 7e					ld a,(hl)	; get type of value on TOS 
3928 fe 02				cp DS_TYPE_INUM  
392a 28 00				jr z, .eq_inum 
392c			 
392c				if FORTH_ENABLE_FLOATMATH 
392c					jr .eq_done 
392c			 
392c				endif 
392c					 
392c			 
392c			.eq_inum: 
392c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392c cd 5e 21			call macro_dsp_valuehl 
392f				endm 
# End of macro FORTH_DSP_VALUEHL
392f			 
392f e5					push hl 
3930			 
3930					; destroy value TOS 
3930			 
3930					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3930 cd 16 22			call macro_forth_dsp_pop 
3933				endm 
# End of macro FORTH_DSP_POP
3933			 
3933			 
3933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3933 cd 5e 21			call macro_dsp_valuehl 
3936				endm 
# End of macro FORTH_DSP_VALUEHL
3936			 
3936					; one value on hl get other one back 
3936			 
3936 e5					push hl 
3937			 
3937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3937 cd 16 22			call macro_forth_dsp_pop 
393a				endm 
# End of macro FORTH_DSP_POP
393a			 
393a 0e 00				ld c, FORTH_FALSE 
393c			 
393c e1					pop hl 
393d d1					pop de 
393e			 
393e 7b					ld a, e 
393f bd					cp l 
3940			 
3940 20 06				jr nz, .eq_done 
3942			 
3942 7a					ld a, d 
3943 bc					cp h 
3944			 
3944 20 02				jr nz, .eq_done 
3946			 
3946 0e 01				ld c, FORTH_TRUE 
3948					 
3948			 
3948			 
3948			.eq_done: 
3948			 
3948					; TODO push value back onto stack for another op etc 
3948			 
3948 26 00				ld h, 0 
394a 69					ld l, c 
394b					if DEBUG_FORTH_WORDS 
394b						DMARK "EQ1" 
394b f5				push af  
394c 3a 60 39			ld a, (.dmark)  
394f 32 6e fe			ld (debug_mark),a  
3952 3a 61 39			ld a, (.dmark+1)  
3955 32 6f fe			ld (debug_mark+1),a  
3958 3a 62 39			ld a, (.dmark+2)  
395b 32 70 fe			ld (debug_mark+2),a  
395e 18 03			jr .pastdmark  
3960 ..			.dmark: db "EQ1"  
3963 f1			.pastdmark: pop af  
3964			endm  
# End of macro DMARK
3964						CALLMONITOR 
3964 cd f3 18			call break_point_state  
3967				endm  
# End of macro CALLMONITOR
3967					endif 
3967 cd 67 1f				call forth_push_numhl 
396a			 
396a					NEXTW 
396a c3 14 23			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			 
396d			 
396d			.ENDLOGIC: 
396d			; eof 
396d			 
396d			 
# End of file forth_words_logic.asm
396d			include "forth_words_maths.asm" 
396d			 
396d			; | ## Maths Words 
396d			 
396d			.PLUS:	 
396d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
396d 15				db WORD_SYS_CORE+1             
396e cb 39			dw .NEG            
3970 02				db 1 + 1 
3971 .. 00			db "+",0              
3973				endm 
# End of macro CWHEAD
3973			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3973					if DEBUG_FORTH_WORDS_KEY 
3973						DMARK "PLU" 
3973 f5				push af  
3974 3a 88 39			ld a, (.dmark)  
3977 32 6e fe			ld (debug_mark),a  
397a 3a 89 39			ld a, (.dmark+1)  
397d 32 6f fe			ld (debug_mark+1),a  
3980 3a 8a 39			ld a, (.dmark+2)  
3983 32 70 fe			ld (debug_mark+2),a  
3986 18 03			jr .pastdmark  
3988 ..			.dmark: db "PLU"  
398b f1			.pastdmark: pop af  
398c			endm  
# End of macro DMARK
398c						CALLMONITOR 
398c cd f3 18			call break_point_state  
398f				endm  
# End of macro CALLMONITOR
398f					endif 
398f					; add top two values and push back result 
398f			 
398f					;for v5 FORTH_DSP_VALUE 
398f					FORTH_DSP 
398f cd 24 21			call macro_forth_dsp 
3992				endm 
# End of macro FORTH_DSP
3992 7e					ld a,(hl)	; get type of value on TOS 
3993 fe 02				cp DS_TYPE_INUM  
3995 28 03				jr z, .dot_inum 
3997			 
3997					NEXTW 
3997 c3 14 23			jp macro_next 
399a				endm 
# End of macro NEXTW
399a			 
399a			; float maths 
399a			 
399a				if FORTH_ENABLE_FLOATMATH 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					if DEBUG_FORTH_MATHS 
399a						DMARK "ADD" 
399a				CALLMONITOR 
399a					endif 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a			 
399a					push hl 
399a					 
399a					 
399a			 
399a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
399a			 
399a					; get next number 
399a			 
399a						FORTH_DSP_VALUE 
399a			 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a					push hl 
399a			 
399a			 
399a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399a			 
399a						; TODO do add 
399a			 
399a						call IADD 
399a			 
399a						; TODO get result back as ascii 
399a			 
399a						; TODO push result  
399a			 
399a			 
399a			 
399a						jr .dot_done 
399a				endif 
399a			 
399a			.dot_inum: 
399a			 
399a			 
399a					if DEBUG_FORTH_DOT 
399a						DMARK "+IT" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 6e fe			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 6f fe			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 70 fe			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "+IT"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3				CALLMONITOR 
39b3 cd f3 18			call break_point_state  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6			 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd 5e 21			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9				; TODO add floating point number detection 
39b9			 
39b9 e5					push hl 
39ba			 
39ba					; destroy value TOS 
39ba			 
39ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ba cd 16 22			call macro_forth_dsp_pop 
39bd				endm 
# End of macro FORTH_DSP_POP
39bd			 
39bd			 
39bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bd cd 5e 21			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0					; one value on hl get other one back 
39c0			 
39c0 d1					pop de 
39c1			 
39c1					; do the add 
39c1			 
39c1 19					add hl,de 
39c2			 
39c2					; save it 
39c2			 
39c2			;		push hl	 
39c2			 
39c2					; 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 16 22			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5					; TODO push value back onto stack for another op etc 
39c5			 
39c5			;		pop hl 
39c5			 
39c5			.dot_done: 
39c5 cd 67 1f				call forth_push_numhl 
39c8			 
39c8					NEXTW 
39c8 c3 14 23			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			.NEG: 
39cb			 
39cb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39cb 17				db WORD_SYS_CORE+3             
39cc 0e 3a			dw .DIV            
39ce 02				db 1 + 1 
39cf .. 00			db "-",0              
39d1				endm 
# End of macro CWHEAD
39d1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39d1					if DEBUG_FORTH_WORDS_KEY 
39d1						DMARK "SUB" 
39d1 f5				push af  
39d2 3a e6 39			ld a, (.dmark)  
39d5 32 6e fe			ld (debug_mark),a  
39d8 3a e7 39			ld a, (.dmark+1)  
39db 32 6f fe			ld (debug_mark+1),a  
39de 3a e8 39			ld a, (.dmark+2)  
39e1 32 70 fe			ld (debug_mark+2),a  
39e4 18 03			jr .pastdmark  
39e6 ..			.dmark: db "SUB"  
39e9 f1			.pastdmark: pop af  
39ea			endm  
# End of macro DMARK
39ea						CALLMONITOR 
39ea cd f3 18			call break_point_state  
39ed				endm  
# End of macro CALLMONITOR
39ed					endif 
39ed			 
39ed			 
39ed				; TODO add floating point number detection 
39ed					; v5 FORTH_DSP_VALUE 
39ed					FORTH_DSP 
39ed cd 24 21			call macro_forth_dsp 
39f0				endm 
# End of macro FORTH_DSP
39f0 7e					ld a,(hl)	; get type of value on TOS 
39f1 fe 02				cp DS_TYPE_INUM  
39f3 28 03				jr z, .neg_inum 
39f5			 
39f5					NEXTW 
39f5 c3 14 23			jp macro_next 
39f8				endm 
# End of macro NEXTW
39f8			 
39f8			; float maths 
39f8			 
39f8				if FORTH_ENABLE_FLOATMATH 
39f8					jr .neg_done 
39f8			 
39f8				endif 
39f8					 
39f8			 
39f8			.neg_inum: 
39f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f8 cd 5e 21			call macro_dsp_valuehl 
39fb				endm 
# End of macro FORTH_DSP_VALUEHL
39fb			 
39fb e5					push hl 
39fc			 
39fc					; destroy value TOS 
39fc			 
39fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39fc cd 16 22			call macro_forth_dsp_pop 
39ff				endm 
# End of macro FORTH_DSP_POP
39ff			 
39ff			 
39ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ff cd 5e 21			call macro_dsp_valuehl 
3a02				endm 
# End of macro FORTH_DSP_VALUEHL
3a02			 
3a02					; one value on hl get other one back 
3a02			 
3a02 d1					pop de 
3a03			 
3a03					; do the sub 
3a03			;		ex de, hl 
3a03			 
3a03 ed 52				sbc hl,de 
3a05			 
3a05					; save it 
3a05			 
3a05			;		push hl	 
3a05			 
3a05					; 
3a05			 
3a05					; destroy value TOS 
3a05			 
3a05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a05 cd 16 22			call macro_forth_dsp_pop 
3a08				endm 
# End of macro FORTH_DSP_POP
3a08			 
3a08					; TODO push value back onto stack for another op etc 
3a08			 
3a08			;		pop hl 
3a08			 
3a08 cd 67 1f				call forth_push_numhl 
3a0b			.neg_done: 
3a0b			 
3a0b					NEXTW 
3a0b c3 14 23			jp macro_next 
3a0e				endm 
# End of macro NEXTW
3a0e			.DIV: 
3a0e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a0e 18				db WORD_SYS_CORE+4             
3a0f 5b 3a			dw .MUL            
3a11 02				db 1 + 1 
3a12 .. 00			db "/",0              
3a14				endm 
# End of macro CWHEAD
3a14			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a14					if DEBUG_FORTH_WORDS_KEY 
3a14						DMARK "DIV" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 6e fe			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 6f fe			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 70 fe			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "DIV"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d						CALLMONITOR 
3a2d cd f3 18			call break_point_state  
3a30				endm  
# End of macro CALLMONITOR
3a30					endif 
3a30				; TODO add floating point number detection 
3a30					; v5 FORTH_DSP_VALUE 
3a30					FORTH_DSP 
3a30 cd 24 21			call macro_forth_dsp 
3a33				endm 
# End of macro FORTH_DSP
3a33 7e					ld a,(hl)	; get type of value on TOS 
3a34 fe 02				cp DS_TYPE_INUM  
3a36 28 03				jr z, .div_inum 
3a38			 
3a38				if FORTH_ENABLE_FLOATMATH 
3a38					jr .div_done 
3a38			 
3a38				endif 
3a38					NEXTW 
3a38 c3 14 23			jp macro_next 
3a3b				endm 
# End of macro NEXTW
3a3b			.div_inum: 
3a3b			 
3a3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3b cd 5e 21			call macro_dsp_valuehl 
3a3e				endm 
# End of macro FORTH_DSP_VALUEHL
3a3e			 
3a3e e5					push hl    ; to go to bc 
3a3f			 
3a3f					; destroy value TOS 
3a3f			 
3a3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3f cd 16 22			call macro_forth_dsp_pop 
3a42				endm 
# End of macro FORTH_DSP_POP
3a42			 
3a42			 
3a42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a42 cd 5e 21			call macro_dsp_valuehl 
3a45				endm 
# End of macro FORTH_DSP_VALUEHL
3a45			 
3a45					; hl to go to de 
3a45			 
3a45 e5					push hl 
3a46			 
3a46 c1					pop bc 
3a47 d1					pop de		 
3a48			 
3a48			 
3a48					if DEBUG_FORTH_MATHS 
3a48						DMARK "DIV" 
3a48				CALLMONITOR 
3a48					endif 
3a48					; one value on hl but move to a get other one back 
3a48			 
3a48			        
3a48 cd a9 0e			call Div16 
3a4b			 
3a4b			;	push af	 
3a4b e5				push hl 
3a4c c5				push bc 
3a4d			 
3a4d					if DEBUG_FORTH_MATHS 
3a4d						DMARK "DI1" 
3a4d				CALLMONITOR 
3a4d					endif 
3a4d			 
3a4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a4d cd 16 22			call macro_forth_dsp_pop 
3a50				endm 
# End of macro FORTH_DSP_POP
3a50			 
3a50			 
3a50			 
3a50 e1					pop hl    ; result 
3a51			 
3a51 cd 67 1f				call forth_push_numhl 
3a54			 
3a54 e1					pop hl    ; reminder 
3a55			;		ld h,0 
3a55			;		ld l,d 
3a55			 
3a55 cd 67 1f				call forth_push_numhl 
3a58			.div_done: 
3a58					NEXTW 
3a58 c3 14 23			jp macro_next 
3a5b				endm 
# End of macro NEXTW
3a5b			.MUL: 
3a5b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a5b 19				db WORD_SYS_CORE+5             
3a5c a0 3a			dw .MIN            
3a5e 02				db 1 + 1 
3a5f .. 00			db "*",0              
3a61				endm 
# End of macro CWHEAD
3a61			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a61				; TODO add floating point number detection 
3a61					if DEBUG_FORTH_WORDS_KEY 
3a61						DMARK "MUL" 
3a61 f5				push af  
3a62 3a 76 3a			ld a, (.dmark)  
3a65 32 6e fe			ld (debug_mark),a  
3a68 3a 77 3a			ld a, (.dmark+1)  
3a6b 32 6f fe			ld (debug_mark+1),a  
3a6e 3a 78 3a			ld a, (.dmark+2)  
3a71 32 70 fe			ld (debug_mark+2),a  
3a74 18 03			jr .pastdmark  
3a76 ..			.dmark: db "MUL"  
3a79 f1			.pastdmark: pop af  
3a7a			endm  
# End of macro DMARK
3a7a						CALLMONITOR 
3a7a cd f3 18			call break_point_state  
3a7d				endm  
# End of macro CALLMONITOR
3a7d					endif 
3a7d					FORTH_DSP 
3a7d cd 24 21			call macro_forth_dsp 
3a80				endm 
# End of macro FORTH_DSP
3a80					; v5 FORTH_DSP_VALUE 
3a80 7e					ld a,(hl)	; get type of value on TOS 
3a81 fe 02				cp DS_TYPE_INUM  
3a83 28 03				jr z, .mul_inum 
3a85			 
3a85				if FORTH_ENABLE_FLOATMATH 
3a85					jr .mul_done 
3a85			 
3a85				endif 
3a85			 
3a85					NEXTW 
3a85 c3 14 23			jp macro_next 
3a88				endm 
# End of macro NEXTW
3a88			.mul_inum:	 
3a88			 
3a88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a88 cd 5e 21			call macro_dsp_valuehl 
3a8b				endm 
# End of macro FORTH_DSP_VALUEHL
3a8b			 
3a8b e5					push hl 
3a8c			 
3a8c					; destroy value TOS 
3a8c			 
3a8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8c cd 16 22			call macro_forth_dsp_pop 
3a8f				endm 
# End of macro FORTH_DSP_POP
3a8f			 
3a8f			 
3a8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a8f cd 5e 21			call macro_dsp_valuehl 
3a92				endm 
# End of macro FORTH_DSP_VALUEHL
3a92			 
3a92					; one value on hl but move to a get other one back 
3a92			 
3a92 7d					ld a, l 
3a93			 
3a93 d1					pop de 
3a94			 
3a94					; do the mull 
3a94			;		ex de, hl 
3a94			 
3a94 cd cf 0e				call Mult16 
3a97					; save it 
3a97			 
3a97			;		push hl	 
3a97			 
3a97					; 
3a97			 
3a97					; destroy value TOS 
3a97			 
3a97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a97 cd 16 22			call macro_forth_dsp_pop 
3a9a				endm 
# End of macro FORTH_DSP_POP
3a9a			 
3a9a					; TODO push value back onto stack for another op etc 
3a9a			 
3a9a			;		pop hl 
3a9a			 
3a9a cd 67 1f				call forth_push_numhl 
3a9d			 
3a9d			.mul_done: 
3a9d					NEXTW 
3a9d c3 14 23			jp macro_next 
3aa0				endm 
# End of macro NEXTW
3aa0			 
3aa0			 
3aa0			 
3aa0			 
3aa0			.MIN: 
3aa0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3aa0 49				db WORD_SYS_CORE+53             
3aa1 21 3b			dw .MAX            
3aa3 04				db 3 + 1 
3aa4 .. 00			db "MIN",0              
3aa8				endm 
# End of macro CWHEAD
3aa8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3aa8					if DEBUG_FORTH_WORDS_KEY 
3aa8						DMARK "MIN" 
3aa8 f5				push af  
3aa9 3a bd 3a			ld a, (.dmark)  
3aac 32 6e fe			ld (debug_mark),a  
3aaf 3a be 3a			ld a, (.dmark+1)  
3ab2 32 6f fe			ld (debug_mark+1),a  
3ab5 3a bf 3a			ld a, (.dmark+2)  
3ab8 32 70 fe			ld (debug_mark+2),a  
3abb 18 03			jr .pastdmark  
3abd ..			.dmark: db "MIN"  
3ac0 f1			.pastdmark: pop af  
3ac1			endm  
# End of macro DMARK
3ac1						CALLMONITOR 
3ac1 cd f3 18			call break_point_state  
3ac4				endm  
# End of macro CALLMONITOR
3ac4					endif 
3ac4					; get u2 
3ac4			 
3ac4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac4 cd 5e 21			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 e5					push hl   ; u2 
3ac8			 
3ac8					; destroy value TOS 
3ac8			 
3ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac8 cd 16 22			call macro_forth_dsp_pop 
3acb				endm 
# End of macro FORTH_DSP_POP
3acb			 
3acb					; get u1 
3acb			 
3acb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3acb cd 5e 21			call macro_dsp_valuehl 
3ace				endm 
# End of macro FORTH_DSP_VALUEHL
3ace			 
3ace e5					push hl  ; u1 
3acf			 
3acf					; destroy value TOS 
3acf			 
3acf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3acf cd 16 22			call macro_forth_dsp_pop 
3ad2				endm 
# End of macro FORTH_DSP_POP
3ad2			 
3ad2 b7			 or a      ;clear carry flag 
3ad3 e1			  pop hl    ; u1 
3ad4 d1			  pop de    ; u2 
3ad5 e5				push hl   ; saved in case hl is lowest 
3ad6 ed 52		  sbc hl,de 
3ad8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3ada			 
3ada e1				pop hl 
3adb					if DEBUG_FORTH_WORDS 
3adb						DMARK "MIN" 
3adb f5				push af  
3adc 3a f0 3a			ld a, (.dmark)  
3adf 32 6e fe			ld (debug_mark),a  
3ae2 3a f1 3a			ld a, (.dmark+1)  
3ae5 32 6f fe			ld (debug_mark+1),a  
3ae8 3a f2 3a			ld a, (.dmark+2)  
3aeb 32 70 fe			ld (debug_mark+2),a  
3aee 18 03			jr .pastdmark  
3af0 ..			.dmark: db "MIN"  
3af3 f1			.pastdmark: pop af  
3af4			endm  
# End of macro DMARK
3af4						CALLMONITOR 
3af4 cd f3 18			call break_point_state  
3af7				endm  
# End of macro CALLMONITOR
3af7					endif 
3af7 cd 67 1f				call forth_push_numhl 
3afa			 
3afa				       NEXTW 
3afa c3 14 23			jp macro_next 
3afd				endm 
# End of macro NEXTW
3afd			 
3afd			.mincont:  
3afd c1				pop bc   ; tidy up 
3afe eb				ex de , hl  
3aff					if DEBUG_FORTH_WORDS 
3aff						DMARK "MI1" 
3aff f5				push af  
3b00 3a 14 3b			ld a, (.dmark)  
3b03 32 6e fe			ld (debug_mark),a  
3b06 3a 15 3b			ld a, (.dmark+1)  
3b09 32 6f fe			ld (debug_mark+1),a  
3b0c 3a 16 3b			ld a, (.dmark+2)  
3b0f 32 70 fe			ld (debug_mark+2),a  
3b12 18 03			jr .pastdmark  
3b14 ..			.dmark: db "MI1"  
3b17 f1			.pastdmark: pop af  
3b18			endm  
# End of macro DMARK
3b18						CALLMONITOR 
3b18 cd f3 18			call break_point_state  
3b1b				endm  
# End of macro CALLMONITOR
3b1b					endif 
3b1b cd 67 1f				call forth_push_numhl 
3b1e			 
3b1e				       NEXTW 
3b1e c3 14 23			jp macro_next 
3b21				endm 
# End of macro NEXTW
3b21			.MAX: 
3b21				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b21 4a				db WORD_SYS_CORE+54             
3b22 a2 3b			dw .RND16            
3b24 04				db 3 + 1 
3b25 .. 00			db "MAX",0              
3b29				endm 
# End of macro CWHEAD
3b29			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b29					if DEBUG_FORTH_WORDS_KEY 
3b29						DMARK "MAX" 
3b29 f5				push af  
3b2a 3a 3e 3b			ld a, (.dmark)  
3b2d 32 6e fe			ld (debug_mark),a  
3b30 3a 3f 3b			ld a, (.dmark+1)  
3b33 32 6f fe			ld (debug_mark+1),a  
3b36 3a 40 3b			ld a, (.dmark+2)  
3b39 32 70 fe			ld (debug_mark+2),a  
3b3c 18 03			jr .pastdmark  
3b3e ..			.dmark: db "MAX"  
3b41 f1			.pastdmark: pop af  
3b42			endm  
# End of macro DMARK
3b42						CALLMONITOR 
3b42 cd f3 18			call break_point_state  
3b45				endm  
# End of macro CALLMONITOR
3b45					endif 
3b45					; get u2 
3b45			 
3b45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b45 cd 5e 21			call macro_dsp_valuehl 
3b48				endm 
# End of macro FORTH_DSP_VALUEHL
3b48			 
3b48 e5					push hl   ; u2 
3b49			 
3b49					; destroy value TOS 
3b49			 
3b49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b49 cd 16 22			call macro_forth_dsp_pop 
3b4c				endm 
# End of macro FORTH_DSP_POP
3b4c			 
3b4c					; get u1 
3b4c			 
3b4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b4c cd 5e 21			call macro_dsp_valuehl 
3b4f				endm 
# End of macro FORTH_DSP_VALUEHL
3b4f			 
3b4f e5					push hl  ; u1 
3b50			 
3b50					; destroy value TOS 
3b50			 
3b50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b50 cd 16 22			call macro_forth_dsp_pop 
3b53				endm 
# End of macro FORTH_DSP_POP
3b53			 
3b53 b7			 or a      ;clear carry flag 
3b54 e1			  pop hl    ; u1 
3b55 d1			  pop de    ; u2 
3b56 e5				push hl   ; saved in case hl is lowest 
3b57 ed 52		  sbc hl,de 
3b59 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b5b			 
3b5b e1				pop hl 
3b5c					if DEBUG_FORTH_WORDS 
3b5c						DMARK "MAX" 
3b5c f5				push af  
3b5d 3a 71 3b			ld a, (.dmark)  
3b60 32 6e fe			ld (debug_mark),a  
3b63 3a 72 3b			ld a, (.dmark+1)  
3b66 32 6f fe			ld (debug_mark+1),a  
3b69 3a 73 3b			ld a, (.dmark+2)  
3b6c 32 70 fe			ld (debug_mark+2),a  
3b6f 18 03			jr .pastdmark  
3b71 ..			.dmark: db "MAX"  
3b74 f1			.pastdmark: pop af  
3b75			endm  
# End of macro DMARK
3b75						CALLMONITOR 
3b75 cd f3 18			call break_point_state  
3b78				endm  
# End of macro CALLMONITOR
3b78					endif 
3b78 cd 67 1f				call forth_push_numhl 
3b7b			 
3b7b				       NEXTW 
3b7b c3 14 23			jp macro_next 
3b7e				endm 
# End of macro NEXTW
3b7e			 
3b7e			.maxcont:  
3b7e c1				pop bc   ; tidy up 
3b7f eb				ex de , hl  
3b80					if DEBUG_FORTH_WORDS 
3b80						DMARK "MA1" 
3b80 f5				push af  
3b81 3a 95 3b			ld a, (.dmark)  
3b84 32 6e fe			ld (debug_mark),a  
3b87 3a 96 3b			ld a, (.dmark+1)  
3b8a 32 6f fe			ld (debug_mark+1),a  
3b8d 3a 97 3b			ld a, (.dmark+2)  
3b90 32 70 fe			ld (debug_mark+2),a  
3b93 18 03			jr .pastdmark  
3b95 ..			.dmark: db "MA1"  
3b98 f1			.pastdmark: pop af  
3b99			endm  
# End of macro DMARK
3b99						CALLMONITOR 
3b99 cd f3 18			call break_point_state  
3b9c				endm  
# End of macro CALLMONITOR
3b9c					endif 
3b9c cd 67 1f				call forth_push_numhl 
3b9f				       NEXTW 
3b9f c3 14 23			jp macro_next 
3ba2				endm 
# End of macro NEXTW
3ba2			 
3ba2			.RND16: 
3ba2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ba2 4e				db WORD_SYS_CORE+58             
3ba3 d1 3b			dw .RND8            
3ba5 06				db 5 + 1 
3ba6 .. 00			db "RND16",0              
3bac				endm 
# End of macro CWHEAD
3bac			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3bac					if DEBUG_FORTH_WORDS_KEY 
3bac						DMARK "R16" 
3bac f5				push af  
3bad 3a c1 3b			ld a, (.dmark)  
3bb0 32 6e fe			ld (debug_mark),a  
3bb3 3a c2 3b			ld a, (.dmark+1)  
3bb6 32 6f fe			ld (debug_mark+1),a  
3bb9 3a c3 3b			ld a, (.dmark+2)  
3bbc 32 70 fe			ld (debug_mark+2),a  
3bbf 18 03			jr .pastdmark  
3bc1 ..			.dmark: db "R16"  
3bc4 f1			.pastdmark: pop af  
3bc5			endm  
# End of macro DMARK
3bc5						CALLMONITOR 
3bc5 cd f3 18			call break_point_state  
3bc8				endm  
# End of macro CALLMONITOR
3bc8					endif 
3bc8 cd 73 0e				call prng16  
3bcb cd 67 1f				call forth_push_numhl 
3bce				       NEXTW 
3bce c3 14 23			jp macro_next 
3bd1				endm 
# End of macro NEXTW
3bd1			.RND8: 
3bd1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bd1 60				db WORD_SYS_CORE+76             
3bd2 06 3c			dw .RND            
3bd4 05				db 4 + 1 
3bd5 .. 00			db "RND8",0              
3bda				endm 
# End of macro CWHEAD
3bda			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bda					if DEBUG_FORTH_WORDS_KEY 
3bda						DMARK "RN8" 
3bda f5				push af  
3bdb 3a ef 3b			ld a, (.dmark)  
3bde 32 6e fe			ld (debug_mark),a  
3be1 3a f0 3b			ld a, (.dmark+1)  
3be4 32 6f fe			ld (debug_mark+1),a  
3be7 3a f1 3b			ld a, (.dmark+2)  
3bea 32 70 fe			ld (debug_mark+2),a  
3bed 18 03			jr .pastdmark  
3bef ..			.dmark: db "RN8"  
3bf2 f1			.pastdmark: pop af  
3bf3			endm  
# End of macro DMARK
3bf3						CALLMONITOR 
3bf3 cd f3 18			call break_point_state  
3bf6				endm  
# End of macro CALLMONITOR
3bf6					endif 
3bf6 2a af fb				ld hl,(xrandc) 
3bf9 23					inc hl 
3bfa cd 8d 0e				call xrnd 
3bfd 6f					ld l,a	 
3bfe 26 00				ld h,0 
3c00 cd 67 1f				call forth_push_numhl 
3c03				       NEXTW 
3c03 c3 14 23			jp macro_next 
3c06				endm 
# End of macro NEXTW
3c06			.RND: 
3c06				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c06 60				db WORD_SYS_CORE+76             
3c07 0c 3d			dw .ENDMATHS            
3c09 04				db 3 + 1 
3c0a .. 00			db "RND",0              
3c0e				endm 
# End of macro CWHEAD
3c0e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c0e			 
3c0e					if DEBUG_FORTH_WORDS_KEY 
3c0e						DMARK "RND" 
3c0e f5				push af  
3c0f 3a 23 3c			ld a, (.dmark)  
3c12 32 6e fe			ld (debug_mark),a  
3c15 3a 24 3c			ld a, (.dmark+1)  
3c18 32 6f fe			ld (debug_mark+1),a  
3c1b 3a 25 3c			ld a, (.dmark+2)  
3c1e 32 70 fe			ld (debug_mark+2),a  
3c21 18 03			jr .pastdmark  
3c23 ..			.dmark: db "RND"  
3c26 f1			.pastdmark: pop af  
3c27			endm  
# End of macro DMARK
3c27						CALLMONITOR 
3c27 cd f3 18			call break_point_state  
3c2a				endm  
# End of macro CALLMONITOR
3c2a					endif 
3c2a					 
3c2a					FORTH_DSP_VALUEHL    ; upper range 
3c2a cd 5e 21			call macro_dsp_valuehl 
3c2d				endm 
# End of macro FORTH_DSP_VALUEHL
3c2d			 
3c2d 22 b3 fb				ld (LFSRSeed), hl	 
3c30			 
3c30					if DEBUG_FORTH_WORDS 
3c30						DMARK "RN1" 
3c30 f5				push af  
3c31 3a 45 3c			ld a, (.dmark)  
3c34 32 6e fe			ld (debug_mark),a  
3c37 3a 46 3c			ld a, (.dmark+1)  
3c3a 32 6f fe			ld (debug_mark+1),a  
3c3d 3a 47 3c			ld a, (.dmark+2)  
3c40 32 70 fe			ld (debug_mark+2),a  
3c43 18 03			jr .pastdmark  
3c45 ..			.dmark: db "RN1"  
3c48 f1			.pastdmark: pop af  
3c49			endm  
# End of macro DMARK
3c49						CALLMONITOR 
3c49 cd f3 18			call break_point_state  
3c4c				endm  
# End of macro CALLMONITOR
3c4c					endif 
3c4c					FORTH_DSP_POP 
3c4c cd 16 22			call macro_forth_dsp_pop 
3c4f				endm 
# End of macro FORTH_DSP_POP
3c4f			 
3c4f					FORTH_DSP_VALUEHL    ; low range 
3c4f cd 5e 21			call macro_dsp_valuehl 
3c52				endm 
# End of macro FORTH_DSP_VALUEHL
3c52			 
3c52					if DEBUG_FORTH_WORDS 
3c52						DMARK "RN2" 
3c52 f5				push af  
3c53 3a 67 3c			ld a, (.dmark)  
3c56 32 6e fe			ld (debug_mark),a  
3c59 3a 68 3c			ld a, (.dmark+1)  
3c5c 32 6f fe			ld (debug_mark+1),a  
3c5f 3a 69 3c			ld a, (.dmark+2)  
3c62 32 70 fe			ld (debug_mark+2),a  
3c65 18 03			jr .pastdmark  
3c67 ..			.dmark: db "RN2"  
3c6a f1			.pastdmark: pop af  
3c6b			endm  
# End of macro DMARK
3c6b						CALLMONITOR 
3c6b cd f3 18			call break_point_state  
3c6e				endm  
# End of macro CALLMONITOR
3c6e					endif 
3c6e 22 b5 fb				ld (LFSRSeed+2), hl 
3c71			 
3c71					FORTH_DSP_POP 
3c71 cd 16 22			call macro_forth_dsp_pop 
3c74				endm 
# End of macro FORTH_DSP_POP
3c74			 
3c74 e5					push hl 
3c75			 
3c75 e1			.inrange:	pop hl 
3c76 cd 73 0e				call prng16  
3c79					if DEBUG_FORTH_WORDS 
3c79						DMARK "RN3" 
3c79 f5				push af  
3c7a 3a 8e 3c			ld a, (.dmark)  
3c7d 32 6e fe			ld (debug_mark),a  
3c80 3a 8f 3c			ld a, (.dmark+1)  
3c83 32 6f fe			ld (debug_mark+1),a  
3c86 3a 90 3c			ld a, (.dmark+2)  
3c89 32 70 fe			ld (debug_mark+2),a  
3c8c 18 03			jr .pastdmark  
3c8e ..			.dmark: db "RN3"  
3c91 f1			.pastdmark: pop af  
3c92			endm  
# End of macro DMARK
3c92						CALLMONITOR 
3c92 cd f3 18			call break_point_state  
3c95				endm  
# End of macro CALLMONITOR
3c95					endif 
3c95					 
3c95					; if the range is 8bit knock out the high byte 
3c95			 
3c95 ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3c99			 
3c99 3e 00				ld a, 0 
3c9b ba					cp d  
3c9c 20 1e				jr nz, .hirange 
3c9e 26 00				ld h, 0   ; knock it down to 8bit 
3ca0			 
3ca0					if DEBUG_FORTH_WORDS 
3ca0						DMARK "RNk" 
3ca0 f5				push af  
3ca1 3a b5 3c			ld a, (.dmark)  
3ca4 32 6e fe			ld (debug_mark),a  
3ca7 3a b6 3c			ld a, (.dmark+1)  
3caa 32 6f fe			ld (debug_mark+1),a  
3cad 3a b7 3c			ld a, (.dmark+2)  
3cb0 32 70 fe			ld (debug_mark+2),a  
3cb3 18 03			jr .pastdmark  
3cb5 ..			.dmark: db "RNk"  
3cb8 f1			.pastdmark: pop af  
3cb9			endm  
# End of macro DMARK
3cb9						CALLMONITOR 
3cb9 cd f3 18			call break_point_state  
3cbc				endm  
# End of macro CALLMONITOR
3cbc					endif 
3cbc			.hirange:   
3cbc e5					push hl  
3cbd b7					or a  
3cbe ed 52		                sbc hl, de 
3cc0			 
3cc0					;call cmp16 
3cc0			 
3cc0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3cc2 e1					pop hl 
3cc3 e5					push hl 
3cc4			 
3cc4					if DEBUG_FORTH_WORDS 
3cc4						DMARK "RN4" 
3cc4 f5				push af  
3cc5 3a d9 3c			ld a, (.dmark)  
3cc8 32 6e fe			ld (debug_mark),a  
3ccb 3a da 3c			ld a, (.dmark+1)  
3cce 32 6f fe			ld (debug_mark+1),a  
3cd1 3a db 3c			ld a, (.dmark+2)  
3cd4 32 70 fe			ld (debug_mark+2),a  
3cd7 18 03			jr .pastdmark  
3cd9 ..			.dmark: db "RN4"  
3cdc f1			.pastdmark: pop af  
3cdd			endm  
# End of macro DMARK
3cdd						CALLMONITOR 
3cdd cd f3 18			call break_point_state  
3ce0				endm  
# End of macro CALLMONITOR
3ce0					endif 
3ce0 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3ce4					;call cmp16 
3ce4				 
3ce4 b7					or a  
3ce5 ed 52		                sbc hl, de 
3ce7 38 8c				jr c, .inrange 
3ce9			 
3ce9 e1					pop hl 
3cea					 
3cea					if DEBUG_FORTH_WORDS 
3cea						DMARK "RNd" 
3cea f5				push af  
3ceb 3a ff 3c			ld a, (.dmark)  
3cee 32 6e fe			ld (debug_mark),a  
3cf1 3a 00 3d			ld a, (.dmark+1)  
3cf4 32 6f fe			ld (debug_mark+1),a  
3cf7 3a 01 3d			ld a, (.dmark+2)  
3cfa 32 70 fe			ld (debug_mark+2),a  
3cfd 18 03			jr .pastdmark  
3cff ..			.dmark: db "RNd"  
3d02 f1			.pastdmark: pop af  
3d03			endm  
# End of macro DMARK
3d03						CALLMONITOR 
3d03 cd f3 18			call break_point_state  
3d06				endm  
# End of macro CALLMONITOR
3d06					endif 
3d06			 
3d06			 
3d06 cd 67 1f				call forth_push_numhl 
3d09				       NEXTW 
3d09 c3 14 23			jp macro_next 
3d0c				endm 
# End of macro NEXTW
3d0c			 
3d0c			.ENDMATHS: 
3d0c			 
3d0c			; eof 
3d0c			 
# End of file forth_words_maths.asm
3d0c			include "forth_words_display.asm" 
3d0c			 
3d0c			; | ## Display Words 
3d0c			 
3d0c			.INFO: 
3d0c			 
3d0c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d0c 62				db WORD_SYS_CORE+78             
3d0d 29 3d			dw .ATP            
3d0f 05				db 4 + 1 
3d10 .. 00			db "INFO",0              
3d15				endm 
# End of macro CWHEAD
3d15			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d15					FORTH_DSP_VALUEHL 
3d15 cd 5e 21			call macro_dsp_valuehl 
3d18				endm 
# End of macro FORTH_DSP_VALUEHL
3d18			 
3d18					FORTH_DSP_POP 
3d18 cd 16 22			call macro_forth_dsp_pop 
3d1b				endm 
# End of macro FORTH_DSP_POP
3d1b			 
3d1b e5					push hl 
3d1c			 
3d1c					FORTH_DSP_VALUEHL 
3d1c cd 5e 21			call macro_dsp_valuehl 
3d1f				endm 
# End of macro FORTH_DSP_VALUEHL
3d1f			 
3d1f					FORTH_DSP_POP 
3d1f cd 16 22			call macro_forth_dsp_pop 
3d22				endm 
# End of macro FORTH_DSP_POP
3d22			 
3d22 d1					pop de 
3d23			 
3d23 cd a9 0c				call info_panel 
3d26			 
3d26			 
3d26					NEXTW 
3d26 c3 14 23			jp macro_next 
3d29				endm 
# End of macro NEXTW
3d29			.ATP: 
3d29				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3d29 62				db WORD_SYS_CORE+78             
3d2a a0 3d			dw .FB            
3d2c 04				db 3 + 1 
3d2d .. 00			db "AT?",0              
3d31				endm 
# End of macro CWHEAD
3d31			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d31					if DEBUG_FORTH_WORDS_KEY 
3d31						DMARK "AT?" 
3d31 f5				push af  
3d32 3a 46 3d			ld a, (.dmark)  
3d35 32 6e fe			ld (debug_mark),a  
3d38 3a 47 3d			ld a, (.dmark+1)  
3d3b 32 6f fe			ld (debug_mark+1),a  
3d3e 3a 48 3d			ld a, (.dmark+2)  
3d41 32 70 fe			ld (debug_mark+2),a  
3d44 18 03			jr .pastdmark  
3d46 ..			.dmark: db "AT?"  
3d49 f1			.pastdmark: pop af  
3d4a			endm  
# End of macro DMARK
3d4a						CALLMONITOR 
3d4a cd f3 18			call break_point_state  
3d4d				endm  
# End of macro CALLMONITOR
3d4d					endif 
3d4d 3a 65 fa				ld a, (f_cursor_ptr) 
3d50			 
3d50			if DEBUG_FORTH_WORDS 
3d50				DMARK "AT?" 
3d50 f5				push af  
3d51 3a 65 3d			ld a, (.dmark)  
3d54 32 6e fe			ld (debug_mark),a  
3d57 3a 66 3d			ld a, (.dmark+1)  
3d5a 32 6f fe			ld (debug_mark+1),a  
3d5d 3a 67 3d			ld a, (.dmark+2)  
3d60 32 70 fe			ld (debug_mark+2),a  
3d63 18 03			jr .pastdmark  
3d65 ..			.dmark: db "AT?"  
3d68 f1			.pastdmark: pop af  
3d69			endm  
# End of macro DMARK
3d69				CALLMONITOR 
3d69 cd f3 18			call break_point_state  
3d6c				endm  
# End of macro CALLMONITOR
3d6c			endif	 
3d6c					; count the number of rows 
3d6c			 
3d6c 06 00				ld b, 0 
3d6e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d6f d6 28				sub display_cols 
3d71 f2 77 3d				jp p, .atprunder 
3d74 04					inc b 
3d75 18 f7				jr .atpr 
3d77			.atprunder:	 
3d77			if DEBUG_FORTH_WORDS 
3d77				DMARK "A?2" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 6e fe			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 6f fe			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 70 fe			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "A?2"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90				CALLMONITOR 
3d90 cd f3 18			call break_point_state  
3d93				endm  
# End of macro CALLMONITOR
3d93			endif	 
3d93 26 00				ld h, 0 
3d95 69					ld l, c 
3d96 cd 67 1f				call forth_push_numhl 
3d99 68					ld l, b  
3d9a cd 67 1f				call forth_push_numhl 
3d9d			 
3d9d			 
3d9d				NEXTW 
3d9d c3 14 23			jp macro_next 
3da0				endm 
# End of macro NEXTW
3da0			 
3da0			.FB: 
3da0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3da0 1b				db WORD_SYS_CORE+7             
3da1 ee 3d			dw .EMIT            
3da3 03				db 2 + 1 
3da4 .. 00			db "FB",0              
3da7				endm 
# End of macro CWHEAD
3da7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3da7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3da7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3da7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3da7					if DEBUG_FORTH_WORDS_KEY 
3da7						DMARK "FB." 
3da7 f5				push af  
3da8 3a bc 3d			ld a, (.dmark)  
3dab 32 6e fe			ld (debug_mark),a  
3dae 3a bd 3d			ld a, (.dmark+1)  
3db1 32 6f fe			ld (debug_mark+1),a  
3db4 3a be 3d			ld a, (.dmark+2)  
3db7 32 70 fe			ld (debug_mark+2),a  
3dba 18 03			jr .pastdmark  
3dbc ..			.dmark: db "FB."  
3dbf f1			.pastdmark: pop af  
3dc0			endm  
# End of macro DMARK
3dc0						CALLMONITOR 
3dc0 cd f3 18			call break_point_state  
3dc3				endm  
# End of macro CALLMONITOR
3dc3					endif 
3dc3			 
3dc3					FORTH_DSP_VALUEHL 
3dc3 cd 5e 21			call macro_dsp_valuehl 
3dc6				endm 
# End of macro FORTH_DSP_VALUEHL
3dc6			 
3dc6 7d					ld a, l 
3dc7 fe 01				cp 1 
3dc9 20 05				jr nz, .fbn1 
3dcb 21 13 fd				ld hl, display_fb1 
3dce 18 15				jr .fbset 
3dd0 fe 02		.fbn1:		cp 2 
3dd2 20 05				jr nz, .fbn2 
3dd4 21 d1 fb				ld hl, display_fb2 
3dd7 18 0c				jr .fbset 
3dd9 fe 03		.fbn2:		cp 3 
3ddb 20 05				jr nz, .fbn3 
3ddd 21 72 fc				ld hl, display_fb3 
3de0 18 03				jr .fbset 
3de2			.fbn3:		 ; if invalid number select first 
3de2 21 13 fd				ld hl, display_fb1 
3de5 22 cf fb		.fbset:		ld (display_fb_active), hl 
3de8			 
3de8					FORTH_DSP_POP 
3de8 cd 16 22			call macro_forth_dsp_pop 
3deb				endm 
# End of macro FORTH_DSP_POP
3deb			 
3deb					NEXTW 
3deb c3 14 23			jp macro_next 
3dee				endm 
# End of macro NEXTW
3dee			 
3dee			 
3dee			.EMIT: 
3dee				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3dee 1b				db WORD_SYS_CORE+7             
3def 3f 3e			dw .DOTH            
3df1 05				db 4 + 1 
3df2 .. 00			db "EMIT",0              
3df7				endm 
# End of macro CWHEAD
3df7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3df7					; get value off TOS and display it 
3df7			 
3df7					if DEBUG_FORTH_WORDS_KEY 
3df7						DMARK "EMT" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 6e fe			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 6f fe			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 70 fe			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "EMT"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10						CALLMONITOR 
3e10 cd f3 18			call break_point_state  
3e13				endm  
# End of macro CALLMONITOR
3e13					endif 
3e13			 
3e13					FORTH_DSP_VALUEHL 
3e13 cd 5e 21			call macro_dsp_valuehl 
3e16				endm 
# End of macro FORTH_DSP_VALUEHL
3e16			 
3e16 7d					ld a,l 
3e17			 
3e17					; TODO write to display 
3e17			 
3e17 32 c6 f3				ld (os_input), a 
3e1a 3e 00				ld a, 0 
3e1c 32 c7 f3				ld (os_input+1), a 
3e1f					 
3e1f 3a 65 fa				ld a, (f_cursor_ptr) 
3e22 11 c6 f3				ld de, os_input 
3e25 cd 2b 0d				call str_at_display 
3e28			 
3e28			 
3e28 3a 43 fa				ld a,(cli_autodisplay) 
3e2b fe 00				cp 0 
3e2d 28 03				jr z, .enoupdate 
3e2f cd 3b 0d						call update_display 
3e32					.enoupdate: 
3e32			 
3e32 3a 65 fa				ld a, (f_cursor_ptr) 
3e35 3c					inc a 
3e36 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3e39			 
3e39			 
3e39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e39 cd 16 22			call macro_forth_dsp_pop 
3e3c				endm 
# End of macro FORTH_DSP_POP
3e3c			  
3e3c			 
3e3c					NEXTW 
3e3c c3 14 23			jp macro_next 
3e3f				endm 
# End of macro NEXTW
3e3f			.DOTH: 
3e3f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e3f 1c				db WORD_SYS_CORE+8             
3e40 6f 3e			dw .DOTF            
3e42 03				db 2 + 1 
3e43 .. 00			db ".-",0              
3e46				endm 
# End of macro CWHEAD
3e46			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e46					; get value off TOS and display it 
3e46					if DEBUG_FORTH_WORDS_KEY 
3e46						DMARK "DTD" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 6e fe			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 6f fe			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 70 fe			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "DTD"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd f3 18			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e64 3e 00			ld a, 0 
3e66 32 44 fa			ld (cli_mvdot), a 
3e69 c3 c6 3e			jp .dotgo 
3e6c				NEXTW 
3e6c c3 14 23			jp macro_next 
3e6f				endm 
# End of macro NEXTW
3e6f			.DOTF: 
3e6f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e6f 1c				db WORD_SYS_CORE+8             
3e70 9d 3e			dw .DOT            
3e72 03				db 2 + 1 
3e73 .. 00			db ".>",0              
3e76				endm 
# End of macro CWHEAD
3e76			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e76					; get value off TOS and display it 
3e76			        ; TODO BUG adds extra spaces 
3e76			        ; TODO BUG handle numerics? 
3e76					if DEBUG_FORTH_WORDS_KEY 
3e76						DMARK "DTC" 
3e76 f5				push af  
3e77 3a 8b 3e			ld a, (.dmark)  
3e7a 32 6e fe			ld (debug_mark),a  
3e7d 3a 8c 3e			ld a, (.dmark+1)  
3e80 32 6f fe			ld (debug_mark+1),a  
3e83 3a 8d 3e			ld a, (.dmark+2)  
3e86 32 70 fe			ld (debug_mark+2),a  
3e89 18 03			jr .pastdmark  
3e8b ..			.dmark: db "DTC"  
3e8e f1			.pastdmark: pop af  
3e8f			endm  
# End of macro DMARK
3e8f						CALLMONITOR 
3e8f cd f3 18			call break_point_state  
3e92				endm  
# End of macro CALLMONITOR
3e92					endif 
3e92 3e 01			ld a, 1 
3e94 32 44 fa			ld (cli_mvdot), a 
3e97 c3 c6 3e			jp .dotgo 
3e9a				NEXTW 
3e9a c3 14 23			jp macro_next 
3e9d				endm 
# End of macro NEXTW
3e9d			 
3e9d			.DOT: 
3e9d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e9d 1c				db WORD_SYS_CORE+8             
3e9e 79 40			dw .CLS            
3ea0 02				db 1 + 1 
3ea1 .. 00			db ".",0              
3ea3				endm 
# End of macro CWHEAD
3ea3			        ; | . ( u -- ) Display TOS | DONE 
3ea3					; get value off TOS and display it 
3ea3			 
3ea3					if DEBUG_FORTH_WORDS_KEY 
3ea3						DMARK "DOT" 
3ea3 f5				push af  
3ea4 3a b8 3e			ld a, (.dmark)  
3ea7 32 6e fe			ld (debug_mark),a  
3eaa 3a b9 3e			ld a, (.dmark+1)  
3ead 32 6f fe			ld (debug_mark+1),a  
3eb0 3a ba 3e			ld a, (.dmark+2)  
3eb3 32 70 fe			ld (debug_mark+2),a  
3eb6 18 03			jr .pastdmark  
3eb8 ..			.dmark: db "DOT"  
3ebb f1			.pastdmark: pop af  
3ebc			endm  
# End of macro DMARK
3ebc						CALLMONITOR 
3ebc cd f3 18			call break_point_state  
3ebf				endm  
# End of macro CALLMONITOR
3ebf					endif 
3ebf 3e 00			ld a, 0 
3ec1 32 44 fa			ld (cli_mvdot), a 
3ec4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ec6				 
3ec6			 
3ec6			.dotgo: 
3ec6			 
3ec6			; move up type to on stack for parserv5 
3ec6					FORTH_DSP 
3ec6 cd 24 21			call macro_forth_dsp 
3ec9				endm 
# End of macro FORTH_DSP
3ec9				;FORTH_DSP_VALUE  
3ec9			 
3ec9			if DEBUG_FORTH_DOT 
3ec9				DMARK "DOT" 
3ec9 f5				push af  
3eca 3a de 3e			ld a, (.dmark)  
3ecd 32 6e fe			ld (debug_mark),a  
3ed0 3a df 3e			ld a, (.dmark+1)  
3ed3 32 6f fe			ld (debug_mark+1),a  
3ed6 3a e0 3e			ld a, (.dmark+2)  
3ed9 32 70 fe			ld (debug_mark+2),a  
3edc 18 03			jr .pastdmark  
3ede ..			.dmark: db "DOT"  
3ee1 f1			.pastdmark: pop af  
3ee2			endm  
# End of macro DMARK
3ee2				CALLMONITOR 
3ee2 cd f3 18			call break_point_state  
3ee5				endm  
# End of macro CALLMONITOR
3ee5			endif	 
3ee5			;		.print: 
3ee5			 
3ee5 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ee6 23				inc hl   ; position to the actual value 
3ee7 fe 01			cp DS_TYPE_STR 
3ee9 20 06			jr nz, .dotnum1  
3eeb			 
3eeb			; display string 
3eeb				FORTH_DSP_VALUE  
3eeb cd 47 21			call macro_forth_dsp_value 
3eee				endm 
# End of macro FORTH_DSP_VALUE
3eee eb				ex de,hl 
3eef 18 49			jr .dotwrite 
3ef1			 
3ef1			.dotnum1: 
3ef1 fe 02			cp DS_TYPE_INUM 
3ef3 20 44			jr nz, .dotflot 
3ef5			 
3ef5			 
3ef5			; display number 
3ef5			 
3ef5			;	push hl 
3ef5			;	call clear_display 
3ef5			;	pop hl 
3ef5			 
3ef5 5e				ld e, (hl) 
3ef6 23				inc hl 
3ef7 56				ld d, (hl) 
3ef8 21 c8 f1			ld hl, scratch 
3efb			if DEBUG_FORTH_DOT 
3efb				DMARK "DT1" 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 6e fe			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 6f fe			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 70 fe			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "DT1"  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14				CALLMONITOR 
3f14 cd f3 18			call break_point_state  
3f17				endm  
# End of macro CALLMONITOR
3f17			endif	 
3f17			 
3f17 cd 59 13			call uitoa_16 
3f1a eb				ex de,hl 
3f1b			 
3f1b			if DEBUG_FORTH_DOT 
3f1b				DMARK "DT2" 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 6e fe			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 6f fe			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 70 fe			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "DT2"  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34				CALLMONITOR 
3f34 cd f3 18			call break_point_state  
3f37				endm  
# End of macro CALLMONITOR
3f37			endif	 
3f37			 
3f37			;	ld de, os_word_scratch 
3f37 18 01			jr .dotwrite 
3f39			 
3f39 00			.dotflot:   nop 
3f3a			; TODO print floating point number 
3f3a			 
3f3a			.dotwrite:		 
3f3a			 
3f3a					; if c is set then set all '-' to spaces 
3f3a					; need to also take into account .>  
3f3a			 
3f3a 3e 01				ld a, 1 
3f3c b9					cp c 
3f3d 20 67				jr nz, .nodashswap 
3f3f			 
3f3f					; DE has the string to write, working with HL 
3f3f			 
3f3f 06 ff				ld b, 255 
3f41 d5					push de 
3f42 e1					pop hl 
3f43			 
3f43			if DEBUG_FORTH_DOT 
3f43				DMARK "DT-" 
3f43 f5				push af  
3f44 3a 58 3f			ld a, (.dmark)  
3f47 32 6e fe			ld (debug_mark),a  
3f4a 3a 59 3f			ld a, (.dmark+1)  
3f4d 32 6f fe			ld (debug_mark+1),a  
3f50 3a 5a 3f			ld a, (.dmark+2)  
3f53 32 70 fe			ld (debug_mark+2),a  
3f56 18 03			jr .pastdmark  
3f58 ..			.dmark: db "DT-"  
3f5b f1			.pastdmark: pop af  
3f5c			endm  
# End of macro DMARK
3f5c				CALLMONITOR 
3f5c cd f3 18			call break_point_state  
3f5f				endm  
# End of macro CALLMONITOR
3f5f			endif	 
3f5f 7e			.dashscan:	ld a, (hl) 
3f60 fe 00				cp 0 
3f62 28 42				jr z, .nodashswap 
3f64 fe 2d				cp '-' 
3f66 20 03				jr nz, .dashskip 
3f68 3e 20				ld a, ' ' 
3f6a 77					ld (hl), a 
3f6b 23			.dashskip:	inc hl 
3f6c			if DEBUG_FORTH_DOT 
3f6c				DMARK "D-2" 
3f6c f5				push af  
3f6d 3a 81 3f			ld a, (.dmark)  
3f70 32 6e fe			ld (debug_mark),a  
3f73 3a 82 3f			ld a, (.dmark+1)  
3f76 32 6f fe			ld (debug_mark+1),a  
3f79 3a 83 3f			ld a, (.dmark+2)  
3f7c 32 70 fe			ld (debug_mark+2),a  
3f7f 18 03			jr .pastdmark  
3f81 ..			.dmark: db "D-2"  
3f84 f1			.pastdmark: pop af  
3f85			endm  
# End of macro DMARK
3f85				CALLMONITOR 
3f85 cd f3 18			call break_point_state  
3f88				endm  
# End of macro CALLMONITOR
3f88			endif	 
3f88 10 d5				djnz .dashscan 
3f8a			 
3f8a			if DEBUG_FORTH_DOT 
3f8a				DMARK "D-1" 
3f8a f5				push af  
3f8b 3a 9f 3f			ld a, (.dmark)  
3f8e 32 6e fe			ld (debug_mark),a  
3f91 3a a0 3f			ld a, (.dmark+1)  
3f94 32 6f fe			ld (debug_mark+1),a  
3f97 3a a1 3f			ld a, (.dmark+2)  
3f9a 32 70 fe			ld (debug_mark+2),a  
3f9d 18 03			jr .pastdmark  
3f9f ..			.dmark: db "D-1"  
3fa2 f1			.pastdmark: pop af  
3fa3			endm  
# End of macro DMARK
3fa3				CALLMONITOR 
3fa3 cd f3 18			call break_point_state  
3fa6				endm  
# End of macro CALLMONITOR
3fa6			endif	 
3fa6			 
3fa6			.nodashswap: 
3fa6			 
3fa6			if DEBUG_FORTH_DOT 
3fa6				DMARK "D-o" 
3fa6 f5				push af  
3fa7 3a bb 3f			ld a, (.dmark)  
3faa 32 6e fe			ld (debug_mark),a  
3fad 3a bc 3f			ld a, (.dmark+1)  
3fb0 32 6f fe			ld (debug_mark+1),a  
3fb3 3a bd 3f			ld a, (.dmark+2)  
3fb6 32 70 fe			ld (debug_mark+2),a  
3fb9 18 03			jr .pastdmark  
3fbb ..			.dmark: db "D-o"  
3fbe f1			.pastdmark: pop af  
3fbf			endm  
# End of macro DMARK
3fbf				CALLMONITOR 
3fbf cd f3 18			call break_point_state  
3fc2				endm  
# End of macro CALLMONITOR
3fc2			endif	 
3fc2			 
3fc2 d5					push de   ; save string start in case we need to advance print 
3fc3			 
3fc3 3a 65 fa				ld a, (f_cursor_ptr) 
3fc6 cd 2b 0d				call str_at_display 
3fc9 3a 43 fa				ld a,(cli_autodisplay) 
3fcc fe 00				cp 0 
3fce 28 03				jr z, .noupdate 
3fd0 cd 3b 0d						call update_display 
3fd3					.noupdate: 
3fd3			 
3fd3			 
3fd3					; see if we need to advance the print position 
3fd3			 
3fd3 e1					pop hl   ; get back string 
3fd4			;		ex de,hl 
3fd4			 
3fd4 3a 44 fa				ld a, (cli_mvdot) 
3fd7			if DEBUG_FORTH_DOT 
3fd7			;		ld e,a 
3fd7				DMARK "D>1" 
3fd7 f5				push af  
3fd8 3a ec 3f			ld a, (.dmark)  
3fdb 32 6e fe			ld (debug_mark),a  
3fde 3a ed 3f			ld a, (.dmark+1)  
3fe1 32 6f fe			ld (debug_mark+1),a  
3fe4 3a ee 3f			ld a, (.dmark+2)  
3fe7 32 70 fe			ld (debug_mark+2),a  
3fea 18 03			jr .pastdmark  
3fec ..			.dmark: db "D>1"  
3fef f1			.pastdmark: pop af  
3ff0			endm  
# End of macro DMARK
3ff0				CALLMONITOR 
3ff0 cd f3 18			call break_point_state  
3ff3				endm  
# End of macro CALLMONITOR
3ff3			endif	 
3ff3 fe 00				cp 0 
3ff5 28 44				jr z, .noadv 
3ff7					; yes, lets advance the print position 
3ff7 3e 00				ld a, 0 
3ff9 cd b5 13				call strlent 
3ffc			if DEBUG_FORTH_DOT 
3ffc				DMARK "D-?" 
3ffc f5				push af  
3ffd 3a 11 40			ld a, (.dmark)  
4000 32 6e fe			ld (debug_mark),a  
4003 3a 12 40			ld a, (.dmark+1)  
4006 32 6f fe			ld (debug_mark+1),a  
4009 3a 13 40			ld a, (.dmark+2)  
400c 32 70 fe			ld (debug_mark+2),a  
400f 18 03			jr .pastdmark  
4011 ..			.dmark: db "D-?"  
4014 f1			.pastdmark: pop af  
4015			endm  
# End of macro DMARK
4015				CALLMONITOR 
4015 cd f3 18			call break_point_state  
4018				endm  
# End of macro CALLMONITOR
4018			endif	 
4018 3a 65 fa				ld a, (f_cursor_ptr) 
401b 85					add a,l 
401c					;call addatohl 
401c					;ld a, l 
401c 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
401f			 
401f			if DEBUG_FORTH_DOT 
401f				DMARK "D->" 
401f f5				push af  
4020 3a 34 40			ld a, (.dmark)  
4023 32 6e fe			ld (debug_mark),a  
4026 3a 35 40			ld a, (.dmark+1)  
4029 32 6f fe			ld (debug_mark+1),a  
402c 3a 36 40			ld a, (.dmark+2)  
402f 32 70 fe			ld (debug_mark+2),a  
4032 18 03			jr .pastdmark  
4034 ..			.dmark: db "D->"  
4037 f1			.pastdmark: pop af  
4038			endm  
# End of macro DMARK
4038				CALLMONITOR 
4038 cd f3 18			call break_point_state  
403b				endm  
# End of macro CALLMONITOR
403b			endif	 
403b			 
403b			.noadv:	 
403b			 
403b					if DEBUG_FORTH_DOT_WAIT 
403b							call next_page_prompt 
403b					endif	 
403b			; TODO this pop off the stack causes a crash. i dont know why 
403b			 
403b			 
403b			if DEBUG_FORTH_DOT 
403b				DMARK "DTh" 
403b f5				push af  
403c 3a 50 40			ld a, (.dmark)  
403f 32 6e fe			ld (debug_mark),a  
4042 3a 51 40			ld a, (.dmark+1)  
4045 32 6f fe			ld (debug_mark+1),a  
4048 3a 52 40			ld a, (.dmark+2)  
404b 32 70 fe			ld (debug_mark+2),a  
404e 18 03			jr .pastdmark  
4050 ..			.dmark: db "DTh"  
4053 f1			.pastdmark: pop af  
4054			endm  
# End of macro DMARK
4054				CALLMONITOR 
4054 cd f3 18			call break_point_state  
4057				endm  
# End of macro CALLMONITOR
4057			endif	 
4057			 
4057					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4057 cd 16 22			call macro_forth_dsp_pop 
405a				endm 
# End of macro FORTH_DSP_POP
405a			 
405a			if DEBUG_FORTH_DOT 
405a				DMARK "DTi" 
405a f5				push af  
405b 3a 6f 40			ld a, (.dmark)  
405e 32 6e fe			ld (debug_mark),a  
4061 3a 70 40			ld a, (.dmark+1)  
4064 32 6f fe			ld (debug_mark+1),a  
4067 3a 71 40			ld a, (.dmark+2)  
406a 32 70 fe			ld (debug_mark+2),a  
406d 18 03			jr .pastdmark  
406f ..			.dmark: db "DTi"  
4072 f1			.pastdmark: pop af  
4073			endm  
# End of macro DMARK
4073				CALLMONITOR 
4073 cd f3 18			call break_point_state  
4076				endm  
# End of macro CALLMONITOR
4076			endif	 
4076			 
4076			 
4076					NEXTW 
4076 c3 14 23			jp macro_next 
4079				endm 
# End of macro NEXTW
4079			 
4079			.CLS: 
4079				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4079 35				db WORD_SYS_CORE+33             
407a a6 40			dw .DRAW            
407c 04				db 3 + 1 
407d .. 00			db "CLS",0              
4081				endm 
# End of macro CWHEAD
4081			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4081					if DEBUG_FORTH_WORDS_KEY 
4081						DMARK "CLS" 
4081 f5				push af  
4082 3a 96 40			ld a, (.dmark)  
4085 32 6e fe			ld (debug_mark),a  
4088 3a 97 40			ld a, (.dmark+1)  
408b 32 6f fe			ld (debug_mark+1),a  
408e 3a 98 40			ld a, (.dmark+2)  
4091 32 70 fe			ld (debug_mark+2),a  
4094 18 03			jr .pastdmark  
4096 ..			.dmark: db "CLS"  
4099 f1			.pastdmark: pop af  
409a			endm  
# End of macro DMARK
409a						CALLMONITOR 
409a cd f3 18			call break_point_state  
409d				endm  
# End of macro CALLMONITOR
409d					endif 
409d cd 18 0d				call clear_display 
40a0 c3 b4 41				jp .home		; and home cursor 
40a3					NEXTW 
40a3 c3 14 23			jp macro_next 
40a6				endm 
# End of macro NEXTW
40a6			 
40a6			.DRAW: 
40a6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
40a6 36				db WORD_SYS_CORE+34             
40a7 d1 40			dw .DUMP            
40a9 05				db 4 + 1 
40aa .. 00			db "DRAW",0              
40af				endm 
# End of macro CWHEAD
40af			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
40af					if DEBUG_FORTH_WORDS_KEY 
40af						DMARK "DRW" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 6e fe			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 6f fe			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 70 fe			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "DRW"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8						CALLMONITOR 
40c8 cd f3 18			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb					endif 
40cb cd 3b 0d				call update_display 
40ce					NEXTW 
40ce c3 14 23			jp macro_next 
40d1				endm 
# End of macro NEXTW
40d1			 
40d1			.DUMP: 
40d1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40d1 37				db WORD_SYS_CORE+35             
40d2 09 41			dw .CDUMP            
40d4 05				db 4 + 1 
40d5 .. 00			db "DUMP",0              
40da				endm 
# End of macro CWHEAD
40da			; | DUMP ( x -- ) With address x display dump   | DONE 
40da			; TODO pop address to use off of the stack 
40da					if DEBUG_FORTH_WORDS_KEY 
40da						DMARK "DUM" 
40da f5				push af  
40db 3a ef 40			ld a, (.dmark)  
40de 32 6e fe			ld (debug_mark),a  
40e1 3a f0 40			ld a, (.dmark+1)  
40e4 32 6f fe			ld (debug_mark+1),a  
40e7 3a f1 40			ld a, (.dmark+2)  
40ea 32 70 fe			ld (debug_mark+2),a  
40ed 18 03			jr .pastdmark  
40ef ..			.dmark: db "DUM"  
40f2 f1			.pastdmark: pop af  
40f3			endm  
# End of macro DMARK
40f3						CALLMONITOR 
40f3 cd f3 18			call break_point_state  
40f6				endm  
# End of macro CALLMONITOR
40f6					endif 
40f6 cd 18 0d				call clear_display 
40f9			 
40f9					; get address 
40f9			 
40f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f9 cd 5e 21			call macro_dsp_valuehl 
40fc				endm 
# End of macro FORTH_DSP_VALUEHL
40fc				 
40fc					; save it for cdump 
40fc			 
40fc 22 eb f4				ld (os_cur_ptr),hl 
40ff			 
40ff					; destroy value TOS 
40ff			 
40ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ff cd 16 22			call macro_forth_dsp_pop 
4102				endm 
# End of macro FORTH_DSP_POP
4102			 
4102 cd e7 1d				call dumpcont	; skip old style of param parsing	 
4105 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4106					NEXTW 
4106 c3 14 23			jp macro_next 
4109				endm 
# End of macro NEXTW
4109			.CDUMP: 
4109				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4109 38				db WORD_SYS_CORE+36             
410a 39 41			dw .DAT            
410c 06				db 5 + 1 
410d .. 00			db "CDUMP",0              
4113				endm 
# End of macro CWHEAD
4113			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4113					if DEBUG_FORTH_WORDS_KEY 
4113						DMARK "CDP" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 6e fe			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 6f fe			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 70 fe			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "CDP"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd f3 18			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f cd 18 0d				call clear_display 
4132 cd e7 1d				call dumpcont	 
4135 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4136					NEXTW 
4136 c3 14 23			jp macro_next 
4139				endm 
# End of macro NEXTW
4139			 
4139			 
4139			 
4139			 
4139			.DAT: 
4139				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4139 3d				db WORD_SYS_CORE+41             
413a 8f 41			dw .HOME            
413c 03				db 2 + 1 
413d .. 00			db "AT",0              
4140				endm 
# End of macro CWHEAD
4140			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4140					if DEBUG_FORTH_WORDS_KEY 
4140						DMARK "AT." 
4140 f5				push af  
4141 3a 55 41			ld a, (.dmark)  
4144 32 6e fe			ld (debug_mark),a  
4147 3a 56 41			ld a, (.dmark+1)  
414a 32 6f fe			ld (debug_mark+1),a  
414d 3a 57 41			ld a, (.dmark+2)  
4150 32 70 fe			ld (debug_mark+2),a  
4153 18 03			jr .pastdmark  
4155 ..			.dmark: db "AT."  
4158 f1			.pastdmark: pop af  
4159			endm  
# End of macro DMARK
4159						CALLMONITOR 
4159 cd f3 18			call break_point_state  
415c				endm  
# End of macro CALLMONITOR
415c					endif 
415c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
415c cd 5e 21			call macro_dsp_valuehl 
415f				endm 
# End of macro FORTH_DSP_VALUEHL
415f			 
415f			 
415f					; TODO save cursor row 
415f 7d					ld a,l 
4160 fe 02				cp 2 
4162 20 04				jr nz, .crow3 
4164 3e 28				ld a, display_row_2 
4166 18 12				jr .ccol1 
4168 fe 03		.crow3:		cp 3 
416a 20 04				jr nz, .crow4 
416c 3e 50				ld a, display_row_3 
416e 18 0a				jr .ccol1 
4170 fe 04		.crow4:		cp 4 
4172 20 04				jr nz, .crow1 
4174 3e 78				ld a, display_row_4 
4176 18 02				jr .ccol1 
4178 3e 00		.crow1:		ld a,display_row_1 
417a f5			.ccol1:		push af			; got row offset 
417b 6f					ld l,a 
417c 26 00				ld h,0 
417e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417e cd 16 22			call macro_forth_dsp_pop 
4181				endm 
# End of macro FORTH_DSP_POP
4181					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4181 cd 5e 21			call macro_dsp_valuehl 
4184				endm 
# End of macro FORTH_DSP_VALUEHL
4184					; TODO save cursor col 
4184 f1					pop af 
4185 85					add l		; add col offset 
4186 32 65 fa				ld (f_cursor_ptr), a 
4189					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4189 cd 16 22			call macro_forth_dsp_pop 
418c				endm 
# End of macro FORTH_DSP_POP
418c			 
418c					; calculate  
418c			 
418c					NEXTW 
418c c3 14 23			jp macro_next 
418f				endm 
# End of macro NEXTW
418f			 
418f			 
418f			.HOME: 
418f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
418f 41				db WORD_SYS_CORE+45             
4190 bc 41			dw .SPACE            
4192 05				db 4 + 1 
4193 .. 00			db "HOME",0              
4198				endm 
# End of macro CWHEAD
4198			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4198					if DEBUG_FORTH_WORDS_KEY 
4198						DMARK "HOM" 
4198 f5				push af  
4199 3a ad 41			ld a, (.dmark)  
419c 32 6e fe			ld (debug_mark),a  
419f 3a ae 41			ld a, (.dmark+1)  
41a2 32 6f fe			ld (debug_mark+1),a  
41a5 3a af 41			ld a, (.dmark+2)  
41a8 32 70 fe			ld (debug_mark+2),a  
41ab 18 03			jr .pastdmark  
41ad ..			.dmark: db "HOM"  
41b0 f1			.pastdmark: pop af  
41b1			endm  
# End of macro DMARK
41b1						CALLMONITOR 
41b1 cd f3 18			call break_point_state  
41b4				endm  
# End of macro CALLMONITOR
41b4					endif 
41b4 3e 00		.home:		ld a, 0		; and home cursor 
41b6 32 65 fa				ld (f_cursor_ptr), a 
41b9					NEXTW 
41b9 c3 14 23			jp macro_next 
41bc				endm 
# End of macro NEXTW
41bc			 
41bc			 
41bc			.SPACE: 
41bc				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
41bc 46				db WORD_SYS_CORE+50             
41bd ea 41			dw .SPACES            
41bf 03				db 2 + 1 
41c0 .. 00			db "BL",0              
41c3				endm 
# End of macro CWHEAD
41c3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
41c3					if DEBUG_FORTH_WORDS_KEY 
41c3						DMARK "BL." 
41c3 f5				push af  
41c4 3a d8 41			ld a, (.dmark)  
41c7 32 6e fe			ld (debug_mark),a  
41ca 3a d9 41			ld a, (.dmark+1)  
41cd 32 6f fe			ld (debug_mark+1),a  
41d0 3a da 41			ld a, (.dmark+2)  
41d3 32 70 fe			ld (debug_mark+2),a  
41d6 18 03			jr .pastdmark  
41d8 ..			.dmark: db "BL."  
41db f1			.pastdmark: pop af  
41dc			endm  
# End of macro DMARK
41dc						CALLMONITOR 
41dc cd f3 18			call break_point_state  
41df				endm  
# End of macro CALLMONITOR
41df					endif 
41df 21 e8 41				ld hl, .blstr 
41e2 cd d5 1f				call forth_push_str 
41e5					 
41e5				       NEXTW 
41e5 c3 14 23			jp macro_next 
41e8				endm 
# End of macro NEXTW
41e8			 
41e8 .. 00		.blstr: db " ", 0 
41ea			 
41ea			.SPACES: 
41ea				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41ea 47				db WORD_SYS_CORE+51             
41eb 85 42			dw .SCROLL            
41ed 07				db 6 + 1 
41ee .. 00			db "SPACES",0              
41f5				endm 
# End of macro CWHEAD
41f5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
41f5					if DEBUG_FORTH_WORDS_KEY 
41f5						DMARK "SPS" 
41f5 f5				push af  
41f6 3a 0a 42			ld a, (.dmark)  
41f9 32 6e fe			ld (debug_mark),a  
41fc 3a 0b 42			ld a, (.dmark+1)  
41ff 32 6f fe			ld (debug_mark+1),a  
4202 3a 0c 42			ld a, (.dmark+2)  
4205 32 70 fe			ld (debug_mark+2),a  
4208 18 03			jr .pastdmark  
420a ..			.dmark: db "SPS"  
420d f1			.pastdmark: pop af  
420e			endm  
# End of macro DMARK
420e						CALLMONITOR 
420e cd f3 18			call break_point_state  
4211				endm  
# End of macro CALLMONITOR
4211					endif 
4211			 
4211			 
4211					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4211 cd 5e 21			call macro_dsp_valuehl 
4214				endm 
# End of macro FORTH_DSP_VALUEHL
4214			 
4214			;		push hl    ; u 
4214					if DEBUG_FORTH_WORDS 
4214						DMARK "SPA" 
4214 f5				push af  
4215 3a 29 42			ld a, (.dmark)  
4218 32 6e fe			ld (debug_mark),a  
421b 3a 2a 42			ld a, (.dmark+1)  
421e 32 6f fe			ld (debug_mark+1),a  
4221 3a 2b 42			ld a, (.dmark+2)  
4224 32 70 fe			ld (debug_mark+2),a  
4227 18 03			jr .pastdmark  
4229 ..			.dmark: db "SPA"  
422c f1			.pastdmark: pop af  
422d			endm  
# End of macro DMARK
422d						CALLMONITOR 
422d cd f3 18			call break_point_state  
4230				endm  
# End of macro CALLMONITOR
4230					endif 
4230			 
4230					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4230 cd 16 22			call macro_forth_dsp_pop 
4233				endm 
# End of macro FORTH_DSP_POP
4233			;		pop hl 
4233 4d					ld c, l 
4234 06 00				ld b, 0 
4236 21 c8 f1				ld hl, scratch  
4239			 
4239					if DEBUG_FORTH_WORDS 
4239						DMARK "SP2" 
4239 f5				push af  
423a 3a 4e 42			ld a, (.dmark)  
423d 32 6e fe			ld (debug_mark),a  
4240 3a 4f 42			ld a, (.dmark+1)  
4243 32 6f fe			ld (debug_mark+1),a  
4246 3a 50 42			ld a, (.dmark+2)  
4249 32 70 fe			ld (debug_mark+2),a  
424c 18 03			jr .pastdmark  
424e ..			.dmark: db "SP2"  
4251 f1			.pastdmark: pop af  
4252			endm  
# End of macro DMARK
4252						CALLMONITOR 
4252 cd f3 18			call break_point_state  
4255				endm  
# End of macro CALLMONITOR
4255					endif 
4255 3e 20				ld a, ' ' 
4257 c5			.spaces1:	push bc 
4258 77					ld (hl),a 
4259 23					inc hl 
425a c1					pop bc 
425b 10 fa				djnz .spaces1 
425d 3e 00				ld a,0 
425f 77					ld (hl),a 
4260 21 c8 f1				ld hl, scratch 
4263					if DEBUG_FORTH_WORDS 
4263						DMARK "SP3" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 6e fe			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 6f fe			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 70 fe			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "SP3"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd f3 18			call break_point_state  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f cd d0 20				call forth_apush 
4282			 
4282				       NEXTW 
4282 c3 14 23			jp macro_next 
4285				endm 
# End of macro NEXTW
4285			 
4285			 
4285			 
4285			.SCROLL: 
4285				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4285 53				db WORD_SYS_CORE+63             
4286 b2 42			dw .SCROLLD            
4288 07				db 6 + 1 
4289 .. 00			db "SCROLL",0              
4290				endm 
# End of macro CWHEAD
4290			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4290					if DEBUG_FORTH_WORDS_KEY 
4290						DMARK "SCR" 
4290 f5				push af  
4291 3a a5 42			ld a, (.dmark)  
4294 32 6e fe			ld (debug_mark),a  
4297 3a a6 42			ld a, (.dmark+1)  
429a 32 6f fe			ld (debug_mark+1),a  
429d 3a a7 42			ld a, (.dmark+2)  
42a0 32 70 fe			ld (debug_mark+2),a  
42a3 18 03			jr .pastdmark  
42a5 ..			.dmark: db "SCR"  
42a8 f1			.pastdmark: pop af  
42a9			endm  
# End of macro DMARK
42a9						CALLMONITOR 
42a9 cd f3 18			call break_point_state  
42ac				endm  
# End of macro CALLMONITOR
42ac					endif 
42ac			 
42ac cd da 0c			call scroll_up 
42af			;	call update_display 
42af			 
42af					NEXTW 
42af c3 14 23			jp macro_next 
42b2				endm 
# End of macro NEXTW
42b2			 
42b2			 
42b2			 
42b2			;		; get dir 
42b2			; 
42b2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42b2			; 
42b2			;		push hl 
42b2			; 
42b2			;		; destroy value TOS 
42b2			; 
42b2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42b2			; 
42b2			;		; get count 
42b2			; 
42b2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42b2			; 
42b2			;		push hl 
42b2			; 
42b2			;		; destroy value TOS 
42b2			; 
42b2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42b2			; 
42b2			;		; one value on hl get other one back 
42b2			; 
42b2			;		pop bc    ; count 
42b2			; 
42b2			;		pop de   ; dir 
42b2			; 
42b2			; 
42b2			;		ld b, c 
42b2			; 
42b2			;.scrolldir:     push bc 
42b2			;		push de 
42b2			; 
42b2			;		ld a, 0 
42b2			;		cp e 
42b2			;		jr z, .scrollup  
42b2			;		call scroll_down 
42b2			;		jr .scrollnext 
42b2			;.scrollup:	call scroll_up 
42b2			; 
42b2			;		 
42b2			;.scrollnext: 
42b2			;		pop de 
42b2			;		pop bc 
42b2			;		djnz .scrolldir 
42b2			; 
42b2			; 
42b2			; 
42b2			; 
42b2			; 
42b2			;		NEXTW 
42b2			 
42b2			.SCROLLD: 
42b2				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
42b2 53				db WORD_SYS_CORE+63             
42b3 e0 42			dw .ATQ            
42b5 08				db 7 + 1 
42b6 .. 00			db "SCROLLD",0              
42be				endm 
# End of macro CWHEAD
42be			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
42be					if DEBUG_FORTH_WORDS_KEY 
42be						DMARK "SCD" 
42be f5				push af  
42bf 3a d3 42			ld a, (.dmark)  
42c2 32 6e fe			ld (debug_mark),a  
42c5 3a d4 42			ld a, (.dmark+1)  
42c8 32 6f fe			ld (debug_mark+1),a  
42cb 3a d5 42			ld a, (.dmark+2)  
42ce 32 70 fe			ld (debug_mark+2),a  
42d1 18 03			jr .pastdmark  
42d3 ..			.dmark: db "SCD"  
42d6 f1			.pastdmark: pop af  
42d7			endm  
# End of macro DMARK
42d7						CALLMONITOR 
42d7 cd f3 18			call break_point_state  
42da				endm  
# End of macro CALLMONITOR
42da					endif 
42da			 
42da cd fe 0c			call scroll_down 
42dd			;	call update_display 
42dd			 
42dd					NEXTW 
42dd c3 14 23			jp macro_next 
42e0				endm 
# End of macro NEXTW
42e0			 
42e0			 
42e0			.ATQ: 
42e0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42e0 62				db WORD_SYS_CORE+78             
42e1 3e 43			dw .AUTODSP            
42e3 04				db 3 + 1 
42e4 .. 00			db "AT@",0              
42e8				endm 
# End of macro CWHEAD
42e8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42e8					if DEBUG_FORTH_WORDS_KEY 
42e8						DMARK "ATA" 
42e8 f5				push af  
42e9 3a fd 42			ld a, (.dmark)  
42ec 32 6e fe			ld (debug_mark),a  
42ef 3a fe 42			ld a, (.dmark+1)  
42f2 32 6f fe			ld (debug_mark+1),a  
42f5 3a ff 42			ld a, (.dmark+2)  
42f8 32 70 fe			ld (debug_mark+2),a  
42fb 18 03			jr .pastdmark  
42fd ..			.dmark: db "ATA"  
4300 f1			.pastdmark: pop af  
4301			endm  
# End of macro DMARK
4301						CALLMONITOR 
4301 cd f3 18			call break_point_state  
4304				endm  
# End of macro CALLMONITOR
4304					endif 
4304			 
4304			 
4304					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4304 cd 5e 21			call macro_dsp_valuehl 
4307				endm 
# End of macro FORTH_DSP_VALUEHL
4307			 
4307					; TODO save cursor row 
4307 7d					ld a,l 
4308 fe 02				cp 2 
430a 20 04				jr nz, .crow3aq 
430c 3e 28				ld a, display_row_2 
430e 18 12				jr .ccol1aq 
4310 fe 03		.crow3aq:		cp 3 
4312 20 04				jr nz, .crow4aq 
4314 3e 50				ld a, display_row_3 
4316 18 0a				jr .ccol1aq 
4318 fe 04		.crow4aq:		cp 4 
431a 20 04				jr nz, .crow1aq 
431c 3e 78				ld a, display_row_4 
431e 18 02				jr .ccol1aq 
4320 3e 00		.crow1aq:		ld a,display_row_1 
4322 f5			.ccol1aq:		push af			; got row offset 
4323 6f					ld l,a 
4324 26 00				ld h,0 
4326					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4326 cd 16 22			call macro_forth_dsp_pop 
4329				endm 
# End of macro FORTH_DSP_POP
4329					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4329 cd 5e 21			call macro_dsp_valuehl 
432c				endm 
# End of macro FORTH_DSP_VALUEHL
432c					; TODO save cursor col 
432c f1					pop af 
432d 85					add l		; add col offset 
432e			 
432e					; add current frame buffer address 
432e 2a cf fb				ld hl, (display_fb_active) 
4331 cd 4c 0f				call addatohl 
4334			 
4334			 
4334			 
4334			 
4334					; get char frame buffer location offset in hl 
4334			 
4334 7e					ld a,(hl) 
4335 26 00				ld h, 0 
4337 6f					ld l, a 
4338			 
4338 cd 67 1f				call forth_push_numhl 
433b			 
433b			 
433b					NEXTW 
433b c3 14 23			jp macro_next 
433e				endm 
# End of macro NEXTW
433e			 
433e			.AUTODSP: 
433e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
433e 63				db WORD_SYS_CORE+79             
433f 54 43			dw .MENU            
4341 05				db 4 + 1 
4342 .. 00			db "ADSP",0              
4347				endm 
# End of macro CWHEAD
4347			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4347			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4347			 
4347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4347 cd 5e 21			call macro_dsp_valuehl 
434a				endm 
# End of macro FORTH_DSP_VALUEHL
434a			 
434a			;		push hl 
434a			 
434a					; destroy value TOS 
434a			 
434a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434a cd 16 22			call macro_forth_dsp_pop 
434d				endm 
# End of macro FORTH_DSP_POP
434d			 
434d			;		pop hl 
434d			 
434d 7d					ld a,l 
434e 32 43 fa				ld (cli_autodisplay), a 
4351				       NEXTW 
4351 c3 14 23			jp macro_next 
4354				endm 
# End of macro NEXTW
4354			 
4354			.MENU: 
4354				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4354 70				db WORD_SYS_CORE+92             
4355 fd 43			dw .ENDDISPLAY            
4357 05				db 4 + 1 
4358 .. 00			db "MENU",0              
435d				endm 
# End of macro CWHEAD
435d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
435d			 
435d			;		; get number of items on the stack 
435d			; 
435d				 
435d					FORTH_DSP_VALUEHL 
435d cd 5e 21			call macro_dsp_valuehl 
4360				endm 
# End of macro FORTH_DSP_VALUEHL
4360				 
4360					if DEBUG_FORTH_WORDS_KEY 
4360						DMARK "MNU" 
4360 f5				push af  
4361 3a 75 43			ld a, (.dmark)  
4364 32 6e fe			ld (debug_mark),a  
4367 3a 76 43			ld a, (.dmark+1)  
436a 32 6f fe			ld (debug_mark+1),a  
436d 3a 77 43			ld a, (.dmark+2)  
4370 32 70 fe			ld (debug_mark+2),a  
4373 18 03			jr .pastdmark  
4375 ..			.dmark: db "MNU"  
4378 f1			.pastdmark: pop af  
4379			endm  
# End of macro DMARK
4379						CALLMONITOR 
4379 cd f3 18			call break_point_state  
437c				endm  
# End of macro CALLMONITOR
437c					endif 
437c			 
437c 45					ld b, l	 
437d 05					dec b 
437e			 
437e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
437e cd 16 22			call macro_forth_dsp_pop 
4381				endm 
# End of macro FORTH_DSP_POP
4381			 
4381			 
4381					; go directly through the stack to pluck out the string pointers and build an array 
4381			 
4381			;		FORTH_DSP 
4381			 
4381					; hl contains top most stack item 
4381				 
4381 11 c8 f1				ld de, scratch 
4384			 
4384			.mbuild: 
4384			 
4384					FORTH_DSP_VALUEHL 
4384 cd 5e 21			call macro_dsp_valuehl 
4387				endm 
# End of macro FORTH_DSP_VALUEHL
4387			 
4387					if DEBUG_FORTH_WORDS 
4387						DMARK "MN3" 
4387 f5				push af  
4388 3a 9c 43			ld a, (.dmark)  
438b 32 6e fe			ld (debug_mark),a  
438e 3a 9d 43			ld a, (.dmark+1)  
4391 32 6f fe			ld (debug_mark+1),a  
4394 3a 9e 43			ld a, (.dmark+2)  
4397 32 70 fe			ld (debug_mark+2),a  
439a 18 03			jr .pastdmark  
439c ..			.dmark: db "MN3"  
439f f1			.pastdmark: pop af  
43a0			endm  
# End of macro DMARK
43a0						CALLMONITOR 
43a0 cd f3 18			call break_point_state  
43a3				endm  
# End of macro CALLMONITOR
43a3					endif 
43a3 eb					ex de, hl 
43a4 73					ld (hl), e 
43a5 23					inc hl 
43a6 72					ld (hl), d 
43a7 23					inc hl 
43a8 eb					ex de, hl 
43a9			 
43a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43a9 cd 16 22			call macro_forth_dsp_pop 
43ac				endm 
# End of macro FORTH_DSP_POP
43ac			 
43ac 10 d6				djnz .mbuild 
43ae			 
43ae					; done add term 
43ae			 
43ae eb					ex de, hl 
43af 36 00				ld (hl), 0 
43b1 23					inc hl 
43b2 36 00				ld (hl), 0 
43b4			 
43b4				 
43b4					 
43b4 21 c8 f1				ld hl, scratch 
43b7			 
43b7					if DEBUG_FORTH_WORDS 
43b7						DMARK "MNx" 
43b7 f5				push af  
43b8 3a cc 43			ld a, (.dmark)  
43bb 32 6e fe			ld (debug_mark),a  
43be 3a cd 43			ld a, (.dmark+1)  
43c1 32 6f fe			ld (debug_mark+1),a  
43c4 3a ce 43			ld a, (.dmark+2)  
43c7 32 70 fe			ld (debug_mark+2),a  
43ca 18 03			jr .pastdmark  
43cc ..			.dmark: db "MNx"  
43cf f1			.pastdmark: pop af  
43d0			endm  
# End of macro DMARK
43d0						CALLMONITOR 
43d0 cd f3 18			call break_point_state  
43d3				endm  
# End of macro CALLMONITOR
43d3					endif 
43d3			 
43d3			 
43d3			 
43d3 3e 00				ld a, 0 
43d5 cd 49 0d				call menu 
43d8			 
43d8			 
43d8 6f					ld l, a 
43d9 26 00				ld h, 0 
43db			 
43db					if DEBUG_FORTH_WORDS 
43db						DMARK "MNr" 
43db f5				push af  
43dc 3a f0 43			ld a, (.dmark)  
43df 32 6e fe			ld (debug_mark),a  
43e2 3a f1 43			ld a, (.dmark+1)  
43e5 32 6f fe			ld (debug_mark+1),a  
43e8 3a f2 43			ld a, (.dmark+2)  
43eb 32 70 fe			ld (debug_mark+2),a  
43ee 18 03			jr .pastdmark  
43f0 ..			.dmark: db "MNr"  
43f3 f1			.pastdmark: pop af  
43f4			endm  
# End of macro DMARK
43f4						CALLMONITOR 
43f4 cd f3 18			call break_point_state  
43f7				endm  
# End of macro CALLMONITOR
43f7					endif 
43f7			 
43f7 cd 67 1f				call forth_push_numhl 
43fa			 
43fa			 
43fa			 
43fa			 
43fa				       NEXTW 
43fa c3 14 23			jp macro_next 
43fd				endm 
# End of macro NEXTW
43fd			 
43fd			 
43fd			.ENDDISPLAY: 
43fd			 
43fd			; eof 
# End of file forth_words_display.asm
43fd			include "forth_words_str.asm" 
43fd			 
43fd			; | ## String Words 
43fd			 
43fd			.PTR:   
43fd			 
43fd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
43fd 48				db WORD_SYS_CORE+52             
43fe 2a 44			dw .STYPE            
4400 04				db 3 + 1 
4401 .. 00			db "PTR",0              
4405				endm 
# End of macro CWHEAD
4405			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4405			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4405			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4405			 
4405					if DEBUG_FORTH_WORDS_KEY 
4405						DMARK "PTR" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 6e fe			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 6f fe			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 70 fe			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "PTR"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd f3 18			call break_point_state  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421					FORTH_DSP_VALUEHL 
4421 cd 5e 21			call macro_dsp_valuehl 
4424				endm 
# End of macro FORTH_DSP_VALUEHL
4424 cd 67 1f				call forth_push_numhl 
4427			 
4427			 
4427					NEXTW 
4427 c3 14 23			jp macro_next 
442a				endm 
# End of macro NEXTW
442a			.STYPE: 
442a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
442a 48				db WORD_SYS_CORE+52             
442b 79 44			dw .UPPER            
442d 06				db 5 + 1 
442e .. 00			db "STYPE",0              
4434				endm 
# End of macro CWHEAD
4434			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4434					if DEBUG_FORTH_WORDS_KEY 
4434						DMARK "STY" 
4434 f5				push af  
4435 3a 49 44			ld a, (.dmark)  
4438 32 6e fe			ld (debug_mark),a  
443b 3a 4a 44			ld a, (.dmark+1)  
443e 32 6f fe			ld (debug_mark+1),a  
4441 3a 4b 44			ld a, (.dmark+2)  
4444 32 70 fe			ld (debug_mark+2),a  
4447 18 03			jr .pastdmark  
4449 ..			.dmark: db "STY"  
444c f1			.pastdmark: pop af  
444d			endm  
# End of macro DMARK
444d						CALLMONITOR 
444d cd f3 18			call break_point_state  
4450				endm  
# End of macro CALLMONITOR
4450					endif 
4450					FORTH_DSP 
4450 cd 24 21			call macro_forth_dsp 
4453				endm 
# End of macro FORTH_DSP
4453					;v5 FORTH_DSP_VALUE 
4453			 
4453 7e					ld a, (hl) 
4454			 
4454 f5					push af 
4455			 
4455			; Dont destroy TOS		FORTH_DSP_POP 
4455			 
4455 f1					pop af 
4456			 
4456 fe 01				cp DS_TYPE_STR 
4458 28 09				jr z, .typestr 
445a			 
445a fe 02				cp DS_TYPE_INUM 
445c 28 0a				jr z, .typeinum 
445e			 
445e 21 77 44				ld hl, .tna 
4461 18 0a				jr .tpush 
4463			 
4463 21 73 44		.typestr:	ld hl, .tstr 
4466 18 05				jr .tpush 
4468 21 75 44		.typeinum:	ld hl, .tinum 
446b 18 00				jr .tpush 
446d			 
446d			.tpush: 
446d			 
446d cd d5 1f				call forth_push_str 
4470			 
4470					NEXTW 
4470 c3 14 23			jp macro_next 
4473				endm 
# End of macro NEXTW
4473 .. 00		.tstr:	db "s",0 
4475 .. 00		.tinum:  db "i",0 
4477 .. 00		.tna:   db "?", 0 
4479			 
4479			 
4479			.UPPER: 
4479				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4479 48				db WORD_SYS_CORE+52             
447a b4 44			dw .LOWER            
447c 06				db 5 + 1 
447d .. 00			db "UPPER",0              
4483				endm 
# End of macro CWHEAD
4483			; | UPPER ( s -- s ) Upper case string s  | DONE 
4483					if DEBUG_FORTH_WORDS_KEY 
4483						DMARK "UPR" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 6e fe			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 6f fe			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 70 fe			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "UPR"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd f3 18			call break_point_state  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f			 
449f					FORTH_DSP 
449f cd 24 21			call macro_forth_dsp 
44a2				endm 
# End of macro FORTH_DSP
44a2					 
44a2			; TODO check is string type 
44a2			 
44a2					FORTH_DSP_VALUEHL 
44a2 cd 5e 21			call macro_dsp_valuehl 
44a5				endm 
# End of macro FORTH_DSP_VALUEHL
44a5			; get pointer to string in hl 
44a5			 
44a5 7e			.toup:		ld a, (hl) 
44a6 fe 00				cp 0 
44a8 28 07				jr z, .toupdone 
44aa			 
44aa cd b9 12				call to_upper 
44ad			 
44ad 77					ld (hl), a 
44ae 23					inc hl 
44af 18 f4				jr .toup 
44b1			 
44b1					 
44b1			 
44b1			 
44b1			; for each char convert to upper 
44b1					 
44b1			.toupdone: 
44b1			 
44b1			 
44b1					NEXTW 
44b1 c3 14 23			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			.LOWER: 
44b4				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
44b4 48				db WORD_SYS_CORE+52             
44b5 ef 44			dw .TCASE            
44b7 06				db 5 + 1 
44b8 .. 00			db "LOWER",0              
44be				endm 
# End of macro CWHEAD
44be			; | LOWER ( s -- s ) Lower case string s  | DONE 
44be					if DEBUG_FORTH_WORDS_KEY 
44be						DMARK "LWR" 
44be f5				push af  
44bf 3a d3 44			ld a, (.dmark)  
44c2 32 6e fe			ld (debug_mark),a  
44c5 3a d4 44			ld a, (.dmark+1)  
44c8 32 6f fe			ld (debug_mark+1),a  
44cb 3a d5 44			ld a, (.dmark+2)  
44ce 32 70 fe			ld (debug_mark+2),a  
44d1 18 03			jr .pastdmark  
44d3 ..			.dmark: db "LWR"  
44d6 f1			.pastdmark: pop af  
44d7			endm  
# End of macro DMARK
44d7						CALLMONITOR 
44d7 cd f3 18			call break_point_state  
44da				endm  
# End of macro CALLMONITOR
44da					endif 
44da			 
44da					FORTH_DSP 
44da cd 24 21			call macro_forth_dsp 
44dd				endm 
# End of macro FORTH_DSP
44dd					 
44dd			; TODO check is string type 
44dd			 
44dd					FORTH_DSP_VALUEHL 
44dd cd 5e 21			call macro_dsp_valuehl 
44e0				endm 
# End of macro FORTH_DSP_VALUEHL
44e0			; get pointer to string in hl 
44e0			 
44e0 7e			.tolow:		ld a, (hl) 
44e1 fe 00				cp 0 
44e3 28 07				jr z, .tolowdone 
44e5			 
44e5 cd c2 12				call to_lower 
44e8			 
44e8 77					ld (hl), a 
44e9 23					inc hl 
44ea 18 f4				jr .tolow 
44ec			 
44ec					 
44ec			 
44ec			 
44ec			; for each char convert to low 
44ec					 
44ec			.tolowdone: 
44ec					NEXTW 
44ec c3 14 23			jp macro_next 
44ef				endm 
# End of macro NEXTW
44ef			.TCASE: 
44ef				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44ef 48				db WORD_SYS_CORE+52             
44f0 25 46			dw .SUBSTR            
44f2 06				db 5 + 1 
44f3 .. 00			db "TCASE",0              
44f9				endm 
# End of macro CWHEAD
44f9			; | TCASE ( s -- s ) Title case string s  | DONE 
44f9					if DEBUG_FORTH_WORDS_KEY 
44f9						DMARK "TCS" 
44f9 f5				push af  
44fa 3a 0e 45			ld a, (.dmark)  
44fd 32 6e fe			ld (debug_mark),a  
4500 3a 0f 45			ld a, (.dmark+1)  
4503 32 6f fe			ld (debug_mark+1),a  
4506 3a 10 45			ld a, (.dmark+2)  
4509 32 70 fe			ld (debug_mark+2),a  
450c 18 03			jr .pastdmark  
450e ..			.dmark: db "TCS"  
4511 f1			.pastdmark: pop af  
4512			endm  
# End of macro DMARK
4512						CALLMONITOR 
4512 cd f3 18			call break_point_state  
4515				endm  
# End of macro CALLMONITOR
4515					endif 
4515			 
4515					FORTH_DSP 
4515 cd 24 21			call macro_forth_dsp 
4518				endm 
# End of macro FORTH_DSP
4518					 
4518			; TODO check is string type 
4518			 
4518					FORTH_DSP_VALUEHL 
4518 cd 5e 21			call macro_dsp_valuehl 
451b				endm 
# End of macro FORTH_DSP_VALUEHL
451b			; get pointer to string in hl 
451b			 
451b					if DEBUG_FORTH_WORDS 
451b						DMARK "TC1" 
451b f5				push af  
451c 3a 30 45			ld a, (.dmark)  
451f 32 6e fe			ld (debug_mark),a  
4522 3a 31 45			ld a, (.dmark+1)  
4525 32 6f fe			ld (debug_mark+1),a  
4528 3a 32 45			ld a, (.dmark+2)  
452b 32 70 fe			ld (debug_mark+2),a  
452e 18 03			jr .pastdmark  
4530 ..			.dmark: db "TC1"  
4533 f1			.pastdmark: pop af  
4534			endm  
# End of macro DMARK
4534						CALLMONITOR 
4534 cd f3 18			call break_point_state  
4537				endm  
# End of macro CALLMONITOR
4537					endif 
4537			 
4537					; first time in turn to upper case first char 
4537			 
4537 7e					ld a, (hl) 
4538 c3 c2 45				jp .totsiptou 
453b			 
453b			 
453b 7e			.tot:		ld a, (hl) 
453c fe 00				cp 0 
453e ca 06 46				jp z, .totdone 
4541			 
4541					if DEBUG_FORTH_WORDS 
4541						DMARK "TC2" 
4541 f5				push af  
4542 3a 56 45			ld a, (.dmark)  
4545 32 6e fe			ld (debug_mark),a  
4548 3a 57 45			ld a, (.dmark+1)  
454b 32 6f fe			ld (debug_mark+1),a  
454e 3a 58 45			ld a, (.dmark+2)  
4551 32 70 fe			ld (debug_mark+2),a  
4554 18 03			jr .pastdmark  
4556 ..			.dmark: db "TC2"  
4559 f1			.pastdmark: pop af  
455a			endm  
# End of macro DMARK
455a						CALLMONITOR 
455a cd f3 18			call break_point_state  
455d				endm  
# End of macro CALLMONITOR
455d					endif 
455d					; check to see if current char is a space 
455d			 
455d fe 20				cp ' ' 
455f 28 21				jr z, .totsp 
4561 cd c2 12				call to_lower 
4564					if DEBUG_FORTH_WORDS 
4564						DMARK "TC3" 
4564 f5				push af  
4565 3a 79 45			ld a, (.dmark)  
4568 32 6e fe			ld (debug_mark),a  
456b 3a 7a 45			ld a, (.dmark+1)  
456e 32 6f fe			ld (debug_mark+1),a  
4571 3a 7b 45			ld a, (.dmark+2)  
4574 32 70 fe			ld (debug_mark+2),a  
4577 18 03			jr .pastdmark  
4579 ..			.dmark: db "TC3"  
457c f1			.pastdmark: pop af  
457d			endm  
# End of macro DMARK
457d						CALLMONITOR 
457d cd f3 18			call break_point_state  
4580				endm  
# End of macro CALLMONITOR
4580					endif 
4580 18 63				jr .totnxt 
4582			 
4582			.totsp:         ; on a space, find next char which should be upper 
4582			 
4582					if DEBUG_FORTH_WORDS 
4582						DMARK "TC4" 
4582 f5				push af  
4583 3a 97 45			ld a, (.dmark)  
4586 32 6e fe			ld (debug_mark),a  
4589 3a 98 45			ld a, (.dmark+1)  
458c 32 6f fe			ld (debug_mark+1),a  
458f 3a 99 45			ld a, (.dmark+2)  
4592 32 70 fe			ld (debug_mark+2),a  
4595 18 03			jr .pastdmark  
4597 ..			.dmark: db "TC4"  
459a f1			.pastdmark: pop af  
459b			endm  
# End of macro DMARK
459b						CALLMONITOR 
459b cd f3 18			call break_point_state  
459e				endm  
# End of macro CALLMONITOR
459e					endif 
459e					;; 
459e			 
459e fe 20				cp ' ' 
45a0 20 20				jr nz, .totsiptou 
45a2 23					inc hl 
45a3 7e					ld a, (hl) 
45a4					if DEBUG_FORTH_WORDS 
45a4						DMARK "TC5" 
45a4 f5				push af  
45a5 3a b9 45			ld a, (.dmark)  
45a8 32 6e fe			ld (debug_mark),a  
45ab 3a ba 45			ld a, (.dmark+1)  
45ae 32 6f fe			ld (debug_mark+1),a  
45b1 3a bb 45			ld a, (.dmark+2)  
45b4 32 70 fe			ld (debug_mark+2),a  
45b7 18 03			jr .pastdmark  
45b9 ..			.dmark: db "TC5"  
45bc f1			.pastdmark: pop af  
45bd			endm  
# End of macro DMARK
45bd						CALLMONITOR 
45bd cd f3 18			call break_point_state  
45c0				endm  
# End of macro CALLMONITOR
45c0					endif 
45c0 18 c0				jr .totsp 
45c2 fe 00		.totsiptou:    cp 0 
45c4 28 40				jr z, .totdone 
45c6					; not space and not zero term so upper case it 
45c6 cd b9 12				call to_upper 
45c9			 
45c9					if DEBUG_FORTH_WORDS 
45c9						DMARK "TC6" 
45c9 f5				push af  
45ca 3a de 45			ld a, (.dmark)  
45cd 32 6e fe			ld (debug_mark),a  
45d0 3a df 45			ld a, (.dmark+1)  
45d3 32 6f fe			ld (debug_mark+1),a  
45d6 3a e0 45			ld a, (.dmark+2)  
45d9 32 70 fe			ld (debug_mark+2),a  
45dc 18 03			jr .pastdmark  
45de ..			.dmark: db "TC6"  
45e1 f1			.pastdmark: pop af  
45e2			endm  
# End of macro DMARK
45e2						CALLMONITOR 
45e2 cd f3 18			call break_point_state  
45e5				endm  
# End of macro CALLMONITOR
45e5					endif 
45e5			 
45e5			 
45e5			.totnxt: 
45e5			 
45e5 77					ld (hl), a 
45e6 23					inc hl 
45e7					if DEBUG_FORTH_WORDS 
45e7						DMARK "TC7" 
45e7 f5				push af  
45e8 3a fc 45			ld a, (.dmark)  
45eb 32 6e fe			ld (debug_mark),a  
45ee 3a fd 45			ld a, (.dmark+1)  
45f1 32 6f fe			ld (debug_mark+1),a  
45f4 3a fe 45			ld a, (.dmark+2)  
45f7 32 70 fe			ld (debug_mark+2),a  
45fa 18 03			jr .pastdmark  
45fc ..			.dmark: db "TC7"  
45ff f1			.pastdmark: pop af  
4600			endm  
# End of macro DMARK
4600						CALLMONITOR 
4600 cd f3 18			call break_point_state  
4603				endm  
# End of macro CALLMONITOR
4603					endif 
4603 c3 3b 45				jp .tot 
4606			 
4606					 
4606			 
4606			 
4606			; for each char convert to low 
4606					 
4606			.totdone: 
4606					if DEBUG_FORTH_WORDS 
4606						DMARK "TCd" 
4606 f5				push af  
4607 3a 1b 46			ld a, (.dmark)  
460a 32 6e fe			ld (debug_mark),a  
460d 3a 1c 46			ld a, (.dmark+1)  
4610 32 6f fe			ld (debug_mark+1),a  
4613 3a 1d 46			ld a, (.dmark+2)  
4616 32 70 fe			ld (debug_mark+2),a  
4619 18 03			jr .pastdmark  
461b ..			.dmark: db "TCd"  
461e f1			.pastdmark: pop af  
461f			endm  
# End of macro DMARK
461f						CALLMONITOR 
461f cd f3 18			call break_point_state  
4622				endm  
# End of macro CALLMONITOR
4622					endif 
4622					NEXTW 
4622 c3 14 23			jp macro_next 
4625				endm 
# End of macro NEXTW
4625			 
4625			.SUBSTR: 
4625				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4625 48				db WORD_SYS_CORE+52             
4626 83 46			dw .LEFT            
4628 07				db 6 + 1 
4629 .. 00			db "SUBSTR",0              
4630				endm 
# End of macro CWHEAD
4630			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4630			 
4630					if DEBUG_FORTH_WORDS_KEY 
4630						DMARK "SST" 
4630 f5				push af  
4631 3a 45 46			ld a, (.dmark)  
4634 32 6e fe			ld (debug_mark),a  
4637 3a 46 46			ld a, (.dmark+1)  
463a 32 6f fe			ld (debug_mark+1),a  
463d 3a 47 46			ld a, (.dmark+2)  
4640 32 70 fe			ld (debug_mark+2),a  
4643 18 03			jr .pastdmark  
4645 ..			.dmark: db "SST"  
4648 f1			.pastdmark: pop af  
4649			endm  
# End of macro DMARK
4649						CALLMONITOR 
4649 cd f3 18			call break_point_state  
464c				endm  
# End of macro CALLMONITOR
464c					endif 
464c			; TODO check string type 
464c					FORTH_DSP_VALUEHL 
464c cd 5e 21			call macro_dsp_valuehl 
464f				endm 
# End of macro FORTH_DSP_VALUEHL
464f			 
464f e5					push hl      ; string length 
4650			 
4650					FORTH_DSP_POP 
4650 cd 16 22			call macro_forth_dsp_pop 
4653				endm 
# End of macro FORTH_DSP_POP
4653			 
4653					FORTH_DSP_VALUEHL 
4653 cd 5e 21			call macro_dsp_valuehl 
4656				endm 
# End of macro FORTH_DSP_VALUEHL
4656			 
4656 e5					push hl     ; start char 
4657			 
4657					FORTH_DSP_POP 
4657 cd 16 22			call macro_forth_dsp_pop 
465a				endm 
# End of macro FORTH_DSP_POP
465a			 
465a			 
465a					FORTH_DSP_VALUE 
465a cd 47 21			call macro_forth_dsp_value 
465d				endm 
# End of macro FORTH_DSP_VALUE
465d			 
465d d1					pop de    ; get start post offset 
465e			 
465e 19					add hl, de    ; starting offset 
465f			 
465f c1					pop bc 
4660 c5					push bc      ; grab size of string 
4661			 
4661 e5					push hl    ; save string start  
4662			 
4662 26 00				ld h, 0 
4664 69					ld l, c 
4665 23					inc hl 
4666 23					inc hl 
4667			 
4667 cd 13 14				call malloc 
466a				if DEBUG_FORTH_MALLOC_GUARD 
466a cc 65 5a				call z,malloc_error 
466d				endif 
466d			 
466d eb					ex de, hl      ; save malloc area for string copy 
466e e1					pop hl    ; get back source 
466f c1					pop bc    ; get length of string back 
4670			 
4670 d5					push de    ; save malloc area for after we push 
4671 ed b0				ldir     ; copy substr 
4673			 
4673			 
4673 eb					ex de, hl 
4674 3e 00				ld a, 0 
4676 77					ld (hl), a   ; term substr 
4677			 
4677					 
4677 e1					pop hl    ; get malloc so we can push it 
4678 e5					push hl   ; save so we can free it afterwards 
4679			 
4679 cd d5 1f				call forth_push_str 
467c			 
467c e1					pop hl 
467d cd dd 14				call free 
4680			 
4680					 
4680					 
4680			 
4680			 
4680					NEXTW 
4680 c3 14 23			jp macro_next 
4683				endm 
# End of macro NEXTW
4683			 
4683			.LEFT: 
4683				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4683 48				db WORD_SYS_CORE+52             
4684 ab 46			dw .RIGHT            
4686 05				db 4 + 1 
4687 .. 00			db "LEFT",0              
468c				endm 
# End of macro CWHEAD
468c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
468c					if DEBUG_FORTH_WORDS_KEY 
468c						DMARK "LEF" 
468c f5				push af  
468d 3a a1 46			ld a, (.dmark)  
4690 32 6e fe			ld (debug_mark),a  
4693 3a a2 46			ld a, (.dmark+1)  
4696 32 6f fe			ld (debug_mark+1),a  
4699 3a a3 46			ld a, (.dmark+2)  
469c 32 70 fe			ld (debug_mark+2),a  
469f 18 03			jr .pastdmark  
46a1 ..			.dmark: db "LEF"  
46a4 f1			.pastdmark: pop af  
46a5			endm  
# End of macro DMARK
46a5						CALLMONITOR 
46a5 cd f3 18			call break_point_state  
46a8				endm  
# End of macro CALLMONITOR
46a8					endif 
46a8			 
46a8					NEXTW 
46a8 c3 14 23			jp macro_next 
46ab				endm 
# End of macro NEXTW
46ab			.RIGHT: 
46ab				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
46ab 48				db WORD_SYS_CORE+52             
46ac d4 46			dw .STR2NUM            
46ae 06				db 5 + 1 
46af .. 00			db "RIGHT",0              
46b5				endm 
# End of macro CWHEAD
46b5			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
46b5					if DEBUG_FORTH_WORDS_KEY 
46b5						DMARK "RIG" 
46b5 f5				push af  
46b6 3a ca 46			ld a, (.dmark)  
46b9 32 6e fe			ld (debug_mark),a  
46bc 3a cb 46			ld a, (.dmark+1)  
46bf 32 6f fe			ld (debug_mark+1),a  
46c2 3a cc 46			ld a, (.dmark+2)  
46c5 32 70 fe			ld (debug_mark+2),a  
46c8 18 03			jr .pastdmark  
46ca ..			.dmark: db "RIG"  
46cd f1			.pastdmark: pop af  
46ce			endm  
# End of macro DMARK
46ce						CALLMONITOR 
46ce cd f3 18			call break_point_state  
46d1				endm  
# End of macro CALLMONITOR
46d1					endif 
46d1			 
46d1					NEXTW 
46d1 c3 14 23			jp macro_next 
46d4				endm 
# End of macro NEXTW
46d4			 
46d4			 
46d4			.STR2NUM: 
46d4				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46d4 48				db WORD_SYS_CORE+52             
46d5 60 47			dw .NUM2STR            
46d7 08				db 7 + 1 
46d8 .. 00			db "STR2NUM",0              
46e0				endm 
# End of macro CWHEAD
46e0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46e0			 
46e0			 
46e0			; TODO STR type check to do 
46e0					if DEBUG_FORTH_WORDS_KEY 
46e0						DMARK "S2N" 
46e0 f5				push af  
46e1 3a f5 46			ld a, (.dmark)  
46e4 32 6e fe			ld (debug_mark),a  
46e7 3a f6 46			ld a, (.dmark+1)  
46ea 32 6f fe			ld (debug_mark+1),a  
46ed 3a f7 46			ld a, (.dmark+2)  
46f0 32 70 fe			ld (debug_mark+2),a  
46f3 18 03			jr .pastdmark  
46f5 ..			.dmark: db "S2N"  
46f8 f1			.pastdmark: pop af  
46f9			endm  
# End of macro DMARK
46f9						CALLMONITOR 
46f9 cd f3 18			call break_point_state  
46fc				endm  
# End of macro CALLMONITOR
46fc					endif 
46fc			 
46fc					;FORTH_DSP 
46fc					FORTH_DSP_VALUE 
46fc cd 47 21			call macro_forth_dsp_value 
46ff				endm 
# End of macro FORTH_DSP_VALUE
46ff					;inc hl 
46ff			 
46ff eb					ex de, hl 
4700					if DEBUG_FORTH_WORDS 
4700						DMARK "S2a" 
4700 f5				push af  
4701 3a 15 47			ld a, (.dmark)  
4704 32 6e fe			ld (debug_mark),a  
4707 3a 16 47			ld a, (.dmark+1)  
470a 32 6f fe			ld (debug_mark+1),a  
470d 3a 17 47			ld a, (.dmark+2)  
4710 32 70 fe			ld (debug_mark+2),a  
4713 18 03			jr .pastdmark  
4715 ..			.dmark: db "S2a"  
4718 f1			.pastdmark: pop af  
4719			endm  
# End of macro DMARK
4719						CALLMONITOR 
4719 cd f3 18			call break_point_state  
471c				endm  
# End of macro CALLMONITOR
471c					endif 
471c cd 41 13				call string_to_uint16 
471f			 
471f					if DEBUG_FORTH_WORDS 
471f						DMARK "S2b" 
471f f5				push af  
4720 3a 34 47			ld a, (.dmark)  
4723 32 6e fe			ld (debug_mark),a  
4726 3a 35 47			ld a, (.dmark+1)  
4729 32 6f fe			ld (debug_mark+1),a  
472c 3a 36 47			ld a, (.dmark+2)  
472f 32 70 fe			ld (debug_mark+2),a  
4732 18 03			jr .pastdmark  
4734 ..			.dmark: db "S2b"  
4737 f1			.pastdmark: pop af  
4738			endm  
# End of macro DMARK
4738						CALLMONITOR 
4738 cd f3 18			call break_point_state  
473b				endm  
# End of macro CALLMONITOR
473b					endif 
473b			;		push hl 
473b					FORTH_DSP_POP 
473b cd 16 22			call macro_forth_dsp_pop 
473e				endm 
# End of macro FORTH_DSP_POP
473e			;		pop hl 
473e					 
473e					if DEBUG_FORTH_WORDS 
473e						DMARK "S2b" 
473e f5				push af  
473f 3a 53 47			ld a, (.dmark)  
4742 32 6e fe			ld (debug_mark),a  
4745 3a 54 47			ld a, (.dmark+1)  
4748 32 6f fe			ld (debug_mark+1),a  
474b 3a 55 47			ld a, (.dmark+2)  
474e 32 70 fe			ld (debug_mark+2),a  
4751 18 03			jr .pastdmark  
4753 ..			.dmark: db "S2b"  
4756 f1			.pastdmark: pop af  
4757			endm  
# End of macro DMARK
4757						CALLMONITOR 
4757 cd f3 18			call break_point_state  
475a				endm  
# End of macro CALLMONITOR
475a					endif 
475a cd 67 1f				call forth_push_numhl	 
475d			 
475d				 
475d				       NEXTW 
475d c3 14 23			jp macro_next 
4760				endm 
# End of macro NEXTW
4760			.NUM2STR: 
4760				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4760 48				db WORD_SYS_CORE+52             
4761 6f 47			dw .CONCAT            
4763 08				db 7 + 1 
4764 .. 00			db "NUM2STR",0              
476c				endm 
# End of macro CWHEAD
476c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
476c			 
476c			;		; malloc a string to target 
476c			;		ld hl, 10     ; TODO max string size should be fine 
476c			;		call malloc 
476c			;		push hl    ; save malloc location 
476c			; 
476c			; 
476c			;; TODO check int type 
476c			;		FORTH_DSP_VALUEHL 
476c			;		ld a, l 
476c			;		call DispAToASCII   
476c			;;TODO need to chage above call to dump into string 
476c			; 
476c			; 
476c			 
476c				       NEXTW 
476c c3 14 23			jp macro_next 
476f				endm 
# End of macro NEXTW
476f			 
476f			.CONCAT: 
476f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
476f 48				db WORD_SYS_CORE+52             
4770 22 48			dw .FIND            
4772 07				db 6 + 1 
4773 .. 00			db "CONCAT",0              
477a				endm 
# End of macro CWHEAD
477a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
477a			 
477a			; TODO check string type 
477a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
477a			 
477a					if DEBUG_FORTH_WORDS_KEY 
477a						DMARK "CON" 
477a f5				push af  
477b 3a 8f 47			ld a, (.dmark)  
477e 32 6e fe			ld (debug_mark),a  
4781 3a 90 47			ld a, (.dmark+1)  
4784 32 6f fe			ld (debug_mark+1),a  
4787 3a 91 47			ld a, (.dmark+2)  
478a 32 70 fe			ld (debug_mark+2),a  
478d 18 03			jr .pastdmark  
478f ..			.dmark: db "CON"  
4792 f1			.pastdmark: pop af  
4793			endm  
# End of macro DMARK
4793						CALLMONITOR 
4793 cd f3 18			call break_point_state  
4796				endm  
# End of macro CALLMONITOR
4796					endif 
4796			 
4796			 
4796					FORTH_DSP_VALUE 
4796 cd 47 21			call macro_forth_dsp_value 
4799				endm 
# End of macro FORTH_DSP_VALUE
4799 e5					push hl   ; s2 
479a			 
479a					FORTH_DSP_POP 
479a cd 16 22			call macro_forth_dsp_pop 
479d				endm 
# End of macro FORTH_DSP_POP
479d			 
479d					FORTH_DSP_VALUE 
479d cd 47 21			call macro_forth_dsp_value 
47a0				endm 
# End of macro FORTH_DSP_VALUE
47a0			 
47a0 e5					push hl   ; s1 
47a1			 
47a1					FORTH_DSP_POP 
47a1 cd 16 22			call macro_forth_dsp_pop 
47a4				endm 
# End of macro FORTH_DSP_POP
47a4					 
47a4			 
47a4					; copy s1 
47a4			 
47a4				 
47a4					; save ptr 
47a4 e1					pop hl  
47a5 e5					push hl 
47a6 3e 00				ld a, 0 
47a8 cd b5 13				call strlent 
47ab					;inc hl    ; zer0 
47ab 06 00				ld b, 0 
47ad 4d					ld c, l 
47ae e1					pop hl		 
47af 11 c8 f1				ld de, scratch	 
47b2					if DEBUG_FORTH_WORDS 
47b2						DMARK "CO1" 
47b2 f5				push af  
47b3 3a c7 47			ld a, (.dmark)  
47b6 32 6e fe			ld (debug_mark),a  
47b9 3a c8 47			ld a, (.dmark+1)  
47bc 32 6f fe			ld (debug_mark+1),a  
47bf 3a c9 47			ld a, (.dmark+2)  
47c2 32 70 fe			ld (debug_mark+2),a  
47c5 18 03			jr .pastdmark  
47c7 ..			.dmark: db "CO1"  
47ca f1			.pastdmark: pop af  
47cb			endm  
# End of macro DMARK
47cb						CALLMONITOR 
47cb cd f3 18			call break_point_state  
47ce				endm  
# End of macro CALLMONITOR
47ce					endif 
47ce ed b0				ldir 
47d0			 
47d0 e1					pop hl 
47d1 e5					push hl 
47d2 d5					push de 
47d3			 
47d3			 
47d3 3e 00				ld a, 0 
47d5 cd b5 13				call strlent 
47d8 23					inc hl    ; zer0 
47d9 23					inc hl 
47da 06 00				ld b, 0 
47dc 4d					ld c, l 
47dd d1					pop de 
47de e1					pop hl		 
47df					if DEBUG_FORTH_WORDS 
47df						DMARK "CO2" 
47df f5				push af  
47e0 3a f4 47			ld a, (.dmark)  
47e3 32 6e fe			ld (debug_mark),a  
47e6 3a f5 47			ld a, (.dmark+1)  
47e9 32 6f fe			ld (debug_mark+1),a  
47ec 3a f6 47			ld a, (.dmark+2)  
47ef 32 70 fe			ld (debug_mark+2),a  
47f2 18 03			jr .pastdmark  
47f4 ..			.dmark: db "CO2"  
47f7 f1			.pastdmark: pop af  
47f8			endm  
# End of macro DMARK
47f8						CALLMONITOR 
47f8 cd f3 18			call break_point_state  
47fb				endm  
# End of macro CALLMONITOR
47fb					endif 
47fb ed b0				ldir 
47fd			 
47fd			 
47fd			 
47fd 21 c8 f1				ld hl, scratch 
4800					if DEBUG_FORTH_WORDS 
4800						DMARK "CO5" 
4800 f5				push af  
4801 3a 15 48			ld a, (.dmark)  
4804 32 6e fe			ld (debug_mark),a  
4807 3a 16 48			ld a, (.dmark+1)  
480a 32 6f fe			ld (debug_mark+1),a  
480d 3a 17 48			ld a, (.dmark+2)  
4810 32 70 fe			ld (debug_mark+2),a  
4813 18 03			jr .pastdmark  
4815 ..			.dmark: db "CO5"  
4818 f1			.pastdmark: pop af  
4819			endm  
# End of macro DMARK
4819						CALLMONITOR 
4819 cd f3 18			call break_point_state  
481c				endm  
# End of macro CALLMONITOR
481c					endif 
481c			 
481c cd d5 1f				call forth_push_str 
481f			 
481f			 
481f			 
481f			 
481f				       NEXTW 
481f c3 14 23			jp macro_next 
4822				endm 
# End of macro NEXTW
4822			 
4822			 
4822			.FIND: 
4822				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4822 4b				db WORD_SYS_CORE+55             
4823 e0 48			dw .LEN            
4825 05				db 4 + 1 
4826 .. 00			db "FIND",0              
482b				endm 
# End of macro CWHEAD
482b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
482b			 
482b					if DEBUG_FORTH_WORDS_KEY 
482b						DMARK "FND" 
482b f5				push af  
482c 3a 40 48			ld a, (.dmark)  
482f 32 6e fe			ld (debug_mark),a  
4832 3a 41 48			ld a, (.dmark+1)  
4835 32 6f fe			ld (debug_mark+1),a  
4838 3a 42 48			ld a, (.dmark+2)  
483b 32 70 fe			ld (debug_mark+2),a  
483e 18 03			jr .pastdmark  
4840 ..			.dmark: db "FND"  
4843 f1			.pastdmark: pop af  
4844			endm  
# End of macro DMARK
4844						CALLMONITOR 
4844 cd f3 18			call break_point_state  
4847				endm  
# End of macro CALLMONITOR
4847					endif 
4847			 
4847			; TODO check string type 
4847					FORTH_DSP_VALUE 
4847 cd 47 21			call macro_forth_dsp_value 
484a				endm 
# End of macro FORTH_DSP_VALUE
484a			 
484a e5					push hl    
484b 7e					ld a,(hl)    ; char to find   
484c			; TODO change char to substr 
484c			 
484c f5					push af 
484d					 
484d			 
484d			 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "FN1" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 6e fe			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 6f fe			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 70 fe			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "FN1"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd f3 18			call break_point_state  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869			 
4869					FORTH_DSP_POP 
4869 cd 16 22			call macro_forth_dsp_pop 
486c				endm 
# End of macro FORTH_DSP_POP
486c			 
486c					; string to search 
486c			 
486c					FORTH_DSP_VALUE 
486c cd 47 21			call macro_forth_dsp_value 
486f				endm 
# End of macro FORTH_DSP_VALUE
486f			 
486f d1					pop de  ; d is char to find  
4870			 
4870					if DEBUG_FORTH_WORDS 
4870						DMARK "FN2" 
4870 f5				push af  
4871 3a 85 48			ld a, (.dmark)  
4874 32 6e fe			ld (debug_mark),a  
4877 3a 86 48			ld a, (.dmark+1)  
487a 32 6f fe			ld (debug_mark+1),a  
487d 3a 87 48			ld a, (.dmark+2)  
4880 32 70 fe			ld (debug_mark+2),a  
4883 18 03			jr .pastdmark  
4885 ..			.dmark: db "FN2"  
4888 f1			.pastdmark: pop af  
4889			endm  
# End of macro DMARK
4889						CALLMONITOR 
4889 cd f3 18			call break_point_state  
488c				endm  
# End of macro CALLMONITOR
488c					endif 
488c					 
488c 01 00 00				ld bc, 0 
488f 7e			.findchar:      ld a,(hl) 
4890 fe 00				cp 0   		 
4892 28 27				jr z, .finddone     
4894 ba					cp d 
4895 28 20				jr z, .foundchar 
4897 03					inc bc 
4898 23					inc hl 
4899					if DEBUG_FORTH_WORDS 
4899						DMARK "FN3" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 6e fe			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 6f fe			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 70 fe			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "FN3"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd f3 18			call break_point_state  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5 18 d8				jr .findchar 
48b7			 
48b7			 
48b7 c5			.foundchar:	push bc 
48b8 e1					pop hl 
48b9 18 03				jr .findexit 
48bb			 
48bb			 
48bb							 
48bb			 
48bb			.finddone:     ; got to end of string with no find 
48bb 21 00 00				ld hl, 0 
48be			.findexit: 
48be			 
48be					if DEBUG_FORTH_WORDS 
48be						DMARK "FNd" 
48be f5				push af  
48bf 3a d3 48			ld a, (.dmark)  
48c2 32 6e fe			ld (debug_mark),a  
48c5 3a d4 48			ld a, (.dmark+1)  
48c8 32 6f fe			ld (debug_mark+1),a  
48cb 3a d5 48			ld a, (.dmark+2)  
48ce 32 70 fe			ld (debug_mark+2),a  
48d1 18 03			jr .pastdmark  
48d3 ..			.dmark: db "FNd"  
48d6 f1			.pastdmark: pop af  
48d7			endm  
# End of macro DMARK
48d7						CALLMONITOR 
48d7 cd f3 18			call break_point_state  
48da				endm  
# End of macro CALLMONITOR
48da					endif 
48da cd 67 1f			call forth_push_numhl 
48dd			 
48dd				       NEXTW 
48dd c3 14 23			jp macro_next 
48e0				endm 
# End of macro NEXTW
48e0			 
48e0			.LEN: 
48e0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48e0 4c				db WORD_SYS_CORE+56             
48e1 4a 49			dw .ASC            
48e3 06				db 5 + 1 
48e4 .. 00			db "COUNT",0              
48ea				endm 
# End of macro CWHEAD
48ea			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48ea			 
48ea					if DEBUG_FORTH_WORDS_KEY 
48ea						DMARK "CNT" 
48ea f5				push af  
48eb 3a ff 48			ld a, (.dmark)  
48ee 32 6e fe			ld (debug_mark),a  
48f1 3a 00 49			ld a, (.dmark+1)  
48f4 32 6f fe			ld (debug_mark+1),a  
48f7 3a 01 49			ld a, (.dmark+2)  
48fa 32 70 fe			ld (debug_mark+2),a  
48fd 18 03			jr .pastdmark  
48ff ..			.dmark: db "CNT"  
4902 f1			.pastdmark: pop af  
4903			endm  
# End of macro DMARK
4903						CALLMONITOR 
4903 cd f3 18			call break_point_state  
4906				endm  
# End of macro CALLMONITOR
4906					endif 
4906			; TODO check string type 
4906					FORTH_DSP_VALUE 
4906 cd 47 21			call macro_forth_dsp_value 
4909				endm 
# End of macro FORTH_DSP_VALUE
4909			 
4909			 
4909					if DEBUG_FORTH_WORDS 
4909						DMARK "CN?" 
4909 f5				push af  
490a 3a 1e 49			ld a, (.dmark)  
490d 32 6e fe			ld (debug_mark),a  
4910 3a 1f 49			ld a, (.dmark+1)  
4913 32 6f fe			ld (debug_mark+1),a  
4916 3a 20 49			ld a, (.dmark+2)  
4919 32 70 fe			ld (debug_mark+2),a  
491c 18 03			jr .pastdmark  
491e ..			.dmark: db "CN?"  
4921 f1			.pastdmark: pop af  
4922			endm  
# End of macro DMARK
4922						CALLMONITOR 
4922 cd f3 18			call break_point_state  
4925				endm  
# End of macro CALLMONITOR
4925					endif 
4925 cd aa 13				call strlenz 
4928					if DEBUG_FORTH_WORDS 
4928						DMARK "CNl" 
4928 f5				push af  
4929 3a 3d 49			ld a, (.dmark)  
492c 32 6e fe			ld (debug_mark),a  
492f 3a 3e 49			ld a, (.dmark+1)  
4932 32 6f fe			ld (debug_mark+1),a  
4935 3a 3f 49			ld a, (.dmark+2)  
4938 32 70 fe			ld (debug_mark+2),a  
493b 18 03			jr .pastdmark  
493d ..			.dmark: db "CNl"  
4940 f1			.pastdmark: pop af  
4941			endm  
# End of macro DMARK
4941						CALLMONITOR 
4941 cd f3 18			call break_point_state  
4944				endm  
# End of macro CALLMONITOR
4944					endif 
4944			 
4944 cd 67 1f				call forth_push_numhl 
4947			 
4947			 
4947			 
4947				       NEXTW 
4947 c3 14 23			jp macro_next 
494a				endm 
# End of macro NEXTW
494a			.ASC: 
494a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
494a 4d				db WORD_SYS_CORE+57             
494b b8 49			dw .CHR            
494d 04				db 3 + 1 
494e .. 00			db "ASC",0              
4952				endm 
# End of macro CWHEAD
4952			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4952					if DEBUG_FORTH_WORDS_KEY 
4952						DMARK "ASC" 
4952 f5				push af  
4953 3a 67 49			ld a, (.dmark)  
4956 32 6e fe			ld (debug_mark),a  
4959 3a 68 49			ld a, (.dmark+1)  
495c 32 6f fe			ld (debug_mark+1),a  
495f 3a 69 49			ld a, (.dmark+2)  
4962 32 70 fe			ld (debug_mark+2),a  
4965 18 03			jr .pastdmark  
4967 ..			.dmark: db "ASC"  
496a f1			.pastdmark: pop af  
496b			endm  
# End of macro DMARK
496b						CALLMONITOR 
496b cd f3 18			call break_point_state  
496e				endm  
# End of macro CALLMONITOR
496e					endif 
496e					FORTH_DSP_VALUE 
496e cd 47 21			call macro_forth_dsp_value 
4971				endm 
# End of macro FORTH_DSP_VALUE
4971					;v5 FORTH_DSP_VALUE 
4971			;		inc hl      ; now at start of numeric as string 
4971			 
4971 e5					push hl 
4972			 
4972					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4972 cd 16 22			call macro_forth_dsp_pop 
4975				endm 
# End of macro FORTH_DSP_POP
4975			 
4975 e1					pop hl 
4976			 
4976					if DEBUG_FORTH_WORDS 
4976						DMARK "AS1" 
4976 f5				push af  
4977 3a 8b 49			ld a, (.dmark)  
497a 32 6e fe			ld (debug_mark),a  
497d 3a 8c 49			ld a, (.dmark+1)  
4980 32 6f fe			ld (debug_mark+1),a  
4983 3a 8d 49			ld a, (.dmark+2)  
4986 32 70 fe			ld (debug_mark+2),a  
4989 18 03			jr .pastdmark  
498b ..			.dmark: db "AS1"  
498e f1			.pastdmark: pop af  
498f			endm  
# End of macro DMARK
498f						CALLMONITOR 
498f cd f3 18			call break_point_state  
4992				endm  
# End of macro CALLMONITOR
4992					endif 
4992					; push the content of a onto the stack as a value 
4992			 
4992 7e					ld a,(hl)   ; get char 
4993 26 00				ld h,0 
4995 6f					ld l,a 
4996					if DEBUG_FORTH_WORDS 
4996						DMARK "AS2" 
4996 f5				push af  
4997 3a ab 49			ld a, (.dmark)  
499a 32 6e fe			ld (debug_mark),a  
499d 3a ac 49			ld a, (.dmark+1)  
49a0 32 6f fe			ld (debug_mark+1),a  
49a3 3a ad 49			ld a, (.dmark+2)  
49a6 32 70 fe			ld (debug_mark+2),a  
49a9 18 03			jr .pastdmark  
49ab ..			.dmark: db "AS2"  
49ae f1			.pastdmark: pop af  
49af			endm  
# End of macro DMARK
49af						CALLMONITOR 
49af cd f3 18			call break_point_state  
49b2				endm  
# End of macro CALLMONITOR
49b2					endif 
49b2 cd 67 1f				call forth_push_numhl 
49b5			 
49b5				       NEXTW 
49b5 c3 14 23			jp macro_next 
49b8				endm 
# End of macro NEXTW
49b8			 
49b8			.CHR: 
49b8				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
49b8 4d				db WORD_SYS_CORE+57             
49b9 f4 49			dw .ENDSTR            
49bb 04				db 3 + 1 
49bc .. 00			db "CHR",0              
49c0				endm 
# End of macro CWHEAD
49c0			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
49c0					if DEBUG_FORTH_WORDS_KEY 
49c0						DMARK "CHR" 
49c0 f5				push af  
49c1 3a d5 49			ld a, (.dmark)  
49c4 32 6e fe			ld (debug_mark),a  
49c7 3a d6 49			ld a, (.dmark+1)  
49ca 32 6f fe			ld (debug_mark+1),a  
49cd 3a d7 49			ld a, (.dmark+2)  
49d0 32 70 fe			ld (debug_mark+2),a  
49d3 18 03			jr .pastdmark  
49d5 ..			.dmark: db "CHR"  
49d8 f1			.pastdmark: pop af  
49d9			endm  
# End of macro DMARK
49d9						CALLMONITOR 
49d9 cd f3 18			call break_point_state  
49dc				endm  
# End of macro CALLMONITOR
49dc					endif 
49dc					FORTH_DSP_VALUEHL 
49dc cd 5e 21			call macro_dsp_valuehl 
49df				endm 
# End of macro FORTH_DSP_VALUEHL
49df			 
49df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49df cd 16 22			call macro_forth_dsp_pop 
49e2				endm 
# End of macro FORTH_DSP_POP
49e2			 
49e2					; save asci byte as a zero term string and push string 
49e2			 
49e2 7d					ld a,l 
49e3 32 c8 f1				ld (scratch), a 
49e6			 
49e6 3e 00				ld a, 0 
49e8 32 c9 f1				ld (scratch+1), a 
49eb			 
49eb 21 c8 f1				ld hl, scratch 
49ee cd d5 1f				call forth_push_str 
49f1			 
49f1			 
49f1				       NEXTW 
49f1 c3 14 23			jp macro_next 
49f4				endm 
# End of macro NEXTW
49f4			 
49f4			 
49f4			 
49f4			 
49f4			.ENDSTR: 
49f4			; eof 
49f4			 
# End of file forth_words_str.asm
49f4			include "forth_words_key.asm" 
49f4			 
49f4			; | ## Keyboard Words 
49f4			 
49f4			.KEY: 
49f4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
49f4 3e				db WORD_SYS_CORE+42             
49f5 24 4a			dw .WAITK            
49f7 04				db 3 + 1 
49f8 .. 00			db "KEY",0              
49fc				endm 
# End of macro CWHEAD
49fc			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
49fc			 
49fc					if DEBUG_FORTH_WORDS_KEY 
49fc						DMARK "KEY" 
49fc f5				push af  
49fd 3a 11 4a			ld a, (.dmark)  
4a00 32 6e fe			ld (debug_mark),a  
4a03 3a 12 4a			ld a, (.dmark+1)  
4a06 32 6f fe			ld (debug_mark+1),a  
4a09 3a 13 4a			ld a, (.dmark+2)  
4a0c 32 70 fe			ld (debug_mark+2),a  
4a0f 18 03			jr .pastdmark  
4a11 ..			.dmark: db "KEY"  
4a14 f1			.pastdmark: pop af  
4a15			endm  
# End of macro DMARK
4a15						CALLMONITOR 
4a15 cd f3 18			call break_point_state  
4a18				endm  
# End of macro CALLMONITOR
4a18					endif 
4a18			; TODO currently waits 
4a18 cd 0a 75				call cin 
4a1b					;call cin_wait 
4a1b 6f					ld l, a 
4a1c 26 00				ld h, 0 
4a1e cd 67 1f				call forth_push_numhl 
4a21					NEXTW 
4a21 c3 14 23			jp macro_next 
4a24				endm 
# End of macro NEXTW
4a24			.WAITK: 
4a24				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4a24 3f				db WORD_SYS_CORE+43             
4a25 56 4a			dw .ACCEPT            
4a27 06				db 5 + 1 
4a28 .. 00			db "WAITK",0              
4a2e				endm 
# End of macro CWHEAD
4a2e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4a2e					if DEBUG_FORTH_WORDS_KEY 
4a2e						DMARK "WAI" 
4a2e f5				push af  
4a2f 3a 43 4a			ld a, (.dmark)  
4a32 32 6e fe			ld (debug_mark),a  
4a35 3a 44 4a			ld a, (.dmark+1)  
4a38 32 6f fe			ld (debug_mark+1),a  
4a3b 3a 45 4a			ld a, (.dmark+2)  
4a3e 32 70 fe			ld (debug_mark+2),a  
4a41 18 03			jr .pastdmark  
4a43 ..			.dmark: db "WAI"  
4a46 f1			.pastdmark: pop af  
4a47			endm  
# End of macro DMARK
4a47						CALLMONITOR 
4a47 cd f3 18			call break_point_state  
4a4a				endm  
# End of macro CALLMONITOR
4a4a					endif 
4a4a cd f9 74				call cin_wait 
4a4d 6f					ld l, a 
4a4e 26 00				ld h, 0 
4a50 cd 67 1f				call forth_push_numhl 
4a53					NEXTW 
4a53 c3 14 23			jp macro_next 
4a56				endm 
# End of macro NEXTW
4a56			.ACCEPT: 
4a56				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a56 40				db WORD_SYS_CORE+44             
4a57 b4 4a			dw .EDIT            
4a59 07				db 6 + 1 
4a5a .. 00			db "ACCEPT",0              
4a61				endm 
# End of macro CWHEAD
4a61			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a61					; TODO crashes on push 
4a61					if DEBUG_FORTH_WORDS_KEY 
4a61						DMARK "ACC" 
4a61 f5				push af  
4a62 3a 76 4a			ld a, (.dmark)  
4a65 32 6e fe			ld (debug_mark),a  
4a68 3a 77 4a			ld a, (.dmark+1)  
4a6b 32 6f fe			ld (debug_mark+1),a  
4a6e 3a 78 4a			ld a, (.dmark+2)  
4a71 32 70 fe			ld (debug_mark+2),a  
4a74 18 03			jr .pastdmark  
4a76 ..			.dmark: db "ACC"  
4a79 f1			.pastdmark: pop af  
4a7a			endm  
# End of macro DMARK
4a7a						CALLMONITOR 
4a7a cd f3 18			call break_point_state  
4a7d				endm  
# End of macro CALLMONITOR
4a7d					endif 
4a7d 21 c6 f3				ld hl, os_input 
4a80 3e 00				ld a, 0 
4a82 77					ld (hl),a 
4a83 3a 65 fa				ld a,(f_cursor_ptr) 
4a86 16 64				ld d, 100 
4a88 0e 00				ld c, 0 
4a8a 1e 28				ld e, 40 
4a8c cd 79 0f				call input_str 
4a8f					; TODO perhaps do a type check and wrap in quotes if not a number 
4a8f 21 c6 f3				ld hl, os_input 
4a92					if DEBUG_FORTH_WORDS 
4a92						DMARK "AC1" 
4a92 f5				push af  
4a93 3a a7 4a			ld a, (.dmark)  
4a96 32 6e fe			ld (debug_mark),a  
4a99 3a a8 4a			ld a, (.dmark+1)  
4a9c 32 6f fe			ld (debug_mark+1),a  
4a9f 3a a9 4a			ld a, (.dmark+2)  
4aa2 32 70 fe			ld (debug_mark+2),a  
4aa5 18 03			jr .pastdmark  
4aa7 ..			.dmark: db "AC1"  
4aaa f1			.pastdmark: pop af  
4aab			endm  
# End of macro DMARK
4aab						CALLMONITOR 
4aab cd f3 18			call break_point_state  
4aae				endm  
# End of macro CALLMONITOR
4aae					endif 
4aae cd d5 1f				call forth_push_str 
4ab1					NEXTW 
4ab1 c3 14 23			jp macro_next 
4ab4				endm 
# End of macro NEXTW
4ab4			 
4ab4			.EDIT: 
4ab4				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4ab4 40				db WORD_SYS_CORE+44             
4ab5 56 4b			dw .ENDKEY            
4ab7 05				db 4 + 1 
4ab8 .. 00			db "EDIT",0              
4abd				endm 
# End of macro CWHEAD
4abd			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4abd			 
4abd					; TODO does not copy from stack 
4abd					if DEBUG_FORTH_WORDS_KEY 
4abd						DMARK "EDT" 
4abd f5				push af  
4abe 3a d2 4a			ld a, (.dmark)  
4ac1 32 6e fe			ld (debug_mark),a  
4ac4 3a d3 4a			ld a, (.dmark+1)  
4ac7 32 6f fe			ld (debug_mark+1),a  
4aca 3a d4 4a			ld a, (.dmark+2)  
4acd 32 70 fe			ld (debug_mark+2),a  
4ad0 18 03			jr .pastdmark  
4ad2 ..			.dmark: db "EDT"  
4ad5 f1			.pastdmark: pop af  
4ad6			endm  
# End of macro DMARK
4ad6						CALLMONITOR 
4ad6 cd f3 18			call break_point_state  
4ad9				endm  
# End of macro CALLMONITOR
4ad9					endif 
4ad9			 
4ad9					;FORTH_DSP 
4ad9					FORTH_DSP_VALUEHL 
4ad9 cd 5e 21			call macro_dsp_valuehl 
4adc				endm 
# End of macro FORTH_DSP_VALUEHL
4adc			;		inc hl    ; TODO do type check 
4adc			 
4adc			;		call get_word_hl 
4adc e5					push hl 
4add					if DEBUG_FORTH_WORDS 
4add						DMARK "EDp" 
4add f5				push af  
4ade 3a f2 4a			ld a, (.dmark)  
4ae1 32 6e fe			ld (debug_mark),a  
4ae4 3a f3 4a			ld a, (.dmark+1)  
4ae7 32 6f fe			ld (debug_mark+1),a  
4aea 3a f4 4a			ld a, (.dmark+2)  
4aed 32 70 fe			ld (debug_mark+2),a  
4af0 18 03			jr .pastdmark  
4af2 ..			.dmark: db "EDp"  
4af5 f1			.pastdmark: pop af  
4af6			endm  
# End of macro DMARK
4af6						CALLMONITOR 
4af6 cd f3 18			call break_point_state  
4af9				endm  
# End of macro CALLMONITOR
4af9					endif 
4af9				;	ld a, 0 
4af9 cd aa 13				call strlenz 
4afc 23					inc hl 
4afd			 
4afd 06 00				ld b, 0 
4aff 4d					ld c, l 
4b00			 
4b00 e1					pop hl 
4b01 11 c6 f3				ld de, os_input 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "EDc" 
4b04 f5				push af  
4b05 3a 19 4b			ld a, (.dmark)  
4b08 32 6e fe			ld (debug_mark),a  
4b0b 3a 1a 4b			ld a, (.dmark+1)  
4b0e 32 6f fe			ld (debug_mark+1),a  
4b11 3a 1b 4b			ld a, (.dmark+2)  
4b14 32 70 fe			ld (debug_mark+2),a  
4b17 18 03			jr .pastdmark  
4b19 ..			.dmark: db "EDc"  
4b1c f1			.pastdmark: pop af  
4b1d			endm  
# End of macro DMARK
4b1d						CALLMONITOR 
4b1d cd f3 18			call break_point_state  
4b20				endm  
# End of macro CALLMONITOR
4b20					endif 
4b20 ed b0				ldir 
4b22			 
4b22			 
4b22 21 c6 f3				ld hl, os_input 
4b25					;ld a, 0 
4b25					;ld (hl),a 
4b25 3a 65 fa				ld a,(f_cursor_ptr) 
4b28 16 64				ld d, 100 
4b2a 0e 00				ld c, 0 
4b2c 1e 28				ld e, 40 
4b2e cd 79 0f				call input_str 
4b31					; TODO perhaps do a type check and wrap in quotes if not a number 
4b31 21 c6 f3				ld hl, os_input 
4b34					if DEBUG_FORTH_WORDS 
4b34						DMARK "ED1" 
4b34 f5				push af  
4b35 3a 49 4b			ld a, (.dmark)  
4b38 32 6e fe			ld (debug_mark),a  
4b3b 3a 4a 4b			ld a, (.dmark+1)  
4b3e 32 6f fe			ld (debug_mark+1),a  
4b41 3a 4b 4b			ld a, (.dmark+2)  
4b44 32 70 fe			ld (debug_mark+2),a  
4b47 18 03			jr .pastdmark  
4b49 ..			.dmark: db "ED1"  
4b4c f1			.pastdmark: pop af  
4b4d			endm  
# End of macro DMARK
4b4d						CALLMONITOR 
4b4d cd f3 18			call break_point_state  
4b50				endm  
# End of macro CALLMONITOR
4b50					endif 
4b50 cd d5 1f				call forth_push_str 
4b53					NEXTW 
4b53 c3 14 23			jp macro_next 
4b56				endm 
# End of macro NEXTW
4b56			 
4b56			 
4b56			 
4b56			.ENDKEY: 
4b56			; eof 
4b56			 
# End of file forth_words_key.asm
4b56			include "forth_words_const.asm" 
4b56			 
4b56			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4b56			 
4b56			 
4b56			.SPITIME: 
4b56				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4b56 77				db WORD_SYS_CORE+99             
4b57 6b 4b			dw .VA            
4b59 08				db 7 + 1 
4b5a .. 00			db "SPITIME",0              
4b62				endm 
# End of macro CWHEAD
4b62			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4b62			; 
4b62			; | If using BANK devices then leave as is. 
4b62			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4b62			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4b62			 
4b62 21 6b fa				ld hl, spi_clktime  
4b65 cd 67 1f				call forth_push_numhl 
4b68			 
4b68					NEXTW 
4b68 c3 14 23			jp macro_next 
4b6b				endm 
# End of macro NEXTW
4b6b			 
4b6b			 
4b6b			.VA: 
4b6b				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4b6b 77				db WORD_SYS_CORE+99             
4b6c 7b 4b			dw .SYMBOL            
4b6e 03				db 2 + 1 
4b6f .. 00			db "VA",0              
4b72				endm 
# End of macro CWHEAD
4b72			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4b72 21 2f fa				ld hl, cli_var_array 
4b75 cd 67 1f				call forth_push_numhl 
4b78			 
4b78					NEXTW 
4b78 c3 14 23			jp macro_next 
4b7b				endm 
# End of macro NEXTW
4b7b			 
4b7b			.SYMBOL: 
4b7b				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4b7b 77				db WORD_SYS_CORE+99             
4b7c b3 4c			dw .ENDCONST            
4b7e 07				db 6 + 1 
4b7f .. 00			db "SYMBOL",0              
4b86				endm 
# End of macro CWHEAD
4b86			;| SYMBOL ( u1 -- )  Get the address of a system sysmbol from a look up table to TOS  | TO TEST 
4b86			;| 
4b86			;| The value is the number reference and the final address is pushed to stack 
4b86			 
4b86					if DEBUG_FORTH_WORDS_KEY 
4b86						DMARK "SYM" 
4b86 f5				push af  
4b87 3a 9b 4b			ld a, (.dmark)  
4b8a 32 6e fe			ld (debug_mark),a  
4b8d 3a 9c 4b			ld a, (.dmark+1)  
4b90 32 6f fe			ld (debug_mark+1),a  
4b93 3a 9d 4b			ld a, (.dmark+2)  
4b96 32 70 fe			ld (debug_mark+2),a  
4b99 18 03			jr .pastdmark  
4b9b ..			.dmark: db "SYM"  
4b9e f1			.pastdmark: pop af  
4b9f			endm  
# End of macro DMARK
4b9f						CALLMONITOR 
4b9f cd f3 18			call break_point_state  
4ba2				endm  
# End of macro CALLMONITOR
4ba2					endif 
4ba2			 
4ba2					FORTH_DSP_VALUEHL 
4ba2 cd 5e 21			call macro_dsp_valuehl 
4ba5				endm 
# End of macro FORTH_DSP_VALUEHL
4ba5			 
4ba5 7d					ld a, l     
4ba6			 
4ba6			 
4ba6					if DEBUG_FORTH_WORDS 
4ba6						DMARK "SY1" 
4ba6 f5				push af  
4ba7 3a bb 4b			ld a, (.dmark)  
4baa 32 6e fe			ld (debug_mark),a  
4bad 3a bc 4b			ld a, (.dmark+1)  
4bb0 32 6f fe			ld (debug_mark+1),a  
4bb3 3a bd 4b			ld a, (.dmark+2)  
4bb6 32 70 fe			ld (debug_mark+2),a  
4bb9 18 03			jr .pastdmark  
4bbb ..			.dmark: db "SY1"  
4bbe f1			.pastdmark: pop af  
4bbf			endm  
# End of macro DMARK
4bbf						CALLMONITOR 
4bbf cd f3 18			call break_point_state  
4bc2				endm  
# End of macro CALLMONITOR
4bc2					endif 
4bc2					 
4bc2 f5					push af	 
4bc3					FORTH_DSP_POP 
4bc3 cd 16 22			call macro_forth_dsp_pop 
4bc6				endm 
# End of macro FORTH_DSP_POP
4bc6 f1					pop af 
4bc7			 
4bc7 cb 27				sla a  
4bc9				 
4bc9					 
4bc9					if DEBUG_FORTH_WORDS 
4bc9						DMARK "SY" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 6e fe			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 6f fe			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 70 fe			ld (debug_mark+2),a  
4bdc 18 02			jr .pastdmark  
4bde ..			.dmark: db "SY"  
4be0 f1			.pastdmark: pop af  
4be1			endm  
# End of macro DMARK
4be1						CALLMONITOR 
4be1 cd f3 18			call break_point_state  
4be4				endm  
# End of macro CALLMONITOR
4be4					endif 
4be4			 
4be4 21 f3 4b				ld hl, sym_table 
4be7 cd 4c 0f				call addatohl 
4bea cd 96 22				call loadwordinhl 
4bed cd 67 1f				call forth_push_numhl 
4bf0			 
4bf0			 
4bf0				       NEXTW 
4bf0 c3 14 23			jp macro_next 
4bf3				endm 
# End of macro NEXTW
4bf3			 
4bf3			sym_table: 
4bf3			 
4bf3			; 0 
4bf3 43 fa		dw cli_autodisplay 
4bf5 51 fa		dw cli_buffer 
4bf7 f5 f9		dw cli_data_sp 
4bf9 2f f7		dw cli_data_stack 
4bfb 4b fa		dw cli_execword 
4bfd f7 f9		dw cli_loop_sp 
4bff 31 f9		dw cli_loop_stack 
4c01 44 fa		dw cli_mvdot 
4c03 49 fa		dw cli_nextword 
4c05 45 fa		dw cli_origptr 
4c07 4f fa		dw cli_origtoken 
4c09			; 11 
4c09 47 fa		dw cli_ptr 
4c0b f9 f9		dw cli_ret_sp 
4c0d b3 f9		dw cli_ret_stack 
4c0f 4d fa		dw cli_token 
4c11 2f fa		dw cli_var_array 
4c13 cb fb		dw cursor_col 
4c15 c9 fb		dw cursor_ptr 
4c17 ca fb		dw cursor_row 
4c19 c7 fb		dw cursor_shape 
4c1b 6e fe		dw debug_mark 
4c1d			; 21 
4c1d b4 fd		dw display_fb0 
4c1f 13 fd		dw display_fb1 
4c21 d1 fb		dw display_fb2 
4c23 72 fc		dw display_fb3 
4c25 cf fb		dw display_fb_active 
4c27 c7 f2		dw execscratch 
4c29 65 fa		dw f_cursor_ptr 
4c2b 72 fe		dw hardware_word 
4c2d 65 fe		dw input_at_cursor 
4c2f 67 fe		dw input_at_pos 
4c31			; 31 
4c31 63 fe		dw input_cur_flash 
4c33 62 fe		dw input_cur_onoff 
4c35 58 fe		dw input_cursor 
4c37 68 fe		dw input_display_size 
4c39 5d fe		dw input_len 
4c3b 6c fe		dw input_ptr 
4c3d 69 fe		dw input_size 
4c3f 6a fe		dw input_start 
4c41 79 0f		dw input_str 
4c43 66 fe		dw input_under_cursor 
4c45			; 41 
4c45 57 fe		dw key_actual_pressed 
4c47 82 fe		dw key_fa 
4c49 7e fe		dw key_face_held 
4c4b 81 fe		dw key_fb 
4c4d 80 fe		dw key_fc 
4c4f 7f fe		dw key_fd 
4c51 88 fe		dw key_held 
4c53 87 fe		dw key_held_prev 
4c55 2a 74		dw key_init 
4c57 83 fe		dw key_repeat_ct 
4c59			; 51 
4c59 05 00		dw key_rows 
4c5b 55 fe		dw key_shift 
4c5d 56 fe		dw key_symbol 
4c5f 89 fe		dw keyscan_scancol 
4c61 93 fe		dw keyscan_table 
4c63 f2 fe		dw keyscan_table_row1 
4c65 e7 fe		dw keyscan_table_row2 
4c67 dc fe		dw keyscan_table_row3 
4c69 d1 fe		dw keyscan_table_row4 
4c6b c6 fe		dw keyscan_table_row5 
4c6d			; 61 
4c6d ef f4		dw os_cli_cmd 
4c6f eb f4		dw os_cur_ptr 
4c71 ed f4		dw os_current_i 
4c73 c6 f3		dw os_input 
4c75 ee f5		dw os_last_cmd 
4c77 c5 f4		dw os_last_new_uword 
4c79 b9 f1		dw os_view_disable 
4c7b b5 f1		dw os_view_hl 
4c7d cd f4		dw os_word_scratch 
4c7f c3 00		dw portbctl 
4c81			; 71 
4c81 c1 00		dw portbdata 
4c83 6a fa		dw spi_cartdev 
4c85 69 fa		dw spi_cartdev2 
4c87 6b fa		dw spi_clktime 
4c89 67 fa		dw spi_device 
4c8b 66 fa		dw spi_device_id 
4c8d 68 fa		dw spi_portbyte 
4c8f ad fb		dw stackstore 
4c91			if STORAGE_SE 
4c91 82 00		dw storage_actl 
4c93 80 00		dw storage_adata 
4c95			else 
4c95			dw 0 
4c95			dw 0 
4c95			endif 
4c95			; 81 
4c95 0c 0b		dw storage_append 
4c97			if STORAGE_SE 
4c97 83 00		dw storage_bctl 
4c99			else 
4c99			dw 0 
4c99			endif 
4c99 99 fb		dw store_bank_active 
4c9b 6e fa		dw store_filecache 
4c9d 7c fa		dw store_longread 
4c9f 72 fa		dw store_openaddr 
4ca1 71 fa		dw store_openext 
4ca3 70 fa		dw store_openmaxext 
4ca5 81 fa		dw store_page 
4ca7 7d fa		dw store_readbuf 
4ca9			; 91 
4ca9 74 fa		dw store_readcont 
4cab 7f fa		dw store_readptr 
4cad 74 fa		dw store_tmpext 
4caf 75 fa		dw store_tmpid 
4cb1 6c fa		dw store_tmppageid 
4cb3			 
4cb3			 
4cb3			.ENDCONST: 
4cb3			 
4cb3			; eof 
4cb3			 
4cb3			 
# End of file forth_words_const.asm
4cb3			 
4cb3			if STORAGE_SE 
4cb3			   	include "forth_words_storage.asm" 
4cb3			 
4cb3			; | ## Fixed Storage Words 
4cb3			 
4cb3			.RECORD: 
4cb3			  
4cb3				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4cb3 3a				db WORD_SYS_CORE+38             
4cb4 57 4d			dw .BREAD            
4cb6 07				db 6 + 1 
4cb7 .. 00			db "RECORD",0              
4cbe				endm 
# End of macro CWHEAD
4cbe			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4cbe			; | | Compatible with PicoSPINet  
4cbe			 
4cbe					if DEBUG_FORTH_WORDS_KEY 
4cbe						DMARK "REC" 
4cbe f5				push af  
4cbf 3a d3 4c			ld a, (.dmark)  
4cc2 32 6e fe			ld (debug_mark),a  
4cc5 3a d4 4c			ld a, (.dmark+1)  
4cc8 32 6f fe			ld (debug_mark+1),a  
4ccb 3a d5 4c			ld a, (.dmark+2)  
4cce 32 70 fe			ld (debug_mark+2),a  
4cd1 18 03			jr .pastdmark  
4cd3 ..			.dmark: db "REC"  
4cd6 f1			.pastdmark: pop af  
4cd7			endm  
# End of macro DMARK
4cd7						CALLMONITOR 
4cd7 cd f3 18			call break_point_state  
4cda				endm  
# End of macro CALLMONITOR
4cda					endif 
4cda			 
4cda					FORTH_DSP_VALUEHL 
4cda cd 5e 21			call macro_dsp_valuehl 
4cdd				endm 
# End of macro FORTH_DSP_VALUEHL
4cdd			 
4cdd e5					push hl    ; id 
4cde			 
4cde					FORTH_DSP_POP 
4cde cd 16 22			call macro_forth_dsp_pop 
4ce1				endm 
# End of macro FORTH_DSP_POP
4ce1			 
4ce1					FORTH_DSP_VALUEHL 
4ce1 cd 5e 21			call macro_dsp_valuehl 
4ce4				endm 
# End of macro FORTH_DSP_VALUEHL
4ce4			 
4ce4					FORTH_DSP_POP 
4ce4 cd 16 22			call macro_forth_dsp_pop 
4ce7				endm 
# End of macro FORTH_DSP_POP
4ce7			 
4ce7 d1					pop de     ; get file id 
4ce8			 
4ce8					; e = file id 
4ce8					; l = file extent 
4ce8			 
4ce8			 
4ce8					; construct request to access file extent 
4ce8			 
4ce8			;		ld a, e 
4ce8 63					ld h, e 
4ce9					 
4ce9					 
4ce9					 
4ce9			 
4ce9					; e has id 
4ce9			 
4ce9 11 81 fa			ld de, store_page 
4cec					if DEBUG_FORTH_WORDS 
4cec						DMARK "REr" 
4cec f5				push af  
4ced 3a 01 4d			ld a, (.dmark)  
4cf0 32 6e fe			ld (debug_mark),a  
4cf3 3a 02 4d			ld a, (.dmark+1)  
4cf6 32 6f fe			ld (debug_mark+1),a  
4cf9 3a 03 4d			ld a, (.dmark+2)  
4cfc 32 70 fe			ld (debug_mark+2),a  
4cff 18 03			jr .pastdmark  
4d01 ..			.dmark: db "REr"  
4d04 f1			.pastdmark: pop af  
4d05			endm  
# End of macro DMARK
4d05						CALLMONITOR 
4d05 cd f3 18			call break_point_state  
4d08				endm  
# End of macro CALLMONITOR
4d08					endif 
4d08 cd 75 09				call storage_read 
4d0b cd 75 0f			call ishlzero 
4d0e 28 22			jr z, .recnotfound 
4d10			 
4d10			 
4d10					if DEBUG_FORTH_WORDS 
4d10						DMARK "REe" 
4d10 f5				push af  
4d11 3a 25 4d			ld a, (.dmark)  
4d14 32 6e fe			ld (debug_mark),a  
4d17 3a 26 4d			ld a, (.dmark+1)  
4d1a 32 6f fe			ld (debug_mark+1),a  
4d1d 3a 27 4d			ld a, (.dmark+2)  
4d20 32 70 fe			ld (debug_mark+2),a  
4d23 18 03			jr .pastdmark  
4d25 ..			.dmark: db "REe"  
4d28 f1			.pastdmark: pop af  
4d29			endm  
# End of macro DMARK
4d29						CALLMONITOR 
4d29 cd f3 18			call break_point_state  
4d2c				endm  
# End of macro CALLMONITOR
4d2c					endif 
4d2c cd d5 1f			call forth_push_str 
4d2f			 
4d2f					NEXTW 
4d2f c3 14 23			jp macro_next 
4d32				endm 
# End of macro NEXTW
4d32			 
4d32			.recnotfound: 
4d32					if DEBUG_FORTH_WORDS 
4d32						DMARK "REf" 
4d32 f5				push af  
4d33 3a 47 4d			ld a, (.dmark)  
4d36 32 6e fe			ld (debug_mark),a  
4d39 3a 48 4d			ld a, (.dmark+1)  
4d3c 32 6f fe			ld (debug_mark+1),a  
4d3f 3a 49 4d			ld a, (.dmark+2)  
4d42 32 70 fe			ld (debug_mark+2),a  
4d45 18 03			jr .pastdmark  
4d47 ..			.dmark: db "REf"  
4d4a f1			.pastdmark: pop af  
4d4b			endm  
# End of macro DMARK
4d4b						CALLMONITOR 
4d4b cd f3 18			call break_point_state  
4d4e				endm  
# End of macro CALLMONITOR
4d4e					endif 
4d4e 21 ff 00			ld hl, 255 
4d51 cd 67 1f			call forth_push_numhl 
4d54				NEXTW 
4d54 c3 14 23			jp macro_next 
4d57				endm 
# End of macro NEXTW
4d57			 
4d57			 
4d57			.BREAD: 
4d57			  
4d57				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4d57 3a				db WORD_SYS_CORE+38             
4d58 da 4d			dw .BWRITE            
4d5a 06				db 5 + 1 
4d5b .. 00			db "BREAD",0              
4d61				endm 
# End of macro CWHEAD
4d61			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4d61			; | | Compatible with PicoSPINet  
4d61				 
4d61					if DEBUG_FORTH_WORDS_KEY 
4d61						DMARK "BRD" 
4d61 f5				push af  
4d62 3a 76 4d			ld a, (.dmark)  
4d65 32 6e fe			ld (debug_mark),a  
4d68 3a 77 4d			ld a, (.dmark+1)  
4d6b 32 6f fe			ld (debug_mark+1),a  
4d6e 3a 78 4d			ld a, (.dmark+2)  
4d71 32 70 fe			ld (debug_mark+2),a  
4d74 18 03			jr .pastdmark  
4d76 ..			.dmark: db "BRD"  
4d79 f1			.pastdmark: pop af  
4d7a			endm  
# End of macro DMARK
4d7a						CALLMONITOR 
4d7a cd f3 18			call break_point_state  
4d7d				endm  
# End of macro CALLMONITOR
4d7d					endif 
4d7d			 
4d7d				FORTH_DSP_VALUEHL 
4d7d cd 5e 21			call macro_dsp_valuehl 
4d80				endm 
# End of macro FORTH_DSP_VALUEHL
4d80			 
4d80				FORTH_DSP_POP 
4d80 cd 16 22			call macro_forth_dsp_pop 
4d83				endm 
# End of macro FORTH_DSP_POP
4d83			 
4d83				; calc block address 
4d83			 
4d83 eb				ex de, hl 
4d84 3e 40			ld a, STORE_BLOCK_PHY 
4d86 cd cf 0e			call Mult16 
4d89			 
4d89			 
4d89 11 81 fa			ld de, store_page 
4d8c			 
4d8c					if DEBUG_FORTH_WORDS 
4d8c						DMARK "BR1" 
4d8c f5				push af  
4d8d 3a a1 4d			ld a, (.dmark)  
4d90 32 6e fe			ld (debug_mark),a  
4d93 3a a2 4d			ld a, (.dmark+1)  
4d96 32 6f fe			ld (debug_mark+1),a  
4d99 3a a3 4d			ld a, (.dmark+2)  
4d9c 32 70 fe			ld (debug_mark+2),a  
4d9f 18 03			jr .pastdmark  
4da1 ..			.dmark: db "BR1"  
4da4 f1			.pastdmark: pop af  
4da5			endm  
# End of macro DMARK
4da5						CALLMONITOR 
4da5 cd f3 18			call break_point_state  
4da8				endm  
# End of macro CALLMONITOR
4da8					endif 
4da8			 
4da8 cd 1c 04			call storage_read_block 
4dab			 
4dab cd 75 0f			call ishlzero 
4dae 20 05			jr nz, .brfound 
4db0			 
4db0 cd 67 1f			call forth_push_numhl 
4db3 18 22			jr .brdone 
4db5			 
4db5			 
4db5			.brfound: 
4db5 21 83 fa		        ld hl, store_page+2 
4db8			 
4db8					if DEBUG_FORTH_WORDS 
4db8						DMARK "BR2" 
4db8 f5				push af  
4db9 3a cd 4d			ld a, (.dmark)  
4dbc 32 6e fe			ld (debug_mark),a  
4dbf 3a ce 4d			ld a, (.dmark+1)  
4dc2 32 6f fe			ld (debug_mark+1),a  
4dc5 3a cf 4d			ld a, (.dmark+2)  
4dc8 32 70 fe			ld (debug_mark+2),a  
4dcb 18 03			jr .pastdmark  
4dcd ..			.dmark: db "BR2"  
4dd0 f1			.pastdmark: pop af  
4dd1			endm  
# End of macro DMARK
4dd1						CALLMONITOR 
4dd1 cd f3 18			call break_point_state  
4dd4				endm  
# End of macro CALLMONITOR
4dd4					endif 
4dd4			 
4dd4 cd d5 1f			call forth_push_str 
4dd7			 
4dd7			 
4dd7			.brdone: 
4dd7			 
4dd7					NEXTW 
4dd7 c3 14 23			jp macro_next 
4dda				endm 
# End of macro NEXTW
4dda			.BWRITE: 
4dda				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4dda 3a				db WORD_SYS_CORE+38             
4ddb 6f 4e			dw .BUPD            
4ddd 07				db 6 + 1 
4dde .. 00			db "BWRITE",0              
4de5				endm 
# End of macro CWHEAD
4de5			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4de5			; | | Compatible with PicoSPINet  
4de5			 
4de5					if DEBUG_FORTH_WORDS_KEY 
4de5						DMARK "BWR" 
4de5 f5				push af  
4de6 3a fa 4d			ld a, (.dmark)  
4de9 32 6e fe			ld (debug_mark),a  
4dec 3a fb 4d			ld a, (.dmark+1)  
4def 32 6f fe			ld (debug_mark+1),a  
4df2 3a fc 4d			ld a, (.dmark+2)  
4df5 32 70 fe			ld (debug_mark+2),a  
4df8 18 03			jr .pastdmark  
4dfa ..			.dmark: db "BWR"  
4dfd f1			.pastdmark: pop af  
4dfe			endm  
# End of macro DMARK
4dfe						CALLMONITOR 
4dfe cd f3 18			call break_point_state  
4e01				endm  
# End of macro CALLMONITOR
4e01					endif 
4e01			 
4e01				FORTH_DSP_VALUEHL 
4e01 cd 5e 21			call macro_dsp_valuehl 
4e04				endm 
# End of macro FORTH_DSP_VALUEHL
4e04			 
4e04				; calc block address 
4e04			 
4e04 eb				ex de, hl 
4e05 3e 40			ld a, STORE_BLOCK_PHY 
4e07 cd cf 0e			call Mult16 
4e0a			 
4e0a e5				push hl         ; address 
4e0b			 
4e0b				FORTH_DSP_POP 
4e0b cd 16 22			call macro_forth_dsp_pop 
4e0e				endm 
# End of macro FORTH_DSP_POP
4e0e			 
4e0e				FORTH_DSP_VALUEHL 
4e0e cd 5e 21			call macro_dsp_valuehl 
4e11				endm 
# End of macro FORTH_DSP_VALUEHL
4e11			 
4e11				FORTH_DSP_POP 
4e11 cd 16 22			call macro_forth_dsp_pop 
4e14				endm 
# End of macro FORTH_DSP_POP
4e14			 
4e14 cd 58 0c			call storage_clear_page 
4e17			 
4e17				; copy string to store page 
4e17			 
4e17 e5				push hl     ; save string address 
4e18			 
4e18 3e 00			ld a, 0 
4e1a cd b5 13			call strlent 
4e1d			 
4e1d 23				inc hl 
4e1e			 
4e1e 4d				ld c, l 
4e1f 06 00			ld b, 0 
4e21			 
4e21 e1				pop hl 
4e22 11 83 fa			ld de, store_page + 2 
4e25					if DEBUG_FORTH_WORDS 
4e25						DMARK "BW1" 
4e25 f5				push af  
4e26 3a 3a 4e			ld a, (.dmark)  
4e29 32 6e fe			ld (debug_mark),a  
4e2c 3a 3b 4e			ld a, (.dmark+1)  
4e2f 32 6f fe			ld (debug_mark+1),a  
4e32 3a 3c 4e			ld a, (.dmark+2)  
4e35 32 70 fe			ld (debug_mark+2),a  
4e38 18 03			jr .pastdmark  
4e3a ..			.dmark: db "BW1"  
4e3d f1			.pastdmark: pop af  
4e3e			endm  
# End of macro DMARK
4e3e						CALLMONITOR 
4e3e cd f3 18			call break_point_state  
4e41				endm  
# End of macro CALLMONITOR
4e41					endif 
4e41 ed b0			ldir 
4e43			 
4e43			 
4e43				; poke the start of the block with flags to prevent high level file ops hitting the block 
4e43			 
4e43 21 ff ff			ld hl, $ffff 
4e46			 
4e46 22 81 fa			ld (store_page), hl	 
4e49				 
4e49 e1				pop hl    ; get address 
4e4a 11 81 fa			ld de, store_page 
4e4d			 
4e4d					if DEBUG_FORTH_WORDS 
4e4d						DMARK "BW2" 
4e4d f5				push af  
4e4e 3a 62 4e			ld a, (.dmark)  
4e51 32 6e fe			ld (debug_mark),a  
4e54 3a 63 4e			ld a, (.dmark+1)  
4e57 32 6f fe			ld (debug_mark+1),a  
4e5a 3a 64 4e			ld a, (.dmark+2)  
4e5d 32 70 fe			ld (debug_mark+2),a  
4e60 18 03			jr .pastdmark  
4e62 ..			.dmark: db "BW2"  
4e65 f1			.pastdmark: pop af  
4e66			endm  
# End of macro DMARK
4e66						CALLMONITOR 
4e66 cd f3 18			call break_point_state  
4e69				endm  
# End of macro CALLMONITOR
4e69					endif 
4e69			 
4e69 cd 81 04			call storage_write_block 
4e6c			 
4e6c					NEXTW 
4e6c c3 14 23			jp macro_next 
4e6f				endm 
# End of macro NEXTW
4e6f			 
4e6f			.BUPD: 
4e6f				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4e6f 3a				db WORD_SYS_CORE+38             
4e70 c5 4e			dw .BYID            
4e72 05				db 4 + 1 
4e73 .. 00			db "BUPD",0              
4e78				endm 
# End of macro CWHEAD
4e78			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4e78			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4e78			; | | or completely different file system structure. 
4e78			; | | Compatible with PicoSPINet  
4e78			 
4e78					if DEBUG_FORTH_WORDS_KEY 
4e78						DMARK "BUD" 
4e78 f5				push af  
4e79 3a 8d 4e			ld a, (.dmark)  
4e7c 32 6e fe			ld (debug_mark),a  
4e7f 3a 8e 4e			ld a, (.dmark+1)  
4e82 32 6f fe			ld (debug_mark+1),a  
4e85 3a 8f 4e			ld a, (.dmark+2)  
4e88 32 70 fe			ld (debug_mark+2),a  
4e8b 18 03			jr .pastdmark  
4e8d ..			.dmark: db "BUD"  
4e90 f1			.pastdmark: pop af  
4e91			endm  
# End of macro DMARK
4e91						CALLMONITOR 
4e91 cd f3 18			call break_point_state  
4e94				endm  
# End of macro CALLMONITOR
4e94					endif 
4e94			 
4e94				FORTH_DSP_VALUEHL 
4e94 cd 5e 21			call macro_dsp_valuehl 
4e97				endm 
# End of macro FORTH_DSP_VALUEHL
4e97			 
4e97				; calc block address 
4e97			 
4e97 eb				ex de, hl 
4e98 3e 40			ld a, STORE_BLOCK_PHY 
4e9a cd cf 0e			call Mult16 
4e9d			 
4e9d				FORTH_DSP_POP 
4e9d cd 16 22			call macro_forth_dsp_pop 
4ea0				endm 
# End of macro FORTH_DSP_POP
4ea0			 
4ea0			 
4ea0 11 81 fa			ld de, store_page 
4ea3			 
4ea3					if DEBUG_FORTH_WORDS 
4ea3						DMARK "BUe" 
4ea3 f5				push af  
4ea4 3a b8 4e			ld a, (.dmark)  
4ea7 32 6e fe			ld (debug_mark),a  
4eaa 3a b9 4e			ld a, (.dmark+1)  
4ead 32 6f fe			ld (debug_mark+1),a  
4eb0 3a ba 4e			ld a, (.dmark+2)  
4eb3 32 70 fe			ld (debug_mark+2),a  
4eb6 18 03			jr .pastdmark  
4eb8 ..			.dmark: db "BUe"  
4ebb f1			.pastdmark: pop af  
4ebc			endm  
# End of macro DMARK
4ebc						CALLMONITOR 
4ebc cd f3 18			call break_point_state  
4ebf				endm  
# End of macro CALLMONITOR
4ebf					endif 
4ebf			 
4ebf cd 81 04			call storage_write_block 
4ec2			 
4ec2					NEXTW 
4ec2 c3 14 23			jp macro_next 
4ec5				endm 
# End of macro NEXTW
4ec5			 
4ec5			.BYID: 
4ec5			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4ec5			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4ec5			; 
4ec5			;		 
4ec5			;		if DEBUG_FORTH_WORDS_KEY 
4ec5			;			DMARK "BYID" 
4ec5			;			CALLMONITOR 
4ec5			;		endif 
4ec5			; 
4ec5			;		; get direct address 
4ec5			; 
4ec5			;		FORTH_DSP_VALUEHL 
4ec5			; 
4ec5			;		FORTH_DSP_POP 
4ec5			; 
4ec5			;	; calc block address 
4ec5			; 
4ec5			;	ex de, hl 
4ec5			;	ld a, STORE_BLOCK_PHY 
4ec5			;	call Mult16 
4ec5			;	;	do BREAD with number as param 
4ec5			;	; push the file name	 
4ec5			;	ld de, store_page 
4ec5			;	call storage_read_block 
4ec5			 ;       ld hl, store_page+2 
4ec5			; 
4ec5			; 
4ec5			;		NEXTW 
4ec5			;.BYNAME: 
4ec5				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4ec5 3a				db WORD_SYS_CORE+38             
4ec6 de 4e			dw .DIR            
4ec8 06				db 5 + 1 
4ec9 .. 00			db "GETID",0              
4ecf				endm 
# End of macro CWHEAD
4ecf			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4ecf			; | | Compatible with PicoSPINet  
4ecf			 
4ecf					; get pointer to file name to seek 
4ecf			 
4ecf					FORTH_DSP_VALUEHL 
4ecf cd 5e 21			call macro_dsp_valuehl 
4ed2				endm 
# End of macro FORTH_DSP_VALUEHL
4ed2			 
4ed2			 
4ed2 cd 43 03				call storage_getid  
4ed5			 
4ed5					FORTH_DSP_POP 
4ed5 cd 16 22			call macro_forth_dsp_pop 
4ed8				endm 
# End of macro FORTH_DSP_POP
4ed8			 
4ed8 cd 67 1f				call forth_push_numhl 
4edb			 
4edb					NEXTW 
4edb c3 14 23			jp macro_next 
4ede				endm 
# End of macro NEXTW
4ede			; 
4ede			.DIR: 
4ede				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4ede 3a				db WORD_SYS_CORE+38             
4edf e2 4f			dw .SAVE            
4ee1 04				db 3 + 1 
4ee2 .. 00			db "DIR",0              
4ee6				endm 
# End of macro CWHEAD
4ee6			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4ee6			; | | Compatible with PicoSPINet  
4ee6			 
4ee6					if DEBUG_FORTH_WORDS_KEY 
4ee6						DMARK "DIR" 
4ee6 f5				push af  
4ee7 3a fb 4e			ld a, (.dmark)  
4eea 32 6e fe			ld (debug_mark),a  
4eed 3a fc 4e			ld a, (.dmark+1)  
4ef0 32 6f fe			ld (debug_mark+1),a  
4ef3 3a fd 4e			ld a, (.dmark+2)  
4ef6 32 70 fe			ld (debug_mark+2),a  
4ef9 18 03			jr .pastdmark  
4efb ..			.dmark: db "DIR"  
4efe f1			.pastdmark: pop af  
4eff			endm  
# End of macro DMARK
4eff						CALLMONITOR 
4eff cd f3 18			call break_point_state  
4f02				endm  
# End of macro CALLMONITOR
4f02					endif 
4f02 cd cd 04			call storage_get_block_0 
4f05			 
4f05 21 81 fa			ld hl, store_page     ; get current id count 
4f08 46				ld b, (hl) 
4f09 0e 00			ld c, 0    ; count of files   
4f0b					if DEBUG_FORTH_WORDS 
4f0b						DMARK "DI1" 
4f0b f5				push af  
4f0c 3a 20 4f			ld a, (.dmark)  
4f0f 32 6e fe			ld (debug_mark),a  
4f12 3a 21 4f			ld a, (.dmark+1)  
4f15 32 6f fe			ld (debug_mark+1),a  
4f18 3a 22 4f			ld a, (.dmark+2)  
4f1b 32 70 fe			ld (debug_mark+2),a  
4f1e 18 03			jr .pastdmark  
4f20 ..			.dmark: db "DI1"  
4f23 f1			.pastdmark: pop af  
4f24			endm  
# End of macro DMARK
4f24						CALLMONITOR 
4f24 cd f3 18			call break_point_state  
4f27				endm  
# End of macro CALLMONITOR
4f27					endif 
4f27			 
4f27				; check for empty drive 
4f27			 
4f27 3e 00			ld a, 0 
4f29 b8				cp b 
4f2a ca 98 4f			jp z, .dirdone 
4f2d			 
4f2d				; for each of the current ids do a search for them and if found push to stack 
4f2d			 
4f2d c5			.diritem:	push bc 
4f2e 21 40 00				ld hl, STORE_BLOCK_PHY 
4f31 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4f33 58					ld e,b 
4f34			 
4f34			;		if DEBUG_FORTH_WORDS 
4f34			;			DMARK "DI2" 
4f34			;			CALLMONITOR 
4f34			;		endif 
4f34			 
4f34 cd 4f 07				call storage_findnextid 
4f37			 
4f37			;		if DEBUG_FORTH_WORDS 
4f37			;			DMARK "DI3" 
4f37			;			CALLMONITOR 
4f37			;		endif 
4f37			 
4f37					; if found hl will be non zero 
4f37			 
4f37 cd 75 0f				call ishlzero 
4f3a			;		ld a, l 
4f3a			;		add h 
4f3a			; 
4f3a			;		cp 0 
4f3a 28 59				jr z, .dirnotfound 
4f3c			 
4f3c					; increase count 
4f3c			 
4f3c c1					pop bc	 
4f3d 0c					inc c 
4f3e c5					push bc 
4f3f					 
4f3f			 
4f3f					; get file header and push the file name 
4f3f			 
4f3f 11 81 fa				ld de, store_page 
4f42 cd 1c 04				call storage_read_block 
4f45			 
4f45					; push file id to stack 
4f45				 
4f45 3a 81 fa				ld a, (store_page) 
4f48 26 00				ld h, 0 
4f4a 6f					ld l, a 
4f4b cd 67 1f				call forth_push_numhl 
4f4e			 
4f4e					; push extent count to stack  
4f4e				 
4f4e 3a 83 fa				ld a, (store_page+2) 
4f51 26 00				ld h, 0 
4f53 6f					ld l, a 
4f54 cd 67 1f				call forth_push_numhl 
4f57			 
4f57					; push file name 
4f57			 
4f57 21 84 fa				ld hl, store_page+3 
4f5a					if DEBUG_FORTH_WORDS 
4f5a						DMARK "DI5" 
4f5a f5				push af  
4f5b 3a 6f 4f			ld a, (.dmark)  
4f5e 32 6e fe			ld (debug_mark),a  
4f61 3a 70 4f			ld a, (.dmark+1)  
4f64 32 6f fe			ld (debug_mark+1),a  
4f67 3a 71 4f			ld a, (.dmark+2)  
4f6a 32 70 fe			ld (debug_mark+2),a  
4f6d 18 03			jr .pastdmark  
4f6f ..			.dmark: db "DI5"  
4f72 f1			.pastdmark: pop af  
4f73			endm  
# End of macro DMARK
4f73						CALLMONITOR 
4f73 cd f3 18			call break_point_state  
4f76				endm  
# End of macro CALLMONITOR
4f76					endif 
4f76 cd d5 1f				call forth_push_str 
4f79					if DEBUG_FORTH_WORDS 
4f79						DMARK "DI6" 
4f79 f5				push af  
4f7a 3a 8e 4f			ld a, (.dmark)  
4f7d 32 6e fe			ld (debug_mark),a  
4f80 3a 8f 4f			ld a, (.dmark+1)  
4f83 32 6f fe			ld (debug_mark+1),a  
4f86 3a 90 4f			ld a, (.dmark+2)  
4f89 32 70 fe			ld (debug_mark+2),a  
4f8c 18 03			jr .pastdmark  
4f8e ..			.dmark: db "DI6"  
4f91 f1			.pastdmark: pop af  
4f92			endm  
# End of macro DMARK
4f92						CALLMONITOR 
4f92 cd f3 18			call break_point_state  
4f95				endm  
# End of macro CALLMONITOR
4f95					endif 
4f95			.dirnotfound: 
4f95 c1					pop bc     
4f96 10 95				djnz .diritem 
4f98				 
4f98			.dirdone:	 
4f98					if DEBUG_FORTH_WORDS 
4f98						DMARK "DI7" 
4f98 f5				push af  
4f99 3a ad 4f			ld a, (.dmark)  
4f9c 32 6e fe			ld (debug_mark),a  
4f9f 3a ae 4f			ld a, (.dmark+1)  
4fa2 32 6f fe			ld (debug_mark+1),a  
4fa5 3a af 4f			ld a, (.dmark+2)  
4fa8 32 70 fe			ld (debug_mark+2),a  
4fab 18 03			jr .pastdmark  
4fad ..			.dmark: db "DI7"  
4fb0 f1			.pastdmark: pop af  
4fb1			endm  
# End of macro DMARK
4fb1						CALLMONITOR 
4fb1 cd f3 18			call break_point_state  
4fb4				endm  
# End of macro CALLMONITOR
4fb4					endif 
4fb4			 
4fb4					; push a count of the dir items found 
4fb4			 
4fb4 26 00				ld h, 0 
4fb6 69					ld l, c 
4fb7 cd 67 1f				call forth_push_numhl 
4fba			 
4fba					; push the bank label 
4fba			 
4fba cd cd 04				call storage_get_block_0 
4fbd			 
4fbd				 
4fbd 21 84 fa		 		ld hl, store_page+3 
4fc0			 
4fc0					if DEBUG_FORTH_WORDS 
4fc0						DMARK "DI8" 
4fc0 f5				push af  
4fc1 3a d5 4f			ld a, (.dmark)  
4fc4 32 6e fe			ld (debug_mark),a  
4fc7 3a d6 4f			ld a, (.dmark+1)  
4fca 32 6f fe			ld (debug_mark+1),a  
4fcd 3a d7 4f			ld a, (.dmark+2)  
4fd0 32 70 fe			ld (debug_mark+2),a  
4fd3 18 03			jr .pastdmark  
4fd5 ..			.dmark: db "DI8"  
4fd8 f1			.pastdmark: pop af  
4fd9			endm  
# End of macro DMARK
4fd9						CALLMONITOR 
4fd9 cd f3 18			call break_point_state  
4fdc				endm  
# End of macro CALLMONITOR
4fdc					endif 
4fdc cd d5 1f				call forth_push_str 
4fdf			 
4fdf			 
4fdf				 
4fdf					NEXTW 
4fdf c3 14 23			jp macro_next 
4fe2				endm 
# End of macro NEXTW
4fe2			.SAVE: 
4fe2			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4fe2			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4fe2			;		NEXTW 
4fe2			;.LOAD: 
4fe2			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4fe2			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4fe2			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4fe2			;; > > The LOAD command can not be used in any user words or compound lines. 
4fe2			; 
4fe2			;		; store_openext use it. If zero it is EOF 
4fe2			; 
4fe2			;		; read block from current stream id 
4fe2			;		; if the block does not contain zero term keep reading blocks until zero found 
4fe2			;		; push the block to stack 
4fe2			;		; save the block id to stream 
4fe2			; 
4fe2			; 
4fe2			;		FORTH_DSP_VALUEHL 
4fe2			; 
4fe2			;;		push hl 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LOA" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;		FORTH_DSP_POP 
4fe2			; 
4fe2			;;		pop hl 
4fe2			; 
4fe2			;		ld h, l 
4fe2			;		ld l, 0 
4fe2			; 
4fe2			;		push hl     ; stack holds current file id and extent to work with 
4fe2			; 
4fe2			; 
4fe2			;		ld de, store_page      ; get block zero of file 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LO0" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;		call storage_read 
4fe2			; 
4fe2			;		ld a, (store_page+2)    ; max extents for this file 
4fe2			;		ld  (store_openmaxext),a   ; get our limit 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LOE" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			; 
4fe2			;; TODO dont know why max extents are not present 
4fe2			;;		cp 0 
4fe2			;;		jp z, .loadeof     ; dont read past eof 
4fe2			; 
4fe2			;;		ld a, 1   ; start from the head of the file 
4fe2			; 
4fe2			;.loadline:	pop hl 
4fe2			;		inc hl 
4fe2			;		ld  a, (store_openmaxext)   ; get our limit 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LOx" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;		inc a 
4fe2			;		cp l 
4fe2			;		jp z, .loadeof 
4fe2			;		push hl    ; save current extent 
4fe2			; 
4fe2			;		ld de, store_page 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LO1" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;		call storage_read 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LO2" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;	call ishlzero 
4fe2			;	ld a, l 
4fe2			;	add h 
4fe2			;	cp 0 
4fe2			;	jr z, .loadeof 
4fe2			; 
4fe2			;	; not eof so hl should point to data to exec 
4fe2			; 
4fe2			;	; will need to add the FORTH_END_BUFFER flag 
4fe2			 ; 
4fe2			;	ld hl, store_page+2 
4fe2			;	ld bc, 255 
4fe2			;	ld a, 0 
4fe2			;	cpir 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LOt" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;	dec hl 
4fe2			;	ld a, ' ' 
4fe2			;	ld (hl), a 
4fe2			;	inc hl 
4fe2			;	ld (hl), a 
4fe2			;	inc hl 
4fe2			;	ld (hl), a 
4fe2			;	inc hl 
4fe2			;	ld a, FORTH_END_BUFFER 
4fe2			;	ld (hl), a 
4fe2			; 
4fe2			;	; TODO handle more than a single block read 
4fe2			; 
4fe2			; 
4fe2			;	ld hl, store_page+2 
4fe2			; 
4fe2			;	ld (os_tok_ptr), hl 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LO3" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			; 
4fe2			;	call forthparse 
4fe2			;	call forthexec 
4fe2			;	call forthexec_cleanup 
4fe2			; 
4fe2			;	; go to next extent 
4fe2			; 
4fe2			;	; get next block  or mark as eof 
4fe2			;	jp .loadline 
4fe2			; 
4fe2			; 
4fe2			; 
4fe2			;	       NEXTW 
4fe2			;.loadeof:	ld a, 0 
4fe2			;		ld (store_openext), a 
4fe2			; 
4fe2			;	if DEBUG_STORESE 
4fe2			;		DMARK "LOF" 
4fe2			;		CALLMONITOR 
4fe2			;	endif 
4fe2			;		ret 
4fe2			;		;NEXTW 
4fe2			;.BSAVE:   
4fe2			; 
4fe2			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4fe2			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4fe2			;		NEXTW 
4fe2			;.BLOAD: 
4fe2			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4fe2			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4fe2			;		NEXTW 
4fe2			;;;; counter gap 
4fe2			 
4fe2			 
4fe2			.SEO: 
4fe2				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4fe2 64				db WORD_SYS_CORE+80             
4fe3 01 50			dw .SEI            
4fe5 04				db 3 + 1 
4fe6 .. 00			db "SEO",0              
4fea				endm 
# End of macro CWHEAD
4fea			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4fea			 
4fea					; get port 
4fea			 
4fea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fea cd 5e 21			call macro_dsp_valuehl 
4fed				endm 
# End of macro FORTH_DSP_VALUEHL
4fed			 
4fed e5					push hl    ; u2 - byte 
4fee			 
4fee					; destroy value TOS 
4fee			 
4fee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fee cd 16 22			call macro_forth_dsp_pop 
4ff1				endm 
# End of macro FORTH_DSP_POP
4ff1			 
4ff1					; get byte to send 
4ff1			 
4ff1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ff1 cd 5e 21			call macro_dsp_valuehl 
4ff4				endm 
# End of macro FORTH_DSP_VALUEHL
4ff4			 
4ff4 e5					push hl    ; u1 - addr 
4ff5			 
4ff5					; destroy value TOS 
4ff5			 
4ff5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ff5 cd 16 22			call macro_forth_dsp_pop 
4ff8				endm 
# End of macro FORTH_DSP_POP
4ff8			 
4ff8					; one value on hl get other one back 
4ff8			 
4ff8 d1					pop de   ; u1 - byte 
4ff9			 
4ff9 e1					pop hl   ; u2 - addr 
4ffa			 
4ffa					; TODO Send SPI byte 
4ffa			 
4ffa			 
4ffa 7b					ld a, e 
4ffb cd 21 02				call se_writebyte 
4ffe			 
4ffe					 
4ffe			 
4ffe					NEXTW 
4ffe c3 14 23			jp macro_next 
5001				endm 
# End of macro NEXTW
5001			 
5001			.SEI: 
5001				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5001 65				db WORD_SYS_CORE+81             
5002 1b 50			dw .SFREE            
5004 04				db 3 + 1 
5005 .. 00			db "SEI",0              
5009				endm 
# End of macro CWHEAD
5009			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5009			 
5009					; get port 
5009			 
5009					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5009 cd 5e 21			call macro_dsp_valuehl 
500c				endm 
# End of macro FORTH_DSP_VALUEHL
500c			 
500c			;		push hl 
500c			 
500c					; destroy value TOS 
500c			 
500c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
500c cd 16 22			call macro_forth_dsp_pop 
500f				endm 
# End of macro FORTH_DSP_POP
500f			 
500f					; one value on hl get other one back 
500f			 
500f			;		pop hl 
500f			 
500f			 
500f					; TODO Get SPI byte 
500f			 
500f cd c3 02				call se_readbyte 
5012			 
5012 26 00				ld h, 0 
5014 6f					ld l, a 
5015 cd 67 1f				call forth_push_numhl 
5018			 
5018					NEXTW 
5018 c3 14 23			jp macro_next 
501b				endm 
# End of macro NEXTW
501b			 
501b			.SFREE: 
501b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
501b 67				db WORD_SYS_CORE+83             
501c 4a 50			dw .SIZE            
501e 06				db 5 + 1 
501f .. 00			db "FFREE",0              
5025				endm 
# End of macro CWHEAD
5025			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5025			; | | Compatible with PicoSPINet  
5025					if DEBUG_FORTH_WORDS_KEY 
5025						DMARK "FFR" 
5025 f5				push af  
5026 3a 3a 50			ld a, (.dmark)  
5029 32 6e fe			ld (debug_mark),a  
502c 3a 3b 50			ld a, (.dmark+1)  
502f 32 6f fe			ld (debug_mark+1),a  
5032 3a 3c 50			ld a, (.dmark+2)  
5035 32 70 fe			ld (debug_mark+2),a  
5038 18 03			jr .pastdmark  
503a ..			.dmark: db "FFR"  
503d f1			.pastdmark: pop af  
503e			endm  
# End of macro DMARK
503e						CALLMONITOR 
503e cd f3 18			call break_point_state  
5041				endm  
# End of macro CALLMONITOR
5041					endif 
5041			 
5041 cd e9 07				call storage_freeblocks 
5044			 
5044 cd 67 1f				call forth_push_numhl 
5047			 
5047				       NEXTW 
5047 c3 14 23			jp macro_next 
504a				endm 
# End of macro NEXTW
504a			.SIZE: 
504a				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
504a 67				db WORD_SYS_CORE+83             
504b 7e 50			dw .CREATE            
504d 05				db 4 + 1 
504e .. 00			db "SIZE",0              
5053				endm 
# End of macro CWHEAD
5053			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5053			; | | Compatible with PicoSPINet  
5053					if DEBUG_FORTH_WORDS_KEY 
5053						DMARK "SIZ" 
5053 f5				push af  
5054 3a 68 50			ld a, (.dmark)  
5057 32 6e fe			ld (debug_mark),a  
505a 3a 69 50			ld a, (.dmark+1)  
505d 32 6f fe			ld (debug_mark+1),a  
5060 3a 6a 50			ld a, (.dmark+2)  
5063 32 70 fe			ld (debug_mark+2),a  
5066 18 03			jr .pastdmark  
5068 ..			.dmark: db "SIZ"  
506b f1			.pastdmark: pop af  
506c			endm  
# End of macro DMARK
506c						CALLMONITOR 
506c cd f3 18			call break_point_state  
506f				endm  
# End of macro CALLMONITOR
506f					endif 
506f			 
506f					FORTH_DSP_VALUEHL 
506f cd 5e 21			call macro_dsp_valuehl 
5072				endm 
# End of macro FORTH_DSP_VALUEHL
5072			;		push hl 
5072					FORTH_DSP_POP 
5072 cd 16 22			call macro_forth_dsp_pop 
5075				endm 
# End of macro FORTH_DSP_POP
5075			;		pop hl 
5075 cd 4b 04				call storage_file_size 
5078			 
5078 cd 67 1f				call forth_push_numhl 
507b			  
507b			 
507b				       NEXTW 
507b c3 14 23			jp macro_next 
507e				endm 
# End of macro NEXTW
507e			 
507e			.CREATE: 
507e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
507e 68				db WORD_SYS_CORE+84             
507f ec 50			dw .APPEND            
5081 07				db 6 + 1 
5082 .. 00			db "CREATE",0              
5089				endm 
# End of macro CWHEAD
5089			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5089			; | | e.g.  
5089			; | | TestProgram CREATE 
5089			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5089			; | |  
5089			; | | Max file IDs are 255. 
5089			; | |  
5089			; | | Compatible with PicoSPINet  
5089					 
5089					if DEBUG_FORTH_WORDS_KEY 
5089						DMARK "CRT" 
5089 f5				push af  
508a 3a 9e 50			ld a, (.dmark)  
508d 32 6e fe			ld (debug_mark),a  
5090 3a 9f 50			ld a, (.dmark+1)  
5093 32 6f fe			ld (debug_mark+1),a  
5096 3a a0 50			ld a, (.dmark+2)  
5099 32 70 fe			ld (debug_mark+2),a  
509c 18 03			jr .pastdmark  
509e ..			.dmark: db "CRT"  
50a1 f1			.pastdmark: pop af  
50a2			endm  
# End of macro DMARK
50a2						CALLMONITOR 
50a2 cd f3 18			call break_point_state  
50a5				endm  
# End of macro CALLMONITOR
50a5					endif 
50a5			;		call storage_get_block_0 
50a5			 
50a5					; TODO pop hl 
50a5			 
50a5					;v5 FORTH_DSP_VALUE 
50a5					FORTH_DSP_VALUE 
50a5 cd 47 21			call macro_forth_dsp_value 
50a8				endm 
# End of macro FORTH_DSP_VALUE
50a8			 
50a8				if DEBUG_STORESE 
50a8					DMARK "CR1" 
50a8 f5				push af  
50a9 3a bd 50			ld a, (.dmark)  
50ac 32 6e fe			ld (debug_mark),a  
50af 3a be 50			ld a, (.dmark+1)  
50b2 32 6f fe			ld (debug_mark+1),a  
50b5 3a bf 50			ld a, (.dmark+2)  
50b8 32 70 fe			ld (debug_mark+2),a  
50bb 18 03			jr .pastdmark  
50bd ..			.dmark: db "CR1"  
50c0 f1			.pastdmark: pop af  
50c1			endm  
# End of macro DMARK
50c1					CALLMONITOR 
50c1 cd f3 18			call break_point_state  
50c4				endm  
# End of macro CALLMONITOR
50c4				endif 
50c4			;		push hl 
50c4			;		FORTH_DSP_POP 
50c4			;		pop hl 
50c4			 
50c4			;		inc hl   ; move past the type marker 
50c4			 
50c4 cd 1f 08				call storage_create 
50c7			 
50c7				if DEBUG_STORESE 
50c7					DMARK "CT1" 
50c7 f5				push af  
50c8 3a dc 50			ld a, (.dmark)  
50cb 32 6e fe			ld (debug_mark),a  
50ce 3a dd 50			ld a, (.dmark+1)  
50d1 32 6f fe			ld (debug_mark+1),a  
50d4 3a de 50			ld a, (.dmark+2)  
50d7 32 70 fe			ld (debug_mark+2),a  
50da 18 03			jr .pastdmark  
50dc ..			.dmark: db "CT1"  
50df f1			.pastdmark: pop af  
50e0			endm  
# End of macro DMARK
50e0					CALLMONITOR 
50e0 cd f3 18			call break_point_state  
50e3				endm  
# End of macro CALLMONITOR
50e3				endif 
50e3			;		push hl 
50e3					FORTH_DSP_POP 
50e3 cd 16 22			call macro_forth_dsp_pop 
50e6				endm 
# End of macro FORTH_DSP_POP
50e6			;		pop hl 
50e6					; push file id to stack 
50e6 cd 67 1f				call forth_push_numhl 
50e9			 
50e9			 
50e9			 
50e9				       NEXTW 
50e9 c3 14 23			jp macro_next 
50ec				endm 
# End of macro NEXTW
50ec			 
50ec			.APPEND: 
50ec				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
50ec 69				db WORD_SYS_CORE+85             
50ed 7d 51			dw .SDEL            
50ef 07				db 6 + 1 
50f0 .. 00			db "APPEND",0              
50f7				endm 
# End of macro CWHEAD
50f7			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
50f7			; | | e.g. 
50f7			; | | Test CREATE      -> $01 
50f7			; | | "A string to add to file" $01 APPEND 
50f7			; | |  
50f7			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
50f7			; | | Compatible with PicoSPINet  
50f7					if DEBUG_FORTH_WORDS_KEY 
50f7						DMARK "APP" 
50f7 f5				push af  
50f8 3a 0c 51			ld a, (.dmark)  
50fb 32 6e fe			ld (debug_mark),a  
50fe 3a 0d 51			ld a, (.dmark+1)  
5101 32 6f fe			ld (debug_mark+1),a  
5104 3a 0e 51			ld a, (.dmark+2)  
5107 32 70 fe			ld (debug_mark+2),a  
510a 18 03			jr .pastdmark  
510c ..			.dmark: db "APP"  
510f f1			.pastdmark: pop af  
5110			endm  
# End of macro DMARK
5110						CALLMONITOR 
5110 cd f3 18			call break_point_state  
5113				endm  
# End of macro CALLMONITOR
5113					endif 
5113			 
5113					FORTH_DSP_VALUEHL 
5113 cd 5e 21			call macro_dsp_valuehl 
5116				endm 
# End of macro FORTH_DSP_VALUEHL
5116 e5					push hl 	; save file id 
5117			 
5117				if DEBUG_STORESE 
5117					DMARK "AP1" 
5117 f5				push af  
5118 3a 2c 51			ld a, (.dmark)  
511b 32 6e fe			ld (debug_mark),a  
511e 3a 2d 51			ld a, (.dmark+1)  
5121 32 6f fe			ld (debug_mark+1),a  
5124 3a 2e 51			ld a, (.dmark+2)  
5127 32 70 fe			ld (debug_mark+2),a  
512a 18 03			jr .pastdmark  
512c ..			.dmark: db "AP1"  
512f f1			.pastdmark: pop af  
5130			endm  
# End of macro DMARK
5130					CALLMONITOR 
5130 cd f3 18			call break_point_state  
5133				endm  
# End of macro CALLMONITOR
5133				endif 
5133					FORTH_DSP_POP 
5133 cd 16 22			call macro_forth_dsp_pop 
5136				endm 
# End of macro FORTH_DSP_POP
5136			 
5136					FORTH_DSP_VALUEHL 
5136 cd 5e 21			call macro_dsp_valuehl 
5139				endm 
# End of macro FORTH_DSP_VALUEHL
5139					;v5 FORTH_DSP_VALUE 
5139 e5					push hl 	; save ptr to string to save 
513a			 
513a				if DEBUG_STORESE 
513a					DMARK "AP1" 
513a f5				push af  
513b 3a 4f 51			ld a, (.dmark)  
513e 32 6e fe			ld (debug_mark),a  
5141 3a 50 51			ld a, (.dmark+1)  
5144 32 6f fe			ld (debug_mark+1),a  
5147 3a 51 51			ld a, (.dmark+2)  
514a 32 70 fe			ld (debug_mark+2),a  
514d 18 03			jr .pastdmark  
514f ..			.dmark: db "AP1"  
5152 f1			.pastdmark: pop af  
5153			endm  
# End of macro DMARK
5153					CALLMONITOR 
5153 cd f3 18			call break_point_state  
5156				endm  
# End of macro CALLMONITOR
5156				endif 
5156					FORTH_DSP_POP 
5156 cd 16 22			call macro_forth_dsp_pop 
5159				endm 
# End of macro FORTH_DSP_POP
5159			 
5159 d1					pop de 
515a e1					pop hl 
515b				if DEBUG_STORESE 
515b					DMARK "AP2" 
515b f5				push af  
515c 3a 70 51			ld a, (.dmark)  
515f 32 6e fe			ld (debug_mark),a  
5162 3a 71 51			ld a, (.dmark+1)  
5165 32 6f fe			ld (debug_mark+1),a  
5168 3a 72 51			ld a, (.dmark+2)  
516b 32 70 fe			ld (debug_mark+2),a  
516e 18 03			jr .pastdmark  
5170 ..			.dmark: db "AP2"  
5173 f1			.pastdmark: pop af  
5174			endm  
# End of macro DMARK
5174					CALLMONITOR 
5174 cd f3 18			call break_point_state  
5177				endm  
# End of macro CALLMONITOR
5177				endif 
5177					;inc de ; skip var type indicator 
5177			 
5177					; TODO how to append numerics???? 
5177			 
5177 cd 0c 0b				call storage_append		 
517a			 
517a				       NEXTW 
517a c3 14 23			jp macro_next 
517d				endm 
# End of macro NEXTW
517d			.SDEL: 
517d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
517d 6a				db WORD_SYS_CORE+86             
517e c9 51			dw .OPEN            
5180 05				db 4 + 1 
5181 .. 00			db "ERA",0              
5185				endm 
# End of macro CWHEAD
5185			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5185			; | | Compatible with PicoSPINet  
5185					FORTH_DSP_VALUEHL 
5185 cd 5e 21			call macro_dsp_valuehl 
5188				endm 
# End of macro FORTH_DSP_VALUEHL
5188			;		push hl 	; save file id 
5188			 
5188					if DEBUG_FORTH_WORDS_KEY 
5188						DMARK "ERA" 
5188 f5				push af  
5189 3a 9d 51			ld a, (.dmark)  
518c 32 6e fe			ld (debug_mark),a  
518f 3a 9e 51			ld a, (.dmark+1)  
5192 32 6f fe			ld (debug_mark+1),a  
5195 3a 9f 51			ld a, (.dmark+2)  
5198 32 70 fe			ld (debug_mark+2),a  
519b 18 03			jr .pastdmark  
519d ..			.dmark: db "ERA"  
51a0 f1			.pastdmark: pop af  
51a1			endm  
# End of macro DMARK
51a1						CALLMONITOR 
51a1 cd f3 18			call break_point_state  
51a4				endm  
# End of macro CALLMONITOR
51a4					endif 
51a4				if DEBUG_STORESE 
51a4					DMARK "ER1" 
51a4 f5				push af  
51a5 3a b9 51			ld a, (.dmark)  
51a8 32 6e fe			ld (debug_mark),a  
51ab 3a ba 51			ld a, (.dmark+1)  
51ae 32 6f fe			ld (debug_mark+1),a  
51b1 3a bb 51			ld a, (.dmark+2)  
51b4 32 70 fe			ld (debug_mark+2),a  
51b7 18 03			jr .pastdmark  
51b9 ..			.dmark: db "ER1"  
51bc f1			.pastdmark: pop af  
51bd			endm  
# End of macro DMARK
51bd					CALLMONITOR 
51bd cd f3 18			call break_point_state  
51c0				endm  
# End of macro CALLMONITOR
51c0				endif 
51c0					FORTH_DSP_POP 
51c0 cd 16 22			call macro_forth_dsp_pop 
51c3				endm 
# End of macro FORTH_DSP_POP
51c3			 
51c3			;		pop hl 
51c3			 
51c3 cd 5e 06				call storage_erase 
51c6				       NEXTW 
51c6 c3 14 23			jp macro_next 
51c9				endm 
# End of macro NEXTW
51c9			 
51c9			.OPEN: 
51c9				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
51c9 6b				db WORD_SYS_CORE+87             
51ca 5d 52			dw .READ            
51cc 05				db 4 + 1 
51cd .. 00			db "OPEN",0              
51d2				endm 
# End of macro CWHEAD
51d2			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
51d2			; | | e.g. 
51d2			; | | $01 OPEN $01 DO $01 READ . LOOP 
51d2			; | | 
51d2			; | | Will return with 255 blocks if the file does not exist 
51d2			; | | Compatible with PicoSPINet  
51d2			 
51d2					if DEBUG_FORTH_WORDS_KEY 
51d2						DMARK "OPN" 
51d2 f5				push af  
51d3 3a e7 51			ld a, (.dmark)  
51d6 32 6e fe			ld (debug_mark),a  
51d9 3a e8 51			ld a, (.dmark+1)  
51dc 32 6f fe			ld (debug_mark+1),a  
51df 3a e9 51			ld a, (.dmark+2)  
51e2 32 70 fe			ld (debug_mark+2),a  
51e5 18 03			jr .pastdmark  
51e7 ..			.dmark: db "OPN"  
51ea f1			.pastdmark: pop af  
51eb			endm  
# End of macro DMARK
51eb						CALLMONITOR 
51eb cd f3 18			call break_point_state  
51ee				endm  
# End of macro CALLMONITOR
51ee					endif 
51ee					; TODO handle multiple file opens 
51ee			 
51ee 3e 01			       	ld a, 1 
51f0 32 71 fa				ld (store_openext), a 
51f3			 
51f3					; get max extents for this file 
51f3				 
51f3								 
51f3					FORTH_DSP_VALUEHL 
51f3 cd 5e 21			call macro_dsp_valuehl 
51f6				endm 
# End of macro FORTH_DSP_VALUEHL
51f6			 
51f6 65					ld h, l 
51f7 2e 00				ld l, 0 
51f9			 
51f9					; store file id 
51f9			 
51f9 7c					ld a, h 
51fa 32 6e fa				ld (store_filecache), a 
51fd			 
51fd				if DEBUG_STORESE 
51fd					DMARK "OPN" 
51fd f5				push af  
51fe 3a 12 52			ld a, (.dmark)  
5201 32 6e fe			ld (debug_mark),a  
5204 3a 13 52			ld a, (.dmark+1)  
5207 32 6f fe			ld (debug_mark+1),a  
520a 3a 14 52			ld a, (.dmark+2)  
520d 32 70 fe			ld (debug_mark+2),a  
5210 18 03			jr .pastdmark  
5212 ..			.dmark: db "OPN"  
5215 f1			.pastdmark: pop af  
5216			endm  
# End of macro DMARK
5216					CALLMONITOR 
5216 cd f3 18			call break_point_state  
5219				endm  
# End of macro CALLMONITOR
5219				endif 
5219			;		push hl 
5219					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5219 cd 16 22			call macro_forth_dsp_pop 
521c				endm 
# End of macro FORTH_DSP_POP
521c			;		pop hl 
521c						 
521c 11 81 fa				ld de, store_page      ; get block zero of file 
521f cd 75 09				call storage_read 
5222 cd 75 0f			call ishlzero 
5225 20 04			jr nz, .opfound 
5227			 
5227				; file does not exist so indicate with 255 extents in use 
5227			 
5227 3e ff			ld a, 255 
5229 18 29			jr .skipopeneof 
522b			 
522b			 
522b			.opfound: 
522b			 
522b			 
522b 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
522e 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
5231					 
5231				if DEBUG_STORESE 
5231					DMARK "OPx" 
5231 f5				push af  
5232 3a 46 52			ld a, (.dmark)  
5235 32 6e fe			ld (debug_mark),a  
5238 3a 47 52			ld a, (.dmark+1)  
523b 32 6f fe			ld (debug_mark+1),a  
523e 3a 48 52			ld a, (.dmark+2)  
5241 32 70 fe			ld (debug_mark+2),a  
5244 18 03			jr .pastdmark  
5246 ..			.dmark: db "OPx"  
5249 f1			.pastdmark: pop af  
524a			endm  
# End of macro DMARK
524a					CALLMONITOR 
524a cd f3 18			call break_point_state  
524d				endm  
# End of macro CALLMONITOR
524d				endif 
524d fe 00				cp 0 
524f 20 03				jr nz, .skipopeneof 
5251					; have opened an empty file 
5251					 
5251 32 71 fa				ld (store_openext), a 
5254			 
5254			.skipopeneof: 
5254			 
5254 6f					ld l, a 
5255 26 00				ld h, 0 
5257 cd 67 1f				call forth_push_numhl 
525a			 
525a			 
525a				       NEXTW 
525a c3 14 23			jp macro_next 
525d				endm 
# End of macro NEXTW
525d			.READ: 
525d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
525d 6c				db WORD_SYS_CORE+88             
525e 87 53			dw .EOF            
5260 05				db 4 + 1 
5261 .. 00			db "READ",0              
5266				endm 
# End of macro CWHEAD
5266			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5266			; | | e.g. 
5266			; | | $01 OPEN $01 DO READ . LOOP 
5266			; | | 
5266			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5266			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5266			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5266			; | | two bytes contain the file id and extent. 
5266			; | |  
5266			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5266			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5266			; | | Compatible with PicoSPINet  
5266			 
5266					if DEBUG_FORTH_WORDS_KEY 
5266						DMARK "REA" 
5266 f5				push af  
5267 3a 7b 52			ld a, (.dmark)  
526a 32 6e fe			ld (debug_mark),a  
526d 3a 7c 52			ld a, (.dmark+1)  
5270 32 6f fe			ld (debug_mark+1),a  
5273 3a 7d 52			ld a, (.dmark+2)  
5276 32 70 fe			ld (debug_mark+2),a  
5279 18 03			jr .pastdmark  
527b ..			.dmark: db "REA"  
527e f1			.pastdmark: pop af  
527f			endm  
# End of macro DMARK
527f						CALLMONITOR 
527f cd f3 18			call break_point_state  
5282				endm  
# End of macro CALLMONITOR
5282					endif 
5282					; store_openext use it. If zero it is EOF 
5282			 
5282					; read block from current stream id 
5282					; if the block does not contain zero term keep reading blocks until zero found 
5282					; push the block to stack 
5282					; save the block id to stream 
5282			 
5282			 
5282 cd b4 53				call .testeof 
5285 3e 01				ld a, 1 
5287 bd					cp l 
5288 ca 63 53				jp z, .ateof 
528b			 
528b			 
528b			;		FORTH_DSP_VALUEHL 
528b			 
528b			;		push hl 
528b			 
528b			;	if DEBUG_STORESE 
528b			;		DMARK "REA" 
528b			;		CALLMONITOR 
528b			;	endif 
528b			;		FORTH_DSP_POP 
528b			 
528b			;		pop hl 
528b				 
528b 3a 6e fa				ld a, (store_filecache) 
528e 67					ld h,a 
528f			 
528f 3a 71 fa				ld a, (store_openext) 
5292 6f					ld l, a 
5293					 
5293 fe 00				cp 0 
5295 ca 63 53				jp z, .ateof     ; dont read past eof 
5298			 
5298 cd 58 0c				call storage_clear_page 
529b			 
529b 11 81 fa				ld de, store_page 
529e				if DEBUG_STORESE 
529e					DMARK "RE1" 
529e f5				push af  
529f 3a b3 52			ld a, (.dmark)  
52a2 32 6e fe			ld (debug_mark),a  
52a5 3a b4 52			ld a, (.dmark+1)  
52a8 32 6f fe			ld (debug_mark+1),a  
52ab 3a b5 52			ld a, (.dmark+2)  
52ae 32 70 fe			ld (debug_mark+2),a  
52b1 18 03			jr .pastdmark  
52b3 ..			.dmark: db "RE1"  
52b6 f1			.pastdmark: pop af  
52b7			endm  
# End of macro DMARK
52b7					CALLMONITOR 
52b7 cd f3 18			call break_point_state  
52ba				endm  
# End of macro CALLMONITOR
52ba				endif 
52ba cd 75 09				call storage_read 
52bd			 
52bd				if DEBUG_STORESE 
52bd					DMARK "RE2" 
52bd f5				push af  
52be 3a d2 52			ld a, (.dmark)  
52c1 32 6e fe			ld (debug_mark),a  
52c4 3a d3 52			ld a, (.dmark+1)  
52c7 32 6f fe			ld (debug_mark+1),a  
52ca 3a d4 52			ld a, (.dmark+2)  
52cd 32 70 fe			ld (debug_mark+2),a  
52d0 18 03			jr .pastdmark  
52d2 ..			.dmark: db "RE2"  
52d5 f1			.pastdmark: pop af  
52d6			endm  
# End of macro DMARK
52d6					CALLMONITOR 
52d6 cd f3 18			call break_point_state  
52d9				endm  
# End of macro CALLMONITOR
52d9				endif 
52d9 cd 75 0f			call ishlzero 
52dc			;	ld a, l 
52dc			;	add h 
52dc			;	cp 0 
52dc ca 63 53			jp z, .readeof 
52df			 
52df				; not eof so hl should point to data to push to stack 
52df			 
52df				if DEBUG_STORESE 
52df					DMARK "RE3" 
52df f5				push af  
52e0 3a f4 52			ld a, (.dmark)  
52e3 32 6e fe			ld (debug_mark),a  
52e6 3a f5 52			ld a, (.dmark+1)  
52e9 32 6f fe			ld (debug_mark+1),a  
52ec 3a f6 52			ld a, (.dmark+2)  
52ef 32 70 fe			ld (debug_mark+2),a  
52f2 18 03			jr .pastdmark  
52f4 ..			.dmark: db "RE3"  
52f7 f1			.pastdmark: pop af  
52f8			endm  
# End of macro DMARK
52f8					CALLMONITOR 
52f8 cd f3 18			call break_point_state  
52fb				endm  
# End of macro CALLMONITOR
52fb				endif 
52fb cd d5 1f			call forth_push_str 
52fe			 
52fe				if DEBUG_STORESE 
52fe					DMARK "RE4" 
52fe f5				push af  
52ff 3a 13 53			ld a, (.dmark)  
5302 32 6e fe			ld (debug_mark),a  
5305 3a 14 53			ld a, (.dmark+1)  
5308 32 6f fe			ld (debug_mark+1),a  
530b 3a 15 53			ld a, (.dmark+2)  
530e 32 70 fe			ld (debug_mark+2),a  
5311 18 03			jr .pastdmark  
5313 ..			.dmark: db "RE4"  
5316 f1			.pastdmark: pop af  
5317			endm  
# End of macro DMARK
5317					CALLMONITOR 
5317 cd f3 18			call break_point_state  
531a				endm  
# End of macro CALLMONITOR
531a				endif 
531a				; get next block  or mark as eof 
531a			 
531a 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
531d 4f				ld c, a	 
531e 3a 71 fa			ld a, (store_openext) 
5321			 
5321				if DEBUG_STORESE 
5321					DMARK "RE5" 
5321 f5				push af  
5322 3a 36 53			ld a, (.dmark)  
5325 32 6e fe			ld (debug_mark),a  
5328 3a 37 53			ld a, (.dmark+1)  
532b 32 6f fe			ld (debug_mark+1),a  
532e 3a 38 53			ld a, (.dmark+2)  
5331 32 70 fe			ld (debug_mark+2),a  
5334 18 03			jr .pastdmark  
5336 ..			.dmark: db "RE5"  
5339 f1			.pastdmark: pop af  
533a			endm  
# End of macro DMARK
533a					CALLMONITOR 
533a cd f3 18			call break_point_state  
533d				endm  
# End of macro CALLMONITOR
533d				endif 
533d b9				cp c 
533e 28 23			jr z, .readeof     ; at last extent 
5340			 
5340 3c					inc a 
5341 32 71 fa				ld (store_openext), a 
5344			 
5344				if DEBUG_STORESE 
5344					DMARK "RE6" 
5344 f5				push af  
5345 3a 59 53			ld a, (.dmark)  
5348 32 6e fe			ld (debug_mark),a  
534b 3a 5a 53			ld a, (.dmark+1)  
534e 32 6f fe			ld (debug_mark+1),a  
5351 3a 5b 53			ld a, (.dmark+2)  
5354 32 70 fe			ld (debug_mark+2),a  
5357 18 03			jr .pastdmark  
5359 ..			.dmark: db "RE6"  
535c f1			.pastdmark: pop af  
535d			endm  
# End of macro DMARK
535d					CALLMONITOR 
535d cd f3 18			call break_point_state  
5360				endm  
# End of macro CALLMONITOR
5360				endif 
5360			 
5360			 
5360				       NEXTW 
5360 c3 14 23			jp macro_next 
5363				endm 
# End of macro NEXTW
5363			.ateof: 
5363				;	ld hl, .showeof 
5363				;	call forth_push_str 
5363 3e 00		.readeof:	ld a, 0 
5365 32 71 fa				ld (store_openext), a 
5368			 
5368					 
5368				if DEBUG_STORESE 
5368					DMARK "REF" 
5368 f5				push af  
5369 3a 7d 53			ld a, (.dmark)  
536c 32 6e fe			ld (debug_mark),a  
536f 3a 7e 53			ld a, (.dmark+1)  
5372 32 6f fe			ld (debug_mark+1),a  
5375 3a 7f 53			ld a, (.dmark+2)  
5378 32 70 fe			ld (debug_mark+2),a  
537b 18 03			jr .pastdmark  
537d ..			.dmark: db "REF"  
5380 f1			.pastdmark: pop af  
5381			endm  
# End of macro DMARK
5381					CALLMONITOR 
5381 cd f3 18			call break_point_state  
5384				endm  
# End of macro CALLMONITOR
5384				endif 
5384				       NEXTW 
5384 c3 14 23			jp macro_next 
5387				endm 
# End of macro NEXTW
5387			 
5387			;.showeof:   db "eof", 0 
5387			 
5387			 
5387			.EOF: 
5387				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5387 6d				db WORD_SYS_CORE+89             
5388 c9 53			dw .FORMAT            
538a 04				db 3 + 1 
538b .. 00			db "EOF",0              
538f				endm 
# End of macro CWHEAD
538f			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
538f			; | | e.g. 
538f			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
538f			; | | Compatible with PicoSPINet  
538f					; TODO if current block id for stream is zero then push true else false 
538f			 
538f					if DEBUG_FORTH_WORDS_KEY 
538f						DMARK "EOF" 
538f f5				push af  
5390 3a a4 53			ld a, (.dmark)  
5393 32 6e fe			ld (debug_mark),a  
5396 3a a5 53			ld a, (.dmark+1)  
5399 32 6f fe			ld (debug_mark+1),a  
539c 3a a6 53			ld a, (.dmark+2)  
539f 32 70 fe			ld (debug_mark+2),a  
53a2 18 03			jr .pastdmark  
53a4 ..			.dmark: db "EOF"  
53a7 f1			.pastdmark: pop af  
53a8			endm  
# End of macro DMARK
53a8						CALLMONITOR 
53a8 cd f3 18			call break_point_state  
53ab				endm  
# End of macro CALLMONITOR
53ab					endif 
53ab			 
53ab					; TODO handlue multiple file streams 
53ab			 
53ab			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
53ab cd b4 53				call .testeof 
53ae cd 67 1f				call forth_push_numhl 
53b1			 
53b1			 
53b1				       NEXTW 
53b1 c3 14 23			jp macro_next 
53b4				endm 
# End of macro NEXTW
53b4			 
53b4			.testeof: 
53b4 2e 01				ld l, 1 
53b6 3a 70 fa				ld a, (store_openmaxext) 
53b9 fe 00				cp 0 
53bb 28 09				jr  z, .eofdone   ; empty file 
53bd 3a 71 fa				ld a, (store_openext) 
53c0 fe 00				cp 0 
53c2 28 02				jr  z, .eofdone 
53c4 2e 00				ld l, 0 
53c6 26 00		.eofdone:	ld h, 0 
53c8 c9					ret 
53c9			 
53c9			 
53c9			 
53c9			 
53c9			.FORMAT: 
53c9				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
53c9 6d				db WORD_SYS_CORE+89             
53ca 1a 54			dw .LABEL            
53cc 07				db 6 + 1 
53cd .. 00			db "FORMAT",0              
53d4				endm 
# End of macro CWHEAD
53d4			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
53d4			; | | Compatible with PicoSPINet  
53d4					; TODO if current block id for stream is zero then push true else false 
53d4				 
53d4				if DEBUG_STORESE 
53d4					DMARK "FOR" 
53d4 f5				push af  
53d5 3a e9 53			ld a, (.dmark)  
53d8 32 6e fe			ld (debug_mark),a  
53db 3a ea 53			ld a, (.dmark+1)  
53de 32 6f fe			ld (debug_mark+1),a  
53e1 3a eb 53			ld a, (.dmark+2)  
53e4 32 70 fe			ld (debug_mark+2),a  
53e7 18 03			jr .pastdmark  
53e9 ..			.dmark: db "FOR"  
53ec f1			.pastdmark: pop af  
53ed			endm  
# End of macro DMARK
53ed					CALLMONITOR 
53ed cd f3 18			call break_point_state  
53f0				endm  
# End of macro CALLMONITOR
53f0				endif 
53f0					; Wipes the bank check flags to cause a reformat on next block 0 read 
53f0			 
53f0 21 01 00				ld hl, 1 
53f3 3e 00				ld a, 0 
53f5 cd 21 02				call se_writebyte 
53f8			 
53f8				if DEBUG_STORESE 
53f8					DMARK "FO0" 
53f8 f5				push af  
53f9 3a 0d 54			ld a, (.dmark)  
53fc 32 6e fe			ld (debug_mark),a  
53ff 3a 0e 54			ld a, (.dmark+1)  
5402 32 6f fe			ld (debug_mark+1),a  
5405 3a 0f 54			ld a, (.dmark+2)  
5408 32 70 fe			ld (debug_mark+2),a  
540b 18 03			jr .pastdmark  
540d ..			.dmark: db "FO0"  
5410 f1			.pastdmark: pop af  
5411			endm  
# End of macro DMARK
5411					CALLMONITOR 
5411 cd f3 18			call break_point_state  
5414				endm  
# End of macro CALLMONITOR
5414				endif 
5414					; force bank init 
5414			 
5414 cd cd 04				call storage_get_block_0 
5417					 
5417				       NEXTW 
5417 c3 14 23			jp macro_next 
541a				endm 
# End of macro NEXTW
541a			.LABEL: 
541a				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
541a 6d				db WORD_SYS_CORE+89             
541b 68 54			dw .STOREPAGE            
541d 06				db 5 + 1 
541e .. 00			db "LABEL",0              
5424				endm 
# End of macro CWHEAD
5424			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5424			; | | Compatible with PicoSPINet  
5424					; TODO test to see if bank is selected 
5424				 
5424					if DEBUG_FORTH_WORDS_KEY 
5424						DMARK "LBL" 
5424 f5				push af  
5425 3a 39 54			ld a, (.dmark)  
5428 32 6e fe			ld (debug_mark),a  
542b 3a 3a 54			ld a, (.dmark+1)  
542e 32 6f fe			ld (debug_mark+1),a  
5431 3a 3b 54			ld a, (.dmark+2)  
5434 32 70 fe			ld (debug_mark+2),a  
5437 18 03			jr .pastdmark  
5439 ..			.dmark: db "LBL"  
543c f1			.pastdmark: pop af  
543d			endm  
# End of macro DMARK
543d						CALLMONITOR 
543d cd f3 18			call break_point_state  
5440				endm  
# End of macro CALLMONITOR
5440					endif 
5440			;	if DEBUG_STORESE 
5440			;		DMARK "LBL" 
5440			;		CALLMONITOR 
5440			;	endif 
5440					FORTH_DSP_VALUEHL 
5440 cd 5e 21			call macro_dsp_valuehl 
5443				endm 
# End of macro FORTH_DSP_VALUEHL
5443					;v5FORTH_DSP_VALUE 
5443					 
5443			;		push hl 
5443					FORTH_DSP_POP 
5443 cd 16 22			call macro_forth_dsp_pop 
5446				endm 
# End of macro FORTH_DSP_POP
5446			;		pop hl 
5446			 
5446			;v5		inc hl   ; move past the type marker 
5446			 
5446				if DEBUG_STORESE 
5446					DMARK "LBl" 
5446 f5				push af  
5447 3a 5b 54			ld a, (.dmark)  
544a 32 6e fe			ld (debug_mark),a  
544d 3a 5c 54			ld a, (.dmark+1)  
5450 32 6f fe			ld (debug_mark+1),a  
5453 3a 5d 54			ld a, (.dmark+2)  
5456 32 70 fe			ld (debug_mark+2),a  
5459 18 03			jr .pastdmark  
545b ..			.dmark: db "LBl"  
545e f1			.pastdmark: pop af  
545f			endm  
# End of macro DMARK
545f					CALLMONITOR 
545f cd f3 18			call break_point_state  
5462				endm  
# End of macro CALLMONITOR
5462				endif 
5462 cd f1 05				call storage_label 
5465			 
5465				       NEXTW 
5465 c3 14 23			jp macro_next 
5468				endm 
# End of macro NEXTW
5468			.STOREPAGE: 
5468				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5468 6d				db WORD_SYS_CORE+89             
5469 9b 54			dw .LABELS            
546b 0a				db 9 + 1 
546c .. 00			db "STOREPAGE",0              
5476				endm 
# End of macro CWHEAD
5476			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5476			; | | Compatible with PicoSPINet  
5476					; TODO test to see if bank is selected 
5476				 
5476					if DEBUG_FORTH_WORDS_KEY 
5476						DMARK "STP" 
5476 f5				push af  
5477 3a 8b 54			ld a, (.dmark)  
547a 32 6e fe			ld (debug_mark),a  
547d 3a 8c 54			ld a, (.dmark+1)  
5480 32 6f fe			ld (debug_mark+1),a  
5483 3a 8d 54			ld a, (.dmark+2)  
5486 32 70 fe			ld (debug_mark+2),a  
5489 18 03			jr .pastdmark  
548b ..			.dmark: db "STP"  
548e f1			.pastdmark: pop af  
548f			endm  
# End of macro DMARK
548f						CALLMONITOR 
548f cd f3 18			call break_point_state  
5492				endm  
# End of macro CALLMONITOR
5492					endif 
5492			;	if DEBUG_STORESE 
5492			;		DMARK "STP" 
5492			;		CALLMONITOR 
5492			;	endif 
5492			 
5492 21 81 fa			ld hl, store_page 
5495 cd 67 1f			call forth_push_numhl 
5498			 
5498			 
5498				       NEXTW 
5498 c3 14 23			jp macro_next 
549b				endm 
# End of macro NEXTW
549b			.LABELS: 
549b				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
549b 6d				db WORD_SYS_CORE+89             
549c 25 55			dw .SCONST1            
549e 07				db 6 + 1 
549f .. 00			db "LABELS",0              
54a6				endm 
# End of macro CWHEAD
54a6			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
54a6			; | | *NOT* Compatible with PicoSPINet  
54a6					;  
54a6			 
54a6					; save the current device selected to restore afterwards 
54a6				 
54a6 3a 67 fa				ld a, (spi_device) 
54a9 f5					push af 
54aa			 
54aa			 
54aa					; run through each of the banks 
54aa			 
54aa 21 01 00				ld hl, 1 
54ad cd 67 1f				call forth_push_numhl 
54b0 3e ff				ld a, SPI_CE_HIGH 
54b2 cb 87				res SPI_CE0, a 
54b4 32 67 fa				ld (spi_device), a 
54b7 cd cd 04				call storage_get_block_0 
54ba 21 84 fa				ld hl, store_page+3 
54bd cd d5 1f				call forth_push_str 
54c0			 
54c0					 
54c0 21 02 00				ld hl, 2 
54c3 cd 67 1f				call forth_push_numhl 
54c6 3e ff				ld a, SPI_CE_HIGH 
54c8 cb 8f				res SPI_CE1, a 
54ca 32 67 fa				ld (spi_device), a 
54cd cd cd 04				call storage_get_block_0 
54d0 21 84 fa				ld hl, store_page+3 
54d3 cd d5 1f				call forth_push_str 
54d6			 
54d6					 
54d6 21 03 00				ld hl, 3 
54d9 cd 67 1f				call forth_push_numhl 
54dc 3e ff				ld a, SPI_CE_HIGH 
54de cb 97				res SPI_CE2, a 
54e0 32 67 fa				ld (spi_device), a 
54e3 cd cd 04				call storage_get_block_0 
54e6 21 84 fa				ld hl, store_page+3 
54e9 cd d5 1f				call forth_push_str 
54ec			 
54ec			 
54ec 21 04 00				ld hl, 4 
54ef cd 67 1f				call forth_push_numhl 
54f2 3e ff				ld a, SPI_CE_HIGH 
54f4 cb 9f				res SPI_CE3, a 
54f6 32 67 fa				ld (spi_device), a 
54f9 cd cd 04				call storage_get_block_0 
54fc 21 84 fa				ld hl, store_page+3 
54ff cd d5 1f				call forth_push_str 
5502			 
5502					 
5502			 
5502 21 05 00				ld hl, 5 
5505 cd 67 1f				call forth_push_numhl 
5508 3e ff				ld a, SPI_CE_HIGH 
550a cb a7				res SPI_CE4, a 
550c 32 67 fa				ld (spi_device), a 
550f cd cd 04				call storage_get_block_0 
5512 21 84 fa				ld hl, store_page+3 
5515 cd d5 1f				call forth_push_str 
5518			 
5518					 
5518					; push fixed count of storage devices (on board) for now 
5518			 
5518 21 05 00				ld hl, 5 
551b cd 67 1f				call forth_push_numhl 
551e			 
551e					; restore selected device  
551e				 
551e f1					pop af 
551f 32 67 fa				ld (spi_device), a 
5522			 
5522				       NEXTW 
5522 c3 14 23			jp macro_next 
5525				endm 
# End of macro NEXTW
5525			 
5525			.SCONST1: 
5525				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5525 6d				db WORD_SYS_CORE+89             
5526 3c 55			dw .SCONST2            
5528 07				db 6 + 1 
5529 .. 00			db "FILEID",0              
5530				endm 
# End of macro CWHEAD
5530			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5530			; | | Compatible with PicoSPINet  
5530 3a 6e fa				ld a, (store_filecache) 
5533 26 00				ld h, 0 
5535 6f					ld l, a 
5536 cd 67 1f				call forth_push_numhl 
5539					NEXTW 
5539 c3 14 23			jp macro_next 
553c				endm 
# End of macro NEXTW
553c			.SCONST2: 
553c				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
553c 6d				db WORD_SYS_CORE+89             
553d 54 55			dw .SCONST3            
553f 08				db 7 + 1 
5540 .. 00			db "FILEEXT",0              
5548				endm 
# End of macro CWHEAD
5548			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5548			; | | Compatible with PicoSPINet  
5548 3a 71 fa				ld a, (store_openext) 
554b 26 00				ld h, 0 
554d 6f					ld l, a 
554e cd 67 1f				call forth_push_numhl 
5551					NEXTW 
5551 c3 14 23			jp macro_next 
5554				endm 
# End of macro NEXTW
5554			.SCONST3: 
5554				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5554 6d				db WORD_SYS_CORE+89             
5555 6c 55			dw .SCONST4            
5557 08				db 7 + 1 
5558 .. 00			db "FILEMAX",0              
5560				endm 
# End of macro CWHEAD
5560			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5560			; | | Compatible with PicoSPINet  
5560 3a 70 fa				ld a, (store_openmaxext) 
5563 26 00				ld h, 0 
5565 6f					ld l, a 
5566 cd 67 1f				call forth_push_numhl 
5569					NEXTW 
5569 c3 14 23			jp macro_next 
556c				endm 
# End of macro NEXTW
556c			.SCONST4: 
556c				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
556c 6d				db WORD_SYS_CORE+89             
556d 82 55			dw .SCONST5            
556f 09				db 8 + 1 
5570 .. 00			db "FILEADDR",0              
5579				endm 
# End of macro CWHEAD
5579			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5579			; | | Compatible with PicoSPINet  
5579 2a 72 fa				ld hl, (store_openaddr) 
557c cd 67 1f				call forth_push_numhl 
557f					NEXTW 
557f c3 14 23			jp macro_next 
5582				endm 
# End of macro NEXTW
5582			.SCONST5: 
5582				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5582 6d				db WORD_SYS_CORE+89             
5583 9b 55			dw .ENDSTORAGE            
5585 09				db 8 + 1 
5586 .. 00			db "READCONT",0              
558f				endm 
# End of macro CWHEAD
558f			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
558f			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
558f			; | | a further read should, if applicable, be CONCAT to the previous read. 
558f			; | | Compatible with PicoSPINet  
558f 3a 74 fa				ld a, (store_readcont) 
5592 26 00				ld h, 0 
5594 6f					ld l, a 
5595 cd 67 1f				call forth_push_numhl 
5598					NEXTW 
5598 c3 14 23			jp macro_next 
559b				endm 
# End of macro NEXTW
559b			.ENDSTORAGE: 
559b			; eof 
# End of file forth_words_storage.asm
559b			endif 
559b				include "forth_words_device.asm" 
559b			; Device related words 
559b			 
559b			; | ## Device Words 
559b			 
559b			;if SOUND_ENABLE 
559b			;.NOTE: 
559b			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
559b			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
559b			;		if DEBUG_FORTH_WORDS_KEY 
559b			;			DMARK "NTE" 
559b			;			CALLMONITOR 
559b			;		endif 
559b			; 
559b			;	 
559b			; 
559b			;		NEXTW 
559b			;.AFTERSOUND: 
559b			;endif 
559b			 
559b			 
559b			USE_GPIO: equ 0 
559b			 
559b			if USE_GPIO 
559b			.GP1: 
559b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
559b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
559b					NEXTW 
559b			.GP2: 
559b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
559b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
559b			 
559b					NEXTW 
559b			 
559b			.GP3: 
559b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
559b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
559b			 
559b					NEXTW 
559b			 
559b			.GP4: 
559b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
559b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
559b			 
559b					NEXTW 
559b			.SIN: 
559b			 
559b			 
559b			endif 
559b			 
559b			 
559b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
559b 33				db WORD_SYS_CORE+31             
559c d0 55			dw .SOUT            
559e 03				db 2 + 1 
559f .. 00			db "IN",0              
55a2				endm 
# End of macro CWHEAD
55a2			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
55a2					if DEBUG_FORTH_WORDS_KEY 
55a2						DMARK "IN." 
55a2 f5				push af  
55a3 3a b7 55			ld a, (.dmark)  
55a6 32 6e fe			ld (debug_mark),a  
55a9 3a b8 55			ld a, (.dmark+1)  
55ac 32 6f fe			ld (debug_mark+1),a  
55af 3a b9 55			ld a, (.dmark+2)  
55b2 32 70 fe			ld (debug_mark+2),a  
55b5 18 03			jr .pastdmark  
55b7 ..			.dmark: db "IN."  
55ba f1			.pastdmark: pop af  
55bb			endm  
# End of macro DMARK
55bb						CALLMONITOR 
55bb cd f3 18			call break_point_state  
55be				endm  
# End of macro CALLMONITOR
55be					endif 
55be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55be cd 5e 21			call macro_dsp_valuehl 
55c1				endm 
# End of macro FORTH_DSP_VALUEHL
55c1			 
55c1 e5					push hl 
55c2			 
55c2					; destroy value TOS 
55c2			 
55c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55c2 cd 16 22			call macro_forth_dsp_pop 
55c5				endm 
# End of macro FORTH_DSP_POP
55c5			 
55c5					; one value on hl get other one back 
55c5			 
55c5 c1					pop bc 
55c6			 
55c6					; do the sub 
55c6			;		ex de, hl 
55c6			 
55c6 ed 68				in l,(c) 
55c8			 
55c8					; save it 
55c8			 
55c8 26 00				ld h,0 
55ca			 
55ca					; TODO push value back onto stack for another op etc 
55ca			 
55ca cd 67 1f				call forth_push_numhl 
55cd					NEXTW 
55cd c3 14 23			jp macro_next 
55d0				endm 
# End of macro NEXTW
55d0			.SOUT: 
55d0				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
55d0 34				db WORD_SYS_CORE+32             
55d1 23 56			dw .SPIO            
55d3 04				db 3 + 1 
55d4 .. 00			db "OUT",0              
55d8				endm 
# End of macro CWHEAD
55d8			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
55d8					if DEBUG_FORTH_WORDS_KEY 
55d8						DMARK "OUT" 
55d8 f5				push af  
55d9 3a ed 55			ld a, (.dmark)  
55dc 32 6e fe			ld (debug_mark),a  
55df 3a ee 55			ld a, (.dmark+1)  
55e2 32 6f fe			ld (debug_mark+1),a  
55e5 3a ef 55			ld a, (.dmark+2)  
55e8 32 70 fe			ld (debug_mark+2),a  
55eb 18 03			jr .pastdmark  
55ed ..			.dmark: db "OUT"  
55f0 f1			.pastdmark: pop af  
55f1			endm  
# End of macro DMARK
55f1						CALLMONITOR 
55f1 cd f3 18			call break_point_state  
55f4				endm  
# End of macro CALLMONITOR
55f4					endif 
55f4			 
55f4					; get port 
55f4			 
55f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55f4 cd 5e 21			call macro_dsp_valuehl 
55f7				endm 
# End of macro FORTH_DSP_VALUEHL
55f7			 
55f7 e5					push hl 
55f8			 
55f8					; destroy value TOS 
55f8			 
55f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55f8 cd 16 22			call macro_forth_dsp_pop 
55fb				endm 
# End of macro FORTH_DSP_POP
55fb			 
55fb					; get byte to send 
55fb			 
55fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55fb cd 5e 21			call macro_dsp_valuehl 
55fe				endm 
# End of macro FORTH_DSP_VALUEHL
55fe			 
55fe			;		push hl 
55fe			 
55fe					; destroy value TOS 
55fe			 
55fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55fe cd 16 22			call macro_forth_dsp_pop 
5601				endm 
# End of macro FORTH_DSP_POP
5601			 
5601					; one value on hl get other one back 
5601			 
5601			;		pop hl 
5601			 
5601 c1					pop bc 
5602			 
5602					if DEBUG_FORTH_WORDS 
5602						DMARK "OUT" 
5602 f5				push af  
5603 3a 17 56			ld a, (.dmark)  
5606 32 6e fe			ld (debug_mark),a  
5609 3a 18 56			ld a, (.dmark+1)  
560c 32 6f fe			ld (debug_mark+1),a  
560f 3a 19 56			ld a, (.dmark+2)  
5612 32 70 fe			ld (debug_mark+2),a  
5615 18 03			jr .pastdmark  
5617 ..			.dmark: db "OUT"  
561a f1			.pastdmark: pop af  
561b			endm  
# End of macro DMARK
561b						CALLMONITOR 
561b cd f3 18			call break_point_state  
561e				endm  
# End of macro CALLMONITOR
561e					endif 
561e			 
561e ed 69				out (c), l 
5620			 
5620					NEXTW 
5620 c3 14 23			jp macro_next 
5623				endm 
# End of macro NEXTW
5623			 
5623			 
5623			.SPIO: 
5623			 
5623			if STORAGE_SE 
5623				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5623 51				db WORD_SYS_CORE+61             
5624 34 56			dw .SPICEH            
5626 07				db 6 + 1 
5627 .. 00			db "SPICEL",0              
562e				endm 
# End of macro CWHEAD
562e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
562e			 
562e cd ca 01				call spi_ce_low 
5631			    NEXTW 
5631 c3 14 23			jp macro_next 
5634				endm 
# End of macro NEXTW
5634			 
5634			.SPICEH: 
5634				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5634 51				db WORD_SYS_CORE+61             
5635 45 56			dw .SPIOb            
5637 07				db 6 + 1 
5638 .. 00			db "SPICEH",0              
563f				endm 
# End of macro CWHEAD
563f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
563f			 
563f cd b9 01				call spi_ce_high 
5642			    NEXTW 
5642 c3 14 23			jp macro_next 
5645				endm 
# End of macro NEXTW
5645			 
5645			 
5645			.SPIOb: 
5645			 
5645				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5645 51				db WORD_SYS_CORE+61             
5646 77 56			dw .SPII            
5648 05				db 4 + 1 
5649 .. 00			db "SPIO",0              
564e				endm 
# End of macro CWHEAD
564e			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
564e			 
564e					if DEBUG_FORTH_WORDS_KEY 
564e						DMARK "SPo" 
564e f5				push af  
564f 3a 63 56			ld a, (.dmark)  
5652 32 6e fe			ld (debug_mark),a  
5655 3a 64 56			ld a, (.dmark+1)  
5658 32 6f fe			ld (debug_mark+1),a  
565b 3a 65 56			ld a, (.dmark+2)  
565e 32 70 fe			ld (debug_mark+2),a  
5661 18 03			jr .pastdmark  
5663 ..			.dmark: db "SPo"  
5666 f1			.pastdmark: pop af  
5667			endm  
# End of macro DMARK
5667						CALLMONITOR 
5667 cd f3 18			call break_point_state  
566a				endm  
# End of macro CALLMONITOR
566a					endif 
566a					; get port 
566a			 
566a			 
566a					; get byte to send 
566a			 
566a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
566a cd 5e 21			call macro_dsp_valuehl 
566d				endm 
# End of macro FORTH_DSP_VALUEHL
566d			 
566d			;		push hl    ; u1  
566d			 
566d					; destroy value TOS 
566d			 
566d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
566d cd 16 22			call macro_forth_dsp_pop 
5670				endm 
# End of macro FORTH_DSP_POP
5670			 
5670					; one value on hl get other one back 
5670			 
5670			;		pop hl   ; u2 - addr 
5670			 
5670					; TODO Send SPI byte 
5670			 
5670			;		push hl 
5670			;		call spi_ce_low 
5670			;		pop hl 
5670 7d					ld a, l 
5671 cd b8 00				call spi_send_byte 
5674			;		call spi_ce_high 
5674			 
5674					NEXTW 
5674 c3 14 23			jp macro_next 
5677				endm 
# End of macro NEXTW
5677			 
5677			.SPII: 
5677				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5677 52				db WORD_SYS_CORE+62             
5678 e0 56			dw .SESEL            
567a 06				db 5 + 1 
567b .. 00			db "SPII",0              
5680				endm 
# End of macro CWHEAD
5680			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5680					if DEBUG_FORTH_WORDS_KEY 
5680						DMARK "SPi" 
5680 f5				push af  
5681 3a 95 56			ld a, (.dmark)  
5684 32 6e fe			ld (debug_mark),a  
5687 3a 96 56			ld a, (.dmark+1)  
568a 32 6f fe			ld (debug_mark+1),a  
568d 3a 97 56			ld a, (.dmark+2)  
5690 32 70 fe			ld (debug_mark+2),a  
5693 18 03			jr .pastdmark  
5695 ..			.dmark: db "SPi"  
5698 f1			.pastdmark: pop af  
5699			endm  
# End of macro DMARK
5699						CALLMONITOR 
5699 cd f3 18			call break_point_state  
569c				endm  
# End of macro CALLMONITOR
569c					endif 
569c			 
569c					; TODO Get SPI byte 
569c			 
569c cd df 00				call spi_read_byte 
569f			 
569f					if DEBUG_FORTH_WORDS 
569f						DMARK "Si2" 
569f f5				push af  
56a0 3a b4 56			ld a, (.dmark)  
56a3 32 6e fe			ld (debug_mark),a  
56a6 3a b5 56			ld a, (.dmark+1)  
56a9 32 6f fe			ld (debug_mark+1),a  
56ac 3a b6 56			ld a, (.dmark+2)  
56af 32 70 fe			ld (debug_mark+2),a  
56b2 18 03			jr .pastdmark  
56b4 ..			.dmark: db "Si2"  
56b7 f1			.pastdmark: pop af  
56b8			endm  
# End of macro DMARK
56b8						CALLMONITOR 
56b8 cd f3 18			call break_point_state  
56bb				endm  
# End of macro CALLMONITOR
56bb					endif 
56bb 26 00				ld h, 0 
56bd 6f					ld l, a 
56be					if DEBUG_FORTH_WORDS 
56be						DMARK "Si3" 
56be f5				push af  
56bf 3a d3 56			ld a, (.dmark)  
56c2 32 6e fe			ld (debug_mark),a  
56c5 3a d4 56			ld a, (.dmark+1)  
56c8 32 6f fe			ld (debug_mark+1),a  
56cb 3a d5 56			ld a, (.dmark+2)  
56ce 32 70 fe			ld (debug_mark+2),a  
56d1 18 03			jr .pastdmark  
56d3 ..			.dmark: db "Si3"  
56d6 f1			.pastdmark: pop af  
56d7			endm  
# End of macro DMARK
56d7						CALLMONITOR 
56d7 cd f3 18			call break_point_state  
56da				endm  
# End of macro CALLMONITOR
56da					endif 
56da cd 67 1f				call forth_push_numhl 
56dd			 
56dd					NEXTW 
56dd c3 14 23			jp macro_next 
56e0				endm 
# End of macro NEXTW
56e0			 
56e0			 
56e0			 
56e0			.SESEL: 
56e0				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
56e0 66				db WORD_SYS_CORE+82             
56e1 89 57			dw .CARTDEV            
56e3 05				db 4 + 1 
56e4 .. 00			db "BANK",0              
56e9				endm 
# End of macro CWHEAD
56e9			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
56e9					if DEBUG_FORTH_WORDS_KEY 
56e9						DMARK "BNK" 
56e9 f5				push af  
56ea 3a fe 56			ld a, (.dmark)  
56ed 32 6e fe			ld (debug_mark),a  
56f0 3a ff 56			ld a, (.dmark+1)  
56f3 32 6f fe			ld (debug_mark+1),a  
56f6 3a 00 57			ld a, (.dmark+2)  
56f9 32 70 fe			ld (debug_mark+2),a  
56fc 18 03			jr .pastdmark  
56fe ..			.dmark: db "BNK"  
5701 f1			.pastdmark: pop af  
5702			endm  
# End of macro DMARK
5702						CALLMONITOR 
5702 cd f3 18			call break_point_state  
5705				endm  
# End of macro CALLMONITOR
5705					endif 
5705			 
5705 3e ff				ld a, 255 
5707 32 6a fa				ld (spi_cartdev), a 
570a			 
570a					; get bank 
570a			 
570a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
570a cd 5e 21			call macro_dsp_valuehl 
570d				endm 
# End of macro FORTH_DSP_VALUEHL
570d			 
570d			;		push hl 
570d			 
570d					; destroy value TOS 
570d			 
570d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
570d cd 16 22			call macro_forth_dsp_pop 
5710				endm 
# End of macro FORTH_DSP_POP
5710			 
5710					; one value on hl get other one back 
5710			 
5710			;		pop hl 
5710			 
5710			 
5710 0e ff				ld c, SPI_CE_HIGH 
5712 06 30				ld b, '0'    ; human readable bank number 
5714			 
5714 7d					ld a, l 
5715			 
5715					if DEBUG_FORTH_WORDS 
5715						DMARK "BNK" 
5715 f5				push af  
5716 3a 2a 57			ld a, (.dmark)  
5719 32 6e fe			ld (debug_mark),a  
571c 3a 2b 57			ld a, (.dmark+1)  
571f 32 6f fe			ld (debug_mark+1),a  
5722 3a 2c 57			ld a, (.dmark+2)  
5725 32 70 fe			ld (debug_mark+2),a  
5728 18 03			jr .pastdmark  
572a ..			.dmark: db "BNK"  
572d f1			.pastdmark: pop af  
572e			endm  
# End of macro DMARK
572e						CALLMONITOR 
572e cd f3 18			call break_point_state  
5731				endm  
# End of macro CALLMONITOR
5731					endif 
5731			 
5731					; active low 
5731			 
5731 fe 00				cp 0 
5733 28 28				jr z, .bset 
5735 fe 01				cp 1 
5737 20 04				jr nz, .b2 
5739 cb 81				res 0, c 
573b 06 31				ld b, '1'    ; human readable bank number 
573d fe 02		.b2:		cp 2 
573f 20 04				jr nz, .b3 
5741 cb 89				res 1, c 
5743 06 32				ld b, '2'    ; human readable bank number 
5745 fe 03		.b3:		cp 3 
5747 20 04				jr nz, .b4 
5749 cb 91				res 2, c 
574b 06 33				ld b, '3'    ; human readable bank number 
574d fe 04		.b4:		cp 4 
574f 20 04				jr nz, .b5 
5751 cb 99				res 3, c 
5753 06 34				ld b, '4'    ; human readable bank number 
5755 fe 05		.b5:		cp 5 
5757 20 04				jr nz, .bset 
5759 cb a1				res 4, c 
575b 06 35				ld b, '5'    ; human readable bank number 
575d			 
575d			.bset: 
575d 79					ld a, c 
575e 32 67 fa				ld (spi_device),a 
5761 78					ld a, b 
5762 32 66 fa				ld (spi_device_id),a 
5765					if DEBUG_FORTH_WORDS 
5765						DMARK "BN2" 
5765 f5				push af  
5766 3a 7a 57			ld a, (.dmark)  
5769 32 6e fe			ld (debug_mark),a  
576c 3a 7b 57			ld a, (.dmark+1)  
576f 32 6f fe			ld (debug_mark+1),a  
5772 3a 7c 57			ld a, (.dmark+2)  
5775 32 70 fe			ld (debug_mark+2),a  
5778 18 03			jr .pastdmark  
577a ..			.dmark: db "BN2"  
577d f1			.pastdmark: pop af  
577e			endm  
# End of macro DMARK
577e						CALLMONITOR 
577e cd f3 18			call break_point_state  
5781				endm  
# End of macro CALLMONITOR
5781					endif 
5781			 
5781					; set default SPI clk pulse time as disabled for BANK use 
5781			 
5781 3e 00				ld a, 0 
5783 32 6b fa				ld (spi_clktime), a 
5786			 
5786					NEXTW 
5786 c3 14 23			jp macro_next 
5789				endm 
# End of macro NEXTW
5789			 
5789			.CARTDEV: 
5789				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5789 66				db WORD_SYS_CORE+82             
578a 37 58			dw .ENDDEVICE            
578c 08				db 7 + 1 
578d .. 00			db "CARTDEV",0              
5795				endm 
# End of macro CWHEAD
5795			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5795					if DEBUG_FORTH_WORDS_KEY 
5795						DMARK "CDV" 
5795 f5				push af  
5796 3a aa 57			ld a, (.dmark)  
5799 32 6e fe			ld (debug_mark),a  
579c 3a ab 57			ld a, (.dmark+1)  
579f 32 6f fe			ld (debug_mark+1),a  
57a2 3a ac 57			ld a, (.dmark+2)  
57a5 32 70 fe			ld (debug_mark+2),a  
57a8 18 03			jr .pastdmark  
57aa ..			.dmark: db "CDV"  
57ad f1			.pastdmark: pop af  
57ae			endm  
# End of macro DMARK
57ae						CALLMONITOR 
57ae cd f3 18			call break_point_state  
57b1				endm  
# End of macro CALLMONITOR
57b1					endif 
57b1			 
57b1					; disable se storage bank selection 
57b1			 
57b1 3e ff				ld a, SPI_CE_HIGH		; ce high 
57b3 32 67 fa				ld (spi_device), a 
57b6			 
57b6					; get bank 
57b6			 
57b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57b6 cd 5e 21			call macro_dsp_valuehl 
57b9				endm 
# End of macro FORTH_DSP_VALUEHL
57b9			 
57b9			;		push hl 
57b9			 
57b9					; destroy value TOS 
57b9			 
57b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57b9 cd 16 22			call macro_forth_dsp_pop 
57bc				endm 
# End of macro FORTH_DSP_POP
57bc			 
57bc					; one value on hl get other one back 
57bc			 
57bc			;		pop hl 
57bc			 
57bc					; active low 
57bc			 
57bc 0e ff				ld c, 255 
57be			 
57be 7d					ld a, l 
57bf					if DEBUG_FORTH_WORDS 
57bf						DMARK "CDV" 
57bf f5				push af  
57c0 3a d4 57			ld a, (.dmark)  
57c3 32 6e fe			ld (debug_mark),a  
57c6 3a d5 57			ld a, (.dmark+1)  
57c9 32 6f fe			ld (debug_mark+1),a  
57cc 3a d6 57			ld a, (.dmark+2)  
57cf 32 70 fe			ld (debug_mark+2),a  
57d2 18 03			jr .pastdmark  
57d4 ..			.dmark: db "CDV"  
57d7 f1			.pastdmark: pop af  
57d8			endm  
# End of macro DMARK
57d8						CALLMONITOR 
57d8 cd f3 18			call break_point_state  
57db				endm  
# End of macro CALLMONITOR
57db					endif 
57db fe 00				cp 0 
57dd 28 30				jr z, .cset 
57df fe 01				cp 1 
57e1 20 02				jr nz, .c2 
57e3 cb 81				res 0, c 
57e5 fe 02		.c2:		cp 2 
57e7 20 02				jr nz, .c3 
57e9 cb 89				res 1, c 
57eb fe 03		.c3:		cp 3 
57ed 20 02				jr nz, .c4 
57ef cb 91				res 2, c 
57f1 fe 04		.c4:		cp 4 
57f3 20 02				jr nz, .c5 
57f5 cb 99				res 3, c 
57f7 fe 05		.c5:		cp 5 
57f9 20 02				jr nz, .c6 
57fb cb a1				res 4, c 
57fd fe 06		.c6:		cp 6 
57ff 20 02				jr nz, .c7 
5801 cb a9				res 5, c 
5803 fe 07		.c7:		cp 7 
5805 20 02				jr nz, .c8 
5807 cb b1				res 6, c 
5809 fe 08		.c8:		cp 8 
580b 20 02				jr nz, .cset 
580d cb b9				res 7, c 
580f 79			.cset:		ld a, c 
5810 32 6a fa				ld (spi_cartdev),a 
5813			 
5813					if DEBUG_FORTH_WORDS 
5813						DMARK "CD2" 
5813 f5				push af  
5814 3a 28 58			ld a, (.dmark)  
5817 32 6e fe			ld (debug_mark),a  
581a 3a 29 58			ld a, (.dmark+1)  
581d 32 6f fe			ld (debug_mark+1),a  
5820 3a 2a 58			ld a, (.dmark+2)  
5823 32 70 fe			ld (debug_mark+2),a  
5826 18 03			jr .pastdmark  
5828 ..			.dmark: db "CD2"  
582b f1			.pastdmark: pop af  
582c			endm  
# End of macro DMARK
582c						CALLMONITOR 
582c cd f3 18			call break_point_state  
582f				endm  
# End of macro CALLMONITOR
582f					endif 
582f			 
582f					; set default SPI clk pulse time as 10ms for CARTDEV use 
582f			 
582f 3e 0a				ld a, $0a 
5831 32 6b fa				ld (spi_clktime), a 
5834					NEXTW 
5834 c3 14 23			jp macro_next 
5837				endm 
# End of macro NEXTW
5837			endif 
5837			 
5837			.ENDDEVICE: 
5837			; eof 
5837			 
# End of file forth_words_device.asm
5837			 
5837			; var handler 
5837			 
5837			 
5837			.VARS: 
5837				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5837 77				db WORD_SYS_CORE+99             
5838 e8 58			dw .V0            
583a 04				db 3 + 1 
583b .. 00			db "VAR",0              
583f				endm 
# End of macro CWHEAD
583f			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
583f			;| 
583f			;| The variable name should consist of a single letter. e.g. "a" 
583f			;! If a full string is passed then only the first char is looked at 
583f			;| Any other char could exceed bounds checks!  
583f			 
583f					if DEBUG_FORTH_WORDS_KEY 
583f						DMARK "VAR" 
583f f5				push af  
5840 3a 54 58			ld a, (.dmark)  
5843 32 6e fe			ld (debug_mark),a  
5846 3a 55 58			ld a, (.dmark+1)  
5849 32 6f fe			ld (debug_mark+1),a  
584c 3a 56 58			ld a, (.dmark+2)  
584f 32 70 fe			ld (debug_mark+2),a  
5852 18 03			jr .pastdmark  
5854 ..			.dmark: db "VAR"  
5857 f1			.pastdmark: pop af  
5858			endm  
# End of macro DMARK
5858						CALLMONITOR 
5858 cd f3 18			call break_point_state  
585b				endm  
# End of macro CALLMONITOR
585b					endif 
585b			 
585b					FORTH_DSP_VALUEHL 
585b cd 5e 21			call macro_dsp_valuehl 
585e				endm 
# End of macro FORTH_DSP_VALUEHL
585e			 
585e 7e					ld a, (hl)    ; get first char on of the string 
585f			 
585f			 
585f					if DEBUG_FORTH_WORDS 
585f						DMARK "VR1" 
585f f5				push af  
5860 3a 74 58			ld a, (.dmark)  
5863 32 6e fe			ld (debug_mark),a  
5866 3a 75 58			ld a, (.dmark+1)  
5869 32 6f fe			ld (debug_mark+1),a  
586c 3a 76 58			ld a, (.dmark+2)  
586f 32 70 fe			ld (debug_mark+2),a  
5872 18 03			jr .pastdmark  
5874 ..			.dmark: db "VR1"  
5877 f1			.pastdmark: pop af  
5878			endm  
# End of macro DMARK
5878						CALLMONITOR 
5878 cd f3 18			call break_point_state  
587b				endm  
# End of macro CALLMONITOR
587b					endif 
587b					 
587b f5					push af	 
587c					FORTH_DSP_POP 
587c cd 16 22			call macro_forth_dsp_pop 
587f				endm 
# End of macro FORTH_DSP_POP
587f f1					pop af 
5880			 
5880					; convert to upper 
5880			 
5880 cd b9 12				call to_upper 
5883					if DEBUG_FORTH_WORDS 
5883						DMARK "Vaa" 
5883 f5				push af  
5884 3a 98 58			ld a, (.dmark)  
5887 32 6e fe			ld (debug_mark),a  
588a 3a 99 58			ld a, (.dmark+1)  
588d 32 6f fe			ld (debug_mark+1),a  
5890 3a 9a 58			ld a, (.dmark+2)  
5893 32 70 fe			ld (debug_mark+2),a  
5896 18 03			jr .pastdmark  
5898 ..			.dmark: db "Vaa"  
589b f1			.pastdmark: pop af  
589c			endm  
# End of macro DMARK
589c						CALLMONITOR 
589c cd f3 18			call break_point_state  
589f				endm  
# End of macro CALLMONITOR
589f					endif 
589f 06 41				ld b, 'A' 
58a1 90					sub b			; set offset 
58a2					if DEBUG_FORTH_WORDS 
58a2						DMARK "Vbb" 
58a2 f5				push af  
58a3 3a b7 58			ld a, (.dmark)  
58a6 32 6e fe			ld (debug_mark),a  
58a9 3a b8 58			ld a, (.dmark+1)  
58ac 32 6f fe			ld (debug_mark+1),a  
58af 3a b9 58			ld a, (.dmark+2)  
58b2 32 70 fe			ld (debug_mark+2),a  
58b5 18 03			jr .pastdmark  
58b7 ..			.dmark: db "Vbb"  
58ba f1			.pastdmark: pop af  
58bb			endm  
# End of macro DMARK
58bb						CALLMONITOR 
58bb cd f3 18			call break_point_state  
58be				endm  
# End of macro CALLMONITOR
58be					endif 
58be cb 27				sla a  
58c0				 
58c0					 
58c0					if DEBUG_FORTH_WORDS 
58c0						DMARK "VR2" 
58c0 f5				push af  
58c1 3a d5 58			ld a, (.dmark)  
58c4 32 6e fe			ld (debug_mark),a  
58c7 3a d6 58			ld a, (.dmark+1)  
58ca 32 6f fe			ld (debug_mark+1),a  
58cd 3a d7 58			ld a, (.dmark+2)  
58d0 32 70 fe			ld (debug_mark+2),a  
58d3 18 03			jr .pastdmark  
58d5 ..			.dmark: db "VR2"  
58d8 f1			.pastdmark: pop af  
58d9			endm  
# End of macro DMARK
58d9						CALLMONITOR 
58d9 cd f3 18			call break_point_state  
58dc				endm  
# End of macro CALLMONITOR
58dc					endif 
58dc			 
58dc 21 fb f9				ld hl, cli_var_array2 
58df cd 4c 0f				call addatohl 
58e2 cd 67 1f				call forth_push_numhl 
58e5			 
58e5			 
58e5				       NEXTW 
58e5 c3 14 23			jp macro_next 
58e8				endm 
# End of macro NEXTW
58e8			.V0: 
58e8				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
58e8 78				db WORD_SYS_CORE+100             
58e9 00 59			dw .V0Q            
58eb 04				db 3 + 1 
58ec .. 00			db "V0!",0              
58f0				endm 
# End of macro CWHEAD
58f0			;| V0! ( u1 -- )  Store value to v0  | DONE 
58f0			 
58f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58f0 cd 5e 21			call macro_dsp_valuehl 
58f3				endm 
# End of macro FORTH_DSP_VALUEHL
58f3			 
58f3 11 2f fa				ld de, cli_var_array 
58f6			 
58f6 eb					ex de, hl 
58f7 73					ld (hl), e 
58f8 23					inc hl 
58f9 72					ld (hl), d 
58fa			 
58fa					; destroy value TOS 
58fa			 
58fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58fa cd 16 22			call macro_forth_dsp_pop 
58fd				endm 
# End of macro FORTH_DSP_POP
58fd			 
58fd				       NEXTW 
58fd c3 14 23			jp macro_next 
5900				endm 
# End of macro NEXTW
5900			.V0Q: 
5900				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5900 79				db WORD_SYS_CORE+101             
5901 11 59			dw .V1S            
5903 04				db 3 + 1 
5904 .. 00			db "V0@",0              
5908				endm 
# End of macro CWHEAD
5908			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5908 2a 2f fa				ld hl, (cli_var_array) 
590b cd 67 1f				call forth_push_numhl 
590e			 
590e				       NEXTW 
590e c3 14 23			jp macro_next 
5911				endm 
# End of macro NEXTW
5911			.V1S: 
5911				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5911 7a				db WORD_SYS_CORE+102             
5912 29 59			dw .V1Q            
5914 04				db 3 + 1 
5915 .. 00			db "V1!",0              
5919				endm 
# End of macro CWHEAD
5919			;| V1! ( u1 -- )  Store value to v1 | DONE 
5919					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5919 cd 5e 21			call macro_dsp_valuehl 
591c				endm 
# End of macro FORTH_DSP_VALUEHL
591c			 
591c 11 31 fa				ld de, cli_var_array+2 
591f				 
591f eb					ex de, hl 
5920 73					ld (hl), e 
5921 23					inc hl 
5922 72					ld (hl), d 
5923			 
5923					; destroy value TOS 
5923			 
5923					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5923 cd 16 22			call macro_forth_dsp_pop 
5926				endm 
# End of macro FORTH_DSP_POP
5926				       NEXTW 
5926 c3 14 23			jp macro_next 
5929				endm 
# End of macro NEXTW
5929			.V1Q: 
5929				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5929 7b				db WORD_SYS_CORE+103             
592a 3a 59			dw .V2S            
592c 04				db 3 + 1 
592d .. 00			db "V1@",0              
5931				endm 
# End of macro CWHEAD
5931			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5931 2a 31 fa				ld hl, (cli_var_array+2) 
5934 cd 67 1f				call forth_push_numhl 
5937				       NEXTW 
5937 c3 14 23			jp macro_next 
593a				endm 
# End of macro NEXTW
593a			.V2S: 
593a				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
593a 7c				db WORD_SYS_CORE+104             
593b 52 59			dw .V2Q            
593d 04				db 3 + 1 
593e .. 00			db "V2!",0              
5942				endm 
# End of macro CWHEAD
5942			;| V2! ( u1 -- )  Store value to v2 | DONE 
5942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5942 cd 5e 21			call macro_dsp_valuehl 
5945				endm 
# End of macro FORTH_DSP_VALUEHL
5945			 
5945 11 33 fa				ld de, cli_var_array+4 
5948				 
5948 eb					ex de, hl 
5949 73					ld (hl), e 
594a 23					inc hl 
594b 72					ld (hl), d 
594c			 
594c					; destroy value TOS 
594c			 
594c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
594c cd 16 22			call macro_forth_dsp_pop 
594f				endm 
# End of macro FORTH_DSP_POP
594f				       NEXTW 
594f c3 14 23			jp macro_next 
5952				endm 
# End of macro NEXTW
5952			.V2Q: 
5952				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5952 7d				db WORD_SYS_CORE+105             
5953 63 59			dw .V3S            
5955 04				db 3 + 1 
5956 .. 00			db "V2@",0              
595a				endm 
# End of macro CWHEAD
595a			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
595a 2a 33 fa				ld hl, (cli_var_array+4) 
595d cd 67 1f				call forth_push_numhl 
5960				       NEXTW 
5960 c3 14 23			jp macro_next 
5963				endm 
# End of macro NEXTW
5963			.V3S: 
5963				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5963 7c				db WORD_SYS_CORE+104             
5964 7b 59			dw .V3Q            
5966 04				db 3 + 1 
5967 .. 00			db "V3!",0              
596b				endm 
# End of macro CWHEAD
596b			;| V3! ( u1 -- )  Store value to v3 | DONE 
596b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
596b cd 5e 21			call macro_dsp_valuehl 
596e				endm 
# End of macro FORTH_DSP_VALUEHL
596e			 
596e 11 35 fa				ld de, cli_var_array+6 
5971				 
5971 eb					ex de, hl 
5972 73					ld (hl), e 
5973 23					inc hl 
5974 72					ld (hl), d 
5975			 
5975					; destroy value TOS 
5975			 
5975					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5975 cd 16 22			call macro_forth_dsp_pop 
5978				endm 
# End of macro FORTH_DSP_POP
5978				       NEXTW 
5978 c3 14 23			jp macro_next 
597b				endm 
# End of macro NEXTW
597b			.V3Q: 
597b				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
597b 7d				db WORD_SYS_CORE+105             
597c 8c 59			dw .END            
597e 04				db 3 + 1 
597f .. 00			db "V3@",0              
5983				endm 
# End of macro CWHEAD
5983			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5983 2a 35 fa				ld hl, (cli_var_array+6) 
5986 cd 67 1f				call forth_push_numhl 
5989				       NEXTW 
5989 c3 14 23			jp macro_next 
598c				endm 
# End of macro NEXTW
598c			 
598c			 
598c			 
598c			 
598c			 
598c			; end of dict marker 
598c			 
598c 00			.END:    db WORD_SYS_END 
598d 00 00			dw 0 
598f 00				db 0 
5990			 
5990			; use to jp here for user dict words to save on macro expansion  
5990			 
5990			user_dict_next: 
5990				NEXTW 
5990 c3 14 23			jp macro_next 
5993				endm 
# End of macro NEXTW
5993			 
5993			 
5993			user_exec: 
5993				;    ld hl, <word code> 
5993				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5993				;    call forthexec 
5993				;    jp user_dict_next   (NEXT) 
5993			        ;    <word code bytes> 
5993 eb				ex de, hl 
5994 2a c9 f4			ld hl,(os_tok_ptr) 
5997				 
5997				FORTH_RSP_NEXT 
5997 cd 0e 1f			call macro_forth_rsp_next 
599a				endm 
# End of macro FORTH_RSP_NEXT
599a			 
599a			if DEBUG_FORTH_UWORD 
599a						DMARK "UEX" 
599a f5				push af  
599b 3a af 59			ld a, (.dmark)  
599e 32 6e fe			ld (debug_mark),a  
59a1 3a b0 59			ld a, (.dmark+1)  
59a4 32 6f fe			ld (debug_mark+1),a  
59a7 3a b1 59			ld a, (.dmark+2)  
59aa 32 70 fe			ld (debug_mark+2),a  
59ad 18 03			jr .pastdmark  
59af ..			.dmark: db "UEX"  
59b2 f1			.pastdmark: pop af  
59b3			endm  
# End of macro DMARK
59b3				CALLMONITOR 
59b3 cd f3 18			call break_point_state  
59b6				endm  
# End of macro CALLMONITOR
59b6			endif 
59b6			 
59b6			 
59b6			 
59b6 eb				ex de, hl 
59b7 22 c9 f4			ld (os_tok_ptr), hl 
59ba				 
59ba				; Don't use next - Skips the first word in uword. 
59ba			 
59ba c3 a5 23			jp exec1 
59bd			;	NEXT 
59bd			 
59bd			 
59bd			; eof 
# End of file forth_wordsv4.asm
59bd			endif 
59bd			;;;;;;;;;;;;;; Debug code 
59bd			 
59bd			 
59bd			;if DEBUG_FORTH_PARSE 
59bd .. 00		.nowordfound: db "No match",0 
59c6 .. 00		.compword:	db "Comparing word ",0 
59d6 .. 00		.nextwordat:	db "Next word at",0 
59e3 .. 00		.charmatch:	db "Char match",0 
59ee			;endif 
59ee			if DEBUG_FORTH_JP 
59ee			.foundword:	db "Word match. Exec..",0 
59ee			endif 
59ee			;if DEBUG_FORTH_PUSH 
59ee .. 00		.enddict:	db "Dict end. Push.",0 
59fe .. 00		.push_str:	db "Pushing string",0 
5a0d .. 00		.push_num:	db "Pushing number",0 
5a1c .. 00		.data_sp:	db "SP:",0 
5a20 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5a32 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5a44 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5a56			;endif 
5a56			;if DEBUG_FORTH_MALLOC 
5a56 .. 00		.push_malloc:	db "Malloc address",0 
5a65			;endif 
5a65			 
5a65			 
5a65			 
5a65			; display malloc address and current data stack pointer  
5a65			 
5a65			malloc_error: 
5a65 d5				push de 
5a66 f5				push af 
5a67 e5				push hl 
5a68 cd 18 0d			call clear_display 
5a6b 11 8d 5a			ld de, .mallocerr 
5a6e 3e 00			ld a,0 
5a70			;	ld de,os_word_scratch 
5a70 cd 2b 0d			call str_at_display 
5a73 3e 11			ld a, display_row_1+17 
5a75 11 6e fe			ld de, debug_mark 
5a78 cd 2b 0d			call str_at_display 
5a7b cd 3b 0d			call update_display 
5a7e				;call break_point_state 
5a7e cd f9 74			call cin_wait 
5a81			 
5a81 3e 20			ld a, ' ' 
5a83 32 b9 f1			ld (os_view_disable), a 
5a86 e1				pop hl 
5a87 f1				pop af 
5a88 d1				pop de	 
5a89				CALLMONITOR 
5a89 cd f3 18			call break_point_state  
5a8c				endm  
# End of macro CALLMONITOR
5a8c c9				ret 
5a8d			 
5a8d .. 00		.mallocerr: 	db "Malloc Error",0 
5a9a			;if DEBUG_FORTH_PUSH 
5a9a			display_data_sp: 
5a9a f5				push af 
5a9b			 
5a9b				; see if disabled 
5a9b			 
5a9b 3a b9 f1			ld a, (os_view_disable) 
5a9e fe 2a			cp '*' 
5aa0 28 67			jr z, .skipdsp 
5aa2			 
5aa2 e5				push hl 
5aa3 e5				push hl 
5aa4 e5			push hl 
5aa5 cd 18 0d			call clear_display 
5aa8 e1			pop hl 
5aa9 7c				ld a,h 
5aaa 21 cd f4			ld hl, os_word_scratch 
5aad cd 4d 12			call hexout 
5ab0 e1				pop hl 
5ab1 7d				ld a,l 
5ab2 21 cf f4			ld hl, os_word_scratch+2 
5ab5 cd 4d 12			call hexout 
5ab8 21 d1 f4			ld hl, os_word_scratch+4 
5abb 3e 00			ld a,0 
5abd 77				ld (hl),a 
5abe 11 cd f4			ld de,os_word_scratch 
5ac1 3e 28				ld a, display_row_2 
5ac3 cd 2b 0d				call str_at_display 
5ac6 11 20 5a			ld de, .wordinhl 
5ac9 3e 00			ld a, display_row_1 
5acb			 
5acb cd 2b 0d				call str_at_display 
5ace 11 6e fe			ld de, debug_mark 
5ad1 3e 11			ld a, display_row_1+17 
5ad3			 
5ad3 cd 2b 0d				call str_at_display 
5ad6			 
5ad6				; display current data stack pointer 
5ad6 11 1c 5a			ld de,.data_sp 
5ad9 3e 30				ld a, display_row_2 + 8 
5adb cd 2b 0d				call str_at_display 
5ade			 
5ade 2a f5 f9			ld hl,(cli_data_sp) 
5ae1 e5				push hl 
5ae2 7c				ld a,h 
5ae3 21 cd f4			ld hl, os_word_scratch 
5ae6 cd 4d 12			call hexout 
5ae9 e1				pop hl 
5aea 7d				ld a,l 
5aeb 21 cf f4			ld hl, os_word_scratch+2 
5aee cd 4d 12			call hexout 
5af1 21 d1 f4			ld hl, os_word_scratch+4 
5af4 3e 00			ld a,0 
5af6 77				ld (hl),a 
5af7 11 cd f4			ld de,os_word_scratch 
5afa 3e 33				ld a, display_row_2 + 11 
5afc cd 2b 0d				call str_at_display 
5aff			 
5aff			 
5aff cd 3b 0d			call update_display 
5b02 cd 95 0c			call delay1s 
5b05 cd 95 0c			call delay1s 
5b08 e1				pop hl 
5b09			.skipdsp: 
5b09 f1				pop af 
5b0a c9				ret 
5b0b			 
5b0b			display_data_malloc: 
5b0b			 
5b0b f5				push af 
5b0c e5				push hl 
5b0d e5				push hl 
5b0e e5			push hl 
5b0f cd 18 0d			call clear_display 
5b12 e1			pop hl 
5b13 7c				ld a,h 
5b14 21 cd f4			ld hl, os_word_scratch 
5b17 cd 4d 12			call hexout 
5b1a e1				pop hl 
5b1b 7d				ld a,l 
5b1c 21 cf f4			ld hl, os_word_scratch+2 
5b1f cd 4d 12			call hexout 
5b22 21 d1 f4			ld hl, os_word_scratch+4 
5b25 3e 00			ld a,0 
5b27 77				ld (hl),a 
5b28 11 cd f4			ld de,os_word_scratch 
5b2b 3e 28				ld a, display_row_2 
5b2d cd 2b 0d				call str_at_display 
5b30 11 56 5a			ld de, .push_malloc 
5b33 3e 00			ld a, display_row_1 
5b35			 
5b35 cd 2b 0d				call str_at_display 
5b38			 
5b38				; display current data stack pointer 
5b38 11 1c 5a			ld de,.data_sp 
5b3b 3e 30				ld a, display_row_2 + 8 
5b3d cd 2b 0d				call str_at_display 
5b40			 
5b40 2a f5 f9			ld hl,(cli_data_sp) 
5b43 e5				push hl 
5b44 7c				ld a,h 
5b45 21 cd f4			ld hl, os_word_scratch 
5b48 cd 4d 12			call hexout 
5b4b e1				pop hl 
5b4c 7d				ld a,l 
5b4d 21 cf f4			ld hl, os_word_scratch+2 
5b50 cd 4d 12			call hexout 
5b53 21 d1 f4			ld hl, os_word_scratch+4 
5b56 3e 00			ld a,0 
5b58 77				ld (hl),a 
5b59 11 cd f4			ld de,os_word_scratch 
5b5c 3e 33				ld a, display_row_2 + 11 
5b5e cd 2b 0d				call str_at_display 
5b61			 
5b61 cd 3b 0d			call update_display 
5b64 cd 95 0c			call delay1s 
5b67 cd 95 0c			call delay1s 
5b6a e1				pop hl 
5b6b f1				pop af 
5b6c c9				ret 
5b6d			;endif 
5b6d			 
5b6d			include "forth_autostart.asm" 
5b6d			; list of commands to perform at system start up 
5b6d			 
5b6d			startcmds: 
5b6d			;	dw test11 
5b6d			;	dw test12 
5b6d			;	dw test13 
5b6d			;	dw test14 
5b6d			;	dw test15 
5b6d			;	dw test16 
5b6d			;	dw test17 
5b6d			;	dw ifthtest1 
5b6d			;	dw ifthtest2 
5b6d			;	dw ifthtest3 
5b6d			;	dw mmtest1 
5b6d			;	dw mmtest2 
5b6d			;	dw mmtest3 
5b6d			;	dw mmtest4 
5b6d			;	dw mmtest5 
5b6d			;	dw mmtest6 
5b6d			;	dw iftest1 
5b6d			;	dw iftest2 
5b6d			;	dw iftest3 
5b6d			;	dw looptest1 
5b6d			;	dw looptest2 
5b6d			;	dw test1 
5b6d			;	dw test2 
5b6d			;	dw test3 
5b6d			;	dw test4 
5b6d			;	dw game2r 
5b6d			;	dw game2b1 
5b6d			;	dw game2b2 
5b6d			 
5b6d				; start up words that are actually useful 
5b6d			 
5b6d e1 5b		    dw spi1 
5b6f 3c 5c		    dw spi2 
5b71 ca 5c		    dw spi3 
5b73 72 5c		    dw spi4 
5b75 9d 5c		    dw spi5 
5b77 30 5d		    dw spi6 
5b79 85 5d		    dw spi7 
5b7b			 
5b7b dd 5d		    dw spi8 
5b7d fc 5d		    dw spi9 
5b7f 54 5e		    dw spi10 
5b81			 
5b81 c7 5e			dw longread 
5b83 0e 5f			dw clrstack 
5b85 41 5f			dw type 
5b87 31 61			dw stest 
5b89 65 5f			dw strncpy 
5b8b c7 60			dw list 
5b8d c6 5f			dw start1 
5b8f d8 5f			dw start2 
5b91			;	dw start3 
5b91 eb 5f			dw start3b 
5b93 67 60			dw start3c 
5b95			 
5b95				; (unit) testing words 
5b95			 
5b95 a8 61			dw mtesta 
5b97 5d 62			dw mtestb 
5b99 00 63			dw mtestc 
5b9b b5 63			dw mtestd 
5b9d 59 64			dw mteste 
5b9f			 
5b9f				; demo/game words 
5b9f			 
5b9f 65 6b		        dw game3w 
5ba1 93 6b		        dw game3p 
5ba3 b1 6b		        dw game3sc 
5ba5 e2 6b		        dw game3vsi 
5ba7 0e 6c		        dw game3vs 
5ba9				 
5ba9 58 69			dw game2b 
5bab c6 69			dw game2bf 
5bad 10 6a			dw game2mba 
5baf a6 6a			dw game2mbas 
5bb1 e8 6a			dw game2mb 
5bb3			 
5bb3 19 66			dw game1 
5bb5 2a 66			dw game1a 
5bb7 8c 66			dw game1b 
5bb9 c1 66			dw game1c 
5bbb f7 66			dw game1d 
5bbd 28 67			dw game1s 
5bbf 3c 67			dw game1t 
5bc1 51 67			dw game1f 
5bc3 85 67			dw game1z 
5bc5 c9 67			dw game1zz 
5bc7			 
5bc7 0f 65			dw test5 
5bc9 47 65			dw test6 
5bcb 7f 65			dw test7 
5bcd 93 65			dw test8 
5bcf bf 65			dw test9 
5bd1 d5 65			dw test10 
5bd3				 
5bd3 a0 68		        dw ssv5 
5bd5 84 68		        dw ssv4 
5bd7 68 68		        dw ssv3 
5bd9 32 68		        dw ssv2 
5bdb b9 68		        dw ssv1 
5bdd 01 69		        dw ssv1cpm 
5bdf			;	dw keyup 
5bdf			;	dw keydown 
5bdf			;	dw keyleft 
5bdf			;	dw keyright 
5bdf			;	dw 	keyf1 
5bdf			;	dw keyf2 
5bdf			;	dw keyf3 
5bdf			;	dw keyf4 
5bdf			;	dw keyf5 
5bdf			;	dw keyf6 
5bdf			;	dw keyf7 
5bdf			;	dw keyf8 
5bdf			;	dw keyf9 
5bdf			;	dw keyf10 
5bdf			;	dw keyf11 
5bdf			;	dw keyf12 
5bdf			;	dw keytab 
5bdf			;	dw keycr 
5bdf			;	dw keyhome 
5bdf			;	dw keyend 
5bdf			;	dw keybs 
5bdf 00 00			db 0, 0	 
5be1			 
5be1			; SPI Net support words 
5be1			 
5be1			; v0! = node to send to 
5be1			; ( str count - ) 
5be1 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5c3c			 
5c3c			; spiputchr ( char node - ) 
5c3c .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5c72			 
5c72			; spigetchr ( - n ) 
5c72 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5c9d			 
5c9d			; getnode ( - n ) 
5c9d .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5cca			 
5cca			; ( str node - )  
5cca .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5d30			; store string ( str i - ) 
5d30			 
5d30			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5d30 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5d85			 
5d85			; get string ( addr i -  )    TO FIX 
5d85			 
5d85 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5ddd			 
5ddd			 
5ddd			; NETCHAT (TODO) 
5ddd			; Program to allow two nodes to chat with eachother 
5ddd			; 
5ddd			; v0 - target node 
5ddd			;  
5ddd			; accept input at 0,0 
5ddd			; if input is string send spitype to target node 
5ddd			; starting at row 2,0 , while spigetchr is not zero ->  
5ddd			; 
5ddd			; 
5ddd			; TODO add paging of get request 
5ddd			 
5ddd			; ( node - ) 
5ddd .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5dfc .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5e54 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5ec7			 
5ec7			 
5ec7			; Long read of currently open file 
5ec7 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5f0e			 
5f0e			; clear stack  
5f0e			 
5f0e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5f41			 
5f41			; type ( addr count - ) 
5f41 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5f65			 
5f65			; some direct memory words 
5f65			; strncpy ( len t f -- t ) 
5f65			 
5f65 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5fc6			 
5fc6 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5fd8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5feb .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6067 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
60c7			 
60c7			 
60c7			; a handy word to list items on the stack 
60c7			 
60c7 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6131			 
6131			 
6131			; test stack  
6131			; rnd8 stest 
6131			 
6131 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
61a8			 
61a8			; random malloc and free cycles 
61a8			 
61a8 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
625d			 
625d			; fixed malloc and free cycles 
625d			 
625d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6300			 
6300			; fixed double string push and drop cycle  
6300			 
6300 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
63b5			 
63b5			; consistent fixed string push and drop cycle  
63b5			 
63b5 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6459			 
6459 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
650f			 
650f			;test1:		db ": aa 1 2 3 ;", 0 
650f			;test2:     	db "111 aa 888 999",0 
650f			;test3:     	db ": bb 77 ;",0 
650f			;test4:     	db "$02 $01 do i . loop bb",0 
650f			 
650f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6547 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
657f .. 00		test7:     	db ": box hline vline ;",0 
6593 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
65bf .. 00		test9:     	db ": sw $01 adsp world ;",0 
65d5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
65fa .. 00		test11:     	db "hello create .",0 
6609 .. 00		test12:     	db "hello2 create .",0 
6619			 
6619			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6619			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6619			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6619			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6619			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6619			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6619			 
6619			;iftest1:     	db "$0001 IF cls .",0 
6619			;iftest2:     	db "$0000 IF cls .",0 
6619			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6619			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6619			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6619			 
6619			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6619			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6619			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6619			 
6619			 
6619			 
6619			; a small guess the number game 
6619			 
6619 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
662a .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
668c			 
668c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
66c1 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
66f7 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6728 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
673c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6751 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6785 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
67c9			 
67c9			; Using 'ga' save a high score across multiple runs using external storage 
67c9			 
67c9 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6832			 
6832			 
6832			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6832			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6832			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6832			 
6832			; simple screen saver to test code memory reuse to destruction 
6832			 
6832 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6868 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6884 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
68a0 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
68b9 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6901 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6958			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6958			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6958			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6958			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6958			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6958			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6958			 
6958			 
6958			 
6958			; minesweeper/battleship finding game 
6958			; draws a game board of random ship/mine positions 
6958			; user enters coords to see if it hits on 
6958			; game ends when all are hit 
6958			; when hit or miss says how many may be in the area 
6958			 
6958			; setup the game board and then hide it 
6958 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
69c6 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6a10			; prompt for where to target 
6a10 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6aa6 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6acb			; TODO see if the entered coords hits or misses pushes char hit of miss 
6acb .. 00		game2mbht:      db ": mbckht nop ;",0 
6ada .. 00		game2mbms:      db ": mbcms nop ;",0 
6ae8			; TODO how many might be near by 
6ae8 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6b65			 
6b65			; Game 3 
6b65			 
6b65			; Vert scroller ski game - avoid the trees! 
6b65			 
6b65			; v0 score (ie turns) 
6b65			; v1 player pos 
6b65			; v2 left wall 
6b65			; v3 right wall 
6b65			 
6b65			; Draw side walls randomly 
6b65			 
6b65 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6b93			 
6b93			; Draw player 
6b93 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6bb1			 
6bb1			; TODO Get Key 
6bb1			 
6bb1			; TODO Move left right 
6bb1			 
6bb1			; scroll and move walls a bit 
6bb1			 
6bb1 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6be2			 
6be2			; main game loop 
6be2			 
6be2 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6c0e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6c4d			 
6c4d			; key board defs 
6c4d			 
6c4d .. 00		keyup:       db ": keyup $05 ;",0 
6c5b .. 00		keydown:       db ": keydown $0a ;",0 
6c6b .. 00		keyleft:       db ": keyleft $0b ;",0 
6c7b .. 00		keyright:       db ": keyright $0c ;",0 
6c8c .. 00		keyf1:       db ": keyf1 $10 ;",0 
6c9a .. 00		keyf2:       db ": keyf2 $11 ;",0 
6ca8 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6cb6 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6cc4 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6cd2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6ce0 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6cee .. 00		keyf8:       db ": keyf8 $17 ;",0 
6cfc .. 00		keyf9:       db ": keyf9 $18 ;",0 
6d0a .. 00		keyf10:       db ": keyf10 $19 ;",0 
6d19 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6d28 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6d37			 
6d37 .. 00		keytab:       db ": keytab $09 ;",0 
6d46 .. 00		keycr:       db ": keycr $0d ;",0 
6d54 .. 00		keyhome:       db ": keyhome $0e ;",0 
6d64 .. 00		keyend:       db ": keyend $0f ;",0 
6d73 .. 00		keybs:       db ": keybs $08 ;",0 
6d81			 
6d81			   
6d81			 
6d81			 
6d81			 
6d81			; eof 
# End of file forth_autostart.asm
6d81			 
6d81 .. 00		sprompt1: db "Startup load...",0 
6d91 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6da7			 
6da7			 
6da7			 
6da7			 
6da7			forth_startup: 
6da7 21 6d 5b			ld hl, startcmds 
6daa 3e 00			ld a, 0 
6dac 32 ee f5			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6daf			 
6daf e5			.start1:	push hl 
6db0 cd 18 0d			call clear_display 
6db3 11 81 6d			ld de, sprompt1 
6db6 3e 00		        ld a, display_row_1 
6db8 cd 2b 0d			call str_at_display 
6dbb 11 91 6d			ld de, sprompt2 
6dbe 3e 28		        ld a, display_row_2 
6dc0 cd 2b 0d			call str_at_display 
6dc3 e1				pop hl 
6dc4 e5				push hl 
6dc5 5e				ld e,(hl) 
6dc6 23				inc hl 
6dc7 56				ld d,(hl) 
6dc8 3e 50		        ld a, display_row_3 
6dca cd 2b 0d			call str_at_display 
6dcd cd 3b 0d			call update_display 
6dd0			 
6dd0			 
6dd0 3a ee f5			ld a, (os_last_cmd) 
6dd3 fe 00			cp 0 
6dd5 28 05			jr z, .startprompt 
6dd7 cd 89 0c			call delay250ms 
6dda 18 24			jr .startdo 
6ddc				 
6ddc				 
6ddc			 
6ddc			.startprompt: 
6ddc			 
6ddc 3e 9f			ld a,display_row_4 + display_cols - 1 
6dde 11 dd 1e		        ld de, endprg 
6de1 cd 2b 0d			call str_at_display 
6de4 cd 3b 0d			call update_display 
6de7 cd 95 0c			call delay1s 
6dea cd f9 74			call cin_wait 
6ded						 
6ded fe 2a			cp '*' 
6def 28 5e			jr z, .startupend1 
6df1 fe 23			cp '#' 
6df3 20 07			jr nz, .startno 
6df5 3e 01			ld a, 1 
6df7 32 ee f5			ld (os_last_cmd),a 
6dfa 18 04			jr .startdo 
6dfc fe 31		.startno:	cp '1' 
6dfe 28 3a			jr z,.startnxt  
6e00			 
6e00				; exec startup line 
6e00			.startdo:	 
6e00 e1				pop hl 
6e01 e5				push hl 
6e02				 
6e02 5e				ld e,(hl) 
6e03 23				inc hl 
6e04 56				ld d,(hl) 
6e05 eb				ex de,hl 
6e06			 
6e06 e5				push hl 
6e07			 
6e07 3e 00			ld a, 0 
6e09				;ld a, FORTH_END_BUFFER 
6e09 cd b5 13			call strlent 
6e0c 23				inc hl   ; include zero term to copy 
6e0d 06 00			ld b,0 
6e0f 4d				ld c,l 
6e10 e1				pop hl 
6e11 11 c8 f1			ld de, scratch 
6e14 ed b0			ldir 
6e16			 
6e16			 
6e16 21 c8 f1			ld hl, scratch 
6e19 cd 62 23			call forthparse 
6e1c cd a2 23			call forthexec 
6e1f cd b4 22			call forthexec_cleanup 
6e22			 
6e22 3e 78			ld a, display_row_4 
6e24 11 81 1c			ld de, endprog 
6e27			 
6e27 cd 3b 0d			call update_display		 
6e2a			 
6e2a 3a ee f5			ld a, (os_last_cmd) 
6e2d fe 00			cp 0 
6e2f 20 09			jr nz, .startnxt 
6e31 cd df 1e			call next_page_prompt 
6e34 cd 18 0d		        call clear_display 
6e37 cd 3b 0d			call update_display		 
6e3a			 
6e3a				; move onto next startup line? 
6e3a			.startnxt: 
6e3a			 
6e3a cd 89 0c			call delay250ms 
6e3d e1				pop hl 
6e3e			 
6e3e 23				inc hl 
6e3f 23				inc hl 
6e40			 
6e40 e5				push hl 
6e41 5e				ld e, (hl) 
6e42 23				inc hl 
6e43 56				ld d, (hl) 
6e44 e1				pop hl 
6e45				; TODO replace 0 test 
6e45			 
6e45 eb				ex de, hl 
6e46 cd 75 0f			call ishlzero 
6e49			;	ld a,e 
6e49			;	add d 
6e49			;	cp 0    ; any left to do? 
6e49 eb				ex de, hl 
6e4a c2 af 6d			jp nz, .start1 
6e4d 18 01			jr .startupend 
6e4f			 
6e4f e1			.startupend1: pop hl 
6e50			.startupend: 
6e50			 
6e50 cd 18 0d			call clear_display 
6e53 cd 3b 0d			call update_display 
6e56 c9				ret 
6e57			 
6e57			 
6e57			; stack over and underflow checks 
6e57			 
6e57			; init the words to detect the under/overflow 
6e57			 
6e57			chk_stk_init: 
6e57				; a vague random number to check so we dont get any "lucky" hits 
6e57 3e 2d			ld a, 45 
6e59 6f				ld l, a 
6e5a 00				nop 
6e5b 3e 17			ld a, 23 
6e5d 67				ld h, a 
6e5e			 
6e5e 22 af f1			ld (chk_word), hl     ; the word we need to check against 
6e61			 
6e61			;	ld (chk_stund), hl	; stack points.... 
6e61 22 fd fe			ld (chk_stovr), hl 
6e64 22 f3 f9			ld (chk_ret_und), hl 
6e67 22 b1 f9			ld (chk_ret_ovr), hl 
6e6a 22 2f f9			ld (chk_loop_ovr), hl 
6e6d 22 2d f7			ld (chk_data_ovr), hl 
6e70 c9				ret 
6e71				 
6e71			check_stacks: 
6e71				; check all stack words 
6e71			 
6e71 e5				push hl 
6e72 d5				push de 
6e73			 
6e73			;	ld de,(chk_word) 
6e73			;	ld hl, (chk_stund)	; stack points.... 
6e73			;	if DEBUG_STK_FAULT 
6e73			;		DMARK "FAa" 
6e73			;		CALLMONITOR 
6e73			;	endif 
6e73			;	call cmp16 
6e73			;	jp z, .chk_faulta 
6e73			; 
6e73			;	ld de, sfaultsu 
6e73			;	jp .chk_fault 
6e73			 
6e73 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6e76 ed 5b af f1		ld de,(chk_word) 
6e7a				if DEBUG_STK_FAULT 
6e7a					DMARK "FAb" 
6e7a					CALLMONITOR 
6e7a				endif 
6e7a cd 6a 0f			call cmp16 
6e7d 28 06			jr z, .chk_fault1 
6e7f 11 20 6f			ld de, sfaultso 
6e82 c3 d4 6e			jp .chk_fault 
6e85			.chk_fault1:  
6e85 2a f3 f9			ld hl, (chk_ret_und) 
6e88 ed 5b af f1		ld de,(chk_word) 
6e8c				if DEBUG_STK_FAULT 
6e8c					DMARK "FAU" 
6e8c					CALLMONITOR 
6e8c				endif 
6e8c cd 6a 0f			call cmp16 
6e8f ca 98 6e			jp z, .chk_fault2 
6e92 11 30 6f			ld de, sfaultru 
6e95 c3 d4 6e			jp .chk_fault 
6e98			.chk_fault2:  
6e98 2a b1 f9			ld hl, (chk_ret_ovr) 
6e9b ed 5b af f1		ld de,(chk_word) 
6e9f				if DEBUG_STK_FAULT 
6e9f					DMARK "FA1" 
6e9f					CALLMONITOR 
6e9f				endif 
6e9f cd 6a 0f			call cmp16 
6ea2 ca ab 6e			jp z, .chk_fault3 
6ea5 11 3e 6f			ld de, sfaultro 
6ea8 c3 d4 6e			jp .chk_fault 
6eab			.chk_fault3:  
6eab 2a 2f f9			ld hl, (chk_loop_ovr) 
6eae ed 5b af f1		ld de,(chk_word) 
6eb2				if DEBUG_STK_FAULT 
6eb2					DMARK "FA2" 
6eb2					CALLMONITOR 
6eb2				endif 
6eb2 cd 6a 0f			call cmp16 
6eb5 ca be 6e			jp z, .chk_fault4 
6eb8 11 58 6f			ld de, sfaultlo 
6ebb c3 d4 6e			jp .chk_fault 
6ebe			.chk_fault4:  
6ebe 2a 2d f7			ld hl, (chk_data_ovr) 
6ec1 ed 5b af f1		ld de,(chk_word) 
6ec5				if DEBUG_STK_FAULT 
6ec5					DMARK "FA3" 
6ec5					CALLMONITOR 
6ec5				endif 
6ec5 cd 6a 0f			call cmp16 
6ec8 ca d1 6e			jp z, .chk_fault5 
6ecb 11 72 6f			ld de, sfaultdo 
6ece c3 d4 6e			jp .chk_fault 
6ed1			 
6ed1			 
6ed1			.chk_fault5:  
6ed1 d1				pop de 
6ed2 e1				pop hl 
6ed3			 
6ed3 c9				ret 
6ed4			 
6ed4 cd 18 0d		.chk_fault: 	call clear_display 
6ed7 3e 28				ld a, display_row_2 
6ed9 cd 2b 0d				call str_at_display 
6edc 11 02 6f				   ld de, .stackfault 
6edf 3e 00				ld a, display_row_1 
6ee1 cd 2b 0d				call str_at_display 
6ee4 11 6e fe				    ld de, debug_mark 
6ee7 3e 11				ld a, display_row_1+17 
6ee9 cd 2b 0d				call str_at_display 
6eec cd 3b 0d				call update_display 
6eef			 
6eef				; prompt before entering montior for investigating issue 
6eef			 
6eef 3e 78			ld a, display_row_4 
6ef1 11 81 1c			ld de, endprog 
6ef4			 
6ef4 cd 3b 0d			call update_display		 
6ef7			 
6ef7 cd df 1e			call next_page_prompt 
6efa			 
6efa d1				pop de 
6efb e1				pop hl 
6efc cd d5 1c				call monitor 
6eff c3 cc 1b				jp warmstart 
6f02					;jp 0 
6f02					;halt 
6f02			 
6f02			 
6f02			 
6f02 .. 00		.stackfault: 	db "Stack fault:",0 
6f0f			 
6f0f .. 00		sfaultsu: 	db	"Stack under flow",0 
6f20 .. 00		sfaultso: 	db	"Stack over flow",0 
6f30 .. 00		sfaultru:	db "RTS underflow",0 
6f3e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6f58 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6f72 .. 00		sfaultdo:	db "DTS overflow", 0 
6f7f			 
6f7f			 
6f7f			fault_dsp_under: 
6f7f 11 91 6f			ld de, .dsp_under 
6f82 c3 41 70			jp .show_fault 
6f85			 
6f85			fault_rsp_under: 
6f85 11 9f 6f			ld de, .rsp_under 
6f88 c3 41 70			jp .show_fault 
6f8b			fault_loop_under: 
6f8b 11 ad 6f			ld de, .loop_under 
6f8e c3 41 70			jp .show_fault 
6f91			 
6f91 .. 00		.dsp_under: db "DSP Underflow",0 
6f9f .. 00		.rsp_under: db "RSP Underflow",0 
6fad .. 00		.loop_under: db "LOOP Underflow",0 
6fbc			 
6fbc			 
6fbc d5			type_faultn: 	push de 
6fbd e5					push hl 
6fbe cd 18 0d				call clear_display 
6fc1 11 e8 6f				   ld de, .typefaultn 
6fc4 3e 00				ld a, display_row_1 
6fc6 cd 2b 0d				call str_at_display 
6fc9 11 6e fe				    ld de, debug_mark 
6fcc 3e 11				ld a, display_row_1+17 
6fce cd 2b 0d				call str_at_display 
6fd1 cd 3b 0d				call update_display 
6fd4			 
6fd4				; prompt before entering montior for investigating issue 
6fd4			 
6fd4 3e 78			ld a, display_row_4 
6fd6 11 81 1c			ld de, endprog 
6fd9			 
6fd9 cd 3b 0d			call update_display		 
6fdc			 
6fdc cd df 1e			call next_page_prompt 
6fdf			 
6fdf e5					push hl 
6fe0 d5					push de 
6fe1 cd d5 1c				call monitor 
6fe4 c3 cc 1b				jp warmstart 
6fe7 76					halt 
6fe8			 
6fe8			 
6fe8 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6fff			 
6fff d5			type_faults: 	push de 
7000 e5					push hl 
7001 cd 18 0d				call clear_display 
7004 11 2a 70				   ld de, .typefaults 
7007 3e 00				ld a, display_row_1 
7009 cd 2b 0d				call str_at_display 
700c 11 6e fe				    ld de, debug_mark 
700f 3e 11				ld a, display_row_1+17 
7011 cd 2b 0d				call str_at_display 
7014 cd 3b 0d				call update_display 
7017			 
7017				; prompt before entering montior for investigating issue 
7017			 
7017 3e 78			ld a, display_row_4 
7019 11 81 1c			ld de, endprog 
701c			 
701c cd 3b 0d			call update_display		 
701f			 
701f cd df 1e			call next_page_prompt 
7022			 
7022 e1					pop hl 
7023 d1					pop de 
7024 cd d5 1c				call monitor 
7027 c3 cc 1b				jp warmstart 
702a			 
702a			 
702a .. 00		.typefaults: db "STR Type Expected TOS!",0 
7041			 
7041			.show_fault: 	 
7041 d5					push de 
7042 cd 18 0d				call clear_display 
7045 d1					pop de 
7046 3e 00				ld a, display_row_1 
7048 cd 2b 0d				call str_at_display 
704b 11 6e fe				    ld de, debug_mark 
704e 3e 11				ld a, display_row_1+17 
7050 cd 2b 0d				call str_at_display 
7053 cd 3b 0d				call update_display 
7056			 
7056				; prompt before entering montior for investigating issue 
7056			 
7056 3e 78			ld a, display_row_4 
7058 11 81 1c			ld de, endprog 
705b			 
705b cd 3b 0d			call update_display		 
705e			 
705e cd df 1e			call next_page_prompt 
7061			 
7061 e1					pop hl 
7062 d1					pop de 
7063 cd d5 1c				call monitor 
7066			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7066			; TODO Make optional fault restart to cli or warm boot? 
7066					;jp warmstart 
7066 c3 27 1c				jp cli 
7069 76					halt 
706a			 
706a			; handle the auto run of code from files in storage 
706a			 
706a			 
706a			if STORAGE_SE 
706a			 
706a .. 00		sprompt3: db "Loading from start-up file?:",0 
7087 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
7098			 
7098			 
7098			forth_autoload: 
7098			 
7098				; load block 0 of store 1 
7098				 
7098 3e fe			ld a, $fe      ; bit 0 clear 
709a 32 67 fa			ld (spi_device), a 
709d			 
709d cd cd 04			call storage_get_block_0 
70a0			 
70a0 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
70a3			 
70a3 fe 00			cp 0 
70a5 c8				ret z     ; auto start not enabled 
70a6			 
70a6 cd 18 0d			call clear_display 
70a9			 
70a9				; set bank 
70a9			 
70a9 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
70ac 32 67 fa				ld (spi_device), a 
70af			 
70af				; get file id to load from and get the file name to display 
70af			 
70af 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
70b2			 
70b2 2e 00				ld l, 0 
70b4 67					ld h, a 
70b5 11 81 fa				ld de, store_page 
70b8			 
70b8					if DEBUG_FORTH_WORDS 
70b8						DMARK "ASp" 
70b8 f5				push af  
70b9 3a cd 70			ld a, (.dmark)  
70bc 32 6e fe			ld (debug_mark),a  
70bf 3a ce 70			ld a, (.dmark+1)  
70c2 32 6f fe			ld (debug_mark+1),a  
70c5 3a cf 70			ld a, (.dmark+2)  
70c8 32 70 fe			ld (debug_mark+2),a  
70cb 18 03			jr .pastdmark  
70cd ..			.dmark: db "ASp"  
70d0 f1			.pastdmark: pop af  
70d1			endm  
# End of macro DMARK
70d1						CALLMONITOR 
70d1 cd f3 18			call break_point_state  
70d4				endm  
# End of macro CALLMONITOR
70d4					endif 
70d4 cd 75 09				call storage_read 
70d7			 
70d7					if DEBUG_FORTH_WORDS 
70d7						DMARK "ASr" 
70d7 f5				push af  
70d8 3a ec 70			ld a, (.dmark)  
70db 32 6e fe			ld (debug_mark),a  
70de 3a ed 70			ld a, (.dmark+1)  
70e1 32 6f fe			ld (debug_mark+1),a  
70e4 3a ee 70			ld a, (.dmark+2)  
70e7 32 70 fe			ld (debug_mark+2),a  
70ea 18 03			jr .pastdmark  
70ec ..			.dmark: db "ASr"  
70ef f1			.pastdmark: pop af  
70f0			endm  
# End of macro DMARK
70f0						CALLMONITOR 
70f0 cd f3 18			call break_point_state  
70f3				endm  
# End of macro CALLMONITOR
70f3					endif 
70f3			 
70f3 cd 75 0f				call ishlzero 
70f6 c8					ret z             ; file not found 
70f7			 
70f7 3e 32				ld a, display_row_2 + 10 
70f9 11 84 fa				ld de, store_page+3 
70fc cd 2b 0d				call str_at_display 
70ff				 
70ff			; 
70ff			 
70ff 3e 05			ld a, display_row_1+5 
7101 11 6a 70			ld de, sprompt3 
7104 cd 2b 0d			call str_at_display 
7107 3e 5f			ld a, display_row_3+15 
7109 11 87 70			ld de, sprompt4 
710c cd 2b 0d			call str_at_display 
710f			 
710f cd 3b 0d			call update_display 
7112			 
7112 cd f9 74			call cin_wait 
7115 fe 6e			cp 'n' 
7117 c8				ret z 
7118 fe 4e			cp 'N' 
711a c8				ret z 
711b			 
711b cd 95 0c			call delay1s 
711e			 
711e 3a 83 fa			ld a, (store_page+2) 
7121 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
7124 3e 01			ld a, 1  
7126 32 71 fa			ld (store_openext), a    ; save count of ext 
7129			 
7129			.autof:  
7129 6f				ld l , a 
712a				 
712a 3a 81 fa			ld a, (store_page) 
712d 67				ld h, a	 
712e 11 81 fa			ld de, store_page 
7131					if DEBUG_FORTH_WORDS 
7131						DMARK "ASl" 
7131 f5				push af  
7132 3a 46 71			ld a, (.dmark)  
7135 32 6e fe			ld (debug_mark),a  
7138 3a 47 71			ld a, (.dmark+1)  
713b 32 6f fe			ld (debug_mark+1),a  
713e 3a 48 71			ld a, (.dmark+2)  
7141 32 70 fe			ld (debug_mark+2),a  
7144 18 03			jr .pastdmark  
7146 ..			.dmark: db "ASl"  
7149 f1			.pastdmark: pop af  
714a			endm  
# End of macro DMARK
714a						CALLMONITOR 
714a cd f3 18			call break_point_state  
714d				endm  
# End of macro CALLMONITOR
714d					endif 
714d cd 75 09				call storage_read 
7150 cd 75 0f			call ishlzero 
7153 c8				ret z 
7154			;	jr z, .autoend 
7154			 
7154					if DEBUG_FORTH_WORDS 
7154						DMARK "ASc" 
7154 f5				push af  
7155 3a 69 71			ld a, (.dmark)  
7158 32 6e fe			ld (debug_mark),a  
715b 3a 6a 71			ld a, (.dmark+1)  
715e 32 6f fe			ld (debug_mark+1),a  
7161 3a 6b 71			ld a, (.dmark+2)  
7164 32 70 fe			ld (debug_mark+2),a  
7167 18 03			jr .pastdmark  
7169 ..			.dmark: db "ASc"  
716c f1			.pastdmark: pop af  
716d			endm  
# End of macro DMARK
716d						CALLMONITOR 
716d cd f3 18			call break_point_state  
7170				endm  
# End of macro CALLMONITOR
7170					endif 
7170 11 83 fa			ld de, store_page+2 
7173 3e 78			ld a, display_row_4 
7175 cd 2b 0d			call str_at_display 
7178			 
7178 cd 3b 0d			call update_display 
717b cd 89 0c			call delay250ms 
717e			 
717e			 
717e			 
717e 21 83 fa			ld hl, store_page+2 
7181 cd 62 23			call forthparse 
7184 cd a2 23			call forthexec 
7187 cd b4 22			call forthexec_cleanup 
718a			 
718a				 
718a 3a 71 fa			ld a, (store_openext) 
718d 3c				inc a 
718e 32 71 fa			ld (store_openext), a    ; save count of ext 
7191			 
7191 18 96			jr .autof 
7193			;.autofdone: 
7193			; 
7193			;		if DEBUG_FORTH_WORDS 
7193			;			DMARK "ASx" 
7193			;			CALLMONITOR 
7193			;		endif 
7193			;;	call clear_display 
7193			;	ret 
7193			 
7193			 
7193			 
7193			endif 
7193			 
7193			 
7193			; eof 
# End of file forth_kernel.asm
7193			;include "nascombasic.asm" 
7193			 
7193			 
7193			; find out where the code ends if loaded into RAM (for SC114) 
7193			;endofcode:  
7193			;	nop 
7193			 
7193			 
7193			; eof 
7193			 
# End of file main.asm
7193			include "firmware_lcd_4x40.asm" 
7193			; **********************************************************************  
7193			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7193			; **********************************************************************  
7193			;  
7193			; **  Written as a Small Computer Monitor App  
7193			; **  www.scc.me.uk  
7193			;  
7193			; History  
7193			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7193			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7193			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7193			;  
7193			; **********************************************************************  
7193			;  
7193			; This program is an example of one of the methods of interfacing an   
7193			; alphanumeric LCD module.   
7193			;  
7193			; In this example the display is connected to either a Z80 PIO or a   
7193			; simple 8-bit output port.   
7193			;  
7193			; This interfacing method uses 4-bit data mode and uses time delays  
7193			; rather than polling the display's ready status. As a result the   
7193			; interface only requires 6 simple output lines:  
7193			;   Output bit 0 = not used  
7193			;   Output bit 1 = not used  
7193			;   Output bit 2 = RS         High = data, Low = instruction  
7193			;   Output bit 3 = E          Active high  
7193			;   Output bit 4 = DB4  
7193			;   Output bit 5 = DB5  
7193			;   Output bit 6 = DB6  
7193			;   Output bit 7 = DB7  
7193			; Display's R/W is connected to 0v so it is always in write mode  
7193			;  
7193			; This set up should work with any system supporting the RC2014 bus  
7193			  
7193			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7193			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7193			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7193			;  
7193			; **********************************************************************  
7193			  
7193			; Additonal for 4x40. E1 and E2 instead of just E   
7193			; TODO swipe vidout signal on port a to activate E2  
7193			  
7193			; **********************************************************************  
7193			; **  Constants  
7193			; **********************************************************************  
7193			; LCD constants required by LCD support module  
7193			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7193			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7193			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7193			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7193			; TODO Decide which E is being set  
7193			kLCDWidth:  EQU display_cols             ;Width in characters  
7193			  
7193			; **********************************************************************  
7193			; **  Code library usage  
7193			; **********************************************************************  
7193			  
7193			; send character to current cursor position  
7193			; wraps and/or scrolls screen automatically  
7193			  
7193			  
7193			  
7193			lcd_init:  
7193			  
7193			; SCMonAPI functions used  
7193			  
7193			; Alphanumeric LCD functions used  
7193			; no need to specify specific functions for this module  
7193			  
7193 3e cf		            LD   A, 11001111b  
7195 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7197 3e 00		            LD   A, 00000000b  
7199 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
719b			  
719b			; Initialise alphanumeric LCD module  
719b 3e 00				ld a, 0  
719d 32 ce fb				ld (display_lcde1e2), a  
71a0 cd 21 72		            CALL fLCD_Init      ;Initialise LCD module  
71a3 3e 01				ld a, 1  
71a5 32 ce fb				ld (display_lcde1e2), a  
71a8 cd 21 72		            CALL fLCD_Init      ;Initialise LCD module  
71ab			  
71ab c9				ret  
71ac			  
71ac			;  
71ac			;;  
71ac			; lcd functions  
71ac			;  
71ac			;  
71ac			  
71ac			; what is at cursor position   
71ac			  
71ac			;get_cursor:	ld de, (cursor_row)   ;  row + col  
71ac			;		call curptr  
71ac			;		ret  
71ac			  
71ac			  
71ac			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
71ac			  
71ac			curptr:  
71ac c5				push bc  
71ad 21 b4 fd			ld hl, display_fb0  
71b0			cpr:	  
71b0				; loop for cursor whole row  
71b0 0e 28			ld c, display_cols  
71b2 23			cpr1:	inc hl  
71b3 0d				dec c  
71b4 20 fc			jr nz, cpr1  
71b6 05				dec b  
71b7 20 f7			jr nz, cpr  
71b9			  
71b9				; add col	  
71b9			  
71b9 23			cpr2:	inc hl  
71ba 1d				dec e  
71bb 20 fc			jr nz, cpr2  
71bd			  
71bd c1				pop bc  
71be c9				ret  
71bf				  
71bf			  
71bf			  
71bf			  
71bf			  
71bf			; write the frame buffer given in hl to hardware   
71bf 22 cc fb		write_display: ld (display_write_tmp), hl 	   
71c2 3e 00			ld a, kLCD_Line1  
71c4 cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71c7 06 28			ld b, display_cols  
71c9 ed 5b cc fb		ld de, (display_write_tmp)  
71cd cd 19 72			call write_len_string  
71d0				  
71d0				  
71d0 2a cc fb			ld hl, (display_write_tmp)  
71d3 11 28 00			ld de, display_cols  
71d6 19				add hl,de  
71d7 22 cc fb			ld (display_write_tmp),hl  
71da			  
71da				  
71da 3e 28			ld a, kLCD_Line2  
71dc cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71df 06 28			ld b, display_cols  
71e1 ed 5b cc fb		ld de, (display_write_tmp)  
71e5 cd 19 72			call write_len_string  
71e8				  
71e8 2a cc fb			ld hl, (display_write_tmp)  
71eb 11 28 00			ld de, display_cols  
71ee 19				add hl,de  
71ef 22 cc fb			ld (display_write_tmp),hl  
71f2			  
71f2				  
71f2 3e 50			ld a, kLCD_Line3  
71f4 cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
71f7 06 28			ld b, display_cols  
71f9 ed 5b cc fb		ld de, (display_write_tmp)  
71fd cd 19 72			call write_len_string  
7200				  
7200 2a cc fb			ld hl, (display_write_tmp)  
7203 11 28 00			ld de, display_cols  
7206 19				add hl,de  
7207 22 cc fb			ld (display_write_tmp),hl  
720a			  
720a				  
720a 3e 78			ld a, kLCD_Line4  
720c cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
720f 06 28			ld b, display_cols  
7211 ed 5b cc fb		ld de, (display_write_tmp)  
7215 cd 19 72			call write_len_string  
7218 c9					ret  
7219				  
7219				; write out a fixed length string given in b from de  
7219			  
7219 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
721a cd 86 72		            CALL fLCD_Data      ;Write character to display  
721d 13				inc de  
721e 10 f9			djnz write_len_string  
7220 c9				ret  
7221			  
7221			; Some other things to do  
7221			;            LD   A, kLCD_Clear ;Display clear  
7221			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7221			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7221			;            LD   A, kLCD_On     ;Display on with no cursor  
7221			;            ;LD   A, kLCD_Off   ;Display off  
7221			;            CALL fLCD_Inst      ;Send instruction to display  
7221			;  
7221			;  
7221			;            halt  
7221			;  
7221			;  
7221			;MsgHello:   DB  "Hello World!",0  
7221			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7221			  
7221			; Custom characters 5 pixels wide by 8 pixels high  
7221			; Up to 8 custom characters can be defined  
7221			;BitMaps:      
7221			;; Character 0x00 = Battery icon  
7221			;            DB  01110b  
7221			;            DB  11011b  
7221			;            DB  10001b  
7221			;            DB  10001b  
7221			;            DB  11111b  
7221			;            DB  11111b  
7221			;            DB  11111b  
7221			;            DB  11111b  
7221			;; Character 0x01 = Bluetooth icon  
7221			;            DB  01100b  
7221			;            DB  01010b  
7221			;            DB  11100b  
7221			;            DB  01000b  
7221			;            DB  11100b  
7221			;            DB  01010b  
7221			;            DB  01100b  
7221			;            DB  00000b  
7221			;  
7221			  
7221			  
7221			; **********************************************************************  
7221			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7221			; **********************************************************************  
7221			;  
7221			; **  Written as a Small Computer Monitor App   
7221			; **  Version 0.1 SCC 2018-05-16  
7221			; **  www.scc.me.uk  
7221			;  
7221			; **********************************************************************  
7221			;  
7221			; This module provides support for alphanumeric LCD modules using with  
7221			; *  HD44780 (or compatible) controller  
7221			; *  5 x 7 pixel fonts  
7221			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7221			; *  Interface via six digital outputs to the display (see below)  
7221			;  
7221			; LCD module pinout:  
7221			;   1  Vss   0v supply  
7221			;   2  Vdd   5v supply  
7221			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7221			;   4  RS    High = data, Low = instruction  
7221			;   5  R/W   High = Read, Low = Write  
7221			;   6  E     Enable signal (active high)  
7221			;   7  DB0   Data bit 0  
7221			;   8  DB1   Data bit 1  
7221			;   9  DB2   Data bit 2  
7221			;  10  DB3   Data bit 3  
7221			;  11  DB4   Data bit 4  
7221			;  12  DB5   Data bit 5  
7221			;  13  DB6   Data bit 6  
7221			;  14  DB7   Data bit 7  
7221			;  15  A     Backlight anode (+)  
7221			;  16  K     Backlight cathode (-)  
7221			;  
7221			; This interfacing method uses 4-bit data mode and uses time delays  
7221			; rather than polling the display's ready status. As a result the   
7221			; interface only requires 6 simple output lines:  
7221			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7221			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7221			;   LCD DB4 = Microcomputer output port bit 4  
7221			;   LCD DB5 = Microcomputer output port bit 5  
7221			;   LCD DB6 = Microcomputer output port bit 6  
7221			;   LCD DB7 = Microcomputer output port bit 7  
7221			; Display's R/W is connected to 0v so it is always in write mode  
7221			; All 6 connections must be on the same port address <kLCDPrt>  
7221			; This method also allows a decent length of cable from micro to LCD  
7221			;  
7221			; **********************************************************************  
7221			;  
7221			; To include the code for any given function provided by this module,   
7221			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7221			; the parent source file.  
7221			; For example:  #REQUIRES   uHexPrefix  
7221			;  
7221			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7221			; in the parent source file.  
7221			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7221			;  
7221			; These are the function names provided by this module:  
7221			; fLCD_Init                     ;Initialise LCD  
7221			; fLCD_Inst                     ;Send instruction to LCD  
7221			; fLCD_Data                     ;Send data byte to LCD  
7221			; fLCD_Pos                      ;Position cursor  
7221			; fLCD_Str                      ;Display string  
7221			; fLCD_Def                      ;Define custom character  
7221			;  
7221			; **********************************************************************  
7221			;  
7221			; Requires SCMonAPI.asm to also be included in the project  
7221			;  
7221			  
7221			  
7221			; **********************************************************************  
7221			; **  Constants  
7221			; **********************************************************************  
7221			  
7221			; Constants that must be defined externally  
7221			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7221			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7221			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7221			;kLCDWidth: EQU 20             ;Width in characters  
7221			  
7221			; general line offsets in any frame buffer  
7221			  
7221			  
7221			display_row_1: equ 0  
7221			display_row_2: equ display_row_1+display_cols  
7221			display_row_3: equ display_row_2 + display_cols  
7221			display_row_4: equ display_row_3 + display_cols  
7221			;display_row_4_eol:   
7221			  
7221			  
7221			; Cursor position values for the start of each line  
7221			  
7221			; E  
7221			kLCD_Line1: EQU 0x00   
7221			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7221			; E1  
7221			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7221			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7221			  
7221			; Instructions to send as A register to fLCD_Inst  
7221			kLCD_Clear: EQU 00000001b     ;LCD clear  
7221			kLCD_Off:   EQU 00001000b     ;LCD off  
7221			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7221			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7221			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7221			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7221			  
7221			; Constants used by this code module  
7221			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7221			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7221			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7221			  
7221			  
7221			  
7221			; **********************************************************************  
7221			; **  LCD support functions  
7221			; **********************************************************************  
7221			  
7221			; Initialise alphanumeric LCD module  
7221			; LCD control register codes:  
7221			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7221			;   N    0 = 1-line mode       1 = 2-line mode  
7221			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7221			;   D    0 = Display off       1 = Display on  
7221			;   C    0 = Cursor off        1 = Cursor on  
7221			;   B    0 = Blinking off      1 = Blinking on  
7221			;   ID   0 = Decrement mode    1 = Increment mode  
7221			;   SH   0 = Entire shift off  1 = Entire shift on  
7221 3e 28		fLCD_Init:  LD   A, 40  
7223 cd 48 73		            CALL LCDDelay       ;Delay 40ms after power up  
7226			; For reliable reset set 8-bit mode - 3 times  
7226 cd 18 73		            CALL WrFn8bit       ;Function = 8-bit mode  
7229 cd 18 73		            CALL WrFn8bit       ;Function = 8-bit mode  
722c cd 18 73		            CALL WrFn8bit       ;Function = 8-bit mode  
722f			; Set 4-bit mode  
722f cd 14 73		            CALL WrFn4bit       ;Function = 4-bit mode  
7232 cd 46 73		            CALL LCDDelay1      ;Delay 37 us or more  
7235			; Function set  
7235 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7237 cd 4a 72		            CALL fLCD_Inst      ;2 line, display on  
723a			; Display On/Off control  
723a 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
723c cd 4a 72		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
723f			; Display Clear  
723f 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7241 cd 4a 72		            CALL fLCD_Inst      ;Clear display  
7244			; Entry mode  
7244 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7246 cd 4a 72		            CALL fLCD_Inst      ;Increment mode, shift off  
7249			; Display module now initialised  
7249 c9			            RET  
724a			; ok to here  
724a			  
724a			; Write instruction to LCD  
724a			;   On entry: A = Instruction byte to be written  
724a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
724a f5			fLCD_Inst:  PUSH AF  
724b f5			            PUSH AF  
724c cd 5e 72		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
724f f1			            POP  AF  
7250 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7251 17			            RLA  
7252 17			            RLA  
7253 17			            RLA  
7254 cd 5e 72		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7257 3e 02		            LD   A, 2  
7259 cd 48 73		            CALL LCDDelay       ;Delay 2 ms to complete   
725c f1			            POP  AF  
725d c9			            RET  
725e			Wr4bits:   
725e f5					push af  
725f 3a ce fb				ld a, (display_lcde1e2)  
7262 fe 00				cp 0     ; e  
7264 20 10				jr nz, .wea2	  
7266 f1					pop af  
7267 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7269 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
726b cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
726d cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
726f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7271 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7273 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7275 c9			            RET  
7276 f1			.wea2:		pop af  
7277 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7279 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
727b cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
727d cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
727f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7281 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7283 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7285 c9			            RET  
7286			  
7286			  
7286			; Write data to LCD  
7286			;   On entry: A = Data byte to be written  
7286			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7286 f5			fLCD_Data:  PUSH AF  
7287 f5			            PUSH AF  
7288 cd 9a 72		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
728b f1			            POP  AF  
728c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
728d 17			            RLA  
728e 17			            RLA  
728f 17			            RLA  
7290 cd 9a 72		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7293 3e 96		            LD   A, 150  
7295 3d			Wait:      DEC  A              ;Wait a while to allow data   
7296 20 fd		            JR   NZ, Wait      ;  write to complete  
7298 f1			            POP  AF  
7299 c9			            RET  
729a			Wr4bitsa:     
729a f5					push af  
729b 3a ce fb				ld a, (display_lcde1e2)  
729e fe 00				cp 0     ; e1  
72a0 20 16				jr nz, .we2	  
72a2 f1					pop af  
72a3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
72a5 cb d7		            SET  kLCDBitRS, A  
72a7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
72a9 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
72ab cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
72ad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
72af cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
72b1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
72b3 cb 97		            RES  kLCDBitRS, A  
72b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72b7 c9			            RET  
72b8 f1			.we2:		pop af  
72b9 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
72bb cb d7		            SET  kLCDBitRS, A  
72bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
72bf cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
72c1 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
72c3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
72c5 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
72c7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
72c9 cb 97		            RES  kLCDBitRS, A  
72cb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72cd c9			            RET  
72ce			  
72ce			  
72ce			; Position cursor to specified location  
72ce			;   On entry: A = Cursor position  
72ce			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
72ce f5			fLCD_Pos:   PUSH AF  
72cf					; at this point set the E1 or E2 flag depending on position  
72cf			  
72cf c5					push bc  
72d0			;		push af  
72d0 06 00				ld b, 0  
72d2 4f					ld c, a  
72d3 3e 4f				ld a, kLCD_Line3-1  
72d5 b7			 		or a      ;clear carry flag  
72d6 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
72d7 38 04				jr c, .pe1  
72d9			  
72d9					; E selection  
72d9 cb 80				res 0, b         ; bit 0 unset e  
72db			;		pop af    ; before line 3 so recover orig pos  
72db			;		ld c, a    ; save for poking back  
72db 18 06				jr .peset	          
72dd			.pe1:          	; E2 selection  
72dd cb c0				set 0, b         ; bit 0 set e1  
72df 79					ld a, c  
72e0 de 4f				sbc a, kLCD_Line3-1  
72e2 4f					ld c, a	         ; save caculated offset  
72e3			;		pop af     ; bin this original value now we have calculated form  
72e3			  
72e3			.peset:		; set bit  
72e3 78					ld a, b  
72e4 32 ce fb				ld (display_lcde1e2), a 	  
72e7 79					ld a, c  
72e8 c1					pop bc  
72e9			  
72e9 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
72eb cd 4a 72		            CALL fLCD_Inst      ;Write instruction to LCD  
72ee f1			            POP  AF  
72ef c9			            RET  
72f0			  
72f0			  
72f0			; Output text string to LCD  
72f0			;   On entry: DE = Pointer to null terminated text string  
72f0			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
72f0 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
72f1 b7			            OR   A              ;Null terminator?  
72f2 c8			            RET  Z              ;Yes, so finished  
72f3 cd 86 72		            CALL fLCD_Data      ;Write character to display  
72f6 13			            INC  DE             ;Point to next character  
72f7 18 f7		            JR   fLCD_Str       ;Repeat  
72f9 c9					ret  
72fa			  
72fa			; Define custom character  
72fa			;   On entry: A = Character number (0 to 7)  
72fa			;             DE = Pointer to character bitmap data  
72fa			;   On exit:  A = Next character number  
72fa			;             DE = Next location following bitmap  
72fa			;             BC HL IX IY I AF' BC' DE' HL' preserved  
72fa			; Character is   
72fa c5			fLCD_Def:   PUSH BC  
72fb f5			            PUSH AF  
72fc 07			            RLCA                ;Calculate location  
72fd 07			            RLCA                ;  for bitmap data  
72fe 07			            RLCA                ;  = 8 x CharacterNumber  
72ff f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7301 cd 4a 72		            CALL fLCD_Inst      ;Write instruction to LCD  
7304 06 00		            LD   B, 0  
7306 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7307 cd 86 72		            CALL fLCD_Data      ;Write byte to display  
730a 13			            INC  DE             ;Point to next byte  
730b 04			            INC  B              ;Count bytes  
730c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
730e 28 f6		            JR   Z, Loop       ;No, so repeat  
7310 f1			            POP  AF  
7311 3c			            INC  A              ;Increment character number  
7312 c1			            POP  BC  
7313 c9			            RET  
7314			  
7314			  
7314			; **********************************************************************  
7314			; **  Private functions  
7314			; **********************************************************************  
7314			  
7314			; Write function to LCD  
7314			;   On entry: A = Function byte to be written  
7314			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7314 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7316 18 02		            JR   WrFunc  
7318 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
731a f5			WrFunc:     PUSH AF  
731b f5					push af  
731c 3a ce fb				ld a, (display_lcde1e2)  
731f fe 00				cp 0     ; e1  
7321 20 0f				jr nz, .wfea2	  
7323 f1					pop af  
7324 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7326 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7328 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
732a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
732c cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
732e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7330 18 0d			jr .wfskip  
7332 f1			.wfea2:		pop af  
7333 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7335 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7337 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7339 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
733b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
733d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
733f 3e 05		.wfskip:            LD  A, 5  
7341 cd 48 73		            CALL LCDDelay       ;Delay 5 ms to complete  
7344 f1			            POP  AF  
7345 c9			            RET  
7346			  
7346			  
7346			; Delay in milliseconds  
7346			;   On entry: A = Number of milliseconds delay  
7346			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7346 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7348 d5			LCDDelay:   PUSH DE  
7349 5f			            LD   E, A           ;Delay by 'A' ms  
734a 16 00		            LD   D, 0  
734c cd 7a 0c		            CALL aDelayInMS  
734f d1			            POP  DE  
7350 c9			            RET  
7351			  
7351			  
7351			testlcd:  
7351 3e 00			ld a, kLCD_Line1  
7353 cd ce 72			call fLCD_Pos  
7356 06 28			ld b, 40  
7358 11 86 73			ld de, .ttext1  
735b cd 19 72			call write_len_string  
735e			  
735e 3e 28			ld a, kLCD_Line2  
7360 cd ce 72			call fLCD_Pos  
7363 06 28			ld b, 40  
7365 11 af 73			ld de, .ttext2  
7368 cd 19 72			call write_len_string  
736b 3e 50			ld a, kLCD_Line3  
736d cd ce 72			call fLCD_Pos  
7370 06 28			ld b, 40  
7372 11 d8 73			ld de, .ttext3  
7375 cd 19 72			call write_len_string  
7378 3e 78			ld a, kLCD_Line4  
737a cd ce 72			call fLCD_Pos  
737d 06 28			ld b, 40  
737f 11 01 74			ld de, .ttext4  
7382 cd 19 72			call write_len_string  
7385			  
7385 76				halt  
7386			  
7386			  
7386 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
73af .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
73d8 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7401 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
742a			   
742a			  
742a			  
742a			; eof  
742a			  
# End of file firmware_lcd_4x40.asm
742a			;include "firmware_lcd_4x20.asm" 
742a			include "firmware_key_5x10.asm" 
742a			; 5 x 10 decade counter scanner  
742a			  
742a			  
742a			; TODO do cursor shape change for shift keys  
742a			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
742a			  
742a			  
742a			; bit mask for each scan column and row for teing the matrix  
742a			  
742a			  
742a			key_init:  
742a			  
742a			; SCMonAPI functions used  
742a			  
742a			; Alphanumeric LCD functions used  
742a			; no need to specify specific functions for this module  
742a			  
742a			  
742a 3e cf		            LD   A, 11001111b  
742c d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
742e			;            LD   A, 00000000b  
742e 3e 1f		            LD   A, 00011111b  
7430 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7432			  
7432			  
7432				; TODO Configure cursor shapes  
7432			  
7432				; Load cursor shapes   
7432 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7434 11 44 74		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7437 06 02		            LD   B, 2           ;Number of characters to define  
7439 cd fa 72		.DefLoop:   CALL fLCD_Def       ;Define custom character  
743c 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
743e			  
743e 3e 01				ld a, 1  
7440 32 c7 fb			ld (cursor_shape),a  
7443 c9				ret  
7444			  
7444			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7444			; Up to 8 custom characters can be defined  
7444			.cursor_shapes:      
7444			;; Character 0x00 = Normal  
7444 1f			            DB  11111b  
7445 1f			            DB  11111b  
7446 1f			            DB  11111b  
7447 1f			            DB  11111b  
7448 1f			            DB  11111b  
7449 1f			            DB  11111b  
744a 1f			            DB  11111b  
744b 1f			            DB  11111b  
744c			;; Character 0x01 = Modifier  
744c 1f			            DB  11111b  
744d 1b			            DB  11011b  
744e 1b			            DB  11011b  
744f 1b			            DB  11011b  
7450 1b			            DB  11011b  
7451 1f			            DB  11111b  
7452 1b			            DB  11011b  
7453 1f			            DB  11111b  
7454			  
7454			  
7454			  
7454			  
7454			; Display custom character 0  
7454			;            LD   A, kLCD_Line1+14  
7454			;            CALL fLCD_Pos       ;Position cursor to location in A  
7454			;            LD   A, 0  
7454			;            CALL fLCD_Data      ;Write character in A at cursor  
7454			  
7454			; Display custom character 1  
7454			;            LD   A, kLCD_Line2+14  
7454			;            CALL fLCD_Pos      ;Position cursor to location in A  
7454			;            LD   A, 1  
7454			;            CALL fLCD_Data     ;Write character in A at cursor  
7454			  
7454			; keyboard scanning   
7454			  
7454			; character in from keyboard  
7454			  
7454			; mapping for the pcb layout  
7454			  
7454			.matrix_to_char:  
7454 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
745f .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
746a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7475 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7480 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
748b			.matrix_to_shift:  
748b			  
748b .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7496 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
74a1 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
74ac 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
74b7 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
74c2			  
74c2			.matrix_to_symbolshift:  
74c2			  
74c2 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
74cd .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
74d8 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
74e3			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
74e3 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
74ee .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
74f9			  
74f9			  
74f9			  
74f9			; mapping for a simple straight through breadboard layout  
74f9			  
74f9			;.matrix_to_char:  
74f9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
74f9			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
74f9			;		db "asdfghjkl",KEY_CR,0  
74f9			;		db "qwertyuiop",0  
74f9			;		 db "1234567890",0  
74f9			;.matrix_to_shift:  
74f9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
74f9			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
74f9			;		db "ASDFGHJKL",KEY_CR,0  
74f9			;		db "QWERTYUIOP",0  
74f9			;		 db "!",'"',"#$%^&*()",0  
74f9			;.matrix_to_symbolshift:  
74f9			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
74f9			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
74f9			;		db "_?*fghjk=",KEY_CR,0  
74f9			;		db "-/+*[]{}@#",0  
74f9			;		 db "1234567890",0  
74f9			  
74f9			;.matrix_to_char: db "D#0*C987B654A321"  
74f9			  
74f9			  
74f9				  
74f9			  
74f9			; add cin and cin_wait  
74f9			  
74f9 cd 0a 75		cin_wait: 	call cin  
74fc						if DEBUG_KEYCINWAIT  
74fc							push af  
74fc							  
74fc							ld hl,key_repeat_ct  
74fc							ld (hl),a  
74fc							inc hl  
74fc							call hexout  
74fc							ld hl,key_repeat_ct+3  
74fc							ld a,0  
74fc							ld (hl),a  
74fc			  
74fc							    LD   A, kLCD_Line1+11  
74fc							    CALL fLCD_Pos       ;Position cursor to location in A  
74fc							    LD   DE, key_repeat_ct  
74fc							    ;LD   DE, MsgHello  
74fc							    CALL fLCD_Str       ;Display string pointed to by DE  
74fc			  
74fc			  
74fc			  
74fc							pop af  
74fc						endif  
74fc fe 00			cp 0  
74fe 28 f9			jr z, cin_wait   ; block until key press  
7500			  
7500							if DEBUG_KEYCINWAIT  
7500								push af  
7500			  
7500								ld a, 'A'	  
7500								ld hl,key_repeat_ct  
7500								ld (hl),a  
7500								inc hl  
7500								ld a,0  
7500								ld (hl),a  
7500			  
7500								    LD   A, kLCD_Line2+11  
7500								    CALL fLCD_Pos       ;Position cursor to location in A  
7500								    LD   DE, key_repeat_ct  
7500								    ;LD   DE, MsgHello  
7500								    CALL fLCD_Str       ;Display string pointed to by DE  
7500			  
7500							call delay500ms  
7500			  
7500								pop af  
7500							endif  
7500 f5				push af   ; save key pressed  
7501			  
7501			.cin_wait1:	  
7501							if DEBUG_KEYCINWAIT  
7501								push af  
7501			  
7501								ld a, 'b'	  
7501								ld hl,key_repeat_ct  
7501								ld (hl),a  
7501								inc hl  
7501								ld a,0  
7501								ld (hl),a  
7501			  
7501								    LD   A, kLCD_Line2+11  
7501								    CALL fLCD_Pos       ;Position cursor to location in A  
7501								    LD   DE, key_repeat_ct  
7501								    ;LD   DE, MsgHello  
7501								    CALL fLCD_Str       ;Display string pointed to by DE  
7501			  
7501			  
7501							call delay500ms  
7501			  
7501								pop af  
7501							endif  
7501			  
7501 cd 0a 75		call cin  
7504 fe 00			cp 0  
7506 20 f9			jr nz, .cin_wait1  	; wait for key release  
7508			if DEBUG_KEYCINWAIT  
7508				push af  
7508			  
7508				ld a, '3'	  
7508				ld hl,key_repeat_ct  
7508				ld (hl),a  
7508				inc hl  
7508				ld a,0  
7508				ld (hl),a  
7508			  
7508			            LD   A, kLCD_Line2+11  
7508			            CALL fLCD_Pos       ;Position cursor to location in A  
7508			            LD   DE, key_repeat_ct  
7508			            ;LD   DE, MsgHello  
7508			            CALL fLCD_Str       ;Display string pointed to by DE  
7508			  
7508			  
7508			call delay500ms  
7508			  
7508				pop af  
7508			endif  
7508			  
7508 f1				pop af   ; get key  
7509 c9				ret  
750a			  
750a			  
750a cd 1e 75		cin: 	call .mtoc  
750d			  
750d			if DEBUG_KEYCIN  
750d				push af  
750d				  
750d				ld hl,key_repeat_ct  
750d				ld (hl),a  
750d				inc hl  
750d				call hexout  
750d				ld hl,key_repeat_ct+3  
750d				ld a,0  
750d				ld (hl),a  
750d			  
750d			            LD   A, kLCD_Line3+15  
750d			            CALL fLCD_Pos       ;Position cursor to location in A  
750d			            LD   DE, key_repeat_ct  
750d			            ;LD   DE, MsgHello  
750d			            CALL fLCD_Str       ;Display string pointed to by DE  
750d			  
750d			  
750d			call delay500ms  
750d			  
750d				pop af  
750d			endif  
750d			  
750d			  
750d				; no key held  
750d fe 00			cp 0  
750f c8				ret z  
7510			  
7510			if DEBUG_KEYCIN  
7510				push af  
7510			  
7510				ld a, '1'	  
7510				ld hl,key_repeat_ct  
7510				ld (hl),a  
7510				inc hl  
7510				ld a,0  
7510				ld (hl),a  
7510			  
7510			            LD   A, kLCD_Line4+15  
7510			            CALL fLCD_Pos       ;Position cursor to location in A  
7510			            LD   DE, key_repeat_ct  
7510			            ;LD   DE, MsgHello  
7510			            CALL fLCD_Str       ;Display string pointed to by DE  
7510			  
7510			  
7510			call delay500ms  
7510			  
7510				pop af  
7510			endif  
7510			  
7510				; stop key bounce  
7510			  
7510 32 88 fe			ld (key_held),a		 ; save it  
7513 47				ld b, a  
7514			  
7514 c5			.cina1:	push bc  
7515			if DEBUG_KEYCIN  
7515				push af  
7515			  
7515				ld hl,key_repeat_ct  
7515				inc hl  
7515				call hexout  
7515				ld hl,key_repeat_ct+3  
7515				ld a,0  
7515				ld (hl),a  
7515				ld hl,key_repeat_ct  
7515				ld a, '2'	  
7515				ld (hl),a  
7515			  
7515			            LD   A, kLCD_Line4+15  
7515			            CALL fLCD_Pos       ;Position cursor to location in A  
7515			            LD   DE, key_repeat_ct  
7515			            ;LD   DE, MsgHello  
7515			            CALL fLCD_Str       ;Display string pointed to by DE  
7515			  
7515				pop af  
7515			endif  
7515 cd 1e 75			call .mtoc  
7518 c1				pop bc  
7519 b8				cp b  
751a 28 f8			jr z, .cina1  
751c 78				ld a,b		  
751d			if DEBUG_KEYCIN  
751d				push af  
751d			  
751d				ld hl,key_repeat_ct  
751d				inc hl  
751d				call hexout  
751d				ld hl,key_repeat_ct+3  
751d				ld a,0  
751d				ld (hl),a  
751d				ld hl,key_repeat_ct  
751d				ld a, '3'	  
751d				ld (hl),a  
751d			  
751d			            LD   A, kLCD_Line4+15  
751d			            CALL fLCD_Pos       ;Position cursor to location in A  
751d			            LD   DE, key_repeat_ct  
751d			            ;LD   DE, MsgHello  
751d			            CALL fLCD_Str       ;Display string pointed to by DE  
751d			  
751d				pop af  
751d			endif  
751d c9				ret  
751e			  
751e			; detect keyboard modifier key press and apply new overlay to the face key held  
751e			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
751e			  
751e			;.cin_map_modifier:   
751e			;	ld a, (hl)  
751e			;	and 255  
751e			;	ret NZ		; modifier key not flagged  
751e			;  
751e			;	; get key face  
751e			;  
751e			;	ld b,(key_face_held)  
751e			;  
751e			;	ld b, key_cols * key_rows  
751e			;  
751e			;	push de  
751e			;	pop hl  
751e			;  
751e			;.mmod1: ld a,(hl)   ; get map test  
751e			;	cp b  
751e			;	jr z, .mmod2  
751e			;  
751e			;  
751e			;  
751e			;.mmod2: inc hl    ;   
751e			;  
751e			;	  
751e			;  
751e			;	  
751e			;  
751e			;	ld hl,key_actual_pressed  
751e			;	ld (hl),a,  
751e			;	ret  
751e			  
751e			; map matrix key held to char on face of key  
751e			  
751e			.mtoc:  
751e			  
751e			; test decade counter strobes  
751e			  
751e			;.decadetest1:  
751e			  
751e			; reset counter  
751e			;ld a, 128  
751e			;out (portbdata),a  
751e			  
751e			  
751e			;ld b, 5  
751e			;.dec1:  
751e			;ld a, 0  
751e			;out (portbdata),a  
751e			;call delay1s  
751e			  
751e			;ld a, 32  
751e			;out (portbdata),a  
751e			;call delay1s  
751e			;call delay1s  
751e			;call delay1s  
751e			;  
751e			;ld a, 64+32  
751e			;out (portbdata),a  
751e			;call delay1s  
751e			;;djnz .dec1  
751e			;  
751e			;jp .decadetest1  
751e			  
751e			  
751e			  
751e			  
751e			  
751e			  
751e			  
751e			  
751e			  
751e			  
751e				; scan keyboard matrix and generate raw scan map  
751e cd b1 75			call matrix  
7521			  
7521				; reuse c bit 0 left modifer button - ie shift  
7521			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7521				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7521			  
7521 0e 00			ld c, 0  
7523			  
7523				; TODO set flags for modifer key presses   
7523				; TODO do a search for modifer key...  
7523			  
7523				;ld hl,keyscan_table_row4  
7523 21 e7 fe			ld hl,keyscan_table_row2  
7526			  
7526 7e				ld a, (hl)  
7527 fe 23			cp '#'  
7529 20 07			jr nz, .nextmodcheck  
752b cb c1			set 0, c  
752d 21 8b 74			ld hl, .matrix_to_shift  
7530 18 21			jr .dokeymap  
7532				; TODO for now igonre  
7532			.nextmodcheck:  
7532 21 dc fe			ld hl,keyscan_table_row3  
7535			  
7535 7e				ld a, (hl)  
7536 fe 23			cp '#'  
7538 20 07			jr nz, .nextmodcheck2  
753a cb c9			set 1, c   
753c 21 c2 74			ld hl, .matrix_to_symbolshift  
753f 18 12			jr .dokeymap  
7541			.nextmodcheck2:  
7541 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7544			  
7544 7e				ld a, (hl)  
7545 fe 23			cp '#'  
7547 20 07			jr nz, .donemodcheck  
7549 cb c9			set 1, c   
754b 21 8b 74			ld hl, .matrix_to_shift  
754e 18 03			jr .dokeymap  
7550			  
7550				; no modifer found so just map to normal keys  
7550				; get mtoc map matrix to respective keys  
7550			;	ld hl, .matrix_to_char  
7550			;	ld hl, .matrix_to_char  
7550			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7550			;	ld a, KEY_SHIFT  
7550			;	call findchar  
7550			;  
7550			;	; got offset to key modifer in b  
7550			;  
7550			;	ld hl,keyscan_table_row5  
7550			;  
7550			;	ld a,b  
7550			;	call addatohl  
7550			;	ld a,(hl)  
7550			;  
7550			;	cp '#'  
7550			;	jr nz, .nextmodcheck  
7550			;	set 0, c  
7550			;	ld hl, .matrix_to_char  
7550			;	jr .dokeymap  
7550			;	; TODO for now igonre  
7550			;.nextmodcheck:  
7550			;	ld hl, .matrix_to_symbolshift  
7550			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7550			;	ld a, KEY_SYMBOLSHIFT  
7550			;	call findchar  
7550			;  
7550			;  
7550			;	; got offset to key modifer in b  
7550			;  
7550			;	ld hl,keyscan_table_row5  
7550			;  
7550			;	ld a,b  
7550			;	call addatohl  
7550			;	ld a,(hl)  
7550			;  
7550			;	cp '#'  
7550			;	jr nz, .donemodcheck  
7550			;	set 1, c   
7550			;	ld hl, .matrix_to_symbolshift  
7550			;	jr .dokeymap  
7550			  
7550			  
7550			  
7550			.donemodcheck:  
7550				; no modifer found so just map to normal keys  
7550				; get mtoc map matrix to respective keys  
7550 21 54 74			ld hl, .matrix_to_char  
7553			  
7553			.dokeymap:  
7553				;ld (key_fa), c   
7553 cd 6c 75			call .mapkeys  
7556			  
7556			  
7556			if DEBUG_KEY  
7556			  
7556			; Display text on first line  
7556			            LD   A, kLCD_Line1  
7556			            CALL fLCD_Pos       ;Position cursor to location in A  
7556			            LD   DE, keyscan_table_row1  
7556			            ;LD   DE, MsgHello  
7556			            CALL fLCD_Str       ;Display string pointed to by DE  
7556			  
7556			; Display text on second line  
7556			            LD   A, kLCD_Line2  
7556			            CALL fLCD_Pos       ;Position cursor to location in A  
7556			            LD   DE, keyscan_table_row2  
7556			            CALL fLCD_Str       ;Display string pointed to by DE  
7556			            LD   A, kLCD_Line3  
7556			            CALL fLCD_Pos       ;Position cursor to location in A  
7556			            LD   DE, keyscan_table_row3  
7556			            CALL fLCD_Str       ;Display string pointed to by DE  
7556			            LD   A, kLCD_Line4  
7556			            CALL fLCD_Pos       ;Position cursor to location in A  
7556			            LD   DE, keyscan_table_row4  
7556			            CALL fLCD_Str       ;Display string pointed to by DE  
7556			            LD   A, kLCD_Line1+10  
7556			            CALL fLCD_Pos       ;Position cursor to location in A  
7556			            LD   DE, keyscan_table_row5  
7556			            CALL fLCD_Str       ;Display string pointed to by DE  
7556			  
7556				;call delay250ms  
7556			endif  
7556			;	jp testkey  
7556			  
7556			; get first char reported  
7556			  
7556 21 c6 fe			ld hl,keyscan_table_row5  
7559			  
7559				;ld b, 46   ; 30 keys to remap + 8 nulls   
7559 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
755b			.findkey:  
755b 7e				ld a,(hl)  
755c fe 00			cp 0  
755e 28 04			jr z, .nextkey  
7560 fe 7e			cp KEY_MATRIX_NO_PRESS  
7562 20 06			jr nz, .foundkey  
7564			.nextkey:  
7564 23				inc hl  
7565 10 f4			djnz .findkey  
7567 3e 00			ld a,0  
7569 c9				ret  
756a			.foundkey:  
756a 7e				ld a,(hl)  
756b c9				ret  
756c				  
756c			  
756c			; convert the raw key map given hl for destination key  
756c			.mapkeys:  
756c 11 c6 fe			ld de,keyscan_table_row5  
756f			  
756f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7571			.remap:  
7571 1a				ld a,(de)  
7572 fe 23			cp '#'  
7574 20 02			jr nz, .remapnext  
7576				;CALLMONITOR  
7576 7e				ld a,(hl)  
7577 12				ld (de),a  
7578			  
7578			  
7578			  
7578			.remapnext:  
7578 23				inc hl  
7579 13				inc de  
757a 10 f5			djnz .remap  
757c				  
757c c9				ret  
757d			  
757d			  
757d			  
757d			.mtocold2:  
757d			  
757d			;	; flag if key D is held down and remove from reporting  
757d			;	ld bc, .key_map_fd    
757d			;	ld hl, keyscan_table  
757d			;	ld de, key_fd  
757d			;	call .key_shift_hold  
757d			;	cp 255  
757d			;	jr z, .cinmap  
757d			;	; flag if key C is held down and remove from reporting  
757d			;	ld bc, .key_map_fc    
757d			;	ld hl, keyscan_table+key_cols  
757d			;	ld de, key_fc  
757d			;	call .key_shift_hold  
757d			;	cp 255  
757d			;	jr z, .cinmap  
757d			;	; flag if key B is held down and remove from reporting  
757d			;	ld bc, .key_map_fb    
757d			;	ld hl, keyscan_table+(key_cols*2)  
757d			;	ld de, key_fb  
757d			;	call .key_shift_hold  
757d			;	cp 255  
757d			;	jr z, .cinmap  
757d			;	; flag if key A is held down and remove from reporting  
757d			;	ld bc, .key_map_fa    
757d			;	ld hl, keyscan_table+(key_cols*3)  
757d			;	ld de, key_fa  
757d			;	call .key_shift_hold  
757d			;	cp 255  
757d			;	jr z, .cinmap  
757d			  
757d 11 54 74			ld de, .matrix_to_char  
7580			  
7580			  
7580			.cinmap1:   
7580				if DEBUG_KEY  
7580			            LD   A, kLCD_Line4  
7580			            CALL fLCD_Pos       ;Position cursor to location in A  
7580					push de  
7580			            LD   DE, keyscan_table  
7580			            CALL fLCD_Str       ;Display string pointed to by DE  
7580					pop de  
7580				endif  
7580			  
7580				; scan key matrix table for any held key  
7580			  
7580				; de holds either the default matrix or one selected above  
7580			  
7580 21 93 fe			ld hl, keyscan_table  
7583 06 32			ld b,key_cols*key_rows  
7585			  
7585 7e			.cin11:	ld a,(hl)  
7586 fe 23			cp '#'  
7588 28 08			jr z, .cinhit1  
758a 23				inc hl  
758b 13				inc de  
758c 05				dec b  
758d 20 f6			jr nz, .cin11  
758f				; no key found held  
758f 3e 00			ld a,0  
7591 c9				ret  
7592 d5			.cinhit1: push de  
7593 e1				pop hl  
7594 7e				ld a,(hl)  
7595 c9				ret  
7596			  
7596			; flag a control key is held   
7596			; hl is key pin, de is flag indicator  
7596			  
7596			.key_shift_hold1:  
7596 c5				push bc  
7597 3e 01			ld a, 1  
7599 32 c7 fb			ld (cursor_shape),a  
759c 06 00			ld b, 0  
759e 7e				ld a, (hl)  
759f fe 2e			cp '.'  
75a1 28 0a			jr z, .key_shift11  
75a3 06 ff			ld b, 255  
75a5 3e 2b			ld a, '+'    ; hide key from later scans  
75a7 77				ld (hl),a  
75a8 3e 02			ld a, 2  
75aa 32 c7 fb			ld (cursor_shape),a  
75ad			.key_shift11:  
75ad				; write flag indicator  
75ad 78				ld a,b  
75ae 12				ld (de),a  
75af			  
75af d1				pop de    ; de now holds the key map ptr  
75b0 c9				ret  
75b1			  
75b1				  
75b1			  
75b1			; scans keyboard matrix and flags key press in memory array	  
75b1				  
75b1			matrix:  
75b1				;call matrix  
75b1				; TODO optimise the code....  
75b1			  
75b1			  
75b1			;ld hl, keyscan_table_row1  
75b1			;ld de, keyscan_table_row1+1  
75b1			;ld bc,46  
75b1			;ld a,KEY_MATRIX_NO_PRESS  
75b1			;ldir  
75b1			  
75b1			  
75b1			  
75b1			; reset counter  
75b1 3e 80		ld a, 128  
75b3 d3 c1		out (portbdata),a  
75b5			  
75b5 06 0a		ld b, 10  
75b7 0e 00		ld c, 0       ; current clock toggle  
75b9			  
75b9			.colscan:  
75b9			  
75b9			; set current column  
75b9			; disable clock enable and set clock low  
75b9			  
75b9			;ld a, 0  
75b9			;out (portbdata),a  
75b9			  
75b9			; For each column scan for switches  
75b9			  
75b9 c5			push bc  
75ba 21 89 fe		ld hl, keyscan_scancol  
75bd cd c6 76		call .rowscan  
75c0 c1			pop bc  
75c1			  
75c1			  
75c1			; get back current column  
75c1			  
75c1			; translate the row scan  
75c1			  
75c1			;   
75c1			; row 1  
75c1			  
75c1 78			ld a,b  
75c2			  
75c2 21 fc fe		LD   hl, keyscan_table_row1+10  
75c5			  
75c5 cd 5e 0f		call subafromhl  
75c8			;call addatohl  
75c8			  
75c8 11 89 fe		ld de, keyscan_scancol  
75cb			  
75cb 1a			ld a,(de)  
75cc 77			ld (hl),a  
75cd			  
75cd			  
75cd			  
75cd			  
75cd			; row 2  
75cd			  
75cd 78			ld a,b  
75ce			  
75ce 21 f1 fe		LD   hl, keyscan_table_row2+10  
75d1			  
75d1			;call addatohl  
75d1 cd 5e 0f		call subafromhl  
75d4			  
75d4			  
75d4 11 8a fe		ld de, keyscan_scancol+1  
75d7			  
75d7 1a			ld a,(de)  
75d8 77			ld (hl),a  
75d9			  
75d9			  
75d9			; row 3  
75d9			  
75d9 78			ld a,b  
75da			  
75da 21 e6 fe		LD   hl, keyscan_table_row3+10  
75dd			  
75dd			;call addatohl  
75dd cd 5e 0f		call subafromhl  
75e0			  
75e0 11 8b fe		ld de, keyscan_scancol+2  
75e3			  
75e3 1a			ld a,(de)  
75e4 77			ld (hl),a  
75e5			  
75e5			  
75e5			  
75e5			; row 4  
75e5			  
75e5 78			ld a,b  
75e6			  
75e6 21 db fe		LD   hl, keyscan_table_row4+10  
75e9			  
75e9			;call addatohl  
75e9 cd 5e 0f		call subafromhl  
75ec			  
75ec 11 8c fe		ld de, keyscan_scancol+3  
75ef			  
75ef 1a			ld a,(de)  
75f0 77			ld (hl),a  
75f1			  
75f1			; row 5  
75f1			  
75f1 78			ld a,b  
75f2			  
75f2 21 d0 fe		LD   hl, keyscan_table_row5+10  
75f5			  
75f5			;call addatohl  
75f5 cd 5e 0f		call subafromhl  
75f8			  
75f8 11 8d fe		ld de, keyscan_scancol+4  
75fb			  
75fb 1a			ld a,(de)  
75fc 77			ld (hl),a  
75fd			  
75fd			; handshake next column  
75fd			  
75fd			  
75fd 3e 40		ld a, 64  
75ff d3 c1		out (portbdata),a  
7601			  
7601 3e 00		ld a, 0  
7603 d3 c1		out (portbdata),a  
7605			  
7605			; toggle clk and move to next column  
7605			;ld a, 64  
7605			;cp c  
7605			;  
7605			;jr z, .coltoglow  
7605			;ld c, a  
7605			;jr .coltog  
7605			;.coltoglow:  
7605			;ld c, 0  
7605			;.coltog:  
7605			;ld a, c  
7605			;out (portbdata),a  
7605			  
7605 10 b2		djnz .colscan  
7607			  
7607 3e 0a		ld a,10  
7609 21 f2 fe		LD   hl, keyscan_table_row1  
760c cd 4c 0f		call addatohl  
760f 3e 00		ld a, 0  
7611 77			ld (hl), a  
7612			  
7612			  
7612 3e 0a		ld a,10  
7614 21 e7 fe		LD   hl, keyscan_table_row2  
7617 cd 4c 0f		call addatohl  
761a 3e 00		ld a, 0  
761c 77			ld (hl), a  
761d			  
761d 3e 0a		ld a,10  
761f 21 dc fe		LD   hl, keyscan_table_row3  
7622 cd 4c 0f		call addatohl  
7625 3e 00		ld a, 0  
7627 77			ld (hl), a  
7628			  
7628 3e 0a		ld a,10  
762a 21 d1 fe		LD   hl, keyscan_table_row4  
762d cd 4c 0f		call addatohl  
7630 3e 00		ld a, 0  
7632 77			ld (hl), a  
7633			  
7633 3e 0a		ld a,10  
7635 21 c6 fe		LD   hl, keyscan_table_row5  
7638 cd 4c 0f		call addatohl  
763b 3e 00		ld a, 0  
763d 77			ld (hl), a  
763e			  
763e			if DEBUG_KEY_MATRIX  
763e			  
763e			; Display text on first line  
763e			            LD   A, kLCD_Line1  
763e			            CALL fLCD_Pos       ;Position cursor to location in A  
763e			            LD   DE, keyscan_table_row1  
763e			            ;LD   DE, MsgHello  
763e			            CALL fLCD_Str       ;Display string pointed to by DE  
763e			  
763e			; Display text on second line  
763e			            LD   A, kLCD_Line2  
763e			            CALL fLCD_Pos       ;Position cursor to location in A  
763e			            LD   DE, keyscan_table_row2  
763e			            CALL fLCD_Str       ;Display string pointed to by DE  
763e			            LD   A, kLCD_Line3  
763e			            CALL fLCD_Pos       ;Position cursor to location in A  
763e			            LD   DE, keyscan_table_row3  
763e			            CALL fLCD_Str       ;Display string pointed to by DE  
763e			            LD   A, kLCD_Line4  
763e			            CALL fLCD_Pos       ;Position cursor to location in A  
763e			            LD   DE, keyscan_table_row4  
763e			            CALL fLCD_Str       ;Display string pointed to by DE  
763e			            LD   A, kLCD_Line4+10  
763e			            CALL fLCD_Pos       ;Position cursor to location in A  
763e			            LD   DE, keyscan_table_row5  
763e			            CALL fLCD_Str       ;Display string pointed to by DE  
763e			  
763e			;call delay250ms  
763e				jp matrix  
763e			endif  
763e c9			ret  
763f			  
763f			; using decade counter....  
763f			  
763f			  
763f			; TODO reset decade counter to start of scan  
763f			  
763f			; reset 15  
763f			; clock 14  
763f			; ce 13  
763f			  
763f			; 1 - q5  
763f			; 2 - q1  
763f			; 3 - q0  
763f			; 4 - q2  
763f			; 5 - q6  
763f			; 6 - q7  
763f			; 7 - q3  
763f			; 8 - vss  
763f			; 9 - q8  
763f			; 10 - q4  
763f			; 11 - q9  
763f			; 12 - cout  
763f			; 16 - vdd  
763f			  
763f			; clock      ce       reset     output  
763f			; 0          x        0         n  
763f			; x          1        0         n  
763f			; x          x        1         q0  
763f			; rising     0        0         n+1  
763f			; falling    x        0         n  
763f			; x          rising   0         n  
763f			; 1          falling  0         x+1  
763f			;  
763f			; x = dont care, if n < 5 carry = 1 otherwise 0  
763f			  
763f			;   
763f			; reset   
763f			; 13=0, 14=0, 15=1 .. 15=0  
763f			;  
763f			; handshake line  
763f			; 14=1.... read line 14=0  
763f			  
763f			  
763f			  
763f			  
763f			  
763f			; TODO hand shake clock for next column scan  
763f			; TODO detect each row  
763f			  
763f			  
763f			  
763f			  
763f			; reset 128  
763f			; clock 64  
763f			; ce 32  
763f			  
763f			  
763f			.cyclestart:  
763f			  
763f			; reset counter  
763f 3e 80		ld a, 128  
7641 d3 c1		out (portbdata),a  
7643			  
7643			; loop leds  
7643 06 0a		ld b,10  
7645			  
7645			.cycle1:  
7645 c5			push bc  
7646 3e 00		ld a, 0  
7648 d3 c1		out (portbdata),a  
764a cd 89 0c		call delay250ms  
764d			  
764d 3e 40		ld a, 64  
764f d3 c1		out (portbdata),a  
7651 cd 89 0c		call delay250ms  
7654			  
7654 3e 00		ld a, 0  
7656 d3 c1		out (portbdata),a  
7658 cd 89 0c		call delay250ms  
765b			  
765b c1			pop bc  
765c 10 e7		djnz .cycle1  
765e			  
765e			  
765e 18 df		jr .cyclestart  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			; map matrix key held to char on face of key  
7660			  
7660			;.mtocold:  
7660			;  
7660			;  
7660			;; reset counter  
7660			;ld a, 128  
7660			;out (portbdata),a  
7660			;  
7660			;  
7660			;; scan keyboard row 1  
7660			;ld a, 0  
7660			;out (portbdata),a  
7660			;;ld a, 64  
7660			;;out (portbdata),a  
7660			;  
7660			;  
7660			;	ld a, 128  
7660			;	ld hl, keyscan_table  
7660			;	call .rowscan  
7660			;  
7660			;;ld a, 0  
7660			;;out (portbdata),a  
7660			;ld a, 64  
7660			;out (portbdata),a  
7660			;  
7660			;	ld a, 64  
7660			;	ld hl, keyscan_table+key_cols  
7660			;	call .rowscan  
7660			;  
7660			;ld a, 0  
7660			;out (portbdata),a  
7660			;;ld a, 64  
7660			;;out (portbdata),a  
7660			;	ld a, 32  
7660			;	ld hl, keyscan_table+(key_cols*2)  
7660			;	call .rowscan  
7660			;  
7660			;  
7660			;;ld a, 0  
7660			;;out (portbdata),a  
7660			;ld a, 64  
7660			;out (portbdata),a  
7660			;  
7660			;	ld a, 16  
7660			;	ld hl, keyscan_table+(key_cols*3)  
7660			;	call .rowscan  
7660			;  
7660			;  
7660			;	; flag if key D is held down and remove from reporting  
7660			;	ld bc, .key_map_fd    
7660			;	ld hl, keyscan_table  
7660			;	ld de, key_fd  
7660			;	call .key_shift_hold  
7660			;	cp 255  
7660			;	jr z, .cinmap  
7660			;	; flag if key C is held down and remove from reporting  
7660			;	ld bc, .key_map_fc    
7660			;	ld hl, keyscan_table+key_cols  
7660			;	ld de, key_fc  
7660			;	call .key_shift_hold  
7660			;	cp 255  
7660			;	jr z, .cinmap  
7660			;	; flag if key B is held down and remove from reporting  
7660			;	ld bc, .key_map_fb    
7660			;	ld hl, keyscan_table+(key_cols*2)  
7660			;	ld de, key_fb  
7660			;	call .key_shift_hold  
7660			;	cp 255  
7660			;	jr z, .cinmap  
7660			;	; flag if key A is held down and remove from reporting  
7660			;	ld bc, .key_map_fa    
7660			;	ld hl, keyscan_table+(key_cols*3)  
7660			;	ld de, key_fa  
7660			;	call .key_shift_hold  
7660			;	cp 255  
7660			;	jr z, .cinmap  
7660			;  
7660			;	ld de, .matrix_to_char  
7660			;  
7660			;  
7660			;.cinmap:   
7660			;	if DEBUG_KEY  
7660			;            LD   A, kLCD_Line4  
7660			;            CALL fLCD_Pos       ;Position cursor to location in A  
7660			;		push de  
7660			;            LD   DE, keyscan_table  
7660			;            CALL fLCD_Str       ;Display string pointed to by DE  
7660			;		pop de  
7660			;	endif  
7660			  
7660				; scan key matrix table for any held key  
7660			  
7660				; de holds either the default matrix or one selected above  
7660			  
7660			;	ld hl, keyscan_table  
7660			;	ld b,key_cols*key_rows  
7660			;  
7660			;.cin1:	ld a,(hl)  
7660			;	cp '#'  
7660			;	jr z, .cinhit  
7660			;	inc hl  
7660			;	inc de  
7660			;	dec b  
7660			;	jr nz, .cin1  
7660			;	; no key found held  
7660			;	ld a,0  
7660			;	ret  
7660			;.cinhit: push de  
7660			;	pop hl  
7660			;	ld a,(hl)  
7660			;	ret  
7660			  
7660			; flag a control key is held   
7660			; hl is key pin, de is flag indicator  
7660			  
7660			;.key_shift_hold:  
7660			;	push bc  
7660			;	ld a, 1  
7660			;	ld (cursor_shape),a  
7660			;	ld b, 0  
7660			;	ld a, (hl)  
7660			;	cp '.'  
7660			;	jr z, .key_shift1  
7660			;	ld b, 255  
7660			;	ld a, '+'    ; hide key from later scans  
7660			;	ld (hl),a  
7660			;	ld a, 2  
7660			;	ld (cursor_shape),a  
7660			;.key_shift1:  
7660			;	; write flag indicator  
7660			;	ld a,b  
7660			;	ld (de),a  
7660			;  
7660			;	pop de    ; de now holds the key map ptr  
7660			;	ret  
7660			  
7660				  
7660				  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			  
7660			;	push hl  
7660			;	push de  
7660			;	push bc  
7660			;	call keyscan  
7660			;	; map key matrix to ascii value of key face  
7660			;  
7660			;	ld hl, key_face_map  
7660			;	ld de, keyscan_table  
7660			;  
7660			;	; get how many keys to look at  
7660			;	ld b, keyscan_table_len  
7660			;	  
7660			;  
7660			;	; at this stage fall out on first key hit  
7660			;	; TODO handle multiple key press  
7660			;  
7660			;map1:	ld a,(hl)  
7660			;	cp '#'  
7660			;	jr z, keyhit  
7660			;	inc hl  
7660			;	inc de  
7660			;	dec b  
7660			;	jr nz, map1  
7660			;nohit:	ld a, 0  
7660			;	jr keydone  
7660			;keyhit: push de  
7660			;	pop hl  
7660			;	ld a,(hl)  
7660			;keydone:  
7660			;	push bc  
7660			;	push de  
7660			; 	push hl  
7660			;	ret   
7660			;  
7660			  
7660			  
7660			  
7660			  
7660			; scan physical key matrix  
7660			  
7660			  
7660			;keyscan:  
7660			;  
7660			;; for each key_row use keyscanr bit mask for out  
7660			;; then read in for keyscanc bitmask  
7660			;; save result of row scan to keyscantable  
7660			;  
7660			;; scan keyboard row 1  
7660			;  
7660			;	ld b, key_rows  
7660			;	ld hl, key_scanr  
7660			;	ld de, keyscan_table  
7660			;  
7660			;rowloop:  
7660			;  
7660			;	ld a,(hl)		; out bit mask to energise keyboard row  
7660			;	call rowscan  
7660			;	inc hl  
7660			;	dec b  
7660			;	jr nz, rowloop  
7660			;  
7660			;	ret  
7660			;  
7660			;  
7660			;; pass a out bitmask, b row number  
7660			;arowscan:   
7660			;	push bc  
7660			;  
7660			;	ld d, b  
7660			;  
7660			;	; calculate buffer location for this row  
7660			;  
7660			;	ld hl, keyscan_table	  
7660			;kbufr:  ld e, key_cols  
7660			;kbufc:	inc hl  
7660			;	dec e  
7660			;	jr nz, kbufc  
7660			;	dec d  
7660			;	jr nz, kbufr  
7660			;  
7660			;	; energise row and read columns  
7660			;  
7660			;	out (portbdata),a  
7660			;	in a,(portbdata)  
7660			;	ld c,a  
7660			;  
7660			;  
7660			;	; save buffer loc  
7660			;  
7660			;	ld (keybufptr), hl  
7660			;  
7660			;	ld hl, key_scanc  
7660			;	ld d, key_cols  
7660			;  
7660			;	; for each column check each bit mask  
7660			;  
7660			;colloop:  
7660			;	  
7660			;  
7660			;	; reset flags for the row   
7660			;  
7660			;	ld b,'.'  
7660			;	and (hl)  
7660			;	jr z, maskskip  
7660			;	ld b,'#'  
7660			;maskskip:  
7660			;	; save  key state  
7660			;	push hl  
7660			;	ld hl, (keybufptr)  
7660			;	ld (hl), b  
7660			;	inc hl  
7660			;	ld (keybufptr), hl  
7660			;  
7660			;	; move to next bit mask  
7660			;	pop hl  
7660			;	inc hl  
7660			;  
7660			;	dec d  
7660			;	jr nz, colloop  
7660			;  
7660			;	ret  
7660			;  
7660			;  
7660			;;  
7660			; lcd functions  
7660			;  
7660			;  
7660			  
7660			;if DEBUG_KEY_MATRIX  
7660			  
7660			; test function to display hardware view of matrix state  
7660			  
7660			matrixold:  
7660			  
7660			  
7660			  
7660			; reset counter  
7660 3e 80		ld a, 128  
7662 d3 c1		out (portbdata),a  
7664			; scan keyboard row 1  
7664 3e 00		ld a, 0  
7666 d3 c1		out (portbdata),a  
7668			;ld a, 64  
7668			;out (portbdata),a  
7668 3e 80			ld a, 128  
766a 21 f2 fe			ld hl, keyscan_table_row1  
766d cd c6 76			call .rowscan  
7670			  
7670			;ld a, 0  
7670			;out (portbdata),a  
7670 3e 40		ld a, 64  
7672 d3 c1		out (portbdata),a  
7674 3e 40			ld a, 64  
7676 21 e7 fe			ld hl, keyscan_table_row2  
7679 cd c6 76			call .rowscan  
767c			  
767c 3e 00		ld a, 0  
767e d3 c1		out (portbdata),a  
7680			;ld a, 64  
7680			;out (portbdata),a  
7680 3e 20			ld a, 32  
7682 21 dc fe			ld hl, keyscan_table_row3  
7685 cd c6 76			call .rowscan  
7688			  
7688			;ld a, 0  
7688			;out (portbdata),a  
7688 3e 40		ld a, 64  
768a d3 c1		out (portbdata),a  
768c 3e 10			ld a, 16  
768e 21 d1 fe			ld hl, keyscan_table_row4  
7691 cd c6 76			call .rowscan  
7694			  
7694			; Display text on first line  
7694 3e 00		            LD   A, kLCD_Line1  
7696 cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7699 11 f2 fe		            LD   DE, keyscan_table_row1  
769c			            ;LD   DE, MsgHello  
769c cd f0 72		            CALL fLCD_Str       ;Display string pointed to by DE  
769f			  
769f			; Display text on second line  
769f 3e 28		            LD   A, kLCD_Line2  
76a1 cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
76a4 11 e7 fe		            LD   DE, keyscan_table_row2  
76a7 cd f0 72		            CALL fLCD_Str       ;Display string pointed to by DE  
76aa 3e 50		            LD   A, kLCD_Line3  
76ac cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
76af 11 dc fe		            LD   DE, keyscan_table_row3  
76b2 cd f0 72		            CALL fLCD_Str       ;Display string pointed to by DE  
76b5 3e 78		            LD   A, kLCD_Line4  
76b7 cd ce 72		            CALL fLCD_Pos       ;Position cursor to location in A  
76ba 11 d1 fe		            LD   DE, keyscan_table_row4  
76bd cd f0 72		            CALL fLCD_Str       ;Display string pointed to by DE  
76c0			  
76c0 cd 89 0c			call delay250ms  
76c3 c3 b1 75			jp matrix  
76c6			  
76c6			; pass de as row display flags  
76c6			.rowscan:   
76c6			;	out (portbdata),a  
76c6 db c1			in a,(portbdata)  
76c8 4f				ld c,a  
76c9				; reset flags for the row   
76c9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
76cb e6 01			and 1  
76cd 28 02			jr z, .p1on  
76cf 06 23			ld b,'#'  
76d1			.p1on:  
76d1 70				ld (hl), b  
76d2 23				inc hl  
76d3			  
76d3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
76d5 79				ld a,c  
76d6 e6 02			and 2  
76d8			;	bit 0,a  
76d8 28 02			jr z, .p2on  
76da 06 23			ld b,'#'  
76dc			.p2on:  
76dc 70				ld (hl), b  
76dd 23				inc hl  
76de			;  
76de 06 7e			ld b,KEY_MATRIX_NO_PRESS  
76e0 79				ld a,c  
76e1 e6 04			and 4  
76e3			;;	bit 0,a  
76e3 28 02			jr z, .p3on  
76e5 06 23			ld b,'#'  
76e7			.p3on:  
76e7 70				ld (hl), b  
76e8 23				inc hl  
76e9			;;  
76e9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
76eb			;;	bit 0,a  
76eb 79				ld a,c  
76ec e6 08			and 8  
76ee 28 02			jr z, .p4on  
76f0 06 23			ld b,'#'  
76f2			.p4on:  
76f2 70				ld (hl), b  
76f3 23				inc hl  
76f4			  
76f4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
76f6			;;	bit 0,a  
76f6 79				ld a,c  
76f7 e6 10			and 16  
76f9 28 02			jr z, .p5on  
76fb 06 23			ld b,'#'  
76fd			.p5on:  
76fd 70				ld (hl), b  
76fe 23				inc hl  
76ff			; zero term  
76ff 06 00			ld b,0  
7701 70				ld (hl), b  
7702			  
7702 c9			.rscandone: ret  
7703			  
7703			;addatohl:  
7703			;  
7703			 ;add   a, l    ; A = A+L  
7703			  ;  ld    l, a    ; L = A+L  
7703			   ; adc   a, h    ; A = A+L+H+carry  
7703			   ; sub   l       ; A = H+carry  
7703			   ; ld    h, a    ; H = H+carry  
7703			  
7703			;ret  
7703			; eof  
# End of file firmware_key_5x10.asm
7703			;include "firmware_key_4x10.asm" 
7703			 
7703			heap_size:    equ heap_end - heap_start 
7703			;eof 
# End of file os_mega.asm
7703
